// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 690 0 0
// InitGlobalVariables ;
  19: CALL 86078 0 0
// InitMacro ;
  23: CALL 55452 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 48380 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 48380 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 48380 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 4
 128: PUSH
 129: LD_INT 3
 131: PUSH
 132: LD_INT 2
 134: PUSH
 135: LD_INT 2
 137: PUSH
 138: EMPTY
 139: LIST
 140: LIST
 141: LIST
 142: LIST
 143: PUSH
 144: LD_OWVAR 67
 148: ARRAY
 149: PPUSH
 150: LD_INT 0
 152: PPUSH
 153: LD_INT 0
 155: PPUSH
 156: LD_INT 0
 158: PPUSH
 159: LD_INT 0
 161: PPUSH
 162: LD_INT 12
 164: PPUSH
 165: LD_INT 0
 167: PPUSH
 168: CALL 48380 0 9
// PrepareArabian ;
 172: CALL 3964 0 0
// PrepareRussian ;
 176: CALL 2935 0 0
// PrepareAlliance ;
 180: CALL 900 0 0
// MC_Start ( ) ;
 184: CALL 57617 0 0
// if debug then
 188: LD_EXP 1
 192: IFFALSE 201
// FogOff ( 1 ) ;
 194: LD_INT 1
 196: PPUSH
 197: CALL_OW 344
// Action ;
 201: CALL 7326 0 0
// end ;
 205: END
// export function CustomInitMacro ; var i ; begin
 206: LD_INT 0
 208: PPUSH
 209: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 210: LD_ADDR_EXP 84
 214: PUSH
 215: LD_INT 1
 217: PUSH
 218: LD_INT 2
 220: PUSH
 221: EMPTY
 222: LIST
 223: LIST
 224: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 225: LD_ADDR_EXP 85
 229: PUSH
 230: LD_INT 3
 232: PUSH
 233: LD_INT 4
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 240: LD_INT 1
 242: PPUSH
 243: LD_INT 12
 245: PUSH
 246: LD_INT 15
 248: PUSH
 249: LD_INT 18
 251: PUSH
 252: LD_INT 20
 254: PUSH
 255: EMPTY
 256: LIST
 257: LIST
 258: LIST
 259: LIST
 260: PUSH
 261: LD_OWVAR 67
 265: ARRAY
 266: PPUSH
 267: LD_INT 7
 269: PPUSH
 270: CALL 79306 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 274: LD_INT 1
 276: PPUSH
 277: LD_EXP 55
 281: PPUSH
 282: CALL 79732 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 286: LD_INT 1
 288: PPUSH
 289: LD_INT 6
 291: PPUSH
 292: CALL 80190 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 9
 301: PUSH
 302: EMPTY
 303: LIST
 304: PPUSH
 305: CALL 80459 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 13
 314: PUSH
 315: LD_INT 1
 317: PUSH
 318: LD_INT 2
 320: PUSH
 321: LD_INT 32
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: LIST
 329: PUSH
 330: LD_INT 13
 332: PUSH
 333: LD_INT 1
 335: PUSH
 336: LD_INT 2
 338: PUSH
 339: LD_EXP 110
 343: PUSH
 344: EMPTY
 345: LIST
 346: LIST
 347: LIST
 348: LIST
 349: PUSH
 350: EMPTY
 351: LIST
 352: LIST
 353: PPUSH
 354: CALL 79672 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 358: LD_INT 2
 360: PPUSH
 361: LD_INT 12
 363: PUSH
 364: LD_INT 14
 366: PUSH
 367: LD_INT 10
 369: PUSH
 370: LD_INT 11
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: PPUSH
 379: CALL 80366 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 383: LD_INT 2
 385: PPUSH
 386: LD_EXP 52
 390: PPUSH
 391: CALL 79732 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 395: LD_INT 2
 397: PPUSH
 398: LD_INT 8
 400: PPUSH
 401: CALL 80190 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 405: LD_INT 2
 407: PPUSH
 408: LD_INT 10
 410: PUSH
 411: EMPTY
 412: LIST
 413: PPUSH
 414: CALL 80459 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 418: LD_INT 2
 420: PPUSH
 421: LD_INT 6
 423: PUSH
 424: LD_INT 71
 426: PUSH
 427: LD_INT 116
 429: PUSH
 430: LD_INT 4
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 4
 441: PUSH
 442: LD_INT 85
 444: PUSH
 445: LD_INT 116
 447: PUSH
 448: LD_INT 4
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: LD_INT 32
 459: PUSH
 460: LD_INT 83
 462: PUSH
 463: LD_INT 111
 465: PUSH
 466: LD_INT 4
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: PUSH
 475: LD_INT 32
 477: PUSH
 478: LD_INT 87
 480: PUSH
 481: LD_INT 121
 483: PUSH
 484: LD_INT 4
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 33
 495: PUSH
 496: LD_INT 88
 498: PUSH
 499: LD_INT 128
 501: PUSH
 502: LD_INT 4
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 32
 513: PUSH
 514: LD_INT 59
 516: PUSH
 517: LD_INT 89
 519: PUSH
 520: LD_INT 3
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 33
 531: PUSH
 532: LD_INT 69
 534: PUSH
 535: LD_INT 98
 537: PUSH
 538: LD_INT 3
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 33
 549: PUSH
 550: LD_INT 77
 552: PUSH
 553: LD_INT 103
 555: PUSH
 556: LD_INT 3
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 33
 567: PUSH
 568: LD_INT 83
 570: PUSH
 571: LD_INT 105
 573: PUSH
 574: LD_INT 3
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 33
 585: PUSH
 586: LD_INT 71
 588: PUSH
 589: LD_INT 125
 591: PUSH
 592: LD_INT 5
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PPUSH
 613: CALL 79516 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 617: LD_INT 2
 619: PPUSH
 620: LD_INT 43
 622: PUSH
 623: LD_INT 47
 625: PUSH
 626: LD_INT 46
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: PPUSH
 634: CALL 80777 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 638: LD_INT 2
 640: PPUSH
 641: LD_INT 21
 643: PUSH
 644: LD_INT 1
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 51
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 22
 661: PUSH
 662: LD_INT 1
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 52
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: EMPTY
 678: LIST
 679: LIST
 680: PPUSH
 681: CALL 79672 0 2
// end ;
 685: LD_VAR 0 1
 689: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 690: LD_INT 0
 692: PPUSH
// debug := false ;
 693: LD_ADDR_EXP 1
 697: PUSH
 698: LD_INT 0
 700: ST_TO_ADDR
// game := true ;
 701: LD_ADDR_EXP 2
 705: PUSH
 706: LD_INT 1
 708: ST_TO_ADDR
// gossudarov_arrive := false ;
 709: LD_ADDR_EXP 4
 713: PUSH
 714: LD_INT 0
 716: ST_TO_ADDR
// ru_lab_builded := false ;
 717: LD_ADDR_EXP 5
 721: PUSH
 722: LD_INT 0
 724: ST_TO_ADDR
// player_spotted := false ;
 725: LD_ADDR_EXP 6
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// first_attack := false ;
 733: LD_ADDR_EXP 7
 737: PUSH
 738: LD_INT 0
 740: ST_TO_ADDR
// ru_attackers := [ ] ;
 741: LD_ADDR_EXP 53
 745: PUSH
 746: EMPTY
 747: ST_TO_ADDR
// ar_base_spotted := false ;
 748: LD_ADDR_EXP 8
 752: PUSH
 753: LD_INT 0
 755: ST_TO_ADDR
// ar_active_attack := false ;
 756: LD_ADDR_EXP 9
 760: PUSH
 761: LD_INT 0
 763: ST_TO_ADDR
// ar_attackers := [ ] ;
 764: LD_ADDR_EXP 11
 768: PUSH
 769: EMPTY
 770: ST_TO_ADDR
// first_powell_attack := false ;
 771: LD_ADDR_EXP 12
 775: PUSH
 776: LD_INT 0
 778: ST_TO_ADDR
// masha_killed := false ;
 779: LD_ADDR_EXP 10
 783: PUSH
 784: LD_INT 0
 786: ST_TO_ADDR
// abdul_escaped := true ;
 787: LD_ADDR_EXP 13
 791: PUSH
 792: LD_INT 1
 794: ST_TO_ADDR
// loss_counter := 0 ;
 795: LD_ADDR_EXP 14
 799: PUSH
 800: LD_INT 0
 802: ST_TO_ADDR
// hack_counter := 0 ;
 803: LD_ADDR_EXP 15
 807: PUSH
 808: LD_INT 0
 810: ST_TO_ADDR
// end ;
 811: LD_VAR 0 1
 815: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 816: LD_EXP 49
 820: PPUSH
 821: CALL_OW 255
 825: PUSH
 826: LD_INT 7
 828: EQUAL
 829: PUSH
 830: LD_EXP 48
 834: PPUSH
 835: CALL_OW 255
 839: PUSH
 840: LD_INT 7
 842: EQUAL
 843: AND
 844: PUSH
 845: LD_EXP 49
 849: PPUSH
 850: CALL_OW 302
 854: AND
 855: PUSH
 856: LD_EXP 48
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: IFFALSE 878
 868: GO 870
 870: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 871: LD_STRING ACH_COMRADE
 873: PPUSH
 874: CALL_OW 543
 878: END
// every 0 0$1 trigger hack_counter >= 10 do
 879: LD_EXP 15
 883: PUSH
 884: LD_INT 10
 886: GREATEREQUAL
 887: IFFALSE 899
 889: GO 891
 891: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 892: LD_STRING ACH_HACK
 894: PPUSH
 895: CALL_OW 543
 899: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 900: LD_INT 0
 902: PPUSH
 903: PPUSH
 904: PPUSH
 905: PPUSH
// uc_side := 7 ;
 906: LD_ADDR_OWVAR 20
 910: PUSH
 911: LD_INT 7
 913: ST_TO_ADDR
// uc_nation := 1 ;
 914: LD_ADDR_OWVAR 21
 918: PUSH
 919: LD_INT 1
 921: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 922: LD_ADDR_EXP 16
 926: PUSH
 927: LD_STRING JMM
 929: PPUSH
 930: LD_EXP 1
 934: NOT
 935: PPUSH
 936: LD_STRING 12a_
 938: PPUSH
 939: CALL 14864 0 3
 943: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 944: LD_EXP 16
 948: PPUSH
 949: LD_INT 71
 951: PPUSH
 952: LD_INT 23
 954: PPUSH
 955: LD_INT 0
 957: PPUSH
 958: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 962: LD_EXP 16
 966: PPUSH
 967: LD_INT 2
 969: PPUSH
 970: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 974: LD_ADDR_EXP 17
 978: PUSH
 979: LD_STRING Roth
 981: PPUSH
 982: LD_EXP 1
 986: NOT
 987: PPUSH
 988: LD_STRING 12a_
 990: PPUSH
 991: CALL 14864 0 3
 995: ST_TO_ADDR
// if Roth then
 996: LD_EXP 17
1000: IFFALSE 1020
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1002: LD_EXP 17
1006: PPUSH
1007: LD_INT 71
1009: PPUSH
1010: LD_INT 21
1012: PPUSH
1013: LD_INT 0
1015: PPUSH
1016: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1020: LD_ADDR_EXP 18
1024: PUSH
1025: LD_STRING Lisa
1027: PPUSH
1028: LD_EXP 1
1032: NOT
1033: PPUSH
1034: LD_STRING 12a_
1036: PPUSH
1037: CALL 14864 0 3
1041: ST_TO_ADDR
// if Lisa then
1042: LD_EXP 18
1046: IFFALSE 1063
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1048: LD_EXP 18
1052: PPUSH
1053: LD_INT 13
1055: PPUSH
1056: LD_INT 0
1058: PPUSH
1059: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1063: LD_ADDR_EXP 19
1067: PUSH
1068: LD_STRING Donaldson
1070: PPUSH
1071: LD_EXP 1
1075: NOT
1076: PPUSH
1077: LD_STRING 12a_
1079: PPUSH
1080: CALL 14864 0 3
1084: ST_TO_ADDR
// if Donaldson then
1085: LD_EXP 19
1089: IFFALSE 1106
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1091: LD_EXP 19
1095: PPUSH
1096: LD_INT 13
1098: PPUSH
1099: LD_INT 0
1101: PPUSH
1102: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1106: LD_ADDR_EXP 20
1110: PUSH
1111: LD_STRING Bobby
1113: PPUSH
1114: LD_EXP 1
1118: NOT
1119: PPUSH
1120: LD_STRING 12a_
1122: PPUSH
1123: CALL 14864 0 3
1127: ST_TO_ADDR
// if Bobby then
1128: LD_EXP 20
1132: IFFALSE 1149
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1134: LD_EXP 20
1138: PPUSH
1139: LD_INT 13
1141: PPUSH
1142: LD_INT 0
1144: PPUSH
1145: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1149: LD_ADDR_EXP 21
1153: PUSH
1154: LD_STRING Cyrus
1156: PPUSH
1157: LD_EXP 1
1161: NOT
1162: PPUSH
1163: LD_STRING 12a_
1165: PPUSH
1166: CALL 14864 0 3
1170: ST_TO_ADDR
// if Cyrus then
1171: LD_EXP 21
1175: IFFALSE 1192
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1177: LD_EXP 21
1181: PPUSH
1182: LD_INT 13
1184: PPUSH
1185: LD_INT 0
1187: PPUSH
1188: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1192: LD_ADDR_EXP 22
1196: PUSH
1197: LD_STRING Denis
1199: PPUSH
1200: LD_EXP 1
1204: NOT
1205: PPUSH
1206: LD_STRING 12a_
1208: PPUSH
1209: CALL 14864 0 3
1213: ST_TO_ADDR
// if Denis then
1214: LD_EXP 22
1218: IFFALSE 1235
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1220: LD_EXP 22
1224: PPUSH
1225: LD_INT 13
1227: PPUSH
1228: LD_INT 0
1230: PPUSH
1231: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1235: LD_ADDR_EXP 23
1239: PUSH
1240: LD_STRING Brown
1242: PPUSH
1243: LD_EXP 1
1247: NOT
1248: PPUSH
1249: LD_STRING 12a_
1251: PPUSH
1252: CALL 14864 0 3
1256: ST_TO_ADDR
// if Brown then
1257: LD_EXP 23
1261: IFFALSE 1278
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1263: LD_EXP 23
1267: PPUSH
1268: LD_INT 13
1270: PPUSH
1271: LD_INT 0
1273: PPUSH
1274: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1278: LD_ADDR_EXP 24
1282: PUSH
1283: LD_STRING Gladstone
1285: PPUSH
1286: LD_EXP 1
1290: NOT
1291: PPUSH
1292: LD_STRING 12a_
1294: PPUSH
1295: CALL 14864 0 3
1299: ST_TO_ADDR
// if Gladstone then
1300: LD_EXP 24
1304: IFFALSE 1321
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1306: LD_EXP 24
1310: PPUSH
1311: LD_INT 13
1313: PPUSH
1314: LD_INT 0
1316: PPUSH
1317: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1321: LD_ADDR_EXP 25
1325: PUSH
1326: LD_STRING Houten
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_STRING 12a_
1337: PPUSH
1338: CALL 14864 0 3
1342: ST_TO_ADDR
// if Houten then
1343: LD_EXP 25
1347: IFFALSE 1364
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1349: LD_EXP 25
1353: PPUSH
1354: LD_INT 13
1356: PPUSH
1357: LD_INT 0
1359: PPUSH
1360: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1364: LD_ADDR_EXP 26
1368: PUSH
1369: LD_STRING Cornell
1371: PPUSH
1372: LD_EXP 1
1376: NOT
1377: PPUSH
1378: LD_STRING 12a_
1380: PPUSH
1381: CALL 14864 0 3
1385: ST_TO_ADDR
// if Cornel then
1386: LD_EXP 26
1390: IFFALSE 1407
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1392: LD_EXP 26
1396: PPUSH
1397: LD_INT 13
1399: PPUSH
1400: LD_INT 0
1402: PPUSH
1403: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1407: LD_ADDR_EXP 27
1411: PUSH
1412: LD_STRING Gary
1414: PPUSH
1415: LD_EXP 1
1419: NOT
1420: PPUSH
1421: LD_STRING 12a_
1423: PPUSH
1424: CALL 14864 0 3
1428: ST_TO_ADDR
// if Gary then
1429: LD_EXP 27
1433: IFFALSE 1450
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1435: LD_EXP 27
1439: PPUSH
1440: LD_INT 13
1442: PPUSH
1443: LD_INT 0
1445: PPUSH
1446: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1450: LD_ADDR_EXP 28
1454: PUSH
1455: LD_STRING Frank
1457: PPUSH
1458: LD_EXP 1
1462: NOT
1463: PPUSH
1464: LD_STRING 12a_
1466: PPUSH
1467: CALL 14864 0 3
1471: ST_TO_ADDR
// if Frank then
1472: LD_EXP 28
1476: IFFALSE 1493
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1478: LD_EXP 28
1482: PPUSH
1483: LD_INT 13
1485: PPUSH
1486: LD_INT 0
1488: PPUSH
1489: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1493: LD_ADDR_EXP 29
1497: PUSH
1498: LD_STRING Kikuchi
1500: PPUSH
1501: LD_EXP 1
1505: NOT
1506: PPUSH
1507: LD_STRING 12a_
1509: PPUSH
1510: CALL 14864 0 3
1514: ST_TO_ADDR
// if Kikuchi then
1515: LD_EXP 29
1519: IFFALSE 1536
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1521: LD_EXP 29
1525: PPUSH
1526: LD_INT 13
1528: PPUSH
1529: LD_INT 0
1531: PPUSH
1532: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1536: LD_ADDR_EXP 30
1540: PUSH
1541: LD_STRING Simms
1543: PPUSH
1544: LD_EXP 1
1548: NOT
1549: PPUSH
1550: LD_STRING 12a_
1552: PPUSH
1553: CALL 14864 0 3
1557: ST_TO_ADDR
// if Simms then
1558: LD_EXP 30
1562: IFFALSE 1579
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1564: LD_EXP 30
1568: PPUSH
1569: LD_INT 13
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1579: LD_ADDR_EXP 31
1583: PUSH
1584: LD_STRING Joan
1586: PPUSH
1587: LD_EXP 1
1591: NOT
1592: PPUSH
1593: LD_STRING 12a_
1595: PPUSH
1596: CALL 14864 0 3
1600: ST_TO_ADDR
// if Joan then
1601: LD_EXP 31
1605: IFFALSE 1622
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1607: LD_EXP 31
1611: PPUSH
1612: LD_INT 13
1614: PPUSH
1615: LD_INT 0
1617: PPUSH
1618: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1622: LD_ADDR_EXP 32
1626: PUSH
1627: LD_STRING DeltaDoctor
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 12a_
1638: PPUSH
1639: CALL 14864 0 3
1643: ST_TO_ADDR
// if DeltaDoctor then
1644: LD_EXP 32
1648: IFFALSE 1665
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1650: LD_EXP 32
1654: PPUSH
1655: LD_INT 13
1657: PPUSH
1658: LD_INT 0
1660: PPUSH
1661: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1665: LD_ADDR_VAR 0 4
1669: PUSH
1670: LD_STRING 12a_others
1672: PPUSH
1673: CALL_OW 31
1677: ST_TO_ADDR
// if tmp then
1678: LD_VAR 0 4
1682: IFFALSE 1716
// for i in tmp do
1684: LD_ADDR_VAR 0 3
1688: PUSH
1689: LD_VAR 0 4
1693: PUSH
1694: FOR_IN
1695: IFFALSE 1714
// PlaceUnitArea ( i , alliance_start , false ) ;
1697: LD_VAR 0 3
1701: PPUSH
1702: LD_INT 13
1704: PPUSH
1705: LD_INT 0
1707: PPUSH
1708: CALL_OW 49
1712: GO 1694
1714: POP
1715: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1716: LD_INT 3
1718: PPUSH
1719: LD_INT 3
1721: PPUSH
1722: LD_INT 3
1724: PPUSH
1725: LD_INT 12
1727: PPUSH
1728: LD_INT 100
1730: PPUSH
1731: CALL 19881 0 5
// veh := CreateVehicle ;
1735: LD_ADDR_VAR 0 2
1739: PUSH
1740: CALL_OW 45
1744: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1745: LD_VAR 0 2
1749: PPUSH
1750: LD_INT 2
1752: PPUSH
1753: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1757: LD_VAR 0 2
1761: PPUSH
1762: LD_INT 60
1764: PPUSH
1765: LD_INT 6
1767: PPUSH
1768: LD_INT 0
1770: PPUSH
1771: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1775: LD_VAR 0 2
1779: PPUSH
1780: LD_INT 4
1782: PPUSH
1783: LD_INT 30
1785: PPUSH
1786: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1790: LD_STRING 11_artifact_captured
1792: PPUSH
1793: LD_INT 0
1795: PPUSH
1796: CALL_OW 30
1800: IFFALSE 1876
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1802: LD_INT 3
1804: PPUSH
1805: LD_INT 3
1807: PPUSH
1808: LD_INT 3
1810: PPUSH
1811: LD_INT 12
1813: PPUSH
1814: LD_INT 100
1816: PPUSH
1817: CALL 19881 0 5
// veh := CreateVehicle ;
1821: LD_ADDR_VAR 0 2
1825: PUSH
1826: CALL_OW 45
1830: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1831: LD_VAR 0 2
1835: PPUSH
1836: LD_INT 3
1838: PPUSH
1839: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1843: LD_VAR 0 2
1847: PPUSH
1848: LD_INT 75
1850: PPUSH
1851: LD_INT 6
1853: PPUSH
1854: LD_INT 0
1856: PPUSH
1857: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1861: LD_VAR 0 2
1865: PPUSH
1866: LD_INT 4
1868: PPUSH
1869: LD_INT 50
1871: PPUSH
1872: CALL_OW 290
// end ; end ;
1876: LD_VAR 0 1
1880: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1881: LD_INT 0
1883: PPUSH
1884: PPUSH
1885: PPUSH
1886: PPUSH
// uc_side := 6 ;
1887: LD_ADDR_OWVAR 20
1891: PUSH
1892: LD_INT 6
1894: ST_TO_ADDR
// uc_nation := 3 ;
1895: LD_ADDR_OWVAR 21
1899: PUSH
1900: LD_INT 3
1902: ST_TO_ADDR
// InitHc ;
1903: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1907: LD_ADDR_EXP 33
1911: PUSH
1912: LD_STRING Gossudarov
1914: PPUSH
1915: CALL_OW 25
1919: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1920: LD_ADDR_EXP 34
1924: PUSH
1925: LD_STRING Kirilenkova
1927: PPUSH
1928: CALL_OW 25
1932: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1933: LD_ADDR_EXP 35
1937: PUSH
1938: LD_STRING Titov
1940: PPUSH
1941: CALL_OW 25
1945: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1946: LD_ADDR_EXP 40
1950: PUSH
1951: LD_STRING Oblukov
1953: PPUSH
1954: CALL_OW 25
1958: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1959: LD_ADDR_EXP 37
1963: PUSH
1964: LD_STRING Dolgov
1966: PPUSH
1967: CALL_OW 25
1971: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1972: LD_ADDR_EXP 38
1976: PUSH
1977: LD_STRING Petrosyan
1979: PPUSH
1980: CALL_OW 25
1984: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1985: LD_ADDR_EXP 39
1989: PUSH
1990: LD_STRING Scholtze
1992: PPUSH
1993: CALL_OW 25
1997: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1998: LD_ADDR_EXP 41
2002: PUSH
2003: LD_STRING Kapitsova
2005: PPUSH
2006: CALL_OW 25
2010: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2011: LD_ADDR_VAR 0 2
2015: PUSH
2016: LD_EXP 33
2020: PUSH
2021: LD_EXP 34
2025: PUSH
2026: LD_EXP 35
2030: PUSH
2031: LD_EXP 40
2035: PUSH
2036: LD_EXP 37
2040: PUSH
2041: LD_EXP 38
2045: PUSH
2046: LD_EXP 39
2050: PUSH
2051: LD_EXP 41
2055: PUSH
2056: EMPTY
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: LIST
2064: LIST
2065: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2066: LD_INT 1
2068: PPUSH
2069: LD_INT 4
2071: PPUSH
2072: LD_INT 8
2074: PPUSH
2075: CALL_OW 380
// un := CreateHuman ;
2079: LD_ADDR_VAR 0 4
2083: PUSH
2084: CALL_OW 44
2088: ST_TO_ADDR
// tmp := tmp ^ un ;
2089: LD_ADDR_VAR 0 2
2093: PUSH
2094: LD_VAR 0 2
2098: PUSH
2099: LD_VAR 0 4
2103: ADD
2104: ST_TO_ADDR
// for i in tmp do
2105: LD_ADDR_VAR 0 3
2109: PUSH
2110: LD_VAR 0 2
2114: PUSH
2115: FOR_IN
2116: IFFALSE 2135
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2118: LD_VAR 0 3
2122: PPUSH
2123: LD_INT 14
2125: PPUSH
2126: LD_INT 0
2128: PPUSH
2129: CALL_OW 49
2133: GO 2115
2135: POP
2136: POP
// if freedom then
2137: LD_EXP 3
2141: IFFALSE 2174
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2143: LD_VAR 0 2
2147: PPUSH
2148: LD_EXP 3
2152: PPUSH
2153: CALL_OW 250
2157: PPUSH
2158: LD_EXP 3
2162: PPUSH
2163: CALL_OW 251
2167: PPUSH
2168: CALL_OW 111
2172: GO 2189
// ComMoveXY ( tmp , 70 , 48 ) ;
2174: LD_VAR 0 2
2178: PPUSH
2179: LD_INT 70
2181: PPUSH
2182: LD_INT 48
2184: PPUSH
2185: CALL_OW 111
// end ;
2189: LD_VAR 0 1
2193: RET
// export function PrepareBelkov ; begin
2194: LD_INT 0
2196: PPUSH
// uc_side := 4 ;
2197: LD_ADDR_OWVAR 20
2201: PUSH
2202: LD_INT 4
2204: ST_TO_ADDR
// uc_nation := 3 ;
2205: LD_ADDR_OWVAR 21
2209: PUSH
2210: LD_INT 3
2212: ST_TO_ADDR
// InitHc ;
2213: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2217: LD_ADDR_EXP 48
2221: PUSH
2222: LD_STRING Belkov
2224: PPUSH
2225: CALL_OW 25
2229: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2230: LD_EXP 48
2234: PPUSH
2235: LD_INT 14
2237: PPUSH
2238: LD_INT 0
2240: PPUSH
2241: CALL_OW 49
// end ;
2245: LD_VAR 0 1
2249: RET
// export function PrepareGnyevko ; begin
2250: LD_INT 0
2252: PPUSH
// uc_side := 4 ;
2253: LD_ADDR_OWVAR 20
2257: PUSH
2258: LD_INT 4
2260: ST_TO_ADDR
// uc_nation := 3 ;
2261: LD_ADDR_OWVAR 21
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// InitHc ;
2269: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2273: LD_ADDR_EXP 49
2277: PUSH
2278: LD_STRING Gnyevko
2280: PPUSH
2281: CALL_OW 25
2285: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2286: LD_EXP 49
2290: PPUSH
2291: LD_INT 14
2293: PPUSH
2294: LD_INT 0
2296: PPUSH
2297: CALL_OW 49
// end ;
2301: LD_VAR 0 1
2305: RET
// export function PrepareBurlak ; var i , tmp ; begin
2306: LD_INT 0
2308: PPUSH
2309: PPUSH
2310: PPUSH
// uc_side := 4 ;
2311: LD_ADDR_OWVAR 20
2315: PUSH
2316: LD_INT 4
2318: ST_TO_ADDR
// uc_nation := 3 ;
2319: LD_ADDR_OWVAR 21
2323: PUSH
2324: LD_INT 3
2326: ST_TO_ADDR
// InitHc ;
2327: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2331: LD_ADDR_EXP 47
2335: PUSH
2336: LD_STRING Burlak
2338: PPUSH
2339: CALL_OW 25
2343: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2344: LD_INT 24
2346: PUSH
2347: LD_INT 23
2349: PUSH
2350: LD_INT 22
2352: PUSH
2353: LD_INT 22
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: LIST
2360: LIST
2361: PUSH
2362: LD_OWVAR 67
2366: ARRAY
2367: PPUSH
2368: LD_INT 1
2370: PPUSH
2371: LD_INT 1
2373: PPUSH
2374: LD_INT 45
2376: PUSH
2377: LD_INT 44
2379: PUSH
2380: LD_INT 43
2382: PUSH
2383: LD_INT 42
2385: PUSH
2386: EMPTY
2387: LIST
2388: LIST
2389: LIST
2390: LIST
2391: PUSH
2392: LD_OWVAR 67
2396: ARRAY
2397: PPUSH
2398: LD_INT 0
2400: PPUSH
2401: CALL 19881 0 5
// Masha := CreateVehicle ;
2405: LD_ADDR_EXP 50
2409: PUSH
2410: CALL_OW 45
2414: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2415: LD_EXP 50
2419: PUSH
2420: LD_EXP 47
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PPUSH
2429: LD_INT 499
2431: PPUSH
2432: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2436: LD_EXP 50
2440: PPUSH
2441: LD_INT 3
2443: PPUSH
2444: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2448: LD_EXP 50
2452: PPUSH
2453: LD_INT 1
2455: PPUSH
2456: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 18
2465: PPUSH
2466: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2470: LD_INT 35
2472: PPUSH
2473: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2477: LD_ADDR_VAR 0 3
2481: PUSH
2482: LD_INT 18
2484: PPUSH
2485: EMPTY
2486: PPUSH
2487: CALL_OW 70
2491: ST_TO_ADDR
// if tmp then
2492: LD_VAR 0 3
2496: IFFALSE 2530
// for i in tmp do
2498: LD_ADDR_VAR 0 2
2502: PUSH
2503: LD_VAR 0 3
2507: PUSH
2508: FOR_IN
2509: IFFALSE 2528
// ComMoveXY ( i , 114 , 9 ) ;
2511: LD_VAR 0 2
2515: PPUSH
2516: LD_INT 114
2518: PPUSH
2519: LD_INT 9
2521: PPUSH
2522: CALL_OW 111
2526: GO 2508
2528: POP
2529: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2530: LD_INT 18
2532: PPUSH
2533: EMPTY
2534: PPUSH
2535: CALL_OW 70
2539: NOT
2540: PUSH
2541: LD_INT 123
2543: PPUSH
2544: LD_INT 3
2546: PPUSH
2547: CALL_OW 428
2551: PUSH
2552: LD_INT 0
2554: EQUAL
2555: AND
2556: IFFALSE 2470
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2558: LD_EXP 50
2562: PPUSH
2563: LD_INT 123
2565: PPUSH
2566: LD_INT 3
2568: PPUSH
2569: LD_INT 0
2571: PPUSH
2572: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2576: LD_EXP 47
2580: PPUSH
2581: LD_INT 125
2583: PPUSH
2584: LD_INT 1
2586: PPUSH
2587: LD_INT 0
2589: PPUSH
2590: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2594: LD_EXP 47
2598: PPUSH
2599: LD_EXP 50
2603: PPUSH
2604: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2608: LD_INT 10
2610: PPUSH
2611: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2615: LD_EXP 50
2619: PPUSH
2620: LD_INT 110
2622: PPUSH
2623: LD_INT 10
2625: PPUSH
2626: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2630: LD_ADDR_EXP 43
2634: PUSH
2635: LD_STRING Petrovova
2637: PPUSH
2638: CALL_OW 25
2642: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2643: LD_ADDR_EXP 45
2647: PUSH
2648: LD_STRING Kuzmov
2650: PPUSH
2651: CALL_OW 25
2655: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2656: LD_ADDR_EXP 44
2660: PUSH
2661: LD_STRING Kovalyuk
2663: PPUSH
2664: CALL_OW 25
2668: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2669: LD_ADDR_EXP 42
2673: PUSH
2674: LD_STRING Lipshchin
2676: PPUSH
2677: CALL_OW 25
2681: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2682: LD_ADDR_EXP 46
2686: PUSH
2687: LD_STRING Karamazov
2689: PPUSH
2690: CALL_OW 25
2694: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2695: LD_ADDR_VAR 0 3
2699: PUSH
2700: LD_EXP 43
2704: PUSH
2705: LD_EXP 45
2709: PUSH
2710: LD_EXP 44
2714: PUSH
2715: LD_EXP 42
2719: PUSH
2720: LD_EXP 46
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: ST_TO_ADDR
// for i in tmp do
2732: LD_ADDR_VAR 0 2
2736: PUSH
2737: LD_VAR 0 3
2741: PUSH
2742: FOR_IN
2743: IFFALSE 2782
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2745: LD_VAR 0 2
2749: PPUSH
2750: LD_INT 399
2752: PPUSH
2753: LD_INT 799
2755: PPUSH
2756: CALL_OW 12
2760: PPUSH
2761: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2765: LD_VAR 0 2
2769: PPUSH
2770: LD_INT 19
2772: PPUSH
2773: LD_INT 0
2775: PPUSH
2776: CALL_OW 49
// end ;
2780: GO 2742
2782: POP
2783: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2784: LD_VAR 0 3
2788: PPUSH
2789: LD_INT 112
2791: PPUSH
2792: LD_INT 5
2794: PPUSH
2795: CALL_OW 111
// AddComHold ( tmp ) ;
2799: LD_VAR 0 3
2803: PPUSH
2804: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2808: LD_ADDR_VAR 0 2
2812: PUSH
2813: LD_VAR 0 3
2817: PPUSH
2818: LD_INT 25
2820: PUSH
2821: LD_INT 1
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: PPUSH
2828: CALL_OW 72
2832: PUSH
2833: FOR_IN
2834: IFFALSE 2874
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2836: LD_VAR 0 2
2840: PPUSH
2841: LD_INT 20
2843: PPUSH
2844: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2848: LD_VAR 0 2
2852: PPUSH
2853: LD_INT 147
2855: PPUSH
2856: LD_INT 45
2858: PPUSH
2859: CALL_OW 178
// AddComCrawl ( i ) ;
2863: LD_VAR 0 2
2867: PPUSH
2868: CALL_OW 197
// end ;
2872: GO 2833
2874: POP
2875: POP
// repeat wait ( 0 0$1 ) ;
2876: LD_INT 35
2878: PPUSH
2879: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2883: LD_EXP 50
2887: PPUSH
2888: LD_INT 110
2890: PPUSH
2891: LD_INT 10
2893: PPUSH
2894: CALL_OW 307
2898: PUSH
2899: LD_EXP 50
2903: PPUSH
2904: CALL_OW 305
2908: NOT
2909: OR
2910: IFFALSE 2876
// ComStop ( Burlak ) ;
2912: LD_EXP 47
2916: PPUSH
2917: CALL_OW 141
// AddComHold ( Burlak ) ;
2921: LD_EXP 47
2925: PPUSH
2926: CALL_OW 200
// end ; end_of_file
2930: LD_VAR 0 1
2934: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2935: LD_INT 0
2937: PPUSH
2938: PPUSH
2939: PPUSH
2940: PPUSH
2941: PPUSH
// uc_side := 3 ;
2942: LD_ADDR_OWVAR 20
2946: PUSH
2947: LD_INT 3
2949: ST_TO_ADDR
// uc_nation := 3 ;
2950: LD_ADDR_OWVAR 21
2954: PUSH
2955: LD_INT 3
2957: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2958: LD_ADDR_EXP 51
2962: PUSH
2963: LD_INT 47
2965: PPUSH
2966: LD_INT 4
2968: PPUSH
2969: LD_STRING 
2971: PPUSH
2972: LD_INT 7
2974: PUSH
2975: LD_INT 8
2977: PUSH
2978: LD_INT 9
2980: PUSH
2981: LD_INT 10
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_OWVAR 67
2994: ARRAY
2995: PPUSH
2996: LD_INT 10000
2998: PUSH
2999: LD_INT 3000
3001: PUSH
3002: LD_INT 300
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: LIST
3009: PPUSH
3010: LD_INT 9
3012: PUSH
3013: LD_INT 5
3015: PUSH
3016: LD_INT 6
3018: PUSH
3019: LD_INT 6
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 23327 0 6
3032: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3033: LD_ADDR_EXP 60
3037: PUSH
3038: LD_EXP 60
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_EXP 51
3050: PPUSH
3051: CALL_OW 1
3055: ST_TO_ADDR
// tmp := [ ] ;
3056: LD_ADDR_VAR 0 4
3060: PUSH
3061: EMPTY
3062: ST_TO_ADDR
// for i = 1 to 4 do
3063: LD_ADDR_VAR 0 2
3067: PUSH
3068: DOUBLE
3069: LD_INT 1
3071: DEC
3072: ST_TO_ADDR
3073: LD_INT 4
3075: PUSH
3076: FOR_TO
3077: IFFALSE 3170
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3079: LD_INT 22
3081: PPUSH
3082: LD_INT 3
3084: PPUSH
3085: LD_INT 3
3087: PPUSH
3088: LD_INT 43
3090: PUSH
3091: LD_INT 45
3093: PUSH
3094: LD_INT 45
3096: PUSH
3097: LD_INT 44
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: LIST
3104: LIST
3105: PUSH
3106: LD_VAR 0 2
3110: PUSH
3111: LD_INT 4
3113: MOD
3114: PUSH
3115: LD_INT 1
3117: PLUS
3118: ARRAY
3119: PPUSH
3120: LD_INT 100
3122: PPUSH
3123: CALL 19881 0 5
// veh := CreateVehicle ;
3127: LD_ADDR_VAR 0 3
3131: PUSH
3132: CALL_OW 45
3136: ST_TO_ADDR
// tmp := tmp ^ veh ;
3137: LD_ADDR_VAR 0 4
3141: PUSH
3142: LD_VAR 0 4
3146: PUSH
3147: LD_VAR 0 3
3151: ADD
3152: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3153: LD_VAR 0 3
3157: PPUSH
3158: LD_INT 2
3160: PPUSH
3161: LD_INT 0
3163: PPUSH
3164: CALL_OW 49
// end ;
3168: GO 3076
3170: POP
3171: POP
// russian_guard := tmp ;
3172: LD_ADDR_EXP 52
3176: PUSH
3177: LD_VAR 0 4
3181: ST_TO_ADDR
// if Difficulty >= 3 then
3182: LD_OWVAR 67
3186: PUSH
3187: LD_INT 3
3189: GREATEREQUAL
3190: IFFALSE 3254
// begin bc_type := b_breastwork ;
3192: LD_ADDR_OWVAR 42
3196: PUSH
3197: LD_INT 31
3199: ST_TO_ADDR
// bc_level := 10 ;
3200: LD_ADDR_OWVAR 43
3204: PUSH
3205: LD_INT 10
3207: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3208: LD_ADDR_VAR 0 5
3212: PUSH
3213: LD_INT 96
3215: PPUSH
3216: LD_INT 105
3218: PPUSH
3219: LD_INT 3
3221: PPUSH
3222: CALL_OW 47
3226: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3227: LD_INT 0
3229: PPUSH
3230: LD_INT 9
3232: PPUSH
3233: LD_INT 10
3235: PPUSH
3236: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3240: CALL_OW 44
3244: PPUSH
3245: LD_VAR 0 5
3249: PPUSH
3250: CALL_OW 52
// end ; end ;
3254: LD_VAR 0 1
3258: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3259: LD_INT 47
3261: PPUSH
3262: CALL_OW 302
3266: PUSH
3267: LD_EXP 6
3271: AND
3272: IFFALSE 3961
3274: GO 3276
3276: DISABLE
3277: LD_INT 0
3279: PPUSH
3280: PPUSH
3281: PPUSH
3282: PPUSH
3283: PPUSH
3284: PPUSH
3285: PPUSH
// begin enable ;
3286: ENABLE
// base := 2 ;
3287: LD_ADDR_VAR 0 2
3291: PUSH
3292: LD_INT 2
3294: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3295: LD_ADDR_VAR 0 4
3299: PUSH
3300: LD_INT 0
3302: PUSH
3303: LD_INT 0
3305: PUSH
3306: LD_INT 0
3308: PUSH
3309: LD_INT 0
3311: PUSH
3312: LD_INT 0
3314: PUSH
3315: LD_INT 0
3317: PUSH
3318: LD_INT 0
3320: PUSH
3321: LD_INT 0
3323: PUSH
3324: LD_INT 1
3326: PUSH
3327: LD_INT 0
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: LIST
3334: LIST
3335: LIST
3336: LIST
3337: LIST
3338: LIST
3339: LIST
3340: LIST
3341: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3342: LD_ADDR_VAR 0 3
3346: PUSH
3347: LD_INT 22
3349: PUSH
3350: LD_INT 1
3352: PUSH
3353: LD_INT 3
3355: PUSH
3356: LD_INT 45
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: LIST
3364: PUSH
3365: LD_INT 21
3367: PUSH
3368: LD_INT 1
3370: PUSH
3371: LD_INT 3
3373: PUSH
3374: LD_INT 45
3376: PUSH
3377: EMPTY
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_INT 22
3385: PUSH
3386: LD_INT 1
3388: PUSH
3389: LD_INT 3
3391: PUSH
3392: LD_INT 45
3394: PUSH
3395: EMPTY
3396: LIST
3397: LIST
3398: LIST
3399: LIST
3400: PUSH
3401: LD_INT 23
3403: PUSH
3404: LD_INT 1
3406: PUSH
3407: LD_INT 3
3409: PUSH
3410: LD_INT 46
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: LIST
3423: LIST
3424: ST_TO_ADDR
// amount := Difficulty ;
3425: LD_ADDR_VAR 0 7
3429: PUSH
3430: LD_OWVAR 67
3434: ST_TO_ADDR
// if tick > 30 30$00 then
3435: LD_OWVAR 1
3439: PUSH
3440: LD_INT 63000
3442: GREATER
3443: IFFALSE 3480
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3445: LD_ADDR_VAR 0 7
3449: PUSH
3450: LD_VAR 0 7
3454: PUSH
3455: LD_INT 2
3457: PUSH
3458: LD_INT 3
3460: PUSH
3461: LD_INT 4
3463: PUSH
3464: LD_INT 4
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: PUSH
3473: LD_OWVAR 67
3477: ARRAY
3478: PLUS
3479: ST_TO_ADDR
// for i = 1 to amount do
3480: LD_ADDR_VAR 0 1
3484: PUSH
3485: DOUBLE
3486: LD_INT 1
3488: DEC
3489: ST_TO_ADDR
3490: LD_VAR 0 7
3494: PUSH
3495: FOR_TO
3496: IFFALSE 3584
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: LD_VAR 0 3
3507: PPUSH
3508: LD_VAR 0 3
3512: PUSH
3513: LD_INT 1
3515: PLUS
3516: PPUSH
3517: LD_INT 23
3519: PUSH
3520: LD_INT 24
3522: PUSH
3523: EMPTY
3524: LIST
3525: LIST
3526: PUSH
3527: LD_INT 1
3529: PPUSH
3530: LD_INT 2
3532: PPUSH
3533: CALL_OW 12
3537: ARRAY
3538: PUSH
3539: LD_INT 1
3541: PUSH
3542: LD_INT 3
3544: PUSH
3545: LD_INT 46
3547: PUSH
3548: LD_INT 47
3550: PUSH
3551: LD_INT 45
3553: PUSH
3554: EMPTY
3555: LIST
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 1
3561: PPUSH
3562: LD_INT 3
3564: PPUSH
3565: CALL_OW 12
3569: ARRAY
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: PPUSH
3577: CALL_OW 2
3581: ST_TO_ADDR
3582: GO 3495
3584: POP
3585: POP
// MC_InsertProduceList ( base , tmp ) ;
3586: LD_VAR 0 2
3590: PPUSH
3591: LD_VAR 0 3
3595: PPUSH
3596: CALL 79672 0 2
// repeat wait ( 0 0$1 ) ;
3600: LD_INT 35
3602: PPUSH
3603: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3607: LD_VAR 0 2
3611: PPUSH
3612: LD_INT 1
3614: PPUSH
3615: CALL 81090 0 2
3619: PUSH
3620: LD_VAR 0 7
3624: GREATEREQUAL
3625: IFFALSE 3600
// wait ( 0 0$30 ) ;
3627: LD_INT 1050
3629: PPUSH
3630: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3634: LD_ADDR_VAR 0 5
3638: PUSH
3639: LD_INT 71
3641: PUSH
3642: LD_INT 19
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 91
3651: PUSH
3652: LD_INT 67
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: PUSH
3659: LD_INT 52
3661: PUSH
3662: LD_INT 44
3664: PUSH
3665: EMPTY
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 68
3671: PUSH
3672: LD_INT 48
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3685: LD_ADDR_VAR 0 6
3689: PUSH
3690: LD_EXP 79
3694: PUSH
3695: LD_VAR 0 2
3699: ARRAY
3700: PUSH
3701: LD_EXP 79
3705: PUSH
3706: LD_VAR 0 2
3710: ARRAY
3711: PPUSH
3712: LD_INT 2
3714: PUSH
3715: LD_INT 34
3717: PUSH
3718: LD_INT 51
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: LD_INT 34
3727: PUSH
3728: LD_INT 52
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: LIST
3739: PPUSH
3740: CALL_OW 72
3744: DIFF
3745: ST_TO_ADDR
// if not attackers then
3746: LD_VAR 0 6
3750: NOT
3751: IFFALSE 3755
// exit ;
3753: GO 3961
// ru_attackers := attackers ;
3755: LD_ADDR_EXP 53
3759: PUSH
3760: LD_VAR 0 6
3764: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3765: LD_ADDR_EXP 79
3769: PUSH
3770: LD_EXP 79
3774: PPUSH
3775: LD_VAR 0 2
3779: PPUSH
3780: LD_EXP 79
3784: PUSH
3785: LD_VAR 0 2
3789: ARRAY
3790: PUSH
3791: LD_VAR 0 6
3795: DIFF
3796: PPUSH
3797: CALL_OW 1
3801: ST_TO_ADDR
// for i = 1 to attackers do
3802: LD_ADDR_VAR 0 1
3806: PUSH
3807: DOUBLE
3808: LD_INT 1
3810: DEC
3811: ST_TO_ADDR
3812: LD_VAR 0 6
3816: PUSH
3817: FOR_TO
3818: IFFALSE 3895
// begin case i mod 3 of 0 :
3820: LD_VAR 0 1
3824: PUSH
3825: LD_INT 3
3827: MOD
3828: PUSH
3829: LD_INT 0
3831: DOUBLE
3832: EQUAL
3833: IFTRUE 3837
3835: GO 3840
3837: POP
// ; 1 :
3838: GO 3893
3840: LD_INT 1
3842: DOUBLE
3843: EQUAL
3844: IFTRUE 3848
3846: GO 3866
3848: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3849: LD_VAR 0 1
3853: PPUSH
3854: LD_INT 32
3856: PPUSH
3857: LD_INT 49
3859: PPUSH
3860: CALL_OW 114
3864: GO 3893
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3892
3874: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3875: LD_VAR 0 1
3879: PPUSH
3880: LD_INT 117
3882: PPUSH
3883: LD_INT 107
3885: PPUSH
3886: CALL_OW 114
3890: GO 3893
3892: POP
// end ;
3893: GO 3817
3895: POP
3896: POP
// repeat wait ( 0 0$1 ) ;
3897: LD_INT 35
3899: PPUSH
3900: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3904: LD_VAR 0 6
3908: PPUSH
3909: LD_INT 60
3911: PUSH
3912: EMPTY
3913: LIST
3914: PPUSH
3915: CALL_OW 72
3919: NOT
3920: IFFALSE 3897
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3922: LD_VAR 0 2
3926: PPUSH
3927: LD_VAR 0 6
3931: PPUSH
3932: LD_VAR 0 5
3936: PPUSH
3937: LD_VAR 0 4
3941: PPUSH
3942: CALL 79857 0 4
// if not first_attack then
3946: LD_EXP 7
3950: NOT
3951: IFFALSE 3961
// first_attack := true ;
3953: LD_ADDR_EXP 7
3957: PUSH
3958: LD_INT 1
3960: ST_TO_ADDR
// end ; end_of_file
3961: PPOPN 7
3963: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3964: LD_INT 0
3966: PPUSH
3967: PPUSH
3968: PPUSH
3969: PPUSH
3970: PPUSH
3971: PPUSH
3972: PPUSH
// uc_side := 2 ;
3973: LD_ADDR_OWVAR 20
3977: PUSH
3978: LD_INT 2
3980: ST_TO_ADDR
// uc_nation := 2 ;
3981: LD_ADDR_OWVAR 21
3985: PUSH
3986: LD_INT 2
3988: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3989: LD_ADDR_EXP 56
3993: PUSH
3994: LD_STRING Abdul
3996: PPUSH
3997: CALL_OW 25
4001: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4002: LD_EXP 56
4006: PPUSH
4007: LD_INT 11
4009: PPUSH
4010: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4014: LD_EXP 56
4018: PPUSH
4019: LD_INT 1
4021: PPUSH
4022: CALL_OW 52
// vc_chassis := 31 ;
4026: LD_ADDR_OWVAR 37
4030: PUSH
4031: LD_INT 31
4033: ST_TO_ADDR
// vc_control := control_rider ;
4034: LD_ADDR_OWVAR 38
4038: PUSH
4039: LD_INT 4
4041: ST_TO_ADDR
// mastodont := CreateVehicle ;
4042: LD_ADDR_EXP 57
4046: PUSH
4047: CALL_OW 45
4051: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4052: LD_EXP 57
4056: PPUSH
4057: LD_INT 153
4059: PPUSH
4060: LD_INT 71
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 48
// InitVc ;
4070: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4074: LD_ADDR_EXP 54
4078: PUSH
4079: LD_INT 1
4081: PPUSH
4082: LD_INT 3
4084: PPUSH
4085: LD_STRING 
4087: PPUSH
4088: LD_INT 7
4090: PUSH
4091: LD_INT 8
4093: PUSH
4094: LD_INT 9
4096: PUSH
4097: LD_INT 10
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: PUSH
4106: LD_OWVAR 67
4110: ARRAY
4111: PPUSH
4112: LD_INT 5000
4114: PUSH
4115: LD_INT 1000
4117: PUSH
4118: LD_INT 300
4120: PUSH
4121: EMPTY
4122: LIST
4123: LIST
4124: LIST
4125: PPUSH
4126: LD_INT 18
4128: PUSH
4129: LD_INT 5
4131: PUSH
4132: LD_INT 6
4134: PUSH
4135: LD_INT 9
4137: PUSH
4138: EMPTY
4139: LIST
4140: LIST
4141: LIST
4142: LIST
4143: PPUSH
4144: CALL 23327 0 6
4148: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4149: LD_ADDR_EXP 60
4153: PUSH
4154: LD_EXP 60
4158: PPUSH
4159: LD_INT 1
4161: PPUSH
4162: LD_EXP 54
4166: PPUSH
4167: CALL_OW 1
4171: ST_TO_ADDR
// tmp := [ ] ;
4172: LD_ADDR_VAR 0 4
4176: PUSH
4177: EMPTY
4178: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4179: LD_ADDR_OWVAR 37
4183: PUSH
4184: LD_INT 14
4186: ST_TO_ADDR
// vc_engine := engine_siberite ;
4187: LD_ADDR_OWVAR 39
4191: PUSH
4192: LD_INT 3
4194: ST_TO_ADDR
// vc_control := control_manual ;
4195: LD_ADDR_OWVAR 38
4199: PUSH
4200: LD_INT 1
4202: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4203: LD_ADDR_OWVAR 40
4207: PUSH
4208: LD_INT 31
4210: ST_TO_ADDR
// for i = 1 to 3 do
4211: LD_ADDR_VAR 0 2
4215: PUSH
4216: DOUBLE
4217: LD_INT 1
4219: DEC
4220: ST_TO_ADDR
4221: LD_INT 3
4223: PUSH
4224: FOR_TO
4225: IFFALSE 4473
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4227: LD_ADDR_VAR 0 5
4231: PUSH
4232: LD_INT 153
4234: PUSH
4235: LD_INT 71
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 155
4244: PUSH
4245: LD_INT 81
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_VAR 0 2
4260: PUSH
4261: LD_INT 2
4263: MOD
4264: PUSH
4265: LD_INT 1
4267: PLUS
4268: ARRAY
4269: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4270: LD_INT 0
4272: PPUSH
4273: LD_INT 3
4275: PPUSH
4276: LD_INT 7
4278: PUSH
4279: LD_INT 8
4281: PUSH
4282: LD_INT 10
4284: PUSH
4285: LD_INT 10
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: LIST
4292: LIST
4293: PUSH
4294: LD_OWVAR 67
4298: ARRAY
4299: PPUSH
4300: CALL_OW 380
// un := CreateVehicle ;
4304: LD_ADDR_VAR 0 6
4308: PUSH
4309: CALL_OW 45
4313: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4314: LD_VAR 0 6
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: LD_INT 5
4324: PPUSH
4325: CALL_OW 12
4329: PPUSH
4330: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4334: LD_VAR 0 6
4338: PPUSH
4339: LD_VAR 0 5
4343: PUSH
4344: LD_INT 1
4346: ARRAY
4347: PPUSH
4348: LD_VAR 0 5
4352: PUSH
4353: LD_INT 2
4355: ARRAY
4356: PPUSH
4357: LD_INT 6
4359: PPUSH
4360: LD_INT 0
4362: PPUSH
4363: CALL_OW 50
// un2 := CreateHuman ;
4367: LD_ADDR_VAR 0 7
4371: PUSH
4372: CALL_OW 44
4376: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4377: LD_VAR 0 7
4381: PPUSH
4382: LD_VAR 0 6
4386: PPUSH
4387: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4391: LD_ADDR_EXP 60
4395: PUSH
4396: LD_EXP 60
4400: PPUSH
4401: LD_INT 1
4403: PUSH
4404: LD_EXP 60
4408: PUSH
4409: LD_INT 1
4411: ARRAY
4412: PUSH
4413: LD_INT 1
4415: PLUS
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: LD_VAR 0 6
4425: PPUSH
4426: CALL 20003 0 3
4430: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4431: LD_ADDR_EXP 60
4435: PUSH
4436: LD_EXP 60
4440: PPUSH
4441: LD_INT 1
4443: PUSH
4444: LD_EXP 60
4448: PUSH
4449: LD_INT 1
4451: ARRAY
4452: PUSH
4453: LD_INT 1
4455: PLUS
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PPUSH
4461: LD_VAR 0 7
4465: PPUSH
4466: CALL 20003 0 3
4470: ST_TO_ADDR
// end ;
4471: GO 4224
4473: POP
4474: POP
// for i = 1 to 5 do
4475: LD_ADDR_VAR 0 2
4479: PUSH
4480: DOUBLE
4481: LD_INT 1
4483: DEC
4484: ST_TO_ADDR
4485: LD_INT 5
4487: PUSH
4488: FOR_TO
4489: IFFALSE 4582
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4491: LD_INT 14
4493: PPUSH
4494: LD_INT 3
4496: PPUSH
4497: LD_INT 1
4499: PPUSH
4500: LD_INT 25
4502: PUSH
4503: LD_INT 28
4505: PUSH
4506: LD_INT 28
4508: PUSH
4509: LD_INT 26
4511: PUSH
4512: EMPTY
4513: LIST
4514: LIST
4515: LIST
4516: LIST
4517: PUSH
4518: LD_VAR 0 2
4522: PUSH
4523: LD_INT 4
4525: MOD
4526: PUSH
4527: LD_INT 1
4529: PLUS
4530: ARRAY
4531: PPUSH
4532: LD_INT 100
4534: PPUSH
4535: CALL 19881 0 5
// veh := CreateVehicle ;
4539: LD_ADDR_VAR 0 3
4543: PUSH
4544: CALL_OW 45
4548: ST_TO_ADDR
// tmp := tmp ^ veh ;
4549: LD_ADDR_VAR 0 4
4553: PUSH
4554: LD_VAR 0 4
4558: PUSH
4559: LD_VAR 0 3
4563: ADD
4564: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4565: LD_VAR 0 3
4569: PPUSH
4570: LD_INT 1
4572: PPUSH
4573: LD_INT 0
4575: PPUSH
4576: CALL_OW 49
// end ;
4580: GO 4488
4582: POP
4583: POP
// arabian_guard := tmp ;
4584: LD_ADDR_EXP 55
4588: PUSH
4589: LD_VAR 0 4
4593: ST_TO_ADDR
// end ;
4594: LD_VAR 0 1
4598: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4599: LD_INT 22
4601: PUSH
4602: LD_INT 7
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: PUSH
4609: LD_INT 91
4611: PUSH
4612: LD_INT 1
4614: PUSH
4615: LD_INT 12
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: LIST
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: PPUSH
4627: CALL_OW 69
4631: PUSH
4632: LD_EXP 57
4636: PPUSH
4637: CALL_OW 256
4641: PUSH
4642: LD_INT 990
4644: LESS
4645: OR
4646: PUSH
4647: LD_EXP 56
4651: PPUSH
4652: CALL_OW 256
4656: PUSH
4657: LD_INT 990
4659: LESS
4660: OR
4661: IFFALSE 4804
4663: GO 4665
4665: DISABLE
// begin if IsInUnit ( Abdul ) then
4666: LD_EXP 56
4670: PPUSH
4671: CALL_OW 310
4675: IFFALSE 4686
// ComExitBuilding ( Abdul ) ;
4677: LD_EXP 56
4681: PPUSH
4682: CALL_OW 122
// if Mastodont then
4686: LD_EXP 57
4690: IFFALSE 4707
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4692: LD_EXP 57
4696: PPUSH
4697: LD_INT 205
4699: PPUSH
4700: LD_INT 132
4702: PPUSH
4703: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4707: LD_EXP 56
4711: PPUSH
4712: LD_INT 205
4714: PPUSH
4715: LD_INT 132
4717: PPUSH
4718: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4722: LD_INT 35
4724: PPUSH
4725: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4729: LD_EXP 56
4733: PPUSH
4734: LD_INT 21
4736: PPUSH
4737: CALL_OW 308
4741: IFFALSE 4722
// RemoveUnit ( Abdul ) ;
4743: LD_EXP 56
4747: PPUSH
4748: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4752: LD_INT 35
4754: PPUSH
4755: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4759: LD_EXP 57
4763: PPUSH
4764: LD_INT 21
4766: PPUSH
4767: CALL_OW 308
4771: PUSH
4772: LD_EXP 57
4776: PPUSH
4777: CALL_OW 301
4781: OR
4782: IFFALSE 4752
// if IsOk ( Mastodont ) then
4784: LD_EXP 57
4788: PPUSH
4789: CALL_OW 302
4793: IFFALSE 4804
// RemoveUnit ( Mastodont ) ;
4795: LD_EXP 57
4799: PPUSH
4800: CALL_OW 64
// end ;
4804: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4805: LD_EXP 56
4809: PPUSH
4810: CALL_OW 301
4814: PUSH
4815: LD_INT 22
4817: PUSH
4818: LD_INT 2
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: PUSH
4825: LD_INT 2
4827: PUSH
4828: LD_INT 25
4830: PUSH
4831: LD_INT 1
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: LD_INT 25
4840: PUSH
4841: LD_INT 2
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 25
4850: PUSH
4851: LD_INT 3
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 25
4860: PUSH
4861: LD_INT 4
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 25
4870: PUSH
4871: LD_INT 8
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PPUSH
4890: CALL_OW 69
4894: PUSH
4895: LD_INT 16
4897: PUSH
4898: LD_INT 19
4900: PUSH
4901: LD_INT 22
4903: PUSH
4904: LD_INT 22
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: LIST
4911: LIST
4912: PUSH
4913: LD_OWVAR 67
4917: ARRAY
4918: LESS
4919: OR
4920: IFFALSE 5593
4922: GO 4924
4924: DISABLE
4925: LD_INT 0
4927: PPUSH
4928: PPUSH
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
// begin MC_Kill ( 1 ) ;
4933: LD_INT 1
4935: PPUSH
4936: CALL 55694 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4940: LD_ADDR_VAR 0 2
4944: PUSH
4945: LD_INT 22
4947: PUSH
4948: LD_INT 2
4950: PUSH
4951: EMPTY
4952: LIST
4953: LIST
4954: PUSH
4955: LD_INT 2
4957: PUSH
4958: LD_INT 25
4960: PUSH
4961: LD_INT 1
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: PUSH
4968: LD_INT 25
4970: PUSH
4971: LD_INT 2
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: PUSH
4978: LD_INT 25
4980: PUSH
4981: LD_INT 3
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 25
4990: PUSH
4991: LD_INT 4
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 25
5000: PUSH
5001: LD_INT 8
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PPUSH
5020: CALL_OW 69
5024: ST_TO_ADDR
// for i in tmp do
5025: LD_ADDR_VAR 0 5
5029: PUSH
5030: LD_VAR 0 2
5034: PUSH
5035: FOR_IN
5036: IFFALSE 5052
// SetTag ( i , 10 ) ;
5038: LD_VAR 0 5
5042: PPUSH
5043: LD_INT 10
5045: PPUSH
5046: CALL_OW 109
5050: GO 5035
5052: POP
5053: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5054: LD_ADDR_VAR 0 3
5058: PUSH
5059: LD_INT 22
5061: PUSH
5062: LD_INT 2
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: PUSH
5069: LD_INT 21
5071: PUSH
5072: LD_INT 1
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: PUSH
5079: EMPTY
5080: LIST
5081: LIST
5082: PPUSH
5083: CALL_OW 69
5087: PUSH
5088: LD_VAR 0 2
5092: DIFF
5093: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5094: LD_ADDR_VAR 0 1
5098: PUSH
5099: LD_INT 22
5101: PUSH
5102: LD_INT 2
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PUSH
5109: LD_INT 21
5111: PUSH
5112: LD_INT 2
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 24
5121: PUSH
5122: LD_INT 300
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: LIST
5133: PPUSH
5134: CALL_OW 69
5138: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5139: LD_ADDR_VAR 0 4
5143: PUSH
5144: LD_VAR 0 1
5148: PPUSH
5149: LD_INT 33
5151: PUSH
5152: LD_INT 1
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 58
5161: PUSH
5162: EMPTY
5163: LIST
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PPUSH
5169: CALL_OW 72
5173: ST_TO_ADDR
// for i in tmp do
5174: LD_ADDR_VAR 0 5
5178: PUSH
5179: LD_VAR 0 2
5183: PUSH
5184: FOR_IN
5185: IFFALSE 5369
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5187: LD_VAR 0 5
5191: PUSH
5192: LD_INT 55
5194: PUSH
5195: EMPTY
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: IN
5203: IFFALSE 5222
// begin AddComMoveXY ( i , 209 , 132 ) ;
5205: LD_VAR 0 5
5209: PPUSH
5210: LD_INT 209
5212: PPUSH
5213: LD_INT 132
5215: PPUSH
5216: CALL_OW 171
// continue ;
5220: GO 5184
// end ; if IsInUnit ( i ) then
5222: LD_VAR 0 5
5226: PPUSH
5227: CALL_OW 310
5231: IFFALSE 5249
// begin ComExitBuilding ( i ) ;
5233: LD_VAR 0 5
5237: PPUSH
5238: CALL_OW 122
// wait ( 3 ) ;
5242: LD_INT 3
5244: PPUSH
5245: CALL_OW 67
// end ; if tmp_empty then
5249: LD_VAR 0 4
5253: IFFALSE 5352
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5255: LD_VAR 0 5
5259: PPUSH
5260: LD_VAR 0 4
5264: PPUSH
5265: LD_VAR 0 5
5269: PPUSH
5270: CALL_OW 74
5274: PPUSH
5275: CALL_OW 296
5279: PUSH
5280: LD_INT 25
5282: LESS
5283: IFFALSE 5352
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5285: LD_ADDR_VAR 0 6
5289: PUSH
5290: LD_VAR 0 4
5294: PPUSH
5295: LD_VAR 0 5
5299: PPUSH
5300: CALL_OW 74
5304: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5305: LD_VAR 0 5
5309: PPUSH
5310: LD_VAR 0 6
5314: PPUSH
5315: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5319: LD_VAR 0 5
5323: PPUSH
5324: LD_INT 209
5326: PPUSH
5327: LD_INT 132
5329: PPUSH
5330: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5334: LD_ADDR_VAR 0 4
5338: PUSH
5339: LD_VAR 0 4
5343: PUSH
5344: LD_VAR 0 6
5348: DIFF
5349: ST_TO_ADDR
// continue ;
5350: GO 5184
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5352: LD_VAR 0 5
5356: PPUSH
5357: LD_INT 201
5359: PPUSH
5360: LD_INT 132
5362: PPUSH
5363: CALL_OW 171
// end ;
5367: GO 5184
5369: POP
5370: POP
// for i in tmp_ape do
5371: LD_ADDR_VAR 0 5
5375: PUSH
5376: LD_VAR 0 3
5380: PUSH
5381: FOR_IN
5382: IFFALSE 5421
// begin if IsInUnit ( i ) then
5384: LD_VAR 0 5
5388: PPUSH
5389: CALL_OW 310
5393: IFFALSE 5404
// ComExitBuilding ( i ) ;
5395: LD_VAR 0 5
5399: PPUSH
5400: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5404: LD_VAR 0 5
5408: PPUSH
5409: LD_INT 201
5411: PPUSH
5412: LD_INT 132
5414: PPUSH
5415: CALL_OW 171
// end ;
5419: GO 5381
5421: POP
5422: POP
// repeat wait ( 0 0$1 ) ;
5423: LD_INT 35
5425: PPUSH
5426: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5430: LD_ADDR_VAR 0 5
5434: PUSH
5435: LD_VAR 0 2
5439: PUSH
5440: LD_VAR 0 3
5444: UNION
5445: PUSH
5446: LD_VAR 0 1
5450: UNION
5451: PUSH
5452: FOR_IN
5453: IFFALSE 5484
// if not HasTask ( i ) then
5455: LD_VAR 0 5
5459: PPUSH
5460: CALL_OW 314
5464: NOT
5465: IFFALSE 5482
// ComMoveXY ( i , 201 , 132 ) ;
5467: LD_VAR 0 5
5471: PPUSH
5472: LD_INT 201
5474: PPUSH
5475: LD_INT 132
5477: PPUSH
5478: CALL_OW 111
5482: GO 5452
5484: POP
5485: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5486: LD_INT 21
5488: PPUSH
5489: LD_INT 22
5491: PUSH
5492: LD_INT 2
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: PPUSH
5499: CALL_OW 70
5503: IFFALSE 5544
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5505: LD_ADDR_VAR 0 5
5509: PUSH
5510: LD_INT 21
5512: PPUSH
5513: LD_INT 22
5515: PUSH
5516: LD_INT 2
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 70
5527: PUSH
5528: FOR_IN
5529: IFFALSE 5542
// RemoveUnit ( i ) ;
5531: LD_VAR 0 5
5535: PPUSH
5536: CALL_OW 64
5540: GO 5528
5542: POP
5543: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5544: LD_INT 22
5546: PUSH
5547: LD_INT 2
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 2
5556: PUSH
5557: LD_INT 21
5559: PUSH
5560: LD_INT 1
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: LD_INT 21
5569: PUSH
5570: LD_INT 2
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PUSH
5577: EMPTY
5578: LIST
5579: LIST
5580: LIST
5581: PUSH
5582: EMPTY
5583: LIST
5584: LIST
5585: PPUSH
5586: CALL_OW 69
5590: NOT
5591: IFFALSE 5423
// end ;
5593: PPOPN 6
5595: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5596: LD_EXP 9
5600: PUSH
5601: LD_INT 92
5603: PPUSH
5604: LD_INT 40
5606: PPUSH
5607: CALL_OW 428
5611: PPUSH
5612: CALL_OW 266
5616: PUSH
5617: LD_INT 30
5619: EQUAL
5620: AND
5621: IFFALSE 5817
5623: GO 5625
5625: DISABLE
5626: LD_INT 0
5628: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5629: LD_ADDR_VAR 0 1
5633: PUSH
5634: LD_EXP 60
5638: PUSH
5639: LD_INT 1
5641: ARRAY
5642: PPUSH
5643: LD_INT 25
5645: PUSH
5646: LD_INT 4
5648: PUSH
5649: EMPTY
5650: LIST
5651: LIST
5652: PPUSH
5653: CALL_OW 72
5657: ST_TO_ADDR
// if not sci then
5658: LD_VAR 0 1
5662: NOT
5663: IFFALSE 5667
// exit ;
5665: GO 5817
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5667: LD_ADDR_EXP 60
5671: PUSH
5672: LD_EXP 60
5676: PPUSH
5677: LD_INT 1
5679: PPUSH
5680: LD_EXP 60
5684: PUSH
5685: LD_INT 1
5687: ARRAY
5688: PUSH
5689: LD_VAR 0 1
5693: PUSH
5694: LD_INT 1
5696: ARRAY
5697: DIFF
5698: PPUSH
5699: CALL_OW 1
5703: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5704: LD_VAR 0 1
5708: PUSH
5709: LD_INT 1
5711: ARRAY
5712: PPUSH
5713: CALL_OW 310
5717: IFFALSE 5732
// ComExitBuilding ( sci [ 1 ] ) ;
5719: LD_VAR 0 1
5723: PUSH
5724: LD_INT 1
5726: ARRAY
5727: PPUSH
5728: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5732: LD_INT 2
5734: PPUSH
5735: LD_INT 105
5737: PPUSH
5738: LD_INT 14
5740: PPUSH
5741: LD_INT 20
5743: PPUSH
5744: CALL 20899 0 4
5748: PUSH
5749: LD_INT 4
5751: ARRAY
5752: PUSH
5753: LD_INT 10
5755: LESS
5756: IFFALSE 5779
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5758: LD_VAR 0 1
5762: PUSH
5763: LD_INT 1
5765: ARRAY
5766: PPUSH
5767: LD_INT 105
5769: PPUSH
5770: LD_INT 14
5772: PPUSH
5773: CALL_OW 171
5777: GO 5798
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5779: LD_VAR 0 1
5783: PUSH
5784: LD_INT 1
5786: ARRAY
5787: PPUSH
5788: LD_INT 118
5790: PPUSH
5791: LD_INT 77
5793: PPUSH
5794: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5798: LD_VAR 0 1
5802: PUSH
5803: LD_INT 1
5805: ARRAY
5806: PPUSH
5807: LD_INT 92
5809: PPUSH
5810: LD_INT 40
5812: PPUSH
5813: CALL_OW 218
// end ;
5817: PPOPN 1
5819: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5820: LD_INT 1
5822: PPUSH
5823: CALL_OW 302
5827: PUSH
5828: LD_EXP 9
5832: AND
5833: IFFALSE 6312
5835: GO 5837
5837: DISABLE
5838: LD_INT 0
5840: PPUSH
5841: PPUSH
5842: PPUSH
5843: PPUSH
5844: PPUSH
5845: PPUSH
// begin enable ;
5846: ENABLE
// base := 1 ;
5847: LD_ADDR_VAR 0 2
5851: PUSH
5852: LD_INT 1
5854: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5855: LD_ADDR_VAR 0 4
5859: PUSH
5860: LD_INT 0
5862: PUSH
5863: LD_INT 0
5865: PUSH
5866: LD_INT 0
5868: PUSH
5869: LD_INT 0
5871: PUSH
5872: LD_INT 0
5874: PUSH
5875: LD_INT 0
5877: PUSH
5878: LD_INT 0
5880: PUSH
5881: LD_INT 0
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 0
5889: PUSH
5890: EMPTY
5891: LIST
5892: LIST
5893: LIST
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5902: LD_ADDR_VAR 0 3
5906: PUSH
5907: LD_INT 14
5909: PUSH
5910: LD_INT 1
5912: PUSH
5913: LD_INT 2
5915: PUSH
5916: LD_INT 26
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 14
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 28
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 13
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 29
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5966: LD_ADDR_VAR 0 1
5970: PUSH
5971: DOUBLE
5972: LD_INT 1
5974: DEC
5975: ST_TO_ADDR
5976: LD_OWVAR 67
5980: PUSH
5981: LD_OWVAR 1
5985: PUSH
5986: LD_INT 21000
5988: DIV
5989: PLUS
5990: PUSH
5991: FOR_TO
5992: IFFALSE 6084
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5994: LD_ADDR_VAR 0 3
5998: PUSH
5999: LD_VAR 0 3
6003: PPUSH
6004: LD_VAR 0 3
6008: PUSH
6009: LD_INT 1
6011: PLUS
6012: PPUSH
6013: LD_INT 13
6015: PUSH
6016: LD_INT 14
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 1
6025: PPUSH
6026: LD_INT 2
6028: PPUSH
6029: CALL_OW 12
6033: ARRAY
6034: PUSH
6035: LD_INT 1
6037: PUSH
6038: LD_INT 2
6040: PUSH
6041: LD_INT 28
6043: PUSH
6044: LD_INT 29
6046: PUSH
6047: LD_INT 25
6049: PUSH
6050: LD_INT 26
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: LD_INT 1
6061: PPUSH
6062: LD_INT 4
6064: PPUSH
6065: CALL_OW 12
6069: ARRAY
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: LIST
6076: PPUSH
6077: CALL_OW 2
6081: ST_TO_ADDR
6082: GO 5991
6084: POP
6085: POP
// MC_InsertProduceList ( base , tmp ) ;
6086: LD_VAR 0 2
6090: PPUSH
6091: LD_VAR 0 3
6095: PPUSH
6096: CALL 79672 0 2
// repeat wait ( 0 0$1 ) ;
6100: LD_INT 35
6102: PPUSH
6103: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6107: LD_EXP 79
6111: PUSH
6112: LD_VAR 0 2
6116: ARRAY
6117: PUSH
6118: LD_INT 6
6120: GREATER
6121: IFFALSE 6100
// wait ( 0 0$20 ) ;
6123: LD_INT 700
6125: PPUSH
6126: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6130: LD_ADDR_VAR 0 5
6134: PUSH
6135: LD_INT 124
6137: PUSH
6138: LD_INT 85
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: PUSH
6145: LD_INT 90
6147: PUSH
6148: LD_INT 61
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: PUSH
6155: LD_INT 69
6157: PUSH
6158: LD_INT 48
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PUSH
6165: LD_INT 68
6167: PUSH
6168: LD_INT 48
6170: PUSH
6171: EMPTY
6172: LIST
6173: LIST
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6181: LD_ADDR_VAR 0 6
6185: PUSH
6186: LD_EXP 79
6190: PUSH
6191: LD_VAR 0 2
6195: ARRAY
6196: PUSH
6197: LD_EXP 79
6201: PUSH
6202: LD_VAR 0 2
6206: ARRAY
6207: PPUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 34
6213: PUSH
6214: LD_INT 32
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: PUSH
6221: LD_INT 34
6223: PUSH
6224: LD_EXP 110
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: CALL_OW 72
6242: DIFF
6243: ST_TO_ADDR
// if not attackers then
6244: LD_VAR 0 6
6248: NOT
6249: IFFALSE 6253
// exit ;
6251: GO 6312
// ar_attackers := attackers ;
6253: LD_ADDR_EXP 11
6257: PUSH
6258: LD_VAR 0 6
6262: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6263: LD_INT 35
6265: PPUSH
6266: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6270: LD_VAR 0 6
6274: PPUSH
6275: LD_INT 60
6277: PUSH
6278: EMPTY
6279: LIST
6280: PPUSH
6281: CALL_OW 72
6285: NOT
6286: IFFALSE 6263
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6288: LD_VAR 0 2
6292: PPUSH
6293: LD_VAR 0 6
6297: PPUSH
6298: LD_VAR 0 5
6302: PPUSH
6303: LD_VAR 0 4
6307: PPUSH
6308: CALL 79857 0 4
// end ;
6312: PPOPN 6
6314: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6315: LD_INT 1
6317: PPUSH
6318: CALL_OW 302
6322: PUSH
6323: LD_EXP 9
6327: AND
6328: PUSH
6329: LD_EXP 50
6333: PPUSH
6334: LD_INT 22
6336: PPUSH
6337: CALL_OW 308
6341: AND
6342: PUSH
6343: LD_INT 1
6345: PPUSH
6346: CALL 80020 0 1
6350: PUSH
6351: LD_INT 0
6353: EQUAL
6354: AND
6355: PUSH
6356: LD_EXP 11
6360: NOT
6361: AND
6362: IFFALSE 6850
6364: GO 6366
6366: DISABLE
6367: LD_INT 0
6369: PPUSH
6370: PPUSH
6371: PPUSH
6372: PPUSH
6373: PPUSH
6374: PPUSH
6375: PPUSH
// begin base := 1 ;
6376: LD_ADDR_VAR 0 2
6380: PUSH
6381: LD_INT 1
6383: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6384: LD_ADDR_VAR 0 4
6388: PUSH
6389: LD_INT 0
6391: PUSH
6392: LD_INT 0
6394: PUSH
6395: LD_INT 0
6397: PUSH
6398: LD_INT 0
6400: PUSH
6401: LD_INT 0
6403: PUSH
6404: LD_INT 0
6406: PUSH
6407: LD_INT 0
6409: PUSH
6410: LD_INT 0
6412: PUSH
6413: LD_INT 1
6415: PUSH
6416: LD_INT 0
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6431: LD_ADDR_VAR 0 3
6435: PUSH
6436: LD_INT 13
6438: PUSH
6439: LD_INT 1
6441: PUSH
6442: LD_INT 2
6444: PUSH
6445: LD_INT 28
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 13
6456: PUSH
6457: LD_INT 1
6459: PUSH
6460: LD_INT 2
6462: PUSH
6463: LD_INT 27
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 13
6474: PUSH
6475: LD_INT 1
6477: PUSH
6478: LD_INT 2
6480: PUSH
6481: LD_INT 25
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 11
6492: PUSH
6493: LD_INT 2
6495: PUSH
6496: LD_INT 2
6498: PUSH
6499: LD_INT 24
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 11
6510: PUSH
6511: LD_INT 2
6513: PUSH
6514: LD_INT 2
6516: PUSH
6517: LD_INT 24
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: LIST
6532: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6533: LD_VAR 0 2
6537: PPUSH
6538: LD_VAR 0 3
6542: PPUSH
6543: CALL 79672 0 2
// repeat wait ( 0 0$1 ) ;
6547: LD_INT 35
6549: PPUSH
6550: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6554: LD_EXP 79
6558: PUSH
6559: LD_VAR 0 2
6563: ARRAY
6564: PUSH
6565: LD_INT 6
6567: GREATEREQUAL
6568: IFFALSE 6547
// wait ( 0 0$20 ) ;
6570: LD_INT 700
6572: PPUSH
6573: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6577: LD_ADDR_VAR 0 5
6581: PUSH
6582: LD_INT 119
6584: PUSH
6585: LD_INT 9
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PUSH
6592: EMPTY
6593: LIST
6594: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6595: LD_ADDR_VAR 0 6
6599: PUSH
6600: LD_EXP 79
6604: PUSH
6605: LD_VAR 0 2
6609: ARRAY
6610: PUSH
6611: LD_EXP 79
6615: PUSH
6616: LD_VAR 0 2
6620: ARRAY
6621: PPUSH
6622: LD_INT 2
6624: PUSH
6625: LD_INT 34
6627: PUSH
6628: LD_INT 32
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: PUSH
6635: LD_INT 34
6637: PUSH
6638: LD_EXP 110
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: PPUSH
6652: CALL_OW 72
6656: DIFF
6657: ST_TO_ADDR
// if not attackers then
6658: LD_VAR 0 6
6662: NOT
6663: IFFALSE 6667
// exit ;
6665: GO 6850
// uc_side := 2 ;
6667: LD_ADDR_OWVAR 20
6671: PUSH
6672: LD_INT 2
6674: ST_TO_ADDR
// uc_nation := 2 ;
6675: LD_ADDR_OWVAR 21
6679: PUSH
6680: LD_INT 2
6682: ST_TO_ADDR
// InitHc ;
6683: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
6687: LD_ADDR_VAR 0 1
6691: PUSH
6692: DOUBLE
6693: LD_INT 1
6695: DEC
6696: ST_TO_ADDR
6697: LD_INT 4
6699: PUSH
6700: LD_INT 5
6702: PUSH
6703: LD_INT 6
6705: PUSH
6706: LD_INT 6
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: PUSH
6715: LD_OWVAR 67
6719: ARRAY
6720: PUSH
6721: FOR_TO
6722: IFFALSE 6799
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6724: LD_INT 0
6726: PPUSH
6727: LD_INT 15
6729: PUSH
6730: LD_INT 17
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PUSH
6737: LD_INT 1
6739: PPUSH
6740: LD_INT 2
6742: PPUSH
6743: CALL_OW 12
6747: ARRAY
6748: PPUSH
6749: LD_INT 8
6751: PPUSH
6752: CALL_OW 380
// un := CreateHuman ;
6756: LD_ADDR_VAR 0 7
6760: PUSH
6761: CALL_OW 44
6765: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6766: LD_VAR 0 7
6770: PPUSH
6771: LD_INT 23
6773: PPUSH
6774: LD_INT 0
6776: PPUSH
6777: CALL_OW 49
// attackers := attackers union un ;
6781: LD_ADDR_VAR 0 6
6785: PUSH
6786: LD_VAR 0 6
6790: PUSH
6791: LD_VAR 0 7
6795: UNION
6796: ST_TO_ADDR
// end ;
6797: GO 6721
6799: POP
6800: POP
// repeat wait ( 0 0$1 ) ;
6801: LD_INT 35
6803: PPUSH
6804: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6808: LD_VAR 0 6
6812: PPUSH
6813: LD_INT 60
6815: PUSH
6816: EMPTY
6817: LIST
6818: PPUSH
6819: CALL_OW 72
6823: NOT
6824: IFFALSE 6801
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6826: LD_VAR 0 2
6830: PPUSH
6831: LD_VAR 0 6
6835: PPUSH
6836: LD_VAR 0 5
6840: PPUSH
6841: LD_VAR 0 4
6845: PPUSH
6846: CALL 79857 0 4
// end ; end_of_file
6850: PPOPN 7
6852: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
6859: PPUSH
6860: PPUSH
// uc_side := 1 ;
6861: LD_ADDR_OWVAR 20
6865: PUSH
6866: LD_INT 1
6868: ST_TO_ADDR
// uc_nation := 1 ;
6869: LD_ADDR_OWVAR 21
6873: PUSH
6874: LD_INT 1
6876: ST_TO_ADDR
// InitHc ;
6877: CALL_OW 19
// InitVc ;
6881: CALL_OW 20
// tmp := [ ] ;
6885: LD_ADDR_VAR 0 3
6889: PUSH
6890: EMPTY
6891: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: DOUBLE
6898: LD_INT 1
6900: DEC
6901: ST_TO_ADDR
6902: LD_INT 6
6904: PUSH
6905: LD_INT 8
6907: PUSH
6908: LD_INT 10
6910: PUSH
6911: LD_INT 10
6913: PUSH
6914: EMPTY
6915: LIST
6916: LIST
6917: LIST
6918: LIST
6919: PUSH
6920: LD_OWVAR 67
6924: ARRAY
6925: PUSH
6926: FOR_TO
6927: IFFALSE 7201
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6929: LD_ADDR_VAR 0 5
6933: PUSH
6934: LD_INT 2
6936: PUSH
6937: LD_INT 4
6939: PUSH
6940: LD_INT 5
6942: PUSH
6943: EMPTY
6944: LIST
6945: LIST
6946: LIST
6947: PUSH
6948: LD_INT 1
6950: PPUSH
6951: LD_INT 3
6953: PPUSH
6954: CALL_OW 12
6958: ARRAY
6959: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6960: LD_VAR 0 5
6964: PUSH
6965: LD_INT 2
6967: DOUBLE
6968: EQUAL
6969: IFTRUE 6973
6971: GO 7007
6973: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
6974: LD_ADDR_VAR 0 6
6978: PUSH
6979: LD_INT 9
6981: PUSH
6982: LD_INT 5
6984: PUSH
6985: LD_INT 7
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: LIST
6992: PUSH
6993: LD_INT 1
6995: PPUSH
6996: LD_INT 3
6998: PPUSH
6999: CALL_OW 12
7003: ARRAY
7004: ST_TO_ADDR
7005: GO 7096
7007: LD_INT 4
7009: DOUBLE
7010: EQUAL
7011: IFTRUE 7015
7013: GO 7053
7015: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7016: LD_ADDR_VAR 0 6
7020: PUSH
7021: LD_INT 9
7023: PUSH
7024: LD_INT 6
7026: PUSH
7027: LD_INT 6
7029: PUSH
7030: LD_INT 7
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: LIST
7037: LIST
7038: PUSH
7039: LD_INT 1
7041: PPUSH
7042: LD_INT 4
7044: PPUSH
7045: CALL_OW 12
7049: ARRAY
7050: ST_TO_ADDR
7051: GO 7096
7053: LD_INT 5
7055: DOUBLE
7056: EQUAL
7057: IFTRUE 7061
7059: GO 7095
7061: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7062: LD_ADDR_VAR 0 6
7066: PUSH
7067: LD_INT 9
7069: PUSH
7070: LD_INT 6
7072: PUSH
7073: LD_INT 7
7075: PUSH
7076: EMPTY
7077: LIST
7078: LIST
7079: LIST
7080: PUSH
7081: LD_INT 1
7083: PPUSH
7084: LD_INT 3
7086: PPUSH
7087: CALL_OW 12
7091: ARRAY
7092: ST_TO_ADDR
7093: GO 7096
7095: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7096: LD_VAR 0 5
7100: PPUSH
7101: LD_INT 1
7103: PUSH
7104: LD_INT 3
7106: PUSH
7107: EMPTY
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 1
7113: PPUSH
7114: LD_INT 2
7116: PPUSH
7117: CALL_OW 12
7121: ARRAY
7122: PPUSH
7123: LD_INT 3
7125: PPUSH
7126: LD_VAR 0 6
7130: PPUSH
7131: LD_INT 70
7133: PPUSH
7134: LD_INT 90
7136: PPUSH
7137: CALL_OW 12
7141: PPUSH
7142: CALL 19881 0 5
// veh := CreateVehicle ;
7146: LD_ADDR_VAR 0 4
7150: PUSH
7151: CALL_OW 45
7155: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7156: LD_VAR 0 4
7160: PPUSH
7161: LD_INT 2
7163: PPUSH
7164: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7168: LD_VAR 0 4
7172: PPUSH
7173: LD_INT 17
7175: PPUSH
7176: LD_INT 0
7178: PPUSH
7179: CALL_OW 49
// tmp := tmp ^ veh ;
7183: LD_ADDR_VAR 0 3
7187: PUSH
7188: LD_VAR 0 3
7192: PUSH
7193: LD_VAR 0 4
7197: ADD
7198: ST_TO_ADDR
// end ;
7199: GO 6926
7201: POP
7202: POP
// if not tmp then
7203: LD_VAR 0 3
7207: NOT
7208: IFFALSE 7212
// exit ;
7210: GO 7321
// if not first_powell_attack then
7212: LD_EXP 12
7216: NOT
7217: IFFALSE 7227
// first_powell_attack := true ;
7219: LD_ADDR_EXP 12
7223: PUSH
7224: LD_INT 1
7226: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7227: LD_INT 70
7229: PPUSH
7230: CALL_OW 67
// for i in tmp do
7234: LD_ADDR_VAR 0 2
7238: PUSH
7239: LD_VAR 0 3
7243: PUSH
7244: FOR_IN
7245: IFFALSE 7312
// if IsOk ( i ) then
7247: LD_VAR 0 2
7251: PPUSH
7252: CALL_OW 302
7256: IFFALSE 7294
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7258: LD_VAR 0 2
7262: PPUSH
7263: LD_INT 81
7265: PUSH
7266: LD_INT 1
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: PPUSH
7273: CALL_OW 69
7277: PPUSH
7278: LD_VAR 0 2
7282: PPUSH
7283: CALL_OW 74
7287: PPUSH
7288: CALL_OW 115
7292: GO 7310
// tmp := tmp diff i ;
7294: LD_ADDR_VAR 0 3
7298: PUSH
7299: LD_VAR 0 3
7303: PUSH
7304: LD_VAR 0 2
7308: DIFF
7309: ST_TO_ADDR
7310: GO 7244
7312: POP
7313: POP
// until not tmp ;
7314: LD_VAR 0 3
7318: NOT
7319: IFFALSE 7227
// end ; end_of_file
7321: LD_VAR 0 1
7325: RET
// export function Action ; var tmp , i , un ; begin
7326: LD_INT 0
7328: PPUSH
7329: PPUSH
7330: PPUSH
7331: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7332: LD_INT 68
7334: PPUSH
7335: LD_INT 39
7337: PPUSH
7338: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7342: LD_ADDR_VAR 0 2
7346: PUSH
7347: LD_INT 22
7349: PUSH
7350: LD_INT 7
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: PPUSH
7357: CALL_OW 69
7361: ST_TO_ADDR
// InGameOn ;
7362: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7366: LD_VAR 0 2
7370: PPUSH
7371: LD_INT 71
7373: PPUSH
7374: LD_INT 49
7376: PPUSH
7377: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7381: LD_INT 35
7383: PPUSH
7384: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7388: LD_INT 7
7390: PPUSH
7391: LD_INT 71
7393: PPUSH
7394: LD_INT 51
7396: PPUSH
7397: CALL_OW 293
7401: IFFALSE 7381
// DialogueOn ;
7403: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7407: LD_EXP 16
7411: PPUSH
7412: LD_STRING D1-JMM-1
7414: PPUSH
7415: CALL_OW 88
// if Joan then
7419: LD_EXP 31
7423: IFFALSE 7437
// Say ( Joan , D1-Joan-1 ) ;
7425: LD_EXP 31
7429: PPUSH
7430: LD_STRING D1-Joan-1
7432: PPUSH
7433: CALL_OW 88
// if Lisa then
7437: LD_EXP 18
7441: IFFALSE 7455
// Say ( Lisa , D1-Lisa-1 ) ;
7443: LD_EXP 18
7447: PPUSH
7448: LD_STRING D1-Lisa-1
7450: PPUSH
7451: CALL_OW 88
// if Joan or Lisa then
7455: LD_EXP 31
7459: PUSH
7460: LD_EXP 18
7464: OR
7465: IFFALSE 7479
// Say ( JMM , D1-JMM-2 ) ;
7467: LD_EXP 16
7471: PPUSH
7472: LD_STRING D1-JMM-2
7474: PPUSH
7475: CALL_OW 88
// DialogueOff ;
7479: CALL_OW 7
// InGameOff ;
7483: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7487: LD_INT 71
7489: PPUSH
7490: LD_INT 50
7492: PPUSH
7493: LD_INT 7
7495: PPUSH
7496: LD_INT 30
7498: NEG
7499: PPUSH
7500: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7504: LD_INT 71
7506: PPUSH
7507: LD_INT 50
7509: PPUSH
7510: LD_INT 7
7512: PPUSH
7513: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7517: LD_STRING M1
7519: PPUSH
7520: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7524: LD_INT 35
7526: PPUSH
7527: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7531: LD_EXP 3
7535: PUSH
7536: LD_OWVAR 1
7540: PUSH
7541: LD_INT 2100
7543: GREATER
7544: OR
7545: IFFALSE 7524
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7547: LD_INT 350
7549: PPUSH
7550: LD_INT 700
7552: PPUSH
7553: CALL_OW 12
7557: PPUSH
7558: CALL_OW 67
// PrepareGossudarov ;
7562: CALL 1881 0 0
// repeat wait ( 0 0$1 ) ;
7566: LD_INT 35
7568: PPUSH
7569: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7573: LD_INT 22
7575: PUSH
7576: LD_INT 6
7578: PUSH
7579: EMPTY
7580: LIST
7581: LIST
7582: PUSH
7583: LD_INT 3
7585: PUSH
7586: LD_INT 24
7588: PUSH
7589: LD_INT 1000
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: PUSH
7600: EMPTY
7601: LIST
7602: LIST
7603: PPUSH
7604: CALL_OW 69
7608: PUSH
7609: LD_INT 7
7611: PPUSH
7612: LD_EXP 33
7616: PPUSH
7617: CALL_OW 292
7621: OR
7622: IFFALSE 7566
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7624: LD_ADDR_VAR 0 2
7628: PUSH
7629: LD_INT 22
7631: PUSH
7632: LD_INT 6
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PPUSH
7639: CALL_OW 69
7643: ST_TO_ADDR
// for i in tmp do
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_VAR 0 2
7653: PUSH
7654: FOR_IN
7655: IFFALSE 7671
// SetSide ( i , 7 ) ;
7657: LD_VAR 0 3
7661: PPUSH
7662: LD_INT 7
7664: PPUSH
7665: CALL_OW 235
7669: GO 7654
7671: POP
7672: POP
// DialogueOn ;
7673: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7677: LD_EXP 16
7681: PUSH
7682: LD_EXP 17
7686: PUSH
7687: EMPTY
7688: LIST
7689: LIST
7690: PPUSH
7691: LD_EXP 33
7695: PPUSH
7696: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7700: LD_EXP 33
7704: PPUSH
7705: CALL_OW 87
// if not Roth then
7709: LD_EXP 17
7713: NOT
7714: IFFALSE 7806
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7716: LD_VAR 0 2
7720: PPUSH
7721: LD_INT 3
7723: PUSH
7724: LD_INT 24
7726: PUSH
7727: LD_INT 1000
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PUSH
7734: EMPTY
7735: LIST
7736: LIST
7737: PPUSH
7738: CALL_OW 72
7742: IFFALSE 7756
// Say ( JMM , D2-JMM-1 ) ;
7744: LD_EXP 16
7748: PPUSH
7749: LD_STRING D2-JMM-1
7751: PPUSH
7752: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7756: LD_EXP 16
7760: PPUSH
7761: LD_STRING D2-JMM-1b
7763: PPUSH
7764: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7768: LD_EXP 33
7772: PPUSH
7773: LD_STRING D2-Gos-1
7775: PPUSH
7776: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7780: LD_EXP 16
7784: PPUSH
7785: LD_STRING D2-JMM-2
7787: PPUSH
7788: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7792: LD_EXP 33
7796: PPUSH
7797: LD_STRING D2-Gos-2
7799: PPUSH
7800: CALL_OW 88
// end else
7804: GO 7958
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7806: LD_VAR 0 2
7810: PPUSH
7811: LD_INT 3
7813: PUSH
7814: LD_INT 24
7816: PUSH
7817: LD_INT 1000
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: PPUSH
7828: CALL_OW 72
7832: IFFALSE 7858
// begin Say ( Roth , D2-Roth-2 ) ;
7834: LD_EXP 17
7838: PPUSH
7839: LD_STRING D2-Roth-2
7841: PPUSH
7842: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7846: LD_EXP 16
7850: PPUSH
7851: LD_STRING D2-JMM-1a
7853: PPUSH
7854: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7858: LD_EXP 17
7862: PPUSH
7863: LD_STRING D2-Roth-2a
7865: PPUSH
7866: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7870: LD_EXP 17
7874: PPUSH
7875: LD_STRING D2-Roth-2b
7877: PPUSH
7878: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7882: LD_EXP 16
7886: PPUSH
7887: LD_STRING D2-JMM-3
7889: PPUSH
7890: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7894: LD_VAR 0 2
7898: PPUSH
7899: LD_INT 3
7901: PUSH
7902: LD_INT 24
7904: PUSH
7905: LD_INT 1000
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PPUSH
7916: CALL_OW 72
7920: IFFALSE 7958
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7922: LD_EXP 33
7926: PPUSH
7927: LD_STRING D2-Gos-3
7929: PPUSH
7930: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7934: LD_EXP 16
7938: PPUSH
7939: LD_STRING D2-JMM-4
7941: PPUSH
7942: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7946: LD_EXP 33
7950: PPUSH
7951: LD_STRING D2-Gos-4
7953: PPUSH
7954: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7958: LD_EXP 16
7962: PPUSH
7963: LD_STRING D2-JMM-5
7965: PPUSH
7966: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7970: LD_EXP 33
7974: PPUSH
7975: LD_STRING D2-Gos-5
7977: PPUSH
7978: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7982: LD_EXP 16
7986: PPUSH
7987: LD_STRING D2-JMM-6
7989: PPUSH
7990: CALL_OW 88
// DialogueOff ;
7994: CALL_OW 7
// wait ( 0 0$2 ) ;
7998: LD_INT 70
8000: PPUSH
8001: CALL_OW 67
// if Kirilenkova then
8005: LD_EXP 34
8009: IFFALSE 8023
// Say ( Kirilenkova , D3-Kir-1 ) ;
8011: LD_EXP 34
8015: PPUSH
8016: LD_STRING D3-Kir-1
8018: PPUSH
8019: CALL_OW 88
// gossudarov_arrive := true ;
8023: LD_ADDR_EXP 4
8027: PUSH
8028: LD_INT 1
8030: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8031: LD_INT 35
8033: PPUSH
8034: CALL_OW 67
// until ru_lab_builded ;
8038: LD_EXP 5
8042: IFFALSE 8031
// DialogueOn ;
8044: CALL_OW 6
// if Kirilenkova then
8048: LD_EXP 34
8052: IFFALSE 8068
// Say ( Kirilenkova , D3a-Kir-1 ) else
8054: LD_EXP 34
8058: PPUSH
8059: LD_STRING D3a-Kir-1
8061: PPUSH
8062: CALL_OW 88
8066: GO 8090
// begin un := SciRu ;
8068: LD_ADDR_VAR 0 4
8072: PUSH
8073: CALL 13248 0 0
8077: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8078: LD_VAR 0 4
8082: PPUSH
8083: LD_STRING D3a-Sci1-1
8085: PPUSH
8086: CALL_OW 88
// end ; if Kirilenkova or un then
8090: LD_EXP 34
8094: PUSH
8095: LD_VAR 0 4
8099: OR
8100: IFFALSE 8114
// Say ( JMM , D3a-JMM-1 ) ;
8102: LD_EXP 16
8106: PPUSH
8107: LD_STRING D3a-JMM-1
8109: PPUSH
8110: CALL_OW 88
// DialogueOff ;
8114: CALL_OW 7
// end ;
8118: LD_VAR 0 1
8122: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8123: LD_EXP 4
8127: PUSH
8128: LD_INT 22
8130: PUSH
8131: LD_INT 7
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PUSH
8138: LD_INT 2
8140: PUSH
8141: LD_INT 25
8143: PUSH
8144: LD_INT 1
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: PUSH
8151: LD_INT 25
8153: PUSH
8154: LD_INT 2
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PUSH
8161: LD_INT 25
8163: PUSH
8164: LD_INT 3
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PUSH
8171: LD_INT 25
8173: PUSH
8174: LD_INT 4
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 25
8183: PUSH
8184: LD_INT 5
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 25
8193: PUSH
8194: LD_INT 8
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: LD_INT 25
8203: PUSH
8204: LD_INT 9
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: LIST
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PUSH
8230: LD_INT 7
8232: LESS
8233: AND
8234: IFFALSE 8246
8236: GO 8238
8238: DISABLE
// YouLost ( TooMany ) ;
8239: LD_STRING TooMany
8241: PPUSH
8242: CALL_OW 104
8246: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8247: LD_EXP 33
8251: PPUSH
8252: CALL_OW 255
8256: PUSH
8257: LD_INT 7
8259: EQUAL
8260: IFFALSE 8477
8262: GO 8264
8264: DISABLE
8265: LD_INT 0
8267: PPUSH
8268: PPUSH
8269: PPUSH
// begin uc_side := 3 ;
8270: LD_ADDR_OWVAR 20
8274: PUSH
8275: LD_INT 3
8277: ST_TO_ADDR
// uc_nation := 3 ;
8278: LD_ADDR_OWVAR 21
8282: PUSH
8283: LD_INT 3
8285: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8286: LD_INT 21
8288: PPUSH
8289: LD_INT 3
8291: PPUSH
8292: LD_INT 3
8294: PPUSH
8295: LD_INT 42
8297: PPUSH
8298: LD_INT 100
8300: PPUSH
8301: CALL 19881 0 5
// un := CreateVehicle ;
8305: LD_ADDR_VAR 0 3
8309: PUSH
8310: CALL_OW 45
8314: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8315: LD_VAR 0 3
8319: PPUSH
8320: LD_INT 15
8322: PPUSH
8323: LD_INT 0
8325: PPUSH
8326: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8330: LD_VAR 0 3
8334: PPUSH
8335: LD_INT 67
8337: PPUSH
8338: LD_INT 45
8340: PPUSH
8341: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8345: LD_VAR 0 3
8349: PPUSH
8350: LD_INT 70
8352: PPUSH
8353: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8357: LD_VAR 0 3
8361: PPUSH
8362: LD_INT 69
8364: PPUSH
8365: LD_INT 18
8367: PPUSH
8368: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8372: LD_VAR 0 3
8376: PPUSH
8377: LD_INT 60
8379: PPUSH
8380: LD_INT 3
8382: PPUSH
8383: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8387: LD_INT 35
8389: PPUSH
8390: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8394: LD_VAR 0 3
8398: PPUSH
8399: CALL_OW 302
8403: NOT
8404: PUSH
8405: LD_VAR 0 3
8409: PPUSH
8410: LD_INT 17
8412: PPUSH
8413: CALL_OW 308
8417: OR
8418: PUSH
8419: LD_VAR 0 3
8423: PPUSH
8424: LD_INT 60
8426: PPUSH
8427: LD_INT 3
8429: PPUSH
8430: CALL_OW 307
8434: OR
8435: IFFALSE 8387
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8437: LD_VAR 0 3
8441: PPUSH
8442: LD_INT 17
8444: PPUSH
8445: CALL_OW 308
8449: PUSH
8450: LD_VAR 0 3
8454: PPUSH
8455: LD_INT 60
8457: PPUSH
8458: LD_INT 3
8460: PPUSH
8461: CALL_OW 307
8465: OR
8466: IFFALSE 8477
// RemoveUnit ( un ) ;
8468: LD_VAR 0 3
8472: PPUSH
8473: CALL_OW 64
// end ;
8477: PPOPN 3
8479: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8480: LD_EXP 4
8484: IFFALSE 8726
8486: GO 8488
8488: DISABLE
8489: LD_INT 0
8491: PPUSH
8492: PPUSH
8493: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8494: LD_INT 70
8496: PPUSH
8497: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8501: LD_ADDR_VAR 0 3
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 7
8511: PUSH
8512: EMPTY
8513: LIST
8514: LIST
8515: PUSH
8516: LD_INT 101
8518: PUSH
8519: LD_INT 3
8521: PUSH
8522: EMPTY
8523: LIST
8524: LIST
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PPUSH
8530: CALL_OW 69
8534: ST_TO_ADDR
// until tmp ;
8535: LD_VAR 0 3
8539: IFFALSE 8494
// un := NearestUnitToUnit ( tmp , JMM ) ;
8541: LD_ADDR_VAR 0 2
8545: PUSH
8546: LD_VAR 0 3
8550: PPUSH
8551: LD_EXP 16
8555: PPUSH
8556: CALL_OW 74
8560: ST_TO_ADDR
// player_spotted := true ;
8561: LD_ADDR_EXP 6
8565: PUSH
8566: LD_INT 1
8568: ST_TO_ADDR
// tmp := SciRu ;
8569: LD_ADDR_VAR 0 3
8573: PUSH
8574: CALL 13248 0 0
8578: ST_TO_ADDR
// if not tmp then
8579: LD_VAR 0 3
8583: NOT
8584: IFFALSE 8596
// tmp := SolRu ;
8586: LD_ADDR_VAR 0 3
8590: PUSH
8591: CALL 13395 0 0
8595: ST_TO_ADDR
// DialogueOn ;
8596: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8600: LD_VAR 0 2
8604: PPUSH
8605: CALL_OW 250
8609: PPUSH
8610: LD_VAR 0 2
8614: PPUSH
8615: CALL_OW 251
8619: PPUSH
8620: LD_INT 7
8622: PPUSH
8623: LD_INT 8
8625: NEG
8626: PPUSH
8627: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8631: LD_VAR 0 2
8635: PPUSH
8636: CALL_OW 87
// if tmp then
8640: LD_VAR 0 3
8644: IFFALSE 8658
// Say ( tmp , D4-RSci1-1 ) ;
8646: LD_VAR 0 3
8650: PPUSH
8651: LD_STRING D4-RSci1-1
8653: PPUSH
8654: CALL_OW 88
// if Gossudarov then
8658: LD_EXP 33
8662: IFFALSE 8688
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8664: LD_EXP 33
8668: PPUSH
8669: LD_STRING D4-Gos-1
8671: PPUSH
8672: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8676: LD_EXP 16
8680: PPUSH
8681: LD_STRING D4-JMM-1
8683: PPUSH
8684: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8688: LD_VAR 0 2
8692: PPUSH
8693: CALL_OW 250
8697: PPUSH
8698: LD_VAR 0 2
8702: PPUSH
8703: CALL_OW 251
8707: PPUSH
8708: LD_INT 7
8710: PPUSH
8711: CALL_OW 331
// DialogueOff ;
8715: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8719: LD_STRING M5
8721: PPUSH
8722: CALL_OW 337
// end ;
8726: PPOPN 3
8728: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8729: LD_EXP 6
8733: IFFALSE 9326
8735: GO 8737
8737: DISABLE
8738: LD_INT 0
8740: PPUSH
8741: PPUSH
8742: PPUSH
// begin PrepareBelkov ;
8743: CALL 2194 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8747: LD_EXP 48
8751: PPUSH
8752: LD_INT 118
8754: PPUSH
8755: LD_INT 106
8757: PPUSH
8758: CALL_OW 111
// AddComHold ( Belkov ) ;
8762: LD_EXP 48
8766: PPUSH
8767: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8771: LD_INT 35
8773: PPUSH
8774: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8778: LD_EXP 48
8782: PPUSH
8783: LD_INT 118
8785: PPUSH
8786: LD_INT 106
8788: PPUSH
8789: CALL_OW 307
8793: IFFALSE 8771
// ChangeSideFog ( 4 , 7 ) ;
8795: LD_INT 4
8797: PPUSH
8798: LD_INT 7
8800: PPUSH
8801: CALL_OW 343
// if IsOk ( Belkov ) then
8805: LD_EXP 48
8809: PPUSH
8810: CALL_OW 302
8814: IFFALSE 8898
// begin InGameOn ;
8816: CALL_OW 8
// DialogueOn ;
8820: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8824: LD_EXP 48
8828: PPUSH
8829: LD_STRING D5-Bel-1
8831: PPUSH
8832: CALL_OW 94
// if Gossudarov then
8836: LD_EXP 33
8840: IFFALSE 8890
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8842: LD_EXP 33
8846: PPUSH
8847: LD_STRING D5-Gos-1
8849: PPUSH
8850: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8854: LD_EXP 16
8858: PPUSH
8859: LD_STRING D5-JMM-1
8861: PPUSH
8862: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8866: LD_EXP 33
8870: PPUSH
8871: LD_STRING D5-Gos-2
8873: PPUSH
8874: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8878: LD_EXP 16
8882: PPUSH
8883: LD_STRING D5-JMM-2
8885: PPUSH
8886: CALL_OW 88
// end ; DialogueOff ;
8890: CALL_OW 7
// InGameOff ;
8894: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8898: LD_STRING QSaveBelkov
8900: PPUSH
8901: CALL_OW 97
8905: PUSH
8906: LD_INT 1
8908: DOUBLE
8909: EQUAL
8910: IFTRUE 8914
8912: GO 8964
8914: POP
// begin DialogueOn ;
8915: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8919: LD_EXP 16
8923: PPUSH
8924: LD_STRING D5a-JMM-1
8926: PPUSH
8927: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8931: LD_EXP 48
8935: PPUSH
8936: LD_STRING D5a-Bel-1
8938: PPUSH
8939: CALL_OW 94
// DialogueOff ;
8943: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8947: LD_EXP 48
8951: PPUSH
8952: LD_INT 83
8954: PPUSH
8955: LD_INT 49
8957: PPUSH
8958: CALL_OW 111
// end ; 2 :
8962: GO 8997
8964: LD_INT 2
8966: DOUBLE
8967: EQUAL
8968: IFTRUE 8972
8970: GO 8996
8972: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8973: LD_EXP 16
8977: PPUSH
8978: LD_STRING D5a-JMM-2
8980: PPUSH
8981: CALL_OW 88
// ComHold ( Belkov ) ;
8985: LD_EXP 48
8989: PPUSH
8990: CALL_OW 140
// end ; end ;
8994: GO 8997
8996: POP
// time := 0 0$00 ;
8997: LD_ADDR_VAR 0 1
9001: PUSH
9002: LD_INT 0
9004: ST_TO_ADDR
// vehSpawned := false ;
9005: LD_ADDR_VAR 0 3
9009: PUSH
9010: LD_INT 0
9012: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9013: LD_INT 35
9015: PPUSH
9016: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9020: LD_VAR 0 1
9024: PUSH
9025: LD_INT 350
9027: PUSH
9028: LD_INT 175
9030: PUSH
9031: LD_INT 105
9033: PUSH
9034: LD_INT 70
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: PUSH
9043: LD_OWVAR 67
9047: ARRAY
9048: GREATEREQUAL
9049: PUSH
9050: LD_VAR 0 3
9054: NOT
9055: AND
9056: IFFALSE 9146
// begin vehSpawned := true ;
9058: LD_ADDR_VAR 0 3
9062: PUSH
9063: LD_INT 1
9065: ST_TO_ADDR
// uc_side := 3 ;
9066: LD_ADDR_OWVAR 20
9070: PUSH
9071: LD_INT 3
9073: ST_TO_ADDR
// uc_nation := 3 ;
9074: LD_ADDR_OWVAR 21
9078: PUSH
9079: LD_INT 3
9081: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9082: LD_INT 22
9084: PPUSH
9085: LD_INT 3
9087: PPUSH
9088: LD_INT 3
9090: PPUSH
9091: LD_INT 43
9093: PPUSH
9094: LD_INT 100
9096: PPUSH
9097: CALL 19881 0 5
// veh := CreateVehicle ;
9101: LD_ADDR_VAR 0 2
9105: PUSH
9106: CALL_OW 45
9110: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9111: LD_VAR 0 2
9115: PPUSH
9116: LD_INT 130
9118: PPUSH
9119: LD_INT 131
9121: PPUSH
9122: LD_INT 0
9124: PPUSH
9125: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9129: LD_VAR 0 2
9133: PPUSH
9134: LD_INT 100
9136: PPUSH
9137: LD_INT 82
9139: PPUSH
9140: CALL_OW 114
// end else
9144: GO 9160
// time := time + 0 0$1 ;
9146: LD_ADDR_VAR 0 1
9150: PUSH
9151: LD_VAR 0 1
9155: PUSH
9156: LD_INT 35
9158: PLUS
9159: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9160: LD_EXP 48
9164: PPUSH
9165: CALL_OW 301
9169: PUSH
9170: LD_EXP 48
9174: PPUSH
9175: CALL_OW 255
9179: PUSH
9180: LD_INT 4
9182: EQUAL
9183: AND
9184: PUSH
9185: LD_INT 22
9187: PUSH
9188: LD_INT 7
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PPUSH
9200: LD_EXP 48
9204: PPUSH
9205: CALL_OW 74
9209: PPUSH
9210: LD_EXP 48
9214: PPUSH
9215: CALL_OW 296
9219: PUSH
9220: LD_INT 10
9222: LESS
9223: OR
9224: IFFALSE 9013
// if IsDead ( Belkov ) then
9226: LD_EXP 48
9230: PPUSH
9231: CALL_OW 301
9235: IFFALSE 9260
// begin CenterNowOnUnits ( Belkov ) ;
9237: LD_EXP 48
9241: PPUSH
9242: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9246: LD_EXP 16
9250: PPUSH
9251: LD_STRING D5a-JMM-2a
9253: PPUSH
9254: CALL_OW 88
// exit ;
9258: GO 9326
// end ; if See ( 7 , Belkov ) then
9260: LD_INT 7
9262: PPUSH
9263: LD_EXP 48
9267: PPUSH
9268: CALL_OW 292
9272: IFFALSE 9286
// SetSide ( Belkov , 7 ) ;
9274: LD_EXP 48
9278: PPUSH
9279: LD_INT 7
9281: PPUSH
9282: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9286: LD_INT 35
9288: PPUSH
9289: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9293: LD_EXP 48
9297: PPUSH
9298: LD_INT 66
9300: PPUSH
9301: LD_INT 45
9303: PPUSH
9304: CALL_OW 297
9308: PUSH
9309: LD_INT 30
9311: LESS
9312: IFFALSE 9286
// Say ( Belkov , D6-Bel-1 ) ;
9314: LD_EXP 48
9318: PPUSH
9319: LD_STRING D6-Bel-1
9321: PPUSH
9322: CALL_OW 88
// end ;
9326: PPOPN 3
9328: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9329: LD_EXP 48
9333: PPUSH
9334: CALL_OW 302
9338: PUSH
9339: LD_EXP 48
9343: PPUSH
9344: CALL_OW 504
9348: PUSH
9349: LD_INT 2
9351: PUSH
9352: LD_INT 34
9354: PUSH
9355: LD_INT 47
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: PUSH
9362: LD_INT 34
9364: PUSH
9365: LD_INT 45
9367: PUSH
9368: EMPTY
9369: LIST
9370: LIST
9371: PUSH
9372: EMPTY
9373: LIST
9374: LIST
9375: LIST
9376: PPUSH
9377: CALL_OW 69
9381: IN
9382: AND
9383: IFFALSE 9400
9385: GO 9387
9387: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9388: LD_EXP 48
9392: PPUSH
9393: LD_STRING D7-Bel-1
9395: PPUSH
9396: CALL_OW 88
9400: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9401: LD_INT 22
9403: PUSH
9404: LD_INT 7
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 101
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: PPUSH
9425: CALL_OW 69
9429: PUSH
9430: LD_EXP 8
9434: NOT
9435: AND
9436: PUSH
9437: LD_EXP 47
9441: PPUSH
9442: CALL_OW 305
9446: NOT
9447: AND
9448: IFFALSE 9918
9450: GO 9452
9452: DISABLE
9453: LD_INT 0
9455: PPUSH
// begin ar_base_spotted := true ;
9456: LD_ADDR_EXP 8
9460: PUSH
9461: LD_INT 1
9463: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9464: LD_ADDR_VAR 0 1
9468: PUSH
9469: LD_INT 22
9471: PUSH
9472: LD_INT 2
9474: PUSH
9475: EMPTY
9476: LIST
9477: LIST
9478: PUSH
9479: LD_INT 21
9481: PUSH
9482: LD_INT 3
9484: PUSH
9485: EMPTY
9486: LIST
9487: LIST
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PPUSH
9493: CALL_OW 69
9497: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9498: LD_ADDR_VAR 0 1
9502: PUSH
9503: LD_VAR 0 1
9507: PPUSH
9508: LD_EXP 16
9512: PPUSH
9513: CALL_OW 74
9517: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9518: LD_INT 7
9520: PPUSH
9521: LD_INT 3
9523: PPUSH
9524: CALL_OW 332
// DialogueOn ;
9528: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9532: LD_VAR 0 1
9536: PPUSH
9537: CALL_OW 250
9541: PPUSH
9542: LD_VAR 0 1
9546: PPUSH
9547: CALL_OW 251
9551: PPUSH
9552: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9556: LD_ADDR_VAR 0 1
9560: PUSH
9561: LD_INT 22
9563: PUSH
9564: LD_INT 7
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: PUSH
9571: LD_INT 23
9573: PUSH
9574: LD_INT 1
9576: PUSH
9577: EMPTY
9578: LIST
9579: LIST
9580: PUSH
9581: LD_INT 26
9583: PUSH
9584: LD_INT 1
9586: PUSH
9587: EMPTY
9588: LIST
9589: LIST
9590: PUSH
9591: EMPTY
9592: LIST
9593: LIST
9594: LIST
9595: PPUSH
9596: CALL_OW 69
9600: PUSH
9601: LD_EXP 16
9605: PUSH
9606: LD_EXP 20
9610: PUSH
9611: LD_EXP 21
9615: PUSH
9616: LD_EXP 28
9620: PUSH
9621: LD_EXP 17
9625: PUSH
9626: LD_EXP 26
9630: PUSH
9631: LD_EXP 22
9635: PUSH
9636: LD_EXP 24
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: DIFF
9651: ST_TO_ADDR
// if not tmp then
9652: LD_VAR 0 1
9656: NOT
9657: IFFALSE 9731
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9659: LD_ADDR_VAR 0 1
9663: PUSH
9664: LD_INT 22
9666: PUSH
9667: LD_INT 7
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PUSH
9674: LD_INT 23
9676: PUSH
9677: LD_INT 1
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: PUSH
9684: LD_INT 26
9686: PUSH
9687: LD_INT 2
9689: PUSH
9690: EMPTY
9691: LIST
9692: LIST
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: LIST
9698: PPUSH
9699: CALL_OW 69
9703: PUSH
9704: LD_EXP 31
9708: PUSH
9709: LD_EXP 18
9713: PUSH
9714: LD_EXP 29
9718: PUSH
9719: LD_EXP 30
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: LIST
9728: LIST
9729: DIFF
9730: ST_TO_ADDR
// if tmp then
9731: LD_VAR 0 1
9735: IFFALSE 9806
// case GetSex ( tmp [ 1 ] ) of sex_male :
9737: LD_VAR 0 1
9741: PUSH
9742: LD_INT 1
9744: ARRAY
9745: PPUSH
9746: CALL_OW 258
9750: PUSH
9751: LD_INT 1
9753: DOUBLE
9754: EQUAL
9755: IFTRUE 9759
9757: GO 9778
9759: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9760: LD_VAR 0 1
9764: PUSH
9765: LD_INT 1
9767: ARRAY
9768: PPUSH
9769: LD_STRING D9-Sol1-1
9771: PPUSH
9772: CALL_OW 88
9776: GO 9806
9778: LD_INT 2
9780: DOUBLE
9781: EQUAL
9782: IFTRUE 9786
9784: GO 9805
9786: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9787: LD_VAR 0 1
9791: PUSH
9792: LD_INT 1
9794: ARRAY
9795: PPUSH
9796: LD_STRING D9-FSol1-1
9798: PPUSH
9799: CALL_OW 88
9803: GO 9806
9805: POP
// if Frank then
9806: LD_EXP 28
9810: IFFALSE 9914
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9812: LD_EXP 57
9816: PPUSH
9817: CALL_OW 250
9821: PPUSH
9822: LD_EXP 57
9826: PPUSH
9827: CALL_OW 251
9831: PPUSH
9832: LD_INT 7
9834: PPUSH
9835: LD_INT 8
9837: PPUSH
9838: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9842: LD_EXP 57
9846: PPUSH
9847: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9851: LD_EXP 28
9855: PPUSH
9856: LD_STRING D9-Frank-1
9858: PPUSH
9859: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9863: LD_EXP 16
9867: PPUSH
9868: LD_STRING D9-JMM-1
9870: PPUSH
9871: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9875: LD_EXP 28
9879: PPUSH
9880: LD_STRING D9-Frank-2
9882: PPUSH
9883: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9887: LD_EXP 57
9891: PPUSH
9892: CALL_OW 250
9896: PPUSH
9897: LD_EXP 57
9901: PPUSH
9902: CALL_OW 251
9906: PPUSH
9907: LD_INT 7
9909: PPUSH
9910: CALL_OW 331
// end ; DialogueOff ;
9914: CALL_OW 7
// end ;
9918: PPOPN 1
9920: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9921: LD_EXP 7
9925: PUSH
9926: LD_OWVAR 1
9930: PUSH
9931: LD_INT 42000
9933: GREATEREQUAL
9934: OR
9935: IFFALSE 10962
9937: GO 9939
9939: DISABLE
9940: LD_INT 0
9942: PPUSH
9943: PPUSH
// begin selected_option := 1 ;
9944: LD_ADDR_VAR 0 2
9948: PUSH
9949: LD_INT 1
9951: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9952: LD_INT 10500
9954: PPUSH
9955: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9959: LD_INT 35
9961: PPUSH
9962: CALL_OW 67
// until not ru_attackers ;
9966: LD_EXP 53
9970: NOT
9971: IFFALSE 9959
// PrepareBurlak ;
9973: CALL 2306 0 0
// repeat wait ( 0 0$2 ) ;
9977: LD_INT 70
9979: PPUSH
9980: CALL_OW 67
// until not HasTask ( Burlak ) ;
9984: LD_EXP 47
9988: PPUSH
9989: CALL_OW 314
9993: NOT
9994: IFFALSE 9977
// InGameOn ;
9996: CALL_OW 8
// DialogueOn ;
10000: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10004: LD_EXP 50
10008: PPUSH
10009: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10013: LD_EXP 47
10017: PPUSH
10018: LD_STRING D10-Bur-1
10020: PPUSH
10021: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10025: LD_EXP 48
10029: PUSH
10030: LD_EXP 48
10034: PPUSH
10035: CALL_OW 255
10039: PUSH
10040: LD_INT 7
10042: EQUAL
10043: AND
10044: IFFALSE 10058
// Say ( Belkov , D10-Bel-1 ) ;
10046: LD_EXP 48
10050: PPUSH
10051: LD_STRING D10-Bel-1
10053: PPUSH
10054: CALL_OW 88
// if Gossudarov then
10058: LD_EXP 33
10062: IFFALSE 10076
// Say ( Gossudarov , D10-Gos-1 ) ;
10064: LD_EXP 33
10068: PPUSH
10069: LD_STRING D10-Gos-1
10071: PPUSH
10072: CALL_OW 88
// if Kirilenkova then
10076: LD_EXP 34
10080: IFFALSE 10094
// Say ( Kirilenkova , D10-Kir-1 ) ;
10082: LD_EXP 34
10086: PPUSH
10087: LD_STRING D10-Kir-1
10089: PPUSH
10090: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10094: CALL 13395 0 0
10098: PPUSH
10099: LD_STRING D10-RSol1-1
10101: PPUSH
10102: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10106: LD_EXP 47
10110: PPUSH
10111: LD_STRING D10-Bur-2
10113: PPUSH
10114: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10118: LD_EXP 16
10122: PPUSH
10123: LD_STRING D10-JMM-2
10125: PPUSH
10126: CALL_OW 88
// if Kirilenkova then
10130: LD_EXP 34
10134: IFFALSE 10150
// Say ( Kirilenkova , D10-Kir-2 ) else
10136: LD_EXP 34
10140: PPUSH
10141: LD_STRING D10-Kir-2
10143: PPUSH
10144: CALL_OW 88
10148: GO 10162
// Say ( SolRu , D10-RSol1-2 ) ;
10150: CALL 13395 0 0
10154: PPUSH
10155: LD_STRING D10-RSol1-2
10157: PPUSH
10158: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10162: LD_EXP 16
10166: PPUSH
10167: LD_STRING D10-JMM-3
10169: PPUSH
10170: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10174: LD_EXP 47
10178: PPUSH
10179: LD_STRING D10-Bur-3
10181: PPUSH
10182: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10186: LD_EXP 16
10190: PPUSH
10191: LD_STRING D10-JMM-4
10193: PPUSH
10194: CALL_OW 88
// DialogueOff ;
10198: CALL_OW 7
// InGameOff ;
10202: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10206: LD_STRING M2
10208: PPUSH
10209: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10213: LD_INT 35
10215: PPUSH
10216: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10220: LD_INT 22
10222: PUSH
10223: LD_INT 7
10225: PUSH
10226: EMPTY
10227: LIST
10228: LIST
10229: PUSH
10230: LD_INT 91
10232: PUSH
10233: LD_EXP 47
10237: PUSH
10238: LD_INT 8
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: PPUSH
10250: CALL_OW 69
10254: IFFALSE 10213
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10256: LD_ADDR_VAR 0 1
10260: PUSH
10261: LD_INT 22
10263: PUSH
10264: LD_INT 4
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PPUSH
10271: CALL_OW 69
10275: PUSH
10276: FOR_IN
10277: IFFALSE 10293
// SetSide ( i , 7 ) ;
10279: LD_VAR 0 1
10283: PPUSH
10284: LD_INT 7
10286: PPUSH
10287: CALL_OW 235
10291: GO 10276
10293: POP
10294: POP
// ChangeMissionObjectives ( M3 ) ;
10295: LD_STRING M3
10297: PPUSH
10298: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10302: LD_INT 35
10304: PPUSH
10305: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10309: LD_EXP 16
10313: PPUSH
10314: LD_EXP 47
10318: PPUSH
10319: CALL_OW 296
10323: PUSH
10324: LD_INT 8
10326: LESS
10327: IFFALSE 10302
// ComTurnUnit ( JMM , Burlak ) ;
10329: LD_EXP 16
10333: PPUSH
10334: LD_EXP 47
10338: PPUSH
10339: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10343: LD_EXP 47
10347: PPUSH
10348: LD_EXP 16
10352: PPUSH
10353: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10357: LD_INT 10
10359: PPUSH
10360: CALL_OW 67
// DialogueOn ;
10364: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10368: LD_EXP 16
10372: PPUSH
10373: LD_STRING D11-JMM-1
10375: PPUSH
10376: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10380: LD_EXP 47
10384: PPUSH
10385: LD_STRING D11-Bur-1
10387: PPUSH
10388: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10392: LD_EXP 16
10396: PPUSH
10397: LD_STRING D11-JMM-2
10399: PPUSH
10400: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10404: LD_EXP 47
10408: PPUSH
10409: LD_STRING D11-Bur-2
10411: PPUSH
10412: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10416: LD_EXP 16
10420: PPUSH
10421: LD_STRING D11-JMM-3
10423: PPUSH
10424: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10428: LD_EXP 47
10432: PPUSH
10433: LD_STRING D11-Bur-3
10435: PPUSH
10436: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10440: LD_EXP 16
10444: PPUSH
10445: LD_STRING D11-JMM-4
10447: PPUSH
10448: CALL_OW 88
// if ar_base_spotted then
10452: LD_EXP 8
10456: IFFALSE 10472
// Say ( Burlak , D12-Bur-1 ) else
10458: LD_EXP 47
10462: PPUSH
10463: LD_STRING D12-Bur-1
10465: PPUSH
10466: CALL_OW 88
10470: GO 10511
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10472: LD_INT 7
10474: PPUSH
10475: LD_INT 3
10477: PPUSH
10478: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10482: LD_INT 127
10484: PPUSH
10485: LD_INT 45
10487: PPUSH
10488: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10492: LD_EXP 47
10496: PPUSH
10497: LD_STRING D12-Bur-1a
10499: PPUSH
10500: CALL_OW 88
// dwait ( 0 0$2 ) ;
10504: LD_INT 70
10506: PPUSH
10507: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10511: LD_EXP 47
10515: PPUSH
10516: LD_STRING D12-Bur-1b
10518: PPUSH
10519: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10523: LD_EXP 16
10527: PPUSH
10528: LD_STRING D12-JMM-1
10530: PPUSH
10531: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10535: LD_EXP 47
10539: PPUSH
10540: LD_STRING D12-Bur-2
10542: PPUSH
10543: CALL_OW 88
// if Roth then
10547: LD_EXP 17
10551: IFFALSE 10567
// Say ( Roth , D12-Roth-2 ) else
10553: LD_EXP 17
10557: PPUSH
10558: LD_STRING D12-Roth-2
10560: PPUSH
10561: CALL_OW 88
10565: GO 10579
// Say ( SciRu , D12-RSci1-2 ) ;
10567: CALL 13248 0 0
10571: PPUSH
10572: LD_STRING D12-RSci1-2
10574: PPUSH
10575: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10579: LD_EXP 16
10583: PPUSH
10584: LD_STRING D12-JMM-2
10586: PPUSH
10587: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10591: LD_EXP 47
10595: PPUSH
10596: LD_STRING D12-Bur-3
10598: PPUSH
10599: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10603: LD_EXP 16
10607: PPUSH
10608: LD_STRING D12-JMM-3
10610: PPUSH
10611: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10615: LD_EXP 47
10619: PPUSH
10620: LD_STRING D12-Bur-4
10622: PPUSH
10623: CALL_OW 88
// case Query ( QBase ) of 1 :
10627: LD_STRING QBase
10629: PPUSH
10630: CALL_OW 97
10634: PUSH
10635: LD_INT 1
10637: DOUBLE
10638: EQUAL
10639: IFTRUE 10643
10641: GO 10761
10643: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10644: LD_EXP 16
10648: PPUSH
10649: LD_STRING D13a-JMM-1
10651: PPUSH
10652: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10656: LD_EXP 47
10660: PPUSH
10661: LD_STRING D13a-Bur-1
10663: PPUSH
10664: CALL_OW 88
// if Roth then
10668: LD_EXP 17
10672: IFFALSE 10688
// Say ( Roth , D13a-Roth-1 ) else
10674: LD_EXP 17
10678: PPUSH
10679: LD_STRING D13a-Roth-1
10681: PPUSH
10682: CALL_OW 88
10686: GO 10700
// Say ( SciRu , D13a-RSci1-1 ) ;
10688: CALL 13248 0 0
10692: PPUSH
10693: LD_STRING D13a-RSci1-1
10695: PPUSH
10696: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10700: LD_EXP 16
10704: PPUSH
10705: LD_STRING D13a-JMM-2
10707: PPUSH
10708: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10712: LD_STRING QBaseAgain
10714: PPUSH
10715: CALL_OW 97
10719: PUSH
10720: LD_INT 1
10722: DOUBLE
10723: EQUAL
10724: IFTRUE 10728
10726: GO 10739
10728: POP
// selected_option := 2 ; 2 :
10729: LD_ADDR_VAR 0 2
10733: PUSH
10734: LD_INT 2
10736: ST_TO_ADDR
10737: GO 10759
10739: LD_INT 2
10741: DOUBLE
10742: EQUAL
10743: IFTRUE 10747
10745: GO 10758
10747: POP
// selected_option := 3 ; end ;
10748: LD_ADDR_VAR 0 2
10752: PUSH
10753: LD_INT 3
10755: ST_TO_ADDR
10756: GO 10759
10758: POP
// end ; 2 :
10759: GO 10800
10761: LD_INT 2
10763: DOUBLE
10764: EQUAL
10765: IFTRUE 10769
10767: GO 10780
10769: POP
// selected_option := 2 ; 3 :
10770: LD_ADDR_VAR 0 2
10774: PUSH
10775: LD_INT 2
10777: ST_TO_ADDR
10778: GO 10800
10780: LD_INT 3
10782: DOUBLE
10783: EQUAL
10784: IFTRUE 10788
10786: GO 10799
10788: POP
// selected_option := 3 ; end ;
10789: LD_ADDR_VAR 0 2
10793: PUSH
10794: LD_INT 3
10796: ST_TO_ADDR
10797: GO 10800
10799: POP
// if selected_option = 2 then
10800: LD_VAR 0 2
10804: PUSH
10805: LD_INT 2
10807: EQUAL
10808: IFFALSE 10902
// begin Say ( JMM , D13b-JMM-1 ) ;
10810: LD_EXP 16
10814: PPUSH
10815: LD_STRING D13b-JMM-1
10817: PPUSH
10818: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10822: LD_EXP 47
10826: PPUSH
10827: LD_STRING D13b-Bur-1
10829: PPUSH
10830: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10834: LD_EXP 16
10838: PPUSH
10839: LD_STRING D13b-JMM-2
10841: PPUSH
10842: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10846: LD_EXP 56
10850: PPUSH
10851: LD_STRING D13b-Abd-2
10853: PPUSH
10854: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10858: LD_EXP 16
10862: PPUSH
10863: LD_STRING D13b-JMM-3
10865: PPUSH
10866: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10870: LD_EXP 56
10874: PPUSH
10875: LD_STRING D13b-Abd-3
10877: PPUSH
10878: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10882: LD_EXP 16
10886: PPUSH
10887: LD_STRING D13b-JMM-4
10889: PPUSH
10890: CALL_OW 88
// ar_active_attack := true ;
10894: LD_ADDR_EXP 9
10898: PUSH
10899: LD_INT 1
10901: ST_TO_ADDR
// end ; if selected_option = 3 then
10902: LD_VAR 0 2
10906: PUSH
10907: LD_INT 3
10909: EQUAL
10910: IFFALSE 10936
// begin Say ( JMM , D13c-JMM-1 ) ;
10912: LD_EXP 16
10916: PPUSH
10917: LD_STRING D13c-JMM-1
10919: PPUSH
10920: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10924: LD_EXP 47
10928: PPUSH
10929: LD_STRING D13c-Bur-1
10931: PPUSH
10932: CALL_OW 88
// end ; DialogueOff ;
10936: CALL_OW 7
// if not ar_active_attack then
10940: LD_EXP 9
10944: NOT
10945: IFFALSE 10962
// begin wait ( 6 6$00 ) ;
10947: LD_INT 12600
10949: PPUSH
10950: CALL_OW 67
// ar_active_attack := true ;
10954: LD_ADDR_EXP 9
10958: PUSH
10959: LD_INT 1
10961: ST_TO_ADDR
// end ; end ;
10962: PPOPN 2
10964: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10965: LD_EXP 47
10969: PPUSH
10970: CALL_OW 305
10974: PUSH
10975: LD_EXP 47
10979: PPUSH
10980: CALL_OW 255
10984: PUSH
10985: LD_INT 7
10987: EQUAL
10988: AND
10989: IFFALSE 11185
10991: GO 10993
10993: DISABLE
10994: LD_INT 0
10996: PPUSH
// begin wait ( 4 4$40 ) ;
10997: LD_INT 9800
10999: PPUSH
11000: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11004: LD_INT 35
11006: PPUSH
11007: CALL_OW 67
// until not ru_attackers ;
11011: LD_EXP 53
11015: NOT
11016: IFFALSE 11004
// PrepareGnyevko ;
11018: CALL 2250 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11022: LD_EXP 49
11026: PPUSH
11027: LD_INT 124
11029: PPUSH
11030: LD_INT 118
11032: PPUSH
11033: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11037: LD_EXP 49
11041: PPUSH
11042: CALL_OW 200
// time := 0 0$00 ;
11046: LD_ADDR_VAR 0 1
11050: PUSH
11051: LD_INT 0
11053: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11054: LD_INT 35
11056: PPUSH
11057: CALL_OW 67
// time := time + 0 0$1 ;
11061: LD_ADDR_VAR 0 1
11065: PUSH
11066: LD_VAR 0 1
11070: PUSH
11071: LD_INT 35
11073: PLUS
11074: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11075: LD_EXP 49
11079: PPUSH
11080: LD_INT 124
11082: PPUSH
11083: LD_INT 118
11085: PPUSH
11086: CALL_OW 307
11090: PUSH
11091: LD_VAR 0 1
11095: PUSH
11096: LD_INT 1050
11098: GREATEREQUAL
11099: OR
11100: IFFALSE 11054
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11102: LD_EXP 49
11106: PPUSH
11107: LD_STRING DBelkov-Gny-1
11109: PPUSH
11110: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11114: LD_EXP 47
11118: PPUSH
11119: LD_STRING DBelkov-Bur-1a
11121: PPUSH
11122: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11126: LD_INT 35
11128: PPUSH
11129: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11133: LD_EXP 49
11137: PPUSH
11138: LD_INT 22
11140: PUSH
11141: LD_INT 7
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PPUSH
11148: CALL_OW 69
11152: PPUSH
11153: LD_EXP 49
11157: PPUSH
11158: CALL_OW 74
11162: PPUSH
11163: CALL_OW 296
11167: PUSH
11168: LD_INT 8
11170: LESS
11171: IFFALSE 11126
// SetSide ( Gnyevko , 7 ) ;
11173: LD_EXP 49
11177: PPUSH
11178: LD_INT 7
11180: PPUSH
11181: CALL_OW 235
// end ;
11185: PPOPN 1
11187: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11188: LD_EXP 47
11192: PPUSH
11193: CALL_OW 255
11197: PUSH
11198: LD_INT 7
11200: EQUAL
11201: IFFALSE 11211
11203: GO 11205
11205: DISABLE
// begin enable ;
11206: ENABLE
// PrepareAmericanAttack ;
11207: CALL 6853 0 0
// end ;
11211: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11212: LD_INT 22
11214: PUSH
11215: LD_INT 1
11217: PUSH
11218: EMPTY
11219: LIST
11220: LIST
11221: PPUSH
11222: CALL_OW 69
11226: IFFALSE 11410
11228: GO 11230
11230: DISABLE
11231: LD_INT 0
11233: PPUSH
11234: PPUSH
// begin while true do
11235: LD_INT 1
11237: IFFALSE 11294
// begin wait ( 0 0$1 ) ;
11239: LD_INT 35
11241: PPUSH
11242: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11246: LD_ADDR_VAR 0 2
11250: PUSH
11251: LD_INT 22
11253: PUSH
11254: LD_INT 1
11256: PUSH
11257: EMPTY
11258: LIST
11259: LIST
11260: PPUSH
11261: CALL_OW 69
11265: PPUSH
11266: LD_EXP 16
11270: PPUSH
11271: CALL_OW 74
11275: ST_TO_ADDR
// if See ( 7 , tmp ) then
11276: LD_INT 7
11278: PPUSH
11279: LD_VAR 0 2
11283: PPUSH
11284: CALL_OW 292
11288: IFFALSE 11292
// break ;
11290: GO 11294
// end ;
11292: GO 11235
// DialogueOn ;
11294: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11298: LD_VAR 0 2
11302: PPUSH
11303: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11307: LD_VAR 0 2
11311: PPUSH
11312: CALL_OW 250
11316: PPUSH
11317: LD_VAR 0 2
11321: PPUSH
11322: CALL_OW 251
11326: PPUSH
11327: LD_INT 7
11329: PPUSH
11330: LD_INT 8
11332: PPUSH
11333: CALL_OW 330
// if Denis then
11337: LD_EXP 22
11341: IFFALSE 11355
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11343: LD_EXP 22
11347: PPUSH
11348: LD_STRING DAmerAttack-Pet-1
11350: PPUSH
11351: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11355: LD_EXP 16
11359: PPUSH
11360: LD_STRING DAmerAttack-JMM-1
11362: PPUSH
11363: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11367: LD_EXP 47
11371: PPUSH
11372: LD_STRING DStop-Bur-1
11374: PPUSH
11375: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11379: LD_VAR 0 2
11383: PPUSH
11384: CALL_OW 250
11388: PPUSH
11389: LD_VAR 0 2
11393: PPUSH
11394: CALL_OW 251
11398: PPUSH
11399: LD_INT 7
11401: PPUSH
11402: CALL_OW 331
// DialogueOff ;
11406: CALL_OW 7
// end ;
11410: PPOPN 2
11412: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11413: LD_INT 22
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: EMPTY
11420: LIST
11421: LIST
11422: PUSH
11423: LD_INT 21
11425: PUSH
11426: LD_INT 1
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PPUSH
11437: CALL_OW 69
11441: PUSH
11442: LD_INT 0
11444: EQUAL
11445: IFFALSE 11487
11447: GO 11449
11449: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11450: LD_STRING M5a
11452: PPUSH
11453: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11457: LD_EXP 16
11461: PPUSH
11462: LD_STRING D8-JMM-1
11464: PPUSH
11465: CALL_OW 88
// if Gossudarov then
11469: LD_EXP 33
11473: IFFALSE 11487
// Say ( Gossudarov , D8-Gos-1 ) ;
11475: LD_EXP 33
11479: PPUSH
11480: LD_STRING D8-Gos-1
11482: PPUSH
11483: CALL_OW 88
// end ;
11487: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11488: LD_INT 22
11490: PUSH
11491: LD_INT 2
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: PUSH
11498: LD_INT 21
11500: PUSH
11501: LD_INT 1
11503: PUSH
11504: EMPTY
11505: LIST
11506: LIST
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PPUSH
11512: CALL_OW 69
11516: PUSH
11517: LD_INT 0
11519: EQUAL
11520: IFFALSE 11570
11522: GO 11524
11524: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11525: LD_STRING M4c
11527: PPUSH
11528: CALL_OW 337
// if Roth then
11532: LD_EXP 17
11536: IFFALSE 11552
// Say ( Roth , DStop-Roth-1 ) else
11538: LD_EXP 17
11542: PPUSH
11543: LD_STRING DStop-Roth-1
11545: PPUSH
11546: CALL_OW 88
11550: GO 11570
// if Gossudarov then
11552: LD_EXP 33
11556: IFFALSE 11570
// Say ( Gossudarov , D8-Gos-1a ) ;
11558: LD_EXP 33
11562: PPUSH
11563: LD_STRING D8-Gos-1a
11565: PPUSH
11566: CALL_OW 88
// end ;
11570: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11571: LD_INT 7
11573: PPUSH
11574: LD_INT 1
11576: PPUSH
11577: LD_INT 1
11579: PPUSH
11580: CALL 14927 0 3
11584: PUSH
11585: LD_INT 0
11587: EQUAL
11588: PUSH
11589: LD_INT 7
11591: PPUSH
11592: LD_INT 3
11594: PPUSH
11595: LD_INT 1
11597: PPUSH
11598: CALL 14927 0 3
11602: PUSH
11603: LD_INT 0
11605: EQUAL
11606: AND
11607: IFFALSE 11619
11609: GO 11611
11611: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11612: LD_STRING M1a
11614: PPUSH
11615: CALL_OW 337
// end ;
11619: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
11620: LD_INT 22
11622: PUSH
11623: LD_INT 2
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: PUSH
11630: LD_INT 21
11632: PUSH
11633: LD_INT 1
11635: PUSH
11636: EMPTY
11637: LIST
11638: LIST
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PPUSH
11644: CALL_OW 69
11648: PUSH
11649: LD_INT 0
11651: EQUAL
11652: PUSH
11653: LD_INT 22
11655: PUSH
11656: LD_INT 3
11658: PUSH
11659: EMPTY
11660: LIST
11661: LIST
11662: PUSH
11663: LD_INT 21
11665: PUSH
11666: LD_INT 1
11668: PUSH
11669: EMPTY
11670: LIST
11671: LIST
11672: PUSH
11673: EMPTY
11674: LIST
11675: LIST
11676: PPUSH
11677: CALL_OW 69
11681: PUSH
11682: LD_INT 0
11684: EQUAL
11685: AND
11686: PUSH
11687: LD_INT 22
11689: PUSH
11690: LD_INT 1
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PPUSH
11697: CALL_OW 69
11701: PUSH
11702: LD_INT 0
11704: EQUAL
11705: AND
11706: PUSH
11707: LD_INT 7
11709: PPUSH
11710: LD_INT 1
11712: PPUSH
11713: LD_INT 1
11715: PPUSH
11716: CALL 14927 0 3
11720: PUSH
11721: LD_INT 0
11723: EQUAL
11724: AND
11725: PUSH
11726: LD_INT 7
11728: PPUSH
11729: LD_INT 3
11731: PPUSH
11732: LD_INT 1
11734: PPUSH
11735: CALL 14927 0 3
11739: PUSH
11740: LD_INT 0
11742: EQUAL
11743: AND
11744: PUSH
11745: LD_EXP 47
11749: PPUSH
11750: CALL_OW 255
11754: PUSH
11755: LD_INT 7
11757: EQUAL
11758: AND
11759: PUSH
11760: LD_EXP 47
11764: PPUSH
11765: CALL_OW 302
11769: AND
11770: IFFALSE 13245
11772: GO 11774
11774: DISABLE
11775: LD_INT 0
11777: PPUSH
11778: PPUSH
11779: PPUSH
11780: PPUSH
11781: PPUSH
11782: PPUSH
// begin m1 := false ;
11783: LD_ADDR_VAR 0 4
11787: PUSH
11788: LD_INT 0
11790: ST_TO_ADDR
// m2 := false ;
11791: LD_ADDR_VAR 0 5
11795: PUSH
11796: LD_INT 0
11798: ST_TO_ADDR
// m3 := false ;
11799: LD_ADDR_VAR 0 6
11803: PUSH
11804: LD_INT 0
11806: ST_TO_ADDR
// if tick < 40 40$00 then
11807: LD_OWVAR 1
11811: PUSH
11812: LD_INT 84000
11814: LESS
11815: IFFALSE 11824
// SetAchievement ( ACH_ASPEED_17 ) ;
11817: LD_STRING ACH_ASPEED_17
11819: PPUSH
11820: CALL_OW 543
// wait ( 0 0$5 ) ;
11824: LD_INT 175
11826: PPUSH
11827: CALL_OW 67
// if not masha_killed then
11831: LD_EXP 10
11835: NOT
11836: IFFALSE 11858
// begin m1 := true ;
11838: LD_ADDR_VAR 0 4
11842: PUSH
11843: LD_INT 1
11845: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11846: LD_STRING Masha
11848: PPUSH
11849: LD_INT 1
11851: PPUSH
11852: CALL_OW 101
// end else
11856: GO 11869
// AddMedal ( Masha , - 1 ) ;
11858: LD_STRING Masha
11860: PPUSH
11861: LD_INT 1
11863: NEG
11864: PPUSH
11865: CALL_OW 101
// if abdul_escaped then
11869: LD_EXP 13
11873: IFFALSE 11888
// AddMedal ( Abdul , - 1 ) else
11875: LD_STRING Abdul
11877: PPUSH
11878: LD_INT 1
11880: NEG
11881: PPUSH
11882: CALL_OW 101
11886: GO 11906
// begin m2 := true ;
11888: LD_ADDR_VAR 0 5
11892: PUSH
11893: LD_INT 1
11895: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11896: LD_STRING Abdul
11898: PPUSH
11899: LD_INT 1
11901: PPUSH
11902: CALL_OW 101
// end ; if loss_counter = 0 then
11906: LD_EXP 14
11910: PUSH
11911: LD_INT 0
11913: EQUAL
11914: IFFALSE 11936
// begin m3 := true ;
11916: LD_ADDR_VAR 0 6
11920: PUSH
11921: LD_INT 1
11923: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11924: LD_STRING People
11926: PPUSH
11927: LD_INT 2
11929: PPUSH
11930: CALL_OW 101
// end else
11934: GO 11998
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
11936: LD_EXP 14
11940: PUSH
11941: LD_INT 3
11943: PUSH
11944: LD_INT 2
11946: PUSH
11947: LD_INT 2
11949: PUSH
11950: LD_INT 1
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: LIST
11957: LIST
11958: PUSH
11959: LD_OWVAR 67
11963: ARRAY
11964: LESSEQUAL
11965: IFFALSE 11987
// begin AddMedal ( People , 1 ) ;
11967: LD_STRING People
11969: PPUSH
11970: LD_INT 1
11972: PPUSH
11973: CALL_OW 101
// m3 := true ;
11977: LD_ADDR_VAR 0 6
11981: PUSH
11982: LD_INT 1
11984: ST_TO_ADDR
// end else
11985: GO 11998
// AddMedal ( People , - 1 ) ;
11987: LD_STRING People
11989: PPUSH
11990: LD_INT 1
11992: NEG
11993: PPUSH
11994: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
11998: LD_OWVAR 67
12002: PUSH
12003: LD_INT 3
12005: GREATEREQUAL
12006: PUSH
12007: LD_VAR 0 4
12011: AND
12012: PUSH
12013: LD_VAR 0 5
12017: AND
12018: PUSH
12019: LD_VAR 0 6
12023: AND
12024: IFFALSE 12036
// SetAchievementEX ( ACH_AMER , 17 ) ;
12026: LD_STRING ACH_AMER
12028: PPUSH
12029: LD_INT 17
12031: PPUSH
12032: CALL_OW 564
// GiveMedals ( MAIN ) ;
12036: LD_STRING MAIN
12038: PPUSH
12039: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12043: LD_ADDR_VAR 0 2
12047: PUSH
12048: LD_INT 22
12050: PUSH
12051: LD_INT 7
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: PUSH
12058: LD_INT 2
12060: PUSH
12061: LD_INT 25
12063: PUSH
12064: LD_INT 1
12066: PUSH
12067: EMPTY
12068: LIST
12069: LIST
12070: PUSH
12071: LD_INT 25
12073: PUSH
12074: LD_INT 2
12076: PUSH
12077: EMPTY
12078: LIST
12079: LIST
12080: PUSH
12081: LD_INT 25
12083: PUSH
12084: LD_INT 3
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PUSH
12091: LD_INT 25
12093: PUSH
12094: LD_INT 4
12096: PUSH
12097: EMPTY
12098: LIST
12099: LIST
12100: PUSH
12101: LD_INT 25
12103: PUSH
12104: LD_INT 5
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: PUSH
12111: LD_INT 25
12113: PUSH
12114: LD_INT 8
12116: PUSH
12117: EMPTY
12118: LIST
12119: LIST
12120: PUSH
12121: LD_INT 25
12123: PUSH
12124: LD_INT 9
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: PUSH
12131: EMPTY
12132: LIST
12133: LIST
12134: LIST
12135: LIST
12136: LIST
12137: LIST
12138: LIST
12139: LIST
12140: PUSH
12141: EMPTY
12142: LIST
12143: LIST
12144: PPUSH
12145: CALL_OW 69
12149: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12150: LD_VAR 0 2
12154: PPUSH
12155: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
12159: LD_ADDR_VAR 0 3
12163: PUSH
12164: LD_EXP 16
12168: PUSH
12169: LD_EXP 17
12173: PUSH
12174: LD_EXP 18
12178: PUSH
12179: LD_EXP 19
12183: PUSH
12184: LD_EXP 20
12188: PUSH
12189: LD_EXP 21
12193: PUSH
12194: LD_EXP 22
12198: PUSH
12199: LD_EXP 23
12203: PUSH
12204: LD_EXP 24
12208: PUSH
12209: LD_EXP 25
12213: PUSH
12214: LD_EXP 26
12218: PUSH
12219: LD_EXP 27
12223: PUSH
12224: LD_EXP 28
12228: PUSH
12229: LD_EXP 29
12233: PUSH
12234: LD_EXP 30
12238: PUSH
12239: LD_EXP 31
12243: PUSH
12244: LD_EXP 32
12248: PUSH
12249: LD_EXP 33
12253: PUSH
12254: LD_EXP 34
12258: PUSH
12259: LD_EXP 35
12263: PUSH
12264: LD_EXP 37
12268: PUSH
12269: LD_EXP 38
12273: PUSH
12274: LD_EXP 39
12278: PUSH
12279: LD_EXP 40
12283: PUSH
12284: LD_EXP 41
12288: PUSH
12289: LD_EXP 42
12293: PUSH
12294: LD_EXP 43
12298: PUSH
12299: LD_EXP 44
12303: PUSH
12304: LD_EXP 45
12308: PUSH
12309: LD_EXP 46
12313: PUSH
12314: LD_EXP 47
12318: PUSH
12319: LD_EXP 48
12323: PUSH
12324: LD_EXP 49
12328: PUSH
12329: EMPTY
12330: LIST
12331: LIST
12332: LIST
12333: LIST
12334: LIST
12335: LIST
12336: LIST
12337: LIST
12338: LIST
12339: LIST
12340: LIST
12341: LIST
12342: LIST
12343: LIST
12344: LIST
12345: LIST
12346: LIST
12347: LIST
12348: LIST
12349: LIST
12350: LIST
12351: LIST
12352: LIST
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: LIST
12360: LIST
12361: LIST
12362: LIST
12363: ST_TO_ADDR
// if tmp diff tmp2 then
12364: LD_VAR 0 2
12368: PUSH
12369: LD_VAR 0 3
12373: DIFF
12374: IFFALSE 12394
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12376: LD_VAR 0 2
12380: PUSH
12381: LD_VAR 0 3
12385: DIFF
12386: PPUSH
12387: LD_STRING 13a_others
12389: PPUSH
12390: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12394: LD_EXP 16
12398: PPUSH
12399: LD_STRING 13a_JMM
12401: PPUSH
12402: CALL_OW 38
// if Titov then
12406: LD_EXP 35
12410: IFFALSE 12424
// SaveCharacters ( Titov , 13a_Titov ) ;
12412: LD_EXP 35
12416: PPUSH
12417: LD_STRING 13a_Titov
12419: PPUSH
12420: CALL_OW 38
// if Dolgov then
12424: LD_EXP 37
12428: IFFALSE 12442
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12430: LD_EXP 37
12434: PPUSH
12435: LD_STRING 13a_Dolgov
12437: PPUSH
12438: CALL_OW 38
// if Petrosyan then
12442: LD_EXP 38
12446: IFFALSE 12460
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12448: LD_EXP 38
12452: PPUSH
12453: LD_STRING 13a_Petrosyan
12455: PPUSH
12456: CALL_OW 38
// if Scholtze then
12460: LD_EXP 39
12464: IFFALSE 12478
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12466: LD_EXP 39
12470: PPUSH
12471: LD_STRING 13a_Scholtze
12473: PPUSH
12474: CALL_OW 38
// if Oblukov then
12478: LD_EXP 40
12482: IFFALSE 12496
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12484: LD_EXP 40
12488: PPUSH
12489: LD_STRING 13a_Oblukov
12491: PPUSH
12492: CALL_OW 38
// if Kapitsova then
12496: LD_EXP 41
12500: IFFALSE 12514
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12502: LD_EXP 41
12506: PPUSH
12507: LD_STRING 13a_Kapitsova
12509: PPUSH
12510: CALL_OW 38
// if Lipshchin then
12514: LD_EXP 42
12518: IFFALSE 12532
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12520: LD_EXP 42
12524: PPUSH
12525: LD_STRING 13a_Lipshchin
12527: PPUSH
12528: CALL_OW 38
// if Petrovova then
12532: LD_EXP 43
12536: IFFALSE 12550
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12538: LD_EXP 43
12542: PPUSH
12543: LD_STRING 13a_Petrovova
12545: PPUSH
12546: CALL_OW 38
// if Kovalyuk then
12550: LD_EXP 44
12554: IFFALSE 12568
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12556: LD_EXP 44
12560: PPUSH
12561: LD_STRING 13a_Kovalyuk
12563: PPUSH
12564: CALL_OW 38
// if Kuzmov then
12568: LD_EXP 45
12572: IFFALSE 12586
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12574: LD_EXP 45
12578: PPUSH
12579: LD_STRING 13a_Kuzmov
12581: PPUSH
12582: CALL_OW 38
// if Karamazov then
12586: LD_EXP 46
12590: IFFALSE 12604
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12592: LD_EXP 46
12596: PPUSH
12597: LD_STRING 13a_Karamazov
12599: PPUSH
12600: CALL_OW 38
// if Burlak then
12604: LD_EXP 47
12608: IFFALSE 12622
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12610: LD_EXP 47
12614: PPUSH
12615: LD_STRING 13a_Burlak
12617: PPUSH
12618: CALL_OW 38
// if Belkov then
12622: LD_EXP 48
12626: IFFALSE 12640
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12628: LD_EXP 48
12632: PPUSH
12633: LD_STRING 13a_Belkov
12635: PPUSH
12636: CALL_OW 38
// if Gnyevko then
12640: LD_EXP 49
12644: IFFALSE 12658
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12646: LD_EXP 49
12650: PPUSH
12651: LD_STRING 13a_Gnyevko
12653: PPUSH
12654: CALL_OW 38
// if Lisa then
12658: LD_EXP 18
12662: IFFALSE 12676
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12664: LD_EXP 18
12668: PPUSH
12669: LD_STRING 13a_Lisa
12671: PPUSH
12672: CALL_OW 38
// if Donaldson then
12676: LD_EXP 19
12680: IFFALSE 12694
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12682: LD_EXP 19
12686: PPUSH
12687: LD_STRING 13a_Donaldson
12689: PPUSH
12690: CALL_OW 38
// if Bobby then
12694: LD_EXP 20
12698: IFFALSE 12712
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12700: LD_EXP 20
12704: PPUSH
12705: LD_STRING 13a_Bobby
12707: PPUSH
12708: CALL_OW 38
// if Cyrus then
12712: LD_EXP 21
12716: IFFALSE 12730
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12718: LD_EXP 21
12722: PPUSH
12723: LD_STRING 13a_Cyrus
12725: PPUSH
12726: CALL_OW 38
// if Denis then
12730: LD_EXP 22
12734: IFFALSE 12748
// SaveCharacters ( Denis , 13a_Denis ) ;
12736: LD_EXP 22
12740: PPUSH
12741: LD_STRING 13a_Denis
12743: PPUSH
12744: CALL_OW 38
// if Brown then
12748: LD_EXP 23
12752: IFFALSE 12766
// SaveCharacters ( Brown , 13a_Brown ) ;
12754: LD_EXP 23
12758: PPUSH
12759: LD_STRING 13a_Brown
12761: PPUSH
12762: CALL_OW 38
// if Gladstone then
12766: LD_EXP 24
12770: IFFALSE 12784
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12772: LD_EXP 24
12776: PPUSH
12777: LD_STRING 13a_Gladstone
12779: PPUSH
12780: CALL_OW 38
// if Houten then
12784: LD_EXP 25
12788: IFFALSE 12802
// SaveCharacters ( Houten , 13a_Houten ) ;
12790: LD_EXP 25
12794: PPUSH
12795: LD_STRING 13a_Houten
12797: PPUSH
12798: CALL_OW 38
// if Cornel then
12802: LD_EXP 26
12806: IFFALSE 12820
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12808: LD_EXP 26
12812: PPUSH
12813: LD_STRING 13a_Cornel
12815: PPUSH
12816: CALL_OW 38
// if Gary then
12820: LD_EXP 27
12824: IFFALSE 12838
// SaveCharacters ( Gary , 13a_Gary ) ;
12826: LD_EXP 27
12830: PPUSH
12831: LD_STRING 13a_Gary
12833: PPUSH
12834: CALL_OW 38
// if Frank then
12838: LD_EXP 28
12842: IFFALSE 12856
// SaveCharacters ( Frank , 13a_Frank ) ;
12844: LD_EXP 28
12848: PPUSH
12849: LD_STRING 13a_Frank
12851: PPUSH
12852: CALL_OW 38
// if Kikuchi then
12856: LD_EXP 29
12860: IFFALSE 12874
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12862: LD_EXP 29
12866: PPUSH
12867: LD_STRING 13a_Kikuchi
12869: PPUSH
12870: CALL_OW 38
// if Simms then
12874: LD_EXP 30
12878: IFFALSE 12892
// SaveCharacters ( Simms , 13a_Simms ) ;
12880: LD_EXP 30
12884: PPUSH
12885: LD_STRING 13a_Simms
12887: PPUSH
12888: CALL_OW 38
// if Joan then
12892: LD_EXP 31
12896: IFFALSE 12910
// SaveCharacters ( Joan , 13a_Joan ) ;
12898: LD_EXP 31
12902: PPUSH
12903: LD_STRING 13a_Joan
12905: PPUSH
12906: CALL_OW 38
// if DeltaDoctor then
12910: LD_EXP 32
12914: IFFALSE 12928
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12916: LD_EXP 32
12920: PPUSH
12921: LD_STRING 13a_DeltaDoctor
12923: PPUSH
12924: CALL_OW 38
// if Gossudarov then
12928: LD_EXP 33
12932: IFFALSE 12946
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12934: LD_EXP 33
12938: PPUSH
12939: LD_STRING 13a_Gossudarov
12941: PPUSH
12942: CALL_OW 38
// if Kirilenkova then
12946: LD_EXP 34
12950: IFFALSE 12964
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12952: LD_EXP 34
12956: PPUSH
12957: LD_STRING 13a_Kirilenkova
12959: PPUSH
12960: CALL_OW 38
// if Roth then
12964: LD_EXP 17
12968: IFFALSE 12982
// SaveCharacters ( Roth , 13a_Roth ) ;
12970: LD_EXP 17
12974: PPUSH
12975: LD_STRING 13a_Roth
12977: PPUSH
12978: CALL_OW 38
// if Masha then
12982: LD_EXP 50
12986: IFFALSE 13041
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12988: LD_EXP 50
12992: PPUSH
12993: CALL_OW 265
12997: PUSH
12998: LD_EXP 50
13002: PPUSH
13003: CALL_OW 262
13007: PUSH
13008: LD_EXP 50
13012: PPUSH
13013: CALL_OW 263
13017: PUSH
13018: LD_EXP 50
13022: PPUSH
13023: CALL_OW 264
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: PPUSH
13034: LD_STRING 13a_Masha
13036: PPUSH
13037: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13041: LD_ADDR_VAR 0 2
13045: PUSH
13046: LD_INT 21
13048: PUSH
13049: LD_INT 3
13051: PUSH
13052: EMPTY
13053: LIST
13054: LIST
13055: PPUSH
13056: CALL_OW 69
13060: ST_TO_ADDR
// tmp2 := [ ] ;
13061: LD_ADDR_VAR 0 3
13065: PUSH
13066: EMPTY
13067: ST_TO_ADDR
// if tmp then
13068: LD_VAR 0 2
13072: IFFALSE 13223
// for i in tmp do
13074: LD_ADDR_VAR 0 1
13078: PUSH
13079: LD_VAR 0 2
13083: PUSH
13084: FOR_IN
13085: IFFALSE 13221
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13087: LD_ADDR_VAR 0 3
13091: PUSH
13092: LD_VAR 0 3
13096: PUSH
13097: LD_VAR 0 1
13101: PPUSH
13102: CALL_OW 255
13106: PUSH
13107: LD_VAR 0 1
13111: PPUSH
13112: CALL_OW 248
13116: PUSH
13117: LD_VAR 0 1
13121: PPUSH
13122: CALL_OW 266
13126: PUSH
13127: LD_VAR 0 1
13131: PPUSH
13132: CALL_OW 250
13136: PUSH
13137: LD_VAR 0 1
13141: PPUSH
13142: CALL_OW 251
13146: PUSH
13147: LD_VAR 0 1
13151: PPUSH
13152: CALL_OW 254
13156: PUSH
13157: LD_VAR 0 1
13161: PPUSH
13162: CALL_OW 267
13166: PUSH
13167: LD_VAR 0 1
13171: PPUSH
13172: LD_INT 1
13174: PPUSH
13175: CALL_OW 268
13179: PUSH
13180: LD_VAR 0 1
13184: PPUSH
13185: LD_INT 2
13187: PPUSH
13188: CALL_OW 268
13192: PUSH
13193: LD_VAR 0 1
13197: PPUSH
13198: CALL_OW 269
13202: PUSH
13203: EMPTY
13204: LIST
13205: LIST
13206: LIST
13207: LIST
13208: LIST
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: LIST
13214: PUSH
13215: EMPTY
13216: LIST
13217: ADD
13218: ST_TO_ADDR
13219: GO 13084
13221: POP
13222: POP
// if tmp2 then
13223: LD_VAR 0 3
13227: IFFALSE 13241
// SaveVariable ( tmp2 , 13a_buildings ) ;
13229: LD_VAR 0 3
13233: PPUSH
13234: LD_STRING 13a_buildings
13236: PPUSH
13237: CALL_OW 39
// YouWin ;
13241: CALL_OW 103
// end ;
13245: PPOPN 6
13247: END
// export function SciRu ; var tmp , t ; begin
13248: LD_INT 0
13250: PPUSH
13251: PPUSH
13252: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13253: LD_ADDR_VAR 0 3
13257: PUSH
13258: LD_EXP 33
13262: PUSH
13263: LD_EXP 47
13267: PUSH
13268: LD_EXP 35
13272: PUSH
13273: LD_EXP 48
13277: PUSH
13278: LD_EXP 49
13282: PUSH
13283: LD_EXP 38
13287: PUSH
13288: LD_EXP 39
13292: PUSH
13293: LD_EXP 37
13297: PUSH
13298: EMPTY
13299: LIST
13300: LIST
13301: LIST
13302: LIST
13303: LIST
13304: LIST
13305: LIST
13306: LIST
13307: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13308: LD_ADDR_VAR 0 2
13312: PUSH
13313: LD_INT 22
13315: PUSH
13316: LD_INT 7
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: PUSH
13323: LD_INT 23
13325: PUSH
13326: LD_INT 3
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: PUSH
13333: LD_INT 25
13335: PUSH
13336: LD_INT 4
13338: PUSH
13339: EMPTY
13340: LIST
13341: LIST
13342: PUSH
13343: LD_INT 26
13345: PUSH
13346: LD_INT 1
13348: PUSH
13349: EMPTY
13350: LIST
13351: LIST
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: LIST
13357: LIST
13358: PPUSH
13359: CALL_OW 69
13363: PUSH
13364: LD_VAR 0 3
13368: DIFF
13369: ST_TO_ADDR
// if tmp then
13370: LD_VAR 0 2
13374: IFFALSE 13390
// result := tmp [ 1 ] ;
13376: LD_ADDR_VAR 0 1
13380: PUSH
13381: LD_VAR 0 2
13385: PUSH
13386: LD_INT 1
13388: ARRAY
13389: ST_TO_ADDR
// end ;
13390: LD_VAR 0 1
13394: RET
// export function SolRu ; var tmp , t ; begin
13395: LD_INT 0
13397: PPUSH
13398: PPUSH
13399: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13400: LD_ADDR_VAR 0 3
13404: PUSH
13405: LD_EXP 33
13409: PUSH
13410: LD_EXP 47
13414: PUSH
13415: LD_EXP 35
13419: PUSH
13420: LD_EXP 48
13424: PUSH
13425: LD_EXP 49
13429: PUSH
13430: LD_EXP 38
13434: PUSH
13435: LD_EXP 39
13439: PUSH
13440: LD_EXP 37
13444: PUSH
13445: EMPTY
13446: LIST
13447: LIST
13448: LIST
13449: LIST
13450: LIST
13451: LIST
13452: LIST
13453: LIST
13454: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13455: LD_ADDR_VAR 0 2
13459: PUSH
13460: LD_INT 22
13462: PUSH
13463: LD_INT 7
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: LD_INT 23
13472: PUSH
13473: LD_INT 3
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: LD_INT 25
13482: PUSH
13483: LD_INT 1
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PUSH
13490: LD_INT 26
13492: PUSH
13493: LD_INT 1
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: LIST
13504: LIST
13505: PPUSH
13506: CALL_OW 69
13510: PUSH
13511: LD_VAR 0 3
13515: DIFF
13516: ST_TO_ADDR
// if tmp then
13517: LD_VAR 0 2
13521: IFFALSE 13537
// result := tmp [ 1 ] ;
13523: LD_ADDR_VAR 0 1
13527: PUSH
13528: LD_VAR 0 2
13532: PUSH
13533: LD_INT 1
13535: ARRAY
13536: ST_TO_ADDR
// end ; end_of_file
13537: LD_VAR 0 1
13541: RET
// export function CustomEvent ( event ) ; begin
13542: LD_INT 0
13544: PPUSH
// end ;
13545: LD_VAR 0 2
13549: RET
// on UnitDestroyed ( un ) do var i , side ;
13550: LD_INT 0
13552: PPUSH
13553: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
13554: LD_VAR 0 1
13558: PPUSH
13559: CALL 100588 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13563: LD_VAR 0 1
13567: PUSH
13568: LD_INT 22
13570: PUSH
13571: LD_INT 7
13573: PUSH
13574: EMPTY
13575: LIST
13576: LIST
13577: PUSH
13578: LD_INT 2
13580: PUSH
13581: LD_INT 25
13583: PUSH
13584: LD_INT 1
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: PUSH
13591: LD_INT 25
13593: PUSH
13594: LD_INT 2
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PUSH
13601: LD_INT 25
13603: PUSH
13604: LD_INT 3
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: LD_INT 25
13613: PUSH
13614: LD_INT 4
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 25
13623: PUSH
13624: LD_INT 5
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: LD_INT 25
13633: PUSH
13634: LD_INT 8
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: LD_INT 25
13643: PUSH
13644: LD_INT 9
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: LIST
13655: LIST
13656: LIST
13657: LIST
13658: LIST
13659: LIST
13660: PUSH
13661: EMPTY
13662: LIST
13663: LIST
13664: PPUSH
13665: CALL_OW 69
13669: IN
13670: IFFALSE 13686
// loss_counter := loss_counter + 1 ;
13672: LD_ADDR_EXP 14
13676: PUSH
13677: LD_EXP 14
13681: PUSH
13682: LD_INT 1
13684: PLUS
13685: ST_TO_ADDR
// if un = Abdul then
13686: LD_VAR 0 1
13690: PUSH
13691: LD_EXP 56
13695: EQUAL
13696: IFFALSE 13706
// abdul_escaped := false ;
13698: LD_ADDR_EXP 13
13702: PUSH
13703: LD_INT 0
13705: ST_TO_ADDR
// if un in ru_attackers then
13706: LD_VAR 0 1
13710: PUSH
13711: LD_EXP 53
13715: IN
13716: IFFALSE 13734
// ru_attackers := ru_attackers diff un ;
13718: LD_ADDR_EXP 53
13722: PUSH
13723: LD_EXP 53
13727: PUSH
13728: LD_VAR 0 1
13732: DIFF
13733: ST_TO_ADDR
// if un in ar_attackers then
13734: LD_VAR 0 1
13738: PUSH
13739: LD_EXP 11
13743: IN
13744: IFFALSE 13762
// ar_attackers := ar_attackers diff un ;
13746: LD_ADDR_EXP 11
13750: PUSH
13751: LD_EXP 11
13755: PUSH
13756: LD_VAR 0 1
13760: DIFF
13761: ST_TO_ADDR
// if un = JMM then
13762: LD_VAR 0 1
13766: PUSH
13767: LD_EXP 16
13771: EQUAL
13772: IFFALSE 13783
// begin YouLost ( JMM ) ;
13774: LD_STRING JMM
13776: PPUSH
13777: CALL_OW 104
// exit ;
13781: GO 13880
// end ; if un = Burlak then
13783: LD_VAR 0 1
13787: PUSH
13788: LD_EXP 47
13792: EQUAL
13793: IFFALSE 13804
// begin YouLost ( Burlak ) ;
13795: LD_STRING Burlak
13797: PPUSH
13798: CALL_OW 104
// exit ;
13802: GO 13880
// end ; if un = freedom then
13804: LD_VAR 0 1
13808: PUSH
13809: LD_EXP 3
13813: EQUAL
13814: IFFALSE 13825
// begin YouLost ( Destroyed ) ;
13816: LD_STRING Destroyed
13818: PPUSH
13819: CALL_OW 104
// exit ;
13823: GO 13880
// end ; if un = Masha then
13825: LD_VAR 0 1
13829: PUSH
13830: LD_EXP 50
13834: EQUAL
13835: IFFALSE 13852
// begin ChangeMissionObjectives ( M4b ) ;
13837: LD_STRING M4b
13839: PPUSH
13840: CALL_OW 337
// masha_killed := true ;
13844: LD_ADDR_EXP 10
13848: PUSH
13849: LD_INT 1
13851: ST_TO_ADDR
// end ; if un = Mastodont then
13852: LD_VAR 0 1
13856: PUSH
13857: LD_EXP 57
13861: EQUAL
13862: IFFALSE 13871
// ChangeMissionObjectives ( M4a ) ;
13864: LD_STRING M4a
13866: PPUSH
13867: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13871: LD_VAR 0 1
13875: PPUSH
13876: CALL 83092 0 1
// end ;
13880: PPOPN 3
13882: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13883: LD_VAR 0 1
13887: PPUSH
13888: LD_VAR 0 2
13892: PPUSH
13893: CALL 85426 0 2
// end ;
13897: PPOPN 2
13899: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13900: LD_VAR 0 1
13904: PPUSH
13905: CALL 84494 0 1
// end ;
13909: PPOPN 1
13911: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13912: LD_VAR 0 1
13916: PUSH
13917: LD_INT 22
13919: PUSH
13920: LD_INT 7
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: PUSH
13927: LD_INT 30
13929: PUSH
13930: LD_INT 0
13932: PUSH
13933: EMPTY
13934: LIST
13935: LIST
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: PPUSH
13941: CALL_OW 69
13945: IN
13946: IFFALSE 13985
// begin SetBName ( building , freedom ) ;
13948: LD_VAR 0 1
13952: PPUSH
13953: LD_STRING freedom
13955: PPUSH
13956: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13960: LD_INT 0
13962: PPUSH
13963: LD_INT 7
13965: PPUSH
13966: LD_INT 0
13968: PPUSH
13969: CALL_OW 324
// freedom := building ;
13973: LD_ADDR_EXP 3
13977: PUSH
13978: LD_VAR 0 1
13982: ST_TO_ADDR
// exit ;
13983: GO 14051
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13985: LD_VAR 0 1
13989: PUSH
13990: LD_INT 22
13992: PUSH
13993: LD_INT 7
13995: PUSH
13996: EMPTY
13997: LIST
13998: LIST
13999: PUSH
14000: LD_INT 23
14002: PUSH
14003: LD_INT 3
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: PUSH
14010: LD_INT 30
14012: PUSH
14013: LD_INT 6
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: PUSH
14020: EMPTY
14021: LIST
14022: LIST
14023: LIST
14024: PPUSH
14025: CALL_OW 69
14029: IN
14030: IFFALSE 14042
// begin ru_lab_builded := true ;
14032: LD_ADDR_EXP 5
14036: PUSH
14037: LD_INT 1
14039: ST_TO_ADDR
// exit ;
14040: GO 14051
// end ; MCE_BuildingComplete ( building ) ;
14042: LD_VAR 0 1
14046: PPUSH
14047: CALL 84735 0 1
// end ;
14051: PPOPN 1
14053: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14054: LD_VAR 0 1
14058: PPUSH
14059: LD_VAR 0 2
14063: PPUSH
14064: CALL 82788 0 2
// end ;
14068: PPOPN 2
14070: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14071: LD_VAR 0 1
14075: PPUSH
14076: LD_VAR 0 2
14080: PPUSH
14081: LD_VAR 0 3
14085: PPUSH
14086: LD_VAR 0 4
14090: PPUSH
14091: LD_VAR 0 5
14095: PPUSH
14096: CALL 82408 0 5
// end ;
14100: PPOPN 5
14102: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
14103: LD_VAR 0 1
14107: PPUSH
14108: LD_VAR 0 2
14112: PPUSH
14113: CALL 100710 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
14117: LD_VAR 0 1
14121: PPUSH
14122: LD_VAR 0 2
14126: PPUSH
14127: CALL 81989 0 2
// end ;
14131: PPOPN 2
14133: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14134: LD_VAR 0 1
14138: PPUSH
14139: CALL_OW 263
14143: PUSH
14144: LD_INT 3
14146: EQUAL
14147: PUSH
14148: LD_VAR 0 2
14152: PPUSH
14153: CALL_OW 263
14157: PUSH
14158: LD_INT 3
14160: EQUAL
14161: OR
14162: IFFALSE 14178
// hack_counter := hack_counter + 1 ;
14164: LD_ADDR_EXP 15
14168: PUSH
14169: LD_EXP 15
14173: PUSH
14174: LD_INT 1
14176: PLUS
14177: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14178: LD_VAR 0 1
14182: PPUSH
14183: LD_VAR 0 2
14187: PPUSH
14188: LD_VAR 0 3
14192: PPUSH
14193: LD_VAR 0 4
14197: PPUSH
14198: CALL 81827 0 4
// end ;
14202: PPOPN 4
14204: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14205: LD_VAR 0 1
14209: PPUSH
14210: LD_VAR 0 2
14214: PPUSH
14215: LD_VAR 0 3
14219: PPUSH
14220: CALL 81602 0 3
// end ;
14224: PPOPN 3
14226: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14227: LD_VAR 0 1
14231: PPUSH
14232: LD_VAR 0 2
14236: PPUSH
14237: CALL 81487 0 2
// end ;
14241: PPOPN 2
14243: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14244: LD_VAR 0 1
14248: PPUSH
14249: LD_VAR 0 2
14253: PPUSH
14254: CALL 85721 0 2
// end ;
14258: PPOPN 2
14260: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14261: LD_VAR 0 1
14265: PPUSH
14266: LD_VAR 0 2
14270: PPUSH
14271: LD_VAR 0 3
14275: PPUSH
14276: LD_VAR 0 4
14280: PPUSH
14281: CALL 85937 0 4
// end ;
14285: PPOPN 4
14287: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14288: LD_VAR 0 1
14292: PPUSH
14293: LD_VAR 0 2
14297: PPUSH
14298: CALL 81296 0 2
// end ;
14302: PPOPN 2
14304: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14305: LD_VAR 0 1
14309: PPUSH
14310: CALL 100694 0 1
// end ; end_of_file
14314: PPOPN 1
14316: END
// every 0 0$30 do var cr , time ;
14317: GO 14319
14319: DISABLE
14320: LD_INT 0
14322: PPUSH
14323: PPUSH
// begin time := 0 0$20 ;
14324: LD_ADDR_VAR 0 2
14328: PUSH
14329: LD_INT 700
14331: ST_TO_ADDR
// while game do
14332: LD_EXP 2
14336: IFFALSE 14439
// begin wait ( time ) ;
14338: LD_VAR 0 2
14342: PPUSH
14343: CALL_OW 67
// if tick > 2 2$00 then
14347: LD_OWVAR 1
14351: PUSH
14352: LD_INT 4200
14354: GREATER
14355: IFFALSE 14392
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14357: LD_ADDR_VAR 0 2
14361: PUSH
14362: LD_VAR 0 2
14366: PUSH
14367: LD_INT 140
14369: PUSH
14370: LD_INT 140
14372: PUSH
14373: LD_INT 210
14375: PUSH
14376: LD_INT 280
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: PUSH
14385: LD_OWVAR 67
14389: ARRAY
14390: PLUS
14391: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14392: LD_INT 1
14394: PPUSH
14395: LD_INT 5
14397: PPUSH
14398: CALL_OW 12
14402: PPUSH
14403: LD_INT 70
14405: PPUSH
14406: LD_INT 49
14408: PPUSH
14409: LD_INT 25
14411: PPUSH
14412: LD_INT 1
14414: PPUSH
14415: CALL_OW 56
// if time > 3 3$00 then
14419: LD_VAR 0 2
14423: PUSH
14424: LD_INT 6300
14426: GREATER
14427: IFFALSE 14437
// time := 0 0$30 ;
14429: LD_ADDR_VAR 0 2
14433: PUSH
14434: LD_INT 1050
14436: ST_TO_ADDR
// end ;
14437: GO 14332
// end ;
14439: PPOPN 2
14441: END
// every 0 0$30 do var cr , time ;
14442: GO 14444
14444: DISABLE
14445: LD_INT 0
14447: PPUSH
14448: PPUSH
// begin time := 0 0$20 ;
14449: LD_ADDR_VAR 0 2
14453: PUSH
14454: LD_INT 700
14456: ST_TO_ADDR
// while game do
14457: LD_EXP 2
14461: IFFALSE 14554
// begin wait ( time ) ;
14463: LD_VAR 0 2
14467: PPUSH
14468: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14472: LD_ADDR_VAR 0 2
14476: PUSH
14477: LD_VAR 0 2
14481: PUSH
14482: LD_INT 140
14484: PUSH
14485: LD_INT 175
14487: PUSH
14488: LD_INT 210
14490: PUSH
14491: LD_INT 280
14493: PUSH
14494: EMPTY
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: PUSH
14500: LD_OWVAR 67
14504: ARRAY
14505: PLUS
14506: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14507: LD_INT 3
14509: PPUSH
14510: LD_INT 5
14512: PPUSH
14513: CALL_OW 12
14517: PPUSH
14518: LD_INT 26
14520: PPUSH
14521: LD_INT 9
14523: PPUSH
14524: LD_INT 30
14526: PPUSH
14527: LD_INT 1
14529: PPUSH
14530: CALL_OW 56
// if time > 3 3$00 then
14534: LD_VAR 0 2
14538: PUSH
14539: LD_INT 6300
14541: GREATER
14542: IFFALSE 14552
// time := 0 0$20 ;
14544: LD_ADDR_VAR 0 2
14548: PUSH
14549: LD_INT 700
14551: ST_TO_ADDR
// end ;
14552: GO 14457
// end ;
14554: PPOPN 2
14556: END
// every 0 0$30 do var cr , time ;
14557: GO 14559
14559: DISABLE
14560: LD_INT 0
14562: PPUSH
14563: PPUSH
// begin time := 0 0$20 ;
14564: LD_ADDR_VAR 0 2
14568: PUSH
14569: LD_INT 700
14571: ST_TO_ADDR
// while game do
14572: LD_EXP 2
14576: IFFALSE 14705
// begin wait ( time ) ;
14578: LD_VAR 0 2
14582: PPUSH
14583: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
14587: LD_ADDR_VAR 0 2
14591: PUSH
14592: LD_VAR 0 2
14596: PUSH
14597: LD_INT 175
14599: PUSH
14600: LD_INT 210
14602: PUSH
14603: LD_INT 280
14605: PUSH
14606: LD_INT 350
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: PUSH
14615: LD_OWVAR 67
14619: ARRAY
14620: PLUS
14621: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14622: LD_INT 1
14624: PPUSH
14625: LD_INT 5
14627: PPUSH
14628: CALL_OW 12
14632: PPUSH
14633: LD_INT 179
14635: PPUSH
14636: LD_INT 101
14638: PPUSH
14639: LD_INT 20
14641: PPUSH
14642: LD_INT 1
14644: PPUSH
14645: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14649: LD_INT 350
14651: PPUSH
14652: LD_INT 525
14654: PPUSH
14655: CALL_OW 12
14659: PPUSH
14660: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14664: LD_INT 1
14666: PPUSH
14667: LD_INT 5
14669: PPUSH
14670: CALL_OW 12
14674: PPUSH
14675: LD_INT 9
14677: PPUSH
14678: LD_INT 1
14680: PPUSH
14681: CALL_OW 55
// if time > 4 4$00 then
14685: LD_VAR 0 2
14689: PUSH
14690: LD_INT 8400
14692: GREATER
14693: IFFALSE 14703
// time := 0 0$30 ;
14695: LD_ADDR_VAR 0 2
14699: PUSH
14700: LD_INT 1050
14702: ST_TO_ADDR
// end ;
14703: GO 14572
// end ;
14705: PPOPN 2
14707: END
// every 0 0$30 do var cr , time ;
14708: GO 14710
14710: DISABLE
14711: LD_INT 0
14713: PPUSH
14714: PPUSH
// begin time := 0 0$10 ;
14715: LD_ADDR_VAR 0 2
14719: PUSH
14720: LD_INT 350
14722: ST_TO_ADDR
// while game do
14723: LD_EXP 2
14727: IFFALSE 14861
// begin wait ( time ) ;
14729: LD_VAR 0 2
14733: PPUSH
14734: CALL_OW 67
// time := time + 0 0$10 ;
14738: LD_ADDR_VAR 0 2
14742: PUSH
14743: LD_VAR 0 2
14747: PUSH
14748: LD_INT 350
14750: PLUS
14751: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14752: LD_INT 1
14754: PPUSH
14755: LD_INT 5
14757: PPUSH
14758: CALL_OW 12
14762: PPUSH
14763: LD_INT 11
14765: PPUSH
14766: LD_INT 1
14768: PPUSH
14769: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14773: LD_ADDR_VAR 0 1
14777: PUSH
14778: LD_INT 1
14780: PPUSH
14781: LD_INT 3
14783: PPUSH
14784: CALL_OW 12
14788: ST_TO_ADDR
// if cr = 1 then
14789: LD_VAR 0 1
14793: PUSH
14794: LD_INT 1
14796: EQUAL
14797: IFFALSE 14841
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14799: LD_INT 700
14801: PPUSH
14802: LD_INT 1575
14804: PPUSH
14805: CALL_OW 12
14809: PPUSH
14810: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14814: LD_INT 1
14816: PPUSH
14817: LD_INT 5
14819: PPUSH
14820: CALL_OW 12
14824: PPUSH
14825: LD_INT 34
14827: PPUSH
14828: LD_INT 50
14830: PPUSH
14831: LD_INT 7
14833: PPUSH
14834: LD_INT 1
14836: PPUSH
14837: CALL_OW 56
// end ; if time > 4 4$00 then
14841: LD_VAR 0 2
14845: PUSH
14846: LD_INT 8400
14848: GREATER
14849: IFFALSE 14859
// time := 0 0$40 ;
14851: LD_ADDR_VAR 0 2
14855: PUSH
14856: LD_INT 1400
14858: ST_TO_ADDR
// end ;
14859: GO 14723
// end ; end_of_file
14861: PPOPN 2
14863: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14864: LD_INT 0
14866: PPUSH
14867: PPUSH
// if exist_mode then
14868: LD_VAR 0 2
14872: IFFALSE 14897
// unit := CreateCharacter ( prefix & ident ) else
14874: LD_ADDR_VAR 0 5
14878: PUSH
14879: LD_VAR 0 3
14883: PUSH
14884: LD_VAR 0 1
14888: STR
14889: PPUSH
14890: CALL_OW 34
14894: ST_TO_ADDR
14895: GO 14912
// unit := NewCharacter ( ident ) ;
14897: LD_ADDR_VAR 0 5
14901: PUSH
14902: LD_VAR 0 1
14906: PPUSH
14907: CALL_OW 25
14911: ST_TO_ADDR
// result := unit ;
14912: LD_ADDR_VAR 0 4
14916: PUSH
14917: LD_VAR 0 5
14921: ST_TO_ADDR
// end ;
14922: LD_VAR 0 4
14926: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14927: LD_INT 0
14929: PPUSH
14930: PPUSH
// if not side or not nation then
14931: LD_VAR 0 1
14935: NOT
14936: PUSH
14937: LD_VAR 0 2
14941: NOT
14942: OR
14943: IFFALSE 14947
// exit ;
14945: GO 15715
// case nation of nation_american :
14947: LD_VAR 0 2
14951: PUSH
14952: LD_INT 1
14954: DOUBLE
14955: EQUAL
14956: IFTRUE 14960
14958: GO 15174
14960: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14961: LD_ADDR_VAR 0 4
14965: PUSH
14966: LD_INT 35
14968: PUSH
14969: LD_INT 45
14971: PUSH
14972: LD_INT 46
14974: PUSH
14975: LD_INT 47
14977: PUSH
14978: LD_INT 82
14980: PUSH
14981: LD_INT 83
14983: PUSH
14984: LD_INT 84
14986: PUSH
14987: LD_INT 85
14989: PUSH
14990: LD_INT 86
14992: PUSH
14993: LD_INT 1
14995: PUSH
14996: LD_INT 2
14998: PUSH
14999: LD_INT 6
15001: PUSH
15002: LD_INT 15
15004: PUSH
15005: LD_INT 16
15007: PUSH
15008: LD_INT 7
15010: PUSH
15011: LD_INT 12
15013: PUSH
15014: LD_INT 13
15016: PUSH
15017: LD_INT 10
15019: PUSH
15020: LD_INT 14
15022: PUSH
15023: LD_INT 20
15025: PUSH
15026: LD_INT 21
15028: PUSH
15029: LD_INT 22
15031: PUSH
15032: LD_INT 25
15034: PUSH
15035: LD_INT 32
15037: PUSH
15038: LD_INT 27
15040: PUSH
15041: LD_INT 36
15043: PUSH
15044: LD_INT 69
15046: PUSH
15047: LD_INT 39
15049: PUSH
15050: LD_INT 34
15052: PUSH
15053: LD_INT 40
15055: PUSH
15056: LD_INT 48
15058: PUSH
15059: LD_INT 49
15061: PUSH
15062: LD_INT 50
15064: PUSH
15065: LD_INT 51
15067: PUSH
15068: LD_INT 52
15070: PUSH
15071: LD_INT 53
15073: PUSH
15074: LD_INT 54
15076: PUSH
15077: LD_INT 55
15079: PUSH
15080: LD_INT 56
15082: PUSH
15083: LD_INT 57
15085: PUSH
15086: LD_INT 58
15088: PUSH
15089: LD_INT 59
15091: PUSH
15092: LD_INT 60
15094: PUSH
15095: LD_INT 61
15097: PUSH
15098: LD_INT 62
15100: PUSH
15101: LD_INT 80
15103: PUSH
15104: LD_INT 82
15106: PUSH
15107: LD_INT 83
15109: PUSH
15110: LD_INT 84
15112: PUSH
15113: LD_INT 85
15115: PUSH
15116: LD_INT 86
15118: PUSH
15119: EMPTY
15120: LIST
15121: LIST
15122: LIST
15123: LIST
15124: LIST
15125: LIST
15126: LIST
15127: LIST
15128: LIST
15129: LIST
15130: LIST
15131: LIST
15132: LIST
15133: LIST
15134: LIST
15135: LIST
15136: LIST
15137: LIST
15138: LIST
15139: LIST
15140: LIST
15141: LIST
15142: LIST
15143: LIST
15144: LIST
15145: LIST
15146: LIST
15147: LIST
15148: LIST
15149: LIST
15150: LIST
15151: LIST
15152: LIST
15153: LIST
15154: LIST
15155: LIST
15156: LIST
15157: LIST
15158: LIST
15159: LIST
15160: LIST
15161: LIST
15162: LIST
15163: LIST
15164: LIST
15165: LIST
15166: LIST
15167: LIST
15168: LIST
15169: LIST
15170: LIST
15171: ST_TO_ADDR
15172: GO 15639
15174: LD_INT 2
15176: DOUBLE
15177: EQUAL
15178: IFTRUE 15182
15180: GO 15408
15182: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15183: LD_ADDR_VAR 0 4
15187: PUSH
15188: LD_INT 35
15190: PUSH
15191: LD_INT 45
15193: PUSH
15194: LD_INT 46
15196: PUSH
15197: LD_INT 47
15199: PUSH
15200: LD_INT 82
15202: PUSH
15203: LD_INT 83
15205: PUSH
15206: LD_INT 84
15208: PUSH
15209: LD_INT 85
15211: PUSH
15212: LD_INT 87
15214: PUSH
15215: LD_INT 70
15217: PUSH
15218: LD_INT 1
15220: PUSH
15221: LD_INT 11
15223: PUSH
15224: LD_INT 3
15226: PUSH
15227: LD_INT 4
15229: PUSH
15230: LD_INT 5
15232: PUSH
15233: LD_INT 6
15235: PUSH
15236: LD_INT 15
15238: PUSH
15239: LD_INT 18
15241: PUSH
15242: LD_INT 7
15244: PUSH
15245: LD_INT 17
15247: PUSH
15248: LD_INT 8
15250: PUSH
15251: LD_INT 20
15253: PUSH
15254: LD_INT 21
15256: PUSH
15257: LD_INT 22
15259: PUSH
15260: LD_INT 72
15262: PUSH
15263: LD_INT 26
15265: PUSH
15266: LD_INT 69
15268: PUSH
15269: LD_INT 39
15271: PUSH
15272: LD_INT 40
15274: PUSH
15275: LD_INT 41
15277: PUSH
15278: LD_INT 42
15280: PUSH
15281: LD_INT 43
15283: PUSH
15284: LD_INT 48
15286: PUSH
15287: LD_INT 49
15289: PUSH
15290: LD_INT 50
15292: PUSH
15293: LD_INT 51
15295: PUSH
15296: LD_INT 52
15298: PUSH
15299: LD_INT 53
15301: PUSH
15302: LD_INT 54
15304: PUSH
15305: LD_INT 55
15307: PUSH
15308: LD_INT 56
15310: PUSH
15311: LD_INT 60
15313: PUSH
15314: LD_INT 61
15316: PUSH
15317: LD_INT 62
15319: PUSH
15320: LD_INT 66
15322: PUSH
15323: LD_INT 67
15325: PUSH
15326: LD_INT 68
15328: PUSH
15329: LD_INT 81
15331: PUSH
15332: LD_INT 82
15334: PUSH
15335: LD_INT 83
15337: PUSH
15338: LD_INT 84
15340: PUSH
15341: LD_INT 85
15343: PUSH
15344: LD_INT 87
15346: PUSH
15347: LD_INT 88
15349: PUSH
15350: EMPTY
15351: LIST
15352: LIST
15353: LIST
15354: LIST
15355: LIST
15356: LIST
15357: LIST
15358: LIST
15359: LIST
15360: LIST
15361: LIST
15362: LIST
15363: LIST
15364: LIST
15365: LIST
15366: LIST
15367: LIST
15368: LIST
15369: LIST
15370: LIST
15371: LIST
15372: LIST
15373: LIST
15374: LIST
15375: LIST
15376: LIST
15377: LIST
15378: LIST
15379: LIST
15380: LIST
15381: LIST
15382: LIST
15383: LIST
15384: LIST
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: LIST
15391: LIST
15392: LIST
15393: LIST
15394: LIST
15395: LIST
15396: LIST
15397: LIST
15398: LIST
15399: LIST
15400: LIST
15401: LIST
15402: LIST
15403: LIST
15404: LIST
15405: ST_TO_ADDR
15406: GO 15639
15408: LD_INT 3
15410: DOUBLE
15411: EQUAL
15412: IFTRUE 15416
15414: GO 15638
15416: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15417: LD_ADDR_VAR 0 4
15421: PUSH
15422: LD_INT 46
15424: PUSH
15425: LD_INT 47
15427: PUSH
15428: LD_INT 1
15430: PUSH
15431: LD_INT 2
15433: PUSH
15434: LD_INT 82
15436: PUSH
15437: LD_INT 83
15439: PUSH
15440: LD_INT 84
15442: PUSH
15443: LD_INT 85
15445: PUSH
15446: LD_INT 86
15448: PUSH
15449: LD_INT 11
15451: PUSH
15452: LD_INT 9
15454: PUSH
15455: LD_INT 20
15457: PUSH
15458: LD_INT 19
15460: PUSH
15461: LD_INT 21
15463: PUSH
15464: LD_INT 24
15466: PUSH
15467: LD_INT 22
15469: PUSH
15470: LD_INT 25
15472: PUSH
15473: LD_INT 28
15475: PUSH
15476: LD_INT 29
15478: PUSH
15479: LD_INT 30
15481: PUSH
15482: LD_INT 31
15484: PUSH
15485: LD_INT 37
15487: PUSH
15488: LD_INT 38
15490: PUSH
15491: LD_INT 32
15493: PUSH
15494: LD_INT 27
15496: PUSH
15497: LD_INT 33
15499: PUSH
15500: LD_INT 69
15502: PUSH
15503: LD_INT 39
15505: PUSH
15506: LD_INT 34
15508: PUSH
15509: LD_INT 40
15511: PUSH
15512: LD_INT 71
15514: PUSH
15515: LD_INT 23
15517: PUSH
15518: LD_INT 44
15520: PUSH
15521: LD_INT 48
15523: PUSH
15524: LD_INT 49
15526: PUSH
15527: LD_INT 50
15529: PUSH
15530: LD_INT 51
15532: PUSH
15533: LD_INT 52
15535: PUSH
15536: LD_INT 53
15538: PUSH
15539: LD_INT 54
15541: PUSH
15542: LD_INT 55
15544: PUSH
15545: LD_INT 56
15547: PUSH
15548: LD_INT 57
15550: PUSH
15551: LD_INT 58
15553: PUSH
15554: LD_INT 59
15556: PUSH
15557: LD_INT 63
15559: PUSH
15560: LD_INT 64
15562: PUSH
15563: LD_INT 65
15565: PUSH
15566: LD_INT 82
15568: PUSH
15569: LD_INT 83
15571: PUSH
15572: LD_INT 84
15574: PUSH
15575: LD_INT 85
15577: PUSH
15578: LD_INT 86
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: LIST
15585: LIST
15586: LIST
15587: LIST
15588: LIST
15589: LIST
15590: LIST
15591: LIST
15592: LIST
15593: LIST
15594: LIST
15595: LIST
15596: LIST
15597: LIST
15598: LIST
15599: LIST
15600: LIST
15601: LIST
15602: LIST
15603: LIST
15604: LIST
15605: LIST
15606: LIST
15607: LIST
15608: LIST
15609: LIST
15610: LIST
15611: LIST
15612: LIST
15613: LIST
15614: LIST
15615: LIST
15616: LIST
15617: LIST
15618: LIST
15619: LIST
15620: LIST
15621: LIST
15622: LIST
15623: LIST
15624: LIST
15625: LIST
15626: LIST
15627: LIST
15628: LIST
15629: LIST
15630: LIST
15631: LIST
15632: LIST
15633: LIST
15634: LIST
15635: ST_TO_ADDR
15636: GO 15639
15638: POP
// if state > - 1 and state < 3 then
15639: LD_VAR 0 3
15643: PUSH
15644: LD_INT 1
15646: NEG
15647: GREATER
15648: PUSH
15649: LD_VAR 0 3
15653: PUSH
15654: LD_INT 3
15656: LESS
15657: AND
15658: IFFALSE 15715
// for i in result do
15660: LD_ADDR_VAR 0 5
15664: PUSH
15665: LD_VAR 0 4
15669: PUSH
15670: FOR_IN
15671: IFFALSE 15713
// if GetTech ( i , side ) <> state then
15673: LD_VAR 0 5
15677: PPUSH
15678: LD_VAR 0 1
15682: PPUSH
15683: CALL_OW 321
15687: PUSH
15688: LD_VAR 0 3
15692: NONEQUAL
15693: IFFALSE 15711
// result := result diff i ;
15695: LD_ADDR_VAR 0 4
15699: PUSH
15700: LD_VAR 0 4
15704: PUSH
15705: LD_VAR 0 5
15709: DIFF
15710: ST_TO_ADDR
15711: GO 15670
15713: POP
15714: POP
// end ;
15715: LD_VAR 0 4
15719: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15720: LD_INT 0
15722: PPUSH
15723: PPUSH
15724: PPUSH
// result := true ;
15725: LD_ADDR_VAR 0 3
15729: PUSH
15730: LD_INT 1
15732: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15733: LD_ADDR_VAR 0 5
15737: PUSH
15738: LD_VAR 0 2
15742: PPUSH
15743: CALL_OW 480
15747: ST_TO_ADDR
// if not tmp then
15748: LD_VAR 0 5
15752: NOT
15753: IFFALSE 15757
// exit ;
15755: GO 15806
// for i in tmp do
15757: LD_ADDR_VAR 0 4
15761: PUSH
15762: LD_VAR 0 5
15766: PUSH
15767: FOR_IN
15768: IFFALSE 15804
// if GetTech ( i , side ) <> state_researched then
15770: LD_VAR 0 4
15774: PPUSH
15775: LD_VAR 0 1
15779: PPUSH
15780: CALL_OW 321
15784: PUSH
15785: LD_INT 2
15787: NONEQUAL
15788: IFFALSE 15802
// begin result := false ;
15790: LD_ADDR_VAR 0 3
15794: PUSH
15795: LD_INT 0
15797: ST_TO_ADDR
// exit ;
15798: POP
15799: POP
15800: GO 15806
// end ;
15802: GO 15767
15804: POP
15805: POP
// end ;
15806: LD_VAR 0 3
15810: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15811: LD_INT 0
15813: PPUSH
15814: PPUSH
15815: PPUSH
15816: PPUSH
15817: PPUSH
15818: PPUSH
15819: PPUSH
15820: PPUSH
15821: PPUSH
15822: PPUSH
15823: PPUSH
15824: PPUSH
15825: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15826: LD_VAR 0 1
15830: NOT
15831: PUSH
15832: LD_VAR 0 1
15836: PPUSH
15837: CALL_OW 257
15841: PUSH
15842: LD_INT 9
15844: NONEQUAL
15845: OR
15846: IFFALSE 15850
// exit ;
15848: GO 16423
// side := GetSide ( unit ) ;
15850: LD_ADDR_VAR 0 9
15854: PUSH
15855: LD_VAR 0 1
15859: PPUSH
15860: CALL_OW 255
15864: ST_TO_ADDR
// tech_space := tech_spacanom ;
15865: LD_ADDR_VAR 0 12
15869: PUSH
15870: LD_INT 29
15872: ST_TO_ADDR
// tech_time := tech_taurad ;
15873: LD_ADDR_VAR 0 13
15877: PUSH
15878: LD_INT 28
15880: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15881: LD_ADDR_VAR 0 11
15885: PUSH
15886: LD_VAR 0 1
15890: PPUSH
15891: CALL_OW 310
15895: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15896: LD_VAR 0 11
15900: PPUSH
15901: CALL_OW 247
15905: PUSH
15906: LD_INT 2
15908: EQUAL
15909: IFFALSE 15913
// exit ;
15911: GO 16423
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15913: LD_ADDR_VAR 0 8
15917: PUSH
15918: LD_INT 81
15920: PUSH
15921: LD_VAR 0 9
15925: PUSH
15926: EMPTY
15927: LIST
15928: LIST
15929: PUSH
15930: LD_INT 3
15932: PUSH
15933: LD_INT 21
15935: PUSH
15936: LD_INT 3
15938: PUSH
15939: EMPTY
15940: LIST
15941: LIST
15942: PUSH
15943: EMPTY
15944: LIST
15945: LIST
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: PPUSH
15951: CALL_OW 69
15955: ST_TO_ADDR
// if not tmp then
15956: LD_VAR 0 8
15960: NOT
15961: IFFALSE 15965
// exit ;
15963: GO 16423
// if in_unit then
15965: LD_VAR 0 11
15969: IFFALSE 15993
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15971: LD_ADDR_VAR 0 10
15975: PUSH
15976: LD_VAR 0 8
15980: PPUSH
15981: LD_VAR 0 11
15985: PPUSH
15986: CALL_OW 74
15990: ST_TO_ADDR
15991: GO 16013
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15993: LD_ADDR_VAR 0 10
15997: PUSH
15998: LD_VAR 0 8
16002: PPUSH
16003: LD_VAR 0 1
16007: PPUSH
16008: CALL_OW 74
16012: ST_TO_ADDR
// if not enemy then
16013: LD_VAR 0 10
16017: NOT
16018: IFFALSE 16022
// exit ;
16020: GO 16423
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
16022: LD_VAR 0 11
16026: PUSH
16027: LD_VAR 0 11
16031: PPUSH
16032: LD_VAR 0 10
16036: PPUSH
16037: CALL_OW 296
16041: PUSH
16042: LD_INT 13
16044: GREATER
16045: AND
16046: PUSH
16047: LD_VAR 0 1
16051: PPUSH
16052: LD_VAR 0 10
16056: PPUSH
16057: CALL_OW 296
16061: PUSH
16062: LD_INT 12
16064: GREATER
16065: OR
16066: IFFALSE 16070
// exit ;
16068: GO 16423
// missile := [ 1 ] ;
16070: LD_ADDR_VAR 0 14
16074: PUSH
16075: LD_INT 1
16077: PUSH
16078: EMPTY
16079: LIST
16080: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16081: LD_VAR 0 9
16085: PPUSH
16086: LD_VAR 0 12
16090: PPUSH
16091: CALL_OW 325
16095: IFFALSE 16124
// missile := Replace ( missile , missile + 1 , 2 ) ;
16097: LD_ADDR_VAR 0 14
16101: PUSH
16102: LD_VAR 0 14
16106: PPUSH
16107: LD_VAR 0 14
16111: PUSH
16112: LD_INT 1
16114: PLUS
16115: PPUSH
16116: LD_INT 2
16118: PPUSH
16119: CALL_OW 1
16123: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16124: LD_VAR 0 9
16128: PPUSH
16129: LD_VAR 0 13
16133: PPUSH
16134: CALL_OW 325
16138: PUSH
16139: LD_VAR 0 10
16143: PPUSH
16144: CALL_OW 255
16148: PPUSH
16149: LD_VAR 0 13
16153: PPUSH
16154: CALL_OW 325
16158: NOT
16159: AND
16160: IFFALSE 16189
// missile := Replace ( missile , missile + 1 , 3 ) ;
16162: LD_ADDR_VAR 0 14
16166: PUSH
16167: LD_VAR 0 14
16171: PPUSH
16172: LD_VAR 0 14
16176: PUSH
16177: LD_INT 1
16179: PLUS
16180: PPUSH
16181: LD_INT 3
16183: PPUSH
16184: CALL_OW 1
16188: ST_TO_ADDR
// if missile < 2 then
16189: LD_VAR 0 14
16193: PUSH
16194: LD_INT 2
16196: LESS
16197: IFFALSE 16201
// exit ;
16199: GO 16423
// x := GetX ( enemy ) ;
16201: LD_ADDR_VAR 0 4
16205: PUSH
16206: LD_VAR 0 10
16210: PPUSH
16211: CALL_OW 250
16215: ST_TO_ADDR
// y := GetY ( enemy ) ;
16216: LD_ADDR_VAR 0 5
16220: PUSH
16221: LD_VAR 0 10
16225: PPUSH
16226: CALL_OW 251
16230: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16231: LD_ADDR_VAR 0 6
16235: PUSH
16236: LD_VAR 0 4
16240: PUSH
16241: LD_INT 1
16243: NEG
16244: PPUSH
16245: LD_INT 1
16247: PPUSH
16248: CALL_OW 12
16252: PLUS
16253: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16254: LD_ADDR_VAR 0 7
16258: PUSH
16259: LD_VAR 0 5
16263: PUSH
16264: LD_INT 1
16266: NEG
16267: PPUSH
16268: LD_INT 1
16270: PPUSH
16271: CALL_OW 12
16275: PLUS
16276: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16277: LD_VAR 0 6
16281: PPUSH
16282: LD_VAR 0 7
16286: PPUSH
16287: CALL_OW 488
16291: NOT
16292: IFFALSE 16314
// begin _x := x ;
16294: LD_ADDR_VAR 0 6
16298: PUSH
16299: LD_VAR 0 4
16303: ST_TO_ADDR
// _y := y ;
16304: LD_ADDR_VAR 0 7
16308: PUSH
16309: LD_VAR 0 5
16313: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16314: LD_ADDR_VAR 0 3
16318: PUSH
16319: LD_INT 1
16321: PPUSH
16322: LD_VAR 0 14
16326: PPUSH
16327: CALL_OW 12
16331: ST_TO_ADDR
// case i of 1 :
16332: LD_VAR 0 3
16336: PUSH
16337: LD_INT 1
16339: DOUBLE
16340: EQUAL
16341: IFTRUE 16345
16343: GO 16362
16345: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16346: LD_VAR 0 1
16350: PPUSH
16351: LD_VAR 0 10
16355: PPUSH
16356: CALL_OW 115
16360: GO 16423
16362: LD_INT 2
16364: DOUBLE
16365: EQUAL
16366: IFTRUE 16370
16368: GO 16392
16370: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16371: LD_VAR 0 1
16375: PPUSH
16376: LD_VAR 0 6
16380: PPUSH
16381: LD_VAR 0 7
16385: PPUSH
16386: CALL_OW 153
16390: GO 16423
16392: LD_INT 3
16394: DOUBLE
16395: EQUAL
16396: IFTRUE 16400
16398: GO 16422
16400: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16401: LD_VAR 0 1
16405: PPUSH
16406: LD_VAR 0 6
16410: PPUSH
16411: LD_VAR 0 7
16415: PPUSH
16416: CALL_OW 154
16420: GO 16423
16422: POP
// end ;
16423: LD_VAR 0 2
16427: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16428: LD_INT 0
16430: PPUSH
16431: PPUSH
16432: PPUSH
16433: PPUSH
16434: PPUSH
16435: PPUSH
// if not unit or not building then
16436: LD_VAR 0 1
16440: NOT
16441: PUSH
16442: LD_VAR 0 2
16446: NOT
16447: OR
16448: IFFALSE 16452
// exit ;
16450: GO 16610
// x := GetX ( building ) ;
16452: LD_ADDR_VAR 0 5
16456: PUSH
16457: LD_VAR 0 2
16461: PPUSH
16462: CALL_OW 250
16466: ST_TO_ADDR
// y := GetY ( building ) ;
16467: LD_ADDR_VAR 0 6
16471: PUSH
16472: LD_VAR 0 2
16476: PPUSH
16477: CALL_OW 251
16481: ST_TO_ADDR
// for i = 0 to 5 do
16482: LD_ADDR_VAR 0 4
16486: PUSH
16487: DOUBLE
16488: LD_INT 0
16490: DEC
16491: ST_TO_ADDR
16492: LD_INT 5
16494: PUSH
16495: FOR_TO
16496: IFFALSE 16608
// begin _x := ShiftX ( x , i , 3 ) ;
16498: LD_ADDR_VAR 0 7
16502: PUSH
16503: LD_VAR 0 5
16507: PPUSH
16508: LD_VAR 0 4
16512: PPUSH
16513: LD_INT 3
16515: PPUSH
16516: CALL_OW 272
16520: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16521: LD_ADDR_VAR 0 8
16525: PUSH
16526: LD_VAR 0 6
16530: PPUSH
16531: LD_VAR 0 4
16535: PPUSH
16536: LD_INT 3
16538: PPUSH
16539: CALL_OW 273
16543: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16544: LD_VAR 0 7
16548: PPUSH
16549: LD_VAR 0 8
16553: PPUSH
16554: CALL_OW 488
16558: NOT
16559: IFFALSE 16563
// continue ;
16561: GO 16495
// if HexInfo ( _x , _y ) = 0 then
16563: LD_VAR 0 7
16567: PPUSH
16568: LD_VAR 0 8
16572: PPUSH
16573: CALL_OW 428
16577: PUSH
16578: LD_INT 0
16580: EQUAL
16581: IFFALSE 16606
// begin ComMoveXY ( unit , _x , _y ) ;
16583: LD_VAR 0 1
16587: PPUSH
16588: LD_VAR 0 7
16592: PPUSH
16593: LD_VAR 0 8
16597: PPUSH
16598: CALL_OW 111
// exit ;
16602: POP
16603: POP
16604: GO 16610
// end ; end ;
16606: GO 16495
16608: POP
16609: POP
// end ;
16610: LD_VAR 0 3
16614: RET
// export function ScanBase ( side , base_area ) ; begin
16615: LD_INT 0
16617: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16618: LD_ADDR_VAR 0 3
16622: PUSH
16623: LD_VAR 0 2
16627: PPUSH
16628: LD_INT 81
16630: PUSH
16631: LD_VAR 0 1
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: PPUSH
16640: CALL_OW 70
16644: ST_TO_ADDR
// end ;
16645: LD_VAR 0 3
16649: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16650: LD_INT 0
16652: PPUSH
16653: PPUSH
16654: PPUSH
16655: PPUSH
// result := false ;
16656: LD_ADDR_VAR 0 2
16660: PUSH
16661: LD_INT 0
16663: ST_TO_ADDR
// side := GetSide ( unit ) ;
16664: LD_ADDR_VAR 0 3
16668: PUSH
16669: LD_VAR 0 1
16673: PPUSH
16674: CALL_OW 255
16678: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16679: LD_ADDR_VAR 0 4
16683: PUSH
16684: LD_VAR 0 1
16688: PPUSH
16689: CALL_OW 248
16693: ST_TO_ADDR
// case nat of 1 :
16694: LD_VAR 0 4
16698: PUSH
16699: LD_INT 1
16701: DOUBLE
16702: EQUAL
16703: IFTRUE 16707
16705: GO 16718
16707: POP
// tech := tech_lassight ; 2 :
16708: LD_ADDR_VAR 0 5
16712: PUSH
16713: LD_INT 12
16715: ST_TO_ADDR
16716: GO 16757
16718: LD_INT 2
16720: DOUBLE
16721: EQUAL
16722: IFTRUE 16726
16724: GO 16737
16726: POP
// tech := tech_mortar ; 3 :
16727: LD_ADDR_VAR 0 5
16731: PUSH
16732: LD_INT 41
16734: ST_TO_ADDR
16735: GO 16757
16737: LD_INT 3
16739: DOUBLE
16740: EQUAL
16741: IFTRUE 16745
16743: GO 16756
16745: POP
// tech := tech_bazooka ; end ;
16746: LD_ADDR_VAR 0 5
16750: PUSH
16751: LD_INT 44
16753: ST_TO_ADDR
16754: GO 16757
16756: POP
// if Researched ( side , tech ) then
16757: LD_VAR 0 3
16761: PPUSH
16762: LD_VAR 0 5
16766: PPUSH
16767: CALL_OW 325
16771: IFFALSE 16798
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16773: LD_ADDR_VAR 0 2
16777: PUSH
16778: LD_INT 5
16780: PUSH
16781: LD_INT 8
16783: PUSH
16784: LD_INT 9
16786: PUSH
16787: EMPTY
16788: LIST
16789: LIST
16790: LIST
16791: PUSH
16792: LD_VAR 0 4
16796: ARRAY
16797: ST_TO_ADDR
// end ;
16798: LD_VAR 0 2
16802: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16803: LD_INT 0
16805: PPUSH
16806: PPUSH
16807: PPUSH
// if not mines then
16808: LD_VAR 0 2
16812: NOT
16813: IFFALSE 16817
// exit ;
16815: GO 16961
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16817: LD_ADDR_VAR 0 5
16821: PUSH
16822: LD_INT 81
16824: PUSH
16825: LD_VAR 0 1
16829: PUSH
16830: EMPTY
16831: LIST
16832: LIST
16833: PUSH
16834: LD_INT 3
16836: PUSH
16837: LD_INT 21
16839: PUSH
16840: LD_INT 3
16842: PUSH
16843: EMPTY
16844: LIST
16845: LIST
16846: PUSH
16847: EMPTY
16848: LIST
16849: LIST
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: PPUSH
16855: CALL_OW 69
16859: ST_TO_ADDR
// for i in mines do
16860: LD_ADDR_VAR 0 4
16864: PUSH
16865: LD_VAR 0 2
16869: PUSH
16870: FOR_IN
16871: IFFALSE 16959
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16873: LD_VAR 0 4
16877: PUSH
16878: LD_INT 1
16880: ARRAY
16881: PPUSH
16882: LD_VAR 0 4
16886: PUSH
16887: LD_INT 2
16889: ARRAY
16890: PPUSH
16891: CALL_OW 458
16895: NOT
16896: IFFALSE 16900
// continue ;
16898: GO 16870
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16900: LD_VAR 0 4
16904: PUSH
16905: LD_INT 1
16907: ARRAY
16908: PPUSH
16909: LD_VAR 0 4
16913: PUSH
16914: LD_INT 2
16916: ARRAY
16917: PPUSH
16918: CALL_OW 428
16922: PUSH
16923: LD_VAR 0 5
16927: IN
16928: IFFALSE 16957
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16930: LD_VAR 0 4
16934: PUSH
16935: LD_INT 1
16937: ARRAY
16938: PPUSH
16939: LD_VAR 0 4
16943: PUSH
16944: LD_INT 2
16946: ARRAY
16947: PPUSH
16948: LD_VAR 0 1
16952: PPUSH
16953: CALL_OW 456
// end ;
16957: GO 16870
16959: POP
16960: POP
// end ;
16961: LD_VAR 0 3
16965: RET
// export function Count ( array ) ; var i ; begin
16966: LD_INT 0
16968: PPUSH
16969: PPUSH
// result := 0 ;
16970: LD_ADDR_VAR 0 2
16974: PUSH
16975: LD_INT 0
16977: ST_TO_ADDR
// for i in array do
16978: LD_ADDR_VAR 0 3
16982: PUSH
16983: LD_VAR 0 1
16987: PUSH
16988: FOR_IN
16989: IFFALSE 17013
// if i then
16991: LD_VAR 0 3
16995: IFFALSE 17011
// result := result + 1 ;
16997: LD_ADDR_VAR 0 2
17001: PUSH
17002: LD_VAR 0 2
17006: PUSH
17007: LD_INT 1
17009: PLUS
17010: ST_TO_ADDR
17011: GO 16988
17013: POP
17014: POP
// end ;
17015: LD_VAR 0 2
17019: RET
// export function IsEmpty ( building ) ; begin
17020: LD_INT 0
17022: PPUSH
// if not building then
17023: LD_VAR 0 1
17027: NOT
17028: IFFALSE 17032
// exit ;
17030: GO 17075
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17032: LD_ADDR_VAR 0 2
17036: PUSH
17037: LD_VAR 0 1
17041: PUSH
17042: LD_INT 22
17044: PUSH
17045: LD_VAR 0 1
17049: PPUSH
17050: CALL_OW 255
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: PUSH
17059: LD_INT 58
17061: PUSH
17062: EMPTY
17063: LIST
17064: PUSH
17065: EMPTY
17066: LIST
17067: LIST
17068: PPUSH
17069: CALL_OW 69
17073: IN
17074: ST_TO_ADDR
// end ;
17075: LD_VAR 0 2
17079: RET
// export function IsNotFull ( building ) ; var places ; begin
17080: LD_INT 0
17082: PPUSH
17083: PPUSH
// if not building then
17084: LD_VAR 0 1
17088: NOT
17089: IFFALSE 17093
// exit ;
17091: GO 17264
// result := false ;
17093: LD_ADDR_VAR 0 2
17097: PUSH
17098: LD_INT 0
17100: ST_TO_ADDR
// places := 0 ;
17101: LD_ADDR_VAR 0 3
17105: PUSH
17106: LD_INT 0
17108: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
17109: LD_VAR 0 1
17113: PPUSH
17114: CALL_OW 266
17118: PUSH
17119: LD_INT 0
17121: DOUBLE
17122: EQUAL
17123: IFTRUE 17181
17125: LD_INT 1
17127: DOUBLE
17128: EQUAL
17129: IFTRUE 17181
17131: LD_INT 6
17133: DOUBLE
17134: EQUAL
17135: IFTRUE 17181
17137: LD_INT 7
17139: DOUBLE
17140: EQUAL
17141: IFTRUE 17181
17143: LD_INT 8
17145: DOUBLE
17146: EQUAL
17147: IFTRUE 17181
17149: LD_INT 4
17151: DOUBLE
17152: EQUAL
17153: IFTRUE 17181
17155: LD_INT 5
17157: DOUBLE
17158: EQUAL
17159: IFTRUE 17181
17161: LD_INT 2
17163: DOUBLE
17164: EQUAL
17165: IFTRUE 17181
17167: LD_INT 3
17169: DOUBLE
17170: EQUAL
17171: IFTRUE 17181
17173: LD_INT 35
17175: DOUBLE
17176: EQUAL
17177: IFTRUE 17181
17179: GO 17192
17181: POP
// places := 6 ; b_bunker , b_breastwork :
17182: LD_ADDR_VAR 0 3
17186: PUSH
17187: LD_INT 6
17189: ST_TO_ADDR
17190: GO 17237
17192: LD_INT 32
17194: DOUBLE
17195: EQUAL
17196: IFTRUE 17206
17198: LD_INT 31
17200: DOUBLE
17201: EQUAL
17202: IFTRUE 17206
17204: GO 17217
17206: POP
// places := 1 ; b_control_tower :
17207: LD_ADDR_VAR 0 3
17211: PUSH
17212: LD_INT 1
17214: ST_TO_ADDR
17215: GO 17237
17217: LD_INT 36
17219: DOUBLE
17220: EQUAL
17221: IFTRUE 17225
17223: GO 17236
17225: POP
// places := 3 ; end ;
17226: LD_ADDR_VAR 0 3
17230: PUSH
17231: LD_INT 3
17233: ST_TO_ADDR
17234: GO 17237
17236: POP
// if places then
17237: LD_VAR 0 3
17241: IFFALSE 17264
// result := UnitsInside ( building ) < places ;
17243: LD_ADDR_VAR 0 2
17247: PUSH
17248: LD_VAR 0 1
17252: PPUSH
17253: CALL_OW 313
17257: PUSH
17258: LD_VAR 0 3
17262: LESS
17263: ST_TO_ADDR
// end ;
17264: LD_VAR 0 2
17268: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17269: LD_INT 0
17271: PPUSH
17272: PPUSH
17273: PPUSH
17274: PPUSH
// tmp := [ ] ;
17275: LD_ADDR_VAR 0 3
17279: PUSH
17280: EMPTY
17281: ST_TO_ADDR
// list := [ ] ;
17282: LD_ADDR_VAR 0 5
17286: PUSH
17287: EMPTY
17288: ST_TO_ADDR
// for i = 16 to 25 do
17289: LD_ADDR_VAR 0 4
17293: PUSH
17294: DOUBLE
17295: LD_INT 16
17297: DEC
17298: ST_TO_ADDR
17299: LD_INT 25
17301: PUSH
17302: FOR_TO
17303: IFFALSE 17376
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17305: LD_ADDR_VAR 0 3
17309: PUSH
17310: LD_VAR 0 3
17314: PUSH
17315: LD_INT 22
17317: PUSH
17318: LD_VAR 0 1
17322: PPUSH
17323: CALL_OW 255
17327: PUSH
17328: EMPTY
17329: LIST
17330: LIST
17331: PUSH
17332: LD_INT 91
17334: PUSH
17335: LD_VAR 0 1
17339: PUSH
17340: LD_INT 6
17342: PUSH
17343: EMPTY
17344: LIST
17345: LIST
17346: LIST
17347: PUSH
17348: LD_INT 30
17350: PUSH
17351: LD_VAR 0 4
17355: PUSH
17356: EMPTY
17357: LIST
17358: LIST
17359: PUSH
17360: EMPTY
17361: LIST
17362: LIST
17363: LIST
17364: PUSH
17365: EMPTY
17366: LIST
17367: PPUSH
17368: CALL_OW 69
17372: ADD
17373: ST_TO_ADDR
17374: GO 17302
17376: POP
17377: POP
// for i = 1 to tmp do
17378: LD_ADDR_VAR 0 4
17382: PUSH
17383: DOUBLE
17384: LD_INT 1
17386: DEC
17387: ST_TO_ADDR
17388: LD_VAR 0 3
17392: PUSH
17393: FOR_TO
17394: IFFALSE 17482
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17396: LD_ADDR_VAR 0 5
17400: PUSH
17401: LD_VAR 0 5
17405: PUSH
17406: LD_VAR 0 3
17410: PUSH
17411: LD_VAR 0 4
17415: ARRAY
17416: PPUSH
17417: CALL_OW 266
17421: PUSH
17422: LD_VAR 0 3
17426: PUSH
17427: LD_VAR 0 4
17431: ARRAY
17432: PPUSH
17433: CALL_OW 250
17437: PUSH
17438: LD_VAR 0 3
17442: PUSH
17443: LD_VAR 0 4
17447: ARRAY
17448: PPUSH
17449: CALL_OW 251
17453: PUSH
17454: LD_VAR 0 3
17458: PUSH
17459: LD_VAR 0 4
17463: ARRAY
17464: PPUSH
17465: CALL_OW 254
17469: PUSH
17470: EMPTY
17471: LIST
17472: LIST
17473: LIST
17474: LIST
17475: PUSH
17476: EMPTY
17477: LIST
17478: ADD
17479: ST_TO_ADDR
17480: GO 17393
17482: POP
17483: POP
// result := list ;
17484: LD_ADDR_VAR 0 2
17488: PUSH
17489: LD_VAR 0 5
17493: ST_TO_ADDR
// end ;
17494: LD_VAR 0 2
17498: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17499: LD_INT 0
17501: PPUSH
17502: PPUSH
17503: PPUSH
17504: PPUSH
17505: PPUSH
17506: PPUSH
17507: PPUSH
// if not factory then
17508: LD_VAR 0 1
17512: NOT
17513: IFFALSE 17517
// exit ;
17515: GO 18110
// if control = control_apeman then
17517: LD_VAR 0 4
17521: PUSH
17522: LD_INT 5
17524: EQUAL
17525: IFFALSE 17634
// begin tmp := UnitsInside ( factory ) ;
17527: LD_ADDR_VAR 0 8
17531: PUSH
17532: LD_VAR 0 1
17536: PPUSH
17537: CALL_OW 313
17541: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17542: LD_VAR 0 8
17546: PPUSH
17547: LD_INT 25
17549: PUSH
17550: LD_INT 12
17552: PUSH
17553: EMPTY
17554: LIST
17555: LIST
17556: PPUSH
17557: CALL_OW 72
17561: NOT
17562: IFFALSE 17572
// control := control_manual ;
17564: LD_ADDR_VAR 0 4
17568: PUSH
17569: LD_INT 1
17571: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17572: LD_ADDR_VAR 0 8
17576: PUSH
17577: LD_VAR 0 1
17581: PPUSH
17582: CALL 17269 0 1
17586: ST_TO_ADDR
// if tmp then
17587: LD_VAR 0 8
17591: IFFALSE 17634
// begin for i in tmp do
17593: LD_ADDR_VAR 0 7
17597: PUSH
17598: LD_VAR 0 8
17602: PUSH
17603: FOR_IN
17604: IFFALSE 17632
// if i [ 1 ] = b_ext_radio then
17606: LD_VAR 0 7
17610: PUSH
17611: LD_INT 1
17613: ARRAY
17614: PUSH
17615: LD_INT 22
17617: EQUAL
17618: IFFALSE 17630
// begin control := control_remote ;
17620: LD_ADDR_VAR 0 4
17624: PUSH
17625: LD_INT 2
17627: ST_TO_ADDR
// break ;
17628: GO 17632
// end ;
17630: GO 17603
17632: POP
17633: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17634: LD_VAR 0 1
17638: PPUSH
17639: LD_VAR 0 2
17643: PPUSH
17644: LD_VAR 0 3
17648: PPUSH
17649: LD_VAR 0 4
17653: PPUSH
17654: LD_VAR 0 5
17658: PPUSH
17659: CALL_OW 448
17663: IFFALSE 17698
// begin result := [ chassis , engine , control , weapon ] ;
17665: LD_ADDR_VAR 0 6
17669: PUSH
17670: LD_VAR 0 2
17674: PUSH
17675: LD_VAR 0 3
17679: PUSH
17680: LD_VAR 0 4
17684: PUSH
17685: LD_VAR 0 5
17689: PUSH
17690: EMPTY
17691: LIST
17692: LIST
17693: LIST
17694: LIST
17695: ST_TO_ADDR
// exit ;
17696: GO 18110
// end ; _chassis := AvailableChassisList ( factory ) ;
17698: LD_ADDR_VAR 0 9
17702: PUSH
17703: LD_VAR 0 1
17707: PPUSH
17708: CALL_OW 475
17712: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17713: LD_ADDR_VAR 0 11
17717: PUSH
17718: LD_VAR 0 1
17722: PPUSH
17723: CALL_OW 476
17727: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17728: LD_ADDR_VAR 0 12
17732: PUSH
17733: LD_VAR 0 1
17737: PPUSH
17738: CALL_OW 477
17742: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17743: LD_ADDR_VAR 0 10
17747: PUSH
17748: LD_VAR 0 1
17752: PPUSH
17753: CALL_OW 478
17757: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17758: LD_VAR 0 9
17762: NOT
17763: PUSH
17764: LD_VAR 0 11
17768: NOT
17769: OR
17770: PUSH
17771: LD_VAR 0 12
17775: NOT
17776: OR
17777: PUSH
17778: LD_VAR 0 10
17782: NOT
17783: OR
17784: IFFALSE 17819
// begin result := [ chassis , engine , control , weapon ] ;
17786: LD_ADDR_VAR 0 6
17790: PUSH
17791: LD_VAR 0 2
17795: PUSH
17796: LD_VAR 0 3
17800: PUSH
17801: LD_VAR 0 4
17805: PUSH
17806: LD_VAR 0 5
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: ST_TO_ADDR
// exit ;
17817: GO 18110
// end ; if not chassis in _chassis then
17819: LD_VAR 0 2
17823: PUSH
17824: LD_VAR 0 9
17828: IN
17829: NOT
17830: IFFALSE 17856
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17832: LD_ADDR_VAR 0 2
17836: PUSH
17837: LD_VAR 0 9
17841: PUSH
17842: LD_INT 1
17844: PPUSH
17845: LD_VAR 0 9
17849: PPUSH
17850: CALL_OW 12
17854: ARRAY
17855: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17856: LD_VAR 0 2
17860: PPUSH
17861: LD_VAR 0 3
17865: PPUSH
17866: CALL 18115 0 2
17870: NOT
17871: IFFALSE 17930
// repeat engine := _engine [ 1 ] ;
17873: LD_ADDR_VAR 0 3
17877: PUSH
17878: LD_VAR 0 11
17882: PUSH
17883: LD_INT 1
17885: ARRAY
17886: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17887: LD_ADDR_VAR 0 11
17891: PUSH
17892: LD_VAR 0 11
17896: PPUSH
17897: LD_INT 1
17899: PPUSH
17900: CALL_OW 3
17904: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17905: LD_VAR 0 2
17909: PPUSH
17910: LD_VAR 0 3
17914: PPUSH
17915: CALL 18115 0 2
17919: PUSH
17920: LD_VAR 0 11
17924: PUSH
17925: EMPTY
17926: EQUAL
17927: OR
17928: IFFALSE 17873
// if not control in _control then
17930: LD_VAR 0 4
17934: PUSH
17935: LD_VAR 0 12
17939: IN
17940: NOT
17941: IFFALSE 17967
// control := _control [ rand ( 1 , _control ) ] ;
17943: LD_ADDR_VAR 0 4
17947: PUSH
17948: LD_VAR 0 12
17952: PUSH
17953: LD_INT 1
17955: PPUSH
17956: LD_VAR 0 12
17960: PPUSH
17961: CALL_OW 12
17965: ARRAY
17966: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17967: LD_VAR 0 2
17971: PPUSH
17972: LD_VAR 0 5
17976: PPUSH
17977: CALL 18335 0 2
17981: NOT
17982: IFFALSE 18041
// repeat weapon := _weapon [ 1 ] ;
17984: LD_ADDR_VAR 0 5
17988: PUSH
17989: LD_VAR 0 10
17993: PUSH
17994: LD_INT 1
17996: ARRAY
17997: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17998: LD_ADDR_VAR 0 10
18002: PUSH
18003: LD_VAR 0 10
18007: PPUSH
18008: LD_INT 1
18010: PPUSH
18011: CALL_OW 3
18015: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18016: LD_VAR 0 2
18020: PPUSH
18021: LD_VAR 0 5
18025: PPUSH
18026: CALL 18335 0 2
18030: PUSH
18031: LD_VAR 0 10
18035: PUSH
18036: EMPTY
18037: EQUAL
18038: OR
18039: IFFALSE 17984
// result := [ ] ;
18041: LD_ADDR_VAR 0 6
18045: PUSH
18046: EMPTY
18047: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18048: LD_VAR 0 1
18052: PPUSH
18053: LD_VAR 0 2
18057: PPUSH
18058: LD_VAR 0 3
18062: PPUSH
18063: LD_VAR 0 4
18067: PPUSH
18068: LD_VAR 0 5
18072: PPUSH
18073: CALL_OW 448
18077: IFFALSE 18110
// result := [ chassis , engine , control , weapon ] ;
18079: LD_ADDR_VAR 0 6
18083: PUSH
18084: LD_VAR 0 2
18088: PUSH
18089: LD_VAR 0 3
18093: PUSH
18094: LD_VAR 0 4
18098: PUSH
18099: LD_VAR 0 5
18103: PUSH
18104: EMPTY
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: ST_TO_ADDR
// end ;
18110: LD_VAR 0 6
18114: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18115: LD_INT 0
18117: PPUSH
// if not chassis or not engine then
18118: LD_VAR 0 1
18122: NOT
18123: PUSH
18124: LD_VAR 0 2
18128: NOT
18129: OR
18130: IFFALSE 18134
// exit ;
18132: GO 18330
// case engine of engine_solar :
18134: LD_VAR 0 2
18138: PUSH
18139: LD_INT 2
18141: DOUBLE
18142: EQUAL
18143: IFTRUE 18147
18145: GO 18185
18147: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18148: LD_ADDR_VAR 0 3
18152: PUSH
18153: LD_INT 11
18155: PUSH
18156: LD_INT 12
18158: PUSH
18159: LD_INT 13
18161: PUSH
18162: LD_INT 14
18164: PUSH
18165: LD_INT 1
18167: PUSH
18168: LD_INT 2
18170: PUSH
18171: LD_INT 3
18173: PUSH
18174: EMPTY
18175: LIST
18176: LIST
18177: LIST
18178: LIST
18179: LIST
18180: LIST
18181: LIST
18182: ST_TO_ADDR
18183: GO 18314
18185: LD_INT 1
18187: DOUBLE
18188: EQUAL
18189: IFTRUE 18193
18191: GO 18255
18193: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18194: LD_ADDR_VAR 0 3
18198: PUSH
18199: LD_INT 11
18201: PUSH
18202: LD_INT 12
18204: PUSH
18205: LD_INT 13
18207: PUSH
18208: LD_INT 14
18210: PUSH
18211: LD_INT 1
18213: PUSH
18214: LD_INT 2
18216: PUSH
18217: LD_INT 3
18219: PUSH
18220: LD_INT 4
18222: PUSH
18223: LD_INT 5
18225: PUSH
18226: LD_INT 21
18228: PUSH
18229: LD_INT 23
18231: PUSH
18232: LD_INT 22
18234: PUSH
18235: LD_INT 24
18237: PUSH
18238: EMPTY
18239: LIST
18240: LIST
18241: LIST
18242: LIST
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: ST_TO_ADDR
18253: GO 18314
18255: LD_INT 3
18257: DOUBLE
18258: EQUAL
18259: IFTRUE 18263
18261: GO 18313
18263: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18264: LD_ADDR_VAR 0 3
18268: PUSH
18269: LD_INT 13
18271: PUSH
18272: LD_INT 14
18274: PUSH
18275: LD_INT 2
18277: PUSH
18278: LD_INT 3
18280: PUSH
18281: LD_INT 4
18283: PUSH
18284: LD_INT 5
18286: PUSH
18287: LD_INT 21
18289: PUSH
18290: LD_INT 22
18292: PUSH
18293: LD_INT 23
18295: PUSH
18296: LD_INT 24
18298: PUSH
18299: EMPTY
18300: LIST
18301: LIST
18302: LIST
18303: LIST
18304: LIST
18305: LIST
18306: LIST
18307: LIST
18308: LIST
18309: LIST
18310: ST_TO_ADDR
18311: GO 18314
18313: POP
// result := ( chassis in result ) ;
18314: LD_ADDR_VAR 0 3
18318: PUSH
18319: LD_VAR 0 1
18323: PUSH
18324: LD_VAR 0 3
18328: IN
18329: ST_TO_ADDR
// end ;
18330: LD_VAR 0 3
18334: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18335: LD_INT 0
18337: PPUSH
// if not chassis or not weapon then
18338: LD_VAR 0 1
18342: NOT
18343: PUSH
18344: LD_VAR 0 2
18348: NOT
18349: OR
18350: IFFALSE 18354
// exit ;
18352: GO 19416
// case weapon of us_machine_gun :
18354: LD_VAR 0 2
18358: PUSH
18359: LD_INT 2
18361: DOUBLE
18362: EQUAL
18363: IFTRUE 18367
18365: GO 18397
18367: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18368: LD_ADDR_VAR 0 3
18372: PUSH
18373: LD_INT 1
18375: PUSH
18376: LD_INT 2
18378: PUSH
18379: LD_INT 3
18381: PUSH
18382: LD_INT 4
18384: PUSH
18385: LD_INT 5
18387: PUSH
18388: EMPTY
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: ST_TO_ADDR
18395: GO 19400
18397: LD_INT 3
18399: DOUBLE
18400: EQUAL
18401: IFTRUE 18405
18403: GO 18435
18405: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18406: LD_ADDR_VAR 0 3
18410: PUSH
18411: LD_INT 1
18413: PUSH
18414: LD_INT 2
18416: PUSH
18417: LD_INT 3
18419: PUSH
18420: LD_INT 4
18422: PUSH
18423: LD_INT 5
18425: PUSH
18426: EMPTY
18427: LIST
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: ST_TO_ADDR
18433: GO 19400
18435: LD_INT 11
18437: DOUBLE
18438: EQUAL
18439: IFTRUE 18443
18441: GO 18473
18443: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18444: LD_ADDR_VAR 0 3
18448: PUSH
18449: LD_INT 1
18451: PUSH
18452: LD_INT 2
18454: PUSH
18455: LD_INT 3
18457: PUSH
18458: LD_INT 4
18460: PUSH
18461: LD_INT 5
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: LIST
18468: LIST
18469: LIST
18470: ST_TO_ADDR
18471: GO 19400
18473: LD_INT 4
18475: DOUBLE
18476: EQUAL
18477: IFTRUE 18481
18479: GO 18507
18481: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18482: LD_ADDR_VAR 0 3
18486: PUSH
18487: LD_INT 2
18489: PUSH
18490: LD_INT 3
18492: PUSH
18493: LD_INT 4
18495: PUSH
18496: LD_INT 5
18498: PUSH
18499: EMPTY
18500: LIST
18501: LIST
18502: LIST
18503: LIST
18504: ST_TO_ADDR
18505: GO 19400
18507: LD_INT 5
18509: DOUBLE
18510: EQUAL
18511: IFTRUE 18515
18513: GO 18541
18515: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18516: LD_ADDR_VAR 0 3
18520: PUSH
18521: LD_INT 2
18523: PUSH
18524: LD_INT 3
18526: PUSH
18527: LD_INT 4
18529: PUSH
18530: LD_INT 5
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: LIST
18537: LIST
18538: ST_TO_ADDR
18539: GO 19400
18541: LD_INT 9
18543: DOUBLE
18544: EQUAL
18545: IFTRUE 18549
18547: GO 18575
18549: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18550: LD_ADDR_VAR 0 3
18554: PUSH
18555: LD_INT 2
18557: PUSH
18558: LD_INT 3
18560: PUSH
18561: LD_INT 4
18563: PUSH
18564: LD_INT 5
18566: PUSH
18567: EMPTY
18568: LIST
18569: LIST
18570: LIST
18571: LIST
18572: ST_TO_ADDR
18573: GO 19400
18575: LD_INT 7
18577: DOUBLE
18578: EQUAL
18579: IFTRUE 18583
18581: GO 18609
18583: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18584: LD_ADDR_VAR 0 3
18588: PUSH
18589: LD_INT 2
18591: PUSH
18592: LD_INT 3
18594: PUSH
18595: LD_INT 4
18597: PUSH
18598: LD_INT 5
18600: PUSH
18601: EMPTY
18602: LIST
18603: LIST
18604: LIST
18605: LIST
18606: ST_TO_ADDR
18607: GO 19400
18609: LD_INT 12
18611: DOUBLE
18612: EQUAL
18613: IFTRUE 18617
18615: GO 18643
18617: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18618: LD_ADDR_VAR 0 3
18622: PUSH
18623: LD_INT 2
18625: PUSH
18626: LD_INT 3
18628: PUSH
18629: LD_INT 4
18631: PUSH
18632: LD_INT 5
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: ST_TO_ADDR
18641: GO 19400
18643: LD_INT 13
18645: DOUBLE
18646: EQUAL
18647: IFTRUE 18651
18649: GO 18677
18651: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18652: LD_ADDR_VAR 0 3
18656: PUSH
18657: LD_INT 2
18659: PUSH
18660: LD_INT 3
18662: PUSH
18663: LD_INT 4
18665: PUSH
18666: LD_INT 5
18668: PUSH
18669: EMPTY
18670: LIST
18671: LIST
18672: LIST
18673: LIST
18674: ST_TO_ADDR
18675: GO 19400
18677: LD_INT 14
18679: DOUBLE
18680: EQUAL
18681: IFTRUE 18685
18683: GO 18703
18685: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18686: LD_ADDR_VAR 0 3
18690: PUSH
18691: LD_INT 4
18693: PUSH
18694: LD_INT 5
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: ST_TO_ADDR
18701: GO 19400
18703: LD_INT 6
18705: DOUBLE
18706: EQUAL
18707: IFTRUE 18711
18709: GO 18729
18711: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18712: LD_ADDR_VAR 0 3
18716: PUSH
18717: LD_INT 4
18719: PUSH
18720: LD_INT 5
18722: PUSH
18723: EMPTY
18724: LIST
18725: LIST
18726: ST_TO_ADDR
18727: GO 19400
18729: LD_INT 10
18731: DOUBLE
18732: EQUAL
18733: IFTRUE 18737
18735: GO 18755
18737: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18738: LD_ADDR_VAR 0 3
18742: PUSH
18743: LD_INT 4
18745: PUSH
18746: LD_INT 5
18748: PUSH
18749: EMPTY
18750: LIST
18751: LIST
18752: ST_TO_ADDR
18753: GO 19400
18755: LD_INT 22
18757: DOUBLE
18758: EQUAL
18759: IFTRUE 18763
18761: GO 18789
18763: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18764: LD_ADDR_VAR 0 3
18768: PUSH
18769: LD_INT 11
18771: PUSH
18772: LD_INT 12
18774: PUSH
18775: LD_INT 13
18777: PUSH
18778: LD_INT 14
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: LIST
18785: LIST
18786: ST_TO_ADDR
18787: GO 19400
18789: LD_INT 23
18791: DOUBLE
18792: EQUAL
18793: IFTRUE 18797
18795: GO 18823
18797: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18798: LD_ADDR_VAR 0 3
18802: PUSH
18803: LD_INT 11
18805: PUSH
18806: LD_INT 12
18808: PUSH
18809: LD_INT 13
18811: PUSH
18812: LD_INT 14
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: LIST
18819: LIST
18820: ST_TO_ADDR
18821: GO 19400
18823: LD_INT 24
18825: DOUBLE
18826: EQUAL
18827: IFTRUE 18831
18829: GO 18857
18831: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18832: LD_ADDR_VAR 0 3
18836: PUSH
18837: LD_INT 11
18839: PUSH
18840: LD_INT 12
18842: PUSH
18843: LD_INT 13
18845: PUSH
18846: LD_INT 14
18848: PUSH
18849: EMPTY
18850: LIST
18851: LIST
18852: LIST
18853: LIST
18854: ST_TO_ADDR
18855: GO 19400
18857: LD_INT 30
18859: DOUBLE
18860: EQUAL
18861: IFTRUE 18865
18863: GO 18891
18865: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18866: LD_ADDR_VAR 0 3
18870: PUSH
18871: LD_INT 11
18873: PUSH
18874: LD_INT 12
18876: PUSH
18877: LD_INT 13
18879: PUSH
18880: LD_INT 14
18882: PUSH
18883: EMPTY
18884: LIST
18885: LIST
18886: LIST
18887: LIST
18888: ST_TO_ADDR
18889: GO 19400
18891: LD_INT 25
18893: DOUBLE
18894: EQUAL
18895: IFTRUE 18899
18897: GO 18917
18899: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18900: LD_ADDR_VAR 0 3
18904: PUSH
18905: LD_INT 13
18907: PUSH
18908: LD_INT 14
18910: PUSH
18911: EMPTY
18912: LIST
18913: LIST
18914: ST_TO_ADDR
18915: GO 19400
18917: LD_INT 27
18919: DOUBLE
18920: EQUAL
18921: IFTRUE 18925
18923: GO 18943
18925: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
18926: LD_ADDR_VAR 0 3
18930: PUSH
18931: LD_INT 13
18933: PUSH
18934: LD_INT 14
18936: PUSH
18937: EMPTY
18938: LIST
18939: LIST
18940: ST_TO_ADDR
18941: GO 19400
18943: LD_EXP 109
18947: DOUBLE
18948: EQUAL
18949: IFTRUE 18953
18951: GO 18979
18953: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18954: LD_ADDR_VAR 0 3
18958: PUSH
18959: LD_INT 11
18961: PUSH
18962: LD_INT 12
18964: PUSH
18965: LD_INT 13
18967: PUSH
18968: LD_INT 14
18970: PUSH
18971: EMPTY
18972: LIST
18973: LIST
18974: LIST
18975: LIST
18976: ST_TO_ADDR
18977: GO 19400
18979: LD_INT 28
18981: DOUBLE
18982: EQUAL
18983: IFTRUE 18987
18985: GO 19005
18987: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18988: LD_ADDR_VAR 0 3
18992: PUSH
18993: LD_INT 13
18995: PUSH
18996: LD_INT 14
18998: PUSH
18999: EMPTY
19000: LIST
19001: LIST
19002: ST_TO_ADDR
19003: GO 19400
19005: LD_INT 29
19007: DOUBLE
19008: EQUAL
19009: IFTRUE 19013
19011: GO 19031
19013: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19014: LD_ADDR_VAR 0 3
19018: PUSH
19019: LD_INT 13
19021: PUSH
19022: LD_INT 14
19024: PUSH
19025: EMPTY
19026: LIST
19027: LIST
19028: ST_TO_ADDR
19029: GO 19400
19031: LD_INT 31
19033: DOUBLE
19034: EQUAL
19035: IFTRUE 19039
19037: GO 19057
19039: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19040: LD_ADDR_VAR 0 3
19044: PUSH
19045: LD_INT 13
19047: PUSH
19048: LD_INT 14
19050: PUSH
19051: EMPTY
19052: LIST
19053: LIST
19054: ST_TO_ADDR
19055: GO 19400
19057: LD_INT 26
19059: DOUBLE
19060: EQUAL
19061: IFTRUE 19065
19063: GO 19083
19065: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19066: LD_ADDR_VAR 0 3
19070: PUSH
19071: LD_INT 13
19073: PUSH
19074: LD_INT 14
19076: PUSH
19077: EMPTY
19078: LIST
19079: LIST
19080: ST_TO_ADDR
19081: GO 19400
19083: LD_INT 42
19085: DOUBLE
19086: EQUAL
19087: IFTRUE 19091
19089: GO 19117
19091: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19092: LD_ADDR_VAR 0 3
19096: PUSH
19097: LD_INT 21
19099: PUSH
19100: LD_INT 22
19102: PUSH
19103: LD_INT 23
19105: PUSH
19106: LD_INT 24
19108: PUSH
19109: EMPTY
19110: LIST
19111: LIST
19112: LIST
19113: LIST
19114: ST_TO_ADDR
19115: GO 19400
19117: LD_INT 43
19119: DOUBLE
19120: EQUAL
19121: IFTRUE 19125
19123: GO 19151
19125: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19126: LD_ADDR_VAR 0 3
19130: PUSH
19131: LD_INT 21
19133: PUSH
19134: LD_INT 22
19136: PUSH
19137: LD_INT 23
19139: PUSH
19140: LD_INT 24
19142: PUSH
19143: EMPTY
19144: LIST
19145: LIST
19146: LIST
19147: LIST
19148: ST_TO_ADDR
19149: GO 19400
19151: LD_INT 44
19153: DOUBLE
19154: EQUAL
19155: IFTRUE 19159
19157: GO 19185
19159: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19160: LD_ADDR_VAR 0 3
19164: PUSH
19165: LD_INT 21
19167: PUSH
19168: LD_INT 22
19170: PUSH
19171: LD_INT 23
19173: PUSH
19174: LD_INT 24
19176: PUSH
19177: EMPTY
19178: LIST
19179: LIST
19180: LIST
19181: LIST
19182: ST_TO_ADDR
19183: GO 19400
19185: LD_INT 45
19187: DOUBLE
19188: EQUAL
19189: IFTRUE 19193
19191: GO 19219
19193: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19194: LD_ADDR_VAR 0 3
19198: PUSH
19199: LD_INT 21
19201: PUSH
19202: LD_INT 22
19204: PUSH
19205: LD_INT 23
19207: PUSH
19208: LD_INT 24
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: LIST
19215: LIST
19216: ST_TO_ADDR
19217: GO 19400
19219: LD_INT 49
19221: DOUBLE
19222: EQUAL
19223: IFTRUE 19227
19225: GO 19253
19227: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19228: LD_ADDR_VAR 0 3
19232: PUSH
19233: LD_INT 21
19235: PUSH
19236: LD_INT 22
19238: PUSH
19239: LD_INT 23
19241: PUSH
19242: LD_INT 24
19244: PUSH
19245: EMPTY
19246: LIST
19247: LIST
19248: LIST
19249: LIST
19250: ST_TO_ADDR
19251: GO 19400
19253: LD_INT 51
19255: DOUBLE
19256: EQUAL
19257: IFTRUE 19261
19259: GO 19287
19261: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19262: LD_ADDR_VAR 0 3
19266: PUSH
19267: LD_INT 21
19269: PUSH
19270: LD_INT 22
19272: PUSH
19273: LD_INT 23
19275: PUSH
19276: LD_INT 24
19278: PUSH
19279: EMPTY
19280: LIST
19281: LIST
19282: LIST
19283: LIST
19284: ST_TO_ADDR
19285: GO 19400
19287: LD_INT 52
19289: DOUBLE
19290: EQUAL
19291: IFTRUE 19295
19293: GO 19321
19295: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19296: LD_ADDR_VAR 0 3
19300: PUSH
19301: LD_INT 21
19303: PUSH
19304: LD_INT 22
19306: PUSH
19307: LD_INT 23
19309: PUSH
19310: LD_INT 24
19312: PUSH
19313: EMPTY
19314: LIST
19315: LIST
19316: LIST
19317: LIST
19318: ST_TO_ADDR
19319: GO 19400
19321: LD_INT 53
19323: DOUBLE
19324: EQUAL
19325: IFTRUE 19329
19327: GO 19347
19329: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19330: LD_ADDR_VAR 0 3
19334: PUSH
19335: LD_INT 23
19337: PUSH
19338: LD_INT 24
19340: PUSH
19341: EMPTY
19342: LIST
19343: LIST
19344: ST_TO_ADDR
19345: GO 19400
19347: LD_INT 46
19349: DOUBLE
19350: EQUAL
19351: IFTRUE 19355
19353: GO 19373
19355: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19356: LD_ADDR_VAR 0 3
19360: PUSH
19361: LD_INT 23
19363: PUSH
19364: LD_INT 24
19366: PUSH
19367: EMPTY
19368: LIST
19369: LIST
19370: ST_TO_ADDR
19371: GO 19400
19373: LD_INT 47
19375: DOUBLE
19376: EQUAL
19377: IFTRUE 19381
19379: GO 19399
19381: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19382: LD_ADDR_VAR 0 3
19386: PUSH
19387: LD_INT 23
19389: PUSH
19390: LD_INT 24
19392: PUSH
19393: EMPTY
19394: LIST
19395: LIST
19396: ST_TO_ADDR
19397: GO 19400
19399: POP
// result := ( chassis in result ) ;
19400: LD_ADDR_VAR 0 3
19404: PUSH
19405: LD_VAR 0 1
19409: PUSH
19410: LD_VAR 0 3
19414: IN
19415: ST_TO_ADDR
// end ;
19416: LD_VAR 0 3
19420: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19421: LD_INT 0
19423: PPUSH
19424: PPUSH
19425: PPUSH
19426: PPUSH
19427: PPUSH
19428: PPUSH
19429: PPUSH
// result := array ;
19430: LD_ADDR_VAR 0 5
19434: PUSH
19435: LD_VAR 0 1
19439: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19440: LD_VAR 0 1
19444: NOT
19445: PUSH
19446: LD_VAR 0 2
19450: NOT
19451: OR
19452: PUSH
19453: LD_VAR 0 3
19457: NOT
19458: OR
19459: PUSH
19460: LD_VAR 0 2
19464: PUSH
19465: LD_VAR 0 1
19469: GREATER
19470: OR
19471: PUSH
19472: LD_VAR 0 3
19476: PUSH
19477: LD_VAR 0 1
19481: GREATER
19482: OR
19483: IFFALSE 19487
// exit ;
19485: GO 19783
// if direction then
19487: LD_VAR 0 4
19491: IFFALSE 19555
// begin d := 1 ;
19493: LD_ADDR_VAR 0 9
19497: PUSH
19498: LD_INT 1
19500: ST_TO_ADDR
// if i_from > i_to then
19501: LD_VAR 0 2
19505: PUSH
19506: LD_VAR 0 3
19510: GREATER
19511: IFFALSE 19537
// length := ( array - i_from ) + i_to else
19513: LD_ADDR_VAR 0 11
19517: PUSH
19518: LD_VAR 0 1
19522: PUSH
19523: LD_VAR 0 2
19527: MINUS
19528: PUSH
19529: LD_VAR 0 3
19533: PLUS
19534: ST_TO_ADDR
19535: GO 19553
// length := i_to - i_from ;
19537: LD_ADDR_VAR 0 11
19541: PUSH
19542: LD_VAR 0 3
19546: PUSH
19547: LD_VAR 0 2
19551: MINUS
19552: ST_TO_ADDR
// end else
19553: GO 19616
// begin d := - 1 ;
19555: LD_ADDR_VAR 0 9
19559: PUSH
19560: LD_INT 1
19562: NEG
19563: ST_TO_ADDR
// if i_from > i_to then
19564: LD_VAR 0 2
19568: PUSH
19569: LD_VAR 0 3
19573: GREATER
19574: IFFALSE 19594
// length := i_from - i_to else
19576: LD_ADDR_VAR 0 11
19580: PUSH
19581: LD_VAR 0 2
19585: PUSH
19586: LD_VAR 0 3
19590: MINUS
19591: ST_TO_ADDR
19592: GO 19616
// length := ( array - i_to ) + i_from ;
19594: LD_ADDR_VAR 0 11
19598: PUSH
19599: LD_VAR 0 1
19603: PUSH
19604: LD_VAR 0 3
19608: MINUS
19609: PUSH
19610: LD_VAR 0 2
19614: PLUS
19615: ST_TO_ADDR
// end ; if not length then
19616: LD_VAR 0 11
19620: NOT
19621: IFFALSE 19625
// exit ;
19623: GO 19783
// tmp := array ;
19625: LD_ADDR_VAR 0 10
19629: PUSH
19630: LD_VAR 0 1
19634: ST_TO_ADDR
// for i = 1 to length do
19635: LD_ADDR_VAR 0 6
19639: PUSH
19640: DOUBLE
19641: LD_INT 1
19643: DEC
19644: ST_TO_ADDR
19645: LD_VAR 0 11
19649: PUSH
19650: FOR_TO
19651: IFFALSE 19771
// begin for j = 1 to array do
19653: LD_ADDR_VAR 0 7
19657: PUSH
19658: DOUBLE
19659: LD_INT 1
19661: DEC
19662: ST_TO_ADDR
19663: LD_VAR 0 1
19667: PUSH
19668: FOR_TO
19669: IFFALSE 19757
// begin k := j + d ;
19671: LD_ADDR_VAR 0 8
19675: PUSH
19676: LD_VAR 0 7
19680: PUSH
19681: LD_VAR 0 9
19685: PLUS
19686: ST_TO_ADDR
// if k > array then
19687: LD_VAR 0 8
19691: PUSH
19692: LD_VAR 0 1
19696: GREATER
19697: IFFALSE 19707
// k := 1 ;
19699: LD_ADDR_VAR 0 8
19703: PUSH
19704: LD_INT 1
19706: ST_TO_ADDR
// if not k then
19707: LD_VAR 0 8
19711: NOT
19712: IFFALSE 19724
// k := array ;
19714: LD_ADDR_VAR 0 8
19718: PUSH
19719: LD_VAR 0 1
19723: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19724: LD_ADDR_VAR 0 10
19728: PUSH
19729: LD_VAR 0 10
19733: PPUSH
19734: LD_VAR 0 8
19738: PPUSH
19739: LD_VAR 0 1
19743: PUSH
19744: LD_VAR 0 7
19748: ARRAY
19749: PPUSH
19750: CALL_OW 1
19754: ST_TO_ADDR
// end ;
19755: GO 19668
19757: POP
19758: POP
// array := tmp ;
19759: LD_ADDR_VAR 0 1
19763: PUSH
19764: LD_VAR 0 10
19768: ST_TO_ADDR
// end ;
19769: GO 19650
19771: POP
19772: POP
// result := array ;
19773: LD_ADDR_VAR 0 5
19777: PUSH
19778: LD_VAR 0 1
19782: ST_TO_ADDR
// end ;
19783: LD_VAR 0 5
19787: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19788: LD_INT 0
19790: PPUSH
19791: PPUSH
// result := 0 ;
19792: LD_ADDR_VAR 0 3
19796: PUSH
19797: LD_INT 0
19799: ST_TO_ADDR
// if not array or not value in array then
19800: LD_VAR 0 1
19804: NOT
19805: PUSH
19806: LD_VAR 0 2
19810: PUSH
19811: LD_VAR 0 1
19815: IN
19816: NOT
19817: OR
19818: IFFALSE 19822
// exit ;
19820: GO 19876
// for i = 1 to array do
19822: LD_ADDR_VAR 0 4
19826: PUSH
19827: DOUBLE
19828: LD_INT 1
19830: DEC
19831: ST_TO_ADDR
19832: LD_VAR 0 1
19836: PUSH
19837: FOR_TO
19838: IFFALSE 19874
// if value = array [ i ] then
19840: LD_VAR 0 2
19844: PUSH
19845: LD_VAR 0 1
19849: PUSH
19850: LD_VAR 0 4
19854: ARRAY
19855: EQUAL
19856: IFFALSE 19872
// begin result := i ;
19858: LD_ADDR_VAR 0 3
19862: PUSH
19863: LD_VAR 0 4
19867: ST_TO_ADDR
// exit ;
19868: POP
19869: POP
19870: GO 19876
// end ;
19872: GO 19837
19874: POP
19875: POP
// end ;
19876: LD_VAR 0 3
19880: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19881: LD_INT 0
19883: PPUSH
// vc_chassis := chassis ;
19884: LD_ADDR_OWVAR 37
19888: PUSH
19889: LD_VAR 0 1
19893: ST_TO_ADDR
// vc_engine := engine ;
19894: LD_ADDR_OWVAR 39
19898: PUSH
19899: LD_VAR 0 2
19903: ST_TO_ADDR
// vc_control := control ;
19904: LD_ADDR_OWVAR 38
19908: PUSH
19909: LD_VAR 0 3
19913: ST_TO_ADDR
// vc_weapon := weapon ;
19914: LD_ADDR_OWVAR 40
19918: PUSH
19919: LD_VAR 0 4
19923: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19924: LD_ADDR_OWVAR 41
19928: PUSH
19929: LD_VAR 0 5
19933: ST_TO_ADDR
// end ;
19934: LD_VAR 0 6
19938: RET
// export function WantPlant ( unit ) ; var task ; begin
19939: LD_INT 0
19941: PPUSH
19942: PPUSH
// result := false ;
19943: LD_ADDR_VAR 0 2
19947: PUSH
19948: LD_INT 0
19950: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19951: LD_ADDR_VAR 0 3
19955: PUSH
19956: LD_VAR 0 1
19960: PPUSH
19961: CALL_OW 437
19965: ST_TO_ADDR
// if task then
19966: LD_VAR 0 3
19970: IFFALSE 19998
// if task [ 1 ] [ 1 ] = p then
19972: LD_VAR 0 3
19976: PUSH
19977: LD_INT 1
19979: ARRAY
19980: PUSH
19981: LD_INT 1
19983: ARRAY
19984: PUSH
19985: LD_STRING p
19987: EQUAL
19988: IFFALSE 19998
// result := true ;
19990: LD_ADDR_VAR 0 2
19994: PUSH
19995: LD_INT 1
19997: ST_TO_ADDR
// end ;
19998: LD_VAR 0 2
20002: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20003: LD_INT 0
20005: PPUSH
20006: PPUSH
20007: PPUSH
20008: PPUSH
// if pos < 1 then
20009: LD_VAR 0 2
20013: PUSH
20014: LD_INT 1
20016: LESS
20017: IFFALSE 20021
// exit ;
20019: GO 20324
// if pos = 1 then
20021: LD_VAR 0 2
20025: PUSH
20026: LD_INT 1
20028: EQUAL
20029: IFFALSE 20062
// result := Replace ( arr , pos [ 1 ] , value ) else
20031: LD_ADDR_VAR 0 4
20035: PUSH
20036: LD_VAR 0 1
20040: PPUSH
20041: LD_VAR 0 2
20045: PUSH
20046: LD_INT 1
20048: ARRAY
20049: PPUSH
20050: LD_VAR 0 3
20054: PPUSH
20055: CALL_OW 1
20059: ST_TO_ADDR
20060: GO 20324
// begin tmp := arr ;
20062: LD_ADDR_VAR 0 6
20066: PUSH
20067: LD_VAR 0 1
20071: ST_TO_ADDR
// s_arr := [ tmp ] ;
20072: LD_ADDR_VAR 0 7
20076: PUSH
20077: LD_VAR 0 6
20081: PUSH
20082: EMPTY
20083: LIST
20084: ST_TO_ADDR
// for i = 1 to pos - 1 do
20085: LD_ADDR_VAR 0 5
20089: PUSH
20090: DOUBLE
20091: LD_INT 1
20093: DEC
20094: ST_TO_ADDR
20095: LD_VAR 0 2
20099: PUSH
20100: LD_INT 1
20102: MINUS
20103: PUSH
20104: FOR_TO
20105: IFFALSE 20150
// begin tmp := tmp [ pos [ i ] ] ;
20107: LD_ADDR_VAR 0 6
20111: PUSH
20112: LD_VAR 0 6
20116: PUSH
20117: LD_VAR 0 2
20121: PUSH
20122: LD_VAR 0 5
20126: ARRAY
20127: ARRAY
20128: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20129: LD_ADDR_VAR 0 7
20133: PUSH
20134: LD_VAR 0 7
20138: PUSH
20139: LD_VAR 0 6
20143: PUSH
20144: EMPTY
20145: LIST
20146: ADD
20147: ST_TO_ADDR
// end ;
20148: GO 20104
20150: POP
20151: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20152: LD_ADDR_VAR 0 6
20156: PUSH
20157: LD_VAR 0 6
20161: PPUSH
20162: LD_VAR 0 2
20166: PUSH
20167: LD_VAR 0 2
20171: ARRAY
20172: PPUSH
20173: LD_VAR 0 3
20177: PPUSH
20178: CALL_OW 1
20182: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20183: LD_ADDR_VAR 0 7
20187: PUSH
20188: LD_VAR 0 7
20192: PPUSH
20193: LD_VAR 0 7
20197: PPUSH
20198: LD_VAR 0 6
20202: PPUSH
20203: CALL_OW 1
20207: ST_TO_ADDR
// for i = s_arr downto 2 do
20208: LD_ADDR_VAR 0 5
20212: PUSH
20213: DOUBLE
20214: LD_VAR 0 7
20218: INC
20219: ST_TO_ADDR
20220: LD_INT 2
20222: PUSH
20223: FOR_DOWNTO
20224: IFFALSE 20308
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20226: LD_ADDR_VAR 0 6
20230: PUSH
20231: LD_VAR 0 7
20235: PUSH
20236: LD_VAR 0 5
20240: PUSH
20241: LD_INT 1
20243: MINUS
20244: ARRAY
20245: PPUSH
20246: LD_VAR 0 2
20250: PUSH
20251: LD_VAR 0 5
20255: PUSH
20256: LD_INT 1
20258: MINUS
20259: ARRAY
20260: PPUSH
20261: LD_VAR 0 7
20265: PUSH
20266: LD_VAR 0 5
20270: ARRAY
20271: PPUSH
20272: CALL_OW 1
20276: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20277: LD_ADDR_VAR 0 7
20281: PUSH
20282: LD_VAR 0 7
20286: PPUSH
20287: LD_VAR 0 5
20291: PUSH
20292: LD_INT 1
20294: MINUS
20295: PPUSH
20296: LD_VAR 0 6
20300: PPUSH
20301: CALL_OW 1
20305: ST_TO_ADDR
// end ;
20306: GO 20223
20308: POP
20309: POP
// result := s_arr [ 1 ] ;
20310: LD_ADDR_VAR 0 4
20314: PUSH
20315: LD_VAR 0 7
20319: PUSH
20320: LD_INT 1
20322: ARRAY
20323: ST_TO_ADDR
// end ; end ;
20324: LD_VAR 0 4
20328: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20329: LD_INT 0
20331: PPUSH
20332: PPUSH
// if not list then
20333: LD_VAR 0 1
20337: NOT
20338: IFFALSE 20342
// exit ;
20340: GO 20433
// i := list [ pos1 ] ;
20342: LD_ADDR_VAR 0 5
20346: PUSH
20347: LD_VAR 0 1
20351: PUSH
20352: LD_VAR 0 2
20356: ARRAY
20357: ST_TO_ADDR
// if not i then
20358: LD_VAR 0 5
20362: NOT
20363: IFFALSE 20367
// exit ;
20365: GO 20433
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20367: LD_ADDR_VAR 0 1
20371: PUSH
20372: LD_VAR 0 1
20376: PPUSH
20377: LD_VAR 0 2
20381: PPUSH
20382: LD_VAR 0 1
20386: PUSH
20387: LD_VAR 0 3
20391: ARRAY
20392: PPUSH
20393: CALL_OW 1
20397: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20398: LD_ADDR_VAR 0 1
20402: PUSH
20403: LD_VAR 0 1
20407: PPUSH
20408: LD_VAR 0 3
20412: PPUSH
20413: LD_VAR 0 5
20417: PPUSH
20418: CALL_OW 1
20422: ST_TO_ADDR
// result := list ;
20423: LD_ADDR_VAR 0 4
20427: PUSH
20428: LD_VAR 0 1
20432: ST_TO_ADDR
// end ;
20433: LD_VAR 0 4
20437: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20438: LD_INT 0
20440: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20441: LD_ADDR_VAR 0 5
20445: PUSH
20446: LD_VAR 0 1
20450: PPUSH
20451: CALL_OW 250
20455: PPUSH
20456: LD_VAR 0 1
20460: PPUSH
20461: CALL_OW 251
20465: PPUSH
20466: LD_VAR 0 2
20470: PPUSH
20471: LD_VAR 0 3
20475: PPUSH
20476: LD_VAR 0 4
20480: PPUSH
20481: CALL 20491 0 5
20485: ST_TO_ADDR
// end ;
20486: LD_VAR 0 5
20490: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20491: LD_INT 0
20493: PPUSH
20494: PPUSH
20495: PPUSH
20496: PPUSH
// if not list then
20497: LD_VAR 0 3
20501: NOT
20502: IFFALSE 20506
// exit ;
20504: GO 20894
// result := [ ] ;
20506: LD_ADDR_VAR 0 6
20510: PUSH
20511: EMPTY
20512: ST_TO_ADDR
// for i in list do
20513: LD_ADDR_VAR 0 7
20517: PUSH
20518: LD_VAR 0 3
20522: PUSH
20523: FOR_IN
20524: IFFALSE 20726
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20526: LD_ADDR_VAR 0 9
20530: PUSH
20531: LD_VAR 0 7
20535: PPUSH
20536: LD_VAR 0 1
20540: PPUSH
20541: LD_VAR 0 2
20545: PPUSH
20546: CALL_OW 297
20550: ST_TO_ADDR
// if not result then
20551: LD_VAR 0 6
20555: NOT
20556: IFFALSE 20582
// result := [ [ i , tmp ] ] else
20558: LD_ADDR_VAR 0 6
20562: PUSH
20563: LD_VAR 0 7
20567: PUSH
20568: LD_VAR 0 9
20572: PUSH
20573: EMPTY
20574: LIST
20575: LIST
20576: PUSH
20577: EMPTY
20578: LIST
20579: ST_TO_ADDR
20580: GO 20724
// begin if result [ result ] [ 2 ] < tmp then
20582: LD_VAR 0 6
20586: PUSH
20587: LD_VAR 0 6
20591: ARRAY
20592: PUSH
20593: LD_INT 2
20595: ARRAY
20596: PUSH
20597: LD_VAR 0 9
20601: LESS
20602: IFFALSE 20644
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20604: LD_ADDR_VAR 0 6
20608: PUSH
20609: LD_VAR 0 6
20613: PPUSH
20614: LD_VAR 0 6
20618: PUSH
20619: LD_INT 1
20621: PLUS
20622: PPUSH
20623: LD_VAR 0 7
20627: PUSH
20628: LD_VAR 0 9
20632: PUSH
20633: EMPTY
20634: LIST
20635: LIST
20636: PPUSH
20637: CALL_OW 2
20641: ST_TO_ADDR
20642: GO 20724
// for j = 1 to result do
20644: LD_ADDR_VAR 0 8
20648: PUSH
20649: DOUBLE
20650: LD_INT 1
20652: DEC
20653: ST_TO_ADDR
20654: LD_VAR 0 6
20658: PUSH
20659: FOR_TO
20660: IFFALSE 20722
// begin if tmp < result [ j ] [ 2 ] then
20662: LD_VAR 0 9
20666: PUSH
20667: LD_VAR 0 6
20671: PUSH
20672: LD_VAR 0 8
20676: ARRAY
20677: PUSH
20678: LD_INT 2
20680: ARRAY
20681: LESS
20682: IFFALSE 20720
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20684: LD_ADDR_VAR 0 6
20688: PUSH
20689: LD_VAR 0 6
20693: PPUSH
20694: LD_VAR 0 8
20698: PPUSH
20699: LD_VAR 0 7
20703: PUSH
20704: LD_VAR 0 9
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: PPUSH
20713: CALL_OW 2
20717: ST_TO_ADDR
// break ;
20718: GO 20722
// end ; end ;
20720: GO 20659
20722: POP
20723: POP
// end ; end ;
20724: GO 20523
20726: POP
20727: POP
// if result and not asc then
20728: LD_VAR 0 6
20732: PUSH
20733: LD_VAR 0 4
20737: NOT
20738: AND
20739: IFFALSE 20814
// begin tmp := result ;
20741: LD_ADDR_VAR 0 9
20745: PUSH
20746: LD_VAR 0 6
20750: ST_TO_ADDR
// for i = tmp downto 1 do
20751: LD_ADDR_VAR 0 7
20755: PUSH
20756: DOUBLE
20757: LD_VAR 0 9
20761: INC
20762: ST_TO_ADDR
20763: LD_INT 1
20765: PUSH
20766: FOR_DOWNTO
20767: IFFALSE 20812
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20769: LD_ADDR_VAR 0 6
20773: PUSH
20774: LD_VAR 0 6
20778: PPUSH
20779: LD_VAR 0 9
20783: PUSH
20784: LD_VAR 0 7
20788: MINUS
20789: PUSH
20790: LD_INT 1
20792: PLUS
20793: PPUSH
20794: LD_VAR 0 9
20798: PUSH
20799: LD_VAR 0 7
20803: ARRAY
20804: PPUSH
20805: CALL_OW 1
20809: ST_TO_ADDR
20810: GO 20766
20812: POP
20813: POP
// end ; tmp := [ ] ;
20814: LD_ADDR_VAR 0 9
20818: PUSH
20819: EMPTY
20820: ST_TO_ADDR
// if mode then
20821: LD_VAR 0 5
20825: IFFALSE 20894
// begin for i = 1 to result do
20827: LD_ADDR_VAR 0 7
20831: PUSH
20832: DOUBLE
20833: LD_INT 1
20835: DEC
20836: ST_TO_ADDR
20837: LD_VAR 0 6
20841: PUSH
20842: FOR_TO
20843: IFFALSE 20882
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20845: LD_ADDR_VAR 0 9
20849: PUSH
20850: LD_VAR 0 9
20854: PPUSH
20855: LD_VAR 0 7
20859: PPUSH
20860: LD_VAR 0 6
20864: PUSH
20865: LD_VAR 0 7
20869: ARRAY
20870: PUSH
20871: LD_INT 1
20873: ARRAY
20874: PPUSH
20875: CALL_OW 1
20879: ST_TO_ADDR
20880: GO 20842
20882: POP
20883: POP
// result := tmp ;
20884: LD_ADDR_VAR 0 6
20888: PUSH
20889: LD_VAR 0 9
20893: ST_TO_ADDR
// end ; end ;
20894: LD_VAR 0 6
20898: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20899: LD_INT 0
20901: PPUSH
20902: PPUSH
20903: PPUSH
20904: PPUSH
20905: PPUSH
20906: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20907: LD_ADDR_VAR 0 5
20911: PUSH
20912: LD_INT 0
20914: PUSH
20915: LD_INT 0
20917: PUSH
20918: LD_INT 0
20920: PUSH
20921: EMPTY
20922: PUSH
20923: EMPTY
20924: LIST
20925: LIST
20926: LIST
20927: LIST
20928: ST_TO_ADDR
// if not x or not y then
20929: LD_VAR 0 2
20933: NOT
20934: PUSH
20935: LD_VAR 0 3
20939: NOT
20940: OR
20941: IFFALSE 20945
// exit ;
20943: GO 22597
// if not range then
20945: LD_VAR 0 4
20949: NOT
20950: IFFALSE 20960
// range := 10 ;
20952: LD_ADDR_VAR 0 4
20956: PUSH
20957: LD_INT 10
20959: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20960: LD_ADDR_VAR 0 8
20964: PUSH
20965: LD_INT 81
20967: PUSH
20968: LD_VAR 0 1
20972: PUSH
20973: EMPTY
20974: LIST
20975: LIST
20976: PUSH
20977: LD_INT 92
20979: PUSH
20980: LD_VAR 0 2
20984: PUSH
20985: LD_VAR 0 3
20989: PUSH
20990: LD_VAR 0 4
20994: PUSH
20995: EMPTY
20996: LIST
20997: LIST
20998: LIST
20999: LIST
21000: PUSH
21001: LD_INT 3
21003: PUSH
21004: LD_INT 21
21006: PUSH
21007: LD_INT 3
21009: PUSH
21010: EMPTY
21011: LIST
21012: LIST
21013: PUSH
21014: EMPTY
21015: LIST
21016: LIST
21017: PUSH
21018: EMPTY
21019: LIST
21020: LIST
21021: LIST
21022: PPUSH
21023: CALL_OW 69
21027: ST_TO_ADDR
// if not tmp then
21028: LD_VAR 0 8
21032: NOT
21033: IFFALSE 21037
// exit ;
21035: GO 22597
// for i in tmp do
21037: LD_ADDR_VAR 0 6
21041: PUSH
21042: LD_VAR 0 8
21046: PUSH
21047: FOR_IN
21048: IFFALSE 22572
// begin points := [ 0 , 0 , 0 ] ;
21050: LD_ADDR_VAR 0 9
21054: PUSH
21055: LD_INT 0
21057: PUSH
21058: LD_INT 0
21060: PUSH
21061: LD_INT 0
21063: PUSH
21064: EMPTY
21065: LIST
21066: LIST
21067: LIST
21068: ST_TO_ADDR
// bpoints := 1 ;
21069: LD_ADDR_VAR 0 10
21073: PUSH
21074: LD_INT 1
21076: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21077: LD_VAR 0 6
21081: PPUSH
21082: CALL_OW 247
21086: PUSH
21087: LD_INT 1
21089: DOUBLE
21090: EQUAL
21091: IFTRUE 21095
21093: GO 21673
21095: POP
// begin if GetClass ( i ) = 1 then
21096: LD_VAR 0 6
21100: PPUSH
21101: CALL_OW 257
21105: PUSH
21106: LD_INT 1
21108: EQUAL
21109: IFFALSE 21130
// points := [ 10 , 5 , 3 ] ;
21111: LD_ADDR_VAR 0 9
21115: PUSH
21116: LD_INT 10
21118: PUSH
21119: LD_INT 5
21121: PUSH
21122: LD_INT 3
21124: PUSH
21125: EMPTY
21126: LIST
21127: LIST
21128: LIST
21129: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21130: LD_VAR 0 6
21134: PPUSH
21135: CALL_OW 257
21139: PUSH
21140: LD_INT 2
21142: PUSH
21143: LD_INT 3
21145: PUSH
21146: LD_INT 4
21148: PUSH
21149: EMPTY
21150: LIST
21151: LIST
21152: LIST
21153: IN
21154: IFFALSE 21175
// points := [ 3 , 2 , 1 ] ;
21156: LD_ADDR_VAR 0 9
21160: PUSH
21161: LD_INT 3
21163: PUSH
21164: LD_INT 2
21166: PUSH
21167: LD_INT 1
21169: PUSH
21170: EMPTY
21171: LIST
21172: LIST
21173: LIST
21174: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21175: LD_VAR 0 6
21179: PPUSH
21180: CALL_OW 257
21184: PUSH
21185: LD_INT 5
21187: EQUAL
21188: IFFALSE 21209
// points := [ 130 , 5 , 2 ] ;
21190: LD_ADDR_VAR 0 9
21194: PUSH
21195: LD_INT 130
21197: PUSH
21198: LD_INT 5
21200: PUSH
21201: LD_INT 2
21203: PUSH
21204: EMPTY
21205: LIST
21206: LIST
21207: LIST
21208: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21209: LD_VAR 0 6
21213: PPUSH
21214: CALL_OW 257
21218: PUSH
21219: LD_INT 8
21221: EQUAL
21222: IFFALSE 21243
// points := [ 35 , 35 , 30 ] ;
21224: LD_ADDR_VAR 0 9
21228: PUSH
21229: LD_INT 35
21231: PUSH
21232: LD_INT 35
21234: PUSH
21235: LD_INT 30
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: LIST
21242: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21243: LD_VAR 0 6
21247: PPUSH
21248: CALL_OW 257
21252: PUSH
21253: LD_INT 9
21255: EQUAL
21256: IFFALSE 21277
// points := [ 20 , 55 , 40 ] ;
21258: LD_ADDR_VAR 0 9
21262: PUSH
21263: LD_INT 20
21265: PUSH
21266: LD_INT 55
21268: PUSH
21269: LD_INT 40
21271: PUSH
21272: EMPTY
21273: LIST
21274: LIST
21275: LIST
21276: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21277: LD_VAR 0 6
21281: PPUSH
21282: CALL_OW 257
21286: PUSH
21287: LD_INT 12
21289: PUSH
21290: LD_INT 16
21292: PUSH
21293: EMPTY
21294: LIST
21295: LIST
21296: IN
21297: IFFALSE 21318
// points := [ 5 , 3 , 2 ] ;
21299: LD_ADDR_VAR 0 9
21303: PUSH
21304: LD_INT 5
21306: PUSH
21307: LD_INT 3
21309: PUSH
21310: LD_INT 2
21312: PUSH
21313: EMPTY
21314: LIST
21315: LIST
21316: LIST
21317: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21318: LD_VAR 0 6
21322: PPUSH
21323: CALL_OW 257
21327: PUSH
21328: LD_INT 17
21330: EQUAL
21331: IFFALSE 21352
// points := [ 100 , 50 , 75 ] ;
21333: LD_ADDR_VAR 0 9
21337: PUSH
21338: LD_INT 100
21340: PUSH
21341: LD_INT 50
21343: PUSH
21344: LD_INT 75
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: LIST
21351: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21352: LD_VAR 0 6
21356: PPUSH
21357: CALL_OW 257
21361: PUSH
21362: LD_INT 15
21364: EQUAL
21365: IFFALSE 21386
// points := [ 10 , 5 , 3 ] ;
21367: LD_ADDR_VAR 0 9
21371: PUSH
21372: LD_INT 10
21374: PUSH
21375: LD_INT 5
21377: PUSH
21378: LD_INT 3
21380: PUSH
21381: EMPTY
21382: LIST
21383: LIST
21384: LIST
21385: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21386: LD_VAR 0 6
21390: PPUSH
21391: CALL_OW 257
21395: PUSH
21396: LD_INT 14
21398: EQUAL
21399: IFFALSE 21420
// points := [ 10 , 0 , 0 ] ;
21401: LD_ADDR_VAR 0 9
21405: PUSH
21406: LD_INT 10
21408: PUSH
21409: LD_INT 0
21411: PUSH
21412: LD_INT 0
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: LIST
21419: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21420: LD_VAR 0 6
21424: PPUSH
21425: CALL_OW 257
21429: PUSH
21430: LD_INT 11
21432: EQUAL
21433: IFFALSE 21454
// points := [ 30 , 10 , 5 ] ;
21435: LD_ADDR_VAR 0 9
21439: PUSH
21440: LD_INT 30
21442: PUSH
21443: LD_INT 10
21445: PUSH
21446: LD_INT 5
21448: PUSH
21449: EMPTY
21450: LIST
21451: LIST
21452: LIST
21453: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21454: LD_VAR 0 1
21458: PPUSH
21459: LD_INT 5
21461: PPUSH
21462: CALL_OW 321
21466: PUSH
21467: LD_INT 2
21469: EQUAL
21470: IFFALSE 21487
// bpoints := bpoints * 1.8 ;
21472: LD_ADDR_VAR 0 10
21476: PUSH
21477: LD_VAR 0 10
21481: PUSH
21482: LD_REAL  1.80000000000000E+0000
21485: MUL
21486: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21487: LD_VAR 0 6
21491: PPUSH
21492: CALL_OW 257
21496: PUSH
21497: LD_INT 1
21499: PUSH
21500: LD_INT 2
21502: PUSH
21503: LD_INT 3
21505: PUSH
21506: LD_INT 4
21508: PUSH
21509: EMPTY
21510: LIST
21511: LIST
21512: LIST
21513: LIST
21514: IN
21515: PUSH
21516: LD_VAR 0 1
21520: PPUSH
21521: LD_INT 51
21523: PPUSH
21524: CALL_OW 321
21528: PUSH
21529: LD_INT 2
21531: EQUAL
21532: AND
21533: IFFALSE 21550
// bpoints := bpoints * 1.2 ;
21535: LD_ADDR_VAR 0 10
21539: PUSH
21540: LD_VAR 0 10
21544: PUSH
21545: LD_REAL  1.20000000000000E+0000
21548: MUL
21549: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21550: LD_VAR 0 6
21554: PPUSH
21555: CALL_OW 257
21559: PUSH
21560: LD_INT 5
21562: PUSH
21563: LD_INT 7
21565: PUSH
21566: LD_INT 9
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: LIST
21573: IN
21574: PUSH
21575: LD_VAR 0 1
21579: PPUSH
21580: LD_INT 52
21582: PPUSH
21583: CALL_OW 321
21587: PUSH
21588: LD_INT 2
21590: EQUAL
21591: AND
21592: IFFALSE 21609
// bpoints := bpoints * 1.5 ;
21594: LD_ADDR_VAR 0 10
21598: PUSH
21599: LD_VAR 0 10
21603: PUSH
21604: LD_REAL  1.50000000000000E+0000
21607: MUL
21608: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21609: LD_VAR 0 1
21613: PPUSH
21614: LD_INT 66
21616: PPUSH
21617: CALL_OW 321
21621: PUSH
21622: LD_INT 2
21624: EQUAL
21625: IFFALSE 21642
// bpoints := bpoints * 1.1 ;
21627: LD_ADDR_VAR 0 10
21631: PUSH
21632: LD_VAR 0 10
21636: PUSH
21637: LD_REAL  1.10000000000000E+0000
21640: MUL
21641: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21642: LD_ADDR_VAR 0 10
21646: PUSH
21647: LD_VAR 0 10
21651: PUSH
21652: LD_VAR 0 6
21656: PPUSH
21657: LD_INT 1
21659: PPUSH
21660: CALL_OW 259
21664: PUSH
21665: LD_REAL  1.15000000000000E+0000
21668: MUL
21669: MUL
21670: ST_TO_ADDR
// end ; unit_vehicle :
21671: GO 22501
21673: LD_INT 2
21675: DOUBLE
21676: EQUAL
21677: IFTRUE 21681
21679: GO 22489
21681: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21682: LD_VAR 0 6
21686: PPUSH
21687: CALL_OW 264
21691: PUSH
21692: LD_INT 2
21694: PUSH
21695: LD_INT 42
21697: PUSH
21698: LD_INT 24
21700: PUSH
21701: EMPTY
21702: LIST
21703: LIST
21704: LIST
21705: IN
21706: IFFALSE 21727
// points := [ 25 , 5 , 3 ] ;
21708: LD_ADDR_VAR 0 9
21712: PUSH
21713: LD_INT 25
21715: PUSH
21716: LD_INT 5
21718: PUSH
21719: LD_INT 3
21721: PUSH
21722: EMPTY
21723: LIST
21724: LIST
21725: LIST
21726: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21727: LD_VAR 0 6
21731: PPUSH
21732: CALL_OW 264
21736: PUSH
21737: LD_INT 4
21739: PUSH
21740: LD_INT 43
21742: PUSH
21743: LD_INT 25
21745: PUSH
21746: EMPTY
21747: LIST
21748: LIST
21749: LIST
21750: IN
21751: IFFALSE 21772
// points := [ 40 , 15 , 5 ] ;
21753: LD_ADDR_VAR 0 9
21757: PUSH
21758: LD_INT 40
21760: PUSH
21761: LD_INT 15
21763: PUSH
21764: LD_INT 5
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: LIST
21771: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21772: LD_VAR 0 6
21776: PPUSH
21777: CALL_OW 264
21781: PUSH
21782: LD_INT 3
21784: PUSH
21785: LD_INT 23
21787: PUSH
21788: EMPTY
21789: LIST
21790: LIST
21791: IN
21792: IFFALSE 21813
// points := [ 7 , 25 , 8 ] ;
21794: LD_ADDR_VAR 0 9
21798: PUSH
21799: LD_INT 7
21801: PUSH
21802: LD_INT 25
21804: PUSH
21805: LD_INT 8
21807: PUSH
21808: EMPTY
21809: LIST
21810: LIST
21811: LIST
21812: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21813: LD_VAR 0 6
21817: PPUSH
21818: CALL_OW 264
21822: PUSH
21823: LD_INT 5
21825: PUSH
21826: LD_INT 27
21828: PUSH
21829: LD_INT 44
21831: PUSH
21832: EMPTY
21833: LIST
21834: LIST
21835: LIST
21836: IN
21837: IFFALSE 21858
// points := [ 14 , 50 , 16 ] ;
21839: LD_ADDR_VAR 0 9
21843: PUSH
21844: LD_INT 14
21846: PUSH
21847: LD_INT 50
21849: PUSH
21850: LD_INT 16
21852: PUSH
21853: EMPTY
21854: LIST
21855: LIST
21856: LIST
21857: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21858: LD_VAR 0 6
21862: PPUSH
21863: CALL_OW 264
21867: PUSH
21868: LD_INT 6
21870: PUSH
21871: LD_INT 46
21873: PUSH
21874: EMPTY
21875: LIST
21876: LIST
21877: IN
21878: IFFALSE 21899
// points := [ 32 , 120 , 70 ] ;
21880: LD_ADDR_VAR 0 9
21884: PUSH
21885: LD_INT 32
21887: PUSH
21888: LD_INT 120
21890: PUSH
21891: LD_INT 70
21893: PUSH
21894: EMPTY
21895: LIST
21896: LIST
21897: LIST
21898: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21899: LD_VAR 0 6
21903: PPUSH
21904: CALL_OW 264
21908: PUSH
21909: LD_INT 7
21911: PUSH
21912: LD_INT 28
21914: PUSH
21915: LD_INT 45
21917: PUSH
21918: LD_EXP 109
21922: PUSH
21923: EMPTY
21924: LIST
21925: LIST
21926: LIST
21927: LIST
21928: IN
21929: IFFALSE 21950
// points := [ 35 , 20 , 45 ] ;
21931: LD_ADDR_VAR 0 9
21935: PUSH
21936: LD_INT 35
21938: PUSH
21939: LD_INT 20
21941: PUSH
21942: LD_INT 45
21944: PUSH
21945: EMPTY
21946: LIST
21947: LIST
21948: LIST
21949: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21950: LD_VAR 0 6
21954: PPUSH
21955: CALL_OW 264
21959: PUSH
21960: LD_INT 47
21962: PUSH
21963: EMPTY
21964: LIST
21965: IN
21966: IFFALSE 21987
// points := [ 67 , 45 , 75 ] ;
21968: LD_ADDR_VAR 0 9
21972: PUSH
21973: LD_INT 67
21975: PUSH
21976: LD_INT 45
21978: PUSH
21979: LD_INT 75
21981: PUSH
21982: EMPTY
21983: LIST
21984: LIST
21985: LIST
21986: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21987: LD_VAR 0 6
21991: PPUSH
21992: CALL_OW 264
21996: PUSH
21997: LD_INT 26
21999: PUSH
22000: EMPTY
22001: LIST
22002: IN
22003: IFFALSE 22024
// points := [ 120 , 30 , 80 ] ;
22005: LD_ADDR_VAR 0 9
22009: PUSH
22010: LD_INT 120
22012: PUSH
22013: LD_INT 30
22015: PUSH
22016: LD_INT 80
22018: PUSH
22019: EMPTY
22020: LIST
22021: LIST
22022: LIST
22023: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22024: LD_VAR 0 6
22028: PPUSH
22029: CALL_OW 264
22033: PUSH
22034: LD_INT 22
22036: PUSH
22037: EMPTY
22038: LIST
22039: IN
22040: IFFALSE 22061
// points := [ 40 , 1 , 1 ] ;
22042: LD_ADDR_VAR 0 9
22046: PUSH
22047: LD_INT 40
22049: PUSH
22050: LD_INT 1
22052: PUSH
22053: LD_INT 1
22055: PUSH
22056: EMPTY
22057: LIST
22058: LIST
22059: LIST
22060: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22061: LD_VAR 0 6
22065: PPUSH
22066: CALL_OW 264
22070: PUSH
22071: LD_INT 29
22073: PUSH
22074: EMPTY
22075: LIST
22076: IN
22077: IFFALSE 22098
// points := [ 70 , 200 , 400 ] ;
22079: LD_ADDR_VAR 0 9
22083: PUSH
22084: LD_INT 70
22086: PUSH
22087: LD_INT 200
22089: PUSH
22090: LD_INT 400
22092: PUSH
22093: EMPTY
22094: LIST
22095: LIST
22096: LIST
22097: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22098: LD_VAR 0 6
22102: PPUSH
22103: CALL_OW 264
22107: PUSH
22108: LD_INT 14
22110: PUSH
22111: LD_INT 53
22113: PUSH
22114: EMPTY
22115: LIST
22116: LIST
22117: IN
22118: IFFALSE 22139
// points := [ 40 , 10 , 20 ] ;
22120: LD_ADDR_VAR 0 9
22124: PUSH
22125: LD_INT 40
22127: PUSH
22128: LD_INT 10
22130: PUSH
22131: LD_INT 20
22133: PUSH
22134: EMPTY
22135: LIST
22136: LIST
22137: LIST
22138: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22139: LD_VAR 0 6
22143: PPUSH
22144: CALL_OW 264
22148: PUSH
22149: LD_INT 9
22151: PUSH
22152: EMPTY
22153: LIST
22154: IN
22155: IFFALSE 22176
// points := [ 5 , 70 , 20 ] ;
22157: LD_ADDR_VAR 0 9
22161: PUSH
22162: LD_INT 5
22164: PUSH
22165: LD_INT 70
22167: PUSH
22168: LD_INT 20
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: LIST
22175: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22176: LD_VAR 0 6
22180: PPUSH
22181: CALL_OW 264
22185: PUSH
22186: LD_INT 10
22188: PUSH
22189: EMPTY
22190: LIST
22191: IN
22192: IFFALSE 22213
// points := [ 35 , 110 , 70 ] ;
22194: LD_ADDR_VAR 0 9
22198: PUSH
22199: LD_INT 35
22201: PUSH
22202: LD_INT 110
22204: PUSH
22205: LD_INT 70
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: LIST
22212: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22213: LD_VAR 0 6
22217: PPUSH
22218: CALL_OW 265
22222: PUSH
22223: LD_INT 25
22225: EQUAL
22226: IFFALSE 22247
// points := [ 80 , 65 , 100 ] ;
22228: LD_ADDR_VAR 0 9
22232: PUSH
22233: LD_INT 80
22235: PUSH
22236: LD_INT 65
22238: PUSH
22239: LD_INT 100
22241: PUSH
22242: EMPTY
22243: LIST
22244: LIST
22245: LIST
22246: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22247: LD_VAR 0 6
22251: PPUSH
22252: CALL_OW 263
22256: PUSH
22257: LD_INT 1
22259: EQUAL
22260: IFFALSE 22295
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22262: LD_ADDR_VAR 0 10
22266: PUSH
22267: LD_VAR 0 10
22271: PUSH
22272: LD_VAR 0 6
22276: PPUSH
22277: CALL_OW 311
22281: PPUSH
22282: LD_INT 3
22284: PPUSH
22285: CALL_OW 259
22289: PUSH
22290: LD_INT 4
22292: MUL
22293: MUL
22294: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22295: LD_VAR 0 6
22299: PPUSH
22300: CALL_OW 263
22304: PUSH
22305: LD_INT 2
22307: EQUAL
22308: IFFALSE 22359
// begin j := IsControledBy ( i ) ;
22310: LD_ADDR_VAR 0 7
22314: PUSH
22315: LD_VAR 0 6
22319: PPUSH
22320: CALL_OW 312
22324: ST_TO_ADDR
// if j then
22325: LD_VAR 0 7
22329: IFFALSE 22359
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22331: LD_ADDR_VAR 0 10
22335: PUSH
22336: LD_VAR 0 10
22340: PUSH
22341: LD_VAR 0 7
22345: PPUSH
22346: LD_INT 3
22348: PPUSH
22349: CALL_OW 259
22353: PUSH
22354: LD_INT 3
22356: MUL
22357: MUL
22358: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22359: LD_VAR 0 6
22363: PPUSH
22364: CALL_OW 264
22368: PUSH
22369: LD_INT 5
22371: PUSH
22372: LD_INT 6
22374: PUSH
22375: LD_INT 46
22377: PUSH
22378: LD_INT 44
22380: PUSH
22381: LD_INT 47
22383: PUSH
22384: LD_INT 45
22386: PUSH
22387: LD_INT 28
22389: PUSH
22390: LD_INT 7
22392: PUSH
22393: LD_INT 27
22395: PUSH
22396: LD_INT 29
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: LIST
22403: LIST
22404: LIST
22405: LIST
22406: LIST
22407: LIST
22408: LIST
22409: LIST
22410: IN
22411: PUSH
22412: LD_VAR 0 1
22416: PPUSH
22417: LD_INT 52
22419: PPUSH
22420: CALL_OW 321
22424: PUSH
22425: LD_INT 2
22427: EQUAL
22428: AND
22429: IFFALSE 22446
// bpoints := bpoints * 1.2 ;
22431: LD_ADDR_VAR 0 10
22435: PUSH
22436: LD_VAR 0 10
22440: PUSH
22441: LD_REAL  1.20000000000000E+0000
22444: MUL
22445: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22446: LD_VAR 0 6
22450: PPUSH
22451: CALL_OW 264
22455: PUSH
22456: LD_INT 6
22458: PUSH
22459: LD_INT 46
22461: PUSH
22462: LD_INT 47
22464: PUSH
22465: EMPTY
22466: LIST
22467: LIST
22468: LIST
22469: IN
22470: IFFALSE 22487
// bpoints := bpoints * 1.2 ;
22472: LD_ADDR_VAR 0 10
22476: PUSH
22477: LD_VAR 0 10
22481: PUSH
22482: LD_REAL  1.20000000000000E+0000
22485: MUL
22486: ST_TO_ADDR
// end ; unit_building :
22487: GO 22501
22489: LD_INT 3
22491: DOUBLE
22492: EQUAL
22493: IFTRUE 22497
22495: GO 22500
22497: POP
// ; end ;
22498: GO 22501
22500: POP
// for j = 1 to 3 do
22501: LD_ADDR_VAR 0 7
22505: PUSH
22506: DOUBLE
22507: LD_INT 1
22509: DEC
22510: ST_TO_ADDR
22511: LD_INT 3
22513: PUSH
22514: FOR_TO
22515: IFFALSE 22568
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22517: LD_ADDR_VAR 0 5
22521: PUSH
22522: LD_VAR 0 5
22526: PPUSH
22527: LD_VAR 0 7
22531: PPUSH
22532: LD_VAR 0 5
22536: PUSH
22537: LD_VAR 0 7
22541: ARRAY
22542: PUSH
22543: LD_VAR 0 9
22547: PUSH
22548: LD_VAR 0 7
22552: ARRAY
22553: PUSH
22554: LD_VAR 0 10
22558: MUL
22559: PLUS
22560: PPUSH
22561: CALL_OW 1
22565: ST_TO_ADDR
22566: GO 22514
22568: POP
22569: POP
// end ;
22570: GO 21047
22572: POP
22573: POP
// result := Replace ( result , 4 , tmp ) ;
22574: LD_ADDR_VAR 0 5
22578: PUSH
22579: LD_VAR 0 5
22583: PPUSH
22584: LD_INT 4
22586: PPUSH
22587: LD_VAR 0 8
22591: PPUSH
22592: CALL_OW 1
22596: ST_TO_ADDR
// end ;
22597: LD_VAR 0 5
22601: RET
// export function DangerAtRange ( unit , range ) ; begin
22602: LD_INT 0
22604: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22605: LD_ADDR_VAR 0 3
22609: PUSH
22610: LD_VAR 0 1
22614: PPUSH
22615: CALL_OW 255
22619: PPUSH
22620: LD_VAR 0 1
22624: PPUSH
22625: CALL_OW 250
22629: PPUSH
22630: LD_VAR 0 1
22634: PPUSH
22635: CALL_OW 251
22639: PPUSH
22640: LD_VAR 0 2
22644: PPUSH
22645: CALL 20899 0 4
22649: ST_TO_ADDR
// end ;
22650: LD_VAR 0 3
22654: RET
// export function DangerInArea ( side , area ) ; begin
22655: LD_INT 0
22657: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22658: LD_ADDR_VAR 0 3
22662: PUSH
22663: LD_VAR 0 2
22667: PPUSH
22668: LD_INT 81
22670: PUSH
22671: LD_VAR 0 1
22675: PUSH
22676: EMPTY
22677: LIST
22678: LIST
22679: PPUSH
22680: CALL_OW 70
22684: ST_TO_ADDR
// end ;
22685: LD_VAR 0 3
22689: RET
// export function IsExtension ( b ) ; begin
22690: LD_INT 0
22692: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22693: LD_ADDR_VAR 0 2
22697: PUSH
22698: LD_VAR 0 1
22702: PUSH
22703: LD_INT 23
22705: PUSH
22706: LD_INT 20
22708: PUSH
22709: LD_INT 22
22711: PUSH
22712: LD_INT 17
22714: PUSH
22715: LD_INT 24
22717: PUSH
22718: LD_INT 21
22720: PUSH
22721: LD_INT 19
22723: PUSH
22724: LD_INT 16
22726: PUSH
22727: LD_INT 25
22729: PUSH
22730: LD_INT 18
22732: PUSH
22733: EMPTY
22734: LIST
22735: LIST
22736: LIST
22737: LIST
22738: LIST
22739: LIST
22740: LIST
22741: LIST
22742: LIST
22743: LIST
22744: IN
22745: ST_TO_ADDR
// end ;
22746: LD_VAR 0 2
22750: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22751: LD_INT 0
22753: PPUSH
22754: PPUSH
22755: PPUSH
// result := [ ] ;
22756: LD_ADDR_VAR 0 4
22760: PUSH
22761: EMPTY
22762: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22763: LD_ADDR_VAR 0 5
22767: PUSH
22768: LD_VAR 0 2
22772: PPUSH
22773: LD_INT 21
22775: PUSH
22776: LD_INT 3
22778: PUSH
22779: EMPTY
22780: LIST
22781: LIST
22782: PPUSH
22783: CALL_OW 70
22787: ST_TO_ADDR
// if not tmp then
22788: LD_VAR 0 5
22792: NOT
22793: IFFALSE 22797
// exit ;
22795: GO 22861
// if checkLink then
22797: LD_VAR 0 3
22801: IFFALSE 22851
// begin for i in tmp do
22803: LD_ADDR_VAR 0 6
22807: PUSH
22808: LD_VAR 0 5
22812: PUSH
22813: FOR_IN
22814: IFFALSE 22849
// if GetBase ( i ) <> base then
22816: LD_VAR 0 6
22820: PPUSH
22821: CALL_OW 274
22825: PUSH
22826: LD_VAR 0 1
22830: NONEQUAL
22831: IFFALSE 22847
// ComLinkToBase ( base , i ) ;
22833: LD_VAR 0 1
22837: PPUSH
22838: LD_VAR 0 6
22842: PPUSH
22843: CALL_OW 169
22847: GO 22813
22849: POP
22850: POP
// end ; result := tmp ;
22851: LD_ADDR_VAR 0 4
22855: PUSH
22856: LD_VAR 0 5
22860: ST_TO_ADDR
// end ;
22861: LD_VAR 0 4
22865: RET
// export function ComComplete ( units , b ) ; var i ; begin
22866: LD_INT 0
22868: PPUSH
22869: PPUSH
// if not units then
22870: LD_VAR 0 1
22874: NOT
22875: IFFALSE 22879
// exit ;
22877: GO 22969
// for i in units do
22879: LD_ADDR_VAR 0 4
22883: PUSH
22884: LD_VAR 0 1
22888: PUSH
22889: FOR_IN
22890: IFFALSE 22967
// if BuildingStatus ( b ) = bs_build then
22892: LD_VAR 0 2
22896: PPUSH
22897: CALL_OW 461
22901: PUSH
22902: LD_INT 1
22904: EQUAL
22905: IFFALSE 22965
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22907: LD_VAR 0 4
22911: PPUSH
22912: LD_STRING h
22914: PUSH
22915: LD_VAR 0 2
22919: PPUSH
22920: CALL_OW 250
22924: PUSH
22925: LD_VAR 0 2
22929: PPUSH
22930: CALL_OW 251
22934: PUSH
22935: LD_VAR 0 2
22939: PUSH
22940: LD_INT 0
22942: PUSH
22943: LD_INT 0
22945: PUSH
22946: LD_INT 0
22948: PUSH
22949: EMPTY
22950: LIST
22951: LIST
22952: LIST
22953: LIST
22954: LIST
22955: LIST
22956: LIST
22957: PUSH
22958: EMPTY
22959: LIST
22960: PPUSH
22961: CALL_OW 446
22965: GO 22889
22967: POP
22968: POP
// end ;
22969: LD_VAR 0 3
22973: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22974: LD_INT 0
22976: PPUSH
22977: PPUSH
22978: PPUSH
22979: PPUSH
22980: PPUSH
22981: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
22982: LD_VAR 0 1
22986: NOT
22987: PUSH
22988: LD_VAR 0 1
22992: PPUSH
22993: CALL_OW 263
22997: PUSH
22998: LD_INT 2
23000: NONEQUAL
23001: OR
23002: IFFALSE 23006
// exit ;
23004: GO 23322
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23006: LD_ADDR_VAR 0 6
23010: PUSH
23011: LD_INT 22
23013: PUSH
23014: LD_VAR 0 1
23018: PPUSH
23019: CALL_OW 255
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: PUSH
23028: LD_INT 2
23030: PUSH
23031: LD_INT 30
23033: PUSH
23034: LD_INT 36
23036: PUSH
23037: EMPTY
23038: LIST
23039: LIST
23040: PUSH
23041: LD_INT 34
23043: PUSH
23044: LD_INT 31
23046: PUSH
23047: EMPTY
23048: LIST
23049: LIST
23050: PUSH
23051: EMPTY
23052: LIST
23053: LIST
23054: LIST
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: PPUSH
23060: CALL_OW 69
23064: ST_TO_ADDR
// if not tmp then
23065: LD_VAR 0 6
23069: NOT
23070: IFFALSE 23074
// exit ;
23072: GO 23322
// result := [ ] ;
23074: LD_ADDR_VAR 0 2
23078: PUSH
23079: EMPTY
23080: ST_TO_ADDR
// for i in tmp do
23081: LD_ADDR_VAR 0 3
23085: PUSH
23086: LD_VAR 0 6
23090: PUSH
23091: FOR_IN
23092: IFFALSE 23163
// begin t := UnitsInside ( i ) ;
23094: LD_ADDR_VAR 0 4
23098: PUSH
23099: LD_VAR 0 3
23103: PPUSH
23104: CALL_OW 313
23108: ST_TO_ADDR
// if t then
23109: LD_VAR 0 4
23113: IFFALSE 23161
// for j in t do
23115: LD_ADDR_VAR 0 7
23119: PUSH
23120: LD_VAR 0 4
23124: PUSH
23125: FOR_IN
23126: IFFALSE 23159
// result := Replace ( result , result + 1 , j ) ;
23128: LD_ADDR_VAR 0 2
23132: PUSH
23133: LD_VAR 0 2
23137: PPUSH
23138: LD_VAR 0 2
23142: PUSH
23143: LD_INT 1
23145: PLUS
23146: PPUSH
23147: LD_VAR 0 7
23151: PPUSH
23152: CALL_OW 1
23156: ST_TO_ADDR
23157: GO 23125
23159: POP
23160: POP
// end ;
23161: GO 23091
23163: POP
23164: POP
// if not result then
23165: LD_VAR 0 2
23169: NOT
23170: IFFALSE 23174
// exit ;
23172: GO 23322
// mech := result [ 1 ] ;
23174: LD_ADDR_VAR 0 5
23178: PUSH
23179: LD_VAR 0 2
23183: PUSH
23184: LD_INT 1
23186: ARRAY
23187: ST_TO_ADDR
// if result > 1 then
23188: LD_VAR 0 2
23192: PUSH
23193: LD_INT 1
23195: GREATER
23196: IFFALSE 23308
// begin for i = 2 to result do
23198: LD_ADDR_VAR 0 3
23202: PUSH
23203: DOUBLE
23204: LD_INT 2
23206: DEC
23207: ST_TO_ADDR
23208: LD_VAR 0 2
23212: PUSH
23213: FOR_TO
23214: IFFALSE 23306
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23216: LD_ADDR_VAR 0 4
23220: PUSH
23221: LD_VAR 0 2
23225: PUSH
23226: LD_VAR 0 3
23230: ARRAY
23231: PPUSH
23232: LD_INT 3
23234: PPUSH
23235: CALL_OW 259
23239: PUSH
23240: LD_VAR 0 2
23244: PUSH
23245: LD_VAR 0 3
23249: ARRAY
23250: PPUSH
23251: CALL_OW 432
23255: MINUS
23256: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23257: LD_VAR 0 4
23261: PUSH
23262: LD_VAR 0 5
23266: PPUSH
23267: LD_INT 3
23269: PPUSH
23270: CALL_OW 259
23274: PUSH
23275: LD_VAR 0 5
23279: PPUSH
23280: CALL_OW 432
23284: MINUS
23285: GREATEREQUAL
23286: IFFALSE 23304
// mech := result [ i ] ;
23288: LD_ADDR_VAR 0 5
23292: PUSH
23293: LD_VAR 0 2
23297: PUSH
23298: LD_VAR 0 3
23302: ARRAY
23303: ST_TO_ADDR
// end ;
23304: GO 23213
23306: POP
23307: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23308: LD_VAR 0 1
23312: PPUSH
23313: LD_VAR 0 5
23317: PPUSH
23318: CALL_OW 135
// end ;
23322: LD_VAR 0 2
23326: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23327: LD_INT 0
23329: PPUSH
23330: PPUSH
23331: PPUSH
23332: PPUSH
23333: PPUSH
23334: PPUSH
23335: PPUSH
23336: PPUSH
23337: PPUSH
23338: PPUSH
23339: PPUSH
23340: PPUSH
23341: PPUSH
// result := [ ] ;
23342: LD_ADDR_VAR 0 7
23346: PUSH
23347: EMPTY
23348: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23349: LD_VAR 0 1
23353: PPUSH
23354: CALL_OW 266
23358: PUSH
23359: LD_INT 0
23361: PUSH
23362: LD_INT 1
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: IN
23369: NOT
23370: IFFALSE 23374
// exit ;
23372: GO 25008
// if name then
23374: LD_VAR 0 3
23378: IFFALSE 23394
// SetBName ( base_dep , name ) ;
23380: LD_VAR 0 1
23384: PPUSH
23385: LD_VAR 0 3
23389: PPUSH
23390: CALL_OW 500
// base := GetBase ( base_dep ) ;
23394: LD_ADDR_VAR 0 15
23398: PUSH
23399: LD_VAR 0 1
23403: PPUSH
23404: CALL_OW 274
23408: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23409: LD_ADDR_VAR 0 16
23413: PUSH
23414: LD_VAR 0 1
23418: PPUSH
23419: CALL_OW 255
23423: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23424: LD_ADDR_VAR 0 17
23428: PUSH
23429: LD_VAR 0 1
23433: PPUSH
23434: CALL_OW 248
23438: ST_TO_ADDR
// if sources then
23439: LD_VAR 0 5
23443: IFFALSE 23490
// for i = 1 to 3 do
23445: LD_ADDR_VAR 0 8
23449: PUSH
23450: DOUBLE
23451: LD_INT 1
23453: DEC
23454: ST_TO_ADDR
23455: LD_INT 3
23457: PUSH
23458: FOR_TO
23459: IFFALSE 23488
// AddResourceType ( base , i , sources [ i ] ) ;
23461: LD_VAR 0 15
23465: PPUSH
23466: LD_VAR 0 8
23470: PPUSH
23471: LD_VAR 0 5
23475: PUSH
23476: LD_VAR 0 8
23480: ARRAY
23481: PPUSH
23482: CALL_OW 276
23486: GO 23458
23488: POP
23489: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23490: LD_ADDR_VAR 0 18
23494: PUSH
23495: LD_VAR 0 15
23499: PPUSH
23500: LD_VAR 0 2
23504: PPUSH
23505: LD_INT 1
23507: PPUSH
23508: CALL 22751 0 3
23512: ST_TO_ADDR
// InitHc ;
23513: CALL_OW 19
// InitUc ;
23517: CALL_OW 18
// uc_side := side ;
23521: LD_ADDR_OWVAR 20
23525: PUSH
23526: LD_VAR 0 16
23530: ST_TO_ADDR
// uc_nation := nation ;
23531: LD_ADDR_OWVAR 21
23535: PUSH
23536: LD_VAR 0 17
23540: ST_TO_ADDR
// if buildings then
23541: LD_VAR 0 18
23545: IFFALSE 24867
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23547: LD_ADDR_VAR 0 19
23551: PUSH
23552: LD_VAR 0 18
23556: PPUSH
23557: LD_INT 2
23559: PUSH
23560: LD_INT 30
23562: PUSH
23563: LD_INT 29
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: PUSH
23570: LD_INT 30
23572: PUSH
23573: LD_INT 30
23575: PUSH
23576: EMPTY
23577: LIST
23578: LIST
23579: PUSH
23580: EMPTY
23581: LIST
23582: LIST
23583: LIST
23584: PPUSH
23585: CALL_OW 72
23589: ST_TO_ADDR
// if tmp then
23590: LD_VAR 0 19
23594: IFFALSE 23642
// for i in tmp do
23596: LD_ADDR_VAR 0 8
23600: PUSH
23601: LD_VAR 0 19
23605: PUSH
23606: FOR_IN
23607: IFFALSE 23640
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23609: LD_VAR 0 8
23613: PPUSH
23614: CALL_OW 250
23618: PPUSH
23619: LD_VAR 0 8
23623: PPUSH
23624: CALL_OW 251
23628: PPUSH
23629: LD_VAR 0 16
23633: PPUSH
23634: CALL_OW 441
23638: GO 23606
23640: POP
23641: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23642: LD_VAR 0 18
23646: PPUSH
23647: LD_INT 2
23649: PUSH
23650: LD_INT 30
23652: PUSH
23653: LD_INT 32
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: LD_INT 30
23662: PUSH
23663: LD_INT 33
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: LIST
23674: PPUSH
23675: CALL_OW 72
23679: IFFALSE 23767
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23681: LD_ADDR_VAR 0 8
23685: PUSH
23686: LD_VAR 0 18
23690: PPUSH
23691: LD_INT 2
23693: PUSH
23694: LD_INT 30
23696: PUSH
23697: LD_INT 32
23699: PUSH
23700: EMPTY
23701: LIST
23702: LIST
23703: PUSH
23704: LD_INT 30
23706: PUSH
23707: LD_INT 33
23709: PUSH
23710: EMPTY
23711: LIST
23712: LIST
23713: PUSH
23714: EMPTY
23715: LIST
23716: LIST
23717: LIST
23718: PPUSH
23719: CALL_OW 72
23723: PUSH
23724: FOR_IN
23725: IFFALSE 23765
// begin if not GetBWeapon ( i ) then
23727: LD_VAR 0 8
23731: PPUSH
23732: CALL_OW 269
23736: NOT
23737: IFFALSE 23763
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23739: LD_VAR 0 8
23743: PPUSH
23744: LD_VAR 0 8
23748: PPUSH
23749: LD_VAR 0 2
23753: PPUSH
23754: CALL 25013 0 2
23758: PPUSH
23759: CALL_OW 431
// end ;
23763: GO 23724
23765: POP
23766: POP
// end ; for i = 1 to personel do
23767: LD_ADDR_VAR 0 8
23771: PUSH
23772: DOUBLE
23773: LD_INT 1
23775: DEC
23776: ST_TO_ADDR
23777: LD_VAR 0 6
23781: PUSH
23782: FOR_TO
23783: IFFALSE 24847
// begin if i > 4 then
23785: LD_VAR 0 8
23789: PUSH
23790: LD_INT 4
23792: GREATER
23793: IFFALSE 23797
// break ;
23795: GO 24847
// case i of 1 :
23797: LD_VAR 0 8
23801: PUSH
23802: LD_INT 1
23804: DOUBLE
23805: EQUAL
23806: IFTRUE 23810
23808: GO 23890
23810: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23811: LD_ADDR_VAR 0 12
23815: PUSH
23816: LD_VAR 0 18
23820: PPUSH
23821: LD_INT 22
23823: PUSH
23824: LD_VAR 0 16
23828: PUSH
23829: EMPTY
23830: LIST
23831: LIST
23832: PUSH
23833: LD_INT 58
23835: PUSH
23836: EMPTY
23837: LIST
23838: PUSH
23839: LD_INT 2
23841: PUSH
23842: LD_INT 30
23844: PUSH
23845: LD_INT 32
23847: PUSH
23848: EMPTY
23849: LIST
23850: LIST
23851: PUSH
23852: LD_INT 30
23854: PUSH
23855: LD_INT 4
23857: PUSH
23858: EMPTY
23859: LIST
23860: LIST
23861: PUSH
23862: LD_INT 30
23864: PUSH
23865: LD_INT 5
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: LIST
23876: LIST
23877: PUSH
23878: EMPTY
23879: LIST
23880: LIST
23881: LIST
23882: PPUSH
23883: CALL_OW 72
23887: ST_TO_ADDR
23888: GO 24112
23890: LD_INT 2
23892: DOUBLE
23893: EQUAL
23894: IFTRUE 23898
23896: GO 23960
23898: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23899: LD_ADDR_VAR 0 12
23903: PUSH
23904: LD_VAR 0 18
23908: PPUSH
23909: LD_INT 22
23911: PUSH
23912: LD_VAR 0 16
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: PUSH
23921: LD_INT 2
23923: PUSH
23924: LD_INT 30
23926: PUSH
23927: LD_INT 0
23929: PUSH
23930: EMPTY
23931: LIST
23932: LIST
23933: PUSH
23934: LD_INT 30
23936: PUSH
23937: LD_INT 1
23939: PUSH
23940: EMPTY
23941: LIST
23942: LIST
23943: PUSH
23944: EMPTY
23945: LIST
23946: LIST
23947: LIST
23948: PUSH
23949: EMPTY
23950: LIST
23951: LIST
23952: PPUSH
23953: CALL_OW 72
23957: ST_TO_ADDR
23958: GO 24112
23960: LD_INT 3
23962: DOUBLE
23963: EQUAL
23964: IFTRUE 23968
23966: GO 24030
23968: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23969: LD_ADDR_VAR 0 12
23973: PUSH
23974: LD_VAR 0 18
23978: PPUSH
23979: LD_INT 22
23981: PUSH
23982: LD_VAR 0 16
23986: PUSH
23987: EMPTY
23988: LIST
23989: LIST
23990: PUSH
23991: LD_INT 2
23993: PUSH
23994: LD_INT 30
23996: PUSH
23997: LD_INT 2
23999: PUSH
24000: EMPTY
24001: LIST
24002: LIST
24003: PUSH
24004: LD_INT 30
24006: PUSH
24007: LD_INT 3
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: EMPTY
24015: LIST
24016: LIST
24017: LIST
24018: PUSH
24019: EMPTY
24020: LIST
24021: LIST
24022: PPUSH
24023: CALL_OW 72
24027: ST_TO_ADDR
24028: GO 24112
24030: LD_INT 4
24032: DOUBLE
24033: EQUAL
24034: IFTRUE 24038
24036: GO 24111
24038: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24039: LD_ADDR_VAR 0 12
24043: PUSH
24044: LD_VAR 0 18
24048: PPUSH
24049: LD_INT 22
24051: PUSH
24052: LD_VAR 0 16
24056: PUSH
24057: EMPTY
24058: LIST
24059: LIST
24060: PUSH
24061: LD_INT 2
24063: PUSH
24064: LD_INT 30
24066: PUSH
24067: LD_INT 6
24069: PUSH
24070: EMPTY
24071: LIST
24072: LIST
24073: PUSH
24074: LD_INT 30
24076: PUSH
24077: LD_INT 7
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: PUSH
24084: LD_INT 30
24086: PUSH
24087: LD_INT 8
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: LIST
24098: LIST
24099: PUSH
24100: EMPTY
24101: LIST
24102: LIST
24103: PPUSH
24104: CALL_OW 72
24108: ST_TO_ADDR
24109: GO 24112
24111: POP
// if i = 1 then
24112: LD_VAR 0 8
24116: PUSH
24117: LD_INT 1
24119: EQUAL
24120: IFFALSE 24231
// begin tmp := [ ] ;
24122: LD_ADDR_VAR 0 19
24126: PUSH
24127: EMPTY
24128: ST_TO_ADDR
// for j in f do
24129: LD_ADDR_VAR 0 9
24133: PUSH
24134: LD_VAR 0 12
24138: PUSH
24139: FOR_IN
24140: IFFALSE 24213
// if GetBType ( j ) = b_bunker then
24142: LD_VAR 0 9
24146: PPUSH
24147: CALL_OW 266
24151: PUSH
24152: LD_INT 32
24154: EQUAL
24155: IFFALSE 24182
// tmp := Insert ( tmp , 1 , j ) else
24157: LD_ADDR_VAR 0 19
24161: PUSH
24162: LD_VAR 0 19
24166: PPUSH
24167: LD_INT 1
24169: PPUSH
24170: LD_VAR 0 9
24174: PPUSH
24175: CALL_OW 2
24179: ST_TO_ADDR
24180: GO 24211
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24182: LD_ADDR_VAR 0 19
24186: PUSH
24187: LD_VAR 0 19
24191: PPUSH
24192: LD_VAR 0 19
24196: PUSH
24197: LD_INT 1
24199: PLUS
24200: PPUSH
24201: LD_VAR 0 9
24205: PPUSH
24206: CALL_OW 2
24210: ST_TO_ADDR
24211: GO 24139
24213: POP
24214: POP
// if tmp then
24215: LD_VAR 0 19
24219: IFFALSE 24231
// f := tmp ;
24221: LD_ADDR_VAR 0 12
24225: PUSH
24226: LD_VAR 0 19
24230: ST_TO_ADDR
// end ; x := personel [ i ] ;
24231: LD_ADDR_VAR 0 13
24235: PUSH
24236: LD_VAR 0 6
24240: PUSH
24241: LD_VAR 0 8
24245: ARRAY
24246: ST_TO_ADDR
// if x = - 1 then
24247: LD_VAR 0 13
24251: PUSH
24252: LD_INT 1
24254: NEG
24255: EQUAL
24256: IFFALSE 24465
// begin for j in f do
24258: LD_ADDR_VAR 0 9
24262: PUSH
24263: LD_VAR 0 12
24267: PUSH
24268: FOR_IN
24269: IFFALSE 24461
// repeat InitHc ;
24271: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24275: LD_VAR 0 9
24279: PPUSH
24280: CALL_OW 266
24284: PUSH
24285: LD_INT 5
24287: EQUAL
24288: IFFALSE 24358
// begin if UnitsInside ( j ) < 3 then
24290: LD_VAR 0 9
24294: PPUSH
24295: CALL_OW 313
24299: PUSH
24300: LD_INT 3
24302: LESS
24303: IFFALSE 24339
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24305: LD_INT 0
24307: PPUSH
24308: LD_INT 5
24310: PUSH
24311: LD_INT 8
24313: PUSH
24314: LD_INT 9
24316: PUSH
24317: EMPTY
24318: LIST
24319: LIST
24320: LIST
24321: PUSH
24322: LD_VAR 0 17
24326: ARRAY
24327: PPUSH
24328: LD_VAR 0 4
24332: PPUSH
24333: CALL_OW 380
24337: GO 24356
// PrepareHuman ( false , i , skill ) ;
24339: LD_INT 0
24341: PPUSH
24342: LD_VAR 0 8
24346: PPUSH
24347: LD_VAR 0 4
24351: PPUSH
24352: CALL_OW 380
// end else
24356: GO 24375
// PrepareHuman ( false , i , skill ) ;
24358: LD_INT 0
24360: PPUSH
24361: LD_VAR 0 8
24365: PPUSH
24366: LD_VAR 0 4
24370: PPUSH
24371: CALL_OW 380
// un := CreateHuman ;
24375: LD_ADDR_VAR 0 14
24379: PUSH
24380: CALL_OW 44
24384: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24385: LD_ADDR_VAR 0 7
24389: PUSH
24390: LD_VAR 0 7
24394: PPUSH
24395: LD_INT 1
24397: PPUSH
24398: LD_VAR 0 14
24402: PPUSH
24403: CALL_OW 2
24407: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24408: LD_VAR 0 14
24412: PPUSH
24413: LD_VAR 0 9
24417: PPUSH
24418: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24422: LD_VAR 0 9
24426: PPUSH
24427: CALL_OW 313
24431: PUSH
24432: LD_INT 6
24434: EQUAL
24435: PUSH
24436: LD_VAR 0 9
24440: PPUSH
24441: CALL_OW 266
24445: PUSH
24446: LD_INT 32
24448: PUSH
24449: LD_INT 31
24451: PUSH
24452: EMPTY
24453: LIST
24454: LIST
24455: IN
24456: OR
24457: IFFALSE 24271
24459: GO 24268
24461: POP
24462: POP
// end else
24463: GO 24845
// for j = 1 to x do
24465: LD_ADDR_VAR 0 9
24469: PUSH
24470: DOUBLE
24471: LD_INT 1
24473: DEC
24474: ST_TO_ADDR
24475: LD_VAR 0 13
24479: PUSH
24480: FOR_TO
24481: IFFALSE 24843
// begin InitHc ;
24483: CALL_OW 19
// if not f then
24487: LD_VAR 0 12
24491: NOT
24492: IFFALSE 24581
// begin PrepareHuman ( false , i , skill ) ;
24494: LD_INT 0
24496: PPUSH
24497: LD_VAR 0 8
24501: PPUSH
24502: LD_VAR 0 4
24506: PPUSH
24507: CALL_OW 380
// un := CreateHuman ;
24511: LD_ADDR_VAR 0 14
24515: PUSH
24516: CALL_OW 44
24520: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24521: LD_ADDR_VAR 0 7
24525: PUSH
24526: LD_VAR 0 7
24530: PPUSH
24531: LD_INT 1
24533: PPUSH
24534: LD_VAR 0 14
24538: PPUSH
24539: CALL_OW 2
24543: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24544: LD_VAR 0 14
24548: PPUSH
24549: LD_VAR 0 1
24553: PPUSH
24554: CALL_OW 250
24558: PPUSH
24559: LD_VAR 0 1
24563: PPUSH
24564: CALL_OW 251
24568: PPUSH
24569: LD_INT 10
24571: PPUSH
24572: LD_INT 0
24574: PPUSH
24575: CALL_OW 50
// continue ;
24579: GO 24480
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24581: LD_VAR 0 12
24585: PUSH
24586: LD_INT 1
24588: ARRAY
24589: PPUSH
24590: CALL_OW 313
24594: PUSH
24595: LD_VAR 0 12
24599: PUSH
24600: LD_INT 1
24602: ARRAY
24603: PPUSH
24604: CALL_OW 266
24608: PUSH
24609: LD_INT 32
24611: PUSH
24612: LD_INT 31
24614: PUSH
24615: EMPTY
24616: LIST
24617: LIST
24618: IN
24619: AND
24620: PUSH
24621: LD_VAR 0 12
24625: PUSH
24626: LD_INT 1
24628: ARRAY
24629: PPUSH
24630: CALL_OW 313
24634: PUSH
24635: LD_INT 6
24637: EQUAL
24638: OR
24639: IFFALSE 24659
// f := Delete ( f , 1 ) ;
24641: LD_ADDR_VAR 0 12
24645: PUSH
24646: LD_VAR 0 12
24650: PPUSH
24651: LD_INT 1
24653: PPUSH
24654: CALL_OW 3
24658: ST_TO_ADDR
// if not f then
24659: LD_VAR 0 12
24663: NOT
24664: IFFALSE 24682
// begin x := x + 2 ;
24666: LD_ADDR_VAR 0 13
24670: PUSH
24671: LD_VAR 0 13
24675: PUSH
24676: LD_INT 2
24678: PLUS
24679: ST_TO_ADDR
// continue ;
24680: GO 24480
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24682: LD_VAR 0 12
24686: PUSH
24687: LD_INT 1
24689: ARRAY
24690: PPUSH
24691: CALL_OW 266
24695: PUSH
24696: LD_INT 5
24698: EQUAL
24699: IFFALSE 24773
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24701: LD_VAR 0 12
24705: PUSH
24706: LD_INT 1
24708: ARRAY
24709: PPUSH
24710: CALL_OW 313
24714: PUSH
24715: LD_INT 3
24717: LESS
24718: IFFALSE 24754
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24720: LD_INT 0
24722: PPUSH
24723: LD_INT 5
24725: PUSH
24726: LD_INT 8
24728: PUSH
24729: LD_INT 9
24731: PUSH
24732: EMPTY
24733: LIST
24734: LIST
24735: LIST
24736: PUSH
24737: LD_VAR 0 17
24741: ARRAY
24742: PPUSH
24743: LD_VAR 0 4
24747: PPUSH
24748: CALL_OW 380
24752: GO 24771
// PrepareHuman ( false , i , skill ) ;
24754: LD_INT 0
24756: PPUSH
24757: LD_VAR 0 8
24761: PPUSH
24762: LD_VAR 0 4
24766: PPUSH
24767: CALL_OW 380
// end else
24771: GO 24790
// PrepareHuman ( false , i , skill ) ;
24773: LD_INT 0
24775: PPUSH
24776: LD_VAR 0 8
24780: PPUSH
24781: LD_VAR 0 4
24785: PPUSH
24786: CALL_OW 380
// un := CreateHuman ;
24790: LD_ADDR_VAR 0 14
24794: PUSH
24795: CALL_OW 44
24799: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24800: LD_ADDR_VAR 0 7
24804: PUSH
24805: LD_VAR 0 7
24809: PPUSH
24810: LD_INT 1
24812: PPUSH
24813: LD_VAR 0 14
24817: PPUSH
24818: CALL_OW 2
24822: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24823: LD_VAR 0 14
24827: PPUSH
24828: LD_VAR 0 12
24832: PUSH
24833: LD_INT 1
24835: ARRAY
24836: PPUSH
24837: CALL_OW 52
// end ;
24841: GO 24480
24843: POP
24844: POP
// end ;
24845: GO 23782
24847: POP
24848: POP
// result := result ^ buildings ;
24849: LD_ADDR_VAR 0 7
24853: PUSH
24854: LD_VAR 0 7
24858: PUSH
24859: LD_VAR 0 18
24863: ADD
24864: ST_TO_ADDR
// end else
24865: GO 25008
// begin for i = 1 to personel do
24867: LD_ADDR_VAR 0 8
24871: PUSH
24872: DOUBLE
24873: LD_INT 1
24875: DEC
24876: ST_TO_ADDR
24877: LD_VAR 0 6
24881: PUSH
24882: FOR_TO
24883: IFFALSE 25006
// begin if i > 4 then
24885: LD_VAR 0 8
24889: PUSH
24890: LD_INT 4
24892: GREATER
24893: IFFALSE 24897
// break ;
24895: GO 25006
// x := personel [ i ] ;
24897: LD_ADDR_VAR 0 13
24901: PUSH
24902: LD_VAR 0 6
24906: PUSH
24907: LD_VAR 0 8
24911: ARRAY
24912: ST_TO_ADDR
// if x = - 1 then
24913: LD_VAR 0 13
24917: PUSH
24918: LD_INT 1
24920: NEG
24921: EQUAL
24922: IFFALSE 24926
// continue ;
24924: GO 24882
// PrepareHuman ( false , i , skill ) ;
24926: LD_INT 0
24928: PPUSH
24929: LD_VAR 0 8
24933: PPUSH
24934: LD_VAR 0 4
24938: PPUSH
24939: CALL_OW 380
// un := CreateHuman ;
24943: LD_ADDR_VAR 0 14
24947: PUSH
24948: CALL_OW 44
24952: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24953: LD_VAR 0 14
24957: PPUSH
24958: LD_VAR 0 1
24962: PPUSH
24963: CALL_OW 250
24967: PPUSH
24968: LD_VAR 0 1
24972: PPUSH
24973: CALL_OW 251
24977: PPUSH
24978: LD_INT 10
24980: PPUSH
24981: LD_INT 0
24983: PPUSH
24984: CALL_OW 50
// result := result ^ un ;
24988: LD_ADDR_VAR 0 7
24992: PUSH
24993: LD_VAR 0 7
24997: PUSH
24998: LD_VAR 0 14
25002: ADD
25003: ST_TO_ADDR
// end ;
25004: GO 24882
25006: POP
25007: POP
// end ; end ;
25008: LD_VAR 0 7
25012: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25013: LD_INT 0
25015: PPUSH
25016: PPUSH
25017: PPUSH
25018: PPUSH
25019: PPUSH
25020: PPUSH
25021: PPUSH
25022: PPUSH
25023: PPUSH
25024: PPUSH
25025: PPUSH
25026: PPUSH
25027: PPUSH
25028: PPUSH
25029: PPUSH
25030: PPUSH
// result := false ;
25031: LD_ADDR_VAR 0 3
25035: PUSH
25036: LD_INT 0
25038: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25039: LD_VAR 0 1
25043: NOT
25044: PUSH
25045: LD_VAR 0 1
25049: PPUSH
25050: CALL_OW 266
25054: PUSH
25055: LD_INT 32
25057: PUSH
25058: LD_INT 33
25060: PUSH
25061: EMPTY
25062: LIST
25063: LIST
25064: IN
25065: NOT
25066: OR
25067: IFFALSE 25071
// exit ;
25069: GO 26180
// nat := GetNation ( tower ) ;
25071: LD_ADDR_VAR 0 12
25075: PUSH
25076: LD_VAR 0 1
25080: PPUSH
25081: CALL_OW 248
25085: ST_TO_ADDR
// side := GetSide ( tower ) ;
25086: LD_ADDR_VAR 0 16
25090: PUSH
25091: LD_VAR 0 1
25095: PPUSH
25096: CALL_OW 255
25100: ST_TO_ADDR
// x := GetX ( tower ) ;
25101: LD_ADDR_VAR 0 10
25105: PUSH
25106: LD_VAR 0 1
25110: PPUSH
25111: CALL_OW 250
25115: ST_TO_ADDR
// y := GetY ( tower ) ;
25116: LD_ADDR_VAR 0 11
25120: PUSH
25121: LD_VAR 0 1
25125: PPUSH
25126: CALL_OW 251
25130: ST_TO_ADDR
// if not x or not y then
25131: LD_VAR 0 10
25135: NOT
25136: PUSH
25137: LD_VAR 0 11
25141: NOT
25142: OR
25143: IFFALSE 25147
// exit ;
25145: GO 26180
// weapon := 0 ;
25147: LD_ADDR_VAR 0 18
25151: PUSH
25152: LD_INT 0
25154: ST_TO_ADDR
// fac_list := [ ] ;
25155: LD_ADDR_VAR 0 17
25159: PUSH
25160: EMPTY
25161: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
25162: LD_ADDR_VAR 0 6
25166: PUSH
25167: LD_VAR 0 1
25171: PPUSH
25172: CALL_OW 274
25176: PPUSH
25177: LD_VAR 0 2
25181: PPUSH
25182: LD_INT 0
25184: PPUSH
25185: CALL 22751 0 3
25189: PPUSH
25190: LD_INT 30
25192: PUSH
25193: LD_INT 3
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PPUSH
25200: CALL_OW 72
25204: ST_TO_ADDR
// if not factories then
25205: LD_VAR 0 6
25209: NOT
25210: IFFALSE 25214
// exit ;
25212: GO 26180
// for i in factories do
25214: LD_ADDR_VAR 0 8
25218: PUSH
25219: LD_VAR 0 6
25223: PUSH
25224: FOR_IN
25225: IFFALSE 25250
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25227: LD_ADDR_VAR 0 17
25231: PUSH
25232: LD_VAR 0 17
25236: PUSH
25237: LD_VAR 0 8
25241: PPUSH
25242: CALL_OW 478
25246: UNION
25247: ST_TO_ADDR
25248: GO 25224
25250: POP
25251: POP
// if not fac_list then
25252: LD_VAR 0 17
25256: NOT
25257: IFFALSE 25261
// exit ;
25259: GO 26180
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25261: LD_ADDR_VAR 0 5
25265: PUSH
25266: LD_INT 4
25268: PUSH
25269: LD_INT 5
25271: PUSH
25272: LD_INT 9
25274: PUSH
25275: LD_INT 10
25277: PUSH
25278: LD_INT 6
25280: PUSH
25281: LD_INT 7
25283: PUSH
25284: LD_INT 11
25286: PUSH
25287: EMPTY
25288: LIST
25289: LIST
25290: LIST
25291: LIST
25292: LIST
25293: LIST
25294: LIST
25295: PUSH
25296: LD_INT 27
25298: PUSH
25299: LD_INT 28
25301: PUSH
25302: LD_INT 26
25304: PUSH
25305: LD_INT 30
25307: PUSH
25308: EMPTY
25309: LIST
25310: LIST
25311: LIST
25312: LIST
25313: PUSH
25314: LD_INT 43
25316: PUSH
25317: LD_INT 44
25319: PUSH
25320: LD_INT 46
25322: PUSH
25323: LD_INT 45
25325: PUSH
25326: LD_INT 47
25328: PUSH
25329: LD_INT 49
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: LIST
25336: LIST
25337: LIST
25338: LIST
25339: PUSH
25340: EMPTY
25341: LIST
25342: LIST
25343: LIST
25344: PUSH
25345: LD_VAR 0 12
25349: ARRAY
25350: ST_TO_ADDR
// list := list isect fac_list ;
25351: LD_ADDR_VAR 0 5
25355: PUSH
25356: LD_VAR 0 5
25360: PUSH
25361: LD_VAR 0 17
25365: ISECT
25366: ST_TO_ADDR
// if not list then
25367: LD_VAR 0 5
25371: NOT
25372: IFFALSE 25376
// exit ;
25374: GO 26180
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25376: LD_VAR 0 12
25380: PUSH
25381: LD_INT 3
25383: EQUAL
25384: PUSH
25385: LD_INT 49
25387: PUSH
25388: LD_VAR 0 5
25392: IN
25393: AND
25394: PUSH
25395: LD_INT 31
25397: PPUSH
25398: LD_VAR 0 16
25402: PPUSH
25403: CALL_OW 321
25407: PUSH
25408: LD_INT 2
25410: EQUAL
25411: AND
25412: IFFALSE 25472
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25414: LD_INT 22
25416: PUSH
25417: LD_VAR 0 16
25421: PUSH
25422: EMPTY
25423: LIST
25424: LIST
25425: PUSH
25426: LD_INT 35
25428: PUSH
25429: LD_INT 49
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: PUSH
25436: LD_INT 91
25438: PUSH
25439: LD_VAR 0 1
25443: PUSH
25444: LD_INT 10
25446: PUSH
25447: EMPTY
25448: LIST
25449: LIST
25450: LIST
25451: PUSH
25452: EMPTY
25453: LIST
25454: LIST
25455: LIST
25456: PPUSH
25457: CALL_OW 69
25461: NOT
25462: IFFALSE 25472
// weapon := ru_time_lapser ;
25464: LD_ADDR_VAR 0 18
25468: PUSH
25469: LD_INT 49
25471: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25472: LD_VAR 0 12
25476: PUSH
25477: LD_INT 1
25479: PUSH
25480: LD_INT 2
25482: PUSH
25483: EMPTY
25484: LIST
25485: LIST
25486: IN
25487: PUSH
25488: LD_INT 11
25490: PUSH
25491: LD_VAR 0 5
25495: IN
25496: PUSH
25497: LD_INT 30
25499: PUSH
25500: LD_VAR 0 5
25504: IN
25505: OR
25506: AND
25507: PUSH
25508: LD_INT 6
25510: PPUSH
25511: LD_VAR 0 16
25515: PPUSH
25516: CALL_OW 321
25520: PUSH
25521: LD_INT 2
25523: EQUAL
25524: AND
25525: IFFALSE 25690
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25527: LD_INT 22
25529: PUSH
25530: LD_VAR 0 16
25534: PUSH
25535: EMPTY
25536: LIST
25537: LIST
25538: PUSH
25539: LD_INT 2
25541: PUSH
25542: LD_INT 35
25544: PUSH
25545: LD_INT 11
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: PUSH
25552: LD_INT 35
25554: PUSH
25555: LD_INT 30
25557: PUSH
25558: EMPTY
25559: LIST
25560: LIST
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: LIST
25566: PUSH
25567: LD_INT 91
25569: PUSH
25570: LD_VAR 0 1
25574: PUSH
25575: LD_INT 18
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: LIST
25582: PUSH
25583: EMPTY
25584: LIST
25585: LIST
25586: LIST
25587: PPUSH
25588: CALL_OW 69
25592: NOT
25593: PUSH
25594: LD_INT 22
25596: PUSH
25597: LD_VAR 0 16
25601: PUSH
25602: EMPTY
25603: LIST
25604: LIST
25605: PUSH
25606: LD_INT 2
25608: PUSH
25609: LD_INT 30
25611: PUSH
25612: LD_INT 32
25614: PUSH
25615: EMPTY
25616: LIST
25617: LIST
25618: PUSH
25619: LD_INT 30
25621: PUSH
25622: LD_INT 33
25624: PUSH
25625: EMPTY
25626: LIST
25627: LIST
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: LIST
25633: PUSH
25634: LD_INT 91
25636: PUSH
25637: LD_VAR 0 1
25641: PUSH
25642: LD_INT 12
25644: PUSH
25645: EMPTY
25646: LIST
25647: LIST
25648: LIST
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: LIST
25654: PUSH
25655: EMPTY
25656: LIST
25657: PPUSH
25658: CALL_OW 69
25662: PUSH
25663: LD_INT 2
25665: GREATER
25666: AND
25667: IFFALSE 25690
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25669: LD_ADDR_VAR 0 18
25673: PUSH
25674: LD_INT 11
25676: PUSH
25677: LD_INT 30
25679: PUSH
25680: EMPTY
25681: LIST
25682: LIST
25683: PUSH
25684: LD_VAR 0 12
25688: ARRAY
25689: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25690: LD_VAR 0 18
25694: NOT
25695: PUSH
25696: LD_INT 40
25698: PPUSH
25699: LD_VAR 0 16
25703: PPUSH
25704: CALL_OW 321
25708: PUSH
25709: LD_INT 2
25711: EQUAL
25712: AND
25713: PUSH
25714: LD_INT 7
25716: PUSH
25717: LD_VAR 0 5
25721: IN
25722: PUSH
25723: LD_INT 28
25725: PUSH
25726: LD_VAR 0 5
25730: IN
25731: OR
25732: PUSH
25733: LD_INT 45
25735: PUSH
25736: LD_VAR 0 5
25740: IN
25741: OR
25742: AND
25743: IFFALSE 25997
// begin hex := GetHexInfo ( x , y ) ;
25745: LD_ADDR_VAR 0 4
25749: PUSH
25750: LD_VAR 0 10
25754: PPUSH
25755: LD_VAR 0 11
25759: PPUSH
25760: CALL_OW 546
25764: ST_TO_ADDR
// if hex [ 1 ] then
25765: LD_VAR 0 4
25769: PUSH
25770: LD_INT 1
25772: ARRAY
25773: IFFALSE 25777
// exit ;
25775: GO 26180
// height := hex [ 2 ] ;
25777: LD_ADDR_VAR 0 15
25781: PUSH
25782: LD_VAR 0 4
25786: PUSH
25787: LD_INT 2
25789: ARRAY
25790: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25791: LD_ADDR_VAR 0 14
25795: PUSH
25796: LD_INT 0
25798: PUSH
25799: LD_INT 2
25801: PUSH
25802: LD_INT 3
25804: PUSH
25805: LD_INT 5
25807: PUSH
25808: EMPTY
25809: LIST
25810: LIST
25811: LIST
25812: LIST
25813: ST_TO_ADDR
// for i in tmp do
25814: LD_ADDR_VAR 0 8
25818: PUSH
25819: LD_VAR 0 14
25823: PUSH
25824: FOR_IN
25825: IFFALSE 25995
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25827: LD_ADDR_VAR 0 9
25831: PUSH
25832: LD_VAR 0 10
25836: PPUSH
25837: LD_VAR 0 8
25841: PPUSH
25842: LD_INT 5
25844: PPUSH
25845: CALL_OW 272
25849: PUSH
25850: LD_VAR 0 11
25854: PPUSH
25855: LD_VAR 0 8
25859: PPUSH
25860: LD_INT 5
25862: PPUSH
25863: CALL_OW 273
25867: PUSH
25868: EMPTY
25869: LIST
25870: LIST
25871: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25872: LD_VAR 0 9
25876: PUSH
25877: LD_INT 1
25879: ARRAY
25880: PPUSH
25881: LD_VAR 0 9
25885: PUSH
25886: LD_INT 2
25888: ARRAY
25889: PPUSH
25890: CALL_OW 488
25894: IFFALSE 25993
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25896: LD_ADDR_VAR 0 4
25900: PUSH
25901: LD_VAR 0 9
25905: PUSH
25906: LD_INT 1
25908: ARRAY
25909: PPUSH
25910: LD_VAR 0 9
25914: PUSH
25915: LD_INT 2
25917: ARRAY
25918: PPUSH
25919: CALL_OW 546
25923: ST_TO_ADDR
// if hex [ 1 ] then
25924: LD_VAR 0 4
25928: PUSH
25929: LD_INT 1
25931: ARRAY
25932: IFFALSE 25936
// continue ;
25934: GO 25824
// h := hex [ 2 ] ;
25936: LD_ADDR_VAR 0 13
25940: PUSH
25941: LD_VAR 0 4
25945: PUSH
25946: LD_INT 2
25948: ARRAY
25949: ST_TO_ADDR
// if h + 7 < height then
25950: LD_VAR 0 13
25954: PUSH
25955: LD_INT 7
25957: PLUS
25958: PUSH
25959: LD_VAR 0 15
25963: LESS
25964: IFFALSE 25993
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25966: LD_ADDR_VAR 0 18
25970: PUSH
25971: LD_INT 7
25973: PUSH
25974: LD_INT 28
25976: PUSH
25977: LD_INT 45
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: LIST
25984: PUSH
25985: LD_VAR 0 12
25989: ARRAY
25990: ST_TO_ADDR
// break ;
25991: GO 25995
// end ; end ; end ;
25993: GO 25824
25995: POP
25996: POP
// end ; if not weapon then
25997: LD_VAR 0 18
26001: NOT
26002: IFFALSE 26062
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26004: LD_ADDR_VAR 0 5
26008: PUSH
26009: LD_VAR 0 5
26013: PUSH
26014: LD_INT 11
26016: PUSH
26017: LD_INT 30
26019: PUSH
26020: LD_INT 49
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: LIST
26027: DIFF
26028: ST_TO_ADDR
// if not list then
26029: LD_VAR 0 5
26033: NOT
26034: IFFALSE 26038
// exit ;
26036: GO 26180
// weapon := list [ rand ( 1 , list ) ] ;
26038: LD_ADDR_VAR 0 18
26042: PUSH
26043: LD_VAR 0 5
26047: PUSH
26048: LD_INT 1
26050: PPUSH
26051: LD_VAR 0 5
26055: PPUSH
26056: CALL_OW 12
26060: ARRAY
26061: ST_TO_ADDR
// end ; if weapon then
26062: LD_VAR 0 18
26066: IFFALSE 26180
// begin tmp := CostOfWeapon ( weapon ) ;
26068: LD_ADDR_VAR 0 14
26072: PUSH
26073: LD_VAR 0 18
26077: PPUSH
26078: CALL_OW 451
26082: ST_TO_ADDR
// j := GetBase ( tower ) ;
26083: LD_ADDR_VAR 0 9
26087: PUSH
26088: LD_VAR 0 1
26092: PPUSH
26093: CALL_OW 274
26097: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26098: LD_VAR 0 9
26102: PPUSH
26103: LD_INT 1
26105: PPUSH
26106: CALL_OW 275
26110: PUSH
26111: LD_VAR 0 14
26115: PUSH
26116: LD_INT 1
26118: ARRAY
26119: GREATEREQUAL
26120: PUSH
26121: LD_VAR 0 9
26125: PPUSH
26126: LD_INT 2
26128: PPUSH
26129: CALL_OW 275
26133: PUSH
26134: LD_VAR 0 14
26138: PUSH
26139: LD_INT 2
26141: ARRAY
26142: GREATEREQUAL
26143: AND
26144: PUSH
26145: LD_VAR 0 9
26149: PPUSH
26150: LD_INT 3
26152: PPUSH
26153: CALL_OW 275
26157: PUSH
26158: LD_VAR 0 14
26162: PUSH
26163: LD_INT 3
26165: ARRAY
26166: GREATEREQUAL
26167: AND
26168: IFFALSE 26180
// result := weapon ;
26170: LD_ADDR_VAR 0 3
26174: PUSH
26175: LD_VAR 0 18
26179: ST_TO_ADDR
// end ; end ;
26180: LD_VAR 0 3
26184: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26185: LD_INT 0
26187: PPUSH
26188: PPUSH
// result := true ;
26189: LD_ADDR_VAR 0 3
26193: PUSH
26194: LD_INT 1
26196: ST_TO_ADDR
// if array1 = array2 then
26197: LD_VAR 0 1
26201: PUSH
26202: LD_VAR 0 2
26206: EQUAL
26207: IFFALSE 26267
// begin for i = 1 to array1 do
26209: LD_ADDR_VAR 0 4
26213: PUSH
26214: DOUBLE
26215: LD_INT 1
26217: DEC
26218: ST_TO_ADDR
26219: LD_VAR 0 1
26223: PUSH
26224: FOR_TO
26225: IFFALSE 26263
// if array1 [ i ] <> array2 [ i ] then
26227: LD_VAR 0 1
26231: PUSH
26232: LD_VAR 0 4
26236: ARRAY
26237: PUSH
26238: LD_VAR 0 2
26242: PUSH
26243: LD_VAR 0 4
26247: ARRAY
26248: NONEQUAL
26249: IFFALSE 26261
// begin result := false ;
26251: LD_ADDR_VAR 0 3
26255: PUSH
26256: LD_INT 0
26258: ST_TO_ADDR
// break ;
26259: GO 26263
// end ;
26261: GO 26224
26263: POP
26264: POP
// end else
26265: GO 26275
// result := false ;
26267: LD_ADDR_VAR 0 3
26271: PUSH
26272: LD_INT 0
26274: ST_TO_ADDR
// end ;
26275: LD_VAR 0 3
26279: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26280: LD_INT 0
26282: PPUSH
26283: PPUSH
// if not array1 or not array2 then
26284: LD_VAR 0 1
26288: NOT
26289: PUSH
26290: LD_VAR 0 2
26294: NOT
26295: OR
26296: IFFALSE 26300
// exit ;
26298: GO 26364
// result := true ;
26300: LD_ADDR_VAR 0 3
26304: PUSH
26305: LD_INT 1
26307: ST_TO_ADDR
// for i = 1 to array1 do
26308: LD_ADDR_VAR 0 4
26312: PUSH
26313: DOUBLE
26314: LD_INT 1
26316: DEC
26317: ST_TO_ADDR
26318: LD_VAR 0 1
26322: PUSH
26323: FOR_TO
26324: IFFALSE 26362
// if array1 [ i ] <> array2 [ i ] then
26326: LD_VAR 0 1
26330: PUSH
26331: LD_VAR 0 4
26335: ARRAY
26336: PUSH
26337: LD_VAR 0 2
26341: PUSH
26342: LD_VAR 0 4
26346: ARRAY
26347: NONEQUAL
26348: IFFALSE 26360
// begin result := false ;
26350: LD_ADDR_VAR 0 3
26354: PUSH
26355: LD_INT 0
26357: ST_TO_ADDR
// break ;
26358: GO 26362
// end ;
26360: GO 26323
26362: POP
26363: POP
// end ;
26364: LD_VAR 0 3
26368: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26369: LD_INT 0
26371: PPUSH
26372: PPUSH
26373: PPUSH
// pom := GetBase ( fac ) ;
26374: LD_ADDR_VAR 0 5
26378: PUSH
26379: LD_VAR 0 1
26383: PPUSH
26384: CALL_OW 274
26388: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26389: LD_ADDR_VAR 0 4
26393: PUSH
26394: LD_VAR 0 2
26398: PUSH
26399: LD_INT 1
26401: ARRAY
26402: PPUSH
26403: LD_VAR 0 2
26407: PUSH
26408: LD_INT 2
26410: ARRAY
26411: PPUSH
26412: LD_VAR 0 2
26416: PUSH
26417: LD_INT 3
26419: ARRAY
26420: PPUSH
26421: LD_VAR 0 2
26425: PUSH
26426: LD_INT 4
26428: ARRAY
26429: PPUSH
26430: CALL_OW 449
26434: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26435: LD_ADDR_VAR 0 3
26439: PUSH
26440: LD_VAR 0 5
26444: PPUSH
26445: LD_INT 1
26447: PPUSH
26448: CALL_OW 275
26452: PUSH
26453: LD_VAR 0 4
26457: PUSH
26458: LD_INT 1
26460: ARRAY
26461: GREATEREQUAL
26462: PUSH
26463: LD_VAR 0 5
26467: PPUSH
26468: LD_INT 2
26470: PPUSH
26471: CALL_OW 275
26475: PUSH
26476: LD_VAR 0 4
26480: PUSH
26481: LD_INT 2
26483: ARRAY
26484: GREATEREQUAL
26485: AND
26486: PUSH
26487: LD_VAR 0 5
26491: PPUSH
26492: LD_INT 3
26494: PPUSH
26495: CALL_OW 275
26499: PUSH
26500: LD_VAR 0 4
26504: PUSH
26505: LD_INT 3
26507: ARRAY
26508: GREATEREQUAL
26509: AND
26510: ST_TO_ADDR
// end ;
26511: LD_VAR 0 3
26515: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26516: LD_INT 0
26518: PPUSH
26519: PPUSH
26520: PPUSH
26521: PPUSH
// pom := GetBase ( building ) ;
26522: LD_ADDR_VAR 0 3
26526: PUSH
26527: LD_VAR 0 1
26531: PPUSH
26532: CALL_OW 274
26536: ST_TO_ADDR
// if not pom then
26537: LD_VAR 0 3
26541: NOT
26542: IFFALSE 26546
// exit ;
26544: GO 26716
// btype := GetBType ( building ) ;
26546: LD_ADDR_VAR 0 5
26550: PUSH
26551: LD_VAR 0 1
26555: PPUSH
26556: CALL_OW 266
26560: ST_TO_ADDR
// if btype = b_armoury then
26561: LD_VAR 0 5
26565: PUSH
26566: LD_INT 4
26568: EQUAL
26569: IFFALSE 26579
// btype := b_barracks ;
26571: LD_ADDR_VAR 0 5
26575: PUSH
26576: LD_INT 5
26578: ST_TO_ADDR
// if btype = b_depot then
26579: LD_VAR 0 5
26583: PUSH
26584: LD_INT 0
26586: EQUAL
26587: IFFALSE 26597
// btype := b_warehouse ;
26589: LD_ADDR_VAR 0 5
26593: PUSH
26594: LD_INT 1
26596: ST_TO_ADDR
// if btype = b_workshop then
26597: LD_VAR 0 5
26601: PUSH
26602: LD_INT 2
26604: EQUAL
26605: IFFALSE 26615
// btype := b_factory ;
26607: LD_ADDR_VAR 0 5
26611: PUSH
26612: LD_INT 3
26614: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26615: LD_ADDR_VAR 0 4
26619: PUSH
26620: LD_VAR 0 5
26624: PPUSH
26625: LD_VAR 0 1
26629: PPUSH
26630: CALL_OW 248
26634: PPUSH
26635: CALL_OW 450
26639: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26640: LD_ADDR_VAR 0 2
26644: PUSH
26645: LD_VAR 0 3
26649: PPUSH
26650: LD_INT 1
26652: PPUSH
26653: CALL_OW 275
26657: PUSH
26658: LD_VAR 0 4
26662: PUSH
26663: LD_INT 1
26665: ARRAY
26666: GREATEREQUAL
26667: PUSH
26668: LD_VAR 0 3
26672: PPUSH
26673: LD_INT 2
26675: PPUSH
26676: CALL_OW 275
26680: PUSH
26681: LD_VAR 0 4
26685: PUSH
26686: LD_INT 2
26688: ARRAY
26689: GREATEREQUAL
26690: AND
26691: PUSH
26692: LD_VAR 0 3
26696: PPUSH
26697: LD_INT 3
26699: PPUSH
26700: CALL_OW 275
26704: PUSH
26705: LD_VAR 0 4
26709: PUSH
26710: LD_INT 3
26712: ARRAY
26713: GREATEREQUAL
26714: AND
26715: ST_TO_ADDR
// end ;
26716: LD_VAR 0 2
26720: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26721: LD_INT 0
26723: PPUSH
26724: PPUSH
26725: PPUSH
// pom := GetBase ( building ) ;
26726: LD_ADDR_VAR 0 4
26730: PUSH
26731: LD_VAR 0 1
26735: PPUSH
26736: CALL_OW 274
26740: ST_TO_ADDR
// if not pom then
26741: LD_VAR 0 4
26745: NOT
26746: IFFALSE 26750
// exit ;
26748: GO 26851
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26750: LD_ADDR_VAR 0 5
26754: PUSH
26755: LD_VAR 0 2
26759: PPUSH
26760: LD_VAR 0 1
26764: PPUSH
26765: CALL_OW 248
26769: PPUSH
26770: CALL_OW 450
26774: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26775: LD_ADDR_VAR 0 3
26779: PUSH
26780: LD_VAR 0 4
26784: PPUSH
26785: LD_INT 1
26787: PPUSH
26788: CALL_OW 275
26792: PUSH
26793: LD_VAR 0 5
26797: PUSH
26798: LD_INT 1
26800: ARRAY
26801: GREATEREQUAL
26802: PUSH
26803: LD_VAR 0 4
26807: PPUSH
26808: LD_INT 2
26810: PPUSH
26811: CALL_OW 275
26815: PUSH
26816: LD_VAR 0 5
26820: PUSH
26821: LD_INT 2
26823: ARRAY
26824: GREATEREQUAL
26825: AND
26826: PUSH
26827: LD_VAR 0 4
26831: PPUSH
26832: LD_INT 3
26834: PPUSH
26835: CALL_OW 275
26839: PUSH
26840: LD_VAR 0 5
26844: PUSH
26845: LD_INT 3
26847: ARRAY
26848: GREATEREQUAL
26849: AND
26850: ST_TO_ADDR
// end ;
26851: LD_VAR 0 3
26855: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26856: LD_INT 0
26858: PPUSH
26859: PPUSH
26860: PPUSH
26861: PPUSH
26862: PPUSH
26863: PPUSH
26864: PPUSH
26865: PPUSH
26866: PPUSH
26867: PPUSH
26868: PPUSH
// result := false ;
26869: LD_ADDR_VAR 0 8
26873: PUSH
26874: LD_INT 0
26876: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26877: LD_VAR 0 5
26881: NOT
26882: PUSH
26883: LD_VAR 0 1
26887: NOT
26888: OR
26889: PUSH
26890: LD_VAR 0 2
26894: NOT
26895: OR
26896: PUSH
26897: LD_VAR 0 3
26901: NOT
26902: OR
26903: IFFALSE 26907
// exit ;
26905: GO 27721
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26907: LD_ADDR_VAR 0 14
26911: PUSH
26912: LD_VAR 0 1
26916: PPUSH
26917: LD_VAR 0 2
26921: PPUSH
26922: LD_VAR 0 3
26926: PPUSH
26927: LD_VAR 0 4
26931: PPUSH
26932: LD_VAR 0 5
26936: PUSH
26937: LD_INT 1
26939: ARRAY
26940: PPUSH
26941: CALL_OW 248
26945: PPUSH
26946: LD_INT 0
26948: PPUSH
26949: CALL 28958 0 6
26953: ST_TO_ADDR
// if not hexes then
26954: LD_VAR 0 14
26958: NOT
26959: IFFALSE 26963
// exit ;
26961: GO 27721
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26963: LD_ADDR_VAR 0 17
26967: PUSH
26968: LD_VAR 0 5
26972: PPUSH
26973: LD_INT 22
26975: PUSH
26976: LD_VAR 0 13
26980: PPUSH
26981: CALL_OW 255
26985: PUSH
26986: EMPTY
26987: LIST
26988: LIST
26989: PUSH
26990: LD_INT 2
26992: PUSH
26993: LD_INT 30
26995: PUSH
26996: LD_INT 0
26998: PUSH
26999: EMPTY
27000: LIST
27001: LIST
27002: PUSH
27003: LD_INT 30
27005: PUSH
27006: LD_INT 1
27008: PUSH
27009: EMPTY
27010: LIST
27011: LIST
27012: PUSH
27013: EMPTY
27014: LIST
27015: LIST
27016: LIST
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PPUSH
27022: CALL_OW 72
27026: ST_TO_ADDR
// for i = 1 to hexes do
27027: LD_ADDR_VAR 0 9
27031: PUSH
27032: DOUBLE
27033: LD_INT 1
27035: DEC
27036: ST_TO_ADDR
27037: LD_VAR 0 14
27041: PUSH
27042: FOR_TO
27043: IFFALSE 27719
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27045: LD_ADDR_VAR 0 13
27049: PUSH
27050: LD_VAR 0 14
27054: PUSH
27055: LD_VAR 0 9
27059: ARRAY
27060: PUSH
27061: LD_INT 1
27063: ARRAY
27064: PPUSH
27065: LD_VAR 0 14
27069: PUSH
27070: LD_VAR 0 9
27074: ARRAY
27075: PUSH
27076: LD_INT 2
27078: ARRAY
27079: PPUSH
27080: CALL_OW 428
27084: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27085: LD_VAR 0 14
27089: PUSH
27090: LD_VAR 0 9
27094: ARRAY
27095: PUSH
27096: LD_INT 1
27098: ARRAY
27099: PPUSH
27100: LD_VAR 0 14
27104: PUSH
27105: LD_VAR 0 9
27109: ARRAY
27110: PUSH
27111: LD_INT 2
27113: ARRAY
27114: PPUSH
27115: CALL_OW 351
27119: PUSH
27120: LD_VAR 0 14
27124: PUSH
27125: LD_VAR 0 9
27129: ARRAY
27130: PUSH
27131: LD_INT 1
27133: ARRAY
27134: PPUSH
27135: LD_VAR 0 14
27139: PUSH
27140: LD_VAR 0 9
27144: ARRAY
27145: PUSH
27146: LD_INT 2
27148: ARRAY
27149: PPUSH
27150: CALL_OW 488
27154: NOT
27155: OR
27156: PUSH
27157: LD_VAR 0 13
27161: PPUSH
27162: CALL_OW 247
27166: PUSH
27167: LD_INT 3
27169: EQUAL
27170: OR
27171: IFFALSE 27177
// exit ;
27173: POP
27174: POP
27175: GO 27721
// if not tmp then
27177: LD_VAR 0 13
27181: NOT
27182: IFFALSE 27186
// continue ;
27184: GO 27042
// result := true ;
27186: LD_ADDR_VAR 0 8
27190: PUSH
27191: LD_INT 1
27193: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
27194: LD_VAR 0 6
27198: PUSH
27199: LD_VAR 0 13
27203: PPUSH
27204: CALL_OW 247
27208: PUSH
27209: LD_INT 2
27211: EQUAL
27212: AND
27213: PUSH
27214: LD_VAR 0 13
27218: PPUSH
27219: CALL_OW 263
27223: PUSH
27224: LD_INT 1
27226: EQUAL
27227: AND
27228: IFFALSE 27392
// begin if IsDrivenBy ( tmp ) then
27230: LD_VAR 0 13
27234: PPUSH
27235: CALL_OW 311
27239: IFFALSE 27243
// continue ;
27241: GO 27042
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27243: LD_VAR 0 6
27247: PPUSH
27248: LD_INT 3
27250: PUSH
27251: LD_INT 60
27253: PUSH
27254: EMPTY
27255: LIST
27256: PUSH
27257: EMPTY
27258: LIST
27259: LIST
27260: PUSH
27261: LD_INT 3
27263: PUSH
27264: LD_INT 55
27266: PUSH
27267: EMPTY
27268: LIST
27269: PUSH
27270: EMPTY
27271: LIST
27272: LIST
27273: PUSH
27274: EMPTY
27275: LIST
27276: LIST
27277: PPUSH
27278: CALL_OW 72
27282: IFFALSE 27390
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27284: LD_ADDR_VAR 0 18
27288: PUSH
27289: LD_VAR 0 6
27293: PPUSH
27294: LD_INT 3
27296: PUSH
27297: LD_INT 60
27299: PUSH
27300: EMPTY
27301: LIST
27302: PUSH
27303: EMPTY
27304: LIST
27305: LIST
27306: PUSH
27307: LD_INT 3
27309: PUSH
27310: LD_INT 55
27312: PUSH
27313: EMPTY
27314: LIST
27315: PUSH
27316: EMPTY
27317: LIST
27318: LIST
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PPUSH
27324: CALL_OW 72
27328: PUSH
27329: LD_INT 1
27331: ARRAY
27332: ST_TO_ADDR
// if IsInUnit ( driver ) then
27333: LD_VAR 0 18
27337: PPUSH
27338: CALL_OW 310
27342: IFFALSE 27353
// ComExit ( driver ) ;
27344: LD_VAR 0 18
27348: PPUSH
27349: CALL 52086 0 1
// AddComEnterUnit ( driver , tmp ) ;
27353: LD_VAR 0 18
27357: PPUSH
27358: LD_VAR 0 13
27362: PPUSH
27363: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27367: LD_VAR 0 18
27371: PPUSH
27372: LD_VAR 0 7
27376: PPUSH
27377: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27381: LD_VAR 0 18
27385: PPUSH
27386: CALL_OW 181
// end ; continue ;
27390: GO 27042
// end ; if not cleaners or not tmp in cleaners then
27392: LD_VAR 0 6
27396: NOT
27397: PUSH
27398: LD_VAR 0 13
27402: PUSH
27403: LD_VAR 0 6
27407: IN
27408: NOT
27409: OR
27410: IFFALSE 27717
// begin if dep then
27412: LD_VAR 0 17
27416: IFFALSE 27552
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27418: LD_ADDR_VAR 0 16
27422: PUSH
27423: LD_VAR 0 17
27427: PUSH
27428: LD_INT 1
27430: ARRAY
27431: PPUSH
27432: CALL_OW 250
27436: PPUSH
27437: LD_VAR 0 17
27441: PUSH
27442: LD_INT 1
27444: ARRAY
27445: PPUSH
27446: CALL_OW 254
27450: PPUSH
27451: LD_INT 5
27453: PPUSH
27454: CALL_OW 272
27458: PUSH
27459: LD_VAR 0 17
27463: PUSH
27464: LD_INT 1
27466: ARRAY
27467: PPUSH
27468: CALL_OW 251
27472: PPUSH
27473: LD_VAR 0 17
27477: PUSH
27478: LD_INT 1
27480: ARRAY
27481: PPUSH
27482: CALL_OW 254
27486: PPUSH
27487: LD_INT 5
27489: PPUSH
27490: CALL_OW 273
27494: PUSH
27495: EMPTY
27496: LIST
27497: LIST
27498: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27499: LD_VAR 0 16
27503: PUSH
27504: LD_INT 1
27506: ARRAY
27507: PPUSH
27508: LD_VAR 0 16
27512: PUSH
27513: LD_INT 2
27515: ARRAY
27516: PPUSH
27517: CALL_OW 488
27521: IFFALSE 27552
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27523: LD_VAR 0 13
27527: PPUSH
27528: LD_VAR 0 16
27532: PUSH
27533: LD_INT 1
27535: ARRAY
27536: PPUSH
27537: LD_VAR 0 16
27541: PUSH
27542: LD_INT 2
27544: ARRAY
27545: PPUSH
27546: CALL_OW 111
// continue ;
27550: GO 27042
// end ; end ; r := GetDir ( tmp ) ;
27552: LD_ADDR_VAR 0 15
27556: PUSH
27557: LD_VAR 0 13
27561: PPUSH
27562: CALL_OW 254
27566: ST_TO_ADDR
// if r = 5 then
27567: LD_VAR 0 15
27571: PUSH
27572: LD_INT 5
27574: EQUAL
27575: IFFALSE 27585
// r := 0 ;
27577: LD_ADDR_VAR 0 15
27581: PUSH
27582: LD_INT 0
27584: ST_TO_ADDR
// for j = r to 5 do
27585: LD_ADDR_VAR 0 10
27589: PUSH
27590: DOUBLE
27591: LD_VAR 0 15
27595: DEC
27596: ST_TO_ADDR
27597: LD_INT 5
27599: PUSH
27600: FOR_TO
27601: IFFALSE 27715
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27603: LD_ADDR_VAR 0 11
27607: PUSH
27608: LD_VAR 0 13
27612: PPUSH
27613: CALL_OW 250
27617: PPUSH
27618: LD_VAR 0 10
27622: PPUSH
27623: LD_INT 2
27625: PPUSH
27626: CALL_OW 272
27630: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27631: LD_ADDR_VAR 0 12
27635: PUSH
27636: LD_VAR 0 13
27640: PPUSH
27641: CALL_OW 251
27645: PPUSH
27646: LD_VAR 0 10
27650: PPUSH
27651: LD_INT 2
27653: PPUSH
27654: CALL_OW 273
27658: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27659: LD_VAR 0 11
27663: PPUSH
27664: LD_VAR 0 12
27668: PPUSH
27669: CALL_OW 488
27673: PUSH
27674: LD_VAR 0 11
27678: PPUSH
27679: LD_VAR 0 12
27683: PPUSH
27684: CALL_OW 428
27688: NOT
27689: AND
27690: IFFALSE 27713
// begin ComMoveXY ( tmp , _x , _y ) ;
27692: LD_VAR 0 13
27696: PPUSH
27697: LD_VAR 0 11
27701: PPUSH
27702: LD_VAR 0 12
27706: PPUSH
27707: CALL_OW 111
// break ;
27711: GO 27715
// end ; end ;
27713: GO 27600
27715: POP
27716: POP
// end ; end ;
27717: GO 27042
27719: POP
27720: POP
// end ;
27721: LD_VAR 0 8
27725: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27726: LD_INT 0
27728: PPUSH
// result := true ;
27729: LD_ADDR_VAR 0 3
27733: PUSH
27734: LD_INT 1
27736: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27737: LD_VAR 0 2
27741: PUSH
27742: LD_INT 24
27744: DOUBLE
27745: EQUAL
27746: IFTRUE 27756
27748: LD_INT 33
27750: DOUBLE
27751: EQUAL
27752: IFTRUE 27756
27754: GO 27781
27756: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27757: LD_ADDR_VAR 0 3
27761: PUSH
27762: LD_INT 32
27764: PPUSH
27765: LD_VAR 0 1
27769: PPUSH
27770: CALL_OW 321
27774: PUSH
27775: LD_INT 2
27777: EQUAL
27778: ST_TO_ADDR
27779: GO 28101
27781: LD_INT 20
27783: DOUBLE
27784: EQUAL
27785: IFTRUE 27789
27787: GO 27814
27789: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27790: LD_ADDR_VAR 0 3
27794: PUSH
27795: LD_INT 6
27797: PPUSH
27798: LD_VAR 0 1
27802: PPUSH
27803: CALL_OW 321
27807: PUSH
27808: LD_INT 2
27810: EQUAL
27811: ST_TO_ADDR
27812: GO 28101
27814: LD_INT 22
27816: DOUBLE
27817: EQUAL
27818: IFTRUE 27828
27820: LD_INT 36
27822: DOUBLE
27823: EQUAL
27824: IFTRUE 27828
27826: GO 27853
27828: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27829: LD_ADDR_VAR 0 3
27833: PUSH
27834: LD_INT 15
27836: PPUSH
27837: LD_VAR 0 1
27841: PPUSH
27842: CALL_OW 321
27846: PUSH
27847: LD_INT 2
27849: EQUAL
27850: ST_TO_ADDR
27851: GO 28101
27853: LD_INT 30
27855: DOUBLE
27856: EQUAL
27857: IFTRUE 27861
27859: GO 27886
27861: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27862: LD_ADDR_VAR 0 3
27866: PUSH
27867: LD_INT 20
27869: PPUSH
27870: LD_VAR 0 1
27874: PPUSH
27875: CALL_OW 321
27879: PUSH
27880: LD_INT 2
27882: EQUAL
27883: ST_TO_ADDR
27884: GO 28101
27886: LD_INT 28
27888: DOUBLE
27889: EQUAL
27890: IFTRUE 27900
27892: LD_INT 21
27894: DOUBLE
27895: EQUAL
27896: IFTRUE 27900
27898: GO 27925
27900: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27901: LD_ADDR_VAR 0 3
27905: PUSH
27906: LD_INT 21
27908: PPUSH
27909: LD_VAR 0 1
27913: PPUSH
27914: CALL_OW 321
27918: PUSH
27919: LD_INT 2
27921: EQUAL
27922: ST_TO_ADDR
27923: GO 28101
27925: LD_INT 16
27927: DOUBLE
27928: EQUAL
27929: IFTRUE 27933
27931: GO 27960
27933: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
27934: LD_ADDR_VAR 0 3
27938: PUSH
27939: LD_EXP 117
27943: PPUSH
27944: LD_VAR 0 1
27948: PPUSH
27949: CALL_OW 321
27953: PUSH
27954: LD_INT 2
27956: EQUAL
27957: ST_TO_ADDR
27958: GO 28101
27960: LD_INT 19
27962: DOUBLE
27963: EQUAL
27964: IFTRUE 27974
27966: LD_INT 23
27968: DOUBLE
27969: EQUAL
27970: IFTRUE 27974
27972: GO 28001
27974: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
27975: LD_ADDR_VAR 0 3
27979: PUSH
27980: LD_EXP 116
27984: PPUSH
27985: LD_VAR 0 1
27989: PPUSH
27990: CALL_OW 321
27994: PUSH
27995: LD_INT 2
27997: EQUAL
27998: ST_TO_ADDR
27999: GO 28101
28001: LD_INT 17
28003: DOUBLE
28004: EQUAL
28005: IFTRUE 28009
28007: GO 28034
28009: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
28010: LD_ADDR_VAR 0 3
28014: PUSH
28015: LD_INT 39
28017: PPUSH
28018: LD_VAR 0 1
28022: PPUSH
28023: CALL_OW 321
28027: PUSH
28028: LD_INT 2
28030: EQUAL
28031: ST_TO_ADDR
28032: GO 28101
28034: LD_INT 18
28036: DOUBLE
28037: EQUAL
28038: IFTRUE 28042
28040: GO 28067
28042: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
28043: LD_ADDR_VAR 0 3
28047: PUSH
28048: LD_INT 40
28050: PPUSH
28051: LD_VAR 0 1
28055: PPUSH
28056: CALL_OW 321
28060: PUSH
28061: LD_INT 2
28063: EQUAL
28064: ST_TO_ADDR
28065: GO 28101
28067: LD_INT 27
28069: DOUBLE
28070: EQUAL
28071: IFTRUE 28075
28073: GO 28100
28075: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
28076: LD_ADDR_VAR 0 3
28080: PUSH
28081: LD_INT 35
28083: PPUSH
28084: LD_VAR 0 1
28088: PPUSH
28089: CALL_OW 321
28093: PUSH
28094: LD_INT 2
28096: EQUAL
28097: ST_TO_ADDR
28098: GO 28101
28100: POP
// end ;
28101: LD_VAR 0 3
28105: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
28106: LD_INT 0
28108: PPUSH
28109: PPUSH
28110: PPUSH
28111: PPUSH
28112: PPUSH
28113: PPUSH
28114: PPUSH
28115: PPUSH
28116: PPUSH
28117: PPUSH
28118: PPUSH
// result := false ;
28119: LD_ADDR_VAR 0 6
28123: PUSH
28124: LD_INT 0
28126: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28127: LD_VAR 0 1
28131: NOT
28132: PUSH
28133: LD_VAR 0 1
28137: PPUSH
28138: CALL_OW 266
28142: PUSH
28143: LD_INT 0
28145: PUSH
28146: LD_INT 1
28148: PUSH
28149: EMPTY
28150: LIST
28151: LIST
28152: IN
28153: NOT
28154: OR
28155: PUSH
28156: LD_VAR 0 2
28160: NOT
28161: OR
28162: PUSH
28163: LD_VAR 0 5
28167: PUSH
28168: LD_INT 0
28170: PUSH
28171: LD_INT 1
28173: PUSH
28174: LD_INT 2
28176: PUSH
28177: LD_INT 3
28179: PUSH
28180: LD_INT 4
28182: PUSH
28183: LD_INT 5
28185: PUSH
28186: EMPTY
28187: LIST
28188: LIST
28189: LIST
28190: LIST
28191: LIST
28192: LIST
28193: IN
28194: NOT
28195: OR
28196: PUSH
28197: LD_VAR 0 3
28201: PPUSH
28202: LD_VAR 0 4
28206: PPUSH
28207: CALL_OW 488
28211: NOT
28212: OR
28213: IFFALSE 28217
// exit ;
28215: GO 28953
// side := GetSide ( depot ) ;
28217: LD_ADDR_VAR 0 9
28221: PUSH
28222: LD_VAR 0 1
28226: PPUSH
28227: CALL_OW 255
28231: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28232: LD_VAR 0 9
28236: PPUSH
28237: LD_VAR 0 2
28241: PPUSH
28242: CALL 27726 0 2
28246: NOT
28247: IFFALSE 28251
// exit ;
28249: GO 28953
// pom := GetBase ( depot ) ;
28251: LD_ADDR_VAR 0 10
28255: PUSH
28256: LD_VAR 0 1
28260: PPUSH
28261: CALL_OW 274
28265: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28266: LD_ADDR_VAR 0 11
28270: PUSH
28271: LD_VAR 0 2
28275: PPUSH
28276: LD_VAR 0 1
28280: PPUSH
28281: CALL_OW 248
28285: PPUSH
28286: CALL_OW 450
28290: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28291: LD_VAR 0 10
28295: PPUSH
28296: LD_INT 1
28298: PPUSH
28299: CALL_OW 275
28303: PUSH
28304: LD_VAR 0 11
28308: PUSH
28309: LD_INT 1
28311: ARRAY
28312: GREATEREQUAL
28313: PUSH
28314: LD_VAR 0 10
28318: PPUSH
28319: LD_INT 2
28321: PPUSH
28322: CALL_OW 275
28326: PUSH
28327: LD_VAR 0 11
28331: PUSH
28332: LD_INT 2
28334: ARRAY
28335: GREATEREQUAL
28336: AND
28337: PUSH
28338: LD_VAR 0 10
28342: PPUSH
28343: LD_INT 3
28345: PPUSH
28346: CALL_OW 275
28350: PUSH
28351: LD_VAR 0 11
28355: PUSH
28356: LD_INT 3
28358: ARRAY
28359: GREATEREQUAL
28360: AND
28361: NOT
28362: IFFALSE 28366
// exit ;
28364: GO 28953
// if GetBType ( depot ) = b_depot then
28366: LD_VAR 0 1
28370: PPUSH
28371: CALL_OW 266
28375: PUSH
28376: LD_INT 0
28378: EQUAL
28379: IFFALSE 28391
// dist := 28 else
28381: LD_ADDR_VAR 0 14
28385: PUSH
28386: LD_INT 28
28388: ST_TO_ADDR
28389: GO 28399
// dist := 36 ;
28391: LD_ADDR_VAR 0 14
28395: PUSH
28396: LD_INT 36
28398: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28399: LD_VAR 0 1
28403: PPUSH
28404: LD_VAR 0 3
28408: PPUSH
28409: LD_VAR 0 4
28413: PPUSH
28414: CALL_OW 297
28418: PUSH
28419: LD_VAR 0 14
28423: GREATER
28424: IFFALSE 28428
// exit ;
28426: GO 28953
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28428: LD_ADDR_VAR 0 12
28432: PUSH
28433: LD_VAR 0 2
28437: PPUSH
28438: LD_VAR 0 3
28442: PPUSH
28443: LD_VAR 0 4
28447: PPUSH
28448: LD_VAR 0 5
28452: PPUSH
28453: LD_VAR 0 1
28457: PPUSH
28458: CALL_OW 248
28462: PPUSH
28463: LD_INT 0
28465: PPUSH
28466: CALL 28958 0 6
28470: ST_TO_ADDR
// if not hexes then
28471: LD_VAR 0 12
28475: NOT
28476: IFFALSE 28480
// exit ;
28478: GO 28953
// hex := GetHexInfo ( x , y ) ;
28480: LD_ADDR_VAR 0 15
28484: PUSH
28485: LD_VAR 0 3
28489: PPUSH
28490: LD_VAR 0 4
28494: PPUSH
28495: CALL_OW 546
28499: ST_TO_ADDR
// if hex [ 1 ] then
28500: LD_VAR 0 15
28504: PUSH
28505: LD_INT 1
28507: ARRAY
28508: IFFALSE 28512
// exit ;
28510: GO 28953
// height := hex [ 2 ] ;
28512: LD_ADDR_VAR 0 13
28516: PUSH
28517: LD_VAR 0 15
28521: PUSH
28522: LD_INT 2
28524: ARRAY
28525: ST_TO_ADDR
// for i = 1 to hexes do
28526: LD_ADDR_VAR 0 7
28530: PUSH
28531: DOUBLE
28532: LD_INT 1
28534: DEC
28535: ST_TO_ADDR
28536: LD_VAR 0 12
28540: PUSH
28541: FOR_TO
28542: IFFALSE 28872
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28544: LD_VAR 0 12
28548: PUSH
28549: LD_VAR 0 7
28553: ARRAY
28554: PUSH
28555: LD_INT 1
28557: ARRAY
28558: PPUSH
28559: LD_VAR 0 12
28563: PUSH
28564: LD_VAR 0 7
28568: ARRAY
28569: PUSH
28570: LD_INT 2
28572: ARRAY
28573: PPUSH
28574: CALL_OW 488
28578: NOT
28579: PUSH
28580: LD_VAR 0 12
28584: PUSH
28585: LD_VAR 0 7
28589: ARRAY
28590: PUSH
28591: LD_INT 1
28593: ARRAY
28594: PPUSH
28595: LD_VAR 0 12
28599: PUSH
28600: LD_VAR 0 7
28604: ARRAY
28605: PUSH
28606: LD_INT 2
28608: ARRAY
28609: PPUSH
28610: CALL_OW 428
28614: PUSH
28615: LD_INT 0
28617: GREATER
28618: OR
28619: PUSH
28620: LD_VAR 0 12
28624: PUSH
28625: LD_VAR 0 7
28629: ARRAY
28630: PUSH
28631: LD_INT 1
28633: ARRAY
28634: PPUSH
28635: LD_VAR 0 12
28639: PUSH
28640: LD_VAR 0 7
28644: ARRAY
28645: PUSH
28646: LD_INT 2
28648: ARRAY
28649: PPUSH
28650: CALL_OW 351
28654: OR
28655: IFFALSE 28661
// exit ;
28657: POP
28658: POP
28659: GO 28953
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28661: LD_ADDR_VAR 0 8
28665: PUSH
28666: LD_VAR 0 12
28670: PUSH
28671: LD_VAR 0 7
28675: ARRAY
28676: PUSH
28677: LD_INT 1
28679: ARRAY
28680: PPUSH
28681: LD_VAR 0 12
28685: PUSH
28686: LD_VAR 0 7
28690: ARRAY
28691: PUSH
28692: LD_INT 2
28694: ARRAY
28695: PPUSH
28696: CALL_OW 546
28700: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28701: LD_VAR 0 8
28705: PUSH
28706: LD_INT 1
28708: ARRAY
28709: PUSH
28710: LD_VAR 0 8
28714: PUSH
28715: LD_INT 2
28717: ARRAY
28718: PUSH
28719: LD_VAR 0 13
28723: PUSH
28724: LD_INT 2
28726: PLUS
28727: GREATER
28728: OR
28729: PUSH
28730: LD_VAR 0 8
28734: PUSH
28735: LD_INT 2
28737: ARRAY
28738: PUSH
28739: LD_VAR 0 13
28743: PUSH
28744: LD_INT 2
28746: MINUS
28747: LESS
28748: OR
28749: PUSH
28750: LD_VAR 0 8
28754: PUSH
28755: LD_INT 3
28757: ARRAY
28758: PUSH
28759: LD_INT 0
28761: PUSH
28762: LD_INT 8
28764: PUSH
28765: LD_INT 9
28767: PUSH
28768: LD_INT 10
28770: PUSH
28771: LD_INT 11
28773: PUSH
28774: LD_INT 12
28776: PUSH
28777: LD_INT 13
28779: PUSH
28780: LD_INT 16
28782: PUSH
28783: LD_INT 17
28785: PUSH
28786: LD_INT 18
28788: PUSH
28789: LD_INT 19
28791: PUSH
28792: LD_INT 20
28794: PUSH
28795: LD_INT 21
28797: PUSH
28798: EMPTY
28799: LIST
28800: LIST
28801: LIST
28802: LIST
28803: LIST
28804: LIST
28805: LIST
28806: LIST
28807: LIST
28808: LIST
28809: LIST
28810: LIST
28811: LIST
28812: IN
28813: NOT
28814: OR
28815: PUSH
28816: LD_VAR 0 8
28820: PUSH
28821: LD_INT 5
28823: ARRAY
28824: NOT
28825: OR
28826: PUSH
28827: LD_VAR 0 8
28831: PUSH
28832: LD_INT 6
28834: ARRAY
28835: PUSH
28836: LD_INT 1
28838: PUSH
28839: LD_INT 2
28841: PUSH
28842: LD_INT 7
28844: PUSH
28845: LD_INT 9
28847: PUSH
28848: LD_INT 10
28850: PUSH
28851: LD_INT 11
28853: PUSH
28854: EMPTY
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: IN
28862: NOT
28863: OR
28864: IFFALSE 28870
// exit ;
28866: POP
28867: POP
28868: GO 28953
// end ;
28870: GO 28541
28872: POP
28873: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28874: LD_VAR 0 9
28878: PPUSH
28879: LD_VAR 0 3
28883: PPUSH
28884: LD_VAR 0 4
28888: PPUSH
28889: LD_INT 20
28891: PPUSH
28892: CALL 20899 0 4
28896: PUSH
28897: LD_INT 4
28899: ARRAY
28900: IFFALSE 28904
// exit ;
28902: GO 28953
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28904: LD_VAR 0 2
28908: PUSH
28909: LD_INT 29
28911: PUSH
28912: LD_INT 30
28914: PUSH
28915: EMPTY
28916: LIST
28917: LIST
28918: IN
28919: PUSH
28920: LD_VAR 0 3
28924: PPUSH
28925: LD_VAR 0 4
28929: PPUSH
28930: LD_VAR 0 9
28934: PPUSH
28935: CALL_OW 440
28939: NOT
28940: AND
28941: IFFALSE 28945
// exit ;
28943: GO 28953
// result := true ;
28945: LD_ADDR_VAR 0 6
28949: PUSH
28950: LD_INT 1
28952: ST_TO_ADDR
// end ;
28953: LD_VAR 0 6
28957: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
28958: LD_INT 0
28960: PPUSH
28961: PPUSH
28962: PPUSH
28963: PPUSH
28964: PPUSH
28965: PPUSH
28966: PPUSH
28967: PPUSH
28968: PPUSH
28969: PPUSH
28970: PPUSH
28971: PPUSH
28972: PPUSH
28973: PPUSH
28974: PPUSH
28975: PPUSH
28976: PPUSH
28977: PPUSH
28978: PPUSH
28979: PPUSH
28980: PPUSH
28981: PPUSH
28982: PPUSH
28983: PPUSH
28984: PPUSH
28985: PPUSH
28986: PPUSH
28987: PPUSH
28988: PPUSH
28989: PPUSH
28990: PPUSH
28991: PPUSH
28992: PPUSH
28993: PPUSH
28994: PPUSH
28995: PPUSH
28996: PPUSH
28997: PPUSH
28998: PPUSH
28999: PPUSH
29000: PPUSH
29001: PPUSH
29002: PPUSH
29003: PPUSH
29004: PPUSH
29005: PPUSH
29006: PPUSH
29007: PPUSH
29008: PPUSH
29009: PPUSH
29010: PPUSH
29011: PPUSH
29012: PPUSH
29013: PPUSH
29014: PPUSH
29015: PPUSH
29016: PPUSH
29017: PPUSH
// result = [ ] ;
29018: LD_ADDR_VAR 0 7
29022: PUSH
29023: EMPTY
29024: ST_TO_ADDR
// temp_list = [ ] ;
29025: LD_ADDR_VAR 0 9
29029: PUSH
29030: EMPTY
29031: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29032: LD_VAR 0 4
29036: PUSH
29037: LD_INT 0
29039: PUSH
29040: LD_INT 1
29042: PUSH
29043: LD_INT 2
29045: PUSH
29046: LD_INT 3
29048: PUSH
29049: LD_INT 4
29051: PUSH
29052: LD_INT 5
29054: PUSH
29055: EMPTY
29056: LIST
29057: LIST
29058: LIST
29059: LIST
29060: LIST
29061: LIST
29062: IN
29063: NOT
29064: PUSH
29065: LD_VAR 0 1
29069: PUSH
29070: LD_INT 0
29072: PUSH
29073: LD_INT 1
29075: PUSH
29076: EMPTY
29077: LIST
29078: LIST
29079: IN
29080: PUSH
29081: LD_VAR 0 5
29085: PUSH
29086: LD_INT 1
29088: PUSH
29089: LD_INT 2
29091: PUSH
29092: LD_INT 3
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: LIST
29099: IN
29100: NOT
29101: AND
29102: OR
29103: IFFALSE 29107
// exit ;
29105: GO 47498
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29107: LD_VAR 0 1
29111: PUSH
29112: LD_INT 6
29114: PUSH
29115: LD_INT 7
29117: PUSH
29118: LD_INT 8
29120: PUSH
29121: LD_INT 13
29123: PUSH
29124: LD_INT 12
29126: PUSH
29127: LD_INT 15
29129: PUSH
29130: LD_INT 11
29132: PUSH
29133: LD_INT 14
29135: PUSH
29136: LD_INT 10
29138: PUSH
29139: EMPTY
29140: LIST
29141: LIST
29142: LIST
29143: LIST
29144: LIST
29145: LIST
29146: LIST
29147: LIST
29148: LIST
29149: IN
29150: IFFALSE 29160
// btype = b_lab ;
29152: LD_ADDR_VAR 0 1
29156: PUSH
29157: LD_INT 6
29159: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29160: LD_VAR 0 6
29164: PUSH
29165: LD_INT 0
29167: PUSH
29168: LD_INT 1
29170: PUSH
29171: LD_INT 2
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: LIST
29178: IN
29179: NOT
29180: PUSH
29181: LD_VAR 0 1
29185: PUSH
29186: LD_INT 0
29188: PUSH
29189: LD_INT 1
29191: PUSH
29192: LD_INT 2
29194: PUSH
29195: LD_INT 3
29197: PUSH
29198: LD_INT 6
29200: PUSH
29201: LD_INT 36
29203: PUSH
29204: LD_INT 4
29206: PUSH
29207: LD_INT 5
29209: PUSH
29210: LD_INT 31
29212: PUSH
29213: LD_INT 32
29215: PUSH
29216: LD_INT 33
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: LIST
29226: LIST
29227: LIST
29228: LIST
29229: LIST
29230: LIST
29231: IN
29232: NOT
29233: PUSH
29234: LD_VAR 0 6
29238: PUSH
29239: LD_INT 1
29241: EQUAL
29242: AND
29243: OR
29244: PUSH
29245: LD_VAR 0 1
29249: PUSH
29250: LD_INT 2
29252: PUSH
29253: LD_INT 3
29255: PUSH
29256: EMPTY
29257: LIST
29258: LIST
29259: IN
29260: NOT
29261: PUSH
29262: LD_VAR 0 6
29266: PUSH
29267: LD_INT 2
29269: EQUAL
29270: AND
29271: OR
29272: IFFALSE 29282
// mode = 0 ;
29274: LD_ADDR_VAR 0 6
29278: PUSH
29279: LD_INT 0
29281: ST_TO_ADDR
// case mode of 0 :
29282: LD_VAR 0 6
29286: PUSH
29287: LD_INT 0
29289: DOUBLE
29290: EQUAL
29291: IFTRUE 29295
29293: GO 40748
29295: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29296: LD_ADDR_VAR 0 11
29300: PUSH
29301: LD_INT 0
29303: PUSH
29304: LD_INT 0
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: LD_INT 0
29313: PUSH
29314: LD_INT 1
29316: NEG
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 1
29324: PUSH
29325: LD_INT 0
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: PUSH
29332: LD_INT 1
29334: PUSH
29335: LD_INT 1
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 0
29344: PUSH
29345: LD_INT 1
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: LD_INT 1
29354: NEG
29355: PUSH
29356: LD_INT 0
29358: PUSH
29359: EMPTY
29360: LIST
29361: LIST
29362: PUSH
29363: LD_INT 1
29365: NEG
29366: PUSH
29367: LD_INT 1
29369: NEG
29370: PUSH
29371: EMPTY
29372: LIST
29373: LIST
29374: PUSH
29375: LD_INT 1
29377: NEG
29378: PUSH
29379: LD_INT 2
29381: NEG
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PUSH
29387: LD_INT 0
29389: PUSH
29390: LD_INT 2
29392: NEG
29393: PUSH
29394: EMPTY
29395: LIST
29396: LIST
29397: PUSH
29398: LD_INT 1
29400: PUSH
29401: LD_INT 1
29403: NEG
29404: PUSH
29405: EMPTY
29406: LIST
29407: LIST
29408: PUSH
29409: LD_INT 1
29411: PUSH
29412: LD_INT 2
29414: PUSH
29415: EMPTY
29416: LIST
29417: LIST
29418: PUSH
29419: LD_INT 0
29421: PUSH
29422: LD_INT 2
29424: PUSH
29425: EMPTY
29426: LIST
29427: LIST
29428: PUSH
29429: LD_INT 1
29431: NEG
29432: PUSH
29433: LD_INT 1
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 1
29442: PUSH
29443: LD_INT 3
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: PUSH
29450: LD_INT 0
29452: PUSH
29453: LD_INT 3
29455: PUSH
29456: EMPTY
29457: LIST
29458: LIST
29459: PUSH
29460: LD_INT 1
29462: NEG
29463: PUSH
29464: LD_INT 2
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: LIST
29475: LIST
29476: LIST
29477: LIST
29478: LIST
29479: LIST
29480: LIST
29481: LIST
29482: LIST
29483: LIST
29484: LIST
29485: LIST
29486: LIST
29487: LIST
29488: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29489: LD_ADDR_VAR 0 12
29493: PUSH
29494: LD_INT 0
29496: PUSH
29497: LD_INT 0
29499: PUSH
29500: EMPTY
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 0
29506: PUSH
29507: LD_INT 1
29509: NEG
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 1
29517: PUSH
29518: LD_INT 0
29520: PUSH
29521: EMPTY
29522: LIST
29523: LIST
29524: PUSH
29525: LD_INT 1
29527: PUSH
29528: LD_INT 1
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 0
29537: PUSH
29538: LD_INT 1
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: PUSH
29545: LD_INT 1
29547: NEG
29548: PUSH
29549: LD_INT 0
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PUSH
29556: LD_INT 1
29558: NEG
29559: PUSH
29560: LD_INT 1
29562: NEG
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: PUSH
29568: LD_INT 1
29570: PUSH
29571: LD_INT 1
29573: NEG
29574: PUSH
29575: EMPTY
29576: LIST
29577: LIST
29578: PUSH
29579: LD_INT 2
29581: PUSH
29582: LD_INT 0
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: PUSH
29589: LD_INT 2
29591: PUSH
29592: LD_INT 1
29594: PUSH
29595: EMPTY
29596: LIST
29597: LIST
29598: PUSH
29599: LD_INT 1
29601: NEG
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: PUSH
29610: LD_INT 2
29612: NEG
29613: PUSH
29614: LD_INT 0
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 2
29623: NEG
29624: PUSH
29625: LD_INT 1
29627: NEG
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PUSH
29633: LD_INT 2
29635: NEG
29636: PUSH
29637: LD_INT 1
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 3
29646: NEG
29647: PUSH
29648: LD_INT 0
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: PUSH
29655: LD_INT 3
29657: NEG
29658: PUSH
29659: LD_INT 1
29661: NEG
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: EMPTY
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: LIST
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: LIST
29682: LIST
29683: LIST
29684: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29685: LD_ADDR_VAR 0 13
29689: PUSH
29690: LD_INT 0
29692: PUSH
29693: LD_INT 0
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: PUSH
29700: LD_INT 0
29702: PUSH
29703: LD_INT 1
29705: NEG
29706: PUSH
29707: EMPTY
29708: LIST
29709: LIST
29710: PUSH
29711: LD_INT 1
29713: PUSH
29714: LD_INT 0
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PUSH
29721: LD_INT 1
29723: PUSH
29724: LD_INT 1
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PUSH
29731: LD_INT 0
29733: PUSH
29734: LD_INT 1
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 1
29743: NEG
29744: PUSH
29745: LD_INT 0
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: PUSH
29752: LD_INT 1
29754: NEG
29755: PUSH
29756: LD_INT 1
29758: NEG
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 1
29766: NEG
29767: PUSH
29768: LD_INT 2
29770: NEG
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 2
29778: PUSH
29779: LD_INT 1
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 2
29788: PUSH
29789: LD_INT 2
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 1
29798: PUSH
29799: LD_INT 2
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 2
29808: NEG
29809: PUSH
29810: LD_INT 1
29812: NEG
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 2
29820: NEG
29821: PUSH
29822: LD_INT 2
29824: NEG
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 2
29832: NEG
29833: PUSH
29834: LD_INT 3
29836: NEG
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 3
29844: NEG
29845: PUSH
29846: LD_INT 2
29848: NEG
29849: PUSH
29850: EMPTY
29851: LIST
29852: LIST
29853: PUSH
29854: LD_INT 3
29856: NEG
29857: PUSH
29858: LD_INT 3
29860: NEG
29861: PUSH
29862: EMPTY
29863: LIST
29864: LIST
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: LIST
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: LIST
29882: LIST
29883: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29884: LD_ADDR_VAR 0 14
29888: PUSH
29889: LD_INT 0
29891: PUSH
29892: LD_INT 0
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 0
29901: PUSH
29902: LD_INT 1
29904: NEG
29905: PUSH
29906: EMPTY
29907: LIST
29908: LIST
29909: PUSH
29910: LD_INT 1
29912: PUSH
29913: LD_INT 0
29915: PUSH
29916: EMPTY
29917: LIST
29918: LIST
29919: PUSH
29920: LD_INT 1
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: PUSH
29930: LD_INT 0
29932: PUSH
29933: LD_INT 1
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: PUSH
29940: LD_INT 1
29942: NEG
29943: PUSH
29944: LD_INT 0
29946: PUSH
29947: EMPTY
29948: LIST
29949: LIST
29950: PUSH
29951: LD_INT 1
29953: NEG
29954: PUSH
29955: LD_INT 1
29957: NEG
29958: PUSH
29959: EMPTY
29960: LIST
29961: LIST
29962: PUSH
29963: LD_INT 1
29965: NEG
29966: PUSH
29967: LD_INT 2
29969: NEG
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: LD_INT 0
29977: PUSH
29978: LD_INT 2
29980: NEG
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: LD_INT 1
29988: PUSH
29989: LD_INT 1
29991: NEG
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 1
29999: PUSH
30000: LD_INT 2
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: LD_INT 0
30009: PUSH
30010: LD_INT 2
30012: PUSH
30013: EMPTY
30014: LIST
30015: LIST
30016: PUSH
30017: LD_INT 1
30019: NEG
30020: PUSH
30021: LD_INT 1
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PUSH
30028: LD_INT 1
30030: NEG
30031: PUSH
30032: LD_INT 3
30034: NEG
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_INT 0
30042: PUSH
30043: LD_INT 3
30045: NEG
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PUSH
30051: LD_INT 1
30053: PUSH
30054: LD_INT 2
30056: NEG
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: LIST
30066: LIST
30067: LIST
30068: LIST
30069: LIST
30070: LIST
30071: LIST
30072: LIST
30073: LIST
30074: LIST
30075: LIST
30076: LIST
30077: LIST
30078: LIST
30079: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30080: LD_ADDR_VAR 0 15
30084: PUSH
30085: LD_INT 0
30087: PUSH
30088: LD_INT 0
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 0
30097: PUSH
30098: LD_INT 1
30100: NEG
30101: PUSH
30102: EMPTY
30103: LIST
30104: LIST
30105: PUSH
30106: LD_INT 1
30108: PUSH
30109: LD_INT 0
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 1
30118: PUSH
30119: LD_INT 1
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PUSH
30126: LD_INT 0
30128: PUSH
30129: LD_INT 1
30131: PUSH
30132: EMPTY
30133: LIST
30134: LIST
30135: PUSH
30136: LD_INT 1
30138: NEG
30139: PUSH
30140: LD_INT 0
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 1
30149: NEG
30150: PUSH
30151: LD_INT 1
30153: NEG
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 1
30161: PUSH
30162: LD_INT 1
30164: NEG
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 2
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 2
30182: PUSH
30183: LD_INT 1
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 1
30192: NEG
30193: PUSH
30194: LD_INT 1
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 2
30203: NEG
30204: PUSH
30205: LD_INT 0
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 2
30214: NEG
30215: PUSH
30216: LD_INT 1
30218: NEG
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 2
30226: PUSH
30227: LD_INT 1
30229: NEG
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 3
30237: PUSH
30238: LD_INT 0
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 3
30247: PUSH
30248: LD_INT 1
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: LIST
30259: LIST
30260: LIST
30261: LIST
30262: LIST
30263: LIST
30264: LIST
30265: LIST
30266: LIST
30267: LIST
30268: LIST
30269: LIST
30270: LIST
30271: LIST
30272: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30273: LD_ADDR_VAR 0 16
30277: PUSH
30278: LD_INT 0
30280: PUSH
30281: LD_INT 0
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 0
30290: PUSH
30291: LD_INT 1
30293: NEG
30294: PUSH
30295: EMPTY
30296: LIST
30297: LIST
30298: PUSH
30299: LD_INT 1
30301: PUSH
30302: LD_INT 0
30304: PUSH
30305: EMPTY
30306: LIST
30307: LIST
30308: PUSH
30309: LD_INT 1
30311: PUSH
30312: LD_INT 1
30314: PUSH
30315: EMPTY
30316: LIST
30317: LIST
30318: PUSH
30319: LD_INT 0
30321: PUSH
30322: LD_INT 1
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: PUSH
30329: LD_INT 1
30331: NEG
30332: PUSH
30333: LD_INT 0
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 1
30342: NEG
30343: PUSH
30344: LD_INT 1
30346: NEG
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 1
30354: NEG
30355: PUSH
30356: LD_INT 2
30358: NEG
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 2
30366: PUSH
30367: LD_INT 1
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 2
30376: PUSH
30377: LD_INT 2
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: PUSH
30384: LD_INT 1
30386: PUSH
30387: LD_INT 2
30389: PUSH
30390: EMPTY
30391: LIST
30392: LIST
30393: PUSH
30394: LD_INT 2
30396: NEG
30397: PUSH
30398: LD_INT 1
30400: NEG
30401: PUSH
30402: EMPTY
30403: LIST
30404: LIST
30405: PUSH
30406: LD_INT 2
30408: NEG
30409: PUSH
30410: LD_INT 2
30412: NEG
30413: PUSH
30414: EMPTY
30415: LIST
30416: LIST
30417: PUSH
30418: LD_INT 3
30420: PUSH
30421: LD_INT 2
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 3
30430: PUSH
30431: LD_INT 3
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 2
30440: PUSH
30441: LD_INT 3
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: LIST
30452: LIST
30453: LIST
30454: LIST
30455: LIST
30456: LIST
30457: LIST
30458: LIST
30459: LIST
30460: LIST
30461: LIST
30462: LIST
30463: LIST
30464: LIST
30465: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30466: LD_ADDR_VAR 0 17
30470: PUSH
30471: LD_INT 0
30473: PUSH
30474: LD_INT 0
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 0
30483: PUSH
30484: LD_INT 1
30486: NEG
30487: PUSH
30488: EMPTY
30489: LIST
30490: LIST
30491: PUSH
30492: LD_INT 1
30494: PUSH
30495: LD_INT 0
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: PUSH
30502: LD_INT 1
30504: PUSH
30505: LD_INT 1
30507: PUSH
30508: EMPTY
30509: LIST
30510: LIST
30511: PUSH
30512: LD_INT 0
30514: PUSH
30515: LD_INT 1
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 1
30524: NEG
30525: PUSH
30526: LD_INT 0
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: PUSH
30533: LD_INT 1
30535: NEG
30536: PUSH
30537: LD_INT 1
30539: NEG
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: LD_INT 1
30547: NEG
30548: PUSH
30549: LD_INT 2
30551: NEG
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PUSH
30557: LD_INT 0
30559: PUSH
30560: LD_INT 2
30562: NEG
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 1
30570: PUSH
30571: LD_INT 1
30573: NEG
30574: PUSH
30575: EMPTY
30576: LIST
30577: LIST
30578: PUSH
30579: LD_INT 2
30581: PUSH
30582: LD_INT 0
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: LD_INT 2
30591: PUSH
30592: LD_INT 1
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 2
30601: PUSH
30602: LD_INT 2
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: PUSH
30609: LD_INT 1
30611: PUSH
30612: LD_INT 2
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 0
30621: PUSH
30622: LD_INT 2
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: LD_INT 1
30631: NEG
30632: PUSH
30633: LD_INT 1
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 2
30642: NEG
30643: PUSH
30644: LD_INT 0
30646: PUSH
30647: EMPTY
30648: LIST
30649: LIST
30650: PUSH
30651: LD_INT 2
30653: NEG
30654: PUSH
30655: LD_INT 1
30657: NEG
30658: PUSH
30659: EMPTY
30660: LIST
30661: LIST
30662: PUSH
30663: LD_INT 2
30665: NEG
30666: PUSH
30667: LD_INT 2
30669: NEG
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: LIST
30679: LIST
30680: LIST
30681: LIST
30682: LIST
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30696: LD_ADDR_VAR 0 18
30700: PUSH
30701: LD_INT 0
30703: PUSH
30704: LD_INT 0
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 0
30713: PUSH
30714: LD_INT 1
30716: NEG
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: LD_INT 1
30724: PUSH
30725: LD_INT 0
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 1
30734: PUSH
30735: LD_INT 1
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 0
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: LD_INT 1
30754: NEG
30755: PUSH
30756: LD_INT 0
30758: PUSH
30759: EMPTY
30760: LIST
30761: LIST
30762: PUSH
30763: LD_INT 1
30765: NEG
30766: PUSH
30767: LD_INT 1
30769: NEG
30770: PUSH
30771: EMPTY
30772: LIST
30773: LIST
30774: PUSH
30775: LD_INT 1
30777: NEG
30778: PUSH
30779: LD_INT 2
30781: NEG
30782: PUSH
30783: EMPTY
30784: LIST
30785: LIST
30786: PUSH
30787: LD_INT 0
30789: PUSH
30790: LD_INT 2
30792: NEG
30793: PUSH
30794: EMPTY
30795: LIST
30796: LIST
30797: PUSH
30798: LD_INT 1
30800: PUSH
30801: LD_INT 1
30803: NEG
30804: PUSH
30805: EMPTY
30806: LIST
30807: LIST
30808: PUSH
30809: LD_INT 2
30811: PUSH
30812: LD_INT 0
30814: PUSH
30815: EMPTY
30816: LIST
30817: LIST
30818: PUSH
30819: LD_INT 2
30821: PUSH
30822: LD_INT 1
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 2
30831: PUSH
30832: LD_INT 2
30834: PUSH
30835: EMPTY
30836: LIST
30837: LIST
30838: PUSH
30839: LD_INT 1
30841: PUSH
30842: LD_INT 2
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: PUSH
30849: LD_INT 0
30851: PUSH
30852: LD_INT 2
30854: PUSH
30855: EMPTY
30856: LIST
30857: LIST
30858: PUSH
30859: LD_INT 1
30861: NEG
30862: PUSH
30863: LD_INT 1
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: LD_INT 2
30872: NEG
30873: PUSH
30874: LD_INT 0
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PUSH
30881: LD_INT 2
30883: NEG
30884: PUSH
30885: LD_INT 1
30887: NEG
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 2
30895: NEG
30896: PUSH
30897: LD_INT 2
30899: NEG
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30926: LD_ADDR_VAR 0 19
30930: PUSH
30931: LD_INT 0
30933: PUSH
30934: LD_INT 0
30936: PUSH
30937: EMPTY
30938: LIST
30939: LIST
30940: PUSH
30941: LD_INT 0
30943: PUSH
30944: LD_INT 1
30946: NEG
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 1
30954: PUSH
30955: LD_INT 0
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: LD_INT 1
30964: PUSH
30965: LD_INT 1
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 0
30974: PUSH
30975: LD_INT 1
30977: PUSH
30978: EMPTY
30979: LIST
30980: LIST
30981: PUSH
30982: LD_INT 1
30984: NEG
30985: PUSH
30986: LD_INT 0
30988: PUSH
30989: EMPTY
30990: LIST
30991: LIST
30992: PUSH
30993: LD_INT 1
30995: NEG
30996: PUSH
30997: LD_INT 1
30999: NEG
31000: PUSH
31001: EMPTY
31002: LIST
31003: LIST
31004: PUSH
31005: LD_INT 1
31007: NEG
31008: PUSH
31009: LD_INT 2
31011: NEG
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PUSH
31017: LD_INT 0
31019: PUSH
31020: LD_INT 2
31022: NEG
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 1
31030: PUSH
31031: LD_INT 1
31033: NEG
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PUSH
31039: LD_INT 2
31041: PUSH
31042: LD_INT 0
31044: PUSH
31045: EMPTY
31046: LIST
31047: LIST
31048: PUSH
31049: LD_INT 2
31051: PUSH
31052: LD_INT 1
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 2
31061: PUSH
31062: LD_INT 2
31064: PUSH
31065: EMPTY
31066: LIST
31067: LIST
31068: PUSH
31069: LD_INT 1
31071: PUSH
31072: LD_INT 2
31074: PUSH
31075: EMPTY
31076: LIST
31077: LIST
31078: PUSH
31079: LD_INT 0
31081: PUSH
31082: LD_INT 2
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: LD_INT 1
31091: NEG
31092: PUSH
31093: LD_INT 1
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 2
31102: NEG
31103: PUSH
31104: LD_INT 0
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 2
31113: NEG
31114: PUSH
31115: LD_INT 1
31117: NEG
31118: PUSH
31119: EMPTY
31120: LIST
31121: LIST
31122: PUSH
31123: LD_INT 2
31125: NEG
31126: PUSH
31127: LD_INT 2
31129: NEG
31130: PUSH
31131: EMPTY
31132: LIST
31133: LIST
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: LIST
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: LIST
31154: LIST
31155: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31156: LD_ADDR_VAR 0 20
31160: PUSH
31161: LD_INT 0
31163: PUSH
31164: LD_INT 0
31166: PUSH
31167: EMPTY
31168: LIST
31169: LIST
31170: PUSH
31171: LD_INT 0
31173: PUSH
31174: LD_INT 1
31176: NEG
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 1
31184: PUSH
31185: LD_INT 0
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 1
31194: PUSH
31195: LD_INT 1
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 0
31204: PUSH
31205: LD_INT 1
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 1
31214: NEG
31215: PUSH
31216: LD_INT 0
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PUSH
31223: LD_INT 1
31225: NEG
31226: PUSH
31227: LD_INT 1
31229: NEG
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 1
31237: NEG
31238: PUSH
31239: LD_INT 2
31241: NEG
31242: PUSH
31243: EMPTY
31244: LIST
31245: LIST
31246: PUSH
31247: LD_INT 0
31249: PUSH
31250: LD_INT 2
31252: NEG
31253: PUSH
31254: EMPTY
31255: LIST
31256: LIST
31257: PUSH
31258: LD_INT 1
31260: PUSH
31261: LD_INT 1
31263: NEG
31264: PUSH
31265: EMPTY
31266: LIST
31267: LIST
31268: PUSH
31269: LD_INT 2
31271: PUSH
31272: LD_INT 0
31274: PUSH
31275: EMPTY
31276: LIST
31277: LIST
31278: PUSH
31279: LD_INT 2
31281: PUSH
31282: LD_INT 1
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 2
31291: PUSH
31292: LD_INT 2
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: PUSH
31299: LD_INT 1
31301: PUSH
31302: LD_INT 2
31304: PUSH
31305: EMPTY
31306: LIST
31307: LIST
31308: PUSH
31309: LD_INT 0
31311: PUSH
31312: LD_INT 2
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: PUSH
31319: LD_INT 1
31321: NEG
31322: PUSH
31323: LD_INT 1
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 2
31332: NEG
31333: PUSH
31334: LD_INT 0
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 2
31343: NEG
31344: PUSH
31345: LD_INT 1
31347: NEG
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 2
31355: NEG
31356: PUSH
31357: LD_INT 2
31359: NEG
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: EMPTY
31366: LIST
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31386: LD_ADDR_VAR 0 21
31390: PUSH
31391: LD_INT 0
31393: PUSH
31394: LD_INT 0
31396: PUSH
31397: EMPTY
31398: LIST
31399: LIST
31400: PUSH
31401: LD_INT 0
31403: PUSH
31404: LD_INT 1
31406: NEG
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 1
31414: PUSH
31415: LD_INT 0
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 1
31424: PUSH
31425: LD_INT 1
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PUSH
31432: LD_INT 0
31434: PUSH
31435: LD_INT 1
31437: PUSH
31438: EMPTY
31439: LIST
31440: LIST
31441: PUSH
31442: LD_INT 1
31444: NEG
31445: PUSH
31446: LD_INT 0
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 1
31455: NEG
31456: PUSH
31457: LD_INT 1
31459: NEG
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 1
31467: NEG
31468: PUSH
31469: LD_INT 2
31471: NEG
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PUSH
31477: LD_INT 0
31479: PUSH
31480: LD_INT 2
31482: NEG
31483: PUSH
31484: EMPTY
31485: LIST
31486: LIST
31487: PUSH
31488: LD_INT 1
31490: PUSH
31491: LD_INT 1
31493: NEG
31494: PUSH
31495: EMPTY
31496: LIST
31497: LIST
31498: PUSH
31499: LD_INT 2
31501: PUSH
31502: LD_INT 0
31504: PUSH
31505: EMPTY
31506: LIST
31507: LIST
31508: PUSH
31509: LD_INT 2
31511: PUSH
31512: LD_INT 1
31514: PUSH
31515: EMPTY
31516: LIST
31517: LIST
31518: PUSH
31519: LD_INT 2
31521: PUSH
31522: LD_INT 2
31524: PUSH
31525: EMPTY
31526: LIST
31527: LIST
31528: PUSH
31529: LD_INT 1
31531: PUSH
31532: LD_INT 2
31534: PUSH
31535: EMPTY
31536: LIST
31537: LIST
31538: PUSH
31539: LD_INT 0
31541: PUSH
31542: LD_INT 2
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 1
31551: NEG
31552: PUSH
31553: LD_INT 1
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 2
31562: NEG
31563: PUSH
31564: LD_INT 0
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 2
31573: NEG
31574: PUSH
31575: LD_INT 1
31577: NEG
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 2
31585: NEG
31586: PUSH
31587: LD_INT 2
31589: NEG
31590: PUSH
31591: EMPTY
31592: LIST
31593: LIST
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: LIST
31599: LIST
31600: LIST
31601: LIST
31602: LIST
31603: LIST
31604: LIST
31605: LIST
31606: LIST
31607: LIST
31608: LIST
31609: LIST
31610: LIST
31611: LIST
31612: LIST
31613: LIST
31614: LIST
31615: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31616: LD_ADDR_VAR 0 22
31620: PUSH
31621: LD_INT 0
31623: PUSH
31624: LD_INT 0
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 0
31633: PUSH
31634: LD_INT 1
31636: NEG
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 1
31644: PUSH
31645: LD_INT 0
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 1
31654: PUSH
31655: LD_INT 1
31657: PUSH
31658: EMPTY
31659: LIST
31660: LIST
31661: PUSH
31662: LD_INT 0
31664: PUSH
31665: LD_INT 1
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PUSH
31672: LD_INT 1
31674: NEG
31675: PUSH
31676: LD_INT 0
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 1
31685: NEG
31686: PUSH
31687: LD_INT 1
31689: NEG
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 1
31697: NEG
31698: PUSH
31699: LD_INT 2
31701: NEG
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: LD_INT 0
31709: PUSH
31710: LD_INT 2
31712: NEG
31713: PUSH
31714: EMPTY
31715: LIST
31716: LIST
31717: PUSH
31718: LD_INT 1
31720: PUSH
31721: LD_INT 1
31723: NEG
31724: PUSH
31725: EMPTY
31726: LIST
31727: LIST
31728: PUSH
31729: LD_INT 2
31731: PUSH
31732: LD_INT 0
31734: PUSH
31735: EMPTY
31736: LIST
31737: LIST
31738: PUSH
31739: LD_INT 2
31741: PUSH
31742: LD_INT 1
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 2
31751: PUSH
31752: LD_INT 2
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 1
31761: PUSH
31762: LD_INT 2
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 0
31771: PUSH
31772: LD_INT 2
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 1
31781: NEG
31782: PUSH
31783: LD_INT 1
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 2
31792: NEG
31793: PUSH
31794: LD_INT 0
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PUSH
31801: LD_INT 2
31803: NEG
31804: PUSH
31805: LD_INT 1
31807: NEG
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 2
31815: NEG
31816: PUSH
31817: LD_INT 2
31819: NEG
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: EMPTY
31826: LIST
31827: LIST
31828: LIST
31829: LIST
31830: LIST
31831: LIST
31832: LIST
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: LIST
31845: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31846: LD_ADDR_VAR 0 23
31850: PUSH
31851: LD_INT 0
31853: PUSH
31854: LD_INT 0
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 0
31863: PUSH
31864: LD_INT 1
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 1
31874: PUSH
31875: LD_INT 0
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 1
31884: PUSH
31885: LD_INT 1
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 0
31894: PUSH
31895: LD_INT 1
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 1
31904: NEG
31905: PUSH
31906: LD_INT 0
31908: PUSH
31909: EMPTY
31910: LIST
31911: LIST
31912: PUSH
31913: LD_INT 1
31915: NEG
31916: PUSH
31917: LD_INT 1
31919: NEG
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 1
31927: NEG
31928: PUSH
31929: LD_INT 2
31931: NEG
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 0
31939: PUSH
31940: LD_INT 2
31942: NEG
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: LD_INT 1
31950: PUSH
31951: LD_INT 1
31953: NEG
31954: PUSH
31955: EMPTY
31956: LIST
31957: LIST
31958: PUSH
31959: LD_INT 2
31961: PUSH
31962: LD_INT 0
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 2
31971: PUSH
31972: LD_INT 1
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 2
31981: PUSH
31982: LD_INT 2
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 1
31991: PUSH
31992: LD_INT 2
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 0
32001: PUSH
32002: LD_INT 2
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 1
32011: NEG
32012: PUSH
32013: LD_INT 1
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 2
32022: NEG
32023: PUSH
32024: LD_INT 0
32026: PUSH
32027: EMPTY
32028: LIST
32029: LIST
32030: PUSH
32031: LD_INT 2
32033: NEG
32034: PUSH
32035: LD_INT 1
32037: NEG
32038: PUSH
32039: EMPTY
32040: LIST
32041: LIST
32042: PUSH
32043: LD_INT 2
32045: NEG
32046: PUSH
32047: LD_INT 2
32049: NEG
32050: PUSH
32051: EMPTY
32052: LIST
32053: LIST
32054: PUSH
32055: LD_INT 2
32057: NEG
32058: PUSH
32059: LD_INT 3
32061: NEG
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 1
32069: NEG
32070: PUSH
32071: LD_INT 3
32073: NEG
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: PUSH
32079: LD_INT 1
32081: PUSH
32082: LD_INT 2
32084: NEG
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: PUSH
32090: LD_INT 2
32092: PUSH
32093: LD_INT 1
32095: NEG
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: LIST
32105: LIST
32106: LIST
32107: LIST
32108: LIST
32109: LIST
32110: LIST
32111: LIST
32112: LIST
32113: LIST
32114: LIST
32115: LIST
32116: LIST
32117: LIST
32118: LIST
32119: LIST
32120: LIST
32121: LIST
32122: LIST
32123: LIST
32124: LIST
32125: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32126: LD_ADDR_VAR 0 24
32130: PUSH
32131: LD_INT 0
32133: PUSH
32134: LD_INT 0
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: LD_INT 0
32143: PUSH
32144: LD_INT 1
32146: NEG
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 1
32154: PUSH
32155: LD_INT 0
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: LD_INT 1
32164: PUSH
32165: LD_INT 1
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 0
32174: PUSH
32175: LD_INT 1
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: LD_INT 1
32184: NEG
32185: PUSH
32186: LD_INT 0
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PUSH
32193: LD_INT 1
32195: NEG
32196: PUSH
32197: LD_INT 1
32199: NEG
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 1
32207: NEG
32208: PUSH
32209: LD_INT 2
32211: NEG
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 0
32219: PUSH
32220: LD_INT 2
32222: NEG
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: PUSH
32228: LD_INT 1
32230: PUSH
32231: LD_INT 1
32233: NEG
32234: PUSH
32235: EMPTY
32236: LIST
32237: LIST
32238: PUSH
32239: LD_INT 2
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: PUSH
32249: LD_INT 2
32251: PUSH
32252: LD_INT 1
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 2
32261: PUSH
32262: LD_INT 2
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PUSH
32269: LD_INT 1
32271: PUSH
32272: LD_INT 2
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 0
32281: PUSH
32282: LD_INT 2
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 1
32291: NEG
32292: PUSH
32293: LD_INT 1
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 2
32302: NEG
32303: PUSH
32304: LD_INT 0
32306: PUSH
32307: EMPTY
32308: LIST
32309: LIST
32310: PUSH
32311: LD_INT 2
32313: NEG
32314: PUSH
32315: LD_INT 1
32317: NEG
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 2
32325: NEG
32326: PUSH
32327: LD_INT 2
32329: NEG
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 1
32337: PUSH
32338: LD_INT 2
32340: NEG
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 2
32348: PUSH
32349: LD_INT 1
32351: NEG
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 3
32359: PUSH
32360: LD_INT 1
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 3
32369: PUSH
32370: LD_INT 2
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: LIST
32381: LIST
32382: LIST
32383: LIST
32384: LIST
32385: LIST
32386: LIST
32387: LIST
32388: LIST
32389: LIST
32390: LIST
32391: LIST
32392: LIST
32393: LIST
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: LIST
32401: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32402: LD_ADDR_VAR 0 25
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: LD_INT 0
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 0
32419: PUSH
32420: LD_INT 1
32422: NEG
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 1
32430: PUSH
32431: LD_INT 0
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: LD_INT 1
32440: PUSH
32441: LD_INT 1
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 0
32450: PUSH
32451: LD_INT 1
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 1
32460: NEG
32461: PUSH
32462: LD_INT 0
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 1
32471: NEG
32472: PUSH
32473: LD_INT 1
32475: NEG
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: LD_INT 1
32483: NEG
32484: PUSH
32485: LD_INT 2
32487: NEG
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: PUSH
32493: LD_INT 0
32495: PUSH
32496: LD_INT 2
32498: NEG
32499: PUSH
32500: EMPTY
32501: LIST
32502: LIST
32503: PUSH
32504: LD_INT 1
32506: PUSH
32507: LD_INT 1
32509: NEG
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: LD_INT 2
32517: PUSH
32518: LD_INT 0
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 2
32527: PUSH
32528: LD_INT 1
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 2
32537: PUSH
32538: LD_INT 2
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: LD_INT 1
32547: PUSH
32548: LD_INT 2
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 0
32557: PUSH
32558: LD_INT 2
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 1
32567: NEG
32568: PUSH
32569: LD_INT 1
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 2
32578: NEG
32579: PUSH
32580: LD_INT 0
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PUSH
32587: LD_INT 2
32589: NEG
32590: PUSH
32591: LD_INT 1
32593: NEG
32594: PUSH
32595: EMPTY
32596: LIST
32597: LIST
32598: PUSH
32599: LD_INT 2
32601: NEG
32602: PUSH
32603: LD_INT 2
32605: NEG
32606: PUSH
32607: EMPTY
32608: LIST
32609: LIST
32610: PUSH
32611: LD_INT 3
32613: PUSH
32614: LD_INT 1
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PUSH
32621: LD_INT 3
32623: PUSH
32624: LD_INT 2
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: LD_INT 2
32633: PUSH
32634: LD_INT 3
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: PUSH
32641: LD_INT 1
32643: PUSH
32644: LD_INT 3
32646: PUSH
32647: EMPTY
32648: LIST
32649: LIST
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: LIST
32664: LIST
32665: LIST
32666: LIST
32667: LIST
32668: LIST
32669: LIST
32670: LIST
32671: LIST
32672: LIST
32673: LIST
32674: LIST
32675: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32676: LD_ADDR_VAR 0 26
32680: PUSH
32681: LD_INT 0
32683: PUSH
32684: LD_INT 0
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: PUSH
32691: LD_INT 0
32693: PUSH
32694: LD_INT 1
32696: NEG
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: PUSH
32705: LD_INT 0
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 1
32714: PUSH
32715: LD_INT 1
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PUSH
32722: LD_INT 0
32724: PUSH
32725: LD_INT 1
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 1
32734: NEG
32735: PUSH
32736: LD_INT 0
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 1
32745: NEG
32746: PUSH
32747: LD_INT 1
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: NEG
32758: PUSH
32759: LD_INT 2
32761: NEG
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 0
32769: PUSH
32770: LD_INT 2
32772: NEG
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 1
32780: PUSH
32781: LD_INT 1
32783: NEG
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 2
32791: PUSH
32792: LD_INT 0
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 2
32801: PUSH
32802: LD_INT 1
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 2
32811: PUSH
32812: LD_INT 2
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 1
32821: PUSH
32822: LD_INT 2
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 0
32831: PUSH
32832: LD_INT 2
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 1
32841: NEG
32842: PUSH
32843: LD_INT 1
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 2
32852: NEG
32853: PUSH
32854: LD_INT 0
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 2
32863: NEG
32864: PUSH
32865: LD_INT 1
32867: NEG
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 2
32875: NEG
32876: PUSH
32877: LD_INT 2
32879: NEG
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 2
32887: PUSH
32888: LD_INT 3
32890: PUSH
32891: EMPTY
32892: LIST
32893: LIST
32894: PUSH
32895: LD_INT 1
32897: PUSH
32898: LD_INT 3
32900: PUSH
32901: EMPTY
32902: LIST
32903: LIST
32904: PUSH
32905: LD_INT 1
32907: NEG
32908: PUSH
32909: LD_INT 2
32911: PUSH
32912: EMPTY
32913: LIST
32914: LIST
32915: PUSH
32916: LD_INT 2
32918: NEG
32919: PUSH
32920: LD_INT 1
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: LIST
32943: LIST
32944: LIST
32945: LIST
32946: LIST
32947: LIST
32948: LIST
32949: LIST
32950: LIST
32951: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32952: LD_ADDR_VAR 0 27
32956: PUSH
32957: LD_INT 0
32959: PUSH
32960: LD_INT 0
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 0
32969: PUSH
32970: LD_INT 1
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 1
32980: PUSH
32981: LD_INT 0
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: LD_INT 1
32990: PUSH
32991: LD_INT 1
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 0
33000: PUSH
33001: LD_INT 1
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 1
33010: NEG
33011: PUSH
33012: LD_INT 0
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 1
33021: NEG
33022: PUSH
33023: LD_INT 1
33025: NEG
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: LD_INT 1
33033: NEG
33034: PUSH
33035: LD_INT 2
33037: NEG
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 0
33045: PUSH
33046: LD_INT 2
33048: NEG
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 1
33056: PUSH
33057: LD_INT 1
33059: NEG
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 2
33067: PUSH
33068: LD_INT 0
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 2
33077: PUSH
33078: LD_INT 1
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 2
33087: PUSH
33088: LD_INT 2
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 1
33097: PUSH
33098: LD_INT 2
33100: PUSH
33101: EMPTY
33102: LIST
33103: LIST
33104: PUSH
33105: LD_INT 0
33107: PUSH
33108: LD_INT 2
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 1
33117: NEG
33118: PUSH
33119: LD_INT 1
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 2
33128: NEG
33129: PUSH
33130: LD_INT 0
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: PUSH
33137: LD_INT 2
33139: NEG
33140: PUSH
33141: LD_INT 1
33143: NEG
33144: PUSH
33145: EMPTY
33146: LIST
33147: LIST
33148: PUSH
33149: LD_INT 2
33151: NEG
33152: PUSH
33153: LD_INT 2
33155: NEG
33156: PUSH
33157: EMPTY
33158: LIST
33159: LIST
33160: PUSH
33161: LD_INT 1
33163: NEG
33164: PUSH
33165: LD_INT 2
33167: PUSH
33168: EMPTY
33169: LIST
33170: LIST
33171: PUSH
33172: LD_INT 2
33174: NEG
33175: PUSH
33176: LD_INT 1
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 3
33185: NEG
33186: PUSH
33187: LD_INT 1
33189: NEG
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 3
33197: NEG
33198: PUSH
33199: LD_INT 2
33201: NEG
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33232: LD_ADDR_VAR 0 28
33236: PUSH
33237: LD_INT 0
33239: PUSH
33240: LD_INT 0
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: PUSH
33247: LD_INT 0
33249: PUSH
33250: LD_INT 1
33252: NEG
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 1
33260: PUSH
33261: LD_INT 0
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 1
33270: PUSH
33271: LD_INT 1
33273: PUSH
33274: EMPTY
33275: LIST
33276: LIST
33277: PUSH
33278: LD_INT 0
33280: PUSH
33281: LD_INT 1
33283: PUSH
33284: EMPTY
33285: LIST
33286: LIST
33287: PUSH
33288: LD_INT 1
33290: NEG
33291: PUSH
33292: LD_INT 0
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 1
33301: NEG
33302: PUSH
33303: LD_INT 1
33305: NEG
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 1
33313: NEG
33314: PUSH
33315: LD_INT 2
33317: NEG
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: PUSH
33323: LD_INT 0
33325: PUSH
33326: LD_INT 2
33328: NEG
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 1
33336: PUSH
33337: LD_INT 1
33339: NEG
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 2
33347: PUSH
33348: LD_INT 0
33350: PUSH
33351: EMPTY
33352: LIST
33353: LIST
33354: PUSH
33355: LD_INT 2
33357: PUSH
33358: LD_INT 1
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 2
33367: PUSH
33368: LD_INT 2
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 1
33377: PUSH
33378: LD_INT 2
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 0
33387: PUSH
33388: LD_INT 2
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 1
33397: NEG
33398: PUSH
33399: LD_INT 1
33401: PUSH
33402: EMPTY
33403: LIST
33404: LIST
33405: PUSH
33406: LD_INT 2
33408: NEG
33409: PUSH
33410: LD_INT 0
33412: PUSH
33413: EMPTY
33414: LIST
33415: LIST
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: LD_INT 1
33423: NEG
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PUSH
33429: LD_INT 2
33431: NEG
33432: PUSH
33433: LD_INT 2
33435: NEG
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 2
33443: NEG
33444: PUSH
33445: LD_INT 3
33447: NEG
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 1
33455: NEG
33456: PUSH
33457: LD_INT 3
33459: NEG
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 3
33467: NEG
33468: PUSH
33469: LD_INT 1
33471: NEG
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 3
33479: NEG
33480: PUSH
33481: LD_INT 2
33483: NEG
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: LIST
33493: LIST
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: LIST
33499: LIST
33500: LIST
33501: LIST
33502: LIST
33503: LIST
33504: LIST
33505: LIST
33506: LIST
33507: LIST
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33514: LD_ADDR_VAR 0 29
33518: PUSH
33519: LD_INT 0
33521: PUSH
33522: LD_INT 0
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 0
33531: PUSH
33532: LD_INT 1
33534: NEG
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: PUSH
33540: LD_INT 1
33542: PUSH
33543: LD_INT 0
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 1
33552: PUSH
33553: LD_INT 1
33555: PUSH
33556: EMPTY
33557: LIST
33558: LIST
33559: PUSH
33560: LD_INT 0
33562: PUSH
33563: LD_INT 1
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: LD_INT 0
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 1
33583: NEG
33584: PUSH
33585: LD_INT 1
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 1
33595: NEG
33596: PUSH
33597: LD_INT 2
33599: NEG
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 0
33607: PUSH
33608: LD_INT 2
33610: NEG
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: LD_INT 1
33621: NEG
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 2
33629: PUSH
33630: LD_INT 0
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 2
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: PUSH
33650: LD_INT 2
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 0
33659: PUSH
33660: LD_INT 2
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 1
33669: NEG
33670: PUSH
33671: LD_INT 1
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 2
33680: NEG
33681: PUSH
33682: LD_INT 1
33684: NEG
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: LD_INT 2
33692: NEG
33693: PUSH
33694: LD_INT 2
33696: NEG
33697: PUSH
33698: EMPTY
33699: LIST
33700: LIST
33701: PUSH
33702: LD_INT 2
33704: NEG
33705: PUSH
33706: LD_INT 3
33708: NEG
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 2
33716: PUSH
33717: LD_INT 1
33719: NEG
33720: PUSH
33721: EMPTY
33722: LIST
33723: LIST
33724: PUSH
33725: LD_INT 3
33727: PUSH
33728: LD_INT 1
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 1
33737: PUSH
33738: LD_INT 3
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: LD_INT 1
33747: NEG
33748: PUSH
33749: LD_INT 2
33751: PUSH
33752: EMPTY
33753: LIST
33754: LIST
33755: PUSH
33756: LD_INT 3
33758: NEG
33759: PUSH
33760: LD_INT 2
33762: NEG
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: EMPTY
33769: LIST
33770: LIST
33771: LIST
33772: LIST
33773: LIST
33774: LIST
33775: LIST
33776: LIST
33777: LIST
33778: LIST
33779: LIST
33780: LIST
33781: LIST
33782: LIST
33783: LIST
33784: LIST
33785: LIST
33786: LIST
33787: LIST
33788: LIST
33789: LIST
33790: LIST
33791: LIST
33792: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33793: LD_ADDR_VAR 0 30
33797: PUSH
33798: LD_INT 0
33800: PUSH
33801: LD_INT 0
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 0
33810: PUSH
33811: LD_INT 1
33813: NEG
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 1
33821: PUSH
33822: LD_INT 0
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 1
33831: PUSH
33832: LD_INT 1
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: LD_INT 0
33841: PUSH
33842: LD_INT 1
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 1
33851: NEG
33852: PUSH
33853: LD_INT 0
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 1
33862: NEG
33863: PUSH
33864: LD_INT 1
33866: NEG
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 1
33874: NEG
33875: PUSH
33876: LD_INT 2
33878: NEG
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: LD_INT 0
33886: PUSH
33887: LD_INT 2
33889: NEG
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 1
33897: PUSH
33898: LD_INT 1
33900: NEG
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 2
33908: PUSH
33909: LD_INT 0
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 2
33918: PUSH
33919: LD_INT 1
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 2
33928: PUSH
33929: LD_INT 2
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 1
33938: PUSH
33939: LD_INT 2
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 1
33948: NEG
33949: PUSH
33950: LD_INT 1
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 2
33959: NEG
33960: PUSH
33961: LD_INT 0
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 2
33970: NEG
33971: PUSH
33972: LD_INT 1
33974: NEG
33975: PUSH
33976: EMPTY
33977: LIST
33978: LIST
33979: PUSH
33980: LD_INT 1
33982: NEG
33983: PUSH
33984: LD_INT 3
33986: NEG
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: LD_INT 1
33994: PUSH
33995: LD_INT 2
33997: NEG
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 3
34005: PUSH
34006: LD_INT 2
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 2
34015: PUSH
34016: LD_INT 3
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 2
34025: NEG
34026: PUSH
34027: LD_INT 1
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: LD_INT 3
34036: NEG
34037: PUSH
34038: LD_INT 1
34040: NEG
34041: PUSH
34042: EMPTY
34043: LIST
34044: LIST
34045: PUSH
34046: EMPTY
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: LIST
34055: LIST
34056: LIST
34057: LIST
34058: LIST
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34071: LD_ADDR_VAR 0 31
34075: PUSH
34076: LD_INT 0
34078: PUSH
34079: LD_INT 0
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: LD_INT 0
34088: PUSH
34089: LD_INT 1
34091: NEG
34092: PUSH
34093: EMPTY
34094: LIST
34095: LIST
34096: PUSH
34097: LD_INT 1
34099: PUSH
34100: LD_INT 0
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 1
34109: PUSH
34110: LD_INT 1
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 0
34119: PUSH
34120: LD_INT 1
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 1
34129: NEG
34130: PUSH
34131: LD_INT 0
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 1
34140: NEG
34141: PUSH
34142: LD_INT 1
34144: NEG
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: LD_INT 2
34156: NEG
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 1
34164: PUSH
34165: LD_INT 1
34167: NEG
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 2
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 2
34185: PUSH
34186: LD_INT 1
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 2
34195: PUSH
34196: LD_INT 2
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 1
34205: PUSH
34206: LD_INT 2
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 0
34215: PUSH
34216: LD_INT 2
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 1
34225: NEG
34226: PUSH
34227: LD_INT 1
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 2
34236: NEG
34237: PUSH
34238: LD_INT 1
34240: NEG
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: PUSH
34246: LD_INT 2
34248: NEG
34249: PUSH
34250: LD_INT 2
34252: NEG
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 2
34260: NEG
34261: PUSH
34262: LD_INT 3
34264: NEG
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 2
34272: PUSH
34273: LD_INT 1
34275: NEG
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 3
34283: PUSH
34284: LD_INT 1
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: LD_INT 1
34293: PUSH
34294: LD_INT 3
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 1
34303: NEG
34304: PUSH
34305: LD_INT 2
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PUSH
34312: LD_INT 3
34314: NEG
34315: PUSH
34316: LD_INT 2
34318: NEG
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PUSH
34324: EMPTY
34325: LIST
34326: LIST
34327: LIST
34328: LIST
34329: LIST
34330: LIST
34331: LIST
34332: LIST
34333: LIST
34334: LIST
34335: LIST
34336: LIST
34337: LIST
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34349: LD_ADDR_VAR 0 32
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: LD_INT 0
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 0
34366: PUSH
34367: LD_INT 1
34369: NEG
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 1
34377: PUSH
34378: LD_INT 0
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 1
34387: PUSH
34388: LD_INT 1
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 0
34397: PUSH
34398: LD_INT 1
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 1
34407: NEG
34408: PUSH
34409: LD_INT 0
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 1
34418: NEG
34419: PUSH
34420: LD_INT 1
34422: NEG
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 1
34430: NEG
34431: PUSH
34432: LD_INT 2
34434: NEG
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 0
34442: PUSH
34443: LD_INT 2
34445: NEG
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: PUSH
34454: LD_INT 1
34456: NEG
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 2
34464: PUSH
34465: LD_INT 1
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 2
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 1
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 0
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 1
34504: NEG
34505: PUSH
34506: LD_INT 1
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: LD_INT 2
34515: NEG
34516: PUSH
34517: LD_INT 0
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 2
34526: NEG
34527: PUSH
34528: LD_INT 1
34530: NEG
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 1
34538: NEG
34539: PUSH
34540: LD_INT 3
34542: NEG
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PUSH
34548: LD_INT 1
34550: PUSH
34551: LD_INT 2
34553: NEG
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 3
34561: PUSH
34562: LD_INT 2
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: PUSH
34569: LD_INT 2
34571: PUSH
34572: LD_INT 3
34574: PUSH
34575: EMPTY
34576: LIST
34577: LIST
34578: PUSH
34579: LD_INT 2
34581: NEG
34582: PUSH
34583: LD_INT 1
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 3
34592: NEG
34593: PUSH
34594: LD_INT 1
34596: NEG
34597: PUSH
34598: EMPTY
34599: LIST
34600: LIST
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: LIST
34606: LIST
34607: LIST
34608: LIST
34609: LIST
34610: LIST
34611: LIST
34612: LIST
34613: LIST
34614: LIST
34615: LIST
34616: LIST
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: LIST
34625: LIST
34626: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34627: LD_ADDR_VAR 0 33
34631: PUSH
34632: LD_INT 0
34634: PUSH
34635: LD_INT 0
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 0
34644: PUSH
34645: LD_INT 1
34647: NEG
34648: PUSH
34649: EMPTY
34650: LIST
34651: LIST
34652: PUSH
34653: LD_INT 1
34655: PUSH
34656: LD_INT 0
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 1
34665: PUSH
34666: LD_INT 1
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 0
34675: PUSH
34676: LD_INT 1
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 1
34685: NEG
34686: PUSH
34687: LD_INT 0
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 1
34696: NEG
34697: PUSH
34698: LD_INT 1
34700: NEG
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: PUSH
34706: LD_INT 1
34708: NEG
34709: PUSH
34710: LD_INT 2
34712: NEG
34713: PUSH
34714: EMPTY
34715: LIST
34716: LIST
34717: PUSH
34718: LD_INT 1
34720: PUSH
34721: LD_INT 1
34723: NEG
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 2
34731: PUSH
34732: LD_INT 0
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 2
34741: PUSH
34742: LD_INT 1
34744: PUSH
34745: EMPTY
34746: LIST
34747: LIST
34748: PUSH
34749: LD_INT 1
34751: PUSH
34752: LD_INT 2
34754: PUSH
34755: EMPTY
34756: LIST
34757: LIST
34758: PUSH
34759: LD_INT 0
34761: PUSH
34762: LD_INT 2
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: PUSH
34769: LD_INT 1
34771: NEG
34772: PUSH
34773: LD_INT 1
34775: PUSH
34776: EMPTY
34777: LIST
34778: LIST
34779: PUSH
34780: LD_INT 2
34782: NEG
34783: PUSH
34784: LD_INT 0
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: LD_INT 2
34793: NEG
34794: PUSH
34795: LD_INT 1
34797: NEG
34798: PUSH
34799: EMPTY
34800: LIST
34801: LIST
34802: PUSH
34803: LD_INT 2
34805: NEG
34806: PUSH
34807: LD_INT 2
34809: NEG
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PUSH
34815: LD_INT 2
34817: NEG
34818: PUSH
34819: LD_INT 3
34821: NEG
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 2
34829: PUSH
34830: LD_INT 1
34832: NEG
34833: PUSH
34834: EMPTY
34835: LIST
34836: LIST
34837: PUSH
34838: LD_INT 3
34840: PUSH
34841: LD_INT 1
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 1
34850: PUSH
34851: LD_INT 3
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 1
34860: NEG
34861: PUSH
34862: LD_INT 2
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 3
34871: NEG
34872: PUSH
34873: LD_INT 2
34875: NEG
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: LIST
34903: LIST
34904: LIST
34905: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34906: LD_ADDR_VAR 0 34
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: LD_INT 0
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 0
34923: PUSH
34924: LD_INT 1
34926: NEG
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 1
34934: PUSH
34935: LD_INT 0
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 1
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 0
34954: PUSH
34955: LD_INT 1
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 1
34964: NEG
34965: PUSH
34966: LD_INT 0
34968: PUSH
34969: EMPTY
34970: LIST
34971: LIST
34972: PUSH
34973: LD_INT 1
34975: NEG
34976: PUSH
34977: LD_INT 1
34979: NEG
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: LD_INT 2
34991: NEG
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 0
34999: PUSH
35000: LD_INT 2
35002: NEG
35003: PUSH
35004: EMPTY
35005: LIST
35006: LIST
35007: PUSH
35008: LD_INT 1
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 2
35021: PUSH
35022: LD_INT 1
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: PUSH
35029: LD_INT 2
35031: PUSH
35032: LD_INT 2
35034: PUSH
35035: EMPTY
35036: LIST
35037: LIST
35038: PUSH
35039: LD_INT 1
35041: PUSH
35042: LD_INT 2
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: PUSH
35049: LD_INT 1
35051: NEG
35052: PUSH
35053: LD_INT 1
35055: PUSH
35056: EMPTY
35057: LIST
35058: LIST
35059: PUSH
35060: LD_INT 2
35062: NEG
35063: PUSH
35064: LD_INT 0
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 2
35073: NEG
35074: PUSH
35075: LD_INT 1
35077: NEG
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: LD_INT 2
35085: NEG
35086: PUSH
35087: LD_INT 2
35089: NEG
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 1
35097: NEG
35098: PUSH
35099: LD_INT 3
35101: NEG
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 1
35109: PUSH
35110: LD_INT 2
35112: NEG
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 3
35120: PUSH
35121: LD_INT 2
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 2
35130: PUSH
35131: LD_INT 3
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 2
35140: NEG
35141: PUSH
35142: LD_INT 1
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: PUSH
35149: LD_INT 3
35151: NEG
35152: PUSH
35153: LD_INT 1
35155: NEG
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: LIST
35165: LIST
35166: LIST
35167: LIST
35168: LIST
35169: LIST
35170: LIST
35171: LIST
35172: LIST
35173: LIST
35174: LIST
35175: LIST
35176: LIST
35177: LIST
35178: LIST
35179: LIST
35180: LIST
35181: LIST
35182: LIST
35183: LIST
35184: LIST
35185: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35186: LD_ADDR_VAR 0 35
35190: PUSH
35191: LD_INT 0
35193: PUSH
35194: LD_INT 0
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 0
35203: PUSH
35204: LD_INT 1
35206: NEG
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 1
35214: PUSH
35215: LD_INT 0
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: LD_INT 1
35224: PUSH
35225: LD_INT 1
35227: PUSH
35228: EMPTY
35229: LIST
35230: LIST
35231: PUSH
35232: LD_INT 0
35234: PUSH
35235: LD_INT 1
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PUSH
35242: LD_INT 1
35244: NEG
35245: PUSH
35246: LD_INT 0
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 1
35255: NEG
35256: PUSH
35257: LD_INT 1
35259: NEG
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 2
35267: PUSH
35268: LD_INT 1
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 2
35277: NEG
35278: PUSH
35279: LD_INT 1
35281: NEG
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35298: LD_ADDR_VAR 0 36
35302: PUSH
35303: LD_INT 0
35305: PUSH
35306: LD_INT 0
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 0
35315: PUSH
35316: LD_INT 1
35318: NEG
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: LD_INT 0
35329: PUSH
35330: EMPTY
35331: LIST
35332: LIST
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: LD_INT 1
35339: PUSH
35340: EMPTY
35341: LIST
35342: LIST
35343: PUSH
35344: LD_INT 0
35346: PUSH
35347: LD_INT 1
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 1
35356: NEG
35357: PUSH
35358: LD_INT 0
35360: PUSH
35361: EMPTY
35362: LIST
35363: LIST
35364: PUSH
35365: LD_INT 1
35367: NEG
35368: PUSH
35369: LD_INT 1
35371: NEG
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 1
35379: NEG
35380: PUSH
35381: LD_INT 2
35383: NEG
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 1
35391: PUSH
35392: LD_INT 2
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: LIST
35403: LIST
35404: LIST
35405: LIST
35406: LIST
35407: LIST
35408: LIST
35409: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35410: LD_ADDR_VAR 0 37
35414: PUSH
35415: LD_INT 0
35417: PUSH
35418: LD_INT 0
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 0
35427: PUSH
35428: LD_INT 1
35430: NEG
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 1
35438: PUSH
35439: LD_INT 0
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: PUSH
35446: LD_INT 1
35448: PUSH
35449: LD_INT 1
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: LD_INT 0
35458: PUSH
35459: LD_INT 1
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: LD_INT 0
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 1
35479: NEG
35480: PUSH
35481: LD_INT 1
35483: NEG
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 1
35491: PUSH
35492: LD_INT 1
35494: NEG
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 1
35502: NEG
35503: PUSH
35504: LD_INT 1
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: LIST
35515: LIST
35516: LIST
35517: LIST
35518: LIST
35519: LIST
35520: LIST
35521: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35522: LD_ADDR_VAR 0 38
35526: PUSH
35527: LD_INT 0
35529: PUSH
35530: LD_INT 0
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 0
35539: PUSH
35540: LD_INT 1
35542: NEG
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 1
35550: PUSH
35551: LD_INT 0
35553: PUSH
35554: EMPTY
35555: LIST
35556: LIST
35557: PUSH
35558: LD_INT 1
35560: PUSH
35561: LD_INT 1
35563: PUSH
35564: EMPTY
35565: LIST
35566: LIST
35567: PUSH
35568: LD_INT 0
35570: PUSH
35571: LD_INT 1
35573: PUSH
35574: EMPTY
35575: LIST
35576: LIST
35577: PUSH
35578: LD_INT 1
35580: NEG
35581: PUSH
35582: LD_INT 0
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: LD_INT 1
35591: NEG
35592: PUSH
35593: LD_INT 1
35595: NEG
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 2
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 2
35613: NEG
35614: PUSH
35615: LD_INT 1
35617: NEG
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: LIST
35627: LIST
35628: LIST
35629: LIST
35630: LIST
35631: LIST
35632: LIST
35633: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35634: LD_ADDR_VAR 0 39
35638: PUSH
35639: LD_INT 0
35641: PUSH
35642: LD_INT 0
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 0
35651: PUSH
35652: LD_INT 1
35654: NEG
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 1
35662: PUSH
35663: LD_INT 0
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: PUSH
35670: LD_INT 1
35672: PUSH
35673: LD_INT 1
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 0
35682: PUSH
35683: LD_INT 1
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 1
35692: NEG
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 1
35703: NEG
35704: PUSH
35705: LD_INT 1
35707: NEG
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: PUSH
35713: LD_INT 1
35715: NEG
35716: PUSH
35717: LD_INT 2
35719: NEG
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 1
35727: PUSH
35728: LD_INT 2
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: EMPTY
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: LIST
35745: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35746: LD_ADDR_VAR 0 40
35750: PUSH
35751: LD_INT 0
35753: PUSH
35754: LD_INT 0
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 0
35763: PUSH
35764: LD_INT 1
35766: NEG
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: PUSH
35775: LD_INT 0
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: PUSH
35782: LD_INT 1
35784: PUSH
35785: LD_INT 1
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: PUSH
35792: LD_INT 0
35794: PUSH
35795: LD_INT 1
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 1
35804: NEG
35805: PUSH
35806: LD_INT 0
35808: PUSH
35809: EMPTY
35810: LIST
35811: LIST
35812: PUSH
35813: LD_INT 1
35815: NEG
35816: PUSH
35817: LD_INT 1
35819: NEG
35820: PUSH
35821: EMPTY
35822: LIST
35823: LIST
35824: PUSH
35825: LD_INT 1
35827: PUSH
35828: LD_INT 1
35830: NEG
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PUSH
35836: LD_INT 1
35838: NEG
35839: PUSH
35840: LD_INT 1
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: LIST
35856: LIST
35857: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35858: LD_ADDR_VAR 0 41
35862: PUSH
35863: LD_INT 0
35865: PUSH
35866: LD_INT 0
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PUSH
35873: LD_INT 0
35875: PUSH
35876: LD_INT 1
35878: NEG
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: PUSH
35884: LD_INT 1
35886: PUSH
35887: LD_INT 0
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 1
35896: PUSH
35897: LD_INT 1
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 0
35906: PUSH
35907: LD_INT 1
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 1
35916: NEG
35917: PUSH
35918: LD_INT 0
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 1
35927: NEG
35928: PUSH
35929: LD_INT 1
35931: NEG
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 1
35939: NEG
35940: PUSH
35941: LD_INT 2
35943: NEG
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 1
35951: PUSH
35952: LD_INT 1
35954: NEG
35955: PUSH
35956: EMPTY
35957: LIST
35958: LIST
35959: PUSH
35960: LD_INT 2
35962: PUSH
35963: LD_INT 0
35965: PUSH
35966: EMPTY
35967: LIST
35968: LIST
35969: PUSH
35970: LD_INT 2
35972: PUSH
35973: LD_INT 1
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: LD_INT 2
35982: PUSH
35983: LD_INT 2
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: LD_INT 1
35992: PUSH
35993: LD_INT 2
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 1
36002: NEG
36003: PUSH
36004: LD_INT 1
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 2
36013: NEG
36014: PUSH
36015: LD_INT 0
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 2
36024: NEG
36025: PUSH
36026: LD_INT 1
36028: NEG
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: LD_INT 2
36036: NEG
36037: PUSH
36038: LD_INT 2
36040: NEG
36041: PUSH
36042: EMPTY
36043: LIST
36044: LIST
36045: PUSH
36046: LD_INT 2
36048: NEG
36049: PUSH
36050: LD_INT 3
36052: NEG
36053: PUSH
36054: EMPTY
36055: LIST
36056: LIST
36057: PUSH
36058: LD_INT 2
36060: PUSH
36061: LD_INT 1
36063: NEG
36064: PUSH
36065: EMPTY
36066: LIST
36067: LIST
36068: PUSH
36069: LD_INT 3
36071: PUSH
36072: LD_INT 0
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 3
36081: PUSH
36082: LD_INT 1
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 3
36091: PUSH
36092: LD_INT 2
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 3
36101: PUSH
36102: LD_INT 3
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 2
36111: PUSH
36112: LD_INT 3
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 2
36121: NEG
36122: PUSH
36123: LD_INT 1
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 3
36132: NEG
36133: PUSH
36134: LD_INT 0
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 3
36143: NEG
36144: PUSH
36145: LD_INT 1
36147: NEG
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 3
36155: NEG
36156: PUSH
36157: LD_INT 2
36159: NEG
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 3
36167: NEG
36168: PUSH
36169: LD_INT 3
36171: NEG
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: EMPTY
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: LIST
36200: LIST
36201: LIST
36202: LIST
36203: LIST
36204: LIST
36205: LIST
36206: LIST
36207: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36208: LD_ADDR_VAR 0 42
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: LD_INT 0
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: LD_INT 0
36225: PUSH
36226: LD_INT 1
36228: NEG
36229: PUSH
36230: EMPTY
36231: LIST
36232: LIST
36233: PUSH
36234: LD_INT 1
36236: PUSH
36237: LD_INT 0
36239: PUSH
36240: EMPTY
36241: LIST
36242: LIST
36243: PUSH
36244: LD_INT 1
36246: PUSH
36247: LD_INT 1
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: LD_INT 0
36256: PUSH
36257: LD_INT 1
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 1
36266: NEG
36267: PUSH
36268: LD_INT 0
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: PUSH
36275: LD_INT 1
36277: NEG
36278: PUSH
36279: LD_INT 1
36281: NEG
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: LD_INT 2
36293: NEG
36294: PUSH
36295: EMPTY
36296: LIST
36297: LIST
36298: PUSH
36299: LD_INT 0
36301: PUSH
36302: LD_INT 2
36304: NEG
36305: PUSH
36306: EMPTY
36307: LIST
36308: LIST
36309: PUSH
36310: LD_INT 1
36312: PUSH
36313: LD_INT 1
36315: NEG
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 2
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 2
36333: PUSH
36334: LD_INT 2
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: PUSH
36341: LD_INT 1
36343: PUSH
36344: LD_INT 2
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 0
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 1
36363: NEG
36364: PUSH
36365: LD_INT 1
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 2
36374: NEG
36375: PUSH
36376: LD_INT 1
36378: NEG
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PUSH
36384: LD_INT 2
36386: NEG
36387: PUSH
36388: LD_INT 2
36390: NEG
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 2
36398: NEG
36399: PUSH
36400: LD_INT 3
36402: NEG
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 1
36410: NEG
36411: PUSH
36412: LD_INT 3
36414: NEG
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 0
36422: PUSH
36423: LD_INT 3
36425: NEG
36426: PUSH
36427: EMPTY
36428: LIST
36429: LIST
36430: PUSH
36431: LD_INT 1
36433: PUSH
36434: LD_INT 2
36436: NEG
36437: PUSH
36438: EMPTY
36439: LIST
36440: LIST
36441: PUSH
36442: LD_INT 3
36444: PUSH
36445: LD_INT 2
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: PUSH
36452: LD_INT 3
36454: PUSH
36455: LD_INT 3
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: PUSH
36462: LD_INT 2
36464: PUSH
36465: LD_INT 3
36467: PUSH
36468: EMPTY
36469: LIST
36470: LIST
36471: PUSH
36472: LD_INT 1
36474: PUSH
36475: LD_INT 3
36477: PUSH
36478: EMPTY
36479: LIST
36480: LIST
36481: PUSH
36482: LD_INT 0
36484: PUSH
36485: LD_INT 3
36487: PUSH
36488: EMPTY
36489: LIST
36490: LIST
36491: PUSH
36492: LD_INT 1
36494: NEG
36495: PUSH
36496: LD_INT 2
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 3
36505: NEG
36506: PUSH
36507: LD_INT 2
36509: NEG
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 3
36517: NEG
36518: PUSH
36519: LD_INT 3
36521: NEG
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: LIST
36537: LIST
36538: LIST
36539: LIST
36540: LIST
36541: LIST
36542: LIST
36543: LIST
36544: LIST
36545: LIST
36546: LIST
36547: LIST
36548: LIST
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: LIST
36555: LIST
36556: LIST
36557: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36558: LD_ADDR_VAR 0 43
36562: PUSH
36563: LD_INT 0
36565: PUSH
36566: LD_INT 0
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 0
36575: PUSH
36576: LD_INT 1
36578: NEG
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: LD_INT 1
36586: PUSH
36587: LD_INT 0
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 1
36596: PUSH
36597: LD_INT 1
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 0
36606: PUSH
36607: LD_INT 1
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 1
36616: NEG
36617: PUSH
36618: LD_INT 0
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 1
36627: NEG
36628: PUSH
36629: LD_INT 1
36631: NEG
36632: PUSH
36633: EMPTY
36634: LIST
36635: LIST
36636: PUSH
36637: LD_INT 1
36639: NEG
36640: PUSH
36641: LD_INT 2
36643: NEG
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: PUSH
36649: LD_INT 0
36651: PUSH
36652: LD_INT 2
36654: NEG
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 1
36662: PUSH
36663: LD_INT 1
36665: NEG
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 2
36673: PUSH
36674: LD_INT 0
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 2
36683: PUSH
36684: LD_INT 1
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 1
36693: PUSH
36694: LD_INT 2
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 0
36703: PUSH
36704: LD_INT 2
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: NEG
36714: PUSH
36715: LD_INT 1
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 2
36724: NEG
36725: PUSH
36726: LD_INT 0
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 2
36735: NEG
36736: PUSH
36737: LD_INT 1
36739: NEG
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: LD_INT 1
36747: NEG
36748: PUSH
36749: LD_INT 3
36751: NEG
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 0
36759: PUSH
36760: LD_INT 3
36762: NEG
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 1
36770: PUSH
36771: LD_INT 2
36773: NEG
36774: PUSH
36775: EMPTY
36776: LIST
36777: LIST
36778: PUSH
36779: LD_INT 2
36781: PUSH
36782: LD_INT 1
36784: NEG
36785: PUSH
36786: EMPTY
36787: LIST
36788: LIST
36789: PUSH
36790: LD_INT 3
36792: PUSH
36793: LD_INT 0
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: LD_INT 3
36802: PUSH
36803: LD_INT 1
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: PUSH
36810: LD_INT 1
36812: PUSH
36813: LD_INT 3
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: PUSH
36820: LD_INT 0
36822: PUSH
36823: LD_INT 3
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: PUSH
36830: LD_INT 1
36832: NEG
36833: PUSH
36834: LD_INT 2
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 2
36843: NEG
36844: PUSH
36845: LD_INT 1
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 3
36854: NEG
36855: PUSH
36856: LD_INT 0
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PUSH
36863: LD_INT 3
36865: NEG
36866: PUSH
36867: LD_INT 1
36869: NEG
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: LIST
36882: LIST
36883: LIST
36884: LIST
36885: LIST
36886: LIST
36887: LIST
36888: LIST
36889: LIST
36890: LIST
36891: LIST
36892: LIST
36893: LIST
36894: LIST
36895: LIST
36896: LIST
36897: LIST
36898: LIST
36899: LIST
36900: LIST
36901: LIST
36902: LIST
36903: LIST
36904: LIST
36905: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36906: LD_ADDR_VAR 0 44
36910: PUSH
36911: LD_INT 0
36913: PUSH
36914: LD_INT 0
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: LD_INT 0
36923: PUSH
36924: LD_INT 1
36926: NEG
36927: PUSH
36928: EMPTY
36929: LIST
36930: LIST
36931: PUSH
36932: LD_INT 1
36934: PUSH
36935: LD_INT 0
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: LD_INT 1
36944: PUSH
36945: LD_INT 1
36947: PUSH
36948: EMPTY
36949: LIST
36950: LIST
36951: PUSH
36952: LD_INT 0
36954: PUSH
36955: LD_INT 1
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 1
36964: NEG
36965: PUSH
36966: LD_INT 0
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 1
36975: NEG
36976: PUSH
36977: LD_INT 1
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 1
36987: NEG
36988: PUSH
36989: LD_INT 2
36991: NEG
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 1
36999: PUSH
37000: LD_INT 1
37002: NEG
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 2
37010: PUSH
37011: LD_INT 0
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 2
37020: PUSH
37021: LD_INT 1
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 2
37030: PUSH
37031: LD_INT 2
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 1
37040: PUSH
37041: LD_INT 2
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 1
37050: NEG
37051: PUSH
37052: LD_INT 1
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: LD_INT 2
37061: NEG
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 2
37072: NEG
37073: PUSH
37074: LD_INT 1
37076: NEG
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 2
37084: NEG
37085: PUSH
37086: LD_INT 2
37088: NEG
37089: PUSH
37090: EMPTY
37091: LIST
37092: LIST
37093: PUSH
37094: LD_INT 2
37096: NEG
37097: PUSH
37098: LD_INT 3
37100: NEG
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: LD_INT 2
37108: PUSH
37109: LD_INT 1
37111: NEG
37112: PUSH
37113: EMPTY
37114: LIST
37115: LIST
37116: PUSH
37117: LD_INT 3
37119: PUSH
37120: LD_INT 0
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: LD_INT 3
37129: PUSH
37130: LD_INT 1
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 3
37139: PUSH
37140: LD_INT 2
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 3
37149: PUSH
37150: LD_INT 3
37152: PUSH
37153: EMPTY
37154: LIST
37155: LIST
37156: PUSH
37157: LD_INT 2
37159: PUSH
37160: LD_INT 3
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 2
37169: NEG
37170: PUSH
37171: LD_INT 1
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: PUSH
37178: LD_INT 3
37180: NEG
37181: PUSH
37182: LD_INT 0
37184: PUSH
37185: EMPTY
37186: LIST
37187: LIST
37188: PUSH
37189: LD_INT 3
37191: NEG
37192: PUSH
37193: LD_INT 1
37195: NEG
37196: PUSH
37197: EMPTY
37198: LIST
37199: LIST
37200: PUSH
37201: LD_INT 3
37203: NEG
37204: PUSH
37205: LD_INT 2
37207: NEG
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 3
37215: NEG
37216: PUSH
37217: LD_INT 3
37219: NEG
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: LIST
37239: LIST
37240: LIST
37241: LIST
37242: LIST
37243: LIST
37244: LIST
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: LIST
37250: LIST
37251: LIST
37252: LIST
37253: LIST
37254: LIST
37255: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37256: LD_ADDR_VAR 0 45
37260: PUSH
37261: LD_INT 0
37263: PUSH
37264: LD_INT 0
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 0
37273: PUSH
37274: LD_INT 1
37276: NEG
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 1
37284: PUSH
37285: LD_INT 0
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 1
37294: PUSH
37295: LD_INT 1
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 0
37304: PUSH
37305: LD_INT 1
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 1
37314: NEG
37315: PUSH
37316: LD_INT 0
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 1
37325: NEG
37326: PUSH
37327: LD_INT 1
37329: NEG
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 1
37337: NEG
37338: PUSH
37339: LD_INT 2
37341: NEG
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 0
37349: PUSH
37350: LD_INT 2
37352: NEG
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: LD_INT 1
37360: PUSH
37361: LD_INT 1
37363: NEG
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 2
37371: PUSH
37372: LD_INT 1
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 2
37381: PUSH
37382: LD_INT 2
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 1
37391: PUSH
37392: LD_INT 2
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 0
37401: PUSH
37402: LD_INT 2
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: LD_INT 1
37411: NEG
37412: PUSH
37413: LD_INT 1
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: LD_INT 2
37422: NEG
37423: PUSH
37424: LD_INT 1
37426: NEG
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 2
37434: NEG
37435: PUSH
37436: LD_INT 2
37438: NEG
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 2
37446: NEG
37447: PUSH
37448: LD_INT 3
37450: NEG
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 1
37458: NEG
37459: PUSH
37460: LD_INT 3
37462: NEG
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: LD_INT 0
37470: PUSH
37471: LD_INT 3
37473: NEG
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 1
37481: PUSH
37482: LD_INT 2
37484: NEG
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 3
37492: PUSH
37493: LD_INT 2
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: LD_INT 3
37502: PUSH
37503: LD_INT 3
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 2
37512: PUSH
37513: LD_INT 3
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 1
37522: PUSH
37523: LD_INT 3
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 0
37532: PUSH
37533: LD_INT 3
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: NEG
37543: PUSH
37544: LD_INT 2
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 3
37553: NEG
37554: PUSH
37555: LD_INT 2
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 3
37565: NEG
37566: PUSH
37567: LD_INT 3
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: LIST
37592: LIST
37593: LIST
37594: LIST
37595: LIST
37596: LIST
37597: LIST
37598: LIST
37599: LIST
37600: LIST
37601: LIST
37602: LIST
37603: LIST
37604: LIST
37605: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37606: LD_ADDR_VAR 0 46
37610: PUSH
37611: LD_INT 0
37613: PUSH
37614: LD_INT 0
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 0
37623: PUSH
37624: LD_INT 1
37626: NEG
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: LD_INT 1
37634: PUSH
37635: LD_INT 0
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 1
37644: PUSH
37645: LD_INT 1
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 0
37654: PUSH
37655: LD_INT 1
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: LD_INT 0
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: PUSH
37673: LD_INT 1
37675: NEG
37676: PUSH
37677: LD_INT 1
37679: NEG
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: LD_INT 1
37687: NEG
37688: PUSH
37689: LD_INT 2
37691: NEG
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 0
37699: PUSH
37700: LD_INT 2
37702: NEG
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 1
37710: PUSH
37711: LD_INT 1
37713: NEG
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: PUSH
37719: LD_INT 2
37721: PUSH
37722: LD_INT 0
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: LD_INT 2
37731: PUSH
37732: LD_INT 1
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PUSH
37739: LD_INT 1
37741: PUSH
37742: LD_INT 2
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: PUSH
37749: LD_INT 0
37751: PUSH
37752: LD_INT 2
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 1
37761: NEG
37762: PUSH
37763: LD_INT 1
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 2
37772: NEG
37773: PUSH
37774: LD_INT 0
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PUSH
37781: LD_INT 2
37783: NEG
37784: PUSH
37785: LD_INT 1
37787: NEG
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: LD_INT 3
37799: NEG
37800: PUSH
37801: EMPTY
37802: LIST
37803: LIST
37804: PUSH
37805: LD_INT 0
37807: PUSH
37808: LD_INT 3
37810: NEG
37811: PUSH
37812: EMPTY
37813: LIST
37814: LIST
37815: PUSH
37816: LD_INT 1
37818: PUSH
37819: LD_INT 2
37821: NEG
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: LD_INT 2
37829: PUSH
37830: LD_INT 1
37832: NEG
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 3
37840: PUSH
37841: LD_INT 0
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 3
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 1
37860: PUSH
37861: LD_INT 3
37863: PUSH
37864: EMPTY
37865: LIST
37866: LIST
37867: PUSH
37868: LD_INT 0
37870: PUSH
37871: LD_INT 3
37873: PUSH
37874: EMPTY
37875: LIST
37876: LIST
37877: PUSH
37878: LD_INT 1
37880: NEG
37881: PUSH
37882: LD_INT 2
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: LD_INT 2
37891: NEG
37892: PUSH
37893: LD_INT 1
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 3
37902: NEG
37903: PUSH
37904: LD_INT 0
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 3
37913: NEG
37914: PUSH
37915: LD_INT 1
37917: NEG
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: LIST
37927: LIST
37928: LIST
37929: LIST
37930: LIST
37931: LIST
37932: LIST
37933: LIST
37934: LIST
37935: LIST
37936: LIST
37937: LIST
37938: LIST
37939: LIST
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: LIST
37949: LIST
37950: LIST
37951: LIST
37952: LIST
37953: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37954: LD_ADDR_VAR 0 47
37958: PUSH
37959: LD_INT 0
37961: PUSH
37962: LD_INT 0
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: PUSH
37969: LD_INT 0
37971: PUSH
37972: LD_INT 1
37974: NEG
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: PUSH
37980: LD_INT 1
37982: PUSH
37983: LD_INT 0
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 1
37992: PUSH
37993: LD_INT 1
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 0
38002: PUSH
38003: LD_INT 1
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 1
38012: NEG
38013: PUSH
38014: LD_INT 0
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 1
38023: NEG
38024: PUSH
38025: LD_INT 1
38027: NEG
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: LD_INT 1
38035: NEG
38036: PUSH
38037: LD_INT 2
38039: NEG
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 0
38047: PUSH
38048: LD_INT 2
38050: NEG
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: PUSH
38059: LD_INT 1
38061: NEG
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 2
38069: NEG
38070: PUSH
38071: LD_INT 1
38073: NEG
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 2
38081: NEG
38082: PUSH
38083: LD_INT 2
38085: NEG
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: LIST
38095: LIST
38096: LIST
38097: LIST
38098: LIST
38099: LIST
38100: LIST
38101: LIST
38102: LIST
38103: LIST
38104: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38105: LD_ADDR_VAR 0 48
38109: PUSH
38110: LD_INT 0
38112: PUSH
38113: LD_INT 0
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 0
38122: PUSH
38123: LD_INT 1
38125: NEG
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 1
38133: PUSH
38134: LD_INT 0
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: PUSH
38141: LD_INT 1
38143: PUSH
38144: LD_INT 1
38146: PUSH
38147: EMPTY
38148: LIST
38149: LIST
38150: PUSH
38151: LD_INT 0
38153: PUSH
38154: LD_INT 1
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 1
38163: NEG
38164: PUSH
38165: LD_INT 0
38167: PUSH
38168: EMPTY
38169: LIST
38170: LIST
38171: PUSH
38172: LD_INT 1
38174: NEG
38175: PUSH
38176: LD_INT 1
38178: NEG
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 1
38186: NEG
38187: PUSH
38188: LD_INT 2
38190: NEG
38191: PUSH
38192: EMPTY
38193: LIST
38194: LIST
38195: PUSH
38196: LD_INT 0
38198: PUSH
38199: LD_INT 2
38201: NEG
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: LD_INT 1
38209: PUSH
38210: LD_INT 1
38212: NEG
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 2
38220: PUSH
38221: LD_INT 0
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 2
38230: PUSH
38231: LD_INT 1
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: LIST
38247: LIST
38248: LIST
38249: LIST
38250: LIST
38251: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38252: LD_ADDR_VAR 0 49
38256: PUSH
38257: LD_INT 0
38259: PUSH
38260: LD_INT 0
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 0
38269: PUSH
38270: LD_INT 1
38272: NEG
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 1
38280: PUSH
38281: LD_INT 0
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 1
38290: PUSH
38291: LD_INT 1
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 0
38300: PUSH
38301: LD_INT 1
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: LD_INT 1
38310: NEG
38311: PUSH
38312: LD_INT 0
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 1
38321: NEG
38322: PUSH
38323: LD_INT 1
38325: NEG
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 1
38333: PUSH
38334: LD_INT 1
38336: NEG
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 2
38344: PUSH
38345: LD_INT 0
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 2
38354: PUSH
38355: LD_INT 1
38357: PUSH
38358: EMPTY
38359: LIST
38360: LIST
38361: PUSH
38362: LD_INT 2
38364: PUSH
38365: LD_INT 2
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 1
38374: PUSH
38375: LD_INT 2
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: LIST
38386: LIST
38387: LIST
38388: LIST
38389: LIST
38390: LIST
38391: LIST
38392: LIST
38393: LIST
38394: LIST
38395: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38396: LD_ADDR_VAR 0 50
38400: PUSH
38401: LD_INT 0
38403: PUSH
38404: LD_INT 0
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: PUSH
38411: LD_INT 0
38413: PUSH
38414: LD_INT 1
38416: NEG
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 1
38424: PUSH
38425: LD_INT 0
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PUSH
38432: LD_INT 1
38434: PUSH
38435: LD_INT 1
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 0
38444: PUSH
38445: LD_INT 1
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 1
38454: NEG
38455: PUSH
38456: LD_INT 0
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 1
38465: NEG
38466: PUSH
38467: LD_INT 1
38469: NEG
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: PUSH
38475: LD_INT 2
38477: PUSH
38478: LD_INT 1
38480: PUSH
38481: EMPTY
38482: LIST
38483: LIST
38484: PUSH
38485: LD_INT 2
38487: PUSH
38488: LD_INT 2
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 1
38497: PUSH
38498: LD_INT 2
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: PUSH
38505: LD_INT 0
38507: PUSH
38508: LD_INT 2
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: LD_INT 1
38517: NEG
38518: PUSH
38519: LD_INT 1
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38540: LD_ADDR_VAR 0 51
38544: PUSH
38545: LD_INT 0
38547: PUSH
38548: LD_INT 0
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: LD_INT 1
38560: NEG
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 1
38568: PUSH
38569: LD_INT 0
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: PUSH
38579: LD_INT 1
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: LD_INT 1
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 1
38598: NEG
38599: PUSH
38600: LD_INT 0
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 1
38609: NEG
38610: PUSH
38611: LD_INT 1
38613: NEG
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: PUSH
38619: LD_INT 1
38621: PUSH
38622: LD_INT 2
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 0
38631: PUSH
38632: LD_INT 2
38634: PUSH
38635: EMPTY
38636: LIST
38637: LIST
38638: PUSH
38639: LD_INT 1
38641: NEG
38642: PUSH
38643: LD_INT 1
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: PUSH
38650: LD_INT 2
38652: NEG
38653: PUSH
38654: LD_INT 0
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 2
38663: NEG
38664: PUSH
38665: LD_INT 1
38667: NEG
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: LIST
38677: LIST
38678: LIST
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: LIST
38686: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38687: LD_ADDR_VAR 0 52
38691: PUSH
38692: LD_INT 0
38694: PUSH
38695: LD_INT 0
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 0
38704: PUSH
38705: LD_INT 1
38707: NEG
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PUSH
38713: LD_INT 1
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: EMPTY
38720: LIST
38721: LIST
38722: PUSH
38723: LD_INT 1
38725: PUSH
38726: LD_INT 1
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PUSH
38733: LD_INT 0
38735: PUSH
38736: LD_INT 1
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 1
38745: NEG
38746: PUSH
38747: LD_INT 0
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 1
38756: NEG
38757: PUSH
38758: LD_INT 1
38760: NEG
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 1
38768: NEG
38769: PUSH
38770: LD_INT 2
38772: NEG
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 1
38780: NEG
38781: PUSH
38782: LD_INT 1
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 2
38791: NEG
38792: PUSH
38793: LD_INT 0
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 2
38802: NEG
38803: PUSH
38804: LD_INT 1
38806: NEG
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 2
38814: NEG
38815: PUSH
38816: LD_INT 2
38818: NEG
38819: PUSH
38820: EMPTY
38821: LIST
38822: LIST
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: LIST
38834: LIST
38835: LIST
38836: LIST
38837: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38838: LD_ADDR_VAR 0 53
38842: PUSH
38843: LD_INT 0
38845: PUSH
38846: LD_INT 0
38848: PUSH
38849: EMPTY
38850: LIST
38851: LIST
38852: PUSH
38853: LD_INT 0
38855: PUSH
38856: LD_INT 1
38858: NEG
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: PUSH
38864: LD_INT 1
38866: PUSH
38867: LD_INT 0
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 1
38876: PUSH
38877: LD_INT 1
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 0
38886: PUSH
38887: LD_INT 1
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 1
38896: NEG
38897: PUSH
38898: LD_INT 0
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: LD_INT 1
38907: NEG
38908: PUSH
38909: LD_INT 1
38911: NEG
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 1
38919: NEG
38920: PUSH
38921: LD_INT 2
38923: NEG
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: LD_INT 0
38931: PUSH
38932: LD_INT 2
38934: NEG
38935: PUSH
38936: EMPTY
38937: LIST
38938: LIST
38939: PUSH
38940: LD_INT 1
38942: PUSH
38943: LD_INT 1
38945: NEG
38946: PUSH
38947: EMPTY
38948: LIST
38949: LIST
38950: PUSH
38951: LD_INT 2
38953: PUSH
38954: LD_INT 0
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: PUSH
38961: LD_INT 2
38963: PUSH
38964: LD_INT 1
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 2
38973: PUSH
38974: LD_INT 2
38976: PUSH
38977: EMPTY
38978: LIST
38979: LIST
38980: PUSH
38981: LD_INT 1
38983: PUSH
38984: LD_INT 2
38986: PUSH
38987: EMPTY
38988: LIST
38989: LIST
38990: PUSH
38991: LD_INT 0
38993: PUSH
38994: LD_INT 2
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 1
39003: NEG
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 2
39014: NEG
39015: PUSH
39016: LD_INT 0
39018: PUSH
39019: EMPTY
39020: LIST
39021: LIST
39022: PUSH
39023: LD_INT 2
39025: NEG
39026: PUSH
39027: LD_INT 1
39029: NEG
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 2
39037: NEG
39038: PUSH
39039: LD_INT 2
39041: NEG
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39068: LD_ADDR_VAR 0 54
39072: PUSH
39073: LD_INT 0
39075: PUSH
39076: LD_INT 0
39078: PUSH
39079: EMPTY
39080: LIST
39081: LIST
39082: PUSH
39083: LD_INT 0
39085: PUSH
39086: LD_INT 1
39088: NEG
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: PUSH
39094: LD_INT 1
39096: PUSH
39097: LD_INT 0
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 1
39106: PUSH
39107: LD_INT 1
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PUSH
39114: LD_INT 0
39116: PUSH
39117: LD_INT 1
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 1
39126: NEG
39127: PUSH
39128: LD_INT 0
39130: PUSH
39131: EMPTY
39132: LIST
39133: LIST
39134: PUSH
39135: LD_INT 1
39137: NEG
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: LD_INT 1
39149: NEG
39150: PUSH
39151: LD_INT 2
39153: NEG
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 0
39161: PUSH
39162: LD_INT 2
39164: NEG
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 1
39172: PUSH
39173: LD_INT 1
39175: NEG
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: LD_INT 2
39183: PUSH
39184: LD_INT 0
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 2
39193: PUSH
39194: LD_INT 1
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 2
39203: PUSH
39204: LD_INT 2
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 1
39213: PUSH
39214: LD_INT 2
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 0
39223: PUSH
39224: LD_INT 2
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 1
39233: NEG
39234: PUSH
39235: LD_INT 1
39237: PUSH
39238: EMPTY
39239: LIST
39240: LIST
39241: PUSH
39242: LD_INT 2
39244: NEG
39245: PUSH
39246: LD_INT 0
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: PUSH
39253: LD_INT 2
39255: NEG
39256: PUSH
39257: LD_INT 1
39259: NEG
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: PUSH
39265: LD_INT 2
39267: NEG
39268: PUSH
39269: LD_INT 2
39271: NEG
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: LIST
39281: LIST
39282: LIST
39283: LIST
39284: LIST
39285: LIST
39286: LIST
39287: LIST
39288: LIST
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39298: LD_ADDR_VAR 0 55
39302: PUSH
39303: LD_INT 0
39305: PUSH
39306: LD_INT 0
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 0
39315: PUSH
39316: LD_INT 1
39318: NEG
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 1
39326: PUSH
39327: LD_INT 0
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: PUSH
39334: LD_INT 1
39336: PUSH
39337: LD_INT 1
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 0
39346: PUSH
39347: LD_INT 1
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 1
39356: NEG
39357: PUSH
39358: LD_INT 0
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PUSH
39365: LD_INT 1
39367: NEG
39368: PUSH
39369: LD_INT 1
39371: NEG
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: LD_INT 1
39379: NEG
39380: PUSH
39381: LD_INT 2
39383: NEG
39384: PUSH
39385: EMPTY
39386: LIST
39387: LIST
39388: PUSH
39389: LD_INT 0
39391: PUSH
39392: LD_INT 2
39394: NEG
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: PUSH
39400: LD_INT 1
39402: PUSH
39403: LD_INT 1
39405: NEG
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: LD_INT 2
39413: PUSH
39414: LD_INT 0
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 2
39423: PUSH
39424: LD_INT 1
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 2
39433: PUSH
39434: LD_INT 2
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PUSH
39441: LD_INT 1
39443: PUSH
39444: LD_INT 2
39446: PUSH
39447: EMPTY
39448: LIST
39449: LIST
39450: PUSH
39451: LD_INT 0
39453: PUSH
39454: LD_INT 2
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 1
39463: NEG
39464: PUSH
39465: LD_INT 1
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 2
39474: NEG
39475: PUSH
39476: LD_INT 0
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: LD_INT 2
39485: NEG
39486: PUSH
39487: LD_INT 1
39489: NEG
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 2
39497: NEG
39498: PUSH
39499: LD_INT 2
39501: NEG
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: LIST
39511: LIST
39512: LIST
39513: LIST
39514: LIST
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39528: LD_ADDR_VAR 0 56
39532: PUSH
39533: LD_INT 0
39535: PUSH
39536: LD_INT 0
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 0
39545: PUSH
39546: LD_INT 1
39548: NEG
39549: PUSH
39550: EMPTY
39551: LIST
39552: LIST
39553: PUSH
39554: LD_INT 1
39556: PUSH
39557: LD_INT 0
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 1
39566: PUSH
39567: LD_INT 1
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 0
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 1
39586: NEG
39587: PUSH
39588: LD_INT 0
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: LD_INT 1
39597: NEG
39598: PUSH
39599: LD_INT 1
39601: NEG
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: LD_INT 1
39609: NEG
39610: PUSH
39611: LD_INT 2
39613: NEG
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: LD_INT 0
39621: PUSH
39622: LD_INT 2
39624: NEG
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: LD_INT 1
39632: PUSH
39633: LD_INT 1
39635: NEG
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 2
39643: PUSH
39644: LD_INT 0
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: LD_INT 2
39653: PUSH
39654: LD_INT 1
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 2
39663: PUSH
39664: LD_INT 2
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 1
39673: PUSH
39674: LD_INT 2
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 0
39683: PUSH
39684: LD_INT 2
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: LD_INT 1
39693: NEG
39694: PUSH
39695: LD_INT 1
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 2
39704: NEG
39705: PUSH
39706: LD_INT 0
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PUSH
39713: LD_INT 2
39715: NEG
39716: PUSH
39717: LD_INT 1
39719: NEG
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 2
39727: NEG
39728: PUSH
39729: LD_INT 2
39731: NEG
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: LIST
39741: LIST
39742: LIST
39743: LIST
39744: LIST
39745: LIST
39746: LIST
39747: LIST
39748: LIST
39749: LIST
39750: LIST
39751: LIST
39752: LIST
39753: LIST
39754: LIST
39755: LIST
39756: LIST
39757: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39758: LD_ADDR_VAR 0 57
39762: PUSH
39763: LD_INT 0
39765: PUSH
39766: LD_INT 0
39768: PUSH
39769: EMPTY
39770: LIST
39771: LIST
39772: PUSH
39773: LD_INT 0
39775: PUSH
39776: LD_INT 1
39778: NEG
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: PUSH
39784: LD_INT 1
39786: PUSH
39787: LD_INT 0
39789: PUSH
39790: EMPTY
39791: LIST
39792: LIST
39793: PUSH
39794: LD_INT 1
39796: PUSH
39797: LD_INT 1
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 0
39806: PUSH
39807: LD_INT 1
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 1
39816: NEG
39817: PUSH
39818: LD_INT 0
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 1
39827: NEG
39828: PUSH
39829: LD_INT 1
39831: NEG
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: LD_INT 2
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 0
39851: PUSH
39852: LD_INT 2
39854: NEG
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 1
39862: PUSH
39863: LD_INT 1
39865: NEG
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: PUSH
39871: LD_INT 2
39873: PUSH
39874: LD_INT 0
39876: PUSH
39877: EMPTY
39878: LIST
39879: LIST
39880: PUSH
39881: LD_INT 2
39883: PUSH
39884: LD_INT 1
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 2
39893: PUSH
39894: LD_INT 2
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: LD_INT 1
39903: PUSH
39904: LD_INT 2
39906: PUSH
39907: EMPTY
39908: LIST
39909: LIST
39910: PUSH
39911: LD_INT 0
39913: PUSH
39914: LD_INT 2
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: LD_INT 1
39923: NEG
39924: PUSH
39925: LD_INT 1
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 2
39934: NEG
39935: PUSH
39936: LD_INT 0
39938: PUSH
39939: EMPTY
39940: LIST
39941: LIST
39942: PUSH
39943: LD_INT 2
39945: NEG
39946: PUSH
39947: LD_INT 1
39949: NEG
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 2
39957: NEG
39958: PUSH
39959: LD_INT 2
39961: NEG
39962: PUSH
39963: EMPTY
39964: LIST
39965: LIST
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: LIST
39971: LIST
39972: LIST
39973: LIST
39974: LIST
39975: LIST
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39988: LD_ADDR_VAR 0 58
39992: PUSH
39993: LD_INT 0
39995: PUSH
39996: LD_INT 0
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 0
40005: PUSH
40006: LD_INT 1
40008: NEG
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: LD_INT 1
40016: PUSH
40017: LD_INT 0
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 1
40026: PUSH
40027: LD_INT 1
40029: PUSH
40030: EMPTY
40031: LIST
40032: LIST
40033: PUSH
40034: LD_INT 0
40036: PUSH
40037: LD_INT 1
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 1
40046: NEG
40047: PUSH
40048: LD_INT 0
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: PUSH
40055: LD_INT 1
40057: NEG
40058: PUSH
40059: LD_INT 1
40061: NEG
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: LD_INT 1
40069: NEG
40070: PUSH
40071: LD_INT 2
40073: NEG
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 0
40081: PUSH
40082: LD_INT 2
40084: NEG
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 1
40092: PUSH
40093: LD_INT 1
40095: NEG
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 2
40103: PUSH
40104: LD_INT 0
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 2
40113: PUSH
40114: LD_INT 1
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 2
40123: PUSH
40124: LD_INT 2
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 1
40133: PUSH
40134: LD_INT 2
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: PUSH
40141: LD_INT 0
40143: PUSH
40144: LD_INT 2
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 1
40153: NEG
40154: PUSH
40155: LD_INT 1
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 2
40164: NEG
40165: PUSH
40166: LD_INT 0
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: LD_INT 2
40175: NEG
40176: PUSH
40177: LD_INT 1
40179: NEG
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 2
40187: NEG
40188: PUSH
40189: LD_INT 2
40191: NEG
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: LIST
40207: LIST
40208: LIST
40209: LIST
40210: LIST
40211: LIST
40212: LIST
40213: LIST
40214: LIST
40215: LIST
40216: LIST
40217: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40218: LD_ADDR_VAR 0 59
40222: PUSH
40223: LD_INT 0
40225: PUSH
40226: LD_INT 0
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 0
40235: PUSH
40236: LD_INT 1
40238: NEG
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 1
40246: PUSH
40247: LD_INT 0
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 1
40256: PUSH
40257: LD_INT 1
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 0
40266: PUSH
40267: LD_INT 1
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 1
40276: NEG
40277: PUSH
40278: LD_INT 0
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 1
40287: NEG
40288: PUSH
40289: LD_INT 1
40291: NEG
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: LIST
40301: LIST
40302: LIST
40303: LIST
40304: LIST
40305: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40306: LD_ADDR_VAR 0 60
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: LD_INT 0
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 0
40323: PUSH
40324: LD_INT 1
40326: NEG
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 1
40334: PUSH
40335: LD_INT 0
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PUSH
40342: LD_INT 1
40344: PUSH
40345: LD_INT 1
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 0
40354: PUSH
40355: LD_INT 1
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: PUSH
40362: LD_INT 1
40364: NEG
40365: PUSH
40366: LD_INT 0
40368: PUSH
40369: EMPTY
40370: LIST
40371: LIST
40372: PUSH
40373: LD_INT 1
40375: NEG
40376: PUSH
40377: LD_INT 1
40379: NEG
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40394: LD_ADDR_VAR 0 61
40398: PUSH
40399: LD_INT 0
40401: PUSH
40402: LD_INT 0
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PUSH
40409: LD_INT 0
40411: PUSH
40412: LD_INT 1
40414: NEG
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: PUSH
40420: LD_INT 1
40422: PUSH
40423: LD_INT 0
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 1
40432: PUSH
40433: LD_INT 1
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 0
40442: PUSH
40443: LD_INT 1
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: LD_INT 1
40452: NEG
40453: PUSH
40454: LD_INT 0
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 1
40463: NEG
40464: PUSH
40465: LD_INT 1
40467: NEG
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: EMPTY
40474: LIST
40475: LIST
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40482: LD_ADDR_VAR 0 62
40486: PUSH
40487: LD_INT 0
40489: PUSH
40490: LD_INT 0
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: LD_INT 0
40499: PUSH
40500: LD_INT 1
40502: NEG
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 1
40510: PUSH
40511: LD_INT 0
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 1
40520: PUSH
40521: LD_INT 1
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: LD_INT 1
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 1
40540: NEG
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 1
40551: NEG
40552: PUSH
40553: LD_INT 1
40555: NEG
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: EMPTY
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40570: LD_ADDR_VAR 0 63
40574: PUSH
40575: LD_INT 0
40577: PUSH
40578: LD_INT 0
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: LD_INT 0
40587: PUSH
40588: LD_INT 1
40590: NEG
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: PUSH
40596: LD_INT 1
40598: PUSH
40599: LD_INT 0
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: PUSH
40606: LD_INT 1
40608: PUSH
40609: LD_INT 1
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 0
40618: PUSH
40619: LD_INT 1
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: PUSH
40626: LD_INT 1
40628: NEG
40629: PUSH
40630: LD_INT 0
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 1
40639: NEG
40640: PUSH
40641: LD_INT 1
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: EMPTY
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: LIST
40656: LIST
40657: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40658: LD_ADDR_VAR 0 64
40662: PUSH
40663: LD_INT 0
40665: PUSH
40666: LD_INT 0
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 0
40675: PUSH
40676: LD_INT 1
40678: NEG
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 1
40686: PUSH
40687: LD_INT 0
40689: PUSH
40690: EMPTY
40691: LIST
40692: LIST
40693: PUSH
40694: LD_INT 1
40696: PUSH
40697: LD_INT 1
40699: PUSH
40700: EMPTY
40701: LIST
40702: LIST
40703: PUSH
40704: LD_INT 0
40706: PUSH
40707: LD_INT 1
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 1
40716: NEG
40717: PUSH
40718: LD_INT 0
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: NEG
40728: PUSH
40729: LD_INT 1
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: LIST
40741: LIST
40742: LIST
40743: LIST
40744: LIST
40745: ST_TO_ADDR
// end ; 1 :
40746: GO 46643
40748: LD_INT 1
40750: DOUBLE
40751: EQUAL
40752: IFTRUE 40756
40754: GO 43379
40756: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40757: LD_ADDR_VAR 0 11
40761: PUSH
40762: LD_INT 1
40764: NEG
40765: PUSH
40766: LD_INT 3
40768: NEG
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 0
40776: PUSH
40777: LD_INT 3
40779: NEG
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 1
40787: PUSH
40788: LD_INT 2
40790: NEG
40791: PUSH
40792: EMPTY
40793: LIST
40794: LIST
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: LIST
40800: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40801: LD_ADDR_VAR 0 12
40805: PUSH
40806: LD_INT 2
40808: PUSH
40809: LD_INT 1
40811: NEG
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 3
40819: PUSH
40820: LD_INT 0
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: PUSH
40827: LD_INT 3
40829: PUSH
40830: LD_INT 1
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: LIST
40841: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40842: LD_ADDR_VAR 0 13
40846: PUSH
40847: LD_INT 3
40849: PUSH
40850: LD_INT 2
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 3
40859: PUSH
40860: LD_INT 3
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 2
40869: PUSH
40870: LD_INT 3
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: LIST
40881: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40882: LD_ADDR_VAR 0 14
40886: PUSH
40887: LD_INT 1
40889: PUSH
40890: LD_INT 3
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: LD_INT 0
40899: PUSH
40900: LD_INT 3
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PUSH
40907: LD_INT 1
40909: NEG
40910: PUSH
40911: LD_INT 2
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: LIST
40922: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40923: LD_ADDR_VAR 0 15
40927: PUSH
40928: LD_INT 2
40930: NEG
40931: PUSH
40932: LD_INT 1
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 3
40941: NEG
40942: PUSH
40943: LD_INT 0
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 3
40952: NEG
40953: PUSH
40954: LD_INT 1
40956: NEG
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: LIST
40966: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40967: LD_ADDR_VAR 0 16
40971: PUSH
40972: LD_INT 2
40974: NEG
40975: PUSH
40976: LD_INT 3
40978: NEG
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PUSH
40984: LD_INT 3
40986: NEG
40987: PUSH
40988: LD_INT 2
40990: NEG
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: LD_INT 3
40998: NEG
40999: PUSH
41000: LD_INT 3
41002: NEG
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: LIST
41012: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41013: LD_ADDR_VAR 0 17
41017: PUSH
41018: LD_INT 1
41020: NEG
41021: PUSH
41022: LD_INT 3
41024: NEG
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: LD_INT 0
41032: PUSH
41033: LD_INT 3
41035: NEG
41036: PUSH
41037: EMPTY
41038: LIST
41039: LIST
41040: PUSH
41041: LD_INT 1
41043: PUSH
41044: LD_INT 2
41046: NEG
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: LIST
41056: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41057: LD_ADDR_VAR 0 18
41061: PUSH
41062: LD_INT 2
41064: PUSH
41065: LD_INT 1
41067: NEG
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: PUSH
41073: LD_INT 3
41075: PUSH
41076: LD_INT 0
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 3
41085: PUSH
41086: LD_INT 1
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: LIST
41097: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41098: LD_ADDR_VAR 0 19
41102: PUSH
41103: LD_INT 3
41105: PUSH
41106: LD_INT 2
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: PUSH
41113: LD_INT 3
41115: PUSH
41116: LD_INT 3
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: PUSH
41123: LD_INT 2
41125: PUSH
41126: LD_INT 3
41128: PUSH
41129: EMPTY
41130: LIST
41131: LIST
41132: PUSH
41133: EMPTY
41134: LIST
41135: LIST
41136: LIST
41137: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41138: LD_ADDR_VAR 0 20
41142: PUSH
41143: LD_INT 1
41145: PUSH
41146: LD_INT 3
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 0
41155: PUSH
41156: LD_INT 3
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: LD_INT 1
41165: NEG
41166: PUSH
41167: LD_INT 2
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: EMPTY
41175: LIST
41176: LIST
41177: LIST
41178: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41179: LD_ADDR_VAR 0 21
41183: PUSH
41184: LD_INT 2
41186: NEG
41187: PUSH
41188: LD_INT 1
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PUSH
41195: LD_INT 3
41197: NEG
41198: PUSH
41199: LD_INT 0
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 3
41208: NEG
41209: PUSH
41210: LD_INT 1
41212: NEG
41213: PUSH
41214: EMPTY
41215: LIST
41216: LIST
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: LIST
41222: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41223: LD_ADDR_VAR 0 22
41227: PUSH
41228: LD_INT 2
41230: NEG
41231: PUSH
41232: LD_INT 3
41234: NEG
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 3
41242: NEG
41243: PUSH
41244: LD_INT 2
41246: NEG
41247: PUSH
41248: EMPTY
41249: LIST
41250: LIST
41251: PUSH
41252: LD_INT 3
41254: NEG
41255: PUSH
41256: LD_INT 3
41258: NEG
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: LIST
41268: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41269: LD_ADDR_VAR 0 23
41273: PUSH
41274: LD_INT 0
41276: PUSH
41277: LD_INT 3
41279: NEG
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 1
41287: NEG
41288: PUSH
41289: LD_INT 4
41291: NEG
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 1
41299: PUSH
41300: LD_INT 3
41302: NEG
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: LIST
41312: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41313: LD_ADDR_VAR 0 24
41317: PUSH
41318: LD_INT 3
41320: PUSH
41321: LD_INT 0
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: LD_INT 3
41330: PUSH
41331: LD_INT 1
41333: NEG
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 4
41341: PUSH
41342: LD_INT 1
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: LIST
41353: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41354: LD_ADDR_VAR 0 25
41358: PUSH
41359: LD_INT 3
41361: PUSH
41362: LD_INT 3
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 4
41371: PUSH
41372: LD_INT 3
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 3
41381: PUSH
41382: LD_INT 4
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: LIST
41393: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41394: LD_ADDR_VAR 0 26
41398: PUSH
41399: LD_INT 0
41401: PUSH
41402: LD_INT 3
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 1
41411: PUSH
41412: LD_INT 4
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 1
41421: NEG
41422: PUSH
41423: LD_INT 3
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: LIST
41434: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41435: LD_ADDR_VAR 0 27
41439: PUSH
41440: LD_INT 3
41442: NEG
41443: PUSH
41444: LD_INT 0
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 3
41453: NEG
41454: PUSH
41455: LD_INT 1
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 4
41464: NEG
41465: PUSH
41466: LD_INT 1
41468: NEG
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: LIST
41478: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41479: LD_ADDR_VAR 0 28
41483: PUSH
41484: LD_INT 3
41486: NEG
41487: PUSH
41488: LD_INT 3
41490: NEG
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: LD_INT 3
41498: NEG
41499: PUSH
41500: LD_INT 4
41502: NEG
41503: PUSH
41504: EMPTY
41505: LIST
41506: LIST
41507: PUSH
41508: LD_INT 4
41510: NEG
41511: PUSH
41512: LD_INT 3
41514: NEG
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: LIST
41524: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41525: LD_ADDR_VAR 0 29
41529: PUSH
41530: LD_INT 1
41532: NEG
41533: PUSH
41534: LD_INT 3
41536: NEG
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: LD_INT 0
41544: PUSH
41545: LD_INT 3
41547: NEG
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: LD_INT 1
41555: PUSH
41556: LD_INT 2
41558: NEG
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 1
41566: NEG
41567: PUSH
41568: LD_INT 4
41570: NEG
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 0
41578: PUSH
41579: LD_INT 4
41581: NEG
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PUSH
41587: LD_INT 1
41589: PUSH
41590: LD_INT 3
41592: NEG
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: PUSH
41598: LD_INT 1
41600: NEG
41601: PUSH
41602: LD_INT 5
41604: NEG
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 0
41612: PUSH
41613: LD_INT 5
41615: NEG
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: PUSH
41621: LD_INT 1
41623: PUSH
41624: LD_INT 4
41626: NEG
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 1
41634: NEG
41635: PUSH
41636: LD_INT 6
41638: NEG
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: LD_INT 0
41646: PUSH
41647: LD_INT 6
41649: NEG
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: LD_INT 1
41657: PUSH
41658: LD_INT 5
41660: NEG
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: LIST
41670: LIST
41671: LIST
41672: LIST
41673: LIST
41674: LIST
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41680: LD_ADDR_VAR 0 30
41684: PUSH
41685: LD_INT 2
41687: PUSH
41688: LD_INT 1
41690: NEG
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 3
41698: PUSH
41699: LD_INT 0
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 3
41708: PUSH
41709: LD_INT 1
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 3
41718: PUSH
41719: LD_INT 1
41721: NEG
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: PUSH
41727: LD_INT 4
41729: PUSH
41730: LD_INT 0
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 4
41739: PUSH
41740: LD_INT 1
41742: PUSH
41743: EMPTY
41744: LIST
41745: LIST
41746: PUSH
41747: LD_INT 4
41749: PUSH
41750: LD_INT 1
41752: NEG
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 5
41760: PUSH
41761: LD_INT 0
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: LD_INT 5
41770: PUSH
41771: LD_INT 1
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: LD_INT 5
41780: PUSH
41781: LD_INT 1
41783: NEG
41784: PUSH
41785: EMPTY
41786: LIST
41787: LIST
41788: PUSH
41789: LD_INT 6
41791: PUSH
41792: LD_INT 0
41794: PUSH
41795: EMPTY
41796: LIST
41797: LIST
41798: PUSH
41799: LD_INT 6
41801: PUSH
41802: LD_INT 1
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: LIST
41813: LIST
41814: LIST
41815: LIST
41816: LIST
41817: LIST
41818: LIST
41819: LIST
41820: LIST
41821: LIST
41822: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41823: LD_ADDR_VAR 0 31
41827: PUSH
41828: LD_INT 3
41830: PUSH
41831: LD_INT 2
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 3
41840: PUSH
41841: LD_INT 3
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 2
41850: PUSH
41851: LD_INT 3
41853: PUSH
41854: EMPTY
41855: LIST
41856: LIST
41857: PUSH
41858: LD_INT 4
41860: PUSH
41861: LD_INT 3
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 4
41870: PUSH
41871: LD_INT 4
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 3
41880: PUSH
41881: LD_INT 4
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 5
41890: PUSH
41891: LD_INT 4
41893: PUSH
41894: EMPTY
41895: LIST
41896: LIST
41897: PUSH
41898: LD_INT 5
41900: PUSH
41901: LD_INT 5
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 4
41910: PUSH
41911: LD_INT 5
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: PUSH
41918: LD_INT 6
41920: PUSH
41921: LD_INT 5
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 6
41930: PUSH
41931: LD_INT 6
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 5
41940: PUSH
41941: LD_INT 6
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: LIST
41952: LIST
41953: LIST
41954: LIST
41955: LIST
41956: LIST
41957: LIST
41958: LIST
41959: LIST
41960: LIST
41961: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41962: LD_ADDR_VAR 0 32
41966: PUSH
41967: LD_INT 1
41969: PUSH
41970: LD_INT 3
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: PUSH
41977: LD_INT 0
41979: PUSH
41980: LD_INT 3
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: PUSH
41987: LD_INT 1
41989: NEG
41990: PUSH
41991: LD_INT 2
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: PUSH
41998: LD_INT 1
42000: PUSH
42001: LD_INT 4
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: PUSH
42008: LD_INT 0
42010: PUSH
42011: LD_INT 4
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 1
42020: NEG
42021: PUSH
42022: LD_INT 3
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 1
42031: PUSH
42032: LD_INT 5
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 0
42041: PUSH
42042: LD_INT 5
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 1
42051: NEG
42052: PUSH
42053: LD_INT 4
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 1
42062: PUSH
42063: LD_INT 6
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 0
42072: PUSH
42073: LD_INT 6
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: PUSH
42080: LD_INT 1
42082: NEG
42083: PUSH
42084: LD_INT 5
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: LIST
42095: LIST
42096: LIST
42097: LIST
42098: LIST
42099: LIST
42100: LIST
42101: LIST
42102: LIST
42103: LIST
42104: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42105: LD_ADDR_VAR 0 33
42109: PUSH
42110: LD_INT 2
42112: NEG
42113: PUSH
42114: LD_INT 1
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 3
42123: NEG
42124: PUSH
42125: LD_INT 0
42127: PUSH
42128: EMPTY
42129: LIST
42130: LIST
42131: PUSH
42132: LD_INT 3
42134: NEG
42135: PUSH
42136: LD_INT 1
42138: NEG
42139: PUSH
42140: EMPTY
42141: LIST
42142: LIST
42143: PUSH
42144: LD_INT 3
42146: NEG
42147: PUSH
42148: LD_INT 1
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 4
42157: NEG
42158: PUSH
42159: LD_INT 0
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: PUSH
42166: LD_INT 4
42168: NEG
42169: PUSH
42170: LD_INT 1
42172: NEG
42173: PUSH
42174: EMPTY
42175: LIST
42176: LIST
42177: PUSH
42178: LD_INT 4
42180: NEG
42181: PUSH
42182: LD_INT 1
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: LD_INT 5
42191: NEG
42192: PUSH
42193: LD_INT 0
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 5
42202: NEG
42203: PUSH
42204: LD_INT 1
42206: NEG
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: PUSH
42212: LD_INT 5
42214: NEG
42215: PUSH
42216: LD_INT 1
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 6
42225: NEG
42226: PUSH
42227: LD_INT 0
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: PUSH
42234: LD_INT 6
42236: NEG
42237: PUSH
42238: LD_INT 1
42240: NEG
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: EMPTY
42247: LIST
42248: LIST
42249: LIST
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: LIST
42259: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42260: LD_ADDR_VAR 0 34
42264: PUSH
42265: LD_INT 2
42267: NEG
42268: PUSH
42269: LD_INT 3
42271: NEG
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: LD_INT 3
42279: NEG
42280: PUSH
42281: LD_INT 2
42283: NEG
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 3
42291: NEG
42292: PUSH
42293: LD_INT 3
42295: NEG
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: LD_INT 3
42303: NEG
42304: PUSH
42305: LD_INT 4
42307: NEG
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: PUSH
42313: LD_INT 4
42315: NEG
42316: PUSH
42317: LD_INT 3
42319: NEG
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 4
42327: NEG
42328: PUSH
42329: LD_INT 4
42331: NEG
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: PUSH
42337: LD_INT 4
42339: NEG
42340: PUSH
42341: LD_INT 5
42343: NEG
42344: PUSH
42345: EMPTY
42346: LIST
42347: LIST
42348: PUSH
42349: LD_INT 5
42351: NEG
42352: PUSH
42353: LD_INT 4
42355: NEG
42356: PUSH
42357: EMPTY
42358: LIST
42359: LIST
42360: PUSH
42361: LD_INT 5
42363: NEG
42364: PUSH
42365: LD_INT 5
42367: NEG
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 5
42375: NEG
42376: PUSH
42377: LD_INT 6
42379: NEG
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: LD_INT 6
42387: NEG
42388: PUSH
42389: LD_INT 5
42391: NEG
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 6
42399: NEG
42400: PUSH
42401: LD_INT 6
42403: NEG
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: LIST
42413: LIST
42414: LIST
42415: LIST
42416: LIST
42417: LIST
42418: LIST
42419: LIST
42420: LIST
42421: LIST
42422: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42423: LD_ADDR_VAR 0 41
42427: PUSH
42428: LD_INT 0
42430: PUSH
42431: LD_INT 2
42433: NEG
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 1
42441: NEG
42442: PUSH
42443: LD_INT 3
42445: NEG
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: LD_INT 1
42453: PUSH
42454: LD_INT 2
42456: NEG
42457: PUSH
42458: EMPTY
42459: LIST
42460: LIST
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: LIST
42466: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42467: LD_ADDR_VAR 0 42
42471: PUSH
42472: LD_INT 2
42474: PUSH
42475: LD_INT 0
42477: PUSH
42478: EMPTY
42479: LIST
42480: LIST
42481: PUSH
42482: LD_INT 2
42484: PUSH
42485: LD_INT 1
42487: NEG
42488: PUSH
42489: EMPTY
42490: LIST
42491: LIST
42492: PUSH
42493: LD_INT 3
42495: PUSH
42496: LD_INT 1
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: LIST
42507: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42508: LD_ADDR_VAR 0 43
42512: PUSH
42513: LD_INT 2
42515: PUSH
42516: LD_INT 2
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 3
42525: PUSH
42526: LD_INT 2
42528: PUSH
42529: EMPTY
42530: LIST
42531: LIST
42532: PUSH
42533: LD_INT 2
42535: PUSH
42536: LD_INT 3
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: EMPTY
42544: LIST
42545: LIST
42546: LIST
42547: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42548: LD_ADDR_VAR 0 44
42552: PUSH
42553: LD_INT 0
42555: PUSH
42556: LD_INT 2
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 1
42565: PUSH
42566: LD_INT 3
42568: PUSH
42569: EMPTY
42570: LIST
42571: LIST
42572: PUSH
42573: LD_INT 1
42575: NEG
42576: PUSH
42577: LD_INT 2
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: LIST
42588: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42589: LD_ADDR_VAR 0 45
42593: PUSH
42594: LD_INT 2
42596: NEG
42597: PUSH
42598: LD_INT 0
42600: PUSH
42601: EMPTY
42602: LIST
42603: LIST
42604: PUSH
42605: LD_INT 2
42607: NEG
42608: PUSH
42609: LD_INT 1
42611: PUSH
42612: EMPTY
42613: LIST
42614: LIST
42615: PUSH
42616: LD_INT 3
42618: NEG
42619: PUSH
42620: LD_INT 1
42622: NEG
42623: PUSH
42624: EMPTY
42625: LIST
42626: LIST
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: LIST
42632: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42633: LD_ADDR_VAR 0 46
42637: PUSH
42638: LD_INT 2
42640: NEG
42641: PUSH
42642: LD_INT 2
42644: NEG
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PUSH
42650: LD_INT 2
42652: NEG
42653: PUSH
42654: LD_INT 3
42656: NEG
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: LD_INT 3
42664: NEG
42665: PUSH
42666: LD_INT 2
42668: NEG
42669: PUSH
42670: EMPTY
42671: LIST
42672: LIST
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: LIST
42678: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42679: LD_ADDR_VAR 0 47
42683: PUSH
42684: LD_INT 2
42686: NEG
42687: PUSH
42688: LD_INT 3
42690: NEG
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: LD_INT 1
42698: NEG
42699: PUSH
42700: LD_INT 3
42702: NEG
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42712: LD_ADDR_VAR 0 48
42716: PUSH
42717: LD_INT 1
42719: PUSH
42720: LD_INT 2
42722: NEG
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: LD_INT 2
42730: PUSH
42731: LD_INT 1
42733: NEG
42734: PUSH
42735: EMPTY
42736: LIST
42737: LIST
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42743: LD_ADDR_VAR 0 49
42747: PUSH
42748: LD_INT 3
42750: PUSH
42751: LD_INT 1
42753: PUSH
42754: EMPTY
42755: LIST
42756: LIST
42757: PUSH
42758: LD_INT 3
42760: PUSH
42761: LD_INT 2
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42772: LD_ADDR_VAR 0 50
42776: PUSH
42777: LD_INT 2
42779: PUSH
42780: LD_INT 3
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PUSH
42787: LD_INT 1
42789: PUSH
42790: LD_INT 3
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42801: LD_ADDR_VAR 0 51
42805: PUSH
42806: LD_INT 1
42808: NEG
42809: PUSH
42810: LD_INT 2
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 2
42819: NEG
42820: PUSH
42821: LD_INT 1
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42832: LD_ADDR_VAR 0 52
42836: PUSH
42837: LD_INT 3
42839: NEG
42840: PUSH
42841: LD_INT 1
42843: NEG
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: LD_INT 3
42851: NEG
42852: PUSH
42853: LD_INT 2
42855: NEG
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42865: LD_ADDR_VAR 0 53
42869: PUSH
42870: LD_INT 1
42872: NEG
42873: PUSH
42874: LD_INT 3
42876: NEG
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: PUSH
42882: LD_INT 0
42884: PUSH
42885: LD_INT 3
42887: NEG
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: PUSH
42893: LD_INT 1
42895: PUSH
42896: LD_INT 2
42898: NEG
42899: PUSH
42900: EMPTY
42901: LIST
42902: LIST
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: LIST
42908: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42909: LD_ADDR_VAR 0 54
42913: PUSH
42914: LD_INT 2
42916: PUSH
42917: LD_INT 1
42919: NEG
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: PUSH
42925: LD_INT 3
42927: PUSH
42928: LD_INT 0
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: LD_INT 3
42937: PUSH
42938: LD_INT 1
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: EMPTY
42946: LIST
42947: LIST
42948: LIST
42949: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42950: LD_ADDR_VAR 0 55
42954: PUSH
42955: LD_INT 3
42957: PUSH
42958: LD_INT 2
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 3
42967: PUSH
42968: LD_INT 3
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 2
42977: PUSH
42978: LD_INT 3
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: EMPTY
42986: LIST
42987: LIST
42988: LIST
42989: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42990: LD_ADDR_VAR 0 56
42994: PUSH
42995: LD_INT 1
42997: PUSH
42998: LD_INT 3
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: LD_INT 0
43007: PUSH
43008: LD_INT 3
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: PUSH
43015: LD_INT 1
43017: NEG
43018: PUSH
43019: LD_INT 2
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: LIST
43030: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43031: LD_ADDR_VAR 0 57
43035: PUSH
43036: LD_INT 2
43038: NEG
43039: PUSH
43040: LD_INT 1
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 3
43049: NEG
43050: PUSH
43051: LD_INT 0
43053: PUSH
43054: EMPTY
43055: LIST
43056: LIST
43057: PUSH
43058: LD_INT 3
43060: NEG
43061: PUSH
43062: LD_INT 1
43064: NEG
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: LIST
43074: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43075: LD_ADDR_VAR 0 58
43079: PUSH
43080: LD_INT 2
43082: NEG
43083: PUSH
43084: LD_INT 3
43086: NEG
43087: PUSH
43088: EMPTY
43089: LIST
43090: LIST
43091: PUSH
43092: LD_INT 3
43094: NEG
43095: PUSH
43096: LD_INT 2
43098: NEG
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: LD_INT 3
43106: NEG
43107: PUSH
43108: LD_INT 3
43110: NEG
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PUSH
43116: EMPTY
43117: LIST
43118: LIST
43119: LIST
43120: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43121: LD_ADDR_VAR 0 59
43125: PUSH
43126: LD_INT 1
43128: NEG
43129: PUSH
43130: LD_INT 2
43132: NEG
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: PUSH
43138: LD_INT 0
43140: PUSH
43141: LD_INT 2
43143: NEG
43144: PUSH
43145: EMPTY
43146: LIST
43147: LIST
43148: PUSH
43149: LD_INT 1
43151: PUSH
43152: LD_INT 1
43154: NEG
43155: PUSH
43156: EMPTY
43157: LIST
43158: LIST
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: LIST
43164: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43165: LD_ADDR_VAR 0 60
43169: PUSH
43170: LD_INT 1
43172: PUSH
43173: LD_INT 1
43175: NEG
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: PUSH
43181: LD_INT 2
43183: PUSH
43184: LD_INT 0
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: PUSH
43191: LD_INT 2
43193: PUSH
43194: LD_INT 1
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: EMPTY
43202: LIST
43203: LIST
43204: LIST
43205: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43206: LD_ADDR_VAR 0 61
43210: PUSH
43211: LD_INT 2
43213: PUSH
43214: LD_INT 1
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 2
43223: PUSH
43224: LD_INT 2
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: PUSH
43231: LD_INT 1
43233: PUSH
43234: LD_INT 2
43236: PUSH
43237: EMPTY
43238: LIST
43239: LIST
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: LIST
43245: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43246: LD_ADDR_VAR 0 62
43250: PUSH
43251: LD_INT 1
43253: PUSH
43254: LD_INT 2
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: LD_INT 0
43263: PUSH
43264: LD_INT 2
43266: PUSH
43267: EMPTY
43268: LIST
43269: LIST
43270: PUSH
43271: LD_INT 1
43273: NEG
43274: PUSH
43275: LD_INT 1
43277: PUSH
43278: EMPTY
43279: LIST
43280: LIST
43281: PUSH
43282: EMPTY
43283: LIST
43284: LIST
43285: LIST
43286: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43287: LD_ADDR_VAR 0 63
43291: PUSH
43292: LD_INT 1
43294: NEG
43295: PUSH
43296: LD_INT 1
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: LD_INT 2
43305: NEG
43306: PUSH
43307: LD_INT 0
43309: PUSH
43310: EMPTY
43311: LIST
43312: LIST
43313: PUSH
43314: LD_INT 2
43316: NEG
43317: PUSH
43318: LD_INT 1
43320: NEG
43321: PUSH
43322: EMPTY
43323: LIST
43324: LIST
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: LIST
43330: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43331: LD_ADDR_VAR 0 64
43335: PUSH
43336: LD_INT 1
43338: NEG
43339: PUSH
43340: LD_INT 2
43342: NEG
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: PUSH
43348: LD_INT 2
43350: NEG
43351: PUSH
43352: LD_INT 1
43354: NEG
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 2
43362: NEG
43363: PUSH
43364: LD_INT 2
43366: NEG
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: EMPTY
43373: LIST
43374: LIST
43375: LIST
43376: ST_TO_ADDR
// end ; 2 :
43377: GO 46643
43379: LD_INT 2
43381: DOUBLE
43382: EQUAL
43383: IFTRUE 43387
43385: GO 46642
43387: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43388: LD_ADDR_VAR 0 29
43392: PUSH
43393: LD_INT 4
43395: PUSH
43396: LD_INT 0
43398: PUSH
43399: EMPTY
43400: LIST
43401: LIST
43402: PUSH
43403: LD_INT 4
43405: PUSH
43406: LD_INT 1
43408: NEG
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: PUSH
43414: LD_INT 5
43416: PUSH
43417: LD_INT 0
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 5
43426: PUSH
43427: LD_INT 1
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: LD_INT 4
43436: PUSH
43437: LD_INT 1
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PUSH
43444: LD_INT 3
43446: PUSH
43447: LD_INT 0
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: PUSH
43454: LD_INT 3
43456: PUSH
43457: LD_INT 1
43459: NEG
43460: PUSH
43461: EMPTY
43462: LIST
43463: LIST
43464: PUSH
43465: LD_INT 3
43467: PUSH
43468: LD_INT 2
43470: NEG
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 5
43478: PUSH
43479: LD_INT 2
43481: PUSH
43482: EMPTY
43483: LIST
43484: LIST
43485: PUSH
43486: LD_INT 3
43488: PUSH
43489: LD_INT 3
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PUSH
43496: LD_INT 3
43498: PUSH
43499: LD_INT 2
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: PUSH
43506: LD_INT 4
43508: PUSH
43509: LD_INT 3
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: PUSH
43516: LD_INT 4
43518: PUSH
43519: LD_INT 4
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: PUSH
43526: LD_INT 3
43528: PUSH
43529: LD_INT 4
43531: PUSH
43532: EMPTY
43533: LIST
43534: LIST
43535: PUSH
43536: LD_INT 2
43538: PUSH
43539: LD_INT 3
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PUSH
43546: LD_INT 2
43548: PUSH
43549: LD_INT 2
43551: PUSH
43552: EMPTY
43553: LIST
43554: LIST
43555: PUSH
43556: LD_INT 4
43558: PUSH
43559: LD_INT 2
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: LD_INT 2
43568: PUSH
43569: LD_INT 4
43571: PUSH
43572: EMPTY
43573: LIST
43574: LIST
43575: PUSH
43576: LD_INT 0
43578: PUSH
43579: LD_INT 4
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PUSH
43586: LD_INT 0
43588: PUSH
43589: LD_INT 3
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PUSH
43596: LD_INT 1
43598: PUSH
43599: LD_INT 4
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: PUSH
43606: LD_INT 1
43608: PUSH
43609: LD_INT 5
43611: PUSH
43612: EMPTY
43613: LIST
43614: LIST
43615: PUSH
43616: LD_INT 0
43618: PUSH
43619: LD_INT 5
43621: PUSH
43622: EMPTY
43623: LIST
43624: LIST
43625: PUSH
43626: LD_INT 1
43628: NEG
43629: PUSH
43630: LD_INT 4
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: PUSH
43637: LD_INT 1
43639: NEG
43640: PUSH
43641: LD_INT 3
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: PUSH
43648: LD_INT 2
43650: PUSH
43651: LD_INT 5
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PUSH
43658: LD_INT 2
43660: NEG
43661: PUSH
43662: LD_INT 3
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: LD_INT 3
43671: NEG
43672: PUSH
43673: LD_INT 0
43675: PUSH
43676: EMPTY
43677: LIST
43678: LIST
43679: PUSH
43680: LD_INT 3
43682: NEG
43683: PUSH
43684: LD_INT 1
43686: NEG
43687: PUSH
43688: EMPTY
43689: LIST
43690: LIST
43691: PUSH
43692: LD_INT 2
43694: NEG
43695: PUSH
43696: LD_INT 0
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 2
43705: NEG
43706: PUSH
43707: LD_INT 1
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 3
43716: NEG
43717: PUSH
43718: LD_INT 1
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 4
43727: NEG
43728: PUSH
43729: LD_INT 0
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: PUSH
43736: LD_INT 4
43738: NEG
43739: PUSH
43740: LD_INT 1
43742: NEG
43743: PUSH
43744: EMPTY
43745: LIST
43746: LIST
43747: PUSH
43748: LD_INT 4
43750: NEG
43751: PUSH
43752: LD_INT 2
43754: NEG
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: LD_INT 2
43762: NEG
43763: PUSH
43764: LD_INT 2
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 4
43773: NEG
43774: PUSH
43775: LD_INT 4
43777: NEG
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 4
43785: NEG
43786: PUSH
43787: LD_INT 5
43789: NEG
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 3
43797: NEG
43798: PUSH
43799: LD_INT 4
43801: NEG
43802: PUSH
43803: EMPTY
43804: LIST
43805: LIST
43806: PUSH
43807: LD_INT 3
43809: NEG
43810: PUSH
43811: LD_INT 3
43813: NEG
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: LD_INT 4
43821: NEG
43822: PUSH
43823: LD_INT 3
43825: NEG
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: LD_INT 5
43833: NEG
43834: PUSH
43835: LD_INT 4
43837: NEG
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 5
43845: NEG
43846: PUSH
43847: LD_INT 5
43849: NEG
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 3
43857: NEG
43858: PUSH
43859: LD_INT 5
43861: NEG
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 5
43869: NEG
43870: PUSH
43871: LD_INT 3
43873: NEG
43874: PUSH
43875: EMPTY
43876: LIST
43877: LIST
43878: PUSH
43879: EMPTY
43880: LIST
43881: LIST
43882: LIST
43883: LIST
43884: LIST
43885: LIST
43886: LIST
43887: LIST
43888: LIST
43889: LIST
43890: LIST
43891: LIST
43892: LIST
43893: LIST
43894: LIST
43895: LIST
43896: LIST
43897: LIST
43898: LIST
43899: LIST
43900: LIST
43901: LIST
43902: LIST
43903: LIST
43904: LIST
43905: LIST
43906: LIST
43907: LIST
43908: LIST
43909: LIST
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: LIST
43915: LIST
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: LIST
43921: LIST
43922: LIST
43923: LIST
43924: LIST
43925: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43926: LD_ADDR_VAR 0 30
43930: PUSH
43931: LD_INT 4
43933: PUSH
43934: LD_INT 4
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: LD_INT 4
43943: PUSH
43944: LD_INT 3
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PUSH
43951: LD_INT 5
43953: PUSH
43954: LD_INT 4
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 5
43963: PUSH
43964: LD_INT 5
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: PUSH
43971: LD_INT 4
43973: PUSH
43974: LD_INT 5
43976: PUSH
43977: EMPTY
43978: LIST
43979: LIST
43980: PUSH
43981: LD_INT 3
43983: PUSH
43984: LD_INT 4
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 3
43993: PUSH
43994: LD_INT 3
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 5
44003: PUSH
44004: LD_INT 3
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 3
44013: PUSH
44014: LD_INT 5
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: LD_INT 0
44023: PUSH
44024: LD_INT 3
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: LD_INT 0
44033: PUSH
44034: LD_INT 2
44036: PUSH
44037: EMPTY
44038: LIST
44039: LIST
44040: PUSH
44041: LD_INT 1
44043: PUSH
44044: LD_INT 3
44046: PUSH
44047: EMPTY
44048: LIST
44049: LIST
44050: PUSH
44051: LD_INT 1
44053: PUSH
44054: LD_INT 4
44056: PUSH
44057: EMPTY
44058: LIST
44059: LIST
44060: PUSH
44061: LD_INT 0
44063: PUSH
44064: LD_INT 4
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: PUSH
44071: LD_INT 1
44073: NEG
44074: PUSH
44075: LD_INT 3
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: PUSH
44082: LD_INT 1
44084: NEG
44085: PUSH
44086: LD_INT 2
44088: PUSH
44089: EMPTY
44090: LIST
44091: LIST
44092: PUSH
44093: LD_INT 2
44095: PUSH
44096: LD_INT 4
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: PUSH
44103: LD_INT 2
44105: NEG
44106: PUSH
44107: LD_INT 2
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: LD_INT 4
44116: NEG
44117: PUSH
44118: LD_INT 0
44120: PUSH
44121: EMPTY
44122: LIST
44123: LIST
44124: PUSH
44125: LD_INT 4
44127: NEG
44128: PUSH
44129: LD_INT 1
44131: NEG
44132: PUSH
44133: EMPTY
44134: LIST
44135: LIST
44136: PUSH
44137: LD_INT 3
44139: NEG
44140: PUSH
44141: LD_INT 0
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: LD_INT 3
44150: NEG
44151: PUSH
44152: LD_INT 1
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 4
44161: NEG
44162: PUSH
44163: LD_INT 1
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 5
44172: NEG
44173: PUSH
44174: LD_INT 0
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: LD_INT 5
44183: NEG
44184: PUSH
44185: LD_INT 1
44187: NEG
44188: PUSH
44189: EMPTY
44190: LIST
44191: LIST
44192: PUSH
44193: LD_INT 5
44195: NEG
44196: PUSH
44197: LD_INT 2
44199: NEG
44200: PUSH
44201: EMPTY
44202: LIST
44203: LIST
44204: PUSH
44205: LD_INT 3
44207: NEG
44208: PUSH
44209: LD_INT 2
44211: PUSH
44212: EMPTY
44213: LIST
44214: LIST
44215: PUSH
44216: LD_INT 3
44218: NEG
44219: PUSH
44220: LD_INT 3
44222: NEG
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: PUSH
44228: LD_INT 3
44230: NEG
44231: PUSH
44232: LD_INT 4
44234: NEG
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_INT 2
44242: NEG
44243: PUSH
44244: LD_INT 3
44246: NEG
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: LD_INT 2
44254: NEG
44255: PUSH
44256: LD_INT 2
44258: NEG
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PUSH
44264: LD_INT 3
44266: NEG
44267: PUSH
44268: LD_INT 2
44270: NEG
44271: PUSH
44272: EMPTY
44273: LIST
44274: LIST
44275: PUSH
44276: LD_INT 4
44278: NEG
44279: PUSH
44280: LD_INT 3
44282: NEG
44283: PUSH
44284: EMPTY
44285: LIST
44286: LIST
44287: PUSH
44288: LD_INT 4
44290: NEG
44291: PUSH
44292: LD_INT 4
44294: NEG
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 2
44302: NEG
44303: PUSH
44304: LD_INT 4
44306: NEG
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_INT 4
44314: NEG
44315: PUSH
44316: LD_INT 2
44318: NEG
44319: PUSH
44320: EMPTY
44321: LIST
44322: LIST
44323: PUSH
44324: LD_INT 0
44326: PUSH
44327: LD_INT 4
44329: NEG
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: PUSH
44335: LD_INT 0
44337: PUSH
44338: LD_INT 5
44340: NEG
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 1
44348: PUSH
44349: LD_INT 4
44351: NEG
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: PUSH
44357: LD_INT 1
44359: PUSH
44360: LD_INT 3
44362: NEG
44363: PUSH
44364: EMPTY
44365: LIST
44366: LIST
44367: PUSH
44368: LD_INT 0
44370: PUSH
44371: LD_INT 3
44373: NEG
44374: PUSH
44375: EMPTY
44376: LIST
44377: LIST
44378: PUSH
44379: LD_INT 1
44381: NEG
44382: PUSH
44383: LD_INT 4
44385: NEG
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 1
44393: NEG
44394: PUSH
44395: LD_INT 5
44397: NEG
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: PUSH
44403: LD_INT 2
44405: PUSH
44406: LD_INT 3
44408: NEG
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PUSH
44414: LD_INT 2
44416: NEG
44417: PUSH
44418: LD_INT 5
44420: NEG
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: LIST
44430: LIST
44431: LIST
44432: LIST
44433: LIST
44434: LIST
44435: LIST
44436: LIST
44437: LIST
44438: LIST
44439: LIST
44440: LIST
44441: LIST
44442: LIST
44443: LIST
44444: LIST
44445: LIST
44446: LIST
44447: LIST
44448: LIST
44449: LIST
44450: LIST
44451: LIST
44452: LIST
44453: LIST
44454: LIST
44455: LIST
44456: LIST
44457: LIST
44458: LIST
44459: LIST
44460: LIST
44461: LIST
44462: LIST
44463: LIST
44464: LIST
44465: LIST
44466: LIST
44467: LIST
44468: LIST
44469: LIST
44470: LIST
44471: LIST
44472: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44473: LD_ADDR_VAR 0 31
44477: PUSH
44478: LD_INT 0
44480: PUSH
44481: LD_INT 4
44483: PUSH
44484: EMPTY
44485: LIST
44486: LIST
44487: PUSH
44488: LD_INT 0
44490: PUSH
44491: LD_INT 3
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: PUSH
44498: LD_INT 1
44500: PUSH
44501: LD_INT 4
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: PUSH
44508: LD_INT 1
44510: PUSH
44511: LD_INT 5
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: PUSH
44518: LD_INT 0
44520: PUSH
44521: LD_INT 5
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 1
44530: NEG
44531: PUSH
44532: LD_INT 4
44534: PUSH
44535: EMPTY
44536: LIST
44537: LIST
44538: PUSH
44539: LD_INT 1
44541: NEG
44542: PUSH
44543: LD_INT 3
44545: PUSH
44546: EMPTY
44547: LIST
44548: LIST
44549: PUSH
44550: LD_INT 2
44552: PUSH
44553: LD_INT 5
44555: PUSH
44556: EMPTY
44557: LIST
44558: LIST
44559: PUSH
44560: LD_INT 2
44562: NEG
44563: PUSH
44564: LD_INT 3
44566: PUSH
44567: EMPTY
44568: LIST
44569: LIST
44570: PUSH
44571: LD_INT 3
44573: NEG
44574: PUSH
44575: LD_INT 0
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: PUSH
44582: LD_INT 3
44584: NEG
44585: PUSH
44586: LD_INT 1
44588: NEG
44589: PUSH
44590: EMPTY
44591: LIST
44592: LIST
44593: PUSH
44594: LD_INT 2
44596: NEG
44597: PUSH
44598: LD_INT 0
44600: PUSH
44601: EMPTY
44602: LIST
44603: LIST
44604: PUSH
44605: LD_INT 2
44607: NEG
44608: PUSH
44609: LD_INT 1
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 3
44618: NEG
44619: PUSH
44620: LD_INT 1
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PUSH
44627: LD_INT 4
44629: NEG
44630: PUSH
44631: LD_INT 0
44633: PUSH
44634: EMPTY
44635: LIST
44636: LIST
44637: PUSH
44638: LD_INT 4
44640: NEG
44641: PUSH
44642: LD_INT 1
44644: NEG
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: PUSH
44650: LD_INT 4
44652: NEG
44653: PUSH
44654: LD_INT 2
44656: NEG
44657: PUSH
44658: EMPTY
44659: LIST
44660: LIST
44661: PUSH
44662: LD_INT 2
44664: NEG
44665: PUSH
44666: LD_INT 2
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 4
44675: NEG
44676: PUSH
44677: LD_INT 4
44679: NEG
44680: PUSH
44681: EMPTY
44682: LIST
44683: LIST
44684: PUSH
44685: LD_INT 4
44687: NEG
44688: PUSH
44689: LD_INT 5
44691: NEG
44692: PUSH
44693: EMPTY
44694: LIST
44695: LIST
44696: PUSH
44697: LD_INT 3
44699: NEG
44700: PUSH
44701: LD_INT 4
44703: NEG
44704: PUSH
44705: EMPTY
44706: LIST
44707: LIST
44708: PUSH
44709: LD_INT 3
44711: NEG
44712: PUSH
44713: LD_INT 3
44715: NEG
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: PUSH
44721: LD_INT 4
44723: NEG
44724: PUSH
44725: LD_INT 3
44727: NEG
44728: PUSH
44729: EMPTY
44730: LIST
44731: LIST
44732: PUSH
44733: LD_INT 5
44735: NEG
44736: PUSH
44737: LD_INT 4
44739: NEG
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 5
44747: NEG
44748: PUSH
44749: LD_INT 5
44751: NEG
44752: PUSH
44753: EMPTY
44754: LIST
44755: LIST
44756: PUSH
44757: LD_INT 3
44759: NEG
44760: PUSH
44761: LD_INT 5
44763: NEG
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: PUSH
44769: LD_INT 5
44771: NEG
44772: PUSH
44773: LD_INT 3
44775: NEG
44776: PUSH
44777: EMPTY
44778: LIST
44779: LIST
44780: PUSH
44781: LD_INT 0
44783: PUSH
44784: LD_INT 3
44786: NEG
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 0
44794: PUSH
44795: LD_INT 4
44797: NEG
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 1
44805: PUSH
44806: LD_INT 3
44808: NEG
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: LD_INT 1
44816: PUSH
44817: LD_INT 2
44819: NEG
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: LD_INT 0
44827: PUSH
44828: LD_INT 2
44830: NEG
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PUSH
44836: LD_INT 1
44838: NEG
44839: PUSH
44840: LD_INT 3
44842: NEG
44843: PUSH
44844: EMPTY
44845: LIST
44846: LIST
44847: PUSH
44848: LD_INT 1
44850: NEG
44851: PUSH
44852: LD_INT 4
44854: NEG
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 2
44862: PUSH
44863: LD_INT 2
44865: NEG
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 2
44873: NEG
44874: PUSH
44875: LD_INT 4
44877: NEG
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 4
44885: PUSH
44886: LD_INT 0
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 4
44895: PUSH
44896: LD_INT 1
44898: NEG
44899: PUSH
44900: EMPTY
44901: LIST
44902: LIST
44903: PUSH
44904: LD_INT 5
44906: PUSH
44907: LD_INT 0
44909: PUSH
44910: EMPTY
44911: LIST
44912: LIST
44913: PUSH
44914: LD_INT 5
44916: PUSH
44917: LD_INT 1
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: PUSH
44924: LD_INT 4
44926: PUSH
44927: LD_INT 1
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: LD_INT 3
44936: PUSH
44937: LD_INT 0
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 3
44946: PUSH
44947: LD_INT 1
44949: NEG
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 3
44957: PUSH
44958: LD_INT 2
44960: NEG
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 5
44968: PUSH
44969: LD_INT 2
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: LIST
44980: LIST
44981: LIST
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: LIST
44987: LIST
44988: LIST
44989: LIST
44990: LIST
44991: LIST
44992: LIST
44993: LIST
44994: LIST
44995: LIST
44996: LIST
44997: LIST
44998: LIST
44999: LIST
45000: LIST
45001: LIST
45002: LIST
45003: LIST
45004: LIST
45005: LIST
45006: LIST
45007: LIST
45008: LIST
45009: LIST
45010: LIST
45011: LIST
45012: LIST
45013: LIST
45014: LIST
45015: LIST
45016: LIST
45017: LIST
45018: LIST
45019: LIST
45020: LIST
45021: LIST
45022: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45023: LD_ADDR_VAR 0 32
45027: PUSH
45028: LD_INT 4
45030: NEG
45031: PUSH
45032: LD_INT 0
45034: PUSH
45035: EMPTY
45036: LIST
45037: LIST
45038: PUSH
45039: LD_INT 4
45041: NEG
45042: PUSH
45043: LD_INT 1
45045: NEG
45046: PUSH
45047: EMPTY
45048: LIST
45049: LIST
45050: PUSH
45051: LD_INT 3
45053: NEG
45054: PUSH
45055: LD_INT 0
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: LD_INT 3
45064: NEG
45065: PUSH
45066: LD_INT 1
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 4
45075: NEG
45076: PUSH
45077: LD_INT 1
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: PUSH
45084: LD_INT 5
45086: NEG
45087: PUSH
45088: LD_INT 0
45090: PUSH
45091: EMPTY
45092: LIST
45093: LIST
45094: PUSH
45095: LD_INT 5
45097: NEG
45098: PUSH
45099: LD_INT 1
45101: NEG
45102: PUSH
45103: EMPTY
45104: LIST
45105: LIST
45106: PUSH
45107: LD_INT 5
45109: NEG
45110: PUSH
45111: LD_INT 2
45113: NEG
45114: PUSH
45115: EMPTY
45116: LIST
45117: LIST
45118: PUSH
45119: LD_INT 3
45121: NEG
45122: PUSH
45123: LD_INT 2
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: PUSH
45130: LD_INT 3
45132: NEG
45133: PUSH
45134: LD_INT 3
45136: NEG
45137: PUSH
45138: EMPTY
45139: LIST
45140: LIST
45141: PUSH
45142: LD_INT 3
45144: NEG
45145: PUSH
45146: LD_INT 4
45148: NEG
45149: PUSH
45150: EMPTY
45151: LIST
45152: LIST
45153: PUSH
45154: LD_INT 2
45156: NEG
45157: PUSH
45158: LD_INT 3
45160: NEG
45161: PUSH
45162: EMPTY
45163: LIST
45164: LIST
45165: PUSH
45166: LD_INT 2
45168: NEG
45169: PUSH
45170: LD_INT 2
45172: NEG
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: LD_INT 3
45180: NEG
45181: PUSH
45182: LD_INT 2
45184: NEG
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: PUSH
45190: LD_INT 4
45192: NEG
45193: PUSH
45194: LD_INT 3
45196: NEG
45197: PUSH
45198: EMPTY
45199: LIST
45200: LIST
45201: PUSH
45202: LD_INT 4
45204: NEG
45205: PUSH
45206: LD_INT 4
45208: NEG
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PUSH
45214: LD_INT 2
45216: NEG
45217: PUSH
45218: LD_INT 4
45220: NEG
45221: PUSH
45222: EMPTY
45223: LIST
45224: LIST
45225: PUSH
45226: LD_INT 4
45228: NEG
45229: PUSH
45230: LD_INT 2
45232: NEG
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: PUSH
45238: LD_INT 0
45240: PUSH
45241: LD_INT 4
45243: NEG
45244: PUSH
45245: EMPTY
45246: LIST
45247: LIST
45248: PUSH
45249: LD_INT 0
45251: PUSH
45252: LD_INT 5
45254: NEG
45255: PUSH
45256: EMPTY
45257: LIST
45258: LIST
45259: PUSH
45260: LD_INT 1
45262: PUSH
45263: LD_INT 4
45265: NEG
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 1
45273: PUSH
45274: LD_INT 3
45276: NEG
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: PUSH
45282: LD_INT 0
45284: PUSH
45285: LD_INT 3
45287: NEG
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PUSH
45293: LD_INT 1
45295: NEG
45296: PUSH
45297: LD_INT 4
45299: NEG
45300: PUSH
45301: EMPTY
45302: LIST
45303: LIST
45304: PUSH
45305: LD_INT 1
45307: NEG
45308: PUSH
45309: LD_INT 5
45311: NEG
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 2
45319: PUSH
45320: LD_INT 3
45322: NEG
45323: PUSH
45324: EMPTY
45325: LIST
45326: LIST
45327: PUSH
45328: LD_INT 2
45330: NEG
45331: PUSH
45332: LD_INT 5
45334: NEG
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: PUSH
45340: LD_INT 3
45342: PUSH
45343: LD_INT 0
45345: PUSH
45346: EMPTY
45347: LIST
45348: LIST
45349: PUSH
45350: LD_INT 3
45352: PUSH
45353: LD_INT 1
45355: NEG
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: PUSH
45361: LD_INT 4
45363: PUSH
45364: LD_INT 0
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: PUSH
45371: LD_INT 4
45373: PUSH
45374: LD_INT 1
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: LD_INT 3
45383: PUSH
45384: LD_INT 1
45386: PUSH
45387: EMPTY
45388: LIST
45389: LIST
45390: PUSH
45391: LD_INT 2
45393: PUSH
45394: LD_INT 0
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 2
45403: PUSH
45404: LD_INT 1
45406: NEG
45407: PUSH
45408: EMPTY
45409: LIST
45410: LIST
45411: PUSH
45412: LD_INT 2
45414: PUSH
45415: LD_INT 2
45417: NEG
45418: PUSH
45419: EMPTY
45420: LIST
45421: LIST
45422: PUSH
45423: LD_INT 4
45425: PUSH
45426: LD_INT 2
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 4
45435: PUSH
45436: LD_INT 4
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 4
45445: PUSH
45446: LD_INT 3
45448: PUSH
45449: EMPTY
45450: LIST
45451: LIST
45452: PUSH
45453: LD_INT 5
45455: PUSH
45456: LD_INT 4
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: PUSH
45463: LD_INT 5
45465: PUSH
45466: LD_INT 5
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 4
45475: PUSH
45476: LD_INT 5
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: PUSH
45483: LD_INT 3
45485: PUSH
45486: LD_INT 4
45488: PUSH
45489: EMPTY
45490: LIST
45491: LIST
45492: PUSH
45493: LD_INT 3
45495: PUSH
45496: LD_INT 3
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 5
45505: PUSH
45506: LD_INT 3
45508: PUSH
45509: EMPTY
45510: LIST
45511: LIST
45512: PUSH
45513: LD_INT 3
45515: PUSH
45516: LD_INT 5
45518: PUSH
45519: EMPTY
45520: LIST
45521: LIST
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: LIST
45550: LIST
45551: LIST
45552: LIST
45553: LIST
45554: LIST
45555: LIST
45556: LIST
45557: LIST
45558: LIST
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45570: LD_ADDR_VAR 0 33
45574: PUSH
45575: LD_INT 4
45577: NEG
45578: PUSH
45579: LD_INT 4
45581: NEG
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: PUSH
45587: LD_INT 4
45589: NEG
45590: PUSH
45591: LD_INT 5
45593: NEG
45594: PUSH
45595: EMPTY
45596: LIST
45597: LIST
45598: PUSH
45599: LD_INT 3
45601: NEG
45602: PUSH
45603: LD_INT 4
45605: NEG
45606: PUSH
45607: EMPTY
45608: LIST
45609: LIST
45610: PUSH
45611: LD_INT 3
45613: NEG
45614: PUSH
45615: LD_INT 3
45617: NEG
45618: PUSH
45619: EMPTY
45620: LIST
45621: LIST
45622: PUSH
45623: LD_INT 4
45625: NEG
45626: PUSH
45627: LD_INT 3
45629: NEG
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: PUSH
45635: LD_INT 5
45637: NEG
45638: PUSH
45639: LD_INT 4
45641: NEG
45642: PUSH
45643: EMPTY
45644: LIST
45645: LIST
45646: PUSH
45647: LD_INT 5
45649: NEG
45650: PUSH
45651: LD_INT 5
45653: NEG
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 3
45661: NEG
45662: PUSH
45663: LD_INT 5
45665: NEG
45666: PUSH
45667: EMPTY
45668: LIST
45669: LIST
45670: PUSH
45671: LD_INT 5
45673: NEG
45674: PUSH
45675: LD_INT 3
45677: NEG
45678: PUSH
45679: EMPTY
45680: LIST
45681: LIST
45682: PUSH
45683: LD_INT 0
45685: PUSH
45686: LD_INT 3
45688: NEG
45689: PUSH
45690: EMPTY
45691: LIST
45692: LIST
45693: PUSH
45694: LD_INT 0
45696: PUSH
45697: LD_INT 4
45699: NEG
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: PUSH
45705: LD_INT 1
45707: PUSH
45708: LD_INT 3
45710: NEG
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 1
45718: PUSH
45719: LD_INT 2
45721: NEG
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: LD_INT 0
45729: PUSH
45730: LD_INT 2
45732: NEG
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: PUSH
45738: LD_INT 1
45740: NEG
45741: PUSH
45742: LD_INT 3
45744: NEG
45745: PUSH
45746: EMPTY
45747: LIST
45748: LIST
45749: PUSH
45750: LD_INT 1
45752: NEG
45753: PUSH
45754: LD_INT 4
45756: NEG
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 2
45764: PUSH
45765: LD_INT 2
45767: NEG
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: PUSH
45773: LD_INT 2
45775: NEG
45776: PUSH
45777: LD_INT 4
45779: NEG
45780: PUSH
45781: EMPTY
45782: LIST
45783: LIST
45784: PUSH
45785: LD_INT 4
45787: PUSH
45788: LD_INT 0
45790: PUSH
45791: EMPTY
45792: LIST
45793: LIST
45794: PUSH
45795: LD_INT 4
45797: PUSH
45798: LD_INT 1
45800: NEG
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: LD_INT 5
45808: PUSH
45809: LD_INT 0
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 5
45818: PUSH
45819: LD_INT 1
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: LD_INT 4
45828: PUSH
45829: LD_INT 1
45831: PUSH
45832: EMPTY
45833: LIST
45834: LIST
45835: PUSH
45836: LD_INT 3
45838: PUSH
45839: LD_INT 0
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: PUSH
45846: LD_INT 3
45848: PUSH
45849: LD_INT 1
45851: NEG
45852: PUSH
45853: EMPTY
45854: LIST
45855: LIST
45856: PUSH
45857: LD_INT 3
45859: PUSH
45860: LD_INT 2
45862: NEG
45863: PUSH
45864: EMPTY
45865: LIST
45866: LIST
45867: PUSH
45868: LD_INT 5
45870: PUSH
45871: LD_INT 2
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: PUSH
45878: LD_INT 3
45880: PUSH
45881: LD_INT 3
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: PUSH
45888: LD_INT 3
45890: PUSH
45891: LD_INT 2
45893: PUSH
45894: EMPTY
45895: LIST
45896: LIST
45897: PUSH
45898: LD_INT 4
45900: PUSH
45901: LD_INT 3
45903: PUSH
45904: EMPTY
45905: LIST
45906: LIST
45907: PUSH
45908: LD_INT 4
45910: PUSH
45911: LD_INT 4
45913: PUSH
45914: EMPTY
45915: LIST
45916: LIST
45917: PUSH
45918: LD_INT 3
45920: PUSH
45921: LD_INT 4
45923: PUSH
45924: EMPTY
45925: LIST
45926: LIST
45927: PUSH
45928: LD_INT 2
45930: PUSH
45931: LD_INT 3
45933: PUSH
45934: EMPTY
45935: LIST
45936: LIST
45937: PUSH
45938: LD_INT 2
45940: PUSH
45941: LD_INT 2
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: PUSH
45948: LD_INT 4
45950: PUSH
45951: LD_INT 2
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: PUSH
45958: LD_INT 2
45960: PUSH
45961: LD_INT 4
45963: PUSH
45964: EMPTY
45965: LIST
45966: LIST
45967: PUSH
45968: LD_INT 0
45970: PUSH
45971: LD_INT 4
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 0
45980: PUSH
45981: LD_INT 3
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: PUSH
45988: LD_INT 1
45990: PUSH
45991: LD_INT 4
45993: PUSH
45994: EMPTY
45995: LIST
45996: LIST
45997: PUSH
45998: LD_INT 1
46000: PUSH
46001: LD_INT 5
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 0
46010: PUSH
46011: LD_INT 5
46013: PUSH
46014: EMPTY
46015: LIST
46016: LIST
46017: PUSH
46018: LD_INT 1
46020: NEG
46021: PUSH
46022: LD_INT 4
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 1
46031: NEG
46032: PUSH
46033: LD_INT 3
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: PUSH
46040: LD_INT 2
46042: PUSH
46043: LD_INT 5
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: PUSH
46050: LD_INT 2
46052: NEG
46053: PUSH
46054: LD_INT 3
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: PUSH
46061: EMPTY
46062: LIST
46063: LIST
46064: LIST
46065: LIST
46066: LIST
46067: LIST
46068: LIST
46069: LIST
46070: LIST
46071: LIST
46072: LIST
46073: LIST
46074: LIST
46075: LIST
46076: LIST
46077: LIST
46078: LIST
46079: LIST
46080: LIST
46081: LIST
46082: LIST
46083: LIST
46084: LIST
46085: LIST
46086: LIST
46087: LIST
46088: LIST
46089: LIST
46090: LIST
46091: LIST
46092: LIST
46093: LIST
46094: LIST
46095: LIST
46096: LIST
46097: LIST
46098: LIST
46099: LIST
46100: LIST
46101: LIST
46102: LIST
46103: LIST
46104: LIST
46105: LIST
46106: LIST
46107: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46108: LD_ADDR_VAR 0 34
46112: PUSH
46113: LD_INT 0
46115: PUSH
46116: LD_INT 4
46118: NEG
46119: PUSH
46120: EMPTY
46121: LIST
46122: LIST
46123: PUSH
46124: LD_INT 0
46126: PUSH
46127: LD_INT 5
46129: NEG
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 1
46137: PUSH
46138: LD_INT 4
46140: NEG
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 1
46148: PUSH
46149: LD_INT 3
46151: NEG
46152: PUSH
46153: EMPTY
46154: LIST
46155: LIST
46156: PUSH
46157: LD_INT 0
46159: PUSH
46160: LD_INT 3
46162: NEG
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: PUSH
46168: LD_INT 1
46170: NEG
46171: PUSH
46172: LD_INT 4
46174: NEG
46175: PUSH
46176: EMPTY
46177: LIST
46178: LIST
46179: PUSH
46180: LD_INT 1
46182: NEG
46183: PUSH
46184: LD_INT 5
46186: NEG
46187: PUSH
46188: EMPTY
46189: LIST
46190: LIST
46191: PUSH
46192: LD_INT 2
46194: PUSH
46195: LD_INT 3
46197: NEG
46198: PUSH
46199: EMPTY
46200: LIST
46201: LIST
46202: PUSH
46203: LD_INT 2
46205: NEG
46206: PUSH
46207: LD_INT 5
46209: NEG
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: PUSH
46215: LD_INT 3
46217: PUSH
46218: LD_INT 0
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 3
46227: PUSH
46228: LD_INT 1
46230: NEG
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 4
46238: PUSH
46239: LD_INT 0
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 4
46248: PUSH
46249: LD_INT 1
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 3
46258: PUSH
46259: LD_INT 1
46261: PUSH
46262: EMPTY
46263: LIST
46264: LIST
46265: PUSH
46266: LD_INT 2
46268: PUSH
46269: LD_INT 0
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: LD_INT 2
46278: PUSH
46279: LD_INT 1
46281: NEG
46282: PUSH
46283: EMPTY
46284: LIST
46285: LIST
46286: PUSH
46287: LD_INT 2
46289: PUSH
46290: LD_INT 2
46292: NEG
46293: PUSH
46294: EMPTY
46295: LIST
46296: LIST
46297: PUSH
46298: LD_INT 4
46300: PUSH
46301: LD_INT 2
46303: PUSH
46304: EMPTY
46305: LIST
46306: LIST
46307: PUSH
46308: LD_INT 4
46310: PUSH
46311: LD_INT 4
46313: PUSH
46314: EMPTY
46315: LIST
46316: LIST
46317: PUSH
46318: LD_INT 4
46320: PUSH
46321: LD_INT 3
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: PUSH
46328: LD_INT 5
46330: PUSH
46331: LD_INT 4
46333: PUSH
46334: EMPTY
46335: LIST
46336: LIST
46337: PUSH
46338: LD_INT 5
46340: PUSH
46341: LD_INT 5
46343: PUSH
46344: EMPTY
46345: LIST
46346: LIST
46347: PUSH
46348: LD_INT 4
46350: PUSH
46351: LD_INT 5
46353: PUSH
46354: EMPTY
46355: LIST
46356: LIST
46357: PUSH
46358: LD_INT 3
46360: PUSH
46361: LD_INT 4
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 3
46370: PUSH
46371: LD_INT 3
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PUSH
46378: LD_INT 5
46380: PUSH
46381: LD_INT 3
46383: PUSH
46384: EMPTY
46385: LIST
46386: LIST
46387: PUSH
46388: LD_INT 3
46390: PUSH
46391: LD_INT 5
46393: PUSH
46394: EMPTY
46395: LIST
46396: LIST
46397: PUSH
46398: LD_INT 0
46400: PUSH
46401: LD_INT 3
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: PUSH
46408: LD_INT 0
46410: PUSH
46411: LD_INT 2
46413: PUSH
46414: EMPTY
46415: LIST
46416: LIST
46417: PUSH
46418: LD_INT 1
46420: PUSH
46421: LD_INT 3
46423: PUSH
46424: EMPTY
46425: LIST
46426: LIST
46427: PUSH
46428: LD_INT 1
46430: PUSH
46431: LD_INT 4
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: LD_INT 0
46440: PUSH
46441: LD_INT 4
46443: PUSH
46444: EMPTY
46445: LIST
46446: LIST
46447: PUSH
46448: LD_INT 1
46450: NEG
46451: PUSH
46452: LD_INT 3
46454: PUSH
46455: EMPTY
46456: LIST
46457: LIST
46458: PUSH
46459: LD_INT 1
46461: NEG
46462: PUSH
46463: LD_INT 2
46465: PUSH
46466: EMPTY
46467: LIST
46468: LIST
46469: PUSH
46470: LD_INT 2
46472: PUSH
46473: LD_INT 4
46475: PUSH
46476: EMPTY
46477: LIST
46478: LIST
46479: PUSH
46480: LD_INT 2
46482: NEG
46483: PUSH
46484: LD_INT 2
46486: PUSH
46487: EMPTY
46488: LIST
46489: LIST
46490: PUSH
46491: LD_INT 4
46493: NEG
46494: PUSH
46495: LD_INT 0
46497: PUSH
46498: EMPTY
46499: LIST
46500: LIST
46501: PUSH
46502: LD_INT 4
46504: NEG
46505: PUSH
46506: LD_INT 1
46508: NEG
46509: PUSH
46510: EMPTY
46511: LIST
46512: LIST
46513: PUSH
46514: LD_INT 3
46516: NEG
46517: PUSH
46518: LD_INT 0
46520: PUSH
46521: EMPTY
46522: LIST
46523: LIST
46524: PUSH
46525: LD_INT 3
46527: NEG
46528: PUSH
46529: LD_INT 1
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: PUSH
46536: LD_INT 4
46538: NEG
46539: PUSH
46540: LD_INT 1
46542: PUSH
46543: EMPTY
46544: LIST
46545: LIST
46546: PUSH
46547: LD_INT 5
46549: NEG
46550: PUSH
46551: LD_INT 0
46553: PUSH
46554: EMPTY
46555: LIST
46556: LIST
46557: PUSH
46558: LD_INT 5
46560: NEG
46561: PUSH
46562: LD_INT 1
46564: NEG
46565: PUSH
46566: EMPTY
46567: LIST
46568: LIST
46569: PUSH
46570: LD_INT 5
46572: NEG
46573: PUSH
46574: LD_INT 2
46576: NEG
46577: PUSH
46578: EMPTY
46579: LIST
46580: LIST
46581: PUSH
46582: LD_INT 3
46584: NEG
46585: PUSH
46586: LD_INT 2
46588: PUSH
46589: EMPTY
46590: LIST
46591: LIST
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: LIST
46630: LIST
46631: LIST
46632: LIST
46633: LIST
46634: LIST
46635: LIST
46636: LIST
46637: LIST
46638: LIST
46639: ST_TO_ADDR
// end ; end ;
46640: GO 46643
46642: POP
// case btype of b_depot , b_warehouse :
46643: LD_VAR 0 1
46647: PUSH
46648: LD_INT 0
46650: DOUBLE
46651: EQUAL
46652: IFTRUE 46662
46654: LD_INT 1
46656: DOUBLE
46657: EQUAL
46658: IFTRUE 46662
46660: GO 46863
46662: POP
// case nation of nation_american :
46663: LD_VAR 0 5
46667: PUSH
46668: LD_INT 1
46670: DOUBLE
46671: EQUAL
46672: IFTRUE 46676
46674: GO 46732
46676: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46677: LD_ADDR_VAR 0 9
46681: PUSH
46682: LD_VAR 0 11
46686: PUSH
46687: LD_VAR 0 12
46691: PUSH
46692: LD_VAR 0 13
46696: PUSH
46697: LD_VAR 0 14
46701: PUSH
46702: LD_VAR 0 15
46706: PUSH
46707: LD_VAR 0 16
46711: PUSH
46712: EMPTY
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: LIST
46718: LIST
46719: PUSH
46720: LD_VAR 0 4
46724: PUSH
46725: LD_INT 1
46727: PLUS
46728: ARRAY
46729: ST_TO_ADDR
46730: GO 46861
46732: LD_INT 2
46734: DOUBLE
46735: EQUAL
46736: IFTRUE 46740
46738: GO 46796
46740: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46741: LD_ADDR_VAR 0 9
46745: PUSH
46746: LD_VAR 0 17
46750: PUSH
46751: LD_VAR 0 18
46755: PUSH
46756: LD_VAR 0 19
46760: PUSH
46761: LD_VAR 0 20
46765: PUSH
46766: LD_VAR 0 21
46770: PUSH
46771: LD_VAR 0 22
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: PUSH
46784: LD_VAR 0 4
46788: PUSH
46789: LD_INT 1
46791: PLUS
46792: ARRAY
46793: ST_TO_ADDR
46794: GO 46861
46796: LD_INT 3
46798: DOUBLE
46799: EQUAL
46800: IFTRUE 46804
46802: GO 46860
46804: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46805: LD_ADDR_VAR 0 9
46809: PUSH
46810: LD_VAR 0 23
46814: PUSH
46815: LD_VAR 0 24
46819: PUSH
46820: LD_VAR 0 25
46824: PUSH
46825: LD_VAR 0 26
46829: PUSH
46830: LD_VAR 0 27
46834: PUSH
46835: LD_VAR 0 28
46839: PUSH
46840: EMPTY
46841: LIST
46842: LIST
46843: LIST
46844: LIST
46845: LIST
46846: LIST
46847: PUSH
46848: LD_VAR 0 4
46852: PUSH
46853: LD_INT 1
46855: PLUS
46856: ARRAY
46857: ST_TO_ADDR
46858: GO 46861
46860: POP
46861: GO 47416
46863: LD_INT 2
46865: DOUBLE
46866: EQUAL
46867: IFTRUE 46877
46869: LD_INT 3
46871: DOUBLE
46872: EQUAL
46873: IFTRUE 46877
46875: GO 46933
46877: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46878: LD_ADDR_VAR 0 9
46882: PUSH
46883: LD_VAR 0 29
46887: PUSH
46888: LD_VAR 0 30
46892: PUSH
46893: LD_VAR 0 31
46897: PUSH
46898: LD_VAR 0 32
46902: PUSH
46903: LD_VAR 0 33
46907: PUSH
46908: LD_VAR 0 34
46912: PUSH
46913: EMPTY
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: LIST
46919: LIST
46920: PUSH
46921: LD_VAR 0 4
46925: PUSH
46926: LD_INT 1
46928: PLUS
46929: ARRAY
46930: ST_TO_ADDR
46931: GO 47416
46933: LD_INT 16
46935: DOUBLE
46936: EQUAL
46937: IFTRUE 46995
46939: LD_INT 17
46941: DOUBLE
46942: EQUAL
46943: IFTRUE 46995
46945: LD_INT 18
46947: DOUBLE
46948: EQUAL
46949: IFTRUE 46995
46951: LD_INT 19
46953: DOUBLE
46954: EQUAL
46955: IFTRUE 46995
46957: LD_INT 22
46959: DOUBLE
46960: EQUAL
46961: IFTRUE 46995
46963: LD_INT 20
46965: DOUBLE
46966: EQUAL
46967: IFTRUE 46995
46969: LD_INT 21
46971: DOUBLE
46972: EQUAL
46973: IFTRUE 46995
46975: LD_INT 23
46977: DOUBLE
46978: EQUAL
46979: IFTRUE 46995
46981: LD_INT 24
46983: DOUBLE
46984: EQUAL
46985: IFTRUE 46995
46987: LD_INT 25
46989: DOUBLE
46990: EQUAL
46991: IFTRUE 46995
46993: GO 47051
46995: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46996: LD_ADDR_VAR 0 9
47000: PUSH
47001: LD_VAR 0 35
47005: PUSH
47006: LD_VAR 0 36
47010: PUSH
47011: LD_VAR 0 37
47015: PUSH
47016: LD_VAR 0 38
47020: PUSH
47021: LD_VAR 0 39
47025: PUSH
47026: LD_VAR 0 40
47030: PUSH
47031: EMPTY
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: PUSH
47039: LD_VAR 0 4
47043: PUSH
47044: LD_INT 1
47046: PLUS
47047: ARRAY
47048: ST_TO_ADDR
47049: GO 47416
47051: LD_INT 6
47053: DOUBLE
47054: EQUAL
47055: IFTRUE 47107
47057: LD_INT 7
47059: DOUBLE
47060: EQUAL
47061: IFTRUE 47107
47063: LD_INT 8
47065: DOUBLE
47066: EQUAL
47067: IFTRUE 47107
47069: LD_INT 13
47071: DOUBLE
47072: EQUAL
47073: IFTRUE 47107
47075: LD_INT 12
47077: DOUBLE
47078: EQUAL
47079: IFTRUE 47107
47081: LD_INT 15
47083: DOUBLE
47084: EQUAL
47085: IFTRUE 47107
47087: LD_INT 11
47089: DOUBLE
47090: EQUAL
47091: IFTRUE 47107
47093: LD_INT 14
47095: DOUBLE
47096: EQUAL
47097: IFTRUE 47107
47099: LD_INT 10
47101: DOUBLE
47102: EQUAL
47103: IFTRUE 47107
47105: GO 47163
47107: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
47108: LD_ADDR_VAR 0 9
47112: PUSH
47113: LD_VAR 0 41
47117: PUSH
47118: LD_VAR 0 42
47122: PUSH
47123: LD_VAR 0 43
47127: PUSH
47128: LD_VAR 0 44
47132: PUSH
47133: LD_VAR 0 45
47137: PUSH
47138: LD_VAR 0 46
47142: PUSH
47143: EMPTY
47144: LIST
47145: LIST
47146: LIST
47147: LIST
47148: LIST
47149: LIST
47150: PUSH
47151: LD_VAR 0 4
47155: PUSH
47156: LD_INT 1
47158: PLUS
47159: ARRAY
47160: ST_TO_ADDR
47161: GO 47416
47163: LD_INT 36
47165: DOUBLE
47166: EQUAL
47167: IFTRUE 47171
47169: GO 47227
47171: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47172: LD_ADDR_VAR 0 9
47176: PUSH
47177: LD_VAR 0 47
47181: PUSH
47182: LD_VAR 0 48
47186: PUSH
47187: LD_VAR 0 49
47191: PUSH
47192: LD_VAR 0 50
47196: PUSH
47197: LD_VAR 0 51
47201: PUSH
47202: LD_VAR 0 52
47206: PUSH
47207: EMPTY
47208: LIST
47209: LIST
47210: LIST
47211: LIST
47212: LIST
47213: LIST
47214: PUSH
47215: LD_VAR 0 4
47219: PUSH
47220: LD_INT 1
47222: PLUS
47223: ARRAY
47224: ST_TO_ADDR
47225: GO 47416
47227: LD_INT 4
47229: DOUBLE
47230: EQUAL
47231: IFTRUE 47253
47233: LD_INT 5
47235: DOUBLE
47236: EQUAL
47237: IFTRUE 47253
47239: LD_INT 34
47241: DOUBLE
47242: EQUAL
47243: IFTRUE 47253
47245: LD_INT 37
47247: DOUBLE
47248: EQUAL
47249: IFTRUE 47253
47251: GO 47309
47253: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47254: LD_ADDR_VAR 0 9
47258: PUSH
47259: LD_VAR 0 53
47263: PUSH
47264: LD_VAR 0 54
47268: PUSH
47269: LD_VAR 0 55
47273: PUSH
47274: LD_VAR 0 56
47278: PUSH
47279: LD_VAR 0 57
47283: PUSH
47284: LD_VAR 0 58
47288: PUSH
47289: EMPTY
47290: LIST
47291: LIST
47292: LIST
47293: LIST
47294: LIST
47295: LIST
47296: PUSH
47297: LD_VAR 0 4
47301: PUSH
47302: LD_INT 1
47304: PLUS
47305: ARRAY
47306: ST_TO_ADDR
47307: GO 47416
47309: LD_INT 31
47311: DOUBLE
47312: EQUAL
47313: IFTRUE 47359
47315: LD_INT 32
47317: DOUBLE
47318: EQUAL
47319: IFTRUE 47359
47321: LD_INT 33
47323: DOUBLE
47324: EQUAL
47325: IFTRUE 47359
47327: LD_INT 27
47329: DOUBLE
47330: EQUAL
47331: IFTRUE 47359
47333: LD_INT 26
47335: DOUBLE
47336: EQUAL
47337: IFTRUE 47359
47339: LD_INT 28
47341: DOUBLE
47342: EQUAL
47343: IFTRUE 47359
47345: LD_INT 29
47347: DOUBLE
47348: EQUAL
47349: IFTRUE 47359
47351: LD_INT 30
47353: DOUBLE
47354: EQUAL
47355: IFTRUE 47359
47357: GO 47415
47359: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47360: LD_ADDR_VAR 0 9
47364: PUSH
47365: LD_VAR 0 59
47369: PUSH
47370: LD_VAR 0 60
47374: PUSH
47375: LD_VAR 0 61
47379: PUSH
47380: LD_VAR 0 62
47384: PUSH
47385: LD_VAR 0 63
47389: PUSH
47390: LD_VAR 0 64
47394: PUSH
47395: EMPTY
47396: LIST
47397: LIST
47398: LIST
47399: LIST
47400: LIST
47401: LIST
47402: PUSH
47403: LD_VAR 0 4
47407: PUSH
47408: LD_INT 1
47410: PLUS
47411: ARRAY
47412: ST_TO_ADDR
47413: GO 47416
47415: POP
// temp_list2 = [ ] ;
47416: LD_ADDR_VAR 0 10
47420: PUSH
47421: EMPTY
47422: ST_TO_ADDR
// for i in temp_list do
47423: LD_ADDR_VAR 0 8
47427: PUSH
47428: LD_VAR 0 9
47432: PUSH
47433: FOR_IN
47434: IFFALSE 47486
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47436: LD_ADDR_VAR 0 10
47440: PUSH
47441: LD_VAR 0 10
47445: PUSH
47446: LD_VAR 0 8
47450: PUSH
47451: LD_INT 1
47453: ARRAY
47454: PUSH
47455: LD_VAR 0 2
47459: PLUS
47460: PUSH
47461: LD_VAR 0 8
47465: PUSH
47466: LD_INT 2
47468: ARRAY
47469: PUSH
47470: LD_VAR 0 3
47474: PLUS
47475: PUSH
47476: EMPTY
47477: LIST
47478: LIST
47479: PUSH
47480: EMPTY
47481: LIST
47482: ADD
47483: ST_TO_ADDR
47484: GO 47433
47486: POP
47487: POP
// result = temp_list2 ;
47488: LD_ADDR_VAR 0 7
47492: PUSH
47493: LD_VAR 0 10
47497: ST_TO_ADDR
// end ;
47498: LD_VAR 0 7
47502: RET
// export function EnemyInRange ( unit , dist ) ; begin
47503: LD_INT 0
47505: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47506: LD_ADDR_VAR 0 3
47510: PUSH
47511: LD_VAR 0 1
47515: PPUSH
47516: CALL_OW 255
47520: PPUSH
47521: LD_VAR 0 1
47525: PPUSH
47526: CALL_OW 250
47530: PPUSH
47531: LD_VAR 0 1
47535: PPUSH
47536: CALL_OW 251
47540: PPUSH
47541: LD_VAR 0 2
47545: PPUSH
47546: CALL 20899 0 4
47550: PUSH
47551: LD_INT 4
47553: ARRAY
47554: ST_TO_ADDR
// end ;
47555: LD_VAR 0 3
47559: RET
// export function PlayerSeeMe ( unit ) ; begin
47560: LD_INT 0
47562: PPUSH
// result := See ( your_side , unit ) ;
47563: LD_ADDR_VAR 0 2
47567: PUSH
47568: LD_OWVAR 2
47572: PPUSH
47573: LD_VAR 0 1
47577: PPUSH
47578: CALL_OW 292
47582: ST_TO_ADDR
// end ;
47583: LD_VAR 0 2
47587: RET
// export function ReverseDir ( unit ) ; begin
47588: LD_INT 0
47590: PPUSH
// if not unit then
47591: LD_VAR 0 1
47595: NOT
47596: IFFALSE 47600
// exit ;
47598: GO 47623
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47600: LD_ADDR_VAR 0 2
47604: PUSH
47605: LD_VAR 0 1
47609: PPUSH
47610: CALL_OW 254
47614: PUSH
47615: LD_INT 3
47617: PLUS
47618: PUSH
47619: LD_INT 6
47621: MOD
47622: ST_TO_ADDR
// end ;
47623: LD_VAR 0 2
47627: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47628: LD_INT 0
47630: PPUSH
47631: PPUSH
47632: PPUSH
47633: PPUSH
47634: PPUSH
// if not hexes then
47635: LD_VAR 0 2
47639: NOT
47640: IFFALSE 47644
// exit ;
47642: GO 47792
// dist := 9999 ;
47644: LD_ADDR_VAR 0 5
47648: PUSH
47649: LD_INT 9999
47651: ST_TO_ADDR
// for i = 1 to hexes do
47652: LD_ADDR_VAR 0 4
47656: PUSH
47657: DOUBLE
47658: LD_INT 1
47660: DEC
47661: ST_TO_ADDR
47662: LD_VAR 0 2
47666: PUSH
47667: FOR_TO
47668: IFFALSE 47780
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47670: LD_VAR 0 1
47674: PPUSH
47675: LD_VAR 0 2
47679: PUSH
47680: LD_VAR 0 4
47684: ARRAY
47685: PUSH
47686: LD_INT 1
47688: ARRAY
47689: PPUSH
47690: LD_VAR 0 2
47694: PUSH
47695: LD_VAR 0 4
47699: ARRAY
47700: PUSH
47701: LD_INT 2
47703: ARRAY
47704: PPUSH
47705: CALL_OW 297
47709: PUSH
47710: LD_VAR 0 5
47714: LESS
47715: IFFALSE 47778
// begin hex := hexes [ i ] ;
47717: LD_ADDR_VAR 0 7
47721: PUSH
47722: LD_VAR 0 2
47726: PUSH
47727: LD_VAR 0 4
47731: ARRAY
47732: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47733: LD_ADDR_VAR 0 5
47737: PUSH
47738: LD_VAR 0 1
47742: PPUSH
47743: LD_VAR 0 2
47747: PUSH
47748: LD_VAR 0 4
47752: ARRAY
47753: PUSH
47754: LD_INT 1
47756: ARRAY
47757: PPUSH
47758: LD_VAR 0 2
47762: PUSH
47763: LD_VAR 0 4
47767: ARRAY
47768: PUSH
47769: LD_INT 2
47771: ARRAY
47772: PPUSH
47773: CALL_OW 297
47777: ST_TO_ADDR
// end ; end ;
47778: GO 47667
47780: POP
47781: POP
// result := hex ;
47782: LD_ADDR_VAR 0 3
47786: PUSH
47787: LD_VAR 0 7
47791: ST_TO_ADDR
// end ;
47792: LD_VAR 0 3
47796: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47797: LD_INT 0
47799: PPUSH
47800: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47801: LD_VAR 0 1
47805: NOT
47806: PUSH
47807: LD_VAR 0 1
47811: PUSH
47812: LD_INT 21
47814: PUSH
47815: LD_INT 2
47817: PUSH
47818: EMPTY
47819: LIST
47820: LIST
47821: PUSH
47822: LD_INT 23
47824: PUSH
47825: LD_INT 2
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PPUSH
47836: CALL_OW 69
47840: IN
47841: NOT
47842: OR
47843: IFFALSE 47847
// exit ;
47845: GO 47894
// for i = 1 to 3 do
47847: LD_ADDR_VAR 0 3
47851: PUSH
47852: DOUBLE
47853: LD_INT 1
47855: DEC
47856: ST_TO_ADDR
47857: LD_INT 3
47859: PUSH
47860: FOR_TO
47861: IFFALSE 47892
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47863: LD_VAR 0 1
47867: PPUSH
47868: CALL_OW 250
47872: PPUSH
47873: LD_VAR 0 1
47877: PPUSH
47878: CALL_OW 251
47882: PPUSH
47883: LD_INT 1
47885: PPUSH
47886: CALL_OW 453
47890: GO 47860
47892: POP
47893: POP
// end ;
47894: LD_VAR 0 2
47898: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47899: LD_INT 0
47901: PPUSH
47902: PPUSH
47903: PPUSH
47904: PPUSH
47905: PPUSH
47906: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47907: LD_VAR 0 1
47911: NOT
47912: PUSH
47913: LD_VAR 0 2
47917: NOT
47918: OR
47919: PUSH
47920: LD_VAR 0 1
47924: PPUSH
47925: CALL_OW 314
47929: OR
47930: IFFALSE 47934
// exit ;
47932: GO 48375
// x := GetX ( enemy_unit ) ;
47934: LD_ADDR_VAR 0 7
47938: PUSH
47939: LD_VAR 0 2
47943: PPUSH
47944: CALL_OW 250
47948: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47949: LD_ADDR_VAR 0 8
47953: PUSH
47954: LD_VAR 0 2
47958: PPUSH
47959: CALL_OW 251
47963: ST_TO_ADDR
// if not x or not y then
47964: LD_VAR 0 7
47968: NOT
47969: PUSH
47970: LD_VAR 0 8
47974: NOT
47975: OR
47976: IFFALSE 47980
// exit ;
47978: GO 48375
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47980: LD_ADDR_VAR 0 6
47984: PUSH
47985: LD_VAR 0 7
47989: PPUSH
47990: LD_INT 0
47992: PPUSH
47993: LD_INT 4
47995: PPUSH
47996: CALL_OW 272
48000: PUSH
48001: LD_VAR 0 8
48005: PPUSH
48006: LD_INT 0
48008: PPUSH
48009: LD_INT 4
48011: PPUSH
48012: CALL_OW 273
48016: PUSH
48017: EMPTY
48018: LIST
48019: LIST
48020: PUSH
48021: LD_VAR 0 7
48025: PPUSH
48026: LD_INT 1
48028: PPUSH
48029: LD_INT 4
48031: PPUSH
48032: CALL_OW 272
48036: PUSH
48037: LD_VAR 0 8
48041: PPUSH
48042: LD_INT 1
48044: PPUSH
48045: LD_INT 4
48047: PPUSH
48048: CALL_OW 273
48052: PUSH
48053: EMPTY
48054: LIST
48055: LIST
48056: PUSH
48057: LD_VAR 0 7
48061: PPUSH
48062: LD_INT 2
48064: PPUSH
48065: LD_INT 4
48067: PPUSH
48068: CALL_OW 272
48072: PUSH
48073: LD_VAR 0 8
48077: PPUSH
48078: LD_INT 2
48080: PPUSH
48081: LD_INT 4
48083: PPUSH
48084: CALL_OW 273
48088: PUSH
48089: EMPTY
48090: LIST
48091: LIST
48092: PUSH
48093: LD_VAR 0 7
48097: PPUSH
48098: LD_INT 3
48100: PPUSH
48101: LD_INT 4
48103: PPUSH
48104: CALL_OW 272
48108: PUSH
48109: LD_VAR 0 8
48113: PPUSH
48114: LD_INT 3
48116: PPUSH
48117: LD_INT 4
48119: PPUSH
48120: CALL_OW 273
48124: PUSH
48125: EMPTY
48126: LIST
48127: LIST
48128: PUSH
48129: LD_VAR 0 7
48133: PPUSH
48134: LD_INT 4
48136: PPUSH
48137: LD_INT 4
48139: PPUSH
48140: CALL_OW 272
48144: PUSH
48145: LD_VAR 0 8
48149: PPUSH
48150: LD_INT 4
48152: PPUSH
48153: LD_INT 4
48155: PPUSH
48156: CALL_OW 273
48160: PUSH
48161: EMPTY
48162: LIST
48163: LIST
48164: PUSH
48165: LD_VAR 0 7
48169: PPUSH
48170: LD_INT 5
48172: PPUSH
48173: LD_INT 4
48175: PPUSH
48176: CALL_OW 272
48180: PUSH
48181: LD_VAR 0 8
48185: PPUSH
48186: LD_INT 5
48188: PPUSH
48189: LD_INT 4
48191: PPUSH
48192: CALL_OW 273
48196: PUSH
48197: EMPTY
48198: LIST
48199: LIST
48200: PUSH
48201: EMPTY
48202: LIST
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: LIST
48208: ST_TO_ADDR
// for i = tmp downto 1 do
48209: LD_ADDR_VAR 0 4
48213: PUSH
48214: DOUBLE
48215: LD_VAR 0 6
48219: INC
48220: ST_TO_ADDR
48221: LD_INT 1
48223: PUSH
48224: FOR_DOWNTO
48225: IFFALSE 48326
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48227: LD_VAR 0 6
48231: PUSH
48232: LD_VAR 0 4
48236: ARRAY
48237: PUSH
48238: LD_INT 1
48240: ARRAY
48241: PPUSH
48242: LD_VAR 0 6
48246: PUSH
48247: LD_VAR 0 4
48251: ARRAY
48252: PUSH
48253: LD_INT 2
48255: ARRAY
48256: PPUSH
48257: CALL_OW 488
48261: NOT
48262: PUSH
48263: LD_VAR 0 6
48267: PUSH
48268: LD_VAR 0 4
48272: ARRAY
48273: PUSH
48274: LD_INT 1
48276: ARRAY
48277: PPUSH
48278: LD_VAR 0 6
48282: PUSH
48283: LD_VAR 0 4
48287: ARRAY
48288: PUSH
48289: LD_INT 2
48291: ARRAY
48292: PPUSH
48293: CALL_OW 428
48297: PUSH
48298: LD_INT 0
48300: NONEQUAL
48301: OR
48302: IFFALSE 48324
// tmp := Delete ( tmp , i ) ;
48304: LD_ADDR_VAR 0 6
48308: PUSH
48309: LD_VAR 0 6
48313: PPUSH
48314: LD_VAR 0 4
48318: PPUSH
48319: CALL_OW 3
48323: ST_TO_ADDR
48324: GO 48224
48326: POP
48327: POP
// j := GetClosestHex ( unit , tmp ) ;
48328: LD_ADDR_VAR 0 5
48332: PUSH
48333: LD_VAR 0 1
48337: PPUSH
48338: LD_VAR 0 6
48342: PPUSH
48343: CALL 47628 0 2
48347: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48348: LD_VAR 0 1
48352: PPUSH
48353: LD_VAR 0 5
48357: PUSH
48358: LD_INT 1
48360: ARRAY
48361: PPUSH
48362: LD_VAR 0 5
48366: PUSH
48367: LD_INT 2
48369: ARRAY
48370: PPUSH
48371: CALL_OW 111
// end ;
48375: LD_VAR 0 3
48379: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48380: LD_INT 0
48382: PPUSH
48383: PPUSH
48384: PPUSH
// uc_side = 0 ;
48385: LD_ADDR_OWVAR 20
48389: PUSH
48390: LD_INT 0
48392: ST_TO_ADDR
// uc_nation = 0 ;
48393: LD_ADDR_OWVAR 21
48397: PUSH
48398: LD_INT 0
48400: ST_TO_ADDR
// InitHc_All ( ) ;
48401: CALL_OW 584
// InitVc ;
48405: CALL_OW 20
// if mastodonts then
48409: LD_VAR 0 6
48413: IFFALSE 48480
// for i = 1 to mastodonts do
48415: LD_ADDR_VAR 0 11
48419: PUSH
48420: DOUBLE
48421: LD_INT 1
48423: DEC
48424: ST_TO_ADDR
48425: LD_VAR 0 6
48429: PUSH
48430: FOR_TO
48431: IFFALSE 48478
// begin vc_chassis := 31 ;
48433: LD_ADDR_OWVAR 37
48437: PUSH
48438: LD_INT 31
48440: ST_TO_ADDR
// vc_control := control_rider ;
48441: LD_ADDR_OWVAR 38
48445: PUSH
48446: LD_INT 4
48448: ST_TO_ADDR
// animal := CreateVehicle ;
48449: LD_ADDR_VAR 0 12
48453: PUSH
48454: CALL_OW 45
48458: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48459: LD_VAR 0 12
48463: PPUSH
48464: LD_VAR 0 8
48468: PPUSH
48469: LD_INT 0
48471: PPUSH
48472: CALL 50615 0 3
// end ;
48476: GO 48430
48478: POP
48479: POP
// if horses then
48480: LD_VAR 0 5
48484: IFFALSE 48551
// for i = 1 to horses do
48486: LD_ADDR_VAR 0 11
48490: PUSH
48491: DOUBLE
48492: LD_INT 1
48494: DEC
48495: ST_TO_ADDR
48496: LD_VAR 0 5
48500: PUSH
48501: FOR_TO
48502: IFFALSE 48549
// begin hc_class := 21 ;
48504: LD_ADDR_OWVAR 28
48508: PUSH
48509: LD_INT 21
48511: ST_TO_ADDR
// hc_gallery :=  ;
48512: LD_ADDR_OWVAR 33
48516: PUSH
48517: LD_STRING 
48519: ST_TO_ADDR
// animal := CreateHuman ;
48520: LD_ADDR_VAR 0 12
48524: PUSH
48525: CALL_OW 44
48529: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48530: LD_VAR 0 12
48534: PPUSH
48535: LD_VAR 0 8
48539: PPUSH
48540: LD_INT 0
48542: PPUSH
48543: CALL 50615 0 3
// end ;
48547: GO 48501
48549: POP
48550: POP
// if birds then
48551: LD_VAR 0 1
48555: IFFALSE 48622
// for i = 1 to birds do
48557: LD_ADDR_VAR 0 11
48561: PUSH
48562: DOUBLE
48563: LD_INT 1
48565: DEC
48566: ST_TO_ADDR
48567: LD_VAR 0 1
48571: PUSH
48572: FOR_TO
48573: IFFALSE 48620
// begin hc_class = 18 ;
48575: LD_ADDR_OWVAR 28
48579: PUSH
48580: LD_INT 18
48582: ST_TO_ADDR
// hc_gallery =  ;
48583: LD_ADDR_OWVAR 33
48587: PUSH
48588: LD_STRING 
48590: ST_TO_ADDR
// animal := CreateHuman ;
48591: LD_ADDR_VAR 0 12
48595: PUSH
48596: CALL_OW 44
48600: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48601: LD_VAR 0 12
48605: PPUSH
48606: LD_VAR 0 8
48610: PPUSH
48611: LD_INT 0
48613: PPUSH
48614: CALL 50615 0 3
// end ;
48618: GO 48572
48620: POP
48621: POP
// if tigers then
48622: LD_VAR 0 2
48626: IFFALSE 48710
// for i = 1 to tigers do
48628: LD_ADDR_VAR 0 11
48632: PUSH
48633: DOUBLE
48634: LD_INT 1
48636: DEC
48637: ST_TO_ADDR
48638: LD_VAR 0 2
48642: PUSH
48643: FOR_TO
48644: IFFALSE 48708
// begin hc_class = class_tiger ;
48646: LD_ADDR_OWVAR 28
48650: PUSH
48651: LD_INT 14
48653: ST_TO_ADDR
// hc_gallery =  ;
48654: LD_ADDR_OWVAR 33
48658: PUSH
48659: LD_STRING 
48661: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48662: LD_ADDR_OWVAR 35
48666: PUSH
48667: LD_INT 7
48669: NEG
48670: PPUSH
48671: LD_INT 7
48673: PPUSH
48674: CALL_OW 12
48678: ST_TO_ADDR
// animal := CreateHuman ;
48679: LD_ADDR_VAR 0 12
48683: PUSH
48684: CALL_OW 44
48688: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48689: LD_VAR 0 12
48693: PPUSH
48694: LD_VAR 0 8
48698: PPUSH
48699: LD_INT 0
48701: PPUSH
48702: CALL 50615 0 3
// end ;
48706: GO 48643
48708: POP
48709: POP
// if apemans then
48710: LD_VAR 0 3
48714: IFFALSE 48837
// for i = 1 to apemans do
48716: LD_ADDR_VAR 0 11
48720: PUSH
48721: DOUBLE
48722: LD_INT 1
48724: DEC
48725: ST_TO_ADDR
48726: LD_VAR 0 3
48730: PUSH
48731: FOR_TO
48732: IFFALSE 48835
// begin hc_class = class_apeman ;
48734: LD_ADDR_OWVAR 28
48738: PUSH
48739: LD_INT 12
48741: ST_TO_ADDR
// hc_gallery =  ;
48742: LD_ADDR_OWVAR 33
48746: PUSH
48747: LD_STRING 
48749: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
48750: LD_ADDR_OWVAR 35
48754: PUSH
48755: LD_INT 2
48757: NEG
48758: PPUSH
48759: LD_INT 2
48761: PPUSH
48762: CALL_OW 12
48766: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48767: LD_ADDR_OWVAR 31
48771: PUSH
48772: LD_INT 1
48774: PPUSH
48775: LD_INT 3
48777: PPUSH
48778: CALL_OW 12
48782: PUSH
48783: LD_INT 1
48785: PPUSH
48786: LD_INT 3
48788: PPUSH
48789: CALL_OW 12
48793: PUSH
48794: LD_INT 0
48796: PUSH
48797: LD_INT 0
48799: PUSH
48800: EMPTY
48801: LIST
48802: LIST
48803: LIST
48804: LIST
48805: ST_TO_ADDR
// animal := CreateHuman ;
48806: LD_ADDR_VAR 0 12
48810: PUSH
48811: CALL_OW 44
48815: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48816: LD_VAR 0 12
48820: PPUSH
48821: LD_VAR 0 8
48825: PPUSH
48826: LD_INT 0
48828: PPUSH
48829: CALL 50615 0 3
// end ;
48833: GO 48731
48835: POP
48836: POP
// if enchidnas then
48837: LD_VAR 0 4
48841: IFFALSE 48908
// for i = 1 to enchidnas do
48843: LD_ADDR_VAR 0 11
48847: PUSH
48848: DOUBLE
48849: LD_INT 1
48851: DEC
48852: ST_TO_ADDR
48853: LD_VAR 0 4
48857: PUSH
48858: FOR_TO
48859: IFFALSE 48906
// begin hc_class = 13 ;
48861: LD_ADDR_OWVAR 28
48865: PUSH
48866: LD_INT 13
48868: ST_TO_ADDR
// hc_gallery =  ;
48869: LD_ADDR_OWVAR 33
48873: PUSH
48874: LD_STRING 
48876: ST_TO_ADDR
// animal := CreateHuman ;
48877: LD_ADDR_VAR 0 12
48881: PUSH
48882: CALL_OW 44
48886: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48887: LD_VAR 0 12
48891: PPUSH
48892: LD_VAR 0 8
48896: PPUSH
48897: LD_INT 0
48899: PPUSH
48900: CALL 50615 0 3
// end ;
48904: GO 48858
48906: POP
48907: POP
// if fishes then
48908: LD_VAR 0 7
48912: IFFALSE 48979
// for i = 1 to fishes do
48914: LD_ADDR_VAR 0 11
48918: PUSH
48919: DOUBLE
48920: LD_INT 1
48922: DEC
48923: ST_TO_ADDR
48924: LD_VAR 0 7
48928: PUSH
48929: FOR_TO
48930: IFFALSE 48977
// begin hc_class = 20 ;
48932: LD_ADDR_OWVAR 28
48936: PUSH
48937: LD_INT 20
48939: ST_TO_ADDR
// hc_gallery =  ;
48940: LD_ADDR_OWVAR 33
48944: PUSH
48945: LD_STRING 
48947: ST_TO_ADDR
// animal := CreateHuman ;
48948: LD_ADDR_VAR 0 12
48952: PUSH
48953: CALL_OW 44
48957: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48958: LD_VAR 0 12
48962: PPUSH
48963: LD_VAR 0 9
48967: PPUSH
48968: LD_INT 0
48970: PPUSH
48971: CALL 50615 0 3
// end ;
48975: GO 48929
48977: POP
48978: POP
// end ;
48979: LD_VAR 0 10
48983: RET
// export function WantHeal ( sci , unit ) ; begin
48984: LD_INT 0
48986: PPUSH
// if GetTaskList ( sci ) > 0 then
48987: LD_VAR 0 1
48991: PPUSH
48992: CALL_OW 437
48996: PUSH
48997: LD_INT 0
48999: GREATER
49000: IFFALSE 49070
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49002: LD_VAR 0 1
49006: PPUSH
49007: CALL_OW 437
49011: PUSH
49012: LD_INT 1
49014: ARRAY
49015: PUSH
49016: LD_INT 1
49018: ARRAY
49019: PUSH
49020: LD_STRING l
49022: EQUAL
49023: PUSH
49024: LD_VAR 0 1
49028: PPUSH
49029: CALL_OW 437
49033: PUSH
49034: LD_INT 1
49036: ARRAY
49037: PUSH
49038: LD_INT 4
49040: ARRAY
49041: PUSH
49042: LD_VAR 0 2
49046: EQUAL
49047: AND
49048: IFFALSE 49060
// result := true else
49050: LD_ADDR_VAR 0 3
49054: PUSH
49055: LD_INT 1
49057: ST_TO_ADDR
49058: GO 49068
// result := false ;
49060: LD_ADDR_VAR 0 3
49064: PUSH
49065: LD_INT 0
49067: ST_TO_ADDR
// end else
49068: GO 49078
// result := false ;
49070: LD_ADDR_VAR 0 3
49074: PUSH
49075: LD_INT 0
49077: ST_TO_ADDR
// end ;
49078: LD_VAR 0 3
49082: RET
// export function HealTarget ( sci ) ; begin
49083: LD_INT 0
49085: PPUSH
// if not sci then
49086: LD_VAR 0 1
49090: NOT
49091: IFFALSE 49095
// exit ;
49093: GO 49160
// result := 0 ;
49095: LD_ADDR_VAR 0 2
49099: PUSH
49100: LD_INT 0
49102: ST_TO_ADDR
// if GetTaskList ( sci ) then
49103: LD_VAR 0 1
49107: PPUSH
49108: CALL_OW 437
49112: IFFALSE 49160
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49114: LD_VAR 0 1
49118: PPUSH
49119: CALL_OW 437
49123: PUSH
49124: LD_INT 1
49126: ARRAY
49127: PUSH
49128: LD_INT 1
49130: ARRAY
49131: PUSH
49132: LD_STRING l
49134: EQUAL
49135: IFFALSE 49160
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49137: LD_ADDR_VAR 0 2
49141: PUSH
49142: LD_VAR 0 1
49146: PPUSH
49147: CALL_OW 437
49151: PUSH
49152: LD_INT 1
49154: ARRAY
49155: PUSH
49156: LD_INT 4
49158: ARRAY
49159: ST_TO_ADDR
// end ;
49160: LD_VAR 0 2
49164: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
49165: LD_INT 0
49167: PPUSH
49168: PPUSH
49169: PPUSH
49170: PPUSH
// if not base_units then
49171: LD_VAR 0 1
49175: NOT
49176: IFFALSE 49180
// exit ;
49178: GO 49267
// result := false ;
49180: LD_ADDR_VAR 0 2
49184: PUSH
49185: LD_INT 0
49187: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
49188: LD_ADDR_VAR 0 5
49192: PUSH
49193: LD_VAR 0 1
49197: PPUSH
49198: LD_INT 21
49200: PUSH
49201: LD_INT 3
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: PPUSH
49208: CALL_OW 72
49212: ST_TO_ADDR
// if not tmp then
49213: LD_VAR 0 5
49217: NOT
49218: IFFALSE 49222
// exit ;
49220: GO 49267
// for i in tmp do
49222: LD_ADDR_VAR 0 3
49226: PUSH
49227: LD_VAR 0 5
49231: PUSH
49232: FOR_IN
49233: IFFALSE 49265
// begin result := EnemyInRange ( i , 22 ) ;
49235: LD_ADDR_VAR 0 2
49239: PUSH
49240: LD_VAR 0 3
49244: PPUSH
49245: LD_INT 22
49247: PPUSH
49248: CALL 47503 0 2
49252: ST_TO_ADDR
// if result then
49253: LD_VAR 0 2
49257: IFFALSE 49263
// exit ;
49259: POP
49260: POP
49261: GO 49267
// end ;
49263: GO 49232
49265: POP
49266: POP
// end ;
49267: LD_VAR 0 2
49271: RET
// export function FilterByTag ( units , tag ) ; begin
49272: LD_INT 0
49274: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
49275: LD_ADDR_VAR 0 3
49279: PUSH
49280: LD_VAR 0 1
49284: PPUSH
49285: LD_INT 120
49287: PUSH
49288: LD_VAR 0 2
49292: PUSH
49293: EMPTY
49294: LIST
49295: LIST
49296: PPUSH
49297: CALL_OW 72
49301: ST_TO_ADDR
// end ;
49302: LD_VAR 0 3
49306: RET
// export function IsDriver ( un ) ; begin
49307: LD_INT 0
49309: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
49310: LD_ADDR_VAR 0 2
49314: PUSH
49315: LD_VAR 0 1
49319: PUSH
49320: LD_INT 55
49322: PUSH
49323: EMPTY
49324: LIST
49325: PPUSH
49326: CALL_OW 69
49330: IN
49331: ST_TO_ADDR
// end ;
49332: LD_VAR 0 2
49336: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
49337: LD_INT 0
49339: PPUSH
49340: PPUSH
// list := [ ] ;
49341: LD_ADDR_VAR 0 5
49345: PUSH
49346: EMPTY
49347: ST_TO_ADDR
// case d of 0 :
49348: LD_VAR 0 3
49352: PUSH
49353: LD_INT 0
49355: DOUBLE
49356: EQUAL
49357: IFTRUE 49361
49359: GO 49494
49361: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
49362: LD_ADDR_VAR 0 5
49366: PUSH
49367: LD_VAR 0 1
49371: PUSH
49372: LD_INT 4
49374: MINUS
49375: PUSH
49376: LD_VAR 0 2
49380: PUSH
49381: LD_INT 4
49383: MINUS
49384: PUSH
49385: LD_INT 2
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: LIST
49392: PUSH
49393: LD_VAR 0 1
49397: PUSH
49398: LD_INT 3
49400: MINUS
49401: PUSH
49402: LD_VAR 0 2
49406: PUSH
49407: LD_INT 1
49409: PUSH
49410: EMPTY
49411: LIST
49412: LIST
49413: LIST
49414: PUSH
49415: LD_VAR 0 1
49419: PUSH
49420: LD_INT 4
49422: PLUS
49423: PUSH
49424: LD_VAR 0 2
49428: PUSH
49429: LD_INT 4
49431: PUSH
49432: EMPTY
49433: LIST
49434: LIST
49435: LIST
49436: PUSH
49437: LD_VAR 0 1
49441: PUSH
49442: LD_INT 3
49444: PLUS
49445: PUSH
49446: LD_VAR 0 2
49450: PUSH
49451: LD_INT 3
49453: PLUS
49454: PUSH
49455: LD_INT 5
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: LIST
49462: PUSH
49463: LD_VAR 0 1
49467: PUSH
49468: LD_VAR 0 2
49472: PUSH
49473: LD_INT 4
49475: PLUS
49476: PUSH
49477: LD_INT 0
49479: PUSH
49480: EMPTY
49481: LIST
49482: LIST
49483: LIST
49484: PUSH
49485: EMPTY
49486: LIST
49487: LIST
49488: LIST
49489: LIST
49490: LIST
49491: ST_TO_ADDR
// end ; 1 :
49492: GO 50192
49494: LD_INT 1
49496: DOUBLE
49497: EQUAL
49498: IFTRUE 49502
49500: GO 49635
49502: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
49503: LD_ADDR_VAR 0 5
49507: PUSH
49508: LD_VAR 0 1
49512: PUSH
49513: LD_VAR 0 2
49517: PUSH
49518: LD_INT 4
49520: MINUS
49521: PUSH
49522: LD_INT 3
49524: PUSH
49525: EMPTY
49526: LIST
49527: LIST
49528: LIST
49529: PUSH
49530: LD_VAR 0 1
49534: PUSH
49535: LD_INT 3
49537: MINUS
49538: PUSH
49539: LD_VAR 0 2
49543: PUSH
49544: LD_INT 3
49546: MINUS
49547: PUSH
49548: LD_INT 2
49550: PUSH
49551: EMPTY
49552: LIST
49553: LIST
49554: LIST
49555: PUSH
49556: LD_VAR 0 1
49560: PUSH
49561: LD_INT 4
49563: MINUS
49564: PUSH
49565: LD_VAR 0 2
49569: PUSH
49570: LD_INT 1
49572: PUSH
49573: EMPTY
49574: LIST
49575: LIST
49576: LIST
49577: PUSH
49578: LD_VAR 0 1
49582: PUSH
49583: LD_VAR 0 2
49587: PUSH
49588: LD_INT 3
49590: PLUS
49591: PUSH
49592: LD_INT 0
49594: PUSH
49595: EMPTY
49596: LIST
49597: LIST
49598: LIST
49599: PUSH
49600: LD_VAR 0 1
49604: PUSH
49605: LD_INT 4
49607: PLUS
49608: PUSH
49609: LD_VAR 0 2
49613: PUSH
49614: LD_INT 4
49616: PLUS
49617: PUSH
49618: LD_INT 5
49620: PUSH
49621: EMPTY
49622: LIST
49623: LIST
49624: LIST
49625: PUSH
49626: EMPTY
49627: LIST
49628: LIST
49629: LIST
49630: LIST
49631: LIST
49632: ST_TO_ADDR
// end ; 2 :
49633: GO 50192
49635: LD_INT 2
49637: DOUBLE
49638: EQUAL
49639: IFTRUE 49643
49641: GO 49772
49643: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
49644: LD_ADDR_VAR 0 5
49648: PUSH
49649: LD_VAR 0 1
49653: PUSH
49654: LD_VAR 0 2
49658: PUSH
49659: LD_INT 3
49661: MINUS
49662: PUSH
49663: LD_INT 3
49665: PUSH
49666: EMPTY
49667: LIST
49668: LIST
49669: LIST
49670: PUSH
49671: LD_VAR 0 1
49675: PUSH
49676: LD_INT 4
49678: PLUS
49679: PUSH
49680: LD_VAR 0 2
49684: PUSH
49685: LD_INT 4
49687: PUSH
49688: EMPTY
49689: LIST
49690: LIST
49691: LIST
49692: PUSH
49693: LD_VAR 0 1
49697: PUSH
49698: LD_VAR 0 2
49702: PUSH
49703: LD_INT 4
49705: PLUS
49706: PUSH
49707: LD_INT 0
49709: PUSH
49710: EMPTY
49711: LIST
49712: LIST
49713: LIST
49714: PUSH
49715: LD_VAR 0 1
49719: PUSH
49720: LD_INT 3
49722: MINUS
49723: PUSH
49724: LD_VAR 0 2
49728: PUSH
49729: LD_INT 1
49731: PUSH
49732: EMPTY
49733: LIST
49734: LIST
49735: LIST
49736: PUSH
49737: LD_VAR 0 1
49741: PUSH
49742: LD_INT 4
49744: MINUS
49745: PUSH
49746: LD_VAR 0 2
49750: PUSH
49751: LD_INT 4
49753: MINUS
49754: PUSH
49755: LD_INT 2
49757: PUSH
49758: EMPTY
49759: LIST
49760: LIST
49761: LIST
49762: PUSH
49763: EMPTY
49764: LIST
49765: LIST
49766: LIST
49767: LIST
49768: LIST
49769: ST_TO_ADDR
// end ; 3 :
49770: GO 50192
49772: LD_INT 3
49774: DOUBLE
49775: EQUAL
49776: IFTRUE 49780
49778: GO 49913
49780: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49781: LD_ADDR_VAR 0 5
49785: PUSH
49786: LD_VAR 0 1
49790: PUSH
49791: LD_INT 3
49793: PLUS
49794: PUSH
49795: LD_VAR 0 2
49799: PUSH
49800: LD_INT 4
49802: PUSH
49803: EMPTY
49804: LIST
49805: LIST
49806: LIST
49807: PUSH
49808: LD_VAR 0 1
49812: PUSH
49813: LD_INT 4
49815: PLUS
49816: PUSH
49817: LD_VAR 0 2
49821: PUSH
49822: LD_INT 4
49824: PLUS
49825: PUSH
49826: LD_INT 5
49828: PUSH
49829: EMPTY
49830: LIST
49831: LIST
49832: LIST
49833: PUSH
49834: LD_VAR 0 1
49838: PUSH
49839: LD_INT 4
49841: MINUS
49842: PUSH
49843: LD_VAR 0 2
49847: PUSH
49848: LD_INT 1
49850: PUSH
49851: EMPTY
49852: LIST
49853: LIST
49854: LIST
49855: PUSH
49856: LD_VAR 0 1
49860: PUSH
49861: LD_VAR 0 2
49865: PUSH
49866: LD_INT 4
49868: MINUS
49869: PUSH
49870: LD_INT 3
49872: PUSH
49873: EMPTY
49874: LIST
49875: LIST
49876: LIST
49877: PUSH
49878: LD_VAR 0 1
49882: PUSH
49883: LD_INT 3
49885: MINUS
49886: PUSH
49887: LD_VAR 0 2
49891: PUSH
49892: LD_INT 3
49894: MINUS
49895: PUSH
49896: LD_INT 2
49898: PUSH
49899: EMPTY
49900: LIST
49901: LIST
49902: LIST
49903: PUSH
49904: EMPTY
49905: LIST
49906: LIST
49907: LIST
49908: LIST
49909: LIST
49910: ST_TO_ADDR
// end ; 4 :
49911: GO 50192
49913: LD_INT 4
49915: DOUBLE
49916: EQUAL
49917: IFTRUE 49921
49919: GO 50054
49921: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49922: LD_ADDR_VAR 0 5
49926: PUSH
49927: LD_VAR 0 1
49931: PUSH
49932: LD_VAR 0 2
49936: PUSH
49937: LD_INT 4
49939: PLUS
49940: PUSH
49941: LD_INT 0
49943: PUSH
49944: EMPTY
49945: LIST
49946: LIST
49947: LIST
49948: PUSH
49949: LD_VAR 0 1
49953: PUSH
49954: LD_INT 3
49956: PLUS
49957: PUSH
49958: LD_VAR 0 2
49962: PUSH
49963: LD_INT 3
49965: PLUS
49966: PUSH
49967: LD_INT 5
49969: PUSH
49970: EMPTY
49971: LIST
49972: LIST
49973: LIST
49974: PUSH
49975: LD_VAR 0 1
49979: PUSH
49980: LD_INT 4
49982: PLUS
49983: PUSH
49984: LD_VAR 0 2
49988: PUSH
49989: LD_INT 4
49991: PUSH
49992: EMPTY
49993: LIST
49994: LIST
49995: LIST
49996: PUSH
49997: LD_VAR 0 1
50001: PUSH
50002: LD_VAR 0 2
50006: PUSH
50007: LD_INT 3
50009: MINUS
50010: PUSH
50011: LD_INT 3
50013: PUSH
50014: EMPTY
50015: LIST
50016: LIST
50017: LIST
50018: PUSH
50019: LD_VAR 0 1
50023: PUSH
50024: LD_INT 4
50026: MINUS
50027: PUSH
50028: LD_VAR 0 2
50032: PUSH
50033: LD_INT 4
50035: MINUS
50036: PUSH
50037: LD_INT 2
50039: PUSH
50040: EMPTY
50041: LIST
50042: LIST
50043: LIST
50044: PUSH
50045: EMPTY
50046: LIST
50047: LIST
50048: LIST
50049: LIST
50050: LIST
50051: ST_TO_ADDR
// end ; 5 :
50052: GO 50192
50054: LD_INT 5
50056: DOUBLE
50057: EQUAL
50058: IFTRUE 50062
50060: GO 50191
50062: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
50063: LD_ADDR_VAR 0 5
50067: PUSH
50068: LD_VAR 0 1
50072: PUSH
50073: LD_INT 4
50075: MINUS
50076: PUSH
50077: LD_VAR 0 2
50081: PUSH
50082: LD_INT 1
50084: PUSH
50085: EMPTY
50086: LIST
50087: LIST
50088: LIST
50089: PUSH
50090: LD_VAR 0 1
50094: PUSH
50095: LD_VAR 0 2
50099: PUSH
50100: LD_INT 4
50102: MINUS
50103: PUSH
50104: LD_INT 3
50106: PUSH
50107: EMPTY
50108: LIST
50109: LIST
50110: LIST
50111: PUSH
50112: LD_VAR 0 1
50116: PUSH
50117: LD_INT 4
50119: PLUS
50120: PUSH
50121: LD_VAR 0 2
50125: PUSH
50126: LD_INT 4
50128: PLUS
50129: PUSH
50130: LD_INT 5
50132: PUSH
50133: EMPTY
50134: LIST
50135: LIST
50136: LIST
50137: PUSH
50138: LD_VAR 0 1
50142: PUSH
50143: LD_INT 3
50145: PLUS
50146: PUSH
50147: LD_VAR 0 2
50151: PUSH
50152: LD_INT 4
50154: PUSH
50155: EMPTY
50156: LIST
50157: LIST
50158: LIST
50159: PUSH
50160: LD_VAR 0 1
50164: PUSH
50165: LD_VAR 0 2
50169: PUSH
50170: LD_INT 3
50172: PLUS
50173: PUSH
50174: LD_INT 0
50176: PUSH
50177: EMPTY
50178: LIST
50179: LIST
50180: LIST
50181: PUSH
50182: EMPTY
50183: LIST
50184: LIST
50185: LIST
50186: LIST
50187: LIST
50188: ST_TO_ADDR
// end ; end ;
50189: GO 50192
50191: POP
// result := list ;
50192: LD_ADDR_VAR 0 4
50196: PUSH
50197: LD_VAR 0 5
50201: ST_TO_ADDR
// end ;
50202: LD_VAR 0 4
50206: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
50207: LD_INT 0
50209: PPUSH
50210: PPUSH
50211: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
50212: LD_VAR 0 1
50216: NOT
50217: PUSH
50218: LD_VAR 0 2
50222: PUSH
50223: LD_INT 1
50225: PUSH
50226: LD_INT 2
50228: PUSH
50229: LD_INT 3
50231: PUSH
50232: LD_INT 4
50234: PUSH
50235: EMPTY
50236: LIST
50237: LIST
50238: LIST
50239: LIST
50240: IN
50241: NOT
50242: OR
50243: IFFALSE 50247
// exit ;
50245: GO 50339
// tmp := [ ] ;
50247: LD_ADDR_VAR 0 5
50251: PUSH
50252: EMPTY
50253: ST_TO_ADDR
// for i in units do
50254: LD_ADDR_VAR 0 4
50258: PUSH
50259: LD_VAR 0 1
50263: PUSH
50264: FOR_IN
50265: IFFALSE 50308
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
50267: LD_ADDR_VAR 0 5
50271: PUSH
50272: LD_VAR 0 5
50276: PPUSH
50277: LD_VAR 0 5
50281: PUSH
50282: LD_INT 1
50284: PLUS
50285: PPUSH
50286: LD_VAR 0 4
50290: PPUSH
50291: LD_VAR 0 2
50295: PPUSH
50296: CALL_OW 259
50300: PPUSH
50301: CALL_OW 2
50305: ST_TO_ADDR
50306: GO 50264
50308: POP
50309: POP
// if not tmp then
50310: LD_VAR 0 5
50314: NOT
50315: IFFALSE 50319
// exit ;
50317: GO 50339
// result := SortListByListDesc ( units , tmp ) ;
50319: LD_ADDR_VAR 0 3
50323: PUSH
50324: LD_VAR 0 1
50328: PPUSH
50329: LD_VAR 0 5
50333: PPUSH
50334: CALL_OW 77
50338: ST_TO_ADDR
// end ;
50339: LD_VAR 0 3
50343: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
50344: LD_INT 0
50346: PPUSH
50347: PPUSH
50348: PPUSH
// result := false ;
50349: LD_ADDR_VAR 0 3
50353: PUSH
50354: LD_INT 0
50356: ST_TO_ADDR
// x := GetX ( building ) ;
50357: LD_ADDR_VAR 0 4
50361: PUSH
50362: LD_VAR 0 2
50366: PPUSH
50367: CALL_OW 250
50371: ST_TO_ADDR
// y := GetY ( building ) ;
50372: LD_ADDR_VAR 0 5
50376: PUSH
50377: LD_VAR 0 2
50381: PPUSH
50382: CALL_OW 251
50386: ST_TO_ADDR
// if not building or not x or not y then
50387: LD_VAR 0 2
50391: NOT
50392: PUSH
50393: LD_VAR 0 4
50397: NOT
50398: OR
50399: PUSH
50400: LD_VAR 0 5
50404: NOT
50405: OR
50406: IFFALSE 50410
// exit ;
50408: GO 50502
// if GetTaskList ( unit ) then
50410: LD_VAR 0 1
50414: PPUSH
50415: CALL_OW 437
50419: IFFALSE 50502
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50421: LD_STRING e
50423: PUSH
50424: LD_VAR 0 1
50428: PPUSH
50429: CALL_OW 437
50433: PUSH
50434: LD_INT 1
50436: ARRAY
50437: PUSH
50438: LD_INT 1
50440: ARRAY
50441: EQUAL
50442: PUSH
50443: LD_VAR 0 4
50447: PUSH
50448: LD_VAR 0 1
50452: PPUSH
50453: CALL_OW 437
50457: PUSH
50458: LD_INT 1
50460: ARRAY
50461: PUSH
50462: LD_INT 2
50464: ARRAY
50465: EQUAL
50466: AND
50467: PUSH
50468: LD_VAR 0 5
50472: PUSH
50473: LD_VAR 0 1
50477: PPUSH
50478: CALL_OW 437
50482: PUSH
50483: LD_INT 1
50485: ARRAY
50486: PUSH
50487: LD_INT 3
50489: ARRAY
50490: EQUAL
50491: AND
50492: IFFALSE 50502
// result := true end ;
50494: LD_ADDR_VAR 0 3
50498: PUSH
50499: LD_INT 1
50501: ST_TO_ADDR
// end ;
50502: LD_VAR 0 3
50506: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
50507: LD_INT 0
50509: PPUSH
// result := false ;
50510: LD_ADDR_VAR 0 4
50514: PUSH
50515: LD_INT 0
50517: ST_TO_ADDR
// if GetTaskList ( unit ) then
50518: LD_VAR 0 1
50522: PPUSH
50523: CALL_OW 437
50527: IFFALSE 50610
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50529: LD_STRING M
50531: PUSH
50532: LD_VAR 0 1
50536: PPUSH
50537: CALL_OW 437
50541: PUSH
50542: LD_INT 1
50544: ARRAY
50545: PUSH
50546: LD_INT 1
50548: ARRAY
50549: EQUAL
50550: PUSH
50551: LD_VAR 0 2
50555: PUSH
50556: LD_VAR 0 1
50560: PPUSH
50561: CALL_OW 437
50565: PUSH
50566: LD_INT 1
50568: ARRAY
50569: PUSH
50570: LD_INT 2
50572: ARRAY
50573: EQUAL
50574: AND
50575: PUSH
50576: LD_VAR 0 3
50580: PUSH
50581: LD_VAR 0 1
50585: PPUSH
50586: CALL_OW 437
50590: PUSH
50591: LD_INT 1
50593: ARRAY
50594: PUSH
50595: LD_INT 3
50597: ARRAY
50598: EQUAL
50599: AND
50600: IFFALSE 50610
// result := true ;
50602: LD_ADDR_VAR 0 4
50606: PUSH
50607: LD_INT 1
50609: ST_TO_ADDR
// end ; end ;
50610: LD_VAR 0 4
50614: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
50615: LD_INT 0
50617: PPUSH
50618: PPUSH
50619: PPUSH
50620: PPUSH
// if not unit or not area then
50621: LD_VAR 0 1
50625: NOT
50626: PUSH
50627: LD_VAR 0 2
50631: NOT
50632: OR
50633: IFFALSE 50637
// exit ;
50635: GO 50801
// tmp := AreaToList ( area , i ) ;
50637: LD_ADDR_VAR 0 6
50641: PUSH
50642: LD_VAR 0 2
50646: PPUSH
50647: LD_VAR 0 5
50651: PPUSH
50652: CALL_OW 517
50656: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
50657: LD_ADDR_VAR 0 5
50661: PUSH
50662: DOUBLE
50663: LD_INT 1
50665: DEC
50666: ST_TO_ADDR
50667: LD_VAR 0 6
50671: PUSH
50672: LD_INT 1
50674: ARRAY
50675: PUSH
50676: FOR_TO
50677: IFFALSE 50799
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
50679: LD_ADDR_VAR 0 7
50683: PUSH
50684: LD_VAR 0 6
50688: PUSH
50689: LD_INT 1
50691: ARRAY
50692: PUSH
50693: LD_VAR 0 5
50697: ARRAY
50698: PUSH
50699: LD_VAR 0 6
50703: PUSH
50704: LD_INT 2
50706: ARRAY
50707: PUSH
50708: LD_VAR 0 5
50712: ARRAY
50713: PUSH
50714: EMPTY
50715: LIST
50716: LIST
50717: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
50718: LD_VAR 0 7
50722: PUSH
50723: LD_INT 1
50725: ARRAY
50726: PPUSH
50727: LD_VAR 0 7
50731: PUSH
50732: LD_INT 2
50734: ARRAY
50735: PPUSH
50736: CALL_OW 428
50740: PUSH
50741: LD_INT 0
50743: EQUAL
50744: IFFALSE 50797
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
50746: LD_VAR 0 1
50750: PPUSH
50751: LD_VAR 0 7
50755: PUSH
50756: LD_INT 1
50758: ARRAY
50759: PPUSH
50760: LD_VAR 0 7
50764: PUSH
50765: LD_INT 2
50767: ARRAY
50768: PPUSH
50769: LD_VAR 0 3
50773: PPUSH
50774: CALL_OW 48
// result := IsPlaced ( unit ) ;
50778: LD_ADDR_VAR 0 4
50782: PUSH
50783: LD_VAR 0 1
50787: PPUSH
50788: CALL_OW 305
50792: ST_TO_ADDR
// exit ;
50793: POP
50794: POP
50795: GO 50801
// end ; end ;
50797: GO 50676
50799: POP
50800: POP
// end ;
50801: LD_VAR 0 4
50805: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50806: LD_INT 0
50808: PPUSH
50809: PPUSH
50810: PPUSH
// if not side or side > 8 then
50811: LD_VAR 0 1
50815: NOT
50816: PUSH
50817: LD_VAR 0 1
50821: PUSH
50822: LD_INT 8
50824: GREATER
50825: OR
50826: IFFALSE 50830
// exit ;
50828: GO 51017
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50830: LD_ADDR_VAR 0 4
50834: PUSH
50835: LD_INT 22
50837: PUSH
50838: LD_VAR 0 1
50842: PUSH
50843: EMPTY
50844: LIST
50845: LIST
50846: PUSH
50847: LD_INT 21
50849: PUSH
50850: LD_INT 3
50852: PUSH
50853: EMPTY
50854: LIST
50855: LIST
50856: PUSH
50857: EMPTY
50858: LIST
50859: LIST
50860: PPUSH
50861: CALL_OW 69
50865: ST_TO_ADDR
// if not tmp then
50866: LD_VAR 0 4
50870: NOT
50871: IFFALSE 50875
// exit ;
50873: GO 51017
// enable_addtolog := true ;
50875: LD_ADDR_OWVAR 81
50879: PUSH
50880: LD_INT 1
50882: ST_TO_ADDR
// AddToLog ( [ ) ;
50883: LD_STRING [
50885: PPUSH
50886: CALL_OW 561
// for i in tmp do
50890: LD_ADDR_VAR 0 3
50894: PUSH
50895: LD_VAR 0 4
50899: PUSH
50900: FOR_IN
50901: IFFALSE 51008
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50903: LD_STRING [
50905: PUSH
50906: LD_VAR 0 3
50910: PPUSH
50911: CALL_OW 266
50915: STR
50916: PUSH
50917: LD_STRING , 
50919: STR
50920: PUSH
50921: LD_VAR 0 3
50925: PPUSH
50926: CALL_OW 250
50930: STR
50931: PUSH
50932: LD_STRING , 
50934: STR
50935: PUSH
50936: LD_VAR 0 3
50940: PPUSH
50941: CALL_OW 251
50945: STR
50946: PUSH
50947: LD_STRING , 
50949: STR
50950: PUSH
50951: LD_VAR 0 3
50955: PPUSH
50956: CALL_OW 254
50960: STR
50961: PUSH
50962: LD_STRING , 
50964: STR
50965: PUSH
50966: LD_VAR 0 3
50970: PPUSH
50971: LD_INT 1
50973: PPUSH
50974: CALL_OW 268
50978: STR
50979: PUSH
50980: LD_STRING , 
50982: STR
50983: PUSH
50984: LD_VAR 0 3
50988: PPUSH
50989: LD_INT 2
50991: PPUSH
50992: CALL_OW 268
50996: STR
50997: PUSH
50998: LD_STRING ],
51000: STR
51001: PPUSH
51002: CALL_OW 561
// end ;
51006: GO 50900
51008: POP
51009: POP
// AddToLog ( ]; ) ;
51010: LD_STRING ];
51012: PPUSH
51013: CALL_OW 561
// end ;
51017: LD_VAR 0 2
51021: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
51022: LD_INT 0
51024: PPUSH
51025: PPUSH
51026: PPUSH
51027: PPUSH
51028: PPUSH
// if not area or not rate or not max then
51029: LD_VAR 0 1
51033: NOT
51034: PUSH
51035: LD_VAR 0 2
51039: NOT
51040: OR
51041: PUSH
51042: LD_VAR 0 4
51046: NOT
51047: OR
51048: IFFALSE 51052
// exit ;
51050: GO 51241
// while 1 do
51052: LD_INT 1
51054: IFFALSE 51241
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
51056: LD_ADDR_VAR 0 9
51060: PUSH
51061: LD_VAR 0 1
51065: PPUSH
51066: LD_INT 1
51068: PPUSH
51069: CALL_OW 287
51073: PUSH
51074: LD_INT 10
51076: MUL
51077: ST_TO_ADDR
// r := rate / 10 ;
51078: LD_ADDR_VAR 0 7
51082: PUSH
51083: LD_VAR 0 2
51087: PUSH
51088: LD_INT 10
51090: DIVREAL
51091: ST_TO_ADDR
// time := 1 1$00 ;
51092: LD_ADDR_VAR 0 8
51096: PUSH
51097: LD_INT 2100
51099: ST_TO_ADDR
// if amount < min then
51100: LD_VAR 0 9
51104: PUSH
51105: LD_VAR 0 3
51109: LESS
51110: IFFALSE 51128
// r := r * 2 else
51112: LD_ADDR_VAR 0 7
51116: PUSH
51117: LD_VAR 0 7
51121: PUSH
51122: LD_INT 2
51124: MUL
51125: ST_TO_ADDR
51126: GO 51154
// if amount > max then
51128: LD_VAR 0 9
51132: PUSH
51133: LD_VAR 0 4
51137: GREATER
51138: IFFALSE 51154
// r := r / 2 ;
51140: LD_ADDR_VAR 0 7
51144: PUSH
51145: LD_VAR 0 7
51149: PUSH
51150: LD_INT 2
51152: DIVREAL
51153: ST_TO_ADDR
// time := time / r ;
51154: LD_ADDR_VAR 0 8
51158: PUSH
51159: LD_VAR 0 8
51163: PUSH
51164: LD_VAR 0 7
51168: DIVREAL
51169: ST_TO_ADDR
// if time < 0 then
51170: LD_VAR 0 8
51174: PUSH
51175: LD_INT 0
51177: LESS
51178: IFFALSE 51195
// time := time * - 1 ;
51180: LD_ADDR_VAR 0 8
51184: PUSH
51185: LD_VAR 0 8
51189: PUSH
51190: LD_INT 1
51192: NEG
51193: MUL
51194: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
51195: LD_VAR 0 8
51199: PUSH
51200: LD_INT 35
51202: PPUSH
51203: LD_INT 875
51205: PPUSH
51206: CALL_OW 12
51210: PLUS
51211: PPUSH
51212: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
51216: LD_INT 1
51218: PPUSH
51219: LD_INT 5
51221: PPUSH
51222: CALL_OW 12
51226: PPUSH
51227: LD_VAR 0 1
51231: PPUSH
51232: LD_INT 1
51234: PPUSH
51235: CALL_OW 55
// end ;
51239: GO 51052
// end ;
51241: LD_VAR 0 5
51245: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51246: LD_INT 0
51248: PPUSH
51249: PPUSH
51250: PPUSH
51251: PPUSH
51252: PPUSH
51253: PPUSH
51254: PPUSH
51255: PPUSH
// if not turrets or not factories then
51256: LD_VAR 0 1
51260: NOT
51261: PUSH
51262: LD_VAR 0 2
51266: NOT
51267: OR
51268: IFFALSE 51272
// exit ;
51270: GO 51579
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51272: LD_ADDR_VAR 0 10
51276: PUSH
51277: LD_INT 5
51279: PUSH
51280: LD_INT 6
51282: PUSH
51283: EMPTY
51284: LIST
51285: LIST
51286: PUSH
51287: LD_INT 2
51289: PUSH
51290: LD_INT 4
51292: PUSH
51293: EMPTY
51294: LIST
51295: LIST
51296: PUSH
51297: LD_INT 3
51299: PUSH
51300: LD_INT 5
51302: PUSH
51303: EMPTY
51304: LIST
51305: LIST
51306: PUSH
51307: EMPTY
51308: LIST
51309: LIST
51310: LIST
51311: PUSH
51312: LD_INT 24
51314: PUSH
51315: LD_INT 25
51317: PUSH
51318: EMPTY
51319: LIST
51320: LIST
51321: PUSH
51322: LD_INT 23
51324: PUSH
51325: LD_INT 27
51327: PUSH
51328: EMPTY
51329: LIST
51330: LIST
51331: PUSH
51332: EMPTY
51333: LIST
51334: LIST
51335: PUSH
51336: LD_INT 42
51338: PUSH
51339: LD_INT 43
51341: PUSH
51342: EMPTY
51343: LIST
51344: LIST
51345: PUSH
51346: LD_INT 44
51348: PUSH
51349: LD_INT 46
51351: PUSH
51352: EMPTY
51353: LIST
51354: LIST
51355: PUSH
51356: LD_INT 45
51358: PUSH
51359: LD_INT 47
51361: PUSH
51362: EMPTY
51363: LIST
51364: LIST
51365: PUSH
51366: EMPTY
51367: LIST
51368: LIST
51369: LIST
51370: PUSH
51371: EMPTY
51372: LIST
51373: LIST
51374: LIST
51375: ST_TO_ADDR
// result := [ ] ;
51376: LD_ADDR_VAR 0 3
51380: PUSH
51381: EMPTY
51382: ST_TO_ADDR
// for i in turrets do
51383: LD_ADDR_VAR 0 4
51387: PUSH
51388: LD_VAR 0 1
51392: PUSH
51393: FOR_IN
51394: IFFALSE 51577
// begin nat := GetNation ( i ) ;
51396: LD_ADDR_VAR 0 7
51400: PUSH
51401: LD_VAR 0 4
51405: PPUSH
51406: CALL_OW 248
51410: ST_TO_ADDR
// weapon := 0 ;
51411: LD_ADDR_VAR 0 8
51415: PUSH
51416: LD_INT 0
51418: ST_TO_ADDR
// if not nat then
51419: LD_VAR 0 7
51423: NOT
51424: IFFALSE 51428
// continue ;
51426: GO 51393
// for j in list [ nat ] do
51428: LD_ADDR_VAR 0 5
51432: PUSH
51433: LD_VAR 0 10
51437: PUSH
51438: LD_VAR 0 7
51442: ARRAY
51443: PUSH
51444: FOR_IN
51445: IFFALSE 51486
// if GetBWeapon ( i ) = j [ 1 ] then
51447: LD_VAR 0 4
51451: PPUSH
51452: CALL_OW 269
51456: PUSH
51457: LD_VAR 0 5
51461: PUSH
51462: LD_INT 1
51464: ARRAY
51465: EQUAL
51466: IFFALSE 51484
// begin weapon := j [ 2 ] ;
51468: LD_ADDR_VAR 0 8
51472: PUSH
51473: LD_VAR 0 5
51477: PUSH
51478: LD_INT 2
51480: ARRAY
51481: ST_TO_ADDR
// break ;
51482: GO 51486
// end ;
51484: GO 51444
51486: POP
51487: POP
// if not weapon then
51488: LD_VAR 0 8
51492: NOT
51493: IFFALSE 51497
// continue ;
51495: GO 51393
// for k in factories do
51497: LD_ADDR_VAR 0 6
51501: PUSH
51502: LD_VAR 0 2
51506: PUSH
51507: FOR_IN
51508: IFFALSE 51573
// begin weapons := AvailableWeaponList ( k ) ;
51510: LD_ADDR_VAR 0 9
51514: PUSH
51515: LD_VAR 0 6
51519: PPUSH
51520: CALL_OW 478
51524: ST_TO_ADDR
// if not weapons then
51525: LD_VAR 0 9
51529: NOT
51530: IFFALSE 51534
// continue ;
51532: GO 51507
// if weapon in weapons then
51534: LD_VAR 0 8
51538: PUSH
51539: LD_VAR 0 9
51543: IN
51544: IFFALSE 51571
// begin result := [ i , weapon ] ;
51546: LD_ADDR_VAR 0 3
51550: PUSH
51551: LD_VAR 0 4
51555: PUSH
51556: LD_VAR 0 8
51560: PUSH
51561: EMPTY
51562: LIST
51563: LIST
51564: ST_TO_ADDR
// exit ;
51565: POP
51566: POP
51567: POP
51568: POP
51569: GO 51579
// end ; end ;
51571: GO 51507
51573: POP
51574: POP
// end ;
51575: GO 51393
51577: POP
51578: POP
// end ;
51579: LD_VAR 0 3
51583: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
51584: LD_INT 0
51586: PPUSH
// if not side or side > 8 then
51587: LD_VAR 0 3
51591: NOT
51592: PUSH
51593: LD_VAR 0 3
51597: PUSH
51598: LD_INT 8
51600: GREATER
51601: OR
51602: IFFALSE 51606
// exit ;
51604: GO 51665
// if not range then
51606: LD_VAR 0 4
51610: NOT
51611: IFFALSE 51622
// range := - 12 ;
51613: LD_ADDR_VAR 0 4
51617: PUSH
51618: LD_INT 12
51620: NEG
51621: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
51622: LD_VAR 0 1
51626: PPUSH
51627: LD_VAR 0 2
51631: PPUSH
51632: LD_VAR 0 3
51636: PPUSH
51637: LD_VAR 0 4
51641: PPUSH
51642: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
51646: LD_VAR 0 1
51650: PPUSH
51651: LD_VAR 0 2
51655: PPUSH
51656: LD_VAR 0 3
51660: PPUSH
51661: CALL_OW 331
// end ;
51665: LD_VAR 0 5
51669: RET
// export function Video ( mode ) ; begin
51670: LD_INT 0
51672: PPUSH
// ingame_video = mode ;
51673: LD_ADDR_OWVAR 52
51677: PUSH
51678: LD_VAR 0 1
51682: ST_TO_ADDR
// interface_hidden = mode ;
51683: LD_ADDR_OWVAR 54
51687: PUSH
51688: LD_VAR 0 1
51692: ST_TO_ADDR
// end ;
51693: LD_VAR 0 2
51697: RET
// export function Join ( array , element ) ; begin
51698: LD_INT 0
51700: PPUSH
// result := Replace ( array , array + 1 , element ) ;
51701: LD_ADDR_VAR 0 3
51705: PUSH
51706: LD_VAR 0 1
51710: PPUSH
51711: LD_VAR 0 1
51715: PUSH
51716: LD_INT 1
51718: PLUS
51719: PPUSH
51720: LD_VAR 0 2
51724: PPUSH
51725: CALL_OW 1
51729: ST_TO_ADDR
// end ;
51730: LD_VAR 0 3
51734: RET
// export function JoinUnion ( array , element ) ; begin
51735: LD_INT 0
51737: PPUSH
// result := array union element ;
51738: LD_ADDR_VAR 0 3
51742: PUSH
51743: LD_VAR 0 1
51747: PUSH
51748: LD_VAR 0 2
51752: UNION
51753: ST_TO_ADDR
// end ;
51754: LD_VAR 0 3
51758: RET
// export function GetBehemoths ( side ) ; begin
51759: LD_INT 0
51761: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
51762: LD_ADDR_VAR 0 2
51766: PUSH
51767: LD_INT 22
51769: PUSH
51770: LD_VAR 0 1
51774: PUSH
51775: EMPTY
51776: LIST
51777: LIST
51778: PUSH
51779: LD_INT 31
51781: PUSH
51782: LD_INT 25
51784: PUSH
51785: EMPTY
51786: LIST
51787: LIST
51788: PUSH
51789: EMPTY
51790: LIST
51791: LIST
51792: PPUSH
51793: CALL_OW 69
51797: ST_TO_ADDR
// end ;
51798: LD_VAR 0 2
51802: RET
// export function Shuffle ( array ) ; var i , index ; begin
51803: LD_INT 0
51805: PPUSH
51806: PPUSH
51807: PPUSH
// result := [ ] ;
51808: LD_ADDR_VAR 0 2
51812: PUSH
51813: EMPTY
51814: ST_TO_ADDR
// if not array then
51815: LD_VAR 0 1
51819: NOT
51820: IFFALSE 51824
// exit ;
51822: GO 51923
// Randomize ;
51824: CALL_OW 10
// for i = array downto 1 do
51828: LD_ADDR_VAR 0 3
51832: PUSH
51833: DOUBLE
51834: LD_VAR 0 1
51838: INC
51839: ST_TO_ADDR
51840: LD_INT 1
51842: PUSH
51843: FOR_DOWNTO
51844: IFFALSE 51921
// begin index := rand ( 1 , array ) ;
51846: LD_ADDR_VAR 0 4
51850: PUSH
51851: LD_INT 1
51853: PPUSH
51854: LD_VAR 0 1
51858: PPUSH
51859: CALL_OW 12
51863: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51864: LD_ADDR_VAR 0 2
51868: PUSH
51869: LD_VAR 0 2
51873: PPUSH
51874: LD_VAR 0 2
51878: PUSH
51879: LD_INT 1
51881: PLUS
51882: PPUSH
51883: LD_VAR 0 1
51887: PUSH
51888: LD_VAR 0 4
51892: ARRAY
51893: PPUSH
51894: CALL_OW 2
51898: ST_TO_ADDR
// array := Delete ( array , index ) ;
51899: LD_ADDR_VAR 0 1
51903: PUSH
51904: LD_VAR 0 1
51908: PPUSH
51909: LD_VAR 0 4
51913: PPUSH
51914: CALL_OW 3
51918: ST_TO_ADDR
// end ;
51919: GO 51843
51921: POP
51922: POP
// end ;
51923: LD_VAR 0 2
51927: RET
// export function GetBaseMaterials ( base ) ; begin
51928: LD_INT 0
51930: PPUSH
// result := [ 0 , 0 , 0 ] ;
51931: LD_ADDR_VAR 0 2
51935: PUSH
51936: LD_INT 0
51938: PUSH
51939: LD_INT 0
51941: PUSH
51942: LD_INT 0
51944: PUSH
51945: EMPTY
51946: LIST
51947: LIST
51948: LIST
51949: ST_TO_ADDR
// if not base then
51950: LD_VAR 0 1
51954: NOT
51955: IFFALSE 51959
// exit ;
51957: GO 52008
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51959: LD_ADDR_VAR 0 2
51963: PUSH
51964: LD_VAR 0 1
51968: PPUSH
51969: LD_INT 1
51971: PPUSH
51972: CALL_OW 275
51976: PUSH
51977: LD_VAR 0 1
51981: PPUSH
51982: LD_INT 2
51984: PPUSH
51985: CALL_OW 275
51989: PUSH
51990: LD_VAR 0 1
51994: PPUSH
51995: LD_INT 3
51997: PPUSH
51998: CALL_OW 275
52002: PUSH
52003: EMPTY
52004: LIST
52005: LIST
52006: LIST
52007: ST_TO_ADDR
// end ;
52008: LD_VAR 0 2
52012: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
52013: LD_INT 0
52015: PPUSH
52016: PPUSH
// result := array ;
52017: LD_ADDR_VAR 0 3
52021: PUSH
52022: LD_VAR 0 1
52026: ST_TO_ADDR
// if size > 0 then
52027: LD_VAR 0 2
52031: PUSH
52032: LD_INT 0
52034: GREATER
52035: IFFALSE 52081
// for i := array downto size do
52037: LD_ADDR_VAR 0 4
52041: PUSH
52042: DOUBLE
52043: LD_VAR 0 1
52047: INC
52048: ST_TO_ADDR
52049: LD_VAR 0 2
52053: PUSH
52054: FOR_DOWNTO
52055: IFFALSE 52079
// result := Delete ( result , result ) ;
52057: LD_ADDR_VAR 0 3
52061: PUSH
52062: LD_VAR 0 3
52066: PPUSH
52067: LD_VAR 0 3
52071: PPUSH
52072: CALL_OW 3
52076: ST_TO_ADDR
52077: GO 52054
52079: POP
52080: POP
// end ;
52081: LD_VAR 0 3
52085: RET
// export function ComExit ( unit ) ; var tmp ; begin
52086: LD_INT 0
52088: PPUSH
52089: PPUSH
// if not IsInUnit ( unit ) then
52090: LD_VAR 0 1
52094: PPUSH
52095: CALL_OW 310
52099: NOT
52100: IFFALSE 52104
// exit ;
52102: GO 52164
// tmp := IsInUnit ( unit ) ;
52104: LD_ADDR_VAR 0 3
52108: PUSH
52109: LD_VAR 0 1
52113: PPUSH
52114: CALL_OW 310
52118: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
52119: LD_VAR 0 3
52123: PPUSH
52124: CALL_OW 247
52128: PUSH
52129: LD_INT 2
52131: EQUAL
52132: IFFALSE 52145
// ComExitVehicle ( unit ) else
52134: LD_VAR 0 1
52138: PPUSH
52139: CALL_OW 121
52143: GO 52154
// ComExitBuilding ( unit ) ;
52145: LD_VAR 0 1
52149: PPUSH
52150: CALL_OW 122
// result := tmp ;
52154: LD_ADDR_VAR 0 2
52158: PUSH
52159: LD_VAR 0 3
52163: ST_TO_ADDR
// end ;
52164: LD_VAR 0 2
52168: RET
// export function ComExitAll ( units ) ; var i ; begin
52169: LD_INT 0
52171: PPUSH
52172: PPUSH
// if not units then
52173: LD_VAR 0 1
52177: NOT
52178: IFFALSE 52182
// exit ;
52180: GO 52208
// for i in units do
52182: LD_ADDR_VAR 0 3
52186: PUSH
52187: LD_VAR 0 1
52191: PUSH
52192: FOR_IN
52193: IFFALSE 52206
// ComExit ( i ) ;
52195: LD_VAR 0 3
52199: PPUSH
52200: CALL 52086 0 1
52204: GO 52192
52206: POP
52207: POP
// end ;
52208: LD_VAR 0 2
52212: RET
// export function ResetHc ; begin
52213: LD_INT 0
52215: PPUSH
// InitHc ;
52216: CALL_OW 19
// hc_importance := 0 ;
52220: LD_ADDR_OWVAR 32
52224: PUSH
52225: LD_INT 0
52227: ST_TO_ADDR
// end ;
52228: LD_VAR 0 1
52232: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52233: LD_INT 0
52235: PPUSH
52236: PPUSH
52237: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52238: LD_ADDR_VAR 0 6
52242: PUSH
52243: LD_VAR 0 1
52247: PUSH
52248: LD_VAR 0 3
52252: PLUS
52253: PUSH
52254: LD_INT 2
52256: DIV
52257: ST_TO_ADDR
// if _x < 0 then
52258: LD_VAR 0 6
52262: PUSH
52263: LD_INT 0
52265: LESS
52266: IFFALSE 52283
// _x := _x * - 1 ;
52268: LD_ADDR_VAR 0 6
52272: PUSH
52273: LD_VAR 0 6
52277: PUSH
52278: LD_INT 1
52280: NEG
52281: MUL
52282: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
52283: LD_ADDR_VAR 0 7
52287: PUSH
52288: LD_VAR 0 2
52292: PUSH
52293: LD_VAR 0 4
52297: PLUS
52298: PUSH
52299: LD_INT 2
52301: DIV
52302: ST_TO_ADDR
// if _y < 0 then
52303: LD_VAR 0 7
52307: PUSH
52308: LD_INT 0
52310: LESS
52311: IFFALSE 52328
// _y := _y * - 1 ;
52313: LD_ADDR_VAR 0 7
52317: PUSH
52318: LD_VAR 0 7
52322: PUSH
52323: LD_INT 1
52325: NEG
52326: MUL
52327: ST_TO_ADDR
// result := [ _x , _y ] ;
52328: LD_ADDR_VAR 0 5
52332: PUSH
52333: LD_VAR 0 6
52337: PUSH
52338: LD_VAR 0 7
52342: PUSH
52343: EMPTY
52344: LIST
52345: LIST
52346: ST_TO_ADDR
// end ;
52347: LD_VAR 0 5
52351: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
52352: LD_INT 0
52354: PPUSH
52355: PPUSH
52356: PPUSH
52357: PPUSH
// task := GetTaskList ( unit ) ;
52358: LD_ADDR_VAR 0 7
52362: PUSH
52363: LD_VAR 0 1
52367: PPUSH
52368: CALL_OW 437
52372: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
52373: LD_VAR 0 7
52377: NOT
52378: PUSH
52379: LD_VAR 0 1
52383: PPUSH
52384: LD_VAR 0 2
52388: PPUSH
52389: CALL_OW 308
52393: NOT
52394: AND
52395: IFFALSE 52399
// exit ;
52397: GO 52517
// if IsInArea ( unit , area ) then
52399: LD_VAR 0 1
52403: PPUSH
52404: LD_VAR 0 2
52408: PPUSH
52409: CALL_OW 308
52413: IFFALSE 52431
// begin ComMoveToArea ( unit , goAway ) ;
52415: LD_VAR 0 1
52419: PPUSH
52420: LD_VAR 0 3
52424: PPUSH
52425: CALL_OW 113
// exit ;
52429: GO 52517
// end ; if task [ 1 ] [ 1 ] <> M then
52431: LD_VAR 0 7
52435: PUSH
52436: LD_INT 1
52438: ARRAY
52439: PUSH
52440: LD_INT 1
52442: ARRAY
52443: PUSH
52444: LD_STRING M
52446: NONEQUAL
52447: IFFALSE 52451
// exit ;
52449: GO 52517
// x := task [ 1 ] [ 2 ] ;
52451: LD_ADDR_VAR 0 5
52455: PUSH
52456: LD_VAR 0 7
52460: PUSH
52461: LD_INT 1
52463: ARRAY
52464: PUSH
52465: LD_INT 2
52467: ARRAY
52468: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
52469: LD_ADDR_VAR 0 6
52473: PUSH
52474: LD_VAR 0 7
52478: PUSH
52479: LD_INT 1
52481: ARRAY
52482: PUSH
52483: LD_INT 3
52485: ARRAY
52486: ST_TO_ADDR
// if InArea ( x , y , area ) then
52487: LD_VAR 0 5
52491: PPUSH
52492: LD_VAR 0 6
52496: PPUSH
52497: LD_VAR 0 2
52501: PPUSH
52502: CALL_OW 309
52506: IFFALSE 52517
// ComStop ( unit ) ;
52508: LD_VAR 0 1
52512: PPUSH
52513: CALL_OW 141
// end ;
52517: LD_VAR 0 4
52521: RET
// export function Abs ( value ) ; begin
52522: LD_INT 0
52524: PPUSH
// result := value ;
52525: LD_ADDR_VAR 0 2
52529: PUSH
52530: LD_VAR 0 1
52534: ST_TO_ADDR
// if value < 0 then
52535: LD_VAR 0 1
52539: PUSH
52540: LD_INT 0
52542: LESS
52543: IFFALSE 52560
// result := value * - 1 ;
52545: LD_ADDR_VAR 0 2
52549: PUSH
52550: LD_VAR 0 1
52554: PUSH
52555: LD_INT 1
52557: NEG
52558: MUL
52559: ST_TO_ADDR
// end ;
52560: LD_VAR 0 2
52564: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
52565: LD_INT 0
52567: PPUSH
52568: PPUSH
52569: PPUSH
52570: PPUSH
52571: PPUSH
52572: PPUSH
52573: PPUSH
52574: PPUSH
// if not unit or not building then
52575: LD_VAR 0 1
52579: NOT
52580: PUSH
52581: LD_VAR 0 2
52585: NOT
52586: OR
52587: IFFALSE 52591
// exit ;
52589: GO 52817
// x := GetX ( building ) ;
52591: LD_ADDR_VAR 0 4
52595: PUSH
52596: LD_VAR 0 2
52600: PPUSH
52601: CALL_OW 250
52605: ST_TO_ADDR
// y := GetY ( building ) ;
52606: LD_ADDR_VAR 0 6
52610: PUSH
52611: LD_VAR 0 2
52615: PPUSH
52616: CALL_OW 251
52620: ST_TO_ADDR
// d := GetDir ( building ) ;
52621: LD_ADDR_VAR 0 8
52625: PUSH
52626: LD_VAR 0 2
52630: PPUSH
52631: CALL_OW 254
52635: ST_TO_ADDR
// r := 4 ;
52636: LD_ADDR_VAR 0 9
52640: PUSH
52641: LD_INT 4
52643: ST_TO_ADDR
// for i := 1 to 5 do
52644: LD_ADDR_VAR 0 10
52648: PUSH
52649: DOUBLE
52650: LD_INT 1
52652: DEC
52653: ST_TO_ADDR
52654: LD_INT 5
52656: PUSH
52657: FOR_TO
52658: IFFALSE 52815
// begin _x := ShiftX ( x , d , r + i ) ;
52660: LD_ADDR_VAR 0 5
52664: PUSH
52665: LD_VAR 0 4
52669: PPUSH
52670: LD_VAR 0 8
52674: PPUSH
52675: LD_VAR 0 9
52679: PUSH
52680: LD_VAR 0 10
52684: PLUS
52685: PPUSH
52686: CALL_OW 272
52690: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
52691: LD_ADDR_VAR 0 7
52695: PUSH
52696: LD_VAR 0 6
52700: PPUSH
52701: LD_VAR 0 8
52705: PPUSH
52706: LD_VAR 0 9
52710: PUSH
52711: LD_VAR 0 10
52715: PLUS
52716: PPUSH
52717: CALL_OW 273
52721: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
52722: LD_VAR 0 5
52726: PPUSH
52727: LD_VAR 0 7
52731: PPUSH
52732: CALL_OW 488
52736: PUSH
52737: LD_VAR 0 5
52741: PPUSH
52742: LD_VAR 0 7
52746: PPUSH
52747: CALL_OW 428
52751: PPUSH
52752: CALL_OW 247
52756: PUSH
52757: LD_INT 3
52759: PUSH
52760: LD_INT 2
52762: PUSH
52763: EMPTY
52764: LIST
52765: LIST
52766: IN
52767: NOT
52768: AND
52769: IFFALSE 52813
// begin ComMoveXY ( unit , _x , _y ) ;
52771: LD_VAR 0 1
52775: PPUSH
52776: LD_VAR 0 5
52780: PPUSH
52781: LD_VAR 0 7
52785: PPUSH
52786: CALL_OW 111
// result := [ _x , _y ] ;
52790: LD_ADDR_VAR 0 3
52794: PUSH
52795: LD_VAR 0 5
52799: PUSH
52800: LD_VAR 0 7
52804: PUSH
52805: EMPTY
52806: LIST
52807: LIST
52808: ST_TO_ADDR
// exit ;
52809: POP
52810: POP
52811: GO 52817
// end ; end ;
52813: GO 52657
52815: POP
52816: POP
// end ;
52817: LD_VAR 0 3
52821: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52822: LD_INT 0
52824: PPUSH
52825: PPUSH
52826: PPUSH
// result := 0 ;
52827: LD_ADDR_VAR 0 3
52831: PUSH
52832: LD_INT 0
52834: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52835: LD_VAR 0 1
52839: PUSH
52840: LD_INT 0
52842: LESS
52843: PUSH
52844: LD_VAR 0 1
52848: PUSH
52849: LD_INT 8
52851: GREATER
52852: OR
52853: PUSH
52854: LD_VAR 0 2
52858: PUSH
52859: LD_INT 0
52861: LESS
52862: OR
52863: PUSH
52864: LD_VAR 0 2
52868: PUSH
52869: LD_INT 8
52871: GREATER
52872: OR
52873: IFFALSE 52877
// exit ;
52875: GO 52952
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52877: LD_ADDR_VAR 0 4
52881: PUSH
52882: LD_INT 22
52884: PUSH
52885: LD_VAR 0 2
52889: PUSH
52890: EMPTY
52891: LIST
52892: LIST
52893: PPUSH
52894: CALL_OW 69
52898: PUSH
52899: FOR_IN
52900: IFFALSE 52950
// begin un := UnitShoot ( i ) ;
52902: LD_ADDR_VAR 0 5
52906: PUSH
52907: LD_VAR 0 4
52911: PPUSH
52912: CALL_OW 504
52916: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52917: LD_VAR 0 5
52921: PPUSH
52922: CALL_OW 255
52926: PUSH
52927: LD_VAR 0 1
52931: EQUAL
52932: IFFALSE 52948
// begin result := un ;
52934: LD_ADDR_VAR 0 3
52938: PUSH
52939: LD_VAR 0 5
52943: ST_TO_ADDR
// exit ;
52944: POP
52945: POP
52946: GO 52952
// end ; end ;
52948: GO 52899
52950: POP
52951: POP
// end ;
52952: LD_VAR 0 3
52956: RET
// export function GetCargoBay ( units ) ; begin
52957: LD_INT 0
52959: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52960: LD_ADDR_VAR 0 2
52964: PUSH
52965: LD_VAR 0 1
52969: PPUSH
52970: LD_INT 2
52972: PUSH
52973: LD_INT 34
52975: PUSH
52976: LD_INT 12
52978: PUSH
52979: EMPTY
52980: LIST
52981: LIST
52982: PUSH
52983: LD_INT 34
52985: PUSH
52986: LD_INT 51
52988: PUSH
52989: EMPTY
52990: LIST
52991: LIST
52992: PUSH
52993: LD_INT 34
52995: PUSH
52996: LD_INT 32
52998: PUSH
52999: EMPTY
53000: LIST
53001: LIST
53002: PUSH
53003: LD_INT 34
53005: PUSH
53006: LD_EXP 105
53010: PUSH
53011: EMPTY
53012: LIST
53013: LIST
53014: PUSH
53015: EMPTY
53016: LIST
53017: LIST
53018: LIST
53019: LIST
53020: LIST
53021: PPUSH
53022: CALL_OW 72
53026: ST_TO_ADDR
// end ;
53027: LD_VAR 0 2
53031: RET
// export function Negate ( value ) ; begin
53032: LD_INT 0
53034: PPUSH
// result := not value ;
53035: LD_ADDR_VAR 0 2
53039: PUSH
53040: LD_VAR 0 1
53044: NOT
53045: ST_TO_ADDR
// end ;
53046: LD_VAR 0 2
53050: RET
// export function Inc ( value ) ; begin
53051: LD_INT 0
53053: PPUSH
// result := value + 1 ;
53054: LD_ADDR_VAR 0 2
53058: PUSH
53059: LD_VAR 0 1
53063: PUSH
53064: LD_INT 1
53066: PLUS
53067: ST_TO_ADDR
// end ;
53068: LD_VAR 0 2
53072: RET
// export function Dec ( value ) ; begin
53073: LD_INT 0
53075: PPUSH
// result := value - 1 ;
53076: LD_ADDR_VAR 0 2
53080: PUSH
53081: LD_VAR 0 1
53085: PUSH
53086: LD_INT 1
53088: MINUS
53089: ST_TO_ADDR
// end ;
53090: LD_VAR 0 2
53094: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
53095: LD_INT 0
53097: PPUSH
53098: PPUSH
53099: PPUSH
53100: PPUSH
53101: PPUSH
53102: PPUSH
53103: PPUSH
53104: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
53105: LD_VAR 0 1
53109: PPUSH
53110: LD_VAR 0 2
53114: PPUSH
53115: CALL_OW 488
53119: NOT
53120: PUSH
53121: LD_VAR 0 3
53125: PPUSH
53126: LD_VAR 0 4
53130: PPUSH
53131: CALL_OW 488
53135: NOT
53136: OR
53137: IFFALSE 53150
// begin result := - 1 ;
53139: LD_ADDR_VAR 0 5
53143: PUSH
53144: LD_INT 1
53146: NEG
53147: ST_TO_ADDR
// exit ;
53148: GO 53385
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
53150: LD_ADDR_VAR 0 12
53154: PUSH
53155: LD_VAR 0 1
53159: PPUSH
53160: LD_VAR 0 2
53164: PPUSH
53165: LD_VAR 0 3
53169: PPUSH
53170: LD_VAR 0 4
53174: PPUSH
53175: CALL 52233 0 4
53179: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
53180: LD_ADDR_VAR 0 11
53184: PUSH
53185: LD_VAR 0 1
53189: PPUSH
53190: LD_VAR 0 2
53194: PPUSH
53195: LD_VAR 0 12
53199: PUSH
53200: LD_INT 1
53202: ARRAY
53203: PPUSH
53204: LD_VAR 0 12
53208: PUSH
53209: LD_INT 2
53211: ARRAY
53212: PPUSH
53213: CALL_OW 298
53217: ST_TO_ADDR
// distance := 9999 ;
53218: LD_ADDR_VAR 0 10
53222: PUSH
53223: LD_INT 9999
53225: ST_TO_ADDR
// for i := 0 to 5 do
53226: LD_ADDR_VAR 0 6
53230: PUSH
53231: DOUBLE
53232: LD_INT 0
53234: DEC
53235: ST_TO_ADDR
53236: LD_INT 5
53238: PUSH
53239: FOR_TO
53240: IFFALSE 53383
// begin _x := ShiftX ( x1 , i , centerDist ) ;
53242: LD_ADDR_VAR 0 7
53246: PUSH
53247: LD_VAR 0 1
53251: PPUSH
53252: LD_VAR 0 6
53256: PPUSH
53257: LD_VAR 0 11
53261: PPUSH
53262: CALL_OW 272
53266: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
53267: LD_ADDR_VAR 0 8
53271: PUSH
53272: LD_VAR 0 2
53276: PPUSH
53277: LD_VAR 0 6
53281: PPUSH
53282: LD_VAR 0 11
53286: PPUSH
53287: CALL_OW 273
53291: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53292: LD_VAR 0 7
53296: PPUSH
53297: LD_VAR 0 8
53301: PPUSH
53302: CALL_OW 488
53306: NOT
53307: IFFALSE 53311
// continue ;
53309: GO 53239
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
53311: LD_ADDR_VAR 0 9
53315: PUSH
53316: LD_VAR 0 12
53320: PUSH
53321: LD_INT 1
53323: ARRAY
53324: PPUSH
53325: LD_VAR 0 12
53329: PUSH
53330: LD_INT 2
53332: ARRAY
53333: PPUSH
53334: LD_VAR 0 7
53338: PPUSH
53339: LD_VAR 0 8
53343: PPUSH
53344: CALL_OW 298
53348: ST_TO_ADDR
// if tmp < distance then
53349: LD_VAR 0 9
53353: PUSH
53354: LD_VAR 0 10
53358: LESS
53359: IFFALSE 53381
// begin result := i ;
53361: LD_ADDR_VAR 0 5
53365: PUSH
53366: LD_VAR 0 6
53370: ST_TO_ADDR
// distance := tmp ;
53371: LD_ADDR_VAR 0 10
53375: PUSH
53376: LD_VAR 0 9
53380: ST_TO_ADDR
// end ; end ;
53381: GO 53239
53383: POP
53384: POP
// end ;
53385: LD_VAR 0 5
53389: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53390: LD_INT 0
53392: PPUSH
53393: PPUSH
// if not driver or not IsInUnit ( driver ) then
53394: LD_VAR 0 1
53398: NOT
53399: PUSH
53400: LD_VAR 0 1
53404: PPUSH
53405: CALL_OW 310
53409: NOT
53410: OR
53411: IFFALSE 53415
// exit ;
53413: GO 53505
// vehicle := IsInUnit ( driver ) ;
53415: LD_ADDR_VAR 0 3
53419: PUSH
53420: LD_VAR 0 1
53424: PPUSH
53425: CALL_OW 310
53429: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53430: LD_VAR 0 1
53434: PPUSH
53435: LD_STRING \
53437: PUSH
53438: LD_INT 0
53440: PUSH
53441: LD_INT 0
53443: PUSH
53444: LD_INT 0
53446: PUSH
53447: LD_INT 0
53449: PUSH
53450: LD_INT 0
53452: PUSH
53453: LD_INT 0
53455: PUSH
53456: EMPTY
53457: LIST
53458: LIST
53459: LIST
53460: LIST
53461: LIST
53462: LIST
53463: LIST
53464: PUSH
53465: LD_STRING E
53467: PUSH
53468: LD_INT 0
53470: PUSH
53471: LD_INT 0
53473: PUSH
53474: LD_VAR 0 3
53478: PUSH
53479: LD_INT 0
53481: PUSH
53482: LD_INT 0
53484: PUSH
53485: LD_INT 0
53487: PUSH
53488: EMPTY
53489: LIST
53490: LIST
53491: LIST
53492: LIST
53493: LIST
53494: LIST
53495: LIST
53496: PUSH
53497: EMPTY
53498: LIST
53499: LIST
53500: PPUSH
53501: CALL_OW 446
// end ;
53505: LD_VAR 0 2
53509: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53510: LD_INT 0
53512: PPUSH
53513: PPUSH
// if not driver or not IsInUnit ( driver ) then
53514: LD_VAR 0 1
53518: NOT
53519: PUSH
53520: LD_VAR 0 1
53524: PPUSH
53525: CALL_OW 310
53529: NOT
53530: OR
53531: IFFALSE 53535
// exit ;
53533: GO 53625
// vehicle := IsInUnit ( driver ) ;
53535: LD_ADDR_VAR 0 3
53539: PUSH
53540: LD_VAR 0 1
53544: PPUSH
53545: CALL_OW 310
53549: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53550: LD_VAR 0 1
53554: PPUSH
53555: LD_STRING \
53557: PUSH
53558: LD_INT 0
53560: PUSH
53561: LD_INT 0
53563: PUSH
53564: LD_INT 0
53566: PUSH
53567: LD_INT 0
53569: PUSH
53570: LD_INT 0
53572: PUSH
53573: LD_INT 0
53575: PUSH
53576: EMPTY
53577: LIST
53578: LIST
53579: LIST
53580: LIST
53581: LIST
53582: LIST
53583: LIST
53584: PUSH
53585: LD_STRING E
53587: PUSH
53588: LD_INT 0
53590: PUSH
53591: LD_INT 0
53593: PUSH
53594: LD_VAR 0 3
53598: PUSH
53599: LD_INT 0
53601: PUSH
53602: LD_INT 0
53604: PUSH
53605: LD_INT 0
53607: PUSH
53608: EMPTY
53609: LIST
53610: LIST
53611: LIST
53612: LIST
53613: LIST
53614: LIST
53615: LIST
53616: PUSH
53617: EMPTY
53618: LIST
53619: LIST
53620: PPUSH
53621: CALL_OW 447
// end ;
53625: LD_VAR 0 2
53629: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
53630: LD_INT 0
53632: PPUSH
53633: PPUSH
53634: PPUSH
// tmp := [ ] ;
53635: LD_ADDR_VAR 0 5
53639: PUSH
53640: EMPTY
53641: ST_TO_ADDR
// for i in units do
53642: LD_ADDR_VAR 0 4
53646: PUSH
53647: LD_VAR 0 1
53651: PUSH
53652: FOR_IN
53653: IFFALSE 53691
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
53655: LD_ADDR_VAR 0 5
53659: PUSH
53660: LD_VAR 0 5
53664: PPUSH
53665: LD_VAR 0 5
53669: PUSH
53670: LD_INT 1
53672: PLUS
53673: PPUSH
53674: LD_VAR 0 4
53678: PPUSH
53679: CALL_OW 256
53683: PPUSH
53684: CALL_OW 2
53688: ST_TO_ADDR
53689: GO 53652
53691: POP
53692: POP
// if not tmp then
53693: LD_VAR 0 5
53697: NOT
53698: IFFALSE 53702
// exit ;
53700: GO 53750
// if asc then
53702: LD_VAR 0 2
53706: IFFALSE 53730
// result := SortListByListAsc ( units , tmp ) else
53708: LD_ADDR_VAR 0 3
53712: PUSH
53713: LD_VAR 0 1
53717: PPUSH
53718: LD_VAR 0 5
53722: PPUSH
53723: CALL_OW 76
53727: ST_TO_ADDR
53728: GO 53750
// result := SortListByListDesc ( units , tmp ) ;
53730: LD_ADDR_VAR 0 3
53734: PUSH
53735: LD_VAR 0 1
53739: PPUSH
53740: LD_VAR 0 5
53744: PPUSH
53745: CALL_OW 77
53749: ST_TO_ADDR
// end ;
53750: LD_VAR 0 3
53754: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
53755: LD_INT 0
53757: PPUSH
53758: PPUSH
// task := GetTaskList ( mech ) ;
53759: LD_ADDR_VAR 0 4
53763: PUSH
53764: LD_VAR 0 1
53768: PPUSH
53769: CALL_OW 437
53773: ST_TO_ADDR
// if not task then
53774: LD_VAR 0 4
53778: NOT
53779: IFFALSE 53783
// exit ;
53781: GO 53825
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
53783: LD_ADDR_VAR 0 3
53787: PUSH
53788: LD_VAR 0 4
53792: PUSH
53793: LD_INT 1
53795: ARRAY
53796: PUSH
53797: LD_INT 1
53799: ARRAY
53800: PUSH
53801: LD_STRING r
53803: EQUAL
53804: PUSH
53805: LD_VAR 0 4
53809: PUSH
53810: LD_INT 1
53812: ARRAY
53813: PUSH
53814: LD_INT 4
53816: ARRAY
53817: PUSH
53818: LD_VAR 0 2
53822: EQUAL
53823: AND
53824: ST_TO_ADDR
// end ;
53825: LD_VAR 0 3
53829: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
53830: LD_INT 0
53832: PPUSH
// SetDir ( unit , d ) ;
53833: LD_VAR 0 1
53837: PPUSH
53838: LD_VAR 0 4
53842: PPUSH
53843: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
53847: LD_VAR 0 1
53851: PPUSH
53852: LD_VAR 0 2
53856: PPUSH
53857: LD_VAR 0 3
53861: PPUSH
53862: LD_VAR 0 5
53866: PPUSH
53867: CALL_OW 48
// end ;
53871: LD_VAR 0 6
53875: RET
// export function ToNaturalNumber ( number ) ; begin
53876: LD_INT 0
53878: PPUSH
// result := number div 1 ;
53879: LD_ADDR_VAR 0 2
53883: PUSH
53884: LD_VAR 0 1
53888: PUSH
53889: LD_INT 1
53891: DIV
53892: ST_TO_ADDR
// if number < 0 then
53893: LD_VAR 0 1
53897: PUSH
53898: LD_INT 0
53900: LESS
53901: IFFALSE 53911
// result := 0 ;
53903: LD_ADDR_VAR 0 2
53907: PUSH
53908: LD_INT 0
53910: ST_TO_ADDR
// end ;
53911: LD_VAR 0 2
53915: RET
// export function SortByClass ( units , class ) ; var un ; begin
53916: LD_INT 0
53918: PPUSH
53919: PPUSH
// if not units or not class then
53920: LD_VAR 0 1
53924: NOT
53925: PUSH
53926: LD_VAR 0 2
53930: NOT
53931: OR
53932: IFFALSE 53936
// exit ;
53934: GO 54031
// result := [ ] ;
53936: LD_ADDR_VAR 0 3
53940: PUSH
53941: EMPTY
53942: ST_TO_ADDR
// for un in units do
53943: LD_ADDR_VAR 0 4
53947: PUSH
53948: LD_VAR 0 1
53952: PUSH
53953: FOR_IN
53954: IFFALSE 54029
// if GetClass ( un ) = class then
53956: LD_VAR 0 4
53960: PPUSH
53961: CALL_OW 257
53965: PUSH
53966: LD_VAR 0 2
53970: EQUAL
53971: IFFALSE 53998
// result := Insert ( result , 1 , un ) else
53973: LD_ADDR_VAR 0 3
53977: PUSH
53978: LD_VAR 0 3
53982: PPUSH
53983: LD_INT 1
53985: PPUSH
53986: LD_VAR 0 4
53990: PPUSH
53991: CALL_OW 2
53995: ST_TO_ADDR
53996: GO 54027
// result := Replace ( result , result + 1 , un ) ;
53998: LD_ADDR_VAR 0 3
54002: PUSH
54003: LD_VAR 0 3
54007: PPUSH
54008: LD_VAR 0 3
54012: PUSH
54013: LD_INT 1
54015: PLUS
54016: PPUSH
54017: LD_VAR 0 4
54021: PPUSH
54022: CALL_OW 1
54026: ST_TO_ADDR
54027: GO 53953
54029: POP
54030: POP
// end ;
54031: LD_VAR 0 3
54035: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
54036: LD_INT 0
54038: PPUSH
54039: PPUSH
54040: PPUSH
54041: PPUSH
54042: PPUSH
54043: PPUSH
54044: PPUSH
// result := [ ] ;
54045: LD_ADDR_VAR 0 4
54049: PUSH
54050: EMPTY
54051: ST_TO_ADDR
// if x - r < 0 then
54052: LD_VAR 0 1
54056: PUSH
54057: LD_VAR 0 3
54061: MINUS
54062: PUSH
54063: LD_INT 0
54065: LESS
54066: IFFALSE 54078
// min_x := 0 else
54068: LD_ADDR_VAR 0 8
54072: PUSH
54073: LD_INT 0
54075: ST_TO_ADDR
54076: GO 54094
// min_x := x - r ;
54078: LD_ADDR_VAR 0 8
54082: PUSH
54083: LD_VAR 0 1
54087: PUSH
54088: LD_VAR 0 3
54092: MINUS
54093: ST_TO_ADDR
// if y - r < 0 then
54094: LD_VAR 0 2
54098: PUSH
54099: LD_VAR 0 3
54103: MINUS
54104: PUSH
54105: LD_INT 0
54107: LESS
54108: IFFALSE 54120
// min_y := 0 else
54110: LD_ADDR_VAR 0 7
54114: PUSH
54115: LD_INT 0
54117: ST_TO_ADDR
54118: GO 54136
// min_y := y - r ;
54120: LD_ADDR_VAR 0 7
54124: PUSH
54125: LD_VAR 0 2
54129: PUSH
54130: LD_VAR 0 3
54134: MINUS
54135: ST_TO_ADDR
// max_x := x + r ;
54136: LD_ADDR_VAR 0 9
54140: PUSH
54141: LD_VAR 0 1
54145: PUSH
54146: LD_VAR 0 3
54150: PLUS
54151: ST_TO_ADDR
// max_y := y + r ;
54152: LD_ADDR_VAR 0 10
54156: PUSH
54157: LD_VAR 0 2
54161: PUSH
54162: LD_VAR 0 3
54166: PLUS
54167: ST_TO_ADDR
// for _x = min_x to max_x do
54168: LD_ADDR_VAR 0 5
54172: PUSH
54173: DOUBLE
54174: LD_VAR 0 8
54178: DEC
54179: ST_TO_ADDR
54180: LD_VAR 0 9
54184: PUSH
54185: FOR_TO
54186: IFFALSE 54287
// for _y = min_y to max_y do
54188: LD_ADDR_VAR 0 6
54192: PUSH
54193: DOUBLE
54194: LD_VAR 0 7
54198: DEC
54199: ST_TO_ADDR
54200: LD_VAR 0 10
54204: PUSH
54205: FOR_TO
54206: IFFALSE 54283
// begin if not ValidHex ( _x , _y ) then
54208: LD_VAR 0 5
54212: PPUSH
54213: LD_VAR 0 6
54217: PPUSH
54218: CALL_OW 488
54222: NOT
54223: IFFALSE 54227
// continue ;
54225: GO 54205
// if GetResourceTypeXY ( _x , _y ) then
54227: LD_VAR 0 5
54231: PPUSH
54232: LD_VAR 0 6
54236: PPUSH
54237: CALL_OW 283
54241: IFFALSE 54281
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
54243: LD_ADDR_VAR 0 4
54247: PUSH
54248: LD_VAR 0 4
54252: PPUSH
54253: LD_VAR 0 4
54257: PUSH
54258: LD_INT 1
54260: PLUS
54261: PPUSH
54262: LD_VAR 0 5
54266: PUSH
54267: LD_VAR 0 6
54271: PUSH
54272: EMPTY
54273: LIST
54274: LIST
54275: PPUSH
54276: CALL_OW 1
54280: ST_TO_ADDR
// end ;
54281: GO 54205
54283: POP
54284: POP
54285: GO 54185
54287: POP
54288: POP
// end ;
54289: LD_VAR 0 4
54293: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
54294: LD_INT 0
54296: PPUSH
54297: PPUSH
54298: PPUSH
54299: PPUSH
54300: PPUSH
54301: PPUSH
54302: PPUSH
54303: PPUSH
// if not units then
54304: LD_VAR 0 1
54308: NOT
54309: IFFALSE 54313
// exit ;
54311: GO 54839
// result := UnitFilter ( units , [ f_ok ] ) ;
54313: LD_ADDR_VAR 0 3
54317: PUSH
54318: LD_VAR 0 1
54322: PPUSH
54323: LD_INT 50
54325: PUSH
54326: EMPTY
54327: LIST
54328: PPUSH
54329: CALL_OW 72
54333: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
54334: LD_ADDR_VAR 0 8
54338: PUSH
54339: LD_VAR 0 1
54343: PUSH
54344: LD_INT 1
54346: ARRAY
54347: PPUSH
54348: CALL_OW 255
54352: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
54353: LD_ADDR_VAR 0 10
54357: PUSH
54358: LD_INT 29
54360: PUSH
54361: LD_EXP 108
54365: PUSH
54366: LD_INT 49
54368: PUSH
54369: EMPTY
54370: LIST
54371: LIST
54372: LIST
54373: ST_TO_ADDR
// if not result then
54374: LD_VAR 0 3
54378: NOT
54379: IFFALSE 54383
// exit ;
54381: GO 54839
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
54383: LD_ADDR_VAR 0 5
54387: PUSH
54388: LD_INT 81
54390: PUSH
54391: LD_VAR 0 8
54395: PUSH
54396: EMPTY
54397: LIST
54398: LIST
54399: PPUSH
54400: CALL_OW 69
54404: ST_TO_ADDR
// for i in result do
54405: LD_ADDR_VAR 0 4
54409: PUSH
54410: LD_VAR 0 3
54414: PUSH
54415: FOR_IN
54416: IFFALSE 54837
// begin tag := GetTag ( i ) + 1 ;
54418: LD_ADDR_VAR 0 9
54422: PUSH
54423: LD_VAR 0 4
54427: PPUSH
54428: CALL_OW 110
54432: PUSH
54433: LD_INT 1
54435: PLUS
54436: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
54437: LD_ADDR_VAR 0 7
54441: PUSH
54442: LD_VAR 0 4
54446: PPUSH
54447: CALL_OW 250
54451: PPUSH
54452: LD_VAR 0 4
54456: PPUSH
54457: CALL_OW 251
54461: PPUSH
54462: LD_INT 6
54464: PPUSH
54465: CALL 54036 0 3
54469: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
54470: LD_VAR 0 4
54474: PPUSH
54475: CALL_OW 247
54479: PUSH
54480: LD_INT 2
54482: EQUAL
54483: PUSH
54484: LD_VAR 0 7
54488: AND
54489: PUSH
54490: LD_VAR 0 4
54494: PPUSH
54495: CALL_OW 264
54499: PUSH
54500: LD_VAR 0 10
54504: IN
54505: NOT
54506: AND
54507: IFFALSE 54546
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
54509: LD_VAR 0 4
54513: PPUSH
54514: LD_VAR 0 7
54518: PUSH
54519: LD_INT 1
54521: ARRAY
54522: PUSH
54523: LD_INT 1
54525: ARRAY
54526: PPUSH
54527: LD_VAR 0 7
54531: PUSH
54532: LD_INT 1
54534: ARRAY
54535: PUSH
54536: LD_INT 2
54538: ARRAY
54539: PPUSH
54540: CALL_OW 116
54544: GO 54835
// if path > tag then
54546: LD_VAR 0 2
54550: PUSH
54551: LD_VAR 0 9
54555: GREATER
54556: IFFALSE 54764
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
54558: LD_ADDR_VAR 0 6
54562: PUSH
54563: LD_VAR 0 5
54567: PPUSH
54568: LD_INT 91
54570: PUSH
54571: LD_VAR 0 4
54575: PUSH
54576: LD_INT 8
54578: PUSH
54579: EMPTY
54580: LIST
54581: LIST
54582: LIST
54583: PPUSH
54584: CALL_OW 72
54588: ST_TO_ADDR
// if nearEnemy then
54589: LD_VAR 0 6
54593: IFFALSE 54662
// begin if GetWeapon ( i ) = ru_time_lapser then
54595: LD_VAR 0 4
54599: PPUSH
54600: CALL_OW 264
54604: PUSH
54605: LD_INT 49
54607: EQUAL
54608: IFFALSE 54636
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
54610: LD_VAR 0 4
54614: PPUSH
54615: LD_VAR 0 6
54619: PPUSH
54620: LD_VAR 0 4
54624: PPUSH
54625: CALL_OW 74
54629: PPUSH
54630: CALL_OW 112
54634: GO 54660
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
54636: LD_VAR 0 4
54640: PPUSH
54641: LD_VAR 0 6
54645: PPUSH
54646: LD_VAR 0 4
54650: PPUSH
54651: CALL_OW 74
54655: PPUSH
54656: CALL_OW 115
// end else
54660: GO 54762
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
54662: LD_VAR 0 4
54666: PPUSH
54667: LD_VAR 0 2
54671: PUSH
54672: LD_VAR 0 9
54676: ARRAY
54677: PUSH
54678: LD_INT 1
54680: ARRAY
54681: PPUSH
54682: LD_VAR 0 2
54686: PUSH
54687: LD_VAR 0 9
54691: ARRAY
54692: PUSH
54693: LD_INT 2
54695: ARRAY
54696: PPUSH
54697: CALL_OW 297
54701: PUSH
54702: LD_INT 6
54704: GREATER
54705: IFFALSE 54748
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
54707: LD_VAR 0 4
54711: PPUSH
54712: LD_VAR 0 2
54716: PUSH
54717: LD_VAR 0 9
54721: ARRAY
54722: PUSH
54723: LD_INT 1
54725: ARRAY
54726: PPUSH
54727: LD_VAR 0 2
54731: PUSH
54732: LD_VAR 0 9
54736: ARRAY
54737: PUSH
54738: LD_INT 2
54740: ARRAY
54741: PPUSH
54742: CALL_OW 114
54746: GO 54762
// SetTag ( i , tag ) ;
54748: LD_VAR 0 4
54752: PPUSH
54753: LD_VAR 0 9
54757: PPUSH
54758: CALL_OW 109
// end else
54762: GO 54835
// if enemy then
54764: LD_VAR 0 5
54768: IFFALSE 54835
// begin if GetWeapon ( i ) = ru_time_lapser then
54770: LD_VAR 0 4
54774: PPUSH
54775: CALL_OW 264
54779: PUSH
54780: LD_INT 49
54782: EQUAL
54783: IFFALSE 54811
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
54785: LD_VAR 0 4
54789: PPUSH
54790: LD_VAR 0 5
54794: PPUSH
54795: LD_VAR 0 4
54799: PPUSH
54800: CALL_OW 74
54804: PPUSH
54805: CALL_OW 112
54809: GO 54835
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
54811: LD_VAR 0 4
54815: PPUSH
54816: LD_VAR 0 5
54820: PPUSH
54821: LD_VAR 0 4
54825: PPUSH
54826: CALL_OW 74
54830: PPUSH
54831: CALL_OW 115
// end ; end ;
54835: GO 54415
54837: POP
54838: POP
// end ;
54839: LD_VAR 0 3
54843: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
54844: LD_INT 0
54846: PPUSH
54847: PPUSH
54848: PPUSH
// if not unit or IsInUnit ( unit ) then
54849: LD_VAR 0 1
54853: NOT
54854: PUSH
54855: LD_VAR 0 1
54859: PPUSH
54860: CALL_OW 310
54864: OR
54865: IFFALSE 54869
// exit ;
54867: GO 54960
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
54869: LD_ADDR_VAR 0 4
54873: PUSH
54874: LD_VAR 0 1
54878: PPUSH
54879: CALL_OW 250
54883: PPUSH
54884: LD_VAR 0 2
54888: PPUSH
54889: LD_INT 1
54891: PPUSH
54892: CALL_OW 272
54896: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
54897: LD_ADDR_VAR 0 5
54901: PUSH
54902: LD_VAR 0 1
54906: PPUSH
54907: CALL_OW 251
54911: PPUSH
54912: LD_VAR 0 2
54916: PPUSH
54917: LD_INT 1
54919: PPUSH
54920: CALL_OW 273
54924: ST_TO_ADDR
// if ValidHex ( x , y ) then
54925: LD_VAR 0 4
54929: PPUSH
54930: LD_VAR 0 5
54934: PPUSH
54935: CALL_OW 488
54939: IFFALSE 54960
// ComTurnXY ( unit , x , y ) ;
54941: LD_VAR 0 1
54945: PPUSH
54946: LD_VAR 0 4
54950: PPUSH
54951: LD_VAR 0 5
54955: PPUSH
54956: CALL_OW 118
// end ;
54960: LD_VAR 0 3
54964: RET
// export function SeeUnits ( side , units ) ; var i ; begin
54965: LD_INT 0
54967: PPUSH
54968: PPUSH
// result := false ;
54969: LD_ADDR_VAR 0 3
54973: PUSH
54974: LD_INT 0
54976: ST_TO_ADDR
// if not units then
54977: LD_VAR 0 2
54981: NOT
54982: IFFALSE 54986
// exit ;
54984: GO 55031
// for i in units do
54986: LD_ADDR_VAR 0 4
54990: PUSH
54991: LD_VAR 0 2
54995: PUSH
54996: FOR_IN
54997: IFFALSE 55029
// if See ( side , i ) then
54999: LD_VAR 0 1
55003: PPUSH
55004: LD_VAR 0 4
55008: PPUSH
55009: CALL_OW 292
55013: IFFALSE 55027
// begin result := true ;
55015: LD_ADDR_VAR 0 3
55019: PUSH
55020: LD_INT 1
55022: ST_TO_ADDR
// exit ;
55023: POP
55024: POP
55025: GO 55031
// end ;
55027: GO 54996
55029: POP
55030: POP
// end ;
55031: LD_VAR 0 3
55035: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
55036: LD_INT 0
55038: PPUSH
55039: PPUSH
55040: PPUSH
55041: PPUSH
// if not unit or not points then
55042: LD_VAR 0 1
55046: NOT
55047: PUSH
55048: LD_VAR 0 2
55052: NOT
55053: OR
55054: IFFALSE 55058
// exit ;
55056: GO 55148
// dist := 99999 ;
55058: LD_ADDR_VAR 0 5
55062: PUSH
55063: LD_INT 99999
55065: ST_TO_ADDR
// for i in points do
55066: LD_ADDR_VAR 0 4
55070: PUSH
55071: LD_VAR 0 2
55075: PUSH
55076: FOR_IN
55077: IFFALSE 55146
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
55079: LD_ADDR_VAR 0 6
55083: PUSH
55084: LD_VAR 0 1
55088: PPUSH
55089: LD_VAR 0 4
55093: PUSH
55094: LD_INT 1
55096: ARRAY
55097: PPUSH
55098: LD_VAR 0 4
55102: PUSH
55103: LD_INT 2
55105: ARRAY
55106: PPUSH
55107: CALL_OW 297
55111: ST_TO_ADDR
// if tmpDist < dist then
55112: LD_VAR 0 6
55116: PUSH
55117: LD_VAR 0 5
55121: LESS
55122: IFFALSE 55144
// begin result := i ;
55124: LD_ADDR_VAR 0 3
55128: PUSH
55129: LD_VAR 0 4
55133: ST_TO_ADDR
// dist := tmpDist ;
55134: LD_ADDR_VAR 0 5
55138: PUSH
55139: LD_VAR 0 6
55143: ST_TO_ADDR
// end ; end ;
55144: GO 55076
55146: POP
55147: POP
// end ;
55148: LD_VAR 0 3
55152: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
55153: LD_INT 0
55155: PPUSH
// uc_side := side ;
55156: LD_ADDR_OWVAR 20
55160: PUSH
55161: LD_VAR 0 1
55165: ST_TO_ADDR
// uc_nation := 3 ;
55166: LD_ADDR_OWVAR 21
55170: PUSH
55171: LD_INT 3
55173: ST_TO_ADDR
// vc_chassis := 25 ;
55174: LD_ADDR_OWVAR 37
55178: PUSH
55179: LD_INT 25
55181: ST_TO_ADDR
// vc_engine := engine_siberite ;
55182: LD_ADDR_OWVAR 39
55186: PUSH
55187: LD_INT 3
55189: ST_TO_ADDR
// vc_control := control_computer ;
55190: LD_ADDR_OWVAR 38
55194: PUSH
55195: LD_INT 3
55197: ST_TO_ADDR
// vc_weapon := 59 ;
55198: LD_ADDR_OWVAR 40
55202: PUSH
55203: LD_INT 59
55205: ST_TO_ADDR
// result := CreateVehicle ;
55206: LD_ADDR_VAR 0 5
55210: PUSH
55211: CALL_OW 45
55215: ST_TO_ADDR
// SetDir ( result , d ) ;
55216: LD_VAR 0 5
55220: PPUSH
55221: LD_VAR 0 4
55225: PPUSH
55226: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
55230: LD_VAR 0 5
55234: PPUSH
55235: LD_VAR 0 2
55239: PPUSH
55240: LD_VAR 0 3
55244: PPUSH
55245: LD_INT 0
55247: PPUSH
55248: CALL_OW 48
// end ;
55252: LD_VAR 0 5
55256: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
55257: LD_INT 0
55259: PPUSH
55260: PPUSH
55261: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
55262: LD_ADDR_VAR 0 2
55266: PUSH
55267: LD_INT 0
55269: PUSH
55270: LD_INT 0
55272: PUSH
55273: LD_INT 0
55275: PUSH
55276: LD_INT 0
55278: PUSH
55279: EMPTY
55280: LIST
55281: LIST
55282: LIST
55283: LIST
55284: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
55285: LD_VAR 0 1
55289: NOT
55290: PUSH
55291: LD_VAR 0 1
55295: PPUSH
55296: CALL_OW 264
55300: PUSH
55301: LD_INT 12
55303: PUSH
55304: LD_INT 51
55306: PUSH
55307: LD_INT 32
55309: PUSH
55310: LD_EXP 105
55314: PUSH
55315: EMPTY
55316: LIST
55317: LIST
55318: LIST
55319: LIST
55320: IN
55321: NOT
55322: OR
55323: IFFALSE 55327
// exit ;
55325: GO 55425
// for i := 1 to 3 do
55327: LD_ADDR_VAR 0 3
55331: PUSH
55332: DOUBLE
55333: LD_INT 1
55335: DEC
55336: ST_TO_ADDR
55337: LD_INT 3
55339: PUSH
55340: FOR_TO
55341: IFFALSE 55423
// begin tmp := GetCargo ( cargo , i ) ;
55343: LD_ADDR_VAR 0 4
55347: PUSH
55348: LD_VAR 0 1
55352: PPUSH
55353: LD_VAR 0 3
55357: PPUSH
55358: CALL_OW 289
55362: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
55363: LD_ADDR_VAR 0 2
55367: PUSH
55368: LD_VAR 0 2
55372: PPUSH
55373: LD_VAR 0 3
55377: PPUSH
55378: LD_VAR 0 4
55382: PPUSH
55383: CALL_OW 1
55387: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
55388: LD_ADDR_VAR 0 2
55392: PUSH
55393: LD_VAR 0 2
55397: PPUSH
55398: LD_INT 4
55400: PPUSH
55401: LD_VAR 0 2
55405: PUSH
55406: LD_INT 4
55408: ARRAY
55409: PUSH
55410: LD_VAR 0 4
55414: PLUS
55415: PPUSH
55416: CALL_OW 1
55420: ST_TO_ADDR
// end ;
55421: GO 55340
55423: POP
55424: POP
// end ;
55425: LD_VAR 0 2
55429: RET
// export function Length ( array ) ; begin
55430: LD_INT 0
55432: PPUSH
// result := array + 0 ;
55433: LD_ADDR_VAR 0 2
55437: PUSH
55438: LD_VAR 0 1
55442: PUSH
55443: LD_INT 0
55445: PLUS
55446: ST_TO_ADDR
// end ; end_of_file
55447: LD_VAR 0 2
55451: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
55452: LD_INT 0
55454: PPUSH
55455: PPUSH
// skirmish := false ;
55456: LD_ADDR_EXP 58
55460: PUSH
55461: LD_INT 0
55463: ST_TO_ADDR
// debug_mc := false ;
55464: LD_ADDR_EXP 59
55468: PUSH
55469: LD_INT 0
55471: ST_TO_ADDR
// mc_bases := [ ] ;
55472: LD_ADDR_EXP 60
55476: PUSH
55477: EMPTY
55478: ST_TO_ADDR
// mc_sides := [ ] ;
55479: LD_ADDR_EXP 86
55483: PUSH
55484: EMPTY
55485: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
55486: LD_ADDR_EXP 61
55490: PUSH
55491: EMPTY
55492: ST_TO_ADDR
// mc_building_repairs := [ ] ;
55493: LD_ADDR_EXP 62
55497: PUSH
55498: EMPTY
55499: ST_TO_ADDR
// mc_need_heal := [ ] ;
55500: LD_ADDR_EXP 63
55504: PUSH
55505: EMPTY
55506: ST_TO_ADDR
// mc_healers := [ ] ;
55507: LD_ADDR_EXP 64
55511: PUSH
55512: EMPTY
55513: ST_TO_ADDR
// mc_build_list := [ ] ;
55514: LD_ADDR_EXP 65
55518: PUSH
55519: EMPTY
55520: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
55521: LD_ADDR_EXP 92
55525: PUSH
55526: EMPTY
55527: ST_TO_ADDR
// mc_builders := [ ] ;
55528: LD_ADDR_EXP 66
55532: PUSH
55533: EMPTY
55534: ST_TO_ADDR
// mc_construct_list := [ ] ;
55535: LD_ADDR_EXP 67
55539: PUSH
55540: EMPTY
55541: ST_TO_ADDR
// mc_turret_list := [ ] ;
55542: LD_ADDR_EXP 68
55546: PUSH
55547: EMPTY
55548: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
55549: LD_ADDR_EXP 69
55553: PUSH
55554: EMPTY
55555: ST_TO_ADDR
// mc_miners := [ ] ;
55556: LD_ADDR_EXP 74
55560: PUSH
55561: EMPTY
55562: ST_TO_ADDR
// mc_mines := [ ] ;
55563: LD_ADDR_EXP 73
55567: PUSH
55568: EMPTY
55569: ST_TO_ADDR
// mc_minefields := [ ] ;
55570: LD_ADDR_EXP 75
55574: PUSH
55575: EMPTY
55576: ST_TO_ADDR
// mc_crates := [ ] ;
55577: LD_ADDR_EXP 76
55581: PUSH
55582: EMPTY
55583: ST_TO_ADDR
// mc_crates_collector := [ ] ;
55584: LD_ADDR_EXP 77
55588: PUSH
55589: EMPTY
55590: ST_TO_ADDR
// mc_crates_area := [ ] ;
55591: LD_ADDR_EXP 78
55595: PUSH
55596: EMPTY
55597: ST_TO_ADDR
// mc_vehicles := [ ] ;
55598: LD_ADDR_EXP 79
55602: PUSH
55603: EMPTY
55604: ST_TO_ADDR
// mc_attack := [ ] ;
55605: LD_ADDR_EXP 80
55609: PUSH
55610: EMPTY
55611: ST_TO_ADDR
// mc_produce := [ ] ;
55612: LD_ADDR_EXP 81
55616: PUSH
55617: EMPTY
55618: ST_TO_ADDR
// mc_defender := [ ] ;
55619: LD_ADDR_EXP 82
55623: PUSH
55624: EMPTY
55625: ST_TO_ADDR
// mc_parking := [ ] ;
55626: LD_ADDR_EXP 84
55630: PUSH
55631: EMPTY
55632: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
55633: LD_ADDR_EXP 70
55637: PUSH
55638: EMPTY
55639: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
55640: LD_ADDR_EXP 72
55644: PUSH
55645: EMPTY
55646: ST_TO_ADDR
// mc_scan := [ ] ;
55647: LD_ADDR_EXP 83
55651: PUSH
55652: EMPTY
55653: ST_TO_ADDR
// mc_scan_area := [ ] ;
55654: LD_ADDR_EXP 85
55658: PUSH
55659: EMPTY
55660: ST_TO_ADDR
// mc_tech := [ ] ;
55661: LD_ADDR_EXP 87
55665: PUSH
55666: EMPTY
55667: ST_TO_ADDR
// mc_class := [ ] ;
55668: LD_ADDR_EXP 101
55672: PUSH
55673: EMPTY
55674: ST_TO_ADDR
// mc_class_case_use := [ ] ;
55675: LD_ADDR_EXP 102
55679: PUSH
55680: EMPTY
55681: ST_TO_ADDR
// mc_is_defending := [ ] ;
55682: LD_ADDR_EXP 103
55686: PUSH
55687: EMPTY
55688: ST_TO_ADDR
// end ;
55689: LD_VAR 0 1
55693: RET
// export function MC_Kill ( base ) ; begin
55694: LD_INT 0
55696: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
55697: LD_ADDR_EXP 60
55701: PUSH
55702: LD_EXP 60
55706: PPUSH
55707: LD_VAR 0 1
55711: PPUSH
55712: EMPTY
55713: PPUSH
55714: CALL_OW 1
55718: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55719: LD_ADDR_EXP 61
55723: PUSH
55724: LD_EXP 61
55728: PPUSH
55729: LD_VAR 0 1
55733: PPUSH
55734: EMPTY
55735: PPUSH
55736: CALL_OW 1
55740: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55741: LD_ADDR_EXP 62
55745: PUSH
55746: LD_EXP 62
55750: PPUSH
55751: LD_VAR 0 1
55755: PPUSH
55756: EMPTY
55757: PPUSH
55758: CALL_OW 1
55762: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55763: LD_ADDR_EXP 63
55767: PUSH
55768: LD_EXP 63
55772: PPUSH
55773: LD_VAR 0 1
55777: PPUSH
55778: EMPTY
55779: PPUSH
55780: CALL_OW 1
55784: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55785: LD_ADDR_EXP 64
55789: PUSH
55790: LD_EXP 64
55794: PPUSH
55795: LD_VAR 0 1
55799: PPUSH
55800: EMPTY
55801: PPUSH
55802: CALL_OW 1
55806: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55807: LD_ADDR_EXP 65
55811: PUSH
55812: LD_EXP 65
55816: PPUSH
55817: LD_VAR 0 1
55821: PPUSH
55822: EMPTY
55823: PPUSH
55824: CALL_OW 1
55828: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55829: LD_ADDR_EXP 66
55833: PUSH
55834: LD_EXP 66
55838: PPUSH
55839: LD_VAR 0 1
55843: PPUSH
55844: EMPTY
55845: PPUSH
55846: CALL_OW 1
55850: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55851: LD_ADDR_EXP 67
55855: PUSH
55856: LD_EXP 67
55860: PPUSH
55861: LD_VAR 0 1
55865: PPUSH
55866: EMPTY
55867: PPUSH
55868: CALL_OW 1
55872: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55873: LD_ADDR_EXP 68
55877: PUSH
55878: LD_EXP 68
55882: PPUSH
55883: LD_VAR 0 1
55887: PPUSH
55888: EMPTY
55889: PPUSH
55890: CALL_OW 1
55894: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55895: LD_ADDR_EXP 69
55899: PUSH
55900: LD_EXP 69
55904: PPUSH
55905: LD_VAR 0 1
55909: PPUSH
55910: EMPTY
55911: PPUSH
55912: CALL_OW 1
55916: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55917: LD_ADDR_EXP 70
55921: PUSH
55922: LD_EXP 70
55926: PPUSH
55927: LD_VAR 0 1
55931: PPUSH
55932: EMPTY
55933: PPUSH
55934: CALL_OW 1
55938: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55939: LD_ADDR_EXP 71
55943: PUSH
55944: LD_EXP 71
55948: PPUSH
55949: LD_VAR 0 1
55953: PPUSH
55954: LD_INT 0
55956: PPUSH
55957: CALL_OW 1
55961: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55962: LD_ADDR_EXP 72
55966: PUSH
55967: LD_EXP 72
55971: PPUSH
55972: LD_VAR 0 1
55976: PPUSH
55977: EMPTY
55978: PPUSH
55979: CALL_OW 1
55983: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55984: LD_ADDR_EXP 73
55988: PUSH
55989: LD_EXP 73
55993: PPUSH
55994: LD_VAR 0 1
55998: PPUSH
55999: EMPTY
56000: PPUSH
56001: CALL_OW 1
56005: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56006: LD_ADDR_EXP 74
56010: PUSH
56011: LD_EXP 74
56015: PPUSH
56016: LD_VAR 0 1
56020: PPUSH
56021: EMPTY
56022: PPUSH
56023: CALL_OW 1
56027: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56028: LD_ADDR_EXP 75
56032: PUSH
56033: LD_EXP 75
56037: PPUSH
56038: LD_VAR 0 1
56042: PPUSH
56043: EMPTY
56044: PPUSH
56045: CALL_OW 1
56049: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56050: LD_ADDR_EXP 76
56054: PUSH
56055: LD_EXP 76
56059: PPUSH
56060: LD_VAR 0 1
56064: PPUSH
56065: EMPTY
56066: PPUSH
56067: CALL_OW 1
56071: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56072: LD_ADDR_EXP 77
56076: PUSH
56077: LD_EXP 77
56081: PPUSH
56082: LD_VAR 0 1
56086: PPUSH
56087: EMPTY
56088: PPUSH
56089: CALL_OW 1
56093: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56094: LD_ADDR_EXP 78
56098: PUSH
56099: LD_EXP 78
56103: PPUSH
56104: LD_VAR 0 1
56108: PPUSH
56109: EMPTY
56110: PPUSH
56111: CALL_OW 1
56115: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56116: LD_ADDR_EXP 79
56120: PUSH
56121: LD_EXP 79
56125: PPUSH
56126: LD_VAR 0 1
56130: PPUSH
56131: EMPTY
56132: PPUSH
56133: CALL_OW 1
56137: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56138: LD_ADDR_EXP 80
56142: PUSH
56143: LD_EXP 80
56147: PPUSH
56148: LD_VAR 0 1
56152: PPUSH
56153: EMPTY
56154: PPUSH
56155: CALL_OW 1
56159: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56160: LD_ADDR_EXP 81
56164: PUSH
56165: LD_EXP 81
56169: PPUSH
56170: LD_VAR 0 1
56174: PPUSH
56175: EMPTY
56176: PPUSH
56177: CALL_OW 1
56181: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56182: LD_ADDR_EXP 82
56186: PUSH
56187: LD_EXP 82
56191: PPUSH
56192: LD_VAR 0 1
56196: PPUSH
56197: EMPTY
56198: PPUSH
56199: CALL_OW 1
56203: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56204: LD_ADDR_EXP 83
56208: PUSH
56209: LD_EXP 83
56213: PPUSH
56214: LD_VAR 0 1
56218: PPUSH
56219: EMPTY
56220: PPUSH
56221: CALL_OW 1
56225: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56226: LD_ADDR_EXP 84
56230: PUSH
56231: LD_EXP 84
56235: PPUSH
56236: LD_VAR 0 1
56240: PPUSH
56241: EMPTY
56242: PPUSH
56243: CALL_OW 1
56247: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56248: LD_ADDR_EXP 85
56252: PUSH
56253: LD_EXP 85
56257: PPUSH
56258: LD_VAR 0 1
56262: PPUSH
56263: EMPTY
56264: PPUSH
56265: CALL_OW 1
56269: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56270: LD_ADDR_EXP 87
56274: PUSH
56275: LD_EXP 87
56279: PPUSH
56280: LD_VAR 0 1
56284: PPUSH
56285: EMPTY
56286: PPUSH
56287: CALL_OW 1
56291: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56292: LD_ADDR_EXP 89
56296: PUSH
56297: LD_EXP 89
56301: PPUSH
56302: LD_VAR 0 1
56306: PPUSH
56307: EMPTY
56308: PPUSH
56309: CALL_OW 1
56313: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56314: LD_ADDR_EXP 90
56318: PUSH
56319: LD_EXP 90
56323: PPUSH
56324: LD_VAR 0 1
56328: PPUSH
56329: EMPTY
56330: PPUSH
56331: CALL_OW 1
56335: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56336: LD_ADDR_EXP 91
56340: PUSH
56341: LD_EXP 91
56345: PPUSH
56346: LD_VAR 0 1
56350: PPUSH
56351: EMPTY
56352: PPUSH
56353: CALL_OW 1
56357: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56358: LD_ADDR_EXP 92
56362: PUSH
56363: LD_EXP 92
56367: PPUSH
56368: LD_VAR 0 1
56372: PPUSH
56373: EMPTY
56374: PPUSH
56375: CALL_OW 1
56379: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56380: LD_ADDR_EXP 93
56384: PUSH
56385: LD_EXP 93
56389: PPUSH
56390: LD_VAR 0 1
56394: PPUSH
56395: EMPTY
56396: PPUSH
56397: CALL_OW 1
56401: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56402: LD_ADDR_EXP 94
56406: PUSH
56407: LD_EXP 94
56411: PPUSH
56412: LD_VAR 0 1
56416: PPUSH
56417: EMPTY
56418: PPUSH
56419: CALL_OW 1
56423: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56424: LD_ADDR_EXP 95
56428: PUSH
56429: LD_EXP 95
56433: PPUSH
56434: LD_VAR 0 1
56438: PPUSH
56439: EMPTY
56440: PPUSH
56441: CALL_OW 1
56445: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56446: LD_ADDR_EXP 96
56450: PUSH
56451: LD_EXP 96
56455: PPUSH
56456: LD_VAR 0 1
56460: PPUSH
56461: EMPTY
56462: PPUSH
56463: CALL_OW 1
56467: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56468: LD_ADDR_EXP 97
56472: PUSH
56473: LD_EXP 97
56477: PPUSH
56478: LD_VAR 0 1
56482: PPUSH
56483: EMPTY
56484: PPUSH
56485: CALL_OW 1
56489: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56490: LD_ADDR_EXP 98
56494: PUSH
56495: LD_EXP 98
56499: PPUSH
56500: LD_VAR 0 1
56504: PPUSH
56505: EMPTY
56506: PPUSH
56507: CALL_OW 1
56511: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56512: LD_ADDR_EXP 99
56516: PUSH
56517: LD_EXP 99
56521: PPUSH
56522: LD_VAR 0 1
56526: PPUSH
56527: EMPTY
56528: PPUSH
56529: CALL_OW 1
56533: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56534: LD_ADDR_EXP 100
56538: PUSH
56539: LD_EXP 100
56543: PPUSH
56544: LD_VAR 0 1
56548: PPUSH
56549: EMPTY
56550: PPUSH
56551: CALL_OW 1
56555: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56556: LD_ADDR_EXP 101
56560: PUSH
56561: LD_EXP 101
56565: PPUSH
56566: LD_VAR 0 1
56570: PPUSH
56571: EMPTY
56572: PPUSH
56573: CALL_OW 1
56577: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56578: LD_ADDR_EXP 102
56582: PUSH
56583: LD_EXP 102
56587: PPUSH
56588: LD_VAR 0 1
56592: PPUSH
56593: LD_INT 0
56595: PPUSH
56596: CALL_OW 1
56600: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56601: LD_ADDR_EXP 103
56605: PUSH
56606: LD_EXP 103
56610: PPUSH
56611: LD_VAR 0 1
56615: PPUSH
56616: LD_INT 0
56618: PPUSH
56619: CALL_OW 1
56623: ST_TO_ADDR
// end ;
56624: LD_VAR 0 2
56628: RET
// export function MC_Add ( side , units ) ; var base ; begin
56629: LD_INT 0
56631: PPUSH
56632: PPUSH
// base := mc_bases + 1 ;
56633: LD_ADDR_VAR 0 4
56637: PUSH
56638: LD_EXP 60
56642: PUSH
56643: LD_INT 1
56645: PLUS
56646: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
56647: LD_ADDR_EXP 86
56651: PUSH
56652: LD_EXP 86
56656: PPUSH
56657: LD_VAR 0 4
56661: PPUSH
56662: LD_VAR 0 1
56666: PPUSH
56667: CALL_OW 1
56671: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
56672: LD_ADDR_EXP 60
56676: PUSH
56677: LD_EXP 60
56681: PPUSH
56682: LD_VAR 0 4
56686: PPUSH
56687: LD_VAR 0 2
56691: PPUSH
56692: CALL_OW 1
56696: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56697: LD_ADDR_EXP 61
56701: PUSH
56702: LD_EXP 61
56706: PPUSH
56707: LD_VAR 0 4
56711: PPUSH
56712: EMPTY
56713: PPUSH
56714: CALL_OW 1
56718: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56719: LD_ADDR_EXP 62
56723: PUSH
56724: LD_EXP 62
56728: PPUSH
56729: LD_VAR 0 4
56733: PPUSH
56734: EMPTY
56735: PPUSH
56736: CALL_OW 1
56740: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56741: LD_ADDR_EXP 63
56745: PUSH
56746: LD_EXP 63
56750: PPUSH
56751: LD_VAR 0 4
56755: PPUSH
56756: EMPTY
56757: PPUSH
56758: CALL_OW 1
56762: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56763: LD_ADDR_EXP 64
56767: PUSH
56768: LD_EXP 64
56772: PPUSH
56773: LD_VAR 0 4
56777: PPUSH
56778: EMPTY
56779: PPUSH
56780: CALL_OW 1
56784: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56785: LD_ADDR_EXP 65
56789: PUSH
56790: LD_EXP 65
56794: PPUSH
56795: LD_VAR 0 4
56799: PPUSH
56800: EMPTY
56801: PPUSH
56802: CALL_OW 1
56806: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56807: LD_ADDR_EXP 66
56811: PUSH
56812: LD_EXP 66
56816: PPUSH
56817: LD_VAR 0 4
56821: PPUSH
56822: EMPTY
56823: PPUSH
56824: CALL_OW 1
56828: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56829: LD_ADDR_EXP 67
56833: PUSH
56834: LD_EXP 67
56838: PPUSH
56839: LD_VAR 0 4
56843: PPUSH
56844: EMPTY
56845: PPUSH
56846: CALL_OW 1
56850: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56851: LD_ADDR_EXP 68
56855: PUSH
56856: LD_EXP 68
56860: PPUSH
56861: LD_VAR 0 4
56865: PPUSH
56866: EMPTY
56867: PPUSH
56868: CALL_OW 1
56872: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56873: LD_ADDR_EXP 69
56877: PUSH
56878: LD_EXP 69
56882: PPUSH
56883: LD_VAR 0 4
56887: PPUSH
56888: EMPTY
56889: PPUSH
56890: CALL_OW 1
56894: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56895: LD_ADDR_EXP 70
56899: PUSH
56900: LD_EXP 70
56904: PPUSH
56905: LD_VAR 0 4
56909: PPUSH
56910: EMPTY
56911: PPUSH
56912: CALL_OW 1
56916: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56917: LD_ADDR_EXP 71
56921: PUSH
56922: LD_EXP 71
56926: PPUSH
56927: LD_VAR 0 4
56931: PPUSH
56932: LD_INT 0
56934: PPUSH
56935: CALL_OW 1
56939: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56940: LD_ADDR_EXP 72
56944: PUSH
56945: LD_EXP 72
56949: PPUSH
56950: LD_VAR 0 4
56954: PPUSH
56955: EMPTY
56956: PPUSH
56957: CALL_OW 1
56961: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56962: LD_ADDR_EXP 73
56966: PUSH
56967: LD_EXP 73
56971: PPUSH
56972: LD_VAR 0 4
56976: PPUSH
56977: EMPTY
56978: PPUSH
56979: CALL_OW 1
56983: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56984: LD_ADDR_EXP 74
56988: PUSH
56989: LD_EXP 74
56993: PPUSH
56994: LD_VAR 0 4
56998: PPUSH
56999: EMPTY
57000: PPUSH
57001: CALL_OW 1
57005: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57006: LD_ADDR_EXP 75
57010: PUSH
57011: LD_EXP 75
57015: PPUSH
57016: LD_VAR 0 4
57020: PPUSH
57021: EMPTY
57022: PPUSH
57023: CALL_OW 1
57027: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57028: LD_ADDR_EXP 76
57032: PUSH
57033: LD_EXP 76
57037: PPUSH
57038: LD_VAR 0 4
57042: PPUSH
57043: EMPTY
57044: PPUSH
57045: CALL_OW 1
57049: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57050: LD_ADDR_EXP 77
57054: PUSH
57055: LD_EXP 77
57059: PPUSH
57060: LD_VAR 0 4
57064: PPUSH
57065: EMPTY
57066: PPUSH
57067: CALL_OW 1
57071: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57072: LD_ADDR_EXP 78
57076: PUSH
57077: LD_EXP 78
57081: PPUSH
57082: LD_VAR 0 4
57086: PPUSH
57087: EMPTY
57088: PPUSH
57089: CALL_OW 1
57093: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57094: LD_ADDR_EXP 79
57098: PUSH
57099: LD_EXP 79
57103: PPUSH
57104: LD_VAR 0 4
57108: PPUSH
57109: EMPTY
57110: PPUSH
57111: CALL_OW 1
57115: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57116: LD_ADDR_EXP 80
57120: PUSH
57121: LD_EXP 80
57125: PPUSH
57126: LD_VAR 0 4
57130: PPUSH
57131: EMPTY
57132: PPUSH
57133: CALL_OW 1
57137: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57138: LD_ADDR_EXP 81
57142: PUSH
57143: LD_EXP 81
57147: PPUSH
57148: LD_VAR 0 4
57152: PPUSH
57153: EMPTY
57154: PPUSH
57155: CALL_OW 1
57159: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57160: LD_ADDR_EXP 82
57164: PUSH
57165: LD_EXP 82
57169: PPUSH
57170: LD_VAR 0 4
57174: PPUSH
57175: EMPTY
57176: PPUSH
57177: CALL_OW 1
57181: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57182: LD_ADDR_EXP 83
57186: PUSH
57187: LD_EXP 83
57191: PPUSH
57192: LD_VAR 0 4
57196: PPUSH
57197: EMPTY
57198: PPUSH
57199: CALL_OW 1
57203: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57204: LD_ADDR_EXP 84
57208: PUSH
57209: LD_EXP 84
57213: PPUSH
57214: LD_VAR 0 4
57218: PPUSH
57219: EMPTY
57220: PPUSH
57221: CALL_OW 1
57225: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57226: LD_ADDR_EXP 85
57230: PUSH
57231: LD_EXP 85
57235: PPUSH
57236: LD_VAR 0 4
57240: PPUSH
57241: EMPTY
57242: PPUSH
57243: CALL_OW 1
57247: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57248: LD_ADDR_EXP 87
57252: PUSH
57253: LD_EXP 87
57257: PPUSH
57258: LD_VAR 0 4
57262: PPUSH
57263: EMPTY
57264: PPUSH
57265: CALL_OW 1
57269: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57270: LD_ADDR_EXP 89
57274: PUSH
57275: LD_EXP 89
57279: PPUSH
57280: LD_VAR 0 4
57284: PPUSH
57285: EMPTY
57286: PPUSH
57287: CALL_OW 1
57291: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57292: LD_ADDR_EXP 90
57296: PUSH
57297: LD_EXP 90
57301: PPUSH
57302: LD_VAR 0 4
57306: PPUSH
57307: EMPTY
57308: PPUSH
57309: CALL_OW 1
57313: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57314: LD_ADDR_EXP 91
57318: PUSH
57319: LD_EXP 91
57323: PPUSH
57324: LD_VAR 0 4
57328: PPUSH
57329: EMPTY
57330: PPUSH
57331: CALL_OW 1
57335: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57336: LD_ADDR_EXP 92
57340: PUSH
57341: LD_EXP 92
57345: PPUSH
57346: LD_VAR 0 4
57350: PPUSH
57351: EMPTY
57352: PPUSH
57353: CALL_OW 1
57357: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57358: LD_ADDR_EXP 93
57362: PUSH
57363: LD_EXP 93
57367: PPUSH
57368: LD_VAR 0 4
57372: PPUSH
57373: EMPTY
57374: PPUSH
57375: CALL_OW 1
57379: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57380: LD_ADDR_EXP 94
57384: PUSH
57385: LD_EXP 94
57389: PPUSH
57390: LD_VAR 0 4
57394: PPUSH
57395: EMPTY
57396: PPUSH
57397: CALL_OW 1
57401: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57402: LD_ADDR_EXP 95
57406: PUSH
57407: LD_EXP 95
57411: PPUSH
57412: LD_VAR 0 4
57416: PPUSH
57417: EMPTY
57418: PPUSH
57419: CALL_OW 1
57423: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57424: LD_ADDR_EXP 96
57428: PUSH
57429: LD_EXP 96
57433: PPUSH
57434: LD_VAR 0 4
57438: PPUSH
57439: EMPTY
57440: PPUSH
57441: CALL_OW 1
57445: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57446: LD_ADDR_EXP 97
57450: PUSH
57451: LD_EXP 97
57455: PPUSH
57456: LD_VAR 0 4
57460: PPUSH
57461: EMPTY
57462: PPUSH
57463: CALL_OW 1
57467: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57468: LD_ADDR_EXP 98
57472: PUSH
57473: LD_EXP 98
57477: PPUSH
57478: LD_VAR 0 4
57482: PPUSH
57483: EMPTY
57484: PPUSH
57485: CALL_OW 1
57489: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57490: LD_ADDR_EXP 99
57494: PUSH
57495: LD_EXP 99
57499: PPUSH
57500: LD_VAR 0 4
57504: PPUSH
57505: EMPTY
57506: PPUSH
57507: CALL_OW 1
57511: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57512: LD_ADDR_EXP 100
57516: PUSH
57517: LD_EXP 100
57521: PPUSH
57522: LD_VAR 0 4
57526: PPUSH
57527: EMPTY
57528: PPUSH
57529: CALL_OW 1
57533: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57534: LD_ADDR_EXP 101
57538: PUSH
57539: LD_EXP 101
57543: PPUSH
57544: LD_VAR 0 4
57548: PPUSH
57549: EMPTY
57550: PPUSH
57551: CALL_OW 1
57555: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57556: LD_ADDR_EXP 102
57560: PUSH
57561: LD_EXP 102
57565: PPUSH
57566: LD_VAR 0 4
57570: PPUSH
57571: LD_INT 0
57573: PPUSH
57574: CALL_OW 1
57578: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57579: LD_ADDR_EXP 103
57583: PUSH
57584: LD_EXP 103
57588: PPUSH
57589: LD_VAR 0 4
57593: PPUSH
57594: LD_INT 0
57596: PPUSH
57597: CALL_OW 1
57601: ST_TO_ADDR
// result := base ;
57602: LD_ADDR_VAR 0 3
57606: PUSH
57607: LD_VAR 0 4
57611: ST_TO_ADDR
// end ;
57612: LD_VAR 0 3
57616: RET
// export function MC_Start ( ) ; var i ; begin
57617: LD_INT 0
57619: PPUSH
57620: PPUSH
// for i = 1 to mc_bases do
57621: LD_ADDR_VAR 0 2
57625: PUSH
57626: DOUBLE
57627: LD_INT 1
57629: DEC
57630: ST_TO_ADDR
57631: LD_EXP 60
57635: PUSH
57636: FOR_TO
57637: IFFALSE 58737
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57639: LD_ADDR_EXP 60
57643: PUSH
57644: LD_EXP 60
57648: PPUSH
57649: LD_VAR 0 2
57653: PPUSH
57654: LD_EXP 60
57658: PUSH
57659: LD_VAR 0 2
57663: ARRAY
57664: PUSH
57665: LD_INT 0
57667: DIFF
57668: PPUSH
57669: CALL_OW 1
57673: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57674: LD_ADDR_EXP 61
57678: PUSH
57679: LD_EXP 61
57683: PPUSH
57684: LD_VAR 0 2
57688: PPUSH
57689: EMPTY
57690: PPUSH
57691: CALL_OW 1
57695: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57696: LD_ADDR_EXP 62
57700: PUSH
57701: LD_EXP 62
57705: PPUSH
57706: LD_VAR 0 2
57710: PPUSH
57711: EMPTY
57712: PPUSH
57713: CALL_OW 1
57717: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57718: LD_ADDR_EXP 63
57722: PUSH
57723: LD_EXP 63
57727: PPUSH
57728: LD_VAR 0 2
57732: PPUSH
57733: EMPTY
57734: PPUSH
57735: CALL_OW 1
57739: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57740: LD_ADDR_EXP 64
57744: PUSH
57745: LD_EXP 64
57749: PPUSH
57750: LD_VAR 0 2
57754: PPUSH
57755: EMPTY
57756: PUSH
57757: EMPTY
57758: PUSH
57759: EMPTY
57760: LIST
57761: LIST
57762: PPUSH
57763: CALL_OW 1
57767: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57768: LD_ADDR_EXP 65
57772: PUSH
57773: LD_EXP 65
57777: PPUSH
57778: LD_VAR 0 2
57782: PPUSH
57783: EMPTY
57784: PPUSH
57785: CALL_OW 1
57789: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57790: LD_ADDR_EXP 92
57794: PUSH
57795: LD_EXP 92
57799: PPUSH
57800: LD_VAR 0 2
57804: PPUSH
57805: EMPTY
57806: PPUSH
57807: CALL_OW 1
57811: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57812: LD_ADDR_EXP 66
57816: PUSH
57817: LD_EXP 66
57821: PPUSH
57822: LD_VAR 0 2
57826: PPUSH
57827: EMPTY
57828: PPUSH
57829: CALL_OW 1
57833: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57834: LD_ADDR_EXP 67
57838: PUSH
57839: LD_EXP 67
57843: PPUSH
57844: LD_VAR 0 2
57848: PPUSH
57849: EMPTY
57850: PPUSH
57851: CALL_OW 1
57855: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57856: LD_ADDR_EXP 68
57860: PUSH
57861: LD_EXP 68
57865: PPUSH
57866: LD_VAR 0 2
57870: PPUSH
57871: LD_EXP 60
57875: PUSH
57876: LD_VAR 0 2
57880: ARRAY
57881: PPUSH
57882: LD_INT 2
57884: PUSH
57885: LD_INT 30
57887: PUSH
57888: LD_INT 32
57890: PUSH
57891: EMPTY
57892: LIST
57893: LIST
57894: PUSH
57895: LD_INT 30
57897: PUSH
57898: LD_INT 33
57900: PUSH
57901: EMPTY
57902: LIST
57903: LIST
57904: PUSH
57905: EMPTY
57906: LIST
57907: LIST
57908: LIST
57909: PPUSH
57910: CALL_OW 72
57914: PPUSH
57915: CALL_OW 1
57919: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57920: LD_ADDR_EXP 69
57924: PUSH
57925: LD_EXP 69
57929: PPUSH
57930: LD_VAR 0 2
57934: PPUSH
57935: LD_EXP 60
57939: PUSH
57940: LD_VAR 0 2
57944: ARRAY
57945: PPUSH
57946: LD_INT 2
57948: PUSH
57949: LD_INT 30
57951: PUSH
57952: LD_INT 32
57954: PUSH
57955: EMPTY
57956: LIST
57957: LIST
57958: PUSH
57959: LD_INT 30
57961: PUSH
57962: LD_INT 31
57964: PUSH
57965: EMPTY
57966: LIST
57967: LIST
57968: PUSH
57969: EMPTY
57970: LIST
57971: LIST
57972: LIST
57973: PUSH
57974: LD_INT 58
57976: PUSH
57977: EMPTY
57978: LIST
57979: PUSH
57980: EMPTY
57981: LIST
57982: LIST
57983: PPUSH
57984: CALL_OW 72
57988: PPUSH
57989: CALL_OW 1
57993: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57994: LD_ADDR_EXP 70
57998: PUSH
57999: LD_EXP 70
58003: PPUSH
58004: LD_VAR 0 2
58008: PPUSH
58009: EMPTY
58010: PPUSH
58011: CALL_OW 1
58015: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
58016: LD_ADDR_EXP 74
58020: PUSH
58021: LD_EXP 74
58025: PPUSH
58026: LD_VAR 0 2
58030: PPUSH
58031: EMPTY
58032: PPUSH
58033: CALL_OW 1
58037: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
58038: LD_ADDR_EXP 73
58042: PUSH
58043: LD_EXP 73
58047: PPUSH
58048: LD_VAR 0 2
58052: PPUSH
58053: EMPTY
58054: PPUSH
58055: CALL_OW 1
58059: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
58060: LD_ADDR_EXP 75
58064: PUSH
58065: LD_EXP 75
58069: PPUSH
58070: LD_VAR 0 2
58074: PPUSH
58075: EMPTY
58076: PPUSH
58077: CALL_OW 1
58081: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
58082: LD_ADDR_EXP 76
58086: PUSH
58087: LD_EXP 76
58091: PPUSH
58092: LD_VAR 0 2
58096: PPUSH
58097: EMPTY
58098: PPUSH
58099: CALL_OW 1
58103: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
58104: LD_ADDR_EXP 77
58108: PUSH
58109: LD_EXP 77
58113: PPUSH
58114: LD_VAR 0 2
58118: PPUSH
58119: EMPTY
58120: PPUSH
58121: CALL_OW 1
58125: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
58126: LD_ADDR_EXP 78
58130: PUSH
58131: LD_EXP 78
58135: PPUSH
58136: LD_VAR 0 2
58140: PPUSH
58141: EMPTY
58142: PPUSH
58143: CALL_OW 1
58147: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
58148: LD_ADDR_EXP 79
58152: PUSH
58153: LD_EXP 79
58157: PPUSH
58158: LD_VAR 0 2
58162: PPUSH
58163: EMPTY
58164: PPUSH
58165: CALL_OW 1
58169: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
58170: LD_ADDR_EXP 80
58174: PUSH
58175: LD_EXP 80
58179: PPUSH
58180: LD_VAR 0 2
58184: PPUSH
58185: EMPTY
58186: PPUSH
58187: CALL_OW 1
58191: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
58192: LD_ADDR_EXP 81
58196: PUSH
58197: LD_EXP 81
58201: PPUSH
58202: LD_VAR 0 2
58206: PPUSH
58207: EMPTY
58208: PPUSH
58209: CALL_OW 1
58213: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
58214: LD_ADDR_EXP 82
58218: PUSH
58219: LD_EXP 82
58223: PPUSH
58224: LD_VAR 0 2
58228: PPUSH
58229: EMPTY
58230: PPUSH
58231: CALL_OW 1
58235: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
58236: LD_ADDR_EXP 71
58240: PUSH
58241: LD_EXP 71
58245: PPUSH
58246: LD_VAR 0 2
58250: PPUSH
58251: LD_INT 0
58253: PPUSH
58254: CALL_OW 1
58258: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
58259: LD_ADDR_EXP 84
58263: PUSH
58264: LD_EXP 84
58268: PPUSH
58269: LD_VAR 0 2
58273: PPUSH
58274: LD_INT 0
58276: PPUSH
58277: CALL_OW 1
58281: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
58282: LD_ADDR_EXP 72
58286: PUSH
58287: LD_EXP 72
58291: PPUSH
58292: LD_VAR 0 2
58296: PPUSH
58297: EMPTY
58298: PPUSH
58299: CALL_OW 1
58303: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
58304: LD_ADDR_EXP 83
58308: PUSH
58309: LD_EXP 83
58313: PPUSH
58314: LD_VAR 0 2
58318: PPUSH
58319: LD_INT 0
58321: PPUSH
58322: CALL_OW 1
58326: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
58327: LD_ADDR_EXP 85
58331: PUSH
58332: LD_EXP 85
58336: PPUSH
58337: LD_VAR 0 2
58341: PPUSH
58342: EMPTY
58343: PPUSH
58344: CALL_OW 1
58348: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
58349: LD_ADDR_EXP 88
58353: PUSH
58354: LD_EXP 88
58358: PPUSH
58359: LD_VAR 0 2
58363: PPUSH
58364: LD_INT 0
58366: PPUSH
58367: CALL_OW 1
58371: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
58372: LD_ADDR_EXP 89
58376: PUSH
58377: LD_EXP 89
58381: PPUSH
58382: LD_VAR 0 2
58386: PPUSH
58387: EMPTY
58388: PPUSH
58389: CALL_OW 1
58393: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
58394: LD_ADDR_EXP 90
58398: PUSH
58399: LD_EXP 90
58403: PPUSH
58404: LD_VAR 0 2
58408: PPUSH
58409: EMPTY
58410: PPUSH
58411: CALL_OW 1
58415: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58416: LD_ADDR_EXP 91
58420: PUSH
58421: LD_EXP 91
58425: PPUSH
58426: LD_VAR 0 2
58430: PPUSH
58431: EMPTY
58432: PPUSH
58433: CALL_OW 1
58437: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
58438: LD_ADDR_EXP 93
58442: PUSH
58443: LD_EXP 93
58447: PPUSH
58448: LD_VAR 0 2
58452: PPUSH
58453: LD_EXP 60
58457: PUSH
58458: LD_VAR 0 2
58462: ARRAY
58463: PPUSH
58464: LD_INT 2
58466: PUSH
58467: LD_INT 30
58469: PUSH
58470: LD_INT 6
58472: PUSH
58473: EMPTY
58474: LIST
58475: LIST
58476: PUSH
58477: LD_INT 30
58479: PUSH
58480: LD_INT 7
58482: PUSH
58483: EMPTY
58484: LIST
58485: LIST
58486: PUSH
58487: LD_INT 30
58489: PUSH
58490: LD_INT 8
58492: PUSH
58493: EMPTY
58494: LIST
58495: LIST
58496: PUSH
58497: EMPTY
58498: LIST
58499: LIST
58500: LIST
58501: LIST
58502: PPUSH
58503: CALL_OW 72
58507: PPUSH
58508: CALL_OW 1
58512: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
58513: LD_ADDR_EXP 94
58517: PUSH
58518: LD_EXP 94
58522: PPUSH
58523: LD_VAR 0 2
58527: PPUSH
58528: EMPTY
58529: PPUSH
58530: CALL_OW 1
58534: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
58535: LD_ADDR_EXP 95
58539: PUSH
58540: LD_EXP 95
58544: PPUSH
58545: LD_VAR 0 2
58549: PPUSH
58550: EMPTY
58551: PPUSH
58552: CALL_OW 1
58556: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
58557: LD_ADDR_EXP 96
58561: PUSH
58562: LD_EXP 96
58566: PPUSH
58567: LD_VAR 0 2
58571: PPUSH
58572: EMPTY
58573: PPUSH
58574: CALL_OW 1
58578: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58579: LD_ADDR_EXP 97
58583: PUSH
58584: LD_EXP 97
58588: PPUSH
58589: LD_VAR 0 2
58593: PPUSH
58594: EMPTY
58595: PPUSH
58596: CALL_OW 1
58600: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58601: LD_ADDR_EXP 98
58605: PUSH
58606: LD_EXP 98
58610: PPUSH
58611: LD_VAR 0 2
58615: PPUSH
58616: EMPTY
58617: PPUSH
58618: CALL_OW 1
58622: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58623: LD_ADDR_EXP 99
58627: PUSH
58628: LD_EXP 99
58632: PPUSH
58633: LD_VAR 0 2
58637: PPUSH
58638: EMPTY
58639: PPUSH
58640: CALL_OW 1
58644: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58645: LD_ADDR_EXP 100
58649: PUSH
58650: LD_EXP 100
58654: PPUSH
58655: LD_VAR 0 2
58659: PPUSH
58660: EMPTY
58661: PPUSH
58662: CALL_OW 1
58666: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58667: LD_ADDR_EXP 101
58671: PUSH
58672: LD_EXP 101
58676: PPUSH
58677: LD_VAR 0 2
58681: PPUSH
58682: EMPTY
58683: PPUSH
58684: CALL_OW 1
58688: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58689: LD_ADDR_EXP 102
58693: PUSH
58694: LD_EXP 102
58698: PPUSH
58699: LD_VAR 0 2
58703: PPUSH
58704: LD_INT 0
58706: PPUSH
58707: CALL_OW 1
58711: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
58712: LD_ADDR_EXP 103
58716: PUSH
58717: LD_EXP 103
58721: PPUSH
58722: LD_VAR 0 2
58726: PPUSH
58727: LD_INT 0
58729: PPUSH
58730: CALL_OW 1
58734: ST_TO_ADDR
// end ;
58735: GO 57636
58737: POP
58738: POP
// MC_InitSides ( ) ;
58739: CALL 59025 0 0
// MC_InitResearch ( ) ;
58743: CALL 58764 0 0
// CustomInitMacro ( ) ;
58747: CALL 206 0 0
// skirmish := true ;
58751: LD_ADDR_EXP 58
58755: PUSH
58756: LD_INT 1
58758: ST_TO_ADDR
// end ;
58759: LD_VAR 0 1
58763: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58764: LD_INT 0
58766: PPUSH
58767: PPUSH
58768: PPUSH
58769: PPUSH
58770: PPUSH
58771: PPUSH
// if not mc_bases then
58772: LD_EXP 60
58776: NOT
58777: IFFALSE 58781
// exit ;
58779: GO 59020
// for i = 1 to 8 do
58781: LD_ADDR_VAR 0 2
58785: PUSH
58786: DOUBLE
58787: LD_INT 1
58789: DEC
58790: ST_TO_ADDR
58791: LD_INT 8
58793: PUSH
58794: FOR_TO
58795: IFFALSE 58821
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58797: LD_ADDR_EXP 87
58801: PUSH
58802: LD_EXP 87
58806: PPUSH
58807: LD_VAR 0 2
58811: PPUSH
58812: EMPTY
58813: PPUSH
58814: CALL_OW 1
58818: ST_TO_ADDR
58819: GO 58794
58821: POP
58822: POP
// tmp := [ ] ;
58823: LD_ADDR_VAR 0 5
58827: PUSH
58828: EMPTY
58829: ST_TO_ADDR
// for i = 1 to mc_sides do
58830: LD_ADDR_VAR 0 2
58834: PUSH
58835: DOUBLE
58836: LD_INT 1
58838: DEC
58839: ST_TO_ADDR
58840: LD_EXP 86
58844: PUSH
58845: FOR_TO
58846: IFFALSE 58904
// if not mc_sides [ i ] in tmp then
58848: LD_EXP 86
58852: PUSH
58853: LD_VAR 0 2
58857: ARRAY
58858: PUSH
58859: LD_VAR 0 5
58863: IN
58864: NOT
58865: IFFALSE 58902
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58867: LD_ADDR_VAR 0 5
58871: PUSH
58872: LD_VAR 0 5
58876: PPUSH
58877: LD_VAR 0 5
58881: PUSH
58882: LD_INT 1
58884: PLUS
58885: PPUSH
58886: LD_EXP 86
58890: PUSH
58891: LD_VAR 0 2
58895: ARRAY
58896: PPUSH
58897: CALL_OW 2
58901: ST_TO_ADDR
58902: GO 58845
58904: POP
58905: POP
// if not tmp then
58906: LD_VAR 0 5
58910: NOT
58911: IFFALSE 58915
// exit ;
58913: GO 59020
// for j in tmp do
58915: LD_ADDR_VAR 0 3
58919: PUSH
58920: LD_VAR 0 5
58924: PUSH
58925: FOR_IN
58926: IFFALSE 59018
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58928: LD_ADDR_VAR 0 6
58932: PUSH
58933: LD_INT 22
58935: PUSH
58936: LD_VAR 0 3
58940: PUSH
58941: EMPTY
58942: LIST
58943: LIST
58944: PPUSH
58945: CALL_OW 69
58949: ST_TO_ADDR
// if not un then
58950: LD_VAR 0 6
58954: NOT
58955: IFFALSE 58959
// continue ;
58957: GO 58925
// nation := GetNation ( un [ 1 ] ) ;
58959: LD_ADDR_VAR 0 4
58963: PUSH
58964: LD_VAR 0 6
58968: PUSH
58969: LD_INT 1
58971: ARRAY
58972: PPUSH
58973: CALL_OW 248
58977: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58978: LD_ADDR_EXP 87
58982: PUSH
58983: LD_EXP 87
58987: PPUSH
58988: LD_VAR 0 3
58992: PPUSH
58993: LD_VAR 0 3
58997: PPUSH
58998: LD_VAR 0 4
59002: PPUSH
59003: LD_INT 1
59005: PPUSH
59006: CALL 14927 0 3
59010: PPUSH
59011: CALL_OW 1
59015: ST_TO_ADDR
// end ;
59016: GO 58925
59018: POP
59019: POP
// end ;
59020: LD_VAR 0 1
59024: RET
// export function MC_InitSides ( ) ; var i ; begin
59025: LD_INT 0
59027: PPUSH
59028: PPUSH
// if not mc_bases then
59029: LD_EXP 60
59033: NOT
59034: IFFALSE 59038
// exit ;
59036: GO 59112
// for i = 1 to mc_bases do
59038: LD_ADDR_VAR 0 2
59042: PUSH
59043: DOUBLE
59044: LD_INT 1
59046: DEC
59047: ST_TO_ADDR
59048: LD_EXP 60
59052: PUSH
59053: FOR_TO
59054: IFFALSE 59110
// if mc_bases [ i ] then
59056: LD_EXP 60
59060: PUSH
59061: LD_VAR 0 2
59065: ARRAY
59066: IFFALSE 59108
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
59068: LD_ADDR_EXP 86
59072: PUSH
59073: LD_EXP 86
59077: PPUSH
59078: LD_VAR 0 2
59082: PPUSH
59083: LD_EXP 60
59087: PUSH
59088: LD_VAR 0 2
59092: ARRAY
59093: PUSH
59094: LD_INT 1
59096: ARRAY
59097: PPUSH
59098: CALL_OW 255
59102: PPUSH
59103: CALL_OW 1
59107: ST_TO_ADDR
59108: GO 59053
59110: POP
59111: POP
// end ;
59112: LD_VAR 0 1
59116: RET
// every 0 0$03 trigger skirmish do
59117: LD_EXP 58
59121: IFFALSE 59275
59123: GO 59125
59125: DISABLE
// begin enable ;
59126: ENABLE
// MC_CheckBuildings ( ) ;
59127: CALL 63773 0 0
// MC_CheckPeopleLife ( ) ;
59131: CALL 63934 0 0
// RaiseSailEvent ( 100 ) ;
59135: LD_INT 100
59137: PPUSH
59138: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
59142: LD_INT 103
59144: PPUSH
59145: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
59149: LD_INT 104
59151: PPUSH
59152: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
59156: LD_INT 105
59158: PPUSH
59159: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
59163: LD_INT 106
59165: PPUSH
59166: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
59170: LD_INT 107
59172: PPUSH
59173: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
59177: LD_INT 108
59179: PPUSH
59180: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
59184: LD_INT 109
59186: PPUSH
59187: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
59191: LD_INT 110
59193: PPUSH
59194: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
59198: LD_INT 111
59200: PPUSH
59201: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
59205: LD_INT 112
59207: PPUSH
59208: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
59212: LD_INT 113
59214: PPUSH
59215: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
59219: LD_INT 120
59221: PPUSH
59222: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
59226: LD_INT 121
59228: PPUSH
59229: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
59233: LD_INT 122
59235: PPUSH
59236: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
59240: LD_INT 123
59242: PPUSH
59243: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
59247: LD_INT 124
59249: PPUSH
59250: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
59254: LD_INT 125
59256: PPUSH
59257: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
59261: LD_INT 126
59263: PPUSH
59264: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
59268: LD_INT 200
59270: PPUSH
59271: CALL_OW 427
// end ;
59275: END
// on SailEvent ( event ) do begin if event < 100 then
59276: LD_VAR 0 1
59280: PUSH
59281: LD_INT 100
59283: LESS
59284: IFFALSE 59295
// CustomEvent ( event ) ;
59286: LD_VAR 0 1
59290: PPUSH
59291: CALL 13542 0 1
// if event = 100 then
59295: LD_VAR 0 1
59299: PUSH
59300: LD_INT 100
59302: EQUAL
59303: IFFALSE 59309
// MC_ClassManager ( ) ;
59305: CALL 59701 0 0
// if event = 101 then
59309: LD_VAR 0 1
59313: PUSH
59314: LD_INT 101
59316: EQUAL
59317: IFFALSE 59323
// MC_RepairBuildings ( ) ;
59319: CALL 64519 0 0
// if event = 102 then
59323: LD_VAR 0 1
59327: PUSH
59328: LD_INT 102
59330: EQUAL
59331: IFFALSE 59337
// MC_Heal ( ) ;
59333: CALL 65426 0 0
// if event = 103 then
59337: LD_VAR 0 1
59341: PUSH
59342: LD_INT 103
59344: EQUAL
59345: IFFALSE 59351
// MC_Build ( ) ;
59347: CALL 65848 0 0
// if event = 104 then
59351: LD_VAR 0 1
59355: PUSH
59356: LD_INT 104
59358: EQUAL
59359: IFFALSE 59365
// MC_TurretWeapon ( ) ;
59361: CALL 67489 0 0
// if event = 105 then
59365: LD_VAR 0 1
59369: PUSH
59370: LD_INT 105
59372: EQUAL
59373: IFFALSE 59379
// MC_BuildUpgrade ( ) ;
59375: CALL 67040 0 0
// if event = 106 then
59379: LD_VAR 0 1
59383: PUSH
59384: LD_INT 106
59386: EQUAL
59387: IFFALSE 59393
// MC_PlantMines ( ) ;
59389: CALL 67919 0 0
// if event = 107 then
59393: LD_VAR 0 1
59397: PUSH
59398: LD_INT 107
59400: EQUAL
59401: IFFALSE 59407
// MC_CollectCrates ( ) ;
59403: CALL 68710 0 0
// if event = 108 then
59407: LD_VAR 0 1
59411: PUSH
59412: LD_INT 108
59414: EQUAL
59415: IFFALSE 59421
// MC_LinkRemoteControl ( ) ;
59417: CALL 70560 0 0
// if event = 109 then
59421: LD_VAR 0 1
59425: PUSH
59426: LD_INT 109
59428: EQUAL
59429: IFFALSE 59435
// MC_ProduceVehicle ( ) ;
59431: CALL 70741 0 0
// if event = 110 then
59435: LD_VAR 0 1
59439: PUSH
59440: LD_INT 110
59442: EQUAL
59443: IFFALSE 59449
// MC_SendAttack ( ) ;
59445: CALL 71207 0 0
// if event = 111 then
59449: LD_VAR 0 1
59453: PUSH
59454: LD_INT 111
59456: EQUAL
59457: IFFALSE 59463
// MC_Defend ( ) ;
59459: CALL 71315 0 0
// if event = 112 then
59463: LD_VAR 0 1
59467: PUSH
59468: LD_INT 112
59470: EQUAL
59471: IFFALSE 59477
// MC_Research ( ) ;
59473: CALL 72195 0 0
// if event = 113 then
59477: LD_VAR 0 1
59481: PUSH
59482: LD_INT 113
59484: EQUAL
59485: IFFALSE 59491
// MC_MinesTrigger ( ) ;
59487: CALL 73309 0 0
// if event = 120 then
59491: LD_VAR 0 1
59495: PUSH
59496: LD_INT 120
59498: EQUAL
59499: IFFALSE 59505
// MC_RepairVehicle ( ) ;
59501: CALL 73408 0 0
// if event = 121 then
59505: LD_VAR 0 1
59509: PUSH
59510: LD_INT 121
59512: EQUAL
59513: IFFALSE 59519
// MC_TameApe ( ) ;
59515: CALL 74149 0 0
// if event = 122 then
59519: LD_VAR 0 1
59523: PUSH
59524: LD_INT 122
59526: EQUAL
59527: IFFALSE 59533
// MC_ChangeApeClass ( ) ;
59529: CALL 74978 0 0
// if event = 123 then
59533: LD_VAR 0 1
59537: PUSH
59538: LD_INT 123
59540: EQUAL
59541: IFFALSE 59547
// MC_Bazooka ( ) ;
59543: CALL 75628 0 0
// if event = 124 then
59547: LD_VAR 0 1
59551: PUSH
59552: LD_INT 124
59554: EQUAL
59555: IFFALSE 59561
// MC_TeleportExit ( ) ;
59557: CALL 75826 0 0
// if event = 125 then
59561: LD_VAR 0 1
59565: PUSH
59566: LD_INT 125
59568: EQUAL
59569: IFFALSE 59575
// MC_Deposits ( ) ;
59571: CALL 76473 0 0
// if event = 126 then
59575: LD_VAR 0 1
59579: PUSH
59580: LD_INT 126
59582: EQUAL
59583: IFFALSE 59589
// MC_RemoteDriver ( ) ;
59585: CALL 77098 0 0
// if event = 200 then
59589: LD_VAR 0 1
59593: PUSH
59594: LD_INT 200
59596: EQUAL
59597: IFFALSE 59603
// MC_Idle ( ) ;
59599: CALL 79047 0 0
// end ;
59603: PPOPN 1
59605: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59606: LD_INT 0
59608: PPUSH
59609: PPUSH
// if not mc_bases [ base ] or not tag then
59610: LD_EXP 60
59614: PUSH
59615: LD_VAR 0 1
59619: ARRAY
59620: NOT
59621: PUSH
59622: LD_VAR 0 2
59626: NOT
59627: OR
59628: IFFALSE 59632
// exit ;
59630: GO 59696
// for i in mc_bases [ base ] union mc_ape [ base ] do
59632: LD_ADDR_VAR 0 4
59636: PUSH
59637: LD_EXP 60
59641: PUSH
59642: LD_VAR 0 1
59646: ARRAY
59647: PUSH
59648: LD_EXP 89
59652: PUSH
59653: LD_VAR 0 1
59657: ARRAY
59658: UNION
59659: PUSH
59660: FOR_IN
59661: IFFALSE 59694
// if GetTag ( i ) = tag then
59663: LD_VAR 0 4
59667: PPUSH
59668: CALL_OW 110
59672: PUSH
59673: LD_VAR 0 2
59677: EQUAL
59678: IFFALSE 59692
// SetTag ( i , 0 ) ;
59680: LD_VAR 0 4
59684: PPUSH
59685: LD_INT 0
59687: PPUSH
59688: CALL_OW 109
59692: GO 59660
59694: POP
59695: POP
// end ;
59696: LD_VAR 0 3
59700: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59701: LD_INT 0
59703: PPUSH
59704: PPUSH
59705: PPUSH
59706: PPUSH
59707: PPUSH
59708: PPUSH
59709: PPUSH
59710: PPUSH
// if not mc_bases then
59711: LD_EXP 60
59715: NOT
59716: IFFALSE 59720
// exit ;
59718: GO 60178
// for i = 1 to mc_bases do
59720: LD_ADDR_VAR 0 2
59724: PUSH
59725: DOUBLE
59726: LD_INT 1
59728: DEC
59729: ST_TO_ADDR
59730: LD_EXP 60
59734: PUSH
59735: FOR_TO
59736: IFFALSE 60176
// begin tmp := MC_ClassCheckReq ( i ) ;
59738: LD_ADDR_VAR 0 4
59742: PUSH
59743: LD_VAR 0 2
59747: PPUSH
59748: CALL 60183 0 1
59752: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59753: LD_ADDR_EXP 101
59757: PUSH
59758: LD_EXP 101
59762: PPUSH
59763: LD_VAR 0 2
59767: PPUSH
59768: LD_VAR 0 4
59772: PPUSH
59773: CALL_OW 1
59777: ST_TO_ADDR
// if not tmp then
59778: LD_VAR 0 4
59782: NOT
59783: IFFALSE 59787
// continue ;
59785: GO 59735
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59787: LD_ADDR_VAR 0 6
59791: PUSH
59792: LD_EXP 60
59796: PUSH
59797: LD_VAR 0 2
59801: ARRAY
59802: PPUSH
59803: LD_INT 2
59805: PUSH
59806: LD_INT 30
59808: PUSH
59809: LD_INT 4
59811: PUSH
59812: EMPTY
59813: LIST
59814: LIST
59815: PUSH
59816: LD_INT 30
59818: PUSH
59819: LD_INT 5
59821: PUSH
59822: EMPTY
59823: LIST
59824: LIST
59825: PUSH
59826: EMPTY
59827: LIST
59828: LIST
59829: LIST
59830: PPUSH
59831: CALL_OW 72
59835: PUSH
59836: LD_EXP 60
59840: PUSH
59841: LD_VAR 0 2
59845: ARRAY
59846: PPUSH
59847: LD_INT 2
59849: PUSH
59850: LD_INT 30
59852: PUSH
59853: LD_INT 0
59855: PUSH
59856: EMPTY
59857: LIST
59858: LIST
59859: PUSH
59860: LD_INT 30
59862: PUSH
59863: LD_INT 1
59865: PUSH
59866: EMPTY
59867: LIST
59868: LIST
59869: PUSH
59870: EMPTY
59871: LIST
59872: LIST
59873: LIST
59874: PPUSH
59875: CALL_OW 72
59879: PUSH
59880: LD_EXP 60
59884: PUSH
59885: LD_VAR 0 2
59889: ARRAY
59890: PPUSH
59891: LD_INT 30
59893: PUSH
59894: LD_INT 3
59896: PUSH
59897: EMPTY
59898: LIST
59899: LIST
59900: PPUSH
59901: CALL_OW 72
59905: PUSH
59906: LD_EXP 60
59910: PUSH
59911: LD_VAR 0 2
59915: ARRAY
59916: PPUSH
59917: LD_INT 2
59919: PUSH
59920: LD_INT 30
59922: PUSH
59923: LD_INT 6
59925: PUSH
59926: EMPTY
59927: LIST
59928: LIST
59929: PUSH
59930: LD_INT 30
59932: PUSH
59933: LD_INT 7
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: PUSH
59940: LD_INT 30
59942: PUSH
59943: LD_INT 8
59945: PUSH
59946: EMPTY
59947: LIST
59948: LIST
59949: PUSH
59950: EMPTY
59951: LIST
59952: LIST
59953: LIST
59954: LIST
59955: PPUSH
59956: CALL_OW 72
59960: PUSH
59961: EMPTY
59962: LIST
59963: LIST
59964: LIST
59965: LIST
59966: ST_TO_ADDR
// for j = 1 to 4 do
59967: LD_ADDR_VAR 0 3
59971: PUSH
59972: DOUBLE
59973: LD_INT 1
59975: DEC
59976: ST_TO_ADDR
59977: LD_INT 4
59979: PUSH
59980: FOR_TO
59981: IFFALSE 60172
// begin if not tmp [ j ] then
59983: LD_VAR 0 4
59987: PUSH
59988: LD_VAR 0 3
59992: ARRAY
59993: NOT
59994: IFFALSE 59998
// continue ;
59996: GO 59980
// for p in tmp [ j ] do
59998: LD_ADDR_VAR 0 5
60002: PUSH
60003: LD_VAR 0 4
60007: PUSH
60008: LD_VAR 0 3
60012: ARRAY
60013: PUSH
60014: FOR_IN
60015: IFFALSE 60168
// begin if not b [ j ] then
60017: LD_VAR 0 6
60021: PUSH
60022: LD_VAR 0 3
60026: ARRAY
60027: NOT
60028: IFFALSE 60032
// break ;
60030: GO 60168
// e := 0 ;
60032: LD_ADDR_VAR 0 7
60036: PUSH
60037: LD_INT 0
60039: ST_TO_ADDR
// for k in b [ j ] do
60040: LD_ADDR_VAR 0 8
60044: PUSH
60045: LD_VAR 0 6
60049: PUSH
60050: LD_VAR 0 3
60054: ARRAY
60055: PUSH
60056: FOR_IN
60057: IFFALSE 60084
// if IsNotFull ( k ) then
60059: LD_VAR 0 8
60063: PPUSH
60064: CALL 17080 0 1
60068: IFFALSE 60082
// begin e := k ;
60070: LD_ADDR_VAR 0 7
60074: PUSH
60075: LD_VAR 0 8
60079: ST_TO_ADDR
// break ;
60080: GO 60084
// end ;
60082: GO 60056
60084: POP
60085: POP
// if e and not UnitGoingToBuilding ( p , e ) then
60086: LD_VAR 0 7
60090: PUSH
60091: LD_VAR 0 5
60095: PPUSH
60096: LD_VAR 0 7
60100: PPUSH
60101: CALL 50344 0 2
60105: NOT
60106: AND
60107: IFFALSE 60166
// begin if IsInUnit ( p ) then
60109: LD_VAR 0 5
60113: PPUSH
60114: CALL_OW 310
60118: IFFALSE 60129
// ComExitBuilding ( p ) ;
60120: LD_VAR 0 5
60124: PPUSH
60125: CALL_OW 122
// ComEnterUnit ( p , e ) ;
60129: LD_VAR 0 5
60133: PPUSH
60134: LD_VAR 0 7
60138: PPUSH
60139: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
60143: LD_VAR 0 5
60147: PPUSH
60148: LD_VAR 0 3
60152: PPUSH
60153: CALL_OW 183
// AddComExitBuilding ( p ) ;
60157: LD_VAR 0 5
60161: PPUSH
60162: CALL_OW 182
// end ; end ;
60166: GO 60014
60168: POP
60169: POP
// end ;
60170: GO 59980
60172: POP
60173: POP
// end ;
60174: GO 59735
60176: POP
60177: POP
// end ;
60178: LD_VAR 0 1
60182: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
60183: LD_INT 0
60185: PPUSH
60186: PPUSH
60187: PPUSH
60188: PPUSH
60189: PPUSH
60190: PPUSH
60191: PPUSH
60192: PPUSH
60193: PPUSH
60194: PPUSH
60195: PPUSH
60196: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60197: LD_VAR 0 1
60201: NOT
60202: PUSH
60203: LD_EXP 60
60207: PUSH
60208: LD_VAR 0 1
60212: ARRAY
60213: NOT
60214: OR
60215: PUSH
60216: LD_EXP 60
60220: PUSH
60221: LD_VAR 0 1
60225: ARRAY
60226: PPUSH
60227: LD_INT 2
60229: PUSH
60230: LD_INT 30
60232: PUSH
60233: LD_INT 0
60235: PUSH
60236: EMPTY
60237: LIST
60238: LIST
60239: PUSH
60240: LD_INT 30
60242: PUSH
60243: LD_INT 1
60245: PUSH
60246: EMPTY
60247: LIST
60248: LIST
60249: PUSH
60250: EMPTY
60251: LIST
60252: LIST
60253: LIST
60254: PPUSH
60255: CALL_OW 72
60259: NOT
60260: OR
60261: IFFALSE 60265
// exit ;
60263: GO 63768
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60265: LD_ADDR_VAR 0 4
60269: PUSH
60270: LD_EXP 60
60274: PUSH
60275: LD_VAR 0 1
60279: ARRAY
60280: PPUSH
60281: LD_INT 2
60283: PUSH
60284: LD_INT 25
60286: PUSH
60287: LD_INT 1
60289: PUSH
60290: EMPTY
60291: LIST
60292: LIST
60293: PUSH
60294: LD_INT 25
60296: PUSH
60297: LD_INT 2
60299: PUSH
60300: EMPTY
60301: LIST
60302: LIST
60303: PUSH
60304: LD_INT 25
60306: PUSH
60307: LD_INT 3
60309: PUSH
60310: EMPTY
60311: LIST
60312: LIST
60313: PUSH
60314: LD_INT 25
60316: PUSH
60317: LD_INT 4
60319: PUSH
60320: EMPTY
60321: LIST
60322: LIST
60323: PUSH
60324: LD_INT 25
60326: PUSH
60327: LD_INT 5
60329: PUSH
60330: EMPTY
60331: LIST
60332: LIST
60333: PUSH
60334: LD_INT 25
60336: PUSH
60337: LD_INT 8
60339: PUSH
60340: EMPTY
60341: LIST
60342: LIST
60343: PUSH
60344: LD_INT 25
60346: PUSH
60347: LD_INT 9
60349: PUSH
60350: EMPTY
60351: LIST
60352: LIST
60353: PUSH
60354: EMPTY
60355: LIST
60356: LIST
60357: LIST
60358: LIST
60359: LIST
60360: LIST
60361: LIST
60362: LIST
60363: PPUSH
60364: CALL_OW 72
60368: ST_TO_ADDR
// if not tmp then
60369: LD_VAR 0 4
60373: NOT
60374: IFFALSE 60378
// exit ;
60376: GO 63768
// for i in tmp do
60378: LD_ADDR_VAR 0 3
60382: PUSH
60383: LD_VAR 0 4
60387: PUSH
60388: FOR_IN
60389: IFFALSE 60420
// if GetTag ( i ) then
60391: LD_VAR 0 3
60395: PPUSH
60396: CALL_OW 110
60400: IFFALSE 60418
// tmp := tmp diff i ;
60402: LD_ADDR_VAR 0 4
60406: PUSH
60407: LD_VAR 0 4
60411: PUSH
60412: LD_VAR 0 3
60416: DIFF
60417: ST_TO_ADDR
60418: GO 60388
60420: POP
60421: POP
// if not tmp then
60422: LD_VAR 0 4
60426: NOT
60427: IFFALSE 60431
// exit ;
60429: GO 63768
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60431: LD_ADDR_VAR 0 5
60435: PUSH
60436: LD_EXP 60
60440: PUSH
60441: LD_VAR 0 1
60445: ARRAY
60446: PPUSH
60447: LD_INT 2
60449: PUSH
60450: LD_INT 25
60452: PUSH
60453: LD_INT 1
60455: PUSH
60456: EMPTY
60457: LIST
60458: LIST
60459: PUSH
60460: LD_INT 25
60462: PUSH
60463: LD_INT 5
60465: PUSH
60466: EMPTY
60467: LIST
60468: LIST
60469: PUSH
60470: LD_INT 25
60472: PUSH
60473: LD_INT 8
60475: PUSH
60476: EMPTY
60477: LIST
60478: LIST
60479: PUSH
60480: LD_INT 25
60482: PUSH
60483: LD_INT 9
60485: PUSH
60486: EMPTY
60487: LIST
60488: LIST
60489: PUSH
60490: EMPTY
60491: LIST
60492: LIST
60493: LIST
60494: LIST
60495: LIST
60496: PPUSH
60497: CALL_OW 72
60501: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
60502: LD_ADDR_VAR 0 6
60506: PUSH
60507: LD_EXP 60
60511: PUSH
60512: LD_VAR 0 1
60516: ARRAY
60517: PPUSH
60518: LD_INT 25
60520: PUSH
60521: LD_INT 2
60523: PUSH
60524: EMPTY
60525: LIST
60526: LIST
60527: PPUSH
60528: CALL_OW 72
60532: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
60533: LD_ADDR_VAR 0 7
60537: PUSH
60538: LD_EXP 60
60542: PUSH
60543: LD_VAR 0 1
60547: ARRAY
60548: PPUSH
60549: LD_INT 25
60551: PUSH
60552: LD_INT 3
60554: PUSH
60555: EMPTY
60556: LIST
60557: LIST
60558: PPUSH
60559: CALL_OW 72
60563: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
60564: LD_ADDR_VAR 0 8
60568: PUSH
60569: LD_EXP 60
60573: PUSH
60574: LD_VAR 0 1
60578: ARRAY
60579: PPUSH
60580: LD_INT 25
60582: PUSH
60583: LD_INT 4
60585: PUSH
60586: EMPTY
60587: LIST
60588: LIST
60589: PUSH
60590: LD_INT 24
60592: PUSH
60593: LD_INT 251
60595: PUSH
60596: EMPTY
60597: LIST
60598: LIST
60599: PUSH
60600: EMPTY
60601: LIST
60602: LIST
60603: PPUSH
60604: CALL_OW 72
60608: ST_TO_ADDR
// if mc_is_defending [ base ] then
60609: LD_EXP 103
60613: PUSH
60614: LD_VAR 0 1
60618: ARRAY
60619: IFFALSE 61080
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60621: LD_ADDR_EXP 102
60625: PUSH
60626: LD_EXP 102
60630: PPUSH
60631: LD_VAR 0 1
60635: PPUSH
60636: LD_INT 4
60638: PPUSH
60639: CALL_OW 1
60643: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60644: LD_ADDR_VAR 0 12
60648: PUSH
60649: LD_EXP 60
60653: PUSH
60654: LD_VAR 0 1
60658: ARRAY
60659: PPUSH
60660: LD_INT 2
60662: PUSH
60663: LD_INT 30
60665: PUSH
60666: LD_INT 4
60668: PUSH
60669: EMPTY
60670: LIST
60671: LIST
60672: PUSH
60673: LD_INT 30
60675: PUSH
60676: LD_INT 5
60678: PUSH
60679: EMPTY
60680: LIST
60681: LIST
60682: PUSH
60683: EMPTY
60684: LIST
60685: LIST
60686: LIST
60687: PPUSH
60688: CALL_OW 72
60692: ST_TO_ADDR
// if not b then
60693: LD_VAR 0 12
60697: NOT
60698: IFFALSE 60702
// exit ;
60700: GO 63768
// p := [ ] ;
60702: LD_ADDR_VAR 0 11
60706: PUSH
60707: EMPTY
60708: ST_TO_ADDR
// if sci >= 2 then
60709: LD_VAR 0 8
60713: PUSH
60714: LD_INT 2
60716: GREATEREQUAL
60717: IFFALSE 60748
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60719: LD_ADDR_VAR 0 8
60723: PUSH
60724: LD_VAR 0 8
60728: PUSH
60729: LD_INT 1
60731: ARRAY
60732: PUSH
60733: LD_VAR 0 8
60737: PUSH
60738: LD_INT 2
60740: ARRAY
60741: PUSH
60742: EMPTY
60743: LIST
60744: LIST
60745: ST_TO_ADDR
60746: GO 60809
// if sci = 1 then
60748: LD_VAR 0 8
60752: PUSH
60753: LD_INT 1
60755: EQUAL
60756: IFFALSE 60777
// sci := [ sci [ 1 ] ] else
60758: LD_ADDR_VAR 0 8
60762: PUSH
60763: LD_VAR 0 8
60767: PUSH
60768: LD_INT 1
60770: ARRAY
60771: PUSH
60772: EMPTY
60773: LIST
60774: ST_TO_ADDR
60775: GO 60809
// if sci = 0 then
60777: LD_VAR 0 8
60781: PUSH
60782: LD_INT 0
60784: EQUAL
60785: IFFALSE 60809
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60787: LD_ADDR_VAR 0 11
60791: PUSH
60792: LD_VAR 0 4
60796: PPUSH
60797: LD_INT 4
60799: PPUSH
60800: CALL 50207 0 2
60804: PUSH
60805: LD_INT 1
60807: ARRAY
60808: ST_TO_ADDR
// if eng > 4 then
60809: LD_VAR 0 6
60813: PUSH
60814: LD_INT 4
60816: GREATER
60817: IFFALSE 60863
// for i = eng downto 4 do
60819: LD_ADDR_VAR 0 3
60823: PUSH
60824: DOUBLE
60825: LD_VAR 0 6
60829: INC
60830: ST_TO_ADDR
60831: LD_INT 4
60833: PUSH
60834: FOR_DOWNTO
60835: IFFALSE 60861
// eng := eng diff eng [ i ] ;
60837: LD_ADDR_VAR 0 6
60841: PUSH
60842: LD_VAR 0 6
60846: PUSH
60847: LD_VAR 0 6
60851: PUSH
60852: LD_VAR 0 3
60856: ARRAY
60857: DIFF
60858: ST_TO_ADDR
60859: GO 60834
60861: POP
60862: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60863: LD_ADDR_VAR 0 4
60867: PUSH
60868: LD_VAR 0 4
60872: PUSH
60873: LD_VAR 0 5
60877: PUSH
60878: LD_VAR 0 6
60882: UNION
60883: PUSH
60884: LD_VAR 0 7
60888: UNION
60889: PUSH
60890: LD_VAR 0 8
60894: UNION
60895: DIFF
60896: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60897: LD_ADDR_VAR 0 13
60901: PUSH
60902: LD_EXP 60
60906: PUSH
60907: LD_VAR 0 1
60911: ARRAY
60912: PPUSH
60913: LD_INT 2
60915: PUSH
60916: LD_INT 30
60918: PUSH
60919: LD_INT 32
60921: PUSH
60922: EMPTY
60923: LIST
60924: LIST
60925: PUSH
60926: LD_INT 30
60928: PUSH
60929: LD_INT 31
60931: PUSH
60932: EMPTY
60933: LIST
60934: LIST
60935: PUSH
60936: EMPTY
60937: LIST
60938: LIST
60939: LIST
60940: PPUSH
60941: CALL_OW 72
60945: PUSH
60946: LD_EXP 60
60950: PUSH
60951: LD_VAR 0 1
60955: ARRAY
60956: PPUSH
60957: LD_INT 2
60959: PUSH
60960: LD_INT 30
60962: PUSH
60963: LD_INT 4
60965: PUSH
60966: EMPTY
60967: LIST
60968: LIST
60969: PUSH
60970: LD_INT 30
60972: PUSH
60973: LD_INT 5
60975: PUSH
60976: EMPTY
60977: LIST
60978: LIST
60979: PUSH
60980: EMPTY
60981: LIST
60982: LIST
60983: LIST
60984: PPUSH
60985: CALL_OW 72
60989: PUSH
60990: LD_INT 6
60992: MUL
60993: PLUS
60994: ST_TO_ADDR
// if bcount < tmp then
60995: LD_VAR 0 13
60999: PUSH
61000: LD_VAR 0 4
61004: LESS
61005: IFFALSE 61051
// for i = tmp downto bcount do
61007: LD_ADDR_VAR 0 3
61011: PUSH
61012: DOUBLE
61013: LD_VAR 0 4
61017: INC
61018: ST_TO_ADDR
61019: LD_VAR 0 13
61023: PUSH
61024: FOR_DOWNTO
61025: IFFALSE 61049
// tmp := Delete ( tmp , tmp ) ;
61027: LD_ADDR_VAR 0 4
61031: PUSH
61032: LD_VAR 0 4
61036: PPUSH
61037: LD_VAR 0 4
61041: PPUSH
61042: CALL_OW 3
61046: ST_TO_ADDR
61047: GO 61024
61049: POP
61050: POP
// result := [ tmp , 0 , 0 , p ] ;
61051: LD_ADDR_VAR 0 2
61055: PUSH
61056: LD_VAR 0 4
61060: PUSH
61061: LD_INT 0
61063: PUSH
61064: LD_INT 0
61066: PUSH
61067: LD_VAR 0 11
61071: PUSH
61072: EMPTY
61073: LIST
61074: LIST
61075: LIST
61076: LIST
61077: ST_TO_ADDR
// exit ;
61078: GO 63768
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61080: LD_EXP 60
61084: PUSH
61085: LD_VAR 0 1
61089: ARRAY
61090: PPUSH
61091: LD_INT 2
61093: PUSH
61094: LD_INT 30
61096: PUSH
61097: LD_INT 6
61099: PUSH
61100: EMPTY
61101: LIST
61102: LIST
61103: PUSH
61104: LD_INT 30
61106: PUSH
61107: LD_INT 7
61109: PUSH
61110: EMPTY
61111: LIST
61112: LIST
61113: PUSH
61114: LD_INT 30
61116: PUSH
61117: LD_INT 8
61119: PUSH
61120: EMPTY
61121: LIST
61122: LIST
61123: PUSH
61124: EMPTY
61125: LIST
61126: LIST
61127: LIST
61128: LIST
61129: PPUSH
61130: CALL_OW 72
61134: NOT
61135: PUSH
61136: LD_EXP 60
61140: PUSH
61141: LD_VAR 0 1
61145: ARRAY
61146: PPUSH
61147: LD_INT 30
61149: PUSH
61150: LD_INT 3
61152: PUSH
61153: EMPTY
61154: LIST
61155: LIST
61156: PPUSH
61157: CALL_OW 72
61161: NOT
61162: AND
61163: IFFALSE 61235
// begin if eng = tmp then
61165: LD_VAR 0 6
61169: PUSH
61170: LD_VAR 0 4
61174: EQUAL
61175: IFFALSE 61179
// exit ;
61177: GO 63768
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
61179: LD_ADDR_EXP 102
61183: PUSH
61184: LD_EXP 102
61188: PPUSH
61189: LD_VAR 0 1
61193: PPUSH
61194: LD_INT 1
61196: PPUSH
61197: CALL_OW 1
61201: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
61202: LD_ADDR_VAR 0 2
61206: PUSH
61207: LD_INT 0
61209: PUSH
61210: LD_VAR 0 4
61214: PUSH
61215: LD_VAR 0 6
61219: DIFF
61220: PUSH
61221: LD_INT 0
61223: PUSH
61224: LD_INT 0
61226: PUSH
61227: EMPTY
61228: LIST
61229: LIST
61230: LIST
61231: LIST
61232: ST_TO_ADDR
// exit ;
61233: GO 63768
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61235: LD_EXP 87
61239: PUSH
61240: LD_EXP 86
61244: PUSH
61245: LD_VAR 0 1
61249: ARRAY
61250: ARRAY
61251: PUSH
61252: LD_EXP 60
61256: PUSH
61257: LD_VAR 0 1
61261: ARRAY
61262: PPUSH
61263: LD_INT 2
61265: PUSH
61266: LD_INT 30
61268: PUSH
61269: LD_INT 6
61271: PUSH
61272: EMPTY
61273: LIST
61274: LIST
61275: PUSH
61276: LD_INT 30
61278: PUSH
61279: LD_INT 7
61281: PUSH
61282: EMPTY
61283: LIST
61284: LIST
61285: PUSH
61286: LD_INT 30
61288: PUSH
61289: LD_INT 8
61291: PUSH
61292: EMPTY
61293: LIST
61294: LIST
61295: PUSH
61296: EMPTY
61297: LIST
61298: LIST
61299: LIST
61300: LIST
61301: PPUSH
61302: CALL_OW 72
61306: AND
61307: PUSH
61308: LD_EXP 60
61312: PUSH
61313: LD_VAR 0 1
61317: ARRAY
61318: PPUSH
61319: LD_INT 30
61321: PUSH
61322: LD_INT 3
61324: PUSH
61325: EMPTY
61326: LIST
61327: LIST
61328: PPUSH
61329: CALL_OW 72
61333: NOT
61334: AND
61335: IFFALSE 61549
// begin if sci >= 6 then
61337: LD_VAR 0 8
61341: PUSH
61342: LD_INT 6
61344: GREATEREQUAL
61345: IFFALSE 61349
// exit ;
61347: GO 63768
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
61349: LD_ADDR_EXP 102
61353: PUSH
61354: LD_EXP 102
61358: PPUSH
61359: LD_VAR 0 1
61363: PPUSH
61364: LD_INT 2
61366: PPUSH
61367: CALL_OW 1
61371: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
61372: LD_ADDR_VAR 0 9
61376: PUSH
61377: LD_VAR 0 4
61381: PUSH
61382: LD_VAR 0 8
61386: DIFF
61387: PPUSH
61388: LD_INT 4
61390: PPUSH
61391: CALL 50207 0 2
61395: ST_TO_ADDR
// p := [ ] ;
61396: LD_ADDR_VAR 0 11
61400: PUSH
61401: EMPTY
61402: ST_TO_ADDR
// if sci < 6 and sort > 6 then
61403: LD_VAR 0 8
61407: PUSH
61408: LD_INT 6
61410: LESS
61411: PUSH
61412: LD_VAR 0 9
61416: PUSH
61417: LD_INT 6
61419: GREATER
61420: AND
61421: IFFALSE 61502
// begin for i = 1 to 6 - sci do
61423: LD_ADDR_VAR 0 3
61427: PUSH
61428: DOUBLE
61429: LD_INT 1
61431: DEC
61432: ST_TO_ADDR
61433: LD_INT 6
61435: PUSH
61436: LD_VAR 0 8
61440: MINUS
61441: PUSH
61442: FOR_TO
61443: IFFALSE 61498
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
61445: LD_ADDR_VAR 0 11
61449: PUSH
61450: LD_VAR 0 11
61454: PPUSH
61455: LD_VAR 0 11
61459: PUSH
61460: LD_INT 1
61462: PLUS
61463: PPUSH
61464: LD_VAR 0 9
61468: PUSH
61469: LD_INT 1
61471: ARRAY
61472: PPUSH
61473: CALL_OW 2
61477: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
61478: LD_ADDR_VAR 0 9
61482: PUSH
61483: LD_VAR 0 9
61487: PPUSH
61488: LD_INT 1
61490: PPUSH
61491: CALL_OW 3
61495: ST_TO_ADDR
// end ;
61496: GO 61442
61498: POP
61499: POP
// end else
61500: GO 61522
// if sort then
61502: LD_VAR 0 9
61506: IFFALSE 61522
// p := sort [ 1 ] ;
61508: LD_ADDR_VAR 0 11
61512: PUSH
61513: LD_VAR 0 9
61517: PUSH
61518: LD_INT 1
61520: ARRAY
61521: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
61522: LD_ADDR_VAR 0 2
61526: PUSH
61527: LD_INT 0
61529: PUSH
61530: LD_INT 0
61532: PUSH
61533: LD_INT 0
61535: PUSH
61536: LD_VAR 0 11
61540: PUSH
61541: EMPTY
61542: LIST
61543: LIST
61544: LIST
61545: LIST
61546: ST_TO_ADDR
// exit ;
61547: GO 63768
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61549: LD_EXP 87
61553: PUSH
61554: LD_EXP 86
61558: PUSH
61559: LD_VAR 0 1
61563: ARRAY
61564: ARRAY
61565: PUSH
61566: LD_EXP 60
61570: PUSH
61571: LD_VAR 0 1
61575: ARRAY
61576: PPUSH
61577: LD_INT 2
61579: PUSH
61580: LD_INT 30
61582: PUSH
61583: LD_INT 6
61585: PUSH
61586: EMPTY
61587: LIST
61588: LIST
61589: PUSH
61590: LD_INT 30
61592: PUSH
61593: LD_INT 7
61595: PUSH
61596: EMPTY
61597: LIST
61598: LIST
61599: PUSH
61600: LD_INT 30
61602: PUSH
61603: LD_INT 8
61605: PUSH
61606: EMPTY
61607: LIST
61608: LIST
61609: PUSH
61610: EMPTY
61611: LIST
61612: LIST
61613: LIST
61614: LIST
61615: PPUSH
61616: CALL_OW 72
61620: AND
61621: PUSH
61622: LD_EXP 60
61626: PUSH
61627: LD_VAR 0 1
61631: ARRAY
61632: PPUSH
61633: LD_INT 30
61635: PUSH
61636: LD_INT 3
61638: PUSH
61639: EMPTY
61640: LIST
61641: LIST
61642: PPUSH
61643: CALL_OW 72
61647: AND
61648: IFFALSE 62382
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61650: LD_ADDR_EXP 102
61654: PUSH
61655: LD_EXP 102
61659: PPUSH
61660: LD_VAR 0 1
61664: PPUSH
61665: LD_INT 3
61667: PPUSH
61668: CALL_OW 1
61672: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61673: LD_ADDR_VAR 0 2
61677: PUSH
61678: LD_INT 0
61680: PUSH
61681: LD_INT 0
61683: PUSH
61684: LD_INT 0
61686: PUSH
61687: LD_INT 0
61689: PUSH
61690: EMPTY
61691: LIST
61692: LIST
61693: LIST
61694: LIST
61695: ST_TO_ADDR
// if not eng then
61696: LD_VAR 0 6
61700: NOT
61701: IFFALSE 61764
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61703: LD_ADDR_VAR 0 11
61707: PUSH
61708: LD_VAR 0 4
61712: PPUSH
61713: LD_INT 2
61715: PPUSH
61716: CALL 50207 0 2
61720: PUSH
61721: LD_INT 1
61723: ARRAY
61724: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61725: LD_ADDR_VAR 0 2
61729: PUSH
61730: LD_VAR 0 2
61734: PPUSH
61735: LD_INT 2
61737: PPUSH
61738: LD_VAR 0 11
61742: PPUSH
61743: CALL_OW 1
61747: ST_TO_ADDR
// tmp := tmp diff p ;
61748: LD_ADDR_VAR 0 4
61752: PUSH
61753: LD_VAR 0 4
61757: PUSH
61758: LD_VAR 0 11
61762: DIFF
61763: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61764: LD_VAR 0 4
61768: PUSH
61769: LD_VAR 0 8
61773: PUSH
61774: LD_INT 6
61776: LESS
61777: AND
61778: IFFALSE 61966
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61780: LD_ADDR_VAR 0 9
61784: PUSH
61785: LD_VAR 0 4
61789: PUSH
61790: LD_VAR 0 8
61794: PUSH
61795: LD_VAR 0 7
61799: UNION
61800: DIFF
61801: PPUSH
61802: LD_INT 4
61804: PPUSH
61805: CALL 50207 0 2
61809: ST_TO_ADDR
// p := [ ] ;
61810: LD_ADDR_VAR 0 11
61814: PUSH
61815: EMPTY
61816: ST_TO_ADDR
// if sort then
61817: LD_VAR 0 9
61821: IFFALSE 61937
// for i = 1 to 6 - sci do
61823: LD_ADDR_VAR 0 3
61827: PUSH
61828: DOUBLE
61829: LD_INT 1
61831: DEC
61832: ST_TO_ADDR
61833: LD_INT 6
61835: PUSH
61836: LD_VAR 0 8
61840: MINUS
61841: PUSH
61842: FOR_TO
61843: IFFALSE 61935
// begin if i = sort then
61845: LD_VAR 0 3
61849: PUSH
61850: LD_VAR 0 9
61854: EQUAL
61855: IFFALSE 61859
// break ;
61857: GO 61935
// if GetClass ( i ) = 4 then
61859: LD_VAR 0 3
61863: PPUSH
61864: CALL_OW 257
61868: PUSH
61869: LD_INT 4
61871: EQUAL
61872: IFFALSE 61876
// continue ;
61874: GO 61842
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61876: LD_ADDR_VAR 0 11
61880: PUSH
61881: LD_VAR 0 11
61885: PPUSH
61886: LD_VAR 0 11
61890: PUSH
61891: LD_INT 1
61893: PLUS
61894: PPUSH
61895: LD_VAR 0 9
61899: PUSH
61900: LD_VAR 0 3
61904: ARRAY
61905: PPUSH
61906: CALL_OW 2
61910: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61911: LD_ADDR_VAR 0 4
61915: PUSH
61916: LD_VAR 0 4
61920: PUSH
61921: LD_VAR 0 9
61925: PUSH
61926: LD_VAR 0 3
61930: ARRAY
61931: DIFF
61932: ST_TO_ADDR
// end ;
61933: GO 61842
61935: POP
61936: POP
// if p then
61937: LD_VAR 0 11
61941: IFFALSE 61966
// result := Replace ( result , 4 , p ) ;
61943: LD_ADDR_VAR 0 2
61947: PUSH
61948: LD_VAR 0 2
61952: PPUSH
61953: LD_INT 4
61955: PPUSH
61956: LD_VAR 0 11
61960: PPUSH
61961: CALL_OW 1
61965: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61966: LD_VAR 0 4
61970: PUSH
61971: LD_VAR 0 7
61975: PUSH
61976: LD_INT 6
61978: LESS
61979: AND
61980: IFFALSE 62168
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61982: LD_ADDR_VAR 0 9
61986: PUSH
61987: LD_VAR 0 4
61991: PUSH
61992: LD_VAR 0 8
61996: PUSH
61997: LD_VAR 0 7
62001: UNION
62002: DIFF
62003: PPUSH
62004: LD_INT 3
62006: PPUSH
62007: CALL 50207 0 2
62011: ST_TO_ADDR
// p := [ ] ;
62012: LD_ADDR_VAR 0 11
62016: PUSH
62017: EMPTY
62018: ST_TO_ADDR
// if sort then
62019: LD_VAR 0 9
62023: IFFALSE 62139
// for i = 1 to 6 - mech do
62025: LD_ADDR_VAR 0 3
62029: PUSH
62030: DOUBLE
62031: LD_INT 1
62033: DEC
62034: ST_TO_ADDR
62035: LD_INT 6
62037: PUSH
62038: LD_VAR 0 7
62042: MINUS
62043: PUSH
62044: FOR_TO
62045: IFFALSE 62137
// begin if i = sort then
62047: LD_VAR 0 3
62051: PUSH
62052: LD_VAR 0 9
62056: EQUAL
62057: IFFALSE 62061
// break ;
62059: GO 62137
// if GetClass ( i ) = 3 then
62061: LD_VAR 0 3
62065: PPUSH
62066: CALL_OW 257
62070: PUSH
62071: LD_INT 3
62073: EQUAL
62074: IFFALSE 62078
// continue ;
62076: GO 62044
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62078: LD_ADDR_VAR 0 11
62082: PUSH
62083: LD_VAR 0 11
62087: PPUSH
62088: LD_VAR 0 11
62092: PUSH
62093: LD_INT 1
62095: PLUS
62096: PPUSH
62097: LD_VAR 0 9
62101: PUSH
62102: LD_VAR 0 3
62106: ARRAY
62107: PPUSH
62108: CALL_OW 2
62112: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62113: LD_ADDR_VAR 0 4
62117: PUSH
62118: LD_VAR 0 4
62122: PUSH
62123: LD_VAR 0 9
62127: PUSH
62128: LD_VAR 0 3
62132: ARRAY
62133: DIFF
62134: ST_TO_ADDR
// end ;
62135: GO 62044
62137: POP
62138: POP
// if p then
62139: LD_VAR 0 11
62143: IFFALSE 62168
// result := Replace ( result , 3 , p ) ;
62145: LD_ADDR_VAR 0 2
62149: PUSH
62150: LD_VAR 0 2
62154: PPUSH
62155: LD_INT 3
62157: PPUSH
62158: LD_VAR 0 11
62162: PPUSH
62163: CALL_OW 1
62167: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
62168: LD_VAR 0 4
62172: PUSH
62173: LD_INT 6
62175: GREATER
62176: PUSH
62177: LD_VAR 0 6
62181: PUSH
62182: LD_INT 6
62184: LESS
62185: AND
62186: IFFALSE 62380
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62188: LD_ADDR_VAR 0 9
62192: PUSH
62193: LD_VAR 0 4
62197: PUSH
62198: LD_VAR 0 8
62202: PUSH
62203: LD_VAR 0 7
62207: UNION
62208: PUSH
62209: LD_VAR 0 6
62213: UNION
62214: DIFF
62215: PPUSH
62216: LD_INT 2
62218: PPUSH
62219: CALL 50207 0 2
62223: ST_TO_ADDR
// p := [ ] ;
62224: LD_ADDR_VAR 0 11
62228: PUSH
62229: EMPTY
62230: ST_TO_ADDR
// if sort then
62231: LD_VAR 0 9
62235: IFFALSE 62351
// for i = 1 to 6 - eng do
62237: LD_ADDR_VAR 0 3
62241: PUSH
62242: DOUBLE
62243: LD_INT 1
62245: DEC
62246: ST_TO_ADDR
62247: LD_INT 6
62249: PUSH
62250: LD_VAR 0 6
62254: MINUS
62255: PUSH
62256: FOR_TO
62257: IFFALSE 62349
// begin if i = sort then
62259: LD_VAR 0 3
62263: PUSH
62264: LD_VAR 0 9
62268: EQUAL
62269: IFFALSE 62273
// break ;
62271: GO 62349
// if GetClass ( i ) = 2 then
62273: LD_VAR 0 3
62277: PPUSH
62278: CALL_OW 257
62282: PUSH
62283: LD_INT 2
62285: EQUAL
62286: IFFALSE 62290
// continue ;
62288: GO 62256
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62290: LD_ADDR_VAR 0 11
62294: PUSH
62295: LD_VAR 0 11
62299: PPUSH
62300: LD_VAR 0 11
62304: PUSH
62305: LD_INT 1
62307: PLUS
62308: PPUSH
62309: LD_VAR 0 9
62313: PUSH
62314: LD_VAR 0 3
62318: ARRAY
62319: PPUSH
62320: CALL_OW 2
62324: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62325: LD_ADDR_VAR 0 4
62329: PUSH
62330: LD_VAR 0 4
62334: PUSH
62335: LD_VAR 0 9
62339: PUSH
62340: LD_VAR 0 3
62344: ARRAY
62345: DIFF
62346: ST_TO_ADDR
// end ;
62347: GO 62256
62349: POP
62350: POP
// if p then
62351: LD_VAR 0 11
62355: IFFALSE 62380
// result := Replace ( result , 2 , p ) ;
62357: LD_ADDR_VAR 0 2
62361: PUSH
62362: LD_VAR 0 2
62366: PPUSH
62367: LD_INT 2
62369: PPUSH
62370: LD_VAR 0 11
62374: PPUSH
62375: CALL_OW 1
62379: ST_TO_ADDR
// end ; exit ;
62380: GO 63768
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
62382: LD_EXP 87
62386: PUSH
62387: LD_EXP 86
62391: PUSH
62392: LD_VAR 0 1
62396: ARRAY
62397: ARRAY
62398: NOT
62399: PUSH
62400: LD_EXP 60
62404: PUSH
62405: LD_VAR 0 1
62409: ARRAY
62410: PPUSH
62411: LD_INT 30
62413: PUSH
62414: LD_INT 3
62416: PUSH
62417: EMPTY
62418: LIST
62419: LIST
62420: PPUSH
62421: CALL_OW 72
62425: AND
62426: PUSH
62427: LD_EXP 65
62431: PUSH
62432: LD_VAR 0 1
62436: ARRAY
62437: AND
62438: IFFALSE 63046
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
62440: LD_ADDR_EXP 102
62444: PUSH
62445: LD_EXP 102
62449: PPUSH
62450: LD_VAR 0 1
62454: PPUSH
62455: LD_INT 5
62457: PPUSH
62458: CALL_OW 1
62462: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62463: LD_ADDR_VAR 0 2
62467: PUSH
62468: LD_INT 0
62470: PUSH
62471: LD_INT 0
62473: PUSH
62474: LD_INT 0
62476: PUSH
62477: LD_INT 0
62479: PUSH
62480: EMPTY
62481: LIST
62482: LIST
62483: LIST
62484: LIST
62485: ST_TO_ADDR
// if sci > 1 then
62486: LD_VAR 0 8
62490: PUSH
62491: LD_INT 1
62493: GREATER
62494: IFFALSE 62522
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
62496: LD_ADDR_VAR 0 4
62500: PUSH
62501: LD_VAR 0 4
62505: PUSH
62506: LD_VAR 0 8
62510: PUSH
62511: LD_VAR 0 8
62515: PUSH
62516: LD_INT 1
62518: ARRAY
62519: DIFF
62520: DIFF
62521: ST_TO_ADDR
// if tmp and not sci then
62522: LD_VAR 0 4
62526: PUSH
62527: LD_VAR 0 8
62531: NOT
62532: AND
62533: IFFALSE 62602
// begin sort := SortBySkill ( tmp , 4 ) ;
62535: LD_ADDR_VAR 0 9
62539: PUSH
62540: LD_VAR 0 4
62544: PPUSH
62545: LD_INT 4
62547: PPUSH
62548: CALL 50207 0 2
62552: ST_TO_ADDR
// if sort then
62553: LD_VAR 0 9
62557: IFFALSE 62573
// p := sort [ 1 ] ;
62559: LD_ADDR_VAR 0 11
62563: PUSH
62564: LD_VAR 0 9
62568: PUSH
62569: LD_INT 1
62571: ARRAY
62572: ST_TO_ADDR
// if p then
62573: LD_VAR 0 11
62577: IFFALSE 62602
// result := Replace ( result , 4 , p ) ;
62579: LD_ADDR_VAR 0 2
62583: PUSH
62584: LD_VAR 0 2
62588: PPUSH
62589: LD_INT 4
62591: PPUSH
62592: LD_VAR 0 11
62596: PPUSH
62597: CALL_OW 1
62601: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62602: LD_ADDR_VAR 0 4
62606: PUSH
62607: LD_VAR 0 4
62611: PUSH
62612: LD_VAR 0 7
62616: DIFF
62617: ST_TO_ADDR
// if tmp and mech < 6 then
62618: LD_VAR 0 4
62622: PUSH
62623: LD_VAR 0 7
62627: PUSH
62628: LD_INT 6
62630: LESS
62631: AND
62632: IFFALSE 62820
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62634: LD_ADDR_VAR 0 9
62638: PUSH
62639: LD_VAR 0 4
62643: PUSH
62644: LD_VAR 0 8
62648: PUSH
62649: LD_VAR 0 7
62653: UNION
62654: DIFF
62655: PPUSH
62656: LD_INT 3
62658: PPUSH
62659: CALL 50207 0 2
62663: ST_TO_ADDR
// p := [ ] ;
62664: LD_ADDR_VAR 0 11
62668: PUSH
62669: EMPTY
62670: ST_TO_ADDR
// if sort then
62671: LD_VAR 0 9
62675: IFFALSE 62791
// for i = 1 to 6 - mech do
62677: LD_ADDR_VAR 0 3
62681: PUSH
62682: DOUBLE
62683: LD_INT 1
62685: DEC
62686: ST_TO_ADDR
62687: LD_INT 6
62689: PUSH
62690: LD_VAR 0 7
62694: MINUS
62695: PUSH
62696: FOR_TO
62697: IFFALSE 62789
// begin if i = sort then
62699: LD_VAR 0 3
62703: PUSH
62704: LD_VAR 0 9
62708: EQUAL
62709: IFFALSE 62713
// break ;
62711: GO 62789
// if GetClass ( i ) = 3 then
62713: LD_VAR 0 3
62717: PPUSH
62718: CALL_OW 257
62722: PUSH
62723: LD_INT 3
62725: EQUAL
62726: IFFALSE 62730
// continue ;
62728: GO 62696
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62730: LD_ADDR_VAR 0 11
62734: PUSH
62735: LD_VAR 0 11
62739: PPUSH
62740: LD_VAR 0 11
62744: PUSH
62745: LD_INT 1
62747: PLUS
62748: PPUSH
62749: LD_VAR 0 9
62753: PUSH
62754: LD_VAR 0 3
62758: ARRAY
62759: PPUSH
62760: CALL_OW 2
62764: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62765: LD_ADDR_VAR 0 4
62769: PUSH
62770: LD_VAR 0 4
62774: PUSH
62775: LD_VAR 0 9
62779: PUSH
62780: LD_VAR 0 3
62784: ARRAY
62785: DIFF
62786: ST_TO_ADDR
// end ;
62787: GO 62696
62789: POP
62790: POP
// if p then
62791: LD_VAR 0 11
62795: IFFALSE 62820
// result := Replace ( result , 3 , p ) ;
62797: LD_ADDR_VAR 0 2
62801: PUSH
62802: LD_VAR 0 2
62806: PPUSH
62807: LD_INT 3
62809: PPUSH
62810: LD_VAR 0 11
62814: PPUSH
62815: CALL_OW 1
62819: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62820: LD_ADDR_VAR 0 4
62824: PUSH
62825: LD_VAR 0 4
62829: PUSH
62830: LD_VAR 0 6
62834: DIFF
62835: ST_TO_ADDR
// if tmp and eng < 6 then
62836: LD_VAR 0 4
62840: PUSH
62841: LD_VAR 0 6
62845: PUSH
62846: LD_INT 6
62848: LESS
62849: AND
62850: IFFALSE 63044
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62852: LD_ADDR_VAR 0 9
62856: PUSH
62857: LD_VAR 0 4
62861: PUSH
62862: LD_VAR 0 8
62866: PUSH
62867: LD_VAR 0 7
62871: UNION
62872: PUSH
62873: LD_VAR 0 6
62877: UNION
62878: DIFF
62879: PPUSH
62880: LD_INT 2
62882: PPUSH
62883: CALL 50207 0 2
62887: ST_TO_ADDR
// p := [ ] ;
62888: LD_ADDR_VAR 0 11
62892: PUSH
62893: EMPTY
62894: ST_TO_ADDR
// if sort then
62895: LD_VAR 0 9
62899: IFFALSE 63015
// for i = 1 to 6 - eng do
62901: LD_ADDR_VAR 0 3
62905: PUSH
62906: DOUBLE
62907: LD_INT 1
62909: DEC
62910: ST_TO_ADDR
62911: LD_INT 6
62913: PUSH
62914: LD_VAR 0 6
62918: MINUS
62919: PUSH
62920: FOR_TO
62921: IFFALSE 63013
// begin if i = sort then
62923: LD_VAR 0 3
62927: PUSH
62928: LD_VAR 0 9
62932: EQUAL
62933: IFFALSE 62937
// break ;
62935: GO 63013
// if GetClass ( i ) = 2 then
62937: LD_VAR 0 3
62941: PPUSH
62942: CALL_OW 257
62946: PUSH
62947: LD_INT 2
62949: EQUAL
62950: IFFALSE 62954
// continue ;
62952: GO 62920
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62954: LD_ADDR_VAR 0 11
62958: PUSH
62959: LD_VAR 0 11
62963: PPUSH
62964: LD_VAR 0 11
62968: PUSH
62969: LD_INT 1
62971: PLUS
62972: PPUSH
62973: LD_VAR 0 9
62977: PUSH
62978: LD_VAR 0 3
62982: ARRAY
62983: PPUSH
62984: CALL_OW 2
62988: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62989: LD_ADDR_VAR 0 4
62993: PUSH
62994: LD_VAR 0 4
62998: PUSH
62999: LD_VAR 0 9
63003: PUSH
63004: LD_VAR 0 3
63008: ARRAY
63009: DIFF
63010: ST_TO_ADDR
// end ;
63011: GO 62920
63013: POP
63014: POP
// if p then
63015: LD_VAR 0 11
63019: IFFALSE 63044
// result := Replace ( result , 2 , p ) ;
63021: LD_ADDR_VAR 0 2
63025: PUSH
63026: LD_VAR 0 2
63030: PPUSH
63031: LD_INT 2
63033: PPUSH
63034: LD_VAR 0 11
63038: PPUSH
63039: CALL_OW 1
63043: ST_TO_ADDR
// end ; exit ;
63044: GO 63768
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
63046: LD_EXP 87
63050: PUSH
63051: LD_EXP 86
63055: PUSH
63056: LD_VAR 0 1
63060: ARRAY
63061: ARRAY
63062: NOT
63063: PUSH
63064: LD_EXP 60
63068: PUSH
63069: LD_VAR 0 1
63073: ARRAY
63074: PPUSH
63075: LD_INT 30
63077: PUSH
63078: LD_INT 3
63080: PUSH
63081: EMPTY
63082: LIST
63083: LIST
63084: PPUSH
63085: CALL_OW 72
63089: AND
63090: PUSH
63091: LD_EXP 65
63095: PUSH
63096: LD_VAR 0 1
63100: ARRAY
63101: NOT
63102: AND
63103: IFFALSE 63768
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
63105: LD_ADDR_EXP 102
63109: PUSH
63110: LD_EXP 102
63114: PPUSH
63115: LD_VAR 0 1
63119: PPUSH
63120: LD_INT 6
63122: PPUSH
63123: CALL_OW 1
63127: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63128: LD_ADDR_VAR 0 2
63132: PUSH
63133: LD_INT 0
63135: PUSH
63136: LD_INT 0
63138: PUSH
63139: LD_INT 0
63141: PUSH
63142: LD_INT 0
63144: PUSH
63145: EMPTY
63146: LIST
63147: LIST
63148: LIST
63149: LIST
63150: ST_TO_ADDR
// if sci >= 1 then
63151: LD_VAR 0 8
63155: PUSH
63156: LD_INT 1
63158: GREATEREQUAL
63159: IFFALSE 63181
// tmp := tmp diff sci [ 1 ] ;
63161: LD_ADDR_VAR 0 4
63165: PUSH
63166: LD_VAR 0 4
63170: PUSH
63171: LD_VAR 0 8
63175: PUSH
63176: LD_INT 1
63178: ARRAY
63179: DIFF
63180: ST_TO_ADDR
// if tmp and not sci then
63181: LD_VAR 0 4
63185: PUSH
63186: LD_VAR 0 8
63190: NOT
63191: AND
63192: IFFALSE 63261
// begin sort := SortBySkill ( tmp , 4 ) ;
63194: LD_ADDR_VAR 0 9
63198: PUSH
63199: LD_VAR 0 4
63203: PPUSH
63204: LD_INT 4
63206: PPUSH
63207: CALL 50207 0 2
63211: ST_TO_ADDR
// if sort then
63212: LD_VAR 0 9
63216: IFFALSE 63232
// p := sort [ 1 ] ;
63218: LD_ADDR_VAR 0 11
63222: PUSH
63223: LD_VAR 0 9
63227: PUSH
63228: LD_INT 1
63230: ARRAY
63231: ST_TO_ADDR
// if p then
63232: LD_VAR 0 11
63236: IFFALSE 63261
// result := Replace ( result , 4 , p ) ;
63238: LD_ADDR_VAR 0 2
63242: PUSH
63243: LD_VAR 0 2
63247: PPUSH
63248: LD_INT 4
63250: PPUSH
63251: LD_VAR 0 11
63255: PPUSH
63256: CALL_OW 1
63260: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63261: LD_ADDR_VAR 0 4
63265: PUSH
63266: LD_VAR 0 4
63270: PUSH
63271: LD_VAR 0 7
63275: DIFF
63276: ST_TO_ADDR
// if tmp and mech < 6 then
63277: LD_VAR 0 4
63281: PUSH
63282: LD_VAR 0 7
63286: PUSH
63287: LD_INT 6
63289: LESS
63290: AND
63291: IFFALSE 63473
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
63293: LD_ADDR_VAR 0 9
63297: PUSH
63298: LD_VAR 0 4
63302: PUSH
63303: LD_VAR 0 7
63307: DIFF
63308: PPUSH
63309: LD_INT 3
63311: PPUSH
63312: CALL 50207 0 2
63316: ST_TO_ADDR
// p := [ ] ;
63317: LD_ADDR_VAR 0 11
63321: PUSH
63322: EMPTY
63323: ST_TO_ADDR
// if sort then
63324: LD_VAR 0 9
63328: IFFALSE 63444
// for i = 1 to 6 - mech do
63330: LD_ADDR_VAR 0 3
63334: PUSH
63335: DOUBLE
63336: LD_INT 1
63338: DEC
63339: ST_TO_ADDR
63340: LD_INT 6
63342: PUSH
63343: LD_VAR 0 7
63347: MINUS
63348: PUSH
63349: FOR_TO
63350: IFFALSE 63442
// begin if i = sort then
63352: LD_VAR 0 3
63356: PUSH
63357: LD_VAR 0 9
63361: EQUAL
63362: IFFALSE 63366
// break ;
63364: GO 63442
// if GetClass ( i ) = 3 then
63366: LD_VAR 0 3
63370: PPUSH
63371: CALL_OW 257
63375: PUSH
63376: LD_INT 3
63378: EQUAL
63379: IFFALSE 63383
// continue ;
63381: GO 63349
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63383: LD_ADDR_VAR 0 11
63387: PUSH
63388: LD_VAR 0 11
63392: PPUSH
63393: LD_VAR 0 11
63397: PUSH
63398: LD_INT 1
63400: PLUS
63401: PPUSH
63402: LD_VAR 0 9
63406: PUSH
63407: LD_VAR 0 3
63411: ARRAY
63412: PPUSH
63413: CALL_OW 2
63417: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63418: LD_ADDR_VAR 0 4
63422: PUSH
63423: LD_VAR 0 4
63427: PUSH
63428: LD_VAR 0 9
63432: PUSH
63433: LD_VAR 0 3
63437: ARRAY
63438: DIFF
63439: ST_TO_ADDR
// end ;
63440: GO 63349
63442: POP
63443: POP
// if p then
63444: LD_VAR 0 11
63448: IFFALSE 63473
// result := Replace ( result , 3 , p ) ;
63450: LD_ADDR_VAR 0 2
63454: PUSH
63455: LD_VAR 0 2
63459: PPUSH
63460: LD_INT 3
63462: PPUSH
63463: LD_VAR 0 11
63467: PPUSH
63468: CALL_OW 1
63472: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63473: LD_ADDR_VAR 0 4
63477: PUSH
63478: LD_VAR 0 4
63482: PUSH
63483: LD_VAR 0 6
63487: DIFF
63488: ST_TO_ADDR
// if tmp and eng < 4 then
63489: LD_VAR 0 4
63493: PUSH
63494: LD_VAR 0 6
63498: PUSH
63499: LD_INT 4
63501: LESS
63502: AND
63503: IFFALSE 63693
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
63505: LD_ADDR_VAR 0 9
63509: PUSH
63510: LD_VAR 0 4
63514: PUSH
63515: LD_VAR 0 7
63519: PUSH
63520: LD_VAR 0 6
63524: UNION
63525: DIFF
63526: PPUSH
63527: LD_INT 2
63529: PPUSH
63530: CALL 50207 0 2
63534: ST_TO_ADDR
// p := [ ] ;
63535: LD_ADDR_VAR 0 11
63539: PUSH
63540: EMPTY
63541: ST_TO_ADDR
// if sort then
63542: LD_VAR 0 9
63546: IFFALSE 63662
// for i = 1 to 4 - eng do
63548: LD_ADDR_VAR 0 3
63552: PUSH
63553: DOUBLE
63554: LD_INT 1
63556: DEC
63557: ST_TO_ADDR
63558: LD_INT 4
63560: PUSH
63561: LD_VAR 0 6
63565: MINUS
63566: PUSH
63567: FOR_TO
63568: IFFALSE 63660
// begin if i = sort then
63570: LD_VAR 0 3
63574: PUSH
63575: LD_VAR 0 9
63579: EQUAL
63580: IFFALSE 63584
// break ;
63582: GO 63660
// if GetClass ( i ) = 2 then
63584: LD_VAR 0 3
63588: PPUSH
63589: CALL_OW 257
63593: PUSH
63594: LD_INT 2
63596: EQUAL
63597: IFFALSE 63601
// continue ;
63599: GO 63567
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63601: LD_ADDR_VAR 0 11
63605: PUSH
63606: LD_VAR 0 11
63610: PPUSH
63611: LD_VAR 0 11
63615: PUSH
63616: LD_INT 1
63618: PLUS
63619: PPUSH
63620: LD_VAR 0 9
63624: PUSH
63625: LD_VAR 0 3
63629: ARRAY
63630: PPUSH
63631: CALL_OW 2
63635: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63636: LD_ADDR_VAR 0 4
63640: PUSH
63641: LD_VAR 0 4
63645: PUSH
63646: LD_VAR 0 9
63650: PUSH
63651: LD_VAR 0 3
63655: ARRAY
63656: DIFF
63657: ST_TO_ADDR
// end ;
63658: GO 63567
63660: POP
63661: POP
// if p then
63662: LD_VAR 0 11
63666: IFFALSE 63691
// result := Replace ( result , 2 , p ) ;
63668: LD_ADDR_VAR 0 2
63672: PUSH
63673: LD_VAR 0 2
63677: PPUSH
63678: LD_INT 2
63680: PPUSH
63681: LD_VAR 0 11
63685: PPUSH
63686: CALL_OW 1
63690: ST_TO_ADDR
// end else
63691: GO 63737
// for i = eng downto 5 do
63693: LD_ADDR_VAR 0 3
63697: PUSH
63698: DOUBLE
63699: LD_VAR 0 6
63703: INC
63704: ST_TO_ADDR
63705: LD_INT 5
63707: PUSH
63708: FOR_DOWNTO
63709: IFFALSE 63735
// tmp := tmp union eng [ i ] ;
63711: LD_ADDR_VAR 0 4
63715: PUSH
63716: LD_VAR 0 4
63720: PUSH
63721: LD_VAR 0 6
63725: PUSH
63726: LD_VAR 0 3
63730: ARRAY
63731: UNION
63732: ST_TO_ADDR
63733: GO 63708
63735: POP
63736: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63737: LD_ADDR_VAR 0 2
63741: PUSH
63742: LD_VAR 0 2
63746: PPUSH
63747: LD_INT 1
63749: PPUSH
63750: LD_VAR 0 4
63754: PUSH
63755: LD_VAR 0 5
63759: DIFF
63760: PPUSH
63761: CALL_OW 1
63765: ST_TO_ADDR
// exit ;
63766: GO 63768
// end ; end ;
63768: LD_VAR 0 2
63772: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63773: LD_INT 0
63775: PPUSH
63776: PPUSH
63777: PPUSH
// if not mc_bases then
63778: LD_EXP 60
63782: NOT
63783: IFFALSE 63787
// exit ;
63785: GO 63929
// for i = 1 to mc_bases do
63787: LD_ADDR_VAR 0 2
63791: PUSH
63792: DOUBLE
63793: LD_INT 1
63795: DEC
63796: ST_TO_ADDR
63797: LD_EXP 60
63801: PUSH
63802: FOR_TO
63803: IFFALSE 63920
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63805: LD_ADDR_VAR 0 3
63809: PUSH
63810: LD_EXP 60
63814: PUSH
63815: LD_VAR 0 2
63819: ARRAY
63820: PPUSH
63821: LD_INT 21
63823: PUSH
63824: LD_INT 3
63826: PUSH
63827: EMPTY
63828: LIST
63829: LIST
63830: PUSH
63831: LD_INT 3
63833: PUSH
63834: LD_INT 2
63836: PUSH
63837: LD_INT 30
63839: PUSH
63840: LD_INT 29
63842: PUSH
63843: EMPTY
63844: LIST
63845: LIST
63846: PUSH
63847: LD_INT 30
63849: PUSH
63850: LD_INT 30
63852: PUSH
63853: EMPTY
63854: LIST
63855: LIST
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: LIST
63861: PUSH
63862: EMPTY
63863: LIST
63864: LIST
63865: PUSH
63866: LD_INT 3
63868: PUSH
63869: LD_INT 24
63871: PUSH
63872: LD_INT 1000
63874: PUSH
63875: EMPTY
63876: LIST
63877: LIST
63878: PUSH
63879: EMPTY
63880: LIST
63881: LIST
63882: PUSH
63883: EMPTY
63884: LIST
63885: LIST
63886: LIST
63887: PPUSH
63888: CALL_OW 72
63892: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63893: LD_ADDR_EXP 61
63897: PUSH
63898: LD_EXP 61
63902: PPUSH
63903: LD_VAR 0 2
63907: PPUSH
63908: LD_VAR 0 3
63912: PPUSH
63913: CALL_OW 1
63917: ST_TO_ADDR
// end ;
63918: GO 63802
63920: POP
63921: POP
// RaiseSailEvent ( 101 ) ;
63922: LD_INT 101
63924: PPUSH
63925: CALL_OW 427
// end ;
63929: LD_VAR 0 1
63933: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63934: LD_INT 0
63936: PPUSH
63937: PPUSH
63938: PPUSH
63939: PPUSH
63940: PPUSH
63941: PPUSH
63942: PPUSH
// if not mc_bases then
63943: LD_EXP 60
63947: NOT
63948: IFFALSE 63952
// exit ;
63950: GO 64514
// for i = 1 to mc_bases do
63952: LD_ADDR_VAR 0 2
63956: PUSH
63957: DOUBLE
63958: LD_INT 1
63960: DEC
63961: ST_TO_ADDR
63962: LD_EXP 60
63966: PUSH
63967: FOR_TO
63968: IFFALSE 64505
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
63970: LD_ADDR_VAR 0 5
63974: PUSH
63975: LD_EXP 60
63979: PUSH
63980: LD_VAR 0 2
63984: ARRAY
63985: PUSH
63986: LD_EXP 89
63990: PUSH
63991: LD_VAR 0 2
63995: ARRAY
63996: UNION
63997: PPUSH
63998: LD_INT 21
64000: PUSH
64001: LD_INT 1
64003: PUSH
64004: EMPTY
64005: LIST
64006: LIST
64007: PUSH
64008: LD_INT 1
64010: PUSH
64011: LD_INT 3
64013: PUSH
64014: LD_INT 54
64016: PUSH
64017: EMPTY
64018: LIST
64019: PUSH
64020: EMPTY
64021: LIST
64022: LIST
64023: PUSH
64024: LD_INT 3
64026: PUSH
64027: LD_INT 24
64029: PUSH
64030: LD_INT 1000
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: PUSH
64037: EMPTY
64038: LIST
64039: LIST
64040: PUSH
64041: EMPTY
64042: LIST
64043: LIST
64044: LIST
64045: PUSH
64046: EMPTY
64047: LIST
64048: LIST
64049: PPUSH
64050: CALL_OW 72
64054: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
64055: LD_ADDR_VAR 0 6
64059: PUSH
64060: LD_EXP 60
64064: PUSH
64065: LD_VAR 0 2
64069: ARRAY
64070: PPUSH
64071: LD_INT 21
64073: PUSH
64074: LD_INT 1
64076: PUSH
64077: EMPTY
64078: LIST
64079: LIST
64080: PUSH
64081: LD_INT 1
64083: PUSH
64084: LD_INT 3
64086: PUSH
64087: LD_INT 54
64089: PUSH
64090: EMPTY
64091: LIST
64092: PUSH
64093: EMPTY
64094: LIST
64095: LIST
64096: PUSH
64097: LD_INT 3
64099: PUSH
64100: LD_INT 24
64102: PUSH
64103: LD_INT 250
64105: PUSH
64106: EMPTY
64107: LIST
64108: LIST
64109: PUSH
64110: EMPTY
64111: LIST
64112: LIST
64113: PUSH
64114: EMPTY
64115: LIST
64116: LIST
64117: LIST
64118: PUSH
64119: EMPTY
64120: LIST
64121: LIST
64122: PPUSH
64123: CALL_OW 72
64127: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
64128: LD_ADDR_VAR 0 7
64132: PUSH
64133: LD_VAR 0 5
64137: PUSH
64138: LD_VAR 0 6
64142: DIFF
64143: ST_TO_ADDR
// if not need_heal_1 then
64144: LD_VAR 0 6
64148: NOT
64149: IFFALSE 64182
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
64151: LD_ADDR_EXP 63
64155: PUSH
64156: LD_EXP 63
64160: PPUSH
64161: LD_VAR 0 2
64165: PUSH
64166: LD_INT 1
64168: PUSH
64169: EMPTY
64170: LIST
64171: LIST
64172: PPUSH
64173: EMPTY
64174: PPUSH
64175: CALL 20003 0 3
64179: ST_TO_ADDR
64180: GO 64252
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
64182: LD_ADDR_EXP 63
64186: PUSH
64187: LD_EXP 63
64191: PPUSH
64192: LD_VAR 0 2
64196: PUSH
64197: LD_INT 1
64199: PUSH
64200: EMPTY
64201: LIST
64202: LIST
64203: PPUSH
64204: LD_EXP 63
64208: PUSH
64209: LD_VAR 0 2
64213: ARRAY
64214: PUSH
64215: LD_INT 1
64217: ARRAY
64218: PPUSH
64219: LD_INT 3
64221: PUSH
64222: LD_INT 24
64224: PUSH
64225: LD_INT 1000
64227: PUSH
64228: EMPTY
64229: LIST
64230: LIST
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: PPUSH
64236: CALL_OW 72
64240: PUSH
64241: LD_VAR 0 6
64245: UNION
64246: PPUSH
64247: CALL 20003 0 3
64251: ST_TO_ADDR
// if not need_heal_2 then
64252: LD_VAR 0 7
64256: NOT
64257: IFFALSE 64290
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
64259: LD_ADDR_EXP 63
64263: PUSH
64264: LD_EXP 63
64268: PPUSH
64269: LD_VAR 0 2
64273: PUSH
64274: LD_INT 2
64276: PUSH
64277: EMPTY
64278: LIST
64279: LIST
64280: PPUSH
64281: EMPTY
64282: PPUSH
64283: CALL 20003 0 3
64287: ST_TO_ADDR
64288: GO 64322
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
64290: LD_ADDR_EXP 63
64294: PUSH
64295: LD_EXP 63
64299: PPUSH
64300: LD_VAR 0 2
64304: PUSH
64305: LD_INT 2
64307: PUSH
64308: EMPTY
64309: LIST
64310: LIST
64311: PPUSH
64312: LD_VAR 0 7
64316: PPUSH
64317: CALL 20003 0 3
64321: ST_TO_ADDR
// if need_heal_2 then
64322: LD_VAR 0 7
64326: IFFALSE 64487
// for j in need_heal_2 do
64328: LD_ADDR_VAR 0 3
64332: PUSH
64333: LD_VAR 0 7
64337: PUSH
64338: FOR_IN
64339: IFFALSE 64485
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64341: LD_ADDR_VAR 0 5
64345: PUSH
64346: LD_EXP 60
64350: PUSH
64351: LD_VAR 0 2
64355: ARRAY
64356: PPUSH
64357: LD_INT 2
64359: PUSH
64360: LD_INT 30
64362: PUSH
64363: LD_INT 6
64365: PUSH
64366: EMPTY
64367: LIST
64368: LIST
64369: PUSH
64370: LD_INT 30
64372: PUSH
64373: LD_INT 7
64375: PUSH
64376: EMPTY
64377: LIST
64378: LIST
64379: PUSH
64380: LD_INT 30
64382: PUSH
64383: LD_INT 8
64385: PUSH
64386: EMPTY
64387: LIST
64388: LIST
64389: PUSH
64390: LD_INT 30
64392: PUSH
64393: LD_INT 0
64395: PUSH
64396: EMPTY
64397: LIST
64398: LIST
64399: PUSH
64400: LD_INT 30
64402: PUSH
64403: LD_INT 1
64405: PUSH
64406: EMPTY
64407: LIST
64408: LIST
64409: PUSH
64410: EMPTY
64411: LIST
64412: LIST
64413: LIST
64414: LIST
64415: LIST
64416: LIST
64417: PPUSH
64418: CALL_OW 72
64422: ST_TO_ADDR
// if tmp then
64423: LD_VAR 0 5
64427: IFFALSE 64483
// begin k := NearestUnitToUnit ( tmp , j ) ;
64429: LD_ADDR_VAR 0 4
64433: PUSH
64434: LD_VAR 0 5
64438: PPUSH
64439: LD_VAR 0 3
64443: PPUSH
64444: CALL_OW 74
64448: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
64449: LD_VAR 0 3
64453: PPUSH
64454: LD_VAR 0 4
64458: PPUSH
64459: CALL_OW 296
64463: PUSH
64464: LD_INT 5
64466: GREATER
64467: IFFALSE 64483
// ComMoveToNearbyEntrance ( j , k ) ;
64469: LD_VAR 0 3
64473: PPUSH
64474: LD_VAR 0 4
64478: PPUSH
64479: CALL 52565 0 2
// end ; end ;
64483: GO 64338
64485: POP
64486: POP
// if not need_heal_1 and not need_heal_2 then
64487: LD_VAR 0 6
64491: NOT
64492: PUSH
64493: LD_VAR 0 7
64497: NOT
64498: AND
64499: IFFALSE 64503
// continue ;
64501: GO 63967
// end ;
64503: GO 63967
64505: POP
64506: POP
// RaiseSailEvent ( 102 ) ;
64507: LD_INT 102
64509: PPUSH
64510: CALL_OW 427
// end ;
64514: LD_VAR 0 1
64518: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
64519: LD_INT 0
64521: PPUSH
64522: PPUSH
64523: PPUSH
64524: PPUSH
64525: PPUSH
64526: PPUSH
64527: PPUSH
64528: PPUSH
// if not mc_bases then
64529: LD_EXP 60
64533: NOT
64534: IFFALSE 64538
// exit ;
64536: GO 65421
// for i = 1 to mc_bases do
64538: LD_ADDR_VAR 0 2
64542: PUSH
64543: DOUBLE
64544: LD_INT 1
64546: DEC
64547: ST_TO_ADDR
64548: LD_EXP 60
64552: PUSH
64553: FOR_TO
64554: IFFALSE 65419
// begin if not mc_building_need_repair [ i ] then
64556: LD_EXP 61
64560: PUSH
64561: LD_VAR 0 2
64565: ARRAY
64566: NOT
64567: IFFALSE 64754
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
64569: LD_ADDR_VAR 0 6
64573: PUSH
64574: LD_EXP 79
64578: PUSH
64579: LD_VAR 0 2
64583: ARRAY
64584: PPUSH
64585: LD_INT 3
64587: PUSH
64588: LD_INT 24
64590: PUSH
64591: LD_INT 1000
64593: PUSH
64594: EMPTY
64595: LIST
64596: LIST
64597: PUSH
64598: EMPTY
64599: LIST
64600: LIST
64601: PUSH
64602: LD_INT 2
64604: PUSH
64605: LD_INT 34
64607: PUSH
64608: LD_INT 13
64610: PUSH
64611: EMPTY
64612: LIST
64613: LIST
64614: PUSH
64615: LD_INT 34
64617: PUSH
64618: LD_INT 52
64620: PUSH
64621: EMPTY
64622: LIST
64623: LIST
64624: PUSH
64625: LD_INT 34
64627: PUSH
64628: LD_EXP 110
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: PUSH
64637: EMPTY
64638: LIST
64639: LIST
64640: LIST
64641: LIST
64642: PUSH
64643: EMPTY
64644: LIST
64645: LIST
64646: PPUSH
64647: CALL_OW 72
64651: ST_TO_ADDR
// if cranes then
64652: LD_VAR 0 6
64656: IFFALSE 64718
// for j in cranes do
64658: LD_ADDR_VAR 0 3
64662: PUSH
64663: LD_VAR 0 6
64667: PUSH
64668: FOR_IN
64669: IFFALSE 64716
// if not IsInArea ( j , mc_parking [ i ] ) then
64671: LD_VAR 0 3
64675: PPUSH
64676: LD_EXP 84
64680: PUSH
64681: LD_VAR 0 2
64685: ARRAY
64686: PPUSH
64687: CALL_OW 308
64691: NOT
64692: IFFALSE 64714
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64694: LD_VAR 0 3
64698: PPUSH
64699: LD_EXP 84
64703: PUSH
64704: LD_VAR 0 2
64708: ARRAY
64709: PPUSH
64710: CALL_OW 113
64714: GO 64668
64716: POP
64717: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64718: LD_ADDR_EXP 62
64722: PUSH
64723: LD_EXP 62
64727: PPUSH
64728: LD_VAR 0 2
64732: PPUSH
64733: EMPTY
64734: PPUSH
64735: CALL_OW 1
64739: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64740: LD_VAR 0 2
64744: PPUSH
64745: LD_INT 101
64747: PPUSH
64748: CALL 59606 0 2
// continue ;
64752: GO 64553
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64754: LD_ADDR_EXP 66
64758: PUSH
64759: LD_EXP 66
64763: PPUSH
64764: LD_VAR 0 2
64768: PPUSH
64769: EMPTY
64770: PPUSH
64771: CALL_OW 1
64775: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64776: LD_VAR 0 2
64780: PPUSH
64781: LD_INT 103
64783: PPUSH
64784: CALL 59606 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64788: LD_ADDR_VAR 0 5
64792: PUSH
64793: LD_EXP 60
64797: PUSH
64798: LD_VAR 0 2
64802: ARRAY
64803: PUSH
64804: LD_EXP 89
64808: PUSH
64809: LD_VAR 0 2
64813: ARRAY
64814: UNION
64815: PPUSH
64816: LD_INT 2
64818: PUSH
64819: LD_INT 25
64821: PUSH
64822: LD_INT 2
64824: PUSH
64825: EMPTY
64826: LIST
64827: LIST
64828: PUSH
64829: LD_INT 25
64831: PUSH
64832: LD_INT 16
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PUSH
64839: EMPTY
64840: LIST
64841: LIST
64842: LIST
64843: PUSH
64844: EMPTY
64845: LIST
64846: PPUSH
64847: CALL_OW 72
64851: ST_TO_ADDR
// if mc_need_heal [ i ] then
64852: LD_EXP 63
64856: PUSH
64857: LD_VAR 0 2
64861: ARRAY
64862: IFFALSE 64906
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
64864: LD_ADDR_VAR 0 5
64868: PUSH
64869: LD_VAR 0 5
64873: PUSH
64874: LD_EXP 63
64878: PUSH
64879: LD_VAR 0 2
64883: ARRAY
64884: PUSH
64885: LD_INT 1
64887: ARRAY
64888: PUSH
64889: LD_EXP 63
64893: PUSH
64894: LD_VAR 0 2
64898: ARRAY
64899: PUSH
64900: LD_INT 2
64902: ARRAY
64903: UNION
64904: DIFF
64905: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
64906: LD_ADDR_VAR 0 6
64910: PUSH
64911: LD_EXP 79
64915: PUSH
64916: LD_VAR 0 2
64920: ARRAY
64921: PPUSH
64922: LD_INT 2
64924: PUSH
64925: LD_INT 34
64927: PUSH
64928: LD_INT 13
64930: PUSH
64931: EMPTY
64932: LIST
64933: LIST
64934: PUSH
64935: LD_INT 34
64937: PUSH
64938: LD_INT 52
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: PUSH
64945: LD_INT 34
64947: PUSH
64948: LD_EXP 110
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: EMPTY
64958: LIST
64959: LIST
64960: LIST
64961: LIST
64962: PPUSH
64963: CALL_OW 72
64967: ST_TO_ADDR
// if cranes then
64968: LD_VAR 0 6
64972: IFFALSE 65108
// begin for j in cranes do
64974: LD_ADDR_VAR 0 3
64978: PUSH
64979: LD_VAR 0 6
64983: PUSH
64984: FOR_IN
64985: IFFALSE 65106
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
64987: LD_VAR 0 3
64991: PPUSH
64992: CALL_OW 256
64996: PUSH
64997: LD_INT 1000
64999: EQUAL
65000: PUSH
65001: LD_VAR 0 3
65005: PPUSH
65006: CALL_OW 314
65010: NOT
65011: AND
65012: IFFALSE 65046
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
65014: LD_VAR 0 3
65018: PPUSH
65019: LD_EXP 61
65023: PUSH
65024: LD_VAR 0 2
65028: ARRAY
65029: PPUSH
65030: LD_VAR 0 3
65034: PPUSH
65035: CALL_OW 74
65039: PPUSH
65040: CALL_OW 130
65044: GO 65104
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
65046: LD_VAR 0 3
65050: PPUSH
65051: CALL_OW 256
65055: PUSH
65056: LD_INT 500
65058: LESS
65059: PUSH
65060: LD_VAR 0 3
65064: PPUSH
65065: LD_EXP 84
65069: PUSH
65070: LD_VAR 0 2
65074: ARRAY
65075: PPUSH
65076: CALL_OW 308
65080: NOT
65081: AND
65082: IFFALSE 65104
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65084: LD_VAR 0 3
65088: PPUSH
65089: LD_EXP 84
65093: PUSH
65094: LD_VAR 0 2
65098: ARRAY
65099: PPUSH
65100: CALL_OW 113
// end ;
65104: GO 64984
65106: POP
65107: POP
// end ; if tmp > 3 then
65108: LD_VAR 0 5
65112: PUSH
65113: LD_INT 3
65115: GREATER
65116: IFFALSE 65136
// tmp := ShrinkArray ( tmp , 4 ) ;
65118: LD_ADDR_VAR 0 5
65122: PUSH
65123: LD_VAR 0 5
65127: PPUSH
65128: LD_INT 4
65130: PPUSH
65131: CALL 52013 0 2
65135: ST_TO_ADDR
// if not tmp then
65136: LD_VAR 0 5
65140: NOT
65141: IFFALSE 65145
// continue ;
65143: GO 64553
// for j in tmp do
65145: LD_ADDR_VAR 0 3
65149: PUSH
65150: LD_VAR 0 5
65154: PUSH
65155: FOR_IN
65156: IFFALSE 65415
// begin if IsInUnit ( j ) then
65158: LD_VAR 0 3
65162: PPUSH
65163: CALL_OW 310
65167: IFFALSE 65178
// ComExitBuilding ( j ) ;
65169: LD_VAR 0 3
65173: PPUSH
65174: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
65178: LD_VAR 0 3
65182: PUSH
65183: LD_EXP 62
65187: PUSH
65188: LD_VAR 0 2
65192: ARRAY
65193: IN
65194: NOT
65195: IFFALSE 65253
// begin SetTag ( j , 101 ) ;
65197: LD_VAR 0 3
65201: PPUSH
65202: LD_INT 101
65204: PPUSH
65205: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
65209: LD_ADDR_EXP 62
65213: PUSH
65214: LD_EXP 62
65218: PPUSH
65219: LD_VAR 0 2
65223: PUSH
65224: LD_EXP 62
65228: PUSH
65229: LD_VAR 0 2
65233: ARRAY
65234: PUSH
65235: LD_INT 1
65237: PLUS
65238: PUSH
65239: EMPTY
65240: LIST
65241: LIST
65242: PPUSH
65243: LD_VAR 0 3
65247: PPUSH
65248: CALL 20003 0 3
65252: ST_TO_ADDR
// end ; wait ( 1 ) ;
65253: LD_INT 1
65255: PPUSH
65256: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
65260: LD_ADDR_VAR 0 7
65264: PUSH
65265: LD_EXP 61
65269: PUSH
65270: LD_VAR 0 2
65274: ARRAY
65275: ST_TO_ADDR
// if mc_scan [ i ] then
65276: LD_EXP 83
65280: PUSH
65281: LD_VAR 0 2
65285: ARRAY
65286: IFFALSE 65348
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
65288: LD_ADDR_VAR 0 7
65292: PUSH
65293: LD_EXP 61
65297: PUSH
65298: LD_VAR 0 2
65302: ARRAY
65303: PPUSH
65304: LD_INT 3
65306: PUSH
65307: LD_INT 30
65309: PUSH
65310: LD_INT 32
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: LD_INT 30
65319: PUSH
65320: LD_INT 33
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: PUSH
65327: LD_INT 30
65329: PUSH
65330: LD_INT 31
65332: PUSH
65333: EMPTY
65334: LIST
65335: LIST
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: LIST
65341: LIST
65342: PPUSH
65343: CALL_OW 72
65347: ST_TO_ADDR
// if not to_repair_tmp then
65348: LD_VAR 0 7
65352: NOT
65353: IFFALSE 65357
// continue ;
65355: GO 65155
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
65357: LD_ADDR_VAR 0 8
65361: PUSH
65362: LD_VAR 0 7
65366: PPUSH
65367: LD_VAR 0 3
65371: PPUSH
65372: CALL_OW 74
65376: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
65377: LD_VAR 0 8
65381: PPUSH
65382: LD_INT 16
65384: PPUSH
65385: CALL 22602 0 2
65389: PUSH
65390: LD_INT 4
65392: ARRAY
65393: PUSH
65394: LD_INT 10
65396: LESS
65397: IFFALSE 65413
// ComRepairBuilding ( j , to_repair ) ;
65399: LD_VAR 0 3
65403: PPUSH
65404: LD_VAR 0 8
65408: PPUSH
65409: CALL_OW 130
// end ;
65413: GO 65155
65415: POP
65416: POP
// end ;
65417: GO 64553
65419: POP
65420: POP
// end ;
65421: LD_VAR 0 1
65425: RET
// export function MC_Heal ; var i , j , tmp ; begin
65426: LD_INT 0
65428: PPUSH
65429: PPUSH
65430: PPUSH
65431: PPUSH
// if not mc_bases then
65432: LD_EXP 60
65436: NOT
65437: IFFALSE 65441
// exit ;
65439: GO 65843
// for i = 1 to mc_bases do
65441: LD_ADDR_VAR 0 2
65445: PUSH
65446: DOUBLE
65447: LD_INT 1
65449: DEC
65450: ST_TO_ADDR
65451: LD_EXP 60
65455: PUSH
65456: FOR_TO
65457: IFFALSE 65841
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
65459: LD_EXP 63
65463: PUSH
65464: LD_VAR 0 2
65468: ARRAY
65469: PUSH
65470: LD_INT 1
65472: ARRAY
65473: NOT
65474: PUSH
65475: LD_EXP 63
65479: PUSH
65480: LD_VAR 0 2
65484: ARRAY
65485: PUSH
65486: LD_INT 2
65488: ARRAY
65489: NOT
65490: AND
65491: IFFALSE 65529
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
65493: LD_ADDR_EXP 64
65497: PUSH
65498: LD_EXP 64
65502: PPUSH
65503: LD_VAR 0 2
65507: PPUSH
65508: EMPTY
65509: PPUSH
65510: CALL_OW 1
65514: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
65515: LD_VAR 0 2
65519: PPUSH
65520: LD_INT 102
65522: PPUSH
65523: CALL 59606 0 2
// continue ;
65527: GO 65456
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
65529: LD_ADDR_VAR 0 4
65533: PUSH
65534: LD_EXP 60
65538: PUSH
65539: LD_VAR 0 2
65543: ARRAY
65544: PPUSH
65545: LD_INT 25
65547: PUSH
65548: LD_INT 4
65550: PUSH
65551: EMPTY
65552: LIST
65553: LIST
65554: PPUSH
65555: CALL_OW 72
65559: ST_TO_ADDR
// if not tmp then
65560: LD_VAR 0 4
65564: NOT
65565: IFFALSE 65569
// continue ;
65567: GO 65456
// if mc_taming [ i ] then
65569: LD_EXP 91
65573: PUSH
65574: LD_VAR 0 2
65578: ARRAY
65579: IFFALSE 65603
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65581: LD_ADDR_EXP 91
65585: PUSH
65586: LD_EXP 91
65590: PPUSH
65591: LD_VAR 0 2
65595: PPUSH
65596: EMPTY
65597: PPUSH
65598: CALL_OW 1
65602: ST_TO_ADDR
// for j in tmp do
65603: LD_ADDR_VAR 0 3
65607: PUSH
65608: LD_VAR 0 4
65612: PUSH
65613: FOR_IN
65614: IFFALSE 65837
// begin if IsInUnit ( j ) then
65616: LD_VAR 0 3
65620: PPUSH
65621: CALL_OW 310
65625: IFFALSE 65636
// ComExitBuilding ( j ) ;
65627: LD_VAR 0 3
65631: PPUSH
65632: CALL_OW 122
// if not j in mc_healers [ i ] then
65636: LD_VAR 0 3
65640: PUSH
65641: LD_EXP 64
65645: PUSH
65646: LD_VAR 0 2
65650: ARRAY
65651: IN
65652: NOT
65653: IFFALSE 65699
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
65655: LD_ADDR_EXP 64
65659: PUSH
65660: LD_EXP 64
65664: PPUSH
65665: LD_VAR 0 2
65669: PUSH
65670: LD_EXP 64
65674: PUSH
65675: LD_VAR 0 2
65679: ARRAY
65680: PUSH
65681: LD_INT 1
65683: PLUS
65684: PUSH
65685: EMPTY
65686: LIST
65687: LIST
65688: PPUSH
65689: LD_VAR 0 3
65693: PPUSH
65694: CALL 20003 0 3
65698: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
65699: LD_VAR 0 3
65703: PPUSH
65704: CALL_OW 110
65708: PUSH
65709: LD_INT 102
65711: NONEQUAL
65712: IFFALSE 65726
// SetTag ( j , 102 ) ;
65714: LD_VAR 0 3
65718: PPUSH
65719: LD_INT 102
65721: PPUSH
65722: CALL_OW 109
// Wait ( 3 ) ;
65726: LD_INT 3
65728: PPUSH
65729: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
65733: LD_EXP 63
65737: PUSH
65738: LD_VAR 0 2
65742: ARRAY
65743: PUSH
65744: LD_INT 1
65746: ARRAY
65747: IFFALSE 65779
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
65749: LD_VAR 0 3
65753: PPUSH
65754: LD_EXP 63
65758: PUSH
65759: LD_VAR 0 2
65763: ARRAY
65764: PUSH
65765: LD_INT 1
65767: ARRAY
65768: PUSH
65769: LD_INT 1
65771: ARRAY
65772: PPUSH
65773: CALL_OW 128
65777: GO 65835
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65779: LD_VAR 0 3
65783: PPUSH
65784: CALL_OW 314
65788: NOT
65789: PUSH
65790: LD_EXP 63
65794: PUSH
65795: LD_VAR 0 2
65799: ARRAY
65800: PUSH
65801: LD_INT 2
65803: ARRAY
65804: AND
65805: IFFALSE 65835
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65807: LD_VAR 0 3
65811: PPUSH
65812: LD_EXP 63
65816: PUSH
65817: LD_VAR 0 2
65821: ARRAY
65822: PUSH
65823: LD_INT 2
65825: ARRAY
65826: PUSH
65827: LD_INT 1
65829: ARRAY
65830: PPUSH
65831: CALL_OW 128
// end ;
65835: GO 65613
65837: POP
65838: POP
// end ;
65839: GO 65456
65841: POP
65842: POP
// end ;
65843: LD_VAR 0 1
65847: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
65848: LD_INT 0
65850: PPUSH
65851: PPUSH
65852: PPUSH
65853: PPUSH
65854: PPUSH
// if not mc_bases then
65855: LD_EXP 60
65859: NOT
65860: IFFALSE 65864
// exit ;
65862: GO 67035
// for i = 1 to mc_bases do
65864: LD_ADDR_VAR 0 2
65868: PUSH
65869: DOUBLE
65870: LD_INT 1
65872: DEC
65873: ST_TO_ADDR
65874: LD_EXP 60
65878: PUSH
65879: FOR_TO
65880: IFFALSE 67033
// begin if mc_scan [ i ] then
65882: LD_EXP 83
65886: PUSH
65887: LD_VAR 0 2
65891: ARRAY
65892: IFFALSE 65896
// continue ;
65894: GO 65879
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65896: LD_EXP 65
65900: PUSH
65901: LD_VAR 0 2
65905: ARRAY
65906: NOT
65907: PUSH
65908: LD_EXP 67
65912: PUSH
65913: LD_VAR 0 2
65917: ARRAY
65918: NOT
65919: AND
65920: PUSH
65921: LD_EXP 66
65925: PUSH
65926: LD_VAR 0 2
65930: ARRAY
65931: AND
65932: IFFALSE 65970
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65934: LD_ADDR_EXP 66
65938: PUSH
65939: LD_EXP 66
65943: PPUSH
65944: LD_VAR 0 2
65948: PPUSH
65949: EMPTY
65950: PPUSH
65951: CALL_OW 1
65955: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65956: LD_VAR 0 2
65960: PPUSH
65961: LD_INT 103
65963: PPUSH
65964: CALL 59606 0 2
// continue ;
65968: GO 65879
// end ; if mc_construct_list [ i ] then
65970: LD_EXP 67
65974: PUSH
65975: LD_VAR 0 2
65979: ARRAY
65980: IFFALSE 66200
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65982: LD_ADDR_VAR 0 4
65986: PUSH
65987: LD_EXP 60
65991: PUSH
65992: LD_VAR 0 2
65996: ARRAY
65997: PPUSH
65998: LD_INT 25
66000: PUSH
66001: LD_INT 2
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PPUSH
66008: CALL_OW 72
66012: PUSH
66013: LD_EXP 62
66017: PUSH
66018: LD_VAR 0 2
66022: ARRAY
66023: DIFF
66024: ST_TO_ADDR
// if not tmp then
66025: LD_VAR 0 4
66029: NOT
66030: IFFALSE 66034
// continue ;
66032: GO 65879
// for j in tmp do
66034: LD_ADDR_VAR 0 3
66038: PUSH
66039: LD_VAR 0 4
66043: PUSH
66044: FOR_IN
66045: IFFALSE 66196
// begin if not mc_builders [ i ] then
66047: LD_EXP 66
66051: PUSH
66052: LD_VAR 0 2
66056: ARRAY
66057: NOT
66058: IFFALSE 66116
// begin SetTag ( j , 103 ) ;
66060: LD_VAR 0 3
66064: PPUSH
66065: LD_INT 103
66067: PPUSH
66068: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66072: LD_ADDR_EXP 66
66076: PUSH
66077: LD_EXP 66
66081: PPUSH
66082: LD_VAR 0 2
66086: PUSH
66087: LD_EXP 66
66091: PUSH
66092: LD_VAR 0 2
66096: ARRAY
66097: PUSH
66098: LD_INT 1
66100: PLUS
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: PPUSH
66106: LD_VAR 0 3
66110: PPUSH
66111: CALL 20003 0 3
66115: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66116: LD_VAR 0 3
66120: PPUSH
66121: CALL_OW 310
66125: IFFALSE 66136
// ComExitBuilding ( j ) ;
66127: LD_VAR 0 3
66131: PPUSH
66132: CALL_OW 122
// wait ( 3 ) ;
66136: LD_INT 3
66138: PPUSH
66139: CALL_OW 67
// if not mc_construct_list [ i ] then
66143: LD_EXP 67
66147: PUSH
66148: LD_VAR 0 2
66152: ARRAY
66153: NOT
66154: IFFALSE 66158
// break ;
66156: GO 66196
// if not HasTask ( j ) then
66158: LD_VAR 0 3
66162: PPUSH
66163: CALL_OW 314
66167: NOT
66168: IFFALSE 66194
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
66170: LD_VAR 0 3
66174: PPUSH
66175: LD_EXP 67
66179: PUSH
66180: LD_VAR 0 2
66184: ARRAY
66185: PUSH
66186: LD_INT 1
66188: ARRAY
66189: PPUSH
66190: CALL 22866 0 2
// end ;
66194: GO 66044
66196: POP
66197: POP
// end else
66198: GO 67031
// if mc_build_list [ i ] then
66200: LD_EXP 65
66204: PUSH
66205: LD_VAR 0 2
66209: ARRAY
66210: IFFALSE 67031
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66212: LD_ADDR_VAR 0 5
66216: PUSH
66217: LD_EXP 60
66221: PUSH
66222: LD_VAR 0 2
66226: ARRAY
66227: PPUSH
66228: LD_INT 2
66230: PUSH
66231: LD_INT 30
66233: PUSH
66234: LD_INT 0
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: PUSH
66241: LD_INT 30
66243: PUSH
66244: LD_INT 1
66246: PUSH
66247: EMPTY
66248: LIST
66249: LIST
66250: PUSH
66251: EMPTY
66252: LIST
66253: LIST
66254: LIST
66255: PPUSH
66256: CALL_OW 72
66260: ST_TO_ADDR
// if depot then
66261: LD_VAR 0 5
66265: IFFALSE 66283
// depot := depot [ 1 ] else
66267: LD_ADDR_VAR 0 5
66271: PUSH
66272: LD_VAR 0 5
66276: PUSH
66277: LD_INT 1
66279: ARRAY
66280: ST_TO_ADDR
66281: GO 66291
// depot := 0 ;
66283: LD_ADDR_VAR 0 5
66287: PUSH
66288: LD_INT 0
66290: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
66291: LD_EXP 65
66295: PUSH
66296: LD_VAR 0 2
66300: ARRAY
66301: PUSH
66302: LD_INT 1
66304: ARRAY
66305: PUSH
66306: LD_INT 1
66308: ARRAY
66309: PPUSH
66310: CALL 22690 0 1
66314: PUSH
66315: LD_EXP 60
66319: PUSH
66320: LD_VAR 0 2
66324: ARRAY
66325: PPUSH
66326: LD_INT 2
66328: PUSH
66329: LD_INT 30
66331: PUSH
66332: LD_INT 2
66334: PUSH
66335: EMPTY
66336: LIST
66337: LIST
66338: PUSH
66339: LD_INT 30
66341: PUSH
66342: LD_INT 3
66344: PUSH
66345: EMPTY
66346: LIST
66347: LIST
66348: PUSH
66349: EMPTY
66350: LIST
66351: LIST
66352: LIST
66353: PPUSH
66354: CALL_OW 72
66358: NOT
66359: AND
66360: IFFALSE 66465
// begin for j = 1 to mc_build_list [ i ] do
66362: LD_ADDR_VAR 0 3
66366: PUSH
66367: DOUBLE
66368: LD_INT 1
66370: DEC
66371: ST_TO_ADDR
66372: LD_EXP 65
66376: PUSH
66377: LD_VAR 0 2
66381: ARRAY
66382: PUSH
66383: FOR_TO
66384: IFFALSE 66463
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
66386: LD_EXP 65
66390: PUSH
66391: LD_VAR 0 2
66395: ARRAY
66396: PUSH
66397: LD_VAR 0 3
66401: ARRAY
66402: PUSH
66403: LD_INT 1
66405: ARRAY
66406: PUSH
66407: LD_INT 2
66409: EQUAL
66410: IFFALSE 66461
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
66412: LD_ADDR_EXP 65
66416: PUSH
66417: LD_EXP 65
66421: PPUSH
66422: LD_VAR 0 2
66426: PPUSH
66427: LD_EXP 65
66431: PUSH
66432: LD_VAR 0 2
66436: ARRAY
66437: PPUSH
66438: LD_VAR 0 3
66442: PPUSH
66443: LD_INT 1
66445: PPUSH
66446: LD_INT 0
66448: PPUSH
66449: CALL 19421 0 4
66453: PPUSH
66454: CALL_OW 1
66458: ST_TO_ADDR
// break ;
66459: GO 66463
// end ;
66461: GO 66383
66463: POP
66464: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
66465: LD_EXP 65
66469: PUSH
66470: LD_VAR 0 2
66474: ARRAY
66475: PUSH
66476: LD_INT 1
66478: ARRAY
66479: PUSH
66480: LD_INT 1
66482: ARRAY
66483: PUSH
66484: LD_INT 0
66486: EQUAL
66487: PUSH
66488: LD_VAR 0 5
66492: PUSH
66493: LD_VAR 0 5
66497: PPUSH
66498: LD_EXP 65
66502: PUSH
66503: LD_VAR 0 2
66507: ARRAY
66508: PUSH
66509: LD_INT 1
66511: ARRAY
66512: PUSH
66513: LD_INT 1
66515: ARRAY
66516: PPUSH
66517: LD_EXP 65
66521: PUSH
66522: LD_VAR 0 2
66526: ARRAY
66527: PUSH
66528: LD_INT 1
66530: ARRAY
66531: PUSH
66532: LD_INT 2
66534: ARRAY
66535: PPUSH
66536: LD_EXP 65
66540: PUSH
66541: LD_VAR 0 2
66545: ARRAY
66546: PUSH
66547: LD_INT 1
66549: ARRAY
66550: PUSH
66551: LD_INT 3
66553: ARRAY
66554: PPUSH
66555: LD_EXP 65
66559: PUSH
66560: LD_VAR 0 2
66564: ARRAY
66565: PUSH
66566: LD_INT 1
66568: ARRAY
66569: PUSH
66570: LD_INT 4
66572: ARRAY
66573: PPUSH
66574: CALL 28106 0 5
66578: AND
66579: OR
66580: IFFALSE 66861
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66582: LD_ADDR_VAR 0 4
66586: PUSH
66587: LD_EXP 60
66591: PUSH
66592: LD_VAR 0 2
66596: ARRAY
66597: PPUSH
66598: LD_INT 25
66600: PUSH
66601: LD_INT 2
66603: PUSH
66604: EMPTY
66605: LIST
66606: LIST
66607: PPUSH
66608: CALL_OW 72
66612: PUSH
66613: LD_EXP 62
66617: PUSH
66618: LD_VAR 0 2
66622: ARRAY
66623: DIFF
66624: ST_TO_ADDR
// if not tmp then
66625: LD_VAR 0 4
66629: NOT
66630: IFFALSE 66634
// continue ;
66632: GO 65879
// for j in tmp do
66634: LD_ADDR_VAR 0 3
66638: PUSH
66639: LD_VAR 0 4
66643: PUSH
66644: FOR_IN
66645: IFFALSE 66857
// begin if not mc_builders [ i ] then
66647: LD_EXP 66
66651: PUSH
66652: LD_VAR 0 2
66656: ARRAY
66657: NOT
66658: IFFALSE 66716
// begin SetTag ( j , 103 ) ;
66660: LD_VAR 0 3
66664: PPUSH
66665: LD_INT 103
66667: PPUSH
66668: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66672: LD_ADDR_EXP 66
66676: PUSH
66677: LD_EXP 66
66681: PPUSH
66682: LD_VAR 0 2
66686: PUSH
66687: LD_EXP 66
66691: PUSH
66692: LD_VAR 0 2
66696: ARRAY
66697: PUSH
66698: LD_INT 1
66700: PLUS
66701: PUSH
66702: EMPTY
66703: LIST
66704: LIST
66705: PPUSH
66706: LD_VAR 0 3
66710: PPUSH
66711: CALL 20003 0 3
66715: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66716: LD_VAR 0 3
66720: PPUSH
66721: CALL_OW 310
66725: IFFALSE 66736
// ComExitBuilding ( j ) ;
66727: LD_VAR 0 3
66731: PPUSH
66732: CALL_OW 122
// wait ( 3 ) ;
66736: LD_INT 3
66738: PPUSH
66739: CALL_OW 67
// if not mc_build_list [ i ] then
66743: LD_EXP 65
66747: PUSH
66748: LD_VAR 0 2
66752: ARRAY
66753: NOT
66754: IFFALSE 66758
// break ;
66756: GO 66857
// if not HasTask ( j ) then
66758: LD_VAR 0 3
66762: PPUSH
66763: CALL_OW 314
66767: NOT
66768: IFFALSE 66855
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66770: LD_VAR 0 3
66774: PPUSH
66775: LD_EXP 65
66779: PUSH
66780: LD_VAR 0 2
66784: ARRAY
66785: PUSH
66786: LD_INT 1
66788: ARRAY
66789: PUSH
66790: LD_INT 1
66792: ARRAY
66793: PPUSH
66794: LD_EXP 65
66798: PUSH
66799: LD_VAR 0 2
66803: ARRAY
66804: PUSH
66805: LD_INT 1
66807: ARRAY
66808: PUSH
66809: LD_INT 2
66811: ARRAY
66812: PPUSH
66813: LD_EXP 65
66817: PUSH
66818: LD_VAR 0 2
66822: ARRAY
66823: PUSH
66824: LD_INT 1
66826: ARRAY
66827: PUSH
66828: LD_INT 3
66830: ARRAY
66831: PPUSH
66832: LD_EXP 65
66836: PUSH
66837: LD_VAR 0 2
66841: ARRAY
66842: PUSH
66843: LD_INT 1
66845: ARRAY
66846: PUSH
66847: LD_INT 4
66849: ARRAY
66850: PPUSH
66851: CALL_OW 145
// end ;
66855: GO 66644
66857: POP
66858: POP
// end else
66859: GO 67031
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
66861: LD_EXP 60
66865: PUSH
66866: LD_VAR 0 2
66870: ARRAY
66871: PPUSH
66872: LD_EXP 65
66876: PUSH
66877: LD_VAR 0 2
66881: ARRAY
66882: PUSH
66883: LD_INT 1
66885: ARRAY
66886: PUSH
66887: LD_INT 1
66889: ARRAY
66890: PPUSH
66891: LD_EXP 65
66895: PUSH
66896: LD_VAR 0 2
66900: ARRAY
66901: PUSH
66902: LD_INT 1
66904: ARRAY
66905: PUSH
66906: LD_INT 2
66908: ARRAY
66909: PPUSH
66910: LD_EXP 65
66914: PUSH
66915: LD_VAR 0 2
66919: ARRAY
66920: PUSH
66921: LD_INT 1
66923: ARRAY
66924: PUSH
66925: LD_INT 3
66927: ARRAY
66928: PPUSH
66929: LD_EXP 65
66933: PUSH
66934: LD_VAR 0 2
66938: ARRAY
66939: PUSH
66940: LD_INT 1
66942: ARRAY
66943: PUSH
66944: LD_INT 4
66946: ARRAY
66947: PPUSH
66948: LD_EXP 60
66952: PUSH
66953: LD_VAR 0 2
66957: ARRAY
66958: PPUSH
66959: LD_INT 21
66961: PUSH
66962: LD_INT 3
66964: PUSH
66965: EMPTY
66966: LIST
66967: LIST
66968: PPUSH
66969: CALL_OW 72
66973: PPUSH
66974: EMPTY
66975: PPUSH
66976: CALL 26856 0 7
66980: NOT
66981: IFFALSE 67031
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66983: LD_ADDR_EXP 65
66987: PUSH
66988: LD_EXP 65
66992: PPUSH
66993: LD_VAR 0 2
66997: PPUSH
66998: LD_EXP 65
67002: PUSH
67003: LD_VAR 0 2
67007: ARRAY
67008: PPUSH
67009: LD_INT 1
67011: PPUSH
67012: LD_INT 1
67014: NEG
67015: PPUSH
67016: LD_INT 0
67018: PPUSH
67019: CALL 19421 0 4
67023: PPUSH
67024: CALL_OW 1
67028: ST_TO_ADDR
// continue ;
67029: GO 65879
// end ; end ; end ;
67031: GO 65879
67033: POP
67034: POP
// end ;
67035: LD_VAR 0 1
67039: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
67040: LD_INT 0
67042: PPUSH
67043: PPUSH
67044: PPUSH
67045: PPUSH
67046: PPUSH
67047: PPUSH
// if not mc_bases then
67048: LD_EXP 60
67052: NOT
67053: IFFALSE 67057
// exit ;
67055: GO 67484
// for i = 1 to mc_bases do
67057: LD_ADDR_VAR 0 2
67061: PUSH
67062: DOUBLE
67063: LD_INT 1
67065: DEC
67066: ST_TO_ADDR
67067: LD_EXP 60
67071: PUSH
67072: FOR_TO
67073: IFFALSE 67482
// begin tmp := mc_build_upgrade [ i ] ;
67075: LD_ADDR_VAR 0 4
67079: PUSH
67080: LD_EXP 92
67084: PUSH
67085: LD_VAR 0 2
67089: ARRAY
67090: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
67091: LD_ADDR_VAR 0 6
67095: PUSH
67096: LD_EXP 93
67100: PUSH
67101: LD_VAR 0 2
67105: ARRAY
67106: PPUSH
67107: LD_INT 2
67109: PUSH
67110: LD_INT 30
67112: PUSH
67113: LD_INT 6
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 30
67122: PUSH
67123: LD_INT 7
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: LIST
67134: PPUSH
67135: CALL_OW 72
67139: ST_TO_ADDR
// if not tmp and not lab then
67140: LD_VAR 0 4
67144: NOT
67145: PUSH
67146: LD_VAR 0 6
67150: NOT
67151: AND
67152: IFFALSE 67156
// continue ;
67154: GO 67072
// if tmp then
67156: LD_VAR 0 4
67160: IFFALSE 67280
// for j in tmp do
67162: LD_ADDR_VAR 0 3
67166: PUSH
67167: LD_VAR 0 4
67171: PUSH
67172: FOR_IN
67173: IFFALSE 67278
// begin if UpgradeCost ( j ) then
67175: LD_VAR 0 3
67179: PPUSH
67180: CALL 26516 0 1
67184: IFFALSE 67276
// begin ComUpgrade ( j ) ;
67186: LD_VAR 0 3
67190: PPUSH
67191: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
67195: LD_ADDR_EXP 92
67199: PUSH
67200: LD_EXP 92
67204: PPUSH
67205: LD_VAR 0 2
67209: PPUSH
67210: LD_EXP 92
67214: PUSH
67215: LD_VAR 0 2
67219: ARRAY
67220: PUSH
67221: LD_VAR 0 3
67225: DIFF
67226: PPUSH
67227: CALL_OW 1
67231: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67232: LD_ADDR_EXP 67
67236: PUSH
67237: LD_EXP 67
67241: PPUSH
67242: LD_VAR 0 2
67246: PUSH
67247: LD_EXP 67
67251: PUSH
67252: LD_VAR 0 2
67256: ARRAY
67257: PUSH
67258: LD_INT 1
67260: PLUS
67261: PUSH
67262: EMPTY
67263: LIST
67264: LIST
67265: PPUSH
67266: LD_VAR 0 3
67270: PPUSH
67271: CALL 20003 0 3
67275: ST_TO_ADDR
// end ; end ;
67276: GO 67172
67278: POP
67279: POP
// if not lab or not mc_lab_upgrade [ i ] then
67280: LD_VAR 0 6
67284: NOT
67285: PUSH
67286: LD_EXP 94
67290: PUSH
67291: LD_VAR 0 2
67295: ARRAY
67296: NOT
67297: OR
67298: IFFALSE 67302
// continue ;
67300: GO 67072
// for j in lab do
67302: LD_ADDR_VAR 0 3
67306: PUSH
67307: LD_VAR 0 6
67311: PUSH
67312: FOR_IN
67313: IFFALSE 67478
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
67315: LD_VAR 0 3
67319: PPUSH
67320: CALL_OW 266
67324: PUSH
67325: LD_INT 6
67327: PUSH
67328: LD_INT 7
67330: PUSH
67331: EMPTY
67332: LIST
67333: LIST
67334: IN
67335: PUSH
67336: LD_VAR 0 3
67340: PPUSH
67341: CALL_OW 461
67345: PUSH
67346: LD_INT 1
67348: NONEQUAL
67349: AND
67350: IFFALSE 67476
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
67352: LD_VAR 0 3
67356: PPUSH
67357: LD_EXP 94
67361: PUSH
67362: LD_VAR 0 2
67366: ARRAY
67367: PUSH
67368: LD_INT 1
67370: ARRAY
67371: PPUSH
67372: CALL 26721 0 2
67376: IFFALSE 67476
// begin ComCancel ( j ) ;
67378: LD_VAR 0 3
67382: PPUSH
67383: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
67387: LD_VAR 0 3
67391: PPUSH
67392: LD_EXP 94
67396: PUSH
67397: LD_VAR 0 2
67401: ARRAY
67402: PUSH
67403: LD_INT 1
67405: ARRAY
67406: PPUSH
67407: CALL_OW 207
// if not j in mc_construct_list [ i ] then
67411: LD_VAR 0 3
67415: PUSH
67416: LD_EXP 67
67420: PUSH
67421: LD_VAR 0 2
67425: ARRAY
67426: IN
67427: NOT
67428: IFFALSE 67474
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67430: LD_ADDR_EXP 67
67434: PUSH
67435: LD_EXP 67
67439: PPUSH
67440: LD_VAR 0 2
67444: PUSH
67445: LD_EXP 67
67449: PUSH
67450: LD_VAR 0 2
67454: ARRAY
67455: PUSH
67456: LD_INT 1
67458: PLUS
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PPUSH
67464: LD_VAR 0 3
67468: PPUSH
67469: CALL 20003 0 3
67473: ST_TO_ADDR
// break ;
67474: GO 67478
// end ; end ; end ;
67476: GO 67312
67478: POP
67479: POP
// end ;
67480: GO 67072
67482: POP
67483: POP
// end ;
67484: LD_VAR 0 1
67488: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
67489: LD_INT 0
67491: PPUSH
67492: PPUSH
67493: PPUSH
67494: PPUSH
67495: PPUSH
67496: PPUSH
67497: PPUSH
67498: PPUSH
67499: PPUSH
// if not mc_bases then
67500: LD_EXP 60
67504: NOT
67505: IFFALSE 67509
// exit ;
67507: GO 67914
// for i = 1 to mc_bases do
67509: LD_ADDR_VAR 0 2
67513: PUSH
67514: DOUBLE
67515: LD_INT 1
67517: DEC
67518: ST_TO_ADDR
67519: LD_EXP 60
67523: PUSH
67524: FOR_TO
67525: IFFALSE 67912
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
67527: LD_EXP 68
67531: PUSH
67532: LD_VAR 0 2
67536: ARRAY
67537: NOT
67538: PUSH
67539: LD_EXP 60
67543: PUSH
67544: LD_VAR 0 2
67548: ARRAY
67549: PPUSH
67550: LD_INT 30
67552: PUSH
67553: LD_INT 3
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PPUSH
67560: CALL_OW 72
67564: NOT
67565: OR
67566: IFFALSE 67570
// continue ;
67568: GO 67524
// busy := false ;
67570: LD_ADDR_VAR 0 8
67574: PUSH
67575: LD_INT 0
67577: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67578: LD_ADDR_VAR 0 4
67582: PUSH
67583: LD_EXP 60
67587: PUSH
67588: LD_VAR 0 2
67592: ARRAY
67593: PPUSH
67594: LD_INT 30
67596: PUSH
67597: LD_INT 3
67599: PUSH
67600: EMPTY
67601: LIST
67602: LIST
67603: PPUSH
67604: CALL_OW 72
67608: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
67609: LD_ADDR_VAR 0 6
67613: PUSH
67614: LD_EXP 68
67618: PUSH
67619: LD_VAR 0 2
67623: ARRAY
67624: PPUSH
67625: LD_INT 2
67627: PUSH
67628: LD_INT 30
67630: PUSH
67631: LD_INT 32
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 30
67640: PUSH
67641: LD_INT 33
67643: PUSH
67644: EMPTY
67645: LIST
67646: LIST
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: LIST
67652: PPUSH
67653: CALL_OW 72
67657: ST_TO_ADDR
// if not t then
67658: LD_VAR 0 6
67662: NOT
67663: IFFALSE 67667
// continue ;
67665: GO 67524
// for j in tmp do
67667: LD_ADDR_VAR 0 3
67671: PUSH
67672: LD_VAR 0 4
67676: PUSH
67677: FOR_IN
67678: IFFALSE 67708
// if not BuildingStatus ( j ) = bs_idle then
67680: LD_VAR 0 3
67684: PPUSH
67685: CALL_OW 461
67689: PUSH
67690: LD_INT 2
67692: EQUAL
67693: NOT
67694: IFFALSE 67706
// begin busy := true ;
67696: LD_ADDR_VAR 0 8
67700: PUSH
67701: LD_INT 1
67703: ST_TO_ADDR
// break ;
67704: GO 67708
// end ;
67706: GO 67677
67708: POP
67709: POP
// if busy then
67710: LD_VAR 0 8
67714: IFFALSE 67718
// continue ;
67716: GO 67524
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
67718: LD_ADDR_VAR 0 7
67722: PUSH
67723: LD_VAR 0 6
67727: PPUSH
67728: LD_INT 35
67730: PUSH
67731: LD_INT 0
67733: PUSH
67734: EMPTY
67735: LIST
67736: LIST
67737: PPUSH
67738: CALL_OW 72
67742: ST_TO_ADDR
// if tw then
67743: LD_VAR 0 7
67747: IFFALSE 67824
// begin tw := tw [ 1 ] ;
67749: LD_ADDR_VAR 0 7
67753: PUSH
67754: LD_VAR 0 7
67758: PUSH
67759: LD_INT 1
67761: ARRAY
67762: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
67763: LD_ADDR_VAR 0 9
67767: PUSH
67768: LD_VAR 0 7
67772: PPUSH
67773: LD_EXP 85
67777: PUSH
67778: LD_VAR 0 2
67782: ARRAY
67783: PPUSH
67784: CALL 25013 0 2
67788: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67789: LD_EXP 99
67793: PUSH
67794: LD_VAR 0 2
67798: ARRAY
67799: IFFALSE 67822
// if not weapon in mc_allowed_tower_weapons [ i ] then
67801: LD_VAR 0 9
67805: PUSH
67806: LD_EXP 99
67810: PUSH
67811: LD_VAR 0 2
67815: ARRAY
67816: IN
67817: NOT
67818: IFFALSE 67822
// continue ;
67820: GO 67524
// end else
67822: GO 67887
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67824: LD_ADDR_VAR 0 5
67828: PUSH
67829: LD_EXP 68
67833: PUSH
67834: LD_VAR 0 2
67838: ARRAY
67839: PPUSH
67840: LD_VAR 0 4
67844: PPUSH
67845: CALL 51246 0 2
67849: ST_TO_ADDR
// if not tmp2 then
67850: LD_VAR 0 5
67854: NOT
67855: IFFALSE 67859
// continue ;
67857: GO 67524
// tw := tmp2 [ 1 ] ;
67859: LD_ADDR_VAR 0 7
67863: PUSH
67864: LD_VAR 0 5
67868: PUSH
67869: LD_INT 1
67871: ARRAY
67872: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67873: LD_ADDR_VAR 0 9
67877: PUSH
67878: LD_VAR 0 5
67882: PUSH
67883: LD_INT 2
67885: ARRAY
67886: ST_TO_ADDR
// end ; if not weapon then
67887: LD_VAR 0 9
67891: NOT
67892: IFFALSE 67896
// continue ;
67894: GO 67524
// ComPlaceWeapon ( tw , weapon ) ;
67896: LD_VAR 0 7
67900: PPUSH
67901: LD_VAR 0 9
67905: PPUSH
67906: CALL_OW 148
// end ;
67910: GO 67524
67912: POP
67913: POP
// end ;
67914: LD_VAR 0 1
67918: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
67919: LD_INT 0
67921: PPUSH
67922: PPUSH
67923: PPUSH
67924: PPUSH
67925: PPUSH
67926: PPUSH
67927: PPUSH
// if not mc_bases then
67928: LD_EXP 60
67932: NOT
67933: IFFALSE 67937
// exit ;
67935: GO 68705
// for i = 1 to mc_bases do
67937: LD_ADDR_VAR 0 2
67941: PUSH
67942: DOUBLE
67943: LD_INT 1
67945: DEC
67946: ST_TO_ADDR
67947: LD_EXP 60
67951: PUSH
67952: FOR_TO
67953: IFFALSE 68703
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
67955: LD_EXP 73
67959: PUSH
67960: LD_VAR 0 2
67964: ARRAY
67965: NOT
67966: PUSH
67967: LD_EXP 73
67971: PUSH
67972: LD_VAR 0 2
67976: ARRAY
67977: PUSH
67978: LD_EXP 74
67982: PUSH
67983: LD_VAR 0 2
67987: ARRAY
67988: EQUAL
67989: OR
67990: PUSH
67991: LD_EXP 83
67995: PUSH
67996: LD_VAR 0 2
68000: ARRAY
68001: OR
68002: IFFALSE 68006
// continue ;
68004: GO 67952
// if mc_miners [ i ] then
68006: LD_EXP 74
68010: PUSH
68011: LD_VAR 0 2
68015: ARRAY
68016: IFFALSE 68390
// begin for j = mc_miners [ i ] downto 1 do
68018: LD_ADDR_VAR 0 3
68022: PUSH
68023: DOUBLE
68024: LD_EXP 74
68028: PUSH
68029: LD_VAR 0 2
68033: ARRAY
68034: INC
68035: ST_TO_ADDR
68036: LD_INT 1
68038: PUSH
68039: FOR_DOWNTO
68040: IFFALSE 68388
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
68042: LD_EXP 74
68046: PUSH
68047: LD_VAR 0 2
68051: ARRAY
68052: PUSH
68053: LD_VAR 0 3
68057: ARRAY
68058: PPUSH
68059: CALL_OW 301
68063: PUSH
68064: LD_EXP 74
68068: PUSH
68069: LD_VAR 0 2
68073: ARRAY
68074: PUSH
68075: LD_VAR 0 3
68079: ARRAY
68080: PPUSH
68081: CALL_OW 257
68085: PUSH
68086: LD_INT 1
68088: NONEQUAL
68089: OR
68090: IFFALSE 68153
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
68092: LD_ADDR_VAR 0 5
68096: PUSH
68097: LD_EXP 74
68101: PUSH
68102: LD_VAR 0 2
68106: ARRAY
68107: PUSH
68108: LD_EXP 74
68112: PUSH
68113: LD_VAR 0 2
68117: ARRAY
68118: PUSH
68119: LD_VAR 0 3
68123: ARRAY
68124: DIFF
68125: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
68126: LD_ADDR_EXP 74
68130: PUSH
68131: LD_EXP 74
68135: PPUSH
68136: LD_VAR 0 2
68140: PPUSH
68141: LD_VAR 0 5
68145: PPUSH
68146: CALL_OW 1
68150: ST_TO_ADDR
// continue ;
68151: GO 68039
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
68153: LD_EXP 74
68157: PUSH
68158: LD_VAR 0 2
68162: ARRAY
68163: PUSH
68164: LD_VAR 0 3
68168: ARRAY
68169: PPUSH
68170: CALL_OW 257
68174: PUSH
68175: LD_INT 1
68177: EQUAL
68178: PUSH
68179: LD_EXP 74
68183: PUSH
68184: LD_VAR 0 2
68188: ARRAY
68189: PUSH
68190: LD_VAR 0 3
68194: ARRAY
68195: PPUSH
68196: CALL_OW 459
68200: NOT
68201: AND
68202: PUSH
68203: LD_EXP 74
68207: PUSH
68208: LD_VAR 0 2
68212: ARRAY
68213: PUSH
68214: LD_VAR 0 3
68218: ARRAY
68219: PPUSH
68220: CALL_OW 314
68224: NOT
68225: AND
68226: IFFALSE 68386
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
68228: LD_EXP 74
68232: PUSH
68233: LD_VAR 0 2
68237: ARRAY
68238: PUSH
68239: LD_VAR 0 3
68243: ARRAY
68244: PPUSH
68245: CALL_OW 310
68249: IFFALSE 68272
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
68251: LD_EXP 74
68255: PUSH
68256: LD_VAR 0 2
68260: ARRAY
68261: PUSH
68262: LD_VAR 0 3
68266: ARRAY
68267: PPUSH
68268: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
68272: LD_EXP 74
68276: PUSH
68277: LD_VAR 0 2
68281: ARRAY
68282: PUSH
68283: LD_VAR 0 3
68287: ARRAY
68288: PPUSH
68289: CALL_OW 314
68293: NOT
68294: IFFALSE 68386
// begin r := rand ( 1 , mc_mines [ i ] ) ;
68296: LD_ADDR_VAR 0 7
68300: PUSH
68301: LD_INT 1
68303: PPUSH
68304: LD_EXP 73
68308: PUSH
68309: LD_VAR 0 2
68313: ARRAY
68314: PPUSH
68315: CALL_OW 12
68319: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
68320: LD_EXP 74
68324: PUSH
68325: LD_VAR 0 2
68329: ARRAY
68330: PUSH
68331: LD_VAR 0 3
68335: ARRAY
68336: PPUSH
68337: LD_EXP 73
68341: PUSH
68342: LD_VAR 0 2
68346: ARRAY
68347: PUSH
68348: LD_VAR 0 7
68352: ARRAY
68353: PUSH
68354: LD_INT 1
68356: ARRAY
68357: PPUSH
68358: LD_EXP 73
68362: PUSH
68363: LD_VAR 0 2
68367: ARRAY
68368: PUSH
68369: LD_VAR 0 7
68373: ARRAY
68374: PUSH
68375: LD_INT 2
68377: ARRAY
68378: PPUSH
68379: LD_INT 0
68381: PPUSH
68382: CALL_OW 193
// end ; end ; end ;
68386: GO 68039
68388: POP
68389: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
68390: LD_ADDR_VAR 0 5
68394: PUSH
68395: LD_EXP 60
68399: PUSH
68400: LD_VAR 0 2
68404: ARRAY
68405: PPUSH
68406: LD_INT 2
68408: PUSH
68409: LD_INT 30
68411: PUSH
68412: LD_INT 4
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: LD_INT 30
68421: PUSH
68422: LD_INT 5
68424: PUSH
68425: EMPTY
68426: LIST
68427: LIST
68428: PUSH
68429: LD_INT 30
68431: PUSH
68432: LD_INT 32
68434: PUSH
68435: EMPTY
68436: LIST
68437: LIST
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: LIST
68443: LIST
68444: PPUSH
68445: CALL_OW 72
68449: ST_TO_ADDR
// if not tmp then
68450: LD_VAR 0 5
68454: NOT
68455: IFFALSE 68459
// continue ;
68457: GO 67952
// list := [ ] ;
68459: LD_ADDR_VAR 0 6
68463: PUSH
68464: EMPTY
68465: ST_TO_ADDR
// for j in tmp do
68466: LD_ADDR_VAR 0 3
68470: PUSH
68471: LD_VAR 0 5
68475: PUSH
68476: FOR_IN
68477: IFFALSE 68546
// begin for k in UnitsInside ( j ) do
68479: LD_ADDR_VAR 0 4
68483: PUSH
68484: LD_VAR 0 3
68488: PPUSH
68489: CALL_OW 313
68493: PUSH
68494: FOR_IN
68495: IFFALSE 68542
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
68497: LD_VAR 0 4
68501: PPUSH
68502: CALL_OW 257
68506: PUSH
68507: LD_INT 1
68509: EQUAL
68510: PUSH
68511: LD_VAR 0 4
68515: PPUSH
68516: CALL_OW 459
68520: NOT
68521: AND
68522: IFFALSE 68540
// list := list ^ k ;
68524: LD_ADDR_VAR 0 6
68528: PUSH
68529: LD_VAR 0 6
68533: PUSH
68534: LD_VAR 0 4
68538: ADD
68539: ST_TO_ADDR
68540: GO 68494
68542: POP
68543: POP
// end ;
68544: GO 68476
68546: POP
68547: POP
// list := list diff mc_miners [ i ] ;
68548: LD_ADDR_VAR 0 6
68552: PUSH
68553: LD_VAR 0 6
68557: PUSH
68558: LD_EXP 74
68562: PUSH
68563: LD_VAR 0 2
68567: ARRAY
68568: DIFF
68569: ST_TO_ADDR
// if not list then
68570: LD_VAR 0 6
68574: NOT
68575: IFFALSE 68579
// continue ;
68577: GO 67952
// k := mc_mines [ i ] - mc_miners [ i ] ;
68579: LD_ADDR_VAR 0 4
68583: PUSH
68584: LD_EXP 73
68588: PUSH
68589: LD_VAR 0 2
68593: ARRAY
68594: PUSH
68595: LD_EXP 74
68599: PUSH
68600: LD_VAR 0 2
68604: ARRAY
68605: MINUS
68606: ST_TO_ADDR
// if k > list then
68607: LD_VAR 0 4
68611: PUSH
68612: LD_VAR 0 6
68616: GREATER
68617: IFFALSE 68629
// k := list ;
68619: LD_ADDR_VAR 0 4
68623: PUSH
68624: LD_VAR 0 6
68628: ST_TO_ADDR
// for j = 1 to k do
68629: LD_ADDR_VAR 0 3
68633: PUSH
68634: DOUBLE
68635: LD_INT 1
68637: DEC
68638: ST_TO_ADDR
68639: LD_VAR 0 4
68643: PUSH
68644: FOR_TO
68645: IFFALSE 68699
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
68647: LD_ADDR_EXP 74
68651: PUSH
68652: LD_EXP 74
68656: PPUSH
68657: LD_VAR 0 2
68661: PUSH
68662: LD_EXP 74
68666: PUSH
68667: LD_VAR 0 2
68671: ARRAY
68672: PUSH
68673: LD_INT 1
68675: PLUS
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PPUSH
68681: LD_VAR 0 6
68685: PUSH
68686: LD_VAR 0 3
68690: ARRAY
68691: PPUSH
68692: CALL 20003 0 3
68696: ST_TO_ADDR
68697: GO 68644
68699: POP
68700: POP
// end ;
68701: GO 67952
68703: POP
68704: POP
// end ;
68705: LD_VAR 0 1
68709: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
68710: LD_INT 0
68712: PPUSH
68713: PPUSH
68714: PPUSH
68715: PPUSH
68716: PPUSH
68717: PPUSH
68718: PPUSH
68719: PPUSH
68720: PPUSH
68721: PPUSH
68722: PPUSH
// if not mc_bases then
68723: LD_EXP 60
68727: NOT
68728: IFFALSE 68732
// exit ;
68730: GO 70555
// for i = 1 to mc_bases do
68732: LD_ADDR_VAR 0 2
68736: PUSH
68737: DOUBLE
68738: LD_INT 1
68740: DEC
68741: ST_TO_ADDR
68742: LD_EXP 60
68746: PUSH
68747: FOR_TO
68748: IFFALSE 70553
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68750: LD_EXP 60
68754: PUSH
68755: LD_VAR 0 2
68759: ARRAY
68760: NOT
68761: PUSH
68762: LD_EXP 67
68766: PUSH
68767: LD_VAR 0 2
68771: ARRAY
68772: OR
68773: IFFALSE 68777
// continue ;
68775: GO 68747
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68777: LD_EXP 76
68781: PUSH
68782: LD_VAR 0 2
68786: ARRAY
68787: NOT
68788: PUSH
68789: LD_EXP 77
68793: PUSH
68794: LD_VAR 0 2
68798: ARRAY
68799: AND
68800: IFFALSE 68838
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68802: LD_ADDR_EXP 77
68806: PUSH
68807: LD_EXP 77
68811: PPUSH
68812: LD_VAR 0 2
68816: PPUSH
68817: EMPTY
68818: PPUSH
68819: CALL_OW 1
68823: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68824: LD_VAR 0 2
68828: PPUSH
68829: LD_INT 107
68831: PPUSH
68832: CALL 59606 0 2
// continue ;
68836: GO 68747
// end ; target := [ ] ;
68838: LD_ADDR_VAR 0 7
68842: PUSH
68843: EMPTY
68844: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68845: LD_ADDR_VAR 0 6
68849: PUSH
68850: LD_EXP 60
68854: PUSH
68855: LD_VAR 0 2
68859: ARRAY
68860: PUSH
68861: LD_INT 1
68863: ARRAY
68864: PPUSH
68865: CALL_OW 255
68869: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68870: LD_ADDR_VAR 0 9
68874: PUSH
68875: LD_EXP 60
68879: PUSH
68880: LD_VAR 0 2
68884: ARRAY
68885: PPUSH
68886: LD_INT 2
68888: PUSH
68889: LD_INT 30
68891: PUSH
68892: LD_INT 0
68894: PUSH
68895: EMPTY
68896: LIST
68897: LIST
68898: PUSH
68899: LD_INT 30
68901: PUSH
68902: LD_INT 1
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: LIST
68913: PPUSH
68914: CALL_OW 72
68918: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68919: LD_ADDR_VAR 0 3
68923: PUSH
68924: DOUBLE
68925: LD_EXP 76
68929: PUSH
68930: LD_VAR 0 2
68934: ARRAY
68935: INC
68936: ST_TO_ADDR
68937: LD_INT 1
68939: PUSH
68940: FOR_DOWNTO
68941: IFFALSE 69186
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68943: LD_EXP 76
68947: PUSH
68948: LD_VAR 0 2
68952: ARRAY
68953: PUSH
68954: LD_VAR 0 3
68958: ARRAY
68959: PUSH
68960: LD_INT 2
68962: ARRAY
68963: PPUSH
68964: LD_EXP 76
68968: PUSH
68969: LD_VAR 0 2
68973: ARRAY
68974: PUSH
68975: LD_VAR 0 3
68979: ARRAY
68980: PUSH
68981: LD_INT 3
68983: ARRAY
68984: PPUSH
68985: CALL_OW 488
68989: PUSH
68990: LD_EXP 76
68994: PUSH
68995: LD_VAR 0 2
68999: ARRAY
69000: PUSH
69001: LD_VAR 0 3
69005: ARRAY
69006: PUSH
69007: LD_INT 2
69009: ARRAY
69010: PPUSH
69011: LD_EXP 76
69015: PUSH
69016: LD_VAR 0 2
69020: ARRAY
69021: PUSH
69022: LD_VAR 0 3
69026: ARRAY
69027: PUSH
69028: LD_INT 3
69030: ARRAY
69031: PPUSH
69032: CALL_OW 284
69036: PUSH
69037: LD_INT 0
69039: EQUAL
69040: AND
69041: IFFALSE 69096
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
69043: LD_ADDR_VAR 0 5
69047: PUSH
69048: LD_EXP 76
69052: PUSH
69053: LD_VAR 0 2
69057: ARRAY
69058: PPUSH
69059: LD_VAR 0 3
69063: PPUSH
69064: CALL_OW 3
69068: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
69069: LD_ADDR_EXP 76
69073: PUSH
69074: LD_EXP 76
69078: PPUSH
69079: LD_VAR 0 2
69083: PPUSH
69084: LD_VAR 0 5
69088: PPUSH
69089: CALL_OW 1
69093: ST_TO_ADDR
// continue ;
69094: GO 68940
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
69096: LD_VAR 0 6
69100: PPUSH
69101: LD_EXP 76
69105: PUSH
69106: LD_VAR 0 2
69110: ARRAY
69111: PUSH
69112: LD_VAR 0 3
69116: ARRAY
69117: PUSH
69118: LD_INT 2
69120: ARRAY
69121: PPUSH
69122: LD_EXP 76
69126: PUSH
69127: LD_VAR 0 2
69131: ARRAY
69132: PUSH
69133: LD_VAR 0 3
69137: ARRAY
69138: PUSH
69139: LD_INT 3
69141: ARRAY
69142: PPUSH
69143: LD_INT 30
69145: PPUSH
69146: CALL 20899 0 4
69150: PUSH
69151: LD_INT 4
69153: ARRAY
69154: PUSH
69155: LD_INT 0
69157: EQUAL
69158: IFFALSE 69184
// begin target := mc_crates [ i ] [ j ] ;
69160: LD_ADDR_VAR 0 7
69164: PUSH
69165: LD_EXP 76
69169: PUSH
69170: LD_VAR 0 2
69174: ARRAY
69175: PUSH
69176: LD_VAR 0 3
69180: ARRAY
69181: ST_TO_ADDR
// break ;
69182: GO 69186
// end ; end ;
69184: GO 68940
69186: POP
69187: POP
// if not target then
69188: LD_VAR 0 7
69192: NOT
69193: IFFALSE 69197
// continue ;
69195: GO 68747
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
69197: LD_ADDR_VAR 0 8
69201: PUSH
69202: LD_EXP 79
69206: PUSH
69207: LD_VAR 0 2
69211: ARRAY
69212: PPUSH
69213: LD_INT 2
69215: PUSH
69216: LD_INT 3
69218: PUSH
69219: LD_INT 58
69221: PUSH
69222: EMPTY
69223: LIST
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: LD_INT 61
69231: PUSH
69232: EMPTY
69233: LIST
69234: PUSH
69235: LD_INT 33
69237: PUSH
69238: LD_INT 5
69240: PUSH
69241: EMPTY
69242: LIST
69243: LIST
69244: PUSH
69245: LD_INT 33
69247: PUSH
69248: LD_INT 3
69250: PUSH
69251: EMPTY
69252: LIST
69253: LIST
69254: PUSH
69255: EMPTY
69256: LIST
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: PUSH
69262: LD_INT 2
69264: PUSH
69265: LD_INT 34
69267: PUSH
69268: LD_INT 32
69270: PUSH
69271: EMPTY
69272: LIST
69273: LIST
69274: PUSH
69275: LD_INT 34
69277: PUSH
69278: LD_INT 51
69280: PUSH
69281: EMPTY
69282: LIST
69283: LIST
69284: PUSH
69285: LD_INT 34
69287: PUSH
69288: LD_INT 12
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: PUSH
69301: EMPTY
69302: LIST
69303: LIST
69304: PPUSH
69305: CALL_OW 72
69309: ST_TO_ADDR
// if not cargo then
69310: LD_VAR 0 8
69314: NOT
69315: IFFALSE 70021
// begin if mc_crates_collector [ i ] < 5 then
69317: LD_EXP 77
69321: PUSH
69322: LD_VAR 0 2
69326: ARRAY
69327: PUSH
69328: LD_INT 5
69330: LESS
69331: IFFALSE 69697
// begin if mc_ape [ i ] then
69333: LD_EXP 89
69337: PUSH
69338: LD_VAR 0 2
69342: ARRAY
69343: IFFALSE 69390
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
69345: LD_ADDR_VAR 0 5
69349: PUSH
69350: LD_EXP 89
69354: PUSH
69355: LD_VAR 0 2
69359: ARRAY
69360: PPUSH
69361: LD_INT 25
69363: PUSH
69364: LD_INT 16
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 24
69373: PUSH
69374: LD_INT 750
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PPUSH
69385: CALL_OW 72
69389: ST_TO_ADDR
// if not tmp then
69390: LD_VAR 0 5
69394: NOT
69395: IFFALSE 69442
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
69397: LD_ADDR_VAR 0 5
69401: PUSH
69402: LD_EXP 60
69406: PUSH
69407: LD_VAR 0 2
69411: ARRAY
69412: PPUSH
69413: LD_INT 25
69415: PUSH
69416: LD_INT 2
69418: PUSH
69419: EMPTY
69420: LIST
69421: LIST
69422: PUSH
69423: LD_INT 24
69425: PUSH
69426: LD_INT 750
69428: PUSH
69429: EMPTY
69430: LIST
69431: LIST
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PPUSH
69437: CALL_OW 72
69441: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
69442: LD_EXP 89
69446: PUSH
69447: LD_VAR 0 2
69451: ARRAY
69452: PUSH
69453: LD_EXP 60
69457: PUSH
69458: LD_VAR 0 2
69462: ARRAY
69463: PPUSH
69464: LD_INT 25
69466: PUSH
69467: LD_INT 2
69469: PUSH
69470: EMPTY
69471: LIST
69472: LIST
69473: PUSH
69474: LD_INT 24
69476: PUSH
69477: LD_INT 750
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PPUSH
69488: CALL_OW 72
69492: AND
69493: PUSH
69494: LD_VAR 0 5
69498: PUSH
69499: LD_INT 5
69501: LESS
69502: AND
69503: IFFALSE 69585
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
69505: LD_ADDR_VAR 0 3
69509: PUSH
69510: LD_EXP 60
69514: PUSH
69515: LD_VAR 0 2
69519: ARRAY
69520: PPUSH
69521: LD_INT 25
69523: PUSH
69524: LD_INT 2
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: LD_INT 24
69533: PUSH
69534: LD_INT 750
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: PPUSH
69545: CALL_OW 72
69549: PUSH
69550: FOR_IN
69551: IFFALSE 69583
// begin tmp := tmp union j ;
69553: LD_ADDR_VAR 0 5
69557: PUSH
69558: LD_VAR 0 5
69562: PUSH
69563: LD_VAR 0 3
69567: UNION
69568: ST_TO_ADDR
// if tmp >= 5 then
69569: LD_VAR 0 5
69573: PUSH
69574: LD_INT 5
69576: GREATEREQUAL
69577: IFFALSE 69581
// break ;
69579: GO 69583
// end ;
69581: GO 69550
69583: POP
69584: POP
// end ; if not tmp then
69585: LD_VAR 0 5
69589: NOT
69590: IFFALSE 69594
// continue ;
69592: GO 68747
// for j in tmp do
69594: LD_ADDR_VAR 0 3
69598: PUSH
69599: LD_VAR 0 5
69603: PUSH
69604: FOR_IN
69605: IFFALSE 69695
// if not GetTag ( j ) then
69607: LD_VAR 0 3
69611: PPUSH
69612: CALL_OW 110
69616: NOT
69617: IFFALSE 69693
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
69619: LD_ADDR_EXP 77
69623: PUSH
69624: LD_EXP 77
69628: PPUSH
69629: LD_VAR 0 2
69633: PUSH
69634: LD_EXP 77
69638: PUSH
69639: LD_VAR 0 2
69643: ARRAY
69644: PUSH
69645: LD_INT 1
69647: PLUS
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: PPUSH
69653: LD_VAR 0 3
69657: PPUSH
69658: CALL 20003 0 3
69662: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69663: LD_VAR 0 3
69667: PPUSH
69668: LD_INT 107
69670: PPUSH
69671: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69675: LD_EXP 77
69679: PUSH
69680: LD_VAR 0 2
69684: ARRAY
69685: PUSH
69686: LD_INT 5
69688: GREATEREQUAL
69689: IFFALSE 69693
// break ;
69691: GO 69695
// end ;
69693: GO 69604
69695: POP
69696: POP
// end ; if mc_crates_collector [ i ] and target then
69697: LD_EXP 77
69701: PUSH
69702: LD_VAR 0 2
69706: ARRAY
69707: PUSH
69708: LD_VAR 0 7
69712: AND
69713: IFFALSE 70019
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69715: LD_EXP 77
69719: PUSH
69720: LD_VAR 0 2
69724: ARRAY
69725: PUSH
69726: LD_VAR 0 7
69730: PUSH
69731: LD_INT 1
69733: ARRAY
69734: LESS
69735: IFFALSE 69755
// tmp := mc_crates_collector [ i ] else
69737: LD_ADDR_VAR 0 5
69741: PUSH
69742: LD_EXP 77
69746: PUSH
69747: LD_VAR 0 2
69751: ARRAY
69752: ST_TO_ADDR
69753: GO 69769
// tmp := target [ 1 ] ;
69755: LD_ADDR_VAR 0 5
69759: PUSH
69760: LD_VAR 0 7
69764: PUSH
69765: LD_INT 1
69767: ARRAY
69768: ST_TO_ADDR
// k := 0 ;
69769: LD_ADDR_VAR 0 4
69773: PUSH
69774: LD_INT 0
69776: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69777: LD_ADDR_VAR 0 3
69781: PUSH
69782: LD_EXP 77
69786: PUSH
69787: LD_VAR 0 2
69791: ARRAY
69792: PUSH
69793: FOR_IN
69794: IFFALSE 70017
// begin k := k + 1 ;
69796: LD_ADDR_VAR 0 4
69800: PUSH
69801: LD_VAR 0 4
69805: PUSH
69806: LD_INT 1
69808: PLUS
69809: ST_TO_ADDR
// if k > tmp then
69810: LD_VAR 0 4
69814: PUSH
69815: LD_VAR 0 5
69819: GREATER
69820: IFFALSE 69824
// break ;
69822: GO 70017
// if not GetClass ( j ) in [ 2 , 16 ] then
69824: LD_VAR 0 3
69828: PPUSH
69829: CALL_OW 257
69833: PUSH
69834: LD_INT 2
69836: PUSH
69837: LD_INT 16
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: IN
69844: NOT
69845: IFFALSE 69898
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69847: LD_ADDR_EXP 77
69851: PUSH
69852: LD_EXP 77
69856: PPUSH
69857: LD_VAR 0 2
69861: PPUSH
69862: LD_EXP 77
69866: PUSH
69867: LD_VAR 0 2
69871: ARRAY
69872: PUSH
69873: LD_VAR 0 3
69877: DIFF
69878: PPUSH
69879: CALL_OW 1
69883: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69884: LD_VAR 0 3
69888: PPUSH
69889: LD_INT 0
69891: PPUSH
69892: CALL_OW 109
// continue ;
69896: GO 69793
// end ; if IsInUnit ( j ) then
69898: LD_VAR 0 3
69902: PPUSH
69903: CALL_OW 310
69907: IFFALSE 69918
// ComExitBuilding ( j ) ;
69909: LD_VAR 0 3
69913: PPUSH
69914: CALL_OW 122
// wait ( 3 ) ;
69918: LD_INT 3
69920: PPUSH
69921: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
69925: LD_VAR 0 3
69929: PPUSH
69930: CALL_OW 314
69934: PUSH
69935: LD_VAR 0 6
69939: PPUSH
69940: LD_VAR 0 7
69944: PUSH
69945: LD_INT 2
69947: ARRAY
69948: PPUSH
69949: LD_VAR 0 7
69953: PUSH
69954: LD_INT 3
69956: ARRAY
69957: PPUSH
69958: LD_INT 30
69960: PPUSH
69961: CALL 20899 0 4
69965: PUSH
69966: LD_INT 4
69968: ARRAY
69969: AND
69970: IFFALSE 69988
// ComStandNearbyBuilding ( j , depot ) else
69972: LD_VAR 0 3
69976: PPUSH
69977: LD_VAR 0 9
69981: PPUSH
69982: CALL 16428 0 2
69986: GO 70015
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69988: LD_VAR 0 3
69992: PPUSH
69993: LD_VAR 0 7
69997: PUSH
69998: LD_INT 2
70000: ARRAY
70001: PPUSH
70002: LD_VAR 0 7
70006: PUSH
70007: LD_INT 3
70009: ARRAY
70010: PPUSH
70011: CALL_OW 117
// end ;
70015: GO 69793
70017: POP
70018: POP
// end ; end else
70019: GO 70551
// begin for j in cargo do
70021: LD_ADDR_VAR 0 3
70025: PUSH
70026: LD_VAR 0 8
70030: PUSH
70031: FOR_IN
70032: IFFALSE 70549
// begin if GetTag ( j ) <> 0 then
70034: LD_VAR 0 3
70038: PPUSH
70039: CALL_OW 110
70043: PUSH
70044: LD_INT 0
70046: NONEQUAL
70047: IFFALSE 70051
// continue ;
70049: GO 70031
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
70051: LD_VAR 0 3
70055: PPUSH
70056: CALL_OW 256
70060: PUSH
70061: LD_INT 1000
70063: LESS
70064: PUSH
70065: LD_VAR 0 3
70069: PPUSH
70070: LD_EXP 84
70074: PUSH
70075: LD_VAR 0 2
70079: ARRAY
70080: PPUSH
70081: CALL_OW 308
70085: NOT
70086: AND
70087: IFFALSE 70109
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70089: LD_VAR 0 3
70093: PPUSH
70094: LD_EXP 84
70098: PUSH
70099: LD_VAR 0 2
70103: ARRAY
70104: PPUSH
70105: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
70109: LD_VAR 0 3
70113: PPUSH
70114: CALL_OW 256
70118: PUSH
70119: LD_INT 1000
70121: LESS
70122: PUSH
70123: LD_VAR 0 3
70127: PPUSH
70128: LD_EXP 84
70132: PUSH
70133: LD_VAR 0 2
70137: ARRAY
70138: PPUSH
70139: CALL_OW 308
70143: AND
70144: IFFALSE 70148
// continue ;
70146: GO 70031
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
70148: LD_VAR 0 3
70152: PPUSH
70153: CALL_OW 262
70157: PUSH
70158: LD_INT 2
70160: EQUAL
70161: PUSH
70162: LD_VAR 0 3
70166: PPUSH
70167: CALL_OW 261
70171: PUSH
70172: LD_INT 15
70174: LESS
70175: AND
70176: IFFALSE 70180
// continue ;
70178: GO 70031
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
70180: LD_VAR 0 3
70184: PPUSH
70185: CALL_OW 262
70189: PUSH
70190: LD_INT 1
70192: EQUAL
70193: PUSH
70194: LD_VAR 0 3
70198: PPUSH
70199: CALL_OW 261
70203: PUSH
70204: LD_INT 10
70206: LESS
70207: AND
70208: IFFALSE 70488
// begin if not depot then
70210: LD_VAR 0 9
70214: NOT
70215: IFFALSE 70219
// continue ;
70217: GO 70031
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
70219: LD_VAR 0 3
70223: PPUSH
70224: LD_VAR 0 9
70228: PPUSH
70229: LD_VAR 0 3
70233: PPUSH
70234: CALL_OW 74
70238: PPUSH
70239: CALL_OW 296
70243: PUSH
70244: LD_INT 6
70246: LESS
70247: IFFALSE 70263
// SetFuel ( j , 100 ) else
70249: LD_VAR 0 3
70253: PPUSH
70254: LD_INT 100
70256: PPUSH
70257: CALL_OW 240
70261: GO 70488
// if GetFuel ( j ) = 0 then
70263: LD_VAR 0 3
70267: PPUSH
70268: CALL_OW 261
70272: PUSH
70273: LD_INT 0
70275: EQUAL
70276: IFFALSE 70488
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
70278: LD_ADDR_EXP 79
70282: PUSH
70283: LD_EXP 79
70287: PPUSH
70288: LD_VAR 0 2
70292: PPUSH
70293: LD_EXP 79
70297: PUSH
70298: LD_VAR 0 2
70302: ARRAY
70303: PUSH
70304: LD_VAR 0 3
70308: DIFF
70309: PPUSH
70310: CALL_OW 1
70314: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
70315: LD_VAR 0 3
70319: PPUSH
70320: CALL_OW 263
70324: PUSH
70325: LD_INT 1
70327: EQUAL
70328: IFFALSE 70344
// ComExitVehicle ( IsInUnit ( j ) ) ;
70330: LD_VAR 0 3
70334: PPUSH
70335: CALL_OW 310
70339: PPUSH
70340: CALL_OW 121
// if GetControl ( j ) = control_remote then
70344: LD_VAR 0 3
70348: PPUSH
70349: CALL_OW 263
70353: PUSH
70354: LD_INT 2
70356: EQUAL
70357: IFFALSE 70368
// ComUnlink ( j ) ;
70359: LD_VAR 0 3
70363: PPUSH
70364: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
70368: LD_ADDR_VAR 0 10
70372: PUSH
70373: LD_VAR 0 2
70377: PPUSH
70378: LD_INT 3
70380: PPUSH
70381: CALL 80127 0 2
70385: ST_TO_ADDR
// if fac then
70386: LD_VAR 0 10
70390: IFFALSE 70486
// begin for k in fac do
70392: LD_ADDR_VAR 0 4
70396: PUSH
70397: LD_VAR 0 10
70401: PUSH
70402: FOR_IN
70403: IFFALSE 70484
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
70405: LD_ADDR_VAR 0 11
70409: PUSH
70410: LD_VAR 0 10
70414: PPUSH
70415: LD_VAR 0 3
70419: PPUSH
70420: CALL_OW 265
70424: PPUSH
70425: LD_VAR 0 3
70429: PPUSH
70430: CALL_OW 262
70434: PPUSH
70435: LD_VAR 0 3
70439: PPUSH
70440: CALL_OW 263
70444: PPUSH
70445: LD_VAR 0 3
70449: PPUSH
70450: CALL_OW 264
70454: PPUSH
70455: CALL 17499 0 5
70459: ST_TO_ADDR
// if components then
70460: LD_VAR 0 11
70464: IFFALSE 70482
// begin MC_InsertProduceList ( i , components ) ;
70466: LD_VAR 0 2
70470: PPUSH
70471: LD_VAR 0 11
70475: PPUSH
70476: CALL 79672 0 2
// break ;
70480: GO 70484
// end ; end ;
70482: GO 70402
70484: POP
70485: POP
// end ; continue ;
70486: GO 70031
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
70488: LD_VAR 0 3
70492: PPUSH
70493: LD_INT 1
70495: PPUSH
70496: CALL_OW 289
70500: PUSH
70501: LD_INT 100
70503: LESS
70504: PUSH
70505: LD_VAR 0 3
70509: PPUSH
70510: CALL_OW 314
70514: NOT
70515: AND
70516: IFFALSE 70545
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70518: LD_VAR 0 3
70522: PPUSH
70523: LD_VAR 0 7
70527: PUSH
70528: LD_INT 2
70530: ARRAY
70531: PPUSH
70532: LD_VAR 0 7
70536: PUSH
70537: LD_INT 3
70539: ARRAY
70540: PPUSH
70541: CALL_OW 117
// break ;
70545: GO 70549
// end ;
70547: GO 70031
70549: POP
70550: POP
// end ; end ;
70551: GO 68747
70553: POP
70554: POP
// end ;
70555: LD_VAR 0 1
70559: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
70560: LD_INT 0
70562: PPUSH
70563: PPUSH
70564: PPUSH
70565: PPUSH
// if not mc_bases then
70566: LD_EXP 60
70570: NOT
70571: IFFALSE 70575
// exit ;
70573: GO 70736
// for i = 1 to mc_bases do
70575: LD_ADDR_VAR 0 2
70579: PUSH
70580: DOUBLE
70581: LD_INT 1
70583: DEC
70584: ST_TO_ADDR
70585: LD_EXP 60
70589: PUSH
70590: FOR_TO
70591: IFFALSE 70734
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
70593: LD_ADDR_VAR 0 4
70597: PUSH
70598: LD_EXP 79
70602: PUSH
70603: LD_VAR 0 2
70607: ARRAY
70608: PUSH
70609: LD_EXP 82
70613: PUSH
70614: LD_VAR 0 2
70618: ARRAY
70619: UNION
70620: PPUSH
70621: LD_INT 33
70623: PUSH
70624: LD_INT 2
70626: PUSH
70627: EMPTY
70628: LIST
70629: LIST
70630: PPUSH
70631: CALL_OW 72
70635: ST_TO_ADDR
// if tmp then
70636: LD_VAR 0 4
70640: IFFALSE 70732
// for j in tmp do
70642: LD_ADDR_VAR 0 3
70646: PUSH
70647: LD_VAR 0 4
70651: PUSH
70652: FOR_IN
70653: IFFALSE 70730
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70655: LD_VAR 0 3
70659: PPUSH
70660: CALL_OW 312
70664: NOT
70665: PUSH
70666: LD_VAR 0 3
70670: PPUSH
70671: CALL_OW 256
70675: PUSH
70676: LD_INT 250
70678: GREATEREQUAL
70679: AND
70680: IFFALSE 70693
// Connect ( j ) else
70682: LD_VAR 0 3
70686: PPUSH
70687: CALL 22974 0 1
70691: GO 70728
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70693: LD_VAR 0 3
70697: PPUSH
70698: CALL_OW 256
70702: PUSH
70703: LD_INT 250
70705: LESS
70706: PUSH
70707: LD_VAR 0 3
70711: PPUSH
70712: CALL_OW 312
70716: AND
70717: IFFALSE 70728
// ComUnlink ( j ) ;
70719: LD_VAR 0 3
70723: PPUSH
70724: CALL_OW 136
70728: GO 70652
70730: POP
70731: POP
// end ;
70732: GO 70590
70734: POP
70735: POP
// end ;
70736: LD_VAR 0 1
70740: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70741: LD_INT 0
70743: PPUSH
70744: PPUSH
70745: PPUSH
70746: PPUSH
70747: PPUSH
// if not mc_bases then
70748: LD_EXP 60
70752: NOT
70753: IFFALSE 70757
// exit ;
70755: GO 71202
// for i = 1 to mc_bases do
70757: LD_ADDR_VAR 0 2
70761: PUSH
70762: DOUBLE
70763: LD_INT 1
70765: DEC
70766: ST_TO_ADDR
70767: LD_EXP 60
70771: PUSH
70772: FOR_TO
70773: IFFALSE 71200
// begin if not mc_produce [ i ] then
70775: LD_EXP 81
70779: PUSH
70780: LD_VAR 0 2
70784: ARRAY
70785: NOT
70786: IFFALSE 70790
// continue ;
70788: GO 70772
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70790: LD_ADDR_VAR 0 5
70794: PUSH
70795: LD_EXP 60
70799: PUSH
70800: LD_VAR 0 2
70804: ARRAY
70805: PPUSH
70806: LD_INT 30
70808: PUSH
70809: LD_INT 3
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PPUSH
70816: CALL_OW 72
70820: ST_TO_ADDR
// if not fac then
70821: LD_VAR 0 5
70825: NOT
70826: IFFALSE 70830
// continue ;
70828: GO 70772
// for j in fac do
70830: LD_ADDR_VAR 0 3
70834: PUSH
70835: LD_VAR 0 5
70839: PUSH
70840: FOR_IN
70841: IFFALSE 71196
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
70843: LD_VAR 0 3
70847: PPUSH
70848: CALL_OW 461
70852: PUSH
70853: LD_INT 2
70855: NONEQUAL
70856: PUSH
70857: LD_VAR 0 3
70861: PPUSH
70862: LD_INT 15
70864: PPUSH
70865: CALL 22602 0 2
70869: PUSH
70870: LD_INT 4
70872: ARRAY
70873: OR
70874: IFFALSE 70878
// continue ;
70876: GO 70840
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70878: LD_VAR 0 3
70882: PPUSH
70883: LD_EXP 81
70887: PUSH
70888: LD_VAR 0 2
70892: ARRAY
70893: PUSH
70894: LD_INT 1
70896: ARRAY
70897: PUSH
70898: LD_INT 1
70900: ARRAY
70901: PPUSH
70902: LD_EXP 81
70906: PUSH
70907: LD_VAR 0 2
70911: ARRAY
70912: PUSH
70913: LD_INT 1
70915: ARRAY
70916: PUSH
70917: LD_INT 2
70919: ARRAY
70920: PPUSH
70921: LD_EXP 81
70925: PUSH
70926: LD_VAR 0 2
70930: ARRAY
70931: PUSH
70932: LD_INT 1
70934: ARRAY
70935: PUSH
70936: LD_INT 3
70938: ARRAY
70939: PPUSH
70940: LD_EXP 81
70944: PUSH
70945: LD_VAR 0 2
70949: ARRAY
70950: PUSH
70951: LD_INT 1
70953: ARRAY
70954: PUSH
70955: LD_INT 4
70957: ARRAY
70958: PPUSH
70959: CALL_OW 448
70963: PUSH
70964: LD_VAR 0 3
70968: PPUSH
70969: LD_EXP 81
70973: PUSH
70974: LD_VAR 0 2
70978: ARRAY
70979: PUSH
70980: LD_INT 1
70982: ARRAY
70983: PUSH
70984: LD_INT 1
70986: ARRAY
70987: PUSH
70988: LD_EXP 81
70992: PUSH
70993: LD_VAR 0 2
70997: ARRAY
70998: PUSH
70999: LD_INT 1
71001: ARRAY
71002: PUSH
71003: LD_INT 2
71005: ARRAY
71006: PUSH
71007: LD_EXP 81
71011: PUSH
71012: LD_VAR 0 2
71016: ARRAY
71017: PUSH
71018: LD_INT 1
71020: ARRAY
71021: PUSH
71022: LD_INT 3
71024: ARRAY
71025: PUSH
71026: LD_EXP 81
71030: PUSH
71031: LD_VAR 0 2
71035: ARRAY
71036: PUSH
71037: LD_INT 1
71039: ARRAY
71040: PUSH
71041: LD_INT 4
71043: ARRAY
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: LIST
71049: LIST
71050: PPUSH
71051: CALL 26369 0 2
71055: AND
71056: IFFALSE 71194
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
71058: LD_VAR 0 3
71062: PPUSH
71063: LD_EXP 81
71067: PUSH
71068: LD_VAR 0 2
71072: ARRAY
71073: PUSH
71074: LD_INT 1
71076: ARRAY
71077: PUSH
71078: LD_INT 1
71080: ARRAY
71081: PPUSH
71082: LD_EXP 81
71086: PUSH
71087: LD_VAR 0 2
71091: ARRAY
71092: PUSH
71093: LD_INT 1
71095: ARRAY
71096: PUSH
71097: LD_INT 2
71099: ARRAY
71100: PPUSH
71101: LD_EXP 81
71105: PUSH
71106: LD_VAR 0 2
71110: ARRAY
71111: PUSH
71112: LD_INT 1
71114: ARRAY
71115: PUSH
71116: LD_INT 3
71118: ARRAY
71119: PPUSH
71120: LD_EXP 81
71124: PUSH
71125: LD_VAR 0 2
71129: ARRAY
71130: PUSH
71131: LD_INT 1
71133: ARRAY
71134: PUSH
71135: LD_INT 4
71137: ARRAY
71138: PPUSH
71139: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
71143: LD_ADDR_VAR 0 4
71147: PUSH
71148: LD_EXP 81
71152: PUSH
71153: LD_VAR 0 2
71157: ARRAY
71158: PPUSH
71159: LD_INT 1
71161: PPUSH
71162: CALL_OW 3
71166: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
71167: LD_ADDR_EXP 81
71171: PUSH
71172: LD_EXP 81
71176: PPUSH
71177: LD_VAR 0 2
71181: PPUSH
71182: LD_VAR 0 4
71186: PPUSH
71187: CALL_OW 1
71191: ST_TO_ADDR
// break ;
71192: GO 71196
// end ; end ;
71194: GO 70840
71196: POP
71197: POP
// end ;
71198: GO 70772
71200: POP
71201: POP
// end ;
71202: LD_VAR 0 1
71206: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
71207: LD_INT 0
71209: PPUSH
71210: PPUSH
71211: PPUSH
// if not mc_bases then
71212: LD_EXP 60
71216: NOT
71217: IFFALSE 71221
// exit ;
71219: GO 71310
// for i = 1 to mc_bases do
71221: LD_ADDR_VAR 0 2
71225: PUSH
71226: DOUBLE
71227: LD_INT 1
71229: DEC
71230: ST_TO_ADDR
71231: LD_EXP 60
71235: PUSH
71236: FOR_TO
71237: IFFALSE 71308
// begin if mc_attack [ i ] then
71239: LD_EXP 80
71243: PUSH
71244: LD_VAR 0 2
71248: ARRAY
71249: IFFALSE 71306
// begin tmp := mc_attack [ i ] [ 1 ] ;
71251: LD_ADDR_VAR 0 3
71255: PUSH
71256: LD_EXP 80
71260: PUSH
71261: LD_VAR 0 2
71265: ARRAY
71266: PUSH
71267: LD_INT 1
71269: ARRAY
71270: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
71271: LD_ADDR_EXP 80
71275: PUSH
71276: LD_EXP 80
71280: PPUSH
71281: LD_VAR 0 2
71285: PPUSH
71286: EMPTY
71287: PPUSH
71288: CALL_OW 1
71292: ST_TO_ADDR
// Attack ( tmp ) ;
71293: LD_VAR 0 3
71297: PPUSH
71298: CALL 105228 0 1
// exit ;
71302: POP
71303: POP
71304: GO 71310
// end ; end ;
71306: GO 71236
71308: POP
71309: POP
// end ;
71310: LD_VAR 0 1
71314: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
71315: LD_INT 0
71317: PPUSH
71318: PPUSH
71319: PPUSH
71320: PPUSH
71321: PPUSH
71322: PPUSH
71323: PPUSH
// if not mc_bases then
71324: LD_EXP 60
71328: NOT
71329: IFFALSE 71333
// exit ;
71331: GO 72190
// for i = 1 to mc_bases do
71333: LD_ADDR_VAR 0 2
71337: PUSH
71338: DOUBLE
71339: LD_INT 1
71341: DEC
71342: ST_TO_ADDR
71343: LD_EXP 60
71347: PUSH
71348: FOR_TO
71349: IFFALSE 72188
// begin if not mc_bases [ i ] then
71351: LD_EXP 60
71355: PUSH
71356: LD_VAR 0 2
71360: ARRAY
71361: NOT
71362: IFFALSE 71366
// continue ;
71364: GO 71348
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
71366: LD_ADDR_VAR 0 7
71370: PUSH
71371: LD_EXP 60
71375: PUSH
71376: LD_VAR 0 2
71380: ARRAY
71381: PUSH
71382: LD_INT 1
71384: ARRAY
71385: PPUSH
71386: CALL 16650 0 1
71390: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
71391: LD_ADDR_EXP 83
71395: PUSH
71396: LD_EXP 83
71400: PPUSH
71401: LD_VAR 0 2
71405: PPUSH
71406: LD_EXP 60
71410: PUSH
71411: LD_VAR 0 2
71415: ARRAY
71416: PUSH
71417: LD_INT 1
71419: ARRAY
71420: PPUSH
71421: CALL_OW 255
71425: PPUSH
71426: LD_EXP 85
71430: PUSH
71431: LD_VAR 0 2
71435: ARRAY
71436: PPUSH
71437: CALL 16615 0 2
71441: PPUSH
71442: CALL_OW 1
71446: ST_TO_ADDR
// if not mc_scan [ i ] then
71447: LD_EXP 83
71451: PUSH
71452: LD_VAR 0 2
71456: ARRAY
71457: NOT
71458: IFFALSE 71636
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
71460: LD_ADDR_EXP 103
71464: PUSH
71465: LD_EXP 103
71469: PPUSH
71470: LD_VAR 0 2
71474: PPUSH
71475: LD_INT 0
71477: PPUSH
71478: CALL_OW 1
71482: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71483: LD_ADDR_VAR 0 4
71487: PUSH
71488: LD_EXP 60
71492: PUSH
71493: LD_VAR 0 2
71497: ARRAY
71498: PPUSH
71499: LD_INT 2
71501: PUSH
71502: LD_INT 25
71504: PUSH
71505: LD_INT 5
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: PUSH
71512: LD_INT 25
71514: PUSH
71515: LD_INT 8
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: PUSH
71522: LD_INT 25
71524: PUSH
71525: LD_INT 9
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: LIST
71536: LIST
71537: PPUSH
71538: CALL_OW 72
71542: ST_TO_ADDR
// if not tmp then
71543: LD_VAR 0 4
71547: NOT
71548: IFFALSE 71552
// continue ;
71550: GO 71348
// for j in tmp do
71552: LD_ADDR_VAR 0 3
71556: PUSH
71557: LD_VAR 0 4
71561: PUSH
71562: FOR_IN
71563: IFFALSE 71634
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
71565: LD_VAR 0 3
71569: PPUSH
71570: CALL_OW 310
71574: PPUSH
71575: CALL_OW 266
71579: PUSH
71580: LD_INT 5
71582: EQUAL
71583: PUSH
71584: LD_VAR 0 3
71588: PPUSH
71589: CALL_OW 257
71593: PUSH
71594: LD_INT 1
71596: EQUAL
71597: AND
71598: PUSH
71599: LD_VAR 0 3
71603: PPUSH
71604: CALL_OW 459
71608: NOT
71609: AND
71610: PUSH
71611: LD_VAR 0 7
71615: AND
71616: IFFALSE 71632
// ComChangeProfession ( j , class ) ;
71618: LD_VAR 0 3
71622: PPUSH
71623: LD_VAR 0 7
71627: PPUSH
71628: CALL_OW 123
71632: GO 71562
71634: POP
71635: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
71636: LD_EXP 83
71640: PUSH
71641: LD_VAR 0 2
71645: ARRAY
71646: PUSH
71647: LD_EXP 103
71651: PUSH
71652: LD_VAR 0 2
71656: ARRAY
71657: NOT
71658: AND
71659: PUSH
71660: LD_EXP 82
71664: PUSH
71665: LD_VAR 0 2
71669: ARRAY
71670: NOT
71671: AND
71672: PUSH
71673: LD_EXP 60
71677: PUSH
71678: LD_VAR 0 2
71682: ARRAY
71683: PPUSH
71684: LD_INT 50
71686: PUSH
71687: EMPTY
71688: LIST
71689: PUSH
71690: LD_INT 2
71692: PUSH
71693: LD_INT 30
71695: PUSH
71696: LD_INT 32
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 30
71705: PUSH
71706: LD_INT 33
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PUSH
71713: LD_INT 30
71715: PUSH
71716: LD_INT 4
71718: PUSH
71719: EMPTY
71720: LIST
71721: LIST
71722: PUSH
71723: LD_INT 30
71725: PUSH
71726: LD_INT 5
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: LIST
71737: LIST
71738: LIST
71739: PUSH
71740: EMPTY
71741: LIST
71742: LIST
71743: PPUSH
71744: CALL_OW 72
71748: PUSH
71749: LD_INT 4
71751: LESS
71752: PUSH
71753: LD_EXP 60
71757: PUSH
71758: LD_VAR 0 2
71762: ARRAY
71763: PPUSH
71764: LD_INT 3
71766: PUSH
71767: LD_INT 24
71769: PUSH
71770: LD_INT 1000
71772: PUSH
71773: EMPTY
71774: LIST
71775: LIST
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: LD_INT 2
71783: PUSH
71784: LD_INT 30
71786: PUSH
71787: LD_INT 0
71789: PUSH
71790: EMPTY
71791: LIST
71792: LIST
71793: PUSH
71794: LD_INT 30
71796: PUSH
71797: LD_INT 1
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: PUSH
71804: EMPTY
71805: LIST
71806: LIST
71807: LIST
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PPUSH
71813: CALL_OW 72
71817: OR
71818: AND
71819: IFFALSE 72070
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71821: LD_ADDR_EXP 103
71825: PUSH
71826: LD_EXP 103
71830: PPUSH
71831: LD_VAR 0 2
71835: PPUSH
71836: LD_INT 1
71838: PPUSH
71839: CALL_OW 1
71843: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71844: LD_ADDR_VAR 0 4
71848: PUSH
71849: LD_EXP 60
71853: PUSH
71854: LD_VAR 0 2
71858: ARRAY
71859: PPUSH
71860: LD_INT 2
71862: PUSH
71863: LD_INT 25
71865: PUSH
71866: LD_INT 1
71868: PUSH
71869: EMPTY
71870: LIST
71871: LIST
71872: PUSH
71873: LD_INT 25
71875: PUSH
71876: LD_INT 5
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: PUSH
71883: LD_INT 25
71885: PUSH
71886: LD_INT 8
71888: PUSH
71889: EMPTY
71890: LIST
71891: LIST
71892: PUSH
71893: LD_INT 25
71895: PUSH
71896: LD_INT 9
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: EMPTY
71904: LIST
71905: LIST
71906: LIST
71907: LIST
71908: LIST
71909: PPUSH
71910: CALL_OW 72
71914: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71915: LD_ADDR_VAR 0 4
71919: PUSH
71920: LD_VAR 0 4
71924: PUSH
71925: LD_VAR 0 4
71929: PPUSH
71930: LD_INT 18
71932: PPUSH
71933: CALL 49272 0 2
71937: DIFF
71938: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
71939: LD_VAR 0 4
71943: NOT
71944: PUSH
71945: LD_EXP 60
71949: PUSH
71950: LD_VAR 0 2
71954: ARRAY
71955: PPUSH
71956: LD_INT 2
71958: PUSH
71959: LD_INT 30
71961: PUSH
71962: LD_INT 4
71964: PUSH
71965: EMPTY
71966: LIST
71967: LIST
71968: PUSH
71969: LD_INT 30
71971: PUSH
71972: LD_INT 5
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: LIST
71983: PPUSH
71984: CALL_OW 72
71988: NOT
71989: AND
71990: IFFALSE 72052
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
71992: LD_ADDR_VAR 0 4
71996: PUSH
71997: LD_EXP 60
72001: PUSH
72002: LD_VAR 0 2
72006: ARRAY
72007: PPUSH
72008: LD_INT 2
72010: PUSH
72011: LD_INT 25
72013: PUSH
72014: LD_INT 2
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: LD_INT 25
72023: PUSH
72024: LD_INT 3
72026: PUSH
72027: EMPTY
72028: LIST
72029: LIST
72030: PUSH
72031: LD_INT 25
72033: PUSH
72034: LD_INT 4
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: EMPTY
72042: LIST
72043: LIST
72044: LIST
72045: LIST
72046: PPUSH
72047: CALL_OW 72
72051: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
72052: LD_VAR 0 2
72056: PPUSH
72057: LD_VAR 0 4
72061: PPUSH
72062: CALL 109937 0 2
// exit ;
72066: POP
72067: POP
72068: GO 72190
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
72070: LD_EXP 83
72074: PUSH
72075: LD_VAR 0 2
72079: ARRAY
72080: PUSH
72081: LD_EXP 103
72085: PUSH
72086: LD_VAR 0 2
72090: ARRAY
72091: NOT
72092: AND
72093: PUSH
72094: LD_EXP 82
72098: PUSH
72099: LD_VAR 0 2
72103: ARRAY
72104: AND
72105: IFFALSE 72186
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
72107: LD_ADDR_EXP 103
72111: PUSH
72112: LD_EXP 103
72116: PPUSH
72117: LD_VAR 0 2
72121: PPUSH
72122: LD_INT 1
72124: PPUSH
72125: CALL_OW 1
72129: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
72130: LD_ADDR_VAR 0 4
72134: PUSH
72135: LD_EXP 82
72139: PUSH
72140: LD_VAR 0 2
72144: ARRAY
72145: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
72146: LD_ADDR_EXP 82
72150: PUSH
72151: LD_EXP 82
72155: PPUSH
72156: LD_VAR 0 2
72160: PPUSH
72161: EMPTY
72162: PPUSH
72163: CALL_OW 1
72167: ST_TO_ADDR
// Defend ( i , tmp ) ;
72168: LD_VAR 0 2
72172: PPUSH
72173: LD_VAR 0 4
72177: PPUSH
72178: CALL 110533 0 2
// exit ;
72182: POP
72183: POP
72184: GO 72190
// end ; end ;
72186: GO 71348
72188: POP
72189: POP
// end ;
72190: LD_VAR 0 1
72194: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
72195: LD_INT 0
72197: PPUSH
72198: PPUSH
72199: PPUSH
72200: PPUSH
72201: PPUSH
72202: PPUSH
72203: PPUSH
72204: PPUSH
72205: PPUSH
72206: PPUSH
72207: PPUSH
// if not mc_bases then
72208: LD_EXP 60
72212: NOT
72213: IFFALSE 72217
// exit ;
72215: GO 73304
// for i = 1 to mc_bases do
72217: LD_ADDR_VAR 0 2
72221: PUSH
72222: DOUBLE
72223: LD_INT 1
72225: DEC
72226: ST_TO_ADDR
72227: LD_EXP 60
72231: PUSH
72232: FOR_TO
72233: IFFALSE 73302
// begin tmp := mc_lab [ i ] ;
72235: LD_ADDR_VAR 0 6
72239: PUSH
72240: LD_EXP 93
72244: PUSH
72245: LD_VAR 0 2
72249: ARRAY
72250: ST_TO_ADDR
// if not tmp then
72251: LD_VAR 0 6
72255: NOT
72256: IFFALSE 72260
// continue ;
72258: GO 72232
// idle_lab := 0 ;
72260: LD_ADDR_VAR 0 11
72264: PUSH
72265: LD_INT 0
72267: ST_TO_ADDR
// for j in tmp do
72268: LD_ADDR_VAR 0 3
72272: PUSH
72273: LD_VAR 0 6
72277: PUSH
72278: FOR_IN
72279: IFFALSE 73298
// begin researching := false ;
72281: LD_ADDR_VAR 0 10
72285: PUSH
72286: LD_INT 0
72288: ST_TO_ADDR
// side := GetSide ( j ) ;
72289: LD_ADDR_VAR 0 4
72293: PUSH
72294: LD_VAR 0 3
72298: PPUSH
72299: CALL_OW 255
72303: ST_TO_ADDR
// if not mc_tech [ side ] then
72304: LD_EXP 87
72308: PUSH
72309: LD_VAR 0 4
72313: ARRAY
72314: NOT
72315: IFFALSE 72319
// continue ;
72317: GO 72278
// if BuildingStatus ( j ) = bs_idle then
72319: LD_VAR 0 3
72323: PPUSH
72324: CALL_OW 461
72328: PUSH
72329: LD_INT 2
72331: EQUAL
72332: IFFALSE 72520
// begin if idle_lab and UnitsInside ( j ) < 6 then
72334: LD_VAR 0 11
72338: PUSH
72339: LD_VAR 0 3
72343: PPUSH
72344: CALL_OW 313
72348: PUSH
72349: LD_INT 6
72351: LESS
72352: AND
72353: IFFALSE 72424
// begin tmp2 := UnitsInside ( idle_lab ) ;
72355: LD_ADDR_VAR 0 9
72359: PUSH
72360: LD_VAR 0 11
72364: PPUSH
72365: CALL_OW 313
72369: ST_TO_ADDR
// if tmp2 then
72370: LD_VAR 0 9
72374: IFFALSE 72416
// for x in tmp2 do
72376: LD_ADDR_VAR 0 7
72380: PUSH
72381: LD_VAR 0 9
72385: PUSH
72386: FOR_IN
72387: IFFALSE 72414
// begin ComExitBuilding ( x ) ;
72389: LD_VAR 0 7
72393: PPUSH
72394: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72398: LD_VAR 0 7
72402: PPUSH
72403: LD_VAR 0 3
72407: PPUSH
72408: CALL_OW 180
// end ;
72412: GO 72386
72414: POP
72415: POP
// idle_lab := 0 ;
72416: LD_ADDR_VAR 0 11
72420: PUSH
72421: LD_INT 0
72423: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
72424: LD_ADDR_VAR 0 5
72428: PUSH
72429: LD_EXP 87
72433: PUSH
72434: LD_VAR 0 4
72438: ARRAY
72439: PUSH
72440: FOR_IN
72441: IFFALSE 72501
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
72443: LD_VAR 0 3
72447: PPUSH
72448: LD_VAR 0 5
72452: PPUSH
72453: CALL_OW 430
72457: PUSH
72458: LD_VAR 0 4
72462: PPUSH
72463: LD_VAR 0 5
72467: PPUSH
72468: CALL 15720 0 2
72472: AND
72473: IFFALSE 72499
// begin researching := true ;
72475: LD_ADDR_VAR 0 10
72479: PUSH
72480: LD_INT 1
72482: ST_TO_ADDR
// ComResearch ( j , t ) ;
72483: LD_VAR 0 3
72487: PPUSH
72488: LD_VAR 0 5
72492: PPUSH
72493: CALL_OW 124
// break ;
72497: GO 72501
// end ;
72499: GO 72440
72501: POP
72502: POP
// if not researching then
72503: LD_VAR 0 10
72507: NOT
72508: IFFALSE 72520
// idle_lab := j ;
72510: LD_ADDR_VAR 0 11
72514: PUSH
72515: LD_VAR 0 3
72519: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
72520: LD_VAR 0 3
72524: PPUSH
72525: CALL_OW 461
72529: PUSH
72530: LD_INT 10
72532: EQUAL
72533: IFFALSE 73121
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
72535: LD_EXP 89
72539: PUSH
72540: LD_VAR 0 2
72544: ARRAY
72545: NOT
72546: PUSH
72547: LD_EXP 90
72551: PUSH
72552: LD_VAR 0 2
72556: ARRAY
72557: NOT
72558: AND
72559: PUSH
72560: LD_EXP 87
72564: PUSH
72565: LD_VAR 0 4
72569: ARRAY
72570: PUSH
72571: LD_INT 1
72573: GREATER
72574: AND
72575: IFFALSE 72706
// begin ComCancel ( j ) ;
72577: LD_VAR 0 3
72581: PPUSH
72582: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
72586: LD_ADDR_EXP 87
72590: PUSH
72591: LD_EXP 87
72595: PPUSH
72596: LD_VAR 0 4
72600: PPUSH
72601: LD_EXP 87
72605: PUSH
72606: LD_VAR 0 4
72610: ARRAY
72611: PPUSH
72612: LD_EXP 87
72616: PUSH
72617: LD_VAR 0 4
72621: ARRAY
72622: PUSH
72623: LD_INT 1
72625: MINUS
72626: PPUSH
72627: LD_EXP 87
72631: PUSH
72632: LD_VAR 0 4
72636: ARRAY
72637: PPUSH
72638: LD_INT 0
72640: PPUSH
72641: CALL 19421 0 4
72645: PPUSH
72646: CALL_OW 1
72650: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72651: LD_ADDR_EXP 87
72655: PUSH
72656: LD_EXP 87
72660: PPUSH
72661: LD_VAR 0 4
72665: PPUSH
72666: LD_EXP 87
72670: PUSH
72671: LD_VAR 0 4
72675: ARRAY
72676: PPUSH
72677: LD_EXP 87
72681: PUSH
72682: LD_VAR 0 4
72686: ARRAY
72687: PPUSH
72688: LD_INT 1
72690: PPUSH
72691: LD_INT 0
72693: PPUSH
72694: CALL 19421 0 4
72698: PPUSH
72699: CALL_OW 1
72703: ST_TO_ADDR
// continue ;
72704: GO 72278
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72706: LD_EXP 89
72710: PUSH
72711: LD_VAR 0 2
72715: ARRAY
72716: PUSH
72717: LD_EXP 90
72721: PUSH
72722: LD_VAR 0 2
72726: ARRAY
72727: NOT
72728: AND
72729: IFFALSE 72856
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
72731: LD_ADDR_EXP 90
72735: PUSH
72736: LD_EXP 90
72740: PPUSH
72741: LD_VAR 0 2
72745: PUSH
72746: LD_EXP 90
72750: PUSH
72751: LD_VAR 0 2
72755: ARRAY
72756: PUSH
72757: LD_INT 1
72759: PLUS
72760: PUSH
72761: EMPTY
72762: LIST
72763: LIST
72764: PPUSH
72765: LD_EXP 89
72769: PUSH
72770: LD_VAR 0 2
72774: ARRAY
72775: PUSH
72776: LD_INT 1
72778: ARRAY
72779: PPUSH
72780: CALL 20003 0 3
72784: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
72785: LD_EXP 89
72789: PUSH
72790: LD_VAR 0 2
72794: ARRAY
72795: PUSH
72796: LD_INT 1
72798: ARRAY
72799: PPUSH
72800: LD_INT 112
72802: PPUSH
72803: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
72807: LD_ADDR_VAR 0 9
72811: PUSH
72812: LD_EXP 89
72816: PUSH
72817: LD_VAR 0 2
72821: ARRAY
72822: PPUSH
72823: LD_INT 1
72825: PPUSH
72826: CALL_OW 3
72830: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
72831: LD_ADDR_EXP 89
72835: PUSH
72836: LD_EXP 89
72840: PPUSH
72841: LD_VAR 0 2
72845: PPUSH
72846: LD_VAR 0 9
72850: PPUSH
72851: CALL_OW 1
72855: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
72856: LD_EXP 89
72860: PUSH
72861: LD_VAR 0 2
72865: ARRAY
72866: PUSH
72867: LD_EXP 90
72871: PUSH
72872: LD_VAR 0 2
72876: ARRAY
72877: AND
72878: PUSH
72879: LD_EXP 90
72883: PUSH
72884: LD_VAR 0 2
72888: ARRAY
72889: PUSH
72890: LD_INT 1
72892: ARRAY
72893: PPUSH
72894: CALL_OW 310
72898: NOT
72899: AND
72900: PUSH
72901: LD_VAR 0 3
72905: PPUSH
72906: CALL_OW 313
72910: PUSH
72911: LD_INT 6
72913: EQUAL
72914: AND
72915: IFFALSE 72971
// begin tmp2 := UnitsInside ( j ) ;
72917: LD_ADDR_VAR 0 9
72921: PUSH
72922: LD_VAR 0 3
72926: PPUSH
72927: CALL_OW 313
72931: ST_TO_ADDR
// if tmp2 = 6 then
72932: LD_VAR 0 9
72936: PUSH
72937: LD_INT 6
72939: EQUAL
72940: IFFALSE 72971
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72942: LD_VAR 0 9
72946: PUSH
72947: LD_INT 1
72949: ARRAY
72950: PPUSH
72951: LD_INT 112
72953: PPUSH
72954: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72958: LD_VAR 0 9
72962: PUSH
72963: LD_INT 1
72965: ARRAY
72966: PPUSH
72967: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72971: LD_EXP 90
72975: PUSH
72976: LD_VAR 0 2
72980: ARRAY
72981: PUSH
72982: LD_EXP 90
72986: PUSH
72987: LD_VAR 0 2
72991: ARRAY
72992: PUSH
72993: LD_INT 1
72995: ARRAY
72996: PPUSH
72997: CALL_OW 314
73001: NOT
73002: AND
73003: PUSH
73004: LD_EXP 90
73008: PUSH
73009: LD_VAR 0 2
73013: ARRAY
73014: PUSH
73015: LD_INT 1
73017: ARRAY
73018: PPUSH
73019: CALL_OW 310
73023: NOT
73024: AND
73025: IFFALSE 73051
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73027: LD_EXP 90
73031: PUSH
73032: LD_VAR 0 2
73036: ARRAY
73037: PUSH
73038: LD_INT 1
73040: ARRAY
73041: PPUSH
73042: LD_VAR 0 3
73046: PPUSH
73047: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
73051: LD_EXP 90
73055: PUSH
73056: LD_VAR 0 2
73060: ARRAY
73061: PUSH
73062: LD_INT 1
73064: ARRAY
73065: PPUSH
73066: CALL_OW 310
73070: PUSH
73071: LD_EXP 90
73075: PUSH
73076: LD_VAR 0 2
73080: ARRAY
73081: PUSH
73082: LD_INT 1
73084: ARRAY
73085: PPUSH
73086: CALL_OW 310
73090: PPUSH
73091: CALL_OW 461
73095: PUSH
73096: LD_INT 3
73098: NONEQUAL
73099: AND
73100: IFFALSE 73121
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
73102: LD_EXP 90
73106: PUSH
73107: LD_VAR 0 2
73111: ARRAY
73112: PUSH
73113: LD_INT 1
73115: ARRAY
73116: PPUSH
73117: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
73121: LD_VAR 0 3
73125: PPUSH
73126: CALL_OW 461
73130: PUSH
73131: LD_INT 6
73133: EQUAL
73134: PUSH
73135: LD_VAR 0 6
73139: PUSH
73140: LD_INT 1
73142: GREATER
73143: AND
73144: IFFALSE 73296
// begin sci := [ ] ;
73146: LD_ADDR_VAR 0 8
73150: PUSH
73151: EMPTY
73152: ST_TO_ADDR
// for x in ( tmp diff j ) do
73153: LD_ADDR_VAR 0 7
73157: PUSH
73158: LD_VAR 0 6
73162: PUSH
73163: LD_VAR 0 3
73167: DIFF
73168: PUSH
73169: FOR_IN
73170: IFFALSE 73222
// begin if sci = 6 then
73172: LD_VAR 0 8
73176: PUSH
73177: LD_INT 6
73179: EQUAL
73180: IFFALSE 73184
// break ;
73182: GO 73222
// if BuildingStatus ( x ) = bs_idle then
73184: LD_VAR 0 7
73188: PPUSH
73189: CALL_OW 461
73193: PUSH
73194: LD_INT 2
73196: EQUAL
73197: IFFALSE 73220
// sci := sci ^ UnitsInside ( x ) ;
73199: LD_ADDR_VAR 0 8
73203: PUSH
73204: LD_VAR 0 8
73208: PUSH
73209: LD_VAR 0 7
73213: PPUSH
73214: CALL_OW 313
73218: ADD
73219: ST_TO_ADDR
// end ;
73220: GO 73169
73222: POP
73223: POP
// if not sci then
73224: LD_VAR 0 8
73228: NOT
73229: IFFALSE 73233
// continue ;
73231: GO 72278
// for x in sci do
73233: LD_ADDR_VAR 0 7
73237: PUSH
73238: LD_VAR 0 8
73242: PUSH
73243: FOR_IN
73244: IFFALSE 73294
// if IsInUnit ( x ) and not HasTask ( x ) then
73246: LD_VAR 0 7
73250: PPUSH
73251: CALL_OW 310
73255: PUSH
73256: LD_VAR 0 7
73260: PPUSH
73261: CALL_OW 314
73265: NOT
73266: AND
73267: IFFALSE 73292
// begin ComExitBuilding ( x ) ;
73269: LD_VAR 0 7
73273: PPUSH
73274: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73278: LD_VAR 0 7
73282: PPUSH
73283: LD_VAR 0 3
73287: PPUSH
73288: CALL_OW 180
// end ;
73292: GO 73243
73294: POP
73295: POP
// end ; end ;
73296: GO 72278
73298: POP
73299: POP
// end ;
73300: GO 72232
73302: POP
73303: POP
// end ;
73304: LD_VAR 0 1
73308: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
73309: LD_INT 0
73311: PPUSH
73312: PPUSH
// if not mc_bases then
73313: LD_EXP 60
73317: NOT
73318: IFFALSE 73322
// exit ;
73320: GO 73403
// for i = 1 to mc_bases do
73322: LD_ADDR_VAR 0 2
73326: PUSH
73327: DOUBLE
73328: LD_INT 1
73330: DEC
73331: ST_TO_ADDR
73332: LD_EXP 60
73336: PUSH
73337: FOR_TO
73338: IFFALSE 73401
// if mc_mines [ i ] and mc_miners [ i ] then
73340: LD_EXP 73
73344: PUSH
73345: LD_VAR 0 2
73349: ARRAY
73350: PUSH
73351: LD_EXP 74
73355: PUSH
73356: LD_VAR 0 2
73360: ARRAY
73361: AND
73362: IFFALSE 73399
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
73364: LD_EXP 74
73368: PUSH
73369: LD_VAR 0 2
73373: ARRAY
73374: PUSH
73375: LD_INT 1
73377: ARRAY
73378: PPUSH
73379: CALL_OW 255
73383: PPUSH
73384: LD_EXP 73
73388: PUSH
73389: LD_VAR 0 2
73393: ARRAY
73394: PPUSH
73395: CALL 16803 0 2
73399: GO 73337
73401: POP
73402: POP
// end ;
73403: LD_VAR 0 1
73407: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
73408: LD_INT 0
73410: PPUSH
73411: PPUSH
73412: PPUSH
73413: PPUSH
73414: PPUSH
73415: PPUSH
73416: PPUSH
73417: PPUSH
// if not mc_bases or not mc_parking then
73418: LD_EXP 60
73422: NOT
73423: PUSH
73424: LD_EXP 84
73428: NOT
73429: OR
73430: IFFALSE 73434
// exit ;
73432: GO 74144
// for i = 1 to mc_bases do
73434: LD_ADDR_VAR 0 2
73438: PUSH
73439: DOUBLE
73440: LD_INT 1
73442: DEC
73443: ST_TO_ADDR
73444: LD_EXP 60
73448: PUSH
73449: FOR_TO
73450: IFFALSE 74142
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
73452: LD_EXP 60
73456: PUSH
73457: LD_VAR 0 2
73461: ARRAY
73462: NOT
73463: PUSH
73464: LD_EXP 84
73468: PUSH
73469: LD_VAR 0 2
73473: ARRAY
73474: NOT
73475: OR
73476: IFFALSE 73480
// continue ;
73478: GO 73449
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
73480: LD_ADDR_VAR 0 5
73484: PUSH
73485: LD_EXP 60
73489: PUSH
73490: LD_VAR 0 2
73494: ARRAY
73495: PUSH
73496: LD_INT 1
73498: ARRAY
73499: PPUSH
73500: CALL_OW 255
73504: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73505: LD_ADDR_VAR 0 6
73509: PUSH
73510: LD_EXP 60
73514: PUSH
73515: LD_VAR 0 2
73519: ARRAY
73520: PPUSH
73521: LD_INT 30
73523: PUSH
73524: LD_INT 3
73526: PUSH
73527: EMPTY
73528: LIST
73529: LIST
73530: PPUSH
73531: CALL_OW 72
73535: ST_TO_ADDR
// if not fac then
73536: LD_VAR 0 6
73540: NOT
73541: IFFALSE 73592
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73543: LD_ADDR_VAR 0 6
73547: PUSH
73548: LD_EXP 60
73552: PUSH
73553: LD_VAR 0 2
73557: ARRAY
73558: PPUSH
73559: LD_INT 2
73561: PUSH
73562: LD_INT 30
73564: PUSH
73565: LD_INT 0
73567: PUSH
73568: EMPTY
73569: LIST
73570: LIST
73571: PUSH
73572: LD_INT 30
73574: PUSH
73575: LD_INT 1
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: LIST
73586: PPUSH
73587: CALL_OW 72
73591: ST_TO_ADDR
// if not fac then
73592: LD_VAR 0 6
73596: NOT
73597: IFFALSE 73601
// continue ;
73599: GO 73449
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73601: LD_ADDR_VAR 0 7
73605: PUSH
73606: LD_EXP 84
73610: PUSH
73611: LD_VAR 0 2
73615: ARRAY
73616: PPUSH
73617: LD_INT 22
73619: PUSH
73620: LD_VAR 0 5
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: LD_INT 21
73631: PUSH
73632: LD_INT 2
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: PUSH
73639: LD_INT 3
73641: PUSH
73642: LD_INT 24
73644: PUSH
73645: LD_INT 1000
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: LIST
73660: PPUSH
73661: CALL_OW 70
73665: ST_TO_ADDR
// for j in fac do
73666: LD_ADDR_VAR 0 3
73670: PUSH
73671: LD_VAR 0 6
73675: PUSH
73676: FOR_IN
73677: IFFALSE 73758
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73679: LD_ADDR_VAR 0 7
73683: PUSH
73684: LD_VAR 0 7
73688: PUSH
73689: LD_INT 22
73691: PUSH
73692: LD_VAR 0 5
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: PUSH
73701: LD_INT 91
73703: PUSH
73704: LD_VAR 0 3
73708: PUSH
73709: LD_INT 15
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: LIST
73716: PUSH
73717: LD_INT 21
73719: PUSH
73720: LD_INT 2
73722: PUSH
73723: EMPTY
73724: LIST
73725: LIST
73726: PUSH
73727: LD_INT 3
73729: PUSH
73730: LD_INT 24
73732: PUSH
73733: LD_INT 1000
73735: PUSH
73736: EMPTY
73737: LIST
73738: LIST
73739: PUSH
73740: EMPTY
73741: LIST
73742: LIST
73743: PUSH
73744: EMPTY
73745: LIST
73746: LIST
73747: LIST
73748: LIST
73749: PPUSH
73750: CALL_OW 69
73754: UNION
73755: ST_TO_ADDR
73756: GO 73676
73758: POP
73759: POP
// if not vehs then
73760: LD_VAR 0 7
73764: NOT
73765: IFFALSE 73791
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73767: LD_ADDR_EXP 72
73771: PUSH
73772: LD_EXP 72
73776: PPUSH
73777: LD_VAR 0 2
73781: PPUSH
73782: EMPTY
73783: PPUSH
73784: CALL_OW 1
73788: ST_TO_ADDR
// continue ;
73789: GO 73449
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73791: LD_ADDR_VAR 0 8
73795: PUSH
73796: LD_EXP 60
73800: PUSH
73801: LD_VAR 0 2
73805: ARRAY
73806: PPUSH
73807: LD_INT 30
73809: PUSH
73810: LD_INT 3
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PPUSH
73817: CALL_OW 72
73821: ST_TO_ADDR
// if tmp then
73822: LD_VAR 0 8
73826: IFFALSE 73929
// begin for j in tmp do
73828: LD_ADDR_VAR 0 3
73832: PUSH
73833: LD_VAR 0 8
73837: PUSH
73838: FOR_IN
73839: IFFALSE 73927
// for k in UnitsInside ( j ) do
73841: LD_ADDR_VAR 0 4
73845: PUSH
73846: LD_VAR 0 3
73850: PPUSH
73851: CALL_OW 313
73855: PUSH
73856: FOR_IN
73857: IFFALSE 73923
// if k then
73859: LD_VAR 0 4
73863: IFFALSE 73921
// if not k in mc_repair_vehicle [ i ] then
73865: LD_VAR 0 4
73869: PUSH
73870: LD_EXP 72
73874: PUSH
73875: LD_VAR 0 2
73879: ARRAY
73880: IN
73881: NOT
73882: IFFALSE 73921
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73884: LD_ADDR_EXP 72
73888: PUSH
73889: LD_EXP 72
73893: PPUSH
73894: LD_VAR 0 2
73898: PPUSH
73899: LD_EXP 72
73903: PUSH
73904: LD_VAR 0 2
73908: ARRAY
73909: PUSH
73910: LD_VAR 0 4
73914: UNION
73915: PPUSH
73916: CALL_OW 1
73920: ST_TO_ADDR
73921: GO 73856
73923: POP
73924: POP
73925: GO 73838
73927: POP
73928: POP
// end ; if not mc_repair_vehicle [ i ] then
73929: LD_EXP 72
73933: PUSH
73934: LD_VAR 0 2
73938: ARRAY
73939: NOT
73940: IFFALSE 73944
// continue ;
73942: GO 73449
// for j in mc_repair_vehicle [ i ] do
73944: LD_ADDR_VAR 0 3
73948: PUSH
73949: LD_EXP 72
73953: PUSH
73954: LD_VAR 0 2
73958: ARRAY
73959: PUSH
73960: FOR_IN
73961: IFFALSE 74138
// begin if GetClass ( j ) <> 3 then
73963: LD_VAR 0 3
73967: PPUSH
73968: CALL_OW 257
73972: PUSH
73973: LD_INT 3
73975: NONEQUAL
73976: IFFALSE 74017
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73978: LD_ADDR_EXP 72
73982: PUSH
73983: LD_EXP 72
73987: PPUSH
73988: LD_VAR 0 2
73992: PPUSH
73993: LD_EXP 72
73997: PUSH
73998: LD_VAR 0 2
74002: ARRAY
74003: PUSH
74004: LD_VAR 0 3
74008: DIFF
74009: PPUSH
74010: CALL_OW 1
74014: ST_TO_ADDR
// continue ;
74015: GO 73960
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74017: LD_VAR 0 3
74021: PPUSH
74022: CALL_OW 311
74026: NOT
74027: PUSH
74028: LD_VAR 0 3
74032: PUSH
74033: LD_EXP 63
74037: PUSH
74038: LD_VAR 0 2
74042: ARRAY
74043: PUSH
74044: LD_INT 1
74046: ARRAY
74047: IN
74048: NOT
74049: AND
74050: PUSH
74051: LD_VAR 0 3
74055: PUSH
74056: LD_EXP 63
74060: PUSH
74061: LD_VAR 0 2
74065: ARRAY
74066: PUSH
74067: LD_INT 2
74069: ARRAY
74070: IN
74071: NOT
74072: AND
74073: IFFALSE 74136
// begin if IsInUnit ( j ) then
74075: LD_VAR 0 3
74079: PPUSH
74080: CALL_OW 310
74084: IFFALSE 74097
// ComExitBuilding ( j ) else
74086: LD_VAR 0 3
74090: PPUSH
74091: CALL_OW 122
74095: GO 74136
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
74097: LD_VAR 0 3
74101: PPUSH
74102: LD_VAR 0 7
74106: PUSH
74107: LD_INT 1
74109: ARRAY
74110: PPUSH
74111: CALL 53755 0 2
74115: NOT
74116: IFFALSE 74136
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
74118: LD_VAR 0 3
74122: PPUSH
74123: LD_VAR 0 7
74127: PUSH
74128: LD_INT 1
74130: ARRAY
74131: PPUSH
74132: CALL_OW 129
// end ; end ;
74136: GO 73960
74138: POP
74139: POP
// end ;
74140: GO 73449
74142: POP
74143: POP
// end ;
74144: LD_VAR 0 1
74148: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
74149: LD_INT 0
74151: PPUSH
74152: PPUSH
74153: PPUSH
74154: PPUSH
74155: PPUSH
74156: PPUSH
74157: PPUSH
74158: PPUSH
74159: PPUSH
74160: PPUSH
74161: PPUSH
// if not mc_bases then
74162: LD_EXP 60
74166: NOT
74167: IFFALSE 74171
// exit ;
74169: GO 74973
// for i = 1 to mc_bases do
74171: LD_ADDR_VAR 0 2
74175: PUSH
74176: DOUBLE
74177: LD_INT 1
74179: DEC
74180: ST_TO_ADDR
74181: LD_EXP 60
74185: PUSH
74186: FOR_TO
74187: IFFALSE 74971
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
74189: LD_EXP 88
74193: PUSH
74194: LD_VAR 0 2
74198: ARRAY
74199: NOT
74200: PUSH
74201: LD_EXP 63
74205: PUSH
74206: LD_VAR 0 2
74210: ARRAY
74211: PUSH
74212: LD_INT 1
74214: ARRAY
74215: OR
74216: PUSH
74217: LD_EXP 63
74221: PUSH
74222: LD_VAR 0 2
74226: ARRAY
74227: PUSH
74228: LD_INT 2
74230: ARRAY
74231: OR
74232: PUSH
74233: LD_EXP 86
74237: PUSH
74238: LD_VAR 0 2
74242: ARRAY
74243: PPUSH
74244: LD_INT 1
74246: PPUSH
74247: CALL_OW 325
74251: NOT
74252: OR
74253: PUSH
74254: LD_EXP 83
74258: PUSH
74259: LD_VAR 0 2
74263: ARRAY
74264: OR
74265: IFFALSE 74269
// continue ;
74267: GO 74186
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
74269: LD_ADDR_VAR 0 8
74273: PUSH
74274: LD_EXP 60
74278: PUSH
74279: LD_VAR 0 2
74283: ARRAY
74284: PPUSH
74285: LD_INT 25
74287: PUSH
74288: LD_INT 4
74290: PUSH
74291: EMPTY
74292: LIST
74293: LIST
74294: PUSH
74295: LD_INT 50
74297: PUSH
74298: EMPTY
74299: LIST
74300: PUSH
74301: LD_INT 3
74303: PUSH
74304: LD_INT 60
74306: PUSH
74307: EMPTY
74308: LIST
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: LIST
74318: PPUSH
74319: CALL_OW 72
74323: PUSH
74324: LD_EXP 64
74328: PUSH
74329: LD_VAR 0 2
74333: ARRAY
74334: DIFF
74335: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74336: LD_ADDR_VAR 0 9
74340: PUSH
74341: LD_EXP 60
74345: PUSH
74346: LD_VAR 0 2
74350: ARRAY
74351: PPUSH
74352: LD_INT 2
74354: PUSH
74355: LD_INT 30
74357: PUSH
74358: LD_INT 0
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 30
74367: PUSH
74368: LD_INT 1
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: LIST
74379: PPUSH
74380: CALL_OW 72
74384: ST_TO_ADDR
// if not tmp or not dep then
74385: LD_VAR 0 8
74389: NOT
74390: PUSH
74391: LD_VAR 0 9
74395: NOT
74396: OR
74397: IFFALSE 74401
// continue ;
74399: GO 74186
// side := GetSide ( tmp [ 1 ] ) ;
74401: LD_ADDR_VAR 0 11
74405: PUSH
74406: LD_VAR 0 8
74410: PUSH
74411: LD_INT 1
74413: ARRAY
74414: PPUSH
74415: CALL_OW 255
74419: ST_TO_ADDR
// dep := dep [ 1 ] ;
74420: LD_ADDR_VAR 0 9
74424: PUSH
74425: LD_VAR 0 9
74429: PUSH
74430: LD_INT 1
74432: ARRAY
74433: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
74434: LD_ADDR_VAR 0 7
74438: PUSH
74439: LD_EXP 88
74443: PUSH
74444: LD_VAR 0 2
74448: ARRAY
74449: PPUSH
74450: LD_INT 22
74452: PUSH
74453: LD_INT 0
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: LD_INT 25
74462: PUSH
74463: LD_INT 12
74465: PUSH
74466: EMPTY
74467: LIST
74468: LIST
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: PPUSH
74474: CALL_OW 70
74478: PUSH
74479: LD_INT 22
74481: PUSH
74482: LD_INT 0
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 25
74491: PUSH
74492: LD_INT 12
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 91
74501: PUSH
74502: LD_VAR 0 9
74506: PUSH
74507: LD_INT 20
74509: PUSH
74510: EMPTY
74511: LIST
74512: LIST
74513: LIST
74514: PUSH
74515: EMPTY
74516: LIST
74517: LIST
74518: LIST
74519: PPUSH
74520: CALL_OW 69
74524: UNION
74525: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
74526: LD_ADDR_VAR 0 10
74530: PUSH
74531: LD_EXP 88
74535: PUSH
74536: LD_VAR 0 2
74540: ARRAY
74541: PPUSH
74542: LD_INT 81
74544: PUSH
74545: LD_VAR 0 11
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PPUSH
74554: CALL_OW 70
74558: ST_TO_ADDR
// if not apes or danger_at_area then
74559: LD_VAR 0 7
74563: NOT
74564: PUSH
74565: LD_VAR 0 10
74569: OR
74570: IFFALSE 74620
// begin if mc_taming [ i ] then
74572: LD_EXP 91
74576: PUSH
74577: LD_VAR 0 2
74581: ARRAY
74582: IFFALSE 74618
// begin MC_Reset ( i , 121 ) ;
74584: LD_VAR 0 2
74588: PPUSH
74589: LD_INT 121
74591: PPUSH
74592: CALL 59606 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74596: LD_ADDR_EXP 91
74600: PUSH
74601: LD_EXP 91
74605: PPUSH
74606: LD_VAR 0 2
74610: PPUSH
74611: EMPTY
74612: PPUSH
74613: CALL_OW 1
74617: ST_TO_ADDR
// end ; continue ;
74618: GO 74186
// end ; for j in tmp do
74620: LD_ADDR_VAR 0 3
74624: PUSH
74625: LD_VAR 0 8
74629: PUSH
74630: FOR_IN
74631: IFFALSE 74967
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74633: LD_VAR 0 3
74637: PUSH
74638: LD_EXP 91
74642: PUSH
74643: LD_VAR 0 2
74647: ARRAY
74648: IN
74649: NOT
74650: PUSH
74651: LD_EXP 91
74655: PUSH
74656: LD_VAR 0 2
74660: ARRAY
74661: PUSH
74662: LD_INT 3
74664: LESS
74665: AND
74666: IFFALSE 74724
// begin SetTag ( j , 121 ) ;
74668: LD_VAR 0 3
74672: PPUSH
74673: LD_INT 121
74675: PPUSH
74676: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74680: LD_ADDR_EXP 91
74684: PUSH
74685: LD_EXP 91
74689: PPUSH
74690: LD_VAR 0 2
74694: PUSH
74695: LD_EXP 91
74699: PUSH
74700: LD_VAR 0 2
74704: ARRAY
74705: PUSH
74706: LD_INT 1
74708: PLUS
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: PPUSH
74714: LD_VAR 0 3
74718: PPUSH
74719: CALL 20003 0 3
74723: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74724: LD_VAR 0 3
74728: PUSH
74729: LD_EXP 91
74733: PUSH
74734: LD_VAR 0 2
74738: ARRAY
74739: IN
74740: IFFALSE 74965
// begin if GetClass ( j ) <> 4 then
74742: LD_VAR 0 3
74746: PPUSH
74747: CALL_OW 257
74751: PUSH
74752: LD_INT 4
74754: NONEQUAL
74755: IFFALSE 74808
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
74757: LD_ADDR_EXP 91
74761: PUSH
74762: LD_EXP 91
74766: PPUSH
74767: LD_VAR 0 2
74771: PPUSH
74772: LD_EXP 91
74776: PUSH
74777: LD_VAR 0 2
74781: ARRAY
74782: PUSH
74783: LD_VAR 0 3
74787: DIFF
74788: PPUSH
74789: CALL_OW 1
74793: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74794: LD_VAR 0 3
74798: PPUSH
74799: LD_INT 0
74801: PPUSH
74802: CALL_OW 109
// continue ;
74806: GO 74630
// end ; if IsInUnit ( j ) then
74808: LD_VAR 0 3
74812: PPUSH
74813: CALL_OW 310
74817: IFFALSE 74828
// ComExitBuilding ( j ) ;
74819: LD_VAR 0 3
74823: PPUSH
74824: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
74828: LD_ADDR_VAR 0 6
74832: PUSH
74833: LD_VAR 0 7
74837: PPUSH
74838: LD_VAR 0 3
74842: PPUSH
74843: CALL_OW 74
74847: ST_TO_ADDR
// if not ape then
74848: LD_VAR 0 6
74852: NOT
74853: IFFALSE 74857
// break ;
74855: GO 74967
// x := GetX ( ape ) ;
74857: LD_ADDR_VAR 0 4
74861: PUSH
74862: LD_VAR 0 6
74866: PPUSH
74867: CALL_OW 250
74871: ST_TO_ADDR
// y := GetY ( ape ) ;
74872: LD_ADDR_VAR 0 5
74876: PUSH
74877: LD_VAR 0 6
74881: PPUSH
74882: CALL_OW 251
74886: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74887: LD_VAR 0 4
74891: PPUSH
74892: LD_VAR 0 5
74896: PPUSH
74897: CALL_OW 488
74901: NOT
74902: PUSH
74903: LD_VAR 0 11
74907: PPUSH
74908: LD_VAR 0 4
74912: PPUSH
74913: LD_VAR 0 5
74917: PPUSH
74918: LD_INT 20
74920: PPUSH
74921: CALL 20899 0 4
74925: PUSH
74926: LD_INT 4
74928: ARRAY
74929: OR
74930: IFFALSE 74934
// break ;
74932: GO 74967
// if not HasTask ( j ) then
74934: LD_VAR 0 3
74938: PPUSH
74939: CALL_OW 314
74943: NOT
74944: IFFALSE 74965
// ComTameXY ( j , x , y ) ;
74946: LD_VAR 0 3
74950: PPUSH
74951: LD_VAR 0 4
74955: PPUSH
74956: LD_VAR 0 5
74960: PPUSH
74961: CALL_OW 131
// end ; end ;
74965: GO 74630
74967: POP
74968: POP
// end ;
74969: GO 74186
74971: POP
74972: POP
// end ;
74973: LD_VAR 0 1
74977: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74978: LD_INT 0
74980: PPUSH
74981: PPUSH
74982: PPUSH
74983: PPUSH
74984: PPUSH
74985: PPUSH
74986: PPUSH
74987: PPUSH
// if not mc_bases then
74988: LD_EXP 60
74992: NOT
74993: IFFALSE 74997
// exit ;
74995: GO 75623
// for i = 1 to mc_bases do
74997: LD_ADDR_VAR 0 2
75001: PUSH
75002: DOUBLE
75003: LD_INT 1
75005: DEC
75006: ST_TO_ADDR
75007: LD_EXP 60
75011: PUSH
75012: FOR_TO
75013: IFFALSE 75621
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75015: LD_EXP 89
75019: PUSH
75020: LD_VAR 0 2
75024: ARRAY
75025: NOT
75026: PUSH
75027: LD_EXP 89
75031: PUSH
75032: LD_VAR 0 2
75036: ARRAY
75037: PPUSH
75038: LD_INT 25
75040: PUSH
75041: LD_INT 12
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: PPUSH
75048: CALL_OW 72
75052: NOT
75053: OR
75054: IFFALSE 75058
// continue ;
75056: GO 75012
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
75058: LD_ADDR_VAR 0 5
75062: PUSH
75063: LD_EXP 89
75067: PUSH
75068: LD_VAR 0 2
75072: ARRAY
75073: PUSH
75074: LD_INT 1
75076: ARRAY
75077: PPUSH
75078: CALL_OW 255
75082: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
75083: LD_VAR 0 5
75087: PPUSH
75088: LD_INT 2
75090: PPUSH
75091: CALL_OW 325
75095: IFFALSE 75348
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75097: LD_ADDR_VAR 0 4
75101: PUSH
75102: LD_EXP 89
75106: PUSH
75107: LD_VAR 0 2
75111: ARRAY
75112: PPUSH
75113: LD_INT 25
75115: PUSH
75116: LD_INT 16
75118: PUSH
75119: EMPTY
75120: LIST
75121: LIST
75122: PPUSH
75123: CALL_OW 72
75127: ST_TO_ADDR
// if tmp < 6 then
75128: LD_VAR 0 4
75132: PUSH
75133: LD_INT 6
75135: LESS
75136: IFFALSE 75348
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75138: LD_ADDR_VAR 0 6
75142: PUSH
75143: LD_EXP 60
75147: PUSH
75148: LD_VAR 0 2
75152: ARRAY
75153: PPUSH
75154: LD_INT 2
75156: PUSH
75157: LD_INT 30
75159: PUSH
75160: LD_INT 0
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: PUSH
75167: LD_INT 30
75169: PUSH
75170: LD_INT 1
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: LIST
75181: PPUSH
75182: CALL_OW 72
75186: ST_TO_ADDR
// if depot then
75187: LD_VAR 0 6
75191: IFFALSE 75348
// begin selected := 0 ;
75193: LD_ADDR_VAR 0 7
75197: PUSH
75198: LD_INT 0
75200: ST_TO_ADDR
// for j in depot do
75201: LD_ADDR_VAR 0 3
75205: PUSH
75206: LD_VAR 0 6
75210: PUSH
75211: FOR_IN
75212: IFFALSE 75243
// begin if UnitsInside ( j ) < 6 then
75214: LD_VAR 0 3
75218: PPUSH
75219: CALL_OW 313
75223: PUSH
75224: LD_INT 6
75226: LESS
75227: IFFALSE 75241
// begin selected := j ;
75229: LD_ADDR_VAR 0 7
75233: PUSH
75234: LD_VAR 0 3
75238: ST_TO_ADDR
// break ;
75239: GO 75243
// end ; end ;
75241: GO 75211
75243: POP
75244: POP
// if selected then
75245: LD_VAR 0 7
75249: IFFALSE 75348
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75251: LD_ADDR_VAR 0 3
75255: PUSH
75256: LD_EXP 89
75260: PUSH
75261: LD_VAR 0 2
75265: ARRAY
75266: PPUSH
75267: LD_INT 25
75269: PUSH
75270: LD_INT 12
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: PPUSH
75277: CALL_OW 72
75281: PUSH
75282: FOR_IN
75283: IFFALSE 75346
// if not HasTask ( j ) then
75285: LD_VAR 0 3
75289: PPUSH
75290: CALL_OW 314
75294: NOT
75295: IFFALSE 75344
// begin if not IsInUnit ( j ) then
75297: LD_VAR 0 3
75301: PPUSH
75302: CALL_OW 310
75306: NOT
75307: IFFALSE 75323
// ComEnterUnit ( j , selected ) ;
75309: LD_VAR 0 3
75313: PPUSH
75314: LD_VAR 0 7
75318: PPUSH
75319: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
75323: LD_VAR 0 3
75327: PPUSH
75328: LD_INT 16
75330: PPUSH
75331: CALL_OW 183
// AddComExitBuilding ( j ) ;
75335: LD_VAR 0 3
75339: PPUSH
75340: CALL_OW 182
// end ;
75344: GO 75282
75346: POP
75347: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
75348: LD_VAR 0 5
75352: PPUSH
75353: LD_INT 11
75355: PPUSH
75356: CALL_OW 325
75360: IFFALSE 75619
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75362: LD_ADDR_VAR 0 4
75366: PUSH
75367: LD_EXP 89
75371: PUSH
75372: LD_VAR 0 2
75376: ARRAY
75377: PPUSH
75378: LD_INT 25
75380: PUSH
75381: LD_INT 16
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: PPUSH
75388: CALL_OW 72
75392: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
75393: LD_VAR 0 4
75397: PUSH
75398: LD_INT 6
75400: GREATEREQUAL
75401: PUSH
75402: LD_VAR 0 5
75406: PPUSH
75407: LD_INT 2
75409: PPUSH
75410: CALL_OW 325
75414: NOT
75415: OR
75416: IFFALSE 75619
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
75418: LD_ADDR_VAR 0 8
75422: PUSH
75423: LD_EXP 60
75427: PUSH
75428: LD_VAR 0 2
75432: ARRAY
75433: PPUSH
75434: LD_INT 2
75436: PUSH
75437: LD_INT 30
75439: PUSH
75440: LD_INT 4
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: PUSH
75447: LD_INT 30
75449: PUSH
75450: LD_INT 5
75452: PUSH
75453: EMPTY
75454: LIST
75455: LIST
75456: PUSH
75457: EMPTY
75458: LIST
75459: LIST
75460: LIST
75461: PPUSH
75462: CALL_OW 72
75466: ST_TO_ADDR
// if barracks then
75467: LD_VAR 0 8
75471: IFFALSE 75619
// begin selected := 0 ;
75473: LD_ADDR_VAR 0 7
75477: PUSH
75478: LD_INT 0
75480: ST_TO_ADDR
// for j in barracks do
75481: LD_ADDR_VAR 0 3
75485: PUSH
75486: LD_VAR 0 8
75490: PUSH
75491: FOR_IN
75492: IFFALSE 75523
// begin if UnitsInside ( j ) < 6 then
75494: LD_VAR 0 3
75498: PPUSH
75499: CALL_OW 313
75503: PUSH
75504: LD_INT 6
75506: LESS
75507: IFFALSE 75521
// begin selected := j ;
75509: LD_ADDR_VAR 0 7
75513: PUSH
75514: LD_VAR 0 3
75518: ST_TO_ADDR
// break ;
75519: GO 75523
// end ; end ;
75521: GO 75491
75523: POP
75524: POP
// if selected then
75525: LD_VAR 0 7
75529: IFFALSE 75619
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75531: LD_ADDR_VAR 0 3
75535: PUSH
75536: LD_EXP 89
75540: PUSH
75541: LD_VAR 0 2
75545: ARRAY
75546: PPUSH
75547: LD_INT 25
75549: PUSH
75550: LD_INT 12
75552: PUSH
75553: EMPTY
75554: LIST
75555: LIST
75556: PPUSH
75557: CALL_OW 72
75561: PUSH
75562: FOR_IN
75563: IFFALSE 75617
// if not IsInUnit ( j ) and not HasTask ( j ) then
75565: LD_VAR 0 3
75569: PPUSH
75570: CALL_OW 310
75574: NOT
75575: PUSH
75576: LD_VAR 0 3
75580: PPUSH
75581: CALL_OW 314
75585: NOT
75586: AND
75587: IFFALSE 75615
// begin ComEnterUnit ( j , selected ) ;
75589: LD_VAR 0 3
75593: PPUSH
75594: LD_VAR 0 7
75598: PPUSH
75599: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75603: LD_VAR 0 3
75607: PPUSH
75608: LD_INT 15
75610: PPUSH
75611: CALL_OW 183
// end ;
75615: GO 75562
75617: POP
75618: POP
// end ; end ; end ; end ; end ;
75619: GO 75012
75621: POP
75622: POP
// end ;
75623: LD_VAR 0 1
75627: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75628: LD_INT 0
75630: PPUSH
75631: PPUSH
75632: PPUSH
75633: PPUSH
// if not mc_bases then
75634: LD_EXP 60
75638: NOT
75639: IFFALSE 75643
// exit ;
75641: GO 75821
// for i = 1 to mc_bases do
75643: LD_ADDR_VAR 0 2
75647: PUSH
75648: DOUBLE
75649: LD_INT 1
75651: DEC
75652: ST_TO_ADDR
75653: LD_EXP 60
75657: PUSH
75658: FOR_TO
75659: IFFALSE 75819
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75661: LD_ADDR_VAR 0 4
75665: PUSH
75666: LD_EXP 60
75670: PUSH
75671: LD_VAR 0 2
75675: ARRAY
75676: PPUSH
75677: LD_INT 25
75679: PUSH
75680: LD_INT 9
75682: PUSH
75683: EMPTY
75684: LIST
75685: LIST
75686: PPUSH
75687: CALL_OW 72
75691: ST_TO_ADDR
// if not tmp then
75692: LD_VAR 0 4
75696: NOT
75697: IFFALSE 75701
// continue ;
75699: GO 75658
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75701: LD_EXP 86
75705: PUSH
75706: LD_VAR 0 2
75710: ARRAY
75711: PPUSH
75712: LD_INT 29
75714: PPUSH
75715: CALL_OW 325
75719: NOT
75720: PUSH
75721: LD_EXP 86
75725: PUSH
75726: LD_VAR 0 2
75730: ARRAY
75731: PPUSH
75732: LD_INT 28
75734: PPUSH
75735: CALL_OW 325
75739: NOT
75740: AND
75741: IFFALSE 75745
// continue ;
75743: GO 75658
// for j in tmp do
75745: LD_ADDR_VAR 0 3
75749: PUSH
75750: LD_VAR 0 4
75754: PUSH
75755: FOR_IN
75756: IFFALSE 75815
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75758: LD_VAR 0 3
75762: PUSH
75763: LD_EXP 63
75767: PUSH
75768: LD_VAR 0 2
75772: ARRAY
75773: PUSH
75774: LD_INT 1
75776: ARRAY
75777: IN
75778: NOT
75779: PUSH
75780: LD_VAR 0 3
75784: PUSH
75785: LD_EXP 63
75789: PUSH
75790: LD_VAR 0 2
75794: ARRAY
75795: PUSH
75796: LD_INT 2
75798: ARRAY
75799: IN
75800: NOT
75801: AND
75802: IFFALSE 75813
// ComSpaceTimeShoot ( j ) ;
75804: LD_VAR 0 3
75808: PPUSH
75809: CALL 15811 0 1
75813: GO 75755
75815: POP
75816: POP
// end ;
75817: GO 75658
75819: POP
75820: POP
// end ;
75821: LD_VAR 0 1
75825: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
75826: LD_INT 0
75828: PPUSH
75829: PPUSH
75830: PPUSH
75831: PPUSH
75832: PPUSH
75833: PPUSH
75834: PPUSH
75835: PPUSH
75836: PPUSH
// if not mc_bases then
75837: LD_EXP 60
75841: NOT
75842: IFFALSE 75846
// exit ;
75844: GO 76468
// for i = 1 to mc_bases do
75846: LD_ADDR_VAR 0 2
75850: PUSH
75851: DOUBLE
75852: LD_INT 1
75854: DEC
75855: ST_TO_ADDR
75856: LD_EXP 60
75860: PUSH
75861: FOR_TO
75862: IFFALSE 76466
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
75864: LD_EXP 95
75868: PUSH
75869: LD_VAR 0 2
75873: ARRAY
75874: NOT
75875: PUSH
75876: LD_INT 38
75878: PPUSH
75879: LD_EXP 86
75883: PUSH
75884: LD_VAR 0 2
75888: ARRAY
75889: PPUSH
75890: CALL_OW 321
75894: PUSH
75895: LD_INT 2
75897: NONEQUAL
75898: OR
75899: IFFALSE 75903
// continue ;
75901: GO 75861
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75903: LD_ADDR_VAR 0 8
75907: PUSH
75908: LD_EXP 60
75912: PUSH
75913: LD_VAR 0 2
75917: ARRAY
75918: PPUSH
75919: LD_INT 30
75921: PUSH
75922: LD_INT 34
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PPUSH
75929: CALL_OW 72
75933: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75934: LD_ADDR_VAR 0 9
75938: PUSH
75939: LD_EXP 60
75943: PUSH
75944: LD_VAR 0 2
75948: ARRAY
75949: PPUSH
75950: LD_INT 25
75952: PUSH
75953: LD_INT 4
75955: PUSH
75956: EMPTY
75957: LIST
75958: LIST
75959: PPUSH
75960: CALL_OW 72
75964: PPUSH
75965: LD_INT 0
75967: PPUSH
75968: CALL 49272 0 2
75972: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75973: LD_VAR 0 9
75977: NOT
75978: PUSH
75979: LD_VAR 0 8
75983: NOT
75984: OR
75985: PUSH
75986: LD_EXP 60
75990: PUSH
75991: LD_VAR 0 2
75995: ARRAY
75996: PPUSH
75997: LD_INT 124
75999: PPUSH
76000: CALL 49272 0 2
76004: OR
76005: IFFALSE 76009
// continue ;
76007: GO 75861
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76009: LD_EXP 96
76013: PUSH
76014: LD_VAR 0 2
76018: ARRAY
76019: PUSH
76020: LD_EXP 95
76024: PUSH
76025: LD_VAR 0 2
76029: ARRAY
76030: LESS
76031: PUSH
76032: LD_EXP 96
76036: PUSH
76037: LD_VAR 0 2
76041: ARRAY
76042: PUSH
76043: LD_VAR 0 8
76047: LESS
76048: AND
76049: IFFALSE 76464
// begin tmp := sci [ 1 ] ;
76051: LD_ADDR_VAR 0 7
76055: PUSH
76056: LD_VAR 0 9
76060: PUSH
76061: LD_INT 1
76063: ARRAY
76064: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
76065: LD_VAR 0 7
76069: PPUSH
76070: LD_INT 124
76072: PPUSH
76073: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
76077: LD_ADDR_VAR 0 3
76081: PUSH
76082: DOUBLE
76083: LD_EXP 95
76087: PUSH
76088: LD_VAR 0 2
76092: ARRAY
76093: INC
76094: ST_TO_ADDR
76095: LD_EXP 95
76099: PUSH
76100: LD_VAR 0 2
76104: ARRAY
76105: PUSH
76106: FOR_DOWNTO
76107: IFFALSE 76450
// begin if IsInUnit ( tmp ) then
76109: LD_VAR 0 7
76113: PPUSH
76114: CALL_OW 310
76118: IFFALSE 76129
// ComExitBuilding ( tmp ) ;
76120: LD_VAR 0 7
76124: PPUSH
76125: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
76129: LD_INT 35
76131: PPUSH
76132: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
76136: LD_VAR 0 7
76140: PPUSH
76141: CALL_OW 310
76145: NOT
76146: PUSH
76147: LD_VAR 0 7
76151: PPUSH
76152: CALL_OW 314
76156: NOT
76157: AND
76158: IFFALSE 76129
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
76160: LD_ADDR_VAR 0 6
76164: PUSH
76165: LD_VAR 0 7
76169: PPUSH
76170: CALL_OW 250
76174: PUSH
76175: LD_VAR 0 7
76179: PPUSH
76180: CALL_OW 251
76184: PUSH
76185: EMPTY
76186: LIST
76187: LIST
76188: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76189: LD_INT 35
76191: PPUSH
76192: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
76196: LD_ADDR_VAR 0 4
76200: PUSH
76201: LD_EXP 95
76205: PUSH
76206: LD_VAR 0 2
76210: ARRAY
76211: PUSH
76212: LD_VAR 0 3
76216: ARRAY
76217: PUSH
76218: LD_INT 1
76220: ARRAY
76221: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
76222: LD_ADDR_VAR 0 5
76226: PUSH
76227: LD_EXP 95
76231: PUSH
76232: LD_VAR 0 2
76236: ARRAY
76237: PUSH
76238: LD_VAR 0 3
76242: ARRAY
76243: PUSH
76244: LD_INT 2
76246: ARRAY
76247: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
76248: LD_VAR 0 7
76252: PPUSH
76253: LD_INT 10
76255: PPUSH
76256: CALL 22602 0 2
76260: PUSH
76261: LD_INT 4
76263: ARRAY
76264: IFFALSE 76302
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
76266: LD_VAR 0 7
76270: PPUSH
76271: LD_VAR 0 6
76275: PUSH
76276: LD_INT 1
76278: ARRAY
76279: PPUSH
76280: LD_VAR 0 6
76284: PUSH
76285: LD_INT 2
76287: ARRAY
76288: PPUSH
76289: CALL_OW 111
// wait ( 0 0$10 ) ;
76293: LD_INT 350
76295: PPUSH
76296: CALL_OW 67
// end else
76300: GO 76328
// begin ComMoveXY ( tmp , x , y ) ;
76302: LD_VAR 0 7
76306: PPUSH
76307: LD_VAR 0 4
76311: PPUSH
76312: LD_VAR 0 5
76316: PPUSH
76317: CALL_OW 111
// wait ( 0 0$3 ) ;
76321: LD_INT 105
76323: PPUSH
76324: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
76328: LD_VAR 0 7
76332: PPUSH
76333: LD_VAR 0 4
76337: PPUSH
76338: LD_VAR 0 5
76342: PPUSH
76343: CALL_OW 307
76347: IFFALSE 76189
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
76349: LD_VAR 0 7
76353: PPUSH
76354: LD_VAR 0 4
76358: PPUSH
76359: LD_VAR 0 5
76363: PPUSH
76364: LD_VAR 0 8
76368: PUSH
76369: LD_VAR 0 3
76373: ARRAY
76374: PPUSH
76375: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
76379: LD_INT 35
76381: PPUSH
76382: CALL_OW 67
// until not HasTask ( tmp ) ;
76386: LD_VAR 0 7
76390: PPUSH
76391: CALL_OW 314
76395: NOT
76396: IFFALSE 76379
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
76398: LD_ADDR_EXP 96
76402: PUSH
76403: LD_EXP 96
76407: PPUSH
76408: LD_VAR 0 2
76412: PUSH
76413: LD_EXP 96
76417: PUSH
76418: LD_VAR 0 2
76422: ARRAY
76423: PUSH
76424: LD_INT 1
76426: PLUS
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: PPUSH
76432: LD_VAR 0 8
76436: PUSH
76437: LD_VAR 0 3
76441: ARRAY
76442: PPUSH
76443: CALL 20003 0 3
76447: ST_TO_ADDR
// end ;
76448: GO 76106
76450: POP
76451: POP
// MC_Reset ( i , 124 ) ;
76452: LD_VAR 0 2
76456: PPUSH
76457: LD_INT 124
76459: PPUSH
76460: CALL 59606 0 2
// end ; end ;
76464: GO 75861
76466: POP
76467: POP
// end ;
76468: LD_VAR 0 1
76472: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
76473: LD_INT 0
76475: PPUSH
76476: PPUSH
76477: PPUSH
// if not mc_bases then
76478: LD_EXP 60
76482: NOT
76483: IFFALSE 76487
// exit ;
76485: GO 77093
// for i = 1 to mc_bases do
76487: LD_ADDR_VAR 0 2
76491: PUSH
76492: DOUBLE
76493: LD_INT 1
76495: DEC
76496: ST_TO_ADDR
76497: LD_EXP 60
76501: PUSH
76502: FOR_TO
76503: IFFALSE 77091
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
76505: LD_ADDR_VAR 0 3
76509: PUSH
76510: LD_EXP 60
76514: PUSH
76515: LD_VAR 0 2
76519: ARRAY
76520: PPUSH
76521: LD_INT 25
76523: PUSH
76524: LD_INT 4
76526: PUSH
76527: EMPTY
76528: LIST
76529: LIST
76530: PPUSH
76531: CALL_OW 72
76535: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76536: LD_VAR 0 3
76540: NOT
76541: PUSH
76542: LD_EXP 97
76546: PUSH
76547: LD_VAR 0 2
76551: ARRAY
76552: NOT
76553: OR
76554: PUSH
76555: LD_EXP 60
76559: PUSH
76560: LD_VAR 0 2
76564: ARRAY
76565: PPUSH
76566: LD_INT 2
76568: PUSH
76569: LD_INT 30
76571: PUSH
76572: LD_INT 0
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: LD_INT 30
76581: PUSH
76582: LD_INT 1
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: LIST
76593: PPUSH
76594: CALL_OW 72
76598: NOT
76599: OR
76600: IFFALSE 76650
// begin if mc_deposits_finder [ i ] then
76602: LD_EXP 98
76606: PUSH
76607: LD_VAR 0 2
76611: ARRAY
76612: IFFALSE 76648
// begin MC_Reset ( i , 125 ) ;
76614: LD_VAR 0 2
76618: PPUSH
76619: LD_INT 125
76621: PPUSH
76622: CALL 59606 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76626: LD_ADDR_EXP 98
76630: PUSH
76631: LD_EXP 98
76635: PPUSH
76636: LD_VAR 0 2
76640: PPUSH
76641: EMPTY
76642: PPUSH
76643: CALL_OW 1
76647: ST_TO_ADDR
// end ; continue ;
76648: GO 76502
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76650: LD_EXP 97
76654: PUSH
76655: LD_VAR 0 2
76659: ARRAY
76660: PUSH
76661: LD_INT 1
76663: ARRAY
76664: PUSH
76665: LD_INT 3
76667: ARRAY
76668: PUSH
76669: LD_INT 1
76671: EQUAL
76672: PUSH
76673: LD_INT 20
76675: PPUSH
76676: LD_EXP 86
76680: PUSH
76681: LD_VAR 0 2
76685: ARRAY
76686: PPUSH
76687: CALL_OW 321
76691: PUSH
76692: LD_INT 2
76694: NONEQUAL
76695: AND
76696: IFFALSE 76746
// begin if mc_deposits_finder [ i ] then
76698: LD_EXP 98
76702: PUSH
76703: LD_VAR 0 2
76707: ARRAY
76708: IFFALSE 76744
// begin MC_Reset ( i , 125 ) ;
76710: LD_VAR 0 2
76714: PPUSH
76715: LD_INT 125
76717: PPUSH
76718: CALL 59606 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76722: LD_ADDR_EXP 98
76726: PUSH
76727: LD_EXP 98
76731: PPUSH
76732: LD_VAR 0 2
76736: PPUSH
76737: EMPTY
76738: PPUSH
76739: CALL_OW 1
76743: ST_TO_ADDR
// end ; continue ;
76744: GO 76502
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
76746: LD_EXP 97
76750: PUSH
76751: LD_VAR 0 2
76755: ARRAY
76756: PUSH
76757: LD_INT 1
76759: ARRAY
76760: PUSH
76761: LD_INT 1
76763: ARRAY
76764: PPUSH
76765: LD_EXP 97
76769: PUSH
76770: LD_VAR 0 2
76774: ARRAY
76775: PUSH
76776: LD_INT 1
76778: ARRAY
76779: PUSH
76780: LD_INT 2
76782: ARRAY
76783: PPUSH
76784: LD_EXP 86
76788: PUSH
76789: LD_VAR 0 2
76793: ARRAY
76794: PPUSH
76795: CALL_OW 440
76799: IFFALSE 76842
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
76801: LD_ADDR_EXP 97
76805: PUSH
76806: LD_EXP 97
76810: PPUSH
76811: LD_VAR 0 2
76815: PPUSH
76816: LD_EXP 97
76820: PUSH
76821: LD_VAR 0 2
76825: ARRAY
76826: PPUSH
76827: LD_INT 1
76829: PPUSH
76830: CALL_OW 3
76834: PPUSH
76835: CALL_OW 1
76839: ST_TO_ADDR
76840: GO 77089
// begin if not mc_deposits_finder [ i ] then
76842: LD_EXP 98
76846: PUSH
76847: LD_VAR 0 2
76851: ARRAY
76852: NOT
76853: IFFALSE 76905
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
76855: LD_ADDR_EXP 98
76859: PUSH
76860: LD_EXP 98
76864: PPUSH
76865: LD_VAR 0 2
76869: PPUSH
76870: LD_VAR 0 3
76874: PUSH
76875: LD_INT 1
76877: ARRAY
76878: PUSH
76879: EMPTY
76880: LIST
76881: PPUSH
76882: CALL_OW 1
76886: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76887: LD_VAR 0 3
76891: PUSH
76892: LD_INT 1
76894: ARRAY
76895: PPUSH
76896: LD_INT 125
76898: PPUSH
76899: CALL_OW 109
// end else
76903: GO 77089
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76905: LD_EXP 98
76909: PUSH
76910: LD_VAR 0 2
76914: ARRAY
76915: PUSH
76916: LD_INT 1
76918: ARRAY
76919: PPUSH
76920: CALL_OW 310
76924: IFFALSE 76947
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76926: LD_EXP 98
76930: PUSH
76931: LD_VAR 0 2
76935: ARRAY
76936: PUSH
76937: LD_INT 1
76939: ARRAY
76940: PPUSH
76941: CALL_OW 122
76945: GO 77089
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76947: LD_EXP 98
76951: PUSH
76952: LD_VAR 0 2
76956: ARRAY
76957: PUSH
76958: LD_INT 1
76960: ARRAY
76961: PPUSH
76962: CALL_OW 314
76966: NOT
76967: PUSH
76968: LD_EXP 98
76972: PUSH
76973: LD_VAR 0 2
76977: ARRAY
76978: PUSH
76979: LD_INT 1
76981: ARRAY
76982: PPUSH
76983: LD_EXP 97
76987: PUSH
76988: LD_VAR 0 2
76992: ARRAY
76993: PUSH
76994: LD_INT 1
76996: ARRAY
76997: PUSH
76998: LD_INT 1
77000: ARRAY
77001: PPUSH
77002: LD_EXP 97
77006: PUSH
77007: LD_VAR 0 2
77011: ARRAY
77012: PUSH
77013: LD_INT 1
77015: ARRAY
77016: PUSH
77017: LD_INT 2
77019: ARRAY
77020: PPUSH
77021: CALL_OW 297
77025: PUSH
77026: LD_INT 6
77028: GREATER
77029: AND
77030: IFFALSE 77089
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
77032: LD_EXP 98
77036: PUSH
77037: LD_VAR 0 2
77041: ARRAY
77042: PUSH
77043: LD_INT 1
77045: ARRAY
77046: PPUSH
77047: LD_EXP 97
77051: PUSH
77052: LD_VAR 0 2
77056: ARRAY
77057: PUSH
77058: LD_INT 1
77060: ARRAY
77061: PUSH
77062: LD_INT 1
77064: ARRAY
77065: PPUSH
77066: LD_EXP 97
77070: PUSH
77071: LD_VAR 0 2
77075: ARRAY
77076: PUSH
77077: LD_INT 1
77079: ARRAY
77080: PUSH
77081: LD_INT 2
77083: ARRAY
77084: PPUSH
77085: CALL_OW 111
// end ; end ; end ;
77089: GO 76502
77091: POP
77092: POP
// end ;
77093: LD_VAR 0 1
77097: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
77098: LD_INT 0
77100: PPUSH
77101: PPUSH
77102: PPUSH
77103: PPUSH
77104: PPUSH
77105: PPUSH
77106: PPUSH
77107: PPUSH
77108: PPUSH
77109: PPUSH
77110: PPUSH
// if not mc_bases then
77111: LD_EXP 60
77115: NOT
77116: IFFALSE 77120
// exit ;
77118: GO 78060
// for i = 1 to mc_bases do
77120: LD_ADDR_VAR 0 2
77124: PUSH
77125: DOUBLE
77126: LD_INT 1
77128: DEC
77129: ST_TO_ADDR
77130: LD_EXP 60
77134: PUSH
77135: FOR_TO
77136: IFFALSE 78058
// begin if not mc_bases [ i ] or mc_scan [ i ] then
77138: LD_EXP 60
77142: PUSH
77143: LD_VAR 0 2
77147: ARRAY
77148: NOT
77149: PUSH
77150: LD_EXP 83
77154: PUSH
77155: LD_VAR 0 2
77159: ARRAY
77160: OR
77161: IFFALSE 77165
// continue ;
77163: GO 77135
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
77165: LD_ADDR_VAR 0 7
77169: PUSH
77170: LD_EXP 60
77174: PUSH
77175: LD_VAR 0 2
77179: ARRAY
77180: PUSH
77181: LD_INT 1
77183: ARRAY
77184: PPUSH
77185: CALL_OW 248
77189: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
77190: LD_VAR 0 7
77194: PUSH
77195: LD_INT 3
77197: EQUAL
77198: PUSH
77199: LD_EXP 79
77203: PUSH
77204: LD_VAR 0 2
77208: ARRAY
77209: PUSH
77210: LD_EXP 82
77214: PUSH
77215: LD_VAR 0 2
77219: ARRAY
77220: UNION
77221: PPUSH
77222: LD_INT 33
77224: PUSH
77225: LD_INT 2
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: PPUSH
77232: CALL_OW 72
77236: NOT
77237: OR
77238: IFFALSE 77242
// continue ;
77240: GO 77135
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
77242: LD_ADDR_VAR 0 9
77246: PUSH
77247: LD_EXP 60
77251: PUSH
77252: LD_VAR 0 2
77256: ARRAY
77257: PPUSH
77258: LD_INT 30
77260: PUSH
77261: LD_INT 36
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PPUSH
77268: CALL_OW 72
77272: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
77273: LD_ADDR_VAR 0 10
77277: PUSH
77278: LD_EXP 79
77282: PUSH
77283: LD_VAR 0 2
77287: ARRAY
77288: PPUSH
77289: LD_INT 34
77291: PUSH
77292: LD_INT 31
77294: PUSH
77295: EMPTY
77296: LIST
77297: LIST
77298: PPUSH
77299: CALL_OW 72
77303: ST_TO_ADDR
// if not cts and not mcts then
77304: LD_VAR 0 9
77308: NOT
77309: PUSH
77310: LD_VAR 0 10
77314: NOT
77315: AND
77316: IFFALSE 77320
// continue ;
77318: GO 77135
// x := cts ;
77320: LD_ADDR_VAR 0 11
77324: PUSH
77325: LD_VAR 0 9
77329: ST_TO_ADDR
// if not x then
77330: LD_VAR 0 11
77334: NOT
77335: IFFALSE 77347
// x := mcts ;
77337: LD_ADDR_VAR 0 11
77341: PUSH
77342: LD_VAR 0 10
77346: ST_TO_ADDR
// if not x then
77347: LD_VAR 0 11
77351: NOT
77352: IFFALSE 77356
// continue ;
77354: GO 77135
// if mc_remote_driver [ i ] then
77356: LD_EXP 100
77360: PUSH
77361: LD_VAR 0 2
77365: ARRAY
77366: IFFALSE 77753
// for j in mc_remote_driver [ i ] do
77368: LD_ADDR_VAR 0 3
77372: PUSH
77373: LD_EXP 100
77377: PUSH
77378: LD_VAR 0 2
77382: ARRAY
77383: PUSH
77384: FOR_IN
77385: IFFALSE 77751
// begin if GetClass ( j ) <> 3 then
77387: LD_VAR 0 3
77391: PPUSH
77392: CALL_OW 257
77396: PUSH
77397: LD_INT 3
77399: NONEQUAL
77400: IFFALSE 77453
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
77402: LD_ADDR_EXP 100
77406: PUSH
77407: LD_EXP 100
77411: PPUSH
77412: LD_VAR 0 2
77416: PPUSH
77417: LD_EXP 100
77421: PUSH
77422: LD_VAR 0 2
77426: ARRAY
77427: PUSH
77428: LD_VAR 0 3
77432: DIFF
77433: PPUSH
77434: CALL_OW 1
77438: ST_TO_ADDR
// SetTag ( j , 0 ) ;
77439: LD_VAR 0 3
77443: PPUSH
77444: LD_INT 0
77446: PPUSH
77447: CALL_OW 109
// continue ;
77451: GO 77384
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
77453: LD_EXP 79
77457: PUSH
77458: LD_VAR 0 2
77462: ARRAY
77463: PPUSH
77464: LD_INT 34
77466: PUSH
77467: LD_INT 31
77469: PUSH
77470: EMPTY
77471: LIST
77472: LIST
77473: PUSH
77474: LD_INT 58
77476: PUSH
77477: EMPTY
77478: LIST
77479: PUSH
77480: EMPTY
77481: LIST
77482: LIST
77483: PPUSH
77484: CALL_OW 72
77488: PUSH
77489: LD_VAR 0 3
77493: PPUSH
77494: CALL 49307 0 1
77498: NOT
77499: AND
77500: IFFALSE 77571
// begin if IsInUnit ( j ) then
77502: LD_VAR 0 3
77506: PPUSH
77507: CALL_OW 310
77511: IFFALSE 77522
// ComExitBuilding ( j ) ;
77513: LD_VAR 0 3
77517: PPUSH
77518: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
77522: LD_VAR 0 3
77526: PPUSH
77527: LD_EXP 79
77531: PUSH
77532: LD_VAR 0 2
77536: ARRAY
77537: PPUSH
77538: LD_INT 34
77540: PUSH
77541: LD_INT 31
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: LD_INT 58
77550: PUSH
77551: EMPTY
77552: LIST
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PPUSH
77558: CALL_OW 72
77562: PUSH
77563: LD_INT 1
77565: ARRAY
77566: PPUSH
77567: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
77571: LD_VAR 0 3
77575: PPUSH
77576: CALL_OW 310
77580: NOT
77581: PUSH
77582: LD_VAR 0 3
77586: PPUSH
77587: CALL_OW 310
77591: PPUSH
77592: CALL_OW 266
77596: PUSH
77597: LD_INT 36
77599: NONEQUAL
77600: PUSH
77601: LD_VAR 0 3
77605: PPUSH
77606: CALL 49307 0 1
77610: NOT
77611: AND
77612: OR
77613: IFFALSE 77749
// begin if IsInUnit ( j ) then
77615: LD_VAR 0 3
77619: PPUSH
77620: CALL_OW 310
77624: IFFALSE 77635
// ComExitBuilding ( j ) ;
77626: LD_VAR 0 3
77630: PPUSH
77631: CALL_OW 122
// ct := 0 ;
77635: LD_ADDR_VAR 0 8
77639: PUSH
77640: LD_INT 0
77642: ST_TO_ADDR
// for k in x do
77643: LD_ADDR_VAR 0 4
77647: PUSH
77648: LD_VAR 0 11
77652: PUSH
77653: FOR_IN
77654: IFFALSE 77727
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77656: LD_VAR 0 4
77660: PPUSH
77661: CALL_OW 264
77665: PUSH
77666: LD_INT 31
77668: EQUAL
77669: PUSH
77670: LD_VAR 0 4
77674: PPUSH
77675: CALL_OW 311
77679: NOT
77680: AND
77681: PUSH
77682: LD_VAR 0 4
77686: PPUSH
77687: CALL_OW 266
77691: PUSH
77692: LD_INT 36
77694: EQUAL
77695: PUSH
77696: LD_VAR 0 4
77700: PPUSH
77701: CALL_OW 313
77705: PUSH
77706: LD_INT 3
77708: LESS
77709: AND
77710: OR
77711: IFFALSE 77725
// begin ct := k ;
77713: LD_ADDR_VAR 0 8
77717: PUSH
77718: LD_VAR 0 4
77722: ST_TO_ADDR
// break ;
77723: GO 77727
// end ;
77725: GO 77653
77727: POP
77728: POP
// if ct then
77729: LD_VAR 0 8
77733: IFFALSE 77749
// ComEnterUnit ( j , ct ) ;
77735: LD_VAR 0 3
77739: PPUSH
77740: LD_VAR 0 8
77744: PPUSH
77745: CALL_OW 120
// end ; end ;
77749: GO 77384
77751: POP
77752: POP
// places := 0 ;
77753: LD_ADDR_VAR 0 5
77757: PUSH
77758: LD_INT 0
77760: ST_TO_ADDR
// for j = 1 to x do
77761: LD_ADDR_VAR 0 3
77765: PUSH
77766: DOUBLE
77767: LD_INT 1
77769: DEC
77770: ST_TO_ADDR
77771: LD_VAR 0 11
77775: PUSH
77776: FOR_TO
77777: IFFALSE 77853
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77779: LD_VAR 0 11
77783: PUSH
77784: LD_VAR 0 3
77788: ARRAY
77789: PPUSH
77790: CALL_OW 264
77794: PUSH
77795: LD_INT 31
77797: EQUAL
77798: IFFALSE 77816
// places := places + 1 else
77800: LD_ADDR_VAR 0 5
77804: PUSH
77805: LD_VAR 0 5
77809: PUSH
77810: LD_INT 1
77812: PLUS
77813: ST_TO_ADDR
77814: GO 77851
// if GetBType ( x [ j ] ) = b_control_tower then
77816: LD_VAR 0 11
77820: PUSH
77821: LD_VAR 0 3
77825: ARRAY
77826: PPUSH
77827: CALL_OW 266
77831: PUSH
77832: LD_INT 36
77834: EQUAL
77835: IFFALSE 77851
// places := places + 3 ;
77837: LD_ADDR_VAR 0 5
77841: PUSH
77842: LD_VAR 0 5
77846: PUSH
77847: LD_INT 3
77849: PLUS
77850: ST_TO_ADDR
77851: GO 77776
77853: POP
77854: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
77855: LD_VAR 0 5
77859: PUSH
77860: LD_INT 0
77862: EQUAL
77863: PUSH
77864: LD_VAR 0 5
77868: PUSH
77869: LD_EXP 100
77873: PUSH
77874: LD_VAR 0 2
77878: ARRAY
77879: LESSEQUAL
77880: OR
77881: IFFALSE 77885
// continue ;
77883: GO 77135
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
77885: LD_ADDR_VAR 0 6
77889: PUSH
77890: LD_EXP 60
77894: PUSH
77895: LD_VAR 0 2
77899: ARRAY
77900: PPUSH
77901: LD_INT 25
77903: PUSH
77904: LD_INT 3
77906: PUSH
77907: EMPTY
77908: LIST
77909: LIST
77910: PPUSH
77911: CALL_OW 72
77915: PUSH
77916: LD_EXP 100
77920: PUSH
77921: LD_VAR 0 2
77925: ARRAY
77926: DIFF
77927: PPUSH
77928: LD_INT 3
77930: PPUSH
77931: CALL 50207 0 2
77935: ST_TO_ADDR
// for j in tmp do
77936: LD_ADDR_VAR 0 3
77940: PUSH
77941: LD_VAR 0 6
77945: PUSH
77946: FOR_IN
77947: IFFALSE 77982
// if GetTag ( j ) > 0 then
77949: LD_VAR 0 3
77953: PPUSH
77954: CALL_OW 110
77958: PUSH
77959: LD_INT 0
77961: GREATER
77962: IFFALSE 77980
// tmp := tmp diff j ;
77964: LD_ADDR_VAR 0 6
77968: PUSH
77969: LD_VAR 0 6
77973: PUSH
77974: LD_VAR 0 3
77978: DIFF
77979: ST_TO_ADDR
77980: GO 77946
77982: POP
77983: POP
// if not tmp then
77984: LD_VAR 0 6
77988: NOT
77989: IFFALSE 77993
// continue ;
77991: GO 77135
// if places then
77993: LD_VAR 0 5
77997: IFFALSE 78056
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
77999: LD_ADDR_EXP 100
78003: PUSH
78004: LD_EXP 100
78008: PPUSH
78009: LD_VAR 0 2
78013: PPUSH
78014: LD_EXP 100
78018: PUSH
78019: LD_VAR 0 2
78023: ARRAY
78024: PUSH
78025: LD_VAR 0 6
78029: PUSH
78030: LD_INT 1
78032: ARRAY
78033: UNION
78034: PPUSH
78035: CALL_OW 1
78039: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78040: LD_VAR 0 6
78044: PUSH
78045: LD_INT 1
78047: ARRAY
78048: PPUSH
78049: LD_INT 126
78051: PPUSH
78052: CALL_OW 109
// end ; end ;
78056: GO 77135
78058: POP
78059: POP
// end ;
78060: LD_VAR 0 1
78064: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
78065: LD_INT 0
78067: PPUSH
78068: PPUSH
78069: PPUSH
78070: PPUSH
78071: PPUSH
78072: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
78073: LD_VAR 0 1
78077: NOT
78078: PUSH
78079: LD_VAR 0 2
78083: NOT
78084: OR
78085: PUSH
78086: LD_VAR 0 3
78090: NOT
78091: OR
78092: PUSH
78093: LD_VAR 0 4
78097: PUSH
78098: LD_INT 1
78100: PUSH
78101: LD_INT 2
78103: PUSH
78104: LD_INT 3
78106: PUSH
78107: LD_INT 4
78109: PUSH
78110: LD_INT 5
78112: PUSH
78113: LD_INT 8
78115: PUSH
78116: LD_INT 9
78118: PUSH
78119: LD_INT 15
78121: PUSH
78122: LD_INT 16
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: LIST
78129: LIST
78130: LIST
78131: LIST
78132: LIST
78133: LIST
78134: LIST
78135: IN
78136: NOT
78137: OR
78138: IFFALSE 78142
// exit ;
78140: GO 79042
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
78142: LD_ADDR_VAR 0 2
78146: PUSH
78147: LD_VAR 0 2
78151: PPUSH
78152: LD_INT 21
78154: PUSH
78155: LD_INT 3
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 24
78164: PUSH
78165: LD_INT 250
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PPUSH
78176: CALL_OW 72
78180: ST_TO_ADDR
// case class of 1 , 15 :
78181: LD_VAR 0 4
78185: PUSH
78186: LD_INT 1
78188: DOUBLE
78189: EQUAL
78190: IFTRUE 78200
78192: LD_INT 15
78194: DOUBLE
78195: EQUAL
78196: IFTRUE 78200
78198: GO 78285
78200: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
78201: LD_ADDR_VAR 0 8
78205: PUSH
78206: LD_VAR 0 2
78210: PPUSH
78211: LD_INT 2
78213: PUSH
78214: LD_INT 30
78216: PUSH
78217: LD_INT 32
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: PUSH
78224: LD_INT 30
78226: PUSH
78227: LD_INT 31
78229: PUSH
78230: EMPTY
78231: LIST
78232: LIST
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: LIST
78238: PPUSH
78239: CALL_OW 72
78243: PUSH
78244: LD_VAR 0 2
78248: PPUSH
78249: LD_INT 2
78251: PUSH
78252: LD_INT 30
78254: PUSH
78255: LD_INT 4
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: PUSH
78262: LD_INT 30
78264: PUSH
78265: LD_INT 5
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: LIST
78276: PPUSH
78277: CALL_OW 72
78281: ADD
78282: ST_TO_ADDR
78283: GO 78531
78285: LD_INT 2
78287: DOUBLE
78288: EQUAL
78289: IFTRUE 78299
78291: LD_INT 16
78293: DOUBLE
78294: EQUAL
78295: IFTRUE 78299
78297: GO 78345
78299: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
78300: LD_ADDR_VAR 0 8
78304: PUSH
78305: LD_VAR 0 2
78309: PPUSH
78310: LD_INT 2
78312: PUSH
78313: LD_INT 30
78315: PUSH
78316: LD_INT 0
78318: PUSH
78319: EMPTY
78320: LIST
78321: LIST
78322: PUSH
78323: LD_INT 30
78325: PUSH
78326: LD_INT 1
78328: PUSH
78329: EMPTY
78330: LIST
78331: LIST
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: LIST
78337: PPUSH
78338: CALL_OW 72
78342: ST_TO_ADDR
78343: GO 78531
78345: LD_INT 3
78347: DOUBLE
78348: EQUAL
78349: IFTRUE 78353
78351: GO 78399
78353: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
78354: LD_ADDR_VAR 0 8
78358: PUSH
78359: LD_VAR 0 2
78363: PPUSH
78364: LD_INT 2
78366: PUSH
78367: LD_INT 30
78369: PUSH
78370: LD_INT 2
78372: PUSH
78373: EMPTY
78374: LIST
78375: LIST
78376: PUSH
78377: LD_INT 30
78379: PUSH
78380: LD_INT 3
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: PUSH
78387: EMPTY
78388: LIST
78389: LIST
78390: LIST
78391: PPUSH
78392: CALL_OW 72
78396: ST_TO_ADDR
78397: GO 78531
78399: LD_INT 4
78401: DOUBLE
78402: EQUAL
78403: IFTRUE 78407
78405: GO 78464
78407: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
78408: LD_ADDR_VAR 0 8
78412: PUSH
78413: LD_VAR 0 2
78417: PPUSH
78418: LD_INT 2
78420: PUSH
78421: LD_INT 30
78423: PUSH
78424: LD_INT 6
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: LD_INT 30
78433: PUSH
78434: LD_INT 7
78436: PUSH
78437: EMPTY
78438: LIST
78439: LIST
78440: PUSH
78441: LD_INT 30
78443: PUSH
78444: LD_INT 8
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: LIST
78455: LIST
78456: PPUSH
78457: CALL_OW 72
78461: ST_TO_ADDR
78462: GO 78531
78464: LD_INT 5
78466: DOUBLE
78467: EQUAL
78468: IFTRUE 78484
78470: LD_INT 8
78472: DOUBLE
78473: EQUAL
78474: IFTRUE 78484
78476: LD_INT 9
78478: DOUBLE
78479: EQUAL
78480: IFTRUE 78484
78482: GO 78530
78484: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
78485: LD_ADDR_VAR 0 8
78489: PUSH
78490: LD_VAR 0 2
78494: PPUSH
78495: LD_INT 2
78497: PUSH
78498: LD_INT 30
78500: PUSH
78501: LD_INT 4
78503: PUSH
78504: EMPTY
78505: LIST
78506: LIST
78507: PUSH
78508: LD_INT 30
78510: PUSH
78511: LD_INT 5
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: PUSH
78518: EMPTY
78519: LIST
78520: LIST
78521: LIST
78522: PPUSH
78523: CALL_OW 72
78527: ST_TO_ADDR
78528: GO 78531
78530: POP
// if not tmp then
78531: LD_VAR 0 8
78535: NOT
78536: IFFALSE 78540
// exit ;
78538: GO 79042
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
78540: LD_VAR 0 4
78544: PUSH
78545: LD_INT 1
78547: PUSH
78548: LD_INT 15
78550: PUSH
78551: EMPTY
78552: LIST
78553: LIST
78554: IN
78555: PUSH
78556: LD_EXP 69
78560: PUSH
78561: LD_VAR 0 1
78565: ARRAY
78566: AND
78567: IFFALSE 78723
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
78569: LD_ADDR_VAR 0 9
78573: PUSH
78574: LD_EXP 69
78578: PUSH
78579: LD_VAR 0 1
78583: ARRAY
78584: PUSH
78585: LD_INT 1
78587: ARRAY
78588: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78589: LD_VAR 0 9
78593: PUSH
78594: LD_EXP 70
78598: PUSH
78599: LD_VAR 0 1
78603: ARRAY
78604: IN
78605: NOT
78606: IFFALSE 78721
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78608: LD_ADDR_EXP 70
78612: PUSH
78613: LD_EXP 70
78617: PPUSH
78618: LD_VAR 0 1
78622: PUSH
78623: LD_EXP 70
78627: PUSH
78628: LD_VAR 0 1
78632: ARRAY
78633: PUSH
78634: LD_INT 1
78636: PLUS
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: PPUSH
78642: LD_VAR 0 9
78646: PPUSH
78647: CALL 20003 0 3
78651: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78652: LD_ADDR_EXP 69
78656: PUSH
78657: LD_EXP 69
78661: PPUSH
78662: LD_VAR 0 1
78666: PPUSH
78667: LD_EXP 69
78671: PUSH
78672: LD_VAR 0 1
78676: ARRAY
78677: PUSH
78678: LD_VAR 0 9
78682: DIFF
78683: PPUSH
78684: CALL_OW 1
78688: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78689: LD_VAR 0 3
78693: PPUSH
78694: LD_EXP 70
78698: PUSH
78699: LD_VAR 0 1
78703: ARRAY
78704: PUSH
78705: LD_EXP 70
78709: PUSH
78710: LD_VAR 0 1
78714: ARRAY
78715: ARRAY
78716: PPUSH
78717: CALL_OW 120
// end ; exit ;
78721: GO 79042
// end ; if tmp > 1 then
78723: LD_VAR 0 8
78727: PUSH
78728: LD_INT 1
78730: GREATER
78731: IFFALSE 78835
// for i = 2 to tmp do
78733: LD_ADDR_VAR 0 6
78737: PUSH
78738: DOUBLE
78739: LD_INT 2
78741: DEC
78742: ST_TO_ADDR
78743: LD_VAR 0 8
78747: PUSH
78748: FOR_TO
78749: IFFALSE 78833
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78751: LD_VAR 0 8
78755: PUSH
78756: LD_VAR 0 6
78760: ARRAY
78761: PPUSH
78762: CALL_OW 461
78766: PUSH
78767: LD_INT 6
78769: EQUAL
78770: IFFALSE 78831
// begin x := tmp [ i ] ;
78772: LD_ADDR_VAR 0 9
78776: PUSH
78777: LD_VAR 0 8
78781: PUSH
78782: LD_VAR 0 6
78786: ARRAY
78787: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78788: LD_ADDR_VAR 0 8
78792: PUSH
78793: LD_VAR 0 8
78797: PPUSH
78798: LD_VAR 0 6
78802: PPUSH
78803: CALL_OW 3
78807: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78808: LD_ADDR_VAR 0 8
78812: PUSH
78813: LD_VAR 0 8
78817: PPUSH
78818: LD_INT 1
78820: PPUSH
78821: LD_VAR 0 9
78825: PPUSH
78826: CALL_OW 2
78830: ST_TO_ADDR
// end ;
78831: GO 78748
78833: POP
78834: POP
// for i in tmp do
78835: LD_ADDR_VAR 0 6
78839: PUSH
78840: LD_VAR 0 8
78844: PUSH
78845: FOR_IN
78846: IFFALSE 78915
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
78848: LD_VAR 0 6
78852: PPUSH
78853: CALL_OW 313
78857: PUSH
78858: LD_INT 6
78860: LESS
78861: PUSH
78862: LD_VAR 0 6
78866: PPUSH
78867: CALL_OW 266
78871: PUSH
78872: LD_INT 31
78874: PUSH
78875: LD_INT 32
78877: PUSH
78878: EMPTY
78879: LIST
78880: LIST
78881: IN
78882: NOT
78883: AND
78884: PUSH
78885: LD_VAR 0 6
78889: PPUSH
78890: CALL_OW 313
78894: PUSH
78895: LD_INT 0
78897: EQUAL
78898: OR
78899: IFFALSE 78913
// begin j := i ;
78901: LD_ADDR_VAR 0 7
78905: PUSH
78906: LD_VAR 0 6
78910: ST_TO_ADDR
// break ;
78911: GO 78915
// end ; end ;
78913: GO 78845
78915: POP
78916: POP
// if j then
78917: LD_VAR 0 7
78921: IFFALSE 78939
// ComEnterUnit ( unit , j ) else
78923: LD_VAR 0 3
78927: PPUSH
78928: LD_VAR 0 7
78932: PPUSH
78933: CALL_OW 120
78937: GO 79042
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78939: LD_ADDR_VAR 0 10
78943: PUSH
78944: LD_VAR 0 2
78948: PPUSH
78949: LD_INT 2
78951: PUSH
78952: LD_INT 30
78954: PUSH
78955: LD_INT 0
78957: PUSH
78958: EMPTY
78959: LIST
78960: LIST
78961: PUSH
78962: LD_INT 30
78964: PUSH
78965: LD_INT 1
78967: PUSH
78968: EMPTY
78969: LIST
78970: LIST
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: LIST
78976: PPUSH
78977: CALL_OW 72
78981: ST_TO_ADDR
// if depot then
78982: LD_VAR 0 10
78986: IFFALSE 79042
// begin depot := NearestUnitToUnit ( depot , unit ) ;
78988: LD_ADDR_VAR 0 10
78992: PUSH
78993: LD_VAR 0 10
78997: PPUSH
78998: LD_VAR 0 3
79002: PPUSH
79003: CALL_OW 74
79007: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79008: LD_VAR 0 3
79012: PPUSH
79013: LD_VAR 0 10
79017: PPUSH
79018: CALL_OW 296
79022: PUSH
79023: LD_INT 10
79025: GREATER
79026: IFFALSE 79042
// ComStandNearbyBuilding ( unit , depot ) ;
79028: LD_VAR 0 3
79032: PPUSH
79033: LD_VAR 0 10
79037: PPUSH
79038: CALL 16428 0 2
// end ; end ; end ;
79042: LD_VAR 0 5
79046: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
79047: LD_INT 0
79049: PPUSH
79050: PPUSH
79051: PPUSH
79052: PPUSH
// if not mc_bases then
79053: LD_EXP 60
79057: NOT
79058: IFFALSE 79062
// exit ;
79060: GO 79301
// for i = 1 to mc_bases do
79062: LD_ADDR_VAR 0 2
79066: PUSH
79067: DOUBLE
79068: LD_INT 1
79070: DEC
79071: ST_TO_ADDR
79072: LD_EXP 60
79076: PUSH
79077: FOR_TO
79078: IFFALSE 79299
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
79080: LD_ADDR_VAR 0 4
79084: PUSH
79085: LD_EXP 60
79089: PUSH
79090: LD_VAR 0 2
79094: ARRAY
79095: PPUSH
79096: LD_INT 21
79098: PUSH
79099: LD_INT 1
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PPUSH
79106: CALL_OW 72
79110: PUSH
79111: LD_EXP 89
79115: PUSH
79116: LD_VAR 0 2
79120: ARRAY
79121: UNION
79122: ST_TO_ADDR
// if not tmp then
79123: LD_VAR 0 4
79127: NOT
79128: IFFALSE 79132
// continue ;
79130: GO 79077
// for j in tmp do
79132: LD_ADDR_VAR 0 3
79136: PUSH
79137: LD_VAR 0 4
79141: PUSH
79142: FOR_IN
79143: IFFALSE 79295
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
79145: LD_VAR 0 3
79149: PPUSH
79150: CALL_OW 110
79154: NOT
79155: PUSH
79156: LD_VAR 0 3
79160: PPUSH
79161: CALL_OW 314
79165: NOT
79166: AND
79167: PUSH
79168: LD_VAR 0 3
79172: PPUSH
79173: CALL_OW 311
79177: NOT
79178: AND
79179: PUSH
79180: LD_VAR 0 3
79184: PPUSH
79185: CALL_OW 310
79189: NOT
79190: AND
79191: PUSH
79192: LD_VAR 0 3
79196: PUSH
79197: LD_EXP 63
79201: PUSH
79202: LD_VAR 0 2
79206: ARRAY
79207: PUSH
79208: LD_INT 1
79210: ARRAY
79211: IN
79212: NOT
79213: AND
79214: PUSH
79215: LD_VAR 0 3
79219: PUSH
79220: LD_EXP 63
79224: PUSH
79225: LD_VAR 0 2
79229: ARRAY
79230: PUSH
79231: LD_INT 2
79233: ARRAY
79234: IN
79235: NOT
79236: AND
79237: PUSH
79238: LD_VAR 0 3
79242: PUSH
79243: LD_EXP 72
79247: PUSH
79248: LD_VAR 0 2
79252: ARRAY
79253: IN
79254: NOT
79255: AND
79256: IFFALSE 79293
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
79258: LD_VAR 0 2
79262: PPUSH
79263: LD_EXP 60
79267: PUSH
79268: LD_VAR 0 2
79272: ARRAY
79273: PPUSH
79274: LD_VAR 0 3
79278: PPUSH
79279: LD_VAR 0 3
79283: PPUSH
79284: CALL_OW 257
79288: PPUSH
79289: CALL 78065 0 4
// end ;
79293: GO 79142
79295: POP
79296: POP
// end ;
79297: GO 79077
79299: POP
79300: POP
// end ;
79301: LD_VAR 0 1
79305: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
79306: LD_INT 0
79308: PPUSH
79309: PPUSH
79310: PPUSH
79311: PPUSH
79312: PPUSH
79313: PPUSH
// if not mc_bases [ base ] then
79314: LD_EXP 60
79318: PUSH
79319: LD_VAR 0 1
79323: ARRAY
79324: NOT
79325: IFFALSE 79329
// exit ;
79327: GO 79511
// tmp := [ ] ;
79329: LD_ADDR_VAR 0 6
79333: PUSH
79334: EMPTY
79335: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
79336: LD_ADDR_VAR 0 7
79340: PUSH
79341: LD_VAR 0 3
79345: PPUSH
79346: LD_INT 0
79348: PPUSH
79349: CALL_OW 517
79353: ST_TO_ADDR
// if not list then
79354: LD_VAR 0 7
79358: NOT
79359: IFFALSE 79363
// exit ;
79361: GO 79511
// for i = 1 to amount do
79363: LD_ADDR_VAR 0 5
79367: PUSH
79368: DOUBLE
79369: LD_INT 1
79371: DEC
79372: ST_TO_ADDR
79373: LD_VAR 0 2
79377: PUSH
79378: FOR_TO
79379: IFFALSE 79459
// begin x := rand ( 1 , list [ 1 ] ) ;
79381: LD_ADDR_VAR 0 8
79385: PUSH
79386: LD_INT 1
79388: PPUSH
79389: LD_VAR 0 7
79393: PUSH
79394: LD_INT 1
79396: ARRAY
79397: PPUSH
79398: CALL_OW 12
79402: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
79403: LD_ADDR_VAR 0 6
79407: PUSH
79408: LD_VAR 0 6
79412: PPUSH
79413: LD_VAR 0 5
79417: PPUSH
79418: LD_VAR 0 7
79422: PUSH
79423: LD_INT 1
79425: ARRAY
79426: PUSH
79427: LD_VAR 0 8
79431: ARRAY
79432: PUSH
79433: LD_VAR 0 7
79437: PUSH
79438: LD_INT 2
79440: ARRAY
79441: PUSH
79442: LD_VAR 0 8
79446: ARRAY
79447: PUSH
79448: EMPTY
79449: LIST
79450: LIST
79451: PPUSH
79452: CALL_OW 1
79456: ST_TO_ADDR
// end ;
79457: GO 79378
79459: POP
79460: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
79461: LD_ADDR_EXP 73
79465: PUSH
79466: LD_EXP 73
79470: PPUSH
79471: LD_VAR 0 1
79475: PPUSH
79476: LD_VAR 0 6
79480: PPUSH
79481: CALL_OW 1
79485: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
79486: LD_ADDR_EXP 75
79490: PUSH
79491: LD_EXP 75
79495: PPUSH
79496: LD_VAR 0 1
79500: PPUSH
79501: LD_VAR 0 3
79505: PPUSH
79506: CALL_OW 1
79510: ST_TO_ADDR
// end ;
79511: LD_VAR 0 4
79515: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
79516: LD_INT 0
79518: PPUSH
// if not mc_bases [ base ] then
79519: LD_EXP 60
79523: PUSH
79524: LD_VAR 0 1
79528: ARRAY
79529: NOT
79530: IFFALSE 79534
// exit ;
79532: GO 79559
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
79534: LD_ADDR_EXP 65
79538: PUSH
79539: LD_EXP 65
79543: PPUSH
79544: LD_VAR 0 1
79548: PPUSH
79549: LD_VAR 0 2
79553: PPUSH
79554: CALL_OW 1
79558: ST_TO_ADDR
// end ;
79559: LD_VAR 0 3
79563: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
79564: LD_INT 0
79566: PPUSH
// if not mc_bases [ base ] then
79567: LD_EXP 60
79571: PUSH
79572: LD_VAR 0 1
79576: ARRAY
79577: NOT
79578: IFFALSE 79582
// exit ;
79580: GO 79619
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79582: LD_ADDR_EXP 65
79586: PUSH
79587: LD_EXP 65
79591: PPUSH
79592: LD_VAR 0 1
79596: PPUSH
79597: LD_EXP 65
79601: PUSH
79602: LD_VAR 0 1
79606: ARRAY
79607: PUSH
79608: LD_VAR 0 2
79612: UNION
79613: PPUSH
79614: CALL_OW 1
79618: ST_TO_ADDR
// end ;
79619: LD_VAR 0 3
79623: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79624: LD_INT 0
79626: PPUSH
// if not mc_bases [ base ] then
79627: LD_EXP 60
79631: PUSH
79632: LD_VAR 0 1
79636: ARRAY
79637: NOT
79638: IFFALSE 79642
// exit ;
79640: GO 79667
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79642: LD_ADDR_EXP 81
79646: PUSH
79647: LD_EXP 81
79651: PPUSH
79652: LD_VAR 0 1
79656: PPUSH
79657: LD_VAR 0 2
79661: PPUSH
79662: CALL_OW 1
79666: ST_TO_ADDR
// end ;
79667: LD_VAR 0 3
79671: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79672: LD_INT 0
79674: PPUSH
// if not mc_bases [ base ] then
79675: LD_EXP 60
79679: PUSH
79680: LD_VAR 0 1
79684: ARRAY
79685: NOT
79686: IFFALSE 79690
// exit ;
79688: GO 79727
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79690: LD_ADDR_EXP 81
79694: PUSH
79695: LD_EXP 81
79699: PPUSH
79700: LD_VAR 0 1
79704: PPUSH
79705: LD_EXP 81
79709: PUSH
79710: LD_VAR 0 1
79714: ARRAY
79715: PUSH
79716: LD_VAR 0 2
79720: ADD
79721: PPUSH
79722: CALL_OW 1
79726: ST_TO_ADDR
// end ;
79727: LD_VAR 0 3
79731: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79732: LD_INT 0
79734: PPUSH
// if not mc_bases [ base ] then
79735: LD_EXP 60
79739: PUSH
79740: LD_VAR 0 1
79744: ARRAY
79745: NOT
79746: IFFALSE 79750
// exit ;
79748: GO 79804
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79750: LD_ADDR_EXP 82
79754: PUSH
79755: LD_EXP 82
79759: PPUSH
79760: LD_VAR 0 1
79764: PPUSH
79765: LD_VAR 0 2
79769: PPUSH
79770: CALL_OW 1
79774: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79775: LD_ADDR_EXP 71
79779: PUSH
79780: LD_EXP 71
79784: PPUSH
79785: LD_VAR 0 1
79789: PPUSH
79790: LD_VAR 0 2
79794: PUSH
79795: LD_INT 0
79797: PLUS
79798: PPUSH
79799: CALL_OW 1
79803: ST_TO_ADDR
// end ;
79804: LD_VAR 0 3
79808: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79809: LD_INT 0
79811: PPUSH
// if not mc_bases [ base ] then
79812: LD_EXP 60
79816: PUSH
79817: LD_VAR 0 1
79821: ARRAY
79822: NOT
79823: IFFALSE 79827
// exit ;
79825: GO 79852
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79827: LD_ADDR_EXP 71
79831: PUSH
79832: LD_EXP 71
79836: PPUSH
79837: LD_VAR 0 1
79841: PPUSH
79842: LD_VAR 0 2
79846: PPUSH
79847: CALL_OW 1
79851: ST_TO_ADDR
// end ;
79852: LD_VAR 0 3
79856: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79857: LD_INT 0
79859: PPUSH
79860: PPUSH
79861: PPUSH
79862: PPUSH
// if not mc_bases [ base ] then
79863: LD_EXP 60
79867: PUSH
79868: LD_VAR 0 1
79872: ARRAY
79873: NOT
79874: IFFALSE 79878
// exit ;
79876: GO 79943
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79878: LD_ADDR_EXP 80
79882: PUSH
79883: LD_EXP 80
79887: PPUSH
79888: LD_VAR 0 1
79892: PUSH
79893: LD_EXP 80
79897: PUSH
79898: LD_VAR 0 1
79902: ARRAY
79903: PUSH
79904: LD_INT 1
79906: PLUS
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PPUSH
79912: LD_VAR 0 1
79916: PUSH
79917: LD_VAR 0 2
79921: PUSH
79922: LD_VAR 0 3
79926: PUSH
79927: LD_VAR 0 4
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: LIST
79936: LIST
79937: PPUSH
79938: CALL 20003 0 3
79942: ST_TO_ADDR
// end ;
79943: LD_VAR 0 5
79947: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79948: LD_INT 0
79950: PPUSH
// if not mc_bases [ base ] then
79951: LD_EXP 60
79955: PUSH
79956: LD_VAR 0 1
79960: ARRAY
79961: NOT
79962: IFFALSE 79966
// exit ;
79964: GO 79991
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
79966: LD_ADDR_EXP 97
79970: PUSH
79971: LD_EXP 97
79975: PPUSH
79976: LD_VAR 0 1
79980: PPUSH
79981: LD_VAR 0 2
79985: PPUSH
79986: CALL_OW 1
79990: ST_TO_ADDR
// end ;
79991: LD_VAR 0 3
79995: RET
// export function MC_GetMinesField ( base ) ; begin
79996: LD_INT 0
79998: PPUSH
// result := mc_mines [ base ] ;
79999: LD_ADDR_VAR 0 2
80003: PUSH
80004: LD_EXP 73
80008: PUSH
80009: LD_VAR 0 1
80013: ARRAY
80014: ST_TO_ADDR
// end ;
80015: LD_VAR 0 2
80019: RET
// export function MC_GetProduceList ( base ) ; begin
80020: LD_INT 0
80022: PPUSH
// result := mc_produce [ base ] ;
80023: LD_ADDR_VAR 0 2
80027: PUSH
80028: LD_EXP 81
80032: PUSH
80033: LD_VAR 0 1
80037: ARRAY
80038: ST_TO_ADDR
// end ;
80039: LD_VAR 0 2
80043: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
80044: LD_INT 0
80046: PPUSH
80047: PPUSH
// if not mc_bases then
80048: LD_EXP 60
80052: NOT
80053: IFFALSE 80057
// exit ;
80055: GO 80122
// if mc_bases [ base ] then
80057: LD_EXP 60
80061: PUSH
80062: LD_VAR 0 1
80066: ARRAY
80067: IFFALSE 80122
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80069: LD_ADDR_VAR 0 3
80073: PUSH
80074: LD_EXP 60
80078: PUSH
80079: LD_VAR 0 1
80083: ARRAY
80084: PPUSH
80085: LD_INT 30
80087: PUSH
80088: LD_VAR 0 2
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PPUSH
80097: CALL_OW 72
80101: ST_TO_ADDR
// if result then
80102: LD_VAR 0 3
80106: IFFALSE 80122
// result := result [ 1 ] ;
80108: LD_ADDR_VAR 0 3
80112: PUSH
80113: LD_VAR 0 3
80117: PUSH
80118: LD_INT 1
80120: ARRAY
80121: ST_TO_ADDR
// end ; end ;
80122: LD_VAR 0 3
80126: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
80127: LD_INT 0
80129: PPUSH
80130: PPUSH
// if not mc_bases then
80131: LD_EXP 60
80135: NOT
80136: IFFALSE 80140
// exit ;
80138: GO 80185
// if mc_bases [ base ] then
80140: LD_EXP 60
80144: PUSH
80145: LD_VAR 0 1
80149: ARRAY
80150: IFFALSE 80185
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80152: LD_ADDR_VAR 0 3
80156: PUSH
80157: LD_EXP 60
80161: PUSH
80162: LD_VAR 0 1
80166: ARRAY
80167: PPUSH
80168: LD_INT 30
80170: PUSH
80171: LD_VAR 0 2
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PPUSH
80180: CALL_OW 72
80184: ST_TO_ADDR
// end ;
80185: LD_VAR 0 3
80189: RET
// export function MC_SetTame ( base , area ) ; begin
80190: LD_INT 0
80192: PPUSH
// if not mc_bases or not base then
80193: LD_EXP 60
80197: NOT
80198: PUSH
80199: LD_VAR 0 1
80203: NOT
80204: OR
80205: IFFALSE 80209
// exit ;
80207: GO 80234
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
80209: LD_ADDR_EXP 88
80213: PUSH
80214: LD_EXP 88
80218: PPUSH
80219: LD_VAR 0 1
80223: PPUSH
80224: LD_VAR 0 2
80228: PPUSH
80229: CALL_OW 1
80233: ST_TO_ADDR
// end ;
80234: LD_VAR 0 3
80238: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
80239: LD_INT 0
80241: PPUSH
80242: PPUSH
// if not mc_bases or not base then
80243: LD_EXP 60
80247: NOT
80248: PUSH
80249: LD_VAR 0 1
80253: NOT
80254: OR
80255: IFFALSE 80259
// exit ;
80257: GO 80361
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80259: LD_ADDR_VAR 0 4
80263: PUSH
80264: LD_EXP 60
80268: PUSH
80269: LD_VAR 0 1
80273: ARRAY
80274: PPUSH
80275: LD_INT 30
80277: PUSH
80278: LD_VAR 0 2
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PPUSH
80287: CALL_OW 72
80291: ST_TO_ADDR
// if not tmp then
80292: LD_VAR 0 4
80296: NOT
80297: IFFALSE 80301
// exit ;
80299: GO 80361
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
80301: LD_ADDR_EXP 92
80305: PUSH
80306: LD_EXP 92
80310: PPUSH
80311: LD_VAR 0 1
80315: PPUSH
80316: LD_EXP 92
80320: PUSH
80321: LD_VAR 0 1
80325: ARRAY
80326: PPUSH
80327: LD_EXP 92
80331: PUSH
80332: LD_VAR 0 1
80336: ARRAY
80337: PUSH
80338: LD_INT 1
80340: PLUS
80341: PPUSH
80342: LD_VAR 0 4
80346: PUSH
80347: LD_INT 1
80349: ARRAY
80350: PPUSH
80351: CALL_OW 2
80355: PPUSH
80356: CALL_OW 1
80360: ST_TO_ADDR
// end ;
80361: LD_VAR 0 3
80365: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
80366: LD_INT 0
80368: PPUSH
80369: PPUSH
// if not mc_bases or not base or not kinds then
80370: LD_EXP 60
80374: NOT
80375: PUSH
80376: LD_VAR 0 1
80380: NOT
80381: OR
80382: PUSH
80383: LD_VAR 0 2
80387: NOT
80388: OR
80389: IFFALSE 80393
// exit ;
80391: GO 80454
// for i in kinds do
80393: LD_ADDR_VAR 0 4
80397: PUSH
80398: LD_VAR 0 2
80402: PUSH
80403: FOR_IN
80404: IFFALSE 80452
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
80406: LD_ADDR_EXP 94
80410: PUSH
80411: LD_EXP 94
80415: PPUSH
80416: LD_VAR 0 1
80420: PUSH
80421: LD_EXP 94
80425: PUSH
80426: LD_VAR 0 1
80430: ARRAY
80431: PUSH
80432: LD_INT 1
80434: PLUS
80435: PUSH
80436: EMPTY
80437: LIST
80438: LIST
80439: PPUSH
80440: LD_VAR 0 4
80444: PPUSH
80445: CALL 20003 0 3
80449: ST_TO_ADDR
80450: GO 80403
80452: POP
80453: POP
// end ;
80454: LD_VAR 0 3
80458: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
80459: LD_INT 0
80461: PPUSH
// if not mc_bases or not base or not areas then
80462: LD_EXP 60
80466: NOT
80467: PUSH
80468: LD_VAR 0 1
80472: NOT
80473: OR
80474: PUSH
80475: LD_VAR 0 2
80479: NOT
80480: OR
80481: IFFALSE 80485
// exit ;
80483: GO 80510
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
80485: LD_ADDR_EXP 78
80489: PUSH
80490: LD_EXP 78
80494: PPUSH
80495: LD_VAR 0 1
80499: PPUSH
80500: LD_VAR 0 2
80504: PPUSH
80505: CALL_OW 1
80509: ST_TO_ADDR
// end ;
80510: LD_VAR 0 3
80514: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
80515: LD_INT 0
80517: PPUSH
// if not mc_bases or not base or not teleports_exit then
80518: LD_EXP 60
80522: NOT
80523: PUSH
80524: LD_VAR 0 1
80528: NOT
80529: OR
80530: PUSH
80531: LD_VAR 0 2
80535: NOT
80536: OR
80537: IFFALSE 80541
// exit ;
80539: GO 80566
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
80541: LD_ADDR_EXP 95
80545: PUSH
80546: LD_EXP 95
80550: PPUSH
80551: LD_VAR 0 1
80555: PPUSH
80556: LD_VAR 0 2
80560: PPUSH
80561: CALL_OW 1
80565: ST_TO_ADDR
// end ;
80566: LD_VAR 0 3
80570: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
80571: LD_INT 0
80573: PPUSH
80574: PPUSH
80575: PPUSH
// if not mc_bases or not base or not ext_list then
80576: LD_EXP 60
80580: NOT
80581: PUSH
80582: LD_VAR 0 1
80586: NOT
80587: OR
80588: PUSH
80589: LD_VAR 0 5
80593: NOT
80594: OR
80595: IFFALSE 80599
// exit ;
80597: GO 80772
// tmp := GetFacExtXYD ( x , y , d ) ;
80599: LD_ADDR_VAR 0 8
80603: PUSH
80604: LD_VAR 0 2
80608: PPUSH
80609: LD_VAR 0 3
80613: PPUSH
80614: LD_VAR 0 4
80618: PPUSH
80619: CALL 49337 0 3
80623: ST_TO_ADDR
// if not tmp then
80624: LD_VAR 0 8
80628: NOT
80629: IFFALSE 80633
// exit ;
80631: GO 80772
// for i in tmp do
80633: LD_ADDR_VAR 0 7
80637: PUSH
80638: LD_VAR 0 8
80642: PUSH
80643: FOR_IN
80644: IFFALSE 80770
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80646: LD_ADDR_EXP 65
80650: PUSH
80651: LD_EXP 65
80655: PPUSH
80656: LD_VAR 0 1
80660: PPUSH
80661: LD_EXP 65
80665: PUSH
80666: LD_VAR 0 1
80670: ARRAY
80671: PPUSH
80672: LD_EXP 65
80676: PUSH
80677: LD_VAR 0 1
80681: ARRAY
80682: PUSH
80683: LD_INT 1
80685: PLUS
80686: PPUSH
80687: LD_VAR 0 5
80691: PUSH
80692: LD_INT 1
80694: ARRAY
80695: PUSH
80696: LD_VAR 0 7
80700: PUSH
80701: LD_INT 1
80703: ARRAY
80704: PUSH
80705: LD_VAR 0 7
80709: PUSH
80710: LD_INT 2
80712: ARRAY
80713: PUSH
80714: LD_VAR 0 7
80718: PUSH
80719: LD_INT 3
80721: ARRAY
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: PPUSH
80729: CALL_OW 2
80733: PPUSH
80734: CALL_OW 1
80738: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80739: LD_ADDR_VAR 0 5
80743: PUSH
80744: LD_VAR 0 5
80748: PPUSH
80749: LD_INT 1
80751: PPUSH
80752: CALL_OW 3
80756: ST_TO_ADDR
// if not ext_list then
80757: LD_VAR 0 5
80761: NOT
80762: IFFALSE 80768
// exit ;
80764: POP
80765: POP
80766: GO 80772
// end ;
80768: GO 80643
80770: POP
80771: POP
// end ;
80772: LD_VAR 0 6
80776: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80777: LD_INT 0
80779: PPUSH
// if not mc_bases or not base or not weapon_list then
80780: LD_EXP 60
80784: NOT
80785: PUSH
80786: LD_VAR 0 1
80790: NOT
80791: OR
80792: PUSH
80793: LD_VAR 0 2
80797: NOT
80798: OR
80799: IFFALSE 80803
// exit ;
80801: GO 80828
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80803: LD_ADDR_EXP 99
80807: PUSH
80808: LD_EXP 99
80812: PPUSH
80813: LD_VAR 0 1
80817: PPUSH
80818: LD_VAR 0 2
80822: PPUSH
80823: CALL_OW 1
80827: ST_TO_ADDR
// end ;
80828: LD_VAR 0 3
80832: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80833: LD_INT 0
80835: PPUSH
// if not mc_bases or not base or not tech_list then
80836: LD_EXP 60
80840: NOT
80841: PUSH
80842: LD_VAR 0 1
80846: NOT
80847: OR
80848: PUSH
80849: LD_VAR 0 2
80853: NOT
80854: OR
80855: IFFALSE 80859
// exit ;
80857: GO 80884
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80859: LD_ADDR_EXP 87
80863: PUSH
80864: LD_EXP 87
80868: PPUSH
80869: LD_VAR 0 1
80873: PPUSH
80874: LD_VAR 0 2
80878: PPUSH
80879: CALL_OW 1
80883: ST_TO_ADDR
// end ;
80884: LD_VAR 0 3
80888: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80889: LD_INT 0
80891: PPUSH
// if not mc_bases or not parking_area or not base then
80892: LD_EXP 60
80896: NOT
80897: PUSH
80898: LD_VAR 0 2
80902: NOT
80903: OR
80904: PUSH
80905: LD_VAR 0 1
80909: NOT
80910: OR
80911: IFFALSE 80915
// exit ;
80913: GO 80940
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80915: LD_ADDR_EXP 84
80919: PUSH
80920: LD_EXP 84
80924: PPUSH
80925: LD_VAR 0 1
80929: PPUSH
80930: LD_VAR 0 2
80934: PPUSH
80935: CALL_OW 1
80939: ST_TO_ADDR
// end ;
80940: LD_VAR 0 3
80944: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80945: LD_INT 0
80947: PPUSH
// if not mc_bases or not base or not scan_area then
80948: LD_EXP 60
80952: NOT
80953: PUSH
80954: LD_VAR 0 1
80958: NOT
80959: OR
80960: PUSH
80961: LD_VAR 0 2
80965: NOT
80966: OR
80967: IFFALSE 80971
// exit ;
80969: GO 80996
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
80971: LD_ADDR_EXP 85
80975: PUSH
80976: LD_EXP 85
80980: PPUSH
80981: LD_VAR 0 1
80985: PPUSH
80986: LD_VAR 0 2
80990: PPUSH
80991: CALL_OW 1
80995: ST_TO_ADDR
// end ;
80996: LD_VAR 0 3
81000: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81001: LD_INT 0
81003: PPUSH
81004: PPUSH
// if not mc_bases or not base then
81005: LD_EXP 60
81009: NOT
81010: PUSH
81011: LD_VAR 0 1
81015: NOT
81016: OR
81017: IFFALSE 81021
// exit ;
81019: GO 81085
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
81021: LD_ADDR_VAR 0 3
81025: PUSH
81026: LD_INT 1
81028: PUSH
81029: LD_INT 2
81031: PUSH
81032: LD_INT 3
81034: PUSH
81035: LD_INT 4
81037: PUSH
81038: LD_INT 11
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: LIST
81045: LIST
81046: LIST
81047: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
81048: LD_ADDR_EXP 87
81052: PUSH
81053: LD_EXP 87
81057: PPUSH
81058: LD_VAR 0 1
81062: PPUSH
81063: LD_EXP 87
81067: PUSH
81068: LD_VAR 0 1
81072: ARRAY
81073: PUSH
81074: LD_VAR 0 3
81078: DIFF
81079: PPUSH
81080: CALL_OW 1
81084: ST_TO_ADDR
// end ;
81085: LD_VAR 0 2
81089: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
81090: LD_INT 0
81092: PPUSH
// result := mc_vehicles [ base ] ;
81093: LD_ADDR_VAR 0 3
81097: PUSH
81098: LD_EXP 79
81102: PUSH
81103: LD_VAR 0 1
81107: ARRAY
81108: ST_TO_ADDR
// if onlyCombat then
81109: LD_VAR 0 2
81113: IFFALSE 81291
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
81115: LD_ADDR_VAR 0 3
81119: PUSH
81120: LD_VAR 0 3
81124: PUSH
81125: LD_VAR 0 3
81129: PPUSH
81130: LD_INT 2
81132: PUSH
81133: LD_INT 34
81135: PUSH
81136: LD_INT 12
81138: PUSH
81139: EMPTY
81140: LIST
81141: LIST
81142: PUSH
81143: LD_INT 34
81145: PUSH
81146: LD_INT 51
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 34
81155: PUSH
81156: LD_EXP 105
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: PUSH
81165: LD_INT 34
81167: PUSH
81168: LD_INT 32
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 34
81177: PUSH
81178: LD_INT 13
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 34
81187: PUSH
81188: LD_INT 52
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 34
81197: PUSH
81198: LD_EXP 110
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 34
81209: PUSH
81210: LD_INT 14
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: PUSH
81217: LD_INT 34
81219: PUSH
81220: LD_INT 53
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 34
81229: PUSH
81230: LD_EXP 104
81234: PUSH
81235: EMPTY
81236: LIST
81237: LIST
81238: PUSH
81239: LD_INT 34
81241: PUSH
81242: LD_INT 31
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 34
81251: PUSH
81252: LD_INT 48
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: PUSH
81259: LD_INT 34
81261: PUSH
81262: LD_INT 8
81264: PUSH
81265: EMPTY
81266: LIST
81267: LIST
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: LIST
81280: LIST
81281: LIST
81282: LIST
81283: LIST
81284: PPUSH
81285: CALL_OW 72
81289: DIFF
81290: ST_TO_ADDR
// end ; end_of_file
81291: LD_VAR 0 3
81295: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
81296: LD_INT 0
81298: PPUSH
81299: PPUSH
81300: PPUSH
// if not mc_bases or not skirmish then
81301: LD_EXP 60
81305: NOT
81306: PUSH
81307: LD_EXP 58
81311: NOT
81312: OR
81313: IFFALSE 81317
// exit ;
81315: GO 81482
// for i = 1 to mc_bases do
81317: LD_ADDR_VAR 0 4
81321: PUSH
81322: DOUBLE
81323: LD_INT 1
81325: DEC
81326: ST_TO_ADDR
81327: LD_EXP 60
81331: PUSH
81332: FOR_TO
81333: IFFALSE 81480
// begin if sci in mc_bases [ i ] then
81335: LD_VAR 0 2
81339: PUSH
81340: LD_EXP 60
81344: PUSH
81345: LD_VAR 0 4
81349: ARRAY
81350: IN
81351: IFFALSE 81478
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
81353: LD_ADDR_EXP 89
81357: PUSH
81358: LD_EXP 89
81362: PPUSH
81363: LD_VAR 0 4
81367: PUSH
81368: LD_EXP 89
81372: PUSH
81373: LD_VAR 0 4
81377: ARRAY
81378: PUSH
81379: LD_INT 1
81381: PLUS
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: PPUSH
81387: LD_VAR 0 1
81391: PPUSH
81392: CALL 20003 0 3
81396: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
81397: LD_ADDR_VAR 0 5
81401: PUSH
81402: LD_EXP 60
81406: PUSH
81407: LD_VAR 0 4
81411: ARRAY
81412: PPUSH
81413: LD_INT 2
81415: PUSH
81416: LD_INT 30
81418: PUSH
81419: LD_INT 0
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 30
81428: PUSH
81429: LD_INT 1
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: LIST
81440: PPUSH
81441: CALL_OW 72
81445: PPUSH
81446: LD_VAR 0 1
81450: PPUSH
81451: CALL_OW 74
81455: ST_TO_ADDR
// if tmp then
81456: LD_VAR 0 5
81460: IFFALSE 81476
// ComStandNearbyBuilding ( ape , tmp ) ;
81462: LD_VAR 0 1
81466: PPUSH
81467: LD_VAR 0 5
81471: PPUSH
81472: CALL 16428 0 2
// break ;
81476: GO 81480
// end ; end ;
81478: GO 81332
81480: POP
81481: POP
// end ;
81482: LD_VAR 0 3
81486: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
81487: LD_INT 0
81489: PPUSH
81490: PPUSH
81491: PPUSH
// if not mc_bases or not skirmish then
81492: LD_EXP 60
81496: NOT
81497: PUSH
81498: LD_EXP 58
81502: NOT
81503: OR
81504: IFFALSE 81508
// exit ;
81506: GO 81597
// for i = 1 to mc_bases do
81508: LD_ADDR_VAR 0 4
81512: PUSH
81513: DOUBLE
81514: LD_INT 1
81516: DEC
81517: ST_TO_ADDR
81518: LD_EXP 60
81522: PUSH
81523: FOR_TO
81524: IFFALSE 81595
// begin if building in mc_busy_turret_list [ i ] then
81526: LD_VAR 0 1
81530: PUSH
81531: LD_EXP 70
81535: PUSH
81536: LD_VAR 0 4
81540: ARRAY
81541: IN
81542: IFFALSE 81593
// begin tmp := mc_busy_turret_list [ i ] diff building ;
81544: LD_ADDR_VAR 0 5
81548: PUSH
81549: LD_EXP 70
81553: PUSH
81554: LD_VAR 0 4
81558: ARRAY
81559: PUSH
81560: LD_VAR 0 1
81564: DIFF
81565: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
81566: LD_ADDR_EXP 70
81570: PUSH
81571: LD_EXP 70
81575: PPUSH
81576: LD_VAR 0 4
81580: PPUSH
81581: LD_VAR 0 5
81585: PPUSH
81586: CALL_OW 1
81590: ST_TO_ADDR
// break ;
81591: GO 81595
// end ; end ;
81593: GO 81523
81595: POP
81596: POP
// end ;
81597: LD_VAR 0 3
81601: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81602: LD_INT 0
81604: PPUSH
81605: PPUSH
81606: PPUSH
// if not mc_bases or not skirmish then
81607: LD_EXP 60
81611: NOT
81612: PUSH
81613: LD_EXP 58
81617: NOT
81618: OR
81619: IFFALSE 81623
// exit ;
81621: GO 81822
// for i = 1 to mc_bases do
81623: LD_ADDR_VAR 0 5
81627: PUSH
81628: DOUBLE
81629: LD_INT 1
81631: DEC
81632: ST_TO_ADDR
81633: LD_EXP 60
81637: PUSH
81638: FOR_TO
81639: IFFALSE 81820
// if building in mc_bases [ i ] then
81641: LD_VAR 0 1
81645: PUSH
81646: LD_EXP 60
81650: PUSH
81651: LD_VAR 0 5
81655: ARRAY
81656: IN
81657: IFFALSE 81818
// begin tmp := mc_bases [ i ] diff building ;
81659: LD_ADDR_VAR 0 6
81663: PUSH
81664: LD_EXP 60
81668: PUSH
81669: LD_VAR 0 5
81673: ARRAY
81674: PUSH
81675: LD_VAR 0 1
81679: DIFF
81680: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81681: LD_ADDR_EXP 60
81685: PUSH
81686: LD_EXP 60
81690: PPUSH
81691: LD_VAR 0 5
81695: PPUSH
81696: LD_VAR 0 6
81700: PPUSH
81701: CALL_OW 1
81705: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81706: LD_VAR 0 1
81710: PUSH
81711: LD_EXP 68
81715: PUSH
81716: LD_VAR 0 5
81720: ARRAY
81721: IN
81722: IFFALSE 81761
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81724: LD_ADDR_EXP 68
81728: PUSH
81729: LD_EXP 68
81733: PPUSH
81734: LD_VAR 0 5
81738: PPUSH
81739: LD_EXP 68
81743: PUSH
81744: LD_VAR 0 5
81748: ARRAY
81749: PUSH
81750: LD_VAR 0 1
81754: DIFF
81755: PPUSH
81756: CALL_OW 1
81760: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81761: LD_VAR 0 1
81765: PUSH
81766: LD_EXP 69
81770: PUSH
81771: LD_VAR 0 5
81775: ARRAY
81776: IN
81777: IFFALSE 81816
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81779: LD_ADDR_EXP 69
81783: PUSH
81784: LD_EXP 69
81788: PPUSH
81789: LD_VAR 0 5
81793: PPUSH
81794: LD_EXP 69
81798: PUSH
81799: LD_VAR 0 5
81803: ARRAY
81804: PUSH
81805: LD_VAR 0 1
81809: DIFF
81810: PPUSH
81811: CALL_OW 1
81815: ST_TO_ADDR
// break ;
81816: GO 81820
// end ;
81818: GO 81638
81820: POP
81821: POP
// end ;
81822: LD_VAR 0 4
81826: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81827: LD_INT 0
81829: PPUSH
81830: PPUSH
81831: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81832: LD_EXP 60
81836: NOT
81837: PUSH
81838: LD_EXP 58
81842: NOT
81843: OR
81844: PUSH
81845: LD_VAR 0 3
81849: PUSH
81850: LD_EXP 86
81854: IN
81855: NOT
81856: OR
81857: IFFALSE 81861
// exit ;
81859: GO 81984
// for i = 1 to mc_vehicles do
81861: LD_ADDR_VAR 0 6
81865: PUSH
81866: DOUBLE
81867: LD_INT 1
81869: DEC
81870: ST_TO_ADDR
81871: LD_EXP 79
81875: PUSH
81876: FOR_TO
81877: IFFALSE 81982
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81879: LD_VAR 0 2
81883: PUSH
81884: LD_EXP 79
81888: PUSH
81889: LD_VAR 0 6
81893: ARRAY
81894: IN
81895: PUSH
81896: LD_VAR 0 1
81900: PUSH
81901: LD_EXP 79
81905: PUSH
81906: LD_VAR 0 6
81910: ARRAY
81911: IN
81912: OR
81913: IFFALSE 81980
// begin tmp := mc_vehicles [ i ] diff old ;
81915: LD_ADDR_VAR 0 7
81919: PUSH
81920: LD_EXP 79
81924: PUSH
81925: LD_VAR 0 6
81929: ARRAY
81930: PUSH
81931: LD_VAR 0 2
81935: DIFF
81936: ST_TO_ADDR
// tmp := tmp diff new ;
81937: LD_ADDR_VAR 0 7
81941: PUSH
81942: LD_VAR 0 7
81946: PUSH
81947: LD_VAR 0 1
81951: DIFF
81952: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81953: LD_ADDR_EXP 79
81957: PUSH
81958: LD_EXP 79
81962: PPUSH
81963: LD_VAR 0 6
81967: PPUSH
81968: LD_VAR 0 7
81972: PPUSH
81973: CALL_OW 1
81977: ST_TO_ADDR
// break ;
81978: GO 81982
// end ;
81980: GO 81876
81982: POP
81983: POP
// end ;
81984: LD_VAR 0 5
81988: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
81989: LD_INT 0
81991: PPUSH
81992: PPUSH
81993: PPUSH
81994: PPUSH
// if not mc_bases or not skirmish then
81995: LD_EXP 60
81999: NOT
82000: PUSH
82001: LD_EXP 58
82005: NOT
82006: OR
82007: IFFALSE 82011
// exit ;
82009: GO 82403
// side := GetSide ( vehicle ) ;
82011: LD_ADDR_VAR 0 5
82015: PUSH
82016: LD_VAR 0 1
82020: PPUSH
82021: CALL_OW 255
82025: ST_TO_ADDR
// for i = 1 to mc_bases do
82026: LD_ADDR_VAR 0 4
82030: PUSH
82031: DOUBLE
82032: LD_INT 1
82034: DEC
82035: ST_TO_ADDR
82036: LD_EXP 60
82040: PUSH
82041: FOR_TO
82042: IFFALSE 82401
// begin if factory in mc_bases [ i ] then
82044: LD_VAR 0 2
82048: PUSH
82049: LD_EXP 60
82053: PUSH
82054: LD_VAR 0 4
82058: ARRAY
82059: IN
82060: IFFALSE 82399
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
82062: LD_EXP 82
82066: PUSH
82067: LD_VAR 0 4
82071: ARRAY
82072: PUSH
82073: LD_EXP 71
82077: PUSH
82078: LD_VAR 0 4
82082: ARRAY
82083: LESS
82084: PUSH
82085: LD_VAR 0 1
82089: PPUSH
82090: CALL_OW 264
82094: PUSH
82095: LD_INT 31
82097: PUSH
82098: LD_INT 32
82100: PUSH
82101: LD_INT 51
82103: PUSH
82104: LD_EXP 105
82108: PUSH
82109: LD_INT 12
82111: PUSH
82112: LD_INT 30
82114: PUSH
82115: LD_EXP 104
82119: PUSH
82120: LD_INT 11
82122: PUSH
82123: LD_INT 53
82125: PUSH
82126: LD_INT 14
82128: PUSH
82129: LD_EXP 108
82133: PUSH
82134: LD_INT 29
82136: PUSH
82137: LD_EXP 106
82141: PUSH
82142: LD_INT 13
82144: PUSH
82145: LD_INT 52
82147: PUSH
82148: LD_EXP 110
82152: PUSH
82153: LD_INT 48
82155: PUSH
82156: LD_INT 8
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: LIST
82163: LIST
82164: LIST
82165: LIST
82166: LIST
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: IN
82179: NOT
82180: AND
82181: IFFALSE 82229
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
82183: LD_ADDR_EXP 82
82187: PUSH
82188: LD_EXP 82
82192: PPUSH
82193: LD_VAR 0 4
82197: PUSH
82198: LD_EXP 82
82202: PUSH
82203: LD_VAR 0 4
82207: ARRAY
82208: PUSH
82209: LD_INT 1
82211: PLUS
82212: PUSH
82213: EMPTY
82214: LIST
82215: LIST
82216: PPUSH
82217: LD_VAR 0 1
82221: PPUSH
82222: CALL 20003 0 3
82226: ST_TO_ADDR
82227: GO 82273
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
82229: LD_ADDR_EXP 79
82233: PUSH
82234: LD_EXP 79
82238: PPUSH
82239: LD_VAR 0 4
82243: PUSH
82244: LD_EXP 79
82248: PUSH
82249: LD_VAR 0 4
82253: ARRAY
82254: PUSH
82255: LD_INT 1
82257: PLUS
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PPUSH
82263: LD_VAR 0 1
82267: PPUSH
82268: CALL 20003 0 3
82272: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
82273: LD_VAR 0 1
82277: PPUSH
82278: CALL_OW 263
82282: PUSH
82283: LD_INT 2
82285: EQUAL
82286: IFFALSE 82315
// begin repeat wait ( 0 0$3 ) ;
82288: LD_INT 105
82290: PPUSH
82291: CALL_OW 67
// Connect ( vehicle ) ;
82295: LD_VAR 0 1
82299: PPUSH
82300: CALL 22974 0 1
// until IsControledBy ( vehicle ) ;
82304: LD_VAR 0 1
82308: PPUSH
82309: CALL_OW 312
82313: IFFALSE 82288
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
82315: LD_VAR 0 1
82319: PPUSH
82320: LD_EXP 84
82324: PUSH
82325: LD_VAR 0 4
82329: ARRAY
82330: PPUSH
82331: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
82335: LD_VAR 0 1
82339: PPUSH
82340: CALL_OW 263
82344: PUSH
82345: LD_INT 1
82347: NONEQUAL
82348: IFFALSE 82352
// break ;
82350: GO 82401
// repeat wait ( 0 0$1 ) ;
82352: LD_INT 35
82354: PPUSH
82355: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
82359: LD_VAR 0 1
82363: PPUSH
82364: LD_EXP 84
82368: PUSH
82369: LD_VAR 0 4
82373: ARRAY
82374: PPUSH
82375: CALL_OW 308
82379: IFFALSE 82352
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
82381: LD_VAR 0 1
82385: PPUSH
82386: CALL_OW 311
82390: PPUSH
82391: CALL_OW 121
// exit ;
82395: POP
82396: POP
82397: GO 82403
// end ; end ;
82399: GO 82041
82401: POP
82402: POP
// end ;
82403: LD_VAR 0 3
82407: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
82408: LD_INT 0
82410: PPUSH
82411: PPUSH
82412: PPUSH
82413: PPUSH
// if not mc_bases or not skirmish then
82414: LD_EXP 60
82418: NOT
82419: PUSH
82420: LD_EXP 58
82424: NOT
82425: OR
82426: IFFALSE 82430
// exit ;
82428: GO 82783
// repeat wait ( 0 0$1 ) ;
82430: LD_INT 35
82432: PPUSH
82433: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
82437: LD_VAR 0 2
82441: PPUSH
82442: LD_VAR 0 3
82446: PPUSH
82447: CALL_OW 284
82451: IFFALSE 82430
// if GetResourceTypeXY ( x , y ) = mat_artefact then
82453: LD_VAR 0 2
82457: PPUSH
82458: LD_VAR 0 3
82462: PPUSH
82463: CALL_OW 283
82467: PUSH
82468: LD_INT 4
82470: EQUAL
82471: IFFALSE 82475
// exit ;
82473: GO 82783
// for i = 1 to mc_bases do
82475: LD_ADDR_VAR 0 7
82479: PUSH
82480: DOUBLE
82481: LD_INT 1
82483: DEC
82484: ST_TO_ADDR
82485: LD_EXP 60
82489: PUSH
82490: FOR_TO
82491: IFFALSE 82781
// begin if mc_crates_area [ i ] then
82493: LD_EXP 78
82497: PUSH
82498: LD_VAR 0 7
82502: ARRAY
82503: IFFALSE 82614
// for j in mc_crates_area [ i ] do
82505: LD_ADDR_VAR 0 8
82509: PUSH
82510: LD_EXP 78
82514: PUSH
82515: LD_VAR 0 7
82519: ARRAY
82520: PUSH
82521: FOR_IN
82522: IFFALSE 82612
// if InArea ( x , y , j ) then
82524: LD_VAR 0 2
82528: PPUSH
82529: LD_VAR 0 3
82533: PPUSH
82534: LD_VAR 0 8
82538: PPUSH
82539: CALL_OW 309
82543: IFFALSE 82610
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82545: LD_ADDR_EXP 76
82549: PUSH
82550: LD_EXP 76
82554: PPUSH
82555: LD_VAR 0 7
82559: PUSH
82560: LD_EXP 76
82564: PUSH
82565: LD_VAR 0 7
82569: ARRAY
82570: PUSH
82571: LD_INT 1
82573: PLUS
82574: PUSH
82575: EMPTY
82576: LIST
82577: LIST
82578: PPUSH
82579: LD_VAR 0 4
82583: PUSH
82584: LD_VAR 0 2
82588: PUSH
82589: LD_VAR 0 3
82593: PUSH
82594: EMPTY
82595: LIST
82596: LIST
82597: LIST
82598: PPUSH
82599: CALL 20003 0 3
82603: ST_TO_ADDR
// exit ;
82604: POP
82605: POP
82606: POP
82607: POP
82608: GO 82783
// end ;
82610: GO 82521
82612: POP
82613: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82614: LD_ADDR_VAR 0 9
82618: PUSH
82619: LD_EXP 60
82623: PUSH
82624: LD_VAR 0 7
82628: ARRAY
82629: PPUSH
82630: LD_INT 2
82632: PUSH
82633: LD_INT 30
82635: PUSH
82636: LD_INT 0
82638: PUSH
82639: EMPTY
82640: LIST
82641: LIST
82642: PUSH
82643: LD_INT 30
82645: PUSH
82646: LD_INT 1
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: LIST
82657: PPUSH
82658: CALL_OW 72
82662: ST_TO_ADDR
// if not depot then
82663: LD_VAR 0 9
82667: NOT
82668: IFFALSE 82672
// continue ;
82670: GO 82490
// for j in depot do
82672: LD_ADDR_VAR 0 8
82676: PUSH
82677: LD_VAR 0 9
82681: PUSH
82682: FOR_IN
82683: IFFALSE 82777
// if GetDistUnitXY ( j , x , y ) < 30 then
82685: LD_VAR 0 8
82689: PPUSH
82690: LD_VAR 0 2
82694: PPUSH
82695: LD_VAR 0 3
82699: PPUSH
82700: CALL_OW 297
82704: PUSH
82705: LD_INT 30
82707: LESS
82708: IFFALSE 82775
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82710: LD_ADDR_EXP 76
82714: PUSH
82715: LD_EXP 76
82719: PPUSH
82720: LD_VAR 0 7
82724: PUSH
82725: LD_EXP 76
82729: PUSH
82730: LD_VAR 0 7
82734: ARRAY
82735: PUSH
82736: LD_INT 1
82738: PLUS
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: PPUSH
82744: LD_VAR 0 4
82748: PUSH
82749: LD_VAR 0 2
82753: PUSH
82754: LD_VAR 0 3
82758: PUSH
82759: EMPTY
82760: LIST
82761: LIST
82762: LIST
82763: PPUSH
82764: CALL 20003 0 3
82768: ST_TO_ADDR
// exit ;
82769: POP
82770: POP
82771: POP
82772: POP
82773: GO 82783
// end ;
82775: GO 82682
82777: POP
82778: POP
// end ;
82779: GO 82490
82781: POP
82782: POP
// end ;
82783: LD_VAR 0 6
82787: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82788: LD_INT 0
82790: PPUSH
82791: PPUSH
82792: PPUSH
82793: PPUSH
// if not mc_bases or not skirmish then
82794: LD_EXP 60
82798: NOT
82799: PUSH
82800: LD_EXP 58
82804: NOT
82805: OR
82806: IFFALSE 82810
// exit ;
82808: GO 83087
// side := GetSide ( lab ) ;
82810: LD_ADDR_VAR 0 4
82814: PUSH
82815: LD_VAR 0 2
82819: PPUSH
82820: CALL_OW 255
82824: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82825: LD_VAR 0 4
82829: PUSH
82830: LD_EXP 86
82834: IN
82835: NOT
82836: PUSH
82837: LD_EXP 87
82841: NOT
82842: OR
82843: PUSH
82844: LD_EXP 60
82848: NOT
82849: OR
82850: IFFALSE 82854
// exit ;
82852: GO 83087
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82854: LD_ADDR_EXP 87
82858: PUSH
82859: LD_EXP 87
82863: PPUSH
82864: LD_VAR 0 4
82868: PPUSH
82869: LD_EXP 87
82873: PUSH
82874: LD_VAR 0 4
82878: ARRAY
82879: PUSH
82880: LD_VAR 0 1
82884: DIFF
82885: PPUSH
82886: CALL_OW 1
82890: ST_TO_ADDR
// for i = 1 to mc_bases do
82891: LD_ADDR_VAR 0 5
82895: PUSH
82896: DOUBLE
82897: LD_INT 1
82899: DEC
82900: ST_TO_ADDR
82901: LD_EXP 60
82905: PUSH
82906: FOR_TO
82907: IFFALSE 83085
// begin if lab in mc_bases [ i ] then
82909: LD_VAR 0 2
82913: PUSH
82914: LD_EXP 60
82918: PUSH
82919: LD_VAR 0 5
82923: ARRAY
82924: IN
82925: IFFALSE 83083
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82927: LD_VAR 0 1
82931: PUSH
82932: LD_INT 11
82934: PUSH
82935: LD_INT 4
82937: PUSH
82938: LD_INT 3
82940: PUSH
82941: LD_INT 2
82943: PUSH
82944: EMPTY
82945: LIST
82946: LIST
82947: LIST
82948: LIST
82949: IN
82950: PUSH
82951: LD_EXP 90
82955: PUSH
82956: LD_VAR 0 5
82960: ARRAY
82961: AND
82962: IFFALSE 83083
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82964: LD_ADDR_VAR 0 6
82968: PUSH
82969: LD_EXP 90
82973: PUSH
82974: LD_VAR 0 5
82978: ARRAY
82979: PUSH
82980: LD_INT 1
82982: ARRAY
82983: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82984: LD_ADDR_EXP 90
82988: PUSH
82989: LD_EXP 90
82993: PPUSH
82994: LD_VAR 0 5
82998: PPUSH
82999: EMPTY
83000: PPUSH
83001: CALL_OW 1
83005: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
83006: LD_VAR 0 6
83010: PPUSH
83011: LD_INT 0
83013: PPUSH
83014: CALL_OW 109
// ComExitBuilding ( tmp ) ;
83018: LD_VAR 0 6
83022: PPUSH
83023: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
83027: LD_ADDR_EXP 89
83031: PUSH
83032: LD_EXP 89
83036: PPUSH
83037: LD_VAR 0 5
83041: PPUSH
83042: LD_EXP 89
83046: PUSH
83047: LD_VAR 0 5
83051: ARRAY
83052: PPUSH
83053: LD_INT 1
83055: PPUSH
83056: LD_VAR 0 6
83060: PPUSH
83061: CALL_OW 2
83065: PPUSH
83066: CALL_OW 1
83070: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
83071: LD_VAR 0 5
83075: PPUSH
83076: LD_INT 112
83078: PPUSH
83079: CALL 59606 0 2
// end ; end ; end ;
83083: GO 82906
83085: POP
83086: POP
// end ;
83087: LD_VAR 0 3
83091: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
83092: LD_INT 0
83094: PPUSH
83095: PPUSH
83096: PPUSH
83097: PPUSH
83098: PPUSH
83099: PPUSH
83100: PPUSH
83101: PPUSH
// if not mc_bases or not skirmish then
83102: LD_EXP 60
83106: NOT
83107: PUSH
83108: LD_EXP 58
83112: NOT
83113: OR
83114: IFFALSE 83118
// exit ;
83116: GO 84489
// for i = 1 to mc_bases do
83118: LD_ADDR_VAR 0 3
83122: PUSH
83123: DOUBLE
83124: LD_INT 1
83126: DEC
83127: ST_TO_ADDR
83128: LD_EXP 60
83132: PUSH
83133: FOR_TO
83134: IFFALSE 84487
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
83136: LD_VAR 0 1
83140: PUSH
83141: LD_EXP 60
83145: PUSH
83146: LD_VAR 0 3
83150: ARRAY
83151: IN
83152: PUSH
83153: LD_VAR 0 1
83157: PUSH
83158: LD_EXP 67
83162: PUSH
83163: LD_VAR 0 3
83167: ARRAY
83168: IN
83169: OR
83170: PUSH
83171: LD_VAR 0 1
83175: PUSH
83176: LD_EXP 82
83180: PUSH
83181: LD_VAR 0 3
83185: ARRAY
83186: IN
83187: OR
83188: PUSH
83189: LD_VAR 0 1
83193: PUSH
83194: LD_EXP 79
83198: PUSH
83199: LD_VAR 0 3
83203: ARRAY
83204: IN
83205: OR
83206: PUSH
83207: LD_VAR 0 1
83211: PUSH
83212: LD_EXP 89
83216: PUSH
83217: LD_VAR 0 3
83221: ARRAY
83222: IN
83223: OR
83224: PUSH
83225: LD_VAR 0 1
83229: PUSH
83230: LD_EXP 90
83234: PUSH
83235: LD_VAR 0 3
83239: ARRAY
83240: IN
83241: OR
83242: IFFALSE 84485
// begin if un in mc_ape [ i ] then
83244: LD_VAR 0 1
83248: PUSH
83249: LD_EXP 89
83253: PUSH
83254: LD_VAR 0 3
83258: ARRAY
83259: IN
83260: IFFALSE 83299
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
83262: LD_ADDR_EXP 89
83266: PUSH
83267: LD_EXP 89
83271: PPUSH
83272: LD_VAR 0 3
83276: PPUSH
83277: LD_EXP 89
83281: PUSH
83282: LD_VAR 0 3
83286: ARRAY
83287: PUSH
83288: LD_VAR 0 1
83292: DIFF
83293: PPUSH
83294: CALL_OW 1
83298: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
83299: LD_VAR 0 1
83303: PUSH
83304: LD_EXP 90
83308: PUSH
83309: LD_VAR 0 3
83313: ARRAY
83314: IN
83315: IFFALSE 83339
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83317: LD_ADDR_EXP 90
83321: PUSH
83322: LD_EXP 90
83326: PPUSH
83327: LD_VAR 0 3
83331: PPUSH
83332: EMPTY
83333: PPUSH
83334: CALL_OW 1
83338: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
83339: LD_VAR 0 1
83343: PPUSH
83344: CALL_OW 247
83348: PUSH
83349: LD_INT 2
83351: EQUAL
83352: PUSH
83353: LD_VAR 0 1
83357: PPUSH
83358: CALL_OW 110
83362: PUSH
83363: LD_INT 20
83365: EQUAL
83366: PUSH
83367: LD_VAR 0 1
83371: PUSH
83372: LD_EXP 82
83376: PUSH
83377: LD_VAR 0 3
83381: ARRAY
83382: IN
83383: OR
83384: PUSH
83385: LD_VAR 0 1
83389: PPUSH
83390: CALL_OW 264
83394: PUSH
83395: LD_INT 12
83397: PUSH
83398: LD_INT 51
83400: PUSH
83401: LD_EXP 105
83405: PUSH
83406: LD_INT 32
83408: PUSH
83409: LD_INT 13
83411: PUSH
83412: LD_INT 52
83414: PUSH
83415: LD_INT 31
83417: PUSH
83418: EMPTY
83419: LIST
83420: LIST
83421: LIST
83422: LIST
83423: LIST
83424: LIST
83425: LIST
83426: IN
83427: OR
83428: AND
83429: IFFALSE 83737
// begin if un in mc_defender [ i ] then
83431: LD_VAR 0 1
83435: PUSH
83436: LD_EXP 82
83440: PUSH
83441: LD_VAR 0 3
83445: ARRAY
83446: IN
83447: IFFALSE 83486
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83449: LD_ADDR_EXP 82
83453: PUSH
83454: LD_EXP 82
83458: PPUSH
83459: LD_VAR 0 3
83463: PPUSH
83464: LD_EXP 82
83468: PUSH
83469: LD_VAR 0 3
83473: ARRAY
83474: PUSH
83475: LD_VAR 0 1
83479: DIFF
83480: PPUSH
83481: CALL_OW 1
83485: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
83486: LD_ADDR_VAR 0 8
83490: PUSH
83491: LD_VAR 0 3
83495: PPUSH
83496: LD_INT 3
83498: PPUSH
83499: CALL 80127 0 2
83503: ST_TO_ADDR
// if fac then
83504: LD_VAR 0 8
83508: IFFALSE 83737
// begin for j in fac do
83510: LD_ADDR_VAR 0 4
83514: PUSH
83515: LD_VAR 0 8
83519: PUSH
83520: FOR_IN
83521: IFFALSE 83735
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
83523: LD_ADDR_VAR 0 9
83527: PUSH
83528: LD_VAR 0 8
83532: PPUSH
83533: LD_VAR 0 1
83537: PPUSH
83538: CALL_OW 265
83542: PPUSH
83543: LD_VAR 0 1
83547: PPUSH
83548: CALL_OW 262
83552: PPUSH
83553: LD_VAR 0 1
83557: PPUSH
83558: CALL_OW 263
83562: PPUSH
83563: LD_VAR 0 1
83567: PPUSH
83568: CALL_OW 264
83572: PPUSH
83573: CALL 17499 0 5
83577: ST_TO_ADDR
// if components then
83578: LD_VAR 0 9
83582: IFFALSE 83733
// begin if GetWeapon ( un ) = ar_control_tower then
83584: LD_VAR 0 1
83588: PPUSH
83589: CALL_OW 264
83593: PUSH
83594: LD_INT 31
83596: EQUAL
83597: IFFALSE 83714
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
83599: LD_VAR 0 1
83603: PPUSH
83604: CALL_OW 311
83608: PPUSH
83609: LD_INT 0
83611: PPUSH
83612: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
83616: LD_ADDR_EXP 100
83620: PUSH
83621: LD_EXP 100
83625: PPUSH
83626: LD_VAR 0 3
83630: PPUSH
83631: LD_EXP 100
83635: PUSH
83636: LD_VAR 0 3
83640: ARRAY
83641: PUSH
83642: LD_VAR 0 1
83646: PPUSH
83647: CALL_OW 311
83651: DIFF
83652: PPUSH
83653: CALL_OW 1
83657: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
83658: LD_ADDR_VAR 0 7
83662: PUSH
83663: LD_EXP 81
83667: PUSH
83668: LD_VAR 0 3
83672: ARRAY
83673: PPUSH
83674: LD_INT 1
83676: PPUSH
83677: LD_VAR 0 9
83681: PPUSH
83682: CALL_OW 2
83686: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
83687: LD_ADDR_EXP 81
83691: PUSH
83692: LD_EXP 81
83696: PPUSH
83697: LD_VAR 0 3
83701: PPUSH
83702: LD_VAR 0 7
83706: PPUSH
83707: CALL_OW 1
83711: ST_TO_ADDR
// end else
83712: GO 83731
// MC_InsertProduceList ( i , [ components ] ) ;
83714: LD_VAR 0 3
83718: PPUSH
83719: LD_VAR 0 9
83723: PUSH
83724: EMPTY
83725: LIST
83726: PPUSH
83727: CALL 79672 0 2
// break ;
83731: GO 83735
// end ; end ;
83733: GO 83520
83735: POP
83736: POP
// end ; end ; if GetType ( un ) = unit_building then
83737: LD_VAR 0 1
83741: PPUSH
83742: CALL_OW 247
83746: PUSH
83747: LD_INT 3
83749: EQUAL
83750: IFFALSE 84153
// begin btype := GetBType ( un ) ;
83752: LD_ADDR_VAR 0 5
83756: PUSH
83757: LD_VAR 0 1
83761: PPUSH
83762: CALL_OW 266
83766: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
83767: LD_VAR 0 5
83771: PUSH
83772: LD_INT 29
83774: PUSH
83775: LD_INT 30
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: IN
83782: IFFALSE 83855
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
83784: LD_VAR 0 1
83788: PPUSH
83789: CALL_OW 250
83793: PPUSH
83794: LD_VAR 0 1
83798: PPUSH
83799: CALL_OW 251
83803: PPUSH
83804: LD_VAR 0 1
83808: PPUSH
83809: CALL_OW 255
83813: PPUSH
83814: CALL_OW 440
83818: NOT
83819: IFFALSE 83855
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
83821: LD_VAR 0 1
83825: PPUSH
83826: CALL_OW 250
83830: PPUSH
83831: LD_VAR 0 1
83835: PPUSH
83836: CALL_OW 251
83840: PPUSH
83841: LD_VAR 0 1
83845: PPUSH
83846: CALL_OW 255
83850: PPUSH
83851: CALL_OW 441
// end ; if btype = b_warehouse then
83855: LD_VAR 0 5
83859: PUSH
83860: LD_INT 1
83862: EQUAL
83863: IFFALSE 83881
// begin btype := b_depot ;
83865: LD_ADDR_VAR 0 5
83869: PUSH
83870: LD_INT 0
83872: ST_TO_ADDR
// pos := 1 ;
83873: LD_ADDR_VAR 0 6
83877: PUSH
83878: LD_INT 1
83880: ST_TO_ADDR
// end ; if btype = b_factory then
83881: LD_VAR 0 5
83885: PUSH
83886: LD_INT 3
83888: EQUAL
83889: IFFALSE 83907
// begin btype := b_workshop ;
83891: LD_ADDR_VAR 0 5
83895: PUSH
83896: LD_INT 2
83898: ST_TO_ADDR
// pos := 1 ;
83899: LD_ADDR_VAR 0 6
83903: PUSH
83904: LD_INT 1
83906: ST_TO_ADDR
// end ; if btype = b_barracks then
83907: LD_VAR 0 5
83911: PUSH
83912: LD_INT 5
83914: EQUAL
83915: IFFALSE 83925
// btype := b_armoury ;
83917: LD_ADDR_VAR 0 5
83921: PUSH
83922: LD_INT 4
83924: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83925: LD_VAR 0 5
83929: PUSH
83930: LD_INT 7
83932: PUSH
83933: LD_INT 8
83935: PUSH
83936: EMPTY
83937: LIST
83938: LIST
83939: IN
83940: IFFALSE 83950
// btype := b_lab ;
83942: LD_ADDR_VAR 0 5
83946: PUSH
83947: LD_INT 6
83949: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83950: LD_ADDR_EXP 65
83954: PUSH
83955: LD_EXP 65
83959: PPUSH
83960: LD_VAR 0 3
83964: PUSH
83965: LD_EXP 65
83969: PUSH
83970: LD_VAR 0 3
83974: ARRAY
83975: PUSH
83976: LD_INT 1
83978: PLUS
83979: PUSH
83980: EMPTY
83981: LIST
83982: LIST
83983: PPUSH
83984: LD_VAR 0 5
83988: PUSH
83989: LD_VAR 0 1
83993: PPUSH
83994: CALL_OW 250
83998: PUSH
83999: LD_VAR 0 1
84003: PPUSH
84004: CALL_OW 251
84008: PUSH
84009: LD_VAR 0 1
84013: PPUSH
84014: CALL_OW 254
84018: PUSH
84019: EMPTY
84020: LIST
84021: LIST
84022: LIST
84023: LIST
84024: PPUSH
84025: CALL 20003 0 3
84029: ST_TO_ADDR
// if pos = 1 then
84030: LD_VAR 0 6
84034: PUSH
84035: LD_INT 1
84037: EQUAL
84038: IFFALSE 84153
// begin tmp := mc_build_list [ i ] ;
84040: LD_ADDR_VAR 0 7
84044: PUSH
84045: LD_EXP 65
84049: PUSH
84050: LD_VAR 0 3
84054: ARRAY
84055: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
84056: LD_VAR 0 7
84060: PPUSH
84061: LD_INT 2
84063: PUSH
84064: LD_INT 30
84066: PUSH
84067: LD_INT 0
84069: PUSH
84070: EMPTY
84071: LIST
84072: LIST
84073: PUSH
84074: LD_INT 30
84076: PUSH
84077: LD_INT 1
84079: PUSH
84080: EMPTY
84081: LIST
84082: LIST
84083: PUSH
84084: EMPTY
84085: LIST
84086: LIST
84087: LIST
84088: PPUSH
84089: CALL_OW 72
84093: IFFALSE 84103
// pos := 2 ;
84095: LD_ADDR_VAR 0 6
84099: PUSH
84100: LD_INT 2
84102: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
84103: LD_ADDR_VAR 0 7
84107: PUSH
84108: LD_VAR 0 7
84112: PPUSH
84113: LD_VAR 0 6
84117: PPUSH
84118: LD_VAR 0 7
84122: PPUSH
84123: CALL 20329 0 3
84127: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
84128: LD_ADDR_EXP 65
84132: PUSH
84133: LD_EXP 65
84137: PPUSH
84138: LD_VAR 0 3
84142: PPUSH
84143: LD_VAR 0 7
84147: PPUSH
84148: CALL_OW 1
84152: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
84153: LD_VAR 0 1
84157: PUSH
84158: LD_EXP 60
84162: PUSH
84163: LD_VAR 0 3
84167: ARRAY
84168: IN
84169: IFFALSE 84208
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
84171: LD_ADDR_EXP 60
84175: PUSH
84176: LD_EXP 60
84180: PPUSH
84181: LD_VAR 0 3
84185: PPUSH
84186: LD_EXP 60
84190: PUSH
84191: LD_VAR 0 3
84195: ARRAY
84196: PUSH
84197: LD_VAR 0 1
84201: DIFF
84202: PPUSH
84203: CALL_OW 1
84207: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
84208: LD_VAR 0 1
84212: PUSH
84213: LD_EXP 67
84217: PUSH
84218: LD_VAR 0 3
84222: ARRAY
84223: IN
84224: IFFALSE 84263
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
84226: LD_ADDR_EXP 67
84230: PUSH
84231: LD_EXP 67
84235: PPUSH
84236: LD_VAR 0 3
84240: PPUSH
84241: LD_EXP 67
84245: PUSH
84246: LD_VAR 0 3
84250: ARRAY
84251: PUSH
84252: LD_VAR 0 1
84256: DIFF
84257: PPUSH
84258: CALL_OW 1
84262: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
84263: LD_VAR 0 1
84267: PUSH
84268: LD_EXP 79
84272: PUSH
84273: LD_VAR 0 3
84277: ARRAY
84278: IN
84279: IFFALSE 84318
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
84281: LD_ADDR_EXP 79
84285: PUSH
84286: LD_EXP 79
84290: PPUSH
84291: LD_VAR 0 3
84295: PPUSH
84296: LD_EXP 79
84300: PUSH
84301: LD_VAR 0 3
84305: ARRAY
84306: PUSH
84307: LD_VAR 0 1
84311: DIFF
84312: PPUSH
84313: CALL_OW 1
84317: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
84318: LD_VAR 0 1
84322: PUSH
84323: LD_EXP 82
84327: PUSH
84328: LD_VAR 0 3
84332: ARRAY
84333: IN
84334: IFFALSE 84373
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84336: LD_ADDR_EXP 82
84340: PUSH
84341: LD_EXP 82
84345: PPUSH
84346: LD_VAR 0 3
84350: PPUSH
84351: LD_EXP 82
84355: PUSH
84356: LD_VAR 0 3
84360: ARRAY
84361: PUSH
84362: LD_VAR 0 1
84366: DIFF
84367: PPUSH
84368: CALL_OW 1
84372: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
84373: LD_VAR 0 1
84377: PUSH
84378: LD_EXP 69
84382: PUSH
84383: LD_VAR 0 3
84387: ARRAY
84388: IN
84389: IFFALSE 84428
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
84391: LD_ADDR_EXP 69
84395: PUSH
84396: LD_EXP 69
84400: PPUSH
84401: LD_VAR 0 3
84405: PPUSH
84406: LD_EXP 69
84410: PUSH
84411: LD_VAR 0 3
84415: ARRAY
84416: PUSH
84417: LD_VAR 0 1
84421: DIFF
84422: PPUSH
84423: CALL_OW 1
84427: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
84428: LD_VAR 0 1
84432: PUSH
84433: LD_EXP 68
84437: PUSH
84438: LD_VAR 0 3
84442: ARRAY
84443: IN
84444: IFFALSE 84483
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
84446: LD_ADDR_EXP 68
84450: PUSH
84451: LD_EXP 68
84455: PPUSH
84456: LD_VAR 0 3
84460: PPUSH
84461: LD_EXP 68
84465: PUSH
84466: LD_VAR 0 3
84470: ARRAY
84471: PUSH
84472: LD_VAR 0 1
84476: DIFF
84477: PPUSH
84478: CALL_OW 1
84482: ST_TO_ADDR
// end ; break ;
84483: GO 84487
// end ;
84485: GO 83133
84487: POP
84488: POP
// end ;
84489: LD_VAR 0 2
84493: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
84494: LD_INT 0
84496: PPUSH
84497: PPUSH
84498: PPUSH
// if not mc_bases or not skirmish then
84499: LD_EXP 60
84503: NOT
84504: PUSH
84505: LD_EXP 58
84509: NOT
84510: OR
84511: IFFALSE 84515
// exit ;
84513: GO 84730
// for i = 1 to mc_bases do
84515: LD_ADDR_VAR 0 3
84519: PUSH
84520: DOUBLE
84521: LD_INT 1
84523: DEC
84524: ST_TO_ADDR
84525: LD_EXP 60
84529: PUSH
84530: FOR_TO
84531: IFFALSE 84728
// begin if building in mc_construct_list [ i ] then
84533: LD_VAR 0 1
84537: PUSH
84538: LD_EXP 67
84542: PUSH
84543: LD_VAR 0 3
84547: ARRAY
84548: IN
84549: IFFALSE 84726
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84551: LD_ADDR_EXP 67
84555: PUSH
84556: LD_EXP 67
84560: PPUSH
84561: LD_VAR 0 3
84565: PPUSH
84566: LD_EXP 67
84570: PUSH
84571: LD_VAR 0 3
84575: ARRAY
84576: PUSH
84577: LD_VAR 0 1
84581: DIFF
84582: PPUSH
84583: CALL_OW 1
84587: ST_TO_ADDR
// if building in mc_lab [ i ] then
84588: LD_VAR 0 1
84592: PUSH
84593: LD_EXP 93
84597: PUSH
84598: LD_VAR 0 3
84602: ARRAY
84603: IN
84604: IFFALSE 84659
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84606: LD_ADDR_EXP 94
84610: PUSH
84611: LD_EXP 94
84615: PPUSH
84616: LD_VAR 0 3
84620: PPUSH
84621: LD_EXP 94
84625: PUSH
84626: LD_VAR 0 3
84630: ARRAY
84631: PPUSH
84632: LD_INT 1
84634: PPUSH
84635: LD_EXP 94
84639: PUSH
84640: LD_VAR 0 3
84644: ARRAY
84645: PPUSH
84646: LD_INT 0
84648: PPUSH
84649: CALL 19421 0 4
84653: PPUSH
84654: CALL_OW 1
84658: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84659: LD_VAR 0 1
84663: PUSH
84664: LD_EXP 60
84668: PUSH
84669: LD_VAR 0 3
84673: ARRAY
84674: IN
84675: NOT
84676: IFFALSE 84722
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84678: LD_ADDR_EXP 60
84682: PUSH
84683: LD_EXP 60
84687: PPUSH
84688: LD_VAR 0 3
84692: PUSH
84693: LD_EXP 60
84697: PUSH
84698: LD_VAR 0 3
84702: ARRAY
84703: PUSH
84704: LD_INT 1
84706: PLUS
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PPUSH
84712: LD_VAR 0 1
84716: PPUSH
84717: CALL 20003 0 3
84721: ST_TO_ADDR
// exit ;
84722: POP
84723: POP
84724: GO 84730
// end ; end ;
84726: GO 84530
84728: POP
84729: POP
// end ;
84730: LD_VAR 0 2
84734: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84735: LD_INT 0
84737: PPUSH
84738: PPUSH
84739: PPUSH
84740: PPUSH
84741: PPUSH
84742: PPUSH
84743: PPUSH
// if not mc_bases or not skirmish then
84744: LD_EXP 60
84748: NOT
84749: PUSH
84750: LD_EXP 58
84754: NOT
84755: OR
84756: IFFALSE 84760
// exit ;
84758: GO 85421
// for i = 1 to mc_bases do
84760: LD_ADDR_VAR 0 3
84764: PUSH
84765: DOUBLE
84766: LD_INT 1
84768: DEC
84769: ST_TO_ADDR
84770: LD_EXP 60
84774: PUSH
84775: FOR_TO
84776: IFFALSE 85419
// begin if building in mc_construct_list [ i ] then
84778: LD_VAR 0 1
84782: PUSH
84783: LD_EXP 67
84787: PUSH
84788: LD_VAR 0 3
84792: ARRAY
84793: IN
84794: IFFALSE 85417
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84796: LD_ADDR_EXP 67
84800: PUSH
84801: LD_EXP 67
84805: PPUSH
84806: LD_VAR 0 3
84810: PPUSH
84811: LD_EXP 67
84815: PUSH
84816: LD_VAR 0 3
84820: ARRAY
84821: PUSH
84822: LD_VAR 0 1
84826: DIFF
84827: PPUSH
84828: CALL_OW 1
84832: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84833: LD_ADDR_EXP 60
84837: PUSH
84838: LD_EXP 60
84842: PPUSH
84843: LD_VAR 0 3
84847: PUSH
84848: LD_EXP 60
84852: PUSH
84853: LD_VAR 0 3
84857: ARRAY
84858: PUSH
84859: LD_INT 1
84861: PLUS
84862: PUSH
84863: EMPTY
84864: LIST
84865: LIST
84866: PPUSH
84867: LD_VAR 0 1
84871: PPUSH
84872: CALL 20003 0 3
84876: ST_TO_ADDR
// btype := GetBType ( building ) ;
84877: LD_ADDR_VAR 0 5
84881: PUSH
84882: LD_VAR 0 1
84886: PPUSH
84887: CALL_OW 266
84891: ST_TO_ADDR
// side := GetSide ( building ) ;
84892: LD_ADDR_VAR 0 8
84896: PUSH
84897: LD_VAR 0 1
84901: PPUSH
84902: CALL_OW 255
84906: ST_TO_ADDR
// if btype = b_lab then
84907: LD_VAR 0 5
84911: PUSH
84912: LD_INT 6
84914: EQUAL
84915: IFFALSE 84965
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84917: LD_ADDR_EXP 93
84921: PUSH
84922: LD_EXP 93
84926: PPUSH
84927: LD_VAR 0 3
84931: PUSH
84932: LD_EXP 93
84936: PUSH
84937: LD_VAR 0 3
84941: ARRAY
84942: PUSH
84943: LD_INT 1
84945: PLUS
84946: PUSH
84947: EMPTY
84948: LIST
84949: LIST
84950: PPUSH
84951: LD_VAR 0 1
84955: PPUSH
84956: CALL 20003 0 3
84960: ST_TO_ADDR
// exit ;
84961: POP
84962: POP
84963: GO 85421
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84965: LD_VAR 0 5
84969: PUSH
84970: LD_INT 0
84972: PUSH
84973: LD_INT 2
84975: PUSH
84976: LD_INT 4
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: LIST
84983: IN
84984: IFFALSE 85108
// begin if btype = b_armoury then
84986: LD_VAR 0 5
84990: PUSH
84991: LD_INT 4
84993: EQUAL
84994: IFFALSE 85004
// btype := b_barracks ;
84996: LD_ADDR_VAR 0 5
85000: PUSH
85001: LD_INT 5
85003: ST_TO_ADDR
// if btype = b_depot then
85004: LD_VAR 0 5
85008: PUSH
85009: LD_INT 0
85011: EQUAL
85012: IFFALSE 85022
// btype := b_warehouse ;
85014: LD_ADDR_VAR 0 5
85018: PUSH
85019: LD_INT 1
85021: ST_TO_ADDR
// if btype = b_workshop then
85022: LD_VAR 0 5
85026: PUSH
85027: LD_INT 2
85029: EQUAL
85030: IFFALSE 85040
// btype := b_factory ;
85032: LD_ADDR_VAR 0 5
85036: PUSH
85037: LD_INT 3
85039: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
85040: LD_VAR 0 5
85044: PPUSH
85045: LD_VAR 0 8
85049: PPUSH
85050: CALL_OW 323
85054: PUSH
85055: LD_INT 1
85057: EQUAL
85058: IFFALSE 85104
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
85060: LD_ADDR_EXP 92
85064: PUSH
85065: LD_EXP 92
85069: PPUSH
85070: LD_VAR 0 3
85074: PUSH
85075: LD_EXP 92
85079: PUSH
85080: LD_VAR 0 3
85084: ARRAY
85085: PUSH
85086: LD_INT 1
85088: PLUS
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PPUSH
85094: LD_VAR 0 1
85098: PPUSH
85099: CALL 20003 0 3
85103: ST_TO_ADDR
// exit ;
85104: POP
85105: POP
85106: GO 85421
// end ; if btype in [ b_bunker , b_turret ] then
85108: LD_VAR 0 5
85112: PUSH
85113: LD_INT 32
85115: PUSH
85116: LD_INT 33
85118: PUSH
85119: EMPTY
85120: LIST
85121: LIST
85122: IN
85123: IFFALSE 85413
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
85125: LD_ADDR_EXP 68
85129: PUSH
85130: LD_EXP 68
85134: PPUSH
85135: LD_VAR 0 3
85139: PUSH
85140: LD_EXP 68
85144: PUSH
85145: LD_VAR 0 3
85149: ARRAY
85150: PUSH
85151: LD_INT 1
85153: PLUS
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: PPUSH
85159: LD_VAR 0 1
85163: PPUSH
85164: CALL 20003 0 3
85168: ST_TO_ADDR
// if btype = b_bunker then
85169: LD_VAR 0 5
85173: PUSH
85174: LD_INT 32
85176: EQUAL
85177: IFFALSE 85413
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85179: LD_ADDR_EXP 69
85183: PUSH
85184: LD_EXP 69
85188: PPUSH
85189: LD_VAR 0 3
85193: PUSH
85194: LD_EXP 69
85198: PUSH
85199: LD_VAR 0 3
85203: ARRAY
85204: PUSH
85205: LD_INT 1
85207: PLUS
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PPUSH
85213: LD_VAR 0 1
85217: PPUSH
85218: CALL 20003 0 3
85222: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
85223: LD_ADDR_VAR 0 6
85227: PUSH
85228: LD_EXP 60
85232: PUSH
85233: LD_VAR 0 3
85237: ARRAY
85238: PPUSH
85239: LD_INT 25
85241: PUSH
85242: LD_INT 1
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: PUSH
85249: LD_INT 3
85251: PUSH
85252: LD_INT 54
85254: PUSH
85255: EMPTY
85256: LIST
85257: PUSH
85258: EMPTY
85259: LIST
85260: LIST
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PPUSH
85266: CALL_OW 72
85270: ST_TO_ADDR
// if tmp then
85271: LD_VAR 0 6
85275: IFFALSE 85281
// exit ;
85277: POP
85278: POP
85279: GO 85421
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
85281: LD_ADDR_VAR 0 6
85285: PUSH
85286: LD_EXP 60
85290: PUSH
85291: LD_VAR 0 3
85295: ARRAY
85296: PPUSH
85297: LD_INT 2
85299: PUSH
85300: LD_INT 30
85302: PUSH
85303: LD_INT 4
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: PUSH
85310: LD_INT 30
85312: PUSH
85313: LD_INT 5
85315: PUSH
85316: EMPTY
85317: LIST
85318: LIST
85319: PUSH
85320: EMPTY
85321: LIST
85322: LIST
85323: LIST
85324: PPUSH
85325: CALL_OW 72
85329: ST_TO_ADDR
// if not tmp then
85330: LD_VAR 0 6
85334: NOT
85335: IFFALSE 85341
// exit ;
85337: POP
85338: POP
85339: GO 85421
// for j in tmp do
85341: LD_ADDR_VAR 0 4
85345: PUSH
85346: LD_VAR 0 6
85350: PUSH
85351: FOR_IN
85352: IFFALSE 85411
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
85354: LD_ADDR_VAR 0 7
85358: PUSH
85359: LD_VAR 0 4
85363: PPUSH
85364: CALL_OW 313
85368: PPUSH
85369: LD_INT 25
85371: PUSH
85372: LD_INT 1
85374: PUSH
85375: EMPTY
85376: LIST
85377: LIST
85378: PPUSH
85379: CALL_OW 72
85383: ST_TO_ADDR
// if units then
85384: LD_VAR 0 7
85388: IFFALSE 85409
// begin ComExitBuilding ( units [ 1 ] ) ;
85390: LD_VAR 0 7
85394: PUSH
85395: LD_INT 1
85397: ARRAY
85398: PPUSH
85399: CALL_OW 122
// exit ;
85403: POP
85404: POP
85405: POP
85406: POP
85407: GO 85421
// end ; end ;
85409: GO 85351
85411: POP
85412: POP
// end ; end ; exit ;
85413: POP
85414: POP
85415: GO 85421
// end ; end ;
85417: GO 84775
85419: POP
85420: POP
// end ;
85421: LD_VAR 0 2
85425: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
85426: LD_INT 0
85428: PPUSH
85429: PPUSH
85430: PPUSH
85431: PPUSH
85432: PPUSH
85433: PPUSH
85434: PPUSH
// if not mc_bases or not skirmish then
85435: LD_EXP 60
85439: NOT
85440: PUSH
85441: LD_EXP 58
85445: NOT
85446: OR
85447: IFFALSE 85451
// exit ;
85449: GO 85716
// btype := GetBType ( building ) ;
85451: LD_ADDR_VAR 0 6
85455: PUSH
85456: LD_VAR 0 1
85460: PPUSH
85461: CALL_OW 266
85465: ST_TO_ADDR
// x := GetX ( building ) ;
85466: LD_ADDR_VAR 0 7
85470: PUSH
85471: LD_VAR 0 1
85475: PPUSH
85476: CALL_OW 250
85480: ST_TO_ADDR
// y := GetY ( building ) ;
85481: LD_ADDR_VAR 0 8
85485: PUSH
85486: LD_VAR 0 1
85490: PPUSH
85491: CALL_OW 251
85495: ST_TO_ADDR
// d := GetDir ( building ) ;
85496: LD_ADDR_VAR 0 9
85500: PUSH
85501: LD_VAR 0 1
85505: PPUSH
85506: CALL_OW 254
85510: ST_TO_ADDR
// for i = 1 to mc_bases do
85511: LD_ADDR_VAR 0 4
85515: PUSH
85516: DOUBLE
85517: LD_INT 1
85519: DEC
85520: ST_TO_ADDR
85521: LD_EXP 60
85525: PUSH
85526: FOR_TO
85527: IFFALSE 85714
// begin if not mc_build_list [ i ] then
85529: LD_EXP 65
85533: PUSH
85534: LD_VAR 0 4
85538: ARRAY
85539: NOT
85540: IFFALSE 85544
// continue ;
85542: GO 85526
// for j := 1 to mc_build_list [ i ] do
85544: LD_ADDR_VAR 0 5
85548: PUSH
85549: DOUBLE
85550: LD_INT 1
85552: DEC
85553: ST_TO_ADDR
85554: LD_EXP 65
85558: PUSH
85559: LD_VAR 0 4
85563: ARRAY
85564: PUSH
85565: FOR_TO
85566: IFFALSE 85710
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
85568: LD_VAR 0 6
85572: PUSH
85573: LD_VAR 0 7
85577: PUSH
85578: LD_VAR 0 8
85582: PUSH
85583: LD_VAR 0 9
85587: PUSH
85588: EMPTY
85589: LIST
85590: LIST
85591: LIST
85592: LIST
85593: PPUSH
85594: LD_EXP 65
85598: PUSH
85599: LD_VAR 0 4
85603: ARRAY
85604: PUSH
85605: LD_VAR 0 5
85609: ARRAY
85610: PPUSH
85611: CALL 26185 0 2
85615: IFFALSE 85708
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
85617: LD_ADDR_EXP 65
85621: PUSH
85622: LD_EXP 65
85626: PPUSH
85627: LD_VAR 0 4
85631: PPUSH
85632: LD_EXP 65
85636: PUSH
85637: LD_VAR 0 4
85641: ARRAY
85642: PPUSH
85643: LD_VAR 0 5
85647: PPUSH
85648: CALL_OW 3
85652: PPUSH
85653: CALL_OW 1
85657: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85658: LD_ADDR_EXP 67
85662: PUSH
85663: LD_EXP 67
85667: PPUSH
85668: LD_VAR 0 4
85672: PUSH
85673: LD_EXP 67
85677: PUSH
85678: LD_VAR 0 4
85682: ARRAY
85683: PUSH
85684: LD_INT 1
85686: PLUS
85687: PUSH
85688: EMPTY
85689: LIST
85690: LIST
85691: PPUSH
85692: LD_VAR 0 1
85696: PPUSH
85697: CALL 20003 0 3
85701: ST_TO_ADDR
// exit ;
85702: POP
85703: POP
85704: POP
85705: POP
85706: GO 85716
// end ;
85708: GO 85565
85710: POP
85711: POP
// end ;
85712: GO 85526
85714: POP
85715: POP
// end ;
85716: LD_VAR 0 3
85720: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85721: LD_INT 0
85723: PPUSH
85724: PPUSH
85725: PPUSH
// if not mc_bases or not skirmish then
85726: LD_EXP 60
85730: NOT
85731: PUSH
85732: LD_EXP 58
85736: NOT
85737: OR
85738: IFFALSE 85742
// exit ;
85740: GO 85932
// for i = 1 to mc_bases do
85742: LD_ADDR_VAR 0 4
85746: PUSH
85747: DOUBLE
85748: LD_INT 1
85750: DEC
85751: ST_TO_ADDR
85752: LD_EXP 60
85756: PUSH
85757: FOR_TO
85758: IFFALSE 85845
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85760: LD_VAR 0 1
85764: PUSH
85765: LD_EXP 68
85769: PUSH
85770: LD_VAR 0 4
85774: ARRAY
85775: IN
85776: PUSH
85777: LD_VAR 0 1
85781: PUSH
85782: LD_EXP 69
85786: PUSH
85787: LD_VAR 0 4
85791: ARRAY
85792: IN
85793: NOT
85794: AND
85795: IFFALSE 85843
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85797: LD_ADDR_EXP 69
85801: PUSH
85802: LD_EXP 69
85806: PPUSH
85807: LD_VAR 0 4
85811: PUSH
85812: LD_EXP 69
85816: PUSH
85817: LD_VAR 0 4
85821: ARRAY
85822: PUSH
85823: LD_INT 1
85825: PLUS
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: PPUSH
85831: LD_VAR 0 1
85835: PPUSH
85836: CALL 20003 0 3
85840: ST_TO_ADDR
// break ;
85841: GO 85845
// end ; end ;
85843: GO 85757
85845: POP
85846: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85847: LD_VAR 0 1
85851: PPUSH
85852: CALL_OW 257
85856: PUSH
85857: LD_EXP 86
85861: IN
85862: PUSH
85863: LD_VAR 0 1
85867: PPUSH
85868: CALL_OW 266
85872: PUSH
85873: LD_INT 5
85875: EQUAL
85876: AND
85877: PUSH
85878: LD_VAR 0 2
85882: PPUSH
85883: CALL_OW 110
85887: PUSH
85888: LD_INT 18
85890: NONEQUAL
85891: AND
85892: IFFALSE 85932
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85894: LD_VAR 0 2
85898: PPUSH
85899: CALL_OW 257
85903: PUSH
85904: LD_INT 5
85906: PUSH
85907: LD_INT 8
85909: PUSH
85910: LD_INT 9
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: LIST
85917: IN
85918: IFFALSE 85932
// SetClass ( unit , 1 ) ;
85920: LD_VAR 0 2
85924: PPUSH
85925: LD_INT 1
85927: PPUSH
85928: CALL_OW 336
// end ;
85932: LD_VAR 0 3
85936: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85937: LD_INT 0
85939: PPUSH
85940: PPUSH
// if not mc_bases or not skirmish then
85941: LD_EXP 60
85945: NOT
85946: PUSH
85947: LD_EXP 58
85951: NOT
85952: OR
85953: IFFALSE 85957
// exit ;
85955: GO 86073
// if GetLives ( abandoned_vehicle ) > 250 then
85957: LD_VAR 0 2
85961: PPUSH
85962: CALL_OW 256
85966: PUSH
85967: LD_INT 250
85969: GREATER
85970: IFFALSE 85974
// exit ;
85972: GO 86073
// for i = 1 to mc_bases do
85974: LD_ADDR_VAR 0 6
85978: PUSH
85979: DOUBLE
85980: LD_INT 1
85982: DEC
85983: ST_TO_ADDR
85984: LD_EXP 60
85988: PUSH
85989: FOR_TO
85990: IFFALSE 86071
// begin if driver in mc_bases [ i ] then
85992: LD_VAR 0 1
85996: PUSH
85997: LD_EXP 60
86001: PUSH
86002: LD_VAR 0 6
86006: ARRAY
86007: IN
86008: IFFALSE 86069
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
86010: LD_VAR 0 1
86014: PPUSH
86015: LD_EXP 60
86019: PUSH
86020: LD_VAR 0 6
86024: ARRAY
86025: PPUSH
86026: LD_INT 2
86028: PUSH
86029: LD_INT 30
86031: PUSH
86032: LD_INT 0
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PUSH
86039: LD_INT 30
86041: PUSH
86042: LD_INT 1
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: LIST
86053: PPUSH
86054: CALL_OW 72
86058: PUSH
86059: LD_INT 1
86061: ARRAY
86062: PPUSH
86063: CALL 52565 0 2
// break ;
86067: GO 86071
// end ; end ;
86069: GO 85989
86071: POP
86072: POP
// end ; end_of_file
86073: LD_VAR 0 5
86077: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
86078: LD_INT 0
86080: PPUSH
// ar_miner := 81 ;
86081: LD_ADDR_EXP 111
86085: PUSH
86086: LD_INT 81
86088: ST_TO_ADDR
// ar_crane := 88 ;
86089: LD_ADDR_EXP 110
86093: PUSH
86094: LD_INT 88
86096: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
86097: LD_ADDR_EXP 105
86101: PUSH
86102: LD_INT 89
86104: ST_TO_ADDR
// us_hack := 99 ;
86105: LD_ADDR_EXP 106
86109: PUSH
86110: LD_INT 99
86112: ST_TO_ADDR
// us_artillery := 97 ;
86113: LD_ADDR_EXP 107
86117: PUSH
86118: LD_INT 97
86120: ST_TO_ADDR
// ar_bio_bomb := 91 ;
86121: LD_ADDR_EXP 108
86125: PUSH
86126: LD_INT 91
86128: ST_TO_ADDR
// ar_mortar := 92 ;
86129: LD_ADDR_EXP 109
86133: PUSH
86134: LD_INT 92
86136: ST_TO_ADDR
// ru_flamethrower := 93 ;
86137: LD_ADDR_EXP 112
86141: PUSH
86142: LD_INT 93
86144: ST_TO_ADDR
// ru_radar := 98 ;
86145: LD_ADDR_EXP 104
86149: PUSH
86150: LD_INT 98
86152: ST_TO_ADDR
// tech_Artillery := 80 ;
86153: LD_ADDR_EXP 113
86157: PUSH
86158: LD_INT 80
86160: ST_TO_ADDR
// tech_RadMat := 81 ;
86161: LD_ADDR_EXP 114
86165: PUSH
86166: LD_INT 81
86168: ST_TO_ADDR
// tech_BasicTools := 82 ;
86169: LD_ADDR_EXP 115
86173: PUSH
86174: LD_INT 82
86176: ST_TO_ADDR
// tech_Cargo := 83 ;
86177: LD_ADDR_EXP 116
86181: PUSH
86182: LD_INT 83
86184: ST_TO_ADDR
// tech_Track := 84 ;
86185: LD_ADDR_EXP 117
86189: PUSH
86190: LD_INT 84
86192: ST_TO_ADDR
// tech_Crane := 85 ;
86193: LD_ADDR_EXP 118
86197: PUSH
86198: LD_INT 85
86200: ST_TO_ADDR
// tech_Bulldozer := 86 ;
86201: LD_ADDR_EXP 119
86205: PUSH
86206: LD_INT 86
86208: ST_TO_ADDR
// tech_Hovercraft := 87 ;
86209: LD_ADDR_EXP 120
86213: PUSH
86214: LD_INT 87
86216: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
86217: LD_ADDR_EXP 121
86221: PUSH
86222: LD_INT 88
86224: ST_TO_ADDR
// class_mastodont := 31 ;
86225: LD_ADDR_EXP 122
86229: PUSH
86230: LD_INT 31
86232: ST_TO_ADDR
// class_horse := 21 ;
86233: LD_ADDR_EXP 123
86237: PUSH
86238: LD_INT 21
86240: ST_TO_ADDR
// end ;
86241: LD_VAR 0 1
86245: RET
// every 1 do
86246: GO 86248
86248: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
86249: CALL 86078 0 0
86253: END
// every 0 0$1 do
86254: GO 86256
86256: DISABLE
// begin enable ;
86257: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
86258: LD_STRING updateTimer(
86260: PUSH
86261: LD_OWVAR 1
86265: STR
86266: PUSH
86267: LD_STRING );
86269: STR
86270: PPUSH
86271: CALL_OW 559
// end ;
86275: END
// export function SOS_MapStart ( ) ; begin
86276: LD_INT 0
86278: PPUSH
// if streamModeActive then
86279: LD_EXP 124
86283: IFFALSE 86292
// DefineStreamItems ( true ) ;
86285: LD_INT 1
86287: PPUSH
86288: CALL 87942 0 1
// UpdateFactoryWaypoints ( ) ;
86292: CALL 101526 0 0
// end ;
86296: LD_VAR 0 1
86300: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
86301: LD_INT 0
86303: PPUSH
// if p2 = 100 then
86304: LD_VAR 0 2
86308: PUSH
86309: LD_INT 100
86311: EQUAL
86312: IFFALSE 87315
// begin if not StreamModeActive then
86314: LD_EXP 124
86318: NOT
86319: IFFALSE 86329
// StreamModeActive := true ;
86321: LD_ADDR_EXP 124
86325: PUSH
86326: LD_INT 1
86328: ST_TO_ADDR
// if p3 = 0 then
86329: LD_VAR 0 3
86333: PUSH
86334: LD_INT 0
86336: EQUAL
86337: IFFALSE 86343
// InitStreamMode ;
86339: CALL 87478 0 0
// if p3 = 1 then
86343: LD_VAR 0 3
86347: PUSH
86348: LD_INT 1
86350: EQUAL
86351: IFFALSE 86361
// sRocket := true ;
86353: LD_ADDR_EXP 129
86357: PUSH
86358: LD_INT 1
86360: ST_TO_ADDR
// if p3 = 2 then
86361: LD_VAR 0 3
86365: PUSH
86366: LD_INT 2
86368: EQUAL
86369: IFFALSE 86379
// sSpeed := true ;
86371: LD_ADDR_EXP 128
86375: PUSH
86376: LD_INT 1
86378: ST_TO_ADDR
// if p3 = 3 then
86379: LD_VAR 0 3
86383: PUSH
86384: LD_INT 3
86386: EQUAL
86387: IFFALSE 86397
// sEngine := true ;
86389: LD_ADDR_EXP 130
86393: PUSH
86394: LD_INT 1
86396: ST_TO_ADDR
// if p3 = 4 then
86397: LD_VAR 0 3
86401: PUSH
86402: LD_INT 4
86404: EQUAL
86405: IFFALSE 86415
// sSpec := true ;
86407: LD_ADDR_EXP 127
86411: PUSH
86412: LD_INT 1
86414: ST_TO_ADDR
// if p3 = 5 then
86415: LD_VAR 0 3
86419: PUSH
86420: LD_INT 5
86422: EQUAL
86423: IFFALSE 86433
// sLevel := true ;
86425: LD_ADDR_EXP 131
86429: PUSH
86430: LD_INT 1
86432: ST_TO_ADDR
// if p3 = 6 then
86433: LD_VAR 0 3
86437: PUSH
86438: LD_INT 6
86440: EQUAL
86441: IFFALSE 86451
// sArmoury := true ;
86443: LD_ADDR_EXP 132
86447: PUSH
86448: LD_INT 1
86450: ST_TO_ADDR
// if p3 = 7 then
86451: LD_VAR 0 3
86455: PUSH
86456: LD_INT 7
86458: EQUAL
86459: IFFALSE 86469
// sRadar := true ;
86461: LD_ADDR_EXP 133
86465: PUSH
86466: LD_INT 1
86468: ST_TO_ADDR
// if p3 = 8 then
86469: LD_VAR 0 3
86473: PUSH
86474: LD_INT 8
86476: EQUAL
86477: IFFALSE 86487
// sBunker := true ;
86479: LD_ADDR_EXP 134
86483: PUSH
86484: LD_INT 1
86486: ST_TO_ADDR
// if p3 = 9 then
86487: LD_VAR 0 3
86491: PUSH
86492: LD_INT 9
86494: EQUAL
86495: IFFALSE 86505
// sHack := true ;
86497: LD_ADDR_EXP 135
86501: PUSH
86502: LD_INT 1
86504: ST_TO_ADDR
// if p3 = 10 then
86505: LD_VAR 0 3
86509: PUSH
86510: LD_INT 10
86512: EQUAL
86513: IFFALSE 86523
// sFire := true ;
86515: LD_ADDR_EXP 136
86519: PUSH
86520: LD_INT 1
86522: ST_TO_ADDR
// if p3 = 11 then
86523: LD_VAR 0 3
86527: PUSH
86528: LD_INT 11
86530: EQUAL
86531: IFFALSE 86541
// sRefresh := true ;
86533: LD_ADDR_EXP 137
86537: PUSH
86538: LD_INT 1
86540: ST_TO_ADDR
// if p3 = 12 then
86541: LD_VAR 0 3
86545: PUSH
86546: LD_INT 12
86548: EQUAL
86549: IFFALSE 86559
// sExp := true ;
86551: LD_ADDR_EXP 138
86555: PUSH
86556: LD_INT 1
86558: ST_TO_ADDR
// if p3 = 13 then
86559: LD_VAR 0 3
86563: PUSH
86564: LD_INT 13
86566: EQUAL
86567: IFFALSE 86577
// sDepot := true ;
86569: LD_ADDR_EXP 139
86573: PUSH
86574: LD_INT 1
86576: ST_TO_ADDR
// if p3 = 14 then
86577: LD_VAR 0 3
86581: PUSH
86582: LD_INT 14
86584: EQUAL
86585: IFFALSE 86595
// sFlag := true ;
86587: LD_ADDR_EXP 140
86591: PUSH
86592: LD_INT 1
86594: ST_TO_ADDR
// if p3 = 15 then
86595: LD_VAR 0 3
86599: PUSH
86600: LD_INT 15
86602: EQUAL
86603: IFFALSE 86613
// sKamikadze := true ;
86605: LD_ADDR_EXP 148
86609: PUSH
86610: LD_INT 1
86612: ST_TO_ADDR
// if p3 = 16 then
86613: LD_VAR 0 3
86617: PUSH
86618: LD_INT 16
86620: EQUAL
86621: IFFALSE 86631
// sTroll := true ;
86623: LD_ADDR_EXP 149
86627: PUSH
86628: LD_INT 1
86630: ST_TO_ADDR
// if p3 = 17 then
86631: LD_VAR 0 3
86635: PUSH
86636: LD_INT 17
86638: EQUAL
86639: IFFALSE 86649
// sSlow := true ;
86641: LD_ADDR_EXP 150
86645: PUSH
86646: LD_INT 1
86648: ST_TO_ADDR
// if p3 = 18 then
86649: LD_VAR 0 3
86653: PUSH
86654: LD_INT 18
86656: EQUAL
86657: IFFALSE 86667
// sLack := true ;
86659: LD_ADDR_EXP 151
86663: PUSH
86664: LD_INT 1
86666: ST_TO_ADDR
// if p3 = 19 then
86667: LD_VAR 0 3
86671: PUSH
86672: LD_INT 19
86674: EQUAL
86675: IFFALSE 86685
// sTank := true ;
86677: LD_ADDR_EXP 153
86681: PUSH
86682: LD_INT 1
86684: ST_TO_ADDR
// if p3 = 20 then
86685: LD_VAR 0 3
86689: PUSH
86690: LD_INT 20
86692: EQUAL
86693: IFFALSE 86703
// sRemote := true ;
86695: LD_ADDR_EXP 154
86699: PUSH
86700: LD_INT 1
86702: ST_TO_ADDR
// if p3 = 21 then
86703: LD_VAR 0 3
86707: PUSH
86708: LD_INT 21
86710: EQUAL
86711: IFFALSE 86721
// sPowell := true ;
86713: LD_ADDR_EXP 155
86717: PUSH
86718: LD_INT 1
86720: ST_TO_ADDR
// if p3 = 22 then
86721: LD_VAR 0 3
86725: PUSH
86726: LD_INT 22
86728: EQUAL
86729: IFFALSE 86739
// sTeleport := true ;
86731: LD_ADDR_EXP 158
86735: PUSH
86736: LD_INT 1
86738: ST_TO_ADDR
// if p3 = 23 then
86739: LD_VAR 0 3
86743: PUSH
86744: LD_INT 23
86746: EQUAL
86747: IFFALSE 86757
// sOilTower := true ;
86749: LD_ADDR_EXP 160
86753: PUSH
86754: LD_INT 1
86756: ST_TO_ADDR
// if p3 = 24 then
86757: LD_VAR 0 3
86761: PUSH
86762: LD_INT 24
86764: EQUAL
86765: IFFALSE 86775
// sShovel := true ;
86767: LD_ADDR_EXP 161
86771: PUSH
86772: LD_INT 1
86774: ST_TO_ADDR
// if p3 = 25 then
86775: LD_VAR 0 3
86779: PUSH
86780: LD_INT 25
86782: EQUAL
86783: IFFALSE 86793
// sSheik := true ;
86785: LD_ADDR_EXP 162
86789: PUSH
86790: LD_INT 1
86792: ST_TO_ADDR
// if p3 = 26 then
86793: LD_VAR 0 3
86797: PUSH
86798: LD_INT 26
86800: EQUAL
86801: IFFALSE 86811
// sEarthquake := true ;
86803: LD_ADDR_EXP 164
86807: PUSH
86808: LD_INT 1
86810: ST_TO_ADDR
// if p3 = 27 then
86811: LD_VAR 0 3
86815: PUSH
86816: LD_INT 27
86818: EQUAL
86819: IFFALSE 86829
// sAI := true ;
86821: LD_ADDR_EXP 165
86825: PUSH
86826: LD_INT 1
86828: ST_TO_ADDR
// if p3 = 28 then
86829: LD_VAR 0 3
86833: PUSH
86834: LD_INT 28
86836: EQUAL
86837: IFFALSE 86847
// sCargo := true ;
86839: LD_ADDR_EXP 168
86843: PUSH
86844: LD_INT 1
86846: ST_TO_ADDR
// if p3 = 29 then
86847: LD_VAR 0 3
86851: PUSH
86852: LD_INT 29
86854: EQUAL
86855: IFFALSE 86865
// sDLaser := true ;
86857: LD_ADDR_EXP 169
86861: PUSH
86862: LD_INT 1
86864: ST_TO_ADDR
// if p3 = 30 then
86865: LD_VAR 0 3
86869: PUSH
86870: LD_INT 30
86872: EQUAL
86873: IFFALSE 86883
// sExchange := true ;
86875: LD_ADDR_EXP 170
86879: PUSH
86880: LD_INT 1
86882: ST_TO_ADDR
// if p3 = 31 then
86883: LD_VAR 0 3
86887: PUSH
86888: LD_INT 31
86890: EQUAL
86891: IFFALSE 86901
// sFac := true ;
86893: LD_ADDR_EXP 171
86897: PUSH
86898: LD_INT 1
86900: ST_TO_ADDR
// if p3 = 32 then
86901: LD_VAR 0 3
86905: PUSH
86906: LD_INT 32
86908: EQUAL
86909: IFFALSE 86919
// sPower := true ;
86911: LD_ADDR_EXP 172
86915: PUSH
86916: LD_INT 1
86918: ST_TO_ADDR
// if p3 = 33 then
86919: LD_VAR 0 3
86923: PUSH
86924: LD_INT 33
86926: EQUAL
86927: IFFALSE 86937
// sRandom := true ;
86929: LD_ADDR_EXP 173
86933: PUSH
86934: LD_INT 1
86936: ST_TO_ADDR
// if p3 = 34 then
86937: LD_VAR 0 3
86941: PUSH
86942: LD_INT 34
86944: EQUAL
86945: IFFALSE 86955
// sShield := true ;
86947: LD_ADDR_EXP 174
86951: PUSH
86952: LD_INT 1
86954: ST_TO_ADDR
// if p3 = 35 then
86955: LD_VAR 0 3
86959: PUSH
86960: LD_INT 35
86962: EQUAL
86963: IFFALSE 86973
// sTime := true ;
86965: LD_ADDR_EXP 175
86969: PUSH
86970: LD_INT 1
86972: ST_TO_ADDR
// if p3 = 36 then
86973: LD_VAR 0 3
86977: PUSH
86978: LD_INT 36
86980: EQUAL
86981: IFFALSE 86991
// sTools := true ;
86983: LD_ADDR_EXP 176
86987: PUSH
86988: LD_INT 1
86990: ST_TO_ADDR
// if p3 = 101 then
86991: LD_VAR 0 3
86995: PUSH
86996: LD_INT 101
86998: EQUAL
86999: IFFALSE 87009
// sSold := true ;
87001: LD_ADDR_EXP 141
87005: PUSH
87006: LD_INT 1
87008: ST_TO_ADDR
// if p3 = 102 then
87009: LD_VAR 0 3
87013: PUSH
87014: LD_INT 102
87016: EQUAL
87017: IFFALSE 87027
// sDiff := true ;
87019: LD_ADDR_EXP 142
87023: PUSH
87024: LD_INT 1
87026: ST_TO_ADDR
// if p3 = 103 then
87027: LD_VAR 0 3
87031: PUSH
87032: LD_INT 103
87034: EQUAL
87035: IFFALSE 87045
// sFog := true ;
87037: LD_ADDR_EXP 145
87041: PUSH
87042: LD_INT 1
87044: ST_TO_ADDR
// if p3 = 104 then
87045: LD_VAR 0 3
87049: PUSH
87050: LD_INT 104
87052: EQUAL
87053: IFFALSE 87063
// sReset := true ;
87055: LD_ADDR_EXP 146
87059: PUSH
87060: LD_INT 1
87062: ST_TO_ADDR
// if p3 = 105 then
87063: LD_VAR 0 3
87067: PUSH
87068: LD_INT 105
87070: EQUAL
87071: IFFALSE 87081
// sSun := true ;
87073: LD_ADDR_EXP 147
87077: PUSH
87078: LD_INT 1
87080: ST_TO_ADDR
// if p3 = 106 then
87081: LD_VAR 0 3
87085: PUSH
87086: LD_INT 106
87088: EQUAL
87089: IFFALSE 87099
// sTiger := true ;
87091: LD_ADDR_EXP 143
87095: PUSH
87096: LD_INT 1
87098: ST_TO_ADDR
// if p3 = 107 then
87099: LD_VAR 0 3
87103: PUSH
87104: LD_INT 107
87106: EQUAL
87107: IFFALSE 87117
// sBomb := true ;
87109: LD_ADDR_EXP 144
87113: PUSH
87114: LD_INT 1
87116: ST_TO_ADDR
// if p3 = 108 then
87117: LD_VAR 0 3
87121: PUSH
87122: LD_INT 108
87124: EQUAL
87125: IFFALSE 87135
// sWound := true ;
87127: LD_ADDR_EXP 152
87131: PUSH
87132: LD_INT 1
87134: ST_TO_ADDR
// if p3 = 109 then
87135: LD_VAR 0 3
87139: PUSH
87140: LD_INT 109
87142: EQUAL
87143: IFFALSE 87153
// sBetray := true ;
87145: LD_ADDR_EXP 156
87149: PUSH
87150: LD_INT 1
87152: ST_TO_ADDR
// if p3 = 110 then
87153: LD_VAR 0 3
87157: PUSH
87158: LD_INT 110
87160: EQUAL
87161: IFFALSE 87171
// sContamin := true ;
87163: LD_ADDR_EXP 157
87167: PUSH
87168: LD_INT 1
87170: ST_TO_ADDR
// if p3 = 111 then
87171: LD_VAR 0 3
87175: PUSH
87176: LD_INT 111
87178: EQUAL
87179: IFFALSE 87189
// sOil := true ;
87181: LD_ADDR_EXP 159
87185: PUSH
87186: LD_INT 1
87188: ST_TO_ADDR
// if p3 = 112 then
87189: LD_VAR 0 3
87193: PUSH
87194: LD_INT 112
87196: EQUAL
87197: IFFALSE 87207
// sStu := true ;
87199: LD_ADDR_EXP 163
87203: PUSH
87204: LD_INT 1
87206: ST_TO_ADDR
// if p3 = 113 then
87207: LD_VAR 0 3
87211: PUSH
87212: LD_INT 113
87214: EQUAL
87215: IFFALSE 87225
// sBazooka := true ;
87217: LD_ADDR_EXP 166
87221: PUSH
87222: LD_INT 1
87224: ST_TO_ADDR
// if p3 = 114 then
87225: LD_VAR 0 3
87229: PUSH
87230: LD_INT 114
87232: EQUAL
87233: IFFALSE 87243
// sMortar := true ;
87235: LD_ADDR_EXP 167
87239: PUSH
87240: LD_INT 1
87242: ST_TO_ADDR
// if p3 = 115 then
87243: LD_VAR 0 3
87247: PUSH
87248: LD_INT 115
87250: EQUAL
87251: IFFALSE 87261
// sRanger := true ;
87253: LD_ADDR_EXP 177
87257: PUSH
87258: LD_INT 1
87260: ST_TO_ADDR
// if p3 = 116 then
87261: LD_VAR 0 3
87265: PUSH
87266: LD_INT 116
87268: EQUAL
87269: IFFALSE 87279
// sComputer := true ;
87271: LD_ADDR_EXP 178
87275: PUSH
87276: LD_INT 1
87278: ST_TO_ADDR
// if p3 = 117 then
87279: LD_VAR 0 3
87283: PUSH
87284: LD_INT 117
87286: EQUAL
87287: IFFALSE 87297
// s30 := true ;
87289: LD_ADDR_EXP 179
87293: PUSH
87294: LD_INT 1
87296: ST_TO_ADDR
// if p3 = 118 then
87297: LD_VAR 0 3
87301: PUSH
87302: LD_INT 118
87304: EQUAL
87305: IFFALSE 87315
// s60 := true ;
87307: LD_ADDR_EXP 180
87311: PUSH
87312: LD_INT 1
87314: ST_TO_ADDR
// end ; if p2 = 101 then
87315: LD_VAR 0 2
87319: PUSH
87320: LD_INT 101
87322: EQUAL
87323: IFFALSE 87451
// begin case p3 of 1 :
87325: LD_VAR 0 3
87329: PUSH
87330: LD_INT 1
87332: DOUBLE
87333: EQUAL
87334: IFTRUE 87338
87336: GO 87345
87338: POP
// hHackUnlimitedResources ; 2 :
87339: CALL 99549 0 0
87343: GO 87451
87345: LD_INT 2
87347: DOUBLE
87348: EQUAL
87349: IFTRUE 87353
87351: GO 87360
87353: POP
// hHackSetLevel10 ; 3 :
87354: CALL 99682 0 0
87358: GO 87451
87360: LD_INT 3
87362: DOUBLE
87363: EQUAL
87364: IFTRUE 87368
87366: GO 87375
87368: POP
// hHackSetLevel10YourUnits ; 4 :
87369: CALL 99767 0 0
87373: GO 87451
87375: LD_INT 4
87377: DOUBLE
87378: EQUAL
87379: IFTRUE 87383
87381: GO 87390
87383: POP
// hHackInvincible ; 5 :
87384: CALL 100215 0 0
87388: GO 87451
87390: LD_INT 5
87392: DOUBLE
87393: EQUAL
87394: IFTRUE 87398
87396: GO 87405
87398: POP
// hHackInvisible ; 6 :
87399: CALL 100326 0 0
87403: GO 87451
87405: LD_INT 6
87407: DOUBLE
87408: EQUAL
87409: IFTRUE 87413
87411: GO 87420
87413: POP
// hHackChangeYourSide ; 7 :
87414: CALL 100383 0 0
87418: GO 87451
87420: LD_INT 7
87422: DOUBLE
87423: EQUAL
87424: IFTRUE 87428
87426: GO 87435
87428: POP
// hHackChangeUnitSide ; 8 :
87429: CALL 100425 0 0
87433: GO 87451
87435: LD_INT 8
87437: DOUBLE
87438: EQUAL
87439: IFTRUE 87443
87441: GO 87450
87443: POP
// hHackFog ; end ;
87444: CALL 100526 0 0
87448: GO 87451
87450: POP
// end ; end ;
87451: LD_VAR 0 7
87455: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
87456: GO 87458
87458: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
87459: LD_STRING initStreamRollete();
87461: PPUSH
87462: CALL_OW 559
// InitStreamMode ;
87466: CALL 87478 0 0
// DefineStreamItems ( false ) ;
87470: LD_INT 0
87472: PPUSH
87473: CALL 87942 0 1
// end ;
87477: END
// function InitStreamMode ; begin
87478: LD_INT 0
87480: PPUSH
// streamModeActive := false ;
87481: LD_ADDR_EXP 124
87485: PUSH
87486: LD_INT 0
87488: ST_TO_ADDR
// normalCounter := 36 ;
87489: LD_ADDR_EXP 125
87493: PUSH
87494: LD_INT 36
87496: ST_TO_ADDR
// hardcoreCounter := 18 ;
87497: LD_ADDR_EXP 126
87501: PUSH
87502: LD_INT 18
87504: ST_TO_ADDR
// sRocket := false ;
87505: LD_ADDR_EXP 129
87509: PUSH
87510: LD_INT 0
87512: ST_TO_ADDR
// sSpeed := false ;
87513: LD_ADDR_EXP 128
87517: PUSH
87518: LD_INT 0
87520: ST_TO_ADDR
// sEngine := false ;
87521: LD_ADDR_EXP 130
87525: PUSH
87526: LD_INT 0
87528: ST_TO_ADDR
// sSpec := false ;
87529: LD_ADDR_EXP 127
87533: PUSH
87534: LD_INT 0
87536: ST_TO_ADDR
// sLevel := false ;
87537: LD_ADDR_EXP 131
87541: PUSH
87542: LD_INT 0
87544: ST_TO_ADDR
// sArmoury := false ;
87545: LD_ADDR_EXP 132
87549: PUSH
87550: LD_INT 0
87552: ST_TO_ADDR
// sRadar := false ;
87553: LD_ADDR_EXP 133
87557: PUSH
87558: LD_INT 0
87560: ST_TO_ADDR
// sBunker := false ;
87561: LD_ADDR_EXP 134
87565: PUSH
87566: LD_INT 0
87568: ST_TO_ADDR
// sHack := false ;
87569: LD_ADDR_EXP 135
87573: PUSH
87574: LD_INT 0
87576: ST_TO_ADDR
// sFire := false ;
87577: LD_ADDR_EXP 136
87581: PUSH
87582: LD_INT 0
87584: ST_TO_ADDR
// sRefresh := false ;
87585: LD_ADDR_EXP 137
87589: PUSH
87590: LD_INT 0
87592: ST_TO_ADDR
// sExp := false ;
87593: LD_ADDR_EXP 138
87597: PUSH
87598: LD_INT 0
87600: ST_TO_ADDR
// sDepot := false ;
87601: LD_ADDR_EXP 139
87605: PUSH
87606: LD_INT 0
87608: ST_TO_ADDR
// sFlag := false ;
87609: LD_ADDR_EXP 140
87613: PUSH
87614: LD_INT 0
87616: ST_TO_ADDR
// sKamikadze := false ;
87617: LD_ADDR_EXP 148
87621: PUSH
87622: LD_INT 0
87624: ST_TO_ADDR
// sTroll := false ;
87625: LD_ADDR_EXP 149
87629: PUSH
87630: LD_INT 0
87632: ST_TO_ADDR
// sSlow := false ;
87633: LD_ADDR_EXP 150
87637: PUSH
87638: LD_INT 0
87640: ST_TO_ADDR
// sLack := false ;
87641: LD_ADDR_EXP 151
87645: PUSH
87646: LD_INT 0
87648: ST_TO_ADDR
// sTank := false ;
87649: LD_ADDR_EXP 153
87653: PUSH
87654: LD_INT 0
87656: ST_TO_ADDR
// sRemote := false ;
87657: LD_ADDR_EXP 154
87661: PUSH
87662: LD_INT 0
87664: ST_TO_ADDR
// sPowell := false ;
87665: LD_ADDR_EXP 155
87669: PUSH
87670: LD_INT 0
87672: ST_TO_ADDR
// sTeleport := false ;
87673: LD_ADDR_EXP 158
87677: PUSH
87678: LD_INT 0
87680: ST_TO_ADDR
// sOilTower := false ;
87681: LD_ADDR_EXP 160
87685: PUSH
87686: LD_INT 0
87688: ST_TO_ADDR
// sShovel := false ;
87689: LD_ADDR_EXP 161
87693: PUSH
87694: LD_INT 0
87696: ST_TO_ADDR
// sSheik := false ;
87697: LD_ADDR_EXP 162
87701: PUSH
87702: LD_INT 0
87704: ST_TO_ADDR
// sEarthquake := false ;
87705: LD_ADDR_EXP 164
87709: PUSH
87710: LD_INT 0
87712: ST_TO_ADDR
// sAI := false ;
87713: LD_ADDR_EXP 165
87717: PUSH
87718: LD_INT 0
87720: ST_TO_ADDR
// sCargo := false ;
87721: LD_ADDR_EXP 168
87725: PUSH
87726: LD_INT 0
87728: ST_TO_ADDR
// sDLaser := false ;
87729: LD_ADDR_EXP 169
87733: PUSH
87734: LD_INT 0
87736: ST_TO_ADDR
// sExchange := false ;
87737: LD_ADDR_EXP 170
87741: PUSH
87742: LD_INT 0
87744: ST_TO_ADDR
// sFac := false ;
87745: LD_ADDR_EXP 171
87749: PUSH
87750: LD_INT 0
87752: ST_TO_ADDR
// sPower := false ;
87753: LD_ADDR_EXP 172
87757: PUSH
87758: LD_INT 0
87760: ST_TO_ADDR
// sRandom := false ;
87761: LD_ADDR_EXP 173
87765: PUSH
87766: LD_INT 0
87768: ST_TO_ADDR
// sShield := false ;
87769: LD_ADDR_EXP 174
87773: PUSH
87774: LD_INT 0
87776: ST_TO_ADDR
// sTime := false ;
87777: LD_ADDR_EXP 175
87781: PUSH
87782: LD_INT 0
87784: ST_TO_ADDR
// sTools := false ;
87785: LD_ADDR_EXP 176
87789: PUSH
87790: LD_INT 0
87792: ST_TO_ADDR
// sSold := false ;
87793: LD_ADDR_EXP 141
87797: PUSH
87798: LD_INT 0
87800: ST_TO_ADDR
// sDiff := false ;
87801: LD_ADDR_EXP 142
87805: PUSH
87806: LD_INT 0
87808: ST_TO_ADDR
// sFog := false ;
87809: LD_ADDR_EXP 145
87813: PUSH
87814: LD_INT 0
87816: ST_TO_ADDR
// sReset := false ;
87817: LD_ADDR_EXP 146
87821: PUSH
87822: LD_INT 0
87824: ST_TO_ADDR
// sSun := false ;
87825: LD_ADDR_EXP 147
87829: PUSH
87830: LD_INT 0
87832: ST_TO_ADDR
// sTiger := false ;
87833: LD_ADDR_EXP 143
87837: PUSH
87838: LD_INT 0
87840: ST_TO_ADDR
// sBomb := false ;
87841: LD_ADDR_EXP 144
87845: PUSH
87846: LD_INT 0
87848: ST_TO_ADDR
// sWound := false ;
87849: LD_ADDR_EXP 152
87853: PUSH
87854: LD_INT 0
87856: ST_TO_ADDR
// sBetray := false ;
87857: LD_ADDR_EXP 156
87861: PUSH
87862: LD_INT 0
87864: ST_TO_ADDR
// sContamin := false ;
87865: LD_ADDR_EXP 157
87869: PUSH
87870: LD_INT 0
87872: ST_TO_ADDR
// sOil := false ;
87873: LD_ADDR_EXP 159
87877: PUSH
87878: LD_INT 0
87880: ST_TO_ADDR
// sStu := false ;
87881: LD_ADDR_EXP 163
87885: PUSH
87886: LD_INT 0
87888: ST_TO_ADDR
// sBazooka := false ;
87889: LD_ADDR_EXP 166
87893: PUSH
87894: LD_INT 0
87896: ST_TO_ADDR
// sMortar := false ;
87897: LD_ADDR_EXP 167
87901: PUSH
87902: LD_INT 0
87904: ST_TO_ADDR
// sRanger := false ;
87905: LD_ADDR_EXP 177
87909: PUSH
87910: LD_INT 0
87912: ST_TO_ADDR
// sComputer := false ;
87913: LD_ADDR_EXP 178
87917: PUSH
87918: LD_INT 0
87920: ST_TO_ADDR
// s30 := false ;
87921: LD_ADDR_EXP 179
87925: PUSH
87926: LD_INT 0
87928: ST_TO_ADDR
// s60 := false ;
87929: LD_ADDR_EXP 180
87933: PUSH
87934: LD_INT 0
87936: ST_TO_ADDR
// end ;
87937: LD_VAR 0 1
87941: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
87942: LD_INT 0
87944: PPUSH
87945: PPUSH
87946: PPUSH
87947: PPUSH
87948: PPUSH
87949: PPUSH
87950: PPUSH
// result := [ ] ;
87951: LD_ADDR_VAR 0 2
87955: PUSH
87956: EMPTY
87957: ST_TO_ADDR
// if campaign_id = 1 then
87958: LD_OWVAR 69
87962: PUSH
87963: LD_INT 1
87965: EQUAL
87966: IFFALSE 91132
// begin case mission_number of 1 :
87968: LD_OWVAR 70
87972: PUSH
87973: LD_INT 1
87975: DOUBLE
87976: EQUAL
87977: IFTRUE 87981
87979: GO 88057
87981: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
87982: LD_ADDR_VAR 0 2
87986: PUSH
87987: LD_INT 2
87989: PUSH
87990: LD_INT 4
87992: PUSH
87993: LD_INT 11
87995: PUSH
87996: LD_INT 12
87998: PUSH
87999: LD_INT 15
88001: PUSH
88002: LD_INT 16
88004: PUSH
88005: LD_INT 22
88007: PUSH
88008: LD_INT 23
88010: PUSH
88011: LD_INT 26
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: PUSH
88025: LD_INT 101
88027: PUSH
88028: LD_INT 102
88030: PUSH
88031: LD_INT 106
88033: PUSH
88034: LD_INT 116
88036: PUSH
88037: LD_INT 117
88039: PUSH
88040: LD_INT 118
88042: PUSH
88043: EMPTY
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: ST_TO_ADDR
88055: GO 91130
88057: LD_INT 2
88059: DOUBLE
88060: EQUAL
88061: IFTRUE 88065
88063: GO 88149
88065: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
88066: LD_ADDR_VAR 0 2
88070: PUSH
88071: LD_INT 2
88073: PUSH
88074: LD_INT 4
88076: PUSH
88077: LD_INT 11
88079: PUSH
88080: LD_INT 12
88082: PUSH
88083: LD_INT 15
88085: PUSH
88086: LD_INT 16
88088: PUSH
88089: LD_INT 22
88091: PUSH
88092: LD_INT 23
88094: PUSH
88095: LD_INT 26
88097: PUSH
88098: EMPTY
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: LIST
88108: PUSH
88109: LD_INT 101
88111: PUSH
88112: LD_INT 102
88114: PUSH
88115: LD_INT 105
88117: PUSH
88118: LD_INT 106
88120: PUSH
88121: LD_INT 108
88123: PUSH
88124: LD_INT 116
88126: PUSH
88127: LD_INT 117
88129: PUSH
88130: LD_INT 118
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: ST_TO_ADDR
88147: GO 91130
88149: LD_INT 3
88151: DOUBLE
88152: EQUAL
88153: IFTRUE 88157
88155: GO 88245
88157: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
88158: LD_ADDR_VAR 0 2
88162: PUSH
88163: LD_INT 2
88165: PUSH
88166: LD_INT 4
88168: PUSH
88169: LD_INT 5
88171: PUSH
88172: LD_INT 11
88174: PUSH
88175: LD_INT 12
88177: PUSH
88178: LD_INT 15
88180: PUSH
88181: LD_INT 16
88183: PUSH
88184: LD_INT 22
88186: PUSH
88187: LD_INT 26
88189: PUSH
88190: LD_INT 36
88192: PUSH
88193: EMPTY
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 101
88207: PUSH
88208: LD_INT 102
88210: PUSH
88211: LD_INT 105
88213: PUSH
88214: LD_INT 106
88216: PUSH
88217: LD_INT 108
88219: PUSH
88220: LD_INT 116
88222: PUSH
88223: LD_INT 117
88225: PUSH
88226: LD_INT 118
88228: PUSH
88229: EMPTY
88230: LIST
88231: LIST
88232: LIST
88233: LIST
88234: LIST
88235: LIST
88236: LIST
88237: LIST
88238: PUSH
88239: EMPTY
88240: LIST
88241: LIST
88242: ST_TO_ADDR
88243: GO 91130
88245: LD_INT 4
88247: DOUBLE
88248: EQUAL
88249: IFTRUE 88253
88251: GO 88349
88253: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
88254: LD_ADDR_VAR 0 2
88258: PUSH
88259: LD_INT 2
88261: PUSH
88262: LD_INT 4
88264: PUSH
88265: LD_INT 5
88267: PUSH
88268: LD_INT 8
88270: PUSH
88271: LD_INT 11
88273: PUSH
88274: LD_INT 12
88276: PUSH
88277: LD_INT 15
88279: PUSH
88280: LD_INT 16
88282: PUSH
88283: LD_INT 22
88285: PUSH
88286: LD_INT 23
88288: PUSH
88289: LD_INT 26
88291: PUSH
88292: LD_INT 36
88294: PUSH
88295: EMPTY
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: LIST
88308: PUSH
88309: LD_INT 101
88311: PUSH
88312: LD_INT 102
88314: PUSH
88315: LD_INT 105
88317: PUSH
88318: LD_INT 106
88320: PUSH
88321: LD_INT 108
88323: PUSH
88324: LD_INT 116
88326: PUSH
88327: LD_INT 117
88329: PUSH
88330: LD_INT 118
88332: PUSH
88333: EMPTY
88334: LIST
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: LIST
88340: LIST
88341: LIST
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: ST_TO_ADDR
88347: GO 91130
88349: LD_INT 5
88351: DOUBLE
88352: EQUAL
88353: IFTRUE 88357
88355: GO 88469
88357: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
88358: LD_ADDR_VAR 0 2
88362: PUSH
88363: LD_INT 2
88365: PUSH
88366: LD_INT 4
88368: PUSH
88369: LD_INT 5
88371: PUSH
88372: LD_INT 6
88374: PUSH
88375: LD_INT 8
88377: PUSH
88378: LD_INT 11
88380: PUSH
88381: LD_INT 12
88383: PUSH
88384: LD_INT 15
88386: PUSH
88387: LD_INT 16
88389: PUSH
88390: LD_INT 22
88392: PUSH
88393: LD_INT 23
88395: PUSH
88396: LD_INT 25
88398: PUSH
88399: LD_INT 26
88401: PUSH
88402: LD_INT 36
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: LIST
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 101
88423: PUSH
88424: LD_INT 102
88426: PUSH
88427: LD_INT 105
88429: PUSH
88430: LD_INT 106
88432: PUSH
88433: LD_INT 108
88435: PUSH
88436: LD_INT 109
88438: PUSH
88439: LD_INT 112
88441: PUSH
88442: LD_INT 116
88444: PUSH
88445: LD_INT 117
88447: PUSH
88448: LD_INT 118
88450: PUSH
88451: EMPTY
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: PUSH
88463: EMPTY
88464: LIST
88465: LIST
88466: ST_TO_ADDR
88467: GO 91130
88469: LD_INT 6
88471: DOUBLE
88472: EQUAL
88473: IFTRUE 88477
88475: GO 88609
88477: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
88478: LD_ADDR_VAR 0 2
88482: PUSH
88483: LD_INT 2
88485: PUSH
88486: LD_INT 4
88488: PUSH
88489: LD_INT 5
88491: PUSH
88492: LD_INT 6
88494: PUSH
88495: LD_INT 8
88497: PUSH
88498: LD_INT 11
88500: PUSH
88501: LD_INT 12
88503: PUSH
88504: LD_INT 15
88506: PUSH
88507: LD_INT 16
88509: PUSH
88510: LD_INT 20
88512: PUSH
88513: LD_INT 21
88515: PUSH
88516: LD_INT 22
88518: PUSH
88519: LD_INT 23
88521: PUSH
88522: LD_INT 25
88524: PUSH
88525: LD_INT 26
88527: PUSH
88528: LD_INT 30
88530: PUSH
88531: LD_INT 31
88533: PUSH
88534: LD_INT 32
88536: PUSH
88537: LD_INT 36
88539: PUSH
88540: EMPTY
88541: LIST
88542: LIST
88543: LIST
88544: LIST
88545: LIST
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: PUSH
88561: LD_INT 101
88563: PUSH
88564: LD_INT 102
88566: PUSH
88567: LD_INT 105
88569: PUSH
88570: LD_INT 106
88572: PUSH
88573: LD_INT 108
88575: PUSH
88576: LD_INT 109
88578: PUSH
88579: LD_INT 112
88581: PUSH
88582: LD_INT 116
88584: PUSH
88585: LD_INT 117
88587: PUSH
88588: LD_INT 118
88590: PUSH
88591: EMPTY
88592: LIST
88593: LIST
88594: LIST
88595: LIST
88596: LIST
88597: LIST
88598: LIST
88599: LIST
88600: LIST
88601: LIST
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: ST_TO_ADDR
88607: GO 91130
88609: LD_INT 7
88611: DOUBLE
88612: EQUAL
88613: IFTRUE 88617
88615: GO 88729
88617: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
88618: LD_ADDR_VAR 0 2
88622: PUSH
88623: LD_INT 2
88625: PUSH
88626: LD_INT 4
88628: PUSH
88629: LD_INT 5
88631: PUSH
88632: LD_INT 7
88634: PUSH
88635: LD_INT 11
88637: PUSH
88638: LD_INT 12
88640: PUSH
88641: LD_INT 15
88643: PUSH
88644: LD_INT 16
88646: PUSH
88647: LD_INT 20
88649: PUSH
88650: LD_INT 21
88652: PUSH
88653: LD_INT 22
88655: PUSH
88656: LD_INT 23
88658: PUSH
88659: LD_INT 25
88661: PUSH
88662: LD_INT 26
88664: PUSH
88665: EMPTY
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: PUSH
88681: LD_INT 101
88683: PUSH
88684: LD_INT 102
88686: PUSH
88687: LD_INT 103
88689: PUSH
88690: LD_INT 105
88692: PUSH
88693: LD_INT 106
88695: PUSH
88696: LD_INT 108
88698: PUSH
88699: LD_INT 112
88701: PUSH
88702: LD_INT 116
88704: PUSH
88705: LD_INT 117
88707: PUSH
88708: LD_INT 118
88710: PUSH
88711: EMPTY
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: ST_TO_ADDR
88727: GO 91130
88729: LD_INT 8
88731: DOUBLE
88732: EQUAL
88733: IFTRUE 88737
88735: GO 88877
88737: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
88738: LD_ADDR_VAR 0 2
88742: PUSH
88743: LD_INT 2
88745: PUSH
88746: LD_INT 4
88748: PUSH
88749: LD_INT 5
88751: PUSH
88752: LD_INT 6
88754: PUSH
88755: LD_INT 7
88757: PUSH
88758: LD_INT 8
88760: PUSH
88761: LD_INT 11
88763: PUSH
88764: LD_INT 12
88766: PUSH
88767: LD_INT 15
88769: PUSH
88770: LD_INT 16
88772: PUSH
88773: LD_INT 20
88775: PUSH
88776: LD_INT 21
88778: PUSH
88779: LD_INT 22
88781: PUSH
88782: LD_INT 23
88784: PUSH
88785: LD_INT 25
88787: PUSH
88788: LD_INT 26
88790: PUSH
88791: LD_INT 30
88793: PUSH
88794: LD_INT 31
88796: PUSH
88797: LD_INT 32
88799: PUSH
88800: LD_INT 36
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: LIST
88816: LIST
88817: LIST
88818: LIST
88819: LIST
88820: LIST
88821: LIST
88822: LIST
88823: LIST
88824: PUSH
88825: LD_INT 101
88827: PUSH
88828: LD_INT 102
88830: PUSH
88831: LD_INT 103
88833: PUSH
88834: LD_INT 105
88836: PUSH
88837: LD_INT 106
88839: PUSH
88840: LD_INT 108
88842: PUSH
88843: LD_INT 109
88845: PUSH
88846: LD_INT 112
88848: PUSH
88849: LD_INT 116
88851: PUSH
88852: LD_INT 117
88854: PUSH
88855: LD_INT 118
88857: PUSH
88858: EMPTY
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: PUSH
88871: EMPTY
88872: LIST
88873: LIST
88874: ST_TO_ADDR
88875: GO 91130
88877: LD_INT 9
88879: DOUBLE
88880: EQUAL
88881: IFTRUE 88885
88883: GO 89033
88885: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
88886: LD_ADDR_VAR 0 2
88890: PUSH
88891: LD_INT 2
88893: PUSH
88894: LD_INT 4
88896: PUSH
88897: LD_INT 5
88899: PUSH
88900: LD_INT 6
88902: PUSH
88903: LD_INT 7
88905: PUSH
88906: LD_INT 8
88908: PUSH
88909: LD_INT 11
88911: PUSH
88912: LD_INT 12
88914: PUSH
88915: LD_INT 15
88917: PUSH
88918: LD_INT 16
88920: PUSH
88921: LD_INT 20
88923: PUSH
88924: LD_INT 21
88926: PUSH
88927: LD_INT 22
88929: PUSH
88930: LD_INT 23
88932: PUSH
88933: LD_INT 25
88935: PUSH
88936: LD_INT 26
88938: PUSH
88939: LD_INT 28
88941: PUSH
88942: LD_INT 30
88944: PUSH
88945: LD_INT 31
88947: PUSH
88948: LD_INT 32
88950: PUSH
88951: LD_INT 36
88953: PUSH
88954: EMPTY
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: LIST
88967: LIST
88968: LIST
88969: LIST
88970: LIST
88971: LIST
88972: LIST
88973: LIST
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 101
88979: PUSH
88980: LD_INT 102
88982: PUSH
88983: LD_INT 103
88985: PUSH
88986: LD_INT 105
88988: PUSH
88989: LD_INT 106
88991: PUSH
88992: LD_INT 108
88994: PUSH
88995: LD_INT 109
88997: PUSH
88998: LD_INT 112
89000: PUSH
89001: LD_INT 114
89003: PUSH
89004: LD_INT 116
89006: PUSH
89007: LD_INT 117
89009: PUSH
89010: LD_INT 118
89012: PUSH
89013: EMPTY
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: PUSH
89027: EMPTY
89028: LIST
89029: LIST
89030: ST_TO_ADDR
89031: GO 91130
89033: LD_INT 10
89035: DOUBLE
89036: EQUAL
89037: IFTRUE 89041
89039: GO 89237
89041: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
89042: LD_ADDR_VAR 0 2
89046: PUSH
89047: LD_INT 2
89049: PUSH
89050: LD_INT 4
89052: PUSH
89053: LD_INT 5
89055: PUSH
89056: LD_INT 6
89058: PUSH
89059: LD_INT 7
89061: PUSH
89062: LD_INT 8
89064: PUSH
89065: LD_INT 9
89067: PUSH
89068: LD_INT 10
89070: PUSH
89071: LD_INT 11
89073: PUSH
89074: LD_INT 12
89076: PUSH
89077: LD_INT 13
89079: PUSH
89080: LD_INT 14
89082: PUSH
89083: LD_INT 15
89085: PUSH
89086: LD_INT 16
89088: PUSH
89089: LD_INT 17
89091: PUSH
89092: LD_INT 18
89094: PUSH
89095: LD_INT 19
89097: PUSH
89098: LD_INT 20
89100: PUSH
89101: LD_INT 21
89103: PUSH
89104: LD_INT 22
89106: PUSH
89107: LD_INT 23
89109: PUSH
89110: LD_INT 24
89112: PUSH
89113: LD_INT 25
89115: PUSH
89116: LD_INT 26
89118: PUSH
89119: LD_INT 28
89121: PUSH
89122: LD_INT 30
89124: PUSH
89125: LD_INT 31
89127: PUSH
89128: LD_INT 32
89130: PUSH
89131: LD_INT 36
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: LIST
89146: LIST
89147: LIST
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: PUSH
89165: LD_INT 101
89167: PUSH
89168: LD_INT 102
89170: PUSH
89171: LD_INT 103
89173: PUSH
89174: LD_INT 104
89176: PUSH
89177: LD_INT 105
89179: PUSH
89180: LD_INT 106
89182: PUSH
89183: LD_INT 107
89185: PUSH
89186: LD_INT 108
89188: PUSH
89189: LD_INT 109
89191: PUSH
89192: LD_INT 110
89194: PUSH
89195: LD_INT 111
89197: PUSH
89198: LD_INT 112
89200: PUSH
89201: LD_INT 114
89203: PUSH
89204: LD_INT 116
89206: PUSH
89207: LD_INT 117
89209: PUSH
89210: LD_INT 118
89212: PUSH
89213: EMPTY
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: ST_TO_ADDR
89235: GO 91130
89237: LD_INT 11
89239: DOUBLE
89240: EQUAL
89241: IFTRUE 89245
89243: GO 89449
89245: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
89246: LD_ADDR_VAR 0 2
89250: PUSH
89251: LD_INT 2
89253: PUSH
89254: LD_INT 3
89256: PUSH
89257: LD_INT 4
89259: PUSH
89260: LD_INT 5
89262: PUSH
89263: LD_INT 6
89265: PUSH
89266: LD_INT 7
89268: PUSH
89269: LD_INT 8
89271: PUSH
89272: LD_INT 9
89274: PUSH
89275: LD_INT 10
89277: PUSH
89278: LD_INT 11
89280: PUSH
89281: LD_INT 12
89283: PUSH
89284: LD_INT 13
89286: PUSH
89287: LD_INT 14
89289: PUSH
89290: LD_INT 15
89292: PUSH
89293: LD_INT 16
89295: PUSH
89296: LD_INT 17
89298: PUSH
89299: LD_INT 18
89301: PUSH
89302: LD_INT 19
89304: PUSH
89305: LD_INT 20
89307: PUSH
89308: LD_INT 21
89310: PUSH
89311: LD_INT 22
89313: PUSH
89314: LD_INT 23
89316: PUSH
89317: LD_INT 24
89319: PUSH
89320: LD_INT 25
89322: PUSH
89323: LD_INT 26
89325: PUSH
89326: LD_INT 28
89328: PUSH
89329: LD_INT 30
89331: PUSH
89332: LD_INT 31
89334: PUSH
89335: LD_INT 32
89337: PUSH
89338: LD_INT 34
89340: PUSH
89341: LD_INT 36
89343: PUSH
89344: EMPTY
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: LIST
89372: LIST
89373: LIST
89374: LIST
89375: LIST
89376: PUSH
89377: LD_INT 101
89379: PUSH
89380: LD_INT 102
89382: PUSH
89383: LD_INT 103
89385: PUSH
89386: LD_INT 104
89388: PUSH
89389: LD_INT 105
89391: PUSH
89392: LD_INT 106
89394: PUSH
89395: LD_INT 107
89397: PUSH
89398: LD_INT 108
89400: PUSH
89401: LD_INT 109
89403: PUSH
89404: LD_INT 110
89406: PUSH
89407: LD_INT 111
89409: PUSH
89410: LD_INT 112
89412: PUSH
89413: LD_INT 114
89415: PUSH
89416: LD_INT 116
89418: PUSH
89419: LD_INT 117
89421: PUSH
89422: LD_INT 118
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: LIST
89433: LIST
89434: LIST
89435: LIST
89436: LIST
89437: LIST
89438: LIST
89439: LIST
89440: LIST
89441: LIST
89442: PUSH
89443: EMPTY
89444: LIST
89445: LIST
89446: ST_TO_ADDR
89447: GO 91130
89449: LD_INT 12
89451: DOUBLE
89452: EQUAL
89453: IFTRUE 89457
89455: GO 89677
89457: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
89458: LD_ADDR_VAR 0 2
89462: PUSH
89463: LD_INT 1
89465: PUSH
89466: LD_INT 2
89468: PUSH
89469: LD_INT 3
89471: PUSH
89472: LD_INT 4
89474: PUSH
89475: LD_INT 5
89477: PUSH
89478: LD_INT 6
89480: PUSH
89481: LD_INT 7
89483: PUSH
89484: LD_INT 8
89486: PUSH
89487: LD_INT 9
89489: PUSH
89490: LD_INT 10
89492: PUSH
89493: LD_INT 11
89495: PUSH
89496: LD_INT 12
89498: PUSH
89499: LD_INT 13
89501: PUSH
89502: LD_INT 14
89504: PUSH
89505: LD_INT 15
89507: PUSH
89508: LD_INT 16
89510: PUSH
89511: LD_INT 17
89513: PUSH
89514: LD_INT 18
89516: PUSH
89517: LD_INT 19
89519: PUSH
89520: LD_INT 20
89522: PUSH
89523: LD_INT 21
89525: PUSH
89526: LD_INT 22
89528: PUSH
89529: LD_INT 23
89531: PUSH
89532: LD_INT 24
89534: PUSH
89535: LD_INT 25
89537: PUSH
89538: LD_INT 26
89540: PUSH
89541: LD_INT 27
89543: PUSH
89544: LD_INT 28
89546: PUSH
89547: LD_INT 30
89549: PUSH
89550: LD_INT 31
89552: PUSH
89553: LD_INT 32
89555: PUSH
89556: LD_INT 33
89558: PUSH
89559: LD_INT 34
89561: PUSH
89562: LD_INT 36
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: LIST
89585: LIST
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: LIST
89595: LIST
89596: LIST
89597: LIST
89598: LIST
89599: LIST
89600: PUSH
89601: LD_INT 101
89603: PUSH
89604: LD_INT 102
89606: PUSH
89607: LD_INT 103
89609: PUSH
89610: LD_INT 104
89612: PUSH
89613: LD_INT 105
89615: PUSH
89616: LD_INT 106
89618: PUSH
89619: LD_INT 107
89621: PUSH
89622: LD_INT 108
89624: PUSH
89625: LD_INT 109
89627: PUSH
89628: LD_INT 110
89630: PUSH
89631: LD_INT 111
89633: PUSH
89634: LD_INT 112
89636: PUSH
89637: LD_INT 113
89639: PUSH
89640: LD_INT 114
89642: PUSH
89643: LD_INT 116
89645: PUSH
89646: LD_INT 117
89648: PUSH
89649: LD_INT 118
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: LIST
89656: LIST
89657: LIST
89658: LIST
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: ST_TO_ADDR
89675: GO 91130
89677: LD_INT 13
89679: DOUBLE
89680: EQUAL
89681: IFTRUE 89685
89683: GO 89893
89685: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
89686: LD_ADDR_VAR 0 2
89690: PUSH
89691: LD_INT 1
89693: PUSH
89694: LD_INT 2
89696: PUSH
89697: LD_INT 3
89699: PUSH
89700: LD_INT 4
89702: PUSH
89703: LD_INT 5
89705: PUSH
89706: LD_INT 8
89708: PUSH
89709: LD_INT 9
89711: PUSH
89712: LD_INT 10
89714: PUSH
89715: LD_INT 11
89717: PUSH
89718: LD_INT 12
89720: PUSH
89721: LD_INT 14
89723: PUSH
89724: LD_INT 15
89726: PUSH
89727: LD_INT 16
89729: PUSH
89730: LD_INT 17
89732: PUSH
89733: LD_INT 18
89735: PUSH
89736: LD_INT 19
89738: PUSH
89739: LD_INT 20
89741: PUSH
89742: LD_INT 21
89744: PUSH
89745: LD_INT 22
89747: PUSH
89748: LD_INT 23
89750: PUSH
89751: LD_INT 24
89753: PUSH
89754: LD_INT 25
89756: PUSH
89757: LD_INT 26
89759: PUSH
89760: LD_INT 27
89762: PUSH
89763: LD_INT 28
89765: PUSH
89766: LD_INT 30
89768: PUSH
89769: LD_INT 31
89771: PUSH
89772: LD_INT 32
89774: PUSH
89775: LD_INT 33
89777: PUSH
89778: LD_INT 34
89780: PUSH
89781: LD_INT 36
89783: PUSH
89784: EMPTY
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: LIST
89809: LIST
89810: LIST
89811: LIST
89812: LIST
89813: LIST
89814: LIST
89815: LIST
89816: PUSH
89817: LD_INT 101
89819: PUSH
89820: LD_INT 102
89822: PUSH
89823: LD_INT 103
89825: PUSH
89826: LD_INT 104
89828: PUSH
89829: LD_INT 105
89831: PUSH
89832: LD_INT 106
89834: PUSH
89835: LD_INT 107
89837: PUSH
89838: LD_INT 108
89840: PUSH
89841: LD_INT 109
89843: PUSH
89844: LD_INT 110
89846: PUSH
89847: LD_INT 111
89849: PUSH
89850: LD_INT 112
89852: PUSH
89853: LD_INT 113
89855: PUSH
89856: LD_INT 114
89858: PUSH
89859: LD_INT 116
89861: PUSH
89862: LD_INT 117
89864: PUSH
89865: LD_INT 118
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: LIST
89879: LIST
89880: LIST
89881: LIST
89882: LIST
89883: LIST
89884: LIST
89885: LIST
89886: PUSH
89887: EMPTY
89888: LIST
89889: LIST
89890: ST_TO_ADDR
89891: GO 91130
89893: LD_INT 14
89895: DOUBLE
89896: EQUAL
89897: IFTRUE 89901
89899: GO 90125
89901: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
89902: LD_ADDR_VAR 0 2
89906: PUSH
89907: LD_INT 1
89909: PUSH
89910: LD_INT 2
89912: PUSH
89913: LD_INT 3
89915: PUSH
89916: LD_INT 4
89918: PUSH
89919: LD_INT 5
89921: PUSH
89922: LD_INT 6
89924: PUSH
89925: LD_INT 7
89927: PUSH
89928: LD_INT 8
89930: PUSH
89931: LD_INT 9
89933: PUSH
89934: LD_INT 10
89936: PUSH
89937: LD_INT 11
89939: PUSH
89940: LD_INT 12
89942: PUSH
89943: LD_INT 13
89945: PUSH
89946: LD_INT 14
89948: PUSH
89949: LD_INT 15
89951: PUSH
89952: LD_INT 16
89954: PUSH
89955: LD_INT 17
89957: PUSH
89958: LD_INT 18
89960: PUSH
89961: LD_INT 19
89963: PUSH
89964: LD_INT 20
89966: PUSH
89967: LD_INT 21
89969: PUSH
89970: LD_INT 22
89972: PUSH
89973: LD_INT 23
89975: PUSH
89976: LD_INT 24
89978: PUSH
89979: LD_INT 25
89981: PUSH
89982: LD_INT 26
89984: PUSH
89985: LD_INT 27
89987: PUSH
89988: LD_INT 28
89990: PUSH
89991: LD_INT 29
89993: PUSH
89994: LD_INT 30
89996: PUSH
89997: LD_INT 31
89999: PUSH
90000: LD_INT 32
90002: PUSH
90003: LD_INT 33
90005: PUSH
90006: LD_INT 34
90008: PUSH
90009: LD_INT 36
90011: PUSH
90012: EMPTY
90013: LIST
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: LIST
90019: LIST
90020: LIST
90021: LIST
90022: LIST
90023: LIST
90024: LIST
90025: LIST
90026: LIST
90027: LIST
90028: LIST
90029: LIST
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: PUSH
90049: LD_INT 101
90051: PUSH
90052: LD_INT 102
90054: PUSH
90055: LD_INT 103
90057: PUSH
90058: LD_INT 104
90060: PUSH
90061: LD_INT 105
90063: PUSH
90064: LD_INT 106
90066: PUSH
90067: LD_INT 107
90069: PUSH
90070: LD_INT 108
90072: PUSH
90073: LD_INT 109
90075: PUSH
90076: LD_INT 110
90078: PUSH
90079: LD_INT 111
90081: PUSH
90082: LD_INT 112
90084: PUSH
90085: LD_INT 113
90087: PUSH
90088: LD_INT 114
90090: PUSH
90091: LD_INT 116
90093: PUSH
90094: LD_INT 117
90096: PUSH
90097: LD_INT 118
90099: PUSH
90100: EMPTY
90101: LIST
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: PUSH
90119: EMPTY
90120: LIST
90121: LIST
90122: ST_TO_ADDR
90123: GO 91130
90125: LD_INT 15
90127: DOUBLE
90128: EQUAL
90129: IFTRUE 90133
90131: GO 90357
90133: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
90134: LD_ADDR_VAR 0 2
90138: PUSH
90139: LD_INT 1
90141: PUSH
90142: LD_INT 2
90144: PUSH
90145: LD_INT 3
90147: PUSH
90148: LD_INT 4
90150: PUSH
90151: LD_INT 5
90153: PUSH
90154: LD_INT 6
90156: PUSH
90157: LD_INT 7
90159: PUSH
90160: LD_INT 8
90162: PUSH
90163: LD_INT 9
90165: PUSH
90166: LD_INT 10
90168: PUSH
90169: LD_INT 11
90171: PUSH
90172: LD_INT 12
90174: PUSH
90175: LD_INT 13
90177: PUSH
90178: LD_INT 14
90180: PUSH
90181: LD_INT 15
90183: PUSH
90184: LD_INT 16
90186: PUSH
90187: LD_INT 17
90189: PUSH
90190: LD_INT 18
90192: PUSH
90193: LD_INT 19
90195: PUSH
90196: LD_INT 20
90198: PUSH
90199: LD_INT 21
90201: PUSH
90202: LD_INT 22
90204: PUSH
90205: LD_INT 23
90207: PUSH
90208: LD_INT 24
90210: PUSH
90211: LD_INT 25
90213: PUSH
90214: LD_INT 26
90216: PUSH
90217: LD_INT 27
90219: PUSH
90220: LD_INT 28
90222: PUSH
90223: LD_INT 29
90225: PUSH
90226: LD_INT 30
90228: PUSH
90229: LD_INT 31
90231: PUSH
90232: LD_INT 32
90234: PUSH
90235: LD_INT 33
90237: PUSH
90238: LD_INT 34
90240: PUSH
90241: LD_INT 36
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: LIST
90268: LIST
90269: LIST
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: LIST
90278: LIST
90279: LIST
90280: PUSH
90281: LD_INT 101
90283: PUSH
90284: LD_INT 102
90286: PUSH
90287: LD_INT 103
90289: PUSH
90290: LD_INT 104
90292: PUSH
90293: LD_INT 105
90295: PUSH
90296: LD_INT 106
90298: PUSH
90299: LD_INT 107
90301: PUSH
90302: LD_INT 108
90304: PUSH
90305: LD_INT 109
90307: PUSH
90308: LD_INT 110
90310: PUSH
90311: LD_INT 111
90313: PUSH
90314: LD_INT 112
90316: PUSH
90317: LD_INT 113
90319: PUSH
90320: LD_INT 114
90322: PUSH
90323: LD_INT 116
90325: PUSH
90326: LD_INT 117
90328: PUSH
90329: LD_INT 118
90331: PUSH
90332: EMPTY
90333: LIST
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: ST_TO_ADDR
90355: GO 91130
90357: LD_INT 16
90359: DOUBLE
90360: EQUAL
90361: IFTRUE 90365
90363: GO 90501
90365: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
90366: LD_ADDR_VAR 0 2
90370: PUSH
90371: LD_INT 2
90373: PUSH
90374: LD_INT 4
90376: PUSH
90377: LD_INT 5
90379: PUSH
90380: LD_INT 7
90382: PUSH
90383: LD_INT 11
90385: PUSH
90386: LD_INT 12
90388: PUSH
90389: LD_INT 15
90391: PUSH
90392: LD_INT 16
90394: PUSH
90395: LD_INT 20
90397: PUSH
90398: LD_INT 21
90400: PUSH
90401: LD_INT 22
90403: PUSH
90404: LD_INT 23
90406: PUSH
90407: LD_INT 25
90409: PUSH
90410: LD_INT 26
90412: PUSH
90413: LD_INT 30
90415: PUSH
90416: LD_INT 31
90418: PUSH
90419: LD_INT 32
90421: PUSH
90422: LD_INT 33
90424: PUSH
90425: LD_INT 34
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: LIST
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: LIST
90445: LIST
90446: LIST
90447: LIST
90448: PUSH
90449: LD_INT 101
90451: PUSH
90452: LD_INT 102
90454: PUSH
90455: LD_INT 103
90457: PUSH
90458: LD_INT 106
90460: PUSH
90461: LD_INT 108
90463: PUSH
90464: LD_INT 112
90466: PUSH
90467: LD_INT 113
90469: PUSH
90470: LD_INT 114
90472: PUSH
90473: LD_INT 116
90475: PUSH
90476: LD_INT 117
90478: PUSH
90479: LD_INT 118
90481: PUSH
90482: EMPTY
90483: LIST
90484: LIST
90485: LIST
90486: LIST
90487: LIST
90488: LIST
90489: LIST
90490: LIST
90491: LIST
90492: LIST
90493: LIST
90494: PUSH
90495: EMPTY
90496: LIST
90497: LIST
90498: ST_TO_ADDR
90499: GO 91130
90501: LD_INT 17
90503: DOUBLE
90504: EQUAL
90505: IFTRUE 90509
90507: GO 90733
90509: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
90510: LD_ADDR_VAR 0 2
90514: PUSH
90515: LD_INT 1
90517: PUSH
90518: LD_INT 2
90520: PUSH
90521: LD_INT 3
90523: PUSH
90524: LD_INT 4
90526: PUSH
90527: LD_INT 5
90529: PUSH
90530: LD_INT 6
90532: PUSH
90533: LD_INT 7
90535: PUSH
90536: LD_INT 8
90538: PUSH
90539: LD_INT 9
90541: PUSH
90542: LD_INT 10
90544: PUSH
90545: LD_INT 11
90547: PUSH
90548: LD_INT 12
90550: PUSH
90551: LD_INT 13
90553: PUSH
90554: LD_INT 14
90556: PUSH
90557: LD_INT 15
90559: PUSH
90560: LD_INT 16
90562: PUSH
90563: LD_INT 17
90565: PUSH
90566: LD_INT 18
90568: PUSH
90569: LD_INT 19
90571: PUSH
90572: LD_INT 20
90574: PUSH
90575: LD_INT 21
90577: PUSH
90578: LD_INT 22
90580: PUSH
90581: LD_INT 23
90583: PUSH
90584: LD_INT 24
90586: PUSH
90587: LD_INT 25
90589: PUSH
90590: LD_INT 26
90592: PUSH
90593: LD_INT 27
90595: PUSH
90596: LD_INT 28
90598: PUSH
90599: LD_INT 29
90601: PUSH
90602: LD_INT 30
90604: PUSH
90605: LD_INT 31
90607: PUSH
90608: LD_INT 32
90610: PUSH
90611: LD_INT 33
90613: PUSH
90614: LD_INT 34
90616: PUSH
90617: LD_INT 36
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: PUSH
90657: LD_INT 101
90659: PUSH
90660: LD_INT 102
90662: PUSH
90663: LD_INT 103
90665: PUSH
90666: LD_INT 104
90668: PUSH
90669: LD_INT 105
90671: PUSH
90672: LD_INT 106
90674: PUSH
90675: LD_INT 107
90677: PUSH
90678: LD_INT 108
90680: PUSH
90681: LD_INT 109
90683: PUSH
90684: LD_INT 110
90686: PUSH
90687: LD_INT 111
90689: PUSH
90690: LD_INT 112
90692: PUSH
90693: LD_INT 113
90695: PUSH
90696: LD_INT 114
90698: PUSH
90699: LD_INT 116
90701: PUSH
90702: LD_INT 117
90704: PUSH
90705: LD_INT 118
90707: PUSH
90708: EMPTY
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: LIST
90716: LIST
90717: LIST
90718: LIST
90719: LIST
90720: LIST
90721: LIST
90722: LIST
90723: LIST
90724: LIST
90725: LIST
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: ST_TO_ADDR
90731: GO 91130
90733: LD_INT 18
90735: DOUBLE
90736: EQUAL
90737: IFTRUE 90741
90739: GO 90889
90741: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
90742: LD_ADDR_VAR 0 2
90746: PUSH
90747: LD_INT 2
90749: PUSH
90750: LD_INT 4
90752: PUSH
90753: LD_INT 5
90755: PUSH
90756: LD_INT 7
90758: PUSH
90759: LD_INT 11
90761: PUSH
90762: LD_INT 12
90764: PUSH
90765: LD_INT 15
90767: PUSH
90768: LD_INT 16
90770: PUSH
90771: LD_INT 20
90773: PUSH
90774: LD_INT 21
90776: PUSH
90777: LD_INT 22
90779: PUSH
90780: LD_INT 23
90782: PUSH
90783: LD_INT 25
90785: PUSH
90786: LD_INT 26
90788: PUSH
90789: LD_INT 30
90791: PUSH
90792: LD_INT 31
90794: PUSH
90795: LD_INT 32
90797: PUSH
90798: LD_INT 33
90800: PUSH
90801: LD_INT 34
90803: PUSH
90804: LD_INT 35
90806: PUSH
90807: LD_INT 36
90809: PUSH
90810: EMPTY
90811: LIST
90812: LIST
90813: LIST
90814: LIST
90815: LIST
90816: LIST
90817: LIST
90818: LIST
90819: LIST
90820: LIST
90821: LIST
90822: LIST
90823: LIST
90824: LIST
90825: LIST
90826: LIST
90827: LIST
90828: LIST
90829: LIST
90830: LIST
90831: LIST
90832: PUSH
90833: LD_INT 101
90835: PUSH
90836: LD_INT 102
90838: PUSH
90839: LD_INT 103
90841: PUSH
90842: LD_INT 106
90844: PUSH
90845: LD_INT 108
90847: PUSH
90848: LD_INT 112
90850: PUSH
90851: LD_INT 113
90853: PUSH
90854: LD_INT 114
90856: PUSH
90857: LD_INT 115
90859: PUSH
90860: LD_INT 116
90862: PUSH
90863: LD_INT 117
90865: PUSH
90866: LD_INT 118
90868: PUSH
90869: EMPTY
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: PUSH
90883: EMPTY
90884: LIST
90885: LIST
90886: ST_TO_ADDR
90887: GO 91130
90889: LD_INT 19
90891: DOUBLE
90892: EQUAL
90893: IFTRUE 90897
90895: GO 91129
90897: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
90898: LD_ADDR_VAR 0 2
90902: PUSH
90903: LD_INT 1
90905: PUSH
90906: LD_INT 2
90908: PUSH
90909: LD_INT 3
90911: PUSH
90912: LD_INT 4
90914: PUSH
90915: LD_INT 5
90917: PUSH
90918: LD_INT 6
90920: PUSH
90921: LD_INT 7
90923: PUSH
90924: LD_INT 8
90926: PUSH
90927: LD_INT 9
90929: PUSH
90930: LD_INT 10
90932: PUSH
90933: LD_INT 11
90935: PUSH
90936: LD_INT 12
90938: PUSH
90939: LD_INT 13
90941: PUSH
90942: LD_INT 14
90944: PUSH
90945: LD_INT 15
90947: PUSH
90948: LD_INT 16
90950: PUSH
90951: LD_INT 17
90953: PUSH
90954: LD_INT 18
90956: PUSH
90957: LD_INT 19
90959: PUSH
90960: LD_INT 20
90962: PUSH
90963: LD_INT 21
90965: PUSH
90966: LD_INT 22
90968: PUSH
90969: LD_INT 23
90971: PUSH
90972: LD_INT 24
90974: PUSH
90975: LD_INT 25
90977: PUSH
90978: LD_INT 26
90980: PUSH
90981: LD_INT 27
90983: PUSH
90984: LD_INT 28
90986: PUSH
90987: LD_INT 29
90989: PUSH
90990: LD_INT 30
90992: PUSH
90993: LD_INT 31
90995: PUSH
90996: LD_INT 32
90998: PUSH
90999: LD_INT 33
91001: PUSH
91002: LD_INT 34
91004: PUSH
91005: LD_INT 35
91007: PUSH
91008: LD_INT 36
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: LIST
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: LIST
91037: LIST
91038: LIST
91039: LIST
91040: LIST
91041: LIST
91042: LIST
91043: LIST
91044: LIST
91045: LIST
91046: LIST
91047: LIST
91048: PUSH
91049: LD_INT 101
91051: PUSH
91052: LD_INT 102
91054: PUSH
91055: LD_INT 103
91057: PUSH
91058: LD_INT 104
91060: PUSH
91061: LD_INT 105
91063: PUSH
91064: LD_INT 106
91066: PUSH
91067: LD_INT 107
91069: PUSH
91070: LD_INT 108
91072: PUSH
91073: LD_INT 109
91075: PUSH
91076: LD_INT 110
91078: PUSH
91079: LD_INT 111
91081: PUSH
91082: LD_INT 112
91084: PUSH
91085: LD_INT 113
91087: PUSH
91088: LD_INT 114
91090: PUSH
91091: LD_INT 115
91093: PUSH
91094: LD_INT 116
91096: PUSH
91097: LD_INT 117
91099: PUSH
91100: LD_INT 118
91102: PUSH
91103: EMPTY
91104: LIST
91105: LIST
91106: LIST
91107: LIST
91108: LIST
91109: LIST
91110: LIST
91111: LIST
91112: LIST
91113: LIST
91114: LIST
91115: LIST
91116: LIST
91117: LIST
91118: LIST
91119: LIST
91120: LIST
91121: LIST
91122: PUSH
91123: EMPTY
91124: LIST
91125: LIST
91126: ST_TO_ADDR
91127: GO 91130
91129: POP
// end else
91130: GO 91361
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
91132: LD_ADDR_VAR 0 2
91136: PUSH
91137: LD_INT 1
91139: PUSH
91140: LD_INT 2
91142: PUSH
91143: LD_INT 3
91145: PUSH
91146: LD_INT 4
91148: PUSH
91149: LD_INT 5
91151: PUSH
91152: LD_INT 6
91154: PUSH
91155: LD_INT 7
91157: PUSH
91158: LD_INT 8
91160: PUSH
91161: LD_INT 9
91163: PUSH
91164: LD_INT 10
91166: PUSH
91167: LD_INT 11
91169: PUSH
91170: LD_INT 12
91172: PUSH
91173: LD_INT 13
91175: PUSH
91176: LD_INT 14
91178: PUSH
91179: LD_INT 15
91181: PUSH
91182: LD_INT 16
91184: PUSH
91185: LD_INT 17
91187: PUSH
91188: LD_INT 18
91190: PUSH
91191: LD_INT 19
91193: PUSH
91194: LD_INT 20
91196: PUSH
91197: LD_INT 21
91199: PUSH
91200: LD_INT 22
91202: PUSH
91203: LD_INT 23
91205: PUSH
91206: LD_INT 24
91208: PUSH
91209: LD_INT 25
91211: PUSH
91212: LD_INT 26
91214: PUSH
91215: LD_INT 27
91217: PUSH
91218: LD_INT 28
91220: PUSH
91221: LD_INT 29
91223: PUSH
91224: LD_INT 30
91226: PUSH
91227: LD_INT 31
91229: PUSH
91230: LD_INT 32
91232: PUSH
91233: LD_INT 33
91235: PUSH
91236: LD_INT 34
91238: PUSH
91239: LD_INT 35
91241: PUSH
91242: LD_INT 36
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: PUSH
91283: LD_INT 101
91285: PUSH
91286: LD_INT 102
91288: PUSH
91289: LD_INT 103
91291: PUSH
91292: LD_INT 104
91294: PUSH
91295: LD_INT 105
91297: PUSH
91298: LD_INT 106
91300: PUSH
91301: LD_INT 107
91303: PUSH
91304: LD_INT 108
91306: PUSH
91307: LD_INT 109
91309: PUSH
91310: LD_INT 110
91312: PUSH
91313: LD_INT 111
91315: PUSH
91316: LD_INT 112
91318: PUSH
91319: LD_INT 113
91321: PUSH
91322: LD_INT 114
91324: PUSH
91325: LD_INT 115
91327: PUSH
91328: LD_INT 116
91330: PUSH
91331: LD_INT 117
91333: PUSH
91334: LD_INT 118
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: LIST
91350: LIST
91351: LIST
91352: LIST
91353: LIST
91354: LIST
91355: LIST
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: ST_TO_ADDR
// if result then
91361: LD_VAR 0 2
91365: IFFALSE 92151
// begin normal :=  ;
91367: LD_ADDR_VAR 0 5
91371: PUSH
91372: LD_STRING 
91374: ST_TO_ADDR
// hardcore :=  ;
91375: LD_ADDR_VAR 0 6
91379: PUSH
91380: LD_STRING 
91382: ST_TO_ADDR
// active :=  ;
91383: LD_ADDR_VAR 0 7
91387: PUSH
91388: LD_STRING 
91390: ST_TO_ADDR
// for i = 1 to normalCounter do
91391: LD_ADDR_VAR 0 8
91395: PUSH
91396: DOUBLE
91397: LD_INT 1
91399: DEC
91400: ST_TO_ADDR
91401: LD_EXP 125
91405: PUSH
91406: FOR_TO
91407: IFFALSE 91508
// begin tmp := 0 ;
91409: LD_ADDR_VAR 0 3
91413: PUSH
91414: LD_STRING 0
91416: ST_TO_ADDR
// if result [ 1 ] then
91417: LD_VAR 0 2
91421: PUSH
91422: LD_INT 1
91424: ARRAY
91425: IFFALSE 91490
// if result [ 1 ] [ 1 ] = i then
91427: LD_VAR 0 2
91431: PUSH
91432: LD_INT 1
91434: ARRAY
91435: PUSH
91436: LD_INT 1
91438: ARRAY
91439: PUSH
91440: LD_VAR 0 8
91444: EQUAL
91445: IFFALSE 91490
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
91447: LD_ADDR_VAR 0 2
91451: PUSH
91452: LD_VAR 0 2
91456: PPUSH
91457: LD_INT 1
91459: PPUSH
91460: LD_VAR 0 2
91464: PUSH
91465: LD_INT 1
91467: ARRAY
91468: PPUSH
91469: LD_INT 1
91471: PPUSH
91472: CALL_OW 3
91476: PPUSH
91477: CALL_OW 1
91481: ST_TO_ADDR
// tmp := 1 ;
91482: LD_ADDR_VAR 0 3
91486: PUSH
91487: LD_STRING 1
91489: ST_TO_ADDR
// end ; normal := normal & tmp ;
91490: LD_ADDR_VAR 0 5
91494: PUSH
91495: LD_VAR 0 5
91499: PUSH
91500: LD_VAR 0 3
91504: STR
91505: ST_TO_ADDR
// end ;
91506: GO 91406
91508: POP
91509: POP
// for i = 1 to hardcoreCounter do
91510: LD_ADDR_VAR 0 8
91514: PUSH
91515: DOUBLE
91516: LD_INT 1
91518: DEC
91519: ST_TO_ADDR
91520: LD_EXP 126
91524: PUSH
91525: FOR_TO
91526: IFFALSE 91631
// begin tmp := 0 ;
91528: LD_ADDR_VAR 0 3
91532: PUSH
91533: LD_STRING 0
91535: ST_TO_ADDR
// if result [ 2 ] then
91536: LD_VAR 0 2
91540: PUSH
91541: LD_INT 2
91543: ARRAY
91544: IFFALSE 91613
// if result [ 2 ] [ 1 ] = 100 + i then
91546: LD_VAR 0 2
91550: PUSH
91551: LD_INT 2
91553: ARRAY
91554: PUSH
91555: LD_INT 1
91557: ARRAY
91558: PUSH
91559: LD_INT 100
91561: PUSH
91562: LD_VAR 0 8
91566: PLUS
91567: EQUAL
91568: IFFALSE 91613
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
91570: LD_ADDR_VAR 0 2
91574: PUSH
91575: LD_VAR 0 2
91579: PPUSH
91580: LD_INT 2
91582: PPUSH
91583: LD_VAR 0 2
91587: PUSH
91588: LD_INT 2
91590: ARRAY
91591: PPUSH
91592: LD_INT 1
91594: PPUSH
91595: CALL_OW 3
91599: PPUSH
91600: CALL_OW 1
91604: ST_TO_ADDR
// tmp := 1 ;
91605: LD_ADDR_VAR 0 3
91609: PUSH
91610: LD_STRING 1
91612: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
91613: LD_ADDR_VAR 0 6
91617: PUSH
91618: LD_VAR 0 6
91622: PUSH
91623: LD_VAR 0 3
91627: STR
91628: ST_TO_ADDR
// end ;
91629: GO 91525
91631: POP
91632: POP
// if isGameLoad then
91633: LD_VAR 0 1
91637: IFFALSE 92112
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
91639: LD_ADDR_VAR 0 4
91643: PUSH
91644: LD_EXP 129
91648: PUSH
91649: LD_EXP 128
91653: PUSH
91654: LD_EXP 130
91658: PUSH
91659: LD_EXP 127
91663: PUSH
91664: LD_EXP 131
91668: PUSH
91669: LD_EXP 132
91673: PUSH
91674: LD_EXP 133
91678: PUSH
91679: LD_EXP 134
91683: PUSH
91684: LD_EXP 135
91688: PUSH
91689: LD_EXP 136
91693: PUSH
91694: LD_EXP 137
91698: PUSH
91699: LD_EXP 138
91703: PUSH
91704: LD_EXP 139
91708: PUSH
91709: LD_EXP 140
91713: PUSH
91714: LD_EXP 148
91718: PUSH
91719: LD_EXP 149
91723: PUSH
91724: LD_EXP 150
91728: PUSH
91729: LD_EXP 151
91733: PUSH
91734: LD_EXP 153
91738: PUSH
91739: LD_EXP 154
91743: PUSH
91744: LD_EXP 155
91748: PUSH
91749: LD_EXP 158
91753: PUSH
91754: LD_EXP 160
91758: PUSH
91759: LD_EXP 161
91763: PUSH
91764: LD_EXP 162
91768: PUSH
91769: LD_EXP 164
91773: PUSH
91774: LD_EXP 165
91778: PUSH
91779: LD_EXP 168
91783: PUSH
91784: LD_EXP 169
91788: PUSH
91789: LD_EXP 170
91793: PUSH
91794: LD_EXP 171
91798: PUSH
91799: LD_EXP 172
91803: PUSH
91804: LD_EXP 173
91808: PUSH
91809: LD_EXP 174
91813: PUSH
91814: LD_EXP 175
91818: PUSH
91819: LD_EXP 176
91823: PUSH
91824: LD_EXP 141
91828: PUSH
91829: LD_EXP 142
91833: PUSH
91834: LD_EXP 145
91838: PUSH
91839: LD_EXP 146
91843: PUSH
91844: LD_EXP 147
91848: PUSH
91849: LD_EXP 143
91853: PUSH
91854: LD_EXP 144
91858: PUSH
91859: LD_EXP 152
91863: PUSH
91864: LD_EXP 156
91868: PUSH
91869: LD_EXP 157
91873: PUSH
91874: LD_EXP 159
91878: PUSH
91879: LD_EXP 163
91883: PUSH
91884: LD_EXP 166
91888: PUSH
91889: LD_EXP 167
91893: PUSH
91894: LD_EXP 177
91898: PUSH
91899: LD_EXP 178
91903: PUSH
91904: LD_EXP 179
91908: PUSH
91909: LD_EXP 180
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: LIST
91918: LIST
91919: LIST
91920: LIST
91921: LIST
91922: LIST
91923: LIST
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: LIST
91936: LIST
91937: LIST
91938: LIST
91939: LIST
91940: LIST
91941: LIST
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: LIST
91951: LIST
91952: LIST
91953: LIST
91954: LIST
91955: LIST
91956: LIST
91957: LIST
91958: LIST
91959: LIST
91960: LIST
91961: LIST
91962: LIST
91963: LIST
91964: LIST
91965: LIST
91966: LIST
91967: LIST
91968: LIST
91969: ST_TO_ADDR
// tmp :=  ;
91970: LD_ADDR_VAR 0 3
91974: PUSH
91975: LD_STRING 
91977: ST_TO_ADDR
// for i = 1 to normalCounter do
91978: LD_ADDR_VAR 0 8
91982: PUSH
91983: DOUBLE
91984: LD_INT 1
91986: DEC
91987: ST_TO_ADDR
91988: LD_EXP 125
91992: PUSH
91993: FOR_TO
91994: IFFALSE 92030
// begin if flags [ i ] then
91996: LD_VAR 0 4
92000: PUSH
92001: LD_VAR 0 8
92005: ARRAY
92006: IFFALSE 92028
// tmp := tmp & i & ; ;
92008: LD_ADDR_VAR 0 3
92012: PUSH
92013: LD_VAR 0 3
92017: PUSH
92018: LD_VAR 0 8
92022: STR
92023: PUSH
92024: LD_STRING ;
92026: STR
92027: ST_TO_ADDR
// end ;
92028: GO 91993
92030: POP
92031: POP
// for i = 1 to hardcoreCounter do
92032: LD_ADDR_VAR 0 8
92036: PUSH
92037: DOUBLE
92038: LD_INT 1
92040: DEC
92041: ST_TO_ADDR
92042: LD_EXP 126
92046: PUSH
92047: FOR_TO
92048: IFFALSE 92094
// begin if flags [ normalCounter + i ] then
92050: LD_VAR 0 4
92054: PUSH
92055: LD_EXP 125
92059: PUSH
92060: LD_VAR 0 8
92064: PLUS
92065: ARRAY
92066: IFFALSE 92092
// tmp := tmp & ( 100 + i ) & ; ;
92068: LD_ADDR_VAR 0 3
92072: PUSH
92073: LD_VAR 0 3
92077: PUSH
92078: LD_INT 100
92080: PUSH
92081: LD_VAR 0 8
92085: PLUS
92086: STR
92087: PUSH
92088: LD_STRING ;
92090: STR
92091: ST_TO_ADDR
// end ;
92092: GO 92047
92094: POP
92095: POP
// if tmp then
92096: LD_VAR 0 3
92100: IFFALSE 92112
// active := tmp ;
92102: LD_ADDR_VAR 0 7
92106: PUSH
92107: LD_VAR 0 3
92111: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
92112: LD_STRING getStreamItemsFromMission("
92114: PUSH
92115: LD_VAR 0 5
92119: STR
92120: PUSH
92121: LD_STRING ","
92123: STR
92124: PUSH
92125: LD_VAR 0 6
92129: STR
92130: PUSH
92131: LD_STRING ","
92133: STR
92134: PUSH
92135: LD_VAR 0 7
92139: STR
92140: PUSH
92141: LD_STRING ")
92143: STR
92144: PPUSH
92145: CALL_OW 559
// end else
92149: GO 92158
// ToLua ( getStreamItemsFromMission("","","") ) ;
92151: LD_STRING getStreamItemsFromMission("","","")
92153: PPUSH
92154: CALL_OW 559
// end ;
92158: LD_VAR 0 2
92162: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92163: LD_EXP 124
92167: PUSH
92168: LD_EXP 129
92172: AND
92173: IFFALSE 92297
92175: GO 92177
92177: DISABLE
92178: LD_INT 0
92180: PPUSH
92181: PPUSH
// begin enable ;
92182: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92183: LD_ADDR_VAR 0 2
92187: PUSH
92188: LD_INT 22
92190: PUSH
92191: LD_OWVAR 2
92195: PUSH
92196: EMPTY
92197: LIST
92198: LIST
92199: PUSH
92200: LD_INT 2
92202: PUSH
92203: LD_INT 34
92205: PUSH
92206: LD_INT 7
92208: PUSH
92209: EMPTY
92210: LIST
92211: LIST
92212: PUSH
92213: LD_INT 34
92215: PUSH
92216: LD_INT 45
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: LD_INT 34
92225: PUSH
92226: LD_INT 28
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 34
92235: PUSH
92236: LD_INT 47
92238: PUSH
92239: EMPTY
92240: LIST
92241: LIST
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: PUSH
92250: EMPTY
92251: LIST
92252: LIST
92253: PPUSH
92254: CALL_OW 69
92258: ST_TO_ADDR
// if not tmp then
92259: LD_VAR 0 2
92263: NOT
92264: IFFALSE 92268
// exit ;
92266: GO 92297
// for i in tmp do
92268: LD_ADDR_VAR 0 1
92272: PUSH
92273: LD_VAR 0 2
92277: PUSH
92278: FOR_IN
92279: IFFALSE 92295
// begin SetLives ( i , 0 ) ;
92281: LD_VAR 0 1
92285: PPUSH
92286: LD_INT 0
92288: PPUSH
92289: CALL_OW 234
// end ;
92293: GO 92278
92295: POP
92296: POP
// end ;
92297: PPOPN 2
92299: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
92300: LD_EXP 124
92304: PUSH
92305: LD_EXP 130
92309: AND
92310: IFFALSE 92394
92312: GO 92314
92314: DISABLE
92315: LD_INT 0
92317: PPUSH
92318: PPUSH
// begin enable ;
92319: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92320: LD_ADDR_VAR 0 2
92324: PUSH
92325: LD_INT 22
92327: PUSH
92328: LD_OWVAR 2
92332: PUSH
92333: EMPTY
92334: LIST
92335: LIST
92336: PUSH
92337: LD_INT 32
92339: PUSH
92340: LD_INT 3
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: PUSH
92347: EMPTY
92348: LIST
92349: LIST
92350: PPUSH
92351: CALL_OW 69
92355: ST_TO_ADDR
// if not tmp then
92356: LD_VAR 0 2
92360: NOT
92361: IFFALSE 92365
// exit ;
92363: GO 92394
// for i in tmp do
92365: LD_ADDR_VAR 0 1
92369: PUSH
92370: LD_VAR 0 2
92374: PUSH
92375: FOR_IN
92376: IFFALSE 92392
// begin SetLives ( i , 0 ) ;
92378: LD_VAR 0 1
92382: PPUSH
92383: LD_INT 0
92385: PPUSH
92386: CALL_OW 234
// end ;
92390: GO 92375
92392: POP
92393: POP
// end ;
92394: PPOPN 2
92396: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
92397: LD_EXP 124
92401: PUSH
92402: LD_EXP 127
92406: AND
92407: IFFALSE 92500
92409: GO 92411
92411: DISABLE
92412: LD_INT 0
92414: PPUSH
// begin enable ;
92415: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92416: LD_ADDR_VAR 0 1
92420: PUSH
92421: LD_INT 22
92423: PUSH
92424: LD_OWVAR 2
92428: PUSH
92429: EMPTY
92430: LIST
92431: LIST
92432: PUSH
92433: LD_INT 2
92435: PUSH
92436: LD_INT 25
92438: PUSH
92439: LD_INT 5
92441: PUSH
92442: EMPTY
92443: LIST
92444: LIST
92445: PUSH
92446: LD_INT 25
92448: PUSH
92449: LD_INT 9
92451: PUSH
92452: EMPTY
92453: LIST
92454: LIST
92455: PUSH
92456: LD_INT 25
92458: PUSH
92459: LD_INT 8
92461: PUSH
92462: EMPTY
92463: LIST
92464: LIST
92465: PUSH
92466: EMPTY
92467: LIST
92468: LIST
92469: LIST
92470: LIST
92471: PUSH
92472: EMPTY
92473: LIST
92474: LIST
92475: PPUSH
92476: CALL_OW 69
92480: PUSH
92481: FOR_IN
92482: IFFALSE 92498
// begin SetClass ( i , 1 ) ;
92484: LD_VAR 0 1
92488: PPUSH
92489: LD_INT 1
92491: PPUSH
92492: CALL_OW 336
// end ;
92496: GO 92481
92498: POP
92499: POP
// end ;
92500: PPOPN 1
92502: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92503: LD_EXP 124
92507: PUSH
92508: LD_EXP 128
92512: AND
92513: PUSH
92514: LD_OWVAR 65
92518: PUSH
92519: LD_INT 7
92521: LESS
92522: AND
92523: IFFALSE 92537
92525: GO 92527
92527: DISABLE
// begin enable ;
92528: ENABLE
// game_speed := 7 ;
92529: LD_ADDR_OWVAR 65
92533: PUSH
92534: LD_INT 7
92536: ST_TO_ADDR
// end ;
92537: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92538: LD_EXP 124
92542: PUSH
92543: LD_EXP 131
92547: AND
92548: IFFALSE 92750
92550: GO 92552
92552: DISABLE
92553: LD_INT 0
92555: PPUSH
92556: PPUSH
92557: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92558: LD_ADDR_VAR 0 3
92562: PUSH
92563: LD_INT 81
92565: PUSH
92566: LD_OWVAR 2
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: LD_INT 21
92577: PUSH
92578: LD_INT 1
92580: PUSH
92581: EMPTY
92582: LIST
92583: LIST
92584: PUSH
92585: EMPTY
92586: LIST
92587: LIST
92588: PPUSH
92589: CALL_OW 69
92593: ST_TO_ADDR
// if not tmp then
92594: LD_VAR 0 3
92598: NOT
92599: IFFALSE 92603
// exit ;
92601: GO 92750
// if tmp > 5 then
92603: LD_VAR 0 3
92607: PUSH
92608: LD_INT 5
92610: GREATER
92611: IFFALSE 92623
// k := 5 else
92613: LD_ADDR_VAR 0 2
92617: PUSH
92618: LD_INT 5
92620: ST_TO_ADDR
92621: GO 92633
// k := tmp ;
92623: LD_ADDR_VAR 0 2
92627: PUSH
92628: LD_VAR 0 3
92632: ST_TO_ADDR
// for i := 1 to k do
92633: LD_ADDR_VAR 0 1
92637: PUSH
92638: DOUBLE
92639: LD_INT 1
92641: DEC
92642: ST_TO_ADDR
92643: LD_VAR 0 2
92647: PUSH
92648: FOR_TO
92649: IFFALSE 92748
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92651: LD_VAR 0 3
92655: PUSH
92656: LD_VAR 0 1
92660: ARRAY
92661: PPUSH
92662: LD_VAR 0 1
92666: PUSH
92667: LD_INT 4
92669: MOD
92670: PUSH
92671: LD_INT 1
92673: PLUS
92674: PPUSH
92675: CALL_OW 259
92679: PUSH
92680: LD_INT 10
92682: LESS
92683: IFFALSE 92746
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92685: LD_VAR 0 3
92689: PUSH
92690: LD_VAR 0 1
92694: ARRAY
92695: PPUSH
92696: LD_VAR 0 1
92700: PUSH
92701: LD_INT 4
92703: MOD
92704: PUSH
92705: LD_INT 1
92707: PLUS
92708: PPUSH
92709: LD_VAR 0 3
92713: PUSH
92714: LD_VAR 0 1
92718: ARRAY
92719: PPUSH
92720: LD_VAR 0 1
92724: PUSH
92725: LD_INT 4
92727: MOD
92728: PUSH
92729: LD_INT 1
92731: PLUS
92732: PPUSH
92733: CALL_OW 259
92737: PUSH
92738: LD_INT 1
92740: PLUS
92741: PPUSH
92742: CALL_OW 237
92746: GO 92648
92748: POP
92749: POP
// end ;
92750: PPOPN 3
92752: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92753: LD_EXP 124
92757: PUSH
92758: LD_EXP 132
92762: AND
92763: IFFALSE 92783
92765: GO 92767
92767: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92768: LD_INT 4
92770: PPUSH
92771: LD_OWVAR 2
92775: PPUSH
92776: LD_INT 0
92778: PPUSH
92779: CALL_OW 324
92783: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92784: LD_EXP 124
92788: PUSH
92789: LD_EXP 161
92793: AND
92794: IFFALSE 92814
92796: GO 92798
92798: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92799: LD_INT 19
92801: PPUSH
92802: LD_OWVAR 2
92806: PPUSH
92807: LD_INT 0
92809: PPUSH
92810: CALL_OW 324
92814: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92815: LD_EXP 124
92819: PUSH
92820: LD_EXP 133
92824: AND
92825: IFFALSE 92927
92827: GO 92829
92829: DISABLE
92830: LD_INT 0
92832: PPUSH
92833: PPUSH
// begin enable ;
92834: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92835: LD_ADDR_VAR 0 2
92839: PUSH
92840: LD_INT 22
92842: PUSH
92843: LD_OWVAR 2
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: PUSH
92852: LD_INT 2
92854: PUSH
92855: LD_INT 34
92857: PUSH
92858: LD_INT 11
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PUSH
92865: LD_INT 34
92867: PUSH
92868: LD_INT 30
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: EMPTY
92876: LIST
92877: LIST
92878: LIST
92879: PUSH
92880: EMPTY
92881: LIST
92882: LIST
92883: PPUSH
92884: CALL_OW 69
92888: ST_TO_ADDR
// if not tmp then
92889: LD_VAR 0 2
92893: NOT
92894: IFFALSE 92898
// exit ;
92896: GO 92927
// for i in tmp do
92898: LD_ADDR_VAR 0 1
92902: PUSH
92903: LD_VAR 0 2
92907: PUSH
92908: FOR_IN
92909: IFFALSE 92925
// begin SetLives ( i , 0 ) ;
92911: LD_VAR 0 1
92915: PPUSH
92916: LD_INT 0
92918: PPUSH
92919: CALL_OW 234
// end ;
92923: GO 92908
92925: POP
92926: POP
// end ;
92927: PPOPN 2
92929: END
// every 0 0$1 trigger StreamModeActive and sBunker do
92930: LD_EXP 124
92934: PUSH
92935: LD_EXP 134
92939: AND
92940: IFFALSE 92960
92942: GO 92944
92944: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
92945: LD_INT 32
92947: PPUSH
92948: LD_OWVAR 2
92952: PPUSH
92953: LD_INT 0
92955: PPUSH
92956: CALL_OW 324
92960: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
92961: LD_EXP 124
92965: PUSH
92966: LD_EXP 135
92970: AND
92971: IFFALSE 93152
92973: GO 92975
92975: DISABLE
92976: LD_INT 0
92978: PPUSH
92979: PPUSH
92980: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
92981: LD_ADDR_VAR 0 2
92985: PUSH
92986: LD_INT 22
92988: PUSH
92989: LD_OWVAR 2
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: PUSH
92998: LD_INT 33
93000: PUSH
93001: LD_INT 3
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PPUSH
93012: CALL_OW 69
93016: ST_TO_ADDR
// if not tmp then
93017: LD_VAR 0 2
93021: NOT
93022: IFFALSE 93026
// exit ;
93024: GO 93152
// side := 0 ;
93026: LD_ADDR_VAR 0 3
93030: PUSH
93031: LD_INT 0
93033: ST_TO_ADDR
// for i := 1 to 8 do
93034: LD_ADDR_VAR 0 1
93038: PUSH
93039: DOUBLE
93040: LD_INT 1
93042: DEC
93043: ST_TO_ADDR
93044: LD_INT 8
93046: PUSH
93047: FOR_TO
93048: IFFALSE 93096
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93050: LD_OWVAR 2
93054: PUSH
93055: LD_VAR 0 1
93059: NONEQUAL
93060: PUSH
93061: LD_OWVAR 2
93065: PPUSH
93066: LD_VAR 0 1
93070: PPUSH
93071: CALL_OW 81
93075: PUSH
93076: LD_INT 2
93078: EQUAL
93079: AND
93080: IFFALSE 93094
// begin side := i ;
93082: LD_ADDR_VAR 0 3
93086: PUSH
93087: LD_VAR 0 1
93091: ST_TO_ADDR
// break ;
93092: GO 93096
// end ;
93094: GO 93047
93096: POP
93097: POP
// if not side then
93098: LD_VAR 0 3
93102: NOT
93103: IFFALSE 93107
// exit ;
93105: GO 93152
// for i := 1 to tmp do
93107: LD_ADDR_VAR 0 1
93111: PUSH
93112: DOUBLE
93113: LD_INT 1
93115: DEC
93116: ST_TO_ADDR
93117: LD_VAR 0 2
93121: PUSH
93122: FOR_TO
93123: IFFALSE 93150
// if Prob ( 60 ) then
93125: LD_INT 60
93127: PPUSH
93128: CALL_OW 13
93132: IFFALSE 93148
// SetSide ( i , side ) ;
93134: LD_VAR 0 1
93138: PPUSH
93139: LD_VAR 0 3
93143: PPUSH
93144: CALL_OW 235
93148: GO 93122
93150: POP
93151: POP
// end ;
93152: PPOPN 3
93154: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93155: LD_EXP 124
93159: PUSH
93160: LD_EXP 137
93164: AND
93165: IFFALSE 93284
93167: GO 93169
93169: DISABLE
93170: LD_INT 0
93172: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93173: LD_ADDR_VAR 0 1
93177: PUSH
93178: LD_INT 22
93180: PUSH
93181: LD_OWVAR 2
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 21
93192: PUSH
93193: LD_INT 1
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: PUSH
93200: LD_INT 3
93202: PUSH
93203: LD_INT 23
93205: PUSH
93206: LD_INT 0
93208: PUSH
93209: EMPTY
93210: LIST
93211: LIST
93212: PUSH
93213: EMPTY
93214: LIST
93215: LIST
93216: PUSH
93217: EMPTY
93218: LIST
93219: LIST
93220: LIST
93221: PPUSH
93222: CALL_OW 69
93226: PUSH
93227: FOR_IN
93228: IFFALSE 93282
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
93230: LD_VAR 0 1
93234: PPUSH
93235: CALL_OW 257
93239: PUSH
93240: LD_INT 1
93242: PUSH
93243: LD_INT 2
93245: PUSH
93246: LD_INT 3
93248: PUSH
93249: LD_INT 4
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: IN
93258: IFFALSE 93280
// SetClass ( un , rand ( 1 , 4 ) ) ;
93260: LD_VAR 0 1
93264: PPUSH
93265: LD_INT 1
93267: PPUSH
93268: LD_INT 4
93270: PPUSH
93271: CALL_OW 12
93275: PPUSH
93276: CALL_OW 336
93280: GO 93227
93282: POP
93283: POP
// end ;
93284: PPOPN 1
93286: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
93287: LD_EXP 124
93291: PUSH
93292: LD_EXP 136
93296: AND
93297: IFFALSE 93376
93299: GO 93301
93301: DISABLE
93302: LD_INT 0
93304: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93305: LD_ADDR_VAR 0 1
93309: PUSH
93310: LD_INT 22
93312: PUSH
93313: LD_OWVAR 2
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: PUSH
93322: LD_INT 21
93324: PUSH
93325: LD_INT 3
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: PUSH
93332: EMPTY
93333: LIST
93334: LIST
93335: PPUSH
93336: CALL_OW 69
93340: ST_TO_ADDR
// if not tmp then
93341: LD_VAR 0 1
93345: NOT
93346: IFFALSE 93350
// exit ;
93348: GO 93376
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93350: LD_VAR 0 1
93354: PUSH
93355: LD_INT 1
93357: PPUSH
93358: LD_VAR 0 1
93362: PPUSH
93363: CALL_OW 12
93367: ARRAY
93368: PPUSH
93369: LD_INT 100
93371: PPUSH
93372: CALL_OW 234
// end ;
93376: PPOPN 1
93378: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93379: LD_EXP 124
93383: PUSH
93384: LD_EXP 138
93388: AND
93389: IFFALSE 93487
93391: GO 93393
93393: DISABLE
93394: LD_INT 0
93396: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93397: LD_ADDR_VAR 0 1
93401: PUSH
93402: LD_INT 22
93404: PUSH
93405: LD_OWVAR 2
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: PUSH
93414: LD_INT 21
93416: PUSH
93417: LD_INT 1
93419: PUSH
93420: EMPTY
93421: LIST
93422: LIST
93423: PUSH
93424: EMPTY
93425: LIST
93426: LIST
93427: PPUSH
93428: CALL_OW 69
93432: ST_TO_ADDR
// if not tmp then
93433: LD_VAR 0 1
93437: NOT
93438: IFFALSE 93442
// exit ;
93440: GO 93487
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93442: LD_VAR 0 1
93446: PUSH
93447: LD_INT 1
93449: PPUSH
93450: LD_VAR 0 1
93454: PPUSH
93455: CALL_OW 12
93459: ARRAY
93460: PPUSH
93461: LD_INT 1
93463: PPUSH
93464: LD_INT 4
93466: PPUSH
93467: CALL_OW 12
93471: PPUSH
93472: LD_INT 3000
93474: PPUSH
93475: LD_INT 9000
93477: PPUSH
93478: CALL_OW 12
93482: PPUSH
93483: CALL_OW 492
// end ;
93487: PPOPN 1
93489: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93490: LD_EXP 124
93494: PUSH
93495: LD_EXP 139
93499: AND
93500: IFFALSE 93520
93502: GO 93504
93504: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93505: LD_INT 1
93507: PPUSH
93508: LD_OWVAR 2
93512: PPUSH
93513: LD_INT 0
93515: PPUSH
93516: CALL_OW 324
93520: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93521: LD_EXP 124
93525: PUSH
93526: LD_EXP 140
93530: AND
93531: IFFALSE 93614
93533: GO 93535
93535: DISABLE
93536: LD_INT 0
93538: PPUSH
93539: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93540: LD_ADDR_VAR 0 2
93544: PUSH
93545: LD_INT 22
93547: PUSH
93548: LD_OWVAR 2
93552: PUSH
93553: EMPTY
93554: LIST
93555: LIST
93556: PUSH
93557: LD_INT 21
93559: PUSH
93560: LD_INT 3
93562: PUSH
93563: EMPTY
93564: LIST
93565: LIST
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: PPUSH
93571: CALL_OW 69
93575: ST_TO_ADDR
// if not tmp then
93576: LD_VAR 0 2
93580: NOT
93581: IFFALSE 93585
// exit ;
93583: GO 93614
// for i in tmp do
93585: LD_ADDR_VAR 0 1
93589: PUSH
93590: LD_VAR 0 2
93594: PUSH
93595: FOR_IN
93596: IFFALSE 93612
// SetBLevel ( i , 10 ) ;
93598: LD_VAR 0 1
93602: PPUSH
93603: LD_INT 10
93605: PPUSH
93606: CALL_OW 241
93610: GO 93595
93612: POP
93613: POP
// end ;
93614: PPOPN 2
93616: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93617: LD_EXP 124
93621: PUSH
93622: LD_EXP 141
93626: AND
93627: IFFALSE 93738
93629: GO 93631
93631: DISABLE
93632: LD_INT 0
93634: PPUSH
93635: PPUSH
93636: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93637: LD_ADDR_VAR 0 3
93641: PUSH
93642: LD_INT 22
93644: PUSH
93645: LD_OWVAR 2
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: LD_INT 25
93656: PUSH
93657: LD_INT 1
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: PUSH
93664: EMPTY
93665: LIST
93666: LIST
93667: PPUSH
93668: CALL_OW 69
93672: ST_TO_ADDR
// if not tmp then
93673: LD_VAR 0 3
93677: NOT
93678: IFFALSE 93682
// exit ;
93680: GO 93738
// un := tmp [ rand ( 1 , tmp ) ] ;
93682: LD_ADDR_VAR 0 2
93686: PUSH
93687: LD_VAR 0 3
93691: PUSH
93692: LD_INT 1
93694: PPUSH
93695: LD_VAR 0 3
93699: PPUSH
93700: CALL_OW 12
93704: ARRAY
93705: ST_TO_ADDR
// if Crawls ( un ) then
93706: LD_VAR 0 2
93710: PPUSH
93711: CALL_OW 318
93715: IFFALSE 93726
// ComWalk ( un ) ;
93717: LD_VAR 0 2
93721: PPUSH
93722: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93726: LD_VAR 0 2
93730: PPUSH
93731: LD_INT 5
93733: PPUSH
93734: CALL_OW 336
// end ;
93738: PPOPN 3
93740: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
93741: LD_EXP 124
93745: PUSH
93746: LD_EXP 142
93750: AND
93751: PUSH
93752: LD_OWVAR 67
93756: PUSH
93757: LD_INT 4
93759: LESS
93760: AND
93761: IFFALSE 93780
93763: GO 93765
93765: DISABLE
// begin Difficulty := Difficulty + 1 ;
93766: LD_ADDR_OWVAR 67
93770: PUSH
93771: LD_OWVAR 67
93775: PUSH
93776: LD_INT 1
93778: PLUS
93779: ST_TO_ADDR
// end ;
93780: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93781: LD_EXP 124
93785: PUSH
93786: LD_EXP 143
93790: AND
93791: IFFALSE 93894
93793: GO 93795
93795: DISABLE
93796: LD_INT 0
93798: PPUSH
// begin for i := 1 to 5 do
93799: LD_ADDR_VAR 0 1
93803: PUSH
93804: DOUBLE
93805: LD_INT 1
93807: DEC
93808: ST_TO_ADDR
93809: LD_INT 5
93811: PUSH
93812: FOR_TO
93813: IFFALSE 93892
// begin uc_nation := nation_nature ;
93815: LD_ADDR_OWVAR 21
93819: PUSH
93820: LD_INT 0
93822: ST_TO_ADDR
// uc_side := 0 ;
93823: LD_ADDR_OWVAR 20
93827: PUSH
93828: LD_INT 0
93830: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93831: LD_ADDR_OWVAR 29
93835: PUSH
93836: LD_INT 12
93838: PUSH
93839: LD_INT 12
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: ST_TO_ADDR
// hc_agressivity := 20 ;
93846: LD_ADDR_OWVAR 35
93850: PUSH
93851: LD_INT 20
93853: ST_TO_ADDR
// hc_class := class_tiger ;
93854: LD_ADDR_OWVAR 28
93858: PUSH
93859: LD_INT 14
93861: ST_TO_ADDR
// hc_gallery :=  ;
93862: LD_ADDR_OWVAR 33
93866: PUSH
93867: LD_STRING 
93869: ST_TO_ADDR
// hc_name :=  ;
93870: LD_ADDR_OWVAR 26
93874: PUSH
93875: LD_STRING 
93877: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93878: CALL_OW 44
93882: PPUSH
93883: LD_INT 0
93885: PPUSH
93886: CALL_OW 51
// end ;
93890: GO 93812
93892: POP
93893: POP
// end ;
93894: PPOPN 1
93896: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93897: LD_EXP 124
93901: PUSH
93902: LD_EXP 144
93906: AND
93907: IFFALSE 93916
93909: GO 93911
93911: DISABLE
// StreamSibBomb ;
93912: CALL 93917 0 0
93916: END
// export function StreamSibBomb ; var i , x , y ; begin
93917: LD_INT 0
93919: PPUSH
93920: PPUSH
93921: PPUSH
93922: PPUSH
// result := false ;
93923: LD_ADDR_VAR 0 1
93927: PUSH
93928: LD_INT 0
93930: ST_TO_ADDR
// for i := 1 to 16 do
93931: LD_ADDR_VAR 0 2
93935: PUSH
93936: DOUBLE
93937: LD_INT 1
93939: DEC
93940: ST_TO_ADDR
93941: LD_INT 16
93943: PUSH
93944: FOR_TO
93945: IFFALSE 94144
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93947: LD_ADDR_VAR 0 3
93951: PUSH
93952: LD_INT 10
93954: PUSH
93955: LD_INT 20
93957: PUSH
93958: LD_INT 30
93960: PUSH
93961: LD_INT 40
93963: PUSH
93964: LD_INT 50
93966: PUSH
93967: LD_INT 60
93969: PUSH
93970: LD_INT 70
93972: PUSH
93973: LD_INT 80
93975: PUSH
93976: LD_INT 90
93978: PUSH
93979: LD_INT 100
93981: PUSH
93982: LD_INT 110
93984: PUSH
93985: LD_INT 120
93987: PUSH
93988: LD_INT 130
93990: PUSH
93991: LD_INT 140
93993: PUSH
93994: LD_INT 150
93996: PUSH
93997: EMPTY
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: PUSH
94014: LD_INT 1
94016: PPUSH
94017: LD_INT 15
94019: PPUSH
94020: CALL_OW 12
94024: ARRAY
94025: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94026: LD_ADDR_VAR 0 4
94030: PUSH
94031: LD_INT 10
94033: PUSH
94034: LD_INT 20
94036: PUSH
94037: LD_INT 30
94039: PUSH
94040: LD_INT 40
94042: PUSH
94043: LD_INT 50
94045: PUSH
94046: LD_INT 60
94048: PUSH
94049: LD_INT 70
94051: PUSH
94052: LD_INT 80
94054: PUSH
94055: LD_INT 90
94057: PUSH
94058: LD_INT 100
94060: PUSH
94061: LD_INT 110
94063: PUSH
94064: LD_INT 120
94066: PUSH
94067: LD_INT 130
94069: PUSH
94070: LD_INT 140
94072: PUSH
94073: LD_INT 150
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: PUSH
94093: LD_INT 1
94095: PPUSH
94096: LD_INT 15
94098: PPUSH
94099: CALL_OW 12
94103: ARRAY
94104: ST_TO_ADDR
// if ValidHex ( x , y ) then
94105: LD_VAR 0 3
94109: PPUSH
94110: LD_VAR 0 4
94114: PPUSH
94115: CALL_OW 488
94119: IFFALSE 94142
// begin result := [ x , y ] ;
94121: LD_ADDR_VAR 0 1
94125: PUSH
94126: LD_VAR 0 3
94130: PUSH
94131: LD_VAR 0 4
94135: PUSH
94136: EMPTY
94137: LIST
94138: LIST
94139: ST_TO_ADDR
// break ;
94140: GO 94144
// end ; end ;
94142: GO 93944
94144: POP
94145: POP
// if result then
94146: LD_VAR 0 1
94150: IFFALSE 94210
// begin ToLua ( playSibBomb() ) ;
94152: LD_STRING playSibBomb()
94154: PPUSH
94155: CALL_OW 559
// wait ( 0 0$14 ) ;
94159: LD_INT 490
94161: PPUSH
94162: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94166: LD_VAR 0 1
94170: PUSH
94171: LD_INT 1
94173: ARRAY
94174: PPUSH
94175: LD_VAR 0 1
94179: PUSH
94180: LD_INT 2
94182: ARRAY
94183: PPUSH
94184: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94188: LD_VAR 0 1
94192: PUSH
94193: LD_INT 1
94195: ARRAY
94196: PPUSH
94197: LD_VAR 0 1
94201: PUSH
94202: LD_INT 2
94204: ARRAY
94205: PPUSH
94206: CALL_OW 429
// end ; end ;
94210: LD_VAR 0 1
94214: RET
// every 0 0$1 trigger StreamModeActive and sReset do
94215: LD_EXP 124
94219: PUSH
94220: LD_EXP 146
94224: AND
94225: IFFALSE 94237
94227: GO 94229
94229: DISABLE
// YouLost (  ) ;
94230: LD_STRING 
94232: PPUSH
94233: CALL_OW 104
94237: END
// every 0 0$1 trigger StreamModeActive and sFog do
94238: LD_EXP 124
94242: PUSH
94243: LD_EXP 145
94247: AND
94248: IFFALSE 94262
94250: GO 94252
94252: DISABLE
// FogOff ( your_side ) ;
94253: LD_OWVAR 2
94257: PPUSH
94258: CALL_OW 344
94262: END
// every 0 0$1 trigger StreamModeActive and sSun do
94263: LD_EXP 124
94267: PUSH
94268: LD_EXP 147
94272: AND
94273: IFFALSE 94301
94275: GO 94277
94277: DISABLE
// begin solar_recharge_percent := 0 ;
94278: LD_ADDR_OWVAR 79
94282: PUSH
94283: LD_INT 0
94285: ST_TO_ADDR
// wait ( 5 5$00 ) ;
94286: LD_INT 10500
94288: PPUSH
94289: CALL_OW 67
// solar_recharge_percent := 100 ;
94293: LD_ADDR_OWVAR 79
94297: PUSH
94298: LD_INT 100
94300: ST_TO_ADDR
// end ;
94301: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
94302: LD_EXP 124
94306: PUSH
94307: LD_EXP 148
94311: AND
94312: IFFALSE 94551
94314: GO 94316
94316: DISABLE
94317: LD_INT 0
94319: PPUSH
94320: PPUSH
94321: PPUSH
// begin tmp := [ ] ;
94322: LD_ADDR_VAR 0 3
94326: PUSH
94327: EMPTY
94328: ST_TO_ADDR
// for i := 1 to 6 do
94329: LD_ADDR_VAR 0 1
94333: PUSH
94334: DOUBLE
94335: LD_INT 1
94337: DEC
94338: ST_TO_ADDR
94339: LD_INT 6
94341: PUSH
94342: FOR_TO
94343: IFFALSE 94448
// begin uc_nation := nation_nature ;
94345: LD_ADDR_OWVAR 21
94349: PUSH
94350: LD_INT 0
94352: ST_TO_ADDR
// uc_side := 0 ;
94353: LD_ADDR_OWVAR 20
94357: PUSH
94358: LD_INT 0
94360: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94361: LD_ADDR_OWVAR 29
94365: PUSH
94366: LD_INT 12
94368: PUSH
94369: LD_INT 12
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: ST_TO_ADDR
// hc_agressivity := 20 ;
94376: LD_ADDR_OWVAR 35
94380: PUSH
94381: LD_INT 20
94383: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
94384: LD_ADDR_OWVAR 28
94388: PUSH
94389: LD_INT 17
94391: ST_TO_ADDR
// hc_gallery :=  ;
94392: LD_ADDR_OWVAR 33
94396: PUSH
94397: LD_STRING 
94399: ST_TO_ADDR
// hc_name :=  ;
94400: LD_ADDR_OWVAR 26
94404: PUSH
94405: LD_STRING 
94407: ST_TO_ADDR
// un := CreateHuman ;
94408: LD_ADDR_VAR 0 2
94412: PUSH
94413: CALL_OW 44
94417: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94418: LD_VAR 0 2
94422: PPUSH
94423: LD_INT 1
94425: PPUSH
94426: CALL_OW 51
// tmp := tmp ^ un ;
94430: LD_ADDR_VAR 0 3
94434: PUSH
94435: LD_VAR 0 3
94439: PUSH
94440: LD_VAR 0 2
94444: ADD
94445: ST_TO_ADDR
// end ;
94446: GO 94342
94448: POP
94449: POP
// repeat wait ( 0 0$1 ) ;
94450: LD_INT 35
94452: PPUSH
94453: CALL_OW 67
// for un in tmp do
94457: LD_ADDR_VAR 0 2
94461: PUSH
94462: LD_VAR 0 3
94466: PUSH
94467: FOR_IN
94468: IFFALSE 94542
// begin if IsDead ( un ) then
94470: LD_VAR 0 2
94474: PPUSH
94475: CALL_OW 301
94479: IFFALSE 94499
// begin tmp := tmp diff un ;
94481: LD_ADDR_VAR 0 3
94485: PUSH
94486: LD_VAR 0 3
94490: PUSH
94491: LD_VAR 0 2
94495: DIFF
94496: ST_TO_ADDR
// continue ;
94497: GO 94467
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94499: LD_VAR 0 2
94503: PPUSH
94504: LD_INT 3
94506: PUSH
94507: LD_INT 22
94509: PUSH
94510: LD_INT 0
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: EMPTY
94518: LIST
94519: LIST
94520: PPUSH
94521: CALL_OW 69
94525: PPUSH
94526: LD_VAR 0 2
94530: PPUSH
94531: CALL_OW 74
94535: PPUSH
94536: CALL_OW 115
// end ;
94540: GO 94467
94542: POP
94543: POP
// until not tmp ;
94544: LD_VAR 0 3
94548: NOT
94549: IFFALSE 94450
// end ;
94551: PPOPN 3
94553: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94554: LD_EXP 124
94558: PUSH
94559: LD_EXP 149
94563: AND
94564: IFFALSE 94618
94566: GO 94568
94568: DISABLE
// begin ToLua ( displayTroll(); ) ;
94569: LD_STRING displayTroll();
94571: PPUSH
94572: CALL_OW 559
// wait ( 3 3$00 ) ;
94576: LD_INT 6300
94578: PPUSH
94579: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94583: LD_STRING hideTroll();
94585: PPUSH
94586: CALL_OW 559
// wait ( 1 1$00 ) ;
94590: LD_INT 2100
94592: PPUSH
94593: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94597: LD_STRING displayTroll();
94599: PPUSH
94600: CALL_OW 559
// wait ( 1 1$00 ) ;
94604: LD_INT 2100
94606: PPUSH
94607: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94611: LD_STRING hideTroll();
94613: PPUSH
94614: CALL_OW 559
// end ;
94618: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94619: LD_EXP 124
94623: PUSH
94624: LD_EXP 150
94628: AND
94629: IFFALSE 94692
94631: GO 94633
94633: DISABLE
94634: LD_INT 0
94636: PPUSH
// begin p := 0 ;
94637: LD_ADDR_VAR 0 1
94641: PUSH
94642: LD_INT 0
94644: ST_TO_ADDR
// repeat game_speed := 1 ;
94645: LD_ADDR_OWVAR 65
94649: PUSH
94650: LD_INT 1
94652: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94653: LD_INT 35
94655: PPUSH
94656: CALL_OW 67
// p := p + 1 ;
94660: LD_ADDR_VAR 0 1
94664: PUSH
94665: LD_VAR 0 1
94669: PUSH
94670: LD_INT 1
94672: PLUS
94673: ST_TO_ADDR
// until p >= 60 ;
94674: LD_VAR 0 1
94678: PUSH
94679: LD_INT 60
94681: GREATEREQUAL
94682: IFFALSE 94645
// game_speed := 4 ;
94684: LD_ADDR_OWVAR 65
94688: PUSH
94689: LD_INT 4
94691: ST_TO_ADDR
// end ;
94692: PPOPN 1
94694: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94695: LD_EXP 124
94699: PUSH
94700: LD_EXP 151
94704: AND
94705: IFFALSE 94851
94707: GO 94709
94709: DISABLE
94710: LD_INT 0
94712: PPUSH
94713: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94714: LD_ADDR_VAR 0 1
94718: PUSH
94719: LD_INT 22
94721: PUSH
94722: LD_OWVAR 2
94726: PUSH
94727: EMPTY
94728: LIST
94729: LIST
94730: PUSH
94731: LD_INT 2
94733: PUSH
94734: LD_INT 30
94736: PUSH
94737: LD_INT 0
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 30
94746: PUSH
94747: LD_INT 1
94749: PUSH
94750: EMPTY
94751: LIST
94752: LIST
94753: PUSH
94754: EMPTY
94755: LIST
94756: LIST
94757: LIST
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PPUSH
94763: CALL_OW 69
94767: ST_TO_ADDR
// if not depot then
94768: LD_VAR 0 1
94772: NOT
94773: IFFALSE 94777
// exit ;
94775: GO 94851
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94777: LD_ADDR_VAR 0 2
94781: PUSH
94782: LD_VAR 0 1
94786: PUSH
94787: LD_INT 1
94789: PPUSH
94790: LD_VAR 0 1
94794: PPUSH
94795: CALL_OW 12
94799: ARRAY
94800: PPUSH
94801: CALL_OW 274
94805: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94806: LD_VAR 0 2
94810: PPUSH
94811: LD_INT 1
94813: PPUSH
94814: LD_INT 0
94816: PPUSH
94817: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94821: LD_VAR 0 2
94825: PPUSH
94826: LD_INT 2
94828: PPUSH
94829: LD_INT 0
94831: PPUSH
94832: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94836: LD_VAR 0 2
94840: PPUSH
94841: LD_INT 3
94843: PPUSH
94844: LD_INT 0
94846: PPUSH
94847: CALL_OW 277
// end ;
94851: PPOPN 2
94853: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94854: LD_EXP 124
94858: PUSH
94859: LD_EXP 152
94863: AND
94864: IFFALSE 94961
94866: GO 94868
94868: DISABLE
94869: LD_INT 0
94871: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94872: LD_ADDR_VAR 0 1
94876: PUSH
94877: LD_INT 22
94879: PUSH
94880: LD_OWVAR 2
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: PUSH
94889: LD_INT 21
94891: PUSH
94892: LD_INT 1
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 3
94901: PUSH
94902: LD_INT 23
94904: PUSH
94905: LD_INT 0
94907: PUSH
94908: EMPTY
94909: LIST
94910: LIST
94911: PUSH
94912: EMPTY
94913: LIST
94914: LIST
94915: PUSH
94916: EMPTY
94917: LIST
94918: LIST
94919: LIST
94920: PPUSH
94921: CALL_OW 69
94925: ST_TO_ADDR
// if not tmp then
94926: LD_VAR 0 1
94930: NOT
94931: IFFALSE 94935
// exit ;
94933: GO 94961
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
94935: LD_VAR 0 1
94939: PUSH
94940: LD_INT 1
94942: PPUSH
94943: LD_VAR 0 1
94947: PPUSH
94948: CALL_OW 12
94952: ARRAY
94953: PPUSH
94954: LD_INT 200
94956: PPUSH
94957: CALL_OW 234
// end ;
94961: PPOPN 1
94963: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
94964: LD_EXP 124
94968: PUSH
94969: LD_EXP 153
94973: AND
94974: IFFALSE 95053
94976: GO 94978
94978: DISABLE
94979: LD_INT 0
94981: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
94982: LD_ADDR_VAR 0 1
94986: PUSH
94987: LD_INT 22
94989: PUSH
94990: LD_OWVAR 2
94994: PUSH
94995: EMPTY
94996: LIST
94997: LIST
94998: PUSH
94999: LD_INT 21
95001: PUSH
95002: LD_INT 2
95004: PUSH
95005: EMPTY
95006: LIST
95007: LIST
95008: PUSH
95009: EMPTY
95010: LIST
95011: LIST
95012: PPUSH
95013: CALL_OW 69
95017: ST_TO_ADDR
// if not tmp then
95018: LD_VAR 0 1
95022: NOT
95023: IFFALSE 95027
// exit ;
95025: GO 95053
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95027: LD_VAR 0 1
95031: PUSH
95032: LD_INT 1
95034: PPUSH
95035: LD_VAR 0 1
95039: PPUSH
95040: CALL_OW 12
95044: ARRAY
95045: PPUSH
95046: LD_INT 60
95048: PPUSH
95049: CALL_OW 234
// end ;
95053: PPOPN 1
95055: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95056: LD_EXP 124
95060: PUSH
95061: LD_EXP 154
95065: AND
95066: IFFALSE 95165
95068: GO 95070
95070: DISABLE
95071: LD_INT 0
95073: PPUSH
95074: PPUSH
// begin enable ;
95075: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95076: LD_ADDR_VAR 0 1
95080: PUSH
95081: LD_INT 22
95083: PUSH
95084: LD_OWVAR 2
95088: PUSH
95089: EMPTY
95090: LIST
95091: LIST
95092: PUSH
95093: LD_INT 61
95095: PUSH
95096: EMPTY
95097: LIST
95098: PUSH
95099: LD_INT 33
95101: PUSH
95102: LD_INT 2
95104: PUSH
95105: EMPTY
95106: LIST
95107: LIST
95108: PUSH
95109: EMPTY
95110: LIST
95111: LIST
95112: LIST
95113: PPUSH
95114: CALL_OW 69
95118: ST_TO_ADDR
// if not tmp then
95119: LD_VAR 0 1
95123: NOT
95124: IFFALSE 95128
// exit ;
95126: GO 95165
// for i in tmp do
95128: LD_ADDR_VAR 0 2
95132: PUSH
95133: LD_VAR 0 1
95137: PUSH
95138: FOR_IN
95139: IFFALSE 95163
// if IsControledBy ( i ) then
95141: LD_VAR 0 2
95145: PPUSH
95146: CALL_OW 312
95150: IFFALSE 95161
// ComUnlink ( i ) ;
95152: LD_VAR 0 2
95156: PPUSH
95157: CALL_OW 136
95161: GO 95138
95163: POP
95164: POP
// end ;
95165: PPOPN 2
95167: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95168: LD_EXP 124
95172: PUSH
95173: LD_EXP 155
95177: AND
95178: IFFALSE 95318
95180: GO 95182
95182: DISABLE
95183: LD_INT 0
95185: PPUSH
95186: PPUSH
// begin ToLua ( displayPowell(); ) ;
95187: LD_STRING displayPowell();
95189: PPUSH
95190: CALL_OW 559
// uc_side := 0 ;
95194: LD_ADDR_OWVAR 20
95198: PUSH
95199: LD_INT 0
95201: ST_TO_ADDR
// uc_nation := 2 ;
95202: LD_ADDR_OWVAR 21
95206: PUSH
95207: LD_INT 2
95209: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
95210: LD_ADDR_OWVAR 37
95214: PUSH
95215: LD_INT 14
95217: ST_TO_ADDR
// vc_engine := engine_siberite ;
95218: LD_ADDR_OWVAR 39
95222: PUSH
95223: LD_INT 3
95225: ST_TO_ADDR
// vc_control := control_apeman ;
95226: LD_ADDR_OWVAR 38
95230: PUSH
95231: LD_INT 5
95233: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
95234: LD_ADDR_OWVAR 40
95238: PUSH
95239: LD_INT 29
95241: ST_TO_ADDR
// un := CreateVehicle ;
95242: LD_ADDR_VAR 0 2
95246: PUSH
95247: CALL_OW 45
95251: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95252: LD_VAR 0 2
95256: PPUSH
95257: LD_INT 1
95259: PPUSH
95260: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95264: LD_INT 35
95266: PPUSH
95267: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95271: LD_VAR 0 2
95275: PPUSH
95276: LD_INT 22
95278: PUSH
95279: LD_OWVAR 2
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: PPUSH
95288: CALL_OW 69
95292: PPUSH
95293: LD_VAR 0 2
95297: PPUSH
95298: CALL_OW 74
95302: PPUSH
95303: CALL_OW 115
// until IsDead ( un ) ;
95307: LD_VAR 0 2
95311: PPUSH
95312: CALL_OW 301
95316: IFFALSE 95264
// end ;
95318: PPOPN 2
95320: END
// every 0 0$1 trigger StreamModeActive and sStu do
95321: LD_EXP 124
95325: PUSH
95326: LD_EXP 163
95330: AND
95331: IFFALSE 95347
95333: GO 95335
95335: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95336: LD_STRING displayStucuk();
95338: PPUSH
95339: CALL_OW 559
// ResetFog ;
95343: CALL_OW 335
// end ;
95347: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95348: LD_EXP 124
95352: PUSH
95353: LD_EXP 156
95357: AND
95358: IFFALSE 95499
95360: GO 95362
95362: DISABLE
95363: LD_INT 0
95365: PPUSH
95366: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95367: LD_ADDR_VAR 0 2
95371: PUSH
95372: LD_INT 22
95374: PUSH
95375: LD_OWVAR 2
95379: PUSH
95380: EMPTY
95381: LIST
95382: LIST
95383: PUSH
95384: LD_INT 21
95386: PUSH
95387: LD_INT 1
95389: PUSH
95390: EMPTY
95391: LIST
95392: LIST
95393: PUSH
95394: EMPTY
95395: LIST
95396: LIST
95397: PPUSH
95398: CALL_OW 69
95402: ST_TO_ADDR
// if not tmp then
95403: LD_VAR 0 2
95407: NOT
95408: IFFALSE 95412
// exit ;
95410: GO 95499
// un := tmp [ rand ( 1 , tmp ) ] ;
95412: LD_ADDR_VAR 0 1
95416: PUSH
95417: LD_VAR 0 2
95421: PUSH
95422: LD_INT 1
95424: PPUSH
95425: LD_VAR 0 2
95429: PPUSH
95430: CALL_OW 12
95434: ARRAY
95435: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95436: LD_VAR 0 1
95440: PPUSH
95441: LD_INT 0
95443: PPUSH
95444: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95448: LD_VAR 0 1
95452: PPUSH
95453: LD_OWVAR 3
95457: PUSH
95458: LD_VAR 0 1
95462: DIFF
95463: PPUSH
95464: LD_VAR 0 1
95468: PPUSH
95469: CALL_OW 74
95473: PPUSH
95474: CALL_OW 115
// wait ( 0 0$20 ) ;
95478: LD_INT 700
95480: PPUSH
95481: CALL_OW 67
// SetSide ( un , your_side ) ;
95485: LD_VAR 0 1
95489: PPUSH
95490: LD_OWVAR 2
95494: PPUSH
95495: CALL_OW 235
// end ;
95499: PPOPN 2
95501: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95502: LD_EXP 124
95506: PUSH
95507: LD_EXP 157
95511: AND
95512: IFFALSE 95618
95514: GO 95516
95516: DISABLE
95517: LD_INT 0
95519: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95520: LD_ADDR_VAR 0 1
95524: PUSH
95525: LD_INT 22
95527: PUSH
95528: LD_OWVAR 2
95532: PUSH
95533: EMPTY
95534: LIST
95535: LIST
95536: PUSH
95537: LD_INT 2
95539: PUSH
95540: LD_INT 30
95542: PUSH
95543: LD_INT 0
95545: PUSH
95546: EMPTY
95547: LIST
95548: LIST
95549: PUSH
95550: LD_INT 30
95552: PUSH
95553: LD_INT 1
95555: PUSH
95556: EMPTY
95557: LIST
95558: LIST
95559: PUSH
95560: EMPTY
95561: LIST
95562: LIST
95563: LIST
95564: PUSH
95565: EMPTY
95566: LIST
95567: LIST
95568: PPUSH
95569: CALL_OW 69
95573: ST_TO_ADDR
// if not depot then
95574: LD_VAR 0 1
95578: NOT
95579: IFFALSE 95583
// exit ;
95581: GO 95618
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95583: LD_VAR 0 1
95587: PUSH
95588: LD_INT 1
95590: ARRAY
95591: PPUSH
95592: CALL_OW 250
95596: PPUSH
95597: LD_VAR 0 1
95601: PUSH
95602: LD_INT 1
95604: ARRAY
95605: PPUSH
95606: CALL_OW 251
95610: PPUSH
95611: LD_INT 70
95613: PPUSH
95614: CALL_OW 495
// end ;
95618: PPOPN 1
95620: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95621: LD_EXP 124
95625: PUSH
95626: LD_EXP 158
95630: AND
95631: IFFALSE 95842
95633: GO 95635
95635: DISABLE
95636: LD_INT 0
95638: PPUSH
95639: PPUSH
95640: PPUSH
95641: PPUSH
95642: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95643: LD_ADDR_VAR 0 5
95647: PUSH
95648: LD_INT 22
95650: PUSH
95651: LD_OWVAR 2
95655: PUSH
95656: EMPTY
95657: LIST
95658: LIST
95659: PUSH
95660: LD_INT 21
95662: PUSH
95663: LD_INT 1
95665: PUSH
95666: EMPTY
95667: LIST
95668: LIST
95669: PUSH
95670: EMPTY
95671: LIST
95672: LIST
95673: PPUSH
95674: CALL_OW 69
95678: ST_TO_ADDR
// if not tmp then
95679: LD_VAR 0 5
95683: NOT
95684: IFFALSE 95688
// exit ;
95686: GO 95842
// for i in tmp do
95688: LD_ADDR_VAR 0 1
95692: PUSH
95693: LD_VAR 0 5
95697: PUSH
95698: FOR_IN
95699: IFFALSE 95840
// begin d := rand ( 0 , 5 ) ;
95701: LD_ADDR_VAR 0 4
95705: PUSH
95706: LD_INT 0
95708: PPUSH
95709: LD_INT 5
95711: PPUSH
95712: CALL_OW 12
95716: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95717: LD_ADDR_VAR 0 2
95721: PUSH
95722: LD_VAR 0 1
95726: PPUSH
95727: CALL_OW 250
95731: PPUSH
95732: LD_VAR 0 4
95736: PPUSH
95737: LD_INT 3
95739: PPUSH
95740: LD_INT 12
95742: PPUSH
95743: CALL_OW 12
95747: PPUSH
95748: CALL_OW 272
95752: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95753: LD_ADDR_VAR 0 3
95757: PUSH
95758: LD_VAR 0 1
95762: PPUSH
95763: CALL_OW 251
95767: PPUSH
95768: LD_VAR 0 4
95772: PPUSH
95773: LD_INT 3
95775: PPUSH
95776: LD_INT 12
95778: PPUSH
95779: CALL_OW 12
95783: PPUSH
95784: CALL_OW 273
95788: ST_TO_ADDR
// if ValidHex ( x , y ) then
95789: LD_VAR 0 2
95793: PPUSH
95794: LD_VAR 0 3
95798: PPUSH
95799: CALL_OW 488
95803: IFFALSE 95838
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95805: LD_VAR 0 1
95809: PPUSH
95810: LD_VAR 0 2
95814: PPUSH
95815: LD_VAR 0 3
95819: PPUSH
95820: LD_INT 3
95822: PPUSH
95823: LD_INT 6
95825: PPUSH
95826: CALL_OW 12
95830: PPUSH
95831: LD_INT 1
95833: PPUSH
95834: CALL_OW 483
// end ;
95838: GO 95698
95840: POP
95841: POP
// end ;
95842: PPOPN 5
95844: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95845: LD_EXP 124
95849: PUSH
95850: LD_EXP 159
95854: AND
95855: IFFALSE 95949
95857: GO 95859
95859: DISABLE
95860: LD_INT 0
95862: PPUSH
95863: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95864: LD_ADDR_VAR 0 2
95868: PUSH
95869: LD_INT 22
95871: PUSH
95872: LD_OWVAR 2
95876: PUSH
95877: EMPTY
95878: LIST
95879: LIST
95880: PUSH
95881: LD_INT 32
95883: PUSH
95884: LD_INT 1
95886: PUSH
95887: EMPTY
95888: LIST
95889: LIST
95890: PUSH
95891: LD_INT 21
95893: PUSH
95894: LD_INT 2
95896: PUSH
95897: EMPTY
95898: LIST
95899: LIST
95900: PUSH
95901: EMPTY
95902: LIST
95903: LIST
95904: LIST
95905: PPUSH
95906: CALL_OW 69
95910: ST_TO_ADDR
// if not tmp then
95911: LD_VAR 0 2
95915: NOT
95916: IFFALSE 95920
// exit ;
95918: GO 95949
// for i in tmp do
95920: LD_ADDR_VAR 0 1
95924: PUSH
95925: LD_VAR 0 2
95929: PUSH
95930: FOR_IN
95931: IFFALSE 95947
// SetFuel ( i , 0 ) ;
95933: LD_VAR 0 1
95937: PPUSH
95938: LD_INT 0
95940: PPUSH
95941: CALL_OW 240
95945: GO 95930
95947: POP
95948: POP
// end ;
95949: PPOPN 2
95951: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
95952: LD_EXP 124
95956: PUSH
95957: LD_EXP 160
95961: AND
95962: IFFALSE 96028
95964: GO 95966
95966: DISABLE
95967: LD_INT 0
95969: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95970: LD_ADDR_VAR 0 1
95974: PUSH
95975: LD_INT 22
95977: PUSH
95978: LD_OWVAR 2
95982: PUSH
95983: EMPTY
95984: LIST
95985: LIST
95986: PUSH
95987: LD_INT 30
95989: PUSH
95990: LD_INT 29
95992: PUSH
95993: EMPTY
95994: LIST
95995: LIST
95996: PUSH
95997: EMPTY
95998: LIST
95999: LIST
96000: PPUSH
96001: CALL_OW 69
96005: ST_TO_ADDR
// if not tmp then
96006: LD_VAR 0 1
96010: NOT
96011: IFFALSE 96015
// exit ;
96013: GO 96028
// DestroyUnit ( tmp [ 1 ] ) ;
96015: LD_VAR 0 1
96019: PUSH
96020: LD_INT 1
96022: ARRAY
96023: PPUSH
96024: CALL_OW 65
// end ;
96028: PPOPN 1
96030: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96031: LD_EXP 124
96035: PUSH
96036: LD_EXP 162
96040: AND
96041: IFFALSE 96170
96043: GO 96045
96045: DISABLE
96046: LD_INT 0
96048: PPUSH
// begin uc_side := 0 ;
96049: LD_ADDR_OWVAR 20
96053: PUSH
96054: LD_INT 0
96056: ST_TO_ADDR
// uc_nation := nation_arabian ;
96057: LD_ADDR_OWVAR 21
96061: PUSH
96062: LD_INT 2
96064: ST_TO_ADDR
// hc_gallery :=  ;
96065: LD_ADDR_OWVAR 33
96069: PUSH
96070: LD_STRING 
96072: ST_TO_ADDR
// hc_name :=  ;
96073: LD_ADDR_OWVAR 26
96077: PUSH
96078: LD_STRING 
96080: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96081: LD_INT 1
96083: PPUSH
96084: LD_INT 11
96086: PPUSH
96087: LD_INT 10
96089: PPUSH
96090: CALL_OW 380
// un := CreateHuman ;
96094: LD_ADDR_VAR 0 1
96098: PUSH
96099: CALL_OW 44
96103: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96104: LD_VAR 0 1
96108: PPUSH
96109: LD_INT 1
96111: PPUSH
96112: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96116: LD_INT 35
96118: PPUSH
96119: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96123: LD_VAR 0 1
96127: PPUSH
96128: LD_INT 22
96130: PUSH
96131: LD_OWVAR 2
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PPUSH
96140: CALL_OW 69
96144: PPUSH
96145: LD_VAR 0 1
96149: PPUSH
96150: CALL_OW 74
96154: PPUSH
96155: CALL_OW 115
// until IsDead ( un ) ;
96159: LD_VAR 0 1
96163: PPUSH
96164: CALL_OW 301
96168: IFFALSE 96116
// end ;
96170: PPOPN 1
96172: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96173: LD_EXP 124
96177: PUSH
96178: LD_EXP 164
96182: AND
96183: IFFALSE 96195
96185: GO 96187
96187: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96188: LD_STRING earthquake(getX(game), 0, 32)
96190: PPUSH
96191: CALL_OW 559
96195: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
96196: LD_EXP 124
96200: PUSH
96201: LD_EXP 165
96205: AND
96206: IFFALSE 96297
96208: GO 96210
96210: DISABLE
96211: LD_INT 0
96213: PPUSH
// begin enable ;
96214: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
96215: LD_ADDR_VAR 0 1
96219: PUSH
96220: LD_INT 22
96222: PUSH
96223: LD_OWVAR 2
96227: PUSH
96228: EMPTY
96229: LIST
96230: LIST
96231: PUSH
96232: LD_INT 21
96234: PUSH
96235: LD_INT 2
96237: PUSH
96238: EMPTY
96239: LIST
96240: LIST
96241: PUSH
96242: LD_INT 33
96244: PUSH
96245: LD_INT 3
96247: PUSH
96248: EMPTY
96249: LIST
96250: LIST
96251: PUSH
96252: EMPTY
96253: LIST
96254: LIST
96255: LIST
96256: PPUSH
96257: CALL_OW 69
96261: ST_TO_ADDR
// if not tmp then
96262: LD_VAR 0 1
96266: NOT
96267: IFFALSE 96271
// exit ;
96269: GO 96297
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96271: LD_VAR 0 1
96275: PUSH
96276: LD_INT 1
96278: PPUSH
96279: LD_VAR 0 1
96283: PPUSH
96284: CALL_OW 12
96288: ARRAY
96289: PPUSH
96290: LD_INT 1
96292: PPUSH
96293: CALL_OW 234
// end ;
96297: PPOPN 1
96299: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
96300: LD_EXP 124
96304: PUSH
96305: LD_EXP 166
96309: AND
96310: IFFALSE 96451
96312: GO 96314
96314: DISABLE
96315: LD_INT 0
96317: PPUSH
96318: PPUSH
96319: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96320: LD_ADDR_VAR 0 3
96324: PUSH
96325: LD_INT 22
96327: PUSH
96328: LD_OWVAR 2
96332: PUSH
96333: EMPTY
96334: LIST
96335: LIST
96336: PUSH
96337: LD_INT 25
96339: PUSH
96340: LD_INT 1
96342: PUSH
96343: EMPTY
96344: LIST
96345: LIST
96346: PUSH
96347: EMPTY
96348: LIST
96349: LIST
96350: PPUSH
96351: CALL_OW 69
96355: ST_TO_ADDR
// if not tmp then
96356: LD_VAR 0 3
96360: NOT
96361: IFFALSE 96365
// exit ;
96363: GO 96451
// un := tmp [ rand ( 1 , tmp ) ] ;
96365: LD_ADDR_VAR 0 2
96369: PUSH
96370: LD_VAR 0 3
96374: PUSH
96375: LD_INT 1
96377: PPUSH
96378: LD_VAR 0 3
96382: PPUSH
96383: CALL_OW 12
96387: ARRAY
96388: ST_TO_ADDR
// if Crawls ( un ) then
96389: LD_VAR 0 2
96393: PPUSH
96394: CALL_OW 318
96398: IFFALSE 96409
// ComWalk ( un ) ;
96400: LD_VAR 0 2
96404: PPUSH
96405: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96409: LD_VAR 0 2
96413: PPUSH
96414: LD_INT 9
96416: PPUSH
96417: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96421: LD_INT 28
96423: PPUSH
96424: LD_OWVAR 2
96428: PPUSH
96429: LD_INT 2
96431: PPUSH
96432: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96436: LD_INT 29
96438: PPUSH
96439: LD_OWVAR 2
96443: PPUSH
96444: LD_INT 2
96446: PPUSH
96447: CALL_OW 322
// end ;
96451: PPOPN 3
96453: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96454: LD_EXP 124
96458: PUSH
96459: LD_EXP 167
96463: AND
96464: IFFALSE 96575
96466: GO 96468
96468: DISABLE
96469: LD_INT 0
96471: PPUSH
96472: PPUSH
96473: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96474: LD_ADDR_VAR 0 3
96478: PUSH
96479: LD_INT 22
96481: PUSH
96482: LD_OWVAR 2
96486: PUSH
96487: EMPTY
96488: LIST
96489: LIST
96490: PUSH
96491: LD_INT 25
96493: PUSH
96494: LD_INT 1
96496: PUSH
96497: EMPTY
96498: LIST
96499: LIST
96500: PUSH
96501: EMPTY
96502: LIST
96503: LIST
96504: PPUSH
96505: CALL_OW 69
96509: ST_TO_ADDR
// if not tmp then
96510: LD_VAR 0 3
96514: NOT
96515: IFFALSE 96519
// exit ;
96517: GO 96575
// un := tmp [ rand ( 1 , tmp ) ] ;
96519: LD_ADDR_VAR 0 2
96523: PUSH
96524: LD_VAR 0 3
96528: PUSH
96529: LD_INT 1
96531: PPUSH
96532: LD_VAR 0 3
96536: PPUSH
96537: CALL_OW 12
96541: ARRAY
96542: ST_TO_ADDR
// if Crawls ( un ) then
96543: LD_VAR 0 2
96547: PPUSH
96548: CALL_OW 318
96552: IFFALSE 96563
// ComWalk ( un ) ;
96554: LD_VAR 0 2
96558: PPUSH
96559: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96563: LD_VAR 0 2
96567: PPUSH
96568: LD_INT 8
96570: PPUSH
96571: CALL_OW 336
// end ;
96575: PPOPN 3
96577: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96578: LD_EXP 124
96582: PUSH
96583: LD_EXP 168
96587: AND
96588: IFFALSE 96732
96590: GO 96592
96592: DISABLE
96593: LD_INT 0
96595: PPUSH
96596: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96597: LD_ADDR_VAR 0 2
96601: PUSH
96602: LD_INT 22
96604: PUSH
96605: LD_OWVAR 2
96609: PUSH
96610: EMPTY
96611: LIST
96612: LIST
96613: PUSH
96614: LD_INT 21
96616: PUSH
96617: LD_INT 2
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: PUSH
96624: LD_INT 2
96626: PUSH
96627: LD_INT 34
96629: PUSH
96630: LD_INT 12
96632: PUSH
96633: EMPTY
96634: LIST
96635: LIST
96636: PUSH
96637: LD_INT 34
96639: PUSH
96640: LD_INT 51
96642: PUSH
96643: EMPTY
96644: LIST
96645: LIST
96646: PUSH
96647: LD_INT 34
96649: PUSH
96650: LD_INT 32
96652: PUSH
96653: EMPTY
96654: LIST
96655: LIST
96656: PUSH
96657: EMPTY
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: PUSH
96663: EMPTY
96664: LIST
96665: LIST
96666: LIST
96667: PPUSH
96668: CALL_OW 69
96672: ST_TO_ADDR
// if not tmp then
96673: LD_VAR 0 2
96677: NOT
96678: IFFALSE 96682
// exit ;
96680: GO 96732
// for i in tmp do
96682: LD_ADDR_VAR 0 1
96686: PUSH
96687: LD_VAR 0 2
96691: PUSH
96692: FOR_IN
96693: IFFALSE 96730
// if GetCargo ( i , mat_artifact ) = 0 then
96695: LD_VAR 0 1
96699: PPUSH
96700: LD_INT 4
96702: PPUSH
96703: CALL_OW 289
96707: PUSH
96708: LD_INT 0
96710: EQUAL
96711: IFFALSE 96728
// SetCargo ( i , mat_siberit , 100 ) ;
96713: LD_VAR 0 1
96717: PPUSH
96718: LD_INT 3
96720: PPUSH
96721: LD_INT 100
96723: PPUSH
96724: CALL_OW 290
96728: GO 96692
96730: POP
96731: POP
// end ;
96732: PPOPN 2
96734: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96735: LD_EXP 124
96739: PUSH
96740: LD_EXP 169
96744: AND
96745: IFFALSE 96928
96747: GO 96749
96749: DISABLE
96750: LD_INT 0
96752: PPUSH
96753: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96754: LD_ADDR_VAR 0 2
96758: PUSH
96759: LD_INT 22
96761: PUSH
96762: LD_OWVAR 2
96766: PUSH
96767: EMPTY
96768: LIST
96769: LIST
96770: PPUSH
96771: CALL_OW 69
96775: ST_TO_ADDR
// if not tmp then
96776: LD_VAR 0 2
96780: NOT
96781: IFFALSE 96785
// exit ;
96783: GO 96928
// for i := 1 to 2 do
96785: LD_ADDR_VAR 0 1
96789: PUSH
96790: DOUBLE
96791: LD_INT 1
96793: DEC
96794: ST_TO_ADDR
96795: LD_INT 2
96797: PUSH
96798: FOR_TO
96799: IFFALSE 96926
// begin uc_side := your_side ;
96801: LD_ADDR_OWVAR 20
96805: PUSH
96806: LD_OWVAR 2
96810: ST_TO_ADDR
// uc_nation := nation_american ;
96811: LD_ADDR_OWVAR 21
96815: PUSH
96816: LD_INT 1
96818: ST_TO_ADDR
// vc_chassis := us_morphling ;
96819: LD_ADDR_OWVAR 37
96823: PUSH
96824: LD_INT 5
96826: ST_TO_ADDR
// vc_engine := engine_siberite ;
96827: LD_ADDR_OWVAR 39
96831: PUSH
96832: LD_INT 3
96834: ST_TO_ADDR
// vc_control := control_computer ;
96835: LD_ADDR_OWVAR 38
96839: PUSH
96840: LD_INT 3
96842: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96843: LD_ADDR_OWVAR 40
96847: PUSH
96848: LD_INT 10
96850: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
96851: LD_VAR 0 2
96855: PUSH
96856: LD_INT 1
96858: ARRAY
96859: PPUSH
96860: CALL_OW 310
96864: NOT
96865: IFFALSE 96912
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
96867: CALL_OW 45
96871: PPUSH
96872: LD_VAR 0 2
96876: PUSH
96877: LD_INT 1
96879: ARRAY
96880: PPUSH
96881: CALL_OW 250
96885: PPUSH
96886: LD_VAR 0 2
96890: PUSH
96891: LD_INT 1
96893: ARRAY
96894: PPUSH
96895: CALL_OW 251
96899: PPUSH
96900: LD_INT 12
96902: PPUSH
96903: LD_INT 1
96905: PPUSH
96906: CALL_OW 50
96910: GO 96924
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
96912: CALL_OW 45
96916: PPUSH
96917: LD_INT 1
96919: PPUSH
96920: CALL_OW 51
// end ;
96924: GO 96798
96926: POP
96927: POP
// end ;
96928: PPOPN 2
96930: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
96931: LD_EXP 124
96935: PUSH
96936: LD_EXP 170
96940: AND
96941: IFFALSE 97163
96943: GO 96945
96945: DISABLE
96946: LD_INT 0
96948: PPUSH
96949: PPUSH
96950: PPUSH
96951: PPUSH
96952: PPUSH
96953: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96954: LD_ADDR_VAR 0 6
96958: PUSH
96959: LD_INT 22
96961: PUSH
96962: LD_OWVAR 2
96966: PUSH
96967: EMPTY
96968: LIST
96969: LIST
96970: PUSH
96971: LD_INT 21
96973: PUSH
96974: LD_INT 1
96976: PUSH
96977: EMPTY
96978: LIST
96979: LIST
96980: PUSH
96981: LD_INT 3
96983: PUSH
96984: LD_INT 23
96986: PUSH
96987: LD_INT 0
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: PUSH
96994: EMPTY
96995: LIST
96996: LIST
96997: PUSH
96998: EMPTY
96999: LIST
97000: LIST
97001: LIST
97002: PPUSH
97003: CALL_OW 69
97007: ST_TO_ADDR
// if not tmp then
97008: LD_VAR 0 6
97012: NOT
97013: IFFALSE 97017
// exit ;
97015: GO 97163
// s1 := rand ( 1 , 4 ) ;
97017: LD_ADDR_VAR 0 2
97021: PUSH
97022: LD_INT 1
97024: PPUSH
97025: LD_INT 4
97027: PPUSH
97028: CALL_OW 12
97032: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97033: LD_ADDR_VAR 0 4
97037: PUSH
97038: LD_VAR 0 6
97042: PUSH
97043: LD_INT 1
97045: ARRAY
97046: PPUSH
97047: LD_VAR 0 2
97051: PPUSH
97052: CALL_OW 259
97056: ST_TO_ADDR
// if s1 = 1 then
97057: LD_VAR 0 2
97061: PUSH
97062: LD_INT 1
97064: EQUAL
97065: IFFALSE 97085
// s2 := rand ( 2 , 4 ) else
97067: LD_ADDR_VAR 0 3
97071: PUSH
97072: LD_INT 2
97074: PPUSH
97075: LD_INT 4
97077: PPUSH
97078: CALL_OW 12
97082: ST_TO_ADDR
97083: GO 97093
// s2 := 1 ;
97085: LD_ADDR_VAR 0 3
97089: PUSH
97090: LD_INT 1
97092: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97093: LD_ADDR_VAR 0 5
97097: PUSH
97098: LD_VAR 0 6
97102: PUSH
97103: LD_INT 1
97105: ARRAY
97106: PPUSH
97107: LD_VAR 0 3
97111: PPUSH
97112: CALL_OW 259
97116: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97117: LD_VAR 0 6
97121: PUSH
97122: LD_INT 1
97124: ARRAY
97125: PPUSH
97126: LD_VAR 0 2
97130: PPUSH
97131: LD_VAR 0 5
97135: PPUSH
97136: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97140: LD_VAR 0 6
97144: PUSH
97145: LD_INT 1
97147: ARRAY
97148: PPUSH
97149: LD_VAR 0 3
97153: PPUSH
97154: LD_VAR 0 4
97158: PPUSH
97159: CALL_OW 237
// end ;
97163: PPOPN 6
97165: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97166: LD_EXP 124
97170: PUSH
97171: LD_EXP 171
97175: AND
97176: IFFALSE 97255
97178: GO 97180
97180: DISABLE
97181: LD_INT 0
97183: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97184: LD_ADDR_VAR 0 1
97188: PUSH
97189: LD_INT 22
97191: PUSH
97192: LD_OWVAR 2
97196: PUSH
97197: EMPTY
97198: LIST
97199: LIST
97200: PUSH
97201: LD_INT 30
97203: PUSH
97204: LD_INT 3
97206: PUSH
97207: EMPTY
97208: LIST
97209: LIST
97210: PUSH
97211: EMPTY
97212: LIST
97213: LIST
97214: PPUSH
97215: CALL_OW 69
97219: ST_TO_ADDR
// if not tmp then
97220: LD_VAR 0 1
97224: NOT
97225: IFFALSE 97229
// exit ;
97227: GO 97255
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97229: LD_VAR 0 1
97233: PUSH
97234: LD_INT 1
97236: PPUSH
97237: LD_VAR 0 1
97241: PPUSH
97242: CALL_OW 12
97246: ARRAY
97247: PPUSH
97248: LD_INT 1
97250: PPUSH
97251: CALL_OW 234
// end ;
97255: PPOPN 1
97257: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
97258: LD_EXP 124
97262: PUSH
97263: LD_EXP 172
97267: AND
97268: IFFALSE 97380
97270: GO 97272
97272: DISABLE
97273: LD_INT 0
97275: PPUSH
97276: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
97277: LD_ADDR_VAR 0 2
97281: PUSH
97282: LD_INT 22
97284: PUSH
97285: LD_OWVAR 2
97289: PUSH
97290: EMPTY
97291: LIST
97292: LIST
97293: PUSH
97294: LD_INT 2
97296: PUSH
97297: LD_INT 30
97299: PUSH
97300: LD_INT 27
97302: PUSH
97303: EMPTY
97304: LIST
97305: LIST
97306: PUSH
97307: LD_INT 30
97309: PUSH
97310: LD_INT 26
97312: PUSH
97313: EMPTY
97314: LIST
97315: LIST
97316: PUSH
97317: LD_INT 30
97319: PUSH
97320: LD_INT 28
97322: PUSH
97323: EMPTY
97324: LIST
97325: LIST
97326: PUSH
97327: EMPTY
97328: LIST
97329: LIST
97330: LIST
97331: LIST
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: PPUSH
97337: CALL_OW 69
97341: ST_TO_ADDR
// if not tmp then
97342: LD_VAR 0 2
97346: NOT
97347: IFFALSE 97351
// exit ;
97349: GO 97380
// for i in tmp do
97351: LD_ADDR_VAR 0 1
97355: PUSH
97356: LD_VAR 0 2
97360: PUSH
97361: FOR_IN
97362: IFFALSE 97378
// SetLives ( i , 1 ) ;
97364: LD_VAR 0 1
97368: PPUSH
97369: LD_INT 1
97371: PPUSH
97372: CALL_OW 234
97376: GO 97361
97378: POP
97379: POP
// end ;
97380: PPOPN 2
97382: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97383: LD_EXP 124
97387: PUSH
97388: LD_EXP 173
97392: AND
97393: IFFALSE 97680
97395: GO 97397
97397: DISABLE
97398: LD_INT 0
97400: PPUSH
97401: PPUSH
97402: PPUSH
// begin i := rand ( 1 , 7 ) ;
97403: LD_ADDR_VAR 0 1
97407: PUSH
97408: LD_INT 1
97410: PPUSH
97411: LD_INT 7
97413: PPUSH
97414: CALL_OW 12
97418: ST_TO_ADDR
// case i of 1 :
97419: LD_VAR 0 1
97423: PUSH
97424: LD_INT 1
97426: DOUBLE
97427: EQUAL
97428: IFTRUE 97432
97430: GO 97442
97432: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97433: LD_STRING earthquake(getX(game), 0, 32)
97435: PPUSH
97436: CALL_OW 559
97440: GO 97680
97442: LD_INT 2
97444: DOUBLE
97445: EQUAL
97446: IFTRUE 97450
97448: GO 97464
97450: POP
// begin ToLua ( displayStucuk(); ) ;
97451: LD_STRING displayStucuk();
97453: PPUSH
97454: CALL_OW 559
// ResetFog ;
97458: CALL_OW 335
// end ; 3 :
97462: GO 97680
97464: LD_INT 3
97466: DOUBLE
97467: EQUAL
97468: IFTRUE 97472
97470: GO 97576
97472: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97473: LD_ADDR_VAR 0 2
97477: PUSH
97478: LD_INT 22
97480: PUSH
97481: LD_OWVAR 2
97485: PUSH
97486: EMPTY
97487: LIST
97488: LIST
97489: PUSH
97490: LD_INT 25
97492: PUSH
97493: LD_INT 1
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PUSH
97500: EMPTY
97501: LIST
97502: LIST
97503: PPUSH
97504: CALL_OW 69
97508: ST_TO_ADDR
// if not tmp then
97509: LD_VAR 0 2
97513: NOT
97514: IFFALSE 97518
// exit ;
97516: GO 97680
// un := tmp [ rand ( 1 , tmp ) ] ;
97518: LD_ADDR_VAR 0 3
97522: PUSH
97523: LD_VAR 0 2
97527: PUSH
97528: LD_INT 1
97530: PPUSH
97531: LD_VAR 0 2
97535: PPUSH
97536: CALL_OW 12
97540: ARRAY
97541: ST_TO_ADDR
// if Crawls ( un ) then
97542: LD_VAR 0 3
97546: PPUSH
97547: CALL_OW 318
97551: IFFALSE 97562
// ComWalk ( un ) ;
97553: LD_VAR 0 3
97557: PPUSH
97558: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97562: LD_VAR 0 3
97566: PPUSH
97567: LD_INT 8
97569: PPUSH
97570: CALL_OW 336
// end ; 4 :
97574: GO 97680
97576: LD_INT 4
97578: DOUBLE
97579: EQUAL
97580: IFTRUE 97584
97582: GO 97658
97584: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97585: LD_ADDR_VAR 0 2
97589: PUSH
97590: LD_INT 22
97592: PUSH
97593: LD_OWVAR 2
97597: PUSH
97598: EMPTY
97599: LIST
97600: LIST
97601: PUSH
97602: LD_INT 30
97604: PUSH
97605: LD_INT 29
97607: PUSH
97608: EMPTY
97609: LIST
97610: LIST
97611: PUSH
97612: EMPTY
97613: LIST
97614: LIST
97615: PPUSH
97616: CALL_OW 69
97620: ST_TO_ADDR
// if not tmp then
97621: LD_VAR 0 2
97625: NOT
97626: IFFALSE 97630
// exit ;
97628: GO 97680
// CenterNowOnUnits ( tmp [ 1 ] ) ;
97630: LD_VAR 0 2
97634: PUSH
97635: LD_INT 1
97637: ARRAY
97638: PPUSH
97639: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
97643: LD_VAR 0 2
97647: PUSH
97648: LD_INT 1
97650: ARRAY
97651: PPUSH
97652: CALL_OW 65
// end ; 5 .. 7 :
97656: GO 97680
97658: LD_INT 5
97660: DOUBLE
97661: GREATEREQUAL
97662: IFFALSE 97670
97664: LD_INT 7
97666: DOUBLE
97667: LESSEQUAL
97668: IFTRUE 97672
97670: GO 97679
97672: POP
// StreamSibBomb ; end ;
97673: CALL 93917 0 0
97677: GO 97680
97679: POP
// end ;
97680: PPOPN 3
97682: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97683: LD_EXP 124
97687: PUSH
97688: LD_EXP 174
97692: AND
97693: IFFALSE 97849
97695: GO 97697
97697: DISABLE
97698: LD_INT 0
97700: PPUSH
97701: PPUSH
97702: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97703: LD_ADDR_VAR 0 2
97707: PUSH
97708: LD_INT 81
97710: PUSH
97711: LD_OWVAR 2
97715: PUSH
97716: EMPTY
97717: LIST
97718: LIST
97719: PUSH
97720: LD_INT 2
97722: PUSH
97723: LD_INT 21
97725: PUSH
97726: LD_INT 1
97728: PUSH
97729: EMPTY
97730: LIST
97731: LIST
97732: PUSH
97733: LD_INT 21
97735: PUSH
97736: LD_INT 2
97738: PUSH
97739: EMPTY
97740: LIST
97741: LIST
97742: PUSH
97743: EMPTY
97744: LIST
97745: LIST
97746: LIST
97747: PUSH
97748: EMPTY
97749: LIST
97750: LIST
97751: PPUSH
97752: CALL_OW 69
97756: ST_TO_ADDR
// if not tmp then
97757: LD_VAR 0 2
97761: NOT
97762: IFFALSE 97766
// exit ;
97764: GO 97849
// p := 0 ;
97766: LD_ADDR_VAR 0 3
97770: PUSH
97771: LD_INT 0
97773: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97774: LD_INT 35
97776: PPUSH
97777: CALL_OW 67
// p := p + 1 ;
97781: LD_ADDR_VAR 0 3
97785: PUSH
97786: LD_VAR 0 3
97790: PUSH
97791: LD_INT 1
97793: PLUS
97794: ST_TO_ADDR
// for i in tmp do
97795: LD_ADDR_VAR 0 1
97799: PUSH
97800: LD_VAR 0 2
97804: PUSH
97805: FOR_IN
97806: IFFALSE 97837
// if GetLives ( i ) < 1000 then
97808: LD_VAR 0 1
97812: PPUSH
97813: CALL_OW 256
97817: PUSH
97818: LD_INT 1000
97820: LESS
97821: IFFALSE 97835
// SetLives ( i , 1000 ) ;
97823: LD_VAR 0 1
97827: PPUSH
97828: LD_INT 1000
97830: PPUSH
97831: CALL_OW 234
97835: GO 97805
97837: POP
97838: POP
// until p > 20 ;
97839: LD_VAR 0 3
97843: PUSH
97844: LD_INT 20
97846: GREATER
97847: IFFALSE 97774
// end ;
97849: PPOPN 3
97851: END
// every 0 0$1 trigger StreamModeActive and sTime do
97852: LD_EXP 124
97856: PUSH
97857: LD_EXP 175
97861: AND
97862: IFFALSE 97897
97864: GO 97866
97866: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97867: LD_INT 28
97869: PPUSH
97870: LD_OWVAR 2
97874: PPUSH
97875: LD_INT 2
97877: PPUSH
97878: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97882: LD_INT 30
97884: PPUSH
97885: LD_OWVAR 2
97889: PPUSH
97890: LD_INT 2
97892: PPUSH
97893: CALL_OW 322
// end ;
97897: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97898: LD_EXP 124
97902: PUSH
97903: LD_EXP 176
97907: AND
97908: IFFALSE 98029
97910: GO 97912
97912: DISABLE
97913: LD_INT 0
97915: PPUSH
97916: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97917: LD_ADDR_VAR 0 2
97921: PUSH
97922: LD_INT 22
97924: PUSH
97925: LD_OWVAR 2
97929: PUSH
97930: EMPTY
97931: LIST
97932: LIST
97933: PUSH
97934: LD_INT 21
97936: PUSH
97937: LD_INT 1
97939: PUSH
97940: EMPTY
97941: LIST
97942: LIST
97943: PUSH
97944: LD_INT 3
97946: PUSH
97947: LD_INT 23
97949: PUSH
97950: LD_INT 0
97952: PUSH
97953: EMPTY
97954: LIST
97955: LIST
97956: PUSH
97957: EMPTY
97958: LIST
97959: LIST
97960: PUSH
97961: EMPTY
97962: LIST
97963: LIST
97964: LIST
97965: PPUSH
97966: CALL_OW 69
97970: ST_TO_ADDR
// if not tmp then
97971: LD_VAR 0 2
97975: NOT
97976: IFFALSE 97980
// exit ;
97978: GO 98029
// for i in tmp do
97980: LD_ADDR_VAR 0 1
97984: PUSH
97985: LD_VAR 0 2
97989: PUSH
97990: FOR_IN
97991: IFFALSE 98027
// begin if Crawls ( i ) then
97993: LD_VAR 0 1
97997: PPUSH
97998: CALL_OW 318
98002: IFFALSE 98013
// ComWalk ( i ) ;
98004: LD_VAR 0 1
98008: PPUSH
98009: CALL_OW 138
// SetClass ( i , 2 ) ;
98013: LD_VAR 0 1
98017: PPUSH
98018: LD_INT 2
98020: PPUSH
98021: CALL_OW 336
// end ;
98025: GO 97990
98027: POP
98028: POP
// end ;
98029: PPOPN 2
98031: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98032: LD_EXP 124
98036: PUSH
98037: LD_EXP 177
98041: AND
98042: IFFALSE 98330
98044: GO 98046
98046: DISABLE
98047: LD_INT 0
98049: PPUSH
98050: PPUSH
98051: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98052: LD_OWVAR 2
98056: PPUSH
98057: LD_INT 9
98059: PPUSH
98060: LD_INT 1
98062: PPUSH
98063: LD_INT 1
98065: PPUSH
98066: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98070: LD_INT 9
98072: PPUSH
98073: LD_OWVAR 2
98077: PPUSH
98078: CALL_OW 343
// uc_side := 9 ;
98082: LD_ADDR_OWVAR 20
98086: PUSH
98087: LD_INT 9
98089: ST_TO_ADDR
// uc_nation := 2 ;
98090: LD_ADDR_OWVAR 21
98094: PUSH
98095: LD_INT 2
98097: ST_TO_ADDR
// hc_name := Dark Warrior ;
98098: LD_ADDR_OWVAR 26
98102: PUSH
98103: LD_STRING Dark Warrior
98105: ST_TO_ADDR
// hc_gallery :=  ;
98106: LD_ADDR_OWVAR 33
98110: PUSH
98111: LD_STRING 
98113: ST_TO_ADDR
// hc_noskilllimit := true ;
98114: LD_ADDR_OWVAR 76
98118: PUSH
98119: LD_INT 1
98121: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
98122: LD_ADDR_OWVAR 31
98126: PUSH
98127: LD_INT 30
98129: PUSH
98130: LD_INT 30
98132: PUSH
98133: LD_INT 30
98135: PUSH
98136: LD_INT 30
98138: PUSH
98139: EMPTY
98140: LIST
98141: LIST
98142: LIST
98143: LIST
98144: ST_TO_ADDR
// un := CreateHuman ;
98145: LD_ADDR_VAR 0 3
98149: PUSH
98150: CALL_OW 44
98154: ST_TO_ADDR
// hc_noskilllimit := false ;
98155: LD_ADDR_OWVAR 76
98159: PUSH
98160: LD_INT 0
98162: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98163: LD_VAR 0 3
98167: PPUSH
98168: LD_INT 1
98170: PPUSH
98171: CALL_OW 51
// ToLua ( playRanger() ) ;
98175: LD_STRING playRanger()
98177: PPUSH
98178: CALL_OW 559
// p := 0 ;
98182: LD_ADDR_VAR 0 2
98186: PUSH
98187: LD_INT 0
98189: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98190: LD_INT 35
98192: PPUSH
98193: CALL_OW 67
// p := p + 1 ;
98197: LD_ADDR_VAR 0 2
98201: PUSH
98202: LD_VAR 0 2
98206: PUSH
98207: LD_INT 1
98209: PLUS
98210: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
98211: LD_VAR 0 3
98215: PPUSH
98216: CALL_OW 256
98220: PUSH
98221: LD_INT 1000
98223: LESS
98224: IFFALSE 98238
// SetLives ( un , 1000 ) ;
98226: LD_VAR 0 3
98230: PPUSH
98231: LD_INT 1000
98233: PPUSH
98234: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
98238: LD_VAR 0 3
98242: PPUSH
98243: LD_INT 81
98245: PUSH
98246: LD_OWVAR 2
98250: PUSH
98251: EMPTY
98252: LIST
98253: LIST
98254: PUSH
98255: LD_INT 91
98257: PUSH
98258: LD_VAR 0 3
98262: PUSH
98263: LD_INT 30
98265: PUSH
98266: EMPTY
98267: LIST
98268: LIST
98269: LIST
98270: PUSH
98271: EMPTY
98272: LIST
98273: LIST
98274: PPUSH
98275: CALL_OW 69
98279: PPUSH
98280: LD_VAR 0 3
98284: PPUSH
98285: CALL_OW 74
98289: PPUSH
98290: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
98294: LD_VAR 0 2
98298: PUSH
98299: LD_INT 80
98301: GREATER
98302: PUSH
98303: LD_VAR 0 3
98307: PPUSH
98308: CALL_OW 301
98312: OR
98313: IFFALSE 98190
// if un then
98315: LD_VAR 0 3
98319: IFFALSE 98330
// RemoveUnit ( un ) ;
98321: LD_VAR 0 3
98325: PPUSH
98326: CALL_OW 64
// end ;
98330: PPOPN 3
98332: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
98333: LD_EXP 178
98337: IFFALSE 98453
98339: GO 98341
98341: DISABLE
98342: LD_INT 0
98344: PPUSH
98345: PPUSH
98346: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98347: LD_ADDR_VAR 0 2
98351: PUSH
98352: LD_INT 81
98354: PUSH
98355: LD_OWVAR 2
98359: PUSH
98360: EMPTY
98361: LIST
98362: LIST
98363: PUSH
98364: LD_INT 21
98366: PUSH
98367: LD_INT 1
98369: PUSH
98370: EMPTY
98371: LIST
98372: LIST
98373: PUSH
98374: EMPTY
98375: LIST
98376: LIST
98377: PPUSH
98378: CALL_OW 69
98382: ST_TO_ADDR
// ToLua ( playComputer() ) ;
98383: LD_STRING playComputer()
98385: PPUSH
98386: CALL_OW 559
// if not tmp then
98390: LD_VAR 0 2
98394: NOT
98395: IFFALSE 98399
// exit ;
98397: GO 98453
// for i in tmp do
98399: LD_ADDR_VAR 0 1
98403: PUSH
98404: LD_VAR 0 2
98408: PUSH
98409: FOR_IN
98410: IFFALSE 98451
// for j := 1 to 4 do
98412: LD_ADDR_VAR 0 3
98416: PUSH
98417: DOUBLE
98418: LD_INT 1
98420: DEC
98421: ST_TO_ADDR
98422: LD_INT 4
98424: PUSH
98425: FOR_TO
98426: IFFALSE 98447
// SetSkill ( i , j , 10 ) ;
98428: LD_VAR 0 1
98432: PPUSH
98433: LD_VAR 0 3
98437: PPUSH
98438: LD_INT 10
98440: PPUSH
98441: CALL_OW 237
98445: GO 98425
98447: POP
98448: POP
98449: GO 98409
98451: POP
98452: POP
// end ;
98453: PPOPN 3
98455: END
// every 0 0$1 trigger s30 do var i , tmp ;
98456: LD_EXP 179
98460: IFFALSE 98529
98462: GO 98464
98464: DISABLE
98465: LD_INT 0
98467: PPUSH
98468: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98469: LD_ADDR_VAR 0 2
98473: PUSH
98474: LD_INT 22
98476: PUSH
98477: LD_OWVAR 2
98481: PUSH
98482: EMPTY
98483: LIST
98484: LIST
98485: PPUSH
98486: CALL_OW 69
98490: ST_TO_ADDR
// if not tmp then
98491: LD_VAR 0 2
98495: NOT
98496: IFFALSE 98500
// exit ;
98498: GO 98529
// for i in tmp do
98500: LD_ADDR_VAR 0 1
98504: PUSH
98505: LD_VAR 0 2
98509: PUSH
98510: FOR_IN
98511: IFFALSE 98527
// SetLives ( i , 300 ) ;
98513: LD_VAR 0 1
98517: PPUSH
98518: LD_INT 300
98520: PPUSH
98521: CALL_OW 234
98525: GO 98510
98527: POP
98528: POP
// end ;
98529: PPOPN 2
98531: END
// every 0 0$1 trigger s60 do var i , tmp ;
98532: LD_EXP 180
98536: IFFALSE 98605
98538: GO 98540
98540: DISABLE
98541: LD_INT 0
98543: PPUSH
98544: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98545: LD_ADDR_VAR 0 2
98549: PUSH
98550: LD_INT 22
98552: PUSH
98553: LD_OWVAR 2
98557: PUSH
98558: EMPTY
98559: LIST
98560: LIST
98561: PPUSH
98562: CALL_OW 69
98566: ST_TO_ADDR
// if not tmp then
98567: LD_VAR 0 2
98571: NOT
98572: IFFALSE 98576
// exit ;
98574: GO 98605
// for i in tmp do
98576: LD_ADDR_VAR 0 1
98580: PUSH
98581: LD_VAR 0 2
98585: PUSH
98586: FOR_IN
98587: IFFALSE 98603
// SetLives ( i , 600 ) ;
98589: LD_VAR 0 1
98593: PPUSH
98594: LD_INT 600
98596: PPUSH
98597: CALL_OW 234
98601: GO 98586
98603: POP
98604: POP
// end ;
98605: PPOPN 2
98607: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
98608: LD_INT 0
98610: PPUSH
// case cmd of 301 :
98611: LD_VAR 0 1
98615: PUSH
98616: LD_INT 301
98618: DOUBLE
98619: EQUAL
98620: IFTRUE 98624
98622: GO 98656
98624: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
98625: LD_VAR 0 6
98629: PPUSH
98630: LD_VAR 0 7
98634: PPUSH
98635: LD_VAR 0 8
98639: PPUSH
98640: LD_VAR 0 4
98644: PPUSH
98645: LD_VAR 0 5
98649: PPUSH
98650: CALL 99857 0 5
98654: GO 98777
98656: LD_INT 302
98658: DOUBLE
98659: EQUAL
98660: IFTRUE 98664
98662: GO 98701
98664: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
98665: LD_VAR 0 6
98669: PPUSH
98670: LD_VAR 0 7
98674: PPUSH
98675: LD_VAR 0 8
98679: PPUSH
98680: LD_VAR 0 9
98684: PPUSH
98685: LD_VAR 0 4
98689: PPUSH
98690: LD_VAR 0 5
98694: PPUSH
98695: CALL 99948 0 6
98699: GO 98777
98701: LD_INT 303
98703: DOUBLE
98704: EQUAL
98705: IFTRUE 98709
98707: GO 98746
98709: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
98710: LD_VAR 0 6
98714: PPUSH
98715: LD_VAR 0 7
98719: PPUSH
98720: LD_VAR 0 8
98724: PPUSH
98725: LD_VAR 0 9
98729: PPUSH
98730: LD_VAR 0 4
98734: PPUSH
98735: LD_VAR 0 5
98739: PPUSH
98740: CALL 98782 0 6
98744: GO 98777
98746: LD_INT 304
98748: DOUBLE
98749: EQUAL
98750: IFTRUE 98754
98752: GO 98776
98754: POP
// hHackTeleport ( unit , x , y ) ; end ;
98755: LD_VAR 0 2
98759: PPUSH
98760: LD_VAR 0 4
98764: PPUSH
98765: LD_VAR 0 5
98769: PPUSH
98770: CALL 100541 0 3
98774: GO 98777
98776: POP
// end ;
98777: LD_VAR 0 12
98781: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
98782: LD_INT 0
98784: PPUSH
98785: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
98786: LD_VAR 0 1
98790: PUSH
98791: LD_INT 1
98793: LESS
98794: PUSH
98795: LD_VAR 0 1
98799: PUSH
98800: LD_INT 3
98802: GREATER
98803: OR
98804: PUSH
98805: LD_VAR 0 5
98809: PPUSH
98810: LD_VAR 0 6
98814: PPUSH
98815: CALL_OW 428
98819: OR
98820: IFFALSE 98824
// exit ;
98822: GO 99544
// uc_side := your_side ;
98824: LD_ADDR_OWVAR 20
98828: PUSH
98829: LD_OWVAR 2
98833: ST_TO_ADDR
// uc_nation := nation ;
98834: LD_ADDR_OWVAR 21
98838: PUSH
98839: LD_VAR 0 1
98843: ST_TO_ADDR
// bc_level = 1 ;
98844: LD_ADDR_OWVAR 43
98848: PUSH
98849: LD_INT 1
98851: ST_TO_ADDR
// case btype of 1 :
98852: LD_VAR 0 2
98856: PUSH
98857: LD_INT 1
98859: DOUBLE
98860: EQUAL
98861: IFTRUE 98865
98863: GO 98876
98865: POP
// bc_type := b_depot ; 2 :
98866: LD_ADDR_OWVAR 42
98870: PUSH
98871: LD_INT 0
98873: ST_TO_ADDR
98874: GO 99488
98876: LD_INT 2
98878: DOUBLE
98879: EQUAL
98880: IFTRUE 98884
98882: GO 98895
98884: POP
// bc_type := b_warehouse ; 3 :
98885: LD_ADDR_OWVAR 42
98889: PUSH
98890: LD_INT 1
98892: ST_TO_ADDR
98893: GO 99488
98895: LD_INT 3
98897: DOUBLE
98898: EQUAL
98899: IFTRUE 98903
98901: GO 98914
98903: POP
// bc_type := b_lab ; 4 .. 9 :
98904: LD_ADDR_OWVAR 42
98908: PUSH
98909: LD_INT 6
98911: ST_TO_ADDR
98912: GO 99488
98914: LD_INT 4
98916: DOUBLE
98917: GREATEREQUAL
98918: IFFALSE 98926
98920: LD_INT 9
98922: DOUBLE
98923: LESSEQUAL
98924: IFTRUE 98928
98926: GO 98980
98928: POP
// begin bc_type := b_lab_half ;
98929: LD_ADDR_OWVAR 42
98933: PUSH
98934: LD_INT 7
98936: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
98937: LD_ADDR_OWVAR 44
98941: PUSH
98942: LD_INT 10
98944: PUSH
98945: LD_INT 11
98947: PUSH
98948: LD_INT 12
98950: PUSH
98951: LD_INT 15
98953: PUSH
98954: LD_INT 14
98956: PUSH
98957: LD_INT 13
98959: PUSH
98960: EMPTY
98961: LIST
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: PUSH
98968: LD_VAR 0 2
98972: PUSH
98973: LD_INT 3
98975: MINUS
98976: ARRAY
98977: ST_TO_ADDR
// end ; 10 .. 13 :
98978: GO 99488
98980: LD_INT 10
98982: DOUBLE
98983: GREATEREQUAL
98984: IFFALSE 98992
98986: LD_INT 13
98988: DOUBLE
98989: LESSEQUAL
98990: IFTRUE 98994
98992: GO 99071
98994: POP
// begin bc_type := b_lab_full ;
98995: LD_ADDR_OWVAR 42
98999: PUSH
99000: LD_INT 8
99002: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
99003: LD_ADDR_OWVAR 44
99007: PUSH
99008: LD_INT 10
99010: PUSH
99011: LD_INT 12
99013: PUSH
99014: LD_INT 14
99016: PUSH
99017: LD_INT 13
99019: PUSH
99020: EMPTY
99021: LIST
99022: LIST
99023: LIST
99024: LIST
99025: PUSH
99026: LD_VAR 0 2
99030: PUSH
99031: LD_INT 9
99033: MINUS
99034: ARRAY
99035: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
99036: LD_ADDR_OWVAR 45
99040: PUSH
99041: LD_INT 11
99043: PUSH
99044: LD_INT 15
99046: PUSH
99047: LD_INT 12
99049: PUSH
99050: LD_INT 15
99052: PUSH
99053: EMPTY
99054: LIST
99055: LIST
99056: LIST
99057: LIST
99058: PUSH
99059: LD_VAR 0 2
99063: PUSH
99064: LD_INT 9
99066: MINUS
99067: ARRAY
99068: ST_TO_ADDR
// end ; 14 :
99069: GO 99488
99071: LD_INT 14
99073: DOUBLE
99074: EQUAL
99075: IFTRUE 99079
99077: GO 99090
99079: POP
// bc_type := b_workshop ; 15 :
99080: LD_ADDR_OWVAR 42
99084: PUSH
99085: LD_INT 2
99087: ST_TO_ADDR
99088: GO 99488
99090: LD_INT 15
99092: DOUBLE
99093: EQUAL
99094: IFTRUE 99098
99096: GO 99109
99098: POP
// bc_type := b_factory ; 16 :
99099: LD_ADDR_OWVAR 42
99103: PUSH
99104: LD_INT 3
99106: ST_TO_ADDR
99107: GO 99488
99109: LD_INT 16
99111: DOUBLE
99112: EQUAL
99113: IFTRUE 99117
99115: GO 99128
99117: POP
// bc_type := b_ext_gun ; 17 :
99118: LD_ADDR_OWVAR 42
99122: PUSH
99123: LD_INT 17
99125: ST_TO_ADDR
99126: GO 99488
99128: LD_INT 17
99130: DOUBLE
99131: EQUAL
99132: IFTRUE 99136
99134: GO 99164
99136: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
99137: LD_ADDR_OWVAR 42
99141: PUSH
99142: LD_INT 19
99144: PUSH
99145: LD_INT 23
99147: PUSH
99148: LD_INT 19
99150: PUSH
99151: EMPTY
99152: LIST
99153: LIST
99154: LIST
99155: PUSH
99156: LD_VAR 0 1
99160: ARRAY
99161: ST_TO_ADDR
99162: GO 99488
99164: LD_INT 18
99166: DOUBLE
99167: EQUAL
99168: IFTRUE 99172
99170: GO 99183
99172: POP
// bc_type := b_ext_radar ; 19 :
99173: LD_ADDR_OWVAR 42
99177: PUSH
99178: LD_INT 20
99180: ST_TO_ADDR
99181: GO 99488
99183: LD_INT 19
99185: DOUBLE
99186: EQUAL
99187: IFTRUE 99191
99189: GO 99202
99191: POP
// bc_type := b_ext_radio ; 20 :
99192: LD_ADDR_OWVAR 42
99196: PUSH
99197: LD_INT 22
99199: ST_TO_ADDR
99200: GO 99488
99202: LD_INT 20
99204: DOUBLE
99205: EQUAL
99206: IFTRUE 99210
99208: GO 99221
99210: POP
// bc_type := b_ext_siberium ; 21 :
99211: LD_ADDR_OWVAR 42
99215: PUSH
99216: LD_INT 21
99218: ST_TO_ADDR
99219: GO 99488
99221: LD_INT 21
99223: DOUBLE
99224: EQUAL
99225: IFTRUE 99229
99227: GO 99240
99229: POP
// bc_type := b_ext_computer ; 22 :
99230: LD_ADDR_OWVAR 42
99234: PUSH
99235: LD_INT 24
99237: ST_TO_ADDR
99238: GO 99488
99240: LD_INT 22
99242: DOUBLE
99243: EQUAL
99244: IFTRUE 99248
99246: GO 99259
99248: POP
// bc_type := b_ext_track ; 23 :
99249: LD_ADDR_OWVAR 42
99253: PUSH
99254: LD_INT 16
99256: ST_TO_ADDR
99257: GO 99488
99259: LD_INT 23
99261: DOUBLE
99262: EQUAL
99263: IFTRUE 99267
99265: GO 99278
99267: POP
// bc_type := b_ext_laser ; 24 :
99268: LD_ADDR_OWVAR 42
99272: PUSH
99273: LD_INT 25
99275: ST_TO_ADDR
99276: GO 99488
99278: LD_INT 24
99280: DOUBLE
99281: EQUAL
99282: IFTRUE 99286
99284: GO 99297
99286: POP
// bc_type := b_control_tower ; 25 :
99287: LD_ADDR_OWVAR 42
99291: PUSH
99292: LD_INT 36
99294: ST_TO_ADDR
99295: GO 99488
99297: LD_INT 25
99299: DOUBLE
99300: EQUAL
99301: IFTRUE 99305
99303: GO 99316
99305: POP
// bc_type := b_breastwork ; 26 :
99306: LD_ADDR_OWVAR 42
99310: PUSH
99311: LD_INT 31
99313: ST_TO_ADDR
99314: GO 99488
99316: LD_INT 26
99318: DOUBLE
99319: EQUAL
99320: IFTRUE 99324
99322: GO 99335
99324: POP
// bc_type := b_bunker ; 27 :
99325: LD_ADDR_OWVAR 42
99329: PUSH
99330: LD_INT 32
99332: ST_TO_ADDR
99333: GO 99488
99335: LD_INT 27
99337: DOUBLE
99338: EQUAL
99339: IFTRUE 99343
99341: GO 99354
99343: POP
// bc_type := b_turret ; 28 :
99344: LD_ADDR_OWVAR 42
99348: PUSH
99349: LD_INT 33
99351: ST_TO_ADDR
99352: GO 99488
99354: LD_INT 28
99356: DOUBLE
99357: EQUAL
99358: IFTRUE 99362
99360: GO 99373
99362: POP
// bc_type := b_armoury ; 29 :
99363: LD_ADDR_OWVAR 42
99367: PUSH
99368: LD_INT 4
99370: ST_TO_ADDR
99371: GO 99488
99373: LD_INT 29
99375: DOUBLE
99376: EQUAL
99377: IFTRUE 99381
99379: GO 99392
99381: POP
// bc_type := b_barracks ; 30 :
99382: LD_ADDR_OWVAR 42
99386: PUSH
99387: LD_INT 5
99389: ST_TO_ADDR
99390: GO 99488
99392: LD_INT 30
99394: DOUBLE
99395: EQUAL
99396: IFTRUE 99400
99398: GO 99411
99400: POP
// bc_type := b_solar_power ; 31 :
99401: LD_ADDR_OWVAR 42
99405: PUSH
99406: LD_INT 27
99408: ST_TO_ADDR
99409: GO 99488
99411: LD_INT 31
99413: DOUBLE
99414: EQUAL
99415: IFTRUE 99419
99417: GO 99430
99419: POP
// bc_type := b_oil_power ; 32 :
99420: LD_ADDR_OWVAR 42
99424: PUSH
99425: LD_INT 26
99427: ST_TO_ADDR
99428: GO 99488
99430: LD_INT 32
99432: DOUBLE
99433: EQUAL
99434: IFTRUE 99438
99436: GO 99449
99438: POP
// bc_type := b_siberite_power ; 33 :
99439: LD_ADDR_OWVAR 42
99443: PUSH
99444: LD_INT 28
99446: ST_TO_ADDR
99447: GO 99488
99449: LD_INT 33
99451: DOUBLE
99452: EQUAL
99453: IFTRUE 99457
99455: GO 99468
99457: POP
// bc_type := b_oil_mine ; 34 :
99458: LD_ADDR_OWVAR 42
99462: PUSH
99463: LD_INT 29
99465: ST_TO_ADDR
99466: GO 99488
99468: LD_INT 34
99470: DOUBLE
99471: EQUAL
99472: IFTRUE 99476
99474: GO 99487
99476: POP
// bc_type := b_siberite_mine ; end ;
99477: LD_ADDR_OWVAR 42
99481: PUSH
99482: LD_INT 30
99484: ST_TO_ADDR
99485: GO 99488
99487: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
99488: LD_ADDR_VAR 0 8
99492: PUSH
99493: LD_VAR 0 5
99497: PPUSH
99498: LD_VAR 0 6
99502: PPUSH
99503: LD_VAR 0 3
99507: PPUSH
99508: CALL_OW 47
99512: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
99513: LD_OWVAR 42
99517: PUSH
99518: LD_INT 32
99520: PUSH
99521: LD_INT 33
99523: PUSH
99524: EMPTY
99525: LIST
99526: LIST
99527: IN
99528: IFFALSE 99544
// PlaceWeaponTurret ( b , weapon ) ;
99530: LD_VAR 0 8
99534: PPUSH
99535: LD_VAR 0 4
99539: PPUSH
99540: CALL_OW 431
// end ;
99544: LD_VAR 0 7
99548: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
99549: LD_INT 0
99551: PPUSH
99552: PPUSH
99553: PPUSH
99554: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99555: LD_ADDR_VAR 0 4
99559: PUSH
99560: LD_INT 22
99562: PUSH
99563: LD_OWVAR 2
99567: PUSH
99568: EMPTY
99569: LIST
99570: LIST
99571: PUSH
99572: LD_INT 2
99574: PUSH
99575: LD_INT 30
99577: PUSH
99578: LD_INT 0
99580: PUSH
99581: EMPTY
99582: LIST
99583: LIST
99584: PUSH
99585: LD_INT 30
99587: PUSH
99588: LD_INT 1
99590: PUSH
99591: EMPTY
99592: LIST
99593: LIST
99594: PUSH
99595: EMPTY
99596: LIST
99597: LIST
99598: LIST
99599: PUSH
99600: EMPTY
99601: LIST
99602: LIST
99603: PPUSH
99604: CALL_OW 69
99608: ST_TO_ADDR
// if not tmp then
99609: LD_VAR 0 4
99613: NOT
99614: IFFALSE 99618
// exit ;
99616: GO 99677
// for i in tmp do
99618: LD_ADDR_VAR 0 2
99622: PUSH
99623: LD_VAR 0 4
99627: PUSH
99628: FOR_IN
99629: IFFALSE 99675
// for j = 1 to 3 do
99631: LD_ADDR_VAR 0 3
99635: PUSH
99636: DOUBLE
99637: LD_INT 1
99639: DEC
99640: ST_TO_ADDR
99641: LD_INT 3
99643: PUSH
99644: FOR_TO
99645: IFFALSE 99671
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
99647: LD_VAR 0 2
99651: PPUSH
99652: CALL_OW 274
99656: PPUSH
99657: LD_VAR 0 3
99661: PPUSH
99662: LD_INT 99999
99664: PPUSH
99665: CALL_OW 277
99669: GO 99644
99671: POP
99672: POP
99673: GO 99628
99675: POP
99676: POP
// end ;
99677: LD_VAR 0 1
99681: RET
// export function hHackSetLevel10 ; var i , j ; begin
99682: LD_INT 0
99684: PPUSH
99685: PPUSH
99686: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99687: LD_ADDR_VAR 0 2
99691: PUSH
99692: LD_INT 21
99694: PUSH
99695: LD_INT 1
99697: PUSH
99698: EMPTY
99699: LIST
99700: LIST
99701: PPUSH
99702: CALL_OW 69
99706: PUSH
99707: FOR_IN
99708: IFFALSE 99760
// if IsSelected ( i ) then
99710: LD_VAR 0 2
99714: PPUSH
99715: CALL_OW 306
99719: IFFALSE 99758
// begin for j := 1 to 4 do
99721: LD_ADDR_VAR 0 3
99725: PUSH
99726: DOUBLE
99727: LD_INT 1
99729: DEC
99730: ST_TO_ADDR
99731: LD_INT 4
99733: PUSH
99734: FOR_TO
99735: IFFALSE 99756
// SetSkill ( i , j , 10 ) ;
99737: LD_VAR 0 2
99741: PPUSH
99742: LD_VAR 0 3
99746: PPUSH
99747: LD_INT 10
99749: PPUSH
99750: CALL_OW 237
99754: GO 99734
99756: POP
99757: POP
// end ;
99758: GO 99707
99760: POP
99761: POP
// end ;
99762: LD_VAR 0 1
99766: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
99767: LD_INT 0
99769: PPUSH
99770: PPUSH
99771: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
99772: LD_ADDR_VAR 0 2
99776: PUSH
99777: LD_INT 22
99779: PUSH
99780: LD_OWVAR 2
99784: PUSH
99785: EMPTY
99786: LIST
99787: LIST
99788: PUSH
99789: LD_INT 21
99791: PUSH
99792: LD_INT 1
99794: PUSH
99795: EMPTY
99796: LIST
99797: LIST
99798: PUSH
99799: EMPTY
99800: LIST
99801: LIST
99802: PPUSH
99803: CALL_OW 69
99807: PUSH
99808: FOR_IN
99809: IFFALSE 99850
// begin for j := 1 to 4 do
99811: LD_ADDR_VAR 0 3
99815: PUSH
99816: DOUBLE
99817: LD_INT 1
99819: DEC
99820: ST_TO_ADDR
99821: LD_INT 4
99823: PUSH
99824: FOR_TO
99825: IFFALSE 99846
// SetSkill ( i , j , 10 ) ;
99827: LD_VAR 0 2
99831: PPUSH
99832: LD_VAR 0 3
99836: PPUSH
99837: LD_INT 10
99839: PPUSH
99840: CALL_OW 237
99844: GO 99824
99846: POP
99847: POP
// end ;
99848: GO 99808
99850: POP
99851: POP
// end ;
99852: LD_VAR 0 1
99856: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
99857: LD_INT 0
99859: PPUSH
// uc_side := your_side ;
99860: LD_ADDR_OWVAR 20
99864: PUSH
99865: LD_OWVAR 2
99869: ST_TO_ADDR
// uc_nation := nation ;
99870: LD_ADDR_OWVAR 21
99874: PUSH
99875: LD_VAR 0 1
99879: ST_TO_ADDR
// InitHc ;
99880: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
99884: LD_INT 0
99886: PPUSH
99887: LD_VAR 0 2
99891: PPUSH
99892: LD_VAR 0 3
99896: PPUSH
99897: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
99901: LD_VAR 0 4
99905: PPUSH
99906: LD_VAR 0 5
99910: PPUSH
99911: CALL_OW 428
99915: PUSH
99916: LD_INT 0
99918: EQUAL
99919: IFFALSE 99943
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
99921: CALL_OW 44
99925: PPUSH
99926: LD_VAR 0 4
99930: PPUSH
99931: LD_VAR 0 5
99935: PPUSH
99936: LD_INT 1
99938: PPUSH
99939: CALL_OW 48
// end ;
99943: LD_VAR 0 6
99947: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
99948: LD_INT 0
99950: PPUSH
99951: PPUSH
// uc_side := your_side ;
99952: LD_ADDR_OWVAR 20
99956: PUSH
99957: LD_OWVAR 2
99961: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
99962: LD_VAR 0 1
99966: PUSH
99967: LD_INT 1
99969: PUSH
99970: LD_INT 2
99972: PUSH
99973: LD_INT 3
99975: PUSH
99976: LD_INT 4
99978: PUSH
99979: LD_INT 5
99981: PUSH
99982: EMPTY
99983: LIST
99984: LIST
99985: LIST
99986: LIST
99987: LIST
99988: IN
99989: IFFALSE 100001
// uc_nation := nation_american else
99991: LD_ADDR_OWVAR 21
99995: PUSH
99996: LD_INT 1
99998: ST_TO_ADDR
99999: GO 100044
// if chassis in [ 11 , 12 , 13 , 14 ] then
100001: LD_VAR 0 1
100005: PUSH
100006: LD_INT 11
100008: PUSH
100009: LD_INT 12
100011: PUSH
100012: LD_INT 13
100014: PUSH
100015: LD_INT 14
100017: PUSH
100018: EMPTY
100019: LIST
100020: LIST
100021: LIST
100022: LIST
100023: IN
100024: IFFALSE 100036
// uc_nation := nation_arabian else
100026: LD_ADDR_OWVAR 21
100030: PUSH
100031: LD_INT 2
100033: ST_TO_ADDR
100034: GO 100044
// uc_nation := nation_russian ;
100036: LD_ADDR_OWVAR 21
100040: PUSH
100041: LD_INT 3
100043: ST_TO_ADDR
// vc_chassis := chassis ;
100044: LD_ADDR_OWVAR 37
100048: PUSH
100049: LD_VAR 0 1
100053: ST_TO_ADDR
// vc_engine := engine ;
100054: LD_ADDR_OWVAR 39
100058: PUSH
100059: LD_VAR 0 2
100063: ST_TO_ADDR
// vc_control := control ;
100064: LD_ADDR_OWVAR 38
100068: PUSH
100069: LD_VAR 0 3
100073: ST_TO_ADDR
// vc_weapon := weapon ;
100074: LD_ADDR_OWVAR 40
100078: PUSH
100079: LD_VAR 0 4
100083: ST_TO_ADDR
// un := CreateVehicle ;
100084: LD_ADDR_VAR 0 8
100088: PUSH
100089: CALL_OW 45
100093: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
100094: LD_VAR 0 8
100098: PPUSH
100099: LD_INT 0
100101: PPUSH
100102: LD_INT 5
100104: PPUSH
100105: CALL_OW 12
100109: PPUSH
100110: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
100114: LD_VAR 0 8
100118: PPUSH
100119: LD_VAR 0 5
100123: PPUSH
100124: LD_VAR 0 6
100128: PPUSH
100129: LD_INT 1
100131: PPUSH
100132: CALL_OW 48
// end ;
100136: LD_VAR 0 7
100140: RET
// export hInvincible ; every 1 do
100141: GO 100143
100143: DISABLE
// hInvincible := [ ] ;
100144: LD_ADDR_EXP 181
100148: PUSH
100149: EMPTY
100150: ST_TO_ADDR
100151: END
// every 10 do var i ;
100152: GO 100154
100154: DISABLE
100155: LD_INT 0
100157: PPUSH
// begin enable ;
100158: ENABLE
// if not hInvincible then
100159: LD_EXP 181
100163: NOT
100164: IFFALSE 100168
// exit ;
100166: GO 100212
// for i in hInvincible do
100168: LD_ADDR_VAR 0 1
100172: PUSH
100173: LD_EXP 181
100177: PUSH
100178: FOR_IN
100179: IFFALSE 100210
// if GetLives ( i ) < 1000 then
100181: LD_VAR 0 1
100185: PPUSH
100186: CALL_OW 256
100190: PUSH
100191: LD_INT 1000
100193: LESS
100194: IFFALSE 100208
// SetLives ( i , 1000 ) ;
100196: LD_VAR 0 1
100200: PPUSH
100201: LD_INT 1000
100203: PPUSH
100204: CALL_OW 234
100208: GO 100178
100210: POP
100211: POP
// end ;
100212: PPOPN 1
100214: END
// export function hHackInvincible ; var i ; begin
100215: LD_INT 0
100217: PPUSH
100218: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
100219: LD_ADDR_VAR 0 2
100223: PUSH
100224: LD_INT 2
100226: PUSH
100227: LD_INT 21
100229: PUSH
100230: LD_INT 1
100232: PUSH
100233: EMPTY
100234: LIST
100235: LIST
100236: PUSH
100237: LD_INT 21
100239: PUSH
100240: LD_INT 2
100242: PUSH
100243: EMPTY
100244: LIST
100245: LIST
100246: PUSH
100247: EMPTY
100248: LIST
100249: LIST
100250: LIST
100251: PPUSH
100252: CALL_OW 69
100256: PUSH
100257: FOR_IN
100258: IFFALSE 100319
// if IsSelected ( i ) then
100260: LD_VAR 0 2
100264: PPUSH
100265: CALL_OW 306
100269: IFFALSE 100317
// begin if i in hInvincible then
100271: LD_VAR 0 2
100275: PUSH
100276: LD_EXP 181
100280: IN
100281: IFFALSE 100301
// hInvincible := hInvincible diff i else
100283: LD_ADDR_EXP 181
100287: PUSH
100288: LD_EXP 181
100292: PUSH
100293: LD_VAR 0 2
100297: DIFF
100298: ST_TO_ADDR
100299: GO 100317
// hInvincible := hInvincible union i ;
100301: LD_ADDR_EXP 181
100305: PUSH
100306: LD_EXP 181
100310: PUSH
100311: LD_VAR 0 2
100315: UNION
100316: ST_TO_ADDR
// end ;
100317: GO 100257
100319: POP
100320: POP
// end ;
100321: LD_VAR 0 1
100325: RET
// export function hHackInvisible ; var i , j ; begin
100326: LD_INT 0
100328: PPUSH
100329: PPUSH
100330: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100331: LD_ADDR_VAR 0 2
100335: PUSH
100336: LD_INT 21
100338: PUSH
100339: LD_INT 1
100341: PUSH
100342: EMPTY
100343: LIST
100344: LIST
100345: PPUSH
100346: CALL_OW 69
100350: PUSH
100351: FOR_IN
100352: IFFALSE 100376
// if IsSelected ( i ) then
100354: LD_VAR 0 2
100358: PPUSH
100359: CALL_OW 306
100363: IFFALSE 100374
// ComForceInvisible ( i ) ;
100365: LD_VAR 0 2
100369: PPUSH
100370: CALL_OW 496
100374: GO 100351
100376: POP
100377: POP
// end ;
100378: LD_VAR 0 1
100382: RET
// export function hHackChangeYourSide ; begin
100383: LD_INT 0
100385: PPUSH
// if your_side = 8 then
100386: LD_OWVAR 2
100390: PUSH
100391: LD_INT 8
100393: EQUAL
100394: IFFALSE 100406
// your_side := 0 else
100396: LD_ADDR_OWVAR 2
100400: PUSH
100401: LD_INT 0
100403: ST_TO_ADDR
100404: GO 100420
// your_side := your_side + 1 ;
100406: LD_ADDR_OWVAR 2
100410: PUSH
100411: LD_OWVAR 2
100415: PUSH
100416: LD_INT 1
100418: PLUS
100419: ST_TO_ADDR
// end ;
100420: LD_VAR 0 1
100424: RET
// export function hHackChangeUnitSide ; var i , j ; begin
100425: LD_INT 0
100427: PPUSH
100428: PPUSH
100429: PPUSH
// for i in all_units do
100430: LD_ADDR_VAR 0 2
100434: PUSH
100435: LD_OWVAR 3
100439: PUSH
100440: FOR_IN
100441: IFFALSE 100519
// if IsSelected ( i ) then
100443: LD_VAR 0 2
100447: PPUSH
100448: CALL_OW 306
100452: IFFALSE 100517
// begin j := GetSide ( i ) ;
100454: LD_ADDR_VAR 0 3
100458: PUSH
100459: LD_VAR 0 2
100463: PPUSH
100464: CALL_OW 255
100468: ST_TO_ADDR
// if j = 8 then
100469: LD_VAR 0 3
100473: PUSH
100474: LD_INT 8
100476: EQUAL
100477: IFFALSE 100489
// j := 0 else
100479: LD_ADDR_VAR 0 3
100483: PUSH
100484: LD_INT 0
100486: ST_TO_ADDR
100487: GO 100503
// j := j + 1 ;
100489: LD_ADDR_VAR 0 3
100493: PUSH
100494: LD_VAR 0 3
100498: PUSH
100499: LD_INT 1
100501: PLUS
100502: ST_TO_ADDR
// SetSide ( i , j ) ;
100503: LD_VAR 0 2
100507: PPUSH
100508: LD_VAR 0 3
100512: PPUSH
100513: CALL_OW 235
// end ;
100517: GO 100440
100519: POP
100520: POP
// end ;
100521: LD_VAR 0 1
100525: RET
// export function hHackFog ; begin
100526: LD_INT 0
100528: PPUSH
// FogOff ( true ) ;
100529: LD_INT 1
100531: PPUSH
100532: CALL_OW 344
// end ;
100536: LD_VAR 0 1
100540: RET
// export function hHackTeleport ( unit , x , y ) ; begin
100541: LD_INT 0
100543: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
100544: LD_VAR 0 1
100548: PPUSH
100549: LD_VAR 0 2
100553: PPUSH
100554: LD_VAR 0 3
100558: PPUSH
100559: LD_INT 1
100561: PPUSH
100562: LD_INT 1
100564: PPUSH
100565: CALL_OW 483
// CenterOnXY ( x , y ) ;
100569: LD_VAR 0 2
100573: PPUSH
100574: LD_VAR 0 3
100578: PPUSH
100579: CALL_OW 84
// end ; end_of_file
100583: LD_VAR 0 4
100587: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
100588: LD_INT 0
100590: PPUSH
100591: PPUSH
100592: PPUSH
100593: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
100594: LD_VAR 0 1
100598: PPUSH
100599: CALL_OW 264
100603: PUSH
100604: LD_EXP 108
100608: EQUAL
100609: IFFALSE 100681
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
100611: LD_INT 68
100613: PPUSH
100614: LD_VAR 0 1
100618: PPUSH
100619: CALL_OW 255
100623: PPUSH
100624: CALL_OW 321
100628: PUSH
100629: LD_INT 2
100631: EQUAL
100632: IFFALSE 100644
// eff := 70 else
100634: LD_ADDR_VAR 0 4
100638: PUSH
100639: LD_INT 70
100641: ST_TO_ADDR
100642: GO 100652
// eff := 30 ;
100644: LD_ADDR_VAR 0 4
100648: PUSH
100649: LD_INT 30
100651: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
100652: LD_VAR 0 1
100656: PPUSH
100657: CALL_OW 250
100661: PPUSH
100662: LD_VAR 0 1
100666: PPUSH
100667: CALL_OW 251
100671: PPUSH
100672: LD_VAR 0 4
100676: PPUSH
100677: CALL_OW 495
// end ; end ;
100681: LD_VAR 0 2
100685: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
100686: LD_INT 0
100688: PPUSH
// end ;
100689: LD_VAR 0 4
100693: RET
// export function SOS_Command ( cmd ) ; begin
100694: LD_INT 0
100696: PPUSH
// end ;
100697: LD_VAR 0 2
100701: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
100702: LD_INT 0
100704: PPUSH
// end ;
100705: LD_VAR 0 6
100709: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
100710: LD_INT 0
100712: PPUSH
100713: PPUSH
// if not vehicle or not factory then
100714: LD_VAR 0 1
100718: NOT
100719: PUSH
100720: LD_VAR 0 2
100724: NOT
100725: OR
100726: IFFALSE 100730
// exit ;
100728: GO 100961
// if factoryWaypoints >= factory then
100730: LD_EXP 182
100734: PUSH
100735: LD_VAR 0 2
100739: GREATEREQUAL
100740: IFFALSE 100961
// if factoryWaypoints [ factory ] then
100742: LD_EXP 182
100746: PUSH
100747: LD_VAR 0 2
100751: ARRAY
100752: IFFALSE 100961
// begin if GetControl ( vehicle ) = control_manual then
100754: LD_VAR 0 1
100758: PPUSH
100759: CALL_OW 263
100763: PUSH
100764: LD_INT 1
100766: EQUAL
100767: IFFALSE 100848
// begin driver := IsDrivenBy ( vehicle ) ;
100769: LD_ADDR_VAR 0 4
100773: PUSH
100774: LD_VAR 0 1
100778: PPUSH
100779: CALL_OW 311
100783: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
100784: LD_VAR 0 4
100788: PPUSH
100789: LD_EXP 182
100793: PUSH
100794: LD_VAR 0 2
100798: ARRAY
100799: PUSH
100800: LD_INT 3
100802: ARRAY
100803: PPUSH
100804: LD_EXP 182
100808: PUSH
100809: LD_VAR 0 2
100813: ARRAY
100814: PUSH
100815: LD_INT 4
100817: ARRAY
100818: PPUSH
100819: CALL_OW 171
// AddComExitVehicle ( driver ) ;
100823: LD_VAR 0 4
100827: PPUSH
100828: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
100832: LD_VAR 0 4
100836: PPUSH
100837: LD_VAR 0 2
100841: PPUSH
100842: CALL_OW 180
// end else
100846: GO 100961
// if GetControl ( vehicle ) = control_remote then
100848: LD_VAR 0 1
100852: PPUSH
100853: CALL_OW 263
100857: PUSH
100858: LD_INT 2
100860: EQUAL
100861: IFFALSE 100922
// begin wait ( 0 0$2 ) ;
100863: LD_INT 70
100865: PPUSH
100866: CALL_OW 67
// if Connect ( vehicle ) then
100870: LD_VAR 0 1
100874: PPUSH
100875: CALL 22974 0 1
100879: IFFALSE 100920
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
100881: LD_VAR 0 1
100885: PPUSH
100886: LD_EXP 182
100890: PUSH
100891: LD_VAR 0 2
100895: ARRAY
100896: PUSH
100897: LD_INT 3
100899: ARRAY
100900: PPUSH
100901: LD_EXP 182
100905: PUSH
100906: LD_VAR 0 2
100910: ARRAY
100911: PUSH
100912: LD_INT 4
100914: ARRAY
100915: PPUSH
100916: CALL_OW 171
// end else
100920: GO 100961
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
100922: LD_VAR 0 1
100926: PPUSH
100927: LD_EXP 182
100931: PUSH
100932: LD_VAR 0 2
100936: ARRAY
100937: PUSH
100938: LD_INT 3
100940: ARRAY
100941: PPUSH
100942: LD_EXP 182
100946: PUSH
100947: LD_VAR 0 2
100951: ARRAY
100952: PUSH
100953: LD_INT 4
100955: ARRAY
100956: PPUSH
100957: CALL_OW 171
// end ; end ;
100961: LD_VAR 0 3
100965: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
100966: LD_INT 0
100968: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
100969: LD_VAR 0 1
100973: PUSH
100974: LD_INT 250
100976: EQUAL
100977: PUSH
100978: LD_VAR 0 2
100982: PPUSH
100983: CALL_OW 264
100987: PUSH
100988: LD_EXP 111
100992: EQUAL
100993: AND
100994: IFFALSE 101015
// MinerPlaceMine ( unit , x , y ) ;
100996: LD_VAR 0 2
101000: PPUSH
101001: LD_VAR 0 4
101005: PPUSH
101006: LD_VAR 0 5
101010: PPUSH
101011: CALL 103743 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
101015: LD_VAR 0 1
101019: PUSH
101020: LD_INT 251
101022: EQUAL
101023: PUSH
101024: LD_VAR 0 2
101028: PPUSH
101029: CALL_OW 264
101033: PUSH
101034: LD_EXP 111
101038: EQUAL
101039: AND
101040: IFFALSE 101061
// MinerDetonateMine ( unit , x , y ) ;
101042: LD_VAR 0 2
101046: PPUSH
101047: LD_VAR 0 4
101051: PPUSH
101052: LD_VAR 0 5
101056: PPUSH
101057: CALL 104020 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
101061: LD_VAR 0 1
101065: PUSH
101066: LD_INT 252
101068: EQUAL
101069: PUSH
101070: LD_VAR 0 2
101074: PPUSH
101075: CALL_OW 264
101079: PUSH
101080: LD_EXP 111
101084: EQUAL
101085: AND
101086: IFFALSE 101107
// MinerCreateMinefield ( unit , x , y ) ;
101088: LD_VAR 0 2
101092: PPUSH
101093: LD_VAR 0 4
101097: PPUSH
101098: LD_VAR 0 5
101102: PPUSH
101103: CALL 104437 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
101107: LD_VAR 0 1
101111: PUSH
101112: LD_INT 253
101114: EQUAL
101115: PUSH
101116: LD_VAR 0 2
101120: PPUSH
101121: CALL_OW 257
101125: PUSH
101126: LD_INT 5
101128: EQUAL
101129: AND
101130: IFFALSE 101151
// ComBinocular ( unit , x , y ) ;
101132: LD_VAR 0 2
101136: PPUSH
101137: LD_VAR 0 4
101141: PPUSH
101142: LD_VAR 0 5
101146: PPUSH
101147: CALL 104808 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
101151: LD_VAR 0 1
101155: PUSH
101156: LD_INT 254
101158: EQUAL
101159: PUSH
101160: LD_VAR 0 2
101164: PPUSH
101165: CALL_OW 264
101169: PUSH
101170: LD_EXP 106
101174: EQUAL
101175: AND
101176: PUSH
101177: LD_VAR 0 3
101181: PPUSH
101182: CALL_OW 263
101186: PUSH
101187: LD_INT 3
101189: EQUAL
101190: AND
101191: IFFALSE 101207
// HackDestroyVehicle ( unit , selectedUnit ) ;
101193: LD_VAR 0 2
101197: PPUSH
101198: LD_VAR 0 3
101202: PPUSH
101203: CALL 103103 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
101207: LD_VAR 0 1
101211: PUSH
101212: LD_INT 255
101214: EQUAL
101215: PUSH
101216: LD_VAR 0 2
101220: PPUSH
101221: CALL_OW 264
101225: PUSH
101226: LD_INT 14
101228: PUSH
101229: LD_INT 53
101231: PUSH
101232: EMPTY
101233: LIST
101234: LIST
101235: IN
101236: AND
101237: PUSH
101238: LD_VAR 0 4
101242: PPUSH
101243: LD_VAR 0 5
101247: PPUSH
101248: CALL_OW 488
101252: AND
101253: IFFALSE 101277
// CutTreeXYR ( unit , x , y , 12 ) ;
101255: LD_VAR 0 2
101259: PPUSH
101260: LD_VAR 0 4
101264: PPUSH
101265: LD_VAR 0 5
101269: PPUSH
101270: LD_INT 12
101272: PPUSH
101273: CALL 101669 0 4
// if cmd = 256 then
101277: LD_VAR 0 1
101281: PUSH
101282: LD_INT 256
101284: EQUAL
101285: IFFALSE 101306
// SetFactoryWaypoint ( unit , x , y ) ;
101287: LD_VAR 0 2
101291: PPUSH
101292: LD_VAR 0 4
101296: PPUSH
101297: LD_VAR 0 5
101301: PPUSH
101302: CALL 101311 0 3
// end ;
101306: LD_VAR 0 6
101310: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
101311: LD_INT 0
101313: PPUSH
101314: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
101315: LD_VAR 0 1
101319: NOT
101320: PUSH
101321: LD_VAR 0 2
101325: PPUSH
101326: LD_VAR 0 3
101330: PPUSH
101331: CALL_OW 488
101335: NOT
101336: OR
101337: PUSH
101338: LD_VAR 0 1
101342: PPUSH
101343: CALL_OW 266
101347: PUSH
101348: LD_INT 3
101350: NONEQUAL
101351: PUSH
101352: LD_VAR 0 1
101356: PPUSH
101357: CALL_OW 247
101361: PUSH
101362: LD_INT 1
101364: EQUAL
101365: NOT
101366: AND
101367: OR
101368: IFFALSE 101372
// exit ;
101370: GO 101521
// if GetType ( factory ) = unit_human then
101372: LD_VAR 0 1
101376: PPUSH
101377: CALL_OW 247
101381: PUSH
101382: LD_INT 1
101384: EQUAL
101385: IFFALSE 101402
// factory := IsInUnit ( factory ) ;
101387: LD_ADDR_VAR 0 1
101391: PUSH
101392: LD_VAR 0 1
101396: PPUSH
101397: CALL_OW 310
101401: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
101402: LD_VAR 0 1
101406: PPUSH
101407: CALL_OW 266
101411: PUSH
101412: LD_INT 3
101414: NONEQUAL
101415: IFFALSE 101419
// exit ;
101417: GO 101521
// if HexInfo ( x , y ) = factory then
101419: LD_VAR 0 2
101423: PPUSH
101424: LD_VAR 0 3
101428: PPUSH
101429: CALL_OW 428
101433: PUSH
101434: LD_VAR 0 1
101438: EQUAL
101439: IFFALSE 101466
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
101441: LD_ADDR_EXP 182
101445: PUSH
101446: LD_EXP 182
101450: PPUSH
101451: LD_VAR 0 1
101455: PPUSH
101456: LD_INT 0
101458: PPUSH
101459: CALL_OW 1
101463: ST_TO_ADDR
101464: GO 101517
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
101466: LD_ADDR_EXP 182
101470: PUSH
101471: LD_EXP 182
101475: PPUSH
101476: LD_VAR 0 1
101480: PPUSH
101481: LD_VAR 0 1
101485: PPUSH
101486: CALL_OW 255
101490: PUSH
101491: LD_VAR 0 1
101495: PUSH
101496: LD_VAR 0 2
101500: PUSH
101501: LD_VAR 0 3
101505: PUSH
101506: EMPTY
101507: LIST
101508: LIST
101509: LIST
101510: LIST
101511: PPUSH
101512: CALL_OW 1
101516: ST_TO_ADDR
// UpdateFactoryWaypoints ;
101517: CALL 101526 0 0
// end ;
101521: LD_VAR 0 4
101525: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
101526: LD_INT 0
101528: PPUSH
101529: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
101530: LD_STRING resetFactoryWaypoint();
101532: PPUSH
101533: CALL_OW 559
// if factoryWaypoints then
101537: LD_EXP 182
101541: IFFALSE 101664
// begin for i := 1 to factoryWaypoints do
101543: LD_ADDR_VAR 0 2
101547: PUSH
101548: DOUBLE
101549: LD_INT 1
101551: DEC
101552: ST_TO_ADDR
101553: LD_EXP 182
101557: PUSH
101558: FOR_TO
101559: IFFALSE 101662
// if factoryWaypoints [ i ] then
101561: LD_EXP 182
101565: PUSH
101566: LD_VAR 0 2
101570: ARRAY
101571: IFFALSE 101660
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
101573: LD_STRING setFactoryWaypointXY(
101575: PUSH
101576: LD_EXP 182
101580: PUSH
101581: LD_VAR 0 2
101585: ARRAY
101586: PUSH
101587: LD_INT 1
101589: ARRAY
101590: STR
101591: PUSH
101592: LD_STRING ,
101594: STR
101595: PUSH
101596: LD_EXP 182
101600: PUSH
101601: LD_VAR 0 2
101605: ARRAY
101606: PUSH
101607: LD_INT 2
101609: ARRAY
101610: STR
101611: PUSH
101612: LD_STRING ,
101614: STR
101615: PUSH
101616: LD_EXP 182
101620: PUSH
101621: LD_VAR 0 2
101625: ARRAY
101626: PUSH
101627: LD_INT 3
101629: ARRAY
101630: STR
101631: PUSH
101632: LD_STRING ,
101634: STR
101635: PUSH
101636: LD_EXP 182
101640: PUSH
101641: LD_VAR 0 2
101645: ARRAY
101646: PUSH
101647: LD_INT 4
101649: ARRAY
101650: STR
101651: PUSH
101652: LD_STRING )
101654: STR
101655: PPUSH
101656: CALL_OW 559
101660: GO 101558
101662: POP
101663: POP
// end ; end ;
101664: LD_VAR 0 1
101668: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
101669: LD_INT 0
101671: PPUSH
101672: PPUSH
101673: PPUSH
101674: PPUSH
101675: PPUSH
101676: PPUSH
101677: PPUSH
101678: PPUSH
101679: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
101680: LD_VAR 0 1
101684: NOT
101685: PUSH
101686: LD_VAR 0 2
101690: PPUSH
101691: LD_VAR 0 3
101695: PPUSH
101696: CALL_OW 488
101700: NOT
101701: OR
101702: PUSH
101703: LD_VAR 0 4
101707: NOT
101708: OR
101709: IFFALSE 101713
// exit ;
101711: GO 102053
// list := [ ] ;
101713: LD_ADDR_VAR 0 13
101717: PUSH
101718: EMPTY
101719: ST_TO_ADDR
// if x - r < 0 then
101720: LD_VAR 0 2
101724: PUSH
101725: LD_VAR 0 4
101729: MINUS
101730: PUSH
101731: LD_INT 0
101733: LESS
101734: IFFALSE 101746
// min_x := 0 else
101736: LD_ADDR_VAR 0 7
101740: PUSH
101741: LD_INT 0
101743: ST_TO_ADDR
101744: GO 101762
// min_x := x - r ;
101746: LD_ADDR_VAR 0 7
101750: PUSH
101751: LD_VAR 0 2
101755: PUSH
101756: LD_VAR 0 4
101760: MINUS
101761: ST_TO_ADDR
// if y - r < 0 then
101762: LD_VAR 0 3
101766: PUSH
101767: LD_VAR 0 4
101771: MINUS
101772: PUSH
101773: LD_INT 0
101775: LESS
101776: IFFALSE 101788
// min_y := 0 else
101778: LD_ADDR_VAR 0 8
101782: PUSH
101783: LD_INT 0
101785: ST_TO_ADDR
101786: GO 101804
// min_y := y - r ;
101788: LD_ADDR_VAR 0 8
101792: PUSH
101793: LD_VAR 0 3
101797: PUSH
101798: LD_VAR 0 4
101802: MINUS
101803: ST_TO_ADDR
// max_x := x + r ;
101804: LD_ADDR_VAR 0 9
101808: PUSH
101809: LD_VAR 0 2
101813: PUSH
101814: LD_VAR 0 4
101818: PLUS
101819: ST_TO_ADDR
// max_y := y + r ;
101820: LD_ADDR_VAR 0 10
101824: PUSH
101825: LD_VAR 0 3
101829: PUSH
101830: LD_VAR 0 4
101834: PLUS
101835: ST_TO_ADDR
// for _x = min_x to max_x do
101836: LD_ADDR_VAR 0 11
101840: PUSH
101841: DOUBLE
101842: LD_VAR 0 7
101846: DEC
101847: ST_TO_ADDR
101848: LD_VAR 0 9
101852: PUSH
101853: FOR_TO
101854: IFFALSE 101971
// for _y = min_y to max_y do
101856: LD_ADDR_VAR 0 12
101860: PUSH
101861: DOUBLE
101862: LD_VAR 0 8
101866: DEC
101867: ST_TO_ADDR
101868: LD_VAR 0 10
101872: PUSH
101873: FOR_TO
101874: IFFALSE 101967
// begin if not ValidHex ( _x , _y ) then
101876: LD_VAR 0 11
101880: PPUSH
101881: LD_VAR 0 12
101885: PPUSH
101886: CALL_OW 488
101890: NOT
101891: IFFALSE 101895
// continue ;
101893: GO 101873
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
101895: LD_VAR 0 11
101899: PPUSH
101900: LD_VAR 0 12
101904: PPUSH
101905: CALL_OW 351
101909: PUSH
101910: LD_VAR 0 11
101914: PPUSH
101915: LD_VAR 0 12
101919: PPUSH
101920: CALL_OW 554
101924: AND
101925: IFFALSE 101965
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
101927: LD_ADDR_VAR 0 13
101931: PUSH
101932: LD_VAR 0 13
101936: PPUSH
101937: LD_VAR 0 13
101941: PUSH
101942: LD_INT 1
101944: PLUS
101945: PPUSH
101946: LD_VAR 0 11
101950: PUSH
101951: LD_VAR 0 12
101955: PUSH
101956: EMPTY
101957: LIST
101958: LIST
101959: PPUSH
101960: CALL_OW 2
101964: ST_TO_ADDR
// end ;
101965: GO 101873
101967: POP
101968: POP
101969: GO 101853
101971: POP
101972: POP
// if not list then
101973: LD_VAR 0 13
101977: NOT
101978: IFFALSE 101982
// exit ;
101980: GO 102053
// for i in list do
101982: LD_ADDR_VAR 0 6
101986: PUSH
101987: LD_VAR 0 13
101991: PUSH
101992: FOR_IN
101993: IFFALSE 102051
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
101995: LD_VAR 0 1
101999: PPUSH
102000: LD_STRING M
102002: PUSH
102003: LD_VAR 0 6
102007: PUSH
102008: LD_INT 1
102010: ARRAY
102011: PUSH
102012: LD_VAR 0 6
102016: PUSH
102017: LD_INT 2
102019: ARRAY
102020: PUSH
102021: LD_INT 0
102023: PUSH
102024: LD_INT 0
102026: PUSH
102027: LD_INT 0
102029: PUSH
102030: LD_INT 0
102032: PUSH
102033: EMPTY
102034: LIST
102035: LIST
102036: LIST
102037: LIST
102038: LIST
102039: LIST
102040: LIST
102041: PUSH
102042: EMPTY
102043: LIST
102044: PPUSH
102045: CALL_OW 447
102049: GO 101992
102051: POP
102052: POP
// end ;
102053: LD_VAR 0 5
102057: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
102058: LD_EXP 183
102062: NOT
102063: IFFALSE 102113
102065: GO 102067
102067: DISABLE
// begin initHack := true ;
102068: LD_ADDR_EXP 183
102072: PUSH
102073: LD_INT 1
102075: ST_TO_ADDR
// hackTanks := [ ] ;
102076: LD_ADDR_EXP 184
102080: PUSH
102081: EMPTY
102082: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
102083: LD_ADDR_EXP 185
102087: PUSH
102088: EMPTY
102089: ST_TO_ADDR
// hackLimit := 3 ;
102090: LD_ADDR_EXP 186
102094: PUSH
102095: LD_INT 3
102097: ST_TO_ADDR
// hackDist := 12 ;
102098: LD_ADDR_EXP 187
102102: PUSH
102103: LD_INT 12
102105: ST_TO_ADDR
// hackCounter := [ ] ;
102106: LD_ADDR_EXP 188
102110: PUSH
102111: EMPTY
102112: ST_TO_ADDR
// end ;
102113: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
102114: LD_EXP 183
102118: PUSH
102119: LD_INT 34
102121: PUSH
102122: LD_EXP 106
102126: PUSH
102127: EMPTY
102128: LIST
102129: LIST
102130: PPUSH
102131: CALL_OW 69
102135: AND
102136: IFFALSE 102391
102138: GO 102140
102140: DISABLE
102141: LD_INT 0
102143: PPUSH
102144: PPUSH
// begin enable ;
102145: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
102146: LD_ADDR_VAR 0 1
102150: PUSH
102151: LD_INT 34
102153: PUSH
102154: LD_EXP 106
102158: PUSH
102159: EMPTY
102160: LIST
102161: LIST
102162: PPUSH
102163: CALL_OW 69
102167: PUSH
102168: FOR_IN
102169: IFFALSE 102389
// begin if not i in hackTanks then
102171: LD_VAR 0 1
102175: PUSH
102176: LD_EXP 184
102180: IN
102181: NOT
102182: IFFALSE 102265
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
102184: LD_ADDR_EXP 184
102188: PUSH
102189: LD_EXP 184
102193: PPUSH
102194: LD_EXP 184
102198: PUSH
102199: LD_INT 1
102201: PLUS
102202: PPUSH
102203: LD_VAR 0 1
102207: PPUSH
102208: CALL_OW 1
102212: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
102213: LD_ADDR_EXP 185
102217: PUSH
102218: LD_EXP 185
102222: PPUSH
102223: LD_EXP 185
102227: PUSH
102228: LD_INT 1
102230: PLUS
102231: PPUSH
102232: EMPTY
102233: PPUSH
102234: CALL_OW 1
102238: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
102239: LD_ADDR_EXP 188
102243: PUSH
102244: LD_EXP 188
102248: PPUSH
102249: LD_EXP 188
102253: PUSH
102254: LD_INT 1
102256: PLUS
102257: PPUSH
102258: EMPTY
102259: PPUSH
102260: CALL_OW 1
102264: ST_TO_ADDR
// end ; if not IsOk ( i ) then
102265: LD_VAR 0 1
102269: PPUSH
102270: CALL_OW 302
102274: NOT
102275: IFFALSE 102288
// begin HackUnlinkAll ( i ) ;
102277: LD_VAR 0 1
102281: PPUSH
102282: CALL 102394 0 1
// continue ;
102286: GO 102168
// end ; HackCheckCapturedStatus ( i ) ;
102288: LD_VAR 0 1
102292: PPUSH
102293: CALL 102837 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
102297: LD_ADDR_VAR 0 2
102301: PUSH
102302: LD_INT 81
102304: PUSH
102305: LD_VAR 0 1
102309: PPUSH
102310: CALL_OW 255
102314: PUSH
102315: EMPTY
102316: LIST
102317: LIST
102318: PUSH
102319: LD_INT 33
102321: PUSH
102322: LD_INT 3
102324: PUSH
102325: EMPTY
102326: LIST
102327: LIST
102328: PUSH
102329: LD_INT 91
102331: PUSH
102332: LD_VAR 0 1
102336: PUSH
102337: LD_EXP 187
102341: PUSH
102342: EMPTY
102343: LIST
102344: LIST
102345: LIST
102346: PUSH
102347: LD_INT 50
102349: PUSH
102350: EMPTY
102351: LIST
102352: PUSH
102353: EMPTY
102354: LIST
102355: LIST
102356: LIST
102357: LIST
102358: PPUSH
102359: CALL_OW 69
102363: ST_TO_ADDR
// if not tmp then
102364: LD_VAR 0 2
102368: NOT
102369: IFFALSE 102373
// continue ;
102371: GO 102168
// HackLink ( i , tmp ) ;
102373: LD_VAR 0 1
102377: PPUSH
102378: LD_VAR 0 2
102382: PPUSH
102383: CALL 102530 0 2
// end ;
102387: GO 102168
102389: POP
102390: POP
// end ;
102391: PPOPN 2
102393: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
102394: LD_INT 0
102396: PPUSH
102397: PPUSH
102398: PPUSH
// if not hack in hackTanks then
102399: LD_VAR 0 1
102403: PUSH
102404: LD_EXP 184
102408: IN
102409: NOT
102410: IFFALSE 102414
// exit ;
102412: GO 102525
// index := GetElementIndex ( hackTanks , hack ) ;
102414: LD_ADDR_VAR 0 4
102418: PUSH
102419: LD_EXP 184
102423: PPUSH
102424: LD_VAR 0 1
102428: PPUSH
102429: CALL 19788 0 2
102433: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
102434: LD_EXP 185
102438: PUSH
102439: LD_VAR 0 4
102443: ARRAY
102444: IFFALSE 102525
// begin for i in hackTanksCaptured [ index ] do
102446: LD_ADDR_VAR 0 3
102450: PUSH
102451: LD_EXP 185
102455: PUSH
102456: LD_VAR 0 4
102460: ARRAY
102461: PUSH
102462: FOR_IN
102463: IFFALSE 102489
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
102465: LD_VAR 0 3
102469: PUSH
102470: LD_INT 1
102472: ARRAY
102473: PPUSH
102474: LD_VAR 0 3
102478: PUSH
102479: LD_INT 2
102481: ARRAY
102482: PPUSH
102483: CALL_OW 235
102487: GO 102462
102489: POP
102490: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
102491: LD_ADDR_EXP 185
102495: PUSH
102496: LD_EXP 185
102500: PPUSH
102501: LD_VAR 0 4
102505: PPUSH
102506: EMPTY
102507: PPUSH
102508: CALL_OW 1
102512: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
102513: LD_VAR 0 1
102517: PPUSH
102518: LD_INT 0
102520: PPUSH
102521: CALL_OW 505
// end ; end ;
102525: LD_VAR 0 2
102529: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
102530: LD_INT 0
102532: PPUSH
102533: PPUSH
102534: PPUSH
// if not hack in hackTanks or not vehicles then
102535: LD_VAR 0 1
102539: PUSH
102540: LD_EXP 184
102544: IN
102545: NOT
102546: PUSH
102547: LD_VAR 0 2
102551: NOT
102552: OR
102553: IFFALSE 102557
// exit ;
102555: GO 102832
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
102557: LD_ADDR_VAR 0 2
102561: PUSH
102562: LD_VAR 0 1
102566: PPUSH
102567: LD_VAR 0 2
102571: PPUSH
102572: LD_INT 1
102574: PPUSH
102575: LD_INT 1
102577: PPUSH
102578: CALL 20438 0 4
102582: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
102583: LD_ADDR_VAR 0 5
102587: PUSH
102588: LD_EXP 184
102592: PPUSH
102593: LD_VAR 0 1
102597: PPUSH
102598: CALL 19788 0 2
102602: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
102603: LD_EXP 185
102607: PUSH
102608: LD_VAR 0 5
102612: ARRAY
102613: PUSH
102614: LD_EXP 186
102618: LESS
102619: IFFALSE 102808
// begin for i := 1 to vehicles do
102621: LD_ADDR_VAR 0 4
102625: PUSH
102626: DOUBLE
102627: LD_INT 1
102629: DEC
102630: ST_TO_ADDR
102631: LD_VAR 0 2
102635: PUSH
102636: FOR_TO
102637: IFFALSE 102806
// begin if hackTanksCaptured [ index ] = hackLimit then
102639: LD_EXP 185
102643: PUSH
102644: LD_VAR 0 5
102648: ARRAY
102649: PUSH
102650: LD_EXP 186
102654: EQUAL
102655: IFFALSE 102659
// break ;
102657: GO 102806
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
102659: LD_ADDR_EXP 188
102663: PUSH
102664: LD_EXP 188
102668: PPUSH
102669: LD_VAR 0 5
102673: PPUSH
102674: LD_EXP 188
102678: PUSH
102679: LD_VAR 0 5
102683: ARRAY
102684: PUSH
102685: LD_INT 1
102687: PLUS
102688: PPUSH
102689: CALL_OW 1
102693: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
102694: LD_ADDR_EXP 185
102698: PUSH
102699: LD_EXP 185
102703: PPUSH
102704: LD_VAR 0 5
102708: PUSH
102709: LD_EXP 185
102713: PUSH
102714: LD_VAR 0 5
102718: ARRAY
102719: PUSH
102720: LD_INT 1
102722: PLUS
102723: PUSH
102724: EMPTY
102725: LIST
102726: LIST
102727: PPUSH
102728: LD_VAR 0 2
102732: PUSH
102733: LD_VAR 0 4
102737: ARRAY
102738: PUSH
102739: LD_VAR 0 2
102743: PUSH
102744: LD_VAR 0 4
102748: ARRAY
102749: PPUSH
102750: CALL_OW 255
102754: PUSH
102755: EMPTY
102756: LIST
102757: LIST
102758: PPUSH
102759: CALL 20003 0 3
102763: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
102764: LD_VAR 0 2
102768: PUSH
102769: LD_VAR 0 4
102773: ARRAY
102774: PPUSH
102775: LD_VAR 0 1
102779: PPUSH
102780: CALL_OW 255
102784: PPUSH
102785: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
102789: LD_VAR 0 2
102793: PUSH
102794: LD_VAR 0 4
102798: ARRAY
102799: PPUSH
102800: CALL_OW 141
// end ;
102804: GO 102636
102806: POP
102807: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102808: LD_VAR 0 1
102812: PPUSH
102813: LD_EXP 185
102817: PUSH
102818: LD_VAR 0 5
102822: ARRAY
102823: PUSH
102824: LD_INT 0
102826: PLUS
102827: PPUSH
102828: CALL_OW 505
// end ;
102832: LD_VAR 0 3
102836: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
102837: LD_INT 0
102839: PPUSH
102840: PPUSH
102841: PPUSH
102842: PPUSH
// if not hack in hackTanks then
102843: LD_VAR 0 1
102847: PUSH
102848: LD_EXP 184
102852: IN
102853: NOT
102854: IFFALSE 102858
// exit ;
102856: GO 103098
// index := GetElementIndex ( hackTanks , hack ) ;
102858: LD_ADDR_VAR 0 4
102862: PUSH
102863: LD_EXP 184
102867: PPUSH
102868: LD_VAR 0 1
102872: PPUSH
102873: CALL 19788 0 2
102877: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
102878: LD_ADDR_VAR 0 3
102882: PUSH
102883: DOUBLE
102884: LD_EXP 185
102888: PUSH
102889: LD_VAR 0 4
102893: ARRAY
102894: INC
102895: ST_TO_ADDR
102896: LD_INT 1
102898: PUSH
102899: FOR_DOWNTO
102900: IFFALSE 103072
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
102902: LD_ADDR_VAR 0 5
102906: PUSH
102907: LD_EXP 185
102911: PUSH
102912: LD_VAR 0 4
102916: ARRAY
102917: PUSH
102918: LD_VAR 0 3
102922: ARRAY
102923: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
102924: LD_VAR 0 5
102928: PUSH
102929: LD_INT 1
102931: ARRAY
102932: PPUSH
102933: CALL_OW 302
102937: NOT
102938: PUSH
102939: LD_VAR 0 5
102943: PUSH
102944: LD_INT 1
102946: ARRAY
102947: PPUSH
102948: CALL_OW 255
102952: PUSH
102953: LD_VAR 0 1
102957: PPUSH
102958: CALL_OW 255
102962: NONEQUAL
102963: OR
102964: IFFALSE 103070
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
102966: LD_VAR 0 5
102970: PUSH
102971: LD_INT 1
102973: ARRAY
102974: PPUSH
102975: CALL_OW 305
102979: PUSH
102980: LD_VAR 0 5
102984: PUSH
102985: LD_INT 1
102987: ARRAY
102988: PPUSH
102989: CALL_OW 255
102993: PUSH
102994: LD_VAR 0 1
102998: PPUSH
102999: CALL_OW 255
103003: EQUAL
103004: AND
103005: IFFALSE 103029
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
103007: LD_VAR 0 5
103011: PUSH
103012: LD_INT 1
103014: ARRAY
103015: PPUSH
103016: LD_VAR 0 5
103020: PUSH
103021: LD_INT 2
103023: ARRAY
103024: PPUSH
103025: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
103029: LD_ADDR_EXP 185
103033: PUSH
103034: LD_EXP 185
103038: PPUSH
103039: LD_VAR 0 4
103043: PPUSH
103044: LD_EXP 185
103048: PUSH
103049: LD_VAR 0 4
103053: ARRAY
103054: PPUSH
103055: LD_VAR 0 3
103059: PPUSH
103060: CALL_OW 3
103064: PPUSH
103065: CALL_OW 1
103069: ST_TO_ADDR
// end ; end ;
103070: GO 102899
103072: POP
103073: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103074: LD_VAR 0 1
103078: PPUSH
103079: LD_EXP 185
103083: PUSH
103084: LD_VAR 0 4
103088: ARRAY
103089: PUSH
103090: LD_INT 0
103092: PLUS
103093: PPUSH
103094: CALL_OW 505
// end ;
103098: LD_VAR 0 2
103102: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
103103: LD_INT 0
103105: PPUSH
103106: PPUSH
103107: PPUSH
103108: PPUSH
// if not hack in hackTanks then
103109: LD_VAR 0 1
103113: PUSH
103114: LD_EXP 184
103118: IN
103119: NOT
103120: IFFALSE 103124
// exit ;
103122: GO 103209
// index := GetElementIndex ( hackTanks , hack ) ;
103124: LD_ADDR_VAR 0 5
103128: PUSH
103129: LD_EXP 184
103133: PPUSH
103134: LD_VAR 0 1
103138: PPUSH
103139: CALL 19788 0 2
103143: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
103144: LD_ADDR_VAR 0 4
103148: PUSH
103149: DOUBLE
103150: LD_INT 1
103152: DEC
103153: ST_TO_ADDR
103154: LD_EXP 185
103158: PUSH
103159: LD_VAR 0 5
103163: ARRAY
103164: PUSH
103165: FOR_TO
103166: IFFALSE 103207
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
103168: LD_EXP 185
103172: PUSH
103173: LD_VAR 0 5
103177: ARRAY
103178: PUSH
103179: LD_VAR 0 4
103183: ARRAY
103184: PUSH
103185: LD_INT 1
103187: ARRAY
103188: PUSH
103189: LD_VAR 0 2
103193: EQUAL
103194: IFFALSE 103205
// KillUnit ( vehicle ) ;
103196: LD_VAR 0 2
103200: PPUSH
103201: CALL_OW 66
103205: GO 103165
103207: POP
103208: POP
// end ;
103209: LD_VAR 0 3
103213: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
103214: LD_EXP 189
103218: NOT
103219: IFFALSE 103254
103221: GO 103223
103223: DISABLE
// begin initMiner := true ;
103224: LD_ADDR_EXP 189
103228: PUSH
103229: LD_INT 1
103231: ST_TO_ADDR
// minersList := [ ] ;
103232: LD_ADDR_EXP 190
103236: PUSH
103237: EMPTY
103238: ST_TO_ADDR
// minerMinesList := [ ] ;
103239: LD_ADDR_EXP 191
103243: PUSH
103244: EMPTY
103245: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
103246: LD_ADDR_EXP 192
103250: PUSH
103251: LD_INT 5
103253: ST_TO_ADDR
// end ;
103254: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
103255: LD_EXP 189
103259: PUSH
103260: LD_INT 34
103262: PUSH
103263: LD_EXP 111
103267: PUSH
103268: EMPTY
103269: LIST
103270: LIST
103271: PPUSH
103272: CALL_OW 69
103276: AND
103277: IFFALSE 103740
103279: GO 103281
103281: DISABLE
103282: LD_INT 0
103284: PPUSH
103285: PPUSH
103286: PPUSH
103287: PPUSH
// begin enable ;
103288: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
103289: LD_ADDR_VAR 0 1
103293: PUSH
103294: LD_INT 34
103296: PUSH
103297: LD_EXP 111
103301: PUSH
103302: EMPTY
103303: LIST
103304: LIST
103305: PPUSH
103306: CALL_OW 69
103310: PUSH
103311: FOR_IN
103312: IFFALSE 103384
// begin if not i in minersList then
103314: LD_VAR 0 1
103318: PUSH
103319: LD_EXP 190
103323: IN
103324: NOT
103325: IFFALSE 103382
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
103327: LD_ADDR_EXP 190
103331: PUSH
103332: LD_EXP 190
103336: PPUSH
103337: LD_EXP 190
103341: PUSH
103342: LD_INT 1
103344: PLUS
103345: PPUSH
103346: LD_VAR 0 1
103350: PPUSH
103351: CALL_OW 1
103355: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
103356: LD_ADDR_EXP 191
103360: PUSH
103361: LD_EXP 191
103365: PPUSH
103366: LD_EXP 191
103370: PUSH
103371: LD_INT 1
103373: PLUS
103374: PPUSH
103375: EMPTY
103376: PPUSH
103377: CALL_OW 1
103381: ST_TO_ADDR
// end end ;
103382: GO 103311
103384: POP
103385: POP
// for i := minerMinesList downto 1 do
103386: LD_ADDR_VAR 0 1
103390: PUSH
103391: DOUBLE
103392: LD_EXP 191
103396: INC
103397: ST_TO_ADDR
103398: LD_INT 1
103400: PUSH
103401: FOR_DOWNTO
103402: IFFALSE 103738
// begin if IsLive ( minersList [ i ] ) then
103404: LD_EXP 190
103408: PUSH
103409: LD_VAR 0 1
103413: ARRAY
103414: PPUSH
103415: CALL_OW 300
103419: IFFALSE 103447
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
103421: LD_EXP 190
103425: PUSH
103426: LD_VAR 0 1
103430: ARRAY
103431: PPUSH
103432: LD_EXP 191
103436: PUSH
103437: LD_VAR 0 1
103441: ARRAY
103442: PPUSH
103443: CALL_OW 505
// if not minerMinesList [ i ] then
103447: LD_EXP 191
103451: PUSH
103452: LD_VAR 0 1
103456: ARRAY
103457: NOT
103458: IFFALSE 103462
// continue ;
103460: GO 103401
// for j := minerMinesList [ i ] downto 1 do
103462: LD_ADDR_VAR 0 2
103466: PUSH
103467: DOUBLE
103468: LD_EXP 191
103472: PUSH
103473: LD_VAR 0 1
103477: ARRAY
103478: INC
103479: ST_TO_ADDR
103480: LD_INT 1
103482: PUSH
103483: FOR_DOWNTO
103484: IFFALSE 103734
// begin side := GetSide ( minersList [ i ] ) ;
103486: LD_ADDR_VAR 0 3
103490: PUSH
103491: LD_EXP 190
103495: PUSH
103496: LD_VAR 0 1
103500: ARRAY
103501: PPUSH
103502: CALL_OW 255
103506: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
103507: LD_ADDR_VAR 0 4
103511: PUSH
103512: LD_EXP 191
103516: PUSH
103517: LD_VAR 0 1
103521: ARRAY
103522: PUSH
103523: LD_VAR 0 2
103527: ARRAY
103528: PUSH
103529: LD_INT 1
103531: ARRAY
103532: PPUSH
103533: LD_EXP 191
103537: PUSH
103538: LD_VAR 0 1
103542: ARRAY
103543: PUSH
103544: LD_VAR 0 2
103548: ARRAY
103549: PUSH
103550: LD_INT 2
103552: ARRAY
103553: PPUSH
103554: CALL_OW 428
103558: ST_TO_ADDR
// if not tmp then
103559: LD_VAR 0 4
103563: NOT
103564: IFFALSE 103568
// continue ;
103566: GO 103483
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
103568: LD_VAR 0 4
103572: PUSH
103573: LD_INT 81
103575: PUSH
103576: LD_VAR 0 3
103580: PUSH
103581: EMPTY
103582: LIST
103583: LIST
103584: PPUSH
103585: CALL_OW 69
103589: IN
103590: PUSH
103591: LD_EXP 191
103595: PUSH
103596: LD_VAR 0 1
103600: ARRAY
103601: PUSH
103602: LD_VAR 0 2
103606: ARRAY
103607: PUSH
103608: LD_INT 1
103610: ARRAY
103611: PPUSH
103612: LD_EXP 191
103616: PUSH
103617: LD_VAR 0 1
103621: ARRAY
103622: PUSH
103623: LD_VAR 0 2
103627: ARRAY
103628: PUSH
103629: LD_INT 2
103631: ARRAY
103632: PPUSH
103633: CALL_OW 458
103637: AND
103638: IFFALSE 103732
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
103640: LD_EXP 191
103644: PUSH
103645: LD_VAR 0 1
103649: ARRAY
103650: PUSH
103651: LD_VAR 0 2
103655: ARRAY
103656: PUSH
103657: LD_INT 1
103659: ARRAY
103660: PPUSH
103661: LD_EXP 191
103665: PUSH
103666: LD_VAR 0 1
103670: ARRAY
103671: PUSH
103672: LD_VAR 0 2
103676: ARRAY
103677: PUSH
103678: LD_INT 2
103680: ARRAY
103681: PPUSH
103682: LD_VAR 0 3
103686: PPUSH
103687: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
103691: LD_ADDR_EXP 191
103695: PUSH
103696: LD_EXP 191
103700: PPUSH
103701: LD_VAR 0 1
103705: PPUSH
103706: LD_EXP 191
103710: PUSH
103711: LD_VAR 0 1
103715: ARRAY
103716: PPUSH
103717: LD_VAR 0 2
103721: PPUSH
103722: CALL_OW 3
103726: PPUSH
103727: CALL_OW 1
103731: ST_TO_ADDR
// end ; end ;
103732: GO 103483
103734: POP
103735: POP
// end ;
103736: GO 103401
103738: POP
103739: POP
// end ;
103740: PPOPN 4
103742: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
103743: LD_INT 0
103745: PPUSH
103746: PPUSH
// result := false ;
103747: LD_ADDR_VAR 0 4
103751: PUSH
103752: LD_INT 0
103754: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
103755: LD_VAR 0 1
103759: PPUSH
103760: CALL_OW 264
103764: PUSH
103765: LD_EXP 111
103769: EQUAL
103770: NOT
103771: IFFALSE 103775
// exit ;
103773: GO 104015
// index := GetElementIndex ( minersList , unit ) ;
103775: LD_ADDR_VAR 0 5
103779: PUSH
103780: LD_EXP 190
103784: PPUSH
103785: LD_VAR 0 1
103789: PPUSH
103790: CALL 19788 0 2
103794: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
103795: LD_EXP 191
103799: PUSH
103800: LD_VAR 0 5
103804: ARRAY
103805: PUSH
103806: LD_EXP 192
103810: GREATEREQUAL
103811: IFFALSE 103815
// exit ;
103813: GO 104015
// ComMoveXY ( unit , x , y ) ;
103815: LD_VAR 0 1
103819: PPUSH
103820: LD_VAR 0 2
103824: PPUSH
103825: LD_VAR 0 3
103829: PPUSH
103830: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
103834: LD_INT 35
103836: PPUSH
103837: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
103841: LD_VAR 0 1
103845: PPUSH
103846: LD_VAR 0 2
103850: PPUSH
103851: LD_VAR 0 3
103855: PPUSH
103856: CALL 50507 0 3
103860: NOT
103861: PUSH
103862: LD_VAR 0 1
103866: PPUSH
103867: CALL_OW 314
103871: AND
103872: IFFALSE 103876
// exit ;
103874: GO 104015
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
103876: LD_VAR 0 2
103880: PPUSH
103881: LD_VAR 0 3
103885: PPUSH
103886: CALL_OW 428
103890: PUSH
103891: LD_VAR 0 1
103895: EQUAL
103896: PUSH
103897: LD_VAR 0 1
103901: PPUSH
103902: CALL_OW 314
103906: NOT
103907: AND
103908: IFFALSE 103834
// PlaySoundXY ( x , y , PlantMine ) ;
103910: LD_VAR 0 2
103914: PPUSH
103915: LD_VAR 0 3
103919: PPUSH
103920: LD_STRING PlantMine
103922: PPUSH
103923: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
103927: LD_VAR 0 2
103931: PPUSH
103932: LD_VAR 0 3
103936: PPUSH
103937: LD_VAR 0 1
103941: PPUSH
103942: CALL_OW 255
103946: PPUSH
103947: LD_INT 0
103949: PPUSH
103950: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
103954: LD_ADDR_EXP 191
103958: PUSH
103959: LD_EXP 191
103963: PPUSH
103964: LD_VAR 0 5
103968: PUSH
103969: LD_EXP 191
103973: PUSH
103974: LD_VAR 0 5
103978: ARRAY
103979: PUSH
103980: LD_INT 1
103982: PLUS
103983: PUSH
103984: EMPTY
103985: LIST
103986: LIST
103987: PPUSH
103988: LD_VAR 0 2
103992: PUSH
103993: LD_VAR 0 3
103997: PUSH
103998: EMPTY
103999: LIST
104000: LIST
104001: PPUSH
104002: CALL 20003 0 3
104006: ST_TO_ADDR
// result := true ;
104007: LD_ADDR_VAR 0 4
104011: PUSH
104012: LD_INT 1
104014: ST_TO_ADDR
// end ;
104015: LD_VAR 0 4
104019: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
104020: LD_INT 0
104022: PPUSH
104023: PPUSH
104024: PPUSH
// if not unit in minersList then
104025: LD_VAR 0 1
104029: PUSH
104030: LD_EXP 190
104034: IN
104035: NOT
104036: IFFALSE 104040
// exit ;
104038: GO 104432
// index := GetElementIndex ( minersList , unit ) ;
104040: LD_ADDR_VAR 0 6
104044: PUSH
104045: LD_EXP 190
104049: PPUSH
104050: LD_VAR 0 1
104054: PPUSH
104055: CALL 19788 0 2
104059: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
104060: LD_ADDR_VAR 0 5
104064: PUSH
104065: DOUBLE
104066: LD_EXP 191
104070: PUSH
104071: LD_VAR 0 6
104075: ARRAY
104076: INC
104077: ST_TO_ADDR
104078: LD_INT 1
104080: PUSH
104081: FOR_DOWNTO
104082: IFFALSE 104243
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
104084: LD_EXP 191
104088: PUSH
104089: LD_VAR 0 6
104093: ARRAY
104094: PUSH
104095: LD_VAR 0 5
104099: ARRAY
104100: PUSH
104101: LD_INT 1
104103: ARRAY
104104: PUSH
104105: LD_VAR 0 2
104109: EQUAL
104110: PUSH
104111: LD_EXP 191
104115: PUSH
104116: LD_VAR 0 6
104120: ARRAY
104121: PUSH
104122: LD_VAR 0 5
104126: ARRAY
104127: PUSH
104128: LD_INT 2
104130: ARRAY
104131: PUSH
104132: LD_VAR 0 3
104136: EQUAL
104137: AND
104138: IFFALSE 104241
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104140: LD_EXP 191
104144: PUSH
104145: LD_VAR 0 6
104149: ARRAY
104150: PUSH
104151: LD_VAR 0 5
104155: ARRAY
104156: PUSH
104157: LD_INT 1
104159: ARRAY
104160: PPUSH
104161: LD_EXP 191
104165: PUSH
104166: LD_VAR 0 6
104170: ARRAY
104171: PUSH
104172: LD_VAR 0 5
104176: ARRAY
104177: PUSH
104178: LD_INT 2
104180: ARRAY
104181: PPUSH
104182: LD_VAR 0 1
104186: PPUSH
104187: CALL_OW 255
104191: PPUSH
104192: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104196: LD_ADDR_EXP 191
104200: PUSH
104201: LD_EXP 191
104205: PPUSH
104206: LD_VAR 0 6
104210: PPUSH
104211: LD_EXP 191
104215: PUSH
104216: LD_VAR 0 6
104220: ARRAY
104221: PPUSH
104222: LD_VAR 0 5
104226: PPUSH
104227: CALL_OW 3
104231: PPUSH
104232: CALL_OW 1
104236: ST_TO_ADDR
// exit ;
104237: POP
104238: POP
104239: GO 104432
// end ; end ;
104241: GO 104081
104243: POP
104244: POP
// for i := minerMinesList [ index ] downto 1 do
104245: LD_ADDR_VAR 0 5
104249: PUSH
104250: DOUBLE
104251: LD_EXP 191
104255: PUSH
104256: LD_VAR 0 6
104260: ARRAY
104261: INC
104262: ST_TO_ADDR
104263: LD_INT 1
104265: PUSH
104266: FOR_DOWNTO
104267: IFFALSE 104430
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
104269: LD_EXP 191
104273: PUSH
104274: LD_VAR 0 6
104278: ARRAY
104279: PUSH
104280: LD_VAR 0 5
104284: ARRAY
104285: PUSH
104286: LD_INT 1
104288: ARRAY
104289: PPUSH
104290: LD_EXP 191
104294: PUSH
104295: LD_VAR 0 6
104299: ARRAY
104300: PUSH
104301: LD_VAR 0 5
104305: ARRAY
104306: PUSH
104307: LD_INT 2
104309: ARRAY
104310: PPUSH
104311: LD_VAR 0 2
104315: PPUSH
104316: LD_VAR 0 3
104320: PPUSH
104321: CALL_OW 298
104325: PUSH
104326: LD_INT 6
104328: LESS
104329: IFFALSE 104428
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104331: LD_EXP 191
104335: PUSH
104336: LD_VAR 0 6
104340: ARRAY
104341: PUSH
104342: LD_VAR 0 5
104346: ARRAY
104347: PUSH
104348: LD_INT 1
104350: ARRAY
104351: PPUSH
104352: LD_EXP 191
104356: PUSH
104357: LD_VAR 0 6
104361: ARRAY
104362: PUSH
104363: LD_VAR 0 5
104367: ARRAY
104368: PUSH
104369: LD_INT 2
104371: ARRAY
104372: PPUSH
104373: LD_VAR 0 1
104377: PPUSH
104378: CALL_OW 255
104382: PPUSH
104383: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104387: LD_ADDR_EXP 191
104391: PUSH
104392: LD_EXP 191
104396: PPUSH
104397: LD_VAR 0 6
104401: PPUSH
104402: LD_EXP 191
104406: PUSH
104407: LD_VAR 0 6
104411: ARRAY
104412: PPUSH
104413: LD_VAR 0 5
104417: PPUSH
104418: CALL_OW 3
104422: PPUSH
104423: CALL_OW 1
104427: ST_TO_ADDR
// end ; end ;
104428: GO 104266
104430: POP
104431: POP
// end ;
104432: LD_VAR 0 4
104436: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
104437: LD_INT 0
104439: PPUSH
104440: PPUSH
104441: PPUSH
104442: PPUSH
104443: PPUSH
104444: PPUSH
104445: PPUSH
104446: PPUSH
104447: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
104448: LD_VAR 0 1
104452: PPUSH
104453: CALL_OW 264
104457: PUSH
104458: LD_EXP 111
104462: EQUAL
104463: NOT
104464: PUSH
104465: LD_VAR 0 1
104469: PUSH
104470: LD_EXP 190
104474: IN
104475: NOT
104476: OR
104477: IFFALSE 104481
// exit ;
104479: GO 104803
// index := GetElementIndex ( minersList , unit ) ;
104481: LD_ADDR_VAR 0 6
104485: PUSH
104486: LD_EXP 190
104490: PPUSH
104491: LD_VAR 0 1
104495: PPUSH
104496: CALL 19788 0 2
104500: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
104501: LD_ADDR_VAR 0 8
104505: PUSH
104506: LD_EXP 192
104510: PUSH
104511: LD_EXP 191
104515: PUSH
104516: LD_VAR 0 6
104520: ARRAY
104521: MINUS
104522: ST_TO_ADDR
// if not minesFreeAmount then
104523: LD_VAR 0 8
104527: NOT
104528: IFFALSE 104532
// exit ;
104530: GO 104803
// tmp := [ ] ;
104532: LD_ADDR_VAR 0 7
104536: PUSH
104537: EMPTY
104538: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
104539: LD_ADDR_VAR 0 5
104543: PUSH
104544: DOUBLE
104545: LD_INT 1
104547: DEC
104548: ST_TO_ADDR
104549: LD_VAR 0 8
104553: PUSH
104554: FOR_TO
104555: IFFALSE 104750
// begin _d := rand ( 0 , 5 ) ;
104557: LD_ADDR_VAR 0 11
104561: PUSH
104562: LD_INT 0
104564: PPUSH
104565: LD_INT 5
104567: PPUSH
104568: CALL_OW 12
104572: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
104573: LD_ADDR_VAR 0 12
104577: PUSH
104578: LD_INT 2
104580: PPUSH
104581: LD_INT 6
104583: PPUSH
104584: CALL_OW 12
104588: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
104589: LD_ADDR_VAR 0 9
104593: PUSH
104594: LD_VAR 0 2
104598: PPUSH
104599: LD_VAR 0 11
104603: PPUSH
104604: LD_VAR 0 12
104608: PPUSH
104609: CALL_OW 272
104613: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
104614: LD_ADDR_VAR 0 10
104618: PUSH
104619: LD_VAR 0 3
104623: PPUSH
104624: LD_VAR 0 11
104628: PPUSH
104629: LD_VAR 0 12
104633: PPUSH
104634: CALL_OW 273
104638: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
104639: LD_VAR 0 9
104643: PPUSH
104644: LD_VAR 0 10
104648: PPUSH
104649: CALL_OW 488
104653: PUSH
104654: LD_VAR 0 9
104658: PUSH
104659: LD_VAR 0 10
104663: PUSH
104664: EMPTY
104665: LIST
104666: LIST
104667: PUSH
104668: LD_VAR 0 7
104672: IN
104673: NOT
104674: AND
104675: PUSH
104676: LD_VAR 0 9
104680: PPUSH
104681: LD_VAR 0 10
104685: PPUSH
104686: CALL_OW 458
104690: NOT
104691: AND
104692: IFFALSE 104734
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
104694: LD_ADDR_VAR 0 7
104698: PUSH
104699: LD_VAR 0 7
104703: PPUSH
104704: LD_VAR 0 7
104708: PUSH
104709: LD_INT 1
104711: PLUS
104712: PPUSH
104713: LD_VAR 0 9
104717: PUSH
104718: LD_VAR 0 10
104722: PUSH
104723: EMPTY
104724: LIST
104725: LIST
104726: PPUSH
104727: CALL_OW 1
104731: ST_TO_ADDR
104732: GO 104748
// i := i - 1 ;
104734: LD_ADDR_VAR 0 5
104738: PUSH
104739: LD_VAR 0 5
104743: PUSH
104744: LD_INT 1
104746: MINUS
104747: ST_TO_ADDR
// end ;
104748: GO 104554
104750: POP
104751: POP
// for i in tmp do
104752: LD_ADDR_VAR 0 5
104756: PUSH
104757: LD_VAR 0 7
104761: PUSH
104762: FOR_IN
104763: IFFALSE 104801
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
104765: LD_VAR 0 1
104769: PPUSH
104770: LD_VAR 0 5
104774: PUSH
104775: LD_INT 1
104777: ARRAY
104778: PPUSH
104779: LD_VAR 0 5
104783: PUSH
104784: LD_INT 2
104786: ARRAY
104787: PPUSH
104788: CALL 103743 0 3
104792: NOT
104793: IFFALSE 104799
// exit ;
104795: POP
104796: POP
104797: GO 104803
104799: GO 104762
104801: POP
104802: POP
// end ;
104803: LD_VAR 0 4
104807: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
104808: LD_INT 0
104810: PPUSH
104811: PPUSH
104812: PPUSH
104813: PPUSH
104814: PPUSH
104815: PPUSH
104816: PPUSH
// if not GetClass ( unit ) = class_sniper then
104817: LD_VAR 0 1
104821: PPUSH
104822: CALL_OW 257
104826: PUSH
104827: LD_INT 5
104829: EQUAL
104830: NOT
104831: IFFALSE 104835
// exit ;
104833: GO 105223
// dist := 8 ;
104835: LD_ADDR_VAR 0 5
104839: PUSH
104840: LD_INT 8
104842: ST_TO_ADDR
// viewRange := 12 ;
104843: LD_ADDR_VAR 0 7
104847: PUSH
104848: LD_INT 12
104850: ST_TO_ADDR
// side := GetSide ( unit ) ;
104851: LD_ADDR_VAR 0 6
104855: PUSH
104856: LD_VAR 0 1
104860: PPUSH
104861: CALL_OW 255
104865: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
104866: LD_INT 61
104868: PPUSH
104869: LD_VAR 0 6
104873: PPUSH
104874: CALL_OW 321
104878: PUSH
104879: LD_INT 2
104881: EQUAL
104882: IFFALSE 104892
// viewRange := 16 ;
104884: LD_ADDR_VAR 0 7
104888: PUSH
104889: LD_INT 16
104891: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
104892: LD_VAR 0 1
104896: PPUSH
104897: LD_VAR 0 2
104901: PPUSH
104902: LD_VAR 0 3
104906: PPUSH
104907: CALL_OW 297
104911: PUSH
104912: LD_VAR 0 5
104916: GREATER
104917: IFFALSE 104996
// begin ComMoveXY ( unit , x , y ) ;
104919: LD_VAR 0 1
104923: PPUSH
104924: LD_VAR 0 2
104928: PPUSH
104929: LD_VAR 0 3
104933: PPUSH
104934: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104938: LD_INT 35
104940: PPUSH
104941: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
104945: LD_VAR 0 1
104949: PPUSH
104950: LD_VAR 0 2
104954: PPUSH
104955: LD_VAR 0 3
104959: PPUSH
104960: CALL 50507 0 3
104964: NOT
104965: IFFALSE 104969
// exit ;
104967: GO 105223
// until GetDistUnitXY ( unit , x , y ) < dist ;
104969: LD_VAR 0 1
104973: PPUSH
104974: LD_VAR 0 2
104978: PPUSH
104979: LD_VAR 0 3
104983: PPUSH
104984: CALL_OW 297
104988: PUSH
104989: LD_VAR 0 5
104993: LESS
104994: IFFALSE 104938
// end ; ComTurnXY ( unit , x , y ) ;
104996: LD_VAR 0 1
105000: PPUSH
105001: LD_VAR 0 2
105005: PPUSH
105006: LD_VAR 0 3
105010: PPUSH
105011: CALL_OW 118
// wait ( 5 ) ;
105015: LD_INT 5
105017: PPUSH
105018: CALL_OW 67
// _d := GetDir ( unit ) ;
105022: LD_ADDR_VAR 0 10
105026: PUSH
105027: LD_VAR 0 1
105031: PPUSH
105032: CALL_OW 254
105036: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
105037: LD_ADDR_VAR 0 8
105041: PUSH
105042: LD_VAR 0 1
105046: PPUSH
105047: CALL_OW 250
105051: PPUSH
105052: LD_VAR 0 10
105056: PPUSH
105057: LD_VAR 0 5
105061: PPUSH
105062: CALL_OW 272
105066: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
105067: LD_ADDR_VAR 0 9
105071: PUSH
105072: LD_VAR 0 1
105076: PPUSH
105077: CALL_OW 251
105081: PPUSH
105082: LD_VAR 0 10
105086: PPUSH
105087: LD_VAR 0 5
105091: PPUSH
105092: CALL_OW 273
105096: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
105097: LD_VAR 0 8
105101: PPUSH
105102: LD_VAR 0 9
105106: PPUSH
105107: CALL_OW 488
105111: NOT
105112: IFFALSE 105116
// exit ;
105114: GO 105223
// ComAnimCustom ( unit , 1 ) ;
105116: LD_VAR 0 1
105120: PPUSH
105121: LD_INT 1
105123: PPUSH
105124: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
105128: LD_VAR 0 8
105132: PPUSH
105133: LD_VAR 0 9
105137: PPUSH
105138: LD_VAR 0 6
105142: PPUSH
105143: LD_VAR 0 7
105147: PPUSH
105148: CALL_OW 330
// repeat wait ( 1 ) ;
105152: LD_INT 1
105154: PPUSH
105155: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
105159: LD_VAR 0 1
105163: PPUSH
105164: CALL_OW 316
105168: PUSH
105169: LD_VAR 0 1
105173: PPUSH
105174: CALL_OW 314
105178: OR
105179: PUSH
105180: LD_VAR 0 1
105184: PPUSH
105185: CALL_OW 302
105189: NOT
105190: OR
105191: PUSH
105192: LD_VAR 0 1
105196: PPUSH
105197: CALL_OW 301
105201: OR
105202: IFFALSE 105152
// RemoveSeeing ( _x , _y , side ) ;
105204: LD_VAR 0 8
105208: PPUSH
105209: LD_VAR 0 9
105213: PPUSH
105214: LD_VAR 0 6
105218: PPUSH
105219: CALL_OW 331
// end ; end_of_file
105223: LD_VAR 0 4
105227: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
105228: LD_INT 0
105230: PPUSH
105231: PPUSH
105232: PPUSH
105233: PPUSH
105234: PPUSH
105235: PPUSH
105236: PPUSH
105237: PPUSH
105238: PPUSH
105239: PPUSH
105240: PPUSH
105241: PPUSH
105242: PPUSH
105243: PPUSH
105244: PPUSH
105245: PPUSH
105246: PPUSH
105247: PPUSH
105248: PPUSH
105249: PPUSH
105250: PPUSH
105251: PPUSH
105252: PPUSH
105253: PPUSH
105254: PPUSH
105255: PPUSH
105256: PPUSH
105257: PPUSH
105258: PPUSH
105259: PPUSH
105260: PPUSH
105261: PPUSH
105262: PPUSH
105263: PPUSH
// if not list then
105264: LD_VAR 0 1
105268: NOT
105269: IFFALSE 105273
// exit ;
105271: GO 109932
// base := list [ 1 ] ;
105273: LD_ADDR_VAR 0 3
105277: PUSH
105278: LD_VAR 0 1
105282: PUSH
105283: LD_INT 1
105285: ARRAY
105286: ST_TO_ADDR
// group := list [ 2 ] ;
105287: LD_ADDR_VAR 0 4
105291: PUSH
105292: LD_VAR 0 1
105296: PUSH
105297: LD_INT 2
105299: ARRAY
105300: ST_TO_ADDR
// path := list [ 3 ] ;
105301: LD_ADDR_VAR 0 5
105305: PUSH
105306: LD_VAR 0 1
105310: PUSH
105311: LD_INT 3
105313: ARRAY
105314: ST_TO_ADDR
// flags := list [ 4 ] ;
105315: LD_ADDR_VAR 0 6
105319: PUSH
105320: LD_VAR 0 1
105324: PUSH
105325: LD_INT 4
105327: ARRAY
105328: ST_TO_ADDR
// mined := [ ] ;
105329: LD_ADDR_VAR 0 27
105333: PUSH
105334: EMPTY
105335: ST_TO_ADDR
// bombed := [ ] ;
105336: LD_ADDR_VAR 0 28
105340: PUSH
105341: EMPTY
105342: ST_TO_ADDR
// healers := [ ] ;
105343: LD_ADDR_VAR 0 31
105347: PUSH
105348: EMPTY
105349: ST_TO_ADDR
// to_heal := [ ] ;
105350: LD_ADDR_VAR 0 30
105354: PUSH
105355: EMPTY
105356: ST_TO_ADDR
// repairs := [ ] ;
105357: LD_ADDR_VAR 0 33
105361: PUSH
105362: EMPTY
105363: ST_TO_ADDR
// to_repair := [ ] ;
105364: LD_ADDR_VAR 0 32
105368: PUSH
105369: EMPTY
105370: ST_TO_ADDR
// if not group or not path then
105371: LD_VAR 0 4
105375: NOT
105376: PUSH
105377: LD_VAR 0 5
105381: NOT
105382: OR
105383: IFFALSE 105387
// exit ;
105385: GO 109932
// side := GetSide ( group [ 1 ] ) ;
105387: LD_ADDR_VAR 0 35
105391: PUSH
105392: LD_VAR 0 4
105396: PUSH
105397: LD_INT 1
105399: ARRAY
105400: PPUSH
105401: CALL_OW 255
105405: ST_TO_ADDR
// if flags then
105406: LD_VAR 0 6
105410: IFFALSE 105554
// begin f_ignore_area := flags [ 1 ] ;
105412: LD_ADDR_VAR 0 17
105416: PUSH
105417: LD_VAR 0 6
105421: PUSH
105422: LD_INT 1
105424: ARRAY
105425: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
105426: LD_ADDR_VAR 0 18
105430: PUSH
105431: LD_VAR 0 6
105435: PUSH
105436: LD_INT 2
105438: ARRAY
105439: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
105440: LD_ADDR_VAR 0 19
105444: PUSH
105445: LD_VAR 0 6
105449: PUSH
105450: LD_INT 3
105452: ARRAY
105453: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
105454: LD_ADDR_VAR 0 20
105458: PUSH
105459: LD_VAR 0 6
105463: PUSH
105464: LD_INT 4
105466: ARRAY
105467: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
105468: LD_ADDR_VAR 0 21
105472: PUSH
105473: LD_VAR 0 6
105477: PUSH
105478: LD_INT 5
105480: ARRAY
105481: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
105482: LD_ADDR_VAR 0 22
105486: PUSH
105487: LD_VAR 0 6
105491: PUSH
105492: LD_INT 6
105494: ARRAY
105495: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
105496: LD_ADDR_VAR 0 23
105500: PUSH
105501: LD_VAR 0 6
105505: PUSH
105506: LD_INT 7
105508: ARRAY
105509: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
105510: LD_ADDR_VAR 0 24
105514: PUSH
105515: LD_VAR 0 6
105519: PUSH
105520: LD_INT 8
105522: ARRAY
105523: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
105524: LD_ADDR_VAR 0 25
105528: PUSH
105529: LD_VAR 0 6
105533: PUSH
105534: LD_INT 9
105536: ARRAY
105537: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
105538: LD_ADDR_VAR 0 26
105542: PUSH
105543: LD_VAR 0 6
105547: PUSH
105548: LD_INT 10
105550: ARRAY
105551: ST_TO_ADDR
// end else
105552: GO 105634
// begin f_ignore_area := false ;
105554: LD_ADDR_VAR 0 17
105558: PUSH
105559: LD_INT 0
105561: ST_TO_ADDR
// f_capture := false ;
105562: LD_ADDR_VAR 0 18
105566: PUSH
105567: LD_INT 0
105569: ST_TO_ADDR
// f_ignore_civ := false ;
105570: LD_ADDR_VAR 0 19
105574: PUSH
105575: LD_INT 0
105577: ST_TO_ADDR
// f_murder := false ;
105578: LD_ADDR_VAR 0 20
105582: PUSH
105583: LD_INT 0
105585: ST_TO_ADDR
// f_mines := false ;
105586: LD_ADDR_VAR 0 21
105590: PUSH
105591: LD_INT 0
105593: ST_TO_ADDR
// f_repair := false ;
105594: LD_ADDR_VAR 0 22
105598: PUSH
105599: LD_INT 0
105601: ST_TO_ADDR
// f_heal := false ;
105602: LD_ADDR_VAR 0 23
105606: PUSH
105607: LD_INT 0
105609: ST_TO_ADDR
// f_spacetime := false ;
105610: LD_ADDR_VAR 0 24
105614: PUSH
105615: LD_INT 0
105617: ST_TO_ADDR
// f_attack_depot := false ;
105618: LD_ADDR_VAR 0 25
105622: PUSH
105623: LD_INT 0
105625: ST_TO_ADDR
// f_crawl := false ;
105626: LD_ADDR_VAR 0 26
105630: PUSH
105631: LD_INT 0
105633: ST_TO_ADDR
// end ; if f_heal then
105634: LD_VAR 0 23
105638: IFFALSE 105665
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
105640: LD_ADDR_VAR 0 31
105644: PUSH
105645: LD_VAR 0 4
105649: PPUSH
105650: LD_INT 25
105652: PUSH
105653: LD_INT 4
105655: PUSH
105656: EMPTY
105657: LIST
105658: LIST
105659: PPUSH
105660: CALL_OW 72
105664: ST_TO_ADDR
// if f_repair then
105665: LD_VAR 0 22
105669: IFFALSE 105696
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
105671: LD_ADDR_VAR 0 33
105675: PUSH
105676: LD_VAR 0 4
105680: PPUSH
105681: LD_INT 25
105683: PUSH
105684: LD_INT 3
105686: PUSH
105687: EMPTY
105688: LIST
105689: LIST
105690: PPUSH
105691: CALL_OW 72
105695: ST_TO_ADDR
// units_path := [ ] ;
105696: LD_ADDR_VAR 0 16
105700: PUSH
105701: EMPTY
105702: ST_TO_ADDR
// for i = 1 to group do
105703: LD_ADDR_VAR 0 7
105707: PUSH
105708: DOUBLE
105709: LD_INT 1
105711: DEC
105712: ST_TO_ADDR
105713: LD_VAR 0 4
105717: PUSH
105718: FOR_TO
105719: IFFALSE 105748
// units_path := Replace ( units_path , i , path ) ;
105721: LD_ADDR_VAR 0 16
105725: PUSH
105726: LD_VAR 0 16
105730: PPUSH
105731: LD_VAR 0 7
105735: PPUSH
105736: LD_VAR 0 5
105740: PPUSH
105741: CALL_OW 1
105745: ST_TO_ADDR
105746: GO 105718
105748: POP
105749: POP
// repeat for i = group downto 1 do
105750: LD_ADDR_VAR 0 7
105754: PUSH
105755: DOUBLE
105756: LD_VAR 0 4
105760: INC
105761: ST_TO_ADDR
105762: LD_INT 1
105764: PUSH
105765: FOR_DOWNTO
105766: IFFALSE 109888
// begin wait ( 5 ) ;
105768: LD_INT 5
105770: PPUSH
105771: CALL_OW 67
// tmp := [ ] ;
105775: LD_ADDR_VAR 0 14
105779: PUSH
105780: EMPTY
105781: ST_TO_ADDR
// attacking := false ;
105782: LD_ADDR_VAR 0 29
105786: PUSH
105787: LD_INT 0
105789: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
105790: LD_VAR 0 4
105794: PUSH
105795: LD_VAR 0 7
105799: ARRAY
105800: PPUSH
105801: CALL_OW 301
105805: PUSH
105806: LD_VAR 0 4
105810: PUSH
105811: LD_VAR 0 7
105815: ARRAY
105816: NOT
105817: OR
105818: IFFALSE 105927
// begin if GetType ( group [ i ] ) = unit_human then
105820: LD_VAR 0 4
105824: PUSH
105825: LD_VAR 0 7
105829: ARRAY
105830: PPUSH
105831: CALL_OW 247
105835: PUSH
105836: LD_INT 1
105838: EQUAL
105839: IFFALSE 105885
// begin to_heal := to_heal diff group [ i ] ;
105841: LD_ADDR_VAR 0 30
105845: PUSH
105846: LD_VAR 0 30
105850: PUSH
105851: LD_VAR 0 4
105855: PUSH
105856: LD_VAR 0 7
105860: ARRAY
105861: DIFF
105862: ST_TO_ADDR
// healers := healers diff group [ i ] ;
105863: LD_ADDR_VAR 0 31
105867: PUSH
105868: LD_VAR 0 31
105872: PUSH
105873: LD_VAR 0 4
105877: PUSH
105878: LD_VAR 0 7
105882: ARRAY
105883: DIFF
105884: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
105885: LD_ADDR_VAR 0 4
105889: PUSH
105890: LD_VAR 0 4
105894: PPUSH
105895: LD_VAR 0 7
105899: PPUSH
105900: CALL_OW 3
105904: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
105905: LD_ADDR_VAR 0 16
105909: PUSH
105910: LD_VAR 0 16
105914: PPUSH
105915: LD_VAR 0 7
105919: PPUSH
105920: CALL_OW 3
105924: ST_TO_ADDR
// continue ;
105925: GO 105765
// end ; if f_repair then
105927: LD_VAR 0 22
105931: IFFALSE 106420
// begin if GetType ( group [ i ] ) = unit_vehicle then
105933: LD_VAR 0 4
105937: PUSH
105938: LD_VAR 0 7
105942: ARRAY
105943: PPUSH
105944: CALL_OW 247
105948: PUSH
105949: LD_INT 2
105951: EQUAL
105952: IFFALSE 106142
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
105954: LD_VAR 0 4
105958: PUSH
105959: LD_VAR 0 7
105963: ARRAY
105964: PPUSH
105965: CALL_OW 256
105969: PUSH
105970: LD_INT 700
105972: LESS
105973: PUSH
105974: LD_VAR 0 4
105978: PUSH
105979: LD_VAR 0 7
105983: ARRAY
105984: PUSH
105985: LD_VAR 0 32
105989: IN
105990: NOT
105991: AND
105992: IFFALSE 106016
// to_repair := to_repair union group [ i ] ;
105994: LD_ADDR_VAR 0 32
105998: PUSH
105999: LD_VAR 0 32
106003: PUSH
106004: LD_VAR 0 4
106008: PUSH
106009: LD_VAR 0 7
106013: ARRAY
106014: UNION
106015: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
106016: LD_VAR 0 4
106020: PUSH
106021: LD_VAR 0 7
106025: ARRAY
106026: PPUSH
106027: CALL_OW 256
106031: PUSH
106032: LD_INT 1000
106034: EQUAL
106035: PUSH
106036: LD_VAR 0 4
106040: PUSH
106041: LD_VAR 0 7
106045: ARRAY
106046: PUSH
106047: LD_VAR 0 32
106051: IN
106052: AND
106053: IFFALSE 106077
// to_repair := to_repair diff group [ i ] ;
106055: LD_ADDR_VAR 0 32
106059: PUSH
106060: LD_VAR 0 32
106064: PUSH
106065: LD_VAR 0 4
106069: PUSH
106070: LD_VAR 0 7
106074: ARRAY
106075: DIFF
106076: ST_TO_ADDR
// if group [ i ] in to_repair then
106077: LD_VAR 0 4
106081: PUSH
106082: LD_VAR 0 7
106086: ARRAY
106087: PUSH
106088: LD_VAR 0 32
106092: IN
106093: IFFALSE 106140
// begin if not IsInArea ( group [ i ] , f_repair ) then
106095: LD_VAR 0 4
106099: PUSH
106100: LD_VAR 0 7
106104: ARRAY
106105: PPUSH
106106: LD_VAR 0 22
106110: PPUSH
106111: CALL_OW 308
106115: NOT
106116: IFFALSE 106138
// ComMoveToArea ( group [ i ] , f_repair ) ;
106118: LD_VAR 0 4
106122: PUSH
106123: LD_VAR 0 7
106127: ARRAY
106128: PPUSH
106129: LD_VAR 0 22
106133: PPUSH
106134: CALL_OW 113
// continue ;
106138: GO 105765
// end ; end else
106140: GO 106420
// if group [ i ] in repairs then
106142: LD_VAR 0 4
106146: PUSH
106147: LD_VAR 0 7
106151: ARRAY
106152: PUSH
106153: LD_VAR 0 33
106157: IN
106158: IFFALSE 106420
// begin if IsInUnit ( group [ i ] ) then
106160: LD_VAR 0 4
106164: PUSH
106165: LD_VAR 0 7
106169: ARRAY
106170: PPUSH
106171: CALL_OW 310
106175: IFFALSE 106243
// begin z := IsInUnit ( group [ i ] ) ;
106177: LD_ADDR_VAR 0 13
106181: PUSH
106182: LD_VAR 0 4
106186: PUSH
106187: LD_VAR 0 7
106191: ARRAY
106192: PPUSH
106193: CALL_OW 310
106197: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
106198: LD_VAR 0 13
106202: PUSH
106203: LD_VAR 0 32
106207: IN
106208: PUSH
106209: LD_VAR 0 13
106213: PPUSH
106214: LD_VAR 0 22
106218: PPUSH
106219: CALL_OW 308
106223: AND
106224: IFFALSE 106241
// ComExitVehicle ( group [ i ] ) ;
106226: LD_VAR 0 4
106230: PUSH
106231: LD_VAR 0 7
106235: ARRAY
106236: PPUSH
106237: CALL_OW 121
// end else
106241: GO 106420
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
106243: LD_ADDR_VAR 0 13
106247: PUSH
106248: LD_VAR 0 4
106252: PPUSH
106253: LD_INT 95
106255: PUSH
106256: LD_VAR 0 22
106260: PUSH
106261: EMPTY
106262: LIST
106263: LIST
106264: PUSH
106265: LD_INT 58
106267: PUSH
106268: EMPTY
106269: LIST
106270: PUSH
106271: EMPTY
106272: LIST
106273: LIST
106274: PPUSH
106275: CALL_OW 72
106279: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
106280: LD_VAR 0 4
106284: PUSH
106285: LD_VAR 0 7
106289: ARRAY
106290: PPUSH
106291: CALL_OW 314
106295: NOT
106296: IFFALSE 106418
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
106298: LD_ADDR_VAR 0 10
106302: PUSH
106303: LD_VAR 0 13
106307: PPUSH
106308: LD_VAR 0 4
106312: PUSH
106313: LD_VAR 0 7
106317: ARRAY
106318: PPUSH
106319: CALL_OW 74
106323: ST_TO_ADDR
// if not x then
106324: LD_VAR 0 10
106328: NOT
106329: IFFALSE 106333
// continue ;
106331: GO 105765
// if GetLives ( x ) < 1000 then
106333: LD_VAR 0 10
106337: PPUSH
106338: CALL_OW 256
106342: PUSH
106343: LD_INT 1000
106345: LESS
106346: IFFALSE 106370
// ComRepairVehicle ( group [ i ] , x ) else
106348: LD_VAR 0 4
106352: PUSH
106353: LD_VAR 0 7
106357: ARRAY
106358: PPUSH
106359: LD_VAR 0 10
106363: PPUSH
106364: CALL_OW 129
106368: GO 106418
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
106370: LD_VAR 0 23
106374: PUSH
106375: LD_VAR 0 4
106379: PUSH
106380: LD_VAR 0 7
106384: ARRAY
106385: PPUSH
106386: CALL_OW 256
106390: PUSH
106391: LD_INT 1000
106393: LESS
106394: AND
106395: NOT
106396: IFFALSE 106418
// ComEnterUnit ( group [ i ] , x ) ;
106398: LD_VAR 0 4
106402: PUSH
106403: LD_VAR 0 7
106407: ARRAY
106408: PPUSH
106409: LD_VAR 0 10
106413: PPUSH
106414: CALL_OW 120
// end ; continue ;
106418: GO 105765
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
106420: LD_VAR 0 23
106424: PUSH
106425: LD_VAR 0 4
106429: PUSH
106430: LD_VAR 0 7
106434: ARRAY
106435: PPUSH
106436: CALL_OW 247
106440: PUSH
106441: LD_INT 1
106443: EQUAL
106444: AND
106445: IFFALSE 106923
// begin if group [ i ] in healers then
106447: LD_VAR 0 4
106451: PUSH
106452: LD_VAR 0 7
106456: ARRAY
106457: PUSH
106458: LD_VAR 0 31
106462: IN
106463: IFFALSE 106736
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
106465: LD_VAR 0 4
106469: PUSH
106470: LD_VAR 0 7
106474: ARRAY
106475: PPUSH
106476: LD_VAR 0 23
106480: PPUSH
106481: CALL_OW 308
106485: NOT
106486: PUSH
106487: LD_VAR 0 4
106491: PUSH
106492: LD_VAR 0 7
106496: ARRAY
106497: PPUSH
106498: CALL_OW 314
106502: NOT
106503: AND
106504: IFFALSE 106528
// ComMoveToArea ( group [ i ] , f_heal ) else
106506: LD_VAR 0 4
106510: PUSH
106511: LD_VAR 0 7
106515: ARRAY
106516: PPUSH
106517: LD_VAR 0 23
106521: PPUSH
106522: CALL_OW 113
106526: GO 106734
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
106528: LD_VAR 0 4
106532: PUSH
106533: LD_VAR 0 7
106537: ARRAY
106538: PPUSH
106539: CALL 49083 0 1
106543: PPUSH
106544: CALL_OW 256
106548: PUSH
106549: LD_INT 1000
106551: EQUAL
106552: IFFALSE 106571
// ComStop ( group [ i ] ) else
106554: LD_VAR 0 4
106558: PUSH
106559: LD_VAR 0 7
106563: ARRAY
106564: PPUSH
106565: CALL_OW 141
106569: GO 106734
// if not HasTask ( group [ i ] ) and to_heal then
106571: LD_VAR 0 4
106575: PUSH
106576: LD_VAR 0 7
106580: ARRAY
106581: PPUSH
106582: CALL_OW 314
106586: NOT
106587: PUSH
106588: LD_VAR 0 30
106592: AND
106593: IFFALSE 106734
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
106595: LD_ADDR_VAR 0 13
106599: PUSH
106600: LD_VAR 0 30
106604: PPUSH
106605: LD_INT 3
106607: PUSH
106608: LD_INT 54
106610: PUSH
106611: EMPTY
106612: LIST
106613: PUSH
106614: EMPTY
106615: LIST
106616: LIST
106617: PPUSH
106618: CALL_OW 72
106622: PPUSH
106623: LD_VAR 0 4
106627: PUSH
106628: LD_VAR 0 7
106632: ARRAY
106633: PPUSH
106634: CALL_OW 74
106638: ST_TO_ADDR
// if z then
106639: LD_VAR 0 13
106643: IFFALSE 106734
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
106645: LD_INT 91
106647: PUSH
106648: LD_VAR 0 13
106652: PUSH
106653: LD_INT 10
106655: PUSH
106656: EMPTY
106657: LIST
106658: LIST
106659: LIST
106660: PUSH
106661: LD_INT 81
106663: PUSH
106664: LD_VAR 0 13
106668: PPUSH
106669: CALL_OW 255
106673: PUSH
106674: EMPTY
106675: LIST
106676: LIST
106677: PUSH
106678: EMPTY
106679: LIST
106680: LIST
106681: PPUSH
106682: CALL_OW 69
106686: PUSH
106687: LD_INT 0
106689: EQUAL
106690: IFFALSE 106714
// ComHeal ( group [ i ] , z ) else
106692: LD_VAR 0 4
106696: PUSH
106697: LD_VAR 0 7
106701: ARRAY
106702: PPUSH
106703: LD_VAR 0 13
106707: PPUSH
106708: CALL_OW 128
106712: GO 106734
// ComMoveToArea ( group [ i ] , f_heal ) ;
106714: LD_VAR 0 4
106718: PUSH
106719: LD_VAR 0 7
106723: ARRAY
106724: PPUSH
106725: LD_VAR 0 23
106729: PPUSH
106730: CALL_OW 113
// end ; continue ;
106734: GO 105765
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
106736: LD_VAR 0 4
106740: PUSH
106741: LD_VAR 0 7
106745: ARRAY
106746: PPUSH
106747: CALL_OW 256
106751: PUSH
106752: LD_INT 700
106754: LESS
106755: PUSH
106756: LD_VAR 0 4
106760: PUSH
106761: LD_VAR 0 7
106765: ARRAY
106766: PUSH
106767: LD_VAR 0 30
106771: IN
106772: NOT
106773: AND
106774: IFFALSE 106798
// to_heal := to_heal union group [ i ] ;
106776: LD_ADDR_VAR 0 30
106780: PUSH
106781: LD_VAR 0 30
106785: PUSH
106786: LD_VAR 0 4
106790: PUSH
106791: LD_VAR 0 7
106795: ARRAY
106796: UNION
106797: ST_TO_ADDR
// if group [ i ] in to_heal then
106798: LD_VAR 0 4
106802: PUSH
106803: LD_VAR 0 7
106807: ARRAY
106808: PUSH
106809: LD_VAR 0 30
106813: IN
106814: IFFALSE 106923
// begin if GetLives ( group [ i ] ) = 1000 then
106816: LD_VAR 0 4
106820: PUSH
106821: LD_VAR 0 7
106825: ARRAY
106826: PPUSH
106827: CALL_OW 256
106831: PUSH
106832: LD_INT 1000
106834: EQUAL
106835: IFFALSE 106861
// to_heal := to_heal diff group [ i ] else
106837: LD_ADDR_VAR 0 30
106841: PUSH
106842: LD_VAR 0 30
106846: PUSH
106847: LD_VAR 0 4
106851: PUSH
106852: LD_VAR 0 7
106856: ARRAY
106857: DIFF
106858: ST_TO_ADDR
106859: GO 106923
// begin if not IsInArea ( group [ i ] , to_heal ) then
106861: LD_VAR 0 4
106865: PUSH
106866: LD_VAR 0 7
106870: ARRAY
106871: PPUSH
106872: LD_VAR 0 30
106876: PPUSH
106877: CALL_OW 308
106881: NOT
106882: IFFALSE 106906
// ComMoveToArea ( group [ i ] , f_heal ) else
106884: LD_VAR 0 4
106888: PUSH
106889: LD_VAR 0 7
106893: ARRAY
106894: PPUSH
106895: LD_VAR 0 23
106899: PPUSH
106900: CALL_OW 113
106904: GO 106921
// ComHold ( group [ i ] ) ;
106906: LD_VAR 0 4
106910: PUSH
106911: LD_VAR 0 7
106915: ARRAY
106916: PPUSH
106917: CALL_OW 140
// continue ;
106921: GO 105765
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
106923: LD_VAR 0 4
106927: PUSH
106928: LD_VAR 0 7
106932: ARRAY
106933: PPUSH
106934: LD_INT 10
106936: PPUSH
106937: CALL 47503 0 2
106941: NOT
106942: PUSH
106943: LD_VAR 0 16
106947: PUSH
106948: LD_VAR 0 7
106952: ARRAY
106953: PUSH
106954: EMPTY
106955: EQUAL
106956: NOT
106957: AND
106958: IFFALSE 107224
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
106960: LD_VAR 0 4
106964: PUSH
106965: LD_VAR 0 7
106969: ARRAY
106970: PPUSH
106971: CALL_OW 262
106975: PUSH
106976: LD_INT 1
106978: PUSH
106979: LD_INT 2
106981: PUSH
106982: EMPTY
106983: LIST
106984: LIST
106985: IN
106986: IFFALSE 107027
// if GetFuel ( group [ i ] ) < 10 then
106988: LD_VAR 0 4
106992: PUSH
106993: LD_VAR 0 7
106997: ARRAY
106998: PPUSH
106999: CALL_OW 261
107003: PUSH
107004: LD_INT 10
107006: LESS
107007: IFFALSE 107027
// SetFuel ( group [ i ] , 12 ) ;
107009: LD_VAR 0 4
107013: PUSH
107014: LD_VAR 0 7
107018: ARRAY
107019: PPUSH
107020: LD_INT 12
107022: PPUSH
107023: CALL_OW 240
// if units_path [ i ] then
107027: LD_VAR 0 16
107031: PUSH
107032: LD_VAR 0 7
107036: ARRAY
107037: IFFALSE 107222
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
107039: LD_VAR 0 4
107043: PUSH
107044: LD_VAR 0 7
107048: ARRAY
107049: PPUSH
107050: LD_VAR 0 16
107054: PUSH
107055: LD_VAR 0 7
107059: ARRAY
107060: PUSH
107061: LD_INT 1
107063: ARRAY
107064: PUSH
107065: LD_INT 1
107067: ARRAY
107068: PPUSH
107069: LD_VAR 0 16
107073: PUSH
107074: LD_VAR 0 7
107078: ARRAY
107079: PUSH
107080: LD_INT 1
107082: ARRAY
107083: PUSH
107084: LD_INT 2
107086: ARRAY
107087: PPUSH
107088: CALL_OW 297
107092: PUSH
107093: LD_INT 6
107095: GREATER
107096: IFFALSE 107171
// begin if not HasTask ( group [ i ] ) then
107098: LD_VAR 0 4
107102: PUSH
107103: LD_VAR 0 7
107107: ARRAY
107108: PPUSH
107109: CALL_OW 314
107113: NOT
107114: IFFALSE 107169
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
107116: LD_VAR 0 4
107120: PUSH
107121: LD_VAR 0 7
107125: ARRAY
107126: PPUSH
107127: LD_VAR 0 16
107131: PUSH
107132: LD_VAR 0 7
107136: ARRAY
107137: PUSH
107138: LD_INT 1
107140: ARRAY
107141: PUSH
107142: LD_INT 1
107144: ARRAY
107145: PPUSH
107146: LD_VAR 0 16
107150: PUSH
107151: LD_VAR 0 7
107155: ARRAY
107156: PUSH
107157: LD_INT 1
107159: ARRAY
107160: PUSH
107161: LD_INT 2
107163: ARRAY
107164: PPUSH
107165: CALL_OW 114
// end else
107169: GO 107222
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
107171: LD_ADDR_VAR 0 15
107175: PUSH
107176: LD_VAR 0 16
107180: PUSH
107181: LD_VAR 0 7
107185: ARRAY
107186: PPUSH
107187: LD_INT 1
107189: PPUSH
107190: CALL_OW 3
107194: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
107195: LD_ADDR_VAR 0 16
107199: PUSH
107200: LD_VAR 0 16
107204: PPUSH
107205: LD_VAR 0 7
107209: PPUSH
107210: LD_VAR 0 15
107214: PPUSH
107215: CALL_OW 1
107219: ST_TO_ADDR
// continue ;
107220: GO 105765
// end ; end ; end else
107222: GO 109886
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
107224: LD_ADDR_VAR 0 14
107228: PUSH
107229: LD_INT 81
107231: PUSH
107232: LD_VAR 0 4
107236: PUSH
107237: LD_VAR 0 7
107241: ARRAY
107242: PPUSH
107243: CALL_OW 255
107247: PUSH
107248: EMPTY
107249: LIST
107250: LIST
107251: PPUSH
107252: CALL_OW 69
107256: ST_TO_ADDR
// if not tmp then
107257: LD_VAR 0 14
107261: NOT
107262: IFFALSE 107266
// continue ;
107264: GO 105765
// if f_ignore_area then
107266: LD_VAR 0 17
107270: IFFALSE 107358
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
107272: LD_ADDR_VAR 0 15
107276: PUSH
107277: LD_VAR 0 14
107281: PPUSH
107282: LD_INT 3
107284: PUSH
107285: LD_INT 92
107287: PUSH
107288: LD_VAR 0 17
107292: PUSH
107293: LD_INT 1
107295: ARRAY
107296: PUSH
107297: LD_VAR 0 17
107301: PUSH
107302: LD_INT 2
107304: ARRAY
107305: PUSH
107306: LD_VAR 0 17
107310: PUSH
107311: LD_INT 3
107313: ARRAY
107314: PUSH
107315: EMPTY
107316: LIST
107317: LIST
107318: LIST
107319: LIST
107320: PUSH
107321: EMPTY
107322: LIST
107323: LIST
107324: PPUSH
107325: CALL_OW 72
107329: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107330: LD_VAR 0 14
107334: PUSH
107335: LD_VAR 0 15
107339: DIFF
107340: IFFALSE 107358
// tmp := tmp diff tmp2 ;
107342: LD_ADDR_VAR 0 14
107346: PUSH
107347: LD_VAR 0 14
107351: PUSH
107352: LD_VAR 0 15
107356: DIFF
107357: ST_TO_ADDR
// end ; if not f_murder then
107358: LD_VAR 0 20
107362: NOT
107363: IFFALSE 107421
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
107365: LD_ADDR_VAR 0 15
107369: PUSH
107370: LD_VAR 0 14
107374: PPUSH
107375: LD_INT 3
107377: PUSH
107378: LD_INT 50
107380: PUSH
107381: EMPTY
107382: LIST
107383: PUSH
107384: EMPTY
107385: LIST
107386: LIST
107387: PPUSH
107388: CALL_OW 72
107392: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107393: LD_VAR 0 14
107397: PUSH
107398: LD_VAR 0 15
107402: DIFF
107403: IFFALSE 107421
// tmp := tmp diff tmp2 ;
107405: LD_ADDR_VAR 0 14
107409: PUSH
107410: LD_VAR 0 14
107414: PUSH
107415: LD_VAR 0 15
107419: DIFF
107420: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
107421: LD_ADDR_VAR 0 14
107425: PUSH
107426: LD_VAR 0 4
107430: PUSH
107431: LD_VAR 0 7
107435: ARRAY
107436: PPUSH
107437: LD_VAR 0 14
107441: PPUSH
107442: LD_INT 1
107444: PPUSH
107445: LD_INT 1
107447: PPUSH
107448: CALL 20438 0 4
107452: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
107453: LD_VAR 0 4
107457: PUSH
107458: LD_VAR 0 7
107462: ARRAY
107463: PPUSH
107464: CALL_OW 257
107468: PUSH
107469: LD_INT 1
107471: EQUAL
107472: IFFALSE 107920
// begin if WantPlant ( group [ i ] ) then
107474: LD_VAR 0 4
107478: PUSH
107479: LD_VAR 0 7
107483: ARRAY
107484: PPUSH
107485: CALL 19939 0 1
107489: IFFALSE 107493
// continue ;
107491: GO 105765
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
107493: LD_VAR 0 18
107497: PUSH
107498: LD_VAR 0 4
107502: PUSH
107503: LD_VAR 0 7
107507: ARRAY
107508: PPUSH
107509: CALL_OW 310
107513: NOT
107514: AND
107515: PUSH
107516: LD_VAR 0 14
107520: PUSH
107521: LD_INT 1
107523: ARRAY
107524: PUSH
107525: LD_VAR 0 14
107529: PPUSH
107530: LD_INT 21
107532: PUSH
107533: LD_INT 2
107535: PUSH
107536: EMPTY
107537: LIST
107538: LIST
107539: PUSH
107540: LD_INT 58
107542: PUSH
107543: EMPTY
107544: LIST
107545: PUSH
107546: EMPTY
107547: LIST
107548: LIST
107549: PPUSH
107550: CALL_OW 72
107554: IN
107555: AND
107556: IFFALSE 107592
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
107558: LD_VAR 0 4
107562: PUSH
107563: LD_VAR 0 7
107567: ARRAY
107568: PPUSH
107569: LD_VAR 0 14
107573: PUSH
107574: LD_INT 1
107576: ARRAY
107577: PPUSH
107578: CALL_OW 120
// attacking := true ;
107582: LD_ADDR_VAR 0 29
107586: PUSH
107587: LD_INT 1
107589: ST_TO_ADDR
// continue ;
107590: GO 105765
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
107592: LD_VAR 0 26
107596: PUSH
107597: LD_VAR 0 4
107601: PUSH
107602: LD_VAR 0 7
107606: ARRAY
107607: PPUSH
107608: CALL_OW 257
107612: PUSH
107613: LD_INT 1
107615: EQUAL
107616: AND
107617: PUSH
107618: LD_VAR 0 4
107622: PUSH
107623: LD_VAR 0 7
107627: ARRAY
107628: PPUSH
107629: CALL_OW 256
107633: PUSH
107634: LD_INT 800
107636: LESS
107637: AND
107638: PUSH
107639: LD_VAR 0 4
107643: PUSH
107644: LD_VAR 0 7
107648: ARRAY
107649: PPUSH
107650: CALL_OW 318
107654: NOT
107655: AND
107656: IFFALSE 107673
// ComCrawl ( group [ i ] ) ;
107658: LD_VAR 0 4
107662: PUSH
107663: LD_VAR 0 7
107667: ARRAY
107668: PPUSH
107669: CALL_OW 137
// if f_mines then
107673: LD_VAR 0 21
107677: IFFALSE 107920
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
107679: LD_VAR 0 14
107683: PUSH
107684: LD_INT 1
107686: ARRAY
107687: PPUSH
107688: CALL_OW 247
107692: PUSH
107693: LD_INT 3
107695: EQUAL
107696: PUSH
107697: LD_VAR 0 14
107701: PUSH
107702: LD_INT 1
107704: ARRAY
107705: PUSH
107706: LD_VAR 0 27
107710: IN
107711: NOT
107712: AND
107713: IFFALSE 107920
// begin x := GetX ( tmp [ 1 ] ) ;
107715: LD_ADDR_VAR 0 10
107719: PUSH
107720: LD_VAR 0 14
107724: PUSH
107725: LD_INT 1
107727: ARRAY
107728: PPUSH
107729: CALL_OW 250
107733: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
107734: LD_ADDR_VAR 0 11
107738: PUSH
107739: LD_VAR 0 14
107743: PUSH
107744: LD_INT 1
107746: ARRAY
107747: PPUSH
107748: CALL_OW 251
107752: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
107753: LD_ADDR_VAR 0 12
107757: PUSH
107758: LD_VAR 0 4
107762: PUSH
107763: LD_VAR 0 7
107767: ARRAY
107768: PPUSH
107769: CALL 47588 0 1
107773: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
107774: LD_VAR 0 4
107778: PUSH
107779: LD_VAR 0 7
107783: ARRAY
107784: PPUSH
107785: LD_VAR 0 10
107789: PPUSH
107790: LD_VAR 0 11
107794: PPUSH
107795: LD_VAR 0 14
107799: PUSH
107800: LD_INT 1
107802: ARRAY
107803: PPUSH
107804: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
107808: LD_VAR 0 4
107812: PUSH
107813: LD_VAR 0 7
107817: ARRAY
107818: PPUSH
107819: LD_VAR 0 10
107823: PPUSH
107824: LD_VAR 0 12
107828: PPUSH
107829: LD_INT 7
107831: PPUSH
107832: CALL_OW 272
107836: PPUSH
107837: LD_VAR 0 11
107841: PPUSH
107842: LD_VAR 0 12
107846: PPUSH
107847: LD_INT 7
107849: PPUSH
107850: CALL_OW 273
107854: PPUSH
107855: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
107859: LD_VAR 0 4
107863: PUSH
107864: LD_VAR 0 7
107868: ARRAY
107869: PPUSH
107870: LD_INT 71
107872: PPUSH
107873: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
107877: LD_ADDR_VAR 0 27
107881: PUSH
107882: LD_VAR 0 27
107886: PPUSH
107887: LD_VAR 0 27
107891: PUSH
107892: LD_INT 1
107894: PLUS
107895: PPUSH
107896: LD_VAR 0 14
107900: PUSH
107901: LD_INT 1
107903: ARRAY
107904: PPUSH
107905: CALL_OW 1
107909: ST_TO_ADDR
// attacking := true ;
107910: LD_ADDR_VAR 0 29
107914: PUSH
107915: LD_INT 1
107917: ST_TO_ADDR
// continue ;
107918: GO 105765
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
107920: LD_VAR 0 4
107924: PUSH
107925: LD_VAR 0 7
107929: ARRAY
107930: PPUSH
107931: CALL_OW 257
107935: PUSH
107936: LD_INT 17
107938: EQUAL
107939: PUSH
107940: LD_VAR 0 4
107944: PUSH
107945: LD_VAR 0 7
107949: ARRAY
107950: PPUSH
107951: CALL_OW 110
107955: PUSH
107956: LD_INT 71
107958: EQUAL
107959: NOT
107960: AND
107961: IFFALSE 108107
// begin attacking := false ;
107963: LD_ADDR_VAR 0 29
107967: PUSH
107968: LD_INT 0
107970: ST_TO_ADDR
// k := 5 ;
107971: LD_ADDR_VAR 0 9
107975: PUSH
107976: LD_INT 5
107978: ST_TO_ADDR
// if tmp < k then
107979: LD_VAR 0 14
107983: PUSH
107984: LD_VAR 0 9
107988: LESS
107989: IFFALSE 108001
// k := tmp ;
107991: LD_ADDR_VAR 0 9
107995: PUSH
107996: LD_VAR 0 14
108000: ST_TO_ADDR
// for j = 1 to k do
108001: LD_ADDR_VAR 0 8
108005: PUSH
108006: DOUBLE
108007: LD_INT 1
108009: DEC
108010: ST_TO_ADDR
108011: LD_VAR 0 9
108015: PUSH
108016: FOR_TO
108017: IFFALSE 108105
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
108019: LD_VAR 0 14
108023: PUSH
108024: LD_VAR 0 8
108028: ARRAY
108029: PUSH
108030: LD_VAR 0 14
108034: PPUSH
108035: LD_INT 58
108037: PUSH
108038: EMPTY
108039: LIST
108040: PPUSH
108041: CALL_OW 72
108045: IN
108046: NOT
108047: IFFALSE 108103
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108049: LD_VAR 0 4
108053: PUSH
108054: LD_VAR 0 7
108058: ARRAY
108059: PPUSH
108060: LD_VAR 0 14
108064: PUSH
108065: LD_VAR 0 8
108069: ARRAY
108070: PPUSH
108071: CALL_OW 115
// attacking := true ;
108075: LD_ADDR_VAR 0 29
108079: PUSH
108080: LD_INT 1
108082: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
108083: LD_VAR 0 4
108087: PUSH
108088: LD_VAR 0 7
108092: ARRAY
108093: PPUSH
108094: LD_INT 71
108096: PPUSH
108097: CALL_OW 109
// continue ;
108101: GO 108016
// end ; end ;
108103: GO 108016
108105: POP
108106: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
108107: LD_VAR 0 4
108111: PUSH
108112: LD_VAR 0 7
108116: ARRAY
108117: PPUSH
108118: CALL_OW 257
108122: PUSH
108123: LD_INT 8
108125: EQUAL
108126: PUSH
108127: LD_VAR 0 4
108131: PUSH
108132: LD_VAR 0 7
108136: ARRAY
108137: PPUSH
108138: CALL_OW 264
108142: PUSH
108143: LD_INT 28
108145: PUSH
108146: LD_INT 45
108148: PUSH
108149: LD_INT 7
108151: PUSH
108152: LD_INT 47
108154: PUSH
108155: EMPTY
108156: LIST
108157: LIST
108158: LIST
108159: LIST
108160: IN
108161: OR
108162: IFFALSE 108418
// begin attacking := false ;
108164: LD_ADDR_VAR 0 29
108168: PUSH
108169: LD_INT 0
108171: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
108172: LD_VAR 0 14
108176: PUSH
108177: LD_INT 1
108179: ARRAY
108180: PPUSH
108181: CALL_OW 266
108185: PUSH
108186: LD_INT 32
108188: PUSH
108189: LD_INT 31
108191: PUSH
108192: LD_INT 33
108194: PUSH
108195: LD_INT 4
108197: PUSH
108198: LD_INT 5
108200: PUSH
108201: EMPTY
108202: LIST
108203: LIST
108204: LIST
108205: LIST
108206: LIST
108207: IN
108208: IFFALSE 108394
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
108210: LD_ADDR_VAR 0 9
108214: PUSH
108215: LD_VAR 0 14
108219: PUSH
108220: LD_INT 1
108222: ARRAY
108223: PPUSH
108224: CALL_OW 266
108228: PPUSH
108229: LD_VAR 0 14
108233: PUSH
108234: LD_INT 1
108236: ARRAY
108237: PPUSH
108238: CALL_OW 250
108242: PPUSH
108243: LD_VAR 0 14
108247: PUSH
108248: LD_INT 1
108250: ARRAY
108251: PPUSH
108252: CALL_OW 251
108256: PPUSH
108257: LD_VAR 0 14
108261: PUSH
108262: LD_INT 1
108264: ARRAY
108265: PPUSH
108266: CALL_OW 254
108270: PPUSH
108271: LD_VAR 0 14
108275: PUSH
108276: LD_INT 1
108278: ARRAY
108279: PPUSH
108280: CALL_OW 248
108284: PPUSH
108285: LD_INT 0
108287: PPUSH
108288: CALL 28958 0 6
108292: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
108293: LD_ADDR_VAR 0 8
108297: PUSH
108298: LD_VAR 0 4
108302: PUSH
108303: LD_VAR 0 7
108307: ARRAY
108308: PPUSH
108309: LD_VAR 0 9
108313: PPUSH
108314: CALL 47628 0 2
108318: ST_TO_ADDR
// if j then
108319: LD_VAR 0 8
108323: IFFALSE 108392
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
108325: LD_VAR 0 8
108329: PUSH
108330: LD_INT 1
108332: ARRAY
108333: PPUSH
108334: LD_VAR 0 8
108338: PUSH
108339: LD_INT 2
108341: ARRAY
108342: PPUSH
108343: CALL_OW 488
108347: IFFALSE 108392
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
108349: LD_VAR 0 4
108353: PUSH
108354: LD_VAR 0 7
108358: ARRAY
108359: PPUSH
108360: LD_VAR 0 8
108364: PUSH
108365: LD_INT 1
108367: ARRAY
108368: PPUSH
108369: LD_VAR 0 8
108373: PUSH
108374: LD_INT 2
108376: ARRAY
108377: PPUSH
108378: CALL_OW 116
// attacking := true ;
108382: LD_ADDR_VAR 0 29
108386: PUSH
108387: LD_INT 1
108389: ST_TO_ADDR
// continue ;
108390: GO 105765
// end ; end else
108392: GO 108418
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108394: LD_VAR 0 4
108398: PUSH
108399: LD_VAR 0 7
108403: ARRAY
108404: PPUSH
108405: LD_VAR 0 14
108409: PUSH
108410: LD_INT 1
108412: ARRAY
108413: PPUSH
108414: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
108418: LD_VAR 0 4
108422: PUSH
108423: LD_VAR 0 7
108427: ARRAY
108428: PPUSH
108429: CALL_OW 265
108433: PUSH
108434: LD_INT 11
108436: EQUAL
108437: IFFALSE 108715
// begin k := 10 ;
108439: LD_ADDR_VAR 0 9
108443: PUSH
108444: LD_INT 10
108446: ST_TO_ADDR
// x := 0 ;
108447: LD_ADDR_VAR 0 10
108451: PUSH
108452: LD_INT 0
108454: ST_TO_ADDR
// if tmp < k then
108455: LD_VAR 0 14
108459: PUSH
108460: LD_VAR 0 9
108464: LESS
108465: IFFALSE 108477
// k := tmp ;
108467: LD_ADDR_VAR 0 9
108471: PUSH
108472: LD_VAR 0 14
108476: ST_TO_ADDR
// for j = k downto 1 do
108477: LD_ADDR_VAR 0 8
108481: PUSH
108482: DOUBLE
108483: LD_VAR 0 9
108487: INC
108488: ST_TO_ADDR
108489: LD_INT 1
108491: PUSH
108492: FOR_DOWNTO
108493: IFFALSE 108568
// begin if GetType ( tmp [ j ] ) = unit_human then
108495: LD_VAR 0 14
108499: PUSH
108500: LD_VAR 0 8
108504: ARRAY
108505: PPUSH
108506: CALL_OW 247
108510: PUSH
108511: LD_INT 1
108513: EQUAL
108514: IFFALSE 108566
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
108516: LD_VAR 0 4
108520: PUSH
108521: LD_VAR 0 7
108525: ARRAY
108526: PPUSH
108527: LD_VAR 0 14
108531: PUSH
108532: LD_VAR 0 8
108536: ARRAY
108537: PPUSH
108538: CALL 47899 0 2
// x := tmp [ j ] ;
108542: LD_ADDR_VAR 0 10
108546: PUSH
108547: LD_VAR 0 14
108551: PUSH
108552: LD_VAR 0 8
108556: ARRAY
108557: ST_TO_ADDR
// attacking := true ;
108558: LD_ADDR_VAR 0 29
108562: PUSH
108563: LD_INT 1
108565: ST_TO_ADDR
// end ; end ;
108566: GO 108492
108568: POP
108569: POP
// if not x then
108570: LD_VAR 0 10
108574: NOT
108575: IFFALSE 108715
// begin attacking := true ;
108577: LD_ADDR_VAR 0 29
108581: PUSH
108582: LD_INT 1
108584: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
108585: LD_VAR 0 4
108589: PUSH
108590: LD_VAR 0 7
108594: ARRAY
108595: PPUSH
108596: CALL_OW 250
108600: PPUSH
108601: LD_VAR 0 4
108605: PUSH
108606: LD_VAR 0 7
108610: ARRAY
108611: PPUSH
108612: CALL_OW 251
108616: PPUSH
108617: CALL_OW 546
108621: PUSH
108622: LD_INT 2
108624: ARRAY
108625: PUSH
108626: LD_VAR 0 14
108630: PUSH
108631: LD_INT 1
108633: ARRAY
108634: PPUSH
108635: CALL_OW 250
108639: PPUSH
108640: LD_VAR 0 14
108644: PUSH
108645: LD_INT 1
108647: ARRAY
108648: PPUSH
108649: CALL_OW 251
108653: PPUSH
108654: CALL_OW 546
108658: PUSH
108659: LD_INT 2
108661: ARRAY
108662: EQUAL
108663: IFFALSE 108691
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
108665: LD_VAR 0 4
108669: PUSH
108670: LD_VAR 0 7
108674: ARRAY
108675: PPUSH
108676: LD_VAR 0 14
108680: PUSH
108681: LD_INT 1
108683: ARRAY
108684: PPUSH
108685: CALL 47899 0 2
108689: GO 108715
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108691: LD_VAR 0 4
108695: PUSH
108696: LD_VAR 0 7
108700: ARRAY
108701: PPUSH
108702: LD_VAR 0 14
108706: PUSH
108707: LD_INT 1
108709: ARRAY
108710: PPUSH
108711: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
108715: LD_VAR 0 4
108719: PUSH
108720: LD_VAR 0 7
108724: ARRAY
108725: PPUSH
108726: CALL_OW 264
108730: PUSH
108731: LD_INT 29
108733: EQUAL
108734: IFFALSE 109100
// begin if WantsToAttack ( group [ i ] ) in bombed then
108736: LD_VAR 0 4
108740: PUSH
108741: LD_VAR 0 7
108745: ARRAY
108746: PPUSH
108747: CALL_OW 319
108751: PUSH
108752: LD_VAR 0 28
108756: IN
108757: IFFALSE 108761
// continue ;
108759: GO 105765
// k := 8 ;
108761: LD_ADDR_VAR 0 9
108765: PUSH
108766: LD_INT 8
108768: ST_TO_ADDR
// x := 0 ;
108769: LD_ADDR_VAR 0 10
108773: PUSH
108774: LD_INT 0
108776: ST_TO_ADDR
// if tmp < k then
108777: LD_VAR 0 14
108781: PUSH
108782: LD_VAR 0 9
108786: LESS
108787: IFFALSE 108799
// k := tmp ;
108789: LD_ADDR_VAR 0 9
108793: PUSH
108794: LD_VAR 0 14
108798: ST_TO_ADDR
// for j = 1 to k do
108799: LD_ADDR_VAR 0 8
108803: PUSH
108804: DOUBLE
108805: LD_INT 1
108807: DEC
108808: ST_TO_ADDR
108809: LD_VAR 0 9
108813: PUSH
108814: FOR_TO
108815: IFFALSE 108947
// begin if GetType ( tmp [ j ] ) = unit_building then
108817: LD_VAR 0 14
108821: PUSH
108822: LD_VAR 0 8
108826: ARRAY
108827: PPUSH
108828: CALL_OW 247
108832: PUSH
108833: LD_INT 3
108835: EQUAL
108836: IFFALSE 108945
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
108838: LD_VAR 0 14
108842: PUSH
108843: LD_VAR 0 8
108847: ARRAY
108848: PUSH
108849: LD_VAR 0 28
108853: IN
108854: NOT
108855: PUSH
108856: LD_VAR 0 14
108860: PUSH
108861: LD_VAR 0 8
108865: ARRAY
108866: PPUSH
108867: CALL_OW 313
108871: AND
108872: IFFALSE 108945
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108874: LD_VAR 0 4
108878: PUSH
108879: LD_VAR 0 7
108883: ARRAY
108884: PPUSH
108885: LD_VAR 0 14
108889: PUSH
108890: LD_VAR 0 8
108894: ARRAY
108895: PPUSH
108896: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
108900: LD_ADDR_VAR 0 28
108904: PUSH
108905: LD_VAR 0 28
108909: PPUSH
108910: LD_VAR 0 28
108914: PUSH
108915: LD_INT 1
108917: PLUS
108918: PPUSH
108919: LD_VAR 0 14
108923: PUSH
108924: LD_VAR 0 8
108928: ARRAY
108929: PPUSH
108930: CALL_OW 1
108934: ST_TO_ADDR
// attacking := true ;
108935: LD_ADDR_VAR 0 29
108939: PUSH
108940: LD_INT 1
108942: ST_TO_ADDR
// break ;
108943: GO 108947
// end ; end ;
108945: GO 108814
108947: POP
108948: POP
// if not attacking and f_attack_depot then
108949: LD_VAR 0 29
108953: NOT
108954: PUSH
108955: LD_VAR 0 25
108959: AND
108960: IFFALSE 109055
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108962: LD_ADDR_VAR 0 13
108966: PUSH
108967: LD_VAR 0 14
108971: PPUSH
108972: LD_INT 2
108974: PUSH
108975: LD_INT 30
108977: PUSH
108978: LD_INT 0
108980: PUSH
108981: EMPTY
108982: LIST
108983: LIST
108984: PUSH
108985: LD_INT 30
108987: PUSH
108988: LD_INT 1
108990: PUSH
108991: EMPTY
108992: LIST
108993: LIST
108994: PUSH
108995: EMPTY
108996: LIST
108997: LIST
108998: LIST
108999: PPUSH
109000: CALL_OW 72
109004: ST_TO_ADDR
// if z then
109005: LD_VAR 0 13
109009: IFFALSE 109055
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
109011: LD_VAR 0 4
109015: PUSH
109016: LD_VAR 0 7
109020: ARRAY
109021: PPUSH
109022: LD_VAR 0 13
109026: PPUSH
109027: LD_VAR 0 4
109031: PUSH
109032: LD_VAR 0 7
109036: ARRAY
109037: PPUSH
109038: CALL_OW 74
109042: PPUSH
109043: CALL_OW 115
// attacking := true ;
109047: LD_ADDR_VAR 0 29
109051: PUSH
109052: LD_INT 1
109054: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
109055: LD_VAR 0 4
109059: PUSH
109060: LD_VAR 0 7
109064: ARRAY
109065: PPUSH
109066: CALL_OW 256
109070: PUSH
109071: LD_INT 500
109073: LESS
109074: IFFALSE 109100
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109076: LD_VAR 0 4
109080: PUSH
109081: LD_VAR 0 7
109085: ARRAY
109086: PPUSH
109087: LD_VAR 0 14
109091: PUSH
109092: LD_INT 1
109094: ARRAY
109095: PPUSH
109096: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
109100: LD_VAR 0 4
109104: PUSH
109105: LD_VAR 0 7
109109: ARRAY
109110: PPUSH
109111: CALL_OW 264
109115: PUSH
109116: LD_INT 49
109118: EQUAL
109119: IFFALSE 109240
// begin if not HasTask ( group [ i ] ) then
109121: LD_VAR 0 4
109125: PUSH
109126: LD_VAR 0 7
109130: ARRAY
109131: PPUSH
109132: CALL_OW 314
109136: NOT
109137: IFFALSE 109240
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
109139: LD_ADDR_VAR 0 9
109143: PUSH
109144: LD_INT 81
109146: PUSH
109147: LD_VAR 0 4
109151: PUSH
109152: LD_VAR 0 7
109156: ARRAY
109157: PPUSH
109158: CALL_OW 255
109162: PUSH
109163: EMPTY
109164: LIST
109165: LIST
109166: PPUSH
109167: CALL_OW 69
109171: PPUSH
109172: LD_VAR 0 4
109176: PUSH
109177: LD_VAR 0 7
109181: ARRAY
109182: PPUSH
109183: CALL_OW 74
109187: ST_TO_ADDR
// if k then
109188: LD_VAR 0 9
109192: IFFALSE 109240
// if GetDistUnits ( group [ i ] , k ) > 10 then
109194: LD_VAR 0 4
109198: PUSH
109199: LD_VAR 0 7
109203: ARRAY
109204: PPUSH
109205: LD_VAR 0 9
109209: PPUSH
109210: CALL_OW 296
109214: PUSH
109215: LD_INT 10
109217: GREATER
109218: IFFALSE 109240
// ComMoveUnit ( group [ i ] , k ) ;
109220: LD_VAR 0 4
109224: PUSH
109225: LD_VAR 0 7
109229: ARRAY
109230: PPUSH
109231: LD_VAR 0 9
109235: PPUSH
109236: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
109240: LD_VAR 0 4
109244: PUSH
109245: LD_VAR 0 7
109249: ARRAY
109250: PPUSH
109251: CALL_OW 256
109255: PUSH
109256: LD_INT 250
109258: LESS
109259: PUSH
109260: LD_VAR 0 4
109264: PUSH
109265: LD_VAR 0 7
109269: ARRAY
109270: PUSH
109271: LD_INT 21
109273: PUSH
109274: LD_INT 2
109276: PUSH
109277: EMPTY
109278: LIST
109279: LIST
109280: PUSH
109281: LD_INT 23
109283: PUSH
109284: LD_INT 2
109286: PUSH
109287: EMPTY
109288: LIST
109289: LIST
109290: PUSH
109291: EMPTY
109292: LIST
109293: LIST
109294: PPUSH
109295: CALL_OW 69
109299: IN
109300: AND
109301: IFFALSE 109426
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
109303: LD_ADDR_VAR 0 9
109307: PUSH
109308: LD_OWVAR 3
109312: PUSH
109313: LD_VAR 0 4
109317: PUSH
109318: LD_VAR 0 7
109322: ARRAY
109323: DIFF
109324: PPUSH
109325: LD_VAR 0 4
109329: PUSH
109330: LD_VAR 0 7
109334: ARRAY
109335: PPUSH
109336: CALL_OW 74
109340: ST_TO_ADDR
// if not k then
109341: LD_VAR 0 9
109345: NOT
109346: IFFALSE 109350
// continue ;
109348: GO 105765
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
109350: LD_VAR 0 9
109354: PUSH
109355: LD_INT 81
109357: PUSH
109358: LD_VAR 0 4
109362: PUSH
109363: LD_VAR 0 7
109367: ARRAY
109368: PPUSH
109369: CALL_OW 255
109373: PUSH
109374: EMPTY
109375: LIST
109376: LIST
109377: PPUSH
109378: CALL_OW 69
109382: IN
109383: PUSH
109384: LD_VAR 0 9
109388: PPUSH
109389: LD_VAR 0 4
109393: PUSH
109394: LD_VAR 0 7
109398: ARRAY
109399: PPUSH
109400: CALL_OW 296
109404: PUSH
109405: LD_INT 5
109407: LESS
109408: AND
109409: IFFALSE 109426
// ComAutodestruct ( group [ i ] ) ;
109411: LD_VAR 0 4
109415: PUSH
109416: LD_VAR 0 7
109420: ARRAY
109421: PPUSH
109422: CALL 47797 0 1
// end ; if f_attack_depot then
109426: LD_VAR 0 25
109430: IFFALSE 109542
// begin k := 6 ;
109432: LD_ADDR_VAR 0 9
109436: PUSH
109437: LD_INT 6
109439: ST_TO_ADDR
// if tmp < k then
109440: LD_VAR 0 14
109444: PUSH
109445: LD_VAR 0 9
109449: LESS
109450: IFFALSE 109462
// k := tmp ;
109452: LD_ADDR_VAR 0 9
109456: PUSH
109457: LD_VAR 0 14
109461: ST_TO_ADDR
// for j = 1 to k do
109462: LD_ADDR_VAR 0 8
109466: PUSH
109467: DOUBLE
109468: LD_INT 1
109470: DEC
109471: ST_TO_ADDR
109472: LD_VAR 0 9
109476: PUSH
109477: FOR_TO
109478: IFFALSE 109540
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
109480: LD_VAR 0 8
109484: PPUSH
109485: CALL_OW 266
109489: PUSH
109490: LD_INT 0
109492: PUSH
109493: LD_INT 1
109495: PUSH
109496: EMPTY
109497: LIST
109498: LIST
109499: IN
109500: IFFALSE 109538
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109502: LD_VAR 0 4
109506: PUSH
109507: LD_VAR 0 7
109511: ARRAY
109512: PPUSH
109513: LD_VAR 0 14
109517: PUSH
109518: LD_VAR 0 8
109522: ARRAY
109523: PPUSH
109524: CALL_OW 115
// attacking := true ;
109528: LD_ADDR_VAR 0 29
109532: PUSH
109533: LD_INT 1
109535: ST_TO_ADDR
// break ;
109536: GO 109540
// end ;
109538: GO 109477
109540: POP
109541: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
109542: LD_VAR 0 4
109546: PUSH
109547: LD_VAR 0 7
109551: ARRAY
109552: PPUSH
109553: CALL_OW 302
109557: PUSH
109558: LD_VAR 0 29
109562: NOT
109563: AND
109564: IFFALSE 109886
// begin if GetTag ( group [ i ] ) = 71 then
109566: LD_VAR 0 4
109570: PUSH
109571: LD_VAR 0 7
109575: ARRAY
109576: PPUSH
109577: CALL_OW 110
109581: PUSH
109582: LD_INT 71
109584: EQUAL
109585: IFFALSE 109626
// begin if HasTask ( group [ i ] ) then
109587: LD_VAR 0 4
109591: PUSH
109592: LD_VAR 0 7
109596: ARRAY
109597: PPUSH
109598: CALL_OW 314
109602: IFFALSE 109608
// continue else
109604: GO 105765
109606: GO 109626
// SetTag ( group [ i ] , 0 ) ;
109608: LD_VAR 0 4
109612: PUSH
109613: LD_VAR 0 7
109617: ARRAY
109618: PPUSH
109619: LD_INT 0
109621: PPUSH
109622: CALL_OW 109
// end ; k := 8 ;
109626: LD_ADDR_VAR 0 9
109630: PUSH
109631: LD_INT 8
109633: ST_TO_ADDR
// x := 0 ;
109634: LD_ADDR_VAR 0 10
109638: PUSH
109639: LD_INT 0
109641: ST_TO_ADDR
// if tmp < k then
109642: LD_VAR 0 14
109646: PUSH
109647: LD_VAR 0 9
109651: LESS
109652: IFFALSE 109664
// k := tmp ;
109654: LD_ADDR_VAR 0 9
109658: PUSH
109659: LD_VAR 0 14
109663: ST_TO_ADDR
// for j = 1 to k do
109664: LD_ADDR_VAR 0 8
109668: PUSH
109669: DOUBLE
109670: LD_INT 1
109672: DEC
109673: ST_TO_ADDR
109674: LD_VAR 0 9
109678: PUSH
109679: FOR_TO
109680: IFFALSE 109778
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
109682: LD_VAR 0 14
109686: PUSH
109687: LD_VAR 0 8
109691: ARRAY
109692: PPUSH
109693: CALL_OW 247
109697: PUSH
109698: LD_INT 1
109700: EQUAL
109701: PUSH
109702: LD_VAR 0 14
109706: PUSH
109707: LD_VAR 0 8
109711: ARRAY
109712: PPUSH
109713: CALL_OW 256
109717: PUSH
109718: LD_INT 250
109720: LESS
109721: PUSH
109722: LD_VAR 0 20
109726: AND
109727: PUSH
109728: LD_VAR 0 20
109732: NOT
109733: PUSH
109734: LD_VAR 0 14
109738: PUSH
109739: LD_VAR 0 8
109743: ARRAY
109744: PPUSH
109745: CALL_OW 256
109749: PUSH
109750: LD_INT 250
109752: GREATEREQUAL
109753: AND
109754: OR
109755: AND
109756: IFFALSE 109776
// begin x := tmp [ j ] ;
109758: LD_ADDR_VAR 0 10
109762: PUSH
109763: LD_VAR 0 14
109767: PUSH
109768: LD_VAR 0 8
109772: ARRAY
109773: ST_TO_ADDR
// break ;
109774: GO 109778
// end ;
109776: GO 109679
109778: POP
109779: POP
// if x then
109780: LD_VAR 0 10
109784: IFFALSE 109808
// ComAttackUnit ( group [ i ] , x ) else
109786: LD_VAR 0 4
109790: PUSH
109791: LD_VAR 0 7
109795: ARRAY
109796: PPUSH
109797: LD_VAR 0 10
109801: PPUSH
109802: CALL_OW 115
109806: GO 109832
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109808: LD_VAR 0 4
109812: PUSH
109813: LD_VAR 0 7
109817: ARRAY
109818: PPUSH
109819: LD_VAR 0 14
109823: PUSH
109824: LD_INT 1
109826: ARRAY
109827: PPUSH
109828: CALL_OW 115
// if not HasTask ( group [ i ] ) then
109832: LD_VAR 0 4
109836: PUSH
109837: LD_VAR 0 7
109841: ARRAY
109842: PPUSH
109843: CALL_OW 314
109847: NOT
109848: IFFALSE 109886
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
109850: LD_VAR 0 4
109854: PUSH
109855: LD_VAR 0 7
109859: ARRAY
109860: PPUSH
109861: LD_VAR 0 14
109865: PPUSH
109866: LD_VAR 0 4
109870: PUSH
109871: LD_VAR 0 7
109875: ARRAY
109876: PPUSH
109877: CALL_OW 74
109881: PPUSH
109882: CALL_OW 115
// end ; end ; end ;
109886: GO 105765
109888: POP
109889: POP
// wait ( 0 0$2 ) ;
109890: LD_INT 70
109892: PPUSH
109893: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
109897: LD_VAR 0 4
109901: NOT
109902: PUSH
109903: LD_VAR 0 4
109907: PUSH
109908: EMPTY
109909: EQUAL
109910: OR
109911: PUSH
109912: LD_INT 81
109914: PUSH
109915: LD_VAR 0 35
109919: PUSH
109920: EMPTY
109921: LIST
109922: LIST
109923: PPUSH
109924: CALL_OW 69
109928: NOT
109929: OR
109930: IFFALSE 105750
// end ;
109932: LD_VAR 0 2
109936: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
109937: LD_INT 0
109939: PPUSH
109940: PPUSH
109941: PPUSH
109942: PPUSH
109943: PPUSH
109944: PPUSH
// if not base or not mc_bases [ base ] or not solds then
109945: LD_VAR 0 1
109949: NOT
109950: PUSH
109951: LD_EXP 60
109955: PUSH
109956: LD_VAR 0 1
109960: ARRAY
109961: NOT
109962: OR
109963: PUSH
109964: LD_VAR 0 2
109968: NOT
109969: OR
109970: IFFALSE 109974
// exit ;
109972: GO 110528
// side := mc_sides [ base ] ;
109974: LD_ADDR_VAR 0 6
109978: PUSH
109979: LD_EXP 86
109983: PUSH
109984: LD_VAR 0 1
109988: ARRAY
109989: ST_TO_ADDR
// if not side then
109990: LD_VAR 0 6
109994: NOT
109995: IFFALSE 109999
// exit ;
109997: GO 110528
// for i in solds do
109999: LD_ADDR_VAR 0 7
110003: PUSH
110004: LD_VAR 0 2
110008: PUSH
110009: FOR_IN
110010: IFFALSE 110071
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
110012: LD_VAR 0 7
110016: PPUSH
110017: CALL_OW 310
110021: PPUSH
110022: CALL_OW 266
110026: PUSH
110027: LD_INT 32
110029: PUSH
110030: LD_INT 31
110032: PUSH
110033: EMPTY
110034: LIST
110035: LIST
110036: IN
110037: IFFALSE 110057
// solds := solds diff i else
110039: LD_ADDR_VAR 0 2
110043: PUSH
110044: LD_VAR 0 2
110048: PUSH
110049: LD_VAR 0 7
110053: DIFF
110054: ST_TO_ADDR
110055: GO 110069
// SetTag ( i , 18 ) ;
110057: LD_VAR 0 7
110061: PPUSH
110062: LD_INT 18
110064: PPUSH
110065: CALL_OW 109
110069: GO 110009
110071: POP
110072: POP
// if not solds then
110073: LD_VAR 0 2
110077: NOT
110078: IFFALSE 110082
// exit ;
110080: GO 110528
// repeat wait ( 0 0$2 ) ;
110082: LD_INT 70
110084: PPUSH
110085: CALL_OW 67
// enemy := mc_scan [ base ] ;
110089: LD_ADDR_VAR 0 4
110093: PUSH
110094: LD_EXP 83
110098: PUSH
110099: LD_VAR 0 1
110103: ARRAY
110104: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110105: LD_EXP 60
110109: PUSH
110110: LD_VAR 0 1
110114: ARRAY
110115: NOT
110116: PUSH
110117: LD_EXP 60
110121: PUSH
110122: LD_VAR 0 1
110126: ARRAY
110127: PUSH
110128: EMPTY
110129: EQUAL
110130: OR
110131: IFFALSE 110168
// begin for i in solds do
110133: LD_ADDR_VAR 0 7
110137: PUSH
110138: LD_VAR 0 2
110142: PUSH
110143: FOR_IN
110144: IFFALSE 110157
// ComStop ( i ) ;
110146: LD_VAR 0 7
110150: PPUSH
110151: CALL_OW 141
110155: GO 110143
110157: POP
110158: POP
// solds := [ ] ;
110159: LD_ADDR_VAR 0 2
110163: PUSH
110164: EMPTY
110165: ST_TO_ADDR
// exit ;
110166: GO 110528
// end ; for i in solds do
110168: LD_ADDR_VAR 0 7
110172: PUSH
110173: LD_VAR 0 2
110177: PUSH
110178: FOR_IN
110179: IFFALSE 110500
// begin if IsInUnit ( i ) then
110181: LD_VAR 0 7
110185: PPUSH
110186: CALL_OW 310
110190: IFFALSE 110201
// ComExitBuilding ( i ) ;
110192: LD_VAR 0 7
110196: PPUSH
110197: CALL_OW 122
// if GetLives ( i ) > 500 then
110201: LD_VAR 0 7
110205: PPUSH
110206: CALL_OW 256
110210: PUSH
110211: LD_INT 500
110213: GREATER
110214: IFFALSE 110267
// begin e := NearestUnitToUnit ( enemy , i ) ;
110216: LD_ADDR_VAR 0 5
110220: PUSH
110221: LD_VAR 0 4
110225: PPUSH
110226: LD_VAR 0 7
110230: PPUSH
110231: CALL_OW 74
110235: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
110236: LD_VAR 0 7
110240: PPUSH
110241: LD_VAR 0 5
110245: PPUSH
110246: CALL_OW 250
110250: PPUSH
110251: LD_VAR 0 5
110255: PPUSH
110256: CALL_OW 251
110260: PPUSH
110261: CALL_OW 114
// end else
110265: GO 110498
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
110267: LD_VAR 0 7
110271: PPUSH
110272: LD_EXP 60
110276: PUSH
110277: LD_VAR 0 1
110281: ARRAY
110282: PPUSH
110283: LD_INT 2
110285: PUSH
110286: LD_INT 30
110288: PUSH
110289: LD_INT 0
110291: PUSH
110292: EMPTY
110293: LIST
110294: LIST
110295: PUSH
110296: LD_INT 30
110298: PUSH
110299: LD_INT 1
110301: PUSH
110302: EMPTY
110303: LIST
110304: LIST
110305: PUSH
110306: LD_INT 30
110308: PUSH
110309: LD_INT 6
110311: PUSH
110312: EMPTY
110313: LIST
110314: LIST
110315: PUSH
110316: EMPTY
110317: LIST
110318: LIST
110319: LIST
110320: LIST
110321: PPUSH
110322: CALL_OW 72
110326: PPUSH
110327: LD_VAR 0 7
110331: PPUSH
110332: CALL_OW 74
110336: PPUSH
110337: CALL_OW 296
110341: PUSH
110342: LD_INT 10
110344: GREATER
110345: IFFALSE 110498
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
110347: LD_ADDR_VAR 0 8
110351: PUSH
110352: LD_EXP 60
110356: PUSH
110357: LD_VAR 0 1
110361: ARRAY
110362: PPUSH
110363: LD_INT 2
110365: PUSH
110366: LD_INT 30
110368: PUSH
110369: LD_INT 0
110371: PUSH
110372: EMPTY
110373: LIST
110374: LIST
110375: PUSH
110376: LD_INT 30
110378: PUSH
110379: LD_INT 1
110381: PUSH
110382: EMPTY
110383: LIST
110384: LIST
110385: PUSH
110386: LD_INT 30
110388: PUSH
110389: LD_INT 6
110391: PUSH
110392: EMPTY
110393: LIST
110394: LIST
110395: PUSH
110396: EMPTY
110397: LIST
110398: LIST
110399: LIST
110400: LIST
110401: PPUSH
110402: CALL_OW 72
110406: PPUSH
110407: LD_VAR 0 7
110411: PPUSH
110412: CALL_OW 74
110416: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
110417: LD_VAR 0 7
110421: PPUSH
110422: LD_VAR 0 8
110426: PPUSH
110427: CALL_OW 250
110431: PPUSH
110432: LD_INT 3
110434: PPUSH
110435: LD_INT 5
110437: PPUSH
110438: CALL_OW 272
110442: PPUSH
110443: LD_VAR 0 8
110447: PPUSH
110448: CALL_OW 251
110452: PPUSH
110453: LD_INT 3
110455: PPUSH
110456: LD_INT 5
110458: PPUSH
110459: CALL_OW 273
110463: PPUSH
110464: CALL_OW 111
// SetTag ( i , 0 ) ;
110468: LD_VAR 0 7
110472: PPUSH
110473: LD_INT 0
110475: PPUSH
110476: CALL_OW 109
// solds := solds diff i ;
110480: LD_ADDR_VAR 0 2
110484: PUSH
110485: LD_VAR 0 2
110489: PUSH
110490: LD_VAR 0 7
110494: DIFF
110495: ST_TO_ADDR
// continue ;
110496: GO 110178
// end ; end ;
110498: GO 110178
110500: POP
110501: POP
// until not solds or not enemy ;
110502: LD_VAR 0 2
110506: NOT
110507: PUSH
110508: LD_VAR 0 4
110512: NOT
110513: OR
110514: IFFALSE 110082
// MC_Reset ( base , 18 ) ;
110516: LD_VAR 0 1
110520: PPUSH
110521: LD_INT 18
110523: PPUSH
110524: CALL 59606 0 2
// end ;
110528: LD_VAR 0 3
110532: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
110533: LD_INT 0
110535: PPUSH
110536: PPUSH
110537: PPUSH
110538: PPUSH
110539: PPUSH
110540: PPUSH
110541: PPUSH
110542: PPUSH
110543: PPUSH
110544: PPUSH
110545: PPUSH
110546: PPUSH
110547: PPUSH
110548: PPUSH
110549: PPUSH
110550: PPUSH
110551: PPUSH
110552: PPUSH
110553: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
110554: LD_ADDR_VAR 0 12
110558: PUSH
110559: LD_EXP 60
110563: PUSH
110564: LD_VAR 0 1
110568: ARRAY
110569: PPUSH
110570: LD_INT 25
110572: PUSH
110573: LD_INT 3
110575: PUSH
110576: EMPTY
110577: LIST
110578: LIST
110579: PPUSH
110580: CALL_OW 72
110584: ST_TO_ADDR
// if mc_remote_driver [ base ] then
110585: LD_EXP 100
110589: PUSH
110590: LD_VAR 0 1
110594: ARRAY
110595: IFFALSE 110619
// mechs := mechs diff mc_remote_driver [ base ] ;
110597: LD_ADDR_VAR 0 12
110601: PUSH
110602: LD_VAR 0 12
110606: PUSH
110607: LD_EXP 100
110611: PUSH
110612: LD_VAR 0 1
110616: ARRAY
110617: DIFF
110618: ST_TO_ADDR
// for i in mechs do
110619: LD_ADDR_VAR 0 4
110623: PUSH
110624: LD_VAR 0 12
110628: PUSH
110629: FOR_IN
110630: IFFALSE 110665
// if GetTag ( i ) > 0 then
110632: LD_VAR 0 4
110636: PPUSH
110637: CALL_OW 110
110641: PUSH
110642: LD_INT 0
110644: GREATER
110645: IFFALSE 110663
// mechs := mechs diff i ;
110647: LD_ADDR_VAR 0 12
110651: PUSH
110652: LD_VAR 0 12
110656: PUSH
110657: LD_VAR 0 4
110661: DIFF
110662: ST_TO_ADDR
110663: GO 110629
110665: POP
110666: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
110667: LD_ADDR_VAR 0 8
110671: PUSH
110672: LD_EXP 60
110676: PUSH
110677: LD_VAR 0 1
110681: ARRAY
110682: PPUSH
110683: LD_INT 2
110685: PUSH
110686: LD_INT 25
110688: PUSH
110689: LD_INT 1
110691: PUSH
110692: EMPTY
110693: LIST
110694: LIST
110695: PUSH
110696: LD_INT 25
110698: PUSH
110699: LD_INT 5
110701: PUSH
110702: EMPTY
110703: LIST
110704: LIST
110705: PUSH
110706: LD_INT 25
110708: PUSH
110709: LD_INT 8
110711: PUSH
110712: EMPTY
110713: LIST
110714: LIST
110715: PUSH
110716: LD_INT 25
110718: PUSH
110719: LD_INT 9
110721: PUSH
110722: EMPTY
110723: LIST
110724: LIST
110725: PUSH
110726: EMPTY
110727: LIST
110728: LIST
110729: LIST
110730: LIST
110731: LIST
110732: PPUSH
110733: CALL_OW 72
110737: ST_TO_ADDR
// if not defenders and not solds then
110738: LD_VAR 0 2
110742: NOT
110743: PUSH
110744: LD_VAR 0 8
110748: NOT
110749: AND
110750: IFFALSE 110754
// exit ;
110752: GO 112524
// depot_under_attack := false ;
110754: LD_ADDR_VAR 0 16
110758: PUSH
110759: LD_INT 0
110761: ST_TO_ADDR
// sold_defenders := [ ] ;
110762: LD_ADDR_VAR 0 17
110766: PUSH
110767: EMPTY
110768: ST_TO_ADDR
// if mechs then
110769: LD_VAR 0 12
110773: IFFALSE 110926
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
110775: LD_ADDR_VAR 0 4
110779: PUSH
110780: LD_VAR 0 2
110784: PPUSH
110785: LD_INT 21
110787: PUSH
110788: LD_INT 2
110790: PUSH
110791: EMPTY
110792: LIST
110793: LIST
110794: PPUSH
110795: CALL_OW 72
110799: PUSH
110800: FOR_IN
110801: IFFALSE 110924
// begin if GetTag ( i ) <> 20 then
110803: LD_VAR 0 4
110807: PPUSH
110808: CALL_OW 110
110812: PUSH
110813: LD_INT 20
110815: NONEQUAL
110816: IFFALSE 110830
// SetTag ( i , 20 ) ;
110818: LD_VAR 0 4
110822: PPUSH
110823: LD_INT 20
110825: PPUSH
110826: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
110830: LD_VAR 0 4
110834: PPUSH
110835: CALL_OW 263
110839: PUSH
110840: LD_INT 1
110842: EQUAL
110843: PUSH
110844: LD_VAR 0 4
110848: PPUSH
110849: CALL_OW 311
110853: NOT
110854: AND
110855: IFFALSE 110922
// begin un := mechs [ 1 ] ;
110857: LD_ADDR_VAR 0 10
110861: PUSH
110862: LD_VAR 0 12
110866: PUSH
110867: LD_INT 1
110869: ARRAY
110870: ST_TO_ADDR
// ComExit ( un ) ;
110871: LD_VAR 0 10
110875: PPUSH
110876: CALL 52086 0 1
// AddComEnterUnit ( un , i ) ;
110880: LD_VAR 0 10
110884: PPUSH
110885: LD_VAR 0 4
110889: PPUSH
110890: CALL_OW 180
// SetTag ( un , 19 ) ;
110894: LD_VAR 0 10
110898: PPUSH
110899: LD_INT 19
110901: PPUSH
110902: CALL_OW 109
// mechs := mechs diff un ;
110906: LD_ADDR_VAR 0 12
110910: PUSH
110911: LD_VAR 0 12
110915: PUSH
110916: LD_VAR 0 10
110920: DIFF
110921: ST_TO_ADDR
// end ; end ;
110922: GO 110800
110924: POP
110925: POP
// if solds then
110926: LD_VAR 0 8
110930: IFFALSE 110989
// for i in solds do
110932: LD_ADDR_VAR 0 4
110936: PUSH
110937: LD_VAR 0 8
110941: PUSH
110942: FOR_IN
110943: IFFALSE 110987
// if not GetTag ( i ) then
110945: LD_VAR 0 4
110949: PPUSH
110950: CALL_OW 110
110954: NOT
110955: IFFALSE 110985
// begin defenders := defenders union i ;
110957: LD_ADDR_VAR 0 2
110961: PUSH
110962: LD_VAR 0 2
110966: PUSH
110967: LD_VAR 0 4
110971: UNION
110972: ST_TO_ADDR
// SetTag ( i , 18 ) ;
110973: LD_VAR 0 4
110977: PPUSH
110978: LD_INT 18
110980: PPUSH
110981: CALL_OW 109
// end ;
110985: GO 110942
110987: POP
110988: POP
// repeat wait ( 0 0$2 ) ;
110989: LD_INT 70
110991: PPUSH
110992: CALL_OW 67
// enemy := mc_scan [ base ] ;
110996: LD_ADDR_VAR 0 21
111000: PUSH
111001: LD_EXP 83
111005: PUSH
111006: LD_VAR 0 1
111010: ARRAY
111011: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111012: LD_EXP 60
111016: PUSH
111017: LD_VAR 0 1
111021: ARRAY
111022: NOT
111023: PUSH
111024: LD_EXP 60
111028: PUSH
111029: LD_VAR 0 1
111033: ARRAY
111034: PUSH
111035: EMPTY
111036: EQUAL
111037: OR
111038: IFFALSE 111075
// begin for i in defenders do
111040: LD_ADDR_VAR 0 4
111044: PUSH
111045: LD_VAR 0 2
111049: PUSH
111050: FOR_IN
111051: IFFALSE 111064
// ComStop ( i ) ;
111053: LD_VAR 0 4
111057: PPUSH
111058: CALL_OW 141
111062: GO 111050
111064: POP
111065: POP
// defenders := [ ] ;
111066: LD_ADDR_VAR 0 2
111070: PUSH
111071: EMPTY
111072: ST_TO_ADDR
// exit ;
111073: GO 112524
// end ; for i in defenders do
111075: LD_ADDR_VAR 0 4
111079: PUSH
111080: LD_VAR 0 2
111084: PUSH
111085: FOR_IN
111086: IFFALSE 111984
// begin e := NearestUnitToUnit ( enemy , i ) ;
111088: LD_ADDR_VAR 0 13
111092: PUSH
111093: LD_VAR 0 21
111097: PPUSH
111098: LD_VAR 0 4
111102: PPUSH
111103: CALL_OW 74
111107: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111108: LD_ADDR_VAR 0 7
111112: PUSH
111113: LD_EXP 60
111117: PUSH
111118: LD_VAR 0 1
111122: ARRAY
111123: PPUSH
111124: LD_INT 2
111126: PUSH
111127: LD_INT 30
111129: PUSH
111130: LD_INT 0
111132: PUSH
111133: EMPTY
111134: LIST
111135: LIST
111136: PUSH
111137: LD_INT 30
111139: PUSH
111140: LD_INT 1
111142: PUSH
111143: EMPTY
111144: LIST
111145: LIST
111146: PUSH
111147: EMPTY
111148: LIST
111149: LIST
111150: LIST
111151: PPUSH
111152: CALL_OW 72
111156: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
111157: LD_ADDR_VAR 0 16
111161: PUSH
111162: LD_VAR 0 7
111166: NOT
111167: PUSH
111168: LD_VAR 0 7
111172: PPUSH
111173: LD_INT 3
111175: PUSH
111176: LD_INT 24
111178: PUSH
111179: LD_INT 600
111181: PUSH
111182: EMPTY
111183: LIST
111184: LIST
111185: PUSH
111186: EMPTY
111187: LIST
111188: LIST
111189: PPUSH
111190: CALL_OW 72
111194: OR
111195: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
111196: LD_VAR 0 4
111200: PPUSH
111201: CALL_OW 247
111205: PUSH
111206: LD_INT 2
111208: DOUBLE
111209: EQUAL
111210: IFTRUE 111214
111212: GO 111610
111214: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
111215: LD_VAR 0 4
111219: PPUSH
111220: CALL_OW 256
111224: PUSH
111225: LD_INT 1000
111227: EQUAL
111228: PUSH
111229: LD_VAR 0 4
111233: PPUSH
111234: LD_VAR 0 13
111238: PPUSH
111239: CALL_OW 296
111243: PUSH
111244: LD_INT 40
111246: LESS
111247: PUSH
111248: LD_VAR 0 13
111252: PPUSH
111253: LD_EXP 85
111257: PUSH
111258: LD_VAR 0 1
111262: ARRAY
111263: PPUSH
111264: CALL_OW 308
111268: OR
111269: AND
111270: IFFALSE 111392
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
111272: LD_VAR 0 4
111276: PPUSH
111277: CALL_OW 262
111281: PUSH
111282: LD_INT 1
111284: EQUAL
111285: PUSH
111286: LD_VAR 0 4
111290: PPUSH
111291: CALL_OW 261
111295: PUSH
111296: LD_INT 30
111298: LESS
111299: AND
111300: PUSH
111301: LD_VAR 0 7
111305: AND
111306: IFFALSE 111376
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
111308: LD_VAR 0 4
111312: PPUSH
111313: LD_VAR 0 7
111317: PPUSH
111318: LD_VAR 0 4
111322: PPUSH
111323: CALL_OW 74
111327: PPUSH
111328: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
111332: LD_VAR 0 4
111336: PPUSH
111337: LD_VAR 0 7
111341: PPUSH
111342: LD_VAR 0 4
111346: PPUSH
111347: CALL_OW 74
111351: PPUSH
111352: CALL_OW 296
111356: PUSH
111357: LD_INT 6
111359: LESS
111360: IFFALSE 111374
// SetFuel ( i , 100 ) ;
111362: LD_VAR 0 4
111366: PPUSH
111367: LD_INT 100
111369: PPUSH
111370: CALL_OW 240
// end else
111374: GO 111390
// ComAttackUnit ( i , e ) ;
111376: LD_VAR 0 4
111380: PPUSH
111381: LD_VAR 0 13
111385: PPUSH
111386: CALL_OW 115
// end else
111390: GO 111493
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
111392: LD_VAR 0 13
111396: PPUSH
111397: LD_EXP 85
111401: PUSH
111402: LD_VAR 0 1
111406: ARRAY
111407: PPUSH
111408: CALL_OW 308
111412: NOT
111413: PUSH
111414: LD_VAR 0 4
111418: PPUSH
111419: LD_VAR 0 13
111423: PPUSH
111424: CALL_OW 296
111428: PUSH
111429: LD_INT 40
111431: GREATEREQUAL
111432: AND
111433: PUSH
111434: LD_VAR 0 4
111438: PPUSH
111439: CALL_OW 256
111443: PUSH
111444: LD_INT 650
111446: LESSEQUAL
111447: OR
111448: PUSH
111449: LD_VAR 0 4
111453: PPUSH
111454: LD_EXP 84
111458: PUSH
111459: LD_VAR 0 1
111463: ARRAY
111464: PPUSH
111465: CALL_OW 308
111469: NOT
111470: AND
111471: IFFALSE 111493
// ComMoveToArea ( i , mc_parking [ base ] ) ;
111473: LD_VAR 0 4
111477: PPUSH
111478: LD_EXP 84
111482: PUSH
111483: LD_VAR 0 1
111487: ARRAY
111488: PPUSH
111489: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
111493: LD_VAR 0 4
111497: PPUSH
111498: CALL_OW 256
111502: PUSH
111503: LD_INT 1000
111505: LESS
111506: PUSH
111507: LD_VAR 0 4
111511: PPUSH
111512: CALL_OW 263
111516: PUSH
111517: LD_INT 1
111519: EQUAL
111520: AND
111521: PUSH
111522: LD_VAR 0 4
111526: PPUSH
111527: CALL_OW 311
111531: AND
111532: PUSH
111533: LD_VAR 0 4
111537: PPUSH
111538: LD_EXP 84
111542: PUSH
111543: LD_VAR 0 1
111547: ARRAY
111548: PPUSH
111549: CALL_OW 308
111553: AND
111554: IFFALSE 111608
// begin mech := IsDrivenBy ( i ) ;
111556: LD_ADDR_VAR 0 9
111560: PUSH
111561: LD_VAR 0 4
111565: PPUSH
111566: CALL_OW 311
111570: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
111571: LD_VAR 0 9
111575: PPUSH
111576: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
111580: LD_VAR 0 9
111584: PPUSH
111585: LD_VAR 0 4
111589: PPUSH
111590: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
111594: LD_VAR 0 9
111598: PPUSH
111599: LD_VAR 0 4
111603: PPUSH
111604: CALL_OW 180
// end ; end ; unit_human :
111608: GO 111955
111610: LD_INT 1
111612: DOUBLE
111613: EQUAL
111614: IFTRUE 111618
111616: GO 111954
111618: POP
// begin b := IsInUnit ( i ) ;
111619: LD_ADDR_VAR 0 18
111623: PUSH
111624: LD_VAR 0 4
111628: PPUSH
111629: CALL_OW 310
111633: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
111634: LD_ADDR_VAR 0 19
111638: PUSH
111639: LD_VAR 0 18
111643: NOT
111644: PUSH
111645: LD_VAR 0 18
111649: PPUSH
111650: CALL_OW 266
111654: PUSH
111655: LD_INT 32
111657: PUSH
111658: LD_INT 31
111660: PUSH
111661: EMPTY
111662: LIST
111663: LIST
111664: IN
111665: OR
111666: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
111667: LD_VAR 0 18
111671: PPUSH
111672: CALL_OW 266
111676: PUSH
111677: LD_INT 5
111679: EQUAL
111680: PUSH
111681: LD_VAR 0 4
111685: PPUSH
111686: CALL_OW 257
111690: PUSH
111691: LD_INT 1
111693: PUSH
111694: LD_INT 2
111696: PUSH
111697: LD_INT 3
111699: PUSH
111700: LD_INT 4
111702: PUSH
111703: EMPTY
111704: LIST
111705: LIST
111706: LIST
111707: LIST
111708: IN
111709: AND
111710: IFFALSE 111747
// begin class := AllowSpecClass ( i ) ;
111712: LD_ADDR_VAR 0 20
111716: PUSH
111717: LD_VAR 0 4
111721: PPUSH
111722: CALL 16650 0 1
111726: ST_TO_ADDR
// if class then
111727: LD_VAR 0 20
111731: IFFALSE 111747
// ComChangeProfession ( i , class ) ;
111733: LD_VAR 0 4
111737: PPUSH
111738: LD_VAR 0 20
111742: PPUSH
111743: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
111747: LD_VAR 0 16
111751: PUSH
111752: LD_VAR 0 2
111756: PPUSH
111757: LD_INT 21
111759: PUSH
111760: LD_INT 2
111762: PUSH
111763: EMPTY
111764: LIST
111765: LIST
111766: PPUSH
111767: CALL_OW 72
111771: PUSH
111772: LD_INT 1
111774: LESSEQUAL
111775: OR
111776: PUSH
111777: LD_VAR 0 19
111781: AND
111782: PUSH
111783: LD_VAR 0 4
111787: PUSH
111788: LD_VAR 0 17
111792: IN
111793: NOT
111794: AND
111795: IFFALSE 111888
// begin if b then
111797: LD_VAR 0 18
111801: IFFALSE 111850
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
111803: LD_VAR 0 18
111807: PPUSH
111808: LD_VAR 0 21
111812: PPUSH
111813: LD_VAR 0 18
111817: PPUSH
111818: CALL_OW 74
111822: PPUSH
111823: CALL_OW 296
111827: PUSH
111828: LD_INT 10
111830: LESS
111831: PUSH
111832: LD_VAR 0 18
111836: PPUSH
111837: CALL_OW 461
111841: PUSH
111842: LD_INT 7
111844: NONEQUAL
111845: AND
111846: IFFALSE 111850
// continue ;
111848: GO 111085
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
111850: LD_ADDR_VAR 0 17
111854: PUSH
111855: LD_VAR 0 17
111859: PPUSH
111860: LD_VAR 0 17
111864: PUSH
111865: LD_INT 1
111867: PLUS
111868: PPUSH
111869: LD_VAR 0 4
111873: PPUSH
111874: CALL_OW 1
111878: ST_TO_ADDR
// ComExitBuilding ( i ) ;
111879: LD_VAR 0 4
111883: PPUSH
111884: CALL_OW 122
// end ; if sold_defenders then
111888: LD_VAR 0 17
111892: IFFALSE 111952
// if i in sold_defenders then
111894: LD_VAR 0 4
111898: PUSH
111899: LD_VAR 0 17
111903: IN
111904: IFFALSE 111952
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
111906: LD_VAR 0 4
111910: PPUSH
111911: CALL_OW 314
111915: NOT
111916: PUSH
111917: LD_VAR 0 4
111921: PPUSH
111922: LD_VAR 0 13
111926: PPUSH
111927: CALL_OW 296
111931: PUSH
111932: LD_INT 30
111934: LESS
111935: AND
111936: IFFALSE 111952
// ComAttackUnit ( i , e ) ;
111938: LD_VAR 0 4
111942: PPUSH
111943: LD_VAR 0 13
111947: PPUSH
111948: CALL_OW 115
// end ; end ; end ;
111952: GO 111955
111954: POP
// if IsDead ( i ) then
111955: LD_VAR 0 4
111959: PPUSH
111960: CALL_OW 301
111964: IFFALSE 111982
// defenders := defenders diff i ;
111966: LD_ADDR_VAR 0 2
111970: PUSH
111971: LD_VAR 0 2
111975: PUSH
111976: LD_VAR 0 4
111980: DIFF
111981: ST_TO_ADDR
// end ;
111982: GO 111085
111984: POP
111985: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
111986: LD_VAR 0 21
111990: NOT
111991: PUSH
111992: LD_VAR 0 2
111996: NOT
111997: OR
111998: PUSH
111999: LD_EXP 60
112003: PUSH
112004: LD_VAR 0 1
112008: ARRAY
112009: NOT
112010: OR
112011: IFFALSE 110989
// MC_Reset ( base , 18 ) ;
112013: LD_VAR 0 1
112017: PPUSH
112018: LD_INT 18
112020: PPUSH
112021: CALL 59606 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112025: LD_ADDR_VAR 0 2
112029: PUSH
112030: LD_VAR 0 2
112034: PUSH
112035: LD_VAR 0 2
112039: PPUSH
112040: LD_INT 2
112042: PUSH
112043: LD_INT 25
112045: PUSH
112046: LD_INT 1
112048: PUSH
112049: EMPTY
112050: LIST
112051: LIST
112052: PUSH
112053: LD_INT 25
112055: PUSH
112056: LD_INT 5
112058: PUSH
112059: EMPTY
112060: LIST
112061: LIST
112062: PUSH
112063: LD_INT 25
112065: PUSH
112066: LD_INT 8
112068: PUSH
112069: EMPTY
112070: LIST
112071: LIST
112072: PUSH
112073: LD_INT 25
112075: PUSH
112076: LD_INT 9
112078: PUSH
112079: EMPTY
112080: LIST
112081: LIST
112082: PUSH
112083: EMPTY
112084: LIST
112085: LIST
112086: LIST
112087: LIST
112088: LIST
112089: PPUSH
112090: CALL_OW 72
112094: DIFF
112095: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
112096: LD_VAR 0 21
112100: NOT
112101: PUSH
112102: LD_VAR 0 2
112106: PPUSH
112107: LD_INT 21
112109: PUSH
112110: LD_INT 2
112112: PUSH
112113: EMPTY
112114: LIST
112115: LIST
112116: PPUSH
112117: CALL_OW 72
112121: AND
112122: IFFALSE 112460
// begin tmp := FilterByTag ( defenders , 19 ) ;
112124: LD_ADDR_VAR 0 11
112128: PUSH
112129: LD_VAR 0 2
112133: PPUSH
112134: LD_INT 19
112136: PPUSH
112137: CALL 49272 0 2
112141: ST_TO_ADDR
// if tmp then
112142: LD_VAR 0 11
112146: IFFALSE 112216
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
112148: LD_ADDR_VAR 0 11
112152: PUSH
112153: LD_VAR 0 11
112157: PPUSH
112158: LD_INT 25
112160: PUSH
112161: LD_INT 3
112163: PUSH
112164: EMPTY
112165: LIST
112166: LIST
112167: PPUSH
112168: CALL_OW 72
112172: ST_TO_ADDR
// if tmp then
112173: LD_VAR 0 11
112177: IFFALSE 112216
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
112179: LD_ADDR_EXP 72
112183: PUSH
112184: LD_EXP 72
112188: PPUSH
112189: LD_VAR 0 1
112193: PPUSH
112194: LD_EXP 72
112198: PUSH
112199: LD_VAR 0 1
112203: ARRAY
112204: PUSH
112205: LD_VAR 0 11
112209: UNION
112210: PPUSH
112211: CALL_OW 1
112215: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
112216: LD_VAR 0 1
112220: PPUSH
112221: LD_INT 19
112223: PPUSH
112224: CALL 59606 0 2
// repeat wait ( 0 0$1 ) ;
112228: LD_INT 35
112230: PPUSH
112231: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112235: LD_EXP 60
112239: PUSH
112240: LD_VAR 0 1
112244: ARRAY
112245: NOT
112246: PUSH
112247: LD_EXP 60
112251: PUSH
112252: LD_VAR 0 1
112256: ARRAY
112257: PUSH
112258: EMPTY
112259: EQUAL
112260: OR
112261: IFFALSE 112298
// begin for i in defenders do
112263: LD_ADDR_VAR 0 4
112267: PUSH
112268: LD_VAR 0 2
112272: PUSH
112273: FOR_IN
112274: IFFALSE 112287
// ComStop ( i ) ;
112276: LD_VAR 0 4
112280: PPUSH
112281: CALL_OW 141
112285: GO 112273
112287: POP
112288: POP
// defenders := [ ] ;
112289: LD_ADDR_VAR 0 2
112293: PUSH
112294: EMPTY
112295: ST_TO_ADDR
// exit ;
112296: GO 112524
// end ; for i in defenders do
112298: LD_ADDR_VAR 0 4
112302: PUSH
112303: LD_VAR 0 2
112307: PUSH
112308: FOR_IN
112309: IFFALSE 112398
// begin if not IsInArea ( i , mc_parking [ base ] ) then
112311: LD_VAR 0 4
112315: PPUSH
112316: LD_EXP 84
112320: PUSH
112321: LD_VAR 0 1
112325: ARRAY
112326: PPUSH
112327: CALL_OW 308
112331: NOT
112332: IFFALSE 112356
// ComMoveToArea ( i , mc_parking [ base ] ) else
112334: LD_VAR 0 4
112338: PPUSH
112339: LD_EXP 84
112343: PUSH
112344: LD_VAR 0 1
112348: ARRAY
112349: PPUSH
112350: CALL_OW 113
112354: GO 112396
// if GetControl ( i ) = control_manual then
112356: LD_VAR 0 4
112360: PPUSH
112361: CALL_OW 263
112365: PUSH
112366: LD_INT 1
112368: EQUAL
112369: IFFALSE 112396
// if IsDrivenBy ( i ) then
112371: LD_VAR 0 4
112375: PPUSH
112376: CALL_OW 311
112380: IFFALSE 112396
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
112382: LD_VAR 0 4
112386: PPUSH
112387: CALL_OW 311
112391: PPUSH
112392: CALL_OW 121
// end ;
112396: GO 112308
112398: POP
112399: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
112400: LD_VAR 0 2
112404: PPUSH
112405: LD_INT 95
112407: PUSH
112408: LD_EXP 84
112412: PUSH
112413: LD_VAR 0 1
112417: ARRAY
112418: PUSH
112419: EMPTY
112420: LIST
112421: LIST
112422: PPUSH
112423: CALL_OW 72
112427: PUSH
112428: LD_VAR 0 2
112432: EQUAL
112433: PUSH
112434: LD_EXP 83
112438: PUSH
112439: LD_VAR 0 1
112443: ARRAY
112444: OR
112445: PUSH
112446: LD_EXP 60
112450: PUSH
112451: LD_VAR 0 1
112455: ARRAY
112456: NOT
112457: OR
112458: IFFALSE 112228
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
112460: LD_ADDR_EXP 82
112464: PUSH
112465: LD_EXP 82
112469: PPUSH
112470: LD_VAR 0 1
112474: PPUSH
112475: LD_VAR 0 2
112479: PPUSH
112480: LD_INT 21
112482: PUSH
112483: LD_INT 2
112485: PUSH
112486: EMPTY
112487: LIST
112488: LIST
112489: PPUSH
112490: CALL_OW 72
112494: PPUSH
112495: CALL_OW 1
112499: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
112500: LD_VAR 0 1
112504: PPUSH
112505: LD_INT 19
112507: PPUSH
112508: CALL 59606 0 2
// MC_Reset ( base , 20 ) ;
112512: LD_VAR 0 1
112516: PPUSH
112517: LD_INT 20
112519: PPUSH
112520: CALL 59606 0 2
// end ; end_of_file
112524: LD_VAR 0 3
112528: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
112529: LD_VAR 0 1
112533: PUSH
112534: LD_INT 200
112536: DOUBLE
112537: GREATEREQUAL
112538: IFFALSE 112546
112540: LD_INT 299
112542: DOUBLE
112543: LESSEQUAL
112544: IFTRUE 112548
112546: GO 112580
112548: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
112549: LD_VAR 0 1
112553: PPUSH
112554: LD_VAR 0 2
112558: PPUSH
112559: LD_VAR 0 3
112563: PPUSH
112564: LD_VAR 0 4
112568: PPUSH
112569: LD_VAR 0 5
112573: PPUSH
112574: CALL 100966 0 5
112578: GO 112657
112580: LD_INT 300
112582: DOUBLE
112583: GREATEREQUAL
112584: IFFALSE 112592
112586: LD_INT 399
112588: DOUBLE
112589: LESSEQUAL
112590: IFTRUE 112594
112592: GO 112656
112594: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
112595: LD_VAR 0 1
112599: PPUSH
112600: LD_VAR 0 2
112604: PPUSH
112605: LD_VAR 0 3
112609: PPUSH
112610: LD_VAR 0 4
112614: PPUSH
112615: LD_VAR 0 5
112619: PPUSH
112620: LD_VAR 0 6
112624: PPUSH
112625: LD_VAR 0 7
112629: PPUSH
112630: LD_VAR 0 8
112634: PPUSH
112635: LD_VAR 0 9
112639: PPUSH
112640: LD_VAR 0 10
112644: PPUSH
112645: LD_VAR 0 11
112649: PPUSH
112650: CALL 98608 0 11
112654: GO 112657
112656: POP
// end ;
112657: PPOPN 11
112659: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
112660: LD_VAR 0 1
112664: PPUSH
112665: LD_VAR 0 2
112669: PPUSH
112670: LD_VAR 0 3
112674: PPUSH
112675: LD_VAR 0 4
112679: PPUSH
112680: LD_VAR 0 5
112684: PPUSH
112685: CALL 100702 0 5
// end ; end_of_file
112689: PPOPN 5
112691: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
112692: LD_VAR 0 1
112696: PPUSH
112697: LD_VAR 0 2
112701: PPUSH
112702: LD_VAR 0 3
112706: PPUSH
112707: LD_VAR 0 4
112711: PPUSH
112712: LD_VAR 0 5
112716: PPUSH
112717: LD_VAR 0 6
112721: PPUSH
112722: CALL 86301 0 6
// end ;
112726: PPOPN 6
112728: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
112729: LD_INT 0
112731: PPUSH
// begin if not units then
112732: LD_VAR 0 1
112736: NOT
112737: IFFALSE 112741
// exit ;
112739: GO 112829
// if p1 = 1 then
112741: LD_VAR 0 2
112745: PUSH
112746: LD_INT 1
112748: EQUAL
112749: IFFALSE 112829
// begin if p2 = 1 then
112751: LD_VAR 0 3
112755: PUSH
112756: LD_INT 1
112758: EQUAL
112759: IFFALSE 112790
// begin for i in units do
112761: LD_ADDR_VAR 0 7
112765: PUSH
112766: LD_VAR 0 1
112770: PUSH
112771: FOR_IN
112772: IFFALSE 112788
// begin SetUnitAttackType ( i , 3 ) ;
112774: LD_VAR 0 7
112778: PPUSH
112779: LD_INT 3
112781: PPUSH
112782: CALL_OW 603
// end ;
112786: GO 112771
112788: POP
112789: POP
// end ; if p2 = 2 then
112790: LD_VAR 0 3
112794: PUSH
112795: LD_INT 2
112797: EQUAL
112798: IFFALSE 112829
// begin for i in units do
112800: LD_ADDR_VAR 0 7
112804: PUSH
112805: LD_VAR 0 1
112809: PUSH
112810: FOR_IN
112811: IFFALSE 112827
// begin SetUnitAttackType ( i , 1 ) ;
112813: LD_VAR 0 7
112817: PPUSH
112818: LD_INT 1
112820: PPUSH
112821: CALL_OW 603
// end ;
112825: GO 112810
112827: POP
112828: POP
// end ; end ; end ;
112829: PPOPN 7
112831: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
112832: CALL 86276 0 0
// end ;
112836: PPOPN 1
112838: END
