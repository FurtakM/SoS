// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 57584 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49318 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49318 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49318 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 49318 0 9
// PrepareArabian ;
 147: CALL 3690 0 0
// PrepareRussian ;
 151: CALL 2825 0 0
// PrepareAlliance ;
 155: CALL 821 0 0
// MC_Start ( ) ;
 159: CALL 59696 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6853 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 83
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 84
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 80913 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 54
 252: PPUSH
 253: CALL 81339 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 81797 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 82066 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 81279 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 81973 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 51
 340: PPUSH
 341: CALL 81339 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 81797 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 82066 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 81123 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 81279 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := 0 ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 52
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// hack_counter := 0 ;
 724: LD_ADDR_EXP 14
 728: PUSH
 729: LD_INT 0
 731: ST_TO_ADDR
// end ;
 732: LD_VAR 0 1
 736: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 737: LD_EXP 48
 741: PPUSH
 742: CALL_OW 255
 746: PUSH
 747: LD_INT 7
 749: EQUAL
 750: PUSH
 751: LD_EXP 47
 755: PPUSH
 756: CALL_OW 255
 760: PUSH
 761: LD_INT 7
 763: EQUAL
 764: AND
 765: PUSH
 766: LD_EXP 48
 770: PPUSH
 771: CALL_OW 302
 775: AND
 776: PUSH
 777: LD_EXP 47
 781: PPUSH
 782: CALL_OW 302
 786: AND
 787: IFFALSE 799
 789: GO 791
 791: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 792: LD_STRING ACH_COMRADE
 794: PPUSH
 795: CALL_OW 543
 799: END
// every 0 0$1 trigger hack_counter >= 10 do
 800: LD_EXP 14
 804: PUSH
 805: LD_INT 10
 807: GREATEREQUAL
 808: IFFALSE 820
 810: GO 812
 812: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 813: LD_STRING ACH_HACK
 815: PPUSH
 816: CALL_OW 543
 820: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
 825: PPUSH
 826: PPUSH
// uc_side := 7 ;
 827: LD_ADDR_OWVAR 20
 831: PUSH
 832: LD_INT 7
 834: ST_TO_ADDR
// uc_nation := 1 ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_INT 1
 842: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 843: LD_ADDR_EXP 15
 847: PUSH
 848: LD_STRING JMM
 850: PPUSH
 851: LD_EXP 1
 855: NOT
 856: PPUSH
 857: LD_STRING 12a_
 859: PPUSH
 860: CALL 14292 0 3
 864: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 865: LD_EXP 15
 869: PPUSH
 870: LD_INT 71
 872: PPUSH
 873: LD_INT 23
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 883: LD_EXP 15
 887: PPUSH
 888: LD_INT 2
 890: PPUSH
 891: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 895: LD_ADDR_EXP 16
 899: PUSH
 900: LD_STRING Roth
 902: PPUSH
 903: LD_EXP 1
 907: NOT
 908: PPUSH
 909: LD_STRING 12a_
 911: PPUSH
 912: CALL 14292 0 3
 916: ST_TO_ADDR
// if Roth then
 917: LD_EXP 16
 921: IFFALSE 941
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 923: LD_EXP 16
 927: PPUSH
 928: LD_INT 71
 930: PPUSH
 931: LD_INT 21
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Lisa
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 14292 0 3
 962: ST_TO_ADDR
// if Lisa then
 963: LD_EXP 17
 967: IFFALSE 984
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 13
 976: PPUSH
 977: LD_INT 0
 979: PPUSH
 980: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 984: LD_ADDR_EXP 18
 988: PUSH
 989: LD_STRING Donaldson
 991: PPUSH
 992: LD_EXP 1
 996: NOT
 997: PPUSH
 998: LD_STRING 12a_
1000: PPUSH
1001: CALL 14292 0 3
1005: ST_TO_ADDR
// if Donaldson then
1006: LD_EXP 18
1010: IFFALSE 1027
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1012: LD_EXP 18
1016: PPUSH
1017: LD_INT 13
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_STRING Bobby
1034: PPUSH
1035: LD_EXP 1
1039: NOT
1040: PPUSH
1041: LD_STRING 12a_
1043: PPUSH
1044: CALL 14292 0 3
1048: ST_TO_ADDR
// if Bobby then
1049: LD_EXP 19
1053: IFFALSE 1070
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1055: LD_EXP 19
1059: PPUSH
1060: LD_INT 13
1062: PPUSH
1063: LD_INT 0
1065: PPUSH
1066: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1070: LD_ADDR_EXP 20
1074: PUSH
1075: LD_STRING Cyrus
1077: PPUSH
1078: LD_EXP 1
1082: NOT
1083: PPUSH
1084: LD_STRING 12a_
1086: PPUSH
1087: CALL 14292 0 3
1091: ST_TO_ADDR
// if Cyrus then
1092: LD_EXP 20
1096: IFFALSE 1113
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1098: LD_EXP 20
1102: PPUSH
1103: LD_INT 13
1105: PPUSH
1106: LD_INT 0
1108: PPUSH
1109: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1113: LD_ADDR_EXP 21
1117: PUSH
1118: LD_STRING Denis
1120: PPUSH
1121: LD_EXP 1
1125: NOT
1126: PPUSH
1127: LD_STRING 12a_
1129: PPUSH
1130: CALL 14292 0 3
1134: ST_TO_ADDR
// if Denis then
1135: LD_EXP 21
1139: IFFALSE 1156
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1141: LD_EXP 21
1145: PPUSH
1146: LD_INT 13
1148: PPUSH
1149: LD_INT 0
1151: PPUSH
1152: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1156: LD_ADDR_EXP 22
1160: PUSH
1161: LD_STRING Brown
1163: PPUSH
1164: LD_EXP 1
1168: NOT
1169: PPUSH
1170: LD_STRING 12a_
1172: PPUSH
1173: CALL 14292 0 3
1177: ST_TO_ADDR
// if Brown then
1178: LD_EXP 22
1182: IFFALSE 1199
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1184: LD_EXP 22
1188: PPUSH
1189: LD_INT 13
1191: PPUSH
1192: LD_INT 0
1194: PPUSH
1195: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1199: LD_ADDR_EXP 23
1203: PUSH
1204: LD_STRING Gladstone
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_STRING 12a_
1215: PPUSH
1216: CALL 14292 0 3
1220: ST_TO_ADDR
// if Gladstone then
1221: LD_EXP 23
1225: IFFALSE 1242
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1227: LD_EXP 23
1231: PPUSH
1232: LD_INT 13
1234: PPUSH
1235: LD_INT 0
1237: PPUSH
1238: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1242: LD_ADDR_EXP 24
1246: PUSH
1247: LD_STRING Houten
1249: PPUSH
1250: LD_EXP 1
1254: NOT
1255: PPUSH
1256: LD_STRING 12a_
1258: PPUSH
1259: CALL 14292 0 3
1263: ST_TO_ADDR
// if Houten then
1264: LD_EXP 24
1268: IFFALSE 1285
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1270: LD_EXP 24
1274: PPUSH
1275: LD_INT 13
1277: PPUSH
1278: LD_INT 0
1280: PPUSH
1281: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1285: LD_ADDR_EXP 25
1289: PUSH
1290: LD_STRING Cornell
1292: PPUSH
1293: LD_EXP 1
1297: NOT
1298: PPUSH
1299: LD_STRING 12a_
1301: PPUSH
1302: CALL 14292 0 3
1306: ST_TO_ADDR
// if Cornel then
1307: LD_EXP 25
1311: IFFALSE 1328
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1313: LD_EXP 25
1317: PPUSH
1318: LD_INT 13
1320: PPUSH
1321: LD_INT 0
1323: PPUSH
1324: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1328: LD_ADDR_EXP 26
1332: PUSH
1333: LD_STRING Gary
1335: PPUSH
1336: LD_EXP 1
1340: NOT
1341: PPUSH
1342: LD_STRING 12a_
1344: PPUSH
1345: CALL 14292 0 3
1349: ST_TO_ADDR
// if Gary then
1350: LD_EXP 26
1354: IFFALSE 1371
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1356: LD_EXP 26
1360: PPUSH
1361: LD_INT 13
1363: PPUSH
1364: LD_INT 0
1366: PPUSH
1367: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1371: LD_ADDR_EXP 27
1375: PUSH
1376: LD_STRING Frank
1378: PPUSH
1379: LD_EXP 1
1383: NOT
1384: PPUSH
1385: LD_STRING 12a_
1387: PPUSH
1388: CALL 14292 0 3
1392: ST_TO_ADDR
// if Frank then
1393: LD_EXP 27
1397: IFFALSE 1414
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1399: LD_EXP 27
1403: PPUSH
1404: LD_INT 13
1406: PPUSH
1407: LD_INT 0
1409: PPUSH
1410: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1414: LD_ADDR_EXP 28
1418: PUSH
1419: LD_STRING Kikuchi
1421: PPUSH
1422: LD_EXP 1
1426: NOT
1427: PPUSH
1428: LD_STRING 12a_
1430: PPUSH
1431: CALL 14292 0 3
1435: ST_TO_ADDR
// if Kikuchi then
1436: LD_EXP 28
1440: IFFALSE 1457
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1442: LD_EXP 28
1446: PPUSH
1447: LD_INT 13
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1457: LD_ADDR_EXP 29
1461: PUSH
1462: LD_STRING Simms
1464: PPUSH
1465: LD_EXP 1
1469: NOT
1470: PPUSH
1471: LD_STRING 12a_
1473: PPUSH
1474: CALL 14292 0 3
1478: ST_TO_ADDR
// if Simms then
1479: LD_EXP 29
1483: IFFALSE 1500
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1485: LD_EXP 29
1489: PPUSH
1490: LD_INT 13
1492: PPUSH
1493: LD_INT 0
1495: PPUSH
1496: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1500: LD_ADDR_EXP 30
1504: PUSH
1505: LD_STRING Joan
1507: PPUSH
1508: LD_EXP 1
1512: NOT
1513: PPUSH
1514: LD_STRING 12a_
1516: PPUSH
1517: CALL 14292 0 3
1521: ST_TO_ADDR
// if Joan then
1522: LD_EXP 30
1526: IFFALSE 1543
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1528: LD_EXP 30
1532: PPUSH
1533: LD_INT 13
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1543: LD_ADDR_EXP 31
1547: PUSH
1548: LD_STRING DeltaDoctor
1550: PPUSH
1551: LD_EXP 1
1555: NOT
1556: PPUSH
1557: LD_STRING 12a_
1559: PPUSH
1560: CALL 14292 0 3
1564: ST_TO_ADDR
// if DeltaDoctor then
1565: LD_EXP 31
1569: IFFALSE 1586
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1571: LD_EXP 31
1575: PPUSH
1576: LD_INT 13
1578: PPUSH
1579: LD_INT 0
1581: PPUSH
1582: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_STRING 12a_others
1593: PPUSH
1594: CALL_OW 31
1598: ST_TO_ADDR
// if tmp then
1599: LD_VAR 0 4
1603: IFFALSE 1637
// for i in tmp do
1605: LD_ADDR_VAR 0 3
1609: PUSH
1610: LD_VAR 0 4
1614: PUSH
1615: FOR_IN
1616: IFFALSE 1635
// PlaceUnitArea ( i , alliance_start , false ) ;
1618: LD_VAR 0 3
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
1633: GO 1615
1635: POP
1636: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 3
1642: PPUSH
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 12
1648: PPUSH
1649: LD_INT 100
1651: PPUSH
1652: CALL 21527 0 5
// veh := CreateVehicle ;
1656: LD_ADDR_VAR 0 2
1660: PUSH
1661: CALL_OW 45
1665: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1666: LD_VAR 0 2
1670: PPUSH
1671: LD_INT 2
1673: PPUSH
1674: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1678: LD_VAR 0 2
1682: PPUSH
1683: LD_INT 60
1685: PPUSH
1686: LD_INT 6
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1696: LD_VAR 0 2
1700: PPUSH
1701: LD_INT 4
1703: PPUSH
1704: LD_INT 30
1706: PPUSH
1707: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1711: LD_STRING 11_artifact_captured
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 30
1721: IFFALSE 1797
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1723: LD_INT 3
1725: PPUSH
1726: LD_INT 3
1728: PPUSH
1729: LD_INT 3
1731: PPUSH
1732: LD_INT 12
1734: PPUSH
1735: LD_INT 100
1737: PPUSH
1738: CALL 21527 0 5
// veh := CreateVehicle ;
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: CALL_OW 45
1751: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1752: LD_VAR 0 2
1756: PPUSH
1757: LD_INT 3
1759: PPUSH
1760: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1764: LD_VAR 0 2
1768: PPUSH
1769: LD_INT 75
1771: PPUSH
1772: LD_INT 6
1774: PPUSH
1775: LD_INT 0
1777: PPUSH
1778: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1782: LD_VAR 0 2
1786: PPUSH
1787: LD_INT 4
1789: PPUSH
1790: LD_INT 50
1792: PPUSH
1793: CALL_OW 290
// end ; end ;
1797: LD_VAR 0 1
1801: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1802: LD_INT 0
1804: PPUSH
1805: PPUSH
1806: PPUSH
1807: PPUSH
// uc_side := 6 ;
1808: LD_ADDR_OWVAR 20
1812: PUSH
1813: LD_INT 6
1815: ST_TO_ADDR
// uc_nation := 3 ;
1816: LD_ADDR_OWVAR 21
1820: PUSH
1821: LD_INT 3
1823: ST_TO_ADDR
// InitHc ;
1824: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1828: LD_ADDR_EXP 32
1832: PUSH
1833: LD_STRING Gossudarov
1835: PPUSH
1836: CALL_OW 25
1840: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1841: LD_ADDR_EXP 33
1845: PUSH
1846: LD_STRING Kirilenkova
1848: PPUSH
1849: CALL_OW 25
1853: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1854: LD_ADDR_EXP 34
1858: PUSH
1859: LD_STRING Titov
1861: PPUSH
1862: CALL_OW 25
1866: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1867: LD_ADDR_EXP 39
1871: PUSH
1872: LD_STRING Oblukov
1874: PPUSH
1875: CALL_OW 25
1879: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1880: LD_ADDR_EXP 36
1884: PUSH
1885: LD_STRING Dolgov
1887: PPUSH
1888: CALL_OW 25
1892: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1893: LD_ADDR_EXP 37
1897: PUSH
1898: LD_STRING Petrosyan
1900: PPUSH
1901: CALL_OW 25
1905: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1906: LD_ADDR_EXP 38
1910: PUSH
1911: LD_STRING Scholtze
1913: PPUSH
1914: CALL_OW 25
1918: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1919: LD_ADDR_EXP 40
1923: PUSH
1924: LD_STRING Kapitsova
1926: PPUSH
1927: CALL_OW 25
1931: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1932: LD_ADDR_VAR 0 2
1936: PUSH
1937: LD_EXP 32
1941: PUSH
1942: LD_EXP 33
1946: PUSH
1947: LD_EXP 34
1951: PUSH
1952: LD_EXP 39
1956: PUSH
1957: LD_EXP 36
1961: PUSH
1962: LD_EXP 37
1966: PUSH
1967: LD_EXP 38
1971: PUSH
1972: LD_EXP 40
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: LIST
1986: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1987: LD_INT 1
1989: PPUSH
1990: LD_INT 4
1992: PPUSH
1993: LD_INT 8
1995: PPUSH
1996: CALL_OW 380
// un := CreateHuman ;
2000: LD_ADDR_VAR 0 4
2004: PUSH
2005: CALL_OW 44
2009: ST_TO_ADDR
// tmp := tmp ^ un ;
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_VAR 0 4
2024: ADD
2025: ST_TO_ADDR
// for i in tmp do
2026: LD_ADDR_VAR 0 3
2030: PUSH
2031: LD_VAR 0 2
2035: PUSH
2036: FOR_IN
2037: IFFALSE 2056
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2039: LD_VAR 0 3
2043: PPUSH
2044: LD_INT 14
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: CALL_OW 49
2054: GO 2036
2056: POP
2057: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_EXP 3
2067: PPUSH
2068: CALL_OW 250
2072: PPUSH
2073: LD_EXP 3
2077: PPUSH
2078: CALL_OW 251
2082: PPUSH
2083: CALL_OW 111
// end ;
2087: LD_VAR 0 1
2091: RET
// export function PrepareBelkov ; begin
2092: LD_INT 0
2094: PPUSH
// uc_side := 4 ;
2095: LD_ADDR_OWVAR 20
2099: PUSH
2100: LD_INT 4
2102: ST_TO_ADDR
// uc_nation := 3 ;
2103: LD_ADDR_OWVAR 21
2107: PUSH
2108: LD_INT 3
2110: ST_TO_ADDR
// InitHc ;
2111: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2115: LD_ADDR_EXP 47
2119: PUSH
2120: LD_STRING Belkov
2122: PPUSH
2123: CALL_OW 25
2127: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2128: LD_EXP 47
2132: PPUSH
2133: LD_INT 14
2135: PPUSH
2136: LD_INT 0
2138: PPUSH
2139: CALL_OW 49
// end ;
2143: LD_VAR 0 1
2147: RET
// export function PrepareGnyevko ; begin
2148: LD_INT 0
2150: PPUSH
// uc_side := 4 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 4
2158: ST_TO_ADDR
// uc_nation := 3 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 3
2166: ST_TO_ADDR
// InitHc ;
2167: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2171: LD_ADDR_EXP 48
2175: PUSH
2176: LD_STRING Gnyevko
2178: PPUSH
2179: CALL_OW 25
2183: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2184: LD_EXP 48
2188: PPUSH
2189: LD_INT 14
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 49
// end ;
2199: LD_VAR 0 1
2203: RET
// export function PrepareBurlak ; var i , tmp ; begin
2204: LD_INT 0
2206: PPUSH
2207: PPUSH
2208: PPUSH
// uc_side := 4 ;
2209: LD_ADDR_OWVAR 20
2213: PUSH
2214: LD_INT 4
2216: ST_TO_ADDR
// uc_nation := 3 ;
2217: LD_ADDR_OWVAR 21
2221: PUSH
2222: LD_INT 3
2224: ST_TO_ADDR
// InitHc ;
2225: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2229: LD_ADDR_EXP 46
2233: PUSH
2234: LD_STRING Burlak
2236: PPUSH
2237: CALL_OW 25
2241: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2242: LD_INT 24
2244: PUSH
2245: LD_INT 23
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: PUSH
2256: LD_OWVAR 67
2260: ARRAY
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 1
2267: PPUSH
2268: LD_INT 45
2270: PUSH
2271: LD_INT 44
2273: PUSH
2274: LD_INT 43
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: LIST
2281: PUSH
2282: LD_OWVAR 67
2286: ARRAY
2287: PPUSH
2288: LD_INT 0
2290: PPUSH
2291: CALL 21527 0 5
// Masha := CreateVehicle ;
2295: LD_ADDR_EXP 49
2299: PUSH
2300: CALL_OW 45
2304: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2305: LD_EXP 49
2309: PUSH
2310: LD_EXP 46
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PPUSH
2319: LD_INT 499
2321: PPUSH
2322: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2326: LD_EXP 49
2330: PPUSH
2331: LD_INT 3
2333: PPUSH
2334: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2338: LD_EXP 49
2342: PPUSH
2343: LD_INT 1
2345: PPUSH
2346: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2350: LD_INT 1
2352: PPUSH
2353: LD_INT 18
2355: PPUSH
2356: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2360: LD_INT 35
2362: PPUSH
2363: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 18
2374: PPUSH
2375: EMPTY
2376: PPUSH
2377: CALL_OW 70
2381: ST_TO_ADDR
// if tmp then
2382: LD_VAR 0 3
2386: IFFALSE 2420
// for i in tmp do
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 3
2397: PUSH
2398: FOR_IN
2399: IFFALSE 2418
// ComMoveXY ( i , 114 , 9 ) ;
2401: LD_VAR 0 2
2405: PPUSH
2406: LD_INT 114
2408: PPUSH
2409: LD_INT 9
2411: PPUSH
2412: CALL_OW 111
2416: GO 2398
2418: POP
2419: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2420: LD_INT 18
2422: PPUSH
2423: EMPTY
2424: PPUSH
2425: CALL_OW 70
2429: NOT
2430: PUSH
2431: LD_INT 123
2433: PPUSH
2434: LD_INT 3
2436: PPUSH
2437: CALL_OW 428
2441: PUSH
2442: LD_INT 0
2444: EQUAL
2445: AND
2446: IFFALSE 2360
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2448: LD_EXP 49
2452: PPUSH
2453: LD_INT 123
2455: PPUSH
2456: LD_INT 3
2458: PPUSH
2459: LD_INT 0
2461: PPUSH
2462: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2466: LD_EXP 46
2470: PPUSH
2471: LD_INT 125
2473: PPUSH
2474: LD_INT 1
2476: PPUSH
2477: LD_INT 0
2479: PPUSH
2480: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2484: LD_EXP 46
2488: PPUSH
2489: LD_EXP 49
2493: PPUSH
2494: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2498: LD_INT 10
2500: PPUSH
2501: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2505: LD_EXP 49
2509: PPUSH
2510: LD_INT 110
2512: PPUSH
2513: LD_INT 10
2515: PPUSH
2516: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2520: LD_ADDR_EXP 42
2524: PUSH
2525: LD_STRING Petrovova
2527: PPUSH
2528: CALL_OW 25
2532: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2533: LD_ADDR_EXP 44
2537: PUSH
2538: LD_STRING Kuzmov
2540: PPUSH
2541: CALL_OW 25
2545: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2546: LD_ADDR_EXP 43
2550: PUSH
2551: LD_STRING Kovalyuk
2553: PPUSH
2554: CALL_OW 25
2558: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2559: LD_ADDR_EXP 41
2563: PUSH
2564: LD_STRING Lipshchin
2566: PPUSH
2567: CALL_OW 25
2571: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2572: LD_ADDR_EXP 45
2576: PUSH
2577: LD_STRING Karamazov
2579: PPUSH
2580: CALL_OW 25
2584: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: LD_EXP 42
2594: PUSH
2595: LD_EXP 44
2599: PUSH
2600: LD_EXP 43
2604: PUSH
2605: LD_EXP 41
2609: PUSH
2610: LD_EXP 45
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: LIST
2621: ST_TO_ADDR
// for i in tmp do
2622: LD_ADDR_VAR 0 2
2626: PUSH
2627: LD_VAR 0 3
2631: PUSH
2632: FOR_IN
2633: IFFALSE 2672
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2635: LD_VAR 0 2
2639: PPUSH
2640: LD_INT 399
2642: PPUSH
2643: LD_INT 799
2645: PPUSH
2646: CALL_OW 12
2650: PPUSH
2651: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2655: LD_VAR 0 2
2659: PPUSH
2660: LD_INT 19
2662: PPUSH
2663: LD_INT 0
2665: PPUSH
2666: CALL_OW 49
// end ;
2670: GO 2632
2672: POP
2673: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2674: LD_VAR 0 3
2678: PPUSH
2679: LD_INT 116
2681: PPUSH
2682: LD_INT 8
2684: PPUSH
2685: CALL_OW 111
// AddComHold ( tmp ) ;
2689: LD_VAR 0 3
2693: PPUSH
2694: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2698: LD_ADDR_VAR 0 2
2702: PUSH
2703: LD_VAR 0 3
2707: PPUSH
2708: LD_INT 25
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PPUSH
2718: CALL_OW 72
2722: PUSH
2723: FOR_IN
2724: IFFALSE 2764
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2726: LD_VAR 0 2
2730: PPUSH
2731: LD_INT 20
2733: PPUSH
2734: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 147
2745: PPUSH
2746: LD_INT 45
2748: PPUSH
2749: CALL_OW 178
// AddComCrawl ( i ) ;
2753: LD_VAR 0 2
2757: PPUSH
2758: CALL_OW 197
// end ;
2762: GO 2723
2764: POP
2765: POP
// repeat wait ( 0 0$1 ) ;
2766: LD_INT 35
2768: PPUSH
2769: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2773: LD_EXP 49
2777: PPUSH
2778: LD_INT 110
2780: PPUSH
2781: LD_INT 10
2783: PPUSH
2784: CALL_OW 307
2788: PUSH
2789: LD_EXP 49
2793: PPUSH
2794: CALL_OW 305
2798: NOT
2799: OR
2800: IFFALSE 2766
// ComStop ( Burlak ) ;
2802: LD_EXP 46
2806: PPUSH
2807: CALL_OW 141
// AddComHold ( Burlak ) ;
2811: LD_EXP 46
2815: PPUSH
2816: CALL_OW 200
// end ; end_of_file
2820: LD_VAR 0 1
2824: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
2829: PPUSH
2830: PPUSH
// uc_side := 3 ;
2831: LD_ADDR_OWVAR 20
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// uc_nation := 3 ;
2839: LD_ADDR_OWVAR 21
2843: PUSH
2844: LD_INT 3
2846: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2847: LD_ADDR_EXP 50
2851: PUSH
2852: LD_INT 47
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: LD_STRING 
2860: PPUSH
2861: LD_INT 7
2863: PUSH
2864: LD_INT 8
2866: PUSH
2867: LD_INT 9
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PUSH
2875: LD_OWVAR 67
2879: ARRAY
2880: PPUSH
2881: LD_INT 10000
2883: PUSH
2884: LD_INT 3000
2886: PUSH
2887: LD_INT 300
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: LIST
2894: PPUSH
2895: LD_INT 9
2897: PUSH
2898: LD_INT 5
2900: PUSH
2901: LD_INT 6
2903: PUSH
2904: LD_INT 6
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: PPUSH
2913: CALL 24936 0 6
2917: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2918: LD_ADDR_EXP 59
2922: PUSH
2923: LD_EXP 59
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_EXP 50
2935: PPUSH
2936: CALL_OW 1
2940: ST_TO_ADDR
// tmp := [ ] ;
2941: LD_ADDR_VAR 0 4
2945: PUSH
2946: EMPTY
2947: ST_TO_ADDR
// for i = 1 to 4 do
2948: LD_ADDR_VAR 0 2
2952: PUSH
2953: DOUBLE
2954: LD_INT 1
2956: DEC
2957: ST_TO_ADDR
2958: LD_INT 4
2960: PUSH
2961: FOR_TO
2962: IFFALSE 3055
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2964: LD_INT 22
2966: PPUSH
2967: LD_INT 3
2969: PPUSH
2970: LD_INT 3
2972: PPUSH
2973: LD_INT 43
2975: PUSH
2976: LD_INT 45
2978: PUSH
2979: LD_INT 45
2981: PUSH
2982: LD_INT 44
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: PUSH
2991: LD_VAR 0 2
2995: PUSH
2996: LD_INT 4
2998: MOD
2999: PUSH
3000: LD_INT 1
3002: PLUS
3003: ARRAY
3004: PPUSH
3005: LD_INT 100
3007: PPUSH
3008: CALL 21527 0 5
// veh := CreateVehicle ;
3012: LD_ADDR_VAR 0 3
3016: PUSH
3017: CALL_OW 45
3021: ST_TO_ADDR
// tmp := tmp ^ veh ;
3022: LD_ADDR_VAR 0 4
3026: PUSH
3027: LD_VAR 0 4
3031: PUSH
3032: LD_VAR 0 3
3036: ADD
3037: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3038: LD_VAR 0 3
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 49
// end ;
3053: GO 2961
3055: POP
3056: POP
// russian_guard := tmp ;
3057: LD_ADDR_EXP 51
3061: PUSH
3062: LD_VAR 0 4
3066: ST_TO_ADDR
// end ;
3067: LD_VAR 0 1
3071: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3072: LD_INT 47
3074: PPUSH
3075: CALL_OW 302
3079: PUSH
3080: LD_EXP 6
3084: AND
3085: IFFALSE 3687
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
// begin enable ;
3098: ENABLE
// base := 2 ;
3099: LD_ADDR_VAR 0 2
3103: PUSH
3104: LD_INT 2
3106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3107: LD_ADDR_VAR 0 4
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: LD_INT 0
3117: PUSH
3118: LD_INT 0
3120: PUSH
3121: LD_INT 0
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 0
3129: PUSH
3130: LD_INT 0
3132: PUSH
3133: LD_INT 0
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: LD_INT 0
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3154: LD_ADDR_VAR 0 3
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_INT 45
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 21
3179: PUSH
3180: LD_INT 1
3182: PUSH
3183: LD_INT 3
3185: PUSH
3186: LD_INT 45
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 22
3197: PUSH
3198: LD_INT 1
3200: PUSH
3201: LD_INT 3
3203: PUSH
3204: LD_INT 45
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 23
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: LD_INT 3
3221: PUSH
3222: LD_INT 46
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3237: LD_ADDR_VAR 0 1
3241: PUSH
3242: DOUBLE
3243: LD_INT 1
3245: DEC
3246: ST_TO_ADDR
3247: LD_OWVAR 67
3251: PUSH
3252: LD_OWVAR 1
3256: PUSH
3257: LD_INT 21000
3259: DIV
3260: PLUS
3261: PUSH
3262: FOR_TO
3263: IFFALSE 3351
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3265: LD_ADDR_VAR 0 3
3269: PUSH
3270: LD_VAR 0 3
3274: PPUSH
3275: LD_VAR 0 3
3279: PUSH
3280: LD_INT 1
3282: PLUS
3283: PPUSH
3284: LD_INT 23
3286: PUSH
3287: LD_INT 24
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 1
3296: PPUSH
3297: LD_INT 2
3299: PPUSH
3300: CALL_OW 12
3304: ARRAY
3305: PUSH
3306: LD_INT 1
3308: PUSH
3309: LD_INT 3
3311: PUSH
3312: LD_INT 46
3314: PUSH
3315: LD_INT 47
3317: PUSH
3318: LD_INT 45
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 1
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: CALL_OW 12
3336: ARRAY
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 2
3348: ST_TO_ADDR
3349: GO 3262
3351: POP
3352: POP
// MC_InsertProduceList ( base , tmp ) ;
3353: LD_VAR 0 2
3357: PPUSH
3358: LD_VAR 0 3
3362: PPUSH
3363: CALL 81279 0 2
// repeat wait ( 0 0$1 ) ;
3367: LD_INT 35
3369: PPUSH
3370: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3374: LD_EXP 78
3378: PUSH
3379: LD_VAR 0 2
3383: ARRAY
3384: PUSH
3385: LD_INT 6
3387: GREATER
3388: IFFALSE 3367
// wait ( 0 0$20 ) ;
3390: LD_INT 700
3392: PPUSH
3393: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3397: LD_ADDR_VAR 0 5
3401: PUSH
3402: LD_INT 71
3404: PUSH
3405: LD_INT 19
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PUSH
3412: LD_INT 91
3414: PUSH
3415: LD_INT 67
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PUSH
3422: LD_INT 52
3424: PUSH
3425: LD_INT 44
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 68
3434: PUSH
3435: LD_INT 48
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3448: LD_ADDR_VAR 0 6
3452: PUSH
3453: LD_EXP 78
3457: PUSH
3458: LD_VAR 0 2
3462: ARRAY
3463: PUSH
3464: LD_EXP 78
3468: PUSH
3469: LD_VAR 0 2
3473: ARRAY
3474: PPUSH
3475: LD_INT 2
3477: PUSH
3478: LD_INT 34
3480: PUSH
3481: LD_INT 51
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 34
3490: PUSH
3491: LD_INT 52
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: PPUSH
3503: CALL_OW 72
3507: DIFF
3508: ST_TO_ADDR
// if not attackers then
3509: LD_VAR 0 6
3513: NOT
3514: IFFALSE 3518
// exit ;
3516: GO 3687
// ru_attackers := attackers ;
3518: LD_ADDR_EXP 52
3522: PUSH
3523: LD_VAR 0 6
3527: ST_TO_ADDR
// for i = 1 to attackers do
3528: LD_ADDR_VAR 0 1
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_VAR 0 6
3542: PUSH
3543: FOR_TO
3544: IFFALSE 3621
// begin case i mod 3 of 0 :
3546: LD_VAR 0 1
3550: PUSH
3551: LD_INT 3
3553: MOD
3554: PUSH
3555: LD_INT 0
3557: DOUBLE
3558: EQUAL
3559: IFTRUE 3563
3561: GO 3566
3563: POP
// ; 1 :
3564: GO 3619
3566: LD_INT 1
3568: DOUBLE
3569: EQUAL
3570: IFTRUE 3574
3572: GO 3592
3574: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3575: LD_VAR 0 1
3579: PPUSH
3580: LD_INT 32
3582: PPUSH
3583: LD_INT 49
3585: PPUSH
3586: CALL_OW 114
3590: GO 3619
3592: LD_INT 2
3594: DOUBLE
3595: EQUAL
3596: IFTRUE 3600
3598: GO 3618
3600: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3601: LD_VAR 0 1
3605: PPUSH
3606: LD_INT 117
3608: PPUSH
3609: LD_INT 107
3611: PPUSH
3612: CALL_OW 114
3616: GO 3619
3618: POP
// end ;
3619: GO 3543
3621: POP
3622: POP
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3630: LD_VAR 0 6
3634: PPUSH
3635: LD_INT 60
3637: PUSH
3638: EMPTY
3639: LIST
3640: PPUSH
3641: CALL_OW 72
3645: NOT
3646: IFFALSE 3623
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3648: LD_VAR 0 2
3652: PPUSH
3653: LD_VAR 0 6
3657: PPUSH
3658: LD_VAR 0 5
3662: PPUSH
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL 81464 0 4
// if not first_attack then
3672: LD_EXP 7
3676: NOT
3677: IFFALSE 3687
// first_attack := true ;
3679: LD_ADDR_EXP 7
3683: PUSH
3684: LD_INT 1
3686: ST_TO_ADDR
// end ; end_of_file
3687: PPOPN 6
3689: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3690: LD_INT 0
3692: PPUSH
3693: PPUSH
3694: PPUSH
3695: PPUSH
3696: PPUSH
3697: PPUSH
3698: PPUSH
// uc_side := 2 ;
3699: LD_ADDR_OWVAR 20
3703: PUSH
3704: LD_INT 2
3706: ST_TO_ADDR
// uc_nation := 2 ;
3707: LD_ADDR_OWVAR 21
3711: PUSH
3712: LD_INT 2
3714: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3715: LD_ADDR_EXP 55
3719: PUSH
3720: LD_STRING Abdul
3722: PPUSH
3723: CALL_OW 25
3727: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3728: LD_EXP 55
3732: PPUSH
3733: LD_INT 11
3735: PPUSH
3736: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3740: LD_EXP 55
3744: PPUSH
3745: LD_INT 1
3747: PPUSH
3748: CALL_OW 52
// vc_chassis := 31 ;
3752: LD_ADDR_OWVAR 37
3756: PUSH
3757: LD_INT 31
3759: ST_TO_ADDR
// vc_control := control_rider ;
3760: LD_ADDR_OWVAR 38
3764: PUSH
3765: LD_INT 4
3767: ST_TO_ADDR
// mastodont := CreateVehicle ;
3768: LD_ADDR_EXP 56
3772: PUSH
3773: CALL_OW 45
3777: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3778: LD_EXP 56
3782: PPUSH
3783: LD_INT 153
3785: PPUSH
3786: LD_INT 71
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// InitVc ;
3796: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3800: LD_ADDR_EXP 53
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_STRING 
3813: PPUSH
3814: LD_INT 7
3816: PUSH
3817: LD_INT 8
3819: PUSH
3820: LD_INT 9
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PUSH
3828: LD_OWVAR 67
3832: ARRAY
3833: PPUSH
3834: LD_INT 5000
3836: PUSH
3837: LD_INT 1000
3839: PUSH
3840: LD_INT 300
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: PPUSH
3848: LD_INT 22
3850: PUSH
3851: LD_INT 5
3853: PUSH
3854: LD_INT 6
3856: PUSH
3857: LD_INT 9
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: PPUSH
3866: CALL 24936 0 6
3870: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3871: LD_ADDR_EXP 59
3875: PUSH
3876: LD_EXP 59
3880: PPUSH
3881: LD_INT 1
3883: PPUSH
3884: LD_EXP 53
3888: PPUSH
3889: CALL_OW 1
3893: ST_TO_ADDR
// tmp := [ ] ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: EMPTY
3900: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3901: LD_ADDR_OWVAR 37
3905: PUSH
3906: LD_INT 14
3908: ST_TO_ADDR
// vc_engine := engine_siberite ;
3909: LD_ADDR_OWVAR 39
3913: PUSH
3914: LD_INT 3
3916: ST_TO_ADDR
// vc_control := control_manual ;
3917: LD_ADDR_OWVAR 38
3921: PUSH
3922: LD_INT 1
3924: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3925: LD_ADDR_OWVAR 40
3929: PUSH
3930: LD_INT 31
3932: ST_TO_ADDR
// for i = 1 to 3 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 3
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4191
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3949: LD_ADDR_VAR 0 5
3953: PUSH
3954: LD_INT 153
3956: PUSH
3957: LD_INT 71
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 155
3966: PUSH
3967: LD_INT 81
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PUSH
3978: LD_VAR 0 2
3982: PUSH
3983: LD_INT 2
3985: MOD
3986: PUSH
3987: LD_INT 1
3989: PLUS
3990: ARRAY
3991: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3992: LD_INT 0
3994: PPUSH
3995: LD_INT 3
3997: PPUSH
3998: LD_INT 7
4000: PUSH
4001: LD_INT 8
4003: PUSH
4004: LD_INT 9
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: LIST
4011: PUSH
4012: LD_OWVAR 67
4016: ARRAY
4017: PPUSH
4018: CALL_OW 380
// un := CreateVehicle ;
4022: LD_ADDR_VAR 0 6
4026: PUSH
4027: CALL_OW 45
4031: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4032: LD_VAR 0 6
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: LD_INT 5
4042: PPUSH
4043: CALL_OW 12
4047: PPUSH
4048: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PUSH
4062: LD_INT 1
4064: ARRAY
4065: PPUSH
4066: LD_VAR 0 5
4070: PUSH
4071: LD_INT 2
4073: ARRAY
4074: PPUSH
4075: LD_INT 6
4077: PPUSH
4078: LD_INT 0
4080: PPUSH
4081: CALL_OW 50
// un2 := CreateHuman ;
4085: LD_ADDR_VAR 0 7
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4095: LD_VAR 0 7
4099: PPUSH
4100: LD_VAR 0 6
4104: PPUSH
4105: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4109: LD_ADDR_EXP 59
4113: PUSH
4114: LD_EXP 59
4118: PPUSH
4119: LD_INT 1
4121: PUSH
4122: LD_EXP 59
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PPUSH
4139: LD_VAR 0 6
4143: PPUSH
4144: CALL 21649 0 3
4148: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4149: LD_ADDR_EXP 59
4153: PUSH
4154: LD_EXP 59
4158: PPUSH
4159: LD_INT 1
4161: PUSH
4162: LD_EXP 59
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PUSH
4171: LD_INT 1
4173: PLUS
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: PPUSH
4179: LD_VAR 0 7
4183: PPUSH
4184: CALL 21649 0 3
4188: ST_TO_ADDR
// end ;
4189: GO 3946
4191: POP
4192: POP
// for i = 1 to 5 do
4193: LD_ADDR_VAR 0 2
4197: PUSH
4198: DOUBLE
4199: LD_INT 1
4201: DEC
4202: ST_TO_ADDR
4203: LD_INT 5
4205: PUSH
4206: FOR_TO
4207: IFFALSE 4300
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4209: LD_INT 14
4211: PPUSH
4212: LD_INT 3
4214: PPUSH
4215: LD_INT 1
4217: PPUSH
4218: LD_INT 25
4220: PUSH
4221: LD_INT 28
4223: PUSH
4224: LD_INT 28
4226: PUSH
4227: LD_INT 26
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: PUSH
4236: LD_VAR 0 2
4240: PUSH
4241: LD_INT 4
4243: MOD
4244: PUSH
4245: LD_INT 1
4247: PLUS
4248: ARRAY
4249: PPUSH
4250: LD_INT 100
4252: PPUSH
4253: CALL 21527 0 5
// veh := CreateVehicle ;
4257: LD_ADDR_VAR 0 3
4261: PUSH
4262: CALL_OW 45
4266: ST_TO_ADDR
// tmp := tmp ^ veh ;
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: LD_VAR 0 4
4276: PUSH
4277: LD_VAR 0 3
4281: ADD
4282: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4283: LD_VAR 0 3
4287: PPUSH
4288: LD_INT 1
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// end ;
4298: GO 4206
4300: POP
4301: POP
// arabian_guard := tmp ;
4302: LD_ADDR_EXP 54
4306: PUSH
4307: LD_VAR 0 4
4311: ST_TO_ADDR
// end ;
4312: LD_VAR 0 1
4316: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4317: LD_INT 22
4319: PUSH
4320: LD_INT 7
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: PUSH
4327: LD_INT 91
4329: PUSH
4330: LD_INT 1
4332: PUSH
4333: LD_INT 12
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PPUSH
4345: CALL_OW 69
4349: PUSH
4350: LD_EXP 56
4354: PPUSH
4355: CALL_OW 256
4359: PUSH
4360: LD_INT 990
4362: LESS
4363: OR
4364: PUSH
4365: LD_EXP 55
4369: PPUSH
4370: CALL_OW 256
4374: PUSH
4375: LD_INT 990
4377: LESS
4378: OR
4379: IFFALSE 4522
4381: GO 4383
4383: DISABLE
// begin if IsInUnit ( Abdul ) then
4384: LD_EXP 55
4388: PPUSH
4389: CALL_OW 310
4393: IFFALSE 4404
// ComExitBuilding ( Abdul ) ;
4395: LD_EXP 55
4399: PPUSH
4400: CALL_OW 122
// if Mastodont then
4404: LD_EXP 56
4408: IFFALSE 4425
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4410: LD_EXP 56
4414: PPUSH
4415: LD_INT 205
4417: PPUSH
4418: LD_INT 132
4420: PPUSH
4421: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4425: LD_EXP 55
4429: PPUSH
4430: LD_INT 205
4432: PPUSH
4433: LD_INT 132
4435: PPUSH
4436: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4440: LD_INT 35
4442: PPUSH
4443: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4447: LD_EXP 55
4451: PPUSH
4452: LD_INT 21
4454: PPUSH
4455: CALL_OW 308
4459: IFFALSE 4440
// RemoveUnit ( Abdul ) ;
4461: LD_EXP 55
4465: PPUSH
4466: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4470: LD_INT 35
4472: PPUSH
4473: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4477: LD_EXP 56
4481: PPUSH
4482: LD_INT 21
4484: PPUSH
4485: CALL_OW 308
4489: PUSH
4490: LD_EXP 56
4494: PPUSH
4495: CALL_OW 301
4499: OR
4500: IFFALSE 4470
// if IsOk ( Mastodont ) then
4502: LD_EXP 56
4506: PPUSH
4507: CALL_OW 302
4511: IFFALSE 4522
// RemoveUnit ( Mastodont ) ;
4513: LD_EXP 56
4517: PPUSH
4518: CALL_OW 64
// end ;
4522: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4523: LD_EXP 55
4527: PPUSH
4528: CALL_OW 301
4532: PUSH
4533: LD_INT 22
4535: PUSH
4536: LD_INT 2
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: LD_INT 2
4545: PUSH
4546: LD_INT 25
4548: PUSH
4549: LD_INT 1
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 2
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 25
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 25
4578: PUSH
4579: LD_INT 4
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 25
4588: PUSH
4589: LD_INT 8
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: PPUSH
4608: CALL_OW 69
4612: PUSH
4613: LD_INT 16
4615: PUSH
4616: LD_INT 19
4618: PUSH
4619: LD_INT 22
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: LIST
4626: PUSH
4627: LD_OWVAR 67
4631: ARRAY
4632: LESS
4633: OR
4634: IFFALSE 5307
4636: GO 4638
4638: DISABLE
4639: LD_INT 0
4641: PPUSH
4642: PPUSH
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
// begin MC_Kill ( 1 ) ;
4647: LD_INT 1
4649: PPUSH
4650: CALL 57819 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4654: LD_ADDR_VAR 0 2
4658: PUSH
4659: LD_INT 22
4661: PUSH
4662: LD_INT 2
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: LD_INT 25
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: LD_INT 25
4684: PUSH
4685: LD_INT 2
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 25
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 25
4704: PUSH
4705: LD_INT 4
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 25
4714: PUSH
4715: LD_INT 8
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PPUSH
4734: CALL_OW 69
4738: ST_TO_ADDR
// for i in tmp do
4739: LD_ADDR_VAR 0 5
4743: PUSH
4744: LD_VAR 0 2
4748: PUSH
4749: FOR_IN
4750: IFFALSE 4766
// SetTag ( i , 10 ) ;
4752: LD_VAR 0 5
4756: PPUSH
4757: LD_INT 10
4759: PPUSH
4760: CALL_OW 109
4764: GO 4749
4766: POP
4767: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4768: LD_ADDR_VAR 0 3
4772: PUSH
4773: LD_INT 22
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 21
4785: PUSH
4786: LD_INT 1
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PPUSH
4797: CALL_OW 69
4801: PUSH
4802: LD_VAR 0 2
4806: DIFF
4807: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4808: LD_ADDR_VAR 0 1
4812: PUSH
4813: LD_INT 22
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 21
4825: PUSH
4826: LD_INT 2
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 24
4835: PUSH
4836: LD_INT 300
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: LIST
4847: PPUSH
4848: CALL_OW 69
4852: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4853: LD_ADDR_VAR 0 4
4857: PUSH
4858: LD_VAR 0 1
4862: PPUSH
4863: LD_INT 33
4865: PUSH
4866: LD_INT 1
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: PUSH
4873: LD_INT 58
4875: PUSH
4876: EMPTY
4877: LIST
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: PPUSH
4883: CALL_OW 72
4887: ST_TO_ADDR
// for i in tmp do
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_VAR 0 2
4897: PUSH
4898: FOR_IN
4899: IFFALSE 5083
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4901: LD_VAR 0 5
4905: PUSH
4906: LD_INT 55
4908: PUSH
4909: EMPTY
4910: LIST
4911: PPUSH
4912: CALL_OW 69
4916: IN
4917: IFFALSE 4936
// begin AddComMoveXY ( i , 209 , 132 ) ;
4919: LD_VAR 0 5
4923: PPUSH
4924: LD_INT 209
4926: PPUSH
4927: LD_INT 132
4929: PPUSH
4930: CALL_OW 171
// continue ;
4934: GO 4898
// end ; if IsInUnit ( i ) then
4936: LD_VAR 0 5
4940: PPUSH
4941: CALL_OW 310
4945: IFFALSE 4963
// begin ComExitBuilding ( i ) ;
4947: LD_VAR 0 5
4951: PPUSH
4952: CALL_OW 122
// wait ( 3 ) ;
4956: LD_INT 3
4958: PPUSH
4959: CALL_OW 67
// end ; if tmp_empty then
4963: LD_VAR 0 4
4967: IFFALSE 5066
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4969: LD_VAR 0 5
4973: PPUSH
4974: LD_VAR 0 4
4978: PPUSH
4979: LD_VAR 0 5
4983: PPUSH
4984: CALL_OW 74
4988: PPUSH
4989: CALL_OW 296
4993: PUSH
4994: LD_INT 25
4996: LESS
4997: IFFALSE 5066
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4999: LD_ADDR_VAR 0 6
5003: PUSH
5004: LD_VAR 0 4
5008: PPUSH
5009: LD_VAR 0 5
5013: PPUSH
5014: CALL_OW 74
5018: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5019: LD_VAR 0 5
5023: PPUSH
5024: LD_VAR 0 6
5028: PPUSH
5029: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5033: LD_VAR 0 5
5037: PPUSH
5038: LD_INT 209
5040: PPUSH
5041: LD_INT 132
5043: PPUSH
5044: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5048: LD_ADDR_VAR 0 4
5052: PUSH
5053: LD_VAR 0 4
5057: PUSH
5058: LD_VAR 0 6
5062: DIFF
5063: ST_TO_ADDR
// continue ;
5064: GO 4898
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5066: LD_VAR 0 5
5070: PPUSH
5071: LD_INT 201
5073: PPUSH
5074: LD_INT 132
5076: PPUSH
5077: CALL_OW 171
// end ;
5081: GO 4898
5083: POP
5084: POP
// for i in tmp_ape do
5085: LD_ADDR_VAR 0 5
5089: PUSH
5090: LD_VAR 0 3
5094: PUSH
5095: FOR_IN
5096: IFFALSE 5135
// begin if IsInUnit ( i ) then
5098: LD_VAR 0 5
5102: PPUSH
5103: CALL_OW 310
5107: IFFALSE 5118
// ComExitBuilding ( i ) ;
5109: LD_VAR 0 5
5113: PPUSH
5114: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5118: LD_VAR 0 5
5122: PPUSH
5123: LD_INT 201
5125: PPUSH
5126: LD_INT 132
5128: PPUSH
5129: CALL_OW 171
// end ;
5133: GO 5095
5135: POP
5136: POP
// repeat wait ( 0 0$1 ) ;
5137: LD_INT 35
5139: PPUSH
5140: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5144: LD_ADDR_VAR 0 5
5148: PUSH
5149: LD_VAR 0 2
5153: PUSH
5154: LD_VAR 0 3
5158: UNION
5159: PUSH
5160: LD_VAR 0 1
5164: UNION
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5198
// if not HasTask ( i ) then
5169: LD_VAR 0 5
5173: PPUSH
5174: CALL_OW 314
5178: NOT
5179: IFFALSE 5196
// ComMoveXY ( i , 201 , 132 ) ;
5181: LD_VAR 0 5
5185: PPUSH
5186: LD_INT 201
5188: PPUSH
5189: LD_INT 132
5191: PPUSH
5192: CALL_OW 111
5196: GO 5166
5198: POP
5199: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5200: LD_INT 21
5202: PPUSH
5203: LD_INT 22
5205: PUSH
5206: LD_INT 2
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 70
5217: IFFALSE 5258
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_INT 21
5226: PPUSH
5227: LD_INT 22
5229: PUSH
5230: LD_INT 2
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 70
5241: PUSH
5242: FOR_IN
5243: IFFALSE 5256
// RemoveUnit ( i ) ;
5245: LD_VAR 0 5
5249: PPUSH
5250: CALL_OW 64
5254: GO 5242
5256: POP
5257: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5258: LD_INT 22
5260: PUSH
5261: LD_INT 2
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 2
5270: PUSH
5271: LD_INT 21
5273: PUSH
5274: LD_INT 1
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: LD_INT 21
5283: PUSH
5284: LD_INT 2
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 69
5304: NOT
5305: IFFALSE 5137
// end ;
5307: PPOPN 6
5309: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5310: LD_EXP 9
5314: PUSH
5315: LD_INT 92
5317: PPUSH
5318: LD_INT 40
5320: PPUSH
5321: CALL_OW 428
5325: PPUSH
5326: CALL_OW 266
5330: PUSH
5331: LD_INT 30
5333: EQUAL
5334: AND
5335: IFFALSE 5531
5337: GO 5339
5339: DISABLE
5340: LD_INT 0
5342: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5343: LD_ADDR_VAR 0 1
5347: PUSH
5348: LD_EXP 59
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_INT 25
5359: PUSH
5360: LD_INT 4
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PPUSH
5367: CALL_OW 72
5371: ST_TO_ADDR
// if not sci then
5372: LD_VAR 0 1
5376: NOT
5377: IFFALSE 5381
// exit ;
5379: GO 5531
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5381: LD_ADDR_EXP 59
5385: PUSH
5386: LD_EXP 59
5390: PPUSH
5391: LD_INT 1
5393: PPUSH
5394: LD_EXP 59
5398: PUSH
5399: LD_INT 1
5401: ARRAY
5402: PUSH
5403: LD_VAR 0 1
5407: PUSH
5408: LD_INT 1
5410: ARRAY
5411: DIFF
5412: PPUSH
5413: CALL_OW 1
5417: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5418: LD_VAR 0 1
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PPUSH
5427: CALL_OW 310
5431: IFFALSE 5446
// ComExitBuilding ( sci [ 1 ] ) ;
5433: LD_VAR 0 1
5437: PUSH
5438: LD_INT 1
5440: ARRAY
5441: PPUSH
5442: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5446: LD_INT 2
5448: PPUSH
5449: LD_INT 105
5451: PPUSH
5452: LD_INT 14
5454: PPUSH
5455: LD_INT 20
5457: PPUSH
5458: CALL 22545 0 4
5462: PUSH
5463: LD_INT 4
5465: ARRAY
5466: PUSH
5467: LD_INT 10
5469: LESS
5470: IFFALSE 5493
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 1
5479: ARRAY
5480: PPUSH
5481: LD_INT 105
5483: PPUSH
5484: LD_INT 14
5486: PPUSH
5487: CALL_OW 171
5491: GO 5512
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5493: LD_VAR 0 1
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: LD_INT 118
5504: PPUSH
5505: LD_INT 77
5507: PPUSH
5508: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5512: LD_VAR 0 1
5516: PUSH
5517: LD_INT 1
5519: ARRAY
5520: PPUSH
5521: LD_INT 92
5523: PPUSH
5524: LD_INT 40
5526: PPUSH
5527: CALL_OW 218
// end ;
5531: PPOPN 1
5533: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5534: LD_INT 1
5536: PPUSH
5537: CALL_OW 302
5541: PUSH
5542: LD_EXP 9
5546: AND
5547: IFFALSE 6006
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
5557: PPUSH
5558: PPUSH
5559: PPUSH
// begin enable ;
5560: ENABLE
// base := 1 ;
5561: LD_ADDR_VAR 0 2
5565: PUSH
5566: LD_INT 1
5568: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5569: LD_ADDR_VAR 0 4
5573: PUSH
5574: LD_INT 0
5576: PUSH
5577: LD_INT 0
5579: PUSH
5580: LD_INT 0
5582: PUSH
5583: LD_INT 0
5585: PUSH
5586: LD_INT 0
5588: PUSH
5589: LD_INT 0
5591: PUSH
5592: LD_INT 0
5594: PUSH
5595: LD_INT 0
5597: PUSH
5598: LD_INT 1
5600: PUSH
5601: LD_INT 0
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5616: LD_ADDR_VAR 0 3
5620: PUSH
5621: LD_INT 14
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 26
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 14
5641: PUSH
5642: LD_INT 1
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: LD_INT 28
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: LD_INT 13
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: LD_INT 29
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: LIST
5679: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5680: LD_ADDR_VAR 0 1
5684: PUSH
5685: DOUBLE
5686: LD_INT 1
5688: DEC
5689: ST_TO_ADDR
5690: LD_OWVAR 67
5694: PUSH
5695: LD_OWVAR 1
5699: PUSH
5700: LD_INT 21000
5702: DIV
5703: PLUS
5704: PUSH
5705: FOR_TO
5706: IFFALSE 5798
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5708: LD_ADDR_VAR 0 3
5712: PUSH
5713: LD_VAR 0 3
5717: PPUSH
5718: LD_VAR 0 3
5722: PUSH
5723: LD_INT 1
5725: PLUS
5726: PPUSH
5727: LD_INT 13
5729: PUSH
5730: LD_INT 14
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: PUSH
5737: LD_INT 1
5739: PPUSH
5740: LD_INT 2
5742: PPUSH
5743: CALL_OW 12
5747: ARRAY
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: LD_INT 2
5754: PUSH
5755: LD_INT 28
5757: PUSH
5758: LD_INT 29
5760: PUSH
5761: LD_INT 25
5763: PUSH
5764: LD_INT 26
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 1
5775: PPUSH
5776: LD_INT 4
5778: PPUSH
5779: CALL_OW 12
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PPUSH
5791: CALL_OW 2
5795: ST_TO_ADDR
5796: GO 5705
5798: POP
5799: POP
// MC_InsertProduceList ( base , tmp ) ;
5800: LD_VAR 0 2
5804: PPUSH
5805: LD_VAR 0 3
5809: PPUSH
5810: CALL 81279 0 2
// repeat wait ( 0 0$1 ) ;
5814: LD_INT 35
5816: PPUSH
5817: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5821: LD_EXP 78
5825: PUSH
5826: LD_VAR 0 2
5830: ARRAY
5831: PUSH
5832: LD_INT 6
5834: GREATER
5835: IFFALSE 5814
// wait ( 0 0$20 ) ;
5837: LD_INT 700
5839: PPUSH
5840: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5844: LD_ADDR_VAR 0 5
5848: PUSH
5849: LD_INT 124
5851: PUSH
5852: LD_INT 85
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_INT 90
5861: PUSH
5862: LD_INT 61
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 69
5871: PUSH
5872: LD_INT 48
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 68
5881: PUSH
5882: LD_INT 48
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5895: LD_ADDR_VAR 0 6
5899: PUSH
5900: LD_EXP 78
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PUSH
5911: LD_EXP 78
5915: PUSH
5916: LD_VAR 0 2
5920: ARRAY
5921: PPUSH
5922: LD_INT 34
5924: PUSH
5925: LD_INT 32
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 72
5936: DIFF
5937: ST_TO_ADDR
// if not attackers then
5938: LD_VAR 0 6
5942: NOT
5943: IFFALSE 5947
// exit ;
5945: GO 6006
// ar_attackers := attackers ;
5947: LD_ADDR_EXP 10
5951: PUSH
5952: LD_VAR 0 6
5956: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5957: LD_INT 35
5959: PPUSH
5960: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5964: LD_VAR 0 6
5968: PPUSH
5969: LD_INT 60
5971: PUSH
5972: EMPTY
5973: LIST
5974: PPUSH
5975: CALL_OW 72
5979: NOT
5980: IFFALSE 5957
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5982: LD_VAR 0 2
5986: PPUSH
5987: LD_VAR 0 6
5991: PPUSH
5992: LD_VAR 0 5
5996: PPUSH
5997: LD_VAR 0 4
6001: PPUSH
6002: CALL 81464 0 4
// end ;
6006: PPOPN 6
6008: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6009: LD_INT 1
6011: PPUSH
6012: CALL_OW 302
6016: PUSH
6017: LD_EXP 9
6021: AND
6022: PUSH
6023: LD_EXP 49
6027: PPUSH
6028: LD_INT 22
6030: PPUSH
6031: CALL_OW 308
6035: AND
6036: PUSH
6037: LD_INT 1
6039: PPUSH
6040: CALL 81627 0 1
6044: PUSH
6045: LD_INT 0
6047: EQUAL
6048: AND
6049: PUSH
6050: LD_EXP 10
6054: NOT
6055: AND
6056: IFFALSE 6520
6058: GO 6060
6060: DISABLE
6061: LD_INT 0
6063: PPUSH
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
6068: PPUSH
6069: PPUSH
// begin base := 1 ;
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_INT 1
6077: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6078: LD_ADDR_VAR 0 4
6082: PUSH
6083: LD_INT 0
6085: PUSH
6086: LD_INT 0
6088: PUSH
6089: LD_INT 0
6091: PUSH
6092: LD_INT 0
6094: PUSH
6095: LD_INT 0
6097: PUSH
6098: LD_INT 0
6100: PUSH
6101: LD_INT 0
6103: PUSH
6104: LD_INT 0
6106: PUSH
6107: LD_INT 1
6109: PUSH
6110: LD_INT 0
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6125: LD_ADDR_VAR 0 3
6129: PUSH
6130: LD_INT 13
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 13
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 27
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 13
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 25
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 11
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 24
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 11
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 24
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6227: LD_VAR 0 2
6231: PPUSH
6232: LD_VAR 0 3
6236: PPUSH
6237: CALL 81279 0 2
// repeat wait ( 0 0$1 ) ;
6241: LD_INT 35
6243: PPUSH
6244: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6248: LD_EXP 78
6252: PUSH
6253: LD_VAR 0 2
6257: ARRAY
6258: PUSH
6259: LD_INT 6
6261: GREATEREQUAL
6262: IFFALSE 6241
// wait ( 0 0$20 ) ;
6264: LD_INT 700
6266: PPUSH
6267: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6271: LD_ADDR_VAR 0 5
6275: PUSH
6276: LD_INT 119
6278: PUSH
6279: LD_INT 9
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PUSH
6286: EMPTY
6287: LIST
6288: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6289: LD_ADDR_VAR 0 6
6293: PUSH
6294: LD_EXP 78
6298: PUSH
6299: LD_VAR 0 2
6303: ARRAY
6304: PUSH
6305: LD_EXP 78
6309: PUSH
6310: LD_VAR 0 2
6314: ARRAY
6315: PPUSH
6316: LD_INT 34
6318: PUSH
6319: LD_INT 32
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: PPUSH
6326: CALL_OW 72
6330: DIFF
6331: ST_TO_ADDR
// if not attackers then
6332: LD_VAR 0 6
6336: NOT
6337: IFFALSE 6341
// exit ;
6339: GO 6520
// uc_side := 2 ;
6341: LD_ADDR_OWVAR 20
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// uc_nation := 2 ;
6349: LD_ADDR_OWVAR 21
6353: PUSH
6354: LD_INT 2
6356: ST_TO_ADDR
// InitHc ;
6357: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6361: LD_ADDR_VAR 0 1
6365: PUSH
6366: DOUBLE
6367: LD_INT 1
6369: DEC
6370: ST_TO_ADDR
6371: LD_INT 4
6373: PUSH
6374: LD_INT 5
6376: PUSH
6377: LD_INT 6
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: LD_OWVAR 67
6389: ARRAY
6390: PUSH
6391: FOR_TO
6392: IFFALSE 6469
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6394: LD_INT 0
6396: PPUSH
6397: LD_INT 15
6399: PUSH
6400: LD_INT 17
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: PPUSH
6419: LD_INT 8
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 7
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6436: LD_VAR 0 7
6440: PPUSH
6441: LD_INT 23
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// attackers := attackers union un ;
6451: LD_ADDR_VAR 0 6
6455: PUSH
6456: LD_VAR 0 6
6460: PUSH
6461: LD_VAR 0 7
6465: UNION
6466: ST_TO_ADDR
// end ;
6467: GO 6391
6469: POP
6470: POP
// repeat wait ( 0 0$1 ) ;
6471: LD_INT 35
6473: PPUSH
6474: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6478: LD_VAR 0 6
6482: PPUSH
6483: LD_INT 60
6485: PUSH
6486: EMPTY
6487: LIST
6488: PPUSH
6489: CALL_OW 72
6493: NOT
6494: IFFALSE 6471
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6496: LD_VAR 0 2
6500: PPUSH
6501: LD_VAR 0 6
6505: PPUSH
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 81464 0 4
// end ; end_of_file
6520: PPOPN 7
6522: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6523: LD_INT 0
6525: PPUSH
6526: PPUSH
6527: PPUSH
6528: PPUSH
// uc_side := 1 ;
6529: LD_ADDR_OWVAR 20
6533: PUSH
6534: LD_INT 1
6536: ST_TO_ADDR
// uc_nation := 1 ;
6537: LD_ADDR_OWVAR 21
6541: PUSH
6542: LD_INT 1
6544: ST_TO_ADDR
// InitHc ;
6545: CALL_OW 19
// InitVc ;
6549: CALL_OW 20
// tmp := [ ] ;
6553: LD_ADDR_VAR 0 3
6557: PUSH
6558: EMPTY
6559: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_INT 5
6572: PUSH
6573: LD_INT 6
6575: PUSH
6576: LD_INT 6
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: LIST
6583: PUSH
6584: LD_OWVAR 67
6588: ARRAY
6589: PUSH
6590: FOR_TO
6591: IFFALSE 6728
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6593: LD_INT 2
6595: PUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: LD_INT 1
6609: PPUSH
6610: LD_INT 3
6612: PPUSH
6613: CALL_OW 12
6617: ARRAY
6618: PPUSH
6619: LD_INT 1
6621: PUSH
6622: LD_INT 3
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 2
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PPUSH
6641: LD_INT 3
6643: PPUSH
6644: LD_INT 9
6646: PUSH
6647: LD_INT 7
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 1
6656: PPUSH
6657: LD_INT 2
6659: PPUSH
6660: CALL_OW 12
6664: ARRAY
6665: PPUSH
6666: LD_INT 78
6668: PPUSH
6669: CALL 21527 0 5
// veh := CreateVehicle ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: CALL_OW 45
6682: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6683: LD_VAR 0 4
6687: PPUSH
6688: LD_INT 2
6690: PPUSH
6691: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6695: LD_VAR 0 4
6699: PPUSH
6700: LD_INT 17
6702: PPUSH
6703: LD_INT 0
6705: PPUSH
6706: CALL_OW 49
// tmp := tmp ^ veh ;
6710: LD_ADDR_VAR 0 3
6714: PUSH
6715: LD_VAR 0 3
6719: PUSH
6720: LD_VAR 0 4
6724: ADD
6725: ST_TO_ADDR
// end ;
6726: GO 6590
6728: POP
6729: POP
// if not tmp then
6730: LD_VAR 0 3
6734: NOT
6735: IFFALSE 6739
// exit ;
6737: GO 6848
// if not first_powell_attack then
6739: LD_EXP 11
6743: NOT
6744: IFFALSE 6754
// first_powell_attack := true ;
6746: LD_ADDR_EXP 11
6750: PUSH
6751: LD_INT 1
6753: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6754: LD_INT 70
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_VAR 0 3
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6839
// if IsOk ( i ) then
6774: LD_VAR 0 2
6778: PPUSH
6779: CALL_OW 302
6783: IFFALSE 6821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6785: LD_VAR 0 2
6789: PPUSH
6790: LD_INT 81
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: PPUSH
6805: LD_VAR 0 2
6809: PPUSH
6810: CALL_OW 74
6814: PPUSH
6815: CALL_OW 115
6819: GO 6837
// tmp := tmp diff i ;
6821: LD_ADDR_VAR 0 3
6825: PUSH
6826: LD_VAR 0 3
6830: PUSH
6831: LD_VAR 0 2
6835: DIFF
6836: ST_TO_ADDR
6837: GO 6771
6839: POP
6840: POP
// until not tmp ;
6841: LD_VAR 0 3
6845: NOT
6846: IFFALSE 6754
// end ; end_of_file
6848: LD_VAR 0 1
6852: RET
// export function Action ; var tmp , i , un ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6859: LD_INT 68
6861: PPUSH
6862: LD_INT 39
6864: PPUSH
6865: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6869: LD_ADDR_VAR 0 2
6873: PUSH
6874: LD_INT 22
6876: PUSH
6877: LD_INT 7
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PPUSH
6884: CALL_OW 69
6888: ST_TO_ADDR
// InGameOn ;
6889: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6893: LD_VAR 0 2
6897: PPUSH
6898: LD_INT 71
6900: PPUSH
6901: LD_INT 49
6903: PPUSH
6904: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6908: LD_INT 35
6910: PPUSH
6911: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6915: LD_INT 7
6917: PPUSH
6918: LD_INT 71
6920: PPUSH
6921: LD_INT 51
6923: PPUSH
6924: CALL_OW 293
6928: IFFALSE 6908
// DialogueOn ;
6930: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6934: LD_EXP 15
6938: PPUSH
6939: LD_STRING D1-JMM-1
6941: PPUSH
6942: CALL_OW 88
// if Joan then
6946: LD_EXP 30
6950: IFFALSE 6964
// Say ( Joan , D1-Joan-1 ) ;
6952: LD_EXP 30
6956: PPUSH
6957: LD_STRING D1-Joan-1
6959: PPUSH
6960: CALL_OW 88
// if Lisa then
6964: LD_EXP 17
6968: IFFALSE 6982
// Say ( Lisa , D1-Lisa-1 ) ;
6970: LD_EXP 17
6974: PPUSH
6975: LD_STRING D1-Lisa-1
6977: PPUSH
6978: CALL_OW 88
// if Joan or Lisa then
6982: LD_EXP 30
6986: PUSH
6987: LD_EXP 17
6991: OR
6992: IFFALSE 7006
// Say ( JMM , D1-JMM-2 ) ;
6994: LD_EXP 15
6998: PPUSH
6999: LD_STRING D1-JMM-2
7001: PPUSH
7002: CALL_OW 88
// DialogueOff ;
7006: CALL_OW 7
// InGameOff ;
7010: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7014: LD_INT 71
7016: PPUSH
7017: LD_INT 50
7019: PPUSH
7020: LD_INT 7
7022: PPUSH
7023: LD_INT 30
7025: NEG
7026: PPUSH
7027: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7031: LD_INT 71
7033: PPUSH
7034: LD_INT 50
7036: PPUSH
7037: LD_INT 7
7039: PPUSH
7040: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7044: LD_STRING M1
7046: PPUSH
7047: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7051: LD_INT 35
7053: PPUSH
7054: CALL_OW 67
// until freedom ;
7058: LD_EXP 3
7062: IFFALSE 7051
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7064: LD_INT 350
7066: PPUSH
7067: LD_INT 700
7069: PPUSH
7070: CALL_OW 12
7074: PPUSH
7075: CALL_OW 67
// PrepareGossudarov ;
7079: CALL 1802 0 0
// repeat wait ( 0 0$1 ) ;
7083: LD_INT 35
7085: PPUSH
7086: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7090: LD_INT 22
7092: PUSH
7093: LD_INT 6
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 24
7105: PUSH
7106: LD_INT 1000
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PPUSH
7121: CALL_OW 69
7125: PUSH
7126: LD_INT 7
7128: PPUSH
7129: LD_EXP 32
7133: PPUSH
7134: CALL_OW 292
7138: OR
7139: IFFALSE 7083
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7141: LD_ADDR_VAR 0 2
7145: PUSH
7146: LD_INT 22
7148: PUSH
7149: LD_INT 6
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PPUSH
7156: CALL_OW 69
7160: ST_TO_ADDR
// for i in tmp do
7161: LD_ADDR_VAR 0 3
7165: PUSH
7166: LD_VAR 0 2
7170: PUSH
7171: FOR_IN
7172: IFFALSE 7188
// SetSide ( i , 7 ) ;
7174: LD_VAR 0 3
7178: PPUSH
7179: LD_INT 7
7181: PPUSH
7182: CALL_OW 235
7186: GO 7171
7188: POP
7189: POP
// DialogueOn ;
7190: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7194: LD_EXP 15
7198: PUSH
7199: LD_EXP 16
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PPUSH
7208: LD_EXP 32
7212: PPUSH
7213: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7217: LD_EXP 32
7221: PPUSH
7222: CALL_OW 87
// if not Roth then
7226: LD_EXP 16
7230: NOT
7231: IFFALSE 7323
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7233: LD_VAR 0 2
7237: PPUSH
7238: LD_INT 3
7240: PUSH
7241: LD_INT 24
7243: PUSH
7244: LD_INT 1000
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 72
7259: IFFALSE 7273
// Say ( JMM , D2-JMM-1 ) ;
7261: LD_EXP 15
7265: PPUSH
7266: LD_STRING D2-JMM-1
7268: PPUSH
7269: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7273: LD_EXP 15
7277: PPUSH
7278: LD_STRING D2-JMM-1b
7280: PPUSH
7281: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7285: LD_EXP 32
7289: PPUSH
7290: LD_STRING D2-Gos-1
7292: PPUSH
7293: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7297: LD_EXP 15
7301: PPUSH
7302: LD_STRING D2-JMM-2
7304: PPUSH
7305: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7309: LD_EXP 32
7313: PPUSH
7314: LD_STRING D2-Gos-2
7316: PPUSH
7317: CALL_OW 88
// end else
7321: GO 7475
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7323: LD_VAR 0 2
7327: PPUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 72
7349: IFFALSE 7375
// begin Say ( Roth , D2-Roth-2 ) ;
7351: LD_EXP 16
7355: PPUSH
7356: LD_STRING D2-Roth-2
7358: PPUSH
7359: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7363: LD_EXP 15
7367: PPUSH
7368: LD_STRING D2-JMM-1a
7370: PPUSH
7371: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7375: LD_EXP 16
7379: PPUSH
7380: LD_STRING D2-Roth-2a
7382: PPUSH
7383: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7387: LD_EXP 16
7391: PPUSH
7392: LD_STRING D2-Roth-2b
7394: PPUSH
7395: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7399: LD_EXP 15
7403: PPUSH
7404: LD_STRING D2-JMM-3
7406: PPUSH
7407: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7411: LD_VAR 0 2
7415: PPUSH
7416: LD_INT 3
7418: PUSH
7419: LD_INT 24
7421: PUSH
7422: LD_INT 1000
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PPUSH
7433: CALL_OW 72
7437: IFFALSE 7475
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7439: LD_EXP 32
7443: PPUSH
7444: LD_STRING D2-Gos-3
7446: PPUSH
7447: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7451: LD_EXP 15
7455: PPUSH
7456: LD_STRING D2-JMM-4
7458: PPUSH
7459: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7463: LD_EXP 32
7467: PPUSH
7468: LD_STRING D2-Gos-4
7470: PPUSH
7471: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7475: LD_EXP 15
7479: PPUSH
7480: LD_STRING D2-JMM-5
7482: PPUSH
7483: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7487: LD_EXP 32
7491: PPUSH
7492: LD_STRING D2-Gos-5
7494: PPUSH
7495: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7499: LD_EXP 15
7503: PPUSH
7504: LD_STRING D2-JMM-6
7506: PPUSH
7507: CALL_OW 88
// DialogueOff ;
7511: CALL_OW 7
// wait ( 0 0$2 ) ;
7515: LD_INT 70
7517: PPUSH
7518: CALL_OW 67
// if Kirilenkova then
7522: LD_EXP 33
7526: IFFALSE 7540
// Say ( Kirilenkova , D3-Kir-1 ) ;
7528: LD_EXP 33
7532: PPUSH
7533: LD_STRING D3-Kir-1
7535: PPUSH
7536: CALL_OW 88
// gossudarov_arrive := true ;
7540: LD_ADDR_EXP 4
7544: PUSH
7545: LD_INT 1
7547: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7548: LD_INT 35
7550: PPUSH
7551: CALL_OW 67
// until ru_lab_builded ;
7555: LD_EXP 5
7559: IFFALSE 7548
// DialogueOn ;
7561: CALL_OW 6
// if Kirilenkova then
7565: LD_EXP 33
7569: IFFALSE 7585
// Say ( Kirilenkova , D3a-Kir-1 ) else
7571: LD_EXP 33
7575: PPUSH
7576: LD_STRING D3a-Kir-1
7578: PPUSH
7579: CALL_OW 88
7583: GO 7607
// begin un := SciRu ;
7585: LD_ADDR_VAR 0 4
7589: PUSH
7590: CALL 12719 0 0
7594: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7595: LD_VAR 0 4
7599: PPUSH
7600: LD_STRING D3a-Sci1-1
7602: PPUSH
7603: CALL_OW 88
// end ; if Kirilenkova or un then
7607: LD_EXP 33
7611: PUSH
7612: LD_VAR 0 4
7616: OR
7617: IFFALSE 7631
// Say ( JMM , D3a-JMM-1 ) ;
7619: LD_EXP 15
7623: PPUSH
7624: LD_STRING D3a-JMM-1
7626: PPUSH
7627: CALL_OW 88
// DialogueOff ;
7631: CALL_OW 7
// end ;
7635: LD_VAR 0 1
7639: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7640: LD_EXP 4
7644: PUSH
7645: LD_INT 22
7647: PUSH
7648: LD_INT 7
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: PUSH
7655: LD_INT 2
7657: PUSH
7658: LD_INT 25
7660: PUSH
7661: LD_INT 1
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 25
7670: PUSH
7671: LD_INT 2
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 25
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 25
7690: PUSH
7691: LD_INT 4
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: LD_INT 5
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: PUSH
7708: LD_INT 25
7710: PUSH
7711: LD_INT 8
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 25
7720: PUSH
7721: LD_INT 9
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: EMPTY
7739: LIST
7740: LIST
7741: PPUSH
7742: CALL_OW 69
7746: PUSH
7747: LD_INT 7
7749: LESS
7750: AND
7751: IFFALSE 7763
7753: GO 7755
7755: DISABLE
// YouLost ( TooMany ) ;
7756: LD_STRING TooMany
7758: PPUSH
7759: CALL_OW 104
7763: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7764: LD_EXP 32
7768: PPUSH
7769: CALL_OW 255
7773: PUSH
7774: LD_INT 7
7776: EQUAL
7777: IFFALSE 7977
7779: GO 7781
7781: DISABLE
7782: LD_INT 0
7784: PPUSH
7785: PPUSH
7786: PPUSH
// begin uc_side := 3 ;
7787: LD_ADDR_OWVAR 20
7791: PUSH
7792: LD_INT 3
7794: ST_TO_ADDR
// uc_nation := 3 ;
7795: LD_ADDR_OWVAR 21
7799: PUSH
7800: LD_INT 3
7802: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7803: LD_INT 21
7805: PPUSH
7806: LD_INT 3
7808: PPUSH
7809: LD_INT 3
7811: PPUSH
7812: LD_INT 42
7814: PPUSH
7815: LD_INT 100
7817: PPUSH
7818: CALL 21527 0 5
// un := CreateVehicle ;
7822: LD_ADDR_VAR 0 3
7826: PUSH
7827: CALL_OW 45
7831: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7832: LD_VAR 0 3
7836: PPUSH
7837: LD_INT 15
7839: PPUSH
7840: LD_INT 0
7842: PPUSH
7843: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7847: LD_VAR 0 3
7851: PPUSH
7852: LD_INT 67
7854: PPUSH
7855: LD_INT 45
7857: PPUSH
7858: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7862: LD_VAR 0 3
7866: PPUSH
7867: LD_INT 70
7869: PPUSH
7870: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7874: LD_VAR 0 3
7878: PPUSH
7879: LD_INT 69
7881: PPUSH
7882: LD_INT 18
7884: PPUSH
7885: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7889: LD_VAR 0 3
7893: PPUSH
7894: LD_INT 60
7896: PPUSH
7897: LD_INT 2
7899: PPUSH
7900: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7904: LD_INT 35
7906: PPUSH
7907: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7911: LD_VAR 0 3
7915: PPUSH
7916: CALL_OW 302
7920: NOT
7921: PUSH
7922: LD_VAR 0 3
7926: PPUSH
7927: LD_INT 17
7929: PPUSH
7930: CALL_OW 308
7934: OR
7935: IFFALSE 7904
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7937: LD_VAR 0 3
7941: PPUSH
7942: LD_INT 17
7944: PPUSH
7945: CALL_OW 308
7949: PUSH
7950: LD_VAR 0 3
7954: PPUSH
7955: LD_INT 60
7957: PPUSH
7958: LD_INT 2
7960: PPUSH
7961: CALL_OW 307
7965: OR
7966: IFFALSE 7977
// RemoveUnit ( un ) ;
7968: LD_VAR 0 3
7972: PPUSH
7973: CALL_OW 64
// end ;
7977: PPOPN 3
7979: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
7980: LD_EXP 4
7984: IFFALSE 8226
7986: GO 7988
7988: DISABLE
7989: LD_INT 0
7991: PPUSH
7992: PPUSH
7993: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7994: LD_INT 70
7996: PPUSH
7997: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8001: LD_ADDR_VAR 0 3
8005: PUSH
8006: LD_INT 22
8008: PUSH
8009: LD_INT 7
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 101
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: PPUSH
8030: CALL_OW 69
8034: ST_TO_ADDR
// until tmp ;
8035: LD_VAR 0 3
8039: IFFALSE 7994
// un := NearestUnitToUnit ( tmp , JMM ) ;
8041: LD_ADDR_VAR 0 2
8045: PUSH
8046: LD_VAR 0 3
8050: PPUSH
8051: LD_EXP 15
8055: PPUSH
8056: CALL_OW 74
8060: ST_TO_ADDR
// player_spotted := true ;
8061: LD_ADDR_EXP 6
8065: PUSH
8066: LD_INT 1
8068: ST_TO_ADDR
// tmp := SciRu ;
8069: LD_ADDR_VAR 0 3
8073: PUSH
8074: CALL 12719 0 0
8078: ST_TO_ADDR
// if not tmp then
8079: LD_VAR 0 3
8083: NOT
8084: IFFALSE 8096
// tmp := SolRu ;
8086: LD_ADDR_VAR 0 3
8090: PUSH
8091: CALL 12866 0 0
8095: ST_TO_ADDR
// DialogueOn ;
8096: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8100: LD_VAR 0 2
8104: PPUSH
8105: CALL_OW 250
8109: PPUSH
8110: LD_VAR 0 2
8114: PPUSH
8115: CALL_OW 251
8119: PPUSH
8120: LD_INT 7
8122: PPUSH
8123: LD_INT 8
8125: NEG
8126: PPUSH
8127: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8131: LD_VAR 0 2
8135: PPUSH
8136: CALL_OW 87
// if tmp then
8140: LD_VAR 0 3
8144: IFFALSE 8158
// Say ( tmp , D4-RSci1-1 ) ;
8146: LD_VAR 0 3
8150: PPUSH
8151: LD_STRING D4-RSci1-1
8153: PPUSH
8154: CALL_OW 88
// if Gossudarov then
8158: LD_EXP 32
8162: IFFALSE 8188
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8164: LD_EXP 32
8168: PPUSH
8169: LD_STRING D4-Gos-1
8171: PPUSH
8172: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8176: LD_EXP 15
8180: PPUSH
8181: LD_STRING D4-JMM-1
8183: PPUSH
8184: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8188: LD_VAR 0 2
8192: PPUSH
8193: CALL_OW 250
8197: PPUSH
8198: LD_VAR 0 2
8202: PPUSH
8203: CALL_OW 251
8207: PPUSH
8208: LD_INT 7
8210: PPUSH
8211: CALL_OW 331
// DialogueOff ;
8215: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8219: LD_STRING M5
8221: PPUSH
8222: CALL_OW 337
// end ;
8226: PPOPN 3
8228: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8229: LD_EXP 6
8233: IFFALSE 8822
8235: GO 8237
8237: DISABLE
8238: LD_INT 0
8240: PPUSH
8241: PPUSH
8242: PPUSH
// begin PrepareBelkov ;
8243: CALL 2092 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8247: LD_EXP 47
8251: PPUSH
8252: LD_INT 118
8254: PPUSH
8255: LD_INT 106
8257: PPUSH
8258: CALL_OW 111
// AddComHold ( Belkov ) ;
8262: LD_EXP 47
8266: PPUSH
8267: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8271: LD_INT 35
8273: PPUSH
8274: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8278: LD_EXP 47
8282: PPUSH
8283: LD_INT 118
8285: PPUSH
8286: LD_INT 106
8288: PPUSH
8289: CALL_OW 307
8293: IFFALSE 8271
// ChangeSideFog ( 4 , 7 ) ;
8295: LD_INT 4
8297: PPUSH
8298: LD_INT 7
8300: PPUSH
8301: CALL_OW 343
// if IsOk ( Belkov ) then
8305: LD_EXP 47
8309: PPUSH
8310: CALL_OW 302
8314: IFFALSE 8398
// begin InGameOn ;
8316: CALL_OW 8
// DialogueOn ;
8320: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8324: LD_EXP 47
8328: PPUSH
8329: LD_STRING D5-Bel-1
8331: PPUSH
8332: CALL_OW 94
// if Gossudarov then
8336: LD_EXP 32
8340: IFFALSE 8390
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8342: LD_EXP 32
8346: PPUSH
8347: LD_STRING D5-Gos-1
8349: PPUSH
8350: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8354: LD_EXP 15
8358: PPUSH
8359: LD_STRING D5-JMM-1
8361: PPUSH
8362: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8366: LD_EXP 32
8370: PPUSH
8371: LD_STRING D5-Gos-2
8373: PPUSH
8374: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8378: LD_EXP 15
8382: PPUSH
8383: LD_STRING D5-JMM-2
8385: PPUSH
8386: CALL_OW 88
// end ; DialogueOff ;
8390: CALL_OW 7
// InGameOff ;
8394: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8398: LD_STRING QSaveBelkov
8400: PPUSH
8401: CALL_OW 97
8405: PUSH
8406: LD_INT 1
8408: DOUBLE
8409: EQUAL
8410: IFTRUE 8414
8412: GO 8464
8414: POP
// begin DialogueOn ;
8415: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8419: LD_EXP 15
8423: PPUSH
8424: LD_STRING D5a-JMM-1
8426: PPUSH
8427: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8431: LD_EXP 47
8435: PPUSH
8436: LD_STRING D5a-Bel-1
8438: PPUSH
8439: CALL_OW 94
// DialogueOff ;
8443: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8447: LD_EXP 47
8451: PPUSH
8452: LD_INT 83
8454: PPUSH
8455: LD_INT 49
8457: PPUSH
8458: CALL_OW 111
// end ; 2 :
8462: GO 8497
8464: LD_INT 2
8466: DOUBLE
8467: EQUAL
8468: IFTRUE 8472
8470: GO 8496
8472: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8473: LD_EXP 15
8477: PPUSH
8478: LD_STRING D5a-JMM-2
8480: PPUSH
8481: CALL_OW 88
// ComHold ( Belkov ) ;
8485: LD_EXP 47
8489: PPUSH
8490: CALL_OW 140
// end ; end ;
8494: GO 8497
8496: POP
// time := 0 0$00 ;
8497: LD_ADDR_VAR 0 1
8501: PUSH
8502: LD_INT 0
8504: ST_TO_ADDR
// vehSpawned := false ;
8505: LD_ADDR_VAR 0 3
8509: PUSH
8510: LD_INT 0
8512: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8513: LD_INT 35
8515: PPUSH
8516: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8520: LD_VAR 0 1
8524: PUSH
8525: LD_INT 350
8527: PUSH
8528: LD_INT 175
8530: PUSH
8531: LD_INT 70
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: PUSH
8539: LD_OWVAR 67
8543: ARRAY
8544: GREATEREQUAL
8545: PUSH
8546: LD_VAR 0 3
8550: NOT
8551: AND
8552: IFFALSE 8642
// begin vehSpawned := true ;
8554: LD_ADDR_VAR 0 3
8558: PUSH
8559: LD_INT 1
8561: ST_TO_ADDR
// uc_side := 3 ;
8562: LD_ADDR_OWVAR 20
8566: PUSH
8567: LD_INT 3
8569: ST_TO_ADDR
// uc_nation := 3 ;
8570: LD_ADDR_OWVAR 21
8574: PUSH
8575: LD_INT 3
8577: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8578: LD_INT 22
8580: PPUSH
8581: LD_INT 3
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_INT 43
8589: PPUSH
8590: LD_INT 100
8592: PPUSH
8593: CALL 21527 0 5
// veh := CreateVehicle ;
8597: LD_ADDR_VAR 0 2
8601: PUSH
8602: CALL_OW 45
8606: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8607: LD_VAR 0 2
8611: PPUSH
8612: LD_INT 130
8614: PPUSH
8615: LD_INT 131
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8625: LD_VAR 0 2
8629: PPUSH
8630: LD_INT 100
8632: PPUSH
8633: LD_INT 82
8635: PPUSH
8636: CALL_OW 114
// end else
8640: GO 8656
// time := time + 0 0$1 ;
8642: LD_ADDR_VAR 0 1
8646: PUSH
8647: LD_VAR 0 1
8651: PUSH
8652: LD_INT 35
8654: PLUS
8655: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8656: LD_EXP 47
8660: PPUSH
8661: CALL_OW 301
8665: PUSH
8666: LD_EXP 47
8670: PPUSH
8671: CALL_OW 255
8675: PUSH
8676: LD_INT 4
8678: EQUAL
8679: AND
8680: PUSH
8681: LD_INT 22
8683: PUSH
8684: LD_INT 7
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PPUSH
8691: CALL_OW 69
8695: PPUSH
8696: LD_EXP 47
8700: PPUSH
8701: CALL_OW 74
8705: PPUSH
8706: LD_EXP 47
8710: PPUSH
8711: CALL_OW 296
8715: PUSH
8716: LD_INT 10
8718: LESS
8719: OR
8720: IFFALSE 8513
// if IsDead ( Belkov ) then
8722: LD_EXP 47
8726: PPUSH
8727: CALL_OW 301
8731: IFFALSE 8756
// begin CenterNowOnUnits ( Belkov ) ;
8733: LD_EXP 47
8737: PPUSH
8738: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8742: LD_EXP 15
8746: PPUSH
8747: LD_STRING D5a-JMM-2a
8749: PPUSH
8750: CALL_OW 88
// exit ;
8754: GO 8822
// end ; if See ( 7 , Belkov ) then
8756: LD_INT 7
8758: PPUSH
8759: LD_EXP 47
8763: PPUSH
8764: CALL_OW 292
8768: IFFALSE 8782
// SetSide ( Belkov , 7 ) ;
8770: LD_EXP 47
8774: PPUSH
8775: LD_INT 7
8777: PPUSH
8778: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8782: LD_INT 35
8784: PPUSH
8785: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8789: LD_EXP 47
8793: PPUSH
8794: LD_INT 66
8796: PPUSH
8797: LD_INT 45
8799: PPUSH
8800: CALL_OW 297
8804: PUSH
8805: LD_INT 30
8807: LESS
8808: IFFALSE 8782
// Say ( Belkov , D6-Bel-1 ) ;
8810: LD_EXP 47
8814: PPUSH
8815: LD_STRING D6-Bel-1
8817: PPUSH
8818: CALL_OW 88
// end ;
8822: PPOPN 3
8824: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8825: LD_EXP 47
8829: PPUSH
8830: CALL_OW 302
8834: PUSH
8835: LD_EXP 47
8839: PPUSH
8840: CALL_OW 504
8844: PUSH
8845: LD_INT 2
8847: PUSH
8848: LD_INT 34
8850: PUSH
8851: LD_INT 47
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 34
8860: PUSH
8861: LD_INT 45
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: LIST
8872: PPUSH
8873: CALL_OW 69
8877: IN
8878: AND
8879: IFFALSE 8896
8881: GO 8883
8883: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8884: LD_EXP 47
8888: PPUSH
8889: LD_STRING D7-Bel-1
8891: PPUSH
8892: CALL_OW 88
8896: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8897: LD_INT 22
8899: PUSH
8900: LD_INT 7
8902: PUSH
8903: EMPTY
8904: LIST
8905: LIST
8906: PUSH
8907: LD_INT 101
8909: PUSH
8910: LD_INT 2
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: PUSH
8917: EMPTY
8918: LIST
8919: LIST
8920: PPUSH
8921: CALL_OW 69
8925: PUSH
8926: LD_EXP 8
8930: NOT
8931: AND
8932: PUSH
8933: LD_EXP 46
8937: PPUSH
8938: CALL_OW 305
8942: NOT
8943: AND
8944: IFFALSE 9414
8946: GO 8948
8948: DISABLE
8949: LD_INT 0
8951: PPUSH
// begin ar_base_spotted := true ;
8952: LD_ADDR_EXP 8
8956: PUSH
8957: LD_INT 1
8959: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8960: LD_ADDR_VAR 0 1
8964: PUSH
8965: LD_INT 22
8967: PUSH
8968: LD_INT 2
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PUSH
8975: LD_INT 21
8977: PUSH
8978: LD_INT 3
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PPUSH
8989: CALL_OW 69
8993: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8994: LD_ADDR_VAR 0 1
8998: PUSH
8999: LD_VAR 0 1
9003: PPUSH
9004: LD_EXP 15
9008: PPUSH
9009: CALL_OW 74
9013: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9014: LD_INT 7
9016: PPUSH
9017: LD_INT 3
9019: PPUSH
9020: CALL_OW 332
// DialogueOn ;
9024: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9028: LD_VAR 0 1
9032: PPUSH
9033: CALL_OW 250
9037: PPUSH
9038: LD_VAR 0 1
9042: PPUSH
9043: CALL_OW 251
9047: PPUSH
9048: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9052: LD_ADDR_VAR 0 1
9056: PUSH
9057: LD_INT 22
9059: PUSH
9060: LD_INT 7
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: PUSH
9067: LD_INT 23
9069: PUSH
9070: LD_INT 1
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: PUSH
9077: LD_INT 26
9079: PUSH
9080: LD_INT 1
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: LIST
9091: PPUSH
9092: CALL_OW 69
9096: PUSH
9097: LD_EXP 15
9101: PUSH
9102: LD_EXP 19
9106: PUSH
9107: LD_EXP 20
9111: PUSH
9112: LD_EXP 27
9116: PUSH
9117: LD_EXP 16
9121: PUSH
9122: LD_EXP 25
9126: PUSH
9127: LD_EXP 21
9131: PUSH
9132: LD_EXP 23
9136: PUSH
9137: EMPTY
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: DIFF
9147: ST_TO_ADDR
// if not tmp then
9148: LD_VAR 0 1
9152: NOT
9153: IFFALSE 9227
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9155: LD_ADDR_VAR 0 1
9159: PUSH
9160: LD_INT 22
9162: PUSH
9163: LD_INT 7
9165: PUSH
9166: EMPTY
9167: LIST
9168: LIST
9169: PUSH
9170: LD_INT 23
9172: PUSH
9173: LD_INT 1
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 26
9182: PUSH
9183: LD_INT 2
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PUSH
9200: LD_EXP 30
9204: PUSH
9205: LD_EXP 17
9209: PUSH
9210: LD_EXP 28
9214: PUSH
9215: LD_EXP 29
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: DIFF
9226: ST_TO_ADDR
// if tmp then
9227: LD_VAR 0 1
9231: IFFALSE 9302
// case GetSex ( tmp [ 1 ] ) of sex_male :
9233: LD_VAR 0 1
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 258
9246: PUSH
9247: LD_INT 1
9249: DOUBLE
9250: EQUAL
9251: IFTRUE 9255
9253: GO 9274
9255: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9256: LD_VAR 0 1
9260: PUSH
9261: LD_INT 1
9263: ARRAY
9264: PPUSH
9265: LD_STRING D9-Sol1-1
9267: PPUSH
9268: CALL_OW 88
9272: GO 9302
9274: LD_INT 2
9276: DOUBLE
9277: EQUAL
9278: IFTRUE 9282
9280: GO 9301
9282: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9283: LD_VAR 0 1
9287: PUSH
9288: LD_INT 1
9290: ARRAY
9291: PPUSH
9292: LD_STRING D9-FSol1-1
9294: PPUSH
9295: CALL_OW 88
9299: GO 9302
9301: POP
// if Frank then
9302: LD_EXP 27
9306: IFFALSE 9410
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9308: LD_EXP 56
9312: PPUSH
9313: CALL_OW 250
9317: PPUSH
9318: LD_EXP 56
9322: PPUSH
9323: CALL_OW 251
9327: PPUSH
9328: LD_INT 7
9330: PPUSH
9331: LD_INT 8
9333: PPUSH
9334: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9338: LD_EXP 56
9342: PPUSH
9343: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9347: LD_EXP 27
9351: PPUSH
9352: LD_STRING D9-Frank-1
9354: PPUSH
9355: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9359: LD_EXP 15
9363: PPUSH
9364: LD_STRING D9-JMM-1
9366: PPUSH
9367: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9371: LD_EXP 27
9375: PPUSH
9376: LD_STRING D9-Frank-2
9378: PPUSH
9379: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9383: LD_EXP 56
9387: PPUSH
9388: CALL_OW 250
9392: PPUSH
9393: LD_EXP 56
9397: PPUSH
9398: CALL_OW 251
9402: PPUSH
9403: LD_INT 7
9405: PPUSH
9406: CALL_OW 331
// end ; DialogueOff ;
9410: CALL_OW 7
// end ;
9414: PPOPN 1
9416: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9417: LD_EXP 7
9421: PUSH
9422: LD_OWVAR 1
9426: PUSH
9427: LD_INT 42000
9429: GREATEREQUAL
9430: OR
9431: IFFALSE 10458
9433: GO 9435
9435: DISABLE
9436: LD_INT 0
9438: PPUSH
9439: PPUSH
// begin selected_option := 1 ;
9440: LD_ADDR_VAR 0 2
9444: PUSH
9445: LD_INT 1
9447: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9448: LD_INT 10500
9450: PPUSH
9451: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9455: LD_INT 35
9457: PPUSH
9458: CALL_OW 67
// until not ru_attackers ;
9462: LD_EXP 52
9466: NOT
9467: IFFALSE 9455
// PrepareBurlak ;
9469: CALL 2204 0 0
// repeat wait ( 0 0$2 ) ;
9473: LD_INT 70
9475: PPUSH
9476: CALL_OW 67
// until not HasTask ( Burlak ) ;
9480: LD_EXP 46
9484: PPUSH
9485: CALL_OW 314
9489: NOT
9490: IFFALSE 9473
// InGameOn ;
9492: CALL_OW 8
// DialogueOn ;
9496: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9500: LD_EXP 49
9504: PPUSH
9505: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9509: LD_EXP 46
9513: PPUSH
9514: LD_STRING D10-Bur-1
9516: PPUSH
9517: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9521: LD_EXP 47
9525: PUSH
9526: LD_EXP 47
9530: PPUSH
9531: CALL_OW 255
9535: PUSH
9536: LD_INT 7
9538: EQUAL
9539: AND
9540: IFFALSE 9554
// Say ( Belkov , D10-Bel-1 ) ;
9542: LD_EXP 47
9546: PPUSH
9547: LD_STRING D10-Bel-1
9549: PPUSH
9550: CALL_OW 88
// if Gossudarov then
9554: LD_EXP 32
9558: IFFALSE 9572
// Say ( Gossudarov , D10-Gos-1 ) ;
9560: LD_EXP 32
9564: PPUSH
9565: LD_STRING D10-Gos-1
9567: PPUSH
9568: CALL_OW 88
// if Kirilenkova then
9572: LD_EXP 33
9576: IFFALSE 9590
// Say ( Kirilenkova , D10-Kir-1 ) ;
9578: LD_EXP 33
9582: PPUSH
9583: LD_STRING D10-Kir-1
9585: PPUSH
9586: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9590: CALL 12866 0 0
9594: PPUSH
9595: LD_STRING D10-RSol1-1
9597: PPUSH
9598: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9602: LD_EXP 46
9606: PPUSH
9607: LD_STRING D10-Bur-2
9609: PPUSH
9610: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9614: LD_EXP 15
9618: PPUSH
9619: LD_STRING D10-JMM-2
9621: PPUSH
9622: CALL_OW 88
// if Kirilenkova then
9626: LD_EXP 33
9630: IFFALSE 9646
// Say ( Kirilenkova , D10-Kir-2 ) else
9632: LD_EXP 33
9636: PPUSH
9637: LD_STRING D10-Kir-2
9639: PPUSH
9640: CALL_OW 88
9644: GO 9658
// Say ( SolRu , D10-RSol1-2 ) ;
9646: CALL 12866 0 0
9650: PPUSH
9651: LD_STRING D10-RSol1-2
9653: PPUSH
9654: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9658: LD_EXP 15
9662: PPUSH
9663: LD_STRING D10-JMM-3
9665: PPUSH
9666: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9670: LD_EXP 46
9674: PPUSH
9675: LD_STRING D10-Bur-3
9677: PPUSH
9678: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9682: LD_EXP 15
9686: PPUSH
9687: LD_STRING D10-JMM-4
9689: PPUSH
9690: CALL_OW 88
// DialogueOff ;
9694: CALL_OW 7
// InGameOff ;
9698: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9702: LD_STRING M2
9704: PPUSH
9705: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9709: LD_INT 35
9711: PPUSH
9712: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9716: LD_INT 22
9718: PUSH
9719: LD_INT 7
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: PUSH
9726: LD_INT 91
9728: PUSH
9729: LD_EXP 46
9733: PUSH
9734: LD_INT 8
9736: PUSH
9737: EMPTY
9738: LIST
9739: LIST
9740: LIST
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: PPUSH
9746: CALL_OW 69
9750: IFFALSE 9709
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9752: LD_ADDR_VAR 0 1
9756: PUSH
9757: LD_INT 22
9759: PUSH
9760: LD_INT 4
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PPUSH
9767: CALL_OW 69
9771: PUSH
9772: FOR_IN
9773: IFFALSE 9789
// SetSide ( i , 7 ) ;
9775: LD_VAR 0 1
9779: PPUSH
9780: LD_INT 7
9782: PPUSH
9783: CALL_OW 235
9787: GO 9772
9789: POP
9790: POP
// ChangeMissionObjectives ( M3 ) ;
9791: LD_STRING M3
9793: PPUSH
9794: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9798: LD_INT 35
9800: PPUSH
9801: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9805: LD_EXP 15
9809: PPUSH
9810: LD_EXP 46
9814: PPUSH
9815: CALL_OW 296
9819: PUSH
9820: LD_INT 8
9822: LESS
9823: IFFALSE 9798
// ComTurnUnit ( JMM , Burlak ) ;
9825: LD_EXP 15
9829: PPUSH
9830: LD_EXP 46
9834: PPUSH
9835: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9839: LD_EXP 46
9843: PPUSH
9844: LD_EXP 15
9848: PPUSH
9849: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9853: LD_INT 10
9855: PPUSH
9856: CALL_OW 67
// DialogueOn ;
9860: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9864: LD_EXP 15
9868: PPUSH
9869: LD_STRING D11-JMM-1
9871: PPUSH
9872: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9876: LD_EXP 46
9880: PPUSH
9881: LD_STRING D11-Bur-1
9883: PPUSH
9884: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9888: LD_EXP 15
9892: PPUSH
9893: LD_STRING D11-JMM-2
9895: PPUSH
9896: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9900: LD_EXP 46
9904: PPUSH
9905: LD_STRING D11-Bur-2
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9912: LD_EXP 15
9916: PPUSH
9917: LD_STRING D11-JMM-3
9919: PPUSH
9920: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9924: LD_EXP 46
9928: PPUSH
9929: LD_STRING D11-Bur-3
9931: PPUSH
9932: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9936: LD_EXP 15
9940: PPUSH
9941: LD_STRING D11-JMM-4
9943: PPUSH
9944: CALL_OW 88
// if ar_base_spotted then
9948: LD_EXP 8
9952: IFFALSE 9968
// Say ( Burlak , D12-Bur-1 ) else
9954: LD_EXP 46
9958: PPUSH
9959: LD_STRING D12-Bur-1
9961: PPUSH
9962: CALL_OW 88
9966: GO 10007
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9968: LD_INT 7
9970: PPUSH
9971: LD_INT 3
9973: PPUSH
9974: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9978: LD_INT 127
9980: PPUSH
9981: LD_INT 45
9983: PPUSH
9984: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9988: LD_EXP 46
9992: PPUSH
9993: LD_STRING D12-Bur-1a
9995: PPUSH
9996: CALL_OW 88
// dwait ( 0 0$2 ) ;
10000: LD_INT 70
10002: PPUSH
10003: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10007: LD_EXP 46
10011: PPUSH
10012: LD_STRING D12-Bur-1b
10014: PPUSH
10015: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10019: LD_EXP 15
10023: PPUSH
10024: LD_STRING D12-JMM-1
10026: PPUSH
10027: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10031: LD_EXP 46
10035: PPUSH
10036: LD_STRING D12-Bur-2
10038: PPUSH
10039: CALL_OW 88
// if Roth then
10043: LD_EXP 16
10047: IFFALSE 10063
// Say ( Roth , D12-Roth-2 ) else
10049: LD_EXP 16
10053: PPUSH
10054: LD_STRING D12-Roth-2
10056: PPUSH
10057: CALL_OW 88
10061: GO 10075
// Say ( SciRu , D12-RSci1-2 ) ;
10063: CALL 12719 0 0
10067: PPUSH
10068: LD_STRING D12-RSci1-2
10070: PPUSH
10071: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10075: LD_EXP 15
10079: PPUSH
10080: LD_STRING D12-JMM-2
10082: PPUSH
10083: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10087: LD_EXP 46
10091: PPUSH
10092: LD_STRING D12-Bur-3
10094: PPUSH
10095: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10099: LD_EXP 15
10103: PPUSH
10104: LD_STRING D12-JMM-3
10106: PPUSH
10107: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10111: LD_EXP 46
10115: PPUSH
10116: LD_STRING D12-Bur-4
10118: PPUSH
10119: CALL_OW 88
// case Query ( QBase ) of 1 :
10123: LD_STRING QBase
10125: PPUSH
10126: CALL_OW 97
10130: PUSH
10131: LD_INT 1
10133: DOUBLE
10134: EQUAL
10135: IFTRUE 10139
10137: GO 10257
10139: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10140: LD_EXP 15
10144: PPUSH
10145: LD_STRING D13a-JMM-1
10147: PPUSH
10148: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10152: LD_EXP 46
10156: PPUSH
10157: LD_STRING D13a-Bur-1
10159: PPUSH
10160: CALL_OW 88
// if Roth then
10164: LD_EXP 16
10168: IFFALSE 10184
// Say ( Roth , D13a-Roth-1 ) else
10170: LD_EXP 16
10174: PPUSH
10175: LD_STRING D13a-Roth-1
10177: PPUSH
10178: CALL_OW 88
10182: GO 10196
// Say ( SciRu , D13a-RSci1-1 ) ;
10184: CALL 12719 0 0
10188: PPUSH
10189: LD_STRING D13a-RSci1-1
10191: PPUSH
10192: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10196: LD_EXP 15
10200: PPUSH
10201: LD_STRING D13a-JMM-2
10203: PPUSH
10204: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10208: LD_STRING QBaseAgain
10210: PPUSH
10211: CALL_OW 97
10215: PUSH
10216: LD_INT 1
10218: DOUBLE
10219: EQUAL
10220: IFTRUE 10224
10222: GO 10235
10224: POP
// selected_option := 2 ; 2 :
10225: LD_ADDR_VAR 0 2
10229: PUSH
10230: LD_INT 2
10232: ST_TO_ADDR
10233: GO 10255
10235: LD_INT 2
10237: DOUBLE
10238: EQUAL
10239: IFTRUE 10243
10241: GO 10254
10243: POP
// selected_option := 3 ; end ;
10244: LD_ADDR_VAR 0 2
10248: PUSH
10249: LD_INT 3
10251: ST_TO_ADDR
10252: GO 10255
10254: POP
// end ; 2 :
10255: GO 10296
10257: LD_INT 2
10259: DOUBLE
10260: EQUAL
10261: IFTRUE 10265
10263: GO 10276
10265: POP
// selected_option := 2 ; 3 :
10266: LD_ADDR_VAR 0 2
10270: PUSH
10271: LD_INT 2
10273: ST_TO_ADDR
10274: GO 10296
10276: LD_INT 3
10278: DOUBLE
10279: EQUAL
10280: IFTRUE 10284
10282: GO 10295
10284: POP
// selected_option := 3 ; end ;
10285: LD_ADDR_VAR 0 2
10289: PUSH
10290: LD_INT 3
10292: ST_TO_ADDR
10293: GO 10296
10295: POP
// if selected_option = 2 then
10296: LD_VAR 0 2
10300: PUSH
10301: LD_INT 2
10303: EQUAL
10304: IFFALSE 10398
// begin Say ( JMM , D13b-JMM-1 ) ;
10306: LD_EXP 15
10310: PPUSH
10311: LD_STRING D13b-JMM-1
10313: PPUSH
10314: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10318: LD_EXP 46
10322: PPUSH
10323: LD_STRING D13b-Bur-1
10325: PPUSH
10326: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10330: LD_EXP 15
10334: PPUSH
10335: LD_STRING D13b-JMM-2
10337: PPUSH
10338: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10342: LD_EXP 55
10346: PPUSH
10347: LD_STRING D13b-Abd-2
10349: PPUSH
10350: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10354: LD_EXP 15
10358: PPUSH
10359: LD_STRING D13b-JMM-3
10361: PPUSH
10362: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10366: LD_EXP 55
10370: PPUSH
10371: LD_STRING D13b-Abd-3
10373: PPUSH
10374: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10378: LD_EXP 15
10382: PPUSH
10383: LD_STRING D13b-JMM-4
10385: PPUSH
10386: CALL_OW 88
// ar_active_attack := true ;
10390: LD_ADDR_EXP 9
10394: PUSH
10395: LD_INT 1
10397: ST_TO_ADDR
// end ; if selected_option = 3 then
10398: LD_VAR 0 2
10402: PUSH
10403: LD_INT 3
10405: EQUAL
10406: IFFALSE 10432
// begin Say ( JMM , D13c-JMM-1 ) ;
10408: LD_EXP 15
10412: PPUSH
10413: LD_STRING D13c-JMM-1
10415: PPUSH
10416: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10420: LD_EXP 46
10424: PPUSH
10425: LD_STRING D13c-Bur-1
10427: PPUSH
10428: CALL_OW 88
// end ; DialogueOff ;
10432: CALL_OW 7
// if not ar_active_attack then
10436: LD_EXP 9
10440: NOT
10441: IFFALSE 10458
// begin wait ( 6 6$00 ) ;
10443: LD_INT 12600
10445: PPUSH
10446: CALL_OW 67
// ar_active_attack := true ;
10450: LD_ADDR_EXP 9
10454: PUSH
10455: LD_INT 1
10457: ST_TO_ADDR
// end ; end ;
10458: PPOPN 2
10460: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10461: LD_EXP 46
10465: PPUSH
10466: CALL_OW 305
10470: PUSH
10471: LD_EXP 46
10475: PPUSH
10476: CALL_OW 255
10480: PUSH
10481: LD_INT 7
10483: EQUAL
10484: AND
10485: IFFALSE 10681
10487: GO 10489
10489: DISABLE
10490: LD_INT 0
10492: PPUSH
// begin wait ( 4 4$40 ) ;
10493: LD_INT 9800
10495: PPUSH
10496: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10500: LD_INT 35
10502: PPUSH
10503: CALL_OW 67
// until not ru_attackers ;
10507: LD_EXP 52
10511: NOT
10512: IFFALSE 10500
// PrepareGnyevko ;
10514: CALL 2148 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10518: LD_EXP 48
10522: PPUSH
10523: LD_INT 124
10525: PPUSH
10526: LD_INT 118
10528: PPUSH
10529: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10533: LD_EXP 48
10537: PPUSH
10538: CALL_OW 200
// time := 0 0$00 ;
10542: LD_ADDR_VAR 0 1
10546: PUSH
10547: LD_INT 0
10549: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10550: LD_INT 35
10552: PPUSH
10553: CALL_OW 67
// time := time + 0 0$1 ;
10557: LD_ADDR_VAR 0 1
10561: PUSH
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 35
10569: PLUS
10570: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10571: LD_EXP 48
10575: PPUSH
10576: LD_INT 124
10578: PPUSH
10579: LD_INT 118
10581: PPUSH
10582: CALL_OW 307
10586: PUSH
10587: LD_VAR 0 1
10591: PUSH
10592: LD_INT 1050
10594: GREATEREQUAL
10595: OR
10596: IFFALSE 10550
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10598: LD_EXP 48
10602: PPUSH
10603: LD_STRING DBelkov-Gny-1
10605: PPUSH
10606: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10610: LD_EXP 46
10614: PPUSH
10615: LD_STRING DBelkov-Bur-1a
10617: PPUSH
10618: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10622: LD_INT 35
10624: PPUSH
10625: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10629: LD_EXP 48
10633: PPUSH
10634: LD_INT 22
10636: PUSH
10637: LD_INT 7
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PPUSH
10644: CALL_OW 69
10648: PPUSH
10649: LD_EXP 48
10653: PPUSH
10654: CALL_OW 74
10658: PPUSH
10659: CALL_OW 296
10663: PUSH
10664: LD_INT 8
10666: LESS
10667: IFFALSE 10622
// SetSide ( Gnyevko , 7 ) ;
10669: LD_EXP 48
10673: PPUSH
10674: LD_INT 7
10676: PPUSH
10677: CALL_OW 235
// end ;
10681: PPOPN 1
10683: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10684: LD_EXP 46
10688: PPUSH
10689: CALL_OW 255
10693: PUSH
10694: LD_INT 7
10696: EQUAL
10697: IFFALSE 10707
10699: GO 10701
10701: DISABLE
// begin enable ;
10702: ENABLE
// PrepareAmericanAttack ;
10703: CALL 6523 0 0
// end ;
10707: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10708: LD_INT 22
10710: PUSH
10711: LD_INT 1
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PPUSH
10718: CALL_OW 69
10722: IFFALSE 10906
10724: GO 10726
10726: DISABLE
10727: LD_INT 0
10729: PPUSH
10730: PPUSH
// begin while true do
10731: LD_INT 1
10733: IFFALSE 10790
// begin wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10742: LD_ADDR_VAR 0 2
10746: PUSH
10747: LD_INT 22
10749: PUSH
10750: LD_INT 1
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PPUSH
10757: CALL_OW 69
10761: PPUSH
10762: LD_EXP 15
10766: PPUSH
10767: CALL_OW 74
10771: ST_TO_ADDR
// if See ( 7 , tmp ) then
10772: LD_INT 7
10774: PPUSH
10775: LD_VAR 0 2
10779: PPUSH
10780: CALL_OW 292
10784: IFFALSE 10788
// break ;
10786: GO 10790
// end ;
10788: GO 10731
// DialogueOn ;
10790: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10794: LD_VAR 0 2
10798: PPUSH
10799: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10803: LD_VAR 0 2
10807: PPUSH
10808: CALL_OW 250
10812: PPUSH
10813: LD_VAR 0 2
10817: PPUSH
10818: CALL_OW 251
10822: PPUSH
10823: LD_INT 7
10825: PPUSH
10826: LD_INT 8
10828: PPUSH
10829: CALL_OW 330
// if Denis then
10833: LD_EXP 21
10837: IFFALSE 10851
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10839: LD_EXP 21
10843: PPUSH
10844: LD_STRING DAmerAttack-Pet-1
10846: PPUSH
10847: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10851: LD_EXP 15
10855: PPUSH
10856: LD_STRING DAmerAttack-JMM-1
10858: PPUSH
10859: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10863: LD_EXP 46
10867: PPUSH
10868: LD_STRING DStop-Bur-1
10870: PPUSH
10871: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10875: LD_VAR 0 2
10879: PPUSH
10880: CALL_OW 250
10884: PPUSH
10885: LD_VAR 0 2
10889: PPUSH
10890: CALL_OW 251
10894: PPUSH
10895: LD_INT 7
10897: PPUSH
10898: CALL_OW 331
// DialogueOff ;
10902: CALL_OW 7
// end ;
10906: PPOPN 2
10908: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10909: LD_INT 22
10911: PUSH
10912: LD_INT 3
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 21
10921: PUSH
10922: LD_INT 1
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PPUSH
10933: CALL_OW 69
10937: PUSH
10938: LD_INT 0
10940: EQUAL
10941: IFFALSE 10983
10943: GO 10945
10945: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10946: LD_STRING M5a
10948: PPUSH
10949: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10953: LD_EXP 15
10957: PPUSH
10958: LD_STRING D8-JMM-1
10960: PPUSH
10961: CALL_OW 88
// if Gossudarov then
10965: LD_EXP 32
10969: IFFALSE 10983
// Say ( Gossudarov , D8-Gos-1 ) ;
10971: LD_EXP 32
10975: PPUSH
10976: LD_STRING D8-Gos-1
10978: PPUSH
10979: CALL_OW 88
// end ;
10983: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10984: LD_INT 22
10986: PUSH
10987: LD_INT 2
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 21
10996: PUSH
10997: LD_INT 1
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PPUSH
11008: CALL_OW 69
11012: PUSH
11013: LD_INT 0
11015: EQUAL
11016: IFFALSE 11066
11018: GO 11020
11020: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11021: LD_STRING M4c
11023: PPUSH
11024: CALL_OW 337
// if Roth then
11028: LD_EXP 16
11032: IFFALSE 11048
// Say ( Roth , DStop-Roth-1 ) else
11034: LD_EXP 16
11038: PPUSH
11039: LD_STRING DStop-Roth-1
11041: PPUSH
11042: CALL_OW 88
11046: GO 11066
// if Gossudarov then
11048: LD_EXP 32
11052: IFFALSE 11066
// Say ( Gossudarov , D8-Gos-1a ) ;
11054: LD_EXP 32
11058: PPUSH
11059: LD_STRING D8-Gos-1a
11061: PPUSH
11062: CALL_OW 88
// end ;
11066: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11067: LD_INT 7
11069: PPUSH
11070: LD_INT 1
11072: PPUSH
11073: LD_INT 1
11075: PPUSH
11076: CALL 14355 0 3
11080: PUSH
11081: LD_INT 0
11083: EQUAL
11084: PUSH
11085: LD_INT 7
11087: PPUSH
11088: LD_INT 3
11090: PPUSH
11091: LD_INT 1
11093: PPUSH
11094: CALL 14355 0 3
11098: PUSH
11099: LD_INT 0
11101: EQUAL
11102: AND
11103: IFFALSE 11115
11105: GO 11107
11107: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11108: LD_STRING M1a
11110: PPUSH
11111: CALL_OW 337
// end ;
11115: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11116: LD_INT 22
11118: PUSH
11119: LD_INT 2
11121: PUSH
11122: EMPTY
11123: LIST
11124: LIST
11125: PUSH
11126: LD_INT 21
11128: PUSH
11129: LD_INT 1
11131: PUSH
11132: EMPTY
11133: LIST
11134: LIST
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PPUSH
11140: CALL_OW 69
11144: PUSH
11145: LD_INT 0
11147: EQUAL
11148: PUSH
11149: LD_INT 22
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: PUSH
11159: LD_INT 21
11161: PUSH
11162: LD_INT 1
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: PPUSH
11173: CALL_OW 69
11177: PUSH
11178: LD_INT 0
11180: EQUAL
11181: AND
11182: PUSH
11183: LD_INT 22
11185: PUSH
11186: LD_INT 1
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PPUSH
11193: CALL_OW 69
11197: PUSH
11198: LD_INT 0
11200: EQUAL
11201: AND
11202: PUSH
11203: LD_INT 7
11205: PPUSH
11206: LD_INT 1
11208: PPUSH
11209: LD_INT 1
11211: PPUSH
11212: CALL 14355 0 3
11216: PUSH
11217: LD_INT 0
11219: EQUAL
11220: AND
11221: PUSH
11222: LD_INT 7
11224: PPUSH
11225: LD_INT 3
11227: PPUSH
11228: LD_INT 1
11230: PPUSH
11231: CALL 14355 0 3
11235: PUSH
11236: LD_INT 0
11238: EQUAL
11239: AND
11240: IFFALSE 12716
11242: GO 11244
11244: DISABLE
11245: LD_INT 0
11247: PPUSH
11248: PPUSH
11249: PPUSH
11250: PPUSH
11251: PPUSH
11252: PPUSH
// begin m1 := false ;
11253: LD_ADDR_VAR 0 4
11257: PUSH
11258: LD_INT 0
11260: ST_TO_ADDR
// m2 := false ;
11261: LD_ADDR_VAR 0 5
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// m3 := false ;
11269: LD_ADDR_VAR 0 6
11273: PUSH
11274: LD_INT 0
11276: ST_TO_ADDR
// if tick < 40 40$00 then
11277: LD_OWVAR 1
11281: PUSH
11282: LD_INT 84000
11284: LESS
11285: IFFALSE 11294
// SetAchievement ( ACH_ASPEED_17 ) ;
11287: LD_STRING ACH_ASPEED_17
11289: PPUSH
11290: CALL_OW 543
// wait ( 0 0$1 ) ;
11294: LD_INT 35
11296: PPUSH
11297: CALL_OW 67
// if not IsDead ( Masha ) then
11301: LD_EXP 49
11305: PPUSH
11306: CALL_OW 301
11310: NOT
11311: IFFALSE 11333
// begin m1 := true ;
11313: LD_ADDR_VAR 0 4
11317: PUSH
11318: LD_INT 1
11320: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11321: LD_STRING Masha
11323: PPUSH
11324: LD_INT 1
11326: PPUSH
11327: CALL_OW 101
// end else
11331: GO 11344
// AddMedal ( Masha , - 1 ) ;
11333: LD_STRING Masha
11335: PPUSH
11336: LD_INT 1
11338: NEG
11339: PPUSH
11340: CALL_OW 101
// if abdul_escaped then
11344: LD_EXP 12
11348: IFFALSE 11363
// AddMedal ( Abdul , - 1 ) else
11350: LD_STRING Abdul
11352: PPUSH
11353: LD_INT 1
11355: NEG
11356: PPUSH
11357: CALL_OW 101
11361: GO 11381
// begin m2 := true ;
11363: LD_ADDR_VAR 0 5
11367: PUSH
11368: LD_INT 1
11370: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11371: LD_STRING Abdul
11373: PPUSH
11374: LD_INT 1
11376: PPUSH
11377: CALL_OW 101
// end ; if loss_counter = 0 then
11381: LD_EXP 13
11385: PUSH
11386: LD_INT 0
11388: EQUAL
11389: IFFALSE 11411
// begin m3 := true ;
11391: LD_ADDR_VAR 0 6
11395: PUSH
11396: LD_INT 1
11398: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11399: LD_STRING People
11401: PPUSH
11402: LD_INT 2
11404: PPUSH
11405: CALL_OW 101
// end else
11409: GO 11469
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11411: LD_EXP 13
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: LD_INT 2
11421: PUSH
11422: LD_INT 2
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: LIST
11429: PUSH
11430: LD_OWVAR 67
11434: ARRAY
11435: LESSEQUAL
11436: IFFALSE 11458
// begin AddMedal ( People , 1 ) ;
11438: LD_STRING People
11440: PPUSH
11441: LD_INT 1
11443: PPUSH
11444: CALL_OW 101
// m3 := true ;
11448: LD_ADDR_VAR 0 6
11452: PUSH
11453: LD_INT 1
11455: ST_TO_ADDR
// end else
11456: GO 11469
// AddMedal ( People , - 1 ) ;
11458: LD_STRING People
11460: PPUSH
11461: LD_INT 1
11463: NEG
11464: PPUSH
11465: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11469: LD_OWVAR 67
11473: PUSH
11474: LD_INT 3
11476: EQUAL
11477: PUSH
11478: LD_VAR 0 4
11482: AND
11483: PUSH
11484: LD_VAR 0 5
11488: AND
11489: PUSH
11490: LD_VAR 0 6
11494: AND
11495: IFFALSE 11507
// SetAchievementEX ( ACH_AMER , 17 ) ;
11497: LD_STRING ACH_AMER
11499: PPUSH
11500: LD_INT 17
11502: PPUSH
11503: CALL_OW 564
// GiveMedals ( MAIN ) ;
11507: LD_STRING MAIN
11509: PPUSH
11510: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11514: LD_ADDR_VAR 0 2
11518: PUSH
11519: LD_INT 22
11521: PUSH
11522: LD_INT 7
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: PUSH
11529: LD_INT 2
11531: PUSH
11532: LD_INT 25
11534: PUSH
11535: LD_INT 1
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 2
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 25
11554: PUSH
11555: LD_INT 3
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 25
11564: PUSH
11565: LD_INT 4
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: LD_INT 25
11574: PUSH
11575: LD_INT 5
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PUSH
11582: LD_INT 25
11584: PUSH
11585: LD_INT 8
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 25
11594: PUSH
11595: LD_INT 9
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11621: LD_VAR 0 2
11625: PPUSH
11626: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11630: LD_ADDR_VAR 0 3
11634: PUSH
11635: LD_EXP 15
11639: PUSH
11640: LD_EXP 16
11644: PUSH
11645: LD_EXP 17
11649: PUSH
11650: LD_EXP 18
11654: PUSH
11655: LD_EXP 19
11659: PUSH
11660: LD_EXP 20
11664: PUSH
11665: LD_EXP 21
11669: PUSH
11670: LD_EXP 22
11674: PUSH
11675: LD_EXP 23
11679: PUSH
11680: LD_EXP 24
11684: PUSH
11685: LD_EXP 25
11689: PUSH
11690: LD_EXP 26
11694: PUSH
11695: LD_EXP 27
11699: PUSH
11700: LD_EXP 28
11704: PUSH
11705: LD_EXP 29
11709: PUSH
11710: LD_EXP 30
11714: PUSH
11715: LD_EXP 31
11719: PUSH
11720: LD_EXP 32
11724: PUSH
11725: LD_EXP 33
11729: PUSH
11730: LD_EXP 34
11734: PUSH
11735: LD_EXP 36
11739: PUSH
11740: LD_EXP 37
11744: PUSH
11745: LD_EXP 38
11749: PUSH
11750: LD_EXP 39
11754: PUSH
11755: LD_EXP 40
11759: PUSH
11760: LD_EXP 41
11764: PUSH
11765: LD_EXP 42
11769: PUSH
11770: LD_EXP 43
11774: PUSH
11775: LD_EXP 44
11779: PUSH
11780: LD_EXP 45
11784: PUSH
11785: LD_EXP 46
11789: PUSH
11790: LD_EXP 47
11794: PUSH
11795: LD_EXP 48
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: ST_TO_ADDR
// if tmp diff tmp2 then
11835: LD_VAR 0 2
11839: PUSH
11840: LD_VAR 0 3
11844: DIFF
11845: IFFALSE 11865
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11847: LD_VAR 0 2
11851: PUSH
11852: LD_VAR 0 3
11856: DIFF
11857: PPUSH
11858: LD_STRING 13a_others
11860: PPUSH
11861: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11865: LD_EXP 15
11869: PPUSH
11870: LD_STRING 13a_JMM
11872: PPUSH
11873: CALL_OW 38
// if Titov then
11877: LD_EXP 34
11881: IFFALSE 11895
// SaveCharacters ( Titov , 13a_Titov ) ;
11883: LD_EXP 34
11887: PPUSH
11888: LD_STRING 13a_Titov
11890: PPUSH
11891: CALL_OW 38
// if Dolgov then
11895: LD_EXP 36
11899: IFFALSE 11913
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11901: LD_EXP 36
11905: PPUSH
11906: LD_STRING 13a_Dolgov
11908: PPUSH
11909: CALL_OW 38
// if Petrosyan then
11913: LD_EXP 37
11917: IFFALSE 11931
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11919: LD_EXP 37
11923: PPUSH
11924: LD_STRING 13a_Petrosyan
11926: PPUSH
11927: CALL_OW 38
// if Scholtze then
11931: LD_EXP 38
11935: IFFALSE 11949
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11937: LD_EXP 38
11941: PPUSH
11942: LD_STRING 13a_Scholtze
11944: PPUSH
11945: CALL_OW 38
// if Oblukov then
11949: LD_EXP 39
11953: IFFALSE 11967
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11955: LD_EXP 39
11959: PPUSH
11960: LD_STRING 13a_Oblukov
11962: PPUSH
11963: CALL_OW 38
// if Kapitsova then
11967: LD_EXP 40
11971: IFFALSE 11985
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11973: LD_EXP 40
11977: PPUSH
11978: LD_STRING 13a_Kapitsova
11980: PPUSH
11981: CALL_OW 38
// if Lipshchin then
11985: LD_EXP 41
11989: IFFALSE 12003
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11991: LD_EXP 41
11995: PPUSH
11996: LD_STRING 13a_Lipshchin
11998: PPUSH
11999: CALL_OW 38
// if Petrovova then
12003: LD_EXP 42
12007: IFFALSE 12021
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12009: LD_EXP 42
12013: PPUSH
12014: LD_STRING 13a_Petrovova
12016: PPUSH
12017: CALL_OW 38
// if Kovalyuk then
12021: LD_EXP 43
12025: IFFALSE 12039
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12027: LD_EXP 43
12031: PPUSH
12032: LD_STRING 13a_Kovalyuk
12034: PPUSH
12035: CALL_OW 38
// if Kuzmov then
12039: LD_EXP 44
12043: IFFALSE 12057
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12045: LD_EXP 44
12049: PPUSH
12050: LD_STRING 13a_Kuzmov
12052: PPUSH
12053: CALL_OW 38
// if Karamazov then
12057: LD_EXP 45
12061: IFFALSE 12075
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12063: LD_EXP 45
12067: PPUSH
12068: LD_STRING 13a_Karamazov
12070: PPUSH
12071: CALL_OW 38
// if Burlak then
12075: LD_EXP 46
12079: IFFALSE 12093
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12081: LD_EXP 46
12085: PPUSH
12086: LD_STRING 13a_Burlak
12088: PPUSH
12089: CALL_OW 38
// if Belkov then
12093: LD_EXP 47
12097: IFFALSE 12111
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12099: LD_EXP 47
12103: PPUSH
12104: LD_STRING 13a_Belkov
12106: PPUSH
12107: CALL_OW 38
// if Gnyevko then
12111: LD_EXP 48
12115: IFFALSE 12129
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12117: LD_EXP 48
12121: PPUSH
12122: LD_STRING 13a_Gnyevko
12124: PPUSH
12125: CALL_OW 38
// if Lisa then
12129: LD_EXP 17
12133: IFFALSE 12147
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12135: LD_EXP 17
12139: PPUSH
12140: LD_STRING 13a_Lisa
12142: PPUSH
12143: CALL_OW 38
// if Donaldson then
12147: LD_EXP 18
12151: IFFALSE 12165
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12153: LD_EXP 18
12157: PPUSH
12158: LD_STRING 13a_Donaldson
12160: PPUSH
12161: CALL_OW 38
// if Bobby then
12165: LD_EXP 19
12169: IFFALSE 12183
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12171: LD_EXP 19
12175: PPUSH
12176: LD_STRING 13a_Bobby
12178: PPUSH
12179: CALL_OW 38
// if Cyrus then
12183: LD_EXP 20
12187: IFFALSE 12201
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12189: LD_EXP 20
12193: PPUSH
12194: LD_STRING 13a_Cyrus
12196: PPUSH
12197: CALL_OW 38
// if Denis then
12201: LD_EXP 21
12205: IFFALSE 12219
// SaveCharacters ( Denis , 13a_Denis ) ;
12207: LD_EXP 21
12211: PPUSH
12212: LD_STRING 13a_Denis
12214: PPUSH
12215: CALL_OW 38
// if Brown then
12219: LD_EXP 22
12223: IFFALSE 12237
// SaveCharacters ( Brown , 13a_Brown ) ;
12225: LD_EXP 22
12229: PPUSH
12230: LD_STRING 13a_Brown
12232: PPUSH
12233: CALL_OW 38
// if Gladstone then
12237: LD_EXP 23
12241: IFFALSE 12255
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12243: LD_EXP 23
12247: PPUSH
12248: LD_STRING 13a_Gladstone
12250: PPUSH
12251: CALL_OW 38
// if Houten then
12255: LD_EXP 24
12259: IFFALSE 12273
// SaveCharacters ( Houten , 13a_Houten ) ;
12261: LD_EXP 24
12265: PPUSH
12266: LD_STRING 13a_Houten
12268: PPUSH
12269: CALL_OW 38
// if Cornel then
12273: LD_EXP 25
12277: IFFALSE 12291
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12279: LD_EXP 25
12283: PPUSH
12284: LD_STRING 13a_Cornel
12286: PPUSH
12287: CALL_OW 38
// if Gary then
12291: LD_EXP 26
12295: IFFALSE 12309
// SaveCharacters ( Gary , 13a_Gary ) ;
12297: LD_EXP 26
12301: PPUSH
12302: LD_STRING 13a_Gary
12304: PPUSH
12305: CALL_OW 38
// if Frank then
12309: LD_EXP 27
12313: IFFALSE 12327
// SaveCharacters ( Frank , 13a_Frank ) ;
12315: LD_EXP 27
12319: PPUSH
12320: LD_STRING 13a_Frank
12322: PPUSH
12323: CALL_OW 38
// if Kikuchi then
12327: LD_EXP 28
12331: IFFALSE 12345
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12333: LD_EXP 28
12337: PPUSH
12338: LD_STRING 13a_Kikuchi
12340: PPUSH
12341: CALL_OW 38
// if Simms then
12345: LD_EXP 29
12349: IFFALSE 12363
// SaveCharacters ( Simms , 13a_Simms ) ;
12351: LD_EXP 29
12355: PPUSH
12356: LD_STRING 13a_Simms
12358: PPUSH
12359: CALL_OW 38
// if Joan then
12363: LD_EXP 30
12367: IFFALSE 12381
// SaveCharacters ( Joan , 13a_Joan ) ;
12369: LD_EXP 30
12373: PPUSH
12374: LD_STRING 13a_Joan
12376: PPUSH
12377: CALL_OW 38
// if DeltaDoctor then
12381: LD_EXP 31
12385: IFFALSE 12399
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12387: LD_EXP 31
12391: PPUSH
12392: LD_STRING 13a_DeltaDoctor
12394: PPUSH
12395: CALL_OW 38
// if Gossudarov then
12399: LD_EXP 32
12403: IFFALSE 12417
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12405: LD_EXP 32
12409: PPUSH
12410: LD_STRING 13a_Gossudarov
12412: PPUSH
12413: CALL_OW 38
// if Kirilenkova then
12417: LD_EXP 33
12421: IFFALSE 12435
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12423: LD_EXP 33
12427: PPUSH
12428: LD_STRING 13a_Kirilenkova
12430: PPUSH
12431: CALL_OW 38
// if Roth then
12435: LD_EXP 16
12439: IFFALSE 12453
// SaveCharacters ( Roth , 13a_Roth ) ;
12441: LD_EXP 16
12445: PPUSH
12446: LD_STRING 13a_Roth
12448: PPUSH
12449: CALL_OW 38
// if Masha then
12453: LD_EXP 49
12457: IFFALSE 12512
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12459: LD_EXP 49
12463: PPUSH
12464: CALL_OW 265
12468: PUSH
12469: LD_EXP 49
12473: PPUSH
12474: CALL_OW 262
12478: PUSH
12479: LD_EXP 49
12483: PPUSH
12484: CALL_OW 263
12488: PUSH
12489: LD_EXP 49
12493: PPUSH
12494: CALL_OW 264
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: PPUSH
12505: LD_STRING 13a_Masha
12507: PPUSH
12508: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12512: LD_ADDR_VAR 0 2
12516: PUSH
12517: LD_INT 21
12519: PUSH
12520: LD_INT 3
12522: PUSH
12523: EMPTY
12524: LIST
12525: LIST
12526: PPUSH
12527: CALL_OW 69
12531: ST_TO_ADDR
// tmp2 := [ ] ;
12532: LD_ADDR_VAR 0 3
12536: PUSH
12537: EMPTY
12538: ST_TO_ADDR
// if tmp then
12539: LD_VAR 0 2
12543: IFFALSE 12694
// for i in tmp do
12545: LD_ADDR_VAR 0 1
12549: PUSH
12550: LD_VAR 0 2
12554: PUSH
12555: FOR_IN
12556: IFFALSE 12692
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12558: LD_ADDR_VAR 0 3
12562: PUSH
12563: LD_VAR 0 3
12567: PUSH
12568: LD_VAR 0 1
12572: PPUSH
12573: CALL_OW 255
12577: PUSH
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 248
12587: PUSH
12588: LD_VAR 0 1
12592: PPUSH
12593: CALL_OW 266
12597: PUSH
12598: LD_VAR 0 1
12602: PPUSH
12603: CALL_OW 250
12607: PUSH
12608: LD_VAR 0 1
12612: PPUSH
12613: CALL_OW 251
12617: PUSH
12618: LD_VAR 0 1
12622: PPUSH
12623: CALL_OW 254
12627: PUSH
12628: LD_VAR 0 1
12632: PPUSH
12633: CALL_OW 267
12637: PUSH
12638: LD_VAR 0 1
12642: PPUSH
12643: LD_INT 1
12645: PPUSH
12646: CALL_OW 268
12650: PUSH
12651: LD_VAR 0 1
12655: PPUSH
12656: LD_INT 2
12658: PPUSH
12659: CALL_OW 268
12663: PUSH
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 269
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: PUSH
12686: EMPTY
12687: LIST
12688: ADD
12689: ST_TO_ADDR
12690: GO 12555
12692: POP
12693: POP
// if tmp2 then
12694: LD_VAR 0 3
12698: IFFALSE 12712
// SaveVariable ( tmp2 , 13a_buildings ) ;
12700: LD_VAR 0 3
12704: PPUSH
12705: LD_STRING 13a_buildings
12707: PPUSH
12708: CALL_OW 39
// YouWin ;
12712: CALL_OW 103
// end ;
12716: PPOPN 6
12718: END
// export function SciRu ; var tmp , t ; begin
12719: LD_INT 0
12721: PPUSH
12722: PPUSH
12723: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12724: LD_ADDR_VAR 0 3
12728: PUSH
12729: LD_EXP 32
12733: PUSH
12734: LD_EXP 46
12738: PUSH
12739: LD_EXP 34
12743: PUSH
12744: LD_EXP 47
12748: PUSH
12749: LD_EXP 48
12753: PUSH
12754: LD_EXP 37
12758: PUSH
12759: LD_EXP 38
12763: PUSH
12764: LD_EXP 36
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12779: LD_ADDR_VAR 0 2
12783: PUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 7
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 23
12796: PUSH
12797: LD_INT 3
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 25
12806: PUSH
12807: LD_INT 4
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 26
12816: PUSH
12817: LD_INT 1
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: PUSH
12824: EMPTY
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: PPUSH
12830: CALL_OW 69
12834: PUSH
12835: LD_VAR 0 3
12839: DIFF
12840: ST_TO_ADDR
// if tmp then
12841: LD_VAR 0 2
12845: IFFALSE 12861
// result := tmp [ 1 ] ;
12847: LD_ADDR_VAR 0 1
12851: PUSH
12852: LD_VAR 0 2
12856: PUSH
12857: LD_INT 1
12859: ARRAY
12860: ST_TO_ADDR
// end ;
12861: LD_VAR 0 1
12865: RET
// export function SolRu ; var tmp , t ; begin
12866: LD_INT 0
12868: PPUSH
12869: PPUSH
12870: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12871: LD_ADDR_VAR 0 3
12875: PUSH
12876: LD_EXP 32
12880: PUSH
12881: LD_EXP 46
12885: PUSH
12886: LD_EXP 34
12890: PUSH
12891: LD_EXP 47
12895: PUSH
12896: LD_EXP 48
12900: PUSH
12901: LD_EXP 37
12905: PUSH
12906: LD_EXP 38
12910: PUSH
12911: LD_EXP 36
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12926: LD_ADDR_VAR 0 2
12930: PUSH
12931: LD_INT 22
12933: PUSH
12934: LD_INT 7
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: PUSH
12941: LD_INT 23
12943: PUSH
12944: LD_INT 3
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 25
12953: PUSH
12954: LD_INT 1
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 26
12963: PUSH
12964: LD_INT 1
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: PPUSH
12977: CALL_OW 69
12981: PUSH
12982: LD_VAR 0 3
12986: DIFF
12987: ST_TO_ADDR
// if tmp then
12988: LD_VAR 0 2
12992: IFFALSE 13008
// result := tmp [ 1 ] ;
12994: LD_ADDR_VAR 0 1
12998: PUSH
12999: LD_VAR 0 2
13003: PUSH
13004: LD_INT 1
13006: ARRAY
13007: ST_TO_ADDR
// end ; end_of_file
13008: LD_VAR 0 1
13012: RET
// export function CustomEvent ( event ) ; begin
13013: LD_INT 0
13015: PPUSH
// end ;
13016: LD_VAR 0 2
13020: RET
// on UnitDestroyed ( un ) do var i , side ;
13021: LD_INT 0
13023: PPUSH
13024: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13025: LD_VAR 0 1
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 7
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PUSH
13040: LD_INT 2
13042: PUSH
13043: LD_INT 25
13045: PUSH
13046: LD_INT 1
13048: PUSH
13049: EMPTY
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 25
13055: PUSH
13056: LD_INT 2
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 25
13065: PUSH
13066: LD_INT 3
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: PUSH
13073: LD_INT 25
13075: PUSH
13076: LD_INT 4
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PUSH
13083: LD_INT 25
13085: PUSH
13086: LD_INT 5
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: PUSH
13093: LD_INT 25
13095: PUSH
13096: LD_INT 8
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: PUSH
13103: LD_INT 25
13105: PUSH
13106: LD_INT 9
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PUSH
13113: EMPTY
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: PUSH
13123: EMPTY
13124: LIST
13125: LIST
13126: PPUSH
13127: CALL_OW 69
13131: IN
13132: IFFALSE 13148
// loss_counter := loss_counter + 1 ;
13134: LD_ADDR_EXP 13
13138: PUSH
13139: LD_EXP 13
13143: PUSH
13144: LD_INT 1
13146: PLUS
13147: ST_TO_ADDR
// if un = Abdul then
13148: LD_VAR 0 1
13152: PUSH
13153: LD_EXP 55
13157: EQUAL
13158: IFFALSE 13168
// abdul_escaped := false ;
13160: LD_ADDR_EXP 12
13164: PUSH
13165: LD_INT 0
13167: ST_TO_ADDR
// if un in ru_attackers then
13168: LD_VAR 0 1
13172: PUSH
13173: LD_EXP 52
13177: IN
13178: IFFALSE 13196
// ru_attackers := ru_attackers diff un ;
13180: LD_ADDR_EXP 52
13184: PUSH
13185: LD_EXP 52
13189: PUSH
13190: LD_VAR 0 1
13194: DIFF
13195: ST_TO_ADDR
// if un in ar_attackers then
13196: LD_VAR 0 1
13200: PUSH
13201: LD_EXP 10
13205: IN
13206: IFFALSE 13224
// ar_attackers := ar_attackers diff un ;
13208: LD_ADDR_EXP 10
13212: PUSH
13213: LD_EXP 10
13217: PUSH
13218: LD_VAR 0 1
13222: DIFF
13223: ST_TO_ADDR
// if un = JMM then
13224: LD_VAR 0 1
13228: PUSH
13229: LD_EXP 15
13233: EQUAL
13234: IFFALSE 13245
// begin YouLost ( JMM ) ;
13236: LD_STRING JMM
13238: PPUSH
13239: CALL_OW 104
// exit ;
13243: GO 13334
// end ; if un = Burlak then
13245: LD_VAR 0 1
13249: PUSH
13250: LD_EXP 46
13254: EQUAL
13255: IFFALSE 13266
// begin YouLost ( Burlak ) ;
13257: LD_STRING Burlak
13259: PPUSH
13260: CALL_OW 104
// exit ;
13264: GO 13334
// end ; if un = freedom then
13266: LD_VAR 0 1
13270: PUSH
13271: LD_EXP 3
13275: EQUAL
13276: IFFALSE 13287
// begin YouLost ( Destroyed ) ;
13278: LD_STRING Destroyed
13280: PPUSH
13281: CALL_OW 104
// exit ;
13285: GO 13334
// end ; if un = Masha then
13287: LD_VAR 0 1
13291: PUSH
13292: LD_EXP 49
13296: EQUAL
13297: IFFALSE 13306
// ChangeMissionObjectives ( M4b ) ;
13299: LD_STRING M4b
13301: PPUSH
13302: CALL_OW 337
// if un = Mastodont then
13306: LD_VAR 0 1
13310: PUSH
13311: LD_EXP 56
13315: EQUAL
13316: IFFALSE 13325
// ChangeMissionObjectives ( M4a ) ;
13318: LD_STRING M4a
13320: PPUSH
13321: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13325: LD_VAR 0 1
13329: PPUSH
13330: CALL 84671 0 1
// end ;
13334: PPOPN 3
13336: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13337: LD_VAR 0 1
13341: PPUSH
13342: LD_VAR 0 2
13346: PPUSH
13347: CALL 87005 0 2
// end ;
13351: PPOPN 2
13353: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13354: LD_VAR 0 1
13358: PPUSH
13359: CALL 86073 0 1
// end ;
13363: PPOPN 1
13365: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13366: LD_VAR 0 1
13370: PUSH
13371: LD_INT 22
13373: PUSH
13374: LD_INT 7
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: PUSH
13381: LD_INT 30
13383: PUSH
13384: LD_INT 0
13386: PUSH
13387: EMPTY
13388: LIST
13389: LIST
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PPUSH
13395: CALL_OW 69
13399: IN
13400: IFFALSE 13439
// begin SetBName ( building , freedom ) ;
13402: LD_VAR 0 1
13406: PPUSH
13407: LD_STRING freedom
13409: PPUSH
13410: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13414: LD_INT 0
13416: PPUSH
13417: LD_INT 7
13419: PPUSH
13420: LD_INT 0
13422: PPUSH
13423: CALL_OW 324
// freedom := building ;
13427: LD_ADDR_EXP 3
13431: PUSH
13432: LD_VAR 0 1
13436: ST_TO_ADDR
// exit ;
13437: GO 13505
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13439: LD_VAR 0 1
13443: PUSH
13444: LD_INT 22
13446: PUSH
13447: LD_INT 7
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 23
13456: PUSH
13457: LD_INT 3
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 30
13466: PUSH
13467: LD_INT 6
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: LIST
13478: PPUSH
13479: CALL_OW 69
13483: IN
13484: IFFALSE 13496
// begin ru_lab_builded := true ;
13486: LD_ADDR_EXP 5
13490: PUSH
13491: LD_INT 1
13493: ST_TO_ADDR
// exit ;
13494: GO 13505
// end ; MCE_BuildingComplete ( building ) ;
13496: LD_VAR 0 1
13500: PPUSH
13501: CALL 86314 0 1
// end ;
13505: PPOPN 1
13507: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13508: LD_VAR 0 1
13512: PPUSH
13513: LD_VAR 0 2
13517: PPUSH
13518: CALL 84367 0 2
// end ;
13522: PPOPN 2
13524: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13525: LD_VAR 0 1
13529: PPUSH
13530: LD_VAR 0 2
13534: PPUSH
13535: LD_VAR 0 3
13539: PPUSH
13540: LD_VAR 0 4
13544: PPUSH
13545: LD_VAR 0 5
13549: PPUSH
13550: CALL 83987 0 5
// end ;
13554: PPOPN 5
13556: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13557: LD_VAR 0 1
13561: PPUSH
13562: LD_VAR 0 2
13566: PPUSH
13567: CALL 83583 0 2
// end ;
13571: PPOPN 2
13573: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13574: LD_VAR 0 1
13578: PPUSH
13579: CALL_OW 263
13583: PUSH
13584: LD_INT 3
13586: EQUAL
13587: PUSH
13588: LD_VAR 0 2
13592: PPUSH
13593: CALL_OW 263
13597: PUSH
13598: LD_INT 3
13600: EQUAL
13601: OR
13602: IFFALSE 13618
// hack_counter := hack_counter + 1 ;
13604: LD_ADDR_EXP 14
13608: PUSH
13609: LD_EXP 14
13613: PUSH
13614: LD_INT 1
13616: PLUS
13617: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13618: LD_VAR 0 1
13622: PPUSH
13623: LD_VAR 0 2
13627: PPUSH
13628: LD_VAR 0 3
13632: PPUSH
13633: LD_VAR 0 4
13637: PPUSH
13638: CALL 83421 0 4
// end ;
13642: PPOPN 4
13644: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13645: LD_VAR 0 1
13649: PPUSH
13650: LD_VAR 0 2
13654: PPUSH
13655: LD_VAR 0 3
13659: PPUSH
13660: CALL 83196 0 3
// end ;
13664: PPOPN 3
13666: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13667: LD_VAR 0 1
13671: PPUSH
13672: LD_VAR 0 2
13676: PPUSH
13677: CALL 83081 0 2
// end ;
13681: PPOPN 2
13683: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13684: LD_VAR 0 1
13688: PPUSH
13689: LD_VAR 0 2
13693: PPUSH
13694: CALL 87266 0 2
// end ;
13698: PPOPN 2
13700: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13701: LD_VAR 0 1
13705: PPUSH
13706: LD_VAR 0 2
13710: PPUSH
13711: LD_VAR 0 3
13715: PPUSH
13716: LD_VAR 0 4
13720: PPUSH
13721: CALL 87482 0 4
// end ;
13725: PPOPN 4
13727: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13728: LD_VAR 0 1
13732: PPUSH
13733: LD_VAR 0 2
13737: PPUSH
13738: CALL 82890 0 2
// end ;
13742: PPOPN 2
13744: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13745: LD_VAR 0 1
13749: PPUSH
13750: CALL 98676 0 1
// end ; end_of_file
13754: PPOPN 1
13756: END
// every 0 0$30 do var cr , time ;
13757: GO 13759
13759: DISABLE
13760: LD_INT 0
13762: PPUSH
13763: PPUSH
// begin time := 0 0$30 ;
13764: LD_ADDR_VAR 0 2
13768: PUSH
13769: LD_INT 1050
13771: ST_TO_ADDR
// while game do
13772: LD_EXP 2
13776: IFFALSE 13875
// begin wait ( time ) ;
13778: LD_VAR 0 2
13782: PPUSH
13783: CALL_OW 67
// if tick > 2 2$00 then
13787: LD_OWVAR 1
13791: PUSH
13792: LD_INT 4200
13794: GREATER
13795: IFFALSE 13828
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13797: LD_ADDR_VAR 0 2
13801: PUSH
13802: LD_VAR 0 2
13806: PUSH
13807: LD_INT 280
13809: PUSH
13810: LD_INT 420
13812: PUSH
13813: LD_INT 630
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: LIST
13820: PUSH
13821: LD_OWVAR 67
13825: ARRAY
13826: PLUS
13827: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13828: LD_INT 1
13830: PPUSH
13831: LD_INT 5
13833: PPUSH
13834: CALL_OW 12
13838: PPUSH
13839: LD_INT 70
13841: PPUSH
13842: LD_INT 49
13844: PPUSH
13845: LD_INT 25
13847: PPUSH
13848: LD_INT 1
13850: PPUSH
13851: CALL_OW 56
// if time > 5 5$00 then
13855: LD_VAR 0 2
13859: PUSH
13860: LD_INT 10500
13862: GREATER
13863: IFFALSE 13873
// time := 0 0$30 ;
13865: LD_ADDR_VAR 0 2
13869: PUSH
13870: LD_INT 1050
13872: ST_TO_ADDR
// end ;
13873: GO 13772
// end ;
13875: PPOPN 2
13877: END
// every 0 0$30 do var cr , time ;
13878: GO 13880
13880: DISABLE
13881: LD_INT 0
13883: PPUSH
13884: PPUSH
// begin time := 0 0$20 ;
13885: LD_ADDR_VAR 0 2
13889: PUSH
13890: LD_INT 700
13892: ST_TO_ADDR
// while game do
13893: LD_EXP 2
13897: IFFALSE 13986
// begin wait ( time ) ;
13899: LD_VAR 0 2
13903: PPUSH
13904: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13908: LD_ADDR_VAR 0 2
13912: PUSH
13913: LD_VAR 0 2
13917: PUSH
13918: LD_INT 490
13920: PUSH
13921: LD_INT 525
13923: PUSH
13924: LD_INT 560
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: LIST
13931: PUSH
13932: LD_OWVAR 67
13936: ARRAY
13937: PLUS
13938: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13939: LD_INT 3
13941: PPUSH
13942: LD_INT 5
13944: PPUSH
13945: CALL_OW 12
13949: PPUSH
13950: LD_INT 26
13952: PPUSH
13953: LD_INT 9
13955: PPUSH
13956: LD_INT 30
13958: PPUSH
13959: LD_INT 1
13961: PPUSH
13962: CALL_OW 56
// if time > 3 3$00 then
13966: LD_VAR 0 2
13970: PUSH
13971: LD_INT 6300
13973: GREATER
13974: IFFALSE 13984
// time := 0 0$20 ;
13976: LD_ADDR_VAR 0 2
13980: PUSH
13981: LD_INT 700
13983: ST_TO_ADDR
// end ;
13984: GO 13893
// end ;
13986: PPOPN 2
13988: END
// every 0 0$30 do var cr , time ;
13989: GO 13991
13991: DISABLE
13992: LD_INT 0
13994: PPUSH
13995: PPUSH
// begin time := 0 0$20 ;
13996: LD_ADDR_VAR 0 2
14000: PUSH
14001: LD_INT 700
14003: ST_TO_ADDR
// while game do
14004: LD_EXP 2
14008: IFFALSE 14133
// begin wait ( time ) ;
14010: LD_VAR 0 2
14014: PPUSH
14015: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14019: LD_ADDR_VAR 0 2
14023: PUSH
14024: LD_VAR 0 2
14028: PUSH
14029: LD_INT 175
14031: PUSH
14032: LD_INT 210
14034: PUSH
14035: LD_INT 280
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: LIST
14042: PUSH
14043: LD_OWVAR 67
14047: ARRAY
14048: PLUS
14049: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14050: LD_INT 1
14052: PPUSH
14053: LD_INT 5
14055: PPUSH
14056: CALL_OW 12
14060: PPUSH
14061: LD_INT 179
14063: PPUSH
14064: LD_INT 101
14066: PPUSH
14067: LD_INT 20
14069: PPUSH
14070: LD_INT 1
14072: PPUSH
14073: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14077: LD_INT 350
14079: PPUSH
14080: LD_INT 525
14082: PPUSH
14083: CALL_OW 12
14087: PPUSH
14088: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14092: LD_INT 1
14094: PPUSH
14095: LD_INT 5
14097: PPUSH
14098: CALL_OW 12
14102: PPUSH
14103: LD_INT 9
14105: PPUSH
14106: LD_INT 1
14108: PPUSH
14109: CALL_OW 55
// if time > 4 4$00 then
14113: LD_VAR 0 2
14117: PUSH
14118: LD_INT 8400
14120: GREATER
14121: IFFALSE 14131
// time := 0 0$30 ;
14123: LD_ADDR_VAR 0 2
14127: PUSH
14128: LD_INT 1050
14130: ST_TO_ADDR
// end ;
14131: GO 14004
// end ;
14133: PPOPN 2
14135: END
// every 0 0$30 do var cr , time ;
14136: GO 14138
14138: DISABLE
14139: LD_INT 0
14141: PPUSH
14142: PPUSH
// begin time := 0 0$10 ;
14143: LD_ADDR_VAR 0 2
14147: PUSH
14148: LD_INT 350
14150: ST_TO_ADDR
// while game do
14151: LD_EXP 2
14155: IFFALSE 14289
// begin wait ( time ) ;
14157: LD_VAR 0 2
14161: PPUSH
14162: CALL_OW 67
// time := time + 0 0$10 ;
14166: LD_ADDR_VAR 0 2
14170: PUSH
14171: LD_VAR 0 2
14175: PUSH
14176: LD_INT 350
14178: PLUS
14179: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14180: LD_INT 1
14182: PPUSH
14183: LD_INT 5
14185: PPUSH
14186: CALL_OW 12
14190: PPUSH
14191: LD_INT 11
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_INT 1
14208: PPUSH
14209: LD_INT 3
14211: PPUSH
14212: CALL_OW 12
14216: ST_TO_ADDR
// if cr = 1 then
14217: LD_VAR 0 1
14221: PUSH
14222: LD_INT 1
14224: EQUAL
14225: IFFALSE 14269
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14227: LD_INT 700
14229: PPUSH
14230: LD_INT 1575
14232: PPUSH
14233: CALL_OW 12
14237: PPUSH
14238: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14242: LD_INT 1
14244: PPUSH
14245: LD_INT 5
14247: PPUSH
14248: CALL_OW 12
14252: PPUSH
14253: LD_INT 34
14255: PPUSH
14256: LD_INT 50
14258: PPUSH
14259: LD_INT 7
14261: PPUSH
14262: LD_INT 1
14264: PPUSH
14265: CALL_OW 56
// end ; if time > 8 8$00 then
14269: LD_VAR 0 2
14273: PUSH
14274: LD_INT 16800
14276: GREATER
14277: IFFALSE 14287
// time := 0 0$40 ;
14279: LD_ADDR_VAR 0 2
14283: PUSH
14284: LD_INT 1400
14286: ST_TO_ADDR
// end ;
14287: GO 14151
// end ; end_of_file
14289: PPOPN 2
14291: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14292: LD_INT 0
14294: PPUSH
14295: PPUSH
// if exist_mode then
14296: LD_VAR 0 2
14300: IFFALSE 14325
// unit := CreateCharacter ( prefix & ident ) else
14302: LD_ADDR_VAR 0 5
14306: PUSH
14307: LD_VAR 0 3
14311: PUSH
14312: LD_VAR 0 1
14316: STR
14317: PPUSH
14318: CALL_OW 34
14322: ST_TO_ADDR
14323: GO 14340
// unit := NewCharacter ( ident ) ;
14325: LD_ADDR_VAR 0 5
14329: PUSH
14330: LD_VAR 0 1
14334: PPUSH
14335: CALL_OW 25
14339: ST_TO_ADDR
// result := unit ;
14340: LD_ADDR_VAR 0 4
14344: PUSH
14345: LD_VAR 0 5
14349: ST_TO_ADDR
// end ;
14350: LD_VAR 0 4
14354: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14355: LD_INT 0
14357: PPUSH
14358: PPUSH
// if not side or not nation then
14359: LD_VAR 0 1
14363: NOT
14364: PUSH
14365: LD_VAR 0 2
14369: NOT
14370: OR
14371: IFFALSE 14375
// exit ;
14373: GO 15139
// case nation of nation_american :
14375: LD_VAR 0 2
14379: PUSH
14380: LD_INT 1
14382: DOUBLE
14383: EQUAL
14384: IFTRUE 14388
14386: GO 14602
14388: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14389: LD_ADDR_VAR 0 4
14393: PUSH
14394: LD_INT 35
14396: PUSH
14397: LD_INT 45
14399: PUSH
14400: LD_INT 46
14402: PUSH
14403: LD_INT 47
14405: PUSH
14406: LD_INT 82
14408: PUSH
14409: LD_INT 83
14411: PUSH
14412: LD_INT 84
14414: PUSH
14415: LD_INT 85
14417: PUSH
14418: LD_INT 86
14420: PUSH
14421: LD_INT 1
14423: PUSH
14424: LD_INT 2
14426: PUSH
14427: LD_INT 6
14429: PUSH
14430: LD_INT 15
14432: PUSH
14433: LD_INT 16
14435: PUSH
14436: LD_INT 7
14438: PUSH
14439: LD_INT 12
14441: PUSH
14442: LD_INT 13
14444: PUSH
14445: LD_INT 10
14447: PUSH
14448: LD_INT 14
14450: PUSH
14451: LD_INT 20
14453: PUSH
14454: LD_INT 21
14456: PUSH
14457: LD_INT 22
14459: PUSH
14460: LD_INT 25
14462: PUSH
14463: LD_INT 32
14465: PUSH
14466: LD_INT 27
14468: PUSH
14469: LD_INT 36
14471: PUSH
14472: LD_INT 69
14474: PUSH
14475: LD_INT 39
14477: PUSH
14478: LD_INT 34
14480: PUSH
14481: LD_INT 40
14483: PUSH
14484: LD_INT 48
14486: PUSH
14487: LD_INT 49
14489: PUSH
14490: LD_INT 50
14492: PUSH
14493: LD_INT 51
14495: PUSH
14496: LD_INT 52
14498: PUSH
14499: LD_INT 53
14501: PUSH
14502: LD_INT 54
14504: PUSH
14505: LD_INT 55
14507: PUSH
14508: LD_INT 56
14510: PUSH
14511: LD_INT 57
14513: PUSH
14514: LD_INT 58
14516: PUSH
14517: LD_INT 59
14519: PUSH
14520: LD_INT 60
14522: PUSH
14523: LD_INT 61
14525: PUSH
14526: LD_INT 62
14528: PUSH
14529: LD_INT 80
14531: PUSH
14532: LD_INT 82
14534: PUSH
14535: LD_INT 83
14537: PUSH
14538: LD_INT 84
14540: PUSH
14541: LD_INT 85
14543: PUSH
14544: LD_INT 86
14546: PUSH
14547: EMPTY
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: ST_TO_ADDR
14600: GO 15063
14602: LD_INT 2
14604: DOUBLE
14605: EQUAL
14606: IFTRUE 14610
14608: GO 14832
14610: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
14611: LD_ADDR_VAR 0 4
14615: PUSH
14616: LD_INT 35
14618: PUSH
14619: LD_INT 45
14621: PUSH
14622: LD_INT 46
14624: PUSH
14625: LD_INT 47
14627: PUSH
14628: LD_INT 82
14630: PUSH
14631: LD_INT 83
14633: PUSH
14634: LD_INT 84
14636: PUSH
14637: LD_INT 85
14639: PUSH
14640: LD_INT 87
14642: PUSH
14643: LD_INT 70
14645: PUSH
14646: LD_INT 1
14648: PUSH
14649: LD_INT 11
14651: PUSH
14652: LD_INT 3
14654: PUSH
14655: LD_INT 4
14657: PUSH
14658: LD_INT 5
14660: PUSH
14661: LD_INT 6
14663: PUSH
14664: LD_INT 15
14666: PUSH
14667: LD_INT 18
14669: PUSH
14670: LD_INT 7
14672: PUSH
14673: LD_INT 17
14675: PUSH
14676: LD_INT 8
14678: PUSH
14679: LD_INT 20
14681: PUSH
14682: LD_INT 21
14684: PUSH
14685: LD_INT 22
14687: PUSH
14688: LD_INT 72
14690: PUSH
14691: LD_INT 26
14693: PUSH
14694: LD_INT 69
14696: PUSH
14697: LD_INT 39
14699: PUSH
14700: LD_INT 40
14702: PUSH
14703: LD_INT 41
14705: PUSH
14706: LD_INT 42
14708: PUSH
14709: LD_INT 43
14711: PUSH
14712: LD_INT 48
14714: PUSH
14715: LD_INT 49
14717: PUSH
14718: LD_INT 50
14720: PUSH
14721: LD_INT 51
14723: PUSH
14724: LD_INT 52
14726: PUSH
14727: LD_INT 53
14729: PUSH
14730: LD_INT 54
14732: PUSH
14733: LD_INT 55
14735: PUSH
14736: LD_INT 56
14738: PUSH
14739: LD_INT 60
14741: PUSH
14742: LD_INT 61
14744: PUSH
14745: LD_INT 62
14747: PUSH
14748: LD_INT 66
14750: PUSH
14751: LD_INT 67
14753: PUSH
14754: LD_INT 68
14756: PUSH
14757: LD_INT 81
14759: PUSH
14760: LD_INT 82
14762: PUSH
14763: LD_INT 83
14765: PUSH
14766: LD_INT 84
14768: PUSH
14769: LD_INT 85
14771: PUSH
14772: LD_INT 87
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: LIST
14779: LIST
14780: LIST
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: LIST
14795: LIST
14796: LIST
14797: LIST
14798: LIST
14799: LIST
14800: LIST
14801: LIST
14802: LIST
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: LIST
14808: LIST
14809: LIST
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: LIST
14817: LIST
14818: LIST
14819: LIST
14820: LIST
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: LIST
14826: LIST
14827: LIST
14828: LIST
14829: ST_TO_ADDR
14830: GO 15063
14832: LD_INT 3
14834: DOUBLE
14835: EQUAL
14836: IFTRUE 14840
14838: GO 15062
14840: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14841: LD_ADDR_VAR 0 4
14845: PUSH
14846: LD_INT 46
14848: PUSH
14849: LD_INT 47
14851: PUSH
14852: LD_INT 1
14854: PUSH
14855: LD_INT 2
14857: PUSH
14858: LD_INT 82
14860: PUSH
14861: LD_INT 83
14863: PUSH
14864: LD_INT 84
14866: PUSH
14867: LD_INT 85
14869: PUSH
14870: LD_INT 86
14872: PUSH
14873: LD_INT 11
14875: PUSH
14876: LD_INT 9
14878: PUSH
14879: LD_INT 20
14881: PUSH
14882: LD_INT 19
14884: PUSH
14885: LD_INT 21
14887: PUSH
14888: LD_INT 24
14890: PUSH
14891: LD_INT 22
14893: PUSH
14894: LD_INT 25
14896: PUSH
14897: LD_INT 28
14899: PUSH
14900: LD_INT 29
14902: PUSH
14903: LD_INT 30
14905: PUSH
14906: LD_INT 31
14908: PUSH
14909: LD_INT 37
14911: PUSH
14912: LD_INT 38
14914: PUSH
14915: LD_INT 32
14917: PUSH
14918: LD_INT 27
14920: PUSH
14921: LD_INT 33
14923: PUSH
14924: LD_INT 69
14926: PUSH
14927: LD_INT 39
14929: PUSH
14930: LD_INT 34
14932: PUSH
14933: LD_INT 40
14935: PUSH
14936: LD_INT 71
14938: PUSH
14939: LD_INT 23
14941: PUSH
14942: LD_INT 44
14944: PUSH
14945: LD_INT 48
14947: PUSH
14948: LD_INT 49
14950: PUSH
14951: LD_INT 50
14953: PUSH
14954: LD_INT 51
14956: PUSH
14957: LD_INT 52
14959: PUSH
14960: LD_INT 53
14962: PUSH
14963: LD_INT 54
14965: PUSH
14966: LD_INT 55
14968: PUSH
14969: LD_INT 56
14971: PUSH
14972: LD_INT 57
14974: PUSH
14975: LD_INT 58
14977: PUSH
14978: LD_INT 59
14980: PUSH
14981: LD_INT 63
14983: PUSH
14984: LD_INT 64
14986: PUSH
14987: LD_INT 65
14989: PUSH
14990: LD_INT 82
14992: PUSH
14993: LD_INT 83
14995: PUSH
14996: LD_INT 84
14998: PUSH
14999: LD_INT 85
15001: PUSH
15002: LD_INT 86
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: LIST
15031: LIST
15032: LIST
15033: LIST
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: LIST
15052: LIST
15053: LIST
15054: LIST
15055: LIST
15056: LIST
15057: LIST
15058: LIST
15059: ST_TO_ADDR
15060: GO 15063
15062: POP
// if state > - 1 and state < 3 then
15063: LD_VAR 0 3
15067: PUSH
15068: LD_INT 1
15070: NEG
15071: GREATER
15072: PUSH
15073: LD_VAR 0 3
15077: PUSH
15078: LD_INT 3
15080: LESS
15081: AND
15082: IFFALSE 15139
// for i in result do
15084: LD_ADDR_VAR 0 5
15088: PUSH
15089: LD_VAR 0 4
15093: PUSH
15094: FOR_IN
15095: IFFALSE 15137
// if GetTech ( i , side ) <> state then
15097: LD_VAR 0 5
15101: PPUSH
15102: LD_VAR 0 1
15106: PPUSH
15107: CALL_OW 321
15111: PUSH
15112: LD_VAR 0 3
15116: NONEQUAL
15117: IFFALSE 15135
// result := result diff i ;
15119: LD_ADDR_VAR 0 4
15123: PUSH
15124: LD_VAR 0 4
15128: PUSH
15129: LD_VAR 0 5
15133: DIFF
15134: ST_TO_ADDR
15135: GO 15094
15137: POP
15138: POP
// end ;
15139: LD_VAR 0 4
15143: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15144: LD_INT 0
15146: PPUSH
15147: PPUSH
15148: PPUSH
// result := true ;
15149: LD_ADDR_VAR 0 3
15153: PUSH
15154: LD_INT 1
15156: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15157: LD_ADDR_VAR 0 5
15161: PUSH
15162: LD_VAR 0 2
15166: PPUSH
15167: CALL_OW 480
15171: ST_TO_ADDR
// if not tmp then
15172: LD_VAR 0 5
15176: NOT
15177: IFFALSE 15181
// exit ;
15179: GO 15230
// for i in tmp do
15181: LD_ADDR_VAR 0 4
15185: PUSH
15186: LD_VAR 0 5
15190: PUSH
15191: FOR_IN
15192: IFFALSE 15228
// if GetTech ( i , side ) <> state_researched then
15194: LD_VAR 0 4
15198: PPUSH
15199: LD_VAR 0 1
15203: PPUSH
15204: CALL_OW 321
15208: PUSH
15209: LD_INT 2
15211: NONEQUAL
15212: IFFALSE 15226
// begin result := false ;
15214: LD_ADDR_VAR 0 3
15218: PUSH
15219: LD_INT 0
15221: ST_TO_ADDR
// exit ;
15222: POP
15223: POP
15224: GO 15230
// end ;
15226: GO 15191
15228: POP
15229: POP
// end ;
15230: LD_VAR 0 3
15234: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15235: LD_INT 0
15237: PPUSH
15238: PPUSH
15239: PPUSH
15240: PPUSH
15241: PPUSH
15242: PPUSH
15243: PPUSH
15244: PPUSH
15245: PPUSH
15246: PPUSH
15247: PPUSH
15248: PPUSH
15249: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15250: LD_VAR 0 1
15254: NOT
15255: PUSH
15256: LD_VAR 0 1
15260: PPUSH
15261: CALL_OW 257
15265: PUSH
15266: LD_INT 9
15268: NONEQUAL
15269: OR
15270: IFFALSE 15274
// exit ;
15272: GO 15847
// side := GetSide ( unit ) ;
15274: LD_ADDR_VAR 0 9
15278: PUSH
15279: LD_VAR 0 1
15283: PPUSH
15284: CALL_OW 255
15288: ST_TO_ADDR
// tech_space := tech_spacanom ;
15289: LD_ADDR_VAR 0 12
15293: PUSH
15294: LD_INT 29
15296: ST_TO_ADDR
// tech_time := tech_taurad ;
15297: LD_ADDR_VAR 0 13
15301: PUSH
15302: LD_INT 28
15304: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15305: LD_ADDR_VAR 0 11
15309: PUSH
15310: LD_VAR 0 1
15314: PPUSH
15315: CALL_OW 310
15319: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15320: LD_VAR 0 11
15324: PPUSH
15325: CALL_OW 247
15329: PUSH
15330: LD_INT 2
15332: EQUAL
15333: IFFALSE 15337
// exit ;
15335: GO 15847
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15337: LD_ADDR_VAR 0 8
15341: PUSH
15342: LD_INT 81
15344: PUSH
15345: LD_VAR 0 9
15349: PUSH
15350: EMPTY
15351: LIST
15352: LIST
15353: PUSH
15354: LD_INT 3
15356: PUSH
15357: LD_INT 21
15359: PUSH
15360: LD_INT 3
15362: PUSH
15363: EMPTY
15364: LIST
15365: LIST
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PPUSH
15375: CALL_OW 69
15379: ST_TO_ADDR
// if not tmp then
15380: LD_VAR 0 8
15384: NOT
15385: IFFALSE 15389
// exit ;
15387: GO 15847
// if in_unit then
15389: LD_VAR 0 11
15393: IFFALSE 15417
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15395: LD_ADDR_VAR 0 10
15399: PUSH
15400: LD_VAR 0 8
15404: PPUSH
15405: LD_VAR 0 11
15409: PPUSH
15410: CALL_OW 74
15414: ST_TO_ADDR
15415: GO 15437
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15417: LD_ADDR_VAR 0 10
15421: PUSH
15422: LD_VAR 0 8
15426: PPUSH
15427: LD_VAR 0 1
15431: PPUSH
15432: CALL_OW 74
15436: ST_TO_ADDR
// if not enemy then
15437: LD_VAR 0 10
15441: NOT
15442: IFFALSE 15446
// exit ;
15444: GO 15847
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15446: LD_VAR 0 11
15450: PUSH
15451: LD_VAR 0 11
15455: PPUSH
15456: LD_VAR 0 10
15460: PPUSH
15461: CALL_OW 296
15465: PUSH
15466: LD_INT 13
15468: GREATER
15469: AND
15470: PUSH
15471: LD_VAR 0 1
15475: PPUSH
15476: LD_VAR 0 10
15480: PPUSH
15481: CALL_OW 296
15485: PUSH
15486: LD_INT 12
15488: GREATER
15489: OR
15490: IFFALSE 15494
// exit ;
15492: GO 15847
// missile := [ 1 ] ;
15494: LD_ADDR_VAR 0 14
15498: PUSH
15499: LD_INT 1
15501: PUSH
15502: EMPTY
15503: LIST
15504: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15505: LD_VAR 0 9
15509: PPUSH
15510: LD_VAR 0 12
15514: PPUSH
15515: CALL_OW 325
15519: IFFALSE 15548
// missile := Insert ( missile , missile + 1 , 2 ) ;
15521: LD_ADDR_VAR 0 14
15525: PUSH
15526: LD_VAR 0 14
15530: PPUSH
15531: LD_VAR 0 14
15535: PUSH
15536: LD_INT 1
15538: PLUS
15539: PPUSH
15540: LD_INT 2
15542: PPUSH
15543: CALL_OW 2
15547: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15548: LD_VAR 0 9
15552: PPUSH
15553: LD_VAR 0 13
15557: PPUSH
15558: CALL_OW 325
15562: PUSH
15563: LD_VAR 0 10
15567: PPUSH
15568: CALL_OW 255
15572: PPUSH
15573: LD_VAR 0 13
15577: PPUSH
15578: CALL_OW 325
15582: NOT
15583: AND
15584: IFFALSE 15613
// missile := Insert ( missile , missile + 1 , 3 ) ;
15586: LD_ADDR_VAR 0 14
15590: PUSH
15591: LD_VAR 0 14
15595: PPUSH
15596: LD_VAR 0 14
15600: PUSH
15601: LD_INT 1
15603: PLUS
15604: PPUSH
15605: LD_INT 3
15607: PPUSH
15608: CALL_OW 2
15612: ST_TO_ADDR
// if missile < 2 then
15613: LD_VAR 0 14
15617: PUSH
15618: LD_INT 2
15620: LESS
15621: IFFALSE 15625
// exit ;
15623: GO 15847
// x := GetX ( enemy ) ;
15625: LD_ADDR_VAR 0 4
15629: PUSH
15630: LD_VAR 0 10
15634: PPUSH
15635: CALL_OW 250
15639: ST_TO_ADDR
// y := GetY ( enemy ) ;
15640: LD_ADDR_VAR 0 5
15644: PUSH
15645: LD_VAR 0 10
15649: PPUSH
15650: CALL_OW 251
15654: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15655: LD_ADDR_VAR 0 6
15659: PUSH
15660: LD_VAR 0 4
15664: PUSH
15665: LD_INT 1
15667: NEG
15668: PPUSH
15669: LD_INT 1
15671: PPUSH
15672: CALL_OW 12
15676: PLUS
15677: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15678: LD_ADDR_VAR 0 7
15682: PUSH
15683: LD_VAR 0 5
15687: PUSH
15688: LD_INT 1
15690: NEG
15691: PPUSH
15692: LD_INT 1
15694: PPUSH
15695: CALL_OW 12
15699: PLUS
15700: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15701: LD_VAR 0 6
15705: PPUSH
15706: LD_VAR 0 7
15710: PPUSH
15711: CALL_OW 488
15715: NOT
15716: IFFALSE 15738
// begin _x := x ;
15718: LD_ADDR_VAR 0 6
15722: PUSH
15723: LD_VAR 0 4
15727: ST_TO_ADDR
// _y := y ;
15728: LD_ADDR_VAR 0 7
15732: PUSH
15733: LD_VAR 0 5
15737: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15738: LD_ADDR_VAR 0 3
15742: PUSH
15743: LD_INT 1
15745: PPUSH
15746: LD_VAR 0 14
15750: PPUSH
15751: CALL_OW 12
15755: ST_TO_ADDR
// case i of 1 :
15756: LD_VAR 0 3
15760: PUSH
15761: LD_INT 1
15763: DOUBLE
15764: EQUAL
15765: IFTRUE 15769
15767: GO 15786
15769: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_VAR 0 10
15779: PPUSH
15780: CALL_OW 115
15784: GO 15847
15786: LD_INT 2
15788: DOUBLE
15789: EQUAL
15790: IFTRUE 15794
15792: GO 15816
15794: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15795: LD_VAR 0 1
15799: PPUSH
15800: LD_VAR 0 6
15804: PPUSH
15805: LD_VAR 0 7
15809: PPUSH
15810: CALL_OW 153
15814: GO 15847
15816: LD_INT 3
15818: DOUBLE
15819: EQUAL
15820: IFTRUE 15824
15822: GO 15846
15824: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15825: LD_VAR 0 1
15829: PPUSH
15830: LD_VAR 0 6
15834: PPUSH
15835: LD_VAR 0 7
15839: PPUSH
15840: CALL_OW 154
15844: GO 15847
15846: POP
// end ;
15847: LD_VAR 0 2
15851: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15852: LD_INT 0
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
15858: PPUSH
15859: PPUSH
// if not unit or not building then
15860: LD_VAR 0 1
15864: NOT
15865: PUSH
15866: LD_VAR 0 2
15870: NOT
15871: OR
15872: IFFALSE 15876
// exit ;
15874: GO 16034
// x := GetX ( building ) ;
15876: LD_ADDR_VAR 0 5
15880: PUSH
15881: LD_VAR 0 2
15885: PPUSH
15886: CALL_OW 250
15890: ST_TO_ADDR
// y := GetY ( building ) ;
15891: LD_ADDR_VAR 0 6
15895: PUSH
15896: LD_VAR 0 2
15900: PPUSH
15901: CALL_OW 251
15905: ST_TO_ADDR
// for i = 0 to 5 do
15906: LD_ADDR_VAR 0 4
15910: PUSH
15911: DOUBLE
15912: LD_INT 0
15914: DEC
15915: ST_TO_ADDR
15916: LD_INT 5
15918: PUSH
15919: FOR_TO
15920: IFFALSE 16032
// begin _x := ShiftX ( x , i , 3 ) ;
15922: LD_ADDR_VAR 0 7
15926: PUSH
15927: LD_VAR 0 5
15931: PPUSH
15932: LD_VAR 0 4
15936: PPUSH
15937: LD_INT 3
15939: PPUSH
15940: CALL_OW 272
15944: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15945: LD_ADDR_VAR 0 8
15949: PUSH
15950: LD_VAR 0 6
15954: PPUSH
15955: LD_VAR 0 4
15959: PPUSH
15960: LD_INT 3
15962: PPUSH
15963: CALL_OW 273
15967: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15968: LD_VAR 0 7
15972: PPUSH
15973: LD_VAR 0 8
15977: PPUSH
15978: CALL_OW 488
15982: NOT
15983: IFFALSE 15987
// continue ;
15985: GO 15919
// if HexInfo ( _x , _y ) = 0 then
15987: LD_VAR 0 7
15991: PPUSH
15992: LD_VAR 0 8
15996: PPUSH
15997: CALL_OW 428
16001: PUSH
16002: LD_INT 0
16004: EQUAL
16005: IFFALSE 16030
// begin ComMoveXY ( unit , _x , _y ) ;
16007: LD_VAR 0 1
16011: PPUSH
16012: LD_VAR 0 7
16016: PPUSH
16017: LD_VAR 0 8
16021: PPUSH
16022: CALL_OW 111
// exit ;
16026: POP
16027: POP
16028: GO 16034
// end ; end ;
16030: GO 15919
16032: POP
16033: POP
// end ;
16034: LD_VAR 0 3
16038: RET
// export function ScanBase ( side , base_area ) ; begin
16039: LD_INT 0
16041: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16042: LD_ADDR_VAR 0 3
16046: PUSH
16047: LD_VAR 0 2
16051: PPUSH
16052: LD_INT 81
16054: PUSH
16055: LD_VAR 0 1
16059: PUSH
16060: EMPTY
16061: LIST
16062: LIST
16063: PPUSH
16064: CALL_OW 70
16068: ST_TO_ADDR
// end ;
16069: LD_VAR 0 3
16073: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
16074: LD_INT 0
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
16080: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
16081: LD_VAR 0 1
16085: NOT
16086: PUSH
16087: LD_EXP 59
16091: PUSH
16092: LD_VAR 0 1
16096: ARRAY
16097: NOT
16098: OR
16099: PUSH
16100: LD_VAR 0 2
16104: NOT
16105: OR
16106: PUSH
16107: LD_VAR 0 3
16111: NOT
16112: OR
16113: IFFALSE 16117
// exit ;
16115: GO 16630
// side := mc_sides [ base ] ;
16117: LD_ADDR_VAR 0 6
16121: PUSH
16122: LD_EXP 85
16126: PUSH
16127: LD_VAR 0 1
16131: ARRAY
16132: ST_TO_ADDR
// if not side then
16133: LD_VAR 0 6
16137: NOT
16138: IFFALSE 16142
// exit ;
16140: GO 16630
// for i in solds do
16142: LD_ADDR_VAR 0 7
16146: PUSH
16147: LD_VAR 0 2
16151: PUSH
16152: FOR_IN
16153: IFFALSE 16214
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
16155: LD_VAR 0 7
16159: PPUSH
16160: CALL_OW 310
16164: PPUSH
16165: CALL_OW 266
16169: PUSH
16170: LD_INT 32
16172: PUSH
16173: LD_INT 31
16175: PUSH
16176: EMPTY
16177: LIST
16178: LIST
16179: IN
16180: IFFALSE 16200
// solds := solds diff i else
16182: LD_ADDR_VAR 0 2
16186: PUSH
16187: LD_VAR 0 2
16191: PUSH
16192: LD_VAR 0 7
16196: DIFF
16197: ST_TO_ADDR
16198: GO 16212
// SetTag ( i , 18 ) ;
16200: LD_VAR 0 7
16204: PPUSH
16205: LD_INT 18
16207: PPUSH
16208: CALL_OW 109
16212: GO 16152
16214: POP
16215: POP
// if not solds then
16216: LD_VAR 0 2
16220: NOT
16221: IFFALSE 16225
// exit ;
16223: GO 16630
// repeat wait ( 0 0$1 ) ;
16225: LD_INT 35
16227: PPUSH
16228: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
16232: LD_ADDR_VAR 0 5
16236: PUSH
16237: LD_VAR 0 6
16241: PPUSH
16242: LD_VAR 0 3
16246: PPUSH
16247: CALL 16039 0 2
16251: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16252: LD_EXP 59
16256: PUSH
16257: LD_VAR 0 1
16261: ARRAY
16262: NOT
16263: PUSH
16264: LD_EXP 59
16268: PUSH
16269: LD_VAR 0 1
16273: ARRAY
16274: PUSH
16275: EMPTY
16276: EQUAL
16277: OR
16278: IFFALSE 16315
// begin for i in solds do
16280: LD_ADDR_VAR 0 7
16284: PUSH
16285: LD_VAR 0 2
16289: PUSH
16290: FOR_IN
16291: IFFALSE 16304
// ComStop ( i ) ;
16293: LD_VAR 0 7
16297: PPUSH
16298: CALL_OW 141
16302: GO 16290
16304: POP
16305: POP
// solds := [ ] ;
16306: LD_ADDR_VAR 0 2
16310: PUSH
16311: EMPTY
16312: ST_TO_ADDR
// exit ;
16313: GO 16630
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
16315: LD_VAR 0 5
16319: NOT
16320: PUSH
16321: LD_VAR 0 5
16325: PUSH
16326: LD_INT 3
16328: GREATER
16329: OR
16330: PUSH
16331: LD_EXP 81
16335: PUSH
16336: LD_VAR 0 1
16340: ARRAY
16341: OR
16342: IFFALSE 16383
// begin for i in solds do
16344: LD_ADDR_VAR 0 7
16348: PUSH
16349: LD_VAR 0 2
16353: PUSH
16354: FOR_IN
16355: IFFALSE 16379
// if HasTask ( i ) then
16357: LD_VAR 0 7
16361: PPUSH
16362: CALL_OW 314
16366: IFFALSE 16377
// ComStop ( i ) ;
16368: LD_VAR 0 7
16372: PPUSH
16373: CALL_OW 141
16377: GO 16354
16379: POP
16380: POP
// break ;
16381: GO 16618
// end ; for i in solds do
16383: LD_ADDR_VAR 0 7
16387: PUSH
16388: LD_VAR 0 2
16392: PUSH
16393: FOR_IN
16394: IFFALSE 16610
// begin if IsInUnit ( i ) then
16396: LD_VAR 0 7
16400: PPUSH
16401: CALL_OW 310
16405: IFFALSE 16416
// ComExitBuilding ( i ) ;
16407: LD_VAR 0 7
16411: PPUSH
16412: CALL_OW 122
// if GetLives ( i ) > 333 then
16416: LD_VAR 0 7
16420: PPUSH
16421: CALL_OW 256
16425: PUSH
16426: LD_INT 333
16428: GREATER
16429: IFFALSE 16457
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16431: LD_VAR 0 7
16435: PPUSH
16436: LD_VAR 0 5
16440: PPUSH
16441: LD_VAR 0 7
16445: PPUSH
16446: CALL_OW 74
16450: PPUSH
16451: CALL_OW 115
16455: GO 16608
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
16457: LD_ADDR_VAR 0 8
16461: PUSH
16462: LD_EXP 59
16466: PUSH
16467: LD_VAR 0 1
16471: ARRAY
16472: PPUSH
16473: LD_INT 2
16475: PUSH
16476: LD_INT 30
16478: PUSH
16479: LD_INT 0
16481: PUSH
16482: EMPTY
16483: LIST
16484: LIST
16485: PUSH
16486: LD_INT 30
16488: PUSH
16489: LD_INT 1
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PUSH
16496: LD_INT 30
16498: PUSH
16499: LD_INT 6
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: LIST
16510: LIST
16511: PPUSH
16512: CALL_OW 72
16516: PPUSH
16517: LD_VAR 0 7
16521: PPUSH
16522: CALL_OW 74
16526: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16527: LD_VAR 0 7
16531: PPUSH
16532: LD_VAR 0 8
16536: PPUSH
16537: CALL_OW 250
16541: PPUSH
16542: LD_INT 3
16544: PPUSH
16545: LD_INT 5
16547: PPUSH
16548: CALL_OW 272
16552: PPUSH
16553: LD_VAR 0 8
16557: PPUSH
16558: CALL_OW 251
16562: PPUSH
16563: LD_INT 3
16565: PPUSH
16566: LD_INT 5
16568: PPUSH
16569: CALL_OW 273
16573: PPUSH
16574: CALL_OW 111
// SetTag ( i , 0 ) ;
16578: LD_VAR 0 7
16582: PPUSH
16583: LD_INT 0
16585: PPUSH
16586: CALL_OW 109
// solds := solds diff i ;
16590: LD_ADDR_VAR 0 2
16594: PUSH
16595: LD_VAR 0 2
16599: PUSH
16600: LD_VAR 0 7
16604: DIFF
16605: ST_TO_ADDR
// continue ;
16606: GO 16393
// end ; end ;
16608: GO 16393
16610: POP
16611: POP
// until solds ;
16612: LD_VAR 0 2
16616: IFFALSE 16225
// MC_Reset ( base , 18 ) ;
16618: LD_VAR 0 1
16622: PPUSH
16623: LD_INT 18
16625: PPUSH
16626: CALL 61662 0 2
// end ;
16630: LD_VAR 0 4
16634: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16635: LD_INT 0
16637: PPUSH
16638: PPUSH
16639: PPUSH
16640: PPUSH
16641: PPUSH
16642: PPUSH
16643: PPUSH
16644: PPUSH
16645: PPUSH
16646: PPUSH
16647: PPUSH
16648: PPUSH
16649: PPUSH
16650: PPUSH
16651: PPUSH
16652: PPUSH
16653: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16654: LD_ADDR_VAR 0 13
16658: PUSH
16659: LD_EXP 59
16663: PUSH
16664: LD_VAR 0 1
16668: ARRAY
16669: PPUSH
16670: LD_INT 25
16672: PUSH
16673: LD_INT 3
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PPUSH
16680: CALL_OW 72
16684: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16685: LD_EXP 99
16689: PUSH
16690: LD_VAR 0 1
16694: ARRAY
16695: IFFALSE 16719
// mechs := mechs diff mc_remote_driver [ base ] ;
16697: LD_ADDR_VAR 0 13
16701: PUSH
16702: LD_VAR 0 13
16706: PUSH
16707: LD_EXP 99
16711: PUSH
16712: LD_VAR 0 1
16716: ARRAY
16717: DIFF
16718: ST_TO_ADDR
// for i in mechs do
16719: LD_ADDR_VAR 0 5
16723: PUSH
16724: LD_VAR 0 13
16728: PUSH
16729: FOR_IN
16730: IFFALSE 16765
// if GetTag ( i ) > 0 then
16732: LD_VAR 0 5
16736: PPUSH
16737: CALL_OW 110
16741: PUSH
16742: LD_INT 0
16744: GREATER
16745: IFFALSE 16763
// mechs := mechs diff i ;
16747: LD_ADDR_VAR 0 13
16751: PUSH
16752: LD_VAR 0 13
16756: PUSH
16757: LD_VAR 0 5
16761: DIFF
16762: ST_TO_ADDR
16763: GO 16729
16765: POP
16766: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16767: LD_ADDR_VAR 0 9
16771: PUSH
16772: LD_EXP 59
16776: PUSH
16777: LD_VAR 0 1
16781: ARRAY
16782: PPUSH
16783: LD_INT 2
16785: PUSH
16786: LD_INT 25
16788: PUSH
16789: LD_INT 1
16791: PUSH
16792: EMPTY
16793: LIST
16794: LIST
16795: PUSH
16796: LD_INT 25
16798: PUSH
16799: LD_INT 5
16801: PUSH
16802: EMPTY
16803: LIST
16804: LIST
16805: PUSH
16806: LD_INT 25
16808: PUSH
16809: LD_INT 8
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: PUSH
16816: LD_INT 25
16818: PUSH
16819: LD_INT 9
16821: PUSH
16822: EMPTY
16823: LIST
16824: LIST
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: LIST
16830: LIST
16831: LIST
16832: PPUSH
16833: CALL_OW 72
16837: ST_TO_ADDR
// if not defenders and not solds then
16838: LD_VAR 0 2
16842: NOT
16843: PUSH
16844: LD_VAR 0 9
16848: NOT
16849: AND
16850: IFFALSE 16854
// exit ;
16852: GO 18480
// depot_under_attack := false ;
16854: LD_ADDR_VAR 0 17
16858: PUSH
16859: LD_INT 0
16861: ST_TO_ADDR
// sold_defenders := [ ] ;
16862: LD_ADDR_VAR 0 18
16866: PUSH
16867: EMPTY
16868: ST_TO_ADDR
// if mechs then
16869: LD_VAR 0 13
16873: IFFALSE 17002
// for i in defenders do
16875: LD_ADDR_VAR 0 5
16879: PUSH
16880: LD_VAR 0 2
16884: PUSH
16885: FOR_IN
16886: IFFALSE 17000
// begin SetTag ( i , 20 ) ;
16888: LD_VAR 0 5
16892: PPUSH
16893: LD_INT 20
16895: PPUSH
16896: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16900: LD_VAR 0 5
16904: PPUSH
16905: CALL_OW 263
16909: PUSH
16910: LD_INT 1
16912: EQUAL
16913: PUSH
16914: LD_VAR 0 5
16918: PPUSH
16919: CALL_OW 311
16923: NOT
16924: AND
16925: PUSH
16926: LD_VAR 0 13
16930: AND
16931: IFFALSE 16998
// begin un := mechs [ 1 ] ;
16933: LD_ADDR_VAR 0 11
16937: PUSH
16938: LD_VAR 0 13
16942: PUSH
16943: LD_INT 1
16945: ARRAY
16946: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16947: LD_VAR 0 11
16951: PPUSH
16952: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16956: LD_VAR 0 11
16960: PPUSH
16961: LD_VAR 0 5
16965: PPUSH
16966: CALL_OW 180
// SetTag ( un , 19 ) ;
16970: LD_VAR 0 11
16974: PPUSH
16975: LD_INT 19
16977: PPUSH
16978: CALL_OW 109
// mechs := mechs diff un ;
16982: LD_ADDR_VAR 0 13
16986: PUSH
16987: LD_VAR 0 13
16991: PUSH
16992: LD_VAR 0 11
16996: DIFF
16997: ST_TO_ADDR
// end ; end ;
16998: GO 16885
17000: POP
17001: POP
// if solds then
17002: LD_VAR 0 9
17006: IFFALSE 17065
// for i in solds do
17008: LD_ADDR_VAR 0 5
17012: PUSH
17013: LD_VAR 0 9
17017: PUSH
17018: FOR_IN
17019: IFFALSE 17063
// if not GetTag ( i ) then
17021: LD_VAR 0 5
17025: PPUSH
17026: CALL_OW 110
17030: NOT
17031: IFFALSE 17061
// begin defenders := defenders union i ;
17033: LD_ADDR_VAR 0 2
17037: PUSH
17038: LD_VAR 0 2
17042: PUSH
17043: LD_VAR 0 5
17047: UNION
17048: ST_TO_ADDR
// SetTag ( i , 18 ) ;
17049: LD_VAR 0 5
17053: PPUSH
17054: LD_INT 18
17056: PPUSH
17057: CALL_OW 109
// end ;
17061: GO 17018
17063: POP
17064: POP
// repeat wait ( 0 0$1 ) ;
17065: LD_INT 35
17067: PPUSH
17068: CALL_OW 67
// enemy := mc_scan [ base ] ;
17072: LD_ADDR_VAR 0 3
17076: PUSH
17077: LD_EXP 82
17081: PUSH
17082: LD_VAR 0 1
17086: ARRAY
17087: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
17088: LD_EXP 59
17092: PUSH
17093: LD_VAR 0 1
17097: ARRAY
17098: NOT
17099: PUSH
17100: LD_EXP 59
17104: PUSH
17105: LD_VAR 0 1
17109: ARRAY
17110: PUSH
17111: EMPTY
17112: EQUAL
17113: OR
17114: IFFALSE 17151
// begin for i in defenders do
17116: LD_ADDR_VAR 0 5
17120: PUSH
17121: LD_VAR 0 2
17125: PUSH
17126: FOR_IN
17127: IFFALSE 17140
// ComStop ( i ) ;
17129: LD_VAR 0 5
17133: PPUSH
17134: CALL_OW 141
17138: GO 17126
17140: POP
17141: POP
// defenders := [ ] ;
17142: LD_ADDR_VAR 0 2
17146: PUSH
17147: EMPTY
17148: ST_TO_ADDR
// exit ;
17149: GO 18480
// end ; for i in defenders do
17151: LD_ADDR_VAR 0 5
17155: PUSH
17156: LD_VAR 0 2
17160: PUSH
17161: FOR_IN
17162: IFFALSE 17980
// begin e := NearestUnitToUnit ( enemy , i ) ;
17164: LD_ADDR_VAR 0 14
17168: PUSH
17169: LD_VAR 0 3
17173: PPUSH
17174: LD_VAR 0 5
17178: PPUSH
17179: CALL_OW 74
17183: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
17184: LD_ADDR_VAR 0 8
17188: PUSH
17189: LD_EXP 59
17193: PUSH
17194: LD_VAR 0 1
17198: ARRAY
17199: PPUSH
17200: LD_INT 2
17202: PUSH
17203: LD_INT 30
17205: PUSH
17206: LD_INT 0
17208: PUSH
17209: EMPTY
17210: LIST
17211: LIST
17212: PUSH
17213: LD_INT 30
17215: PUSH
17216: LD_INT 1
17218: PUSH
17219: EMPTY
17220: LIST
17221: LIST
17222: PUSH
17223: EMPTY
17224: LIST
17225: LIST
17226: LIST
17227: PPUSH
17228: CALL_OW 72
17232: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
17233: LD_ADDR_VAR 0 17
17237: PUSH
17238: LD_VAR 0 8
17242: NOT
17243: PUSH
17244: LD_VAR 0 8
17248: PPUSH
17249: LD_INT 3
17251: PUSH
17252: LD_INT 24
17254: PUSH
17255: LD_INT 600
17257: PUSH
17258: EMPTY
17259: LIST
17260: LIST
17261: PUSH
17262: EMPTY
17263: LIST
17264: LIST
17265: PPUSH
17266: CALL_OW 72
17270: OR
17271: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
17272: LD_VAR 0 5
17276: PPUSH
17277: CALL_OW 247
17281: PUSH
17282: LD_INT 2
17284: DOUBLE
17285: EQUAL
17286: IFTRUE 17290
17288: GO 17686
17290: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
17291: LD_VAR 0 5
17295: PPUSH
17296: CALL_OW 256
17300: PUSH
17301: LD_INT 650
17303: GREATER
17304: PUSH
17305: LD_VAR 0 5
17309: PPUSH
17310: LD_VAR 0 14
17314: PPUSH
17315: CALL_OW 296
17319: PUSH
17320: LD_INT 40
17322: LESS
17323: PUSH
17324: LD_VAR 0 14
17328: PPUSH
17329: LD_EXP 84
17333: PUSH
17334: LD_VAR 0 1
17338: ARRAY
17339: PPUSH
17340: CALL_OW 308
17344: OR
17345: AND
17346: IFFALSE 17468
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
17348: LD_VAR 0 5
17352: PPUSH
17353: CALL_OW 262
17357: PUSH
17358: LD_INT 1
17360: EQUAL
17361: PUSH
17362: LD_VAR 0 5
17366: PPUSH
17367: CALL_OW 261
17371: PUSH
17372: LD_INT 30
17374: LESS
17375: AND
17376: PUSH
17377: LD_VAR 0 8
17381: AND
17382: IFFALSE 17452
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
17384: LD_VAR 0 5
17388: PPUSH
17389: LD_VAR 0 8
17393: PPUSH
17394: LD_VAR 0 5
17398: PPUSH
17399: CALL_OW 74
17403: PPUSH
17404: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
17408: LD_VAR 0 5
17412: PPUSH
17413: LD_VAR 0 8
17417: PPUSH
17418: LD_VAR 0 5
17422: PPUSH
17423: CALL_OW 74
17427: PPUSH
17428: CALL_OW 296
17432: PUSH
17433: LD_INT 6
17435: LESS
17436: IFFALSE 17450
// SetFuel ( i , 100 ) ;
17438: LD_VAR 0 5
17442: PPUSH
17443: LD_INT 100
17445: PPUSH
17446: CALL_OW 240
// end else
17450: GO 17466
// ComAttackUnit ( i , e ) ;
17452: LD_VAR 0 5
17456: PPUSH
17457: LD_VAR 0 14
17461: PPUSH
17462: CALL_OW 115
// end else
17466: GO 17569
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
17468: LD_VAR 0 14
17472: PPUSH
17473: LD_EXP 84
17477: PUSH
17478: LD_VAR 0 1
17482: ARRAY
17483: PPUSH
17484: CALL_OW 308
17488: NOT
17489: PUSH
17490: LD_VAR 0 5
17494: PPUSH
17495: LD_VAR 0 14
17499: PPUSH
17500: CALL_OW 296
17504: PUSH
17505: LD_INT 40
17507: GREATEREQUAL
17508: AND
17509: PUSH
17510: LD_VAR 0 5
17514: PPUSH
17515: CALL_OW 256
17519: PUSH
17520: LD_INT 650
17522: LESSEQUAL
17523: OR
17524: PUSH
17525: LD_VAR 0 5
17529: PPUSH
17530: LD_EXP 83
17534: PUSH
17535: LD_VAR 0 1
17539: ARRAY
17540: PPUSH
17541: CALL_OW 308
17545: NOT
17546: AND
17547: IFFALSE 17569
// ComMoveToArea ( i , mc_parking [ base ] ) ;
17549: LD_VAR 0 5
17553: PPUSH
17554: LD_EXP 83
17558: PUSH
17559: LD_VAR 0 1
17563: ARRAY
17564: PPUSH
17565: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
17569: LD_VAR 0 5
17573: PPUSH
17574: CALL_OW 256
17578: PUSH
17579: LD_INT 998
17581: LESS
17582: PUSH
17583: LD_VAR 0 5
17587: PPUSH
17588: CALL_OW 263
17592: PUSH
17593: LD_INT 1
17595: EQUAL
17596: AND
17597: PUSH
17598: LD_VAR 0 5
17602: PPUSH
17603: CALL_OW 311
17607: AND
17608: PUSH
17609: LD_VAR 0 5
17613: PPUSH
17614: LD_EXP 83
17618: PUSH
17619: LD_VAR 0 1
17623: ARRAY
17624: PPUSH
17625: CALL_OW 308
17629: AND
17630: IFFALSE 17684
// begin mech := IsDrivenBy ( i ) ;
17632: LD_ADDR_VAR 0 10
17636: PUSH
17637: LD_VAR 0 5
17641: PPUSH
17642: CALL_OW 311
17646: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
17647: LD_VAR 0 10
17651: PPUSH
17652: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
17656: LD_VAR 0 10
17660: PPUSH
17661: LD_VAR 0 5
17665: PPUSH
17666: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
17670: LD_VAR 0 10
17674: PPUSH
17675: LD_VAR 0 5
17679: PPUSH
17680: CALL_OW 180
// end ; end ; unit_human :
17684: GO 17951
17686: LD_INT 1
17688: DOUBLE
17689: EQUAL
17690: IFTRUE 17694
17692: GO 17950
17694: POP
// begin b := IsInUnit ( i ) ;
17695: LD_ADDR_VAR 0 19
17699: PUSH
17700: LD_VAR 0 5
17704: PPUSH
17705: CALL_OW 310
17709: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17710: LD_ADDR_VAR 0 20
17714: PUSH
17715: LD_VAR 0 19
17719: NOT
17720: PUSH
17721: LD_VAR 0 19
17725: PPUSH
17726: CALL_OW 266
17730: PUSH
17731: LD_INT 32
17733: PUSH
17734: LD_INT 31
17736: PUSH
17737: EMPTY
17738: LIST
17739: LIST
17740: IN
17741: OR
17742: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17743: LD_VAR 0 17
17747: PUSH
17748: LD_VAR 0 2
17752: PPUSH
17753: LD_INT 21
17755: PUSH
17756: LD_INT 2
17758: PUSH
17759: EMPTY
17760: LIST
17761: LIST
17762: PPUSH
17763: CALL_OW 72
17767: PUSH
17768: LD_INT 1
17770: LESSEQUAL
17771: OR
17772: PUSH
17773: LD_VAR 0 20
17777: AND
17778: PUSH
17779: LD_VAR 0 5
17783: PUSH
17784: LD_VAR 0 18
17788: IN
17789: NOT
17790: AND
17791: IFFALSE 17884
// begin if b then
17793: LD_VAR 0 19
17797: IFFALSE 17846
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17799: LD_VAR 0 19
17803: PPUSH
17804: LD_VAR 0 3
17808: PPUSH
17809: LD_VAR 0 19
17813: PPUSH
17814: CALL_OW 74
17818: PPUSH
17819: CALL_OW 296
17823: PUSH
17824: LD_INT 10
17826: LESS
17827: PUSH
17828: LD_VAR 0 19
17832: PPUSH
17833: CALL_OW 461
17837: PUSH
17838: LD_INT 7
17840: NONEQUAL
17841: AND
17842: IFFALSE 17846
// continue ;
17844: GO 17161
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17846: LD_ADDR_VAR 0 18
17850: PUSH
17851: LD_VAR 0 18
17855: PPUSH
17856: LD_VAR 0 18
17860: PUSH
17861: LD_INT 1
17863: PLUS
17864: PPUSH
17865: LD_VAR 0 5
17869: PPUSH
17870: CALL_OW 1
17874: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17875: LD_VAR 0 5
17879: PPUSH
17880: CALL_OW 122
// end ; if sold_defenders then
17884: LD_VAR 0 18
17888: IFFALSE 17948
// if i in sold_defenders then
17890: LD_VAR 0 5
17894: PUSH
17895: LD_VAR 0 18
17899: IN
17900: IFFALSE 17948
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17902: LD_VAR 0 5
17906: PPUSH
17907: CALL_OW 314
17911: NOT
17912: PUSH
17913: LD_VAR 0 5
17917: PPUSH
17918: LD_VAR 0 14
17922: PPUSH
17923: CALL_OW 296
17927: PUSH
17928: LD_INT 30
17930: LESS
17931: AND
17932: IFFALSE 17948
// ComAttackUnit ( i , e ) ;
17934: LD_VAR 0 5
17938: PPUSH
17939: LD_VAR 0 14
17943: PPUSH
17944: CALL_OW 115
// end ; end ; end ;
17948: GO 17951
17950: POP
// if IsDead ( i ) then
17951: LD_VAR 0 5
17955: PPUSH
17956: CALL_OW 301
17960: IFFALSE 17978
// defenders := defenders diff i ;
17962: LD_ADDR_VAR 0 2
17966: PUSH
17967: LD_VAR 0 2
17971: PUSH
17972: LD_VAR 0 5
17976: DIFF
17977: ST_TO_ADDR
// end ;
17978: GO 17161
17980: POP
17981: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
17982: LD_VAR 0 3
17986: NOT
17987: PUSH
17988: LD_VAR 0 2
17992: NOT
17993: OR
17994: PUSH
17995: LD_EXP 59
17999: PUSH
18000: LD_VAR 0 1
18004: ARRAY
18005: NOT
18006: OR
18007: IFFALSE 17065
// MC_Reset ( base , 18 ) ;
18009: LD_VAR 0 1
18013: PPUSH
18014: LD_INT 18
18016: PPUSH
18017: CALL 61662 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
18021: LD_ADDR_VAR 0 2
18025: PUSH
18026: LD_VAR 0 2
18030: PUSH
18031: LD_VAR 0 2
18035: PPUSH
18036: LD_INT 2
18038: PUSH
18039: LD_INT 25
18041: PUSH
18042: LD_INT 1
18044: PUSH
18045: EMPTY
18046: LIST
18047: LIST
18048: PUSH
18049: LD_INT 25
18051: PUSH
18052: LD_INT 5
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: PUSH
18059: LD_INT 25
18061: PUSH
18062: LD_INT 8
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: LD_INT 25
18071: PUSH
18072: LD_INT 9
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: PUSH
18079: EMPTY
18080: LIST
18081: LIST
18082: LIST
18083: LIST
18084: LIST
18085: PPUSH
18086: CALL_OW 72
18090: DIFF
18091: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
18092: LD_VAR 0 3
18096: NOT
18097: PUSH
18098: LD_VAR 0 2
18102: PPUSH
18103: LD_INT 21
18105: PUSH
18106: LD_INT 2
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: PPUSH
18113: CALL_OW 72
18117: AND
18118: IFFALSE 18456
// begin tmp := FilterByTag ( defenders , 19 ) ;
18120: LD_ADDR_VAR 0 12
18124: PUSH
18125: LD_VAR 0 2
18129: PPUSH
18130: LD_INT 19
18132: PPUSH
18133: CALL 54919 0 2
18137: ST_TO_ADDR
// if tmp then
18138: LD_VAR 0 12
18142: IFFALSE 18212
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
18144: LD_ADDR_VAR 0 12
18148: PUSH
18149: LD_VAR 0 12
18153: PPUSH
18154: LD_INT 25
18156: PUSH
18157: LD_INT 3
18159: PUSH
18160: EMPTY
18161: LIST
18162: LIST
18163: PPUSH
18164: CALL_OW 72
18168: ST_TO_ADDR
// if tmp then
18169: LD_VAR 0 12
18173: IFFALSE 18212
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
18175: LD_ADDR_EXP 71
18179: PUSH
18180: LD_EXP 71
18184: PPUSH
18185: LD_VAR 0 1
18189: PPUSH
18190: LD_EXP 71
18194: PUSH
18195: LD_VAR 0 1
18199: ARRAY
18200: PUSH
18201: LD_VAR 0 12
18205: UNION
18206: PPUSH
18207: CALL_OW 1
18211: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
18212: LD_VAR 0 1
18216: PPUSH
18217: LD_INT 19
18219: PPUSH
18220: CALL 61662 0 2
// repeat wait ( 0 0$1 ) ;
18224: LD_INT 35
18226: PPUSH
18227: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
18231: LD_EXP 59
18235: PUSH
18236: LD_VAR 0 1
18240: ARRAY
18241: NOT
18242: PUSH
18243: LD_EXP 59
18247: PUSH
18248: LD_VAR 0 1
18252: ARRAY
18253: PUSH
18254: EMPTY
18255: EQUAL
18256: OR
18257: IFFALSE 18294
// begin for i in defenders do
18259: LD_ADDR_VAR 0 5
18263: PUSH
18264: LD_VAR 0 2
18268: PUSH
18269: FOR_IN
18270: IFFALSE 18283
// ComStop ( i ) ;
18272: LD_VAR 0 5
18276: PPUSH
18277: CALL_OW 141
18281: GO 18269
18283: POP
18284: POP
// defenders := [ ] ;
18285: LD_ADDR_VAR 0 2
18289: PUSH
18290: EMPTY
18291: ST_TO_ADDR
// exit ;
18292: GO 18480
// end ; for i in defenders do
18294: LD_ADDR_VAR 0 5
18298: PUSH
18299: LD_VAR 0 2
18303: PUSH
18304: FOR_IN
18305: IFFALSE 18394
// begin if not IsInArea ( i , mc_parking [ base ] ) then
18307: LD_VAR 0 5
18311: PPUSH
18312: LD_EXP 83
18316: PUSH
18317: LD_VAR 0 1
18321: ARRAY
18322: PPUSH
18323: CALL_OW 308
18327: NOT
18328: IFFALSE 18352
// ComMoveToArea ( i , mc_parking [ base ] ) else
18330: LD_VAR 0 5
18334: PPUSH
18335: LD_EXP 83
18339: PUSH
18340: LD_VAR 0 1
18344: ARRAY
18345: PPUSH
18346: CALL_OW 113
18350: GO 18392
// if GetControl ( i ) = control_manual then
18352: LD_VAR 0 5
18356: PPUSH
18357: CALL_OW 263
18361: PUSH
18362: LD_INT 1
18364: EQUAL
18365: IFFALSE 18392
// if IsDrivenBy ( i ) then
18367: LD_VAR 0 5
18371: PPUSH
18372: CALL_OW 311
18376: IFFALSE 18392
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
18378: LD_VAR 0 5
18382: PPUSH
18383: CALL_OW 311
18387: PPUSH
18388: CALL_OW 121
// end ;
18392: GO 18304
18394: POP
18395: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
18396: LD_VAR 0 2
18400: PPUSH
18401: LD_INT 95
18403: PUSH
18404: LD_EXP 83
18408: PUSH
18409: LD_VAR 0 1
18413: ARRAY
18414: PUSH
18415: EMPTY
18416: LIST
18417: LIST
18418: PPUSH
18419: CALL_OW 72
18423: PUSH
18424: LD_VAR 0 2
18428: EQUAL
18429: PUSH
18430: LD_EXP 82
18434: PUSH
18435: LD_VAR 0 1
18439: ARRAY
18440: OR
18441: PUSH
18442: LD_EXP 59
18446: PUSH
18447: LD_VAR 0 1
18451: ARRAY
18452: NOT
18453: OR
18454: IFFALSE 18224
// end ; MC_Reset ( base , 19 ) ;
18456: LD_VAR 0 1
18460: PPUSH
18461: LD_INT 19
18463: PPUSH
18464: CALL 61662 0 2
// MC_Reset ( base , 20 ) ;
18468: LD_VAR 0 1
18472: PPUSH
18473: LD_INT 20
18475: PPUSH
18476: CALL 61662 0 2
// end ;
18480: LD_VAR 0 4
18484: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18485: LD_INT 0
18487: PPUSH
18488: PPUSH
18489: PPUSH
18490: PPUSH
// result := false ;
18491: LD_ADDR_VAR 0 2
18495: PUSH
18496: LD_INT 0
18498: ST_TO_ADDR
// side := GetSide ( unit ) ;
18499: LD_ADDR_VAR 0 3
18503: PUSH
18504: LD_VAR 0 1
18508: PPUSH
18509: CALL_OW 255
18513: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18514: LD_ADDR_VAR 0 4
18518: PUSH
18519: LD_VAR 0 1
18523: PPUSH
18524: CALL_OW 248
18528: ST_TO_ADDR
// case nat of 1 :
18529: LD_VAR 0 4
18533: PUSH
18534: LD_INT 1
18536: DOUBLE
18537: EQUAL
18538: IFTRUE 18542
18540: GO 18553
18542: POP
// tech := tech_lassight ; 2 :
18543: LD_ADDR_VAR 0 5
18547: PUSH
18548: LD_INT 12
18550: ST_TO_ADDR
18551: GO 18592
18553: LD_INT 2
18555: DOUBLE
18556: EQUAL
18557: IFTRUE 18561
18559: GO 18572
18561: POP
// tech := tech_mortar ; 3 :
18562: LD_ADDR_VAR 0 5
18566: PUSH
18567: LD_INT 41
18569: ST_TO_ADDR
18570: GO 18592
18572: LD_INT 3
18574: DOUBLE
18575: EQUAL
18576: IFTRUE 18580
18578: GO 18591
18580: POP
// tech := tech_bazooka ; end ;
18581: LD_ADDR_VAR 0 5
18585: PUSH
18586: LD_INT 44
18588: ST_TO_ADDR
18589: GO 18592
18591: POP
// if Researched ( side , tech ) then
18592: LD_VAR 0 3
18596: PPUSH
18597: LD_VAR 0 5
18601: PPUSH
18602: CALL_OW 325
18606: IFFALSE 18633
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18608: LD_ADDR_VAR 0 2
18612: PUSH
18613: LD_INT 5
18615: PUSH
18616: LD_INT 8
18618: PUSH
18619: LD_INT 9
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: LIST
18626: PUSH
18627: LD_VAR 0 4
18631: ARRAY
18632: ST_TO_ADDR
// end ;
18633: LD_VAR 0 2
18637: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18638: LD_INT 0
18640: PPUSH
18641: PPUSH
18642: PPUSH
// if not mines then
18643: LD_VAR 0 2
18647: NOT
18648: IFFALSE 18652
// exit ;
18650: GO 18796
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18652: LD_ADDR_VAR 0 5
18656: PUSH
18657: LD_INT 81
18659: PUSH
18660: LD_VAR 0 1
18664: PUSH
18665: EMPTY
18666: LIST
18667: LIST
18668: PUSH
18669: LD_INT 3
18671: PUSH
18672: LD_INT 21
18674: PUSH
18675: LD_INT 3
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: PUSH
18682: EMPTY
18683: LIST
18684: LIST
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: PPUSH
18690: CALL_OW 69
18694: ST_TO_ADDR
// for i in mines do
18695: LD_ADDR_VAR 0 4
18699: PUSH
18700: LD_VAR 0 2
18704: PUSH
18705: FOR_IN
18706: IFFALSE 18794
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18708: LD_VAR 0 4
18712: PUSH
18713: LD_INT 1
18715: ARRAY
18716: PPUSH
18717: LD_VAR 0 4
18721: PUSH
18722: LD_INT 2
18724: ARRAY
18725: PPUSH
18726: CALL_OW 458
18730: NOT
18731: IFFALSE 18735
// continue ;
18733: GO 18705
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18735: LD_VAR 0 4
18739: PUSH
18740: LD_INT 1
18742: ARRAY
18743: PPUSH
18744: LD_VAR 0 4
18748: PUSH
18749: LD_INT 2
18751: ARRAY
18752: PPUSH
18753: CALL_OW 428
18757: PUSH
18758: LD_VAR 0 5
18762: IN
18763: IFFALSE 18792
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18765: LD_VAR 0 4
18769: PUSH
18770: LD_INT 1
18772: ARRAY
18773: PPUSH
18774: LD_VAR 0 4
18778: PUSH
18779: LD_INT 2
18781: ARRAY
18782: PPUSH
18783: LD_VAR 0 1
18787: PPUSH
18788: CALL_OW 456
// end ;
18792: GO 18705
18794: POP
18795: POP
// end ;
18796: LD_VAR 0 3
18800: RET
// export function Count ( array ) ; var i ; begin
18801: LD_INT 0
18803: PPUSH
18804: PPUSH
// result := 0 ;
18805: LD_ADDR_VAR 0 2
18809: PUSH
18810: LD_INT 0
18812: ST_TO_ADDR
// for i in array do
18813: LD_ADDR_VAR 0 3
18817: PUSH
18818: LD_VAR 0 1
18822: PUSH
18823: FOR_IN
18824: IFFALSE 18848
// if i then
18826: LD_VAR 0 3
18830: IFFALSE 18846
// result := result + 1 ;
18832: LD_ADDR_VAR 0 2
18836: PUSH
18837: LD_VAR 0 2
18841: PUSH
18842: LD_INT 1
18844: PLUS
18845: ST_TO_ADDR
18846: GO 18823
18848: POP
18849: POP
// end ;
18850: LD_VAR 0 2
18854: RET
// export function IsEmpty ( building ) ; begin
18855: LD_INT 0
18857: PPUSH
// if not building then
18858: LD_VAR 0 1
18862: NOT
18863: IFFALSE 18867
// exit ;
18865: GO 18910
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18867: LD_ADDR_VAR 0 2
18871: PUSH
18872: LD_VAR 0 1
18876: PUSH
18877: LD_INT 22
18879: PUSH
18880: LD_VAR 0 1
18884: PPUSH
18885: CALL_OW 255
18889: PUSH
18890: EMPTY
18891: LIST
18892: LIST
18893: PUSH
18894: LD_INT 58
18896: PUSH
18897: EMPTY
18898: LIST
18899: PUSH
18900: EMPTY
18901: LIST
18902: LIST
18903: PPUSH
18904: CALL_OW 69
18908: IN
18909: ST_TO_ADDR
// end ;
18910: LD_VAR 0 2
18914: RET
// export function IsNotFull ( building ) ; begin
18915: LD_INT 0
18917: PPUSH
// if not building then
18918: LD_VAR 0 1
18922: NOT
18923: IFFALSE 18927
// exit ;
18925: GO 18946
// result := UnitsInside ( building ) < 6 ;
18927: LD_ADDR_VAR 0 2
18931: PUSH
18932: LD_VAR 0 1
18936: PPUSH
18937: CALL_OW 313
18941: PUSH
18942: LD_INT 6
18944: LESS
18945: ST_TO_ADDR
// end ;
18946: LD_VAR 0 2
18950: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18951: LD_INT 0
18953: PPUSH
18954: PPUSH
18955: PPUSH
18956: PPUSH
// tmp := [ ] ;
18957: LD_ADDR_VAR 0 3
18961: PUSH
18962: EMPTY
18963: ST_TO_ADDR
// list := [ ] ;
18964: LD_ADDR_VAR 0 5
18968: PUSH
18969: EMPTY
18970: ST_TO_ADDR
// for i = 16 to 25 do
18971: LD_ADDR_VAR 0 4
18975: PUSH
18976: DOUBLE
18977: LD_INT 16
18979: DEC
18980: ST_TO_ADDR
18981: LD_INT 25
18983: PUSH
18984: FOR_TO
18985: IFFALSE 19058
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18987: LD_ADDR_VAR 0 3
18991: PUSH
18992: LD_VAR 0 3
18996: PUSH
18997: LD_INT 22
18999: PUSH
19000: LD_VAR 0 1
19004: PPUSH
19005: CALL_OW 255
19009: PUSH
19010: EMPTY
19011: LIST
19012: LIST
19013: PUSH
19014: LD_INT 91
19016: PUSH
19017: LD_VAR 0 1
19021: PUSH
19022: LD_INT 6
19024: PUSH
19025: EMPTY
19026: LIST
19027: LIST
19028: LIST
19029: PUSH
19030: LD_INT 30
19032: PUSH
19033: LD_VAR 0 4
19037: PUSH
19038: EMPTY
19039: LIST
19040: LIST
19041: PUSH
19042: EMPTY
19043: LIST
19044: LIST
19045: LIST
19046: PUSH
19047: EMPTY
19048: LIST
19049: PPUSH
19050: CALL_OW 69
19054: ADD
19055: ST_TO_ADDR
19056: GO 18984
19058: POP
19059: POP
// for i = 1 to tmp do
19060: LD_ADDR_VAR 0 4
19064: PUSH
19065: DOUBLE
19066: LD_INT 1
19068: DEC
19069: ST_TO_ADDR
19070: LD_VAR 0 3
19074: PUSH
19075: FOR_TO
19076: IFFALSE 19164
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
19078: LD_ADDR_VAR 0 5
19082: PUSH
19083: LD_VAR 0 5
19087: PUSH
19088: LD_VAR 0 3
19092: PUSH
19093: LD_VAR 0 4
19097: ARRAY
19098: PPUSH
19099: CALL_OW 266
19103: PUSH
19104: LD_VAR 0 3
19108: PUSH
19109: LD_VAR 0 4
19113: ARRAY
19114: PPUSH
19115: CALL_OW 250
19119: PUSH
19120: LD_VAR 0 3
19124: PUSH
19125: LD_VAR 0 4
19129: ARRAY
19130: PPUSH
19131: CALL_OW 251
19135: PUSH
19136: LD_VAR 0 3
19140: PUSH
19141: LD_VAR 0 4
19145: ARRAY
19146: PPUSH
19147: CALL_OW 254
19151: PUSH
19152: EMPTY
19153: LIST
19154: LIST
19155: LIST
19156: LIST
19157: PUSH
19158: EMPTY
19159: LIST
19160: ADD
19161: ST_TO_ADDR
19162: GO 19075
19164: POP
19165: POP
// result := list ;
19166: LD_ADDR_VAR 0 2
19170: PUSH
19171: LD_VAR 0 5
19175: ST_TO_ADDR
// end ;
19176: LD_VAR 0 2
19180: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19181: LD_INT 0
19183: PPUSH
19184: PPUSH
19185: PPUSH
19186: PPUSH
19187: PPUSH
19188: PPUSH
19189: PPUSH
// if not factory then
19190: LD_VAR 0 1
19194: NOT
19195: IFFALSE 19199
// exit ;
19197: GO 19792
// if control = control_apeman then
19199: LD_VAR 0 4
19203: PUSH
19204: LD_INT 5
19206: EQUAL
19207: IFFALSE 19316
// begin tmp := UnitsInside ( factory ) ;
19209: LD_ADDR_VAR 0 8
19213: PUSH
19214: LD_VAR 0 1
19218: PPUSH
19219: CALL_OW 313
19223: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
19224: LD_VAR 0 8
19228: PPUSH
19229: LD_INT 25
19231: PUSH
19232: LD_INT 12
19234: PUSH
19235: EMPTY
19236: LIST
19237: LIST
19238: PPUSH
19239: CALL_OW 72
19243: NOT
19244: IFFALSE 19254
// control := control_manual ;
19246: LD_ADDR_VAR 0 4
19250: PUSH
19251: LD_INT 1
19253: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
19254: LD_ADDR_VAR 0 8
19258: PUSH
19259: LD_VAR 0 1
19263: PPUSH
19264: CALL 18951 0 1
19268: ST_TO_ADDR
// if tmp then
19269: LD_VAR 0 8
19273: IFFALSE 19316
// begin for i in tmp do
19275: LD_ADDR_VAR 0 7
19279: PUSH
19280: LD_VAR 0 8
19284: PUSH
19285: FOR_IN
19286: IFFALSE 19314
// if i [ 1 ] = b_ext_radio then
19288: LD_VAR 0 7
19292: PUSH
19293: LD_INT 1
19295: ARRAY
19296: PUSH
19297: LD_INT 22
19299: EQUAL
19300: IFFALSE 19312
// begin control := control_remote ;
19302: LD_ADDR_VAR 0 4
19306: PUSH
19307: LD_INT 2
19309: ST_TO_ADDR
// break ;
19310: GO 19314
// end ;
19312: GO 19285
19314: POP
19315: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19316: LD_VAR 0 1
19320: PPUSH
19321: LD_VAR 0 2
19325: PPUSH
19326: LD_VAR 0 3
19330: PPUSH
19331: LD_VAR 0 4
19335: PPUSH
19336: LD_VAR 0 5
19340: PPUSH
19341: CALL_OW 448
19345: IFFALSE 19380
// begin result := [ chassis , engine , control , weapon ] ;
19347: LD_ADDR_VAR 0 6
19351: PUSH
19352: LD_VAR 0 2
19356: PUSH
19357: LD_VAR 0 3
19361: PUSH
19362: LD_VAR 0 4
19366: PUSH
19367: LD_VAR 0 5
19371: PUSH
19372: EMPTY
19373: LIST
19374: LIST
19375: LIST
19376: LIST
19377: ST_TO_ADDR
// exit ;
19378: GO 19792
// end ; _chassis := AvailableChassisList ( factory ) ;
19380: LD_ADDR_VAR 0 9
19384: PUSH
19385: LD_VAR 0 1
19389: PPUSH
19390: CALL_OW 475
19394: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19395: LD_ADDR_VAR 0 11
19399: PUSH
19400: LD_VAR 0 1
19404: PPUSH
19405: CALL_OW 476
19409: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19410: LD_ADDR_VAR 0 12
19414: PUSH
19415: LD_VAR 0 1
19419: PPUSH
19420: CALL_OW 477
19424: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19425: LD_ADDR_VAR 0 10
19429: PUSH
19430: LD_VAR 0 1
19434: PPUSH
19435: CALL_OW 478
19439: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19440: LD_VAR 0 9
19444: NOT
19445: PUSH
19446: LD_VAR 0 11
19450: NOT
19451: OR
19452: PUSH
19453: LD_VAR 0 12
19457: NOT
19458: OR
19459: PUSH
19460: LD_VAR 0 10
19464: NOT
19465: OR
19466: IFFALSE 19501
// begin result := [ chassis , engine , control , weapon ] ;
19468: LD_ADDR_VAR 0 6
19472: PUSH
19473: LD_VAR 0 2
19477: PUSH
19478: LD_VAR 0 3
19482: PUSH
19483: LD_VAR 0 4
19487: PUSH
19488: LD_VAR 0 5
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: ST_TO_ADDR
// exit ;
19499: GO 19792
// end ; if not chassis in _chassis then
19501: LD_VAR 0 2
19505: PUSH
19506: LD_VAR 0 9
19510: IN
19511: NOT
19512: IFFALSE 19538
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19514: LD_ADDR_VAR 0 2
19518: PUSH
19519: LD_VAR 0 9
19523: PUSH
19524: LD_INT 1
19526: PPUSH
19527: LD_VAR 0 9
19531: PPUSH
19532: CALL_OW 12
19536: ARRAY
19537: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19538: LD_VAR 0 2
19542: PPUSH
19543: LD_VAR 0 3
19547: PPUSH
19548: CALL 19797 0 2
19552: NOT
19553: IFFALSE 19612
// repeat engine := _engine [ 1 ] ;
19555: LD_ADDR_VAR 0 3
19559: PUSH
19560: LD_VAR 0 11
19564: PUSH
19565: LD_INT 1
19567: ARRAY
19568: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19569: LD_ADDR_VAR 0 11
19573: PUSH
19574: LD_VAR 0 11
19578: PPUSH
19579: LD_INT 1
19581: PPUSH
19582: CALL_OW 3
19586: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19587: LD_VAR 0 2
19591: PPUSH
19592: LD_VAR 0 3
19596: PPUSH
19597: CALL 19797 0 2
19601: PUSH
19602: LD_VAR 0 11
19606: PUSH
19607: EMPTY
19608: EQUAL
19609: OR
19610: IFFALSE 19555
// if not control in _control then
19612: LD_VAR 0 4
19616: PUSH
19617: LD_VAR 0 12
19621: IN
19622: NOT
19623: IFFALSE 19649
// control := _control [ rand ( 1 , _control ) ] ;
19625: LD_ADDR_VAR 0 4
19629: PUSH
19630: LD_VAR 0 12
19634: PUSH
19635: LD_INT 1
19637: PPUSH
19638: LD_VAR 0 12
19642: PPUSH
19643: CALL_OW 12
19647: ARRAY
19648: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19649: LD_VAR 0 2
19653: PPUSH
19654: LD_VAR 0 5
19658: PPUSH
19659: CALL 20017 0 2
19663: NOT
19664: IFFALSE 19723
// repeat weapon := _weapon [ 1 ] ;
19666: LD_ADDR_VAR 0 5
19670: PUSH
19671: LD_VAR 0 10
19675: PUSH
19676: LD_INT 1
19678: ARRAY
19679: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19680: LD_ADDR_VAR 0 10
19684: PUSH
19685: LD_VAR 0 10
19689: PPUSH
19690: LD_INT 1
19692: PPUSH
19693: CALL_OW 3
19697: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19698: LD_VAR 0 2
19702: PPUSH
19703: LD_VAR 0 5
19707: PPUSH
19708: CALL 20017 0 2
19712: PUSH
19713: LD_VAR 0 10
19717: PUSH
19718: EMPTY
19719: EQUAL
19720: OR
19721: IFFALSE 19666
// result := [ ] ;
19723: LD_ADDR_VAR 0 6
19727: PUSH
19728: EMPTY
19729: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19730: LD_VAR 0 1
19734: PPUSH
19735: LD_VAR 0 2
19739: PPUSH
19740: LD_VAR 0 3
19744: PPUSH
19745: LD_VAR 0 4
19749: PPUSH
19750: LD_VAR 0 5
19754: PPUSH
19755: CALL_OW 448
19759: IFFALSE 19792
// result := [ chassis , engine , control , weapon ] ;
19761: LD_ADDR_VAR 0 6
19765: PUSH
19766: LD_VAR 0 2
19770: PUSH
19771: LD_VAR 0 3
19775: PUSH
19776: LD_VAR 0 4
19780: PUSH
19781: LD_VAR 0 5
19785: PUSH
19786: EMPTY
19787: LIST
19788: LIST
19789: LIST
19790: LIST
19791: ST_TO_ADDR
// end ;
19792: LD_VAR 0 6
19796: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19797: LD_INT 0
19799: PPUSH
// if not chassis or not engine then
19800: LD_VAR 0 1
19804: NOT
19805: PUSH
19806: LD_VAR 0 2
19810: NOT
19811: OR
19812: IFFALSE 19816
// exit ;
19814: GO 20012
// case engine of engine_solar :
19816: LD_VAR 0 2
19820: PUSH
19821: LD_INT 2
19823: DOUBLE
19824: EQUAL
19825: IFTRUE 19829
19827: GO 19867
19829: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19830: LD_ADDR_VAR 0 3
19834: PUSH
19835: LD_INT 11
19837: PUSH
19838: LD_INT 12
19840: PUSH
19841: LD_INT 13
19843: PUSH
19844: LD_INT 14
19846: PUSH
19847: LD_INT 1
19849: PUSH
19850: LD_INT 2
19852: PUSH
19853: LD_INT 3
19855: PUSH
19856: EMPTY
19857: LIST
19858: LIST
19859: LIST
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: ST_TO_ADDR
19865: GO 19996
19867: LD_INT 1
19869: DOUBLE
19870: EQUAL
19871: IFTRUE 19875
19873: GO 19937
19875: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19876: LD_ADDR_VAR 0 3
19880: PUSH
19881: LD_INT 11
19883: PUSH
19884: LD_INT 12
19886: PUSH
19887: LD_INT 13
19889: PUSH
19890: LD_INT 14
19892: PUSH
19893: LD_INT 1
19895: PUSH
19896: LD_INT 2
19898: PUSH
19899: LD_INT 3
19901: PUSH
19902: LD_INT 4
19904: PUSH
19905: LD_INT 5
19907: PUSH
19908: LD_INT 21
19910: PUSH
19911: LD_INT 23
19913: PUSH
19914: LD_INT 22
19916: PUSH
19917: LD_INT 24
19919: PUSH
19920: EMPTY
19921: LIST
19922: LIST
19923: LIST
19924: LIST
19925: LIST
19926: LIST
19927: LIST
19928: LIST
19929: LIST
19930: LIST
19931: LIST
19932: LIST
19933: LIST
19934: ST_TO_ADDR
19935: GO 19996
19937: LD_INT 3
19939: DOUBLE
19940: EQUAL
19941: IFTRUE 19945
19943: GO 19995
19945: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19946: LD_ADDR_VAR 0 3
19950: PUSH
19951: LD_INT 13
19953: PUSH
19954: LD_INT 14
19956: PUSH
19957: LD_INT 2
19959: PUSH
19960: LD_INT 3
19962: PUSH
19963: LD_INT 4
19965: PUSH
19966: LD_INT 5
19968: PUSH
19969: LD_INT 21
19971: PUSH
19972: LD_INT 22
19974: PUSH
19975: LD_INT 23
19977: PUSH
19978: LD_INT 24
19980: PUSH
19981: EMPTY
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: ST_TO_ADDR
19993: GO 19996
19995: POP
// result := ( chassis in result ) ;
19996: LD_ADDR_VAR 0 3
20000: PUSH
20001: LD_VAR 0 1
20005: PUSH
20006: LD_VAR 0 3
20010: IN
20011: ST_TO_ADDR
// end ;
20012: LD_VAR 0 3
20016: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
20017: LD_INT 0
20019: PPUSH
// if not chassis or not weapon then
20020: LD_VAR 0 1
20024: NOT
20025: PUSH
20026: LD_VAR 0 2
20030: NOT
20031: OR
20032: IFFALSE 20036
// exit ;
20034: GO 21062
// case weapon of us_machine_gun :
20036: LD_VAR 0 2
20040: PUSH
20041: LD_INT 2
20043: DOUBLE
20044: EQUAL
20045: IFTRUE 20049
20047: GO 20079
20049: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
20050: LD_ADDR_VAR 0 3
20054: PUSH
20055: LD_INT 1
20057: PUSH
20058: LD_INT 2
20060: PUSH
20061: LD_INT 3
20063: PUSH
20064: LD_INT 4
20066: PUSH
20067: LD_INT 5
20069: PUSH
20070: EMPTY
20071: LIST
20072: LIST
20073: LIST
20074: LIST
20075: LIST
20076: ST_TO_ADDR
20077: GO 21046
20079: LD_INT 3
20081: DOUBLE
20082: EQUAL
20083: IFTRUE 20087
20085: GO 20117
20087: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
20088: LD_ADDR_VAR 0 3
20092: PUSH
20093: LD_INT 1
20095: PUSH
20096: LD_INT 2
20098: PUSH
20099: LD_INT 3
20101: PUSH
20102: LD_INT 4
20104: PUSH
20105: LD_INT 5
20107: PUSH
20108: EMPTY
20109: LIST
20110: LIST
20111: LIST
20112: LIST
20113: LIST
20114: ST_TO_ADDR
20115: GO 21046
20117: LD_INT 11
20119: DOUBLE
20120: EQUAL
20121: IFTRUE 20125
20123: GO 20155
20125: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20126: LD_ADDR_VAR 0 3
20130: PUSH
20131: LD_INT 1
20133: PUSH
20134: LD_INT 2
20136: PUSH
20137: LD_INT 3
20139: PUSH
20140: LD_INT 4
20142: PUSH
20143: LD_INT 5
20145: PUSH
20146: EMPTY
20147: LIST
20148: LIST
20149: LIST
20150: LIST
20151: LIST
20152: ST_TO_ADDR
20153: GO 21046
20155: LD_INT 4
20157: DOUBLE
20158: EQUAL
20159: IFTRUE 20163
20161: GO 20189
20163: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20164: LD_ADDR_VAR 0 3
20168: PUSH
20169: LD_INT 2
20171: PUSH
20172: LD_INT 3
20174: PUSH
20175: LD_INT 4
20177: PUSH
20178: LD_INT 5
20180: PUSH
20181: EMPTY
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: ST_TO_ADDR
20187: GO 21046
20189: LD_INT 5
20191: DOUBLE
20192: EQUAL
20193: IFTRUE 20197
20195: GO 20223
20197: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
20198: LD_ADDR_VAR 0 3
20202: PUSH
20203: LD_INT 2
20205: PUSH
20206: LD_INT 3
20208: PUSH
20209: LD_INT 4
20211: PUSH
20212: LD_INT 5
20214: PUSH
20215: EMPTY
20216: LIST
20217: LIST
20218: LIST
20219: LIST
20220: ST_TO_ADDR
20221: GO 21046
20223: LD_INT 9
20225: DOUBLE
20226: EQUAL
20227: IFTRUE 20231
20229: GO 20257
20231: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
20232: LD_ADDR_VAR 0 3
20236: PUSH
20237: LD_INT 2
20239: PUSH
20240: LD_INT 3
20242: PUSH
20243: LD_INT 4
20245: PUSH
20246: LD_INT 5
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: LIST
20253: LIST
20254: ST_TO_ADDR
20255: GO 21046
20257: LD_INT 7
20259: DOUBLE
20260: EQUAL
20261: IFTRUE 20265
20263: GO 20291
20265: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
20266: LD_ADDR_VAR 0 3
20270: PUSH
20271: LD_INT 2
20273: PUSH
20274: LD_INT 3
20276: PUSH
20277: LD_INT 4
20279: PUSH
20280: LD_INT 5
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: LIST
20287: LIST
20288: ST_TO_ADDR
20289: GO 21046
20291: LD_INT 12
20293: DOUBLE
20294: EQUAL
20295: IFTRUE 20299
20297: GO 20325
20299: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20300: LD_ADDR_VAR 0 3
20304: PUSH
20305: LD_INT 2
20307: PUSH
20308: LD_INT 3
20310: PUSH
20311: LD_INT 4
20313: PUSH
20314: LD_INT 5
20316: PUSH
20317: EMPTY
20318: LIST
20319: LIST
20320: LIST
20321: LIST
20322: ST_TO_ADDR
20323: GO 21046
20325: LD_INT 13
20327: DOUBLE
20328: EQUAL
20329: IFTRUE 20333
20331: GO 20359
20333: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20334: LD_ADDR_VAR 0 3
20338: PUSH
20339: LD_INT 2
20341: PUSH
20342: LD_INT 3
20344: PUSH
20345: LD_INT 4
20347: PUSH
20348: LD_INT 5
20350: PUSH
20351: EMPTY
20352: LIST
20353: LIST
20354: LIST
20355: LIST
20356: ST_TO_ADDR
20357: GO 21046
20359: LD_INT 14
20361: DOUBLE
20362: EQUAL
20363: IFTRUE 20367
20365: GO 20385
20367: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20368: LD_ADDR_VAR 0 3
20372: PUSH
20373: LD_INT 4
20375: PUSH
20376: LD_INT 5
20378: PUSH
20379: EMPTY
20380: LIST
20381: LIST
20382: ST_TO_ADDR
20383: GO 21046
20385: LD_INT 6
20387: DOUBLE
20388: EQUAL
20389: IFTRUE 20393
20391: GO 20411
20393: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20394: LD_ADDR_VAR 0 3
20398: PUSH
20399: LD_INT 4
20401: PUSH
20402: LD_INT 5
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: ST_TO_ADDR
20409: GO 21046
20411: LD_INT 10
20413: DOUBLE
20414: EQUAL
20415: IFTRUE 20419
20417: GO 20437
20419: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20420: LD_ADDR_VAR 0 3
20424: PUSH
20425: LD_INT 4
20427: PUSH
20428: LD_INT 5
20430: PUSH
20431: EMPTY
20432: LIST
20433: LIST
20434: ST_TO_ADDR
20435: GO 21046
20437: LD_INT 22
20439: DOUBLE
20440: EQUAL
20441: IFTRUE 20445
20443: GO 20471
20445: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20446: LD_ADDR_VAR 0 3
20450: PUSH
20451: LD_INT 11
20453: PUSH
20454: LD_INT 12
20456: PUSH
20457: LD_INT 13
20459: PUSH
20460: LD_INT 14
20462: PUSH
20463: EMPTY
20464: LIST
20465: LIST
20466: LIST
20467: LIST
20468: ST_TO_ADDR
20469: GO 21046
20471: LD_INT 23
20473: DOUBLE
20474: EQUAL
20475: IFTRUE 20479
20477: GO 20505
20479: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20480: LD_ADDR_VAR 0 3
20484: PUSH
20485: LD_INT 11
20487: PUSH
20488: LD_INT 12
20490: PUSH
20491: LD_INT 13
20493: PUSH
20494: LD_INT 14
20496: PUSH
20497: EMPTY
20498: LIST
20499: LIST
20500: LIST
20501: LIST
20502: ST_TO_ADDR
20503: GO 21046
20505: LD_INT 24
20507: DOUBLE
20508: EQUAL
20509: IFTRUE 20513
20511: GO 20539
20513: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20514: LD_ADDR_VAR 0 3
20518: PUSH
20519: LD_INT 11
20521: PUSH
20522: LD_INT 12
20524: PUSH
20525: LD_INT 13
20527: PUSH
20528: LD_INT 14
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: LIST
20535: LIST
20536: ST_TO_ADDR
20537: GO 21046
20539: LD_INT 30
20541: DOUBLE
20542: EQUAL
20543: IFTRUE 20547
20545: GO 20573
20547: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20548: LD_ADDR_VAR 0 3
20552: PUSH
20553: LD_INT 11
20555: PUSH
20556: LD_INT 12
20558: PUSH
20559: LD_INT 13
20561: PUSH
20562: LD_INT 14
20564: PUSH
20565: EMPTY
20566: LIST
20567: LIST
20568: LIST
20569: LIST
20570: ST_TO_ADDR
20571: GO 21046
20573: LD_INT 25
20575: DOUBLE
20576: EQUAL
20577: IFTRUE 20581
20579: GO 20599
20581: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20582: LD_ADDR_VAR 0 3
20586: PUSH
20587: LD_INT 13
20589: PUSH
20590: LD_INT 14
20592: PUSH
20593: EMPTY
20594: LIST
20595: LIST
20596: ST_TO_ADDR
20597: GO 21046
20599: LD_INT 27
20601: DOUBLE
20602: EQUAL
20603: IFTRUE 20607
20605: GO 20625
20607: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20608: LD_ADDR_VAR 0 3
20612: PUSH
20613: LD_INT 13
20615: PUSH
20616: LD_INT 14
20618: PUSH
20619: EMPTY
20620: LIST
20621: LIST
20622: ST_TO_ADDR
20623: GO 21046
20625: LD_INT 28
20627: DOUBLE
20628: EQUAL
20629: IFTRUE 20633
20631: GO 20651
20633: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20634: LD_ADDR_VAR 0 3
20638: PUSH
20639: LD_INT 13
20641: PUSH
20642: LD_INT 14
20644: PUSH
20645: EMPTY
20646: LIST
20647: LIST
20648: ST_TO_ADDR
20649: GO 21046
20651: LD_INT 29
20653: DOUBLE
20654: EQUAL
20655: IFTRUE 20659
20657: GO 20677
20659: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20660: LD_ADDR_VAR 0 3
20664: PUSH
20665: LD_INT 13
20667: PUSH
20668: LD_INT 14
20670: PUSH
20671: EMPTY
20672: LIST
20673: LIST
20674: ST_TO_ADDR
20675: GO 21046
20677: LD_INT 31
20679: DOUBLE
20680: EQUAL
20681: IFTRUE 20685
20683: GO 20703
20685: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20686: LD_ADDR_VAR 0 3
20690: PUSH
20691: LD_INT 13
20693: PUSH
20694: LD_INT 14
20696: PUSH
20697: EMPTY
20698: LIST
20699: LIST
20700: ST_TO_ADDR
20701: GO 21046
20703: LD_INT 26
20705: DOUBLE
20706: EQUAL
20707: IFTRUE 20711
20709: GO 20729
20711: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20712: LD_ADDR_VAR 0 3
20716: PUSH
20717: LD_INT 13
20719: PUSH
20720: LD_INT 14
20722: PUSH
20723: EMPTY
20724: LIST
20725: LIST
20726: ST_TO_ADDR
20727: GO 21046
20729: LD_INT 42
20731: DOUBLE
20732: EQUAL
20733: IFTRUE 20737
20735: GO 20763
20737: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20738: LD_ADDR_VAR 0 3
20742: PUSH
20743: LD_INT 21
20745: PUSH
20746: LD_INT 22
20748: PUSH
20749: LD_INT 23
20751: PUSH
20752: LD_INT 24
20754: PUSH
20755: EMPTY
20756: LIST
20757: LIST
20758: LIST
20759: LIST
20760: ST_TO_ADDR
20761: GO 21046
20763: LD_INT 43
20765: DOUBLE
20766: EQUAL
20767: IFTRUE 20771
20769: GO 20797
20771: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20772: LD_ADDR_VAR 0 3
20776: PUSH
20777: LD_INT 21
20779: PUSH
20780: LD_INT 22
20782: PUSH
20783: LD_INT 23
20785: PUSH
20786: LD_INT 24
20788: PUSH
20789: EMPTY
20790: LIST
20791: LIST
20792: LIST
20793: LIST
20794: ST_TO_ADDR
20795: GO 21046
20797: LD_INT 44
20799: DOUBLE
20800: EQUAL
20801: IFTRUE 20805
20803: GO 20831
20805: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20806: LD_ADDR_VAR 0 3
20810: PUSH
20811: LD_INT 21
20813: PUSH
20814: LD_INT 22
20816: PUSH
20817: LD_INT 23
20819: PUSH
20820: LD_INT 24
20822: PUSH
20823: EMPTY
20824: LIST
20825: LIST
20826: LIST
20827: LIST
20828: ST_TO_ADDR
20829: GO 21046
20831: LD_INT 45
20833: DOUBLE
20834: EQUAL
20835: IFTRUE 20839
20837: GO 20865
20839: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20840: LD_ADDR_VAR 0 3
20844: PUSH
20845: LD_INT 21
20847: PUSH
20848: LD_INT 22
20850: PUSH
20851: LD_INT 23
20853: PUSH
20854: LD_INT 24
20856: PUSH
20857: EMPTY
20858: LIST
20859: LIST
20860: LIST
20861: LIST
20862: ST_TO_ADDR
20863: GO 21046
20865: LD_INT 49
20867: DOUBLE
20868: EQUAL
20869: IFTRUE 20873
20871: GO 20899
20873: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20874: LD_ADDR_VAR 0 3
20878: PUSH
20879: LD_INT 21
20881: PUSH
20882: LD_INT 22
20884: PUSH
20885: LD_INT 23
20887: PUSH
20888: LD_INT 24
20890: PUSH
20891: EMPTY
20892: LIST
20893: LIST
20894: LIST
20895: LIST
20896: ST_TO_ADDR
20897: GO 21046
20899: LD_INT 51
20901: DOUBLE
20902: EQUAL
20903: IFTRUE 20907
20905: GO 20933
20907: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20908: LD_ADDR_VAR 0 3
20912: PUSH
20913: LD_INT 21
20915: PUSH
20916: LD_INT 22
20918: PUSH
20919: LD_INT 23
20921: PUSH
20922: LD_INT 24
20924: PUSH
20925: EMPTY
20926: LIST
20927: LIST
20928: LIST
20929: LIST
20930: ST_TO_ADDR
20931: GO 21046
20933: LD_INT 52
20935: DOUBLE
20936: EQUAL
20937: IFTRUE 20941
20939: GO 20967
20941: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20942: LD_ADDR_VAR 0 3
20946: PUSH
20947: LD_INT 21
20949: PUSH
20950: LD_INT 22
20952: PUSH
20953: LD_INT 23
20955: PUSH
20956: LD_INT 24
20958: PUSH
20959: EMPTY
20960: LIST
20961: LIST
20962: LIST
20963: LIST
20964: ST_TO_ADDR
20965: GO 21046
20967: LD_INT 53
20969: DOUBLE
20970: EQUAL
20971: IFTRUE 20975
20973: GO 20993
20975: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20976: LD_ADDR_VAR 0 3
20980: PUSH
20981: LD_INT 23
20983: PUSH
20984: LD_INT 24
20986: PUSH
20987: EMPTY
20988: LIST
20989: LIST
20990: ST_TO_ADDR
20991: GO 21046
20993: LD_INT 46
20995: DOUBLE
20996: EQUAL
20997: IFTRUE 21001
20999: GO 21019
21001: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
21002: LD_ADDR_VAR 0 3
21006: PUSH
21007: LD_INT 23
21009: PUSH
21010: LD_INT 24
21012: PUSH
21013: EMPTY
21014: LIST
21015: LIST
21016: ST_TO_ADDR
21017: GO 21046
21019: LD_INT 47
21021: DOUBLE
21022: EQUAL
21023: IFTRUE 21027
21025: GO 21045
21027: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
21028: LD_ADDR_VAR 0 3
21032: PUSH
21033: LD_INT 23
21035: PUSH
21036: LD_INT 24
21038: PUSH
21039: EMPTY
21040: LIST
21041: LIST
21042: ST_TO_ADDR
21043: GO 21046
21045: POP
// result := ( chassis in result ) ;
21046: LD_ADDR_VAR 0 3
21050: PUSH
21051: LD_VAR 0 1
21055: PUSH
21056: LD_VAR 0 3
21060: IN
21061: ST_TO_ADDR
// end ;
21062: LD_VAR 0 3
21066: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
21067: LD_INT 0
21069: PPUSH
21070: PPUSH
21071: PPUSH
21072: PPUSH
21073: PPUSH
21074: PPUSH
21075: PPUSH
// result := array ;
21076: LD_ADDR_VAR 0 5
21080: PUSH
21081: LD_VAR 0 1
21085: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
21086: LD_VAR 0 1
21090: NOT
21091: PUSH
21092: LD_VAR 0 2
21096: NOT
21097: OR
21098: PUSH
21099: LD_VAR 0 3
21103: NOT
21104: OR
21105: PUSH
21106: LD_VAR 0 2
21110: PUSH
21111: LD_VAR 0 1
21115: GREATER
21116: OR
21117: PUSH
21118: LD_VAR 0 3
21122: PUSH
21123: LD_VAR 0 1
21127: GREATER
21128: OR
21129: IFFALSE 21133
// exit ;
21131: GO 21429
// if direction then
21133: LD_VAR 0 4
21137: IFFALSE 21201
// begin d := 1 ;
21139: LD_ADDR_VAR 0 9
21143: PUSH
21144: LD_INT 1
21146: ST_TO_ADDR
// if i_from > i_to then
21147: LD_VAR 0 2
21151: PUSH
21152: LD_VAR 0 3
21156: GREATER
21157: IFFALSE 21183
// length := ( array - i_from ) + i_to else
21159: LD_ADDR_VAR 0 11
21163: PUSH
21164: LD_VAR 0 1
21168: PUSH
21169: LD_VAR 0 2
21173: MINUS
21174: PUSH
21175: LD_VAR 0 3
21179: PLUS
21180: ST_TO_ADDR
21181: GO 21199
// length := i_to - i_from ;
21183: LD_ADDR_VAR 0 11
21187: PUSH
21188: LD_VAR 0 3
21192: PUSH
21193: LD_VAR 0 2
21197: MINUS
21198: ST_TO_ADDR
// end else
21199: GO 21262
// begin d := - 1 ;
21201: LD_ADDR_VAR 0 9
21205: PUSH
21206: LD_INT 1
21208: NEG
21209: ST_TO_ADDR
// if i_from > i_to then
21210: LD_VAR 0 2
21214: PUSH
21215: LD_VAR 0 3
21219: GREATER
21220: IFFALSE 21240
// length := i_from - i_to else
21222: LD_ADDR_VAR 0 11
21226: PUSH
21227: LD_VAR 0 2
21231: PUSH
21232: LD_VAR 0 3
21236: MINUS
21237: ST_TO_ADDR
21238: GO 21262
// length := ( array - i_to ) + i_from ;
21240: LD_ADDR_VAR 0 11
21244: PUSH
21245: LD_VAR 0 1
21249: PUSH
21250: LD_VAR 0 3
21254: MINUS
21255: PUSH
21256: LD_VAR 0 2
21260: PLUS
21261: ST_TO_ADDR
// end ; if not length then
21262: LD_VAR 0 11
21266: NOT
21267: IFFALSE 21271
// exit ;
21269: GO 21429
// tmp := array ;
21271: LD_ADDR_VAR 0 10
21275: PUSH
21276: LD_VAR 0 1
21280: ST_TO_ADDR
// for i = 1 to length do
21281: LD_ADDR_VAR 0 6
21285: PUSH
21286: DOUBLE
21287: LD_INT 1
21289: DEC
21290: ST_TO_ADDR
21291: LD_VAR 0 11
21295: PUSH
21296: FOR_TO
21297: IFFALSE 21417
// begin for j = 1 to array do
21299: LD_ADDR_VAR 0 7
21303: PUSH
21304: DOUBLE
21305: LD_INT 1
21307: DEC
21308: ST_TO_ADDR
21309: LD_VAR 0 1
21313: PUSH
21314: FOR_TO
21315: IFFALSE 21403
// begin k := j + d ;
21317: LD_ADDR_VAR 0 8
21321: PUSH
21322: LD_VAR 0 7
21326: PUSH
21327: LD_VAR 0 9
21331: PLUS
21332: ST_TO_ADDR
// if k > array then
21333: LD_VAR 0 8
21337: PUSH
21338: LD_VAR 0 1
21342: GREATER
21343: IFFALSE 21353
// k := 1 ;
21345: LD_ADDR_VAR 0 8
21349: PUSH
21350: LD_INT 1
21352: ST_TO_ADDR
// if not k then
21353: LD_VAR 0 8
21357: NOT
21358: IFFALSE 21370
// k := array ;
21360: LD_ADDR_VAR 0 8
21364: PUSH
21365: LD_VAR 0 1
21369: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21370: LD_ADDR_VAR 0 10
21374: PUSH
21375: LD_VAR 0 10
21379: PPUSH
21380: LD_VAR 0 8
21384: PPUSH
21385: LD_VAR 0 1
21389: PUSH
21390: LD_VAR 0 7
21394: ARRAY
21395: PPUSH
21396: CALL_OW 1
21400: ST_TO_ADDR
// end ;
21401: GO 21314
21403: POP
21404: POP
// array := tmp ;
21405: LD_ADDR_VAR 0 1
21409: PUSH
21410: LD_VAR 0 10
21414: ST_TO_ADDR
// end ;
21415: GO 21296
21417: POP
21418: POP
// result := array ;
21419: LD_ADDR_VAR 0 5
21423: PUSH
21424: LD_VAR 0 1
21428: ST_TO_ADDR
// end ;
21429: LD_VAR 0 5
21433: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21434: LD_INT 0
21436: PPUSH
21437: PPUSH
// result := 0 ;
21438: LD_ADDR_VAR 0 3
21442: PUSH
21443: LD_INT 0
21445: ST_TO_ADDR
// if not array or not value in array then
21446: LD_VAR 0 1
21450: NOT
21451: PUSH
21452: LD_VAR 0 2
21456: PUSH
21457: LD_VAR 0 1
21461: IN
21462: NOT
21463: OR
21464: IFFALSE 21468
// exit ;
21466: GO 21522
// for i = 1 to array do
21468: LD_ADDR_VAR 0 4
21472: PUSH
21473: DOUBLE
21474: LD_INT 1
21476: DEC
21477: ST_TO_ADDR
21478: LD_VAR 0 1
21482: PUSH
21483: FOR_TO
21484: IFFALSE 21520
// if value = array [ i ] then
21486: LD_VAR 0 2
21490: PUSH
21491: LD_VAR 0 1
21495: PUSH
21496: LD_VAR 0 4
21500: ARRAY
21501: EQUAL
21502: IFFALSE 21518
// begin result := i ;
21504: LD_ADDR_VAR 0 3
21508: PUSH
21509: LD_VAR 0 4
21513: ST_TO_ADDR
// exit ;
21514: POP
21515: POP
21516: GO 21522
// end ;
21518: GO 21483
21520: POP
21521: POP
// end ;
21522: LD_VAR 0 3
21526: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21527: LD_INT 0
21529: PPUSH
// vc_chassis := chassis ;
21530: LD_ADDR_OWVAR 37
21534: PUSH
21535: LD_VAR 0 1
21539: ST_TO_ADDR
// vc_engine := engine ;
21540: LD_ADDR_OWVAR 39
21544: PUSH
21545: LD_VAR 0 2
21549: ST_TO_ADDR
// vc_control := control ;
21550: LD_ADDR_OWVAR 38
21554: PUSH
21555: LD_VAR 0 3
21559: ST_TO_ADDR
// vc_weapon := weapon ;
21560: LD_ADDR_OWVAR 40
21564: PUSH
21565: LD_VAR 0 4
21569: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21570: LD_ADDR_OWVAR 41
21574: PUSH
21575: LD_VAR 0 5
21579: ST_TO_ADDR
// end ;
21580: LD_VAR 0 6
21584: RET
// export function WantPlant ( unit ) ; var task ; begin
21585: LD_INT 0
21587: PPUSH
21588: PPUSH
// result := false ;
21589: LD_ADDR_VAR 0 2
21593: PUSH
21594: LD_INT 0
21596: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21597: LD_ADDR_VAR 0 3
21601: PUSH
21602: LD_VAR 0 1
21606: PPUSH
21607: CALL_OW 437
21611: ST_TO_ADDR
// if task then
21612: LD_VAR 0 3
21616: IFFALSE 21644
// if task [ 1 ] [ 1 ] = p then
21618: LD_VAR 0 3
21622: PUSH
21623: LD_INT 1
21625: ARRAY
21626: PUSH
21627: LD_INT 1
21629: ARRAY
21630: PUSH
21631: LD_STRING p
21633: EQUAL
21634: IFFALSE 21644
// result := true ;
21636: LD_ADDR_VAR 0 2
21640: PUSH
21641: LD_INT 1
21643: ST_TO_ADDR
// end ;
21644: LD_VAR 0 2
21648: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21649: LD_INT 0
21651: PPUSH
21652: PPUSH
21653: PPUSH
21654: PPUSH
// if pos < 1 then
21655: LD_VAR 0 2
21659: PUSH
21660: LD_INT 1
21662: LESS
21663: IFFALSE 21667
// exit ;
21665: GO 21970
// if pos = 1 then
21667: LD_VAR 0 2
21671: PUSH
21672: LD_INT 1
21674: EQUAL
21675: IFFALSE 21708
// result := Replace ( arr , pos [ 1 ] , value ) else
21677: LD_ADDR_VAR 0 4
21681: PUSH
21682: LD_VAR 0 1
21686: PPUSH
21687: LD_VAR 0 2
21691: PUSH
21692: LD_INT 1
21694: ARRAY
21695: PPUSH
21696: LD_VAR 0 3
21700: PPUSH
21701: CALL_OW 1
21705: ST_TO_ADDR
21706: GO 21970
// begin tmp := arr ;
21708: LD_ADDR_VAR 0 6
21712: PUSH
21713: LD_VAR 0 1
21717: ST_TO_ADDR
// s_arr := [ tmp ] ;
21718: LD_ADDR_VAR 0 7
21722: PUSH
21723: LD_VAR 0 6
21727: PUSH
21728: EMPTY
21729: LIST
21730: ST_TO_ADDR
// for i = 1 to pos - 1 do
21731: LD_ADDR_VAR 0 5
21735: PUSH
21736: DOUBLE
21737: LD_INT 1
21739: DEC
21740: ST_TO_ADDR
21741: LD_VAR 0 2
21745: PUSH
21746: LD_INT 1
21748: MINUS
21749: PUSH
21750: FOR_TO
21751: IFFALSE 21796
// begin tmp := tmp [ pos [ i ] ] ;
21753: LD_ADDR_VAR 0 6
21757: PUSH
21758: LD_VAR 0 6
21762: PUSH
21763: LD_VAR 0 2
21767: PUSH
21768: LD_VAR 0 5
21772: ARRAY
21773: ARRAY
21774: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21775: LD_ADDR_VAR 0 7
21779: PUSH
21780: LD_VAR 0 7
21784: PUSH
21785: LD_VAR 0 6
21789: PUSH
21790: EMPTY
21791: LIST
21792: ADD
21793: ST_TO_ADDR
// end ;
21794: GO 21750
21796: POP
21797: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21798: LD_ADDR_VAR 0 6
21802: PUSH
21803: LD_VAR 0 6
21807: PPUSH
21808: LD_VAR 0 2
21812: PUSH
21813: LD_VAR 0 2
21817: ARRAY
21818: PPUSH
21819: LD_VAR 0 3
21823: PPUSH
21824: CALL_OW 1
21828: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21829: LD_ADDR_VAR 0 7
21833: PUSH
21834: LD_VAR 0 7
21838: PPUSH
21839: LD_VAR 0 7
21843: PPUSH
21844: LD_VAR 0 6
21848: PPUSH
21849: CALL_OW 1
21853: ST_TO_ADDR
// for i = s_arr downto 2 do
21854: LD_ADDR_VAR 0 5
21858: PUSH
21859: DOUBLE
21860: LD_VAR 0 7
21864: INC
21865: ST_TO_ADDR
21866: LD_INT 2
21868: PUSH
21869: FOR_DOWNTO
21870: IFFALSE 21954
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21872: LD_ADDR_VAR 0 6
21876: PUSH
21877: LD_VAR 0 7
21881: PUSH
21882: LD_VAR 0 5
21886: PUSH
21887: LD_INT 1
21889: MINUS
21890: ARRAY
21891: PPUSH
21892: LD_VAR 0 2
21896: PUSH
21897: LD_VAR 0 5
21901: PUSH
21902: LD_INT 1
21904: MINUS
21905: ARRAY
21906: PPUSH
21907: LD_VAR 0 7
21911: PUSH
21912: LD_VAR 0 5
21916: ARRAY
21917: PPUSH
21918: CALL_OW 1
21922: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21923: LD_ADDR_VAR 0 7
21927: PUSH
21928: LD_VAR 0 7
21932: PPUSH
21933: LD_VAR 0 5
21937: PUSH
21938: LD_INT 1
21940: MINUS
21941: PPUSH
21942: LD_VAR 0 6
21946: PPUSH
21947: CALL_OW 1
21951: ST_TO_ADDR
// end ;
21952: GO 21869
21954: POP
21955: POP
// result := s_arr [ 1 ] ;
21956: LD_ADDR_VAR 0 4
21960: PUSH
21961: LD_VAR 0 7
21965: PUSH
21966: LD_INT 1
21968: ARRAY
21969: ST_TO_ADDR
// end ; end ;
21970: LD_VAR 0 4
21974: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21975: LD_INT 0
21977: PPUSH
21978: PPUSH
// if not list then
21979: LD_VAR 0 1
21983: NOT
21984: IFFALSE 21988
// exit ;
21986: GO 22079
// i := list [ pos1 ] ;
21988: LD_ADDR_VAR 0 5
21992: PUSH
21993: LD_VAR 0 1
21997: PUSH
21998: LD_VAR 0 2
22002: ARRAY
22003: ST_TO_ADDR
// if not i then
22004: LD_VAR 0 5
22008: NOT
22009: IFFALSE 22013
// exit ;
22011: GO 22079
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
22013: LD_ADDR_VAR 0 1
22017: PUSH
22018: LD_VAR 0 1
22022: PPUSH
22023: LD_VAR 0 2
22027: PPUSH
22028: LD_VAR 0 1
22032: PUSH
22033: LD_VAR 0 3
22037: ARRAY
22038: PPUSH
22039: CALL_OW 1
22043: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
22044: LD_ADDR_VAR 0 1
22048: PUSH
22049: LD_VAR 0 1
22053: PPUSH
22054: LD_VAR 0 3
22058: PPUSH
22059: LD_VAR 0 5
22063: PPUSH
22064: CALL_OW 1
22068: ST_TO_ADDR
// result := list ;
22069: LD_ADDR_VAR 0 4
22073: PUSH
22074: LD_VAR 0 1
22078: ST_TO_ADDR
// end ;
22079: LD_VAR 0 4
22083: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
22084: LD_INT 0
22086: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
22087: LD_ADDR_VAR 0 5
22091: PUSH
22092: LD_VAR 0 1
22096: PPUSH
22097: CALL_OW 250
22101: PPUSH
22102: LD_VAR 0 1
22106: PPUSH
22107: CALL_OW 251
22111: PPUSH
22112: LD_VAR 0 2
22116: PPUSH
22117: LD_VAR 0 3
22121: PPUSH
22122: LD_VAR 0 4
22126: PPUSH
22127: CALL 22137 0 5
22131: ST_TO_ADDR
// end ;
22132: LD_VAR 0 5
22136: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22137: LD_INT 0
22139: PPUSH
22140: PPUSH
22141: PPUSH
22142: PPUSH
// if not list then
22143: LD_VAR 0 3
22147: NOT
22148: IFFALSE 22152
// exit ;
22150: GO 22540
// result := [ ] ;
22152: LD_ADDR_VAR 0 6
22156: PUSH
22157: EMPTY
22158: ST_TO_ADDR
// for i in list do
22159: LD_ADDR_VAR 0 7
22163: PUSH
22164: LD_VAR 0 3
22168: PUSH
22169: FOR_IN
22170: IFFALSE 22372
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22172: LD_ADDR_VAR 0 9
22176: PUSH
22177: LD_VAR 0 7
22181: PPUSH
22182: LD_VAR 0 1
22186: PPUSH
22187: LD_VAR 0 2
22191: PPUSH
22192: CALL_OW 297
22196: ST_TO_ADDR
// if not result then
22197: LD_VAR 0 6
22201: NOT
22202: IFFALSE 22228
// result := [ [ i , tmp ] ] else
22204: LD_ADDR_VAR 0 6
22208: PUSH
22209: LD_VAR 0 7
22213: PUSH
22214: LD_VAR 0 9
22218: PUSH
22219: EMPTY
22220: LIST
22221: LIST
22222: PUSH
22223: EMPTY
22224: LIST
22225: ST_TO_ADDR
22226: GO 22370
// begin if result [ result ] [ 2 ] < tmp then
22228: LD_VAR 0 6
22232: PUSH
22233: LD_VAR 0 6
22237: ARRAY
22238: PUSH
22239: LD_INT 2
22241: ARRAY
22242: PUSH
22243: LD_VAR 0 9
22247: LESS
22248: IFFALSE 22290
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
22250: LD_ADDR_VAR 0 6
22254: PUSH
22255: LD_VAR 0 6
22259: PPUSH
22260: LD_VAR 0 6
22264: PUSH
22265: LD_INT 1
22267: PLUS
22268: PPUSH
22269: LD_VAR 0 7
22273: PUSH
22274: LD_VAR 0 9
22278: PUSH
22279: EMPTY
22280: LIST
22281: LIST
22282: PPUSH
22283: CALL_OW 2
22287: ST_TO_ADDR
22288: GO 22370
// for j = 1 to result do
22290: LD_ADDR_VAR 0 8
22294: PUSH
22295: DOUBLE
22296: LD_INT 1
22298: DEC
22299: ST_TO_ADDR
22300: LD_VAR 0 6
22304: PUSH
22305: FOR_TO
22306: IFFALSE 22368
// begin if tmp < result [ j ] [ 2 ] then
22308: LD_VAR 0 9
22312: PUSH
22313: LD_VAR 0 6
22317: PUSH
22318: LD_VAR 0 8
22322: ARRAY
22323: PUSH
22324: LD_INT 2
22326: ARRAY
22327: LESS
22328: IFFALSE 22366
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22330: LD_ADDR_VAR 0 6
22334: PUSH
22335: LD_VAR 0 6
22339: PPUSH
22340: LD_VAR 0 8
22344: PPUSH
22345: LD_VAR 0 7
22349: PUSH
22350: LD_VAR 0 9
22354: PUSH
22355: EMPTY
22356: LIST
22357: LIST
22358: PPUSH
22359: CALL_OW 2
22363: ST_TO_ADDR
// break ;
22364: GO 22368
// end ; end ;
22366: GO 22305
22368: POP
22369: POP
// end ; end ;
22370: GO 22169
22372: POP
22373: POP
// if result and not asc then
22374: LD_VAR 0 6
22378: PUSH
22379: LD_VAR 0 4
22383: NOT
22384: AND
22385: IFFALSE 22460
// begin tmp := result ;
22387: LD_ADDR_VAR 0 9
22391: PUSH
22392: LD_VAR 0 6
22396: ST_TO_ADDR
// for i = tmp downto 1 do
22397: LD_ADDR_VAR 0 7
22401: PUSH
22402: DOUBLE
22403: LD_VAR 0 9
22407: INC
22408: ST_TO_ADDR
22409: LD_INT 1
22411: PUSH
22412: FOR_DOWNTO
22413: IFFALSE 22458
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22415: LD_ADDR_VAR 0 6
22419: PUSH
22420: LD_VAR 0 6
22424: PPUSH
22425: LD_VAR 0 9
22429: PUSH
22430: LD_VAR 0 7
22434: MINUS
22435: PUSH
22436: LD_INT 1
22438: PLUS
22439: PPUSH
22440: LD_VAR 0 9
22444: PUSH
22445: LD_VAR 0 7
22449: ARRAY
22450: PPUSH
22451: CALL_OW 1
22455: ST_TO_ADDR
22456: GO 22412
22458: POP
22459: POP
// end ; tmp := [ ] ;
22460: LD_ADDR_VAR 0 9
22464: PUSH
22465: EMPTY
22466: ST_TO_ADDR
// if mode then
22467: LD_VAR 0 5
22471: IFFALSE 22540
// begin for i = 1 to result do
22473: LD_ADDR_VAR 0 7
22477: PUSH
22478: DOUBLE
22479: LD_INT 1
22481: DEC
22482: ST_TO_ADDR
22483: LD_VAR 0 6
22487: PUSH
22488: FOR_TO
22489: IFFALSE 22528
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22491: LD_ADDR_VAR 0 9
22495: PUSH
22496: LD_VAR 0 9
22500: PPUSH
22501: LD_VAR 0 7
22505: PPUSH
22506: LD_VAR 0 6
22510: PUSH
22511: LD_VAR 0 7
22515: ARRAY
22516: PUSH
22517: LD_INT 1
22519: ARRAY
22520: PPUSH
22521: CALL_OW 1
22525: ST_TO_ADDR
22526: GO 22488
22528: POP
22529: POP
// result := tmp ;
22530: LD_ADDR_VAR 0 6
22534: PUSH
22535: LD_VAR 0 9
22539: ST_TO_ADDR
// end ; end ;
22540: LD_VAR 0 6
22544: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22545: LD_INT 0
22547: PPUSH
22548: PPUSH
22549: PPUSH
22550: PPUSH
22551: PPUSH
22552: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22553: LD_ADDR_VAR 0 5
22557: PUSH
22558: LD_INT 0
22560: PUSH
22561: LD_INT 0
22563: PUSH
22564: LD_INT 0
22566: PUSH
22567: EMPTY
22568: PUSH
22569: EMPTY
22570: LIST
22571: LIST
22572: LIST
22573: LIST
22574: ST_TO_ADDR
// if not x or not y then
22575: LD_VAR 0 2
22579: NOT
22580: PUSH
22581: LD_VAR 0 3
22585: NOT
22586: OR
22587: IFFALSE 22591
// exit ;
22589: GO 24237
// if not range then
22591: LD_VAR 0 4
22595: NOT
22596: IFFALSE 22606
// range := 10 ;
22598: LD_ADDR_VAR 0 4
22602: PUSH
22603: LD_INT 10
22605: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22606: LD_ADDR_VAR 0 8
22610: PUSH
22611: LD_INT 81
22613: PUSH
22614: LD_VAR 0 1
22618: PUSH
22619: EMPTY
22620: LIST
22621: LIST
22622: PUSH
22623: LD_INT 92
22625: PUSH
22626: LD_VAR 0 2
22630: PUSH
22631: LD_VAR 0 3
22635: PUSH
22636: LD_VAR 0 4
22640: PUSH
22641: EMPTY
22642: LIST
22643: LIST
22644: LIST
22645: LIST
22646: PUSH
22647: LD_INT 3
22649: PUSH
22650: LD_INT 21
22652: PUSH
22653: LD_INT 3
22655: PUSH
22656: EMPTY
22657: LIST
22658: LIST
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: PUSH
22664: EMPTY
22665: LIST
22666: LIST
22667: LIST
22668: PPUSH
22669: CALL_OW 69
22673: ST_TO_ADDR
// if not tmp then
22674: LD_VAR 0 8
22678: NOT
22679: IFFALSE 22683
// exit ;
22681: GO 24237
// for i in tmp do
22683: LD_ADDR_VAR 0 6
22687: PUSH
22688: LD_VAR 0 8
22692: PUSH
22693: FOR_IN
22694: IFFALSE 24212
// begin points := [ 0 , 0 , 0 ] ;
22696: LD_ADDR_VAR 0 9
22700: PUSH
22701: LD_INT 0
22703: PUSH
22704: LD_INT 0
22706: PUSH
22707: LD_INT 0
22709: PUSH
22710: EMPTY
22711: LIST
22712: LIST
22713: LIST
22714: ST_TO_ADDR
// bpoints := 1 ;
22715: LD_ADDR_VAR 0 10
22719: PUSH
22720: LD_INT 1
22722: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22723: LD_VAR 0 6
22727: PPUSH
22728: CALL_OW 247
22732: PUSH
22733: LD_INT 1
22735: DOUBLE
22736: EQUAL
22737: IFTRUE 22741
22739: GO 23319
22741: POP
// begin if GetClass ( i ) = 1 then
22742: LD_VAR 0 6
22746: PPUSH
22747: CALL_OW 257
22751: PUSH
22752: LD_INT 1
22754: EQUAL
22755: IFFALSE 22776
// points := [ 10 , 5 , 3 ] ;
22757: LD_ADDR_VAR 0 9
22761: PUSH
22762: LD_INT 10
22764: PUSH
22765: LD_INT 5
22767: PUSH
22768: LD_INT 3
22770: PUSH
22771: EMPTY
22772: LIST
22773: LIST
22774: LIST
22775: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22776: LD_VAR 0 6
22780: PPUSH
22781: CALL_OW 257
22785: PUSH
22786: LD_INT 2
22788: PUSH
22789: LD_INT 3
22791: PUSH
22792: LD_INT 4
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: LIST
22799: IN
22800: IFFALSE 22821
// points := [ 3 , 2 , 1 ] ;
22802: LD_ADDR_VAR 0 9
22806: PUSH
22807: LD_INT 3
22809: PUSH
22810: LD_INT 2
22812: PUSH
22813: LD_INT 1
22815: PUSH
22816: EMPTY
22817: LIST
22818: LIST
22819: LIST
22820: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22821: LD_VAR 0 6
22825: PPUSH
22826: CALL_OW 257
22830: PUSH
22831: LD_INT 5
22833: EQUAL
22834: IFFALSE 22855
// points := [ 130 , 5 , 2 ] ;
22836: LD_ADDR_VAR 0 9
22840: PUSH
22841: LD_INT 130
22843: PUSH
22844: LD_INT 5
22846: PUSH
22847: LD_INT 2
22849: PUSH
22850: EMPTY
22851: LIST
22852: LIST
22853: LIST
22854: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22855: LD_VAR 0 6
22859: PPUSH
22860: CALL_OW 257
22864: PUSH
22865: LD_INT 8
22867: EQUAL
22868: IFFALSE 22889
// points := [ 35 , 35 , 30 ] ;
22870: LD_ADDR_VAR 0 9
22874: PUSH
22875: LD_INT 35
22877: PUSH
22878: LD_INT 35
22880: PUSH
22881: LD_INT 30
22883: PUSH
22884: EMPTY
22885: LIST
22886: LIST
22887: LIST
22888: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22889: LD_VAR 0 6
22893: PPUSH
22894: CALL_OW 257
22898: PUSH
22899: LD_INT 9
22901: EQUAL
22902: IFFALSE 22923
// points := [ 20 , 55 , 40 ] ;
22904: LD_ADDR_VAR 0 9
22908: PUSH
22909: LD_INT 20
22911: PUSH
22912: LD_INT 55
22914: PUSH
22915: LD_INT 40
22917: PUSH
22918: EMPTY
22919: LIST
22920: LIST
22921: LIST
22922: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22923: LD_VAR 0 6
22927: PPUSH
22928: CALL_OW 257
22932: PUSH
22933: LD_INT 12
22935: PUSH
22936: LD_INT 16
22938: PUSH
22939: EMPTY
22940: LIST
22941: LIST
22942: IN
22943: IFFALSE 22964
// points := [ 5 , 3 , 2 ] ;
22945: LD_ADDR_VAR 0 9
22949: PUSH
22950: LD_INT 5
22952: PUSH
22953: LD_INT 3
22955: PUSH
22956: LD_INT 2
22958: PUSH
22959: EMPTY
22960: LIST
22961: LIST
22962: LIST
22963: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22964: LD_VAR 0 6
22968: PPUSH
22969: CALL_OW 257
22973: PUSH
22974: LD_INT 17
22976: EQUAL
22977: IFFALSE 22998
// points := [ 100 , 50 , 75 ] ;
22979: LD_ADDR_VAR 0 9
22983: PUSH
22984: LD_INT 100
22986: PUSH
22987: LD_INT 50
22989: PUSH
22990: LD_INT 75
22992: PUSH
22993: EMPTY
22994: LIST
22995: LIST
22996: LIST
22997: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22998: LD_VAR 0 6
23002: PPUSH
23003: CALL_OW 257
23007: PUSH
23008: LD_INT 15
23010: EQUAL
23011: IFFALSE 23032
// points := [ 10 , 5 , 3 ] ;
23013: LD_ADDR_VAR 0 9
23017: PUSH
23018: LD_INT 10
23020: PUSH
23021: LD_INT 5
23023: PUSH
23024: LD_INT 3
23026: PUSH
23027: EMPTY
23028: LIST
23029: LIST
23030: LIST
23031: ST_TO_ADDR
// if GetClass ( i ) = 14 then
23032: LD_VAR 0 6
23036: PPUSH
23037: CALL_OW 257
23041: PUSH
23042: LD_INT 14
23044: EQUAL
23045: IFFALSE 23066
// points := [ 10 , 0 , 0 ] ;
23047: LD_ADDR_VAR 0 9
23051: PUSH
23052: LD_INT 10
23054: PUSH
23055: LD_INT 0
23057: PUSH
23058: LD_INT 0
23060: PUSH
23061: EMPTY
23062: LIST
23063: LIST
23064: LIST
23065: ST_TO_ADDR
// if GetClass ( i ) = 11 then
23066: LD_VAR 0 6
23070: PPUSH
23071: CALL_OW 257
23075: PUSH
23076: LD_INT 11
23078: EQUAL
23079: IFFALSE 23100
// points := [ 30 , 10 , 5 ] ;
23081: LD_ADDR_VAR 0 9
23085: PUSH
23086: LD_INT 30
23088: PUSH
23089: LD_INT 10
23091: PUSH
23092: LD_INT 5
23094: PUSH
23095: EMPTY
23096: LIST
23097: LIST
23098: LIST
23099: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
23100: LD_VAR 0 1
23104: PPUSH
23105: LD_INT 5
23107: PPUSH
23108: CALL_OW 321
23112: PUSH
23113: LD_INT 2
23115: EQUAL
23116: IFFALSE 23133
// bpoints := bpoints * 1.8 ;
23118: LD_ADDR_VAR 0 10
23122: PUSH
23123: LD_VAR 0 10
23127: PUSH
23128: LD_REAL  1.80000000000000E+0000
23131: MUL
23132: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23133: LD_VAR 0 6
23137: PPUSH
23138: CALL_OW 257
23142: PUSH
23143: LD_INT 1
23145: PUSH
23146: LD_INT 2
23148: PUSH
23149: LD_INT 3
23151: PUSH
23152: LD_INT 4
23154: PUSH
23155: EMPTY
23156: LIST
23157: LIST
23158: LIST
23159: LIST
23160: IN
23161: PUSH
23162: LD_VAR 0 1
23166: PPUSH
23167: LD_INT 51
23169: PPUSH
23170: CALL_OW 321
23174: PUSH
23175: LD_INT 2
23177: EQUAL
23178: AND
23179: IFFALSE 23196
// bpoints := bpoints * 1.2 ;
23181: LD_ADDR_VAR 0 10
23185: PUSH
23186: LD_VAR 0 10
23190: PUSH
23191: LD_REAL  1.20000000000000E+0000
23194: MUL
23195: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23196: LD_VAR 0 6
23200: PPUSH
23201: CALL_OW 257
23205: PUSH
23206: LD_INT 5
23208: PUSH
23209: LD_INT 7
23211: PUSH
23212: LD_INT 9
23214: PUSH
23215: EMPTY
23216: LIST
23217: LIST
23218: LIST
23219: IN
23220: PUSH
23221: LD_VAR 0 1
23225: PPUSH
23226: LD_INT 52
23228: PPUSH
23229: CALL_OW 321
23233: PUSH
23234: LD_INT 2
23236: EQUAL
23237: AND
23238: IFFALSE 23255
// bpoints := bpoints * 1.5 ;
23240: LD_ADDR_VAR 0 10
23244: PUSH
23245: LD_VAR 0 10
23249: PUSH
23250: LD_REAL  1.50000000000000E+0000
23253: MUL
23254: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
23255: LD_VAR 0 1
23259: PPUSH
23260: LD_INT 66
23262: PPUSH
23263: CALL_OW 321
23267: PUSH
23268: LD_INT 2
23270: EQUAL
23271: IFFALSE 23288
// bpoints := bpoints * 1.1 ;
23273: LD_ADDR_VAR 0 10
23277: PUSH
23278: LD_VAR 0 10
23282: PUSH
23283: LD_REAL  1.10000000000000E+0000
23286: MUL
23287: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23288: LD_ADDR_VAR 0 10
23292: PUSH
23293: LD_VAR 0 10
23297: PUSH
23298: LD_VAR 0 6
23302: PPUSH
23303: LD_INT 1
23305: PPUSH
23306: CALL_OW 259
23310: PUSH
23311: LD_REAL  1.15000000000000E+0000
23314: MUL
23315: MUL
23316: ST_TO_ADDR
// end ; unit_vehicle :
23317: GO 24141
23319: LD_INT 2
23321: DOUBLE
23322: EQUAL
23323: IFTRUE 23327
23325: GO 24129
23327: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23328: LD_VAR 0 6
23332: PPUSH
23333: CALL_OW 264
23337: PUSH
23338: LD_INT 2
23340: PUSH
23341: LD_INT 42
23343: PUSH
23344: LD_INT 24
23346: PUSH
23347: EMPTY
23348: LIST
23349: LIST
23350: LIST
23351: IN
23352: IFFALSE 23373
// points := [ 25 , 5 , 3 ] ;
23354: LD_ADDR_VAR 0 9
23358: PUSH
23359: LD_INT 25
23361: PUSH
23362: LD_INT 5
23364: PUSH
23365: LD_INT 3
23367: PUSH
23368: EMPTY
23369: LIST
23370: LIST
23371: LIST
23372: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23373: LD_VAR 0 6
23377: PPUSH
23378: CALL_OW 264
23382: PUSH
23383: LD_INT 4
23385: PUSH
23386: LD_INT 43
23388: PUSH
23389: LD_INT 25
23391: PUSH
23392: EMPTY
23393: LIST
23394: LIST
23395: LIST
23396: IN
23397: IFFALSE 23418
// points := [ 40 , 15 , 5 ] ;
23399: LD_ADDR_VAR 0 9
23403: PUSH
23404: LD_INT 40
23406: PUSH
23407: LD_INT 15
23409: PUSH
23410: LD_INT 5
23412: PUSH
23413: EMPTY
23414: LIST
23415: LIST
23416: LIST
23417: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23418: LD_VAR 0 6
23422: PPUSH
23423: CALL_OW 264
23427: PUSH
23428: LD_INT 3
23430: PUSH
23431: LD_INT 23
23433: PUSH
23434: EMPTY
23435: LIST
23436: LIST
23437: IN
23438: IFFALSE 23459
// points := [ 7 , 25 , 8 ] ;
23440: LD_ADDR_VAR 0 9
23444: PUSH
23445: LD_INT 7
23447: PUSH
23448: LD_INT 25
23450: PUSH
23451: LD_INT 8
23453: PUSH
23454: EMPTY
23455: LIST
23456: LIST
23457: LIST
23458: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23459: LD_VAR 0 6
23463: PPUSH
23464: CALL_OW 264
23468: PUSH
23469: LD_INT 5
23471: PUSH
23472: LD_INT 27
23474: PUSH
23475: LD_INT 44
23477: PUSH
23478: EMPTY
23479: LIST
23480: LIST
23481: LIST
23482: IN
23483: IFFALSE 23504
// points := [ 14 , 50 , 16 ] ;
23485: LD_ADDR_VAR 0 9
23489: PUSH
23490: LD_INT 14
23492: PUSH
23493: LD_INT 50
23495: PUSH
23496: LD_INT 16
23498: PUSH
23499: EMPTY
23500: LIST
23501: LIST
23502: LIST
23503: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23504: LD_VAR 0 6
23508: PPUSH
23509: CALL_OW 264
23513: PUSH
23514: LD_INT 6
23516: PUSH
23517: LD_INT 46
23519: PUSH
23520: EMPTY
23521: LIST
23522: LIST
23523: IN
23524: IFFALSE 23545
// points := [ 32 , 120 , 70 ] ;
23526: LD_ADDR_VAR 0 9
23530: PUSH
23531: LD_INT 32
23533: PUSH
23534: LD_INT 120
23536: PUSH
23537: LD_INT 70
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: LIST
23544: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
23545: LD_VAR 0 6
23549: PPUSH
23550: CALL_OW 264
23554: PUSH
23555: LD_INT 7
23557: PUSH
23558: LD_INT 28
23560: PUSH
23561: LD_INT 45
23563: PUSH
23564: EMPTY
23565: LIST
23566: LIST
23567: LIST
23568: IN
23569: IFFALSE 23590
// points := [ 35 , 20 , 45 ] ;
23571: LD_ADDR_VAR 0 9
23575: PUSH
23576: LD_INT 35
23578: PUSH
23579: LD_INT 20
23581: PUSH
23582: LD_INT 45
23584: PUSH
23585: EMPTY
23586: LIST
23587: LIST
23588: LIST
23589: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23590: LD_VAR 0 6
23594: PPUSH
23595: CALL_OW 264
23599: PUSH
23600: LD_INT 47
23602: PUSH
23603: EMPTY
23604: LIST
23605: IN
23606: IFFALSE 23627
// points := [ 67 , 45 , 75 ] ;
23608: LD_ADDR_VAR 0 9
23612: PUSH
23613: LD_INT 67
23615: PUSH
23616: LD_INT 45
23618: PUSH
23619: LD_INT 75
23621: PUSH
23622: EMPTY
23623: LIST
23624: LIST
23625: LIST
23626: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23627: LD_VAR 0 6
23631: PPUSH
23632: CALL_OW 264
23636: PUSH
23637: LD_INT 26
23639: PUSH
23640: EMPTY
23641: LIST
23642: IN
23643: IFFALSE 23664
// points := [ 120 , 30 , 80 ] ;
23645: LD_ADDR_VAR 0 9
23649: PUSH
23650: LD_INT 120
23652: PUSH
23653: LD_INT 30
23655: PUSH
23656: LD_INT 80
23658: PUSH
23659: EMPTY
23660: LIST
23661: LIST
23662: LIST
23663: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23664: LD_VAR 0 6
23668: PPUSH
23669: CALL_OW 264
23673: PUSH
23674: LD_INT 22
23676: PUSH
23677: EMPTY
23678: LIST
23679: IN
23680: IFFALSE 23701
// points := [ 40 , 1 , 1 ] ;
23682: LD_ADDR_VAR 0 9
23686: PUSH
23687: LD_INT 40
23689: PUSH
23690: LD_INT 1
23692: PUSH
23693: LD_INT 1
23695: PUSH
23696: EMPTY
23697: LIST
23698: LIST
23699: LIST
23700: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23701: LD_VAR 0 6
23705: PPUSH
23706: CALL_OW 264
23710: PUSH
23711: LD_INT 29
23713: PUSH
23714: EMPTY
23715: LIST
23716: IN
23717: IFFALSE 23738
// points := [ 70 , 200 , 400 ] ;
23719: LD_ADDR_VAR 0 9
23723: PUSH
23724: LD_INT 70
23726: PUSH
23727: LD_INT 200
23729: PUSH
23730: LD_INT 400
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: LIST
23737: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23738: LD_VAR 0 6
23742: PPUSH
23743: CALL_OW 264
23747: PUSH
23748: LD_INT 14
23750: PUSH
23751: LD_INT 53
23753: PUSH
23754: EMPTY
23755: LIST
23756: LIST
23757: IN
23758: IFFALSE 23779
// points := [ 40 , 10 , 20 ] ;
23760: LD_ADDR_VAR 0 9
23764: PUSH
23765: LD_INT 40
23767: PUSH
23768: LD_INT 10
23770: PUSH
23771: LD_INT 20
23773: PUSH
23774: EMPTY
23775: LIST
23776: LIST
23777: LIST
23778: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23779: LD_VAR 0 6
23783: PPUSH
23784: CALL_OW 264
23788: PUSH
23789: LD_INT 9
23791: PUSH
23792: EMPTY
23793: LIST
23794: IN
23795: IFFALSE 23816
// points := [ 5 , 70 , 20 ] ;
23797: LD_ADDR_VAR 0 9
23801: PUSH
23802: LD_INT 5
23804: PUSH
23805: LD_INT 70
23807: PUSH
23808: LD_INT 20
23810: PUSH
23811: EMPTY
23812: LIST
23813: LIST
23814: LIST
23815: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23816: LD_VAR 0 6
23820: PPUSH
23821: CALL_OW 264
23825: PUSH
23826: LD_INT 10
23828: PUSH
23829: EMPTY
23830: LIST
23831: IN
23832: IFFALSE 23853
// points := [ 35 , 110 , 70 ] ;
23834: LD_ADDR_VAR 0 9
23838: PUSH
23839: LD_INT 35
23841: PUSH
23842: LD_INT 110
23844: PUSH
23845: LD_INT 70
23847: PUSH
23848: EMPTY
23849: LIST
23850: LIST
23851: LIST
23852: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23853: LD_VAR 0 6
23857: PPUSH
23858: CALL_OW 265
23862: PUSH
23863: LD_INT 25
23865: EQUAL
23866: IFFALSE 23887
// points := [ 80 , 65 , 100 ] ;
23868: LD_ADDR_VAR 0 9
23872: PUSH
23873: LD_INT 80
23875: PUSH
23876: LD_INT 65
23878: PUSH
23879: LD_INT 100
23881: PUSH
23882: EMPTY
23883: LIST
23884: LIST
23885: LIST
23886: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23887: LD_VAR 0 6
23891: PPUSH
23892: CALL_OW 263
23896: PUSH
23897: LD_INT 1
23899: EQUAL
23900: IFFALSE 23935
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23902: LD_ADDR_VAR 0 10
23906: PUSH
23907: LD_VAR 0 10
23911: PUSH
23912: LD_VAR 0 6
23916: PPUSH
23917: CALL_OW 311
23921: PPUSH
23922: LD_INT 3
23924: PPUSH
23925: CALL_OW 259
23929: PUSH
23930: LD_INT 4
23932: MUL
23933: MUL
23934: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23935: LD_VAR 0 6
23939: PPUSH
23940: CALL_OW 263
23944: PUSH
23945: LD_INT 2
23947: EQUAL
23948: IFFALSE 23999
// begin j := IsControledBy ( i ) ;
23950: LD_ADDR_VAR 0 7
23954: PUSH
23955: LD_VAR 0 6
23959: PPUSH
23960: CALL_OW 312
23964: ST_TO_ADDR
// if j then
23965: LD_VAR 0 7
23969: IFFALSE 23999
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23971: LD_ADDR_VAR 0 10
23975: PUSH
23976: LD_VAR 0 10
23980: PUSH
23981: LD_VAR 0 7
23985: PPUSH
23986: LD_INT 3
23988: PPUSH
23989: CALL_OW 259
23993: PUSH
23994: LD_INT 3
23996: MUL
23997: MUL
23998: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23999: LD_VAR 0 6
24003: PPUSH
24004: CALL_OW 264
24008: PUSH
24009: LD_INT 5
24011: PUSH
24012: LD_INT 6
24014: PUSH
24015: LD_INT 46
24017: PUSH
24018: LD_INT 44
24020: PUSH
24021: LD_INT 47
24023: PUSH
24024: LD_INT 45
24026: PUSH
24027: LD_INT 28
24029: PUSH
24030: LD_INT 7
24032: PUSH
24033: LD_INT 27
24035: PUSH
24036: LD_INT 29
24038: PUSH
24039: EMPTY
24040: LIST
24041: LIST
24042: LIST
24043: LIST
24044: LIST
24045: LIST
24046: LIST
24047: LIST
24048: LIST
24049: LIST
24050: IN
24051: PUSH
24052: LD_VAR 0 1
24056: PPUSH
24057: LD_INT 52
24059: PPUSH
24060: CALL_OW 321
24064: PUSH
24065: LD_INT 2
24067: EQUAL
24068: AND
24069: IFFALSE 24086
// bpoints := bpoints * 1.2 ;
24071: LD_ADDR_VAR 0 10
24075: PUSH
24076: LD_VAR 0 10
24080: PUSH
24081: LD_REAL  1.20000000000000E+0000
24084: MUL
24085: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
24086: LD_VAR 0 6
24090: PPUSH
24091: CALL_OW 264
24095: PUSH
24096: LD_INT 6
24098: PUSH
24099: LD_INT 46
24101: PUSH
24102: LD_INT 47
24104: PUSH
24105: EMPTY
24106: LIST
24107: LIST
24108: LIST
24109: IN
24110: IFFALSE 24127
// bpoints := bpoints * 1.2 ;
24112: LD_ADDR_VAR 0 10
24116: PUSH
24117: LD_VAR 0 10
24121: PUSH
24122: LD_REAL  1.20000000000000E+0000
24125: MUL
24126: ST_TO_ADDR
// end ; unit_building :
24127: GO 24141
24129: LD_INT 3
24131: DOUBLE
24132: EQUAL
24133: IFTRUE 24137
24135: GO 24140
24137: POP
// ; end ;
24138: GO 24141
24140: POP
// for j = 1 to 3 do
24141: LD_ADDR_VAR 0 7
24145: PUSH
24146: DOUBLE
24147: LD_INT 1
24149: DEC
24150: ST_TO_ADDR
24151: LD_INT 3
24153: PUSH
24154: FOR_TO
24155: IFFALSE 24208
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24157: LD_ADDR_VAR 0 5
24161: PUSH
24162: LD_VAR 0 5
24166: PPUSH
24167: LD_VAR 0 7
24171: PPUSH
24172: LD_VAR 0 5
24176: PUSH
24177: LD_VAR 0 7
24181: ARRAY
24182: PUSH
24183: LD_VAR 0 9
24187: PUSH
24188: LD_VAR 0 7
24192: ARRAY
24193: PUSH
24194: LD_VAR 0 10
24198: MUL
24199: PLUS
24200: PPUSH
24201: CALL_OW 1
24205: ST_TO_ADDR
24206: GO 24154
24208: POP
24209: POP
// end ;
24210: GO 22693
24212: POP
24213: POP
// result := Replace ( result , 4 , tmp ) ;
24214: LD_ADDR_VAR 0 5
24218: PUSH
24219: LD_VAR 0 5
24223: PPUSH
24224: LD_INT 4
24226: PPUSH
24227: LD_VAR 0 8
24231: PPUSH
24232: CALL_OW 1
24236: ST_TO_ADDR
// end ;
24237: LD_VAR 0 5
24241: RET
// export function DangerAtRange ( unit , range ) ; begin
24242: LD_INT 0
24244: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
24245: LD_ADDR_VAR 0 3
24249: PUSH
24250: LD_VAR 0 1
24254: PPUSH
24255: CALL_OW 255
24259: PPUSH
24260: LD_VAR 0 1
24264: PPUSH
24265: CALL_OW 250
24269: PPUSH
24270: LD_VAR 0 1
24274: PPUSH
24275: CALL_OW 251
24279: PPUSH
24280: LD_VAR 0 2
24284: PPUSH
24285: CALL 22545 0 4
24289: ST_TO_ADDR
// end ;
24290: LD_VAR 0 3
24294: RET
// export function DangerInArea ( side , area ) ; begin
24295: LD_INT 0
24297: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24298: LD_ADDR_VAR 0 3
24302: PUSH
24303: LD_VAR 0 2
24307: PPUSH
24308: LD_INT 81
24310: PUSH
24311: LD_VAR 0 1
24315: PUSH
24316: EMPTY
24317: LIST
24318: LIST
24319: PPUSH
24320: CALL_OW 70
24324: ST_TO_ADDR
// end ;
24325: LD_VAR 0 3
24329: RET
// export function IsExtension ( b ) ; begin
24330: LD_INT 0
24332: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24333: LD_ADDR_VAR 0 2
24337: PUSH
24338: LD_VAR 0 1
24342: PUSH
24343: LD_INT 23
24345: PUSH
24346: LD_INT 20
24348: PUSH
24349: LD_INT 22
24351: PUSH
24352: LD_INT 17
24354: PUSH
24355: LD_INT 24
24357: PUSH
24358: LD_INT 21
24360: PUSH
24361: LD_INT 19
24363: PUSH
24364: LD_INT 16
24366: PUSH
24367: LD_INT 25
24369: PUSH
24370: LD_INT 18
24372: PUSH
24373: EMPTY
24374: LIST
24375: LIST
24376: LIST
24377: LIST
24378: LIST
24379: LIST
24380: LIST
24381: LIST
24382: LIST
24383: LIST
24384: IN
24385: ST_TO_ADDR
// end ;
24386: LD_VAR 0 2
24390: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
24391: LD_INT 0
24393: PPUSH
24394: PPUSH
24395: PPUSH
// result := [ ] ;
24396: LD_ADDR_VAR 0 3
24400: PUSH
24401: EMPTY
24402: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24403: LD_ADDR_VAR 0 4
24407: PUSH
24408: LD_VAR 0 2
24412: PPUSH
24413: LD_INT 21
24415: PUSH
24416: LD_INT 3
24418: PUSH
24419: EMPTY
24420: LIST
24421: LIST
24422: PPUSH
24423: CALL_OW 70
24427: ST_TO_ADDR
// if not tmp then
24428: LD_VAR 0 4
24432: NOT
24433: IFFALSE 24437
// exit ;
24435: GO 24495
// for i in tmp do
24437: LD_ADDR_VAR 0 5
24441: PUSH
24442: LD_VAR 0 4
24446: PUSH
24447: FOR_IN
24448: IFFALSE 24483
// if GetBase ( i ) <> base then
24450: LD_VAR 0 5
24454: PPUSH
24455: CALL_OW 274
24459: PUSH
24460: LD_VAR 0 1
24464: NONEQUAL
24465: IFFALSE 24481
// ComLinkToBase ( base , i ) ;
24467: LD_VAR 0 1
24471: PPUSH
24472: LD_VAR 0 5
24476: PPUSH
24477: CALL_OW 169
24481: GO 24447
24483: POP
24484: POP
// result := tmp ;
24485: LD_ADDR_VAR 0 3
24489: PUSH
24490: LD_VAR 0 4
24494: ST_TO_ADDR
// end ;
24495: LD_VAR 0 3
24499: RET
// export function ComComplete ( unit , b ) ; var i ; begin
24500: LD_INT 0
24502: PPUSH
24503: PPUSH
// if BuildingStatus ( b ) = bs_build then
24504: LD_VAR 0 2
24508: PPUSH
24509: CALL_OW 461
24513: PUSH
24514: LD_INT 1
24516: EQUAL
24517: IFFALSE 24577
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24519: LD_VAR 0 1
24523: PPUSH
24524: LD_STRING h
24526: PUSH
24527: LD_VAR 0 2
24531: PPUSH
24532: CALL_OW 250
24536: PUSH
24537: LD_VAR 0 2
24541: PPUSH
24542: CALL_OW 251
24546: PUSH
24547: LD_VAR 0 2
24551: PUSH
24552: LD_INT 0
24554: PUSH
24555: LD_INT 0
24557: PUSH
24558: LD_INT 0
24560: PUSH
24561: EMPTY
24562: LIST
24563: LIST
24564: LIST
24565: LIST
24566: LIST
24567: LIST
24568: LIST
24569: PUSH
24570: EMPTY
24571: LIST
24572: PPUSH
24573: CALL_OW 446
// end ;
24577: LD_VAR 0 3
24581: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24582: LD_INT 0
24584: PPUSH
24585: PPUSH
24586: PPUSH
24587: PPUSH
24588: PPUSH
24589: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
24590: LD_VAR 0 1
24594: NOT
24595: PUSH
24596: LD_VAR 0 1
24600: PPUSH
24601: CALL_OW 263
24605: PUSH
24606: LD_INT 2
24608: EQUAL
24609: NOT
24610: OR
24611: IFFALSE 24615
// exit ;
24613: GO 24931
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24615: LD_ADDR_VAR 0 6
24619: PUSH
24620: LD_INT 22
24622: PUSH
24623: LD_VAR 0 1
24627: PPUSH
24628: CALL_OW 255
24632: PUSH
24633: EMPTY
24634: LIST
24635: LIST
24636: PUSH
24637: LD_INT 2
24639: PUSH
24640: LD_INT 30
24642: PUSH
24643: LD_INT 36
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: PUSH
24650: LD_INT 34
24652: PUSH
24653: LD_INT 31
24655: PUSH
24656: EMPTY
24657: LIST
24658: LIST
24659: PUSH
24660: EMPTY
24661: LIST
24662: LIST
24663: LIST
24664: PUSH
24665: EMPTY
24666: LIST
24667: LIST
24668: PPUSH
24669: CALL_OW 69
24673: ST_TO_ADDR
// if not tmp then
24674: LD_VAR 0 6
24678: NOT
24679: IFFALSE 24683
// exit ;
24681: GO 24931
// result := [ ] ;
24683: LD_ADDR_VAR 0 2
24687: PUSH
24688: EMPTY
24689: ST_TO_ADDR
// for i in tmp do
24690: LD_ADDR_VAR 0 3
24694: PUSH
24695: LD_VAR 0 6
24699: PUSH
24700: FOR_IN
24701: IFFALSE 24772
// begin t := UnitsInside ( i ) ;
24703: LD_ADDR_VAR 0 4
24707: PUSH
24708: LD_VAR 0 3
24712: PPUSH
24713: CALL_OW 313
24717: ST_TO_ADDR
// if t then
24718: LD_VAR 0 4
24722: IFFALSE 24770
// for j in t do
24724: LD_ADDR_VAR 0 7
24728: PUSH
24729: LD_VAR 0 4
24733: PUSH
24734: FOR_IN
24735: IFFALSE 24768
// result := Insert ( result , result + 1 , j ) ;
24737: LD_ADDR_VAR 0 2
24741: PUSH
24742: LD_VAR 0 2
24746: PPUSH
24747: LD_VAR 0 2
24751: PUSH
24752: LD_INT 1
24754: PLUS
24755: PPUSH
24756: LD_VAR 0 7
24760: PPUSH
24761: CALL_OW 2
24765: ST_TO_ADDR
24766: GO 24734
24768: POP
24769: POP
// end ;
24770: GO 24700
24772: POP
24773: POP
// if not result then
24774: LD_VAR 0 2
24778: NOT
24779: IFFALSE 24783
// exit ;
24781: GO 24931
// mech := result [ 1 ] ;
24783: LD_ADDR_VAR 0 5
24787: PUSH
24788: LD_VAR 0 2
24792: PUSH
24793: LD_INT 1
24795: ARRAY
24796: ST_TO_ADDR
// if result > 1 then
24797: LD_VAR 0 2
24801: PUSH
24802: LD_INT 1
24804: GREATER
24805: IFFALSE 24917
// for i = 2 to result do
24807: LD_ADDR_VAR 0 3
24811: PUSH
24812: DOUBLE
24813: LD_INT 2
24815: DEC
24816: ST_TO_ADDR
24817: LD_VAR 0 2
24821: PUSH
24822: FOR_TO
24823: IFFALSE 24915
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24825: LD_ADDR_VAR 0 4
24829: PUSH
24830: LD_VAR 0 2
24834: PUSH
24835: LD_VAR 0 3
24839: ARRAY
24840: PPUSH
24841: LD_INT 3
24843: PPUSH
24844: CALL_OW 259
24848: PUSH
24849: LD_VAR 0 2
24853: PUSH
24854: LD_VAR 0 3
24858: ARRAY
24859: PPUSH
24860: CALL_OW 432
24864: MINUS
24865: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24866: LD_VAR 0 4
24870: PUSH
24871: LD_VAR 0 5
24875: PPUSH
24876: LD_INT 3
24878: PPUSH
24879: CALL_OW 259
24883: PUSH
24884: LD_VAR 0 5
24888: PPUSH
24889: CALL_OW 432
24893: MINUS
24894: GREATEREQUAL
24895: IFFALSE 24913
// mech := result [ i ] ;
24897: LD_ADDR_VAR 0 5
24901: PUSH
24902: LD_VAR 0 2
24906: PUSH
24907: LD_VAR 0 3
24911: ARRAY
24912: ST_TO_ADDR
// end ;
24913: GO 24822
24915: POP
24916: POP
// ComLinkTo ( vehicle , mech ) ;
24917: LD_VAR 0 1
24921: PPUSH
24922: LD_VAR 0 5
24926: PPUSH
24927: CALL_OW 135
// end ;
24931: LD_VAR 0 2
24935: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24936: LD_INT 0
24938: PPUSH
24939: PPUSH
24940: PPUSH
24941: PPUSH
24942: PPUSH
24943: PPUSH
24944: PPUSH
24945: PPUSH
24946: PPUSH
24947: PPUSH
24948: PPUSH
24949: PPUSH
24950: PPUSH
// result := [ ] ;
24951: LD_ADDR_VAR 0 7
24955: PUSH
24956: EMPTY
24957: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24958: LD_VAR 0 1
24962: PPUSH
24963: CALL_OW 266
24967: PUSH
24968: LD_INT 0
24970: PUSH
24971: LD_INT 1
24973: PUSH
24974: EMPTY
24975: LIST
24976: LIST
24977: IN
24978: NOT
24979: IFFALSE 24983
// exit ;
24981: GO 26614
// if name then
24983: LD_VAR 0 3
24987: IFFALSE 25003
// SetBName ( base_dep , name ) ;
24989: LD_VAR 0 1
24993: PPUSH
24994: LD_VAR 0 3
24998: PPUSH
24999: CALL_OW 500
// base := GetBase ( base_dep ) ;
25003: LD_ADDR_VAR 0 15
25007: PUSH
25008: LD_VAR 0 1
25012: PPUSH
25013: CALL_OW 274
25017: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
25018: LD_ADDR_VAR 0 16
25022: PUSH
25023: LD_VAR 0 1
25027: PPUSH
25028: CALL_OW 255
25032: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
25033: LD_ADDR_VAR 0 17
25037: PUSH
25038: LD_VAR 0 1
25042: PPUSH
25043: CALL_OW 248
25047: ST_TO_ADDR
// if sources then
25048: LD_VAR 0 5
25052: IFFALSE 25099
// for i = 1 to 3 do
25054: LD_ADDR_VAR 0 8
25058: PUSH
25059: DOUBLE
25060: LD_INT 1
25062: DEC
25063: ST_TO_ADDR
25064: LD_INT 3
25066: PUSH
25067: FOR_TO
25068: IFFALSE 25097
// AddResourceType ( base , i , sources [ i ] ) ;
25070: LD_VAR 0 15
25074: PPUSH
25075: LD_VAR 0 8
25079: PPUSH
25080: LD_VAR 0 5
25084: PUSH
25085: LD_VAR 0 8
25089: ARRAY
25090: PPUSH
25091: CALL_OW 276
25095: GO 25067
25097: POP
25098: POP
// buildings := GetBaseBuildings ( base , area ) ;
25099: LD_ADDR_VAR 0 18
25103: PUSH
25104: LD_VAR 0 15
25108: PPUSH
25109: LD_VAR 0 2
25113: PPUSH
25114: CALL 24391 0 2
25118: ST_TO_ADDR
// InitHc ;
25119: CALL_OW 19
// InitUc ;
25123: CALL_OW 18
// uc_side := side ;
25127: LD_ADDR_OWVAR 20
25131: PUSH
25132: LD_VAR 0 16
25136: ST_TO_ADDR
// uc_nation := nation ;
25137: LD_ADDR_OWVAR 21
25141: PUSH
25142: LD_VAR 0 17
25146: ST_TO_ADDR
// if buildings then
25147: LD_VAR 0 18
25151: IFFALSE 26473
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25153: LD_ADDR_VAR 0 19
25157: PUSH
25158: LD_VAR 0 18
25162: PPUSH
25163: LD_INT 2
25165: PUSH
25166: LD_INT 30
25168: PUSH
25169: LD_INT 29
25171: PUSH
25172: EMPTY
25173: LIST
25174: LIST
25175: PUSH
25176: LD_INT 30
25178: PUSH
25179: LD_INT 30
25181: PUSH
25182: EMPTY
25183: LIST
25184: LIST
25185: PUSH
25186: EMPTY
25187: LIST
25188: LIST
25189: LIST
25190: PPUSH
25191: CALL_OW 72
25195: ST_TO_ADDR
// if tmp then
25196: LD_VAR 0 19
25200: IFFALSE 25248
// for i in tmp do
25202: LD_ADDR_VAR 0 8
25206: PUSH
25207: LD_VAR 0 19
25211: PUSH
25212: FOR_IN
25213: IFFALSE 25246
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
25215: LD_VAR 0 8
25219: PPUSH
25220: CALL_OW 250
25224: PPUSH
25225: LD_VAR 0 8
25229: PPUSH
25230: CALL_OW 251
25234: PPUSH
25235: LD_VAR 0 16
25239: PPUSH
25240: CALL_OW 441
25244: GO 25212
25246: POP
25247: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
25248: LD_VAR 0 18
25252: PPUSH
25253: LD_INT 2
25255: PUSH
25256: LD_INT 30
25258: PUSH
25259: LD_INT 32
25261: PUSH
25262: EMPTY
25263: LIST
25264: LIST
25265: PUSH
25266: LD_INT 30
25268: PUSH
25269: LD_INT 33
25271: PUSH
25272: EMPTY
25273: LIST
25274: LIST
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: LIST
25280: PPUSH
25281: CALL_OW 72
25285: IFFALSE 25373
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25287: LD_ADDR_VAR 0 8
25291: PUSH
25292: LD_VAR 0 18
25296: PPUSH
25297: LD_INT 2
25299: PUSH
25300: LD_INT 30
25302: PUSH
25303: LD_INT 32
25305: PUSH
25306: EMPTY
25307: LIST
25308: LIST
25309: PUSH
25310: LD_INT 30
25312: PUSH
25313: LD_INT 33
25315: PUSH
25316: EMPTY
25317: LIST
25318: LIST
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: LIST
25324: PPUSH
25325: CALL_OW 72
25329: PUSH
25330: FOR_IN
25331: IFFALSE 25371
// begin if not GetBWeapon ( i ) then
25333: LD_VAR 0 8
25337: PPUSH
25338: CALL_OW 269
25342: NOT
25343: IFFALSE 25369
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25345: LD_VAR 0 8
25349: PPUSH
25350: LD_VAR 0 8
25354: PPUSH
25355: LD_VAR 0 2
25359: PPUSH
25360: CALL 26619 0 2
25364: PPUSH
25365: CALL_OW 431
// end ;
25369: GO 25330
25371: POP
25372: POP
// end ; for i = 1 to personel do
25373: LD_ADDR_VAR 0 8
25377: PUSH
25378: DOUBLE
25379: LD_INT 1
25381: DEC
25382: ST_TO_ADDR
25383: LD_VAR 0 6
25387: PUSH
25388: FOR_TO
25389: IFFALSE 26453
// begin if i > 4 then
25391: LD_VAR 0 8
25395: PUSH
25396: LD_INT 4
25398: GREATER
25399: IFFALSE 25403
// break ;
25401: GO 26453
// case i of 1 :
25403: LD_VAR 0 8
25407: PUSH
25408: LD_INT 1
25410: DOUBLE
25411: EQUAL
25412: IFTRUE 25416
25414: GO 25496
25416: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25417: LD_ADDR_VAR 0 12
25421: PUSH
25422: LD_VAR 0 18
25426: PPUSH
25427: LD_INT 22
25429: PUSH
25430: LD_VAR 0 16
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PUSH
25439: LD_INT 58
25441: PUSH
25442: EMPTY
25443: LIST
25444: PUSH
25445: LD_INT 2
25447: PUSH
25448: LD_INT 30
25450: PUSH
25451: LD_INT 32
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: PUSH
25458: LD_INT 30
25460: PUSH
25461: LD_INT 4
25463: PUSH
25464: EMPTY
25465: LIST
25466: LIST
25467: PUSH
25468: LD_INT 30
25470: PUSH
25471: LD_INT 5
25473: PUSH
25474: EMPTY
25475: LIST
25476: LIST
25477: PUSH
25478: EMPTY
25479: LIST
25480: LIST
25481: LIST
25482: LIST
25483: PUSH
25484: EMPTY
25485: LIST
25486: LIST
25487: LIST
25488: PPUSH
25489: CALL_OW 72
25493: ST_TO_ADDR
25494: GO 25718
25496: LD_INT 2
25498: DOUBLE
25499: EQUAL
25500: IFTRUE 25504
25502: GO 25566
25504: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25505: LD_ADDR_VAR 0 12
25509: PUSH
25510: LD_VAR 0 18
25514: PPUSH
25515: LD_INT 22
25517: PUSH
25518: LD_VAR 0 16
25522: PUSH
25523: EMPTY
25524: LIST
25525: LIST
25526: PUSH
25527: LD_INT 2
25529: PUSH
25530: LD_INT 30
25532: PUSH
25533: LD_INT 0
25535: PUSH
25536: EMPTY
25537: LIST
25538: LIST
25539: PUSH
25540: LD_INT 30
25542: PUSH
25543: LD_INT 1
25545: PUSH
25546: EMPTY
25547: LIST
25548: LIST
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: LIST
25554: PUSH
25555: EMPTY
25556: LIST
25557: LIST
25558: PPUSH
25559: CALL_OW 72
25563: ST_TO_ADDR
25564: GO 25718
25566: LD_INT 3
25568: DOUBLE
25569: EQUAL
25570: IFTRUE 25574
25572: GO 25636
25574: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25575: LD_ADDR_VAR 0 12
25579: PUSH
25580: LD_VAR 0 18
25584: PPUSH
25585: LD_INT 22
25587: PUSH
25588: LD_VAR 0 16
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 2
25599: PUSH
25600: LD_INT 30
25602: PUSH
25603: LD_INT 2
25605: PUSH
25606: EMPTY
25607: LIST
25608: LIST
25609: PUSH
25610: LD_INT 30
25612: PUSH
25613: LD_INT 3
25615: PUSH
25616: EMPTY
25617: LIST
25618: LIST
25619: PUSH
25620: EMPTY
25621: LIST
25622: LIST
25623: LIST
25624: PUSH
25625: EMPTY
25626: LIST
25627: LIST
25628: PPUSH
25629: CALL_OW 72
25633: ST_TO_ADDR
25634: GO 25718
25636: LD_INT 4
25638: DOUBLE
25639: EQUAL
25640: IFTRUE 25644
25642: GO 25717
25644: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25645: LD_ADDR_VAR 0 12
25649: PUSH
25650: LD_VAR 0 18
25654: PPUSH
25655: LD_INT 22
25657: PUSH
25658: LD_VAR 0 16
25662: PUSH
25663: EMPTY
25664: LIST
25665: LIST
25666: PUSH
25667: LD_INT 2
25669: PUSH
25670: LD_INT 30
25672: PUSH
25673: LD_INT 6
25675: PUSH
25676: EMPTY
25677: LIST
25678: LIST
25679: PUSH
25680: LD_INT 30
25682: PUSH
25683: LD_INT 7
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: PUSH
25690: LD_INT 30
25692: PUSH
25693: LD_INT 8
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: LIST
25704: LIST
25705: PUSH
25706: EMPTY
25707: LIST
25708: LIST
25709: PPUSH
25710: CALL_OW 72
25714: ST_TO_ADDR
25715: GO 25718
25717: POP
// if i = 1 then
25718: LD_VAR 0 8
25722: PUSH
25723: LD_INT 1
25725: EQUAL
25726: IFFALSE 25837
// begin tmp := [ ] ;
25728: LD_ADDR_VAR 0 19
25732: PUSH
25733: EMPTY
25734: ST_TO_ADDR
// for j in f do
25735: LD_ADDR_VAR 0 9
25739: PUSH
25740: LD_VAR 0 12
25744: PUSH
25745: FOR_IN
25746: IFFALSE 25819
// if GetBType ( j ) = b_bunker then
25748: LD_VAR 0 9
25752: PPUSH
25753: CALL_OW 266
25757: PUSH
25758: LD_INT 32
25760: EQUAL
25761: IFFALSE 25788
// tmp := Insert ( tmp , 1 , j ) else
25763: LD_ADDR_VAR 0 19
25767: PUSH
25768: LD_VAR 0 19
25772: PPUSH
25773: LD_INT 1
25775: PPUSH
25776: LD_VAR 0 9
25780: PPUSH
25781: CALL_OW 2
25785: ST_TO_ADDR
25786: GO 25817
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25788: LD_ADDR_VAR 0 19
25792: PUSH
25793: LD_VAR 0 19
25797: PPUSH
25798: LD_VAR 0 19
25802: PUSH
25803: LD_INT 1
25805: PLUS
25806: PPUSH
25807: LD_VAR 0 9
25811: PPUSH
25812: CALL_OW 2
25816: ST_TO_ADDR
25817: GO 25745
25819: POP
25820: POP
// if tmp then
25821: LD_VAR 0 19
25825: IFFALSE 25837
// f := tmp ;
25827: LD_ADDR_VAR 0 12
25831: PUSH
25832: LD_VAR 0 19
25836: ST_TO_ADDR
// end ; x := personel [ i ] ;
25837: LD_ADDR_VAR 0 13
25841: PUSH
25842: LD_VAR 0 6
25846: PUSH
25847: LD_VAR 0 8
25851: ARRAY
25852: ST_TO_ADDR
// if x = - 1 then
25853: LD_VAR 0 13
25857: PUSH
25858: LD_INT 1
25860: NEG
25861: EQUAL
25862: IFFALSE 26071
// begin for j in f do
25864: LD_ADDR_VAR 0 9
25868: PUSH
25869: LD_VAR 0 12
25873: PUSH
25874: FOR_IN
25875: IFFALSE 26067
// repeat InitHc ;
25877: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25881: LD_VAR 0 9
25885: PPUSH
25886: CALL_OW 266
25890: PUSH
25891: LD_INT 5
25893: EQUAL
25894: IFFALSE 25964
// begin if UnitsInside ( j ) < 3 then
25896: LD_VAR 0 9
25900: PPUSH
25901: CALL_OW 313
25905: PUSH
25906: LD_INT 3
25908: LESS
25909: IFFALSE 25945
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25911: LD_INT 0
25913: PPUSH
25914: LD_INT 5
25916: PUSH
25917: LD_INT 8
25919: PUSH
25920: LD_INT 9
25922: PUSH
25923: EMPTY
25924: LIST
25925: LIST
25926: LIST
25927: PUSH
25928: LD_VAR 0 17
25932: ARRAY
25933: PPUSH
25934: LD_VAR 0 4
25938: PPUSH
25939: CALL_OW 380
25943: GO 25962
// PrepareHuman ( false , i , skill ) ;
25945: LD_INT 0
25947: PPUSH
25948: LD_VAR 0 8
25952: PPUSH
25953: LD_VAR 0 4
25957: PPUSH
25958: CALL_OW 380
// end else
25962: GO 25981
// PrepareHuman ( false , i , skill ) ;
25964: LD_INT 0
25966: PPUSH
25967: LD_VAR 0 8
25971: PPUSH
25972: LD_VAR 0 4
25976: PPUSH
25977: CALL_OW 380
// un := CreateHuman ;
25981: LD_ADDR_VAR 0 14
25985: PUSH
25986: CALL_OW 44
25990: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25991: LD_ADDR_VAR 0 7
25995: PUSH
25996: LD_VAR 0 7
26000: PPUSH
26001: LD_INT 1
26003: PPUSH
26004: LD_VAR 0 14
26008: PPUSH
26009: CALL_OW 2
26013: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
26014: LD_VAR 0 14
26018: PPUSH
26019: LD_VAR 0 9
26023: PPUSH
26024: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
26028: LD_VAR 0 9
26032: PPUSH
26033: CALL_OW 313
26037: PUSH
26038: LD_INT 6
26040: EQUAL
26041: PUSH
26042: LD_VAR 0 9
26046: PPUSH
26047: CALL_OW 266
26051: PUSH
26052: LD_INT 32
26054: PUSH
26055: LD_INT 31
26057: PUSH
26058: EMPTY
26059: LIST
26060: LIST
26061: IN
26062: OR
26063: IFFALSE 25877
26065: GO 25874
26067: POP
26068: POP
// end else
26069: GO 26451
// for j = 1 to x do
26071: LD_ADDR_VAR 0 9
26075: PUSH
26076: DOUBLE
26077: LD_INT 1
26079: DEC
26080: ST_TO_ADDR
26081: LD_VAR 0 13
26085: PUSH
26086: FOR_TO
26087: IFFALSE 26449
// begin InitHc ;
26089: CALL_OW 19
// if not f then
26093: LD_VAR 0 12
26097: NOT
26098: IFFALSE 26187
// begin PrepareHuman ( false , i , skill ) ;
26100: LD_INT 0
26102: PPUSH
26103: LD_VAR 0 8
26107: PPUSH
26108: LD_VAR 0 4
26112: PPUSH
26113: CALL_OW 380
// un := CreateHuman ;
26117: LD_ADDR_VAR 0 14
26121: PUSH
26122: CALL_OW 44
26126: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26127: LD_ADDR_VAR 0 7
26131: PUSH
26132: LD_VAR 0 7
26136: PPUSH
26137: LD_INT 1
26139: PPUSH
26140: LD_VAR 0 14
26144: PPUSH
26145: CALL_OW 2
26149: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26150: LD_VAR 0 14
26154: PPUSH
26155: LD_VAR 0 1
26159: PPUSH
26160: CALL_OW 250
26164: PPUSH
26165: LD_VAR 0 1
26169: PPUSH
26170: CALL_OW 251
26174: PPUSH
26175: LD_INT 10
26177: PPUSH
26178: LD_INT 0
26180: PPUSH
26181: CALL_OW 50
// continue ;
26185: GO 26086
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26187: LD_VAR 0 12
26191: PUSH
26192: LD_INT 1
26194: ARRAY
26195: PPUSH
26196: CALL_OW 313
26200: PUSH
26201: LD_VAR 0 12
26205: PUSH
26206: LD_INT 1
26208: ARRAY
26209: PPUSH
26210: CALL_OW 266
26214: PUSH
26215: LD_INT 32
26217: PUSH
26218: LD_INT 31
26220: PUSH
26221: EMPTY
26222: LIST
26223: LIST
26224: IN
26225: AND
26226: PUSH
26227: LD_VAR 0 12
26231: PUSH
26232: LD_INT 1
26234: ARRAY
26235: PPUSH
26236: CALL_OW 313
26240: PUSH
26241: LD_INT 6
26243: EQUAL
26244: OR
26245: IFFALSE 26265
// f := Delete ( f , 1 ) ;
26247: LD_ADDR_VAR 0 12
26251: PUSH
26252: LD_VAR 0 12
26256: PPUSH
26257: LD_INT 1
26259: PPUSH
26260: CALL_OW 3
26264: ST_TO_ADDR
// if not f then
26265: LD_VAR 0 12
26269: NOT
26270: IFFALSE 26288
// begin x := x + 2 ;
26272: LD_ADDR_VAR 0 13
26276: PUSH
26277: LD_VAR 0 13
26281: PUSH
26282: LD_INT 2
26284: PLUS
26285: ST_TO_ADDR
// continue ;
26286: GO 26086
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26288: LD_VAR 0 12
26292: PUSH
26293: LD_INT 1
26295: ARRAY
26296: PPUSH
26297: CALL_OW 266
26301: PUSH
26302: LD_INT 5
26304: EQUAL
26305: IFFALSE 26379
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26307: LD_VAR 0 12
26311: PUSH
26312: LD_INT 1
26314: ARRAY
26315: PPUSH
26316: CALL_OW 313
26320: PUSH
26321: LD_INT 3
26323: LESS
26324: IFFALSE 26360
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26326: LD_INT 0
26328: PPUSH
26329: LD_INT 5
26331: PUSH
26332: LD_INT 8
26334: PUSH
26335: LD_INT 9
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: LIST
26342: PUSH
26343: LD_VAR 0 17
26347: ARRAY
26348: PPUSH
26349: LD_VAR 0 4
26353: PPUSH
26354: CALL_OW 380
26358: GO 26377
// PrepareHuman ( false , i , skill ) ;
26360: LD_INT 0
26362: PPUSH
26363: LD_VAR 0 8
26367: PPUSH
26368: LD_VAR 0 4
26372: PPUSH
26373: CALL_OW 380
// end else
26377: GO 26396
// PrepareHuman ( false , i , skill ) ;
26379: LD_INT 0
26381: PPUSH
26382: LD_VAR 0 8
26386: PPUSH
26387: LD_VAR 0 4
26391: PPUSH
26392: CALL_OW 380
// un := CreateHuman ;
26396: LD_ADDR_VAR 0 14
26400: PUSH
26401: CALL_OW 44
26405: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26406: LD_ADDR_VAR 0 7
26410: PUSH
26411: LD_VAR 0 7
26415: PPUSH
26416: LD_INT 1
26418: PPUSH
26419: LD_VAR 0 14
26423: PPUSH
26424: CALL_OW 2
26428: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26429: LD_VAR 0 14
26433: PPUSH
26434: LD_VAR 0 12
26438: PUSH
26439: LD_INT 1
26441: ARRAY
26442: PPUSH
26443: CALL_OW 52
// end ;
26447: GO 26086
26449: POP
26450: POP
// end ;
26451: GO 25388
26453: POP
26454: POP
// result := result ^ buildings ;
26455: LD_ADDR_VAR 0 7
26459: PUSH
26460: LD_VAR 0 7
26464: PUSH
26465: LD_VAR 0 18
26469: ADD
26470: ST_TO_ADDR
// end else
26471: GO 26614
// begin for i = 1 to personel do
26473: LD_ADDR_VAR 0 8
26477: PUSH
26478: DOUBLE
26479: LD_INT 1
26481: DEC
26482: ST_TO_ADDR
26483: LD_VAR 0 6
26487: PUSH
26488: FOR_TO
26489: IFFALSE 26612
// begin if i > 4 then
26491: LD_VAR 0 8
26495: PUSH
26496: LD_INT 4
26498: GREATER
26499: IFFALSE 26503
// break ;
26501: GO 26612
// x := personel [ i ] ;
26503: LD_ADDR_VAR 0 13
26507: PUSH
26508: LD_VAR 0 6
26512: PUSH
26513: LD_VAR 0 8
26517: ARRAY
26518: ST_TO_ADDR
// if x = - 1 then
26519: LD_VAR 0 13
26523: PUSH
26524: LD_INT 1
26526: NEG
26527: EQUAL
26528: IFFALSE 26532
// continue ;
26530: GO 26488
// PrepareHuman ( false , i , skill ) ;
26532: LD_INT 0
26534: PPUSH
26535: LD_VAR 0 8
26539: PPUSH
26540: LD_VAR 0 4
26544: PPUSH
26545: CALL_OW 380
// un := CreateHuman ;
26549: LD_ADDR_VAR 0 14
26553: PUSH
26554: CALL_OW 44
26558: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26559: LD_VAR 0 14
26563: PPUSH
26564: LD_VAR 0 1
26568: PPUSH
26569: CALL_OW 250
26573: PPUSH
26574: LD_VAR 0 1
26578: PPUSH
26579: CALL_OW 251
26583: PPUSH
26584: LD_INT 10
26586: PPUSH
26587: LD_INT 0
26589: PPUSH
26590: CALL_OW 50
// result := result ^ un ;
26594: LD_ADDR_VAR 0 7
26598: PUSH
26599: LD_VAR 0 7
26603: PUSH
26604: LD_VAR 0 14
26608: ADD
26609: ST_TO_ADDR
// end ;
26610: GO 26488
26612: POP
26613: POP
// end ; end ;
26614: LD_VAR 0 7
26618: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26619: LD_INT 0
26621: PPUSH
26622: PPUSH
26623: PPUSH
26624: PPUSH
26625: PPUSH
26626: PPUSH
26627: PPUSH
26628: PPUSH
26629: PPUSH
26630: PPUSH
26631: PPUSH
26632: PPUSH
26633: PPUSH
26634: PPUSH
26635: PPUSH
26636: PPUSH
// result := false ;
26637: LD_ADDR_VAR 0 3
26641: PUSH
26642: LD_INT 0
26644: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26645: LD_VAR 0 1
26649: NOT
26650: PUSH
26651: LD_VAR 0 1
26655: PPUSH
26656: CALL_OW 266
26660: PUSH
26661: LD_INT 32
26663: PUSH
26664: LD_INT 33
26666: PUSH
26667: EMPTY
26668: LIST
26669: LIST
26670: IN
26671: NOT
26672: OR
26673: IFFALSE 26677
// exit ;
26675: GO 27813
// nat := GetNation ( tower ) ;
26677: LD_ADDR_VAR 0 12
26681: PUSH
26682: LD_VAR 0 1
26686: PPUSH
26687: CALL_OW 248
26691: ST_TO_ADDR
// side := GetSide ( tower ) ;
26692: LD_ADDR_VAR 0 16
26696: PUSH
26697: LD_VAR 0 1
26701: PPUSH
26702: CALL_OW 255
26706: ST_TO_ADDR
// x := GetX ( tower ) ;
26707: LD_ADDR_VAR 0 10
26711: PUSH
26712: LD_VAR 0 1
26716: PPUSH
26717: CALL_OW 250
26721: ST_TO_ADDR
// y := GetY ( tower ) ;
26722: LD_ADDR_VAR 0 11
26726: PUSH
26727: LD_VAR 0 1
26731: PPUSH
26732: CALL_OW 251
26736: ST_TO_ADDR
// if not x or not y then
26737: LD_VAR 0 10
26741: NOT
26742: PUSH
26743: LD_VAR 0 11
26747: NOT
26748: OR
26749: IFFALSE 26753
// exit ;
26751: GO 27813
// weapon := 0 ;
26753: LD_ADDR_VAR 0 18
26757: PUSH
26758: LD_INT 0
26760: ST_TO_ADDR
// fac_list := [ ] ;
26761: LD_ADDR_VAR 0 17
26765: PUSH
26766: EMPTY
26767: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
26768: LD_ADDR_VAR 0 6
26772: PUSH
26773: LD_VAR 0 1
26777: PPUSH
26778: CALL_OW 274
26782: PPUSH
26783: LD_VAR 0 2
26787: PPUSH
26788: CALL 24391 0 2
26792: PPUSH
26793: LD_INT 30
26795: PUSH
26796: LD_INT 3
26798: PUSH
26799: EMPTY
26800: LIST
26801: LIST
26802: PPUSH
26803: CALL_OW 72
26807: ST_TO_ADDR
// if not factories then
26808: LD_VAR 0 6
26812: NOT
26813: IFFALSE 26817
// exit ;
26815: GO 27813
// for i in factories do
26817: LD_ADDR_VAR 0 8
26821: PUSH
26822: LD_VAR 0 6
26826: PUSH
26827: FOR_IN
26828: IFFALSE 26853
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26830: LD_ADDR_VAR 0 17
26834: PUSH
26835: LD_VAR 0 17
26839: PUSH
26840: LD_VAR 0 8
26844: PPUSH
26845: CALL_OW 478
26849: UNION
26850: ST_TO_ADDR
26851: GO 26827
26853: POP
26854: POP
// if not fac_list then
26855: LD_VAR 0 17
26859: NOT
26860: IFFALSE 26864
// exit ;
26862: GO 27813
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26864: LD_ADDR_VAR 0 5
26868: PUSH
26869: LD_INT 4
26871: PUSH
26872: LD_INT 5
26874: PUSH
26875: LD_INT 9
26877: PUSH
26878: LD_INT 10
26880: PUSH
26881: LD_INT 6
26883: PUSH
26884: LD_INT 7
26886: PUSH
26887: LD_INT 11
26889: PUSH
26890: EMPTY
26891: LIST
26892: LIST
26893: LIST
26894: LIST
26895: LIST
26896: LIST
26897: LIST
26898: PUSH
26899: LD_INT 27
26901: PUSH
26902: LD_INT 28
26904: PUSH
26905: LD_INT 26
26907: PUSH
26908: LD_INT 30
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: LIST
26915: LIST
26916: PUSH
26917: LD_INT 43
26919: PUSH
26920: LD_INT 44
26922: PUSH
26923: LD_INT 46
26925: PUSH
26926: LD_INT 45
26928: PUSH
26929: LD_INT 47
26931: PUSH
26932: LD_INT 49
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: LIST
26939: LIST
26940: LIST
26941: LIST
26942: PUSH
26943: EMPTY
26944: LIST
26945: LIST
26946: LIST
26947: PUSH
26948: LD_VAR 0 12
26952: ARRAY
26953: ST_TO_ADDR
// for i in list do
26954: LD_ADDR_VAR 0 8
26958: PUSH
26959: LD_VAR 0 5
26963: PUSH
26964: FOR_IN
26965: IFFALSE 26998
// if not i in fac_list then
26967: LD_VAR 0 8
26971: PUSH
26972: LD_VAR 0 17
26976: IN
26977: NOT
26978: IFFALSE 26996
// list := list diff i ;
26980: LD_ADDR_VAR 0 5
26984: PUSH
26985: LD_VAR 0 5
26989: PUSH
26990: LD_VAR 0 8
26994: DIFF
26995: ST_TO_ADDR
26996: GO 26964
26998: POP
26999: POP
// if not list then
27000: LD_VAR 0 5
27004: NOT
27005: IFFALSE 27009
// exit ;
27007: GO 27813
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
27009: LD_VAR 0 12
27013: PUSH
27014: LD_INT 3
27016: EQUAL
27017: PUSH
27018: LD_INT 49
27020: PUSH
27021: LD_VAR 0 5
27025: IN
27026: AND
27027: PUSH
27028: LD_INT 31
27030: PPUSH
27031: LD_VAR 0 16
27035: PPUSH
27036: CALL_OW 321
27040: PUSH
27041: LD_INT 2
27043: EQUAL
27044: AND
27045: IFFALSE 27105
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
27047: LD_INT 22
27049: PUSH
27050: LD_VAR 0 16
27054: PUSH
27055: EMPTY
27056: LIST
27057: LIST
27058: PUSH
27059: LD_INT 35
27061: PUSH
27062: LD_INT 49
27064: PUSH
27065: EMPTY
27066: LIST
27067: LIST
27068: PUSH
27069: LD_INT 91
27071: PUSH
27072: LD_VAR 0 1
27076: PUSH
27077: LD_INT 10
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: LIST
27084: PUSH
27085: EMPTY
27086: LIST
27087: LIST
27088: LIST
27089: PPUSH
27090: CALL_OW 69
27094: NOT
27095: IFFALSE 27105
// weapon := ru_time_lapser ;
27097: LD_ADDR_VAR 0 18
27101: PUSH
27102: LD_INT 49
27104: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
27105: LD_VAR 0 12
27109: PUSH
27110: LD_INT 1
27112: PUSH
27113: LD_INT 2
27115: PUSH
27116: EMPTY
27117: LIST
27118: LIST
27119: IN
27120: PUSH
27121: LD_INT 11
27123: PUSH
27124: LD_VAR 0 5
27128: IN
27129: PUSH
27130: LD_INT 30
27132: PUSH
27133: LD_VAR 0 5
27137: IN
27138: OR
27139: AND
27140: PUSH
27141: LD_INT 6
27143: PPUSH
27144: LD_VAR 0 16
27148: PPUSH
27149: CALL_OW 321
27153: PUSH
27154: LD_INT 2
27156: EQUAL
27157: AND
27158: IFFALSE 27323
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27160: LD_INT 22
27162: PUSH
27163: LD_VAR 0 16
27167: PUSH
27168: EMPTY
27169: LIST
27170: LIST
27171: PUSH
27172: LD_INT 2
27174: PUSH
27175: LD_INT 35
27177: PUSH
27178: LD_INT 11
27180: PUSH
27181: EMPTY
27182: LIST
27183: LIST
27184: PUSH
27185: LD_INT 35
27187: PUSH
27188: LD_INT 30
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: EMPTY
27196: LIST
27197: LIST
27198: LIST
27199: PUSH
27200: LD_INT 91
27202: PUSH
27203: LD_VAR 0 1
27207: PUSH
27208: LD_INT 18
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: LIST
27215: PUSH
27216: EMPTY
27217: LIST
27218: LIST
27219: LIST
27220: PPUSH
27221: CALL_OW 69
27225: NOT
27226: PUSH
27227: LD_INT 22
27229: PUSH
27230: LD_VAR 0 16
27234: PUSH
27235: EMPTY
27236: LIST
27237: LIST
27238: PUSH
27239: LD_INT 2
27241: PUSH
27242: LD_INT 30
27244: PUSH
27245: LD_INT 32
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: PUSH
27252: LD_INT 30
27254: PUSH
27255: LD_INT 33
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: LIST
27266: PUSH
27267: LD_INT 91
27269: PUSH
27270: LD_VAR 0 1
27274: PUSH
27275: LD_INT 12
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: LIST
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: LIST
27287: PUSH
27288: EMPTY
27289: LIST
27290: PPUSH
27291: CALL_OW 69
27295: PUSH
27296: LD_INT 2
27298: GREATER
27299: AND
27300: IFFALSE 27323
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27302: LD_ADDR_VAR 0 18
27306: PUSH
27307: LD_INT 11
27309: PUSH
27310: LD_INT 30
27312: PUSH
27313: EMPTY
27314: LIST
27315: LIST
27316: PUSH
27317: LD_VAR 0 12
27321: ARRAY
27322: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27323: LD_VAR 0 18
27327: NOT
27328: PUSH
27329: LD_INT 40
27331: PPUSH
27332: LD_VAR 0 16
27336: PPUSH
27337: CALL_OW 321
27341: PUSH
27342: LD_INT 2
27344: EQUAL
27345: AND
27346: PUSH
27347: LD_INT 7
27349: PUSH
27350: LD_VAR 0 5
27354: IN
27355: PUSH
27356: LD_INT 28
27358: PUSH
27359: LD_VAR 0 5
27363: IN
27364: OR
27365: PUSH
27366: LD_INT 45
27368: PUSH
27369: LD_VAR 0 5
27373: IN
27374: OR
27375: AND
27376: IFFALSE 27630
// begin hex := GetHexInfo ( x , y ) ;
27378: LD_ADDR_VAR 0 4
27382: PUSH
27383: LD_VAR 0 10
27387: PPUSH
27388: LD_VAR 0 11
27392: PPUSH
27393: CALL_OW 546
27397: ST_TO_ADDR
// if hex [ 1 ] then
27398: LD_VAR 0 4
27402: PUSH
27403: LD_INT 1
27405: ARRAY
27406: IFFALSE 27410
// exit ;
27408: GO 27813
// height := hex [ 2 ] ;
27410: LD_ADDR_VAR 0 15
27414: PUSH
27415: LD_VAR 0 4
27419: PUSH
27420: LD_INT 2
27422: ARRAY
27423: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27424: LD_ADDR_VAR 0 14
27428: PUSH
27429: LD_INT 0
27431: PUSH
27432: LD_INT 2
27434: PUSH
27435: LD_INT 3
27437: PUSH
27438: LD_INT 5
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: LIST
27445: LIST
27446: ST_TO_ADDR
// for i in tmp do
27447: LD_ADDR_VAR 0 8
27451: PUSH
27452: LD_VAR 0 14
27456: PUSH
27457: FOR_IN
27458: IFFALSE 27628
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27460: LD_ADDR_VAR 0 9
27464: PUSH
27465: LD_VAR 0 10
27469: PPUSH
27470: LD_VAR 0 8
27474: PPUSH
27475: LD_INT 5
27477: PPUSH
27478: CALL_OW 272
27482: PUSH
27483: LD_VAR 0 11
27487: PPUSH
27488: LD_VAR 0 8
27492: PPUSH
27493: LD_INT 5
27495: PPUSH
27496: CALL_OW 273
27500: PUSH
27501: EMPTY
27502: LIST
27503: LIST
27504: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27505: LD_VAR 0 9
27509: PUSH
27510: LD_INT 1
27512: ARRAY
27513: PPUSH
27514: LD_VAR 0 9
27518: PUSH
27519: LD_INT 2
27521: ARRAY
27522: PPUSH
27523: CALL_OW 488
27527: IFFALSE 27626
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27529: LD_ADDR_VAR 0 4
27533: PUSH
27534: LD_VAR 0 9
27538: PUSH
27539: LD_INT 1
27541: ARRAY
27542: PPUSH
27543: LD_VAR 0 9
27547: PUSH
27548: LD_INT 2
27550: ARRAY
27551: PPUSH
27552: CALL_OW 546
27556: ST_TO_ADDR
// if hex [ 1 ] then
27557: LD_VAR 0 4
27561: PUSH
27562: LD_INT 1
27564: ARRAY
27565: IFFALSE 27569
// continue ;
27567: GO 27457
// h := hex [ 2 ] ;
27569: LD_ADDR_VAR 0 13
27573: PUSH
27574: LD_VAR 0 4
27578: PUSH
27579: LD_INT 2
27581: ARRAY
27582: ST_TO_ADDR
// if h + 7 < height then
27583: LD_VAR 0 13
27587: PUSH
27588: LD_INT 7
27590: PLUS
27591: PUSH
27592: LD_VAR 0 15
27596: LESS
27597: IFFALSE 27626
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27599: LD_ADDR_VAR 0 18
27603: PUSH
27604: LD_INT 7
27606: PUSH
27607: LD_INT 28
27609: PUSH
27610: LD_INT 45
27612: PUSH
27613: EMPTY
27614: LIST
27615: LIST
27616: LIST
27617: PUSH
27618: LD_VAR 0 12
27622: ARRAY
27623: ST_TO_ADDR
// break ;
27624: GO 27628
// end ; end ; end ;
27626: GO 27457
27628: POP
27629: POP
// end ; if not weapon then
27630: LD_VAR 0 18
27634: NOT
27635: IFFALSE 27695
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27637: LD_ADDR_VAR 0 5
27641: PUSH
27642: LD_VAR 0 5
27646: PUSH
27647: LD_INT 11
27649: PUSH
27650: LD_INT 30
27652: PUSH
27653: LD_INT 49
27655: PUSH
27656: EMPTY
27657: LIST
27658: LIST
27659: LIST
27660: DIFF
27661: ST_TO_ADDR
// if not list then
27662: LD_VAR 0 5
27666: NOT
27667: IFFALSE 27671
// exit ;
27669: GO 27813
// weapon := list [ rand ( 1 , list ) ] ;
27671: LD_ADDR_VAR 0 18
27675: PUSH
27676: LD_VAR 0 5
27680: PUSH
27681: LD_INT 1
27683: PPUSH
27684: LD_VAR 0 5
27688: PPUSH
27689: CALL_OW 12
27693: ARRAY
27694: ST_TO_ADDR
// end ; if weapon then
27695: LD_VAR 0 18
27699: IFFALSE 27813
// begin tmp := CostOfWeapon ( weapon ) ;
27701: LD_ADDR_VAR 0 14
27705: PUSH
27706: LD_VAR 0 18
27710: PPUSH
27711: CALL_OW 451
27715: ST_TO_ADDR
// j := GetBase ( tower ) ;
27716: LD_ADDR_VAR 0 9
27720: PUSH
27721: LD_VAR 0 1
27725: PPUSH
27726: CALL_OW 274
27730: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27731: LD_VAR 0 9
27735: PPUSH
27736: LD_INT 1
27738: PPUSH
27739: CALL_OW 275
27743: PUSH
27744: LD_VAR 0 14
27748: PUSH
27749: LD_INT 1
27751: ARRAY
27752: GREATEREQUAL
27753: PUSH
27754: LD_VAR 0 9
27758: PPUSH
27759: LD_INT 2
27761: PPUSH
27762: CALL_OW 275
27766: PUSH
27767: LD_VAR 0 14
27771: PUSH
27772: LD_INT 2
27774: ARRAY
27775: GREATEREQUAL
27776: AND
27777: PUSH
27778: LD_VAR 0 9
27782: PPUSH
27783: LD_INT 3
27785: PPUSH
27786: CALL_OW 275
27790: PUSH
27791: LD_VAR 0 14
27795: PUSH
27796: LD_INT 3
27798: ARRAY
27799: GREATEREQUAL
27800: AND
27801: IFFALSE 27813
// result := weapon ;
27803: LD_ADDR_VAR 0 3
27807: PUSH
27808: LD_VAR 0 18
27812: ST_TO_ADDR
// end ; end ;
27813: LD_VAR 0 3
27817: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27818: LD_INT 0
27820: PPUSH
27821: PPUSH
// result := true ;
27822: LD_ADDR_VAR 0 3
27826: PUSH
27827: LD_INT 1
27829: ST_TO_ADDR
// if array1 = array2 then
27830: LD_VAR 0 1
27834: PUSH
27835: LD_VAR 0 2
27839: EQUAL
27840: IFFALSE 27900
// begin for i = 1 to array1 do
27842: LD_ADDR_VAR 0 4
27846: PUSH
27847: DOUBLE
27848: LD_INT 1
27850: DEC
27851: ST_TO_ADDR
27852: LD_VAR 0 1
27856: PUSH
27857: FOR_TO
27858: IFFALSE 27896
// if array1 [ i ] <> array2 [ i ] then
27860: LD_VAR 0 1
27864: PUSH
27865: LD_VAR 0 4
27869: ARRAY
27870: PUSH
27871: LD_VAR 0 2
27875: PUSH
27876: LD_VAR 0 4
27880: ARRAY
27881: NONEQUAL
27882: IFFALSE 27894
// begin result := false ;
27884: LD_ADDR_VAR 0 3
27888: PUSH
27889: LD_INT 0
27891: ST_TO_ADDR
// break ;
27892: GO 27896
// end ;
27894: GO 27857
27896: POP
27897: POP
// end else
27898: GO 27908
// result := false ;
27900: LD_ADDR_VAR 0 3
27904: PUSH
27905: LD_INT 0
27907: ST_TO_ADDR
// end ;
27908: LD_VAR 0 3
27912: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27913: LD_INT 0
27915: PPUSH
27916: PPUSH
27917: PPUSH
// pom := GetBase ( fac ) ;
27918: LD_ADDR_VAR 0 5
27922: PUSH
27923: LD_VAR 0 1
27927: PPUSH
27928: CALL_OW 274
27932: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27933: LD_ADDR_VAR 0 4
27937: PUSH
27938: LD_VAR 0 2
27942: PUSH
27943: LD_INT 1
27945: ARRAY
27946: PPUSH
27947: LD_VAR 0 2
27951: PUSH
27952: LD_INT 2
27954: ARRAY
27955: PPUSH
27956: LD_VAR 0 2
27960: PUSH
27961: LD_INT 3
27963: ARRAY
27964: PPUSH
27965: LD_VAR 0 2
27969: PUSH
27970: LD_INT 4
27972: ARRAY
27973: PPUSH
27974: CALL_OW 449
27978: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27979: LD_ADDR_VAR 0 3
27983: PUSH
27984: LD_VAR 0 5
27988: PPUSH
27989: LD_INT 1
27991: PPUSH
27992: CALL_OW 275
27996: PUSH
27997: LD_VAR 0 4
28001: PUSH
28002: LD_INT 1
28004: ARRAY
28005: GREATEREQUAL
28006: PUSH
28007: LD_VAR 0 5
28011: PPUSH
28012: LD_INT 2
28014: PPUSH
28015: CALL_OW 275
28019: PUSH
28020: LD_VAR 0 4
28024: PUSH
28025: LD_INT 2
28027: ARRAY
28028: GREATEREQUAL
28029: AND
28030: PUSH
28031: LD_VAR 0 5
28035: PPUSH
28036: LD_INT 3
28038: PPUSH
28039: CALL_OW 275
28043: PUSH
28044: LD_VAR 0 4
28048: PUSH
28049: LD_INT 3
28051: ARRAY
28052: GREATEREQUAL
28053: AND
28054: ST_TO_ADDR
// end ;
28055: LD_VAR 0 3
28059: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
28060: LD_INT 0
28062: PPUSH
28063: PPUSH
28064: PPUSH
28065: PPUSH
// pom := GetBase ( building ) ;
28066: LD_ADDR_VAR 0 3
28070: PUSH
28071: LD_VAR 0 1
28075: PPUSH
28076: CALL_OW 274
28080: ST_TO_ADDR
// if not pom then
28081: LD_VAR 0 3
28085: NOT
28086: IFFALSE 28090
// exit ;
28088: GO 28260
// btype := GetBType ( building ) ;
28090: LD_ADDR_VAR 0 5
28094: PUSH
28095: LD_VAR 0 1
28099: PPUSH
28100: CALL_OW 266
28104: ST_TO_ADDR
// if btype = b_armoury then
28105: LD_VAR 0 5
28109: PUSH
28110: LD_INT 4
28112: EQUAL
28113: IFFALSE 28123
// btype := b_barracks ;
28115: LD_ADDR_VAR 0 5
28119: PUSH
28120: LD_INT 5
28122: ST_TO_ADDR
// if btype = b_depot then
28123: LD_VAR 0 5
28127: PUSH
28128: LD_INT 0
28130: EQUAL
28131: IFFALSE 28141
// btype := b_warehouse ;
28133: LD_ADDR_VAR 0 5
28137: PUSH
28138: LD_INT 1
28140: ST_TO_ADDR
// if btype = b_workshop then
28141: LD_VAR 0 5
28145: PUSH
28146: LD_INT 2
28148: EQUAL
28149: IFFALSE 28159
// btype := b_factory ;
28151: LD_ADDR_VAR 0 5
28155: PUSH
28156: LD_INT 3
28158: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28159: LD_ADDR_VAR 0 4
28163: PUSH
28164: LD_VAR 0 5
28168: PPUSH
28169: LD_VAR 0 1
28173: PPUSH
28174: CALL_OW 248
28178: PPUSH
28179: CALL_OW 450
28183: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28184: LD_ADDR_VAR 0 2
28188: PUSH
28189: LD_VAR 0 3
28193: PPUSH
28194: LD_INT 1
28196: PPUSH
28197: CALL_OW 275
28201: PUSH
28202: LD_VAR 0 4
28206: PUSH
28207: LD_INT 1
28209: ARRAY
28210: GREATEREQUAL
28211: PUSH
28212: LD_VAR 0 3
28216: PPUSH
28217: LD_INT 2
28219: PPUSH
28220: CALL_OW 275
28224: PUSH
28225: LD_VAR 0 4
28229: PUSH
28230: LD_INT 2
28232: ARRAY
28233: GREATEREQUAL
28234: AND
28235: PUSH
28236: LD_VAR 0 3
28240: PPUSH
28241: LD_INT 3
28243: PPUSH
28244: CALL_OW 275
28248: PUSH
28249: LD_VAR 0 4
28253: PUSH
28254: LD_INT 3
28256: ARRAY
28257: GREATEREQUAL
28258: AND
28259: ST_TO_ADDR
// end ;
28260: LD_VAR 0 2
28264: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28265: LD_INT 0
28267: PPUSH
28268: PPUSH
28269: PPUSH
// pom := GetBase ( building ) ;
28270: LD_ADDR_VAR 0 4
28274: PUSH
28275: LD_VAR 0 1
28279: PPUSH
28280: CALL_OW 274
28284: ST_TO_ADDR
// if not pom then
28285: LD_VAR 0 4
28289: NOT
28290: IFFALSE 28294
// exit ;
28292: GO 28395
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28294: LD_ADDR_VAR 0 5
28298: PUSH
28299: LD_VAR 0 2
28303: PPUSH
28304: LD_VAR 0 1
28308: PPUSH
28309: CALL_OW 248
28313: PPUSH
28314: CALL_OW 450
28318: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28319: LD_ADDR_VAR 0 3
28323: PUSH
28324: LD_VAR 0 4
28328: PPUSH
28329: LD_INT 1
28331: PPUSH
28332: CALL_OW 275
28336: PUSH
28337: LD_VAR 0 5
28341: PUSH
28342: LD_INT 1
28344: ARRAY
28345: GREATEREQUAL
28346: PUSH
28347: LD_VAR 0 4
28351: PPUSH
28352: LD_INT 2
28354: PPUSH
28355: CALL_OW 275
28359: PUSH
28360: LD_VAR 0 5
28364: PUSH
28365: LD_INT 2
28367: ARRAY
28368: GREATEREQUAL
28369: AND
28370: PUSH
28371: LD_VAR 0 4
28375: PPUSH
28376: LD_INT 3
28378: PPUSH
28379: CALL_OW 275
28383: PUSH
28384: LD_VAR 0 5
28388: PUSH
28389: LD_INT 3
28391: ARRAY
28392: GREATEREQUAL
28393: AND
28394: ST_TO_ADDR
// end ;
28395: LD_VAR 0 3
28399: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
28400: LD_INT 0
28402: PPUSH
28403: PPUSH
28404: PPUSH
28405: PPUSH
28406: PPUSH
28407: PPUSH
28408: PPUSH
28409: PPUSH
28410: PPUSH
28411: PPUSH
// result := false ;
28412: LD_ADDR_VAR 0 6
28416: PUSH
28417: LD_INT 0
28419: ST_TO_ADDR
// if not base or not btype or not x or not y then
28420: LD_VAR 0 1
28424: NOT
28425: PUSH
28426: LD_VAR 0 2
28430: NOT
28431: OR
28432: PUSH
28433: LD_VAR 0 3
28437: NOT
28438: OR
28439: PUSH
28440: LD_VAR 0 4
28444: NOT
28445: OR
28446: IFFALSE 28450
// exit ;
28448: GO 29059
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
28450: LD_ADDR_VAR 0 12
28454: PUSH
28455: LD_VAR 0 2
28459: PPUSH
28460: LD_VAR 0 3
28464: PPUSH
28465: LD_VAR 0 4
28469: PPUSH
28470: LD_VAR 0 5
28474: PPUSH
28475: LD_VAR 0 1
28479: PUSH
28480: LD_INT 1
28482: ARRAY
28483: PPUSH
28484: CALL_OW 248
28488: PPUSH
28489: LD_INT 0
28491: PPUSH
28492: CALL 29896 0 6
28496: ST_TO_ADDR
// if not hexes then
28497: LD_VAR 0 12
28501: NOT
28502: IFFALSE 28506
// exit ;
28504: GO 29059
// for i = 1 to hexes do
28506: LD_ADDR_VAR 0 7
28510: PUSH
28511: DOUBLE
28512: LD_INT 1
28514: DEC
28515: ST_TO_ADDR
28516: LD_VAR 0 12
28520: PUSH
28521: FOR_TO
28522: IFFALSE 29057
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28524: LD_ADDR_VAR 0 11
28528: PUSH
28529: LD_VAR 0 12
28533: PUSH
28534: LD_VAR 0 7
28538: ARRAY
28539: PUSH
28540: LD_INT 1
28542: ARRAY
28543: PPUSH
28544: LD_VAR 0 12
28548: PUSH
28549: LD_VAR 0 7
28553: ARRAY
28554: PUSH
28555: LD_INT 2
28557: ARRAY
28558: PPUSH
28559: CALL_OW 428
28563: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28564: LD_VAR 0 12
28568: PUSH
28569: LD_VAR 0 7
28573: ARRAY
28574: PUSH
28575: LD_INT 1
28577: ARRAY
28578: PPUSH
28579: LD_VAR 0 12
28583: PUSH
28584: LD_VAR 0 7
28588: ARRAY
28589: PUSH
28590: LD_INT 2
28592: ARRAY
28593: PPUSH
28594: CALL_OW 351
28598: PUSH
28599: LD_VAR 0 12
28603: PUSH
28604: LD_VAR 0 7
28608: ARRAY
28609: PUSH
28610: LD_INT 1
28612: ARRAY
28613: PPUSH
28614: LD_VAR 0 12
28618: PUSH
28619: LD_VAR 0 7
28623: ARRAY
28624: PUSH
28625: LD_INT 2
28627: ARRAY
28628: PPUSH
28629: CALL_OW 488
28633: NOT
28634: OR
28635: PUSH
28636: LD_VAR 0 11
28640: PPUSH
28641: CALL_OW 247
28645: PUSH
28646: LD_INT 3
28648: EQUAL
28649: OR
28650: IFFALSE 28656
// exit ;
28652: POP
28653: POP
28654: GO 29059
// if not tmp or not tmp in base then
28656: LD_VAR 0 11
28660: NOT
28661: PUSH
28662: LD_VAR 0 11
28666: PUSH
28667: LD_VAR 0 1
28671: IN
28672: NOT
28673: OR
28674: IFFALSE 28678
// continue ;
28676: GO 28521
// result := true ;
28678: LD_ADDR_VAR 0 6
28682: PUSH
28683: LD_INT 1
28685: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28686: LD_ADDR_VAR 0 15
28690: PUSH
28691: LD_VAR 0 1
28695: PPUSH
28696: LD_INT 22
28698: PUSH
28699: LD_VAR 0 11
28703: PPUSH
28704: CALL_OW 255
28708: PUSH
28709: EMPTY
28710: LIST
28711: LIST
28712: PUSH
28713: LD_INT 2
28715: PUSH
28716: LD_INT 30
28718: PUSH
28719: LD_INT 0
28721: PUSH
28722: EMPTY
28723: LIST
28724: LIST
28725: PUSH
28726: LD_INT 30
28728: PUSH
28729: LD_INT 1
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: LIST
28740: PUSH
28741: EMPTY
28742: LIST
28743: LIST
28744: PPUSH
28745: CALL_OW 72
28749: ST_TO_ADDR
// if dep then
28750: LD_VAR 0 15
28754: IFFALSE 28890
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28756: LD_ADDR_VAR 0 14
28760: PUSH
28761: LD_VAR 0 15
28765: PUSH
28766: LD_INT 1
28768: ARRAY
28769: PPUSH
28770: CALL_OW 250
28774: PPUSH
28775: LD_VAR 0 15
28779: PUSH
28780: LD_INT 1
28782: ARRAY
28783: PPUSH
28784: CALL_OW 254
28788: PPUSH
28789: LD_INT 5
28791: PPUSH
28792: CALL_OW 272
28796: PUSH
28797: LD_VAR 0 15
28801: PUSH
28802: LD_INT 1
28804: ARRAY
28805: PPUSH
28806: CALL_OW 251
28810: PPUSH
28811: LD_VAR 0 15
28815: PUSH
28816: LD_INT 1
28818: ARRAY
28819: PPUSH
28820: CALL_OW 254
28824: PPUSH
28825: LD_INT 5
28827: PPUSH
28828: CALL_OW 273
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28837: LD_VAR 0 14
28841: PUSH
28842: LD_INT 1
28844: ARRAY
28845: PPUSH
28846: LD_VAR 0 14
28850: PUSH
28851: LD_INT 2
28853: ARRAY
28854: PPUSH
28855: CALL_OW 488
28859: IFFALSE 28890
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28861: LD_VAR 0 11
28865: PPUSH
28866: LD_VAR 0 14
28870: PUSH
28871: LD_INT 1
28873: ARRAY
28874: PPUSH
28875: LD_VAR 0 14
28879: PUSH
28880: LD_INT 2
28882: ARRAY
28883: PPUSH
28884: CALL_OW 111
// continue ;
28888: GO 28521
// end ; end ; r := GetDir ( tmp ) ;
28890: LD_ADDR_VAR 0 13
28894: PUSH
28895: LD_VAR 0 11
28899: PPUSH
28900: CALL_OW 254
28904: ST_TO_ADDR
// if r = 5 then
28905: LD_VAR 0 13
28909: PUSH
28910: LD_INT 5
28912: EQUAL
28913: IFFALSE 28923
// r := 0 ;
28915: LD_ADDR_VAR 0 13
28919: PUSH
28920: LD_INT 0
28922: ST_TO_ADDR
// for j = r to 5 do
28923: LD_ADDR_VAR 0 8
28927: PUSH
28928: DOUBLE
28929: LD_VAR 0 13
28933: DEC
28934: ST_TO_ADDR
28935: LD_INT 5
28937: PUSH
28938: FOR_TO
28939: IFFALSE 29053
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28941: LD_ADDR_VAR 0 9
28945: PUSH
28946: LD_VAR 0 11
28950: PPUSH
28951: CALL_OW 250
28955: PPUSH
28956: LD_VAR 0 8
28960: PPUSH
28961: LD_INT 2
28963: PPUSH
28964: CALL_OW 272
28968: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28969: LD_ADDR_VAR 0 10
28973: PUSH
28974: LD_VAR 0 11
28978: PPUSH
28979: CALL_OW 251
28983: PPUSH
28984: LD_VAR 0 8
28988: PPUSH
28989: LD_INT 2
28991: PPUSH
28992: CALL_OW 273
28996: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28997: LD_VAR 0 9
29001: PPUSH
29002: LD_VAR 0 10
29006: PPUSH
29007: CALL_OW 488
29011: PUSH
29012: LD_VAR 0 9
29016: PPUSH
29017: LD_VAR 0 10
29021: PPUSH
29022: CALL_OW 428
29026: NOT
29027: AND
29028: IFFALSE 29051
// begin ComMoveXY ( tmp , _x , _y ) ;
29030: LD_VAR 0 11
29034: PPUSH
29035: LD_VAR 0 9
29039: PPUSH
29040: LD_VAR 0 10
29044: PPUSH
29045: CALL_OW 111
// break ;
29049: GO 29053
// end ; end ;
29051: GO 28938
29053: POP
29054: POP
// end ;
29055: GO 28521
29057: POP
29058: POP
// end ;
29059: LD_VAR 0 6
29063: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
29064: LD_INT 0
29066: PPUSH
29067: PPUSH
29068: PPUSH
29069: PPUSH
29070: PPUSH
29071: PPUSH
29072: PPUSH
29073: PPUSH
29074: PPUSH
29075: PPUSH
// result := false ;
29076: LD_ADDR_VAR 0 6
29080: PUSH
29081: LD_INT 0
29083: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
29084: LD_VAR 0 1
29088: NOT
29089: PUSH
29090: LD_VAR 0 1
29094: PPUSH
29095: CALL_OW 266
29099: PUSH
29100: LD_INT 0
29102: PUSH
29103: LD_INT 1
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: IN
29110: NOT
29111: OR
29112: PUSH
29113: LD_VAR 0 2
29117: NOT
29118: OR
29119: PUSH
29120: LD_VAR 0 5
29124: PUSH
29125: LD_INT 0
29127: PUSH
29128: LD_INT 1
29130: PUSH
29131: LD_INT 2
29133: PUSH
29134: LD_INT 3
29136: PUSH
29137: LD_INT 4
29139: PUSH
29140: LD_INT 5
29142: PUSH
29143: EMPTY
29144: LIST
29145: LIST
29146: LIST
29147: LIST
29148: LIST
29149: LIST
29150: IN
29151: NOT
29152: OR
29153: PUSH
29154: LD_VAR 0 3
29158: PPUSH
29159: LD_VAR 0 4
29163: PPUSH
29164: CALL_OW 488
29168: NOT
29169: OR
29170: IFFALSE 29174
// exit ;
29172: GO 29891
// pom := GetBase ( depot ) ;
29174: LD_ADDR_VAR 0 10
29178: PUSH
29179: LD_VAR 0 1
29183: PPUSH
29184: CALL_OW 274
29188: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
29189: LD_ADDR_VAR 0 11
29193: PUSH
29194: LD_VAR 0 2
29198: PPUSH
29199: LD_VAR 0 1
29203: PPUSH
29204: CALL_OW 248
29208: PPUSH
29209: CALL_OW 450
29213: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
29214: LD_VAR 0 10
29218: PPUSH
29219: LD_INT 1
29221: PPUSH
29222: CALL_OW 275
29226: PUSH
29227: LD_VAR 0 11
29231: PUSH
29232: LD_INT 1
29234: ARRAY
29235: GREATEREQUAL
29236: PUSH
29237: LD_VAR 0 10
29241: PPUSH
29242: LD_INT 2
29244: PPUSH
29245: CALL_OW 275
29249: PUSH
29250: LD_VAR 0 11
29254: PUSH
29255: LD_INT 2
29257: ARRAY
29258: GREATEREQUAL
29259: AND
29260: PUSH
29261: LD_VAR 0 10
29265: PPUSH
29266: LD_INT 3
29268: PPUSH
29269: CALL_OW 275
29273: PUSH
29274: LD_VAR 0 11
29278: PUSH
29279: LD_INT 3
29281: ARRAY
29282: GREATEREQUAL
29283: AND
29284: NOT
29285: IFFALSE 29289
// exit ;
29287: GO 29891
// if GetBType ( depot ) = b_depot then
29289: LD_VAR 0 1
29293: PPUSH
29294: CALL_OW 266
29298: PUSH
29299: LD_INT 0
29301: EQUAL
29302: IFFALSE 29314
// dist := 28 else
29304: LD_ADDR_VAR 0 14
29308: PUSH
29309: LD_INT 28
29311: ST_TO_ADDR
29312: GO 29322
// dist := 36 ;
29314: LD_ADDR_VAR 0 14
29318: PUSH
29319: LD_INT 36
29321: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
29322: LD_VAR 0 1
29326: PPUSH
29327: LD_VAR 0 3
29331: PPUSH
29332: LD_VAR 0 4
29336: PPUSH
29337: CALL_OW 297
29341: PUSH
29342: LD_VAR 0 14
29346: GREATER
29347: IFFALSE 29351
// exit ;
29349: GO 29891
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
29351: LD_ADDR_VAR 0 12
29355: PUSH
29356: LD_VAR 0 2
29360: PPUSH
29361: LD_VAR 0 3
29365: PPUSH
29366: LD_VAR 0 4
29370: PPUSH
29371: LD_VAR 0 5
29375: PPUSH
29376: LD_VAR 0 1
29380: PPUSH
29381: CALL_OW 248
29385: PPUSH
29386: LD_INT 0
29388: PPUSH
29389: CALL 29896 0 6
29393: ST_TO_ADDR
// if not hexes then
29394: LD_VAR 0 12
29398: NOT
29399: IFFALSE 29403
// exit ;
29401: GO 29891
// hex := GetHexInfo ( x , y ) ;
29403: LD_ADDR_VAR 0 15
29407: PUSH
29408: LD_VAR 0 3
29412: PPUSH
29413: LD_VAR 0 4
29417: PPUSH
29418: CALL_OW 546
29422: ST_TO_ADDR
// if hex [ 1 ] then
29423: LD_VAR 0 15
29427: PUSH
29428: LD_INT 1
29430: ARRAY
29431: IFFALSE 29435
// exit ;
29433: GO 29891
// height := hex [ 2 ] ;
29435: LD_ADDR_VAR 0 13
29439: PUSH
29440: LD_VAR 0 15
29444: PUSH
29445: LD_INT 2
29447: ARRAY
29448: ST_TO_ADDR
// for i = 1 to hexes do
29449: LD_ADDR_VAR 0 7
29453: PUSH
29454: DOUBLE
29455: LD_INT 1
29457: DEC
29458: ST_TO_ADDR
29459: LD_VAR 0 12
29463: PUSH
29464: FOR_TO
29465: IFFALSE 29795
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29467: LD_VAR 0 12
29471: PUSH
29472: LD_VAR 0 7
29476: ARRAY
29477: PUSH
29478: LD_INT 1
29480: ARRAY
29481: PPUSH
29482: LD_VAR 0 12
29486: PUSH
29487: LD_VAR 0 7
29491: ARRAY
29492: PUSH
29493: LD_INT 2
29495: ARRAY
29496: PPUSH
29497: CALL_OW 488
29501: NOT
29502: PUSH
29503: LD_VAR 0 12
29507: PUSH
29508: LD_VAR 0 7
29512: ARRAY
29513: PUSH
29514: LD_INT 1
29516: ARRAY
29517: PPUSH
29518: LD_VAR 0 12
29522: PUSH
29523: LD_VAR 0 7
29527: ARRAY
29528: PUSH
29529: LD_INT 2
29531: ARRAY
29532: PPUSH
29533: CALL_OW 428
29537: PUSH
29538: LD_INT 0
29540: GREATER
29541: OR
29542: PUSH
29543: LD_VAR 0 12
29547: PUSH
29548: LD_VAR 0 7
29552: ARRAY
29553: PUSH
29554: LD_INT 1
29556: ARRAY
29557: PPUSH
29558: LD_VAR 0 12
29562: PUSH
29563: LD_VAR 0 7
29567: ARRAY
29568: PUSH
29569: LD_INT 2
29571: ARRAY
29572: PPUSH
29573: CALL_OW 351
29577: OR
29578: IFFALSE 29584
// exit ;
29580: POP
29581: POP
29582: GO 29891
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29584: LD_ADDR_VAR 0 8
29588: PUSH
29589: LD_VAR 0 12
29593: PUSH
29594: LD_VAR 0 7
29598: ARRAY
29599: PUSH
29600: LD_INT 1
29602: ARRAY
29603: PPUSH
29604: LD_VAR 0 12
29608: PUSH
29609: LD_VAR 0 7
29613: ARRAY
29614: PUSH
29615: LD_INT 2
29617: ARRAY
29618: PPUSH
29619: CALL_OW 546
29623: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29624: LD_VAR 0 8
29628: PUSH
29629: LD_INT 1
29631: ARRAY
29632: PUSH
29633: LD_VAR 0 8
29637: PUSH
29638: LD_INT 2
29640: ARRAY
29641: PUSH
29642: LD_VAR 0 13
29646: PUSH
29647: LD_INT 2
29649: PLUS
29650: GREATER
29651: OR
29652: PUSH
29653: LD_VAR 0 8
29657: PUSH
29658: LD_INT 2
29660: ARRAY
29661: PUSH
29662: LD_VAR 0 13
29666: PUSH
29667: LD_INT 2
29669: MINUS
29670: LESS
29671: OR
29672: PUSH
29673: LD_VAR 0 8
29677: PUSH
29678: LD_INT 3
29680: ARRAY
29681: PUSH
29682: LD_INT 0
29684: PUSH
29685: LD_INT 8
29687: PUSH
29688: LD_INT 9
29690: PUSH
29691: LD_INT 10
29693: PUSH
29694: LD_INT 11
29696: PUSH
29697: LD_INT 12
29699: PUSH
29700: LD_INT 13
29702: PUSH
29703: LD_INT 16
29705: PUSH
29706: LD_INT 17
29708: PUSH
29709: LD_INT 18
29711: PUSH
29712: LD_INT 19
29714: PUSH
29715: LD_INT 20
29717: PUSH
29718: LD_INT 21
29720: PUSH
29721: EMPTY
29722: LIST
29723: LIST
29724: LIST
29725: LIST
29726: LIST
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: IN
29736: NOT
29737: OR
29738: PUSH
29739: LD_VAR 0 8
29743: PUSH
29744: LD_INT 5
29746: ARRAY
29747: NOT
29748: OR
29749: PUSH
29750: LD_VAR 0 8
29754: PUSH
29755: LD_INT 6
29757: ARRAY
29758: PUSH
29759: LD_INT 1
29761: PUSH
29762: LD_INT 2
29764: PUSH
29765: LD_INT 7
29767: PUSH
29768: LD_INT 9
29770: PUSH
29771: LD_INT 10
29773: PUSH
29774: LD_INT 11
29776: PUSH
29777: EMPTY
29778: LIST
29779: LIST
29780: LIST
29781: LIST
29782: LIST
29783: LIST
29784: IN
29785: NOT
29786: OR
29787: IFFALSE 29793
// exit ;
29789: POP
29790: POP
29791: GO 29891
// end ;
29793: GO 29464
29795: POP
29796: POP
// side := GetSide ( depot ) ;
29797: LD_ADDR_VAR 0 9
29801: PUSH
29802: LD_VAR 0 1
29806: PPUSH
29807: CALL_OW 255
29811: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29812: LD_VAR 0 9
29816: PPUSH
29817: LD_VAR 0 3
29821: PPUSH
29822: LD_VAR 0 4
29826: PPUSH
29827: LD_INT 20
29829: PPUSH
29830: CALL 22545 0 4
29834: PUSH
29835: LD_INT 4
29837: ARRAY
29838: IFFALSE 29842
// exit ;
29840: GO 29891
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29842: LD_VAR 0 2
29846: PUSH
29847: LD_INT 29
29849: PUSH
29850: LD_INT 30
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: IN
29857: PUSH
29858: LD_VAR 0 3
29862: PPUSH
29863: LD_VAR 0 4
29867: PPUSH
29868: LD_VAR 0 9
29872: PPUSH
29873: CALL_OW 440
29877: NOT
29878: AND
29879: IFFALSE 29883
// exit ;
29881: GO 29891
// result := true ;
29883: LD_ADDR_VAR 0 6
29887: PUSH
29888: LD_INT 1
29890: ST_TO_ADDR
// end ;
29891: LD_VAR 0 6
29895: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29896: LD_INT 0
29898: PPUSH
29899: PPUSH
29900: PPUSH
29901: PPUSH
29902: PPUSH
29903: PPUSH
29904: PPUSH
29905: PPUSH
29906: PPUSH
29907: PPUSH
29908: PPUSH
29909: PPUSH
29910: PPUSH
29911: PPUSH
29912: PPUSH
29913: PPUSH
29914: PPUSH
29915: PPUSH
29916: PPUSH
29917: PPUSH
29918: PPUSH
29919: PPUSH
29920: PPUSH
29921: PPUSH
29922: PPUSH
29923: PPUSH
29924: PPUSH
29925: PPUSH
29926: PPUSH
29927: PPUSH
29928: PPUSH
29929: PPUSH
29930: PPUSH
29931: PPUSH
29932: PPUSH
29933: PPUSH
29934: PPUSH
29935: PPUSH
29936: PPUSH
29937: PPUSH
29938: PPUSH
29939: PPUSH
29940: PPUSH
29941: PPUSH
29942: PPUSH
29943: PPUSH
29944: PPUSH
29945: PPUSH
29946: PPUSH
29947: PPUSH
29948: PPUSH
29949: PPUSH
29950: PPUSH
29951: PPUSH
29952: PPUSH
29953: PPUSH
29954: PPUSH
29955: PPUSH
// result = [ ] ;
29956: LD_ADDR_VAR 0 7
29960: PUSH
29961: EMPTY
29962: ST_TO_ADDR
// temp_list = [ ] ;
29963: LD_ADDR_VAR 0 9
29967: PUSH
29968: EMPTY
29969: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29970: LD_VAR 0 4
29974: PUSH
29975: LD_INT 0
29977: PUSH
29978: LD_INT 1
29980: PUSH
29981: LD_INT 2
29983: PUSH
29984: LD_INT 3
29986: PUSH
29987: LD_INT 4
29989: PUSH
29990: LD_INT 5
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: LIST
29997: LIST
29998: LIST
29999: LIST
30000: IN
30001: NOT
30002: PUSH
30003: LD_VAR 0 1
30007: PUSH
30008: LD_INT 0
30010: PUSH
30011: LD_INT 1
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: IN
30018: PUSH
30019: LD_VAR 0 5
30023: PUSH
30024: LD_INT 1
30026: PUSH
30027: LD_INT 2
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: LIST
30037: IN
30038: NOT
30039: AND
30040: OR
30041: IFFALSE 30045
// exit ;
30043: GO 48436
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
30045: LD_VAR 0 1
30049: PUSH
30050: LD_INT 6
30052: PUSH
30053: LD_INT 7
30055: PUSH
30056: LD_INT 8
30058: PUSH
30059: LD_INT 13
30061: PUSH
30062: LD_INT 12
30064: PUSH
30065: LD_INT 15
30067: PUSH
30068: LD_INT 11
30070: PUSH
30071: LD_INT 14
30073: PUSH
30074: LD_INT 10
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: LIST
30081: LIST
30082: LIST
30083: LIST
30084: LIST
30085: LIST
30086: LIST
30087: IN
30088: IFFALSE 30098
// btype = b_lab ;
30090: LD_ADDR_VAR 0 1
30094: PUSH
30095: LD_INT 6
30097: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
30098: LD_VAR 0 6
30102: PUSH
30103: LD_INT 0
30105: PUSH
30106: LD_INT 1
30108: PUSH
30109: LD_INT 2
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: LIST
30116: IN
30117: NOT
30118: PUSH
30119: LD_VAR 0 1
30123: PUSH
30124: LD_INT 0
30126: PUSH
30127: LD_INT 1
30129: PUSH
30130: LD_INT 2
30132: PUSH
30133: LD_INT 3
30135: PUSH
30136: LD_INT 6
30138: PUSH
30139: LD_INT 36
30141: PUSH
30142: LD_INT 4
30144: PUSH
30145: LD_INT 5
30147: PUSH
30148: LD_INT 31
30150: PUSH
30151: LD_INT 32
30153: PUSH
30154: LD_INT 33
30156: PUSH
30157: EMPTY
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: LIST
30167: LIST
30168: LIST
30169: IN
30170: NOT
30171: PUSH
30172: LD_VAR 0 6
30176: PUSH
30177: LD_INT 1
30179: EQUAL
30180: AND
30181: OR
30182: PUSH
30183: LD_VAR 0 1
30187: PUSH
30188: LD_INT 2
30190: PUSH
30191: LD_INT 3
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: IN
30198: NOT
30199: PUSH
30200: LD_VAR 0 6
30204: PUSH
30205: LD_INT 2
30207: EQUAL
30208: AND
30209: OR
30210: IFFALSE 30220
// mode = 0 ;
30212: LD_ADDR_VAR 0 6
30216: PUSH
30217: LD_INT 0
30219: ST_TO_ADDR
// case mode of 0 :
30220: LD_VAR 0 6
30224: PUSH
30225: LD_INT 0
30227: DOUBLE
30228: EQUAL
30229: IFTRUE 30233
30231: GO 41686
30233: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
30234: LD_ADDR_VAR 0 11
30238: PUSH
30239: LD_INT 0
30241: PUSH
30242: LD_INT 0
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: LD_INT 0
30251: PUSH
30252: LD_INT 1
30254: NEG
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 1
30262: PUSH
30263: LD_INT 0
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 1
30272: PUSH
30273: LD_INT 1
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 0
30282: PUSH
30283: LD_INT 1
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 1
30292: NEG
30293: PUSH
30294: LD_INT 0
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 1
30303: NEG
30304: PUSH
30305: LD_INT 1
30307: NEG
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: LD_INT 1
30315: NEG
30316: PUSH
30317: LD_INT 2
30319: NEG
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: LD_INT 0
30327: PUSH
30328: LD_INT 2
30330: NEG
30331: PUSH
30332: EMPTY
30333: LIST
30334: LIST
30335: PUSH
30336: LD_INT 1
30338: PUSH
30339: LD_INT 1
30341: NEG
30342: PUSH
30343: EMPTY
30344: LIST
30345: LIST
30346: PUSH
30347: LD_INT 1
30349: PUSH
30350: LD_INT 2
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PUSH
30357: LD_INT 0
30359: PUSH
30360: LD_INT 2
30362: PUSH
30363: EMPTY
30364: LIST
30365: LIST
30366: PUSH
30367: LD_INT 1
30369: NEG
30370: PUSH
30371: LD_INT 1
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: LD_INT 1
30380: PUSH
30381: LD_INT 3
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: PUSH
30388: LD_INT 0
30390: PUSH
30391: LD_INT 3
30393: PUSH
30394: EMPTY
30395: LIST
30396: LIST
30397: PUSH
30398: LD_INT 1
30400: NEG
30401: PUSH
30402: LD_INT 2
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: LIST
30413: LIST
30414: LIST
30415: LIST
30416: LIST
30417: LIST
30418: LIST
30419: LIST
30420: LIST
30421: LIST
30422: LIST
30423: LIST
30424: LIST
30425: LIST
30426: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30427: LD_ADDR_VAR 0 12
30431: PUSH
30432: LD_INT 0
30434: PUSH
30435: LD_INT 0
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PUSH
30442: LD_INT 0
30444: PUSH
30445: LD_INT 1
30447: NEG
30448: PUSH
30449: EMPTY
30450: LIST
30451: LIST
30452: PUSH
30453: LD_INT 1
30455: PUSH
30456: LD_INT 0
30458: PUSH
30459: EMPTY
30460: LIST
30461: LIST
30462: PUSH
30463: LD_INT 1
30465: PUSH
30466: LD_INT 1
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: PUSH
30473: LD_INT 0
30475: PUSH
30476: LD_INT 1
30478: PUSH
30479: EMPTY
30480: LIST
30481: LIST
30482: PUSH
30483: LD_INT 1
30485: NEG
30486: PUSH
30487: LD_INT 0
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: PUSH
30494: LD_INT 1
30496: NEG
30497: PUSH
30498: LD_INT 1
30500: NEG
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 1
30508: PUSH
30509: LD_INT 1
30511: NEG
30512: PUSH
30513: EMPTY
30514: LIST
30515: LIST
30516: PUSH
30517: LD_INT 2
30519: PUSH
30520: LD_INT 0
30522: PUSH
30523: EMPTY
30524: LIST
30525: LIST
30526: PUSH
30527: LD_INT 2
30529: PUSH
30530: LD_INT 1
30532: PUSH
30533: EMPTY
30534: LIST
30535: LIST
30536: PUSH
30537: LD_INT 1
30539: NEG
30540: PUSH
30541: LD_INT 1
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 2
30550: NEG
30551: PUSH
30552: LD_INT 0
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 2
30561: NEG
30562: PUSH
30563: LD_INT 1
30565: NEG
30566: PUSH
30567: EMPTY
30568: LIST
30569: LIST
30570: PUSH
30571: LD_INT 2
30573: NEG
30574: PUSH
30575: LD_INT 1
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 3
30584: NEG
30585: PUSH
30586: LD_INT 0
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: PUSH
30593: LD_INT 3
30595: NEG
30596: PUSH
30597: LD_INT 1
30599: NEG
30600: PUSH
30601: EMPTY
30602: LIST
30603: LIST
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: LIST
30613: LIST
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: LIST
30619: LIST
30620: LIST
30621: LIST
30622: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30623: LD_ADDR_VAR 0 13
30627: PUSH
30628: LD_INT 0
30630: PUSH
30631: LD_INT 0
30633: PUSH
30634: EMPTY
30635: LIST
30636: LIST
30637: PUSH
30638: LD_INT 0
30640: PUSH
30641: LD_INT 1
30643: NEG
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 1
30651: PUSH
30652: LD_INT 0
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 1
30661: PUSH
30662: LD_INT 1
30664: PUSH
30665: EMPTY
30666: LIST
30667: LIST
30668: PUSH
30669: LD_INT 0
30671: PUSH
30672: LD_INT 1
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PUSH
30679: LD_INT 1
30681: NEG
30682: PUSH
30683: LD_INT 0
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: PUSH
30690: LD_INT 1
30692: NEG
30693: PUSH
30694: LD_INT 1
30696: NEG
30697: PUSH
30698: EMPTY
30699: LIST
30700: LIST
30701: PUSH
30702: LD_INT 1
30704: NEG
30705: PUSH
30706: LD_INT 2
30708: NEG
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: PUSH
30714: LD_INT 2
30716: PUSH
30717: LD_INT 1
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: PUSH
30724: LD_INT 2
30726: PUSH
30727: LD_INT 2
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: PUSH
30734: LD_INT 1
30736: PUSH
30737: LD_INT 2
30739: PUSH
30740: EMPTY
30741: LIST
30742: LIST
30743: PUSH
30744: LD_INT 2
30746: NEG
30747: PUSH
30748: LD_INT 1
30750: NEG
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 2
30758: NEG
30759: PUSH
30760: LD_INT 2
30762: NEG
30763: PUSH
30764: EMPTY
30765: LIST
30766: LIST
30767: PUSH
30768: LD_INT 2
30770: NEG
30771: PUSH
30772: LD_INT 3
30774: NEG
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 3
30782: NEG
30783: PUSH
30784: LD_INT 2
30786: NEG
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 3
30794: NEG
30795: PUSH
30796: LD_INT 3
30798: NEG
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: EMPTY
30805: LIST
30806: LIST
30807: LIST
30808: LIST
30809: LIST
30810: LIST
30811: LIST
30812: LIST
30813: LIST
30814: LIST
30815: LIST
30816: LIST
30817: LIST
30818: LIST
30819: LIST
30820: LIST
30821: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30822: LD_ADDR_VAR 0 14
30826: PUSH
30827: LD_INT 0
30829: PUSH
30830: LD_INT 0
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 0
30839: PUSH
30840: LD_INT 1
30842: NEG
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: LD_INT 1
30850: PUSH
30851: LD_INT 0
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: LD_INT 1
30860: PUSH
30861: LD_INT 1
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 0
30870: PUSH
30871: LD_INT 1
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PUSH
30878: LD_INT 1
30880: NEG
30881: PUSH
30882: LD_INT 0
30884: PUSH
30885: EMPTY
30886: LIST
30887: LIST
30888: PUSH
30889: LD_INT 1
30891: NEG
30892: PUSH
30893: LD_INT 1
30895: NEG
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: PUSH
30901: LD_INT 1
30903: NEG
30904: PUSH
30905: LD_INT 2
30907: NEG
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 0
30915: PUSH
30916: LD_INT 2
30918: NEG
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 1
30926: PUSH
30927: LD_INT 1
30929: NEG
30930: PUSH
30931: EMPTY
30932: LIST
30933: LIST
30934: PUSH
30935: LD_INT 1
30937: PUSH
30938: LD_INT 2
30940: PUSH
30941: EMPTY
30942: LIST
30943: LIST
30944: PUSH
30945: LD_INT 0
30947: PUSH
30948: LD_INT 2
30950: PUSH
30951: EMPTY
30952: LIST
30953: LIST
30954: PUSH
30955: LD_INT 1
30957: NEG
30958: PUSH
30959: LD_INT 1
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: PUSH
30966: LD_INT 1
30968: NEG
30969: PUSH
30970: LD_INT 3
30972: NEG
30973: PUSH
30974: EMPTY
30975: LIST
30976: LIST
30977: PUSH
30978: LD_INT 0
30980: PUSH
30981: LD_INT 3
30983: NEG
30984: PUSH
30985: EMPTY
30986: LIST
30987: LIST
30988: PUSH
30989: LD_INT 1
30991: PUSH
30992: LD_INT 2
30994: NEG
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: EMPTY
31001: LIST
31002: LIST
31003: LIST
31004: LIST
31005: LIST
31006: LIST
31007: LIST
31008: LIST
31009: LIST
31010: LIST
31011: LIST
31012: LIST
31013: LIST
31014: LIST
31015: LIST
31016: LIST
31017: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31018: LD_ADDR_VAR 0 15
31022: PUSH
31023: LD_INT 0
31025: PUSH
31026: LD_INT 0
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 0
31035: PUSH
31036: LD_INT 1
31038: NEG
31039: PUSH
31040: EMPTY
31041: LIST
31042: LIST
31043: PUSH
31044: LD_INT 1
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 1
31056: PUSH
31057: LD_INT 1
31059: PUSH
31060: EMPTY
31061: LIST
31062: LIST
31063: PUSH
31064: LD_INT 0
31066: PUSH
31067: LD_INT 1
31069: PUSH
31070: EMPTY
31071: LIST
31072: LIST
31073: PUSH
31074: LD_INT 1
31076: NEG
31077: PUSH
31078: LD_INT 0
31080: PUSH
31081: EMPTY
31082: LIST
31083: LIST
31084: PUSH
31085: LD_INT 1
31087: NEG
31088: PUSH
31089: LD_INT 1
31091: NEG
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PUSH
31097: LD_INT 1
31099: PUSH
31100: LD_INT 1
31102: NEG
31103: PUSH
31104: EMPTY
31105: LIST
31106: LIST
31107: PUSH
31108: LD_INT 2
31110: PUSH
31111: LD_INT 0
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: LD_INT 2
31120: PUSH
31121: LD_INT 1
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 1
31130: NEG
31131: PUSH
31132: LD_INT 1
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: PUSH
31139: LD_INT 2
31141: NEG
31142: PUSH
31143: LD_INT 0
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 2
31152: NEG
31153: PUSH
31154: LD_INT 1
31156: NEG
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: LD_INT 2
31164: PUSH
31165: LD_INT 1
31167: NEG
31168: PUSH
31169: EMPTY
31170: LIST
31171: LIST
31172: PUSH
31173: LD_INT 3
31175: PUSH
31176: LD_INT 0
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 3
31185: PUSH
31186: LD_INT 1
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: EMPTY
31194: LIST
31195: LIST
31196: LIST
31197: LIST
31198: LIST
31199: LIST
31200: LIST
31201: LIST
31202: LIST
31203: LIST
31204: LIST
31205: LIST
31206: LIST
31207: LIST
31208: LIST
31209: LIST
31210: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31211: LD_ADDR_VAR 0 16
31215: PUSH
31216: LD_INT 0
31218: PUSH
31219: LD_INT 0
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: PUSH
31226: LD_INT 0
31228: PUSH
31229: LD_INT 1
31231: NEG
31232: PUSH
31233: EMPTY
31234: LIST
31235: LIST
31236: PUSH
31237: LD_INT 1
31239: PUSH
31240: LD_INT 0
31242: PUSH
31243: EMPTY
31244: LIST
31245: LIST
31246: PUSH
31247: LD_INT 1
31249: PUSH
31250: LD_INT 1
31252: PUSH
31253: EMPTY
31254: LIST
31255: LIST
31256: PUSH
31257: LD_INT 0
31259: PUSH
31260: LD_INT 1
31262: PUSH
31263: EMPTY
31264: LIST
31265: LIST
31266: PUSH
31267: LD_INT 1
31269: NEG
31270: PUSH
31271: LD_INT 0
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: PUSH
31278: LD_INT 1
31280: NEG
31281: PUSH
31282: LD_INT 1
31284: NEG
31285: PUSH
31286: EMPTY
31287: LIST
31288: LIST
31289: PUSH
31290: LD_INT 1
31292: NEG
31293: PUSH
31294: LD_INT 2
31296: NEG
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 2
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 2
31314: PUSH
31315: LD_INT 2
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: LD_INT 1
31324: PUSH
31325: LD_INT 2
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 2
31334: NEG
31335: PUSH
31336: LD_INT 1
31338: NEG
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PUSH
31344: LD_INT 2
31346: NEG
31347: PUSH
31348: LD_INT 2
31350: NEG
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: PUSH
31356: LD_INT 3
31358: PUSH
31359: LD_INT 2
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 3
31368: PUSH
31369: LD_INT 3
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 2
31378: PUSH
31379: LD_INT 3
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: LIST
31397: LIST
31398: LIST
31399: LIST
31400: LIST
31401: LIST
31402: LIST
31403: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31404: LD_ADDR_VAR 0 17
31408: PUSH
31409: LD_INT 0
31411: PUSH
31412: LD_INT 0
31414: PUSH
31415: EMPTY
31416: LIST
31417: LIST
31418: PUSH
31419: LD_INT 0
31421: PUSH
31422: LD_INT 1
31424: NEG
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 1
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 1
31442: PUSH
31443: LD_INT 1
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 0
31452: PUSH
31453: LD_INT 1
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: LD_INT 1
31462: NEG
31463: PUSH
31464: LD_INT 0
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 1
31473: NEG
31474: PUSH
31475: LD_INT 1
31477: NEG
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 1
31485: NEG
31486: PUSH
31487: LD_INT 2
31489: NEG
31490: PUSH
31491: EMPTY
31492: LIST
31493: LIST
31494: PUSH
31495: LD_INT 0
31497: PUSH
31498: LD_INT 2
31500: NEG
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: PUSH
31506: LD_INT 1
31508: PUSH
31509: LD_INT 1
31511: NEG
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: PUSH
31517: LD_INT 2
31519: PUSH
31520: LD_INT 0
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 2
31529: PUSH
31530: LD_INT 1
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 2
31539: PUSH
31540: LD_INT 2
31542: PUSH
31543: EMPTY
31544: LIST
31545: LIST
31546: PUSH
31547: LD_INT 1
31549: PUSH
31550: LD_INT 2
31552: PUSH
31553: EMPTY
31554: LIST
31555: LIST
31556: PUSH
31557: LD_INT 0
31559: PUSH
31560: LD_INT 2
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 1
31569: NEG
31570: PUSH
31571: LD_INT 1
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: PUSH
31578: LD_INT 2
31580: NEG
31581: PUSH
31582: LD_INT 0
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PUSH
31589: LD_INT 2
31591: NEG
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 2
31603: NEG
31604: PUSH
31605: LD_INT 2
31607: NEG
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: LIST
31619: LIST
31620: LIST
31621: LIST
31622: LIST
31623: LIST
31624: LIST
31625: LIST
31626: LIST
31627: LIST
31628: LIST
31629: LIST
31630: LIST
31631: LIST
31632: LIST
31633: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31634: LD_ADDR_VAR 0 18
31638: PUSH
31639: LD_INT 0
31641: PUSH
31642: LD_INT 0
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 0
31651: PUSH
31652: LD_INT 1
31654: NEG
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 1
31662: PUSH
31663: LD_INT 0
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 1
31672: PUSH
31673: LD_INT 1
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 0
31682: PUSH
31683: LD_INT 1
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 1
31692: NEG
31693: PUSH
31694: LD_INT 0
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: LD_INT 1
31703: NEG
31704: PUSH
31705: LD_INT 1
31707: NEG
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: PUSH
31713: LD_INT 1
31715: NEG
31716: PUSH
31717: LD_INT 2
31719: NEG
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: LD_INT 0
31727: PUSH
31728: LD_INT 2
31730: NEG
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 1
31738: PUSH
31739: LD_INT 1
31741: NEG
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 2
31749: PUSH
31750: LD_INT 0
31752: PUSH
31753: EMPTY
31754: LIST
31755: LIST
31756: PUSH
31757: LD_INT 2
31759: PUSH
31760: LD_INT 1
31762: PUSH
31763: EMPTY
31764: LIST
31765: LIST
31766: PUSH
31767: LD_INT 2
31769: PUSH
31770: LD_INT 2
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 1
31779: PUSH
31780: LD_INT 2
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: PUSH
31787: LD_INT 0
31789: PUSH
31790: LD_INT 2
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 1
31799: NEG
31800: PUSH
31801: LD_INT 1
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: LD_INT 2
31810: NEG
31811: PUSH
31812: LD_INT 0
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: LD_INT 2
31821: NEG
31822: PUSH
31823: LD_INT 1
31825: NEG
31826: PUSH
31827: EMPTY
31828: LIST
31829: LIST
31830: PUSH
31831: LD_INT 2
31833: NEG
31834: PUSH
31835: LD_INT 2
31837: NEG
31838: PUSH
31839: EMPTY
31840: LIST
31841: LIST
31842: PUSH
31843: EMPTY
31844: LIST
31845: LIST
31846: LIST
31847: LIST
31848: LIST
31849: LIST
31850: LIST
31851: LIST
31852: LIST
31853: LIST
31854: LIST
31855: LIST
31856: LIST
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31864: LD_ADDR_VAR 0 19
31868: PUSH
31869: LD_INT 0
31871: PUSH
31872: LD_INT 0
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 0
31881: PUSH
31882: LD_INT 1
31884: NEG
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: PUSH
31890: LD_INT 1
31892: PUSH
31893: LD_INT 0
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 1
31902: PUSH
31903: LD_INT 1
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: LD_INT 0
31912: PUSH
31913: LD_INT 1
31915: PUSH
31916: EMPTY
31917: LIST
31918: LIST
31919: PUSH
31920: LD_INT 1
31922: NEG
31923: PUSH
31924: LD_INT 0
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 1
31933: NEG
31934: PUSH
31935: LD_INT 1
31937: NEG
31938: PUSH
31939: EMPTY
31940: LIST
31941: LIST
31942: PUSH
31943: LD_INT 1
31945: NEG
31946: PUSH
31947: LD_INT 2
31949: NEG
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PUSH
31955: LD_INT 0
31957: PUSH
31958: LD_INT 2
31960: NEG
31961: PUSH
31962: EMPTY
31963: LIST
31964: LIST
31965: PUSH
31966: LD_INT 1
31968: PUSH
31969: LD_INT 1
31971: NEG
31972: PUSH
31973: EMPTY
31974: LIST
31975: LIST
31976: PUSH
31977: LD_INT 2
31979: PUSH
31980: LD_INT 0
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 2
31989: PUSH
31990: LD_INT 1
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: LD_INT 2
31999: PUSH
32000: LD_INT 2
32002: PUSH
32003: EMPTY
32004: LIST
32005: LIST
32006: PUSH
32007: LD_INT 1
32009: PUSH
32010: LD_INT 2
32012: PUSH
32013: EMPTY
32014: LIST
32015: LIST
32016: PUSH
32017: LD_INT 0
32019: PUSH
32020: LD_INT 2
32022: PUSH
32023: EMPTY
32024: LIST
32025: LIST
32026: PUSH
32027: LD_INT 1
32029: NEG
32030: PUSH
32031: LD_INT 1
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 2
32040: NEG
32041: PUSH
32042: LD_INT 0
32044: PUSH
32045: EMPTY
32046: LIST
32047: LIST
32048: PUSH
32049: LD_INT 2
32051: NEG
32052: PUSH
32053: LD_INT 1
32055: NEG
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 2
32063: NEG
32064: PUSH
32065: LD_INT 2
32067: NEG
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: LIST
32077: LIST
32078: LIST
32079: LIST
32080: LIST
32081: LIST
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: LIST
32087: LIST
32088: LIST
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32094: LD_ADDR_VAR 0 20
32098: PUSH
32099: LD_INT 0
32101: PUSH
32102: LD_INT 0
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: LD_INT 0
32111: PUSH
32112: LD_INT 1
32114: NEG
32115: PUSH
32116: EMPTY
32117: LIST
32118: LIST
32119: PUSH
32120: LD_INT 1
32122: PUSH
32123: LD_INT 0
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PUSH
32130: LD_INT 1
32132: PUSH
32133: LD_INT 1
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 0
32142: PUSH
32143: LD_INT 1
32145: PUSH
32146: EMPTY
32147: LIST
32148: LIST
32149: PUSH
32150: LD_INT 1
32152: NEG
32153: PUSH
32154: LD_INT 0
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: PUSH
32161: LD_INT 1
32163: NEG
32164: PUSH
32165: LD_INT 1
32167: NEG
32168: PUSH
32169: EMPTY
32170: LIST
32171: LIST
32172: PUSH
32173: LD_INT 1
32175: NEG
32176: PUSH
32177: LD_INT 2
32179: NEG
32180: PUSH
32181: EMPTY
32182: LIST
32183: LIST
32184: PUSH
32185: LD_INT 0
32187: PUSH
32188: LD_INT 2
32190: NEG
32191: PUSH
32192: EMPTY
32193: LIST
32194: LIST
32195: PUSH
32196: LD_INT 1
32198: PUSH
32199: LD_INT 1
32201: NEG
32202: PUSH
32203: EMPTY
32204: LIST
32205: LIST
32206: PUSH
32207: LD_INT 2
32209: PUSH
32210: LD_INT 0
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 2
32219: PUSH
32220: LD_INT 1
32222: PUSH
32223: EMPTY
32224: LIST
32225: LIST
32226: PUSH
32227: LD_INT 2
32229: PUSH
32230: LD_INT 2
32232: PUSH
32233: EMPTY
32234: LIST
32235: LIST
32236: PUSH
32237: LD_INT 1
32239: PUSH
32240: LD_INT 2
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 0
32249: PUSH
32250: LD_INT 2
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: LD_INT 1
32259: NEG
32260: PUSH
32261: LD_INT 1
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: PUSH
32268: LD_INT 2
32270: NEG
32271: PUSH
32272: LD_INT 0
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 2
32281: NEG
32282: PUSH
32283: LD_INT 1
32285: NEG
32286: PUSH
32287: EMPTY
32288: LIST
32289: LIST
32290: PUSH
32291: LD_INT 2
32293: NEG
32294: PUSH
32295: LD_INT 2
32297: NEG
32298: PUSH
32299: EMPTY
32300: LIST
32301: LIST
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: LIST
32307: LIST
32308: LIST
32309: LIST
32310: LIST
32311: LIST
32312: LIST
32313: LIST
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: LIST
32320: LIST
32321: LIST
32322: LIST
32323: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32324: LD_ADDR_VAR 0 21
32328: PUSH
32329: LD_INT 0
32331: PUSH
32332: LD_INT 0
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: PUSH
32339: LD_INT 0
32341: PUSH
32342: LD_INT 1
32344: NEG
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 1
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 1
32362: PUSH
32363: LD_INT 1
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 0
32372: PUSH
32373: LD_INT 1
32375: PUSH
32376: EMPTY
32377: LIST
32378: LIST
32379: PUSH
32380: LD_INT 1
32382: NEG
32383: PUSH
32384: LD_INT 0
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 1
32393: NEG
32394: PUSH
32395: LD_INT 1
32397: NEG
32398: PUSH
32399: EMPTY
32400: LIST
32401: LIST
32402: PUSH
32403: LD_INT 1
32405: NEG
32406: PUSH
32407: LD_INT 2
32409: NEG
32410: PUSH
32411: EMPTY
32412: LIST
32413: LIST
32414: PUSH
32415: LD_INT 0
32417: PUSH
32418: LD_INT 2
32420: NEG
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: PUSH
32426: LD_INT 1
32428: PUSH
32429: LD_INT 1
32431: NEG
32432: PUSH
32433: EMPTY
32434: LIST
32435: LIST
32436: PUSH
32437: LD_INT 2
32439: PUSH
32440: LD_INT 0
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PUSH
32447: LD_INT 2
32449: PUSH
32450: LD_INT 1
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: LD_INT 2
32459: PUSH
32460: LD_INT 2
32462: PUSH
32463: EMPTY
32464: LIST
32465: LIST
32466: PUSH
32467: LD_INT 1
32469: PUSH
32470: LD_INT 2
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: PUSH
32477: LD_INT 0
32479: PUSH
32480: LD_INT 2
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: LD_INT 1
32489: NEG
32490: PUSH
32491: LD_INT 1
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PUSH
32498: LD_INT 2
32500: NEG
32501: PUSH
32502: LD_INT 0
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 2
32511: NEG
32512: PUSH
32513: LD_INT 1
32515: NEG
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 2
32523: NEG
32524: PUSH
32525: LD_INT 2
32527: NEG
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: LIST
32545: LIST
32546: LIST
32547: LIST
32548: LIST
32549: LIST
32550: LIST
32551: LIST
32552: LIST
32553: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32554: LD_ADDR_VAR 0 22
32558: PUSH
32559: LD_INT 0
32561: PUSH
32562: LD_INT 0
32564: PUSH
32565: EMPTY
32566: LIST
32567: LIST
32568: PUSH
32569: LD_INT 0
32571: PUSH
32572: LD_INT 1
32574: NEG
32575: PUSH
32576: EMPTY
32577: LIST
32578: LIST
32579: PUSH
32580: LD_INT 1
32582: PUSH
32583: LD_INT 0
32585: PUSH
32586: EMPTY
32587: LIST
32588: LIST
32589: PUSH
32590: LD_INT 1
32592: PUSH
32593: LD_INT 1
32595: PUSH
32596: EMPTY
32597: LIST
32598: LIST
32599: PUSH
32600: LD_INT 0
32602: PUSH
32603: LD_INT 1
32605: PUSH
32606: EMPTY
32607: LIST
32608: LIST
32609: PUSH
32610: LD_INT 1
32612: NEG
32613: PUSH
32614: LD_INT 0
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PUSH
32621: LD_INT 1
32623: NEG
32624: PUSH
32625: LD_INT 1
32627: NEG
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 1
32635: NEG
32636: PUSH
32637: LD_INT 2
32639: NEG
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: PUSH
32645: LD_INT 0
32647: PUSH
32648: LD_INT 2
32650: NEG
32651: PUSH
32652: EMPTY
32653: LIST
32654: LIST
32655: PUSH
32656: LD_INT 1
32658: PUSH
32659: LD_INT 1
32661: NEG
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: PUSH
32667: LD_INT 2
32669: PUSH
32670: LD_INT 0
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: PUSH
32677: LD_INT 2
32679: PUSH
32680: LD_INT 1
32682: PUSH
32683: EMPTY
32684: LIST
32685: LIST
32686: PUSH
32687: LD_INT 2
32689: PUSH
32690: LD_INT 2
32692: PUSH
32693: EMPTY
32694: LIST
32695: LIST
32696: PUSH
32697: LD_INT 1
32699: PUSH
32700: LD_INT 2
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 0
32709: PUSH
32710: LD_INT 2
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: PUSH
32717: LD_INT 1
32719: NEG
32720: PUSH
32721: LD_INT 1
32723: PUSH
32724: EMPTY
32725: LIST
32726: LIST
32727: PUSH
32728: LD_INT 2
32730: NEG
32731: PUSH
32732: LD_INT 0
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: LD_INT 2
32741: NEG
32742: PUSH
32743: LD_INT 1
32745: NEG
32746: PUSH
32747: EMPTY
32748: LIST
32749: LIST
32750: PUSH
32751: LD_INT 2
32753: NEG
32754: PUSH
32755: LD_INT 2
32757: NEG
32758: PUSH
32759: EMPTY
32760: LIST
32761: LIST
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: LIST
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: LIST
32781: LIST
32782: LIST
32783: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32784: LD_ADDR_VAR 0 23
32788: PUSH
32789: LD_INT 0
32791: PUSH
32792: LD_INT 0
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 0
32801: PUSH
32802: LD_INT 1
32804: NEG
32805: PUSH
32806: EMPTY
32807: LIST
32808: LIST
32809: PUSH
32810: LD_INT 1
32812: PUSH
32813: LD_INT 0
32815: PUSH
32816: EMPTY
32817: LIST
32818: LIST
32819: PUSH
32820: LD_INT 1
32822: PUSH
32823: LD_INT 1
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 0
32832: PUSH
32833: LD_INT 1
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 1
32842: NEG
32843: PUSH
32844: LD_INT 0
32846: PUSH
32847: EMPTY
32848: LIST
32849: LIST
32850: PUSH
32851: LD_INT 1
32853: NEG
32854: PUSH
32855: LD_INT 1
32857: NEG
32858: PUSH
32859: EMPTY
32860: LIST
32861: LIST
32862: PUSH
32863: LD_INT 1
32865: NEG
32866: PUSH
32867: LD_INT 2
32869: NEG
32870: PUSH
32871: EMPTY
32872: LIST
32873: LIST
32874: PUSH
32875: LD_INT 0
32877: PUSH
32878: LD_INT 2
32880: NEG
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 1
32888: PUSH
32889: LD_INT 1
32891: NEG
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 2
32899: PUSH
32900: LD_INT 0
32902: PUSH
32903: EMPTY
32904: LIST
32905: LIST
32906: PUSH
32907: LD_INT 2
32909: PUSH
32910: LD_INT 1
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: LD_INT 2
32919: PUSH
32920: LD_INT 2
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PUSH
32927: LD_INT 1
32929: PUSH
32930: LD_INT 2
32932: PUSH
32933: EMPTY
32934: LIST
32935: LIST
32936: PUSH
32937: LD_INT 0
32939: PUSH
32940: LD_INT 2
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 1
32949: NEG
32950: PUSH
32951: LD_INT 1
32953: PUSH
32954: EMPTY
32955: LIST
32956: LIST
32957: PUSH
32958: LD_INT 2
32960: NEG
32961: PUSH
32962: LD_INT 0
32964: PUSH
32965: EMPTY
32966: LIST
32967: LIST
32968: PUSH
32969: LD_INT 2
32971: NEG
32972: PUSH
32973: LD_INT 1
32975: NEG
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: LD_INT 2
32983: NEG
32984: PUSH
32985: LD_INT 2
32987: NEG
32988: PUSH
32989: EMPTY
32990: LIST
32991: LIST
32992: PUSH
32993: LD_INT 2
32995: NEG
32996: PUSH
32997: LD_INT 3
32999: NEG
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: LD_INT 1
33007: NEG
33008: PUSH
33009: LD_INT 3
33011: NEG
33012: PUSH
33013: EMPTY
33014: LIST
33015: LIST
33016: PUSH
33017: LD_INT 1
33019: PUSH
33020: LD_INT 2
33022: NEG
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 2
33030: PUSH
33031: LD_INT 1
33033: NEG
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: LIST
33054: LIST
33055: LIST
33056: LIST
33057: LIST
33058: LIST
33059: LIST
33060: LIST
33061: LIST
33062: LIST
33063: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
33064: LD_ADDR_VAR 0 24
33068: PUSH
33069: LD_INT 0
33071: PUSH
33072: LD_INT 0
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 0
33081: PUSH
33082: LD_INT 1
33084: NEG
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 1
33092: PUSH
33093: LD_INT 0
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 1
33102: PUSH
33103: LD_INT 1
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 0
33112: PUSH
33113: LD_INT 1
33115: PUSH
33116: EMPTY
33117: LIST
33118: LIST
33119: PUSH
33120: LD_INT 1
33122: NEG
33123: PUSH
33124: LD_INT 0
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 1
33133: NEG
33134: PUSH
33135: LD_INT 1
33137: NEG
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: LD_INT 1
33145: NEG
33146: PUSH
33147: LD_INT 2
33149: NEG
33150: PUSH
33151: EMPTY
33152: LIST
33153: LIST
33154: PUSH
33155: LD_INT 0
33157: PUSH
33158: LD_INT 2
33160: NEG
33161: PUSH
33162: EMPTY
33163: LIST
33164: LIST
33165: PUSH
33166: LD_INT 1
33168: PUSH
33169: LD_INT 1
33171: NEG
33172: PUSH
33173: EMPTY
33174: LIST
33175: LIST
33176: PUSH
33177: LD_INT 2
33179: PUSH
33180: LD_INT 0
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 2
33189: PUSH
33190: LD_INT 1
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 2
33199: PUSH
33200: LD_INT 2
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 1
33209: PUSH
33210: LD_INT 2
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: LD_INT 0
33219: PUSH
33220: LD_INT 2
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 1
33229: NEG
33230: PUSH
33231: LD_INT 1
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 2
33240: NEG
33241: PUSH
33242: LD_INT 0
33244: PUSH
33245: EMPTY
33246: LIST
33247: LIST
33248: PUSH
33249: LD_INT 2
33251: NEG
33252: PUSH
33253: LD_INT 1
33255: NEG
33256: PUSH
33257: EMPTY
33258: LIST
33259: LIST
33260: PUSH
33261: LD_INT 2
33263: NEG
33264: PUSH
33265: LD_INT 2
33267: NEG
33268: PUSH
33269: EMPTY
33270: LIST
33271: LIST
33272: PUSH
33273: LD_INT 1
33275: PUSH
33276: LD_INT 2
33278: NEG
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 2
33286: PUSH
33287: LD_INT 1
33289: NEG
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 3
33297: PUSH
33298: LD_INT 1
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: PUSH
33305: LD_INT 3
33307: PUSH
33308: LD_INT 2
33310: PUSH
33311: EMPTY
33312: LIST
33313: LIST
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: LIST
33319: LIST
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: LIST
33337: LIST
33338: LIST
33339: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
33340: LD_ADDR_VAR 0 25
33344: PUSH
33345: LD_INT 0
33347: PUSH
33348: LD_INT 0
33350: PUSH
33351: EMPTY
33352: LIST
33353: LIST
33354: PUSH
33355: LD_INT 0
33357: PUSH
33358: LD_INT 1
33360: NEG
33361: PUSH
33362: EMPTY
33363: LIST
33364: LIST
33365: PUSH
33366: LD_INT 1
33368: PUSH
33369: LD_INT 0
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PUSH
33376: LD_INT 1
33378: PUSH
33379: LD_INT 1
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 0
33388: PUSH
33389: LD_INT 1
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 1
33398: NEG
33399: PUSH
33400: LD_INT 0
33402: PUSH
33403: EMPTY
33404: LIST
33405: LIST
33406: PUSH
33407: LD_INT 1
33409: NEG
33410: PUSH
33411: LD_INT 1
33413: NEG
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: PUSH
33419: LD_INT 1
33421: NEG
33422: PUSH
33423: LD_INT 2
33425: NEG
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 0
33433: PUSH
33434: LD_INT 2
33436: NEG
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 1
33444: PUSH
33445: LD_INT 1
33447: NEG
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 2
33455: PUSH
33456: LD_INT 0
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 2
33465: PUSH
33466: LD_INT 1
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 2
33475: PUSH
33476: LD_INT 2
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PUSH
33483: LD_INT 1
33485: PUSH
33486: LD_INT 2
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: PUSH
33493: LD_INT 0
33495: PUSH
33496: LD_INT 2
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: PUSH
33503: LD_INT 1
33505: NEG
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 2
33516: NEG
33517: PUSH
33518: LD_INT 0
33520: PUSH
33521: EMPTY
33522: LIST
33523: LIST
33524: PUSH
33525: LD_INT 2
33527: NEG
33528: PUSH
33529: LD_INT 1
33531: NEG
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 2
33539: NEG
33540: PUSH
33541: LD_INT 2
33543: NEG
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 3
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 3
33561: PUSH
33562: LD_INT 2
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 2
33571: PUSH
33572: LD_INT 3
33574: PUSH
33575: EMPTY
33576: LIST
33577: LIST
33578: PUSH
33579: LD_INT 1
33581: PUSH
33582: LD_INT 3
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: LIST
33612: LIST
33613: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33614: LD_ADDR_VAR 0 26
33618: PUSH
33619: LD_INT 0
33621: PUSH
33622: LD_INT 0
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 0
33631: PUSH
33632: LD_INT 1
33634: NEG
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: LD_INT 0
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 1
33652: PUSH
33653: LD_INT 1
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 0
33662: PUSH
33663: LD_INT 1
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 1
33672: NEG
33673: PUSH
33674: LD_INT 0
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 1
33683: NEG
33684: PUSH
33685: LD_INT 1
33687: NEG
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_INT 1
33695: NEG
33696: PUSH
33697: LD_INT 2
33699: NEG
33700: PUSH
33701: EMPTY
33702: LIST
33703: LIST
33704: PUSH
33705: LD_INT 0
33707: PUSH
33708: LD_INT 2
33710: NEG
33711: PUSH
33712: EMPTY
33713: LIST
33714: LIST
33715: PUSH
33716: LD_INT 1
33718: PUSH
33719: LD_INT 1
33721: NEG
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PUSH
33727: LD_INT 2
33729: PUSH
33730: LD_INT 0
33732: PUSH
33733: EMPTY
33734: LIST
33735: LIST
33736: PUSH
33737: LD_INT 2
33739: PUSH
33740: LD_INT 1
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 2
33749: PUSH
33750: LD_INT 2
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 1
33759: PUSH
33760: LD_INT 2
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 0
33769: PUSH
33770: LD_INT 2
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PUSH
33777: LD_INT 1
33779: NEG
33780: PUSH
33781: LD_INT 1
33783: PUSH
33784: EMPTY
33785: LIST
33786: LIST
33787: PUSH
33788: LD_INT 2
33790: NEG
33791: PUSH
33792: LD_INT 0
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: PUSH
33799: LD_INT 2
33801: NEG
33802: PUSH
33803: LD_INT 1
33805: NEG
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 2
33813: NEG
33814: PUSH
33815: LD_INT 2
33817: NEG
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: LD_INT 2
33825: PUSH
33826: LD_INT 3
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: PUSH
33833: LD_INT 1
33835: PUSH
33836: LD_INT 3
33838: PUSH
33839: EMPTY
33840: LIST
33841: LIST
33842: PUSH
33843: LD_INT 1
33845: NEG
33846: PUSH
33847: LD_INT 2
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: LD_INT 2
33856: NEG
33857: PUSH
33858: LD_INT 1
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33890: LD_ADDR_VAR 0 27
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: LD_INT 0
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 0
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: PUSH
33919: LD_INT 0
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 1
33928: PUSH
33929: LD_INT 1
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 0
33938: PUSH
33939: LD_INT 1
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 1
33948: NEG
33949: PUSH
33950: LD_INT 0
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 1
33959: NEG
33960: PUSH
33961: LD_INT 1
33963: NEG
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 1
33971: NEG
33972: PUSH
33973: LD_INT 2
33975: NEG
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: LD_INT 2
33986: NEG
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: LD_INT 1
33994: PUSH
33995: LD_INT 1
33997: NEG
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 2
34005: PUSH
34006: LD_INT 0
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 2
34015: PUSH
34016: LD_INT 1
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 2
34025: PUSH
34026: LD_INT 2
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 1
34035: PUSH
34036: LD_INT 2
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 0
34045: PUSH
34046: LD_INT 2
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: LD_INT 1
34055: NEG
34056: PUSH
34057: LD_INT 1
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 2
34066: NEG
34067: PUSH
34068: LD_INT 0
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: LD_INT 2
34077: NEG
34078: PUSH
34079: LD_INT 1
34081: NEG
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: PUSH
34087: LD_INT 2
34089: NEG
34090: PUSH
34091: LD_INT 2
34093: NEG
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 1
34101: NEG
34102: PUSH
34103: LD_INT 2
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 2
34112: NEG
34113: PUSH
34114: LD_INT 1
34116: PUSH
34117: EMPTY
34118: LIST
34119: LIST
34120: PUSH
34121: LD_INT 3
34123: NEG
34124: PUSH
34125: LD_INT 1
34127: NEG
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 3
34135: NEG
34136: PUSH
34137: LD_INT 2
34139: NEG
34140: PUSH
34141: EMPTY
34142: LIST
34143: LIST
34144: PUSH
34145: EMPTY
34146: LIST
34147: LIST
34148: LIST
34149: LIST
34150: LIST
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: LIST
34169: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34170: LD_ADDR_VAR 0 28
34174: PUSH
34175: LD_INT 0
34177: PUSH
34178: LD_INT 0
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 0
34187: PUSH
34188: LD_INT 1
34190: NEG
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 1
34198: PUSH
34199: LD_INT 0
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 1
34208: PUSH
34209: LD_INT 1
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: LD_INT 0
34218: PUSH
34219: LD_INT 1
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PUSH
34226: LD_INT 1
34228: NEG
34229: PUSH
34230: LD_INT 0
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: LD_INT 1
34243: NEG
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 1
34251: NEG
34252: PUSH
34253: LD_INT 2
34255: NEG
34256: PUSH
34257: EMPTY
34258: LIST
34259: LIST
34260: PUSH
34261: LD_INT 0
34263: PUSH
34264: LD_INT 2
34266: NEG
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: PUSH
34272: LD_INT 1
34274: PUSH
34275: LD_INT 1
34277: NEG
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 2
34285: PUSH
34286: LD_INT 0
34288: PUSH
34289: EMPTY
34290: LIST
34291: LIST
34292: PUSH
34293: LD_INT 2
34295: PUSH
34296: LD_INT 1
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 2
34305: PUSH
34306: LD_INT 2
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 1
34315: PUSH
34316: LD_INT 2
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 0
34325: PUSH
34326: LD_INT 2
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 1
34335: NEG
34336: PUSH
34337: LD_INT 1
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 2
34346: NEG
34347: PUSH
34348: LD_INT 0
34350: PUSH
34351: EMPTY
34352: LIST
34353: LIST
34354: PUSH
34355: LD_INT 2
34357: NEG
34358: PUSH
34359: LD_INT 1
34361: NEG
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 2
34369: NEG
34370: PUSH
34371: LD_INT 2
34373: NEG
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 2
34381: NEG
34382: PUSH
34383: LD_INT 3
34385: NEG
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: PUSH
34391: LD_INT 1
34393: NEG
34394: PUSH
34395: LD_INT 3
34397: NEG
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: LD_INT 3
34405: NEG
34406: PUSH
34407: LD_INT 1
34409: NEG
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: LD_INT 3
34417: NEG
34418: PUSH
34419: LD_INT 2
34421: NEG
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: LIST
34451: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34452: LD_ADDR_VAR 0 29
34456: PUSH
34457: LD_INT 0
34459: PUSH
34460: LD_INT 0
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: LD_INT 0
34469: PUSH
34470: LD_INT 1
34472: NEG
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 1
34480: PUSH
34481: LD_INT 0
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 1
34490: PUSH
34491: LD_INT 1
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 0
34500: PUSH
34501: LD_INT 1
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 1
34510: NEG
34511: PUSH
34512: LD_INT 0
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: LD_INT 1
34525: NEG
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: LD_INT 1
34533: NEG
34534: PUSH
34535: LD_INT 2
34537: NEG
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 0
34545: PUSH
34546: LD_INT 2
34548: NEG
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: PUSH
34554: LD_INT 1
34556: PUSH
34557: LD_INT 1
34559: NEG
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 2
34567: PUSH
34568: LD_INT 0
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 2
34577: PUSH
34578: LD_INT 1
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 1
34587: PUSH
34588: LD_INT 2
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 0
34597: PUSH
34598: LD_INT 2
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 1
34607: NEG
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 2
34618: NEG
34619: PUSH
34620: LD_INT 1
34622: NEG
34623: PUSH
34624: EMPTY
34625: LIST
34626: LIST
34627: PUSH
34628: LD_INT 2
34630: NEG
34631: PUSH
34632: LD_INT 2
34634: NEG
34635: PUSH
34636: EMPTY
34637: LIST
34638: LIST
34639: PUSH
34640: LD_INT 2
34642: NEG
34643: PUSH
34644: LD_INT 3
34646: NEG
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 2
34654: PUSH
34655: LD_INT 1
34657: NEG
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 3
34665: PUSH
34666: LD_INT 1
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 1
34675: PUSH
34676: LD_INT 3
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 1
34685: NEG
34686: PUSH
34687: LD_INT 2
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 3
34696: NEG
34697: PUSH
34698: LD_INT 2
34700: NEG
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: PUSH
34706: EMPTY
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34731: LD_ADDR_VAR 0 30
34735: PUSH
34736: LD_INT 0
34738: PUSH
34739: LD_INT 0
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 0
34748: PUSH
34749: LD_INT 1
34751: NEG
34752: PUSH
34753: EMPTY
34754: LIST
34755: LIST
34756: PUSH
34757: LD_INT 1
34759: PUSH
34760: LD_INT 0
34762: PUSH
34763: EMPTY
34764: LIST
34765: LIST
34766: PUSH
34767: LD_INT 1
34769: PUSH
34770: LD_INT 1
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: LD_INT 0
34779: PUSH
34780: LD_INT 1
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PUSH
34787: LD_INT 1
34789: NEG
34790: PUSH
34791: LD_INT 0
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 1
34800: NEG
34801: PUSH
34802: LD_INT 1
34804: NEG
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 1
34812: NEG
34813: PUSH
34814: LD_INT 2
34816: NEG
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 0
34824: PUSH
34825: LD_INT 2
34827: NEG
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 1
34835: PUSH
34836: LD_INT 1
34838: NEG
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 2
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 2
34856: PUSH
34857: LD_INT 1
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 2
34866: PUSH
34867: LD_INT 2
34869: PUSH
34870: EMPTY
34871: LIST
34872: LIST
34873: PUSH
34874: LD_INT 1
34876: PUSH
34877: LD_INT 2
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 1
34886: NEG
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 2
34897: NEG
34898: PUSH
34899: LD_INT 0
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 2
34908: NEG
34909: PUSH
34910: LD_INT 1
34912: NEG
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: LD_INT 1
34920: NEG
34921: PUSH
34922: LD_INT 3
34924: NEG
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 1
34932: PUSH
34933: LD_INT 2
34935: NEG
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 3
34943: PUSH
34944: LD_INT 2
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: LD_INT 2
34953: PUSH
34954: LD_INT 3
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 2
34963: NEG
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 3
34974: NEG
34975: PUSH
34976: LD_INT 1
34978: NEG
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PUSH
34984: EMPTY
34985: LIST
34986: LIST
34987: LIST
34988: LIST
34989: LIST
34990: LIST
34991: LIST
34992: LIST
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: LIST
35001: LIST
35002: LIST
35003: LIST
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35009: LD_ADDR_VAR 0 31
35013: PUSH
35014: LD_INT 0
35016: PUSH
35017: LD_INT 0
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: LD_INT 0
35026: PUSH
35027: LD_INT 1
35029: NEG
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: LD_INT 1
35037: PUSH
35038: LD_INT 0
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: LD_INT 1
35047: PUSH
35048: LD_INT 1
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: PUSH
35055: LD_INT 0
35057: PUSH
35058: LD_INT 1
35060: PUSH
35061: EMPTY
35062: LIST
35063: LIST
35064: PUSH
35065: LD_INT 1
35067: NEG
35068: PUSH
35069: LD_INT 0
35071: PUSH
35072: EMPTY
35073: LIST
35074: LIST
35075: PUSH
35076: LD_INT 1
35078: NEG
35079: PUSH
35080: LD_INT 1
35082: NEG
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 1
35090: NEG
35091: PUSH
35092: LD_INT 2
35094: NEG
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 1
35102: PUSH
35103: LD_INT 1
35105: NEG
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 2
35113: PUSH
35114: LD_INT 0
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: LD_INT 2
35123: PUSH
35124: LD_INT 1
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 2
35133: PUSH
35134: LD_INT 2
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 1
35143: PUSH
35144: LD_INT 2
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: PUSH
35151: LD_INT 0
35153: PUSH
35154: LD_INT 2
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: LD_INT 1
35163: NEG
35164: PUSH
35165: LD_INT 1
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 2
35174: NEG
35175: PUSH
35176: LD_INT 1
35178: NEG
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 2
35186: NEG
35187: PUSH
35188: LD_INT 2
35190: NEG
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 2
35198: NEG
35199: PUSH
35200: LD_INT 3
35202: NEG
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 2
35210: PUSH
35211: LD_INT 1
35213: NEG
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 3
35221: PUSH
35222: LD_INT 1
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 1
35231: PUSH
35232: LD_INT 3
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: PUSH
35239: LD_INT 1
35241: NEG
35242: PUSH
35243: LD_INT 2
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: LD_INT 3
35252: NEG
35253: PUSH
35254: LD_INT 2
35256: NEG
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: LIST
35266: LIST
35267: LIST
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35287: LD_ADDR_VAR 0 32
35291: PUSH
35292: LD_INT 0
35294: PUSH
35295: LD_INT 0
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: PUSH
35316: LD_INT 0
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 1
35325: PUSH
35326: LD_INT 1
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 0
35335: PUSH
35336: LD_INT 1
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 1
35345: NEG
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 1
35356: NEG
35357: PUSH
35358: LD_INT 1
35360: NEG
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 1
35368: NEG
35369: PUSH
35370: LD_INT 2
35372: NEG
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 0
35380: PUSH
35381: LD_INT 2
35383: NEG
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 1
35391: PUSH
35392: LD_INT 1
35394: NEG
35395: PUSH
35396: EMPTY
35397: LIST
35398: LIST
35399: PUSH
35400: LD_INT 2
35402: PUSH
35403: LD_INT 1
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: LD_INT 2
35412: PUSH
35413: LD_INT 2
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: LD_INT 1
35422: PUSH
35423: LD_INT 2
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 0
35432: PUSH
35433: LD_INT 2
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 1
35442: NEG
35443: PUSH
35444: LD_INT 1
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: PUSH
35451: LD_INT 2
35453: NEG
35454: PUSH
35455: LD_INT 0
35457: PUSH
35458: EMPTY
35459: LIST
35460: LIST
35461: PUSH
35462: LD_INT 2
35464: NEG
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: EMPTY
35471: LIST
35472: LIST
35473: PUSH
35474: LD_INT 1
35476: NEG
35477: PUSH
35478: LD_INT 3
35480: NEG
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PUSH
35486: LD_INT 1
35488: PUSH
35489: LD_INT 2
35491: NEG
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 3
35499: PUSH
35500: LD_INT 2
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 2
35509: PUSH
35510: LD_INT 3
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 2
35519: NEG
35520: PUSH
35521: LD_INT 1
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 3
35530: NEG
35531: PUSH
35532: LD_INT 1
35534: NEG
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: LIST
35544: LIST
35545: LIST
35546: LIST
35547: LIST
35548: LIST
35549: LIST
35550: LIST
35551: LIST
35552: LIST
35553: LIST
35554: LIST
35555: LIST
35556: LIST
35557: LIST
35558: LIST
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35565: LD_ADDR_VAR 0 33
35569: PUSH
35570: LD_INT 0
35572: PUSH
35573: LD_INT 0
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 0
35582: PUSH
35583: LD_INT 1
35585: NEG
35586: PUSH
35587: EMPTY
35588: LIST
35589: LIST
35590: PUSH
35591: LD_INT 1
35593: PUSH
35594: LD_INT 0
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 1
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 0
35613: PUSH
35614: LD_INT 1
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 1
35623: NEG
35624: PUSH
35625: LD_INT 0
35627: PUSH
35628: EMPTY
35629: LIST
35630: LIST
35631: PUSH
35632: LD_INT 1
35634: NEG
35635: PUSH
35636: LD_INT 1
35638: NEG
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 1
35646: NEG
35647: PUSH
35648: LD_INT 2
35650: NEG
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 1
35658: PUSH
35659: LD_INT 1
35661: NEG
35662: PUSH
35663: EMPTY
35664: LIST
35665: LIST
35666: PUSH
35667: LD_INT 2
35669: PUSH
35670: LD_INT 0
35672: PUSH
35673: EMPTY
35674: LIST
35675: LIST
35676: PUSH
35677: LD_INT 2
35679: PUSH
35680: LD_INT 1
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PUSH
35687: LD_INT 1
35689: PUSH
35690: LD_INT 2
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: LD_INT 2
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: PUSH
35707: LD_INT 1
35709: NEG
35710: PUSH
35711: LD_INT 1
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: LD_INT 2
35720: NEG
35721: PUSH
35722: LD_INT 0
35724: PUSH
35725: EMPTY
35726: LIST
35727: LIST
35728: PUSH
35729: LD_INT 2
35731: NEG
35732: PUSH
35733: LD_INT 1
35735: NEG
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 2
35743: NEG
35744: PUSH
35745: LD_INT 2
35747: NEG
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 2
35755: NEG
35756: PUSH
35757: LD_INT 3
35759: NEG
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: PUSH
35765: LD_INT 2
35767: PUSH
35768: LD_INT 1
35770: NEG
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PUSH
35776: LD_INT 3
35778: PUSH
35779: LD_INT 1
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PUSH
35786: LD_INT 1
35788: PUSH
35789: LD_INT 3
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: LD_INT 1
35798: NEG
35799: PUSH
35800: LD_INT 2
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 3
35809: NEG
35810: PUSH
35811: LD_INT 2
35813: NEG
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: EMPTY
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35844: LD_ADDR_VAR 0 34
35848: PUSH
35849: LD_INT 0
35851: PUSH
35852: LD_INT 0
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 0
35861: PUSH
35862: LD_INT 1
35864: NEG
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 1
35872: PUSH
35873: LD_INT 0
35875: PUSH
35876: EMPTY
35877: LIST
35878: LIST
35879: PUSH
35880: LD_INT 1
35882: PUSH
35883: LD_INT 1
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: PUSH
35890: LD_INT 0
35892: PUSH
35893: LD_INT 1
35895: PUSH
35896: EMPTY
35897: LIST
35898: LIST
35899: PUSH
35900: LD_INT 1
35902: NEG
35903: PUSH
35904: LD_INT 0
35906: PUSH
35907: EMPTY
35908: LIST
35909: LIST
35910: PUSH
35911: LD_INT 1
35913: NEG
35914: PUSH
35915: LD_INT 1
35917: NEG
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 1
35925: NEG
35926: PUSH
35927: LD_INT 2
35929: NEG
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 0
35937: PUSH
35938: LD_INT 2
35940: NEG
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 1
35948: PUSH
35949: LD_INT 1
35951: NEG
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 2
35959: PUSH
35960: LD_INT 1
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: LD_INT 2
35969: PUSH
35970: LD_INT 2
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 1
35979: PUSH
35980: LD_INT 2
35982: PUSH
35983: EMPTY
35984: LIST
35985: LIST
35986: PUSH
35987: LD_INT 1
35989: NEG
35990: PUSH
35991: LD_INT 1
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 2
36000: NEG
36001: PUSH
36002: LD_INT 0
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 2
36011: NEG
36012: PUSH
36013: LD_INT 1
36015: NEG
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 2
36023: NEG
36024: PUSH
36025: LD_INT 2
36027: NEG
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 1
36035: NEG
36036: PUSH
36037: LD_INT 3
36039: NEG
36040: PUSH
36041: EMPTY
36042: LIST
36043: LIST
36044: PUSH
36045: LD_INT 1
36047: PUSH
36048: LD_INT 2
36050: NEG
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 3
36058: PUSH
36059: LD_INT 2
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 2
36068: PUSH
36069: LD_INT 3
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: LD_INT 2
36078: NEG
36079: PUSH
36080: LD_INT 1
36082: PUSH
36083: EMPTY
36084: LIST
36085: LIST
36086: PUSH
36087: LD_INT 3
36089: NEG
36090: PUSH
36091: LD_INT 1
36093: NEG
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: EMPTY
36100: LIST
36101: LIST
36102: LIST
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36124: LD_ADDR_VAR 0 35
36128: PUSH
36129: LD_INT 0
36131: PUSH
36132: LD_INT 0
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 0
36141: PUSH
36142: LD_INT 1
36144: NEG
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 1
36152: PUSH
36153: LD_INT 0
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: LD_INT 1
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 0
36172: PUSH
36173: LD_INT 1
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 1
36182: NEG
36183: PUSH
36184: LD_INT 0
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 1
36193: NEG
36194: PUSH
36195: LD_INT 1
36197: NEG
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 2
36205: PUSH
36206: LD_INT 1
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 2
36215: NEG
36216: PUSH
36217: LD_INT 1
36219: NEG
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: LIST
36229: LIST
36230: LIST
36231: LIST
36232: LIST
36233: LIST
36234: LIST
36235: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36236: LD_ADDR_VAR 0 36
36240: PUSH
36241: LD_INT 0
36243: PUSH
36244: LD_INT 0
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: LD_INT 1
36256: NEG
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PUSH
36262: LD_INT 1
36264: PUSH
36265: LD_INT 0
36267: PUSH
36268: EMPTY
36269: LIST
36270: LIST
36271: PUSH
36272: LD_INT 1
36274: PUSH
36275: LD_INT 1
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 0
36284: PUSH
36285: LD_INT 1
36287: PUSH
36288: EMPTY
36289: LIST
36290: LIST
36291: PUSH
36292: LD_INT 1
36294: NEG
36295: PUSH
36296: LD_INT 0
36298: PUSH
36299: EMPTY
36300: LIST
36301: LIST
36302: PUSH
36303: LD_INT 1
36305: NEG
36306: PUSH
36307: LD_INT 1
36309: NEG
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 1
36317: NEG
36318: PUSH
36319: LD_INT 2
36321: NEG
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 1
36329: PUSH
36330: LD_INT 2
36332: PUSH
36333: EMPTY
36334: LIST
36335: LIST
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: LIST
36346: LIST
36347: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36348: LD_ADDR_VAR 0 37
36352: PUSH
36353: LD_INT 0
36355: PUSH
36356: LD_INT 0
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: LD_INT 0
36365: PUSH
36366: LD_INT 1
36368: NEG
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: PUSH
36374: LD_INT 1
36376: PUSH
36377: LD_INT 0
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PUSH
36384: LD_INT 1
36386: PUSH
36387: LD_INT 1
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: LD_INT 0
36396: PUSH
36397: LD_INT 1
36399: PUSH
36400: EMPTY
36401: LIST
36402: LIST
36403: PUSH
36404: LD_INT 1
36406: NEG
36407: PUSH
36408: LD_INT 0
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 1
36417: NEG
36418: PUSH
36419: LD_INT 1
36421: NEG
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 1
36429: PUSH
36430: LD_INT 1
36432: NEG
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 1
36440: NEG
36441: PUSH
36442: LD_INT 1
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: LIST
36453: LIST
36454: LIST
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36460: LD_ADDR_VAR 0 38
36464: PUSH
36465: LD_INT 0
36467: PUSH
36468: LD_INT 0
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: LD_INT 0
36477: PUSH
36478: LD_INT 1
36480: NEG
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 1
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 1
36498: PUSH
36499: LD_INT 1
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: PUSH
36506: LD_INT 0
36508: PUSH
36509: LD_INT 1
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: PUSH
36516: LD_INT 1
36518: NEG
36519: PUSH
36520: LD_INT 0
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 1
36529: NEG
36530: PUSH
36531: LD_INT 1
36533: NEG
36534: PUSH
36535: EMPTY
36536: LIST
36537: LIST
36538: PUSH
36539: LD_INT 2
36541: PUSH
36542: LD_INT 1
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: LD_INT 2
36551: NEG
36552: PUSH
36553: LD_INT 1
36555: NEG
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: EMPTY
36562: LIST
36563: LIST
36564: LIST
36565: LIST
36566: LIST
36567: LIST
36568: LIST
36569: LIST
36570: LIST
36571: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36572: LD_ADDR_VAR 0 39
36576: PUSH
36577: LD_INT 0
36579: PUSH
36580: LD_INT 0
36582: PUSH
36583: EMPTY
36584: LIST
36585: LIST
36586: PUSH
36587: LD_INT 0
36589: PUSH
36590: LD_INT 1
36592: NEG
36593: PUSH
36594: EMPTY
36595: LIST
36596: LIST
36597: PUSH
36598: LD_INT 1
36600: PUSH
36601: LD_INT 0
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 1
36610: PUSH
36611: LD_INT 1
36613: PUSH
36614: EMPTY
36615: LIST
36616: LIST
36617: PUSH
36618: LD_INT 0
36620: PUSH
36621: LD_INT 1
36623: PUSH
36624: EMPTY
36625: LIST
36626: LIST
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: LD_INT 0
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 1
36641: NEG
36642: PUSH
36643: LD_INT 1
36645: NEG
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: PUSH
36651: LD_INT 1
36653: NEG
36654: PUSH
36655: LD_INT 2
36657: NEG
36658: PUSH
36659: EMPTY
36660: LIST
36661: LIST
36662: PUSH
36663: LD_INT 1
36665: PUSH
36666: LD_INT 2
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: EMPTY
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36684: LD_ADDR_VAR 0 40
36688: PUSH
36689: LD_INT 0
36691: PUSH
36692: LD_INT 0
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: PUSH
36699: LD_INT 0
36701: PUSH
36702: LD_INT 1
36704: NEG
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 1
36712: PUSH
36713: LD_INT 0
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: PUSH
36720: LD_INT 1
36722: PUSH
36723: LD_INT 1
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 0
36732: PUSH
36733: LD_INT 1
36735: PUSH
36736: EMPTY
36737: LIST
36738: LIST
36739: PUSH
36740: LD_INT 1
36742: NEG
36743: PUSH
36744: LD_INT 0
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 1
36753: NEG
36754: PUSH
36755: LD_INT 1
36757: NEG
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PUSH
36763: LD_INT 1
36765: PUSH
36766: LD_INT 1
36768: NEG
36769: PUSH
36770: EMPTY
36771: LIST
36772: LIST
36773: PUSH
36774: LD_INT 1
36776: NEG
36777: PUSH
36778: LD_INT 1
36780: PUSH
36781: EMPTY
36782: LIST
36783: LIST
36784: PUSH
36785: EMPTY
36786: LIST
36787: LIST
36788: LIST
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36796: LD_ADDR_VAR 0 41
36800: PUSH
36801: LD_INT 0
36803: PUSH
36804: LD_INT 0
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 0
36813: PUSH
36814: LD_INT 1
36816: NEG
36817: PUSH
36818: EMPTY
36819: LIST
36820: LIST
36821: PUSH
36822: LD_INT 1
36824: PUSH
36825: LD_INT 0
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: LD_INT 1
36834: PUSH
36835: LD_INT 1
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: PUSH
36842: LD_INT 0
36844: PUSH
36845: LD_INT 1
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 1
36854: NEG
36855: PUSH
36856: LD_INT 0
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PUSH
36863: LD_INT 1
36865: NEG
36866: PUSH
36867: LD_INT 1
36869: NEG
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 1
36877: NEG
36878: PUSH
36879: LD_INT 2
36881: NEG
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 1
36889: PUSH
36890: LD_INT 1
36892: NEG
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 2
36900: PUSH
36901: LD_INT 0
36903: PUSH
36904: EMPTY
36905: LIST
36906: LIST
36907: PUSH
36908: LD_INT 2
36910: PUSH
36911: LD_INT 1
36913: PUSH
36914: EMPTY
36915: LIST
36916: LIST
36917: PUSH
36918: LD_INT 2
36920: PUSH
36921: LD_INT 2
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 1
36930: PUSH
36931: LD_INT 2
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 1
36940: NEG
36941: PUSH
36942: LD_INT 1
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 2
36951: NEG
36952: PUSH
36953: LD_INT 0
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 2
36962: NEG
36963: PUSH
36964: LD_INT 1
36966: NEG
36967: PUSH
36968: EMPTY
36969: LIST
36970: LIST
36971: PUSH
36972: LD_INT 2
36974: NEG
36975: PUSH
36976: LD_INT 2
36978: NEG
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 2
36986: NEG
36987: PUSH
36988: LD_INT 3
36990: NEG
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 2
36998: PUSH
36999: LD_INT 1
37001: NEG
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 3
37009: PUSH
37010: LD_INT 0
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 3
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 3
37029: PUSH
37030: LD_INT 2
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 3
37039: PUSH
37040: LD_INT 3
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: LD_INT 2
37049: PUSH
37050: LD_INT 3
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 2
37059: NEG
37060: PUSH
37061: LD_INT 1
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 3
37070: NEG
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 3
37081: NEG
37082: PUSH
37083: LD_INT 1
37085: NEG
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 3
37093: NEG
37094: PUSH
37095: LD_INT 2
37097: NEG
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 3
37105: NEG
37106: PUSH
37107: LD_INT 3
37109: NEG
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: LIST
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: LIST
37145: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37146: LD_ADDR_VAR 0 42
37150: PUSH
37151: LD_INT 0
37153: PUSH
37154: LD_INT 0
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 0
37163: PUSH
37164: LD_INT 1
37166: NEG
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: PUSH
37172: LD_INT 1
37174: PUSH
37175: LD_INT 0
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 1
37184: PUSH
37185: LD_INT 1
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: LD_INT 0
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 1
37204: NEG
37205: PUSH
37206: LD_INT 0
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 1
37215: NEG
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: LD_INT 1
37227: NEG
37228: PUSH
37229: LD_INT 2
37231: NEG
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 0
37239: PUSH
37240: LD_INT 2
37242: NEG
37243: PUSH
37244: EMPTY
37245: LIST
37246: LIST
37247: PUSH
37248: LD_INT 1
37250: PUSH
37251: LD_INT 1
37253: NEG
37254: PUSH
37255: EMPTY
37256: LIST
37257: LIST
37258: PUSH
37259: LD_INT 2
37261: PUSH
37262: LD_INT 1
37264: PUSH
37265: EMPTY
37266: LIST
37267: LIST
37268: PUSH
37269: LD_INT 2
37271: PUSH
37272: LD_INT 2
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 1
37281: PUSH
37282: LD_INT 2
37284: PUSH
37285: EMPTY
37286: LIST
37287: LIST
37288: PUSH
37289: LD_INT 0
37291: PUSH
37292: LD_INT 2
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: PUSH
37299: LD_INT 1
37301: NEG
37302: PUSH
37303: LD_INT 1
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 2
37312: NEG
37313: PUSH
37314: LD_INT 1
37316: NEG
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 2
37324: NEG
37325: PUSH
37326: LD_INT 2
37328: NEG
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PUSH
37334: LD_INT 2
37336: NEG
37337: PUSH
37338: LD_INT 3
37340: NEG
37341: PUSH
37342: EMPTY
37343: LIST
37344: LIST
37345: PUSH
37346: LD_INT 1
37348: NEG
37349: PUSH
37350: LD_INT 3
37352: NEG
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: LD_INT 0
37360: PUSH
37361: LD_INT 3
37363: NEG
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 1
37371: PUSH
37372: LD_INT 2
37374: NEG
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 3
37382: PUSH
37383: LD_INT 2
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PUSH
37390: LD_INT 3
37392: PUSH
37393: LD_INT 3
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: PUSH
37400: LD_INT 2
37402: PUSH
37403: LD_INT 3
37405: PUSH
37406: EMPTY
37407: LIST
37408: LIST
37409: PUSH
37410: LD_INT 1
37412: PUSH
37413: LD_INT 3
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: LD_INT 0
37422: PUSH
37423: LD_INT 3
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: LD_INT 1
37432: NEG
37433: PUSH
37434: LD_INT 2
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: LD_INT 3
37443: NEG
37444: PUSH
37445: LD_INT 2
37447: NEG
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: LD_INT 3
37455: NEG
37456: PUSH
37457: LD_INT 3
37459: NEG
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: LIST
37469: LIST
37470: LIST
37471: LIST
37472: LIST
37473: LIST
37474: LIST
37475: LIST
37476: LIST
37477: LIST
37478: LIST
37479: LIST
37480: LIST
37481: LIST
37482: LIST
37483: LIST
37484: LIST
37485: LIST
37486: LIST
37487: LIST
37488: LIST
37489: LIST
37490: LIST
37491: LIST
37492: LIST
37493: LIST
37494: LIST
37495: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37496: LD_ADDR_VAR 0 43
37500: PUSH
37501: LD_INT 0
37503: PUSH
37504: LD_INT 0
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 0
37513: PUSH
37514: LD_INT 1
37516: NEG
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 1
37524: PUSH
37525: LD_INT 0
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 1
37534: PUSH
37535: LD_INT 1
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: LD_INT 0
37544: PUSH
37545: LD_INT 1
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 1
37554: NEG
37555: PUSH
37556: LD_INT 0
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 1
37565: NEG
37566: PUSH
37567: LD_INT 1
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 1
37577: NEG
37578: PUSH
37579: LD_INT 2
37581: NEG
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: LD_INT 0
37589: PUSH
37590: LD_INT 2
37592: NEG
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 1
37600: PUSH
37601: LD_INT 1
37603: NEG
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 2
37611: PUSH
37612: LD_INT 0
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: PUSH
37619: LD_INT 2
37621: PUSH
37622: LD_INT 1
37624: PUSH
37625: EMPTY
37626: LIST
37627: LIST
37628: PUSH
37629: LD_INT 1
37631: PUSH
37632: LD_INT 2
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PUSH
37639: LD_INT 0
37641: PUSH
37642: LD_INT 2
37644: PUSH
37645: EMPTY
37646: LIST
37647: LIST
37648: PUSH
37649: LD_INT 1
37651: NEG
37652: PUSH
37653: LD_INT 1
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: LD_INT 2
37662: NEG
37663: PUSH
37664: LD_INT 0
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 2
37673: NEG
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 1
37685: NEG
37686: PUSH
37687: LD_INT 3
37689: NEG
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 0
37697: PUSH
37698: LD_INT 3
37700: NEG
37701: PUSH
37702: EMPTY
37703: LIST
37704: LIST
37705: PUSH
37706: LD_INT 1
37708: PUSH
37709: LD_INT 2
37711: NEG
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 2
37719: PUSH
37720: LD_INT 1
37722: NEG
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 3
37730: PUSH
37731: LD_INT 0
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: LD_INT 3
37740: PUSH
37741: LD_INT 1
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 1
37750: PUSH
37751: LD_INT 3
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 0
37760: PUSH
37761: LD_INT 3
37763: PUSH
37764: EMPTY
37765: LIST
37766: LIST
37767: PUSH
37768: LD_INT 1
37770: NEG
37771: PUSH
37772: LD_INT 2
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 2
37781: NEG
37782: PUSH
37783: LD_INT 1
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 3
37792: NEG
37793: PUSH
37794: LD_INT 0
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 3
37803: NEG
37804: PUSH
37805: LD_INT 1
37807: NEG
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: LIST
37823: LIST
37824: LIST
37825: LIST
37826: LIST
37827: LIST
37828: LIST
37829: LIST
37830: LIST
37831: LIST
37832: LIST
37833: LIST
37834: LIST
37835: LIST
37836: LIST
37837: LIST
37838: LIST
37839: LIST
37840: LIST
37841: LIST
37842: LIST
37843: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37844: LD_ADDR_VAR 0 44
37848: PUSH
37849: LD_INT 0
37851: PUSH
37852: LD_INT 0
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 0
37861: PUSH
37862: LD_INT 1
37864: NEG
37865: PUSH
37866: EMPTY
37867: LIST
37868: LIST
37869: PUSH
37870: LD_INT 1
37872: PUSH
37873: LD_INT 0
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 1
37882: PUSH
37883: LD_INT 1
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: PUSH
37890: LD_INT 0
37892: PUSH
37893: LD_INT 1
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 1
37902: NEG
37903: PUSH
37904: LD_INT 0
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 1
37913: NEG
37914: PUSH
37915: LD_INT 1
37917: NEG
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: LD_INT 1
37925: NEG
37926: PUSH
37927: LD_INT 2
37929: NEG
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: LD_INT 1
37937: PUSH
37938: LD_INT 1
37940: NEG
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: LD_INT 2
37948: PUSH
37949: LD_INT 0
37951: PUSH
37952: EMPTY
37953: LIST
37954: LIST
37955: PUSH
37956: LD_INT 2
37958: PUSH
37959: LD_INT 1
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: PUSH
37966: LD_INT 2
37968: PUSH
37969: LD_INT 2
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: PUSH
37976: LD_INT 1
37978: PUSH
37979: LD_INT 2
37981: PUSH
37982: EMPTY
37983: LIST
37984: LIST
37985: PUSH
37986: LD_INT 1
37988: NEG
37989: PUSH
37990: LD_INT 1
37992: PUSH
37993: EMPTY
37994: LIST
37995: LIST
37996: PUSH
37997: LD_INT 2
37999: NEG
38000: PUSH
38001: LD_INT 0
38003: PUSH
38004: EMPTY
38005: LIST
38006: LIST
38007: PUSH
38008: LD_INT 2
38010: NEG
38011: PUSH
38012: LD_INT 1
38014: NEG
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: LD_INT 2
38022: NEG
38023: PUSH
38024: LD_INT 2
38026: NEG
38027: PUSH
38028: EMPTY
38029: LIST
38030: LIST
38031: PUSH
38032: LD_INT 2
38034: NEG
38035: PUSH
38036: LD_INT 3
38038: NEG
38039: PUSH
38040: EMPTY
38041: LIST
38042: LIST
38043: PUSH
38044: LD_INT 2
38046: PUSH
38047: LD_INT 1
38049: NEG
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 3
38057: PUSH
38058: LD_INT 0
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 3
38067: PUSH
38068: LD_INT 1
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: LD_INT 3
38077: PUSH
38078: LD_INT 2
38080: PUSH
38081: EMPTY
38082: LIST
38083: LIST
38084: PUSH
38085: LD_INT 3
38087: PUSH
38088: LD_INT 3
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 2
38097: PUSH
38098: LD_INT 3
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 2
38107: NEG
38108: PUSH
38109: LD_INT 1
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: LD_INT 3
38118: NEG
38119: PUSH
38120: LD_INT 0
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 3
38129: NEG
38130: PUSH
38131: LD_INT 1
38133: NEG
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 3
38141: NEG
38142: PUSH
38143: LD_INT 2
38145: NEG
38146: PUSH
38147: EMPTY
38148: LIST
38149: LIST
38150: PUSH
38151: LD_INT 3
38153: NEG
38154: PUSH
38155: LD_INT 3
38157: NEG
38158: PUSH
38159: EMPTY
38160: LIST
38161: LIST
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: LIST
38167: LIST
38168: LIST
38169: LIST
38170: LIST
38171: LIST
38172: LIST
38173: LIST
38174: LIST
38175: LIST
38176: LIST
38177: LIST
38178: LIST
38179: LIST
38180: LIST
38181: LIST
38182: LIST
38183: LIST
38184: LIST
38185: LIST
38186: LIST
38187: LIST
38188: LIST
38189: LIST
38190: LIST
38191: LIST
38192: LIST
38193: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38194: LD_ADDR_VAR 0 45
38198: PUSH
38199: LD_INT 0
38201: PUSH
38202: LD_INT 0
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 0
38211: PUSH
38212: LD_INT 1
38214: NEG
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 1
38222: PUSH
38223: LD_INT 0
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 1
38232: PUSH
38233: LD_INT 1
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 0
38242: PUSH
38243: LD_INT 1
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 1
38252: NEG
38253: PUSH
38254: LD_INT 0
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: LD_INT 1
38263: NEG
38264: PUSH
38265: LD_INT 1
38267: NEG
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: LD_INT 1
38275: NEG
38276: PUSH
38277: LD_INT 2
38279: NEG
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: LD_INT 0
38287: PUSH
38288: LD_INT 2
38290: NEG
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 1
38298: PUSH
38299: LD_INT 1
38301: NEG
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 2
38309: PUSH
38310: LD_INT 1
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: PUSH
38317: LD_INT 2
38319: PUSH
38320: LD_INT 2
38322: PUSH
38323: EMPTY
38324: LIST
38325: LIST
38326: PUSH
38327: LD_INT 1
38329: PUSH
38330: LD_INT 2
38332: PUSH
38333: EMPTY
38334: LIST
38335: LIST
38336: PUSH
38337: LD_INT 0
38339: PUSH
38340: LD_INT 2
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: LD_INT 1
38349: NEG
38350: PUSH
38351: LD_INT 1
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 2
38360: NEG
38361: PUSH
38362: LD_INT 1
38364: NEG
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 2
38372: NEG
38373: PUSH
38374: LD_INT 2
38376: NEG
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: PUSH
38382: LD_INT 2
38384: NEG
38385: PUSH
38386: LD_INT 3
38388: NEG
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 1
38396: NEG
38397: PUSH
38398: LD_INT 3
38400: NEG
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: LD_INT 0
38408: PUSH
38409: LD_INT 3
38411: NEG
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: PUSH
38417: LD_INT 1
38419: PUSH
38420: LD_INT 2
38422: NEG
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 3
38430: PUSH
38431: LD_INT 2
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 3
38440: PUSH
38441: LD_INT 3
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 2
38450: PUSH
38451: LD_INT 3
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: PUSH
38458: LD_INT 1
38460: PUSH
38461: LD_INT 3
38463: PUSH
38464: EMPTY
38465: LIST
38466: LIST
38467: PUSH
38468: LD_INT 0
38470: PUSH
38471: LD_INT 3
38473: PUSH
38474: EMPTY
38475: LIST
38476: LIST
38477: PUSH
38478: LD_INT 1
38480: NEG
38481: PUSH
38482: LD_INT 2
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 3
38491: NEG
38492: PUSH
38493: LD_INT 2
38495: NEG
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: PUSH
38501: LD_INT 3
38503: NEG
38504: PUSH
38505: LD_INT 3
38507: NEG
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: LIST
38525: LIST
38526: LIST
38527: LIST
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: LIST
38540: LIST
38541: LIST
38542: LIST
38543: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38544: LD_ADDR_VAR 0 46
38548: PUSH
38549: LD_INT 0
38551: PUSH
38552: LD_INT 0
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: PUSH
38559: LD_INT 0
38561: PUSH
38562: LD_INT 1
38564: NEG
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 1
38572: PUSH
38573: LD_INT 0
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: PUSH
38580: LD_INT 1
38582: PUSH
38583: LD_INT 1
38585: PUSH
38586: EMPTY
38587: LIST
38588: LIST
38589: PUSH
38590: LD_INT 0
38592: PUSH
38593: LD_INT 1
38595: PUSH
38596: EMPTY
38597: LIST
38598: LIST
38599: PUSH
38600: LD_INT 1
38602: NEG
38603: PUSH
38604: LD_INT 0
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 1
38613: NEG
38614: PUSH
38615: LD_INT 1
38617: NEG
38618: PUSH
38619: EMPTY
38620: LIST
38621: LIST
38622: PUSH
38623: LD_INT 1
38625: NEG
38626: PUSH
38627: LD_INT 2
38629: NEG
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 0
38637: PUSH
38638: LD_INT 2
38640: NEG
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: PUSH
38646: LD_INT 1
38648: PUSH
38649: LD_INT 1
38651: NEG
38652: PUSH
38653: EMPTY
38654: LIST
38655: LIST
38656: PUSH
38657: LD_INT 2
38659: PUSH
38660: LD_INT 0
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PUSH
38667: LD_INT 2
38669: PUSH
38670: LD_INT 1
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: PUSH
38677: LD_INT 1
38679: PUSH
38680: LD_INT 2
38682: PUSH
38683: EMPTY
38684: LIST
38685: LIST
38686: PUSH
38687: LD_INT 0
38689: PUSH
38690: LD_INT 2
38692: PUSH
38693: EMPTY
38694: LIST
38695: LIST
38696: PUSH
38697: LD_INT 1
38699: NEG
38700: PUSH
38701: LD_INT 1
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PUSH
38708: LD_INT 2
38710: NEG
38711: PUSH
38712: LD_INT 0
38714: PUSH
38715: EMPTY
38716: LIST
38717: LIST
38718: PUSH
38719: LD_INT 2
38721: NEG
38722: PUSH
38723: LD_INT 1
38725: NEG
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: LD_INT 1
38733: NEG
38734: PUSH
38735: LD_INT 3
38737: NEG
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 0
38745: PUSH
38746: LD_INT 3
38748: NEG
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 1
38756: PUSH
38757: LD_INT 2
38759: NEG
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PUSH
38765: LD_INT 2
38767: PUSH
38768: LD_INT 1
38770: NEG
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 3
38778: PUSH
38779: LD_INT 0
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: LD_INT 3
38788: PUSH
38789: LD_INT 1
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: PUSH
38796: LD_INT 1
38798: PUSH
38799: LD_INT 3
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 0
38808: PUSH
38809: LD_INT 3
38811: PUSH
38812: EMPTY
38813: LIST
38814: LIST
38815: PUSH
38816: LD_INT 1
38818: NEG
38819: PUSH
38820: LD_INT 2
38822: PUSH
38823: EMPTY
38824: LIST
38825: LIST
38826: PUSH
38827: LD_INT 2
38829: NEG
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: EMPTY
38835: LIST
38836: LIST
38837: PUSH
38838: LD_INT 3
38840: NEG
38841: PUSH
38842: LD_INT 0
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PUSH
38849: LD_INT 3
38851: NEG
38852: PUSH
38853: LD_INT 1
38855: NEG
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: LIST
38865: LIST
38866: LIST
38867: LIST
38868: LIST
38869: LIST
38870: LIST
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38892: LD_ADDR_VAR 0 47
38896: PUSH
38897: LD_INT 0
38899: PUSH
38900: LD_INT 0
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 0
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 1
38920: PUSH
38921: LD_INT 0
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 1
38930: PUSH
38931: LD_INT 1
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 0
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 1
38950: NEG
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 1
38961: NEG
38962: PUSH
38963: LD_INT 1
38965: NEG
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 1
38973: NEG
38974: PUSH
38975: LD_INT 2
38977: NEG
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: LD_INT 0
38985: PUSH
38986: LD_INT 2
38988: NEG
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 1
38996: PUSH
38997: LD_INT 1
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 2
39007: NEG
39008: PUSH
39009: LD_INT 1
39011: NEG
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: PUSH
39017: LD_INT 2
39019: NEG
39020: PUSH
39021: LD_INT 2
39023: NEG
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: LIST
39033: LIST
39034: LIST
39035: LIST
39036: LIST
39037: LIST
39038: LIST
39039: LIST
39040: LIST
39041: LIST
39042: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39043: LD_ADDR_VAR 0 48
39047: PUSH
39048: LD_INT 0
39050: PUSH
39051: LD_INT 0
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: LD_INT 0
39060: PUSH
39061: LD_INT 1
39063: NEG
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: LD_INT 1
39071: PUSH
39072: LD_INT 0
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 1
39081: PUSH
39082: LD_INT 1
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 0
39091: PUSH
39092: LD_INT 1
39094: PUSH
39095: EMPTY
39096: LIST
39097: LIST
39098: PUSH
39099: LD_INT 1
39101: NEG
39102: PUSH
39103: LD_INT 0
39105: PUSH
39106: EMPTY
39107: LIST
39108: LIST
39109: PUSH
39110: LD_INT 1
39112: NEG
39113: PUSH
39114: LD_INT 1
39116: NEG
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 1
39124: NEG
39125: PUSH
39126: LD_INT 2
39128: NEG
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 0
39136: PUSH
39137: LD_INT 2
39139: NEG
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 1
39147: PUSH
39148: LD_INT 1
39150: NEG
39151: PUSH
39152: EMPTY
39153: LIST
39154: LIST
39155: PUSH
39156: LD_INT 2
39158: PUSH
39159: LD_INT 0
39161: PUSH
39162: EMPTY
39163: LIST
39164: LIST
39165: PUSH
39166: LD_INT 2
39168: PUSH
39169: LD_INT 1
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: LIST
39185: LIST
39186: LIST
39187: LIST
39188: LIST
39189: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39190: LD_ADDR_VAR 0 49
39194: PUSH
39195: LD_INT 0
39197: PUSH
39198: LD_INT 0
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 0
39207: PUSH
39208: LD_INT 1
39210: NEG
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 1
39218: PUSH
39219: LD_INT 0
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: LD_INT 1
39228: PUSH
39229: LD_INT 1
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 0
39238: PUSH
39239: LD_INT 1
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 1
39248: NEG
39249: PUSH
39250: LD_INT 0
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: LD_INT 1
39259: NEG
39260: PUSH
39261: LD_INT 1
39263: NEG
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: LD_INT 1
39271: PUSH
39272: LD_INT 1
39274: NEG
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PUSH
39280: LD_INT 2
39282: PUSH
39283: LD_INT 0
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 2
39292: PUSH
39293: LD_INT 1
39295: PUSH
39296: EMPTY
39297: LIST
39298: LIST
39299: PUSH
39300: LD_INT 2
39302: PUSH
39303: LD_INT 2
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: PUSH
39310: LD_INT 1
39312: PUSH
39313: LD_INT 2
39315: PUSH
39316: EMPTY
39317: LIST
39318: LIST
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: LIST
39324: LIST
39325: LIST
39326: LIST
39327: LIST
39328: LIST
39329: LIST
39330: LIST
39331: LIST
39332: LIST
39333: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39334: LD_ADDR_VAR 0 50
39338: PUSH
39339: LD_INT 0
39341: PUSH
39342: LD_INT 0
39344: PUSH
39345: EMPTY
39346: LIST
39347: LIST
39348: PUSH
39349: LD_INT 0
39351: PUSH
39352: LD_INT 1
39354: NEG
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: LD_INT 1
39362: PUSH
39363: LD_INT 0
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 1
39372: PUSH
39373: LD_INT 1
39375: PUSH
39376: EMPTY
39377: LIST
39378: LIST
39379: PUSH
39380: LD_INT 0
39382: PUSH
39383: LD_INT 1
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 1
39392: NEG
39393: PUSH
39394: LD_INT 0
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 1
39403: NEG
39404: PUSH
39405: LD_INT 1
39407: NEG
39408: PUSH
39409: EMPTY
39410: LIST
39411: LIST
39412: PUSH
39413: LD_INT 2
39415: PUSH
39416: LD_INT 1
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 2
39425: PUSH
39426: LD_INT 2
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: PUSH
39433: LD_INT 1
39435: PUSH
39436: LD_INT 2
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 0
39445: PUSH
39446: LD_INT 2
39448: PUSH
39449: EMPTY
39450: LIST
39451: LIST
39452: PUSH
39453: LD_INT 1
39455: NEG
39456: PUSH
39457: LD_INT 1
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: LIST
39468: LIST
39469: LIST
39470: LIST
39471: LIST
39472: LIST
39473: LIST
39474: LIST
39475: LIST
39476: LIST
39477: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39478: LD_ADDR_VAR 0 51
39482: PUSH
39483: LD_INT 0
39485: PUSH
39486: LD_INT 0
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 0
39495: PUSH
39496: LD_INT 1
39498: NEG
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 1
39506: PUSH
39507: LD_INT 0
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 1
39516: PUSH
39517: LD_INT 1
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 0
39526: PUSH
39527: LD_INT 1
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: PUSH
39534: LD_INT 1
39536: NEG
39537: PUSH
39538: LD_INT 0
39540: PUSH
39541: EMPTY
39542: LIST
39543: LIST
39544: PUSH
39545: LD_INT 1
39547: NEG
39548: PUSH
39549: LD_INT 1
39551: NEG
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 1
39559: PUSH
39560: LD_INT 2
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 0
39569: PUSH
39570: LD_INT 2
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 1
39579: NEG
39580: PUSH
39581: LD_INT 1
39583: PUSH
39584: EMPTY
39585: LIST
39586: LIST
39587: PUSH
39588: LD_INT 2
39590: NEG
39591: PUSH
39592: LD_INT 0
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 2
39601: NEG
39602: PUSH
39603: LD_INT 1
39605: NEG
39606: PUSH
39607: EMPTY
39608: LIST
39609: LIST
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: LIST
39615: LIST
39616: LIST
39617: LIST
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39625: LD_ADDR_VAR 0 52
39629: PUSH
39630: LD_INT 0
39632: PUSH
39633: LD_INT 0
39635: PUSH
39636: EMPTY
39637: LIST
39638: LIST
39639: PUSH
39640: LD_INT 0
39642: PUSH
39643: LD_INT 1
39645: NEG
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: LD_INT 1
39653: PUSH
39654: LD_INT 0
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 1
39663: PUSH
39664: LD_INT 1
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 0
39673: PUSH
39674: LD_INT 1
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 1
39683: NEG
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 1
39694: NEG
39695: PUSH
39696: LD_INT 1
39698: NEG
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: PUSH
39704: LD_INT 1
39706: NEG
39707: PUSH
39708: LD_INT 2
39710: NEG
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: LD_INT 1
39718: NEG
39719: PUSH
39720: LD_INT 1
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 2
39729: NEG
39730: PUSH
39731: LD_INT 0
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 2
39740: NEG
39741: PUSH
39742: LD_INT 1
39744: NEG
39745: PUSH
39746: EMPTY
39747: LIST
39748: LIST
39749: PUSH
39750: LD_INT 2
39752: NEG
39753: PUSH
39754: LD_INT 2
39756: NEG
39757: PUSH
39758: EMPTY
39759: LIST
39760: LIST
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: LIST
39766: LIST
39767: LIST
39768: LIST
39769: LIST
39770: LIST
39771: LIST
39772: LIST
39773: LIST
39774: LIST
39775: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39776: LD_ADDR_VAR 0 53
39780: PUSH
39781: LD_INT 0
39783: PUSH
39784: LD_INT 0
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 0
39793: PUSH
39794: LD_INT 1
39796: NEG
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 1
39804: PUSH
39805: LD_INT 0
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 1
39814: PUSH
39815: LD_INT 1
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 0
39824: PUSH
39825: LD_INT 1
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 1
39834: NEG
39835: PUSH
39836: LD_INT 0
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: PUSH
39843: LD_INT 1
39845: NEG
39846: PUSH
39847: LD_INT 1
39849: NEG
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 1
39857: NEG
39858: PUSH
39859: LD_INT 2
39861: NEG
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 0
39869: PUSH
39870: LD_INT 2
39872: NEG
39873: PUSH
39874: EMPTY
39875: LIST
39876: LIST
39877: PUSH
39878: LD_INT 1
39880: PUSH
39881: LD_INT 1
39883: NEG
39884: PUSH
39885: EMPTY
39886: LIST
39887: LIST
39888: PUSH
39889: LD_INT 2
39891: PUSH
39892: LD_INT 0
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PUSH
39899: LD_INT 2
39901: PUSH
39902: LD_INT 1
39904: PUSH
39905: EMPTY
39906: LIST
39907: LIST
39908: PUSH
39909: LD_INT 2
39911: PUSH
39912: LD_INT 2
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: PUSH
39919: LD_INT 1
39921: PUSH
39922: LD_INT 2
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: PUSH
39929: LD_INT 0
39931: PUSH
39932: LD_INT 2
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: PUSH
39939: LD_INT 1
39941: NEG
39942: PUSH
39943: LD_INT 1
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 2
39952: NEG
39953: PUSH
39954: LD_INT 0
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 2
39963: NEG
39964: PUSH
39965: LD_INT 1
39967: NEG
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: PUSH
39973: LD_INT 2
39975: NEG
39976: PUSH
39977: LD_INT 2
39979: NEG
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40006: LD_ADDR_VAR 0 54
40010: PUSH
40011: LD_INT 0
40013: PUSH
40014: LD_INT 0
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 0
40023: PUSH
40024: LD_INT 1
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 1
40034: PUSH
40035: LD_INT 0
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 1
40044: PUSH
40045: LD_INT 1
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 0
40054: PUSH
40055: LD_INT 1
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 1
40064: NEG
40065: PUSH
40066: LD_INT 0
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: LD_INT 1
40075: NEG
40076: PUSH
40077: LD_INT 1
40079: NEG
40080: PUSH
40081: EMPTY
40082: LIST
40083: LIST
40084: PUSH
40085: LD_INT 1
40087: NEG
40088: PUSH
40089: LD_INT 2
40091: NEG
40092: PUSH
40093: EMPTY
40094: LIST
40095: LIST
40096: PUSH
40097: LD_INT 0
40099: PUSH
40100: LD_INT 2
40102: NEG
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 1
40110: PUSH
40111: LD_INT 1
40113: NEG
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 2
40121: PUSH
40122: LD_INT 0
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: PUSH
40129: LD_INT 2
40131: PUSH
40132: LD_INT 1
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: PUSH
40139: LD_INT 2
40141: PUSH
40142: LD_INT 2
40144: PUSH
40145: EMPTY
40146: LIST
40147: LIST
40148: PUSH
40149: LD_INT 1
40151: PUSH
40152: LD_INT 2
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PUSH
40159: LD_INT 0
40161: PUSH
40162: LD_INT 2
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 1
40171: NEG
40172: PUSH
40173: LD_INT 1
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PUSH
40180: LD_INT 2
40182: NEG
40183: PUSH
40184: LD_INT 0
40186: PUSH
40187: EMPTY
40188: LIST
40189: LIST
40190: PUSH
40191: LD_INT 2
40193: NEG
40194: PUSH
40195: LD_INT 1
40197: NEG
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: PUSH
40203: LD_INT 2
40205: NEG
40206: PUSH
40207: LD_INT 2
40209: NEG
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: EMPTY
40216: LIST
40217: LIST
40218: LIST
40219: LIST
40220: LIST
40221: LIST
40222: LIST
40223: LIST
40224: LIST
40225: LIST
40226: LIST
40227: LIST
40228: LIST
40229: LIST
40230: LIST
40231: LIST
40232: LIST
40233: LIST
40234: LIST
40235: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40236: LD_ADDR_VAR 0 55
40240: PUSH
40241: LD_INT 0
40243: PUSH
40244: LD_INT 0
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 0
40253: PUSH
40254: LD_INT 1
40256: NEG
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PUSH
40262: LD_INT 1
40264: PUSH
40265: LD_INT 0
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: LD_INT 1
40274: PUSH
40275: LD_INT 1
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: PUSH
40282: LD_INT 0
40284: PUSH
40285: LD_INT 1
40287: PUSH
40288: EMPTY
40289: LIST
40290: LIST
40291: PUSH
40292: LD_INT 1
40294: NEG
40295: PUSH
40296: LD_INT 0
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: PUSH
40303: LD_INT 1
40305: NEG
40306: PUSH
40307: LD_INT 1
40309: NEG
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 1
40317: NEG
40318: PUSH
40319: LD_INT 2
40321: NEG
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PUSH
40327: LD_INT 0
40329: PUSH
40330: LD_INT 2
40332: NEG
40333: PUSH
40334: EMPTY
40335: LIST
40336: LIST
40337: PUSH
40338: LD_INT 1
40340: PUSH
40341: LD_INT 1
40343: NEG
40344: PUSH
40345: EMPTY
40346: LIST
40347: LIST
40348: PUSH
40349: LD_INT 2
40351: PUSH
40352: LD_INT 0
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PUSH
40359: LD_INT 2
40361: PUSH
40362: LD_INT 1
40364: PUSH
40365: EMPTY
40366: LIST
40367: LIST
40368: PUSH
40369: LD_INT 2
40371: PUSH
40372: LD_INT 2
40374: PUSH
40375: EMPTY
40376: LIST
40377: LIST
40378: PUSH
40379: LD_INT 1
40381: PUSH
40382: LD_INT 2
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: PUSH
40389: LD_INT 0
40391: PUSH
40392: LD_INT 2
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: PUSH
40399: LD_INT 1
40401: NEG
40402: PUSH
40403: LD_INT 1
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 2
40412: NEG
40413: PUSH
40414: LD_INT 0
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 2
40423: NEG
40424: PUSH
40425: LD_INT 1
40427: NEG
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 2
40435: NEG
40436: PUSH
40437: LD_INT 2
40439: NEG
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: LIST
40453: LIST
40454: LIST
40455: LIST
40456: LIST
40457: LIST
40458: LIST
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40466: LD_ADDR_VAR 0 56
40470: PUSH
40471: LD_INT 0
40473: PUSH
40474: LD_INT 0
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 0
40483: PUSH
40484: LD_INT 1
40486: NEG
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 1
40494: PUSH
40495: LD_INT 0
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 1
40504: PUSH
40505: LD_INT 1
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 0
40514: PUSH
40515: LD_INT 1
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: LD_INT 1
40524: NEG
40525: PUSH
40526: LD_INT 0
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PUSH
40533: LD_INT 1
40535: NEG
40536: PUSH
40537: LD_INT 1
40539: NEG
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: LD_INT 1
40547: NEG
40548: PUSH
40549: LD_INT 2
40551: NEG
40552: PUSH
40553: EMPTY
40554: LIST
40555: LIST
40556: PUSH
40557: LD_INT 0
40559: PUSH
40560: LD_INT 2
40562: NEG
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 1
40570: PUSH
40571: LD_INT 1
40573: NEG
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 2
40581: PUSH
40582: LD_INT 0
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: PUSH
40589: LD_INT 2
40591: PUSH
40592: LD_INT 1
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: LD_INT 2
40601: PUSH
40602: LD_INT 2
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: LD_INT 1
40611: PUSH
40612: LD_INT 2
40614: PUSH
40615: EMPTY
40616: LIST
40617: LIST
40618: PUSH
40619: LD_INT 0
40621: PUSH
40622: LD_INT 2
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: PUSH
40629: LD_INT 1
40631: NEG
40632: PUSH
40633: LD_INT 1
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 2
40642: NEG
40643: PUSH
40644: LD_INT 0
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 2
40653: NEG
40654: PUSH
40655: LD_INT 1
40657: NEG
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 2
40665: NEG
40666: PUSH
40667: LD_INT 2
40669: NEG
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40696: LD_ADDR_VAR 0 57
40700: PUSH
40701: LD_INT 0
40703: PUSH
40704: LD_INT 0
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PUSH
40711: LD_INT 0
40713: PUSH
40714: LD_INT 1
40716: NEG
40717: PUSH
40718: EMPTY
40719: LIST
40720: LIST
40721: PUSH
40722: LD_INT 1
40724: PUSH
40725: LD_INT 0
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 1
40734: PUSH
40735: LD_INT 1
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: PUSH
40742: LD_INT 0
40744: PUSH
40745: LD_INT 1
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 1
40754: NEG
40755: PUSH
40756: LD_INT 0
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 1
40765: NEG
40766: PUSH
40767: LD_INT 1
40769: NEG
40770: PUSH
40771: EMPTY
40772: LIST
40773: LIST
40774: PUSH
40775: LD_INT 1
40777: NEG
40778: PUSH
40779: LD_INT 2
40781: NEG
40782: PUSH
40783: EMPTY
40784: LIST
40785: LIST
40786: PUSH
40787: LD_INT 0
40789: PUSH
40790: LD_INT 2
40792: NEG
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: LD_INT 1
40800: PUSH
40801: LD_INT 1
40803: NEG
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: PUSH
40809: LD_INT 2
40811: PUSH
40812: LD_INT 0
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: LD_INT 2
40821: PUSH
40822: LD_INT 1
40824: PUSH
40825: EMPTY
40826: LIST
40827: LIST
40828: PUSH
40829: LD_INT 2
40831: PUSH
40832: LD_INT 2
40834: PUSH
40835: EMPTY
40836: LIST
40837: LIST
40838: PUSH
40839: LD_INT 1
40841: PUSH
40842: LD_INT 2
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: PUSH
40849: LD_INT 0
40851: PUSH
40852: LD_INT 2
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: PUSH
40859: LD_INT 1
40861: NEG
40862: PUSH
40863: LD_INT 1
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 2
40872: NEG
40873: PUSH
40874: LD_INT 0
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 2
40883: NEG
40884: PUSH
40885: LD_INT 1
40887: NEG
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 2
40895: NEG
40896: PUSH
40897: LD_INT 2
40899: NEG
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: LIST
40913: LIST
40914: LIST
40915: LIST
40916: LIST
40917: LIST
40918: LIST
40919: LIST
40920: LIST
40921: LIST
40922: LIST
40923: LIST
40924: LIST
40925: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40926: LD_ADDR_VAR 0 58
40930: PUSH
40931: LD_INT 0
40933: PUSH
40934: LD_INT 0
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PUSH
40941: LD_INT 0
40943: PUSH
40944: LD_INT 1
40946: NEG
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: PUSH
40952: LD_INT 1
40954: PUSH
40955: LD_INT 0
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PUSH
40962: LD_INT 1
40964: PUSH
40965: LD_INT 1
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 0
40974: PUSH
40975: LD_INT 1
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: LD_INT 1
40984: NEG
40985: PUSH
40986: LD_INT 0
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: PUSH
40993: LD_INT 1
40995: NEG
40996: PUSH
40997: LD_INT 1
40999: NEG
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PUSH
41005: LD_INT 1
41007: NEG
41008: PUSH
41009: LD_INT 2
41011: NEG
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PUSH
41017: LD_INT 0
41019: PUSH
41020: LD_INT 2
41022: NEG
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PUSH
41028: LD_INT 1
41030: PUSH
41031: LD_INT 1
41033: NEG
41034: PUSH
41035: EMPTY
41036: LIST
41037: LIST
41038: PUSH
41039: LD_INT 2
41041: PUSH
41042: LD_INT 0
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 2
41051: PUSH
41052: LD_INT 1
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 2
41061: PUSH
41062: LD_INT 2
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: LD_INT 1
41071: PUSH
41072: LD_INT 2
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: PUSH
41079: LD_INT 0
41081: PUSH
41082: LD_INT 2
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 1
41091: NEG
41092: PUSH
41093: LD_INT 1
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 2
41102: NEG
41103: PUSH
41104: LD_INT 0
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 2
41113: NEG
41114: PUSH
41115: LD_INT 1
41117: NEG
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: PUSH
41123: LD_INT 2
41125: NEG
41126: PUSH
41127: LD_INT 2
41129: NEG
41130: PUSH
41131: EMPTY
41132: LIST
41133: LIST
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: LIST
41139: LIST
41140: LIST
41141: LIST
41142: LIST
41143: LIST
41144: LIST
41145: LIST
41146: LIST
41147: LIST
41148: LIST
41149: LIST
41150: LIST
41151: LIST
41152: LIST
41153: LIST
41154: LIST
41155: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41156: LD_ADDR_VAR 0 59
41160: PUSH
41161: LD_INT 0
41163: PUSH
41164: LD_INT 0
41166: PUSH
41167: EMPTY
41168: LIST
41169: LIST
41170: PUSH
41171: LD_INT 0
41173: PUSH
41174: LD_INT 1
41176: NEG
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 1
41184: PUSH
41185: LD_INT 0
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 1
41194: PUSH
41195: LD_INT 1
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 0
41204: PUSH
41205: LD_INT 1
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 1
41214: NEG
41215: PUSH
41216: LD_INT 0
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 1
41225: NEG
41226: PUSH
41227: LD_INT 1
41229: NEG
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41244: LD_ADDR_VAR 0 60
41248: PUSH
41249: LD_INT 0
41251: PUSH
41252: LD_INT 0
41254: PUSH
41255: EMPTY
41256: LIST
41257: LIST
41258: PUSH
41259: LD_INT 0
41261: PUSH
41262: LD_INT 1
41264: NEG
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: PUSH
41270: LD_INT 1
41272: PUSH
41273: LD_INT 0
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 1
41282: PUSH
41283: LD_INT 1
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: LD_INT 0
41292: PUSH
41293: LD_INT 1
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: PUSH
41300: LD_INT 1
41302: NEG
41303: PUSH
41304: LD_INT 0
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: PUSH
41311: LD_INT 1
41313: NEG
41314: PUSH
41315: LD_INT 1
41317: NEG
41318: PUSH
41319: EMPTY
41320: LIST
41321: LIST
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: LIST
41327: LIST
41328: LIST
41329: LIST
41330: LIST
41331: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41332: LD_ADDR_VAR 0 61
41336: PUSH
41337: LD_INT 0
41339: PUSH
41340: LD_INT 0
41342: PUSH
41343: EMPTY
41344: LIST
41345: LIST
41346: PUSH
41347: LD_INT 0
41349: PUSH
41350: LD_INT 1
41352: NEG
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 1
41360: PUSH
41361: LD_INT 0
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 1
41370: PUSH
41371: LD_INT 1
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 0
41380: PUSH
41381: LD_INT 1
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 1
41390: NEG
41391: PUSH
41392: LD_INT 0
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 1
41401: NEG
41402: PUSH
41403: LD_INT 1
41405: NEG
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: LIST
41415: LIST
41416: LIST
41417: LIST
41418: LIST
41419: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41420: LD_ADDR_VAR 0 62
41424: PUSH
41425: LD_INT 0
41427: PUSH
41428: LD_INT 0
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: PUSH
41435: LD_INT 0
41437: PUSH
41438: LD_INT 1
41440: NEG
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: LD_INT 1
41448: PUSH
41449: LD_INT 0
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: LD_INT 1
41458: PUSH
41459: LD_INT 1
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PUSH
41466: LD_INT 0
41468: PUSH
41469: LD_INT 1
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: LD_INT 1
41478: NEG
41479: PUSH
41480: LD_INT 0
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 1
41489: NEG
41490: PUSH
41491: LD_INT 1
41493: NEG
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PUSH
41499: EMPTY
41500: LIST
41501: LIST
41502: LIST
41503: LIST
41504: LIST
41505: LIST
41506: LIST
41507: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41508: LD_ADDR_VAR 0 63
41512: PUSH
41513: LD_INT 0
41515: PUSH
41516: LD_INT 0
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 0
41525: PUSH
41526: LD_INT 1
41528: NEG
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 1
41536: PUSH
41537: LD_INT 0
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 1
41546: PUSH
41547: LD_INT 1
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 0
41556: PUSH
41557: LD_INT 1
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 1
41566: NEG
41567: PUSH
41568: LD_INT 0
41570: PUSH
41571: EMPTY
41572: LIST
41573: LIST
41574: PUSH
41575: LD_INT 1
41577: NEG
41578: PUSH
41579: LD_INT 1
41581: NEG
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41596: LD_ADDR_VAR 0 64
41600: PUSH
41601: LD_INT 0
41603: PUSH
41604: LD_INT 0
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: PUSH
41611: LD_INT 0
41613: PUSH
41614: LD_INT 1
41616: NEG
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: PUSH
41622: LD_INT 1
41624: PUSH
41625: LD_INT 0
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 1
41634: PUSH
41635: LD_INT 1
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_INT 0
41644: PUSH
41645: LD_INT 1
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 1
41654: NEG
41655: PUSH
41656: LD_INT 0
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 1
41665: NEG
41666: PUSH
41667: LD_INT 1
41669: NEG
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: EMPTY
41676: LIST
41677: LIST
41678: LIST
41679: LIST
41680: LIST
41681: LIST
41682: LIST
41683: ST_TO_ADDR
// end ; 1 :
41684: GO 47581
41686: LD_INT 1
41688: DOUBLE
41689: EQUAL
41690: IFTRUE 41694
41692: GO 44317
41694: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41695: LD_ADDR_VAR 0 11
41699: PUSH
41700: LD_INT 1
41702: NEG
41703: PUSH
41704: LD_INT 3
41706: NEG
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: LD_INT 0
41714: PUSH
41715: LD_INT 3
41717: NEG
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: LD_INT 1
41725: PUSH
41726: LD_INT 2
41728: NEG
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PUSH
41734: EMPTY
41735: LIST
41736: LIST
41737: LIST
41738: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41739: LD_ADDR_VAR 0 12
41743: PUSH
41744: LD_INT 2
41746: PUSH
41747: LD_INT 1
41749: NEG
41750: PUSH
41751: EMPTY
41752: LIST
41753: LIST
41754: PUSH
41755: LD_INT 3
41757: PUSH
41758: LD_INT 0
41760: PUSH
41761: EMPTY
41762: LIST
41763: LIST
41764: PUSH
41765: LD_INT 3
41767: PUSH
41768: LD_INT 1
41770: PUSH
41771: EMPTY
41772: LIST
41773: LIST
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: LIST
41779: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41780: LD_ADDR_VAR 0 13
41784: PUSH
41785: LD_INT 3
41787: PUSH
41788: LD_INT 2
41790: PUSH
41791: EMPTY
41792: LIST
41793: LIST
41794: PUSH
41795: LD_INT 3
41797: PUSH
41798: LD_INT 3
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: PUSH
41805: LD_INT 2
41807: PUSH
41808: LD_INT 3
41810: PUSH
41811: EMPTY
41812: LIST
41813: LIST
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: LIST
41819: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41820: LD_ADDR_VAR 0 14
41824: PUSH
41825: LD_INT 1
41827: PUSH
41828: LD_INT 3
41830: PUSH
41831: EMPTY
41832: LIST
41833: LIST
41834: PUSH
41835: LD_INT 0
41837: PUSH
41838: LD_INT 3
41840: PUSH
41841: EMPTY
41842: LIST
41843: LIST
41844: PUSH
41845: LD_INT 1
41847: NEG
41848: PUSH
41849: LD_INT 2
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: LIST
41860: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41861: LD_ADDR_VAR 0 15
41865: PUSH
41866: LD_INT 2
41868: NEG
41869: PUSH
41870: LD_INT 1
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: LD_INT 3
41879: NEG
41880: PUSH
41881: LD_INT 0
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 3
41890: NEG
41891: PUSH
41892: LD_INT 1
41894: NEG
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: LIST
41904: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41905: LD_ADDR_VAR 0 16
41909: PUSH
41910: LD_INT 2
41912: NEG
41913: PUSH
41914: LD_INT 3
41916: NEG
41917: PUSH
41918: EMPTY
41919: LIST
41920: LIST
41921: PUSH
41922: LD_INT 3
41924: NEG
41925: PUSH
41926: LD_INT 2
41928: NEG
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PUSH
41934: LD_INT 3
41936: NEG
41937: PUSH
41938: LD_INT 3
41940: NEG
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PUSH
41946: EMPTY
41947: LIST
41948: LIST
41949: LIST
41950: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41951: LD_ADDR_VAR 0 17
41955: PUSH
41956: LD_INT 1
41958: NEG
41959: PUSH
41960: LD_INT 3
41962: NEG
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: PUSH
41968: LD_INT 0
41970: PUSH
41971: LD_INT 3
41973: NEG
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 1
41981: PUSH
41982: LD_INT 2
41984: NEG
41985: PUSH
41986: EMPTY
41987: LIST
41988: LIST
41989: PUSH
41990: EMPTY
41991: LIST
41992: LIST
41993: LIST
41994: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41995: LD_ADDR_VAR 0 18
41999: PUSH
42000: LD_INT 2
42002: PUSH
42003: LD_INT 1
42005: NEG
42006: PUSH
42007: EMPTY
42008: LIST
42009: LIST
42010: PUSH
42011: LD_INT 3
42013: PUSH
42014: LD_INT 0
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: PUSH
42021: LD_INT 3
42023: PUSH
42024: LD_INT 1
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: PUSH
42031: EMPTY
42032: LIST
42033: LIST
42034: LIST
42035: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42036: LD_ADDR_VAR 0 19
42040: PUSH
42041: LD_INT 3
42043: PUSH
42044: LD_INT 2
42046: PUSH
42047: EMPTY
42048: LIST
42049: LIST
42050: PUSH
42051: LD_INT 3
42053: PUSH
42054: LD_INT 3
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 2
42063: PUSH
42064: LD_INT 3
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: LIST
42075: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42076: LD_ADDR_VAR 0 20
42080: PUSH
42081: LD_INT 1
42083: PUSH
42084: LD_INT 3
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 0
42093: PUSH
42094: LD_INT 3
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 1
42103: NEG
42104: PUSH
42105: LD_INT 2
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: PUSH
42112: EMPTY
42113: LIST
42114: LIST
42115: LIST
42116: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42117: LD_ADDR_VAR 0 21
42121: PUSH
42122: LD_INT 2
42124: NEG
42125: PUSH
42126: LD_INT 1
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: LD_INT 3
42135: NEG
42136: PUSH
42137: LD_INT 0
42139: PUSH
42140: EMPTY
42141: LIST
42142: LIST
42143: PUSH
42144: LD_INT 3
42146: NEG
42147: PUSH
42148: LD_INT 1
42150: NEG
42151: PUSH
42152: EMPTY
42153: LIST
42154: LIST
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: LIST
42160: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42161: LD_ADDR_VAR 0 22
42165: PUSH
42166: LD_INT 2
42168: NEG
42169: PUSH
42170: LD_INT 3
42172: NEG
42173: PUSH
42174: EMPTY
42175: LIST
42176: LIST
42177: PUSH
42178: LD_INT 3
42180: NEG
42181: PUSH
42182: LD_INT 2
42184: NEG
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 3
42192: NEG
42193: PUSH
42194: LD_INT 3
42196: NEG
42197: PUSH
42198: EMPTY
42199: LIST
42200: LIST
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: LIST
42206: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
42207: LD_ADDR_VAR 0 23
42211: PUSH
42212: LD_INT 0
42214: PUSH
42215: LD_INT 3
42217: NEG
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 1
42225: NEG
42226: PUSH
42227: LD_INT 4
42229: NEG
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: LD_INT 1
42237: PUSH
42238: LD_INT 3
42240: NEG
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: EMPTY
42247: LIST
42248: LIST
42249: LIST
42250: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
42251: LD_ADDR_VAR 0 24
42255: PUSH
42256: LD_INT 3
42258: PUSH
42259: LD_INT 0
42261: PUSH
42262: EMPTY
42263: LIST
42264: LIST
42265: PUSH
42266: LD_INT 3
42268: PUSH
42269: LD_INT 1
42271: NEG
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: LD_INT 4
42279: PUSH
42280: LD_INT 1
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: LIST
42291: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
42292: LD_ADDR_VAR 0 25
42296: PUSH
42297: LD_INT 3
42299: PUSH
42300: LD_INT 3
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: LD_INT 4
42309: PUSH
42310: LD_INT 3
42312: PUSH
42313: EMPTY
42314: LIST
42315: LIST
42316: PUSH
42317: LD_INT 3
42319: PUSH
42320: LD_INT 4
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: LIST
42331: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
42332: LD_ADDR_VAR 0 26
42336: PUSH
42337: LD_INT 0
42339: PUSH
42340: LD_INT 3
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 1
42349: PUSH
42350: LD_INT 4
42352: PUSH
42353: EMPTY
42354: LIST
42355: LIST
42356: PUSH
42357: LD_INT 1
42359: NEG
42360: PUSH
42361: LD_INT 3
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: EMPTY
42369: LIST
42370: LIST
42371: LIST
42372: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
42373: LD_ADDR_VAR 0 27
42377: PUSH
42378: LD_INT 3
42380: NEG
42381: PUSH
42382: LD_INT 0
42384: PUSH
42385: EMPTY
42386: LIST
42387: LIST
42388: PUSH
42389: LD_INT 3
42391: NEG
42392: PUSH
42393: LD_INT 1
42395: PUSH
42396: EMPTY
42397: LIST
42398: LIST
42399: PUSH
42400: LD_INT 4
42402: NEG
42403: PUSH
42404: LD_INT 1
42406: NEG
42407: PUSH
42408: EMPTY
42409: LIST
42410: LIST
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: LIST
42416: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
42417: LD_ADDR_VAR 0 28
42421: PUSH
42422: LD_INT 3
42424: NEG
42425: PUSH
42426: LD_INT 3
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 3
42436: NEG
42437: PUSH
42438: LD_INT 4
42440: NEG
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 4
42448: NEG
42449: PUSH
42450: LD_INT 3
42452: NEG
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: EMPTY
42459: LIST
42460: LIST
42461: LIST
42462: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42463: LD_ADDR_VAR 0 29
42467: PUSH
42468: LD_INT 1
42470: NEG
42471: PUSH
42472: LD_INT 3
42474: NEG
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: LD_INT 0
42482: PUSH
42483: LD_INT 3
42485: NEG
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 1
42493: PUSH
42494: LD_INT 2
42496: NEG
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PUSH
42502: LD_INT 1
42504: NEG
42505: PUSH
42506: LD_INT 4
42508: NEG
42509: PUSH
42510: EMPTY
42511: LIST
42512: LIST
42513: PUSH
42514: LD_INT 0
42516: PUSH
42517: LD_INT 4
42519: NEG
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: PUSH
42525: LD_INT 1
42527: PUSH
42528: LD_INT 3
42530: NEG
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: LD_INT 1
42538: NEG
42539: PUSH
42540: LD_INT 5
42542: NEG
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 0
42550: PUSH
42551: LD_INT 5
42553: NEG
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 1
42561: PUSH
42562: LD_INT 4
42564: NEG
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 1
42572: NEG
42573: PUSH
42574: LD_INT 6
42576: NEG
42577: PUSH
42578: EMPTY
42579: LIST
42580: LIST
42581: PUSH
42582: LD_INT 0
42584: PUSH
42585: LD_INT 6
42587: NEG
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: PUSH
42593: LD_INT 1
42595: PUSH
42596: LD_INT 5
42598: NEG
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: EMPTY
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42618: LD_ADDR_VAR 0 30
42622: PUSH
42623: LD_INT 2
42625: PUSH
42626: LD_INT 1
42628: NEG
42629: PUSH
42630: EMPTY
42631: LIST
42632: LIST
42633: PUSH
42634: LD_INT 3
42636: PUSH
42637: LD_INT 0
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 3
42646: PUSH
42647: LD_INT 1
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 3
42656: PUSH
42657: LD_INT 1
42659: NEG
42660: PUSH
42661: EMPTY
42662: LIST
42663: LIST
42664: PUSH
42665: LD_INT 4
42667: PUSH
42668: LD_INT 0
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: LD_INT 4
42677: PUSH
42678: LD_INT 1
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: LD_INT 4
42687: PUSH
42688: LD_INT 1
42690: NEG
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: LD_INT 5
42698: PUSH
42699: LD_INT 0
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: PUSH
42706: LD_INT 5
42708: PUSH
42709: LD_INT 1
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PUSH
42716: LD_INT 5
42718: PUSH
42719: LD_INT 1
42721: NEG
42722: PUSH
42723: EMPTY
42724: LIST
42725: LIST
42726: PUSH
42727: LD_INT 6
42729: PUSH
42730: LD_INT 0
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: PUSH
42737: LD_INT 6
42739: PUSH
42740: LD_INT 1
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: LIST
42751: LIST
42752: LIST
42753: LIST
42754: LIST
42755: LIST
42756: LIST
42757: LIST
42758: LIST
42759: LIST
42760: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42761: LD_ADDR_VAR 0 31
42765: PUSH
42766: LD_INT 3
42768: PUSH
42769: LD_INT 2
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PUSH
42776: LD_INT 3
42778: PUSH
42779: LD_INT 3
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: PUSH
42786: LD_INT 2
42788: PUSH
42789: LD_INT 3
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: PUSH
42796: LD_INT 4
42798: PUSH
42799: LD_INT 3
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: PUSH
42806: LD_INT 4
42808: PUSH
42809: LD_INT 4
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: PUSH
42816: LD_INT 3
42818: PUSH
42819: LD_INT 4
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 5
42828: PUSH
42829: LD_INT 4
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 5
42838: PUSH
42839: LD_INT 5
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: PUSH
42846: LD_INT 4
42848: PUSH
42849: LD_INT 5
42851: PUSH
42852: EMPTY
42853: LIST
42854: LIST
42855: PUSH
42856: LD_INT 6
42858: PUSH
42859: LD_INT 5
42861: PUSH
42862: EMPTY
42863: LIST
42864: LIST
42865: PUSH
42866: LD_INT 6
42868: PUSH
42869: LD_INT 6
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 5
42878: PUSH
42879: LD_INT 6
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: LIST
42892: LIST
42893: LIST
42894: LIST
42895: LIST
42896: LIST
42897: LIST
42898: LIST
42899: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42900: LD_ADDR_VAR 0 32
42904: PUSH
42905: LD_INT 1
42907: PUSH
42908: LD_INT 3
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: LD_INT 0
42917: PUSH
42918: LD_INT 3
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: PUSH
42925: LD_INT 1
42927: NEG
42928: PUSH
42929: LD_INT 2
42931: PUSH
42932: EMPTY
42933: LIST
42934: LIST
42935: PUSH
42936: LD_INT 1
42938: PUSH
42939: LD_INT 4
42941: PUSH
42942: EMPTY
42943: LIST
42944: LIST
42945: PUSH
42946: LD_INT 0
42948: PUSH
42949: LD_INT 4
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: LD_INT 1
42958: NEG
42959: PUSH
42960: LD_INT 3
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: LD_INT 1
42969: PUSH
42970: LD_INT 5
42972: PUSH
42973: EMPTY
42974: LIST
42975: LIST
42976: PUSH
42977: LD_INT 0
42979: PUSH
42980: LD_INT 5
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: PUSH
42987: LD_INT 1
42989: NEG
42990: PUSH
42991: LD_INT 4
42993: PUSH
42994: EMPTY
42995: LIST
42996: LIST
42997: PUSH
42998: LD_INT 1
43000: PUSH
43001: LD_INT 6
43003: PUSH
43004: EMPTY
43005: LIST
43006: LIST
43007: PUSH
43008: LD_INT 0
43010: PUSH
43011: LD_INT 6
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: PUSH
43018: LD_INT 1
43020: NEG
43021: PUSH
43022: LD_INT 5
43024: PUSH
43025: EMPTY
43026: LIST
43027: LIST
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
43043: LD_ADDR_VAR 0 33
43047: PUSH
43048: LD_INT 2
43050: NEG
43051: PUSH
43052: LD_INT 1
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: LD_INT 3
43061: NEG
43062: PUSH
43063: LD_INT 0
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PUSH
43070: LD_INT 3
43072: NEG
43073: PUSH
43074: LD_INT 1
43076: NEG
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 3
43084: NEG
43085: PUSH
43086: LD_INT 1
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 4
43095: NEG
43096: PUSH
43097: LD_INT 0
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: LD_INT 4
43106: NEG
43107: PUSH
43108: LD_INT 1
43110: NEG
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PUSH
43116: LD_INT 4
43118: NEG
43119: PUSH
43120: LD_INT 1
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 5
43129: NEG
43130: PUSH
43131: LD_INT 0
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: PUSH
43138: LD_INT 5
43140: NEG
43141: PUSH
43142: LD_INT 1
43144: NEG
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: PUSH
43150: LD_INT 5
43152: NEG
43153: PUSH
43154: LD_INT 1
43156: PUSH
43157: EMPTY
43158: LIST
43159: LIST
43160: PUSH
43161: LD_INT 6
43163: NEG
43164: PUSH
43165: LD_INT 0
43167: PUSH
43168: EMPTY
43169: LIST
43170: LIST
43171: PUSH
43172: LD_INT 6
43174: NEG
43175: PUSH
43176: LD_INT 1
43178: NEG
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: LIST
43196: LIST
43197: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
43198: LD_ADDR_VAR 0 34
43202: PUSH
43203: LD_INT 2
43205: NEG
43206: PUSH
43207: LD_INT 3
43209: NEG
43210: PUSH
43211: EMPTY
43212: LIST
43213: LIST
43214: PUSH
43215: LD_INT 3
43217: NEG
43218: PUSH
43219: LD_INT 2
43221: NEG
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: LD_INT 3
43229: NEG
43230: PUSH
43231: LD_INT 3
43233: NEG
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: LD_INT 3
43241: NEG
43242: PUSH
43243: LD_INT 4
43245: NEG
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: PUSH
43251: LD_INT 4
43253: NEG
43254: PUSH
43255: LD_INT 3
43257: NEG
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: PUSH
43263: LD_INT 4
43265: NEG
43266: PUSH
43267: LD_INT 4
43269: NEG
43270: PUSH
43271: EMPTY
43272: LIST
43273: LIST
43274: PUSH
43275: LD_INT 4
43277: NEG
43278: PUSH
43279: LD_INT 5
43281: NEG
43282: PUSH
43283: EMPTY
43284: LIST
43285: LIST
43286: PUSH
43287: LD_INT 5
43289: NEG
43290: PUSH
43291: LD_INT 4
43293: NEG
43294: PUSH
43295: EMPTY
43296: LIST
43297: LIST
43298: PUSH
43299: LD_INT 5
43301: NEG
43302: PUSH
43303: LD_INT 5
43305: NEG
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: LD_INT 5
43313: NEG
43314: PUSH
43315: LD_INT 6
43317: NEG
43318: PUSH
43319: EMPTY
43320: LIST
43321: LIST
43322: PUSH
43323: LD_INT 6
43325: NEG
43326: PUSH
43327: LD_INT 5
43329: NEG
43330: PUSH
43331: EMPTY
43332: LIST
43333: LIST
43334: PUSH
43335: LD_INT 6
43337: NEG
43338: PUSH
43339: LD_INT 6
43341: NEG
43342: PUSH
43343: EMPTY
43344: LIST
43345: LIST
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: LIST
43351: LIST
43352: LIST
43353: LIST
43354: LIST
43355: LIST
43356: LIST
43357: LIST
43358: LIST
43359: LIST
43360: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
43361: LD_ADDR_VAR 0 41
43365: PUSH
43366: LD_INT 0
43368: PUSH
43369: LD_INT 2
43371: NEG
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 1
43379: NEG
43380: PUSH
43381: LD_INT 3
43383: NEG
43384: PUSH
43385: EMPTY
43386: LIST
43387: LIST
43388: PUSH
43389: LD_INT 1
43391: PUSH
43392: LD_INT 2
43394: NEG
43395: PUSH
43396: EMPTY
43397: LIST
43398: LIST
43399: PUSH
43400: EMPTY
43401: LIST
43402: LIST
43403: LIST
43404: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
43405: LD_ADDR_VAR 0 42
43409: PUSH
43410: LD_INT 2
43412: PUSH
43413: LD_INT 0
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: LD_INT 2
43422: PUSH
43423: LD_INT 1
43425: NEG
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: PUSH
43431: LD_INT 3
43433: PUSH
43434: LD_INT 1
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: LIST
43445: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
43446: LD_ADDR_VAR 0 43
43450: PUSH
43451: LD_INT 2
43453: PUSH
43454: LD_INT 2
43456: PUSH
43457: EMPTY
43458: LIST
43459: LIST
43460: PUSH
43461: LD_INT 3
43463: PUSH
43464: LD_INT 2
43466: PUSH
43467: EMPTY
43468: LIST
43469: LIST
43470: PUSH
43471: LD_INT 2
43473: PUSH
43474: LD_INT 3
43476: PUSH
43477: EMPTY
43478: LIST
43479: LIST
43480: PUSH
43481: EMPTY
43482: LIST
43483: LIST
43484: LIST
43485: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43486: LD_ADDR_VAR 0 44
43490: PUSH
43491: LD_INT 0
43493: PUSH
43494: LD_INT 2
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 1
43503: PUSH
43504: LD_INT 3
43506: PUSH
43507: EMPTY
43508: LIST
43509: LIST
43510: PUSH
43511: LD_INT 1
43513: NEG
43514: PUSH
43515: LD_INT 2
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: LIST
43526: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43527: LD_ADDR_VAR 0 45
43531: PUSH
43532: LD_INT 2
43534: NEG
43535: PUSH
43536: LD_INT 0
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 2
43545: NEG
43546: PUSH
43547: LD_INT 1
43549: PUSH
43550: EMPTY
43551: LIST
43552: LIST
43553: PUSH
43554: LD_INT 3
43556: NEG
43557: PUSH
43558: LD_INT 1
43560: NEG
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: EMPTY
43567: LIST
43568: LIST
43569: LIST
43570: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43571: LD_ADDR_VAR 0 46
43575: PUSH
43576: LD_INT 2
43578: NEG
43579: PUSH
43580: LD_INT 2
43582: NEG
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: PUSH
43588: LD_INT 2
43590: NEG
43591: PUSH
43592: LD_INT 3
43594: NEG
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PUSH
43600: LD_INT 3
43602: NEG
43603: PUSH
43604: LD_INT 2
43606: NEG
43607: PUSH
43608: EMPTY
43609: LIST
43610: LIST
43611: PUSH
43612: EMPTY
43613: LIST
43614: LIST
43615: LIST
43616: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43617: LD_ADDR_VAR 0 47
43621: PUSH
43622: LD_INT 2
43624: NEG
43625: PUSH
43626: LD_INT 3
43628: NEG
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 1
43636: NEG
43637: PUSH
43638: LD_INT 3
43640: NEG
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: EMPTY
43647: LIST
43648: LIST
43649: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43650: LD_ADDR_VAR 0 48
43654: PUSH
43655: LD_INT 1
43657: PUSH
43658: LD_INT 2
43660: NEG
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: LD_INT 2
43668: PUSH
43669: LD_INT 1
43671: NEG
43672: PUSH
43673: EMPTY
43674: LIST
43675: LIST
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43681: LD_ADDR_VAR 0 49
43685: PUSH
43686: LD_INT 3
43688: PUSH
43689: LD_INT 1
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 3
43698: PUSH
43699: LD_INT 2
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: PUSH
43706: EMPTY
43707: LIST
43708: LIST
43709: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43710: LD_ADDR_VAR 0 50
43714: PUSH
43715: LD_INT 2
43717: PUSH
43718: LD_INT 3
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 1
43727: PUSH
43728: LD_INT 3
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43739: LD_ADDR_VAR 0 51
43743: PUSH
43744: LD_INT 1
43746: NEG
43747: PUSH
43748: LD_INT 2
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 2
43757: NEG
43758: PUSH
43759: LD_INT 1
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43770: LD_ADDR_VAR 0 52
43774: PUSH
43775: LD_INT 3
43777: NEG
43778: PUSH
43779: LD_INT 1
43781: NEG
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 3
43789: NEG
43790: PUSH
43791: LD_INT 2
43793: NEG
43794: PUSH
43795: EMPTY
43796: LIST
43797: LIST
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43803: LD_ADDR_VAR 0 53
43807: PUSH
43808: LD_INT 1
43810: NEG
43811: PUSH
43812: LD_INT 3
43814: NEG
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 0
43822: PUSH
43823: LD_INT 3
43825: NEG
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: LD_INT 1
43833: PUSH
43834: LD_INT 2
43836: NEG
43837: PUSH
43838: EMPTY
43839: LIST
43840: LIST
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: LIST
43846: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43847: LD_ADDR_VAR 0 54
43851: PUSH
43852: LD_INT 2
43854: PUSH
43855: LD_INT 1
43857: NEG
43858: PUSH
43859: EMPTY
43860: LIST
43861: LIST
43862: PUSH
43863: LD_INT 3
43865: PUSH
43866: LD_INT 0
43868: PUSH
43869: EMPTY
43870: LIST
43871: LIST
43872: PUSH
43873: LD_INT 3
43875: PUSH
43876: LD_INT 1
43878: PUSH
43879: EMPTY
43880: LIST
43881: LIST
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: LIST
43887: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43888: LD_ADDR_VAR 0 55
43892: PUSH
43893: LD_INT 3
43895: PUSH
43896: LD_INT 2
43898: PUSH
43899: EMPTY
43900: LIST
43901: LIST
43902: PUSH
43903: LD_INT 3
43905: PUSH
43906: LD_INT 3
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: LD_INT 2
43915: PUSH
43916: LD_INT 3
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: LIST
43927: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43928: LD_ADDR_VAR 0 56
43932: PUSH
43933: LD_INT 1
43935: PUSH
43936: LD_INT 3
43938: PUSH
43939: EMPTY
43940: LIST
43941: LIST
43942: PUSH
43943: LD_INT 0
43945: PUSH
43946: LD_INT 3
43948: PUSH
43949: EMPTY
43950: LIST
43951: LIST
43952: PUSH
43953: LD_INT 1
43955: NEG
43956: PUSH
43957: LD_INT 2
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: PUSH
43964: EMPTY
43965: LIST
43966: LIST
43967: LIST
43968: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43969: LD_ADDR_VAR 0 57
43973: PUSH
43974: LD_INT 2
43976: NEG
43977: PUSH
43978: LD_INT 1
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 3
43987: NEG
43988: PUSH
43989: LD_INT 0
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: LD_INT 3
43998: NEG
43999: PUSH
44000: LD_INT 1
44002: NEG
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: LIST
44012: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44013: LD_ADDR_VAR 0 58
44017: PUSH
44018: LD_INT 2
44020: NEG
44021: PUSH
44022: LD_INT 3
44024: NEG
44025: PUSH
44026: EMPTY
44027: LIST
44028: LIST
44029: PUSH
44030: LD_INT 3
44032: NEG
44033: PUSH
44034: LD_INT 2
44036: NEG
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: PUSH
44042: LD_INT 3
44044: NEG
44045: PUSH
44046: LD_INT 3
44048: NEG
44049: PUSH
44050: EMPTY
44051: LIST
44052: LIST
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: LIST
44058: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
44059: LD_ADDR_VAR 0 59
44063: PUSH
44064: LD_INT 1
44066: NEG
44067: PUSH
44068: LD_INT 2
44070: NEG
44071: PUSH
44072: EMPTY
44073: LIST
44074: LIST
44075: PUSH
44076: LD_INT 0
44078: PUSH
44079: LD_INT 2
44081: NEG
44082: PUSH
44083: EMPTY
44084: LIST
44085: LIST
44086: PUSH
44087: LD_INT 1
44089: PUSH
44090: LD_INT 1
44092: NEG
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: LIST
44102: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
44103: LD_ADDR_VAR 0 60
44107: PUSH
44108: LD_INT 1
44110: PUSH
44111: LD_INT 1
44113: NEG
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PUSH
44119: LD_INT 2
44121: PUSH
44122: LD_INT 0
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: PUSH
44129: LD_INT 2
44131: PUSH
44132: LD_INT 1
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: LIST
44143: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44144: LD_ADDR_VAR 0 61
44148: PUSH
44149: LD_INT 2
44151: PUSH
44152: LD_INT 1
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 2
44161: PUSH
44162: LD_INT 2
44164: PUSH
44165: EMPTY
44166: LIST
44167: LIST
44168: PUSH
44169: LD_INT 1
44171: PUSH
44172: LD_INT 2
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PUSH
44179: EMPTY
44180: LIST
44181: LIST
44182: LIST
44183: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
44184: LD_ADDR_VAR 0 62
44188: PUSH
44189: LD_INT 1
44191: PUSH
44192: LD_INT 2
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 0
44201: PUSH
44202: LD_INT 2
44204: PUSH
44205: EMPTY
44206: LIST
44207: LIST
44208: PUSH
44209: LD_INT 1
44211: NEG
44212: PUSH
44213: LD_INT 1
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: LIST
44224: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
44225: LD_ADDR_VAR 0 63
44229: PUSH
44230: LD_INT 1
44232: NEG
44233: PUSH
44234: LD_INT 1
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: PUSH
44241: LD_INT 2
44243: NEG
44244: PUSH
44245: LD_INT 0
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: LD_INT 2
44254: NEG
44255: PUSH
44256: LD_INT 1
44258: NEG
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: LIST
44268: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44269: LD_ADDR_VAR 0 64
44273: PUSH
44274: LD_INT 1
44276: NEG
44277: PUSH
44278: LD_INT 2
44280: NEG
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 2
44288: NEG
44289: PUSH
44290: LD_INT 1
44292: NEG
44293: PUSH
44294: EMPTY
44295: LIST
44296: LIST
44297: PUSH
44298: LD_INT 2
44300: NEG
44301: PUSH
44302: LD_INT 2
44304: NEG
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: PUSH
44310: EMPTY
44311: LIST
44312: LIST
44313: LIST
44314: ST_TO_ADDR
// end ; 2 :
44315: GO 47581
44317: LD_INT 2
44319: DOUBLE
44320: EQUAL
44321: IFTRUE 44325
44323: GO 47580
44325: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
44326: LD_ADDR_VAR 0 29
44330: PUSH
44331: LD_INT 4
44333: PUSH
44334: LD_INT 0
44336: PUSH
44337: EMPTY
44338: LIST
44339: LIST
44340: PUSH
44341: LD_INT 4
44343: PUSH
44344: LD_INT 1
44346: NEG
44347: PUSH
44348: EMPTY
44349: LIST
44350: LIST
44351: PUSH
44352: LD_INT 5
44354: PUSH
44355: LD_INT 0
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 5
44364: PUSH
44365: LD_INT 1
44367: PUSH
44368: EMPTY
44369: LIST
44370: LIST
44371: PUSH
44372: LD_INT 4
44374: PUSH
44375: LD_INT 1
44377: PUSH
44378: EMPTY
44379: LIST
44380: LIST
44381: PUSH
44382: LD_INT 3
44384: PUSH
44385: LD_INT 0
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 3
44394: PUSH
44395: LD_INT 1
44397: NEG
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: PUSH
44403: LD_INT 3
44405: PUSH
44406: LD_INT 2
44408: NEG
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PUSH
44414: LD_INT 5
44416: PUSH
44417: LD_INT 2
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 3
44426: PUSH
44427: LD_INT 3
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 3
44436: PUSH
44437: LD_INT 2
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 4
44446: PUSH
44447: LD_INT 3
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PUSH
44454: LD_INT 4
44456: PUSH
44457: LD_INT 4
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: PUSH
44464: LD_INT 3
44466: PUSH
44467: LD_INT 4
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 2
44476: PUSH
44477: LD_INT 3
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: PUSH
44484: LD_INT 2
44486: PUSH
44487: LD_INT 2
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: PUSH
44494: LD_INT 4
44496: PUSH
44497: LD_INT 2
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: LD_INT 2
44506: PUSH
44507: LD_INT 4
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: PUSH
44514: LD_INT 0
44516: PUSH
44517: LD_INT 4
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 0
44526: PUSH
44527: LD_INT 3
44529: PUSH
44530: EMPTY
44531: LIST
44532: LIST
44533: PUSH
44534: LD_INT 1
44536: PUSH
44537: LD_INT 4
44539: PUSH
44540: EMPTY
44541: LIST
44542: LIST
44543: PUSH
44544: LD_INT 1
44546: PUSH
44547: LD_INT 5
44549: PUSH
44550: EMPTY
44551: LIST
44552: LIST
44553: PUSH
44554: LD_INT 0
44556: PUSH
44557: LD_INT 5
44559: PUSH
44560: EMPTY
44561: LIST
44562: LIST
44563: PUSH
44564: LD_INT 1
44566: NEG
44567: PUSH
44568: LD_INT 4
44570: PUSH
44571: EMPTY
44572: LIST
44573: LIST
44574: PUSH
44575: LD_INT 1
44577: NEG
44578: PUSH
44579: LD_INT 3
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: PUSH
44586: LD_INT 2
44588: PUSH
44589: LD_INT 5
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 2
44598: NEG
44599: PUSH
44600: LD_INT 3
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: PUSH
44607: LD_INT 3
44609: NEG
44610: PUSH
44611: LD_INT 0
44613: PUSH
44614: EMPTY
44615: LIST
44616: LIST
44617: PUSH
44618: LD_INT 3
44620: NEG
44621: PUSH
44622: LD_INT 1
44624: NEG
44625: PUSH
44626: EMPTY
44627: LIST
44628: LIST
44629: PUSH
44630: LD_INT 2
44632: NEG
44633: PUSH
44634: LD_INT 0
44636: PUSH
44637: EMPTY
44638: LIST
44639: LIST
44640: PUSH
44641: LD_INT 2
44643: NEG
44644: PUSH
44645: LD_INT 1
44647: PUSH
44648: EMPTY
44649: LIST
44650: LIST
44651: PUSH
44652: LD_INT 3
44654: NEG
44655: PUSH
44656: LD_INT 1
44658: PUSH
44659: EMPTY
44660: LIST
44661: LIST
44662: PUSH
44663: LD_INT 4
44665: NEG
44666: PUSH
44667: LD_INT 0
44669: PUSH
44670: EMPTY
44671: LIST
44672: LIST
44673: PUSH
44674: LD_INT 4
44676: NEG
44677: PUSH
44678: LD_INT 1
44680: NEG
44681: PUSH
44682: EMPTY
44683: LIST
44684: LIST
44685: PUSH
44686: LD_INT 4
44688: NEG
44689: PUSH
44690: LD_INT 2
44692: NEG
44693: PUSH
44694: EMPTY
44695: LIST
44696: LIST
44697: PUSH
44698: LD_INT 2
44700: NEG
44701: PUSH
44702: LD_INT 2
44704: PUSH
44705: EMPTY
44706: LIST
44707: LIST
44708: PUSH
44709: LD_INT 4
44711: NEG
44712: PUSH
44713: LD_INT 4
44715: NEG
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: PUSH
44721: LD_INT 4
44723: NEG
44724: PUSH
44725: LD_INT 5
44727: NEG
44728: PUSH
44729: EMPTY
44730: LIST
44731: LIST
44732: PUSH
44733: LD_INT 3
44735: NEG
44736: PUSH
44737: LD_INT 4
44739: NEG
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 3
44747: NEG
44748: PUSH
44749: LD_INT 3
44751: NEG
44752: PUSH
44753: EMPTY
44754: LIST
44755: LIST
44756: PUSH
44757: LD_INT 4
44759: NEG
44760: PUSH
44761: LD_INT 3
44763: NEG
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: PUSH
44769: LD_INT 5
44771: NEG
44772: PUSH
44773: LD_INT 4
44775: NEG
44776: PUSH
44777: EMPTY
44778: LIST
44779: LIST
44780: PUSH
44781: LD_INT 5
44783: NEG
44784: PUSH
44785: LD_INT 5
44787: NEG
44788: PUSH
44789: EMPTY
44790: LIST
44791: LIST
44792: PUSH
44793: LD_INT 3
44795: NEG
44796: PUSH
44797: LD_INT 5
44799: NEG
44800: PUSH
44801: EMPTY
44802: LIST
44803: LIST
44804: PUSH
44805: LD_INT 5
44807: NEG
44808: PUSH
44809: LD_INT 3
44811: NEG
44812: PUSH
44813: EMPTY
44814: LIST
44815: LIST
44816: PUSH
44817: EMPTY
44818: LIST
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: LIST
44824: LIST
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: LIST
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: LIST
44842: LIST
44843: LIST
44844: LIST
44845: LIST
44846: LIST
44847: LIST
44848: LIST
44849: LIST
44850: LIST
44851: LIST
44852: LIST
44853: LIST
44854: LIST
44855: LIST
44856: LIST
44857: LIST
44858: LIST
44859: LIST
44860: LIST
44861: LIST
44862: LIST
44863: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44864: LD_ADDR_VAR 0 30
44868: PUSH
44869: LD_INT 4
44871: PUSH
44872: LD_INT 4
44874: PUSH
44875: EMPTY
44876: LIST
44877: LIST
44878: PUSH
44879: LD_INT 4
44881: PUSH
44882: LD_INT 3
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PUSH
44889: LD_INT 5
44891: PUSH
44892: LD_INT 4
44894: PUSH
44895: EMPTY
44896: LIST
44897: LIST
44898: PUSH
44899: LD_INT 5
44901: PUSH
44902: LD_INT 5
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PUSH
44909: LD_INT 4
44911: PUSH
44912: LD_INT 5
44914: PUSH
44915: EMPTY
44916: LIST
44917: LIST
44918: PUSH
44919: LD_INT 3
44921: PUSH
44922: LD_INT 4
44924: PUSH
44925: EMPTY
44926: LIST
44927: LIST
44928: PUSH
44929: LD_INT 3
44931: PUSH
44932: LD_INT 3
44934: PUSH
44935: EMPTY
44936: LIST
44937: LIST
44938: PUSH
44939: LD_INT 5
44941: PUSH
44942: LD_INT 3
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: PUSH
44949: LD_INT 3
44951: PUSH
44952: LD_INT 5
44954: PUSH
44955: EMPTY
44956: LIST
44957: LIST
44958: PUSH
44959: LD_INT 0
44961: PUSH
44962: LD_INT 3
44964: PUSH
44965: EMPTY
44966: LIST
44967: LIST
44968: PUSH
44969: LD_INT 0
44971: PUSH
44972: LD_INT 2
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: PUSH
44979: LD_INT 1
44981: PUSH
44982: LD_INT 3
44984: PUSH
44985: EMPTY
44986: LIST
44987: LIST
44988: PUSH
44989: LD_INT 1
44991: PUSH
44992: LD_INT 4
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 0
45001: PUSH
45002: LD_INT 4
45004: PUSH
45005: EMPTY
45006: LIST
45007: LIST
45008: PUSH
45009: LD_INT 1
45011: NEG
45012: PUSH
45013: LD_INT 3
45015: PUSH
45016: EMPTY
45017: LIST
45018: LIST
45019: PUSH
45020: LD_INT 1
45022: NEG
45023: PUSH
45024: LD_INT 2
45026: PUSH
45027: EMPTY
45028: LIST
45029: LIST
45030: PUSH
45031: LD_INT 2
45033: PUSH
45034: LD_INT 4
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: PUSH
45041: LD_INT 2
45043: NEG
45044: PUSH
45045: LD_INT 2
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 4
45054: NEG
45055: PUSH
45056: LD_INT 0
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: PUSH
45063: LD_INT 4
45065: NEG
45066: PUSH
45067: LD_INT 1
45069: NEG
45070: PUSH
45071: EMPTY
45072: LIST
45073: LIST
45074: PUSH
45075: LD_INT 3
45077: NEG
45078: PUSH
45079: LD_INT 0
45081: PUSH
45082: EMPTY
45083: LIST
45084: LIST
45085: PUSH
45086: LD_INT 3
45088: NEG
45089: PUSH
45090: LD_INT 1
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 4
45099: NEG
45100: PUSH
45101: LD_INT 1
45103: PUSH
45104: EMPTY
45105: LIST
45106: LIST
45107: PUSH
45108: LD_INT 5
45110: NEG
45111: PUSH
45112: LD_INT 0
45114: PUSH
45115: EMPTY
45116: LIST
45117: LIST
45118: PUSH
45119: LD_INT 5
45121: NEG
45122: PUSH
45123: LD_INT 1
45125: NEG
45126: PUSH
45127: EMPTY
45128: LIST
45129: LIST
45130: PUSH
45131: LD_INT 5
45133: NEG
45134: PUSH
45135: LD_INT 2
45137: NEG
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 3
45145: NEG
45146: PUSH
45147: LD_INT 2
45149: PUSH
45150: EMPTY
45151: LIST
45152: LIST
45153: PUSH
45154: LD_INT 3
45156: NEG
45157: PUSH
45158: LD_INT 3
45160: NEG
45161: PUSH
45162: EMPTY
45163: LIST
45164: LIST
45165: PUSH
45166: LD_INT 3
45168: NEG
45169: PUSH
45170: LD_INT 4
45172: NEG
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: LD_INT 2
45180: NEG
45181: PUSH
45182: LD_INT 3
45184: NEG
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: PUSH
45190: LD_INT 2
45192: NEG
45193: PUSH
45194: LD_INT 2
45196: NEG
45197: PUSH
45198: EMPTY
45199: LIST
45200: LIST
45201: PUSH
45202: LD_INT 3
45204: NEG
45205: PUSH
45206: LD_INT 2
45208: NEG
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PUSH
45214: LD_INT 4
45216: NEG
45217: PUSH
45218: LD_INT 3
45220: NEG
45221: PUSH
45222: EMPTY
45223: LIST
45224: LIST
45225: PUSH
45226: LD_INT 4
45228: NEG
45229: PUSH
45230: LD_INT 4
45232: NEG
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: PUSH
45238: LD_INT 2
45240: NEG
45241: PUSH
45242: LD_INT 4
45244: NEG
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: PUSH
45250: LD_INT 4
45252: NEG
45253: PUSH
45254: LD_INT 2
45256: NEG
45257: PUSH
45258: EMPTY
45259: LIST
45260: LIST
45261: PUSH
45262: LD_INT 0
45264: PUSH
45265: LD_INT 4
45267: NEG
45268: PUSH
45269: EMPTY
45270: LIST
45271: LIST
45272: PUSH
45273: LD_INT 0
45275: PUSH
45276: LD_INT 5
45278: NEG
45279: PUSH
45280: EMPTY
45281: LIST
45282: LIST
45283: PUSH
45284: LD_INT 1
45286: PUSH
45287: LD_INT 4
45289: NEG
45290: PUSH
45291: EMPTY
45292: LIST
45293: LIST
45294: PUSH
45295: LD_INT 1
45297: PUSH
45298: LD_INT 3
45300: NEG
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: PUSH
45306: LD_INT 0
45308: PUSH
45309: LD_INT 3
45311: NEG
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 1
45319: NEG
45320: PUSH
45321: LD_INT 4
45323: NEG
45324: PUSH
45325: EMPTY
45326: LIST
45327: LIST
45328: PUSH
45329: LD_INT 1
45331: NEG
45332: PUSH
45333: LD_INT 5
45335: NEG
45336: PUSH
45337: EMPTY
45338: LIST
45339: LIST
45340: PUSH
45341: LD_INT 2
45343: PUSH
45344: LD_INT 3
45346: NEG
45347: PUSH
45348: EMPTY
45349: LIST
45350: LIST
45351: PUSH
45352: LD_INT 2
45354: NEG
45355: PUSH
45356: LD_INT 5
45358: NEG
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: PUSH
45364: EMPTY
45365: LIST
45366: LIST
45367: LIST
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: LIST
45378: LIST
45379: LIST
45380: LIST
45381: LIST
45382: LIST
45383: LIST
45384: LIST
45385: LIST
45386: LIST
45387: LIST
45388: LIST
45389: LIST
45390: LIST
45391: LIST
45392: LIST
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: LIST
45398: LIST
45399: LIST
45400: LIST
45401: LIST
45402: LIST
45403: LIST
45404: LIST
45405: LIST
45406: LIST
45407: LIST
45408: LIST
45409: LIST
45410: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
45411: LD_ADDR_VAR 0 31
45415: PUSH
45416: LD_INT 0
45418: PUSH
45419: LD_INT 4
45421: PUSH
45422: EMPTY
45423: LIST
45424: LIST
45425: PUSH
45426: LD_INT 0
45428: PUSH
45429: LD_INT 3
45431: PUSH
45432: EMPTY
45433: LIST
45434: LIST
45435: PUSH
45436: LD_INT 1
45438: PUSH
45439: LD_INT 4
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: PUSH
45446: LD_INT 1
45448: PUSH
45449: LD_INT 5
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: LD_INT 0
45458: PUSH
45459: LD_INT 5
45461: PUSH
45462: EMPTY
45463: LIST
45464: LIST
45465: PUSH
45466: LD_INT 1
45468: NEG
45469: PUSH
45470: LD_INT 4
45472: PUSH
45473: EMPTY
45474: LIST
45475: LIST
45476: PUSH
45477: LD_INT 1
45479: NEG
45480: PUSH
45481: LD_INT 3
45483: PUSH
45484: EMPTY
45485: LIST
45486: LIST
45487: PUSH
45488: LD_INT 2
45490: PUSH
45491: LD_INT 5
45493: PUSH
45494: EMPTY
45495: LIST
45496: LIST
45497: PUSH
45498: LD_INT 2
45500: NEG
45501: PUSH
45502: LD_INT 3
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 3
45511: NEG
45512: PUSH
45513: LD_INT 0
45515: PUSH
45516: EMPTY
45517: LIST
45518: LIST
45519: PUSH
45520: LD_INT 3
45522: NEG
45523: PUSH
45524: LD_INT 1
45526: NEG
45527: PUSH
45528: EMPTY
45529: LIST
45530: LIST
45531: PUSH
45532: LD_INT 2
45534: NEG
45535: PUSH
45536: LD_INT 0
45538: PUSH
45539: EMPTY
45540: LIST
45541: LIST
45542: PUSH
45543: LD_INT 2
45545: NEG
45546: PUSH
45547: LD_INT 1
45549: PUSH
45550: EMPTY
45551: LIST
45552: LIST
45553: PUSH
45554: LD_INT 3
45556: NEG
45557: PUSH
45558: LD_INT 1
45560: PUSH
45561: EMPTY
45562: LIST
45563: LIST
45564: PUSH
45565: LD_INT 4
45567: NEG
45568: PUSH
45569: LD_INT 0
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 4
45578: NEG
45579: PUSH
45580: LD_INT 1
45582: NEG
45583: PUSH
45584: EMPTY
45585: LIST
45586: LIST
45587: PUSH
45588: LD_INT 4
45590: NEG
45591: PUSH
45592: LD_INT 2
45594: NEG
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: PUSH
45600: LD_INT 2
45602: NEG
45603: PUSH
45604: LD_INT 2
45606: PUSH
45607: EMPTY
45608: LIST
45609: LIST
45610: PUSH
45611: LD_INT 4
45613: NEG
45614: PUSH
45615: LD_INT 4
45617: NEG
45618: PUSH
45619: EMPTY
45620: LIST
45621: LIST
45622: PUSH
45623: LD_INT 4
45625: NEG
45626: PUSH
45627: LD_INT 5
45629: NEG
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: PUSH
45635: LD_INT 3
45637: NEG
45638: PUSH
45639: LD_INT 4
45641: NEG
45642: PUSH
45643: EMPTY
45644: LIST
45645: LIST
45646: PUSH
45647: LD_INT 3
45649: NEG
45650: PUSH
45651: LD_INT 3
45653: NEG
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 4
45661: NEG
45662: PUSH
45663: LD_INT 3
45665: NEG
45666: PUSH
45667: EMPTY
45668: LIST
45669: LIST
45670: PUSH
45671: LD_INT 5
45673: NEG
45674: PUSH
45675: LD_INT 4
45677: NEG
45678: PUSH
45679: EMPTY
45680: LIST
45681: LIST
45682: PUSH
45683: LD_INT 5
45685: NEG
45686: PUSH
45687: LD_INT 5
45689: NEG
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: PUSH
45695: LD_INT 3
45697: NEG
45698: PUSH
45699: LD_INT 5
45701: NEG
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: PUSH
45707: LD_INT 5
45709: NEG
45710: PUSH
45711: LD_INT 3
45713: NEG
45714: PUSH
45715: EMPTY
45716: LIST
45717: LIST
45718: PUSH
45719: LD_INT 0
45721: PUSH
45722: LD_INT 3
45724: NEG
45725: PUSH
45726: EMPTY
45727: LIST
45728: LIST
45729: PUSH
45730: LD_INT 0
45732: PUSH
45733: LD_INT 4
45735: NEG
45736: PUSH
45737: EMPTY
45738: LIST
45739: LIST
45740: PUSH
45741: LD_INT 1
45743: PUSH
45744: LD_INT 3
45746: NEG
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 1
45754: PUSH
45755: LD_INT 2
45757: NEG
45758: PUSH
45759: EMPTY
45760: LIST
45761: LIST
45762: PUSH
45763: LD_INT 0
45765: PUSH
45766: LD_INT 2
45768: NEG
45769: PUSH
45770: EMPTY
45771: LIST
45772: LIST
45773: PUSH
45774: LD_INT 1
45776: NEG
45777: PUSH
45778: LD_INT 3
45780: NEG
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 1
45788: NEG
45789: PUSH
45790: LD_INT 4
45792: NEG
45793: PUSH
45794: EMPTY
45795: LIST
45796: LIST
45797: PUSH
45798: LD_INT 2
45800: PUSH
45801: LD_INT 2
45803: NEG
45804: PUSH
45805: EMPTY
45806: LIST
45807: LIST
45808: PUSH
45809: LD_INT 2
45811: NEG
45812: PUSH
45813: LD_INT 4
45815: NEG
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 4
45823: PUSH
45824: LD_INT 0
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 4
45833: PUSH
45834: LD_INT 1
45836: NEG
45837: PUSH
45838: EMPTY
45839: LIST
45840: LIST
45841: PUSH
45842: LD_INT 5
45844: PUSH
45845: LD_INT 0
45847: PUSH
45848: EMPTY
45849: LIST
45850: LIST
45851: PUSH
45852: LD_INT 5
45854: PUSH
45855: LD_INT 1
45857: PUSH
45858: EMPTY
45859: LIST
45860: LIST
45861: PUSH
45862: LD_INT 4
45864: PUSH
45865: LD_INT 1
45867: PUSH
45868: EMPTY
45869: LIST
45870: LIST
45871: PUSH
45872: LD_INT 3
45874: PUSH
45875: LD_INT 0
45877: PUSH
45878: EMPTY
45879: LIST
45880: LIST
45881: PUSH
45882: LD_INT 3
45884: PUSH
45885: LD_INT 1
45887: NEG
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: PUSH
45893: LD_INT 3
45895: PUSH
45896: LD_INT 2
45898: NEG
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PUSH
45904: LD_INT 5
45906: PUSH
45907: LD_INT 2
45909: PUSH
45910: EMPTY
45911: LIST
45912: LIST
45913: PUSH
45914: EMPTY
45915: LIST
45916: LIST
45917: LIST
45918: LIST
45919: LIST
45920: LIST
45921: LIST
45922: LIST
45923: LIST
45924: LIST
45925: LIST
45926: LIST
45927: LIST
45928: LIST
45929: LIST
45930: LIST
45931: LIST
45932: LIST
45933: LIST
45934: LIST
45935: LIST
45936: LIST
45937: LIST
45938: LIST
45939: LIST
45940: LIST
45941: LIST
45942: LIST
45943: LIST
45944: LIST
45945: LIST
45946: LIST
45947: LIST
45948: LIST
45949: LIST
45950: LIST
45951: LIST
45952: LIST
45953: LIST
45954: LIST
45955: LIST
45956: LIST
45957: LIST
45958: LIST
45959: LIST
45960: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45961: LD_ADDR_VAR 0 32
45965: PUSH
45966: LD_INT 4
45968: NEG
45969: PUSH
45970: LD_INT 0
45972: PUSH
45973: EMPTY
45974: LIST
45975: LIST
45976: PUSH
45977: LD_INT 4
45979: NEG
45980: PUSH
45981: LD_INT 1
45983: NEG
45984: PUSH
45985: EMPTY
45986: LIST
45987: LIST
45988: PUSH
45989: LD_INT 3
45991: NEG
45992: PUSH
45993: LD_INT 0
45995: PUSH
45996: EMPTY
45997: LIST
45998: LIST
45999: PUSH
46000: LD_INT 3
46002: NEG
46003: PUSH
46004: LD_INT 1
46006: PUSH
46007: EMPTY
46008: LIST
46009: LIST
46010: PUSH
46011: LD_INT 4
46013: NEG
46014: PUSH
46015: LD_INT 1
46017: PUSH
46018: EMPTY
46019: LIST
46020: LIST
46021: PUSH
46022: LD_INT 5
46024: NEG
46025: PUSH
46026: LD_INT 0
46028: PUSH
46029: EMPTY
46030: LIST
46031: LIST
46032: PUSH
46033: LD_INT 5
46035: NEG
46036: PUSH
46037: LD_INT 1
46039: NEG
46040: PUSH
46041: EMPTY
46042: LIST
46043: LIST
46044: PUSH
46045: LD_INT 5
46047: NEG
46048: PUSH
46049: LD_INT 2
46051: NEG
46052: PUSH
46053: EMPTY
46054: LIST
46055: LIST
46056: PUSH
46057: LD_INT 3
46059: NEG
46060: PUSH
46061: LD_INT 2
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: PUSH
46068: LD_INT 3
46070: NEG
46071: PUSH
46072: LD_INT 3
46074: NEG
46075: PUSH
46076: EMPTY
46077: LIST
46078: LIST
46079: PUSH
46080: LD_INT 3
46082: NEG
46083: PUSH
46084: LD_INT 4
46086: NEG
46087: PUSH
46088: EMPTY
46089: LIST
46090: LIST
46091: PUSH
46092: LD_INT 2
46094: NEG
46095: PUSH
46096: LD_INT 3
46098: NEG
46099: PUSH
46100: EMPTY
46101: LIST
46102: LIST
46103: PUSH
46104: LD_INT 2
46106: NEG
46107: PUSH
46108: LD_INT 2
46110: NEG
46111: PUSH
46112: EMPTY
46113: LIST
46114: LIST
46115: PUSH
46116: LD_INT 3
46118: NEG
46119: PUSH
46120: LD_INT 2
46122: NEG
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 4
46130: NEG
46131: PUSH
46132: LD_INT 3
46134: NEG
46135: PUSH
46136: EMPTY
46137: LIST
46138: LIST
46139: PUSH
46140: LD_INT 4
46142: NEG
46143: PUSH
46144: LD_INT 4
46146: NEG
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: PUSH
46152: LD_INT 2
46154: NEG
46155: PUSH
46156: LD_INT 4
46158: NEG
46159: PUSH
46160: EMPTY
46161: LIST
46162: LIST
46163: PUSH
46164: LD_INT 4
46166: NEG
46167: PUSH
46168: LD_INT 2
46170: NEG
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: PUSH
46176: LD_INT 0
46178: PUSH
46179: LD_INT 4
46181: NEG
46182: PUSH
46183: EMPTY
46184: LIST
46185: LIST
46186: PUSH
46187: LD_INT 0
46189: PUSH
46190: LD_INT 5
46192: NEG
46193: PUSH
46194: EMPTY
46195: LIST
46196: LIST
46197: PUSH
46198: LD_INT 1
46200: PUSH
46201: LD_INT 4
46203: NEG
46204: PUSH
46205: EMPTY
46206: LIST
46207: LIST
46208: PUSH
46209: LD_INT 1
46211: PUSH
46212: LD_INT 3
46214: NEG
46215: PUSH
46216: EMPTY
46217: LIST
46218: LIST
46219: PUSH
46220: LD_INT 0
46222: PUSH
46223: LD_INT 3
46225: NEG
46226: PUSH
46227: EMPTY
46228: LIST
46229: LIST
46230: PUSH
46231: LD_INT 1
46233: NEG
46234: PUSH
46235: LD_INT 4
46237: NEG
46238: PUSH
46239: EMPTY
46240: LIST
46241: LIST
46242: PUSH
46243: LD_INT 1
46245: NEG
46246: PUSH
46247: LD_INT 5
46249: NEG
46250: PUSH
46251: EMPTY
46252: LIST
46253: LIST
46254: PUSH
46255: LD_INT 2
46257: PUSH
46258: LD_INT 3
46260: NEG
46261: PUSH
46262: EMPTY
46263: LIST
46264: LIST
46265: PUSH
46266: LD_INT 2
46268: NEG
46269: PUSH
46270: LD_INT 5
46272: NEG
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: PUSH
46278: LD_INT 3
46280: PUSH
46281: LD_INT 0
46283: PUSH
46284: EMPTY
46285: LIST
46286: LIST
46287: PUSH
46288: LD_INT 3
46290: PUSH
46291: LD_INT 1
46293: NEG
46294: PUSH
46295: EMPTY
46296: LIST
46297: LIST
46298: PUSH
46299: LD_INT 4
46301: PUSH
46302: LD_INT 0
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: PUSH
46309: LD_INT 4
46311: PUSH
46312: LD_INT 1
46314: PUSH
46315: EMPTY
46316: LIST
46317: LIST
46318: PUSH
46319: LD_INT 3
46321: PUSH
46322: LD_INT 1
46324: PUSH
46325: EMPTY
46326: LIST
46327: LIST
46328: PUSH
46329: LD_INT 2
46331: PUSH
46332: LD_INT 0
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: PUSH
46339: LD_INT 2
46341: PUSH
46342: LD_INT 1
46344: NEG
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PUSH
46350: LD_INT 2
46352: PUSH
46353: LD_INT 2
46355: NEG
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 4
46363: PUSH
46364: LD_INT 2
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: LD_INT 4
46373: PUSH
46374: LD_INT 4
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 4
46383: PUSH
46384: LD_INT 3
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 5
46393: PUSH
46394: LD_INT 4
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 5
46403: PUSH
46404: LD_INT 5
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: PUSH
46411: LD_INT 4
46413: PUSH
46414: LD_INT 5
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PUSH
46421: LD_INT 3
46423: PUSH
46424: LD_INT 4
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 3
46433: PUSH
46434: LD_INT 3
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 5
46443: PUSH
46444: LD_INT 3
46446: PUSH
46447: EMPTY
46448: LIST
46449: LIST
46450: PUSH
46451: LD_INT 3
46453: PUSH
46454: LD_INT 5
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PUSH
46461: EMPTY
46462: LIST
46463: LIST
46464: LIST
46465: LIST
46466: LIST
46467: LIST
46468: LIST
46469: LIST
46470: LIST
46471: LIST
46472: LIST
46473: LIST
46474: LIST
46475: LIST
46476: LIST
46477: LIST
46478: LIST
46479: LIST
46480: LIST
46481: LIST
46482: LIST
46483: LIST
46484: LIST
46485: LIST
46486: LIST
46487: LIST
46488: LIST
46489: LIST
46490: LIST
46491: LIST
46492: LIST
46493: LIST
46494: LIST
46495: LIST
46496: LIST
46497: LIST
46498: LIST
46499: LIST
46500: LIST
46501: LIST
46502: LIST
46503: LIST
46504: LIST
46505: LIST
46506: LIST
46507: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46508: LD_ADDR_VAR 0 33
46512: PUSH
46513: LD_INT 4
46515: NEG
46516: PUSH
46517: LD_INT 4
46519: NEG
46520: PUSH
46521: EMPTY
46522: LIST
46523: LIST
46524: PUSH
46525: LD_INT 4
46527: NEG
46528: PUSH
46529: LD_INT 5
46531: NEG
46532: PUSH
46533: EMPTY
46534: LIST
46535: LIST
46536: PUSH
46537: LD_INT 3
46539: NEG
46540: PUSH
46541: LD_INT 4
46543: NEG
46544: PUSH
46545: EMPTY
46546: LIST
46547: LIST
46548: PUSH
46549: LD_INT 3
46551: NEG
46552: PUSH
46553: LD_INT 3
46555: NEG
46556: PUSH
46557: EMPTY
46558: LIST
46559: LIST
46560: PUSH
46561: LD_INT 4
46563: NEG
46564: PUSH
46565: LD_INT 3
46567: NEG
46568: PUSH
46569: EMPTY
46570: LIST
46571: LIST
46572: PUSH
46573: LD_INT 5
46575: NEG
46576: PUSH
46577: LD_INT 4
46579: NEG
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: PUSH
46585: LD_INT 5
46587: NEG
46588: PUSH
46589: LD_INT 5
46591: NEG
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: PUSH
46597: LD_INT 3
46599: NEG
46600: PUSH
46601: LD_INT 5
46603: NEG
46604: PUSH
46605: EMPTY
46606: LIST
46607: LIST
46608: PUSH
46609: LD_INT 5
46611: NEG
46612: PUSH
46613: LD_INT 3
46615: NEG
46616: PUSH
46617: EMPTY
46618: LIST
46619: LIST
46620: PUSH
46621: LD_INT 0
46623: PUSH
46624: LD_INT 3
46626: NEG
46627: PUSH
46628: EMPTY
46629: LIST
46630: LIST
46631: PUSH
46632: LD_INT 0
46634: PUSH
46635: LD_INT 4
46637: NEG
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: PUSH
46643: LD_INT 1
46645: PUSH
46646: LD_INT 3
46648: NEG
46649: PUSH
46650: EMPTY
46651: LIST
46652: LIST
46653: PUSH
46654: LD_INT 1
46656: PUSH
46657: LD_INT 2
46659: NEG
46660: PUSH
46661: EMPTY
46662: LIST
46663: LIST
46664: PUSH
46665: LD_INT 0
46667: PUSH
46668: LD_INT 2
46670: NEG
46671: PUSH
46672: EMPTY
46673: LIST
46674: LIST
46675: PUSH
46676: LD_INT 1
46678: NEG
46679: PUSH
46680: LD_INT 3
46682: NEG
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: LD_INT 1
46690: NEG
46691: PUSH
46692: LD_INT 4
46694: NEG
46695: PUSH
46696: EMPTY
46697: LIST
46698: LIST
46699: PUSH
46700: LD_INT 2
46702: PUSH
46703: LD_INT 2
46705: NEG
46706: PUSH
46707: EMPTY
46708: LIST
46709: LIST
46710: PUSH
46711: LD_INT 2
46713: NEG
46714: PUSH
46715: LD_INT 4
46717: NEG
46718: PUSH
46719: EMPTY
46720: LIST
46721: LIST
46722: PUSH
46723: LD_INT 4
46725: PUSH
46726: LD_INT 0
46728: PUSH
46729: EMPTY
46730: LIST
46731: LIST
46732: PUSH
46733: LD_INT 4
46735: PUSH
46736: LD_INT 1
46738: NEG
46739: PUSH
46740: EMPTY
46741: LIST
46742: LIST
46743: PUSH
46744: LD_INT 5
46746: PUSH
46747: LD_INT 0
46749: PUSH
46750: EMPTY
46751: LIST
46752: LIST
46753: PUSH
46754: LD_INT 5
46756: PUSH
46757: LD_INT 1
46759: PUSH
46760: EMPTY
46761: LIST
46762: LIST
46763: PUSH
46764: LD_INT 4
46766: PUSH
46767: LD_INT 1
46769: PUSH
46770: EMPTY
46771: LIST
46772: LIST
46773: PUSH
46774: LD_INT 3
46776: PUSH
46777: LD_INT 0
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: PUSH
46784: LD_INT 3
46786: PUSH
46787: LD_INT 1
46789: NEG
46790: PUSH
46791: EMPTY
46792: LIST
46793: LIST
46794: PUSH
46795: LD_INT 3
46797: PUSH
46798: LD_INT 2
46800: NEG
46801: PUSH
46802: EMPTY
46803: LIST
46804: LIST
46805: PUSH
46806: LD_INT 5
46808: PUSH
46809: LD_INT 2
46811: PUSH
46812: EMPTY
46813: LIST
46814: LIST
46815: PUSH
46816: LD_INT 3
46818: PUSH
46819: LD_INT 3
46821: PUSH
46822: EMPTY
46823: LIST
46824: LIST
46825: PUSH
46826: LD_INT 3
46828: PUSH
46829: LD_INT 2
46831: PUSH
46832: EMPTY
46833: LIST
46834: LIST
46835: PUSH
46836: LD_INT 4
46838: PUSH
46839: LD_INT 3
46841: PUSH
46842: EMPTY
46843: LIST
46844: LIST
46845: PUSH
46846: LD_INT 4
46848: PUSH
46849: LD_INT 4
46851: PUSH
46852: EMPTY
46853: LIST
46854: LIST
46855: PUSH
46856: LD_INT 3
46858: PUSH
46859: LD_INT 4
46861: PUSH
46862: EMPTY
46863: LIST
46864: LIST
46865: PUSH
46866: LD_INT 2
46868: PUSH
46869: LD_INT 3
46871: PUSH
46872: EMPTY
46873: LIST
46874: LIST
46875: PUSH
46876: LD_INT 2
46878: PUSH
46879: LD_INT 2
46881: PUSH
46882: EMPTY
46883: LIST
46884: LIST
46885: PUSH
46886: LD_INT 4
46888: PUSH
46889: LD_INT 2
46891: PUSH
46892: EMPTY
46893: LIST
46894: LIST
46895: PUSH
46896: LD_INT 2
46898: PUSH
46899: LD_INT 4
46901: PUSH
46902: EMPTY
46903: LIST
46904: LIST
46905: PUSH
46906: LD_INT 0
46908: PUSH
46909: LD_INT 4
46911: PUSH
46912: EMPTY
46913: LIST
46914: LIST
46915: PUSH
46916: LD_INT 0
46918: PUSH
46919: LD_INT 3
46921: PUSH
46922: EMPTY
46923: LIST
46924: LIST
46925: PUSH
46926: LD_INT 1
46928: PUSH
46929: LD_INT 4
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: PUSH
46936: LD_INT 1
46938: PUSH
46939: LD_INT 5
46941: PUSH
46942: EMPTY
46943: LIST
46944: LIST
46945: PUSH
46946: LD_INT 0
46948: PUSH
46949: LD_INT 5
46951: PUSH
46952: EMPTY
46953: LIST
46954: LIST
46955: PUSH
46956: LD_INT 1
46958: NEG
46959: PUSH
46960: LD_INT 4
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: PUSH
46967: LD_INT 1
46969: NEG
46970: PUSH
46971: LD_INT 3
46973: PUSH
46974: EMPTY
46975: LIST
46976: LIST
46977: PUSH
46978: LD_INT 2
46980: PUSH
46981: LD_INT 5
46983: PUSH
46984: EMPTY
46985: LIST
46986: LIST
46987: PUSH
46988: LD_INT 2
46990: NEG
46991: PUSH
46992: LD_INT 3
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PUSH
46999: EMPTY
47000: LIST
47001: LIST
47002: LIST
47003: LIST
47004: LIST
47005: LIST
47006: LIST
47007: LIST
47008: LIST
47009: LIST
47010: LIST
47011: LIST
47012: LIST
47013: LIST
47014: LIST
47015: LIST
47016: LIST
47017: LIST
47018: LIST
47019: LIST
47020: LIST
47021: LIST
47022: LIST
47023: LIST
47024: LIST
47025: LIST
47026: LIST
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
47046: LD_ADDR_VAR 0 34
47050: PUSH
47051: LD_INT 0
47053: PUSH
47054: LD_INT 4
47056: NEG
47057: PUSH
47058: EMPTY
47059: LIST
47060: LIST
47061: PUSH
47062: LD_INT 0
47064: PUSH
47065: LD_INT 5
47067: NEG
47068: PUSH
47069: EMPTY
47070: LIST
47071: LIST
47072: PUSH
47073: LD_INT 1
47075: PUSH
47076: LD_INT 4
47078: NEG
47079: PUSH
47080: EMPTY
47081: LIST
47082: LIST
47083: PUSH
47084: LD_INT 1
47086: PUSH
47087: LD_INT 3
47089: NEG
47090: PUSH
47091: EMPTY
47092: LIST
47093: LIST
47094: PUSH
47095: LD_INT 0
47097: PUSH
47098: LD_INT 3
47100: NEG
47101: PUSH
47102: EMPTY
47103: LIST
47104: LIST
47105: PUSH
47106: LD_INT 1
47108: NEG
47109: PUSH
47110: LD_INT 4
47112: NEG
47113: PUSH
47114: EMPTY
47115: LIST
47116: LIST
47117: PUSH
47118: LD_INT 1
47120: NEG
47121: PUSH
47122: LD_INT 5
47124: NEG
47125: PUSH
47126: EMPTY
47127: LIST
47128: LIST
47129: PUSH
47130: LD_INT 2
47132: PUSH
47133: LD_INT 3
47135: NEG
47136: PUSH
47137: EMPTY
47138: LIST
47139: LIST
47140: PUSH
47141: LD_INT 2
47143: NEG
47144: PUSH
47145: LD_INT 5
47147: NEG
47148: PUSH
47149: EMPTY
47150: LIST
47151: LIST
47152: PUSH
47153: LD_INT 3
47155: PUSH
47156: LD_INT 0
47158: PUSH
47159: EMPTY
47160: LIST
47161: LIST
47162: PUSH
47163: LD_INT 3
47165: PUSH
47166: LD_INT 1
47168: NEG
47169: PUSH
47170: EMPTY
47171: LIST
47172: LIST
47173: PUSH
47174: LD_INT 4
47176: PUSH
47177: LD_INT 0
47179: PUSH
47180: EMPTY
47181: LIST
47182: LIST
47183: PUSH
47184: LD_INT 4
47186: PUSH
47187: LD_INT 1
47189: PUSH
47190: EMPTY
47191: LIST
47192: LIST
47193: PUSH
47194: LD_INT 3
47196: PUSH
47197: LD_INT 1
47199: PUSH
47200: EMPTY
47201: LIST
47202: LIST
47203: PUSH
47204: LD_INT 2
47206: PUSH
47207: LD_INT 0
47209: PUSH
47210: EMPTY
47211: LIST
47212: LIST
47213: PUSH
47214: LD_INT 2
47216: PUSH
47217: LD_INT 1
47219: NEG
47220: PUSH
47221: EMPTY
47222: LIST
47223: LIST
47224: PUSH
47225: LD_INT 2
47227: PUSH
47228: LD_INT 2
47230: NEG
47231: PUSH
47232: EMPTY
47233: LIST
47234: LIST
47235: PUSH
47236: LD_INT 4
47238: PUSH
47239: LD_INT 2
47241: PUSH
47242: EMPTY
47243: LIST
47244: LIST
47245: PUSH
47246: LD_INT 4
47248: PUSH
47249: LD_INT 4
47251: PUSH
47252: EMPTY
47253: LIST
47254: LIST
47255: PUSH
47256: LD_INT 4
47258: PUSH
47259: LD_INT 3
47261: PUSH
47262: EMPTY
47263: LIST
47264: LIST
47265: PUSH
47266: LD_INT 5
47268: PUSH
47269: LD_INT 4
47271: PUSH
47272: EMPTY
47273: LIST
47274: LIST
47275: PUSH
47276: LD_INT 5
47278: PUSH
47279: LD_INT 5
47281: PUSH
47282: EMPTY
47283: LIST
47284: LIST
47285: PUSH
47286: LD_INT 4
47288: PUSH
47289: LD_INT 5
47291: PUSH
47292: EMPTY
47293: LIST
47294: LIST
47295: PUSH
47296: LD_INT 3
47298: PUSH
47299: LD_INT 4
47301: PUSH
47302: EMPTY
47303: LIST
47304: LIST
47305: PUSH
47306: LD_INT 3
47308: PUSH
47309: LD_INT 3
47311: PUSH
47312: EMPTY
47313: LIST
47314: LIST
47315: PUSH
47316: LD_INT 5
47318: PUSH
47319: LD_INT 3
47321: PUSH
47322: EMPTY
47323: LIST
47324: LIST
47325: PUSH
47326: LD_INT 3
47328: PUSH
47329: LD_INT 5
47331: PUSH
47332: EMPTY
47333: LIST
47334: LIST
47335: PUSH
47336: LD_INT 0
47338: PUSH
47339: LD_INT 3
47341: PUSH
47342: EMPTY
47343: LIST
47344: LIST
47345: PUSH
47346: LD_INT 0
47348: PUSH
47349: LD_INT 2
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: PUSH
47356: LD_INT 1
47358: PUSH
47359: LD_INT 3
47361: PUSH
47362: EMPTY
47363: LIST
47364: LIST
47365: PUSH
47366: LD_INT 1
47368: PUSH
47369: LD_INT 4
47371: PUSH
47372: EMPTY
47373: LIST
47374: LIST
47375: PUSH
47376: LD_INT 0
47378: PUSH
47379: LD_INT 4
47381: PUSH
47382: EMPTY
47383: LIST
47384: LIST
47385: PUSH
47386: LD_INT 1
47388: NEG
47389: PUSH
47390: LD_INT 3
47392: PUSH
47393: EMPTY
47394: LIST
47395: LIST
47396: PUSH
47397: LD_INT 1
47399: NEG
47400: PUSH
47401: LD_INT 2
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: PUSH
47408: LD_INT 2
47410: PUSH
47411: LD_INT 4
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: PUSH
47418: LD_INT 2
47420: NEG
47421: PUSH
47422: LD_INT 2
47424: PUSH
47425: EMPTY
47426: LIST
47427: LIST
47428: PUSH
47429: LD_INT 4
47431: NEG
47432: PUSH
47433: LD_INT 0
47435: PUSH
47436: EMPTY
47437: LIST
47438: LIST
47439: PUSH
47440: LD_INT 4
47442: NEG
47443: PUSH
47444: LD_INT 1
47446: NEG
47447: PUSH
47448: EMPTY
47449: LIST
47450: LIST
47451: PUSH
47452: LD_INT 3
47454: NEG
47455: PUSH
47456: LD_INT 0
47458: PUSH
47459: EMPTY
47460: LIST
47461: LIST
47462: PUSH
47463: LD_INT 3
47465: NEG
47466: PUSH
47467: LD_INT 1
47469: PUSH
47470: EMPTY
47471: LIST
47472: LIST
47473: PUSH
47474: LD_INT 4
47476: NEG
47477: PUSH
47478: LD_INT 1
47480: PUSH
47481: EMPTY
47482: LIST
47483: LIST
47484: PUSH
47485: LD_INT 5
47487: NEG
47488: PUSH
47489: LD_INT 0
47491: PUSH
47492: EMPTY
47493: LIST
47494: LIST
47495: PUSH
47496: LD_INT 5
47498: NEG
47499: PUSH
47500: LD_INT 1
47502: NEG
47503: PUSH
47504: EMPTY
47505: LIST
47506: LIST
47507: PUSH
47508: LD_INT 5
47510: NEG
47511: PUSH
47512: LD_INT 2
47514: NEG
47515: PUSH
47516: EMPTY
47517: LIST
47518: LIST
47519: PUSH
47520: LD_INT 3
47522: NEG
47523: PUSH
47524: LD_INT 2
47526: PUSH
47527: EMPTY
47528: LIST
47529: LIST
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: LIST
47535: LIST
47536: LIST
47537: LIST
47538: LIST
47539: LIST
47540: LIST
47541: LIST
47542: LIST
47543: LIST
47544: LIST
47545: LIST
47546: LIST
47547: LIST
47548: LIST
47549: LIST
47550: LIST
47551: LIST
47552: LIST
47553: LIST
47554: LIST
47555: LIST
47556: LIST
47557: LIST
47558: LIST
47559: LIST
47560: LIST
47561: LIST
47562: LIST
47563: LIST
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: LIST
47569: LIST
47570: LIST
47571: LIST
47572: LIST
47573: LIST
47574: LIST
47575: LIST
47576: LIST
47577: ST_TO_ADDR
// end ; end ;
47578: GO 47581
47580: POP
// case btype of b_depot , b_warehouse :
47581: LD_VAR 0 1
47585: PUSH
47586: LD_INT 0
47588: DOUBLE
47589: EQUAL
47590: IFTRUE 47600
47592: LD_INT 1
47594: DOUBLE
47595: EQUAL
47596: IFTRUE 47600
47598: GO 47801
47600: POP
// case nation of nation_american :
47601: LD_VAR 0 5
47605: PUSH
47606: LD_INT 1
47608: DOUBLE
47609: EQUAL
47610: IFTRUE 47614
47612: GO 47670
47614: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
47615: LD_ADDR_VAR 0 9
47619: PUSH
47620: LD_VAR 0 11
47624: PUSH
47625: LD_VAR 0 12
47629: PUSH
47630: LD_VAR 0 13
47634: PUSH
47635: LD_VAR 0 14
47639: PUSH
47640: LD_VAR 0 15
47644: PUSH
47645: LD_VAR 0 16
47649: PUSH
47650: EMPTY
47651: LIST
47652: LIST
47653: LIST
47654: LIST
47655: LIST
47656: LIST
47657: PUSH
47658: LD_VAR 0 4
47662: PUSH
47663: LD_INT 1
47665: PLUS
47666: ARRAY
47667: ST_TO_ADDR
47668: GO 47799
47670: LD_INT 2
47672: DOUBLE
47673: EQUAL
47674: IFTRUE 47678
47676: GO 47734
47678: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
47679: LD_ADDR_VAR 0 9
47683: PUSH
47684: LD_VAR 0 17
47688: PUSH
47689: LD_VAR 0 18
47693: PUSH
47694: LD_VAR 0 19
47698: PUSH
47699: LD_VAR 0 20
47703: PUSH
47704: LD_VAR 0 21
47708: PUSH
47709: LD_VAR 0 22
47713: PUSH
47714: EMPTY
47715: LIST
47716: LIST
47717: LIST
47718: LIST
47719: LIST
47720: LIST
47721: PUSH
47722: LD_VAR 0 4
47726: PUSH
47727: LD_INT 1
47729: PLUS
47730: ARRAY
47731: ST_TO_ADDR
47732: GO 47799
47734: LD_INT 3
47736: DOUBLE
47737: EQUAL
47738: IFTRUE 47742
47740: GO 47798
47742: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47743: LD_ADDR_VAR 0 9
47747: PUSH
47748: LD_VAR 0 23
47752: PUSH
47753: LD_VAR 0 24
47757: PUSH
47758: LD_VAR 0 25
47762: PUSH
47763: LD_VAR 0 26
47767: PUSH
47768: LD_VAR 0 27
47772: PUSH
47773: LD_VAR 0 28
47777: PUSH
47778: EMPTY
47779: LIST
47780: LIST
47781: LIST
47782: LIST
47783: LIST
47784: LIST
47785: PUSH
47786: LD_VAR 0 4
47790: PUSH
47791: LD_INT 1
47793: PLUS
47794: ARRAY
47795: ST_TO_ADDR
47796: GO 47799
47798: POP
47799: GO 48354
47801: LD_INT 2
47803: DOUBLE
47804: EQUAL
47805: IFTRUE 47815
47807: LD_INT 3
47809: DOUBLE
47810: EQUAL
47811: IFTRUE 47815
47813: GO 47871
47815: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47816: LD_ADDR_VAR 0 9
47820: PUSH
47821: LD_VAR 0 29
47825: PUSH
47826: LD_VAR 0 30
47830: PUSH
47831: LD_VAR 0 31
47835: PUSH
47836: LD_VAR 0 32
47840: PUSH
47841: LD_VAR 0 33
47845: PUSH
47846: LD_VAR 0 34
47850: PUSH
47851: EMPTY
47852: LIST
47853: LIST
47854: LIST
47855: LIST
47856: LIST
47857: LIST
47858: PUSH
47859: LD_VAR 0 4
47863: PUSH
47864: LD_INT 1
47866: PLUS
47867: ARRAY
47868: ST_TO_ADDR
47869: GO 48354
47871: LD_INT 16
47873: DOUBLE
47874: EQUAL
47875: IFTRUE 47933
47877: LD_INT 17
47879: DOUBLE
47880: EQUAL
47881: IFTRUE 47933
47883: LD_INT 18
47885: DOUBLE
47886: EQUAL
47887: IFTRUE 47933
47889: LD_INT 19
47891: DOUBLE
47892: EQUAL
47893: IFTRUE 47933
47895: LD_INT 22
47897: DOUBLE
47898: EQUAL
47899: IFTRUE 47933
47901: LD_INT 20
47903: DOUBLE
47904: EQUAL
47905: IFTRUE 47933
47907: LD_INT 21
47909: DOUBLE
47910: EQUAL
47911: IFTRUE 47933
47913: LD_INT 23
47915: DOUBLE
47916: EQUAL
47917: IFTRUE 47933
47919: LD_INT 24
47921: DOUBLE
47922: EQUAL
47923: IFTRUE 47933
47925: LD_INT 25
47927: DOUBLE
47928: EQUAL
47929: IFTRUE 47933
47931: GO 47989
47933: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47934: LD_ADDR_VAR 0 9
47938: PUSH
47939: LD_VAR 0 35
47943: PUSH
47944: LD_VAR 0 36
47948: PUSH
47949: LD_VAR 0 37
47953: PUSH
47954: LD_VAR 0 38
47958: PUSH
47959: LD_VAR 0 39
47963: PUSH
47964: LD_VAR 0 40
47968: PUSH
47969: EMPTY
47970: LIST
47971: LIST
47972: LIST
47973: LIST
47974: LIST
47975: LIST
47976: PUSH
47977: LD_VAR 0 4
47981: PUSH
47982: LD_INT 1
47984: PLUS
47985: ARRAY
47986: ST_TO_ADDR
47987: GO 48354
47989: LD_INT 6
47991: DOUBLE
47992: EQUAL
47993: IFTRUE 48045
47995: LD_INT 7
47997: DOUBLE
47998: EQUAL
47999: IFTRUE 48045
48001: LD_INT 8
48003: DOUBLE
48004: EQUAL
48005: IFTRUE 48045
48007: LD_INT 13
48009: DOUBLE
48010: EQUAL
48011: IFTRUE 48045
48013: LD_INT 12
48015: DOUBLE
48016: EQUAL
48017: IFTRUE 48045
48019: LD_INT 15
48021: DOUBLE
48022: EQUAL
48023: IFTRUE 48045
48025: LD_INT 11
48027: DOUBLE
48028: EQUAL
48029: IFTRUE 48045
48031: LD_INT 14
48033: DOUBLE
48034: EQUAL
48035: IFTRUE 48045
48037: LD_INT 10
48039: DOUBLE
48040: EQUAL
48041: IFTRUE 48045
48043: GO 48101
48045: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
48046: LD_ADDR_VAR 0 9
48050: PUSH
48051: LD_VAR 0 41
48055: PUSH
48056: LD_VAR 0 42
48060: PUSH
48061: LD_VAR 0 43
48065: PUSH
48066: LD_VAR 0 44
48070: PUSH
48071: LD_VAR 0 45
48075: PUSH
48076: LD_VAR 0 46
48080: PUSH
48081: EMPTY
48082: LIST
48083: LIST
48084: LIST
48085: LIST
48086: LIST
48087: LIST
48088: PUSH
48089: LD_VAR 0 4
48093: PUSH
48094: LD_INT 1
48096: PLUS
48097: ARRAY
48098: ST_TO_ADDR
48099: GO 48354
48101: LD_INT 36
48103: DOUBLE
48104: EQUAL
48105: IFTRUE 48109
48107: GO 48165
48109: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
48110: LD_ADDR_VAR 0 9
48114: PUSH
48115: LD_VAR 0 47
48119: PUSH
48120: LD_VAR 0 48
48124: PUSH
48125: LD_VAR 0 49
48129: PUSH
48130: LD_VAR 0 50
48134: PUSH
48135: LD_VAR 0 51
48139: PUSH
48140: LD_VAR 0 52
48144: PUSH
48145: EMPTY
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: PUSH
48153: LD_VAR 0 4
48157: PUSH
48158: LD_INT 1
48160: PLUS
48161: ARRAY
48162: ST_TO_ADDR
48163: GO 48354
48165: LD_INT 4
48167: DOUBLE
48168: EQUAL
48169: IFTRUE 48191
48171: LD_INT 5
48173: DOUBLE
48174: EQUAL
48175: IFTRUE 48191
48177: LD_INT 34
48179: DOUBLE
48180: EQUAL
48181: IFTRUE 48191
48183: LD_INT 37
48185: DOUBLE
48186: EQUAL
48187: IFTRUE 48191
48189: GO 48247
48191: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
48192: LD_ADDR_VAR 0 9
48196: PUSH
48197: LD_VAR 0 53
48201: PUSH
48202: LD_VAR 0 54
48206: PUSH
48207: LD_VAR 0 55
48211: PUSH
48212: LD_VAR 0 56
48216: PUSH
48217: LD_VAR 0 57
48221: PUSH
48222: LD_VAR 0 58
48226: PUSH
48227: EMPTY
48228: LIST
48229: LIST
48230: LIST
48231: LIST
48232: LIST
48233: LIST
48234: PUSH
48235: LD_VAR 0 4
48239: PUSH
48240: LD_INT 1
48242: PLUS
48243: ARRAY
48244: ST_TO_ADDR
48245: GO 48354
48247: LD_INT 31
48249: DOUBLE
48250: EQUAL
48251: IFTRUE 48297
48253: LD_INT 32
48255: DOUBLE
48256: EQUAL
48257: IFTRUE 48297
48259: LD_INT 33
48261: DOUBLE
48262: EQUAL
48263: IFTRUE 48297
48265: LD_INT 27
48267: DOUBLE
48268: EQUAL
48269: IFTRUE 48297
48271: LD_INT 26
48273: DOUBLE
48274: EQUAL
48275: IFTRUE 48297
48277: LD_INT 28
48279: DOUBLE
48280: EQUAL
48281: IFTRUE 48297
48283: LD_INT 29
48285: DOUBLE
48286: EQUAL
48287: IFTRUE 48297
48289: LD_INT 30
48291: DOUBLE
48292: EQUAL
48293: IFTRUE 48297
48295: GO 48353
48297: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
48298: LD_ADDR_VAR 0 9
48302: PUSH
48303: LD_VAR 0 59
48307: PUSH
48308: LD_VAR 0 60
48312: PUSH
48313: LD_VAR 0 61
48317: PUSH
48318: LD_VAR 0 62
48322: PUSH
48323: LD_VAR 0 63
48327: PUSH
48328: LD_VAR 0 64
48332: PUSH
48333: EMPTY
48334: LIST
48335: LIST
48336: LIST
48337: LIST
48338: LIST
48339: LIST
48340: PUSH
48341: LD_VAR 0 4
48345: PUSH
48346: LD_INT 1
48348: PLUS
48349: ARRAY
48350: ST_TO_ADDR
48351: GO 48354
48353: POP
// temp_list2 = [ ] ;
48354: LD_ADDR_VAR 0 10
48358: PUSH
48359: EMPTY
48360: ST_TO_ADDR
// for i in temp_list do
48361: LD_ADDR_VAR 0 8
48365: PUSH
48366: LD_VAR 0 9
48370: PUSH
48371: FOR_IN
48372: IFFALSE 48424
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
48374: LD_ADDR_VAR 0 10
48378: PUSH
48379: LD_VAR 0 10
48383: PUSH
48384: LD_VAR 0 8
48388: PUSH
48389: LD_INT 1
48391: ARRAY
48392: PUSH
48393: LD_VAR 0 2
48397: PLUS
48398: PUSH
48399: LD_VAR 0 8
48403: PUSH
48404: LD_INT 2
48406: ARRAY
48407: PUSH
48408: LD_VAR 0 3
48412: PLUS
48413: PUSH
48414: EMPTY
48415: LIST
48416: LIST
48417: PUSH
48418: EMPTY
48419: LIST
48420: ADD
48421: ST_TO_ADDR
48422: GO 48371
48424: POP
48425: POP
// result = temp_list2 ;
48426: LD_ADDR_VAR 0 7
48430: PUSH
48431: LD_VAR 0 10
48435: ST_TO_ADDR
// end ;
48436: LD_VAR 0 7
48440: RET
// export function EnemyInRange ( unit , dist ) ; begin
48441: LD_INT 0
48443: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
48444: LD_ADDR_VAR 0 3
48448: PUSH
48449: LD_VAR 0 1
48453: PPUSH
48454: CALL_OW 255
48458: PPUSH
48459: LD_VAR 0 1
48463: PPUSH
48464: CALL_OW 250
48468: PPUSH
48469: LD_VAR 0 1
48473: PPUSH
48474: CALL_OW 251
48478: PPUSH
48479: LD_VAR 0 2
48483: PPUSH
48484: CALL 22545 0 4
48488: PUSH
48489: LD_INT 4
48491: ARRAY
48492: ST_TO_ADDR
// end ;
48493: LD_VAR 0 3
48497: RET
// export function PlayerSeeMe ( unit ) ; begin
48498: LD_INT 0
48500: PPUSH
// result := See ( your_side , unit ) ;
48501: LD_ADDR_VAR 0 2
48505: PUSH
48506: LD_OWVAR 2
48510: PPUSH
48511: LD_VAR 0 1
48515: PPUSH
48516: CALL_OW 292
48520: ST_TO_ADDR
// end ;
48521: LD_VAR 0 2
48525: RET
// export function ReverseDir ( unit ) ; begin
48526: LD_INT 0
48528: PPUSH
// if not unit then
48529: LD_VAR 0 1
48533: NOT
48534: IFFALSE 48538
// exit ;
48536: GO 48561
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
48538: LD_ADDR_VAR 0 2
48542: PUSH
48543: LD_VAR 0 1
48547: PPUSH
48548: CALL_OW 254
48552: PUSH
48553: LD_INT 3
48555: PLUS
48556: PUSH
48557: LD_INT 6
48559: MOD
48560: ST_TO_ADDR
// end ;
48561: LD_VAR 0 2
48565: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
48566: LD_INT 0
48568: PPUSH
48569: PPUSH
48570: PPUSH
48571: PPUSH
48572: PPUSH
// if not hexes then
48573: LD_VAR 0 2
48577: NOT
48578: IFFALSE 48582
// exit ;
48580: GO 48730
// dist := 9999 ;
48582: LD_ADDR_VAR 0 5
48586: PUSH
48587: LD_INT 9999
48589: ST_TO_ADDR
// for i = 1 to hexes do
48590: LD_ADDR_VAR 0 4
48594: PUSH
48595: DOUBLE
48596: LD_INT 1
48598: DEC
48599: ST_TO_ADDR
48600: LD_VAR 0 2
48604: PUSH
48605: FOR_TO
48606: IFFALSE 48718
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
48608: LD_VAR 0 1
48612: PPUSH
48613: LD_VAR 0 2
48617: PUSH
48618: LD_VAR 0 4
48622: ARRAY
48623: PUSH
48624: LD_INT 1
48626: ARRAY
48627: PPUSH
48628: LD_VAR 0 2
48632: PUSH
48633: LD_VAR 0 4
48637: ARRAY
48638: PUSH
48639: LD_INT 2
48641: ARRAY
48642: PPUSH
48643: CALL_OW 297
48647: PUSH
48648: LD_VAR 0 5
48652: LESS
48653: IFFALSE 48716
// begin hex := hexes [ i ] ;
48655: LD_ADDR_VAR 0 7
48659: PUSH
48660: LD_VAR 0 2
48664: PUSH
48665: LD_VAR 0 4
48669: ARRAY
48670: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48671: LD_ADDR_VAR 0 5
48675: PUSH
48676: LD_VAR 0 1
48680: PPUSH
48681: LD_VAR 0 2
48685: PUSH
48686: LD_VAR 0 4
48690: ARRAY
48691: PUSH
48692: LD_INT 1
48694: ARRAY
48695: PPUSH
48696: LD_VAR 0 2
48700: PUSH
48701: LD_VAR 0 4
48705: ARRAY
48706: PUSH
48707: LD_INT 2
48709: ARRAY
48710: PPUSH
48711: CALL_OW 297
48715: ST_TO_ADDR
// end ; end ;
48716: GO 48605
48718: POP
48719: POP
// result := hex ;
48720: LD_ADDR_VAR 0 3
48724: PUSH
48725: LD_VAR 0 7
48729: ST_TO_ADDR
// end ;
48730: LD_VAR 0 3
48734: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48735: LD_INT 0
48737: PPUSH
48738: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48739: LD_VAR 0 1
48743: NOT
48744: PUSH
48745: LD_VAR 0 1
48749: PUSH
48750: LD_INT 21
48752: PUSH
48753: LD_INT 2
48755: PUSH
48756: EMPTY
48757: LIST
48758: LIST
48759: PUSH
48760: LD_INT 23
48762: PUSH
48763: LD_INT 2
48765: PUSH
48766: EMPTY
48767: LIST
48768: LIST
48769: PUSH
48770: EMPTY
48771: LIST
48772: LIST
48773: PPUSH
48774: CALL_OW 69
48778: IN
48779: NOT
48780: OR
48781: IFFALSE 48785
// exit ;
48783: GO 48832
// for i = 1 to 3 do
48785: LD_ADDR_VAR 0 3
48789: PUSH
48790: DOUBLE
48791: LD_INT 1
48793: DEC
48794: ST_TO_ADDR
48795: LD_INT 3
48797: PUSH
48798: FOR_TO
48799: IFFALSE 48830
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48801: LD_VAR 0 1
48805: PPUSH
48806: CALL_OW 250
48810: PPUSH
48811: LD_VAR 0 1
48815: PPUSH
48816: CALL_OW 251
48820: PPUSH
48821: LD_INT 1
48823: PPUSH
48824: CALL_OW 453
48828: GO 48798
48830: POP
48831: POP
// end ;
48832: LD_VAR 0 2
48836: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48837: LD_INT 0
48839: PPUSH
48840: PPUSH
48841: PPUSH
48842: PPUSH
48843: PPUSH
48844: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48845: LD_VAR 0 1
48849: NOT
48850: PUSH
48851: LD_VAR 0 2
48855: NOT
48856: OR
48857: PUSH
48858: LD_VAR 0 1
48862: PPUSH
48863: CALL_OW 314
48867: OR
48868: IFFALSE 48872
// exit ;
48870: GO 49313
// x := GetX ( enemy_unit ) ;
48872: LD_ADDR_VAR 0 7
48876: PUSH
48877: LD_VAR 0 2
48881: PPUSH
48882: CALL_OW 250
48886: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48887: LD_ADDR_VAR 0 8
48891: PUSH
48892: LD_VAR 0 2
48896: PPUSH
48897: CALL_OW 251
48901: ST_TO_ADDR
// if not x or not y then
48902: LD_VAR 0 7
48906: NOT
48907: PUSH
48908: LD_VAR 0 8
48912: NOT
48913: OR
48914: IFFALSE 48918
// exit ;
48916: GO 49313
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48918: LD_ADDR_VAR 0 6
48922: PUSH
48923: LD_VAR 0 7
48927: PPUSH
48928: LD_INT 0
48930: PPUSH
48931: LD_INT 4
48933: PPUSH
48934: CALL_OW 272
48938: PUSH
48939: LD_VAR 0 8
48943: PPUSH
48944: LD_INT 0
48946: PPUSH
48947: LD_INT 4
48949: PPUSH
48950: CALL_OW 273
48954: PUSH
48955: EMPTY
48956: LIST
48957: LIST
48958: PUSH
48959: LD_VAR 0 7
48963: PPUSH
48964: LD_INT 1
48966: PPUSH
48967: LD_INT 4
48969: PPUSH
48970: CALL_OW 272
48974: PUSH
48975: LD_VAR 0 8
48979: PPUSH
48980: LD_INT 1
48982: PPUSH
48983: LD_INT 4
48985: PPUSH
48986: CALL_OW 273
48990: PUSH
48991: EMPTY
48992: LIST
48993: LIST
48994: PUSH
48995: LD_VAR 0 7
48999: PPUSH
49000: LD_INT 2
49002: PPUSH
49003: LD_INT 4
49005: PPUSH
49006: CALL_OW 272
49010: PUSH
49011: LD_VAR 0 8
49015: PPUSH
49016: LD_INT 2
49018: PPUSH
49019: LD_INT 4
49021: PPUSH
49022: CALL_OW 273
49026: PUSH
49027: EMPTY
49028: LIST
49029: LIST
49030: PUSH
49031: LD_VAR 0 7
49035: PPUSH
49036: LD_INT 3
49038: PPUSH
49039: LD_INT 4
49041: PPUSH
49042: CALL_OW 272
49046: PUSH
49047: LD_VAR 0 8
49051: PPUSH
49052: LD_INT 3
49054: PPUSH
49055: LD_INT 4
49057: PPUSH
49058: CALL_OW 273
49062: PUSH
49063: EMPTY
49064: LIST
49065: LIST
49066: PUSH
49067: LD_VAR 0 7
49071: PPUSH
49072: LD_INT 4
49074: PPUSH
49075: LD_INT 4
49077: PPUSH
49078: CALL_OW 272
49082: PUSH
49083: LD_VAR 0 8
49087: PPUSH
49088: LD_INT 4
49090: PPUSH
49091: LD_INT 4
49093: PPUSH
49094: CALL_OW 273
49098: PUSH
49099: EMPTY
49100: LIST
49101: LIST
49102: PUSH
49103: LD_VAR 0 7
49107: PPUSH
49108: LD_INT 5
49110: PPUSH
49111: LD_INT 4
49113: PPUSH
49114: CALL_OW 272
49118: PUSH
49119: LD_VAR 0 8
49123: PPUSH
49124: LD_INT 5
49126: PPUSH
49127: LD_INT 4
49129: PPUSH
49130: CALL_OW 273
49134: PUSH
49135: EMPTY
49136: LIST
49137: LIST
49138: PUSH
49139: EMPTY
49140: LIST
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: ST_TO_ADDR
// for i = tmp downto 1 do
49147: LD_ADDR_VAR 0 4
49151: PUSH
49152: DOUBLE
49153: LD_VAR 0 6
49157: INC
49158: ST_TO_ADDR
49159: LD_INT 1
49161: PUSH
49162: FOR_DOWNTO
49163: IFFALSE 49264
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
49165: LD_VAR 0 6
49169: PUSH
49170: LD_VAR 0 4
49174: ARRAY
49175: PUSH
49176: LD_INT 1
49178: ARRAY
49179: PPUSH
49180: LD_VAR 0 6
49184: PUSH
49185: LD_VAR 0 4
49189: ARRAY
49190: PUSH
49191: LD_INT 2
49193: ARRAY
49194: PPUSH
49195: CALL_OW 488
49199: NOT
49200: PUSH
49201: LD_VAR 0 6
49205: PUSH
49206: LD_VAR 0 4
49210: ARRAY
49211: PUSH
49212: LD_INT 1
49214: ARRAY
49215: PPUSH
49216: LD_VAR 0 6
49220: PUSH
49221: LD_VAR 0 4
49225: ARRAY
49226: PUSH
49227: LD_INT 2
49229: ARRAY
49230: PPUSH
49231: CALL_OW 428
49235: PUSH
49236: LD_INT 0
49238: NONEQUAL
49239: OR
49240: IFFALSE 49262
// tmp := Delete ( tmp , i ) ;
49242: LD_ADDR_VAR 0 6
49246: PUSH
49247: LD_VAR 0 6
49251: PPUSH
49252: LD_VAR 0 4
49256: PPUSH
49257: CALL_OW 3
49261: ST_TO_ADDR
49262: GO 49162
49264: POP
49265: POP
// j := GetClosestHex ( unit , tmp ) ;
49266: LD_ADDR_VAR 0 5
49270: PUSH
49271: LD_VAR 0 1
49275: PPUSH
49276: LD_VAR 0 6
49280: PPUSH
49281: CALL 48566 0 2
49285: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
49286: LD_VAR 0 1
49290: PPUSH
49291: LD_VAR 0 5
49295: PUSH
49296: LD_INT 1
49298: ARRAY
49299: PPUSH
49300: LD_VAR 0 5
49304: PUSH
49305: LD_INT 2
49307: ARRAY
49308: PPUSH
49309: CALL_OW 111
// end ;
49313: LD_VAR 0 3
49317: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49318: LD_INT 0
49320: PPUSH
49321: PPUSH
49322: PPUSH
// uc_side = 0 ;
49323: LD_ADDR_OWVAR 20
49327: PUSH
49328: LD_INT 0
49330: ST_TO_ADDR
// uc_nation = 0 ;
49331: LD_ADDR_OWVAR 21
49335: PUSH
49336: LD_INT 0
49338: ST_TO_ADDR
// InitHc ;
49339: CALL_OW 19
// InitVc ;
49343: CALL_OW 20
// if mastodonts then
49347: LD_VAR 0 6
49351: IFFALSE 49418
// for i = 1 to mastodonts do
49353: LD_ADDR_VAR 0 11
49357: PUSH
49358: DOUBLE
49359: LD_INT 1
49361: DEC
49362: ST_TO_ADDR
49363: LD_VAR 0 6
49367: PUSH
49368: FOR_TO
49369: IFFALSE 49416
// begin vc_chassis := 31 ;
49371: LD_ADDR_OWVAR 37
49375: PUSH
49376: LD_INT 31
49378: ST_TO_ADDR
// vc_control := control_rider ;
49379: LD_ADDR_OWVAR 38
49383: PUSH
49384: LD_INT 4
49386: ST_TO_ADDR
// animal := CreateVehicle ;
49387: LD_ADDR_VAR 0 12
49391: PUSH
49392: CALL_OW 45
49396: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49397: LD_VAR 0 12
49401: PPUSH
49402: LD_VAR 0 8
49406: PPUSH
49407: LD_INT 0
49409: PPUSH
49410: CALL 56196 0 3
// end ;
49414: GO 49368
49416: POP
49417: POP
// if horses then
49418: LD_VAR 0 5
49422: IFFALSE 49489
// for i = 1 to horses do
49424: LD_ADDR_VAR 0 11
49428: PUSH
49429: DOUBLE
49430: LD_INT 1
49432: DEC
49433: ST_TO_ADDR
49434: LD_VAR 0 5
49438: PUSH
49439: FOR_TO
49440: IFFALSE 49487
// begin hc_class := 21 ;
49442: LD_ADDR_OWVAR 28
49446: PUSH
49447: LD_INT 21
49449: ST_TO_ADDR
// hc_gallery :=  ;
49450: LD_ADDR_OWVAR 33
49454: PUSH
49455: LD_STRING 
49457: ST_TO_ADDR
// animal := CreateHuman ;
49458: LD_ADDR_VAR 0 12
49462: PUSH
49463: CALL_OW 44
49467: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49468: LD_VAR 0 12
49472: PPUSH
49473: LD_VAR 0 8
49477: PPUSH
49478: LD_INT 0
49480: PPUSH
49481: CALL 56196 0 3
// end ;
49485: GO 49439
49487: POP
49488: POP
// if birds then
49489: LD_VAR 0 1
49493: IFFALSE 49560
// for i = 1 to birds do
49495: LD_ADDR_VAR 0 11
49499: PUSH
49500: DOUBLE
49501: LD_INT 1
49503: DEC
49504: ST_TO_ADDR
49505: LD_VAR 0 1
49509: PUSH
49510: FOR_TO
49511: IFFALSE 49558
// begin hc_class = 18 ;
49513: LD_ADDR_OWVAR 28
49517: PUSH
49518: LD_INT 18
49520: ST_TO_ADDR
// hc_gallery =  ;
49521: LD_ADDR_OWVAR 33
49525: PUSH
49526: LD_STRING 
49528: ST_TO_ADDR
// animal := CreateHuman ;
49529: LD_ADDR_VAR 0 12
49533: PUSH
49534: CALL_OW 44
49538: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49539: LD_VAR 0 12
49543: PPUSH
49544: LD_VAR 0 8
49548: PPUSH
49549: LD_INT 0
49551: PPUSH
49552: CALL 56196 0 3
// end ;
49556: GO 49510
49558: POP
49559: POP
// if tigers then
49560: LD_VAR 0 2
49564: IFFALSE 49648
// for i = 1 to tigers do
49566: LD_ADDR_VAR 0 11
49570: PUSH
49571: DOUBLE
49572: LD_INT 1
49574: DEC
49575: ST_TO_ADDR
49576: LD_VAR 0 2
49580: PUSH
49581: FOR_TO
49582: IFFALSE 49646
// begin hc_class = class_tiger ;
49584: LD_ADDR_OWVAR 28
49588: PUSH
49589: LD_INT 14
49591: ST_TO_ADDR
// hc_gallery =  ;
49592: LD_ADDR_OWVAR 33
49596: PUSH
49597: LD_STRING 
49599: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49600: LD_ADDR_OWVAR 35
49604: PUSH
49605: LD_INT 7
49607: NEG
49608: PPUSH
49609: LD_INT 7
49611: PPUSH
49612: CALL_OW 12
49616: ST_TO_ADDR
// animal := CreateHuman ;
49617: LD_ADDR_VAR 0 12
49621: PUSH
49622: CALL_OW 44
49626: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49627: LD_VAR 0 12
49631: PPUSH
49632: LD_VAR 0 8
49636: PPUSH
49637: LD_INT 0
49639: PPUSH
49640: CALL 56196 0 3
// end ;
49644: GO 49581
49646: POP
49647: POP
// if apemans then
49648: LD_VAR 0 3
49652: IFFALSE 49775
// for i = 1 to apemans do
49654: LD_ADDR_VAR 0 11
49658: PUSH
49659: DOUBLE
49660: LD_INT 1
49662: DEC
49663: ST_TO_ADDR
49664: LD_VAR 0 3
49668: PUSH
49669: FOR_TO
49670: IFFALSE 49773
// begin hc_class = class_apeman ;
49672: LD_ADDR_OWVAR 28
49676: PUSH
49677: LD_INT 12
49679: ST_TO_ADDR
// hc_gallery =  ;
49680: LD_ADDR_OWVAR 33
49684: PUSH
49685: LD_STRING 
49687: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
49688: LD_ADDR_OWVAR 35
49692: PUSH
49693: LD_INT 5
49695: NEG
49696: PPUSH
49697: LD_INT 5
49699: PPUSH
49700: CALL_OW 12
49704: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49705: LD_ADDR_OWVAR 31
49709: PUSH
49710: LD_INT 1
49712: PPUSH
49713: LD_INT 3
49715: PPUSH
49716: CALL_OW 12
49720: PUSH
49721: LD_INT 1
49723: PPUSH
49724: LD_INT 3
49726: PPUSH
49727: CALL_OW 12
49731: PUSH
49732: LD_INT 0
49734: PUSH
49735: LD_INT 0
49737: PUSH
49738: EMPTY
49739: LIST
49740: LIST
49741: LIST
49742: LIST
49743: ST_TO_ADDR
// animal := CreateHuman ;
49744: LD_ADDR_VAR 0 12
49748: PUSH
49749: CALL_OW 44
49753: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49754: LD_VAR 0 12
49758: PPUSH
49759: LD_VAR 0 8
49763: PPUSH
49764: LD_INT 0
49766: PPUSH
49767: CALL 56196 0 3
// end ;
49771: GO 49669
49773: POP
49774: POP
// if enchidnas then
49775: LD_VAR 0 4
49779: IFFALSE 49846
// for i = 1 to enchidnas do
49781: LD_ADDR_VAR 0 11
49785: PUSH
49786: DOUBLE
49787: LD_INT 1
49789: DEC
49790: ST_TO_ADDR
49791: LD_VAR 0 4
49795: PUSH
49796: FOR_TO
49797: IFFALSE 49844
// begin hc_class = 13 ;
49799: LD_ADDR_OWVAR 28
49803: PUSH
49804: LD_INT 13
49806: ST_TO_ADDR
// hc_gallery =  ;
49807: LD_ADDR_OWVAR 33
49811: PUSH
49812: LD_STRING 
49814: ST_TO_ADDR
// animal := CreateHuman ;
49815: LD_ADDR_VAR 0 12
49819: PUSH
49820: CALL_OW 44
49824: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49825: LD_VAR 0 12
49829: PPUSH
49830: LD_VAR 0 8
49834: PPUSH
49835: LD_INT 0
49837: PPUSH
49838: CALL 56196 0 3
// end ;
49842: GO 49796
49844: POP
49845: POP
// if fishes then
49846: LD_VAR 0 7
49850: IFFALSE 49917
// for i = 1 to fishes do
49852: LD_ADDR_VAR 0 11
49856: PUSH
49857: DOUBLE
49858: LD_INT 1
49860: DEC
49861: ST_TO_ADDR
49862: LD_VAR 0 7
49866: PUSH
49867: FOR_TO
49868: IFFALSE 49915
// begin hc_class = 20 ;
49870: LD_ADDR_OWVAR 28
49874: PUSH
49875: LD_INT 20
49877: ST_TO_ADDR
// hc_gallery =  ;
49878: LD_ADDR_OWVAR 33
49882: PUSH
49883: LD_STRING 
49885: ST_TO_ADDR
// animal := CreateHuman ;
49886: LD_ADDR_VAR 0 12
49890: PUSH
49891: CALL_OW 44
49895: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49896: LD_VAR 0 12
49900: PPUSH
49901: LD_VAR 0 9
49905: PPUSH
49906: LD_INT 0
49908: PPUSH
49909: CALL 56196 0 3
// end ;
49913: GO 49867
49915: POP
49916: POP
// end ;
49917: LD_VAR 0 10
49921: RET
// export function WantHeal ( sci , unit ) ; begin
49922: LD_INT 0
49924: PPUSH
// if GetTaskList ( sci ) > 0 then
49925: LD_VAR 0 1
49929: PPUSH
49930: CALL_OW 437
49934: PUSH
49935: LD_INT 0
49937: GREATER
49938: IFFALSE 50008
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49940: LD_VAR 0 1
49944: PPUSH
49945: CALL_OW 437
49949: PUSH
49950: LD_INT 1
49952: ARRAY
49953: PUSH
49954: LD_INT 1
49956: ARRAY
49957: PUSH
49958: LD_STRING l
49960: EQUAL
49961: PUSH
49962: LD_VAR 0 1
49966: PPUSH
49967: CALL_OW 437
49971: PUSH
49972: LD_INT 1
49974: ARRAY
49975: PUSH
49976: LD_INT 4
49978: ARRAY
49979: PUSH
49980: LD_VAR 0 2
49984: EQUAL
49985: AND
49986: IFFALSE 49998
// result := true else
49988: LD_ADDR_VAR 0 3
49992: PUSH
49993: LD_INT 1
49995: ST_TO_ADDR
49996: GO 50006
// result := false ;
49998: LD_ADDR_VAR 0 3
50002: PUSH
50003: LD_INT 0
50005: ST_TO_ADDR
// end else
50006: GO 50016
// result := false ;
50008: LD_ADDR_VAR 0 3
50012: PUSH
50013: LD_INT 0
50015: ST_TO_ADDR
// end ;
50016: LD_VAR 0 3
50020: RET
// export function HealTarget ( sci ) ; begin
50021: LD_INT 0
50023: PPUSH
// if not sci then
50024: LD_VAR 0 1
50028: NOT
50029: IFFALSE 50033
// exit ;
50031: GO 50098
// result := 0 ;
50033: LD_ADDR_VAR 0 2
50037: PUSH
50038: LD_INT 0
50040: ST_TO_ADDR
// if GetTaskList ( sci ) then
50041: LD_VAR 0 1
50045: PPUSH
50046: CALL_OW 437
50050: IFFALSE 50098
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
50052: LD_VAR 0 1
50056: PPUSH
50057: CALL_OW 437
50061: PUSH
50062: LD_INT 1
50064: ARRAY
50065: PUSH
50066: LD_INT 1
50068: ARRAY
50069: PUSH
50070: LD_STRING l
50072: EQUAL
50073: IFFALSE 50098
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
50075: LD_ADDR_VAR 0 2
50079: PUSH
50080: LD_VAR 0 1
50084: PPUSH
50085: CALL_OW 437
50089: PUSH
50090: LD_INT 1
50092: ARRAY
50093: PUSH
50094: LD_INT 4
50096: ARRAY
50097: ST_TO_ADDR
// end ;
50098: LD_VAR 0 2
50102: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
50103: LD_INT 0
50105: PPUSH
50106: PPUSH
50107: PPUSH
50108: PPUSH
50109: PPUSH
50110: PPUSH
50111: PPUSH
50112: PPUSH
50113: PPUSH
50114: PPUSH
50115: PPUSH
50116: PPUSH
50117: PPUSH
50118: PPUSH
50119: PPUSH
50120: PPUSH
50121: PPUSH
50122: PPUSH
50123: PPUSH
50124: PPUSH
50125: PPUSH
50126: PPUSH
50127: PPUSH
50128: PPUSH
50129: PPUSH
50130: PPUSH
50131: PPUSH
50132: PPUSH
50133: PPUSH
50134: PPUSH
50135: PPUSH
50136: PPUSH
50137: PPUSH
50138: PPUSH
// if not list then
50139: LD_VAR 0 1
50143: NOT
50144: IFFALSE 50148
// exit ;
50146: GO 54807
// base := list [ 1 ] ;
50148: LD_ADDR_VAR 0 3
50152: PUSH
50153: LD_VAR 0 1
50157: PUSH
50158: LD_INT 1
50160: ARRAY
50161: ST_TO_ADDR
// group := list [ 2 ] ;
50162: LD_ADDR_VAR 0 4
50166: PUSH
50167: LD_VAR 0 1
50171: PUSH
50172: LD_INT 2
50174: ARRAY
50175: ST_TO_ADDR
// path := list [ 3 ] ;
50176: LD_ADDR_VAR 0 5
50180: PUSH
50181: LD_VAR 0 1
50185: PUSH
50186: LD_INT 3
50188: ARRAY
50189: ST_TO_ADDR
// flags := list [ 4 ] ;
50190: LD_ADDR_VAR 0 6
50194: PUSH
50195: LD_VAR 0 1
50199: PUSH
50200: LD_INT 4
50202: ARRAY
50203: ST_TO_ADDR
// mined := [ ] ;
50204: LD_ADDR_VAR 0 27
50208: PUSH
50209: EMPTY
50210: ST_TO_ADDR
// bombed := [ ] ;
50211: LD_ADDR_VAR 0 28
50215: PUSH
50216: EMPTY
50217: ST_TO_ADDR
// healers := [ ] ;
50218: LD_ADDR_VAR 0 31
50222: PUSH
50223: EMPTY
50224: ST_TO_ADDR
// to_heal := [ ] ;
50225: LD_ADDR_VAR 0 30
50229: PUSH
50230: EMPTY
50231: ST_TO_ADDR
// repairs := [ ] ;
50232: LD_ADDR_VAR 0 33
50236: PUSH
50237: EMPTY
50238: ST_TO_ADDR
// to_repair := [ ] ;
50239: LD_ADDR_VAR 0 32
50243: PUSH
50244: EMPTY
50245: ST_TO_ADDR
// if not group or not path then
50246: LD_VAR 0 4
50250: NOT
50251: PUSH
50252: LD_VAR 0 5
50256: NOT
50257: OR
50258: IFFALSE 50262
// exit ;
50260: GO 54807
// side := GetSide ( group [ 1 ] ) ;
50262: LD_ADDR_VAR 0 35
50266: PUSH
50267: LD_VAR 0 4
50271: PUSH
50272: LD_INT 1
50274: ARRAY
50275: PPUSH
50276: CALL_OW 255
50280: ST_TO_ADDR
// if flags then
50281: LD_VAR 0 6
50285: IFFALSE 50429
// begin f_ignore_area := flags [ 1 ] ;
50287: LD_ADDR_VAR 0 17
50291: PUSH
50292: LD_VAR 0 6
50296: PUSH
50297: LD_INT 1
50299: ARRAY
50300: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
50301: LD_ADDR_VAR 0 18
50305: PUSH
50306: LD_VAR 0 6
50310: PUSH
50311: LD_INT 2
50313: ARRAY
50314: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
50315: LD_ADDR_VAR 0 19
50319: PUSH
50320: LD_VAR 0 6
50324: PUSH
50325: LD_INT 3
50327: ARRAY
50328: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
50329: LD_ADDR_VAR 0 20
50333: PUSH
50334: LD_VAR 0 6
50338: PUSH
50339: LD_INT 4
50341: ARRAY
50342: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
50343: LD_ADDR_VAR 0 21
50347: PUSH
50348: LD_VAR 0 6
50352: PUSH
50353: LD_INT 5
50355: ARRAY
50356: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
50357: LD_ADDR_VAR 0 22
50361: PUSH
50362: LD_VAR 0 6
50366: PUSH
50367: LD_INT 6
50369: ARRAY
50370: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
50371: LD_ADDR_VAR 0 23
50375: PUSH
50376: LD_VAR 0 6
50380: PUSH
50381: LD_INT 7
50383: ARRAY
50384: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
50385: LD_ADDR_VAR 0 24
50389: PUSH
50390: LD_VAR 0 6
50394: PUSH
50395: LD_INT 8
50397: ARRAY
50398: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
50399: LD_ADDR_VAR 0 25
50403: PUSH
50404: LD_VAR 0 6
50408: PUSH
50409: LD_INT 9
50411: ARRAY
50412: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
50413: LD_ADDR_VAR 0 26
50417: PUSH
50418: LD_VAR 0 6
50422: PUSH
50423: LD_INT 10
50425: ARRAY
50426: ST_TO_ADDR
// end else
50427: GO 50509
// begin f_ignore_area := false ;
50429: LD_ADDR_VAR 0 17
50433: PUSH
50434: LD_INT 0
50436: ST_TO_ADDR
// f_capture := false ;
50437: LD_ADDR_VAR 0 18
50441: PUSH
50442: LD_INT 0
50444: ST_TO_ADDR
// f_ignore_civ := false ;
50445: LD_ADDR_VAR 0 19
50449: PUSH
50450: LD_INT 0
50452: ST_TO_ADDR
// f_murder := false ;
50453: LD_ADDR_VAR 0 20
50457: PUSH
50458: LD_INT 0
50460: ST_TO_ADDR
// f_mines := false ;
50461: LD_ADDR_VAR 0 21
50465: PUSH
50466: LD_INT 0
50468: ST_TO_ADDR
// f_repair := false ;
50469: LD_ADDR_VAR 0 22
50473: PUSH
50474: LD_INT 0
50476: ST_TO_ADDR
// f_heal := false ;
50477: LD_ADDR_VAR 0 23
50481: PUSH
50482: LD_INT 0
50484: ST_TO_ADDR
// f_spacetime := false ;
50485: LD_ADDR_VAR 0 24
50489: PUSH
50490: LD_INT 0
50492: ST_TO_ADDR
// f_attack_depot := false ;
50493: LD_ADDR_VAR 0 25
50497: PUSH
50498: LD_INT 0
50500: ST_TO_ADDR
// f_crawl := false ;
50501: LD_ADDR_VAR 0 26
50505: PUSH
50506: LD_INT 0
50508: ST_TO_ADDR
// end ; if f_heal then
50509: LD_VAR 0 23
50513: IFFALSE 50540
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
50515: LD_ADDR_VAR 0 31
50519: PUSH
50520: LD_VAR 0 4
50524: PPUSH
50525: LD_INT 25
50527: PUSH
50528: LD_INT 4
50530: PUSH
50531: EMPTY
50532: LIST
50533: LIST
50534: PPUSH
50535: CALL_OW 72
50539: ST_TO_ADDR
// if f_repair then
50540: LD_VAR 0 22
50544: IFFALSE 50571
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
50546: LD_ADDR_VAR 0 33
50550: PUSH
50551: LD_VAR 0 4
50555: PPUSH
50556: LD_INT 25
50558: PUSH
50559: LD_INT 3
50561: PUSH
50562: EMPTY
50563: LIST
50564: LIST
50565: PPUSH
50566: CALL_OW 72
50570: ST_TO_ADDR
// units_path := [ ] ;
50571: LD_ADDR_VAR 0 16
50575: PUSH
50576: EMPTY
50577: ST_TO_ADDR
// for i = 1 to group do
50578: LD_ADDR_VAR 0 7
50582: PUSH
50583: DOUBLE
50584: LD_INT 1
50586: DEC
50587: ST_TO_ADDR
50588: LD_VAR 0 4
50592: PUSH
50593: FOR_TO
50594: IFFALSE 50623
// units_path := Replace ( units_path , i , path ) ;
50596: LD_ADDR_VAR 0 16
50600: PUSH
50601: LD_VAR 0 16
50605: PPUSH
50606: LD_VAR 0 7
50610: PPUSH
50611: LD_VAR 0 5
50615: PPUSH
50616: CALL_OW 1
50620: ST_TO_ADDR
50621: GO 50593
50623: POP
50624: POP
// repeat for i = group downto 1 do
50625: LD_ADDR_VAR 0 7
50629: PUSH
50630: DOUBLE
50631: LD_VAR 0 4
50635: INC
50636: ST_TO_ADDR
50637: LD_INT 1
50639: PUSH
50640: FOR_DOWNTO
50641: IFFALSE 54763
// begin wait ( 5 ) ;
50643: LD_INT 5
50645: PPUSH
50646: CALL_OW 67
// tmp := [ ] ;
50650: LD_ADDR_VAR 0 14
50654: PUSH
50655: EMPTY
50656: ST_TO_ADDR
// attacking := false ;
50657: LD_ADDR_VAR 0 29
50661: PUSH
50662: LD_INT 0
50664: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
50665: LD_VAR 0 4
50669: PUSH
50670: LD_VAR 0 7
50674: ARRAY
50675: PPUSH
50676: CALL_OW 301
50680: PUSH
50681: LD_VAR 0 4
50685: PUSH
50686: LD_VAR 0 7
50690: ARRAY
50691: NOT
50692: OR
50693: IFFALSE 50802
// begin if GetType ( group [ i ] ) = unit_human then
50695: LD_VAR 0 4
50699: PUSH
50700: LD_VAR 0 7
50704: ARRAY
50705: PPUSH
50706: CALL_OW 247
50710: PUSH
50711: LD_INT 1
50713: EQUAL
50714: IFFALSE 50760
// begin to_heal := to_heal diff group [ i ] ;
50716: LD_ADDR_VAR 0 30
50720: PUSH
50721: LD_VAR 0 30
50725: PUSH
50726: LD_VAR 0 4
50730: PUSH
50731: LD_VAR 0 7
50735: ARRAY
50736: DIFF
50737: ST_TO_ADDR
// healers := healers diff group [ i ] ;
50738: LD_ADDR_VAR 0 31
50742: PUSH
50743: LD_VAR 0 31
50747: PUSH
50748: LD_VAR 0 4
50752: PUSH
50753: LD_VAR 0 7
50757: ARRAY
50758: DIFF
50759: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
50760: LD_ADDR_VAR 0 4
50764: PUSH
50765: LD_VAR 0 4
50769: PPUSH
50770: LD_VAR 0 7
50774: PPUSH
50775: CALL_OW 3
50779: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
50780: LD_ADDR_VAR 0 16
50784: PUSH
50785: LD_VAR 0 16
50789: PPUSH
50790: LD_VAR 0 7
50794: PPUSH
50795: CALL_OW 3
50799: ST_TO_ADDR
// continue ;
50800: GO 50640
// end ; if f_repair then
50802: LD_VAR 0 22
50806: IFFALSE 51295
// begin if GetType ( group [ i ] ) = unit_vehicle then
50808: LD_VAR 0 4
50812: PUSH
50813: LD_VAR 0 7
50817: ARRAY
50818: PPUSH
50819: CALL_OW 247
50823: PUSH
50824: LD_INT 2
50826: EQUAL
50827: IFFALSE 51017
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50829: LD_VAR 0 4
50833: PUSH
50834: LD_VAR 0 7
50838: ARRAY
50839: PPUSH
50840: CALL_OW 256
50844: PUSH
50845: LD_INT 700
50847: LESS
50848: PUSH
50849: LD_VAR 0 4
50853: PUSH
50854: LD_VAR 0 7
50858: ARRAY
50859: PUSH
50860: LD_VAR 0 32
50864: IN
50865: NOT
50866: AND
50867: IFFALSE 50891
// to_repair := to_repair union group [ i ] ;
50869: LD_ADDR_VAR 0 32
50873: PUSH
50874: LD_VAR 0 32
50878: PUSH
50879: LD_VAR 0 4
50883: PUSH
50884: LD_VAR 0 7
50888: ARRAY
50889: UNION
50890: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50891: LD_VAR 0 4
50895: PUSH
50896: LD_VAR 0 7
50900: ARRAY
50901: PPUSH
50902: CALL_OW 256
50906: PUSH
50907: LD_INT 1000
50909: EQUAL
50910: PUSH
50911: LD_VAR 0 4
50915: PUSH
50916: LD_VAR 0 7
50920: ARRAY
50921: PUSH
50922: LD_VAR 0 32
50926: IN
50927: AND
50928: IFFALSE 50952
// to_repair := to_repair diff group [ i ] ;
50930: LD_ADDR_VAR 0 32
50934: PUSH
50935: LD_VAR 0 32
50939: PUSH
50940: LD_VAR 0 4
50944: PUSH
50945: LD_VAR 0 7
50949: ARRAY
50950: DIFF
50951: ST_TO_ADDR
// if group [ i ] in to_repair then
50952: LD_VAR 0 4
50956: PUSH
50957: LD_VAR 0 7
50961: ARRAY
50962: PUSH
50963: LD_VAR 0 32
50967: IN
50968: IFFALSE 51015
// begin if not IsInArea ( group [ i ] , f_repair ) then
50970: LD_VAR 0 4
50974: PUSH
50975: LD_VAR 0 7
50979: ARRAY
50980: PPUSH
50981: LD_VAR 0 22
50985: PPUSH
50986: CALL_OW 308
50990: NOT
50991: IFFALSE 51013
// ComMoveToArea ( group [ i ] , f_repair ) ;
50993: LD_VAR 0 4
50997: PUSH
50998: LD_VAR 0 7
51002: ARRAY
51003: PPUSH
51004: LD_VAR 0 22
51008: PPUSH
51009: CALL_OW 113
// continue ;
51013: GO 50640
// end ; end else
51015: GO 51295
// if group [ i ] in repairs then
51017: LD_VAR 0 4
51021: PUSH
51022: LD_VAR 0 7
51026: ARRAY
51027: PUSH
51028: LD_VAR 0 33
51032: IN
51033: IFFALSE 51295
// begin if IsInUnit ( group [ i ] ) then
51035: LD_VAR 0 4
51039: PUSH
51040: LD_VAR 0 7
51044: ARRAY
51045: PPUSH
51046: CALL_OW 310
51050: IFFALSE 51118
// begin z := IsInUnit ( group [ i ] ) ;
51052: LD_ADDR_VAR 0 13
51056: PUSH
51057: LD_VAR 0 4
51061: PUSH
51062: LD_VAR 0 7
51066: ARRAY
51067: PPUSH
51068: CALL_OW 310
51072: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
51073: LD_VAR 0 13
51077: PUSH
51078: LD_VAR 0 32
51082: IN
51083: PUSH
51084: LD_VAR 0 13
51088: PPUSH
51089: LD_VAR 0 22
51093: PPUSH
51094: CALL_OW 308
51098: AND
51099: IFFALSE 51116
// ComExitVehicle ( group [ i ] ) ;
51101: LD_VAR 0 4
51105: PUSH
51106: LD_VAR 0 7
51110: ARRAY
51111: PPUSH
51112: CALL_OW 121
// end else
51116: GO 51295
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
51118: LD_ADDR_VAR 0 13
51122: PUSH
51123: LD_VAR 0 4
51127: PPUSH
51128: LD_INT 95
51130: PUSH
51131: LD_VAR 0 22
51135: PUSH
51136: EMPTY
51137: LIST
51138: LIST
51139: PUSH
51140: LD_INT 58
51142: PUSH
51143: EMPTY
51144: LIST
51145: PUSH
51146: EMPTY
51147: LIST
51148: LIST
51149: PPUSH
51150: CALL_OW 72
51154: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
51155: LD_VAR 0 4
51159: PUSH
51160: LD_VAR 0 7
51164: ARRAY
51165: PPUSH
51166: CALL_OW 314
51170: NOT
51171: IFFALSE 51293
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
51173: LD_ADDR_VAR 0 10
51177: PUSH
51178: LD_VAR 0 13
51182: PPUSH
51183: LD_VAR 0 4
51187: PUSH
51188: LD_VAR 0 7
51192: ARRAY
51193: PPUSH
51194: CALL_OW 74
51198: ST_TO_ADDR
// if not x then
51199: LD_VAR 0 10
51203: NOT
51204: IFFALSE 51208
// continue ;
51206: GO 50640
// if GetLives ( x ) < 1000 then
51208: LD_VAR 0 10
51212: PPUSH
51213: CALL_OW 256
51217: PUSH
51218: LD_INT 1000
51220: LESS
51221: IFFALSE 51245
// ComRepairVehicle ( group [ i ] , x ) else
51223: LD_VAR 0 4
51227: PUSH
51228: LD_VAR 0 7
51232: ARRAY
51233: PPUSH
51234: LD_VAR 0 10
51238: PPUSH
51239: CALL_OW 129
51243: GO 51293
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
51245: LD_VAR 0 23
51249: PUSH
51250: LD_VAR 0 4
51254: PUSH
51255: LD_VAR 0 7
51259: ARRAY
51260: PPUSH
51261: CALL_OW 256
51265: PUSH
51266: LD_INT 1000
51268: LESS
51269: AND
51270: NOT
51271: IFFALSE 51293
// ComEnterUnit ( group [ i ] , x ) ;
51273: LD_VAR 0 4
51277: PUSH
51278: LD_VAR 0 7
51282: ARRAY
51283: PPUSH
51284: LD_VAR 0 10
51288: PPUSH
51289: CALL_OW 120
// end ; continue ;
51293: GO 50640
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
51295: LD_VAR 0 23
51299: PUSH
51300: LD_VAR 0 4
51304: PUSH
51305: LD_VAR 0 7
51309: ARRAY
51310: PPUSH
51311: CALL_OW 247
51315: PUSH
51316: LD_INT 1
51318: EQUAL
51319: AND
51320: IFFALSE 51798
// begin if group [ i ] in healers then
51322: LD_VAR 0 4
51326: PUSH
51327: LD_VAR 0 7
51331: ARRAY
51332: PUSH
51333: LD_VAR 0 31
51337: IN
51338: IFFALSE 51611
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
51340: LD_VAR 0 4
51344: PUSH
51345: LD_VAR 0 7
51349: ARRAY
51350: PPUSH
51351: LD_VAR 0 23
51355: PPUSH
51356: CALL_OW 308
51360: NOT
51361: PUSH
51362: LD_VAR 0 4
51366: PUSH
51367: LD_VAR 0 7
51371: ARRAY
51372: PPUSH
51373: CALL_OW 314
51377: NOT
51378: AND
51379: IFFALSE 51403
// ComMoveToArea ( group [ i ] , f_heal ) else
51381: LD_VAR 0 4
51385: PUSH
51386: LD_VAR 0 7
51390: ARRAY
51391: PPUSH
51392: LD_VAR 0 23
51396: PPUSH
51397: CALL_OW 113
51401: GO 51609
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
51403: LD_VAR 0 4
51407: PUSH
51408: LD_VAR 0 7
51412: ARRAY
51413: PPUSH
51414: CALL 50021 0 1
51418: PPUSH
51419: CALL_OW 256
51423: PUSH
51424: LD_INT 1000
51426: EQUAL
51427: IFFALSE 51446
// ComStop ( group [ i ] ) else
51429: LD_VAR 0 4
51433: PUSH
51434: LD_VAR 0 7
51438: ARRAY
51439: PPUSH
51440: CALL_OW 141
51444: GO 51609
// if not HasTask ( group [ i ] ) and to_heal then
51446: LD_VAR 0 4
51450: PUSH
51451: LD_VAR 0 7
51455: ARRAY
51456: PPUSH
51457: CALL_OW 314
51461: NOT
51462: PUSH
51463: LD_VAR 0 30
51467: AND
51468: IFFALSE 51609
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
51470: LD_ADDR_VAR 0 13
51474: PUSH
51475: LD_VAR 0 30
51479: PPUSH
51480: LD_INT 3
51482: PUSH
51483: LD_INT 54
51485: PUSH
51486: EMPTY
51487: LIST
51488: PUSH
51489: EMPTY
51490: LIST
51491: LIST
51492: PPUSH
51493: CALL_OW 72
51497: PPUSH
51498: LD_VAR 0 4
51502: PUSH
51503: LD_VAR 0 7
51507: ARRAY
51508: PPUSH
51509: CALL_OW 74
51513: ST_TO_ADDR
// if z then
51514: LD_VAR 0 13
51518: IFFALSE 51609
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
51520: LD_INT 91
51522: PUSH
51523: LD_VAR 0 13
51527: PUSH
51528: LD_INT 10
51530: PUSH
51531: EMPTY
51532: LIST
51533: LIST
51534: LIST
51535: PUSH
51536: LD_INT 81
51538: PUSH
51539: LD_VAR 0 13
51543: PPUSH
51544: CALL_OW 255
51548: PUSH
51549: EMPTY
51550: LIST
51551: LIST
51552: PUSH
51553: EMPTY
51554: LIST
51555: LIST
51556: PPUSH
51557: CALL_OW 69
51561: PUSH
51562: LD_INT 0
51564: EQUAL
51565: IFFALSE 51589
// ComHeal ( group [ i ] , z ) else
51567: LD_VAR 0 4
51571: PUSH
51572: LD_VAR 0 7
51576: ARRAY
51577: PPUSH
51578: LD_VAR 0 13
51582: PPUSH
51583: CALL_OW 128
51587: GO 51609
// ComMoveToArea ( group [ i ] , f_heal ) ;
51589: LD_VAR 0 4
51593: PUSH
51594: LD_VAR 0 7
51598: ARRAY
51599: PPUSH
51600: LD_VAR 0 23
51604: PPUSH
51605: CALL_OW 113
// end ; continue ;
51609: GO 50640
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
51611: LD_VAR 0 4
51615: PUSH
51616: LD_VAR 0 7
51620: ARRAY
51621: PPUSH
51622: CALL_OW 256
51626: PUSH
51627: LD_INT 700
51629: LESS
51630: PUSH
51631: LD_VAR 0 4
51635: PUSH
51636: LD_VAR 0 7
51640: ARRAY
51641: PUSH
51642: LD_VAR 0 30
51646: IN
51647: NOT
51648: AND
51649: IFFALSE 51673
// to_heal := to_heal union group [ i ] ;
51651: LD_ADDR_VAR 0 30
51655: PUSH
51656: LD_VAR 0 30
51660: PUSH
51661: LD_VAR 0 4
51665: PUSH
51666: LD_VAR 0 7
51670: ARRAY
51671: UNION
51672: ST_TO_ADDR
// if group [ i ] in to_heal then
51673: LD_VAR 0 4
51677: PUSH
51678: LD_VAR 0 7
51682: ARRAY
51683: PUSH
51684: LD_VAR 0 30
51688: IN
51689: IFFALSE 51798
// begin if GetLives ( group [ i ] ) = 1000 then
51691: LD_VAR 0 4
51695: PUSH
51696: LD_VAR 0 7
51700: ARRAY
51701: PPUSH
51702: CALL_OW 256
51706: PUSH
51707: LD_INT 1000
51709: EQUAL
51710: IFFALSE 51736
// to_heal := to_heal diff group [ i ] else
51712: LD_ADDR_VAR 0 30
51716: PUSH
51717: LD_VAR 0 30
51721: PUSH
51722: LD_VAR 0 4
51726: PUSH
51727: LD_VAR 0 7
51731: ARRAY
51732: DIFF
51733: ST_TO_ADDR
51734: GO 51798
// begin if not IsInArea ( group [ i ] , to_heal ) then
51736: LD_VAR 0 4
51740: PUSH
51741: LD_VAR 0 7
51745: ARRAY
51746: PPUSH
51747: LD_VAR 0 30
51751: PPUSH
51752: CALL_OW 308
51756: NOT
51757: IFFALSE 51781
// ComMoveToArea ( group [ i ] , f_heal ) else
51759: LD_VAR 0 4
51763: PUSH
51764: LD_VAR 0 7
51768: ARRAY
51769: PPUSH
51770: LD_VAR 0 23
51774: PPUSH
51775: CALL_OW 113
51779: GO 51796
// ComHold ( group [ i ] ) ;
51781: LD_VAR 0 4
51785: PUSH
51786: LD_VAR 0 7
51790: ARRAY
51791: PPUSH
51792: CALL_OW 140
// continue ;
51796: GO 50640
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51798: LD_VAR 0 4
51802: PUSH
51803: LD_VAR 0 7
51807: ARRAY
51808: PPUSH
51809: LD_INT 10
51811: PPUSH
51812: CALL 48441 0 2
51816: NOT
51817: PUSH
51818: LD_VAR 0 16
51822: PUSH
51823: LD_VAR 0 7
51827: ARRAY
51828: PUSH
51829: EMPTY
51830: EQUAL
51831: NOT
51832: AND
51833: IFFALSE 52099
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51835: LD_VAR 0 4
51839: PUSH
51840: LD_VAR 0 7
51844: ARRAY
51845: PPUSH
51846: CALL_OW 262
51850: PUSH
51851: LD_INT 1
51853: PUSH
51854: LD_INT 2
51856: PUSH
51857: EMPTY
51858: LIST
51859: LIST
51860: IN
51861: IFFALSE 51902
// if GetFuel ( group [ i ] ) < 10 then
51863: LD_VAR 0 4
51867: PUSH
51868: LD_VAR 0 7
51872: ARRAY
51873: PPUSH
51874: CALL_OW 261
51878: PUSH
51879: LD_INT 10
51881: LESS
51882: IFFALSE 51902
// SetFuel ( group [ i ] , 12 ) ;
51884: LD_VAR 0 4
51888: PUSH
51889: LD_VAR 0 7
51893: ARRAY
51894: PPUSH
51895: LD_INT 12
51897: PPUSH
51898: CALL_OW 240
// if units_path [ i ] then
51902: LD_VAR 0 16
51906: PUSH
51907: LD_VAR 0 7
51911: ARRAY
51912: IFFALSE 52097
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51914: LD_VAR 0 4
51918: PUSH
51919: LD_VAR 0 7
51923: ARRAY
51924: PPUSH
51925: LD_VAR 0 16
51929: PUSH
51930: LD_VAR 0 7
51934: ARRAY
51935: PUSH
51936: LD_INT 1
51938: ARRAY
51939: PUSH
51940: LD_INT 1
51942: ARRAY
51943: PPUSH
51944: LD_VAR 0 16
51948: PUSH
51949: LD_VAR 0 7
51953: ARRAY
51954: PUSH
51955: LD_INT 1
51957: ARRAY
51958: PUSH
51959: LD_INT 2
51961: ARRAY
51962: PPUSH
51963: CALL_OW 297
51967: PUSH
51968: LD_INT 6
51970: GREATER
51971: IFFALSE 52046
// begin if not HasTask ( group [ i ] ) then
51973: LD_VAR 0 4
51977: PUSH
51978: LD_VAR 0 7
51982: ARRAY
51983: PPUSH
51984: CALL_OW 314
51988: NOT
51989: IFFALSE 52044
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51991: LD_VAR 0 4
51995: PUSH
51996: LD_VAR 0 7
52000: ARRAY
52001: PPUSH
52002: LD_VAR 0 16
52006: PUSH
52007: LD_VAR 0 7
52011: ARRAY
52012: PUSH
52013: LD_INT 1
52015: ARRAY
52016: PUSH
52017: LD_INT 1
52019: ARRAY
52020: PPUSH
52021: LD_VAR 0 16
52025: PUSH
52026: LD_VAR 0 7
52030: ARRAY
52031: PUSH
52032: LD_INT 1
52034: ARRAY
52035: PUSH
52036: LD_INT 2
52038: ARRAY
52039: PPUSH
52040: CALL_OW 114
// end else
52044: GO 52097
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
52046: LD_ADDR_VAR 0 15
52050: PUSH
52051: LD_VAR 0 16
52055: PUSH
52056: LD_VAR 0 7
52060: ARRAY
52061: PPUSH
52062: LD_INT 1
52064: PPUSH
52065: CALL_OW 3
52069: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
52070: LD_ADDR_VAR 0 16
52074: PUSH
52075: LD_VAR 0 16
52079: PPUSH
52080: LD_VAR 0 7
52084: PPUSH
52085: LD_VAR 0 15
52089: PPUSH
52090: CALL_OW 1
52094: ST_TO_ADDR
// continue ;
52095: GO 50640
// end ; end ; end else
52097: GO 54761
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
52099: LD_ADDR_VAR 0 14
52103: PUSH
52104: LD_INT 81
52106: PUSH
52107: LD_VAR 0 4
52111: PUSH
52112: LD_VAR 0 7
52116: ARRAY
52117: PPUSH
52118: CALL_OW 255
52122: PUSH
52123: EMPTY
52124: LIST
52125: LIST
52126: PPUSH
52127: CALL_OW 69
52131: ST_TO_ADDR
// if not tmp then
52132: LD_VAR 0 14
52136: NOT
52137: IFFALSE 52141
// continue ;
52139: GO 50640
// if f_ignore_area then
52141: LD_VAR 0 17
52145: IFFALSE 52233
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
52147: LD_ADDR_VAR 0 15
52151: PUSH
52152: LD_VAR 0 14
52156: PPUSH
52157: LD_INT 3
52159: PUSH
52160: LD_INT 92
52162: PUSH
52163: LD_VAR 0 17
52167: PUSH
52168: LD_INT 1
52170: ARRAY
52171: PUSH
52172: LD_VAR 0 17
52176: PUSH
52177: LD_INT 2
52179: ARRAY
52180: PUSH
52181: LD_VAR 0 17
52185: PUSH
52186: LD_INT 3
52188: ARRAY
52189: PUSH
52190: EMPTY
52191: LIST
52192: LIST
52193: LIST
52194: LIST
52195: PUSH
52196: EMPTY
52197: LIST
52198: LIST
52199: PPUSH
52200: CALL_OW 72
52204: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52205: LD_VAR 0 14
52209: PUSH
52210: LD_VAR 0 15
52214: DIFF
52215: IFFALSE 52233
// tmp := tmp diff tmp2 ;
52217: LD_ADDR_VAR 0 14
52221: PUSH
52222: LD_VAR 0 14
52226: PUSH
52227: LD_VAR 0 15
52231: DIFF
52232: ST_TO_ADDR
// end ; if not f_murder then
52233: LD_VAR 0 20
52237: NOT
52238: IFFALSE 52296
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
52240: LD_ADDR_VAR 0 15
52244: PUSH
52245: LD_VAR 0 14
52249: PPUSH
52250: LD_INT 3
52252: PUSH
52253: LD_INT 50
52255: PUSH
52256: EMPTY
52257: LIST
52258: PUSH
52259: EMPTY
52260: LIST
52261: LIST
52262: PPUSH
52263: CALL_OW 72
52267: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52268: LD_VAR 0 14
52272: PUSH
52273: LD_VAR 0 15
52277: DIFF
52278: IFFALSE 52296
// tmp := tmp diff tmp2 ;
52280: LD_ADDR_VAR 0 14
52284: PUSH
52285: LD_VAR 0 14
52289: PUSH
52290: LD_VAR 0 15
52294: DIFF
52295: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
52296: LD_ADDR_VAR 0 14
52300: PUSH
52301: LD_VAR 0 4
52305: PUSH
52306: LD_VAR 0 7
52310: ARRAY
52311: PPUSH
52312: LD_VAR 0 14
52316: PPUSH
52317: LD_INT 1
52319: PPUSH
52320: LD_INT 1
52322: PPUSH
52323: CALL 22084 0 4
52327: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
52328: LD_VAR 0 4
52332: PUSH
52333: LD_VAR 0 7
52337: ARRAY
52338: PPUSH
52339: CALL_OW 257
52343: PUSH
52344: LD_INT 1
52346: EQUAL
52347: IFFALSE 52795
// begin if WantPlant ( group [ i ] ) then
52349: LD_VAR 0 4
52353: PUSH
52354: LD_VAR 0 7
52358: ARRAY
52359: PPUSH
52360: CALL 21585 0 1
52364: IFFALSE 52368
// continue ;
52366: GO 50640
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
52368: LD_VAR 0 18
52372: PUSH
52373: LD_VAR 0 4
52377: PUSH
52378: LD_VAR 0 7
52382: ARRAY
52383: PPUSH
52384: CALL_OW 310
52388: NOT
52389: AND
52390: PUSH
52391: LD_VAR 0 14
52395: PUSH
52396: LD_INT 1
52398: ARRAY
52399: PUSH
52400: LD_VAR 0 14
52404: PPUSH
52405: LD_INT 21
52407: PUSH
52408: LD_INT 2
52410: PUSH
52411: EMPTY
52412: LIST
52413: LIST
52414: PUSH
52415: LD_INT 58
52417: PUSH
52418: EMPTY
52419: LIST
52420: PUSH
52421: EMPTY
52422: LIST
52423: LIST
52424: PPUSH
52425: CALL_OW 72
52429: IN
52430: AND
52431: IFFALSE 52467
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
52433: LD_VAR 0 4
52437: PUSH
52438: LD_VAR 0 7
52442: ARRAY
52443: PPUSH
52444: LD_VAR 0 14
52448: PUSH
52449: LD_INT 1
52451: ARRAY
52452: PPUSH
52453: CALL_OW 120
// attacking := true ;
52457: LD_ADDR_VAR 0 29
52461: PUSH
52462: LD_INT 1
52464: ST_TO_ADDR
// continue ;
52465: GO 50640
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
52467: LD_VAR 0 26
52471: PUSH
52472: LD_VAR 0 4
52476: PUSH
52477: LD_VAR 0 7
52481: ARRAY
52482: PPUSH
52483: CALL_OW 257
52487: PUSH
52488: LD_INT 1
52490: EQUAL
52491: AND
52492: PUSH
52493: LD_VAR 0 4
52497: PUSH
52498: LD_VAR 0 7
52502: ARRAY
52503: PPUSH
52504: CALL_OW 256
52508: PUSH
52509: LD_INT 800
52511: LESS
52512: AND
52513: PUSH
52514: LD_VAR 0 4
52518: PUSH
52519: LD_VAR 0 7
52523: ARRAY
52524: PPUSH
52525: CALL_OW 318
52529: NOT
52530: AND
52531: IFFALSE 52548
// ComCrawl ( group [ i ] ) ;
52533: LD_VAR 0 4
52537: PUSH
52538: LD_VAR 0 7
52542: ARRAY
52543: PPUSH
52544: CALL_OW 137
// if f_mines then
52548: LD_VAR 0 21
52552: IFFALSE 52795
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
52554: LD_VAR 0 14
52558: PUSH
52559: LD_INT 1
52561: ARRAY
52562: PPUSH
52563: CALL_OW 247
52567: PUSH
52568: LD_INT 3
52570: EQUAL
52571: PUSH
52572: LD_VAR 0 14
52576: PUSH
52577: LD_INT 1
52579: ARRAY
52580: PUSH
52581: LD_VAR 0 27
52585: IN
52586: NOT
52587: AND
52588: IFFALSE 52795
// begin x := GetX ( tmp [ 1 ] ) ;
52590: LD_ADDR_VAR 0 10
52594: PUSH
52595: LD_VAR 0 14
52599: PUSH
52600: LD_INT 1
52602: ARRAY
52603: PPUSH
52604: CALL_OW 250
52608: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
52609: LD_ADDR_VAR 0 11
52613: PUSH
52614: LD_VAR 0 14
52618: PUSH
52619: LD_INT 1
52621: ARRAY
52622: PPUSH
52623: CALL_OW 251
52627: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
52628: LD_ADDR_VAR 0 12
52632: PUSH
52633: LD_VAR 0 4
52637: PUSH
52638: LD_VAR 0 7
52642: ARRAY
52643: PPUSH
52644: CALL 48526 0 1
52648: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
52649: LD_VAR 0 4
52653: PUSH
52654: LD_VAR 0 7
52658: ARRAY
52659: PPUSH
52660: LD_VAR 0 10
52664: PPUSH
52665: LD_VAR 0 11
52669: PPUSH
52670: LD_VAR 0 14
52674: PUSH
52675: LD_INT 1
52677: ARRAY
52678: PPUSH
52679: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
52683: LD_VAR 0 4
52687: PUSH
52688: LD_VAR 0 7
52692: ARRAY
52693: PPUSH
52694: LD_VAR 0 10
52698: PPUSH
52699: LD_VAR 0 12
52703: PPUSH
52704: LD_INT 7
52706: PPUSH
52707: CALL_OW 272
52711: PPUSH
52712: LD_VAR 0 11
52716: PPUSH
52717: LD_VAR 0 12
52721: PPUSH
52722: LD_INT 7
52724: PPUSH
52725: CALL_OW 273
52729: PPUSH
52730: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
52734: LD_VAR 0 4
52738: PUSH
52739: LD_VAR 0 7
52743: ARRAY
52744: PPUSH
52745: LD_INT 71
52747: PPUSH
52748: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
52752: LD_ADDR_VAR 0 27
52756: PUSH
52757: LD_VAR 0 27
52761: PPUSH
52762: LD_VAR 0 27
52766: PUSH
52767: LD_INT 1
52769: PLUS
52770: PPUSH
52771: LD_VAR 0 14
52775: PUSH
52776: LD_INT 1
52778: ARRAY
52779: PPUSH
52780: CALL_OW 1
52784: ST_TO_ADDR
// attacking := true ;
52785: LD_ADDR_VAR 0 29
52789: PUSH
52790: LD_INT 1
52792: ST_TO_ADDR
// continue ;
52793: GO 50640
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52795: LD_VAR 0 4
52799: PUSH
52800: LD_VAR 0 7
52804: ARRAY
52805: PPUSH
52806: CALL_OW 257
52810: PUSH
52811: LD_INT 17
52813: EQUAL
52814: PUSH
52815: LD_VAR 0 4
52819: PUSH
52820: LD_VAR 0 7
52824: ARRAY
52825: PPUSH
52826: CALL_OW 110
52830: PUSH
52831: LD_INT 71
52833: EQUAL
52834: NOT
52835: AND
52836: IFFALSE 52982
// begin attacking := false ;
52838: LD_ADDR_VAR 0 29
52842: PUSH
52843: LD_INT 0
52845: ST_TO_ADDR
// k := 5 ;
52846: LD_ADDR_VAR 0 9
52850: PUSH
52851: LD_INT 5
52853: ST_TO_ADDR
// if tmp < k then
52854: LD_VAR 0 14
52858: PUSH
52859: LD_VAR 0 9
52863: LESS
52864: IFFALSE 52876
// k := tmp ;
52866: LD_ADDR_VAR 0 9
52870: PUSH
52871: LD_VAR 0 14
52875: ST_TO_ADDR
// for j = 1 to k do
52876: LD_ADDR_VAR 0 8
52880: PUSH
52881: DOUBLE
52882: LD_INT 1
52884: DEC
52885: ST_TO_ADDR
52886: LD_VAR 0 9
52890: PUSH
52891: FOR_TO
52892: IFFALSE 52980
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52894: LD_VAR 0 14
52898: PUSH
52899: LD_VAR 0 8
52903: ARRAY
52904: PUSH
52905: LD_VAR 0 14
52909: PPUSH
52910: LD_INT 58
52912: PUSH
52913: EMPTY
52914: LIST
52915: PPUSH
52916: CALL_OW 72
52920: IN
52921: NOT
52922: IFFALSE 52978
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52924: LD_VAR 0 4
52928: PUSH
52929: LD_VAR 0 7
52933: ARRAY
52934: PPUSH
52935: LD_VAR 0 14
52939: PUSH
52940: LD_VAR 0 8
52944: ARRAY
52945: PPUSH
52946: CALL_OW 115
// attacking := true ;
52950: LD_ADDR_VAR 0 29
52954: PUSH
52955: LD_INT 1
52957: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52958: LD_VAR 0 4
52962: PUSH
52963: LD_VAR 0 7
52967: ARRAY
52968: PPUSH
52969: LD_INT 71
52971: PPUSH
52972: CALL_OW 109
// continue ;
52976: GO 52891
// end ; end ;
52978: GO 52891
52980: POP
52981: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52982: LD_VAR 0 4
52986: PUSH
52987: LD_VAR 0 7
52991: ARRAY
52992: PPUSH
52993: CALL_OW 257
52997: PUSH
52998: LD_INT 8
53000: EQUAL
53001: PUSH
53002: LD_VAR 0 4
53006: PUSH
53007: LD_VAR 0 7
53011: ARRAY
53012: PPUSH
53013: CALL_OW 264
53017: PUSH
53018: LD_INT 28
53020: PUSH
53021: LD_INT 45
53023: PUSH
53024: LD_INT 7
53026: PUSH
53027: LD_INT 47
53029: PUSH
53030: EMPTY
53031: LIST
53032: LIST
53033: LIST
53034: LIST
53035: IN
53036: OR
53037: IFFALSE 53293
// begin attacking := false ;
53039: LD_ADDR_VAR 0 29
53043: PUSH
53044: LD_INT 0
53046: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
53047: LD_VAR 0 14
53051: PUSH
53052: LD_INT 1
53054: ARRAY
53055: PPUSH
53056: CALL_OW 266
53060: PUSH
53061: LD_INT 32
53063: PUSH
53064: LD_INT 31
53066: PUSH
53067: LD_INT 33
53069: PUSH
53070: LD_INT 4
53072: PUSH
53073: LD_INT 5
53075: PUSH
53076: EMPTY
53077: LIST
53078: LIST
53079: LIST
53080: LIST
53081: LIST
53082: IN
53083: IFFALSE 53269
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
53085: LD_ADDR_VAR 0 9
53089: PUSH
53090: LD_VAR 0 14
53094: PUSH
53095: LD_INT 1
53097: ARRAY
53098: PPUSH
53099: CALL_OW 266
53103: PPUSH
53104: LD_VAR 0 14
53108: PUSH
53109: LD_INT 1
53111: ARRAY
53112: PPUSH
53113: CALL_OW 250
53117: PPUSH
53118: LD_VAR 0 14
53122: PUSH
53123: LD_INT 1
53125: ARRAY
53126: PPUSH
53127: CALL_OW 251
53131: PPUSH
53132: LD_VAR 0 14
53136: PUSH
53137: LD_INT 1
53139: ARRAY
53140: PPUSH
53141: CALL_OW 254
53145: PPUSH
53146: LD_VAR 0 14
53150: PUSH
53151: LD_INT 1
53153: ARRAY
53154: PPUSH
53155: CALL_OW 248
53159: PPUSH
53160: LD_INT 0
53162: PPUSH
53163: CALL 29896 0 6
53167: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
53168: LD_ADDR_VAR 0 8
53172: PUSH
53173: LD_VAR 0 4
53177: PUSH
53178: LD_VAR 0 7
53182: ARRAY
53183: PPUSH
53184: LD_VAR 0 9
53188: PPUSH
53189: CALL 48566 0 2
53193: ST_TO_ADDR
// if j then
53194: LD_VAR 0 8
53198: IFFALSE 53267
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
53200: LD_VAR 0 8
53204: PUSH
53205: LD_INT 1
53207: ARRAY
53208: PPUSH
53209: LD_VAR 0 8
53213: PUSH
53214: LD_INT 2
53216: ARRAY
53217: PPUSH
53218: CALL_OW 488
53222: IFFALSE 53267
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
53224: LD_VAR 0 4
53228: PUSH
53229: LD_VAR 0 7
53233: ARRAY
53234: PPUSH
53235: LD_VAR 0 8
53239: PUSH
53240: LD_INT 1
53242: ARRAY
53243: PPUSH
53244: LD_VAR 0 8
53248: PUSH
53249: LD_INT 2
53251: ARRAY
53252: PPUSH
53253: CALL_OW 116
// attacking := true ;
53257: LD_ADDR_VAR 0 29
53261: PUSH
53262: LD_INT 1
53264: ST_TO_ADDR
// continue ;
53265: GO 50640
// end ; end else
53267: GO 53293
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53269: LD_VAR 0 4
53273: PUSH
53274: LD_VAR 0 7
53278: ARRAY
53279: PPUSH
53280: LD_VAR 0 14
53284: PUSH
53285: LD_INT 1
53287: ARRAY
53288: PPUSH
53289: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
53293: LD_VAR 0 4
53297: PUSH
53298: LD_VAR 0 7
53302: ARRAY
53303: PPUSH
53304: CALL_OW 265
53308: PUSH
53309: LD_INT 11
53311: EQUAL
53312: IFFALSE 53590
// begin k := 10 ;
53314: LD_ADDR_VAR 0 9
53318: PUSH
53319: LD_INT 10
53321: ST_TO_ADDR
// x := 0 ;
53322: LD_ADDR_VAR 0 10
53326: PUSH
53327: LD_INT 0
53329: ST_TO_ADDR
// if tmp < k then
53330: LD_VAR 0 14
53334: PUSH
53335: LD_VAR 0 9
53339: LESS
53340: IFFALSE 53352
// k := tmp ;
53342: LD_ADDR_VAR 0 9
53346: PUSH
53347: LD_VAR 0 14
53351: ST_TO_ADDR
// for j = k downto 1 do
53352: LD_ADDR_VAR 0 8
53356: PUSH
53357: DOUBLE
53358: LD_VAR 0 9
53362: INC
53363: ST_TO_ADDR
53364: LD_INT 1
53366: PUSH
53367: FOR_DOWNTO
53368: IFFALSE 53443
// begin if GetType ( tmp [ j ] ) = unit_human then
53370: LD_VAR 0 14
53374: PUSH
53375: LD_VAR 0 8
53379: ARRAY
53380: PPUSH
53381: CALL_OW 247
53385: PUSH
53386: LD_INT 1
53388: EQUAL
53389: IFFALSE 53441
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
53391: LD_VAR 0 4
53395: PUSH
53396: LD_VAR 0 7
53400: ARRAY
53401: PPUSH
53402: LD_VAR 0 14
53406: PUSH
53407: LD_VAR 0 8
53411: ARRAY
53412: PPUSH
53413: CALL 48837 0 2
// x := tmp [ j ] ;
53417: LD_ADDR_VAR 0 10
53421: PUSH
53422: LD_VAR 0 14
53426: PUSH
53427: LD_VAR 0 8
53431: ARRAY
53432: ST_TO_ADDR
// attacking := true ;
53433: LD_ADDR_VAR 0 29
53437: PUSH
53438: LD_INT 1
53440: ST_TO_ADDR
// end ; end ;
53441: GO 53367
53443: POP
53444: POP
// if not x then
53445: LD_VAR 0 10
53449: NOT
53450: IFFALSE 53590
// begin attacking := true ;
53452: LD_ADDR_VAR 0 29
53456: PUSH
53457: LD_INT 1
53459: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
53460: LD_VAR 0 4
53464: PUSH
53465: LD_VAR 0 7
53469: ARRAY
53470: PPUSH
53471: CALL_OW 250
53475: PPUSH
53476: LD_VAR 0 4
53480: PUSH
53481: LD_VAR 0 7
53485: ARRAY
53486: PPUSH
53487: CALL_OW 251
53491: PPUSH
53492: CALL_OW 546
53496: PUSH
53497: LD_INT 2
53499: ARRAY
53500: PUSH
53501: LD_VAR 0 14
53505: PUSH
53506: LD_INT 1
53508: ARRAY
53509: PPUSH
53510: CALL_OW 250
53514: PPUSH
53515: LD_VAR 0 14
53519: PUSH
53520: LD_INT 1
53522: ARRAY
53523: PPUSH
53524: CALL_OW 251
53528: PPUSH
53529: CALL_OW 546
53533: PUSH
53534: LD_INT 2
53536: ARRAY
53537: EQUAL
53538: IFFALSE 53566
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
53540: LD_VAR 0 4
53544: PUSH
53545: LD_VAR 0 7
53549: ARRAY
53550: PPUSH
53551: LD_VAR 0 14
53555: PUSH
53556: LD_INT 1
53558: ARRAY
53559: PPUSH
53560: CALL 48837 0 2
53564: GO 53590
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53566: LD_VAR 0 4
53570: PUSH
53571: LD_VAR 0 7
53575: ARRAY
53576: PPUSH
53577: LD_VAR 0 14
53581: PUSH
53582: LD_INT 1
53584: ARRAY
53585: PPUSH
53586: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
53590: LD_VAR 0 4
53594: PUSH
53595: LD_VAR 0 7
53599: ARRAY
53600: PPUSH
53601: CALL_OW 264
53605: PUSH
53606: LD_INT 29
53608: EQUAL
53609: IFFALSE 53975
// begin if WantsToAttack ( group [ i ] ) in bombed then
53611: LD_VAR 0 4
53615: PUSH
53616: LD_VAR 0 7
53620: ARRAY
53621: PPUSH
53622: CALL_OW 319
53626: PUSH
53627: LD_VAR 0 28
53631: IN
53632: IFFALSE 53636
// continue ;
53634: GO 50640
// k := 8 ;
53636: LD_ADDR_VAR 0 9
53640: PUSH
53641: LD_INT 8
53643: ST_TO_ADDR
// x := 0 ;
53644: LD_ADDR_VAR 0 10
53648: PUSH
53649: LD_INT 0
53651: ST_TO_ADDR
// if tmp < k then
53652: LD_VAR 0 14
53656: PUSH
53657: LD_VAR 0 9
53661: LESS
53662: IFFALSE 53674
// k := tmp ;
53664: LD_ADDR_VAR 0 9
53668: PUSH
53669: LD_VAR 0 14
53673: ST_TO_ADDR
// for j = 1 to k do
53674: LD_ADDR_VAR 0 8
53678: PUSH
53679: DOUBLE
53680: LD_INT 1
53682: DEC
53683: ST_TO_ADDR
53684: LD_VAR 0 9
53688: PUSH
53689: FOR_TO
53690: IFFALSE 53822
// begin if GetType ( tmp [ j ] ) = unit_building then
53692: LD_VAR 0 14
53696: PUSH
53697: LD_VAR 0 8
53701: ARRAY
53702: PPUSH
53703: CALL_OW 247
53707: PUSH
53708: LD_INT 3
53710: EQUAL
53711: IFFALSE 53820
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
53713: LD_VAR 0 14
53717: PUSH
53718: LD_VAR 0 8
53722: ARRAY
53723: PUSH
53724: LD_VAR 0 28
53728: IN
53729: NOT
53730: PUSH
53731: LD_VAR 0 14
53735: PUSH
53736: LD_VAR 0 8
53740: ARRAY
53741: PPUSH
53742: CALL_OW 313
53746: AND
53747: IFFALSE 53820
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53749: LD_VAR 0 4
53753: PUSH
53754: LD_VAR 0 7
53758: ARRAY
53759: PPUSH
53760: LD_VAR 0 14
53764: PUSH
53765: LD_VAR 0 8
53769: ARRAY
53770: PPUSH
53771: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
53775: LD_ADDR_VAR 0 28
53779: PUSH
53780: LD_VAR 0 28
53784: PPUSH
53785: LD_VAR 0 28
53789: PUSH
53790: LD_INT 1
53792: PLUS
53793: PPUSH
53794: LD_VAR 0 14
53798: PUSH
53799: LD_VAR 0 8
53803: ARRAY
53804: PPUSH
53805: CALL_OW 1
53809: ST_TO_ADDR
// attacking := true ;
53810: LD_ADDR_VAR 0 29
53814: PUSH
53815: LD_INT 1
53817: ST_TO_ADDR
// break ;
53818: GO 53822
// end ; end ;
53820: GO 53689
53822: POP
53823: POP
// if not attacking and f_attack_depot then
53824: LD_VAR 0 29
53828: NOT
53829: PUSH
53830: LD_VAR 0 25
53834: AND
53835: IFFALSE 53930
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53837: LD_ADDR_VAR 0 13
53841: PUSH
53842: LD_VAR 0 14
53846: PPUSH
53847: LD_INT 2
53849: PUSH
53850: LD_INT 30
53852: PUSH
53853: LD_INT 0
53855: PUSH
53856: EMPTY
53857: LIST
53858: LIST
53859: PUSH
53860: LD_INT 30
53862: PUSH
53863: LD_INT 1
53865: PUSH
53866: EMPTY
53867: LIST
53868: LIST
53869: PUSH
53870: EMPTY
53871: LIST
53872: LIST
53873: LIST
53874: PPUSH
53875: CALL_OW 72
53879: ST_TO_ADDR
// if z then
53880: LD_VAR 0 13
53884: IFFALSE 53930
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53886: LD_VAR 0 4
53890: PUSH
53891: LD_VAR 0 7
53895: ARRAY
53896: PPUSH
53897: LD_VAR 0 13
53901: PPUSH
53902: LD_VAR 0 4
53906: PUSH
53907: LD_VAR 0 7
53911: ARRAY
53912: PPUSH
53913: CALL_OW 74
53917: PPUSH
53918: CALL_OW 115
// attacking := true ;
53922: LD_ADDR_VAR 0 29
53926: PUSH
53927: LD_INT 1
53929: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53930: LD_VAR 0 4
53934: PUSH
53935: LD_VAR 0 7
53939: ARRAY
53940: PPUSH
53941: CALL_OW 256
53945: PUSH
53946: LD_INT 500
53948: LESS
53949: IFFALSE 53975
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53951: LD_VAR 0 4
53955: PUSH
53956: LD_VAR 0 7
53960: ARRAY
53961: PPUSH
53962: LD_VAR 0 14
53966: PUSH
53967: LD_INT 1
53969: ARRAY
53970: PPUSH
53971: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53975: LD_VAR 0 4
53979: PUSH
53980: LD_VAR 0 7
53984: ARRAY
53985: PPUSH
53986: CALL_OW 264
53990: PUSH
53991: LD_INT 49
53993: EQUAL
53994: IFFALSE 54115
// begin if not HasTask ( group [ i ] ) then
53996: LD_VAR 0 4
54000: PUSH
54001: LD_VAR 0 7
54005: ARRAY
54006: PPUSH
54007: CALL_OW 314
54011: NOT
54012: IFFALSE 54115
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
54014: LD_ADDR_VAR 0 9
54018: PUSH
54019: LD_INT 81
54021: PUSH
54022: LD_VAR 0 4
54026: PUSH
54027: LD_VAR 0 7
54031: ARRAY
54032: PPUSH
54033: CALL_OW 255
54037: PUSH
54038: EMPTY
54039: LIST
54040: LIST
54041: PPUSH
54042: CALL_OW 69
54046: PPUSH
54047: LD_VAR 0 4
54051: PUSH
54052: LD_VAR 0 7
54056: ARRAY
54057: PPUSH
54058: CALL_OW 74
54062: ST_TO_ADDR
// if k then
54063: LD_VAR 0 9
54067: IFFALSE 54115
// if GetDistUnits ( group [ i ] , k ) > 10 then
54069: LD_VAR 0 4
54073: PUSH
54074: LD_VAR 0 7
54078: ARRAY
54079: PPUSH
54080: LD_VAR 0 9
54084: PPUSH
54085: CALL_OW 296
54089: PUSH
54090: LD_INT 10
54092: GREATER
54093: IFFALSE 54115
// ComMoveUnit ( group [ i ] , k ) ;
54095: LD_VAR 0 4
54099: PUSH
54100: LD_VAR 0 7
54104: ARRAY
54105: PPUSH
54106: LD_VAR 0 9
54110: PPUSH
54111: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
54115: LD_VAR 0 4
54119: PUSH
54120: LD_VAR 0 7
54124: ARRAY
54125: PPUSH
54126: CALL_OW 256
54130: PUSH
54131: LD_INT 250
54133: LESS
54134: PUSH
54135: LD_VAR 0 4
54139: PUSH
54140: LD_VAR 0 7
54144: ARRAY
54145: PUSH
54146: LD_INT 21
54148: PUSH
54149: LD_INT 2
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: PUSH
54156: LD_INT 23
54158: PUSH
54159: LD_INT 2
54161: PUSH
54162: EMPTY
54163: LIST
54164: LIST
54165: PUSH
54166: EMPTY
54167: LIST
54168: LIST
54169: PPUSH
54170: CALL_OW 69
54174: IN
54175: AND
54176: IFFALSE 54301
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
54178: LD_ADDR_VAR 0 9
54182: PUSH
54183: LD_OWVAR 3
54187: PUSH
54188: LD_VAR 0 4
54192: PUSH
54193: LD_VAR 0 7
54197: ARRAY
54198: DIFF
54199: PPUSH
54200: LD_VAR 0 4
54204: PUSH
54205: LD_VAR 0 7
54209: ARRAY
54210: PPUSH
54211: CALL_OW 74
54215: ST_TO_ADDR
// if not k then
54216: LD_VAR 0 9
54220: NOT
54221: IFFALSE 54225
// continue ;
54223: GO 50640
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
54225: LD_VAR 0 9
54229: PUSH
54230: LD_INT 81
54232: PUSH
54233: LD_VAR 0 4
54237: PUSH
54238: LD_VAR 0 7
54242: ARRAY
54243: PPUSH
54244: CALL_OW 255
54248: PUSH
54249: EMPTY
54250: LIST
54251: LIST
54252: PPUSH
54253: CALL_OW 69
54257: IN
54258: PUSH
54259: LD_VAR 0 9
54263: PPUSH
54264: LD_VAR 0 4
54268: PUSH
54269: LD_VAR 0 7
54273: ARRAY
54274: PPUSH
54275: CALL_OW 296
54279: PUSH
54280: LD_INT 5
54282: LESS
54283: AND
54284: IFFALSE 54301
// ComAutodestruct ( group [ i ] ) ;
54286: LD_VAR 0 4
54290: PUSH
54291: LD_VAR 0 7
54295: ARRAY
54296: PPUSH
54297: CALL 48735 0 1
// end ; if f_attack_depot then
54301: LD_VAR 0 25
54305: IFFALSE 54417
// begin k := 6 ;
54307: LD_ADDR_VAR 0 9
54311: PUSH
54312: LD_INT 6
54314: ST_TO_ADDR
// if tmp < k then
54315: LD_VAR 0 14
54319: PUSH
54320: LD_VAR 0 9
54324: LESS
54325: IFFALSE 54337
// k := tmp ;
54327: LD_ADDR_VAR 0 9
54331: PUSH
54332: LD_VAR 0 14
54336: ST_TO_ADDR
// for j = 1 to k do
54337: LD_ADDR_VAR 0 8
54341: PUSH
54342: DOUBLE
54343: LD_INT 1
54345: DEC
54346: ST_TO_ADDR
54347: LD_VAR 0 9
54351: PUSH
54352: FOR_TO
54353: IFFALSE 54415
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
54355: LD_VAR 0 8
54359: PPUSH
54360: CALL_OW 266
54364: PUSH
54365: LD_INT 0
54367: PUSH
54368: LD_INT 1
54370: PUSH
54371: EMPTY
54372: LIST
54373: LIST
54374: IN
54375: IFFALSE 54413
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
54377: LD_VAR 0 4
54381: PUSH
54382: LD_VAR 0 7
54386: ARRAY
54387: PPUSH
54388: LD_VAR 0 14
54392: PUSH
54393: LD_VAR 0 8
54397: ARRAY
54398: PPUSH
54399: CALL_OW 115
// attacking := true ;
54403: LD_ADDR_VAR 0 29
54407: PUSH
54408: LD_INT 1
54410: ST_TO_ADDR
// break ;
54411: GO 54415
// end ;
54413: GO 54352
54415: POP
54416: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
54417: LD_VAR 0 4
54421: PUSH
54422: LD_VAR 0 7
54426: ARRAY
54427: PPUSH
54428: CALL_OW 302
54432: PUSH
54433: LD_VAR 0 29
54437: NOT
54438: AND
54439: IFFALSE 54761
// begin if GetTag ( group [ i ] ) = 71 then
54441: LD_VAR 0 4
54445: PUSH
54446: LD_VAR 0 7
54450: ARRAY
54451: PPUSH
54452: CALL_OW 110
54456: PUSH
54457: LD_INT 71
54459: EQUAL
54460: IFFALSE 54501
// begin if HasTask ( group [ i ] ) then
54462: LD_VAR 0 4
54466: PUSH
54467: LD_VAR 0 7
54471: ARRAY
54472: PPUSH
54473: CALL_OW 314
54477: IFFALSE 54483
// continue else
54479: GO 50640
54481: GO 54501
// SetTag ( group [ i ] , 0 ) ;
54483: LD_VAR 0 4
54487: PUSH
54488: LD_VAR 0 7
54492: ARRAY
54493: PPUSH
54494: LD_INT 0
54496: PPUSH
54497: CALL_OW 109
// end ; k := 8 ;
54501: LD_ADDR_VAR 0 9
54505: PUSH
54506: LD_INT 8
54508: ST_TO_ADDR
// x := 0 ;
54509: LD_ADDR_VAR 0 10
54513: PUSH
54514: LD_INT 0
54516: ST_TO_ADDR
// if tmp < k then
54517: LD_VAR 0 14
54521: PUSH
54522: LD_VAR 0 9
54526: LESS
54527: IFFALSE 54539
// k := tmp ;
54529: LD_ADDR_VAR 0 9
54533: PUSH
54534: LD_VAR 0 14
54538: ST_TO_ADDR
// for j = 1 to k do
54539: LD_ADDR_VAR 0 8
54543: PUSH
54544: DOUBLE
54545: LD_INT 1
54547: DEC
54548: ST_TO_ADDR
54549: LD_VAR 0 9
54553: PUSH
54554: FOR_TO
54555: IFFALSE 54653
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
54557: LD_VAR 0 14
54561: PUSH
54562: LD_VAR 0 8
54566: ARRAY
54567: PPUSH
54568: CALL_OW 247
54572: PUSH
54573: LD_INT 1
54575: EQUAL
54576: PUSH
54577: LD_VAR 0 14
54581: PUSH
54582: LD_VAR 0 8
54586: ARRAY
54587: PPUSH
54588: CALL_OW 256
54592: PUSH
54593: LD_INT 250
54595: LESS
54596: PUSH
54597: LD_VAR 0 20
54601: AND
54602: PUSH
54603: LD_VAR 0 20
54607: NOT
54608: PUSH
54609: LD_VAR 0 14
54613: PUSH
54614: LD_VAR 0 8
54618: ARRAY
54619: PPUSH
54620: CALL_OW 256
54624: PUSH
54625: LD_INT 250
54627: GREATEREQUAL
54628: AND
54629: OR
54630: AND
54631: IFFALSE 54651
// begin x := tmp [ j ] ;
54633: LD_ADDR_VAR 0 10
54637: PUSH
54638: LD_VAR 0 14
54642: PUSH
54643: LD_VAR 0 8
54647: ARRAY
54648: ST_TO_ADDR
// break ;
54649: GO 54653
// end ;
54651: GO 54554
54653: POP
54654: POP
// if x then
54655: LD_VAR 0 10
54659: IFFALSE 54683
// ComAttackUnit ( group [ i ] , x ) else
54661: LD_VAR 0 4
54665: PUSH
54666: LD_VAR 0 7
54670: ARRAY
54671: PPUSH
54672: LD_VAR 0 10
54676: PPUSH
54677: CALL_OW 115
54681: GO 54707
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
54683: LD_VAR 0 4
54687: PUSH
54688: LD_VAR 0 7
54692: ARRAY
54693: PPUSH
54694: LD_VAR 0 14
54698: PUSH
54699: LD_INT 1
54701: ARRAY
54702: PPUSH
54703: CALL_OW 115
// if not HasTask ( group [ i ] ) then
54707: LD_VAR 0 4
54711: PUSH
54712: LD_VAR 0 7
54716: ARRAY
54717: PPUSH
54718: CALL_OW 314
54722: NOT
54723: IFFALSE 54761
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
54725: LD_VAR 0 4
54729: PUSH
54730: LD_VAR 0 7
54734: ARRAY
54735: PPUSH
54736: LD_VAR 0 14
54740: PPUSH
54741: LD_VAR 0 4
54745: PUSH
54746: LD_VAR 0 7
54750: ARRAY
54751: PPUSH
54752: CALL_OW 74
54756: PPUSH
54757: CALL_OW 115
// end ; end ; end ;
54761: GO 50640
54763: POP
54764: POP
// wait ( 0 0$2 ) ;
54765: LD_INT 70
54767: PPUSH
54768: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
54772: LD_VAR 0 4
54776: NOT
54777: PUSH
54778: LD_VAR 0 4
54782: PUSH
54783: EMPTY
54784: EQUAL
54785: OR
54786: PUSH
54787: LD_INT 81
54789: PUSH
54790: LD_VAR 0 35
54794: PUSH
54795: EMPTY
54796: LIST
54797: LIST
54798: PPUSH
54799: CALL_OW 69
54803: NOT
54804: OR
54805: IFFALSE 50625
// end ;
54807: LD_VAR 0 2
54811: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54812: LD_INT 0
54814: PPUSH
54815: PPUSH
54816: PPUSH
54817: PPUSH
// if not base_units then
54818: LD_VAR 0 1
54822: NOT
54823: IFFALSE 54827
// exit ;
54825: GO 54914
// result := false ;
54827: LD_ADDR_VAR 0 2
54831: PUSH
54832: LD_INT 0
54834: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54835: LD_ADDR_VAR 0 5
54839: PUSH
54840: LD_VAR 0 1
54844: PPUSH
54845: LD_INT 21
54847: PUSH
54848: LD_INT 3
54850: PUSH
54851: EMPTY
54852: LIST
54853: LIST
54854: PPUSH
54855: CALL_OW 72
54859: ST_TO_ADDR
// if not tmp then
54860: LD_VAR 0 5
54864: NOT
54865: IFFALSE 54869
// exit ;
54867: GO 54914
// for i in tmp do
54869: LD_ADDR_VAR 0 3
54873: PUSH
54874: LD_VAR 0 5
54878: PUSH
54879: FOR_IN
54880: IFFALSE 54912
// begin result := EnemyInRange ( i , 22 ) ;
54882: LD_ADDR_VAR 0 2
54886: PUSH
54887: LD_VAR 0 3
54891: PPUSH
54892: LD_INT 22
54894: PPUSH
54895: CALL 48441 0 2
54899: ST_TO_ADDR
// if result then
54900: LD_VAR 0 2
54904: IFFALSE 54910
// exit ;
54906: POP
54907: POP
54908: GO 54914
// end ;
54910: GO 54879
54912: POP
54913: POP
// end ;
54914: LD_VAR 0 2
54918: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54919: LD_INT 0
54921: PPUSH
54922: PPUSH
// if not units then
54923: LD_VAR 0 1
54927: NOT
54928: IFFALSE 54932
// exit ;
54930: GO 55002
// result := [ ] ;
54932: LD_ADDR_VAR 0 3
54936: PUSH
54937: EMPTY
54938: ST_TO_ADDR
// for i in units do
54939: LD_ADDR_VAR 0 4
54943: PUSH
54944: LD_VAR 0 1
54948: PUSH
54949: FOR_IN
54950: IFFALSE 55000
// if GetTag ( i ) = tag then
54952: LD_VAR 0 4
54956: PPUSH
54957: CALL_OW 110
54961: PUSH
54962: LD_VAR 0 2
54966: EQUAL
54967: IFFALSE 54998
// result := Insert ( result , result + 1 , i ) ;
54969: LD_ADDR_VAR 0 3
54973: PUSH
54974: LD_VAR 0 3
54978: PPUSH
54979: LD_VAR 0 3
54983: PUSH
54984: LD_INT 1
54986: PLUS
54987: PPUSH
54988: LD_VAR 0 4
54992: PPUSH
54993: CALL_OW 2
54997: ST_TO_ADDR
54998: GO 54949
55000: POP
55001: POP
// end ;
55002: LD_VAR 0 3
55006: RET
// export function IsDriver ( un ) ; begin
55007: LD_INT 0
55009: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
55010: LD_ADDR_VAR 0 2
55014: PUSH
55015: LD_VAR 0 1
55019: PUSH
55020: LD_INT 55
55022: PUSH
55023: EMPTY
55024: LIST
55025: PPUSH
55026: CALL_OW 69
55030: IN
55031: ST_TO_ADDR
// end ;
55032: LD_VAR 0 2
55036: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
55037: LD_INT 0
55039: PPUSH
55040: PPUSH
// list := [ ] ;
55041: LD_ADDR_VAR 0 5
55045: PUSH
55046: EMPTY
55047: ST_TO_ADDR
// case d of 0 :
55048: LD_VAR 0 3
55052: PUSH
55053: LD_INT 0
55055: DOUBLE
55056: EQUAL
55057: IFTRUE 55061
55059: GO 55194
55061: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
55062: LD_ADDR_VAR 0 5
55066: PUSH
55067: LD_VAR 0 1
55071: PUSH
55072: LD_INT 4
55074: MINUS
55075: PUSH
55076: LD_VAR 0 2
55080: PUSH
55081: LD_INT 4
55083: MINUS
55084: PUSH
55085: LD_INT 2
55087: PUSH
55088: EMPTY
55089: LIST
55090: LIST
55091: LIST
55092: PUSH
55093: LD_VAR 0 1
55097: PUSH
55098: LD_INT 3
55100: MINUS
55101: PUSH
55102: LD_VAR 0 2
55106: PUSH
55107: LD_INT 1
55109: PUSH
55110: EMPTY
55111: LIST
55112: LIST
55113: LIST
55114: PUSH
55115: LD_VAR 0 1
55119: PUSH
55120: LD_INT 4
55122: PLUS
55123: PUSH
55124: LD_VAR 0 2
55128: PUSH
55129: LD_INT 4
55131: PUSH
55132: EMPTY
55133: LIST
55134: LIST
55135: LIST
55136: PUSH
55137: LD_VAR 0 1
55141: PUSH
55142: LD_INT 3
55144: PLUS
55145: PUSH
55146: LD_VAR 0 2
55150: PUSH
55151: LD_INT 3
55153: PLUS
55154: PUSH
55155: LD_INT 5
55157: PUSH
55158: EMPTY
55159: LIST
55160: LIST
55161: LIST
55162: PUSH
55163: LD_VAR 0 1
55167: PUSH
55168: LD_VAR 0 2
55172: PUSH
55173: LD_INT 4
55175: PLUS
55176: PUSH
55177: LD_INT 0
55179: PUSH
55180: EMPTY
55181: LIST
55182: LIST
55183: LIST
55184: PUSH
55185: EMPTY
55186: LIST
55187: LIST
55188: LIST
55189: LIST
55190: LIST
55191: ST_TO_ADDR
// end ; 1 :
55192: GO 55892
55194: LD_INT 1
55196: DOUBLE
55197: EQUAL
55198: IFTRUE 55202
55200: GO 55335
55202: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55203: LD_ADDR_VAR 0 5
55207: PUSH
55208: LD_VAR 0 1
55212: PUSH
55213: LD_VAR 0 2
55217: PUSH
55218: LD_INT 4
55220: MINUS
55221: PUSH
55222: LD_INT 3
55224: PUSH
55225: EMPTY
55226: LIST
55227: LIST
55228: LIST
55229: PUSH
55230: LD_VAR 0 1
55234: PUSH
55235: LD_INT 3
55237: MINUS
55238: PUSH
55239: LD_VAR 0 2
55243: PUSH
55244: LD_INT 3
55246: MINUS
55247: PUSH
55248: LD_INT 2
55250: PUSH
55251: EMPTY
55252: LIST
55253: LIST
55254: LIST
55255: PUSH
55256: LD_VAR 0 1
55260: PUSH
55261: LD_INT 4
55263: MINUS
55264: PUSH
55265: LD_VAR 0 2
55269: PUSH
55270: LD_INT 1
55272: PUSH
55273: EMPTY
55274: LIST
55275: LIST
55276: LIST
55277: PUSH
55278: LD_VAR 0 1
55282: PUSH
55283: LD_VAR 0 2
55287: PUSH
55288: LD_INT 3
55290: PLUS
55291: PUSH
55292: LD_INT 0
55294: PUSH
55295: EMPTY
55296: LIST
55297: LIST
55298: LIST
55299: PUSH
55300: LD_VAR 0 1
55304: PUSH
55305: LD_INT 4
55307: PLUS
55308: PUSH
55309: LD_VAR 0 2
55313: PUSH
55314: LD_INT 4
55316: PLUS
55317: PUSH
55318: LD_INT 5
55320: PUSH
55321: EMPTY
55322: LIST
55323: LIST
55324: LIST
55325: PUSH
55326: EMPTY
55327: LIST
55328: LIST
55329: LIST
55330: LIST
55331: LIST
55332: ST_TO_ADDR
// end ; 2 :
55333: GO 55892
55335: LD_INT 2
55337: DOUBLE
55338: EQUAL
55339: IFTRUE 55343
55341: GO 55472
55343: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55344: LD_ADDR_VAR 0 5
55348: PUSH
55349: LD_VAR 0 1
55353: PUSH
55354: LD_VAR 0 2
55358: PUSH
55359: LD_INT 3
55361: MINUS
55362: PUSH
55363: LD_INT 3
55365: PUSH
55366: EMPTY
55367: LIST
55368: LIST
55369: LIST
55370: PUSH
55371: LD_VAR 0 1
55375: PUSH
55376: LD_INT 4
55378: PLUS
55379: PUSH
55380: LD_VAR 0 2
55384: PUSH
55385: LD_INT 4
55387: PUSH
55388: EMPTY
55389: LIST
55390: LIST
55391: LIST
55392: PUSH
55393: LD_VAR 0 1
55397: PUSH
55398: LD_VAR 0 2
55402: PUSH
55403: LD_INT 4
55405: PLUS
55406: PUSH
55407: LD_INT 0
55409: PUSH
55410: EMPTY
55411: LIST
55412: LIST
55413: LIST
55414: PUSH
55415: LD_VAR 0 1
55419: PUSH
55420: LD_INT 3
55422: MINUS
55423: PUSH
55424: LD_VAR 0 2
55428: PUSH
55429: LD_INT 1
55431: PUSH
55432: EMPTY
55433: LIST
55434: LIST
55435: LIST
55436: PUSH
55437: LD_VAR 0 1
55441: PUSH
55442: LD_INT 4
55444: MINUS
55445: PUSH
55446: LD_VAR 0 2
55450: PUSH
55451: LD_INT 4
55453: MINUS
55454: PUSH
55455: LD_INT 2
55457: PUSH
55458: EMPTY
55459: LIST
55460: LIST
55461: LIST
55462: PUSH
55463: EMPTY
55464: LIST
55465: LIST
55466: LIST
55467: LIST
55468: LIST
55469: ST_TO_ADDR
// end ; 3 :
55470: GO 55892
55472: LD_INT 3
55474: DOUBLE
55475: EQUAL
55476: IFTRUE 55480
55478: GO 55613
55480: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55481: LD_ADDR_VAR 0 5
55485: PUSH
55486: LD_VAR 0 1
55490: PUSH
55491: LD_INT 3
55493: PLUS
55494: PUSH
55495: LD_VAR 0 2
55499: PUSH
55500: LD_INT 4
55502: PUSH
55503: EMPTY
55504: LIST
55505: LIST
55506: LIST
55507: PUSH
55508: LD_VAR 0 1
55512: PUSH
55513: LD_INT 4
55515: PLUS
55516: PUSH
55517: LD_VAR 0 2
55521: PUSH
55522: LD_INT 4
55524: PLUS
55525: PUSH
55526: LD_INT 5
55528: PUSH
55529: EMPTY
55530: LIST
55531: LIST
55532: LIST
55533: PUSH
55534: LD_VAR 0 1
55538: PUSH
55539: LD_INT 4
55541: MINUS
55542: PUSH
55543: LD_VAR 0 2
55547: PUSH
55548: LD_INT 1
55550: PUSH
55551: EMPTY
55552: LIST
55553: LIST
55554: LIST
55555: PUSH
55556: LD_VAR 0 1
55560: PUSH
55561: LD_VAR 0 2
55565: PUSH
55566: LD_INT 4
55568: MINUS
55569: PUSH
55570: LD_INT 3
55572: PUSH
55573: EMPTY
55574: LIST
55575: LIST
55576: LIST
55577: PUSH
55578: LD_VAR 0 1
55582: PUSH
55583: LD_INT 3
55585: MINUS
55586: PUSH
55587: LD_VAR 0 2
55591: PUSH
55592: LD_INT 3
55594: MINUS
55595: PUSH
55596: LD_INT 2
55598: PUSH
55599: EMPTY
55600: LIST
55601: LIST
55602: LIST
55603: PUSH
55604: EMPTY
55605: LIST
55606: LIST
55607: LIST
55608: LIST
55609: LIST
55610: ST_TO_ADDR
// end ; 4 :
55611: GO 55892
55613: LD_INT 4
55615: DOUBLE
55616: EQUAL
55617: IFTRUE 55621
55619: GO 55754
55621: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55622: LD_ADDR_VAR 0 5
55626: PUSH
55627: LD_VAR 0 1
55631: PUSH
55632: LD_VAR 0 2
55636: PUSH
55637: LD_INT 4
55639: PLUS
55640: PUSH
55641: LD_INT 0
55643: PUSH
55644: EMPTY
55645: LIST
55646: LIST
55647: LIST
55648: PUSH
55649: LD_VAR 0 1
55653: PUSH
55654: LD_INT 3
55656: PLUS
55657: PUSH
55658: LD_VAR 0 2
55662: PUSH
55663: LD_INT 3
55665: PLUS
55666: PUSH
55667: LD_INT 5
55669: PUSH
55670: EMPTY
55671: LIST
55672: LIST
55673: LIST
55674: PUSH
55675: LD_VAR 0 1
55679: PUSH
55680: LD_INT 4
55682: PLUS
55683: PUSH
55684: LD_VAR 0 2
55688: PUSH
55689: LD_INT 4
55691: PUSH
55692: EMPTY
55693: LIST
55694: LIST
55695: LIST
55696: PUSH
55697: LD_VAR 0 1
55701: PUSH
55702: LD_VAR 0 2
55706: PUSH
55707: LD_INT 3
55709: MINUS
55710: PUSH
55711: LD_INT 3
55713: PUSH
55714: EMPTY
55715: LIST
55716: LIST
55717: LIST
55718: PUSH
55719: LD_VAR 0 1
55723: PUSH
55724: LD_INT 4
55726: MINUS
55727: PUSH
55728: LD_VAR 0 2
55732: PUSH
55733: LD_INT 4
55735: MINUS
55736: PUSH
55737: LD_INT 2
55739: PUSH
55740: EMPTY
55741: LIST
55742: LIST
55743: LIST
55744: PUSH
55745: EMPTY
55746: LIST
55747: LIST
55748: LIST
55749: LIST
55750: LIST
55751: ST_TO_ADDR
// end ; 5 :
55752: GO 55892
55754: LD_INT 5
55756: DOUBLE
55757: EQUAL
55758: IFTRUE 55762
55760: GO 55891
55762: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55763: LD_ADDR_VAR 0 5
55767: PUSH
55768: LD_VAR 0 1
55772: PUSH
55773: LD_INT 4
55775: MINUS
55776: PUSH
55777: LD_VAR 0 2
55781: PUSH
55782: LD_INT 1
55784: PUSH
55785: EMPTY
55786: LIST
55787: LIST
55788: LIST
55789: PUSH
55790: LD_VAR 0 1
55794: PUSH
55795: LD_VAR 0 2
55799: PUSH
55800: LD_INT 4
55802: MINUS
55803: PUSH
55804: LD_INT 3
55806: PUSH
55807: EMPTY
55808: LIST
55809: LIST
55810: LIST
55811: PUSH
55812: LD_VAR 0 1
55816: PUSH
55817: LD_INT 4
55819: PLUS
55820: PUSH
55821: LD_VAR 0 2
55825: PUSH
55826: LD_INT 4
55828: PLUS
55829: PUSH
55830: LD_INT 5
55832: PUSH
55833: EMPTY
55834: LIST
55835: LIST
55836: LIST
55837: PUSH
55838: LD_VAR 0 1
55842: PUSH
55843: LD_INT 3
55845: PLUS
55846: PUSH
55847: LD_VAR 0 2
55851: PUSH
55852: LD_INT 4
55854: PUSH
55855: EMPTY
55856: LIST
55857: LIST
55858: LIST
55859: PUSH
55860: LD_VAR 0 1
55864: PUSH
55865: LD_VAR 0 2
55869: PUSH
55870: LD_INT 3
55872: PLUS
55873: PUSH
55874: LD_INT 0
55876: PUSH
55877: EMPTY
55878: LIST
55879: LIST
55880: LIST
55881: PUSH
55882: EMPTY
55883: LIST
55884: LIST
55885: LIST
55886: LIST
55887: LIST
55888: ST_TO_ADDR
// end ; end ;
55889: GO 55892
55891: POP
// result := list ;
55892: LD_ADDR_VAR 0 4
55896: PUSH
55897: LD_VAR 0 5
55901: ST_TO_ADDR
// end ;
55902: LD_VAR 0 4
55906: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55907: LD_INT 0
55909: PPUSH
55910: PPUSH
55911: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55912: LD_VAR 0 1
55916: NOT
55917: PUSH
55918: LD_VAR 0 2
55922: PUSH
55923: LD_INT 1
55925: PUSH
55926: LD_INT 2
55928: PUSH
55929: LD_INT 3
55931: PUSH
55932: LD_INT 4
55934: PUSH
55935: EMPTY
55936: LIST
55937: LIST
55938: LIST
55939: LIST
55940: IN
55941: NOT
55942: OR
55943: IFFALSE 55947
// exit ;
55945: GO 56039
// tmp := [ ] ;
55947: LD_ADDR_VAR 0 5
55951: PUSH
55952: EMPTY
55953: ST_TO_ADDR
// for i in units do
55954: LD_ADDR_VAR 0 4
55958: PUSH
55959: LD_VAR 0 1
55963: PUSH
55964: FOR_IN
55965: IFFALSE 56008
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55967: LD_ADDR_VAR 0 5
55971: PUSH
55972: LD_VAR 0 5
55976: PPUSH
55977: LD_VAR 0 5
55981: PUSH
55982: LD_INT 1
55984: PLUS
55985: PPUSH
55986: LD_VAR 0 4
55990: PPUSH
55991: LD_VAR 0 2
55995: PPUSH
55996: CALL_OW 259
56000: PPUSH
56001: CALL_OW 2
56005: ST_TO_ADDR
56006: GO 55964
56008: POP
56009: POP
// if not tmp then
56010: LD_VAR 0 5
56014: NOT
56015: IFFALSE 56019
// exit ;
56017: GO 56039
// result := SortListByListDesc ( units , tmp ) ;
56019: LD_ADDR_VAR 0 3
56023: PUSH
56024: LD_VAR 0 1
56028: PPUSH
56029: LD_VAR 0 5
56033: PPUSH
56034: CALL_OW 77
56038: ST_TO_ADDR
// end ;
56039: LD_VAR 0 3
56043: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
56044: LD_INT 0
56046: PPUSH
56047: PPUSH
56048: PPUSH
// x := GetX ( building ) ;
56049: LD_ADDR_VAR 0 4
56053: PUSH
56054: LD_VAR 0 2
56058: PPUSH
56059: CALL_OW 250
56063: ST_TO_ADDR
// y := GetY ( building ) ;
56064: LD_ADDR_VAR 0 5
56068: PUSH
56069: LD_VAR 0 2
56073: PPUSH
56074: CALL_OW 251
56078: ST_TO_ADDR
// if GetTaskList ( unit ) then
56079: LD_VAR 0 1
56083: PPUSH
56084: CALL_OW 437
56088: IFFALSE 56183
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56090: LD_STRING e
56092: PUSH
56093: LD_VAR 0 1
56097: PPUSH
56098: CALL_OW 437
56102: PUSH
56103: LD_INT 1
56105: ARRAY
56106: PUSH
56107: LD_INT 1
56109: ARRAY
56110: EQUAL
56111: PUSH
56112: LD_VAR 0 4
56116: PUSH
56117: LD_VAR 0 1
56121: PPUSH
56122: CALL_OW 437
56126: PUSH
56127: LD_INT 1
56129: ARRAY
56130: PUSH
56131: LD_INT 2
56133: ARRAY
56134: EQUAL
56135: AND
56136: PUSH
56137: LD_VAR 0 5
56141: PUSH
56142: LD_VAR 0 1
56146: PPUSH
56147: CALL_OW 437
56151: PUSH
56152: LD_INT 1
56154: ARRAY
56155: PUSH
56156: LD_INT 3
56158: ARRAY
56159: EQUAL
56160: AND
56161: IFFALSE 56173
// result := true else
56163: LD_ADDR_VAR 0 3
56167: PUSH
56168: LD_INT 1
56170: ST_TO_ADDR
56171: GO 56181
// result := false ;
56173: LD_ADDR_VAR 0 3
56177: PUSH
56178: LD_INT 0
56180: ST_TO_ADDR
// end else
56181: GO 56191
// result := false ;
56183: LD_ADDR_VAR 0 3
56187: PUSH
56188: LD_INT 0
56190: ST_TO_ADDR
// end ;
56191: LD_VAR 0 3
56195: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56196: LD_INT 0
56198: PPUSH
56199: PPUSH
56200: PPUSH
56201: PPUSH
// if not unit or not area then
56202: LD_VAR 0 1
56206: NOT
56207: PUSH
56208: LD_VAR 0 2
56212: NOT
56213: OR
56214: IFFALSE 56218
// exit ;
56216: GO 56382
// tmp := AreaToList ( area , i ) ;
56218: LD_ADDR_VAR 0 6
56222: PUSH
56223: LD_VAR 0 2
56227: PPUSH
56228: LD_VAR 0 5
56232: PPUSH
56233: CALL_OW 517
56237: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56238: LD_ADDR_VAR 0 5
56242: PUSH
56243: DOUBLE
56244: LD_INT 1
56246: DEC
56247: ST_TO_ADDR
56248: LD_VAR 0 6
56252: PUSH
56253: LD_INT 1
56255: ARRAY
56256: PUSH
56257: FOR_TO
56258: IFFALSE 56380
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56260: LD_ADDR_VAR 0 7
56264: PUSH
56265: LD_VAR 0 6
56269: PUSH
56270: LD_INT 1
56272: ARRAY
56273: PUSH
56274: LD_VAR 0 5
56278: ARRAY
56279: PUSH
56280: LD_VAR 0 6
56284: PUSH
56285: LD_INT 2
56287: ARRAY
56288: PUSH
56289: LD_VAR 0 5
56293: ARRAY
56294: PUSH
56295: EMPTY
56296: LIST
56297: LIST
56298: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56299: LD_VAR 0 7
56303: PUSH
56304: LD_INT 1
56306: ARRAY
56307: PPUSH
56308: LD_VAR 0 7
56312: PUSH
56313: LD_INT 2
56315: ARRAY
56316: PPUSH
56317: CALL_OW 428
56321: PUSH
56322: LD_INT 0
56324: EQUAL
56325: IFFALSE 56378
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56327: LD_VAR 0 1
56331: PPUSH
56332: LD_VAR 0 7
56336: PUSH
56337: LD_INT 1
56339: ARRAY
56340: PPUSH
56341: LD_VAR 0 7
56345: PUSH
56346: LD_INT 2
56348: ARRAY
56349: PPUSH
56350: LD_VAR 0 3
56354: PPUSH
56355: CALL_OW 48
// result := IsPlaced ( unit ) ;
56359: LD_ADDR_VAR 0 4
56363: PUSH
56364: LD_VAR 0 1
56368: PPUSH
56369: CALL_OW 305
56373: ST_TO_ADDR
// exit ;
56374: POP
56375: POP
56376: GO 56382
// end ; end ;
56378: GO 56257
56380: POP
56381: POP
// end ;
56382: LD_VAR 0 4
56386: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56387: LD_INT 0
56389: PPUSH
56390: PPUSH
56391: PPUSH
// if not side or side > 8 then
56392: LD_VAR 0 1
56396: NOT
56397: PUSH
56398: LD_VAR 0 1
56402: PUSH
56403: LD_INT 8
56405: GREATER
56406: OR
56407: IFFALSE 56411
// exit ;
56409: GO 56598
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56411: LD_ADDR_VAR 0 4
56415: PUSH
56416: LD_INT 22
56418: PUSH
56419: LD_VAR 0 1
56423: PUSH
56424: EMPTY
56425: LIST
56426: LIST
56427: PUSH
56428: LD_INT 21
56430: PUSH
56431: LD_INT 3
56433: PUSH
56434: EMPTY
56435: LIST
56436: LIST
56437: PUSH
56438: EMPTY
56439: LIST
56440: LIST
56441: PPUSH
56442: CALL_OW 69
56446: ST_TO_ADDR
// if not tmp then
56447: LD_VAR 0 4
56451: NOT
56452: IFFALSE 56456
// exit ;
56454: GO 56598
// enable_addtolog := true ;
56456: LD_ADDR_OWVAR 81
56460: PUSH
56461: LD_INT 1
56463: ST_TO_ADDR
// AddToLog ( [ ) ;
56464: LD_STRING [
56466: PPUSH
56467: CALL_OW 561
// for i in tmp do
56471: LD_ADDR_VAR 0 3
56475: PUSH
56476: LD_VAR 0 4
56480: PUSH
56481: FOR_IN
56482: IFFALSE 56589
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56484: LD_STRING [
56486: PUSH
56487: LD_VAR 0 3
56491: PPUSH
56492: CALL_OW 266
56496: STR
56497: PUSH
56498: LD_STRING , 
56500: STR
56501: PUSH
56502: LD_VAR 0 3
56506: PPUSH
56507: CALL_OW 250
56511: STR
56512: PUSH
56513: LD_STRING , 
56515: STR
56516: PUSH
56517: LD_VAR 0 3
56521: PPUSH
56522: CALL_OW 251
56526: STR
56527: PUSH
56528: LD_STRING , 
56530: STR
56531: PUSH
56532: LD_VAR 0 3
56536: PPUSH
56537: CALL_OW 254
56541: STR
56542: PUSH
56543: LD_STRING , 
56545: STR
56546: PUSH
56547: LD_VAR 0 3
56551: PPUSH
56552: LD_INT 1
56554: PPUSH
56555: CALL_OW 268
56559: STR
56560: PUSH
56561: LD_STRING , 
56563: STR
56564: PUSH
56565: LD_VAR 0 3
56569: PPUSH
56570: LD_INT 2
56572: PPUSH
56573: CALL_OW 268
56577: STR
56578: PUSH
56579: LD_STRING ],
56581: STR
56582: PPUSH
56583: CALL_OW 561
// end ;
56587: GO 56481
56589: POP
56590: POP
// AddToLog ( ]; ) ;
56591: LD_STRING ];
56593: PPUSH
56594: CALL_OW 561
// end ;
56598: LD_VAR 0 2
56602: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56603: LD_INT 0
56605: PPUSH
56606: PPUSH
56607: PPUSH
56608: PPUSH
56609: PPUSH
// if not area or not rate or not max then
56610: LD_VAR 0 1
56614: NOT
56615: PUSH
56616: LD_VAR 0 2
56620: NOT
56621: OR
56622: PUSH
56623: LD_VAR 0 4
56627: NOT
56628: OR
56629: IFFALSE 56633
// exit ;
56631: GO 56825
// while 1 do
56633: LD_INT 1
56635: IFFALSE 56825
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56637: LD_ADDR_VAR 0 9
56641: PUSH
56642: LD_VAR 0 1
56646: PPUSH
56647: LD_INT 1
56649: PPUSH
56650: CALL_OW 287
56654: PUSH
56655: LD_INT 10
56657: MUL
56658: ST_TO_ADDR
// r := rate / 10 ;
56659: LD_ADDR_VAR 0 7
56663: PUSH
56664: LD_VAR 0 2
56668: PUSH
56669: LD_INT 10
56671: DIVREAL
56672: ST_TO_ADDR
// time := 1 1$00 ;
56673: LD_ADDR_VAR 0 8
56677: PUSH
56678: LD_INT 2100
56680: ST_TO_ADDR
// if amount < min then
56681: LD_VAR 0 9
56685: PUSH
56686: LD_VAR 0 3
56690: LESS
56691: IFFALSE 56709
// r := r * 2 else
56693: LD_ADDR_VAR 0 7
56697: PUSH
56698: LD_VAR 0 7
56702: PUSH
56703: LD_INT 2
56705: MUL
56706: ST_TO_ADDR
56707: GO 56735
// if amount > max then
56709: LD_VAR 0 9
56713: PUSH
56714: LD_VAR 0 4
56718: GREATER
56719: IFFALSE 56735
// r := r / 2 ;
56721: LD_ADDR_VAR 0 7
56725: PUSH
56726: LD_VAR 0 7
56730: PUSH
56731: LD_INT 2
56733: DIVREAL
56734: ST_TO_ADDR
// time := time / r ;
56735: LD_ADDR_VAR 0 8
56739: PUSH
56740: LD_VAR 0 8
56744: PUSH
56745: LD_VAR 0 7
56749: DIVREAL
56750: ST_TO_ADDR
// if time < 0 then
56751: LD_VAR 0 8
56755: PUSH
56756: LD_INT 0
56758: LESS
56759: IFFALSE 56776
// time := time * - 1 ;
56761: LD_ADDR_VAR 0 8
56765: PUSH
56766: LD_VAR 0 8
56770: PUSH
56771: LD_INT 1
56773: NEG
56774: MUL
56775: ST_TO_ADDR
// wait ( time ) ;
56776: LD_VAR 0 8
56780: PPUSH
56781: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56785: LD_INT 35
56787: PPUSH
56788: LD_INT 875
56790: PPUSH
56791: CALL_OW 12
56795: PPUSH
56796: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56800: LD_INT 1
56802: PPUSH
56803: LD_INT 5
56805: PPUSH
56806: CALL_OW 12
56810: PPUSH
56811: LD_VAR 0 1
56815: PPUSH
56816: LD_INT 1
56818: PPUSH
56819: CALL_OW 55
// end ;
56823: GO 56633
// end ;
56825: LD_VAR 0 5
56829: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56830: LD_INT 0
56832: PPUSH
56833: PPUSH
56834: PPUSH
56835: PPUSH
56836: PPUSH
56837: PPUSH
56838: PPUSH
56839: PPUSH
// if not turrets or not factories then
56840: LD_VAR 0 1
56844: NOT
56845: PUSH
56846: LD_VAR 0 2
56850: NOT
56851: OR
56852: IFFALSE 56856
// exit ;
56854: GO 57163
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56856: LD_ADDR_VAR 0 10
56860: PUSH
56861: LD_INT 5
56863: PUSH
56864: LD_INT 6
56866: PUSH
56867: EMPTY
56868: LIST
56869: LIST
56870: PUSH
56871: LD_INT 2
56873: PUSH
56874: LD_INT 4
56876: PUSH
56877: EMPTY
56878: LIST
56879: LIST
56880: PUSH
56881: LD_INT 3
56883: PUSH
56884: LD_INT 5
56886: PUSH
56887: EMPTY
56888: LIST
56889: LIST
56890: PUSH
56891: EMPTY
56892: LIST
56893: LIST
56894: LIST
56895: PUSH
56896: LD_INT 24
56898: PUSH
56899: LD_INT 25
56901: PUSH
56902: EMPTY
56903: LIST
56904: LIST
56905: PUSH
56906: LD_INT 23
56908: PUSH
56909: LD_INT 27
56911: PUSH
56912: EMPTY
56913: LIST
56914: LIST
56915: PUSH
56916: EMPTY
56917: LIST
56918: LIST
56919: PUSH
56920: LD_INT 42
56922: PUSH
56923: LD_INT 43
56925: PUSH
56926: EMPTY
56927: LIST
56928: LIST
56929: PUSH
56930: LD_INT 44
56932: PUSH
56933: LD_INT 46
56935: PUSH
56936: EMPTY
56937: LIST
56938: LIST
56939: PUSH
56940: LD_INT 45
56942: PUSH
56943: LD_INT 47
56945: PUSH
56946: EMPTY
56947: LIST
56948: LIST
56949: PUSH
56950: EMPTY
56951: LIST
56952: LIST
56953: LIST
56954: PUSH
56955: EMPTY
56956: LIST
56957: LIST
56958: LIST
56959: ST_TO_ADDR
// result := [ ] ;
56960: LD_ADDR_VAR 0 3
56964: PUSH
56965: EMPTY
56966: ST_TO_ADDR
// for i in turrets do
56967: LD_ADDR_VAR 0 4
56971: PUSH
56972: LD_VAR 0 1
56976: PUSH
56977: FOR_IN
56978: IFFALSE 57161
// begin nat := GetNation ( i ) ;
56980: LD_ADDR_VAR 0 7
56984: PUSH
56985: LD_VAR 0 4
56989: PPUSH
56990: CALL_OW 248
56994: ST_TO_ADDR
// weapon := 0 ;
56995: LD_ADDR_VAR 0 8
56999: PUSH
57000: LD_INT 0
57002: ST_TO_ADDR
// if not nat then
57003: LD_VAR 0 7
57007: NOT
57008: IFFALSE 57012
// continue ;
57010: GO 56977
// for j in list [ nat ] do
57012: LD_ADDR_VAR 0 5
57016: PUSH
57017: LD_VAR 0 10
57021: PUSH
57022: LD_VAR 0 7
57026: ARRAY
57027: PUSH
57028: FOR_IN
57029: IFFALSE 57070
// if GetBWeapon ( i ) = j [ 1 ] then
57031: LD_VAR 0 4
57035: PPUSH
57036: CALL_OW 269
57040: PUSH
57041: LD_VAR 0 5
57045: PUSH
57046: LD_INT 1
57048: ARRAY
57049: EQUAL
57050: IFFALSE 57068
// begin weapon := j [ 2 ] ;
57052: LD_ADDR_VAR 0 8
57056: PUSH
57057: LD_VAR 0 5
57061: PUSH
57062: LD_INT 2
57064: ARRAY
57065: ST_TO_ADDR
// break ;
57066: GO 57070
// end ;
57068: GO 57028
57070: POP
57071: POP
// if not weapon then
57072: LD_VAR 0 8
57076: NOT
57077: IFFALSE 57081
// continue ;
57079: GO 56977
// for k in factories do
57081: LD_ADDR_VAR 0 6
57085: PUSH
57086: LD_VAR 0 2
57090: PUSH
57091: FOR_IN
57092: IFFALSE 57157
// begin weapons := AvailableWeaponList ( k ) ;
57094: LD_ADDR_VAR 0 9
57098: PUSH
57099: LD_VAR 0 6
57103: PPUSH
57104: CALL_OW 478
57108: ST_TO_ADDR
// if not weapons then
57109: LD_VAR 0 9
57113: NOT
57114: IFFALSE 57118
// continue ;
57116: GO 57091
// if weapon in weapons then
57118: LD_VAR 0 8
57122: PUSH
57123: LD_VAR 0 9
57127: IN
57128: IFFALSE 57155
// begin result := [ i , weapon ] ;
57130: LD_ADDR_VAR 0 3
57134: PUSH
57135: LD_VAR 0 4
57139: PUSH
57140: LD_VAR 0 8
57144: PUSH
57145: EMPTY
57146: LIST
57147: LIST
57148: ST_TO_ADDR
// exit ;
57149: POP
57150: POP
57151: POP
57152: POP
57153: GO 57163
// end ; end ;
57155: GO 57091
57157: POP
57158: POP
// end ;
57159: GO 56977
57161: POP
57162: POP
// end ;
57163: LD_VAR 0 3
57167: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57168: LD_INT 0
57170: PPUSH
// if not side or side > 8 then
57171: LD_VAR 0 3
57175: NOT
57176: PUSH
57177: LD_VAR 0 3
57181: PUSH
57182: LD_INT 8
57184: GREATER
57185: OR
57186: IFFALSE 57190
// exit ;
57188: GO 57249
// if not range then
57190: LD_VAR 0 4
57194: NOT
57195: IFFALSE 57206
// range := - 12 ;
57197: LD_ADDR_VAR 0 4
57201: PUSH
57202: LD_INT 12
57204: NEG
57205: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57206: LD_VAR 0 1
57210: PPUSH
57211: LD_VAR 0 2
57215: PPUSH
57216: LD_VAR 0 3
57220: PPUSH
57221: LD_VAR 0 4
57225: PPUSH
57226: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57230: LD_VAR 0 1
57234: PPUSH
57235: LD_VAR 0 2
57239: PPUSH
57240: LD_VAR 0 3
57244: PPUSH
57245: CALL_OW 331
// end ;
57249: LD_VAR 0 5
57253: RET
// export function Video ( mode ) ; begin
57254: LD_INT 0
57256: PPUSH
// ingame_video = mode ;
57257: LD_ADDR_OWVAR 52
57261: PUSH
57262: LD_VAR 0 1
57266: ST_TO_ADDR
// interface_hidden = mode ;
57267: LD_ADDR_OWVAR 54
57271: PUSH
57272: LD_VAR 0 1
57276: ST_TO_ADDR
// end ;
57277: LD_VAR 0 2
57281: RET
// export function Join ( array , element ) ; begin
57282: LD_INT 0
57284: PPUSH
// result := array ^ element ;
57285: LD_ADDR_VAR 0 3
57289: PUSH
57290: LD_VAR 0 1
57294: PUSH
57295: LD_VAR 0 2
57299: ADD
57300: ST_TO_ADDR
// end ;
57301: LD_VAR 0 3
57305: RET
// export function JoinUnion ( array , element ) ; begin
57306: LD_INT 0
57308: PPUSH
// result := array union element ;
57309: LD_ADDR_VAR 0 3
57313: PUSH
57314: LD_VAR 0 1
57318: PUSH
57319: LD_VAR 0 2
57323: UNION
57324: ST_TO_ADDR
// end ;
57325: LD_VAR 0 3
57329: RET
// export function GetBehemoths ( side ) ; begin
57330: LD_INT 0
57332: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
57333: LD_ADDR_VAR 0 2
57337: PUSH
57338: LD_INT 22
57340: PUSH
57341: LD_VAR 0 1
57345: PUSH
57346: EMPTY
57347: LIST
57348: LIST
57349: PUSH
57350: LD_INT 31
57352: PUSH
57353: LD_INT 25
57355: PUSH
57356: EMPTY
57357: LIST
57358: LIST
57359: PUSH
57360: EMPTY
57361: LIST
57362: LIST
57363: PPUSH
57364: CALL_OW 69
57368: ST_TO_ADDR
// end ;
57369: LD_VAR 0 2
57373: RET
// export function Shuffle ( array ) ; var i , index ; begin
57374: LD_INT 0
57376: PPUSH
57377: PPUSH
57378: PPUSH
// result := [ ] ;
57379: LD_ADDR_VAR 0 2
57383: PUSH
57384: EMPTY
57385: ST_TO_ADDR
// if not array then
57386: LD_VAR 0 1
57390: NOT
57391: IFFALSE 57395
// exit ;
57393: GO 57494
// Randomize ;
57395: CALL_OW 10
// for i = array downto 1 do
57399: LD_ADDR_VAR 0 3
57403: PUSH
57404: DOUBLE
57405: LD_VAR 0 1
57409: INC
57410: ST_TO_ADDR
57411: LD_INT 1
57413: PUSH
57414: FOR_DOWNTO
57415: IFFALSE 57492
// begin index := rand ( 1 , array ) ;
57417: LD_ADDR_VAR 0 4
57421: PUSH
57422: LD_INT 1
57424: PPUSH
57425: LD_VAR 0 1
57429: PPUSH
57430: CALL_OW 12
57434: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57435: LD_ADDR_VAR 0 2
57439: PUSH
57440: LD_VAR 0 2
57444: PPUSH
57445: LD_VAR 0 2
57449: PUSH
57450: LD_INT 1
57452: PLUS
57453: PPUSH
57454: LD_VAR 0 1
57458: PUSH
57459: LD_VAR 0 4
57463: ARRAY
57464: PPUSH
57465: CALL_OW 2
57469: ST_TO_ADDR
// array := Delete ( array , index ) ;
57470: LD_ADDR_VAR 0 1
57474: PUSH
57475: LD_VAR 0 1
57479: PPUSH
57480: LD_VAR 0 4
57484: PPUSH
57485: CALL_OW 3
57489: ST_TO_ADDR
// end ;
57490: GO 57414
57492: POP
57493: POP
// end ;
57494: LD_VAR 0 2
57498: RET
// export function GetBaseMaterials ( base ) ; begin
57499: LD_INT 0
57501: PPUSH
// result := [ 0 , 0 , 0 ] ;
57502: LD_ADDR_VAR 0 2
57506: PUSH
57507: LD_INT 0
57509: PUSH
57510: LD_INT 0
57512: PUSH
57513: LD_INT 0
57515: PUSH
57516: EMPTY
57517: LIST
57518: LIST
57519: LIST
57520: ST_TO_ADDR
// if not base then
57521: LD_VAR 0 1
57525: NOT
57526: IFFALSE 57530
// exit ;
57528: GO 57579
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57530: LD_ADDR_VAR 0 2
57534: PUSH
57535: LD_VAR 0 1
57539: PPUSH
57540: LD_INT 1
57542: PPUSH
57543: CALL_OW 275
57547: PUSH
57548: LD_VAR 0 1
57552: PPUSH
57553: LD_INT 2
57555: PPUSH
57556: CALL_OW 275
57560: PUSH
57561: LD_VAR 0 1
57565: PPUSH
57566: LD_INT 3
57568: PPUSH
57569: CALL_OW 275
57573: PUSH
57574: EMPTY
57575: LIST
57576: LIST
57577: LIST
57578: ST_TO_ADDR
// end ; end_of_file
57579: LD_VAR 0 2
57583: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
57584: LD_INT 0
57586: PPUSH
57587: PPUSH
// skirmish := false ;
57588: LD_ADDR_EXP 57
57592: PUSH
57593: LD_INT 0
57595: ST_TO_ADDR
// debug_mc := false ;
57596: LD_ADDR_EXP 58
57600: PUSH
57601: LD_INT 0
57603: ST_TO_ADDR
// mc_bases := [ ] ;
57604: LD_ADDR_EXP 59
57608: PUSH
57609: EMPTY
57610: ST_TO_ADDR
// mc_sides := [ ] ;
57611: LD_ADDR_EXP 85
57615: PUSH
57616: EMPTY
57617: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57618: LD_ADDR_EXP 60
57622: PUSH
57623: EMPTY
57624: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57625: LD_ADDR_EXP 61
57629: PUSH
57630: EMPTY
57631: ST_TO_ADDR
// mc_need_heal := [ ] ;
57632: LD_ADDR_EXP 62
57636: PUSH
57637: EMPTY
57638: ST_TO_ADDR
// mc_healers := [ ] ;
57639: LD_ADDR_EXP 63
57643: PUSH
57644: EMPTY
57645: ST_TO_ADDR
// mc_build_list := [ ] ;
57646: LD_ADDR_EXP 64
57650: PUSH
57651: EMPTY
57652: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57653: LD_ADDR_EXP 91
57657: PUSH
57658: EMPTY
57659: ST_TO_ADDR
// mc_builders := [ ] ;
57660: LD_ADDR_EXP 65
57664: PUSH
57665: EMPTY
57666: ST_TO_ADDR
// mc_construct_list := [ ] ;
57667: LD_ADDR_EXP 66
57671: PUSH
57672: EMPTY
57673: ST_TO_ADDR
// mc_turret_list := [ ] ;
57674: LD_ADDR_EXP 67
57678: PUSH
57679: EMPTY
57680: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57681: LD_ADDR_EXP 68
57685: PUSH
57686: EMPTY
57687: ST_TO_ADDR
// mc_miners := [ ] ;
57688: LD_ADDR_EXP 73
57692: PUSH
57693: EMPTY
57694: ST_TO_ADDR
// mc_mines := [ ] ;
57695: LD_ADDR_EXP 72
57699: PUSH
57700: EMPTY
57701: ST_TO_ADDR
// mc_minefields := [ ] ;
57702: LD_ADDR_EXP 74
57706: PUSH
57707: EMPTY
57708: ST_TO_ADDR
// mc_crates := [ ] ;
57709: LD_ADDR_EXP 75
57713: PUSH
57714: EMPTY
57715: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57716: LD_ADDR_EXP 76
57720: PUSH
57721: EMPTY
57722: ST_TO_ADDR
// mc_crates_area := [ ] ;
57723: LD_ADDR_EXP 77
57727: PUSH
57728: EMPTY
57729: ST_TO_ADDR
// mc_vehicles := [ ] ;
57730: LD_ADDR_EXP 78
57734: PUSH
57735: EMPTY
57736: ST_TO_ADDR
// mc_attack := [ ] ;
57737: LD_ADDR_EXP 79
57741: PUSH
57742: EMPTY
57743: ST_TO_ADDR
// mc_produce := [ ] ;
57744: LD_ADDR_EXP 80
57748: PUSH
57749: EMPTY
57750: ST_TO_ADDR
// mc_defender := [ ] ;
57751: LD_ADDR_EXP 81
57755: PUSH
57756: EMPTY
57757: ST_TO_ADDR
// mc_parking := [ ] ;
57758: LD_ADDR_EXP 83
57762: PUSH
57763: EMPTY
57764: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57765: LD_ADDR_EXP 69
57769: PUSH
57770: EMPTY
57771: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57772: LD_ADDR_EXP 71
57776: PUSH
57777: EMPTY
57778: ST_TO_ADDR
// mc_scan := [ ] ;
57779: LD_ADDR_EXP 82
57783: PUSH
57784: EMPTY
57785: ST_TO_ADDR
// mc_scan_area := [ ] ;
57786: LD_ADDR_EXP 84
57790: PUSH
57791: EMPTY
57792: ST_TO_ADDR
// mc_tech := [ ] ;
57793: LD_ADDR_EXP 86
57797: PUSH
57798: EMPTY
57799: ST_TO_ADDR
// mc_class := [ ] ;
57800: LD_ADDR_EXP 100
57804: PUSH
57805: EMPTY
57806: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57807: LD_ADDR_EXP 101
57811: PUSH
57812: EMPTY
57813: ST_TO_ADDR
// end ;
57814: LD_VAR 0 1
57818: RET
// export function MC_Kill ( base ) ; begin
57819: LD_INT 0
57821: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57822: LD_ADDR_EXP 59
57826: PUSH
57827: LD_EXP 59
57831: PPUSH
57832: LD_VAR 0 1
57836: PPUSH
57837: EMPTY
57838: PPUSH
57839: CALL_OW 1
57843: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57844: LD_ADDR_EXP 60
57848: PUSH
57849: LD_EXP 60
57853: PPUSH
57854: LD_VAR 0 1
57858: PPUSH
57859: EMPTY
57860: PPUSH
57861: CALL_OW 1
57865: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57866: LD_ADDR_EXP 61
57870: PUSH
57871: LD_EXP 61
57875: PPUSH
57876: LD_VAR 0 1
57880: PPUSH
57881: EMPTY
57882: PPUSH
57883: CALL_OW 1
57887: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57888: LD_ADDR_EXP 62
57892: PUSH
57893: LD_EXP 62
57897: PPUSH
57898: LD_VAR 0 1
57902: PPUSH
57903: EMPTY
57904: PPUSH
57905: CALL_OW 1
57909: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57910: LD_ADDR_EXP 63
57914: PUSH
57915: LD_EXP 63
57919: PPUSH
57920: LD_VAR 0 1
57924: PPUSH
57925: EMPTY
57926: PPUSH
57927: CALL_OW 1
57931: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57932: LD_ADDR_EXP 64
57936: PUSH
57937: LD_EXP 64
57941: PPUSH
57942: LD_VAR 0 1
57946: PPUSH
57947: EMPTY
57948: PPUSH
57949: CALL_OW 1
57953: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57954: LD_ADDR_EXP 65
57958: PUSH
57959: LD_EXP 65
57963: PPUSH
57964: LD_VAR 0 1
57968: PPUSH
57969: EMPTY
57970: PPUSH
57971: CALL_OW 1
57975: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57976: LD_ADDR_EXP 66
57980: PUSH
57981: LD_EXP 66
57985: PPUSH
57986: LD_VAR 0 1
57990: PPUSH
57991: EMPTY
57992: PPUSH
57993: CALL_OW 1
57997: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57998: LD_ADDR_EXP 67
58002: PUSH
58003: LD_EXP 67
58007: PPUSH
58008: LD_VAR 0 1
58012: PPUSH
58013: EMPTY
58014: PPUSH
58015: CALL_OW 1
58019: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58020: LD_ADDR_EXP 68
58024: PUSH
58025: LD_EXP 68
58029: PPUSH
58030: LD_VAR 0 1
58034: PPUSH
58035: EMPTY
58036: PPUSH
58037: CALL_OW 1
58041: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58042: LD_ADDR_EXP 69
58046: PUSH
58047: LD_EXP 69
58051: PPUSH
58052: LD_VAR 0 1
58056: PPUSH
58057: EMPTY
58058: PPUSH
58059: CALL_OW 1
58063: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58064: LD_ADDR_EXP 70
58068: PUSH
58069: LD_EXP 70
58073: PPUSH
58074: LD_VAR 0 1
58078: PPUSH
58079: LD_INT 0
58081: PPUSH
58082: CALL_OW 1
58086: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58087: LD_ADDR_EXP 71
58091: PUSH
58092: LD_EXP 71
58096: PPUSH
58097: LD_VAR 0 1
58101: PPUSH
58102: EMPTY
58103: PPUSH
58104: CALL_OW 1
58108: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58109: LD_ADDR_EXP 72
58113: PUSH
58114: LD_EXP 72
58118: PPUSH
58119: LD_VAR 0 1
58123: PPUSH
58124: EMPTY
58125: PPUSH
58126: CALL_OW 1
58130: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58131: LD_ADDR_EXP 73
58135: PUSH
58136: LD_EXP 73
58140: PPUSH
58141: LD_VAR 0 1
58145: PPUSH
58146: EMPTY
58147: PPUSH
58148: CALL_OW 1
58152: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58153: LD_ADDR_EXP 74
58157: PUSH
58158: LD_EXP 74
58162: PPUSH
58163: LD_VAR 0 1
58167: PPUSH
58168: EMPTY
58169: PPUSH
58170: CALL_OW 1
58174: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58175: LD_ADDR_EXP 75
58179: PUSH
58180: LD_EXP 75
58184: PPUSH
58185: LD_VAR 0 1
58189: PPUSH
58190: EMPTY
58191: PPUSH
58192: CALL_OW 1
58196: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58197: LD_ADDR_EXP 76
58201: PUSH
58202: LD_EXP 76
58206: PPUSH
58207: LD_VAR 0 1
58211: PPUSH
58212: EMPTY
58213: PPUSH
58214: CALL_OW 1
58218: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58219: LD_ADDR_EXP 77
58223: PUSH
58224: LD_EXP 77
58228: PPUSH
58229: LD_VAR 0 1
58233: PPUSH
58234: EMPTY
58235: PPUSH
58236: CALL_OW 1
58240: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58241: LD_ADDR_EXP 78
58245: PUSH
58246: LD_EXP 78
58250: PPUSH
58251: LD_VAR 0 1
58255: PPUSH
58256: EMPTY
58257: PPUSH
58258: CALL_OW 1
58262: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58263: LD_ADDR_EXP 79
58267: PUSH
58268: LD_EXP 79
58272: PPUSH
58273: LD_VAR 0 1
58277: PPUSH
58278: EMPTY
58279: PPUSH
58280: CALL_OW 1
58284: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58285: LD_ADDR_EXP 80
58289: PUSH
58290: LD_EXP 80
58294: PPUSH
58295: LD_VAR 0 1
58299: PPUSH
58300: EMPTY
58301: PPUSH
58302: CALL_OW 1
58306: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58307: LD_ADDR_EXP 81
58311: PUSH
58312: LD_EXP 81
58316: PPUSH
58317: LD_VAR 0 1
58321: PPUSH
58322: EMPTY
58323: PPUSH
58324: CALL_OW 1
58328: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58329: LD_ADDR_EXP 82
58333: PUSH
58334: LD_EXP 82
58338: PPUSH
58339: LD_VAR 0 1
58343: PPUSH
58344: EMPTY
58345: PPUSH
58346: CALL_OW 1
58350: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58351: LD_ADDR_EXP 83
58355: PUSH
58356: LD_EXP 83
58360: PPUSH
58361: LD_VAR 0 1
58365: PPUSH
58366: EMPTY
58367: PPUSH
58368: CALL_OW 1
58372: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58373: LD_ADDR_EXP 84
58377: PUSH
58378: LD_EXP 84
58382: PPUSH
58383: LD_VAR 0 1
58387: PPUSH
58388: EMPTY
58389: PPUSH
58390: CALL_OW 1
58394: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58395: LD_ADDR_EXP 86
58399: PUSH
58400: LD_EXP 86
58404: PPUSH
58405: LD_VAR 0 1
58409: PPUSH
58410: EMPTY
58411: PPUSH
58412: CALL_OW 1
58416: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58417: LD_ADDR_EXP 88
58421: PUSH
58422: LD_EXP 88
58426: PPUSH
58427: LD_VAR 0 1
58431: PPUSH
58432: EMPTY
58433: PPUSH
58434: CALL_OW 1
58438: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58439: LD_ADDR_EXP 89
58443: PUSH
58444: LD_EXP 89
58448: PPUSH
58449: LD_VAR 0 1
58453: PPUSH
58454: EMPTY
58455: PPUSH
58456: CALL_OW 1
58460: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58461: LD_ADDR_EXP 90
58465: PUSH
58466: LD_EXP 90
58470: PPUSH
58471: LD_VAR 0 1
58475: PPUSH
58476: EMPTY
58477: PPUSH
58478: CALL_OW 1
58482: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58483: LD_ADDR_EXP 91
58487: PUSH
58488: LD_EXP 91
58492: PPUSH
58493: LD_VAR 0 1
58497: PPUSH
58498: EMPTY
58499: PPUSH
58500: CALL_OW 1
58504: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58505: LD_ADDR_EXP 92
58509: PUSH
58510: LD_EXP 92
58514: PPUSH
58515: LD_VAR 0 1
58519: PPUSH
58520: EMPTY
58521: PPUSH
58522: CALL_OW 1
58526: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58527: LD_ADDR_EXP 93
58531: PUSH
58532: LD_EXP 93
58536: PPUSH
58537: LD_VAR 0 1
58541: PPUSH
58542: EMPTY
58543: PPUSH
58544: CALL_OW 1
58548: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58549: LD_ADDR_EXP 94
58553: PUSH
58554: LD_EXP 94
58558: PPUSH
58559: LD_VAR 0 1
58563: PPUSH
58564: EMPTY
58565: PPUSH
58566: CALL_OW 1
58570: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58571: LD_ADDR_EXP 95
58575: PUSH
58576: LD_EXP 95
58580: PPUSH
58581: LD_VAR 0 1
58585: PPUSH
58586: EMPTY
58587: PPUSH
58588: CALL_OW 1
58592: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58593: LD_ADDR_EXP 96
58597: PUSH
58598: LD_EXP 96
58602: PPUSH
58603: LD_VAR 0 1
58607: PPUSH
58608: EMPTY
58609: PPUSH
58610: CALL_OW 1
58614: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58615: LD_ADDR_EXP 97
58619: PUSH
58620: LD_EXP 97
58624: PPUSH
58625: LD_VAR 0 1
58629: PPUSH
58630: EMPTY
58631: PPUSH
58632: CALL_OW 1
58636: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58637: LD_ADDR_EXP 98
58641: PUSH
58642: LD_EXP 98
58646: PPUSH
58647: LD_VAR 0 1
58651: PPUSH
58652: EMPTY
58653: PPUSH
58654: CALL_OW 1
58658: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58659: LD_ADDR_EXP 99
58663: PUSH
58664: LD_EXP 99
58668: PPUSH
58669: LD_VAR 0 1
58673: PPUSH
58674: EMPTY
58675: PPUSH
58676: CALL_OW 1
58680: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58681: LD_ADDR_EXP 100
58685: PUSH
58686: LD_EXP 100
58690: PPUSH
58691: LD_VAR 0 1
58695: PPUSH
58696: EMPTY
58697: PPUSH
58698: CALL_OW 1
58702: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58703: LD_ADDR_EXP 101
58707: PUSH
58708: LD_EXP 101
58712: PPUSH
58713: LD_VAR 0 1
58717: PPUSH
58718: LD_INT 0
58720: PPUSH
58721: CALL_OW 1
58725: ST_TO_ADDR
// end ;
58726: LD_VAR 0 2
58730: RET
// export function MC_Add ( side , units ) ; var base ; begin
58731: LD_INT 0
58733: PPUSH
58734: PPUSH
// base := mc_bases + 1 ;
58735: LD_ADDR_VAR 0 4
58739: PUSH
58740: LD_EXP 59
58744: PUSH
58745: LD_INT 1
58747: PLUS
58748: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58749: LD_ADDR_EXP 85
58753: PUSH
58754: LD_EXP 85
58758: PPUSH
58759: LD_VAR 0 4
58763: PPUSH
58764: LD_VAR 0 1
58768: PPUSH
58769: CALL_OW 1
58773: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58774: LD_ADDR_EXP 59
58778: PUSH
58779: LD_EXP 59
58783: PPUSH
58784: LD_VAR 0 4
58788: PPUSH
58789: LD_VAR 0 2
58793: PPUSH
58794: CALL_OW 1
58798: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58799: LD_ADDR_EXP 60
58803: PUSH
58804: LD_EXP 60
58808: PPUSH
58809: LD_VAR 0 4
58813: PPUSH
58814: EMPTY
58815: PPUSH
58816: CALL_OW 1
58820: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58821: LD_ADDR_EXP 61
58825: PUSH
58826: LD_EXP 61
58830: PPUSH
58831: LD_VAR 0 4
58835: PPUSH
58836: EMPTY
58837: PPUSH
58838: CALL_OW 1
58842: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58843: LD_ADDR_EXP 62
58847: PUSH
58848: LD_EXP 62
58852: PPUSH
58853: LD_VAR 0 4
58857: PPUSH
58858: EMPTY
58859: PPUSH
58860: CALL_OW 1
58864: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58865: LD_ADDR_EXP 63
58869: PUSH
58870: LD_EXP 63
58874: PPUSH
58875: LD_VAR 0 4
58879: PPUSH
58880: EMPTY
58881: PPUSH
58882: CALL_OW 1
58886: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58887: LD_ADDR_EXP 64
58891: PUSH
58892: LD_EXP 64
58896: PPUSH
58897: LD_VAR 0 4
58901: PPUSH
58902: EMPTY
58903: PPUSH
58904: CALL_OW 1
58908: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58909: LD_ADDR_EXP 65
58913: PUSH
58914: LD_EXP 65
58918: PPUSH
58919: LD_VAR 0 4
58923: PPUSH
58924: EMPTY
58925: PPUSH
58926: CALL_OW 1
58930: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58931: LD_ADDR_EXP 66
58935: PUSH
58936: LD_EXP 66
58940: PPUSH
58941: LD_VAR 0 4
58945: PPUSH
58946: EMPTY
58947: PPUSH
58948: CALL_OW 1
58952: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58953: LD_ADDR_EXP 67
58957: PUSH
58958: LD_EXP 67
58962: PPUSH
58963: LD_VAR 0 4
58967: PPUSH
58968: EMPTY
58969: PPUSH
58970: CALL_OW 1
58974: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58975: LD_ADDR_EXP 68
58979: PUSH
58980: LD_EXP 68
58984: PPUSH
58985: LD_VAR 0 4
58989: PPUSH
58990: EMPTY
58991: PPUSH
58992: CALL_OW 1
58996: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58997: LD_ADDR_EXP 69
59001: PUSH
59002: LD_EXP 69
59006: PPUSH
59007: LD_VAR 0 4
59011: PPUSH
59012: EMPTY
59013: PPUSH
59014: CALL_OW 1
59018: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
59019: LD_ADDR_EXP 70
59023: PUSH
59024: LD_EXP 70
59028: PPUSH
59029: LD_VAR 0 4
59033: PPUSH
59034: LD_INT 0
59036: PPUSH
59037: CALL_OW 1
59041: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
59042: LD_ADDR_EXP 71
59046: PUSH
59047: LD_EXP 71
59051: PPUSH
59052: LD_VAR 0 4
59056: PPUSH
59057: EMPTY
59058: PPUSH
59059: CALL_OW 1
59063: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
59064: LD_ADDR_EXP 72
59068: PUSH
59069: LD_EXP 72
59073: PPUSH
59074: LD_VAR 0 4
59078: PPUSH
59079: EMPTY
59080: PPUSH
59081: CALL_OW 1
59085: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
59086: LD_ADDR_EXP 73
59090: PUSH
59091: LD_EXP 73
59095: PPUSH
59096: LD_VAR 0 4
59100: PPUSH
59101: EMPTY
59102: PPUSH
59103: CALL_OW 1
59107: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
59108: LD_ADDR_EXP 74
59112: PUSH
59113: LD_EXP 74
59117: PPUSH
59118: LD_VAR 0 4
59122: PPUSH
59123: EMPTY
59124: PPUSH
59125: CALL_OW 1
59129: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
59130: LD_ADDR_EXP 75
59134: PUSH
59135: LD_EXP 75
59139: PPUSH
59140: LD_VAR 0 4
59144: PPUSH
59145: EMPTY
59146: PPUSH
59147: CALL_OW 1
59151: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59152: LD_ADDR_EXP 76
59156: PUSH
59157: LD_EXP 76
59161: PPUSH
59162: LD_VAR 0 4
59166: PPUSH
59167: EMPTY
59168: PPUSH
59169: CALL_OW 1
59173: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59174: LD_ADDR_EXP 77
59178: PUSH
59179: LD_EXP 77
59183: PPUSH
59184: LD_VAR 0 4
59188: PPUSH
59189: EMPTY
59190: PPUSH
59191: CALL_OW 1
59195: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59196: LD_ADDR_EXP 78
59200: PUSH
59201: LD_EXP 78
59205: PPUSH
59206: LD_VAR 0 4
59210: PPUSH
59211: EMPTY
59212: PPUSH
59213: CALL_OW 1
59217: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59218: LD_ADDR_EXP 79
59222: PUSH
59223: LD_EXP 79
59227: PPUSH
59228: LD_VAR 0 4
59232: PPUSH
59233: EMPTY
59234: PPUSH
59235: CALL_OW 1
59239: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59240: LD_ADDR_EXP 80
59244: PUSH
59245: LD_EXP 80
59249: PPUSH
59250: LD_VAR 0 4
59254: PPUSH
59255: EMPTY
59256: PPUSH
59257: CALL_OW 1
59261: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59262: LD_ADDR_EXP 81
59266: PUSH
59267: LD_EXP 81
59271: PPUSH
59272: LD_VAR 0 4
59276: PPUSH
59277: EMPTY
59278: PPUSH
59279: CALL_OW 1
59283: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59284: LD_ADDR_EXP 82
59288: PUSH
59289: LD_EXP 82
59293: PPUSH
59294: LD_VAR 0 4
59298: PPUSH
59299: EMPTY
59300: PPUSH
59301: CALL_OW 1
59305: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59306: LD_ADDR_EXP 83
59310: PUSH
59311: LD_EXP 83
59315: PPUSH
59316: LD_VAR 0 4
59320: PPUSH
59321: EMPTY
59322: PPUSH
59323: CALL_OW 1
59327: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
59328: LD_ADDR_EXP 84
59332: PUSH
59333: LD_EXP 84
59337: PPUSH
59338: LD_VAR 0 4
59342: PPUSH
59343: EMPTY
59344: PPUSH
59345: CALL_OW 1
59349: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59350: LD_ADDR_EXP 86
59354: PUSH
59355: LD_EXP 86
59359: PPUSH
59360: LD_VAR 0 4
59364: PPUSH
59365: EMPTY
59366: PPUSH
59367: CALL_OW 1
59371: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
59372: LD_ADDR_EXP 88
59376: PUSH
59377: LD_EXP 88
59381: PPUSH
59382: LD_VAR 0 4
59386: PPUSH
59387: EMPTY
59388: PPUSH
59389: CALL_OW 1
59393: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59394: LD_ADDR_EXP 89
59398: PUSH
59399: LD_EXP 89
59403: PPUSH
59404: LD_VAR 0 4
59408: PPUSH
59409: EMPTY
59410: PPUSH
59411: CALL_OW 1
59415: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59416: LD_ADDR_EXP 90
59420: PUSH
59421: LD_EXP 90
59425: PPUSH
59426: LD_VAR 0 4
59430: PPUSH
59431: EMPTY
59432: PPUSH
59433: CALL_OW 1
59437: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59438: LD_ADDR_EXP 91
59442: PUSH
59443: LD_EXP 91
59447: PPUSH
59448: LD_VAR 0 4
59452: PPUSH
59453: EMPTY
59454: PPUSH
59455: CALL_OW 1
59459: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59460: LD_ADDR_EXP 92
59464: PUSH
59465: LD_EXP 92
59469: PPUSH
59470: LD_VAR 0 4
59474: PPUSH
59475: EMPTY
59476: PPUSH
59477: CALL_OW 1
59481: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59482: LD_ADDR_EXP 93
59486: PUSH
59487: LD_EXP 93
59491: PPUSH
59492: LD_VAR 0 4
59496: PPUSH
59497: EMPTY
59498: PPUSH
59499: CALL_OW 1
59503: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59504: LD_ADDR_EXP 94
59508: PUSH
59509: LD_EXP 94
59513: PPUSH
59514: LD_VAR 0 4
59518: PPUSH
59519: EMPTY
59520: PPUSH
59521: CALL_OW 1
59525: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59526: LD_ADDR_EXP 95
59530: PUSH
59531: LD_EXP 95
59535: PPUSH
59536: LD_VAR 0 4
59540: PPUSH
59541: EMPTY
59542: PPUSH
59543: CALL_OW 1
59547: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59548: LD_ADDR_EXP 96
59552: PUSH
59553: LD_EXP 96
59557: PPUSH
59558: LD_VAR 0 4
59562: PPUSH
59563: EMPTY
59564: PPUSH
59565: CALL_OW 1
59569: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59570: LD_ADDR_EXP 97
59574: PUSH
59575: LD_EXP 97
59579: PPUSH
59580: LD_VAR 0 4
59584: PPUSH
59585: EMPTY
59586: PPUSH
59587: CALL_OW 1
59591: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59592: LD_ADDR_EXP 98
59596: PUSH
59597: LD_EXP 98
59601: PPUSH
59602: LD_VAR 0 4
59606: PPUSH
59607: EMPTY
59608: PPUSH
59609: CALL_OW 1
59613: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59614: LD_ADDR_EXP 99
59618: PUSH
59619: LD_EXP 99
59623: PPUSH
59624: LD_VAR 0 4
59628: PPUSH
59629: EMPTY
59630: PPUSH
59631: CALL_OW 1
59635: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59636: LD_ADDR_EXP 100
59640: PUSH
59641: LD_EXP 100
59645: PPUSH
59646: LD_VAR 0 4
59650: PPUSH
59651: EMPTY
59652: PPUSH
59653: CALL_OW 1
59657: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59658: LD_ADDR_EXP 101
59662: PUSH
59663: LD_EXP 101
59667: PPUSH
59668: LD_VAR 0 4
59672: PPUSH
59673: LD_INT 0
59675: PPUSH
59676: CALL_OW 1
59680: ST_TO_ADDR
// result := base ;
59681: LD_ADDR_VAR 0 3
59685: PUSH
59686: LD_VAR 0 4
59690: ST_TO_ADDR
// end ;
59691: LD_VAR 0 3
59695: RET
// export function MC_Start ( ) ; var i ; begin
59696: LD_INT 0
59698: PPUSH
59699: PPUSH
// for i = 1 to mc_bases do
59700: LD_ADDR_VAR 0 2
59704: PUSH
59705: DOUBLE
59706: LD_INT 1
59708: DEC
59709: ST_TO_ADDR
59710: LD_EXP 59
59714: PUSH
59715: FOR_TO
59716: IFFALSE 60793
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59718: LD_ADDR_EXP 59
59722: PUSH
59723: LD_EXP 59
59727: PPUSH
59728: LD_VAR 0 2
59732: PPUSH
59733: LD_EXP 59
59737: PUSH
59738: LD_VAR 0 2
59742: ARRAY
59743: PUSH
59744: LD_INT 0
59746: DIFF
59747: PPUSH
59748: CALL_OW 1
59752: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59753: LD_ADDR_EXP 60
59757: PUSH
59758: LD_EXP 60
59762: PPUSH
59763: LD_VAR 0 2
59767: PPUSH
59768: EMPTY
59769: PPUSH
59770: CALL_OW 1
59774: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59775: LD_ADDR_EXP 61
59779: PUSH
59780: LD_EXP 61
59784: PPUSH
59785: LD_VAR 0 2
59789: PPUSH
59790: EMPTY
59791: PPUSH
59792: CALL_OW 1
59796: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59797: LD_ADDR_EXP 62
59801: PUSH
59802: LD_EXP 62
59806: PPUSH
59807: LD_VAR 0 2
59811: PPUSH
59812: EMPTY
59813: PPUSH
59814: CALL_OW 1
59818: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59819: LD_ADDR_EXP 63
59823: PUSH
59824: LD_EXP 63
59828: PPUSH
59829: LD_VAR 0 2
59833: PPUSH
59834: EMPTY
59835: PUSH
59836: EMPTY
59837: PUSH
59838: EMPTY
59839: LIST
59840: LIST
59841: PPUSH
59842: CALL_OW 1
59846: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59847: LD_ADDR_EXP 64
59851: PUSH
59852: LD_EXP 64
59856: PPUSH
59857: LD_VAR 0 2
59861: PPUSH
59862: EMPTY
59863: PPUSH
59864: CALL_OW 1
59868: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59869: LD_ADDR_EXP 91
59873: PUSH
59874: LD_EXP 91
59878: PPUSH
59879: LD_VAR 0 2
59883: PPUSH
59884: EMPTY
59885: PPUSH
59886: CALL_OW 1
59890: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59891: LD_ADDR_EXP 65
59895: PUSH
59896: LD_EXP 65
59900: PPUSH
59901: LD_VAR 0 2
59905: PPUSH
59906: EMPTY
59907: PPUSH
59908: CALL_OW 1
59912: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59913: LD_ADDR_EXP 66
59917: PUSH
59918: LD_EXP 66
59922: PPUSH
59923: LD_VAR 0 2
59927: PPUSH
59928: EMPTY
59929: PPUSH
59930: CALL_OW 1
59934: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59935: LD_ADDR_EXP 67
59939: PUSH
59940: LD_EXP 67
59944: PPUSH
59945: LD_VAR 0 2
59949: PPUSH
59950: LD_EXP 59
59954: PUSH
59955: LD_VAR 0 2
59959: ARRAY
59960: PPUSH
59961: LD_INT 2
59963: PUSH
59964: LD_INT 30
59966: PUSH
59967: LD_INT 32
59969: PUSH
59970: EMPTY
59971: LIST
59972: LIST
59973: PUSH
59974: LD_INT 30
59976: PUSH
59977: LD_INT 33
59979: PUSH
59980: EMPTY
59981: LIST
59982: LIST
59983: PUSH
59984: EMPTY
59985: LIST
59986: LIST
59987: LIST
59988: PPUSH
59989: CALL_OW 72
59993: PPUSH
59994: CALL_OW 1
59998: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59999: LD_ADDR_EXP 68
60003: PUSH
60004: LD_EXP 68
60008: PPUSH
60009: LD_VAR 0 2
60013: PPUSH
60014: LD_EXP 59
60018: PUSH
60019: LD_VAR 0 2
60023: ARRAY
60024: PPUSH
60025: LD_INT 2
60027: PUSH
60028: LD_INT 30
60030: PUSH
60031: LD_INT 32
60033: PUSH
60034: EMPTY
60035: LIST
60036: LIST
60037: PUSH
60038: LD_INT 30
60040: PUSH
60041: LD_INT 31
60043: PUSH
60044: EMPTY
60045: LIST
60046: LIST
60047: PUSH
60048: EMPTY
60049: LIST
60050: LIST
60051: LIST
60052: PUSH
60053: LD_INT 58
60055: PUSH
60056: EMPTY
60057: LIST
60058: PUSH
60059: EMPTY
60060: LIST
60061: LIST
60062: PPUSH
60063: CALL_OW 72
60067: PPUSH
60068: CALL_OW 1
60072: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
60073: LD_ADDR_EXP 69
60077: PUSH
60078: LD_EXP 69
60082: PPUSH
60083: LD_VAR 0 2
60087: PPUSH
60088: EMPTY
60089: PPUSH
60090: CALL_OW 1
60094: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
60095: LD_ADDR_EXP 73
60099: PUSH
60100: LD_EXP 73
60104: PPUSH
60105: LD_VAR 0 2
60109: PPUSH
60110: EMPTY
60111: PPUSH
60112: CALL_OW 1
60116: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
60117: LD_ADDR_EXP 72
60121: PUSH
60122: LD_EXP 72
60126: PPUSH
60127: LD_VAR 0 2
60131: PPUSH
60132: EMPTY
60133: PPUSH
60134: CALL_OW 1
60138: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
60139: LD_ADDR_EXP 74
60143: PUSH
60144: LD_EXP 74
60148: PPUSH
60149: LD_VAR 0 2
60153: PPUSH
60154: EMPTY
60155: PPUSH
60156: CALL_OW 1
60160: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
60161: LD_ADDR_EXP 75
60165: PUSH
60166: LD_EXP 75
60170: PPUSH
60171: LD_VAR 0 2
60175: PPUSH
60176: EMPTY
60177: PPUSH
60178: CALL_OW 1
60182: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60183: LD_ADDR_EXP 76
60187: PUSH
60188: LD_EXP 76
60192: PPUSH
60193: LD_VAR 0 2
60197: PPUSH
60198: EMPTY
60199: PPUSH
60200: CALL_OW 1
60204: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
60205: LD_ADDR_EXP 77
60209: PUSH
60210: LD_EXP 77
60214: PPUSH
60215: LD_VAR 0 2
60219: PPUSH
60220: EMPTY
60221: PPUSH
60222: CALL_OW 1
60226: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
60227: LD_ADDR_EXP 78
60231: PUSH
60232: LD_EXP 78
60236: PPUSH
60237: LD_VAR 0 2
60241: PPUSH
60242: EMPTY
60243: PPUSH
60244: CALL_OW 1
60248: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
60249: LD_ADDR_EXP 79
60253: PUSH
60254: LD_EXP 79
60258: PPUSH
60259: LD_VAR 0 2
60263: PPUSH
60264: EMPTY
60265: PPUSH
60266: CALL_OW 1
60270: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
60271: LD_ADDR_EXP 80
60275: PUSH
60276: LD_EXP 80
60280: PPUSH
60281: LD_VAR 0 2
60285: PPUSH
60286: EMPTY
60287: PPUSH
60288: CALL_OW 1
60292: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
60293: LD_ADDR_EXP 81
60297: PUSH
60298: LD_EXP 81
60302: PPUSH
60303: LD_VAR 0 2
60307: PPUSH
60308: EMPTY
60309: PPUSH
60310: CALL_OW 1
60314: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
60315: LD_ADDR_EXP 70
60319: PUSH
60320: LD_EXP 70
60324: PPUSH
60325: LD_VAR 0 2
60329: PPUSH
60330: LD_INT 0
60332: PPUSH
60333: CALL_OW 1
60337: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
60338: LD_ADDR_EXP 83
60342: PUSH
60343: LD_EXP 83
60347: PPUSH
60348: LD_VAR 0 2
60352: PPUSH
60353: LD_INT 0
60355: PPUSH
60356: CALL_OW 1
60360: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
60361: LD_ADDR_EXP 71
60365: PUSH
60366: LD_EXP 71
60370: PPUSH
60371: LD_VAR 0 2
60375: PPUSH
60376: EMPTY
60377: PPUSH
60378: CALL_OW 1
60382: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
60383: LD_ADDR_EXP 82
60387: PUSH
60388: LD_EXP 82
60392: PPUSH
60393: LD_VAR 0 2
60397: PPUSH
60398: LD_INT 0
60400: PPUSH
60401: CALL_OW 1
60405: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
60406: LD_ADDR_EXP 84
60410: PUSH
60411: LD_EXP 84
60415: PPUSH
60416: LD_VAR 0 2
60420: PPUSH
60421: EMPTY
60422: PPUSH
60423: CALL_OW 1
60427: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
60428: LD_ADDR_EXP 87
60432: PUSH
60433: LD_EXP 87
60437: PPUSH
60438: LD_VAR 0 2
60442: PPUSH
60443: LD_INT 0
60445: PPUSH
60446: CALL_OW 1
60450: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
60451: LD_ADDR_EXP 88
60455: PUSH
60456: LD_EXP 88
60460: PPUSH
60461: LD_VAR 0 2
60465: PPUSH
60466: EMPTY
60467: PPUSH
60468: CALL_OW 1
60472: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60473: LD_ADDR_EXP 89
60477: PUSH
60478: LD_EXP 89
60482: PPUSH
60483: LD_VAR 0 2
60487: PPUSH
60488: EMPTY
60489: PPUSH
60490: CALL_OW 1
60494: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60495: LD_ADDR_EXP 90
60499: PUSH
60500: LD_EXP 90
60504: PPUSH
60505: LD_VAR 0 2
60509: PPUSH
60510: EMPTY
60511: PPUSH
60512: CALL_OW 1
60516: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60517: LD_ADDR_EXP 92
60521: PUSH
60522: LD_EXP 92
60526: PPUSH
60527: LD_VAR 0 2
60531: PPUSH
60532: LD_EXP 59
60536: PUSH
60537: LD_VAR 0 2
60541: ARRAY
60542: PPUSH
60543: LD_INT 2
60545: PUSH
60546: LD_INT 30
60548: PUSH
60549: LD_INT 6
60551: PUSH
60552: EMPTY
60553: LIST
60554: LIST
60555: PUSH
60556: LD_INT 30
60558: PUSH
60559: LD_INT 7
60561: PUSH
60562: EMPTY
60563: LIST
60564: LIST
60565: PUSH
60566: LD_INT 30
60568: PUSH
60569: LD_INT 8
60571: PUSH
60572: EMPTY
60573: LIST
60574: LIST
60575: PUSH
60576: EMPTY
60577: LIST
60578: LIST
60579: LIST
60580: LIST
60581: PPUSH
60582: CALL_OW 72
60586: PPUSH
60587: CALL_OW 1
60591: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60592: LD_ADDR_EXP 93
60596: PUSH
60597: LD_EXP 93
60601: PPUSH
60602: LD_VAR 0 2
60606: PPUSH
60607: EMPTY
60608: PPUSH
60609: CALL_OW 1
60613: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60614: LD_ADDR_EXP 94
60618: PUSH
60619: LD_EXP 94
60623: PPUSH
60624: LD_VAR 0 2
60628: PPUSH
60629: EMPTY
60630: PPUSH
60631: CALL_OW 1
60635: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60636: LD_ADDR_EXP 95
60640: PUSH
60641: LD_EXP 95
60645: PPUSH
60646: LD_VAR 0 2
60650: PPUSH
60651: EMPTY
60652: PPUSH
60653: CALL_OW 1
60657: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60658: LD_ADDR_EXP 96
60662: PUSH
60663: LD_EXP 96
60667: PPUSH
60668: LD_VAR 0 2
60672: PPUSH
60673: EMPTY
60674: PPUSH
60675: CALL_OW 1
60679: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60680: LD_ADDR_EXP 97
60684: PUSH
60685: LD_EXP 97
60689: PPUSH
60690: LD_VAR 0 2
60694: PPUSH
60695: EMPTY
60696: PPUSH
60697: CALL_OW 1
60701: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60702: LD_ADDR_EXP 98
60706: PUSH
60707: LD_EXP 98
60711: PPUSH
60712: LD_VAR 0 2
60716: PPUSH
60717: EMPTY
60718: PPUSH
60719: CALL_OW 1
60723: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60724: LD_ADDR_EXP 99
60728: PUSH
60729: LD_EXP 99
60733: PPUSH
60734: LD_VAR 0 2
60738: PPUSH
60739: EMPTY
60740: PPUSH
60741: CALL_OW 1
60745: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60746: LD_ADDR_EXP 100
60750: PUSH
60751: LD_EXP 100
60755: PPUSH
60756: LD_VAR 0 2
60760: PPUSH
60761: EMPTY
60762: PPUSH
60763: CALL_OW 1
60767: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60768: LD_ADDR_EXP 101
60772: PUSH
60773: LD_EXP 101
60777: PPUSH
60778: LD_VAR 0 2
60782: PPUSH
60783: LD_INT 0
60785: PPUSH
60786: CALL_OW 1
60790: ST_TO_ADDR
// end ;
60791: GO 59715
60793: POP
60794: POP
// MC_InitSides ( ) ;
60795: CALL 61081 0 0
// MC_InitResearch ( ) ;
60799: CALL 60820 0 0
// CustomInitMacro ( ) ;
60803: CALL 181 0 0
// skirmish := true ;
60807: LD_ADDR_EXP 57
60811: PUSH
60812: LD_INT 1
60814: ST_TO_ADDR
// end ;
60815: LD_VAR 0 1
60819: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60820: LD_INT 0
60822: PPUSH
60823: PPUSH
60824: PPUSH
60825: PPUSH
60826: PPUSH
60827: PPUSH
// if not mc_bases then
60828: LD_EXP 59
60832: NOT
60833: IFFALSE 60837
// exit ;
60835: GO 61076
// for i = 1 to 8 do
60837: LD_ADDR_VAR 0 2
60841: PUSH
60842: DOUBLE
60843: LD_INT 1
60845: DEC
60846: ST_TO_ADDR
60847: LD_INT 8
60849: PUSH
60850: FOR_TO
60851: IFFALSE 60877
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60853: LD_ADDR_EXP 86
60857: PUSH
60858: LD_EXP 86
60862: PPUSH
60863: LD_VAR 0 2
60867: PPUSH
60868: EMPTY
60869: PPUSH
60870: CALL_OW 1
60874: ST_TO_ADDR
60875: GO 60850
60877: POP
60878: POP
// tmp := [ ] ;
60879: LD_ADDR_VAR 0 5
60883: PUSH
60884: EMPTY
60885: ST_TO_ADDR
// for i = 1 to mc_sides do
60886: LD_ADDR_VAR 0 2
60890: PUSH
60891: DOUBLE
60892: LD_INT 1
60894: DEC
60895: ST_TO_ADDR
60896: LD_EXP 85
60900: PUSH
60901: FOR_TO
60902: IFFALSE 60960
// if not mc_sides [ i ] in tmp then
60904: LD_EXP 85
60908: PUSH
60909: LD_VAR 0 2
60913: ARRAY
60914: PUSH
60915: LD_VAR 0 5
60919: IN
60920: NOT
60921: IFFALSE 60958
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60923: LD_ADDR_VAR 0 5
60927: PUSH
60928: LD_VAR 0 5
60932: PPUSH
60933: LD_VAR 0 5
60937: PUSH
60938: LD_INT 1
60940: PLUS
60941: PPUSH
60942: LD_EXP 85
60946: PUSH
60947: LD_VAR 0 2
60951: ARRAY
60952: PPUSH
60953: CALL_OW 2
60957: ST_TO_ADDR
60958: GO 60901
60960: POP
60961: POP
// if not tmp then
60962: LD_VAR 0 5
60966: NOT
60967: IFFALSE 60971
// exit ;
60969: GO 61076
// for j in tmp do
60971: LD_ADDR_VAR 0 3
60975: PUSH
60976: LD_VAR 0 5
60980: PUSH
60981: FOR_IN
60982: IFFALSE 61074
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60984: LD_ADDR_VAR 0 6
60988: PUSH
60989: LD_INT 22
60991: PUSH
60992: LD_VAR 0 3
60996: PUSH
60997: EMPTY
60998: LIST
60999: LIST
61000: PPUSH
61001: CALL_OW 69
61005: ST_TO_ADDR
// if not un then
61006: LD_VAR 0 6
61010: NOT
61011: IFFALSE 61015
// continue ;
61013: GO 60981
// nation := GetNation ( un [ 1 ] ) ;
61015: LD_ADDR_VAR 0 4
61019: PUSH
61020: LD_VAR 0 6
61024: PUSH
61025: LD_INT 1
61027: ARRAY
61028: PPUSH
61029: CALL_OW 248
61033: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
61034: LD_ADDR_EXP 86
61038: PUSH
61039: LD_EXP 86
61043: PPUSH
61044: LD_VAR 0 3
61048: PPUSH
61049: LD_VAR 0 3
61053: PPUSH
61054: LD_VAR 0 4
61058: PPUSH
61059: LD_INT 1
61061: PPUSH
61062: CALL 14355 0 3
61066: PPUSH
61067: CALL_OW 1
61071: ST_TO_ADDR
// end ;
61072: GO 60981
61074: POP
61075: POP
// end ;
61076: LD_VAR 0 1
61080: RET
// export function MC_InitSides ( ) ; var i ; begin
61081: LD_INT 0
61083: PPUSH
61084: PPUSH
// if not mc_bases then
61085: LD_EXP 59
61089: NOT
61090: IFFALSE 61094
// exit ;
61092: GO 61168
// for i = 1 to mc_bases do
61094: LD_ADDR_VAR 0 2
61098: PUSH
61099: DOUBLE
61100: LD_INT 1
61102: DEC
61103: ST_TO_ADDR
61104: LD_EXP 59
61108: PUSH
61109: FOR_TO
61110: IFFALSE 61166
// if mc_bases [ i ] then
61112: LD_EXP 59
61116: PUSH
61117: LD_VAR 0 2
61121: ARRAY
61122: IFFALSE 61164
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
61124: LD_ADDR_EXP 85
61128: PUSH
61129: LD_EXP 85
61133: PPUSH
61134: LD_VAR 0 2
61138: PPUSH
61139: LD_EXP 59
61143: PUSH
61144: LD_VAR 0 2
61148: ARRAY
61149: PUSH
61150: LD_INT 1
61152: ARRAY
61153: PPUSH
61154: CALL_OW 255
61158: PPUSH
61159: CALL_OW 1
61163: ST_TO_ADDR
61164: GO 61109
61166: POP
61167: POP
// end ;
61168: LD_VAR 0 1
61172: RET
// every 0 0$01 trigger skirmish do
61173: LD_EXP 57
61177: IFFALSE 61331
61179: GO 61181
61181: DISABLE
// begin enable ;
61182: ENABLE
// MC_CheckBuildings ( ) ;
61183: CALL 65829 0 0
// MC_CheckPeopleLife ( ) ;
61187: CALL 65954 0 0
// RaiseSailEvent ( 100 ) ;
61191: LD_INT 100
61193: PPUSH
61194: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
61198: LD_INT 103
61200: PPUSH
61201: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
61205: LD_INT 104
61207: PPUSH
61208: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
61212: LD_INT 105
61214: PPUSH
61215: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
61219: LD_INT 106
61221: PPUSH
61222: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
61226: LD_INT 107
61228: PPUSH
61229: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
61233: LD_INT 108
61235: PPUSH
61236: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
61240: LD_INT 109
61242: PPUSH
61243: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
61247: LD_INT 110
61249: PPUSH
61250: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
61254: LD_INT 111
61256: PPUSH
61257: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
61261: LD_INT 112
61263: PPUSH
61264: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
61268: LD_INT 113
61270: PPUSH
61271: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
61275: LD_INT 120
61277: PPUSH
61278: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
61282: LD_INT 121
61284: PPUSH
61285: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
61289: LD_INT 122
61291: PPUSH
61292: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
61296: LD_INT 123
61298: PPUSH
61299: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
61303: LD_INT 124
61305: PPUSH
61306: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
61310: LD_INT 125
61312: PPUSH
61313: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
61317: LD_INT 126
61319: PPUSH
61320: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
61324: LD_INT 200
61326: PPUSH
61327: CALL_OW 427
// end ;
61331: END
// on SailEvent ( event ) do begin if event < 100 then
61332: LD_VAR 0 1
61336: PUSH
61337: LD_INT 100
61339: LESS
61340: IFFALSE 61351
// CustomEvent ( event ) ;
61342: LD_VAR 0 1
61346: PPUSH
61347: CALL 13013 0 1
// if event = 100 then
61351: LD_VAR 0 1
61355: PUSH
61356: LD_INT 100
61358: EQUAL
61359: IFFALSE 61365
// MC_ClassManager ( ) ;
61361: CALL 61757 0 0
// if event = 101 then
61365: LD_VAR 0 1
61369: PUSH
61370: LD_INT 101
61372: EQUAL
61373: IFFALSE 61379
// MC_RepairBuildings ( ) ;
61375: CALL 66550 0 0
// if event = 102 then
61379: LD_VAR 0 1
61383: PUSH
61384: LD_INT 102
61386: EQUAL
61387: IFFALSE 61393
// MC_Heal ( ) ;
61389: CALL 67414 0 0
// if event = 103 then
61393: LD_VAR 0 1
61397: PUSH
61398: LD_INT 103
61400: EQUAL
61401: IFFALSE 61407
// MC_Build ( ) ;
61403: CALL 67836 0 0
// if event = 104 then
61407: LD_VAR 0 1
61411: PUSH
61412: LD_INT 104
61414: EQUAL
61415: IFFALSE 61421
// MC_TurretWeapon ( ) ;
61417: CALL 69449 0 0
// if event = 105 then
61421: LD_VAR 0 1
61425: PUSH
61426: LD_INT 105
61428: EQUAL
61429: IFFALSE 61435
// MC_BuildUpgrade ( ) ;
61431: CALL 69000 0 0
// if event = 106 then
61435: LD_VAR 0 1
61439: PUSH
61440: LD_INT 106
61442: EQUAL
61443: IFFALSE 61449
// MC_PlantMines ( ) ;
61445: CALL 69879 0 0
// if event = 107 then
61449: LD_VAR 0 1
61453: PUSH
61454: LD_INT 107
61456: EQUAL
61457: IFFALSE 61463
// MC_CollectCrates ( ) ;
61459: CALL 70677 0 0
// if event = 108 then
61463: LD_VAR 0 1
61467: PUSH
61468: LD_INT 108
61470: EQUAL
61471: IFFALSE 61477
// MC_LinkRemoteControl ( ) ;
61473: CALL 72453 0 0
// if event = 109 then
61477: LD_VAR 0 1
61481: PUSH
61482: LD_INT 109
61484: EQUAL
61485: IFFALSE 61491
// MC_ProduceVehicle ( ) ;
61487: CALL 72634 0 0
// if event = 110 then
61491: LD_VAR 0 1
61495: PUSH
61496: LD_INT 110
61498: EQUAL
61499: IFFALSE 61505
// MC_SendAttack ( ) ;
61501: CALL 73100 0 0
// if event = 111 then
61505: LD_VAR 0 1
61509: PUSH
61510: LD_INT 111
61512: EQUAL
61513: IFFALSE 61519
// MC_Defend ( ) ;
61515: CALL 73208 0 0
// if event = 112 then
61519: LD_VAR 0 1
61523: PUSH
61524: LD_INT 112
61526: EQUAL
61527: IFFALSE 61533
// MC_Research ( ) ;
61529: CALL 73813 0 0
// if event = 113 then
61533: LD_VAR 0 1
61537: PUSH
61538: LD_INT 113
61540: EQUAL
61541: IFFALSE 61547
// MC_MinesTrigger ( ) ;
61543: CALL 74927 0 0
// if event = 120 then
61547: LD_VAR 0 1
61551: PUSH
61552: LD_INT 120
61554: EQUAL
61555: IFFALSE 61561
// MC_RepairVehicle ( ) ;
61557: CALL 75026 0 0
// if event = 121 then
61561: LD_VAR 0 1
61565: PUSH
61566: LD_INT 121
61568: EQUAL
61569: IFFALSE 61575
// MC_TameApe ( ) ;
61571: CALL 75756 0 0
// if event = 122 then
61575: LD_VAR 0 1
61579: PUSH
61580: LD_INT 122
61582: EQUAL
61583: IFFALSE 61589
// MC_ChangeApeClass ( ) ;
61585: CALL 76585 0 0
// if event = 123 then
61589: LD_VAR 0 1
61593: PUSH
61594: LD_INT 123
61596: EQUAL
61597: IFFALSE 61603
// MC_Bazooka ( ) ;
61599: CALL 77235 0 0
// if event = 124 then
61603: LD_VAR 0 1
61607: PUSH
61608: LD_INT 124
61610: EQUAL
61611: IFFALSE 61617
// MC_TeleportExit ( ) ;
61613: CALL 77433 0 0
// if event = 125 then
61617: LD_VAR 0 1
61621: PUSH
61622: LD_INT 125
61624: EQUAL
61625: IFFALSE 61631
// MC_Deposits ( ) ;
61627: CALL 78080 0 0
// if event = 126 then
61631: LD_VAR 0 1
61635: PUSH
61636: LD_INT 126
61638: EQUAL
61639: IFFALSE 61645
// MC_RemoteDriver ( ) ;
61641: CALL 78705 0 0
// if event = 200 then
61645: LD_VAR 0 1
61649: PUSH
61650: LD_INT 200
61652: EQUAL
61653: IFFALSE 61659
// MC_Idle ( ) ;
61655: CALL 80654 0 0
// end ;
61659: PPOPN 1
61661: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61662: LD_INT 0
61664: PPUSH
61665: PPUSH
// if not mc_bases [ base ] or not tag then
61666: LD_EXP 59
61670: PUSH
61671: LD_VAR 0 1
61675: ARRAY
61676: NOT
61677: PUSH
61678: LD_VAR 0 2
61682: NOT
61683: OR
61684: IFFALSE 61688
// exit ;
61686: GO 61752
// for i in mc_bases [ base ] union mc_ape [ base ] do
61688: LD_ADDR_VAR 0 4
61692: PUSH
61693: LD_EXP 59
61697: PUSH
61698: LD_VAR 0 1
61702: ARRAY
61703: PUSH
61704: LD_EXP 88
61708: PUSH
61709: LD_VAR 0 1
61713: ARRAY
61714: UNION
61715: PUSH
61716: FOR_IN
61717: IFFALSE 61750
// if GetTag ( i ) = tag then
61719: LD_VAR 0 4
61723: PPUSH
61724: CALL_OW 110
61728: PUSH
61729: LD_VAR 0 2
61733: EQUAL
61734: IFFALSE 61748
// SetTag ( i , 0 ) ;
61736: LD_VAR 0 4
61740: PPUSH
61741: LD_INT 0
61743: PPUSH
61744: CALL_OW 109
61748: GO 61716
61750: POP
61751: POP
// end ;
61752: LD_VAR 0 3
61756: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61757: LD_INT 0
61759: PPUSH
61760: PPUSH
61761: PPUSH
61762: PPUSH
61763: PPUSH
61764: PPUSH
61765: PPUSH
61766: PPUSH
// if not mc_bases then
61767: LD_EXP 59
61771: NOT
61772: IFFALSE 61776
// exit ;
61774: GO 62234
// for i = 1 to mc_bases do
61776: LD_ADDR_VAR 0 2
61780: PUSH
61781: DOUBLE
61782: LD_INT 1
61784: DEC
61785: ST_TO_ADDR
61786: LD_EXP 59
61790: PUSH
61791: FOR_TO
61792: IFFALSE 62232
// begin tmp := MC_ClassCheckReq ( i ) ;
61794: LD_ADDR_VAR 0 4
61798: PUSH
61799: LD_VAR 0 2
61803: PPUSH
61804: CALL 62239 0 1
61808: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61809: LD_ADDR_EXP 100
61813: PUSH
61814: LD_EXP 100
61818: PPUSH
61819: LD_VAR 0 2
61823: PPUSH
61824: LD_VAR 0 4
61828: PPUSH
61829: CALL_OW 1
61833: ST_TO_ADDR
// if not tmp then
61834: LD_VAR 0 4
61838: NOT
61839: IFFALSE 61843
// continue ;
61841: GO 61791
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61843: LD_ADDR_VAR 0 6
61847: PUSH
61848: LD_EXP 59
61852: PUSH
61853: LD_VAR 0 2
61857: ARRAY
61858: PPUSH
61859: LD_INT 2
61861: PUSH
61862: LD_INT 30
61864: PUSH
61865: LD_INT 4
61867: PUSH
61868: EMPTY
61869: LIST
61870: LIST
61871: PUSH
61872: LD_INT 30
61874: PUSH
61875: LD_INT 5
61877: PUSH
61878: EMPTY
61879: LIST
61880: LIST
61881: PUSH
61882: EMPTY
61883: LIST
61884: LIST
61885: LIST
61886: PPUSH
61887: CALL_OW 72
61891: PUSH
61892: LD_EXP 59
61896: PUSH
61897: LD_VAR 0 2
61901: ARRAY
61902: PPUSH
61903: LD_INT 2
61905: PUSH
61906: LD_INT 30
61908: PUSH
61909: LD_INT 0
61911: PUSH
61912: EMPTY
61913: LIST
61914: LIST
61915: PUSH
61916: LD_INT 30
61918: PUSH
61919: LD_INT 1
61921: PUSH
61922: EMPTY
61923: LIST
61924: LIST
61925: PUSH
61926: EMPTY
61927: LIST
61928: LIST
61929: LIST
61930: PPUSH
61931: CALL_OW 72
61935: PUSH
61936: LD_EXP 59
61940: PUSH
61941: LD_VAR 0 2
61945: ARRAY
61946: PPUSH
61947: LD_INT 30
61949: PUSH
61950: LD_INT 3
61952: PUSH
61953: EMPTY
61954: LIST
61955: LIST
61956: PPUSH
61957: CALL_OW 72
61961: PUSH
61962: LD_EXP 59
61966: PUSH
61967: LD_VAR 0 2
61971: ARRAY
61972: PPUSH
61973: LD_INT 2
61975: PUSH
61976: LD_INT 30
61978: PUSH
61979: LD_INT 6
61981: PUSH
61982: EMPTY
61983: LIST
61984: LIST
61985: PUSH
61986: LD_INT 30
61988: PUSH
61989: LD_INT 7
61991: PUSH
61992: EMPTY
61993: LIST
61994: LIST
61995: PUSH
61996: LD_INT 30
61998: PUSH
61999: LD_INT 8
62001: PUSH
62002: EMPTY
62003: LIST
62004: LIST
62005: PUSH
62006: EMPTY
62007: LIST
62008: LIST
62009: LIST
62010: LIST
62011: PPUSH
62012: CALL_OW 72
62016: PUSH
62017: EMPTY
62018: LIST
62019: LIST
62020: LIST
62021: LIST
62022: ST_TO_ADDR
// for j = 1 to 4 do
62023: LD_ADDR_VAR 0 3
62027: PUSH
62028: DOUBLE
62029: LD_INT 1
62031: DEC
62032: ST_TO_ADDR
62033: LD_INT 4
62035: PUSH
62036: FOR_TO
62037: IFFALSE 62228
// begin if not tmp [ j ] then
62039: LD_VAR 0 4
62043: PUSH
62044: LD_VAR 0 3
62048: ARRAY
62049: NOT
62050: IFFALSE 62054
// continue ;
62052: GO 62036
// for p in tmp [ j ] do
62054: LD_ADDR_VAR 0 5
62058: PUSH
62059: LD_VAR 0 4
62063: PUSH
62064: LD_VAR 0 3
62068: ARRAY
62069: PUSH
62070: FOR_IN
62071: IFFALSE 62224
// begin if not b [ j ] then
62073: LD_VAR 0 6
62077: PUSH
62078: LD_VAR 0 3
62082: ARRAY
62083: NOT
62084: IFFALSE 62088
// break ;
62086: GO 62224
// e := 0 ;
62088: LD_ADDR_VAR 0 7
62092: PUSH
62093: LD_INT 0
62095: ST_TO_ADDR
// for k in b [ j ] do
62096: LD_ADDR_VAR 0 8
62100: PUSH
62101: LD_VAR 0 6
62105: PUSH
62106: LD_VAR 0 3
62110: ARRAY
62111: PUSH
62112: FOR_IN
62113: IFFALSE 62140
// if IsNotFull ( k ) then
62115: LD_VAR 0 8
62119: PPUSH
62120: CALL 18915 0 1
62124: IFFALSE 62138
// begin e := k ;
62126: LD_ADDR_VAR 0 7
62130: PUSH
62131: LD_VAR 0 8
62135: ST_TO_ADDR
// break ;
62136: GO 62140
// end ;
62138: GO 62112
62140: POP
62141: POP
// if e and not UnitGoingToBuilding ( p , e ) then
62142: LD_VAR 0 7
62146: PUSH
62147: LD_VAR 0 5
62151: PPUSH
62152: LD_VAR 0 7
62156: PPUSH
62157: CALL 56044 0 2
62161: NOT
62162: AND
62163: IFFALSE 62222
// begin if IsInUnit ( p ) then
62165: LD_VAR 0 5
62169: PPUSH
62170: CALL_OW 310
62174: IFFALSE 62185
// ComExitBuilding ( p ) ;
62176: LD_VAR 0 5
62180: PPUSH
62181: CALL_OW 122
// ComEnterUnit ( p , e ) ;
62185: LD_VAR 0 5
62189: PPUSH
62190: LD_VAR 0 7
62194: PPUSH
62195: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
62199: LD_VAR 0 5
62203: PPUSH
62204: LD_VAR 0 3
62208: PPUSH
62209: CALL_OW 183
// AddComExitBuilding ( p ) ;
62213: LD_VAR 0 5
62217: PPUSH
62218: CALL_OW 182
// end ; end ;
62222: GO 62070
62224: POP
62225: POP
// end ;
62226: GO 62036
62228: POP
62229: POP
// end ;
62230: GO 61791
62232: POP
62233: POP
// end ;
62234: LD_VAR 0 1
62238: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
62239: LD_INT 0
62241: PPUSH
62242: PPUSH
62243: PPUSH
62244: PPUSH
62245: PPUSH
62246: PPUSH
62247: PPUSH
62248: PPUSH
62249: PPUSH
62250: PPUSH
62251: PPUSH
62252: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62253: LD_VAR 0 1
62257: NOT
62258: PUSH
62259: LD_EXP 59
62263: PUSH
62264: LD_VAR 0 1
62268: ARRAY
62269: NOT
62270: OR
62271: PUSH
62272: LD_EXP 59
62276: PUSH
62277: LD_VAR 0 1
62281: ARRAY
62282: PPUSH
62283: LD_INT 2
62285: PUSH
62286: LD_INT 30
62288: PUSH
62289: LD_INT 0
62291: PUSH
62292: EMPTY
62293: LIST
62294: LIST
62295: PUSH
62296: LD_INT 30
62298: PUSH
62299: LD_INT 1
62301: PUSH
62302: EMPTY
62303: LIST
62304: LIST
62305: PUSH
62306: EMPTY
62307: LIST
62308: LIST
62309: LIST
62310: PPUSH
62311: CALL_OW 72
62315: NOT
62316: OR
62317: IFFALSE 62321
// exit ;
62319: GO 65824
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62321: LD_ADDR_VAR 0 4
62325: PUSH
62326: LD_EXP 59
62330: PUSH
62331: LD_VAR 0 1
62335: ARRAY
62336: PPUSH
62337: LD_INT 2
62339: PUSH
62340: LD_INT 25
62342: PUSH
62343: LD_INT 1
62345: PUSH
62346: EMPTY
62347: LIST
62348: LIST
62349: PUSH
62350: LD_INT 25
62352: PUSH
62353: LD_INT 2
62355: PUSH
62356: EMPTY
62357: LIST
62358: LIST
62359: PUSH
62360: LD_INT 25
62362: PUSH
62363: LD_INT 3
62365: PUSH
62366: EMPTY
62367: LIST
62368: LIST
62369: PUSH
62370: LD_INT 25
62372: PUSH
62373: LD_INT 4
62375: PUSH
62376: EMPTY
62377: LIST
62378: LIST
62379: PUSH
62380: LD_INT 25
62382: PUSH
62383: LD_INT 5
62385: PUSH
62386: EMPTY
62387: LIST
62388: LIST
62389: PUSH
62390: LD_INT 25
62392: PUSH
62393: LD_INT 8
62395: PUSH
62396: EMPTY
62397: LIST
62398: LIST
62399: PUSH
62400: LD_INT 25
62402: PUSH
62403: LD_INT 9
62405: PUSH
62406: EMPTY
62407: LIST
62408: LIST
62409: PUSH
62410: EMPTY
62411: LIST
62412: LIST
62413: LIST
62414: LIST
62415: LIST
62416: LIST
62417: LIST
62418: LIST
62419: PPUSH
62420: CALL_OW 72
62424: ST_TO_ADDR
// if not tmp then
62425: LD_VAR 0 4
62429: NOT
62430: IFFALSE 62434
// exit ;
62432: GO 65824
// for i in tmp do
62434: LD_ADDR_VAR 0 3
62438: PUSH
62439: LD_VAR 0 4
62443: PUSH
62444: FOR_IN
62445: IFFALSE 62476
// if GetTag ( i ) then
62447: LD_VAR 0 3
62451: PPUSH
62452: CALL_OW 110
62456: IFFALSE 62474
// tmp := tmp diff i ;
62458: LD_ADDR_VAR 0 4
62462: PUSH
62463: LD_VAR 0 4
62467: PUSH
62468: LD_VAR 0 3
62472: DIFF
62473: ST_TO_ADDR
62474: GO 62444
62476: POP
62477: POP
// if not tmp then
62478: LD_VAR 0 4
62482: NOT
62483: IFFALSE 62487
// exit ;
62485: GO 65824
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62487: LD_ADDR_VAR 0 5
62491: PUSH
62492: LD_EXP 59
62496: PUSH
62497: LD_VAR 0 1
62501: ARRAY
62502: PPUSH
62503: LD_INT 2
62505: PUSH
62506: LD_INT 25
62508: PUSH
62509: LD_INT 1
62511: PUSH
62512: EMPTY
62513: LIST
62514: LIST
62515: PUSH
62516: LD_INT 25
62518: PUSH
62519: LD_INT 5
62521: PUSH
62522: EMPTY
62523: LIST
62524: LIST
62525: PUSH
62526: LD_INT 25
62528: PUSH
62529: LD_INT 8
62531: PUSH
62532: EMPTY
62533: LIST
62534: LIST
62535: PUSH
62536: LD_INT 25
62538: PUSH
62539: LD_INT 9
62541: PUSH
62542: EMPTY
62543: LIST
62544: LIST
62545: PUSH
62546: EMPTY
62547: LIST
62548: LIST
62549: LIST
62550: LIST
62551: LIST
62552: PPUSH
62553: CALL_OW 72
62557: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62558: LD_ADDR_VAR 0 6
62562: PUSH
62563: LD_EXP 59
62567: PUSH
62568: LD_VAR 0 1
62572: ARRAY
62573: PPUSH
62574: LD_INT 25
62576: PUSH
62577: LD_INT 2
62579: PUSH
62580: EMPTY
62581: LIST
62582: LIST
62583: PPUSH
62584: CALL_OW 72
62588: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62589: LD_ADDR_VAR 0 7
62593: PUSH
62594: LD_EXP 59
62598: PUSH
62599: LD_VAR 0 1
62603: ARRAY
62604: PPUSH
62605: LD_INT 25
62607: PUSH
62608: LD_INT 3
62610: PUSH
62611: EMPTY
62612: LIST
62613: LIST
62614: PPUSH
62615: CALL_OW 72
62619: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62620: LD_ADDR_VAR 0 8
62624: PUSH
62625: LD_EXP 59
62629: PUSH
62630: LD_VAR 0 1
62634: ARRAY
62635: PPUSH
62636: LD_INT 25
62638: PUSH
62639: LD_INT 4
62641: PUSH
62642: EMPTY
62643: LIST
62644: LIST
62645: PUSH
62646: LD_INT 24
62648: PUSH
62649: LD_INT 251
62651: PUSH
62652: EMPTY
62653: LIST
62654: LIST
62655: PUSH
62656: EMPTY
62657: LIST
62658: LIST
62659: PPUSH
62660: CALL_OW 72
62664: ST_TO_ADDR
// if mc_scan [ base ] then
62665: LD_EXP 82
62669: PUSH
62670: LD_VAR 0 1
62674: ARRAY
62675: IFFALSE 63136
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62677: LD_ADDR_EXP 101
62681: PUSH
62682: LD_EXP 101
62686: PPUSH
62687: LD_VAR 0 1
62691: PPUSH
62692: LD_INT 4
62694: PPUSH
62695: CALL_OW 1
62699: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62700: LD_ADDR_VAR 0 12
62704: PUSH
62705: LD_EXP 59
62709: PUSH
62710: LD_VAR 0 1
62714: ARRAY
62715: PPUSH
62716: LD_INT 2
62718: PUSH
62719: LD_INT 30
62721: PUSH
62722: LD_INT 4
62724: PUSH
62725: EMPTY
62726: LIST
62727: LIST
62728: PUSH
62729: LD_INT 30
62731: PUSH
62732: LD_INT 5
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: PUSH
62739: EMPTY
62740: LIST
62741: LIST
62742: LIST
62743: PPUSH
62744: CALL_OW 72
62748: ST_TO_ADDR
// if not b then
62749: LD_VAR 0 12
62753: NOT
62754: IFFALSE 62758
// exit ;
62756: GO 65824
// p := [ ] ;
62758: LD_ADDR_VAR 0 11
62762: PUSH
62763: EMPTY
62764: ST_TO_ADDR
// if sci >= 2 then
62765: LD_VAR 0 8
62769: PUSH
62770: LD_INT 2
62772: GREATEREQUAL
62773: IFFALSE 62804
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62775: LD_ADDR_VAR 0 8
62779: PUSH
62780: LD_VAR 0 8
62784: PUSH
62785: LD_INT 1
62787: ARRAY
62788: PUSH
62789: LD_VAR 0 8
62793: PUSH
62794: LD_INT 2
62796: ARRAY
62797: PUSH
62798: EMPTY
62799: LIST
62800: LIST
62801: ST_TO_ADDR
62802: GO 62865
// if sci = 1 then
62804: LD_VAR 0 8
62808: PUSH
62809: LD_INT 1
62811: EQUAL
62812: IFFALSE 62833
// sci := [ sci [ 1 ] ] else
62814: LD_ADDR_VAR 0 8
62818: PUSH
62819: LD_VAR 0 8
62823: PUSH
62824: LD_INT 1
62826: ARRAY
62827: PUSH
62828: EMPTY
62829: LIST
62830: ST_TO_ADDR
62831: GO 62865
// if sci = 0 then
62833: LD_VAR 0 8
62837: PUSH
62838: LD_INT 0
62840: EQUAL
62841: IFFALSE 62865
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62843: LD_ADDR_VAR 0 11
62847: PUSH
62848: LD_VAR 0 4
62852: PPUSH
62853: LD_INT 4
62855: PPUSH
62856: CALL 55907 0 2
62860: PUSH
62861: LD_INT 1
62863: ARRAY
62864: ST_TO_ADDR
// if eng > 4 then
62865: LD_VAR 0 6
62869: PUSH
62870: LD_INT 4
62872: GREATER
62873: IFFALSE 62919
// for i = eng downto 4 do
62875: LD_ADDR_VAR 0 3
62879: PUSH
62880: DOUBLE
62881: LD_VAR 0 6
62885: INC
62886: ST_TO_ADDR
62887: LD_INT 4
62889: PUSH
62890: FOR_DOWNTO
62891: IFFALSE 62917
// eng := eng diff eng [ i ] ;
62893: LD_ADDR_VAR 0 6
62897: PUSH
62898: LD_VAR 0 6
62902: PUSH
62903: LD_VAR 0 6
62907: PUSH
62908: LD_VAR 0 3
62912: ARRAY
62913: DIFF
62914: ST_TO_ADDR
62915: GO 62890
62917: POP
62918: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62919: LD_ADDR_VAR 0 4
62923: PUSH
62924: LD_VAR 0 4
62928: PUSH
62929: LD_VAR 0 5
62933: PUSH
62934: LD_VAR 0 6
62938: UNION
62939: PUSH
62940: LD_VAR 0 7
62944: UNION
62945: PUSH
62946: LD_VAR 0 8
62950: UNION
62951: DIFF
62952: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62953: LD_ADDR_VAR 0 13
62957: PUSH
62958: LD_EXP 59
62962: PUSH
62963: LD_VAR 0 1
62967: ARRAY
62968: PPUSH
62969: LD_INT 2
62971: PUSH
62972: LD_INT 30
62974: PUSH
62975: LD_INT 32
62977: PUSH
62978: EMPTY
62979: LIST
62980: LIST
62981: PUSH
62982: LD_INT 30
62984: PUSH
62985: LD_INT 31
62987: PUSH
62988: EMPTY
62989: LIST
62990: LIST
62991: PUSH
62992: EMPTY
62993: LIST
62994: LIST
62995: LIST
62996: PPUSH
62997: CALL_OW 72
63001: PUSH
63002: LD_EXP 59
63006: PUSH
63007: LD_VAR 0 1
63011: ARRAY
63012: PPUSH
63013: LD_INT 2
63015: PUSH
63016: LD_INT 30
63018: PUSH
63019: LD_INT 4
63021: PUSH
63022: EMPTY
63023: LIST
63024: LIST
63025: PUSH
63026: LD_INT 30
63028: PUSH
63029: LD_INT 5
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: PUSH
63036: EMPTY
63037: LIST
63038: LIST
63039: LIST
63040: PPUSH
63041: CALL_OW 72
63045: PUSH
63046: LD_INT 6
63048: MUL
63049: PLUS
63050: ST_TO_ADDR
// if bcount < tmp then
63051: LD_VAR 0 13
63055: PUSH
63056: LD_VAR 0 4
63060: LESS
63061: IFFALSE 63107
// for i = tmp downto bcount do
63063: LD_ADDR_VAR 0 3
63067: PUSH
63068: DOUBLE
63069: LD_VAR 0 4
63073: INC
63074: ST_TO_ADDR
63075: LD_VAR 0 13
63079: PUSH
63080: FOR_DOWNTO
63081: IFFALSE 63105
// tmp := Delete ( tmp , tmp ) ;
63083: LD_ADDR_VAR 0 4
63087: PUSH
63088: LD_VAR 0 4
63092: PPUSH
63093: LD_VAR 0 4
63097: PPUSH
63098: CALL_OW 3
63102: ST_TO_ADDR
63103: GO 63080
63105: POP
63106: POP
// result := [ tmp , 0 , 0 , p ] ;
63107: LD_ADDR_VAR 0 2
63111: PUSH
63112: LD_VAR 0 4
63116: PUSH
63117: LD_INT 0
63119: PUSH
63120: LD_INT 0
63122: PUSH
63123: LD_VAR 0 11
63127: PUSH
63128: EMPTY
63129: LIST
63130: LIST
63131: LIST
63132: LIST
63133: ST_TO_ADDR
// exit ;
63134: GO 65824
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63136: LD_EXP 59
63140: PUSH
63141: LD_VAR 0 1
63145: ARRAY
63146: PPUSH
63147: LD_INT 2
63149: PUSH
63150: LD_INT 30
63152: PUSH
63153: LD_INT 6
63155: PUSH
63156: EMPTY
63157: LIST
63158: LIST
63159: PUSH
63160: LD_INT 30
63162: PUSH
63163: LD_INT 7
63165: PUSH
63166: EMPTY
63167: LIST
63168: LIST
63169: PUSH
63170: LD_INT 30
63172: PUSH
63173: LD_INT 8
63175: PUSH
63176: EMPTY
63177: LIST
63178: LIST
63179: PUSH
63180: EMPTY
63181: LIST
63182: LIST
63183: LIST
63184: LIST
63185: PPUSH
63186: CALL_OW 72
63190: NOT
63191: PUSH
63192: LD_EXP 59
63196: PUSH
63197: LD_VAR 0 1
63201: ARRAY
63202: PPUSH
63203: LD_INT 30
63205: PUSH
63206: LD_INT 3
63208: PUSH
63209: EMPTY
63210: LIST
63211: LIST
63212: PPUSH
63213: CALL_OW 72
63217: NOT
63218: AND
63219: IFFALSE 63291
// begin if eng = tmp then
63221: LD_VAR 0 6
63225: PUSH
63226: LD_VAR 0 4
63230: EQUAL
63231: IFFALSE 63235
// exit ;
63233: GO 65824
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
63235: LD_ADDR_EXP 101
63239: PUSH
63240: LD_EXP 101
63244: PPUSH
63245: LD_VAR 0 1
63249: PPUSH
63250: LD_INT 1
63252: PPUSH
63253: CALL_OW 1
63257: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
63258: LD_ADDR_VAR 0 2
63262: PUSH
63263: LD_INT 0
63265: PUSH
63266: LD_VAR 0 4
63270: PUSH
63271: LD_VAR 0 6
63275: DIFF
63276: PUSH
63277: LD_INT 0
63279: PUSH
63280: LD_INT 0
63282: PUSH
63283: EMPTY
63284: LIST
63285: LIST
63286: LIST
63287: LIST
63288: ST_TO_ADDR
// exit ;
63289: GO 65824
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63291: LD_EXP 86
63295: PUSH
63296: LD_EXP 85
63300: PUSH
63301: LD_VAR 0 1
63305: ARRAY
63306: ARRAY
63307: PUSH
63308: LD_EXP 59
63312: PUSH
63313: LD_VAR 0 1
63317: ARRAY
63318: PPUSH
63319: LD_INT 2
63321: PUSH
63322: LD_INT 30
63324: PUSH
63325: LD_INT 6
63327: PUSH
63328: EMPTY
63329: LIST
63330: LIST
63331: PUSH
63332: LD_INT 30
63334: PUSH
63335: LD_INT 7
63337: PUSH
63338: EMPTY
63339: LIST
63340: LIST
63341: PUSH
63342: LD_INT 30
63344: PUSH
63345: LD_INT 8
63347: PUSH
63348: EMPTY
63349: LIST
63350: LIST
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: LIST
63356: LIST
63357: PPUSH
63358: CALL_OW 72
63362: AND
63363: PUSH
63364: LD_EXP 59
63368: PUSH
63369: LD_VAR 0 1
63373: ARRAY
63374: PPUSH
63375: LD_INT 30
63377: PUSH
63378: LD_INT 3
63380: PUSH
63381: EMPTY
63382: LIST
63383: LIST
63384: PPUSH
63385: CALL_OW 72
63389: NOT
63390: AND
63391: IFFALSE 63605
// begin if sci >= 6 then
63393: LD_VAR 0 8
63397: PUSH
63398: LD_INT 6
63400: GREATEREQUAL
63401: IFFALSE 63405
// exit ;
63403: GO 65824
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
63405: LD_ADDR_EXP 101
63409: PUSH
63410: LD_EXP 101
63414: PPUSH
63415: LD_VAR 0 1
63419: PPUSH
63420: LD_INT 2
63422: PPUSH
63423: CALL_OW 1
63427: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
63428: LD_ADDR_VAR 0 9
63432: PUSH
63433: LD_VAR 0 4
63437: PUSH
63438: LD_VAR 0 8
63442: DIFF
63443: PPUSH
63444: LD_INT 4
63446: PPUSH
63447: CALL 55907 0 2
63451: ST_TO_ADDR
// p := [ ] ;
63452: LD_ADDR_VAR 0 11
63456: PUSH
63457: EMPTY
63458: ST_TO_ADDR
// if sci < 6 and sort > 6 then
63459: LD_VAR 0 8
63463: PUSH
63464: LD_INT 6
63466: LESS
63467: PUSH
63468: LD_VAR 0 9
63472: PUSH
63473: LD_INT 6
63475: GREATER
63476: AND
63477: IFFALSE 63558
// begin for i = 1 to 6 - sci do
63479: LD_ADDR_VAR 0 3
63483: PUSH
63484: DOUBLE
63485: LD_INT 1
63487: DEC
63488: ST_TO_ADDR
63489: LD_INT 6
63491: PUSH
63492: LD_VAR 0 8
63496: MINUS
63497: PUSH
63498: FOR_TO
63499: IFFALSE 63554
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63501: LD_ADDR_VAR 0 11
63505: PUSH
63506: LD_VAR 0 11
63510: PPUSH
63511: LD_VAR 0 11
63515: PUSH
63516: LD_INT 1
63518: PLUS
63519: PPUSH
63520: LD_VAR 0 9
63524: PUSH
63525: LD_INT 1
63527: ARRAY
63528: PPUSH
63529: CALL_OW 2
63533: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63534: LD_ADDR_VAR 0 9
63538: PUSH
63539: LD_VAR 0 9
63543: PPUSH
63544: LD_INT 1
63546: PPUSH
63547: CALL_OW 3
63551: ST_TO_ADDR
// end ;
63552: GO 63498
63554: POP
63555: POP
// end else
63556: GO 63578
// if sort then
63558: LD_VAR 0 9
63562: IFFALSE 63578
// p := sort [ 1 ] ;
63564: LD_ADDR_VAR 0 11
63568: PUSH
63569: LD_VAR 0 9
63573: PUSH
63574: LD_INT 1
63576: ARRAY
63577: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63578: LD_ADDR_VAR 0 2
63582: PUSH
63583: LD_INT 0
63585: PUSH
63586: LD_INT 0
63588: PUSH
63589: LD_INT 0
63591: PUSH
63592: LD_VAR 0 11
63596: PUSH
63597: EMPTY
63598: LIST
63599: LIST
63600: LIST
63601: LIST
63602: ST_TO_ADDR
// exit ;
63603: GO 65824
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63605: LD_EXP 86
63609: PUSH
63610: LD_EXP 85
63614: PUSH
63615: LD_VAR 0 1
63619: ARRAY
63620: ARRAY
63621: PUSH
63622: LD_EXP 59
63626: PUSH
63627: LD_VAR 0 1
63631: ARRAY
63632: PPUSH
63633: LD_INT 2
63635: PUSH
63636: LD_INT 30
63638: PUSH
63639: LD_INT 6
63641: PUSH
63642: EMPTY
63643: LIST
63644: LIST
63645: PUSH
63646: LD_INT 30
63648: PUSH
63649: LD_INT 7
63651: PUSH
63652: EMPTY
63653: LIST
63654: LIST
63655: PUSH
63656: LD_INT 30
63658: PUSH
63659: LD_INT 8
63661: PUSH
63662: EMPTY
63663: LIST
63664: LIST
63665: PUSH
63666: EMPTY
63667: LIST
63668: LIST
63669: LIST
63670: LIST
63671: PPUSH
63672: CALL_OW 72
63676: AND
63677: PUSH
63678: LD_EXP 59
63682: PUSH
63683: LD_VAR 0 1
63687: ARRAY
63688: PPUSH
63689: LD_INT 30
63691: PUSH
63692: LD_INT 3
63694: PUSH
63695: EMPTY
63696: LIST
63697: LIST
63698: PPUSH
63699: CALL_OW 72
63703: AND
63704: IFFALSE 64438
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63706: LD_ADDR_EXP 101
63710: PUSH
63711: LD_EXP 101
63715: PPUSH
63716: LD_VAR 0 1
63720: PPUSH
63721: LD_INT 3
63723: PPUSH
63724: CALL_OW 1
63728: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63729: LD_ADDR_VAR 0 2
63733: PUSH
63734: LD_INT 0
63736: PUSH
63737: LD_INT 0
63739: PUSH
63740: LD_INT 0
63742: PUSH
63743: LD_INT 0
63745: PUSH
63746: EMPTY
63747: LIST
63748: LIST
63749: LIST
63750: LIST
63751: ST_TO_ADDR
// if not eng then
63752: LD_VAR 0 6
63756: NOT
63757: IFFALSE 63820
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63759: LD_ADDR_VAR 0 11
63763: PUSH
63764: LD_VAR 0 4
63768: PPUSH
63769: LD_INT 2
63771: PPUSH
63772: CALL 55907 0 2
63776: PUSH
63777: LD_INT 1
63779: ARRAY
63780: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63781: LD_ADDR_VAR 0 2
63785: PUSH
63786: LD_VAR 0 2
63790: PPUSH
63791: LD_INT 2
63793: PPUSH
63794: LD_VAR 0 11
63798: PPUSH
63799: CALL_OW 1
63803: ST_TO_ADDR
// tmp := tmp diff p ;
63804: LD_ADDR_VAR 0 4
63808: PUSH
63809: LD_VAR 0 4
63813: PUSH
63814: LD_VAR 0 11
63818: DIFF
63819: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63820: LD_VAR 0 4
63824: PUSH
63825: LD_VAR 0 8
63829: PUSH
63830: LD_INT 6
63832: LESS
63833: AND
63834: IFFALSE 64022
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63836: LD_ADDR_VAR 0 9
63840: PUSH
63841: LD_VAR 0 4
63845: PUSH
63846: LD_VAR 0 8
63850: PUSH
63851: LD_VAR 0 7
63855: UNION
63856: DIFF
63857: PPUSH
63858: LD_INT 4
63860: PPUSH
63861: CALL 55907 0 2
63865: ST_TO_ADDR
// p := [ ] ;
63866: LD_ADDR_VAR 0 11
63870: PUSH
63871: EMPTY
63872: ST_TO_ADDR
// if sort then
63873: LD_VAR 0 9
63877: IFFALSE 63993
// for i = 1 to 6 - sci do
63879: LD_ADDR_VAR 0 3
63883: PUSH
63884: DOUBLE
63885: LD_INT 1
63887: DEC
63888: ST_TO_ADDR
63889: LD_INT 6
63891: PUSH
63892: LD_VAR 0 8
63896: MINUS
63897: PUSH
63898: FOR_TO
63899: IFFALSE 63991
// begin if i = sort then
63901: LD_VAR 0 3
63905: PUSH
63906: LD_VAR 0 9
63910: EQUAL
63911: IFFALSE 63915
// break ;
63913: GO 63991
// if GetClass ( i ) = 4 then
63915: LD_VAR 0 3
63919: PPUSH
63920: CALL_OW 257
63924: PUSH
63925: LD_INT 4
63927: EQUAL
63928: IFFALSE 63932
// continue ;
63930: GO 63898
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63932: LD_ADDR_VAR 0 11
63936: PUSH
63937: LD_VAR 0 11
63941: PPUSH
63942: LD_VAR 0 11
63946: PUSH
63947: LD_INT 1
63949: PLUS
63950: PPUSH
63951: LD_VAR 0 9
63955: PUSH
63956: LD_VAR 0 3
63960: ARRAY
63961: PPUSH
63962: CALL_OW 2
63966: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63967: LD_ADDR_VAR 0 4
63971: PUSH
63972: LD_VAR 0 4
63976: PUSH
63977: LD_VAR 0 9
63981: PUSH
63982: LD_VAR 0 3
63986: ARRAY
63987: DIFF
63988: ST_TO_ADDR
// end ;
63989: GO 63898
63991: POP
63992: POP
// if p then
63993: LD_VAR 0 11
63997: IFFALSE 64022
// result := Replace ( result , 4 , p ) ;
63999: LD_ADDR_VAR 0 2
64003: PUSH
64004: LD_VAR 0 2
64008: PPUSH
64009: LD_INT 4
64011: PPUSH
64012: LD_VAR 0 11
64016: PPUSH
64017: CALL_OW 1
64021: ST_TO_ADDR
// end ; if tmp and mech < 6 then
64022: LD_VAR 0 4
64026: PUSH
64027: LD_VAR 0 7
64031: PUSH
64032: LD_INT 6
64034: LESS
64035: AND
64036: IFFALSE 64224
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64038: LD_ADDR_VAR 0 9
64042: PUSH
64043: LD_VAR 0 4
64047: PUSH
64048: LD_VAR 0 8
64052: PUSH
64053: LD_VAR 0 7
64057: UNION
64058: DIFF
64059: PPUSH
64060: LD_INT 3
64062: PPUSH
64063: CALL 55907 0 2
64067: ST_TO_ADDR
// p := [ ] ;
64068: LD_ADDR_VAR 0 11
64072: PUSH
64073: EMPTY
64074: ST_TO_ADDR
// if sort then
64075: LD_VAR 0 9
64079: IFFALSE 64195
// for i = 1 to 6 - mech do
64081: LD_ADDR_VAR 0 3
64085: PUSH
64086: DOUBLE
64087: LD_INT 1
64089: DEC
64090: ST_TO_ADDR
64091: LD_INT 6
64093: PUSH
64094: LD_VAR 0 7
64098: MINUS
64099: PUSH
64100: FOR_TO
64101: IFFALSE 64193
// begin if i = sort then
64103: LD_VAR 0 3
64107: PUSH
64108: LD_VAR 0 9
64112: EQUAL
64113: IFFALSE 64117
// break ;
64115: GO 64193
// if GetClass ( i ) = 3 then
64117: LD_VAR 0 3
64121: PPUSH
64122: CALL_OW 257
64126: PUSH
64127: LD_INT 3
64129: EQUAL
64130: IFFALSE 64134
// continue ;
64132: GO 64100
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64134: LD_ADDR_VAR 0 11
64138: PUSH
64139: LD_VAR 0 11
64143: PPUSH
64144: LD_VAR 0 11
64148: PUSH
64149: LD_INT 1
64151: PLUS
64152: PPUSH
64153: LD_VAR 0 9
64157: PUSH
64158: LD_VAR 0 3
64162: ARRAY
64163: PPUSH
64164: CALL_OW 2
64168: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64169: LD_ADDR_VAR 0 4
64173: PUSH
64174: LD_VAR 0 4
64178: PUSH
64179: LD_VAR 0 9
64183: PUSH
64184: LD_VAR 0 3
64188: ARRAY
64189: DIFF
64190: ST_TO_ADDR
// end ;
64191: GO 64100
64193: POP
64194: POP
// if p then
64195: LD_VAR 0 11
64199: IFFALSE 64224
// result := Replace ( result , 3 , p ) ;
64201: LD_ADDR_VAR 0 2
64205: PUSH
64206: LD_VAR 0 2
64210: PPUSH
64211: LD_INT 3
64213: PPUSH
64214: LD_VAR 0 11
64218: PPUSH
64219: CALL_OW 1
64223: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
64224: LD_VAR 0 4
64228: PUSH
64229: LD_INT 6
64231: GREATER
64232: PUSH
64233: LD_VAR 0 6
64237: PUSH
64238: LD_INT 6
64240: LESS
64241: AND
64242: IFFALSE 64436
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64244: LD_ADDR_VAR 0 9
64248: PUSH
64249: LD_VAR 0 4
64253: PUSH
64254: LD_VAR 0 8
64258: PUSH
64259: LD_VAR 0 7
64263: UNION
64264: PUSH
64265: LD_VAR 0 6
64269: UNION
64270: DIFF
64271: PPUSH
64272: LD_INT 2
64274: PPUSH
64275: CALL 55907 0 2
64279: ST_TO_ADDR
// p := [ ] ;
64280: LD_ADDR_VAR 0 11
64284: PUSH
64285: EMPTY
64286: ST_TO_ADDR
// if sort then
64287: LD_VAR 0 9
64291: IFFALSE 64407
// for i = 1 to 6 - eng do
64293: LD_ADDR_VAR 0 3
64297: PUSH
64298: DOUBLE
64299: LD_INT 1
64301: DEC
64302: ST_TO_ADDR
64303: LD_INT 6
64305: PUSH
64306: LD_VAR 0 6
64310: MINUS
64311: PUSH
64312: FOR_TO
64313: IFFALSE 64405
// begin if i = sort then
64315: LD_VAR 0 3
64319: PUSH
64320: LD_VAR 0 9
64324: EQUAL
64325: IFFALSE 64329
// break ;
64327: GO 64405
// if GetClass ( i ) = 2 then
64329: LD_VAR 0 3
64333: PPUSH
64334: CALL_OW 257
64338: PUSH
64339: LD_INT 2
64341: EQUAL
64342: IFFALSE 64346
// continue ;
64344: GO 64312
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64346: LD_ADDR_VAR 0 11
64350: PUSH
64351: LD_VAR 0 11
64355: PPUSH
64356: LD_VAR 0 11
64360: PUSH
64361: LD_INT 1
64363: PLUS
64364: PPUSH
64365: LD_VAR 0 9
64369: PUSH
64370: LD_VAR 0 3
64374: ARRAY
64375: PPUSH
64376: CALL_OW 2
64380: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64381: LD_ADDR_VAR 0 4
64385: PUSH
64386: LD_VAR 0 4
64390: PUSH
64391: LD_VAR 0 9
64395: PUSH
64396: LD_VAR 0 3
64400: ARRAY
64401: DIFF
64402: ST_TO_ADDR
// end ;
64403: GO 64312
64405: POP
64406: POP
// if p then
64407: LD_VAR 0 11
64411: IFFALSE 64436
// result := Replace ( result , 2 , p ) ;
64413: LD_ADDR_VAR 0 2
64417: PUSH
64418: LD_VAR 0 2
64422: PPUSH
64423: LD_INT 2
64425: PPUSH
64426: LD_VAR 0 11
64430: PPUSH
64431: CALL_OW 1
64435: ST_TO_ADDR
// end ; exit ;
64436: GO 65824
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
64438: LD_EXP 86
64442: PUSH
64443: LD_EXP 85
64447: PUSH
64448: LD_VAR 0 1
64452: ARRAY
64453: ARRAY
64454: NOT
64455: PUSH
64456: LD_EXP 59
64460: PUSH
64461: LD_VAR 0 1
64465: ARRAY
64466: PPUSH
64467: LD_INT 30
64469: PUSH
64470: LD_INT 3
64472: PUSH
64473: EMPTY
64474: LIST
64475: LIST
64476: PPUSH
64477: CALL_OW 72
64481: AND
64482: PUSH
64483: LD_EXP 64
64487: PUSH
64488: LD_VAR 0 1
64492: ARRAY
64493: AND
64494: IFFALSE 65102
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64496: LD_ADDR_EXP 101
64500: PUSH
64501: LD_EXP 101
64505: PPUSH
64506: LD_VAR 0 1
64510: PPUSH
64511: LD_INT 5
64513: PPUSH
64514: CALL_OW 1
64518: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64519: LD_ADDR_VAR 0 2
64523: PUSH
64524: LD_INT 0
64526: PUSH
64527: LD_INT 0
64529: PUSH
64530: LD_INT 0
64532: PUSH
64533: LD_INT 0
64535: PUSH
64536: EMPTY
64537: LIST
64538: LIST
64539: LIST
64540: LIST
64541: ST_TO_ADDR
// if sci > 1 then
64542: LD_VAR 0 8
64546: PUSH
64547: LD_INT 1
64549: GREATER
64550: IFFALSE 64578
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64552: LD_ADDR_VAR 0 4
64556: PUSH
64557: LD_VAR 0 4
64561: PUSH
64562: LD_VAR 0 8
64566: PUSH
64567: LD_VAR 0 8
64571: PUSH
64572: LD_INT 1
64574: ARRAY
64575: DIFF
64576: DIFF
64577: ST_TO_ADDR
// if tmp and not sci then
64578: LD_VAR 0 4
64582: PUSH
64583: LD_VAR 0 8
64587: NOT
64588: AND
64589: IFFALSE 64658
// begin sort := SortBySkill ( tmp , 4 ) ;
64591: LD_ADDR_VAR 0 9
64595: PUSH
64596: LD_VAR 0 4
64600: PPUSH
64601: LD_INT 4
64603: PPUSH
64604: CALL 55907 0 2
64608: ST_TO_ADDR
// if sort then
64609: LD_VAR 0 9
64613: IFFALSE 64629
// p := sort [ 1 ] ;
64615: LD_ADDR_VAR 0 11
64619: PUSH
64620: LD_VAR 0 9
64624: PUSH
64625: LD_INT 1
64627: ARRAY
64628: ST_TO_ADDR
// if p then
64629: LD_VAR 0 11
64633: IFFALSE 64658
// result := Replace ( result , 4 , p ) ;
64635: LD_ADDR_VAR 0 2
64639: PUSH
64640: LD_VAR 0 2
64644: PPUSH
64645: LD_INT 4
64647: PPUSH
64648: LD_VAR 0 11
64652: PPUSH
64653: CALL_OW 1
64657: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64658: LD_ADDR_VAR 0 4
64662: PUSH
64663: LD_VAR 0 4
64667: PUSH
64668: LD_VAR 0 7
64672: DIFF
64673: ST_TO_ADDR
// if tmp and mech < 6 then
64674: LD_VAR 0 4
64678: PUSH
64679: LD_VAR 0 7
64683: PUSH
64684: LD_INT 6
64686: LESS
64687: AND
64688: IFFALSE 64876
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64690: LD_ADDR_VAR 0 9
64694: PUSH
64695: LD_VAR 0 4
64699: PUSH
64700: LD_VAR 0 8
64704: PUSH
64705: LD_VAR 0 7
64709: UNION
64710: DIFF
64711: PPUSH
64712: LD_INT 3
64714: PPUSH
64715: CALL 55907 0 2
64719: ST_TO_ADDR
// p := [ ] ;
64720: LD_ADDR_VAR 0 11
64724: PUSH
64725: EMPTY
64726: ST_TO_ADDR
// if sort then
64727: LD_VAR 0 9
64731: IFFALSE 64847
// for i = 1 to 6 - mech do
64733: LD_ADDR_VAR 0 3
64737: PUSH
64738: DOUBLE
64739: LD_INT 1
64741: DEC
64742: ST_TO_ADDR
64743: LD_INT 6
64745: PUSH
64746: LD_VAR 0 7
64750: MINUS
64751: PUSH
64752: FOR_TO
64753: IFFALSE 64845
// begin if i = sort then
64755: LD_VAR 0 3
64759: PUSH
64760: LD_VAR 0 9
64764: EQUAL
64765: IFFALSE 64769
// break ;
64767: GO 64845
// if GetClass ( i ) = 3 then
64769: LD_VAR 0 3
64773: PPUSH
64774: CALL_OW 257
64778: PUSH
64779: LD_INT 3
64781: EQUAL
64782: IFFALSE 64786
// continue ;
64784: GO 64752
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64786: LD_ADDR_VAR 0 11
64790: PUSH
64791: LD_VAR 0 11
64795: PPUSH
64796: LD_VAR 0 11
64800: PUSH
64801: LD_INT 1
64803: PLUS
64804: PPUSH
64805: LD_VAR 0 9
64809: PUSH
64810: LD_VAR 0 3
64814: ARRAY
64815: PPUSH
64816: CALL_OW 2
64820: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64821: LD_ADDR_VAR 0 4
64825: PUSH
64826: LD_VAR 0 4
64830: PUSH
64831: LD_VAR 0 9
64835: PUSH
64836: LD_VAR 0 3
64840: ARRAY
64841: DIFF
64842: ST_TO_ADDR
// end ;
64843: GO 64752
64845: POP
64846: POP
// if p then
64847: LD_VAR 0 11
64851: IFFALSE 64876
// result := Replace ( result , 3 , p ) ;
64853: LD_ADDR_VAR 0 2
64857: PUSH
64858: LD_VAR 0 2
64862: PPUSH
64863: LD_INT 3
64865: PPUSH
64866: LD_VAR 0 11
64870: PPUSH
64871: CALL_OW 1
64875: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64876: LD_ADDR_VAR 0 4
64880: PUSH
64881: LD_VAR 0 4
64885: PUSH
64886: LD_VAR 0 6
64890: DIFF
64891: ST_TO_ADDR
// if tmp and eng < 6 then
64892: LD_VAR 0 4
64896: PUSH
64897: LD_VAR 0 6
64901: PUSH
64902: LD_INT 6
64904: LESS
64905: AND
64906: IFFALSE 65100
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64908: LD_ADDR_VAR 0 9
64912: PUSH
64913: LD_VAR 0 4
64917: PUSH
64918: LD_VAR 0 8
64922: PUSH
64923: LD_VAR 0 7
64927: UNION
64928: PUSH
64929: LD_VAR 0 6
64933: UNION
64934: DIFF
64935: PPUSH
64936: LD_INT 2
64938: PPUSH
64939: CALL 55907 0 2
64943: ST_TO_ADDR
// p := [ ] ;
64944: LD_ADDR_VAR 0 11
64948: PUSH
64949: EMPTY
64950: ST_TO_ADDR
// if sort then
64951: LD_VAR 0 9
64955: IFFALSE 65071
// for i = 1 to 6 - eng do
64957: LD_ADDR_VAR 0 3
64961: PUSH
64962: DOUBLE
64963: LD_INT 1
64965: DEC
64966: ST_TO_ADDR
64967: LD_INT 6
64969: PUSH
64970: LD_VAR 0 6
64974: MINUS
64975: PUSH
64976: FOR_TO
64977: IFFALSE 65069
// begin if i = sort then
64979: LD_VAR 0 3
64983: PUSH
64984: LD_VAR 0 9
64988: EQUAL
64989: IFFALSE 64993
// break ;
64991: GO 65069
// if GetClass ( i ) = 2 then
64993: LD_VAR 0 3
64997: PPUSH
64998: CALL_OW 257
65002: PUSH
65003: LD_INT 2
65005: EQUAL
65006: IFFALSE 65010
// continue ;
65008: GO 64976
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65010: LD_ADDR_VAR 0 11
65014: PUSH
65015: LD_VAR 0 11
65019: PPUSH
65020: LD_VAR 0 11
65024: PUSH
65025: LD_INT 1
65027: PLUS
65028: PPUSH
65029: LD_VAR 0 9
65033: PUSH
65034: LD_VAR 0 3
65038: ARRAY
65039: PPUSH
65040: CALL_OW 2
65044: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65045: LD_ADDR_VAR 0 4
65049: PUSH
65050: LD_VAR 0 4
65054: PUSH
65055: LD_VAR 0 9
65059: PUSH
65060: LD_VAR 0 3
65064: ARRAY
65065: DIFF
65066: ST_TO_ADDR
// end ;
65067: GO 64976
65069: POP
65070: POP
// if p then
65071: LD_VAR 0 11
65075: IFFALSE 65100
// result := Replace ( result , 2 , p ) ;
65077: LD_ADDR_VAR 0 2
65081: PUSH
65082: LD_VAR 0 2
65086: PPUSH
65087: LD_INT 2
65089: PPUSH
65090: LD_VAR 0 11
65094: PPUSH
65095: CALL_OW 1
65099: ST_TO_ADDR
// end ; exit ;
65100: GO 65824
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
65102: LD_EXP 86
65106: PUSH
65107: LD_EXP 85
65111: PUSH
65112: LD_VAR 0 1
65116: ARRAY
65117: ARRAY
65118: NOT
65119: PUSH
65120: LD_EXP 59
65124: PUSH
65125: LD_VAR 0 1
65129: ARRAY
65130: PPUSH
65131: LD_INT 30
65133: PUSH
65134: LD_INT 3
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PPUSH
65141: CALL_OW 72
65145: AND
65146: PUSH
65147: LD_EXP 64
65151: PUSH
65152: LD_VAR 0 1
65156: ARRAY
65157: NOT
65158: AND
65159: IFFALSE 65824
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
65161: LD_ADDR_EXP 101
65165: PUSH
65166: LD_EXP 101
65170: PPUSH
65171: LD_VAR 0 1
65175: PPUSH
65176: LD_INT 6
65178: PPUSH
65179: CALL_OW 1
65183: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65184: LD_ADDR_VAR 0 2
65188: PUSH
65189: LD_INT 0
65191: PUSH
65192: LD_INT 0
65194: PUSH
65195: LD_INT 0
65197: PUSH
65198: LD_INT 0
65200: PUSH
65201: EMPTY
65202: LIST
65203: LIST
65204: LIST
65205: LIST
65206: ST_TO_ADDR
// if sci >= 1 then
65207: LD_VAR 0 8
65211: PUSH
65212: LD_INT 1
65214: GREATEREQUAL
65215: IFFALSE 65237
// tmp := tmp diff sci [ 1 ] ;
65217: LD_ADDR_VAR 0 4
65221: PUSH
65222: LD_VAR 0 4
65226: PUSH
65227: LD_VAR 0 8
65231: PUSH
65232: LD_INT 1
65234: ARRAY
65235: DIFF
65236: ST_TO_ADDR
// if tmp and not sci then
65237: LD_VAR 0 4
65241: PUSH
65242: LD_VAR 0 8
65246: NOT
65247: AND
65248: IFFALSE 65317
// begin sort := SortBySkill ( tmp , 4 ) ;
65250: LD_ADDR_VAR 0 9
65254: PUSH
65255: LD_VAR 0 4
65259: PPUSH
65260: LD_INT 4
65262: PPUSH
65263: CALL 55907 0 2
65267: ST_TO_ADDR
// if sort then
65268: LD_VAR 0 9
65272: IFFALSE 65288
// p := sort [ 1 ] ;
65274: LD_ADDR_VAR 0 11
65278: PUSH
65279: LD_VAR 0 9
65283: PUSH
65284: LD_INT 1
65286: ARRAY
65287: ST_TO_ADDR
// if p then
65288: LD_VAR 0 11
65292: IFFALSE 65317
// result := Replace ( result , 4 , p ) ;
65294: LD_ADDR_VAR 0 2
65298: PUSH
65299: LD_VAR 0 2
65303: PPUSH
65304: LD_INT 4
65306: PPUSH
65307: LD_VAR 0 11
65311: PPUSH
65312: CALL_OW 1
65316: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
65317: LD_ADDR_VAR 0 4
65321: PUSH
65322: LD_VAR 0 4
65326: PUSH
65327: LD_VAR 0 7
65331: DIFF
65332: ST_TO_ADDR
// if tmp and mech < 6 then
65333: LD_VAR 0 4
65337: PUSH
65338: LD_VAR 0 7
65342: PUSH
65343: LD_INT 6
65345: LESS
65346: AND
65347: IFFALSE 65529
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
65349: LD_ADDR_VAR 0 9
65353: PUSH
65354: LD_VAR 0 4
65358: PUSH
65359: LD_VAR 0 7
65363: DIFF
65364: PPUSH
65365: LD_INT 3
65367: PPUSH
65368: CALL 55907 0 2
65372: ST_TO_ADDR
// p := [ ] ;
65373: LD_ADDR_VAR 0 11
65377: PUSH
65378: EMPTY
65379: ST_TO_ADDR
// if sort then
65380: LD_VAR 0 9
65384: IFFALSE 65500
// for i = 1 to 6 - mech do
65386: LD_ADDR_VAR 0 3
65390: PUSH
65391: DOUBLE
65392: LD_INT 1
65394: DEC
65395: ST_TO_ADDR
65396: LD_INT 6
65398: PUSH
65399: LD_VAR 0 7
65403: MINUS
65404: PUSH
65405: FOR_TO
65406: IFFALSE 65498
// begin if i = sort then
65408: LD_VAR 0 3
65412: PUSH
65413: LD_VAR 0 9
65417: EQUAL
65418: IFFALSE 65422
// break ;
65420: GO 65498
// if GetClass ( i ) = 3 then
65422: LD_VAR 0 3
65426: PPUSH
65427: CALL_OW 257
65431: PUSH
65432: LD_INT 3
65434: EQUAL
65435: IFFALSE 65439
// continue ;
65437: GO 65405
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65439: LD_ADDR_VAR 0 11
65443: PUSH
65444: LD_VAR 0 11
65448: PPUSH
65449: LD_VAR 0 11
65453: PUSH
65454: LD_INT 1
65456: PLUS
65457: PPUSH
65458: LD_VAR 0 9
65462: PUSH
65463: LD_VAR 0 3
65467: ARRAY
65468: PPUSH
65469: CALL_OW 2
65473: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65474: LD_ADDR_VAR 0 4
65478: PUSH
65479: LD_VAR 0 4
65483: PUSH
65484: LD_VAR 0 9
65488: PUSH
65489: LD_VAR 0 3
65493: ARRAY
65494: DIFF
65495: ST_TO_ADDR
// end ;
65496: GO 65405
65498: POP
65499: POP
// if p then
65500: LD_VAR 0 11
65504: IFFALSE 65529
// result := Replace ( result , 3 , p ) ;
65506: LD_ADDR_VAR 0 2
65510: PUSH
65511: LD_VAR 0 2
65515: PPUSH
65516: LD_INT 3
65518: PPUSH
65519: LD_VAR 0 11
65523: PPUSH
65524: CALL_OW 1
65528: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65529: LD_ADDR_VAR 0 4
65533: PUSH
65534: LD_VAR 0 4
65538: PUSH
65539: LD_VAR 0 6
65543: DIFF
65544: ST_TO_ADDR
// if tmp and eng < 4 then
65545: LD_VAR 0 4
65549: PUSH
65550: LD_VAR 0 6
65554: PUSH
65555: LD_INT 4
65557: LESS
65558: AND
65559: IFFALSE 65749
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65561: LD_ADDR_VAR 0 9
65565: PUSH
65566: LD_VAR 0 4
65570: PUSH
65571: LD_VAR 0 7
65575: PUSH
65576: LD_VAR 0 6
65580: UNION
65581: DIFF
65582: PPUSH
65583: LD_INT 2
65585: PPUSH
65586: CALL 55907 0 2
65590: ST_TO_ADDR
// p := [ ] ;
65591: LD_ADDR_VAR 0 11
65595: PUSH
65596: EMPTY
65597: ST_TO_ADDR
// if sort then
65598: LD_VAR 0 9
65602: IFFALSE 65718
// for i = 1 to 4 - eng do
65604: LD_ADDR_VAR 0 3
65608: PUSH
65609: DOUBLE
65610: LD_INT 1
65612: DEC
65613: ST_TO_ADDR
65614: LD_INT 4
65616: PUSH
65617: LD_VAR 0 6
65621: MINUS
65622: PUSH
65623: FOR_TO
65624: IFFALSE 65716
// begin if i = sort then
65626: LD_VAR 0 3
65630: PUSH
65631: LD_VAR 0 9
65635: EQUAL
65636: IFFALSE 65640
// break ;
65638: GO 65716
// if GetClass ( i ) = 2 then
65640: LD_VAR 0 3
65644: PPUSH
65645: CALL_OW 257
65649: PUSH
65650: LD_INT 2
65652: EQUAL
65653: IFFALSE 65657
// continue ;
65655: GO 65623
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65657: LD_ADDR_VAR 0 11
65661: PUSH
65662: LD_VAR 0 11
65666: PPUSH
65667: LD_VAR 0 11
65671: PUSH
65672: LD_INT 1
65674: PLUS
65675: PPUSH
65676: LD_VAR 0 9
65680: PUSH
65681: LD_VAR 0 3
65685: ARRAY
65686: PPUSH
65687: CALL_OW 2
65691: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65692: LD_ADDR_VAR 0 4
65696: PUSH
65697: LD_VAR 0 4
65701: PUSH
65702: LD_VAR 0 9
65706: PUSH
65707: LD_VAR 0 3
65711: ARRAY
65712: DIFF
65713: ST_TO_ADDR
// end ;
65714: GO 65623
65716: POP
65717: POP
// if p then
65718: LD_VAR 0 11
65722: IFFALSE 65747
// result := Replace ( result , 2 , p ) ;
65724: LD_ADDR_VAR 0 2
65728: PUSH
65729: LD_VAR 0 2
65733: PPUSH
65734: LD_INT 2
65736: PPUSH
65737: LD_VAR 0 11
65741: PPUSH
65742: CALL_OW 1
65746: ST_TO_ADDR
// end else
65747: GO 65793
// for i = eng downto 5 do
65749: LD_ADDR_VAR 0 3
65753: PUSH
65754: DOUBLE
65755: LD_VAR 0 6
65759: INC
65760: ST_TO_ADDR
65761: LD_INT 5
65763: PUSH
65764: FOR_DOWNTO
65765: IFFALSE 65791
// tmp := tmp union eng [ i ] ;
65767: LD_ADDR_VAR 0 4
65771: PUSH
65772: LD_VAR 0 4
65776: PUSH
65777: LD_VAR 0 6
65781: PUSH
65782: LD_VAR 0 3
65786: ARRAY
65787: UNION
65788: ST_TO_ADDR
65789: GO 65764
65791: POP
65792: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65793: LD_ADDR_VAR 0 2
65797: PUSH
65798: LD_VAR 0 2
65802: PPUSH
65803: LD_INT 1
65805: PPUSH
65806: LD_VAR 0 4
65810: PUSH
65811: LD_VAR 0 5
65815: DIFF
65816: PPUSH
65817: CALL_OW 1
65821: ST_TO_ADDR
// exit ;
65822: GO 65824
// end ; end ;
65824: LD_VAR 0 2
65828: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65829: LD_INT 0
65831: PPUSH
65832: PPUSH
65833: PPUSH
// if not mc_bases then
65834: LD_EXP 59
65838: NOT
65839: IFFALSE 65843
// exit ;
65841: GO 65949
// for i = 1 to mc_bases do
65843: LD_ADDR_VAR 0 2
65847: PUSH
65848: DOUBLE
65849: LD_INT 1
65851: DEC
65852: ST_TO_ADDR
65853: LD_EXP 59
65857: PUSH
65858: FOR_TO
65859: IFFALSE 65940
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65861: LD_ADDR_VAR 0 3
65865: PUSH
65866: LD_EXP 59
65870: PUSH
65871: LD_VAR 0 2
65875: ARRAY
65876: PPUSH
65877: LD_INT 21
65879: PUSH
65880: LD_INT 3
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PUSH
65887: LD_INT 3
65889: PUSH
65890: LD_INT 24
65892: PUSH
65893: LD_INT 1000
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: PUSH
65900: EMPTY
65901: LIST
65902: LIST
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PPUSH
65908: CALL_OW 72
65912: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65913: LD_ADDR_EXP 60
65917: PUSH
65918: LD_EXP 60
65922: PPUSH
65923: LD_VAR 0 2
65927: PPUSH
65928: LD_VAR 0 3
65932: PPUSH
65933: CALL_OW 1
65937: ST_TO_ADDR
// end ;
65938: GO 65858
65940: POP
65941: POP
// RaiseSailEvent ( 101 ) ;
65942: LD_INT 101
65944: PPUSH
65945: CALL_OW 427
// end ;
65949: LD_VAR 0 1
65953: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65954: LD_INT 0
65956: PPUSH
65957: PPUSH
65958: PPUSH
65959: PPUSH
65960: PPUSH
65961: PPUSH
65962: PPUSH
// if not mc_bases then
65963: LD_EXP 59
65967: NOT
65968: IFFALSE 65972
// exit ;
65970: GO 66545
// for i = 1 to mc_bases do
65972: LD_ADDR_VAR 0 2
65976: PUSH
65977: DOUBLE
65978: LD_INT 1
65980: DEC
65981: ST_TO_ADDR
65982: LD_EXP 59
65986: PUSH
65987: FOR_TO
65988: IFFALSE 66536
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65990: LD_ADDR_VAR 0 5
65994: PUSH
65995: LD_EXP 59
65999: PUSH
66000: LD_VAR 0 2
66004: ARRAY
66005: PUSH
66006: LD_EXP 88
66010: PUSH
66011: LD_VAR 0 2
66015: ARRAY
66016: UNION
66017: PPUSH
66018: LD_INT 21
66020: PUSH
66021: LD_INT 1
66023: PUSH
66024: EMPTY
66025: LIST
66026: LIST
66027: PUSH
66028: LD_INT 1
66030: PUSH
66031: LD_INT 3
66033: PUSH
66034: LD_INT 54
66036: PUSH
66037: EMPTY
66038: LIST
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: PUSH
66044: LD_INT 3
66046: PUSH
66047: LD_INT 24
66049: PUSH
66050: LD_INT 800
66052: PUSH
66053: EMPTY
66054: LIST
66055: LIST
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: EMPTY
66062: LIST
66063: LIST
66064: LIST
66065: PUSH
66066: EMPTY
66067: LIST
66068: LIST
66069: PPUSH
66070: CALL_OW 72
66074: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
66075: LD_ADDR_VAR 0 6
66079: PUSH
66080: LD_EXP 59
66084: PUSH
66085: LD_VAR 0 2
66089: ARRAY
66090: PPUSH
66091: LD_INT 21
66093: PUSH
66094: LD_INT 1
66096: PUSH
66097: EMPTY
66098: LIST
66099: LIST
66100: PUSH
66101: LD_INT 1
66103: PUSH
66104: LD_INT 3
66106: PUSH
66107: LD_INT 54
66109: PUSH
66110: EMPTY
66111: LIST
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: LD_INT 3
66119: PUSH
66120: LD_INT 24
66122: PUSH
66123: LD_INT 250
66125: PUSH
66126: EMPTY
66127: LIST
66128: LIST
66129: PUSH
66130: EMPTY
66131: LIST
66132: LIST
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: LIST
66138: PUSH
66139: EMPTY
66140: LIST
66141: LIST
66142: PPUSH
66143: CALL_OW 72
66147: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
66148: LD_ADDR_VAR 0 7
66152: PUSH
66153: LD_VAR 0 5
66157: PUSH
66158: LD_VAR 0 6
66162: DIFF
66163: ST_TO_ADDR
// if not need_heal_1 then
66164: LD_VAR 0 6
66168: NOT
66169: IFFALSE 66202
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
66171: LD_ADDR_EXP 62
66175: PUSH
66176: LD_EXP 62
66180: PPUSH
66181: LD_VAR 0 2
66185: PUSH
66186: LD_INT 1
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: PPUSH
66193: EMPTY
66194: PPUSH
66195: CALL 21649 0 3
66199: ST_TO_ADDR
66200: GO 66272
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
66202: LD_ADDR_EXP 62
66206: PUSH
66207: LD_EXP 62
66211: PPUSH
66212: LD_VAR 0 2
66216: PUSH
66217: LD_INT 1
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PPUSH
66224: LD_EXP 62
66228: PUSH
66229: LD_VAR 0 2
66233: ARRAY
66234: PUSH
66235: LD_INT 1
66237: ARRAY
66238: PPUSH
66239: LD_INT 3
66241: PUSH
66242: LD_INT 24
66244: PUSH
66245: LD_INT 1000
66247: PUSH
66248: EMPTY
66249: LIST
66250: LIST
66251: PUSH
66252: EMPTY
66253: LIST
66254: LIST
66255: PPUSH
66256: CALL_OW 72
66260: PUSH
66261: LD_VAR 0 6
66265: UNION
66266: PPUSH
66267: CALL 21649 0 3
66271: ST_TO_ADDR
// if not need_heal_2 then
66272: LD_VAR 0 7
66276: NOT
66277: IFFALSE 66310
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
66279: LD_ADDR_EXP 62
66283: PUSH
66284: LD_EXP 62
66288: PPUSH
66289: LD_VAR 0 2
66293: PUSH
66294: LD_INT 2
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: PPUSH
66301: EMPTY
66302: PPUSH
66303: CALL 21649 0 3
66307: ST_TO_ADDR
66308: GO 66342
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
66310: LD_ADDR_EXP 62
66314: PUSH
66315: LD_EXP 62
66319: PPUSH
66320: LD_VAR 0 2
66324: PUSH
66325: LD_INT 2
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: PPUSH
66332: LD_VAR 0 7
66336: PPUSH
66337: CALL 21649 0 3
66341: ST_TO_ADDR
// if need_heal_2 then
66342: LD_VAR 0 7
66346: IFFALSE 66518
// for j in need_heal_2 do
66348: LD_ADDR_VAR 0 3
66352: PUSH
66353: LD_VAR 0 7
66357: PUSH
66358: FOR_IN
66359: IFFALSE 66516
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
66361: LD_ADDR_VAR 0 5
66365: PUSH
66366: LD_EXP 59
66370: PUSH
66371: LD_VAR 0 2
66375: ARRAY
66376: PPUSH
66377: LD_INT 2
66379: PUSH
66380: LD_INT 30
66382: PUSH
66383: LD_INT 6
66385: PUSH
66386: EMPTY
66387: LIST
66388: LIST
66389: PUSH
66390: LD_INT 30
66392: PUSH
66393: LD_INT 7
66395: PUSH
66396: EMPTY
66397: LIST
66398: LIST
66399: PUSH
66400: LD_INT 30
66402: PUSH
66403: LD_INT 8
66405: PUSH
66406: EMPTY
66407: LIST
66408: LIST
66409: PUSH
66410: LD_INT 30
66412: PUSH
66413: LD_INT 0
66415: PUSH
66416: EMPTY
66417: LIST
66418: LIST
66419: PUSH
66420: LD_INT 30
66422: PUSH
66423: LD_INT 1
66425: PUSH
66426: EMPTY
66427: LIST
66428: LIST
66429: PUSH
66430: LD_INT 25
66432: PUSH
66433: LD_INT 4
66435: PUSH
66436: EMPTY
66437: LIST
66438: LIST
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: PPUSH
66449: CALL_OW 72
66453: ST_TO_ADDR
// if tmp then
66454: LD_VAR 0 5
66458: IFFALSE 66514
// begin k := NearestUnitToUnit ( tmp , j ) ;
66460: LD_ADDR_VAR 0 4
66464: PUSH
66465: LD_VAR 0 5
66469: PPUSH
66470: LD_VAR 0 3
66474: PPUSH
66475: CALL_OW 74
66479: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
66480: LD_VAR 0 3
66484: PPUSH
66485: LD_VAR 0 4
66489: PPUSH
66490: CALL_OW 296
66494: PUSH
66495: LD_INT 7
66497: GREATER
66498: IFFALSE 66514
// ComMoveUnit ( j , k ) ;
66500: LD_VAR 0 3
66504: PPUSH
66505: LD_VAR 0 4
66509: PPUSH
66510: CALL_OW 112
// end ; end ;
66514: GO 66358
66516: POP
66517: POP
// if not need_heal_1 and not need_heal_2 then
66518: LD_VAR 0 6
66522: NOT
66523: PUSH
66524: LD_VAR 0 7
66528: NOT
66529: AND
66530: IFFALSE 66534
// continue ;
66532: GO 65987
// end ;
66534: GO 65987
66536: POP
66537: POP
// RaiseSailEvent ( 102 ) ;
66538: LD_INT 102
66540: PPUSH
66541: CALL_OW 427
// end ;
66545: LD_VAR 0 1
66549: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
66550: LD_INT 0
66552: PPUSH
66553: PPUSH
66554: PPUSH
66555: PPUSH
66556: PPUSH
66557: PPUSH
66558: PPUSH
66559: PPUSH
// if not mc_bases then
66560: LD_EXP 59
66564: NOT
66565: IFFALSE 66569
// exit ;
66567: GO 67409
// for i = 1 to mc_bases do
66569: LD_ADDR_VAR 0 2
66573: PUSH
66574: DOUBLE
66575: LD_INT 1
66577: DEC
66578: ST_TO_ADDR
66579: LD_EXP 59
66583: PUSH
66584: FOR_TO
66585: IFFALSE 67407
// begin if not mc_building_need_repair [ i ] then
66587: LD_EXP 60
66591: PUSH
66592: LD_VAR 0 2
66596: ARRAY
66597: NOT
66598: IFFALSE 66772
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
66600: LD_ADDR_VAR 0 6
66604: PUSH
66605: LD_EXP 78
66609: PUSH
66610: LD_VAR 0 2
66614: ARRAY
66615: PPUSH
66616: LD_INT 3
66618: PUSH
66619: LD_INT 24
66621: PUSH
66622: LD_INT 1000
66624: PUSH
66625: EMPTY
66626: LIST
66627: LIST
66628: PUSH
66629: EMPTY
66630: LIST
66631: LIST
66632: PUSH
66633: LD_INT 2
66635: PUSH
66636: LD_INT 34
66638: PUSH
66639: LD_INT 13
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: PUSH
66646: LD_INT 34
66648: PUSH
66649: LD_INT 52
66651: PUSH
66652: EMPTY
66653: LIST
66654: LIST
66655: PUSH
66656: EMPTY
66657: LIST
66658: LIST
66659: LIST
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PPUSH
66665: CALL_OW 72
66669: ST_TO_ADDR
// if cranes then
66670: LD_VAR 0 6
66674: IFFALSE 66736
// for j in cranes do
66676: LD_ADDR_VAR 0 3
66680: PUSH
66681: LD_VAR 0 6
66685: PUSH
66686: FOR_IN
66687: IFFALSE 66734
// if not IsInArea ( j , mc_parking [ i ] ) then
66689: LD_VAR 0 3
66693: PPUSH
66694: LD_EXP 83
66698: PUSH
66699: LD_VAR 0 2
66703: ARRAY
66704: PPUSH
66705: CALL_OW 308
66709: NOT
66710: IFFALSE 66732
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66712: LD_VAR 0 3
66716: PPUSH
66717: LD_EXP 83
66721: PUSH
66722: LD_VAR 0 2
66726: ARRAY
66727: PPUSH
66728: CALL_OW 113
66732: GO 66686
66734: POP
66735: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66736: LD_ADDR_EXP 61
66740: PUSH
66741: LD_EXP 61
66745: PPUSH
66746: LD_VAR 0 2
66750: PPUSH
66751: EMPTY
66752: PPUSH
66753: CALL_OW 1
66757: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66758: LD_VAR 0 2
66762: PPUSH
66763: LD_INT 101
66765: PPUSH
66766: CALL 61662 0 2
// continue ;
66770: GO 66584
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66772: LD_ADDR_EXP 65
66776: PUSH
66777: LD_EXP 65
66781: PPUSH
66782: LD_VAR 0 2
66786: PPUSH
66787: EMPTY
66788: PPUSH
66789: CALL_OW 1
66793: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66794: LD_VAR 0 2
66798: PPUSH
66799: LD_INT 103
66801: PPUSH
66802: CALL 61662 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66806: LD_ADDR_VAR 0 5
66810: PUSH
66811: LD_EXP 59
66815: PUSH
66816: LD_VAR 0 2
66820: ARRAY
66821: PUSH
66822: LD_EXP 88
66826: PUSH
66827: LD_VAR 0 2
66831: ARRAY
66832: UNION
66833: PPUSH
66834: LD_INT 2
66836: PUSH
66837: LD_INT 25
66839: PUSH
66840: LD_INT 2
66842: PUSH
66843: EMPTY
66844: LIST
66845: LIST
66846: PUSH
66847: LD_INT 25
66849: PUSH
66850: LD_INT 16
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: LIST
66861: PUSH
66862: EMPTY
66863: LIST
66864: PPUSH
66865: CALL_OW 72
66869: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66870: LD_ADDR_VAR 0 6
66874: PUSH
66875: LD_EXP 78
66879: PUSH
66880: LD_VAR 0 2
66884: ARRAY
66885: PPUSH
66886: LD_INT 2
66888: PUSH
66889: LD_INT 34
66891: PUSH
66892: LD_INT 13
66894: PUSH
66895: EMPTY
66896: LIST
66897: LIST
66898: PUSH
66899: LD_INT 34
66901: PUSH
66902: LD_INT 52
66904: PUSH
66905: EMPTY
66906: LIST
66907: LIST
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: LIST
66913: PPUSH
66914: CALL_OW 72
66918: ST_TO_ADDR
// if cranes then
66919: LD_VAR 0 6
66923: IFFALSE 67059
// begin for j in cranes do
66925: LD_ADDR_VAR 0 3
66929: PUSH
66930: LD_VAR 0 6
66934: PUSH
66935: FOR_IN
66936: IFFALSE 67057
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66938: LD_VAR 0 3
66942: PPUSH
66943: CALL_OW 256
66947: PUSH
66948: LD_INT 500
66950: GREATEREQUAL
66951: PUSH
66952: LD_VAR 0 3
66956: PPUSH
66957: CALL_OW 314
66961: NOT
66962: AND
66963: IFFALSE 66997
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66965: LD_VAR 0 3
66969: PPUSH
66970: LD_EXP 60
66974: PUSH
66975: LD_VAR 0 2
66979: ARRAY
66980: PPUSH
66981: LD_VAR 0 3
66985: PPUSH
66986: CALL_OW 74
66990: PPUSH
66991: CALL_OW 130
66995: GO 67055
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66997: LD_VAR 0 3
67001: PPUSH
67002: CALL_OW 256
67006: PUSH
67007: LD_INT 500
67009: LESS
67010: PUSH
67011: LD_VAR 0 3
67015: PPUSH
67016: LD_EXP 83
67020: PUSH
67021: LD_VAR 0 2
67025: ARRAY
67026: PPUSH
67027: CALL_OW 308
67031: NOT
67032: AND
67033: IFFALSE 67055
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67035: LD_VAR 0 3
67039: PPUSH
67040: LD_EXP 83
67044: PUSH
67045: LD_VAR 0 2
67049: ARRAY
67050: PPUSH
67051: CALL_OW 113
67055: GO 66935
67057: POP
67058: POP
// end ; if not tmp then
67059: LD_VAR 0 5
67063: NOT
67064: IFFALSE 67068
// continue ;
67066: GO 66584
// for j in tmp do
67068: LD_ADDR_VAR 0 3
67072: PUSH
67073: LD_VAR 0 5
67077: PUSH
67078: FOR_IN
67079: IFFALSE 67403
// begin if mc_need_heal [ i ] then
67081: LD_EXP 62
67085: PUSH
67086: LD_VAR 0 2
67090: ARRAY
67091: IFFALSE 67139
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
67093: LD_VAR 0 3
67097: PUSH
67098: LD_EXP 62
67102: PUSH
67103: LD_VAR 0 2
67107: ARRAY
67108: PUSH
67109: LD_INT 1
67111: ARRAY
67112: IN
67113: PUSH
67114: LD_VAR 0 3
67118: PUSH
67119: LD_EXP 62
67123: PUSH
67124: LD_VAR 0 2
67128: ARRAY
67129: PUSH
67130: LD_INT 2
67132: ARRAY
67133: IN
67134: OR
67135: IFFALSE 67139
// continue ;
67137: GO 67078
// if IsInUnit ( j ) then
67139: LD_VAR 0 3
67143: PPUSH
67144: CALL_OW 310
67148: IFFALSE 67159
// ComExitBuilding ( j ) ;
67150: LD_VAR 0 3
67154: PPUSH
67155: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
67159: LD_VAR 0 3
67163: PUSH
67164: LD_EXP 61
67168: PUSH
67169: LD_VAR 0 2
67173: ARRAY
67174: IN
67175: NOT
67176: IFFALSE 67234
// begin SetTag ( j , 101 ) ;
67178: LD_VAR 0 3
67182: PPUSH
67183: LD_INT 101
67185: PPUSH
67186: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
67190: LD_ADDR_EXP 61
67194: PUSH
67195: LD_EXP 61
67199: PPUSH
67200: LD_VAR 0 2
67204: PUSH
67205: LD_EXP 61
67209: PUSH
67210: LD_VAR 0 2
67214: ARRAY
67215: PUSH
67216: LD_INT 1
67218: PLUS
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PPUSH
67224: LD_VAR 0 3
67228: PPUSH
67229: CALL 21649 0 3
67233: ST_TO_ADDR
// end ; wait ( 1 ) ;
67234: LD_INT 1
67236: PPUSH
67237: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
67241: LD_ADDR_VAR 0 7
67245: PUSH
67246: LD_EXP 60
67250: PUSH
67251: LD_VAR 0 2
67255: ARRAY
67256: ST_TO_ADDR
// if mc_scan [ i ] then
67257: LD_EXP 82
67261: PUSH
67262: LD_VAR 0 2
67266: ARRAY
67267: IFFALSE 67336
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
67269: LD_ADDR_VAR 0 7
67273: PUSH
67274: LD_EXP 60
67278: PUSH
67279: LD_VAR 0 2
67283: ARRAY
67284: PPUSH
67285: LD_INT 3
67287: PUSH
67288: LD_INT 2
67290: PUSH
67291: LD_INT 30
67293: PUSH
67294: LD_INT 32
67296: PUSH
67297: EMPTY
67298: LIST
67299: LIST
67300: PUSH
67301: LD_INT 30
67303: PUSH
67304: LD_INT 33
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: PUSH
67311: LD_INT 30
67313: PUSH
67314: LD_INT 31
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: EMPTY
67322: LIST
67323: LIST
67324: LIST
67325: LIST
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PPUSH
67331: CALL_OW 72
67335: ST_TO_ADDR
// if not to_repair_tmp then
67336: LD_VAR 0 7
67340: NOT
67341: IFFALSE 67345
// continue ;
67343: GO 67078
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
67345: LD_ADDR_VAR 0 8
67349: PUSH
67350: LD_VAR 0 7
67354: PPUSH
67355: LD_VAR 0 3
67359: PPUSH
67360: CALL_OW 74
67364: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
67365: LD_VAR 0 8
67369: PPUSH
67370: LD_INT 14
67372: PPUSH
67373: CALL 24242 0 2
67377: PUSH
67378: LD_INT 4
67380: ARRAY
67381: PUSH
67382: LD_INT 5
67384: LESS
67385: IFFALSE 67401
// ComRepairBuilding ( j , to_repair ) ;
67387: LD_VAR 0 3
67391: PPUSH
67392: LD_VAR 0 8
67396: PPUSH
67397: CALL_OW 130
// end ;
67401: GO 67078
67403: POP
67404: POP
// end ;
67405: GO 66584
67407: POP
67408: POP
// end ;
67409: LD_VAR 0 1
67413: RET
// export function MC_Heal ; var i , j , tmp ; begin
67414: LD_INT 0
67416: PPUSH
67417: PPUSH
67418: PPUSH
67419: PPUSH
// if not mc_bases then
67420: LD_EXP 59
67424: NOT
67425: IFFALSE 67429
// exit ;
67427: GO 67831
// for i = 1 to mc_bases do
67429: LD_ADDR_VAR 0 2
67433: PUSH
67434: DOUBLE
67435: LD_INT 1
67437: DEC
67438: ST_TO_ADDR
67439: LD_EXP 59
67443: PUSH
67444: FOR_TO
67445: IFFALSE 67829
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
67447: LD_EXP 62
67451: PUSH
67452: LD_VAR 0 2
67456: ARRAY
67457: PUSH
67458: LD_INT 1
67460: ARRAY
67461: NOT
67462: PUSH
67463: LD_EXP 62
67467: PUSH
67468: LD_VAR 0 2
67472: ARRAY
67473: PUSH
67474: LD_INT 2
67476: ARRAY
67477: NOT
67478: AND
67479: IFFALSE 67517
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
67481: LD_ADDR_EXP 63
67485: PUSH
67486: LD_EXP 63
67490: PPUSH
67491: LD_VAR 0 2
67495: PPUSH
67496: EMPTY
67497: PPUSH
67498: CALL_OW 1
67502: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
67503: LD_VAR 0 2
67507: PPUSH
67508: LD_INT 102
67510: PPUSH
67511: CALL 61662 0 2
// continue ;
67515: GO 67444
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67517: LD_ADDR_VAR 0 4
67521: PUSH
67522: LD_EXP 59
67526: PUSH
67527: LD_VAR 0 2
67531: ARRAY
67532: PPUSH
67533: LD_INT 25
67535: PUSH
67536: LD_INT 4
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: PPUSH
67543: CALL_OW 72
67547: ST_TO_ADDR
// if not tmp then
67548: LD_VAR 0 4
67552: NOT
67553: IFFALSE 67557
// continue ;
67555: GO 67444
// if mc_taming [ i ] then
67557: LD_EXP 90
67561: PUSH
67562: LD_VAR 0 2
67566: ARRAY
67567: IFFALSE 67591
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67569: LD_ADDR_EXP 90
67573: PUSH
67574: LD_EXP 90
67578: PPUSH
67579: LD_VAR 0 2
67583: PPUSH
67584: EMPTY
67585: PPUSH
67586: CALL_OW 1
67590: ST_TO_ADDR
// for j in tmp do
67591: LD_ADDR_VAR 0 3
67595: PUSH
67596: LD_VAR 0 4
67600: PUSH
67601: FOR_IN
67602: IFFALSE 67825
// begin if IsInUnit ( j ) then
67604: LD_VAR 0 3
67608: PPUSH
67609: CALL_OW 310
67613: IFFALSE 67624
// ComExitBuilding ( j ) ;
67615: LD_VAR 0 3
67619: PPUSH
67620: CALL_OW 122
// if not j in mc_healers [ i ] then
67624: LD_VAR 0 3
67628: PUSH
67629: LD_EXP 63
67633: PUSH
67634: LD_VAR 0 2
67638: ARRAY
67639: IN
67640: NOT
67641: IFFALSE 67687
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67643: LD_ADDR_EXP 63
67647: PUSH
67648: LD_EXP 63
67652: PPUSH
67653: LD_VAR 0 2
67657: PUSH
67658: LD_EXP 63
67662: PUSH
67663: LD_VAR 0 2
67667: ARRAY
67668: PUSH
67669: LD_INT 1
67671: PLUS
67672: PUSH
67673: EMPTY
67674: LIST
67675: LIST
67676: PPUSH
67677: LD_VAR 0 3
67681: PPUSH
67682: CALL 21649 0 3
67686: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67687: LD_VAR 0 3
67691: PPUSH
67692: CALL_OW 110
67696: PUSH
67697: LD_INT 102
67699: NONEQUAL
67700: IFFALSE 67714
// SetTag ( j , 102 ) ;
67702: LD_VAR 0 3
67706: PPUSH
67707: LD_INT 102
67709: PPUSH
67710: CALL_OW 109
// Wait ( 3 ) ;
67714: LD_INT 3
67716: PPUSH
67717: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67721: LD_EXP 62
67725: PUSH
67726: LD_VAR 0 2
67730: ARRAY
67731: PUSH
67732: LD_INT 1
67734: ARRAY
67735: IFFALSE 67767
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67737: LD_VAR 0 3
67741: PPUSH
67742: LD_EXP 62
67746: PUSH
67747: LD_VAR 0 2
67751: ARRAY
67752: PUSH
67753: LD_INT 1
67755: ARRAY
67756: PUSH
67757: LD_INT 1
67759: ARRAY
67760: PPUSH
67761: CALL_OW 128
67765: GO 67823
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67767: LD_VAR 0 3
67771: PPUSH
67772: CALL_OW 314
67776: NOT
67777: PUSH
67778: LD_EXP 62
67782: PUSH
67783: LD_VAR 0 2
67787: ARRAY
67788: PUSH
67789: LD_INT 2
67791: ARRAY
67792: AND
67793: IFFALSE 67823
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67795: LD_VAR 0 3
67799: PPUSH
67800: LD_EXP 62
67804: PUSH
67805: LD_VAR 0 2
67809: ARRAY
67810: PUSH
67811: LD_INT 2
67813: ARRAY
67814: PUSH
67815: LD_INT 1
67817: ARRAY
67818: PPUSH
67819: CALL_OW 128
// end ;
67823: GO 67601
67825: POP
67826: POP
// end ;
67827: GO 67444
67829: POP
67830: POP
// end ;
67831: LD_VAR 0 1
67835: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
67836: LD_INT 0
67838: PPUSH
67839: PPUSH
67840: PPUSH
67841: PPUSH
67842: PPUSH
// if not mc_bases then
67843: LD_EXP 59
67847: NOT
67848: IFFALSE 67852
// exit ;
67850: GO 68995
// for i = 1 to mc_bases do
67852: LD_ADDR_VAR 0 2
67856: PUSH
67857: DOUBLE
67858: LD_INT 1
67860: DEC
67861: ST_TO_ADDR
67862: LD_EXP 59
67866: PUSH
67867: FOR_TO
67868: IFFALSE 68993
// begin if mc_scan [ i ] then
67870: LD_EXP 82
67874: PUSH
67875: LD_VAR 0 2
67879: ARRAY
67880: IFFALSE 67884
// continue ;
67882: GO 67867
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67884: LD_EXP 64
67888: PUSH
67889: LD_VAR 0 2
67893: ARRAY
67894: NOT
67895: PUSH
67896: LD_EXP 66
67900: PUSH
67901: LD_VAR 0 2
67905: ARRAY
67906: NOT
67907: AND
67908: PUSH
67909: LD_EXP 65
67913: PUSH
67914: LD_VAR 0 2
67918: ARRAY
67919: AND
67920: IFFALSE 67958
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67922: LD_ADDR_EXP 65
67926: PUSH
67927: LD_EXP 65
67931: PPUSH
67932: LD_VAR 0 2
67936: PPUSH
67937: EMPTY
67938: PPUSH
67939: CALL_OW 1
67943: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67944: LD_VAR 0 2
67948: PPUSH
67949: LD_INT 103
67951: PPUSH
67952: CALL 61662 0 2
// continue ;
67956: GO 67867
// end ; if mc_construct_list [ i ] then
67958: LD_EXP 66
67962: PUSH
67963: LD_VAR 0 2
67967: ARRAY
67968: IFFALSE 68188
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67970: LD_ADDR_VAR 0 4
67974: PUSH
67975: LD_EXP 59
67979: PUSH
67980: LD_VAR 0 2
67984: ARRAY
67985: PPUSH
67986: LD_INT 25
67988: PUSH
67989: LD_INT 2
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: PPUSH
67996: CALL_OW 72
68000: PUSH
68001: LD_EXP 61
68005: PUSH
68006: LD_VAR 0 2
68010: ARRAY
68011: DIFF
68012: ST_TO_ADDR
// if not tmp then
68013: LD_VAR 0 4
68017: NOT
68018: IFFALSE 68022
// continue ;
68020: GO 67867
// for j in tmp do
68022: LD_ADDR_VAR 0 3
68026: PUSH
68027: LD_VAR 0 4
68031: PUSH
68032: FOR_IN
68033: IFFALSE 68184
// begin if not mc_builders [ i ] then
68035: LD_EXP 65
68039: PUSH
68040: LD_VAR 0 2
68044: ARRAY
68045: NOT
68046: IFFALSE 68104
// begin SetTag ( j , 103 ) ;
68048: LD_VAR 0 3
68052: PPUSH
68053: LD_INT 103
68055: PPUSH
68056: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68060: LD_ADDR_EXP 65
68064: PUSH
68065: LD_EXP 65
68069: PPUSH
68070: LD_VAR 0 2
68074: PUSH
68075: LD_EXP 65
68079: PUSH
68080: LD_VAR 0 2
68084: ARRAY
68085: PUSH
68086: LD_INT 1
68088: PLUS
68089: PUSH
68090: EMPTY
68091: LIST
68092: LIST
68093: PPUSH
68094: LD_VAR 0 3
68098: PPUSH
68099: CALL 21649 0 3
68103: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68104: LD_VAR 0 3
68108: PPUSH
68109: CALL_OW 310
68113: IFFALSE 68124
// ComExitBuilding ( j ) ;
68115: LD_VAR 0 3
68119: PPUSH
68120: CALL_OW 122
// wait ( 3 ) ;
68124: LD_INT 3
68126: PPUSH
68127: CALL_OW 67
// if not mc_construct_list [ i ] then
68131: LD_EXP 66
68135: PUSH
68136: LD_VAR 0 2
68140: ARRAY
68141: NOT
68142: IFFALSE 68146
// break ;
68144: GO 68184
// if not HasTask ( j ) then
68146: LD_VAR 0 3
68150: PPUSH
68151: CALL_OW 314
68155: NOT
68156: IFFALSE 68182
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
68158: LD_VAR 0 3
68162: PPUSH
68163: LD_EXP 66
68167: PUSH
68168: LD_VAR 0 2
68172: ARRAY
68173: PUSH
68174: LD_INT 1
68176: ARRAY
68177: PPUSH
68178: CALL 24500 0 2
// end ;
68182: GO 68032
68184: POP
68185: POP
// end else
68186: GO 68991
// if mc_build_list [ i ] then
68188: LD_EXP 64
68192: PUSH
68193: LD_VAR 0 2
68197: ARRAY
68198: IFFALSE 68991
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68200: LD_ADDR_VAR 0 5
68204: PUSH
68205: LD_EXP 59
68209: PUSH
68210: LD_VAR 0 2
68214: ARRAY
68215: PPUSH
68216: LD_INT 2
68218: PUSH
68219: LD_INT 30
68221: PUSH
68222: LD_INT 0
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 30
68231: PUSH
68232: LD_INT 1
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: EMPTY
68240: LIST
68241: LIST
68242: LIST
68243: PPUSH
68244: CALL_OW 72
68248: ST_TO_ADDR
// if depot then
68249: LD_VAR 0 5
68253: IFFALSE 68271
// depot := depot [ 1 ] else
68255: LD_ADDR_VAR 0 5
68259: PUSH
68260: LD_VAR 0 5
68264: PUSH
68265: LD_INT 1
68267: ARRAY
68268: ST_TO_ADDR
68269: GO 68279
// depot := 0 ;
68271: LD_ADDR_VAR 0 5
68275: PUSH
68276: LD_INT 0
68278: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
68279: LD_EXP 64
68283: PUSH
68284: LD_VAR 0 2
68288: ARRAY
68289: PUSH
68290: LD_INT 1
68292: ARRAY
68293: PUSH
68294: LD_INT 1
68296: ARRAY
68297: PPUSH
68298: CALL 24330 0 1
68302: PUSH
68303: LD_EXP 59
68307: PUSH
68308: LD_VAR 0 2
68312: ARRAY
68313: PPUSH
68314: LD_INT 2
68316: PUSH
68317: LD_INT 30
68319: PUSH
68320: LD_INT 2
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: PUSH
68327: LD_INT 30
68329: PUSH
68330: LD_INT 3
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: LIST
68341: PPUSH
68342: CALL_OW 72
68346: NOT
68347: AND
68348: IFFALSE 68453
// begin for j = 1 to mc_build_list [ i ] do
68350: LD_ADDR_VAR 0 3
68354: PUSH
68355: DOUBLE
68356: LD_INT 1
68358: DEC
68359: ST_TO_ADDR
68360: LD_EXP 64
68364: PUSH
68365: LD_VAR 0 2
68369: ARRAY
68370: PUSH
68371: FOR_TO
68372: IFFALSE 68451
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
68374: LD_EXP 64
68378: PUSH
68379: LD_VAR 0 2
68383: ARRAY
68384: PUSH
68385: LD_VAR 0 3
68389: ARRAY
68390: PUSH
68391: LD_INT 1
68393: ARRAY
68394: PUSH
68395: LD_INT 2
68397: EQUAL
68398: IFFALSE 68449
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
68400: LD_ADDR_EXP 64
68404: PUSH
68405: LD_EXP 64
68409: PPUSH
68410: LD_VAR 0 2
68414: PPUSH
68415: LD_EXP 64
68419: PUSH
68420: LD_VAR 0 2
68424: ARRAY
68425: PPUSH
68426: LD_VAR 0 3
68430: PPUSH
68431: LD_INT 1
68433: PPUSH
68434: LD_INT 0
68436: PPUSH
68437: CALL 21067 0 4
68441: PPUSH
68442: CALL_OW 1
68446: ST_TO_ADDR
// break ;
68447: GO 68451
// end ;
68449: GO 68371
68451: POP
68452: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
68453: LD_EXP 64
68457: PUSH
68458: LD_VAR 0 2
68462: ARRAY
68463: PUSH
68464: LD_INT 1
68466: ARRAY
68467: PUSH
68468: LD_INT 1
68470: ARRAY
68471: PUSH
68472: LD_INT 0
68474: EQUAL
68475: PUSH
68476: LD_VAR 0 5
68480: PUSH
68481: LD_VAR 0 5
68485: PPUSH
68486: LD_EXP 64
68490: PUSH
68491: LD_VAR 0 2
68495: ARRAY
68496: PUSH
68497: LD_INT 1
68499: ARRAY
68500: PUSH
68501: LD_INT 1
68503: ARRAY
68504: PPUSH
68505: LD_EXP 64
68509: PUSH
68510: LD_VAR 0 2
68514: ARRAY
68515: PUSH
68516: LD_INT 1
68518: ARRAY
68519: PUSH
68520: LD_INT 2
68522: ARRAY
68523: PPUSH
68524: LD_EXP 64
68528: PUSH
68529: LD_VAR 0 2
68533: ARRAY
68534: PUSH
68535: LD_INT 1
68537: ARRAY
68538: PUSH
68539: LD_INT 3
68541: ARRAY
68542: PPUSH
68543: LD_EXP 64
68547: PUSH
68548: LD_VAR 0 2
68552: ARRAY
68553: PUSH
68554: LD_INT 1
68556: ARRAY
68557: PUSH
68558: LD_INT 4
68560: ARRAY
68561: PPUSH
68562: CALL 29064 0 5
68566: AND
68567: OR
68568: IFFALSE 68849
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68570: LD_ADDR_VAR 0 4
68574: PUSH
68575: LD_EXP 59
68579: PUSH
68580: LD_VAR 0 2
68584: ARRAY
68585: PPUSH
68586: LD_INT 25
68588: PUSH
68589: LD_INT 2
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: PPUSH
68596: CALL_OW 72
68600: PUSH
68601: LD_EXP 61
68605: PUSH
68606: LD_VAR 0 2
68610: ARRAY
68611: DIFF
68612: ST_TO_ADDR
// if not tmp then
68613: LD_VAR 0 4
68617: NOT
68618: IFFALSE 68622
// continue ;
68620: GO 67867
// for j in tmp do
68622: LD_ADDR_VAR 0 3
68626: PUSH
68627: LD_VAR 0 4
68631: PUSH
68632: FOR_IN
68633: IFFALSE 68845
// begin if not mc_builders [ i ] then
68635: LD_EXP 65
68639: PUSH
68640: LD_VAR 0 2
68644: ARRAY
68645: NOT
68646: IFFALSE 68704
// begin SetTag ( j , 103 ) ;
68648: LD_VAR 0 3
68652: PPUSH
68653: LD_INT 103
68655: PPUSH
68656: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68660: LD_ADDR_EXP 65
68664: PUSH
68665: LD_EXP 65
68669: PPUSH
68670: LD_VAR 0 2
68674: PUSH
68675: LD_EXP 65
68679: PUSH
68680: LD_VAR 0 2
68684: ARRAY
68685: PUSH
68686: LD_INT 1
68688: PLUS
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PPUSH
68694: LD_VAR 0 3
68698: PPUSH
68699: CALL 21649 0 3
68703: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68704: LD_VAR 0 3
68708: PPUSH
68709: CALL_OW 310
68713: IFFALSE 68724
// ComExitBuilding ( j ) ;
68715: LD_VAR 0 3
68719: PPUSH
68720: CALL_OW 122
// wait ( 3 ) ;
68724: LD_INT 3
68726: PPUSH
68727: CALL_OW 67
// if not mc_build_list [ i ] then
68731: LD_EXP 64
68735: PUSH
68736: LD_VAR 0 2
68740: ARRAY
68741: NOT
68742: IFFALSE 68746
// break ;
68744: GO 68845
// if not HasTask ( j ) then
68746: LD_VAR 0 3
68750: PPUSH
68751: CALL_OW 314
68755: NOT
68756: IFFALSE 68843
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68758: LD_VAR 0 3
68762: PPUSH
68763: LD_EXP 64
68767: PUSH
68768: LD_VAR 0 2
68772: ARRAY
68773: PUSH
68774: LD_INT 1
68776: ARRAY
68777: PUSH
68778: LD_INT 1
68780: ARRAY
68781: PPUSH
68782: LD_EXP 64
68786: PUSH
68787: LD_VAR 0 2
68791: ARRAY
68792: PUSH
68793: LD_INT 1
68795: ARRAY
68796: PUSH
68797: LD_INT 2
68799: ARRAY
68800: PPUSH
68801: LD_EXP 64
68805: PUSH
68806: LD_VAR 0 2
68810: ARRAY
68811: PUSH
68812: LD_INT 1
68814: ARRAY
68815: PUSH
68816: LD_INT 3
68818: ARRAY
68819: PPUSH
68820: LD_EXP 64
68824: PUSH
68825: LD_VAR 0 2
68829: ARRAY
68830: PUSH
68831: LD_INT 1
68833: ARRAY
68834: PUSH
68835: LD_INT 4
68837: ARRAY
68838: PPUSH
68839: CALL_OW 145
// end ;
68843: GO 68632
68845: POP
68846: POP
// end else
68847: GO 68991
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68849: LD_EXP 59
68853: PUSH
68854: LD_VAR 0 2
68858: ARRAY
68859: PPUSH
68860: LD_EXP 64
68864: PUSH
68865: LD_VAR 0 2
68869: ARRAY
68870: PUSH
68871: LD_INT 1
68873: ARRAY
68874: PUSH
68875: LD_INT 1
68877: ARRAY
68878: PPUSH
68879: LD_EXP 64
68883: PUSH
68884: LD_VAR 0 2
68888: ARRAY
68889: PUSH
68890: LD_INT 1
68892: ARRAY
68893: PUSH
68894: LD_INT 2
68896: ARRAY
68897: PPUSH
68898: LD_EXP 64
68902: PUSH
68903: LD_VAR 0 2
68907: ARRAY
68908: PUSH
68909: LD_INT 1
68911: ARRAY
68912: PUSH
68913: LD_INT 3
68915: ARRAY
68916: PPUSH
68917: LD_EXP 64
68921: PUSH
68922: LD_VAR 0 2
68926: ARRAY
68927: PUSH
68928: LD_INT 1
68930: ARRAY
68931: PUSH
68932: LD_INT 4
68934: ARRAY
68935: PPUSH
68936: CALL 28400 0 5
68940: NOT
68941: IFFALSE 68991
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68943: LD_ADDR_EXP 64
68947: PUSH
68948: LD_EXP 64
68952: PPUSH
68953: LD_VAR 0 2
68957: PPUSH
68958: LD_EXP 64
68962: PUSH
68963: LD_VAR 0 2
68967: ARRAY
68968: PPUSH
68969: LD_INT 1
68971: PPUSH
68972: LD_INT 1
68974: NEG
68975: PPUSH
68976: LD_INT 0
68978: PPUSH
68979: CALL 21067 0 4
68983: PPUSH
68984: CALL_OW 1
68988: ST_TO_ADDR
// continue ;
68989: GO 67867
// end ; end ; end ;
68991: GO 67867
68993: POP
68994: POP
// end ;
68995: LD_VAR 0 1
68999: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
69000: LD_INT 0
69002: PPUSH
69003: PPUSH
69004: PPUSH
69005: PPUSH
69006: PPUSH
69007: PPUSH
// if not mc_bases then
69008: LD_EXP 59
69012: NOT
69013: IFFALSE 69017
// exit ;
69015: GO 69444
// for i = 1 to mc_bases do
69017: LD_ADDR_VAR 0 2
69021: PUSH
69022: DOUBLE
69023: LD_INT 1
69025: DEC
69026: ST_TO_ADDR
69027: LD_EXP 59
69031: PUSH
69032: FOR_TO
69033: IFFALSE 69442
// begin tmp := mc_build_upgrade [ i ] ;
69035: LD_ADDR_VAR 0 4
69039: PUSH
69040: LD_EXP 91
69044: PUSH
69045: LD_VAR 0 2
69049: ARRAY
69050: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
69051: LD_ADDR_VAR 0 6
69055: PUSH
69056: LD_EXP 92
69060: PUSH
69061: LD_VAR 0 2
69065: ARRAY
69066: PPUSH
69067: LD_INT 2
69069: PUSH
69070: LD_INT 30
69072: PUSH
69073: LD_INT 6
69075: PUSH
69076: EMPTY
69077: LIST
69078: LIST
69079: PUSH
69080: LD_INT 30
69082: PUSH
69083: LD_INT 7
69085: PUSH
69086: EMPTY
69087: LIST
69088: LIST
69089: PUSH
69090: EMPTY
69091: LIST
69092: LIST
69093: LIST
69094: PPUSH
69095: CALL_OW 72
69099: ST_TO_ADDR
// if not tmp and not lab then
69100: LD_VAR 0 4
69104: NOT
69105: PUSH
69106: LD_VAR 0 6
69110: NOT
69111: AND
69112: IFFALSE 69116
// continue ;
69114: GO 69032
// if tmp then
69116: LD_VAR 0 4
69120: IFFALSE 69240
// for j in tmp do
69122: LD_ADDR_VAR 0 3
69126: PUSH
69127: LD_VAR 0 4
69131: PUSH
69132: FOR_IN
69133: IFFALSE 69238
// begin if UpgradeCost ( j ) then
69135: LD_VAR 0 3
69139: PPUSH
69140: CALL 28060 0 1
69144: IFFALSE 69236
// begin ComUpgrade ( j ) ;
69146: LD_VAR 0 3
69150: PPUSH
69151: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
69155: LD_ADDR_EXP 91
69159: PUSH
69160: LD_EXP 91
69164: PPUSH
69165: LD_VAR 0 2
69169: PPUSH
69170: LD_EXP 91
69174: PUSH
69175: LD_VAR 0 2
69179: ARRAY
69180: PUSH
69181: LD_VAR 0 3
69185: DIFF
69186: PPUSH
69187: CALL_OW 1
69191: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69192: LD_ADDR_EXP 66
69196: PUSH
69197: LD_EXP 66
69201: PPUSH
69202: LD_VAR 0 2
69206: PUSH
69207: LD_EXP 66
69211: PUSH
69212: LD_VAR 0 2
69216: ARRAY
69217: PUSH
69218: LD_INT 1
69220: PLUS
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PPUSH
69226: LD_VAR 0 3
69230: PPUSH
69231: CALL 21649 0 3
69235: ST_TO_ADDR
// end ; end ;
69236: GO 69132
69238: POP
69239: POP
// if not lab or not mc_lab_upgrade [ i ] then
69240: LD_VAR 0 6
69244: NOT
69245: PUSH
69246: LD_EXP 93
69250: PUSH
69251: LD_VAR 0 2
69255: ARRAY
69256: NOT
69257: OR
69258: IFFALSE 69262
// continue ;
69260: GO 69032
// for j in lab do
69262: LD_ADDR_VAR 0 3
69266: PUSH
69267: LD_VAR 0 6
69271: PUSH
69272: FOR_IN
69273: IFFALSE 69438
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
69275: LD_VAR 0 3
69279: PPUSH
69280: CALL_OW 266
69284: PUSH
69285: LD_INT 6
69287: PUSH
69288: LD_INT 7
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: IN
69295: PUSH
69296: LD_VAR 0 3
69300: PPUSH
69301: CALL_OW 461
69305: PUSH
69306: LD_INT 1
69308: NONEQUAL
69309: AND
69310: IFFALSE 69436
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
69312: LD_VAR 0 3
69316: PPUSH
69317: LD_EXP 93
69321: PUSH
69322: LD_VAR 0 2
69326: ARRAY
69327: PUSH
69328: LD_INT 1
69330: ARRAY
69331: PPUSH
69332: CALL 28265 0 2
69336: IFFALSE 69436
// begin ComCancel ( j ) ;
69338: LD_VAR 0 3
69342: PPUSH
69343: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
69347: LD_VAR 0 3
69351: PPUSH
69352: LD_EXP 93
69356: PUSH
69357: LD_VAR 0 2
69361: ARRAY
69362: PUSH
69363: LD_INT 1
69365: ARRAY
69366: PPUSH
69367: CALL_OW 207
// if not j in mc_construct_list [ i ] then
69371: LD_VAR 0 3
69375: PUSH
69376: LD_EXP 66
69380: PUSH
69381: LD_VAR 0 2
69385: ARRAY
69386: IN
69387: NOT
69388: IFFALSE 69434
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69390: LD_ADDR_EXP 66
69394: PUSH
69395: LD_EXP 66
69399: PPUSH
69400: LD_VAR 0 2
69404: PUSH
69405: LD_EXP 66
69409: PUSH
69410: LD_VAR 0 2
69414: ARRAY
69415: PUSH
69416: LD_INT 1
69418: PLUS
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PPUSH
69424: LD_VAR 0 3
69428: PPUSH
69429: CALL 21649 0 3
69433: ST_TO_ADDR
// break ;
69434: GO 69438
// end ; end ; end ;
69436: GO 69272
69438: POP
69439: POP
// end ;
69440: GO 69032
69442: POP
69443: POP
// end ;
69444: LD_VAR 0 1
69448: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
69449: LD_INT 0
69451: PPUSH
69452: PPUSH
69453: PPUSH
69454: PPUSH
69455: PPUSH
69456: PPUSH
69457: PPUSH
69458: PPUSH
69459: PPUSH
// if not mc_bases then
69460: LD_EXP 59
69464: NOT
69465: IFFALSE 69469
// exit ;
69467: GO 69874
// for i = 1 to mc_bases do
69469: LD_ADDR_VAR 0 2
69473: PUSH
69474: DOUBLE
69475: LD_INT 1
69477: DEC
69478: ST_TO_ADDR
69479: LD_EXP 59
69483: PUSH
69484: FOR_TO
69485: IFFALSE 69872
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
69487: LD_EXP 67
69491: PUSH
69492: LD_VAR 0 2
69496: ARRAY
69497: NOT
69498: PUSH
69499: LD_EXP 59
69503: PUSH
69504: LD_VAR 0 2
69508: ARRAY
69509: PPUSH
69510: LD_INT 30
69512: PUSH
69513: LD_INT 3
69515: PUSH
69516: EMPTY
69517: LIST
69518: LIST
69519: PPUSH
69520: CALL_OW 72
69524: NOT
69525: OR
69526: IFFALSE 69530
// continue ;
69528: GO 69484
// busy := false ;
69530: LD_ADDR_VAR 0 8
69534: PUSH
69535: LD_INT 0
69537: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69538: LD_ADDR_VAR 0 4
69542: PUSH
69543: LD_EXP 59
69547: PUSH
69548: LD_VAR 0 2
69552: ARRAY
69553: PPUSH
69554: LD_INT 30
69556: PUSH
69557: LD_INT 3
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PPUSH
69564: CALL_OW 72
69568: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69569: LD_ADDR_VAR 0 6
69573: PUSH
69574: LD_EXP 67
69578: PUSH
69579: LD_VAR 0 2
69583: ARRAY
69584: PPUSH
69585: LD_INT 2
69587: PUSH
69588: LD_INT 30
69590: PUSH
69591: LD_INT 32
69593: PUSH
69594: EMPTY
69595: LIST
69596: LIST
69597: PUSH
69598: LD_INT 30
69600: PUSH
69601: LD_INT 33
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: LIST
69612: PPUSH
69613: CALL_OW 72
69617: ST_TO_ADDR
// if not t then
69618: LD_VAR 0 6
69622: NOT
69623: IFFALSE 69627
// continue ;
69625: GO 69484
// for j in tmp do
69627: LD_ADDR_VAR 0 3
69631: PUSH
69632: LD_VAR 0 4
69636: PUSH
69637: FOR_IN
69638: IFFALSE 69668
// if not BuildingStatus ( j ) = bs_idle then
69640: LD_VAR 0 3
69644: PPUSH
69645: CALL_OW 461
69649: PUSH
69650: LD_INT 2
69652: EQUAL
69653: NOT
69654: IFFALSE 69666
// begin busy := true ;
69656: LD_ADDR_VAR 0 8
69660: PUSH
69661: LD_INT 1
69663: ST_TO_ADDR
// break ;
69664: GO 69668
// end ;
69666: GO 69637
69668: POP
69669: POP
// if busy then
69670: LD_VAR 0 8
69674: IFFALSE 69678
// continue ;
69676: GO 69484
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69678: LD_ADDR_VAR 0 7
69682: PUSH
69683: LD_VAR 0 6
69687: PPUSH
69688: LD_INT 35
69690: PUSH
69691: LD_INT 0
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PPUSH
69698: CALL_OW 72
69702: ST_TO_ADDR
// if tw then
69703: LD_VAR 0 7
69707: IFFALSE 69784
// begin tw := tw [ 1 ] ;
69709: LD_ADDR_VAR 0 7
69713: PUSH
69714: LD_VAR 0 7
69718: PUSH
69719: LD_INT 1
69721: ARRAY
69722: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69723: LD_ADDR_VAR 0 9
69727: PUSH
69728: LD_VAR 0 7
69732: PPUSH
69733: LD_EXP 84
69737: PUSH
69738: LD_VAR 0 2
69742: ARRAY
69743: PPUSH
69744: CALL 26619 0 2
69748: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69749: LD_EXP 98
69753: PUSH
69754: LD_VAR 0 2
69758: ARRAY
69759: IFFALSE 69782
// if not weapon in mc_allowed_tower_weapons [ i ] then
69761: LD_VAR 0 9
69765: PUSH
69766: LD_EXP 98
69770: PUSH
69771: LD_VAR 0 2
69775: ARRAY
69776: IN
69777: NOT
69778: IFFALSE 69782
// continue ;
69780: GO 69484
// end else
69782: GO 69847
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69784: LD_ADDR_VAR 0 5
69788: PUSH
69789: LD_EXP 67
69793: PUSH
69794: LD_VAR 0 2
69798: ARRAY
69799: PPUSH
69800: LD_VAR 0 4
69804: PPUSH
69805: CALL 56830 0 2
69809: ST_TO_ADDR
// if not tmp2 then
69810: LD_VAR 0 5
69814: NOT
69815: IFFALSE 69819
// continue ;
69817: GO 69484
// tw := tmp2 [ 1 ] ;
69819: LD_ADDR_VAR 0 7
69823: PUSH
69824: LD_VAR 0 5
69828: PUSH
69829: LD_INT 1
69831: ARRAY
69832: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69833: LD_ADDR_VAR 0 9
69837: PUSH
69838: LD_VAR 0 5
69842: PUSH
69843: LD_INT 2
69845: ARRAY
69846: ST_TO_ADDR
// end ; if not weapon then
69847: LD_VAR 0 9
69851: NOT
69852: IFFALSE 69856
// continue ;
69854: GO 69484
// ComPlaceWeapon ( tw , weapon ) ;
69856: LD_VAR 0 7
69860: PPUSH
69861: LD_VAR 0 9
69865: PPUSH
69866: CALL_OW 148
// end ;
69870: GO 69484
69872: POP
69873: POP
// end ;
69874: LD_VAR 0 1
69878: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
69879: LD_INT 0
69881: PPUSH
69882: PPUSH
69883: PPUSH
69884: PPUSH
69885: PPUSH
69886: PPUSH
// if not mc_bases then
69887: LD_EXP 59
69891: NOT
69892: IFFALSE 69896
// exit ;
69894: GO 70672
// for i = 1 to mc_bases do
69896: LD_ADDR_VAR 0 2
69900: PUSH
69901: DOUBLE
69902: LD_INT 1
69904: DEC
69905: ST_TO_ADDR
69906: LD_EXP 59
69910: PUSH
69911: FOR_TO
69912: IFFALSE 70670
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
69914: LD_EXP 72
69918: PUSH
69919: LD_VAR 0 2
69923: ARRAY
69924: NOT
69925: PUSH
69926: LD_EXP 72
69930: PUSH
69931: LD_VAR 0 2
69935: ARRAY
69936: PUSH
69937: LD_EXP 73
69941: PUSH
69942: LD_VAR 0 2
69946: ARRAY
69947: EQUAL
69948: OR
69949: PUSH
69950: LD_EXP 82
69954: PUSH
69955: LD_VAR 0 2
69959: ARRAY
69960: OR
69961: IFFALSE 69965
// continue ;
69963: GO 69911
// if mc_miners [ i ] then
69965: LD_EXP 73
69969: PUSH
69970: LD_VAR 0 2
69974: ARRAY
69975: IFFALSE 70357
// begin for j = mc_miners [ i ] downto 1 do
69977: LD_ADDR_VAR 0 3
69981: PUSH
69982: DOUBLE
69983: LD_EXP 73
69987: PUSH
69988: LD_VAR 0 2
69992: ARRAY
69993: INC
69994: ST_TO_ADDR
69995: LD_INT 1
69997: PUSH
69998: FOR_DOWNTO
69999: IFFALSE 70355
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
70001: LD_EXP 73
70005: PUSH
70006: LD_VAR 0 2
70010: ARRAY
70011: PUSH
70012: LD_VAR 0 3
70016: ARRAY
70017: PPUSH
70018: CALL_OW 301
70022: PUSH
70023: LD_EXP 73
70027: PUSH
70028: LD_VAR 0 2
70032: ARRAY
70033: PUSH
70034: LD_VAR 0 3
70038: ARRAY
70039: PPUSH
70040: CALL_OW 257
70044: PUSH
70045: LD_INT 1
70047: NONEQUAL
70048: OR
70049: IFFALSE 70112
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
70051: LD_ADDR_VAR 0 5
70055: PUSH
70056: LD_EXP 73
70060: PUSH
70061: LD_VAR 0 2
70065: ARRAY
70066: PUSH
70067: LD_EXP 73
70071: PUSH
70072: LD_VAR 0 2
70076: ARRAY
70077: PUSH
70078: LD_VAR 0 3
70082: ARRAY
70083: DIFF
70084: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
70085: LD_ADDR_EXP 73
70089: PUSH
70090: LD_EXP 73
70094: PPUSH
70095: LD_VAR 0 2
70099: PPUSH
70100: LD_VAR 0 5
70104: PPUSH
70105: CALL_OW 1
70109: ST_TO_ADDR
// continue ;
70110: GO 69998
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
70112: LD_EXP 73
70116: PUSH
70117: LD_VAR 0 2
70121: ARRAY
70122: PUSH
70123: LD_VAR 0 3
70127: ARRAY
70128: PPUSH
70129: CALL_OW 257
70133: PUSH
70134: LD_INT 1
70136: EQUAL
70137: PUSH
70138: LD_EXP 73
70142: PUSH
70143: LD_VAR 0 2
70147: ARRAY
70148: PUSH
70149: LD_VAR 0 3
70153: ARRAY
70154: PPUSH
70155: CALL_OW 459
70159: NOT
70160: AND
70161: PUSH
70162: LD_EXP 73
70166: PUSH
70167: LD_VAR 0 2
70171: ARRAY
70172: PUSH
70173: LD_VAR 0 3
70177: ARRAY
70178: PPUSH
70179: CALL_OW 314
70183: NOT
70184: AND
70185: IFFALSE 70353
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
70187: LD_EXP 73
70191: PUSH
70192: LD_VAR 0 2
70196: ARRAY
70197: PUSH
70198: LD_VAR 0 3
70202: ARRAY
70203: PPUSH
70204: CALL_OW 310
70208: IFFALSE 70231
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
70210: LD_EXP 73
70214: PUSH
70215: LD_VAR 0 2
70219: ARRAY
70220: PUSH
70221: LD_VAR 0 3
70225: ARRAY
70226: PPUSH
70227: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
70231: LD_EXP 73
70235: PUSH
70236: LD_VAR 0 2
70240: ARRAY
70241: PUSH
70242: LD_VAR 0 3
70246: ARRAY
70247: PPUSH
70248: CALL_OW 314
70252: NOT
70253: IFFALSE 70353
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
70255: LD_EXP 73
70259: PUSH
70260: LD_VAR 0 2
70264: ARRAY
70265: PUSH
70266: LD_VAR 0 3
70270: ARRAY
70271: PPUSH
70272: LD_EXP 72
70276: PUSH
70277: LD_VAR 0 2
70281: ARRAY
70282: PUSH
70283: LD_VAR 0 3
70287: PUSH
70288: LD_EXP 72
70292: PUSH
70293: LD_VAR 0 2
70297: ARRAY
70298: MOD
70299: PUSH
70300: LD_INT 1
70302: PLUS
70303: ARRAY
70304: PUSH
70305: LD_INT 1
70307: ARRAY
70308: PPUSH
70309: LD_EXP 72
70313: PUSH
70314: LD_VAR 0 2
70318: ARRAY
70319: PUSH
70320: LD_VAR 0 3
70324: PUSH
70325: LD_EXP 72
70329: PUSH
70330: LD_VAR 0 2
70334: ARRAY
70335: MOD
70336: PUSH
70337: LD_INT 1
70339: PLUS
70340: ARRAY
70341: PUSH
70342: LD_INT 2
70344: ARRAY
70345: PPUSH
70346: LD_INT 0
70348: PPUSH
70349: CALL_OW 193
// end ; end ;
70353: GO 69998
70355: POP
70356: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70357: LD_ADDR_VAR 0 5
70361: PUSH
70362: LD_EXP 59
70366: PUSH
70367: LD_VAR 0 2
70371: ARRAY
70372: PPUSH
70373: LD_INT 2
70375: PUSH
70376: LD_INT 30
70378: PUSH
70379: LD_INT 4
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PUSH
70386: LD_INT 30
70388: PUSH
70389: LD_INT 5
70391: PUSH
70392: EMPTY
70393: LIST
70394: LIST
70395: PUSH
70396: LD_INT 30
70398: PUSH
70399: LD_INT 32
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: EMPTY
70407: LIST
70408: LIST
70409: LIST
70410: LIST
70411: PPUSH
70412: CALL_OW 72
70416: ST_TO_ADDR
// if not tmp then
70417: LD_VAR 0 5
70421: NOT
70422: IFFALSE 70426
// continue ;
70424: GO 69911
// list := [ ] ;
70426: LD_ADDR_VAR 0 6
70430: PUSH
70431: EMPTY
70432: ST_TO_ADDR
// for j in tmp do
70433: LD_ADDR_VAR 0 3
70437: PUSH
70438: LD_VAR 0 5
70442: PUSH
70443: FOR_IN
70444: IFFALSE 70513
// begin for k in UnitsInside ( j ) do
70446: LD_ADDR_VAR 0 4
70450: PUSH
70451: LD_VAR 0 3
70455: PPUSH
70456: CALL_OW 313
70460: PUSH
70461: FOR_IN
70462: IFFALSE 70509
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70464: LD_VAR 0 4
70468: PPUSH
70469: CALL_OW 257
70473: PUSH
70474: LD_INT 1
70476: EQUAL
70477: PUSH
70478: LD_VAR 0 4
70482: PPUSH
70483: CALL_OW 459
70487: NOT
70488: AND
70489: IFFALSE 70507
// list := list ^ k ;
70491: LD_ADDR_VAR 0 6
70495: PUSH
70496: LD_VAR 0 6
70500: PUSH
70501: LD_VAR 0 4
70505: ADD
70506: ST_TO_ADDR
70507: GO 70461
70509: POP
70510: POP
// end ;
70511: GO 70443
70513: POP
70514: POP
// list := list diff mc_miners [ i ] ;
70515: LD_ADDR_VAR 0 6
70519: PUSH
70520: LD_VAR 0 6
70524: PUSH
70525: LD_EXP 73
70529: PUSH
70530: LD_VAR 0 2
70534: ARRAY
70535: DIFF
70536: ST_TO_ADDR
// if not list then
70537: LD_VAR 0 6
70541: NOT
70542: IFFALSE 70546
// continue ;
70544: GO 69911
// k := mc_mines [ i ] - mc_miners [ i ] ;
70546: LD_ADDR_VAR 0 4
70550: PUSH
70551: LD_EXP 72
70555: PUSH
70556: LD_VAR 0 2
70560: ARRAY
70561: PUSH
70562: LD_EXP 73
70566: PUSH
70567: LD_VAR 0 2
70571: ARRAY
70572: MINUS
70573: ST_TO_ADDR
// if k > list then
70574: LD_VAR 0 4
70578: PUSH
70579: LD_VAR 0 6
70583: GREATER
70584: IFFALSE 70596
// k := list ;
70586: LD_ADDR_VAR 0 4
70590: PUSH
70591: LD_VAR 0 6
70595: ST_TO_ADDR
// for j = 1 to k do
70596: LD_ADDR_VAR 0 3
70600: PUSH
70601: DOUBLE
70602: LD_INT 1
70604: DEC
70605: ST_TO_ADDR
70606: LD_VAR 0 4
70610: PUSH
70611: FOR_TO
70612: IFFALSE 70666
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70614: LD_ADDR_EXP 73
70618: PUSH
70619: LD_EXP 73
70623: PPUSH
70624: LD_VAR 0 2
70628: PUSH
70629: LD_EXP 73
70633: PUSH
70634: LD_VAR 0 2
70638: ARRAY
70639: PUSH
70640: LD_INT 1
70642: PLUS
70643: PUSH
70644: EMPTY
70645: LIST
70646: LIST
70647: PPUSH
70648: LD_VAR 0 6
70652: PUSH
70653: LD_VAR 0 3
70657: ARRAY
70658: PPUSH
70659: CALL 21649 0 3
70663: ST_TO_ADDR
70664: GO 70611
70666: POP
70667: POP
// end ;
70668: GO 69911
70670: POP
70671: POP
// end ;
70672: LD_VAR 0 1
70676: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
70677: LD_INT 0
70679: PPUSH
70680: PPUSH
70681: PPUSH
70682: PPUSH
70683: PPUSH
70684: PPUSH
70685: PPUSH
70686: PPUSH
70687: PPUSH
70688: PPUSH
// if not mc_bases then
70689: LD_EXP 59
70693: NOT
70694: IFFALSE 70698
// exit ;
70696: GO 72448
// for i = 1 to mc_bases do
70698: LD_ADDR_VAR 0 2
70702: PUSH
70703: DOUBLE
70704: LD_INT 1
70706: DEC
70707: ST_TO_ADDR
70708: LD_EXP 59
70712: PUSH
70713: FOR_TO
70714: IFFALSE 72446
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70716: LD_EXP 59
70720: PUSH
70721: LD_VAR 0 2
70725: ARRAY
70726: NOT
70727: PUSH
70728: LD_EXP 66
70732: PUSH
70733: LD_VAR 0 2
70737: ARRAY
70738: OR
70739: IFFALSE 70743
// continue ;
70741: GO 70713
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70743: LD_EXP 75
70747: PUSH
70748: LD_VAR 0 2
70752: ARRAY
70753: NOT
70754: PUSH
70755: LD_EXP 76
70759: PUSH
70760: LD_VAR 0 2
70764: ARRAY
70765: AND
70766: IFFALSE 70804
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70768: LD_ADDR_EXP 76
70772: PUSH
70773: LD_EXP 76
70777: PPUSH
70778: LD_VAR 0 2
70782: PPUSH
70783: EMPTY
70784: PPUSH
70785: CALL_OW 1
70789: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70790: LD_VAR 0 2
70794: PPUSH
70795: LD_INT 107
70797: PPUSH
70798: CALL 61662 0 2
// continue ;
70802: GO 70713
// end ; target := [ ] ;
70804: LD_ADDR_VAR 0 6
70808: PUSH
70809: EMPTY
70810: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70811: LD_ADDR_VAR 0 3
70815: PUSH
70816: DOUBLE
70817: LD_EXP 75
70821: PUSH
70822: LD_VAR 0 2
70826: ARRAY
70827: INC
70828: ST_TO_ADDR
70829: LD_INT 1
70831: PUSH
70832: FOR_DOWNTO
70833: IFFALSE 71093
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70835: LD_EXP 75
70839: PUSH
70840: LD_VAR 0 2
70844: ARRAY
70845: PUSH
70846: LD_VAR 0 3
70850: ARRAY
70851: PUSH
70852: LD_INT 2
70854: ARRAY
70855: PPUSH
70856: LD_EXP 75
70860: PUSH
70861: LD_VAR 0 2
70865: ARRAY
70866: PUSH
70867: LD_VAR 0 3
70871: ARRAY
70872: PUSH
70873: LD_INT 3
70875: ARRAY
70876: PPUSH
70877: CALL_OW 488
70881: PUSH
70882: LD_EXP 75
70886: PUSH
70887: LD_VAR 0 2
70891: ARRAY
70892: PUSH
70893: LD_VAR 0 3
70897: ARRAY
70898: PUSH
70899: LD_INT 2
70901: ARRAY
70902: PPUSH
70903: LD_EXP 75
70907: PUSH
70908: LD_VAR 0 2
70912: ARRAY
70913: PUSH
70914: LD_VAR 0 3
70918: ARRAY
70919: PUSH
70920: LD_INT 3
70922: ARRAY
70923: PPUSH
70924: CALL_OW 284
70928: PUSH
70929: LD_INT 0
70931: EQUAL
70932: AND
70933: IFFALSE 70988
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70935: LD_ADDR_VAR 0 5
70939: PUSH
70940: LD_EXP 75
70944: PUSH
70945: LD_VAR 0 2
70949: ARRAY
70950: PPUSH
70951: LD_VAR 0 3
70955: PPUSH
70956: CALL_OW 3
70960: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70961: LD_ADDR_EXP 75
70965: PUSH
70966: LD_EXP 75
70970: PPUSH
70971: LD_VAR 0 2
70975: PPUSH
70976: LD_VAR 0 5
70980: PPUSH
70981: CALL_OW 1
70985: ST_TO_ADDR
// continue ;
70986: GO 70832
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70988: LD_EXP 59
70992: PUSH
70993: LD_VAR 0 2
70997: ARRAY
70998: PUSH
70999: LD_INT 1
71001: ARRAY
71002: PPUSH
71003: CALL_OW 255
71007: PPUSH
71008: LD_EXP 75
71012: PUSH
71013: LD_VAR 0 2
71017: ARRAY
71018: PUSH
71019: LD_VAR 0 3
71023: ARRAY
71024: PUSH
71025: LD_INT 2
71027: ARRAY
71028: PPUSH
71029: LD_EXP 75
71033: PUSH
71034: LD_VAR 0 2
71038: ARRAY
71039: PUSH
71040: LD_VAR 0 3
71044: ARRAY
71045: PUSH
71046: LD_INT 3
71048: ARRAY
71049: PPUSH
71050: LD_INT 30
71052: PPUSH
71053: CALL 22545 0 4
71057: PUSH
71058: LD_INT 4
71060: ARRAY
71061: PUSH
71062: LD_INT 0
71064: EQUAL
71065: IFFALSE 71091
// begin target := mc_crates [ i ] [ j ] ;
71067: LD_ADDR_VAR 0 6
71071: PUSH
71072: LD_EXP 75
71076: PUSH
71077: LD_VAR 0 2
71081: ARRAY
71082: PUSH
71083: LD_VAR 0 3
71087: ARRAY
71088: ST_TO_ADDR
// break ;
71089: GO 71093
// end ; end ;
71091: GO 70832
71093: POP
71094: POP
// if not target then
71095: LD_VAR 0 6
71099: NOT
71100: IFFALSE 71104
// continue ;
71102: GO 70713
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
71104: LD_ADDR_VAR 0 7
71108: PUSH
71109: LD_EXP 78
71113: PUSH
71114: LD_VAR 0 2
71118: ARRAY
71119: PPUSH
71120: LD_INT 2
71122: PUSH
71123: LD_INT 3
71125: PUSH
71126: LD_INT 58
71128: PUSH
71129: EMPTY
71130: LIST
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: PUSH
71136: LD_INT 61
71138: PUSH
71139: EMPTY
71140: LIST
71141: PUSH
71142: LD_INT 33
71144: PUSH
71145: LD_INT 5
71147: PUSH
71148: EMPTY
71149: LIST
71150: LIST
71151: PUSH
71152: LD_INT 33
71154: PUSH
71155: LD_INT 3
71157: PUSH
71158: EMPTY
71159: LIST
71160: LIST
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: LIST
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 2
71171: PUSH
71172: LD_INT 34
71174: PUSH
71175: LD_INT 32
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 34
71184: PUSH
71185: LD_INT 51
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: PUSH
71192: LD_INT 34
71194: PUSH
71195: LD_INT 12
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: LIST
71206: LIST
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PPUSH
71212: CALL_OW 72
71216: ST_TO_ADDR
// if not cargo then
71217: LD_VAR 0 7
71221: NOT
71222: IFFALSE 71865
// begin if mc_crates_collector [ i ] < 5 then
71224: LD_EXP 76
71228: PUSH
71229: LD_VAR 0 2
71233: ARRAY
71234: PUSH
71235: LD_INT 5
71237: LESS
71238: IFFALSE 71604
// begin if mc_ape [ i ] then
71240: LD_EXP 88
71244: PUSH
71245: LD_VAR 0 2
71249: ARRAY
71250: IFFALSE 71297
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
71252: LD_ADDR_VAR 0 5
71256: PUSH
71257: LD_EXP 88
71261: PUSH
71262: LD_VAR 0 2
71266: ARRAY
71267: PPUSH
71268: LD_INT 25
71270: PUSH
71271: LD_INT 16
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PUSH
71278: LD_INT 24
71280: PUSH
71281: LD_INT 750
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: PPUSH
71292: CALL_OW 72
71296: ST_TO_ADDR
// if not tmp then
71297: LD_VAR 0 5
71301: NOT
71302: IFFALSE 71349
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
71304: LD_ADDR_VAR 0 5
71308: PUSH
71309: LD_EXP 59
71313: PUSH
71314: LD_VAR 0 2
71318: ARRAY
71319: PPUSH
71320: LD_INT 25
71322: PUSH
71323: LD_INT 2
71325: PUSH
71326: EMPTY
71327: LIST
71328: LIST
71329: PUSH
71330: LD_INT 24
71332: PUSH
71333: LD_INT 750
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PPUSH
71344: CALL_OW 72
71348: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71349: LD_EXP 88
71353: PUSH
71354: LD_VAR 0 2
71358: ARRAY
71359: PUSH
71360: LD_EXP 59
71364: PUSH
71365: LD_VAR 0 2
71369: ARRAY
71370: PPUSH
71371: LD_INT 25
71373: PUSH
71374: LD_INT 2
71376: PUSH
71377: EMPTY
71378: LIST
71379: LIST
71380: PUSH
71381: LD_INT 24
71383: PUSH
71384: LD_INT 750
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: PUSH
71391: EMPTY
71392: LIST
71393: LIST
71394: PPUSH
71395: CALL_OW 72
71399: AND
71400: PUSH
71401: LD_VAR 0 5
71405: PUSH
71406: LD_INT 5
71408: LESS
71409: AND
71410: IFFALSE 71492
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71412: LD_ADDR_VAR 0 3
71416: PUSH
71417: LD_EXP 59
71421: PUSH
71422: LD_VAR 0 2
71426: ARRAY
71427: PPUSH
71428: LD_INT 25
71430: PUSH
71431: LD_INT 2
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PUSH
71438: LD_INT 24
71440: PUSH
71441: LD_INT 750
71443: PUSH
71444: EMPTY
71445: LIST
71446: LIST
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PPUSH
71452: CALL_OW 72
71456: PUSH
71457: FOR_IN
71458: IFFALSE 71490
// begin tmp := tmp union j ;
71460: LD_ADDR_VAR 0 5
71464: PUSH
71465: LD_VAR 0 5
71469: PUSH
71470: LD_VAR 0 3
71474: UNION
71475: ST_TO_ADDR
// if tmp >= 5 then
71476: LD_VAR 0 5
71480: PUSH
71481: LD_INT 5
71483: GREATEREQUAL
71484: IFFALSE 71488
// break ;
71486: GO 71490
// end ;
71488: GO 71457
71490: POP
71491: POP
// end ; if not tmp then
71492: LD_VAR 0 5
71496: NOT
71497: IFFALSE 71501
// continue ;
71499: GO 70713
// for j in tmp do
71501: LD_ADDR_VAR 0 3
71505: PUSH
71506: LD_VAR 0 5
71510: PUSH
71511: FOR_IN
71512: IFFALSE 71602
// if not GetTag ( j ) then
71514: LD_VAR 0 3
71518: PPUSH
71519: CALL_OW 110
71523: NOT
71524: IFFALSE 71600
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71526: LD_ADDR_EXP 76
71530: PUSH
71531: LD_EXP 76
71535: PPUSH
71536: LD_VAR 0 2
71540: PUSH
71541: LD_EXP 76
71545: PUSH
71546: LD_VAR 0 2
71550: ARRAY
71551: PUSH
71552: LD_INT 1
71554: PLUS
71555: PUSH
71556: EMPTY
71557: LIST
71558: LIST
71559: PPUSH
71560: LD_VAR 0 3
71564: PPUSH
71565: CALL 21649 0 3
71569: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71570: LD_VAR 0 3
71574: PPUSH
71575: LD_INT 107
71577: PPUSH
71578: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71582: LD_EXP 76
71586: PUSH
71587: LD_VAR 0 2
71591: ARRAY
71592: PUSH
71593: LD_INT 5
71595: GREATEREQUAL
71596: IFFALSE 71600
// break ;
71598: GO 71602
// end ;
71600: GO 71511
71602: POP
71603: POP
// end ; if mc_crates_collector [ i ] and target then
71604: LD_EXP 76
71608: PUSH
71609: LD_VAR 0 2
71613: ARRAY
71614: PUSH
71615: LD_VAR 0 6
71619: AND
71620: IFFALSE 71863
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71622: LD_EXP 76
71626: PUSH
71627: LD_VAR 0 2
71631: ARRAY
71632: PUSH
71633: LD_VAR 0 6
71637: PUSH
71638: LD_INT 1
71640: ARRAY
71641: LESS
71642: IFFALSE 71662
// tmp := mc_crates_collector [ i ] else
71644: LD_ADDR_VAR 0 5
71648: PUSH
71649: LD_EXP 76
71653: PUSH
71654: LD_VAR 0 2
71658: ARRAY
71659: ST_TO_ADDR
71660: GO 71676
// tmp := target [ 1 ] ;
71662: LD_ADDR_VAR 0 5
71666: PUSH
71667: LD_VAR 0 6
71671: PUSH
71672: LD_INT 1
71674: ARRAY
71675: ST_TO_ADDR
// k := 0 ;
71676: LD_ADDR_VAR 0 4
71680: PUSH
71681: LD_INT 0
71683: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71684: LD_ADDR_VAR 0 3
71688: PUSH
71689: LD_EXP 76
71693: PUSH
71694: LD_VAR 0 2
71698: ARRAY
71699: PUSH
71700: FOR_IN
71701: IFFALSE 71861
// begin k := k + 1 ;
71703: LD_ADDR_VAR 0 4
71707: PUSH
71708: LD_VAR 0 4
71712: PUSH
71713: LD_INT 1
71715: PLUS
71716: ST_TO_ADDR
// if k > tmp then
71717: LD_VAR 0 4
71721: PUSH
71722: LD_VAR 0 5
71726: GREATER
71727: IFFALSE 71731
// break ;
71729: GO 71861
// if not GetClass ( j ) in [ 2 , 16 ] then
71731: LD_VAR 0 3
71735: PPUSH
71736: CALL_OW 257
71740: PUSH
71741: LD_INT 2
71743: PUSH
71744: LD_INT 16
71746: PUSH
71747: EMPTY
71748: LIST
71749: LIST
71750: IN
71751: NOT
71752: IFFALSE 71805
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71754: LD_ADDR_EXP 76
71758: PUSH
71759: LD_EXP 76
71763: PPUSH
71764: LD_VAR 0 2
71768: PPUSH
71769: LD_EXP 76
71773: PUSH
71774: LD_VAR 0 2
71778: ARRAY
71779: PUSH
71780: LD_VAR 0 3
71784: DIFF
71785: PPUSH
71786: CALL_OW 1
71790: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71791: LD_VAR 0 3
71795: PPUSH
71796: LD_INT 0
71798: PPUSH
71799: CALL_OW 109
// continue ;
71803: GO 71700
// end ; if IsInUnit ( j ) then
71805: LD_VAR 0 3
71809: PPUSH
71810: CALL_OW 310
71814: IFFALSE 71825
// ComExitBuilding ( j ) ;
71816: LD_VAR 0 3
71820: PPUSH
71821: CALL_OW 122
// wait ( 3 ) ;
71825: LD_INT 3
71827: PPUSH
71828: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71832: LD_VAR 0 3
71836: PPUSH
71837: LD_VAR 0 6
71841: PUSH
71842: LD_INT 2
71844: ARRAY
71845: PPUSH
71846: LD_VAR 0 6
71850: PUSH
71851: LD_INT 3
71853: ARRAY
71854: PPUSH
71855: CALL_OW 117
// end ;
71859: GO 71700
71861: POP
71862: POP
// end ; end else
71863: GO 72444
// begin for j in cargo do
71865: LD_ADDR_VAR 0 3
71869: PUSH
71870: LD_VAR 0 7
71874: PUSH
71875: FOR_IN
71876: IFFALSE 72442
// begin if GetTag ( j ) <> 0 then
71878: LD_VAR 0 3
71882: PPUSH
71883: CALL_OW 110
71887: PUSH
71888: LD_INT 0
71890: NONEQUAL
71891: IFFALSE 71895
// continue ;
71893: GO 71875
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71895: LD_VAR 0 3
71899: PPUSH
71900: CALL_OW 256
71904: PUSH
71905: LD_INT 1000
71907: LESS
71908: PUSH
71909: LD_VAR 0 3
71913: PPUSH
71914: LD_EXP 83
71918: PUSH
71919: LD_VAR 0 2
71923: ARRAY
71924: PPUSH
71925: CALL_OW 308
71929: NOT
71930: AND
71931: IFFALSE 71953
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71933: LD_VAR 0 3
71937: PPUSH
71938: LD_EXP 83
71942: PUSH
71943: LD_VAR 0 2
71947: ARRAY
71948: PPUSH
71949: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71953: LD_VAR 0 3
71957: PPUSH
71958: CALL_OW 256
71962: PUSH
71963: LD_INT 1000
71965: LESS
71966: PUSH
71967: LD_VAR 0 3
71971: PPUSH
71972: LD_EXP 83
71976: PUSH
71977: LD_VAR 0 2
71981: ARRAY
71982: PPUSH
71983: CALL_OW 308
71987: AND
71988: IFFALSE 71992
// continue ;
71990: GO 71875
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71992: LD_VAR 0 3
71996: PPUSH
71997: CALL_OW 262
72001: PUSH
72002: LD_INT 2
72004: EQUAL
72005: PUSH
72006: LD_VAR 0 3
72010: PPUSH
72011: CALL_OW 261
72015: PUSH
72016: LD_INT 15
72018: LESS
72019: AND
72020: IFFALSE 72024
// continue ;
72022: GO 71875
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
72024: LD_VAR 0 3
72028: PPUSH
72029: CALL_OW 262
72033: PUSH
72034: LD_INT 1
72036: EQUAL
72037: PUSH
72038: LD_VAR 0 3
72042: PPUSH
72043: CALL_OW 261
72047: PUSH
72048: LD_INT 10
72050: LESS
72051: AND
72052: IFFALSE 72381
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72054: LD_ADDR_VAR 0 8
72058: PUSH
72059: LD_EXP 59
72063: PUSH
72064: LD_VAR 0 2
72068: ARRAY
72069: PPUSH
72070: LD_INT 2
72072: PUSH
72073: LD_INT 30
72075: PUSH
72076: LD_INT 0
72078: PUSH
72079: EMPTY
72080: LIST
72081: LIST
72082: PUSH
72083: LD_INT 30
72085: PUSH
72086: LD_INT 1
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: LIST
72097: PPUSH
72098: CALL_OW 72
72102: ST_TO_ADDR
// if not depot then
72103: LD_VAR 0 8
72107: NOT
72108: IFFALSE 72112
// continue ;
72110: GO 71875
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
72112: LD_VAR 0 3
72116: PPUSH
72117: LD_VAR 0 8
72121: PPUSH
72122: LD_VAR 0 3
72126: PPUSH
72127: CALL_OW 74
72131: PPUSH
72132: CALL_OW 296
72136: PUSH
72137: LD_INT 6
72139: LESS
72140: IFFALSE 72156
// SetFuel ( j , 100 ) else
72142: LD_VAR 0 3
72146: PPUSH
72147: LD_INT 100
72149: PPUSH
72150: CALL_OW 240
72154: GO 72381
// if GetFuel ( j ) = 0 then
72156: LD_VAR 0 3
72160: PPUSH
72161: CALL_OW 261
72165: PUSH
72166: LD_INT 0
72168: EQUAL
72169: IFFALSE 72381
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
72171: LD_ADDR_EXP 78
72175: PUSH
72176: LD_EXP 78
72180: PPUSH
72181: LD_VAR 0 2
72185: PPUSH
72186: LD_EXP 78
72190: PUSH
72191: LD_VAR 0 2
72195: ARRAY
72196: PUSH
72197: LD_VAR 0 3
72201: DIFF
72202: PPUSH
72203: CALL_OW 1
72207: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
72208: LD_VAR 0 3
72212: PPUSH
72213: CALL_OW 263
72217: PUSH
72218: LD_INT 1
72220: EQUAL
72221: IFFALSE 72237
// ComExitVehicle ( IsInUnit ( j ) ) ;
72223: LD_VAR 0 3
72227: PPUSH
72228: CALL_OW 310
72232: PPUSH
72233: CALL_OW 121
// if GetControl ( j ) = control_remote then
72237: LD_VAR 0 3
72241: PPUSH
72242: CALL_OW 263
72246: PUSH
72247: LD_INT 2
72249: EQUAL
72250: IFFALSE 72261
// ComUnlink ( j ) ;
72252: LD_VAR 0 3
72256: PPUSH
72257: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
72261: LD_ADDR_VAR 0 9
72265: PUSH
72266: LD_VAR 0 2
72270: PPUSH
72271: LD_INT 3
72273: PPUSH
72274: CALL 81734 0 2
72278: ST_TO_ADDR
// if fac then
72279: LD_VAR 0 9
72283: IFFALSE 72379
// begin for k in fac do
72285: LD_ADDR_VAR 0 4
72289: PUSH
72290: LD_VAR 0 9
72294: PUSH
72295: FOR_IN
72296: IFFALSE 72377
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
72298: LD_ADDR_VAR 0 10
72302: PUSH
72303: LD_VAR 0 9
72307: PPUSH
72308: LD_VAR 0 3
72312: PPUSH
72313: CALL_OW 265
72317: PPUSH
72318: LD_VAR 0 3
72322: PPUSH
72323: CALL_OW 262
72327: PPUSH
72328: LD_VAR 0 3
72332: PPUSH
72333: CALL_OW 263
72337: PPUSH
72338: LD_VAR 0 3
72342: PPUSH
72343: CALL_OW 264
72347: PPUSH
72348: CALL 19181 0 5
72352: ST_TO_ADDR
// if components then
72353: LD_VAR 0 10
72357: IFFALSE 72375
// begin MC_InsertProduceList ( i , components ) ;
72359: LD_VAR 0 2
72363: PPUSH
72364: LD_VAR 0 10
72368: PPUSH
72369: CALL 81279 0 2
// break ;
72373: GO 72377
// end ; end ;
72375: GO 72295
72377: POP
72378: POP
// end ; continue ;
72379: GO 71875
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72381: LD_VAR 0 3
72385: PPUSH
72386: LD_INT 1
72388: PPUSH
72389: CALL_OW 289
72393: PUSH
72394: LD_INT 100
72396: LESS
72397: PUSH
72398: LD_VAR 0 3
72402: PPUSH
72403: CALL_OW 314
72407: NOT
72408: AND
72409: IFFALSE 72438
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72411: LD_VAR 0 3
72415: PPUSH
72416: LD_VAR 0 6
72420: PUSH
72421: LD_INT 2
72423: ARRAY
72424: PPUSH
72425: LD_VAR 0 6
72429: PUSH
72430: LD_INT 3
72432: ARRAY
72433: PPUSH
72434: CALL_OW 117
// break ;
72438: GO 72442
// end ;
72440: GO 71875
72442: POP
72443: POP
// end ; end ;
72444: GO 70713
72446: POP
72447: POP
// end ;
72448: LD_VAR 0 1
72452: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72453: LD_INT 0
72455: PPUSH
72456: PPUSH
72457: PPUSH
72458: PPUSH
// if not mc_bases then
72459: LD_EXP 59
72463: NOT
72464: IFFALSE 72468
// exit ;
72466: GO 72629
// for i = 1 to mc_bases do
72468: LD_ADDR_VAR 0 2
72472: PUSH
72473: DOUBLE
72474: LD_INT 1
72476: DEC
72477: ST_TO_ADDR
72478: LD_EXP 59
72482: PUSH
72483: FOR_TO
72484: IFFALSE 72627
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72486: LD_ADDR_VAR 0 4
72490: PUSH
72491: LD_EXP 78
72495: PUSH
72496: LD_VAR 0 2
72500: ARRAY
72501: PUSH
72502: LD_EXP 81
72506: PUSH
72507: LD_VAR 0 2
72511: ARRAY
72512: UNION
72513: PPUSH
72514: LD_INT 33
72516: PUSH
72517: LD_INT 2
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PPUSH
72524: CALL_OW 72
72528: ST_TO_ADDR
// if tmp then
72529: LD_VAR 0 4
72533: IFFALSE 72625
// for j in tmp do
72535: LD_ADDR_VAR 0 3
72539: PUSH
72540: LD_VAR 0 4
72544: PUSH
72545: FOR_IN
72546: IFFALSE 72623
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72548: LD_VAR 0 3
72552: PPUSH
72553: CALL_OW 312
72557: NOT
72558: PUSH
72559: LD_VAR 0 3
72563: PPUSH
72564: CALL_OW 256
72568: PUSH
72569: LD_INT 250
72571: GREATEREQUAL
72572: AND
72573: IFFALSE 72586
// Connect ( j ) else
72575: LD_VAR 0 3
72579: PPUSH
72580: CALL 24582 0 1
72584: GO 72621
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72586: LD_VAR 0 3
72590: PPUSH
72591: CALL_OW 256
72595: PUSH
72596: LD_INT 250
72598: LESS
72599: PUSH
72600: LD_VAR 0 3
72604: PPUSH
72605: CALL_OW 312
72609: AND
72610: IFFALSE 72621
// ComUnlink ( j ) ;
72612: LD_VAR 0 3
72616: PPUSH
72617: CALL_OW 136
72621: GO 72545
72623: POP
72624: POP
// end ;
72625: GO 72483
72627: POP
72628: POP
// end ;
72629: LD_VAR 0 1
72633: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72634: LD_INT 0
72636: PPUSH
72637: PPUSH
72638: PPUSH
72639: PPUSH
72640: PPUSH
// if not mc_bases then
72641: LD_EXP 59
72645: NOT
72646: IFFALSE 72650
// exit ;
72648: GO 73095
// for i = 1 to mc_bases do
72650: LD_ADDR_VAR 0 2
72654: PUSH
72655: DOUBLE
72656: LD_INT 1
72658: DEC
72659: ST_TO_ADDR
72660: LD_EXP 59
72664: PUSH
72665: FOR_TO
72666: IFFALSE 73093
// begin if not mc_produce [ i ] then
72668: LD_EXP 80
72672: PUSH
72673: LD_VAR 0 2
72677: ARRAY
72678: NOT
72679: IFFALSE 72683
// continue ;
72681: GO 72665
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72683: LD_ADDR_VAR 0 5
72687: PUSH
72688: LD_EXP 59
72692: PUSH
72693: LD_VAR 0 2
72697: ARRAY
72698: PPUSH
72699: LD_INT 30
72701: PUSH
72702: LD_INT 3
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PPUSH
72709: CALL_OW 72
72713: ST_TO_ADDR
// if not fac then
72714: LD_VAR 0 5
72718: NOT
72719: IFFALSE 72723
// continue ;
72721: GO 72665
// for j in fac do
72723: LD_ADDR_VAR 0 3
72727: PUSH
72728: LD_VAR 0 5
72732: PUSH
72733: FOR_IN
72734: IFFALSE 73089
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72736: LD_VAR 0 3
72740: PPUSH
72741: CALL_OW 461
72745: PUSH
72746: LD_INT 2
72748: NONEQUAL
72749: PUSH
72750: LD_VAR 0 3
72754: PPUSH
72755: LD_INT 15
72757: PPUSH
72758: CALL 24242 0 2
72762: PUSH
72763: LD_INT 4
72765: ARRAY
72766: OR
72767: IFFALSE 72771
// continue ;
72769: GO 72733
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72771: LD_VAR 0 3
72775: PPUSH
72776: LD_EXP 80
72780: PUSH
72781: LD_VAR 0 2
72785: ARRAY
72786: PUSH
72787: LD_INT 1
72789: ARRAY
72790: PUSH
72791: LD_INT 1
72793: ARRAY
72794: PPUSH
72795: LD_EXP 80
72799: PUSH
72800: LD_VAR 0 2
72804: ARRAY
72805: PUSH
72806: LD_INT 1
72808: ARRAY
72809: PUSH
72810: LD_INT 2
72812: ARRAY
72813: PPUSH
72814: LD_EXP 80
72818: PUSH
72819: LD_VAR 0 2
72823: ARRAY
72824: PUSH
72825: LD_INT 1
72827: ARRAY
72828: PUSH
72829: LD_INT 3
72831: ARRAY
72832: PPUSH
72833: LD_EXP 80
72837: PUSH
72838: LD_VAR 0 2
72842: ARRAY
72843: PUSH
72844: LD_INT 1
72846: ARRAY
72847: PUSH
72848: LD_INT 4
72850: ARRAY
72851: PPUSH
72852: CALL_OW 448
72856: PUSH
72857: LD_VAR 0 3
72861: PPUSH
72862: LD_EXP 80
72866: PUSH
72867: LD_VAR 0 2
72871: ARRAY
72872: PUSH
72873: LD_INT 1
72875: ARRAY
72876: PUSH
72877: LD_INT 1
72879: ARRAY
72880: PUSH
72881: LD_EXP 80
72885: PUSH
72886: LD_VAR 0 2
72890: ARRAY
72891: PUSH
72892: LD_INT 1
72894: ARRAY
72895: PUSH
72896: LD_INT 2
72898: ARRAY
72899: PUSH
72900: LD_EXP 80
72904: PUSH
72905: LD_VAR 0 2
72909: ARRAY
72910: PUSH
72911: LD_INT 1
72913: ARRAY
72914: PUSH
72915: LD_INT 3
72917: ARRAY
72918: PUSH
72919: LD_EXP 80
72923: PUSH
72924: LD_VAR 0 2
72928: ARRAY
72929: PUSH
72930: LD_INT 1
72932: ARRAY
72933: PUSH
72934: LD_INT 4
72936: ARRAY
72937: PUSH
72938: EMPTY
72939: LIST
72940: LIST
72941: LIST
72942: LIST
72943: PPUSH
72944: CALL 27913 0 2
72948: AND
72949: IFFALSE 73087
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72951: LD_VAR 0 3
72955: PPUSH
72956: LD_EXP 80
72960: PUSH
72961: LD_VAR 0 2
72965: ARRAY
72966: PUSH
72967: LD_INT 1
72969: ARRAY
72970: PUSH
72971: LD_INT 1
72973: ARRAY
72974: PPUSH
72975: LD_EXP 80
72979: PUSH
72980: LD_VAR 0 2
72984: ARRAY
72985: PUSH
72986: LD_INT 1
72988: ARRAY
72989: PUSH
72990: LD_INT 2
72992: ARRAY
72993: PPUSH
72994: LD_EXP 80
72998: PUSH
72999: LD_VAR 0 2
73003: ARRAY
73004: PUSH
73005: LD_INT 1
73007: ARRAY
73008: PUSH
73009: LD_INT 3
73011: ARRAY
73012: PPUSH
73013: LD_EXP 80
73017: PUSH
73018: LD_VAR 0 2
73022: ARRAY
73023: PUSH
73024: LD_INT 1
73026: ARRAY
73027: PUSH
73028: LD_INT 4
73030: ARRAY
73031: PPUSH
73032: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
73036: LD_ADDR_VAR 0 4
73040: PUSH
73041: LD_EXP 80
73045: PUSH
73046: LD_VAR 0 2
73050: ARRAY
73051: PPUSH
73052: LD_INT 1
73054: PPUSH
73055: CALL_OW 3
73059: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
73060: LD_ADDR_EXP 80
73064: PUSH
73065: LD_EXP 80
73069: PPUSH
73070: LD_VAR 0 2
73074: PPUSH
73075: LD_VAR 0 4
73079: PPUSH
73080: CALL_OW 1
73084: ST_TO_ADDR
// break ;
73085: GO 73089
// end ; end ;
73087: GO 72733
73089: POP
73090: POP
// end ;
73091: GO 72665
73093: POP
73094: POP
// end ;
73095: LD_VAR 0 1
73099: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
73100: LD_INT 0
73102: PPUSH
73103: PPUSH
73104: PPUSH
// if not mc_bases then
73105: LD_EXP 59
73109: NOT
73110: IFFALSE 73114
// exit ;
73112: GO 73203
// for i = 1 to mc_bases do
73114: LD_ADDR_VAR 0 2
73118: PUSH
73119: DOUBLE
73120: LD_INT 1
73122: DEC
73123: ST_TO_ADDR
73124: LD_EXP 59
73128: PUSH
73129: FOR_TO
73130: IFFALSE 73201
// begin if mc_attack [ i ] then
73132: LD_EXP 79
73136: PUSH
73137: LD_VAR 0 2
73141: ARRAY
73142: IFFALSE 73199
// begin tmp := mc_attack [ i ] [ 1 ] ;
73144: LD_ADDR_VAR 0 3
73148: PUSH
73149: LD_EXP 79
73153: PUSH
73154: LD_VAR 0 2
73158: ARRAY
73159: PUSH
73160: LD_INT 1
73162: ARRAY
73163: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
73164: LD_ADDR_EXP 79
73168: PUSH
73169: LD_EXP 79
73173: PPUSH
73174: LD_VAR 0 2
73178: PPUSH
73179: EMPTY
73180: PPUSH
73181: CALL_OW 1
73185: ST_TO_ADDR
// Attack ( tmp ) ;
73186: LD_VAR 0 3
73190: PPUSH
73191: CALL 50103 0 1
// exit ;
73195: POP
73196: POP
73197: GO 73203
// end ; end ;
73199: GO 73129
73201: POP
73202: POP
// end ;
73203: LD_VAR 0 1
73207: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
73208: LD_INT 0
73210: PPUSH
73211: PPUSH
73212: PPUSH
73213: PPUSH
73214: PPUSH
73215: PPUSH
73216: PPUSH
// if not mc_bases then
73217: LD_EXP 59
73221: NOT
73222: IFFALSE 73226
// exit ;
73224: GO 73808
// for i = 1 to mc_bases do
73226: LD_ADDR_VAR 0 2
73230: PUSH
73231: DOUBLE
73232: LD_INT 1
73234: DEC
73235: ST_TO_ADDR
73236: LD_EXP 59
73240: PUSH
73241: FOR_TO
73242: IFFALSE 73806
// begin if not mc_bases [ i ] then
73244: LD_EXP 59
73248: PUSH
73249: LD_VAR 0 2
73253: ARRAY
73254: NOT
73255: IFFALSE 73259
// continue ;
73257: GO 73241
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
73259: LD_ADDR_VAR 0 7
73263: PUSH
73264: LD_EXP 59
73268: PUSH
73269: LD_VAR 0 2
73273: ARRAY
73274: PUSH
73275: LD_INT 1
73277: ARRAY
73278: PPUSH
73279: CALL 18485 0 1
73283: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
73284: LD_ADDR_EXP 82
73288: PUSH
73289: LD_EXP 82
73293: PPUSH
73294: LD_VAR 0 2
73298: PPUSH
73299: LD_EXP 59
73303: PUSH
73304: LD_VAR 0 2
73308: ARRAY
73309: PUSH
73310: LD_INT 1
73312: ARRAY
73313: PPUSH
73314: CALL_OW 255
73318: PPUSH
73319: LD_EXP 84
73323: PUSH
73324: LD_VAR 0 2
73328: ARRAY
73329: PPUSH
73330: CALL 16039 0 2
73334: PPUSH
73335: CALL_OW 1
73339: ST_TO_ADDR
// if not mc_scan [ i ] then
73340: LD_EXP 82
73344: PUSH
73345: LD_VAR 0 2
73349: ARRAY
73350: NOT
73351: IFFALSE 73506
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73353: LD_ADDR_VAR 0 4
73357: PUSH
73358: LD_EXP 59
73362: PUSH
73363: LD_VAR 0 2
73367: ARRAY
73368: PPUSH
73369: LD_INT 2
73371: PUSH
73372: LD_INT 25
73374: PUSH
73375: LD_INT 5
73377: PUSH
73378: EMPTY
73379: LIST
73380: LIST
73381: PUSH
73382: LD_INT 25
73384: PUSH
73385: LD_INT 8
73387: PUSH
73388: EMPTY
73389: LIST
73390: LIST
73391: PUSH
73392: LD_INT 25
73394: PUSH
73395: LD_INT 9
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: LIST
73406: LIST
73407: PPUSH
73408: CALL_OW 72
73412: ST_TO_ADDR
// if not tmp then
73413: LD_VAR 0 4
73417: NOT
73418: IFFALSE 73422
// continue ;
73420: GO 73241
// for j in tmp do
73422: LD_ADDR_VAR 0 3
73426: PUSH
73427: LD_VAR 0 4
73431: PUSH
73432: FOR_IN
73433: IFFALSE 73504
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73435: LD_VAR 0 3
73439: PPUSH
73440: CALL_OW 310
73444: PPUSH
73445: CALL_OW 266
73449: PUSH
73450: LD_INT 5
73452: EQUAL
73453: PUSH
73454: LD_VAR 0 3
73458: PPUSH
73459: CALL_OW 257
73463: PUSH
73464: LD_INT 1
73466: EQUAL
73467: AND
73468: PUSH
73469: LD_VAR 0 3
73473: PPUSH
73474: CALL_OW 459
73478: NOT
73479: AND
73480: PUSH
73481: LD_VAR 0 7
73485: AND
73486: IFFALSE 73502
// ComChangeProfession ( j , class ) ;
73488: LD_VAR 0 3
73492: PPUSH
73493: LD_VAR 0 7
73497: PPUSH
73498: CALL_OW 123
73502: GO 73432
73504: POP
73505: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73506: LD_EXP 82
73510: PUSH
73511: LD_VAR 0 2
73515: ARRAY
73516: PUSH
73517: LD_EXP 81
73521: PUSH
73522: LD_VAR 0 2
73526: ARRAY
73527: NOT
73528: AND
73529: PUSH
73530: LD_EXP 59
73534: PUSH
73535: LD_VAR 0 2
73539: ARRAY
73540: PPUSH
73541: LD_INT 30
73543: PUSH
73544: LD_INT 32
73546: PUSH
73547: EMPTY
73548: LIST
73549: LIST
73550: PPUSH
73551: CALL_OW 72
73555: NOT
73556: AND
73557: PUSH
73558: LD_EXP 59
73562: PUSH
73563: LD_VAR 0 2
73567: ARRAY
73568: PPUSH
73569: LD_INT 2
73571: PUSH
73572: LD_INT 30
73574: PUSH
73575: LD_INT 4
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 30
73584: PUSH
73585: LD_INT 5
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: LIST
73596: PPUSH
73597: CALL_OW 72
73601: NOT
73602: AND
73603: IFFALSE 73735
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73605: LD_ADDR_VAR 0 4
73609: PUSH
73610: LD_EXP 59
73614: PUSH
73615: LD_VAR 0 2
73619: ARRAY
73620: PPUSH
73621: LD_INT 2
73623: PUSH
73624: LD_INT 25
73626: PUSH
73627: LD_INT 1
73629: PUSH
73630: EMPTY
73631: LIST
73632: LIST
73633: PUSH
73634: LD_INT 25
73636: PUSH
73637: LD_INT 5
73639: PUSH
73640: EMPTY
73641: LIST
73642: LIST
73643: PUSH
73644: LD_INT 25
73646: PUSH
73647: LD_INT 8
73649: PUSH
73650: EMPTY
73651: LIST
73652: LIST
73653: PUSH
73654: LD_INT 25
73656: PUSH
73657: LD_INT 9
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: PUSH
73664: EMPTY
73665: LIST
73666: LIST
73667: LIST
73668: LIST
73669: LIST
73670: PPUSH
73671: CALL_OW 72
73675: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73676: LD_ADDR_VAR 0 4
73680: PUSH
73681: LD_VAR 0 4
73685: PUSH
73686: LD_VAR 0 4
73690: PPUSH
73691: LD_INT 18
73693: PPUSH
73694: CALL 54919 0 2
73698: DIFF
73699: ST_TO_ADDR
// if tmp then
73700: LD_VAR 0 4
73704: IFFALSE 73735
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
73706: LD_VAR 0 2
73710: PPUSH
73711: LD_VAR 0 4
73715: PPUSH
73716: LD_EXP 84
73720: PUSH
73721: LD_VAR 0 2
73725: ARRAY
73726: PPUSH
73727: CALL 16074 0 3
// exit ;
73731: POP
73732: POP
73733: GO 73808
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73735: LD_EXP 82
73739: PUSH
73740: LD_VAR 0 2
73744: ARRAY
73745: PUSH
73746: LD_EXP 81
73750: PUSH
73751: LD_VAR 0 2
73755: ARRAY
73756: AND
73757: IFFALSE 73804
// begin tmp := mc_defender [ i ] ;
73759: LD_ADDR_VAR 0 4
73763: PUSH
73764: LD_EXP 81
73768: PUSH
73769: LD_VAR 0 2
73773: ARRAY
73774: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73775: LD_VAR 0 2
73779: PPUSH
73780: LD_VAR 0 4
73784: PPUSH
73785: LD_EXP 82
73789: PUSH
73790: LD_VAR 0 2
73794: ARRAY
73795: PPUSH
73796: CALL 16635 0 3
// exit ;
73800: POP
73801: POP
73802: GO 73808
// end ; end ;
73804: GO 73241
73806: POP
73807: POP
// end ;
73808: LD_VAR 0 1
73812: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73813: LD_INT 0
73815: PPUSH
73816: PPUSH
73817: PPUSH
73818: PPUSH
73819: PPUSH
73820: PPUSH
73821: PPUSH
73822: PPUSH
73823: PPUSH
73824: PPUSH
73825: PPUSH
// if not mc_bases then
73826: LD_EXP 59
73830: NOT
73831: IFFALSE 73835
// exit ;
73833: GO 74922
// for i = 1 to mc_bases do
73835: LD_ADDR_VAR 0 2
73839: PUSH
73840: DOUBLE
73841: LD_INT 1
73843: DEC
73844: ST_TO_ADDR
73845: LD_EXP 59
73849: PUSH
73850: FOR_TO
73851: IFFALSE 74920
// begin tmp := mc_lab [ i ] ;
73853: LD_ADDR_VAR 0 6
73857: PUSH
73858: LD_EXP 92
73862: PUSH
73863: LD_VAR 0 2
73867: ARRAY
73868: ST_TO_ADDR
// if not tmp then
73869: LD_VAR 0 6
73873: NOT
73874: IFFALSE 73878
// continue ;
73876: GO 73850
// idle_lab := 0 ;
73878: LD_ADDR_VAR 0 11
73882: PUSH
73883: LD_INT 0
73885: ST_TO_ADDR
// for j in tmp do
73886: LD_ADDR_VAR 0 3
73890: PUSH
73891: LD_VAR 0 6
73895: PUSH
73896: FOR_IN
73897: IFFALSE 74916
// begin researching := false ;
73899: LD_ADDR_VAR 0 10
73903: PUSH
73904: LD_INT 0
73906: ST_TO_ADDR
// side := GetSide ( j ) ;
73907: LD_ADDR_VAR 0 4
73911: PUSH
73912: LD_VAR 0 3
73916: PPUSH
73917: CALL_OW 255
73921: ST_TO_ADDR
// if not mc_tech [ side ] then
73922: LD_EXP 86
73926: PUSH
73927: LD_VAR 0 4
73931: ARRAY
73932: NOT
73933: IFFALSE 73937
// continue ;
73935: GO 73896
// if BuildingStatus ( j ) = bs_idle then
73937: LD_VAR 0 3
73941: PPUSH
73942: CALL_OW 461
73946: PUSH
73947: LD_INT 2
73949: EQUAL
73950: IFFALSE 74138
// begin if idle_lab and UnitsInside ( j ) < 6 then
73952: LD_VAR 0 11
73956: PUSH
73957: LD_VAR 0 3
73961: PPUSH
73962: CALL_OW 313
73966: PUSH
73967: LD_INT 6
73969: LESS
73970: AND
73971: IFFALSE 74042
// begin tmp2 := UnitsInside ( idle_lab ) ;
73973: LD_ADDR_VAR 0 9
73977: PUSH
73978: LD_VAR 0 11
73982: PPUSH
73983: CALL_OW 313
73987: ST_TO_ADDR
// if tmp2 then
73988: LD_VAR 0 9
73992: IFFALSE 74034
// for x in tmp2 do
73994: LD_ADDR_VAR 0 7
73998: PUSH
73999: LD_VAR 0 9
74003: PUSH
74004: FOR_IN
74005: IFFALSE 74032
// begin ComExitBuilding ( x ) ;
74007: LD_VAR 0 7
74011: PPUSH
74012: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74016: LD_VAR 0 7
74020: PPUSH
74021: LD_VAR 0 3
74025: PPUSH
74026: CALL_OW 180
// end ;
74030: GO 74004
74032: POP
74033: POP
// idle_lab := 0 ;
74034: LD_ADDR_VAR 0 11
74038: PUSH
74039: LD_INT 0
74041: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
74042: LD_ADDR_VAR 0 5
74046: PUSH
74047: LD_EXP 86
74051: PUSH
74052: LD_VAR 0 4
74056: ARRAY
74057: PUSH
74058: FOR_IN
74059: IFFALSE 74119
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
74061: LD_VAR 0 3
74065: PPUSH
74066: LD_VAR 0 5
74070: PPUSH
74071: CALL_OW 430
74075: PUSH
74076: LD_VAR 0 4
74080: PPUSH
74081: LD_VAR 0 5
74085: PPUSH
74086: CALL 15144 0 2
74090: AND
74091: IFFALSE 74117
// begin researching := true ;
74093: LD_ADDR_VAR 0 10
74097: PUSH
74098: LD_INT 1
74100: ST_TO_ADDR
// ComResearch ( j , t ) ;
74101: LD_VAR 0 3
74105: PPUSH
74106: LD_VAR 0 5
74110: PPUSH
74111: CALL_OW 124
// break ;
74115: GO 74119
// end ;
74117: GO 74058
74119: POP
74120: POP
// if not researching then
74121: LD_VAR 0 10
74125: NOT
74126: IFFALSE 74138
// idle_lab := j ;
74128: LD_ADDR_VAR 0 11
74132: PUSH
74133: LD_VAR 0 3
74137: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
74138: LD_VAR 0 3
74142: PPUSH
74143: CALL_OW 461
74147: PUSH
74148: LD_INT 10
74150: EQUAL
74151: IFFALSE 74739
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
74153: LD_EXP 88
74157: PUSH
74158: LD_VAR 0 2
74162: ARRAY
74163: NOT
74164: PUSH
74165: LD_EXP 89
74169: PUSH
74170: LD_VAR 0 2
74174: ARRAY
74175: NOT
74176: AND
74177: PUSH
74178: LD_EXP 86
74182: PUSH
74183: LD_VAR 0 4
74187: ARRAY
74188: PUSH
74189: LD_INT 1
74191: GREATER
74192: AND
74193: IFFALSE 74324
// begin ComCancel ( j ) ;
74195: LD_VAR 0 3
74199: PPUSH
74200: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
74204: LD_ADDR_EXP 86
74208: PUSH
74209: LD_EXP 86
74213: PPUSH
74214: LD_VAR 0 4
74218: PPUSH
74219: LD_EXP 86
74223: PUSH
74224: LD_VAR 0 4
74228: ARRAY
74229: PPUSH
74230: LD_EXP 86
74234: PUSH
74235: LD_VAR 0 4
74239: ARRAY
74240: PUSH
74241: LD_INT 1
74243: MINUS
74244: PPUSH
74245: LD_EXP 86
74249: PUSH
74250: LD_VAR 0 4
74254: ARRAY
74255: PPUSH
74256: LD_INT 0
74258: PPUSH
74259: CALL 21067 0 4
74263: PPUSH
74264: CALL_OW 1
74268: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
74269: LD_ADDR_EXP 86
74273: PUSH
74274: LD_EXP 86
74278: PPUSH
74279: LD_VAR 0 4
74283: PPUSH
74284: LD_EXP 86
74288: PUSH
74289: LD_VAR 0 4
74293: ARRAY
74294: PPUSH
74295: LD_EXP 86
74299: PUSH
74300: LD_VAR 0 4
74304: ARRAY
74305: PPUSH
74306: LD_INT 1
74308: PPUSH
74309: LD_INT 0
74311: PPUSH
74312: CALL 21067 0 4
74316: PPUSH
74317: CALL_OW 1
74321: ST_TO_ADDR
// continue ;
74322: GO 73896
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74324: LD_EXP 88
74328: PUSH
74329: LD_VAR 0 2
74333: ARRAY
74334: PUSH
74335: LD_EXP 89
74339: PUSH
74340: LD_VAR 0 2
74344: ARRAY
74345: NOT
74346: AND
74347: IFFALSE 74474
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74349: LD_ADDR_EXP 89
74353: PUSH
74354: LD_EXP 89
74358: PPUSH
74359: LD_VAR 0 2
74363: PUSH
74364: LD_EXP 89
74368: PUSH
74369: LD_VAR 0 2
74373: ARRAY
74374: PUSH
74375: LD_INT 1
74377: PLUS
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PPUSH
74383: LD_EXP 88
74387: PUSH
74388: LD_VAR 0 2
74392: ARRAY
74393: PUSH
74394: LD_INT 1
74396: ARRAY
74397: PPUSH
74398: CALL 21649 0 3
74402: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74403: LD_EXP 88
74407: PUSH
74408: LD_VAR 0 2
74412: ARRAY
74413: PUSH
74414: LD_INT 1
74416: ARRAY
74417: PPUSH
74418: LD_INT 112
74420: PPUSH
74421: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74425: LD_ADDR_VAR 0 9
74429: PUSH
74430: LD_EXP 88
74434: PUSH
74435: LD_VAR 0 2
74439: ARRAY
74440: PPUSH
74441: LD_INT 1
74443: PPUSH
74444: CALL_OW 3
74448: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74449: LD_ADDR_EXP 88
74453: PUSH
74454: LD_EXP 88
74458: PPUSH
74459: LD_VAR 0 2
74463: PPUSH
74464: LD_VAR 0 9
74468: PPUSH
74469: CALL_OW 1
74473: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74474: LD_EXP 88
74478: PUSH
74479: LD_VAR 0 2
74483: ARRAY
74484: PUSH
74485: LD_EXP 89
74489: PUSH
74490: LD_VAR 0 2
74494: ARRAY
74495: AND
74496: PUSH
74497: LD_EXP 89
74501: PUSH
74502: LD_VAR 0 2
74506: ARRAY
74507: PUSH
74508: LD_INT 1
74510: ARRAY
74511: PPUSH
74512: CALL_OW 310
74516: NOT
74517: AND
74518: PUSH
74519: LD_VAR 0 3
74523: PPUSH
74524: CALL_OW 313
74528: PUSH
74529: LD_INT 6
74531: EQUAL
74532: AND
74533: IFFALSE 74589
// begin tmp2 := UnitsInside ( j ) ;
74535: LD_ADDR_VAR 0 9
74539: PUSH
74540: LD_VAR 0 3
74544: PPUSH
74545: CALL_OW 313
74549: ST_TO_ADDR
// if tmp2 = 6 then
74550: LD_VAR 0 9
74554: PUSH
74555: LD_INT 6
74557: EQUAL
74558: IFFALSE 74589
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74560: LD_VAR 0 9
74564: PUSH
74565: LD_INT 1
74567: ARRAY
74568: PPUSH
74569: LD_INT 112
74571: PPUSH
74572: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74576: LD_VAR 0 9
74580: PUSH
74581: LD_INT 1
74583: ARRAY
74584: PPUSH
74585: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74589: LD_EXP 89
74593: PUSH
74594: LD_VAR 0 2
74598: ARRAY
74599: PUSH
74600: LD_EXP 89
74604: PUSH
74605: LD_VAR 0 2
74609: ARRAY
74610: PUSH
74611: LD_INT 1
74613: ARRAY
74614: PPUSH
74615: CALL_OW 314
74619: NOT
74620: AND
74621: PUSH
74622: LD_EXP 89
74626: PUSH
74627: LD_VAR 0 2
74631: ARRAY
74632: PUSH
74633: LD_INT 1
74635: ARRAY
74636: PPUSH
74637: CALL_OW 310
74641: NOT
74642: AND
74643: IFFALSE 74669
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74645: LD_EXP 89
74649: PUSH
74650: LD_VAR 0 2
74654: ARRAY
74655: PUSH
74656: LD_INT 1
74658: ARRAY
74659: PPUSH
74660: LD_VAR 0 3
74664: PPUSH
74665: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74669: LD_EXP 89
74673: PUSH
74674: LD_VAR 0 2
74678: ARRAY
74679: PUSH
74680: LD_INT 1
74682: ARRAY
74683: PPUSH
74684: CALL_OW 310
74688: PUSH
74689: LD_EXP 89
74693: PUSH
74694: LD_VAR 0 2
74698: ARRAY
74699: PUSH
74700: LD_INT 1
74702: ARRAY
74703: PPUSH
74704: CALL_OW 310
74708: PPUSH
74709: CALL_OW 461
74713: PUSH
74714: LD_INT 3
74716: NONEQUAL
74717: AND
74718: IFFALSE 74739
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74720: LD_EXP 89
74724: PUSH
74725: LD_VAR 0 2
74729: ARRAY
74730: PUSH
74731: LD_INT 1
74733: ARRAY
74734: PPUSH
74735: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74739: LD_VAR 0 3
74743: PPUSH
74744: CALL_OW 461
74748: PUSH
74749: LD_INT 6
74751: EQUAL
74752: PUSH
74753: LD_VAR 0 6
74757: PUSH
74758: LD_INT 1
74760: GREATER
74761: AND
74762: IFFALSE 74914
// begin sci := [ ] ;
74764: LD_ADDR_VAR 0 8
74768: PUSH
74769: EMPTY
74770: ST_TO_ADDR
// for x in ( tmp diff j ) do
74771: LD_ADDR_VAR 0 7
74775: PUSH
74776: LD_VAR 0 6
74780: PUSH
74781: LD_VAR 0 3
74785: DIFF
74786: PUSH
74787: FOR_IN
74788: IFFALSE 74840
// begin if sci = 6 then
74790: LD_VAR 0 8
74794: PUSH
74795: LD_INT 6
74797: EQUAL
74798: IFFALSE 74802
// break ;
74800: GO 74840
// if BuildingStatus ( x ) = bs_idle then
74802: LD_VAR 0 7
74806: PPUSH
74807: CALL_OW 461
74811: PUSH
74812: LD_INT 2
74814: EQUAL
74815: IFFALSE 74838
// sci := sci ^ UnitsInside ( x ) ;
74817: LD_ADDR_VAR 0 8
74821: PUSH
74822: LD_VAR 0 8
74826: PUSH
74827: LD_VAR 0 7
74831: PPUSH
74832: CALL_OW 313
74836: ADD
74837: ST_TO_ADDR
// end ;
74838: GO 74787
74840: POP
74841: POP
// if not sci then
74842: LD_VAR 0 8
74846: NOT
74847: IFFALSE 74851
// continue ;
74849: GO 73896
// for x in sci do
74851: LD_ADDR_VAR 0 7
74855: PUSH
74856: LD_VAR 0 8
74860: PUSH
74861: FOR_IN
74862: IFFALSE 74912
// if IsInUnit ( x ) and not HasTask ( x ) then
74864: LD_VAR 0 7
74868: PPUSH
74869: CALL_OW 310
74873: PUSH
74874: LD_VAR 0 7
74878: PPUSH
74879: CALL_OW 314
74883: NOT
74884: AND
74885: IFFALSE 74910
// begin ComExitBuilding ( x ) ;
74887: LD_VAR 0 7
74891: PPUSH
74892: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74896: LD_VAR 0 7
74900: PPUSH
74901: LD_VAR 0 3
74905: PPUSH
74906: CALL_OW 180
// end ;
74910: GO 74861
74912: POP
74913: POP
// end ; end ;
74914: GO 73896
74916: POP
74917: POP
// end ;
74918: GO 73850
74920: POP
74921: POP
// end ;
74922: LD_VAR 0 1
74926: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74927: LD_INT 0
74929: PPUSH
74930: PPUSH
// if not mc_bases then
74931: LD_EXP 59
74935: NOT
74936: IFFALSE 74940
// exit ;
74938: GO 75021
// for i = 1 to mc_bases do
74940: LD_ADDR_VAR 0 2
74944: PUSH
74945: DOUBLE
74946: LD_INT 1
74948: DEC
74949: ST_TO_ADDR
74950: LD_EXP 59
74954: PUSH
74955: FOR_TO
74956: IFFALSE 75019
// if mc_mines [ i ] and mc_miners [ i ] then
74958: LD_EXP 72
74962: PUSH
74963: LD_VAR 0 2
74967: ARRAY
74968: PUSH
74969: LD_EXP 73
74973: PUSH
74974: LD_VAR 0 2
74978: ARRAY
74979: AND
74980: IFFALSE 75017
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74982: LD_EXP 73
74986: PUSH
74987: LD_VAR 0 2
74991: ARRAY
74992: PUSH
74993: LD_INT 1
74995: ARRAY
74996: PPUSH
74997: CALL_OW 255
75001: PPUSH
75002: LD_EXP 72
75006: PUSH
75007: LD_VAR 0 2
75011: ARRAY
75012: PPUSH
75013: CALL 18638 0 2
75017: GO 74955
75019: POP
75020: POP
// end ;
75021: LD_VAR 0 1
75025: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
75026: LD_INT 0
75028: PPUSH
75029: PPUSH
75030: PPUSH
75031: PPUSH
75032: PPUSH
75033: PPUSH
75034: PPUSH
75035: PPUSH
// if not mc_bases or not mc_parking then
75036: LD_EXP 59
75040: NOT
75041: PUSH
75042: LD_EXP 83
75046: NOT
75047: OR
75048: IFFALSE 75052
// exit ;
75050: GO 75751
// for i = 1 to mc_bases do
75052: LD_ADDR_VAR 0 2
75056: PUSH
75057: DOUBLE
75058: LD_INT 1
75060: DEC
75061: ST_TO_ADDR
75062: LD_EXP 59
75066: PUSH
75067: FOR_TO
75068: IFFALSE 75749
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
75070: LD_EXP 59
75074: PUSH
75075: LD_VAR 0 2
75079: ARRAY
75080: NOT
75081: PUSH
75082: LD_EXP 83
75086: PUSH
75087: LD_VAR 0 2
75091: ARRAY
75092: NOT
75093: OR
75094: IFFALSE 75098
// continue ;
75096: GO 75067
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
75098: LD_ADDR_VAR 0 5
75102: PUSH
75103: LD_EXP 59
75107: PUSH
75108: LD_VAR 0 2
75112: ARRAY
75113: PUSH
75114: LD_INT 1
75116: ARRAY
75117: PPUSH
75118: CALL_OW 255
75122: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75123: LD_ADDR_VAR 0 6
75127: PUSH
75128: LD_EXP 59
75132: PUSH
75133: LD_VAR 0 2
75137: ARRAY
75138: PPUSH
75139: LD_INT 30
75141: PUSH
75142: LD_INT 3
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PPUSH
75149: CALL_OW 72
75153: ST_TO_ADDR
// if not fac then
75154: LD_VAR 0 6
75158: NOT
75159: IFFALSE 75210
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75161: LD_ADDR_VAR 0 6
75165: PUSH
75166: LD_EXP 59
75170: PUSH
75171: LD_VAR 0 2
75175: ARRAY
75176: PPUSH
75177: LD_INT 2
75179: PUSH
75180: LD_INT 30
75182: PUSH
75183: LD_INT 0
75185: PUSH
75186: EMPTY
75187: LIST
75188: LIST
75189: PUSH
75190: LD_INT 30
75192: PUSH
75193: LD_INT 1
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: LIST
75204: PPUSH
75205: CALL_OW 72
75209: ST_TO_ADDR
// if not fac then
75210: LD_VAR 0 6
75214: NOT
75215: IFFALSE 75219
// continue ;
75217: GO 75067
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75219: LD_ADDR_VAR 0 7
75223: PUSH
75224: LD_EXP 83
75228: PUSH
75229: LD_VAR 0 2
75233: ARRAY
75234: PPUSH
75235: LD_INT 22
75237: PUSH
75238: LD_VAR 0 5
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PUSH
75247: LD_INT 21
75249: PUSH
75250: LD_INT 2
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: PUSH
75257: LD_INT 3
75259: PUSH
75260: LD_INT 24
75262: PUSH
75263: LD_INT 1000
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: LIST
75278: PPUSH
75279: CALL_OW 70
75283: ST_TO_ADDR
// for j in fac do
75284: LD_ADDR_VAR 0 3
75288: PUSH
75289: LD_VAR 0 6
75293: PUSH
75294: FOR_IN
75295: IFFALSE 75376
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75297: LD_ADDR_VAR 0 7
75301: PUSH
75302: LD_VAR 0 7
75306: PUSH
75307: LD_INT 22
75309: PUSH
75310: LD_VAR 0 5
75314: PUSH
75315: EMPTY
75316: LIST
75317: LIST
75318: PUSH
75319: LD_INT 91
75321: PUSH
75322: LD_VAR 0 3
75326: PUSH
75327: LD_INT 15
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 21
75337: PUSH
75338: LD_INT 2
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 3
75347: PUSH
75348: LD_INT 24
75350: PUSH
75351: LD_INT 1000
75353: PUSH
75354: EMPTY
75355: LIST
75356: LIST
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: PUSH
75362: EMPTY
75363: LIST
75364: LIST
75365: LIST
75366: LIST
75367: PPUSH
75368: CALL_OW 69
75372: UNION
75373: ST_TO_ADDR
75374: GO 75294
75376: POP
75377: POP
// if not vehs then
75378: LD_VAR 0 7
75382: NOT
75383: IFFALSE 75409
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75385: LD_ADDR_EXP 71
75389: PUSH
75390: LD_EXP 71
75394: PPUSH
75395: LD_VAR 0 2
75399: PPUSH
75400: EMPTY
75401: PPUSH
75402: CALL_OW 1
75406: ST_TO_ADDR
// continue ;
75407: GO 75067
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75409: LD_ADDR_VAR 0 8
75413: PUSH
75414: LD_EXP 59
75418: PUSH
75419: LD_VAR 0 2
75423: ARRAY
75424: PPUSH
75425: LD_INT 30
75427: PUSH
75428: LD_INT 3
75430: PUSH
75431: EMPTY
75432: LIST
75433: LIST
75434: PPUSH
75435: CALL_OW 72
75439: ST_TO_ADDR
// if tmp then
75440: LD_VAR 0 8
75444: IFFALSE 75547
// begin for j in tmp do
75446: LD_ADDR_VAR 0 3
75450: PUSH
75451: LD_VAR 0 8
75455: PUSH
75456: FOR_IN
75457: IFFALSE 75545
// for k in UnitsInside ( j ) do
75459: LD_ADDR_VAR 0 4
75463: PUSH
75464: LD_VAR 0 3
75468: PPUSH
75469: CALL_OW 313
75473: PUSH
75474: FOR_IN
75475: IFFALSE 75541
// if k then
75477: LD_VAR 0 4
75481: IFFALSE 75539
// if not k in mc_repair_vehicle [ i ] then
75483: LD_VAR 0 4
75487: PUSH
75488: LD_EXP 71
75492: PUSH
75493: LD_VAR 0 2
75497: ARRAY
75498: IN
75499: NOT
75500: IFFALSE 75539
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75502: LD_ADDR_EXP 71
75506: PUSH
75507: LD_EXP 71
75511: PPUSH
75512: LD_VAR 0 2
75516: PPUSH
75517: LD_EXP 71
75521: PUSH
75522: LD_VAR 0 2
75526: ARRAY
75527: PUSH
75528: LD_VAR 0 4
75532: UNION
75533: PPUSH
75534: CALL_OW 1
75538: ST_TO_ADDR
75539: GO 75474
75541: POP
75542: POP
75543: GO 75456
75545: POP
75546: POP
// end ; if not mc_repair_vehicle [ i ] then
75547: LD_EXP 71
75551: PUSH
75552: LD_VAR 0 2
75556: ARRAY
75557: NOT
75558: IFFALSE 75562
// continue ;
75560: GO 75067
// for j in mc_repair_vehicle [ i ] do
75562: LD_ADDR_VAR 0 3
75566: PUSH
75567: LD_EXP 71
75571: PUSH
75572: LD_VAR 0 2
75576: ARRAY
75577: PUSH
75578: FOR_IN
75579: IFFALSE 75745
// begin if GetClass ( j ) <> 3 then
75581: LD_VAR 0 3
75585: PPUSH
75586: CALL_OW 257
75590: PUSH
75591: LD_INT 3
75593: NONEQUAL
75594: IFFALSE 75635
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75596: LD_ADDR_EXP 71
75600: PUSH
75601: LD_EXP 71
75605: PPUSH
75606: LD_VAR 0 2
75610: PPUSH
75611: LD_EXP 71
75615: PUSH
75616: LD_VAR 0 2
75620: ARRAY
75621: PUSH
75622: LD_VAR 0 3
75626: DIFF
75627: PPUSH
75628: CALL_OW 1
75632: ST_TO_ADDR
// continue ;
75633: GO 75578
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75635: LD_VAR 0 3
75639: PPUSH
75640: CALL_OW 311
75644: NOT
75645: PUSH
75646: LD_VAR 0 3
75650: PUSH
75651: LD_EXP 62
75655: PUSH
75656: LD_VAR 0 2
75660: ARRAY
75661: PUSH
75662: LD_INT 1
75664: ARRAY
75665: IN
75666: NOT
75667: AND
75668: PUSH
75669: LD_VAR 0 3
75673: PUSH
75674: LD_EXP 62
75678: PUSH
75679: LD_VAR 0 2
75683: ARRAY
75684: PUSH
75685: LD_INT 2
75687: ARRAY
75688: IN
75689: NOT
75690: AND
75691: IFFALSE 75743
// begin if IsInUnit ( j ) then
75693: LD_VAR 0 3
75697: PPUSH
75698: CALL_OW 310
75702: IFFALSE 75713
// ComExitBuilding ( j ) ;
75704: LD_VAR 0 3
75708: PPUSH
75709: CALL_OW 122
// if not HasTask ( j ) then
75713: LD_VAR 0 3
75717: PPUSH
75718: CALL_OW 314
75722: NOT
75723: IFFALSE 75743
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75725: LD_VAR 0 3
75729: PPUSH
75730: LD_VAR 0 7
75734: PUSH
75735: LD_INT 1
75737: ARRAY
75738: PPUSH
75739: CALL_OW 189
// end ; end ;
75743: GO 75578
75745: POP
75746: POP
// end ;
75747: GO 75067
75749: POP
75750: POP
// end ;
75751: LD_VAR 0 1
75755: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75756: LD_INT 0
75758: PPUSH
75759: PPUSH
75760: PPUSH
75761: PPUSH
75762: PPUSH
75763: PPUSH
75764: PPUSH
75765: PPUSH
75766: PPUSH
75767: PPUSH
75768: PPUSH
// if not mc_bases then
75769: LD_EXP 59
75773: NOT
75774: IFFALSE 75778
// exit ;
75776: GO 76580
// for i = 1 to mc_bases do
75778: LD_ADDR_VAR 0 2
75782: PUSH
75783: DOUBLE
75784: LD_INT 1
75786: DEC
75787: ST_TO_ADDR
75788: LD_EXP 59
75792: PUSH
75793: FOR_TO
75794: IFFALSE 76578
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75796: LD_EXP 87
75800: PUSH
75801: LD_VAR 0 2
75805: ARRAY
75806: NOT
75807: PUSH
75808: LD_EXP 62
75812: PUSH
75813: LD_VAR 0 2
75817: ARRAY
75818: PUSH
75819: LD_INT 1
75821: ARRAY
75822: OR
75823: PUSH
75824: LD_EXP 62
75828: PUSH
75829: LD_VAR 0 2
75833: ARRAY
75834: PUSH
75835: LD_INT 2
75837: ARRAY
75838: OR
75839: PUSH
75840: LD_EXP 85
75844: PUSH
75845: LD_VAR 0 2
75849: ARRAY
75850: PPUSH
75851: LD_INT 1
75853: PPUSH
75854: CALL_OW 325
75858: NOT
75859: OR
75860: PUSH
75861: LD_EXP 82
75865: PUSH
75866: LD_VAR 0 2
75870: ARRAY
75871: OR
75872: IFFALSE 75876
// continue ;
75874: GO 75793
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75876: LD_ADDR_VAR 0 8
75880: PUSH
75881: LD_EXP 59
75885: PUSH
75886: LD_VAR 0 2
75890: ARRAY
75891: PPUSH
75892: LD_INT 25
75894: PUSH
75895: LD_INT 4
75897: PUSH
75898: EMPTY
75899: LIST
75900: LIST
75901: PUSH
75902: LD_INT 50
75904: PUSH
75905: EMPTY
75906: LIST
75907: PUSH
75908: LD_INT 3
75910: PUSH
75911: LD_INT 60
75913: PUSH
75914: EMPTY
75915: LIST
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: PUSH
75921: EMPTY
75922: LIST
75923: LIST
75924: LIST
75925: PPUSH
75926: CALL_OW 72
75930: PUSH
75931: LD_EXP 63
75935: PUSH
75936: LD_VAR 0 2
75940: ARRAY
75941: DIFF
75942: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75943: LD_ADDR_VAR 0 9
75947: PUSH
75948: LD_EXP 59
75952: PUSH
75953: LD_VAR 0 2
75957: ARRAY
75958: PPUSH
75959: LD_INT 2
75961: PUSH
75962: LD_INT 30
75964: PUSH
75965: LD_INT 0
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: LD_INT 30
75974: PUSH
75975: LD_INT 1
75977: PUSH
75978: EMPTY
75979: LIST
75980: LIST
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: LIST
75986: PPUSH
75987: CALL_OW 72
75991: ST_TO_ADDR
// if not tmp or not dep then
75992: LD_VAR 0 8
75996: NOT
75997: PUSH
75998: LD_VAR 0 9
76002: NOT
76003: OR
76004: IFFALSE 76008
// continue ;
76006: GO 75793
// side := GetSide ( tmp [ 1 ] ) ;
76008: LD_ADDR_VAR 0 11
76012: PUSH
76013: LD_VAR 0 8
76017: PUSH
76018: LD_INT 1
76020: ARRAY
76021: PPUSH
76022: CALL_OW 255
76026: ST_TO_ADDR
// dep := dep [ 1 ] ;
76027: LD_ADDR_VAR 0 9
76031: PUSH
76032: LD_VAR 0 9
76036: PUSH
76037: LD_INT 1
76039: ARRAY
76040: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
76041: LD_ADDR_VAR 0 7
76045: PUSH
76046: LD_EXP 87
76050: PUSH
76051: LD_VAR 0 2
76055: ARRAY
76056: PPUSH
76057: LD_INT 22
76059: PUSH
76060: LD_INT 0
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: PUSH
76067: LD_INT 25
76069: PUSH
76070: LD_INT 12
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: PUSH
76077: EMPTY
76078: LIST
76079: LIST
76080: PPUSH
76081: CALL_OW 70
76085: PUSH
76086: LD_INT 22
76088: PUSH
76089: LD_INT 0
76091: PUSH
76092: EMPTY
76093: LIST
76094: LIST
76095: PUSH
76096: LD_INT 25
76098: PUSH
76099: LD_INT 12
76101: PUSH
76102: EMPTY
76103: LIST
76104: LIST
76105: PUSH
76106: LD_INT 91
76108: PUSH
76109: LD_VAR 0 9
76113: PUSH
76114: LD_INT 20
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: LIST
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: LIST
76126: PPUSH
76127: CALL_OW 69
76131: UNION
76132: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
76133: LD_ADDR_VAR 0 10
76137: PUSH
76138: LD_EXP 87
76142: PUSH
76143: LD_VAR 0 2
76147: ARRAY
76148: PPUSH
76149: LD_INT 81
76151: PUSH
76152: LD_VAR 0 11
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PPUSH
76161: CALL_OW 70
76165: ST_TO_ADDR
// if not apes or danger_at_area then
76166: LD_VAR 0 7
76170: NOT
76171: PUSH
76172: LD_VAR 0 10
76176: OR
76177: IFFALSE 76227
// begin if mc_taming [ i ] then
76179: LD_EXP 90
76183: PUSH
76184: LD_VAR 0 2
76188: ARRAY
76189: IFFALSE 76225
// begin MC_Reset ( i , 121 ) ;
76191: LD_VAR 0 2
76195: PPUSH
76196: LD_INT 121
76198: PPUSH
76199: CALL 61662 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
76203: LD_ADDR_EXP 90
76207: PUSH
76208: LD_EXP 90
76212: PPUSH
76213: LD_VAR 0 2
76217: PPUSH
76218: EMPTY
76219: PPUSH
76220: CALL_OW 1
76224: ST_TO_ADDR
// end ; continue ;
76225: GO 75793
// end ; for j in tmp do
76227: LD_ADDR_VAR 0 3
76231: PUSH
76232: LD_VAR 0 8
76236: PUSH
76237: FOR_IN
76238: IFFALSE 76574
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
76240: LD_VAR 0 3
76244: PUSH
76245: LD_EXP 90
76249: PUSH
76250: LD_VAR 0 2
76254: ARRAY
76255: IN
76256: NOT
76257: PUSH
76258: LD_EXP 90
76262: PUSH
76263: LD_VAR 0 2
76267: ARRAY
76268: PUSH
76269: LD_INT 3
76271: LESS
76272: AND
76273: IFFALSE 76331
// begin SetTag ( j , 121 ) ;
76275: LD_VAR 0 3
76279: PPUSH
76280: LD_INT 121
76282: PPUSH
76283: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76287: LD_ADDR_EXP 90
76291: PUSH
76292: LD_EXP 90
76296: PPUSH
76297: LD_VAR 0 2
76301: PUSH
76302: LD_EXP 90
76306: PUSH
76307: LD_VAR 0 2
76311: ARRAY
76312: PUSH
76313: LD_INT 1
76315: PLUS
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PPUSH
76321: LD_VAR 0 3
76325: PPUSH
76326: CALL 21649 0 3
76330: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76331: LD_VAR 0 3
76335: PUSH
76336: LD_EXP 90
76340: PUSH
76341: LD_VAR 0 2
76345: ARRAY
76346: IN
76347: IFFALSE 76572
// begin if GetClass ( j ) <> 4 then
76349: LD_VAR 0 3
76353: PPUSH
76354: CALL_OW 257
76358: PUSH
76359: LD_INT 4
76361: NONEQUAL
76362: IFFALSE 76415
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76364: LD_ADDR_EXP 90
76368: PUSH
76369: LD_EXP 90
76373: PPUSH
76374: LD_VAR 0 2
76378: PPUSH
76379: LD_EXP 90
76383: PUSH
76384: LD_VAR 0 2
76388: ARRAY
76389: PUSH
76390: LD_VAR 0 3
76394: DIFF
76395: PPUSH
76396: CALL_OW 1
76400: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76401: LD_VAR 0 3
76405: PPUSH
76406: LD_INT 0
76408: PPUSH
76409: CALL_OW 109
// continue ;
76413: GO 76237
// end ; if IsInUnit ( j ) then
76415: LD_VAR 0 3
76419: PPUSH
76420: CALL_OW 310
76424: IFFALSE 76435
// ComExitBuilding ( j ) ;
76426: LD_VAR 0 3
76430: PPUSH
76431: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76435: LD_ADDR_VAR 0 6
76439: PUSH
76440: LD_VAR 0 7
76444: PPUSH
76445: LD_VAR 0 3
76449: PPUSH
76450: CALL_OW 74
76454: ST_TO_ADDR
// if not ape then
76455: LD_VAR 0 6
76459: NOT
76460: IFFALSE 76464
// break ;
76462: GO 76574
// x := GetX ( ape ) ;
76464: LD_ADDR_VAR 0 4
76468: PUSH
76469: LD_VAR 0 6
76473: PPUSH
76474: CALL_OW 250
76478: ST_TO_ADDR
// y := GetY ( ape ) ;
76479: LD_ADDR_VAR 0 5
76483: PUSH
76484: LD_VAR 0 6
76488: PPUSH
76489: CALL_OW 251
76493: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76494: LD_VAR 0 4
76498: PPUSH
76499: LD_VAR 0 5
76503: PPUSH
76504: CALL_OW 488
76508: NOT
76509: PUSH
76510: LD_VAR 0 11
76514: PPUSH
76515: LD_VAR 0 4
76519: PPUSH
76520: LD_VAR 0 5
76524: PPUSH
76525: LD_INT 20
76527: PPUSH
76528: CALL 22545 0 4
76532: PUSH
76533: LD_INT 4
76535: ARRAY
76536: OR
76537: IFFALSE 76541
// break ;
76539: GO 76574
// if not HasTask ( j ) then
76541: LD_VAR 0 3
76545: PPUSH
76546: CALL_OW 314
76550: NOT
76551: IFFALSE 76572
// ComTameXY ( j , x , y ) ;
76553: LD_VAR 0 3
76557: PPUSH
76558: LD_VAR 0 4
76562: PPUSH
76563: LD_VAR 0 5
76567: PPUSH
76568: CALL_OW 131
// end ; end ;
76572: GO 76237
76574: POP
76575: POP
// end ;
76576: GO 75793
76578: POP
76579: POP
// end ;
76580: LD_VAR 0 1
76584: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76585: LD_INT 0
76587: PPUSH
76588: PPUSH
76589: PPUSH
76590: PPUSH
76591: PPUSH
76592: PPUSH
76593: PPUSH
76594: PPUSH
// if not mc_bases then
76595: LD_EXP 59
76599: NOT
76600: IFFALSE 76604
// exit ;
76602: GO 77230
// for i = 1 to mc_bases do
76604: LD_ADDR_VAR 0 2
76608: PUSH
76609: DOUBLE
76610: LD_INT 1
76612: DEC
76613: ST_TO_ADDR
76614: LD_EXP 59
76618: PUSH
76619: FOR_TO
76620: IFFALSE 77228
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76622: LD_EXP 88
76626: PUSH
76627: LD_VAR 0 2
76631: ARRAY
76632: NOT
76633: PUSH
76634: LD_EXP 88
76638: PUSH
76639: LD_VAR 0 2
76643: ARRAY
76644: PPUSH
76645: LD_INT 25
76647: PUSH
76648: LD_INT 12
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PPUSH
76655: CALL_OW 72
76659: NOT
76660: OR
76661: IFFALSE 76665
// continue ;
76663: GO 76619
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76665: LD_ADDR_VAR 0 5
76669: PUSH
76670: LD_EXP 88
76674: PUSH
76675: LD_VAR 0 2
76679: ARRAY
76680: PUSH
76681: LD_INT 1
76683: ARRAY
76684: PPUSH
76685: CALL_OW 255
76689: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76690: LD_VAR 0 5
76694: PPUSH
76695: LD_INT 2
76697: PPUSH
76698: CALL_OW 325
76702: IFFALSE 76955
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76704: LD_ADDR_VAR 0 4
76708: PUSH
76709: LD_EXP 88
76713: PUSH
76714: LD_VAR 0 2
76718: ARRAY
76719: PPUSH
76720: LD_INT 25
76722: PUSH
76723: LD_INT 16
76725: PUSH
76726: EMPTY
76727: LIST
76728: LIST
76729: PPUSH
76730: CALL_OW 72
76734: ST_TO_ADDR
// if tmp < 6 then
76735: LD_VAR 0 4
76739: PUSH
76740: LD_INT 6
76742: LESS
76743: IFFALSE 76955
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76745: LD_ADDR_VAR 0 6
76749: PUSH
76750: LD_EXP 59
76754: PUSH
76755: LD_VAR 0 2
76759: ARRAY
76760: PPUSH
76761: LD_INT 2
76763: PUSH
76764: LD_INT 30
76766: PUSH
76767: LD_INT 0
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 30
76776: PUSH
76777: LD_INT 1
76779: PUSH
76780: EMPTY
76781: LIST
76782: LIST
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: LIST
76788: PPUSH
76789: CALL_OW 72
76793: ST_TO_ADDR
// if depot then
76794: LD_VAR 0 6
76798: IFFALSE 76955
// begin selected := 0 ;
76800: LD_ADDR_VAR 0 7
76804: PUSH
76805: LD_INT 0
76807: ST_TO_ADDR
// for j in depot do
76808: LD_ADDR_VAR 0 3
76812: PUSH
76813: LD_VAR 0 6
76817: PUSH
76818: FOR_IN
76819: IFFALSE 76850
// begin if UnitsInside ( j ) < 6 then
76821: LD_VAR 0 3
76825: PPUSH
76826: CALL_OW 313
76830: PUSH
76831: LD_INT 6
76833: LESS
76834: IFFALSE 76848
// begin selected := j ;
76836: LD_ADDR_VAR 0 7
76840: PUSH
76841: LD_VAR 0 3
76845: ST_TO_ADDR
// break ;
76846: GO 76850
// end ; end ;
76848: GO 76818
76850: POP
76851: POP
// if selected then
76852: LD_VAR 0 7
76856: IFFALSE 76955
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76858: LD_ADDR_VAR 0 3
76862: PUSH
76863: LD_EXP 88
76867: PUSH
76868: LD_VAR 0 2
76872: ARRAY
76873: PPUSH
76874: LD_INT 25
76876: PUSH
76877: LD_INT 12
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PPUSH
76884: CALL_OW 72
76888: PUSH
76889: FOR_IN
76890: IFFALSE 76953
// if not HasTask ( j ) then
76892: LD_VAR 0 3
76896: PPUSH
76897: CALL_OW 314
76901: NOT
76902: IFFALSE 76951
// begin if not IsInUnit ( j ) then
76904: LD_VAR 0 3
76908: PPUSH
76909: CALL_OW 310
76913: NOT
76914: IFFALSE 76930
// ComEnterUnit ( j , selected ) ;
76916: LD_VAR 0 3
76920: PPUSH
76921: LD_VAR 0 7
76925: PPUSH
76926: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76930: LD_VAR 0 3
76934: PPUSH
76935: LD_INT 16
76937: PPUSH
76938: CALL_OW 183
// AddComExitBuilding ( j ) ;
76942: LD_VAR 0 3
76946: PPUSH
76947: CALL_OW 182
// end ;
76951: GO 76889
76953: POP
76954: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76955: LD_VAR 0 5
76959: PPUSH
76960: LD_INT 11
76962: PPUSH
76963: CALL_OW 325
76967: IFFALSE 77226
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76969: LD_ADDR_VAR 0 4
76973: PUSH
76974: LD_EXP 88
76978: PUSH
76979: LD_VAR 0 2
76983: ARRAY
76984: PPUSH
76985: LD_INT 25
76987: PUSH
76988: LD_INT 16
76990: PUSH
76991: EMPTY
76992: LIST
76993: LIST
76994: PPUSH
76995: CALL_OW 72
76999: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
77000: LD_VAR 0 4
77004: PUSH
77005: LD_INT 6
77007: GREATEREQUAL
77008: PUSH
77009: LD_VAR 0 5
77013: PPUSH
77014: LD_INT 2
77016: PPUSH
77017: CALL_OW 325
77021: NOT
77022: OR
77023: IFFALSE 77226
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
77025: LD_ADDR_VAR 0 8
77029: PUSH
77030: LD_EXP 59
77034: PUSH
77035: LD_VAR 0 2
77039: ARRAY
77040: PPUSH
77041: LD_INT 2
77043: PUSH
77044: LD_INT 30
77046: PUSH
77047: LD_INT 4
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: PUSH
77054: LD_INT 30
77056: PUSH
77057: LD_INT 5
77059: PUSH
77060: EMPTY
77061: LIST
77062: LIST
77063: PUSH
77064: EMPTY
77065: LIST
77066: LIST
77067: LIST
77068: PPUSH
77069: CALL_OW 72
77073: ST_TO_ADDR
// if barracks then
77074: LD_VAR 0 8
77078: IFFALSE 77226
// begin selected := 0 ;
77080: LD_ADDR_VAR 0 7
77084: PUSH
77085: LD_INT 0
77087: ST_TO_ADDR
// for j in barracks do
77088: LD_ADDR_VAR 0 3
77092: PUSH
77093: LD_VAR 0 8
77097: PUSH
77098: FOR_IN
77099: IFFALSE 77130
// begin if UnitsInside ( j ) < 6 then
77101: LD_VAR 0 3
77105: PPUSH
77106: CALL_OW 313
77110: PUSH
77111: LD_INT 6
77113: LESS
77114: IFFALSE 77128
// begin selected := j ;
77116: LD_ADDR_VAR 0 7
77120: PUSH
77121: LD_VAR 0 3
77125: ST_TO_ADDR
// break ;
77126: GO 77130
// end ; end ;
77128: GO 77098
77130: POP
77131: POP
// if selected then
77132: LD_VAR 0 7
77136: IFFALSE 77226
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
77138: LD_ADDR_VAR 0 3
77142: PUSH
77143: LD_EXP 88
77147: PUSH
77148: LD_VAR 0 2
77152: ARRAY
77153: PPUSH
77154: LD_INT 25
77156: PUSH
77157: LD_INT 12
77159: PUSH
77160: EMPTY
77161: LIST
77162: LIST
77163: PPUSH
77164: CALL_OW 72
77168: PUSH
77169: FOR_IN
77170: IFFALSE 77224
// if not IsInUnit ( j ) and not HasTask ( j ) then
77172: LD_VAR 0 3
77176: PPUSH
77177: CALL_OW 310
77181: NOT
77182: PUSH
77183: LD_VAR 0 3
77187: PPUSH
77188: CALL_OW 314
77192: NOT
77193: AND
77194: IFFALSE 77222
// begin ComEnterUnit ( j , selected ) ;
77196: LD_VAR 0 3
77200: PPUSH
77201: LD_VAR 0 7
77205: PPUSH
77206: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
77210: LD_VAR 0 3
77214: PPUSH
77215: LD_INT 15
77217: PPUSH
77218: CALL_OW 183
// end ;
77222: GO 77169
77224: POP
77225: POP
// end ; end ; end ; end ; end ;
77226: GO 76619
77228: POP
77229: POP
// end ;
77230: LD_VAR 0 1
77234: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
77235: LD_INT 0
77237: PPUSH
77238: PPUSH
77239: PPUSH
77240: PPUSH
// if not mc_bases then
77241: LD_EXP 59
77245: NOT
77246: IFFALSE 77250
// exit ;
77248: GO 77428
// for i = 1 to mc_bases do
77250: LD_ADDR_VAR 0 2
77254: PUSH
77255: DOUBLE
77256: LD_INT 1
77258: DEC
77259: ST_TO_ADDR
77260: LD_EXP 59
77264: PUSH
77265: FOR_TO
77266: IFFALSE 77426
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
77268: LD_ADDR_VAR 0 4
77272: PUSH
77273: LD_EXP 59
77277: PUSH
77278: LD_VAR 0 2
77282: ARRAY
77283: PPUSH
77284: LD_INT 25
77286: PUSH
77287: LD_INT 9
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: PPUSH
77294: CALL_OW 72
77298: ST_TO_ADDR
// if not tmp then
77299: LD_VAR 0 4
77303: NOT
77304: IFFALSE 77308
// continue ;
77306: GO 77265
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77308: LD_EXP 85
77312: PUSH
77313: LD_VAR 0 2
77317: ARRAY
77318: PPUSH
77319: LD_INT 29
77321: PPUSH
77322: CALL_OW 325
77326: NOT
77327: PUSH
77328: LD_EXP 85
77332: PUSH
77333: LD_VAR 0 2
77337: ARRAY
77338: PPUSH
77339: LD_INT 28
77341: PPUSH
77342: CALL_OW 325
77346: NOT
77347: AND
77348: IFFALSE 77352
// continue ;
77350: GO 77265
// for j in tmp do
77352: LD_ADDR_VAR 0 3
77356: PUSH
77357: LD_VAR 0 4
77361: PUSH
77362: FOR_IN
77363: IFFALSE 77422
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77365: LD_VAR 0 3
77369: PUSH
77370: LD_EXP 62
77374: PUSH
77375: LD_VAR 0 2
77379: ARRAY
77380: PUSH
77381: LD_INT 1
77383: ARRAY
77384: IN
77385: NOT
77386: PUSH
77387: LD_VAR 0 3
77391: PUSH
77392: LD_EXP 62
77396: PUSH
77397: LD_VAR 0 2
77401: ARRAY
77402: PUSH
77403: LD_INT 2
77405: ARRAY
77406: IN
77407: NOT
77408: AND
77409: IFFALSE 77420
// ComSpaceTimeShoot ( j ) ;
77411: LD_VAR 0 3
77415: PPUSH
77416: CALL 15235 0 1
77420: GO 77362
77422: POP
77423: POP
// end ;
77424: GO 77265
77426: POP
77427: POP
// end ;
77428: LD_VAR 0 1
77432: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77433: LD_INT 0
77435: PPUSH
77436: PPUSH
77437: PPUSH
77438: PPUSH
77439: PPUSH
77440: PPUSH
77441: PPUSH
77442: PPUSH
77443: PPUSH
// if not mc_bases then
77444: LD_EXP 59
77448: NOT
77449: IFFALSE 77453
// exit ;
77451: GO 78075
// for i = 1 to mc_bases do
77453: LD_ADDR_VAR 0 2
77457: PUSH
77458: DOUBLE
77459: LD_INT 1
77461: DEC
77462: ST_TO_ADDR
77463: LD_EXP 59
77467: PUSH
77468: FOR_TO
77469: IFFALSE 78073
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77471: LD_EXP 94
77475: PUSH
77476: LD_VAR 0 2
77480: ARRAY
77481: NOT
77482: PUSH
77483: LD_INT 38
77485: PPUSH
77486: LD_EXP 85
77490: PUSH
77491: LD_VAR 0 2
77495: ARRAY
77496: PPUSH
77497: CALL_OW 321
77501: PUSH
77502: LD_INT 2
77504: NONEQUAL
77505: OR
77506: IFFALSE 77510
// continue ;
77508: GO 77468
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77510: LD_ADDR_VAR 0 8
77514: PUSH
77515: LD_EXP 59
77519: PUSH
77520: LD_VAR 0 2
77524: ARRAY
77525: PPUSH
77526: LD_INT 30
77528: PUSH
77529: LD_INT 34
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PPUSH
77536: CALL_OW 72
77540: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77541: LD_ADDR_VAR 0 9
77545: PUSH
77546: LD_EXP 59
77550: PUSH
77551: LD_VAR 0 2
77555: ARRAY
77556: PPUSH
77557: LD_INT 25
77559: PUSH
77560: LD_INT 4
77562: PUSH
77563: EMPTY
77564: LIST
77565: LIST
77566: PPUSH
77567: CALL_OW 72
77571: PPUSH
77572: LD_INT 0
77574: PPUSH
77575: CALL 54919 0 2
77579: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77580: LD_VAR 0 9
77584: NOT
77585: PUSH
77586: LD_VAR 0 8
77590: NOT
77591: OR
77592: PUSH
77593: LD_EXP 59
77597: PUSH
77598: LD_VAR 0 2
77602: ARRAY
77603: PPUSH
77604: LD_INT 124
77606: PPUSH
77607: CALL 54919 0 2
77611: OR
77612: IFFALSE 77616
// continue ;
77614: GO 77468
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77616: LD_EXP 95
77620: PUSH
77621: LD_VAR 0 2
77625: ARRAY
77626: PUSH
77627: LD_EXP 94
77631: PUSH
77632: LD_VAR 0 2
77636: ARRAY
77637: LESS
77638: PUSH
77639: LD_EXP 95
77643: PUSH
77644: LD_VAR 0 2
77648: ARRAY
77649: PUSH
77650: LD_VAR 0 8
77654: LESS
77655: AND
77656: IFFALSE 78071
// begin tmp := sci [ 1 ] ;
77658: LD_ADDR_VAR 0 7
77662: PUSH
77663: LD_VAR 0 9
77667: PUSH
77668: LD_INT 1
77670: ARRAY
77671: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77672: LD_VAR 0 7
77676: PPUSH
77677: LD_INT 124
77679: PPUSH
77680: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77684: LD_ADDR_VAR 0 3
77688: PUSH
77689: DOUBLE
77690: LD_EXP 94
77694: PUSH
77695: LD_VAR 0 2
77699: ARRAY
77700: INC
77701: ST_TO_ADDR
77702: LD_EXP 94
77706: PUSH
77707: LD_VAR 0 2
77711: ARRAY
77712: PUSH
77713: FOR_DOWNTO
77714: IFFALSE 78057
// begin if IsInUnit ( tmp ) then
77716: LD_VAR 0 7
77720: PPUSH
77721: CALL_OW 310
77725: IFFALSE 77736
// ComExitBuilding ( tmp ) ;
77727: LD_VAR 0 7
77731: PPUSH
77732: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77736: LD_INT 35
77738: PPUSH
77739: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77743: LD_VAR 0 7
77747: PPUSH
77748: CALL_OW 310
77752: NOT
77753: PUSH
77754: LD_VAR 0 7
77758: PPUSH
77759: CALL_OW 314
77763: NOT
77764: AND
77765: IFFALSE 77736
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77767: LD_ADDR_VAR 0 6
77771: PUSH
77772: LD_VAR 0 7
77776: PPUSH
77777: CALL_OW 250
77781: PUSH
77782: LD_VAR 0 7
77786: PPUSH
77787: CALL_OW 251
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77796: LD_INT 35
77798: PPUSH
77799: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77803: LD_ADDR_VAR 0 4
77807: PUSH
77808: LD_EXP 94
77812: PUSH
77813: LD_VAR 0 2
77817: ARRAY
77818: PUSH
77819: LD_VAR 0 3
77823: ARRAY
77824: PUSH
77825: LD_INT 1
77827: ARRAY
77828: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77829: LD_ADDR_VAR 0 5
77833: PUSH
77834: LD_EXP 94
77838: PUSH
77839: LD_VAR 0 2
77843: ARRAY
77844: PUSH
77845: LD_VAR 0 3
77849: ARRAY
77850: PUSH
77851: LD_INT 2
77853: ARRAY
77854: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77855: LD_VAR 0 7
77859: PPUSH
77860: LD_INT 10
77862: PPUSH
77863: CALL 24242 0 2
77867: PUSH
77868: LD_INT 4
77870: ARRAY
77871: IFFALSE 77909
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77873: LD_VAR 0 7
77877: PPUSH
77878: LD_VAR 0 6
77882: PUSH
77883: LD_INT 1
77885: ARRAY
77886: PPUSH
77887: LD_VAR 0 6
77891: PUSH
77892: LD_INT 2
77894: ARRAY
77895: PPUSH
77896: CALL_OW 111
// wait ( 0 0$10 ) ;
77900: LD_INT 350
77902: PPUSH
77903: CALL_OW 67
// end else
77907: GO 77935
// begin ComMoveXY ( tmp , x , y ) ;
77909: LD_VAR 0 7
77913: PPUSH
77914: LD_VAR 0 4
77918: PPUSH
77919: LD_VAR 0 5
77923: PPUSH
77924: CALL_OW 111
// wait ( 0 0$3 ) ;
77928: LD_INT 105
77930: PPUSH
77931: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77935: LD_VAR 0 7
77939: PPUSH
77940: LD_VAR 0 4
77944: PPUSH
77945: LD_VAR 0 5
77949: PPUSH
77950: CALL_OW 307
77954: IFFALSE 77796
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77956: LD_VAR 0 7
77960: PPUSH
77961: LD_VAR 0 4
77965: PPUSH
77966: LD_VAR 0 5
77970: PPUSH
77971: LD_VAR 0 8
77975: PUSH
77976: LD_VAR 0 3
77980: ARRAY
77981: PPUSH
77982: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77986: LD_INT 35
77988: PPUSH
77989: CALL_OW 67
// until not HasTask ( tmp ) ;
77993: LD_VAR 0 7
77997: PPUSH
77998: CALL_OW 314
78002: NOT
78003: IFFALSE 77986
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
78005: LD_ADDR_EXP 95
78009: PUSH
78010: LD_EXP 95
78014: PPUSH
78015: LD_VAR 0 2
78019: PUSH
78020: LD_EXP 95
78024: PUSH
78025: LD_VAR 0 2
78029: ARRAY
78030: PUSH
78031: LD_INT 1
78033: PLUS
78034: PUSH
78035: EMPTY
78036: LIST
78037: LIST
78038: PPUSH
78039: LD_VAR 0 8
78043: PUSH
78044: LD_VAR 0 3
78048: ARRAY
78049: PPUSH
78050: CALL 21649 0 3
78054: ST_TO_ADDR
// end ;
78055: GO 77713
78057: POP
78058: POP
// MC_Reset ( i , 124 ) ;
78059: LD_VAR 0 2
78063: PPUSH
78064: LD_INT 124
78066: PPUSH
78067: CALL 61662 0 2
// end ; end ;
78071: GO 77468
78073: POP
78074: POP
// end ;
78075: LD_VAR 0 1
78079: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
78080: LD_INT 0
78082: PPUSH
78083: PPUSH
78084: PPUSH
// if not mc_bases then
78085: LD_EXP 59
78089: NOT
78090: IFFALSE 78094
// exit ;
78092: GO 78700
// for i = 1 to mc_bases do
78094: LD_ADDR_VAR 0 2
78098: PUSH
78099: DOUBLE
78100: LD_INT 1
78102: DEC
78103: ST_TO_ADDR
78104: LD_EXP 59
78108: PUSH
78109: FOR_TO
78110: IFFALSE 78698
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
78112: LD_ADDR_VAR 0 3
78116: PUSH
78117: LD_EXP 59
78121: PUSH
78122: LD_VAR 0 2
78126: ARRAY
78127: PPUSH
78128: LD_INT 25
78130: PUSH
78131: LD_INT 4
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: PPUSH
78138: CALL_OW 72
78142: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78143: LD_VAR 0 3
78147: NOT
78148: PUSH
78149: LD_EXP 96
78153: PUSH
78154: LD_VAR 0 2
78158: ARRAY
78159: NOT
78160: OR
78161: PUSH
78162: LD_EXP 59
78166: PUSH
78167: LD_VAR 0 2
78171: ARRAY
78172: PPUSH
78173: LD_INT 2
78175: PUSH
78176: LD_INT 30
78178: PUSH
78179: LD_INT 0
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PUSH
78186: LD_INT 30
78188: PUSH
78189: LD_INT 1
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: LIST
78200: PPUSH
78201: CALL_OW 72
78205: NOT
78206: OR
78207: IFFALSE 78257
// begin if mc_deposits_finder [ i ] then
78209: LD_EXP 97
78213: PUSH
78214: LD_VAR 0 2
78218: ARRAY
78219: IFFALSE 78255
// begin MC_Reset ( i , 125 ) ;
78221: LD_VAR 0 2
78225: PPUSH
78226: LD_INT 125
78228: PPUSH
78229: CALL 61662 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78233: LD_ADDR_EXP 97
78237: PUSH
78238: LD_EXP 97
78242: PPUSH
78243: LD_VAR 0 2
78247: PPUSH
78248: EMPTY
78249: PPUSH
78250: CALL_OW 1
78254: ST_TO_ADDR
// end ; continue ;
78255: GO 78109
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
78257: LD_EXP 96
78261: PUSH
78262: LD_VAR 0 2
78266: ARRAY
78267: PUSH
78268: LD_INT 1
78270: ARRAY
78271: PUSH
78272: LD_INT 3
78274: ARRAY
78275: PUSH
78276: LD_INT 1
78278: EQUAL
78279: PUSH
78280: LD_INT 20
78282: PPUSH
78283: LD_EXP 85
78287: PUSH
78288: LD_VAR 0 2
78292: ARRAY
78293: PPUSH
78294: CALL_OW 321
78298: PUSH
78299: LD_INT 2
78301: NONEQUAL
78302: AND
78303: IFFALSE 78353
// begin if mc_deposits_finder [ i ] then
78305: LD_EXP 97
78309: PUSH
78310: LD_VAR 0 2
78314: ARRAY
78315: IFFALSE 78351
// begin MC_Reset ( i , 125 ) ;
78317: LD_VAR 0 2
78321: PPUSH
78322: LD_INT 125
78324: PPUSH
78325: CALL 61662 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78329: LD_ADDR_EXP 97
78333: PUSH
78334: LD_EXP 97
78338: PPUSH
78339: LD_VAR 0 2
78343: PPUSH
78344: EMPTY
78345: PPUSH
78346: CALL_OW 1
78350: ST_TO_ADDR
// end ; continue ;
78351: GO 78109
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78353: LD_EXP 96
78357: PUSH
78358: LD_VAR 0 2
78362: ARRAY
78363: PUSH
78364: LD_INT 1
78366: ARRAY
78367: PUSH
78368: LD_INT 1
78370: ARRAY
78371: PPUSH
78372: LD_EXP 96
78376: PUSH
78377: LD_VAR 0 2
78381: ARRAY
78382: PUSH
78383: LD_INT 1
78385: ARRAY
78386: PUSH
78387: LD_INT 2
78389: ARRAY
78390: PPUSH
78391: LD_EXP 85
78395: PUSH
78396: LD_VAR 0 2
78400: ARRAY
78401: PPUSH
78402: CALL_OW 440
78406: IFFALSE 78449
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78408: LD_ADDR_EXP 96
78412: PUSH
78413: LD_EXP 96
78417: PPUSH
78418: LD_VAR 0 2
78422: PPUSH
78423: LD_EXP 96
78427: PUSH
78428: LD_VAR 0 2
78432: ARRAY
78433: PPUSH
78434: LD_INT 1
78436: PPUSH
78437: CALL_OW 3
78441: PPUSH
78442: CALL_OW 1
78446: ST_TO_ADDR
78447: GO 78696
// begin if not mc_deposits_finder [ i ] then
78449: LD_EXP 97
78453: PUSH
78454: LD_VAR 0 2
78458: ARRAY
78459: NOT
78460: IFFALSE 78512
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78462: LD_ADDR_EXP 97
78466: PUSH
78467: LD_EXP 97
78471: PPUSH
78472: LD_VAR 0 2
78476: PPUSH
78477: LD_VAR 0 3
78481: PUSH
78482: LD_INT 1
78484: ARRAY
78485: PUSH
78486: EMPTY
78487: LIST
78488: PPUSH
78489: CALL_OW 1
78493: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78494: LD_VAR 0 3
78498: PUSH
78499: LD_INT 1
78501: ARRAY
78502: PPUSH
78503: LD_INT 125
78505: PPUSH
78506: CALL_OW 109
// end else
78510: GO 78696
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78512: LD_EXP 97
78516: PUSH
78517: LD_VAR 0 2
78521: ARRAY
78522: PUSH
78523: LD_INT 1
78525: ARRAY
78526: PPUSH
78527: CALL_OW 310
78531: IFFALSE 78554
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78533: LD_EXP 97
78537: PUSH
78538: LD_VAR 0 2
78542: ARRAY
78543: PUSH
78544: LD_INT 1
78546: ARRAY
78547: PPUSH
78548: CALL_OW 122
78552: GO 78696
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78554: LD_EXP 97
78558: PUSH
78559: LD_VAR 0 2
78563: ARRAY
78564: PUSH
78565: LD_INT 1
78567: ARRAY
78568: PPUSH
78569: CALL_OW 314
78573: NOT
78574: PUSH
78575: LD_EXP 97
78579: PUSH
78580: LD_VAR 0 2
78584: ARRAY
78585: PUSH
78586: LD_INT 1
78588: ARRAY
78589: PPUSH
78590: LD_EXP 96
78594: PUSH
78595: LD_VAR 0 2
78599: ARRAY
78600: PUSH
78601: LD_INT 1
78603: ARRAY
78604: PUSH
78605: LD_INT 1
78607: ARRAY
78608: PPUSH
78609: LD_EXP 96
78613: PUSH
78614: LD_VAR 0 2
78618: ARRAY
78619: PUSH
78620: LD_INT 1
78622: ARRAY
78623: PUSH
78624: LD_INT 2
78626: ARRAY
78627: PPUSH
78628: CALL_OW 297
78632: PUSH
78633: LD_INT 6
78635: GREATER
78636: AND
78637: IFFALSE 78696
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78639: LD_EXP 97
78643: PUSH
78644: LD_VAR 0 2
78648: ARRAY
78649: PUSH
78650: LD_INT 1
78652: ARRAY
78653: PPUSH
78654: LD_EXP 96
78658: PUSH
78659: LD_VAR 0 2
78663: ARRAY
78664: PUSH
78665: LD_INT 1
78667: ARRAY
78668: PUSH
78669: LD_INT 1
78671: ARRAY
78672: PPUSH
78673: LD_EXP 96
78677: PUSH
78678: LD_VAR 0 2
78682: ARRAY
78683: PUSH
78684: LD_INT 1
78686: ARRAY
78687: PUSH
78688: LD_INT 2
78690: ARRAY
78691: PPUSH
78692: CALL_OW 111
// end ; end ; end ;
78696: GO 78109
78698: POP
78699: POP
// end ;
78700: LD_VAR 0 1
78704: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78705: LD_INT 0
78707: PPUSH
78708: PPUSH
78709: PPUSH
78710: PPUSH
78711: PPUSH
78712: PPUSH
78713: PPUSH
78714: PPUSH
78715: PPUSH
78716: PPUSH
78717: PPUSH
// if not mc_bases then
78718: LD_EXP 59
78722: NOT
78723: IFFALSE 78727
// exit ;
78725: GO 79667
// for i = 1 to mc_bases do
78727: LD_ADDR_VAR 0 2
78731: PUSH
78732: DOUBLE
78733: LD_INT 1
78735: DEC
78736: ST_TO_ADDR
78737: LD_EXP 59
78741: PUSH
78742: FOR_TO
78743: IFFALSE 79665
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78745: LD_EXP 59
78749: PUSH
78750: LD_VAR 0 2
78754: ARRAY
78755: NOT
78756: PUSH
78757: LD_EXP 82
78761: PUSH
78762: LD_VAR 0 2
78766: ARRAY
78767: OR
78768: IFFALSE 78772
// continue ;
78770: GO 78742
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78772: LD_ADDR_VAR 0 7
78776: PUSH
78777: LD_EXP 59
78781: PUSH
78782: LD_VAR 0 2
78786: ARRAY
78787: PUSH
78788: LD_INT 1
78790: ARRAY
78791: PPUSH
78792: CALL_OW 248
78796: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78797: LD_VAR 0 7
78801: PUSH
78802: LD_INT 3
78804: EQUAL
78805: PUSH
78806: LD_EXP 78
78810: PUSH
78811: LD_VAR 0 2
78815: ARRAY
78816: PUSH
78817: LD_EXP 81
78821: PUSH
78822: LD_VAR 0 2
78826: ARRAY
78827: UNION
78828: PPUSH
78829: LD_INT 33
78831: PUSH
78832: LD_INT 2
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PPUSH
78839: CALL_OW 72
78843: NOT
78844: OR
78845: IFFALSE 78849
// continue ;
78847: GO 78742
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78849: LD_ADDR_VAR 0 9
78853: PUSH
78854: LD_EXP 59
78858: PUSH
78859: LD_VAR 0 2
78863: ARRAY
78864: PPUSH
78865: LD_INT 30
78867: PUSH
78868: LD_INT 36
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PPUSH
78875: CALL_OW 72
78879: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78880: LD_ADDR_VAR 0 10
78884: PUSH
78885: LD_EXP 78
78889: PUSH
78890: LD_VAR 0 2
78894: ARRAY
78895: PPUSH
78896: LD_INT 34
78898: PUSH
78899: LD_INT 31
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PPUSH
78906: CALL_OW 72
78910: ST_TO_ADDR
// if not cts and not mcts then
78911: LD_VAR 0 9
78915: NOT
78916: PUSH
78917: LD_VAR 0 10
78921: NOT
78922: AND
78923: IFFALSE 78927
// continue ;
78925: GO 78742
// x := cts ;
78927: LD_ADDR_VAR 0 11
78931: PUSH
78932: LD_VAR 0 9
78936: ST_TO_ADDR
// if not x then
78937: LD_VAR 0 11
78941: NOT
78942: IFFALSE 78954
// x := mcts ;
78944: LD_ADDR_VAR 0 11
78948: PUSH
78949: LD_VAR 0 10
78953: ST_TO_ADDR
// if not x then
78954: LD_VAR 0 11
78958: NOT
78959: IFFALSE 78963
// continue ;
78961: GO 78742
// if mc_remote_driver [ i ] then
78963: LD_EXP 99
78967: PUSH
78968: LD_VAR 0 2
78972: ARRAY
78973: IFFALSE 79360
// for j in mc_remote_driver [ i ] do
78975: LD_ADDR_VAR 0 3
78979: PUSH
78980: LD_EXP 99
78984: PUSH
78985: LD_VAR 0 2
78989: ARRAY
78990: PUSH
78991: FOR_IN
78992: IFFALSE 79358
// begin if GetClass ( j ) <> 3 then
78994: LD_VAR 0 3
78998: PPUSH
78999: CALL_OW 257
79003: PUSH
79004: LD_INT 3
79006: NONEQUAL
79007: IFFALSE 79060
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
79009: LD_ADDR_EXP 99
79013: PUSH
79014: LD_EXP 99
79018: PPUSH
79019: LD_VAR 0 2
79023: PPUSH
79024: LD_EXP 99
79028: PUSH
79029: LD_VAR 0 2
79033: ARRAY
79034: PUSH
79035: LD_VAR 0 3
79039: DIFF
79040: PPUSH
79041: CALL_OW 1
79045: ST_TO_ADDR
// SetTag ( j , 0 ) ;
79046: LD_VAR 0 3
79050: PPUSH
79051: LD_INT 0
79053: PPUSH
79054: CALL_OW 109
// continue ;
79058: GO 78991
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
79060: LD_EXP 78
79064: PUSH
79065: LD_VAR 0 2
79069: ARRAY
79070: PPUSH
79071: LD_INT 34
79073: PUSH
79074: LD_INT 31
79076: PUSH
79077: EMPTY
79078: LIST
79079: LIST
79080: PUSH
79081: LD_INT 58
79083: PUSH
79084: EMPTY
79085: LIST
79086: PUSH
79087: EMPTY
79088: LIST
79089: LIST
79090: PPUSH
79091: CALL_OW 72
79095: PUSH
79096: LD_VAR 0 3
79100: PPUSH
79101: CALL 55007 0 1
79105: NOT
79106: AND
79107: IFFALSE 79178
// begin if IsInUnit ( j ) then
79109: LD_VAR 0 3
79113: PPUSH
79114: CALL_OW 310
79118: IFFALSE 79129
// ComExitBuilding ( j ) ;
79120: LD_VAR 0 3
79124: PPUSH
79125: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
79129: LD_VAR 0 3
79133: PPUSH
79134: LD_EXP 78
79138: PUSH
79139: LD_VAR 0 2
79143: ARRAY
79144: PPUSH
79145: LD_INT 34
79147: PUSH
79148: LD_INT 31
79150: PUSH
79151: EMPTY
79152: LIST
79153: LIST
79154: PUSH
79155: LD_INT 58
79157: PUSH
79158: EMPTY
79159: LIST
79160: PUSH
79161: EMPTY
79162: LIST
79163: LIST
79164: PPUSH
79165: CALL_OW 72
79169: PUSH
79170: LD_INT 1
79172: ARRAY
79173: PPUSH
79174: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
79178: LD_VAR 0 3
79182: PPUSH
79183: CALL_OW 310
79187: NOT
79188: PUSH
79189: LD_VAR 0 3
79193: PPUSH
79194: CALL_OW 310
79198: PPUSH
79199: CALL_OW 266
79203: PUSH
79204: LD_INT 36
79206: NONEQUAL
79207: PUSH
79208: LD_VAR 0 3
79212: PPUSH
79213: CALL 55007 0 1
79217: NOT
79218: AND
79219: OR
79220: IFFALSE 79356
// begin if IsInUnit ( j ) then
79222: LD_VAR 0 3
79226: PPUSH
79227: CALL_OW 310
79231: IFFALSE 79242
// ComExitBuilding ( j ) ;
79233: LD_VAR 0 3
79237: PPUSH
79238: CALL_OW 122
// ct := 0 ;
79242: LD_ADDR_VAR 0 8
79246: PUSH
79247: LD_INT 0
79249: ST_TO_ADDR
// for k in x do
79250: LD_ADDR_VAR 0 4
79254: PUSH
79255: LD_VAR 0 11
79259: PUSH
79260: FOR_IN
79261: IFFALSE 79334
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
79263: LD_VAR 0 4
79267: PPUSH
79268: CALL_OW 264
79272: PUSH
79273: LD_INT 31
79275: EQUAL
79276: PUSH
79277: LD_VAR 0 4
79281: PPUSH
79282: CALL_OW 311
79286: NOT
79287: AND
79288: PUSH
79289: LD_VAR 0 4
79293: PPUSH
79294: CALL_OW 266
79298: PUSH
79299: LD_INT 36
79301: EQUAL
79302: PUSH
79303: LD_VAR 0 4
79307: PPUSH
79308: CALL_OW 313
79312: PUSH
79313: LD_INT 3
79315: LESS
79316: AND
79317: OR
79318: IFFALSE 79332
// begin ct := k ;
79320: LD_ADDR_VAR 0 8
79324: PUSH
79325: LD_VAR 0 4
79329: ST_TO_ADDR
// break ;
79330: GO 79334
// end ;
79332: GO 79260
79334: POP
79335: POP
// if ct then
79336: LD_VAR 0 8
79340: IFFALSE 79356
// ComEnterUnit ( j , ct ) ;
79342: LD_VAR 0 3
79346: PPUSH
79347: LD_VAR 0 8
79351: PPUSH
79352: CALL_OW 120
// end ; end ;
79356: GO 78991
79358: POP
79359: POP
// places := 0 ;
79360: LD_ADDR_VAR 0 5
79364: PUSH
79365: LD_INT 0
79367: ST_TO_ADDR
// for j = 1 to x do
79368: LD_ADDR_VAR 0 3
79372: PUSH
79373: DOUBLE
79374: LD_INT 1
79376: DEC
79377: ST_TO_ADDR
79378: LD_VAR 0 11
79382: PUSH
79383: FOR_TO
79384: IFFALSE 79460
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79386: LD_VAR 0 11
79390: PUSH
79391: LD_VAR 0 3
79395: ARRAY
79396: PPUSH
79397: CALL_OW 264
79401: PUSH
79402: LD_INT 31
79404: EQUAL
79405: IFFALSE 79423
// places := places + 1 else
79407: LD_ADDR_VAR 0 5
79411: PUSH
79412: LD_VAR 0 5
79416: PUSH
79417: LD_INT 1
79419: PLUS
79420: ST_TO_ADDR
79421: GO 79458
// if GetBType ( x [ j ] ) = b_control_tower then
79423: LD_VAR 0 11
79427: PUSH
79428: LD_VAR 0 3
79432: ARRAY
79433: PPUSH
79434: CALL_OW 266
79438: PUSH
79439: LD_INT 36
79441: EQUAL
79442: IFFALSE 79458
// places := places + 3 ;
79444: LD_ADDR_VAR 0 5
79448: PUSH
79449: LD_VAR 0 5
79453: PUSH
79454: LD_INT 3
79456: PLUS
79457: ST_TO_ADDR
79458: GO 79383
79460: POP
79461: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79462: LD_VAR 0 5
79466: PUSH
79467: LD_INT 0
79469: EQUAL
79470: PUSH
79471: LD_VAR 0 5
79475: PUSH
79476: LD_EXP 99
79480: PUSH
79481: LD_VAR 0 2
79485: ARRAY
79486: LESSEQUAL
79487: OR
79488: IFFALSE 79492
// continue ;
79490: GO 78742
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79492: LD_ADDR_VAR 0 6
79496: PUSH
79497: LD_EXP 59
79501: PUSH
79502: LD_VAR 0 2
79506: ARRAY
79507: PPUSH
79508: LD_INT 25
79510: PUSH
79511: LD_INT 3
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PPUSH
79518: CALL_OW 72
79522: PUSH
79523: LD_EXP 99
79527: PUSH
79528: LD_VAR 0 2
79532: ARRAY
79533: DIFF
79534: PPUSH
79535: LD_INT 3
79537: PPUSH
79538: CALL 55907 0 2
79542: ST_TO_ADDR
// for j in tmp do
79543: LD_ADDR_VAR 0 3
79547: PUSH
79548: LD_VAR 0 6
79552: PUSH
79553: FOR_IN
79554: IFFALSE 79589
// if GetTag ( j ) > 0 then
79556: LD_VAR 0 3
79560: PPUSH
79561: CALL_OW 110
79565: PUSH
79566: LD_INT 0
79568: GREATER
79569: IFFALSE 79587
// tmp := tmp diff j ;
79571: LD_ADDR_VAR 0 6
79575: PUSH
79576: LD_VAR 0 6
79580: PUSH
79581: LD_VAR 0 3
79585: DIFF
79586: ST_TO_ADDR
79587: GO 79553
79589: POP
79590: POP
// if not tmp then
79591: LD_VAR 0 6
79595: NOT
79596: IFFALSE 79600
// continue ;
79598: GO 78742
// if places then
79600: LD_VAR 0 5
79604: IFFALSE 79663
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79606: LD_ADDR_EXP 99
79610: PUSH
79611: LD_EXP 99
79615: PPUSH
79616: LD_VAR 0 2
79620: PPUSH
79621: LD_EXP 99
79625: PUSH
79626: LD_VAR 0 2
79630: ARRAY
79631: PUSH
79632: LD_VAR 0 6
79636: PUSH
79637: LD_INT 1
79639: ARRAY
79640: UNION
79641: PPUSH
79642: CALL_OW 1
79646: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79647: LD_VAR 0 6
79651: PUSH
79652: LD_INT 1
79654: ARRAY
79655: PPUSH
79656: LD_INT 126
79658: PPUSH
79659: CALL_OW 109
// end ; end ;
79663: GO 78742
79665: POP
79666: POP
// end ;
79667: LD_VAR 0 1
79671: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79672: LD_INT 0
79674: PPUSH
79675: PPUSH
79676: PPUSH
79677: PPUSH
79678: PPUSH
79679: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79680: LD_VAR 0 1
79684: NOT
79685: PUSH
79686: LD_VAR 0 2
79690: NOT
79691: OR
79692: PUSH
79693: LD_VAR 0 3
79697: NOT
79698: OR
79699: PUSH
79700: LD_VAR 0 4
79704: PUSH
79705: LD_INT 1
79707: PUSH
79708: LD_INT 2
79710: PUSH
79711: LD_INT 3
79713: PUSH
79714: LD_INT 4
79716: PUSH
79717: LD_INT 5
79719: PUSH
79720: LD_INT 8
79722: PUSH
79723: LD_INT 9
79725: PUSH
79726: LD_INT 15
79728: PUSH
79729: LD_INT 16
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: LIST
79736: LIST
79737: LIST
79738: LIST
79739: LIST
79740: LIST
79741: LIST
79742: IN
79743: NOT
79744: OR
79745: IFFALSE 79749
// exit ;
79747: GO 80649
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79749: LD_ADDR_VAR 0 2
79753: PUSH
79754: LD_VAR 0 2
79758: PPUSH
79759: LD_INT 21
79761: PUSH
79762: LD_INT 3
79764: PUSH
79765: EMPTY
79766: LIST
79767: LIST
79768: PUSH
79769: LD_INT 24
79771: PUSH
79772: LD_INT 250
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: EMPTY
79780: LIST
79781: LIST
79782: PPUSH
79783: CALL_OW 72
79787: ST_TO_ADDR
// case class of 1 , 15 :
79788: LD_VAR 0 4
79792: PUSH
79793: LD_INT 1
79795: DOUBLE
79796: EQUAL
79797: IFTRUE 79807
79799: LD_INT 15
79801: DOUBLE
79802: EQUAL
79803: IFTRUE 79807
79805: GO 79892
79807: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79808: LD_ADDR_VAR 0 8
79812: PUSH
79813: LD_VAR 0 2
79817: PPUSH
79818: LD_INT 2
79820: PUSH
79821: LD_INT 30
79823: PUSH
79824: LD_INT 32
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PUSH
79831: LD_INT 30
79833: PUSH
79834: LD_INT 31
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: LIST
79845: PPUSH
79846: CALL_OW 72
79850: PUSH
79851: LD_VAR 0 2
79855: PPUSH
79856: LD_INT 2
79858: PUSH
79859: LD_INT 30
79861: PUSH
79862: LD_INT 4
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 30
79871: PUSH
79872: LD_INT 5
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: LIST
79883: PPUSH
79884: CALL_OW 72
79888: ADD
79889: ST_TO_ADDR
79890: GO 80138
79892: LD_INT 2
79894: DOUBLE
79895: EQUAL
79896: IFTRUE 79906
79898: LD_INT 16
79900: DOUBLE
79901: EQUAL
79902: IFTRUE 79906
79904: GO 79952
79906: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79907: LD_ADDR_VAR 0 8
79911: PUSH
79912: LD_VAR 0 2
79916: PPUSH
79917: LD_INT 2
79919: PUSH
79920: LD_INT 30
79922: PUSH
79923: LD_INT 0
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: LD_INT 30
79932: PUSH
79933: LD_INT 1
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: LIST
79944: PPUSH
79945: CALL_OW 72
79949: ST_TO_ADDR
79950: GO 80138
79952: LD_INT 3
79954: DOUBLE
79955: EQUAL
79956: IFTRUE 79960
79958: GO 80006
79960: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79961: LD_ADDR_VAR 0 8
79965: PUSH
79966: LD_VAR 0 2
79970: PPUSH
79971: LD_INT 2
79973: PUSH
79974: LD_INT 30
79976: PUSH
79977: LD_INT 2
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: PUSH
79984: LD_INT 30
79986: PUSH
79987: LD_INT 3
79989: PUSH
79990: EMPTY
79991: LIST
79992: LIST
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: LIST
79998: PPUSH
79999: CALL_OW 72
80003: ST_TO_ADDR
80004: GO 80138
80006: LD_INT 4
80008: DOUBLE
80009: EQUAL
80010: IFTRUE 80014
80012: GO 80071
80014: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
80015: LD_ADDR_VAR 0 8
80019: PUSH
80020: LD_VAR 0 2
80024: PPUSH
80025: LD_INT 2
80027: PUSH
80028: LD_INT 30
80030: PUSH
80031: LD_INT 6
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PUSH
80038: LD_INT 30
80040: PUSH
80041: LD_INT 7
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 30
80050: PUSH
80051: LD_INT 8
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: LIST
80062: LIST
80063: PPUSH
80064: CALL_OW 72
80068: ST_TO_ADDR
80069: GO 80138
80071: LD_INT 5
80073: DOUBLE
80074: EQUAL
80075: IFTRUE 80091
80077: LD_INT 8
80079: DOUBLE
80080: EQUAL
80081: IFTRUE 80091
80083: LD_INT 9
80085: DOUBLE
80086: EQUAL
80087: IFTRUE 80091
80089: GO 80137
80091: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
80092: LD_ADDR_VAR 0 8
80096: PUSH
80097: LD_VAR 0 2
80101: PPUSH
80102: LD_INT 2
80104: PUSH
80105: LD_INT 30
80107: PUSH
80108: LD_INT 4
80110: PUSH
80111: EMPTY
80112: LIST
80113: LIST
80114: PUSH
80115: LD_INT 30
80117: PUSH
80118: LD_INT 5
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: LIST
80129: PPUSH
80130: CALL_OW 72
80134: ST_TO_ADDR
80135: GO 80138
80137: POP
// if not tmp then
80138: LD_VAR 0 8
80142: NOT
80143: IFFALSE 80147
// exit ;
80145: GO 80649
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
80147: LD_VAR 0 4
80151: PUSH
80152: LD_INT 1
80154: PUSH
80155: LD_INT 15
80157: PUSH
80158: EMPTY
80159: LIST
80160: LIST
80161: IN
80162: PUSH
80163: LD_EXP 68
80167: PUSH
80168: LD_VAR 0 1
80172: ARRAY
80173: AND
80174: IFFALSE 80330
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
80176: LD_ADDR_VAR 0 9
80180: PUSH
80181: LD_EXP 68
80185: PUSH
80186: LD_VAR 0 1
80190: ARRAY
80191: PUSH
80192: LD_INT 1
80194: ARRAY
80195: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
80196: LD_VAR 0 9
80200: PUSH
80201: LD_EXP 69
80205: PUSH
80206: LD_VAR 0 1
80210: ARRAY
80211: IN
80212: NOT
80213: IFFALSE 80328
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
80215: LD_ADDR_EXP 69
80219: PUSH
80220: LD_EXP 69
80224: PPUSH
80225: LD_VAR 0 1
80229: PUSH
80230: LD_EXP 69
80234: PUSH
80235: LD_VAR 0 1
80239: ARRAY
80240: PUSH
80241: LD_INT 1
80243: PLUS
80244: PUSH
80245: EMPTY
80246: LIST
80247: LIST
80248: PPUSH
80249: LD_VAR 0 9
80253: PPUSH
80254: CALL 21649 0 3
80258: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
80259: LD_ADDR_EXP 68
80263: PUSH
80264: LD_EXP 68
80268: PPUSH
80269: LD_VAR 0 1
80273: PPUSH
80274: LD_EXP 68
80278: PUSH
80279: LD_VAR 0 1
80283: ARRAY
80284: PUSH
80285: LD_VAR 0 9
80289: DIFF
80290: PPUSH
80291: CALL_OW 1
80295: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80296: LD_VAR 0 3
80300: PPUSH
80301: LD_EXP 69
80305: PUSH
80306: LD_VAR 0 1
80310: ARRAY
80311: PUSH
80312: LD_EXP 69
80316: PUSH
80317: LD_VAR 0 1
80321: ARRAY
80322: ARRAY
80323: PPUSH
80324: CALL_OW 120
// end ; exit ;
80328: GO 80649
// end ; if tmp > 1 then
80330: LD_VAR 0 8
80334: PUSH
80335: LD_INT 1
80337: GREATER
80338: IFFALSE 80442
// for i = 2 to tmp do
80340: LD_ADDR_VAR 0 6
80344: PUSH
80345: DOUBLE
80346: LD_INT 2
80348: DEC
80349: ST_TO_ADDR
80350: LD_VAR 0 8
80354: PUSH
80355: FOR_TO
80356: IFFALSE 80440
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80358: LD_VAR 0 8
80362: PUSH
80363: LD_VAR 0 6
80367: ARRAY
80368: PPUSH
80369: CALL_OW 461
80373: PUSH
80374: LD_INT 6
80376: EQUAL
80377: IFFALSE 80438
// begin x := tmp [ i ] ;
80379: LD_ADDR_VAR 0 9
80383: PUSH
80384: LD_VAR 0 8
80388: PUSH
80389: LD_VAR 0 6
80393: ARRAY
80394: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80395: LD_ADDR_VAR 0 8
80399: PUSH
80400: LD_VAR 0 8
80404: PPUSH
80405: LD_VAR 0 6
80409: PPUSH
80410: CALL_OW 3
80414: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80415: LD_ADDR_VAR 0 8
80419: PUSH
80420: LD_VAR 0 8
80424: PPUSH
80425: LD_INT 1
80427: PPUSH
80428: LD_VAR 0 9
80432: PPUSH
80433: CALL_OW 2
80437: ST_TO_ADDR
// end ;
80438: GO 80355
80440: POP
80441: POP
// for i in tmp do
80442: LD_ADDR_VAR 0 6
80446: PUSH
80447: LD_VAR 0 8
80451: PUSH
80452: FOR_IN
80453: IFFALSE 80522
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
80455: LD_VAR 0 6
80459: PPUSH
80460: CALL_OW 313
80464: PUSH
80465: LD_INT 6
80467: LESS
80468: PUSH
80469: LD_VAR 0 6
80473: PPUSH
80474: CALL_OW 266
80478: PUSH
80479: LD_INT 31
80481: PUSH
80482: LD_INT 32
80484: PUSH
80485: EMPTY
80486: LIST
80487: LIST
80488: IN
80489: NOT
80490: AND
80491: PUSH
80492: LD_VAR 0 6
80496: PPUSH
80497: CALL_OW 313
80501: PUSH
80502: LD_INT 0
80504: EQUAL
80505: OR
80506: IFFALSE 80520
// begin j := i ;
80508: LD_ADDR_VAR 0 7
80512: PUSH
80513: LD_VAR 0 6
80517: ST_TO_ADDR
// break ;
80518: GO 80522
// end ; end ;
80520: GO 80452
80522: POP
80523: POP
// if j then
80524: LD_VAR 0 7
80528: IFFALSE 80546
// ComEnterUnit ( unit , j ) else
80530: LD_VAR 0 3
80534: PPUSH
80535: LD_VAR 0 7
80539: PPUSH
80540: CALL_OW 120
80544: GO 80649
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80546: LD_ADDR_VAR 0 10
80550: PUSH
80551: LD_VAR 0 2
80555: PPUSH
80556: LD_INT 2
80558: PUSH
80559: LD_INT 30
80561: PUSH
80562: LD_INT 0
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 30
80571: PUSH
80572: LD_INT 1
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: LIST
80583: PPUSH
80584: CALL_OW 72
80588: ST_TO_ADDR
// if depot then
80589: LD_VAR 0 10
80593: IFFALSE 80649
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80595: LD_ADDR_VAR 0 10
80599: PUSH
80600: LD_VAR 0 10
80604: PPUSH
80605: LD_VAR 0 3
80609: PPUSH
80610: CALL_OW 74
80614: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80615: LD_VAR 0 3
80619: PPUSH
80620: LD_VAR 0 10
80624: PPUSH
80625: CALL_OW 296
80629: PUSH
80630: LD_INT 10
80632: GREATER
80633: IFFALSE 80649
// ComStandNearbyBuilding ( unit , depot ) ;
80635: LD_VAR 0 3
80639: PPUSH
80640: LD_VAR 0 10
80644: PPUSH
80645: CALL 15852 0 2
// end ; end ; end ;
80649: LD_VAR 0 5
80653: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80654: LD_INT 0
80656: PPUSH
80657: PPUSH
80658: PPUSH
80659: PPUSH
// if not mc_bases then
80660: LD_EXP 59
80664: NOT
80665: IFFALSE 80669
// exit ;
80667: GO 80908
// for i = 1 to mc_bases do
80669: LD_ADDR_VAR 0 2
80673: PUSH
80674: DOUBLE
80675: LD_INT 1
80677: DEC
80678: ST_TO_ADDR
80679: LD_EXP 59
80683: PUSH
80684: FOR_TO
80685: IFFALSE 80906
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80687: LD_ADDR_VAR 0 4
80691: PUSH
80692: LD_EXP 59
80696: PUSH
80697: LD_VAR 0 2
80701: ARRAY
80702: PPUSH
80703: LD_INT 21
80705: PUSH
80706: LD_INT 1
80708: PUSH
80709: EMPTY
80710: LIST
80711: LIST
80712: PPUSH
80713: CALL_OW 72
80717: PUSH
80718: LD_EXP 88
80722: PUSH
80723: LD_VAR 0 2
80727: ARRAY
80728: UNION
80729: ST_TO_ADDR
// if not tmp then
80730: LD_VAR 0 4
80734: NOT
80735: IFFALSE 80739
// continue ;
80737: GO 80684
// for j in tmp do
80739: LD_ADDR_VAR 0 3
80743: PUSH
80744: LD_VAR 0 4
80748: PUSH
80749: FOR_IN
80750: IFFALSE 80902
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80752: LD_VAR 0 3
80756: PPUSH
80757: CALL_OW 110
80761: NOT
80762: PUSH
80763: LD_VAR 0 3
80767: PPUSH
80768: CALL_OW 314
80772: NOT
80773: AND
80774: PUSH
80775: LD_VAR 0 3
80779: PPUSH
80780: CALL_OW 311
80784: NOT
80785: AND
80786: PUSH
80787: LD_VAR 0 3
80791: PPUSH
80792: CALL_OW 310
80796: NOT
80797: AND
80798: PUSH
80799: LD_VAR 0 3
80803: PUSH
80804: LD_EXP 62
80808: PUSH
80809: LD_VAR 0 2
80813: ARRAY
80814: PUSH
80815: LD_INT 1
80817: ARRAY
80818: IN
80819: NOT
80820: AND
80821: PUSH
80822: LD_VAR 0 3
80826: PUSH
80827: LD_EXP 62
80831: PUSH
80832: LD_VAR 0 2
80836: ARRAY
80837: PUSH
80838: LD_INT 2
80840: ARRAY
80841: IN
80842: NOT
80843: AND
80844: PUSH
80845: LD_VAR 0 3
80849: PUSH
80850: LD_EXP 71
80854: PUSH
80855: LD_VAR 0 2
80859: ARRAY
80860: IN
80861: NOT
80862: AND
80863: IFFALSE 80900
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80865: LD_VAR 0 2
80869: PPUSH
80870: LD_EXP 59
80874: PUSH
80875: LD_VAR 0 2
80879: ARRAY
80880: PPUSH
80881: LD_VAR 0 3
80885: PPUSH
80886: LD_VAR 0 3
80890: PPUSH
80891: CALL_OW 257
80895: PPUSH
80896: CALL 79672 0 4
// end ;
80900: GO 80749
80902: POP
80903: POP
// end ;
80904: GO 80684
80906: POP
80907: POP
// end ;
80908: LD_VAR 0 1
80912: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80913: LD_INT 0
80915: PPUSH
80916: PPUSH
80917: PPUSH
80918: PPUSH
80919: PPUSH
80920: PPUSH
// if not mc_bases [ base ] then
80921: LD_EXP 59
80925: PUSH
80926: LD_VAR 0 1
80930: ARRAY
80931: NOT
80932: IFFALSE 80936
// exit ;
80934: GO 81118
// tmp := [ ] ;
80936: LD_ADDR_VAR 0 6
80940: PUSH
80941: EMPTY
80942: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80943: LD_ADDR_VAR 0 7
80947: PUSH
80948: LD_VAR 0 3
80952: PPUSH
80953: LD_INT 0
80955: PPUSH
80956: CALL_OW 517
80960: ST_TO_ADDR
// if not list then
80961: LD_VAR 0 7
80965: NOT
80966: IFFALSE 80970
// exit ;
80968: GO 81118
// for i = 1 to amount do
80970: LD_ADDR_VAR 0 5
80974: PUSH
80975: DOUBLE
80976: LD_INT 1
80978: DEC
80979: ST_TO_ADDR
80980: LD_VAR 0 2
80984: PUSH
80985: FOR_TO
80986: IFFALSE 81066
// begin x := rand ( 1 , list [ 1 ] ) ;
80988: LD_ADDR_VAR 0 8
80992: PUSH
80993: LD_INT 1
80995: PPUSH
80996: LD_VAR 0 7
81000: PUSH
81001: LD_INT 1
81003: ARRAY
81004: PPUSH
81005: CALL_OW 12
81009: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
81010: LD_ADDR_VAR 0 6
81014: PUSH
81015: LD_VAR 0 6
81019: PPUSH
81020: LD_VAR 0 5
81024: PPUSH
81025: LD_VAR 0 7
81029: PUSH
81030: LD_INT 1
81032: ARRAY
81033: PUSH
81034: LD_VAR 0 8
81038: ARRAY
81039: PUSH
81040: LD_VAR 0 7
81044: PUSH
81045: LD_INT 2
81047: ARRAY
81048: PUSH
81049: LD_VAR 0 8
81053: ARRAY
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PPUSH
81059: CALL_OW 1
81063: ST_TO_ADDR
// end ;
81064: GO 80985
81066: POP
81067: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
81068: LD_ADDR_EXP 72
81072: PUSH
81073: LD_EXP 72
81077: PPUSH
81078: LD_VAR 0 1
81082: PPUSH
81083: LD_VAR 0 6
81087: PPUSH
81088: CALL_OW 1
81092: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
81093: LD_ADDR_EXP 74
81097: PUSH
81098: LD_EXP 74
81102: PPUSH
81103: LD_VAR 0 1
81107: PPUSH
81108: LD_VAR 0 3
81112: PPUSH
81113: CALL_OW 1
81117: ST_TO_ADDR
// end ;
81118: LD_VAR 0 4
81122: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
81123: LD_INT 0
81125: PPUSH
// if not mc_bases [ base ] then
81126: LD_EXP 59
81130: PUSH
81131: LD_VAR 0 1
81135: ARRAY
81136: NOT
81137: IFFALSE 81141
// exit ;
81139: GO 81166
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
81141: LD_ADDR_EXP 64
81145: PUSH
81146: LD_EXP 64
81150: PPUSH
81151: LD_VAR 0 1
81155: PPUSH
81156: LD_VAR 0 2
81160: PPUSH
81161: CALL_OW 1
81165: ST_TO_ADDR
// end ;
81166: LD_VAR 0 3
81170: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
81171: LD_INT 0
81173: PPUSH
// if not mc_bases [ base ] then
81174: LD_EXP 59
81178: PUSH
81179: LD_VAR 0 1
81183: ARRAY
81184: NOT
81185: IFFALSE 81189
// exit ;
81187: GO 81226
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
81189: LD_ADDR_EXP 64
81193: PUSH
81194: LD_EXP 64
81198: PPUSH
81199: LD_VAR 0 1
81203: PPUSH
81204: LD_EXP 64
81208: PUSH
81209: LD_VAR 0 1
81213: ARRAY
81214: PUSH
81215: LD_VAR 0 2
81219: UNION
81220: PPUSH
81221: CALL_OW 1
81225: ST_TO_ADDR
// end ;
81226: LD_VAR 0 3
81230: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
81231: LD_INT 0
81233: PPUSH
// if not mc_bases [ base ] then
81234: LD_EXP 59
81238: PUSH
81239: LD_VAR 0 1
81243: ARRAY
81244: NOT
81245: IFFALSE 81249
// exit ;
81247: GO 81274
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
81249: LD_ADDR_EXP 80
81253: PUSH
81254: LD_EXP 80
81258: PPUSH
81259: LD_VAR 0 1
81263: PPUSH
81264: LD_VAR 0 2
81268: PPUSH
81269: CALL_OW 1
81273: ST_TO_ADDR
// end ;
81274: LD_VAR 0 3
81278: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81279: LD_INT 0
81281: PPUSH
// if not mc_bases [ base ] then
81282: LD_EXP 59
81286: PUSH
81287: LD_VAR 0 1
81291: ARRAY
81292: NOT
81293: IFFALSE 81297
// exit ;
81295: GO 81334
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81297: LD_ADDR_EXP 80
81301: PUSH
81302: LD_EXP 80
81306: PPUSH
81307: LD_VAR 0 1
81311: PPUSH
81312: LD_EXP 80
81316: PUSH
81317: LD_VAR 0 1
81321: ARRAY
81322: PUSH
81323: LD_VAR 0 2
81327: ADD
81328: PPUSH
81329: CALL_OW 1
81333: ST_TO_ADDR
// end ;
81334: LD_VAR 0 3
81338: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81339: LD_INT 0
81341: PPUSH
// if not mc_bases [ base ] then
81342: LD_EXP 59
81346: PUSH
81347: LD_VAR 0 1
81351: ARRAY
81352: NOT
81353: IFFALSE 81357
// exit ;
81355: GO 81411
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81357: LD_ADDR_EXP 81
81361: PUSH
81362: LD_EXP 81
81366: PPUSH
81367: LD_VAR 0 1
81371: PPUSH
81372: LD_VAR 0 2
81376: PPUSH
81377: CALL_OW 1
81381: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81382: LD_ADDR_EXP 70
81386: PUSH
81387: LD_EXP 70
81391: PPUSH
81392: LD_VAR 0 1
81396: PPUSH
81397: LD_VAR 0 2
81401: PUSH
81402: LD_INT 0
81404: PLUS
81405: PPUSH
81406: CALL_OW 1
81410: ST_TO_ADDR
// end ;
81411: LD_VAR 0 3
81415: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81416: LD_INT 0
81418: PPUSH
// if not mc_bases [ base ] then
81419: LD_EXP 59
81423: PUSH
81424: LD_VAR 0 1
81428: ARRAY
81429: NOT
81430: IFFALSE 81434
// exit ;
81432: GO 81459
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81434: LD_ADDR_EXP 70
81438: PUSH
81439: LD_EXP 70
81443: PPUSH
81444: LD_VAR 0 1
81448: PPUSH
81449: LD_VAR 0 2
81453: PPUSH
81454: CALL_OW 1
81458: ST_TO_ADDR
// end ;
81459: LD_VAR 0 3
81463: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81464: LD_INT 0
81466: PPUSH
81467: PPUSH
81468: PPUSH
81469: PPUSH
// if not mc_bases [ base ] then
81470: LD_EXP 59
81474: PUSH
81475: LD_VAR 0 1
81479: ARRAY
81480: NOT
81481: IFFALSE 81485
// exit ;
81483: GO 81550
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81485: LD_ADDR_EXP 79
81489: PUSH
81490: LD_EXP 79
81494: PPUSH
81495: LD_VAR 0 1
81499: PUSH
81500: LD_EXP 79
81504: PUSH
81505: LD_VAR 0 1
81509: ARRAY
81510: PUSH
81511: LD_INT 1
81513: PLUS
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PPUSH
81519: LD_VAR 0 1
81523: PUSH
81524: LD_VAR 0 2
81528: PUSH
81529: LD_VAR 0 3
81533: PUSH
81534: LD_VAR 0 4
81538: PUSH
81539: EMPTY
81540: LIST
81541: LIST
81542: LIST
81543: LIST
81544: PPUSH
81545: CALL 21649 0 3
81549: ST_TO_ADDR
// end ;
81550: LD_VAR 0 5
81554: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81555: LD_INT 0
81557: PPUSH
// if not mc_bases [ base ] then
81558: LD_EXP 59
81562: PUSH
81563: LD_VAR 0 1
81567: ARRAY
81568: NOT
81569: IFFALSE 81573
// exit ;
81571: GO 81598
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81573: LD_ADDR_EXP 96
81577: PUSH
81578: LD_EXP 96
81582: PPUSH
81583: LD_VAR 0 1
81587: PPUSH
81588: LD_VAR 0 2
81592: PPUSH
81593: CALL_OW 1
81597: ST_TO_ADDR
// end ;
81598: LD_VAR 0 3
81602: RET
// export function MC_GetMinesField ( base ) ; begin
81603: LD_INT 0
81605: PPUSH
// result := mc_mines [ base ] ;
81606: LD_ADDR_VAR 0 2
81610: PUSH
81611: LD_EXP 72
81615: PUSH
81616: LD_VAR 0 1
81620: ARRAY
81621: ST_TO_ADDR
// end ;
81622: LD_VAR 0 2
81626: RET
// export function MC_GetProduceList ( base ) ; begin
81627: LD_INT 0
81629: PPUSH
// result := mc_produce [ base ] ;
81630: LD_ADDR_VAR 0 2
81634: PUSH
81635: LD_EXP 80
81639: PUSH
81640: LD_VAR 0 1
81644: ARRAY
81645: ST_TO_ADDR
// end ;
81646: LD_VAR 0 2
81650: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81651: LD_INT 0
81653: PPUSH
81654: PPUSH
// if not mc_bases then
81655: LD_EXP 59
81659: NOT
81660: IFFALSE 81664
// exit ;
81662: GO 81729
// if mc_bases [ base ] then
81664: LD_EXP 59
81668: PUSH
81669: LD_VAR 0 1
81673: ARRAY
81674: IFFALSE 81729
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81676: LD_ADDR_VAR 0 3
81680: PUSH
81681: LD_EXP 59
81685: PUSH
81686: LD_VAR 0 1
81690: ARRAY
81691: PPUSH
81692: LD_INT 30
81694: PUSH
81695: LD_VAR 0 2
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PPUSH
81704: CALL_OW 72
81708: ST_TO_ADDR
// if result then
81709: LD_VAR 0 3
81713: IFFALSE 81729
// result := result [ 1 ] ;
81715: LD_ADDR_VAR 0 3
81719: PUSH
81720: LD_VAR 0 3
81724: PUSH
81725: LD_INT 1
81727: ARRAY
81728: ST_TO_ADDR
// end ; end ;
81729: LD_VAR 0 3
81733: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81734: LD_INT 0
81736: PPUSH
81737: PPUSH
// if not mc_bases then
81738: LD_EXP 59
81742: NOT
81743: IFFALSE 81747
// exit ;
81745: GO 81792
// if mc_bases [ base ] then
81747: LD_EXP 59
81751: PUSH
81752: LD_VAR 0 1
81756: ARRAY
81757: IFFALSE 81792
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81759: LD_ADDR_VAR 0 3
81763: PUSH
81764: LD_EXP 59
81768: PUSH
81769: LD_VAR 0 1
81773: ARRAY
81774: PPUSH
81775: LD_INT 30
81777: PUSH
81778: LD_VAR 0 2
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PPUSH
81787: CALL_OW 72
81791: ST_TO_ADDR
// end ;
81792: LD_VAR 0 3
81796: RET
// export function MC_SetTame ( base , area ) ; begin
81797: LD_INT 0
81799: PPUSH
// if not mc_bases or not base then
81800: LD_EXP 59
81804: NOT
81805: PUSH
81806: LD_VAR 0 1
81810: NOT
81811: OR
81812: IFFALSE 81816
// exit ;
81814: GO 81841
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81816: LD_ADDR_EXP 87
81820: PUSH
81821: LD_EXP 87
81825: PPUSH
81826: LD_VAR 0 1
81830: PPUSH
81831: LD_VAR 0 2
81835: PPUSH
81836: CALL_OW 1
81840: ST_TO_ADDR
// end ;
81841: LD_VAR 0 3
81845: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81846: LD_INT 0
81848: PPUSH
81849: PPUSH
// if not mc_bases or not base then
81850: LD_EXP 59
81854: NOT
81855: PUSH
81856: LD_VAR 0 1
81860: NOT
81861: OR
81862: IFFALSE 81866
// exit ;
81864: GO 81968
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81866: LD_ADDR_VAR 0 4
81870: PUSH
81871: LD_EXP 59
81875: PUSH
81876: LD_VAR 0 1
81880: ARRAY
81881: PPUSH
81882: LD_INT 30
81884: PUSH
81885: LD_VAR 0 2
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: PPUSH
81894: CALL_OW 72
81898: ST_TO_ADDR
// if not tmp then
81899: LD_VAR 0 4
81903: NOT
81904: IFFALSE 81908
// exit ;
81906: GO 81968
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81908: LD_ADDR_EXP 91
81912: PUSH
81913: LD_EXP 91
81917: PPUSH
81918: LD_VAR 0 1
81922: PPUSH
81923: LD_EXP 91
81927: PUSH
81928: LD_VAR 0 1
81932: ARRAY
81933: PPUSH
81934: LD_EXP 91
81938: PUSH
81939: LD_VAR 0 1
81943: ARRAY
81944: PUSH
81945: LD_INT 1
81947: PLUS
81948: PPUSH
81949: LD_VAR 0 4
81953: PUSH
81954: LD_INT 1
81956: ARRAY
81957: PPUSH
81958: CALL_OW 2
81962: PPUSH
81963: CALL_OW 1
81967: ST_TO_ADDR
// end ;
81968: LD_VAR 0 3
81972: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81973: LD_INT 0
81975: PPUSH
81976: PPUSH
// if not mc_bases or not base or not kinds then
81977: LD_EXP 59
81981: NOT
81982: PUSH
81983: LD_VAR 0 1
81987: NOT
81988: OR
81989: PUSH
81990: LD_VAR 0 2
81994: NOT
81995: OR
81996: IFFALSE 82000
// exit ;
81998: GO 82061
// for i in kinds do
82000: LD_ADDR_VAR 0 4
82004: PUSH
82005: LD_VAR 0 2
82009: PUSH
82010: FOR_IN
82011: IFFALSE 82059
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
82013: LD_ADDR_EXP 93
82017: PUSH
82018: LD_EXP 93
82022: PPUSH
82023: LD_VAR 0 1
82027: PUSH
82028: LD_EXP 93
82032: PUSH
82033: LD_VAR 0 1
82037: ARRAY
82038: PUSH
82039: LD_INT 1
82041: PLUS
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PPUSH
82047: LD_VAR 0 4
82051: PPUSH
82052: CALL 21649 0 3
82056: ST_TO_ADDR
82057: GO 82010
82059: POP
82060: POP
// end ;
82061: LD_VAR 0 3
82065: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
82066: LD_INT 0
82068: PPUSH
// if not mc_bases or not base or not areas then
82069: LD_EXP 59
82073: NOT
82074: PUSH
82075: LD_VAR 0 1
82079: NOT
82080: OR
82081: PUSH
82082: LD_VAR 0 2
82086: NOT
82087: OR
82088: IFFALSE 82092
// exit ;
82090: GO 82117
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
82092: LD_ADDR_EXP 77
82096: PUSH
82097: LD_EXP 77
82101: PPUSH
82102: LD_VAR 0 1
82106: PPUSH
82107: LD_VAR 0 2
82111: PPUSH
82112: CALL_OW 1
82116: ST_TO_ADDR
// end ;
82117: LD_VAR 0 3
82121: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
82122: LD_INT 0
82124: PPUSH
// if not mc_bases or not base or not teleports_exit then
82125: LD_EXP 59
82129: NOT
82130: PUSH
82131: LD_VAR 0 1
82135: NOT
82136: OR
82137: PUSH
82138: LD_VAR 0 2
82142: NOT
82143: OR
82144: IFFALSE 82148
// exit ;
82146: GO 82173
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
82148: LD_ADDR_EXP 94
82152: PUSH
82153: LD_EXP 94
82157: PPUSH
82158: LD_VAR 0 1
82162: PPUSH
82163: LD_VAR 0 2
82167: PPUSH
82168: CALL_OW 1
82172: ST_TO_ADDR
// end ;
82173: LD_VAR 0 3
82177: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
82178: LD_INT 0
82180: PPUSH
82181: PPUSH
82182: PPUSH
// if not mc_bases or not base or not ext_list then
82183: LD_EXP 59
82187: NOT
82188: PUSH
82189: LD_VAR 0 1
82193: NOT
82194: OR
82195: PUSH
82196: LD_VAR 0 5
82200: NOT
82201: OR
82202: IFFALSE 82206
// exit ;
82204: GO 82379
// tmp := GetFacExtXYD ( x , y , d ) ;
82206: LD_ADDR_VAR 0 8
82210: PUSH
82211: LD_VAR 0 2
82215: PPUSH
82216: LD_VAR 0 3
82220: PPUSH
82221: LD_VAR 0 4
82225: PPUSH
82226: CALL 55037 0 3
82230: ST_TO_ADDR
// if not tmp then
82231: LD_VAR 0 8
82235: NOT
82236: IFFALSE 82240
// exit ;
82238: GO 82379
// for i in tmp do
82240: LD_ADDR_VAR 0 7
82244: PUSH
82245: LD_VAR 0 8
82249: PUSH
82250: FOR_IN
82251: IFFALSE 82377
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
82253: LD_ADDR_EXP 64
82257: PUSH
82258: LD_EXP 64
82262: PPUSH
82263: LD_VAR 0 1
82267: PPUSH
82268: LD_EXP 64
82272: PUSH
82273: LD_VAR 0 1
82277: ARRAY
82278: PPUSH
82279: LD_EXP 64
82283: PUSH
82284: LD_VAR 0 1
82288: ARRAY
82289: PUSH
82290: LD_INT 1
82292: PLUS
82293: PPUSH
82294: LD_VAR 0 5
82298: PUSH
82299: LD_INT 1
82301: ARRAY
82302: PUSH
82303: LD_VAR 0 7
82307: PUSH
82308: LD_INT 1
82310: ARRAY
82311: PUSH
82312: LD_VAR 0 7
82316: PUSH
82317: LD_INT 2
82319: ARRAY
82320: PUSH
82321: LD_VAR 0 7
82325: PUSH
82326: LD_INT 3
82328: ARRAY
82329: PUSH
82330: EMPTY
82331: LIST
82332: LIST
82333: LIST
82334: LIST
82335: PPUSH
82336: CALL_OW 2
82340: PPUSH
82341: CALL_OW 1
82345: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82346: LD_ADDR_VAR 0 5
82350: PUSH
82351: LD_VAR 0 5
82355: PPUSH
82356: LD_INT 1
82358: PPUSH
82359: CALL_OW 3
82363: ST_TO_ADDR
// if not ext_list then
82364: LD_VAR 0 5
82368: NOT
82369: IFFALSE 82375
// exit ;
82371: POP
82372: POP
82373: GO 82379
// end ;
82375: GO 82250
82377: POP
82378: POP
// end ;
82379: LD_VAR 0 6
82383: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82384: LD_INT 0
82386: PPUSH
// if not mc_bases or not base or not weapon_list then
82387: LD_EXP 59
82391: NOT
82392: PUSH
82393: LD_VAR 0 1
82397: NOT
82398: OR
82399: PUSH
82400: LD_VAR 0 2
82404: NOT
82405: OR
82406: IFFALSE 82410
// exit ;
82408: GO 82435
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82410: LD_ADDR_EXP 98
82414: PUSH
82415: LD_EXP 98
82419: PPUSH
82420: LD_VAR 0 1
82424: PPUSH
82425: LD_VAR 0 2
82429: PPUSH
82430: CALL_OW 1
82434: ST_TO_ADDR
// end ;
82435: LD_VAR 0 3
82439: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82440: LD_INT 0
82442: PPUSH
// if not mc_bases or not base or not tech_list then
82443: LD_EXP 59
82447: NOT
82448: PUSH
82449: LD_VAR 0 1
82453: NOT
82454: OR
82455: PUSH
82456: LD_VAR 0 2
82460: NOT
82461: OR
82462: IFFALSE 82466
// exit ;
82464: GO 82491
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82466: LD_ADDR_EXP 86
82470: PUSH
82471: LD_EXP 86
82475: PPUSH
82476: LD_VAR 0 1
82480: PPUSH
82481: LD_VAR 0 2
82485: PPUSH
82486: CALL_OW 1
82490: ST_TO_ADDR
// end ;
82491: LD_VAR 0 3
82495: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82496: LD_INT 0
82498: PPUSH
// if not mc_bases or not parking_area or not base then
82499: LD_EXP 59
82503: NOT
82504: PUSH
82505: LD_VAR 0 2
82509: NOT
82510: OR
82511: PUSH
82512: LD_VAR 0 1
82516: NOT
82517: OR
82518: IFFALSE 82522
// exit ;
82520: GO 82547
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82522: LD_ADDR_EXP 83
82526: PUSH
82527: LD_EXP 83
82531: PPUSH
82532: LD_VAR 0 1
82536: PPUSH
82537: LD_VAR 0 2
82541: PPUSH
82542: CALL_OW 1
82546: ST_TO_ADDR
// end ;
82547: LD_VAR 0 3
82551: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82552: LD_INT 0
82554: PPUSH
// if not mc_bases or not base or not scan_area then
82555: LD_EXP 59
82559: NOT
82560: PUSH
82561: LD_VAR 0 1
82565: NOT
82566: OR
82567: PUSH
82568: LD_VAR 0 2
82572: NOT
82573: OR
82574: IFFALSE 82578
// exit ;
82576: GO 82603
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82578: LD_ADDR_EXP 84
82582: PUSH
82583: LD_EXP 84
82587: PPUSH
82588: LD_VAR 0 1
82592: PPUSH
82593: LD_VAR 0 2
82597: PPUSH
82598: CALL_OW 1
82602: ST_TO_ADDR
// end ;
82603: LD_VAR 0 3
82607: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82608: LD_INT 0
82610: PPUSH
82611: PPUSH
// if not mc_bases or not base then
82612: LD_EXP 59
82616: NOT
82617: PUSH
82618: LD_VAR 0 1
82622: NOT
82623: OR
82624: IFFALSE 82628
// exit ;
82626: GO 82692
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82628: LD_ADDR_VAR 0 3
82632: PUSH
82633: LD_INT 1
82635: PUSH
82636: LD_INT 2
82638: PUSH
82639: LD_INT 3
82641: PUSH
82642: LD_INT 4
82644: PUSH
82645: LD_INT 11
82647: PUSH
82648: EMPTY
82649: LIST
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82655: LD_ADDR_EXP 86
82659: PUSH
82660: LD_EXP 86
82664: PPUSH
82665: LD_VAR 0 1
82669: PPUSH
82670: LD_EXP 86
82674: PUSH
82675: LD_VAR 0 1
82679: ARRAY
82680: PUSH
82681: LD_VAR 0 3
82685: DIFF
82686: PPUSH
82687: CALL_OW 1
82691: ST_TO_ADDR
// end ;
82692: LD_VAR 0 2
82696: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82697: LD_INT 0
82699: PPUSH
// result := mc_vehicles [ base ] ;
82700: LD_ADDR_VAR 0 3
82704: PUSH
82705: LD_EXP 78
82709: PUSH
82710: LD_VAR 0 1
82714: ARRAY
82715: ST_TO_ADDR
// if onlyCombat then
82716: LD_VAR 0 2
82720: IFFALSE 82885
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82722: LD_ADDR_VAR 0 3
82726: PUSH
82727: LD_VAR 0 3
82731: PUSH
82732: LD_VAR 0 3
82736: PPUSH
82737: LD_INT 2
82739: PUSH
82740: LD_INT 34
82742: PUSH
82743: LD_INT 12
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: LD_INT 34
82752: PUSH
82753: LD_INT 51
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: PUSH
82760: LD_INT 34
82762: PUSH
82763: LD_EXP 103
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: LD_INT 34
82774: PUSH
82775: LD_INT 32
82777: PUSH
82778: EMPTY
82779: LIST
82780: LIST
82781: PUSH
82782: LD_INT 34
82784: PUSH
82785: LD_INT 13
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 34
82794: PUSH
82795: LD_INT 52
82797: PUSH
82798: EMPTY
82799: LIST
82800: LIST
82801: PUSH
82802: LD_INT 34
82804: PUSH
82805: LD_INT 14
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: LD_INT 34
82814: PUSH
82815: LD_INT 53
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 34
82824: PUSH
82825: LD_EXP 102
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 34
82836: PUSH
82837: LD_INT 31
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 34
82846: PUSH
82847: LD_INT 48
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: LD_INT 34
82856: PUSH
82857: LD_INT 8
82859: PUSH
82860: EMPTY
82861: LIST
82862: LIST
82863: PUSH
82864: EMPTY
82865: LIST
82866: LIST
82867: LIST
82868: LIST
82869: LIST
82870: LIST
82871: LIST
82872: LIST
82873: LIST
82874: LIST
82875: LIST
82876: LIST
82877: LIST
82878: PPUSH
82879: CALL_OW 72
82883: DIFF
82884: ST_TO_ADDR
// end ; end_of_file
82885: LD_VAR 0 3
82889: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82890: LD_INT 0
82892: PPUSH
82893: PPUSH
82894: PPUSH
// if not mc_bases or not skirmish then
82895: LD_EXP 59
82899: NOT
82900: PUSH
82901: LD_EXP 57
82905: NOT
82906: OR
82907: IFFALSE 82911
// exit ;
82909: GO 83076
// for i = 1 to mc_bases do
82911: LD_ADDR_VAR 0 4
82915: PUSH
82916: DOUBLE
82917: LD_INT 1
82919: DEC
82920: ST_TO_ADDR
82921: LD_EXP 59
82925: PUSH
82926: FOR_TO
82927: IFFALSE 83074
// begin if sci in mc_bases [ i ] then
82929: LD_VAR 0 2
82933: PUSH
82934: LD_EXP 59
82938: PUSH
82939: LD_VAR 0 4
82943: ARRAY
82944: IN
82945: IFFALSE 83072
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82947: LD_ADDR_EXP 88
82951: PUSH
82952: LD_EXP 88
82956: PPUSH
82957: LD_VAR 0 4
82961: PUSH
82962: LD_EXP 88
82966: PUSH
82967: LD_VAR 0 4
82971: ARRAY
82972: PUSH
82973: LD_INT 1
82975: PLUS
82976: PUSH
82977: EMPTY
82978: LIST
82979: LIST
82980: PPUSH
82981: LD_VAR 0 1
82985: PPUSH
82986: CALL 21649 0 3
82990: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82991: LD_ADDR_VAR 0 5
82995: PUSH
82996: LD_EXP 59
83000: PUSH
83001: LD_VAR 0 4
83005: ARRAY
83006: PPUSH
83007: LD_INT 2
83009: PUSH
83010: LD_INT 30
83012: PUSH
83013: LD_INT 0
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 30
83022: PUSH
83023: LD_INT 1
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PUSH
83030: EMPTY
83031: LIST
83032: LIST
83033: LIST
83034: PPUSH
83035: CALL_OW 72
83039: PPUSH
83040: LD_VAR 0 1
83044: PPUSH
83045: CALL_OW 74
83049: ST_TO_ADDR
// if tmp then
83050: LD_VAR 0 5
83054: IFFALSE 83070
// ComStandNearbyBuilding ( ape , tmp ) ;
83056: LD_VAR 0 1
83060: PPUSH
83061: LD_VAR 0 5
83065: PPUSH
83066: CALL 15852 0 2
// break ;
83070: GO 83074
// end ; end ;
83072: GO 82926
83074: POP
83075: POP
// end ;
83076: LD_VAR 0 3
83080: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
83081: LD_INT 0
83083: PPUSH
83084: PPUSH
83085: PPUSH
// if not mc_bases or not skirmish then
83086: LD_EXP 59
83090: NOT
83091: PUSH
83092: LD_EXP 57
83096: NOT
83097: OR
83098: IFFALSE 83102
// exit ;
83100: GO 83191
// for i = 1 to mc_bases do
83102: LD_ADDR_VAR 0 4
83106: PUSH
83107: DOUBLE
83108: LD_INT 1
83110: DEC
83111: ST_TO_ADDR
83112: LD_EXP 59
83116: PUSH
83117: FOR_TO
83118: IFFALSE 83189
// begin if building in mc_busy_turret_list [ i ] then
83120: LD_VAR 0 1
83124: PUSH
83125: LD_EXP 69
83129: PUSH
83130: LD_VAR 0 4
83134: ARRAY
83135: IN
83136: IFFALSE 83187
// begin tmp := mc_busy_turret_list [ i ] diff building ;
83138: LD_ADDR_VAR 0 5
83142: PUSH
83143: LD_EXP 69
83147: PUSH
83148: LD_VAR 0 4
83152: ARRAY
83153: PUSH
83154: LD_VAR 0 1
83158: DIFF
83159: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
83160: LD_ADDR_EXP 69
83164: PUSH
83165: LD_EXP 69
83169: PPUSH
83170: LD_VAR 0 4
83174: PPUSH
83175: LD_VAR 0 5
83179: PPUSH
83180: CALL_OW 1
83184: ST_TO_ADDR
// break ;
83185: GO 83189
// end ; end ;
83187: GO 83117
83189: POP
83190: POP
// end ;
83191: LD_VAR 0 3
83195: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
83196: LD_INT 0
83198: PPUSH
83199: PPUSH
83200: PPUSH
// if not mc_bases or not skirmish then
83201: LD_EXP 59
83205: NOT
83206: PUSH
83207: LD_EXP 57
83211: NOT
83212: OR
83213: IFFALSE 83217
// exit ;
83215: GO 83416
// for i = 1 to mc_bases do
83217: LD_ADDR_VAR 0 5
83221: PUSH
83222: DOUBLE
83223: LD_INT 1
83225: DEC
83226: ST_TO_ADDR
83227: LD_EXP 59
83231: PUSH
83232: FOR_TO
83233: IFFALSE 83414
// if building in mc_bases [ i ] then
83235: LD_VAR 0 1
83239: PUSH
83240: LD_EXP 59
83244: PUSH
83245: LD_VAR 0 5
83249: ARRAY
83250: IN
83251: IFFALSE 83412
// begin tmp := mc_bases [ i ] diff building ;
83253: LD_ADDR_VAR 0 6
83257: PUSH
83258: LD_EXP 59
83262: PUSH
83263: LD_VAR 0 5
83267: ARRAY
83268: PUSH
83269: LD_VAR 0 1
83273: DIFF
83274: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
83275: LD_ADDR_EXP 59
83279: PUSH
83280: LD_EXP 59
83284: PPUSH
83285: LD_VAR 0 5
83289: PPUSH
83290: LD_VAR 0 6
83294: PPUSH
83295: CALL_OW 1
83299: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83300: LD_VAR 0 1
83304: PUSH
83305: LD_EXP 67
83309: PUSH
83310: LD_VAR 0 5
83314: ARRAY
83315: IN
83316: IFFALSE 83355
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83318: LD_ADDR_EXP 67
83322: PUSH
83323: LD_EXP 67
83327: PPUSH
83328: LD_VAR 0 5
83332: PPUSH
83333: LD_EXP 67
83337: PUSH
83338: LD_VAR 0 5
83342: ARRAY
83343: PUSH
83344: LD_VAR 0 1
83348: DIFF
83349: PPUSH
83350: CALL_OW 1
83354: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83355: LD_VAR 0 1
83359: PUSH
83360: LD_EXP 68
83364: PUSH
83365: LD_VAR 0 5
83369: ARRAY
83370: IN
83371: IFFALSE 83410
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83373: LD_ADDR_EXP 68
83377: PUSH
83378: LD_EXP 68
83382: PPUSH
83383: LD_VAR 0 5
83387: PPUSH
83388: LD_EXP 68
83392: PUSH
83393: LD_VAR 0 5
83397: ARRAY
83398: PUSH
83399: LD_VAR 0 1
83403: DIFF
83404: PPUSH
83405: CALL_OW 1
83409: ST_TO_ADDR
// break ;
83410: GO 83414
// end ;
83412: GO 83232
83414: POP
83415: POP
// end ;
83416: LD_VAR 0 4
83420: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83421: LD_INT 0
83423: PPUSH
83424: PPUSH
83425: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83426: LD_EXP 59
83430: NOT
83431: PUSH
83432: LD_EXP 57
83436: NOT
83437: OR
83438: PUSH
83439: LD_VAR 0 3
83443: PUSH
83444: LD_EXP 85
83448: IN
83449: NOT
83450: OR
83451: IFFALSE 83455
// exit ;
83453: GO 83578
// for i = 1 to mc_vehicles do
83455: LD_ADDR_VAR 0 6
83459: PUSH
83460: DOUBLE
83461: LD_INT 1
83463: DEC
83464: ST_TO_ADDR
83465: LD_EXP 78
83469: PUSH
83470: FOR_TO
83471: IFFALSE 83576
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83473: LD_VAR 0 2
83477: PUSH
83478: LD_EXP 78
83482: PUSH
83483: LD_VAR 0 6
83487: ARRAY
83488: IN
83489: PUSH
83490: LD_VAR 0 1
83494: PUSH
83495: LD_EXP 78
83499: PUSH
83500: LD_VAR 0 6
83504: ARRAY
83505: IN
83506: OR
83507: IFFALSE 83574
// begin tmp := mc_vehicles [ i ] diff old ;
83509: LD_ADDR_VAR 0 7
83513: PUSH
83514: LD_EXP 78
83518: PUSH
83519: LD_VAR 0 6
83523: ARRAY
83524: PUSH
83525: LD_VAR 0 2
83529: DIFF
83530: ST_TO_ADDR
// tmp := tmp diff new ;
83531: LD_ADDR_VAR 0 7
83535: PUSH
83536: LD_VAR 0 7
83540: PUSH
83541: LD_VAR 0 1
83545: DIFF
83546: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83547: LD_ADDR_EXP 78
83551: PUSH
83552: LD_EXP 78
83556: PPUSH
83557: LD_VAR 0 6
83561: PPUSH
83562: LD_VAR 0 7
83566: PPUSH
83567: CALL_OW 1
83571: ST_TO_ADDR
// break ;
83572: GO 83576
// end ;
83574: GO 83470
83576: POP
83577: POP
// end ;
83578: LD_VAR 0 5
83582: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83583: LD_INT 0
83585: PPUSH
83586: PPUSH
83587: PPUSH
83588: PPUSH
// if not mc_bases or not skirmish then
83589: LD_EXP 59
83593: NOT
83594: PUSH
83595: LD_EXP 57
83599: NOT
83600: OR
83601: IFFALSE 83605
// exit ;
83603: GO 83982
// side := GetSide ( vehicle ) ;
83605: LD_ADDR_VAR 0 5
83609: PUSH
83610: LD_VAR 0 1
83614: PPUSH
83615: CALL_OW 255
83619: ST_TO_ADDR
// for i = 1 to mc_bases do
83620: LD_ADDR_VAR 0 4
83624: PUSH
83625: DOUBLE
83626: LD_INT 1
83628: DEC
83629: ST_TO_ADDR
83630: LD_EXP 59
83634: PUSH
83635: FOR_TO
83636: IFFALSE 83980
// begin if factory in mc_bases [ i ] then
83638: LD_VAR 0 2
83642: PUSH
83643: LD_EXP 59
83647: PUSH
83648: LD_VAR 0 4
83652: ARRAY
83653: IN
83654: IFFALSE 83978
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
83656: LD_EXP 81
83660: PUSH
83661: LD_VAR 0 4
83665: ARRAY
83666: PUSH
83667: LD_EXP 70
83671: PUSH
83672: LD_VAR 0 4
83676: ARRAY
83677: LESS
83678: PUSH
83679: LD_VAR 0 1
83683: PPUSH
83684: CALL_OW 264
83688: PUSH
83689: LD_INT 31
83691: PUSH
83692: LD_INT 32
83694: PUSH
83695: LD_INT 51
83697: PUSH
83698: LD_EXP 103
83702: PUSH
83703: LD_INT 12
83705: PUSH
83706: LD_INT 30
83708: PUSH
83709: LD_EXP 102
83713: PUSH
83714: LD_INT 11
83716: PUSH
83717: LD_INT 53
83719: PUSH
83720: LD_INT 14
83722: PUSH
83723: LD_EXP 106
83727: PUSH
83728: LD_INT 29
83730: PUSH
83731: LD_EXP 104
83735: PUSH
83736: LD_INT 13
83738: PUSH
83739: LD_INT 52
83741: PUSH
83742: LD_INT 48
83744: PUSH
83745: LD_INT 8
83747: PUSH
83748: EMPTY
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: LIST
83764: LIST
83765: LIST
83766: IN
83767: NOT
83768: AND
83769: IFFALSE 83817
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83771: LD_ADDR_EXP 81
83775: PUSH
83776: LD_EXP 81
83780: PPUSH
83781: LD_VAR 0 4
83785: PUSH
83786: LD_EXP 81
83790: PUSH
83791: LD_VAR 0 4
83795: ARRAY
83796: PUSH
83797: LD_INT 1
83799: PLUS
83800: PUSH
83801: EMPTY
83802: LIST
83803: LIST
83804: PPUSH
83805: LD_VAR 0 1
83809: PPUSH
83810: CALL 21649 0 3
83814: ST_TO_ADDR
83815: GO 83861
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83817: LD_ADDR_EXP 78
83821: PUSH
83822: LD_EXP 78
83826: PPUSH
83827: LD_VAR 0 4
83831: PUSH
83832: LD_EXP 78
83836: PUSH
83837: LD_VAR 0 4
83841: ARRAY
83842: PUSH
83843: LD_INT 1
83845: PLUS
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: PPUSH
83851: LD_VAR 0 1
83855: PPUSH
83856: CALL 21649 0 3
83860: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83861: LD_VAR 0 1
83865: PPUSH
83866: CALL_OW 263
83870: PUSH
83871: LD_INT 2
83873: EQUAL
83874: IFFALSE 83894
// begin repeat wait ( 0 0$1 ) ;
83876: LD_INT 35
83878: PPUSH
83879: CALL_OW 67
// until IsControledBy ( vehicle ) ;
83883: LD_VAR 0 1
83887: PPUSH
83888: CALL_OW 312
83892: IFFALSE 83876
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83894: LD_VAR 0 1
83898: PPUSH
83899: LD_EXP 83
83903: PUSH
83904: LD_VAR 0 4
83908: ARRAY
83909: PPUSH
83910: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83914: LD_VAR 0 1
83918: PPUSH
83919: CALL_OW 263
83923: PUSH
83924: LD_INT 1
83926: NONEQUAL
83927: IFFALSE 83931
// break ;
83929: GO 83980
// repeat wait ( 0 0$1 ) ;
83931: LD_INT 35
83933: PPUSH
83934: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83938: LD_VAR 0 1
83942: PPUSH
83943: LD_EXP 83
83947: PUSH
83948: LD_VAR 0 4
83952: ARRAY
83953: PPUSH
83954: CALL_OW 308
83958: IFFALSE 83931
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83960: LD_VAR 0 1
83964: PPUSH
83965: CALL_OW 311
83969: PPUSH
83970: CALL_OW 121
// exit ;
83974: POP
83975: POP
83976: GO 83982
// end ; end ;
83978: GO 83635
83980: POP
83981: POP
// end ;
83982: LD_VAR 0 3
83986: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83987: LD_INT 0
83989: PPUSH
83990: PPUSH
83991: PPUSH
83992: PPUSH
// if not mc_bases or not skirmish then
83993: LD_EXP 59
83997: NOT
83998: PUSH
83999: LD_EXP 57
84003: NOT
84004: OR
84005: IFFALSE 84009
// exit ;
84007: GO 84362
// repeat wait ( 0 0$1 ) ;
84009: LD_INT 35
84011: PPUSH
84012: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
84016: LD_VAR 0 2
84020: PPUSH
84021: LD_VAR 0 3
84025: PPUSH
84026: CALL_OW 284
84030: IFFALSE 84009
// if GetResourceTypeXY ( x , y ) = mat_artefact then
84032: LD_VAR 0 2
84036: PPUSH
84037: LD_VAR 0 3
84041: PPUSH
84042: CALL_OW 283
84046: PUSH
84047: LD_INT 4
84049: EQUAL
84050: IFFALSE 84054
// exit ;
84052: GO 84362
// for i = 1 to mc_bases do
84054: LD_ADDR_VAR 0 7
84058: PUSH
84059: DOUBLE
84060: LD_INT 1
84062: DEC
84063: ST_TO_ADDR
84064: LD_EXP 59
84068: PUSH
84069: FOR_TO
84070: IFFALSE 84360
// begin if mc_crates_area [ i ] then
84072: LD_EXP 77
84076: PUSH
84077: LD_VAR 0 7
84081: ARRAY
84082: IFFALSE 84193
// for j in mc_crates_area [ i ] do
84084: LD_ADDR_VAR 0 8
84088: PUSH
84089: LD_EXP 77
84093: PUSH
84094: LD_VAR 0 7
84098: ARRAY
84099: PUSH
84100: FOR_IN
84101: IFFALSE 84191
// if InArea ( x , y , j ) then
84103: LD_VAR 0 2
84107: PPUSH
84108: LD_VAR 0 3
84112: PPUSH
84113: LD_VAR 0 8
84117: PPUSH
84118: CALL_OW 309
84122: IFFALSE 84189
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84124: LD_ADDR_EXP 75
84128: PUSH
84129: LD_EXP 75
84133: PPUSH
84134: LD_VAR 0 7
84138: PUSH
84139: LD_EXP 75
84143: PUSH
84144: LD_VAR 0 7
84148: ARRAY
84149: PUSH
84150: LD_INT 1
84152: PLUS
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: PPUSH
84158: LD_VAR 0 4
84162: PUSH
84163: LD_VAR 0 2
84167: PUSH
84168: LD_VAR 0 3
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: LIST
84177: PPUSH
84178: CALL 21649 0 3
84182: ST_TO_ADDR
// exit ;
84183: POP
84184: POP
84185: POP
84186: POP
84187: GO 84362
// end ;
84189: GO 84100
84191: POP
84192: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84193: LD_ADDR_VAR 0 9
84197: PUSH
84198: LD_EXP 59
84202: PUSH
84203: LD_VAR 0 7
84207: ARRAY
84208: PPUSH
84209: LD_INT 2
84211: PUSH
84212: LD_INT 30
84214: PUSH
84215: LD_INT 0
84217: PUSH
84218: EMPTY
84219: LIST
84220: LIST
84221: PUSH
84222: LD_INT 30
84224: PUSH
84225: LD_INT 1
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: LIST
84236: PPUSH
84237: CALL_OW 72
84241: ST_TO_ADDR
// if not depot then
84242: LD_VAR 0 9
84246: NOT
84247: IFFALSE 84251
// continue ;
84249: GO 84069
// for j in depot do
84251: LD_ADDR_VAR 0 8
84255: PUSH
84256: LD_VAR 0 9
84260: PUSH
84261: FOR_IN
84262: IFFALSE 84356
// if GetDistUnitXY ( j , x , y ) < 30 then
84264: LD_VAR 0 8
84268: PPUSH
84269: LD_VAR 0 2
84273: PPUSH
84274: LD_VAR 0 3
84278: PPUSH
84279: CALL_OW 297
84283: PUSH
84284: LD_INT 30
84286: LESS
84287: IFFALSE 84354
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84289: LD_ADDR_EXP 75
84293: PUSH
84294: LD_EXP 75
84298: PPUSH
84299: LD_VAR 0 7
84303: PUSH
84304: LD_EXP 75
84308: PUSH
84309: LD_VAR 0 7
84313: ARRAY
84314: PUSH
84315: LD_INT 1
84317: PLUS
84318: PUSH
84319: EMPTY
84320: LIST
84321: LIST
84322: PPUSH
84323: LD_VAR 0 4
84327: PUSH
84328: LD_VAR 0 2
84332: PUSH
84333: LD_VAR 0 3
84337: PUSH
84338: EMPTY
84339: LIST
84340: LIST
84341: LIST
84342: PPUSH
84343: CALL 21649 0 3
84347: ST_TO_ADDR
// exit ;
84348: POP
84349: POP
84350: POP
84351: POP
84352: GO 84362
// end ;
84354: GO 84261
84356: POP
84357: POP
// end ;
84358: GO 84069
84360: POP
84361: POP
// end ;
84362: LD_VAR 0 6
84366: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84367: LD_INT 0
84369: PPUSH
84370: PPUSH
84371: PPUSH
84372: PPUSH
// if not mc_bases or not skirmish then
84373: LD_EXP 59
84377: NOT
84378: PUSH
84379: LD_EXP 57
84383: NOT
84384: OR
84385: IFFALSE 84389
// exit ;
84387: GO 84666
// side := GetSide ( lab ) ;
84389: LD_ADDR_VAR 0 4
84393: PUSH
84394: LD_VAR 0 2
84398: PPUSH
84399: CALL_OW 255
84403: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84404: LD_VAR 0 4
84408: PUSH
84409: LD_EXP 85
84413: IN
84414: NOT
84415: PUSH
84416: LD_EXP 86
84420: NOT
84421: OR
84422: PUSH
84423: LD_EXP 59
84427: NOT
84428: OR
84429: IFFALSE 84433
// exit ;
84431: GO 84666
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84433: LD_ADDR_EXP 86
84437: PUSH
84438: LD_EXP 86
84442: PPUSH
84443: LD_VAR 0 4
84447: PPUSH
84448: LD_EXP 86
84452: PUSH
84453: LD_VAR 0 4
84457: ARRAY
84458: PUSH
84459: LD_VAR 0 1
84463: DIFF
84464: PPUSH
84465: CALL_OW 1
84469: ST_TO_ADDR
// for i = 1 to mc_bases do
84470: LD_ADDR_VAR 0 5
84474: PUSH
84475: DOUBLE
84476: LD_INT 1
84478: DEC
84479: ST_TO_ADDR
84480: LD_EXP 59
84484: PUSH
84485: FOR_TO
84486: IFFALSE 84664
// begin if lab in mc_bases [ i ] then
84488: LD_VAR 0 2
84492: PUSH
84493: LD_EXP 59
84497: PUSH
84498: LD_VAR 0 5
84502: ARRAY
84503: IN
84504: IFFALSE 84662
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84506: LD_VAR 0 1
84510: PUSH
84511: LD_INT 11
84513: PUSH
84514: LD_INT 4
84516: PUSH
84517: LD_INT 3
84519: PUSH
84520: LD_INT 2
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: LIST
84527: LIST
84528: IN
84529: PUSH
84530: LD_EXP 89
84534: PUSH
84535: LD_VAR 0 5
84539: ARRAY
84540: AND
84541: IFFALSE 84662
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84543: LD_ADDR_VAR 0 6
84547: PUSH
84548: LD_EXP 89
84552: PUSH
84553: LD_VAR 0 5
84557: ARRAY
84558: PUSH
84559: LD_INT 1
84561: ARRAY
84562: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84563: LD_ADDR_EXP 89
84567: PUSH
84568: LD_EXP 89
84572: PPUSH
84573: LD_VAR 0 5
84577: PPUSH
84578: EMPTY
84579: PPUSH
84580: CALL_OW 1
84584: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84585: LD_VAR 0 6
84589: PPUSH
84590: LD_INT 0
84592: PPUSH
84593: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84597: LD_VAR 0 6
84601: PPUSH
84602: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84606: LD_ADDR_EXP 88
84610: PUSH
84611: LD_EXP 88
84615: PPUSH
84616: LD_VAR 0 5
84620: PPUSH
84621: LD_EXP 88
84625: PUSH
84626: LD_VAR 0 5
84630: ARRAY
84631: PPUSH
84632: LD_INT 1
84634: PPUSH
84635: LD_VAR 0 6
84639: PPUSH
84640: CALL_OW 2
84644: PPUSH
84645: CALL_OW 1
84649: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84650: LD_VAR 0 5
84654: PPUSH
84655: LD_INT 112
84657: PPUSH
84658: CALL 61662 0 2
// end ; end ; end ;
84662: GO 84485
84664: POP
84665: POP
// end ;
84666: LD_VAR 0 3
84670: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84671: LD_INT 0
84673: PPUSH
84674: PPUSH
84675: PPUSH
84676: PPUSH
84677: PPUSH
84678: PPUSH
84679: PPUSH
84680: PPUSH
// if not mc_bases or not skirmish then
84681: LD_EXP 59
84685: NOT
84686: PUSH
84687: LD_EXP 57
84691: NOT
84692: OR
84693: IFFALSE 84697
// exit ;
84695: GO 86068
// for i = 1 to mc_bases do
84697: LD_ADDR_VAR 0 3
84701: PUSH
84702: DOUBLE
84703: LD_INT 1
84705: DEC
84706: ST_TO_ADDR
84707: LD_EXP 59
84711: PUSH
84712: FOR_TO
84713: IFFALSE 86066
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84715: LD_VAR 0 1
84719: PUSH
84720: LD_EXP 59
84724: PUSH
84725: LD_VAR 0 3
84729: ARRAY
84730: IN
84731: PUSH
84732: LD_VAR 0 1
84736: PUSH
84737: LD_EXP 66
84741: PUSH
84742: LD_VAR 0 3
84746: ARRAY
84747: IN
84748: OR
84749: PUSH
84750: LD_VAR 0 1
84754: PUSH
84755: LD_EXP 81
84759: PUSH
84760: LD_VAR 0 3
84764: ARRAY
84765: IN
84766: OR
84767: PUSH
84768: LD_VAR 0 1
84772: PUSH
84773: LD_EXP 78
84777: PUSH
84778: LD_VAR 0 3
84782: ARRAY
84783: IN
84784: OR
84785: PUSH
84786: LD_VAR 0 1
84790: PUSH
84791: LD_EXP 88
84795: PUSH
84796: LD_VAR 0 3
84800: ARRAY
84801: IN
84802: OR
84803: PUSH
84804: LD_VAR 0 1
84808: PUSH
84809: LD_EXP 89
84813: PUSH
84814: LD_VAR 0 3
84818: ARRAY
84819: IN
84820: OR
84821: IFFALSE 86064
// begin if un in mc_ape [ i ] then
84823: LD_VAR 0 1
84827: PUSH
84828: LD_EXP 88
84832: PUSH
84833: LD_VAR 0 3
84837: ARRAY
84838: IN
84839: IFFALSE 84878
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84841: LD_ADDR_EXP 88
84845: PUSH
84846: LD_EXP 88
84850: PPUSH
84851: LD_VAR 0 3
84855: PPUSH
84856: LD_EXP 88
84860: PUSH
84861: LD_VAR 0 3
84865: ARRAY
84866: PUSH
84867: LD_VAR 0 1
84871: DIFF
84872: PPUSH
84873: CALL_OW 1
84877: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84878: LD_VAR 0 1
84882: PUSH
84883: LD_EXP 89
84887: PUSH
84888: LD_VAR 0 3
84892: ARRAY
84893: IN
84894: IFFALSE 84918
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84896: LD_ADDR_EXP 89
84900: PUSH
84901: LD_EXP 89
84905: PPUSH
84906: LD_VAR 0 3
84910: PPUSH
84911: EMPTY
84912: PPUSH
84913: CALL_OW 1
84917: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84918: LD_VAR 0 1
84922: PPUSH
84923: CALL_OW 247
84927: PUSH
84928: LD_INT 2
84930: EQUAL
84931: PUSH
84932: LD_VAR 0 1
84936: PPUSH
84937: CALL_OW 110
84941: PUSH
84942: LD_INT 20
84944: EQUAL
84945: PUSH
84946: LD_VAR 0 1
84950: PUSH
84951: LD_EXP 81
84955: PUSH
84956: LD_VAR 0 3
84960: ARRAY
84961: IN
84962: OR
84963: PUSH
84964: LD_VAR 0 1
84968: PPUSH
84969: CALL_OW 264
84973: PUSH
84974: LD_INT 12
84976: PUSH
84977: LD_INT 51
84979: PUSH
84980: LD_EXP 103
84984: PUSH
84985: LD_INT 32
84987: PUSH
84988: LD_INT 13
84990: PUSH
84991: LD_INT 52
84993: PUSH
84994: LD_INT 31
84996: PUSH
84997: EMPTY
84998: LIST
84999: LIST
85000: LIST
85001: LIST
85002: LIST
85003: LIST
85004: LIST
85005: IN
85006: OR
85007: AND
85008: IFFALSE 85316
// begin if un in mc_defender [ i ] then
85010: LD_VAR 0 1
85014: PUSH
85015: LD_EXP 81
85019: PUSH
85020: LD_VAR 0 3
85024: ARRAY
85025: IN
85026: IFFALSE 85065
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85028: LD_ADDR_EXP 81
85032: PUSH
85033: LD_EXP 81
85037: PPUSH
85038: LD_VAR 0 3
85042: PPUSH
85043: LD_EXP 81
85047: PUSH
85048: LD_VAR 0 3
85052: ARRAY
85053: PUSH
85054: LD_VAR 0 1
85058: DIFF
85059: PPUSH
85060: CALL_OW 1
85064: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
85065: LD_ADDR_VAR 0 8
85069: PUSH
85070: LD_VAR 0 3
85074: PPUSH
85075: LD_INT 3
85077: PPUSH
85078: CALL 81734 0 2
85082: ST_TO_ADDR
// if fac then
85083: LD_VAR 0 8
85087: IFFALSE 85316
// begin for j in fac do
85089: LD_ADDR_VAR 0 4
85093: PUSH
85094: LD_VAR 0 8
85098: PUSH
85099: FOR_IN
85100: IFFALSE 85314
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
85102: LD_ADDR_VAR 0 9
85106: PUSH
85107: LD_VAR 0 8
85111: PPUSH
85112: LD_VAR 0 1
85116: PPUSH
85117: CALL_OW 265
85121: PPUSH
85122: LD_VAR 0 1
85126: PPUSH
85127: CALL_OW 262
85131: PPUSH
85132: LD_VAR 0 1
85136: PPUSH
85137: CALL_OW 263
85141: PPUSH
85142: LD_VAR 0 1
85146: PPUSH
85147: CALL_OW 264
85151: PPUSH
85152: CALL 19181 0 5
85156: ST_TO_ADDR
// if components then
85157: LD_VAR 0 9
85161: IFFALSE 85312
// begin if GetWeapon ( un ) = ar_control_tower then
85163: LD_VAR 0 1
85167: PPUSH
85168: CALL_OW 264
85172: PUSH
85173: LD_INT 31
85175: EQUAL
85176: IFFALSE 85293
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
85178: LD_VAR 0 1
85182: PPUSH
85183: CALL_OW 311
85187: PPUSH
85188: LD_INT 0
85190: PPUSH
85191: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
85195: LD_ADDR_EXP 99
85199: PUSH
85200: LD_EXP 99
85204: PPUSH
85205: LD_VAR 0 3
85209: PPUSH
85210: LD_EXP 99
85214: PUSH
85215: LD_VAR 0 3
85219: ARRAY
85220: PUSH
85221: LD_VAR 0 1
85225: PPUSH
85226: CALL_OW 311
85230: DIFF
85231: PPUSH
85232: CALL_OW 1
85236: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
85237: LD_ADDR_VAR 0 7
85241: PUSH
85242: LD_EXP 80
85246: PUSH
85247: LD_VAR 0 3
85251: ARRAY
85252: PPUSH
85253: LD_INT 1
85255: PPUSH
85256: LD_VAR 0 9
85260: PPUSH
85261: CALL_OW 2
85265: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
85266: LD_ADDR_EXP 80
85270: PUSH
85271: LD_EXP 80
85275: PPUSH
85276: LD_VAR 0 3
85280: PPUSH
85281: LD_VAR 0 7
85285: PPUSH
85286: CALL_OW 1
85290: ST_TO_ADDR
// end else
85291: GO 85310
// MC_InsertProduceList ( i , [ components ] ) ;
85293: LD_VAR 0 3
85297: PPUSH
85298: LD_VAR 0 9
85302: PUSH
85303: EMPTY
85304: LIST
85305: PPUSH
85306: CALL 81279 0 2
// break ;
85310: GO 85314
// end ; end ;
85312: GO 85099
85314: POP
85315: POP
// end ; end ; if GetType ( un ) = unit_building then
85316: LD_VAR 0 1
85320: PPUSH
85321: CALL_OW 247
85325: PUSH
85326: LD_INT 3
85328: EQUAL
85329: IFFALSE 85732
// begin btype := GetBType ( un ) ;
85331: LD_ADDR_VAR 0 5
85335: PUSH
85336: LD_VAR 0 1
85340: PPUSH
85341: CALL_OW 266
85345: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85346: LD_VAR 0 5
85350: PUSH
85351: LD_INT 29
85353: PUSH
85354: LD_INT 30
85356: PUSH
85357: EMPTY
85358: LIST
85359: LIST
85360: IN
85361: IFFALSE 85434
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85363: LD_VAR 0 1
85367: PPUSH
85368: CALL_OW 250
85372: PPUSH
85373: LD_VAR 0 1
85377: PPUSH
85378: CALL_OW 251
85382: PPUSH
85383: LD_VAR 0 1
85387: PPUSH
85388: CALL_OW 255
85392: PPUSH
85393: CALL_OW 440
85397: NOT
85398: IFFALSE 85434
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85400: LD_VAR 0 1
85404: PPUSH
85405: CALL_OW 250
85409: PPUSH
85410: LD_VAR 0 1
85414: PPUSH
85415: CALL_OW 251
85419: PPUSH
85420: LD_VAR 0 1
85424: PPUSH
85425: CALL_OW 255
85429: PPUSH
85430: CALL_OW 441
// end ; if btype = b_warehouse then
85434: LD_VAR 0 5
85438: PUSH
85439: LD_INT 1
85441: EQUAL
85442: IFFALSE 85460
// begin btype := b_depot ;
85444: LD_ADDR_VAR 0 5
85448: PUSH
85449: LD_INT 0
85451: ST_TO_ADDR
// pos := 1 ;
85452: LD_ADDR_VAR 0 6
85456: PUSH
85457: LD_INT 1
85459: ST_TO_ADDR
// end ; if btype = b_factory then
85460: LD_VAR 0 5
85464: PUSH
85465: LD_INT 3
85467: EQUAL
85468: IFFALSE 85486
// begin btype := b_workshop ;
85470: LD_ADDR_VAR 0 5
85474: PUSH
85475: LD_INT 2
85477: ST_TO_ADDR
// pos := 1 ;
85478: LD_ADDR_VAR 0 6
85482: PUSH
85483: LD_INT 1
85485: ST_TO_ADDR
// end ; if btype = b_barracks then
85486: LD_VAR 0 5
85490: PUSH
85491: LD_INT 5
85493: EQUAL
85494: IFFALSE 85504
// btype := b_armoury ;
85496: LD_ADDR_VAR 0 5
85500: PUSH
85501: LD_INT 4
85503: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85504: LD_VAR 0 5
85508: PUSH
85509: LD_INT 7
85511: PUSH
85512: LD_INT 8
85514: PUSH
85515: EMPTY
85516: LIST
85517: LIST
85518: IN
85519: IFFALSE 85529
// btype := b_lab ;
85521: LD_ADDR_VAR 0 5
85525: PUSH
85526: LD_INT 6
85528: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85529: LD_ADDR_EXP 64
85533: PUSH
85534: LD_EXP 64
85538: PPUSH
85539: LD_VAR 0 3
85543: PUSH
85544: LD_EXP 64
85548: PUSH
85549: LD_VAR 0 3
85553: ARRAY
85554: PUSH
85555: LD_INT 1
85557: PLUS
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PPUSH
85563: LD_VAR 0 5
85567: PUSH
85568: LD_VAR 0 1
85572: PPUSH
85573: CALL_OW 250
85577: PUSH
85578: LD_VAR 0 1
85582: PPUSH
85583: CALL_OW 251
85587: PUSH
85588: LD_VAR 0 1
85592: PPUSH
85593: CALL_OW 254
85597: PUSH
85598: EMPTY
85599: LIST
85600: LIST
85601: LIST
85602: LIST
85603: PPUSH
85604: CALL 21649 0 3
85608: ST_TO_ADDR
// if pos = 1 then
85609: LD_VAR 0 6
85613: PUSH
85614: LD_INT 1
85616: EQUAL
85617: IFFALSE 85732
// begin tmp := mc_build_list [ i ] ;
85619: LD_ADDR_VAR 0 7
85623: PUSH
85624: LD_EXP 64
85628: PUSH
85629: LD_VAR 0 3
85633: ARRAY
85634: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85635: LD_VAR 0 7
85639: PPUSH
85640: LD_INT 2
85642: PUSH
85643: LD_INT 30
85645: PUSH
85646: LD_INT 0
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: LD_INT 30
85655: PUSH
85656: LD_INT 1
85658: PUSH
85659: EMPTY
85660: LIST
85661: LIST
85662: PUSH
85663: EMPTY
85664: LIST
85665: LIST
85666: LIST
85667: PPUSH
85668: CALL_OW 72
85672: IFFALSE 85682
// pos := 2 ;
85674: LD_ADDR_VAR 0 6
85678: PUSH
85679: LD_INT 2
85681: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85682: LD_ADDR_VAR 0 7
85686: PUSH
85687: LD_VAR 0 7
85691: PPUSH
85692: LD_VAR 0 6
85696: PPUSH
85697: LD_VAR 0 7
85701: PPUSH
85702: CALL 21975 0 3
85706: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85707: LD_ADDR_EXP 64
85711: PUSH
85712: LD_EXP 64
85716: PPUSH
85717: LD_VAR 0 3
85721: PPUSH
85722: LD_VAR 0 7
85726: PPUSH
85727: CALL_OW 1
85731: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85732: LD_VAR 0 1
85736: PUSH
85737: LD_EXP 59
85741: PUSH
85742: LD_VAR 0 3
85746: ARRAY
85747: IN
85748: IFFALSE 85787
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85750: LD_ADDR_EXP 59
85754: PUSH
85755: LD_EXP 59
85759: PPUSH
85760: LD_VAR 0 3
85764: PPUSH
85765: LD_EXP 59
85769: PUSH
85770: LD_VAR 0 3
85774: ARRAY
85775: PUSH
85776: LD_VAR 0 1
85780: DIFF
85781: PPUSH
85782: CALL_OW 1
85786: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85787: LD_VAR 0 1
85791: PUSH
85792: LD_EXP 66
85796: PUSH
85797: LD_VAR 0 3
85801: ARRAY
85802: IN
85803: IFFALSE 85842
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85805: LD_ADDR_EXP 66
85809: PUSH
85810: LD_EXP 66
85814: PPUSH
85815: LD_VAR 0 3
85819: PPUSH
85820: LD_EXP 66
85824: PUSH
85825: LD_VAR 0 3
85829: ARRAY
85830: PUSH
85831: LD_VAR 0 1
85835: DIFF
85836: PPUSH
85837: CALL_OW 1
85841: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85842: LD_VAR 0 1
85846: PUSH
85847: LD_EXP 78
85851: PUSH
85852: LD_VAR 0 3
85856: ARRAY
85857: IN
85858: IFFALSE 85897
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85860: LD_ADDR_EXP 78
85864: PUSH
85865: LD_EXP 78
85869: PPUSH
85870: LD_VAR 0 3
85874: PPUSH
85875: LD_EXP 78
85879: PUSH
85880: LD_VAR 0 3
85884: ARRAY
85885: PUSH
85886: LD_VAR 0 1
85890: DIFF
85891: PPUSH
85892: CALL_OW 1
85896: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85897: LD_VAR 0 1
85901: PUSH
85902: LD_EXP 81
85906: PUSH
85907: LD_VAR 0 3
85911: ARRAY
85912: IN
85913: IFFALSE 85952
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85915: LD_ADDR_EXP 81
85919: PUSH
85920: LD_EXP 81
85924: PPUSH
85925: LD_VAR 0 3
85929: PPUSH
85930: LD_EXP 81
85934: PUSH
85935: LD_VAR 0 3
85939: ARRAY
85940: PUSH
85941: LD_VAR 0 1
85945: DIFF
85946: PPUSH
85947: CALL_OW 1
85951: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85952: LD_VAR 0 1
85956: PUSH
85957: LD_EXP 68
85961: PUSH
85962: LD_VAR 0 3
85966: ARRAY
85967: IN
85968: IFFALSE 86007
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85970: LD_ADDR_EXP 68
85974: PUSH
85975: LD_EXP 68
85979: PPUSH
85980: LD_VAR 0 3
85984: PPUSH
85985: LD_EXP 68
85989: PUSH
85990: LD_VAR 0 3
85994: ARRAY
85995: PUSH
85996: LD_VAR 0 1
86000: DIFF
86001: PPUSH
86002: CALL_OW 1
86006: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
86007: LD_VAR 0 1
86011: PUSH
86012: LD_EXP 67
86016: PUSH
86017: LD_VAR 0 3
86021: ARRAY
86022: IN
86023: IFFALSE 86062
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
86025: LD_ADDR_EXP 67
86029: PUSH
86030: LD_EXP 67
86034: PPUSH
86035: LD_VAR 0 3
86039: PPUSH
86040: LD_EXP 67
86044: PUSH
86045: LD_VAR 0 3
86049: ARRAY
86050: PUSH
86051: LD_VAR 0 1
86055: DIFF
86056: PPUSH
86057: CALL_OW 1
86061: ST_TO_ADDR
// end ; break ;
86062: GO 86066
// end ;
86064: GO 84712
86066: POP
86067: POP
// end ;
86068: LD_VAR 0 2
86072: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
86073: LD_INT 0
86075: PPUSH
86076: PPUSH
86077: PPUSH
// if not mc_bases or not skirmish then
86078: LD_EXP 59
86082: NOT
86083: PUSH
86084: LD_EXP 57
86088: NOT
86089: OR
86090: IFFALSE 86094
// exit ;
86092: GO 86309
// for i = 1 to mc_bases do
86094: LD_ADDR_VAR 0 3
86098: PUSH
86099: DOUBLE
86100: LD_INT 1
86102: DEC
86103: ST_TO_ADDR
86104: LD_EXP 59
86108: PUSH
86109: FOR_TO
86110: IFFALSE 86307
// begin if building in mc_construct_list [ i ] then
86112: LD_VAR 0 1
86116: PUSH
86117: LD_EXP 66
86121: PUSH
86122: LD_VAR 0 3
86126: ARRAY
86127: IN
86128: IFFALSE 86305
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86130: LD_ADDR_EXP 66
86134: PUSH
86135: LD_EXP 66
86139: PPUSH
86140: LD_VAR 0 3
86144: PPUSH
86145: LD_EXP 66
86149: PUSH
86150: LD_VAR 0 3
86154: ARRAY
86155: PUSH
86156: LD_VAR 0 1
86160: DIFF
86161: PPUSH
86162: CALL_OW 1
86166: ST_TO_ADDR
// if building in mc_lab [ i ] then
86167: LD_VAR 0 1
86171: PUSH
86172: LD_EXP 92
86176: PUSH
86177: LD_VAR 0 3
86181: ARRAY
86182: IN
86183: IFFALSE 86238
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
86185: LD_ADDR_EXP 93
86189: PUSH
86190: LD_EXP 93
86194: PPUSH
86195: LD_VAR 0 3
86199: PPUSH
86200: LD_EXP 93
86204: PUSH
86205: LD_VAR 0 3
86209: ARRAY
86210: PPUSH
86211: LD_INT 1
86213: PPUSH
86214: LD_EXP 93
86218: PUSH
86219: LD_VAR 0 3
86223: ARRAY
86224: PPUSH
86225: LD_INT 0
86227: PPUSH
86228: CALL 21067 0 4
86232: PPUSH
86233: CALL_OW 1
86237: ST_TO_ADDR
// if not building in mc_bases [ i ] then
86238: LD_VAR 0 1
86242: PUSH
86243: LD_EXP 59
86247: PUSH
86248: LD_VAR 0 3
86252: ARRAY
86253: IN
86254: NOT
86255: IFFALSE 86301
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86257: LD_ADDR_EXP 59
86261: PUSH
86262: LD_EXP 59
86266: PPUSH
86267: LD_VAR 0 3
86271: PUSH
86272: LD_EXP 59
86276: PUSH
86277: LD_VAR 0 3
86281: ARRAY
86282: PUSH
86283: LD_INT 1
86285: PLUS
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PPUSH
86291: LD_VAR 0 1
86295: PPUSH
86296: CALL 21649 0 3
86300: ST_TO_ADDR
// exit ;
86301: POP
86302: POP
86303: GO 86309
// end ; end ;
86305: GO 86109
86307: POP
86308: POP
// end ;
86309: LD_VAR 0 2
86313: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86314: LD_INT 0
86316: PPUSH
86317: PPUSH
86318: PPUSH
86319: PPUSH
86320: PPUSH
86321: PPUSH
86322: PPUSH
// if not mc_bases or not skirmish then
86323: LD_EXP 59
86327: NOT
86328: PUSH
86329: LD_EXP 57
86333: NOT
86334: OR
86335: IFFALSE 86339
// exit ;
86337: GO 87000
// for i = 1 to mc_bases do
86339: LD_ADDR_VAR 0 3
86343: PUSH
86344: DOUBLE
86345: LD_INT 1
86347: DEC
86348: ST_TO_ADDR
86349: LD_EXP 59
86353: PUSH
86354: FOR_TO
86355: IFFALSE 86998
// begin if building in mc_construct_list [ i ] then
86357: LD_VAR 0 1
86361: PUSH
86362: LD_EXP 66
86366: PUSH
86367: LD_VAR 0 3
86371: ARRAY
86372: IN
86373: IFFALSE 86996
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86375: LD_ADDR_EXP 66
86379: PUSH
86380: LD_EXP 66
86384: PPUSH
86385: LD_VAR 0 3
86389: PPUSH
86390: LD_EXP 66
86394: PUSH
86395: LD_VAR 0 3
86399: ARRAY
86400: PUSH
86401: LD_VAR 0 1
86405: DIFF
86406: PPUSH
86407: CALL_OW 1
86411: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86412: LD_ADDR_EXP 59
86416: PUSH
86417: LD_EXP 59
86421: PPUSH
86422: LD_VAR 0 3
86426: PUSH
86427: LD_EXP 59
86431: PUSH
86432: LD_VAR 0 3
86436: ARRAY
86437: PUSH
86438: LD_INT 1
86440: PLUS
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PPUSH
86446: LD_VAR 0 1
86450: PPUSH
86451: CALL 21649 0 3
86455: ST_TO_ADDR
// btype := GetBType ( building ) ;
86456: LD_ADDR_VAR 0 5
86460: PUSH
86461: LD_VAR 0 1
86465: PPUSH
86466: CALL_OW 266
86470: ST_TO_ADDR
// side := GetSide ( building ) ;
86471: LD_ADDR_VAR 0 8
86475: PUSH
86476: LD_VAR 0 1
86480: PPUSH
86481: CALL_OW 255
86485: ST_TO_ADDR
// if btype = b_lab then
86486: LD_VAR 0 5
86490: PUSH
86491: LD_INT 6
86493: EQUAL
86494: IFFALSE 86544
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86496: LD_ADDR_EXP 92
86500: PUSH
86501: LD_EXP 92
86505: PPUSH
86506: LD_VAR 0 3
86510: PUSH
86511: LD_EXP 92
86515: PUSH
86516: LD_VAR 0 3
86520: ARRAY
86521: PUSH
86522: LD_INT 1
86524: PLUS
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PPUSH
86530: LD_VAR 0 1
86534: PPUSH
86535: CALL 21649 0 3
86539: ST_TO_ADDR
// exit ;
86540: POP
86541: POP
86542: GO 87000
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86544: LD_VAR 0 5
86548: PUSH
86549: LD_INT 0
86551: PUSH
86552: LD_INT 2
86554: PUSH
86555: LD_INT 4
86557: PUSH
86558: EMPTY
86559: LIST
86560: LIST
86561: LIST
86562: IN
86563: IFFALSE 86687
// begin if btype = b_armoury then
86565: LD_VAR 0 5
86569: PUSH
86570: LD_INT 4
86572: EQUAL
86573: IFFALSE 86583
// btype := b_barracks ;
86575: LD_ADDR_VAR 0 5
86579: PUSH
86580: LD_INT 5
86582: ST_TO_ADDR
// if btype = b_depot then
86583: LD_VAR 0 5
86587: PUSH
86588: LD_INT 0
86590: EQUAL
86591: IFFALSE 86601
// btype := b_warehouse ;
86593: LD_ADDR_VAR 0 5
86597: PUSH
86598: LD_INT 1
86600: ST_TO_ADDR
// if btype = b_workshop then
86601: LD_VAR 0 5
86605: PUSH
86606: LD_INT 2
86608: EQUAL
86609: IFFALSE 86619
// btype := b_factory ;
86611: LD_ADDR_VAR 0 5
86615: PUSH
86616: LD_INT 3
86618: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86619: LD_VAR 0 5
86623: PPUSH
86624: LD_VAR 0 8
86628: PPUSH
86629: CALL_OW 323
86633: PUSH
86634: LD_INT 1
86636: EQUAL
86637: IFFALSE 86683
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86639: LD_ADDR_EXP 91
86643: PUSH
86644: LD_EXP 91
86648: PPUSH
86649: LD_VAR 0 3
86653: PUSH
86654: LD_EXP 91
86658: PUSH
86659: LD_VAR 0 3
86663: ARRAY
86664: PUSH
86665: LD_INT 1
86667: PLUS
86668: PUSH
86669: EMPTY
86670: LIST
86671: LIST
86672: PPUSH
86673: LD_VAR 0 1
86677: PPUSH
86678: CALL 21649 0 3
86682: ST_TO_ADDR
// exit ;
86683: POP
86684: POP
86685: GO 87000
// end ; if btype in [ b_bunker , b_turret ] then
86687: LD_VAR 0 5
86691: PUSH
86692: LD_INT 32
86694: PUSH
86695: LD_INT 33
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: IN
86702: IFFALSE 86992
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86704: LD_ADDR_EXP 67
86708: PUSH
86709: LD_EXP 67
86713: PPUSH
86714: LD_VAR 0 3
86718: PUSH
86719: LD_EXP 67
86723: PUSH
86724: LD_VAR 0 3
86728: ARRAY
86729: PUSH
86730: LD_INT 1
86732: PLUS
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PPUSH
86738: LD_VAR 0 1
86742: PPUSH
86743: CALL 21649 0 3
86747: ST_TO_ADDR
// if btype = b_bunker then
86748: LD_VAR 0 5
86752: PUSH
86753: LD_INT 32
86755: EQUAL
86756: IFFALSE 86992
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86758: LD_ADDR_EXP 68
86762: PUSH
86763: LD_EXP 68
86767: PPUSH
86768: LD_VAR 0 3
86772: PUSH
86773: LD_EXP 68
86777: PUSH
86778: LD_VAR 0 3
86782: ARRAY
86783: PUSH
86784: LD_INT 1
86786: PLUS
86787: PUSH
86788: EMPTY
86789: LIST
86790: LIST
86791: PPUSH
86792: LD_VAR 0 1
86796: PPUSH
86797: CALL 21649 0 3
86801: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86802: LD_ADDR_VAR 0 6
86806: PUSH
86807: LD_EXP 59
86811: PUSH
86812: LD_VAR 0 3
86816: ARRAY
86817: PPUSH
86818: LD_INT 25
86820: PUSH
86821: LD_INT 1
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 3
86830: PUSH
86831: LD_INT 54
86833: PUSH
86834: EMPTY
86835: LIST
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PPUSH
86845: CALL_OW 72
86849: ST_TO_ADDR
// if tmp then
86850: LD_VAR 0 6
86854: IFFALSE 86860
// exit ;
86856: POP
86857: POP
86858: GO 87000
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86860: LD_ADDR_VAR 0 6
86864: PUSH
86865: LD_EXP 59
86869: PUSH
86870: LD_VAR 0 3
86874: ARRAY
86875: PPUSH
86876: LD_INT 2
86878: PUSH
86879: LD_INT 30
86881: PUSH
86882: LD_INT 4
86884: PUSH
86885: EMPTY
86886: LIST
86887: LIST
86888: PUSH
86889: LD_INT 30
86891: PUSH
86892: LD_INT 5
86894: PUSH
86895: EMPTY
86896: LIST
86897: LIST
86898: PUSH
86899: EMPTY
86900: LIST
86901: LIST
86902: LIST
86903: PPUSH
86904: CALL_OW 72
86908: ST_TO_ADDR
// if not tmp then
86909: LD_VAR 0 6
86913: NOT
86914: IFFALSE 86920
// exit ;
86916: POP
86917: POP
86918: GO 87000
// for j in tmp do
86920: LD_ADDR_VAR 0 4
86924: PUSH
86925: LD_VAR 0 6
86929: PUSH
86930: FOR_IN
86931: IFFALSE 86990
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86933: LD_ADDR_VAR 0 7
86937: PUSH
86938: LD_VAR 0 4
86942: PPUSH
86943: CALL_OW 313
86947: PPUSH
86948: LD_INT 25
86950: PUSH
86951: LD_INT 1
86953: PUSH
86954: EMPTY
86955: LIST
86956: LIST
86957: PPUSH
86958: CALL_OW 72
86962: ST_TO_ADDR
// if units then
86963: LD_VAR 0 7
86967: IFFALSE 86988
// begin ComExitBuilding ( units [ 1 ] ) ;
86969: LD_VAR 0 7
86973: PUSH
86974: LD_INT 1
86976: ARRAY
86977: PPUSH
86978: CALL_OW 122
// exit ;
86982: POP
86983: POP
86984: POP
86985: POP
86986: GO 87000
// end ; end ;
86988: GO 86930
86990: POP
86991: POP
// end ; end ; exit ;
86992: POP
86993: POP
86994: GO 87000
// end ; end ;
86996: GO 86354
86998: POP
86999: POP
// end ;
87000: LD_VAR 0 2
87004: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
87005: LD_INT 0
87007: PPUSH
87008: PPUSH
87009: PPUSH
87010: PPUSH
87011: PPUSH
87012: PPUSH
87013: PPUSH
// if not mc_bases or not skirmish then
87014: LD_EXP 59
87018: NOT
87019: PUSH
87020: LD_EXP 57
87024: NOT
87025: OR
87026: IFFALSE 87030
// exit ;
87028: GO 87261
// btype := GetBType ( building ) ;
87030: LD_ADDR_VAR 0 6
87034: PUSH
87035: LD_VAR 0 1
87039: PPUSH
87040: CALL_OW 266
87044: ST_TO_ADDR
// x := GetX ( building ) ;
87045: LD_ADDR_VAR 0 7
87049: PUSH
87050: LD_VAR 0 1
87054: PPUSH
87055: CALL_OW 250
87059: ST_TO_ADDR
// y := GetY ( building ) ;
87060: LD_ADDR_VAR 0 8
87064: PUSH
87065: LD_VAR 0 1
87069: PPUSH
87070: CALL_OW 251
87074: ST_TO_ADDR
// d := GetDir ( building ) ;
87075: LD_ADDR_VAR 0 9
87079: PUSH
87080: LD_VAR 0 1
87084: PPUSH
87085: CALL_OW 254
87089: ST_TO_ADDR
// for i = 1 to mc_bases do
87090: LD_ADDR_VAR 0 4
87094: PUSH
87095: DOUBLE
87096: LD_INT 1
87098: DEC
87099: ST_TO_ADDR
87100: LD_EXP 59
87104: PUSH
87105: FOR_TO
87106: IFFALSE 87259
// begin if not mc_build_list [ i ] then
87108: LD_EXP 64
87112: PUSH
87113: LD_VAR 0 4
87117: ARRAY
87118: NOT
87119: IFFALSE 87123
// continue ;
87121: GO 87105
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
87123: LD_VAR 0 6
87127: PUSH
87128: LD_VAR 0 7
87132: PUSH
87133: LD_VAR 0 8
87137: PUSH
87138: LD_VAR 0 9
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: LIST
87147: LIST
87148: PPUSH
87149: LD_EXP 64
87153: PUSH
87154: LD_VAR 0 4
87158: ARRAY
87159: PUSH
87160: LD_INT 1
87162: ARRAY
87163: PPUSH
87164: CALL 27818 0 2
87168: IFFALSE 87257
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
87170: LD_ADDR_EXP 64
87174: PUSH
87175: LD_EXP 64
87179: PPUSH
87180: LD_VAR 0 4
87184: PPUSH
87185: LD_EXP 64
87189: PUSH
87190: LD_VAR 0 4
87194: ARRAY
87195: PPUSH
87196: LD_INT 1
87198: PPUSH
87199: CALL_OW 3
87203: PPUSH
87204: CALL_OW 1
87208: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
87209: LD_ADDR_EXP 66
87213: PUSH
87214: LD_EXP 66
87218: PPUSH
87219: LD_VAR 0 4
87223: PUSH
87224: LD_EXP 66
87228: PUSH
87229: LD_VAR 0 4
87233: ARRAY
87234: PUSH
87235: LD_INT 1
87237: PLUS
87238: PUSH
87239: EMPTY
87240: LIST
87241: LIST
87242: PPUSH
87243: LD_VAR 0 1
87247: PPUSH
87248: CALL 21649 0 3
87252: ST_TO_ADDR
// exit ;
87253: POP
87254: POP
87255: GO 87261
// end ; end ;
87257: GO 87105
87259: POP
87260: POP
// end ;
87261: LD_VAR 0 3
87265: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
87266: LD_INT 0
87268: PPUSH
87269: PPUSH
87270: PPUSH
// if not mc_bases or not skirmish then
87271: LD_EXP 59
87275: NOT
87276: PUSH
87277: LD_EXP 57
87281: NOT
87282: OR
87283: IFFALSE 87287
// exit ;
87285: GO 87477
// for i = 1 to mc_bases do
87287: LD_ADDR_VAR 0 4
87291: PUSH
87292: DOUBLE
87293: LD_INT 1
87295: DEC
87296: ST_TO_ADDR
87297: LD_EXP 59
87301: PUSH
87302: FOR_TO
87303: IFFALSE 87390
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87305: LD_VAR 0 1
87309: PUSH
87310: LD_EXP 67
87314: PUSH
87315: LD_VAR 0 4
87319: ARRAY
87320: IN
87321: PUSH
87322: LD_VAR 0 1
87326: PUSH
87327: LD_EXP 68
87331: PUSH
87332: LD_VAR 0 4
87336: ARRAY
87337: IN
87338: NOT
87339: AND
87340: IFFALSE 87388
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87342: LD_ADDR_EXP 68
87346: PUSH
87347: LD_EXP 68
87351: PPUSH
87352: LD_VAR 0 4
87356: PUSH
87357: LD_EXP 68
87361: PUSH
87362: LD_VAR 0 4
87366: ARRAY
87367: PUSH
87368: LD_INT 1
87370: PLUS
87371: PUSH
87372: EMPTY
87373: LIST
87374: LIST
87375: PPUSH
87376: LD_VAR 0 1
87380: PPUSH
87381: CALL 21649 0 3
87385: ST_TO_ADDR
// break ;
87386: GO 87390
// end ; end ;
87388: GO 87302
87390: POP
87391: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87392: LD_VAR 0 1
87396: PPUSH
87397: CALL_OW 257
87401: PUSH
87402: LD_EXP 85
87406: IN
87407: PUSH
87408: LD_VAR 0 1
87412: PPUSH
87413: CALL_OW 266
87417: PUSH
87418: LD_INT 5
87420: EQUAL
87421: AND
87422: PUSH
87423: LD_VAR 0 2
87427: PPUSH
87428: CALL_OW 110
87432: PUSH
87433: LD_INT 18
87435: NONEQUAL
87436: AND
87437: IFFALSE 87477
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87439: LD_VAR 0 2
87443: PPUSH
87444: CALL_OW 257
87448: PUSH
87449: LD_INT 5
87451: PUSH
87452: LD_INT 8
87454: PUSH
87455: LD_INT 9
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: LIST
87462: IN
87463: IFFALSE 87477
// SetClass ( unit , 1 ) ;
87465: LD_VAR 0 2
87469: PPUSH
87470: LD_INT 1
87472: PPUSH
87473: CALL_OW 336
// end ;
87477: LD_VAR 0 3
87481: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87482: LD_INT 0
87484: PPUSH
87485: PPUSH
// if not mc_bases or not skirmish then
87486: LD_EXP 59
87490: NOT
87491: PUSH
87492: LD_EXP 57
87496: NOT
87497: OR
87498: IFFALSE 87502
// exit ;
87500: GO 87618
// if GetLives ( abandoned_vehicle ) > 250 then
87502: LD_VAR 0 2
87506: PPUSH
87507: CALL_OW 256
87511: PUSH
87512: LD_INT 250
87514: GREATER
87515: IFFALSE 87519
// exit ;
87517: GO 87618
// for i = 1 to mc_bases do
87519: LD_ADDR_VAR 0 6
87523: PUSH
87524: DOUBLE
87525: LD_INT 1
87527: DEC
87528: ST_TO_ADDR
87529: LD_EXP 59
87533: PUSH
87534: FOR_TO
87535: IFFALSE 87616
// begin if driver in mc_bases [ i ] then
87537: LD_VAR 0 1
87541: PUSH
87542: LD_EXP 59
87546: PUSH
87547: LD_VAR 0 6
87551: ARRAY
87552: IN
87553: IFFALSE 87614
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87555: LD_VAR 0 1
87559: PPUSH
87560: LD_EXP 59
87564: PUSH
87565: LD_VAR 0 6
87569: ARRAY
87570: PPUSH
87571: LD_INT 2
87573: PUSH
87574: LD_INT 30
87576: PUSH
87577: LD_INT 0
87579: PUSH
87580: EMPTY
87581: LIST
87582: LIST
87583: PUSH
87584: LD_INT 30
87586: PUSH
87587: LD_INT 1
87589: PUSH
87590: EMPTY
87591: LIST
87592: LIST
87593: PUSH
87594: EMPTY
87595: LIST
87596: LIST
87597: LIST
87598: PPUSH
87599: CALL_OW 72
87603: PUSH
87604: LD_INT 1
87606: ARRAY
87607: PPUSH
87608: CALL_OW 112
// break ;
87612: GO 87616
// end ; end ;
87614: GO 87534
87616: POP
87617: POP
// end ; end_of_file
87618: LD_VAR 0 5
87622: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
87623: GO 87625
87625: DISABLE
// begin ru_radar := 98 ;
87626: LD_ADDR_EXP 102
87630: PUSH
87631: LD_INT 98
87633: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87634: LD_ADDR_EXP 103
87638: PUSH
87639: LD_INT 89
87641: ST_TO_ADDR
// us_hack := 99 ;
87642: LD_ADDR_EXP 104
87646: PUSH
87647: LD_INT 99
87649: ST_TO_ADDR
// us_artillery := 97 ;
87650: LD_ADDR_EXP 105
87654: PUSH
87655: LD_INT 97
87657: ST_TO_ADDR
// ar_bio_bomb := 91 ;
87658: LD_ADDR_EXP 106
87662: PUSH
87663: LD_INT 91
87665: ST_TO_ADDR
// tech_Artillery := 80 ;
87666: LD_ADDR_EXP 107
87670: PUSH
87671: LD_INT 80
87673: ST_TO_ADDR
// tech_RadMat := 81 ;
87674: LD_ADDR_EXP 108
87678: PUSH
87679: LD_INT 81
87681: ST_TO_ADDR
// tech_BasicTools := 82 ;
87682: LD_ADDR_EXP 109
87686: PUSH
87687: LD_INT 82
87689: ST_TO_ADDR
// tech_Cargo := 83 ;
87690: LD_ADDR_EXP 110
87694: PUSH
87695: LD_INT 83
87697: ST_TO_ADDR
// tech_Track := 84 ;
87698: LD_ADDR_EXP 111
87702: PUSH
87703: LD_INT 84
87705: ST_TO_ADDR
// tech_Crane := 85 ;
87706: LD_ADDR_EXP 112
87710: PUSH
87711: LD_INT 85
87713: ST_TO_ADDR
// tech_Bulldozer := 86 ;
87714: LD_ADDR_EXP 113
87718: PUSH
87719: LD_INT 86
87721: ST_TO_ADDR
// tech_Hovercraft := 87 ;
87722: LD_ADDR_EXP 114
87726: PUSH
87727: LD_INT 87
87729: ST_TO_ADDR
// end ; end_of_file end_of_file
87730: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
87731: GO 87733
87733: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
87734: LD_STRING initStreamRollete();
87736: PPUSH
87737: CALL_OW 559
// InitStreamMode ;
87741: CALL 87750 0 0
// DefineStreamItems ( ) ;
87745: CALL 88190 0 0
// end ;
87749: END
// function InitStreamMode ; begin
87750: LD_INT 0
87752: PPUSH
// streamModeActive := false ;
87753: LD_ADDR_EXP 115
87757: PUSH
87758: LD_INT 0
87760: ST_TO_ADDR
// normalCounter := 36 ;
87761: LD_ADDR_EXP 116
87765: PUSH
87766: LD_INT 36
87768: ST_TO_ADDR
// hardcoreCounter := 16 ;
87769: LD_ADDR_EXP 117
87773: PUSH
87774: LD_INT 16
87776: ST_TO_ADDR
// sRocket := false ;
87777: LD_ADDR_EXP 120
87781: PUSH
87782: LD_INT 0
87784: ST_TO_ADDR
// sSpeed := false ;
87785: LD_ADDR_EXP 119
87789: PUSH
87790: LD_INT 0
87792: ST_TO_ADDR
// sEngine := false ;
87793: LD_ADDR_EXP 121
87797: PUSH
87798: LD_INT 0
87800: ST_TO_ADDR
// sSpec := false ;
87801: LD_ADDR_EXP 118
87805: PUSH
87806: LD_INT 0
87808: ST_TO_ADDR
// sLevel := false ;
87809: LD_ADDR_EXP 122
87813: PUSH
87814: LD_INT 0
87816: ST_TO_ADDR
// sArmoury := false ;
87817: LD_ADDR_EXP 123
87821: PUSH
87822: LD_INT 0
87824: ST_TO_ADDR
// sRadar := false ;
87825: LD_ADDR_EXP 124
87829: PUSH
87830: LD_INT 0
87832: ST_TO_ADDR
// sBunker := false ;
87833: LD_ADDR_EXP 125
87837: PUSH
87838: LD_INT 0
87840: ST_TO_ADDR
// sHack := false ;
87841: LD_ADDR_EXP 126
87845: PUSH
87846: LD_INT 0
87848: ST_TO_ADDR
// sFire := false ;
87849: LD_ADDR_EXP 127
87853: PUSH
87854: LD_INT 0
87856: ST_TO_ADDR
// sRefresh := false ;
87857: LD_ADDR_EXP 128
87861: PUSH
87862: LD_INT 0
87864: ST_TO_ADDR
// sExp := false ;
87865: LD_ADDR_EXP 129
87869: PUSH
87870: LD_INT 0
87872: ST_TO_ADDR
// sDepot := false ;
87873: LD_ADDR_EXP 130
87877: PUSH
87878: LD_INT 0
87880: ST_TO_ADDR
// sFlag := false ;
87881: LD_ADDR_EXP 131
87885: PUSH
87886: LD_INT 0
87888: ST_TO_ADDR
// sKamikadze := false ;
87889: LD_ADDR_EXP 139
87893: PUSH
87894: LD_INT 0
87896: ST_TO_ADDR
// sTroll := false ;
87897: LD_ADDR_EXP 140
87901: PUSH
87902: LD_INT 0
87904: ST_TO_ADDR
// sSlow := false ;
87905: LD_ADDR_EXP 141
87909: PUSH
87910: LD_INT 0
87912: ST_TO_ADDR
// sLack := false ;
87913: LD_ADDR_EXP 142
87917: PUSH
87918: LD_INT 0
87920: ST_TO_ADDR
// sTank := false ;
87921: LD_ADDR_EXP 144
87925: PUSH
87926: LD_INT 0
87928: ST_TO_ADDR
// sRemote := false ;
87929: LD_ADDR_EXP 145
87933: PUSH
87934: LD_INT 0
87936: ST_TO_ADDR
// sPowell := false ;
87937: LD_ADDR_EXP 146
87941: PUSH
87942: LD_INT 0
87944: ST_TO_ADDR
// sTeleport := false ;
87945: LD_ADDR_EXP 149
87949: PUSH
87950: LD_INT 0
87952: ST_TO_ADDR
// sOilTower := false ;
87953: LD_ADDR_EXP 151
87957: PUSH
87958: LD_INT 0
87960: ST_TO_ADDR
// sShovel := false ;
87961: LD_ADDR_EXP 152
87965: PUSH
87966: LD_INT 0
87968: ST_TO_ADDR
// sSheik := false ;
87969: LD_ADDR_EXP 153
87973: PUSH
87974: LD_INT 0
87976: ST_TO_ADDR
// sEarthquake := false ;
87977: LD_ADDR_EXP 155
87981: PUSH
87982: LD_INT 0
87984: ST_TO_ADDR
// sAI := false ;
87985: LD_ADDR_EXP 156
87989: PUSH
87990: LD_INT 0
87992: ST_TO_ADDR
// sCargo := false ;
87993: LD_ADDR_EXP 159
87997: PUSH
87998: LD_INT 0
88000: ST_TO_ADDR
// sDLaser := false ;
88001: LD_ADDR_EXP 160
88005: PUSH
88006: LD_INT 0
88008: ST_TO_ADDR
// sExchange := false ;
88009: LD_ADDR_EXP 161
88013: PUSH
88014: LD_INT 0
88016: ST_TO_ADDR
// sFac := false ;
88017: LD_ADDR_EXP 162
88021: PUSH
88022: LD_INT 0
88024: ST_TO_ADDR
// sPower := false ;
88025: LD_ADDR_EXP 163
88029: PUSH
88030: LD_INT 0
88032: ST_TO_ADDR
// sRandom := false ;
88033: LD_ADDR_EXP 164
88037: PUSH
88038: LD_INT 0
88040: ST_TO_ADDR
// sShield := false ;
88041: LD_ADDR_EXP 165
88045: PUSH
88046: LD_INT 0
88048: ST_TO_ADDR
// sTime := false ;
88049: LD_ADDR_EXP 166
88053: PUSH
88054: LD_INT 0
88056: ST_TO_ADDR
// sTools := false ;
88057: LD_ADDR_EXP 167
88061: PUSH
88062: LD_INT 0
88064: ST_TO_ADDR
// sSold := false ;
88065: LD_ADDR_EXP 132
88069: PUSH
88070: LD_INT 0
88072: ST_TO_ADDR
// sDiff := false ;
88073: LD_ADDR_EXP 133
88077: PUSH
88078: LD_INT 0
88080: ST_TO_ADDR
// sFog := false ;
88081: LD_ADDR_EXP 136
88085: PUSH
88086: LD_INT 0
88088: ST_TO_ADDR
// sReset := false ;
88089: LD_ADDR_EXP 137
88093: PUSH
88094: LD_INT 0
88096: ST_TO_ADDR
// sSun := false ;
88097: LD_ADDR_EXP 138
88101: PUSH
88102: LD_INT 0
88104: ST_TO_ADDR
// sTiger := false ;
88105: LD_ADDR_EXP 134
88109: PUSH
88110: LD_INT 0
88112: ST_TO_ADDR
// sBomb := false ;
88113: LD_ADDR_EXP 135
88117: PUSH
88118: LD_INT 0
88120: ST_TO_ADDR
// sWound := false ;
88121: LD_ADDR_EXP 143
88125: PUSH
88126: LD_INT 0
88128: ST_TO_ADDR
// sBetray := false ;
88129: LD_ADDR_EXP 147
88133: PUSH
88134: LD_INT 0
88136: ST_TO_ADDR
// sContamin := false ;
88137: LD_ADDR_EXP 148
88141: PUSH
88142: LD_INT 0
88144: ST_TO_ADDR
// sOil := false ;
88145: LD_ADDR_EXP 150
88149: PUSH
88150: LD_INT 0
88152: ST_TO_ADDR
// sStu := false ;
88153: LD_ADDR_EXP 154
88157: PUSH
88158: LD_INT 0
88160: ST_TO_ADDR
// sBazooka := false ;
88161: LD_ADDR_EXP 157
88165: PUSH
88166: LD_INT 0
88168: ST_TO_ADDR
// sMortar := false ;
88169: LD_ADDR_EXP 158
88173: PUSH
88174: LD_INT 0
88176: ST_TO_ADDR
// sRanger := false ;
88177: LD_ADDR_EXP 168
88181: PUSH
88182: LD_INT 0
88184: ST_TO_ADDR
// end ;
88185: LD_VAR 0 1
88189: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
88190: LD_INT 0
88192: PPUSH
88193: PPUSH
88194: PPUSH
88195: PPUSH
88196: PPUSH
// result := [ ] ;
88197: LD_ADDR_VAR 0 1
88201: PUSH
88202: EMPTY
88203: ST_TO_ADDR
// if campaign_id = 1 then
88204: LD_OWVAR 69
88208: PUSH
88209: LD_INT 1
88211: EQUAL
88212: IFFALSE 91150
// begin case mission_number of 1 :
88214: LD_OWVAR 70
88218: PUSH
88219: LD_INT 1
88221: DOUBLE
88222: EQUAL
88223: IFTRUE 88227
88225: GO 88291
88227: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
88228: LD_ADDR_VAR 0 1
88232: PUSH
88233: LD_INT 2
88235: PUSH
88236: LD_INT 4
88238: PUSH
88239: LD_INT 11
88241: PUSH
88242: LD_INT 12
88244: PUSH
88245: LD_INT 15
88247: PUSH
88248: LD_INT 16
88250: PUSH
88251: LD_INT 22
88253: PUSH
88254: LD_INT 23
88256: PUSH
88257: LD_INT 26
88259: PUSH
88260: EMPTY
88261: LIST
88262: LIST
88263: LIST
88264: LIST
88265: LIST
88266: LIST
88267: LIST
88268: LIST
88269: LIST
88270: PUSH
88271: LD_INT 101
88273: PUSH
88274: LD_INT 102
88276: PUSH
88277: LD_INT 106
88279: PUSH
88280: EMPTY
88281: LIST
88282: LIST
88283: LIST
88284: PUSH
88285: EMPTY
88286: LIST
88287: LIST
88288: ST_TO_ADDR
88289: GO 91148
88291: LD_INT 2
88293: DOUBLE
88294: EQUAL
88295: IFTRUE 88299
88297: GO 88371
88299: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
88300: LD_ADDR_VAR 0 1
88304: PUSH
88305: LD_INT 2
88307: PUSH
88308: LD_INT 4
88310: PUSH
88311: LD_INT 11
88313: PUSH
88314: LD_INT 12
88316: PUSH
88317: LD_INT 15
88319: PUSH
88320: LD_INT 16
88322: PUSH
88323: LD_INT 22
88325: PUSH
88326: LD_INT 23
88328: PUSH
88329: LD_INT 26
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: LIST
88340: LIST
88341: LIST
88342: PUSH
88343: LD_INT 101
88345: PUSH
88346: LD_INT 102
88348: PUSH
88349: LD_INT 105
88351: PUSH
88352: LD_INT 106
88354: PUSH
88355: LD_INT 108
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: PUSH
88365: EMPTY
88366: LIST
88367: LIST
88368: ST_TO_ADDR
88369: GO 91148
88371: LD_INT 3
88373: DOUBLE
88374: EQUAL
88375: IFTRUE 88379
88377: GO 88455
88379: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
88380: LD_ADDR_VAR 0 1
88384: PUSH
88385: LD_INT 2
88387: PUSH
88388: LD_INT 4
88390: PUSH
88391: LD_INT 5
88393: PUSH
88394: LD_INT 11
88396: PUSH
88397: LD_INT 12
88399: PUSH
88400: LD_INT 15
88402: PUSH
88403: LD_INT 16
88405: PUSH
88406: LD_INT 22
88408: PUSH
88409: LD_INT 26
88411: PUSH
88412: LD_INT 36
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: LIST
88419: LIST
88420: LIST
88421: LIST
88422: LIST
88423: LIST
88424: LIST
88425: LIST
88426: PUSH
88427: LD_INT 101
88429: PUSH
88430: LD_INT 102
88432: PUSH
88433: LD_INT 105
88435: PUSH
88436: LD_INT 106
88438: PUSH
88439: LD_INT 108
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: ST_TO_ADDR
88453: GO 91148
88455: LD_INT 4
88457: DOUBLE
88458: EQUAL
88459: IFTRUE 88463
88461: GO 88547
88463: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
88464: LD_ADDR_VAR 0 1
88468: PUSH
88469: LD_INT 2
88471: PUSH
88472: LD_INT 4
88474: PUSH
88475: LD_INT 5
88477: PUSH
88478: LD_INT 8
88480: PUSH
88481: LD_INT 11
88483: PUSH
88484: LD_INT 12
88486: PUSH
88487: LD_INT 15
88489: PUSH
88490: LD_INT 16
88492: PUSH
88493: LD_INT 22
88495: PUSH
88496: LD_INT 23
88498: PUSH
88499: LD_INT 26
88501: PUSH
88502: LD_INT 36
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: PUSH
88519: LD_INT 101
88521: PUSH
88522: LD_INT 102
88524: PUSH
88525: LD_INT 105
88527: PUSH
88528: LD_INT 106
88530: PUSH
88531: LD_INT 108
88533: PUSH
88534: EMPTY
88535: LIST
88536: LIST
88537: LIST
88538: LIST
88539: LIST
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: ST_TO_ADDR
88545: GO 91148
88547: LD_INT 5
88549: DOUBLE
88550: EQUAL
88551: IFTRUE 88555
88553: GO 88655
88555: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
88556: LD_ADDR_VAR 0 1
88560: PUSH
88561: LD_INT 2
88563: PUSH
88564: LD_INT 4
88566: PUSH
88567: LD_INT 5
88569: PUSH
88570: LD_INT 6
88572: PUSH
88573: LD_INT 8
88575: PUSH
88576: LD_INT 11
88578: PUSH
88579: LD_INT 12
88581: PUSH
88582: LD_INT 15
88584: PUSH
88585: LD_INT 16
88587: PUSH
88588: LD_INT 22
88590: PUSH
88591: LD_INT 23
88593: PUSH
88594: LD_INT 25
88596: PUSH
88597: LD_INT 26
88599: PUSH
88600: LD_INT 36
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: LIST
88617: LIST
88618: PUSH
88619: LD_INT 101
88621: PUSH
88622: LD_INT 102
88624: PUSH
88625: LD_INT 105
88627: PUSH
88628: LD_INT 106
88630: PUSH
88631: LD_INT 108
88633: PUSH
88634: LD_INT 109
88636: PUSH
88637: LD_INT 112
88639: PUSH
88640: EMPTY
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: PUSH
88649: EMPTY
88650: LIST
88651: LIST
88652: ST_TO_ADDR
88653: GO 91148
88655: LD_INT 6
88657: DOUBLE
88658: EQUAL
88659: IFTRUE 88663
88661: GO 88783
88663: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
88664: LD_ADDR_VAR 0 1
88668: PUSH
88669: LD_INT 2
88671: PUSH
88672: LD_INT 4
88674: PUSH
88675: LD_INT 5
88677: PUSH
88678: LD_INT 6
88680: PUSH
88681: LD_INT 8
88683: PUSH
88684: LD_INT 11
88686: PUSH
88687: LD_INT 12
88689: PUSH
88690: LD_INT 15
88692: PUSH
88693: LD_INT 16
88695: PUSH
88696: LD_INT 20
88698: PUSH
88699: LD_INT 21
88701: PUSH
88702: LD_INT 22
88704: PUSH
88705: LD_INT 23
88707: PUSH
88708: LD_INT 25
88710: PUSH
88711: LD_INT 26
88713: PUSH
88714: LD_INT 30
88716: PUSH
88717: LD_INT 31
88719: PUSH
88720: LD_INT 32
88722: PUSH
88723: LD_INT 36
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: PUSH
88747: LD_INT 101
88749: PUSH
88750: LD_INT 102
88752: PUSH
88753: LD_INT 105
88755: PUSH
88756: LD_INT 106
88758: PUSH
88759: LD_INT 108
88761: PUSH
88762: LD_INT 109
88764: PUSH
88765: LD_INT 112
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: LIST
88772: LIST
88773: LIST
88774: LIST
88775: LIST
88776: PUSH
88777: EMPTY
88778: LIST
88779: LIST
88780: ST_TO_ADDR
88781: GO 91148
88783: LD_INT 7
88785: DOUBLE
88786: EQUAL
88787: IFTRUE 88791
88789: GO 88891
88791: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
88792: LD_ADDR_VAR 0 1
88796: PUSH
88797: LD_INT 2
88799: PUSH
88800: LD_INT 4
88802: PUSH
88803: LD_INT 5
88805: PUSH
88806: LD_INT 7
88808: PUSH
88809: LD_INT 11
88811: PUSH
88812: LD_INT 12
88814: PUSH
88815: LD_INT 15
88817: PUSH
88818: LD_INT 16
88820: PUSH
88821: LD_INT 20
88823: PUSH
88824: LD_INT 21
88826: PUSH
88827: LD_INT 22
88829: PUSH
88830: LD_INT 23
88832: PUSH
88833: LD_INT 25
88835: PUSH
88836: LD_INT 26
88838: PUSH
88839: EMPTY
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: PUSH
88855: LD_INT 101
88857: PUSH
88858: LD_INT 102
88860: PUSH
88861: LD_INT 103
88863: PUSH
88864: LD_INT 105
88866: PUSH
88867: LD_INT 106
88869: PUSH
88870: LD_INT 108
88872: PUSH
88873: LD_INT 112
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: LIST
88880: LIST
88881: LIST
88882: LIST
88883: LIST
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: ST_TO_ADDR
88889: GO 91148
88891: LD_INT 8
88893: DOUBLE
88894: EQUAL
88895: IFTRUE 88899
88897: GO 89027
88899: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
88900: LD_ADDR_VAR 0 1
88904: PUSH
88905: LD_INT 2
88907: PUSH
88908: LD_INT 4
88910: PUSH
88911: LD_INT 5
88913: PUSH
88914: LD_INT 6
88916: PUSH
88917: LD_INT 7
88919: PUSH
88920: LD_INT 8
88922: PUSH
88923: LD_INT 11
88925: PUSH
88926: LD_INT 12
88928: PUSH
88929: LD_INT 15
88931: PUSH
88932: LD_INT 16
88934: PUSH
88935: LD_INT 20
88937: PUSH
88938: LD_INT 21
88940: PUSH
88941: LD_INT 22
88943: PUSH
88944: LD_INT 23
88946: PUSH
88947: LD_INT 25
88949: PUSH
88950: LD_INT 26
88952: PUSH
88953: LD_INT 30
88955: PUSH
88956: LD_INT 31
88958: PUSH
88959: LD_INT 32
88961: PUSH
88962: LD_INT 36
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: LIST
88969: LIST
88970: LIST
88971: LIST
88972: LIST
88973: LIST
88974: LIST
88975: LIST
88976: LIST
88977: LIST
88978: LIST
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: PUSH
88987: LD_INT 101
88989: PUSH
88990: LD_INT 102
88992: PUSH
88993: LD_INT 103
88995: PUSH
88996: LD_INT 105
88998: PUSH
88999: LD_INT 106
89001: PUSH
89002: LD_INT 108
89004: PUSH
89005: LD_INT 109
89007: PUSH
89008: LD_INT 112
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: ST_TO_ADDR
89025: GO 91148
89027: LD_INT 9
89029: DOUBLE
89030: EQUAL
89031: IFTRUE 89035
89033: GO 89171
89035: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
89036: LD_ADDR_VAR 0 1
89040: PUSH
89041: LD_INT 2
89043: PUSH
89044: LD_INT 4
89046: PUSH
89047: LD_INT 5
89049: PUSH
89050: LD_INT 6
89052: PUSH
89053: LD_INT 7
89055: PUSH
89056: LD_INT 8
89058: PUSH
89059: LD_INT 11
89061: PUSH
89062: LD_INT 12
89064: PUSH
89065: LD_INT 15
89067: PUSH
89068: LD_INT 16
89070: PUSH
89071: LD_INT 20
89073: PUSH
89074: LD_INT 21
89076: PUSH
89077: LD_INT 22
89079: PUSH
89080: LD_INT 23
89082: PUSH
89083: LD_INT 25
89085: PUSH
89086: LD_INT 26
89088: PUSH
89089: LD_INT 28
89091: PUSH
89092: LD_INT 30
89094: PUSH
89095: LD_INT 31
89097: PUSH
89098: LD_INT 32
89100: PUSH
89101: LD_INT 36
89103: PUSH
89104: EMPTY
89105: LIST
89106: LIST
89107: LIST
89108: LIST
89109: LIST
89110: LIST
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: PUSH
89127: LD_INT 101
89129: PUSH
89130: LD_INT 102
89132: PUSH
89133: LD_INT 103
89135: PUSH
89136: LD_INT 105
89138: PUSH
89139: LD_INT 106
89141: PUSH
89142: LD_INT 108
89144: PUSH
89145: LD_INT 109
89147: PUSH
89148: LD_INT 112
89150: PUSH
89151: LD_INT 114
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: PUSH
89165: EMPTY
89166: LIST
89167: LIST
89168: ST_TO_ADDR
89169: GO 91148
89171: LD_INT 10
89173: DOUBLE
89174: EQUAL
89175: IFTRUE 89179
89177: GO 89363
89179: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
89180: LD_ADDR_VAR 0 1
89184: PUSH
89185: LD_INT 2
89187: PUSH
89188: LD_INT 4
89190: PUSH
89191: LD_INT 5
89193: PUSH
89194: LD_INT 6
89196: PUSH
89197: LD_INT 7
89199: PUSH
89200: LD_INT 8
89202: PUSH
89203: LD_INT 9
89205: PUSH
89206: LD_INT 10
89208: PUSH
89209: LD_INT 11
89211: PUSH
89212: LD_INT 12
89214: PUSH
89215: LD_INT 13
89217: PUSH
89218: LD_INT 14
89220: PUSH
89221: LD_INT 15
89223: PUSH
89224: LD_INT 16
89226: PUSH
89227: LD_INT 17
89229: PUSH
89230: LD_INT 18
89232: PUSH
89233: LD_INT 19
89235: PUSH
89236: LD_INT 20
89238: PUSH
89239: LD_INT 21
89241: PUSH
89242: LD_INT 22
89244: PUSH
89245: LD_INT 23
89247: PUSH
89248: LD_INT 24
89250: PUSH
89251: LD_INT 25
89253: PUSH
89254: LD_INT 26
89256: PUSH
89257: LD_INT 28
89259: PUSH
89260: LD_INT 30
89262: PUSH
89263: LD_INT 31
89265: PUSH
89266: LD_INT 32
89268: PUSH
89269: LD_INT 36
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: LIST
89276: LIST
89277: LIST
89278: LIST
89279: LIST
89280: LIST
89281: LIST
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: PUSH
89303: LD_INT 101
89305: PUSH
89306: LD_INT 102
89308: PUSH
89309: LD_INT 103
89311: PUSH
89312: LD_INT 104
89314: PUSH
89315: LD_INT 105
89317: PUSH
89318: LD_INT 106
89320: PUSH
89321: LD_INT 107
89323: PUSH
89324: LD_INT 108
89326: PUSH
89327: LD_INT 109
89329: PUSH
89330: LD_INT 110
89332: PUSH
89333: LD_INT 111
89335: PUSH
89336: LD_INT 112
89338: PUSH
89339: LD_INT 114
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: ST_TO_ADDR
89361: GO 91148
89363: LD_INT 11
89365: DOUBLE
89366: EQUAL
89367: IFTRUE 89371
89369: GO 89563
89371: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
89372: LD_ADDR_VAR 0 1
89376: PUSH
89377: LD_INT 2
89379: PUSH
89380: LD_INT 3
89382: PUSH
89383: LD_INT 4
89385: PUSH
89386: LD_INT 5
89388: PUSH
89389: LD_INT 6
89391: PUSH
89392: LD_INT 7
89394: PUSH
89395: LD_INT 8
89397: PUSH
89398: LD_INT 9
89400: PUSH
89401: LD_INT 10
89403: PUSH
89404: LD_INT 11
89406: PUSH
89407: LD_INT 12
89409: PUSH
89410: LD_INT 13
89412: PUSH
89413: LD_INT 14
89415: PUSH
89416: LD_INT 15
89418: PUSH
89419: LD_INT 16
89421: PUSH
89422: LD_INT 17
89424: PUSH
89425: LD_INT 18
89427: PUSH
89428: LD_INT 19
89430: PUSH
89431: LD_INT 20
89433: PUSH
89434: LD_INT 21
89436: PUSH
89437: LD_INT 22
89439: PUSH
89440: LD_INT 23
89442: PUSH
89443: LD_INT 24
89445: PUSH
89446: LD_INT 25
89448: PUSH
89449: LD_INT 26
89451: PUSH
89452: LD_INT 28
89454: PUSH
89455: LD_INT 30
89457: PUSH
89458: LD_INT 31
89460: PUSH
89461: LD_INT 32
89463: PUSH
89464: LD_INT 34
89466: PUSH
89467: LD_INT 36
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: LIST
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: LIST
89493: LIST
89494: LIST
89495: LIST
89496: LIST
89497: LIST
89498: LIST
89499: LIST
89500: LIST
89501: LIST
89502: PUSH
89503: LD_INT 101
89505: PUSH
89506: LD_INT 102
89508: PUSH
89509: LD_INT 103
89511: PUSH
89512: LD_INT 104
89514: PUSH
89515: LD_INT 105
89517: PUSH
89518: LD_INT 106
89520: PUSH
89521: LD_INT 107
89523: PUSH
89524: LD_INT 108
89526: PUSH
89527: LD_INT 109
89529: PUSH
89530: LD_INT 110
89532: PUSH
89533: LD_INT 111
89535: PUSH
89536: LD_INT 112
89538: PUSH
89539: LD_INT 114
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: PUSH
89557: EMPTY
89558: LIST
89559: LIST
89560: ST_TO_ADDR
89561: GO 91148
89563: LD_INT 12
89565: DOUBLE
89566: EQUAL
89567: IFTRUE 89571
89569: GO 89779
89571: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
89572: LD_ADDR_VAR 0 1
89576: PUSH
89577: LD_INT 1
89579: PUSH
89580: LD_INT 2
89582: PUSH
89583: LD_INT 3
89585: PUSH
89586: LD_INT 4
89588: PUSH
89589: LD_INT 5
89591: PUSH
89592: LD_INT 6
89594: PUSH
89595: LD_INT 7
89597: PUSH
89598: LD_INT 8
89600: PUSH
89601: LD_INT 9
89603: PUSH
89604: LD_INT 10
89606: PUSH
89607: LD_INT 11
89609: PUSH
89610: LD_INT 12
89612: PUSH
89613: LD_INT 13
89615: PUSH
89616: LD_INT 14
89618: PUSH
89619: LD_INT 15
89621: PUSH
89622: LD_INT 16
89624: PUSH
89625: LD_INT 17
89627: PUSH
89628: LD_INT 18
89630: PUSH
89631: LD_INT 19
89633: PUSH
89634: LD_INT 20
89636: PUSH
89637: LD_INT 21
89639: PUSH
89640: LD_INT 22
89642: PUSH
89643: LD_INT 23
89645: PUSH
89646: LD_INT 24
89648: PUSH
89649: LD_INT 25
89651: PUSH
89652: LD_INT 26
89654: PUSH
89655: LD_INT 27
89657: PUSH
89658: LD_INT 28
89660: PUSH
89661: LD_INT 30
89663: PUSH
89664: LD_INT 31
89666: PUSH
89667: LD_INT 32
89669: PUSH
89670: LD_INT 33
89672: PUSH
89673: LD_INT 34
89675: PUSH
89676: LD_INT 36
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: LIST
89714: PUSH
89715: LD_INT 101
89717: PUSH
89718: LD_INT 102
89720: PUSH
89721: LD_INT 103
89723: PUSH
89724: LD_INT 104
89726: PUSH
89727: LD_INT 105
89729: PUSH
89730: LD_INT 106
89732: PUSH
89733: LD_INT 107
89735: PUSH
89736: LD_INT 108
89738: PUSH
89739: LD_INT 109
89741: PUSH
89742: LD_INT 110
89744: PUSH
89745: LD_INT 111
89747: PUSH
89748: LD_INT 112
89750: PUSH
89751: LD_INT 113
89753: PUSH
89754: LD_INT 114
89756: PUSH
89757: EMPTY
89758: LIST
89759: LIST
89760: LIST
89761: LIST
89762: LIST
89763: LIST
89764: LIST
89765: LIST
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: ST_TO_ADDR
89777: GO 91148
89779: LD_INT 13
89781: DOUBLE
89782: EQUAL
89783: IFTRUE 89787
89785: GO 89983
89787: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
89788: LD_ADDR_VAR 0 1
89792: PUSH
89793: LD_INT 1
89795: PUSH
89796: LD_INT 2
89798: PUSH
89799: LD_INT 3
89801: PUSH
89802: LD_INT 4
89804: PUSH
89805: LD_INT 5
89807: PUSH
89808: LD_INT 8
89810: PUSH
89811: LD_INT 9
89813: PUSH
89814: LD_INT 10
89816: PUSH
89817: LD_INT 11
89819: PUSH
89820: LD_INT 12
89822: PUSH
89823: LD_INT 14
89825: PUSH
89826: LD_INT 15
89828: PUSH
89829: LD_INT 16
89831: PUSH
89832: LD_INT 17
89834: PUSH
89835: LD_INT 18
89837: PUSH
89838: LD_INT 19
89840: PUSH
89841: LD_INT 20
89843: PUSH
89844: LD_INT 21
89846: PUSH
89847: LD_INT 22
89849: PUSH
89850: LD_INT 23
89852: PUSH
89853: LD_INT 24
89855: PUSH
89856: LD_INT 25
89858: PUSH
89859: LD_INT 26
89861: PUSH
89862: LD_INT 27
89864: PUSH
89865: LD_INT 28
89867: PUSH
89868: LD_INT 30
89870: PUSH
89871: LD_INT 31
89873: PUSH
89874: LD_INT 32
89876: PUSH
89877: LD_INT 33
89879: PUSH
89880: LD_INT 34
89882: PUSH
89883: LD_INT 36
89885: PUSH
89886: EMPTY
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: LIST
89894: LIST
89895: LIST
89896: LIST
89897: LIST
89898: LIST
89899: LIST
89900: LIST
89901: LIST
89902: LIST
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: PUSH
89919: LD_INT 101
89921: PUSH
89922: LD_INT 102
89924: PUSH
89925: LD_INT 103
89927: PUSH
89928: LD_INT 104
89930: PUSH
89931: LD_INT 105
89933: PUSH
89934: LD_INT 106
89936: PUSH
89937: LD_INT 107
89939: PUSH
89940: LD_INT 108
89942: PUSH
89943: LD_INT 109
89945: PUSH
89946: LD_INT 110
89948: PUSH
89949: LD_INT 111
89951: PUSH
89952: LD_INT 112
89954: PUSH
89955: LD_INT 113
89957: PUSH
89958: LD_INT 114
89960: PUSH
89961: EMPTY
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: ST_TO_ADDR
89981: GO 91148
89983: LD_INT 14
89985: DOUBLE
89986: EQUAL
89987: IFTRUE 89991
89989: GO 90203
89991: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
89992: LD_ADDR_VAR 0 1
89996: PUSH
89997: LD_INT 1
89999: PUSH
90000: LD_INT 2
90002: PUSH
90003: LD_INT 3
90005: PUSH
90006: LD_INT 4
90008: PUSH
90009: LD_INT 5
90011: PUSH
90012: LD_INT 6
90014: PUSH
90015: LD_INT 7
90017: PUSH
90018: LD_INT 8
90020: PUSH
90021: LD_INT 9
90023: PUSH
90024: LD_INT 10
90026: PUSH
90027: LD_INT 11
90029: PUSH
90030: LD_INT 12
90032: PUSH
90033: LD_INT 13
90035: PUSH
90036: LD_INT 14
90038: PUSH
90039: LD_INT 15
90041: PUSH
90042: LD_INT 16
90044: PUSH
90045: LD_INT 17
90047: PUSH
90048: LD_INT 18
90050: PUSH
90051: LD_INT 19
90053: PUSH
90054: LD_INT 20
90056: PUSH
90057: LD_INT 21
90059: PUSH
90060: LD_INT 22
90062: PUSH
90063: LD_INT 23
90065: PUSH
90066: LD_INT 24
90068: PUSH
90069: LD_INT 25
90071: PUSH
90072: LD_INT 26
90074: PUSH
90075: LD_INT 27
90077: PUSH
90078: LD_INT 28
90080: PUSH
90081: LD_INT 29
90083: PUSH
90084: LD_INT 30
90086: PUSH
90087: LD_INT 31
90089: PUSH
90090: LD_INT 32
90092: PUSH
90093: LD_INT 33
90095: PUSH
90096: LD_INT 34
90098: PUSH
90099: LD_INT 36
90101: PUSH
90102: EMPTY
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: LIST
90120: LIST
90121: LIST
90122: LIST
90123: LIST
90124: LIST
90125: LIST
90126: LIST
90127: LIST
90128: LIST
90129: LIST
90130: LIST
90131: LIST
90132: LIST
90133: LIST
90134: LIST
90135: LIST
90136: LIST
90137: LIST
90138: PUSH
90139: LD_INT 101
90141: PUSH
90142: LD_INT 102
90144: PUSH
90145: LD_INT 103
90147: PUSH
90148: LD_INT 104
90150: PUSH
90151: LD_INT 105
90153: PUSH
90154: LD_INT 106
90156: PUSH
90157: LD_INT 107
90159: PUSH
90160: LD_INT 108
90162: PUSH
90163: LD_INT 109
90165: PUSH
90166: LD_INT 110
90168: PUSH
90169: LD_INT 111
90171: PUSH
90172: LD_INT 112
90174: PUSH
90175: LD_INT 113
90177: PUSH
90178: LD_INT 114
90180: PUSH
90181: EMPTY
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: LIST
90194: LIST
90195: LIST
90196: PUSH
90197: EMPTY
90198: LIST
90199: LIST
90200: ST_TO_ADDR
90201: GO 91148
90203: LD_INT 15
90205: DOUBLE
90206: EQUAL
90207: IFTRUE 90211
90209: GO 90423
90211: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
90212: LD_ADDR_VAR 0 1
90216: PUSH
90217: LD_INT 1
90219: PUSH
90220: LD_INT 2
90222: PUSH
90223: LD_INT 3
90225: PUSH
90226: LD_INT 4
90228: PUSH
90229: LD_INT 5
90231: PUSH
90232: LD_INT 6
90234: PUSH
90235: LD_INT 7
90237: PUSH
90238: LD_INT 8
90240: PUSH
90241: LD_INT 9
90243: PUSH
90244: LD_INT 10
90246: PUSH
90247: LD_INT 11
90249: PUSH
90250: LD_INT 12
90252: PUSH
90253: LD_INT 13
90255: PUSH
90256: LD_INT 14
90258: PUSH
90259: LD_INT 15
90261: PUSH
90262: LD_INT 16
90264: PUSH
90265: LD_INT 17
90267: PUSH
90268: LD_INT 18
90270: PUSH
90271: LD_INT 19
90273: PUSH
90274: LD_INT 20
90276: PUSH
90277: LD_INT 21
90279: PUSH
90280: LD_INT 22
90282: PUSH
90283: LD_INT 23
90285: PUSH
90286: LD_INT 24
90288: PUSH
90289: LD_INT 25
90291: PUSH
90292: LD_INT 26
90294: PUSH
90295: LD_INT 27
90297: PUSH
90298: LD_INT 28
90300: PUSH
90301: LD_INT 29
90303: PUSH
90304: LD_INT 30
90306: PUSH
90307: LD_INT 31
90309: PUSH
90310: LD_INT 32
90312: PUSH
90313: LD_INT 33
90315: PUSH
90316: LD_INT 34
90318: PUSH
90319: LD_INT 36
90321: PUSH
90322: EMPTY
90323: LIST
90324: LIST
90325: LIST
90326: LIST
90327: LIST
90328: LIST
90329: LIST
90330: LIST
90331: LIST
90332: LIST
90333: LIST
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: LIST
90351: LIST
90352: LIST
90353: LIST
90354: LIST
90355: LIST
90356: LIST
90357: LIST
90358: PUSH
90359: LD_INT 101
90361: PUSH
90362: LD_INT 102
90364: PUSH
90365: LD_INT 103
90367: PUSH
90368: LD_INT 104
90370: PUSH
90371: LD_INT 105
90373: PUSH
90374: LD_INT 106
90376: PUSH
90377: LD_INT 107
90379: PUSH
90380: LD_INT 108
90382: PUSH
90383: LD_INT 109
90385: PUSH
90386: LD_INT 110
90388: PUSH
90389: LD_INT 111
90391: PUSH
90392: LD_INT 112
90394: PUSH
90395: LD_INT 113
90397: PUSH
90398: LD_INT 114
90400: PUSH
90401: EMPTY
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: PUSH
90417: EMPTY
90418: LIST
90419: LIST
90420: ST_TO_ADDR
90421: GO 91148
90423: LD_INT 16
90425: DOUBLE
90426: EQUAL
90427: IFTRUE 90431
90429: GO 90555
90431: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
90432: LD_ADDR_VAR 0 1
90436: PUSH
90437: LD_INT 2
90439: PUSH
90440: LD_INT 4
90442: PUSH
90443: LD_INT 5
90445: PUSH
90446: LD_INT 7
90448: PUSH
90449: LD_INT 11
90451: PUSH
90452: LD_INT 12
90454: PUSH
90455: LD_INT 15
90457: PUSH
90458: LD_INT 16
90460: PUSH
90461: LD_INT 20
90463: PUSH
90464: LD_INT 21
90466: PUSH
90467: LD_INT 22
90469: PUSH
90470: LD_INT 23
90472: PUSH
90473: LD_INT 25
90475: PUSH
90476: LD_INT 26
90478: PUSH
90479: LD_INT 30
90481: PUSH
90482: LD_INT 31
90484: PUSH
90485: LD_INT 32
90487: PUSH
90488: LD_INT 33
90490: PUSH
90491: LD_INT 34
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: LIST
90498: LIST
90499: LIST
90500: LIST
90501: LIST
90502: LIST
90503: LIST
90504: LIST
90505: LIST
90506: LIST
90507: LIST
90508: LIST
90509: LIST
90510: LIST
90511: LIST
90512: LIST
90513: LIST
90514: PUSH
90515: LD_INT 101
90517: PUSH
90518: LD_INT 102
90520: PUSH
90521: LD_INT 103
90523: PUSH
90524: LD_INT 106
90526: PUSH
90527: LD_INT 108
90529: PUSH
90530: LD_INT 112
90532: PUSH
90533: LD_INT 113
90535: PUSH
90536: LD_INT 114
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: LIST
90543: LIST
90544: LIST
90545: LIST
90546: LIST
90547: LIST
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: ST_TO_ADDR
90553: GO 91148
90555: LD_INT 17
90557: DOUBLE
90558: EQUAL
90559: IFTRUE 90563
90561: GO 90775
90563: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
90564: LD_ADDR_VAR 0 1
90568: PUSH
90569: LD_INT 1
90571: PUSH
90572: LD_INT 2
90574: PUSH
90575: LD_INT 3
90577: PUSH
90578: LD_INT 4
90580: PUSH
90581: LD_INT 5
90583: PUSH
90584: LD_INT 6
90586: PUSH
90587: LD_INT 7
90589: PUSH
90590: LD_INT 8
90592: PUSH
90593: LD_INT 9
90595: PUSH
90596: LD_INT 10
90598: PUSH
90599: LD_INT 11
90601: PUSH
90602: LD_INT 12
90604: PUSH
90605: LD_INT 13
90607: PUSH
90608: LD_INT 14
90610: PUSH
90611: LD_INT 15
90613: PUSH
90614: LD_INT 16
90616: PUSH
90617: LD_INT 17
90619: PUSH
90620: LD_INT 18
90622: PUSH
90623: LD_INT 19
90625: PUSH
90626: LD_INT 20
90628: PUSH
90629: LD_INT 21
90631: PUSH
90632: LD_INT 22
90634: PUSH
90635: LD_INT 23
90637: PUSH
90638: LD_INT 24
90640: PUSH
90641: LD_INT 25
90643: PUSH
90644: LD_INT 26
90646: PUSH
90647: LD_INT 27
90649: PUSH
90650: LD_INT 28
90652: PUSH
90653: LD_INT 29
90655: PUSH
90656: LD_INT 30
90658: PUSH
90659: LD_INT 31
90661: PUSH
90662: LD_INT 32
90664: PUSH
90665: LD_INT 33
90667: PUSH
90668: LD_INT 34
90670: PUSH
90671: LD_INT 36
90673: PUSH
90674: EMPTY
90675: LIST
90676: LIST
90677: LIST
90678: LIST
90679: LIST
90680: LIST
90681: LIST
90682: LIST
90683: LIST
90684: LIST
90685: LIST
90686: LIST
90687: LIST
90688: LIST
90689: LIST
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: LIST
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: PUSH
90711: LD_INT 101
90713: PUSH
90714: LD_INT 102
90716: PUSH
90717: LD_INT 103
90719: PUSH
90720: LD_INT 104
90722: PUSH
90723: LD_INT 105
90725: PUSH
90726: LD_INT 106
90728: PUSH
90729: LD_INT 107
90731: PUSH
90732: LD_INT 108
90734: PUSH
90735: LD_INT 109
90737: PUSH
90738: LD_INT 110
90740: PUSH
90741: LD_INT 111
90743: PUSH
90744: LD_INT 112
90746: PUSH
90747: LD_INT 113
90749: PUSH
90750: LD_INT 114
90752: PUSH
90753: EMPTY
90754: LIST
90755: LIST
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: PUSH
90769: EMPTY
90770: LIST
90771: LIST
90772: ST_TO_ADDR
90773: GO 91148
90775: LD_INT 18
90777: DOUBLE
90778: EQUAL
90779: IFTRUE 90783
90781: GO 90919
90783: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
90784: LD_ADDR_VAR 0 1
90788: PUSH
90789: LD_INT 2
90791: PUSH
90792: LD_INT 4
90794: PUSH
90795: LD_INT 5
90797: PUSH
90798: LD_INT 7
90800: PUSH
90801: LD_INT 11
90803: PUSH
90804: LD_INT 12
90806: PUSH
90807: LD_INT 15
90809: PUSH
90810: LD_INT 16
90812: PUSH
90813: LD_INT 20
90815: PUSH
90816: LD_INT 21
90818: PUSH
90819: LD_INT 22
90821: PUSH
90822: LD_INT 23
90824: PUSH
90825: LD_INT 25
90827: PUSH
90828: LD_INT 26
90830: PUSH
90831: LD_INT 30
90833: PUSH
90834: LD_INT 31
90836: PUSH
90837: LD_INT 32
90839: PUSH
90840: LD_INT 33
90842: PUSH
90843: LD_INT 34
90845: PUSH
90846: LD_INT 35
90848: PUSH
90849: LD_INT 36
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: PUSH
90875: LD_INT 101
90877: PUSH
90878: LD_INT 102
90880: PUSH
90881: LD_INT 103
90883: PUSH
90884: LD_INT 106
90886: PUSH
90887: LD_INT 108
90889: PUSH
90890: LD_INT 112
90892: PUSH
90893: LD_INT 113
90895: PUSH
90896: LD_INT 114
90898: PUSH
90899: LD_INT 115
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: LIST
90906: LIST
90907: LIST
90908: LIST
90909: LIST
90910: LIST
90911: LIST
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: ST_TO_ADDR
90917: GO 91148
90919: LD_INT 19
90921: DOUBLE
90922: EQUAL
90923: IFTRUE 90927
90925: GO 91147
90927: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
90928: LD_ADDR_VAR 0 1
90932: PUSH
90933: LD_INT 1
90935: PUSH
90936: LD_INT 2
90938: PUSH
90939: LD_INT 3
90941: PUSH
90942: LD_INT 4
90944: PUSH
90945: LD_INT 5
90947: PUSH
90948: LD_INT 6
90950: PUSH
90951: LD_INT 7
90953: PUSH
90954: LD_INT 8
90956: PUSH
90957: LD_INT 9
90959: PUSH
90960: LD_INT 10
90962: PUSH
90963: LD_INT 11
90965: PUSH
90966: LD_INT 12
90968: PUSH
90969: LD_INT 13
90971: PUSH
90972: LD_INT 14
90974: PUSH
90975: LD_INT 15
90977: PUSH
90978: LD_INT 16
90980: PUSH
90981: LD_INT 17
90983: PUSH
90984: LD_INT 18
90986: PUSH
90987: LD_INT 19
90989: PUSH
90990: LD_INT 20
90992: PUSH
90993: LD_INT 21
90995: PUSH
90996: LD_INT 22
90998: PUSH
90999: LD_INT 23
91001: PUSH
91002: LD_INT 24
91004: PUSH
91005: LD_INT 25
91007: PUSH
91008: LD_INT 26
91010: PUSH
91011: LD_INT 27
91013: PUSH
91014: LD_INT 28
91016: PUSH
91017: LD_INT 29
91019: PUSH
91020: LD_INT 30
91022: PUSH
91023: LD_INT 31
91025: PUSH
91026: LD_INT 32
91028: PUSH
91029: LD_INT 33
91031: PUSH
91032: LD_INT 34
91034: PUSH
91035: LD_INT 35
91037: PUSH
91038: LD_INT 36
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: LIST
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: LIST
91058: LIST
91059: LIST
91060: LIST
91061: LIST
91062: LIST
91063: LIST
91064: LIST
91065: LIST
91066: LIST
91067: LIST
91068: LIST
91069: LIST
91070: LIST
91071: LIST
91072: LIST
91073: LIST
91074: LIST
91075: LIST
91076: LIST
91077: LIST
91078: PUSH
91079: LD_INT 101
91081: PUSH
91082: LD_INT 102
91084: PUSH
91085: LD_INT 103
91087: PUSH
91088: LD_INT 104
91090: PUSH
91091: LD_INT 105
91093: PUSH
91094: LD_INT 106
91096: PUSH
91097: LD_INT 107
91099: PUSH
91100: LD_INT 108
91102: PUSH
91103: LD_INT 109
91105: PUSH
91106: LD_INT 110
91108: PUSH
91109: LD_INT 111
91111: PUSH
91112: LD_INT 112
91114: PUSH
91115: LD_INT 113
91117: PUSH
91118: LD_INT 114
91120: PUSH
91121: LD_INT 115
91123: PUSH
91124: EMPTY
91125: LIST
91126: LIST
91127: LIST
91128: LIST
91129: LIST
91130: LIST
91131: LIST
91132: LIST
91133: LIST
91134: LIST
91135: LIST
91136: LIST
91137: LIST
91138: LIST
91139: LIST
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: ST_TO_ADDR
91145: GO 91148
91147: POP
// end else
91148: GO 91185
// if campaign_id = 5 then
91150: LD_OWVAR 69
91154: PUSH
91155: LD_INT 5
91157: EQUAL
91158: IFFALSE 91185
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
91160: LD_ADDR_VAR 0 1
91164: PUSH
91165: LD_INT 1
91167: PUSH
91168: LD_INT 2
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: PUSH
91175: LD_INT 100
91177: PUSH
91178: EMPTY
91179: LIST
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: ST_TO_ADDR
// end ; if result then
91185: LD_VAR 0 1
91189: IFFALSE 91478
// begin normal :=  ;
91191: LD_ADDR_VAR 0 3
91195: PUSH
91196: LD_STRING 
91198: ST_TO_ADDR
// hardcore :=  ;
91199: LD_ADDR_VAR 0 4
91203: PUSH
91204: LD_STRING 
91206: ST_TO_ADDR
// for i = 1 to normalCounter do
91207: LD_ADDR_VAR 0 5
91211: PUSH
91212: DOUBLE
91213: LD_INT 1
91215: DEC
91216: ST_TO_ADDR
91217: LD_EXP 116
91221: PUSH
91222: FOR_TO
91223: IFFALSE 91324
// begin tmp := 0 ;
91225: LD_ADDR_VAR 0 2
91229: PUSH
91230: LD_STRING 0
91232: ST_TO_ADDR
// if result [ 1 ] then
91233: LD_VAR 0 1
91237: PUSH
91238: LD_INT 1
91240: ARRAY
91241: IFFALSE 91306
// if result [ 1 ] [ 1 ] = i then
91243: LD_VAR 0 1
91247: PUSH
91248: LD_INT 1
91250: ARRAY
91251: PUSH
91252: LD_INT 1
91254: ARRAY
91255: PUSH
91256: LD_VAR 0 5
91260: EQUAL
91261: IFFALSE 91306
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
91263: LD_ADDR_VAR 0 1
91267: PUSH
91268: LD_VAR 0 1
91272: PPUSH
91273: LD_INT 1
91275: PPUSH
91276: LD_VAR 0 1
91280: PUSH
91281: LD_INT 1
91283: ARRAY
91284: PPUSH
91285: LD_INT 1
91287: PPUSH
91288: CALL_OW 3
91292: PPUSH
91293: CALL_OW 1
91297: ST_TO_ADDR
// tmp := 1 ;
91298: LD_ADDR_VAR 0 2
91302: PUSH
91303: LD_STRING 1
91305: ST_TO_ADDR
// end ; normal := normal & tmp ;
91306: LD_ADDR_VAR 0 3
91310: PUSH
91311: LD_VAR 0 3
91315: PUSH
91316: LD_VAR 0 2
91320: STR
91321: ST_TO_ADDR
// end ;
91322: GO 91222
91324: POP
91325: POP
// for i = 1 to hardcoreCounter do
91326: LD_ADDR_VAR 0 5
91330: PUSH
91331: DOUBLE
91332: LD_INT 1
91334: DEC
91335: ST_TO_ADDR
91336: LD_EXP 117
91340: PUSH
91341: FOR_TO
91342: IFFALSE 91447
// begin tmp := 0 ;
91344: LD_ADDR_VAR 0 2
91348: PUSH
91349: LD_STRING 0
91351: ST_TO_ADDR
// if result [ 2 ] then
91352: LD_VAR 0 1
91356: PUSH
91357: LD_INT 2
91359: ARRAY
91360: IFFALSE 91429
// if result [ 2 ] [ 1 ] = 100 + i then
91362: LD_VAR 0 1
91366: PUSH
91367: LD_INT 2
91369: ARRAY
91370: PUSH
91371: LD_INT 1
91373: ARRAY
91374: PUSH
91375: LD_INT 100
91377: PUSH
91378: LD_VAR 0 5
91382: PLUS
91383: EQUAL
91384: IFFALSE 91429
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
91386: LD_ADDR_VAR 0 1
91390: PUSH
91391: LD_VAR 0 1
91395: PPUSH
91396: LD_INT 2
91398: PPUSH
91399: LD_VAR 0 1
91403: PUSH
91404: LD_INT 2
91406: ARRAY
91407: PPUSH
91408: LD_INT 1
91410: PPUSH
91411: CALL_OW 3
91415: PPUSH
91416: CALL_OW 1
91420: ST_TO_ADDR
// tmp := 1 ;
91421: LD_ADDR_VAR 0 2
91425: PUSH
91426: LD_STRING 1
91428: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
91429: LD_ADDR_VAR 0 4
91433: PUSH
91434: LD_VAR 0 4
91438: PUSH
91439: LD_VAR 0 2
91443: STR
91444: ST_TO_ADDR
// end ;
91445: GO 91341
91447: POP
91448: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
91449: LD_STRING getStreamItemsFromMission("
91451: PUSH
91452: LD_VAR 0 3
91456: STR
91457: PUSH
91458: LD_STRING ","
91460: STR
91461: PUSH
91462: LD_VAR 0 4
91466: STR
91467: PUSH
91468: LD_STRING ")
91470: STR
91471: PPUSH
91472: CALL_OW 559
// end else
91476: GO 91485
// ToLua ( getStreamItemsFromMission("","") ) ;
91478: LD_STRING getStreamItemsFromMission("","")
91480: PPUSH
91481: CALL_OW 559
// end ;
91485: LD_VAR 0 1
91489: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
91490: LD_VAR 0 2
91494: PUSH
91495: LD_INT 100
91497: EQUAL
91498: IFFALSE 92447
// begin if not StreamModeActive then
91500: LD_EXP 115
91504: NOT
91505: IFFALSE 91515
// StreamModeActive := true ;
91507: LD_ADDR_EXP 115
91511: PUSH
91512: LD_INT 1
91514: ST_TO_ADDR
// if p3 = 0 then
91515: LD_VAR 0 3
91519: PUSH
91520: LD_INT 0
91522: EQUAL
91523: IFFALSE 91529
// InitStreamMode ;
91525: CALL 87750 0 0
// if p3 = 1 then
91529: LD_VAR 0 3
91533: PUSH
91534: LD_INT 1
91536: EQUAL
91537: IFFALSE 91547
// sRocket := true ;
91539: LD_ADDR_EXP 120
91543: PUSH
91544: LD_INT 1
91546: ST_TO_ADDR
// if p3 = 2 then
91547: LD_VAR 0 3
91551: PUSH
91552: LD_INT 2
91554: EQUAL
91555: IFFALSE 91565
// sSpeed := true ;
91557: LD_ADDR_EXP 119
91561: PUSH
91562: LD_INT 1
91564: ST_TO_ADDR
// if p3 = 3 then
91565: LD_VAR 0 3
91569: PUSH
91570: LD_INT 3
91572: EQUAL
91573: IFFALSE 91583
// sEngine := true ;
91575: LD_ADDR_EXP 121
91579: PUSH
91580: LD_INT 1
91582: ST_TO_ADDR
// if p3 = 4 then
91583: LD_VAR 0 3
91587: PUSH
91588: LD_INT 4
91590: EQUAL
91591: IFFALSE 91601
// sSpec := true ;
91593: LD_ADDR_EXP 118
91597: PUSH
91598: LD_INT 1
91600: ST_TO_ADDR
// if p3 = 5 then
91601: LD_VAR 0 3
91605: PUSH
91606: LD_INT 5
91608: EQUAL
91609: IFFALSE 91619
// sLevel := true ;
91611: LD_ADDR_EXP 122
91615: PUSH
91616: LD_INT 1
91618: ST_TO_ADDR
// if p3 = 6 then
91619: LD_VAR 0 3
91623: PUSH
91624: LD_INT 6
91626: EQUAL
91627: IFFALSE 91637
// sArmoury := true ;
91629: LD_ADDR_EXP 123
91633: PUSH
91634: LD_INT 1
91636: ST_TO_ADDR
// if p3 = 7 then
91637: LD_VAR 0 3
91641: PUSH
91642: LD_INT 7
91644: EQUAL
91645: IFFALSE 91655
// sRadar := true ;
91647: LD_ADDR_EXP 124
91651: PUSH
91652: LD_INT 1
91654: ST_TO_ADDR
// if p3 = 8 then
91655: LD_VAR 0 3
91659: PUSH
91660: LD_INT 8
91662: EQUAL
91663: IFFALSE 91673
// sBunker := true ;
91665: LD_ADDR_EXP 125
91669: PUSH
91670: LD_INT 1
91672: ST_TO_ADDR
// if p3 = 9 then
91673: LD_VAR 0 3
91677: PUSH
91678: LD_INT 9
91680: EQUAL
91681: IFFALSE 91691
// sHack := true ;
91683: LD_ADDR_EXP 126
91687: PUSH
91688: LD_INT 1
91690: ST_TO_ADDR
// if p3 = 10 then
91691: LD_VAR 0 3
91695: PUSH
91696: LD_INT 10
91698: EQUAL
91699: IFFALSE 91709
// sFire := true ;
91701: LD_ADDR_EXP 127
91705: PUSH
91706: LD_INT 1
91708: ST_TO_ADDR
// if p3 = 11 then
91709: LD_VAR 0 3
91713: PUSH
91714: LD_INT 11
91716: EQUAL
91717: IFFALSE 91727
// sRefresh := true ;
91719: LD_ADDR_EXP 128
91723: PUSH
91724: LD_INT 1
91726: ST_TO_ADDR
// if p3 = 12 then
91727: LD_VAR 0 3
91731: PUSH
91732: LD_INT 12
91734: EQUAL
91735: IFFALSE 91745
// sExp := true ;
91737: LD_ADDR_EXP 129
91741: PUSH
91742: LD_INT 1
91744: ST_TO_ADDR
// if p3 = 13 then
91745: LD_VAR 0 3
91749: PUSH
91750: LD_INT 13
91752: EQUAL
91753: IFFALSE 91763
// sDepot := true ;
91755: LD_ADDR_EXP 130
91759: PUSH
91760: LD_INT 1
91762: ST_TO_ADDR
// if p3 = 14 then
91763: LD_VAR 0 3
91767: PUSH
91768: LD_INT 14
91770: EQUAL
91771: IFFALSE 91781
// sFlag := true ;
91773: LD_ADDR_EXP 131
91777: PUSH
91778: LD_INT 1
91780: ST_TO_ADDR
// if p3 = 15 then
91781: LD_VAR 0 3
91785: PUSH
91786: LD_INT 15
91788: EQUAL
91789: IFFALSE 91799
// sKamikadze := true ;
91791: LD_ADDR_EXP 139
91795: PUSH
91796: LD_INT 1
91798: ST_TO_ADDR
// if p3 = 16 then
91799: LD_VAR 0 3
91803: PUSH
91804: LD_INT 16
91806: EQUAL
91807: IFFALSE 91817
// sTroll := true ;
91809: LD_ADDR_EXP 140
91813: PUSH
91814: LD_INT 1
91816: ST_TO_ADDR
// if p3 = 17 then
91817: LD_VAR 0 3
91821: PUSH
91822: LD_INT 17
91824: EQUAL
91825: IFFALSE 91835
// sSlow := true ;
91827: LD_ADDR_EXP 141
91831: PUSH
91832: LD_INT 1
91834: ST_TO_ADDR
// if p3 = 18 then
91835: LD_VAR 0 3
91839: PUSH
91840: LD_INT 18
91842: EQUAL
91843: IFFALSE 91853
// sLack := true ;
91845: LD_ADDR_EXP 142
91849: PUSH
91850: LD_INT 1
91852: ST_TO_ADDR
// if p3 = 19 then
91853: LD_VAR 0 3
91857: PUSH
91858: LD_INT 19
91860: EQUAL
91861: IFFALSE 91871
// sTank := true ;
91863: LD_ADDR_EXP 144
91867: PUSH
91868: LD_INT 1
91870: ST_TO_ADDR
// if p3 = 20 then
91871: LD_VAR 0 3
91875: PUSH
91876: LD_INT 20
91878: EQUAL
91879: IFFALSE 91889
// sRemote := true ;
91881: LD_ADDR_EXP 145
91885: PUSH
91886: LD_INT 1
91888: ST_TO_ADDR
// if p3 = 21 then
91889: LD_VAR 0 3
91893: PUSH
91894: LD_INT 21
91896: EQUAL
91897: IFFALSE 91907
// sPowell := true ;
91899: LD_ADDR_EXP 146
91903: PUSH
91904: LD_INT 1
91906: ST_TO_ADDR
// if p3 = 22 then
91907: LD_VAR 0 3
91911: PUSH
91912: LD_INT 22
91914: EQUAL
91915: IFFALSE 91925
// sTeleport := true ;
91917: LD_ADDR_EXP 149
91921: PUSH
91922: LD_INT 1
91924: ST_TO_ADDR
// if p3 = 23 then
91925: LD_VAR 0 3
91929: PUSH
91930: LD_INT 23
91932: EQUAL
91933: IFFALSE 91943
// sOilTower := true ;
91935: LD_ADDR_EXP 151
91939: PUSH
91940: LD_INT 1
91942: ST_TO_ADDR
// if p3 = 24 then
91943: LD_VAR 0 3
91947: PUSH
91948: LD_INT 24
91950: EQUAL
91951: IFFALSE 91961
// sShovel := true ;
91953: LD_ADDR_EXP 152
91957: PUSH
91958: LD_INT 1
91960: ST_TO_ADDR
// if p3 = 25 then
91961: LD_VAR 0 3
91965: PUSH
91966: LD_INT 25
91968: EQUAL
91969: IFFALSE 91979
// sSheik := true ;
91971: LD_ADDR_EXP 153
91975: PUSH
91976: LD_INT 1
91978: ST_TO_ADDR
// if p3 = 26 then
91979: LD_VAR 0 3
91983: PUSH
91984: LD_INT 26
91986: EQUAL
91987: IFFALSE 91997
// sEarthquake := true ;
91989: LD_ADDR_EXP 155
91993: PUSH
91994: LD_INT 1
91996: ST_TO_ADDR
// if p3 = 27 then
91997: LD_VAR 0 3
92001: PUSH
92002: LD_INT 27
92004: EQUAL
92005: IFFALSE 92015
// sAI := true ;
92007: LD_ADDR_EXP 156
92011: PUSH
92012: LD_INT 1
92014: ST_TO_ADDR
// if p3 = 28 then
92015: LD_VAR 0 3
92019: PUSH
92020: LD_INT 28
92022: EQUAL
92023: IFFALSE 92033
// sCargo := true ;
92025: LD_ADDR_EXP 159
92029: PUSH
92030: LD_INT 1
92032: ST_TO_ADDR
// if p3 = 29 then
92033: LD_VAR 0 3
92037: PUSH
92038: LD_INT 29
92040: EQUAL
92041: IFFALSE 92051
// sDLaser := true ;
92043: LD_ADDR_EXP 160
92047: PUSH
92048: LD_INT 1
92050: ST_TO_ADDR
// if p3 = 30 then
92051: LD_VAR 0 3
92055: PUSH
92056: LD_INT 30
92058: EQUAL
92059: IFFALSE 92069
// sExchange := true ;
92061: LD_ADDR_EXP 161
92065: PUSH
92066: LD_INT 1
92068: ST_TO_ADDR
// if p3 = 31 then
92069: LD_VAR 0 3
92073: PUSH
92074: LD_INT 31
92076: EQUAL
92077: IFFALSE 92087
// sFac := true ;
92079: LD_ADDR_EXP 162
92083: PUSH
92084: LD_INT 1
92086: ST_TO_ADDR
// if p3 = 32 then
92087: LD_VAR 0 3
92091: PUSH
92092: LD_INT 32
92094: EQUAL
92095: IFFALSE 92105
// sPower := true ;
92097: LD_ADDR_EXP 163
92101: PUSH
92102: LD_INT 1
92104: ST_TO_ADDR
// if p3 = 33 then
92105: LD_VAR 0 3
92109: PUSH
92110: LD_INT 33
92112: EQUAL
92113: IFFALSE 92123
// sRandom := true ;
92115: LD_ADDR_EXP 164
92119: PUSH
92120: LD_INT 1
92122: ST_TO_ADDR
// if p3 = 34 then
92123: LD_VAR 0 3
92127: PUSH
92128: LD_INT 34
92130: EQUAL
92131: IFFALSE 92141
// sShield := true ;
92133: LD_ADDR_EXP 165
92137: PUSH
92138: LD_INT 1
92140: ST_TO_ADDR
// if p3 = 35 then
92141: LD_VAR 0 3
92145: PUSH
92146: LD_INT 35
92148: EQUAL
92149: IFFALSE 92159
// sTime := true ;
92151: LD_ADDR_EXP 166
92155: PUSH
92156: LD_INT 1
92158: ST_TO_ADDR
// if p3 = 36 then
92159: LD_VAR 0 3
92163: PUSH
92164: LD_INT 36
92166: EQUAL
92167: IFFALSE 92177
// sTools := true ;
92169: LD_ADDR_EXP 167
92173: PUSH
92174: LD_INT 1
92176: ST_TO_ADDR
// if p3 = 101 then
92177: LD_VAR 0 3
92181: PUSH
92182: LD_INT 101
92184: EQUAL
92185: IFFALSE 92195
// sSold := true ;
92187: LD_ADDR_EXP 132
92191: PUSH
92192: LD_INT 1
92194: ST_TO_ADDR
// if p3 = 102 then
92195: LD_VAR 0 3
92199: PUSH
92200: LD_INT 102
92202: EQUAL
92203: IFFALSE 92213
// sDiff := true ;
92205: LD_ADDR_EXP 133
92209: PUSH
92210: LD_INT 1
92212: ST_TO_ADDR
// if p3 = 103 then
92213: LD_VAR 0 3
92217: PUSH
92218: LD_INT 103
92220: EQUAL
92221: IFFALSE 92231
// sFog := true ;
92223: LD_ADDR_EXP 136
92227: PUSH
92228: LD_INT 1
92230: ST_TO_ADDR
// if p3 = 104 then
92231: LD_VAR 0 3
92235: PUSH
92236: LD_INT 104
92238: EQUAL
92239: IFFALSE 92249
// sReset := true ;
92241: LD_ADDR_EXP 137
92245: PUSH
92246: LD_INT 1
92248: ST_TO_ADDR
// if p3 = 105 then
92249: LD_VAR 0 3
92253: PUSH
92254: LD_INT 105
92256: EQUAL
92257: IFFALSE 92267
// sSun := true ;
92259: LD_ADDR_EXP 138
92263: PUSH
92264: LD_INT 1
92266: ST_TO_ADDR
// if p3 = 106 then
92267: LD_VAR 0 3
92271: PUSH
92272: LD_INT 106
92274: EQUAL
92275: IFFALSE 92285
// sTiger := true ;
92277: LD_ADDR_EXP 134
92281: PUSH
92282: LD_INT 1
92284: ST_TO_ADDR
// if p3 = 107 then
92285: LD_VAR 0 3
92289: PUSH
92290: LD_INT 107
92292: EQUAL
92293: IFFALSE 92303
// sBomb := true ;
92295: LD_ADDR_EXP 135
92299: PUSH
92300: LD_INT 1
92302: ST_TO_ADDR
// if p3 = 108 then
92303: LD_VAR 0 3
92307: PUSH
92308: LD_INT 108
92310: EQUAL
92311: IFFALSE 92321
// sWound := true ;
92313: LD_ADDR_EXP 143
92317: PUSH
92318: LD_INT 1
92320: ST_TO_ADDR
// if p3 = 109 then
92321: LD_VAR 0 3
92325: PUSH
92326: LD_INT 109
92328: EQUAL
92329: IFFALSE 92339
// sBetray := true ;
92331: LD_ADDR_EXP 147
92335: PUSH
92336: LD_INT 1
92338: ST_TO_ADDR
// if p3 = 110 then
92339: LD_VAR 0 3
92343: PUSH
92344: LD_INT 110
92346: EQUAL
92347: IFFALSE 92357
// sContamin := true ;
92349: LD_ADDR_EXP 148
92353: PUSH
92354: LD_INT 1
92356: ST_TO_ADDR
// if p3 = 111 then
92357: LD_VAR 0 3
92361: PUSH
92362: LD_INT 111
92364: EQUAL
92365: IFFALSE 92375
// sOil := true ;
92367: LD_ADDR_EXP 150
92371: PUSH
92372: LD_INT 1
92374: ST_TO_ADDR
// if p3 = 112 then
92375: LD_VAR 0 3
92379: PUSH
92380: LD_INT 112
92382: EQUAL
92383: IFFALSE 92393
// sStu := true ;
92385: LD_ADDR_EXP 154
92389: PUSH
92390: LD_INT 1
92392: ST_TO_ADDR
// if p3 = 113 then
92393: LD_VAR 0 3
92397: PUSH
92398: LD_INT 113
92400: EQUAL
92401: IFFALSE 92411
// sBazooka := true ;
92403: LD_ADDR_EXP 157
92407: PUSH
92408: LD_INT 1
92410: ST_TO_ADDR
// if p3 = 114 then
92411: LD_VAR 0 3
92415: PUSH
92416: LD_INT 114
92418: EQUAL
92419: IFFALSE 92429
// sMortar := true ;
92421: LD_ADDR_EXP 158
92425: PUSH
92426: LD_INT 1
92428: ST_TO_ADDR
// if p3 = 115 then
92429: LD_VAR 0 3
92433: PUSH
92434: LD_INT 115
92436: EQUAL
92437: IFFALSE 92447
// sRanger := true ;
92439: LD_ADDR_EXP 168
92443: PUSH
92444: LD_INT 1
92446: ST_TO_ADDR
// end ; end ;
92447: PPOPN 6
92449: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92450: LD_EXP 115
92454: PUSH
92455: LD_EXP 120
92459: AND
92460: IFFALSE 92584
92462: GO 92464
92464: DISABLE
92465: LD_INT 0
92467: PPUSH
92468: PPUSH
// begin enable ;
92469: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92470: LD_ADDR_VAR 0 2
92474: PUSH
92475: LD_INT 22
92477: PUSH
92478: LD_OWVAR 2
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: LD_INT 2
92489: PUSH
92490: LD_INT 34
92492: PUSH
92493: LD_INT 7
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 34
92502: PUSH
92503: LD_INT 45
92505: PUSH
92506: EMPTY
92507: LIST
92508: LIST
92509: PUSH
92510: LD_INT 34
92512: PUSH
92513: LD_INT 28
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: PUSH
92520: LD_INT 34
92522: PUSH
92523: LD_INT 47
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: PUSH
92530: EMPTY
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: LIST
92536: PUSH
92537: EMPTY
92538: LIST
92539: LIST
92540: PPUSH
92541: CALL_OW 69
92545: ST_TO_ADDR
// if not tmp then
92546: LD_VAR 0 2
92550: NOT
92551: IFFALSE 92555
// exit ;
92553: GO 92584
// for i in tmp do
92555: LD_ADDR_VAR 0 1
92559: PUSH
92560: LD_VAR 0 2
92564: PUSH
92565: FOR_IN
92566: IFFALSE 92582
// begin SetLives ( i , 0 ) ;
92568: LD_VAR 0 1
92572: PPUSH
92573: LD_INT 0
92575: PPUSH
92576: CALL_OW 234
// end ;
92580: GO 92565
92582: POP
92583: POP
// end ;
92584: PPOPN 2
92586: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
92587: LD_EXP 115
92591: PUSH
92592: LD_EXP 121
92596: AND
92597: IFFALSE 92681
92599: GO 92601
92601: DISABLE
92602: LD_INT 0
92604: PPUSH
92605: PPUSH
// begin enable ;
92606: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92607: LD_ADDR_VAR 0 2
92611: PUSH
92612: LD_INT 22
92614: PUSH
92615: LD_OWVAR 2
92619: PUSH
92620: EMPTY
92621: LIST
92622: LIST
92623: PUSH
92624: LD_INT 32
92626: PUSH
92627: LD_INT 3
92629: PUSH
92630: EMPTY
92631: LIST
92632: LIST
92633: PUSH
92634: EMPTY
92635: LIST
92636: LIST
92637: PPUSH
92638: CALL_OW 69
92642: ST_TO_ADDR
// if not tmp then
92643: LD_VAR 0 2
92647: NOT
92648: IFFALSE 92652
// exit ;
92650: GO 92681
// for i in tmp do
92652: LD_ADDR_VAR 0 1
92656: PUSH
92657: LD_VAR 0 2
92661: PUSH
92662: FOR_IN
92663: IFFALSE 92679
// begin SetLives ( i , 0 ) ;
92665: LD_VAR 0 1
92669: PPUSH
92670: LD_INT 0
92672: PPUSH
92673: CALL_OW 234
// end ;
92677: GO 92662
92679: POP
92680: POP
// end ;
92681: PPOPN 2
92683: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
92684: LD_EXP 115
92688: PUSH
92689: LD_EXP 118
92693: AND
92694: IFFALSE 92787
92696: GO 92698
92698: DISABLE
92699: LD_INT 0
92701: PPUSH
// begin enable ;
92702: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92703: LD_ADDR_VAR 0 1
92707: PUSH
92708: LD_INT 22
92710: PUSH
92711: LD_OWVAR 2
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: LD_INT 2
92722: PUSH
92723: LD_INT 25
92725: PUSH
92726: LD_INT 5
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PUSH
92733: LD_INT 25
92735: PUSH
92736: LD_INT 9
92738: PUSH
92739: EMPTY
92740: LIST
92741: LIST
92742: PUSH
92743: LD_INT 25
92745: PUSH
92746: LD_INT 8
92748: PUSH
92749: EMPTY
92750: LIST
92751: LIST
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: LIST
92757: LIST
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: PPUSH
92763: CALL_OW 69
92767: PUSH
92768: FOR_IN
92769: IFFALSE 92785
// begin SetClass ( i , 1 ) ;
92771: LD_VAR 0 1
92775: PPUSH
92776: LD_INT 1
92778: PPUSH
92779: CALL_OW 336
// end ;
92783: GO 92768
92785: POP
92786: POP
// end ;
92787: PPOPN 1
92789: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92790: LD_EXP 115
92794: PUSH
92795: LD_EXP 119
92799: AND
92800: PUSH
92801: LD_OWVAR 65
92805: PUSH
92806: LD_INT 7
92808: LESS
92809: AND
92810: IFFALSE 92824
92812: GO 92814
92814: DISABLE
// begin enable ;
92815: ENABLE
// game_speed := 7 ;
92816: LD_ADDR_OWVAR 65
92820: PUSH
92821: LD_INT 7
92823: ST_TO_ADDR
// end ;
92824: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92825: LD_EXP 115
92829: PUSH
92830: LD_EXP 122
92834: AND
92835: IFFALSE 93037
92837: GO 92839
92839: DISABLE
92840: LD_INT 0
92842: PPUSH
92843: PPUSH
92844: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92845: LD_ADDR_VAR 0 3
92849: PUSH
92850: LD_INT 81
92852: PUSH
92853: LD_OWVAR 2
92857: PUSH
92858: EMPTY
92859: LIST
92860: LIST
92861: PUSH
92862: LD_INT 21
92864: PUSH
92865: LD_INT 1
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: PUSH
92872: EMPTY
92873: LIST
92874: LIST
92875: PPUSH
92876: CALL_OW 69
92880: ST_TO_ADDR
// if not tmp then
92881: LD_VAR 0 3
92885: NOT
92886: IFFALSE 92890
// exit ;
92888: GO 93037
// if tmp > 5 then
92890: LD_VAR 0 3
92894: PUSH
92895: LD_INT 5
92897: GREATER
92898: IFFALSE 92910
// k := 5 else
92900: LD_ADDR_VAR 0 2
92904: PUSH
92905: LD_INT 5
92907: ST_TO_ADDR
92908: GO 92920
// k := tmp ;
92910: LD_ADDR_VAR 0 2
92914: PUSH
92915: LD_VAR 0 3
92919: ST_TO_ADDR
// for i := 1 to k do
92920: LD_ADDR_VAR 0 1
92924: PUSH
92925: DOUBLE
92926: LD_INT 1
92928: DEC
92929: ST_TO_ADDR
92930: LD_VAR 0 2
92934: PUSH
92935: FOR_TO
92936: IFFALSE 93035
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92938: LD_VAR 0 3
92942: PUSH
92943: LD_VAR 0 1
92947: ARRAY
92948: PPUSH
92949: LD_VAR 0 1
92953: PUSH
92954: LD_INT 4
92956: MOD
92957: PUSH
92958: LD_INT 1
92960: PLUS
92961: PPUSH
92962: CALL_OW 259
92966: PUSH
92967: LD_INT 10
92969: LESS
92970: IFFALSE 93033
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92972: LD_VAR 0 3
92976: PUSH
92977: LD_VAR 0 1
92981: ARRAY
92982: PPUSH
92983: LD_VAR 0 1
92987: PUSH
92988: LD_INT 4
92990: MOD
92991: PUSH
92992: LD_INT 1
92994: PLUS
92995: PPUSH
92996: LD_VAR 0 3
93000: PUSH
93001: LD_VAR 0 1
93005: ARRAY
93006: PPUSH
93007: LD_VAR 0 1
93011: PUSH
93012: LD_INT 4
93014: MOD
93015: PUSH
93016: LD_INT 1
93018: PLUS
93019: PPUSH
93020: CALL_OW 259
93024: PUSH
93025: LD_INT 1
93027: PLUS
93028: PPUSH
93029: CALL_OW 237
93033: GO 92935
93035: POP
93036: POP
// end ;
93037: PPOPN 3
93039: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
93040: LD_EXP 115
93044: PUSH
93045: LD_EXP 123
93049: AND
93050: IFFALSE 93070
93052: GO 93054
93054: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
93055: LD_INT 4
93057: PPUSH
93058: LD_OWVAR 2
93062: PPUSH
93063: LD_INT 0
93065: PPUSH
93066: CALL_OW 324
93070: END
// every 0 0$1 trigger StreamModeActive and sShovel do
93071: LD_EXP 115
93075: PUSH
93076: LD_EXP 152
93080: AND
93081: IFFALSE 93101
93083: GO 93085
93085: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
93086: LD_INT 19
93088: PPUSH
93089: LD_OWVAR 2
93093: PPUSH
93094: LD_INT 0
93096: PPUSH
93097: CALL_OW 324
93101: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
93102: LD_EXP 115
93106: PUSH
93107: LD_EXP 124
93111: AND
93112: IFFALSE 93214
93114: GO 93116
93116: DISABLE
93117: LD_INT 0
93119: PPUSH
93120: PPUSH
// begin enable ;
93121: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
93122: LD_ADDR_VAR 0 2
93126: PUSH
93127: LD_INT 22
93129: PUSH
93130: LD_OWVAR 2
93134: PUSH
93135: EMPTY
93136: LIST
93137: LIST
93138: PUSH
93139: LD_INT 2
93141: PUSH
93142: LD_INT 34
93144: PUSH
93145: LD_INT 11
93147: PUSH
93148: EMPTY
93149: LIST
93150: LIST
93151: PUSH
93152: LD_INT 34
93154: PUSH
93155: LD_INT 30
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: LIST
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PPUSH
93171: CALL_OW 69
93175: ST_TO_ADDR
// if not tmp then
93176: LD_VAR 0 2
93180: NOT
93181: IFFALSE 93185
// exit ;
93183: GO 93214
// for i in tmp do
93185: LD_ADDR_VAR 0 1
93189: PUSH
93190: LD_VAR 0 2
93194: PUSH
93195: FOR_IN
93196: IFFALSE 93212
// begin SetLives ( i , 0 ) ;
93198: LD_VAR 0 1
93202: PPUSH
93203: LD_INT 0
93205: PPUSH
93206: CALL_OW 234
// end ;
93210: GO 93195
93212: POP
93213: POP
// end ;
93214: PPOPN 2
93216: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93217: LD_EXP 115
93221: PUSH
93222: LD_EXP 125
93226: AND
93227: IFFALSE 93247
93229: GO 93231
93231: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93232: LD_INT 32
93234: PPUSH
93235: LD_OWVAR 2
93239: PPUSH
93240: LD_INT 0
93242: PPUSH
93243: CALL_OW 324
93247: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93248: LD_EXP 115
93252: PUSH
93253: LD_EXP 126
93257: AND
93258: IFFALSE 93439
93260: GO 93262
93262: DISABLE
93263: LD_INT 0
93265: PPUSH
93266: PPUSH
93267: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93268: LD_ADDR_VAR 0 2
93272: PUSH
93273: LD_INT 22
93275: PUSH
93276: LD_OWVAR 2
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: PUSH
93285: LD_INT 33
93287: PUSH
93288: LD_INT 3
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: EMPTY
93296: LIST
93297: LIST
93298: PPUSH
93299: CALL_OW 69
93303: ST_TO_ADDR
// if not tmp then
93304: LD_VAR 0 2
93308: NOT
93309: IFFALSE 93313
// exit ;
93311: GO 93439
// side := 0 ;
93313: LD_ADDR_VAR 0 3
93317: PUSH
93318: LD_INT 0
93320: ST_TO_ADDR
// for i := 1 to 8 do
93321: LD_ADDR_VAR 0 1
93325: PUSH
93326: DOUBLE
93327: LD_INT 1
93329: DEC
93330: ST_TO_ADDR
93331: LD_INT 8
93333: PUSH
93334: FOR_TO
93335: IFFALSE 93383
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93337: LD_OWVAR 2
93341: PUSH
93342: LD_VAR 0 1
93346: NONEQUAL
93347: PUSH
93348: LD_OWVAR 2
93352: PPUSH
93353: LD_VAR 0 1
93357: PPUSH
93358: CALL_OW 81
93362: PUSH
93363: LD_INT 2
93365: EQUAL
93366: AND
93367: IFFALSE 93381
// begin side := i ;
93369: LD_ADDR_VAR 0 3
93373: PUSH
93374: LD_VAR 0 1
93378: ST_TO_ADDR
// break ;
93379: GO 93383
// end ;
93381: GO 93334
93383: POP
93384: POP
// if not side then
93385: LD_VAR 0 3
93389: NOT
93390: IFFALSE 93394
// exit ;
93392: GO 93439
// for i := 1 to tmp do
93394: LD_ADDR_VAR 0 1
93398: PUSH
93399: DOUBLE
93400: LD_INT 1
93402: DEC
93403: ST_TO_ADDR
93404: LD_VAR 0 2
93408: PUSH
93409: FOR_TO
93410: IFFALSE 93437
// if Prob ( 60 ) then
93412: LD_INT 60
93414: PPUSH
93415: CALL_OW 13
93419: IFFALSE 93435
// SetSide ( i , side ) ;
93421: LD_VAR 0 1
93425: PPUSH
93426: LD_VAR 0 3
93430: PPUSH
93431: CALL_OW 235
93435: GO 93409
93437: POP
93438: POP
// end ;
93439: PPOPN 3
93441: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93442: LD_EXP 115
93446: PUSH
93447: LD_EXP 128
93451: AND
93452: IFFALSE 93571
93454: GO 93456
93456: DISABLE
93457: LD_INT 0
93459: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93460: LD_ADDR_VAR 0 1
93464: PUSH
93465: LD_INT 22
93467: PUSH
93468: LD_OWVAR 2
93472: PUSH
93473: EMPTY
93474: LIST
93475: LIST
93476: PUSH
93477: LD_INT 21
93479: PUSH
93480: LD_INT 1
93482: PUSH
93483: EMPTY
93484: LIST
93485: LIST
93486: PUSH
93487: LD_INT 3
93489: PUSH
93490: LD_INT 23
93492: PUSH
93493: LD_INT 0
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: EMPTY
93501: LIST
93502: LIST
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: LIST
93508: PPUSH
93509: CALL_OW 69
93513: PUSH
93514: FOR_IN
93515: IFFALSE 93569
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
93517: LD_VAR 0 1
93521: PPUSH
93522: CALL_OW 257
93526: PUSH
93527: LD_INT 1
93529: PUSH
93530: LD_INT 2
93532: PUSH
93533: LD_INT 3
93535: PUSH
93536: LD_INT 4
93538: PUSH
93539: EMPTY
93540: LIST
93541: LIST
93542: LIST
93543: LIST
93544: IN
93545: IFFALSE 93567
// SetClass ( un , rand ( 1 , 4 ) ) ;
93547: LD_VAR 0 1
93551: PPUSH
93552: LD_INT 1
93554: PPUSH
93555: LD_INT 4
93557: PPUSH
93558: CALL_OW 12
93562: PPUSH
93563: CALL_OW 336
93567: GO 93514
93569: POP
93570: POP
// end ;
93571: PPOPN 1
93573: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
93574: LD_EXP 115
93578: PUSH
93579: LD_EXP 127
93583: AND
93584: IFFALSE 93663
93586: GO 93588
93588: DISABLE
93589: LD_INT 0
93591: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93592: LD_ADDR_VAR 0 1
93596: PUSH
93597: LD_INT 22
93599: PUSH
93600: LD_OWVAR 2
93604: PUSH
93605: EMPTY
93606: LIST
93607: LIST
93608: PUSH
93609: LD_INT 21
93611: PUSH
93612: LD_INT 3
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: PPUSH
93623: CALL_OW 69
93627: ST_TO_ADDR
// if not tmp then
93628: LD_VAR 0 1
93632: NOT
93633: IFFALSE 93637
// exit ;
93635: GO 93663
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93637: LD_VAR 0 1
93641: PUSH
93642: LD_INT 1
93644: PPUSH
93645: LD_VAR 0 1
93649: PPUSH
93650: CALL_OW 12
93654: ARRAY
93655: PPUSH
93656: LD_INT 100
93658: PPUSH
93659: CALL_OW 234
// end ;
93663: PPOPN 1
93665: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93666: LD_EXP 115
93670: PUSH
93671: LD_EXP 129
93675: AND
93676: IFFALSE 93774
93678: GO 93680
93680: DISABLE
93681: LD_INT 0
93683: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93684: LD_ADDR_VAR 0 1
93688: PUSH
93689: LD_INT 22
93691: PUSH
93692: LD_OWVAR 2
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: PUSH
93701: LD_INT 21
93703: PUSH
93704: LD_INT 1
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PPUSH
93715: CALL_OW 69
93719: ST_TO_ADDR
// if not tmp then
93720: LD_VAR 0 1
93724: NOT
93725: IFFALSE 93729
// exit ;
93727: GO 93774
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93729: LD_VAR 0 1
93733: PUSH
93734: LD_INT 1
93736: PPUSH
93737: LD_VAR 0 1
93741: PPUSH
93742: CALL_OW 12
93746: ARRAY
93747: PPUSH
93748: LD_INT 1
93750: PPUSH
93751: LD_INT 4
93753: PPUSH
93754: CALL_OW 12
93758: PPUSH
93759: LD_INT 3000
93761: PPUSH
93762: LD_INT 9000
93764: PPUSH
93765: CALL_OW 12
93769: PPUSH
93770: CALL_OW 492
// end ;
93774: PPOPN 1
93776: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93777: LD_EXP 115
93781: PUSH
93782: LD_EXP 130
93786: AND
93787: IFFALSE 93807
93789: GO 93791
93791: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93792: LD_INT 1
93794: PPUSH
93795: LD_OWVAR 2
93799: PPUSH
93800: LD_INT 0
93802: PPUSH
93803: CALL_OW 324
93807: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93808: LD_EXP 115
93812: PUSH
93813: LD_EXP 131
93817: AND
93818: IFFALSE 93901
93820: GO 93822
93822: DISABLE
93823: LD_INT 0
93825: PPUSH
93826: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93827: LD_ADDR_VAR 0 2
93831: PUSH
93832: LD_INT 22
93834: PUSH
93835: LD_OWVAR 2
93839: PUSH
93840: EMPTY
93841: LIST
93842: LIST
93843: PUSH
93844: LD_INT 21
93846: PUSH
93847: LD_INT 3
93849: PUSH
93850: EMPTY
93851: LIST
93852: LIST
93853: PUSH
93854: EMPTY
93855: LIST
93856: LIST
93857: PPUSH
93858: CALL_OW 69
93862: ST_TO_ADDR
// if not tmp then
93863: LD_VAR 0 2
93867: NOT
93868: IFFALSE 93872
// exit ;
93870: GO 93901
// for i in tmp do
93872: LD_ADDR_VAR 0 1
93876: PUSH
93877: LD_VAR 0 2
93881: PUSH
93882: FOR_IN
93883: IFFALSE 93899
// SetBLevel ( i , 10 ) ;
93885: LD_VAR 0 1
93889: PPUSH
93890: LD_INT 10
93892: PPUSH
93893: CALL_OW 241
93897: GO 93882
93899: POP
93900: POP
// end ;
93901: PPOPN 2
93903: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93904: LD_EXP 115
93908: PUSH
93909: LD_EXP 132
93913: AND
93914: IFFALSE 94025
93916: GO 93918
93918: DISABLE
93919: LD_INT 0
93921: PPUSH
93922: PPUSH
93923: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93924: LD_ADDR_VAR 0 3
93928: PUSH
93929: LD_INT 22
93931: PUSH
93932: LD_OWVAR 2
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: LD_INT 25
93943: PUSH
93944: LD_INT 1
93946: PUSH
93947: EMPTY
93948: LIST
93949: LIST
93950: PUSH
93951: EMPTY
93952: LIST
93953: LIST
93954: PPUSH
93955: CALL_OW 69
93959: ST_TO_ADDR
// if not tmp then
93960: LD_VAR 0 3
93964: NOT
93965: IFFALSE 93969
// exit ;
93967: GO 94025
// un := tmp [ rand ( 1 , tmp ) ] ;
93969: LD_ADDR_VAR 0 2
93973: PUSH
93974: LD_VAR 0 3
93978: PUSH
93979: LD_INT 1
93981: PPUSH
93982: LD_VAR 0 3
93986: PPUSH
93987: CALL_OW 12
93991: ARRAY
93992: ST_TO_ADDR
// if Crawls ( un ) then
93993: LD_VAR 0 2
93997: PPUSH
93998: CALL_OW 318
94002: IFFALSE 94013
// ComWalk ( un ) ;
94004: LD_VAR 0 2
94008: PPUSH
94009: CALL_OW 138
// SetClass ( un , class_sniper ) ;
94013: LD_VAR 0 2
94017: PPUSH
94018: LD_INT 5
94020: PPUSH
94021: CALL_OW 336
// end ;
94025: PPOPN 3
94027: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
94028: LD_EXP 115
94032: PUSH
94033: LD_EXP 133
94037: AND
94038: PUSH
94039: LD_OWVAR 67
94043: PUSH
94044: LD_INT 3
94046: LESS
94047: AND
94048: IFFALSE 94067
94050: GO 94052
94052: DISABLE
// Difficulty := Difficulty + 1 ;
94053: LD_ADDR_OWVAR 67
94057: PUSH
94058: LD_OWVAR 67
94062: PUSH
94063: LD_INT 1
94065: PLUS
94066: ST_TO_ADDR
94067: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
94068: LD_EXP 115
94072: PUSH
94073: LD_EXP 134
94077: AND
94078: IFFALSE 94181
94080: GO 94082
94082: DISABLE
94083: LD_INT 0
94085: PPUSH
// begin for i := 1 to 5 do
94086: LD_ADDR_VAR 0 1
94090: PUSH
94091: DOUBLE
94092: LD_INT 1
94094: DEC
94095: ST_TO_ADDR
94096: LD_INT 5
94098: PUSH
94099: FOR_TO
94100: IFFALSE 94179
// begin uc_nation := nation_nature ;
94102: LD_ADDR_OWVAR 21
94106: PUSH
94107: LD_INT 0
94109: ST_TO_ADDR
// uc_side := 0 ;
94110: LD_ADDR_OWVAR 20
94114: PUSH
94115: LD_INT 0
94117: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94118: LD_ADDR_OWVAR 29
94122: PUSH
94123: LD_INT 12
94125: PUSH
94126: LD_INT 12
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: ST_TO_ADDR
// hc_agressivity := 20 ;
94133: LD_ADDR_OWVAR 35
94137: PUSH
94138: LD_INT 20
94140: ST_TO_ADDR
// hc_class := class_tiger ;
94141: LD_ADDR_OWVAR 28
94145: PUSH
94146: LD_INT 14
94148: ST_TO_ADDR
// hc_gallery :=  ;
94149: LD_ADDR_OWVAR 33
94153: PUSH
94154: LD_STRING 
94156: ST_TO_ADDR
// hc_name :=  ;
94157: LD_ADDR_OWVAR 26
94161: PUSH
94162: LD_STRING 
94164: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94165: CALL_OW 44
94169: PPUSH
94170: LD_INT 0
94172: PPUSH
94173: CALL_OW 51
// end ;
94177: GO 94099
94179: POP
94180: POP
// end ;
94181: PPOPN 1
94183: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94184: LD_EXP 115
94188: PUSH
94189: LD_EXP 135
94193: AND
94194: IFFALSE 94203
94196: GO 94198
94198: DISABLE
// StreamSibBomb ;
94199: CALL 94204 0 0
94203: END
// export function StreamSibBomb ; var i , x , y ; begin
94204: LD_INT 0
94206: PPUSH
94207: PPUSH
94208: PPUSH
94209: PPUSH
// result := false ;
94210: LD_ADDR_VAR 0 1
94214: PUSH
94215: LD_INT 0
94217: ST_TO_ADDR
// for i := 1 to 16 do
94218: LD_ADDR_VAR 0 2
94222: PUSH
94223: DOUBLE
94224: LD_INT 1
94226: DEC
94227: ST_TO_ADDR
94228: LD_INT 16
94230: PUSH
94231: FOR_TO
94232: IFFALSE 94431
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94234: LD_ADDR_VAR 0 3
94238: PUSH
94239: LD_INT 10
94241: PUSH
94242: LD_INT 20
94244: PUSH
94245: LD_INT 30
94247: PUSH
94248: LD_INT 40
94250: PUSH
94251: LD_INT 50
94253: PUSH
94254: LD_INT 60
94256: PUSH
94257: LD_INT 70
94259: PUSH
94260: LD_INT 80
94262: PUSH
94263: LD_INT 90
94265: PUSH
94266: LD_INT 100
94268: PUSH
94269: LD_INT 110
94271: PUSH
94272: LD_INT 120
94274: PUSH
94275: LD_INT 130
94277: PUSH
94278: LD_INT 140
94280: PUSH
94281: LD_INT 150
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: PUSH
94301: LD_INT 1
94303: PPUSH
94304: LD_INT 15
94306: PPUSH
94307: CALL_OW 12
94311: ARRAY
94312: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94313: LD_ADDR_VAR 0 4
94317: PUSH
94318: LD_INT 10
94320: PUSH
94321: LD_INT 20
94323: PUSH
94324: LD_INT 30
94326: PUSH
94327: LD_INT 40
94329: PUSH
94330: LD_INT 50
94332: PUSH
94333: LD_INT 60
94335: PUSH
94336: LD_INT 70
94338: PUSH
94339: LD_INT 80
94341: PUSH
94342: LD_INT 90
94344: PUSH
94345: LD_INT 100
94347: PUSH
94348: LD_INT 110
94350: PUSH
94351: LD_INT 120
94353: PUSH
94354: LD_INT 130
94356: PUSH
94357: LD_INT 140
94359: PUSH
94360: LD_INT 150
94362: PUSH
94363: EMPTY
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: LIST
94373: LIST
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: PUSH
94380: LD_INT 1
94382: PPUSH
94383: LD_INT 15
94385: PPUSH
94386: CALL_OW 12
94390: ARRAY
94391: ST_TO_ADDR
// if ValidHex ( x , y ) then
94392: LD_VAR 0 3
94396: PPUSH
94397: LD_VAR 0 4
94401: PPUSH
94402: CALL_OW 488
94406: IFFALSE 94429
// begin result := [ x , y ] ;
94408: LD_ADDR_VAR 0 1
94412: PUSH
94413: LD_VAR 0 3
94417: PUSH
94418: LD_VAR 0 4
94422: PUSH
94423: EMPTY
94424: LIST
94425: LIST
94426: ST_TO_ADDR
// break ;
94427: GO 94431
// end ; end ;
94429: GO 94231
94431: POP
94432: POP
// if result then
94433: LD_VAR 0 1
94437: IFFALSE 94497
// begin ToLua ( playSibBomb() ) ;
94439: LD_STRING playSibBomb()
94441: PPUSH
94442: CALL_OW 559
// wait ( 0 0$14 ) ;
94446: LD_INT 490
94448: PPUSH
94449: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94453: LD_VAR 0 1
94457: PUSH
94458: LD_INT 1
94460: ARRAY
94461: PPUSH
94462: LD_VAR 0 1
94466: PUSH
94467: LD_INT 2
94469: ARRAY
94470: PPUSH
94471: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94475: LD_VAR 0 1
94479: PUSH
94480: LD_INT 1
94482: ARRAY
94483: PPUSH
94484: LD_VAR 0 1
94488: PUSH
94489: LD_INT 2
94491: ARRAY
94492: PPUSH
94493: CALL_OW 429
// end ; end ;
94497: LD_VAR 0 1
94501: RET
// every 0 0$1 trigger StreamModeActive and sReset do
94502: LD_EXP 115
94506: PUSH
94507: LD_EXP 137
94511: AND
94512: IFFALSE 94524
94514: GO 94516
94516: DISABLE
// YouLost (  ) ;
94517: LD_STRING 
94519: PPUSH
94520: CALL_OW 104
94524: END
// every 0 0$1 trigger StreamModeActive and sFog do
94525: LD_EXP 115
94529: PUSH
94530: LD_EXP 136
94534: AND
94535: IFFALSE 94549
94537: GO 94539
94539: DISABLE
// FogOff ( your_side ) ;
94540: LD_OWVAR 2
94544: PPUSH
94545: CALL_OW 344
94549: END
// every 0 0$1 trigger StreamModeActive and sSun do
94550: LD_EXP 115
94554: PUSH
94555: LD_EXP 138
94559: AND
94560: IFFALSE 94588
94562: GO 94564
94564: DISABLE
// begin solar_recharge_percent := 0 ;
94565: LD_ADDR_OWVAR 79
94569: PUSH
94570: LD_INT 0
94572: ST_TO_ADDR
// wait ( 5 5$00 ) ;
94573: LD_INT 10500
94575: PPUSH
94576: CALL_OW 67
// solar_recharge_percent := 100 ;
94580: LD_ADDR_OWVAR 79
94584: PUSH
94585: LD_INT 100
94587: ST_TO_ADDR
// end ;
94588: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
94589: LD_EXP 115
94593: PUSH
94594: LD_EXP 139
94598: AND
94599: IFFALSE 94838
94601: GO 94603
94603: DISABLE
94604: LD_INT 0
94606: PPUSH
94607: PPUSH
94608: PPUSH
// begin tmp := [ ] ;
94609: LD_ADDR_VAR 0 3
94613: PUSH
94614: EMPTY
94615: ST_TO_ADDR
// for i := 1 to 6 do
94616: LD_ADDR_VAR 0 1
94620: PUSH
94621: DOUBLE
94622: LD_INT 1
94624: DEC
94625: ST_TO_ADDR
94626: LD_INT 6
94628: PUSH
94629: FOR_TO
94630: IFFALSE 94735
// begin uc_nation := nation_nature ;
94632: LD_ADDR_OWVAR 21
94636: PUSH
94637: LD_INT 0
94639: ST_TO_ADDR
// uc_side := 0 ;
94640: LD_ADDR_OWVAR 20
94644: PUSH
94645: LD_INT 0
94647: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94648: LD_ADDR_OWVAR 29
94652: PUSH
94653: LD_INT 12
94655: PUSH
94656: LD_INT 12
94658: PUSH
94659: EMPTY
94660: LIST
94661: LIST
94662: ST_TO_ADDR
// hc_agressivity := 20 ;
94663: LD_ADDR_OWVAR 35
94667: PUSH
94668: LD_INT 20
94670: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
94671: LD_ADDR_OWVAR 28
94675: PUSH
94676: LD_INT 17
94678: ST_TO_ADDR
// hc_gallery :=  ;
94679: LD_ADDR_OWVAR 33
94683: PUSH
94684: LD_STRING 
94686: ST_TO_ADDR
// hc_name :=  ;
94687: LD_ADDR_OWVAR 26
94691: PUSH
94692: LD_STRING 
94694: ST_TO_ADDR
// un := CreateHuman ;
94695: LD_ADDR_VAR 0 2
94699: PUSH
94700: CALL_OW 44
94704: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94705: LD_VAR 0 2
94709: PPUSH
94710: LD_INT 1
94712: PPUSH
94713: CALL_OW 51
// tmp := tmp ^ un ;
94717: LD_ADDR_VAR 0 3
94721: PUSH
94722: LD_VAR 0 3
94726: PUSH
94727: LD_VAR 0 2
94731: ADD
94732: ST_TO_ADDR
// end ;
94733: GO 94629
94735: POP
94736: POP
// repeat wait ( 0 0$1 ) ;
94737: LD_INT 35
94739: PPUSH
94740: CALL_OW 67
// for un in tmp do
94744: LD_ADDR_VAR 0 2
94748: PUSH
94749: LD_VAR 0 3
94753: PUSH
94754: FOR_IN
94755: IFFALSE 94829
// begin if IsDead ( un ) then
94757: LD_VAR 0 2
94761: PPUSH
94762: CALL_OW 301
94766: IFFALSE 94786
// begin tmp := tmp diff un ;
94768: LD_ADDR_VAR 0 3
94772: PUSH
94773: LD_VAR 0 3
94777: PUSH
94778: LD_VAR 0 2
94782: DIFF
94783: ST_TO_ADDR
// continue ;
94784: GO 94754
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94786: LD_VAR 0 2
94790: PPUSH
94791: LD_INT 3
94793: PUSH
94794: LD_INT 22
94796: PUSH
94797: LD_INT 0
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: PUSH
94804: EMPTY
94805: LIST
94806: LIST
94807: PPUSH
94808: CALL_OW 69
94812: PPUSH
94813: LD_VAR 0 2
94817: PPUSH
94818: CALL_OW 74
94822: PPUSH
94823: CALL_OW 115
// end ;
94827: GO 94754
94829: POP
94830: POP
// until not tmp ;
94831: LD_VAR 0 3
94835: NOT
94836: IFFALSE 94737
// end ;
94838: PPOPN 3
94840: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94841: LD_EXP 115
94845: PUSH
94846: LD_EXP 140
94850: AND
94851: IFFALSE 94905
94853: GO 94855
94855: DISABLE
// begin ToLua ( displayTroll(); ) ;
94856: LD_STRING displayTroll();
94858: PPUSH
94859: CALL_OW 559
// wait ( 3 3$00 ) ;
94863: LD_INT 6300
94865: PPUSH
94866: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94870: LD_STRING hideTroll();
94872: PPUSH
94873: CALL_OW 559
// wait ( 1 1$00 ) ;
94877: LD_INT 2100
94879: PPUSH
94880: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94884: LD_STRING displayTroll();
94886: PPUSH
94887: CALL_OW 559
// wait ( 1 1$00 ) ;
94891: LD_INT 2100
94893: PPUSH
94894: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94898: LD_STRING hideTroll();
94900: PPUSH
94901: CALL_OW 559
// end ;
94905: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94906: LD_EXP 115
94910: PUSH
94911: LD_EXP 141
94915: AND
94916: IFFALSE 94979
94918: GO 94920
94920: DISABLE
94921: LD_INT 0
94923: PPUSH
// begin p := 0 ;
94924: LD_ADDR_VAR 0 1
94928: PUSH
94929: LD_INT 0
94931: ST_TO_ADDR
// repeat game_speed := 1 ;
94932: LD_ADDR_OWVAR 65
94936: PUSH
94937: LD_INT 1
94939: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94940: LD_INT 35
94942: PPUSH
94943: CALL_OW 67
// p := p + 1 ;
94947: LD_ADDR_VAR 0 1
94951: PUSH
94952: LD_VAR 0 1
94956: PUSH
94957: LD_INT 1
94959: PLUS
94960: ST_TO_ADDR
// until p >= 60 ;
94961: LD_VAR 0 1
94965: PUSH
94966: LD_INT 60
94968: GREATEREQUAL
94969: IFFALSE 94932
// game_speed := 4 ;
94971: LD_ADDR_OWVAR 65
94975: PUSH
94976: LD_INT 4
94978: ST_TO_ADDR
// end ;
94979: PPOPN 1
94981: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94982: LD_EXP 115
94986: PUSH
94987: LD_EXP 142
94991: AND
94992: IFFALSE 95138
94994: GO 94996
94996: DISABLE
94997: LD_INT 0
94999: PPUSH
95000: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95001: LD_ADDR_VAR 0 1
95005: PUSH
95006: LD_INT 22
95008: PUSH
95009: LD_OWVAR 2
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: PUSH
95018: LD_INT 2
95020: PUSH
95021: LD_INT 30
95023: PUSH
95024: LD_INT 0
95026: PUSH
95027: EMPTY
95028: LIST
95029: LIST
95030: PUSH
95031: LD_INT 30
95033: PUSH
95034: LD_INT 1
95036: PUSH
95037: EMPTY
95038: LIST
95039: LIST
95040: PUSH
95041: EMPTY
95042: LIST
95043: LIST
95044: LIST
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: PPUSH
95050: CALL_OW 69
95054: ST_TO_ADDR
// if not depot then
95055: LD_VAR 0 1
95059: NOT
95060: IFFALSE 95064
// exit ;
95062: GO 95138
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
95064: LD_ADDR_VAR 0 2
95068: PUSH
95069: LD_VAR 0 1
95073: PUSH
95074: LD_INT 1
95076: PPUSH
95077: LD_VAR 0 1
95081: PPUSH
95082: CALL_OW 12
95086: ARRAY
95087: PPUSH
95088: CALL_OW 274
95092: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
95093: LD_VAR 0 2
95097: PPUSH
95098: LD_INT 1
95100: PPUSH
95101: LD_INT 0
95103: PPUSH
95104: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
95108: LD_VAR 0 2
95112: PPUSH
95113: LD_INT 2
95115: PPUSH
95116: LD_INT 0
95118: PPUSH
95119: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
95123: LD_VAR 0 2
95127: PPUSH
95128: LD_INT 3
95130: PPUSH
95131: LD_INT 0
95133: PPUSH
95134: CALL_OW 277
// end ;
95138: PPOPN 2
95140: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95141: LD_EXP 115
95145: PUSH
95146: LD_EXP 143
95150: AND
95151: IFFALSE 95248
95153: GO 95155
95155: DISABLE
95156: LD_INT 0
95158: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95159: LD_ADDR_VAR 0 1
95163: PUSH
95164: LD_INT 22
95166: PUSH
95167: LD_OWVAR 2
95171: PUSH
95172: EMPTY
95173: LIST
95174: LIST
95175: PUSH
95176: LD_INT 21
95178: PUSH
95179: LD_INT 1
95181: PUSH
95182: EMPTY
95183: LIST
95184: LIST
95185: PUSH
95186: LD_INT 3
95188: PUSH
95189: LD_INT 23
95191: PUSH
95192: LD_INT 0
95194: PUSH
95195: EMPTY
95196: LIST
95197: LIST
95198: PUSH
95199: EMPTY
95200: LIST
95201: LIST
95202: PUSH
95203: EMPTY
95204: LIST
95205: LIST
95206: LIST
95207: PPUSH
95208: CALL_OW 69
95212: ST_TO_ADDR
// if not tmp then
95213: LD_VAR 0 1
95217: NOT
95218: IFFALSE 95222
// exit ;
95220: GO 95248
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95222: LD_VAR 0 1
95226: PUSH
95227: LD_INT 1
95229: PPUSH
95230: LD_VAR 0 1
95234: PPUSH
95235: CALL_OW 12
95239: ARRAY
95240: PPUSH
95241: LD_INT 200
95243: PPUSH
95244: CALL_OW 234
// end ;
95248: PPOPN 1
95250: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95251: LD_EXP 115
95255: PUSH
95256: LD_EXP 144
95260: AND
95261: IFFALSE 95340
95263: GO 95265
95265: DISABLE
95266: LD_INT 0
95268: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95269: LD_ADDR_VAR 0 1
95273: PUSH
95274: LD_INT 22
95276: PUSH
95277: LD_OWVAR 2
95281: PUSH
95282: EMPTY
95283: LIST
95284: LIST
95285: PUSH
95286: LD_INT 21
95288: PUSH
95289: LD_INT 2
95291: PUSH
95292: EMPTY
95293: LIST
95294: LIST
95295: PUSH
95296: EMPTY
95297: LIST
95298: LIST
95299: PPUSH
95300: CALL_OW 69
95304: ST_TO_ADDR
// if not tmp then
95305: LD_VAR 0 1
95309: NOT
95310: IFFALSE 95314
// exit ;
95312: GO 95340
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95314: LD_VAR 0 1
95318: PUSH
95319: LD_INT 1
95321: PPUSH
95322: LD_VAR 0 1
95326: PPUSH
95327: CALL_OW 12
95331: ARRAY
95332: PPUSH
95333: LD_INT 60
95335: PPUSH
95336: CALL_OW 234
// end ;
95340: PPOPN 1
95342: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95343: LD_EXP 115
95347: PUSH
95348: LD_EXP 145
95352: AND
95353: IFFALSE 95452
95355: GO 95357
95357: DISABLE
95358: LD_INT 0
95360: PPUSH
95361: PPUSH
// begin enable ;
95362: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95363: LD_ADDR_VAR 0 1
95367: PUSH
95368: LD_INT 22
95370: PUSH
95371: LD_OWVAR 2
95375: PUSH
95376: EMPTY
95377: LIST
95378: LIST
95379: PUSH
95380: LD_INT 61
95382: PUSH
95383: EMPTY
95384: LIST
95385: PUSH
95386: LD_INT 33
95388: PUSH
95389: LD_INT 2
95391: PUSH
95392: EMPTY
95393: LIST
95394: LIST
95395: PUSH
95396: EMPTY
95397: LIST
95398: LIST
95399: LIST
95400: PPUSH
95401: CALL_OW 69
95405: ST_TO_ADDR
// if not tmp then
95406: LD_VAR 0 1
95410: NOT
95411: IFFALSE 95415
// exit ;
95413: GO 95452
// for i in tmp do
95415: LD_ADDR_VAR 0 2
95419: PUSH
95420: LD_VAR 0 1
95424: PUSH
95425: FOR_IN
95426: IFFALSE 95450
// if IsControledBy ( i ) then
95428: LD_VAR 0 2
95432: PPUSH
95433: CALL_OW 312
95437: IFFALSE 95448
// ComUnlink ( i ) ;
95439: LD_VAR 0 2
95443: PPUSH
95444: CALL_OW 136
95448: GO 95425
95450: POP
95451: POP
// end ;
95452: PPOPN 2
95454: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95455: LD_EXP 115
95459: PUSH
95460: LD_EXP 146
95464: AND
95465: IFFALSE 95605
95467: GO 95469
95469: DISABLE
95470: LD_INT 0
95472: PPUSH
95473: PPUSH
// begin ToLua ( displayPowell(); ) ;
95474: LD_STRING displayPowell();
95476: PPUSH
95477: CALL_OW 559
// uc_side := 0 ;
95481: LD_ADDR_OWVAR 20
95485: PUSH
95486: LD_INT 0
95488: ST_TO_ADDR
// uc_nation := 2 ;
95489: LD_ADDR_OWVAR 21
95493: PUSH
95494: LD_INT 2
95496: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
95497: LD_ADDR_OWVAR 37
95501: PUSH
95502: LD_INT 14
95504: ST_TO_ADDR
// vc_engine := engine_siberite ;
95505: LD_ADDR_OWVAR 39
95509: PUSH
95510: LD_INT 3
95512: ST_TO_ADDR
// vc_control := control_apeman ;
95513: LD_ADDR_OWVAR 38
95517: PUSH
95518: LD_INT 5
95520: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
95521: LD_ADDR_OWVAR 40
95525: PUSH
95526: LD_INT 29
95528: ST_TO_ADDR
// un := CreateVehicle ;
95529: LD_ADDR_VAR 0 2
95533: PUSH
95534: CALL_OW 45
95538: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95539: LD_VAR 0 2
95543: PPUSH
95544: LD_INT 1
95546: PPUSH
95547: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95551: LD_INT 35
95553: PPUSH
95554: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95558: LD_VAR 0 2
95562: PPUSH
95563: LD_INT 22
95565: PUSH
95566: LD_OWVAR 2
95570: PUSH
95571: EMPTY
95572: LIST
95573: LIST
95574: PPUSH
95575: CALL_OW 69
95579: PPUSH
95580: LD_VAR 0 2
95584: PPUSH
95585: CALL_OW 74
95589: PPUSH
95590: CALL_OW 115
// until IsDead ( un ) ;
95594: LD_VAR 0 2
95598: PPUSH
95599: CALL_OW 301
95603: IFFALSE 95551
// end ;
95605: PPOPN 2
95607: END
// every 0 0$1 trigger StreamModeActive and sStu do
95608: LD_EXP 115
95612: PUSH
95613: LD_EXP 154
95617: AND
95618: IFFALSE 95634
95620: GO 95622
95622: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95623: LD_STRING displayStucuk();
95625: PPUSH
95626: CALL_OW 559
// ResetFog ;
95630: CALL_OW 335
// end ;
95634: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95635: LD_EXP 115
95639: PUSH
95640: LD_EXP 147
95644: AND
95645: IFFALSE 95786
95647: GO 95649
95649: DISABLE
95650: LD_INT 0
95652: PPUSH
95653: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95654: LD_ADDR_VAR 0 2
95658: PUSH
95659: LD_INT 22
95661: PUSH
95662: LD_OWVAR 2
95666: PUSH
95667: EMPTY
95668: LIST
95669: LIST
95670: PUSH
95671: LD_INT 21
95673: PUSH
95674: LD_INT 1
95676: PUSH
95677: EMPTY
95678: LIST
95679: LIST
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PPUSH
95685: CALL_OW 69
95689: ST_TO_ADDR
// if not tmp then
95690: LD_VAR 0 2
95694: NOT
95695: IFFALSE 95699
// exit ;
95697: GO 95786
// un := tmp [ rand ( 1 , tmp ) ] ;
95699: LD_ADDR_VAR 0 1
95703: PUSH
95704: LD_VAR 0 2
95708: PUSH
95709: LD_INT 1
95711: PPUSH
95712: LD_VAR 0 2
95716: PPUSH
95717: CALL_OW 12
95721: ARRAY
95722: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95723: LD_VAR 0 1
95727: PPUSH
95728: LD_INT 0
95730: PPUSH
95731: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95735: LD_VAR 0 1
95739: PPUSH
95740: LD_OWVAR 3
95744: PUSH
95745: LD_VAR 0 1
95749: DIFF
95750: PPUSH
95751: LD_VAR 0 1
95755: PPUSH
95756: CALL_OW 74
95760: PPUSH
95761: CALL_OW 115
// wait ( 0 0$20 ) ;
95765: LD_INT 700
95767: PPUSH
95768: CALL_OW 67
// SetSide ( un , your_side ) ;
95772: LD_VAR 0 1
95776: PPUSH
95777: LD_OWVAR 2
95781: PPUSH
95782: CALL_OW 235
// end ;
95786: PPOPN 2
95788: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95789: LD_EXP 115
95793: PUSH
95794: LD_EXP 148
95798: AND
95799: IFFALSE 95905
95801: GO 95803
95803: DISABLE
95804: LD_INT 0
95806: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95807: LD_ADDR_VAR 0 1
95811: PUSH
95812: LD_INT 22
95814: PUSH
95815: LD_OWVAR 2
95819: PUSH
95820: EMPTY
95821: LIST
95822: LIST
95823: PUSH
95824: LD_INT 2
95826: PUSH
95827: LD_INT 30
95829: PUSH
95830: LD_INT 0
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: PUSH
95837: LD_INT 30
95839: PUSH
95840: LD_INT 1
95842: PUSH
95843: EMPTY
95844: LIST
95845: LIST
95846: PUSH
95847: EMPTY
95848: LIST
95849: LIST
95850: LIST
95851: PUSH
95852: EMPTY
95853: LIST
95854: LIST
95855: PPUSH
95856: CALL_OW 69
95860: ST_TO_ADDR
// if not depot then
95861: LD_VAR 0 1
95865: NOT
95866: IFFALSE 95870
// exit ;
95868: GO 95905
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95870: LD_VAR 0 1
95874: PUSH
95875: LD_INT 1
95877: ARRAY
95878: PPUSH
95879: CALL_OW 250
95883: PPUSH
95884: LD_VAR 0 1
95888: PUSH
95889: LD_INT 1
95891: ARRAY
95892: PPUSH
95893: CALL_OW 251
95897: PPUSH
95898: LD_INT 70
95900: PPUSH
95901: CALL_OW 495
// end ;
95905: PPOPN 1
95907: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95908: LD_EXP 115
95912: PUSH
95913: LD_EXP 149
95917: AND
95918: IFFALSE 96129
95920: GO 95922
95922: DISABLE
95923: LD_INT 0
95925: PPUSH
95926: PPUSH
95927: PPUSH
95928: PPUSH
95929: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95930: LD_ADDR_VAR 0 5
95934: PUSH
95935: LD_INT 22
95937: PUSH
95938: LD_OWVAR 2
95942: PUSH
95943: EMPTY
95944: LIST
95945: LIST
95946: PUSH
95947: LD_INT 21
95949: PUSH
95950: LD_INT 1
95952: PUSH
95953: EMPTY
95954: LIST
95955: LIST
95956: PUSH
95957: EMPTY
95958: LIST
95959: LIST
95960: PPUSH
95961: CALL_OW 69
95965: ST_TO_ADDR
// if not tmp then
95966: LD_VAR 0 5
95970: NOT
95971: IFFALSE 95975
// exit ;
95973: GO 96129
// for i in tmp do
95975: LD_ADDR_VAR 0 1
95979: PUSH
95980: LD_VAR 0 5
95984: PUSH
95985: FOR_IN
95986: IFFALSE 96127
// begin d := rand ( 0 , 5 ) ;
95988: LD_ADDR_VAR 0 4
95992: PUSH
95993: LD_INT 0
95995: PPUSH
95996: LD_INT 5
95998: PPUSH
95999: CALL_OW 12
96003: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
96004: LD_ADDR_VAR 0 2
96008: PUSH
96009: LD_VAR 0 1
96013: PPUSH
96014: CALL_OW 250
96018: PPUSH
96019: LD_VAR 0 4
96023: PPUSH
96024: LD_INT 3
96026: PPUSH
96027: LD_INT 12
96029: PPUSH
96030: CALL_OW 12
96034: PPUSH
96035: CALL_OW 272
96039: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
96040: LD_ADDR_VAR 0 3
96044: PUSH
96045: LD_VAR 0 1
96049: PPUSH
96050: CALL_OW 251
96054: PPUSH
96055: LD_VAR 0 4
96059: PPUSH
96060: LD_INT 3
96062: PPUSH
96063: LD_INT 12
96065: PPUSH
96066: CALL_OW 12
96070: PPUSH
96071: CALL_OW 273
96075: ST_TO_ADDR
// if ValidHex ( x , y ) then
96076: LD_VAR 0 2
96080: PPUSH
96081: LD_VAR 0 3
96085: PPUSH
96086: CALL_OW 488
96090: IFFALSE 96125
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
96092: LD_VAR 0 1
96096: PPUSH
96097: LD_VAR 0 2
96101: PPUSH
96102: LD_VAR 0 3
96106: PPUSH
96107: LD_INT 3
96109: PPUSH
96110: LD_INT 6
96112: PPUSH
96113: CALL_OW 12
96117: PPUSH
96118: LD_INT 1
96120: PPUSH
96121: CALL_OW 483
// end ;
96125: GO 95985
96127: POP
96128: POP
// end ;
96129: PPOPN 5
96131: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96132: LD_EXP 115
96136: PUSH
96137: LD_EXP 150
96141: AND
96142: IFFALSE 96236
96144: GO 96146
96146: DISABLE
96147: LD_INT 0
96149: PPUSH
96150: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96151: LD_ADDR_VAR 0 2
96155: PUSH
96156: LD_INT 22
96158: PUSH
96159: LD_OWVAR 2
96163: PUSH
96164: EMPTY
96165: LIST
96166: LIST
96167: PUSH
96168: LD_INT 32
96170: PUSH
96171: LD_INT 1
96173: PUSH
96174: EMPTY
96175: LIST
96176: LIST
96177: PUSH
96178: LD_INT 21
96180: PUSH
96181: LD_INT 2
96183: PUSH
96184: EMPTY
96185: LIST
96186: LIST
96187: PUSH
96188: EMPTY
96189: LIST
96190: LIST
96191: LIST
96192: PPUSH
96193: CALL_OW 69
96197: ST_TO_ADDR
// if not tmp then
96198: LD_VAR 0 2
96202: NOT
96203: IFFALSE 96207
// exit ;
96205: GO 96236
// for i in tmp do
96207: LD_ADDR_VAR 0 1
96211: PUSH
96212: LD_VAR 0 2
96216: PUSH
96217: FOR_IN
96218: IFFALSE 96234
// SetFuel ( i , 0 ) ;
96220: LD_VAR 0 1
96224: PPUSH
96225: LD_INT 0
96227: PPUSH
96228: CALL_OW 240
96232: GO 96217
96234: POP
96235: POP
// end ;
96236: PPOPN 2
96238: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96239: LD_EXP 115
96243: PUSH
96244: LD_EXP 151
96248: AND
96249: IFFALSE 96315
96251: GO 96253
96253: DISABLE
96254: LD_INT 0
96256: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96257: LD_ADDR_VAR 0 1
96261: PUSH
96262: LD_INT 22
96264: PUSH
96265: LD_OWVAR 2
96269: PUSH
96270: EMPTY
96271: LIST
96272: LIST
96273: PUSH
96274: LD_INT 30
96276: PUSH
96277: LD_INT 29
96279: PUSH
96280: EMPTY
96281: LIST
96282: LIST
96283: PUSH
96284: EMPTY
96285: LIST
96286: LIST
96287: PPUSH
96288: CALL_OW 69
96292: ST_TO_ADDR
// if not tmp then
96293: LD_VAR 0 1
96297: NOT
96298: IFFALSE 96302
// exit ;
96300: GO 96315
// DestroyUnit ( tmp [ 1 ] ) ;
96302: LD_VAR 0 1
96306: PUSH
96307: LD_INT 1
96309: ARRAY
96310: PPUSH
96311: CALL_OW 65
// end ;
96315: PPOPN 1
96317: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96318: LD_EXP 115
96322: PUSH
96323: LD_EXP 153
96327: AND
96328: IFFALSE 96457
96330: GO 96332
96332: DISABLE
96333: LD_INT 0
96335: PPUSH
// begin uc_side := 0 ;
96336: LD_ADDR_OWVAR 20
96340: PUSH
96341: LD_INT 0
96343: ST_TO_ADDR
// uc_nation := nation_arabian ;
96344: LD_ADDR_OWVAR 21
96348: PUSH
96349: LD_INT 2
96351: ST_TO_ADDR
// hc_gallery :=  ;
96352: LD_ADDR_OWVAR 33
96356: PUSH
96357: LD_STRING 
96359: ST_TO_ADDR
// hc_name :=  ;
96360: LD_ADDR_OWVAR 26
96364: PUSH
96365: LD_STRING 
96367: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96368: LD_INT 1
96370: PPUSH
96371: LD_INT 11
96373: PPUSH
96374: LD_INT 10
96376: PPUSH
96377: CALL_OW 380
// un := CreateHuman ;
96381: LD_ADDR_VAR 0 1
96385: PUSH
96386: CALL_OW 44
96390: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96391: LD_VAR 0 1
96395: PPUSH
96396: LD_INT 1
96398: PPUSH
96399: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96403: LD_INT 35
96405: PPUSH
96406: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96410: LD_VAR 0 1
96414: PPUSH
96415: LD_INT 22
96417: PUSH
96418: LD_OWVAR 2
96422: PUSH
96423: EMPTY
96424: LIST
96425: LIST
96426: PPUSH
96427: CALL_OW 69
96431: PPUSH
96432: LD_VAR 0 1
96436: PPUSH
96437: CALL_OW 74
96441: PPUSH
96442: CALL_OW 115
// until IsDead ( un ) ;
96446: LD_VAR 0 1
96450: PPUSH
96451: CALL_OW 301
96455: IFFALSE 96403
// end ;
96457: PPOPN 1
96459: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96460: LD_EXP 115
96464: PUSH
96465: LD_EXP 155
96469: AND
96470: IFFALSE 96482
96472: GO 96474
96474: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96475: LD_STRING earthquake(getX(game), 0, 32)
96477: PPUSH
96478: CALL_OW 559
96482: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
96483: LD_EXP 115
96487: PUSH
96488: LD_EXP 156
96492: AND
96493: IFFALSE 96584
96495: GO 96497
96497: DISABLE
96498: LD_INT 0
96500: PPUSH
// begin enable ;
96501: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
96502: LD_ADDR_VAR 0 1
96506: PUSH
96507: LD_INT 22
96509: PUSH
96510: LD_OWVAR 2
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 21
96521: PUSH
96522: LD_INT 2
96524: PUSH
96525: EMPTY
96526: LIST
96527: LIST
96528: PUSH
96529: LD_INT 33
96531: PUSH
96532: LD_INT 3
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: LIST
96543: PPUSH
96544: CALL_OW 69
96548: ST_TO_ADDR
// if not tmp then
96549: LD_VAR 0 1
96553: NOT
96554: IFFALSE 96558
// exit ;
96556: GO 96584
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96558: LD_VAR 0 1
96562: PUSH
96563: LD_INT 1
96565: PPUSH
96566: LD_VAR 0 1
96570: PPUSH
96571: CALL_OW 12
96575: ARRAY
96576: PPUSH
96577: LD_INT 1
96579: PPUSH
96580: CALL_OW 234
// end ;
96584: PPOPN 1
96586: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
96587: LD_EXP 115
96591: PUSH
96592: LD_EXP 157
96596: AND
96597: IFFALSE 96738
96599: GO 96601
96601: DISABLE
96602: LD_INT 0
96604: PPUSH
96605: PPUSH
96606: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96607: LD_ADDR_VAR 0 3
96611: PUSH
96612: LD_INT 22
96614: PUSH
96615: LD_OWVAR 2
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: PUSH
96624: LD_INT 25
96626: PUSH
96627: LD_INT 1
96629: PUSH
96630: EMPTY
96631: LIST
96632: LIST
96633: PUSH
96634: EMPTY
96635: LIST
96636: LIST
96637: PPUSH
96638: CALL_OW 69
96642: ST_TO_ADDR
// if not tmp then
96643: LD_VAR 0 3
96647: NOT
96648: IFFALSE 96652
// exit ;
96650: GO 96738
// un := tmp [ rand ( 1 , tmp ) ] ;
96652: LD_ADDR_VAR 0 2
96656: PUSH
96657: LD_VAR 0 3
96661: PUSH
96662: LD_INT 1
96664: PPUSH
96665: LD_VAR 0 3
96669: PPUSH
96670: CALL_OW 12
96674: ARRAY
96675: ST_TO_ADDR
// if Crawls ( un ) then
96676: LD_VAR 0 2
96680: PPUSH
96681: CALL_OW 318
96685: IFFALSE 96696
// ComWalk ( un ) ;
96687: LD_VAR 0 2
96691: PPUSH
96692: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96696: LD_VAR 0 2
96700: PPUSH
96701: LD_INT 9
96703: PPUSH
96704: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96708: LD_INT 28
96710: PPUSH
96711: LD_OWVAR 2
96715: PPUSH
96716: LD_INT 2
96718: PPUSH
96719: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96723: LD_INT 29
96725: PPUSH
96726: LD_OWVAR 2
96730: PPUSH
96731: LD_INT 2
96733: PPUSH
96734: CALL_OW 322
// end ;
96738: PPOPN 3
96740: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96741: LD_EXP 115
96745: PUSH
96746: LD_EXP 158
96750: AND
96751: IFFALSE 96862
96753: GO 96755
96755: DISABLE
96756: LD_INT 0
96758: PPUSH
96759: PPUSH
96760: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96761: LD_ADDR_VAR 0 3
96765: PUSH
96766: LD_INT 22
96768: PUSH
96769: LD_OWVAR 2
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: PUSH
96778: LD_INT 25
96780: PUSH
96781: LD_INT 1
96783: PUSH
96784: EMPTY
96785: LIST
96786: LIST
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: PPUSH
96792: CALL_OW 69
96796: ST_TO_ADDR
// if not tmp then
96797: LD_VAR 0 3
96801: NOT
96802: IFFALSE 96806
// exit ;
96804: GO 96862
// un := tmp [ rand ( 1 , tmp ) ] ;
96806: LD_ADDR_VAR 0 2
96810: PUSH
96811: LD_VAR 0 3
96815: PUSH
96816: LD_INT 1
96818: PPUSH
96819: LD_VAR 0 3
96823: PPUSH
96824: CALL_OW 12
96828: ARRAY
96829: ST_TO_ADDR
// if Crawls ( un ) then
96830: LD_VAR 0 2
96834: PPUSH
96835: CALL_OW 318
96839: IFFALSE 96850
// ComWalk ( un ) ;
96841: LD_VAR 0 2
96845: PPUSH
96846: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96850: LD_VAR 0 2
96854: PPUSH
96855: LD_INT 8
96857: PPUSH
96858: CALL_OW 336
// end ;
96862: PPOPN 3
96864: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96865: LD_EXP 115
96869: PUSH
96870: LD_EXP 159
96874: AND
96875: IFFALSE 97019
96877: GO 96879
96879: DISABLE
96880: LD_INT 0
96882: PPUSH
96883: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96884: LD_ADDR_VAR 0 2
96888: PUSH
96889: LD_INT 22
96891: PUSH
96892: LD_OWVAR 2
96896: PUSH
96897: EMPTY
96898: LIST
96899: LIST
96900: PUSH
96901: LD_INT 21
96903: PUSH
96904: LD_INT 2
96906: PUSH
96907: EMPTY
96908: LIST
96909: LIST
96910: PUSH
96911: LD_INT 2
96913: PUSH
96914: LD_INT 34
96916: PUSH
96917: LD_INT 12
96919: PUSH
96920: EMPTY
96921: LIST
96922: LIST
96923: PUSH
96924: LD_INT 34
96926: PUSH
96927: LD_INT 51
96929: PUSH
96930: EMPTY
96931: LIST
96932: LIST
96933: PUSH
96934: LD_INT 34
96936: PUSH
96937: LD_INT 32
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: PUSH
96944: EMPTY
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: PUSH
96950: EMPTY
96951: LIST
96952: LIST
96953: LIST
96954: PPUSH
96955: CALL_OW 69
96959: ST_TO_ADDR
// if not tmp then
96960: LD_VAR 0 2
96964: NOT
96965: IFFALSE 96969
// exit ;
96967: GO 97019
// for i in tmp do
96969: LD_ADDR_VAR 0 1
96973: PUSH
96974: LD_VAR 0 2
96978: PUSH
96979: FOR_IN
96980: IFFALSE 97017
// if GetCargo ( i , mat_artifact ) = 0 then
96982: LD_VAR 0 1
96986: PPUSH
96987: LD_INT 4
96989: PPUSH
96990: CALL_OW 289
96994: PUSH
96995: LD_INT 0
96997: EQUAL
96998: IFFALSE 97015
// SetCargo ( i , mat_siberit , 100 ) ;
97000: LD_VAR 0 1
97004: PPUSH
97005: LD_INT 3
97007: PPUSH
97008: LD_INT 100
97010: PPUSH
97011: CALL_OW 290
97015: GO 96979
97017: POP
97018: POP
// end ;
97019: PPOPN 2
97021: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
97022: LD_EXP 115
97026: PUSH
97027: LD_EXP 160
97031: AND
97032: IFFALSE 97185
97034: GO 97036
97036: DISABLE
97037: LD_INT 0
97039: PPUSH
97040: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97041: LD_ADDR_VAR 0 2
97045: PUSH
97046: LD_INT 22
97048: PUSH
97049: LD_OWVAR 2
97053: PUSH
97054: EMPTY
97055: LIST
97056: LIST
97057: PPUSH
97058: CALL_OW 69
97062: ST_TO_ADDR
// if not tmp then
97063: LD_VAR 0 2
97067: NOT
97068: IFFALSE 97072
// exit ;
97070: GO 97185
// for i := 1 to 2 do
97072: LD_ADDR_VAR 0 1
97076: PUSH
97077: DOUBLE
97078: LD_INT 1
97080: DEC
97081: ST_TO_ADDR
97082: LD_INT 2
97084: PUSH
97085: FOR_TO
97086: IFFALSE 97183
// begin uc_side := your_side ;
97088: LD_ADDR_OWVAR 20
97092: PUSH
97093: LD_OWVAR 2
97097: ST_TO_ADDR
// uc_nation := nation_american ;
97098: LD_ADDR_OWVAR 21
97102: PUSH
97103: LD_INT 1
97105: ST_TO_ADDR
// vc_chassis := us_morphling ;
97106: LD_ADDR_OWVAR 37
97110: PUSH
97111: LD_INT 5
97113: ST_TO_ADDR
// vc_engine := engine_siberite ;
97114: LD_ADDR_OWVAR 39
97118: PUSH
97119: LD_INT 3
97121: ST_TO_ADDR
// vc_control := control_computer ;
97122: LD_ADDR_OWVAR 38
97126: PUSH
97127: LD_INT 3
97129: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97130: LD_ADDR_OWVAR 40
97134: PUSH
97135: LD_INT 10
97137: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
97138: CALL_OW 45
97142: PPUSH
97143: LD_VAR 0 2
97147: PUSH
97148: LD_INT 1
97150: ARRAY
97151: PPUSH
97152: CALL_OW 250
97156: PPUSH
97157: LD_VAR 0 2
97161: PUSH
97162: LD_INT 1
97164: ARRAY
97165: PPUSH
97166: CALL_OW 251
97170: PPUSH
97171: LD_INT 12
97173: PPUSH
97174: LD_INT 1
97176: PPUSH
97177: CALL_OW 50
// end ;
97181: GO 97085
97183: POP
97184: POP
// end ;
97185: PPOPN 2
97187: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97188: LD_EXP 115
97192: PUSH
97193: LD_EXP 161
97197: AND
97198: IFFALSE 97420
97200: GO 97202
97202: DISABLE
97203: LD_INT 0
97205: PPUSH
97206: PPUSH
97207: PPUSH
97208: PPUSH
97209: PPUSH
97210: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97211: LD_ADDR_VAR 0 6
97215: PUSH
97216: LD_INT 22
97218: PUSH
97219: LD_OWVAR 2
97223: PUSH
97224: EMPTY
97225: LIST
97226: LIST
97227: PUSH
97228: LD_INT 21
97230: PUSH
97231: LD_INT 1
97233: PUSH
97234: EMPTY
97235: LIST
97236: LIST
97237: PUSH
97238: LD_INT 3
97240: PUSH
97241: LD_INT 23
97243: PUSH
97244: LD_INT 0
97246: PUSH
97247: EMPTY
97248: LIST
97249: LIST
97250: PUSH
97251: EMPTY
97252: LIST
97253: LIST
97254: PUSH
97255: EMPTY
97256: LIST
97257: LIST
97258: LIST
97259: PPUSH
97260: CALL_OW 69
97264: ST_TO_ADDR
// if not tmp then
97265: LD_VAR 0 6
97269: NOT
97270: IFFALSE 97274
// exit ;
97272: GO 97420
// s1 := rand ( 1 , 4 ) ;
97274: LD_ADDR_VAR 0 2
97278: PUSH
97279: LD_INT 1
97281: PPUSH
97282: LD_INT 4
97284: PPUSH
97285: CALL_OW 12
97289: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97290: LD_ADDR_VAR 0 4
97294: PUSH
97295: LD_VAR 0 6
97299: PUSH
97300: LD_INT 1
97302: ARRAY
97303: PPUSH
97304: LD_VAR 0 2
97308: PPUSH
97309: CALL_OW 259
97313: ST_TO_ADDR
// if s1 = 1 then
97314: LD_VAR 0 2
97318: PUSH
97319: LD_INT 1
97321: EQUAL
97322: IFFALSE 97342
// s2 := rand ( 2 , 4 ) else
97324: LD_ADDR_VAR 0 3
97328: PUSH
97329: LD_INT 2
97331: PPUSH
97332: LD_INT 4
97334: PPUSH
97335: CALL_OW 12
97339: ST_TO_ADDR
97340: GO 97350
// s2 := 1 ;
97342: LD_ADDR_VAR 0 3
97346: PUSH
97347: LD_INT 1
97349: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97350: LD_ADDR_VAR 0 5
97354: PUSH
97355: LD_VAR 0 6
97359: PUSH
97360: LD_INT 1
97362: ARRAY
97363: PPUSH
97364: LD_VAR 0 3
97368: PPUSH
97369: CALL_OW 259
97373: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97374: LD_VAR 0 6
97378: PUSH
97379: LD_INT 1
97381: ARRAY
97382: PPUSH
97383: LD_VAR 0 2
97387: PPUSH
97388: LD_VAR 0 5
97392: PPUSH
97393: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97397: LD_VAR 0 6
97401: PUSH
97402: LD_INT 1
97404: ARRAY
97405: PPUSH
97406: LD_VAR 0 3
97410: PPUSH
97411: LD_VAR 0 4
97415: PPUSH
97416: CALL_OW 237
// end ;
97420: PPOPN 6
97422: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97423: LD_EXP 115
97427: PUSH
97428: LD_EXP 162
97432: AND
97433: IFFALSE 97512
97435: GO 97437
97437: DISABLE
97438: LD_INT 0
97440: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97441: LD_ADDR_VAR 0 1
97445: PUSH
97446: LD_INT 22
97448: PUSH
97449: LD_OWVAR 2
97453: PUSH
97454: EMPTY
97455: LIST
97456: LIST
97457: PUSH
97458: LD_INT 30
97460: PUSH
97461: LD_INT 3
97463: PUSH
97464: EMPTY
97465: LIST
97466: LIST
97467: PUSH
97468: EMPTY
97469: LIST
97470: LIST
97471: PPUSH
97472: CALL_OW 69
97476: ST_TO_ADDR
// if not tmp then
97477: LD_VAR 0 1
97481: NOT
97482: IFFALSE 97486
// exit ;
97484: GO 97512
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97486: LD_VAR 0 1
97490: PUSH
97491: LD_INT 1
97493: PPUSH
97494: LD_VAR 0 1
97498: PPUSH
97499: CALL_OW 12
97503: ARRAY
97504: PPUSH
97505: LD_INT 1
97507: PPUSH
97508: CALL_OW 234
// end ;
97512: PPOPN 1
97514: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
97515: LD_EXP 115
97519: PUSH
97520: LD_EXP 163
97524: AND
97525: IFFALSE 97637
97527: GO 97529
97529: DISABLE
97530: LD_INT 0
97532: PPUSH
97533: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
97534: LD_ADDR_VAR 0 2
97538: PUSH
97539: LD_INT 22
97541: PUSH
97542: LD_OWVAR 2
97546: PUSH
97547: EMPTY
97548: LIST
97549: LIST
97550: PUSH
97551: LD_INT 2
97553: PUSH
97554: LD_INT 30
97556: PUSH
97557: LD_INT 27
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: PUSH
97564: LD_INT 30
97566: PUSH
97567: LD_INT 26
97569: PUSH
97570: EMPTY
97571: LIST
97572: LIST
97573: PUSH
97574: LD_INT 30
97576: PUSH
97577: LD_INT 28
97579: PUSH
97580: EMPTY
97581: LIST
97582: LIST
97583: PUSH
97584: EMPTY
97585: LIST
97586: LIST
97587: LIST
97588: LIST
97589: PUSH
97590: EMPTY
97591: LIST
97592: LIST
97593: PPUSH
97594: CALL_OW 69
97598: ST_TO_ADDR
// if not tmp then
97599: LD_VAR 0 2
97603: NOT
97604: IFFALSE 97608
// exit ;
97606: GO 97637
// for i in tmp do
97608: LD_ADDR_VAR 0 1
97612: PUSH
97613: LD_VAR 0 2
97617: PUSH
97618: FOR_IN
97619: IFFALSE 97635
// SetLives ( i , 1 ) ;
97621: LD_VAR 0 1
97625: PPUSH
97626: LD_INT 1
97628: PPUSH
97629: CALL_OW 234
97633: GO 97618
97635: POP
97636: POP
// end ;
97637: PPOPN 2
97639: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97640: LD_EXP 115
97644: PUSH
97645: LD_EXP 164
97649: AND
97650: IFFALSE 97924
97652: GO 97654
97654: DISABLE
97655: LD_INT 0
97657: PPUSH
97658: PPUSH
97659: PPUSH
// begin i := rand ( 1 , 7 ) ;
97660: LD_ADDR_VAR 0 1
97664: PUSH
97665: LD_INT 1
97667: PPUSH
97668: LD_INT 7
97670: PPUSH
97671: CALL_OW 12
97675: ST_TO_ADDR
// case i of 1 :
97676: LD_VAR 0 1
97680: PUSH
97681: LD_INT 1
97683: DOUBLE
97684: EQUAL
97685: IFTRUE 97689
97687: GO 97699
97689: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97690: LD_STRING earthquake(getX(game), 0, 32)
97692: PPUSH
97693: CALL_OW 559
97697: GO 97924
97699: LD_INT 2
97701: DOUBLE
97702: EQUAL
97703: IFTRUE 97707
97705: GO 97721
97707: POP
// begin ToLua ( displayStucuk(); ) ;
97708: LD_STRING displayStucuk();
97710: PPUSH
97711: CALL_OW 559
// ResetFog ;
97715: CALL_OW 335
// end ; 3 :
97719: GO 97924
97721: LD_INT 3
97723: DOUBLE
97724: EQUAL
97725: IFTRUE 97729
97727: GO 97833
97729: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97730: LD_ADDR_VAR 0 2
97734: PUSH
97735: LD_INT 22
97737: PUSH
97738: LD_OWVAR 2
97742: PUSH
97743: EMPTY
97744: LIST
97745: LIST
97746: PUSH
97747: LD_INT 25
97749: PUSH
97750: LD_INT 1
97752: PUSH
97753: EMPTY
97754: LIST
97755: LIST
97756: PUSH
97757: EMPTY
97758: LIST
97759: LIST
97760: PPUSH
97761: CALL_OW 69
97765: ST_TO_ADDR
// if not tmp then
97766: LD_VAR 0 2
97770: NOT
97771: IFFALSE 97775
// exit ;
97773: GO 97924
// un := tmp [ rand ( 1 , tmp ) ] ;
97775: LD_ADDR_VAR 0 3
97779: PUSH
97780: LD_VAR 0 2
97784: PUSH
97785: LD_INT 1
97787: PPUSH
97788: LD_VAR 0 2
97792: PPUSH
97793: CALL_OW 12
97797: ARRAY
97798: ST_TO_ADDR
// if Crawls ( un ) then
97799: LD_VAR 0 3
97803: PPUSH
97804: CALL_OW 318
97808: IFFALSE 97819
// ComWalk ( un ) ;
97810: LD_VAR 0 3
97814: PPUSH
97815: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97819: LD_VAR 0 3
97823: PPUSH
97824: LD_INT 8
97826: PPUSH
97827: CALL_OW 336
// end ; 4 :
97831: GO 97924
97833: LD_INT 4
97835: DOUBLE
97836: EQUAL
97837: IFTRUE 97841
97839: GO 97902
97841: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97842: LD_ADDR_VAR 0 2
97846: PUSH
97847: LD_INT 22
97849: PUSH
97850: LD_OWVAR 2
97854: PUSH
97855: EMPTY
97856: LIST
97857: LIST
97858: PUSH
97859: LD_INT 30
97861: PUSH
97862: LD_INT 29
97864: PUSH
97865: EMPTY
97866: LIST
97867: LIST
97868: PUSH
97869: EMPTY
97870: LIST
97871: LIST
97872: PPUSH
97873: CALL_OW 69
97877: ST_TO_ADDR
// if not tmp then
97878: LD_VAR 0 2
97882: NOT
97883: IFFALSE 97887
// exit ;
97885: GO 97924
// DestroyUnit ( tmp [ 1 ] ) ;
97887: LD_VAR 0 2
97891: PUSH
97892: LD_INT 1
97894: ARRAY
97895: PPUSH
97896: CALL_OW 65
// end ; 5 .. 7 :
97900: GO 97924
97902: LD_INT 5
97904: DOUBLE
97905: GREATEREQUAL
97906: IFFALSE 97914
97908: LD_INT 7
97910: DOUBLE
97911: LESSEQUAL
97912: IFTRUE 97916
97914: GO 97923
97916: POP
// StreamSibBomb ; end ;
97917: CALL 94204 0 0
97921: GO 97924
97923: POP
// end ;
97924: PPOPN 3
97926: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97927: LD_EXP 115
97931: PUSH
97932: LD_EXP 165
97936: AND
97937: IFFALSE 98093
97939: GO 97941
97941: DISABLE
97942: LD_INT 0
97944: PPUSH
97945: PPUSH
97946: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97947: LD_ADDR_VAR 0 2
97951: PUSH
97952: LD_INT 81
97954: PUSH
97955: LD_OWVAR 2
97959: PUSH
97960: EMPTY
97961: LIST
97962: LIST
97963: PUSH
97964: LD_INT 2
97966: PUSH
97967: LD_INT 21
97969: PUSH
97970: LD_INT 1
97972: PUSH
97973: EMPTY
97974: LIST
97975: LIST
97976: PUSH
97977: LD_INT 21
97979: PUSH
97980: LD_INT 2
97982: PUSH
97983: EMPTY
97984: LIST
97985: LIST
97986: PUSH
97987: EMPTY
97988: LIST
97989: LIST
97990: LIST
97991: PUSH
97992: EMPTY
97993: LIST
97994: LIST
97995: PPUSH
97996: CALL_OW 69
98000: ST_TO_ADDR
// if not tmp then
98001: LD_VAR 0 2
98005: NOT
98006: IFFALSE 98010
// exit ;
98008: GO 98093
// p := 0 ;
98010: LD_ADDR_VAR 0 3
98014: PUSH
98015: LD_INT 0
98017: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98018: LD_INT 35
98020: PPUSH
98021: CALL_OW 67
// p := p + 1 ;
98025: LD_ADDR_VAR 0 3
98029: PUSH
98030: LD_VAR 0 3
98034: PUSH
98035: LD_INT 1
98037: PLUS
98038: ST_TO_ADDR
// for i in tmp do
98039: LD_ADDR_VAR 0 1
98043: PUSH
98044: LD_VAR 0 2
98048: PUSH
98049: FOR_IN
98050: IFFALSE 98081
// if GetLives ( i ) < 1000 then
98052: LD_VAR 0 1
98056: PPUSH
98057: CALL_OW 256
98061: PUSH
98062: LD_INT 1000
98064: LESS
98065: IFFALSE 98079
// SetLives ( i , 1000 ) ;
98067: LD_VAR 0 1
98071: PPUSH
98072: LD_INT 1000
98074: PPUSH
98075: CALL_OW 234
98079: GO 98049
98081: POP
98082: POP
// until p > 20 ;
98083: LD_VAR 0 3
98087: PUSH
98088: LD_INT 20
98090: GREATER
98091: IFFALSE 98018
// end ;
98093: PPOPN 3
98095: END
// every 0 0$1 trigger StreamModeActive and sTime do
98096: LD_EXP 115
98100: PUSH
98101: LD_EXP 166
98105: AND
98106: IFFALSE 98141
98108: GO 98110
98110: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
98111: LD_INT 28
98113: PPUSH
98114: LD_OWVAR 2
98118: PPUSH
98119: LD_INT 2
98121: PPUSH
98122: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98126: LD_INT 30
98128: PPUSH
98129: LD_OWVAR 2
98133: PPUSH
98134: LD_INT 2
98136: PPUSH
98137: CALL_OW 322
// end ;
98141: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98142: LD_EXP 115
98146: PUSH
98147: LD_EXP 167
98151: AND
98152: IFFALSE 98273
98154: GO 98156
98156: DISABLE
98157: LD_INT 0
98159: PPUSH
98160: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98161: LD_ADDR_VAR 0 2
98165: PUSH
98166: LD_INT 22
98168: PUSH
98169: LD_OWVAR 2
98173: PUSH
98174: EMPTY
98175: LIST
98176: LIST
98177: PUSH
98178: LD_INT 21
98180: PUSH
98181: LD_INT 1
98183: PUSH
98184: EMPTY
98185: LIST
98186: LIST
98187: PUSH
98188: LD_INT 3
98190: PUSH
98191: LD_INT 23
98193: PUSH
98194: LD_INT 0
98196: PUSH
98197: EMPTY
98198: LIST
98199: LIST
98200: PUSH
98201: EMPTY
98202: LIST
98203: LIST
98204: PUSH
98205: EMPTY
98206: LIST
98207: LIST
98208: LIST
98209: PPUSH
98210: CALL_OW 69
98214: ST_TO_ADDR
// if not tmp then
98215: LD_VAR 0 2
98219: NOT
98220: IFFALSE 98224
// exit ;
98222: GO 98273
// for i in tmp do
98224: LD_ADDR_VAR 0 1
98228: PUSH
98229: LD_VAR 0 2
98233: PUSH
98234: FOR_IN
98235: IFFALSE 98271
// begin if Crawls ( i ) then
98237: LD_VAR 0 1
98241: PPUSH
98242: CALL_OW 318
98246: IFFALSE 98257
// ComWalk ( i ) ;
98248: LD_VAR 0 1
98252: PPUSH
98253: CALL_OW 138
// SetClass ( i , 2 ) ;
98257: LD_VAR 0 1
98261: PPUSH
98262: LD_INT 2
98264: PPUSH
98265: CALL_OW 336
// end ;
98269: GO 98234
98271: POP
98272: POP
// end ;
98273: PPOPN 2
98275: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98276: LD_EXP 115
98280: PUSH
98281: LD_EXP 168
98285: AND
98286: IFFALSE 98567
98288: GO 98290
98290: DISABLE
98291: LD_INT 0
98293: PPUSH
98294: PPUSH
98295: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98296: LD_OWVAR 2
98300: PPUSH
98301: LD_INT 9
98303: PPUSH
98304: LD_INT 1
98306: PPUSH
98307: LD_INT 1
98309: PPUSH
98310: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98314: LD_INT 9
98316: PPUSH
98317: LD_OWVAR 2
98321: PPUSH
98322: CALL_OW 343
// uc_side := 9 ;
98326: LD_ADDR_OWVAR 20
98330: PUSH
98331: LD_INT 9
98333: ST_TO_ADDR
// uc_nation := 2 ;
98334: LD_ADDR_OWVAR 21
98338: PUSH
98339: LD_INT 2
98341: ST_TO_ADDR
// hc_name := Dark Warrior ;
98342: LD_ADDR_OWVAR 26
98346: PUSH
98347: LD_STRING Dark Warrior
98349: ST_TO_ADDR
// hc_gallery :=  ;
98350: LD_ADDR_OWVAR 33
98354: PUSH
98355: LD_STRING 
98357: ST_TO_ADDR
// hc_noskilllimit := true ;
98358: LD_ADDR_OWVAR 76
98362: PUSH
98363: LD_INT 1
98365: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
98366: LD_ADDR_OWVAR 31
98370: PUSH
98371: LD_INT 30
98373: PUSH
98374: LD_INT 30
98376: PUSH
98377: LD_INT 30
98379: PUSH
98380: LD_INT 30
98382: PUSH
98383: EMPTY
98384: LIST
98385: LIST
98386: LIST
98387: LIST
98388: ST_TO_ADDR
// un := CreateHuman ;
98389: LD_ADDR_VAR 0 3
98393: PUSH
98394: CALL_OW 44
98398: ST_TO_ADDR
// hc_noskilllimit := false ;
98399: LD_ADDR_OWVAR 76
98403: PUSH
98404: LD_INT 0
98406: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98407: LD_VAR 0 3
98411: PPUSH
98412: LD_INT 1
98414: PPUSH
98415: CALL_OW 51
// p := 0 ;
98419: LD_ADDR_VAR 0 2
98423: PUSH
98424: LD_INT 0
98426: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98427: LD_INT 35
98429: PPUSH
98430: CALL_OW 67
// p := p + 1 ;
98434: LD_ADDR_VAR 0 2
98438: PUSH
98439: LD_VAR 0 2
98443: PUSH
98444: LD_INT 1
98446: PLUS
98447: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
98448: LD_VAR 0 3
98452: PPUSH
98453: CALL_OW 256
98457: PUSH
98458: LD_INT 1000
98460: LESS
98461: IFFALSE 98475
// SetLives ( un , 1000 ) ;
98463: LD_VAR 0 3
98467: PPUSH
98468: LD_INT 1000
98470: PPUSH
98471: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
98475: LD_VAR 0 3
98479: PPUSH
98480: LD_INT 81
98482: PUSH
98483: LD_OWVAR 2
98487: PUSH
98488: EMPTY
98489: LIST
98490: LIST
98491: PUSH
98492: LD_INT 91
98494: PUSH
98495: LD_VAR 0 3
98499: PUSH
98500: LD_INT 30
98502: PUSH
98503: EMPTY
98504: LIST
98505: LIST
98506: LIST
98507: PUSH
98508: EMPTY
98509: LIST
98510: LIST
98511: PPUSH
98512: CALL_OW 69
98516: PPUSH
98517: LD_VAR 0 3
98521: PPUSH
98522: CALL_OW 74
98526: PPUSH
98527: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
98531: LD_VAR 0 2
98535: PUSH
98536: LD_INT 60
98538: GREATER
98539: PUSH
98540: LD_VAR 0 3
98544: PPUSH
98545: CALL_OW 301
98549: OR
98550: IFFALSE 98427
// if un then
98552: LD_VAR 0 3
98556: IFFALSE 98567
// RemoveUnit ( un ) ;
98558: LD_VAR 0 3
98562: PPUSH
98563: CALL_OW 64
// end ; end_of_file
98567: PPOPN 3
98569: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
98570: LD_INT 0
98572: PPUSH
98573: PPUSH
98574: PPUSH
98575: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
98576: LD_VAR 0 1
98580: PPUSH
98581: CALL_OW 264
98585: PUSH
98586: LD_EXP 106
98590: EQUAL
98591: IFFALSE 98663
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
98593: LD_INT 68
98595: PPUSH
98596: LD_VAR 0 1
98600: PPUSH
98601: CALL_OW 255
98605: PPUSH
98606: CALL_OW 321
98610: PUSH
98611: LD_INT 2
98613: EQUAL
98614: IFFALSE 98626
// eff := 70 else
98616: LD_ADDR_VAR 0 4
98620: PUSH
98621: LD_INT 70
98623: ST_TO_ADDR
98624: GO 98634
// eff := 30 ;
98626: LD_ADDR_VAR 0 4
98630: PUSH
98631: LD_INT 30
98633: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
98634: LD_VAR 0 1
98638: PPUSH
98639: CALL_OW 250
98643: PPUSH
98644: LD_VAR 0 1
98648: PPUSH
98649: CALL_OW 251
98653: PPUSH
98654: LD_VAR 0 4
98658: PPUSH
98659: CALL_OW 495
// end ; end ;
98663: LD_VAR 0 2
98667: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
98668: LD_INT 0
98670: PPUSH
// end ;
98671: LD_VAR 0 4
98675: RET
// export function SOS_Command ( cmd ) ; begin
98676: LD_INT 0
98678: PPUSH
// end ;
98679: LD_VAR 0 2
98683: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
98684: LD_VAR 0 1
98688: PUSH
98689: LD_INT 255
98691: EQUAL
98692: PUSH
98693: LD_VAR 0 2
98697: PPUSH
98698: CALL_OW 264
98702: PUSH
98703: LD_INT 14
98705: PUSH
98706: LD_INT 53
98708: PUSH
98709: EMPTY
98710: LIST
98711: LIST
98712: IN
98713: AND
98714: PUSH
98715: LD_VAR 0 4
98719: PPUSH
98720: LD_VAR 0 5
98724: PPUSH
98725: CALL_OW 488
98729: AND
98730: IFFALSE 98754
// CutTreeXYR ( unit , x , y , 12 ) ;
98732: LD_VAR 0 2
98736: PPUSH
98737: LD_VAR 0 4
98741: PPUSH
98742: LD_VAR 0 5
98746: PPUSH
98747: LD_INT 12
98749: PPUSH
98750: CALL 98757 0 4
// end ;
98754: PPOPN 5
98756: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
98757: LD_INT 0
98759: PPUSH
98760: PPUSH
98761: PPUSH
98762: PPUSH
98763: PPUSH
98764: PPUSH
98765: PPUSH
98766: PPUSH
98767: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
98768: LD_VAR 0 1
98772: NOT
98773: PUSH
98774: LD_VAR 0 2
98778: PPUSH
98779: LD_VAR 0 3
98783: PPUSH
98784: CALL_OW 488
98788: NOT
98789: OR
98790: PUSH
98791: LD_VAR 0 4
98795: NOT
98796: OR
98797: IFFALSE 98801
// exit ;
98799: GO 99141
// list := [ ] ;
98801: LD_ADDR_VAR 0 13
98805: PUSH
98806: EMPTY
98807: ST_TO_ADDR
// if x - r < 0 then
98808: LD_VAR 0 2
98812: PUSH
98813: LD_VAR 0 4
98817: MINUS
98818: PUSH
98819: LD_INT 0
98821: LESS
98822: IFFALSE 98834
// min_x := 0 else
98824: LD_ADDR_VAR 0 7
98828: PUSH
98829: LD_INT 0
98831: ST_TO_ADDR
98832: GO 98850
// min_x := x - r ;
98834: LD_ADDR_VAR 0 7
98838: PUSH
98839: LD_VAR 0 2
98843: PUSH
98844: LD_VAR 0 4
98848: MINUS
98849: ST_TO_ADDR
// if y - r < 0 then
98850: LD_VAR 0 3
98854: PUSH
98855: LD_VAR 0 4
98859: MINUS
98860: PUSH
98861: LD_INT 0
98863: LESS
98864: IFFALSE 98876
// min_y := 0 else
98866: LD_ADDR_VAR 0 8
98870: PUSH
98871: LD_INT 0
98873: ST_TO_ADDR
98874: GO 98892
// min_y := y - r ;
98876: LD_ADDR_VAR 0 8
98880: PUSH
98881: LD_VAR 0 3
98885: PUSH
98886: LD_VAR 0 4
98890: MINUS
98891: ST_TO_ADDR
// max_x := x + r ;
98892: LD_ADDR_VAR 0 9
98896: PUSH
98897: LD_VAR 0 2
98901: PUSH
98902: LD_VAR 0 4
98906: PLUS
98907: ST_TO_ADDR
// max_y := y + r ;
98908: LD_ADDR_VAR 0 10
98912: PUSH
98913: LD_VAR 0 3
98917: PUSH
98918: LD_VAR 0 4
98922: PLUS
98923: ST_TO_ADDR
// for _x = min_x to max_x do
98924: LD_ADDR_VAR 0 11
98928: PUSH
98929: DOUBLE
98930: LD_VAR 0 7
98934: DEC
98935: ST_TO_ADDR
98936: LD_VAR 0 9
98940: PUSH
98941: FOR_TO
98942: IFFALSE 99059
// for _y = min_y to max_y do
98944: LD_ADDR_VAR 0 12
98948: PUSH
98949: DOUBLE
98950: LD_VAR 0 8
98954: DEC
98955: ST_TO_ADDR
98956: LD_VAR 0 10
98960: PUSH
98961: FOR_TO
98962: IFFALSE 99055
// begin if not ValidHex ( _x , _y ) then
98964: LD_VAR 0 11
98968: PPUSH
98969: LD_VAR 0 12
98973: PPUSH
98974: CALL_OW 488
98978: NOT
98979: IFFALSE 98983
// continue ;
98981: GO 98961
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98983: LD_VAR 0 11
98987: PPUSH
98988: LD_VAR 0 12
98992: PPUSH
98993: CALL_OW 351
98997: PUSH
98998: LD_VAR 0 11
99002: PPUSH
99003: LD_VAR 0 12
99007: PPUSH
99008: CALL_OW 554
99012: AND
99013: IFFALSE 99053
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
99015: LD_ADDR_VAR 0 13
99019: PUSH
99020: LD_VAR 0 13
99024: PPUSH
99025: LD_VAR 0 13
99029: PUSH
99030: LD_INT 1
99032: PLUS
99033: PPUSH
99034: LD_VAR 0 11
99038: PUSH
99039: LD_VAR 0 12
99043: PUSH
99044: EMPTY
99045: LIST
99046: LIST
99047: PPUSH
99048: CALL_OW 2
99052: ST_TO_ADDR
// end ;
99053: GO 98961
99055: POP
99056: POP
99057: GO 98941
99059: POP
99060: POP
// if not list then
99061: LD_VAR 0 13
99065: NOT
99066: IFFALSE 99070
// exit ;
99068: GO 99141
// for i in list do
99070: LD_ADDR_VAR 0 6
99074: PUSH
99075: LD_VAR 0 13
99079: PUSH
99080: FOR_IN
99081: IFFALSE 99139
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
99083: LD_VAR 0 1
99087: PPUSH
99088: LD_STRING M
99090: PUSH
99091: LD_VAR 0 6
99095: PUSH
99096: LD_INT 1
99098: ARRAY
99099: PUSH
99100: LD_VAR 0 6
99104: PUSH
99105: LD_INT 2
99107: ARRAY
99108: PUSH
99109: LD_INT 0
99111: PUSH
99112: LD_INT 0
99114: PUSH
99115: LD_INT 0
99117: PUSH
99118: LD_INT 0
99120: PUSH
99121: EMPTY
99122: LIST
99123: LIST
99124: LIST
99125: LIST
99126: LIST
99127: LIST
99128: LIST
99129: PUSH
99130: EMPTY
99131: LIST
99132: PPUSH
99133: CALL_OW 447
99137: GO 99080
99139: POP
99140: POP
// end ;
99141: LD_VAR 0 5
99145: RET
