// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 623 0 0
// InitMacro ;
  19: CALL 57450 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49217 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49217 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49217 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 49217 0 9
// PrepareArabian ;
 147: CALL 3694 0 0
// PrepareRussian ;
 151: CALL 2829 0 0
// PrepareAlliance ;
 155: CALL 825 0 0
// MC_Start ( ) ;
 159: CALL 59562 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6857 0 0
// PrepareBurlak ;
 180: CALL 2208 0 0
// end ;
 184: END
// export function CustomInitMacro ; var i ; begin
 185: LD_INT 0
 187: PPUSH
 188: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 189: LD_ADDR_EXP 83
 193: PUSH
 194: LD_INT 1
 196: PUSH
 197: LD_INT 2
 199: PUSH
 200: EMPTY
 201: LIST
 202: LIST
 203: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 204: LD_ADDR_EXP 84
 208: PUSH
 209: LD_INT 3
 211: PUSH
 212: LD_INT 4
 214: PUSH
 215: EMPTY
 216: LIST
 217: LIST
 218: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 219: LD_INT 1
 221: PPUSH
 222: LD_INT 12
 224: PUSH
 225: LD_INT 15
 227: PUSH
 228: LD_INT 18
 230: PUSH
 231: EMPTY
 232: LIST
 233: LIST
 234: LIST
 235: PUSH
 236: LD_OWVAR 67
 240: ARRAY
 241: PPUSH
 242: LD_INT 7
 244: PPUSH
 245: CALL 80883 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 249: LD_INT 1
 251: PPUSH
 252: LD_EXP 54
 256: PPUSH
 257: CALL 81309 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 261: LD_INT 1
 263: PPUSH
 264: LD_INT 6
 266: PPUSH
 267: CALL 81767 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 271: LD_INT 1
 273: PPUSH
 274: LD_INT 9
 276: PUSH
 277: EMPTY
 278: LIST
 279: PPUSH
 280: CALL 82036 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 284: LD_INT 1
 286: PPUSH
 287: LD_INT 13
 289: PUSH
 290: LD_INT 1
 292: PUSH
 293: LD_INT 2
 295: PUSH
 296: LD_INT 32
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: PUSH
 305: EMPTY
 306: LIST
 307: PPUSH
 308: CALL 81249 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 312: LD_INT 2
 314: PPUSH
 315: LD_INT 12
 317: PUSH
 318: LD_INT 14
 320: PUSH
 321: LD_INT 10
 323: PUSH
 324: LD_INT 11
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: LIST
 331: LIST
 332: PPUSH
 333: CALL 81943 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 337: LD_INT 2
 339: PPUSH
 340: LD_EXP 51
 344: PPUSH
 345: CALL 81309 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 349: LD_INT 2
 351: PPUSH
 352: LD_INT 8
 354: PPUSH
 355: CALL 81767 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 359: LD_INT 2
 361: PPUSH
 362: LD_INT 10
 364: PUSH
 365: EMPTY
 366: LIST
 367: PPUSH
 368: CALL 82036 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 372: LD_INT 2
 374: PPUSH
 375: LD_INT 6
 377: PUSH
 378: LD_INT 71
 380: PUSH
 381: LD_INT 116
 383: PUSH
 384: LD_INT 4
 386: PUSH
 387: EMPTY
 388: LIST
 389: LIST
 390: LIST
 391: LIST
 392: PUSH
 393: LD_INT 4
 395: PUSH
 396: LD_INT 85
 398: PUSH
 399: LD_INT 116
 401: PUSH
 402: LD_INT 4
 404: PUSH
 405: EMPTY
 406: LIST
 407: LIST
 408: LIST
 409: LIST
 410: PUSH
 411: LD_INT 32
 413: PUSH
 414: LD_INT 83
 416: PUSH
 417: LD_INT 111
 419: PUSH
 420: LD_INT 4
 422: PUSH
 423: EMPTY
 424: LIST
 425: LIST
 426: LIST
 427: LIST
 428: PUSH
 429: LD_INT 32
 431: PUSH
 432: LD_INT 87
 434: PUSH
 435: LD_INT 121
 437: PUSH
 438: LD_INT 4
 440: PUSH
 441: EMPTY
 442: LIST
 443: LIST
 444: LIST
 445: LIST
 446: PUSH
 447: LD_INT 33
 449: PUSH
 450: LD_INT 88
 452: PUSH
 453: LD_INT 128
 455: PUSH
 456: LD_INT 4
 458: PUSH
 459: EMPTY
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: PUSH
 465: LD_INT 32
 467: PUSH
 468: LD_INT 59
 470: PUSH
 471: LD_INT 89
 473: PUSH
 474: LD_INT 3
 476: PUSH
 477: EMPTY
 478: LIST
 479: LIST
 480: LIST
 481: LIST
 482: PUSH
 483: LD_INT 33
 485: PUSH
 486: LD_INT 69
 488: PUSH
 489: LD_INT 98
 491: PUSH
 492: LD_INT 3
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 33
 503: PUSH
 504: LD_INT 77
 506: PUSH
 507: LD_INT 103
 509: PUSH
 510: LD_INT 3
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_INT 33
 521: PUSH
 522: LD_INT 83
 524: PUSH
 525: LD_INT 105
 527: PUSH
 528: LD_INT 3
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: PUSH
 537: LD_INT 33
 539: PUSH
 540: LD_INT 71
 542: PUSH
 543: LD_INT 125
 545: PUSH
 546: LD_INT 5
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: LIST
 565: LIST
 566: PPUSH
 567: CALL 81093 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 571: LD_INT 2
 573: PPUSH
 574: LD_INT 21
 576: PUSH
 577: LD_INT 1
 579: PUSH
 580: LD_INT 3
 582: PUSH
 583: LD_INT 51
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: PUSH
 592: LD_INT 22
 594: PUSH
 595: LD_INT 1
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 52
 603: PUSH
 604: EMPTY
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: PPUSH
 614: CALL 81249 0 2
// end ;
 618: LD_VAR 0 1
 622: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 623: LD_INT 0
 625: PPUSH
// debug := 1 ;
 626: LD_ADDR_EXP 1
 630: PUSH
 631: LD_INT 1
 633: ST_TO_ADDR
// game := true ;
 634: LD_ADDR_EXP 2
 638: PUSH
 639: LD_INT 1
 641: ST_TO_ADDR
// gossudarov_arrive := false ;
 642: LD_ADDR_EXP 4
 646: PUSH
 647: LD_INT 0
 649: ST_TO_ADDR
// ru_lab_builded := false ;
 650: LD_ADDR_EXP 5
 654: PUSH
 655: LD_INT 0
 657: ST_TO_ADDR
// player_spotted := false ;
 658: LD_ADDR_EXP 6
 662: PUSH
 663: LD_INT 0
 665: ST_TO_ADDR
// first_attack := false ;
 666: LD_ADDR_EXP 7
 670: PUSH
 671: LD_INT 0
 673: ST_TO_ADDR
// ru_attackers := [ ] ;
 674: LD_ADDR_EXP 52
 678: PUSH
 679: EMPTY
 680: ST_TO_ADDR
// ar_base_spotted := false ;
 681: LD_ADDR_EXP 8
 685: PUSH
 686: LD_INT 0
 688: ST_TO_ADDR
// ar_active_attack := false ;
 689: LD_ADDR_EXP 9
 693: PUSH
 694: LD_INT 0
 696: ST_TO_ADDR
// ar_attackers := [ ] ;
 697: LD_ADDR_EXP 10
 701: PUSH
 702: EMPTY
 703: ST_TO_ADDR
// first_powell_attack := false ;
 704: LD_ADDR_EXP 11
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// abdul_escaped := true ;
 712: LD_ADDR_EXP 12
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// loss_counter := 0 ;
 720: LD_ADDR_EXP 13
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// hack_counter := 0 ;
 728: LD_ADDR_EXP 14
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// end ;
 736: LD_VAR 0 1
 740: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 741: LD_EXP 48
 745: PPUSH
 746: CALL_OW 255
 750: PUSH
 751: LD_INT 7
 753: EQUAL
 754: PUSH
 755: LD_EXP 47
 759: PPUSH
 760: CALL_OW 255
 764: PUSH
 765: LD_INT 7
 767: EQUAL
 768: AND
 769: PUSH
 770: LD_EXP 48
 774: PPUSH
 775: CALL_OW 302
 779: AND
 780: PUSH
 781: LD_EXP 47
 785: PPUSH
 786: CALL_OW 302
 790: AND
 791: IFFALSE 803
 793: GO 795
 795: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 796: LD_STRING ACH_COMRADE
 798: PPUSH
 799: CALL_OW 543
 803: END
// every 0 0$1 trigger hack_counter >= 10 do
 804: LD_EXP 14
 808: PUSH
 809: LD_INT 10
 811: GREATEREQUAL
 812: IFFALSE 824
 814: GO 816
 816: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 817: LD_STRING ACH_HACK
 819: PPUSH
 820: CALL_OW 543
 824: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 825: LD_INT 0
 827: PPUSH
 828: PPUSH
 829: PPUSH
 830: PPUSH
// uc_side := 7 ;
 831: LD_ADDR_OWVAR 20
 835: PUSH
 836: LD_INT 7
 838: ST_TO_ADDR
// uc_nation := 1 ;
 839: LD_ADDR_OWVAR 21
 843: PUSH
 844: LD_INT 1
 846: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 847: LD_ADDR_EXP 15
 851: PUSH
 852: LD_STRING JMM
 854: PPUSH
 855: LD_EXP 1
 859: NOT
 860: PPUSH
 861: LD_STRING 12a_
 863: PPUSH
 864: CALL 14288 0 3
 868: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 869: LD_EXP 15
 873: PPUSH
 874: LD_INT 71
 876: PPUSH
 877: LD_INT 23
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 887: LD_EXP 15
 891: PPUSH
 892: LD_INT 2
 894: PPUSH
 895: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 899: LD_ADDR_EXP 16
 903: PUSH
 904: LD_STRING Roth
 906: PPUSH
 907: LD_EXP 1
 911: NOT
 912: PPUSH
 913: LD_STRING 12a_
 915: PPUSH
 916: CALL 14288 0 3
 920: ST_TO_ADDR
// if Roth then
 921: LD_EXP 16
 925: IFFALSE 945
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 927: LD_EXP 16
 931: PPUSH
 932: LD_INT 71
 934: PPUSH
 935: LD_INT 21
 937: PPUSH
 938: LD_INT 0
 940: PPUSH
 941: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 945: LD_ADDR_EXP 17
 949: PUSH
 950: LD_STRING Lisa
 952: PPUSH
 953: LD_EXP 1
 957: NOT
 958: PPUSH
 959: LD_STRING 12a_
 961: PPUSH
 962: CALL 14288 0 3
 966: ST_TO_ADDR
// if Lisa then
 967: LD_EXP 17
 971: IFFALSE 988
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 973: LD_EXP 17
 977: PPUSH
 978: LD_INT 13
 980: PPUSH
 981: LD_INT 0
 983: PPUSH
 984: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 988: LD_ADDR_EXP 18
 992: PUSH
 993: LD_STRING Donaldson
 995: PPUSH
 996: LD_EXP 1
1000: NOT
1001: PPUSH
1002: LD_STRING 12a_
1004: PPUSH
1005: CALL 14288 0 3
1009: ST_TO_ADDR
// if Donaldson then
1010: LD_EXP 18
1014: IFFALSE 1031
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1016: LD_EXP 18
1020: PPUSH
1021: LD_INT 13
1023: PPUSH
1024: LD_INT 0
1026: PPUSH
1027: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1031: LD_ADDR_EXP 19
1035: PUSH
1036: LD_STRING Bobby
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_STRING 12a_
1047: PPUSH
1048: CALL 14288 0 3
1052: ST_TO_ADDR
// if Bobby then
1053: LD_EXP 19
1057: IFFALSE 1074
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1059: LD_EXP 19
1063: PPUSH
1064: LD_INT 13
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1074: LD_ADDR_EXP 20
1078: PUSH
1079: LD_STRING Cyrus
1081: PPUSH
1082: LD_EXP 1
1086: NOT
1087: PPUSH
1088: LD_STRING 12a_
1090: PPUSH
1091: CALL 14288 0 3
1095: ST_TO_ADDR
// if Cyrus then
1096: LD_EXP 20
1100: IFFALSE 1117
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1102: LD_EXP 20
1106: PPUSH
1107: LD_INT 13
1109: PPUSH
1110: LD_INT 0
1112: PPUSH
1113: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1117: LD_ADDR_EXP 21
1121: PUSH
1122: LD_STRING Denis
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_STRING 12a_
1133: PPUSH
1134: CALL 14288 0 3
1138: ST_TO_ADDR
// if Denis then
1139: LD_EXP 21
1143: IFFALSE 1160
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1145: LD_EXP 21
1149: PPUSH
1150: LD_INT 13
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1160: LD_ADDR_EXP 22
1164: PUSH
1165: LD_STRING Brown
1167: PPUSH
1168: LD_EXP 1
1172: NOT
1173: PPUSH
1174: LD_STRING 12a_
1176: PPUSH
1177: CALL 14288 0 3
1181: ST_TO_ADDR
// if Brown then
1182: LD_EXP 22
1186: IFFALSE 1203
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1188: LD_EXP 22
1192: PPUSH
1193: LD_INT 13
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1203: LD_ADDR_EXP 23
1207: PUSH
1208: LD_STRING Gladstone
1210: PPUSH
1211: LD_EXP 1
1215: NOT
1216: PPUSH
1217: LD_STRING 12a_
1219: PPUSH
1220: CALL 14288 0 3
1224: ST_TO_ADDR
// if Gladstone then
1225: LD_EXP 23
1229: IFFALSE 1246
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1231: LD_EXP 23
1235: PPUSH
1236: LD_INT 13
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1246: LD_ADDR_EXP 24
1250: PUSH
1251: LD_STRING Houten
1253: PPUSH
1254: LD_EXP 1
1258: NOT
1259: PPUSH
1260: LD_STRING 12a_
1262: PPUSH
1263: CALL 14288 0 3
1267: ST_TO_ADDR
// if Houten then
1268: LD_EXP 24
1272: IFFALSE 1289
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1274: LD_EXP 24
1278: PPUSH
1279: LD_INT 13
1281: PPUSH
1282: LD_INT 0
1284: PPUSH
1285: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1289: LD_ADDR_EXP 25
1293: PUSH
1294: LD_STRING Cornell
1296: PPUSH
1297: LD_EXP 1
1301: NOT
1302: PPUSH
1303: LD_STRING 12a_
1305: PPUSH
1306: CALL 14288 0 3
1310: ST_TO_ADDR
// if Cornel then
1311: LD_EXP 25
1315: IFFALSE 1332
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1317: LD_EXP 25
1321: PPUSH
1322: LD_INT 13
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1332: LD_ADDR_EXP 26
1336: PUSH
1337: LD_STRING Gary
1339: PPUSH
1340: LD_EXP 1
1344: NOT
1345: PPUSH
1346: LD_STRING 12a_
1348: PPUSH
1349: CALL 14288 0 3
1353: ST_TO_ADDR
// if Gary then
1354: LD_EXP 26
1358: IFFALSE 1375
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1360: LD_EXP 26
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: LD_INT 0
1370: PPUSH
1371: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1375: LD_ADDR_EXP 27
1379: PUSH
1380: LD_STRING Frank
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 12a_
1391: PPUSH
1392: CALL 14288 0 3
1396: ST_TO_ADDR
// if Frank then
1397: LD_EXP 27
1401: IFFALSE 1418
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1403: LD_EXP 27
1407: PPUSH
1408: LD_INT 13
1410: PPUSH
1411: LD_INT 0
1413: PPUSH
1414: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1418: LD_ADDR_EXP 28
1422: PUSH
1423: LD_STRING Kikuchi
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: LD_STRING 12a_
1434: PPUSH
1435: CALL 14288 0 3
1439: ST_TO_ADDR
// if Kikuchi then
1440: LD_EXP 28
1444: IFFALSE 1461
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1446: LD_EXP 28
1450: PPUSH
1451: LD_INT 13
1453: PPUSH
1454: LD_INT 0
1456: PPUSH
1457: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1461: LD_ADDR_EXP 29
1465: PUSH
1466: LD_STRING Simms
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 12a_
1477: PPUSH
1478: CALL 14288 0 3
1482: ST_TO_ADDR
// if Simms then
1483: LD_EXP 29
1487: IFFALSE 1504
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1489: LD_EXP 29
1493: PPUSH
1494: LD_INT 13
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1504: LD_ADDR_EXP 30
1508: PUSH
1509: LD_STRING Joan
1511: PPUSH
1512: LD_EXP 1
1516: NOT
1517: PPUSH
1518: LD_STRING 12a_
1520: PPUSH
1521: CALL 14288 0 3
1525: ST_TO_ADDR
// if Joan then
1526: LD_EXP 30
1530: IFFALSE 1547
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1532: LD_EXP 30
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1547: LD_ADDR_EXP 31
1551: PUSH
1552: LD_STRING DeltaDoctor
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 12a_
1563: PPUSH
1564: CALL 14288 0 3
1568: ST_TO_ADDR
// if DeltaDoctor then
1569: LD_EXP 31
1573: IFFALSE 1590
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1575: LD_EXP 31
1579: PPUSH
1580: LD_INT 13
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1590: LD_ADDR_VAR 0 4
1594: PUSH
1595: LD_STRING 12a_others
1597: PPUSH
1598: CALL_OW 31
1602: ST_TO_ADDR
// if tmp then
1603: LD_VAR 0 4
1607: IFFALSE 1641
// for i in tmp do
1609: LD_ADDR_VAR 0 3
1613: PUSH
1614: LD_VAR 0 4
1618: PUSH
1619: FOR_IN
1620: IFFALSE 1639
// PlaceUnitArea ( i , alliance_start , false ) ;
1622: LD_VAR 0 3
1626: PPUSH
1627: LD_INT 13
1629: PPUSH
1630: LD_INT 0
1632: PPUSH
1633: CALL_OW 49
1637: GO 1619
1639: POP
1640: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1641: LD_INT 3
1643: PPUSH
1644: LD_INT 3
1646: PPUSH
1647: LD_INT 3
1649: PPUSH
1650: LD_INT 12
1652: PPUSH
1653: LD_INT 100
1655: PPUSH
1656: CALL 21403 0 5
// veh := CreateVehicle ;
1660: LD_ADDR_VAR 0 2
1664: PUSH
1665: CALL_OW 45
1669: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1670: LD_VAR 0 2
1674: PPUSH
1675: LD_INT 2
1677: PPUSH
1678: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1682: LD_VAR 0 2
1686: PPUSH
1687: LD_INT 60
1689: PPUSH
1690: LD_INT 6
1692: PPUSH
1693: LD_INT 0
1695: PPUSH
1696: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1700: LD_VAR 0 2
1704: PPUSH
1705: LD_INT 4
1707: PPUSH
1708: LD_INT 30
1710: PPUSH
1711: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1715: LD_STRING 11_artifact_captured
1717: PPUSH
1718: LD_INT 0
1720: PPUSH
1721: CALL_OW 30
1725: IFFALSE 1801
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1727: LD_INT 3
1729: PPUSH
1730: LD_INT 3
1732: PPUSH
1733: LD_INT 3
1735: PPUSH
1736: LD_INT 12
1738: PPUSH
1739: LD_INT 100
1741: PPUSH
1742: CALL 21403 0 5
// veh := CreateVehicle ;
1746: LD_ADDR_VAR 0 2
1750: PUSH
1751: CALL_OW 45
1755: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1756: LD_VAR 0 2
1760: PPUSH
1761: LD_INT 3
1763: PPUSH
1764: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1768: LD_VAR 0 2
1772: PPUSH
1773: LD_INT 75
1775: PPUSH
1776: LD_INT 6
1778: PPUSH
1779: LD_INT 0
1781: PPUSH
1782: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1786: LD_VAR 0 2
1790: PPUSH
1791: LD_INT 4
1793: PPUSH
1794: LD_INT 50
1796: PPUSH
1797: CALL_OW 290
// end ; end ;
1801: LD_VAR 0 1
1805: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1806: LD_INT 0
1808: PPUSH
1809: PPUSH
1810: PPUSH
1811: PPUSH
// uc_side := 6 ;
1812: LD_ADDR_OWVAR 20
1816: PUSH
1817: LD_INT 6
1819: ST_TO_ADDR
// uc_nation := 3 ;
1820: LD_ADDR_OWVAR 21
1824: PUSH
1825: LD_INT 3
1827: ST_TO_ADDR
// InitHc ;
1828: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1832: LD_ADDR_EXP 32
1836: PUSH
1837: LD_STRING Gossudarov
1839: PPUSH
1840: CALL_OW 25
1844: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1845: LD_ADDR_EXP 33
1849: PUSH
1850: LD_STRING Kirilenkova
1852: PPUSH
1853: CALL_OW 25
1857: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1858: LD_ADDR_EXP 34
1862: PUSH
1863: LD_STRING Titov
1865: PPUSH
1866: CALL_OW 25
1870: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1871: LD_ADDR_EXP 39
1875: PUSH
1876: LD_STRING Oblukov
1878: PPUSH
1879: CALL_OW 25
1883: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1884: LD_ADDR_EXP 36
1888: PUSH
1889: LD_STRING Dolgov
1891: PPUSH
1892: CALL_OW 25
1896: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1897: LD_ADDR_EXP 37
1901: PUSH
1902: LD_STRING Petrosyan
1904: PPUSH
1905: CALL_OW 25
1909: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1910: LD_ADDR_EXP 38
1914: PUSH
1915: LD_STRING Scholtze
1917: PPUSH
1918: CALL_OW 25
1922: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1923: LD_ADDR_EXP 40
1927: PUSH
1928: LD_STRING Kapitsova
1930: PPUSH
1931: CALL_OW 25
1935: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_EXP 32
1945: PUSH
1946: LD_EXP 33
1950: PUSH
1951: LD_EXP 34
1955: PUSH
1956: LD_EXP 39
1960: PUSH
1961: LD_EXP 36
1965: PUSH
1966: LD_EXP 37
1970: PUSH
1971: LD_EXP 38
1975: PUSH
1976: LD_EXP 40
1980: PUSH
1981: EMPTY
1982: LIST
1983: LIST
1984: LIST
1985: LIST
1986: LIST
1987: LIST
1988: LIST
1989: LIST
1990: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1991: LD_INT 1
1993: PPUSH
1994: LD_INT 4
1996: PPUSH
1997: LD_INT 8
1999: PPUSH
2000: CALL_OW 380
// un := CreateHuman ;
2004: LD_ADDR_VAR 0 4
2008: PUSH
2009: CALL_OW 44
2013: ST_TO_ADDR
// tmp := tmp ^ un ;
2014: LD_ADDR_VAR 0 2
2018: PUSH
2019: LD_VAR 0 2
2023: PUSH
2024: LD_VAR 0 4
2028: ADD
2029: ST_TO_ADDR
// for i in tmp do
2030: LD_ADDR_VAR 0 3
2034: PUSH
2035: LD_VAR 0 2
2039: PUSH
2040: FOR_IN
2041: IFFALSE 2060
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2043: LD_VAR 0 3
2047: PPUSH
2048: LD_INT 14
2050: PPUSH
2051: LD_INT 0
2053: PPUSH
2054: CALL_OW 49
2058: GO 2040
2060: POP
2061: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2062: LD_VAR 0 2
2066: PPUSH
2067: LD_EXP 3
2071: PPUSH
2072: CALL_OW 250
2076: PPUSH
2077: LD_EXP 3
2081: PPUSH
2082: CALL_OW 251
2086: PPUSH
2087: CALL_OW 111
// end ;
2091: LD_VAR 0 1
2095: RET
// export function PrepareBelkov ; begin
2096: LD_INT 0
2098: PPUSH
// uc_side := 4 ;
2099: LD_ADDR_OWVAR 20
2103: PUSH
2104: LD_INT 4
2106: ST_TO_ADDR
// uc_nation := 3 ;
2107: LD_ADDR_OWVAR 21
2111: PUSH
2112: LD_INT 3
2114: ST_TO_ADDR
// InitHc ;
2115: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2119: LD_ADDR_EXP 47
2123: PUSH
2124: LD_STRING Belkov
2126: PPUSH
2127: CALL_OW 25
2131: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2132: LD_EXP 47
2136: PPUSH
2137: LD_INT 14
2139: PPUSH
2140: LD_INT 0
2142: PPUSH
2143: CALL_OW 49
// end ;
2147: LD_VAR 0 1
2151: RET
// export function PrepareGnyevko ; begin
2152: LD_INT 0
2154: PPUSH
// uc_side := 4 ;
2155: LD_ADDR_OWVAR 20
2159: PUSH
2160: LD_INT 4
2162: ST_TO_ADDR
// uc_nation := 3 ;
2163: LD_ADDR_OWVAR 21
2167: PUSH
2168: LD_INT 3
2170: ST_TO_ADDR
// InitHc ;
2171: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2175: LD_ADDR_EXP 48
2179: PUSH
2180: LD_STRING Gnyevko
2182: PPUSH
2183: CALL_OW 25
2187: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2188: LD_EXP 48
2192: PPUSH
2193: LD_INT 14
2195: PPUSH
2196: LD_INT 0
2198: PPUSH
2199: CALL_OW 49
// end ;
2203: LD_VAR 0 1
2207: RET
// export function PrepareBurlak ; var i , tmp ; begin
2208: LD_INT 0
2210: PPUSH
2211: PPUSH
2212: PPUSH
// uc_side := 4 ;
2213: LD_ADDR_OWVAR 20
2217: PUSH
2218: LD_INT 4
2220: ST_TO_ADDR
// uc_nation := 3 ;
2221: LD_ADDR_OWVAR 21
2225: PUSH
2226: LD_INT 3
2228: ST_TO_ADDR
// InitHc ;
2229: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2233: LD_ADDR_EXP 46
2237: PUSH
2238: LD_STRING Burlak
2240: PPUSH
2241: CALL_OW 25
2245: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2246: LD_INT 24
2248: PUSH
2249: LD_INT 23
2251: PUSH
2252: LD_INT 22
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: LIST
2259: PUSH
2260: LD_OWVAR 67
2264: ARRAY
2265: PPUSH
2266: LD_INT 1
2268: PPUSH
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 45
2274: PUSH
2275: LD_INT 44
2277: PUSH
2278: LD_INT 43
2280: PUSH
2281: EMPTY
2282: LIST
2283: LIST
2284: LIST
2285: PUSH
2286: LD_OWVAR 67
2290: ARRAY
2291: PPUSH
2292: LD_INT 0
2294: PPUSH
2295: CALL 21403 0 5
// Masha := CreateVehicle ;
2299: LD_ADDR_EXP 49
2303: PUSH
2304: CALL_OW 45
2308: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2309: LD_EXP 49
2313: PUSH
2314: LD_EXP 46
2318: PUSH
2319: EMPTY
2320: LIST
2321: LIST
2322: PPUSH
2323: LD_INT 499
2325: PPUSH
2326: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2330: LD_EXP 49
2334: PPUSH
2335: LD_INT 3
2337: PPUSH
2338: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2342: LD_EXP 49
2346: PPUSH
2347: LD_INT 1
2349: PPUSH
2350: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2354: LD_INT 1
2356: PPUSH
2357: LD_INT 18
2359: PPUSH
2360: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2364: LD_INT 35
2366: PPUSH
2367: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2371: LD_ADDR_VAR 0 3
2375: PUSH
2376: LD_INT 18
2378: PPUSH
2379: EMPTY
2380: PPUSH
2381: CALL_OW 70
2385: ST_TO_ADDR
// if tmp then
2386: LD_VAR 0 3
2390: IFFALSE 2424
// for i in tmp do
2392: LD_ADDR_VAR 0 2
2396: PUSH
2397: LD_VAR 0 3
2401: PUSH
2402: FOR_IN
2403: IFFALSE 2422
// ComMoveXY ( i , 114 , 9 ) ;
2405: LD_VAR 0 2
2409: PPUSH
2410: LD_INT 114
2412: PPUSH
2413: LD_INT 9
2415: PPUSH
2416: CALL_OW 111
2420: GO 2402
2422: POP
2423: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2424: LD_INT 18
2426: PPUSH
2427: EMPTY
2428: PPUSH
2429: CALL_OW 70
2433: NOT
2434: PUSH
2435: LD_INT 123
2437: PPUSH
2438: LD_INT 3
2440: PPUSH
2441: CALL_OW 428
2445: PUSH
2446: LD_INT 0
2448: EQUAL
2449: AND
2450: IFFALSE 2364
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2452: LD_EXP 49
2456: PPUSH
2457: LD_INT 123
2459: PPUSH
2460: LD_INT 3
2462: PPUSH
2463: LD_INT 0
2465: PPUSH
2466: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2470: LD_EXP 46
2474: PPUSH
2475: LD_INT 125
2477: PPUSH
2478: LD_INT 1
2480: PPUSH
2481: LD_INT 0
2483: PPUSH
2484: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2488: LD_EXP 46
2492: PPUSH
2493: LD_EXP 49
2497: PPUSH
2498: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2502: LD_INT 10
2504: PPUSH
2505: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2509: LD_EXP 49
2513: PPUSH
2514: LD_INT 110
2516: PPUSH
2517: LD_INT 10
2519: PPUSH
2520: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2524: LD_ADDR_EXP 42
2528: PUSH
2529: LD_STRING Petrovova
2531: PPUSH
2532: CALL_OW 25
2536: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2537: LD_ADDR_EXP 44
2541: PUSH
2542: LD_STRING Kuzmov
2544: PPUSH
2545: CALL_OW 25
2549: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2550: LD_ADDR_EXP 43
2554: PUSH
2555: LD_STRING Kovalyuk
2557: PPUSH
2558: CALL_OW 25
2562: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2563: LD_ADDR_EXP 41
2567: PUSH
2568: LD_STRING Lipshchin
2570: PPUSH
2571: CALL_OW 25
2575: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2576: LD_ADDR_EXP 45
2580: PUSH
2581: LD_STRING Karamazov
2583: PPUSH
2584: CALL_OW 25
2588: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2589: LD_ADDR_VAR 0 3
2593: PUSH
2594: LD_EXP 42
2598: PUSH
2599: LD_EXP 44
2603: PUSH
2604: LD_EXP 43
2608: PUSH
2609: LD_EXP 41
2613: PUSH
2614: LD_EXP 45
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: LIST
2623: LIST
2624: LIST
2625: ST_TO_ADDR
// for i in tmp do
2626: LD_ADDR_VAR 0 2
2630: PUSH
2631: LD_VAR 0 3
2635: PUSH
2636: FOR_IN
2637: IFFALSE 2676
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2639: LD_VAR 0 2
2643: PPUSH
2644: LD_INT 399
2646: PPUSH
2647: LD_INT 799
2649: PPUSH
2650: CALL_OW 12
2654: PPUSH
2655: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2659: LD_VAR 0 2
2663: PPUSH
2664: LD_INT 19
2666: PPUSH
2667: LD_INT 0
2669: PPUSH
2670: CALL_OW 49
// end ;
2674: GO 2636
2676: POP
2677: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2678: LD_VAR 0 3
2682: PPUSH
2683: LD_INT 116
2685: PPUSH
2686: LD_INT 8
2688: PPUSH
2689: CALL_OW 111
// AddComHold ( tmp ) ;
2693: LD_VAR 0 3
2697: PPUSH
2698: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2702: LD_ADDR_VAR 0 2
2706: PUSH
2707: LD_VAR 0 3
2711: PPUSH
2712: LD_INT 25
2714: PUSH
2715: LD_INT 1
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: PPUSH
2722: CALL_OW 72
2726: PUSH
2727: FOR_IN
2728: IFFALSE 2768
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2730: LD_VAR 0 2
2734: PPUSH
2735: LD_INT 20
2737: PPUSH
2738: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2742: LD_VAR 0 2
2746: PPUSH
2747: LD_INT 147
2749: PPUSH
2750: LD_INT 45
2752: PPUSH
2753: CALL_OW 178
// AddComCrawl ( i ) ;
2757: LD_VAR 0 2
2761: PPUSH
2762: CALL_OW 197
// end ;
2766: GO 2727
2768: POP
2769: POP
// repeat wait ( 0 0$1 ) ;
2770: LD_INT 35
2772: PPUSH
2773: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2777: LD_EXP 49
2781: PPUSH
2782: LD_INT 110
2784: PPUSH
2785: LD_INT 10
2787: PPUSH
2788: CALL_OW 307
2792: PUSH
2793: LD_EXP 49
2797: PPUSH
2798: CALL_OW 305
2802: NOT
2803: OR
2804: IFFALSE 2770
// ComStop ( Burlak ) ;
2806: LD_EXP 46
2810: PPUSH
2811: CALL_OW 141
// AddComHold ( Burlak ) ;
2815: LD_EXP 46
2819: PPUSH
2820: CALL_OW 200
// end ; end_of_file
2824: LD_VAR 0 1
2828: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2829: LD_INT 0
2831: PPUSH
2832: PPUSH
2833: PPUSH
2834: PPUSH
// uc_side := 3 ;
2835: LD_ADDR_OWVAR 20
2839: PUSH
2840: LD_INT 3
2842: ST_TO_ADDR
// uc_nation := 3 ;
2843: LD_ADDR_OWVAR 21
2847: PUSH
2848: LD_INT 3
2850: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2851: LD_ADDR_EXP 50
2855: PUSH
2856: LD_INT 47
2858: PPUSH
2859: LD_INT 4
2861: PPUSH
2862: LD_STRING 
2864: PPUSH
2865: LD_INT 7
2867: PUSH
2868: LD_INT 8
2870: PUSH
2871: LD_INT 9
2873: PUSH
2874: EMPTY
2875: LIST
2876: LIST
2877: LIST
2878: PUSH
2879: LD_OWVAR 67
2883: ARRAY
2884: PPUSH
2885: LD_INT 10000
2887: PUSH
2888: LD_INT 3000
2890: PUSH
2891: LD_INT 300
2893: PUSH
2894: EMPTY
2895: LIST
2896: LIST
2897: LIST
2898: PPUSH
2899: LD_INT 9
2901: PUSH
2902: LD_INT 5
2904: PUSH
2905: LD_INT 6
2907: PUSH
2908: LD_INT 6
2910: PUSH
2911: EMPTY
2912: LIST
2913: LIST
2914: LIST
2915: LIST
2916: PPUSH
2917: CALL 24812 0 6
2921: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2922: LD_ADDR_EXP 59
2926: PUSH
2927: LD_EXP 59
2931: PPUSH
2932: LD_INT 2
2934: PPUSH
2935: LD_EXP 50
2939: PPUSH
2940: CALL_OW 1
2944: ST_TO_ADDR
// tmp := [ ] ;
2945: LD_ADDR_VAR 0 4
2949: PUSH
2950: EMPTY
2951: ST_TO_ADDR
// for i = 1 to 4 do
2952: LD_ADDR_VAR 0 2
2956: PUSH
2957: DOUBLE
2958: LD_INT 1
2960: DEC
2961: ST_TO_ADDR
2962: LD_INT 4
2964: PUSH
2965: FOR_TO
2966: IFFALSE 3059
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2968: LD_INT 22
2970: PPUSH
2971: LD_INT 3
2973: PPUSH
2974: LD_INT 3
2976: PPUSH
2977: LD_INT 43
2979: PUSH
2980: LD_INT 45
2982: PUSH
2983: LD_INT 45
2985: PUSH
2986: LD_INT 44
2988: PUSH
2989: EMPTY
2990: LIST
2991: LIST
2992: LIST
2993: LIST
2994: PUSH
2995: LD_VAR 0 2
2999: PUSH
3000: LD_INT 4
3002: MOD
3003: PUSH
3004: LD_INT 1
3006: PLUS
3007: ARRAY
3008: PPUSH
3009: LD_INT 100
3011: PPUSH
3012: CALL 21403 0 5
// veh := CreateVehicle ;
3016: LD_ADDR_VAR 0 3
3020: PUSH
3021: CALL_OW 45
3025: ST_TO_ADDR
// tmp := tmp ^ veh ;
3026: LD_ADDR_VAR 0 4
3030: PUSH
3031: LD_VAR 0 4
3035: PUSH
3036: LD_VAR 0 3
3040: ADD
3041: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3042: LD_VAR 0 3
3046: PPUSH
3047: LD_INT 2
3049: PPUSH
3050: LD_INT 0
3052: PPUSH
3053: CALL_OW 49
// end ;
3057: GO 2965
3059: POP
3060: POP
// russian_guard := tmp ;
3061: LD_ADDR_EXP 51
3065: PUSH
3066: LD_VAR 0 4
3070: ST_TO_ADDR
// end ;
3071: LD_VAR 0 1
3075: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3076: LD_INT 47
3078: PPUSH
3079: CALL_OW 302
3083: PUSH
3084: LD_EXP 6
3088: AND
3089: IFFALSE 3691
3091: GO 3093
3093: DISABLE
3094: LD_INT 0
3096: PPUSH
3097: PPUSH
3098: PPUSH
3099: PPUSH
3100: PPUSH
3101: PPUSH
// begin enable ;
3102: ENABLE
// base := 2 ;
3103: LD_ADDR_VAR 0 2
3107: PUSH
3108: LD_INT 2
3110: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3111: LD_ADDR_VAR 0 4
3115: PUSH
3116: LD_INT 0
3118: PUSH
3119: LD_INT 0
3121: PUSH
3122: LD_INT 0
3124: PUSH
3125: LD_INT 0
3127: PUSH
3128: LD_INT 0
3130: PUSH
3131: LD_INT 0
3133: PUSH
3134: LD_INT 0
3136: PUSH
3137: LD_INT 0
3139: PUSH
3140: LD_INT 1
3142: PUSH
3143: LD_INT 0
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: LIST
3155: LIST
3156: LIST
3157: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3158: LD_ADDR_VAR 0 3
3162: PUSH
3163: LD_INT 22
3165: PUSH
3166: LD_INT 1
3168: PUSH
3169: LD_INT 3
3171: PUSH
3172: LD_INT 45
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 21
3183: PUSH
3184: LD_INT 1
3186: PUSH
3187: LD_INT 3
3189: PUSH
3190: LD_INT 45
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: PUSH
3199: LD_INT 22
3201: PUSH
3202: LD_INT 1
3204: PUSH
3205: LD_INT 3
3207: PUSH
3208: LD_INT 45
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 23
3219: PUSH
3220: LD_INT 1
3222: PUSH
3223: LD_INT 3
3225: PUSH
3226: LD_INT 46
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: LIST
3239: LIST
3240: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3241: LD_ADDR_VAR 0 1
3245: PUSH
3246: DOUBLE
3247: LD_INT 1
3249: DEC
3250: ST_TO_ADDR
3251: LD_OWVAR 67
3255: PUSH
3256: LD_OWVAR 1
3260: PUSH
3261: LD_INT 21000
3263: DIV
3264: PLUS
3265: PUSH
3266: FOR_TO
3267: IFFALSE 3355
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3269: LD_ADDR_VAR 0 3
3273: PUSH
3274: LD_VAR 0 3
3278: PPUSH
3279: LD_VAR 0 3
3283: PUSH
3284: LD_INT 1
3286: PLUS
3287: PPUSH
3288: LD_INT 23
3290: PUSH
3291: LD_INT 24
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PUSH
3298: LD_INT 1
3300: PPUSH
3301: LD_INT 2
3303: PPUSH
3304: CALL_OW 12
3308: ARRAY
3309: PUSH
3310: LD_INT 1
3312: PUSH
3313: LD_INT 3
3315: PUSH
3316: LD_INT 46
3318: PUSH
3319: LD_INT 47
3321: PUSH
3322: LD_INT 45
3324: PUSH
3325: EMPTY
3326: LIST
3327: LIST
3328: LIST
3329: PUSH
3330: LD_INT 1
3332: PPUSH
3333: LD_INT 3
3335: PPUSH
3336: CALL_OW 12
3340: ARRAY
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: LIST
3346: LIST
3347: PPUSH
3348: CALL_OW 2
3352: ST_TO_ADDR
3353: GO 3266
3355: POP
3356: POP
// MC_InsertProduceList ( base , tmp ) ;
3357: LD_VAR 0 2
3361: PPUSH
3362: LD_VAR 0 3
3366: PPUSH
3367: CALL 81249 0 2
// repeat wait ( 0 0$1 ) ;
3371: LD_INT 35
3373: PPUSH
3374: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3378: LD_EXP 78
3382: PUSH
3383: LD_VAR 0 2
3387: ARRAY
3388: PUSH
3389: LD_INT 6
3391: GREATER
3392: IFFALSE 3371
// wait ( 0 0$20 ) ;
3394: LD_INT 700
3396: PPUSH
3397: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3401: LD_ADDR_VAR 0 5
3405: PUSH
3406: LD_INT 71
3408: PUSH
3409: LD_INT 19
3411: PUSH
3412: EMPTY
3413: LIST
3414: LIST
3415: PUSH
3416: LD_INT 91
3418: PUSH
3419: LD_INT 67
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PUSH
3426: LD_INT 52
3428: PUSH
3429: LD_INT 44
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PUSH
3436: LD_INT 68
3438: PUSH
3439: LD_INT 48
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: PUSH
3446: EMPTY
3447: LIST
3448: LIST
3449: LIST
3450: LIST
3451: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_EXP 78
3461: PUSH
3462: LD_VAR 0 2
3466: ARRAY
3467: PUSH
3468: LD_EXP 78
3472: PUSH
3473: LD_VAR 0 2
3477: ARRAY
3478: PPUSH
3479: LD_INT 2
3481: PUSH
3482: LD_INT 34
3484: PUSH
3485: LD_INT 51
3487: PUSH
3488: EMPTY
3489: LIST
3490: LIST
3491: PUSH
3492: LD_INT 34
3494: PUSH
3495: LD_INT 52
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: LIST
3506: PPUSH
3507: CALL_OW 72
3511: DIFF
3512: ST_TO_ADDR
// if not attackers then
3513: LD_VAR 0 6
3517: NOT
3518: IFFALSE 3522
// exit ;
3520: GO 3691
// ru_attackers := attackers ;
3522: LD_ADDR_EXP 52
3526: PUSH
3527: LD_VAR 0 6
3531: ST_TO_ADDR
// for i = 1 to attackers do
3532: LD_ADDR_VAR 0 1
3536: PUSH
3537: DOUBLE
3538: LD_INT 1
3540: DEC
3541: ST_TO_ADDR
3542: LD_VAR 0 6
3546: PUSH
3547: FOR_TO
3548: IFFALSE 3625
// begin case i mod 3 of 0 :
3550: LD_VAR 0 1
3554: PUSH
3555: LD_INT 3
3557: MOD
3558: PUSH
3559: LD_INT 0
3561: DOUBLE
3562: EQUAL
3563: IFTRUE 3567
3565: GO 3570
3567: POP
// ; 1 :
3568: GO 3623
3570: LD_INT 1
3572: DOUBLE
3573: EQUAL
3574: IFTRUE 3578
3576: GO 3596
3578: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3579: LD_VAR 0 1
3583: PPUSH
3584: LD_INT 32
3586: PPUSH
3587: LD_INT 49
3589: PPUSH
3590: CALL_OW 114
3594: GO 3623
3596: LD_INT 2
3598: DOUBLE
3599: EQUAL
3600: IFTRUE 3604
3602: GO 3622
3604: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3605: LD_VAR 0 1
3609: PPUSH
3610: LD_INT 117
3612: PPUSH
3613: LD_INT 107
3615: PPUSH
3616: CALL_OW 114
3620: GO 3623
3622: POP
// end ;
3623: GO 3547
3625: POP
3626: POP
// repeat wait ( 0 0$1 ) ;
3627: LD_INT 35
3629: PPUSH
3630: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3634: LD_VAR 0 6
3638: PPUSH
3639: LD_INT 60
3641: PUSH
3642: EMPTY
3643: LIST
3644: PPUSH
3645: CALL_OW 72
3649: NOT
3650: IFFALSE 3627
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3652: LD_VAR 0 2
3656: PPUSH
3657: LD_VAR 0 6
3661: PPUSH
3662: LD_VAR 0 5
3666: PPUSH
3667: LD_VAR 0 4
3671: PPUSH
3672: CALL 81434 0 4
// if not first_attack then
3676: LD_EXP 7
3680: NOT
3681: IFFALSE 3691
// first_attack := true ;
3683: LD_ADDR_EXP 7
3687: PUSH
3688: LD_INT 1
3690: ST_TO_ADDR
// end ; end_of_file
3691: PPOPN 6
3693: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3694: LD_INT 0
3696: PPUSH
3697: PPUSH
3698: PPUSH
3699: PPUSH
3700: PPUSH
3701: PPUSH
3702: PPUSH
// uc_side := 2 ;
3703: LD_ADDR_OWVAR 20
3707: PUSH
3708: LD_INT 2
3710: ST_TO_ADDR
// uc_nation := 2 ;
3711: LD_ADDR_OWVAR 21
3715: PUSH
3716: LD_INT 2
3718: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3719: LD_ADDR_EXP 55
3723: PUSH
3724: LD_STRING Abdul
3726: PPUSH
3727: CALL_OW 25
3731: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3732: LD_EXP 55
3736: PPUSH
3737: LD_INT 11
3739: PPUSH
3740: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3744: LD_EXP 55
3748: PPUSH
3749: LD_INT 1
3751: PPUSH
3752: CALL_OW 52
// vc_chassis := 31 ;
3756: LD_ADDR_OWVAR 37
3760: PUSH
3761: LD_INT 31
3763: ST_TO_ADDR
// vc_control := control_rider ;
3764: LD_ADDR_OWVAR 38
3768: PUSH
3769: LD_INT 4
3771: ST_TO_ADDR
// mastodont := CreateVehicle ;
3772: LD_ADDR_EXP 56
3776: PUSH
3777: CALL_OW 45
3781: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3782: LD_EXP 56
3786: PPUSH
3787: LD_INT 153
3789: PPUSH
3790: LD_INT 71
3792: PPUSH
3793: LD_INT 0
3795: PPUSH
3796: CALL_OW 48
// InitVc ;
3800: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3804: LD_ADDR_EXP 53
3808: PUSH
3809: LD_INT 1
3811: PPUSH
3812: LD_INT 3
3814: PPUSH
3815: LD_STRING 
3817: PPUSH
3818: LD_INT 7
3820: PUSH
3821: LD_INT 8
3823: PUSH
3824: LD_INT 9
3826: PUSH
3827: EMPTY
3828: LIST
3829: LIST
3830: LIST
3831: PUSH
3832: LD_OWVAR 67
3836: ARRAY
3837: PPUSH
3838: LD_INT 5000
3840: PUSH
3841: LD_INT 1000
3843: PUSH
3844: LD_INT 300
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: LIST
3851: PPUSH
3852: LD_INT 22
3854: PUSH
3855: LD_INT 5
3857: PUSH
3858: LD_INT 6
3860: PUSH
3861: LD_INT 9
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: LIST
3868: LIST
3869: PPUSH
3870: CALL 24812 0 6
3874: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3875: LD_ADDR_EXP 59
3879: PUSH
3880: LD_EXP 59
3884: PPUSH
3885: LD_INT 1
3887: PPUSH
3888: LD_EXP 53
3892: PPUSH
3893: CALL_OW 1
3897: ST_TO_ADDR
// tmp := [ ] ;
3898: LD_ADDR_VAR 0 4
3902: PUSH
3903: EMPTY
3904: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3905: LD_ADDR_OWVAR 37
3909: PUSH
3910: LD_INT 14
3912: ST_TO_ADDR
// vc_engine := engine_siberite ;
3913: LD_ADDR_OWVAR 39
3917: PUSH
3918: LD_INT 3
3920: ST_TO_ADDR
// vc_control := control_manual ;
3921: LD_ADDR_OWVAR 38
3925: PUSH
3926: LD_INT 1
3928: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3929: LD_ADDR_OWVAR 40
3933: PUSH
3934: LD_INT 31
3936: ST_TO_ADDR
// for i = 1 to 3 do
3937: LD_ADDR_VAR 0 2
3941: PUSH
3942: DOUBLE
3943: LD_INT 1
3945: DEC
3946: ST_TO_ADDR
3947: LD_INT 3
3949: PUSH
3950: FOR_TO
3951: IFFALSE 4195
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3953: LD_ADDR_VAR 0 5
3957: PUSH
3958: LD_INT 153
3960: PUSH
3961: LD_INT 71
3963: PUSH
3964: EMPTY
3965: LIST
3966: LIST
3967: PUSH
3968: LD_INT 155
3970: PUSH
3971: LD_INT 81
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PUSH
3978: EMPTY
3979: LIST
3980: LIST
3981: PUSH
3982: LD_VAR 0 2
3986: PUSH
3987: LD_INT 2
3989: MOD
3990: PUSH
3991: LD_INT 1
3993: PLUS
3994: ARRAY
3995: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3996: LD_INT 0
3998: PPUSH
3999: LD_INT 3
4001: PPUSH
4002: LD_INT 7
4004: PUSH
4005: LD_INT 8
4007: PUSH
4008: LD_INT 9
4010: PUSH
4011: EMPTY
4012: LIST
4013: LIST
4014: LIST
4015: PUSH
4016: LD_OWVAR 67
4020: ARRAY
4021: PPUSH
4022: CALL_OW 380
// un := CreateVehicle ;
4026: LD_ADDR_VAR 0 6
4030: PUSH
4031: CALL_OW 45
4035: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4036: LD_VAR 0 6
4040: PPUSH
4041: LD_INT 0
4043: PPUSH
4044: LD_INT 5
4046: PPUSH
4047: CALL_OW 12
4051: PPUSH
4052: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4056: LD_VAR 0 6
4060: PPUSH
4061: LD_VAR 0 5
4065: PUSH
4066: LD_INT 1
4068: ARRAY
4069: PPUSH
4070: LD_VAR 0 5
4074: PUSH
4075: LD_INT 2
4077: ARRAY
4078: PPUSH
4079: LD_INT 6
4081: PPUSH
4082: LD_INT 0
4084: PPUSH
4085: CALL_OW 50
// un2 := CreateHuman ;
4089: LD_ADDR_VAR 0 7
4093: PUSH
4094: CALL_OW 44
4098: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4099: LD_VAR 0 7
4103: PPUSH
4104: LD_VAR 0 6
4108: PPUSH
4109: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4113: LD_ADDR_EXP 59
4117: PUSH
4118: LD_EXP 59
4122: PPUSH
4123: LD_INT 1
4125: PUSH
4126: LD_EXP 59
4130: PUSH
4131: LD_INT 1
4133: ARRAY
4134: PUSH
4135: LD_INT 1
4137: PLUS
4138: PUSH
4139: EMPTY
4140: LIST
4141: LIST
4142: PPUSH
4143: LD_VAR 0 6
4147: PPUSH
4148: CALL 21525 0 3
4152: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4153: LD_ADDR_EXP 59
4157: PUSH
4158: LD_EXP 59
4162: PPUSH
4163: LD_INT 1
4165: PUSH
4166: LD_EXP 59
4170: PUSH
4171: LD_INT 1
4173: ARRAY
4174: PUSH
4175: LD_INT 1
4177: PLUS
4178: PUSH
4179: EMPTY
4180: LIST
4181: LIST
4182: PPUSH
4183: LD_VAR 0 7
4187: PPUSH
4188: CALL 21525 0 3
4192: ST_TO_ADDR
// end ;
4193: GO 3950
4195: POP
4196: POP
// for i = 1 to 5 do
4197: LD_ADDR_VAR 0 2
4201: PUSH
4202: DOUBLE
4203: LD_INT 1
4205: DEC
4206: ST_TO_ADDR
4207: LD_INT 5
4209: PUSH
4210: FOR_TO
4211: IFFALSE 4304
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4213: LD_INT 14
4215: PPUSH
4216: LD_INT 3
4218: PPUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 25
4224: PUSH
4225: LD_INT 28
4227: PUSH
4228: LD_INT 28
4230: PUSH
4231: LD_INT 26
4233: PUSH
4234: EMPTY
4235: LIST
4236: LIST
4237: LIST
4238: LIST
4239: PUSH
4240: LD_VAR 0 2
4244: PUSH
4245: LD_INT 4
4247: MOD
4248: PUSH
4249: LD_INT 1
4251: PLUS
4252: ARRAY
4253: PPUSH
4254: LD_INT 100
4256: PPUSH
4257: CALL 21403 0 5
// veh := CreateVehicle ;
4261: LD_ADDR_VAR 0 3
4265: PUSH
4266: CALL_OW 45
4270: ST_TO_ADDR
// tmp := tmp ^ veh ;
4271: LD_ADDR_VAR 0 4
4275: PUSH
4276: LD_VAR 0 4
4280: PUSH
4281: LD_VAR 0 3
4285: ADD
4286: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4287: LD_VAR 0 3
4291: PPUSH
4292: LD_INT 1
4294: PPUSH
4295: LD_INT 0
4297: PPUSH
4298: CALL_OW 49
// end ;
4302: GO 4210
4304: POP
4305: POP
// arabian_guard := tmp ;
4306: LD_ADDR_EXP 54
4310: PUSH
4311: LD_VAR 0 4
4315: ST_TO_ADDR
// end ;
4316: LD_VAR 0 1
4320: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4321: LD_INT 22
4323: PUSH
4324: LD_INT 7
4326: PUSH
4327: EMPTY
4328: LIST
4329: LIST
4330: PUSH
4331: LD_INT 91
4333: PUSH
4334: LD_INT 1
4336: PUSH
4337: LD_INT 12
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: LIST
4344: PUSH
4345: EMPTY
4346: LIST
4347: LIST
4348: PPUSH
4349: CALL_OW 69
4353: PUSH
4354: LD_EXP 56
4358: PPUSH
4359: CALL_OW 256
4363: PUSH
4364: LD_INT 990
4366: LESS
4367: OR
4368: PUSH
4369: LD_EXP 55
4373: PPUSH
4374: CALL_OW 256
4378: PUSH
4379: LD_INT 990
4381: LESS
4382: OR
4383: IFFALSE 4526
4385: GO 4387
4387: DISABLE
// begin if IsInUnit ( Abdul ) then
4388: LD_EXP 55
4392: PPUSH
4393: CALL_OW 310
4397: IFFALSE 4408
// ComExitBuilding ( Abdul ) ;
4399: LD_EXP 55
4403: PPUSH
4404: CALL_OW 122
// if Mastodont then
4408: LD_EXP 56
4412: IFFALSE 4429
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4414: LD_EXP 56
4418: PPUSH
4419: LD_INT 205
4421: PPUSH
4422: LD_INT 132
4424: PPUSH
4425: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4429: LD_EXP 55
4433: PPUSH
4434: LD_INT 205
4436: PPUSH
4437: LD_INT 132
4439: PPUSH
4440: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4444: LD_INT 35
4446: PPUSH
4447: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4451: LD_EXP 55
4455: PPUSH
4456: LD_INT 21
4458: PPUSH
4459: CALL_OW 308
4463: IFFALSE 4444
// RemoveUnit ( Abdul ) ;
4465: LD_EXP 55
4469: PPUSH
4470: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4474: LD_INT 35
4476: PPUSH
4477: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4481: LD_EXP 56
4485: PPUSH
4486: LD_INT 21
4488: PPUSH
4489: CALL_OW 308
4493: PUSH
4494: LD_EXP 56
4498: PPUSH
4499: CALL_OW 301
4503: OR
4504: IFFALSE 4474
// if IsOk ( Mastodont ) then
4506: LD_EXP 56
4510: PPUSH
4511: CALL_OW 302
4515: IFFALSE 4526
// RemoveUnit ( Mastodont ) ;
4517: LD_EXP 56
4521: PPUSH
4522: CALL_OW 64
// end ;
4526: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4527: LD_EXP 55
4531: PPUSH
4532: CALL_OW 301
4536: PUSH
4537: LD_INT 22
4539: PUSH
4540: LD_INT 2
4542: PUSH
4543: EMPTY
4544: LIST
4545: LIST
4546: PUSH
4547: LD_INT 2
4549: PUSH
4550: LD_INT 25
4552: PUSH
4553: LD_INT 1
4555: PUSH
4556: EMPTY
4557: LIST
4558: LIST
4559: PUSH
4560: LD_INT 25
4562: PUSH
4563: LD_INT 2
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: PUSH
4570: LD_INT 25
4572: PUSH
4573: LD_INT 3
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: PUSH
4580: LD_INT 25
4582: PUSH
4583: LD_INT 4
4585: PUSH
4586: EMPTY
4587: LIST
4588: LIST
4589: PUSH
4590: LD_INT 25
4592: PUSH
4593: LD_INT 8
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: PUSH
4600: EMPTY
4601: LIST
4602: LIST
4603: LIST
4604: LIST
4605: LIST
4606: LIST
4607: PUSH
4608: EMPTY
4609: LIST
4610: LIST
4611: PPUSH
4612: CALL_OW 69
4616: PUSH
4617: LD_INT 16
4619: PUSH
4620: LD_INT 19
4622: PUSH
4623: LD_INT 22
4625: PUSH
4626: EMPTY
4627: LIST
4628: LIST
4629: LIST
4630: PUSH
4631: LD_OWVAR 67
4635: ARRAY
4636: LESS
4637: OR
4638: IFFALSE 5311
4640: GO 4642
4642: DISABLE
4643: LD_INT 0
4645: PPUSH
4646: PPUSH
4647: PPUSH
4648: PPUSH
4649: PPUSH
4650: PPUSH
// begin MC_Kill ( 1 ) ;
4651: LD_INT 1
4653: PPUSH
4654: CALL 57685 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4658: LD_ADDR_VAR 0 2
4662: PUSH
4663: LD_INT 22
4665: PUSH
4666: LD_INT 2
4668: PUSH
4669: EMPTY
4670: LIST
4671: LIST
4672: PUSH
4673: LD_INT 2
4675: PUSH
4676: LD_INT 25
4678: PUSH
4679: LD_INT 1
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 25
4688: PUSH
4689: LD_INT 2
4691: PUSH
4692: EMPTY
4693: LIST
4694: LIST
4695: PUSH
4696: LD_INT 25
4698: PUSH
4699: LD_INT 3
4701: PUSH
4702: EMPTY
4703: LIST
4704: LIST
4705: PUSH
4706: LD_INT 25
4708: PUSH
4709: LD_INT 4
4711: PUSH
4712: EMPTY
4713: LIST
4714: LIST
4715: PUSH
4716: LD_INT 25
4718: PUSH
4719: LD_INT 8
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: LIST
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PPUSH
4738: CALL_OW 69
4742: ST_TO_ADDR
// for i in tmp do
4743: LD_ADDR_VAR 0 5
4747: PUSH
4748: LD_VAR 0 2
4752: PUSH
4753: FOR_IN
4754: IFFALSE 4770
// SetTag ( i , 10 ) ;
4756: LD_VAR 0 5
4760: PPUSH
4761: LD_INT 10
4763: PPUSH
4764: CALL_OW 109
4768: GO 4753
4770: POP
4771: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4772: LD_ADDR_VAR 0 3
4776: PUSH
4777: LD_INT 22
4779: PUSH
4780: LD_INT 2
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 21
4789: PUSH
4790: LD_INT 1
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PUSH
4797: EMPTY
4798: LIST
4799: LIST
4800: PPUSH
4801: CALL_OW 69
4805: PUSH
4806: LD_VAR 0 2
4810: DIFF
4811: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4812: LD_ADDR_VAR 0 1
4816: PUSH
4817: LD_INT 22
4819: PUSH
4820: LD_INT 2
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: PUSH
4827: LD_INT 21
4829: PUSH
4830: LD_INT 2
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: LD_INT 24
4839: PUSH
4840: LD_INT 300
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: LIST
4851: PPUSH
4852: CALL_OW 69
4856: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4857: LD_ADDR_VAR 0 4
4861: PUSH
4862: LD_VAR 0 1
4866: PPUSH
4867: LD_INT 33
4869: PUSH
4870: LD_INT 1
4872: PUSH
4873: EMPTY
4874: LIST
4875: LIST
4876: PUSH
4877: LD_INT 58
4879: PUSH
4880: EMPTY
4881: LIST
4882: PUSH
4883: EMPTY
4884: LIST
4885: LIST
4886: PPUSH
4887: CALL_OW 72
4891: ST_TO_ADDR
// for i in tmp do
4892: LD_ADDR_VAR 0 5
4896: PUSH
4897: LD_VAR 0 2
4901: PUSH
4902: FOR_IN
4903: IFFALSE 5087
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4905: LD_VAR 0 5
4909: PUSH
4910: LD_INT 55
4912: PUSH
4913: EMPTY
4914: LIST
4915: PPUSH
4916: CALL_OW 69
4920: IN
4921: IFFALSE 4940
// begin AddComMoveXY ( i , 209 , 132 ) ;
4923: LD_VAR 0 5
4927: PPUSH
4928: LD_INT 209
4930: PPUSH
4931: LD_INT 132
4933: PPUSH
4934: CALL_OW 171
// continue ;
4938: GO 4902
// end ; if IsInUnit ( i ) then
4940: LD_VAR 0 5
4944: PPUSH
4945: CALL_OW 310
4949: IFFALSE 4967
// begin ComExitBuilding ( i ) ;
4951: LD_VAR 0 5
4955: PPUSH
4956: CALL_OW 122
// wait ( 3 ) ;
4960: LD_INT 3
4962: PPUSH
4963: CALL_OW 67
// end ; if tmp_empty then
4967: LD_VAR 0 4
4971: IFFALSE 5070
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4973: LD_VAR 0 5
4977: PPUSH
4978: LD_VAR 0 4
4982: PPUSH
4983: LD_VAR 0 5
4987: PPUSH
4988: CALL_OW 74
4992: PPUSH
4993: CALL_OW 296
4997: PUSH
4998: LD_INT 25
5000: LESS
5001: IFFALSE 5070
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5003: LD_ADDR_VAR 0 6
5007: PUSH
5008: LD_VAR 0 4
5012: PPUSH
5013: LD_VAR 0 5
5017: PPUSH
5018: CALL_OW 74
5022: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5023: LD_VAR 0 5
5027: PPUSH
5028: LD_VAR 0 6
5032: PPUSH
5033: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5037: LD_VAR 0 5
5041: PPUSH
5042: LD_INT 209
5044: PPUSH
5045: LD_INT 132
5047: PPUSH
5048: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5052: LD_ADDR_VAR 0 4
5056: PUSH
5057: LD_VAR 0 4
5061: PUSH
5062: LD_VAR 0 6
5066: DIFF
5067: ST_TO_ADDR
// continue ;
5068: GO 4902
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5070: LD_VAR 0 5
5074: PPUSH
5075: LD_INT 201
5077: PPUSH
5078: LD_INT 132
5080: PPUSH
5081: CALL_OW 171
// end ;
5085: GO 4902
5087: POP
5088: POP
// for i in tmp_ape do
5089: LD_ADDR_VAR 0 5
5093: PUSH
5094: LD_VAR 0 3
5098: PUSH
5099: FOR_IN
5100: IFFALSE 5139
// begin if IsInUnit ( i ) then
5102: LD_VAR 0 5
5106: PPUSH
5107: CALL_OW 310
5111: IFFALSE 5122
// ComExitBuilding ( i ) ;
5113: LD_VAR 0 5
5117: PPUSH
5118: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5122: LD_VAR 0 5
5126: PPUSH
5127: LD_INT 201
5129: PPUSH
5130: LD_INT 132
5132: PPUSH
5133: CALL_OW 171
// end ;
5137: GO 5099
5139: POP
5140: POP
// repeat wait ( 0 0$1 ) ;
5141: LD_INT 35
5143: PPUSH
5144: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5148: LD_ADDR_VAR 0 5
5152: PUSH
5153: LD_VAR 0 2
5157: PUSH
5158: LD_VAR 0 3
5162: UNION
5163: PUSH
5164: LD_VAR 0 1
5168: UNION
5169: PUSH
5170: FOR_IN
5171: IFFALSE 5202
// if not HasTask ( i ) then
5173: LD_VAR 0 5
5177: PPUSH
5178: CALL_OW 314
5182: NOT
5183: IFFALSE 5200
// ComMoveXY ( i , 201 , 132 ) ;
5185: LD_VAR 0 5
5189: PPUSH
5190: LD_INT 201
5192: PPUSH
5193: LD_INT 132
5195: PPUSH
5196: CALL_OW 111
5200: GO 5170
5202: POP
5203: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5204: LD_INT 21
5206: PPUSH
5207: LD_INT 22
5209: PUSH
5210: LD_INT 2
5212: PUSH
5213: EMPTY
5214: LIST
5215: LIST
5216: PPUSH
5217: CALL_OW 70
5221: IFFALSE 5262
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5223: LD_ADDR_VAR 0 5
5227: PUSH
5228: LD_INT 21
5230: PPUSH
5231: LD_INT 22
5233: PUSH
5234: LD_INT 2
5236: PUSH
5237: EMPTY
5238: LIST
5239: LIST
5240: PPUSH
5241: CALL_OW 70
5245: PUSH
5246: FOR_IN
5247: IFFALSE 5260
// RemoveUnit ( i ) ;
5249: LD_VAR 0 5
5253: PPUSH
5254: CALL_OW 64
5258: GO 5246
5260: POP
5261: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5262: LD_INT 22
5264: PUSH
5265: LD_INT 2
5267: PUSH
5268: EMPTY
5269: LIST
5270: LIST
5271: PUSH
5272: LD_INT 2
5274: PUSH
5275: LD_INT 21
5277: PUSH
5278: LD_INT 1
5280: PUSH
5281: EMPTY
5282: LIST
5283: LIST
5284: PUSH
5285: LD_INT 21
5287: PUSH
5288: LD_INT 2
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: PUSH
5295: EMPTY
5296: LIST
5297: LIST
5298: LIST
5299: PUSH
5300: EMPTY
5301: LIST
5302: LIST
5303: PPUSH
5304: CALL_OW 69
5308: NOT
5309: IFFALSE 5141
// end ;
5311: PPOPN 6
5313: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5314: LD_EXP 9
5318: PUSH
5319: LD_INT 92
5321: PPUSH
5322: LD_INT 40
5324: PPUSH
5325: CALL_OW 428
5329: PPUSH
5330: CALL_OW 266
5334: PUSH
5335: LD_INT 30
5337: EQUAL
5338: AND
5339: IFFALSE 5535
5341: GO 5343
5343: DISABLE
5344: LD_INT 0
5346: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5347: LD_ADDR_VAR 0 1
5351: PUSH
5352: LD_EXP 59
5356: PUSH
5357: LD_INT 1
5359: ARRAY
5360: PPUSH
5361: LD_INT 25
5363: PUSH
5364: LD_INT 4
5366: PUSH
5367: EMPTY
5368: LIST
5369: LIST
5370: PPUSH
5371: CALL_OW 72
5375: ST_TO_ADDR
// if not sci then
5376: LD_VAR 0 1
5380: NOT
5381: IFFALSE 5385
// exit ;
5383: GO 5535
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5385: LD_ADDR_EXP 59
5389: PUSH
5390: LD_EXP 59
5394: PPUSH
5395: LD_INT 1
5397: PPUSH
5398: LD_EXP 59
5402: PUSH
5403: LD_INT 1
5405: ARRAY
5406: PUSH
5407: LD_VAR 0 1
5411: PUSH
5412: LD_INT 1
5414: ARRAY
5415: DIFF
5416: PPUSH
5417: CALL_OW 1
5421: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5422: LD_VAR 0 1
5426: PUSH
5427: LD_INT 1
5429: ARRAY
5430: PPUSH
5431: CALL_OW 310
5435: IFFALSE 5450
// ComExitBuilding ( sci [ 1 ] ) ;
5437: LD_VAR 0 1
5441: PUSH
5442: LD_INT 1
5444: ARRAY
5445: PPUSH
5446: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5450: LD_INT 2
5452: PPUSH
5453: LD_INT 105
5455: PPUSH
5456: LD_INT 14
5458: PPUSH
5459: LD_INT 20
5461: PPUSH
5462: CALL 22421 0 4
5466: PUSH
5467: LD_INT 4
5469: ARRAY
5470: PUSH
5471: LD_INT 10
5473: LESS
5474: IFFALSE 5497
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5476: LD_VAR 0 1
5480: PUSH
5481: LD_INT 1
5483: ARRAY
5484: PPUSH
5485: LD_INT 105
5487: PPUSH
5488: LD_INT 14
5490: PPUSH
5491: CALL_OW 171
5495: GO 5516
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5497: LD_VAR 0 1
5501: PUSH
5502: LD_INT 1
5504: ARRAY
5505: PPUSH
5506: LD_INT 118
5508: PPUSH
5509: LD_INT 77
5511: PPUSH
5512: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5516: LD_VAR 0 1
5520: PUSH
5521: LD_INT 1
5523: ARRAY
5524: PPUSH
5525: LD_INT 92
5527: PPUSH
5528: LD_INT 40
5530: PPUSH
5531: CALL_OW 218
// end ;
5535: PPOPN 1
5537: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5538: LD_INT 1
5540: PPUSH
5541: CALL_OW 302
5545: PUSH
5546: LD_EXP 9
5550: AND
5551: IFFALSE 6010
5553: GO 5555
5555: DISABLE
5556: LD_INT 0
5558: PPUSH
5559: PPUSH
5560: PPUSH
5561: PPUSH
5562: PPUSH
5563: PPUSH
// begin enable ;
5564: ENABLE
// base := 1 ;
5565: LD_ADDR_VAR 0 2
5569: PUSH
5570: LD_INT 1
5572: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5573: LD_ADDR_VAR 0 4
5577: PUSH
5578: LD_INT 0
5580: PUSH
5581: LD_INT 0
5583: PUSH
5584: LD_INT 0
5586: PUSH
5587: LD_INT 0
5589: PUSH
5590: LD_INT 0
5592: PUSH
5593: LD_INT 0
5595: PUSH
5596: LD_INT 0
5598: PUSH
5599: LD_INT 0
5601: PUSH
5602: LD_INT 1
5604: PUSH
5605: LD_INT 0
5607: PUSH
5608: EMPTY
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: LIST
5616: LIST
5617: LIST
5618: LIST
5619: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5620: LD_ADDR_VAR 0 3
5624: PUSH
5625: LD_INT 14
5627: PUSH
5628: LD_INT 1
5630: PUSH
5631: LD_INT 2
5633: PUSH
5634: LD_INT 26
5636: PUSH
5637: EMPTY
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: PUSH
5643: LD_INT 14
5645: PUSH
5646: LD_INT 1
5648: PUSH
5649: LD_INT 2
5651: PUSH
5652: LD_INT 28
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: LIST
5659: LIST
5660: PUSH
5661: LD_INT 13
5663: PUSH
5664: LD_INT 1
5666: PUSH
5667: LD_INT 2
5669: PUSH
5670: LD_INT 29
5672: PUSH
5673: EMPTY
5674: LIST
5675: LIST
5676: LIST
5677: LIST
5678: PUSH
5679: EMPTY
5680: LIST
5681: LIST
5682: LIST
5683: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5684: LD_ADDR_VAR 0 1
5688: PUSH
5689: DOUBLE
5690: LD_INT 1
5692: DEC
5693: ST_TO_ADDR
5694: LD_OWVAR 67
5698: PUSH
5699: LD_OWVAR 1
5703: PUSH
5704: LD_INT 21000
5706: DIV
5707: PLUS
5708: PUSH
5709: FOR_TO
5710: IFFALSE 5802
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5712: LD_ADDR_VAR 0 3
5716: PUSH
5717: LD_VAR 0 3
5721: PPUSH
5722: LD_VAR 0 3
5726: PUSH
5727: LD_INT 1
5729: PLUS
5730: PPUSH
5731: LD_INT 13
5733: PUSH
5734: LD_INT 14
5736: PUSH
5737: EMPTY
5738: LIST
5739: LIST
5740: PUSH
5741: LD_INT 1
5743: PPUSH
5744: LD_INT 2
5746: PPUSH
5747: CALL_OW 12
5751: ARRAY
5752: PUSH
5753: LD_INT 1
5755: PUSH
5756: LD_INT 2
5758: PUSH
5759: LD_INT 28
5761: PUSH
5762: LD_INT 29
5764: PUSH
5765: LD_INT 25
5767: PUSH
5768: LD_INT 26
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: LIST
5775: LIST
5776: PUSH
5777: LD_INT 1
5779: PPUSH
5780: LD_INT 4
5782: PPUSH
5783: CALL_OW 12
5787: ARRAY
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: LIST
5793: LIST
5794: PPUSH
5795: CALL_OW 2
5799: ST_TO_ADDR
5800: GO 5709
5802: POP
5803: POP
// MC_InsertProduceList ( base , tmp ) ;
5804: LD_VAR 0 2
5808: PPUSH
5809: LD_VAR 0 3
5813: PPUSH
5814: CALL 81249 0 2
// repeat wait ( 0 0$1 ) ;
5818: LD_INT 35
5820: PPUSH
5821: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5825: LD_EXP 78
5829: PUSH
5830: LD_VAR 0 2
5834: ARRAY
5835: PUSH
5836: LD_INT 6
5838: GREATER
5839: IFFALSE 5818
// wait ( 0 0$20 ) ;
5841: LD_INT 700
5843: PPUSH
5844: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5848: LD_ADDR_VAR 0 5
5852: PUSH
5853: LD_INT 124
5855: PUSH
5856: LD_INT 85
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PUSH
5863: LD_INT 90
5865: PUSH
5866: LD_INT 61
5868: PUSH
5869: EMPTY
5870: LIST
5871: LIST
5872: PUSH
5873: LD_INT 69
5875: PUSH
5876: LD_INT 48
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: PUSH
5883: LD_INT 68
5885: PUSH
5886: LD_INT 48
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5899: LD_ADDR_VAR 0 6
5903: PUSH
5904: LD_EXP 78
5908: PUSH
5909: LD_VAR 0 2
5913: ARRAY
5914: PUSH
5915: LD_EXP 78
5919: PUSH
5920: LD_VAR 0 2
5924: ARRAY
5925: PPUSH
5926: LD_INT 34
5928: PUSH
5929: LD_INT 32
5931: PUSH
5932: EMPTY
5933: LIST
5934: LIST
5935: PPUSH
5936: CALL_OW 72
5940: DIFF
5941: ST_TO_ADDR
// if not attackers then
5942: LD_VAR 0 6
5946: NOT
5947: IFFALSE 5951
// exit ;
5949: GO 6010
// ar_attackers := attackers ;
5951: LD_ADDR_EXP 10
5955: PUSH
5956: LD_VAR 0 6
5960: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5961: LD_INT 35
5963: PPUSH
5964: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5968: LD_VAR 0 6
5972: PPUSH
5973: LD_INT 60
5975: PUSH
5976: EMPTY
5977: LIST
5978: PPUSH
5979: CALL_OW 72
5983: NOT
5984: IFFALSE 5961
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5986: LD_VAR 0 2
5990: PPUSH
5991: LD_VAR 0 6
5995: PPUSH
5996: LD_VAR 0 5
6000: PPUSH
6001: LD_VAR 0 4
6005: PPUSH
6006: CALL 81434 0 4
// end ;
6010: PPOPN 6
6012: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6013: LD_INT 1
6015: PPUSH
6016: CALL_OW 302
6020: PUSH
6021: LD_EXP 9
6025: AND
6026: PUSH
6027: LD_EXP 49
6031: PPUSH
6032: LD_INT 22
6034: PPUSH
6035: CALL_OW 308
6039: AND
6040: PUSH
6041: LD_INT 1
6043: PPUSH
6044: CALL 81597 0 1
6048: PUSH
6049: LD_INT 0
6051: EQUAL
6052: AND
6053: PUSH
6054: LD_EXP 10
6058: NOT
6059: AND
6060: IFFALSE 6524
6062: GO 6064
6064: DISABLE
6065: LD_INT 0
6067: PPUSH
6068: PPUSH
6069: PPUSH
6070: PPUSH
6071: PPUSH
6072: PPUSH
6073: PPUSH
// begin base := 1 ;
6074: LD_ADDR_VAR 0 2
6078: PUSH
6079: LD_INT 1
6081: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6082: LD_ADDR_VAR 0 4
6086: PUSH
6087: LD_INT 0
6089: PUSH
6090: LD_INT 0
6092: PUSH
6093: LD_INT 0
6095: PUSH
6096: LD_INT 0
6098: PUSH
6099: LD_INT 0
6101: PUSH
6102: LD_INT 0
6104: PUSH
6105: LD_INT 0
6107: PUSH
6108: LD_INT 0
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: LD_INT 0
6116: PUSH
6117: EMPTY
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: LIST
6125: LIST
6126: LIST
6127: LIST
6128: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6129: LD_ADDR_VAR 0 3
6133: PUSH
6134: LD_INT 13
6136: PUSH
6137: LD_INT 1
6139: PUSH
6140: LD_INT 2
6142: PUSH
6143: LD_INT 28
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: LIST
6150: LIST
6151: PUSH
6152: LD_INT 13
6154: PUSH
6155: LD_INT 1
6157: PUSH
6158: LD_INT 2
6160: PUSH
6161: LD_INT 27
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: LIST
6169: PUSH
6170: LD_INT 13
6172: PUSH
6173: LD_INT 1
6175: PUSH
6176: LD_INT 2
6178: PUSH
6179: LD_INT 25
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: LIST
6186: LIST
6187: PUSH
6188: LD_INT 11
6190: PUSH
6191: LD_INT 2
6193: PUSH
6194: LD_INT 2
6196: PUSH
6197: LD_INT 24
6199: PUSH
6200: EMPTY
6201: LIST
6202: LIST
6203: LIST
6204: LIST
6205: PUSH
6206: LD_INT 11
6208: PUSH
6209: LD_INT 2
6211: PUSH
6212: LD_INT 2
6214: PUSH
6215: LD_INT 24
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: LIST
6222: LIST
6223: PUSH
6224: EMPTY
6225: LIST
6226: LIST
6227: LIST
6228: LIST
6229: LIST
6230: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6231: LD_VAR 0 2
6235: PPUSH
6236: LD_VAR 0 3
6240: PPUSH
6241: CALL 81249 0 2
// repeat wait ( 0 0$1 ) ;
6245: LD_INT 35
6247: PPUSH
6248: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6252: LD_EXP 78
6256: PUSH
6257: LD_VAR 0 2
6261: ARRAY
6262: PUSH
6263: LD_INT 6
6265: GREATEREQUAL
6266: IFFALSE 6245
// wait ( 0 0$20 ) ;
6268: LD_INT 700
6270: PPUSH
6271: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6275: LD_ADDR_VAR 0 5
6279: PUSH
6280: LD_INT 119
6282: PUSH
6283: LD_INT 9
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: PUSH
6290: EMPTY
6291: LIST
6292: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6293: LD_ADDR_VAR 0 6
6297: PUSH
6298: LD_EXP 78
6302: PUSH
6303: LD_VAR 0 2
6307: ARRAY
6308: PUSH
6309: LD_EXP 78
6313: PUSH
6314: LD_VAR 0 2
6318: ARRAY
6319: PPUSH
6320: LD_INT 34
6322: PUSH
6323: LD_INT 32
6325: PUSH
6326: EMPTY
6327: LIST
6328: LIST
6329: PPUSH
6330: CALL_OW 72
6334: DIFF
6335: ST_TO_ADDR
// if not attackers then
6336: LD_VAR 0 6
6340: NOT
6341: IFFALSE 6345
// exit ;
6343: GO 6524
// uc_side := 2 ;
6345: LD_ADDR_OWVAR 20
6349: PUSH
6350: LD_INT 2
6352: ST_TO_ADDR
// uc_nation := 2 ;
6353: LD_ADDR_OWVAR 21
6357: PUSH
6358: LD_INT 2
6360: ST_TO_ADDR
// InitHc ;
6361: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6365: LD_ADDR_VAR 0 1
6369: PUSH
6370: DOUBLE
6371: LD_INT 1
6373: DEC
6374: ST_TO_ADDR
6375: LD_INT 4
6377: PUSH
6378: LD_INT 5
6380: PUSH
6381: LD_INT 6
6383: PUSH
6384: EMPTY
6385: LIST
6386: LIST
6387: LIST
6388: PUSH
6389: LD_OWVAR 67
6393: ARRAY
6394: PUSH
6395: FOR_TO
6396: IFFALSE 6473
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6398: LD_INT 0
6400: PPUSH
6401: LD_INT 15
6403: PUSH
6404: LD_INT 17
6406: PUSH
6407: EMPTY
6408: LIST
6409: LIST
6410: PUSH
6411: LD_INT 1
6413: PPUSH
6414: LD_INT 2
6416: PPUSH
6417: CALL_OW 12
6421: ARRAY
6422: PPUSH
6423: LD_INT 8
6425: PPUSH
6426: CALL_OW 380
// un := CreateHuman ;
6430: LD_ADDR_VAR 0 7
6434: PUSH
6435: CALL_OW 44
6439: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6440: LD_VAR 0 7
6444: PPUSH
6445: LD_INT 23
6447: PPUSH
6448: LD_INT 0
6450: PPUSH
6451: CALL_OW 49
// attackers := attackers union un ;
6455: LD_ADDR_VAR 0 6
6459: PUSH
6460: LD_VAR 0 6
6464: PUSH
6465: LD_VAR 0 7
6469: UNION
6470: ST_TO_ADDR
// end ;
6471: GO 6395
6473: POP
6474: POP
// repeat wait ( 0 0$1 ) ;
6475: LD_INT 35
6477: PPUSH
6478: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6482: LD_VAR 0 6
6486: PPUSH
6487: LD_INT 60
6489: PUSH
6490: EMPTY
6491: LIST
6492: PPUSH
6493: CALL_OW 72
6497: NOT
6498: IFFALSE 6475
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6500: LD_VAR 0 2
6504: PPUSH
6505: LD_VAR 0 6
6509: PPUSH
6510: LD_VAR 0 5
6514: PPUSH
6515: LD_VAR 0 4
6519: PPUSH
6520: CALL 81434 0 4
// end ; end_of_file
6524: PPOPN 7
6526: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6527: LD_INT 0
6529: PPUSH
6530: PPUSH
6531: PPUSH
6532: PPUSH
// uc_side := 1 ;
6533: LD_ADDR_OWVAR 20
6537: PUSH
6538: LD_INT 1
6540: ST_TO_ADDR
// uc_nation := 1 ;
6541: LD_ADDR_OWVAR 21
6545: PUSH
6546: LD_INT 1
6548: ST_TO_ADDR
// InitHc ;
6549: CALL_OW 19
// InitVc ;
6553: CALL_OW 20
// tmp := [ ] ;
6557: LD_ADDR_VAR 0 3
6561: PUSH
6562: EMPTY
6563: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6564: LD_ADDR_VAR 0 2
6568: PUSH
6569: DOUBLE
6570: LD_INT 1
6572: DEC
6573: ST_TO_ADDR
6574: LD_INT 5
6576: PUSH
6577: LD_INT 6
6579: PUSH
6580: LD_INT 6
6582: PUSH
6583: EMPTY
6584: LIST
6585: LIST
6586: LIST
6587: PUSH
6588: LD_OWVAR 67
6592: ARRAY
6593: PUSH
6594: FOR_TO
6595: IFFALSE 6732
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6597: LD_INT 2
6599: PUSH
6600: LD_INT 4
6602: PUSH
6603: LD_INT 5
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: PUSH
6611: LD_INT 1
6613: PPUSH
6614: LD_INT 3
6616: PPUSH
6617: CALL_OW 12
6621: ARRAY
6622: PPUSH
6623: LD_INT 1
6625: PUSH
6626: LD_INT 3
6628: PUSH
6629: EMPTY
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 1
6635: PPUSH
6636: LD_INT 2
6638: PPUSH
6639: CALL_OW 12
6643: ARRAY
6644: PPUSH
6645: LD_INT 3
6647: PPUSH
6648: LD_INT 9
6650: PUSH
6651: LD_INT 7
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PUSH
6658: LD_INT 1
6660: PPUSH
6661: LD_INT 2
6663: PPUSH
6664: CALL_OW 12
6668: ARRAY
6669: PPUSH
6670: LD_INT 78
6672: PPUSH
6673: CALL 21403 0 5
// veh := CreateVehicle ;
6677: LD_ADDR_VAR 0 4
6681: PUSH
6682: CALL_OW 45
6686: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6687: LD_VAR 0 4
6691: PPUSH
6692: LD_INT 2
6694: PPUSH
6695: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6699: LD_VAR 0 4
6703: PPUSH
6704: LD_INT 17
6706: PPUSH
6707: LD_INT 0
6709: PPUSH
6710: CALL_OW 49
// tmp := tmp ^ veh ;
6714: LD_ADDR_VAR 0 3
6718: PUSH
6719: LD_VAR 0 3
6723: PUSH
6724: LD_VAR 0 4
6728: ADD
6729: ST_TO_ADDR
// end ;
6730: GO 6594
6732: POP
6733: POP
// if not tmp then
6734: LD_VAR 0 3
6738: NOT
6739: IFFALSE 6743
// exit ;
6741: GO 6852
// if not first_powell_attack then
6743: LD_EXP 11
6747: NOT
6748: IFFALSE 6758
// first_powell_attack := true ;
6750: LD_ADDR_EXP 11
6754: PUSH
6755: LD_INT 1
6757: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6758: LD_INT 70
6760: PPUSH
6761: CALL_OW 67
// for i in tmp do
6765: LD_ADDR_VAR 0 2
6769: PUSH
6770: LD_VAR 0 3
6774: PUSH
6775: FOR_IN
6776: IFFALSE 6843
// if IsOk ( i ) then
6778: LD_VAR 0 2
6782: PPUSH
6783: CALL_OW 302
6787: IFFALSE 6825
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6789: LD_VAR 0 2
6793: PPUSH
6794: LD_INT 81
6796: PUSH
6797: LD_INT 1
6799: PUSH
6800: EMPTY
6801: LIST
6802: LIST
6803: PPUSH
6804: CALL_OW 69
6808: PPUSH
6809: LD_VAR 0 2
6813: PPUSH
6814: CALL_OW 74
6818: PPUSH
6819: CALL_OW 115
6823: GO 6841
// tmp := tmp diff i ;
6825: LD_ADDR_VAR 0 3
6829: PUSH
6830: LD_VAR 0 3
6834: PUSH
6835: LD_VAR 0 2
6839: DIFF
6840: ST_TO_ADDR
6841: GO 6775
6843: POP
6844: POP
// until not tmp ;
6845: LD_VAR 0 3
6849: NOT
6850: IFFALSE 6758
// end ; end_of_file
6852: LD_VAR 0 1
6856: RET
// export function Action ; var tmp , i , un ; begin
6857: LD_INT 0
6859: PPUSH
6860: PPUSH
6861: PPUSH
6862: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6863: LD_INT 68
6865: PPUSH
6866: LD_INT 39
6868: PPUSH
6869: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6873: LD_ADDR_VAR 0 2
6877: PUSH
6878: LD_INT 22
6880: PUSH
6881: LD_INT 7
6883: PUSH
6884: EMPTY
6885: LIST
6886: LIST
6887: PPUSH
6888: CALL_OW 69
6892: ST_TO_ADDR
// InGameOn ;
6893: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6897: LD_VAR 0 2
6901: PPUSH
6902: LD_INT 71
6904: PPUSH
6905: LD_INT 49
6907: PPUSH
6908: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6912: LD_INT 35
6914: PPUSH
6915: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6919: LD_INT 7
6921: PPUSH
6922: LD_INT 71
6924: PPUSH
6925: LD_INT 51
6927: PPUSH
6928: CALL_OW 293
6932: IFFALSE 6912
// DialogueOn ;
6934: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6938: LD_EXP 15
6942: PPUSH
6943: LD_STRING D1-JMM-1
6945: PPUSH
6946: CALL_OW 88
// if Joan then
6950: LD_EXP 30
6954: IFFALSE 6968
// Say ( Joan , D1-Joan-1 ) ;
6956: LD_EXP 30
6960: PPUSH
6961: LD_STRING D1-Joan-1
6963: PPUSH
6964: CALL_OW 88
// if Lisa then
6968: LD_EXP 17
6972: IFFALSE 6986
// Say ( Lisa , D1-Lisa-1 ) ;
6974: LD_EXP 17
6978: PPUSH
6979: LD_STRING D1-Lisa-1
6981: PPUSH
6982: CALL_OW 88
// if Joan or Lisa then
6986: LD_EXP 30
6990: PUSH
6991: LD_EXP 17
6995: OR
6996: IFFALSE 7010
// Say ( JMM , D1-JMM-2 ) ;
6998: LD_EXP 15
7002: PPUSH
7003: LD_STRING D1-JMM-2
7005: PPUSH
7006: CALL_OW 88
// DialogueOff ;
7010: CALL_OW 7
// InGameOff ;
7014: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7018: LD_INT 71
7020: PPUSH
7021: LD_INT 50
7023: PPUSH
7024: LD_INT 7
7026: PPUSH
7027: LD_INT 30
7029: NEG
7030: PPUSH
7031: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7035: LD_INT 71
7037: PPUSH
7038: LD_INT 50
7040: PPUSH
7041: LD_INT 7
7043: PPUSH
7044: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7048: LD_STRING M1
7050: PPUSH
7051: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7055: LD_INT 35
7057: PPUSH
7058: CALL_OW 67
// until freedom ;
7062: LD_EXP 3
7066: IFFALSE 7055
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7068: LD_INT 350
7070: PPUSH
7071: LD_INT 700
7073: PPUSH
7074: CALL_OW 12
7078: PPUSH
7079: CALL_OW 67
// PrepareGossudarov ;
7083: CALL 1806 0 0
// repeat wait ( 0 0$1 ) ;
7087: LD_INT 35
7089: PPUSH
7090: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7094: LD_INT 22
7096: PUSH
7097: LD_INT 6
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PUSH
7104: LD_INT 3
7106: PUSH
7107: LD_INT 24
7109: PUSH
7110: LD_INT 1000
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PPUSH
7125: CALL_OW 69
7129: PUSH
7130: LD_INT 7
7132: PPUSH
7133: LD_EXP 32
7137: PPUSH
7138: CALL_OW 292
7142: OR
7143: IFFALSE 7087
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7145: LD_ADDR_VAR 0 2
7149: PUSH
7150: LD_INT 22
7152: PUSH
7153: LD_INT 6
7155: PUSH
7156: EMPTY
7157: LIST
7158: LIST
7159: PPUSH
7160: CALL_OW 69
7164: ST_TO_ADDR
// for i in tmp do
7165: LD_ADDR_VAR 0 3
7169: PUSH
7170: LD_VAR 0 2
7174: PUSH
7175: FOR_IN
7176: IFFALSE 7192
// SetSide ( i , 7 ) ;
7178: LD_VAR 0 3
7182: PPUSH
7183: LD_INT 7
7185: PPUSH
7186: CALL_OW 235
7190: GO 7175
7192: POP
7193: POP
// DialogueOn ;
7194: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7198: LD_EXP 15
7202: PUSH
7203: LD_EXP 16
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: PPUSH
7212: LD_EXP 32
7216: PPUSH
7217: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7221: LD_EXP 32
7225: PPUSH
7226: CALL_OW 87
// if not Roth then
7230: LD_EXP 16
7234: NOT
7235: IFFALSE 7327
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7237: LD_VAR 0 2
7241: PPUSH
7242: LD_INT 3
7244: PUSH
7245: LD_INT 24
7247: PUSH
7248: LD_INT 1000
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: PPUSH
7259: CALL_OW 72
7263: IFFALSE 7277
// Say ( JMM , D2-JMM-1 ) ;
7265: LD_EXP 15
7269: PPUSH
7270: LD_STRING D2-JMM-1
7272: PPUSH
7273: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7277: LD_EXP 15
7281: PPUSH
7282: LD_STRING D2-JMM-1b
7284: PPUSH
7285: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7289: LD_EXP 32
7293: PPUSH
7294: LD_STRING D2-Gos-1
7296: PPUSH
7297: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7301: LD_EXP 15
7305: PPUSH
7306: LD_STRING D2-JMM-2
7308: PPUSH
7309: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7313: LD_EXP 32
7317: PPUSH
7318: LD_STRING D2-Gos-2
7320: PPUSH
7321: CALL_OW 88
// end else
7325: GO 7479
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7327: LD_VAR 0 2
7331: PPUSH
7332: LD_INT 3
7334: PUSH
7335: LD_INT 24
7337: PUSH
7338: LD_INT 1000
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PUSH
7345: EMPTY
7346: LIST
7347: LIST
7348: PPUSH
7349: CALL_OW 72
7353: IFFALSE 7379
// begin Say ( Roth , D2-Roth-2 ) ;
7355: LD_EXP 16
7359: PPUSH
7360: LD_STRING D2-Roth-2
7362: PPUSH
7363: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7367: LD_EXP 15
7371: PPUSH
7372: LD_STRING D2-JMM-1a
7374: PPUSH
7375: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7379: LD_EXP 16
7383: PPUSH
7384: LD_STRING D2-Roth-2a
7386: PPUSH
7387: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7391: LD_EXP 16
7395: PPUSH
7396: LD_STRING D2-Roth-2b
7398: PPUSH
7399: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7403: LD_EXP 15
7407: PPUSH
7408: LD_STRING D2-JMM-3
7410: PPUSH
7411: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7415: LD_VAR 0 2
7419: PPUSH
7420: LD_INT 3
7422: PUSH
7423: LD_INT 24
7425: PUSH
7426: LD_INT 1000
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: PPUSH
7437: CALL_OW 72
7441: IFFALSE 7479
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7443: LD_EXP 32
7447: PPUSH
7448: LD_STRING D2-Gos-3
7450: PPUSH
7451: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7455: LD_EXP 15
7459: PPUSH
7460: LD_STRING D2-JMM-4
7462: PPUSH
7463: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7467: LD_EXP 32
7471: PPUSH
7472: LD_STRING D2-Gos-4
7474: PPUSH
7475: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7479: LD_EXP 15
7483: PPUSH
7484: LD_STRING D2-JMM-5
7486: PPUSH
7487: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7491: LD_EXP 32
7495: PPUSH
7496: LD_STRING D2-Gos-5
7498: PPUSH
7499: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7503: LD_EXP 15
7507: PPUSH
7508: LD_STRING D2-JMM-6
7510: PPUSH
7511: CALL_OW 88
// DialogueOff ;
7515: CALL_OW 7
// wait ( 0 0$2 ) ;
7519: LD_INT 70
7521: PPUSH
7522: CALL_OW 67
// if Kirilenkova then
7526: LD_EXP 33
7530: IFFALSE 7544
// Say ( Kirilenkova , D3-Kir-1 ) ;
7532: LD_EXP 33
7536: PPUSH
7537: LD_STRING D3-Kir-1
7539: PPUSH
7540: CALL_OW 88
// gossudarov_arrive := true ;
7544: LD_ADDR_EXP 4
7548: PUSH
7549: LD_INT 1
7551: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7552: LD_INT 35
7554: PPUSH
7555: CALL_OW 67
// until ru_lab_builded ;
7559: LD_EXP 5
7563: IFFALSE 7552
// if Kirilenkova then
7565: LD_EXP 33
7569: IFFALSE 7585
// Say ( Kirilenkova , D3a-Kir-1 ) else
7571: LD_EXP 33
7575: PPUSH
7576: LD_STRING D3a-Kir-1
7578: PPUSH
7579: CALL_OW 88
7583: GO 7607
// begin un := SciRu ;
7585: LD_ADDR_VAR 0 4
7589: PUSH
7590: CALL 12715 0 0
7594: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7595: LD_VAR 0 4
7599: PPUSH
7600: LD_STRING D3a-Sci1-1
7602: PPUSH
7603: CALL_OW 88
// end ; if Kirilenkova or un then
7607: LD_EXP 33
7611: PUSH
7612: LD_VAR 0 4
7616: OR
7617: IFFALSE 7631
// Say ( JMM , D3a-JMM-1 ) ;
7619: LD_EXP 15
7623: PPUSH
7624: LD_STRING D3a-JMM-1
7626: PPUSH
7627: CALL_OW 88
// end ;
7631: LD_VAR 0 1
7635: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7636: LD_EXP 4
7640: PUSH
7641: LD_INT 22
7643: PUSH
7644: LD_INT 7
7646: PUSH
7647: EMPTY
7648: LIST
7649: LIST
7650: PUSH
7651: LD_INT 2
7653: PUSH
7654: LD_INT 25
7656: PUSH
7657: LD_INT 1
7659: PUSH
7660: EMPTY
7661: LIST
7662: LIST
7663: PUSH
7664: LD_INT 25
7666: PUSH
7667: LD_INT 2
7669: PUSH
7670: EMPTY
7671: LIST
7672: LIST
7673: PUSH
7674: LD_INT 25
7676: PUSH
7677: LD_INT 3
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: PUSH
7684: LD_INT 25
7686: PUSH
7687: LD_INT 4
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: PUSH
7694: LD_INT 25
7696: PUSH
7697: LD_INT 5
7699: PUSH
7700: EMPTY
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 25
7706: PUSH
7707: LD_INT 8
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PUSH
7714: LD_INT 25
7716: PUSH
7717: LD_INT 9
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: LIST
7728: LIST
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: PUSH
7734: EMPTY
7735: LIST
7736: LIST
7737: PPUSH
7738: CALL_OW 69
7742: PUSH
7743: LD_INT 7
7745: LESS
7746: AND
7747: IFFALSE 7759
7749: GO 7751
7751: DISABLE
// YouLost ( TooMany ) ;
7752: LD_STRING TooMany
7754: PPUSH
7755: CALL_OW 104
7759: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7760: LD_EXP 32
7764: PPUSH
7765: CALL_OW 255
7769: PUSH
7770: LD_INT 7
7772: EQUAL
7773: IFFALSE 7973
7775: GO 7777
7777: DISABLE
7778: LD_INT 0
7780: PPUSH
7781: PPUSH
7782: PPUSH
// begin uc_side := 3 ;
7783: LD_ADDR_OWVAR 20
7787: PUSH
7788: LD_INT 3
7790: ST_TO_ADDR
// uc_nation := 3 ;
7791: LD_ADDR_OWVAR 21
7795: PUSH
7796: LD_INT 3
7798: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7799: LD_INT 21
7801: PPUSH
7802: LD_INT 3
7804: PPUSH
7805: LD_INT 3
7807: PPUSH
7808: LD_INT 42
7810: PPUSH
7811: LD_INT 100
7813: PPUSH
7814: CALL 21403 0 5
// un := CreateVehicle ;
7818: LD_ADDR_VAR 0 3
7822: PUSH
7823: CALL_OW 45
7827: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7828: LD_VAR 0 3
7832: PPUSH
7833: LD_INT 15
7835: PPUSH
7836: LD_INT 0
7838: PPUSH
7839: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7843: LD_VAR 0 3
7847: PPUSH
7848: LD_INT 67
7850: PPUSH
7851: LD_INT 45
7853: PPUSH
7854: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7858: LD_VAR 0 3
7862: PPUSH
7863: LD_INT 70
7865: PPUSH
7866: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7870: LD_VAR 0 3
7874: PPUSH
7875: LD_INT 69
7877: PPUSH
7878: LD_INT 18
7880: PPUSH
7881: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7885: LD_VAR 0 3
7889: PPUSH
7890: LD_INT 60
7892: PPUSH
7893: LD_INT 2
7895: PPUSH
7896: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7900: LD_INT 35
7902: PPUSH
7903: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7907: LD_VAR 0 3
7911: PPUSH
7912: CALL_OW 302
7916: NOT
7917: PUSH
7918: LD_VAR 0 3
7922: PPUSH
7923: LD_INT 17
7925: PPUSH
7926: CALL_OW 308
7930: OR
7931: IFFALSE 7900
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7933: LD_VAR 0 3
7937: PPUSH
7938: LD_INT 17
7940: PPUSH
7941: CALL_OW 308
7945: PUSH
7946: LD_VAR 0 3
7950: PPUSH
7951: LD_INT 60
7953: PPUSH
7954: LD_INT 2
7956: PPUSH
7957: CALL_OW 307
7961: OR
7962: IFFALSE 7973
// RemoveUnit ( un ) ;
7964: LD_VAR 0 3
7968: PPUSH
7969: CALL_OW 64
// end ;
7973: PPOPN 3
7975: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
7976: LD_EXP 4
7980: IFFALSE 8222
7982: GO 7984
7984: DISABLE
7985: LD_INT 0
7987: PPUSH
7988: PPUSH
7989: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7990: LD_INT 70
7992: PPUSH
7993: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7997: LD_ADDR_VAR 0 3
8001: PUSH
8002: LD_INT 22
8004: PUSH
8005: LD_INT 7
8007: PUSH
8008: EMPTY
8009: LIST
8010: LIST
8011: PUSH
8012: LD_INT 101
8014: PUSH
8015: LD_INT 3
8017: PUSH
8018: EMPTY
8019: LIST
8020: LIST
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PPUSH
8026: CALL_OW 69
8030: ST_TO_ADDR
// until tmp ;
8031: LD_VAR 0 3
8035: IFFALSE 7990
// un := NearestUnitToUnit ( tmp , JMM ) ;
8037: LD_ADDR_VAR 0 2
8041: PUSH
8042: LD_VAR 0 3
8046: PPUSH
8047: LD_EXP 15
8051: PPUSH
8052: CALL_OW 74
8056: ST_TO_ADDR
// player_spotted := true ;
8057: LD_ADDR_EXP 6
8061: PUSH
8062: LD_INT 1
8064: ST_TO_ADDR
// tmp := SciRu ;
8065: LD_ADDR_VAR 0 3
8069: PUSH
8070: CALL 12715 0 0
8074: ST_TO_ADDR
// if not tmp then
8075: LD_VAR 0 3
8079: NOT
8080: IFFALSE 8092
// tmp := SolRu ;
8082: LD_ADDR_VAR 0 3
8086: PUSH
8087: CALL 12862 0 0
8091: ST_TO_ADDR
// DialogueOn ;
8092: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8096: LD_VAR 0 2
8100: PPUSH
8101: CALL_OW 250
8105: PPUSH
8106: LD_VAR 0 2
8110: PPUSH
8111: CALL_OW 251
8115: PPUSH
8116: LD_INT 7
8118: PPUSH
8119: LD_INT 8
8121: NEG
8122: PPUSH
8123: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8127: LD_VAR 0 2
8131: PPUSH
8132: CALL_OW 87
// if tmp then
8136: LD_VAR 0 3
8140: IFFALSE 8154
// Say ( tmp , D4-RSci1-1 ) ;
8142: LD_VAR 0 3
8146: PPUSH
8147: LD_STRING D4-RSci1-1
8149: PPUSH
8150: CALL_OW 88
// if Gossudarov then
8154: LD_EXP 32
8158: IFFALSE 8184
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8160: LD_EXP 32
8164: PPUSH
8165: LD_STRING D4-Gos-1
8167: PPUSH
8168: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8172: LD_EXP 15
8176: PPUSH
8177: LD_STRING D4-JMM-1
8179: PPUSH
8180: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8184: LD_VAR 0 2
8188: PPUSH
8189: CALL_OW 250
8193: PPUSH
8194: LD_VAR 0 2
8198: PPUSH
8199: CALL_OW 251
8203: PPUSH
8204: LD_INT 7
8206: PPUSH
8207: CALL_OW 331
// DialogueOff ;
8211: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8215: LD_STRING M5
8217: PPUSH
8218: CALL_OW 337
// end ;
8222: PPOPN 3
8224: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8225: LD_EXP 6
8229: IFFALSE 8818
8231: GO 8233
8233: DISABLE
8234: LD_INT 0
8236: PPUSH
8237: PPUSH
8238: PPUSH
// begin PrepareBelkov ;
8239: CALL 2096 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8243: LD_EXP 47
8247: PPUSH
8248: LD_INT 118
8250: PPUSH
8251: LD_INT 106
8253: PPUSH
8254: CALL_OW 111
// AddComHold ( Belkov ) ;
8258: LD_EXP 47
8262: PPUSH
8263: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8267: LD_INT 35
8269: PPUSH
8270: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8274: LD_EXP 47
8278: PPUSH
8279: LD_INT 118
8281: PPUSH
8282: LD_INT 106
8284: PPUSH
8285: CALL_OW 307
8289: IFFALSE 8267
// ChangeSideFog ( 4 , 7 ) ;
8291: LD_INT 4
8293: PPUSH
8294: LD_INT 7
8296: PPUSH
8297: CALL_OW 343
// if IsOk ( Belkov ) then
8301: LD_EXP 47
8305: PPUSH
8306: CALL_OW 302
8310: IFFALSE 8394
// begin InGameOn ;
8312: CALL_OW 8
// DialogueOn ;
8316: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8320: LD_EXP 47
8324: PPUSH
8325: LD_STRING D5-Bel-1
8327: PPUSH
8328: CALL_OW 94
// if Gossudarov then
8332: LD_EXP 32
8336: IFFALSE 8386
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8338: LD_EXP 32
8342: PPUSH
8343: LD_STRING D5-Gos-1
8345: PPUSH
8346: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8350: LD_EXP 15
8354: PPUSH
8355: LD_STRING D5-JMM-1
8357: PPUSH
8358: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8362: LD_EXP 32
8366: PPUSH
8367: LD_STRING D5-Gos-2
8369: PPUSH
8370: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8374: LD_EXP 15
8378: PPUSH
8379: LD_STRING D5-JMM-2
8381: PPUSH
8382: CALL_OW 88
// end ; DialogueOff ;
8386: CALL_OW 7
// InGameOff ;
8390: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8394: LD_STRING QSaveBelkov
8396: PPUSH
8397: CALL_OW 97
8401: PUSH
8402: LD_INT 1
8404: DOUBLE
8405: EQUAL
8406: IFTRUE 8410
8408: GO 8460
8410: POP
// begin DialogueOn ;
8411: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8415: LD_EXP 15
8419: PPUSH
8420: LD_STRING D5a-JMM-1
8422: PPUSH
8423: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8427: LD_EXP 47
8431: PPUSH
8432: LD_STRING D5a-Bel-1
8434: PPUSH
8435: CALL_OW 94
// DialogueOff ;
8439: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8443: LD_EXP 47
8447: PPUSH
8448: LD_INT 83
8450: PPUSH
8451: LD_INT 49
8453: PPUSH
8454: CALL_OW 111
// end ; 2 :
8458: GO 8493
8460: LD_INT 2
8462: DOUBLE
8463: EQUAL
8464: IFTRUE 8468
8466: GO 8492
8468: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8469: LD_EXP 15
8473: PPUSH
8474: LD_STRING D5a-JMM-2
8476: PPUSH
8477: CALL_OW 88
// ComHold ( Belkov ) ;
8481: LD_EXP 47
8485: PPUSH
8486: CALL_OW 140
// end ; end ;
8490: GO 8493
8492: POP
// time := 0 0$00 ;
8493: LD_ADDR_VAR 0 1
8497: PUSH
8498: LD_INT 0
8500: ST_TO_ADDR
// vehSpawned := false ;
8501: LD_ADDR_VAR 0 3
8505: PUSH
8506: LD_INT 0
8508: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8509: LD_INT 35
8511: PPUSH
8512: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8516: LD_VAR 0 1
8520: PUSH
8521: LD_INT 350
8523: PUSH
8524: LD_INT 175
8526: PUSH
8527: LD_INT 70
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: LIST
8534: PUSH
8535: LD_OWVAR 67
8539: ARRAY
8540: GREATEREQUAL
8541: PUSH
8542: LD_VAR 0 3
8546: NOT
8547: AND
8548: IFFALSE 8638
// begin vehSpawned := true ;
8550: LD_ADDR_VAR 0 3
8554: PUSH
8555: LD_INT 1
8557: ST_TO_ADDR
// uc_side := 3 ;
8558: LD_ADDR_OWVAR 20
8562: PUSH
8563: LD_INT 3
8565: ST_TO_ADDR
// uc_nation := 3 ;
8566: LD_ADDR_OWVAR 21
8570: PUSH
8571: LD_INT 3
8573: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8574: LD_INT 22
8576: PPUSH
8577: LD_INT 3
8579: PPUSH
8580: LD_INT 3
8582: PPUSH
8583: LD_INT 43
8585: PPUSH
8586: LD_INT 100
8588: PPUSH
8589: CALL 21403 0 5
// veh := CreateVehicle ;
8593: LD_ADDR_VAR 0 2
8597: PUSH
8598: CALL_OW 45
8602: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8603: LD_VAR 0 2
8607: PPUSH
8608: LD_INT 130
8610: PPUSH
8611: LD_INT 131
8613: PPUSH
8614: LD_INT 0
8616: PPUSH
8617: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8621: LD_VAR 0 2
8625: PPUSH
8626: LD_INT 100
8628: PPUSH
8629: LD_INT 82
8631: PPUSH
8632: CALL_OW 114
// end else
8636: GO 8652
// time := time + 0 0$1 ;
8638: LD_ADDR_VAR 0 1
8642: PUSH
8643: LD_VAR 0 1
8647: PUSH
8648: LD_INT 35
8650: PLUS
8651: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8652: LD_EXP 47
8656: PPUSH
8657: CALL_OW 301
8661: PUSH
8662: LD_EXP 47
8666: PPUSH
8667: CALL_OW 255
8671: PUSH
8672: LD_INT 4
8674: EQUAL
8675: AND
8676: PUSH
8677: LD_INT 22
8679: PUSH
8680: LD_INT 7
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: PPUSH
8687: CALL_OW 69
8691: PPUSH
8692: LD_EXP 47
8696: PPUSH
8697: CALL_OW 74
8701: PPUSH
8702: LD_EXP 47
8706: PPUSH
8707: CALL_OW 296
8711: PUSH
8712: LD_INT 10
8714: LESS
8715: OR
8716: IFFALSE 8509
// if IsDead ( Belkov ) then
8718: LD_EXP 47
8722: PPUSH
8723: CALL_OW 301
8727: IFFALSE 8752
// begin CenterNowOnUnits ( Belkov ) ;
8729: LD_EXP 47
8733: PPUSH
8734: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8738: LD_EXP 15
8742: PPUSH
8743: LD_STRING D5a-JMM-2a
8745: PPUSH
8746: CALL_OW 88
// exit ;
8750: GO 8818
// end ; if See ( 7 , Belkov ) then
8752: LD_INT 7
8754: PPUSH
8755: LD_EXP 47
8759: PPUSH
8760: CALL_OW 292
8764: IFFALSE 8778
// SetSide ( Belkov , 7 ) ;
8766: LD_EXP 47
8770: PPUSH
8771: LD_INT 7
8773: PPUSH
8774: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8778: LD_INT 35
8780: PPUSH
8781: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8785: LD_EXP 47
8789: PPUSH
8790: LD_INT 66
8792: PPUSH
8793: LD_INT 45
8795: PPUSH
8796: CALL_OW 297
8800: PUSH
8801: LD_INT 30
8803: LESS
8804: IFFALSE 8778
// Say ( Belkov , D6-Bel-1 ) ;
8806: LD_EXP 47
8810: PPUSH
8811: LD_STRING D6-Bel-1
8813: PPUSH
8814: CALL_OW 88
// end ;
8818: PPOPN 3
8820: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8821: LD_EXP 47
8825: PPUSH
8826: CALL_OW 302
8830: PUSH
8831: LD_EXP 47
8835: PPUSH
8836: CALL_OW 504
8840: PUSH
8841: LD_INT 2
8843: PUSH
8844: LD_INT 34
8846: PUSH
8847: LD_INT 47
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: LD_INT 34
8856: PUSH
8857: LD_INT 45
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: LIST
8868: PPUSH
8869: CALL_OW 69
8873: IN
8874: AND
8875: IFFALSE 8892
8877: GO 8879
8879: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8880: LD_EXP 47
8884: PPUSH
8885: LD_STRING D7-Bel-1
8887: PPUSH
8888: CALL_OW 88
8892: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8893: LD_INT 22
8895: PUSH
8896: LD_INT 7
8898: PUSH
8899: EMPTY
8900: LIST
8901: LIST
8902: PUSH
8903: LD_INT 101
8905: PUSH
8906: LD_INT 2
8908: PUSH
8909: EMPTY
8910: LIST
8911: LIST
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: PPUSH
8917: CALL_OW 69
8921: PUSH
8922: LD_EXP 8
8926: NOT
8927: AND
8928: PUSH
8929: LD_EXP 46
8933: PPUSH
8934: CALL_OW 305
8938: NOT
8939: AND
8940: IFFALSE 9410
8942: GO 8944
8944: DISABLE
8945: LD_INT 0
8947: PPUSH
// begin ar_base_spotted := true ;
8948: LD_ADDR_EXP 8
8952: PUSH
8953: LD_INT 1
8955: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8956: LD_ADDR_VAR 0 1
8960: PUSH
8961: LD_INT 22
8963: PUSH
8964: LD_INT 2
8966: PUSH
8967: EMPTY
8968: LIST
8969: LIST
8970: PUSH
8971: LD_INT 21
8973: PUSH
8974: LD_INT 3
8976: PUSH
8977: EMPTY
8978: LIST
8979: LIST
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PPUSH
8985: CALL_OW 69
8989: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8990: LD_ADDR_VAR 0 1
8994: PUSH
8995: LD_VAR 0 1
8999: PPUSH
9000: LD_EXP 15
9004: PPUSH
9005: CALL_OW 74
9009: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9010: LD_INT 7
9012: PPUSH
9013: LD_INT 3
9015: PPUSH
9016: CALL_OW 332
// DialogueOn ;
9020: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9024: LD_VAR 0 1
9028: PPUSH
9029: CALL_OW 250
9033: PPUSH
9034: LD_VAR 0 1
9038: PPUSH
9039: CALL_OW 251
9043: PPUSH
9044: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9048: LD_ADDR_VAR 0 1
9052: PUSH
9053: LD_INT 22
9055: PUSH
9056: LD_INT 7
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PUSH
9063: LD_INT 23
9065: PUSH
9066: LD_INT 1
9068: PUSH
9069: EMPTY
9070: LIST
9071: LIST
9072: PUSH
9073: LD_INT 26
9075: PUSH
9076: LD_INT 1
9078: PUSH
9079: EMPTY
9080: LIST
9081: LIST
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: LIST
9087: PPUSH
9088: CALL_OW 69
9092: PUSH
9093: LD_EXP 15
9097: PUSH
9098: LD_EXP 19
9102: PUSH
9103: LD_EXP 20
9107: PUSH
9108: LD_EXP 27
9112: PUSH
9113: LD_EXP 16
9117: PUSH
9118: LD_EXP 25
9122: PUSH
9123: LD_EXP 21
9127: PUSH
9128: LD_EXP 23
9132: PUSH
9133: EMPTY
9134: LIST
9135: LIST
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: DIFF
9143: ST_TO_ADDR
// if not tmp then
9144: LD_VAR 0 1
9148: NOT
9149: IFFALSE 9223
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9151: LD_ADDR_VAR 0 1
9155: PUSH
9156: LD_INT 22
9158: PUSH
9159: LD_INT 7
9161: PUSH
9162: EMPTY
9163: LIST
9164: LIST
9165: PUSH
9166: LD_INT 23
9168: PUSH
9169: LD_INT 1
9171: PUSH
9172: EMPTY
9173: LIST
9174: LIST
9175: PUSH
9176: LD_INT 26
9178: PUSH
9179: LD_INT 2
9181: PUSH
9182: EMPTY
9183: LIST
9184: LIST
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: LIST
9190: PPUSH
9191: CALL_OW 69
9195: PUSH
9196: LD_EXP 30
9200: PUSH
9201: LD_EXP 17
9205: PUSH
9206: LD_EXP 28
9210: PUSH
9211: LD_EXP 29
9215: PUSH
9216: EMPTY
9217: LIST
9218: LIST
9219: LIST
9220: LIST
9221: DIFF
9222: ST_TO_ADDR
// if tmp then
9223: LD_VAR 0 1
9227: IFFALSE 9298
// case GetSex ( tmp [ 1 ] ) of sex_male :
9229: LD_VAR 0 1
9233: PUSH
9234: LD_INT 1
9236: ARRAY
9237: PPUSH
9238: CALL_OW 258
9242: PUSH
9243: LD_INT 1
9245: DOUBLE
9246: EQUAL
9247: IFTRUE 9251
9249: GO 9270
9251: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9252: LD_VAR 0 1
9256: PUSH
9257: LD_INT 1
9259: ARRAY
9260: PPUSH
9261: LD_STRING D9-Sol1-1
9263: PPUSH
9264: CALL_OW 88
9268: GO 9298
9270: LD_INT 2
9272: DOUBLE
9273: EQUAL
9274: IFTRUE 9278
9276: GO 9297
9278: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9279: LD_VAR 0 1
9283: PUSH
9284: LD_INT 1
9286: ARRAY
9287: PPUSH
9288: LD_STRING D9-FSol1-1
9290: PPUSH
9291: CALL_OW 88
9295: GO 9298
9297: POP
// if Frank then
9298: LD_EXP 27
9302: IFFALSE 9406
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9304: LD_EXP 56
9308: PPUSH
9309: CALL_OW 250
9313: PPUSH
9314: LD_EXP 56
9318: PPUSH
9319: CALL_OW 251
9323: PPUSH
9324: LD_INT 7
9326: PPUSH
9327: LD_INT 8
9329: PPUSH
9330: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9334: LD_EXP 56
9338: PPUSH
9339: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9343: LD_EXP 27
9347: PPUSH
9348: LD_STRING D9-Frank-1
9350: PPUSH
9351: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9355: LD_EXP 15
9359: PPUSH
9360: LD_STRING D9-JMM-1
9362: PPUSH
9363: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9367: LD_EXP 27
9371: PPUSH
9372: LD_STRING D9-Frank-2
9374: PPUSH
9375: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9379: LD_EXP 56
9383: PPUSH
9384: CALL_OW 250
9388: PPUSH
9389: LD_EXP 56
9393: PPUSH
9394: CALL_OW 251
9398: PPUSH
9399: LD_INT 7
9401: PPUSH
9402: CALL_OW 331
// end ; DialogueOff ;
9406: CALL_OW 7
// end ;
9410: PPOPN 1
9412: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9413: LD_EXP 7
9417: PUSH
9418: LD_OWVAR 1
9422: PUSH
9423: LD_INT 42000
9425: GREATEREQUAL
9426: OR
9427: IFFALSE 10454
9429: GO 9431
9431: DISABLE
9432: LD_INT 0
9434: PPUSH
9435: PPUSH
// begin selected_option := 1 ;
9436: LD_ADDR_VAR 0 2
9440: PUSH
9441: LD_INT 1
9443: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9444: LD_INT 10500
9446: PPUSH
9447: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9451: LD_INT 35
9453: PPUSH
9454: CALL_OW 67
// until not ru_attackers ;
9458: LD_EXP 52
9462: NOT
9463: IFFALSE 9451
// PrepareBurlak ;
9465: CALL 2208 0 0
// repeat wait ( 0 0$2 ) ;
9469: LD_INT 70
9471: PPUSH
9472: CALL_OW 67
// until not HasTask ( Burlak ) ;
9476: LD_EXP 46
9480: PPUSH
9481: CALL_OW 314
9485: NOT
9486: IFFALSE 9469
// InGameOn ;
9488: CALL_OW 8
// DialogueOn ;
9492: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9496: LD_EXP 49
9500: PPUSH
9501: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9505: LD_EXP 46
9509: PPUSH
9510: LD_STRING D10-Bur-1
9512: PPUSH
9513: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9517: LD_EXP 47
9521: PUSH
9522: LD_EXP 47
9526: PPUSH
9527: CALL_OW 255
9531: PUSH
9532: LD_INT 7
9534: EQUAL
9535: AND
9536: IFFALSE 9550
// Say ( Belkov , D10-Bel-1 ) ;
9538: LD_EXP 47
9542: PPUSH
9543: LD_STRING D10-Bel-1
9545: PPUSH
9546: CALL_OW 88
// if Gossudarov then
9550: LD_EXP 32
9554: IFFALSE 9568
// Say ( Gossudarov , D10-Gos-1 ) ;
9556: LD_EXP 32
9560: PPUSH
9561: LD_STRING D10-Gos-1
9563: PPUSH
9564: CALL_OW 88
// if Kirilenkova then
9568: LD_EXP 33
9572: IFFALSE 9586
// Say ( Kirilenkova , D10-Kir-1 ) ;
9574: LD_EXP 33
9578: PPUSH
9579: LD_STRING D10-Kir-1
9581: PPUSH
9582: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9586: CALL 12862 0 0
9590: PPUSH
9591: LD_STRING D10-RSol1-1
9593: PPUSH
9594: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9598: LD_EXP 46
9602: PPUSH
9603: LD_STRING D10-Bur-2
9605: PPUSH
9606: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9610: LD_EXP 15
9614: PPUSH
9615: LD_STRING D10-JMM-2
9617: PPUSH
9618: CALL_OW 88
// if Kirilenkova then
9622: LD_EXP 33
9626: IFFALSE 9642
// Say ( Kirilenkova , D10-Kir-2 ) else
9628: LD_EXP 33
9632: PPUSH
9633: LD_STRING D10-Kir-2
9635: PPUSH
9636: CALL_OW 88
9640: GO 9654
// Say ( SolRu , D10-RSol1-2 ) ;
9642: CALL 12862 0 0
9646: PPUSH
9647: LD_STRING D10-RSol1-2
9649: PPUSH
9650: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9654: LD_EXP 15
9658: PPUSH
9659: LD_STRING D10-JMM-3
9661: PPUSH
9662: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9666: LD_EXP 46
9670: PPUSH
9671: LD_STRING D10-Bur-3
9673: PPUSH
9674: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9678: LD_EXP 15
9682: PPUSH
9683: LD_STRING D10-JMM-4
9685: PPUSH
9686: CALL_OW 88
// DialogueOff ;
9690: CALL_OW 7
// InGameOff ;
9694: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9698: LD_STRING M2
9700: PPUSH
9701: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9705: LD_INT 35
9707: PPUSH
9708: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9712: LD_INT 22
9714: PUSH
9715: LD_INT 7
9717: PUSH
9718: EMPTY
9719: LIST
9720: LIST
9721: PUSH
9722: LD_INT 91
9724: PUSH
9725: LD_EXP 46
9729: PUSH
9730: LD_INT 8
9732: PUSH
9733: EMPTY
9734: LIST
9735: LIST
9736: LIST
9737: PUSH
9738: EMPTY
9739: LIST
9740: LIST
9741: PPUSH
9742: CALL_OW 69
9746: IFFALSE 9705
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9748: LD_ADDR_VAR 0 1
9752: PUSH
9753: LD_INT 22
9755: PUSH
9756: LD_INT 4
9758: PUSH
9759: EMPTY
9760: LIST
9761: LIST
9762: PPUSH
9763: CALL_OW 69
9767: PUSH
9768: FOR_IN
9769: IFFALSE 9785
// SetSide ( i , 7 ) ;
9771: LD_VAR 0 1
9775: PPUSH
9776: LD_INT 7
9778: PPUSH
9779: CALL_OW 235
9783: GO 9768
9785: POP
9786: POP
// ChangeMissionObjectives ( M3 ) ;
9787: LD_STRING M3
9789: PPUSH
9790: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9794: LD_INT 35
9796: PPUSH
9797: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9801: LD_EXP 15
9805: PPUSH
9806: LD_EXP 46
9810: PPUSH
9811: CALL_OW 296
9815: PUSH
9816: LD_INT 8
9818: LESS
9819: IFFALSE 9794
// ComTurnUnit ( JMM , Burlak ) ;
9821: LD_EXP 15
9825: PPUSH
9826: LD_EXP 46
9830: PPUSH
9831: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9835: LD_EXP 46
9839: PPUSH
9840: LD_EXP 15
9844: PPUSH
9845: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9849: LD_INT 10
9851: PPUSH
9852: CALL_OW 67
// DialogueOn ;
9856: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9860: LD_EXP 15
9864: PPUSH
9865: LD_STRING D11-JMM-1
9867: PPUSH
9868: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9872: LD_EXP 46
9876: PPUSH
9877: LD_STRING D11-Bur-1
9879: PPUSH
9880: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9884: LD_EXP 15
9888: PPUSH
9889: LD_STRING D11-JMM-2
9891: PPUSH
9892: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9896: LD_EXP 46
9900: PPUSH
9901: LD_STRING D11-Bur-2
9903: PPUSH
9904: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9908: LD_EXP 15
9912: PPUSH
9913: LD_STRING D11-JMM-3
9915: PPUSH
9916: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9920: LD_EXP 46
9924: PPUSH
9925: LD_STRING D11-Bur-3
9927: PPUSH
9928: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9932: LD_EXP 15
9936: PPUSH
9937: LD_STRING D11-JMM-4
9939: PPUSH
9940: CALL_OW 88
// if ar_base_spotted then
9944: LD_EXP 8
9948: IFFALSE 9964
// Say ( Burlak , D12-Bur-1 ) else
9950: LD_EXP 46
9954: PPUSH
9955: LD_STRING D12-Bur-1
9957: PPUSH
9958: CALL_OW 88
9962: GO 10003
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9964: LD_INT 7
9966: PPUSH
9967: LD_INT 3
9969: PPUSH
9970: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9974: LD_INT 127
9976: PPUSH
9977: LD_INT 45
9979: PPUSH
9980: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9984: LD_EXP 46
9988: PPUSH
9989: LD_STRING D12-Bur-1a
9991: PPUSH
9992: CALL_OW 88
// dwait ( 0 0$2 ) ;
9996: LD_INT 70
9998: PPUSH
9999: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10003: LD_EXP 46
10007: PPUSH
10008: LD_STRING D12-Bur-1b
10010: PPUSH
10011: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10015: LD_EXP 15
10019: PPUSH
10020: LD_STRING D12-JMM-1
10022: PPUSH
10023: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10027: LD_EXP 46
10031: PPUSH
10032: LD_STRING D12-Bur-2
10034: PPUSH
10035: CALL_OW 88
// if Roth then
10039: LD_EXP 16
10043: IFFALSE 10059
// Say ( Roth , D12-Roth-2 ) else
10045: LD_EXP 16
10049: PPUSH
10050: LD_STRING D12-Roth-2
10052: PPUSH
10053: CALL_OW 88
10057: GO 10071
// Say ( SciRu , D12-RSci1-2 ) ;
10059: CALL 12715 0 0
10063: PPUSH
10064: LD_STRING D12-RSci1-2
10066: PPUSH
10067: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10071: LD_EXP 15
10075: PPUSH
10076: LD_STRING D12-JMM-2
10078: PPUSH
10079: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10083: LD_EXP 46
10087: PPUSH
10088: LD_STRING D12-Bur-3
10090: PPUSH
10091: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10095: LD_EXP 15
10099: PPUSH
10100: LD_STRING D12-JMM-3
10102: PPUSH
10103: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10107: LD_EXP 46
10111: PPUSH
10112: LD_STRING D12-Bur-4
10114: PPUSH
10115: CALL_OW 88
// case Query ( QBase ) of 1 :
10119: LD_STRING QBase
10121: PPUSH
10122: CALL_OW 97
10126: PUSH
10127: LD_INT 1
10129: DOUBLE
10130: EQUAL
10131: IFTRUE 10135
10133: GO 10253
10135: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10136: LD_EXP 15
10140: PPUSH
10141: LD_STRING D13a-JMM-1
10143: PPUSH
10144: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10148: LD_EXP 46
10152: PPUSH
10153: LD_STRING D13a-Bur-1
10155: PPUSH
10156: CALL_OW 88
// if Roth then
10160: LD_EXP 16
10164: IFFALSE 10180
// Say ( Roth , D13a-Roth-1 ) else
10166: LD_EXP 16
10170: PPUSH
10171: LD_STRING D13a-Roth-1
10173: PPUSH
10174: CALL_OW 88
10178: GO 10192
// Say ( SciRu , D13a-RSci1-1 ) ;
10180: CALL 12715 0 0
10184: PPUSH
10185: LD_STRING D13a-RSci1-1
10187: PPUSH
10188: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10192: LD_EXP 15
10196: PPUSH
10197: LD_STRING D13a-JMM-2
10199: PPUSH
10200: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10204: LD_STRING QBaseAgain
10206: PPUSH
10207: CALL_OW 97
10211: PUSH
10212: LD_INT 1
10214: DOUBLE
10215: EQUAL
10216: IFTRUE 10220
10218: GO 10231
10220: POP
// selected_option := 2 ; 2 :
10221: LD_ADDR_VAR 0 2
10225: PUSH
10226: LD_INT 2
10228: ST_TO_ADDR
10229: GO 10251
10231: LD_INT 2
10233: DOUBLE
10234: EQUAL
10235: IFTRUE 10239
10237: GO 10250
10239: POP
// selected_option := 3 ; end ;
10240: LD_ADDR_VAR 0 2
10244: PUSH
10245: LD_INT 3
10247: ST_TO_ADDR
10248: GO 10251
10250: POP
// end ; 2 :
10251: GO 10292
10253: LD_INT 2
10255: DOUBLE
10256: EQUAL
10257: IFTRUE 10261
10259: GO 10272
10261: POP
// selected_option := 2 ; 3 :
10262: LD_ADDR_VAR 0 2
10266: PUSH
10267: LD_INT 2
10269: ST_TO_ADDR
10270: GO 10292
10272: LD_INT 3
10274: DOUBLE
10275: EQUAL
10276: IFTRUE 10280
10278: GO 10291
10280: POP
// selected_option := 3 ; end ;
10281: LD_ADDR_VAR 0 2
10285: PUSH
10286: LD_INT 3
10288: ST_TO_ADDR
10289: GO 10292
10291: POP
// if selected_option = 2 then
10292: LD_VAR 0 2
10296: PUSH
10297: LD_INT 2
10299: EQUAL
10300: IFFALSE 10394
// begin Say ( JMM , D13b-JMM-1 ) ;
10302: LD_EXP 15
10306: PPUSH
10307: LD_STRING D13b-JMM-1
10309: PPUSH
10310: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10314: LD_EXP 46
10318: PPUSH
10319: LD_STRING D13b-Bur-1
10321: PPUSH
10322: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10326: LD_EXP 15
10330: PPUSH
10331: LD_STRING D13b-JMM-2
10333: PPUSH
10334: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10338: LD_EXP 55
10342: PPUSH
10343: LD_STRING D13b-Abd-2
10345: PPUSH
10346: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10350: LD_EXP 15
10354: PPUSH
10355: LD_STRING D13b-JMM-3
10357: PPUSH
10358: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10362: LD_EXP 55
10366: PPUSH
10367: LD_STRING D13b-Abd-3
10369: PPUSH
10370: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10374: LD_EXP 15
10378: PPUSH
10379: LD_STRING D13b-JMM-4
10381: PPUSH
10382: CALL_OW 88
// ar_active_attack := true ;
10386: LD_ADDR_EXP 9
10390: PUSH
10391: LD_INT 1
10393: ST_TO_ADDR
// end ; if selected_option = 3 then
10394: LD_VAR 0 2
10398: PUSH
10399: LD_INT 3
10401: EQUAL
10402: IFFALSE 10428
// begin Say ( JMM , D13c-JMM-1 ) ;
10404: LD_EXP 15
10408: PPUSH
10409: LD_STRING D13c-JMM-1
10411: PPUSH
10412: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10416: LD_EXP 46
10420: PPUSH
10421: LD_STRING D13c-Bur-1
10423: PPUSH
10424: CALL_OW 88
// end ; DialogueOff ;
10428: CALL_OW 7
// if not ar_active_attack then
10432: LD_EXP 9
10436: NOT
10437: IFFALSE 10454
// begin wait ( 6 6$00 ) ;
10439: LD_INT 12600
10441: PPUSH
10442: CALL_OW 67
// ar_active_attack := true ;
10446: LD_ADDR_EXP 9
10450: PUSH
10451: LD_INT 1
10453: ST_TO_ADDR
// end ; end ;
10454: PPOPN 2
10456: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10457: LD_EXP 46
10461: PPUSH
10462: CALL_OW 305
10466: PUSH
10467: LD_EXP 46
10471: PPUSH
10472: CALL_OW 255
10476: PUSH
10477: LD_INT 7
10479: EQUAL
10480: AND
10481: IFFALSE 10677
10483: GO 10485
10485: DISABLE
10486: LD_INT 0
10488: PPUSH
// begin wait ( 4 4$40 ) ;
10489: LD_INT 9800
10491: PPUSH
10492: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10496: LD_INT 35
10498: PPUSH
10499: CALL_OW 67
// until not ru_attackers ;
10503: LD_EXP 52
10507: NOT
10508: IFFALSE 10496
// PrepareGnyevko ;
10510: CALL 2152 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10514: LD_EXP 48
10518: PPUSH
10519: LD_INT 124
10521: PPUSH
10522: LD_INT 118
10524: PPUSH
10525: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10529: LD_EXP 48
10533: PPUSH
10534: CALL_OW 200
// time := 0 0$00 ;
10538: LD_ADDR_VAR 0 1
10542: PUSH
10543: LD_INT 0
10545: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10546: LD_INT 35
10548: PPUSH
10549: CALL_OW 67
// time := time + 0 0$1 ;
10553: LD_ADDR_VAR 0 1
10557: PUSH
10558: LD_VAR 0 1
10562: PUSH
10563: LD_INT 35
10565: PLUS
10566: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10567: LD_EXP 48
10571: PPUSH
10572: LD_INT 124
10574: PPUSH
10575: LD_INT 118
10577: PPUSH
10578: CALL_OW 307
10582: PUSH
10583: LD_VAR 0 1
10587: PUSH
10588: LD_INT 1050
10590: GREATEREQUAL
10591: OR
10592: IFFALSE 10546
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10594: LD_EXP 48
10598: PPUSH
10599: LD_STRING DBelkov-Gny-1
10601: PPUSH
10602: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10606: LD_EXP 46
10610: PPUSH
10611: LD_STRING DBelkov-Bur-1a
10613: PPUSH
10614: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10618: LD_INT 35
10620: PPUSH
10621: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10625: LD_EXP 48
10629: PPUSH
10630: LD_INT 22
10632: PUSH
10633: LD_INT 7
10635: PUSH
10636: EMPTY
10637: LIST
10638: LIST
10639: PPUSH
10640: CALL_OW 69
10644: PPUSH
10645: LD_EXP 48
10649: PPUSH
10650: CALL_OW 74
10654: PPUSH
10655: CALL_OW 296
10659: PUSH
10660: LD_INT 8
10662: LESS
10663: IFFALSE 10618
// SetSide ( Gnyevko , 7 ) ;
10665: LD_EXP 48
10669: PPUSH
10670: LD_INT 7
10672: PPUSH
10673: CALL_OW 235
// end ;
10677: PPOPN 1
10679: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10680: LD_EXP 46
10684: PPUSH
10685: CALL_OW 255
10689: PUSH
10690: LD_INT 7
10692: EQUAL
10693: IFFALSE 10703
10695: GO 10697
10697: DISABLE
// begin enable ;
10698: ENABLE
// PrepareAmericanAttack ;
10699: CALL 6527 0 0
// end ;
10703: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10704: LD_INT 22
10706: PUSH
10707: LD_INT 1
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PPUSH
10714: CALL_OW 69
10718: IFFALSE 10902
10720: GO 10722
10722: DISABLE
10723: LD_INT 0
10725: PPUSH
10726: PPUSH
// begin while true do
10727: LD_INT 1
10729: IFFALSE 10786
// begin wait ( 0 0$1 ) ;
10731: LD_INT 35
10733: PPUSH
10734: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10738: LD_ADDR_VAR 0 2
10742: PUSH
10743: LD_INT 22
10745: PUSH
10746: LD_INT 1
10748: PUSH
10749: EMPTY
10750: LIST
10751: LIST
10752: PPUSH
10753: CALL_OW 69
10757: PPUSH
10758: LD_EXP 15
10762: PPUSH
10763: CALL_OW 74
10767: ST_TO_ADDR
// if See ( 7 , tmp ) then
10768: LD_INT 7
10770: PPUSH
10771: LD_VAR 0 2
10775: PPUSH
10776: CALL_OW 292
10780: IFFALSE 10784
// break ;
10782: GO 10786
// end ;
10784: GO 10727
// DialogueOn ;
10786: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10790: LD_VAR 0 2
10794: PPUSH
10795: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10799: LD_VAR 0 2
10803: PPUSH
10804: CALL_OW 250
10808: PPUSH
10809: LD_VAR 0 2
10813: PPUSH
10814: CALL_OW 251
10818: PPUSH
10819: LD_INT 7
10821: PPUSH
10822: LD_INT 8
10824: PPUSH
10825: CALL_OW 330
// if Denis then
10829: LD_EXP 21
10833: IFFALSE 10847
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10835: LD_EXP 21
10839: PPUSH
10840: LD_STRING DAmerAttack-Pet-1
10842: PPUSH
10843: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10847: LD_EXP 15
10851: PPUSH
10852: LD_STRING DAmerAttack-JMM-1
10854: PPUSH
10855: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10859: LD_EXP 46
10863: PPUSH
10864: LD_STRING DStop-Bur-1
10866: PPUSH
10867: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10871: LD_VAR 0 2
10875: PPUSH
10876: CALL_OW 250
10880: PPUSH
10881: LD_VAR 0 2
10885: PPUSH
10886: CALL_OW 251
10890: PPUSH
10891: LD_INT 7
10893: PPUSH
10894: CALL_OW 331
// DialogueOff ;
10898: CALL_OW 7
// end ;
10902: PPOPN 2
10904: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10905: LD_INT 22
10907: PUSH
10908: LD_INT 3
10910: PUSH
10911: EMPTY
10912: LIST
10913: LIST
10914: PUSH
10915: LD_INT 21
10917: PUSH
10918: LD_INT 1
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: PPUSH
10929: CALL_OW 69
10933: PUSH
10934: LD_INT 0
10936: EQUAL
10937: IFFALSE 10979
10939: GO 10941
10941: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10942: LD_STRING M5a
10944: PPUSH
10945: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10949: LD_EXP 15
10953: PPUSH
10954: LD_STRING D8-JMM-1
10956: PPUSH
10957: CALL_OW 88
// if Gossudarov then
10961: LD_EXP 32
10965: IFFALSE 10979
// Say ( Gossudarov , D8-Gos-1 ) ;
10967: LD_EXP 32
10971: PPUSH
10972: LD_STRING D8-Gos-1
10974: PPUSH
10975: CALL_OW 88
// end ;
10979: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10980: LD_INT 22
10982: PUSH
10983: LD_INT 2
10985: PUSH
10986: EMPTY
10987: LIST
10988: LIST
10989: PUSH
10990: LD_INT 21
10992: PUSH
10993: LD_INT 1
10995: PUSH
10996: EMPTY
10997: LIST
10998: LIST
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PPUSH
11004: CALL_OW 69
11008: PUSH
11009: LD_INT 0
11011: EQUAL
11012: IFFALSE 11062
11014: GO 11016
11016: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11017: LD_STRING M4c
11019: PPUSH
11020: CALL_OW 337
// if Roth then
11024: LD_EXP 16
11028: IFFALSE 11044
// Say ( Roth , DStop-Roth-1 ) else
11030: LD_EXP 16
11034: PPUSH
11035: LD_STRING DStop-Roth-1
11037: PPUSH
11038: CALL_OW 88
11042: GO 11062
// if Gossudarov then
11044: LD_EXP 32
11048: IFFALSE 11062
// Say ( Gossudarov , D8-Gos-1a ) ;
11050: LD_EXP 32
11054: PPUSH
11055: LD_STRING D8-Gos-1a
11057: PPUSH
11058: CALL_OW 88
// end ;
11062: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11063: LD_INT 7
11065: PPUSH
11066: LD_INT 1
11068: PPUSH
11069: LD_INT 1
11071: PPUSH
11072: CALL 14351 0 3
11076: PUSH
11077: LD_INT 0
11079: EQUAL
11080: PUSH
11081: LD_INT 7
11083: PPUSH
11084: LD_INT 3
11086: PPUSH
11087: LD_INT 1
11089: PPUSH
11090: CALL 14351 0 3
11094: PUSH
11095: LD_INT 0
11097: EQUAL
11098: AND
11099: IFFALSE 11111
11101: GO 11103
11103: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11104: LD_STRING M1a
11106: PPUSH
11107: CALL_OW 337
// end ;
11111: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11112: LD_INT 22
11114: PUSH
11115: LD_INT 2
11117: PUSH
11118: EMPTY
11119: LIST
11120: LIST
11121: PUSH
11122: LD_INT 21
11124: PUSH
11125: LD_INT 1
11127: PUSH
11128: EMPTY
11129: LIST
11130: LIST
11131: PUSH
11132: EMPTY
11133: LIST
11134: LIST
11135: PPUSH
11136: CALL_OW 69
11140: PUSH
11141: LD_INT 0
11143: EQUAL
11144: PUSH
11145: LD_INT 22
11147: PUSH
11148: LD_INT 3
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: LD_INT 21
11157: PUSH
11158: LD_INT 1
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PPUSH
11169: CALL_OW 69
11173: PUSH
11174: LD_INT 0
11176: EQUAL
11177: AND
11178: PUSH
11179: LD_INT 22
11181: PUSH
11182: LD_INT 1
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: PPUSH
11189: CALL_OW 69
11193: PUSH
11194: LD_INT 0
11196: EQUAL
11197: AND
11198: PUSH
11199: LD_INT 7
11201: PPUSH
11202: LD_INT 1
11204: PPUSH
11205: LD_INT 1
11207: PPUSH
11208: CALL 14351 0 3
11212: PUSH
11213: LD_INT 0
11215: EQUAL
11216: AND
11217: PUSH
11218: LD_INT 7
11220: PPUSH
11221: LD_INT 3
11223: PPUSH
11224: LD_INT 1
11226: PPUSH
11227: CALL 14351 0 3
11231: PUSH
11232: LD_INT 0
11234: EQUAL
11235: AND
11236: IFFALSE 12712
11238: GO 11240
11240: DISABLE
11241: LD_INT 0
11243: PPUSH
11244: PPUSH
11245: PPUSH
11246: PPUSH
11247: PPUSH
11248: PPUSH
// begin m1 := false ;
11249: LD_ADDR_VAR 0 4
11253: PUSH
11254: LD_INT 0
11256: ST_TO_ADDR
// m2 := false ;
11257: LD_ADDR_VAR 0 5
11261: PUSH
11262: LD_INT 0
11264: ST_TO_ADDR
// m3 := false ;
11265: LD_ADDR_VAR 0 6
11269: PUSH
11270: LD_INT 0
11272: ST_TO_ADDR
// if tick < 40 40$00 then
11273: LD_OWVAR 1
11277: PUSH
11278: LD_INT 84000
11280: LESS
11281: IFFALSE 11290
// SetAchievement ( ACH_ASPEED_17 ) ;
11283: LD_STRING ACH_ASPEED_17
11285: PPUSH
11286: CALL_OW 543
// wait ( 0 0$1 ) ;
11290: LD_INT 35
11292: PPUSH
11293: CALL_OW 67
// if not IsDead ( Masha ) then
11297: LD_EXP 49
11301: PPUSH
11302: CALL_OW 301
11306: NOT
11307: IFFALSE 11329
// begin m1 := true ;
11309: LD_ADDR_VAR 0 4
11313: PUSH
11314: LD_INT 1
11316: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11317: LD_STRING Masha
11319: PPUSH
11320: LD_INT 1
11322: PPUSH
11323: CALL_OW 101
// end else
11327: GO 11340
// AddMedal ( Masha , - 1 ) ;
11329: LD_STRING Masha
11331: PPUSH
11332: LD_INT 1
11334: NEG
11335: PPUSH
11336: CALL_OW 101
// if abdul_escaped then
11340: LD_EXP 12
11344: IFFALSE 11359
// AddMedal ( Abdul , - 1 ) else
11346: LD_STRING Abdul
11348: PPUSH
11349: LD_INT 1
11351: NEG
11352: PPUSH
11353: CALL_OW 101
11357: GO 11377
// begin m2 := true ;
11359: LD_ADDR_VAR 0 5
11363: PUSH
11364: LD_INT 1
11366: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11367: LD_STRING Abdul
11369: PPUSH
11370: LD_INT 1
11372: PPUSH
11373: CALL_OW 101
// end ; if loss_counter = 0 then
11377: LD_EXP 13
11381: PUSH
11382: LD_INT 0
11384: EQUAL
11385: IFFALSE 11407
// begin m3 := true ;
11387: LD_ADDR_VAR 0 6
11391: PUSH
11392: LD_INT 1
11394: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11395: LD_STRING People
11397: PPUSH
11398: LD_INT 2
11400: PPUSH
11401: CALL_OW 101
// end else
11405: GO 11465
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11407: LD_EXP 13
11411: PUSH
11412: LD_INT 3
11414: PUSH
11415: LD_INT 2
11417: PUSH
11418: LD_INT 2
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: LIST
11425: PUSH
11426: LD_OWVAR 67
11430: ARRAY
11431: LESSEQUAL
11432: IFFALSE 11454
// begin AddMedal ( People , 1 ) ;
11434: LD_STRING People
11436: PPUSH
11437: LD_INT 1
11439: PPUSH
11440: CALL_OW 101
// m3 := true ;
11444: LD_ADDR_VAR 0 6
11448: PUSH
11449: LD_INT 1
11451: ST_TO_ADDR
// end else
11452: GO 11465
// AddMedal ( People , - 1 ) ;
11454: LD_STRING People
11456: PPUSH
11457: LD_INT 1
11459: NEG
11460: PPUSH
11461: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11465: LD_OWVAR 67
11469: PUSH
11470: LD_INT 3
11472: EQUAL
11473: PUSH
11474: LD_VAR 0 4
11478: AND
11479: PUSH
11480: LD_VAR 0 5
11484: AND
11485: PUSH
11486: LD_VAR 0 6
11490: AND
11491: IFFALSE 11503
// SetAchievementEX ( ACH_AMER , 17 ) ;
11493: LD_STRING ACH_AMER
11495: PPUSH
11496: LD_INT 17
11498: PPUSH
11499: CALL_OW 564
// GiveMedals ( MAIN ) ;
11503: LD_STRING MAIN
11505: PPUSH
11506: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11510: LD_ADDR_VAR 0 2
11514: PUSH
11515: LD_INT 22
11517: PUSH
11518: LD_INT 7
11520: PUSH
11521: EMPTY
11522: LIST
11523: LIST
11524: PUSH
11525: LD_INT 2
11527: PUSH
11528: LD_INT 25
11530: PUSH
11531: LD_INT 1
11533: PUSH
11534: EMPTY
11535: LIST
11536: LIST
11537: PUSH
11538: LD_INT 25
11540: PUSH
11541: LD_INT 2
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: PUSH
11548: LD_INT 25
11550: PUSH
11551: LD_INT 3
11553: PUSH
11554: EMPTY
11555: LIST
11556: LIST
11557: PUSH
11558: LD_INT 25
11560: PUSH
11561: LD_INT 4
11563: PUSH
11564: EMPTY
11565: LIST
11566: LIST
11567: PUSH
11568: LD_INT 25
11570: PUSH
11571: LD_INT 5
11573: PUSH
11574: EMPTY
11575: LIST
11576: LIST
11577: PUSH
11578: LD_INT 25
11580: PUSH
11581: LD_INT 8
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PUSH
11588: LD_INT 25
11590: PUSH
11591: LD_INT 9
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: LIST
11602: LIST
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: PUSH
11608: EMPTY
11609: LIST
11610: LIST
11611: PPUSH
11612: CALL_OW 69
11616: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11617: LD_VAR 0 2
11621: PPUSH
11622: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11626: LD_ADDR_VAR 0 3
11630: PUSH
11631: LD_EXP 15
11635: PUSH
11636: LD_EXP 16
11640: PUSH
11641: LD_EXP 17
11645: PUSH
11646: LD_EXP 18
11650: PUSH
11651: LD_EXP 19
11655: PUSH
11656: LD_EXP 20
11660: PUSH
11661: LD_EXP 21
11665: PUSH
11666: LD_EXP 22
11670: PUSH
11671: LD_EXP 23
11675: PUSH
11676: LD_EXP 24
11680: PUSH
11681: LD_EXP 25
11685: PUSH
11686: LD_EXP 26
11690: PUSH
11691: LD_EXP 27
11695: PUSH
11696: LD_EXP 28
11700: PUSH
11701: LD_EXP 29
11705: PUSH
11706: LD_EXP 30
11710: PUSH
11711: LD_EXP 31
11715: PUSH
11716: LD_EXP 32
11720: PUSH
11721: LD_EXP 33
11725: PUSH
11726: LD_EXP 34
11730: PUSH
11731: LD_EXP 36
11735: PUSH
11736: LD_EXP 37
11740: PUSH
11741: LD_EXP 38
11745: PUSH
11746: LD_EXP 39
11750: PUSH
11751: LD_EXP 40
11755: PUSH
11756: LD_EXP 41
11760: PUSH
11761: LD_EXP 42
11765: PUSH
11766: LD_EXP 43
11770: PUSH
11771: LD_EXP 44
11775: PUSH
11776: LD_EXP 45
11780: PUSH
11781: LD_EXP 46
11785: PUSH
11786: LD_EXP 47
11790: PUSH
11791: LD_EXP 48
11795: PUSH
11796: EMPTY
11797: LIST
11798: LIST
11799: LIST
11800: LIST
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: ST_TO_ADDR
// if tmp diff tmp2 then
11831: LD_VAR 0 2
11835: PUSH
11836: LD_VAR 0 3
11840: DIFF
11841: IFFALSE 11861
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11843: LD_VAR 0 2
11847: PUSH
11848: LD_VAR 0 3
11852: DIFF
11853: PPUSH
11854: LD_STRING 13a_others
11856: PPUSH
11857: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11861: LD_EXP 15
11865: PPUSH
11866: LD_STRING 13a_JMM
11868: PPUSH
11869: CALL_OW 38
// if Titov then
11873: LD_EXP 34
11877: IFFALSE 11891
// SaveCharacters ( Titov , 13a_Titov ) ;
11879: LD_EXP 34
11883: PPUSH
11884: LD_STRING 13a_Titov
11886: PPUSH
11887: CALL_OW 38
// if Dolgov then
11891: LD_EXP 36
11895: IFFALSE 11909
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11897: LD_EXP 36
11901: PPUSH
11902: LD_STRING 13a_Dolgov
11904: PPUSH
11905: CALL_OW 38
// if Petrosyan then
11909: LD_EXP 37
11913: IFFALSE 11927
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11915: LD_EXP 37
11919: PPUSH
11920: LD_STRING 13a_Petrosyan
11922: PPUSH
11923: CALL_OW 38
// if Scholtze then
11927: LD_EXP 38
11931: IFFALSE 11945
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11933: LD_EXP 38
11937: PPUSH
11938: LD_STRING 13a_Scholtze
11940: PPUSH
11941: CALL_OW 38
// if Oblukov then
11945: LD_EXP 39
11949: IFFALSE 11963
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11951: LD_EXP 39
11955: PPUSH
11956: LD_STRING 13a_Oblukov
11958: PPUSH
11959: CALL_OW 38
// if Kapitsova then
11963: LD_EXP 40
11967: IFFALSE 11981
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11969: LD_EXP 40
11973: PPUSH
11974: LD_STRING 13a_Kapitsova
11976: PPUSH
11977: CALL_OW 38
// if Lipshchin then
11981: LD_EXP 41
11985: IFFALSE 11999
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11987: LD_EXP 41
11991: PPUSH
11992: LD_STRING 13a_Lipshchin
11994: PPUSH
11995: CALL_OW 38
// if Petrovova then
11999: LD_EXP 42
12003: IFFALSE 12017
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12005: LD_EXP 42
12009: PPUSH
12010: LD_STRING 13a_Petrovova
12012: PPUSH
12013: CALL_OW 38
// if Kovalyuk then
12017: LD_EXP 43
12021: IFFALSE 12035
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12023: LD_EXP 43
12027: PPUSH
12028: LD_STRING 13a_Kovalyuk
12030: PPUSH
12031: CALL_OW 38
// if Kuzmov then
12035: LD_EXP 44
12039: IFFALSE 12053
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12041: LD_EXP 44
12045: PPUSH
12046: LD_STRING 13a_Kuzmov
12048: PPUSH
12049: CALL_OW 38
// if Karamazov then
12053: LD_EXP 45
12057: IFFALSE 12071
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12059: LD_EXP 45
12063: PPUSH
12064: LD_STRING 13a_Karamazov
12066: PPUSH
12067: CALL_OW 38
// if Burlak then
12071: LD_EXP 46
12075: IFFALSE 12089
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12077: LD_EXP 46
12081: PPUSH
12082: LD_STRING 13a_Burlak
12084: PPUSH
12085: CALL_OW 38
// if Belkov then
12089: LD_EXP 47
12093: IFFALSE 12107
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12095: LD_EXP 47
12099: PPUSH
12100: LD_STRING 13a_Belkov
12102: PPUSH
12103: CALL_OW 38
// if Gnyevko then
12107: LD_EXP 48
12111: IFFALSE 12125
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12113: LD_EXP 48
12117: PPUSH
12118: LD_STRING 13a_Gnyevko
12120: PPUSH
12121: CALL_OW 38
// if Lisa then
12125: LD_EXP 17
12129: IFFALSE 12143
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12131: LD_EXP 17
12135: PPUSH
12136: LD_STRING 13a_Lisa
12138: PPUSH
12139: CALL_OW 38
// if Donaldson then
12143: LD_EXP 18
12147: IFFALSE 12161
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12149: LD_EXP 18
12153: PPUSH
12154: LD_STRING 13a_Donaldson
12156: PPUSH
12157: CALL_OW 38
// if Bobby then
12161: LD_EXP 19
12165: IFFALSE 12179
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12167: LD_EXP 19
12171: PPUSH
12172: LD_STRING 13a_Bobby
12174: PPUSH
12175: CALL_OW 38
// if Cyrus then
12179: LD_EXP 20
12183: IFFALSE 12197
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12185: LD_EXP 20
12189: PPUSH
12190: LD_STRING 13a_Cyrus
12192: PPUSH
12193: CALL_OW 38
// if Denis then
12197: LD_EXP 21
12201: IFFALSE 12215
// SaveCharacters ( Denis , 13a_Denis ) ;
12203: LD_EXP 21
12207: PPUSH
12208: LD_STRING 13a_Denis
12210: PPUSH
12211: CALL_OW 38
// if Brown then
12215: LD_EXP 22
12219: IFFALSE 12233
// SaveCharacters ( Brown , 13a_Brown ) ;
12221: LD_EXP 22
12225: PPUSH
12226: LD_STRING 13a_Brown
12228: PPUSH
12229: CALL_OW 38
// if Gladstone then
12233: LD_EXP 23
12237: IFFALSE 12251
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12239: LD_EXP 23
12243: PPUSH
12244: LD_STRING 13a_Gladstone
12246: PPUSH
12247: CALL_OW 38
// if Houten then
12251: LD_EXP 24
12255: IFFALSE 12269
// SaveCharacters ( Houten , 13a_Houten ) ;
12257: LD_EXP 24
12261: PPUSH
12262: LD_STRING 13a_Houten
12264: PPUSH
12265: CALL_OW 38
// if Cornel then
12269: LD_EXP 25
12273: IFFALSE 12287
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12275: LD_EXP 25
12279: PPUSH
12280: LD_STRING 13a_Cornel
12282: PPUSH
12283: CALL_OW 38
// if Gary then
12287: LD_EXP 26
12291: IFFALSE 12305
// SaveCharacters ( Gary , 13a_Gary ) ;
12293: LD_EXP 26
12297: PPUSH
12298: LD_STRING 13a_Gary
12300: PPUSH
12301: CALL_OW 38
// if Frank then
12305: LD_EXP 27
12309: IFFALSE 12323
// SaveCharacters ( Frank , 13a_Frank ) ;
12311: LD_EXP 27
12315: PPUSH
12316: LD_STRING 13a_Frank
12318: PPUSH
12319: CALL_OW 38
// if Kikuchi then
12323: LD_EXP 28
12327: IFFALSE 12341
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12329: LD_EXP 28
12333: PPUSH
12334: LD_STRING 13a_Kikuchi
12336: PPUSH
12337: CALL_OW 38
// if Simms then
12341: LD_EXP 29
12345: IFFALSE 12359
// SaveCharacters ( Simms , 13a_Simms ) ;
12347: LD_EXP 29
12351: PPUSH
12352: LD_STRING 13a_Simms
12354: PPUSH
12355: CALL_OW 38
// if Joan then
12359: LD_EXP 30
12363: IFFALSE 12377
// SaveCharacters ( Joan , 13a_Joan ) ;
12365: LD_EXP 30
12369: PPUSH
12370: LD_STRING 13a_Joan
12372: PPUSH
12373: CALL_OW 38
// if DeltaDoctor then
12377: LD_EXP 31
12381: IFFALSE 12395
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12383: LD_EXP 31
12387: PPUSH
12388: LD_STRING 13a_DeltaDoctor
12390: PPUSH
12391: CALL_OW 38
// if Gossudarov then
12395: LD_EXP 32
12399: IFFALSE 12413
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12401: LD_EXP 32
12405: PPUSH
12406: LD_STRING 13a_Gossudarov
12408: PPUSH
12409: CALL_OW 38
// if Kirilenkova then
12413: LD_EXP 33
12417: IFFALSE 12431
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12419: LD_EXP 33
12423: PPUSH
12424: LD_STRING 13a_Kirilenkova
12426: PPUSH
12427: CALL_OW 38
// if Roth then
12431: LD_EXP 16
12435: IFFALSE 12449
// SaveCharacters ( Roth , 13a_Roth ) ;
12437: LD_EXP 16
12441: PPUSH
12442: LD_STRING 13a_Roth
12444: PPUSH
12445: CALL_OW 38
// if Masha then
12449: LD_EXP 49
12453: IFFALSE 12508
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12455: LD_EXP 49
12459: PPUSH
12460: CALL_OW 265
12464: PUSH
12465: LD_EXP 49
12469: PPUSH
12470: CALL_OW 262
12474: PUSH
12475: LD_EXP 49
12479: PPUSH
12480: CALL_OW 263
12484: PUSH
12485: LD_EXP 49
12489: PPUSH
12490: CALL_OW 264
12494: PUSH
12495: EMPTY
12496: LIST
12497: LIST
12498: LIST
12499: LIST
12500: PPUSH
12501: LD_STRING 13a_Masha
12503: PPUSH
12504: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12508: LD_ADDR_VAR 0 2
12512: PUSH
12513: LD_INT 21
12515: PUSH
12516: LD_INT 3
12518: PUSH
12519: EMPTY
12520: LIST
12521: LIST
12522: PPUSH
12523: CALL_OW 69
12527: ST_TO_ADDR
// tmp2 := [ ] ;
12528: LD_ADDR_VAR 0 3
12532: PUSH
12533: EMPTY
12534: ST_TO_ADDR
// if tmp then
12535: LD_VAR 0 2
12539: IFFALSE 12690
// for i in tmp do
12541: LD_ADDR_VAR 0 1
12545: PUSH
12546: LD_VAR 0 2
12550: PUSH
12551: FOR_IN
12552: IFFALSE 12688
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12554: LD_ADDR_VAR 0 3
12558: PUSH
12559: LD_VAR 0 3
12563: PUSH
12564: LD_VAR 0 1
12568: PPUSH
12569: CALL_OW 255
12573: PUSH
12574: LD_VAR 0 1
12578: PPUSH
12579: CALL_OW 248
12583: PUSH
12584: LD_VAR 0 1
12588: PPUSH
12589: CALL_OW 266
12593: PUSH
12594: LD_VAR 0 1
12598: PPUSH
12599: CALL_OW 250
12603: PUSH
12604: LD_VAR 0 1
12608: PPUSH
12609: CALL_OW 251
12613: PUSH
12614: LD_VAR 0 1
12618: PPUSH
12619: CALL_OW 254
12623: PUSH
12624: LD_VAR 0 1
12628: PPUSH
12629: CALL_OW 267
12633: PUSH
12634: LD_VAR 0 1
12638: PPUSH
12639: LD_INT 1
12641: PPUSH
12642: CALL_OW 268
12646: PUSH
12647: LD_VAR 0 1
12651: PPUSH
12652: LD_INT 2
12654: PPUSH
12655: CALL_OW 268
12659: PUSH
12660: LD_VAR 0 1
12664: PPUSH
12665: CALL_OW 269
12669: PUSH
12670: EMPTY
12671: LIST
12672: LIST
12673: LIST
12674: LIST
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: PUSH
12682: EMPTY
12683: LIST
12684: ADD
12685: ST_TO_ADDR
12686: GO 12551
12688: POP
12689: POP
// if tmp2 then
12690: LD_VAR 0 3
12694: IFFALSE 12708
// SaveVariable ( tmp2 , 13a_buildings ) ;
12696: LD_VAR 0 3
12700: PPUSH
12701: LD_STRING 13a_buildings
12703: PPUSH
12704: CALL_OW 39
// YouWin ;
12708: CALL_OW 103
// end ;
12712: PPOPN 6
12714: END
// export function SciRu ; var tmp , t ; begin
12715: LD_INT 0
12717: PPUSH
12718: PPUSH
12719: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12720: LD_ADDR_VAR 0 3
12724: PUSH
12725: LD_EXP 32
12729: PUSH
12730: LD_EXP 46
12734: PUSH
12735: LD_EXP 34
12739: PUSH
12740: LD_EXP 47
12744: PUSH
12745: LD_EXP 48
12749: PUSH
12750: LD_EXP 37
12754: PUSH
12755: LD_EXP 38
12759: PUSH
12760: LD_EXP 36
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12775: LD_ADDR_VAR 0 2
12779: PUSH
12780: LD_INT 22
12782: PUSH
12783: LD_INT 7
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 23
12792: PUSH
12793: LD_INT 3
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 25
12802: PUSH
12803: LD_INT 4
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: LD_INT 26
12812: PUSH
12813: LD_INT 1
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: PPUSH
12826: CALL_OW 69
12830: PUSH
12831: LD_VAR 0 3
12835: DIFF
12836: ST_TO_ADDR
// if tmp then
12837: LD_VAR 0 2
12841: IFFALSE 12857
// result := tmp [ 1 ] ;
12843: LD_ADDR_VAR 0 1
12847: PUSH
12848: LD_VAR 0 2
12852: PUSH
12853: LD_INT 1
12855: ARRAY
12856: ST_TO_ADDR
// end ;
12857: LD_VAR 0 1
12861: RET
// export function SolRu ; var tmp , t ; begin
12862: LD_INT 0
12864: PPUSH
12865: PPUSH
12866: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12867: LD_ADDR_VAR 0 3
12871: PUSH
12872: LD_EXP 32
12876: PUSH
12877: LD_EXP 46
12881: PUSH
12882: LD_EXP 34
12886: PUSH
12887: LD_EXP 47
12891: PUSH
12892: LD_EXP 48
12896: PUSH
12897: LD_EXP 37
12901: PUSH
12902: LD_EXP 38
12906: PUSH
12907: LD_EXP 36
12911: PUSH
12912: EMPTY
12913: LIST
12914: LIST
12915: LIST
12916: LIST
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12922: LD_ADDR_VAR 0 2
12926: PUSH
12927: LD_INT 22
12929: PUSH
12930: LD_INT 7
12932: PUSH
12933: EMPTY
12934: LIST
12935: LIST
12936: PUSH
12937: LD_INT 23
12939: PUSH
12940: LD_INT 3
12942: PUSH
12943: EMPTY
12944: LIST
12945: LIST
12946: PUSH
12947: LD_INT 25
12949: PUSH
12950: LD_INT 1
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: PUSH
12957: LD_INT 26
12959: PUSH
12960: LD_INT 1
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: PPUSH
12973: CALL_OW 69
12977: PUSH
12978: LD_VAR 0 3
12982: DIFF
12983: ST_TO_ADDR
// if tmp then
12984: LD_VAR 0 2
12988: IFFALSE 13004
// result := tmp [ 1 ] ;
12990: LD_ADDR_VAR 0 1
12994: PUSH
12995: LD_VAR 0 2
12999: PUSH
13000: LD_INT 1
13002: ARRAY
13003: ST_TO_ADDR
// end ; end_of_file
13004: LD_VAR 0 1
13008: RET
// export function CustomEvent ( event ) ; begin
13009: LD_INT 0
13011: PPUSH
// end ;
13012: LD_VAR 0 2
13016: RET
// on UnitDestroyed ( un ) do var i , side ;
13017: LD_INT 0
13019: PPUSH
13020: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13021: LD_VAR 0 1
13025: PUSH
13026: LD_INT 22
13028: PUSH
13029: LD_INT 7
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: PUSH
13036: LD_INT 2
13038: PUSH
13039: LD_INT 25
13041: PUSH
13042: LD_INT 1
13044: PUSH
13045: EMPTY
13046: LIST
13047: LIST
13048: PUSH
13049: LD_INT 25
13051: PUSH
13052: LD_INT 2
13054: PUSH
13055: EMPTY
13056: LIST
13057: LIST
13058: PUSH
13059: LD_INT 25
13061: PUSH
13062: LD_INT 3
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: PUSH
13069: LD_INT 25
13071: PUSH
13072: LD_INT 4
13074: PUSH
13075: EMPTY
13076: LIST
13077: LIST
13078: PUSH
13079: LD_INT 25
13081: PUSH
13082: LD_INT 5
13084: PUSH
13085: EMPTY
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 25
13091: PUSH
13092: LD_INT 8
13094: PUSH
13095: EMPTY
13096: LIST
13097: LIST
13098: PUSH
13099: LD_INT 25
13101: PUSH
13102: LD_INT 9
13104: PUSH
13105: EMPTY
13106: LIST
13107: LIST
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: PUSH
13119: EMPTY
13120: LIST
13121: LIST
13122: PPUSH
13123: CALL_OW 69
13127: IN
13128: IFFALSE 13144
// loss_counter := loss_counter + 1 ;
13130: LD_ADDR_EXP 13
13134: PUSH
13135: LD_EXP 13
13139: PUSH
13140: LD_INT 1
13142: PLUS
13143: ST_TO_ADDR
// if un = Abdul then
13144: LD_VAR 0 1
13148: PUSH
13149: LD_EXP 55
13153: EQUAL
13154: IFFALSE 13164
// abdul_escaped := false ;
13156: LD_ADDR_EXP 12
13160: PUSH
13161: LD_INT 0
13163: ST_TO_ADDR
// if un in ru_attackers then
13164: LD_VAR 0 1
13168: PUSH
13169: LD_EXP 52
13173: IN
13174: IFFALSE 13192
// ru_attackers := ru_attackers diff un ;
13176: LD_ADDR_EXP 52
13180: PUSH
13181: LD_EXP 52
13185: PUSH
13186: LD_VAR 0 1
13190: DIFF
13191: ST_TO_ADDR
// if un in ar_attackers then
13192: LD_VAR 0 1
13196: PUSH
13197: LD_EXP 10
13201: IN
13202: IFFALSE 13220
// ar_attackers := ar_attackers diff un ;
13204: LD_ADDR_EXP 10
13208: PUSH
13209: LD_EXP 10
13213: PUSH
13214: LD_VAR 0 1
13218: DIFF
13219: ST_TO_ADDR
// if un = JMM then
13220: LD_VAR 0 1
13224: PUSH
13225: LD_EXP 15
13229: EQUAL
13230: IFFALSE 13241
// begin YouLost ( JMM ) ;
13232: LD_STRING JMM
13234: PPUSH
13235: CALL_OW 104
// exit ;
13239: GO 13330
// end ; if un = Burlak then
13241: LD_VAR 0 1
13245: PUSH
13246: LD_EXP 46
13250: EQUAL
13251: IFFALSE 13262
// begin YouLost ( Burlak ) ;
13253: LD_STRING Burlak
13255: PPUSH
13256: CALL_OW 104
// exit ;
13260: GO 13330
// end ; if un = freedom then
13262: LD_VAR 0 1
13266: PUSH
13267: LD_EXP 3
13271: EQUAL
13272: IFFALSE 13283
// begin YouLost ( Destroyed ) ;
13274: LD_STRING Destroyed
13276: PPUSH
13277: CALL_OW 104
// exit ;
13281: GO 13330
// end ; if un = Masha then
13283: LD_VAR 0 1
13287: PUSH
13288: LD_EXP 49
13292: EQUAL
13293: IFFALSE 13302
// ChangeMissionObjectives ( M4b ) ;
13295: LD_STRING M4b
13297: PPUSH
13298: CALL_OW 337
// if un = Mastodont then
13302: LD_VAR 0 1
13306: PUSH
13307: LD_EXP 56
13311: EQUAL
13312: IFFALSE 13321
// ChangeMissionObjectives ( M4a ) ;
13314: LD_STRING M4a
13316: PPUSH
13317: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13321: LD_VAR 0 1
13325: PPUSH
13326: CALL 84641 0 1
// end ;
13330: PPOPN 3
13332: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13333: LD_VAR 0 1
13337: PPUSH
13338: LD_VAR 0 2
13342: PPUSH
13343: CALL 86975 0 2
// end ;
13347: PPOPN 2
13349: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13350: LD_VAR 0 1
13354: PPUSH
13355: CALL 86043 0 1
// end ;
13359: PPOPN 1
13361: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13362: LD_VAR 0 1
13366: PUSH
13367: LD_INT 22
13369: PUSH
13370: LD_INT 7
13372: PUSH
13373: EMPTY
13374: LIST
13375: LIST
13376: PUSH
13377: LD_INT 30
13379: PUSH
13380: LD_INT 0
13382: PUSH
13383: EMPTY
13384: LIST
13385: LIST
13386: PUSH
13387: EMPTY
13388: LIST
13389: LIST
13390: PPUSH
13391: CALL_OW 69
13395: IN
13396: IFFALSE 13435
// begin SetBName ( building , freedom ) ;
13398: LD_VAR 0 1
13402: PPUSH
13403: LD_STRING freedom
13405: PPUSH
13406: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13410: LD_INT 0
13412: PPUSH
13413: LD_INT 7
13415: PPUSH
13416: LD_INT 0
13418: PPUSH
13419: CALL_OW 324
// freedom := building ;
13423: LD_ADDR_EXP 3
13427: PUSH
13428: LD_VAR 0 1
13432: ST_TO_ADDR
// exit ;
13433: GO 13501
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13435: LD_VAR 0 1
13439: PUSH
13440: LD_INT 22
13442: PUSH
13443: LD_INT 7
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: PUSH
13450: LD_INT 23
13452: PUSH
13453: LD_INT 3
13455: PUSH
13456: EMPTY
13457: LIST
13458: LIST
13459: PUSH
13460: LD_INT 30
13462: PUSH
13463: LD_INT 6
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: LIST
13474: PPUSH
13475: CALL_OW 69
13479: IN
13480: IFFALSE 13492
// begin ru_lab_builded := true ;
13482: LD_ADDR_EXP 5
13486: PUSH
13487: LD_INT 1
13489: ST_TO_ADDR
// exit ;
13490: GO 13501
// end ; MCE_BuildingComplete ( building ) ;
13492: LD_VAR 0 1
13496: PPUSH
13497: CALL 86284 0 1
// end ;
13501: PPOPN 1
13503: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13504: LD_VAR 0 1
13508: PPUSH
13509: LD_VAR 0 2
13513: PPUSH
13514: CALL 84337 0 2
// end ;
13518: PPOPN 2
13520: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13521: LD_VAR 0 1
13525: PPUSH
13526: LD_VAR 0 2
13530: PPUSH
13531: LD_VAR 0 3
13535: PPUSH
13536: LD_VAR 0 4
13540: PPUSH
13541: LD_VAR 0 5
13545: PPUSH
13546: CALL 83957 0 5
// end ;
13550: PPOPN 5
13552: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13553: LD_VAR 0 1
13557: PPUSH
13558: LD_VAR 0 2
13562: PPUSH
13563: CALL 83553 0 2
// end ;
13567: PPOPN 2
13569: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13570: LD_VAR 0 1
13574: PPUSH
13575: CALL_OW 263
13579: PUSH
13580: LD_INT 3
13582: EQUAL
13583: PUSH
13584: LD_VAR 0 2
13588: PPUSH
13589: CALL_OW 263
13593: PUSH
13594: LD_INT 3
13596: EQUAL
13597: OR
13598: IFFALSE 13614
// hack_counter := hack_counter + 1 ;
13600: LD_ADDR_EXP 14
13604: PUSH
13605: LD_EXP 14
13609: PUSH
13610: LD_INT 1
13612: PLUS
13613: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13614: LD_VAR 0 1
13618: PPUSH
13619: LD_VAR 0 2
13623: PPUSH
13624: LD_VAR 0 3
13628: PPUSH
13629: LD_VAR 0 4
13633: PPUSH
13634: CALL 83391 0 4
// end ;
13638: PPOPN 4
13640: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13641: LD_VAR 0 1
13645: PPUSH
13646: LD_VAR 0 2
13650: PPUSH
13651: LD_VAR 0 3
13655: PPUSH
13656: CALL 83166 0 3
// end ;
13660: PPOPN 3
13662: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13663: LD_VAR 0 1
13667: PPUSH
13668: LD_VAR 0 2
13672: PPUSH
13673: CALL 83051 0 2
// end ;
13677: PPOPN 2
13679: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13680: LD_VAR 0 1
13684: PPUSH
13685: LD_VAR 0 2
13689: PPUSH
13690: CALL 87236 0 2
// end ;
13694: PPOPN 2
13696: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13697: LD_VAR 0 1
13701: PPUSH
13702: LD_VAR 0 2
13706: PPUSH
13707: LD_VAR 0 3
13711: PPUSH
13712: LD_VAR 0 4
13716: PPUSH
13717: CALL 87452 0 4
// end ;
13721: PPOPN 4
13723: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13724: LD_VAR 0 1
13728: PPUSH
13729: LD_VAR 0 2
13733: PPUSH
13734: CALL 82860 0 2
// end ;
13738: PPOPN 2
13740: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13741: LD_VAR 0 1
13745: PPUSH
13746: CALL 87735 0 1
// end ; end_of_file
13750: PPOPN 1
13752: END
// every 0 0$30 do var cr , time ;
13753: GO 13755
13755: DISABLE
13756: LD_INT 0
13758: PPUSH
13759: PPUSH
// begin time := 0 0$30 ;
13760: LD_ADDR_VAR 0 2
13764: PUSH
13765: LD_INT 1050
13767: ST_TO_ADDR
// while game do
13768: LD_EXP 2
13772: IFFALSE 13871
// begin wait ( time ) ;
13774: LD_VAR 0 2
13778: PPUSH
13779: CALL_OW 67
// if tick > 2 2$00 then
13783: LD_OWVAR 1
13787: PUSH
13788: LD_INT 4200
13790: GREATER
13791: IFFALSE 13824
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13793: LD_ADDR_VAR 0 2
13797: PUSH
13798: LD_VAR 0 2
13802: PUSH
13803: LD_INT 280
13805: PUSH
13806: LD_INT 420
13808: PUSH
13809: LD_INT 630
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: LIST
13816: PUSH
13817: LD_OWVAR 67
13821: ARRAY
13822: PLUS
13823: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13824: LD_INT 1
13826: PPUSH
13827: LD_INT 5
13829: PPUSH
13830: CALL_OW 12
13834: PPUSH
13835: LD_INT 70
13837: PPUSH
13838: LD_INT 49
13840: PPUSH
13841: LD_INT 25
13843: PPUSH
13844: LD_INT 1
13846: PPUSH
13847: CALL_OW 56
// if time > 5 5$00 then
13851: LD_VAR 0 2
13855: PUSH
13856: LD_INT 10500
13858: GREATER
13859: IFFALSE 13869
// time := 0 0$30 ;
13861: LD_ADDR_VAR 0 2
13865: PUSH
13866: LD_INT 1050
13868: ST_TO_ADDR
// end ;
13869: GO 13768
// end ;
13871: PPOPN 2
13873: END
// every 0 0$30 do var cr , time ;
13874: GO 13876
13876: DISABLE
13877: LD_INT 0
13879: PPUSH
13880: PPUSH
// begin time := 0 0$20 ;
13881: LD_ADDR_VAR 0 2
13885: PUSH
13886: LD_INT 700
13888: ST_TO_ADDR
// while game do
13889: LD_EXP 2
13893: IFFALSE 13982
// begin wait ( time ) ;
13895: LD_VAR 0 2
13899: PPUSH
13900: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13904: LD_ADDR_VAR 0 2
13908: PUSH
13909: LD_VAR 0 2
13913: PUSH
13914: LD_INT 490
13916: PUSH
13917: LD_INT 525
13919: PUSH
13920: LD_INT 560
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: LIST
13927: PUSH
13928: LD_OWVAR 67
13932: ARRAY
13933: PLUS
13934: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13935: LD_INT 3
13937: PPUSH
13938: LD_INT 5
13940: PPUSH
13941: CALL_OW 12
13945: PPUSH
13946: LD_INT 26
13948: PPUSH
13949: LD_INT 9
13951: PPUSH
13952: LD_INT 30
13954: PPUSH
13955: LD_INT 1
13957: PPUSH
13958: CALL_OW 56
// if time > 3 3$00 then
13962: LD_VAR 0 2
13966: PUSH
13967: LD_INT 6300
13969: GREATER
13970: IFFALSE 13980
// time := 0 0$20 ;
13972: LD_ADDR_VAR 0 2
13976: PUSH
13977: LD_INT 700
13979: ST_TO_ADDR
// end ;
13980: GO 13889
// end ;
13982: PPOPN 2
13984: END
// every 0 0$30 do var cr , time ;
13985: GO 13987
13987: DISABLE
13988: LD_INT 0
13990: PPUSH
13991: PPUSH
// begin time := 0 0$20 ;
13992: LD_ADDR_VAR 0 2
13996: PUSH
13997: LD_INT 700
13999: ST_TO_ADDR
// while game do
14000: LD_EXP 2
14004: IFFALSE 14129
// begin wait ( time ) ;
14006: LD_VAR 0 2
14010: PPUSH
14011: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14015: LD_ADDR_VAR 0 2
14019: PUSH
14020: LD_VAR 0 2
14024: PUSH
14025: LD_INT 175
14027: PUSH
14028: LD_INT 210
14030: PUSH
14031: LD_INT 280
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: LIST
14038: PUSH
14039: LD_OWVAR 67
14043: ARRAY
14044: PLUS
14045: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14046: LD_INT 1
14048: PPUSH
14049: LD_INT 5
14051: PPUSH
14052: CALL_OW 12
14056: PPUSH
14057: LD_INT 179
14059: PPUSH
14060: LD_INT 101
14062: PPUSH
14063: LD_INT 20
14065: PPUSH
14066: LD_INT 1
14068: PPUSH
14069: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14073: LD_INT 350
14075: PPUSH
14076: LD_INT 525
14078: PPUSH
14079: CALL_OW 12
14083: PPUSH
14084: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14088: LD_INT 1
14090: PPUSH
14091: LD_INT 5
14093: PPUSH
14094: CALL_OW 12
14098: PPUSH
14099: LD_INT 9
14101: PPUSH
14102: LD_INT 1
14104: PPUSH
14105: CALL_OW 55
// if time > 4 4$00 then
14109: LD_VAR 0 2
14113: PUSH
14114: LD_INT 8400
14116: GREATER
14117: IFFALSE 14127
// time := 0 0$30 ;
14119: LD_ADDR_VAR 0 2
14123: PUSH
14124: LD_INT 1050
14126: ST_TO_ADDR
// end ;
14127: GO 14000
// end ;
14129: PPOPN 2
14131: END
// every 0 0$30 do var cr , time ;
14132: GO 14134
14134: DISABLE
14135: LD_INT 0
14137: PPUSH
14138: PPUSH
// begin time := 0 0$10 ;
14139: LD_ADDR_VAR 0 2
14143: PUSH
14144: LD_INT 350
14146: ST_TO_ADDR
// while game do
14147: LD_EXP 2
14151: IFFALSE 14285
// begin wait ( time ) ;
14153: LD_VAR 0 2
14157: PPUSH
14158: CALL_OW 67
// time := time + 0 0$10 ;
14162: LD_ADDR_VAR 0 2
14166: PUSH
14167: LD_VAR 0 2
14171: PUSH
14172: LD_INT 350
14174: PLUS
14175: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14176: LD_INT 1
14178: PPUSH
14179: LD_INT 5
14181: PPUSH
14182: CALL_OW 12
14186: PPUSH
14187: LD_INT 11
14189: PPUSH
14190: LD_INT 1
14192: PPUSH
14193: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14197: LD_ADDR_VAR 0 1
14201: PUSH
14202: LD_INT 1
14204: PPUSH
14205: LD_INT 3
14207: PPUSH
14208: CALL_OW 12
14212: ST_TO_ADDR
// if cr = 1 then
14213: LD_VAR 0 1
14217: PUSH
14218: LD_INT 1
14220: EQUAL
14221: IFFALSE 14265
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14223: LD_INT 700
14225: PPUSH
14226: LD_INT 1575
14228: PPUSH
14229: CALL_OW 12
14233: PPUSH
14234: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14238: LD_INT 1
14240: PPUSH
14241: LD_INT 5
14243: PPUSH
14244: CALL_OW 12
14248: PPUSH
14249: LD_INT 34
14251: PPUSH
14252: LD_INT 50
14254: PPUSH
14255: LD_INT 7
14257: PPUSH
14258: LD_INT 1
14260: PPUSH
14261: CALL_OW 56
// end ; if time > 8 8$00 then
14265: LD_VAR 0 2
14269: PUSH
14270: LD_INT 16800
14272: GREATER
14273: IFFALSE 14283
// time := 0 0$40 ;
14275: LD_ADDR_VAR 0 2
14279: PUSH
14280: LD_INT 1400
14282: ST_TO_ADDR
// end ;
14283: GO 14147
// end ; end_of_file
14285: PPOPN 2
14287: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14288: LD_INT 0
14290: PPUSH
14291: PPUSH
// if exist_mode then
14292: LD_VAR 0 2
14296: IFFALSE 14321
// unit := CreateCharacter ( prefix & ident ) else
14298: LD_ADDR_VAR 0 5
14302: PUSH
14303: LD_VAR 0 3
14307: PUSH
14308: LD_VAR 0 1
14312: STR
14313: PPUSH
14314: CALL_OW 34
14318: ST_TO_ADDR
14319: GO 14336
// unit := NewCharacter ( ident ) ;
14321: LD_ADDR_VAR 0 5
14325: PUSH
14326: LD_VAR 0 1
14330: PPUSH
14331: CALL_OW 25
14335: ST_TO_ADDR
// result := unit ;
14336: LD_ADDR_VAR 0 4
14340: PUSH
14341: LD_VAR 0 5
14345: ST_TO_ADDR
// end ;
14346: LD_VAR 0 4
14350: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14351: LD_INT 0
14353: PPUSH
14354: PPUSH
// if not side or not nation then
14355: LD_VAR 0 1
14359: NOT
14360: PUSH
14361: LD_VAR 0 2
14365: NOT
14366: OR
14367: IFFALSE 14371
// exit ;
14369: GO 15015
// case nation of nation_american :
14371: LD_VAR 0 2
14375: PUSH
14376: LD_INT 1
14378: DOUBLE
14379: EQUAL
14380: IFTRUE 14384
14382: GO 14558
14384: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14385: LD_ADDR_VAR 0 4
14389: PUSH
14390: LD_INT 35
14392: PUSH
14393: LD_INT 45
14395: PUSH
14396: LD_INT 46
14398: PUSH
14399: LD_INT 47
14401: PUSH
14402: LD_INT 1
14404: PUSH
14405: LD_INT 2
14407: PUSH
14408: LD_INT 6
14410: PUSH
14411: LD_INT 15
14413: PUSH
14414: LD_INT 16
14416: PUSH
14417: LD_INT 7
14419: PUSH
14420: LD_INT 12
14422: PUSH
14423: LD_INT 13
14425: PUSH
14426: LD_INT 10
14428: PUSH
14429: LD_INT 14
14431: PUSH
14432: LD_INT 20
14434: PUSH
14435: LD_INT 21
14437: PUSH
14438: LD_INT 22
14440: PUSH
14441: LD_INT 25
14443: PUSH
14444: LD_INT 32
14446: PUSH
14447: LD_INT 27
14449: PUSH
14450: LD_INT 36
14452: PUSH
14453: LD_INT 69
14455: PUSH
14456: LD_INT 39
14458: PUSH
14459: LD_INT 34
14461: PUSH
14462: LD_INT 40
14464: PUSH
14465: LD_INT 48
14467: PUSH
14468: LD_INT 49
14470: PUSH
14471: LD_INT 50
14473: PUSH
14474: LD_INT 51
14476: PUSH
14477: LD_INT 52
14479: PUSH
14480: LD_INT 53
14482: PUSH
14483: LD_INT 54
14485: PUSH
14486: LD_INT 55
14488: PUSH
14489: LD_INT 56
14491: PUSH
14492: LD_INT 57
14494: PUSH
14495: LD_INT 58
14497: PUSH
14498: LD_INT 59
14500: PUSH
14501: LD_INT 60
14503: PUSH
14504: LD_INT 61
14506: PUSH
14507: LD_INT 62
14509: PUSH
14510: LD_INT 80
14512: PUSH
14513: EMPTY
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: ST_TO_ADDR
14556: GO 14939
14558: LD_INT 2
14560: DOUBLE
14561: EQUAL
14562: IFTRUE 14566
14564: GO 14748
14566: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14567: LD_ADDR_VAR 0 4
14571: PUSH
14572: LD_INT 35
14574: PUSH
14575: LD_INT 45
14577: PUSH
14578: LD_INT 46
14580: PUSH
14581: LD_INT 47
14583: PUSH
14584: LD_INT 70
14586: PUSH
14587: LD_INT 1
14589: PUSH
14590: LD_INT 11
14592: PUSH
14593: LD_INT 3
14595: PUSH
14596: LD_INT 4
14598: PUSH
14599: LD_INT 5
14601: PUSH
14602: LD_INT 6
14604: PUSH
14605: LD_INT 15
14607: PUSH
14608: LD_INT 18
14610: PUSH
14611: LD_INT 7
14613: PUSH
14614: LD_INT 17
14616: PUSH
14617: LD_INT 8
14619: PUSH
14620: LD_INT 20
14622: PUSH
14623: LD_INT 21
14625: PUSH
14626: LD_INT 22
14628: PUSH
14629: LD_INT 72
14631: PUSH
14632: LD_INT 26
14634: PUSH
14635: LD_INT 69
14637: PUSH
14638: LD_INT 39
14640: PUSH
14641: LD_INT 40
14643: PUSH
14644: LD_INT 41
14646: PUSH
14647: LD_INT 42
14649: PUSH
14650: LD_INT 43
14652: PUSH
14653: LD_INT 48
14655: PUSH
14656: LD_INT 49
14658: PUSH
14659: LD_INT 50
14661: PUSH
14662: LD_INT 51
14664: PUSH
14665: LD_INT 52
14667: PUSH
14668: LD_INT 53
14670: PUSH
14671: LD_INT 54
14673: PUSH
14674: LD_INT 55
14676: PUSH
14677: LD_INT 56
14679: PUSH
14680: LD_INT 60
14682: PUSH
14683: LD_INT 61
14685: PUSH
14686: LD_INT 62
14688: PUSH
14689: LD_INT 66
14691: PUSH
14692: LD_INT 67
14694: PUSH
14695: LD_INT 68
14697: PUSH
14698: LD_INT 81
14700: PUSH
14701: EMPTY
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: LIST
14707: LIST
14708: LIST
14709: LIST
14710: LIST
14711: LIST
14712: LIST
14713: LIST
14714: LIST
14715: LIST
14716: LIST
14717: LIST
14718: LIST
14719: LIST
14720: LIST
14721: LIST
14722: LIST
14723: LIST
14724: LIST
14725: LIST
14726: LIST
14727: LIST
14728: LIST
14729: LIST
14730: LIST
14731: LIST
14732: LIST
14733: LIST
14734: LIST
14735: LIST
14736: LIST
14737: LIST
14738: LIST
14739: LIST
14740: LIST
14741: LIST
14742: LIST
14743: LIST
14744: LIST
14745: ST_TO_ADDR
14746: GO 14939
14748: LD_INT 3
14750: DOUBLE
14751: EQUAL
14752: IFTRUE 14756
14754: GO 14938
14756: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14757: LD_ADDR_VAR 0 4
14761: PUSH
14762: LD_INT 46
14764: PUSH
14765: LD_INT 47
14767: PUSH
14768: LD_INT 1
14770: PUSH
14771: LD_INT 2
14773: PUSH
14774: LD_INT 11
14776: PUSH
14777: LD_INT 9
14779: PUSH
14780: LD_INT 20
14782: PUSH
14783: LD_INT 19
14785: PUSH
14786: LD_INT 21
14788: PUSH
14789: LD_INT 24
14791: PUSH
14792: LD_INT 22
14794: PUSH
14795: LD_INT 25
14797: PUSH
14798: LD_INT 28
14800: PUSH
14801: LD_INT 29
14803: PUSH
14804: LD_INT 30
14806: PUSH
14807: LD_INT 31
14809: PUSH
14810: LD_INT 37
14812: PUSH
14813: LD_INT 38
14815: PUSH
14816: LD_INT 32
14818: PUSH
14819: LD_INT 27
14821: PUSH
14822: LD_INT 33
14824: PUSH
14825: LD_INT 69
14827: PUSH
14828: LD_INT 39
14830: PUSH
14831: LD_INT 34
14833: PUSH
14834: LD_INT 40
14836: PUSH
14837: LD_INT 71
14839: PUSH
14840: LD_INT 23
14842: PUSH
14843: LD_INT 44
14845: PUSH
14846: LD_INT 48
14848: PUSH
14849: LD_INT 49
14851: PUSH
14852: LD_INT 50
14854: PUSH
14855: LD_INT 51
14857: PUSH
14858: LD_INT 52
14860: PUSH
14861: LD_INT 53
14863: PUSH
14864: LD_INT 54
14866: PUSH
14867: LD_INT 55
14869: PUSH
14870: LD_INT 56
14872: PUSH
14873: LD_INT 57
14875: PUSH
14876: LD_INT 58
14878: PUSH
14879: LD_INT 59
14881: PUSH
14882: LD_INT 63
14884: PUSH
14885: LD_INT 64
14887: PUSH
14888: LD_INT 65
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: LIST
14895: LIST
14896: LIST
14897: LIST
14898: LIST
14899: LIST
14900: LIST
14901: LIST
14902: LIST
14903: LIST
14904: LIST
14905: LIST
14906: LIST
14907: LIST
14908: LIST
14909: LIST
14910: LIST
14911: LIST
14912: LIST
14913: LIST
14914: LIST
14915: LIST
14916: LIST
14917: LIST
14918: LIST
14919: LIST
14920: LIST
14921: LIST
14922: LIST
14923: LIST
14924: LIST
14925: LIST
14926: LIST
14927: LIST
14928: LIST
14929: LIST
14930: LIST
14931: LIST
14932: LIST
14933: LIST
14934: LIST
14935: ST_TO_ADDR
14936: GO 14939
14938: POP
// if state > - 1 and state < 3 then
14939: LD_VAR 0 3
14943: PUSH
14944: LD_INT 1
14946: NEG
14947: GREATER
14948: PUSH
14949: LD_VAR 0 3
14953: PUSH
14954: LD_INT 3
14956: LESS
14957: AND
14958: IFFALSE 15015
// for i in result do
14960: LD_ADDR_VAR 0 5
14964: PUSH
14965: LD_VAR 0 4
14969: PUSH
14970: FOR_IN
14971: IFFALSE 15013
// if GetTech ( i , side ) <> state then
14973: LD_VAR 0 5
14977: PPUSH
14978: LD_VAR 0 1
14982: PPUSH
14983: CALL_OW 321
14987: PUSH
14988: LD_VAR 0 3
14992: NONEQUAL
14993: IFFALSE 15011
// result := result diff i ;
14995: LD_ADDR_VAR 0 4
14999: PUSH
15000: LD_VAR 0 4
15004: PUSH
15005: LD_VAR 0 5
15009: DIFF
15010: ST_TO_ADDR
15011: GO 14970
15013: POP
15014: POP
// end ;
15015: LD_VAR 0 4
15019: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15020: LD_INT 0
15022: PPUSH
15023: PPUSH
15024: PPUSH
// result := true ;
15025: LD_ADDR_VAR 0 3
15029: PUSH
15030: LD_INT 1
15032: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15033: LD_ADDR_VAR 0 5
15037: PUSH
15038: LD_VAR 0 2
15042: PPUSH
15043: CALL_OW 480
15047: ST_TO_ADDR
// if not tmp then
15048: LD_VAR 0 5
15052: NOT
15053: IFFALSE 15057
// exit ;
15055: GO 15106
// for i in tmp do
15057: LD_ADDR_VAR 0 4
15061: PUSH
15062: LD_VAR 0 5
15066: PUSH
15067: FOR_IN
15068: IFFALSE 15104
// if GetTech ( i , side ) <> state_researched then
15070: LD_VAR 0 4
15074: PPUSH
15075: LD_VAR 0 1
15079: PPUSH
15080: CALL_OW 321
15084: PUSH
15085: LD_INT 2
15087: NONEQUAL
15088: IFFALSE 15102
// begin result := false ;
15090: LD_ADDR_VAR 0 3
15094: PUSH
15095: LD_INT 0
15097: ST_TO_ADDR
// exit ;
15098: POP
15099: POP
15100: GO 15106
// end ;
15102: GO 15067
15104: POP
15105: POP
// end ;
15106: LD_VAR 0 3
15110: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15111: LD_INT 0
15113: PPUSH
15114: PPUSH
15115: PPUSH
15116: PPUSH
15117: PPUSH
15118: PPUSH
15119: PPUSH
15120: PPUSH
15121: PPUSH
15122: PPUSH
15123: PPUSH
15124: PPUSH
15125: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15126: LD_VAR 0 1
15130: NOT
15131: PUSH
15132: LD_VAR 0 1
15136: PPUSH
15137: CALL_OW 257
15141: PUSH
15142: LD_INT 9
15144: NONEQUAL
15145: OR
15146: IFFALSE 15150
// exit ;
15148: GO 15723
// side := GetSide ( unit ) ;
15150: LD_ADDR_VAR 0 9
15154: PUSH
15155: LD_VAR 0 1
15159: PPUSH
15160: CALL_OW 255
15164: ST_TO_ADDR
// tech_space := tech_spacanom ;
15165: LD_ADDR_VAR 0 12
15169: PUSH
15170: LD_INT 29
15172: ST_TO_ADDR
// tech_time := tech_taurad ;
15173: LD_ADDR_VAR 0 13
15177: PUSH
15178: LD_INT 28
15180: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15181: LD_ADDR_VAR 0 11
15185: PUSH
15186: LD_VAR 0 1
15190: PPUSH
15191: CALL_OW 310
15195: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15196: LD_VAR 0 11
15200: PPUSH
15201: CALL_OW 247
15205: PUSH
15206: LD_INT 2
15208: EQUAL
15209: IFFALSE 15213
// exit ;
15211: GO 15723
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15213: LD_ADDR_VAR 0 8
15217: PUSH
15218: LD_INT 81
15220: PUSH
15221: LD_VAR 0 9
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: PUSH
15230: LD_INT 3
15232: PUSH
15233: LD_INT 21
15235: PUSH
15236: LD_INT 3
15238: PUSH
15239: EMPTY
15240: LIST
15241: LIST
15242: PUSH
15243: EMPTY
15244: LIST
15245: LIST
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: PPUSH
15251: CALL_OW 69
15255: ST_TO_ADDR
// if not tmp then
15256: LD_VAR 0 8
15260: NOT
15261: IFFALSE 15265
// exit ;
15263: GO 15723
// if in_unit then
15265: LD_VAR 0 11
15269: IFFALSE 15293
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15271: LD_ADDR_VAR 0 10
15275: PUSH
15276: LD_VAR 0 8
15280: PPUSH
15281: LD_VAR 0 11
15285: PPUSH
15286: CALL_OW 74
15290: ST_TO_ADDR
15291: GO 15313
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15293: LD_ADDR_VAR 0 10
15297: PUSH
15298: LD_VAR 0 8
15302: PPUSH
15303: LD_VAR 0 1
15307: PPUSH
15308: CALL_OW 74
15312: ST_TO_ADDR
// if not enemy then
15313: LD_VAR 0 10
15317: NOT
15318: IFFALSE 15322
// exit ;
15320: GO 15723
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15322: LD_VAR 0 11
15326: PUSH
15327: LD_VAR 0 11
15331: PPUSH
15332: LD_VAR 0 10
15336: PPUSH
15337: CALL_OW 296
15341: PUSH
15342: LD_INT 13
15344: GREATER
15345: AND
15346: PUSH
15347: LD_VAR 0 1
15351: PPUSH
15352: LD_VAR 0 10
15356: PPUSH
15357: CALL_OW 296
15361: PUSH
15362: LD_INT 12
15364: GREATER
15365: OR
15366: IFFALSE 15370
// exit ;
15368: GO 15723
// missile := [ 1 ] ;
15370: LD_ADDR_VAR 0 14
15374: PUSH
15375: LD_INT 1
15377: PUSH
15378: EMPTY
15379: LIST
15380: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15381: LD_VAR 0 9
15385: PPUSH
15386: LD_VAR 0 12
15390: PPUSH
15391: CALL_OW 325
15395: IFFALSE 15424
// missile := Insert ( missile , missile + 1 , 2 ) ;
15397: LD_ADDR_VAR 0 14
15401: PUSH
15402: LD_VAR 0 14
15406: PPUSH
15407: LD_VAR 0 14
15411: PUSH
15412: LD_INT 1
15414: PLUS
15415: PPUSH
15416: LD_INT 2
15418: PPUSH
15419: CALL_OW 2
15423: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15424: LD_VAR 0 9
15428: PPUSH
15429: LD_VAR 0 13
15433: PPUSH
15434: CALL_OW 325
15438: PUSH
15439: LD_VAR 0 10
15443: PPUSH
15444: CALL_OW 255
15448: PPUSH
15449: LD_VAR 0 13
15453: PPUSH
15454: CALL_OW 325
15458: NOT
15459: AND
15460: IFFALSE 15489
// missile := Insert ( missile , missile + 1 , 3 ) ;
15462: LD_ADDR_VAR 0 14
15466: PUSH
15467: LD_VAR 0 14
15471: PPUSH
15472: LD_VAR 0 14
15476: PUSH
15477: LD_INT 1
15479: PLUS
15480: PPUSH
15481: LD_INT 3
15483: PPUSH
15484: CALL_OW 2
15488: ST_TO_ADDR
// if missile < 2 then
15489: LD_VAR 0 14
15493: PUSH
15494: LD_INT 2
15496: LESS
15497: IFFALSE 15501
// exit ;
15499: GO 15723
// x := GetX ( enemy ) ;
15501: LD_ADDR_VAR 0 4
15505: PUSH
15506: LD_VAR 0 10
15510: PPUSH
15511: CALL_OW 250
15515: ST_TO_ADDR
// y := GetY ( enemy ) ;
15516: LD_ADDR_VAR 0 5
15520: PUSH
15521: LD_VAR 0 10
15525: PPUSH
15526: CALL_OW 251
15530: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15531: LD_ADDR_VAR 0 6
15535: PUSH
15536: LD_VAR 0 4
15540: PUSH
15541: LD_INT 1
15543: NEG
15544: PPUSH
15545: LD_INT 1
15547: PPUSH
15548: CALL_OW 12
15552: PLUS
15553: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15554: LD_ADDR_VAR 0 7
15558: PUSH
15559: LD_VAR 0 5
15563: PUSH
15564: LD_INT 1
15566: NEG
15567: PPUSH
15568: LD_INT 1
15570: PPUSH
15571: CALL_OW 12
15575: PLUS
15576: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15577: LD_VAR 0 6
15581: PPUSH
15582: LD_VAR 0 7
15586: PPUSH
15587: CALL_OW 488
15591: NOT
15592: IFFALSE 15614
// begin _x := x ;
15594: LD_ADDR_VAR 0 6
15598: PUSH
15599: LD_VAR 0 4
15603: ST_TO_ADDR
// _y := y ;
15604: LD_ADDR_VAR 0 7
15608: PUSH
15609: LD_VAR 0 5
15613: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15614: LD_ADDR_VAR 0 3
15618: PUSH
15619: LD_INT 1
15621: PPUSH
15622: LD_VAR 0 14
15626: PPUSH
15627: CALL_OW 12
15631: ST_TO_ADDR
// case i of 1 :
15632: LD_VAR 0 3
15636: PUSH
15637: LD_INT 1
15639: DOUBLE
15640: EQUAL
15641: IFTRUE 15645
15643: GO 15662
15645: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15646: LD_VAR 0 1
15650: PPUSH
15651: LD_VAR 0 10
15655: PPUSH
15656: CALL_OW 115
15660: GO 15723
15662: LD_INT 2
15664: DOUBLE
15665: EQUAL
15666: IFTRUE 15670
15668: GO 15692
15670: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15671: LD_VAR 0 1
15675: PPUSH
15676: LD_VAR 0 6
15680: PPUSH
15681: LD_VAR 0 7
15685: PPUSH
15686: CALL_OW 153
15690: GO 15723
15692: LD_INT 3
15694: DOUBLE
15695: EQUAL
15696: IFTRUE 15700
15698: GO 15722
15700: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15701: LD_VAR 0 1
15705: PPUSH
15706: LD_VAR 0 6
15710: PPUSH
15711: LD_VAR 0 7
15715: PPUSH
15716: CALL_OW 154
15720: GO 15723
15722: POP
// end ;
15723: LD_VAR 0 2
15727: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15728: LD_INT 0
15730: PPUSH
15731: PPUSH
15732: PPUSH
15733: PPUSH
15734: PPUSH
15735: PPUSH
// if not unit or not building then
15736: LD_VAR 0 1
15740: NOT
15741: PUSH
15742: LD_VAR 0 2
15746: NOT
15747: OR
15748: IFFALSE 15752
// exit ;
15750: GO 15910
// x := GetX ( building ) ;
15752: LD_ADDR_VAR 0 5
15756: PUSH
15757: LD_VAR 0 2
15761: PPUSH
15762: CALL_OW 250
15766: ST_TO_ADDR
// y := GetY ( building ) ;
15767: LD_ADDR_VAR 0 6
15771: PUSH
15772: LD_VAR 0 2
15776: PPUSH
15777: CALL_OW 251
15781: ST_TO_ADDR
// for i = 0 to 5 do
15782: LD_ADDR_VAR 0 4
15786: PUSH
15787: DOUBLE
15788: LD_INT 0
15790: DEC
15791: ST_TO_ADDR
15792: LD_INT 5
15794: PUSH
15795: FOR_TO
15796: IFFALSE 15908
// begin _x := ShiftX ( x , i , 3 ) ;
15798: LD_ADDR_VAR 0 7
15802: PUSH
15803: LD_VAR 0 5
15807: PPUSH
15808: LD_VAR 0 4
15812: PPUSH
15813: LD_INT 3
15815: PPUSH
15816: CALL_OW 272
15820: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15821: LD_ADDR_VAR 0 8
15825: PUSH
15826: LD_VAR 0 6
15830: PPUSH
15831: LD_VAR 0 4
15835: PPUSH
15836: LD_INT 3
15838: PPUSH
15839: CALL_OW 273
15843: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15844: LD_VAR 0 7
15848: PPUSH
15849: LD_VAR 0 8
15853: PPUSH
15854: CALL_OW 488
15858: NOT
15859: IFFALSE 15863
// continue ;
15861: GO 15795
// if HexInfo ( _x , _y ) = 0 then
15863: LD_VAR 0 7
15867: PPUSH
15868: LD_VAR 0 8
15872: PPUSH
15873: CALL_OW 428
15877: PUSH
15878: LD_INT 0
15880: EQUAL
15881: IFFALSE 15906
// begin ComMoveXY ( unit , _x , _y ) ;
15883: LD_VAR 0 1
15887: PPUSH
15888: LD_VAR 0 7
15892: PPUSH
15893: LD_VAR 0 8
15897: PPUSH
15898: CALL_OW 111
// exit ;
15902: POP
15903: POP
15904: GO 15910
// end ; end ;
15906: GO 15795
15908: POP
15909: POP
// end ;
15910: LD_VAR 0 3
15914: RET
// export function ScanBase ( side , base_area ) ; begin
15915: LD_INT 0
15917: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15918: LD_ADDR_VAR 0 3
15922: PUSH
15923: LD_VAR 0 2
15927: PPUSH
15928: LD_INT 81
15930: PUSH
15931: LD_VAR 0 1
15935: PUSH
15936: EMPTY
15937: LIST
15938: LIST
15939: PPUSH
15940: CALL_OW 70
15944: ST_TO_ADDR
// end ;
15945: LD_VAR 0 3
15949: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15950: LD_INT 0
15952: PPUSH
15953: PPUSH
15954: PPUSH
15955: PPUSH
15956: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15957: LD_VAR 0 1
15961: NOT
15962: PUSH
15963: LD_EXP 59
15967: PUSH
15968: LD_VAR 0 1
15972: ARRAY
15973: NOT
15974: OR
15975: PUSH
15976: LD_VAR 0 2
15980: NOT
15981: OR
15982: PUSH
15983: LD_VAR 0 3
15987: NOT
15988: OR
15989: IFFALSE 15993
// exit ;
15991: GO 16506
// side := mc_sides [ base ] ;
15993: LD_ADDR_VAR 0 6
15997: PUSH
15998: LD_EXP 85
16002: PUSH
16003: LD_VAR 0 1
16007: ARRAY
16008: ST_TO_ADDR
// if not side then
16009: LD_VAR 0 6
16013: NOT
16014: IFFALSE 16018
// exit ;
16016: GO 16506
// for i in solds do
16018: LD_ADDR_VAR 0 7
16022: PUSH
16023: LD_VAR 0 2
16027: PUSH
16028: FOR_IN
16029: IFFALSE 16090
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
16031: LD_VAR 0 7
16035: PPUSH
16036: CALL_OW 310
16040: PPUSH
16041: CALL_OW 266
16045: PUSH
16046: LD_INT 32
16048: PUSH
16049: LD_INT 31
16051: PUSH
16052: EMPTY
16053: LIST
16054: LIST
16055: IN
16056: IFFALSE 16076
// solds := solds diff i else
16058: LD_ADDR_VAR 0 2
16062: PUSH
16063: LD_VAR 0 2
16067: PUSH
16068: LD_VAR 0 7
16072: DIFF
16073: ST_TO_ADDR
16074: GO 16088
// SetTag ( i , 18 ) ;
16076: LD_VAR 0 7
16080: PPUSH
16081: LD_INT 18
16083: PPUSH
16084: CALL_OW 109
16088: GO 16028
16090: POP
16091: POP
// if not solds then
16092: LD_VAR 0 2
16096: NOT
16097: IFFALSE 16101
// exit ;
16099: GO 16506
// repeat wait ( 0 0$1 ) ;
16101: LD_INT 35
16103: PPUSH
16104: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
16108: LD_ADDR_VAR 0 5
16112: PUSH
16113: LD_VAR 0 6
16117: PPUSH
16118: LD_VAR 0 3
16122: PPUSH
16123: CALL 15915 0 2
16127: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16128: LD_EXP 59
16132: PUSH
16133: LD_VAR 0 1
16137: ARRAY
16138: NOT
16139: PUSH
16140: LD_EXP 59
16144: PUSH
16145: LD_VAR 0 1
16149: ARRAY
16150: PUSH
16151: EMPTY
16152: EQUAL
16153: OR
16154: IFFALSE 16191
// begin for i in solds do
16156: LD_ADDR_VAR 0 7
16160: PUSH
16161: LD_VAR 0 2
16165: PUSH
16166: FOR_IN
16167: IFFALSE 16180
// ComStop ( i ) ;
16169: LD_VAR 0 7
16173: PPUSH
16174: CALL_OW 141
16178: GO 16166
16180: POP
16181: POP
// solds := [ ] ;
16182: LD_ADDR_VAR 0 2
16186: PUSH
16187: EMPTY
16188: ST_TO_ADDR
// exit ;
16189: GO 16506
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
16191: LD_VAR 0 5
16195: NOT
16196: PUSH
16197: LD_VAR 0 5
16201: PUSH
16202: LD_INT 3
16204: GREATER
16205: OR
16206: PUSH
16207: LD_EXP 81
16211: PUSH
16212: LD_VAR 0 1
16216: ARRAY
16217: OR
16218: IFFALSE 16259
// begin for i in solds do
16220: LD_ADDR_VAR 0 7
16224: PUSH
16225: LD_VAR 0 2
16229: PUSH
16230: FOR_IN
16231: IFFALSE 16255
// if HasTask ( i ) then
16233: LD_VAR 0 7
16237: PPUSH
16238: CALL_OW 314
16242: IFFALSE 16253
// ComStop ( i ) ;
16244: LD_VAR 0 7
16248: PPUSH
16249: CALL_OW 141
16253: GO 16230
16255: POP
16256: POP
// break ;
16257: GO 16494
// end ; for i in solds do
16259: LD_ADDR_VAR 0 7
16263: PUSH
16264: LD_VAR 0 2
16268: PUSH
16269: FOR_IN
16270: IFFALSE 16486
// begin if IsInUnit ( i ) then
16272: LD_VAR 0 7
16276: PPUSH
16277: CALL_OW 310
16281: IFFALSE 16292
// ComExitBuilding ( i ) ;
16283: LD_VAR 0 7
16287: PPUSH
16288: CALL_OW 122
// if GetLives ( i ) > 333 then
16292: LD_VAR 0 7
16296: PPUSH
16297: CALL_OW 256
16301: PUSH
16302: LD_INT 333
16304: GREATER
16305: IFFALSE 16333
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16307: LD_VAR 0 7
16311: PPUSH
16312: LD_VAR 0 5
16316: PPUSH
16317: LD_VAR 0 7
16321: PPUSH
16322: CALL_OW 74
16326: PPUSH
16327: CALL_OW 115
16331: GO 16484
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
16333: LD_ADDR_VAR 0 8
16337: PUSH
16338: LD_EXP 59
16342: PUSH
16343: LD_VAR 0 1
16347: ARRAY
16348: PPUSH
16349: LD_INT 2
16351: PUSH
16352: LD_INT 30
16354: PUSH
16355: LD_INT 0
16357: PUSH
16358: EMPTY
16359: LIST
16360: LIST
16361: PUSH
16362: LD_INT 30
16364: PUSH
16365: LD_INT 1
16367: PUSH
16368: EMPTY
16369: LIST
16370: LIST
16371: PUSH
16372: LD_INT 30
16374: PUSH
16375: LD_INT 6
16377: PUSH
16378: EMPTY
16379: LIST
16380: LIST
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: LIST
16386: LIST
16387: PPUSH
16388: CALL_OW 72
16392: PPUSH
16393: LD_VAR 0 7
16397: PPUSH
16398: CALL_OW 74
16402: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16403: LD_VAR 0 7
16407: PPUSH
16408: LD_VAR 0 8
16412: PPUSH
16413: CALL_OW 250
16417: PPUSH
16418: LD_INT 3
16420: PPUSH
16421: LD_INT 5
16423: PPUSH
16424: CALL_OW 272
16428: PPUSH
16429: LD_VAR 0 8
16433: PPUSH
16434: CALL_OW 251
16438: PPUSH
16439: LD_INT 3
16441: PPUSH
16442: LD_INT 5
16444: PPUSH
16445: CALL_OW 273
16449: PPUSH
16450: CALL_OW 111
// SetTag ( i , 0 ) ;
16454: LD_VAR 0 7
16458: PPUSH
16459: LD_INT 0
16461: PPUSH
16462: CALL_OW 109
// solds := solds diff i ;
16466: LD_ADDR_VAR 0 2
16470: PUSH
16471: LD_VAR 0 2
16475: PUSH
16476: LD_VAR 0 7
16480: DIFF
16481: ST_TO_ADDR
// continue ;
16482: GO 16269
// end ; end ;
16484: GO 16269
16486: POP
16487: POP
// until solds ;
16488: LD_VAR 0 2
16492: IFFALSE 16101
// MC_Reset ( base , 18 ) ;
16494: LD_VAR 0 1
16498: PPUSH
16499: LD_INT 18
16501: PPUSH
16502: CALL 61528 0 2
// end ;
16506: LD_VAR 0 4
16510: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16511: LD_INT 0
16513: PPUSH
16514: PPUSH
16515: PPUSH
16516: PPUSH
16517: PPUSH
16518: PPUSH
16519: PPUSH
16520: PPUSH
16521: PPUSH
16522: PPUSH
16523: PPUSH
16524: PPUSH
16525: PPUSH
16526: PPUSH
16527: PPUSH
16528: PPUSH
16529: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16530: LD_ADDR_VAR 0 13
16534: PUSH
16535: LD_EXP 59
16539: PUSH
16540: LD_VAR 0 1
16544: ARRAY
16545: PPUSH
16546: LD_INT 25
16548: PUSH
16549: LD_INT 3
16551: PUSH
16552: EMPTY
16553: LIST
16554: LIST
16555: PPUSH
16556: CALL_OW 72
16560: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16561: LD_EXP 99
16565: PUSH
16566: LD_VAR 0 1
16570: ARRAY
16571: IFFALSE 16595
// mechs := mechs diff mc_remote_driver [ base ] ;
16573: LD_ADDR_VAR 0 13
16577: PUSH
16578: LD_VAR 0 13
16582: PUSH
16583: LD_EXP 99
16587: PUSH
16588: LD_VAR 0 1
16592: ARRAY
16593: DIFF
16594: ST_TO_ADDR
// for i in mechs do
16595: LD_ADDR_VAR 0 5
16599: PUSH
16600: LD_VAR 0 13
16604: PUSH
16605: FOR_IN
16606: IFFALSE 16641
// if GetTag ( i ) > 0 then
16608: LD_VAR 0 5
16612: PPUSH
16613: CALL_OW 110
16617: PUSH
16618: LD_INT 0
16620: GREATER
16621: IFFALSE 16639
// mechs := mechs diff i ;
16623: LD_ADDR_VAR 0 13
16627: PUSH
16628: LD_VAR 0 13
16632: PUSH
16633: LD_VAR 0 5
16637: DIFF
16638: ST_TO_ADDR
16639: GO 16605
16641: POP
16642: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16643: LD_ADDR_VAR 0 9
16647: PUSH
16648: LD_EXP 59
16652: PUSH
16653: LD_VAR 0 1
16657: ARRAY
16658: PPUSH
16659: LD_INT 2
16661: PUSH
16662: LD_INT 25
16664: PUSH
16665: LD_INT 1
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: PUSH
16672: LD_INT 25
16674: PUSH
16675: LD_INT 5
16677: PUSH
16678: EMPTY
16679: LIST
16680: LIST
16681: PUSH
16682: LD_INT 25
16684: PUSH
16685: LD_INT 8
16687: PUSH
16688: EMPTY
16689: LIST
16690: LIST
16691: PUSH
16692: LD_INT 25
16694: PUSH
16695: LD_INT 9
16697: PUSH
16698: EMPTY
16699: LIST
16700: LIST
16701: PUSH
16702: EMPTY
16703: LIST
16704: LIST
16705: LIST
16706: LIST
16707: LIST
16708: PPUSH
16709: CALL_OW 72
16713: ST_TO_ADDR
// if not defenders and not solds then
16714: LD_VAR 0 2
16718: NOT
16719: PUSH
16720: LD_VAR 0 9
16724: NOT
16725: AND
16726: IFFALSE 16730
// exit ;
16728: GO 18356
// depot_under_attack := false ;
16730: LD_ADDR_VAR 0 17
16734: PUSH
16735: LD_INT 0
16737: ST_TO_ADDR
// sold_defenders := [ ] ;
16738: LD_ADDR_VAR 0 18
16742: PUSH
16743: EMPTY
16744: ST_TO_ADDR
// if mechs then
16745: LD_VAR 0 13
16749: IFFALSE 16878
// for i in defenders do
16751: LD_ADDR_VAR 0 5
16755: PUSH
16756: LD_VAR 0 2
16760: PUSH
16761: FOR_IN
16762: IFFALSE 16876
// begin SetTag ( i , 20 ) ;
16764: LD_VAR 0 5
16768: PPUSH
16769: LD_INT 20
16771: PPUSH
16772: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16776: LD_VAR 0 5
16780: PPUSH
16781: CALL_OW 263
16785: PUSH
16786: LD_INT 1
16788: EQUAL
16789: PUSH
16790: LD_VAR 0 5
16794: PPUSH
16795: CALL_OW 311
16799: NOT
16800: AND
16801: PUSH
16802: LD_VAR 0 13
16806: AND
16807: IFFALSE 16874
// begin un := mechs [ 1 ] ;
16809: LD_ADDR_VAR 0 11
16813: PUSH
16814: LD_VAR 0 13
16818: PUSH
16819: LD_INT 1
16821: ARRAY
16822: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16823: LD_VAR 0 11
16827: PPUSH
16828: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16832: LD_VAR 0 11
16836: PPUSH
16837: LD_VAR 0 5
16841: PPUSH
16842: CALL_OW 180
// SetTag ( un , 19 ) ;
16846: LD_VAR 0 11
16850: PPUSH
16851: LD_INT 19
16853: PPUSH
16854: CALL_OW 109
// mechs := mechs diff un ;
16858: LD_ADDR_VAR 0 13
16862: PUSH
16863: LD_VAR 0 13
16867: PUSH
16868: LD_VAR 0 11
16872: DIFF
16873: ST_TO_ADDR
// end ; end ;
16874: GO 16761
16876: POP
16877: POP
// if solds then
16878: LD_VAR 0 9
16882: IFFALSE 16941
// for i in solds do
16884: LD_ADDR_VAR 0 5
16888: PUSH
16889: LD_VAR 0 9
16893: PUSH
16894: FOR_IN
16895: IFFALSE 16939
// if not GetTag ( i ) then
16897: LD_VAR 0 5
16901: PPUSH
16902: CALL_OW 110
16906: NOT
16907: IFFALSE 16937
// begin defenders := defenders union i ;
16909: LD_ADDR_VAR 0 2
16913: PUSH
16914: LD_VAR 0 2
16918: PUSH
16919: LD_VAR 0 5
16923: UNION
16924: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16925: LD_VAR 0 5
16929: PPUSH
16930: LD_INT 18
16932: PPUSH
16933: CALL_OW 109
// end ;
16937: GO 16894
16939: POP
16940: POP
// repeat wait ( 0 0$1 ) ;
16941: LD_INT 35
16943: PPUSH
16944: CALL_OW 67
// enemy := mc_scan [ base ] ;
16948: LD_ADDR_VAR 0 3
16952: PUSH
16953: LD_EXP 82
16957: PUSH
16958: LD_VAR 0 1
16962: ARRAY
16963: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16964: LD_EXP 59
16968: PUSH
16969: LD_VAR 0 1
16973: ARRAY
16974: NOT
16975: PUSH
16976: LD_EXP 59
16980: PUSH
16981: LD_VAR 0 1
16985: ARRAY
16986: PUSH
16987: EMPTY
16988: EQUAL
16989: OR
16990: IFFALSE 17027
// begin for i in defenders do
16992: LD_ADDR_VAR 0 5
16996: PUSH
16997: LD_VAR 0 2
17001: PUSH
17002: FOR_IN
17003: IFFALSE 17016
// ComStop ( i ) ;
17005: LD_VAR 0 5
17009: PPUSH
17010: CALL_OW 141
17014: GO 17002
17016: POP
17017: POP
// defenders := [ ] ;
17018: LD_ADDR_VAR 0 2
17022: PUSH
17023: EMPTY
17024: ST_TO_ADDR
// exit ;
17025: GO 18356
// end ; for i in defenders do
17027: LD_ADDR_VAR 0 5
17031: PUSH
17032: LD_VAR 0 2
17036: PUSH
17037: FOR_IN
17038: IFFALSE 17856
// begin e := NearestUnitToUnit ( enemy , i ) ;
17040: LD_ADDR_VAR 0 14
17044: PUSH
17045: LD_VAR 0 3
17049: PPUSH
17050: LD_VAR 0 5
17054: PPUSH
17055: CALL_OW 74
17059: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
17060: LD_ADDR_VAR 0 8
17064: PUSH
17065: LD_EXP 59
17069: PUSH
17070: LD_VAR 0 1
17074: ARRAY
17075: PPUSH
17076: LD_INT 2
17078: PUSH
17079: LD_INT 30
17081: PUSH
17082: LD_INT 0
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: PUSH
17089: LD_INT 30
17091: PUSH
17092: LD_INT 1
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: PUSH
17099: EMPTY
17100: LIST
17101: LIST
17102: LIST
17103: PPUSH
17104: CALL_OW 72
17108: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
17109: LD_ADDR_VAR 0 17
17113: PUSH
17114: LD_VAR 0 8
17118: NOT
17119: PUSH
17120: LD_VAR 0 8
17124: PPUSH
17125: LD_INT 3
17127: PUSH
17128: LD_INT 24
17130: PUSH
17131: LD_INT 600
17133: PUSH
17134: EMPTY
17135: LIST
17136: LIST
17137: PUSH
17138: EMPTY
17139: LIST
17140: LIST
17141: PPUSH
17142: CALL_OW 72
17146: OR
17147: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
17148: LD_VAR 0 5
17152: PPUSH
17153: CALL_OW 247
17157: PUSH
17158: LD_INT 2
17160: DOUBLE
17161: EQUAL
17162: IFTRUE 17166
17164: GO 17562
17166: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
17167: LD_VAR 0 5
17171: PPUSH
17172: CALL_OW 256
17176: PUSH
17177: LD_INT 650
17179: GREATER
17180: PUSH
17181: LD_VAR 0 5
17185: PPUSH
17186: LD_VAR 0 14
17190: PPUSH
17191: CALL_OW 296
17195: PUSH
17196: LD_INT 40
17198: LESS
17199: PUSH
17200: LD_VAR 0 14
17204: PPUSH
17205: LD_EXP 84
17209: PUSH
17210: LD_VAR 0 1
17214: ARRAY
17215: PPUSH
17216: CALL_OW 308
17220: OR
17221: AND
17222: IFFALSE 17344
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
17224: LD_VAR 0 5
17228: PPUSH
17229: CALL_OW 262
17233: PUSH
17234: LD_INT 1
17236: EQUAL
17237: PUSH
17238: LD_VAR 0 5
17242: PPUSH
17243: CALL_OW 261
17247: PUSH
17248: LD_INT 30
17250: LESS
17251: AND
17252: PUSH
17253: LD_VAR 0 8
17257: AND
17258: IFFALSE 17328
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
17260: LD_VAR 0 5
17264: PPUSH
17265: LD_VAR 0 8
17269: PPUSH
17270: LD_VAR 0 5
17274: PPUSH
17275: CALL_OW 74
17279: PPUSH
17280: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
17284: LD_VAR 0 5
17288: PPUSH
17289: LD_VAR 0 8
17293: PPUSH
17294: LD_VAR 0 5
17298: PPUSH
17299: CALL_OW 74
17303: PPUSH
17304: CALL_OW 296
17308: PUSH
17309: LD_INT 6
17311: LESS
17312: IFFALSE 17326
// SetFuel ( i , 100 ) ;
17314: LD_VAR 0 5
17318: PPUSH
17319: LD_INT 100
17321: PPUSH
17322: CALL_OW 240
// end else
17326: GO 17342
// ComAttackUnit ( i , e ) ;
17328: LD_VAR 0 5
17332: PPUSH
17333: LD_VAR 0 14
17337: PPUSH
17338: CALL_OW 115
// end else
17342: GO 17445
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
17344: LD_VAR 0 14
17348: PPUSH
17349: LD_EXP 84
17353: PUSH
17354: LD_VAR 0 1
17358: ARRAY
17359: PPUSH
17360: CALL_OW 308
17364: NOT
17365: PUSH
17366: LD_VAR 0 5
17370: PPUSH
17371: LD_VAR 0 14
17375: PPUSH
17376: CALL_OW 296
17380: PUSH
17381: LD_INT 40
17383: GREATEREQUAL
17384: AND
17385: PUSH
17386: LD_VAR 0 5
17390: PPUSH
17391: CALL_OW 256
17395: PUSH
17396: LD_INT 650
17398: LESSEQUAL
17399: OR
17400: PUSH
17401: LD_VAR 0 5
17405: PPUSH
17406: LD_EXP 83
17410: PUSH
17411: LD_VAR 0 1
17415: ARRAY
17416: PPUSH
17417: CALL_OW 308
17421: NOT
17422: AND
17423: IFFALSE 17445
// ComMoveToArea ( i , mc_parking [ base ] ) ;
17425: LD_VAR 0 5
17429: PPUSH
17430: LD_EXP 83
17434: PUSH
17435: LD_VAR 0 1
17439: ARRAY
17440: PPUSH
17441: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
17445: LD_VAR 0 5
17449: PPUSH
17450: CALL_OW 256
17454: PUSH
17455: LD_INT 998
17457: LESS
17458: PUSH
17459: LD_VAR 0 5
17463: PPUSH
17464: CALL_OW 263
17468: PUSH
17469: LD_INT 1
17471: EQUAL
17472: AND
17473: PUSH
17474: LD_VAR 0 5
17478: PPUSH
17479: CALL_OW 311
17483: AND
17484: PUSH
17485: LD_VAR 0 5
17489: PPUSH
17490: LD_EXP 83
17494: PUSH
17495: LD_VAR 0 1
17499: ARRAY
17500: PPUSH
17501: CALL_OW 308
17505: AND
17506: IFFALSE 17560
// begin mech := IsDrivenBy ( i ) ;
17508: LD_ADDR_VAR 0 10
17512: PUSH
17513: LD_VAR 0 5
17517: PPUSH
17518: CALL_OW 311
17522: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
17523: LD_VAR 0 10
17527: PPUSH
17528: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
17532: LD_VAR 0 10
17536: PPUSH
17537: LD_VAR 0 5
17541: PPUSH
17542: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
17546: LD_VAR 0 10
17550: PPUSH
17551: LD_VAR 0 5
17555: PPUSH
17556: CALL_OW 180
// end ; end ; unit_human :
17560: GO 17827
17562: LD_INT 1
17564: DOUBLE
17565: EQUAL
17566: IFTRUE 17570
17568: GO 17826
17570: POP
// begin b := IsInUnit ( i ) ;
17571: LD_ADDR_VAR 0 19
17575: PUSH
17576: LD_VAR 0 5
17580: PPUSH
17581: CALL_OW 310
17585: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17586: LD_ADDR_VAR 0 20
17590: PUSH
17591: LD_VAR 0 19
17595: NOT
17596: PUSH
17597: LD_VAR 0 19
17601: PPUSH
17602: CALL_OW 266
17606: PUSH
17607: LD_INT 32
17609: PUSH
17610: LD_INT 31
17612: PUSH
17613: EMPTY
17614: LIST
17615: LIST
17616: IN
17617: OR
17618: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17619: LD_VAR 0 17
17623: PUSH
17624: LD_VAR 0 2
17628: PPUSH
17629: LD_INT 21
17631: PUSH
17632: LD_INT 2
17634: PUSH
17635: EMPTY
17636: LIST
17637: LIST
17638: PPUSH
17639: CALL_OW 72
17643: PUSH
17644: LD_INT 1
17646: LESSEQUAL
17647: OR
17648: PUSH
17649: LD_VAR 0 20
17653: AND
17654: PUSH
17655: LD_VAR 0 5
17659: PUSH
17660: LD_VAR 0 18
17664: IN
17665: NOT
17666: AND
17667: IFFALSE 17760
// begin if b then
17669: LD_VAR 0 19
17673: IFFALSE 17722
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17675: LD_VAR 0 19
17679: PPUSH
17680: LD_VAR 0 3
17684: PPUSH
17685: LD_VAR 0 19
17689: PPUSH
17690: CALL_OW 74
17694: PPUSH
17695: CALL_OW 296
17699: PUSH
17700: LD_INT 10
17702: LESS
17703: PUSH
17704: LD_VAR 0 19
17708: PPUSH
17709: CALL_OW 461
17713: PUSH
17714: LD_INT 7
17716: NONEQUAL
17717: AND
17718: IFFALSE 17722
// continue ;
17720: GO 17037
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17722: LD_ADDR_VAR 0 18
17726: PUSH
17727: LD_VAR 0 18
17731: PPUSH
17732: LD_VAR 0 18
17736: PUSH
17737: LD_INT 1
17739: PLUS
17740: PPUSH
17741: LD_VAR 0 5
17745: PPUSH
17746: CALL_OW 1
17750: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17751: LD_VAR 0 5
17755: PPUSH
17756: CALL_OW 122
// end ; if sold_defenders then
17760: LD_VAR 0 18
17764: IFFALSE 17824
// if i in sold_defenders then
17766: LD_VAR 0 5
17770: PUSH
17771: LD_VAR 0 18
17775: IN
17776: IFFALSE 17824
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17778: LD_VAR 0 5
17782: PPUSH
17783: CALL_OW 314
17787: NOT
17788: PUSH
17789: LD_VAR 0 5
17793: PPUSH
17794: LD_VAR 0 14
17798: PPUSH
17799: CALL_OW 296
17803: PUSH
17804: LD_INT 30
17806: LESS
17807: AND
17808: IFFALSE 17824
// ComAttackUnit ( i , e ) ;
17810: LD_VAR 0 5
17814: PPUSH
17815: LD_VAR 0 14
17819: PPUSH
17820: CALL_OW 115
// end ; end ; end ;
17824: GO 17827
17826: POP
// if IsDead ( i ) then
17827: LD_VAR 0 5
17831: PPUSH
17832: CALL_OW 301
17836: IFFALSE 17854
// defenders := defenders diff i ;
17838: LD_ADDR_VAR 0 2
17842: PUSH
17843: LD_VAR 0 2
17847: PUSH
17848: LD_VAR 0 5
17852: DIFF
17853: ST_TO_ADDR
// end ;
17854: GO 17037
17856: POP
17857: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
17858: LD_VAR 0 3
17862: NOT
17863: PUSH
17864: LD_VAR 0 2
17868: NOT
17869: OR
17870: PUSH
17871: LD_EXP 59
17875: PUSH
17876: LD_VAR 0 1
17880: ARRAY
17881: NOT
17882: OR
17883: IFFALSE 16941
// MC_Reset ( base , 18 ) ;
17885: LD_VAR 0 1
17889: PPUSH
17890: LD_INT 18
17892: PPUSH
17893: CALL 61528 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17897: LD_ADDR_VAR 0 2
17901: PUSH
17902: LD_VAR 0 2
17906: PUSH
17907: LD_VAR 0 2
17911: PPUSH
17912: LD_INT 2
17914: PUSH
17915: LD_INT 25
17917: PUSH
17918: LD_INT 1
17920: PUSH
17921: EMPTY
17922: LIST
17923: LIST
17924: PUSH
17925: LD_INT 25
17927: PUSH
17928: LD_INT 5
17930: PUSH
17931: EMPTY
17932: LIST
17933: LIST
17934: PUSH
17935: LD_INT 25
17937: PUSH
17938: LD_INT 8
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: PUSH
17945: LD_INT 25
17947: PUSH
17948: LD_INT 9
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: PUSH
17955: EMPTY
17956: LIST
17957: LIST
17958: LIST
17959: LIST
17960: LIST
17961: PPUSH
17962: CALL_OW 72
17966: DIFF
17967: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17968: LD_VAR 0 3
17972: NOT
17973: PUSH
17974: LD_VAR 0 2
17978: PPUSH
17979: LD_INT 21
17981: PUSH
17982: LD_INT 2
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: PPUSH
17989: CALL_OW 72
17993: AND
17994: IFFALSE 18332
// begin tmp := FilterByTag ( defenders , 19 ) ;
17996: LD_ADDR_VAR 0 12
18000: PUSH
18001: LD_VAR 0 2
18005: PPUSH
18006: LD_INT 19
18008: PPUSH
18009: CALL 54785 0 2
18013: ST_TO_ADDR
// if tmp then
18014: LD_VAR 0 12
18018: IFFALSE 18088
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
18020: LD_ADDR_VAR 0 12
18024: PUSH
18025: LD_VAR 0 12
18029: PPUSH
18030: LD_INT 25
18032: PUSH
18033: LD_INT 3
18035: PUSH
18036: EMPTY
18037: LIST
18038: LIST
18039: PPUSH
18040: CALL_OW 72
18044: ST_TO_ADDR
// if tmp then
18045: LD_VAR 0 12
18049: IFFALSE 18088
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
18051: LD_ADDR_EXP 71
18055: PUSH
18056: LD_EXP 71
18060: PPUSH
18061: LD_VAR 0 1
18065: PPUSH
18066: LD_EXP 71
18070: PUSH
18071: LD_VAR 0 1
18075: ARRAY
18076: PUSH
18077: LD_VAR 0 12
18081: UNION
18082: PPUSH
18083: CALL_OW 1
18087: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
18088: LD_VAR 0 1
18092: PPUSH
18093: LD_INT 19
18095: PPUSH
18096: CALL 61528 0 2
// repeat wait ( 0 0$1 ) ;
18100: LD_INT 35
18102: PPUSH
18103: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
18107: LD_EXP 59
18111: PUSH
18112: LD_VAR 0 1
18116: ARRAY
18117: NOT
18118: PUSH
18119: LD_EXP 59
18123: PUSH
18124: LD_VAR 0 1
18128: ARRAY
18129: PUSH
18130: EMPTY
18131: EQUAL
18132: OR
18133: IFFALSE 18170
// begin for i in defenders do
18135: LD_ADDR_VAR 0 5
18139: PUSH
18140: LD_VAR 0 2
18144: PUSH
18145: FOR_IN
18146: IFFALSE 18159
// ComStop ( i ) ;
18148: LD_VAR 0 5
18152: PPUSH
18153: CALL_OW 141
18157: GO 18145
18159: POP
18160: POP
// defenders := [ ] ;
18161: LD_ADDR_VAR 0 2
18165: PUSH
18166: EMPTY
18167: ST_TO_ADDR
// exit ;
18168: GO 18356
// end ; for i in defenders do
18170: LD_ADDR_VAR 0 5
18174: PUSH
18175: LD_VAR 0 2
18179: PUSH
18180: FOR_IN
18181: IFFALSE 18270
// begin if not IsInArea ( i , mc_parking [ base ] ) then
18183: LD_VAR 0 5
18187: PPUSH
18188: LD_EXP 83
18192: PUSH
18193: LD_VAR 0 1
18197: ARRAY
18198: PPUSH
18199: CALL_OW 308
18203: NOT
18204: IFFALSE 18228
// ComMoveToArea ( i , mc_parking [ base ] ) else
18206: LD_VAR 0 5
18210: PPUSH
18211: LD_EXP 83
18215: PUSH
18216: LD_VAR 0 1
18220: ARRAY
18221: PPUSH
18222: CALL_OW 113
18226: GO 18268
// if GetControl ( i ) = control_manual then
18228: LD_VAR 0 5
18232: PPUSH
18233: CALL_OW 263
18237: PUSH
18238: LD_INT 1
18240: EQUAL
18241: IFFALSE 18268
// if IsDrivenBy ( i ) then
18243: LD_VAR 0 5
18247: PPUSH
18248: CALL_OW 311
18252: IFFALSE 18268
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
18254: LD_VAR 0 5
18258: PPUSH
18259: CALL_OW 311
18263: PPUSH
18264: CALL_OW 121
// end ;
18268: GO 18180
18270: POP
18271: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
18272: LD_VAR 0 2
18276: PPUSH
18277: LD_INT 95
18279: PUSH
18280: LD_EXP 83
18284: PUSH
18285: LD_VAR 0 1
18289: ARRAY
18290: PUSH
18291: EMPTY
18292: LIST
18293: LIST
18294: PPUSH
18295: CALL_OW 72
18299: PUSH
18300: LD_VAR 0 2
18304: EQUAL
18305: PUSH
18306: LD_EXP 82
18310: PUSH
18311: LD_VAR 0 1
18315: ARRAY
18316: OR
18317: PUSH
18318: LD_EXP 59
18322: PUSH
18323: LD_VAR 0 1
18327: ARRAY
18328: NOT
18329: OR
18330: IFFALSE 18100
// end ; MC_Reset ( base , 19 ) ;
18332: LD_VAR 0 1
18336: PPUSH
18337: LD_INT 19
18339: PPUSH
18340: CALL 61528 0 2
// MC_Reset ( base , 20 ) ;
18344: LD_VAR 0 1
18348: PPUSH
18349: LD_INT 20
18351: PPUSH
18352: CALL 61528 0 2
// end ;
18356: LD_VAR 0 4
18360: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18361: LD_INT 0
18363: PPUSH
18364: PPUSH
18365: PPUSH
18366: PPUSH
// result := false ;
18367: LD_ADDR_VAR 0 2
18371: PUSH
18372: LD_INT 0
18374: ST_TO_ADDR
// side := GetSide ( unit ) ;
18375: LD_ADDR_VAR 0 3
18379: PUSH
18380: LD_VAR 0 1
18384: PPUSH
18385: CALL_OW 255
18389: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18390: LD_ADDR_VAR 0 4
18394: PUSH
18395: LD_VAR 0 1
18399: PPUSH
18400: CALL_OW 248
18404: ST_TO_ADDR
// case nat of 1 :
18405: LD_VAR 0 4
18409: PUSH
18410: LD_INT 1
18412: DOUBLE
18413: EQUAL
18414: IFTRUE 18418
18416: GO 18429
18418: POP
// tech := tech_lassight ; 2 :
18419: LD_ADDR_VAR 0 5
18423: PUSH
18424: LD_INT 12
18426: ST_TO_ADDR
18427: GO 18468
18429: LD_INT 2
18431: DOUBLE
18432: EQUAL
18433: IFTRUE 18437
18435: GO 18448
18437: POP
// tech := tech_mortar ; 3 :
18438: LD_ADDR_VAR 0 5
18442: PUSH
18443: LD_INT 41
18445: ST_TO_ADDR
18446: GO 18468
18448: LD_INT 3
18450: DOUBLE
18451: EQUAL
18452: IFTRUE 18456
18454: GO 18467
18456: POP
// tech := tech_bazooka ; end ;
18457: LD_ADDR_VAR 0 5
18461: PUSH
18462: LD_INT 44
18464: ST_TO_ADDR
18465: GO 18468
18467: POP
// if Researched ( side , tech ) then
18468: LD_VAR 0 3
18472: PPUSH
18473: LD_VAR 0 5
18477: PPUSH
18478: CALL_OW 325
18482: IFFALSE 18509
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18484: LD_ADDR_VAR 0 2
18488: PUSH
18489: LD_INT 5
18491: PUSH
18492: LD_INT 8
18494: PUSH
18495: LD_INT 9
18497: PUSH
18498: EMPTY
18499: LIST
18500: LIST
18501: LIST
18502: PUSH
18503: LD_VAR 0 4
18507: ARRAY
18508: ST_TO_ADDR
// end ;
18509: LD_VAR 0 2
18513: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18514: LD_INT 0
18516: PPUSH
18517: PPUSH
18518: PPUSH
// if not mines then
18519: LD_VAR 0 2
18523: NOT
18524: IFFALSE 18528
// exit ;
18526: GO 18672
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18528: LD_ADDR_VAR 0 5
18532: PUSH
18533: LD_INT 81
18535: PUSH
18536: LD_VAR 0 1
18540: PUSH
18541: EMPTY
18542: LIST
18543: LIST
18544: PUSH
18545: LD_INT 3
18547: PUSH
18548: LD_INT 21
18550: PUSH
18551: LD_INT 3
18553: PUSH
18554: EMPTY
18555: LIST
18556: LIST
18557: PUSH
18558: EMPTY
18559: LIST
18560: LIST
18561: PUSH
18562: EMPTY
18563: LIST
18564: LIST
18565: PPUSH
18566: CALL_OW 69
18570: ST_TO_ADDR
// for i in mines do
18571: LD_ADDR_VAR 0 4
18575: PUSH
18576: LD_VAR 0 2
18580: PUSH
18581: FOR_IN
18582: IFFALSE 18670
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18584: LD_VAR 0 4
18588: PUSH
18589: LD_INT 1
18591: ARRAY
18592: PPUSH
18593: LD_VAR 0 4
18597: PUSH
18598: LD_INT 2
18600: ARRAY
18601: PPUSH
18602: CALL_OW 458
18606: NOT
18607: IFFALSE 18611
// continue ;
18609: GO 18581
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18611: LD_VAR 0 4
18615: PUSH
18616: LD_INT 1
18618: ARRAY
18619: PPUSH
18620: LD_VAR 0 4
18624: PUSH
18625: LD_INT 2
18627: ARRAY
18628: PPUSH
18629: CALL_OW 428
18633: PUSH
18634: LD_VAR 0 5
18638: IN
18639: IFFALSE 18668
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18641: LD_VAR 0 4
18645: PUSH
18646: LD_INT 1
18648: ARRAY
18649: PPUSH
18650: LD_VAR 0 4
18654: PUSH
18655: LD_INT 2
18657: ARRAY
18658: PPUSH
18659: LD_VAR 0 1
18663: PPUSH
18664: CALL_OW 456
// end ;
18668: GO 18581
18670: POP
18671: POP
// end ;
18672: LD_VAR 0 3
18676: RET
// export function Count ( array ) ; var i ; begin
18677: LD_INT 0
18679: PPUSH
18680: PPUSH
// result := 0 ;
18681: LD_ADDR_VAR 0 2
18685: PUSH
18686: LD_INT 0
18688: ST_TO_ADDR
// for i in array do
18689: LD_ADDR_VAR 0 3
18693: PUSH
18694: LD_VAR 0 1
18698: PUSH
18699: FOR_IN
18700: IFFALSE 18724
// if i then
18702: LD_VAR 0 3
18706: IFFALSE 18722
// result := result + 1 ;
18708: LD_ADDR_VAR 0 2
18712: PUSH
18713: LD_VAR 0 2
18717: PUSH
18718: LD_INT 1
18720: PLUS
18721: ST_TO_ADDR
18722: GO 18699
18724: POP
18725: POP
// end ;
18726: LD_VAR 0 2
18730: RET
// export function IsEmpty ( building ) ; begin
18731: LD_INT 0
18733: PPUSH
// if not building then
18734: LD_VAR 0 1
18738: NOT
18739: IFFALSE 18743
// exit ;
18741: GO 18786
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18743: LD_ADDR_VAR 0 2
18747: PUSH
18748: LD_VAR 0 1
18752: PUSH
18753: LD_INT 22
18755: PUSH
18756: LD_VAR 0 1
18760: PPUSH
18761: CALL_OW 255
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: PUSH
18770: LD_INT 58
18772: PUSH
18773: EMPTY
18774: LIST
18775: PUSH
18776: EMPTY
18777: LIST
18778: LIST
18779: PPUSH
18780: CALL_OW 69
18784: IN
18785: ST_TO_ADDR
// end ;
18786: LD_VAR 0 2
18790: RET
// export function IsNotFull ( building ) ; begin
18791: LD_INT 0
18793: PPUSH
// if not building then
18794: LD_VAR 0 1
18798: NOT
18799: IFFALSE 18803
// exit ;
18801: GO 18822
// result := UnitsInside ( building ) < 6 ;
18803: LD_ADDR_VAR 0 2
18807: PUSH
18808: LD_VAR 0 1
18812: PPUSH
18813: CALL_OW 313
18817: PUSH
18818: LD_INT 6
18820: LESS
18821: ST_TO_ADDR
// end ;
18822: LD_VAR 0 2
18826: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18827: LD_INT 0
18829: PPUSH
18830: PPUSH
18831: PPUSH
18832: PPUSH
// tmp := [ ] ;
18833: LD_ADDR_VAR 0 3
18837: PUSH
18838: EMPTY
18839: ST_TO_ADDR
// list := [ ] ;
18840: LD_ADDR_VAR 0 5
18844: PUSH
18845: EMPTY
18846: ST_TO_ADDR
// for i = 16 to 25 do
18847: LD_ADDR_VAR 0 4
18851: PUSH
18852: DOUBLE
18853: LD_INT 16
18855: DEC
18856: ST_TO_ADDR
18857: LD_INT 25
18859: PUSH
18860: FOR_TO
18861: IFFALSE 18934
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18863: LD_ADDR_VAR 0 3
18867: PUSH
18868: LD_VAR 0 3
18872: PUSH
18873: LD_INT 22
18875: PUSH
18876: LD_VAR 0 1
18880: PPUSH
18881: CALL_OW 255
18885: PUSH
18886: EMPTY
18887: LIST
18888: LIST
18889: PUSH
18890: LD_INT 91
18892: PUSH
18893: LD_VAR 0 1
18897: PUSH
18898: LD_INT 6
18900: PUSH
18901: EMPTY
18902: LIST
18903: LIST
18904: LIST
18905: PUSH
18906: LD_INT 30
18908: PUSH
18909: LD_VAR 0 4
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: PUSH
18918: EMPTY
18919: LIST
18920: LIST
18921: LIST
18922: PUSH
18923: EMPTY
18924: LIST
18925: PPUSH
18926: CALL_OW 69
18930: ADD
18931: ST_TO_ADDR
18932: GO 18860
18934: POP
18935: POP
// for i = 1 to tmp do
18936: LD_ADDR_VAR 0 4
18940: PUSH
18941: DOUBLE
18942: LD_INT 1
18944: DEC
18945: ST_TO_ADDR
18946: LD_VAR 0 3
18950: PUSH
18951: FOR_TO
18952: IFFALSE 19040
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18954: LD_ADDR_VAR 0 5
18958: PUSH
18959: LD_VAR 0 5
18963: PUSH
18964: LD_VAR 0 3
18968: PUSH
18969: LD_VAR 0 4
18973: ARRAY
18974: PPUSH
18975: CALL_OW 266
18979: PUSH
18980: LD_VAR 0 3
18984: PUSH
18985: LD_VAR 0 4
18989: ARRAY
18990: PPUSH
18991: CALL_OW 250
18995: PUSH
18996: LD_VAR 0 3
19000: PUSH
19001: LD_VAR 0 4
19005: ARRAY
19006: PPUSH
19007: CALL_OW 251
19011: PUSH
19012: LD_VAR 0 3
19016: PUSH
19017: LD_VAR 0 4
19021: ARRAY
19022: PPUSH
19023: CALL_OW 254
19027: PUSH
19028: EMPTY
19029: LIST
19030: LIST
19031: LIST
19032: LIST
19033: PUSH
19034: EMPTY
19035: LIST
19036: ADD
19037: ST_TO_ADDR
19038: GO 18951
19040: POP
19041: POP
// result := list ;
19042: LD_ADDR_VAR 0 2
19046: PUSH
19047: LD_VAR 0 5
19051: ST_TO_ADDR
// end ;
19052: LD_VAR 0 2
19056: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19057: LD_INT 0
19059: PPUSH
19060: PPUSH
19061: PPUSH
19062: PPUSH
19063: PPUSH
19064: PPUSH
19065: PPUSH
// if not factory then
19066: LD_VAR 0 1
19070: NOT
19071: IFFALSE 19075
// exit ;
19073: GO 19668
// if control = control_apeman then
19075: LD_VAR 0 4
19079: PUSH
19080: LD_INT 5
19082: EQUAL
19083: IFFALSE 19192
// begin tmp := UnitsInside ( factory ) ;
19085: LD_ADDR_VAR 0 8
19089: PUSH
19090: LD_VAR 0 1
19094: PPUSH
19095: CALL_OW 313
19099: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
19100: LD_VAR 0 8
19104: PPUSH
19105: LD_INT 25
19107: PUSH
19108: LD_INT 12
19110: PUSH
19111: EMPTY
19112: LIST
19113: LIST
19114: PPUSH
19115: CALL_OW 72
19119: NOT
19120: IFFALSE 19130
// control := control_manual ;
19122: LD_ADDR_VAR 0 4
19126: PUSH
19127: LD_INT 1
19129: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
19130: LD_ADDR_VAR 0 8
19134: PUSH
19135: LD_VAR 0 1
19139: PPUSH
19140: CALL 18827 0 1
19144: ST_TO_ADDR
// if tmp then
19145: LD_VAR 0 8
19149: IFFALSE 19192
// begin for i in tmp do
19151: LD_ADDR_VAR 0 7
19155: PUSH
19156: LD_VAR 0 8
19160: PUSH
19161: FOR_IN
19162: IFFALSE 19190
// if i [ 1 ] = b_ext_radio then
19164: LD_VAR 0 7
19168: PUSH
19169: LD_INT 1
19171: ARRAY
19172: PUSH
19173: LD_INT 22
19175: EQUAL
19176: IFFALSE 19188
// begin control := control_remote ;
19178: LD_ADDR_VAR 0 4
19182: PUSH
19183: LD_INT 2
19185: ST_TO_ADDR
// break ;
19186: GO 19190
// end ;
19188: GO 19161
19190: POP
19191: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19192: LD_VAR 0 1
19196: PPUSH
19197: LD_VAR 0 2
19201: PPUSH
19202: LD_VAR 0 3
19206: PPUSH
19207: LD_VAR 0 4
19211: PPUSH
19212: LD_VAR 0 5
19216: PPUSH
19217: CALL_OW 448
19221: IFFALSE 19256
// begin result := [ chassis , engine , control , weapon ] ;
19223: LD_ADDR_VAR 0 6
19227: PUSH
19228: LD_VAR 0 2
19232: PUSH
19233: LD_VAR 0 3
19237: PUSH
19238: LD_VAR 0 4
19242: PUSH
19243: LD_VAR 0 5
19247: PUSH
19248: EMPTY
19249: LIST
19250: LIST
19251: LIST
19252: LIST
19253: ST_TO_ADDR
// exit ;
19254: GO 19668
// end ; _chassis := AvailableChassisList ( factory ) ;
19256: LD_ADDR_VAR 0 9
19260: PUSH
19261: LD_VAR 0 1
19265: PPUSH
19266: CALL_OW 475
19270: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19271: LD_ADDR_VAR 0 11
19275: PUSH
19276: LD_VAR 0 1
19280: PPUSH
19281: CALL_OW 476
19285: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19286: LD_ADDR_VAR 0 12
19290: PUSH
19291: LD_VAR 0 1
19295: PPUSH
19296: CALL_OW 477
19300: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19301: LD_ADDR_VAR 0 10
19305: PUSH
19306: LD_VAR 0 1
19310: PPUSH
19311: CALL_OW 478
19315: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19316: LD_VAR 0 9
19320: NOT
19321: PUSH
19322: LD_VAR 0 11
19326: NOT
19327: OR
19328: PUSH
19329: LD_VAR 0 12
19333: NOT
19334: OR
19335: PUSH
19336: LD_VAR 0 10
19340: NOT
19341: OR
19342: IFFALSE 19377
// begin result := [ chassis , engine , control , weapon ] ;
19344: LD_ADDR_VAR 0 6
19348: PUSH
19349: LD_VAR 0 2
19353: PUSH
19354: LD_VAR 0 3
19358: PUSH
19359: LD_VAR 0 4
19363: PUSH
19364: LD_VAR 0 5
19368: PUSH
19369: EMPTY
19370: LIST
19371: LIST
19372: LIST
19373: LIST
19374: ST_TO_ADDR
// exit ;
19375: GO 19668
// end ; if not chassis in _chassis then
19377: LD_VAR 0 2
19381: PUSH
19382: LD_VAR 0 9
19386: IN
19387: NOT
19388: IFFALSE 19414
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19390: LD_ADDR_VAR 0 2
19394: PUSH
19395: LD_VAR 0 9
19399: PUSH
19400: LD_INT 1
19402: PPUSH
19403: LD_VAR 0 9
19407: PPUSH
19408: CALL_OW 12
19412: ARRAY
19413: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19414: LD_VAR 0 2
19418: PPUSH
19419: LD_VAR 0 3
19423: PPUSH
19424: CALL 19673 0 2
19428: NOT
19429: IFFALSE 19488
// repeat engine := _engine [ 1 ] ;
19431: LD_ADDR_VAR 0 3
19435: PUSH
19436: LD_VAR 0 11
19440: PUSH
19441: LD_INT 1
19443: ARRAY
19444: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19445: LD_ADDR_VAR 0 11
19449: PUSH
19450: LD_VAR 0 11
19454: PPUSH
19455: LD_INT 1
19457: PPUSH
19458: CALL_OW 3
19462: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19463: LD_VAR 0 2
19467: PPUSH
19468: LD_VAR 0 3
19472: PPUSH
19473: CALL 19673 0 2
19477: PUSH
19478: LD_VAR 0 11
19482: PUSH
19483: EMPTY
19484: EQUAL
19485: OR
19486: IFFALSE 19431
// if not control in _control then
19488: LD_VAR 0 4
19492: PUSH
19493: LD_VAR 0 12
19497: IN
19498: NOT
19499: IFFALSE 19525
// control := _control [ rand ( 1 , _control ) ] ;
19501: LD_ADDR_VAR 0 4
19505: PUSH
19506: LD_VAR 0 12
19510: PUSH
19511: LD_INT 1
19513: PPUSH
19514: LD_VAR 0 12
19518: PPUSH
19519: CALL_OW 12
19523: ARRAY
19524: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19525: LD_VAR 0 2
19529: PPUSH
19530: LD_VAR 0 5
19534: PPUSH
19535: CALL 19893 0 2
19539: NOT
19540: IFFALSE 19599
// repeat weapon := _weapon [ 1 ] ;
19542: LD_ADDR_VAR 0 5
19546: PUSH
19547: LD_VAR 0 10
19551: PUSH
19552: LD_INT 1
19554: ARRAY
19555: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19556: LD_ADDR_VAR 0 10
19560: PUSH
19561: LD_VAR 0 10
19565: PPUSH
19566: LD_INT 1
19568: PPUSH
19569: CALL_OW 3
19573: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19574: LD_VAR 0 2
19578: PPUSH
19579: LD_VAR 0 5
19583: PPUSH
19584: CALL 19893 0 2
19588: PUSH
19589: LD_VAR 0 10
19593: PUSH
19594: EMPTY
19595: EQUAL
19596: OR
19597: IFFALSE 19542
// result := [ ] ;
19599: LD_ADDR_VAR 0 6
19603: PUSH
19604: EMPTY
19605: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19606: LD_VAR 0 1
19610: PPUSH
19611: LD_VAR 0 2
19615: PPUSH
19616: LD_VAR 0 3
19620: PPUSH
19621: LD_VAR 0 4
19625: PPUSH
19626: LD_VAR 0 5
19630: PPUSH
19631: CALL_OW 448
19635: IFFALSE 19668
// result := [ chassis , engine , control , weapon ] ;
19637: LD_ADDR_VAR 0 6
19641: PUSH
19642: LD_VAR 0 2
19646: PUSH
19647: LD_VAR 0 3
19651: PUSH
19652: LD_VAR 0 4
19656: PUSH
19657: LD_VAR 0 5
19661: PUSH
19662: EMPTY
19663: LIST
19664: LIST
19665: LIST
19666: LIST
19667: ST_TO_ADDR
// end ;
19668: LD_VAR 0 6
19672: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19673: LD_INT 0
19675: PPUSH
// if not chassis or not engine then
19676: LD_VAR 0 1
19680: NOT
19681: PUSH
19682: LD_VAR 0 2
19686: NOT
19687: OR
19688: IFFALSE 19692
// exit ;
19690: GO 19888
// case engine of engine_solar :
19692: LD_VAR 0 2
19696: PUSH
19697: LD_INT 2
19699: DOUBLE
19700: EQUAL
19701: IFTRUE 19705
19703: GO 19743
19705: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19706: LD_ADDR_VAR 0 3
19710: PUSH
19711: LD_INT 11
19713: PUSH
19714: LD_INT 12
19716: PUSH
19717: LD_INT 13
19719: PUSH
19720: LD_INT 14
19722: PUSH
19723: LD_INT 1
19725: PUSH
19726: LD_INT 2
19728: PUSH
19729: LD_INT 3
19731: PUSH
19732: EMPTY
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: ST_TO_ADDR
19741: GO 19872
19743: LD_INT 1
19745: DOUBLE
19746: EQUAL
19747: IFTRUE 19751
19749: GO 19813
19751: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19752: LD_ADDR_VAR 0 3
19756: PUSH
19757: LD_INT 11
19759: PUSH
19760: LD_INT 12
19762: PUSH
19763: LD_INT 13
19765: PUSH
19766: LD_INT 14
19768: PUSH
19769: LD_INT 1
19771: PUSH
19772: LD_INT 2
19774: PUSH
19775: LD_INT 3
19777: PUSH
19778: LD_INT 4
19780: PUSH
19781: LD_INT 5
19783: PUSH
19784: LD_INT 21
19786: PUSH
19787: LD_INT 23
19789: PUSH
19790: LD_INT 22
19792: PUSH
19793: LD_INT 24
19795: PUSH
19796: EMPTY
19797: LIST
19798: LIST
19799: LIST
19800: LIST
19801: LIST
19802: LIST
19803: LIST
19804: LIST
19805: LIST
19806: LIST
19807: LIST
19808: LIST
19809: LIST
19810: ST_TO_ADDR
19811: GO 19872
19813: LD_INT 3
19815: DOUBLE
19816: EQUAL
19817: IFTRUE 19821
19819: GO 19871
19821: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19822: LD_ADDR_VAR 0 3
19826: PUSH
19827: LD_INT 13
19829: PUSH
19830: LD_INT 14
19832: PUSH
19833: LD_INT 2
19835: PUSH
19836: LD_INT 3
19838: PUSH
19839: LD_INT 4
19841: PUSH
19842: LD_INT 5
19844: PUSH
19845: LD_INT 21
19847: PUSH
19848: LD_INT 22
19850: PUSH
19851: LD_INT 23
19853: PUSH
19854: LD_INT 24
19856: PUSH
19857: EMPTY
19858: LIST
19859: LIST
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: ST_TO_ADDR
19869: GO 19872
19871: POP
// result := ( chassis in result ) ;
19872: LD_ADDR_VAR 0 3
19876: PUSH
19877: LD_VAR 0 1
19881: PUSH
19882: LD_VAR 0 3
19886: IN
19887: ST_TO_ADDR
// end ;
19888: LD_VAR 0 3
19892: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19893: LD_INT 0
19895: PPUSH
// if not chassis or not weapon then
19896: LD_VAR 0 1
19900: NOT
19901: PUSH
19902: LD_VAR 0 2
19906: NOT
19907: OR
19908: IFFALSE 19912
// exit ;
19910: GO 20938
// case weapon of us_machine_gun :
19912: LD_VAR 0 2
19916: PUSH
19917: LD_INT 2
19919: DOUBLE
19920: EQUAL
19921: IFTRUE 19925
19923: GO 19955
19925: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19926: LD_ADDR_VAR 0 3
19930: PUSH
19931: LD_INT 1
19933: PUSH
19934: LD_INT 2
19936: PUSH
19937: LD_INT 3
19939: PUSH
19940: LD_INT 4
19942: PUSH
19943: LD_INT 5
19945: PUSH
19946: EMPTY
19947: LIST
19948: LIST
19949: LIST
19950: LIST
19951: LIST
19952: ST_TO_ADDR
19953: GO 20922
19955: LD_INT 3
19957: DOUBLE
19958: EQUAL
19959: IFTRUE 19963
19961: GO 19993
19963: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19964: LD_ADDR_VAR 0 3
19968: PUSH
19969: LD_INT 1
19971: PUSH
19972: LD_INT 2
19974: PUSH
19975: LD_INT 3
19977: PUSH
19978: LD_INT 4
19980: PUSH
19981: LD_INT 5
19983: PUSH
19984: EMPTY
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: ST_TO_ADDR
19991: GO 20922
19993: LD_INT 11
19995: DOUBLE
19996: EQUAL
19997: IFTRUE 20001
19999: GO 20031
20001: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20002: LD_ADDR_VAR 0 3
20006: PUSH
20007: LD_INT 1
20009: PUSH
20010: LD_INT 2
20012: PUSH
20013: LD_INT 3
20015: PUSH
20016: LD_INT 4
20018: PUSH
20019: LD_INT 5
20021: PUSH
20022: EMPTY
20023: LIST
20024: LIST
20025: LIST
20026: LIST
20027: LIST
20028: ST_TO_ADDR
20029: GO 20922
20031: LD_INT 4
20033: DOUBLE
20034: EQUAL
20035: IFTRUE 20039
20037: GO 20065
20039: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20040: LD_ADDR_VAR 0 3
20044: PUSH
20045: LD_INT 2
20047: PUSH
20048: LD_INT 3
20050: PUSH
20051: LD_INT 4
20053: PUSH
20054: LD_INT 5
20056: PUSH
20057: EMPTY
20058: LIST
20059: LIST
20060: LIST
20061: LIST
20062: ST_TO_ADDR
20063: GO 20922
20065: LD_INT 5
20067: DOUBLE
20068: EQUAL
20069: IFTRUE 20073
20071: GO 20099
20073: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
20074: LD_ADDR_VAR 0 3
20078: PUSH
20079: LD_INT 2
20081: PUSH
20082: LD_INT 3
20084: PUSH
20085: LD_INT 4
20087: PUSH
20088: LD_INT 5
20090: PUSH
20091: EMPTY
20092: LIST
20093: LIST
20094: LIST
20095: LIST
20096: ST_TO_ADDR
20097: GO 20922
20099: LD_INT 9
20101: DOUBLE
20102: EQUAL
20103: IFTRUE 20107
20105: GO 20133
20107: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
20108: LD_ADDR_VAR 0 3
20112: PUSH
20113: LD_INT 2
20115: PUSH
20116: LD_INT 3
20118: PUSH
20119: LD_INT 4
20121: PUSH
20122: LD_INT 5
20124: PUSH
20125: EMPTY
20126: LIST
20127: LIST
20128: LIST
20129: LIST
20130: ST_TO_ADDR
20131: GO 20922
20133: LD_INT 7
20135: DOUBLE
20136: EQUAL
20137: IFTRUE 20141
20139: GO 20167
20141: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
20142: LD_ADDR_VAR 0 3
20146: PUSH
20147: LD_INT 2
20149: PUSH
20150: LD_INT 3
20152: PUSH
20153: LD_INT 4
20155: PUSH
20156: LD_INT 5
20158: PUSH
20159: EMPTY
20160: LIST
20161: LIST
20162: LIST
20163: LIST
20164: ST_TO_ADDR
20165: GO 20922
20167: LD_INT 12
20169: DOUBLE
20170: EQUAL
20171: IFTRUE 20175
20173: GO 20201
20175: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20176: LD_ADDR_VAR 0 3
20180: PUSH
20181: LD_INT 2
20183: PUSH
20184: LD_INT 3
20186: PUSH
20187: LD_INT 4
20189: PUSH
20190: LD_INT 5
20192: PUSH
20193: EMPTY
20194: LIST
20195: LIST
20196: LIST
20197: LIST
20198: ST_TO_ADDR
20199: GO 20922
20201: LD_INT 13
20203: DOUBLE
20204: EQUAL
20205: IFTRUE 20209
20207: GO 20235
20209: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20210: LD_ADDR_VAR 0 3
20214: PUSH
20215: LD_INT 2
20217: PUSH
20218: LD_INT 3
20220: PUSH
20221: LD_INT 4
20223: PUSH
20224: LD_INT 5
20226: PUSH
20227: EMPTY
20228: LIST
20229: LIST
20230: LIST
20231: LIST
20232: ST_TO_ADDR
20233: GO 20922
20235: LD_INT 14
20237: DOUBLE
20238: EQUAL
20239: IFTRUE 20243
20241: GO 20261
20243: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20244: LD_ADDR_VAR 0 3
20248: PUSH
20249: LD_INT 4
20251: PUSH
20252: LD_INT 5
20254: PUSH
20255: EMPTY
20256: LIST
20257: LIST
20258: ST_TO_ADDR
20259: GO 20922
20261: LD_INT 6
20263: DOUBLE
20264: EQUAL
20265: IFTRUE 20269
20267: GO 20287
20269: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20270: LD_ADDR_VAR 0 3
20274: PUSH
20275: LD_INT 4
20277: PUSH
20278: LD_INT 5
20280: PUSH
20281: EMPTY
20282: LIST
20283: LIST
20284: ST_TO_ADDR
20285: GO 20922
20287: LD_INT 10
20289: DOUBLE
20290: EQUAL
20291: IFTRUE 20295
20293: GO 20313
20295: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20296: LD_ADDR_VAR 0 3
20300: PUSH
20301: LD_INT 4
20303: PUSH
20304: LD_INT 5
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: ST_TO_ADDR
20311: GO 20922
20313: LD_INT 22
20315: DOUBLE
20316: EQUAL
20317: IFTRUE 20321
20319: GO 20347
20321: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20322: LD_ADDR_VAR 0 3
20326: PUSH
20327: LD_INT 11
20329: PUSH
20330: LD_INT 12
20332: PUSH
20333: LD_INT 13
20335: PUSH
20336: LD_INT 14
20338: PUSH
20339: EMPTY
20340: LIST
20341: LIST
20342: LIST
20343: LIST
20344: ST_TO_ADDR
20345: GO 20922
20347: LD_INT 23
20349: DOUBLE
20350: EQUAL
20351: IFTRUE 20355
20353: GO 20381
20355: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20356: LD_ADDR_VAR 0 3
20360: PUSH
20361: LD_INT 11
20363: PUSH
20364: LD_INT 12
20366: PUSH
20367: LD_INT 13
20369: PUSH
20370: LD_INT 14
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: ST_TO_ADDR
20379: GO 20922
20381: LD_INT 24
20383: DOUBLE
20384: EQUAL
20385: IFTRUE 20389
20387: GO 20415
20389: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20390: LD_ADDR_VAR 0 3
20394: PUSH
20395: LD_INT 11
20397: PUSH
20398: LD_INT 12
20400: PUSH
20401: LD_INT 13
20403: PUSH
20404: LD_INT 14
20406: PUSH
20407: EMPTY
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: ST_TO_ADDR
20413: GO 20922
20415: LD_INT 30
20417: DOUBLE
20418: EQUAL
20419: IFTRUE 20423
20421: GO 20449
20423: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20424: LD_ADDR_VAR 0 3
20428: PUSH
20429: LD_INT 11
20431: PUSH
20432: LD_INT 12
20434: PUSH
20435: LD_INT 13
20437: PUSH
20438: LD_INT 14
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: LIST
20445: LIST
20446: ST_TO_ADDR
20447: GO 20922
20449: LD_INT 25
20451: DOUBLE
20452: EQUAL
20453: IFTRUE 20457
20455: GO 20475
20457: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20458: LD_ADDR_VAR 0 3
20462: PUSH
20463: LD_INT 13
20465: PUSH
20466: LD_INT 14
20468: PUSH
20469: EMPTY
20470: LIST
20471: LIST
20472: ST_TO_ADDR
20473: GO 20922
20475: LD_INT 27
20477: DOUBLE
20478: EQUAL
20479: IFTRUE 20483
20481: GO 20501
20483: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20484: LD_ADDR_VAR 0 3
20488: PUSH
20489: LD_INT 13
20491: PUSH
20492: LD_INT 14
20494: PUSH
20495: EMPTY
20496: LIST
20497: LIST
20498: ST_TO_ADDR
20499: GO 20922
20501: LD_INT 28
20503: DOUBLE
20504: EQUAL
20505: IFTRUE 20509
20507: GO 20527
20509: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20510: LD_ADDR_VAR 0 3
20514: PUSH
20515: LD_INT 13
20517: PUSH
20518: LD_INT 14
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: ST_TO_ADDR
20525: GO 20922
20527: LD_INT 29
20529: DOUBLE
20530: EQUAL
20531: IFTRUE 20535
20533: GO 20553
20535: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20536: LD_ADDR_VAR 0 3
20540: PUSH
20541: LD_INT 13
20543: PUSH
20544: LD_INT 14
20546: PUSH
20547: EMPTY
20548: LIST
20549: LIST
20550: ST_TO_ADDR
20551: GO 20922
20553: LD_INT 31
20555: DOUBLE
20556: EQUAL
20557: IFTRUE 20561
20559: GO 20579
20561: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20562: LD_ADDR_VAR 0 3
20566: PUSH
20567: LD_INT 13
20569: PUSH
20570: LD_INT 14
20572: PUSH
20573: EMPTY
20574: LIST
20575: LIST
20576: ST_TO_ADDR
20577: GO 20922
20579: LD_INT 26
20581: DOUBLE
20582: EQUAL
20583: IFTRUE 20587
20585: GO 20605
20587: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20588: LD_ADDR_VAR 0 3
20592: PUSH
20593: LD_INT 13
20595: PUSH
20596: LD_INT 14
20598: PUSH
20599: EMPTY
20600: LIST
20601: LIST
20602: ST_TO_ADDR
20603: GO 20922
20605: LD_INT 42
20607: DOUBLE
20608: EQUAL
20609: IFTRUE 20613
20611: GO 20639
20613: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20614: LD_ADDR_VAR 0 3
20618: PUSH
20619: LD_INT 21
20621: PUSH
20622: LD_INT 22
20624: PUSH
20625: LD_INT 23
20627: PUSH
20628: LD_INT 24
20630: PUSH
20631: EMPTY
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: ST_TO_ADDR
20637: GO 20922
20639: LD_INT 43
20641: DOUBLE
20642: EQUAL
20643: IFTRUE 20647
20645: GO 20673
20647: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20648: LD_ADDR_VAR 0 3
20652: PUSH
20653: LD_INT 21
20655: PUSH
20656: LD_INT 22
20658: PUSH
20659: LD_INT 23
20661: PUSH
20662: LD_INT 24
20664: PUSH
20665: EMPTY
20666: LIST
20667: LIST
20668: LIST
20669: LIST
20670: ST_TO_ADDR
20671: GO 20922
20673: LD_INT 44
20675: DOUBLE
20676: EQUAL
20677: IFTRUE 20681
20679: GO 20707
20681: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20682: LD_ADDR_VAR 0 3
20686: PUSH
20687: LD_INT 21
20689: PUSH
20690: LD_INT 22
20692: PUSH
20693: LD_INT 23
20695: PUSH
20696: LD_INT 24
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: LIST
20703: LIST
20704: ST_TO_ADDR
20705: GO 20922
20707: LD_INT 45
20709: DOUBLE
20710: EQUAL
20711: IFTRUE 20715
20713: GO 20741
20715: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20716: LD_ADDR_VAR 0 3
20720: PUSH
20721: LD_INT 21
20723: PUSH
20724: LD_INT 22
20726: PUSH
20727: LD_INT 23
20729: PUSH
20730: LD_INT 24
20732: PUSH
20733: EMPTY
20734: LIST
20735: LIST
20736: LIST
20737: LIST
20738: ST_TO_ADDR
20739: GO 20922
20741: LD_INT 49
20743: DOUBLE
20744: EQUAL
20745: IFTRUE 20749
20747: GO 20775
20749: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20750: LD_ADDR_VAR 0 3
20754: PUSH
20755: LD_INT 21
20757: PUSH
20758: LD_INT 22
20760: PUSH
20761: LD_INT 23
20763: PUSH
20764: LD_INT 24
20766: PUSH
20767: EMPTY
20768: LIST
20769: LIST
20770: LIST
20771: LIST
20772: ST_TO_ADDR
20773: GO 20922
20775: LD_INT 51
20777: DOUBLE
20778: EQUAL
20779: IFTRUE 20783
20781: GO 20809
20783: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20784: LD_ADDR_VAR 0 3
20788: PUSH
20789: LD_INT 21
20791: PUSH
20792: LD_INT 22
20794: PUSH
20795: LD_INT 23
20797: PUSH
20798: LD_INT 24
20800: PUSH
20801: EMPTY
20802: LIST
20803: LIST
20804: LIST
20805: LIST
20806: ST_TO_ADDR
20807: GO 20922
20809: LD_INT 52
20811: DOUBLE
20812: EQUAL
20813: IFTRUE 20817
20815: GO 20843
20817: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20818: LD_ADDR_VAR 0 3
20822: PUSH
20823: LD_INT 21
20825: PUSH
20826: LD_INT 22
20828: PUSH
20829: LD_INT 23
20831: PUSH
20832: LD_INT 24
20834: PUSH
20835: EMPTY
20836: LIST
20837: LIST
20838: LIST
20839: LIST
20840: ST_TO_ADDR
20841: GO 20922
20843: LD_INT 53
20845: DOUBLE
20846: EQUAL
20847: IFTRUE 20851
20849: GO 20869
20851: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20852: LD_ADDR_VAR 0 3
20856: PUSH
20857: LD_INT 23
20859: PUSH
20860: LD_INT 24
20862: PUSH
20863: EMPTY
20864: LIST
20865: LIST
20866: ST_TO_ADDR
20867: GO 20922
20869: LD_INT 46
20871: DOUBLE
20872: EQUAL
20873: IFTRUE 20877
20875: GO 20895
20877: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20878: LD_ADDR_VAR 0 3
20882: PUSH
20883: LD_INT 23
20885: PUSH
20886: LD_INT 24
20888: PUSH
20889: EMPTY
20890: LIST
20891: LIST
20892: ST_TO_ADDR
20893: GO 20922
20895: LD_INT 47
20897: DOUBLE
20898: EQUAL
20899: IFTRUE 20903
20901: GO 20921
20903: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20904: LD_ADDR_VAR 0 3
20908: PUSH
20909: LD_INT 23
20911: PUSH
20912: LD_INT 24
20914: PUSH
20915: EMPTY
20916: LIST
20917: LIST
20918: ST_TO_ADDR
20919: GO 20922
20921: POP
// result := ( chassis in result ) ;
20922: LD_ADDR_VAR 0 3
20926: PUSH
20927: LD_VAR 0 1
20931: PUSH
20932: LD_VAR 0 3
20936: IN
20937: ST_TO_ADDR
// end ;
20938: LD_VAR 0 3
20942: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20943: LD_INT 0
20945: PPUSH
20946: PPUSH
20947: PPUSH
20948: PPUSH
20949: PPUSH
20950: PPUSH
20951: PPUSH
// result := array ;
20952: LD_ADDR_VAR 0 5
20956: PUSH
20957: LD_VAR 0 1
20961: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20962: LD_VAR 0 1
20966: NOT
20967: PUSH
20968: LD_VAR 0 2
20972: NOT
20973: OR
20974: PUSH
20975: LD_VAR 0 3
20979: NOT
20980: OR
20981: PUSH
20982: LD_VAR 0 2
20986: PUSH
20987: LD_VAR 0 1
20991: GREATER
20992: OR
20993: PUSH
20994: LD_VAR 0 3
20998: PUSH
20999: LD_VAR 0 1
21003: GREATER
21004: OR
21005: IFFALSE 21009
// exit ;
21007: GO 21305
// if direction then
21009: LD_VAR 0 4
21013: IFFALSE 21077
// begin d := 1 ;
21015: LD_ADDR_VAR 0 9
21019: PUSH
21020: LD_INT 1
21022: ST_TO_ADDR
// if i_from > i_to then
21023: LD_VAR 0 2
21027: PUSH
21028: LD_VAR 0 3
21032: GREATER
21033: IFFALSE 21059
// length := ( array - i_from ) + i_to else
21035: LD_ADDR_VAR 0 11
21039: PUSH
21040: LD_VAR 0 1
21044: PUSH
21045: LD_VAR 0 2
21049: MINUS
21050: PUSH
21051: LD_VAR 0 3
21055: PLUS
21056: ST_TO_ADDR
21057: GO 21075
// length := i_to - i_from ;
21059: LD_ADDR_VAR 0 11
21063: PUSH
21064: LD_VAR 0 3
21068: PUSH
21069: LD_VAR 0 2
21073: MINUS
21074: ST_TO_ADDR
// end else
21075: GO 21138
// begin d := - 1 ;
21077: LD_ADDR_VAR 0 9
21081: PUSH
21082: LD_INT 1
21084: NEG
21085: ST_TO_ADDR
// if i_from > i_to then
21086: LD_VAR 0 2
21090: PUSH
21091: LD_VAR 0 3
21095: GREATER
21096: IFFALSE 21116
// length := i_from - i_to else
21098: LD_ADDR_VAR 0 11
21102: PUSH
21103: LD_VAR 0 2
21107: PUSH
21108: LD_VAR 0 3
21112: MINUS
21113: ST_TO_ADDR
21114: GO 21138
// length := ( array - i_to ) + i_from ;
21116: LD_ADDR_VAR 0 11
21120: PUSH
21121: LD_VAR 0 1
21125: PUSH
21126: LD_VAR 0 3
21130: MINUS
21131: PUSH
21132: LD_VAR 0 2
21136: PLUS
21137: ST_TO_ADDR
// end ; if not length then
21138: LD_VAR 0 11
21142: NOT
21143: IFFALSE 21147
// exit ;
21145: GO 21305
// tmp := array ;
21147: LD_ADDR_VAR 0 10
21151: PUSH
21152: LD_VAR 0 1
21156: ST_TO_ADDR
// for i = 1 to length do
21157: LD_ADDR_VAR 0 6
21161: PUSH
21162: DOUBLE
21163: LD_INT 1
21165: DEC
21166: ST_TO_ADDR
21167: LD_VAR 0 11
21171: PUSH
21172: FOR_TO
21173: IFFALSE 21293
// begin for j = 1 to array do
21175: LD_ADDR_VAR 0 7
21179: PUSH
21180: DOUBLE
21181: LD_INT 1
21183: DEC
21184: ST_TO_ADDR
21185: LD_VAR 0 1
21189: PUSH
21190: FOR_TO
21191: IFFALSE 21279
// begin k := j + d ;
21193: LD_ADDR_VAR 0 8
21197: PUSH
21198: LD_VAR 0 7
21202: PUSH
21203: LD_VAR 0 9
21207: PLUS
21208: ST_TO_ADDR
// if k > array then
21209: LD_VAR 0 8
21213: PUSH
21214: LD_VAR 0 1
21218: GREATER
21219: IFFALSE 21229
// k := 1 ;
21221: LD_ADDR_VAR 0 8
21225: PUSH
21226: LD_INT 1
21228: ST_TO_ADDR
// if not k then
21229: LD_VAR 0 8
21233: NOT
21234: IFFALSE 21246
// k := array ;
21236: LD_ADDR_VAR 0 8
21240: PUSH
21241: LD_VAR 0 1
21245: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21246: LD_ADDR_VAR 0 10
21250: PUSH
21251: LD_VAR 0 10
21255: PPUSH
21256: LD_VAR 0 8
21260: PPUSH
21261: LD_VAR 0 1
21265: PUSH
21266: LD_VAR 0 7
21270: ARRAY
21271: PPUSH
21272: CALL_OW 1
21276: ST_TO_ADDR
// end ;
21277: GO 21190
21279: POP
21280: POP
// array := tmp ;
21281: LD_ADDR_VAR 0 1
21285: PUSH
21286: LD_VAR 0 10
21290: ST_TO_ADDR
// end ;
21291: GO 21172
21293: POP
21294: POP
// result := array ;
21295: LD_ADDR_VAR 0 5
21299: PUSH
21300: LD_VAR 0 1
21304: ST_TO_ADDR
// end ;
21305: LD_VAR 0 5
21309: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21310: LD_INT 0
21312: PPUSH
21313: PPUSH
// result := 0 ;
21314: LD_ADDR_VAR 0 3
21318: PUSH
21319: LD_INT 0
21321: ST_TO_ADDR
// if not array or not value in array then
21322: LD_VAR 0 1
21326: NOT
21327: PUSH
21328: LD_VAR 0 2
21332: PUSH
21333: LD_VAR 0 1
21337: IN
21338: NOT
21339: OR
21340: IFFALSE 21344
// exit ;
21342: GO 21398
// for i = 1 to array do
21344: LD_ADDR_VAR 0 4
21348: PUSH
21349: DOUBLE
21350: LD_INT 1
21352: DEC
21353: ST_TO_ADDR
21354: LD_VAR 0 1
21358: PUSH
21359: FOR_TO
21360: IFFALSE 21396
// if value = array [ i ] then
21362: LD_VAR 0 2
21366: PUSH
21367: LD_VAR 0 1
21371: PUSH
21372: LD_VAR 0 4
21376: ARRAY
21377: EQUAL
21378: IFFALSE 21394
// begin result := i ;
21380: LD_ADDR_VAR 0 3
21384: PUSH
21385: LD_VAR 0 4
21389: ST_TO_ADDR
// exit ;
21390: POP
21391: POP
21392: GO 21398
// end ;
21394: GO 21359
21396: POP
21397: POP
// end ;
21398: LD_VAR 0 3
21402: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21403: LD_INT 0
21405: PPUSH
// vc_chassis := chassis ;
21406: LD_ADDR_OWVAR 37
21410: PUSH
21411: LD_VAR 0 1
21415: ST_TO_ADDR
// vc_engine := engine ;
21416: LD_ADDR_OWVAR 39
21420: PUSH
21421: LD_VAR 0 2
21425: ST_TO_ADDR
// vc_control := control ;
21426: LD_ADDR_OWVAR 38
21430: PUSH
21431: LD_VAR 0 3
21435: ST_TO_ADDR
// vc_weapon := weapon ;
21436: LD_ADDR_OWVAR 40
21440: PUSH
21441: LD_VAR 0 4
21445: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21446: LD_ADDR_OWVAR 41
21450: PUSH
21451: LD_VAR 0 5
21455: ST_TO_ADDR
// end ;
21456: LD_VAR 0 6
21460: RET
// export function WantPlant ( unit ) ; var task ; begin
21461: LD_INT 0
21463: PPUSH
21464: PPUSH
// result := false ;
21465: LD_ADDR_VAR 0 2
21469: PUSH
21470: LD_INT 0
21472: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21473: LD_ADDR_VAR 0 3
21477: PUSH
21478: LD_VAR 0 1
21482: PPUSH
21483: CALL_OW 437
21487: ST_TO_ADDR
// if task then
21488: LD_VAR 0 3
21492: IFFALSE 21520
// if task [ 1 ] [ 1 ] = p then
21494: LD_VAR 0 3
21498: PUSH
21499: LD_INT 1
21501: ARRAY
21502: PUSH
21503: LD_INT 1
21505: ARRAY
21506: PUSH
21507: LD_STRING p
21509: EQUAL
21510: IFFALSE 21520
// result := true ;
21512: LD_ADDR_VAR 0 2
21516: PUSH
21517: LD_INT 1
21519: ST_TO_ADDR
// end ;
21520: LD_VAR 0 2
21524: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21525: LD_INT 0
21527: PPUSH
21528: PPUSH
21529: PPUSH
21530: PPUSH
// if pos < 1 then
21531: LD_VAR 0 2
21535: PUSH
21536: LD_INT 1
21538: LESS
21539: IFFALSE 21543
// exit ;
21541: GO 21846
// if pos = 1 then
21543: LD_VAR 0 2
21547: PUSH
21548: LD_INT 1
21550: EQUAL
21551: IFFALSE 21584
// result := Replace ( arr , pos [ 1 ] , value ) else
21553: LD_ADDR_VAR 0 4
21557: PUSH
21558: LD_VAR 0 1
21562: PPUSH
21563: LD_VAR 0 2
21567: PUSH
21568: LD_INT 1
21570: ARRAY
21571: PPUSH
21572: LD_VAR 0 3
21576: PPUSH
21577: CALL_OW 1
21581: ST_TO_ADDR
21582: GO 21846
// begin tmp := arr ;
21584: LD_ADDR_VAR 0 6
21588: PUSH
21589: LD_VAR 0 1
21593: ST_TO_ADDR
// s_arr := [ tmp ] ;
21594: LD_ADDR_VAR 0 7
21598: PUSH
21599: LD_VAR 0 6
21603: PUSH
21604: EMPTY
21605: LIST
21606: ST_TO_ADDR
// for i = 1 to pos - 1 do
21607: LD_ADDR_VAR 0 5
21611: PUSH
21612: DOUBLE
21613: LD_INT 1
21615: DEC
21616: ST_TO_ADDR
21617: LD_VAR 0 2
21621: PUSH
21622: LD_INT 1
21624: MINUS
21625: PUSH
21626: FOR_TO
21627: IFFALSE 21672
// begin tmp := tmp [ pos [ i ] ] ;
21629: LD_ADDR_VAR 0 6
21633: PUSH
21634: LD_VAR 0 6
21638: PUSH
21639: LD_VAR 0 2
21643: PUSH
21644: LD_VAR 0 5
21648: ARRAY
21649: ARRAY
21650: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21651: LD_ADDR_VAR 0 7
21655: PUSH
21656: LD_VAR 0 7
21660: PUSH
21661: LD_VAR 0 6
21665: PUSH
21666: EMPTY
21667: LIST
21668: ADD
21669: ST_TO_ADDR
// end ;
21670: GO 21626
21672: POP
21673: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21674: LD_ADDR_VAR 0 6
21678: PUSH
21679: LD_VAR 0 6
21683: PPUSH
21684: LD_VAR 0 2
21688: PUSH
21689: LD_VAR 0 2
21693: ARRAY
21694: PPUSH
21695: LD_VAR 0 3
21699: PPUSH
21700: CALL_OW 1
21704: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21705: LD_ADDR_VAR 0 7
21709: PUSH
21710: LD_VAR 0 7
21714: PPUSH
21715: LD_VAR 0 7
21719: PPUSH
21720: LD_VAR 0 6
21724: PPUSH
21725: CALL_OW 1
21729: ST_TO_ADDR
// for i = s_arr downto 2 do
21730: LD_ADDR_VAR 0 5
21734: PUSH
21735: DOUBLE
21736: LD_VAR 0 7
21740: INC
21741: ST_TO_ADDR
21742: LD_INT 2
21744: PUSH
21745: FOR_DOWNTO
21746: IFFALSE 21830
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21748: LD_ADDR_VAR 0 6
21752: PUSH
21753: LD_VAR 0 7
21757: PUSH
21758: LD_VAR 0 5
21762: PUSH
21763: LD_INT 1
21765: MINUS
21766: ARRAY
21767: PPUSH
21768: LD_VAR 0 2
21772: PUSH
21773: LD_VAR 0 5
21777: PUSH
21778: LD_INT 1
21780: MINUS
21781: ARRAY
21782: PPUSH
21783: LD_VAR 0 7
21787: PUSH
21788: LD_VAR 0 5
21792: ARRAY
21793: PPUSH
21794: CALL_OW 1
21798: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21799: LD_ADDR_VAR 0 7
21803: PUSH
21804: LD_VAR 0 7
21808: PPUSH
21809: LD_VAR 0 5
21813: PUSH
21814: LD_INT 1
21816: MINUS
21817: PPUSH
21818: LD_VAR 0 6
21822: PPUSH
21823: CALL_OW 1
21827: ST_TO_ADDR
// end ;
21828: GO 21745
21830: POP
21831: POP
// result := s_arr [ 1 ] ;
21832: LD_ADDR_VAR 0 4
21836: PUSH
21837: LD_VAR 0 7
21841: PUSH
21842: LD_INT 1
21844: ARRAY
21845: ST_TO_ADDR
// end ; end ;
21846: LD_VAR 0 4
21850: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21851: LD_INT 0
21853: PPUSH
21854: PPUSH
// if not list then
21855: LD_VAR 0 1
21859: NOT
21860: IFFALSE 21864
// exit ;
21862: GO 21955
// i := list [ pos1 ] ;
21864: LD_ADDR_VAR 0 5
21868: PUSH
21869: LD_VAR 0 1
21873: PUSH
21874: LD_VAR 0 2
21878: ARRAY
21879: ST_TO_ADDR
// if not i then
21880: LD_VAR 0 5
21884: NOT
21885: IFFALSE 21889
// exit ;
21887: GO 21955
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21889: LD_ADDR_VAR 0 1
21893: PUSH
21894: LD_VAR 0 1
21898: PPUSH
21899: LD_VAR 0 2
21903: PPUSH
21904: LD_VAR 0 1
21908: PUSH
21909: LD_VAR 0 3
21913: ARRAY
21914: PPUSH
21915: CALL_OW 1
21919: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21920: LD_ADDR_VAR 0 1
21924: PUSH
21925: LD_VAR 0 1
21929: PPUSH
21930: LD_VAR 0 3
21934: PPUSH
21935: LD_VAR 0 5
21939: PPUSH
21940: CALL_OW 1
21944: ST_TO_ADDR
// result := list ;
21945: LD_ADDR_VAR 0 4
21949: PUSH
21950: LD_VAR 0 1
21954: ST_TO_ADDR
// end ;
21955: LD_VAR 0 4
21959: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21960: LD_INT 0
21962: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21963: LD_ADDR_VAR 0 5
21967: PUSH
21968: LD_VAR 0 1
21972: PPUSH
21973: CALL_OW 250
21977: PPUSH
21978: LD_VAR 0 1
21982: PPUSH
21983: CALL_OW 251
21987: PPUSH
21988: LD_VAR 0 2
21992: PPUSH
21993: LD_VAR 0 3
21997: PPUSH
21998: LD_VAR 0 4
22002: PPUSH
22003: CALL 22013 0 5
22007: ST_TO_ADDR
// end ;
22008: LD_VAR 0 5
22012: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22013: LD_INT 0
22015: PPUSH
22016: PPUSH
22017: PPUSH
22018: PPUSH
// if not list then
22019: LD_VAR 0 3
22023: NOT
22024: IFFALSE 22028
// exit ;
22026: GO 22416
// result := [ ] ;
22028: LD_ADDR_VAR 0 6
22032: PUSH
22033: EMPTY
22034: ST_TO_ADDR
// for i in list do
22035: LD_ADDR_VAR 0 7
22039: PUSH
22040: LD_VAR 0 3
22044: PUSH
22045: FOR_IN
22046: IFFALSE 22248
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22048: LD_ADDR_VAR 0 9
22052: PUSH
22053: LD_VAR 0 7
22057: PPUSH
22058: LD_VAR 0 1
22062: PPUSH
22063: LD_VAR 0 2
22067: PPUSH
22068: CALL_OW 297
22072: ST_TO_ADDR
// if not result then
22073: LD_VAR 0 6
22077: NOT
22078: IFFALSE 22104
// result := [ [ i , tmp ] ] else
22080: LD_ADDR_VAR 0 6
22084: PUSH
22085: LD_VAR 0 7
22089: PUSH
22090: LD_VAR 0 9
22094: PUSH
22095: EMPTY
22096: LIST
22097: LIST
22098: PUSH
22099: EMPTY
22100: LIST
22101: ST_TO_ADDR
22102: GO 22246
// begin if result [ result ] [ 2 ] < tmp then
22104: LD_VAR 0 6
22108: PUSH
22109: LD_VAR 0 6
22113: ARRAY
22114: PUSH
22115: LD_INT 2
22117: ARRAY
22118: PUSH
22119: LD_VAR 0 9
22123: LESS
22124: IFFALSE 22166
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
22126: LD_ADDR_VAR 0 6
22130: PUSH
22131: LD_VAR 0 6
22135: PPUSH
22136: LD_VAR 0 6
22140: PUSH
22141: LD_INT 1
22143: PLUS
22144: PPUSH
22145: LD_VAR 0 7
22149: PUSH
22150: LD_VAR 0 9
22154: PUSH
22155: EMPTY
22156: LIST
22157: LIST
22158: PPUSH
22159: CALL_OW 2
22163: ST_TO_ADDR
22164: GO 22246
// for j = 1 to result do
22166: LD_ADDR_VAR 0 8
22170: PUSH
22171: DOUBLE
22172: LD_INT 1
22174: DEC
22175: ST_TO_ADDR
22176: LD_VAR 0 6
22180: PUSH
22181: FOR_TO
22182: IFFALSE 22244
// begin if tmp < result [ j ] [ 2 ] then
22184: LD_VAR 0 9
22188: PUSH
22189: LD_VAR 0 6
22193: PUSH
22194: LD_VAR 0 8
22198: ARRAY
22199: PUSH
22200: LD_INT 2
22202: ARRAY
22203: LESS
22204: IFFALSE 22242
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22206: LD_ADDR_VAR 0 6
22210: PUSH
22211: LD_VAR 0 6
22215: PPUSH
22216: LD_VAR 0 8
22220: PPUSH
22221: LD_VAR 0 7
22225: PUSH
22226: LD_VAR 0 9
22230: PUSH
22231: EMPTY
22232: LIST
22233: LIST
22234: PPUSH
22235: CALL_OW 2
22239: ST_TO_ADDR
// break ;
22240: GO 22244
// end ; end ;
22242: GO 22181
22244: POP
22245: POP
// end ; end ;
22246: GO 22045
22248: POP
22249: POP
// if result and not asc then
22250: LD_VAR 0 6
22254: PUSH
22255: LD_VAR 0 4
22259: NOT
22260: AND
22261: IFFALSE 22336
// begin tmp := result ;
22263: LD_ADDR_VAR 0 9
22267: PUSH
22268: LD_VAR 0 6
22272: ST_TO_ADDR
// for i = tmp downto 1 do
22273: LD_ADDR_VAR 0 7
22277: PUSH
22278: DOUBLE
22279: LD_VAR 0 9
22283: INC
22284: ST_TO_ADDR
22285: LD_INT 1
22287: PUSH
22288: FOR_DOWNTO
22289: IFFALSE 22334
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22291: LD_ADDR_VAR 0 6
22295: PUSH
22296: LD_VAR 0 6
22300: PPUSH
22301: LD_VAR 0 9
22305: PUSH
22306: LD_VAR 0 7
22310: MINUS
22311: PUSH
22312: LD_INT 1
22314: PLUS
22315: PPUSH
22316: LD_VAR 0 9
22320: PUSH
22321: LD_VAR 0 7
22325: ARRAY
22326: PPUSH
22327: CALL_OW 1
22331: ST_TO_ADDR
22332: GO 22288
22334: POP
22335: POP
// end ; tmp := [ ] ;
22336: LD_ADDR_VAR 0 9
22340: PUSH
22341: EMPTY
22342: ST_TO_ADDR
// if mode then
22343: LD_VAR 0 5
22347: IFFALSE 22416
// begin for i = 1 to result do
22349: LD_ADDR_VAR 0 7
22353: PUSH
22354: DOUBLE
22355: LD_INT 1
22357: DEC
22358: ST_TO_ADDR
22359: LD_VAR 0 6
22363: PUSH
22364: FOR_TO
22365: IFFALSE 22404
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22367: LD_ADDR_VAR 0 9
22371: PUSH
22372: LD_VAR 0 9
22376: PPUSH
22377: LD_VAR 0 7
22381: PPUSH
22382: LD_VAR 0 6
22386: PUSH
22387: LD_VAR 0 7
22391: ARRAY
22392: PUSH
22393: LD_INT 1
22395: ARRAY
22396: PPUSH
22397: CALL_OW 1
22401: ST_TO_ADDR
22402: GO 22364
22404: POP
22405: POP
// result := tmp ;
22406: LD_ADDR_VAR 0 6
22410: PUSH
22411: LD_VAR 0 9
22415: ST_TO_ADDR
// end ; end ;
22416: LD_VAR 0 6
22420: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22421: LD_INT 0
22423: PPUSH
22424: PPUSH
22425: PPUSH
22426: PPUSH
22427: PPUSH
22428: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22429: LD_ADDR_VAR 0 5
22433: PUSH
22434: LD_INT 0
22436: PUSH
22437: LD_INT 0
22439: PUSH
22440: LD_INT 0
22442: PUSH
22443: EMPTY
22444: PUSH
22445: EMPTY
22446: LIST
22447: LIST
22448: LIST
22449: LIST
22450: ST_TO_ADDR
// if not x or not y then
22451: LD_VAR 0 2
22455: NOT
22456: PUSH
22457: LD_VAR 0 3
22461: NOT
22462: OR
22463: IFFALSE 22467
// exit ;
22465: GO 24113
// if not range then
22467: LD_VAR 0 4
22471: NOT
22472: IFFALSE 22482
// range := 10 ;
22474: LD_ADDR_VAR 0 4
22478: PUSH
22479: LD_INT 10
22481: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22482: LD_ADDR_VAR 0 8
22486: PUSH
22487: LD_INT 81
22489: PUSH
22490: LD_VAR 0 1
22494: PUSH
22495: EMPTY
22496: LIST
22497: LIST
22498: PUSH
22499: LD_INT 92
22501: PUSH
22502: LD_VAR 0 2
22506: PUSH
22507: LD_VAR 0 3
22511: PUSH
22512: LD_VAR 0 4
22516: PUSH
22517: EMPTY
22518: LIST
22519: LIST
22520: LIST
22521: LIST
22522: PUSH
22523: LD_INT 3
22525: PUSH
22526: LD_INT 21
22528: PUSH
22529: LD_INT 3
22531: PUSH
22532: EMPTY
22533: LIST
22534: LIST
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: LIST
22544: PPUSH
22545: CALL_OW 69
22549: ST_TO_ADDR
// if not tmp then
22550: LD_VAR 0 8
22554: NOT
22555: IFFALSE 22559
// exit ;
22557: GO 24113
// for i in tmp do
22559: LD_ADDR_VAR 0 6
22563: PUSH
22564: LD_VAR 0 8
22568: PUSH
22569: FOR_IN
22570: IFFALSE 24088
// begin points := [ 0 , 0 , 0 ] ;
22572: LD_ADDR_VAR 0 9
22576: PUSH
22577: LD_INT 0
22579: PUSH
22580: LD_INT 0
22582: PUSH
22583: LD_INT 0
22585: PUSH
22586: EMPTY
22587: LIST
22588: LIST
22589: LIST
22590: ST_TO_ADDR
// bpoints := 1 ;
22591: LD_ADDR_VAR 0 10
22595: PUSH
22596: LD_INT 1
22598: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22599: LD_VAR 0 6
22603: PPUSH
22604: CALL_OW 247
22608: PUSH
22609: LD_INT 1
22611: DOUBLE
22612: EQUAL
22613: IFTRUE 22617
22615: GO 23195
22617: POP
// begin if GetClass ( i ) = 1 then
22618: LD_VAR 0 6
22622: PPUSH
22623: CALL_OW 257
22627: PUSH
22628: LD_INT 1
22630: EQUAL
22631: IFFALSE 22652
// points := [ 10 , 5 , 3 ] ;
22633: LD_ADDR_VAR 0 9
22637: PUSH
22638: LD_INT 10
22640: PUSH
22641: LD_INT 5
22643: PUSH
22644: LD_INT 3
22646: PUSH
22647: EMPTY
22648: LIST
22649: LIST
22650: LIST
22651: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22652: LD_VAR 0 6
22656: PPUSH
22657: CALL_OW 257
22661: PUSH
22662: LD_INT 2
22664: PUSH
22665: LD_INT 3
22667: PUSH
22668: LD_INT 4
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: LIST
22675: IN
22676: IFFALSE 22697
// points := [ 3 , 2 , 1 ] ;
22678: LD_ADDR_VAR 0 9
22682: PUSH
22683: LD_INT 3
22685: PUSH
22686: LD_INT 2
22688: PUSH
22689: LD_INT 1
22691: PUSH
22692: EMPTY
22693: LIST
22694: LIST
22695: LIST
22696: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22697: LD_VAR 0 6
22701: PPUSH
22702: CALL_OW 257
22706: PUSH
22707: LD_INT 5
22709: EQUAL
22710: IFFALSE 22731
// points := [ 130 , 5 , 2 ] ;
22712: LD_ADDR_VAR 0 9
22716: PUSH
22717: LD_INT 130
22719: PUSH
22720: LD_INT 5
22722: PUSH
22723: LD_INT 2
22725: PUSH
22726: EMPTY
22727: LIST
22728: LIST
22729: LIST
22730: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22731: LD_VAR 0 6
22735: PPUSH
22736: CALL_OW 257
22740: PUSH
22741: LD_INT 8
22743: EQUAL
22744: IFFALSE 22765
// points := [ 35 , 35 , 30 ] ;
22746: LD_ADDR_VAR 0 9
22750: PUSH
22751: LD_INT 35
22753: PUSH
22754: LD_INT 35
22756: PUSH
22757: LD_INT 30
22759: PUSH
22760: EMPTY
22761: LIST
22762: LIST
22763: LIST
22764: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22765: LD_VAR 0 6
22769: PPUSH
22770: CALL_OW 257
22774: PUSH
22775: LD_INT 9
22777: EQUAL
22778: IFFALSE 22799
// points := [ 20 , 55 , 40 ] ;
22780: LD_ADDR_VAR 0 9
22784: PUSH
22785: LD_INT 20
22787: PUSH
22788: LD_INT 55
22790: PUSH
22791: LD_INT 40
22793: PUSH
22794: EMPTY
22795: LIST
22796: LIST
22797: LIST
22798: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22799: LD_VAR 0 6
22803: PPUSH
22804: CALL_OW 257
22808: PUSH
22809: LD_INT 12
22811: PUSH
22812: LD_INT 16
22814: PUSH
22815: EMPTY
22816: LIST
22817: LIST
22818: IN
22819: IFFALSE 22840
// points := [ 5 , 3 , 2 ] ;
22821: LD_ADDR_VAR 0 9
22825: PUSH
22826: LD_INT 5
22828: PUSH
22829: LD_INT 3
22831: PUSH
22832: LD_INT 2
22834: PUSH
22835: EMPTY
22836: LIST
22837: LIST
22838: LIST
22839: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22840: LD_VAR 0 6
22844: PPUSH
22845: CALL_OW 257
22849: PUSH
22850: LD_INT 17
22852: EQUAL
22853: IFFALSE 22874
// points := [ 100 , 50 , 75 ] ;
22855: LD_ADDR_VAR 0 9
22859: PUSH
22860: LD_INT 100
22862: PUSH
22863: LD_INT 50
22865: PUSH
22866: LD_INT 75
22868: PUSH
22869: EMPTY
22870: LIST
22871: LIST
22872: LIST
22873: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22874: LD_VAR 0 6
22878: PPUSH
22879: CALL_OW 257
22883: PUSH
22884: LD_INT 15
22886: EQUAL
22887: IFFALSE 22908
// points := [ 10 , 5 , 3 ] ;
22889: LD_ADDR_VAR 0 9
22893: PUSH
22894: LD_INT 10
22896: PUSH
22897: LD_INT 5
22899: PUSH
22900: LD_INT 3
22902: PUSH
22903: EMPTY
22904: LIST
22905: LIST
22906: LIST
22907: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22908: LD_VAR 0 6
22912: PPUSH
22913: CALL_OW 257
22917: PUSH
22918: LD_INT 14
22920: EQUAL
22921: IFFALSE 22942
// points := [ 10 , 0 , 0 ] ;
22923: LD_ADDR_VAR 0 9
22927: PUSH
22928: LD_INT 10
22930: PUSH
22931: LD_INT 0
22933: PUSH
22934: LD_INT 0
22936: PUSH
22937: EMPTY
22938: LIST
22939: LIST
22940: LIST
22941: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22942: LD_VAR 0 6
22946: PPUSH
22947: CALL_OW 257
22951: PUSH
22952: LD_INT 11
22954: EQUAL
22955: IFFALSE 22976
// points := [ 30 , 10 , 5 ] ;
22957: LD_ADDR_VAR 0 9
22961: PUSH
22962: LD_INT 30
22964: PUSH
22965: LD_INT 10
22967: PUSH
22968: LD_INT 5
22970: PUSH
22971: EMPTY
22972: LIST
22973: LIST
22974: LIST
22975: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22976: LD_VAR 0 1
22980: PPUSH
22981: LD_INT 5
22983: PPUSH
22984: CALL_OW 321
22988: PUSH
22989: LD_INT 2
22991: EQUAL
22992: IFFALSE 23009
// bpoints := bpoints * 1.8 ;
22994: LD_ADDR_VAR 0 10
22998: PUSH
22999: LD_VAR 0 10
23003: PUSH
23004: LD_REAL  1.80000000000000E+0000
23007: MUL
23008: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23009: LD_VAR 0 6
23013: PPUSH
23014: CALL_OW 257
23018: PUSH
23019: LD_INT 1
23021: PUSH
23022: LD_INT 2
23024: PUSH
23025: LD_INT 3
23027: PUSH
23028: LD_INT 4
23030: PUSH
23031: EMPTY
23032: LIST
23033: LIST
23034: LIST
23035: LIST
23036: IN
23037: PUSH
23038: LD_VAR 0 1
23042: PPUSH
23043: LD_INT 51
23045: PPUSH
23046: CALL_OW 321
23050: PUSH
23051: LD_INT 2
23053: EQUAL
23054: AND
23055: IFFALSE 23072
// bpoints := bpoints * 1.2 ;
23057: LD_ADDR_VAR 0 10
23061: PUSH
23062: LD_VAR 0 10
23066: PUSH
23067: LD_REAL  1.20000000000000E+0000
23070: MUL
23071: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23072: LD_VAR 0 6
23076: PPUSH
23077: CALL_OW 257
23081: PUSH
23082: LD_INT 5
23084: PUSH
23085: LD_INT 7
23087: PUSH
23088: LD_INT 9
23090: PUSH
23091: EMPTY
23092: LIST
23093: LIST
23094: LIST
23095: IN
23096: PUSH
23097: LD_VAR 0 1
23101: PPUSH
23102: LD_INT 52
23104: PPUSH
23105: CALL_OW 321
23109: PUSH
23110: LD_INT 2
23112: EQUAL
23113: AND
23114: IFFALSE 23131
// bpoints := bpoints * 1.5 ;
23116: LD_ADDR_VAR 0 10
23120: PUSH
23121: LD_VAR 0 10
23125: PUSH
23126: LD_REAL  1.50000000000000E+0000
23129: MUL
23130: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
23131: LD_VAR 0 1
23135: PPUSH
23136: LD_INT 66
23138: PPUSH
23139: CALL_OW 321
23143: PUSH
23144: LD_INT 2
23146: EQUAL
23147: IFFALSE 23164
// bpoints := bpoints * 1.1 ;
23149: LD_ADDR_VAR 0 10
23153: PUSH
23154: LD_VAR 0 10
23158: PUSH
23159: LD_REAL  1.10000000000000E+0000
23162: MUL
23163: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23164: LD_ADDR_VAR 0 10
23168: PUSH
23169: LD_VAR 0 10
23173: PUSH
23174: LD_VAR 0 6
23178: PPUSH
23179: LD_INT 1
23181: PPUSH
23182: CALL_OW 259
23186: PUSH
23187: LD_REAL  1.15000000000000E+0000
23190: MUL
23191: MUL
23192: ST_TO_ADDR
// end ; unit_vehicle :
23193: GO 24017
23195: LD_INT 2
23197: DOUBLE
23198: EQUAL
23199: IFTRUE 23203
23201: GO 24005
23203: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23204: LD_VAR 0 6
23208: PPUSH
23209: CALL_OW 264
23213: PUSH
23214: LD_INT 2
23216: PUSH
23217: LD_INT 42
23219: PUSH
23220: LD_INT 24
23222: PUSH
23223: EMPTY
23224: LIST
23225: LIST
23226: LIST
23227: IN
23228: IFFALSE 23249
// points := [ 25 , 5 , 3 ] ;
23230: LD_ADDR_VAR 0 9
23234: PUSH
23235: LD_INT 25
23237: PUSH
23238: LD_INT 5
23240: PUSH
23241: LD_INT 3
23243: PUSH
23244: EMPTY
23245: LIST
23246: LIST
23247: LIST
23248: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23249: LD_VAR 0 6
23253: PPUSH
23254: CALL_OW 264
23258: PUSH
23259: LD_INT 4
23261: PUSH
23262: LD_INT 43
23264: PUSH
23265: LD_INT 25
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: LIST
23272: IN
23273: IFFALSE 23294
// points := [ 40 , 15 , 5 ] ;
23275: LD_ADDR_VAR 0 9
23279: PUSH
23280: LD_INT 40
23282: PUSH
23283: LD_INT 15
23285: PUSH
23286: LD_INT 5
23288: PUSH
23289: EMPTY
23290: LIST
23291: LIST
23292: LIST
23293: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23294: LD_VAR 0 6
23298: PPUSH
23299: CALL_OW 264
23303: PUSH
23304: LD_INT 3
23306: PUSH
23307: LD_INT 23
23309: PUSH
23310: EMPTY
23311: LIST
23312: LIST
23313: IN
23314: IFFALSE 23335
// points := [ 7 , 25 , 8 ] ;
23316: LD_ADDR_VAR 0 9
23320: PUSH
23321: LD_INT 7
23323: PUSH
23324: LD_INT 25
23326: PUSH
23327: LD_INT 8
23329: PUSH
23330: EMPTY
23331: LIST
23332: LIST
23333: LIST
23334: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23335: LD_VAR 0 6
23339: PPUSH
23340: CALL_OW 264
23344: PUSH
23345: LD_INT 5
23347: PUSH
23348: LD_INT 27
23350: PUSH
23351: LD_INT 44
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: LIST
23358: IN
23359: IFFALSE 23380
// points := [ 14 , 50 , 16 ] ;
23361: LD_ADDR_VAR 0 9
23365: PUSH
23366: LD_INT 14
23368: PUSH
23369: LD_INT 50
23371: PUSH
23372: LD_INT 16
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: LIST
23379: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23380: LD_VAR 0 6
23384: PPUSH
23385: CALL_OW 264
23389: PUSH
23390: LD_INT 6
23392: PUSH
23393: LD_INT 46
23395: PUSH
23396: EMPTY
23397: LIST
23398: LIST
23399: IN
23400: IFFALSE 23421
// points := [ 32 , 120 , 70 ] ;
23402: LD_ADDR_VAR 0 9
23406: PUSH
23407: LD_INT 32
23409: PUSH
23410: LD_INT 120
23412: PUSH
23413: LD_INT 70
23415: PUSH
23416: EMPTY
23417: LIST
23418: LIST
23419: LIST
23420: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
23421: LD_VAR 0 6
23425: PPUSH
23426: CALL_OW 264
23430: PUSH
23431: LD_INT 7
23433: PUSH
23434: LD_INT 28
23436: PUSH
23437: LD_INT 45
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: LIST
23444: IN
23445: IFFALSE 23466
// points := [ 35 , 20 , 45 ] ;
23447: LD_ADDR_VAR 0 9
23451: PUSH
23452: LD_INT 35
23454: PUSH
23455: LD_INT 20
23457: PUSH
23458: LD_INT 45
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: LIST
23465: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23466: LD_VAR 0 6
23470: PPUSH
23471: CALL_OW 264
23475: PUSH
23476: LD_INT 47
23478: PUSH
23479: EMPTY
23480: LIST
23481: IN
23482: IFFALSE 23503
// points := [ 67 , 45 , 75 ] ;
23484: LD_ADDR_VAR 0 9
23488: PUSH
23489: LD_INT 67
23491: PUSH
23492: LD_INT 45
23494: PUSH
23495: LD_INT 75
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: LIST
23502: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23503: LD_VAR 0 6
23507: PPUSH
23508: CALL_OW 264
23512: PUSH
23513: LD_INT 26
23515: PUSH
23516: EMPTY
23517: LIST
23518: IN
23519: IFFALSE 23540
// points := [ 120 , 30 , 80 ] ;
23521: LD_ADDR_VAR 0 9
23525: PUSH
23526: LD_INT 120
23528: PUSH
23529: LD_INT 30
23531: PUSH
23532: LD_INT 80
23534: PUSH
23535: EMPTY
23536: LIST
23537: LIST
23538: LIST
23539: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23540: LD_VAR 0 6
23544: PPUSH
23545: CALL_OW 264
23549: PUSH
23550: LD_INT 22
23552: PUSH
23553: EMPTY
23554: LIST
23555: IN
23556: IFFALSE 23577
// points := [ 40 , 1 , 1 ] ;
23558: LD_ADDR_VAR 0 9
23562: PUSH
23563: LD_INT 40
23565: PUSH
23566: LD_INT 1
23568: PUSH
23569: LD_INT 1
23571: PUSH
23572: EMPTY
23573: LIST
23574: LIST
23575: LIST
23576: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23577: LD_VAR 0 6
23581: PPUSH
23582: CALL_OW 264
23586: PUSH
23587: LD_INT 29
23589: PUSH
23590: EMPTY
23591: LIST
23592: IN
23593: IFFALSE 23614
// points := [ 70 , 200 , 400 ] ;
23595: LD_ADDR_VAR 0 9
23599: PUSH
23600: LD_INT 70
23602: PUSH
23603: LD_INT 200
23605: PUSH
23606: LD_INT 400
23608: PUSH
23609: EMPTY
23610: LIST
23611: LIST
23612: LIST
23613: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23614: LD_VAR 0 6
23618: PPUSH
23619: CALL_OW 264
23623: PUSH
23624: LD_INT 14
23626: PUSH
23627: LD_INT 53
23629: PUSH
23630: EMPTY
23631: LIST
23632: LIST
23633: IN
23634: IFFALSE 23655
// points := [ 40 , 10 , 20 ] ;
23636: LD_ADDR_VAR 0 9
23640: PUSH
23641: LD_INT 40
23643: PUSH
23644: LD_INT 10
23646: PUSH
23647: LD_INT 20
23649: PUSH
23650: EMPTY
23651: LIST
23652: LIST
23653: LIST
23654: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23655: LD_VAR 0 6
23659: PPUSH
23660: CALL_OW 264
23664: PUSH
23665: LD_INT 9
23667: PUSH
23668: EMPTY
23669: LIST
23670: IN
23671: IFFALSE 23692
// points := [ 5 , 70 , 20 ] ;
23673: LD_ADDR_VAR 0 9
23677: PUSH
23678: LD_INT 5
23680: PUSH
23681: LD_INT 70
23683: PUSH
23684: LD_INT 20
23686: PUSH
23687: EMPTY
23688: LIST
23689: LIST
23690: LIST
23691: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23692: LD_VAR 0 6
23696: PPUSH
23697: CALL_OW 264
23701: PUSH
23702: LD_INT 10
23704: PUSH
23705: EMPTY
23706: LIST
23707: IN
23708: IFFALSE 23729
// points := [ 35 , 110 , 70 ] ;
23710: LD_ADDR_VAR 0 9
23714: PUSH
23715: LD_INT 35
23717: PUSH
23718: LD_INT 110
23720: PUSH
23721: LD_INT 70
23723: PUSH
23724: EMPTY
23725: LIST
23726: LIST
23727: LIST
23728: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23729: LD_VAR 0 6
23733: PPUSH
23734: CALL_OW 265
23738: PUSH
23739: LD_INT 25
23741: EQUAL
23742: IFFALSE 23763
// points := [ 80 , 65 , 100 ] ;
23744: LD_ADDR_VAR 0 9
23748: PUSH
23749: LD_INT 80
23751: PUSH
23752: LD_INT 65
23754: PUSH
23755: LD_INT 100
23757: PUSH
23758: EMPTY
23759: LIST
23760: LIST
23761: LIST
23762: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23763: LD_VAR 0 6
23767: PPUSH
23768: CALL_OW 263
23772: PUSH
23773: LD_INT 1
23775: EQUAL
23776: IFFALSE 23811
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23778: LD_ADDR_VAR 0 10
23782: PUSH
23783: LD_VAR 0 10
23787: PUSH
23788: LD_VAR 0 6
23792: PPUSH
23793: CALL_OW 311
23797: PPUSH
23798: LD_INT 3
23800: PPUSH
23801: CALL_OW 259
23805: PUSH
23806: LD_INT 4
23808: MUL
23809: MUL
23810: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23811: LD_VAR 0 6
23815: PPUSH
23816: CALL_OW 263
23820: PUSH
23821: LD_INT 2
23823: EQUAL
23824: IFFALSE 23875
// begin j := IsControledBy ( i ) ;
23826: LD_ADDR_VAR 0 7
23830: PUSH
23831: LD_VAR 0 6
23835: PPUSH
23836: CALL_OW 312
23840: ST_TO_ADDR
// if j then
23841: LD_VAR 0 7
23845: IFFALSE 23875
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23847: LD_ADDR_VAR 0 10
23851: PUSH
23852: LD_VAR 0 10
23856: PUSH
23857: LD_VAR 0 7
23861: PPUSH
23862: LD_INT 3
23864: PPUSH
23865: CALL_OW 259
23869: PUSH
23870: LD_INT 3
23872: MUL
23873: MUL
23874: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23875: LD_VAR 0 6
23879: PPUSH
23880: CALL_OW 264
23884: PUSH
23885: LD_INT 5
23887: PUSH
23888: LD_INT 6
23890: PUSH
23891: LD_INT 46
23893: PUSH
23894: LD_INT 44
23896: PUSH
23897: LD_INT 47
23899: PUSH
23900: LD_INT 45
23902: PUSH
23903: LD_INT 28
23905: PUSH
23906: LD_INT 7
23908: PUSH
23909: LD_INT 27
23911: PUSH
23912: LD_INT 29
23914: PUSH
23915: EMPTY
23916: LIST
23917: LIST
23918: LIST
23919: LIST
23920: LIST
23921: LIST
23922: LIST
23923: LIST
23924: LIST
23925: LIST
23926: IN
23927: PUSH
23928: LD_VAR 0 1
23932: PPUSH
23933: LD_INT 52
23935: PPUSH
23936: CALL_OW 321
23940: PUSH
23941: LD_INT 2
23943: EQUAL
23944: AND
23945: IFFALSE 23962
// bpoints := bpoints * 1.2 ;
23947: LD_ADDR_VAR 0 10
23951: PUSH
23952: LD_VAR 0 10
23956: PUSH
23957: LD_REAL  1.20000000000000E+0000
23960: MUL
23961: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23962: LD_VAR 0 6
23966: PPUSH
23967: CALL_OW 264
23971: PUSH
23972: LD_INT 6
23974: PUSH
23975: LD_INT 46
23977: PUSH
23978: LD_INT 47
23980: PUSH
23981: EMPTY
23982: LIST
23983: LIST
23984: LIST
23985: IN
23986: IFFALSE 24003
// bpoints := bpoints * 1.2 ;
23988: LD_ADDR_VAR 0 10
23992: PUSH
23993: LD_VAR 0 10
23997: PUSH
23998: LD_REAL  1.20000000000000E+0000
24001: MUL
24002: ST_TO_ADDR
// end ; unit_building :
24003: GO 24017
24005: LD_INT 3
24007: DOUBLE
24008: EQUAL
24009: IFTRUE 24013
24011: GO 24016
24013: POP
// ; end ;
24014: GO 24017
24016: POP
// for j = 1 to 3 do
24017: LD_ADDR_VAR 0 7
24021: PUSH
24022: DOUBLE
24023: LD_INT 1
24025: DEC
24026: ST_TO_ADDR
24027: LD_INT 3
24029: PUSH
24030: FOR_TO
24031: IFFALSE 24084
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24033: LD_ADDR_VAR 0 5
24037: PUSH
24038: LD_VAR 0 5
24042: PPUSH
24043: LD_VAR 0 7
24047: PPUSH
24048: LD_VAR 0 5
24052: PUSH
24053: LD_VAR 0 7
24057: ARRAY
24058: PUSH
24059: LD_VAR 0 9
24063: PUSH
24064: LD_VAR 0 7
24068: ARRAY
24069: PUSH
24070: LD_VAR 0 10
24074: MUL
24075: PLUS
24076: PPUSH
24077: CALL_OW 1
24081: ST_TO_ADDR
24082: GO 24030
24084: POP
24085: POP
// end ;
24086: GO 22569
24088: POP
24089: POP
// result := Replace ( result , 4 , tmp ) ;
24090: LD_ADDR_VAR 0 5
24094: PUSH
24095: LD_VAR 0 5
24099: PPUSH
24100: LD_INT 4
24102: PPUSH
24103: LD_VAR 0 8
24107: PPUSH
24108: CALL_OW 1
24112: ST_TO_ADDR
// end ;
24113: LD_VAR 0 5
24117: RET
// export function DangerAtRange ( unit , range ) ; begin
24118: LD_INT 0
24120: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
24121: LD_ADDR_VAR 0 3
24125: PUSH
24126: LD_VAR 0 1
24130: PPUSH
24131: CALL_OW 255
24135: PPUSH
24136: LD_VAR 0 1
24140: PPUSH
24141: CALL_OW 250
24145: PPUSH
24146: LD_VAR 0 1
24150: PPUSH
24151: CALL_OW 251
24155: PPUSH
24156: LD_VAR 0 2
24160: PPUSH
24161: CALL 22421 0 4
24165: ST_TO_ADDR
// end ;
24166: LD_VAR 0 3
24170: RET
// export function DangerInArea ( side , area ) ; begin
24171: LD_INT 0
24173: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24174: LD_ADDR_VAR 0 3
24178: PUSH
24179: LD_VAR 0 2
24183: PPUSH
24184: LD_INT 81
24186: PUSH
24187: LD_VAR 0 1
24191: PUSH
24192: EMPTY
24193: LIST
24194: LIST
24195: PPUSH
24196: CALL_OW 70
24200: ST_TO_ADDR
// end ;
24201: LD_VAR 0 3
24205: RET
// export function IsExtension ( b ) ; begin
24206: LD_INT 0
24208: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24209: LD_ADDR_VAR 0 2
24213: PUSH
24214: LD_VAR 0 1
24218: PUSH
24219: LD_INT 23
24221: PUSH
24222: LD_INT 20
24224: PUSH
24225: LD_INT 22
24227: PUSH
24228: LD_INT 17
24230: PUSH
24231: LD_INT 24
24233: PUSH
24234: LD_INT 21
24236: PUSH
24237: LD_INT 19
24239: PUSH
24240: LD_INT 16
24242: PUSH
24243: LD_INT 25
24245: PUSH
24246: LD_INT 18
24248: PUSH
24249: EMPTY
24250: LIST
24251: LIST
24252: LIST
24253: LIST
24254: LIST
24255: LIST
24256: LIST
24257: LIST
24258: LIST
24259: LIST
24260: IN
24261: ST_TO_ADDR
// end ;
24262: LD_VAR 0 2
24266: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
24267: LD_INT 0
24269: PPUSH
24270: PPUSH
24271: PPUSH
// result := [ ] ;
24272: LD_ADDR_VAR 0 3
24276: PUSH
24277: EMPTY
24278: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24279: LD_ADDR_VAR 0 4
24283: PUSH
24284: LD_VAR 0 2
24288: PPUSH
24289: LD_INT 21
24291: PUSH
24292: LD_INT 3
24294: PUSH
24295: EMPTY
24296: LIST
24297: LIST
24298: PPUSH
24299: CALL_OW 70
24303: ST_TO_ADDR
// if not tmp then
24304: LD_VAR 0 4
24308: NOT
24309: IFFALSE 24313
// exit ;
24311: GO 24371
// for i in tmp do
24313: LD_ADDR_VAR 0 5
24317: PUSH
24318: LD_VAR 0 4
24322: PUSH
24323: FOR_IN
24324: IFFALSE 24359
// if GetBase ( i ) <> base then
24326: LD_VAR 0 5
24330: PPUSH
24331: CALL_OW 274
24335: PUSH
24336: LD_VAR 0 1
24340: NONEQUAL
24341: IFFALSE 24357
// ComLinkToBase ( base , i ) ;
24343: LD_VAR 0 1
24347: PPUSH
24348: LD_VAR 0 5
24352: PPUSH
24353: CALL_OW 169
24357: GO 24323
24359: POP
24360: POP
// result := tmp ;
24361: LD_ADDR_VAR 0 3
24365: PUSH
24366: LD_VAR 0 4
24370: ST_TO_ADDR
// end ;
24371: LD_VAR 0 3
24375: RET
// export function ComComplete ( unit , b ) ; var i ; begin
24376: LD_INT 0
24378: PPUSH
24379: PPUSH
// if BuildingStatus ( b ) = bs_build then
24380: LD_VAR 0 2
24384: PPUSH
24385: CALL_OW 461
24389: PUSH
24390: LD_INT 1
24392: EQUAL
24393: IFFALSE 24453
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24395: LD_VAR 0 1
24399: PPUSH
24400: LD_STRING h
24402: PUSH
24403: LD_VAR 0 2
24407: PPUSH
24408: CALL_OW 250
24412: PUSH
24413: LD_VAR 0 2
24417: PPUSH
24418: CALL_OW 251
24422: PUSH
24423: LD_VAR 0 2
24427: PUSH
24428: LD_INT 0
24430: PUSH
24431: LD_INT 0
24433: PUSH
24434: LD_INT 0
24436: PUSH
24437: EMPTY
24438: LIST
24439: LIST
24440: LIST
24441: LIST
24442: LIST
24443: LIST
24444: LIST
24445: PUSH
24446: EMPTY
24447: LIST
24448: PPUSH
24449: CALL_OW 446
// end ;
24453: LD_VAR 0 3
24457: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24458: LD_INT 0
24460: PPUSH
24461: PPUSH
24462: PPUSH
24463: PPUSH
24464: PPUSH
24465: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
24466: LD_VAR 0 1
24470: NOT
24471: PUSH
24472: LD_VAR 0 1
24476: PPUSH
24477: CALL_OW 263
24481: PUSH
24482: LD_INT 2
24484: EQUAL
24485: NOT
24486: OR
24487: IFFALSE 24491
// exit ;
24489: GO 24807
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24491: LD_ADDR_VAR 0 6
24495: PUSH
24496: LD_INT 22
24498: PUSH
24499: LD_VAR 0 1
24503: PPUSH
24504: CALL_OW 255
24508: PUSH
24509: EMPTY
24510: LIST
24511: LIST
24512: PUSH
24513: LD_INT 2
24515: PUSH
24516: LD_INT 30
24518: PUSH
24519: LD_INT 36
24521: PUSH
24522: EMPTY
24523: LIST
24524: LIST
24525: PUSH
24526: LD_INT 34
24528: PUSH
24529: LD_INT 31
24531: PUSH
24532: EMPTY
24533: LIST
24534: LIST
24535: PUSH
24536: EMPTY
24537: LIST
24538: LIST
24539: LIST
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PPUSH
24545: CALL_OW 69
24549: ST_TO_ADDR
// if not tmp then
24550: LD_VAR 0 6
24554: NOT
24555: IFFALSE 24559
// exit ;
24557: GO 24807
// result := [ ] ;
24559: LD_ADDR_VAR 0 2
24563: PUSH
24564: EMPTY
24565: ST_TO_ADDR
// for i in tmp do
24566: LD_ADDR_VAR 0 3
24570: PUSH
24571: LD_VAR 0 6
24575: PUSH
24576: FOR_IN
24577: IFFALSE 24648
// begin t := UnitsInside ( i ) ;
24579: LD_ADDR_VAR 0 4
24583: PUSH
24584: LD_VAR 0 3
24588: PPUSH
24589: CALL_OW 313
24593: ST_TO_ADDR
// if t then
24594: LD_VAR 0 4
24598: IFFALSE 24646
// for j in t do
24600: LD_ADDR_VAR 0 7
24604: PUSH
24605: LD_VAR 0 4
24609: PUSH
24610: FOR_IN
24611: IFFALSE 24644
// result := Insert ( result , result + 1 , j ) ;
24613: LD_ADDR_VAR 0 2
24617: PUSH
24618: LD_VAR 0 2
24622: PPUSH
24623: LD_VAR 0 2
24627: PUSH
24628: LD_INT 1
24630: PLUS
24631: PPUSH
24632: LD_VAR 0 7
24636: PPUSH
24637: CALL_OW 2
24641: ST_TO_ADDR
24642: GO 24610
24644: POP
24645: POP
// end ;
24646: GO 24576
24648: POP
24649: POP
// if not result then
24650: LD_VAR 0 2
24654: NOT
24655: IFFALSE 24659
// exit ;
24657: GO 24807
// mech := result [ 1 ] ;
24659: LD_ADDR_VAR 0 5
24663: PUSH
24664: LD_VAR 0 2
24668: PUSH
24669: LD_INT 1
24671: ARRAY
24672: ST_TO_ADDR
// if result > 1 then
24673: LD_VAR 0 2
24677: PUSH
24678: LD_INT 1
24680: GREATER
24681: IFFALSE 24793
// for i = 2 to result do
24683: LD_ADDR_VAR 0 3
24687: PUSH
24688: DOUBLE
24689: LD_INT 2
24691: DEC
24692: ST_TO_ADDR
24693: LD_VAR 0 2
24697: PUSH
24698: FOR_TO
24699: IFFALSE 24791
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24701: LD_ADDR_VAR 0 4
24705: PUSH
24706: LD_VAR 0 2
24710: PUSH
24711: LD_VAR 0 3
24715: ARRAY
24716: PPUSH
24717: LD_INT 3
24719: PPUSH
24720: CALL_OW 259
24724: PUSH
24725: LD_VAR 0 2
24729: PUSH
24730: LD_VAR 0 3
24734: ARRAY
24735: PPUSH
24736: CALL_OW 432
24740: MINUS
24741: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24742: LD_VAR 0 4
24746: PUSH
24747: LD_VAR 0 5
24751: PPUSH
24752: LD_INT 3
24754: PPUSH
24755: CALL_OW 259
24759: PUSH
24760: LD_VAR 0 5
24764: PPUSH
24765: CALL_OW 432
24769: MINUS
24770: GREATEREQUAL
24771: IFFALSE 24789
// mech := result [ i ] ;
24773: LD_ADDR_VAR 0 5
24777: PUSH
24778: LD_VAR 0 2
24782: PUSH
24783: LD_VAR 0 3
24787: ARRAY
24788: ST_TO_ADDR
// end ;
24789: GO 24698
24791: POP
24792: POP
// ComLinkTo ( vehicle , mech ) ;
24793: LD_VAR 0 1
24797: PPUSH
24798: LD_VAR 0 5
24802: PPUSH
24803: CALL_OW 135
// end ;
24807: LD_VAR 0 2
24811: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24812: LD_INT 0
24814: PPUSH
24815: PPUSH
24816: PPUSH
24817: PPUSH
24818: PPUSH
24819: PPUSH
24820: PPUSH
24821: PPUSH
24822: PPUSH
24823: PPUSH
24824: PPUSH
24825: PPUSH
24826: PPUSH
// result := [ ] ;
24827: LD_ADDR_VAR 0 7
24831: PUSH
24832: EMPTY
24833: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24834: LD_VAR 0 1
24838: PPUSH
24839: CALL_OW 266
24843: PUSH
24844: LD_INT 0
24846: PUSH
24847: LD_INT 1
24849: PUSH
24850: EMPTY
24851: LIST
24852: LIST
24853: IN
24854: NOT
24855: IFFALSE 24859
// exit ;
24857: GO 26490
// if name then
24859: LD_VAR 0 3
24863: IFFALSE 24879
// SetBName ( base_dep , name ) ;
24865: LD_VAR 0 1
24869: PPUSH
24870: LD_VAR 0 3
24874: PPUSH
24875: CALL_OW 500
// base := GetBase ( base_dep ) ;
24879: LD_ADDR_VAR 0 15
24883: PUSH
24884: LD_VAR 0 1
24888: PPUSH
24889: CALL_OW 274
24893: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24894: LD_ADDR_VAR 0 16
24898: PUSH
24899: LD_VAR 0 1
24903: PPUSH
24904: CALL_OW 255
24908: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24909: LD_ADDR_VAR 0 17
24913: PUSH
24914: LD_VAR 0 1
24918: PPUSH
24919: CALL_OW 248
24923: ST_TO_ADDR
// if sources then
24924: LD_VAR 0 5
24928: IFFALSE 24975
// for i = 1 to 3 do
24930: LD_ADDR_VAR 0 8
24934: PUSH
24935: DOUBLE
24936: LD_INT 1
24938: DEC
24939: ST_TO_ADDR
24940: LD_INT 3
24942: PUSH
24943: FOR_TO
24944: IFFALSE 24973
// AddResourceType ( base , i , sources [ i ] ) ;
24946: LD_VAR 0 15
24950: PPUSH
24951: LD_VAR 0 8
24955: PPUSH
24956: LD_VAR 0 5
24960: PUSH
24961: LD_VAR 0 8
24965: ARRAY
24966: PPUSH
24967: CALL_OW 276
24971: GO 24943
24973: POP
24974: POP
// buildings := GetBaseBuildings ( base , area ) ;
24975: LD_ADDR_VAR 0 18
24979: PUSH
24980: LD_VAR 0 15
24984: PPUSH
24985: LD_VAR 0 2
24989: PPUSH
24990: CALL 24267 0 2
24994: ST_TO_ADDR
// InitHc ;
24995: CALL_OW 19
// InitUc ;
24999: CALL_OW 18
// uc_side := side ;
25003: LD_ADDR_OWVAR 20
25007: PUSH
25008: LD_VAR 0 16
25012: ST_TO_ADDR
// uc_nation := nation ;
25013: LD_ADDR_OWVAR 21
25017: PUSH
25018: LD_VAR 0 17
25022: ST_TO_ADDR
// if buildings then
25023: LD_VAR 0 18
25027: IFFALSE 26349
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25029: LD_ADDR_VAR 0 19
25033: PUSH
25034: LD_VAR 0 18
25038: PPUSH
25039: LD_INT 2
25041: PUSH
25042: LD_INT 30
25044: PUSH
25045: LD_INT 29
25047: PUSH
25048: EMPTY
25049: LIST
25050: LIST
25051: PUSH
25052: LD_INT 30
25054: PUSH
25055: LD_INT 30
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: PUSH
25062: EMPTY
25063: LIST
25064: LIST
25065: LIST
25066: PPUSH
25067: CALL_OW 72
25071: ST_TO_ADDR
// if tmp then
25072: LD_VAR 0 19
25076: IFFALSE 25124
// for i in tmp do
25078: LD_ADDR_VAR 0 8
25082: PUSH
25083: LD_VAR 0 19
25087: PUSH
25088: FOR_IN
25089: IFFALSE 25122
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
25091: LD_VAR 0 8
25095: PPUSH
25096: CALL_OW 250
25100: PPUSH
25101: LD_VAR 0 8
25105: PPUSH
25106: CALL_OW 251
25110: PPUSH
25111: LD_VAR 0 16
25115: PPUSH
25116: CALL_OW 441
25120: GO 25088
25122: POP
25123: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
25124: LD_VAR 0 18
25128: PPUSH
25129: LD_INT 2
25131: PUSH
25132: LD_INT 30
25134: PUSH
25135: LD_INT 32
25137: PUSH
25138: EMPTY
25139: LIST
25140: LIST
25141: PUSH
25142: LD_INT 30
25144: PUSH
25145: LD_INT 33
25147: PUSH
25148: EMPTY
25149: LIST
25150: LIST
25151: PUSH
25152: EMPTY
25153: LIST
25154: LIST
25155: LIST
25156: PPUSH
25157: CALL_OW 72
25161: IFFALSE 25249
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25163: LD_ADDR_VAR 0 8
25167: PUSH
25168: LD_VAR 0 18
25172: PPUSH
25173: LD_INT 2
25175: PUSH
25176: LD_INT 30
25178: PUSH
25179: LD_INT 32
25181: PUSH
25182: EMPTY
25183: LIST
25184: LIST
25185: PUSH
25186: LD_INT 30
25188: PUSH
25189: LD_INT 33
25191: PUSH
25192: EMPTY
25193: LIST
25194: LIST
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: LIST
25200: PPUSH
25201: CALL_OW 72
25205: PUSH
25206: FOR_IN
25207: IFFALSE 25247
// begin if not GetBWeapon ( i ) then
25209: LD_VAR 0 8
25213: PPUSH
25214: CALL_OW 269
25218: NOT
25219: IFFALSE 25245
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25221: LD_VAR 0 8
25225: PPUSH
25226: LD_VAR 0 8
25230: PPUSH
25231: LD_VAR 0 2
25235: PPUSH
25236: CALL 26495 0 2
25240: PPUSH
25241: CALL_OW 431
// end ;
25245: GO 25206
25247: POP
25248: POP
// end ; for i = 1 to personel do
25249: LD_ADDR_VAR 0 8
25253: PUSH
25254: DOUBLE
25255: LD_INT 1
25257: DEC
25258: ST_TO_ADDR
25259: LD_VAR 0 6
25263: PUSH
25264: FOR_TO
25265: IFFALSE 26329
// begin if i > 4 then
25267: LD_VAR 0 8
25271: PUSH
25272: LD_INT 4
25274: GREATER
25275: IFFALSE 25279
// break ;
25277: GO 26329
// case i of 1 :
25279: LD_VAR 0 8
25283: PUSH
25284: LD_INT 1
25286: DOUBLE
25287: EQUAL
25288: IFTRUE 25292
25290: GO 25372
25292: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25293: LD_ADDR_VAR 0 12
25297: PUSH
25298: LD_VAR 0 18
25302: PPUSH
25303: LD_INT 22
25305: PUSH
25306: LD_VAR 0 16
25310: PUSH
25311: EMPTY
25312: LIST
25313: LIST
25314: PUSH
25315: LD_INT 58
25317: PUSH
25318: EMPTY
25319: LIST
25320: PUSH
25321: LD_INT 2
25323: PUSH
25324: LD_INT 30
25326: PUSH
25327: LD_INT 32
25329: PUSH
25330: EMPTY
25331: LIST
25332: LIST
25333: PUSH
25334: LD_INT 30
25336: PUSH
25337: LD_INT 4
25339: PUSH
25340: EMPTY
25341: LIST
25342: LIST
25343: PUSH
25344: LD_INT 30
25346: PUSH
25347: LD_INT 5
25349: PUSH
25350: EMPTY
25351: LIST
25352: LIST
25353: PUSH
25354: EMPTY
25355: LIST
25356: LIST
25357: LIST
25358: LIST
25359: PUSH
25360: EMPTY
25361: LIST
25362: LIST
25363: LIST
25364: PPUSH
25365: CALL_OW 72
25369: ST_TO_ADDR
25370: GO 25594
25372: LD_INT 2
25374: DOUBLE
25375: EQUAL
25376: IFTRUE 25380
25378: GO 25442
25380: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25381: LD_ADDR_VAR 0 12
25385: PUSH
25386: LD_VAR 0 18
25390: PPUSH
25391: LD_INT 22
25393: PUSH
25394: LD_VAR 0 16
25398: PUSH
25399: EMPTY
25400: LIST
25401: LIST
25402: PUSH
25403: LD_INT 2
25405: PUSH
25406: LD_INT 30
25408: PUSH
25409: LD_INT 0
25411: PUSH
25412: EMPTY
25413: LIST
25414: LIST
25415: PUSH
25416: LD_INT 30
25418: PUSH
25419: LD_INT 1
25421: PUSH
25422: EMPTY
25423: LIST
25424: LIST
25425: PUSH
25426: EMPTY
25427: LIST
25428: LIST
25429: LIST
25430: PUSH
25431: EMPTY
25432: LIST
25433: LIST
25434: PPUSH
25435: CALL_OW 72
25439: ST_TO_ADDR
25440: GO 25594
25442: LD_INT 3
25444: DOUBLE
25445: EQUAL
25446: IFTRUE 25450
25448: GO 25512
25450: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25451: LD_ADDR_VAR 0 12
25455: PUSH
25456: LD_VAR 0 18
25460: PPUSH
25461: LD_INT 22
25463: PUSH
25464: LD_VAR 0 16
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: PUSH
25473: LD_INT 2
25475: PUSH
25476: LD_INT 30
25478: PUSH
25479: LD_INT 2
25481: PUSH
25482: EMPTY
25483: LIST
25484: LIST
25485: PUSH
25486: LD_INT 30
25488: PUSH
25489: LD_INT 3
25491: PUSH
25492: EMPTY
25493: LIST
25494: LIST
25495: PUSH
25496: EMPTY
25497: LIST
25498: LIST
25499: LIST
25500: PUSH
25501: EMPTY
25502: LIST
25503: LIST
25504: PPUSH
25505: CALL_OW 72
25509: ST_TO_ADDR
25510: GO 25594
25512: LD_INT 4
25514: DOUBLE
25515: EQUAL
25516: IFTRUE 25520
25518: GO 25593
25520: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25521: LD_ADDR_VAR 0 12
25525: PUSH
25526: LD_VAR 0 18
25530: PPUSH
25531: LD_INT 22
25533: PUSH
25534: LD_VAR 0 16
25538: PUSH
25539: EMPTY
25540: LIST
25541: LIST
25542: PUSH
25543: LD_INT 2
25545: PUSH
25546: LD_INT 30
25548: PUSH
25549: LD_INT 6
25551: PUSH
25552: EMPTY
25553: LIST
25554: LIST
25555: PUSH
25556: LD_INT 30
25558: PUSH
25559: LD_INT 7
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: PUSH
25566: LD_INT 30
25568: PUSH
25569: LD_INT 8
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: LIST
25580: LIST
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PPUSH
25586: CALL_OW 72
25590: ST_TO_ADDR
25591: GO 25594
25593: POP
// if i = 1 then
25594: LD_VAR 0 8
25598: PUSH
25599: LD_INT 1
25601: EQUAL
25602: IFFALSE 25713
// begin tmp := [ ] ;
25604: LD_ADDR_VAR 0 19
25608: PUSH
25609: EMPTY
25610: ST_TO_ADDR
// for j in f do
25611: LD_ADDR_VAR 0 9
25615: PUSH
25616: LD_VAR 0 12
25620: PUSH
25621: FOR_IN
25622: IFFALSE 25695
// if GetBType ( j ) = b_bunker then
25624: LD_VAR 0 9
25628: PPUSH
25629: CALL_OW 266
25633: PUSH
25634: LD_INT 32
25636: EQUAL
25637: IFFALSE 25664
// tmp := Insert ( tmp , 1 , j ) else
25639: LD_ADDR_VAR 0 19
25643: PUSH
25644: LD_VAR 0 19
25648: PPUSH
25649: LD_INT 1
25651: PPUSH
25652: LD_VAR 0 9
25656: PPUSH
25657: CALL_OW 2
25661: ST_TO_ADDR
25662: GO 25693
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25664: LD_ADDR_VAR 0 19
25668: PUSH
25669: LD_VAR 0 19
25673: PPUSH
25674: LD_VAR 0 19
25678: PUSH
25679: LD_INT 1
25681: PLUS
25682: PPUSH
25683: LD_VAR 0 9
25687: PPUSH
25688: CALL_OW 2
25692: ST_TO_ADDR
25693: GO 25621
25695: POP
25696: POP
// if tmp then
25697: LD_VAR 0 19
25701: IFFALSE 25713
// f := tmp ;
25703: LD_ADDR_VAR 0 12
25707: PUSH
25708: LD_VAR 0 19
25712: ST_TO_ADDR
// end ; x := personel [ i ] ;
25713: LD_ADDR_VAR 0 13
25717: PUSH
25718: LD_VAR 0 6
25722: PUSH
25723: LD_VAR 0 8
25727: ARRAY
25728: ST_TO_ADDR
// if x = - 1 then
25729: LD_VAR 0 13
25733: PUSH
25734: LD_INT 1
25736: NEG
25737: EQUAL
25738: IFFALSE 25947
// begin for j in f do
25740: LD_ADDR_VAR 0 9
25744: PUSH
25745: LD_VAR 0 12
25749: PUSH
25750: FOR_IN
25751: IFFALSE 25943
// repeat InitHc ;
25753: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25757: LD_VAR 0 9
25761: PPUSH
25762: CALL_OW 266
25766: PUSH
25767: LD_INT 5
25769: EQUAL
25770: IFFALSE 25840
// begin if UnitsInside ( j ) < 3 then
25772: LD_VAR 0 9
25776: PPUSH
25777: CALL_OW 313
25781: PUSH
25782: LD_INT 3
25784: LESS
25785: IFFALSE 25821
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25787: LD_INT 0
25789: PPUSH
25790: LD_INT 5
25792: PUSH
25793: LD_INT 8
25795: PUSH
25796: LD_INT 9
25798: PUSH
25799: EMPTY
25800: LIST
25801: LIST
25802: LIST
25803: PUSH
25804: LD_VAR 0 17
25808: ARRAY
25809: PPUSH
25810: LD_VAR 0 4
25814: PPUSH
25815: CALL_OW 380
25819: GO 25838
// PrepareHuman ( false , i , skill ) ;
25821: LD_INT 0
25823: PPUSH
25824: LD_VAR 0 8
25828: PPUSH
25829: LD_VAR 0 4
25833: PPUSH
25834: CALL_OW 380
// end else
25838: GO 25857
// PrepareHuman ( false , i , skill ) ;
25840: LD_INT 0
25842: PPUSH
25843: LD_VAR 0 8
25847: PPUSH
25848: LD_VAR 0 4
25852: PPUSH
25853: CALL_OW 380
// un := CreateHuman ;
25857: LD_ADDR_VAR 0 14
25861: PUSH
25862: CALL_OW 44
25866: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25867: LD_ADDR_VAR 0 7
25871: PUSH
25872: LD_VAR 0 7
25876: PPUSH
25877: LD_INT 1
25879: PPUSH
25880: LD_VAR 0 14
25884: PPUSH
25885: CALL_OW 2
25889: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25890: LD_VAR 0 14
25894: PPUSH
25895: LD_VAR 0 9
25899: PPUSH
25900: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25904: LD_VAR 0 9
25908: PPUSH
25909: CALL_OW 313
25913: PUSH
25914: LD_INT 6
25916: EQUAL
25917: PUSH
25918: LD_VAR 0 9
25922: PPUSH
25923: CALL_OW 266
25927: PUSH
25928: LD_INT 32
25930: PUSH
25931: LD_INT 31
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: IN
25938: OR
25939: IFFALSE 25753
25941: GO 25750
25943: POP
25944: POP
// end else
25945: GO 26327
// for j = 1 to x do
25947: LD_ADDR_VAR 0 9
25951: PUSH
25952: DOUBLE
25953: LD_INT 1
25955: DEC
25956: ST_TO_ADDR
25957: LD_VAR 0 13
25961: PUSH
25962: FOR_TO
25963: IFFALSE 26325
// begin InitHc ;
25965: CALL_OW 19
// if not f then
25969: LD_VAR 0 12
25973: NOT
25974: IFFALSE 26063
// begin PrepareHuman ( false , i , skill ) ;
25976: LD_INT 0
25978: PPUSH
25979: LD_VAR 0 8
25983: PPUSH
25984: LD_VAR 0 4
25988: PPUSH
25989: CALL_OW 380
// un := CreateHuman ;
25993: LD_ADDR_VAR 0 14
25997: PUSH
25998: CALL_OW 44
26002: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26003: LD_ADDR_VAR 0 7
26007: PUSH
26008: LD_VAR 0 7
26012: PPUSH
26013: LD_INT 1
26015: PPUSH
26016: LD_VAR 0 14
26020: PPUSH
26021: CALL_OW 2
26025: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26026: LD_VAR 0 14
26030: PPUSH
26031: LD_VAR 0 1
26035: PPUSH
26036: CALL_OW 250
26040: PPUSH
26041: LD_VAR 0 1
26045: PPUSH
26046: CALL_OW 251
26050: PPUSH
26051: LD_INT 10
26053: PPUSH
26054: LD_INT 0
26056: PPUSH
26057: CALL_OW 50
// continue ;
26061: GO 25962
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26063: LD_VAR 0 12
26067: PUSH
26068: LD_INT 1
26070: ARRAY
26071: PPUSH
26072: CALL_OW 313
26076: PUSH
26077: LD_VAR 0 12
26081: PUSH
26082: LD_INT 1
26084: ARRAY
26085: PPUSH
26086: CALL_OW 266
26090: PUSH
26091: LD_INT 32
26093: PUSH
26094: LD_INT 31
26096: PUSH
26097: EMPTY
26098: LIST
26099: LIST
26100: IN
26101: AND
26102: PUSH
26103: LD_VAR 0 12
26107: PUSH
26108: LD_INT 1
26110: ARRAY
26111: PPUSH
26112: CALL_OW 313
26116: PUSH
26117: LD_INT 6
26119: EQUAL
26120: OR
26121: IFFALSE 26141
// f := Delete ( f , 1 ) ;
26123: LD_ADDR_VAR 0 12
26127: PUSH
26128: LD_VAR 0 12
26132: PPUSH
26133: LD_INT 1
26135: PPUSH
26136: CALL_OW 3
26140: ST_TO_ADDR
// if not f then
26141: LD_VAR 0 12
26145: NOT
26146: IFFALSE 26164
// begin x := x + 2 ;
26148: LD_ADDR_VAR 0 13
26152: PUSH
26153: LD_VAR 0 13
26157: PUSH
26158: LD_INT 2
26160: PLUS
26161: ST_TO_ADDR
// continue ;
26162: GO 25962
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26164: LD_VAR 0 12
26168: PUSH
26169: LD_INT 1
26171: ARRAY
26172: PPUSH
26173: CALL_OW 266
26177: PUSH
26178: LD_INT 5
26180: EQUAL
26181: IFFALSE 26255
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26183: LD_VAR 0 12
26187: PUSH
26188: LD_INT 1
26190: ARRAY
26191: PPUSH
26192: CALL_OW 313
26196: PUSH
26197: LD_INT 3
26199: LESS
26200: IFFALSE 26236
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26202: LD_INT 0
26204: PPUSH
26205: LD_INT 5
26207: PUSH
26208: LD_INT 8
26210: PUSH
26211: LD_INT 9
26213: PUSH
26214: EMPTY
26215: LIST
26216: LIST
26217: LIST
26218: PUSH
26219: LD_VAR 0 17
26223: ARRAY
26224: PPUSH
26225: LD_VAR 0 4
26229: PPUSH
26230: CALL_OW 380
26234: GO 26253
// PrepareHuman ( false , i , skill ) ;
26236: LD_INT 0
26238: PPUSH
26239: LD_VAR 0 8
26243: PPUSH
26244: LD_VAR 0 4
26248: PPUSH
26249: CALL_OW 380
// end else
26253: GO 26272
// PrepareHuman ( false , i , skill ) ;
26255: LD_INT 0
26257: PPUSH
26258: LD_VAR 0 8
26262: PPUSH
26263: LD_VAR 0 4
26267: PPUSH
26268: CALL_OW 380
// un := CreateHuman ;
26272: LD_ADDR_VAR 0 14
26276: PUSH
26277: CALL_OW 44
26281: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26282: LD_ADDR_VAR 0 7
26286: PUSH
26287: LD_VAR 0 7
26291: PPUSH
26292: LD_INT 1
26294: PPUSH
26295: LD_VAR 0 14
26299: PPUSH
26300: CALL_OW 2
26304: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26305: LD_VAR 0 14
26309: PPUSH
26310: LD_VAR 0 12
26314: PUSH
26315: LD_INT 1
26317: ARRAY
26318: PPUSH
26319: CALL_OW 52
// end ;
26323: GO 25962
26325: POP
26326: POP
// end ;
26327: GO 25264
26329: POP
26330: POP
// result := result ^ buildings ;
26331: LD_ADDR_VAR 0 7
26335: PUSH
26336: LD_VAR 0 7
26340: PUSH
26341: LD_VAR 0 18
26345: ADD
26346: ST_TO_ADDR
// end else
26347: GO 26490
// begin for i = 1 to personel do
26349: LD_ADDR_VAR 0 8
26353: PUSH
26354: DOUBLE
26355: LD_INT 1
26357: DEC
26358: ST_TO_ADDR
26359: LD_VAR 0 6
26363: PUSH
26364: FOR_TO
26365: IFFALSE 26488
// begin if i > 4 then
26367: LD_VAR 0 8
26371: PUSH
26372: LD_INT 4
26374: GREATER
26375: IFFALSE 26379
// break ;
26377: GO 26488
// x := personel [ i ] ;
26379: LD_ADDR_VAR 0 13
26383: PUSH
26384: LD_VAR 0 6
26388: PUSH
26389: LD_VAR 0 8
26393: ARRAY
26394: ST_TO_ADDR
// if x = - 1 then
26395: LD_VAR 0 13
26399: PUSH
26400: LD_INT 1
26402: NEG
26403: EQUAL
26404: IFFALSE 26408
// continue ;
26406: GO 26364
// PrepareHuman ( false , i , skill ) ;
26408: LD_INT 0
26410: PPUSH
26411: LD_VAR 0 8
26415: PPUSH
26416: LD_VAR 0 4
26420: PPUSH
26421: CALL_OW 380
// un := CreateHuman ;
26425: LD_ADDR_VAR 0 14
26429: PUSH
26430: CALL_OW 44
26434: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26435: LD_VAR 0 14
26439: PPUSH
26440: LD_VAR 0 1
26444: PPUSH
26445: CALL_OW 250
26449: PPUSH
26450: LD_VAR 0 1
26454: PPUSH
26455: CALL_OW 251
26459: PPUSH
26460: LD_INT 10
26462: PPUSH
26463: LD_INT 0
26465: PPUSH
26466: CALL_OW 50
// result := result ^ un ;
26470: LD_ADDR_VAR 0 7
26474: PUSH
26475: LD_VAR 0 7
26479: PUSH
26480: LD_VAR 0 14
26484: ADD
26485: ST_TO_ADDR
// end ;
26486: GO 26364
26488: POP
26489: POP
// end ; end ;
26490: LD_VAR 0 7
26494: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26495: LD_INT 0
26497: PPUSH
26498: PPUSH
26499: PPUSH
26500: PPUSH
26501: PPUSH
26502: PPUSH
26503: PPUSH
26504: PPUSH
26505: PPUSH
26506: PPUSH
26507: PPUSH
26508: PPUSH
26509: PPUSH
26510: PPUSH
26511: PPUSH
26512: PPUSH
// result := false ;
26513: LD_ADDR_VAR 0 3
26517: PUSH
26518: LD_INT 0
26520: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26521: LD_VAR 0 1
26525: NOT
26526: PUSH
26527: LD_VAR 0 1
26531: PPUSH
26532: CALL_OW 266
26536: PUSH
26537: LD_INT 32
26539: PUSH
26540: LD_INT 33
26542: PUSH
26543: EMPTY
26544: LIST
26545: LIST
26546: IN
26547: NOT
26548: OR
26549: IFFALSE 26553
// exit ;
26551: GO 27689
// nat := GetNation ( tower ) ;
26553: LD_ADDR_VAR 0 12
26557: PUSH
26558: LD_VAR 0 1
26562: PPUSH
26563: CALL_OW 248
26567: ST_TO_ADDR
// side := GetSide ( tower ) ;
26568: LD_ADDR_VAR 0 16
26572: PUSH
26573: LD_VAR 0 1
26577: PPUSH
26578: CALL_OW 255
26582: ST_TO_ADDR
// x := GetX ( tower ) ;
26583: LD_ADDR_VAR 0 10
26587: PUSH
26588: LD_VAR 0 1
26592: PPUSH
26593: CALL_OW 250
26597: ST_TO_ADDR
// y := GetY ( tower ) ;
26598: LD_ADDR_VAR 0 11
26602: PUSH
26603: LD_VAR 0 1
26607: PPUSH
26608: CALL_OW 251
26612: ST_TO_ADDR
// if not x or not y then
26613: LD_VAR 0 10
26617: NOT
26618: PUSH
26619: LD_VAR 0 11
26623: NOT
26624: OR
26625: IFFALSE 26629
// exit ;
26627: GO 27689
// weapon := 0 ;
26629: LD_ADDR_VAR 0 18
26633: PUSH
26634: LD_INT 0
26636: ST_TO_ADDR
// fac_list := [ ] ;
26637: LD_ADDR_VAR 0 17
26641: PUSH
26642: EMPTY
26643: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
26644: LD_ADDR_VAR 0 6
26648: PUSH
26649: LD_VAR 0 1
26653: PPUSH
26654: CALL_OW 274
26658: PPUSH
26659: LD_VAR 0 2
26663: PPUSH
26664: CALL 24267 0 2
26668: PPUSH
26669: LD_INT 30
26671: PUSH
26672: LD_INT 3
26674: PUSH
26675: EMPTY
26676: LIST
26677: LIST
26678: PPUSH
26679: CALL_OW 72
26683: ST_TO_ADDR
// if not factories then
26684: LD_VAR 0 6
26688: NOT
26689: IFFALSE 26693
// exit ;
26691: GO 27689
// for i in factories do
26693: LD_ADDR_VAR 0 8
26697: PUSH
26698: LD_VAR 0 6
26702: PUSH
26703: FOR_IN
26704: IFFALSE 26729
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26706: LD_ADDR_VAR 0 17
26710: PUSH
26711: LD_VAR 0 17
26715: PUSH
26716: LD_VAR 0 8
26720: PPUSH
26721: CALL_OW 478
26725: UNION
26726: ST_TO_ADDR
26727: GO 26703
26729: POP
26730: POP
// if not fac_list then
26731: LD_VAR 0 17
26735: NOT
26736: IFFALSE 26740
// exit ;
26738: GO 27689
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26740: LD_ADDR_VAR 0 5
26744: PUSH
26745: LD_INT 4
26747: PUSH
26748: LD_INT 5
26750: PUSH
26751: LD_INT 9
26753: PUSH
26754: LD_INT 10
26756: PUSH
26757: LD_INT 6
26759: PUSH
26760: LD_INT 7
26762: PUSH
26763: LD_INT 11
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: LIST
26770: LIST
26771: LIST
26772: LIST
26773: LIST
26774: PUSH
26775: LD_INT 27
26777: PUSH
26778: LD_INT 28
26780: PUSH
26781: LD_INT 26
26783: PUSH
26784: LD_INT 30
26786: PUSH
26787: EMPTY
26788: LIST
26789: LIST
26790: LIST
26791: LIST
26792: PUSH
26793: LD_INT 43
26795: PUSH
26796: LD_INT 44
26798: PUSH
26799: LD_INT 46
26801: PUSH
26802: LD_INT 45
26804: PUSH
26805: LD_INT 47
26807: PUSH
26808: LD_INT 49
26810: PUSH
26811: EMPTY
26812: LIST
26813: LIST
26814: LIST
26815: LIST
26816: LIST
26817: LIST
26818: PUSH
26819: EMPTY
26820: LIST
26821: LIST
26822: LIST
26823: PUSH
26824: LD_VAR 0 12
26828: ARRAY
26829: ST_TO_ADDR
// for i in list do
26830: LD_ADDR_VAR 0 8
26834: PUSH
26835: LD_VAR 0 5
26839: PUSH
26840: FOR_IN
26841: IFFALSE 26874
// if not i in fac_list then
26843: LD_VAR 0 8
26847: PUSH
26848: LD_VAR 0 17
26852: IN
26853: NOT
26854: IFFALSE 26872
// list := list diff i ;
26856: LD_ADDR_VAR 0 5
26860: PUSH
26861: LD_VAR 0 5
26865: PUSH
26866: LD_VAR 0 8
26870: DIFF
26871: ST_TO_ADDR
26872: GO 26840
26874: POP
26875: POP
// if not list then
26876: LD_VAR 0 5
26880: NOT
26881: IFFALSE 26885
// exit ;
26883: GO 27689
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26885: LD_VAR 0 12
26889: PUSH
26890: LD_INT 3
26892: EQUAL
26893: PUSH
26894: LD_INT 49
26896: PUSH
26897: LD_VAR 0 5
26901: IN
26902: AND
26903: PUSH
26904: LD_INT 31
26906: PPUSH
26907: LD_VAR 0 16
26911: PPUSH
26912: CALL_OW 321
26916: PUSH
26917: LD_INT 2
26919: EQUAL
26920: AND
26921: IFFALSE 26981
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26923: LD_INT 22
26925: PUSH
26926: LD_VAR 0 16
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PUSH
26935: LD_INT 35
26937: PUSH
26938: LD_INT 49
26940: PUSH
26941: EMPTY
26942: LIST
26943: LIST
26944: PUSH
26945: LD_INT 91
26947: PUSH
26948: LD_VAR 0 1
26952: PUSH
26953: LD_INT 10
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: LIST
26960: PUSH
26961: EMPTY
26962: LIST
26963: LIST
26964: LIST
26965: PPUSH
26966: CALL_OW 69
26970: NOT
26971: IFFALSE 26981
// weapon := ru_time_lapser ;
26973: LD_ADDR_VAR 0 18
26977: PUSH
26978: LD_INT 49
26980: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26981: LD_VAR 0 12
26985: PUSH
26986: LD_INT 1
26988: PUSH
26989: LD_INT 2
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: IN
26996: PUSH
26997: LD_INT 11
26999: PUSH
27000: LD_VAR 0 5
27004: IN
27005: PUSH
27006: LD_INT 30
27008: PUSH
27009: LD_VAR 0 5
27013: IN
27014: OR
27015: AND
27016: PUSH
27017: LD_INT 6
27019: PPUSH
27020: LD_VAR 0 16
27024: PPUSH
27025: CALL_OW 321
27029: PUSH
27030: LD_INT 2
27032: EQUAL
27033: AND
27034: IFFALSE 27199
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27036: LD_INT 22
27038: PUSH
27039: LD_VAR 0 16
27043: PUSH
27044: EMPTY
27045: LIST
27046: LIST
27047: PUSH
27048: LD_INT 2
27050: PUSH
27051: LD_INT 35
27053: PUSH
27054: LD_INT 11
27056: PUSH
27057: EMPTY
27058: LIST
27059: LIST
27060: PUSH
27061: LD_INT 35
27063: PUSH
27064: LD_INT 30
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: LIST
27075: PUSH
27076: LD_INT 91
27078: PUSH
27079: LD_VAR 0 1
27083: PUSH
27084: LD_INT 18
27086: PUSH
27087: EMPTY
27088: LIST
27089: LIST
27090: LIST
27091: PUSH
27092: EMPTY
27093: LIST
27094: LIST
27095: LIST
27096: PPUSH
27097: CALL_OW 69
27101: NOT
27102: PUSH
27103: LD_INT 22
27105: PUSH
27106: LD_VAR 0 16
27110: PUSH
27111: EMPTY
27112: LIST
27113: LIST
27114: PUSH
27115: LD_INT 2
27117: PUSH
27118: LD_INT 30
27120: PUSH
27121: LD_INT 32
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PUSH
27128: LD_INT 30
27130: PUSH
27131: LD_INT 33
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: PUSH
27138: EMPTY
27139: LIST
27140: LIST
27141: LIST
27142: PUSH
27143: LD_INT 91
27145: PUSH
27146: LD_VAR 0 1
27150: PUSH
27151: LD_INT 12
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: LIST
27158: PUSH
27159: EMPTY
27160: LIST
27161: LIST
27162: LIST
27163: PUSH
27164: EMPTY
27165: LIST
27166: PPUSH
27167: CALL_OW 69
27171: PUSH
27172: LD_INT 2
27174: GREATER
27175: AND
27176: IFFALSE 27199
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27178: LD_ADDR_VAR 0 18
27182: PUSH
27183: LD_INT 11
27185: PUSH
27186: LD_INT 30
27188: PUSH
27189: EMPTY
27190: LIST
27191: LIST
27192: PUSH
27193: LD_VAR 0 12
27197: ARRAY
27198: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27199: LD_VAR 0 18
27203: NOT
27204: PUSH
27205: LD_INT 40
27207: PPUSH
27208: LD_VAR 0 16
27212: PPUSH
27213: CALL_OW 321
27217: PUSH
27218: LD_INT 2
27220: EQUAL
27221: AND
27222: PUSH
27223: LD_INT 7
27225: PUSH
27226: LD_VAR 0 5
27230: IN
27231: PUSH
27232: LD_INT 28
27234: PUSH
27235: LD_VAR 0 5
27239: IN
27240: OR
27241: PUSH
27242: LD_INT 45
27244: PUSH
27245: LD_VAR 0 5
27249: IN
27250: OR
27251: AND
27252: IFFALSE 27506
// begin hex := GetHexInfo ( x , y ) ;
27254: LD_ADDR_VAR 0 4
27258: PUSH
27259: LD_VAR 0 10
27263: PPUSH
27264: LD_VAR 0 11
27268: PPUSH
27269: CALL_OW 546
27273: ST_TO_ADDR
// if hex [ 1 ] then
27274: LD_VAR 0 4
27278: PUSH
27279: LD_INT 1
27281: ARRAY
27282: IFFALSE 27286
// exit ;
27284: GO 27689
// height := hex [ 2 ] ;
27286: LD_ADDR_VAR 0 15
27290: PUSH
27291: LD_VAR 0 4
27295: PUSH
27296: LD_INT 2
27298: ARRAY
27299: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27300: LD_ADDR_VAR 0 14
27304: PUSH
27305: LD_INT 0
27307: PUSH
27308: LD_INT 2
27310: PUSH
27311: LD_INT 3
27313: PUSH
27314: LD_INT 5
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: LIST
27321: LIST
27322: ST_TO_ADDR
// for i in tmp do
27323: LD_ADDR_VAR 0 8
27327: PUSH
27328: LD_VAR 0 14
27332: PUSH
27333: FOR_IN
27334: IFFALSE 27504
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27336: LD_ADDR_VAR 0 9
27340: PUSH
27341: LD_VAR 0 10
27345: PPUSH
27346: LD_VAR 0 8
27350: PPUSH
27351: LD_INT 5
27353: PPUSH
27354: CALL_OW 272
27358: PUSH
27359: LD_VAR 0 11
27363: PPUSH
27364: LD_VAR 0 8
27368: PPUSH
27369: LD_INT 5
27371: PPUSH
27372: CALL_OW 273
27376: PUSH
27377: EMPTY
27378: LIST
27379: LIST
27380: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27381: LD_VAR 0 9
27385: PUSH
27386: LD_INT 1
27388: ARRAY
27389: PPUSH
27390: LD_VAR 0 9
27394: PUSH
27395: LD_INT 2
27397: ARRAY
27398: PPUSH
27399: CALL_OW 488
27403: IFFALSE 27502
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27405: LD_ADDR_VAR 0 4
27409: PUSH
27410: LD_VAR 0 9
27414: PUSH
27415: LD_INT 1
27417: ARRAY
27418: PPUSH
27419: LD_VAR 0 9
27423: PUSH
27424: LD_INT 2
27426: ARRAY
27427: PPUSH
27428: CALL_OW 546
27432: ST_TO_ADDR
// if hex [ 1 ] then
27433: LD_VAR 0 4
27437: PUSH
27438: LD_INT 1
27440: ARRAY
27441: IFFALSE 27445
// continue ;
27443: GO 27333
// h := hex [ 2 ] ;
27445: LD_ADDR_VAR 0 13
27449: PUSH
27450: LD_VAR 0 4
27454: PUSH
27455: LD_INT 2
27457: ARRAY
27458: ST_TO_ADDR
// if h + 7 < height then
27459: LD_VAR 0 13
27463: PUSH
27464: LD_INT 7
27466: PLUS
27467: PUSH
27468: LD_VAR 0 15
27472: LESS
27473: IFFALSE 27502
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27475: LD_ADDR_VAR 0 18
27479: PUSH
27480: LD_INT 7
27482: PUSH
27483: LD_INT 28
27485: PUSH
27486: LD_INT 45
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: LIST
27493: PUSH
27494: LD_VAR 0 12
27498: ARRAY
27499: ST_TO_ADDR
// break ;
27500: GO 27504
// end ; end ; end ;
27502: GO 27333
27504: POP
27505: POP
// end ; if not weapon then
27506: LD_VAR 0 18
27510: NOT
27511: IFFALSE 27571
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27513: LD_ADDR_VAR 0 5
27517: PUSH
27518: LD_VAR 0 5
27522: PUSH
27523: LD_INT 11
27525: PUSH
27526: LD_INT 30
27528: PUSH
27529: LD_INT 49
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: LIST
27536: DIFF
27537: ST_TO_ADDR
// if not list then
27538: LD_VAR 0 5
27542: NOT
27543: IFFALSE 27547
// exit ;
27545: GO 27689
// weapon := list [ rand ( 1 , list ) ] ;
27547: LD_ADDR_VAR 0 18
27551: PUSH
27552: LD_VAR 0 5
27556: PUSH
27557: LD_INT 1
27559: PPUSH
27560: LD_VAR 0 5
27564: PPUSH
27565: CALL_OW 12
27569: ARRAY
27570: ST_TO_ADDR
// end ; if weapon then
27571: LD_VAR 0 18
27575: IFFALSE 27689
// begin tmp := CostOfWeapon ( weapon ) ;
27577: LD_ADDR_VAR 0 14
27581: PUSH
27582: LD_VAR 0 18
27586: PPUSH
27587: CALL_OW 451
27591: ST_TO_ADDR
// j := GetBase ( tower ) ;
27592: LD_ADDR_VAR 0 9
27596: PUSH
27597: LD_VAR 0 1
27601: PPUSH
27602: CALL_OW 274
27606: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27607: LD_VAR 0 9
27611: PPUSH
27612: LD_INT 1
27614: PPUSH
27615: CALL_OW 275
27619: PUSH
27620: LD_VAR 0 14
27624: PUSH
27625: LD_INT 1
27627: ARRAY
27628: GREATEREQUAL
27629: PUSH
27630: LD_VAR 0 9
27634: PPUSH
27635: LD_INT 2
27637: PPUSH
27638: CALL_OW 275
27642: PUSH
27643: LD_VAR 0 14
27647: PUSH
27648: LD_INT 2
27650: ARRAY
27651: GREATEREQUAL
27652: AND
27653: PUSH
27654: LD_VAR 0 9
27658: PPUSH
27659: LD_INT 3
27661: PPUSH
27662: CALL_OW 275
27666: PUSH
27667: LD_VAR 0 14
27671: PUSH
27672: LD_INT 3
27674: ARRAY
27675: GREATEREQUAL
27676: AND
27677: IFFALSE 27689
// result := weapon ;
27679: LD_ADDR_VAR 0 3
27683: PUSH
27684: LD_VAR 0 18
27688: ST_TO_ADDR
// end ; end ;
27689: LD_VAR 0 3
27693: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27694: LD_INT 0
27696: PPUSH
27697: PPUSH
// result := true ;
27698: LD_ADDR_VAR 0 3
27702: PUSH
27703: LD_INT 1
27705: ST_TO_ADDR
// if array1 = array2 then
27706: LD_VAR 0 1
27710: PUSH
27711: LD_VAR 0 2
27715: EQUAL
27716: IFFALSE 27776
// begin for i = 1 to array1 do
27718: LD_ADDR_VAR 0 4
27722: PUSH
27723: DOUBLE
27724: LD_INT 1
27726: DEC
27727: ST_TO_ADDR
27728: LD_VAR 0 1
27732: PUSH
27733: FOR_TO
27734: IFFALSE 27772
// if array1 [ i ] <> array2 [ i ] then
27736: LD_VAR 0 1
27740: PUSH
27741: LD_VAR 0 4
27745: ARRAY
27746: PUSH
27747: LD_VAR 0 2
27751: PUSH
27752: LD_VAR 0 4
27756: ARRAY
27757: NONEQUAL
27758: IFFALSE 27770
// begin result := false ;
27760: LD_ADDR_VAR 0 3
27764: PUSH
27765: LD_INT 0
27767: ST_TO_ADDR
// break ;
27768: GO 27772
// end ;
27770: GO 27733
27772: POP
27773: POP
// end else
27774: GO 27784
// result := false ;
27776: LD_ADDR_VAR 0 3
27780: PUSH
27781: LD_INT 0
27783: ST_TO_ADDR
// end ;
27784: LD_VAR 0 3
27788: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27789: LD_INT 0
27791: PPUSH
27792: PPUSH
27793: PPUSH
// pom := GetBase ( fac ) ;
27794: LD_ADDR_VAR 0 5
27798: PUSH
27799: LD_VAR 0 1
27803: PPUSH
27804: CALL_OW 274
27808: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27809: LD_ADDR_VAR 0 4
27813: PUSH
27814: LD_VAR 0 2
27818: PUSH
27819: LD_INT 1
27821: ARRAY
27822: PPUSH
27823: LD_VAR 0 2
27827: PUSH
27828: LD_INT 2
27830: ARRAY
27831: PPUSH
27832: LD_VAR 0 2
27836: PUSH
27837: LD_INT 3
27839: ARRAY
27840: PPUSH
27841: LD_VAR 0 2
27845: PUSH
27846: LD_INT 4
27848: ARRAY
27849: PPUSH
27850: CALL_OW 449
27854: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27855: LD_ADDR_VAR 0 3
27859: PUSH
27860: LD_VAR 0 5
27864: PPUSH
27865: LD_INT 1
27867: PPUSH
27868: CALL_OW 275
27872: PUSH
27873: LD_VAR 0 4
27877: PUSH
27878: LD_INT 1
27880: ARRAY
27881: GREATEREQUAL
27882: PUSH
27883: LD_VAR 0 5
27887: PPUSH
27888: LD_INT 2
27890: PPUSH
27891: CALL_OW 275
27895: PUSH
27896: LD_VAR 0 4
27900: PUSH
27901: LD_INT 2
27903: ARRAY
27904: GREATEREQUAL
27905: AND
27906: PUSH
27907: LD_VAR 0 5
27911: PPUSH
27912: LD_INT 3
27914: PPUSH
27915: CALL_OW 275
27919: PUSH
27920: LD_VAR 0 4
27924: PUSH
27925: LD_INT 3
27927: ARRAY
27928: GREATEREQUAL
27929: AND
27930: ST_TO_ADDR
// end ;
27931: LD_VAR 0 3
27935: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27936: LD_INT 0
27938: PPUSH
27939: PPUSH
27940: PPUSH
27941: PPUSH
// pom := GetBase ( building ) ;
27942: LD_ADDR_VAR 0 3
27946: PUSH
27947: LD_VAR 0 1
27951: PPUSH
27952: CALL_OW 274
27956: ST_TO_ADDR
// if not pom then
27957: LD_VAR 0 3
27961: NOT
27962: IFFALSE 27966
// exit ;
27964: GO 28136
// btype := GetBType ( building ) ;
27966: LD_ADDR_VAR 0 5
27970: PUSH
27971: LD_VAR 0 1
27975: PPUSH
27976: CALL_OW 266
27980: ST_TO_ADDR
// if btype = b_armoury then
27981: LD_VAR 0 5
27985: PUSH
27986: LD_INT 4
27988: EQUAL
27989: IFFALSE 27999
// btype := b_barracks ;
27991: LD_ADDR_VAR 0 5
27995: PUSH
27996: LD_INT 5
27998: ST_TO_ADDR
// if btype = b_depot then
27999: LD_VAR 0 5
28003: PUSH
28004: LD_INT 0
28006: EQUAL
28007: IFFALSE 28017
// btype := b_warehouse ;
28009: LD_ADDR_VAR 0 5
28013: PUSH
28014: LD_INT 1
28016: ST_TO_ADDR
// if btype = b_workshop then
28017: LD_VAR 0 5
28021: PUSH
28022: LD_INT 2
28024: EQUAL
28025: IFFALSE 28035
// btype := b_factory ;
28027: LD_ADDR_VAR 0 5
28031: PUSH
28032: LD_INT 3
28034: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28035: LD_ADDR_VAR 0 4
28039: PUSH
28040: LD_VAR 0 5
28044: PPUSH
28045: LD_VAR 0 1
28049: PPUSH
28050: CALL_OW 248
28054: PPUSH
28055: CALL_OW 450
28059: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28060: LD_ADDR_VAR 0 2
28064: PUSH
28065: LD_VAR 0 3
28069: PPUSH
28070: LD_INT 1
28072: PPUSH
28073: CALL_OW 275
28077: PUSH
28078: LD_VAR 0 4
28082: PUSH
28083: LD_INT 1
28085: ARRAY
28086: GREATEREQUAL
28087: PUSH
28088: LD_VAR 0 3
28092: PPUSH
28093: LD_INT 2
28095: PPUSH
28096: CALL_OW 275
28100: PUSH
28101: LD_VAR 0 4
28105: PUSH
28106: LD_INT 2
28108: ARRAY
28109: GREATEREQUAL
28110: AND
28111: PUSH
28112: LD_VAR 0 3
28116: PPUSH
28117: LD_INT 3
28119: PPUSH
28120: CALL_OW 275
28124: PUSH
28125: LD_VAR 0 4
28129: PUSH
28130: LD_INT 3
28132: ARRAY
28133: GREATEREQUAL
28134: AND
28135: ST_TO_ADDR
// end ;
28136: LD_VAR 0 2
28140: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28141: LD_INT 0
28143: PPUSH
28144: PPUSH
28145: PPUSH
// pom := GetBase ( building ) ;
28146: LD_ADDR_VAR 0 4
28150: PUSH
28151: LD_VAR 0 1
28155: PPUSH
28156: CALL_OW 274
28160: ST_TO_ADDR
// if not pom then
28161: LD_VAR 0 4
28165: NOT
28166: IFFALSE 28170
// exit ;
28168: GO 28271
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28170: LD_ADDR_VAR 0 5
28174: PUSH
28175: LD_VAR 0 2
28179: PPUSH
28180: LD_VAR 0 1
28184: PPUSH
28185: CALL_OW 248
28189: PPUSH
28190: CALL_OW 450
28194: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28195: LD_ADDR_VAR 0 3
28199: PUSH
28200: LD_VAR 0 4
28204: PPUSH
28205: LD_INT 1
28207: PPUSH
28208: CALL_OW 275
28212: PUSH
28213: LD_VAR 0 5
28217: PUSH
28218: LD_INT 1
28220: ARRAY
28221: GREATEREQUAL
28222: PUSH
28223: LD_VAR 0 4
28227: PPUSH
28228: LD_INT 2
28230: PPUSH
28231: CALL_OW 275
28235: PUSH
28236: LD_VAR 0 5
28240: PUSH
28241: LD_INT 2
28243: ARRAY
28244: GREATEREQUAL
28245: AND
28246: PUSH
28247: LD_VAR 0 4
28251: PPUSH
28252: LD_INT 3
28254: PPUSH
28255: CALL_OW 275
28259: PUSH
28260: LD_VAR 0 5
28264: PUSH
28265: LD_INT 3
28267: ARRAY
28268: GREATEREQUAL
28269: AND
28270: ST_TO_ADDR
// end ;
28271: LD_VAR 0 3
28275: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
28276: LD_INT 0
28278: PPUSH
28279: PPUSH
28280: PPUSH
28281: PPUSH
28282: PPUSH
28283: PPUSH
28284: PPUSH
28285: PPUSH
28286: PPUSH
28287: PPUSH
// result := false ;
28288: LD_ADDR_VAR 0 6
28292: PUSH
28293: LD_INT 0
28295: ST_TO_ADDR
// if not base or not btype or not x or not y then
28296: LD_VAR 0 1
28300: NOT
28301: PUSH
28302: LD_VAR 0 2
28306: NOT
28307: OR
28308: PUSH
28309: LD_VAR 0 3
28313: NOT
28314: OR
28315: PUSH
28316: LD_VAR 0 4
28320: NOT
28321: OR
28322: IFFALSE 28326
// exit ;
28324: GO 28935
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
28326: LD_ADDR_VAR 0 12
28330: PUSH
28331: LD_VAR 0 2
28335: PPUSH
28336: LD_VAR 0 3
28340: PPUSH
28341: LD_VAR 0 4
28345: PPUSH
28346: LD_VAR 0 5
28350: PPUSH
28351: LD_VAR 0 1
28355: PUSH
28356: LD_INT 1
28358: ARRAY
28359: PPUSH
28360: CALL_OW 248
28364: PPUSH
28365: LD_INT 0
28367: PPUSH
28368: CALL 29772 0 6
28372: ST_TO_ADDR
// if not hexes then
28373: LD_VAR 0 12
28377: NOT
28378: IFFALSE 28382
// exit ;
28380: GO 28935
// for i = 1 to hexes do
28382: LD_ADDR_VAR 0 7
28386: PUSH
28387: DOUBLE
28388: LD_INT 1
28390: DEC
28391: ST_TO_ADDR
28392: LD_VAR 0 12
28396: PUSH
28397: FOR_TO
28398: IFFALSE 28933
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28400: LD_ADDR_VAR 0 11
28404: PUSH
28405: LD_VAR 0 12
28409: PUSH
28410: LD_VAR 0 7
28414: ARRAY
28415: PUSH
28416: LD_INT 1
28418: ARRAY
28419: PPUSH
28420: LD_VAR 0 12
28424: PUSH
28425: LD_VAR 0 7
28429: ARRAY
28430: PUSH
28431: LD_INT 2
28433: ARRAY
28434: PPUSH
28435: CALL_OW 428
28439: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28440: LD_VAR 0 12
28444: PUSH
28445: LD_VAR 0 7
28449: ARRAY
28450: PUSH
28451: LD_INT 1
28453: ARRAY
28454: PPUSH
28455: LD_VAR 0 12
28459: PUSH
28460: LD_VAR 0 7
28464: ARRAY
28465: PUSH
28466: LD_INT 2
28468: ARRAY
28469: PPUSH
28470: CALL_OW 351
28474: PUSH
28475: LD_VAR 0 12
28479: PUSH
28480: LD_VAR 0 7
28484: ARRAY
28485: PUSH
28486: LD_INT 1
28488: ARRAY
28489: PPUSH
28490: LD_VAR 0 12
28494: PUSH
28495: LD_VAR 0 7
28499: ARRAY
28500: PUSH
28501: LD_INT 2
28503: ARRAY
28504: PPUSH
28505: CALL_OW 488
28509: NOT
28510: OR
28511: PUSH
28512: LD_VAR 0 11
28516: PPUSH
28517: CALL_OW 247
28521: PUSH
28522: LD_INT 3
28524: EQUAL
28525: OR
28526: IFFALSE 28532
// exit ;
28528: POP
28529: POP
28530: GO 28935
// if not tmp or not tmp in base then
28532: LD_VAR 0 11
28536: NOT
28537: PUSH
28538: LD_VAR 0 11
28542: PUSH
28543: LD_VAR 0 1
28547: IN
28548: NOT
28549: OR
28550: IFFALSE 28554
// continue ;
28552: GO 28397
// result := true ;
28554: LD_ADDR_VAR 0 6
28558: PUSH
28559: LD_INT 1
28561: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28562: LD_ADDR_VAR 0 15
28566: PUSH
28567: LD_VAR 0 1
28571: PPUSH
28572: LD_INT 22
28574: PUSH
28575: LD_VAR 0 11
28579: PPUSH
28580: CALL_OW 255
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: LD_INT 2
28591: PUSH
28592: LD_INT 30
28594: PUSH
28595: LD_INT 0
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: LD_INT 30
28604: PUSH
28605: LD_INT 1
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: LIST
28616: PUSH
28617: EMPTY
28618: LIST
28619: LIST
28620: PPUSH
28621: CALL_OW 72
28625: ST_TO_ADDR
// if dep then
28626: LD_VAR 0 15
28630: IFFALSE 28766
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28632: LD_ADDR_VAR 0 14
28636: PUSH
28637: LD_VAR 0 15
28641: PUSH
28642: LD_INT 1
28644: ARRAY
28645: PPUSH
28646: CALL_OW 250
28650: PPUSH
28651: LD_VAR 0 15
28655: PUSH
28656: LD_INT 1
28658: ARRAY
28659: PPUSH
28660: CALL_OW 254
28664: PPUSH
28665: LD_INT 5
28667: PPUSH
28668: CALL_OW 272
28672: PUSH
28673: LD_VAR 0 15
28677: PUSH
28678: LD_INT 1
28680: ARRAY
28681: PPUSH
28682: CALL_OW 251
28686: PPUSH
28687: LD_VAR 0 15
28691: PUSH
28692: LD_INT 1
28694: ARRAY
28695: PPUSH
28696: CALL_OW 254
28700: PPUSH
28701: LD_INT 5
28703: PPUSH
28704: CALL_OW 273
28708: PUSH
28709: EMPTY
28710: LIST
28711: LIST
28712: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28713: LD_VAR 0 14
28717: PUSH
28718: LD_INT 1
28720: ARRAY
28721: PPUSH
28722: LD_VAR 0 14
28726: PUSH
28727: LD_INT 2
28729: ARRAY
28730: PPUSH
28731: CALL_OW 488
28735: IFFALSE 28766
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28737: LD_VAR 0 11
28741: PPUSH
28742: LD_VAR 0 14
28746: PUSH
28747: LD_INT 1
28749: ARRAY
28750: PPUSH
28751: LD_VAR 0 14
28755: PUSH
28756: LD_INT 2
28758: ARRAY
28759: PPUSH
28760: CALL_OW 111
// continue ;
28764: GO 28397
// end ; end ; r := GetDir ( tmp ) ;
28766: LD_ADDR_VAR 0 13
28770: PUSH
28771: LD_VAR 0 11
28775: PPUSH
28776: CALL_OW 254
28780: ST_TO_ADDR
// if r = 5 then
28781: LD_VAR 0 13
28785: PUSH
28786: LD_INT 5
28788: EQUAL
28789: IFFALSE 28799
// r := 0 ;
28791: LD_ADDR_VAR 0 13
28795: PUSH
28796: LD_INT 0
28798: ST_TO_ADDR
// for j = r to 5 do
28799: LD_ADDR_VAR 0 8
28803: PUSH
28804: DOUBLE
28805: LD_VAR 0 13
28809: DEC
28810: ST_TO_ADDR
28811: LD_INT 5
28813: PUSH
28814: FOR_TO
28815: IFFALSE 28929
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28817: LD_ADDR_VAR 0 9
28821: PUSH
28822: LD_VAR 0 11
28826: PPUSH
28827: CALL_OW 250
28831: PPUSH
28832: LD_VAR 0 8
28836: PPUSH
28837: LD_INT 2
28839: PPUSH
28840: CALL_OW 272
28844: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28845: LD_ADDR_VAR 0 10
28849: PUSH
28850: LD_VAR 0 11
28854: PPUSH
28855: CALL_OW 251
28859: PPUSH
28860: LD_VAR 0 8
28864: PPUSH
28865: LD_INT 2
28867: PPUSH
28868: CALL_OW 273
28872: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28873: LD_VAR 0 9
28877: PPUSH
28878: LD_VAR 0 10
28882: PPUSH
28883: CALL_OW 488
28887: PUSH
28888: LD_VAR 0 9
28892: PPUSH
28893: LD_VAR 0 10
28897: PPUSH
28898: CALL_OW 428
28902: NOT
28903: AND
28904: IFFALSE 28927
// begin ComMoveXY ( tmp , _x , _y ) ;
28906: LD_VAR 0 11
28910: PPUSH
28911: LD_VAR 0 9
28915: PPUSH
28916: LD_VAR 0 10
28920: PPUSH
28921: CALL_OW 111
// break ;
28925: GO 28929
// end ; end ;
28927: GO 28814
28929: POP
28930: POP
// end ;
28931: GO 28397
28933: POP
28934: POP
// end ;
28935: LD_VAR 0 6
28939: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28940: LD_INT 0
28942: PPUSH
28943: PPUSH
28944: PPUSH
28945: PPUSH
28946: PPUSH
28947: PPUSH
28948: PPUSH
28949: PPUSH
28950: PPUSH
28951: PPUSH
// result := false ;
28952: LD_ADDR_VAR 0 6
28956: PUSH
28957: LD_INT 0
28959: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28960: LD_VAR 0 1
28964: NOT
28965: PUSH
28966: LD_VAR 0 1
28970: PPUSH
28971: CALL_OW 266
28975: PUSH
28976: LD_INT 0
28978: PUSH
28979: LD_INT 1
28981: PUSH
28982: EMPTY
28983: LIST
28984: LIST
28985: IN
28986: NOT
28987: OR
28988: PUSH
28989: LD_VAR 0 2
28993: NOT
28994: OR
28995: PUSH
28996: LD_VAR 0 5
29000: PUSH
29001: LD_INT 0
29003: PUSH
29004: LD_INT 1
29006: PUSH
29007: LD_INT 2
29009: PUSH
29010: LD_INT 3
29012: PUSH
29013: LD_INT 4
29015: PUSH
29016: LD_INT 5
29018: PUSH
29019: EMPTY
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: IN
29027: NOT
29028: OR
29029: PUSH
29030: LD_VAR 0 3
29034: PPUSH
29035: LD_VAR 0 4
29039: PPUSH
29040: CALL_OW 488
29044: NOT
29045: OR
29046: IFFALSE 29050
// exit ;
29048: GO 29767
// pom := GetBase ( depot ) ;
29050: LD_ADDR_VAR 0 10
29054: PUSH
29055: LD_VAR 0 1
29059: PPUSH
29060: CALL_OW 274
29064: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
29065: LD_ADDR_VAR 0 11
29069: PUSH
29070: LD_VAR 0 2
29074: PPUSH
29075: LD_VAR 0 1
29079: PPUSH
29080: CALL_OW 248
29084: PPUSH
29085: CALL_OW 450
29089: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
29090: LD_VAR 0 10
29094: PPUSH
29095: LD_INT 1
29097: PPUSH
29098: CALL_OW 275
29102: PUSH
29103: LD_VAR 0 11
29107: PUSH
29108: LD_INT 1
29110: ARRAY
29111: GREATEREQUAL
29112: PUSH
29113: LD_VAR 0 10
29117: PPUSH
29118: LD_INT 2
29120: PPUSH
29121: CALL_OW 275
29125: PUSH
29126: LD_VAR 0 11
29130: PUSH
29131: LD_INT 2
29133: ARRAY
29134: GREATEREQUAL
29135: AND
29136: PUSH
29137: LD_VAR 0 10
29141: PPUSH
29142: LD_INT 3
29144: PPUSH
29145: CALL_OW 275
29149: PUSH
29150: LD_VAR 0 11
29154: PUSH
29155: LD_INT 3
29157: ARRAY
29158: GREATEREQUAL
29159: AND
29160: NOT
29161: IFFALSE 29165
// exit ;
29163: GO 29767
// if GetBType ( depot ) = b_depot then
29165: LD_VAR 0 1
29169: PPUSH
29170: CALL_OW 266
29174: PUSH
29175: LD_INT 0
29177: EQUAL
29178: IFFALSE 29190
// dist := 28 else
29180: LD_ADDR_VAR 0 14
29184: PUSH
29185: LD_INT 28
29187: ST_TO_ADDR
29188: GO 29198
// dist := 36 ;
29190: LD_ADDR_VAR 0 14
29194: PUSH
29195: LD_INT 36
29197: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
29198: LD_VAR 0 1
29202: PPUSH
29203: LD_VAR 0 3
29207: PPUSH
29208: LD_VAR 0 4
29212: PPUSH
29213: CALL_OW 297
29217: PUSH
29218: LD_VAR 0 14
29222: GREATER
29223: IFFALSE 29227
// exit ;
29225: GO 29767
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
29227: LD_ADDR_VAR 0 12
29231: PUSH
29232: LD_VAR 0 2
29236: PPUSH
29237: LD_VAR 0 3
29241: PPUSH
29242: LD_VAR 0 4
29246: PPUSH
29247: LD_VAR 0 5
29251: PPUSH
29252: LD_VAR 0 1
29256: PPUSH
29257: CALL_OW 248
29261: PPUSH
29262: LD_INT 0
29264: PPUSH
29265: CALL 29772 0 6
29269: ST_TO_ADDR
// if not hexes then
29270: LD_VAR 0 12
29274: NOT
29275: IFFALSE 29279
// exit ;
29277: GO 29767
// hex := GetHexInfo ( x , y ) ;
29279: LD_ADDR_VAR 0 15
29283: PUSH
29284: LD_VAR 0 3
29288: PPUSH
29289: LD_VAR 0 4
29293: PPUSH
29294: CALL_OW 546
29298: ST_TO_ADDR
// if hex [ 1 ] then
29299: LD_VAR 0 15
29303: PUSH
29304: LD_INT 1
29306: ARRAY
29307: IFFALSE 29311
// exit ;
29309: GO 29767
// height := hex [ 2 ] ;
29311: LD_ADDR_VAR 0 13
29315: PUSH
29316: LD_VAR 0 15
29320: PUSH
29321: LD_INT 2
29323: ARRAY
29324: ST_TO_ADDR
// for i = 1 to hexes do
29325: LD_ADDR_VAR 0 7
29329: PUSH
29330: DOUBLE
29331: LD_INT 1
29333: DEC
29334: ST_TO_ADDR
29335: LD_VAR 0 12
29339: PUSH
29340: FOR_TO
29341: IFFALSE 29671
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29343: LD_VAR 0 12
29347: PUSH
29348: LD_VAR 0 7
29352: ARRAY
29353: PUSH
29354: LD_INT 1
29356: ARRAY
29357: PPUSH
29358: LD_VAR 0 12
29362: PUSH
29363: LD_VAR 0 7
29367: ARRAY
29368: PUSH
29369: LD_INT 2
29371: ARRAY
29372: PPUSH
29373: CALL_OW 488
29377: NOT
29378: PUSH
29379: LD_VAR 0 12
29383: PUSH
29384: LD_VAR 0 7
29388: ARRAY
29389: PUSH
29390: LD_INT 1
29392: ARRAY
29393: PPUSH
29394: LD_VAR 0 12
29398: PUSH
29399: LD_VAR 0 7
29403: ARRAY
29404: PUSH
29405: LD_INT 2
29407: ARRAY
29408: PPUSH
29409: CALL_OW 428
29413: PUSH
29414: LD_INT 0
29416: GREATER
29417: OR
29418: PUSH
29419: LD_VAR 0 12
29423: PUSH
29424: LD_VAR 0 7
29428: ARRAY
29429: PUSH
29430: LD_INT 1
29432: ARRAY
29433: PPUSH
29434: LD_VAR 0 12
29438: PUSH
29439: LD_VAR 0 7
29443: ARRAY
29444: PUSH
29445: LD_INT 2
29447: ARRAY
29448: PPUSH
29449: CALL_OW 351
29453: OR
29454: IFFALSE 29460
// exit ;
29456: POP
29457: POP
29458: GO 29767
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29460: LD_ADDR_VAR 0 8
29464: PUSH
29465: LD_VAR 0 12
29469: PUSH
29470: LD_VAR 0 7
29474: ARRAY
29475: PUSH
29476: LD_INT 1
29478: ARRAY
29479: PPUSH
29480: LD_VAR 0 12
29484: PUSH
29485: LD_VAR 0 7
29489: ARRAY
29490: PUSH
29491: LD_INT 2
29493: ARRAY
29494: PPUSH
29495: CALL_OW 546
29499: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29500: LD_VAR 0 8
29504: PUSH
29505: LD_INT 1
29507: ARRAY
29508: PUSH
29509: LD_VAR 0 8
29513: PUSH
29514: LD_INT 2
29516: ARRAY
29517: PUSH
29518: LD_VAR 0 13
29522: PUSH
29523: LD_INT 2
29525: PLUS
29526: GREATER
29527: OR
29528: PUSH
29529: LD_VAR 0 8
29533: PUSH
29534: LD_INT 2
29536: ARRAY
29537: PUSH
29538: LD_VAR 0 13
29542: PUSH
29543: LD_INT 2
29545: MINUS
29546: LESS
29547: OR
29548: PUSH
29549: LD_VAR 0 8
29553: PUSH
29554: LD_INT 3
29556: ARRAY
29557: PUSH
29558: LD_INT 0
29560: PUSH
29561: LD_INT 8
29563: PUSH
29564: LD_INT 9
29566: PUSH
29567: LD_INT 10
29569: PUSH
29570: LD_INT 11
29572: PUSH
29573: LD_INT 12
29575: PUSH
29576: LD_INT 13
29578: PUSH
29579: LD_INT 16
29581: PUSH
29582: LD_INT 17
29584: PUSH
29585: LD_INT 18
29587: PUSH
29588: LD_INT 19
29590: PUSH
29591: LD_INT 20
29593: PUSH
29594: LD_INT 21
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: IN
29612: NOT
29613: OR
29614: PUSH
29615: LD_VAR 0 8
29619: PUSH
29620: LD_INT 5
29622: ARRAY
29623: NOT
29624: OR
29625: PUSH
29626: LD_VAR 0 8
29630: PUSH
29631: LD_INT 6
29633: ARRAY
29634: PUSH
29635: LD_INT 1
29637: PUSH
29638: LD_INT 2
29640: PUSH
29641: LD_INT 7
29643: PUSH
29644: LD_INT 9
29646: PUSH
29647: LD_INT 10
29649: PUSH
29650: LD_INT 11
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: LIST
29657: LIST
29658: LIST
29659: LIST
29660: IN
29661: NOT
29662: OR
29663: IFFALSE 29669
// exit ;
29665: POP
29666: POP
29667: GO 29767
// end ;
29669: GO 29340
29671: POP
29672: POP
// side := GetSide ( depot ) ;
29673: LD_ADDR_VAR 0 9
29677: PUSH
29678: LD_VAR 0 1
29682: PPUSH
29683: CALL_OW 255
29687: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29688: LD_VAR 0 9
29692: PPUSH
29693: LD_VAR 0 3
29697: PPUSH
29698: LD_VAR 0 4
29702: PPUSH
29703: LD_INT 20
29705: PPUSH
29706: CALL 22421 0 4
29710: PUSH
29711: LD_INT 4
29713: ARRAY
29714: IFFALSE 29718
// exit ;
29716: GO 29767
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29718: LD_VAR 0 2
29722: PUSH
29723: LD_INT 29
29725: PUSH
29726: LD_INT 30
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: IN
29733: PUSH
29734: LD_VAR 0 3
29738: PPUSH
29739: LD_VAR 0 4
29743: PPUSH
29744: LD_VAR 0 9
29748: PPUSH
29749: CALL_OW 440
29753: NOT
29754: AND
29755: IFFALSE 29759
// exit ;
29757: GO 29767
// result := true ;
29759: LD_ADDR_VAR 0 6
29763: PUSH
29764: LD_INT 1
29766: ST_TO_ADDR
// end ;
29767: LD_VAR 0 6
29771: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29772: LD_INT 0
29774: PPUSH
29775: PPUSH
29776: PPUSH
29777: PPUSH
29778: PPUSH
29779: PPUSH
29780: PPUSH
29781: PPUSH
29782: PPUSH
29783: PPUSH
29784: PPUSH
29785: PPUSH
29786: PPUSH
29787: PPUSH
29788: PPUSH
29789: PPUSH
29790: PPUSH
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
29795: PPUSH
29796: PPUSH
29797: PPUSH
29798: PPUSH
29799: PPUSH
29800: PPUSH
29801: PPUSH
29802: PPUSH
29803: PPUSH
29804: PPUSH
29805: PPUSH
29806: PPUSH
29807: PPUSH
29808: PPUSH
29809: PPUSH
29810: PPUSH
29811: PPUSH
29812: PPUSH
29813: PPUSH
29814: PPUSH
29815: PPUSH
29816: PPUSH
29817: PPUSH
29818: PPUSH
29819: PPUSH
29820: PPUSH
29821: PPUSH
29822: PPUSH
29823: PPUSH
29824: PPUSH
29825: PPUSH
29826: PPUSH
29827: PPUSH
29828: PPUSH
29829: PPUSH
29830: PPUSH
29831: PPUSH
// result = [ ] ;
29832: LD_ADDR_VAR 0 7
29836: PUSH
29837: EMPTY
29838: ST_TO_ADDR
// temp_list = [ ] ;
29839: LD_ADDR_VAR 0 9
29843: PUSH
29844: EMPTY
29845: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29846: LD_VAR 0 4
29850: PUSH
29851: LD_INT 0
29853: PUSH
29854: LD_INT 1
29856: PUSH
29857: LD_INT 2
29859: PUSH
29860: LD_INT 3
29862: PUSH
29863: LD_INT 4
29865: PUSH
29866: LD_INT 5
29868: PUSH
29869: EMPTY
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: IN
29877: NOT
29878: PUSH
29879: LD_VAR 0 1
29883: PUSH
29884: LD_INT 0
29886: PUSH
29887: LD_INT 1
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: IN
29894: PUSH
29895: LD_VAR 0 5
29899: PUSH
29900: LD_INT 1
29902: PUSH
29903: LD_INT 2
29905: PUSH
29906: LD_INT 3
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: LIST
29913: IN
29914: NOT
29915: AND
29916: OR
29917: IFFALSE 29921
// exit ;
29919: GO 48312
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29921: LD_VAR 0 1
29925: PUSH
29926: LD_INT 6
29928: PUSH
29929: LD_INT 7
29931: PUSH
29932: LD_INT 8
29934: PUSH
29935: LD_INT 13
29937: PUSH
29938: LD_INT 12
29940: PUSH
29941: LD_INT 15
29943: PUSH
29944: LD_INT 11
29946: PUSH
29947: LD_INT 14
29949: PUSH
29950: LD_INT 10
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: LIST
29963: IN
29964: IFFALSE 29974
// btype = b_lab ;
29966: LD_ADDR_VAR 0 1
29970: PUSH
29971: LD_INT 6
29973: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29974: LD_VAR 0 6
29978: PUSH
29979: LD_INT 0
29981: PUSH
29982: LD_INT 1
29984: PUSH
29985: LD_INT 2
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: LIST
29992: IN
29993: NOT
29994: PUSH
29995: LD_VAR 0 1
29999: PUSH
30000: LD_INT 0
30002: PUSH
30003: LD_INT 1
30005: PUSH
30006: LD_INT 2
30008: PUSH
30009: LD_INT 3
30011: PUSH
30012: LD_INT 6
30014: PUSH
30015: LD_INT 36
30017: PUSH
30018: LD_INT 4
30020: PUSH
30021: LD_INT 5
30023: PUSH
30024: LD_INT 31
30026: PUSH
30027: LD_INT 32
30029: PUSH
30030: LD_INT 33
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: IN
30046: NOT
30047: PUSH
30048: LD_VAR 0 6
30052: PUSH
30053: LD_INT 1
30055: EQUAL
30056: AND
30057: OR
30058: PUSH
30059: LD_VAR 0 1
30063: PUSH
30064: LD_INT 2
30066: PUSH
30067: LD_INT 3
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: IN
30074: NOT
30075: PUSH
30076: LD_VAR 0 6
30080: PUSH
30081: LD_INT 2
30083: EQUAL
30084: AND
30085: OR
30086: IFFALSE 30096
// mode = 0 ;
30088: LD_ADDR_VAR 0 6
30092: PUSH
30093: LD_INT 0
30095: ST_TO_ADDR
// case mode of 0 :
30096: LD_VAR 0 6
30100: PUSH
30101: LD_INT 0
30103: DOUBLE
30104: EQUAL
30105: IFTRUE 30109
30107: GO 41562
30109: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
30110: LD_ADDR_VAR 0 11
30114: PUSH
30115: LD_INT 0
30117: PUSH
30118: LD_INT 0
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 0
30127: PUSH
30128: LD_INT 1
30130: NEG
30131: PUSH
30132: EMPTY
30133: LIST
30134: LIST
30135: PUSH
30136: LD_INT 1
30138: PUSH
30139: LD_INT 0
30141: PUSH
30142: EMPTY
30143: LIST
30144: LIST
30145: PUSH
30146: LD_INT 1
30148: PUSH
30149: LD_INT 1
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PUSH
30156: LD_INT 0
30158: PUSH
30159: LD_INT 1
30161: PUSH
30162: EMPTY
30163: LIST
30164: LIST
30165: PUSH
30166: LD_INT 1
30168: NEG
30169: PUSH
30170: LD_INT 0
30172: PUSH
30173: EMPTY
30174: LIST
30175: LIST
30176: PUSH
30177: LD_INT 1
30179: NEG
30180: PUSH
30181: LD_INT 1
30183: NEG
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: LD_INT 1
30191: NEG
30192: PUSH
30193: LD_INT 2
30195: NEG
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 0
30203: PUSH
30204: LD_INT 2
30206: NEG
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 1
30214: PUSH
30215: LD_INT 1
30217: NEG
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 1
30225: PUSH
30226: LD_INT 2
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: LD_INT 0
30235: PUSH
30236: LD_INT 2
30238: PUSH
30239: EMPTY
30240: LIST
30241: LIST
30242: PUSH
30243: LD_INT 1
30245: NEG
30246: PUSH
30247: LD_INT 1
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 1
30256: PUSH
30257: LD_INT 3
30259: PUSH
30260: EMPTY
30261: LIST
30262: LIST
30263: PUSH
30264: LD_INT 0
30266: PUSH
30267: LD_INT 3
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: PUSH
30274: LD_INT 1
30276: NEG
30277: PUSH
30278: LD_INT 2
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: LIST
30289: LIST
30290: LIST
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: LIST
30296: LIST
30297: LIST
30298: LIST
30299: LIST
30300: LIST
30301: LIST
30302: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30303: LD_ADDR_VAR 0 12
30307: PUSH
30308: LD_INT 0
30310: PUSH
30311: LD_INT 0
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 0
30320: PUSH
30321: LD_INT 1
30323: NEG
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: PUSH
30329: LD_INT 1
30331: PUSH
30332: LD_INT 0
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PUSH
30339: LD_INT 1
30341: PUSH
30342: LD_INT 1
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 0
30351: PUSH
30352: LD_INT 1
30354: PUSH
30355: EMPTY
30356: LIST
30357: LIST
30358: PUSH
30359: LD_INT 1
30361: NEG
30362: PUSH
30363: LD_INT 0
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 1
30372: NEG
30373: PUSH
30374: LD_INT 1
30376: NEG
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 1
30384: PUSH
30385: LD_INT 1
30387: NEG
30388: PUSH
30389: EMPTY
30390: LIST
30391: LIST
30392: PUSH
30393: LD_INT 2
30395: PUSH
30396: LD_INT 0
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: LD_INT 2
30405: PUSH
30406: LD_INT 1
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 1
30415: NEG
30416: PUSH
30417: LD_INT 1
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 2
30426: NEG
30427: PUSH
30428: LD_INT 0
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 2
30437: NEG
30438: PUSH
30439: LD_INT 1
30441: NEG
30442: PUSH
30443: EMPTY
30444: LIST
30445: LIST
30446: PUSH
30447: LD_INT 2
30449: NEG
30450: PUSH
30451: LD_INT 1
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 3
30460: NEG
30461: PUSH
30462: LD_INT 0
30464: PUSH
30465: EMPTY
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 3
30471: NEG
30472: PUSH
30473: LD_INT 1
30475: NEG
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: EMPTY
30482: LIST
30483: LIST
30484: LIST
30485: LIST
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30499: LD_ADDR_VAR 0 13
30503: PUSH
30504: LD_INT 0
30506: PUSH
30507: LD_INT 0
30509: PUSH
30510: EMPTY
30511: LIST
30512: LIST
30513: PUSH
30514: LD_INT 0
30516: PUSH
30517: LD_INT 1
30519: NEG
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: PUSH
30525: LD_INT 1
30527: PUSH
30528: LD_INT 0
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 1
30537: PUSH
30538: LD_INT 1
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: LD_INT 0
30547: PUSH
30548: LD_INT 1
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 1
30557: NEG
30558: PUSH
30559: LD_INT 0
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PUSH
30566: LD_INT 1
30568: NEG
30569: PUSH
30570: LD_INT 1
30572: NEG
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: LD_INT 1
30580: NEG
30581: PUSH
30582: LD_INT 2
30584: NEG
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PUSH
30590: LD_INT 2
30592: PUSH
30593: LD_INT 1
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PUSH
30600: LD_INT 2
30602: PUSH
30603: LD_INT 2
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: LD_INT 1
30612: PUSH
30613: LD_INT 2
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PUSH
30620: LD_INT 2
30622: NEG
30623: PUSH
30624: LD_INT 1
30626: NEG
30627: PUSH
30628: EMPTY
30629: LIST
30630: LIST
30631: PUSH
30632: LD_INT 2
30634: NEG
30635: PUSH
30636: LD_INT 2
30638: NEG
30639: PUSH
30640: EMPTY
30641: LIST
30642: LIST
30643: PUSH
30644: LD_INT 2
30646: NEG
30647: PUSH
30648: LD_INT 3
30650: NEG
30651: PUSH
30652: EMPTY
30653: LIST
30654: LIST
30655: PUSH
30656: LD_INT 3
30658: NEG
30659: PUSH
30660: LD_INT 2
30662: NEG
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 3
30670: NEG
30671: PUSH
30672: LD_INT 3
30674: NEG
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: EMPTY
30681: LIST
30682: LIST
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: LIST
30696: LIST
30697: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30698: LD_ADDR_VAR 0 14
30702: PUSH
30703: LD_INT 0
30705: PUSH
30706: LD_INT 0
30708: PUSH
30709: EMPTY
30710: LIST
30711: LIST
30712: PUSH
30713: LD_INT 0
30715: PUSH
30716: LD_INT 1
30718: NEG
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: PUSH
30724: LD_INT 1
30726: PUSH
30727: LD_INT 0
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: PUSH
30734: LD_INT 1
30736: PUSH
30737: LD_INT 1
30739: PUSH
30740: EMPTY
30741: LIST
30742: LIST
30743: PUSH
30744: LD_INT 0
30746: PUSH
30747: LD_INT 1
30749: PUSH
30750: EMPTY
30751: LIST
30752: LIST
30753: PUSH
30754: LD_INT 1
30756: NEG
30757: PUSH
30758: LD_INT 0
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 1
30767: NEG
30768: PUSH
30769: LD_INT 1
30771: NEG
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: LD_INT 1
30779: NEG
30780: PUSH
30781: LD_INT 2
30783: NEG
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: PUSH
30789: LD_INT 0
30791: PUSH
30792: LD_INT 2
30794: NEG
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: PUSH
30800: LD_INT 1
30802: PUSH
30803: LD_INT 1
30805: NEG
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PUSH
30811: LD_INT 1
30813: PUSH
30814: LD_INT 2
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: LD_INT 0
30823: PUSH
30824: LD_INT 2
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: PUSH
30831: LD_INT 1
30833: NEG
30834: PUSH
30835: LD_INT 1
30837: PUSH
30838: EMPTY
30839: LIST
30840: LIST
30841: PUSH
30842: LD_INT 1
30844: NEG
30845: PUSH
30846: LD_INT 3
30848: NEG
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PUSH
30854: LD_INT 0
30856: PUSH
30857: LD_INT 3
30859: NEG
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: PUSH
30865: LD_INT 1
30867: PUSH
30868: LD_INT 2
30870: NEG
30871: PUSH
30872: EMPTY
30873: LIST
30874: LIST
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: LIST
30880: LIST
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: LIST
30887: LIST
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: LIST
30893: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30894: LD_ADDR_VAR 0 15
30898: PUSH
30899: LD_INT 0
30901: PUSH
30902: LD_INT 0
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: PUSH
30909: LD_INT 0
30911: PUSH
30912: LD_INT 1
30914: NEG
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: LD_INT 1
30922: PUSH
30923: LD_INT 0
30925: PUSH
30926: EMPTY
30927: LIST
30928: LIST
30929: PUSH
30930: LD_INT 1
30932: PUSH
30933: LD_INT 1
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: PUSH
30940: LD_INT 0
30942: PUSH
30943: LD_INT 1
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: LD_INT 1
30952: NEG
30953: PUSH
30954: LD_INT 0
30956: PUSH
30957: EMPTY
30958: LIST
30959: LIST
30960: PUSH
30961: LD_INT 1
30963: NEG
30964: PUSH
30965: LD_INT 1
30967: NEG
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: PUSH
30973: LD_INT 1
30975: PUSH
30976: LD_INT 1
30978: NEG
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: PUSH
30984: LD_INT 2
30986: PUSH
30987: LD_INT 0
30989: PUSH
30990: EMPTY
30991: LIST
30992: LIST
30993: PUSH
30994: LD_INT 2
30996: PUSH
30997: LD_INT 1
30999: PUSH
31000: EMPTY
31001: LIST
31002: LIST
31003: PUSH
31004: LD_INT 1
31006: NEG
31007: PUSH
31008: LD_INT 1
31010: PUSH
31011: EMPTY
31012: LIST
31013: LIST
31014: PUSH
31015: LD_INT 2
31017: NEG
31018: PUSH
31019: LD_INT 0
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 2
31028: NEG
31029: PUSH
31030: LD_INT 1
31032: NEG
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: LD_INT 2
31040: PUSH
31041: LD_INT 1
31043: NEG
31044: PUSH
31045: EMPTY
31046: LIST
31047: LIST
31048: PUSH
31049: LD_INT 3
31051: PUSH
31052: LD_INT 0
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 3
31061: PUSH
31062: LD_INT 1
31064: PUSH
31065: EMPTY
31066: LIST
31067: LIST
31068: PUSH
31069: EMPTY
31070: LIST
31071: LIST
31072: LIST
31073: LIST
31074: LIST
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: LIST
31082: LIST
31083: LIST
31084: LIST
31085: LIST
31086: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31087: LD_ADDR_VAR 0 16
31091: PUSH
31092: LD_INT 0
31094: PUSH
31095: LD_INT 0
31097: PUSH
31098: EMPTY
31099: LIST
31100: LIST
31101: PUSH
31102: LD_INT 0
31104: PUSH
31105: LD_INT 1
31107: NEG
31108: PUSH
31109: EMPTY
31110: LIST
31111: LIST
31112: PUSH
31113: LD_INT 1
31115: PUSH
31116: LD_INT 0
31118: PUSH
31119: EMPTY
31120: LIST
31121: LIST
31122: PUSH
31123: LD_INT 1
31125: PUSH
31126: LD_INT 1
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 0
31135: PUSH
31136: LD_INT 1
31138: PUSH
31139: EMPTY
31140: LIST
31141: LIST
31142: PUSH
31143: LD_INT 1
31145: NEG
31146: PUSH
31147: LD_INT 0
31149: PUSH
31150: EMPTY
31151: LIST
31152: LIST
31153: PUSH
31154: LD_INT 1
31156: NEG
31157: PUSH
31158: LD_INT 1
31160: NEG
31161: PUSH
31162: EMPTY
31163: LIST
31164: LIST
31165: PUSH
31166: LD_INT 1
31168: NEG
31169: PUSH
31170: LD_INT 2
31172: NEG
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: LD_INT 2
31180: PUSH
31181: LD_INT 1
31183: PUSH
31184: EMPTY
31185: LIST
31186: LIST
31187: PUSH
31188: LD_INT 2
31190: PUSH
31191: LD_INT 2
31193: PUSH
31194: EMPTY
31195: LIST
31196: LIST
31197: PUSH
31198: LD_INT 1
31200: PUSH
31201: LD_INT 2
31203: PUSH
31204: EMPTY
31205: LIST
31206: LIST
31207: PUSH
31208: LD_INT 2
31210: NEG
31211: PUSH
31212: LD_INT 1
31214: NEG
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: LD_INT 2
31222: NEG
31223: PUSH
31224: LD_INT 2
31226: NEG
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 3
31234: PUSH
31235: LD_INT 2
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: PUSH
31242: LD_INT 3
31244: PUSH
31245: LD_INT 3
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 2
31254: PUSH
31255: LD_INT 3
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: LIST
31274: LIST
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31280: LD_ADDR_VAR 0 17
31284: PUSH
31285: LD_INT 0
31287: PUSH
31288: LD_INT 0
31290: PUSH
31291: EMPTY
31292: LIST
31293: LIST
31294: PUSH
31295: LD_INT 0
31297: PUSH
31298: LD_INT 1
31300: NEG
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: LD_INT 1
31308: PUSH
31309: LD_INT 0
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 1
31318: PUSH
31319: LD_INT 1
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 0
31328: PUSH
31329: LD_INT 1
31331: PUSH
31332: EMPTY
31333: LIST
31334: LIST
31335: PUSH
31336: LD_INT 1
31338: NEG
31339: PUSH
31340: LD_INT 0
31342: PUSH
31343: EMPTY
31344: LIST
31345: LIST
31346: PUSH
31347: LD_INT 1
31349: NEG
31350: PUSH
31351: LD_INT 1
31353: NEG
31354: PUSH
31355: EMPTY
31356: LIST
31357: LIST
31358: PUSH
31359: LD_INT 1
31361: NEG
31362: PUSH
31363: LD_INT 2
31365: NEG
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 0
31373: PUSH
31374: LD_INT 2
31376: NEG
31377: PUSH
31378: EMPTY
31379: LIST
31380: LIST
31381: PUSH
31382: LD_INT 1
31384: PUSH
31385: LD_INT 1
31387: NEG
31388: PUSH
31389: EMPTY
31390: LIST
31391: LIST
31392: PUSH
31393: LD_INT 2
31395: PUSH
31396: LD_INT 0
31398: PUSH
31399: EMPTY
31400: LIST
31401: LIST
31402: PUSH
31403: LD_INT 2
31405: PUSH
31406: LD_INT 1
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: PUSH
31413: LD_INT 2
31415: PUSH
31416: LD_INT 2
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 1
31425: PUSH
31426: LD_INT 2
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: LD_INT 2
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 1
31445: NEG
31446: PUSH
31447: LD_INT 1
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: LD_INT 2
31456: NEG
31457: PUSH
31458: LD_INT 0
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 2
31467: NEG
31468: PUSH
31469: LD_INT 1
31471: NEG
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PUSH
31477: LD_INT 2
31479: NEG
31480: PUSH
31481: LD_INT 2
31483: NEG
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: LIST
31493: LIST
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: LIST
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: LIST
31509: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31510: LD_ADDR_VAR 0 18
31514: PUSH
31515: LD_INT 0
31517: PUSH
31518: LD_INT 0
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 0
31527: PUSH
31528: LD_INT 1
31530: NEG
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 1
31538: PUSH
31539: LD_INT 0
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 1
31548: PUSH
31549: LD_INT 1
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 0
31558: PUSH
31559: LD_INT 1
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: PUSH
31566: LD_INT 1
31568: NEG
31569: PUSH
31570: LD_INT 0
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: LD_INT 1
31579: NEG
31580: PUSH
31581: LD_INT 1
31583: NEG
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PUSH
31589: LD_INT 1
31591: NEG
31592: PUSH
31593: LD_INT 2
31595: NEG
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 0
31603: PUSH
31604: LD_INT 2
31606: NEG
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 1
31614: PUSH
31615: LD_INT 1
31617: NEG
31618: PUSH
31619: EMPTY
31620: LIST
31621: LIST
31622: PUSH
31623: LD_INT 2
31625: PUSH
31626: LD_INT 0
31628: PUSH
31629: EMPTY
31630: LIST
31631: LIST
31632: PUSH
31633: LD_INT 2
31635: PUSH
31636: LD_INT 1
31638: PUSH
31639: EMPTY
31640: LIST
31641: LIST
31642: PUSH
31643: LD_INT 2
31645: PUSH
31646: LD_INT 2
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: PUSH
31653: LD_INT 1
31655: PUSH
31656: LD_INT 2
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PUSH
31663: LD_INT 0
31665: PUSH
31666: LD_INT 2
31668: PUSH
31669: EMPTY
31670: LIST
31671: LIST
31672: PUSH
31673: LD_INT 1
31675: NEG
31676: PUSH
31677: LD_INT 1
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PUSH
31684: LD_INT 2
31686: NEG
31687: PUSH
31688: LD_INT 0
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 2
31697: NEG
31698: PUSH
31699: LD_INT 1
31701: NEG
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: LD_INT 2
31709: NEG
31710: PUSH
31711: LD_INT 2
31713: NEG
31714: PUSH
31715: EMPTY
31716: LIST
31717: LIST
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31740: LD_ADDR_VAR 0 19
31744: PUSH
31745: LD_INT 0
31747: PUSH
31748: LD_INT 0
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 0
31757: PUSH
31758: LD_INT 1
31760: NEG
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 1
31768: PUSH
31769: LD_INT 0
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 1
31778: PUSH
31779: LD_INT 1
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: LD_INT 0
31788: PUSH
31789: LD_INT 1
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 1
31798: NEG
31799: PUSH
31800: LD_INT 0
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 1
31809: NEG
31810: PUSH
31811: LD_INT 1
31813: NEG
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: LD_INT 1
31821: NEG
31822: PUSH
31823: LD_INT 2
31825: NEG
31826: PUSH
31827: EMPTY
31828: LIST
31829: LIST
31830: PUSH
31831: LD_INT 0
31833: PUSH
31834: LD_INT 2
31836: NEG
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 1
31844: PUSH
31845: LD_INT 1
31847: NEG
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: PUSH
31853: LD_INT 2
31855: PUSH
31856: LD_INT 0
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: LD_INT 2
31865: PUSH
31866: LD_INT 1
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PUSH
31873: LD_INT 2
31875: PUSH
31876: LD_INT 2
31878: PUSH
31879: EMPTY
31880: LIST
31881: LIST
31882: PUSH
31883: LD_INT 1
31885: PUSH
31886: LD_INT 2
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PUSH
31893: LD_INT 0
31895: PUSH
31896: LD_INT 2
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: PUSH
31903: LD_INT 1
31905: NEG
31906: PUSH
31907: LD_INT 1
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: LD_INT 2
31916: NEG
31917: PUSH
31918: LD_INT 0
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 2
31927: NEG
31928: PUSH
31929: LD_INT 1
31931: NEG
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 2
31939: NEG
31940: PUSH
31941: LD_INT 2
31943: NEG
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PUSH
31949: EMPTY
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: LIST
31955: LIST
31956: LIST
31957: LIST
31958: LIST
31959: LIST
31960: LIST
31961: LIST
31962: LIST
31963: LIST
31964: LIST
31965: LIST
31966: LIST
31967: LIST
31968: LIST
31969: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31970: LD_ADDR_VAR 0 20
31974: PUSH
31975: LD_INT 0
31977: PUSH
31978: LD_INT 0
31980: PUSH
31981: EMPTY
31982: LIST
31983: LIST
31984: PUSH
31985: LD_INT 0
31987: PUSH
31988: LD_INT 1
31990: NEG
31991: PUSH
31992: EMPTY
31993: LIST
31994: LIST
31995: PUSH
31996: LD_INT 1
31998: PUSH
31999: LD_INT 0
32001: PUSH
32002: EMPTY
32003: LIST
32004: LIST
32005: PUSH
32006: LD_INT 1
32008: PUSH
32009: LD_INT 1
32011: PUSH
32012: EMPTY
32013: LIST
32014: LIST
32015: PUSH
32016: LD_INT 0
32018: PUSH
32019: LD_INT 1
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 1
32028: NEG
32029: PUSH
32030: LD_INT 0
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: LD_INT 1
32039: NEG
32040: PUSH
32041: LD_INT 1
32043: NEG
32044: PUSH
32045: EMPTY
32046: LIST
32047: LIST
32048: PUSH
32049: LD_INT 1
32051: NEG
32052: PUSH
32053: LD_INT 2
32055: NEG
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 0
32063: PUSH
32064: LD_INT 2
32066: NEG
32067: PUSH
32068: EMPTY
32069: LIST
32070: LIST
32071: PUSH
32072: LD_INT 1
32074: PUSH
32075: LD_INT 1
32077: NEG
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: PUSH
32083: LD_INT 2
32085: PUSH
32086: LD_INT 0
32088: PUSH
32089: EMPTY
32090: LIST
32091: LIST
32092: PUSH
32093: LD_INT 2
32095: PUSH
32096: LD_INT 1
32098: PUSH
32099: EMPTY
32100: LIST
32101: LIST
32102: PUSH
32103: LD_INT 2
32105: PUSH
32106: LD_INT 2
32108: PUSH
32109: EMPTY
32110: LIST
32111: LIST
32112: PUSH
32113: LD_INT 1
32115: PUSH
32116: LD_INT 2
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: PUSH
32123: LD_INT 0
32125: PUSH
32126: LD_INT 2
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 1
32135: NEG
32136: PUSH
32137: LD_INT 1
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 2
32146: NEG
32147: PUSH
32148: LD_INT 0
32150: PUSH
32151: EMPTY
32152: LIST
32153: LIST
32154: PUSH
32155: LD_INT 2
32157: NEG
32158: PUSH
32159: LD_INT 1
32161: NEG
32162: PUSH
32163: EMPTY
32164: LIST
32165: LIST
32166: PUSH
32167: LD_INT 2
32169: NEG
32170: PUSH
32171: LD_INT 2
32173: NEG
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32200: LD_ADDR_VAR 0 21
32204: PUSH
32205: LD_INT 0
32207: PUSH
32208: LD_INT 0
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: LD_INT 1
32220: NEG
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 1
32228: PUSH
32229: LD_INT 0
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: LD_INT 1
32238: PUSH
32239: LD_INT 1
32241: PUSH
32242: EMPTY
32243: LIST
32244: LIST
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: LD_INT 1
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 1
32258: NEG
32259: PUSH
32260: LD_INT 0
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: LD_INT 1
32269: NEG
32270: PUSH
32271: LD_INT 1
32273: NEG
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 1
32281: NEG
32282: PUSH
32283: LD_INT 2
32285: NEG
32286: PUSH
32287: EMPTY
32288: LIST
32289: LIST
32290: PUSH
32291: LD_INT 0
32293: PUSH
32294: LD_INT 2
32296: NEG
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 1
32304: PUSH
32305: LD_INT 1
32307: NEG
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: PUSH
32313: LD_INT 2
32315: PUSH
32316: LD_INT 0
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 2
32325: PUSH
32326: LD_INT 1
32328: PUSH
32329: EMPTY
32330: LIST
32331: LIST
32332: PUSH
32333: LD_INT 2
32335: PUSH
32336: LD_INT 2
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: PUSH
32343: LD_INT 1
32345: PUSH
32346: LD_INT 2
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: LD_INT 2
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 1
32365: NEG
32366: PUSH
32367: LD_INT 1
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: NEG
32377: PUSH
32378: LD_INT 0
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 2
32387: NEG
32388: PUSH
32389: LD_INT 1
32391: NEG
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 2
32399: NEG
32400: PUSH
32401: LD_INT 2
32403: NEG
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: LIST
32413: LIST
32414: LIST
32415: LIST
32416: LIST
32417: LIST
32418: LIST
32419: LIST
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32430: LD_ADDR_VAR 0 22
32434: PUSH
32435: LD_INT 0
32437: PUSH
32438: LD_INT 0
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 0
32447: PUSH
32448: LD_INT 1
32450: NEG
32451: PUSH
32452: EMPTY
32453: LIST
32454: LIST
32455: PUSH
32456: LD_INT 1
32458: PUSH
32459: LD_INT 0
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 1
32468: PUSH
32469: LD_INT 1
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 0
32478: PUSH
32479: LD_INT 1
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: LD_INT 1
32488: NEG
32489: PUSH
32490: LD_INT 0
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: PUSH
32497: LD_INT 1
32499: NEG
32500: PUSH
32501: LD_INT 1
32503: NEG
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 1
32511: NEG
32512: PUSH
32513: LD_INT 2
32515: NEG
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 0
32523: PUSH
32524: LD_INT 2
32526: NEG
32527: PUSH
32528: EMPTY
32529: LIST
32530: LIST
32531: PUSH
32532: LD_INT 1
32534: PUSH
32535: LD_INT 1
32537: NEG
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: LD_INT 2
32545: PUSH
32546: LD_INT 0
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 2
32555: PUSH
32556: LD_INT 1
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: PUSH
32563: LD_INT 2
32565: PUSH
32566: LD_INT 2
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 1
32575: PUSH
32576: LD_INT 2
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 0
32585: PUSH
32586: LD_INT 2
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: PUSH
32593: LD_INT 1
32595: NEG
32596: PUSH
32597: LD_INT 1
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 2
32606: NEG
32607: PUSH
32608: LD_INT 0
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 2
32617: NEG
32618: PUSH
32619: LD_INT 1
32621: NEG
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 2
32629: NEG
32630: PUSH
32631: LD_INT 2
32633: NEG
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32660: LD_ADDR_VAR 0 23
32664: PUSH
32665: LD_INT 0
32667: PUSH
32668: LD_INT 0
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 0
32677: PUSH
32678: LD_INT 1
32680: NEG
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 1
32688: PUSH
32689: LD_INT 0
32691: PUSH
32692: EMPTY
32693: LIST
32694: LIST
32695: PUSH
32696: LD_INT 1
32698: PUSH
32699: LD_INT 1
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PUSH
32706: LD_INT 0
32708: PUSH
32709: LD_INT 1
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 1
32718: NEG
32719: PUSH
32720: LD_INT 0
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 1
32729: NEG
32730: PUSH
32731: LD_INT 1
32733: NEG
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: LD_INT 1
32741: NEG
32742: PUSH
32743: LD_INT 2
32745: NEG
32746: PUSH
32747: EMPTY
32748: LIST
32749: LIST
32750: PUSH
32751: LD_INT 0
32753: PUSH
32754: LD_INT 2
32756: NEG
32757: PUSH
32758: EMPTY
32759: LIST
32760: LIST
32761: PUSH
32762: LD_INT 1
32764: PUSH
32765: LD_INT 1
32767: NEG
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PUSH
32773: LD_INT 2
32775: PUSH
32776: LD_INT 0
32778: PUSH
32779: EMPTY
32780: LIST
32781: LIST
32782: PUSH
32783: LD_INT 2
32785: PUSH
32786: LD_INT 1
32788: PUSH
32789: EMPTY
32790: LIST
32791: LIST
32792: PUSH
32793: LD_INT 2
32795: PUSH
32796: LD_INT 2
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: LD_INT 1
32805: PUSH
32806: LD_INT 2
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: PUSH
32813: LD_INT 0
32815: PUSH
32816: LD_INT 2
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: LD_INT 1
32825: NEG
32826: PUSH
32827: LD_INT 1
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 2
32836: NEG
32837: PUSH
32838: LD_INT 0
32840: PUSH
32841: EMPTY
32842: LIST
32843: LIST
32844: PUSH
32845: LD_INT 2
32847: NEG
32848: PUSH
32849: LD_INT 1
32851: NEG
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 2
32859: NEG
32860: PUSH
32861: LD_INT 2
32863: NEG
32864: PUSH
32865: EMPTY
32866: LIST
32867: LIST
32868: PUSH
32869: LD_INT 2
32871: NEG
32872: PUSH
32873: LD_INT 3
32875: NEG
32876: PUSH
32877: EMPTY
32878: LIST
32879: LIST
32880: PUSH
32881: LD_INT 1
32883: NEG
32884: PUSH
32885: LD_INT 3
32887: NEG
32888: PUSH
32889: EMPTY
32890: LIST
32891: LIST
32892: PUSH
32893: LD_INT 1
32895: PUSH
32896: LD_INT 2
32898: NEG
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: PUSH
32904: LD_INT 2
32906: PUSH
32907: LD_INT 1
32909: NEG
32910: PUSH
32911: EMPTY
32912: LIST
32913: LIST
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32940: LD_ADDR_VAR 0 24
32944: PUSH
32945: LD_INT 0
32947: PUSH
32948: LD_INT 0
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 0
32957: PUSH
32958: LD_INT 1
32960: NEG
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: PUSH
32966: LD_INT 1
32968: PUSH
32969: LD_INT 0
32971: PUSH
32972: EMPTY
32973: LIST
32974: LIST
32975: PUSH
32976: LD_INT 1
32978: PUSH
32979: LD_INT 1
32981: PUSH
32982: EMPTY
32983: LIST
32984: LIST
32985: PUSH
32986: LD_INT 0
32988: PUSH
32989: LD_INT 1
32991: PUSH
32992: EMPTY
32993: LIST
32994: LIST
32995: PUSH
32996: LD_INT 1
32998: NEG
32999: PUSH
33000: LD_INT 0
33002: PUSH
33003: EMPTY
33004: LIST
33005: LIST
33006: PUSH
33007: LD_INT 1
33009: NEG
33010: PUSH
33011: LD_INT 1
33013: NEG
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 1
33021: NEG
33022: PUSH
33023: LD_INT 2
33025: NEG
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: LD_INT 0
33033: PUSH
33034: LD_INT 2
33036: NEG
33037: PUSH
33038: EMPTY
33039: LIST
33040: LIST
33041: PUSH
33042: LD_INT 1
33044: PUSH
33045: LD_INT 1
33047: NEG
33048: PUSH
33049: EMPTY
33050: LIST
33051: LIST
33052: PUSH
33053: LD_INT 2
33055: PUSH
33056: LD_INT 0
33058: PUSH
33059: EMPTY
33060: LIST
33061: LIST
33062: PUSH
33063: LD_INT 2
33065: PUSH
33066: LD_INT 1
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 2
33075: PUSH
33076: LD_INT 2
33078: PUSH
33079: EMPTY
33080: LIST
33081: LIST
33082: PUSH
33083: LD_INT 1
33085: PUSH
33086: LD_INT 2
33088: PUSH
33089: EMPTY
33090: LIST
33091: LIST
33092: PUSH
33093: LD_INT 0
33095: PUSH
33096: LD_INT 2
33098: PUSH
33099: EMPTY
33100: LIST
33101: LIST
33102: PUSH
33103: LD_INT 1
33105: NEG
33106: PUSH
33107: LD_INT 1
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 2
33116: NEG
33117: PUSH
33118: LD_INT 0
33120: PUSH
33121: EMPTY
33122: LIST
33123: LIST
33124: PUSH
33125: LD_INT 2
33127: NEG
33128: PUSH
33129: LD_INT 1
33131: NEG
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: PUSH
33137: LD_INT 2
33139: NEG
33140: PUSH
33141: LD_INT 2
33143: NEG
33144: PUSH
33145: EMPTY
33146: LIST
33147: LIST
33148: PUSH
33149: LD_INT 1
33151: PUSH
33152: LD_INT 2
33154: NEG
33155: PUSH
33156: EMPTY
33157: LIST
33158: LIST
33159: PUSH
33160: LD_INT 2
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 3
33173: PUSH
33174: LD_INT 1
33176: PUSH
33177: EMPTY
33178: LIST
33179: LIST
33180: PUSH
33181: LD_INT 3
33183: PUSH
33184: LD_INT 2
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: LIST
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: LIST
33215: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
33216: LD_ADDR_VAR 0 25
33220: PUSH
33221: LD_INT 0
33223: PUSH
33224: LD_INT 0
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 0
33233: PUSH
33234: LD_INT 1
33236: NEG
33237: PUSH
33238: EMPTY
33239: LIST
33240: LIST
33241: PUSH
33242: LD_INT 1
33244: PUSH
33245: LD_INT 0
33247: PUSH
33248: EMPTY
33249: LIST
33250: LIST
33251: PUSH
33252: LD_INT 1
33254: PUSH
33255: LD_INT 1
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: PUSH
33262: LD_INT 0
33264: PUSH
33265: LD_INT 1
33267: PUSH
33268: EMPTY
33269: LIST
33270: LIST
33271: PUSH
33272: LD_INT 1
33274: NEG
33275: PUSH
33276: LD_INT 0
33278: PUSH
33279: EMPTY
33280: LIST
33281: LIST
33282: PUSH
33283: LD_INT 1
33285: NEG
33286: PUSH
33287: LD_INT 1
33289: NEG
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 1
33297: NEG
33298: PUSH
33299: LD_INT 2
33301: NEG
33302: PUSH
33303: EMPTY
33304: LIST
33305: LIST
33306: PUSH
33307: LD_INT 0
33309: PUSH
33310: LD_INT 2
33312: NEG
33313: PUSH
33314: EMPTY
33315: LIST
33316: LIST
33317: PUSH
33318: LD_INT 1
33320: PUSH
33321: LD_INT 1
33323: NEG
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 2
33331: PUSH
33332: LD_INT 0
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 2
33341: PUSH
33342: LD_INT 1
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 2
33351: PUSH
33352: LD_INT 2
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: LD_INT 1
33361: PUSH
33362: LD_INT 2
33364: PUSH
33365: EMPTY
33366: LIST
33367: LIST
33368: PUSH
33369: LD_INT 0
33371: PUSH
33372: LD_INT 2
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: LD_INT 1
33381: NEG
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 2
33392: NEG
33393: PUSH
33394: LD_INT 0
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 2
33403: NEG
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 2
33415: NEG
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 3
33427: PUSH
33428: LD_INT 1
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 3
33437: PUSH
33438: LD_INT 2
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 2
33447: PUSH
33448: LD_INT 3
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 1
33457: PUSH
33458: LD_INT 3
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: EMPTY
33466: LIST
33467: LIST
33468: LIST
33469: LIST
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33490: LD_ADDR_VAR 0 26
33494: PUSH
33495: LD_INT 0
33497: PUSH
33498: LD_INT 0
33500: PUSH
33501: EMPTY
33502: LIST
33503: LIST
33504: PUSH
33505: LD_INT 0
33507: PUSH
33508: LD_INT 1
33510: NEG
33511: PUSH
33512: EMPTY
33513: LIST
33514: LIST
33515: PUSH
33516: LD_INT 1
33518: PUSH
33519: LD_INT 0
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PUSH
33526: LD_INT 1
33528: PUSH
33529: LD_INT 1
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 0
33538: PUSH
33539: LD_INT 1
33541: PUSH
33542: EMPTY
33543: LIST
33544: LIST
33545: PUSH
33546: LD_INT 1
33548: NEG
33549: PUSH
33550: LD_INT 0
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PUSH
33557: LD_INT 1
33559: NEG
33560: PUSH
33561: LD_INT 1
33563: NEG
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 1
33571: NEG
33572: PUSH
33573: LD_INT 2
33575: NEG
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 0
33583: PUSH
33584: LD_INT 2
33586: NEG
33587: PUSH
33588: EMPTY
33589: LIST
33590: LIST
33591: PUSH
33592: LD_INT 1
33594: PUSH
33595: LD_INT 1
33597: NEG
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PUSH
33603: LD_INT 2
33605: PUSH
33606: LD_INT 0
33608: PUSH
33609: EMPTY
33610: LIST
33611: LIST
33612: PUSH
33613: LD_INT 2
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: EMPTY
33620: LIST
33621: LIST
33622: PUSH
33623: LD_INT 2
33625: PUSH
33626: LD_INT 2
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PUSH
33633: LD_INT 1
33635: PUSH
33636: LD_INT 2
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 0
33645: PUSH
33646: LD_INT 2
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 1
33655: NEG
33656: PUSH
33657: LD_INT 1
33659: PUSH
33660: EMPTY
33661: LIST
33662: LIST
33663: PUSH
33664: LD_INT 2
33666: NEG
33667: PUSH
33668: LD_INT 0
33670: PUSH
33671: EMPTY
33672: LIST
33673: LIST
33674: PUSH
33675: LD_INT 2
33677: NEG
33678: PUSH
33679: LD_INT 1
33681: NEG
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 2
33689: NEG
33690: PUSH
33691: LD_INT 2
33693: NEG
33694: PUSH
33695: EMPTY
33696: LIST
33697: LIST
33698: PUSH
33699: LD_INT 2
33701: PUSH
33702: LD_INT 3
33704: PUSH
33705: EMPTY
33706: LIST
33707: LIST
33708: PUSH
33709: LD_INT 1
33711: PUSH
33712: LD_INT 3
33714: PUSH
33715: EMPTY
33716: LIST
33717: LIST
33718: PUSH
33719: LD_INT 1
33721: NEG
33722: PUSH
33723: LD_INT 2
33725: PUSH
33726: EMPTY
33727: LIST
33728: LIST
33729: PUSH
33730: LD_INT 2
33732: NEG
33733: PUSH
33734: LD_INT 1
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: LIST
33745: LIST
33746: LIST
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: LIST
33762: LIST
33763: LIST
33764: LIST
33765: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33766: LD_ADDR_VAR 0 27
33770: PUSH
33771: LD_INT 0
33773: PUSH
33774: LD_INT 0
33776: PUSH
33777: EMPTY
33778: LIST
33779: LIST
33780: PUSH
33781: LD_INT 0
33783: PUSH
33784: LD_INT 1
33786: NEG
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 1
33794: PUSH
33795: LD_INT 0
33797: PUSH
33798: EMPTY
33799: LIST
33800: LIST
33801: PUSH
33802: LD_INT 1
33804: PUSH
33805: LD_INT 1
33807: PUSH
33808: EMPTY
33809: LIST
33810: LIST
33811: PUSH
33812: LD_INT 0
33814: PUSH
33815: LD_INT 1
33817: PUSH
33818: EMPTY
33819: LIST
33820: LIST
33821: PUSH
33822: LD_INT 1
33824: NEG
33825: PUSH
33826: LD_INT 0
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: PUSH
33833: LD_INT 1
33835: NEG
33836: PUSH
33837: LD_INT 1
33839: NEG
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: LD_INT 1
33847: NEG
33848: PUSH
33849: LD_INT 2
33851: NEG
33852: PUSH
33853: EMPTY
33854: LIST
33855: LIST
33856: PUSH
33857: LD_INT 0
33859: PUSH
33860: LD_INT 2
33862: NEG
33863: PUSH
33864: EMPTY
33865: LIST
33866: LIST
33867: PUSH
33868: LD_INT 1
33870: PUSH
33871: LD_INT 1
33873: NEG
33874: PUSH
33875: EMPTY
33876: LIST
33877: LIST
33878: PUSH
33879: LD_INT 2
33881: PUSH
33882: LD_INT 0
33884: PUSH
33885: EMPTY
33886: LIST
33887: LIST
33888: PUSH
33889: LD_INT 2
33891: PUSH
33892: LD_INT 1
33894: PUSH
33895: EMPTY
33896: LIST
33897: LIST
33898: PUSH
33899: LD_INT 2
33901: PUSH
33902: LD_INT 2
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 1
33911: PUSH
33912: LD_INT 2
33914: PUSH
33915: EMPTY
33916: LIST
33917: LIST
33918: PUSH
33919: LD_INT 0
33921: PUSH
33922: LD_INT 2
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 1
33931: NEG
33932: PUSH
33933: LD_INT 1
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: PUSH
33940: LD_INT 2
33942: NEG
33943: PUSH
33944: LD_INT 0
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: LD_INT 2
33953: NEG
33954: PUSH
33955: LD_INT 1
33957: NEG
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 2
33965: NEG
33966: PUSH
33967: LD_INT 2
33969: NEG
33970: PUSH
33971: EMPTY
33972: LIST
33973: LIST
33974: PUSH
33975: LD_INT 1
33977: NEG
33978: PUSH
33979: LD_INT 2
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: PUSH
33986: LD_INT 2
33988: NEG
33989: PUSH
33990: LD_INT 1
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: PUSH
33997: LD_INT 3
33999: NEG
34000: PUSH
34001: LD_INT 1
34003: NEG
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: PUSH
34009: LD_INT 3
34011: NEG
34012: PUSH
34013: LD_INT 2
34015: NEG
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34046: LD_ADDR_VAR 0 28
34050: PUSH
34051: LD_INT 0
34053: PUSH
34054: LD_INT 0
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 0
34063: PUSH
34064: LD_INT 1
34066: NEG
34067: PUSH
34068: EMPTY
34069: LIST
34070: LIST
34071: PUSH
34072: LD_INT 1
34074: PUSH
34075: LD_INT 0
34077: PUSH
34078: EMPTY
34079: LIST
34080: LIST
34081: PUSH
34082: LD_INT 1
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: PUSH
34092: LD_INT 0
34094: PUSH
34095: LD_INT 1
34097: PUSH
34098: EMPTY
34099: LIST
34100: LIST
34101: PUSH
34102: LD_INT 1
34104: NEG
34105: PUSH
34106: LD_INT 0
34108: PUSH
34109: EMPTY
34110: LIST
34111: LIST
34112: PUSH
34113: LD_INT 1
34115: NEG
34116: PUSH
34117: LD_INT 1
34119: NEG
34120: PUSH
34121: EMPTY
34122: LIST
34123: LIST
34124: PUSH
34125: LD_INT 1
34127: NEG
34128: PUSH
34129: LD_INT 2
34131: NEG
34132: PUSH
34133: EMPTY
34134: LIST
34135: LIST
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: LD_INT 2
34142: NEG
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 1
34150: PUSH
34151: LD_INT 1
34153: NEG
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 2
34161: PUSH
34162: LD_INT 0
34164: PUSH
34165: EMPTY
34166: LIST
34167: LIST
34168: PUSH
34169: LD_INT 2
34171: PUSH
34172: LD_INT 1
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PUSH
34179: LD_INT 2
34181: PUSH
34182: LD_INT 2
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: LD_INT 1
34191: PUSH
34192: LD_INT 2
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 0
34201: PUSH
34202: LD_INT 2
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 1
34211: NEG
34212: PUSH
34213: LD_INT 1
34215: PUSH
34216: EMPTY
34217: LIST
34218: LIST
34219: PUSH
34220: LD_INT 2
34222: NEG
34223: PUSH
34224: LD_INT 0
34226: PUSH
34227: EMPTY
34228: LIST
34229: LIST
34230: PUSH
34231: LD_INT 2
34233: NEG
34234: PUSH
34235: LD_INT 1
34237: NEG
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: PUSH
34243: LD_INT 2
34245: NEG
34246: PUSH
34247: LD_INT 2
34249: NEG
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 2
34257: NEG
34258: PUSH
34259: LD_INT 3
34261: NEG
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: LD_INT 1
34269: NEG
34270: PUSH
34271: LD_INT 3
34273: NEG
34274: PUSH
34275: EMPTY
34276: LIST
34277: LIST
34278: PUSH
34279: LD_INT 3
34281: NEG
34282: PUSH
34283: LD_INT 1
34285: NEG
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: LD_INT 3
34293: NEG
34294: PUSH
34295: LD_INT 2
34297: NEG
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: LIST
34307: LIST
34308: LIST
34309: LIST
34310: LIST
34311: LIST
34312: LIST
34313: LIST
34314: LIST
34315: LIST
34316: LIST
34317: LIST
34318: LIST
34319: LIST
34320: LIST
34321: LIST
34322: LIST
34323: LIST
34324: LIST
34325: LIST
34326: LIST
34327: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34328: LD_ADDR_VAR 0 29
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: LD_INT 0
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 0
34345: PUSH
34346: LD_INT 1
34348: NEG
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: PUSH
34357: LD_INT 0
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 1
34366: PUSH
34367: LD_INT 1
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: LD_INT 0
34376: PUSH
34377: LD_INT 1
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PUSH
34384: LD_INT 1
34386: NEG
34387: PUSH
34388: LD_INT 0
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 1
34397: NEG
34398: PUSH
34399: LD_INT 1
34401: NEG
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 1
34409: NEG
34410: PUSH
34411: LD_INT 2
34413: NEG
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 0
34421: PUSH
34422: LD_INT 2
34424: NEG
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 1
34432: PUSH
34433: LD_INT 1
34435: NEG
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 2
34443: PUSH
34444: LD_INT 0
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 2
34453: PUSH
34454: LD_INT 1
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 1
34463: PUSH
34464: LD_INT 2
34466: PUSH
34467: EMPTY
34468: LIST
34469: LIST
34470: PUSH
34471: LD_INT 0
34473: PUSH
34474: LD_INT 2
34476: PUSH
34477: EMPTY
34478: LIST
34479: LIST
34480: PUSH
34481: LD_INT 1
34483: NEG
34484: PUSH
34485: LD_INT 1
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 2
34494: NEG
34495: PUSH
34496: LD_INT 1
34498: NEG
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: LD_INT 2
34506: NEG
34507: PUSH
34508: LD_INT 2
34510: NEG
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 2
34518: NEG
34519: PUSH
34520: LD_INT 3
34522: NEG
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 2
34530: PUSH
34531: LD_INT 1
34533: NEG
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: LD_INT 3
34541: PUSH
34542: LD_INT 1
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 1
34551: PUSH
34552: LD_INT 3
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 1
34561: NEG
34562: PUSH
34563: LD_INT 2
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 3
34572: NEG
34573: PUSH
34574: LD_INT 2
34576: NEG
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: LIST
34586: LIST
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: LIST
34602: LIST
34603: LIST
34604: LIST
34605: LIST
34606: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34607: LD_ADDR_VAR 0 30
34611: PUSH
34612: LD_INT 0
34614: PUSH
34615: LD_INT 0
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 0
34624: PUSH
34625: LD_INT 1
34627: NEG
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 1
34635: PUSH
34636: LD_INT 0
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 1
34645: PUSH
34646: LD_INT 1
34648: PUSH
34649: EMPTY
34650: LIST
34651: LIST
34652: PUSH
34653: LD_INT 0
34655: PUSH
34656: LD_INT 1
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 1
34665: NEG
34666: PUSH
34667: LD_INT 0
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PUSH
34674: LD_INT 1
34676: NEG
34677: PUSH
34678: LD_INT 1
34680: NEG
34681: PUSH
34682: EMPTY
34683: LIST
34684: LIST
34685: PUSH
34686: LD_INT 1
34688: NEG
34689: PUSH
34690: LD_INT 2
34692: NEG
34693: PUSH
34694: EMPTY
34695: LIST
34696: LIST
34697: PUSH
34698: LD_INT 0
34700: PUSH
34701: LD_INT 2
34703: NEG
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 1
34711: PUSH
34712: LD_INT 1
34714: NEG
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 2
34722: PUSH
34723: LD_INT 0
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 2
34732: PUSH
34733: LD_INT 1
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PUSH
34740: LD_INT 2
34742: PUSH
34743: LD_INT 2
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 1
34752: PUSH
34753: LD_INT 2
34755: PUSH
34756: EMPTY
34757: LIST
34758: LIST
34759: PUSH
34760: LD_INT 1
34762: NEG
34763: PUSH
34764: LD_INT 1
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 2
34773: NEG
34774: PUSH
34775: LD_INT 0
34777: PUSH
34778: EMPTY
34779: LIST
34780: LIST
34781: PUSH
34782: LD_INT 2
34784: NEG
34785: PUSH
34786: LD_INT 1
34788: NEG
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 1
34796: NEG
34797: PUSH
34798: LD_INT 3
34800: NEG
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 1
34808: PUSH
34809: LD_INT 2
34811: NEG
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 3
34819: PUSH
34820: LD_INT 2
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 2
34829: PUSH
34830: LD_INT 3
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 2
34839: NEG
34840: PUSH
34841: LD_INT 1
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 3
34850: NEG
34851: PUSH
34852: LD_INT 1
34854: NEG
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: LIST
34864: LIST
34865: LIST
34866: LIST
34867: LIST
34868: LIST
34869: LIST
34870: LIST
34871: LIST
34872: LIST
34873: LIST
34874: LIST
34875: LIST
34876: LIST
34877: LIST
34878: LIST
34879: LIST
34880: LIST
34881: LIST
34882: LIST
34883: LIST
34884: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34885: LD_ADDR_VAR 0 31
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: LD_INT 0
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 0
34902: PUSH
34903: LD_INT 1
34905: NEG
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 1
34913: PUSH
34914: LD_INT 0
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 1
34923: PUSH
34924: LD_INT 1
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PUSH
34931: LD_INT 0
34933: PUSH
34934: LD_INT 1
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 1
34943: NEG
34944: PUSH
34945: LD_INT 0
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 1
34954: NEG
34955: PUSH
34956: LD_INT 1
34958: NEG
34959: PUSH
34960: EMPTY
34961: LIST
34962: LIST
34963: PUSH
34964: LD_INT 1
34966: NEG
34967: PUSH
34968: LD_INT 2
34970: NEG
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PUSH
34976: LD_INT 1
34978: PUSH
34979: LD_INT 1
34981: NEG
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 2
34989: PUSH
34990: LD_INT 0
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 2
34999: PUSH
35000: LD_INT 1
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: PUSH
35010: LD_INT 2
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: PUSH
35017: LD_INT 1
35019: PUSH
35020: LD_INT 2
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: LD_INT 2
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 1
35039: NEG
35040: PUSH
35041: LD_INT 1
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: LD_INT 2
35050: NEG
35051: PUSH
35052: LD_INT 1
35054: NEG
35055: PUSH
35056: EMPTY
35057: LIST
35058: LIST
35059: PUSH
35060: LD_INT 2
35062: NEG
35063: PUSH
35064: LD_INT 2
35066: NEG
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: LD_INT 2
35074: NEG
35075: PUSH
35076: LD_INT 3
35078: NEG
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 2
35086: PUSH
35087: LD_INT 1
35089: NEG
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 3
35097: PUSH
35098: LD_INT 1
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: PUSH
35105: LD_INT 1
35107: PUSH
35108: LD_INT 3
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: PUSH
35115: LD_INT 1
35117: NEG
35118: PUSH
35119: LD_INT 2
35121: PUSH
35122: EMPTY
35123: LIST
35124: LIST
35125: PUSH
35126: LD_INT 3
35128: NEG
35129: PUSH
35130: LD_INT 2
35132: NEG
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: LIST
35142: LIST
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: LIST
35157: LIST
35158: LIST
35159: LIST
35160: LIST
35161: LIST
35162: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35163: LD_ADDR_VAR 0 32
35167: PUSH
35168: LD_INT 0
35170: PUSH
35171: LD_INT 0
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 0
35180: PUSH
35181: LD_INT 1
35183: NEG
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: PUSH
35192: LD_INT 0
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 1
35201: PUSH
35202: LD_INT 1
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: PUSH
35209: LD_INT 0
35211: PUSH
35212: LD_INT 1
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 1
35221: NEG
35222: PUSH
35223: LD_INT 0
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: PUSH
35230: LD_INT 1
35232: NEG
35233: PUSH
35234: LD_INT 1
35236: NEG
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PUSH
35242: LD_INT 1
35244: NEG
35245: PUSH
35246: LD_INT 2
35248: NEG
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 0
35256: PUSH
35257: LD_INT 2
35259: NEG
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 1
35267: PUSH
35268: LD_INT 1
35270: NEG
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 2
35278: PUSH
35279: LD_INT 1
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 2
35288: PUSH
35289: LD_INT 2
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: LD_INT 1
35298: PUSH
35299: LD_INT 2
35301: PUSH
35302: EMPTY
35303: LIST
35304: LIST
35305: PUSH
35306: LD_INT 0
35308: PUSH
35309: LD_INT 2
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 1
35318: NEG
35319: PUSH
35320: LD_INT 1
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 2
35329: NEG
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 2
35340: NEG
35341: PUSH
35342: LD_INT 1
35344: NEG
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: PUSH
35350: LD_INT 1
35352: NEG
35353: PUSH
35354: LD_INT 3
35356: NEG
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 1
35364: PUSH
35365: LD_INT 2
35367: NEG
35368: PUSH
35369: EMPTY
35370: LIST
35371: LIST
35372: PUSH
35373: LD_INT 3
35375: PUSH
35376: LD_INT 2
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 2
35385: PUSH
35386: LD_INT 3
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 2
35395: NEG
35396: PUSH
35397: LD_INT 1
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 3
35406: NEG
35407: PUSH
35408: LD_INT 1
35410: NEG
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: LIST
35440: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35441: LD_ADDR_VAR 0 33
35445: PUSH
35446: LD_INT 0
35448: PUSH
35449: LD_INT 0
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: LD_INT 0
35458: PUSH
35459: LD_INT 1
35461: NEG
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 1
35469: PUSH
35470: LD_INT 0
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 1
35479: PUSH
35480: LD_INT 1
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: LD_INT 1
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: NEG
35500: PUSH
35501: LD_INT 0
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 1
35510: NEG
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 1
35522: NEG
35523: PUSH
35524: LD_INT 2
35526: NEG
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 1
35534: PUSH
35535: LD_INT 1
35537: NEG
35538: PUSH
35539: EMPTY
35540: LIST
35541: LIST
35542: PUSH
35543: LD_INT 2
35545: PUSH
35546: LD_INT 0
35548: PUSH
35549: EMPTY
35550: LIST
35551: LIST
35552: PUSH
35553: LD_INT 2
35555: PUSH
35556: LD_INT 1
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 1
35565: PUSH
35566: LD_INT 2
35568: PUSH
35569: EMPTY
35570: LIST
35571: LIST
35572: PUSH
35573: LD_INT 0
35575: PUSH
35576: LD_INT 2
35578: PUSH
35579: EMPTY
35580: LIST
35581: LIST
35582: PUSH
35583: LD_INT 1
35585: NEG
35586: PUSH
35587: LD_INT 1
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 2
35596: NEG
35597: PUSH
35598: LD_INT 0
35600: PUSH
35601: EMPTY
35602: LIST
35603: LIST
35604: PUSH
35605: LD_INT 2
35607: NEG
35608: PUSH
35609: LD_INT 1
35611: NEG
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 2
35619: NEG
35620: PUSH
35621: LD_INT 2
35623: NEG
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 2
35631: NEG
35632: PUSH
35633: LD_INT 3
35635: NEG
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 2
35643: PUSH
35644: LD_INT 1
35646: NEG
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 3
35654: PUSH
35655: LD_INT 1
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 1
35664: PUSH
35665: LD_INT 3
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 1
35674: NEG
35675: PUSH
35676: LD_INT 2
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: LD_INT 3
35685: NEG
35686: PUSH
35687: LD_INT 2
35689: NEG
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: LIST
35699: LIST
35700: LIST
35701: LIST
35702: LIST
35703: LIST
35704: LIST
35705: LIST
35706: LIST
35707: LIST
35708: LIST
35709: LIST
35710: LIST
35711: LIST
35712: LIST
35713: LIST
35714: LIST
35715: LIST
35716: LIST
35717: LIST
35718: LIST
35719: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35720: LD_ADDR_VAR 0 34
35724: PUSH
35725: LD_INT 0
35727: PUSH
35728: LD_INT 0
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 0
35737: PUSH
35738: LD_INT 1
35740: NEG
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 1
35748: PUSH
35749: LD_INT 0
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 1
35758: PUSH
35759: LD_INT 1
35761: PUSH
35762: EMPTY
35763: LIST
35764: LIST
35765: PUSH
35766: LD_INT 0
35768: PUSH
35769: LD_INT 1
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PUSH
35776: LD_INT 1
35778: NEG
35779: PUSH
35780: LD_INT 0
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: LD_INT 1
35793: NEG
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 1
35801: NEG
35802: PUSH
35803: LD_INT 2
35805: NEG
35806: PUSH
35807: EMPTY
35808: LIST
35809: LIST
35810: PUSH
35811: LD_INT 0
35813: PUSH
35814: LD_INT 2
35816: NEG
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: LD_INT 1
35824: PUSH
35825: LD_INT 1
35827: NEG
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: PUSH
35833: LD_INT 2
35835: PUSH
35836: LD_INT 1
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PUSH
35843: LD_INT 2
35845: PUSH
35846: LD_INT 2
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: LD_INT 1
35855: PUSH
35856: LD_INT 2
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: LD_INT 1
35865: NEG
35866: PUSH
35867: LD_INT 1
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 2
35876: NEG
35877: PUSH
35878: LD_INT 0
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 2
35887: NEG
35888: PUSH
35889: LD_INT 1
35891: NEG
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 2
35899: NEG
35900: PUSH
35901: LD_INT 2
35903: NEG
35904: PUSH
35905: EMPTY
35906: LIST
35907: LIST
35908: PUSH
35909: LD_INT 1
35911: NEG
35912: PUSH
35913: LD_INT 3
35915: NEG
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: PUSH
35921: LD_INT 1
35923: PUSH
35924: LD_INT 2
35926: NEG
35927: PUSH
35928: EMPTY
35929: LIST
35930: LIST
35931: PUSH
35932: LD_INT 3
35934: PUSH
35935: LD_INT 2
35937: PUSH
35938: EMPTY
35939: LIST
35940: LIST
35941: PUSH
35942: LD_INT 2
35944: PUSH
35945: LD_INT 3
35947: PUSH
35948: EMPTY
35949: LIST
35950: LIST
35951: PUSH
35952: LD_INT 2
35954: NEG
35955: PUSH
35956: LD_INT 1
35958: PUSH
35959: EMPTY
35960: LIST
35961: LIST
35962: PUSH
35963: LD_INT 3
35965: NEG
35966: PUSH
35967: LD_INT 1
35969: NEG
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36000: LD_ADDR_VAR 0 35
36004: PUSH
36005: LD_INT 0
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: EMPTY
36012: LIST
36013: LIST
36014: PUSH
36015: LD_INT 0
36017: PUSH
36018: LD_INT 1
36020: NEG
36021: PUSH
36022: EMPTY
36023: LIST
36024: LIST
36025: PUSH
36026: LD_INT 1
36028: PUSH
36029: LD_INT 0
36031: PUSH
36032: EMPTY
36033: LIST
36034: LIST
36035: PUSH
36036: LD_INT 1
36038: PUSH
36039: LD_INT 1
36041: PUSH
36042: EMPTY
36043: LIST
36044: LIST
36045: PUSH
36046: LD_INT 0
36048: PUSH
36049: LD_INT 1
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 1
36058: NEG
36059: PUSH
36060: LD_INT 0
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 1
36069: NEG
36070: PUSH
36071: LD_INT 1
36073: NEG
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 2
36081: PUSH
36082: LD_INT 1
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 2
36091: NEG
36092: PUSH
36093: LD_INT 1
36095: NEG
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: EMPTY
36102: LIST
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36112: LD_ADDR_VAR 0 36
36116: PUSH
36117: LD_INT 0
36119: PUSH
36120: LD_INT 0
36122: PUSH
36123: EMPTY
36124: LIST
36125: LIST
36126: PUSH
36127: LD_INT 0
36129: PUSH
36130: LD_INT 1
36132: NEG
36133: PUSH
36134: EMPTY
36135: LIST
36136: LIST
36137: PUSH
36138: LD_INT 1
36140: PUSH
36141: LD_INT 0
36143: PUSH
36144: EMPTY
36145: LIST
36146: LIST
36147: PUSH
36148: LD_INT 1
36150: PUSH
36151: LD_INT 1
36153: PUSH
36154: EMPTY
36155: LIST
36156: LIST
36157: PUSH
36158: LD_INT 0
36160: PUSH
36161: LD_INT 1
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: LD_INT 1
36170: NEG
36171: PUSH
36172: LD_INT 0
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 1
36181: NEG
36182: PUSH
36183: LD_INT 1
36185: NEG
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 1
36193: NEG
36194: PUSH
36195: LD_INT 2
36197: NEG
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 1
36205: PUSH
36206: LD_INT 2
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: LIST
36217: LIST
36218: LIST
36219: LIST
36220: LIST
36221: LIST
36222: LIST
36223: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36224: LD_ADDR_VAR 0 37
36228: PUSH
36229: LD_INT 0
36231: PUSH
36232: LD_INT 0
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: LD_INT 0
36241: PUSH
36242: LD_INT 1
36244: NEG
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: LD_INT 1
36252: PUSH
36253: LD_INT 0
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: PUSH
36260: LD_INT 1
36262: PUSH
36263: LD_INT 1
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 0
36272: PUSH
36273: LD_INT 1
36275: PUSH
36276: EMPTY
36277: LIST
36278: LIST
36279: PUSH
36280: LD_INT 1
36282: NEG
36283: PUSH
36284: LD_INT 0
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 1
36293: NEG
36294: PUSH
36295: LD_INT 1
36297: NEG
36298: PUSH
36299: EMPTY
36300: LIST
36301: LIST
36302: PUSH
36303: LD_INT 1
36305: PUSH
36306: LD_INT 1
36308: NEG
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 1
36316: NEG
36317: PUSH
36318: LD_INT 1
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36336: LD_ADDR_VAR 0 38
36340: PUSH
36341: LD_INT 0
36343: PUSH
36344: LD_INT 0
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 0
36353: PUSH
36354: LD_INT 1
36356: NEG
36357: PUSH
36358: EMPTY
36359: LIST
36360: LIST
36361: PUSH
36362: LD_INT 1
36364: PUSH
36365: LD_INT 0
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 1
36374: PUSH
36375: LD_INT 1
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 0
36384: PUSH
36385: LD_INT 1
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: PUSH
36392: LD_INT 1
36394: NEG
36395: PUSH
36396: LD_INT 0
36398: PUSH
36399: EMPTY
36400: LIST
36401: LIST
36402: PUSH
36403: LD_INT 1
36405: NEG
36406: PUSH
36407: LD_INT 1
36409: NEG
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 2
36417: PUSH
36418: LD_INT 1
36420: PUSH
36421: EMPTY
36422: LIST
36423: LIST
36424: PUSH
36425: LD_INT 2
36427: NEG
36428: PUSH
36429: LD_INT 1
36431: NEG
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: EMPTY
36438: LIST
36439: LIST
36440: LIST
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: LIST
36447: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36448: LD_ADDR_VAR 0 39
36452: PUSH
36453: LD_INT 0
36455: PUSH
36456: LD_INT 0
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: LD_INT 0
36465: PUSH
36466: LD_INT 1
36468: NEG
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 1
36476: PUSH
36477: LD_INT 0
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: PUSH
36484: LD_INT 1
36486: PUSH
36487: LD_INT 1
36489: PUSH
36490: EMPTY
36491: LIST
36492: LIST
36493: PUSH
36494: LD_INT 0
36496: PUSH
36497: LD_INT 1
36499: PUSH
36500: EMPTY
36501: LIST
36502: LIST
36503: PUSH
36504: LD_INT 1
36506: NEG
36507: PUSH
36508: LD_INT 0
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 1
36517: NEG
36518: PUSH
36519: LD_INT 1
36521: NEG
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 1
36529: NEG
36530: PUSH
36531: LD_INT 2
36533: NEG
36534: PUSH
36535: EMPTY
36536: LIST
36537: LIST
36538: PUSH
36539: LD_INT 1
36541: PUSH
36542: LD_INT 2
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: LIST
36555: LIST
36556: LIST
36557: LIST
36558: LIST
36559: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36560: LD_ADDR_VAR 0 40
36564: PUSH
36565: LD_INT 0
36567: PUSH
36568: LD_INT 0
36570: PUSH
36571: EMPTY
36572: LIST
36573: LIST
36574: PUSH
36575: LD_INT 0
36577: PUSH
36578: LD_INT 1
36580: NEG
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 1
36588: PUSH
36589: LD_INT 0
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: LD_INT 1
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 0
36608: PUSH
36609: LD_INT 1
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: PUSH
36616: LD_INT 1
36618: NEG
36619: PUSH
36620: LD_INT 0
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PUSH
36627: LD_INT 1
36629: NEG
36630: PUSH
36631: LD_INT 1
36633: NEG
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 1
36641: PUSH
36642: LD_INT 1
36644: NEG
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 1
36652: NEG
36653: PUSH
36654: LD_INT 1
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36672: LD_ADDR_VAR 0 41
36676: PUSH
36677: LD_INT 0
36679: PUSH
36680: LD_INT 0
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: LD_INT 0
36689: PUSH
36690: LD_INT 1
36692: NEG
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 1
36700: PUSH
36701: LD_INT 0
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 1
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: EMPTY
36715: LIST
36716: LIST
36717: PUSH
36718: LD_INT 0
36720: PUSH
36721: LD_INT 1
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: PUSH
36728: LD_INT 1
36730: NEG
36731: PUSH
36732: LD_INT 0
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 1
36741: NEG
36742: PUSH
36743: LD_INT 1
36745: NEG
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 1
36753: NEG
36754: PUSH
36755: LD_INT 2
36757: NEG
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PUSH
36763: LD_INT 1
36765: PUSH
36766: LD_INT 1
36768: NEG
36769: PUSH
36770: EMPTY
36771: LIST
36772: LIST
36773: PUSH
36774: LD_INT 2
36776: PUSH
36777: LD_INT 0
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: PUSH
36784: LD_INT 2
36786: PUSH
36787: LD_INT 1
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 2
36796: PUSH
36797: LD_INT 2
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 1
36806: PUSH
36807: LD_INT 2
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 1
36816: NEG
36817: PUSH
36818: LD_INT 1
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 2
36827: NEG
36828: PUSH
36829: LD_INT 0
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: PUSH
36836: LD_INT 2
36838: NEG
36839: PUSH
36840: LD_INT 1
36842: NEG
36843: PUSH
36844: EMPTY
36845: LIST
36846: LIST
36847: PUSH
36848: LD_INT 2
36850: NEG
36851: PUSH
36852: LD_INT 2
36854: NEG
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PUSH
36860: LD_INT 2
36862: NEG
36863: PUSH
36864: LD_INT 3
36866: NEG
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 2
36874: PUSH
36875: LD_INT 1
36877: NEG
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 3
36885: PUSH
36886: LD_INT 0
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: LD_INT 3
36895: PUSH
36896: LD_INT 1
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 3
36905: PUSH
36906: LD_INT 2
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 3
36915: PUSH
36916: LD_INT 3
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: PUSH
36923: LD_INT 2
36925: PUSH
36926: LD_INT 3
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: PUSH
36933: LD_INT 2
36935: NEG
36936: PUSH
36937: LD_INT 1
36939: PUSH
36940: EMPTY
36941: LIST
36942: LIST
36943: PUSH
36944: LD_INT 3
36946: NEG
36947: PUSH
36948: LD_INT 0
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PUSH
36955: LD_INT 3
36957: NEG
36958: PUSH
36959: LD_INT 1
36961: NEG
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: LD_INT 3
36969: NEG
36970: PUSH
36971: LD_INT 2
36973: NEG
36974: PUSH
36975: EMPTY
36976: LIST
36977: LIST
36978: PUSH
36979: LD_INT 3
36981: NEG
36982: PUSH
36983: LD_INT 3
36985: NEG
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: LIST
36995: LIST
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37022: LD_ADDR_VAR 0 42
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: LD_INT 0
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 0
37039: PUSH
37040: LD_INT 1
37042: NEG
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 1
37050: PUSH
37051: LD_INT 0
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 1
37060: PUSH
37061: LD_INT 1
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 0
37070: PUSH
37071: LD_INT 1
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: LD_INT 1
37080: NEG
37081: PUSH
37082: LD_INT 0
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 1
37091: NEG
37092: PUSH
37093: LD_INT 1
37095: NEG
37096: PUSH
37097: EMPTY
37098: LIST
37099: LIST
37100: PUSH
37101: LD_INT 1
37103: NEG
37104: PUSH
37105: LD_INT 2
37107: NEG
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 0
37115: PUSH
37116: LD_INT 2
37118: NEG
37119: PUSH
37120: EMPTY
37121: LIST
37122: LIST
37123: PUSH
37124: LD_INT 1
37126: PUSH
37127: LD_INT 1
37129: NEG
37130: PUSH
37131: EMPTY
37132: LIST
37133: LIST
37134: PUSH
37135: LD_INT 2
37137: PUSH
37138: LD_INT 1
37140: PUSH
37141: EMPTY
37142: LIST
37143: LIST
37144: PUSH
37145: LD_INT 2
37147: PUSH
37148: LD_INT 2
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: PUSH
37155: LD_INT 1
37157: PUSH
37158: LD_INT 2
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: PUSH
37165: LD_INT 0
37167: PUSH
37168: LD_INT 2
37170: PUSH
37171: EMPTY
37172: LIST
37173: LIST
37174: PUSH
37175: LD_INT 1
37177: NEG
37178: PUSH
37179: LD_INT 1
37181: PUSH
37182: EMPTY
37183: LIST
37184: LIST
37185: PUSH
37186: LD_INT 2
37188: NEG
37189: PUSH
37190: LD_INT 1
37192: NEG
37193: PUSH
37194: EMPTY
37195: LIST
37196: LIST
37197: PUSH
37198: LD_INT 2
37200: NEG
37201: PUSH
37202: LD_INT 2
37204: NEG
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 2
37212: NEG
37213: PUSH
37214: LD_INT 3
37216: NEG
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 1
37224: NEG
37225: PUSH
37226: LD_INT 3
37228: NEG
37229: PUSH
37230: EMPTY
37231: LIST
37232: LIST
37233: PUSH
37234: LD_INT 0
37236: PUSH
37237: LD_INT 3
37239: NEG
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 1
37247: PUSH
37248: LD_INT 2
37250: NEG
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PUSH
37256: LD_INT 3
37258: PUSH
37259: LD_INT 2
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: PUSH
37266: LD_INT 3
37268: PUSH
37269: LD_INT 3
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: PUSH
37276: LD_INT 2
37278: PUSH
37279: LD_INT 3
37281: PUSH
37282: EMPTY
37283: LIST
37284: LIST
37285: PUSH
37286: LD_INT 1
37288: PUSH
37289: LD_INT 3
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: LD_INT 0
37298: PUSH
37299: LD_INT 3
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 1
37308: NEG
37309: PUSH
37310: LD_INT 2
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 3
37319: NEG
37320: PUSH
37321: LD_INT 2
37323: NEG
37324: PUSH
37325: EMPTY
37326: LIST
37327: LIST
37328: PUSH
37329: LD_INT 3
37331: NEG
37332: PUSH
37333: LD_INT 3
37335: NEG
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: LIST
37345: LIST
37346: LIST
37347: LIST
37348: LIST
37349: LIST
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: LIST
37368: LIST
37369: LIST
37370: LIST
37371: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37372: LD_ADDR_VAR 0 43
37376: PUSH
37377: LD_INT 0
37379: PUSH
37380: LD_INT 0
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: PUSH
37387: LD_INT 0
37389: PUSH
37390: LD_INT 1
37392: NEG
37393: PUSH
37394: EMPTY
37395: LIST
37396: LIST
37397: PUSH
37398: LD_INT 1
37400: PUSH
37401: LD_INT 0
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: LD_INT 1
37410: PUSH
37411: LD_INT 1
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: PUSH
37418: LD_INT 0
37420: PUSH
37421: LD_INT 1
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: PUSH
37428: LD_INT 1
37430: NEG
37431: PUSH
37432: LD_INT 0
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: LD_INT 1
37441: NEG
37442: PUSH
37443: LD_INT 1
37445: NEG
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: LD_INT 1
37453: NEG
37454: PUSH
37455: LD_INT 2
37457: NEG
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 0
37465: PUSH
37466: LD_INT 2
37468: NEG
37469: PUSH
37470: EMPTY
37471: LIST
37472: LIST
37473: PUSH
37474: LD_INT 1
37476: PUSH
37477: LD_INT 1
37479: NEG
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: LD_INT 2
37487: PUSH
37488: LD_INT 0
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 2
37497: PUSH
37498: LD_INT 1
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 1
37507: PUSH
37508: LD_INT 2
37510: PUSH
37511: EMPTY
37512: LIST
37513: LIST
37514: PUSH
37515: LD_INT 0
37517: PUSH
37518: LD_INT 2
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PUSH
37525: LD_INT 1
37527: NEG
37528: PUSH
37529: LD_INT 1
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: LD_INT 2
37538: NEG
37539: PUSH
37540: LD_INT 0
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 2
37549: NEG
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 1
37561: NEG
37562: PUSH
37563: LD_INT 3
37565: NEG
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: LD_INT 0
37573: PUSH
37574: LD_INT 3
37576: NEG
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 1
37584: PUSH
37585: LD_INT 2
37587: NEG
37588: PUSH
37589: EMPTY
37590: LIST
37591: LIST
37592: PUSH
37593: LD_INT 2
37595: PUSH
37596: LD_INT 1
37598: NEG
37599: PUSH
37600: EMPTY
37601: LIST
37602: LIST
37603: PUSH
37604: LD_INT 3
37606: PUSH
37607: LD_INT 0
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: LD_INT 3
37616: PUSH
37617: LD_INT 1
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: LD_INT 1
37626: PUSH
37627: LD_INT 3
37629: PUSH
37630: EMPTY
37631: LIST
37632: LIST
37633: PUSH
37634: LD_INT 0
37636: PUSH
37637: LD_INT 3
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 1
37646: NEG
37647: PUSH
37648: LD_INT 2
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 2
37657: NEG
37658: PUSH
37659: LD_INT 1
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: LD_INT 3
37668: NEG
37669: PUSH
37670: LD_INT 0
37672: PUSH
37673: EMPTY
37674: LIST
37675: LIST
37676: PUSH
37677: LD_INT 3
37679: NEG
37680: PUSH
37681: LD_INT 1
37683: NEG
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: LIST
37693: LIST
37694: LIST
37695: LIST
37696: LIST
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37720: LD_ADDR_VAR 0 44
37724: PUSH
37725: LD_INT 0
37727: PUSH
37728: LD_INT 0
37730: PUSH
37731: EMPTY
37732: LIST
37733: LIST
37734: PUSH
37735: LD_INT 0
37737: PUSH
37738: LD_INT 1
37740: NEG
37741: PUSH
37742: EMPTY
37743: LIST
37744: LIST
37745: PUSH
37746: LD_INT 1
37748: PUSH
37749: LD_INT 0
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: PUSH
37756: LD_INT 1
37758: PUSH
37759: LD_INT 1
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 0
37768: PUSH
37769: LD_INT 1
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: LD_INT 1
37778: NEG
37779: PUSH
37780: LD_INT 0
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: LD_INT 1
37789: NEG
37790: PUSH
37791: LD_INT 1
37793: NEG
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 1
37801: NEG
37802: PUSH
37803: LD_INT 2
37805: NEG
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 1
37813: PUSH
37814: LD_INT 1
37816: NEG
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 2
37824: PUSH
37825: LD_INT 0
37827: PUSH
37828: EMPTY
37829: LIST
37830: LIST
37831: PUSH
37832: LD_INT 2
37834: PUSH
37835: LD_INT 1
37837: PUSH
37838: EMPTY
37839: LIST
37840: LIST
37841: PUSH
37842: LD_INT 2
37844: PUSH
37845: LD_INT 2
37847: PUSH
37848: EMPTY
37849: LIST
37850: LIST
37851: PUSH
37852: LD_INT 1
37854: PUSH
37855: LD_INT 2
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: LD_INT 1
37864: NEG
37865: PUSH
37866: LD_INT 1
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: LD_INT 2
37875: NEG
37876: PUSH
37877: LD_INT 0
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 2
37886: NEG
37887: PUSH
37888: LD_INT 1
37890: NEG
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 2
37898: NEG
37899: PUSH
37900: LD_INT 2
37902: NEG
37903: PUSH
37904: EMPTY
37905: LIST
37906: LIST
37907: PUSH
37908: LD_INT 2
37910: NEG
37911: PUSH
37912: LD_INT 3
37914: NEG
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: LD_INT 2
37922: PUSH
37923: LD_INT 1
37925: NEG
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: PUSH
37931: LD_INT 3
37933: PUSH
37934: LD_INT 0
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 3
37943: PUSH
37944: LD_INT 1
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: PUSH
37951: LD_INT 3
37953: PUSH
37954: LD_INT 2
37956: PUSH
37957: EMPTY
37958: LIST
37959: LIST
37960: PUSH
37961: LD_INT 3
37963: PUSH
37964: LD_INT 3
37966: PUSH
37967: EMPTY
37968: LIST
37969: LIST
37970: PUSH
37971: LD_INT 2
37973: PUSH
37974: LD_INT 3
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: PUSH
37981: LD_INT 2
37983: NEG
37984: PUSH
37985: LD_INT 1
37987: PUSH
37988: EMPTY
37989: LIST
37990: LIST
37991: PUSH
37992: LD_INT 3
37994: NEG
37995: PUSH
37996: LD_INT 0
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 3
38005: NEG
38006: PUSH
38007: LD_INT 1
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 3
38017: NEG
38018: PUSH
38019: LD_INT 2
38021: NEG
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: LD_INT 3
38029: NEG
38030: PUSH
38031: LD_INT 3
38033: NEG
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38070: LD_ADDR_VAR 0 45
38074: PUSH
38075: LD_INT 0
38077: PUSH
38078: LD_INT 0
38080: PUSH
38081: EMPTY
38082: LIST
38083: LIST
38084: PUSH
38085: LD_INT 0
38087: PUSH
38088: LD_INT 1
38090: NEG
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 1
38098: PUSH
38099: LD_INT 0
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 1
38108: PUSH
38109: LD_INT 1
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: LD_INT 0
38118: PUSH
38119: LD_INT 1
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: PUSH
38126: LD_INT 1
38128: NEG
38129: PUSH
38130: LD_INT 0
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 1
38139: NEG
38140: PUSH
38141: LD_INT 1
38143: NEG
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 1
38151: NEG
38152: PUSH
38153: LD_INT 2
38155: NEG
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 0
38163: PUSH
38164: LD_INT 2
38166: NEG
38167: PUSH
38168: EMPTY
38169: LIST
38170: LIST
38171: PUSH
38172: LD_INT 1
38174: PUSH
38175: LD_INT 1
38177: NEG
38178: PUSH
38179: EMPTY
38180: LIST
38181: LIST
38182: PUSH
38183: LD_INT 2
38185: PUSH
38186: LD_INT 1
38188: PUSH
38189: EMPTY
38190: LIST
38191: LIST
38192: PUSH
38193: LD_INT 2
38195: PUSH
38196: LD_INT 2
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 1
38205: PUSH
38206: LD_INT 2
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: PUSH
38213: LD_INT 0
38215: PUSH
38216: LD_INT 2
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 1
38225: NEG
38226: PUSH
38227: LD_INT 1
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: LD_INT 2
38236: NEG
38237: PUSH
38238: LD_INT 1
38240: NEG
38241: PUSH
38242: EMPTY
38243: LIST
38244: LIST
38245: PUSH
38246: LD_INT 2
38248: NEG
38249: PUSH
38250: LD_INT 2
38252: NEG
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 2
38260: NEG
38261: PUSH
38262: LD_INT 3
38264: NEG
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: LD_INT 1
38272: NEG
38273: PUSH
38274: LD_INT 3
38276: NEG
38277: PUSH
38278: EMPTY
38279: LIST
38280: LIST
38281: PUSH
38282: LD_INT 0
38284: PUSH
38285: LD_INT 3
38287: NEG
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 1
38295: PUSH
38296: LD_INT 2
38298: NEG
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: LD_INT 3
38306: PUSH
38307: LD_INT 2
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: LD_INT 3
38316: PUSH
38317: LD_INT 3
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 2
38326: PUSH
38327: LD_INT 3
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 1
38336: PUSH
38337: LD_INT 3
38339: PUSH
38340: EMPTY
38341: LIST
38342: LIST
38343: PUSH
38344: LD_INT 0
38346: PUSH
38347: LD_INT 3
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: PUSH
38354: LD_INT 1
38356: NEG
38357: PUSH
38358: LD_INT 2
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: LD_INT 3
38367: NEG
38368: PUSH
38369: LD_INT 2
38371: NEG
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 3
38379: NEG
38380: PUSH
38381: LD_INT 3
38383: NEG
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: LIST
38393: LIST
38394: LIST
38395: LIST
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38420: LD_ADDR_VAR 0 46
38424: PUSH
38425: LD_INT 0
38427: PUSH
38428: LD_INT 0
38430: PUSH
38431: EMPTY
38432: LIST
38433: LIST
38434: PUSH
38435: LD_INT 0
38437: PUSH
38438: LD_INT 1
38440: NEG
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 1
38448: PUSH
38449: LD_INT 0
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 1
38458: PUSH
38459: LD_INT 1
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 0
38468: PUSH
38469: LD_INT 1
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: LD_INT 1
38478: NEG
38479: PUSH
38480: LD_INT 0
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: LD_INT 1
38489: NEG
38490: PUSH
38491: LD_INT 1
38493: NEG
38494: PUSH
38495: EMPTY
38496: LIST
38497: LIST
38498: PUSH
38499: LD_INT 1
38501: NEG
38502: PUSH
38503: LD_INT 2
38505: NEG
38506: PUSH
38507: EMPTY
38508: LIST
38509: LIST
38510: PUSH
38511: LD_INT 0
38513: PUSH
38514: LD_INT 2
38516: NEG
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 1
38524: PUSH
38525: LD_INT 1
38527: NEG
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 2
38535: PUSH
38536: LD_INT 0
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 2
38545: PUSH
38546: LD_INT 1
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 1
38555: PUSH
38556: LD_INT 2
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: LD_INT 0
38565: PUSH
38566: LD_INT 2
38568: PUSH
38569: EMPTY
38570: LIST
38571: LIST
38572: PUSH
38573: LD_INT 1
38575: NEG
38576: PUSH
38577: LD_INT 1
38579: PUSH
38580: EMPTY
38581: LIST
38582: LIST
38583: PUSH
38584: LD_INT 2
38586: NEG
38587: PUSH
38588: LD_INT 0
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 2
38597: NEG
38598: PUSH
38599: LD_INT 1
38601: NEG
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 1
38609: NEG
38610: PUSH
38611: LD_INT 3
38613: NEG
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: PUSH
38619: LD_INT 0
38621: PUSH
38622: LD_INT 3
38624: NEG
38625: PUSH
38626: EMPTY
38627: LIST
38628: LIST
38629: PUSH
38630: LD_INT 1
38632: PUSH
38633: LD_INT 2
38635: NEG
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: LD_INT 2
38643: PUSH
38644: LD_INT 1
38646: NEG
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 3
38654: PUSH
38655: LD_INT 0
38657: PUSH
38658: EMPTY
38659: LIST
38660: LIST
38661: PUSH
38662: LD_INT 3
38664: PUSH
38665: LD_INT 1
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: LD_INT 3
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: PUSH
38682: LD_INT 0
38684: PUSH
38685: LD_INT 3
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PUSH
38692: LD_INT 1
38694: NEG
38695: PUSH
38696: LD_INT 2
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: LD_INT 2
38705: NEG
38706: PUSH
38707: LD_INT 1
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 3
38716: NEG
38717: PUSH
38718: LD_INT 0
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 3
38727: NEG
38728: PUSH
38729: LD_INT 1
38731: NEG
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: EMPTY
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: LIST
38760: LIST
38761: LIST
38762: LIST
38763: LIST
38764: LIST
38765: LIST
38766: LIST
38767: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38768: LD_ADDR_VAR 0 47
38772: PUSH
38773: LD_INT 0
38775: PUSH
38776: LD_INT 0
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PUSH
38783: LD_INT 0
38785: PUSH
38786: LD_INT 1
38788: NEG
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 1
38796: PUSH
38797: LD_INT 0
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: LD_INT 1
38806: PUSH
38807: LD_INT 1
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: LD_INT 0
38816: PUSH
38817: LD_INT 1
38819: PUSH
38820: EMPTY
38821: LIST
38822: LIST
38823: PUSH
38824: LD_INT 1
38826: NEG
38827: PUSH
38828: LD_INT 0
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 1
38837: NEG
38838: PUSH
38839: LD_INT 1
38841: NEG
38842: PUSH
38843: EMPTY
38844: LIST
38845: LIST
38846: PUSH
38847: LD_INT 1
38849: NEG
38850: PUSH
38851: LD_INT 2
38853: NEG
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 0
38861: PUSH
38862: LD_INT 2
38864: NEG
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 1
38872: PUSH
38873: LD_INT 1
38875: NEG
38876: PUSH
38877: EMPTY
38878: LIST
38879: LIST
38880: PUSH
38881: LD_INT 2
38883: NEG
38884: PUSH
38885: LD_INT 1
38887: NEG
38888: PUSH
38889: EMPTY
38890: LIST
38891: LIST
38892: PUSH
38893: LD_INT 2
38895: NEG
38896: PUSH
38897: LD_INT 2
38899: NEG
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: LIST
38909: LIST
38910: LIST
38911: LIST
38912: LIST
38913: LIST
38914: LIST
38915: LIST
38916: LIST
38917: LIST
38918: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38919: LD_ADDR_VAR 0 48
38923: PUSH
38924: LD_INT 0
38926: PUSH
38927: LD_INT 0
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 0
38936: PUSH
38937: LD_INT 1
38939: NEG
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 1
38947: PUSH
38948: LD_INT 0
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: LD_INT 1
38957: PUSH
38958: LD_INT 1
38960: PUSH
38961: EMPTY
38962: LIST
38963: LIST
38964: PUSH
38965: LD_INT 0
38967: PUSH
38968: LD_INT 1
38970: PUSH
38971: EMPTY
38972: LIST
38973: LIST
38974: PUSH
38975: LD_INT 1
38977: NEG
38978: PUSH
38979: LD_INT 0
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 1
38988: NEG
38989: PUSH
38990: LD_INT 1
38992: NEG
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 1
39000: NEG
39001: PUSH
39002: LD_INT 2
39004: NEG
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 0
39012: PUSH
39013: LD_INT 2
39015: NEG
39016: PUSH
39017: EMPTY
39018: LIST
39019: LIST
39020: PUSH
39021: LD_INT 1
39023: PUSH
39024: LD_INT 1
39026: NEG
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PUSH
39032: LD_INT 2
39034: PUSH
39035: LD_INT 0
39037: PUSH
39038: EMPTY
39039: LIST
39040: LIST
39041: PUSH
39042: LD_INT 2
39044: PUSH
39045: LD_INT 1
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39066: LD_ADDR_VAR 0 49
39070: PUSH
39071: LD_INT 0
39073: PUSH
39074: LD_INT 0
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 0
39083: PUSH
39084: LD_INT 1
39086: NEG
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: PUSH
39092: LD_INT 1
39094: PUSH
39095: LD_INT 0
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: LD_INT 1
39104: PUSH
39105: LD_INT 1
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: LD_INT 1
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 1
39124: NEG
39125: PUSH
39126: LD_INT 0
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 1
39135: NEG
39136: PUSH
39137: LD_INT 1
39139: NEG
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 1
39147: PUSH
39148: LD_INT 1
39150: NEG
39151: PUSH
39152: EMPTY
39153: LIST
39154: LIST
39155: PUSH
39156: LD_INT 2
39158: PUSH
39159: LD_INT 0
39161: PUSH
39162: EMPTY
39163: LIST
39164: LIST
39165: PUSH
39166: LD_INT 2
39168: PUSH
39169: LD_INT 1
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: LD_INT 2
39178: PUSH
39179: LD_INT 2
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: PUSH
39186: LD_INT 1
39188: PUSH
39189: LD_INT 2
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: LIST
39200: LIST
39201: LIST
39202: LIST
39203: LIST
39204: LIST
39205: LIST
39206: LIST
39207: LIST
39208: LIST
39209: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39210: LD_ADDR_VAR 0 50
39214: PUSH
39215: LD_INT 0
39217: PUSH
39218: LD_INT 0
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 0
39227: PUSH
39228: LD_INT 1
39230: NEG
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 1
39238: PUSH
39239: LD_INT 0
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 1
39248: PUSH
39249: LD_INT 1
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 0
39258: PUSH
39259: LD_INT 1
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 1
39268: NEG
39269: PUSH
39270: LD_INT 0
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 1
39279: NEG
39280: PUSH
39281: LD_INT 1
39283: NEG
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: LD_INT 2
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 2
39301: PUSH
39302: LD_INT 2
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: PUSH
39309: LD_INT 1
39311: PUSH
39312: LD_INT 2
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: LD_INT 0
39321: PUSH
39322: LD_INT 2
39324: PUSH
39325: EMPTY
39326: LIST
39327: LIST
39328: PUSH
39329: LD_INT 1
39331: NEG
39332: PUSH
39333: LD_INT 1
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39354: LD_ADDR_VAR 0 51
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: LD_INT 0
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: LD_INT 1
39374: NEG
39375: PUSH
39376: EMPTY
39377: LIST
39378: LIST
39379: PUSH
39380: LD_INT 1
39382: PUSH
39383: LD_INT 0
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 1
39392: PUSH
39393: LD_INT 1
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: PUSH
39400: LD_INT 0
39402: PUSH
39403: LD_INT 1
39405: PUSH
39406: EMPTY
39407: LIST
39408: LIST
39409: PUSH
39410: LD_INT 1
39412: NEG
39413: PUSH
39414: LD_INT 0
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 1
39423: NEG
39424: PUSH
39425: LD_INT 1
39427: NEG
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: PUSH
39433: LD_INT 1
39435: PUSH
39436: LD_INT 2
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 0
39445: PUSH
39446: LD_INT 2
39448: PUSH
39449: EMPTY
39450: LIST
39451: LIST
39452: PUSH
39453: LD_INT 1
39455: NEG
39456: PUSH
39457: LD_INT 1
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 2
39466: NEG
39467: PUSH
39468: LD_INT 0
39470: PUSH
39471: EMPTY
39472: LIST
39473: LIST
39474: PUSH
39475: LD_INT 2
39477: NEG
39478: PUSH
39479: LD_INT 1
39481: NEG
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: LIST
39491: LIST
39492: LIST
39493: LIST
39494: LIST
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: LIST
39500: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39501: LD_ADDR_VAR 0 52
39505: PUSH
39506: LD_INT 0
39508: PUSH
39509: LD_INT 0
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: PUSH
39516: LD_INT 0
39518: PUSH
39519: LD_INT 1
39521: NEG
39522: PUSH
39523: EMPTY
39524: LIST
39525: LIST
39526: PUSH
39527: LD_INT 1
39529: PUSH
39530: LD_INT 0
39532: PUSH
39533: EMPTY
39534: LIST
39535: LIST
39536: PUSH
39537: LD_INT 1
39539: PUSH
39540: LD_INT 1
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PUSH
39547: LD_INT 0
39549: PUSH
39550: LD_INT 1
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 1
39559: NEG
39560: PUSH
39561: LD_INT 0
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PUSH
39568: LD_INT 1
39570: NEG
39571: PUSH
39572: LD_INT 1
39574: NEG
39575: PUSH
39576: EMPTY
39577: LIST
39578: LIST
39579: PUSH
39580: LD_INT 1
39582: NEG
39583: PUSH
39584: LD_INT 2
39586: NEG
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PUSH
39592: LD_INT 1
39594: NEG
39595: PUSH
39596: LD_INT 1
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 2
39605: NEG
39606: PUSH
39607: LD_INT 0
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 2
39616: NEG
39617: PUSH
39618: LD_INT 1
39620: NEG
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 2
39628: NEG
39629: PUSH
39630: LD_INT 2
39632: NEG
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: LIST
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: LIST
39648: LIST
39649: LIST
39650: LIST
39651: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39652: LD_ADDR_VAR 0 53
39656: PUSH
39657: LD_INT 0
39659: PUSH
39660: LD_INT 0
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 0
39669: PUSH
39670: LD_INT 1
39672: NEG
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 1
39680: PUSH
39681: LD_INT 0
39683: PUSH
39684: EMPTY
39685: LIST
39686: LIST
39687: PUSH
39688: LD_INT 1
39690: PUSH
39691: LD_INT 1
39693: PUSH
39694: EMPTY
39695: LIST
39696: LIST
39697: PUSH
39698: LD_INT 0
39700: PUSH
39701: LD_INT 1
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 1
39710: NEG
39711: PUSH
39712: LD_INT 0
39714: PUSH
39715: EMPTY
39716: LIST
39717: LIST
39718: PUSH
39719: LD_INT 1
39721: NEG
39722: PUSH
39723: LD_INT 1
39725: NEG
39726: PUSH
39727: EMPTY
39728: LIST
39729: LIST
39730: PUSH
39731: LD_INT 1
39733: NEG
39734: PUSH
39735: LD_INT 2
39737: NEG
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PUSH
39743: LD_INT 0
39745: PUSH
39746: LD_INT 2
39748: NEG
39749: PUSH
39750: EMPTY
39751: LIST
39752: LIST
39753: PUSH
39754: LD_INT 1
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 2
39767: PUSH
39768: LD_INT 0
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 2
39777: PUSH
39778: LD_INT 1
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 2
39787: PUSH
39788: LD_INT 2
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 1
39797: PUSH
39798: LD_INT 2
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 0
39807: PUSH
39808: LD_INT 2
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 1
39817: NEG
39818: PUSH
39819: LD_INT 1
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 2
39828: NEG
39829: PUSH
39830: LD_INT 0
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 2
39839: NEG
39840: PUSH
39841: LD_INT 1
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 2
39851: NEG
39852: PUSH
39853: LD_INT 2
39855: NEG
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: LIST
39865: LIST
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39882: LD_ADDR_VAR 0 54
39886: PUSH
39887: LD_INT 0
39889: PUSH
39890: LD_INT 0
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 0
39899: PUSH
39900: LD_INT 1
39902: NEG
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 1
39910: PUSH
39911: LD_INT 0
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PUSH
39918: LD_INT 1
39920: PUSH
39921: LD_INT 1
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 0
39930: PUSH
39931: LD_INT 1
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 1
39940: NEG
39941: PUSH
39942: LD_INT 0
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 1
39951: NEG
39952: PUSH
39953: LD_INT 1
39955: NEG
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 1
39963: NEG
39964: PUSH
39965: LD_INT 2
39967: NEG
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: PUSH
39973: LD_INT 0
39975: PUSH
39976: LD_INT 2
39978: NEG
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: LD_INT 1
39986: PUSH
39987: LD_INT 1
39989: NEG
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: LD_INT 2
39997: PUSH
39998: LD_INT 0
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: PUSH
40005: LD_INT 2
40007: PUSH
40008: LD_INT 1
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: LD_INT 2
40017: PUSH
40018: LD_INT 2
40020: PUSH
40021: EMPTY
40022: LIST
40023: LIST
40024: PUSH
40025: LD_INT 1
40027: PUSH
40028: LD_INT 2
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 0
40037: PUSH
40038: LD_INT 2
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: LD_INT 1
40047: NEG
40048: PUSH
40049: LD_INT 1
40051: PUSH
40052: EMPTY
40053: LIST
40054: LIST
40055: PUSH
40056: LD_INT 2
40058: NEG
40059: PUSH
40060: LD_INT 0
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: LD_INT 2
40069: NEG
40070: PUSH
40071: LD_INT 1
40073: NEG
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 2
40081: NEG
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: LIST
40095: LIST
40096: LIST
40097: LIST
40098: LIST
40099: LIST
40100: LIST
40101: LIST
40102: LIST
40103: LIST
40104: LIST
40105: LIST
40106: LIST
40107: LIST
40108: LIST
40109: LIST
40110: LIST
40111: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40112: LD_ADDR_VAR 0 55
40116: PUSH
40117: LD_INT 0
40119: PUSH
40120: LD_INT 0
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 0
40129: PUSH
40130: LD_INT 1
40132: NEG
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 1
40140: PUSH
40141: LD_INT 0
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: PUSH
40148: LD_INT 1
40150: PUSH
40151: LD_INT 1
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: PUSH
40158: LD_INT 0
40160: PUSH
40161: LD_INT 1
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 1
40170: NEG
40171: PUSH
40172: LD_INT 0
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: LD_INT 1
40181: NEG
40182: PUSH
40183: LD_INT 1
40185: NEG
40186: PUSH
40187: EMPTY
40188: LIST
40189: LIST
40190: PUSH
40191: LD_INT 1
40193: NEG
40194: PUSH
40195: LD_INT 2
40197: NEG
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: PUSH
40203: LD_INT 0
40205: PUSH
40206: LD_INT 2
40208: NEG
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 1
40216: PUSH
40217: LD_INT 1
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 2
40227: PUSH
40228: LD_INT 0
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 2
40237: PUSH
40238: LD_INT 1
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: LD_INT 2
40247: PUSH
40248: LD_INT 2
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 1
40257: PUSH
40258: LD_INT 2
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 0
40267: PUSH
40268: LD_INT 2
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 1
40277: NEG
40278: PUSH
40279: LD_INT 1
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 2
40288: NEG
40289: PUSH
40290: LD_INT 0
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 2
40299: NEG
40300: PUSH
40301: LD_INT 1
40303: NEG
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 2
40311: NEG
40312: PUSH
40313: LD_INT 2
40315: NEG
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: LIST
40325: LIST
40326: LIST
40327: LIST
40328: LIST
40329: LIST
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: LIST
40335: LIST
40336: LIST
40337: LIST
40338: LIST
40339: LIST
40340: LIST
40341: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40342: LD_ADDR_VAR 0 56
40346: PUSH
40347: LD_INT 0
40349: PUSH
40350: LD_INT 0
40352: PUSH
40353: EMPTY
40354: LIST
40355: LIST
40356: PUSH
40357: LD_INT 0
40359: PUSH
40360: LD_INT 1
40362: NEG
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PUSH
40368: LD_INT 1
40370: PUSH
40371: LD_INT 0
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: LD_INT 1
40380: PUSH
40381: LD_INT 1
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: PUSH
40388: LD_INT 0
40390: PUSH
40391: LD_INT 1
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_INT 1
40400: NEG
40401: PUSH
40402: LD_INT 0
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PUSH
40409: LD_INT 1
40411: NEG
40412: PUSH
40413: LD_INT 1
40415: NEG
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 1
40423: NEG
40424: PUSH
40425: LD_INT 2
40427: NEG
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 0
40435: PUSH
40436: LD_INT 2
40438: NEG
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PUSH
40444: LD_INT 1
40446: PUSH
40447: LD_INT 1
40449: NEG
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 2
40457: PUSH
40458: LD_INT 0
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: LD_INT 2
40467: PUSH
40468: LD_INT 1
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: LD_INT 2
40477: PUSH
40478: LD_INT 2
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 1
40487: PUSH
40488: LD_INT 2
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 0
40497: PUSH
40498: LD_INT 2
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 1
40507: NEG
40508: PUSH
40509: LD_INT 1
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: PUSH
40516: LD_INT 2
40518: NEG
40519: PUSH
40520: LD_INT 0
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 2
40529: NEG
40530: PUSH
40531: LD_INT 1
40533: NEG
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 2
40541: NEG
40542: PUSH
40543: LD_INT 2
40545: NEG
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: PUSH
40551: EMPTY
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: LIST
40570: LIST
40571: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40572: LD_ADDR_VAR 0 57
40576: PUSH
40577: LD_INT 0
40579: PUSH
40580: LD_INT 0
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: LD_INT 0
40589: PUSH
40590: LD_INT 1
40592: NEG
40593: PUSH
40594: EMPTY
40595: LIST
40596: LIST
40597: PUSH
40598: LD_INT 1
40600: PUSH
40601: LD_INT 0
40603: PUSH
40604: EMPTY
40605: LIST
40606: LIST
40607: PUSH
40608: LD_INT 1
40610: PUSH
40611: LD_INT 1
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: PUSH
40618: LD_INT 0
40620: PUSH
40621: LD_INT 1
40623: PUSH
40624: EMPTY
40625: LIST
40626: LIST
40627: PUSH
40628: LD_INT 1
40630: NEG
40631: PUSH
40632: LD_INT 0
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: LD_INT 1
40641: NEG
40642: PUSH
40643: LD_INT 1
40645: NEG
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 1
40653: NEG
40654: PUSH
40655: LD_INT 2
40657: NEG
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 0
40665: PUSH
40666: LD_INT 2
40668: NEG
40669: PUSH
40670: EMPTY
40671: LIST
40672: LIST
40673: PUSH
40674: LD_INT 1
40676: PUSH
40677: LD_INT 1
40679: NEG
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: LD_INT 2
40687: PUSH
40688: LD_INT 0
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 2
40697: PUSH
40698: LD_INT 1
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 2
40707: PUSH
40708: LD_INT 2
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: PUSH
40715: LD_INT 1
40717: PUSH
40718: LD_INT 2
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 0
40727: PUSH
40728: LD_INT 2
40730: PUSH
40731: EMPTY
40732: LIST
40733: LIST
40734: PUSH
40735: LD_INT 1
40737: NEG
40738: PUSH
40739: LD_INT 1
40741: PUSH
40742: EMPTY
40743: LIST
40744: LIST
40745: PUSH
40746: LD_INT 2
40748: NEG
40749: PUSH
40750: LD_INT 0
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: LD_INT 2
40759: NEG
40760: PUSH
40761: LD_INT 1
40763: NEG
40764: PUSH
40765: EMPTY
40766: LIST
40767: LIST
40768: PUSH
40769: LD_INT 2
40771: NEG
40772: PUSH
40773: LD_INT 2
40775: NEG
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: LIST
40785: LIST
40786: LIST
40787: LIST
40788: LIST
40789: LIST
40790: LIST
40791: LIST
40792: LIST
40793: LIST
40794: LIST
40795: LIST
40796: LIST
40797: LIST
40798: LIST
40799: LIST
40800: LIST
40801: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40802: LD_ADDR_VAR 0 58
40806: PUSH
40807: LD_INT 0
40809: PUSH
40810: LD_INT 0
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 0
40819: PUSH
40820: LD_INT 1
40822: NEG
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 1
40830: PUSH
40831: LD_INT 0
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PUSH
40838: LD_INT 1
40840: PUSH
40841: LD_INT 1
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: LD_INT 0
40850: PUSH
40851: LD_INT 1
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 1
40860: NEG
40861: PUSH
40862: LD_INT 0
40864: PUSH
40865: EMPTY
40866: LIST
40867: LIST
40868: PUSH
40869: LD_INT 1
40871: NEG
40872: PUSH
40873: LD_INT 1
40875: NEG
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 1
40883: NEG
40884: PUSH
40885: LD_INT 2
40887: NEG
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 0
40895: PUSH
40896: LD_INT 2
40898: NEG
40899: PUSH
40900: EMPTY
40901: LIST
40902: LIST
40903: PUSH
40904: LD_INT 1
40906: PUSH
40907: LD_INT 1
40909: NEG
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: LD_INT 2
40917: PUSH
40918: LD_INT 0
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: LD_INT 2
40927: PUSH
40928: LD_INT 1
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: PUSH
40935: LD_INT 2
40937: PUSH
40938: LD_INT 2
40940: PUSH
40941: EMPTY
40942: LIST
40943: LIST
40944: PUSH
40945: LD_INT 1
40947: PUSH
40948: LD_INT 2
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 0
40957: PUSH
40958: LD_INT 2
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: PUSH
40965: LD_INT 1
40967: NEG
40968: PUSH
40969: LD_INT 1
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: PUSH
40976: LD_INT 2
40978: NEG
40979: PUSH
40980: LD_INT 0
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: LD_INT 2
40989: NEG
40990: PUSH
40991: LD_INT 1
40993: NEG
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PUSH
40999: LD_INT 2
41001: NEG
41002: PUSH
41003: LD_INT 2
41005: NEG
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: LIST
41029: LIST
41030: LIST
41031: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41032: LD_ADDR_VAR 0 59
41036: PUSH
41037: LD_INT 0
41039: PUSH
41040: LD_INT 0
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: LD_INT 0
41049: PUSH
41050: LD_INT 1
41052: NEG
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 1
41060: PUSH
41061: LD_INT 0
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: PUSH
41068: LD_INT 1
41070: PUSH
41071: LD_INT 1
41073: PUSH
41074: EMPTY
41075: LIST
41076: LIST
41077: PUSH
41078: LD_INT 0
41080: PUSH
41081: LD_INT 1
41083: PUSH
41084: EMPTY
41085: LIST
41086: LIST
41087: PUSH
41088: LD_INT 1
41090: NEG
41091: PUSH
41092: LD_INT 0
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PUSH
41099: LD_INT 1
41101: NEG
41102: PUSH
41103: LD_INT 1
41105: NEG
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: LIST
41115: LIST
41116: LIST
41117: LIST
41118: LIST
41119: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41120: LD_ADDR_VAR 0 60
41124: PUSH
41125: LD_INT 0
41127: PUSH
41128: LD_INT 0
41130: PUSH
41131: EMPTY
41132: LIST
41133: LIST
41134: PUSH
41135: LD_INT 0
41137: PUSH
41138: LD_INT 1
41140: NEG
41141: PUSH
41142: EMPTY
41143: LIST
41144: LIST
41145: PUSH
41146: LD_INT 1
41148: PUSH
41149: LD_INT 0
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: LD_INT 1
41158: PUSH
41159: LD_INT 1
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: PUSH
41166: LD_INT 0
41168: PUSH
41169: LD_INT 1
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 1
41178: NEG
41179: PUSH
41180: LD_INT 0
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: LD_INT 1
41189: NEG
41190: PUSH
41191: LD_INT 1
41193: NEG
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: LIST
41203: LIST
41204: LIST
41205: LIST
41206: LIST
41207: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41208: LD_ADDR_VAR 0 61
41212: PUSH
41213: LD_INT 0
41215: PUSH
41216: LD_INT 0
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 0
41225: PUSH
41226: LD_INT 1
41228: NEG
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: PUSH
41234: LD_INT 1
41236: PUSH
41237: LD_INT 0
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PUSH
41244: LD_INT 1
41246: PUSH
41247: LD_INT 1
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 0
41256: PUSH
41257: LD_INT 1
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: LD_INT 1
41266: NEG
41267: PUSH
41268: LD_INT 0
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: PUSH
41275: LD_INT 1
41277: NEG
41278: PUSH
41279: LD_INT 1
41281: NEG
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: LIST
41291: LIST
41292: LIST
41293: LIST
41294: LIST
41295: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41296: LD_ADDR_VAR 0 62
41300: PUSH
41301: LD_INT 0
41303: PUSH
41304: LD_INT 0
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: PUSH
41311: LD_INT 0
41313: PUSH
41314: LD_INT 1
41316: NEG
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 1
41324: PUSH
41325: LD_INT 0
41327: PUSH
41328: EMPTY
41329: LIST
41330: LIST
41331: PUSH
41332: LD_INT 1
41334: PUSH
41335: LD_INT 1
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: PUSH
41342: LD_INT 0
41344: PUSH
41345: LD_INT 1
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: PUSH
41352: LD_INT 1
41354: NEG
41355: PUSH
41356: LD_INT 0
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 1
41365: NEG
41366: PUSH
41367: LD_INT 1
41369: NEG
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: LIST
41383: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41384: LD_ADDR_VAR 0 63
41388: PUSH
41389: LD_INT 0
41391: PUSH
41392: LD_INT 0
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 0
41401: PUSH
41402: LD_INT 1
41404: NEG
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: LD_INT 1
41412: PUSH
41413: LD_INT 0
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 1
41422: PUSH
41423: LD_INT 1
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 0
41432: PUSH
41433: LD_INT 1
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: LD_INT 1
41442: NEG
41443: PUSH
41444: LD_INT 0
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 1
41453: NEG
41454: PUSH
41455: LD_INT 1
41457: NEG
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: LIST
41467: LIST
41468: LIST
41469: LIST
41470: LIST
41471: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41472: LD_ADDR_VAR 0 64
41476: PUSH
41477: LD_INT 0
41479: PUSH
41480: LD_INT 0
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 0
41489: PUSH
41490: LD_INT 1
41492: NEG
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: PUSH
41498: LD_INT 1
41500: PUSH
41501: LD_INT 0
41503: PUSH
41504: EMPTY
41505: LIST
41506: LIST
41507: PUSH
41508: LD_INT 1
41510: PUSH
41511: LD_INT 1
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: LD_INT 0
41520: PUSH
41521: LD_INT 1
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: PUSH
41528: LD_INT 1
41530: NEG
41531: PUSH
41532: LD_INT 0
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: LD_INT 1
41541: NEG
41542: PUSH
41543: LD_INT 1
41545: NEG
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: PUSH
41551: EMPTY
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: LIST
41557: LIST
41558: LIST
41559: ST_TO_ADDR
// end ; 1 :
41560: GO 47457
41562: LD_INT 1
41564: DOUBLE
41565: EQUAL
41566: IFTRUE 41570
41568: GO 44193
41570: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41571: LD_ADDR_VAR 0 11
41575: PUSH
41576: LD_INT 1
41578: NEG
41579: PUSH
41580: LD_INT 3
41582: NEG
41583: PUSH
41584: EMPTY
41585: LIST
41586: LIST
41587: PUSH
41588: LD_INT 0
41590: PUSH
41591: LD_INT 3
41593: NEG
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 1
41601: PUSH
41602: LD_INT 2
41604: NEG
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: LIST
41614: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41615: LD_ADDR_VAR 0 12
41619: PUSH
41620: LD_INT 2
41622: PUSH
41623: LD_INT 1
41625: NEG
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 3
41633: PUSH
41634: LD_INT 0
41636: PUSH
41637: EMPTY
41638: LIST
41639: LIST
41640: PUSH
41641: LD_INT 3
41643: PUSH
41644: LD_INT 1
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: LIST
41655: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41656: LD_ADDR_VAR 0 13
41660: PUSH
41661: LD_INT 3
41663: PUSH
41664: LD_INT 2
41666: PUSH
41667: EMPTY
41668: LIST
41669: LIST
41670: PUSH
41671: LD_INT 3
41673: PUSH
41674: LD_INT 3
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: PUSH
41681: LD_INT 2
41683: PUSH
41684: LD_INT 3
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: LIST
41695: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41696: LD_ADDR_VAR 0 14
41700: PUSH
41701: LD_INT 1
41703: PUSH
41704: LD_INT 3
41706: PUSH
41707: EMPTY
41708: LIST
41709: LIST
41710: PUSH
41711: LD_INT 0
41713: PUSH
41714: LD_INT 3
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: PUSH
41721: LD_INT 1
41723: NEG
41724: PUSH
41725: LD_INT 2
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: LIST
41736: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41737: LD_ADDR_VAR 0 15
41741: PUSH
41742: LD_INT 2
41744: NEG
41745: PUSH
41746: LD_INT 1
41748: PUSH
41749: EMPTY
41750: LIST
41751: LIST
41752: PUSH
41753: LD_INT 3
41755: NEG
41756: PUSH
41757: LD_INT 0
41759: PUSH
41760: EMPTY
41761: LIST
41762: LIST
41763: PUSH
41764: LD_INT 3
41766: NEG
41767: PUSH
41768: LD_INT 1
41770: NEG
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: LIST
41780: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41781: LD_ADDR_VAR 0 16
41785: PUSH
41786: LD_INT 2
41788: NEG
41789: PUSH
41790: LD_INT 3
41792: NEG
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 3
41800: NEG
41801: PUSH
41802: LD_INT 2
41804: NEG
41805: PUSH
41806: EMPTY
41807: LIST
41808: LIST
41809: PUSH
41810: LD_INT 3
41812: NEG
41813: PUSH
41814: LD_INT 3
41816: NEG
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: LIST
41826: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41827: LD_ADDR_VAR 0 17
41831: PUSH
41832: LD_INT 1
41834: NEG
41835: PUSH
41836: LD_INT 3
41838: NEG
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: PUSH
41844: LD_INT 0
41846: PUSH
41847: LD_INT 3
41849: NEG
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: PUSH
41855: LD_INT 1
41857: PUSH
41858: LD_INT 2
41860: NEG
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: LIST
41870: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41871: LD_ADDR_VAR 0 18
41875: PUSH
41876: LD_INT 2
41878: PUSH
41879: LD_INT 1
41881: NEG
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: LD_INT 3
41889: PUSH
41890: LD_INT 0
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PUSH
41897: LD_INT 3
41899: PUSH
41900: LD_INT 1
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: LIST
41911: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41912: LD_ADDR_VAR 0 19
41916: PUSH
41917: LD_INT 3
41919: PUSH
41920: LD_INT 2
41922: PUSH
41923: EMPTY
41924: LIST
41925: LIST
41926: PUSH
41927: LD_INT 3
41929: PUSH
41930: LD_INT 3
41932: PUSH
41933: EMPTY
41934: LIST
41935: LIST
41936: PUSH
41937: LD_INT 2
41939: PUSH
41940: LD_INT 3
41942: PUSH
41943: EMPTY
41944: LIST
41945: LIST
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: LIST
41951: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41952: LD_ADDR_VAR 0 20
41956: PUSH
41957: LD_INT 1
41959: PUSH
41960: LD_INT 3
41962: PUSH
41963: EMPTY
41964: LIST
41965: LIST
41966: PUSH
41967: LD_INT 0
41969: PUSH
41970: LD_INT 3
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: PUSH
41977: LD_INT 1
41979: NEG
41980: PUSH
41981: LD_INT 2
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: LIST
41992: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41993: LD_ADDR_VAR 0 21
41997: PUSH
41998: LD_INT 2
42000: NEG
42001: PUSH
42002: LD_INT 1
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 3
42011: NEG
42012: PUSH
42013: LD_INT 0
42015: PUSH
42016: EMPTY
42017: LIST
42018: LIST
42019: PUSH
42020: LD_INT 3
42022: NEG
42023: PUSH
42024: LD_INT 1
42026: NEG
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: LIST
42036: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42037: LD_ADDR_VAR 0 22
42041: PUSH
42042: LD_INT 2
42044: NEG
42045: PUSH
42046: LD_INT 3
42048: NEG
42049: PUSH
42050: EMPTY
42051: LIST
42052: LIST
42053: PUSH
42054: LD_INT 3
42056: NEG
42057: PUSH
42058: LD_INT 2
42060: NEG
42061: PUSH
42062: EMPTY
42063: LIST
42064: LIST
42065: PUSH
42066: LD_INT 3
42068: NEG
42069: PUSH
42070: LD_INT 3
42072: NEG
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: LIST
42082: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
42083: LD_ADDR_VAR 0 23
42087: PUSH
42088: LD_INT 0
42090: PUSH
42091: LD_INT 3
42093: NEG
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 1
42101: NEG
42102: PUSH
42103: LD_INT 4
42105: NEG
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 1
42113: PUSH
42114: LD_INT 3
42116: NEG
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: LIST
42126: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
42127: LD_ADDR_VAR 0 24
42131: PUSH
42132: LD_INT 3
42134: PUSH
42135: LD_INT 0
42137: PUSH
42138: EMPTY
42139: LIST
42140: LIST
42141: PUSH
42142: LD_INT 3
42144: PUSH
42145: LD_INT 1
42147: NEG
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 4
42155: PUSH
42156: LD_INT 1
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: LIST
42167: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
42168: LD_ADDR_VAR 0 25
42172: PUSH
42173: LD_INT 3
42175: PUSH
42176: LD_INT 3
42178: PUSH
42179: EMPTY
42180: LIST
42181: LIST
42182: PUSH
42183: LD_INT 4
42185: PUSH
42186: LD_INT 3
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: PUSH
42193: LD_INT 3
42195: PUSH
42196: LD_INT 4
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: LIST
42207: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
42208: LD_ADDR_VAR 0 26
42212: PUSH
42213: LD_INT 0
42215: PUSH
42216: LD_INT 3
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 1
42225: PUSH
42226: LD_INT 4
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 1
42235: NEG
42236: PUSH
42237: LD_INT 3
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: EMPTY
42245: LIST
42246: LIST
42247: LIST
42248: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
42249: LD_ADDR_VAR 0 27
42253: PUSH
42254: LD_INT 3
42256: NEG
42257: PUSH
42258: LD_INT 0
42260: PUSH
42261: EMPTY
42262: LIST
42263: LIST
42264: PUSH
42265: LD_INT 3
42267: NEG
42268: PUSH
42269: LD_INT 1
42271: PUSH
42272: EMPTY
42273: LIST
42274: LIST
42275: PUSH
42276: LD_INT 4
42278: NEG
42279: PUSH
42280: LD_INT 1
42282: NEG
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: EMPTY
42289: LIST
42290: LIST
42291: LIST
42292: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
42293: LD_ADDR_VAR 0 28
42297: PUSH
42298: LD_INT 3
42300: NEG
42301: PUSH
42302: LD_INT 3
42304: NEG
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 3
42312: NEG
42313: PUSH
42314: LD_INT 4
42316: NEG
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: PUSH
42322: LD_INT 4
42324: NEG
42325: PUSH
42326: LD_INT 3
42328: NEG
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: LIST
42338: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42339: LD_ADDR_VAR 0 29
42343: PUSH
42344: LD_INT 1
42346: NEG
42347: PUSH
42348: LD_INT 3
42350: NEG
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: LD_INT 0
42358: PUSH
42359: LD_INT 3
42361: NEG
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PUSH
42367: LD_INT 1
42369: PUSH
42370: LD_INT 2
42372: NEG
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: PUSH
42378: LD_INT 1
42380: NEG
42381: PUSH
42382: LD_INT 4
42384: NEG
42385: PUSH
42386: EMPTY
42387: LIST
42388: LIST
42389: PUSH
42390: LD_INT 0
42392: PUSH
42393: LD_INT 4
42395: NEG
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 1
42403: PUSH
42404: LD_INT 3
42406: NEG
42407: PUSH
42408: EMPTY
42409: LIST
42410: LIST
42411: PUSH
42412: LD_INT 1
42414: NEG
42415: PUSH
42416: LD_INT 5
42418: NEG
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PUSH
42424: LD_INT 0
42426: PUSH
42427: LD_INT 5
42429: NEG
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 1
42437: PUSH
42438: LD_INT 4
42440: NEG
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 1
42448: NEG
42449: PUSH
42450: LD_INT 6
42452: NEG
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 0
42460: PUSH
42461: LD_INT 6
42463: NEG
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 1
42471: PUSH
42472: LD_INT 5
42474: NEG
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: LIST
42484: LIST
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: LIST
42490: LIST
42491: LIST
42492: LIST
42493: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42494: LD_ADDR_VAR 0 30
42498: PUSH
42499: LD_INT 2
42501: PUSH
42502: LD_INT 1
42504: NEG
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: PUSH
42510: LD_INT 3
42512: PUSH
42513: LD_INT 0
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PUSH
42520: LD_INT 3
42522: PUSH
42523: LD_INT 1
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: PUSH
42530: LD_INT 3
42532: PUSH
42533: LD_INT 1
42535: NEG
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 4
42543: PUSH
42544: LD_INT 0
42546: PUSH
42547: EMPTY
42548: LIST
42549: LIST
42550: PUSH
42551: LD_INT 4
42553: PUSH
42554: LD_INT 1
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: PUSH
42561: LD_INT 4
42563: PUSH
42564: LD_INT 1
42566: NEG
42567: PUSH
42568: EMPTY
42569: LIST
42570: LIST
42571: PUSH
42572: LD_INT 5
42574: PUSH
42575: LD_INT 0
42577: PUSH
42578: EMPTY
42579: LIST
42580: LIST
42581: PUSH
42582: LD_INT 5
42584: PUSH
42585: LD_INT 1
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PUSH
42592: LD_INT 5
42594: PUSH
42595: LD_INT 1
42597: NEG
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: PUSH
42603: LD_INT 6
42605: PUSH
42606: LD_INT 0
42608: PUSH
42609: EMPTY
42610: LIST
42611: LIST
42612: PUSH
42613: LD_INT 6
42615: PUSH
42616: LD_INT 1
42618: PUSH
42619: EMPTY
42620: LIST
42621: LIST
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: LIST
42627: LIST
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: LIST
42635: LIST
42636: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42637: LD_ADDR_VAR 0 31
42641: PUSH
42642: LD_INT 3
42644: PUSH
42645: LD_INT 2
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 3
42654: PUSH
42655: LD_INT 3
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: LD_INT 2
42664: PUSH
42665: LD_INT 3
42667: PUSH
42668: EMPTY
42669: LIST
42670: LIST
42671: PUSH
42672: LD_INT 4
42674: PUSH
42675: LD_INT 3
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 4
42684: PUSH
42685: LD_INT 4
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 3
42694: PUSH
42695: LD_INT 4
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 5
42704: PUSH
42705: LD_INT 4
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 5
42714: PUSH
42715: LD_INT 5
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 4
42724: PUSH
42725: LD_INT 5
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 6
42734: PUSH
42735: LD_INT 5
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: PUSH
42742: LD_INT 6
42744: PUSH
42745: LD_INT 6
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: LD_INT 5
42754: PUSH
42755: LD_INT 6
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42776: LD_ADDR_VAR 0 32
42780: PUSH
42781: LD_INT 1
42783: PUSH
42784: LD_INT 3
42786: PUSH
42787: EMPTY
42788: LIST
42789: LIST
42790: PUSH
42791: LD_INT 0
42793: PUSH
42794: LD_INT 3
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: PUSH
42801: LD_INT 1
42803: NEG
42804: PUSH
42805: LD_INT 2
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: LD_INT 1
42814: PUSH
42815: LD_INT 4
42817: PUSH
42818: EMPTY
42819: LIST
42820: LIST
42821: PUSH
42822: LD_INT 0
42824: PUSH
42825: LD_INT 4
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: PUSH
42832: LD_INT 1
42834: NEG
42835: PUSH
42836: LD_INT 3
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: PUSH
42843: LD_INT 1
42845: PUSH
42846: LD_INT 5
42848: PUSH
42849: EMPTY
42850: LIST
42851: LIST
42852: PUSH
42853: LD_INT 0
42855: PUSH
42856: LD_INT 5
42858: PUSH
42859: EMPTY
42860: LIST
42861: LIST
42862: PUSH
42863: LD_INT 1
42865: NEG
42866: PUSH
42867: LD_INT 4
42869: PUSH
42870: EMPTY
42871: LIST
42872: LIST
42873: PUSH
42874: LD_INT 1
42876: PUSH
42877: LD_INT 6
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PUSH
42884: LD_INT 0
42886: PUSH
42887: LD_INT 6
42889: PUSH
42890: EMPTY
42891: LIST
42892: LIST
42893: PUSH
42894: LD_INT 1
42896: NEG
42897: PUSH
42898: LD_INT 5
42900: PUSH
42901: EMPTY
42902: LIST
42903: LIST
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: LIST
42909: LIST
42910: LIST
42911: LIST
42912: LIST
42913: LIST
42914: LIST
42915: LIST
42916: LIST
42917: LIST
42918: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42919: LD_ADDR_VAR 0 33
42923: PUSH
42924: LD_INT 2
42926: NEG
42927: PUSH
42928: LD_INT 1
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: LD_INT 3
42937: NEG
42938: PUSH
42939: LD_INT 0
42941: PUSH
42942: EMPTY
42943: LIST
42944: LIST
42945: PUSH
42946: LD_INT 3
42948: NEG
42949: PUSH
42950: LD_INT 1
42952: NEG
42953: PUSH
42954: EMPTY
42955: LIST
42956: LIST
42957: PUSH
42958: LD_INT 3
42960: NEG
42961: PUSH
42962: LD_INT 1
42964: PUSH
42965: EMPTY
42966: LIST
42967: LIST
42968: PUSH
42969: LD_INT 4
42971: NEG
42972: PUSH
42973: LD_INT 0
42975: PUSH
42976: EMPTY
42977: LIST
42978: LIST
42979: PUSH
42980: LD_INT 4
42982: NEG
42983: PUSH
42984: LD_INT 1
42986: NEG
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: PUSH
42992: LD_INT 4
42994: NEG
42995: PUSH
42996: LD_INT 1
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: LD_INT 5
43005: NEG
43006: PUSH
43007: LD_INT 0
43009: PUSH
43010: EMPTY
43011: LIST
43012: LIST
43013: PUSH
43014: LD_INT 5
43016: NEG
43017: PUSH
43018: LD_INT 1
43020: NEG
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: LD_INT 5
43028: NEG
43029: PUSH
43030: LD_INT 1
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: LD_INT 6
43039: NEG
43040: PUSH
43041: LD_INT 0
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: PUSH
43048: LD_INT 6
43050: NEG
43051: PUSH
43052: LD_INT 1
43054: NEG
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: PUSH
43060: EMPTY
43061: LIST
43062: LIST
43063: LIST
43064: LIST
43065: LIST
43066: LIST
43067: LIST
43068: LIST
43069: LIST
43070: LIST
43071: LIST
43072: LIST
43073: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
43074: LD_ADDR_VAR 0 34
43078: PUSH
43079: LD_INT 2
43081: NEG
43082: PUSH
43083: LD_INT 3
43085: NEG
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 3
43093: NEG
43094: PUSH
43095: LD_INT 2
43097: NEG
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 3
43105: NEG
43106: PUSH
43107: LD_INT 3
43109: NEG
43110: PUSH
43111: EMPTY
43112: LIST
43113: LIST
43114: PUSH
43115: LD_INT 3
43117: NEG
43118: PUSH
43119: LD_INT 4
43121: NEG
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 4
43129: NEG
43130: PUSH
43131: LD_INT 3
43133: NEG
43134: PUSH
43135: EMPTY
43136: LIST
43137: LIST
43138: PUSH
43139: LD_INT 4
43141: NEG
43142: PUSH
43143: LD_INT 4
43145: NEG
43146: PUSH
43147: EMPTY
43148: LIST
43149: LIST
43150: PUSH
43151: LD_INT 4
43153: NEG
43154: PUSH
43155: LD_INT 5
43157: NEG
43158: PUSH
43159: EMPTY
43160: LIST
43161: LIST
43162: PUSH
43163: LD_INT 5
43165: NEG
43166: PUSH
43167: LD_INT 4
43169: NEG
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: PUSH
43175: LD_INT 5
43177: NEG
43178: PUSH
43179: LD_INT 5
43181: NEG
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PUSH
43187: LD_INT 5
43189: NEG
43190: PUSH
43191: LD_INT 6
43193: NEG
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: LD_INT 6
43201: NEG
43202: PUSH
43203: LD_INT 5
43205: NEG
43206: PUSH
43207: EMPTY
43208: LIST
43209: LIST
43210: PUSH
43211: LD_INT 6
43213: NEG
43214: PUSH
43215: LD_INT 6
43217: NEG
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: LIST
43227: LIST
43228: LIST
43229: LIST
43230: LIST
43231: LIST
43232: LIST
43233: LIST
43234: LIST
43235: LIST
43236: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
43237: LD_ADDR_VAR 0 41
43241: PUSH
43242: LD_INT 0
43244: PUSH
43245: LD_INT 2
43247: NEG
43248: PUSH
43249: EMPTY
43250: LIST
43251: LIST
43252: PUSH
43253: LD_INT 1
43255: NEG
43256: PUSH
43257: LD_INT 3
43259: NEG
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PUSH
43265: LD_INT 1
43267: PUSH
43268: LD_INT 2
43270: NEG
43271: PUSH
43272: EMPTY
43273: LIST
43274: LIST
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: LIST
43280: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
43281: LD_ADDR_VAR 0 42
43285: PUSH
43286: LD_INT 2
43288: PUSH
43289: LD_INT 0
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 2
43298: PUSH
43299: LD_INT 1
43301: NEG
43302: PUSH
43303: EMPTY
43304: LIST
43305: LIST
43306: PUSH
43307: LD_INT 3
43309: PUSH
43310: LD_INT 1
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: LIST
43321: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
43322: LD_ADDR_VAR 0 43
43326: PUSH
43327: LD_INT 2
43329: PUSH
43330: LD_INT 2
43332: PUSH
43333: EMPTY
43334: LIST
43335: LIST
43336: PUSH
43337: LD_INT 3
43339: PUSH
43340: LD_INT 2
43342: PUSH
43343: EMPTY
43344: LIST
43345: LIST
43346: PUSH
43347: LD_INT 2
43349: PUSH
43350: LD_INT 3
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: LIST
43361: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43362: LD_ADDR_VAR 0 44
43366: PUSH
43367: LD_INT 0
43369: PUSH
43370: LD_INT 2
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 1
43379: PUSH
43380: LD_INT 3
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 1
43389: NEG
43390: PUSH
43391: LD_INT 2
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: EMPTY
43399: LIST
43400: LIST
43401: LIST
43402: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43403: LD_ADDR_VAR 0 45
43407: PUSH
43408: LD_INT 2
43410: NEG
43411: PUSH
43412: LD_INT 0
43414: PUSH
43415: EMPTY
43416: LIST
43417: LIST
43418: PUSH
43419: LD_INT 2
43421: NEG
43422: PUSH
43423: LD_INT 1
43425: PUSH
43426: EMPTY
43427: LIST
43428: LIST
43429: PUSH
43430: LD_INT 3
43432: NEG
43433: PUSH
43434: LD_INT 1
43436: NEG
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: EMPTY
43443: LIST
43444: LIST
43445: LIST
43446: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43447: LD_ADDR_VAR 0 46
43451: PUSH
43452: LD_INT 2
43454: NEG
43455: PUSH
43456: LD_INT 2
43458: NEG
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 2
43466: NEG
43467: PUSH
43468: LD_INT 3
43470: NEG
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 3
43478: NEG
43479: PUSH
43480: LD_INT 2
43482: NEG
43483: PUSH
43484: EMPTY
43485: LIST
43486: LIST
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: LIST
43492: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43493: LD_ADDR_VAR 0 47
43497: PUSH
43498: LD_INT 2
43500: NEG
43501: PUSH
43502: LD_INT 3
43504: NEG
43505: PUSH
43506: EMPTY
43507: LIST
43508: LIST
43509: PUSH
43510: LD_INT 1
43512: NEG
43513: PUSH
43514: LD_INT 3
43516: NEG
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43526: LD_ADDR_VAR 0 48
43530: PUSH
43531: LD_INT 1
43533: PUSH
43534: LD_INT 2
43536: NEG
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 2
43544: PUSH
43545: LD_INT 1
43547: NEG
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43557: LD_ADDR_VAR 0 49
43561: PUSH
43562: LD_INT 3
43564: PUSH
43565: LD_INT 1
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 3
43574: PUSH
43575: LD_INT 2
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43586: LD_ADDR_VAR 0 50
43590: PUSH
43591: LD_INT 2
43593: PUSH
43594: LD_INT 3
43596: PUSH
43597: EMPTY
43598: LIST
43599: LIST
43600: PUSH
43601: LD_INT 1
43603: PUSH
43604: LD_INT 3
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: PUSH
43611: EMPTY
43612: LIST
43613: LIST
43614: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43615: LD_ADDR_VAR 0 51
43619: PUSH
43620: LD_INT 1
43622: NEG
43623: PUSH
43624: LD_INT 2
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 2
43633: NEG
43634: PUSH
43635: LD_INT 1
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43646: LD_ADDR_VAR 0 52
43650: PUSH
43651: LD_INT 3
43653: NEG
43654: PUSH
43655: LD_INT 1
43657: NEG
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 3
43665: NEG
43666: PUSH
43667: LD_INT 2
43669: NEG
43670: PUSH
43671: EMPTY
43672: LIST
43673: LIST
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43679: LD_ADDR_VAR 0 53
43683: PUSH
43684: LD_INT 1
43686: NEG
43687: PUSH
43688: LD_INT 3
43690: NEG
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 0
43698: PUSH
43699: LD_INT 3
43701: NEG
43702: PUSH
43703: EMPTY
43704: LIST
43705: LIST
43706: PUSH
43707: LD_INT 1
43709: PUSH
43710: LD_INT 2
43712: NEG
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PUSH
43718: EMPTY
43719: LIST
43720: LIST
43721: LIST
43722: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43723: LD_ADDR_VAR 0 54
43727: PUSH
43728: LD_INT 2
43730: PUSH
43731: LD_INT 1
43733: NEG
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: LD_INT 3
43741: PUSH
43742: LD_INT 0
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 3
43751: PUSH
43752: LD_INT 1
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: PUSH
43759: EMPTY
43760: LIST
43761: LIST
43762: LIST
43763: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43764: LD_ADDR_VAR 0 55
43768: PUSH
43769: LD_INT 3
43771: PUSH
43772: LD_INT 2
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 3
43781: PUSH
43782: LD_INT 3
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 2
43791: PUSH
43792: LD_INT 3
43794: PUSH
43795: EMPTY
43796: LIST
43797: LIST
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: LIST
43803: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43804: LD_ADDR_VAR 0 56
43808: PUSH
43809: LD_INT 1
43811: PUSH
43812: LD_INT 3
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: LD_INT 0
43821: PUSH
43822: LD_INT 3
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 1
43831: NEG
43832: PUSH
43833: LD_INT 2
43835: PUSH
43836: EMPTY
43837: LIST
43838: LIST
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: LIST
43844: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43845: LD_ADDR_VAR 0 57
43849: PUSH
43850: LD_INT 2
43852: NEG
43853: PUSH
43854: LD_INT 1
43856: PUSH
43857: EMPTY
43858: LIST
43859: LIST
43860: PUSH
43861: LD_INT 3
43863: NEG
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: PUSH
43872: LD_INT 3
43874: NEG
43875: PUSH
43876: LD_INT 1
43878: NEG
43879: PUSH
43880: EMPTY
43881: LIST
43882: LIST
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: LIST
43888: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43889: LD_ADDR_VAR 0 58
43893: PUSH
43894: LD_INT 2
43896: NEG
43897: PUSH
43898: LD_INT 3
43900: NEG
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PUSH
43906: LD_INT 3
43908: NEG
43909: PUSH
43910: LD_INT 2
43912: NEG
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: PUSH
43918: LD_INT 3
43920: NEG
43921: PUSH
43922: LD_INT 3
43924: NEG
43925: PUSH
43926: EMPTY
43927: LIST
43928: LIST
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: LIST
43934: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43935: LD_ADDR_VAR 0 59
43939: PUSH
43940: LD_INT 1
43942: NEG
43943: PUSH
43944: LD_INT 2
43946: NEG
43947: PUSH
43948: EMPTY
43949: LIST
43950: LIST
43951: PUSH
43952: LD_INT 0
43954: PUSH
43955: LD_INT 2
43957: NEG
43958: PUSH
43959: EMPTY
43960: LIST
43961: LIST
43962: PUSH
43963: LD_INT 1
43965: PUSH
43966: LD_INT 1
43968: NEG
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: PUSH
43974: EMPTY
43975: LIST
43976: LIST
43977: LIST
43978: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43979: LD_ADDR_VAR 0 60
43983: PUSH
43984: LD_INT 1
43986: PUSH
43987: LD_INT 1
43989: NEG
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: PUSH
43995: LD_INT 2
43997: PUSH
43998: LD_INT 0
44000: PUSH
44001: EMPTY
44002: LIST
44003: LIST
44004: PUSH
44005: LD_INT 2
44007: PUSH
44008: LD_INT 1
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: LIST
44019: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44020: LD_ADDR_VAR 0 61
44024: PUSH
44025: LD_INT 2
44027: PUSH
44028: LD_INT 1
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 2
44037: PUSH
44038: LD_INT 2
44040: PUSH
44041: EMPTY
44042: LIST
44043: LIST
44044: PUSH
44045: LD_INT 1
44047: PUSH
44048: LD_INT 2
44050: PUSH
44051: EMPTY
44052: LIST
44053: LIST
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: LIST
44059: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
44060: LD_ADDR_VAR 0 62
44064: PUSH
44065: LD_INT 1
44067: PUSH
44068: LD_INT 2
44070: PUSH
44071: EMPTY
44072: LIST
44073: LIST
44074: PUSH
44075: LD_INT 0
44077: PUSH
44078: LD_INT 2
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: PUSH
44085: LD_INT 1
44087: NEG
44088: PUSH
44089: LD_INT 1
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: PUSH
44096: EMPTY
44097: LIST
44098: LIST
44099: LIST
44100: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
44101: LD_ADDR_VAR 0 63
44105: PUSH
44106: LD_INT 1
44108: NEG
44109: PUSH
44110: LD_INT 1
44112: PUSH
44113: EMPTY
44114: LIST
44115: LIST
44116: PUSH
44117: LD_INT 2
44119: NEG
44120: PUSH
44121: LD_INT 0
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: LD_INT 2
44130: NEG
44131: PUSH
44132: LD_INT 1
44134: NEG
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: LIST
44144: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44145: LD_ADDR_VAR 0 64
44149: PUSH
44150: LD_INT 1
44152: NEG
44153: PUSH
44154: LD_INT 2
44156: NEG
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 2
44164: NEG
44165: PUSH
44166: LD_INT 1
44168: NEG
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: LD_INT 2
44176: NEG
44177: PUSH
44178: LD_INT 2
44180: NEG
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: LIST
44190: ST_TO_ADDR
// end ; 2 :
44191: GO 47457
44193: LD_INT 2
44195: DOUBLE
44196: EQUAL
44197: IFTRUE 44201
44199: GO 47456
44201: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
44202: LD_ADDR_VAR 0 29
44206: PUSH
44207: LD_INT 4
44209: PUSH
44210: LD_INT 0
44212: PUSH
44213: EMPTY
44214: LIST
44215: LIST
44216: PUSH
44217: LD_INT 4
44219: PUSH
44220: LD_INT 1
44222: NEG
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: PUSH
44228: LD_INT 5
44230: PUSH
44231: LD_INT 0
44233: PUSH
44234: EMPTY
44235: LIST
44236: LIST
44237: PUSH
44238: LD_INT 5
44240: PUSH
44241: LD_INT 1
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PUSH
44248: LD_INT 4
44250: PUSH
44251: LD_INT 1
44253: PUSH
44254: EMPTY
44255: LIST
44256: LIST
44257: PUSH
44258: LD_INT 3
44260: PUSH
44261: LD_INT 0
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: PUSH
44268: LD_INT 3
44270: PUSH
44271: LD_INT 1
44273: NEG
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PUSH
44279: LD_INT 3
44281: PUSH
44282: LD_INT 2
44284: NEG
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PUSH
44290: LD_INT 5
44292: PUSH
44293: LD_INT 2
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 3
44302: PUSH
44303: LD_INT 3
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: PUSH
44310: LD_INT 3
44312: PUSH
44313: LD_INT 2
44315: PUSH
44316: EMPTY
44317: LIST
44318: LIST
44319: PUSH
44320: LD_INT 4
44322: PUSH
44323: LD_INT 3
44325: PUSH
44326: EMPTY
44327: LIST
44328: LIST
44329: PUSH
44330: LD_INT 4
44332: PUSH
44333: LD_INT 4
44335: PUSH
44336: EMPTY
44337: LIST
44338: LIST
44339: PUSH
44340: LD_INT 3
44342: PUSH
44343: LD_INT 4
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 2
44352: PUSH
44353: LD_INT 3
44355: PUSH
44356: EMPTY
44357: LIST
44358: LIST
44359: PUSH
44360: LD_INT 2
44362: PUSH
44363: LD_INT 2
44365: PUSH
44366: EMPTY
44367: LIST
44368: LIST
44369: PUSH
44370: LD_INT 4
44372: PUSH
44373: LD_INT 2
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 2
44382: PUSH
44383: LD_INT 4
44385: PUSH
44386: EMPTY
44387: LIST
44388: LIST
44389: PUSH
44390: LD_INT 0
44392: PUSH
44393: LD_INT 4
44395: PUSH
44396: EMPTY
44397: LIST
44398: LIST
44399: PUSH
44400: LD_INT 0
44402: PUSH
44403: LD_INT 3
44405: PUSH
44406: EMPTY
44407: LIST
44408: LIST
44409: PUSH
44410: LD_INT 1
44412: PUSH
44413: LD_INT 4
44415: PUSH
44416: EMPTY
44417: LIST
44418: LIST
44419: PUSH
44420: LD_INT 1
44422: PUSH
44423: LD_INT 5
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PUSH
44430: LD_INT 0
44432: PUSH
44433: LD_INT 5
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 1
44442: NEG
44443: PUSH
44444: LD_INT 4
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 1
44453: NEG
44454: PUSH
44455: LD_INT 3
44457: PUSH
44458: EMPTY
44459: LIST
44460: LIST
44461: PUSH
44462: LD_INT 2
44464: PUSH
44465: LD_INT 5
44467: PUSH
44468: EMPTY
44469: LIST
44470: LIST
44471: PUSH
44472: LD_INT 2
44474: NEG
44475: PUSH
44476: LD_INT 3
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: PUSH
44483: LD_INT 3
44485: NEG
44486: PUSH
44487: LD_INT 0
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: PUSH
44494: LD_INT 3
44496: NEG
44497: PUSH
44498: LD_INT 1
44500: NEG
44501: PUSH
44502: EMPTY
44503: LIST
44504: LIST
44505: PUSH
44506: LD_INT 2
44508: NEG
44509: PUSH
44510: LD_INT 0
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PUSH
44517: LD_INT 2
44519: NEG
44520: PUSH
44521: LD_INT 1
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 3
44530: NEG
44531: PUSH
44532: LD_INT 1
44534: PUSH
44535: EMPTY
44536: LIST
44537: LIST
44538: PUSH
44539: LD_INT 4
44541: NEG
44542: PUSH
44543: LD_INT 0
44545: PUSH
44546: EMPTY
44547: LIST
44548: LIST
44549: PUSH
44550: LD_INT 4
44552: NEG
44553: PUSH
44554: LD_INT 1
44556: NEG
44557: PUSH
44558: EMPTY
44559: LIST
44560: LIST
44561: PUSH
44562: LD_INT 4
44564: NEG
44565: PUSH
44566: LD_INT 2
44568: NEG
44569: PUSH
44570: EMPTY
44571: LIST
44572: LIST
44573: PUSH
44574: LD_INT 2
44576: NEG
44577: PUSH
44578: LD_INT 2
44580: PUSH
44581: EMPTY
44582: LIST
44583: LIST
44584: PUSH
44585: LD_INT 4
44587: NEG
44588: PUSH
44589: LD_INT 4
44591: NEG
44592: PUSH
44593: EMPTY
44594: LIST
44595: LIST
44596: PUSH
44597: LD_INT 4
44599: NEG
44600: PUSH
44601: LD_INT 5
44603: NEG
44604: PUSH
44605: EMPTY
44606: LIST
44607: LIST
44608: PUSH
44609: LD_INT 3
44611: NEG
44612: PUSH
44613: LD_INT 4
44615: NEG
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 3
44623: NEG
44624: PUSH
44625: LD_INT 3
44627: NEG
44628: PUSH
44629: EMPTY
44630: LIST
44631: LIST
44632: PUSH
44633: LD_INT 4
44635: NEG
44636: PUSH
44637: LD_INT 3
44639: NEG
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 5
44647: NEG
44648: PUSH
44649: LD_INT 4
44651: NEG
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 5
44659: NEG
44660: PUSH
44661: LD_INT 5
44663: NEG
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PUSH
44669: LD_INT 3
44671: NEG
44672: PUSH
44673: LD_INT 5
44675: NEG
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 5
44683: NEG
44684: PUSH
44685: LD_INT 3
44687: NEG
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: PUSH
44693: EMPTY
44694: LIST
44695: LIST
44696: LIST
44697: LIST
44698: LIST
44699: LIST
44700: LIST
44701: LIST
44702: LIST
44703: LIST
44704: LIST
44705: LIST
44706: LIST
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: LIST
44713: LIST
44714: LIST
44715: LIST
44716: LIST
44717: LIST
44718: LIST
44719: LIST
44720: LIST
44721: LIST
44722: LIST
44723: LIST
44724: LIST
44725: LIST
44726: LIST
44727: LIST
44728: LIST
44729: LIST
44730: LIST
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: LIST
44736: LIST
44737: LIST
44738: LIST
44739: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44740: LD_ADDR_VAR 0 30
44744: PUSH
44745: LD_INT 4
44747: PUSH
44748: LD_INT 4
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 4
44757: PUSH
44758: LD_INT 3
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: PUSH
44765: LD_INT 5
44767: PUSH
44768: LD_INT 4
44770: PUSH
44771: EMPTY
44772: LIST
44773: LIST
44774: PUSH
44775: LD_INT 5
44777: PUSH
44778: LD_INT 5
44780: PUSH
44781: EMPTY
44782: LIST
44783: LIST
44784: PUSH
44785: LD_INT 4
44787: PUSH
44788: LD_INT 5
44790: PUSH
44791: EMPTY
44792: LIST
44793: LIST
44794: PUSH
44795: LD_INT 3
44797: PUSH
44798: LD_INT 4
44800: PUSH
44801: EMPTY
44802: LIST
44803: LIST
44804: PUSH
44805: LD_INT 3
44807: PUSH
44808: LD_INT 3
44810: PUSH
44811: EMPTY
44812: LIST
44813: LIST
44814: PUSH
44815: LD_INT 5
44817: PUSH
44818: LD_INT 3
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: LD_INT 3
44827: PUSH
44828: LD_INT 5
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PUSH
44835: LD_INT 0
44837: PUSH
44838: LD_INT 3
44840: PUSH
44841: EMPTY
44842: LIST
44843: LIST
44844: PUSH
44845: LD_INT 0
44847: PUSH
44848: LD_INT 2
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: LD_INT 1
44857: PUSH
44858: LD_INT 3
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_INT 1
44867: PUSH
44868: LD_INT 4
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 0
44877: PUSH
44878: LD_INT 4
44880: PUSH
44881: EMPTY
44882: LIST
44883: LIST
44884: PUSH
44885: LD_INT 1
44887: NEG
44888: PUSH
44889: LD_INT 3
44891: PUSH
44892: EMPTY
44893: LIST
44894: LIST
44895: PUSH
44896: LD_INT 1
44898: NEG
44899: PUSH
44900: LD_INT 2
44902: PUSH
44903: EMPTY
44904: LIST
44905: LIST
44906: PUSH
44907: LD_INT 2
44909: PUSH
44910: LD_INT 4
44912: PUSH
44913: EMPTY
44914: LIST
44915: LIST
44916: PUSH
44917: LD_INT 2
44919: NEG
44920: PUSH
44921: LD_INT 2
44923: PUSH
44924: EMPTY
44925: LIST
44926: LIST
44927: PUSH
44928: LD_INT 4
44930: NEG
44931: PUSH
44932: LD_INT 0
44934: PUSH
44935: EMPTY
44936: LIST
44937: LIST
44938: PUSH
44939: LD_INT 4
44941: NEG
44942: PUSH
44943: LD_INT 1
44945: NEG
44946: PUSH
44947: EMPTY
44948: LIST
44949: LIST
44950: PUSH
44951: LD_INT 3
44953: NEG
44954: PUSH
44955: LD_INT 0
44957: PUSH
44958: EMPTY
44959: LIST
44960: LIST
44961: PUSH
44962: LD_INT 3
44964: NEG
44965: PUSH
44966: LD_INT 1
44968: PUSH
44969: EMPTY
44970: LIST
44971: LIST
44972: PUSH
44973: LD_INT 4
44975: NEG
44976: PUSH
44977: LD_INT 1
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: PUSH
44984: LD_INT 5
44986: NEG
44987: PUSH
44988: LD_INT 0
44990: PUSH
44991: EMPTY
44992: LIST
44993: LIST
44994: PUSH
44995: LD_INT 5
44997: NEG
44998: PUSH
44999: LD_INT 1
45001: NEG
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: LD_INT 5
45009: NEG
45010: PUSH
45011: LD_INT 2
45013: NEG
45014: PUSH
45015: EMPTY
45016: LIST
45017: LIST
45018: PUSH
45019: LD_INT 3
45021: NEG
45022: PUSH
45023: LD_INT 2
45025: PUSH
45026: EMPTY
45027: LIST
45028: LIST
45029: PUSH
45030: LD_INT 3
45032: NEG
45033: PUSH
45034: LD_INT 3
45036: NEG
45037: PUSH
45038: EMPTY
45039: LIST
45040: LIST
45041: PUSH
45042: LD_INT 3
45044: NEG
45045: PUSH
45046: LD_INT 4
45048: NEG
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PUSH
45054: LD_INT 2
45056: NEG
45057: PUSH
45058: LD_INT 3
45060: NEG
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PUSH
45066: LD_INT 2
45068: NEG
45069: PUSH
45070: LD_INT 2
45072: NEG
45073: PUSH
45074: EMPTY
45075: LIST
45076: LIST
45077: PUSH
45078: LD_INT 3
45080: NEG
45081: PUSH
45082: LD_INT 2
45084: NEG
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: PUSH
45090: LD_INT 4
45092: NEG
45093: PUSH
45094: LD_INT 3
45096: NEG
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: PUSH
45102: LD_INT 4
45104: NEG
45105: PUSH
45106: LD_INT 4
45108: NEG
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 2
45116: NEG
45117: PUSH
45118: LD_INT 4
45120: NEG
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 4
45128: NEG
45129: PUSH
45130: LD_INT 2
45132: NEG
45133: PUSH
45134: EMPTY
45135: LIST
45136: LIST
45137: PUSH
45138: LD_INT 0
45140: PUSH
45141: LD_INT 4
45143: NEG
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: LD_INT 0
45151: PUSH
45152: LD_INT 5
45154: NEG
45155: PUSH
45156: EMPTY
45157: LIST
45158: LIST
45159: PUSH
45160: LD_INT 1
45162: PUSH
45163: LD_INT 4
45165: NEG
45166: PUSH
45167: EMPTY
45168: LIST
45169: LIST
45170: PUSH
45171: LD_INT 1
45173: PUSH
45174: LD_INT 3
45176: NEG
45177: PUSH
45178: EMPTY
45179: LIST
45180: LIST
45181: PUSH
45182: LD_INT 0
45184: PUSH
45185: LD_INT 3
45187: NEG
45188: PUSH
45189: EMPTY
45190: LIST
45191: LIST
45192: PUSH
45193: LD_INT 1
45195: NEG
45196: PUSH
45197: LD_INT 4
45199: NEG
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: PUSH
45205: LD_INT 1
45207: NEG
45208: PUSH
45209: LD_INT 5
45211: NEG
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: PUSH
45217: LD_INT 2
45219: PUSH
45220: LD_INT 3
45222: NEG
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: PUSH
45228: LD_INT 2
45230: NEG
45231: PUSH
45232: LD_INT 5
45234: NEG
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: LIST
45244: LIST
45245: LIST
45246: LIST
45247: LIST
45248: LIST
45249: LIST
45250: LIST
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: LIST
45272: LIST
45273: LIST
45274: LIST
45275: LIST
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: LIST
45281: LIST
45282: LIST
45283: LIST
45284: LIST
45285: LIST
45286: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
45287: LD_ADDR_VAR 0 31
45291: PUSH
45292: LD_INT 0
45294: PUSH
45295: LD_INT 4
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: PUSH
45302: LD_INT 0
45304: PUSH
45305: LD_INT 3
45307: PUSH
45308: EMPTY
45309: LIST
45310: LIST
45311: PUSH
45312: LD_INT 1
45314: PUSH
45315: LD_INT 4
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PUSH
45322: LD_INT 1
45324: PUSH
45325: LD_INT 5
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: PUSH
45332: LD_INT 0
45334: PUSH
45335: LD_INT 5
45337: PUSH
45338: EMPTY
45339: LIST
45340: LIST
45341: PUSH
45342: LD_INT 1
45344: NEG
45345: PUSH
45346: LD_INT 4
45348: PUSH
45349: EMPTY
45350: LIST
45351: LIST
45352: PUSH
45353: LD_INT 1
45355: NEG
45356: PUSH
45357: LD_INT 3
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 2
45366: PUSH
45367: LD_INT 5
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: PUSH
45374: LD_INT 2
45376: NEG
45377: PUSH
45378: LD_INT 3
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: PUSH
45385: LD_INT 3
45387: NEG
45388: PUSH
45389: LD_INT 0
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: PUSH
45396: LD_INT 3
45398: NEG
45399: PUSH
45400: LD_INT 1
45402: NEG
45403: PUSH
45404: EMPTY
45405: LIST
45406: LIST
45407: PUSH
45408: LD_INT 2
45410: NEG
45411: PUSH
45412: LD_INT 0
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 2
45421: NEG
45422: PUSH
45423: LD_INT 1
45425: PUSH
45426: EMPTY
45427: LIST
45428: LIST
45429: PUSH
45430: LD_INT 3
45432: NEG
45433: PUSH
45434: LD_INT 1
45436: PUSH
45437: EMPTY
45438: LIST
45439: LIST
45440: PUSH
45441: LD_INT 4
45443: NEG
45444: PUSH
45445: LD_INT 0
45447: PUSH
45448: EMPTY
45449: LIST
45450: LIST
45451: PUSH
45452: LD_INT 4
45454: NEG
45455: PUSH
45456: LD_INT 1
45458: NEG
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: PUSH
45464: LD_INT 4
45466: NEG
45467: PUSH
45468: LD_INT 2
45470: NEG
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: PUSH
45476: LD_INT 2
45478: NEG
45479: PUSH
45480: LD_INT 2
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: PUSH
45487: LD_INT 4
45489: NEG
45490: PUSH
45491: LD_INT 4
45493: NEG
45494: PUSH
45495: EMPTY
45496: LIST
45497: LIST
45498: PUSH
45499: LD_INT 4
45501: NEG
45502: PUSH
45503: LD_INT 5
45505: NEG
45506: PUSH
45507: EMPTY
45508: LIST
45509: LIST
45510: PUSH
45511: LD_INT 3
45513: NEG
45514: PUSH
45515: LD_INT 4
45517: NEG
45518: PUSH
45519: EMPTY
45520: LIST
45521: LIST
45522: PUSH
45523: LD_INT 3
45525: NEG
45526: PUSH
45527: LD_INT 3
45529: NEG
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: PUSH
45535: LD_INT 4
45537: NEG
45538: PUSH
45539: LD_INT 3
45541: NEG
45542: PUSH
45543: EMPTY
45544: LIST
45545: LIST
45546: PUSH
45547: LD_INT 5
45549: NEG
45550: PUSH
45551: LD_INT 4
45553: NEG
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 5
45561: NEG
45562: PUSH
45563: LD_INT 5
45565: NEG
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 3
45573: NEG
45574: PUSH
45575: LD_INT 5
45577: NEG
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: PUSH
45583: LD_INT 5
45585: NEG
45586: PUSH
45587: LD_INT 3
45589: NEG
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: PUSH
45595: LD_INT 0
45597: PUSH
45598: LD_INT 3
45600: NEG
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: PUSH
45606: LD_INT 0
45608: PUSH
45609: LD_INT 4
45611: NEG
45612: PUSH
45613: EMPTY
45614: LIST
45615: LIST
45616: PUSH
45617: LD_INT 1
45619: PUSH
45620: LD_INT 3
45622: NEG
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PUSH
45628: LD_INT 1
45630: PUSH
45631: LD_INT 2
45633: NEG
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: PUSH
45639: LD_INT 0
45641: PUSH
45642: LD_INT 2
45644: NEG
45645: PUSH
45646: EMPTY
45647: LIST
45648: LIST
45649: PUSH
45650: LD_INT 1
45652: NEG
45653: PUSH
45654: LD_INT 3
45656: NEG
45657: PUSH
45658: EMPTY
45659: LIST
45660: LIST
45661: PUSH
45662: LD_INT 1
45664: NEG
45665: PUSH
45666: LD_INT 4
45668: NEG
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: LD_INT 2
45676: PUSH
45677: LD_INT 2
45679: NEG
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: PUSH
45685: LD_INT 2
45687: NEG
45688: PUSH
45689: LD_INT 4
45691: NEG
45692: PUSH
45693: EMPTY
45694: LIST
45695: LIST
45696: PUSH
45697: LD_INT 4
45699: PUSH
45700: LD_INT 0
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: PUSH
45707: LD_INT 4
45709: PUSH
45710: LD_INT 1
45712: NEG
45713: PUSH
45714: EMPTY
45715: LIST
45716: LIST
45717: PUSH
45718: LD_INT 5
45720: PUSH
45721: LD_INT 0
45723: PUSH
45724: EMPTY
45725: LIST
45726: LIST
45727: PUSH
45728: LD_INT 5
45730: PUSH
45731: LD_INT 1
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: PUSH
45738: LD_INT 4
45740: PUSH
45741: LD_INT 1
45743: PUSH
45744: EMPTY
45745: LIST
45746: LIST
45747: PUSH
45748: LD_INT 3
45750: PUSH
45751: LD_INT 0
45753: PUSH
45754: EMPTY
45755: LIST
45756: LIST
45757: PUSH
45758: LD_INT 3
45760: PUSH
45761: LD_INT 1
45763: NEG
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 3
45771: PUSH
45772: LD_INT 2
45774: NEG
45775: PUSH
45776: EMPTY
45777: LIST
45778: LIST
45779: PUSH
45780: LD_INT 5
45782: PUSH
45783: LD_INT 2
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45837: LD_ADDR_VAR 0 32
45841: PUSH
45842: LD_INT 4
45844: NEG
45845: PUSH
45846: LD_INT 0
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: PUSH
45853: LD_INT 4
45855: NEG
45856: PUSH
45857: LD_INT 1
45859: NEG
45860: PUSH
45861: EMPTY
45862: LIST
45863: LIST
45864: PUSH
45865: LD_INT 3
45867: NEG
45868: PUSH
45869: LD_INT 0
45871: PUSH
45872: EMPTY
45873: LIST
45874: LIST
45875: PUSH
45876: LD_INT 3
45878: NEG
45879: PUSH
45880: LD_INT 1
45882: PUSH
45883: EMPTY
45884: LIST
45885: LIST
45886: PUSH
45887: LD_INT 4
45889: NEG
45890: PUSH
45891: LD_INT 1
45893: PUSH
45894: EMPTY
45895: LIST
45896: LIST
45897: PUSH
45898: LD_INT 5
45900: NEG
45901: PUSH
45902: LD_INT 0
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 5
45911: NEG
45912: PUSH
45913: LD_INT 1
45915: NEG
45916: PUSH
45917: EMPTY
45918: LIST
45919: LIST
45920: PUSH
45921: LD_INT 5
45923: NEG
45924: PUSH
45925: LD_INT 2
45927: NEG
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 3
45935: NEG
45936: PUSH
45937: LD_INT 2
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 3
45946: NEG
45947: PUSH
45948: LD_INT 3
45950: NEG
45951: PUSH
45952: EMPTY
45953: LIST
45954: LIST
45955: PUSH
45956: LD_INT 3
45958: NEG
45959: PUSH
45960: LD_INT 4
45962: NEG
45963: PUSH
45964: EMPTY
45965: LIST
45966: LIST
45967: PUSH
45968: LD_INT 2
45970: NEG
45971: PUSH
45972: LD_INT 3
45974: NEG
45975: PUSH
45976: EMPTY
45977: LIST
45978: LIST
45979: PUSH
45980: LD_INT 2
45982: NEG
45983: PUSH
45984: LD_INT 2
45986: NEG
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: PUSH
45992: LD_INT 3
45994: NEG
45995: PUSH
45996: LD_INT 2
45998: NEG
45999: PUSH
46000: EMPTY
46001: LIST
46002: LIST
46003: PUSH
46004: LD_INT 4
46006: NEG
46007: PUSH
46008: LD_INT 3
46010: NEG
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PUSH
46016: LD_INT 4
46018: NEG
46019: PUSH
46020: LD_INT 4
46022: NEG
46023: PUSH
46024: EMPTY
46025: LIST
46026: LIST
46027: PUSH
46028: LD_INT 2
46030: NEG
46031: PUSH
46032: LD_INT 4
46034: NEG
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: PUSH
46040: LD_INT 4
46042: NEG
46043: PUSH
46044: LD_INT 2
46046: NEG
46047: PUSH
46048: EMPTY
46049: LIST
46050: LIST
46051: PUSH
46052: LD_INT 0
46054: PUSH
46055: LD_INT 4
46057: NEG
46058: PUSH
46059: EMPTY
46060: LIST
46061: LIST
46062: PUSH
46063: LD_INT 0
46065: PUSH
46066: LD_INT 5
46068: NEG
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: PUSH
46074: LD_INT 1
46076: PUSH
46077: LD_INT 4
46079: NEG
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 1
46087: PUSH
46088: LD_INT 3
46090: NEG
46091: PUSH
46092: EMPTY
46093: LIST
46094: LIST
46095: PUSH
46096: LD_INT 0
46098: PUSH
46099: LD_INT 3
46101: NEG
46102: PUSH
46103: EMPTY
46104: LIST
46105: LIST
46106: PUSH
46107: LD_INT 1
46109: NEG
46110: PUSH
46111: LD_INT 4
46113: NEG
46114: PUSH
46115: EMPTY
46116: LIST
46117: LIST
46118: PUSH
46119: LD_INT 1
46121: NEG
46122: PUSH
46123: LD_INT 5
46125: NEG
46126: PUSH
46127: EMPTY
46128: LIST
46129: LIST
46130: PUSH
46131: LD_INT 2
46133: PUSH
46134: LD_INT 3
46136: NEG
46137: PUSH
46138: EMPTY
46139: LIST
46140: LIST
46141: PUSH
46142: LD_INT 2
46144: NEG
46145: PUSH
46146: LD_INT 5
46148: NEG
46149: PUSH
46150: EMPTY
46151: LIST
46152: LIST
46153: PUSH
46154: LD_INT 3
46156: PUSH
46157: LD_INT 0
46159: PUSH
46160: EMPTY
46161: LIST
46162: LIST
46163: PUSH
46164: LD_INT 3
46166: PUSH
46167: LD_INT 1
46169: NEG
46170: PUSH
46171: EMPTY
46172: LIST
46173: LIST
46174: PUSH
46175: LD_INT 4
46177: PUSH
46178: LD_INT 0
46180: PUSH
46181: EMPTY
46182: LIST
46183: LIST
46184: PUSH
46185: LD_INT 4
46187: PUSH
46188: LD_INT 1
46190: PUSH
46191: EMPTY
46192: LIST
46193: LIST
46194: PUSH
46195: LD_INT 3
46197: PUSH
46198: LD_INT 1
46200: PUSH
46201: EMPTY
46202: LIST
46203: LIST
46204: PUSH
46205: LD_INT 2
46207: PUSH
46208: LD_INT 0
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: PUSH
46215: LD_INT 2
46217: PUSH
46218: LD_INT 1
46220: NEG
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: PUSH
46226: LD_INT 2
46228: PUSH
46229: LD_INT 2
46231: NEG
46232: PUSH
46233: EMPTY
46234: LIST
46235: LIST
46236: PUSH
46237: LD_INT 4
46239: PUSH
46240: LD_INT 2
46242: PUSH
46243: EMPTY
46244: LIST
46245: LIST
46246: PUSH
46247: LD_INT 4
46249: PUSH
46250: LD_INT 4
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: PUSH
46257: LD_INT 4
46259: PUSH
46260: LD_INT 3
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PUSH
46267: LD_INT 5
46269: PUSH
46270: LD_INT 4
46272: PUSH
46273: EMPTY
46274: LIST
46275: LIST
46276: PUSH
46277: LD_INT 5
46279: PUSH
46280: LD_INT 5
46282: PUSH
46283: EMPTY
46284: LIST
46285: LIST
46286: PUSH
46287: LD_INT 4
46289: PUSH
46290: LD_INT 5
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: PUSH
46297: LD_INT 3
46299: PUSH
46300: LD_INT 4
46302: PUSH
46303: EMPTY
46304: LIST
46305: LIST
46306: PUSH
46307: LD_INT 3
46309: PUSH
46310: LD_INT 3
46312: PUSH
46313: EMPTY
46314: LIST
46315: LIST
46316: PUSH
46317: LD_INT 5
46319: PUSH
46320: LD_INT 3
46322: PUSH
46323: EMPTY
46324: LIST
46325: LIST
46326: PUSH
46327: LD_INT 3
46329: PUSH
46330: LD_INT 5
46332: PUSH
46333: EMPTY
46334: LIST
46335: LIST
46336: PUSH
46337: EMPTY
46338: LIST
46339: LIST
46340: LIST
46341: LIST
46342: LIST
46343: LIST
46344: LIST
46345: LIST
46346: LIST
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: LIST
46359: LIST
46360: LIST
46361: LIST
46362: LIST
46363: LIST
46364: LIST
46365: LIST
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46384: LD_ADDR_VAR 0 33
46388: PUSH
46389: LD_INT 4
46391: NEG
46392: PUSH
46393: LD_INT 4
46395: NEG
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 4
46403: NEG
46404: PUSH
46405: LD_INT 5
46407: NEG
46408: PUSH
46409: EMPTY
46410: LIST
46411: LIST
46412: PUSH
46413: LD_INT 3
46415: NEG
46416: PUSH
46417: LD_INT 4
46419: NEG
46420: PUSH
46421: EMPTY
46422: LIST
46423: LIST
46424: PUSH
46425: LD_INT 3
46427: NEG
46428: PUSH
46429: LD_INT 3
46431: NEG
46432: PUSH
46433: EMPTY
46434: LIST
46435: LIST
46436: PUSH
46437: LD_INT 4
46439: NEG
46440: PUSH
46441: LD_INT 3
46443: NEG
46444: PUSH
46445: EMPTY
46446: LIST
46447: LIST
46448: PUSH
46449: LD_INT 5
46451: NEG
46452: PUSH
46453: LD_INT 4
46455: NEG
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PUSH
46461: LD_INT 5
46463: NEG
46464: PUSH
46465: LD_INT 5
46467: NEG
46468: PUSH
46469: EMPTY
46470: LIST
46471: LIST
46472: PUSH
46473: LD_INT 3
46475: NEG
46476: PUSH
46477: LD_INT 5
46479: NEG
46480: PUSH
46481: EMPTY
46482: LIST
46483: LIST
46484: PUSH
46485: LD_INT 5
46487: NEG
46488: PUSH
46489: LD_INT 3
46491: NEG
46492: PUSH
46493: EMPTY
46494: LIST
46495: LIST
46496: PUSH
46497: LD_INT 0
46499: PUSH
46500: LD_INT 3
46502: NEG
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 0
46510: PUSH
46511: LD_INT 4
46513: NEG
46514: PUSH
46515: EMPTY
46516: LIST
46517: LIST
46518: PUSH
46519: LD_INT 1
46521: PUSH
46522: LD_INT 3
46524: NEG
46525: PUSH
46526: EMPTY
46527: LIST
46528: LIST
46529: PUSH
46530: LD_INT 1
46532: PUSH
46533: LD_INT 2
46535: NEG
46536: PUSH
46537: EMPTY
46538: LIST
46539: LIST
46540: PUSH
46541: LD_INT 0
46543: PUSH
46544: LD_INT 2
46546: NEG
46547: PUSH
46548: EMPTY
46549: LIST
46550: LIST
46551: PUSH
46552: LD_INT 1
46554: NEG
46555: PUSH
46556: LD_INT 3
46558: NEG
46559: PUSH
46560: EMPTY
46561: LIST
46562: LIST
46563: PUSH
46564: LD_INT 1
46566: NEG
46567: PUSH
46568: LD_INT 4
46570: NEG
46571: PUSH
46572: EMPTY
46573: LIST
46574: LIST
46575: PUSH
46576: LD_INT 2
46578: PUSH
46579: LD_INT 2
46581: NEG
46582: PUSH
46583: EMPTY
46584: LIST
46585: LIST
46586: PUSH
46587: LD_INT 2
46589: NEG
46590: PUSH
46591: LD_INT 4
46593: NEG
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: PUSH
46599: LD_INT 4
46601: PUSH
46602: LD_INT 0
46604: PUSH
46605: EMPTY
46606: LIST
46607: LIST
46608: PUSH
46609: LD_INT 4
46611: PUSH
46612: LD_INT 1
46614: NEG
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: PUSH
46620: LD_INT 5
46622: PUSH
46623: LD_INT 0
46625: PUSH
46626: EMPTY
46627: LIST
46628: LIST
46629: PUSH
46630: LD_INT 5
46632: PUSH
46633: LD_INT 1
46635: PUSH
46636: EMPTY
46637: LIST
46638: LIST
46639: PUSH
46640: LD_INT 4
46642: PUSH
46643: LD_INT 1
46645: PUSH
46646: EMPTY
46647: LIST
46648: LIST
46649: PUSH
46650: LD_INT 3
46652: PUSH
46653: LD_INT 0
46655: PUSH
46656: EMPTY
46657: LIST
46658: LIST
46659: PUSH
46660: LD_INT 3
46662: PUSH
46663: LD_INT 1
46665: NEG
46666: PUSH
46667: EMPTY
46668: LIST
46669: LIST
46670: PUSH
46671: LD_INT 3
46673: PUSH
46674: LD_INT 2
46676: NEG
46677: PUSH
46678: EMPTY
46679: LIST
46680: LIST
46681: PUSH
46682: LD_INT 5
46684: PUSH
46685: LD_INT 2
46687: PUSH
46688: EMPTY
46689: LIST
46690: LIST
46691: PUSH
46692: LD_INT 3
46694: PUSH
46695: LD_INT 3
46697: PUSH
46698: EMPTY
46699: LIST
46700: LIST
46701: PUSH
46702: LD_INT 3
46704: PUSH
46705: LD_INT 2
46707: PUSH
46708: EMPTY
46709: LIST
46710: LIST
46711: PUSH
46712: LD_INT 4
46714: PUSH
46715: LD_INT 3
46717: PUSH
46718: EMPTY
46719: LIST
46720: LIST
46721: PUSH
46722: LD_INT 4
46724: PUSH
46725: LD_INT 4
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: PUSH
46732: LD_INT 3
46734: PUSH
46735: LD_INT 4
46737: PUSH
46738: EMPTY
46739: LIST
46740: LIST
46741: PUSH
46742: LD_INT 2
46744: PUSH
46745: LD_INT 3
46747: PUSH
46748: EMPTY
46749: LIST
46750: LIST
46751: PUSH
46752: LD_INT 2
46754: PUSH
46755: LD_INT 2
46757: PUSH
46758: EMPTY
46759: LIST
46760: LIST
46761: PUSH
46762: LD_INT 4
46764: PUSH
46765: LD_INT 2
46767: PUSH
46768: EMPTY
46769: LIST
46770: LIST
46771: PUSH
46772: LD_INT 2
46774: PUSH
46775: LD_INT 4
46777: PUSH
46778: EMPTY
46779: LIST
46780: LIST
46781: PUSH
46782: LD_INT 0
46784: PUSH
46785: LD_INT 4
46787: PUSH
46788: EMPTY
46789: LIST
46790: LIST
46791: PUSH
46792: LD_INT 0
46794: PUSH
46795: LD_INT 3
46797: PUSH
46798: EMPTY
46799: LIST
46800: LIST
46801: PUSH
46802: LD_INT 1
46804: PUSH
46805: LD_INT 4
46807: PUSH
46808: EMPTY
46809: LIST
46810: LIST
46811: PUSH
46812: LD_INT 1
46814: PUSH
46815: LD_INT 5
46817: PUSH
46818: EMPTY
46819: LIST
46820: LIST
46821: PUSH
46822: LD_INT 0
46824: PUSH
46825: LD_INT 5
46827: PUSH
46828: EMPTY
46829: LIST
46830: LIST
46831: PUSH
46832: LD_INT 1
46834: NEG
46835: PUSH
46836: LD_INT 4
46838: PUSH
46839: EMPTY
46840: LIST
46841: LIST
46842: PUSH
46843: LD_INT 1
46845: NEG
46846: PUSH
46847: LD_INT 3
46849: PUSH
46850: EMPTY
46851: LIST
46852: LIST
46853: PUSH
46854: LD_INT 2
46856: PUSH
46857: LD_INT 5
46859: PUSH
46860: EMPTY
46861: LIST
46862: LIST
46863: PUSH
46864: LD_INT 2
46866: NEG
46867: PUSH
46868: LD_INT 3
46870: PUSH
46871: EMPTY
46872: LIST
46873: LIST
46874: PUSH
46875: EMPTY
46876: LIST
46877: LIST
46878: LIST
46879: LIST
46880: LIST
46881: LIST
46882: LIST
46883: LIST
46884: LIST
46885: LIST
46886: LIST
46887: LIST
46888: LIST
46889: LIST
46890: LIST
46891: LIST
46892: LIST
46893: LIST
46894: LIST
46895: LIST
46896: LIST
46897: LIST
46898: LIST
46899: LIST
46900: LIST
46901: LIST
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: LIST
46919: LIST
46920: LIST
46921: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46922: LD_ADDR_VAR 0 34
46926: PUSH
46927: LD_INT 0
46929: PUSH
46930: LD_INT 4
46932: NEG
46933: PUSH
46934: EMPTY
46935: LIST
46936: LIST
46937: PUSH
46938: LD_INT 0
46940: PUSH
46941: LD_INT 5
46943: NEG
46944: PUSH
46945: EMPTY
46946: LIST
46947: LIST
46948: PUSH
46949: LD_INT 1
46951: PUSH
46952: LD_INT 4
46954: NEG
46955: PUSH
46956: EMPTY
46957: LIST
46958: LIST
46959: PUSH
46960: LD_INT 1
46962: PUSH
46963: LD_INT 3
46965: NEG
46966: PUSH
46967: EMPTY
46968: LIST
46969: LIST
46970: PUSH
46971: LD_INT 0
46973: PUSH
46974: LD_INT 3
46976: NEG
46977: PUSH
46978: EMPTY
46979: LIST
46980: LIST
46981: PUSH
46982: LD_INT 1
46984: NEG
46985: PUSH
46986: LD_INT 4
46988: NEG
46989: PUSH
46990: EMPTY
46991: LIST
46992: LIST
46993: PUSH
46994: LD_INT 1
46996: NEG
46997: PUSH
46998: LD_INT 5
47000: NEG
47001: PUSH
47002: EMPTY
47003: LIST
47004: LIST
47005: PUSH
47006: LD_INT 2
47008: PUSH
47009: LD_INT 3
47011: NEG
47012: PUSH
47013: EMPTY
47014: LIST
47015: LIST
47016: PUSH
47017: LD_INT 2
47019: NEG
47020: PUSH
47021: LD_INT 5
47023: NEG
47024: PUSH
47025: EMPTY
47026: LIST
47027: LIST
47028: PUSH
47029: LD_INT 3
47031: PUSH
47032: LD_INT 0
47034: PUSH
47035: EMPTY
47036: LIST
47037: LIST
47038: PUSH
47039: LD_INT 3
47041: PUSH
47042: LD_INT 1
47044: NEG
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: PUSH
47050: LD_INT 4
47052: PUSH
47053: LD_INT 0
47055: PUSH
47056: EMPTY
47057: LIST
47058: LIST
47059: PUSH
47060: LD_INT 4
47062: PUSH
47063: LD_INT 1
47065: PUSH
47066: EMPTY
47067: LIST
47068: LIST
47069: PUSH
47070: LD_INT 3
47072: PUSH
47073: LD_INT 1
47075: PUSH
47076: EMPTY
47077: LIST
47078: LIST
47079: PUSH
47080: LD_INT 2
47082: PUSH
47083: LD_INT 0
47085: PUSH
47086: EMPTY
47087: LIST
47088: LIST
47089: PUSH
47090: LD_INT 2
47092: PUSH
47093: LD_INT 1
47095: NEG
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: PUSH
47101: LD_INT 2
47103: PUSH
47104: LD_INT 2
47106: NEG
47107: PUSH
47108: EMPTY
47109: LIST
47110: LIST
47111: PUSH
47112: LD_INT 4
47114: PUSH
47115: LD_INT 2
47117: PUSH
47118: EMPTY
47119: LIST
47120: LIST
47121: PUSH
47122: LD_INT 4
47124: PUSH
47125: LD_INT 4
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: PUSH
47132: LD_INT 4
47134: PUSH
47135: LD_INT 3
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: PUSH
47142: LD_INT 5
47144: PUSH
47145: LD_INT 4
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: PUSH
47152: LD_INT 5
47154: PUSH
47155: LD_INT 5
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: PUSH
47162: LD_INT 4
47164: PUSH
47165: LD_INT 5
47167: PUSH
47168: EMPTY
47169: LIST
47170: LIST
47171: PUSH
47172: LD_INT 3
47174: PUSH
47175: LD_INT 4
47177: PUSH
47178: EMPTY
47179: LIST
47180: LIST
47181: PUSH
47182: LD_INT 3
47184: PUSH
47185: LD_INT 3
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: PUSH
47192: LD_INT 5
47194: PUSH
47195: LD_INT 3
47197: PUSH
47198: EMPTY
47199: LIST
47200: LIST
47201: PUSH
47202: LD_INT 3
47204: PUSH
47205: LD_INT 5
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: PUSH
47212: LD_INT 0
47214: PUSH
47215: LD_INT 3
47217: PUSH
47218: EMPTY
47219: LIST
47220: LIST
47221: PUSH
47222: LD_INT 0
47224: PUSH
47225: LD_INT 2
47227: PUSH
47228: EMPTY
47229: LIST
47230: LIST
47231: PUSH
47232: LD_INT 1
47234: PUSH
47235: LD_INT 3
47237: PUSH
47238: EMPTY
47239: LIST
47240: LIST
47241: PUSH
47242: LD_INT 1
47244: PUSH
47245: LD_INT 4
47247: PUSH
47248: EMPTY
47249: LIST
47250: LIST
47251: PUSH
47252: LD_INT 0
47254: PUSH
47255: LD_INT 4
47257: PUSH
47258: EMPTY
47259: LIST
47260: LIST
47261: PUSH
47262: LD_INT 1
47264: NEG
47265: PUSH
47266: LD_INT 3
47268: PUSH
47269: EMPTY
47270: LIST
47271: LIST
47272: PUSH
47273: LD_INT 1
47275: NEG
47276: PUSH
47277: LD_INT 2
47279: PUSH
47280: EMPTY
47281: LIST
47282: LIST
47283: PUSH
47284: LD_INT 2
47286: PUSH
47287: LD_INT 4
47289: PUSH
47290: EMPTY
47291: LIST
47292: LIST
47293: PUSH
47294: LD_INT 2
47296: NEG
47297: PUSH
47298: LD_INT 2
47300: PUSH
47301: EMPTY
47302: LIST
47303: LIST
47304: PUSH
47305: LD_INT 4
47307: NEG
47308: PUSH
47309: LD_INT 0
47311: PUSH
47312: EMPTY
47313: LIST
47314: LIST
47315: PUSH
47316: LD_INT 4
47318: NEG
47319: PUSH
47320: LD_INT 1
47322: NEG
47323: PUSH
47324: EMPTY
47325: LIST
47326: LIST
47327: PUSH
47328: LD_INT 3
47330: NEG
47331: PUSH
47332: LD_INT 0
47334: PUSH
47335: EMPTY
47336: LIST
47337: LIST
47338: PUSH
47339: LD_INT 3
47341: NEG
47342: PUSH
47343: LD_INT 1
47345: PUSH
47346: EMPTY
47347: LIST
47348: LIST
47349: PUSH
47350: LD_INT 4
47352: NEG
47353: PUSH
47354: LD_INT 1
47356: PUSH
47357: EMPTY
47358: LIST
47359: LIST
47360: PUSH
47361: LD_INT 5
47363: NEG
47364: PUSH
47365: LD_INT 0
47367: PUSH
47368: EMPTY
47369: LIST
47370: LIST
47371: PUSH
47372: LD_INT 5
47374: NEG
47375: PUSH
47376: LD_INT 1
47378: NEG
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: PUSH
47384: LD_INT 5
47386: NEG
47387: PUSH
47388: LD_INT 2
47390: NEG
47391: PUSH
47392: EMPTY
47393: LIST
47394: LIST
47395: PUSH
47396: LD_INT 3
47398: NEG
47399: PUSH
47400: LD_INT 2
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: PUSH
47407: EMPTY
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: ST_TO_ADDR
// end ; end ;
47454: GO 47457
47456: POP
// case btype of b_depot , b_warehouse :
47457: LD_VAR 0 1
47461: PUSH
47462: LD_INT 0
47464: DOUBLE
47465: EQUAL
47466: IFTRUE 47476
47468: LD_INT 1
47470: DOUBLE
47471: EQUAL
47472: IFTRUE 47476
47474: GO 47677
47476: POP
// case nation of nation_american :
47477: LD_VAR 0 5
47481: PUSH
47482: LD_INT 1
47484: DOUBLE
47485: EQUAL
47486: IFTRUE 47490
47488: GO 47546
47490: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
47491: LD_ADDR_VAR 0 9
47495: PUSH
47496: LD_VAR 0 11
47500: PUSH
47501: LD_VAR 0 12
47505: PUSH
47506: LD_VAR 0 13
47510: PUSH
47511: LD_VAR 0 14
47515: PUSH
47516: LD_VAR 0 15
47520: PUSH
47521: LD_VAR 0 16
47525: PUSH
47526: EMPTY
47527: LIST
47528: LIST
47529: LIST
47530: LIST
47531: LIST
47532: LIST
47533: PUSH
47534: LD_VAR 0 4
47538: PUSH
47539: LD_INT 1
47541: PLUS
47542: ARRAY
47543: ST_TO_ADDR
47544: GO 47675
47546: LD_INT 2
47548: DOUBLE
47549: EQUAL
47550: IFTRUE 47554
47552: GO 47610
47554: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
47555: LD_ADDR_VAR 0 9
47559: PUSH
47560: LD_VAR 0 17
47564: PUSH
47565: LD_VAR 0 18
47569: PUSH
47570: LD_VAR 0 19
47574: PUSH
47575: LD_VAR 0 20
47579: PUSH
47580: LD_VAR 0 21
47584: PUSH
47585: LD_VAR 0 22
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: LIST
47594: LIST
47595: LIST
47596: LIST
47597: PUSH
47598: LD_VAR 0 4
47602: PUSH
47603: LD_INT 1
47605: PLUS
47606: ARRAY
47607: ST_TO_ADDR
47608: GO 47675
47610: LD_INT 3
47612: DOUBLE
47613: EQUAL
47614: IFTRUE 47618
47616: GO 47674
47618: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47619: LD_ADDR_VAR 0 9
47623: PUSH
47624: LD_VAR 0 23
47628: PUSH
47629: LD_VAR 0 24
47633: PUSH
47634: LD_VAR 0 25
47638: PUSH
47639: LD_VAR 0 26
47643: PUSH
47644: LD_VAR 0 27
47648: PUSH
47649: LD_VAR 0 28
47653: PUSH
47654: EMPTY
47655: LIST
47656: LIST
47657: LIST
47658: LIST
47659: LIST
47660: LIST
47661: PUSH
47662: LD_VAR 0 4
47666: PUSH
47667: LD_INT 1
47669: PLUS
47670: ARRAY
47671: ST_TO_ADDR
47672: GO 47675
47674: POP
47675: GO 48230
47677: LD_INT 2
47679: DOUBLE
47680: EQUAL
47681: IFTRUE 47691
47683: LD_INT 3
47685: DOUBLE
47686: EQUAL
47687: IFTRUE 47691
47689: GO 47747
47691: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47692: LD_ADDR_VAR 0 9
47696: PUSH
47697: LD_VAR 0 29
47701: PUSH
47702: LD_VAR 0 30
47706: PUSH
47707: LD_VAR 0 31
47711: PUSH
47712: LD_VAR 0 32
47716: PUSH
47717: LD_VAR 0 33
47721: PUSH
47722: LD_VAR 0 34
47726: PUSH
47727: EMPTY
47728: LIST
47729: LIST
47730: LIST
47731: LIST
47732: LIST
47733: LIST
47734: PUSH
47735: LD_VAR 0 4
47739: PUSH
47740: LD_INT 1
47742: PLUS
47743: ARRAY
47744: ST_TO_ADDR
47745: GO 48230
47747: LD_INT 16
47749: DOUBLE
47750: EQUAL
47751: IFTRUE 47809
47753: LD_INT 17
47755: DOUBLE
47756: EQUAL
47757: IFTRUE 47809
47759: LD_INT 18
47761: DOUBLE
47762: EQUAL
47763: IFTRUE 47809
47765: LD_INT 19
47767: DOUBLE
47768: EQUAL
47769: IFTRUE 47809
47771: LD_INT 22
47773: DOUBLE
47774: EQUAL
47775: IFTRUE 47809
47777: LD_INT 20
47779: DOUBLE
47780: EQUAL
47781: IFTRUE 47809
47783: LD_INT 21
47785: DOUBLE
47786: EQUAL
47787: IFTRUE 47809
47789: LD_INT 23
47791: DOUBLE
47792: EQUAL
47793: IFTRUE 47809
47795: LD_INT 24
47797: DOUBLE
47798: EQUAL
47799: IFTRUE 47809
47801: LD_INT 25
47803: DOUBLE
47804: EQUAL
47805: IFTRUE 47809
47807: GO 47865
47809: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47810: LD_ADDR_VAR 0 9
47814: PUSH
47815: LD_VAR 0 35
47819: PUSH
47820: LD_VAR 0 36
47824: PUSH
47825: LD_VAR 0 37
47829: PUSH
47830: LD_VAR 0 38
47834: PUSH
47835: LD_VAR 0 39
47839: PUSH
47840: LD_VAR 0 40
47844: PUSH
47845: EMPTY
47846: LIST
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: PUSH
47853: LD_VAR 0 4
47857: PUSH
47858: LD_INT 1
47860: PLUS
47861: ARRAY
47862: ST_TO_ADDR
47863: GO 48230
47865: LD_INT 6
47867: DOUBLE
47868: EQUAL
47869: IFTRUE 47921
47871: LD_INT 7
47873: DOUBLE
47874: EQUAL
47875: IFTRUE 47921
47877: LD_INT 8
47879: DOUBLE
47880: EQUAL
47881: IFTRUE 47921
47883: LD_INT 13
47885: DOUBLE
47886: EQUAL
47887: IFTRUE 47921
47889: LD_INT 12
47891: DOUBLE
47892: EQUAL
47893: IFTRUE 47921
47895: LD_INT 15
47897: DOUBLE
47898: EQUAL
47899: IFTRUE 47921
47901: LD_INT 11
47903: DOUBLE
47904: EQUAL
47905: IFTRUE 47921
47907: LD_INT 14
47909: DOUBLE
47910: EQUAL
47911: IFTRUE 47921
47913: LD_INT 10
47915: DOUBLE
47916: EQUAL
47917: IFTRUE 47921
47919: GO 47977
47921: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47922: LD_ADDR_VAR 0 9
47926: PUSH
47927: LD_VAR 0 41
47931: PUSH
47932: LD_VAR 0 42
47936: PUSH
47937: LD_VAR 0 43
47941: PUSH
47942: LD_VAR 0 44
47946: PUSH
47947: LD_VAR 0 45
47951: PUSH
47952: LD_VAR 0 46
47956: PUSH
47957: EMPTY
47958: LIST
47959: LIST
47960: LIST
47961: LIST
47962: LIST
47963: LIST
47964: PUSH
47965: LD_VAR 0 4
47969: PUSH
47970: LD_INT 1
47972: PLUS
47973: ARRAY
47974: ST_TO_ADDR
47975: GO 48230
47977: LD_INT 36
47979: DOUBLE
47980: EQUAL
47981: IFTRUE 47985
47983: GO 48041
47985: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47986: LD_ADDR_VAR 0 9
47990: PUSH
47991: LD_VAR 0 47
47995: PUSH
47996: LD_VAR 0 48
48000: PUSH
48001: LD_VAR 0 49
48005: PUSH
48006: LD_VAR 0 50
48010: PUSH
48011: LD_VAR 0 51
48015: PUSH
48016: LD_VAR 0 52
48020: PUSH
48021: EMPTY
48022: LIST
48023: LIST
48024: LIST
48025: LIST
48026: LIST
48027: LIST
48028: PUSH
48029: LD_VAR 0 4
48033: PUSH
48034: LD_INT 1
48036: PLUS
48037: ARRAY
48038: ST_TO_ADDR
48039: GO 48230
48041: LD_INT 4
48043: DOUBLE
48044: EQUAL
48045: IFTRUE 48067
48047: LD_INT 5
48049: DOUBLE
48050: EQUAL
48051: IFTRUE 48067
48053: LD_INT 34
48055: DOUBLE
48056: EQUAL
48057: IFTRUE 48067
48059: LD_INT 37
48061: DOUBLE
48062: EQUAL
48063: IFTRUE 48067
48065: GO 48123
48067: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
48068: LD_ADDR_VAR 0 9
48072: PUSH
48073: LD_VAR 0 53
48077: PUSH
48078: LD_VAR 0 54
48082: PUSH
48083: LD_VAR 0 55
48087: PUSH
48088: LD_VAR 0 56
48092: PUSH
48093: LD_VAR 0 57
48097: PUSH
48098: LD_VAR 0 58
48102: PUSH
48103: EMPTY
48104: LIST
48105: LIST
48106: LIST
48107: LIST
48108: LIST
48109: LIST
48110: PUSH
48111: LD_VAR 0 4
48115: PUSH
48116: LD_INT 1
48118: PLUS
48119: ARRAY
48120: ST_TO_ADDR
48121: GO 48230
48123: LD_INT 31
48125: DOUBLE
48126: EQUAL
48127: IFTRUE 48173
48129: LD_INT 32
48131: DOUBLE
48132: EQUAL
48133: IFTRUE 48173
48135: LD_INT 33
48137: DOUBLE
48138: EQUAL
48139: IFTRUE 48173
48141: LD_INT 27
48143: DOUBLE
48144: EQUAL
48145: IFTRUE 48173
48147: LD_INT 26
48149: DOUBLE
48150: EQUAL
48151: IFTRUE 48173
48153: LD_INT 28
48155: DOUBLE
48156: EQUAL
48157: IFTRUE 48173
48159: LD_INT 29
48161: DOUBLE
48162: EQUAL
48163: IFTRUE 48173
48165: LD_INT 30
48167: DOUBLE
48168: EQUAL
48169: IFTRUE 48173
48171: GO 48229
48173: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
48174: LD_ADDR_VAR 0 9
48178: PUSH
48179: LD_VAR 0 59
48183: PUSH
48184: LD_VAR 0 60
48188: PUSH
48189: LD_VAR 0 61
48193: PUSH
48194: LD_VAR 0 62
48198: PUSH
48199: LD_VAR 0 63
48203: PUSH
48204: LD_VAR 0 64
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: LIST
48213: LIST
48214: LIST
48215: LIST
48216: PUSH
48217: LD_VAR 0 4
48221: PUSH
48222: LD_INT 1
48224: PLUS
48225: ARRAY
48226: ST_TO_ADDR
48227: GO 48230
48229: POP
// temp_list2 = [ ] ;
48230: LD_ADDR_VAR 0 10
48234: PUSH
48235: EMPTY
48236: ST_TO_ADDR
// for i in temp_list do
48237: LD_ADDR_VAR 0 8
48241: PUSH
48242: LD_VAR 0 9
48246: PUSH
48247: FOR_IN
48248: IFFALSE 48300
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
48250: LD_ADDR_VAR 0 10
48254: PUSH
48255: LD_VAR 0 10
48259: PUSH
48260: LD_VAR 0 8
48264: PUSH
48265: LD_INT 1
48267: ARRAY
48268: PUSH
48269: LD_VAR 0 2
48273: PLUS
48274: PUSH
48275: LD_VAR 0 8
48279: PUSH
48280: LD_INT 2
48282: ARRAY
48283: PUSH
48284: LD_VAR 0 3
48288: PLUS
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: PUSH
48294: EMPTY
48295: LIST
48296: ADD
48297: ST_TO_ADDR
48298: GO 48247
48300: POP
48301: POP
// result = temp_list2 ;
48302: LD_ADDR_VAR 0 7
48306: PUSH
48307: LD_VAR 0 10
48311: ST_TO_ADDR
// end ;
48312: LD_VAR 0 7
48316: RET
// export function EnemyInRange ( unit , dist ) ; begin
48317: LD_INT 0
48319: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
48320: LD_ADDR_VAR 0 3
48324: PUSH
48325: LD_VAR 0 1
48329: PPUSH
48330: CALL_OW 255
48334: PPUSH
48335: LD_VAR 0 1
48339: PPUSH
48340: CALL_OW 250
48344: PPUSH
48345: LD_VAR 0 1
48349: PPUSH
48350: CALL_OW 251
48354: PPUSH
48355: LD_VAR 0 2
48359: PPUSH
48360: CALL 22421 0 4
48364: PUSH
48365: LD_INT 4
48367: ARRAY
48368: ST_TO_ADDR
// end ;
48369: LD_VAR 0 3
48373: RET
// export function PlayerSeeMe ( unit ) ; begin
48374: LD_INT 0
48376: PPUSH
// result := See ( your_side , unit ) ;
48377: LD_ADDR_VAR 0 2
48381: PUSH
48382: LD_OWVAR 2
48386: PPUSH
48387: LD_VAR 0 1
48391: PPUSH
48392: CALL_OW 292
48396: ST_TO_ADDR
// end ;
48397: LD_VAR 0 2
48401: RET
// export function ReverseDir ( unit ) ; begin
48402: LD_INT 0
48404: PPUSH
// if not unit then
48405: LD_VAR 0 1
48409: NOT
48410: IFFALSE 48414
// exit ;
48412: GO 48460
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
48414: LD_ADDR_VAR 0 2
48418: PUSH
48419: LD_INT 3
48421: PUSH
48422: LD_INT 4
48424: PUSH
48425: LD_INT 5
48427: PUSH
48428: LD_INT 0
48430: PUSH
48431: LD_INT 1
48433: PUSH
48434: LD_INT 2
48436: PUSH
48437: EMPTY
48438: LIST
48439: LIST
48440: LIST
48441: LIST
48442: LIST
48443: LIST
48444: PUSH
48445: LD_VAR 0 1
48449: PPUSH
48450: CALL_OW 254
48454: PUSH
48455: LD_INT 1
48457: PLUS
48458: ARRAY
48459: ST_TO_ADDR
// end ;
48460: LD_VAR 0 2
48464: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
48465: LD_INT 0
48467: PPUSH
48468: PPUSH
48469: PPUSH
48470: PPUSH
48471: PPUSH
// if not hexes then
48472: LD_VAR 0 2
48476: NOT
48477: IFFALSE 48481
// exit ;
48479: GO 48629
// dist := 9999 ;
48481: LD_ADDR_VAR 0 5
48485: PUSH
48486: LD_INT 9999
48488: ST_TO_ADDR
// for i = 1 to hexes do
48489: LD_ADDR_VAR 0 4
48493: PUSH
48494: DOUBLE
48495: LD_INT 1
48497: DEC
48498: ST_TO_ADDR
48499: LD_VAR 0 2
48503: PUSH
48504: FOR_TO
48505: IFFALSE 48617
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
48507: LD_VAR 0 1
48511: PPUSH
48512: LD_VAR 0 2
48516: PUSH
48517: LD_VAR 0 4
48521: ARRAY
48522: PUSH
48523: LD_INT 1
48525: ARRAY
48526: PPUSH
48527: LD_VAR 0 2
48531: PUSH
48532: LD_VAR 0 4
48536: ARRAY
48537: PUSH
48538: LD_INT 2
48540: ARRAY
48541: PPUSH
48542: CALL_OW 297
48546: PUSH
48547: LD_VAR 0 5
48551: LESS
48552: IFFALSE 48615
// begin hex := hexes [ i ] ;
48554: LD_ADDR_VAR 0 7
48558: PUSH
48559: LD_VAR 0 2
48563: PUSH
48564: LD_VAR 0 4
48568: ARRAY
48569: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48570: LD_ADDR_VAR 0 5
48574: PUSH
48575: LD_VAR 0 1
48579: PPUSH
48580: LD_VAR 0 2
48584: PUSH
48585: LD_VAR 0 4
48589: ARRAY
48590: PUSH
48591: LD_INT 1
48593: ARRAY
48594: PPUSH
48595: LD_VAR 0 2
48599: PUSH
48600: LD_VAR 0 4
48604: ARRAY
48605: PUSH
48606: LD_INT 2
48608: ARRAY
48609: PPUSH
48610: CALL_OW 297
48614: ST_TO_ADDR
// end ; end ;
48615: GO 48504
48617: POP
48618: POP
// result := hex ;
48619: LD_ADDR_VAR 0 3
48623: PUSH
48624: LD_VAR 0 7
48628: ST_TO_ADDR
// end ;
48629: LD_VAR 0 3
48633: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48634: LD_INT 0
48636: PPUSH
48637: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48638: LD_VAR 0 1
48642: NOT
48643: PUSH
48644: LD_VAR 0 1
48648: PUSH
48649: LD_INT 21
48651: PUSH
48652: LD_INT 2
48654: PUSH
48655: EMPTY
48656: LIST
48657: LIST
48658: PUSH
48659: LD_INT 23
48661: PUSH
48662: LD_INT 2
48664: PUSH
48665: EMPTY
48666: LIST
48667: LIST
48668: PUSH
48669: EMPTY
48670: LIST
48671: LIST
48672: PPUSH
48673: CALL_OW 69
48677: IN
48678: NOT
48679: OR
48680: IFFALSE 48684
// exit ;
48682: GO 48731
// for i = 1 to 3 do
48684: LD_ADDR_VAR 0 3
48688: PUSH
48689: DOUBLE
48690: LD_INT 1
48692: DEC
48693: ST_TO_ADDR
48694: LD_INT 3
48696: PUSH
48697: FOR_TO
48698: IFFALSE 48729
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48700: LD_VAR 0 1
48704: PPUSH
48705: CALL_OW 250
48709: PPUSH
48710: LD_VAR 0 1
48714: PPUSH
48715: CALL_OW 251
48719: PPUSH
48720: LD_INT 1
48722: PPUSH
48723: CALL_OW 453
48727: GO 48697
48729: POP
48730: POP
// end ;
48731: LD_VAR 0 2
48735: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48736: LD_INT 0
48738: PPUSH
48739: PPUSH
48740: PPUSH
48741: PPUSH
48742: PPUSH
48743: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48744: LD_VAR 0 1
48748: NOT
48749: PUSH
48750: LD_VAR 0 2
48754: NOT
48755: OR
48756: PUSH
48757: LD_VAR 0 1
48761: PPUSH
48762: CALL_OW 314
48766: OR
48767: IFFALSE 48771
// exit ;
48769: GO 49212
// x := GetX ( enemy_unit ) ;
48771: LD_ADDR_VAR 0 7
48775: PUSH
48776: LD_VAR 0 2
48780: PPUSH
48781: CALL_OW 250
48785: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48786: LD_ADDR_VAR 0 8
48790: PUSH
48791: LD_VAR 0 2
48795: PPUSH
48796: CALL_OW 251
48800: ST_TO_ADDR
// if not x or not y then
48801: LD_VAR 0 7
48805: NOT
48806: PUSH
48807: LD_VAR 0 8
48811: NOT
48812: OR
48813: IFFALSE 48817
// exit ;
48815: GO 49212
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48817: LD_ADDR_VAR 0 6
48821: PUSH
48822: LD_VAR 0 7
48826: PPUSH
48827: LD_INT 0
48829: PPUSH
48830: LD_INT 4
48832: PPUSH
48833: CALL_OW 272
48837: PUSH
48838: LD_VAR 0 8
48842: PPUSH
48843: LD_INT 0
48845: PPUSH
48846: LD_INT 4
48848: PPUSH
48849: CALL_OW 273
48853: PUSH
48854: EMPTY
48855: LIST
48856: LIST
48857: PUSH
48858: LD_VAR 0 7
48862: PPUSH
48863: LD_INT 1
48865: PPUSH
48866: LD_INT 4
48868: PPUSH
48869: CALL_OW 272
48873: PUSH
48874: LD_VAR 0 8
48878: PPUSH
48879: LD_INT 1
48881: PPUSH
48882: LD_INT 4
48884: PPUSH
48885: CALL_OW 273
48889: PUSH
48890: EMPTY
48891: LIST
48892: LIST
48893: PUSH
48894: LD_VAR 0 7
48898: PPUSH
48899: LD_INT 2
48901: PPUSH
48902: LD_INT 4
48904: PPUSH
48905: CALL_OW 272
48909: PUSH
48910: LD_VAR 0 8
48914: PPUSH
48915: LD_INT 2
48917: PPUSH
48918: LD_INT 4
48920: PPUSH
48921: CALL_OW 273
48925: PUSH
48926: EMPTY
48927: LIST
48928: LIST
48929: PUSH
48930: LD_VAR 0 7
48934: PPUSH
48935: LD_INT 3
48937: PPUSH
48938: LD_INT 4
48940: PPUSH
48941: CALL_OW 272
48945: PUSH
48946: LD_VAR 0 8
48950: PPUSH
48951: LD_INT 3
48953: PPUSH
48954: LD_INT 4
48956: PPUSH
48957: CALL_OW 273
48961: PUSH
48962: EMPTY
48963: LIST
48964: LIST
48965: PUSH
48966: LD_VAR 0 7
48970: PPUSH
48971: LD_INT 4
48973: PPUSH
48974: LD_INT 4
48976: PPUSH
48977: CALL_OW 272
48981: PUSH
48982: LD_VAR 0 8
48986: PPUSH
48987: LD_INT 4
48989: PPUSH
48990: LD_INT 4
48992: PPUSH
48993: CALL_OW 273
48997: PUSH
48998: EMPTY
48999: LIST
49000: LIST
49001: PUSH
49002: LD_VAR 0 7
49006: PPUSH
49007: LD_INT 5
49009: PPUSH
49010: LD_INT 4
49012: PPUSH
49013: CALL_OW 272
49017: PUSH
49018: LD_VAR 0 8
49022: PPUSH
49023: LD_INT 5
49025: PPUSH
49026: LD_INT 4
49028: PPUSH
49029: CALL_OW 273
49033: PUSH
49034: EMPTY
49035: LIST
49036: LIST
49037: PUSH
49038: EMPTY
49039: LIST
49040: LIST
49041: LIST
49042: LIST
49043: LIST
49044: LIST
49045: ST_TO_ADDR
// for i = tmp downto 1 do
49046: LD_ADDR_VAR 0 4
49050: PUSH
49051: DOUBLE
49052: LD_VAR 0 6
49056: INC
49057: ST_TO_ADDR
49058: LD_INT 1
49060: PUSH
49061: FOR_DOWNTO
49062: IFFALSE 49163
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
49064: LD_VAR 0 6
49068: PUSH
49069: LD_VAR 0 4
49073: ARRAY
49074: PUSH
49075: LD_INT 1
49077: ARRAY
49078: PPUSH
49079: LD_VAR 0 6
49083: PUSH
49084: LD_VAR 0 4
49088: ARRAY
49089: PUSH
49090: LD_INT 2
49092: ARRAY
49093: PPUSH
49094: CALL_OW 488
49098: NOT
49099: PUSH
49100: LD_VAR 0 6
49104: PUSH
49105: LD_VAR 0 4
49109: ARRAY
49110: PUSH
49111: LD_INT 1
49113: ARRAY
49114: PPUSH
49115: LD_VAR 0 6
49119: PUSH
49120: LD_VAR 0 4
49124: ARRAY
49125: PUSH
49126: LD_INT 2
49128: ARRAY
49129: PPUSH
49130: CALL_OW 428
49134: PUSH
49135: LD_INT 0
49137: NONEQUAL
49138: OR
49139: IFFALSE 49161
// tmp := Delete ( tmp , i ) ;
49141: LD_ADDR_VAR 0 6
49145: PUSH
49146: LD_VAR 0 6
49150: PPUSH
49151: LD_VAR 0 4
49155: PPUSH
49156: CALL_OW 3
49160: ST_TO_ADDR
49161: GO 49061
49163: POP
49164: POP
// j := GetClosestHex ( unit , tmp ) ;
49165: LD_ADDR_VAR 0 5
49169: PUSH
49170: LD_VAR 0 1
49174: PPUSH
49175: LD_VAR 0 6
49179: PPUSH
49180: CALL 48465 0 2
49184: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
49185: LD_VAR 0 1
49189: PPUSH
49190: LD_VAR 0 5
49194: PUSH
49195: LD_INT 1
49197: ARRAY
49198: PPUSH
49199: LD_VAR 0 5
49203: PUSH
49204: LD_INT 2
49206: ARRAY
49207: PPUSH
49208: CALL_OW 111
// end ;
49212: LD_VAR 0 3
49216: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49217: LD_INT 0
49219: PPUSH
49220: PPUSH
49221: PPUSH
// uc_side = 0 ;
49222: LD_ADDR_OWVAR 20
49226: PUSH
49227: LD_INT 0
49229: ST_TO_ADDR
// uc_nation = 0 ;
49230: LD_ADDR_OWVAR 21
49234: PUSH
49235: LD_INT 0
49237: ST_TO_ADDR
// InitHc ;
49238: CALL_OW 19
// InitVc ;
49242: CALL_OW 20
// if mastodonts then
49246: LD_VAR 0 6
49250: IFFALSE 49317
// for i = 1 to mastodonts do
49252: LD_ADDR_VAR 0 11
49256: PUSH
49257: DOUBLE
49258: LD_INT 1
49260: DEC
49261: ST_TO_ADDR
49262: LD_VAR 0 6
49266: PUSH
49267: FOR_TO
49268: IFFALSE 49315
// begin vc_chassis := 31 ;
49270: LD_ADDR_OWVAR 37
49274: PUSH
49275: LD_INT 31
49277: ST_TO_ADDR
// vc_control := control_rider ;
49278: LD_ADDR_OWVAR 38
49282: PUSH
49283: LD_INT 4
49285: ST_TO_ADDR
// animal := CreateVehicle ;
49286: LD_ADDR_VAR 0 12
49290: PUSH
49291: CALL_OW 45
49295: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49296: LD_VAR 0 12
49300: PPUSH
49301: LD_VAR 0 8
49305: PPUSH
49306: LD_INT 0
49308: PPUSH
49309: CALL 56062 0 3
// end ;
49313: GO 49267
49315: POP
49316: POP
// if horses then
49317: LD_VAR 0 5
49321: IFFALSE 49388
// for i = 1 to horses do
49323: LD_ADDR_VAR 0 11
49327: PUSH
49328: DOUBLE
49329: LD_INT 1
49331: DEC
49332: ST_TO_ADDR
49333: LD_VAR 0 5
49337: PUSH
49338: FOR_TO
49339: IFFALSE 49386
// begin hc_class := 21 ;
49341: LD_ADDR_OWVAR 28
49345: PUSH
49346: LD_INT 21
49348: ST_TO_ADDR
// hc_gallery :=  ;
49349: LD_ADDR_OWVAR 33
49353: PUSH
49354: LD_STRING 
49356: ST_TO_ADDR
// animal := CreateHuman ;
49357: LD_ADDR_VAR 0 12
49361: PUSH
49362: CALL_OW 44
49366: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49367: LD_VAR 0 12
49371: PPUSH
49372: LD_VAR 0 8
49376: PPUSH
49377: LD_INT 0
49379: PPUSH
49380: CALL 56062 0 3
// end ;
49384: GO 49338
49386: POP
49387: POP
// if birds then
49388: LD_VAR 0 1
49392: IFFALSE 49459
// for i = 1 to birds do
49394: LD_ADDR_VAR 0 11
49398: PUSH
49399: DOUBLE
49400: LD_INT 1
49402: DEC
49403: ST_TO_ADDR
49404: LD_VAR 0 1
49408: PUSH
49409: FOR_TO
49410: IFFALSE 49457
// begin hc_class = 18 ;
49412: LD_ADDR_OWVAR 28
49416: PUSH
49417: LD_INT 18
49419: ST_TO_ADDR
// hc_gallery =  ;
49420: LD_ADDR_OWVAR 33
49424: PUSH
49425: LD_STRING 
49427: ST_TO_ADDR
// animal := CreateHuman ;
49428: LD_ADDR_VAR 0 12
49432: PUSH
49433: CALL_OW 44
49437: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49438: LD_VAR 0 12
49442: PPUSH
49443: LD_VAR 0 8
49447: PPUSH
49448: LD_INT 0
49450: PPUSH
49451: CALL 56062 0 3
// end ;
49455: GO 49409
49457: POP
49458: POP
// if tigers then
49459: LD_VAR 0 2
49463: IFFALSE 49547
// for i = 1 to tigers do
49465: LD_ADDR_VAR 0 11
49469: PUSH
49470: DOUBLE
49471: LD_INT 1
49473: DEC
49474: ST_TO_ADDR
49475: LD_VAR 0 2
49479: PUSH
49480: FOR_TO
49481: IFFALSE 49545
// begin hc_class = class_tiger ;
49483: LD_ADDR_OWVAR 28
49487: PUSH
49488: LD_INT 14
49490: ST_TO_ADDR
// hc_gallery =  ;
49491: LD_ADDR_OWVAR 33
49495: PUSH
49496: LD_STRING 
49498: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49499: LD_ADDR_OWVAR 35
49503: PUSH
49504: LD_INT 7
49506: NEG
49507: PPUSH
49508: LD_INT 7
49510: PPUSH
49511: CALL_OW 12
49515: ST_TO_ADDR
// animal := CreateHuman ;
49516: LD_ADDR_VAR 0 12
49520: PUSH
49521: CALL_OW 44
49525: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49526: LD_VAR 0 12
49530: PPUSH
49531: LD_VAR 0 8
49535: PPUSH
49536: LD_INT 0
49538: PPUSH
49539: CALL 56062 0 3
// end ;
49543: GO 49480
49545: POP
49546: POP
// if apemans then
49547: LD_VAR 0 3
49551: IFFALSE 49674
// for i = 1 to apemans do
49553: LD_ADDR_VAR 0 11
49557: PUSH
49558: DOUBLE
49559: LD_INT 1
49561: DEC
49562: ST_TO_ADDR
49563: LD_VAR 0 3
49567: PUSH
49568: FOR_TO
49569: IFFALSE 49672
// begin hc_class = class_apeman ;
49571: LD_ADDR_OWVAR 28
49575: PUSH
49576: LD_INT 12
49578: ST_TO_ADDR
// hc_gallery =  ;
49579: LD_ADDR_OWVAR 33
49583: PUSH
49584: LD_STRING 
49586: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
49587: LD_ADDR_OWVAR 35
49591: PUSH
49592: LD_INT 5
49594: NEG
49595: PPUSH
49596: LD_INT 5
49598: PPUSH
49599: CALL_OW 12
49603: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49604: LD_ADDR_OWVAR 31
49608: PUSH
49609: LD_INT 1
49611: PPUSH
49612: LD_INT 3
49614: PPUSH
49615: CALL_OW 12
49619: PUSH
49620: LD_INT 1
49622: PPUSH
49623: LD_INT 3
49625: PPUSH
49626: CALL_OW 12
49630: PUSH
49631: LD_INT 0
49633: PUSH
49634: LD_INT 0
49636: PUSH
49637: EMPTY
49638: LIST
49639: LIST
49640: LIST
49641: LIST
49642: ST_TO_ADDR
// animal := CreateHuman ;
49643: LD_ADDR_VAR 0 12
49647: PUSH
49648: CALL_OW 44
49652: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49653: LD_VAR 0 12
49657: PPUSH
49658: LD_VAR 0 8
49662: PPUSH
49663: LD_INT 0
49665: PPUSH
49666: CALL 56062 0 3
// end ;
49670: GO 49568
49672: POP
49673: POP
// if enchidnas then
49674: LD_VAR 0 4
49678: IFFALSE 49745
// for i = 1 to enchidnas do
49680: LD_ADDR_VAR 0 11
49684: PUSH
49685: DOUBLE
49686: LD_INT 1
49688: DEC
49689: ST_TO_ADDR
49690: LD_VAR 0 4
49694: PUSH
49695: FOR_TO
49696: IFFALSE 49743
// begin hc_class = 13 ;
49698: LD_ADDR_OWVAR 28
49702: PUSH
49703: LD_INT 13
49705: ST_TO_ADDR
// hc_gallery =  ;
49706: LD_ADDR_OWVAR 33
49710: PUSH
49711: LD_STRING 
49713: ST_TO_ADDR
// animal := CreateHuman ;
49714: LD_ADDR_VAR 0 12
49718: PUSH
49719: CALL_OW 44
49723: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49724: LD_VAR 0 12
49728: PPUSH
49729: LD_VAR 0 8
49733: PPUSH
49734: LD_INT 0
49736: PPUSH
49737: CALL 56062 0 3
// end ;
49741: GO 49695
49743: POP
49744: POP
// if fishes then
49745: LD_VAR 0 7
49749: IFFALSE 49816
// for i = 1 to fishes do
49751: LD_ADDR_VAR 0 11
49755: PUSH
49756: DOUBLE
49757: LD_INT 1
49759: DEC
49760: ST_TO_ADDR
49761: LD_VAR 0 7
49765: PUSH
49766: FOR_TO
49767: IFFALSE 49814
// begin hc_class = 20 ;
49769: LD_ADDR_OWVAR 28
49773: PUSH
49774: LD_INT 20
49776: ST_TO_ADDR
// hc_gallery =  ;
49777: LD_ADDR_OWVAR 33
49781: PUSH
49782: LD_STRING 
49784: ST_TO_ADDR
// animal := CreateHuman ;
49785: LD_ADDR_VAR 0 12
49789: PUSH
49790: CALL_OW 44
49794: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49795: LD_VAR 0 12
49799: PPUSH
49800: LD_VAR 0 9
49804: PPUSH
49805: LD_INT 0
49807: PPUSH
49808: CALL 56062 0 3
// end ;
49812: GO 49766
49814: POP
49815: POP
// end ;
49816: LD_VAR 0 10
49820: RET
// export function WantHeal ( sci , unit ) ; begin
49821: LD_INT 0
49823: PPUSH
// if GetTaskList ( sci ) > 0 then
49824: LD_VAR 0 1
49828: PPUSH
49829: CALL_OW 437
49833: PUSH
49834: LD_INT 0
49836: GREATER
49837: IFFALSE 49907
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49839: LD_VAR 0 1
49843: PPUSH
49844: CALL_OW 437
49848: PUSH
49849: LD_INT 1
49851: ARRAY
49852: PUSH
49853: LD_INT 1
49855: ARRAY
49856: PUSH
49857: LD_STRING l
49859: EQUAL
49860: PUSH
49861: LD_VAR 0 1
49865: PPUSH
49866: CALL_OW 437
49870: PUSH
49871: LD_INT 1
49873: ARRAY
49874: PUSH
49875: LD_INT 4
49877: ARRAY
49878: PUSH
49879: LD_VAR 0 2
49883: EQUAL
49884: AND
49885: IFFALSE 49897
// result := true else
49887: LD_ADDR_VAR 0 3
49891: PUSH
49892: LD_INT 1
49894: ST_TO_ADDR
49895: GO 49905
// result := false ;
49897: LD_ADDR_VAR 0 3
49901: PUSH
49902: LD_INT 0
49904: ST_TO_ADDR
// end else
49905: GO 49915
// result := false ;
49907: LD_ADDR_VAR 0 3
49911: PUSH
49912: LD_INT 0
49914: ST_TO_ADDR
// end ;
49915: LD_VAR 0 3
49919: RET
// export function HealTarget ( sci ) ; begin
49920: LD_INT 0
49922: PPUSH
// if not sci then
49923: LD_VAR 0 1
49927: NOT
49928: IFFALSE 49932
// exit ;
49930: GO 49997
// result := 0 ;
49932: LD_ADDR_VAR 0 2
49936: PUSH
49937: LD_INT 0
49939: ST_TO_ADDR
// if GetTaskList ( sci ) then
49940: LD_VAR 0 1
49944: PPUSH
49945: CALL_OW 437
49949: IFFALSE 49997
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49951: LD_VAR 0 1
49955: PPUSH
49956: CALL_OW 437
49960: PUSH
49961: LD_INT 1
49963: ARRAY
49964: PUSH
49965: LD_INT 1
49967: ARRAY
49968: PUSH
49969: LD_STRING l
49971: EQUAL
49972: IFFALSE 49997
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49974: LD_ADDR_VAR 0 2
49978: PUSH
49979: LD_VAR 0 1
49983: PPUSH
49984: CALL_OW 437
49988: PUSH
49989: LD_INT 1
49991: ARRAY
49992: PUSH
49993: LD_INT 4
49995: ARRAY
49996: ST_TO_ADDR
// end ;
49997: LD_VAR 0 2
50001: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
50002: LD_INT 0
50004: PPUSH
50005: PPUSH
50006: PPUSH
50007: PPUSH
50008: PPUSH
50009: PPUSH
50010: PPUSH
50011: PPUSH
50012: PPUSH
50013: PPUSH
50014: PPUSH
50015: PPUSH
50016: PPUSH
50017: PPUSH
50018: PPUSH
50019: PPUSH
50020: PPUSH
50021: PPUSH
50022: PPUSH
50023: PPUSH
50024: PPUSH
50025: PPUSH
50026: PPUSH
50027: PPUSH
50028: PPUSH
50029: PPUSH
50030: PPUSH
50031: PPUSH
50032: PPUSH
50033: PPUSH
50034: PPUSH
50035: PPUSH
50036: PPUSH
50037: PPUSH
// if not list then
50038: LD_VAR 0 1
50042: NOT
50043: IFFALSE 50047
// exit ;
50045: GO 54673
// base := list [ 1 ] ;
50047: LD_ADDR_VAR 0 3
50051: PUSH
50052: LD_VAR 0 1
50056: PUSH
50057: LD_INT 1
50059: ARRAY
50060: ST_TO_ADDR
// group := list [ 2 ] ;
50061: LD_ADDR_VAR 0 4
50065: PUSH
50066: LD_VAR 0 1
50070: PUSH
50071: LD_INT 2
50073: ARRAY
50074: ST_TO_ADDR
// path := list [ 3 ] ;
50075: LD_ADDR_VAR 0 5
50079: PUSH
50080: LD_VAR 0 1
50084: PUSH
50085: LD_INT 3
50087: ARRAY
50088: ST_TO_ADDR
// flags := list [ 4 ] ;
50089: LD_ADDR_VAR 0 6
50093: PUSH
50094: LD_VAR 0 1
50098: PUSH
50099: LD_INT 4
50101: ARRAY
50102: ST_TO_ADDR
// mined := [ ] ;
50103: LD_ADDR_VAR 0 27
50107: PUSH
50108: EMPTY
50109: ST_TO_ADDR
// bombed := [ ] ;
50110: LD_ADDR_VAR 0 28
50114: PUSH
50115: EMPTY
50116: ST_TO_ADDR
// healers := [ ] ;
50117: LD_ADDR_VAR 0 31
50121: PUSH
50122: EMPTY
50123: ST_TO_ADDR
// to_heal := [ ] ;
50124: LD_ADDR_VAR 0 30
50128: PUSH
50129: EMPTY
50130: ST_TO_ADDR
// repairs := [ ] ;
50131: LD_ADDR_VAR 0 33
50135: PUSH
50136: EMPTY
50137: ST_TO_ADDR
// to_repair := [ ] ;
50138: LD_ADDR_VAR 0 32
50142: PUSH
50143: EMPTY
50144: ST_TO_ADDR
// if not group or not path then
50145: LD_VAR 0 4
50149: NOT
50150: PUSH
50151: LD_VAR 0 5
50155: NOT
50156: OR
50157: IFFALSE 50161
// exit ;
50159: GO 54673
// side := GetSide ( group [ 1 ] ) ;
50161: LD_ADDR_VAR 0 35
50165: PUSH
50166: LD_VAR 0 4
50170: PUSH
50171: LD_INT 1
50173: ARRAY
50174: PPUSH
50175: CALL_OW 255
50179: ST_TO_ADDR
// if flags then
50180: LD_VAR 0 6
50184: IFFALSE 50328
// begin f_ignore_area := flags [ 1 ] ;
50186: LD_ADDR_VAR 0 17
50190: PUSH
50191: LD_VAR 0 6
50195: PUSH
50196: LD_INT 1
50198: ARRAY
50199: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
50200: LD_ADDR_VAR 0 18
50204: PUSH
50205: LD_VAR 0 6
50209: PUSH
50210: LD_INT 2
50212: ARRAY
50213: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
50214: LD_ADDR_VAR 0 19
50218: PUSH
50219: LD_VAR 0 6
50223: PUSH
50224: LD_INT 3
50226: ARRAY
50227: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
50228: LD_ADDR_VAR 0 20
50232: PUSH
50233: LD_VAR 0 6
50237: PUSH
50238: LD_INT 4
50240: ARRAY
50241: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
50242: LD_ADDR_VAR 0 21
50246: PUSH
50247: LD_VAR 0 6
50251: PUSH
50252: LD_INT 5
50254: ARRAY
50255: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
50256: LD_ADDR_VAR 0 22
50260: PUSH
50261: LD_VAR 0 6
50265: PUSH
50266: LD_INT 6
50268: ARRAY
50269: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
50270: LD_ADDR_VAR 0 23
50274: PUSH
50275: LD_VAR 0 6
50279: PUSH
50280: LD_INT 7
50282: ARRAY
50283: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
50284: LD_ADDR_VAR 0 24
50288: PUSH
50289: LD_VAR 0 6
50293: PUSH
50294: LD_INT 8
50296: ARRAY
50297: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
50298: LD_ADDR_VAR 0 25
50302: PUSH
50303: LD_VAR 0 6
50307: PUSH
50308: LD_INT 9
50310: ARRAY
50311: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
50312: LD_ADDR_VAR 0 26
50316: PUSH
50317: LD_VAR 0 6
50321: PUSH
50322: LD_INT 10
50324: ARRAY
50325: ST_TO_ADDR
// end else
50326: GO 50408
// begin f_ignore_area := false ;
50328: LD_ADDR_VAR 0 17
50332: PUSH
50333: LD_INT 0
50335: ST_TO_ADDR
// f_capture := false ;
50336: LD_ADDR_VAR 0 18
50340: PUSH
50341: LD_INT 0
50343: ST_TO_ADDR
// f_ignore_civ := false ;
50344: LD_ADDR_VAR 0 19
50348: PUSH
50349: LD_INT 0
50351: ST_TO_ADDR
// f_murder := false ;
50352: LD_ADDR_VAR 0 20
50356: PUSH
50357: LD_INT 0
50359: ST_TO_ADDR
// f_mines := false ;
50360: LD_ADDR_VAR 0 21
50364: PUSH
50365: LD_INT 0
50367: ST_TO_ADDR
// f_repair := false ;
50368: LD_ADDR_VAR 0 22
50372: PUSH
50373: LD_INT 0
50375: ST_TO_ADDR
// f_heal := false ;
50376: LD_ADDR_VAR 0 23
50380: PUSH
50381: LD_INT 0
50383: ST_TO_ADDR
// f_spacetime := false ;
50384: LD_ADDR_VAR 0 24
50388: PUSH
50389: LD_INT 0
50391: ST_TO_ADDR
// f_attack_depot := false ;
50392: LD_ADDR_VAR 0 25
50396: PUSH
50397: LD_INT 0
50399: ST_TO_ADDR
// f_crawl := false ;
50400: LD_ADDR_VAR 0 26
50404: PUSH
50405: LD_INT 0
50407: ST_TO_ADDR
// end ; if f_heal then
50408: LD_VAR 0 23
50412: IFFALSE 50439
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
50414: LD_ADDR_VAR 0 31
50418: PUSH
50419: LD_VAR 0 4
50423: PPUSH
50424: LD_INT 25
50426: PUSH
50427: LD_INT 4
50429: PUSH
50430: EMPTY
50431: LIST
50432: LIST
50433: PPUSH
50434: CALL_OW 72
50438: ST_TO_ADDR
// if f_repair then
50439: LD_VAR 0 22
50443: IFFALSE 50470
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
50445: LD_ADDR_VAR 0 33
50449: PUSH
50450: LD_VAR 0 4
50454: PPUSH
50455: LD_INT 25
50457: PUSH
50458: LD_INT 3
50460: PUSH
50461: EMPTY
50462: LIST
50463: LIST
50464: PPUSH
50465: CALL_OW 72
50469: ST_TO_ADDR
// units_path := [ ] ;
50470: LD_ADDR_VAR 0 16
50474: PUSH
50475: EMPTY
50476: ST_TO_ADDR
// for i = 1 to group do
50477: LD_ADDR_VAR 0 7
50481: PUSH
50482: DOUBLE
50483: LD_INT 1
50485: DEC
50486: ST_TO_ADDR
50487: LD_VAR 0 4
50491: PUSH
50492: FOR_TO
50493: IFFALSE 50522
// units_path := Replace ( units_path , i , path ) ;
50495: LD_ADDR_VAR 0 16
50499: PUSH
50500: LD_VAR 0 16
50504: PPUSH
50505: LD_VAR 0 7
50509: PPUSH
50510: LD_VAR 0 5
50514: PPUSH
50515: CALL_OW 1
50519: ST_TO_ADDR
50520: GO 50492
50522: POP
50523: POP
// repeat for i = group downto 1 do
50524: LD_ADDR_VAR 0 7
50528: PUSH
50529: DOUBLE
50530: LD_VAR 0 4
50534: INC
50535: ST_TO_ADDR
50536: LD_INT 1
50538: PUSH
50539: FOR_DOWNTO
50540: IFFALSE 54636
// begin wait ( 5 ) ;
50542: LD_INT 5
50544: PPUSH
50545: CALL_OW 67
// tmp := [ ] ;
50549: LD_ADDR_VAR 0 14
50553: PUSH
50554: EMPTY
50555: ST_TO_ADDR
// attacking := false ;
50556: LD_ADDR_VAR 0 29
50560: PUSH
50561: LD_INT 0
50563: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
50564: LD_VAR 0 4
50568: PUSH
50569: LD_VAR 0 7
50573: ARRAY
50574: PPUSH
50575: CALL_OW 301
50579: PUSH
50580: LD_VAR 0 4
50584: PUSH
50585: LD_VAR 0 7
50589: ARRAY
50590: NOT
50591: OR
50592: IFFALSE 50701
// begin if GetType ( group [ i ] ) = unit_human then
50594: LD_VAR 0 4
50598: PUSH
50599: LD_VAR 0 7
50603: ARRAY
50604: PPUSH
50605: CALL_OW 247
50609: PUSH
50610: LD_INT 1
50612: EQUAL
50613: IFFALSE 50659
// begin to_heal := to_heal diff group [ i ] ;
50615: LD_ADDR_VAR 0 30
50619: PUSH
50620: LD_VAR 0 30
50624: PUSH
50625: LD_VAR 0 4
50629: PUSH
50630: LD_VAR 0 7
50634: ARRAY
50635: DIFF
50636: ST_TO_ADDR
// healers := healers diff group [ i ] ;
50637: LD_ADDR_VAR 0 31
50641: PUSH
50642: LD_VAR 0 31
50646: PUSH
50647: LD_VAR 0 4
50651: PUSH
50652: LD_VAR 0 7
50656: ARRAY
50657: DIFF
50658: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
50659: LD_ADDR_VAR 0 4
50663: PUSH
50664: LD_VAR 0 4
50668: PPUSH
50669: LD_VAR 0 7
50673: PPUSH
50674: CALL_OW 3
50678: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
50679: LD_ADDR_VAR 0 16
50683: PUSH
50684: LD_VAR 0 16
50688: PPUSH
50689: LD_VAR 0 7
50693: PPUSH
50694: CALL_OW 3
50698: ST_TO_ADDR
// continue ;
50699: GO 50539
// end ; if f_repair then
50701: LD_VAR 0 22
50705: IFFALSE 51194
// begin if GetType ( group [ i ] ) = unit_vehicle then
50707: LD_VAR 0 4
50711: PUSH
50712: LD_VAR 0 7
50716: ARRAY
50717: PPUSH
50718: CALL_OW 247
50722: PUSH
50723: LD_INT 2
50725: EQUAL
50726: IFFALSE 50916
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50728: LD_VAR 0 4
50732: PUSH
50733: LD_VAR 0 7
50737: ARRAY
50738: PPUSH
50739: CALL_OW 256
50743: PUSH
50744: LD_INT 700
50746: LESS
50747: PUSH
50748: LD_VAR 0 4
50752: PUSH
50753: LD_VAR 0 7
50757: ARRAY
50758: PUSH
50759: LD_VAR 0 32
50763: IN
50764: NOT
50765: AND
50766: IFFALSE 50790
// to_repair := to_repair union group [ i ] ;
50768: LD_ADDR_VAR 0 32
50772: PUSH
50773: LD_VAR 0 32
50777: PUSH
50778: LD_VAR 0 4
50782: PUSH
50783: LD_VAR 0 7
50787: ARRAY
50788: UNION
50789: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50790: LD_VAR 0 4
50794: PUSH
50795: LD_VAR 0 7
50799: ARRAY
50800: PPUSH
50801: CALL_OW 256
50805: PUSH
50806: LD_INT 1000
50808: EQUAL
50809: PUSH
50810: LD_VAR 0 4
50814: PUSH
50815: LD_VAR 0 7
50819: ARRAY
50820: PUSH
50821: LD_VAR 0 32
50825: IN
50826: AND
50827: IFFALSE 50851
// to_repair := to_repair diff group [ i ] ;
50829: LD_ADDR_VAR 0 32
50833: PUSH
50834: LD_VAR 0 32
50838: PUSH
50839: LD_VAR 0 4
50843: PUSH
50844: LD_VAR 0 7
50848: ARRAY
50849: DIFF
50850: ST_TO_ADDR
// if group [ i ] in to_repair then
50851: LD_VAR 0 4
50855: PUSH
50856: LD_VAR 0 7
50860: ARRAY
50861: PUSH
50862: LD_VAR 0 32
50866: IN
50867: IFFALSE 50914
// begin if not IsInArea ( group [ i ] , f_repair ) then
50869: LD_VAR 0 4
50873: PUSH
50874: LD_VAR 0 7
50878: ARRAY
50879: PPUSH
50880: LD_VAR 0 22
50884: PPUSH
50885: CALL_OW 308
50889: NOT
50890: IFFALSE 50912
// ComMoveToArea ( group [ i ] , f_repair ) ;
50892: LD_VAR 0 4
50896: PUSH
50897: LD_VAR 0 7
50901: ARRAY
50902: PPUSH
50903: LD_VAR 0 22
50907: PPUSH
50908: CALL_OW 113
// continue ;
50912: GO 50539
// end ; end else
50914: GO 51194
// if group [ i ] in repairs then
50916: LD_VAR 0 4
50920: PUSH
50921: LD_VAR 0 7
50925: ARRAY
50926: PUSH
50927: LD_VAR 0 33
50931: IN
50932: IFFALSE 51194
// begin if IsInUnit ( group [ i ] ) then
50934: LD_VAR 0 4
50938: PUSH
50939: LD_VAR 0 7
50943: ARRAY
50944: PPUSH
50945: CALL_OW 310
50949: IFFALSE 51017
// begin z := IsInUnit ( group [ i ] ) ;
50951: LD_ADDR_VAR 0 13
50955: PUSH
50956: LD_VAR 0 4
50960: PUSH
50961: LD_VAR 0 7
50965: ARRAY
50966: PPUSH
50967: CALL_OW 310
50971: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50972: LD_VAR 0 13
50976: PUSH
50977: LD_VAR 0 32
50981: IN
50982: PUSH
50983: LD_VAR 0 13
50987: PPUSH
50988: LD_VAR 0 22
50992: PPUSH
50993: CALL_OW 308
50997: AND
50998: IFFALSE 51015
// ComExitVehicle ( group [ i ] ) ;
51000: LD_VAR 0 4
51004: PUSH
51005: LD_VAR 0 7
51009: ARRAY
51010: PPUSH
51011: CALL_OW 121
// end else
51015: GO 51194
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
51017: LD_ADDR_VAR 0 13
51021: PUSH
51022: LD_VAR 0 4
51026: PPUSH
51027: LD_INT 95
51029: PUSH
51030: LD_VAR 0 22
51034: PUSH
51035: EMPTY
51036: LIST
51037: LIST
51038: PUSH
51039: LD_INT 58
51041: PUSH
51042: EMPTY
51043: LIST
51044: PUSH
51045: EMPTY
51046: LIST
51047: LIST
51048: PPUSH
51049: CALL_OW 72
51053: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
51054: LD_VAR 0 4
51058: PUSH
51059: LD_VAR 0 7
51063: ARRAY
51064: PPUSH
51065: CALL_OW 314
51069: NOT
51070: IFFALSE 51192
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
51072: LD_ADDR_VAR 0 10
51076: PUSH
51077: LD_VAR 0 13
51081: PPUSH
51082: LD_VAR 0 4
51086: PUSH
51087: LD_VAR 0 7
51091: ARRAY
51092: PPUSH
51093: CALL_OW 74
51097: ST_TO_ADDR
// if not x then
51098: LD_VAR 0 10
51102: NOT
51103: IFFALSE 51107
// continue ;
51105: GO 50539
// if GetLives ( x ) < 1000 then
51107: LD_VAR 0 10
51111: PPUSH
51112: CALL_OW 256
51116: PUSH
51117: LD_INT 1000
51119: LESS
51120: IFFALSE 51144
// ComRepairVehicle ( group [ i ] , x ) else
51122: LD_VAR 0 4
51126: PUSH
51127: LD_VAR 0 7
51131: ARRAY
51132: PPUSH
51133: LD_VAR 0 10
51137: PPUSH
51138: CALL_OW 129
51142: GO 51192
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
51144: LD_VAR 0 23
51148: PUSH
51149: LD_VAR 0 4
51153: PUSH
51154: LD_VAR 0 7
51158: ARRAY
51159: PPUSH
51160: CALL_OW 256
51164: PUSH
51165: LD_INT 1000
51167: LESS
51168: AND
51169: NOT
51170: IFFALSE 51192
// ComEnterUnit ( group [ i ] , x ) ;
51172: LD_VAR 0 4
51176: PUSH
51177: LD_VAR 0 7
51181: ARRAY
51182: PPUSH
51183: LD_VAR 0 10
51187: PPUSH
51188: CALL_OW 120
// end ; continue ;
51192: GO 50539
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
51194: LD_VAR 0 23
51198: PUSH
51199: LD_VAR 0 4
51203: PUSH
51204: LD_VAR 0 7
51208: ARRAY
51209: PPUSH
51210: CALL_OW 247
51214: PUSH
51215: LD_INT 1
51217: EQUAL
51218: AND
51219: IFFALSE 51697
// begin if group [ i ] in healers then
51221: LD_VAR 0 4
51225: PUSH
51226: LD_VAR 0 7
51230: ARRAY
51231: PUSH
51232: LD_VAR 0 31
51236: IN
51237: IFFALSE 51510
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
51239: LD_VAR 0 4
51243: PUSH
51244: LD_VAR 0 7
51248: ARRAY
51249: PPUSH
51250: LD_VAR 0 23
51254: PPUSH
51255: CALL_OW 308
51259: NOT
51260: PUSH
51261: LD_VAR 0 4
51265: PUSH
51266: LD_VAR 0 7
51270: ARRAY
51271: PPUSH
51272: CALL_OW 314
51276: NOT
51277: AND
51278: IFFALSE 51302
// ComMoveToArea ( group [ i ] , f_heal ) else
51280: LD_VAR 0 4
51284: PUSH
51285: LD_VAR 0 7
51289: ARRAY
51290: PPUSH
51291: LD_VAR 0 23
51295: PPUSH
51296: CALL_OW 113
51300: GO 51508
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
51302: LD_VAR 0 4
51306: PUSH
51307: LD_VAR 0 7
51311: ARRAY
51312: PPUSH
51313: CALL 49920 0 1
51317: PPUSH
51318: CALL_OW 256
51322: PUSH
51323: LD_INT 1000
51325: EQUAL
51326: IFFALSE 51345
// ComStop ( group [ i ] ) else
51328: LD_VAR 0 4
51332: PUSH
51333: LD_VAR 0 7
51337: ARRAY
51338: PPUSH
51339: CALL_OW 141
51343: GO 51508
// if not HasTask ( group [ i ] ) and to_heal then
51345: LD_VAR 0 4
51349: PUSH
51350: LD_VAR 0 7
51354: ARRAY
51355: PPUSH
51356: CALL_OW 314
51360: NOT
51361: PUSH
51362: LD_VAR 0 30
51366: AND
51367: IFFALSE 51508
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
51369: LD_ADDR_VAR 0 13
51373: PUSH
51374: LD_VAR 0 30
51378: PPUSH
51379: LD_INT 3
51381: PUSH
51382: LD_INT 54
51384: PUSH
51385: EMPTY
51386: LIST
51387: PUSH
51388: EMPTY
51389: LIST
51390: LIST
51391: PPUSH
51392: CALL_OW 72
51396: PPUSH
51397: LD_VAR 0 4
51401: PUSH
51402: LD_VAR 0 7
51406: ARRAY
51407: PPUSH
51408: CALL_OW 74
51412: ST_TO_ADDR
// if z then
51413: LD_VAR 0 13
51417: IFFALSE 51508
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
51419: LD_INT 91
51421: PUSH
51422: LD_VAR 0 13
51426: PUSH
51427: LD_INT 10
51429: PUSH
51430: EMPTY
51431: LIST
51432: LIST
51433: LIST
51434: PUSH
51435: LD_INT 81
51437: PUSH
51438: LD_VAR 0 13
51442: PPUSH
51443: CALL_OW 255
51447: PUSH
51448: EMPTY
51449: LIST
51450: LIST
51451: PUSH
51452: EMPTY
51453: LIST
51454: LIST
51455: PPUSH
51456: CALL_OW 69
51460: PUSH
51461: LD_INT 0
51463: EQUAL
51464: IFFALSE 51488
// ComHeal ( group [ i ] , z ) else
51466: LD_VAR 0 4
51470: PUSH
51471: LD_VAR 0 7
51475: ARRAY
51476: PPUSH
51477: LD_VAR 0 13
51481: PPUSH
51482: CALL_OW 128
51486: GO 51508
// ComMoveToArea ( group [ i ] , f_heal ) ;
51488: LD_VAR 0 4
51492: PUSH
51493: LD_VAR 0 7
51497: ARRAY
51498: PPUSH
51499: LD_VAR 0 23
51503: PPUSH
51504: CALL_OW 113
// end ; continue ;
51508: GO 50539
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
51510: LD_VAR 0 4
51514: PUSH
51515: LD_VAR 0 7
51519: ARRAY
51520: PPUSH
51521: CALL_OW 256
51525: PUSH
51526: LD_INT 700
51528: LESS
51529: PUSH
51530: LD_VAR 0 4
51534: PUSH
51535: LD_VAR 0 7
51539: ARRAY
51540: PUSH
51541: LD_VAR 0 30
51545: IN
51546: NOT
51547: AND
51548: IFFALSE 51572
// to_heal := to_heal union group [ i ] ;
51550: LD_ADDR_VAR 0 30
51554: PUSH
51555: LD_VAR 0 30
51559: PUSH
51560: LD_VAR 0 4
51564: PUSH
51565: LD_VAR 0 7
51569: ARRAY
51570: UNION
51571: ST_TO_ADDR
// if group [ i ] in to_heal then
51572: LD_VAR 0 4
51576: PUSH
51577: LD_VAR 0 7
51581: ARRAY
51582: PUSH
51583: LD_VAR 0 30
51587: IN
51588: IFFALSE 51697
// begin if GetLives ( group [ i ] ) = 1000 then
51590: LD_VAR 0 4
51594: PUSH
51595: LD_VAR 0 7
51599: ARRAY
51600: PPUSH
51601: CALL_OW 256
51605: PUSH
51606: LD_INT 1000
51608: EQUAL
51609: IFFALSE 51635
// to_heal := to_heal diff group [ i ] else
51611: LD_ADDR_VAR 0 30
51615: PUSH
51616: LD_VAR 0 30
51620: PUSH
51621: LD_VAR 0 4
51625: PUSH
51626: LD_VAR 0 7
51630: ARRAY
51631: DIFF
51632: ST_TO_ADDR
51633: GO 51697
// begin if not IsInArea ( group [ i ] , to_heal ) then
51635: LD_VAR 0 4
51639: PUSH
51640: LD_VAR 0 7
51644: ARRAY
51645: PPUSH
51646: LD_VAR 0 30
51650: PPUSH
51651: CALL_OW 308
51655: NOT
51656: IFFALSE 51680
// ComMoveToArea ( group [ i ] , f_heal ) else
51658: LD_VAR 0 4
51662: PUSH
51663: LD_VAR 0 7
51667: ARRAY
51668: PPUSH
51669: LD_VAR 0 23
51673: PPUSH
51674: CALL_OW 113
51678: GO 51695
// ComHold ( group [ i ] ) ;
51680: LD_VAR 0 4
51684: PUSH
51685: LD_VAR 0 7
51689: ARRAY
51690: PPUSH
51691: CALL_OW 140
// continue ;
51695: GO 50539
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51697: LD_VAR 0 4
51701: PUSH
51702: LD_VAR 0 7
51706: ARRAY
51707: PPUSH
51708: LD_INT 10
51710: PPUSH
51711: CALL 48317 0 2
51715: NOT
51716: PUSH
51717: LD_VAR 0 16
51721: PUSH
51722: LD_VAR 0 7
51726: ARRAY
51727: PUSH
51728: EMPTY
51729: EQUAL
51730: NOT
51731: AND
51732: IFFALSE 51998
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51734: LD_VAR 0 4
51738: PUSH
51739: LD_VAR 0 7
51743: ARRAY
51744: PPUSH
51745: CALL_OW 262
51749: PUSH
51750: LD_INT 1
51752: PUSH
51753: LD_INT 2
51755: PUSH
51756: EMPTY
51757: LIST
51758: LIST
51759: IN
51760: IFFALSE 51801
// if GetFuel ( group [ i ] ) < 10 then
51762: LD_VAR 0 4
51766: PUSH
51767: LD_VAR 0 7
51771: ARRAY
51772: PPUSH
51773: CALL_OW 261
51777: PUSH
51778: LD_INT 10
51780: LESS
51781: IFFALSE 51801
// SetFuel ( group [ i ] , 12 ) ;
51783: LD_VAR 0 4
51787: PUSH
51788: LD_VAR 0 7
51792: ARRAY
51793: PPUSH
51794: LD_INT 12
51796: PPUSH
51797: CALL_OW 240
// if units_path [ i ] then
51801: LD_VAR 0 16
51805: PUSH
51806: LD_VAR 0 7
51810: ARRAY
51811: IFFALSE 51996
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51813: LD_VAR 0 4
51817: PUSH
51818: LD_VAR 0 7
51822: ARRAY
51823: PPUSH
51824: LD_VAR 0 16
51828: PUSH
51829: LD_VAR 0 7
51833: ARRAY
51834: PUSH
51835: LD_INT 1
51837: ARRAY
51838: PUSH
51839: LD_INT 1
51841: ARRAY
51842: PPUSH
51843: LD_VAR 0 16
51847: PUSH
51848: LD_VAR 0 7
51852: ARRAY
51853: PUSH
51854: LD_INT 1
51856: ARRAY
51857: PUSH
51858: LD_INT 2
51860: ARRAY
51861: PPUSH
51862: CALL_OW 297
51866: PUSH
51867: LD_INT 6
51869: GREATER
51870: IFFALSE 51945
// begin if not HasTask ( group [ i ] ) then
51872: LD_VAR 0 4
51876: PUSH
51877: LD_VAR 0 7
51881: ARRAY
51882: PPUSH
51883: CALL_OW 314
51887: NOT
51888: IFFALSE 51943
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51890: LD_VAR 0 4
51894: PUSH
51895: LD_VAR 0 7
51899: ARRAY
51900: PPUSH
51901: LD_VAR 0 16
51905: PUSH
51906: LD_VAR 0 7
51910: ARRAY
51911: PUSH
51912: LD_INT 1
51914: ARRAY
51915: PUSH
51916: LD_INT 1
51918: ARRAY
51919: PPUSH
51920: LD_VAR 0 16
51924: PUSH
51925: LD_VAR 0 7
51929: ARRAY
51930: PUSH
51931: LD_INT 1
51933: ARRAY
51934: PUSH
51935: LD_INT 2
51937: ARRAY
51938: PPUSH
51939: CALL_OW 114
// end else
51943: GO 51996
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51945: LD_ADDR_VAR 0 15
51949: PUSH
51950: LD_VAR 0 16
51954: PUSH
51955: LD_VAR 0 7
51959: ARRAY
51960: PPUSH
51961: LD_INT 1
51963: PPUSH
51964: CALL_OW 3
51968: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51969: LD_ADDR_VAR 0 16
51973: PUSH
51974: LD_VAR 0 16
51978: PPUSH
51979: LD_VAR 0 7
51983: PPUSH
51984: LD_VAR 0 15
51988: PPUSH
51989: CALL_OW 1
51993: ST_TO_ADDR
// continue ;
51994: GO 50539
// end ; end ; end else
51996: GO 54634
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51998: LD_ADDR_VAR 0 14
52002: PUSH
52003: LD_INT 81
52005: PUSH
52006: LD_VAR 0 4
52010: PUSH
52011: LD_VAR 0 7
52015: ARRAY
52016: PPUSH
52017: CALL_OW 255
52021: PUSH
52022: EMPTY
52023: LIST
52024: LIST
52025: PPUSH
52026: CALL_OW 69
52030: ST_TO_ADDR
// if not tmp then
52031: LD_VAR 0 14
52035: NOT
52036: IFFALSE 52040
// continue ;
52038: GO 50539
// if f_ignore_area then
52040: LD_VAR 0 17
52044: IFFALSE 52132
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
52046: LD_ADDR_VAR 0 15
52050: PUSH
52051: LD_VAR 0 14
52055: PPUSH
52056: LD_INT 3
52058: PUSH
52059: LD_INT 92
52061: PUSH
52062: LD_VAR 0 17
52066: PUSH
52067: LD_INT 1
52069: ARRAY
52070: PUSH
52071: LD_VAR 0 17
52075: PUSH
52076: LD_INT 2
52078: ARRAY
52079: PUSH
52080: LD_VAR 0 17
52084: PUSH
52085: LD_INT 3
52087: ARRAY
52088: PUSH
52089: EMPTY
52090: LIST
52091: LIST
52092: LIST
52093: LIST
52094: PUSH
52095: EMPTY
52096: LIST
52097: LIST
52098: PPUSH
52099: CALL_OW 72
52103: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52104: LD_VAR 0 14
52108: PUSH
52109: LD_VAR 0 15
52113: DIFF
52114: IFFALSE 52132
// tmp := tmp diff tmp2 ;
52116: LD_ADDR_VAR 0 14
52120: PUSH
52121: LD_VAR 0 14
52125: PUSH
52126: LD_VAR 0 15
52130: DIFF
52131: ST_TO_ADDR
// end ; if not f_murder then
52132: LD_VAR 0 20
52136: NOT
52137: IFFALSE 52195
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
52139: LD_ADDR_VAR 0 15
52143: PUSH
52144: LD_VAR 0 14
52148: PPUSH
52149: LD_INT 3
52151: PUSH
52152: LD_INT 50
52154: PUSH
52155: EMPTY
52156: LIST
52157: PUSH
52158: EMPTY
52159: LIST
52160: LIST
52161: PPUSH
52162: CALL_OW 72
52166: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52167: LD_VAR 0 14
52171: PUSH
52172: LD_VAR 0 15
52176: DIFF
52177: IFFALSE 52195
// tmp := tmp diff tmp2 ;
52179: LD_ADDR_VAR 0 14
52183: PUSH
52184: LD_VAR 0 14
52188: PUSH
52189: LD_VAR 0 15
52193: DIFF
52194: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
52195: LD_ADDR_VAR 0 14
52199: PUSH
52200: LD_VAR 0 4
52204: PUSH
52205: LD_VAR 0 7
52209: ARRAY
52210: PPUSH
52211: LD_VAR 0 14
52215: PPUSH
52216: LD_INT 1
52218: PPUSH
52219: LD_INT 1
52221: PPUSH
52222: CALL 21960 0 4
52226: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
52227: LD_VAR 0 4
52231: PUSH
52232: LD_VAR 0 7
52236: ARRAY
52237: PPUSH
52238: CALL_OW 257
52242: PUSH
52243: LD_INT 1
52245: EQUAL
52246: IFFALSE 52694
// begin if WantPlant ( group [ i ] ) then
52248: LD_VAR 0 4
52252: PUSH
52253: LD_VAR 0 7
52257: ARRAY
52258: PPUSH
52259: CALL 21461 0 1
52263: IFFALSE 52267
// continue ;
52265: GO 50539
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
52267: LD_VAR 0 18
52271: PUSH
52272: LD_VAR 0 4
52276: PUSH
52277: LD_VAR 0 7
52281: ARRAY
52282: PPUSH
52283: CALL_OW 310
52287: NOT
52288: AND
52289: PUSH
52290: LD_VAR 0 14
52294: PUSH
52295: LD_INT 1
52297: ARRAY
52298: PUSH
52299: LD_VAR 0 14
52303: PPUSH
52304: LD_INT 21
52306: PUSH
52307: LD_INT 2
52309: PUSH
52310: EMPTY
52311: LIST
52312: LIST
52313: PUSH
52314: LD_INT 58
52316: PUSH
52317: EMPTY
52318: LIST
52319: PUSH
52320: EMPTY
52321: LIST
52322: LIST
52323: PPUSH
52324: CALL_OW 72
52328: IN
52329: AND
52330: IFFALSE 52366
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
52332: LD_VAR 0 4
52336: PUSH
52337: LD_VAR 0 7
52341: ARRAY
52342: PPUSH
52343: LD_VAR 0 14
52347: PUSH
52348: LD_INT 1
52350: ARRAY
52351: PPUSH
52352: CALL_OW 120
// attacking := true ;
52356: LD_ADDR_VAR 0 29
52360: PUSH
52361: LD_INT 1
52363: ST_TO_ADDR
// continue ;
52364: GO 50539
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
52366: LD_VAR 0 26
52370: PUSH
52371: LD_VAR 0 4
52375: PUSH
52376: LD_VAR 0 7
52380: ARRAY
52381: PPUSH
52382: CALL_OW 257
52386: PUSH
52387: LD_INT 1
52389: EQUAL
52390: AND
52391: PUSH
52392: LD_VAR 0 4
52396: PUSH
52397: LD_VAR 0 7
52401: ARRAY
52402: PPUSH
52403: CALL_OW 256
52407: PUSH
52408: LD_INT 800
52410: LESS
52411: AND
52412: PUSH
52413: LD_VAR 0 4
52417: PUSH
52418: LD_VAR 0 7
52422: ARRAY
52423: PPUSH
52424: CALL_OW 318
52428: NOT
52429: AND
52430: IFFALSE 52447
// ComCrawl ( group [ i ] ) ;
52432: LD_VAR 0 4
52436: PUSH
52437: LD_VAR 0 7
52441: ARRAY
52442: PPUSH
52443: CALL_OW 137
// if f_mines then
52447: LD_VAR 0 21
52451: IFFALSE 52694
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
52453: LD_VAR 0 14
52457: PUSH
52458: LD_INT 1
52460: ARRAY
52461: PPUSH
52462: CALL_OW 247
52466: PUSH
52467: LD_INT 3
52469: EQUAL
52470: PUSH
52471: LD_VAR 0 14
52475: PUSH
52476: LD_INT 1
52478: ARRAY
52479: PUSH
52480: LD_VAR 0 27
52484: IN
52485: NOT
52486: AND
52487: IFFALSE 52694
// begin x := GetX ( tmp [ 1 ] ) ;
52489: LD_ADDR_VAR 0 10
52493: PUSH
52494: LD_VAR 0 14
52498: PUSH
52499: LD_INT 1
52501: ARRAY
52502: PPUSH
52503: CALL_OW 250
52507: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
52508: LD_ADDR_VAR 0 11
52512: PUSH
52513: LD_VAR 0 14
52517: PUSH
52518: LD_INT 1
52520: ARRAY
52521: PPUSH
52522: CALL_OW 251
52526: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
52527: LD_ADDR_VAR 0 12
52531: PUSH
52532: LD_VAR 0 4
52536: PUSH
52537: LD_VAR 0 7
52541: ARRAY
52542: PPUSH
52543: CALL 48402 0 1
52547: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
52548: LD_VAR 0 4
52552: PUSH
52553: LD_VAR 0 7
52557: ARRAY
52558: PPUSH
52559: LD_VAR 0 10
52563: PPUSH
52564: LD_VAR 0 11
52568: PPUSH
52569: LD_VAR 0 14
52573: PUSH
52574: LD_INT 1
52576: ARRAY
52577: PPUSH
52578: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
52582: LD_VAR 0 4
52586: PUSH
52587: LD_VAR 0 7
52591: ARRAY
52592: PPUSH
52593: LD_VAR 0 10
52597: PPUSH
52598: LD_VAR 0 12
52602: PPUSH
52603: LD_INT 7
52605: PPUSH
52606: CALL_OW 272
52610: PPUSH
52611: LD_VAR 0 11
52615: PPUSH
52616: LD_VAR 0 12
52620: PPUSH
52621: LD_INT 7
52623: PPUSH
52624: CALL_OW 273
52628: PPUSH
52629: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
52633: LD_VAR 0 4
52637: PUSH
52638: LD_VAR 0 7
52642: ARRAY
52643: PPUSH
52644: LD_INT 71
52646: PPUSH
52647: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
52651: LD_ADDR_VAR 0 27
52655: PUSH
52656: LD_VAR 0 27
52660: PPUSH
52661: LD_VAR 0 27
52665: PUSH
52666: LD_INT 1
52668: PLUS
52669: PPUSH
52670: LD_VAR 0 14
52674: PUSH
52675: LD_INT 1
52677: ARRAY
52678: PPUSH
52679: CALL_OW 1
52683: ST_TO_ADDR
// attacking := true ;
52684: LD_ADDR_VAR 0 29
52688: PUSH
52689: LD_INT 1
52691: ST_TO_ADDR
// continue ;
52692: GO 50539
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52694: LD_VAR 0 4
52698: PUSH
52699: LD_VAR 0 7
52703: ARRAY
52704: PPUSH
52705: CALL_OW 257
52709: PUSH
52710: LD_INT 17
52712: EQUAL
52713: PUSH
52714: LD_VAR 0 4
52718: PUSH
52719: LD_VAR 0 7
52723: ARRAY
52724: PPUSH
52725: CALL_OW 110
52729: PUSH
52730: LD_INT 71
52732: EQUAL
52733: NOT
52734: AND
52735: IFFALSE 52881
// begin attacking := false ;
52737: LD_ADDR_VAR 0 29
52741: PUSH
52742: LD_INT 0
52744: ST_TO_ADDR
// k := 5 ;
52745: LD_ADDR_VAR 0 9
52749: PUSH
52750: LD_INT 5
52752: ST_TO_ADDR
// if tmp < k then
52753: LD_VAR 0 14
52757: PUSH
52758: LD_VAR 0 9
52762: LESS
52763: IFFALSE 52775
// k := tmp ;
52765: LD_ADDR_VAR 0 9
52769: PUSH
52770: LD_VAR 0 14
52774: ST_TO_ADDR
// for j = 1 to k do
52775: LD_ADDR_VAR 0 8
52779: PUSH
52780: DOUBLE
52781: LD_INT 1
52783: DEC
52784: ST_TO_ADDR
52785: LD_VAR 0 9
52789: PUSH
52790: FOR_TO
52791: IFFALSE 52879
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52793: LD_VAR 0 14
52797: PUSH
52798: LD_VAR 0 8
52802: ARRAY
52803: PUSH
52804: LD_VAR 0 14
52808: PPUSH
52809: LD_INT 58
52811: PUSH
52812: EMPTY
52813: LIST
52814: PPUSH
52815: CALL_OW 72
52819: IN
52820: NOT
52821: IFFALSE 52877
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52823: LD_VAR 0 4
52827: PUSH
52828: LD_VAR 0 7
52832: ARRAY
52833: PPUSH
52834: LD_VAR 0 14
52838: PUSH
52839: LD_VAR 0 8
52843: ARRAY
52844: PPUSH
52845: CALL_OW 115
// attacking := true ;
52849: LD_ADDR_VAR 0 29
52853: PUSH
52854: LD_INT 1
52856: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52857: LD_VAR 0 4
52861: PUSH
52862: LD_VAR 0 7
52866: ARRAY
52867: PPUSH
52868: LD_INT 71
52870: PPUSH
52871: CALL_OW 109
// continue ;
52875: GO 52790
// end ; end ;
52877: GO 52790
52879: POP
52880: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52881: LD_VAR 0 4
52885: PUSH
52886: LD_VAR 0 7
52890: ARRAY
52891: PPUSH
52892: CALL_OW 257
52896: PUSH
52897: LD_INT 8
52899: EQUAL
52900: PUSH
52901: LD_VAR 0 4
52905: PUSH
52906: LD_VAR 0 7
52910: ARRAY
52911: PPUSH
52912: CALL_OW 264
52916: PUSH
52917: LD_INT 28
52919: PUSH
52920: LD_INT 45
52922: PUSH
52923: LD_INT 7
52925: PUSH
52926: LD_INT 47
52928: PUSH
52929: EMPTY
52930: LIST
52931: LIST
52932: LIST
52933: LIST
52934: IN
52935: OR
52936: IFFALSE 53166
// begin attacking := false ;
52938: LD_ADDR_VAR 0 29
52942: PUSH
52943: LD_INT 0
52945: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52946: LD_VAR 0 14
52950: PUSH
52951: LD_INT 1
52953: ARRAY
52954: PPUSH
52955: CALL_OW 266
52959: PUSH
52960: LD_INT 32
52962: PUSH
52963: LD_INT 31
52965: PUSH
52966: LD_INT 33
52968: PUSH
52969: LD_INT 4
52971: PUSH
52972: LD_INT 5
52974: PUSH
52975: EMPTY
52976: LIST
52977: LIST
52978: LIST
52979: LIST
52980: LIST
52981: IN
52982: IFFALSE 53166
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52984: LD_ADDR_VAR 0 9
52988: PUSH
52989: LD_VAR 0 14
52993: PUSH
52994: LD_INT 1
52996: ARRAY
52997: PPUSH
52998: CALL_OW 266
53002: PPUSH
53003: LD_VAR 0 14
53007: PUSH
53008: LD_INT 1
53010: ARRAY
53011: PPUSH
53012: CALL_OW 250
53016: PPUSH
53017: LD_VAR 0 14
53021: PUSH
53022: LD_INT 1
53024: ARRAY
53025: PPUSH
53026: CALL_OW 251
53030: PPUSH
53031: LD_VAR 0 14
53035: PUSH
53036: LD_INT 1
53038: ARRAY
53039: PPUSH
53040: CALL_OW 254
53044: PPUSH
53045: LD_VAR 0 14
53049: PUSH
53050: LD_INT 1
53052: ARRAY
53053: PPUSH
53054: CALL_OW 248
53058: PPUSH
53059: LD_INT 0
53061: PPUSH
53062: CALL 29772 0 6
53066: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
53067: LD_ADDR_VAR 0 8
53071: PUSH
53072: LD_VAR 0 4
53076: PUSH
53077: LD_VAR 0 7
53081: ARRAY
53082: PPUSH
53083: LD_VAR 0 9
53087: PPUSH
53088: CALL 48465 0 2
53092: ST_TO_ADDR
// if j then
53093: LD_VAR 0 8
53097: IFFALSE 53166
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
53099: LD_VAR 0 8
53103: PUSH
53104: LD_INT 1
53106: ARRAY
53107: PPUSH
53108: LD_VAR 0 8
53112: PUSH
53113: LD_INT 2
53115: ARRAY
53116: PPUSH
53117: CALL_OW 488
53121: IFFALSE 53166
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
53123: LD_VAR 0 4
53127: PUSH
53128: LD_VAR 0 7
53132: ARRAY
53133: PPUSH
53134: LD_VAR 0 8
53138: PUSH
53139: LD_INT 1
53141: ARRAY
53142: PPUSH
53143: LD_VAR 0 8
53147: PUSH
53148: LD_INT 2
53150: ARRAY
53151: PPUSH
53152: CALL_OW 116
// attacking := true ;
53156: LD_ADDR_VAR 0 29
53160: PUSH
53161: LD_INT 1
53163: ST_TO_ADDR
// continue ;
53164: GO 50539
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
53166: LD_VAR 0 4
53170: PUSH
53171: LD_VAR 0 7
53175: ARRAY
53176: PPUSH
53177: CALL_OW 265
53181: PUSH
53182: LD_INT 11
53184: EQUAL
53185: IFFALSE 53463
// begin k := 10 ;
53187: LD_ADDR_VAR 0 9
53191: PUSH
53192: LD_INT 10
53194: ST_TO_ADDR
// x := 0 ;
53195: LD_ADDR_VAR 0 10
53199: PUSH
53200: LD_INT 0
53202: ST_TO_ADDR
// if tmp < k then
53203: LD_VAR 0 14
53207: PUSH
53208: LD_VAR 0 9
53212: LESS
53213: IFFALSE 53225
// k := tmp ;
53215: LD_ADDR_VAR 0 9
53219: PUSH
53220: LD_VAR 0 14
53224: ST_TO_ADDR
// for j = k downto 1 do
53225: LD_ADDR_VAR 0 8
53229: PUSH
53230: DOUBLE
53231: LD_VAR 0 9
53235: INC
53236: ST_TO_ADDR
53237: LD_INT 1
53239: PUSH
53240: FOR_DOWNTO
53241: IFFALSE 53316
// begin if GetType ( tmp [ j ] ) = unit_human then
53243: LD_VAR 0 14
53247: PUSH
53248: LD_VAR 0 8
53252: ARRAY
53253: PPUSH
53254: CALL_OW 247
53258: PUSH
53259: LD_INT 1
53261: EQUAL
53262: IFFALSE 53314
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
53264: LD_VAR 0 4
53268: PUSH
53269: LD_VAR 0 7
53273: ARRAY
53274: PPUSH
53275: LD_VAR 0 14
53279: PUSH
53280: LD_VAR 0 8
53284: ARRAY
53285: PPUSH
53286: CALL 48736 0 2
// x := tmp [ j ] ;
53290: LD_ADDR_VAR 0 10
53294: PUSH
53295: LD_VAR 0 14
53299: PUSH
53300: LD_VAR 0 8
53304: ARRAY
53305: ST_TO_ADDR
// attacking := true ;
53306: LD_ADDR_VAR 0 29
53310: PUSH
53311: LD_INT 1
53313: ST_TO_ADDR
// end ; end ;
53314: GO 53240
53316: POP
53317: POP
// if not x then
53318: LD_VAR 0 10
53322: NOT
53323: IFFALSE 53463
// begin attacking := true ;
53325: LD_ADDR_VAR 0 29
53329: PUSH
53330: LD_INT 1
53332: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
53333: LD_VAR 0 4
53337: PUSH
53338: LD_VAR 0 7
53342: ARRAY
53343: PPUSH
53344: CALL_OW 250
53348: PPUSH
53349: LD_VAR 0 4
53353: PUSH
53354: LD_VAR 0 7
53358: ARRAY
53359: PPUSH
53360: CALL_OW 251
53364: PPUSH
53365: CALL_OW 546
53369: PUSH
53370: LD_INT 2
53372: ARRAY
53373: PUSH
53374: LD_VAR 0 14
53378: PUSH
53379: LD_INT 1
53381: ARRAY
53382: PPUSH
53383: CALL_OW 250
53387: PPUSH
53388: LD_VAR 0 14
53392: PUSH
53393: LD_INT 1
53395: ARRAY
53396: PPUSH
53397: CALL_OW 251
53401: PPUSH
53402: CALL_OW 546
53406: PUSH
53407: LD_INT 2
53409: ARRAY
53410: EQUAL
53411: IFFALSE 53439
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
53413: LD_VAR 0 4
53417: PUSH
53418: LD_VAR 0 7
53422: ARRAY
53423: PPUSH
53424: LD_VAR 0 14
53428: PUSH
53429: LD_INT 1
53431: ARRAY
53432: PPUSH
53433: CALL 48736 0 2
53437: GO 53463
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53439: LD_VAR 0 4
53443: PUSH
53444: LD_VAR 0 7
53448: ARRAY
53449: PPUSH
53450: LD_VAR 0 14
53454: PUSH
53455: LD_INT 1
53457: ARRAY
53458: PPUSH
53459: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
53463: LD_VAR 0 4
53467: PUSH
53468: LD_VAR 0 7
53472: ARRAY
53473: PPUSH
53474: CALL_OW 264
53478: PUSH
53479: LD_INT 29
53481: EQUAL
53482: IFFALSE 53848
// begin if WantsToAttack ( group [ i ] ) in bombed then
53484: LD_VAR 0 4
53488: PUSH
53489: LD_VAR 0 7
53493: ARRAY
53494: PPUSH
53495: CALL_OW 319
53499: PUSH
53500: LD_VAR 0 28
53504: IN
53505: IFFALSE 53509
// continue ;
53507: GO 50539
// k := 8 ;
53509: LD_ADDR_VAR 0 9
53513: PUSH
53514: LD_INT 8
53516: ST_TO_ADDR
// x := 0 ;
53517: LD_ADDR_VAR 0 10
53521: PUSH
53522: LD_INT 0
53524: ST_TO_ADDR
// if tmp < k then
53525: LD_VAR 0 14
53529: PUSH
53530: LD_VAR 0 9
53534: LESS
53535: IFFALSE 53547
// k := tmp ;
53537: LD_ADDR_VAR 0 9
53541: PUSH
53542: LD_VAR 0 14
53546: ST_TO_ADDR
// for j = 1 to k do
53547: LD_ADDR_VAR 0 8
53551: PUSH
53552: DOUBLE
53553: LD_INT 1
53555: DEC
53556: ST_TO_ADDR
53557: LD_VAR 0 9
53561: PUSH
53562: FOR_TO
53563: IFFALSE 53695
// begin if GetType ( tmp [ j ] ) = unit_building then
53565: LD_VAR 0 14
53569: PUSH
53570: LD_VAR 0 8
53574: ARRAY
53575: PPUSH
53576: CALL_OW 247
53580: PUSH
53581: LD_INT 3
53583: EQUAL
53584: IFFALSE 53693
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
53586: LD_VAR 0 14
53590: PUSH
53591: LD_VAR 0 8
53595: ARRAY
53596: PUSH
53597: LD_VAR 0 28
53601: IN
53602: NOT
53603: PUSH
53604: LD_VAR 0 14
53608: PUSH
53609: LD_VAR 0 8
53613: ARRAY
53614: PPUSH
53615: CALL_OW 313
53619: AND
53620: IFFALSE 53693
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53622: LD_VAR 0 4
53626: PUSH
53627: LD_VAR 0 7
53631: ARRAY
53632: PPUSH
53633: LD_VAR 0 14
53637: PUSH
53638: LD_VAR 0 8
53642: ARRAY
53643: PPUSH
53644: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
53648: LD_ADDR_VAR 0 28
53652: PUSH
53653: LD_VAR 0 28
53657: PPUSH
53658: LD_VAR 0 28
53662: PUSH
53663: LD_INT 1
53665: PLUS
53666: PPUSH
53667: LD_VAR 0 14
53671: PUSH
53672: LD_VAR 0 8
53676: ARRAY
53677: PPUSH
53678: CALL_OW 1
53682: ST_TO_ADDR
// attacking := true ;
53683: LD_ADDR_VAR 0 29
53687: PUSH
53688: LD_INT 1
53690: ST_TO_ADDR
// break ;
53691: GO 53695
// end ; end ;
53693: GO 53562
53695: POP
53696: POP
// if not attacking and f_attack_depot then
53697: LD_VAR 0 29
53701: NOT
53702: PUSH
53703: LD_VAR 0 25
53707: AND
53708: IFFALSE 53803
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53710: LD_ADDR_VAR 0 13
53714: PUSH
53715: LD_VAR 0 14
53719: PPUSH
53720: LD_INT 2
53722: PUSH
53723: LD_INT 30
53725: PUSH
53726: LD_INT 0
53728: PUSH
53729: EMPTY
53730: LIST
53731: LIST
53732: PUSH
53733: LD_INT 30
53735: PUSH
53736: LD_INT 1
53738: PUSH
53739: EMPTY
53740: LIST
53741: LIST
53742: PUSH
53743: EMPTY
53744: LIST
53745: LIST
53746: LIST
53747: PPUSH
53748: CALL_OW 72
53752: ST_TO_ADDR
// if z then
53753: LD_VAR 0 13
53757: IFFALSE 53803
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53759: LD_VAR 0 4
53763: PUSH
53764: LD_VAR 0 7
53768: ARRAY
53769: PPUSH
53770: LD_VAR 0 13
53774: PPUSH
53775: LD_VAR 0 4
53779: PUSH
53780: LD_VAR 0 7
53784: ARRAY
53785: PPUSH
53786: CALL_OW 74
53790: PPUSH
53791: CALL_OW 115
// attacking := true ;
53795: LD_ADDR_VAR 0 29
53799: PUSH
53800: LD_INT 1
53802: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53803: LD_VAR 0 4
53807: PUSH
53808: LD_VAR 0 7
53812: ARRAY
53813: PPUSH
53814: CALL_OW 256
53818: PUSH
53819: LD_INT 500
53821: LESS
53822: IFFALSE 53848
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53824: LD_VAR 0 4
53828: PUSH
53829: LD_VAR 0 7
53833: ARRAY
53834: PPUSH
53835: LD_VAR 0 14
53839: PUSH
53840: LD_INT 1
53842: ARRAY
53843: PPUSH
53844: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53848: LD_VAR 0 4
53852: PUSH
53853: LD_VAR 0 7
53857: ARRAY
53858: PPUSH
53859: CALL_OW 264
53863: PUSH
53864: LD_INT 49
53866: EQUAL
53867: IFFALSE 53988
// begin if not HasTask ( group [ i ] ) then
53869: LD_VAR 0 4
53873: PUSH
53874: LD_VAR 0 7
53878: ARRAY
53879: PPUSH
53880: CALL_OW 314
53884: NOT
53885: IFFALSE 53988
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53887: LD_ADDR_VAR 0 9
53891: PUSH
53892: LD_INT 81
53894: PUSH
53895: LD_VAR 0 4
53899: PUSH
53900: LD_VAR 0 7
53904: ARRAY
53905: PPUSH
53906: CALL_OW 255
53910: PUSH
53911: EMPTY
53912: LIST
53913: LIST
53914: PPUSH
53915: CALL_OW 69
53919: PPUSH
53920: LD_VAR 0 4
53924: PUSH
53925: LD_VAR 0 7
53929: ARRAY
53930: PPUSH
53931: CALL_OW 74
53935: ST_TO_ADDR
// if k then
53936: LD_VAR 0 9
53940: IFFALSE 53988
// if GetDistUnits ( group [ i ] , k ) > 10 then
53942: LD_VAR 0 4
53946: PUSH
53947: LD_VAR 0 7
53951: ARRAY
53952: PPUSH
53953: LD_VAR 0 9
53957: PPUSH
53958: CALL_OW 296
53962: PUSH
53963: LD_INT 10
53965: GREATER
53966: IFFALSE 53988
// ComMoveUnit ( group [ i ] , k ) ;
53968: LD_VAR 0 4
53972: PUSH
53973: LD_VAR 0 7
53977: ARRAY
53978: PPUSH
53979: LD_VAR 0 9
53983: PPUSH
53984: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53988: LD_VAR 0 4
53992: PUSH
53993: LD_VAR 0 7
53997: ARRAY
53998: PPUSH
53999: CALL_OW 256
54003: PUSH
54004: LD_INT 250
54006: LESS
54007: PUSH
54008: LD_VAR 0 4
54012: PUSH
54013: LD_VAR 0 7
54017: ARRAY
54018: PUSH
54019: LD_INT 21
54021: PUSH
54022: LD_INT 2
54024: PUSH
54025: EMPTY
54026: LIST
54027: LIST
54028: PUSH
54029: LD_INT 23
54031: PUSH
54032: LD_INT 2
54034: PUSH
54035: EMPTY
54036: LIST
54037: LIST
54038: PUSH
54039: EMPTY
54040: LIST
54041: LIST
54042: PPUSH
54043: CALL_OW 69
54047: IN
54048: AND
54049: IFFALSE 54174
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
54051: LD_ADDR_VAR 0 9
54055: PUSH
54056: LD_OWVAR 3
54060: PUSH
54061: LD_VAR 0 4
54065: PUSH
54066: LD_VAR 0 7
54070: ARRAY
54071: DIFF
54072: PPUSH
54073: LD_VAR 0 4
54077: PUSH
54078: LD_VAR 0 7
54082: ARRAY
54083: PPUSH
54084: CALL_OW 74
54088: ST_TO_ADDR
// if not k then
54089: LD_VAR 0 9
54093: NOT
54094: IFFALSE 54098
// continue ;
54096: GO 50539
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
54098: LD_VAR 0 9
54102: PUSH
54103: LD_INT 81
54105: PUSH
54106: LD_VAR 0 4
54110: PUSH
54111: LD_VAR 0 7
54115: ARRAY
54116: PPUSH
54117: CALL_OW 255
54121: PUSH
54122: EMPTY
54123: LIST
54124: LIST
54125: PPUSH
54126: CALL_OW 69
54130: IN
54131: PUSH
54132: LD_VAR 0 9
54136: PPUSH
54137: LD_VAR 0 4
54141: PUSH
54142: LD_VAR 0 7
54146: ARRAY
54147: PPUSH
54148: CALL_OW 296
54152: PUSH
54153: LD_INT 5
54155: LESS
54156: AND
54157: IFFALSE 54174
// ComAutodestruct ( group [ i ] ) ;
54159: LD_VAR 0 4
54163: PUSH
54164: LD_VAR 0 7
54168: ARRAY
54169: PPUSH
54170: CALL 48634 0 1
// end ; if f_attack_depot then
54174: LD_VAR 0 25
54178: IFFALSE 54290
// begin k := 6 ;
54180: LD_ADDR_VAR 0 9
54184: PUSH
54185: LD_INT 6
54187: ST_TO_ADDR
// if tmp < k then
54188: LD_VAR 0 14
54192: PUSH
54193: LD_VAR 0 9
54197: LESS
54198: IFFALSE 54210
// k := tmp ;
54200: LD_ADDR_VAR 0 9
54204: PUSH
54205: LD_VAR 0 14
54209: ST_TO_ADDR
// for j = 1 to k do
54210: LD_ADDR_VAR 0 8
54214: PUSH
54215: DOUBLE
54216: LD_INT 1
54218: DEC
54219: ST_TO_ADDR
54220: LD_VAR 0 9
54224: PUSH
54225: FOR_TO
54226: IFFALSE 54288
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
54228: LD_VAR 0 8
54232: PPUSH
54233: CALL_OW 266
54237: PUSH
54238: LD_INT 0
54240: PUSH
54241: LD_INT 1
54243: PUSH
54244: EMPTY
54245: LIST
54246: LIST
54247: IN
54248: IFFALSE 54286
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
54250: LD_VAR 0 4
54254: PUSH
54255: LD_VAR 0 7
54259: ARRAY
54260: PPUSH
54261: LD_VAR 0 14
54265: PUSH
54266: LD_VAR 0 8
54270: ARRAY
54271: PPUSH
54272: CALL_OW 115
// attacking := true ;
54276: LD_ADDR_VAR 0 29
54280: PUSH
54281: LD_INT 1
54283: ST_TO_ADDR
// break ;
54284: GO 54288
// end ;
54286: GO 54225
54288: POP
54289: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
54290: LD_VAR 0 4
54294: PUSH
54295: LD_VAR 0 7
54299: ARRAY
54300: PPUSH
54301: CALL_OW 302
54305: PUSH
54306: LD_VAR 0 29
54310: NOT
54311: AND
54312: IFFALSE 54634
// begin if GetTag ( group [ i ] ) = 71 then
54314: LD_VAR 0 4
54318: PUSH
54319: LD_VAR 0 7
54323: ARRAY
54324: PPUSH
54325: CALL_OW 110
54329: PUSH
54330: LD_INT 71
54332: EQUAL
54333: IFFALSE 54374
// begin if HasTask ( group [ i ] ) then
54335: LD_VAR 0 4
54339: PUSH
54340: LD_VAR 0 7
54344: ARRAY
54345: PPUSH
54346: CALL_OW 314
54350: IFFALSE 54356
// continue else
54352: GO 50539
54354: GO 54374
// SetTag ( group [ i ] , 0 ) ;
54356: LD_VAR 0 4
54360: PUSH
54361: LD_VAR 0 7
54365: ARRAY
54366: PPUSH
54367: LD_INT 0
54369: PPUSH
54370: CALL_OW 109
// end ; k := 8 ;
54374: LD_ADDR_VAR 0 9
54378: PUSH
54379: LD_INT 8
54381: ST_TO_ADDR
// x := 0 ;
54382: LD_ADDR_VAR 0 10
54386: PUSH
54387: LD_INT 0
54389: ST_TO_ADDR
// if tmp < k then
54390: LD_VAR 0 14
54394: PUSH
54395: LD_VAR 0 9
54399: LESS
54400: IFFALSE 54412
// k := tmp ;
54402: LD_ADDR_VAR 0 9
54406: PUSH
54407: LD_VAR 0 14
54411: ST_TO_ADDR
// for j = 1 to k do
54412: LD_ADDR_VAR 0 8
54416: PUSH
54417: DOUBLE
54418: LD_INT 1
54420: DEC
54421: ST_TO_ADDR
54422: LD_VAR 0 9
54426: PUSH
54427: FOR_TO
54428: IFFALSE 54526
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
54430: LD_VAR 0 14
54434: PUSH
54435: LD_VAR 0 8
54439: ARRAY
54440: PPUSH
54441: CALL_OW 247
54445: PUSH
54446: LD_INT 1
54448: EQUAL
54449: PUSH
54450: LD_VAR 0 14
54454: PUSH
54455: LD_VAR 0 8
54459: ARRAY
54460: PPUSH
54461: CALL_OW 256
54465: PUSH
54466: LD_INT 250
54468: LESS
54469: PUSH
54470: LD_VAR 0 20
54474: AND
54475: PUSH
54476: LD_VAR 0 20
54480: NOT
54481: PUSH
54482: LD_VAR 0 14
54486: PUSH
54487: LD_VAR 0 8
54491: ARRAY
54492: PPUSH
54493: CALL_OW 256
54497: PUSH
54498: LD_INT 250
54500: GREATEREQUAL
54501: AND
54502: OR
54503: AND
54504: IFFALSE 54524
// begin x := tmp [ j ] ;
54506: LD_ADDR_VAR 0 10
54510: PUSH
54511: LD_VAR 0 14
54515: PUSH
54516: LD_VAR 0 8
54520: ARRAY
54521: ST_TO_ADDR
// break ;
54522: GO 54526
// end ;
54524: GO 54427
54526: POP
54527: POP
// if x then
54528: LD_VAR 0 10
54532: IFFALSE 54556
// ComAttackUnit ( group [ i ] , x ) else
54534: LD_VAR 0 4
54538: PUSH
54539: LD_VAR 0 7
54543: ARRAY
54544: PPUSH
54545: LD_VAR 0 10
54549: PPUSH
54550: CALL_OW 115
54554: GO 54580
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
54556: LD_VAR 0 4
54560: PUSH
54561: LD_VAR 0 7
54565: ARRAY
54566: PPUSH
54567: LD_VAR 0 14
54571: PUSH
54572: LD_INT 1
54574: ARRAY
54575: PPUSH
54576: CALL_OW 115
// if not HasTask ( group [ i ] ) then
54580: LD_VAR 0 4
54584: PUSH
54585: LD_VAR 0 7
54589: ARRAY
54590: PPUSH
54591: CALL_OW 314
54595: NOT
54596: IFFALSE 54634
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
54598: LD_VAR 0 4
54602: PUSH
54603: LD_VAR 0 7
54607: ARRAY
54608: PPUSH
54609: LD_VAR 0 14
54613: PPUSH
54614: LD_VAR 0 4
54618: PUSH
54619: LD_VAR 0 7
54623: ARRAY
54624: PPUSH
54625: CALL_OW 74
54629: PPUSH
54630: CALL_OW 115
// end ; end ; end ;
54634: GO 50539
54636: POP
54637: POP
// wait ( 0 0$1 ) ;
54638: LD_INT 35
54640: PPUSH
54641: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
54645: LD_VAR 0 4
54649: PUSH
54650: EMPTY
54651: EQUAL
54652: PUSH
54653: LD_INT 81
54655: PUSH
54656: LD_VAR 0 35
54660: PUSH
54661: EMPTY
54662: LIST
54663: LIST
54664: PPUSH
54665: CALL_OW 69
54669: NOT
54670: OR
54671: IFFALSE 50524
// end ;
54673: LD_VAR 0 2
54677: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54678: LD_INT 0
54680: PPUSH
54681: PPUSH
54682: PPUSH
54683: PPUSH
// if not base_units then
54684: LD_VAR 0 1
54688: NOT
54689: IFFALSE 54693
// exit ;
54691: GO 54780
// result := false ;
54693: LD_ADDR_VAR 0 2
54697: PUSH
54698: LD_INT 0
54700: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54701: LD_ADDR_VAR 0 5
54705: PUSH
54706: LD_VAR 0 1
54710: PPUSH
54711: LD_INT 21
54713: PUSH
54714: LD_INT 3
54716: PUSH
54717: EMPTY
54718: LIST
54719: LIST
54720: PPUSH
54721: CALL_OW 72
54725: ST_TO_ADDR
// if not tmp then
54726: LD_VAR 0 5
54730: NOT
54731: IFFALSE 54735
// exit ;
54733: GO 54780
// for i in tmp do
54735: LD_ADDR_VAR 0 3
54739: PUSH
54740: LD_VAR 0 5
54744: PUSH
54745: FOR_IN
54746: IFFALSE 54778
// begin result := EnemyInRange ( i , 22 ) ;
54748: LD_ADDR_VAR 0 2
54752: PUSH
54753: LD_VAR 0 3
54757: PPUSH
54758: LD_INT 22
54760: PPUSH
54761: CALL 48317 0 2
54765: ST_TO_ADDR
// if result then
54766: LD_VAR 0 2
54770: IFFALSE 54776
// exit ;
54772: POP
54773: POP
54774: GO 54780
// end ;
54776: GO 54745
54778: POP
54779: POP
// end ;
54780: LD_VAR 0 2
54784: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54785: LD_INT 0
54787: PPUSH
54788: PPUSH
// if not units then
54789: LD_VAR 0 1
54793: NOT
54794: IFFALSE 54798
// exit ;
54796: GO 54868
// result := [ ] ;
54798: LD_ADDR_VAR 0 3
54802: PUSH
54803: EMPTY
54804: ST_TO_ADDR
// for i in units do
54805: LD_ADDR_VAR 0 4
54809: PUSH
54810: LD_VAR 0 1
54814: PUSH
54815: FOR_IN
54816: IFFALSE 54866
// if GetTag ( i ) = tag then
54818: LD_VAR 0 4
54822: PPUSH
54823: CALL_OW 110
54827: PUSH
54828: LD_VAR 0 2
54832: EQUAL
54833: IFFALSE 54864
// result := Insert ( result , result + 1 , i ) ;
54835: LD_ADDR_VAR 0 3
54839: PUSH
54840: LD_VAR 0 3
54844: PPUSH
54845: LD_VAR 0 3
54849: PUSH
54850: LD_INT 1
54852: PLUS
54853: PPUSH
54854: LD_VAR 0 4
54858: PPUSH
54859: CALL_OW 2
54863: ST_TO_ADDR
54864: GO 54815
54866: POP
54867: POP
// end ;
54868: LD_VAR 0 3
54872: RET
// export function IsDriver ( un ) ; begin
54873: LD_INT 0
54875: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54876: LD_ADDR_VAR 0 2
54880: PUSH
54881: LD_VAR 0 1
54885: PUSH
54886: LD_INT 55
54888: PUSH
54889: EMPTY
54890: LIST
54891: PPUSH
54892: CALL_OW 69
54896: IN
54897: ST_TO_ADDR
// end ;
54898: LD_VAR 0 2
54902: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54903: LD_INT 0
54905: PPUSH
54906: PPUSH
// list := [ ] ;
54907: LD_ADDR_VAR 0 5
54911: PUSH
54912: EMPTY
54913: ST_TO_ADDR
// case d of 0 :
54914: LD_VAR 0 3
54918: PUSH
54919: LD_INT 0
54921: DOUBLE
54922: EQUAL
54923: IFTRUE 54927
54925: GO 55060
54927: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54928: LD_ADDR_VAR 0 5
54932: PUSH
54933: LD_VAR 0 1
54937: PUSH
54938: LD_INT 4
54940: MINUS
54941: PUSH
54942: LD_VAR 0 2
54946: PUSH
54947: LD_INT 4
54949: MINUS
54950: PUSH
54951: LD_INT 2
54953: PUSH
54954: EMPTY
54955: LIST
54956: LIST
54957: LIST
54958: PUSH
54959: LD_VAR 0 1
54963: PUSH
54964: LD_INT 3
54966: MINUS
54967: PUSH
54968: LD_VAR 0 2
54972: PUSH
54973: LD_INT 1
54975: PUSH
54976: EMPTY
54977: LIST
54978: LIST
54979: LIST
54980: PUSH
54981: LD_VAR 0 1
54985: PUSH
54986: LD_INT 4
54988: PLUS
54989: PUSH
54990: LD_VAR 0 2
54994: PUSH
54995: LD_INT 4
54997: PUSH
54998: EMPTY
54999: LIST
55000: LIST
55001: LIST
55002: PUSH
55003: LD_VAR 0 1
55007: PUSH
55008: LD_INT 3
55010: PLUS
55011: PUSH
55012: LD_VAR 0 2
55016: PUSH
55017: LD_INT 3
55019: PLUS
55020: PUSH
55021: LD_INT 5
55023: PUSH
55024: EMPTY
55025: LIST
55026: LIST
55027: LIST
55028: PUSH
55029: LD_VAR 0 1
55033: PUSH
55034: LD_VAR 0 2
55038: PUSH
55039: LD_INT 4
55041: PLUS
55042: PUSH
55043: LD_INT 0
55045: PUSH
55046: EMPTY
55047: LIST
55048: LIST
55049: LIST
55050: PUSH
55051: EMPTY
55052: LIST
55053: LIST
55054: LIST
55055: LIST
55056: LIST
55057: ST_TO_ADDR
// end ; 1 :
55058: GO 55758
55060: LD_INT 1
55062: DOUBLE
55063: EQUAL
55064: IFTRUE 55068
55066: GO 55201
55068: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55069: LD_ADDR_VAR 0 5
55073: PUSH
55074: LD_VAR 0 1
55078: PUSH
55079: LD_VAR 0 2
55083: PUSH
55084: LD_INT 4
55086: MINUS
55087: PUSH
55088: LD_INT 3
55090: PUSH
55091: EMPTY
55092: LIST
55093: LIST
55094: LIST
55095: PUSH
55096: LD_VAR 0 1
55100: PUSH
55101: LD_INT 3
55103: MINUS
55104: PUSH
55105: LD_VAR 0 2
55109: PUSH
55110: LD_INT 3
55112: MINUS
55113: PUSH
55114: LD_INT 2
55116: PUSH
55117: EMPTY
55118: LIST
55119: LIST
55120: LIST
55121: PUSH
55122: LD_VAR 0 1
55126: PUSH
55127: LD_INT 4
55129: MINUS
55130: PUSH
55131: LD_VAR 0 2
55135: PUSH
55136: LD_INT 1
55138: PUSH
55139: EMPTY
55140: LIST
55141: LIST
55142: LIST
55143: PUSH
55144: LD_VAR 0 1
55148: PUSH
55149: LD_VAR 0 2
55153: PUSH
55154: LD_INT 3
55156: PLUS
55157: PUSH
55158: LD_INT 0
55160: PUSH
55161: EMPTY
55162: LIST
55163: LIST
55164: LIST
55165: PUSH
55166: LD_VAR 0 1
55170: PUSH
55171: LD_INT 4
55173: PLUS
55174: PUSH
55175: LD_VAR 0 2
55179: PUSH
55180: LD_INT 4
55182: PLUS
55183: PUSH
55184: LD_INT 5
55186: PUSH
55187: EMPTY
55188: LIST
55189: LIST
55190: LIST
55191: PUSH
55192: EMPTY
55193: LIST
55194: LIST
55195: LIST
55196: LIST
55197: LIST
55198: ST_TO_ADDR
// end ; 2 :
55199: GO 55758
55201: LD_INT 2
55203: DOUBLE
55204: EQUAL
55205: IFTRUE 55209
55207: GO 55338
55209: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55210: LD_ADDR_VAR 0 5
55214: PUSH
55215: LD_VAR 0 1
55219: PUSH
55220: LD_VAR 0 2
55224: PUSH
55225: LD_INT 3
55227: MINUS
55228: PUSH
55229: LD_INT 3
55231: PUSH
55232: EMPTY
55233: LIST
55234: LIST
55235: LIST
55236: PUSH
55237: LD_VAR 0 1
55241: PUSH
55242: LD_INT 4
55244: PLUS
55245: PUSH
55246: LD_VAR 0 2
55250: PUSH
55251: LD_INT 4
55253: PUSH
55254: EMPTY
55255: LIST
55256: LIST
55257: LIST
55258: PUSH
55259: LD_VAR 0 1
55263: PUSH
55264: LD_VAR 0 2
55268: PUSH
55269: LD_INT 4
55271: PLUS
55272: PUSH
55273: LD_INT 0
55275: PUSH
55276: EMPTY
55277: LIST
55278: LIST
55279: LIST
55280: PUSH
55281: LD_VAR 0 1
55285: PUSH
55286: LD_INT 3
55288: MINUS
55289: PUSH
55290: LD_VAR 0 2
55294: PUSH
55295: LD_INT 1
55297: PUSH
55298: EMPTY
55299: LIST
55300: LIST
55301: LIST
55302: PUSH
55303: LD_VAR 0 1
55307: PUSH
55308: LD_INT 4
55310: MINUS
55311: PUSH
55312: LD_VAR 0 2
55316: PUSH
55317: LD_INT 4
55319: MINUS
55320: PUSH
55321: LD_INT 2
55323: PUSH
55324: EMPTY
55325: LIST
55326: LIST
55327: LIST
55328: PUSH
55329: EMPTY
55330: LIST
55331: LIST
55332: LIST
55333: LIST
55334: LIST
55335: ST_TO_ADDR
// end ; 3 :
55336: GO 55758
55338: LD_INT 3
55340: DOUBLE
55341: EQUAL
55342: IFTRUE 55346
55344: GO 55479
55346: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55347: LD_ADDR_VAR 0 5
55351: PUSH
55352: LD_VAR 0 1
55356: PUSH
55357: LD_INT 3
55359: PLUS
55360: PUSH
55361: LD_VAR 0 2
55365: PUSH
55366: LD_INT 4
55368: PUSH
55369: EMPTY
55370: LIST
55371: LIST
55372: LIST
55373: PUSH
55374: LD_VAR 0 1
55378: PUSH
55379: LD_INT 4
55381: PLUS
55382: PUSH
55383: LD_VAR 0 2
55387: PUSH
55388: LD_INT 4
55390: PLUS
55391: PUSH
55392: LD_INT 5
55394: PUSH
55395: EMPTY
55396: LIST
55397: LIST
55398: LIST
55399: PUSH
55400: LD_VAR 0 1
55404: PUSH
55405: LD_INT 4
55407: MINUS
55408: PUSH
55409: LD_VAR 0 2
55413: PUSH
55414: LD_INT 1
55416: PUSH
55417: EMPTY
55418: LIST
55419: LIST
55420: LIST
55421: PUSH
55422: LD_VAR 0 1
55426: PUSH
55427: LD_VAR 0 2
55431: PUSH
55432: LD_INT 4
55434: MINUS
55435: PUSH
55436: LD_INT 3
55438: PUSH
55439: EMPTY
55440: LIST
55441: LIST
55442: LIST
55443: PUSH
55444: LD_VAR 0 1
55448: PUSH
55449: LD_INT 3
55451: MINUS
55452: PUSH
55453: LD_VAR 0 2
55457: PUSH
55458: LD_INT 3
55460: MINUS
55461: PUSH
55462: LD_INT 2
55464: PUSH
55465: EMPTY
55466: LIST
55467: LIST
55468: LIST
55469: PUSH
55470: EMPTY
55471: LIST
55472: LIST
55473: LIST
55474: LIST
55475: LIST
55476: ST_TO_ADDR
// end ; 4 :
55477: GO 55758
55479: LD_INT 4
55481: DOUBLE
55482: EQUAL
55483: IFTRUE 55487
55485: GO 55620
55487: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55488: LD_ADDR_VAR 0 5
55492: PUSH
55493: LD_VAR 0 1
55497: PUSH
55498: LD_VAR 0 2
55502: PUSH
55503: LD_INT 4
55505: PLUS
55506: PUSH
55507: LD_INT 0
55509: PUSH
55510: EMPTY
55511: LIST
55512: LIST
55513: LIST
55514: PUSH
55515: LD_VAR 0 1
55519: PUSH
55520: LD_INT 3
55522: PLUS
55523: PUSH
55524: LD_VAR 0 2
55528: PUSH
55529: LD_INT 3
55531: PLUS
55532: PUSH
55533: LD_INT 5
55535: PUSH
55536: EMPTY
55537: LIST
55538: LIST
55539: LIST
55540: PUSH
55541: LD_VAR 0 1
55545: PUSH
55546: LD_INT 4
55548: PLUS
55549: PUSH
55550: LD_VAR 0 2
55554: PUSH
55555: LD_INT 4
55557: PUSH
55558: EMPTY
55559: LIST
55560: LIST
55561: LIST
55562: PUSH
55563: LD_VAR 0 1
55567: PUSH
55568: LD_VAR 0 2
55572: PUSH
55573: LD_INT 3
55575: MINUS
55576: PUSH
55577: LD_INT 3
55579: PUSH
55580: EMPTY
55581: LIST
55582: LIST
55583: LIST
55584: PUSH
55585: LD_VAR 0 1
55589: PUSH
55590: LD_INT 4
55592: MINUS
55593: PUSH
55594: LD_VAR 0 2
55598: PUSH
55599: LD_INT 4
55601: MINUS
55602: PUSH
55603: LD_INT 2
55605: PUSH
55606: EMPTY
55607: LIST
55608: LIST
55609: LIST
55610: PUSH
55611: EMPTY
55612: LIST
55613: LIST
55614: LIST
55615: LIST
55616: LIST
55617: ST_TO_ADDR
// end ; 5 :
55618: GO 55758
55620: LD_INT 5
55622: DOUBLE
55623: EQUAL
55624: IFTRUE 55628
55626: GO 55757
55628: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55629: LD_ADDR_VAR 0 5
55633: PUSH
55634: LD_VAR 0 1
55638: PUSH
55639: LD_INT 4
55641: MINUS
55642: PUSH
55643: LD_VAR 0 2
55647: PUSH
55648: LD_INT 1
55650: PUSH
55651: EMPTY
55652: LIST
55653: LIST
55654: LIST
55655: PUSH
55656: LD_VAR 0 1
55660: PUSH
55661: LD_VAR 0 2
55665: PUSH
55666: LD_INT 4
55668: MINUS
55669: PUSH
55670: LD_INT 3
55672: PUSH
55673: EMPTY
55674: LIST
55675: LIST
55676: LIST
55677: PUSH
55678: LD_VAR 0 1
55682: PUSH
55683: LD_INT 4
55685: PLUS
55686: PUSH
55687: LD_VAR 0 2
55691: PUSH
55692: LD_INT 4
55694: PLUS
55695: PUSH
55696: LD_INT 5
55698: PUSH
55699: EMPTY
55700: LIST
55701: LIST
55702: LIST
55703: PUSH
55704: LD_VAR 0 1
55708: PUSH
55709: LD_INT 3
55711: PLUS
55712: PUSH
55713: LD_VAR 0 2
55717: PUSH
55718: LD_INT 4
55720: PUSH
55721: EMPTY
55722: LIST
55723: LIST
55724: LIST
55725: PUSH
55726: LD_VAR 0 1
55730: PUSH
55731: LD_VAR 0 2
55735: PUSH
55736: LD_INT 3
55738: PLUS
55739: PUSH
55740: LD_INT 0
55742: PUSH
55743: EMPTY
55744: LIST
55745: LIST
55746: LIST
55747: PUSH
55748: EMPTY
55749: LIST
55750: LIST
55751: LIST
55752: LIST
55753: LIST
55754: ST_TO_ADDR
// end ; end ;
55755: GO 55758
55757: POP
// result := list ;
55758: LD_ADDR_VAR 0 4
55762: PUSH
55763: LD_VAR 0 5
55767: ST_TO_ADDR
// end ;
55768: LD_VAR 0 4
55772: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55773: LD_INT 0
55775: PPUSH
55776: PPUSH
55777: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55778: LD_VAR 0 1
55782: NOT
55783: PUSH
55784: LD_VAR 0 2
55788: PUSH
55789: LD_INT 1
55791: PUSH
55792: LD_INT 2
55794: PUSH
55795: LD_INT 3
55797: PUSH
55798: LD_INT 4
55800: PUSH
55801: EMPTY
55802: LIST
55803: LIST
55804: LIST
55805: LIST
55806: IN
55807: NOT
55808: OR
55809: IFFALSE 55813
// exit ;
55811: GO 55905
// tmp := [ ] ;
55813: LD_ADDR_VAR 0 5
55817: PUSH
55818: EMPTY
55819: ST_TO_ADDR
// for i in units do
55820: LD_ADDR_VAR 0 4
55824: PUSH
55825: LD_VAR 0 1
55829: PUSH
55830: FOR_IN
55831: IFFALSE 55874
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55833: LD_ADDR_VAR 0 5
55837: PUSH
55838: LD_VAR 0 5
55842: PPUSH
55843: LD_VAR 0 5
55847: PUSH
55848: LD_INT 1
55850: PLUS
55851: PPUSH
55852: LD_VAR 0 4
55856: PPUSH
55857: LD_VAR 0 2
55861: PPUSH
55862: CALL_OW 259
55866: PPUSH
55867: CALL_OW 2
55871: ST_TO_ADDR
55872: GO 55830
55874: POP
55875: POP
// if not tmp then
55876: LD_VAR 0 5
55880: NOT
55881: IFFALSE 55885
// exit ;
55883: GO 55905
// result := SortListByListDesc ( units , tmp ) ;
55885: LD_ADDR_VAR 0 3
55889: PUSH
55890: LD_VAR 0 1
55894: PPUSH
55895: LD_VAR 0 5
55899: PPUSH
55900: CALL_OW 77
55904: ST_TO_ADDR
// end ;
55905: LD_VAR 0 3
55909: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55910: LD_INT 0
55912: PPUSH
55913: PPUSH
55914: PPUSH
// x := GetX ( building ) ;
55915: LD_ADDR_VAR 0 4
55919: PUSH
55920: LD_VAR 0 2
55924: PPUSH
55925: CALL_OW 250
55929: ST_TO_ADDR
// y := GetY ( building ) ;
55930: LD_ADDR_VAR 0 5
55934: PUSH
55935: LD_VAR 0 2
55939: PPUSH
55940: CALL_OW 251
55944: ST_TO_ADDR
// if GetTaskList ( unit ) then
55945: LD_VAR 0 1
55949: PPUSH
55950: CALL_OW 437
55954: IFFALSE 56049
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55956: LD_STRING e
55958: PUSH
55959: LD_VAR 0 1
55963: PPUSH
55964: CALL_OW 437
55968: PUSH
55969: LD_INT 1
55971: ARRAY
55972: PUSH
55973: LD_INT 1
55975: ARRAY
55976: EQUAL
55977: PUSH
55978: LD_VAR 0 4
55982: PUSH
55983: LD_VAR 0 1
55987: PPUSH
55988: CALL_OW 437
55992: PUSH
55993: LD_INT 1
55995: ARRAY
55996: PUSH
55997: LD_INT 2
55999: ARRAY
56000: EQUAL
56001: AND
56002: PUSH
56003: LD_VAR 0 5
56007: PUSH
56008: LD_VAR 0 1
56012: PPUSH
56013: CALL_OW 437
56017: PUSH
56018: LD_INT 1
56020: ARRAY
56021: PUSH
56022: LD_INT 3
56024: ARRAY
56025: EQUAL
56026: AND
56027: IFFALSE 56039
// result := true else
56029: LD_ADDR_VAR 0 3
56033: PUSH
56034: LD_INT 1
56036: ST_TO_ADDR
56037: GO 56047
// result := false ;
56039: LD_ADDR_VAR 0 3
56043: PUSH
56044: LD_INT 0
56046: ST_TO_ADDR
// end else
56047: GO 56057
// result := false ;
56049: LD_ADDR_VAR 0 3
56053: PUSH
56054: LD_INT 0
56056: ST_TO_ADDR
// end ;
56057: LD_VAR 0 3
56061: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56062: LD_INT 0
56064: PPUSH
56065: PPUSH
56066: PPUSH
56067: PPUSH
// if not unit or not area then
56068: LD_VAR 0 1
56072: NOT
56073: PUSH
56074: LD_VAR 0 2
56078: NOT
56079: OR
56080: IFFALSE 56084
// exit ;
56082: GO 56248
// tmp := AreaToList ( area , i ) ;
56084: LD_ADDR_VAR 0 6
56088: PUSH
56089: LD_VAR 0 2
56093: PPUSH
56094: LD_VAR 0 5
56098: PPUSH
56099: CALL_OW 517
56103: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56104: LD_ADDR_VAR 0 5
56108: PUSH
56109: DOUBLE
56110: LD_INT 1
56112: DEC
56113: ST_TO_ADDR
56114: LD_VAR 0 6
56118: PUSH
56119: LD_INT 1
56121: ARRAY
56122: PUSH
56123: FOR_TO
56124: IFFALSE 56246
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56126: LD_ADDR_VAR 0 7
56130: PUSH
56131: LD_VAR 0 6
56135: PUSH
56136: LD_INT 1
56138: ARRAY
56139: PUSH
56140: LD_VAR 0 5
56144: ARRAY
56145: PUSH
56146: LD_VAR 0 6
56150: PUSH
56151: LD_INT 2
56153: ARRAY
56154: PUSH
56155: LD_VAR 0 5
56159: ARRAY
56160: PUSH
56161: EMPTY
56162: LIST
56163: LIST
56164: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56165: LD_VAR 0 7
56169: PUSH
56170: LD_INT 1
56172: ARRAY
56173: PPUSH
56174: LD_VAR 0 7
56178: PUSH
56179: LD_INT 2
56181: ARRAY
56182: PPUSH
56183: CALL_OW 428
56187: PUSH
56188: LD_INT 0
56190: EQUAL
56191: IFFALSE 56244
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56193: LD_VAR 0 1
56197: PPUSH
56198: LD_VAR 0 7
56202: PUSH
56203: LD_INT 1
56205: ARRAY
56206: PPUSH
56207: LD_VAR 0 7
56211: PUSH
56212: LD_INT 2
56214: ARRAY
56215: PPUSH
56216: LD_VAR 0 3
56220: PPUSH
56221: CALL_OW 48
// result := IsPlaced ( unit ) ;
56225: LD_ADDR_VAR 0 4
56229: PUSH
56230: LD_VAR 0 1
56234: PPUSH
56235: CALL_OW 305
56239: ST_TO_ADDR
// exit ;
56240: POP
56241: POP
56242: GO 56248
// end ; end ;
56244: GO 56123
56246: POP
56247: POP
// end ;
56248: LD_VAR 0 4
56252: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56253: LD_INT 0
56255: PPUSH
56256: PPUSH
56257: PPUSH
// if not side or side > 8 then
56258: LD_VAR 0 1
56262: NOT
56263: PUSH
56264: LD_VAR 0 1
56268: PUSH
56269: LD_INT 8
56271: GREATER
56272: OR
56273: IFFALSE 56277
// exit ;
56275: GO 56464
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56277: LD_ADDR_VAR 0 4
56281: PUSH
56282: LD_INT 22
56284: PUSH
56285: LD_VAR 0 1
56289: PUSH
56290: EMPTY
56291: LIST
56292: LIST
56293: PUSH
56294: LD_INT 21
56296: PUSH
56297: LD_INT 3
56299: PUSH
56300: EMPTY
56301: LIST
56302: LIST
56303: PUSH
56304: EMPTY
56305: LIST
56306: LIST
56307: PPUSH
56308: CALL_OW 69
56312: ST_TO_ADDR
// if not tmp then
56313: LD_VAR 0 4
56317: NOT
56318: IFFALSE 56322
// exit ;
56320: GO 56464
// enable_addtolog := true ;
56322: LD_ADDR_OWVAR 81
56326: PUSH
56327: LD_INT 1
56329: ST_TO_ADDR
// AddToLog ( [ ) ;
56330: LD_STRING [
56332: PPUSH
56333: CALL_OW 561
// for i in tmp do
56337: LD_ADDR_VAR 0 3
56341: PUSH
56342: LD_VAR 0 4
56346: PUSH
56347: FOR_IN
56348: IFFALSE 56455
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56350: LD_STRING [
56352: PUSH
56353: LD_VAR 0 3
56357: PPUSH
56358: CALL_OW 266
56362: STR
56363: PUSH
56364: LD_STRING , 
56366: STR
56367: PUSH
56368: LD_VAR 0 3
56372: PPUSH
56373: CALL_OW 250
56377: STR
56378: PUSH
56379: LD_STRING , 
56381: STR
56382: PUSH
56383: LD_VAR 0 3
56387: PPUSH
56388: CALL_OW 251
56392: STR
56393: PUSH
56394: LD_STRING , 
56396: STR
56397: PUSH
56398: LD_VAR 0 3
56402: PPUSH
56403: CALL_OW 254
56407: STR
56408: PUSH
56409: LD_STRING , 
56411: STR
56412: PUSH
56413: LD_VAR 0 3
56417: PPUSH
56418: LD_INT 1
56420: PPUSH
56421: CALL_OW 268
56425: STR
56426: PUSH
56427: LD_STRING , 
56429: STR
56430: PUSH
56431: LD_VAR 0 3
56435: PPUSH
56436: LD_INT 2
56438: PPUSH
56439: CALL_OW 268
56443: STR
56444: PUSH
56445: LD_STRING ],
56447: STR
56448: PPUSH
56449: CALL_OW 561
// end ;
56453: GO 56347
56455: POP
56456: POP
// AddToLog ( ]; ) ;
56457: LD_STRING ];
56459: PPUSH
56460: CALL_OW 561
// end ;
56464: LD_VAR 0 2
56468: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56469: LD_INT 0
56471: PPUSH
56472: PPUSH
56473: PPUSH
56474: PPUSH
56475: PPUSH
// if not area or not rate or not max then
56476: LD_VAR 0 1
56480: NOT
56481: PUSH
56482: LD_VAR 0 2
56486: NOT
56487: OR
56488: PUSH
56489: LD_VAR 0 4
56493: NOT
56494: OR
56495: IFFALSE 56499
// exit ;
56497: GO 56691
// while 1 do
56499: LD_INT 1
56501: IFFALSE 56691
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56503: LD_ADDR_VAR 0 9
56507: PUSH
56508: LD_VAR 0 1
56512: PPUSH
56513: LD_INT 1
56515: PPUSH
56516: CALL_OW 287
56520: PUSH
56521: LD_INT 10
56523: MUL
56524: ST_TO_ADDR
// r := rate / 10 ;
56525: LD_ADDR_VAR 0 7
56529: PUSH
56530: LD_VAR 0 2
56534: PUSH
56535: LD_INT 10
56537: DIVREAL
56538: ST_TO_ADDR
// time := 1 1$00 ;
56539: LD_ADDR_VAR 0 8
56543: PUSH
56544: LD_INT 2100
56546: ST_TO_ADDR
// if amount < min then
56547: LD_VAR 0 9
56551: PUSH
56552: LD_VAR 0 3
56556: LESS
56557: IFFALSE 56575
// r := r * 2 else
56559: LD_ADDR_VAR 0 7
56563: PUSH
56564: LD_VAR 0 7
56568: PUSH
56569: LD_INT 2
56571: MUL
56572: ST_TO_ADDR
56573: GO 56601
// if amount > max then
56575: LD_VAR 0 9
56579: PUSH
56580: LD_VAR 0 4
56584: GREATER
56585: IFFALSE 56601
// r := r / 2 ;
56587: LD_ADDR_VAR 0 7
56591: PUSH
56592: LD_VAR 0 7
56596: PUSH
56597: LD_INT 2
56599: DIVREAL
56600: ST_TO_ADDR
// time := time / r ;
56601: LD_ADDR_VAR 0 8
56605: PUSH
56606: LD_VAR 0 8
56610: PUSH
56611: LD_VAR 0 7
56615: DIVREAL
56616: ST_TO_ADDR
// if time < 0 then
56617: LD_VAR 0 8
56621: PUSH
56622: LD_INT 0
56624: LESS
56625: IFFALSE 56642
// time := time * - 1 ;
56627: LD_ADDR_VAR 0 8
56631: PUSH
56632: LD_VAR 0 8
56636: PUSH
56637: LD_INT 1
56639: NEG
56640: MUL
56641: ST_TO_ADDR
// wait ( time ) ;
56642: LD_VAR 0 8
56646: PPUSH
56647: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56651: LD_INT 35
56653: PPUSH
56654: LD_INT 875
56656: PPUSH
56657: CALL_OW 12
56661: PPUSH
56662: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56666: LD_INT 1
56668: PPUSH
56669: LD_INT 5
56671: PPUSH
56672: CALL_OW 12
56676: PPUSH
56677: LD_VAR 0 1
56681: PPUSH
56682: LD_INT 1
56684: PPUSH
56685: CALL_OW 55
// end ;
56689: GO 56499
// end ;
56691: LD_VAR 0 5
56695: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56696: LD_INT 0
56698: PPUSH
56699: PPUSH
56700: PPUSH
56701: PPUSH
56702: PPUSH
56703: PPUSH
56704: PPUSH
56705: PPUSH
// if not turrets or not factories then
56706: LD_VAR 0 1
56710: NOT
56711: PUSH
56712: LD_VAR 0 2
56716: NOT
56717: OR
56718: IFFALSE 56722
// exit ;
56720: GO 57029
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56722: LD_ADDR_VAR 0 10
56726: PUSH
56727: LD_INT 5
56729: PUSH
56730: LD_INT 6
56732: PUSH
56733: EMPTY
56734: LIST
56735: LIST
56736: PUSH
56737: LD_INT 2
56739: PUSH
56740: LD_INT 4
56742: PUSH
56743: EMPTY
56744: LIST
56745: LIST
56746: PUSH
56747: LD_INT 3
56749: PUSH
56750: LD_INT 5
56752: PUSH
56753: EMPTY
56754: LIST
56755: LIST
56756: PUSH
56757: EMPTY
56758: LIST
56759: LIST
56760: LIST
56761: PUSH
56762: LD_INT 24
56764: PUSH
56765: LD_INT 25
56767: PUSH
56768: EMPTY
56769: LIST
56770: LIST
56771: PUSH
56772: LD_INT 23
56774: PUSH
56775: LD_INT 27
56777: PUSH
56778: EMPTY
56779: LIST
56780: LIST
56781: PUSH
56782: EMPTY
56783: LIST
56784: LIST
56785: PUSH
56786: LD_INT 42
56788: PUSH
56789: LD_INT 43
56791: PUSH
56792: EMPTY
56793: LIST
56794: LIST
56795: PUSH
56796: LD_INT 44
56798: PUSH
56799: LD_INT 46
56801: PUSH
56802: EMPTY
56803: LIST
56804: LIST
56805: PUSH
56806: LD_INT 45
56808: PUSH
56809: LD_INT 47
56811: PUSH
56812: EMPTY
56813: LIST
56814: LIST
56815: PUSH
56816: EMPTY
56817: LIST
56818: LIST
56819: LIST
56820: PUSH
56821: EMPTY
56822: LIST
56823: LIST
56824: LIST
56825: ST_TO_ADDR
// result := [ ] ;
56826: LD_ADDR_VAR 0 3
56830: PUSH
56831: EMPTY
56832: ST_TO_ADDR
// for i in turrets do
56833: LD_ADDR_VAR 0 4
56837: PUSH
56838: LD_VAR 0 1
56842: PUSH
56843: FOR_IN
56844: IFFALSE 57027
// begin nat := GetNation ( i ) ;
56846: LD_ADDR_VAR 0 7
56850: PUSH
56851: LD_VAR 0 4
56855: PPUSH
56856: CALL_OW 248
56860: ST_TO_ADDR
// weapon := 0 ;
56861: LD_ADDR_VAR 0 8
56865: PUSH
56866: LD_INT 0
56868: ST_TO_ADDR
// if not nat then
56869: LD_VAR 0 7
56873: NOT
56874: IFFALSE 56878
// continue ;
56876: GO 56843
// for j in list [ nat ] do
56878: LD_ADDR_VAR 0 5
56882: PUSH
56883: LD_VAR 0 10
56887: PUSH
56888: LD_VAR 0 7
56892: ARRAY
56893: PUSH
56894: FOR_IN
56895: IFFALSE 56936
// if GetBWeapon ( i ) = j [ 1 ] then
56897: LD_VAR 0 4
56901: PPUSH
56902: CALL_OW 269
56906: PUSH
56907: LD_VAR 0 5
56911: PUSH
56912: LD_INT 1
56914: ARRAY
56915: EQUAL
56916: IFFALSE 56934
// begin weapon := j [ 2 ] ;
56918: LD_ADDR_VAR 0 8
56922: PUSH
56923: LD_VAR 0 5
56927: PUSH
56928: LD_INT 2
56930: ARRAY
56931: ST_TO_ADDR
// break ;
56932: GO 56936
// end ;
56934: GO 56894
56936: POP
56937: POP
// if not weapon then
56938: LD_VAR 0 8
56942: NOT
56943: IFFALSE 56947
// continue ;
56945: GO 56843
// for k in factories do
56947: LD_ADDR_VAR 0 6
56951: PUSH
56952: LD_VAR 0 2
56956: PUSH
56957: FOR_IN
56958: IFFALSE 57023
// begin weapons := AvailableWeaponList ( k ) ;
56960: LD_ADDR_VAR 0 9
56964: PUSH
56965: LD_VAR 0 6
56969: PPUSH
56970: CALL_OW 478
56974: ST_TO_ADDR
// if not weapons then
56975: LD_VAR 0 9
56979: NOT
56980: IFFALSE 56984
// continue ;
56982: GO 56957
// if weapon in weapons then
56984: LD_VAR 0 8
56988: PUSH
56989: LD_VAR 0 9
56993: IN
56994: IFFALSE 57021
// begin result := [ i , weapon ] ;
56996: LD_ADDR_VAR 0 3
57000: PUSH
57001: LD_VAR 0 4
57005: PUSH
57006: LD_VAR 0 8
57010: PUSH
57011: EMPTY
57012: LIST
57013: LIST
57014: ST_TO_ADDR
// exit ;
57015: POP
57016: POP
57017: POP
57018: POP
57019: GO 57029
// end ; end ;
57021: GO 56957
57023: POP
57024: POP
// end ;
57025: GO 56843
57027: POP
57028: POP
// end ;
57029: LD_VAR 0 3
57033: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57034: LD_INT 0
57036: PPUSH
// if not side or side > 8 then
57037: LD_VAR 0 3
57041: NOT
57042: PUSH
57043: LD_VAR 0 3
57047: PUSH
57048: LD_INT 8
57050: GREATER
57051: OR
57052: IFFALSE 57056
// exit ;
57054: GO 57115
// if not range then
57056: LD_VAR 0 4
57060: NOT
57061: IFFALSE 57072
// range := - 12 ;
57063: LD_ADDR_VAR 0 4
57067: PUSH
57068: LD_INT 12
57070: NEG
57071: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57072: LD_VAR 0 1
57076: PPUSH
57077: LD_VAR 0 2
57081: PPUSH
57082: LD_VAR 0 3
57086: PPUSH
57087: LD_VAR 0 4
57091: PPUSH
57092: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57096: LD_VAR 0 1
57100: PPUSH
57101: LD_VAR 0 2
57105: PPUSH
57106: LD_VAR 0 3
57110: PPUSH
57111: CALL_OW 331
// end ;
57115: LD_VAR 0 5
57119: RET
// export function Video ( mode ) ; begin
57120: LD_INT 0
57122: PPUSH
// ingame_video = mode ;
57123: LD_ADDR_OWVAR 52
57127: PUSH
57128: LD_VAR 0 1
57132: ST_TO_ADDR
// interface_hidden = mode ;
57133: LD_ADDR_OWVAR 54
57137: PUSH
57138: LD_VAR 0 1
57142: ST_TO_ADDR
// end ;
57143: LD_VAR 0 2
57147: RET
// export function Join ( array , element ) ; begin
57148: LD_INT 0
57150: PPUSH
// result := array ^ element ;
57151: LD_ADDR_VAR 0 3
57155: PUSH
57156: LD_VAR 0 1
57160: PUSH
57161: LD_VAR 0 2
57165: ADD
57166: ST_TO_ADDR
// end ;
57167: LD_VAR 0 3
57171: RET
// export function JoinUnion ( array , element ) ; begin
57172: LD_INT 0
57174: PPUSH
// result := array union element ;
57175: LD_ADDR_VAR 0 3
57179: PUSH
57180: LD_VAR 0 1
57184: PUSH
57185: LD_VAR 0 2
57189: UNION
57190: ST_TO_ADDR
// end ;
57191: LD_VAR 0 3
57195: RET
// export function GetBehemoths ( side ) ; begin
57196: LD_INT 0
57198: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
57199: LD_ADDR_VAR 0 2
57203: PUSH
57204: LD_INT 22
57206: PUSH
57207: LD_VAR 0 1
57211: PUSH
57212: EMPTY
57213: LIST
57214: LIST
57215: PUSH
57216: LD_INT 31
57218: PUSH
57219: LD_INT 25
57221: PUSH
57222: EMPTY
57223: LIST
57224: LIST
57225: PUSH
57226: EMPTY
57227: LIST
57228: LIST
57229: PPUSH
57230: CALL_OW 69
57234: ST_TO_ADDR
// end ;
57235: LD_VAR 0 2
57239: RET
// export function Shuffle ( array ) ; var i , index ; begin
57240: LD_INT 0
57242: PPUSH
57243: PPUSH
57244: PPUSH
// result := [ ] ;
57245: LD_ADDR_VAR 0 2
57249: PUSH
57250: EMPTY
57251: ST_TO_ADDR
// if not array then
57252: LD_VAR 0 1
57256: NOT
57257: IFFALSE 57261
// exit ;
57259: GO 57360
// Randomize ;
57261: CALL_OW 10
// for i = array downto 1 do
57265: LD_ADDR_VAR 0 3
57269: PUSH
57270: DOUBLE
57271: LD_VAR 0 1
57275: INC
57276: ST_TO_ADDR
57277: LD_INT 1
57279: PUSH
57280: FOR_DOWNTO
57281: IFFALSE 57358
// begin index := rand ( 1 , array ) ;
57283: LD_ADDR_VAR 0 4
57287: PUSH
57288: LD_INT 1
57290: PPUSH
57291: LD_VAR 0 1
57295: PPUSH
57296: CALL_OW 12
57300: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57301: LD_ADDR_VAR 0 2
57305: PUSH
57306: LD_VAR 0 2
57310: PPUSH
57311: LD_VAR 0 2
57315: PUSH
57316: LD_INT 1
57318: PLUS
57319: PPUSH
57320: LD_VAR 0 1
57324: PUSH
57325: LD_VAR 0 4
57329: ARRAY
57330: PPUSH
57331: CALL_OW 2
57335: ST_TO_ADDR
// array := Delete ( array , index ) ;
57336: LD_ADDR_VAR 0 1
57340: PUSH
57341: LD_VAR 0 1
57345: PPUSH
57346: LD_VAR 0 4
57350: PPUSH
57351: CALL_OW 3
57355: ST_TO_ADDR
// end ;
57356: GO 57280
57358: POP
57359: POP
// end ;
57360: LD_VAR 0 2
57364: RET
// export function GetBaseMaterials ( base ) ; begin
57365: LD_INT 0
57367: PPUSH
// result := [ 0 , 0 , 0 ] ;
57368: LD_ADDR_VAR 0 2
57372: PUSH
57373: LD_INT 0
57375: PUSH
57376: LD_INT 0
57378: PUSH
57379: LD_INT 0
57381: PUSH
57382: EMPTY
57383: LIST
57384: LIST
57385: LIST
57386: ST_TO_ADDR
// if not base then
57387: LD_VAR 0 1
57391: NOT
57392: IFFALSE 57396
// exit ;
57394: GO 57445
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57396: LD_ADDR_VAR 0 2
57400: PUSH
57401: LD_VAR 0 1
57405: PPUSH
57406: LD_INT 1
57408: PPUSH
57409: CALL_OW 275
57413: PUSH
57414: LD_VAR 0 1
57418: PPUSH
57419: LD_INT 2
57421: PPUSH
57422: CALL_OW 275
57426: PUSH
57427: LD_VAR 0 1
57431: PPUSH
57432: LD_INT 3
57434: PPUSH
57435: CALL_OW 275
57439: PUSH
57440: EMPTY
57441: LIST
57442: LIST
57443: LIST
57444: ST_TO_ADDR
// end ; end_of_file
57445: LD_VAR 0 2
57449: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
57450: LD_INT 0
57452: PPUSH
57453: PPUSH
// skirmish := false ;
57454: LD_ADDR_EXP 57
57458: PUSH
57459: LD_INT 0
57461: ST_TO_ADDR
// debug_mc := false ;
57462: LD_ADDR_EXP 58
57466: PUSH
57467: LD_INT 0
57469: ST_TO_ADDR
// mc_bases := [ ] ;
57470: LD_ADDR_EXP 59
57474: PUSH
57475: EMPTY
57476: ST_TO_ADDR
// mc_sides := [ ] ;
57477: LD_ADDR_EXP 85
57481: PUSH
57482: EMPTY
57483: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57484: LD_ADDR_EXP 60
57488: PUSH
57489: EMPTY
57490: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57491: LD_ADDR_EXP 61
57495: PUSH
57496: EMPTY
57497: ST_TO_ADDR
// mc_need_heal := [ ] ;
57498: LD_ADDR_EXP 62
57502: PUSH
57503: EMPTY
57504: ST_TO_ADDR
// mc_healers := [ ] ;
57505: LD_ADDR_EXP 63
57509: PUSH
57510: EMPTY
57511: ST_TO_ADDR
// mc_build_list := [ ] ;
57512: LD_ADDR_EXP 64
57516: PUSH
57517: EMPTY
57518: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57519: LD_ADDR_EXP 91
57523: PUSH
57524: EMPTY
57525: ST_TO_ADDR
// mc_builders := [ ] ;
57526: LD_ADDR_EXP 65
57530: PUSH
57531: EMPTY
57532: ST_TO_ADDR
// mc_construct_list := [ ] ;
57533: LD_ADDR_EXP 66
57537: PUSH
57538: EMPTY
57539: ST_TO_ADDR
// mc_turret_list := [ ] ;
57540: LD_ADDR_EXP 67
57544: PUSH
57545: EMPTY
57546: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57547: LD_ADDR_EXP 68
57551: PUSH
57552: EMPTY
57553: ST_TO_ADDR
// mc_miners := [ ] ;
57554: LD_ADDR_EXP 73
57558: PUSH
57559: EMPTY
57560: ST_TO_ADDR
// mc_mines := [ ] ;
57561: LD_ADDR_EXP 72
57565: PUSH
57566: EMPTY
57567: ST_TO_ADDR
// mc_minefields := [ ] ;
57568: LD_ADDR_EXP 74
57572: PUSH
57573: EMPTY
57574: ST_TO_ADDR
// mc_crates := [ ] ;
57575: LD_ADDR_EXP 75
57579: PUSH
57580: EMPTY
57581: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57582: LD_ADDR_EXP 76
57586: PUSH
57587: EMPTY
57588: ST_TO_ADDR
// mc_crates_area := [ ] ;
57589: LD_ADDR_EXP 77
57593: PUSH
57594: EMPTY
57595: ST_TO_ADDR
// mc_vehicles := [ ] ;
57596: LD_ADDR_EXP 78
57600: PUSH
57601: EMPTY
57602: ST_TO_ADDR
// mc_attack := [ ] ;
57603: LD_ADDR_EXP 79
57607: PUSH
57608: EMPTY
57609: ST_TO_ADDR
// mc_produce := [ ] ;
57610: LD_ADDR_EXP 80
57614: PUSH
57615: EMPTY
57616: ST_TO_ADDR
// mc_defender := [ ] ;
57617: LD_ADDR_EXP 81
57621: PUSH
57622: EMPTY
57623: ST_TO_ADDR
// mc_parking := [ ] ;
57624: LD_ADDR_EXP 83
57628: PUSH
57629: EMPTY
57630: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57631: LD_ADDR_EXP 69
57635: PUSH
57636: EMPTY
57637: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57638: LD_ADDR_EXP 71
57642: PUSH
57643: EMPTY
57644: ST_TO_ADDR
// mc_scan := [ ] ;
57645: LD_ADDR_EXP 82
57649: PUSH
57650: EMPTY
57651: ST_TO_ADDR
// mc_scan_area := [ ] ;
57652: LD_ADDR_EXP 84
57656: PUSH
57657: EMPTY
57658: ST_TO_ADDR
// mc_tech := [ ] ;
57659: LD_ADDR_EXP 86
57663: PUSH
57664: EMPTY
57665: ST_TO_ADDR
// mc_class := [ ] ;
57666: LD_ADDR_EXP 100
57670: PUSH
57671: EMPTY
57672: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57673: LD_ADDR_EXP 101
57677: PUSH
57678: EMPTY
57679: ST_TO_ADDR
// end ;
57680: LD_VAR 0 1
57684: RET
// export function MC_Kill ( base ) ; begin
57685: LD_INT 0
57687: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57688: LD_ADDR_EXP 59
57692: PUSH
57693: LD_EXP 59
57697: PPUSH
57698: LD_VAR 0 1
57702: PPUSH
57703: EMPTY
57704: PPUSH
57705: CALL_OW 1
57709: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57710: LD_ADDR_EXP 60
57714: PUSH
57715: LD_EXP 60
57719: PPUSH
57720: LD_VAR 0 1
57724: PPUSH
57725: EMPTY
57726: PPUSH
57727: CALL_OW 1
57731: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57732: LD_ADDR_EXP 61
57736: PUSH
57737: LD_EXP 61
57741: PPUSH
57742: LD_VAR 0 1
57746: PPUSH
57747: EMPTY
57748: PPUSH
57749: CALL_OW 1
57753: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57754: LD_ADDR_EXP 62
57758: PUSH
57759: LD_EXP 62
57763: PPUSH
57764: LD_VAR 0 1
57768: PPUSH
57769: EMPTY
57770: PPUSH
57771: CALL_OW 1
57775: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57776: LD_ADDR_EXP 63
57780: PUSH
57781: LD_EXP 63
57785: PPUSH
57786: LD_VAR 0 1
57790: PPUSH
57791: EMPTY
57792: PPUSH
57793: CALL_OW 1
57797: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57798: LD_ADDR_EXP 64
57802: PUSH
57803: LD_EXP 64
57807: PPUSH
57808: LD_VAR 0 1
57812: PPUSH
57813: EMPTY
57814: PPUSH
57815: CALL_OW 1
57819: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57820: LD_ADDR_EXP 65
57824: PUSH
57825: LD_EXP 65
57829: PPUSH
57830: LD_VAR 0 1
57834: PPUSH
57835: EMPTY
57836: PPUSH
57837: CALL_OW 1
57841: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57842: LD_ADDR_EXP 66
57846: PUSH
57847: LD_EXP 66
57851: PPUSH
57852: LD_VAR 0 1
57856: PPUSH
57857: EMPTY
57858: PPUSH
57859: CALL_OW 1
57863: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57864: LD_ADDR_EXP 67
57868: PUSH
57869: LD_EXP 67
57873: PPUSH
57874: LD_VAR 0 1
57878: PPUSH
57879: EMPTY
57880: PPUSH
57881: CALL_OW 1
57885: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57886: LD_ADDR_EXP 68
57890: PUSH
57891: LD_EXP 68
57895: PPUSH
57896: LD_VAR 0 1
57900: PPUSH
57901: EMPTY
57902: PPUSH
57903: CALL_OW 1
57907: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57908: LD_ADDR_EXP 69
57912: PUSH
57913: LD_EXP 69
57917: PPUSH
57918: LD_VAR 0 1
57922: PPUSH
57923: EMPTY
57924: PPUSH
57925: CALL_OW 1
57929: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57930: LD_ADDR_EXP 70
57934: PUSH
57935: LD_EXP 70
57939: PPUSH
57940: LD_VAR 0 1
57944: PPUSH
57945: LD_INT 0
57947: PPUSH
57948: CALL_OW 1
57952: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57953: LD_ADDR_EXP 71
57957: PUSH
57958: LD_EXP 71
57962: PPUSH
57963: LD_VAR 0 1
57967: PPUSH
57968: EMPTY
57969: PPUSH
57970: CALL_OW 1
57974: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57975: LD_ADDR_EXP 72
57979: PUSH
57980: LD_EXP 72
57984: PPUSH
57985: LD_VAR 0 1
57989: PPUSH
57990: EMPTY
57991: PPUSH
57992: CALL_OW 1
57996: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57997: LD_ADDR_EXP 73
58001: PUSH
58002: LD_EXP 73
58006: PPUSH
58007: LD_VAR 0 1
58011: PPUSH
58012: EMPTY
58013: PPUSH
58014: CALL_OW 1
58018: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58019: LD_ADDR_EXP 74
58023: PUSH
58024: LD_EXP 74
58028: PPUSH
58029: LD_VAR 0 1
58033: PPUSH
58034: EMPTY
58035: PPUSH
58036: CALL_OW 1
58040: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58041: LD_ADDR_EXP 75
58045: PUSH
58046: LD_EXP 75
58050: PPUSH
58051: LD_VAR 0 1
58055: PPUSH
58056: EMPTY
58057: PPUSH
58058: CALL_OW 1
58062: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58063: LD_ADDR_EXP 76
58067: PUSH
58068: LD_EXP 76
58072: PPUSH
58073: LD_VAR 0 1
58077: PPUSH
58078: EMPTY
58079: PPUSH
58080: CALL_OW 1
58084: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58085: LD_ADDR_EXP 77
58089: PUSH
58090: LD_EXP 77
58094: PPUSH
58095: LD_VAR 0 1
58099: PPUSH
58100: EMPTY
58101: PPUSH
58102: CALL_OW 1
58106: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58107: LD_ADDR_EXP 78
58111: PUSH
58112: LD_EXP 78
58116: PPUSH
58117: LD_VAR 0 1
58121: PPUSH
58122: EMPTY
58123: PPUSH
58124: CALL_OW 1
58128: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58129: LD_ADDR_EXP 79
58133: PUSH
58134: LD_EXP 79
58138: PPUSH
58139: LD_VAR 0 1
58143: PPUSH
58144: EMPTY
58145: PPUSH
58146: CALL_OW 1
58150: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58151: LD_ADDR_EXP 80
58155: PUSH
58156: LD_EXP 80
58160: PPUSH
58161: LD_VAR 0 1
58165: PPUSH
58166: EMPTY
58167: PPUSH
58168: CALL_OW 1
58172: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58173: LD_ADDR_EXP 81
58177: PUSH
58178: LD_EXP 81
58182: PPUSH
58183: LD_VAR 0 1
58187: PPUSH
58188: EMPTY
58189: PPUSH
58190: CALL_OW 1
58194: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58195: LD_ADDR_EXP 82
58199: PUSH
58200: LD_EXP 82
58204: PPUSH
58205: LD_VAR 0 1
58209: PPUSH
58210: EMPTY
58211: PPUSH
58212: CALL_OW 1
58216: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58217: LD_ADDR_EXP 83
58221: PUSH
58222: LD_EXP 83
58226: PPUSH
58227: LD_VAR 0 1
58231: PPUSH
58232: EMPTY
58233: PPUSH
58234: CALL_OW 1
58238: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58239: LD_ADDR_EXP 84
58243: PUSH
58244: LD_EXP 84
58248: PPUSH
58249: LD_VAR 0 1
58253: PPUSH
58254: EMPTY
58255: PPUSH
58256: CALL_OW 1
58260: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58261: LD_ADDR_EXP 86
58265: PUSH
58266: LD_EXP 86
58270: PPUSH
58271: LD_VAR 0 1
58275: PPUSH
58276: EMPTY
58277: PPUSH
58278: CALL_OW 1
58282: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58283: LD_ADDR_EXP 88
58287: PUSH
58288: LD_EXP 88
58292: PPUSH
58293: LD_VAR 0 1
58297: PPUSH
58298: EMPTY
58299: PPUSH
58300: CALL_OW 1
58304: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58305: LD_ADDR_EXP 89
58309: PUSH
58310: LD_EXP 89
58314: PPUSH
58315: LD_VAR 0 1
58319: PPUSH
58320: EMPTY
58321: PPUSH
58322: CALL_OW 1
58326: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58327: LD_ADDR_EXP 90
58331: PUSH
58332: LD_EXP 90
58336: PPUSH
58337: LD_VAR 0 1
58341: PPUSH
58342: EMPTY
58343: PPUSH
58344: CALL_OW 1
58348: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58349: LD_ADDR_EXP 91
58353: PUSH
58354: LD_EXP 91
58358: PPUSH
58359: LD_VAR 0 1
58363: PPUSH
58364: EMPTY
58365: PPUSH
58366: CALL_OW 1
58370: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58371: LD_ADDR_EXP 92
58375: PUSH
58376: LD_EXP 92
58380: PPUSH
58381: LD_VAR 0 1
58385: PPUSH
58386: EMPTY
58387: PPUSH
58388: CALL_OW 1
58392: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58393: LD_ADDR_EXP 93
58397: PUSH
58398: LD_EXP 93
58402: PPUSH
58403: LD_VAR 0 1
58407: PPUSH
58408: EMPTY
58409: PPUSH
58410: CALL_OW 1
58414: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58415: LD_ADDR_EXP 94
58419: PUSH
58420: LD_EXP 94
58424: PPUSH
58425: LD_VAR 0 1
58429: PPUSH
58430: EMPTY
58431: PPUSH
58432: CALL_OW 1
58436: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58437: LD_ADDR_EXP 95
58441: PUSH
58442: LD_EXP 95
58446: PPUSH
58447: LD_VAR 0 1
58451: PPUSH
58452: EMPTY
58453: PPUSH
58454: CALL_OW 1
58458: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58459: LD_ADDR_EXP 96
58463: PUSH
58464: LD_EXP 96
58468: PPUSH
58469: LD_VAR 0 1
58473: PPUSH
58474: EMPTY
58475: PPUSH
58476: CALL_OW 1
58480: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58481: LD_ADDR_EXP 97
58485: PUSH
58486: LD_EXP 97
58490: PPUSH
58491: LD_VAR 0 1
58495: PPUSH
58496: EMPTY
58497: PPUSH
58498: CALL_OW 1
58502: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58503: LD_ADDR_EXP 98
58507: PUSH
58508: LD_EXP 98
58512: PPUSH
58513: LD_VAR 0 1
58517: PPUSH
58518: EMPTY
58519: PPUSH
58520: CALL_OW 1
58524: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58525: LD_ADDR_EXP 99
58529: PUSH
58530: LD_EXP 99
58534: PPUSH
58535: LD_VAR 0 1
58539: PPUSH
58540: EMPTY
58541: PPUSH
58542: CALL_OW 1
58546: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58547: LD_ADDR_EXP 100
58551: PUSH
58552: LD_EXP 100
58556: PPUSH
58557: LD_VAR 0 1
58561: PPUSH
58562: EMPTY
58563: PPUSH
58564: CALL_OW 1
58568: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58569: LD_ADDR_EXP 101
58573: PUSH
58574: LD_EXP 101
58578: PPUSH
58579: LD_VAR 0 1
58583: PPUSH
58584: LD_INT 0
58586: PPUSH
58587: CALL_OW 1
58591: ST_TO_ADDR
// end ;
58592: LD_VAR 0 2
58596: RET
// export function MC_Add ( side , units ) ; var base ; begin
58597: LD_INT 0
58599: PPUSH
58600: PPUSH
// base := mc_bases + 1 ;
58601: LD_ADDR_VAR 0 4
58605: PUSH
58606: LD_EXP 59
58610: PUSH
58611: LD_INT 1
58613: PLUS
58614: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58615: LD_ADDR_EXP 85
58619: PUSH
58620: LD_EXP 85
58624: PPUSH
58625: LD_VAR 0 4
58629: PPUSH
58630: LD_VAR 0 1
58634: PPUSH
58635: CALL_OW 1
58639: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58640: LD_ADDR_EXP 59
58644: PUSH
58645: LD_EXP 59
58649: PPUSH
58650: LD_VAR 0 4
58654: PPUSH
58655: LD_VAR 0 2
58659: PPUSH
58660: CALL_OW 1
58664: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58665: LD_ADDR_EXP 60
58669: PUSH
58670: LD_EXP 60
58674: PPUSH
58675: LD_VAR 0 4
58679: PPUSH
58680: EMPTY
58681: PPUSH
58682: CALL_OW 1
58686: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58687: LD_ADDR_EXP 61
58691: PUSH
58692: LD_EXP 61
58696: PPUSH
58697: LD_VAR 0 4
58701: PPUSH
58702: EMPTY
58703: PPUSH
58704: CALL_OW 1
58708: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58709: LD_ADDR_EXP 62
58713: PUSH
58714: LD_EXP 62
58718: PPUSH
58719: LD_VAR 0 4
58723: PPUSH
58724: EMPTY
58725: PPUSH
58726: CALL_OW 1
58730: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58731: LD_ADDR_EXP 63
58735: PUSH
58736: LD_EXP 63
58740: PPUSH
58741: LD_VAR 0 4
58745: PPUSH
58746: EMPTY
58747: PPUSH
58748: CALL_OW 1
58752: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58753: LD_ADDR_EXP 64
58757: PUSH
58758: LD_EXP 64
58762: PPUSH
58763: LD_VAR 0 4
58767: PPUSH
58768: EMPTY
58769: PPUSH
58770: CALL_OW 1
58774: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58775: LD_ADDR_EXP 65
58779: PUSH
58780: LD_EXP 65
58784: PPUSH
58785: LD_VAR 0 4
58789: PPUSH
58790: EMPTY
58791: PPUSH
58792: CALL_OW 1
58796: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58797: LD_ADDR_EXP 66
58801: PUSH
58802: LD_EXP 66
58806: PPUSH
58807: LD_VAR 0 4
58811: PPUSH
58812: EMPTY
58813: PPUSH
58814: CALL_OW 1
58818: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58819: LD_ADDR_EXP 67
58823: PUSH
58824: LD_EXP 67
58828: PPUSH
58829: LD_VAR 0 4
58833: PPUSH
58834: EMPTY
58835: PPUSH
58836: CALL_OW 1
58840: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58841: LD_ADDR_EXP 68
58845: PUSH
58846: LD_EXP 68
58850: PPUSH
58851: LD_VAR 0 4
58855: PPUSH
58856: EMPTY
58857: PPUSH
58858: CALL_OW 1
58862: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58863: LD_ADDR_EXP 69
58867: PUSH
58868: LD_EXP 69
58872: PPUSH
58873: LD_VAR 0 4
58877: PPUSH
58878: EMPTY
58879: PPUSH
58880: CALL_OW 1
58884: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58885: LD_ADDR_EXP 70
58889: PUSH
58890: LD_EXP 70
58894: PPUSH
58895: LD_VAR 0 4
58899: PPUSH
58900: LD_INT 0
58902: PPUSH
58903: CALL_OW 1
58907: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58908: LD_ADDR_EXP 71
58912: PUSH
58913: LD_EXP 71
58917: PPUSH
58918: LD_VAR 0 4
58922: PPUSH
58923: EMPTY
58924: PPUSH
58925: CALL_OW 1
58929: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58930: LD_ADDR_EXP 72
58934: PUSH
58935: LD_EXP 72
58939: PPUSH
58940: LD_VAR 0 4
58944: PPUSH
58945: EMPTY
58946: PPUSH
58947: CALL_OW 1
58951: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58952: LD_ADDR_EXP 73
58956: PUSH
58957: LD_EXP 73
58961: PPUSH
58962: LD_VAR 0 4
58966: PPUSH
58967: EMPTY
58968: PPUSH
58969: CALL_OW 1
58973: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58974: LD_ADDR_EXP 74
58978: PUSH
58979: LD_EXP 74
58983: PPUSH
58984: LD_VAR 0 4
58988: PPUSH
58989: EMPTY
58990: PPUSH
58991: CALL_OW 1
58995: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58996: LD_ADDR_EXP 75
59000: PUSH
59001: LD_EXP 75
59005: PPUSH
59006: LD_VAR 0 4
59010: PPUSH
59011: EMPTY
59012: PPUSH
59013: CALL_OW 1
59017: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59018: LD_ADDR_EXP 76
59022: PUSH
59023: LD_EXP 76
59027: PPUSH
59028: LD_VAR 0 4
59032: PPUSH
59033: EMPTY
59034: PPUSH
59035: CALL_OW 1
59039: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59040: LD_ADDR_EXP 77
59044: PUSH
59045: LD_EXP 77
59049: PPUSH
59050: LD_VAR 0 4
59054: PPUSH
59055: EMPTY
59056: PPUSH
59057: CALL_OW 1
59061: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59062: LD_ADDR_EXP 78
59066: PUSH
59067: LD_EXP 78
59071: PPUSH
59072: LD_VAR 0 4
59076: PPUSH
59077: EMPTY
59078: PPUSH
59079: CALL_OW 1
59083: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59084: LD_ADDR_EXP 79
59088: PUSH
59089: LD_EXP 79
59093: PPUSH
59094: LD_VAR 0 4
59098: PPUSH
59099: EMPTY
59100: PPUSH
59101: CALL_OW 1
59105: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59106: LD_ADDR_EXP 80
59110: PUSH
59111: LD_EXP 80
59115: PPUSH
59116: LD_VAR 0 4
59120: PPUSH
59121: EMPTY
59122: PPUSH
59123: CALL_OW 1
59127: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59128: LD_ADDR_EXP 81
59132: PUSH
59133: LD_EXP 81
59137: PPUSH
59138: LD_VAR 0 4
59142: PPUSH
59143: EMPTY
59144: PPUSH
59145: CALL_OW 1
59149: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59150: LD_ADDR_EXP 82
59154: PUSH
59155: LD_EXP 82
59159: PPUSH
59160: LD_VAR 0 4
59164: PPUSH
59165: EMPTY
59166: PPUSH
59167: CALL_OW 1
59171: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59172: LD_ADDR_EXP 83
59176: PUSH
59177: LD_EXP 83
59181: PPUSH
59182: LD_VAR 0 4
59186: PPUSH
59187: EMPTY
59188: PPUSH
59189: CALL_OW 1
59193: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
59194: LD_ADDR_EXP 84
59198: PUSH
59199: LD_EXP 84
59203: PPUSH
59204: LD_VAR 0 4
59208: PPUSH
59209: EMPTY
59210: PPUSH
59211: CALL_OW 1
59215: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59216: LD_ADDR_EXP 86
59220: PUSH
59221: LD_EXP 86
59225: PPUSH
59226: LD_VAR 0 4
59230: PPUSH
59231: EMPTY
59232: PPUSH
59233: CALL_OW 1
59237: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
59238: LD_ADDR_EXP 88
59242: PUSH
59243: LD_EXP 88
59247: PPUSH
59248: LD_VAR 0 4
59252: PPUSH
59253: EMPTY
59254: PPUSH
59255: CALL_OW 1
59259: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59260: LD_ADDR_EXP 89
59264: PUSH
59265: LD_EXP 89
59269: PPUSH
59270: LD_VAR 0 4
59274: PPUSH
59275: EMPTY
59276: PPUSH
59277: CALL_OW 1
59281: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59282: LD_ADDR_EXP 90
59286: PUSH
59287: LD_EXP 90
59291: PPUSH
59292: LD_VAR 0 4
59296: PPUSH
59297: EMPTY
59298: PPUSH
59299: CALL_OW 1
59303: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59304: LD_ADDR_EXP 91
59308: PUSH
59309: LD_EXP 91
59313: PPUSH
59314: LD_VAR 0 4
59318: PPUSH
59319: EMPTY
59320: PPUSH
59321: CALL_OW 1
59325: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59326: LD_ADDR_EXP 92
59330: PUSH
59331: LD_EXP 92
59335: PPUSH
59336: LD_VAR 0 4
59340: PPUSH
59341: EMPTY
59342: PPUSH
59343: CALL_OW 1
59347: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59348: LD_ADDR_EXP 93
59352: PUSH
59353: LD_EXP 93
59357: PPUSH
59358: LD_VAR 0 4
59362: PPUSH
59363: EMPTY
59364: PPUSH
59365: CALL_OW 1
59369: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59370: LD_ADDR_EXP 94
59374: PUSH
59375: LD_EXP 94
59379: PPUSH
59380: LD_VAR 0 4
59384: PPUSH
59385: EMPTY
59386: PPUSH
59387: CALL_OW 1
59391: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59392: LD_ADDR_EXP 95
59396: PUSH
59397: LD_EXP 95
59401: PPUSH
59402: LD_VAR 0 4
59406: PPUSH
59407: EMPTY
59408: PPUSH
59409: CALL_OW 1
59413: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59414: LD_ADDR_EXP 96
59418: PUSH
59419: LD_EXP 96
59423: PPUSH
59424: LD_VAR 0 4
59428: PPUSH
59429: EMPTY
59430: PPUSH
59431: CALL_OW 1
59435: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59436: LD_ADDR_EXP 97
59440: PUSH
59441: LD_EXP 97
59445: PPUSH
59446: LD_VAR 0 4
59450: PPUSH
59451: EMPTY
59452: PPUSH
59453: CALL_OW 1
59457: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59458: LD_ADDR_EXP 98
59462: PUSH
59463: LD_EXP 98
59467: PPUSH
59468: LD_VAR 0 4
59472: PPUSH
59473: EMPTY
59474: PPUSH
59475: CALL_OW 1
59479: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59480: LD_ADDR_EXP 99
59484: PUSH
59485: LD_EXP 99
59489: PPUSH
59490: LD_VAR 0 4
59494: PPUSH
59495: EMPTY
59496: PPUSH
59497: CALL_OW 1
59501: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59502: LD_ADDR_EXP 100
59506: PUSH
59507: LD_EXP 100
59511: PPUSH
59512: LD_VAR 0 4
59516: PPUSH
59517: EMPTY
59518: PPUSH
59519: CALL_OW 1
59523: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59524: LD_ADDR_EXP 101
59528: PUSH
59529: LD_EXP 101
59533: PPUSH
59534: LD_VAR 0 4
59538: PPUSH
59539: LD_INT 0
59541: PPUSH
59542: CALL_OW 1
59546: ST_TO_ADDR
// result := base ;
59547: LD_ADDR_VAR 0 3
59551: PUSH
59552: LD_VAR 0 4
59556: ST_TO_ADDR
// end ;
59557: LD_VAR 0 3
59561: RET
// export function MC_Start ( ) ; var i ; begin
59562: LD_INT 0
59564: PPUSH
59565: PPUSH
// for i = 1 to mc_bases do
59566: LD_ADDR_VAR 0 2
59570: PUSH
59571: DOUBLE
59572: LD_INT 1
59574: DEC
59575: ST_TO_ADDR
59576: LD_EXP 59
59580: PUSH
59581: FOR_TO
59582: IFFALSE 60659
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59584: LD_ADDR_EXP 59
59588: PUSH
59589: LD_EXP 59
59593: PPUSH
59594: LD_VAR 0 2
59598: PPUSH
59599: LD_EXP 59
59603: PUSH
59604: LD_VAR 0 2
59608: ARRAY
59609: PUSH
59610: LD_INT 0
59612: DIFF
59613: PPUSH
59614: CALL_OW 1
59618: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59619: LD_ADDR_EXP 60
59623: PUSH
59624: LD_EXP 60
59628: PPUSH
59629: LD_VAR 0 2
59633: PPUSH
59634: EMPTY
59635: PPUSH
59636: CALL_OW 1
59640: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59641: LD_ADDR_EXP 61
59645: PUSH
59646: LD_EXP 61
59650: PPUSH
59651: LD_VAR 0 2
59655: PPUSH
59656: EMPTY
59657: PPUSH
59658: CALL_OW 1
59662: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59663: LD_ADDR_EXP 62
59667: PUSH
59668: LD_EXP 62
59672: PPUSH
59673: LD_VAR 0 2
59677: PPUSH
59678: EMPTY
59679: PPUSH
59680: CALL_OW 1
59684: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59685: LD_ADDR_EXP 63
59689: PUSH
59690: LD_EXP 63
59694: PPUSH
59695: LD_VAR 0 2
59699: PPUSH
59700: EMPTY
59701: PUSH
59702: EMPTY
59703: PUSH
59704: EMPTY
59705: LIST
59706: LIST
59707: PPUSH
59708: CALL_OW 1
59712: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59713: LD_ADDR_EXP 64
59717: PUSH
59718: LD_EXP 64
59722: PPUSH
59723: LD_VAR 0 2
59727: PPUSH
59728: EMPTY
59729: PPUSH
59730: CALL_OW 1
59734: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59735: LD_ADDR_EXP 91
59739: PUSH
59740: LD_EXP 91
59744: PPUSH
59745: LD_VAR 0 2
59749: PPUSH
59750: EMPTY
59751: PPUSH
59752: CALL_OW 1
59756: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59757: LD_ADDR_EXP 65
59761: PUSH
59762: LD_EXP 65
59766: PPUSH
59767: LD_VAR 0 2
59771: PPUSH
59772: EMPTY
59773: PPUSH
59774: CALL_OW 1
59778: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59779: LD_ADDR_EXP 66
59783: PUSH
59784: LD_EXP 66
59788: PPUSH
59789: LD_VAR 0 2
59793: PPUSH
59794: EMPTY
59795: PPUSH
59796: CALL_OW 1
59800: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59801: LD_ADDR_EXP 67
59805: PUSH
59806: LD_EXP 67
59810: PPUSH
59811: LD_VAR 0 2
59815: PPUSH
59816: LD_EXP 59
59820: PUSH
59821: LD_VAR 0 2
59825: ARRAY
59826: PPUSH
59827: LD_INT 2
59829: PUSH
59830: LD_INT 30
59832: PUSH
59833: LD_INT 32
59835: PUSH
59836: EMPTY
59837: LIST
59838: LIST
59839: PUSH
59840: LD_INT 30
59842: PUSH
59843: LD_INT 33
59845: PUSH
59846: EMPTY
59847: LIST
59848: LIST
59849: PUSH
59850: EMPTY
59851: LIST
59852: LIST
59853: LIST
59854: PPUSH
59855: CALL_OW 72
59859: PPUSH
59860: CALL_OW 1
59864: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59865: LD_ADDR_EXP 68
59869: PUSH
59870: LD_EXP 68
59874: PPUSH
59875: LD_VAR 0 2
59879: PPUSH
59880: LD_EXP 59
59884: PUSH
59885: LD_VAR 0 2
59889: ARRAY
59890: PPUSH
59891: LD_INT 2
59893: PUSH
59894: LD_INT 30
59896: PUSH
59897: LD_INT 32
59899: PUSH
59900: EMPTY
59901: LIST
59902: LIST
59903: PUSH
59904: LD_INT 30
59906: PUSH
59907: LD_INT 31
59909: PUSH
59910: EMPTY
59911: LIST
59912: LIST
59913: PUSH
59914: EMPTY
59915: LIST
59916: LIST
59917: LIST
59918: PUSH
59919: LD_INT 58
59921: PUSH
59922: EMPTY
59923: LIST
59924: PUSH
59925: EMPTY
59926: LIST
59927: LIST
59928: PPUSH
59929: CALL_OW 72
59933: PPUSH
59934: CALL_OW 1
59938: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59939: LD_ADDR_EXP 69
59943: PUSH
59944: LD_EXP 69
59948: PPUSH
59949: LD_VAR 0 2
59953: PPUSH
59954: EMPTY
59955: PPUSH
59956: CALL_OW 1
59960: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59961: LD_ADDR_EXP 73
59965: PUSH
59966: LD_EXP 73
59970: PPUSH
59971: LD_VAR 0 2
59975: PPUSH
59976: EMPTY
59977: PPUSH
59978: CALL_OW 1
59982: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59983: LD_ADDR_EXP 72
59987: PUSH
59988: LD_EXP 72
59992: PPUSH
59993: LD_VAR 0 2
59997: PPUSH
59998: EMPTY
59999: PPUSH
60000: CALL_OW 1
60004: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
60005: LD_ADDR_EXP 74
60009: PUSH
60010: LD_EXP 74
60014: PPUSH
60015: LD_VAR 0 2
60019: PPUSH
60020: EMPTY
60021: PPUSH
60022: CALL_OW 1
60026: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
60027: LD_ADDR_EXP 75
60031: PUSH
60032: LD_EXP 75
60036: PPUSH
60037: LD_VAR 0 2
60041: PPUSH
60042: EMPTY
60043: PPUSH
60044: CALL_OW 1
60048: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60049: LD_ADDR_EXP 76
60053: PUSH
60054: LD_EXP 76
60058: PPUSH
60059: LD_VAR 0 2
60063: PPUSH
60064: EMPTY
60065: PPUSH
60066: CALL_OW 1
60070: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
60071: LD_ADDR_EXP 77
60075: PUSH
60076: LD_EXP 77
60080: PPUSH
60081: LD_VAR 0 2
60085: PPUSH
60086: EMPTY
60087: PPUSH
60088: CALL_OW 1
60092: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
60093: LD_ADDR_EXP 78
60097: PUSH
60098: LD_EXP 78
60102: PPUSH
60103: LD_VAR 0 2
60107: PPUSH
60108: EMPTY
60109: PPUSH
60110: CALL_OW 1
60114: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
60115: LD_ADDR_EXP 79
60119: PUSH
60120: LD_EXP 79
60124: PPUSH
60125: LD_VAR 0 2
60129: PPUSH
60130: EMPTY
60131: PPUSH
60132: CALL_OW 1
60136: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
60137: LD_ADDR_EXP 80
60141: PUSH
60142: LD_EXP 80
60146: PPUSH
60147: LD_VAR 0 2
60151: PPUSH
60152: EMPTY
60153: PPUSH
60154: CALL_OW 1
60158: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
60159: LD_ADDR_EXP 81
60163: PUSH
60164: LD_EXP 81
60168: PPUSH
60169: LD_VAR 0 2
60173: PPUSH
60174: EMPTY
60175: PPUSH
60176: CALL_OW 1
60180: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
60181: LD_ADDR_EXP 70
60185: PUSH
60186: LD_EXP 70
60190: PPUSH
60191: LD_VAR 0 2
60195: PPUSH
60196: LD_INT 0
60198: PPUSH
60199: CALL_OW 1
60203: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
60204: LD_ADDR_EXP 83
60208: PUSH
60209: LD_EXP 83
60213: PPUSH
60214: LD_VAR 0 2
60218: PPUSH
60219: LD_INT 0
60221: PPUSH
60222: CALL_OW 1
60226: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
60227: LD_ADDR_EXP 71
60231: PUSH
60232: LD_EXP 71
60236: PPUSH
60237: LD_VAR 0 2
60241: PPUSH
60242: EMPTY
60243: PPUSH
60244: CALL_OW 1
60248: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
60249: LD_ADDR_EXP 82
60253: PUSH
60254: LD_EXP 82
60258: PPUSH
60259: LD_VAR 0 2
60263: PPUSH
60264: LD_INT 0
60266: PPUSH
60267: CALL_OW 1
60271: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
60272: LD_ADDR_EXP 84
60276: PUSH
60277: LD_EXP 84
60281: PPUSH
60282: LD_VAR 0 2
60286: PPUSH
60287: EMPTY
60288: PPUSH
60289: CALL_OW 1
60293: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
60294: LD_ADDR_EXP 87
60298: PUSH
60299: LD_EXP 87
60303: PPUSH
60304: LD_VAR 0 2
60308: PPUSH
60309: LD_INT 0
60311: PPUSH
60312: CALL_OW 1
60316: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
60317: LD_ADDR_EXP 88
60321: PUSH
60322: LD_EXP 88
60326: PPUSH
60327: LD_VAR 0 2
60331: PPUSH
60332: EMPTY
60333: PPUSH
60334: CALL_OW 1
60338: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60339: LD_ADDR_EXP 89
60343: PUSH
60344: LD_EXP 89
60348: PPUSH
60349: LD_VAR 0 2
60353: PPUSH
60354: EMPTY
60355: PPUSH
60356: CALL_OW 1
60360: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60361: LD_ADDR_EXP 90
60365: PUSH
60366: LD_EXP 90
60370: PPUSH
60371: LD_VAR 0 2
60375: PPUSH
60376: EMPTY
60377: PPUSH
60378: CALL_OW 1
60382: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60383: LD_ADDR_EXP 92
60387: PUSH
60388: LD_EXP 92
60392: PPUSH
60393: LD_VAR 0 2
60397: PPUSH
60398: LD_EXP 59
60402: PUSH
60403: LD_VAR 0 2
60407: ARRAY
60408: PPUSH
60409: LD_INT 2
60411: PUSH
60412: LD_INT 30
60414: PUSH
60415: LD_INT 6
60417: PUSH
60418: EMPTY
60419: LIST
60420: LIST
60421: PUSH
60422: LD_INT 30
60424: PUSH
60425: LD_INT 7
60427: PUSH
60428: EMPTY
60429: LIST
60430: LIST
60431: PUSH
60432: LD_INT 30
60434: PUSH
60435: LD_INT 8
60437: PUSH
60438: EMPTY
60439: LIST
60440: LIST
60441: PUSH
60442: EMPTY
60443: LIST
60444: LIST
60445: LIST
60446: LIST
60447: PPUSH
60448: CALL_OW 72
60452: PPUSH
60453: CALL_OW 1
60457: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60458: LD_ADDR_EXP 93
60462: PUSH
60463: LD_EXP 93
60467: PPUSH
60468: LD_VAR 0 2
60472: PPUSH
60473: EMPTY
60474: PPUSH
60475: CALL_OW 1
60479: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60480: LD_ADDR_EXP 94
60484: PUSH
60485: LD_EXP 94
60489: PPUSH
60490: LD_VAR 0 2
60494: PPUSH
60495: EMPTY
60496: PPUSH
60497: CALL_OW 1
60501: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60502: LD_ADDR_EXP 95
60506: PUSH
60507: LD_EXP 95
60511: PPUSH
60512: LD_VAR 0 2
60516: PPUSH
60517: EMPTY
60518: PPUSH
60519: CALL_OW 1
60523: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60524: LD_ADDR_EXP 96
60528: PUSH
60529: LD_EXP 96
60533: PPUSH
60534: LD_VAR 0 2
60538: PPUSH
60539: EMPTY
60540: PPUSH
60541: CALL_OW 1
60545: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60546: LD_ADDR_EXP 97
60550: PUSH
60551: LD_EXP 97
60555: PPUSH
60556: LD_VAR 0 2
60560: PPUSH
60561: EMPTY
60562: PPUSH
60563: CALL_OW 1
60567: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60568: LD_ADDR_EXP 98
60572: PUSH
60573: LD_EXP 98
60577: PPUSH
60578: LD_VAR 0 2
60582: PPUSH
60583: EMPTY
60584: PPUSH
60585: CALL_OW 1
60589: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60590: LD_ADDR_EXP 99
60594: PUSH
60595: LD_EXP 99
60599: PPUSH
60600: LD_VAR 0 2
60604: PPUSH
60605: EMPTY
60606: PPUSH
60607: CALL_OW 1
60611: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60612: LD_ADDR_EXP 100
60616: PUSH
60617: LD_EXP 100
60621: PPUSH
60622: LD_VAR 0 2
60626: PPUSH
60627: EMPTY
60628: PPUSH
60629: CALL_OW 1
60633: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60634: LD_ADDR_EXP 101
60638: PUSH
60639: LD_EXP 101
60643: PPUSH
60644: LD_VAR 0 2
60648: PPUSH
60649: LD_INT 0
60651: PPUSH
60652: CALL_OW 1
60656: ST_TO_ADDR
// end ;
60657: GO 59581
60659: POP
60660: POP
// MC_InitSides ( ) ;
60661: CALL 60947 0 0
// MC_InitResearch ( ) ;
60665: CALL 60686 0 0
// CustomInitMacro ( ) ;
60669: CALL 185 0 0
// skirmish := true ;
60673: LD_ADDR_EXP 57
60677: PUSH
60678: LD_INT 1
60680: ST_TO_ADDR
// end ;
60681: LD_VAR 0 1
60685: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60686: LD_INT 0
60688: PPUSH
60689: PPUSH
60690: PPUSH
60691: PPUSH
60692: PPUSH
60693: PPUSH
// if not mc_bases then
60694: LD_EXP 59
60698: NOT
60699: IFFALSE 60703
// exit ;
60701: GO 60942
// for i = 1 to 8 do
60703: LD_ADDR_VAR 0 2
60707: PUSH
60708: DOUBLE
60709: LD_INT 1
60711: DEC
60712: ST_TO_ADDR
60713: LD_INT 8
60715: PUSH
60716: FOR_TO
60717: IFFALSE 60743
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60719: LD_ADDR_EXP 86
60723: PUSH
60724: LD_EXP 86
60728: PPUSH
60729: LD_VAR 0 2
60733: PPUSH
60734: EMPTY
60735: PPUSH
60736: CALL_OW 1
60740: ST_TO_ADDR
60741: GO 60716
60743: POP
60744: POP
// tmp := [ ] ;
60745: LD_ADDR_VAR 0 5
60749: PUSH
60750: EMPTY
60751: ST_TO_ADDR
// for i = 1 to mc_sides do
60752: LD_ADDR_VAR 0 2
60756: PUSH
60757: DOUBLE
60758: LD_INT 1
60760: DEC
60761: ST_TO_ADDR
60762: LD_EXP 85
60766: PUSH
60767: FOR_TO
60768: IFFALSE 60826
// if not mc_sides [ i ] in tmp then
60770: LD_EXP 85
60774: PUSH
60775: LD_VAR 0 2
60779: ARRAY
60780: PUSH
60781: LD_VAR 0 5
60785: IN
60786: NOT
60787: IFFALSE 60824
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60789: LD_ADDR_VAR 0 5
60793: PUSH
60794: LD_VAR 0 5
60798: PPUSH
60799: LD_VAR 0 5
60803: PUSH
60804: LD_INT 1
60806: PLUS
60807: PPUSH
60808: LD_EXP 85
60812: PUSH
60813: LD_VAR 0 2
60817: ARRAY
60818: PPUSH
60819: CALL_OW 2
60823: ST_TO_ADDR
60824: GO 60767
60826: POP
60827: POP
// if not tmp then
60828: LD_VAR 0 5
60832: NOT
60833: IFFALSE 60837
// exit ;
60835: GO 60942
// for j in tmp do
60837: LD_ADDR_VAR 0 3
60841: PUSH
60842: LD_VAR 0 5
60846: PUSH
60847: FOR_IN
60848: IFFALSE 60940
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60850: LD_ADDR_VAR 0 6
60854: PUSH
60855: LD_INT 22
60857: PUSH
60858: LD_VAR 0 3
60862: PUSH
60863: EMPTY
60864: LIST
60865: LIST
60866: PPUSH
60867: CALL_OW 69
60871: ST_TO_ADDR
// if not un then
60872: LD_VAR 0 6
60876: NOT
60877: IFFALSE 60881
// continue ;
60879: GO 60847
// nation := GetNation ( un [ 1 ] ) ;
60881: LD_ADDR_VAR 0 4
60885: PUSH
60886: LD_VAR 0 6
60890: PUSH
60891: LD_INT 1
60893: ARRAY
60894: PPUSH
60895: CALL_OW 248
60899: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60900: LD_ADDR_EXP 86
60904: PUSH
60905: LD_EXP 86
60909: PPUSH
60910: LD_VAR 0 3
60914: PPUSH
60915: LD_VAR 0 3
60919: PPUSH
60920: LD_VAR 0 4
60924: PPUSH
60925: LD_INT 1
60927: PPUSH
60928: CALL 14351 0 3
60932: PPUSH
60933: CALL_OW 1
60937: ST_TO_ADDR
// end ;
60938: GO 60847
60940: POP
60941: POP
// end ;
60942: LD_VAR 0 1
60946: RET
// export function MC_InitSides ( ) ; var i ; begin
60947: LD_INT 0
60949: PPUSH
60950: PPUSH
// if not mc_bases then
60951: LD_EXP 59
60955: NOT
60956: IFFALSE 60960
// exit ;
60958: GO 61034
// for i = 1 to mc_bases do
60960: LD_ADDR_VAR 0 2
60964: PUSH
60965: DOUBLE
60966: LD_INT 1
60968: DEC
60969: ST_TO_ADDR
60970: LD_EXP 59
60974: PUSH
60975: FOR_TO
60976: IFFALSE 61032
// if mc_bases [ i ] then
60978: LD_EXP 59
60982: PUSH
60983: LD_VAR 0 2
60987: ARRAY
60988: IFFALSE 61030
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60990: LD_ADDR_EXP 85
60994: PUSH
60995: LD_EXP 85
60999: PPUSH
61000: LD_VAR 0 2
61004: PPUSH
61005: LD_EXP 59
61009: PUSH
61010: LD_VAR 0 2
61014: ARRAY
61015: PUSH
61016: LD_INT 1
61018: ARRAY
61019: PPUSH
61020: CALL_OW 255
61024: PPUSH
61025: CALL_OW 1
61029: ST_TO_ADDR
61030: GO 60975
61032: POP
61033: POP
// end ;
61034: LD_VAR 0 1
61038: RET
// every 0 0$01 trigger skirmish do
61039: LD_EXP 57
61043: IFFALSE 61197
61045: GO 61047
61047: DISABLE
// begin enable ;
61048: ENABLE
// MC_CheckBuildings ( ) ;
61049: CALL 65695 0 0
// MC_CheckPeopleLife ( ) ;
61053: CALL 65820 0 0
// RaiseSailEvent ( 100 ) ;
61057: LD_INT 100
61059: PPUSH
61060: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
61064: LD_INT 103
61066: PPUSH
61067: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
61071: LD_INT 104
61073: PPUSH
61074: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
61078: LD_INT 105
61080: PPUSH
61081: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
61085: LD_INT 106
61087: PPUSH
61088: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
61092: LD_INT 107
61094: PPUSH
61095: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
61099: LD_INT 108
61101: PPUSH
61102: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
61106: LD_INT 109
61108: PPUSH
61109: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
61113: LD_INT 110
61115: PPUSH
61116: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
61120: LD_INT 111
61122: PPUSH
61123: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
61127: LD_INT 112
61129: PPUSH
61130: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
61134: LD_INT 113
61136: PPUSH
61137: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
61141: LD_INT 120
61143: PPUSH
61144: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
61148: LD_INT 121
61150: PPUSH
61151: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
61155: LD_INT 122
61157: PPUSH
61158: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
61162: LD_INT 123
61164: PPUSH
61165: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
61169: LD_INT 124
61171: PPUSH
61172: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
61176: LD_INT 125
61178: PPUSH
61179: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
61183: LD_INT 126
61185: PPUSH
61186: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
61190: LD_INT 200
61192: PPUSH
61193: CALL_OW 427
// end ;
61197: END
// on SailEvent ( event ) do begin if event < 100 then
61198: LD_VAR 0 1
61202: PUSH
61203: LD_INT 100
61205: LESS
61206: IFFALSE 61217
// CustomEvent ( event ) ;
61208: LD_VAR 0 1
61212: PPUSH
61213: CALL 13009 0 1
// if event = 100 then
61217: LD_VAR 0 1
61221: PUSH
61222: LD_INT 100
61224: EQUAL
61225: IFFALSE 61231
// MC_ClassManager ( ) ;
61227: CALL 61623 0 0
// if event = 101 then
61231: LD_VAR 0 1
61235: PUSH
61236: LD_INT 101
61238: EQUAL
61239: IFFALSE 61245
// MC_RepairBuildings ( ) ;
61241: CALL 66416 0 0
// if event = 102 then
61245: LD_VAR 0 1
61249: PUSH
61250: LD_INT 102
61252: EQUAL
61253: IFFALSE 61259
// MC_Heal ( ) ;
61255: CALL 67148 0 0
// if event = 103 then
61259: LD_VAR 0 1
61263: PUSH
61264: LD_INT 103
61266: EQUAL
61267: IFFALSE 61273
// MC_Build ( ) ;
61269: CALL 67570 0 0
// if event = 104 then
61273: LD_VAR 0 1
61277: PUSH
61278: LD_INT 104
61280: EQUAL
61281: IFFALSE 61287
// MC_TurretWeapon ( ) ;
61283: CALL 69183 0 0
// if event = 105 then
61287: LD_VAR 0 1
61291: PUSH
61292: LD_INT 105
61294: EQUAL
61295: IFFALSE 61301
// MC_BuildUpgrade ( ) ;
61297: CALL 68734 0 0
// if event = 106 then
61301: LD_VAR 0 1
61305: PUSH
61306: LD_INT 106
61308: EQUAL
61309: IFFALSE 61315
// MC_PlantMines ( ) ;
61311: CALL 69613 0 0
// if event = 107 then
61315: LD_VAR 0 1
61319: PUSH
61320: LD_INT 107
61322: EQUAL
61323: IFFALSE 61329
// MC_CollectCrates ( ) ;
61325: CALL 70647 0 0
// if event = 108 then
61329: LD_VAR 0 1
61333: PUSH
61334: LD_INT 108
61336: EQUAL
61337: IFFALSE 61343
// MC_LinkRemoteControl ( ) ;
61339: CALL 72423 0 0
// if event = 109 then
61343: LD_VAR 0 1
61347: PUSH
61348: LD_INT 109
61350: EQUAL
61351: IFFALSE 61357
// MC_ProduceVehicle ( ) ;
61353: CALL 72604 0 0
// if event = 110 then
61357: LD_VAR 0 1
61361: PUSH
61362: LD_INT 110
61364: EQUAL
61365: IFFALSE 61371
// MC_SendAttack ( ) ;
61367: CALL 73070 0 0
// if event = 111 then
61371: LD_VAR 0 1
61375: PUSH
61376: LD_INT 111
61378: EQUAL
61379: IFFALSE 61385
// MC_Defend ( ) ;
61381: CALL 73178 0 0
// if event = 112 then
61385: LD_VAR 0 1
61389: PUSH
61390: LD_INT 112
61392: EQUAL
61393: IFFALSE 61399
// MC_Research ( ) ;
61395: CALL 73783 0 0
// if event = 113 then
61399: LD_VAR 0 1
61403: PUSH
61404: LD_INT 113
61406: EQUAL
61407: IFFALSE 61413
// MC_MinesTrigger ( ) ;
61409: CALL 74897 0 0
// if event = 120 then
61413: LD_VAR 0 1
61417: PUSH
61418: LD_INT 120
61420: EQUAL
61421: IFFALSE 61427
// MC_RepairVehicle ( ) ;
61423: CALL 74996 0 0
// if event = 121 then
61427: LD_VAR 0 1
61431: PUSH
61432: LD_INT 121
61434: EQUAL
61435: IFFALSE 61441
// MC_TameApe ( ) ;
61437: CALL 75726 0 0
// if event = 122 then
61441: LD_VAR 0 1
61445: PUSH
61446: LD_INT 122
61448: EQUAL
61449: IFFALSE 61455
// MC_ChangeApeClass ( ) ;
61451: CALL 76555 0 0
// if event = 123 then
61455: LD_VAR 0 1
61459: PUSH
61460: LD_INT 123
61462: EQUAL
61463: IFFALSE 61469
// MC_Bazooka ( ) ;
61465: CALL 77205 0 0
// if event = 124 then
61469: LD_VAR 0 1
61473: PUSH
61474: LD_INT 124
61476: EQUAL
61477: IFFALSE 61483
// MC_TeleportExit ( ) ;
61479: CALL 77403 0 0
// if event = 125 then
61483: LD_VAR 0 1
61487: PUSH
61488: LD_INT 125
61490: EQUAL
61491: IFFALSE 61497
// MC_Deposits ( ) ;
61493: CALL 78050 0 0
// if event = 126 then
61497: LD_VAR 0 1
61501: PUSH
61502: LD_INT 126
61504: EQUAL
61505: IFFALSE 61511
// MC_RemoteDriver ( ) ;
61507: CALL 78675 0 0
// if event = 200 then
61511: LD_VAR 0 1
61515: PUSH
61516: LD_INT 200
61518: EQUAL
61519: IFFALSE 61525
// MC_Idle ( ) ;
61521: CALL 80624 0 0
// end ;
61525: PPOPN 1
61527: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61528: LD_INT 0
61530: PPUSH
61531: PPUSH
// if not mc_bases [ base ] or not tag then
61532: LD_EXP 59
61536: PUSH
61537: LD_VAR 0 1
61541: ARRAY
61542: NOT
61543: PUSH
61544: LD_VAR 0 2
61548: NOT
61549: OR
61550: IFFALSE 61554
// exit ;
61552: GO 61618
// for i in mc_bases [ base ] union mc_ape [ base ] do
61554: LD_ADDR_VAR 0 4
61558: PUSH
61559: LD_EXP 59
61563: PUSH
61564: LD_VAR 0 1
61568: ARRAY
61569: PUSH
61570: LD_EXP 88
61574: PUSH
61575: LD_VAR 0 1
61579: ARRAY
61580: UNION
61581: PUSH
61582: FOR_IN
61583: IFFALSE 61616
// if GetTag ( i ) = tag then
61585: LD_VAR 0 4
61589: PPUSH
61590: CALL_OW 110
61594: PUSH
61595: LD_VAR 0 2
61599: EQUAL
61600: IFFALSE 61614
// SetTag ( i , 0 ) ;
61602: LD_VAR 0 4
61606: PPUSH
61607: LD_INT 0
61609: PPUSH
61610: CALL_OW 109
61614: GO 61582
61616: POP
61617: POP
// end ;
61618: LD_VAR 0 3
61622: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61623: LD_INT 0
61625: PPUSH
61626: PPUSH
61627: PPUSH
61628: PPUSH
61629: PPUSH
61630: PPUSH
61631: PPUSH
61632: PPUSH
// if not mc_bases then
61633: LD_EXP 59
61637: NOT
61638: IFFALSE 61642
// exit ;
61640: GO 62100
// for i = 1 to mc_bases do
61642: LD_ADDR_VAR 0 2
61646: PUSH
61647: DOUBLE
61648: LD_INT 1
61650: DEC
61651: ST_TO_ADDR
61652: LD_EXP 59
61656: PUSH
61657: FOR_TO
61658: IFFALSE 62098
// begin tmp := MC_ClassCheckReq ( i ) ;
61660: LD_ADDR_VAR 0 4
61664: PUSH
61665: LD_VAR 0 2
61669: PPUSH
61670: CALL 62105 0 1
61674: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61675: LD_ADDR_EXP 100
61679: PUSH
61680: LD_EXP 100
61684: PPUSH
61685: LD_VAR 0 2
61689: PPUSH
61690: LD_VAR 0 4
61694: PPUSH
61695: CALL_OW 1
61699: ST_TO_ADDR
// if not tmp then
61700: LD_VAR 0 4
61704: NOT
61705: IFFALSE 61709
// continue ;
61707: GO 61657
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61709: LD_ADDR_VAR 0 6
61713: PUSH
61714: LD_EXP 59
61718: PUSH
61719: LD_VAR 0 2
61723: ARRAY
61724: PPUSH
61725: LD_INT 2
61727: PUSH
61728: LD_INT 30
61730: PUSH
61731: LD_INT 4
61733: PUSH
61734: EMPTY
61735: LIST
61736: LIST
61737: PUSH
61738: LD_INT 30
61740: PUSH
61741: LD_INT 5
61743: PUSH
61744: EMPTY
61745: LIST
61746: LIST
61747: PUSH
61748: EMPTY
61749: LIST
61750: LIST
61751: LIST
61752: PPUSH
61753: CALL_OW 72
61757: PUSH
61758: LD_EXP 59
61762: PUSH
61763: LD_VAR 0 2
61767: ARRAY
61768: PPUSH
61769: LD_INT 2
61771: PUSH
61772: LD_INT 30
61774: PUSH
61775: LD_INT 0
61777: PUSH
61778: EMPTY
61779: LIST
61780: LIST
61781: PUSH
61782: LD_INT 30
61784: PUSH
61785: LD_INT 1
61787: PUSH
61788: EMPTY
61789: LIST
61790: LIST
61791: PUSH
61792: EMPTY
61793: LIST
61794: LIST
61795: LIST
61796: PPUSH
61797: CALL_OW 72
61801: PUSH
61802: LD_EXP 59
61806: PUSH
61807: LD_VAR 0 2
61811: ARRAY
61812: PPUSH
61813: LD_INT 30
61815: PUSH
61816: LD_INT 3
61818: PUSH
61819: EMPTY
61820: LIST
61821: LIST
61822: PPUSH
61823: CALL_OW 72
61827: PUSH
61828: LD_EXP 59
61832: PUSH
61833: LD_VAR 0 2
61837: ARRAY
61838: PPUSH
61839: LD_INT 2
61841: PUSH
61842: LD_INT 30
61844: PUSH
61845: LD_INT 6
61847: PUSH
61848: EMPTY
61849: LIST
61850: LIST
61851: PUSH
61852: LD_INT 30
61854: PUSH
61855: LD_INT 7
61857: PUSH
61858: EMPTY
61859: LIST
61860: LIST
61861: PUSH
61862: LD_INT 30
61864: PUSH
61865: LD_INT 8
61867: PUSH
61868: EMPTY
61869: LIST
61870: LIST
61871: PUSH
61872: EMPTY
61873: LIST
61874: LIST
61875: LIST
61876: LIST
61877: PPUSH
61878: CALL_OW 72
61882: PUSH
61883: EMPTY
61884: LIST
61885: LIST
61886: LIST
61887: LIST
61888: ST_TO_ADDR
// for j = 1 to 4 do
61889: LD_ADDR_VAR 0 3
61893: PUSH
61894: DOUBLE
61895: LD_INT 1
61897: DEC
61898: ST_TO_ADDR
61899: LD_INT 4
61901: PUSH
61902: FOR_TO
61903: IFFALSE 62094
// begin if not tmp [ j ] then
61905: LD_VAR 0 4
61909: PUSH
61910: LD_VAR 0 3
61914: ARRAY
61915: NOT
61916: IFFALSE 61920
// continue ;
61918: GO 61902
// for p in tmp [ j ] do
61920: LD_ADDR_VAR 0 5
61924: PUSH
61925: LD_VAR 0 4
61929: PUSH
61930: LD_VAR 0 3
61934: ARRAY
61935: PUSH
61936: FOR_IN
61937: IFFALSE 62090
// begin if not b [ j ] then
61939: LD_VAR 0 6
61943: PUSH
61944: LD_VAR 0 3
61948: ARRAY
61949: NOT
61950: IFFALSE 61954
// break ;
61952: GO 62090
// e := 0 ;
61954: LD_ADDR_VAR 0 7
61958: PUSH
61959: LD_INT 0
61961: ST_TO_ADDR
// for k in b [ j ] do
61962: LD_ADDR_VAR 0 8
61966: PUSH
61967: LD_VAR 0 6
61971: PUSH
61972: LD_VAR 0 3
61976: ARRAY
61977: PUSH
61978: FOR_IN
61979: IFFALSE 62006
// if IsNotFull ( k ) then
61981: LD_VAR 0 8
61985: PPUSH
61986: CALL 18791 0 1
61990: IFFALSE 62004
// begin e := k ;
61992: LD_ADDR_VAR 0 7
61996: PUSH
61997: LD_VAR 0 8
62001: ST_TO_ADDR
// break ;
62002: GO 62006
// end ;
62004: GO 61978
62006: POP
62007: POP
// if e and not UnitGoingToBuilding ( p , e ) then
62008: LD_VAR 0 7
62012: PUSH
62013: LD_VAR 0 5
62017: PPUSH
62018: LD_VAR 0 7
62022: PPUSH
62023: CALL 55910 0 2
62027: NOT
62028: AND
62029: IFFALSE 62088
// begin if IsInUnit ( p ) then
62031: LD_VAR 0 5
62035: PPUSH
62036: CALL_OW 310
62040: IFFALSE 62051
// ComExitBuilding ( p ) ;
62042: LD_VAR 0 5
62046: PPUSH
62047: CALL_OW 122
// ComEnterUnit ( p , e ) ;
62051: LD_VAR 0 5
62055: PPUSH
62056: LD_VAR 0 7
62060: PPUSH
62061: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
62065: LD_VAR 0 5
62069: PPUSH
62070: LD_VAR 0 3
62074: PPUSH
62075: CALL_OW 183
// AddComExitBuilding ( p ) ;
62079: LD_VAR 0 5
62083: PPUSH
62084: CALL_OW 182
// end ; end ;
62088: GO 61936
62090: POP
62091: POP
// end ;
62092: GO 61902
62094: POP
62095: POP
// end ;
62096: GO 61657
62098: POP
62099: POP
// end ;
62100: LD_VAR 0 1
62104: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
62105: LD_INT 0
62107: PPUSH
62108: PPUSH
62109: PPUSH
62110: PPUSH
62111: PPUSH
62112: PPUSH
62113: PPUSH
62114: PPUSH
62115: PPUSH
62116: PPUSH
62117: PPUSH
62118: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62119: LD_VAR 0 1
62123: NOT
62124: PUSH
62125: LD_EXP 59
62129: PUSH
62130: LD_VAR 0 1
62134: ARRAY
62135: NOT
62136: OR
62137: PUSH
62138: LD_EXP 59
62142: PUSH
62143: LD_VAR 0 1
62147: ARRAY
62148: PPUSH
62149: LD_INT 2
62151: PUSH
62152: LD_INT 30
62154: PUSH
62155: LD_INT 0
62157: PUSH
62158: EMPTY
62159: LIST
62160: LIST
62161: PUSH
62162: LD_INT 30
62164: PUSH
62165: LD_INT 1
62167: PUSH
62168: EMPTY
62169: LIST
62170: LIST
62171: PUSH
62172: EMPTY
62173: LIST
62174: LIST
62175: LIST
62176: PPUSH
62177: CALL_OW 72
62181: NOT
62182: OR
62183: IFFALSE 62187
// exit ;
62185: GO 65690
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62187: LD_ADDR_VAR 0 4
62191: PUSH
62192: LD_EXP 59
62196: PUSH
62197: LD_VAR 0 1
62201: ARRAY
62202: PPUSH
62203: LD_INT 2
62205: PUSH
62206: LD_INT 25
62208: PUSH
62209: LD_INT 1
62211: PUSH
62212: EMPTY
62213: LIST
62214: LIST
62215: PUSH
62216: LD_INT 25
62218: PUSH
62219: LD_INT 2
62221: PUSH
62222: EMPTY
62223: LIST
62224: LIST
62225: PUSH
62226: LD_INT 25
62228: PUSH
62229: LD_INT 3
62231: PUSH
62232: EMPTY
62233: LIST
62234: LIST
62235: PUSH
62236: LD_INT 25
62238: PUSH
62239: LD_INT 4
62241: PUSH
62242: EMPTY
62243: LIST
62244: LIST
62245: PUSH
62246: LD_INT 25
62248: PUSH
62249: LD_INT 5
62251: PUSH
62252: EMPTY
62253: LIST
62254: LIST
62255: PUSH
62256: LD_INT 25
62258: PUSH
62259: LD_INT 8
62261: PUSH
62262: EMPTY
62263: LIST
62264: LIST
62265: PUSH
62266: LD_INT 25
62268: PUSH
62269: LD_INT 9
62271: PUSH
62272: EMPTY
62273: LIST
62274: LIST
62275: PUSH
62276: EMPTY
62277: LIST
62278: LIST
62279: LIST
62280: LIST
62281: LIST
62282: LIST
62283: LIST
62284: LIST
62285: PPUSH
62286: CALL_OW 72
62290: ST_TO_ADDR
// if not tmp then
62291: LD_VAR 0 4
62295: NOT
62296: IFFALSE 62300
// exit ;
62298: GO 65690
// for i in tmp do
62300: LD_ADDR_VAR 0 3
62304: PUSH
62305: LD_VAR 0 4
62309: PUSH
62310: FOR_IN
62311: IFFALSE 62342
// if GetTag ( i ) then
62313: LD_VAR 0 3
62317: PPUSH
62318: CALL_OW 110
62322: IFFALSE 62340
// tmp := tmp diff i ;
62324: LD_ADDR_VAR 0 4
62328: PUSH
62329: LD_VAR 0 4
62333: PUSH
62334: LD_VAR 0 3
62338: DIFF
62339: ST_TO_ADDR
62340: GO 62310
62342: POP
62343: POP
// if not tmp then
62344: LD_VAR 0 4
62348: NOT
62349: IFFALSE 62353
// exit ;
62351: GO 65690
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62353: LD_ADDR_VAR 0 5
62357: PUSH
62358: LD_EXP 59
62362: PUSH
62363: LD_VAR 0 1
62367: ARRAY
62368: PPUSH
62369: LD_INT 2
62371: PUSH
62372: LD_INT 25
62374: PUSH
62375: LD_INT 1
62377: PUSH
62378: EMPTY
62379: LIST
62380: LIST
62381: PUSH
62382: LD_INT 25
62384: PUSH
62385: LD_INT 5
62387: PUSH
62388: EMPTY
62389: LIST
62390: LIST
62391: PUSH
62392: LD_INT 25
62394: PUSH
62395: LD_INT 8
62397: PUSH
62398: EMPTY
62399: LIST
62400: LIST
62401: PUSH
62402: LD_INT 25
62404: PUSH
62405: LD_INT 9
62407: PUSH
62408: EMPTY
62409: LIST
62410: LIST
62411: PUSH
62412: EMPTY
62413: LIST
62414: LIST
62415: LIST
62416: LIST
62417: LIST
62418: PPUSH
62419: CALL_OW 72
62423: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62424: LD_ADDR_VAR 0 6
62428: PUSH
62429: LD_EXP 59
62433: PUSH
62434: LD_VAR 0 1
62438: ARRAY
62439: PPUSH
62440: LD_INT 25
62442: PUSH
62443: LD_INT 2
62445: PUSH
62446: EMPTY
62447: LIST
62448: LIST
62449: PPUSH
62450: CALL_OW 72
62454: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62455: LD_ADDR_VAR 0 7
62459: PUSH
62460: LD_EXP 59
62464: PUSH
62465: LD_VAR 0 1
62469: ARRAY
62470: PPUSH
62471: LD_INT 25
62473: PUSH
62474: LD_INT 3
62476: PUSH
62477: EMPTY
62478: LIST
62479: LIST
62480: PPUSH
62481: CALL_OW 72
62485: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62486: LD_ADDR_VAR 0 8
62490: PUSH
62491: LD_EXP 59
62495: PUSH
62496: LD_VAR 0 1
62500: ARRAY
62501: PPUSH
62502: LD_INT 25
62504: PUSH
62505: LD_INT 4
62507: PUSH
62508: EMPTY
62509: LIST
62510: LIST
62511: PUSH
62512: LD_INT 24
62514: PUSH
62515: LD_INT 251
62517: PUSH
62518: EMPTY
62519: LIST
62520: LIST
62521: PUSH
62522: EMPTY
62523: LIST
62524: LIST
62525: PPUSH
62526: CALL_OW 72
62530: ST_TO_ADDR
// if mc_scan [ base ] then
62531: LD_EXP 82
62535: PUSH
62536: LD_VAR 0 1
62540: ARRAY
62541: IFFALSE 63002
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62543: LD_ADDR_EXP 101
62547: PUSH
62548: LD_EXP 101
62552: PPUSH
62553: LD_VAR 0 1
62557: PPUSH
62558: LD_INT 4
62560: PPUSH
62561: CALL_OW 1
62565: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62566: LD_ADDR_VAR 0 12
62570: PUSH
62571: LD_EXP 59
62575: PUSH
62576: LD_VAR 0 1
62580: ARRAY
62581: PPUSH
62582: LD_INT 2
62584: PUSH
62585: LD_INT 30
62587: PUSH
62588: LD_INT 4
62590: PUSH
62591: EMPTY
62592: LIST
62593: LIST
62594: PUSH
62595: LD_INT 30
62597: PUSH
62598: LD_INT 5
62600: PUSH
62601: EMPTY
62602: LIST
62603: LIST
62604: PUSH
62605: EMPTY
62606: LIST
62607: LIST
62608: LIST
62609: PPUSH
62610: CALL_OW 72
62614: ST_TO_ADDR
// if not b then
62615: LD_VAR 0 12
62619: NOT
62620: IFFALSE 62624
// exit ;
62622: GO 65690
// p := [ ] ;
62624: LD_ADDR_VAR 0 11
62628: PUSH
62629: EMPTY
62630: ST_TO_ADDR
// if sci >= 2 then
62631: LD_VAR 0 8
62635: PUSH
62636: LD_INT 2
62638: GREATEREQUAL
62639: IFFALSE 62670
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62641: LD_ADDR_VAR 0 8
62645: PUSH
62646: LD_VAR 0 8
62650: PUSH
62651: LD_INT 1
62653: ARRAY
62654: PUSH
62655: LD_VAR 0 8
62659: PUSH
62660: LD_INT 2
62662: ARRAY
62663: PUSH
62664: EMPTY
62665: LIST
62666: LIST
62667: ST_TO_ADDR
62668: GO 62731
// if sci = 1 then
62670: LD_VAR 0 8
62674: PUSH
62675: LD_INT 1
62677: EQUAL
62678: IFFALSE 62699
// sci := [ sci [ 1 ] ] else
62680: LD_ADDR_VAR 0 8
62684: PUSH
62685: LD_VAR 0 8
62689: PUSH
62690: LD_INT 1
62692: ARRAY
62693: PUSH
62694: EMPTY
62695: LIST
62696: ST_TO_ADDR
62697: GO 62731
// if sci = 0 then
62699: LD_VAR 0 8
62703: PUSH
62704: LD_INT 0
62706: EQUAL
62707: IFFALSE 62731
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62709: LD_ADDR_VAR 0 11
62713: PUSH
62714: LD_VAR 0 4
62718: PPUSH
62719: LD_INT 4
62721: PPUSH
62722: CALL 55773 0 2
62726: PUSH
62727: LD_INT 1
62729: ARRAY
62730: ST_TO_ADDR
// if eng > 4 then
62731: LD_VAR 0 6
62735: PUSH
62736: LD_INT 4
62738: GREATER
62739: IFFALSE 62785
// for i = eng downto 4 do
62741: LD_ADDR_VAR 0 3
62745: PUSH
62746: DOUBLE
62747: LD_VAR 0 6
62751: INC
62752: ST_TO_ADDR
62753: LD_INT 4
62755: PUSH
62756: FOR_DOWNTO
62757: IFFALSE 62783
// eng := eng diff eng [ i ] ;
62759: LD_ADDR_VAR 0 6
62763: PUSH
62764: LD_VAR 0 6
62768: PUSH
62769: LD_VAR 0 6
62773: PUSH
62774: LD_VAR 0 3
62778: ARRAY
62779: DIFF
62780: ST_TO_ADDR
62781: GO 62756
62783: POP
62784: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62785: LD_ADDR_VAR 0 4
62789: PUSH
62790: LD_VAR 0 4
62794: PUSH
62795: LD_VAR 0 5
62799: PUSH
62800: LD_VAR 0 6
62804: UNION
62805: PUSH
62806: LD_VAR 0 7
62810: UNION
62811: PUSH
62812: LD_VAR 0 8
62816: UNION
62817: DIFF
62818: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62819: LD_ADDR_VAR 0 13
62823: PUSH
62824: LD_EXP 59
62828: PUSH
62829: LD_VAR 0 1
62833: ARRAY
62834: PPUSH
62835: LD_INT 2
62837: PUSH
62838: LD_INT 30
62840: PUSH
62841: LD_INT 32
62843: PUSH
62844: EMPTY
62845: LIST
62846: LIST
62847: PUSH
62848: LD_INT 30
62850: PUSH
62851: LD_INT 31
62853: PUSH
62854: EMPTY
62855: LIST
62856: LIST
62857: PUSH
62858: EMPTY
62859: LIST
62860: LIST
62861: LIST
62862: PPUSH
62863: CALL_OW 72
62867: PUSH
62868: LD_EXP 59
62872: PUSH
62873: LD_VAR 0 1
62877: ARRAY
62878: PPUSH
62879: LD_INT 2
62881: PUSH
62882: LD_INT 30
62884: PUSH
62885: LD_INT 4
62887: PUSH
62888: EMPTY
62889: LIST
62890: LIST
62891: PUSH
62892: LD_INT 30
62894: PUSH
62895: LD_INT 5
62897: PUSH
62898: EMPTY
62899: LIST
62900: LIST
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: LIST
62906: PPUSH
62907: CALL_OW 72
62911: PUSH
62912: LD_INT 6
62914: MUL
62915: PLUS
62916: ST_TO_ADDR
// if bcount < tmp then
62917: LD_VAR 0 13
62921: PUSH
62922: LD_VAR 0 4
62926: LESS
62927: IFFALSE 62973
// for i = tmp downto bcount do
62929: LD_ADDR_VAR 0 3
62933: PUSH
62934: DOUBLE
62935: LD_VAR 0 4
62939: INC
62940: ST_TO_ADDR
62941: LD_VAR 0 13
62945: PUSH
62946: FOR_DOWNTO
62947: IFFALSE 62971
// tmp := Delete ( tmp , tmp ) ;
62949: LD_ADDR_VAR 0 4
62953: PUSH
62954: LD_VAR 0 4
62958: PPUSH
62959: LD_VAR 0 4
62963: PPUSH
62964: CALL_OW 3
62968: ST_TO_ADDR
62969: GO 62946
62971: POP
62972: POP
// result := [ tmp , 0 , 0 , p ] ;
62973: LD_ADDR_VAR 0 2
62977: PUSH
62978: LD_VAR 0 4
62982: PUSH
62983: LD_INT 0
62985: PUSH
62986: LD_INT 0
62988: PUSH
62989: LD_VAR 0 11
62993: PUSH
62994: EMPTY
62995: LIST
62996: LIST
62997: LIST
62998: LIST
62999: ST_TO_ADDR
// exit ;
63000: GO 65690
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63002: LD_EXP 59
63006: PUSH
63007: LD_VAR 0 1
63011: ARRAY
63012: PPUSH
63013: LD_INT 2
63015: PUSH
63016: LD_INT 30
63018: PUSH
63019: LD_INT 6
63021: PUSH
63022: EMPTY
63023: LIST
63024: LIST
63025: PUSH
63026: LD_INT 30
63028: PUSH
63029: LD_INT 7
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: PUSH
63036: LD_INT 30
63038: PUSH
63039: LD_INT 8
63041: PUSH
63042: EMPTY
63043: LIST
63044: LIST
63045: PUSH
63046: EMPTY
63047: LIST
63048: LIST
63049: LIST
63050: LIST
63051: PPUSH
63052: CALL_OW 72
63056: NOT
63057: PUSH
63058: LD_EXP 59
63062: PUSH
63063: LD_VAR 0 1
63067: ARRAY
63068: PPUSH
63069: LD_INT 30
63071: PUSH
63072: LD_INT 3
63074: PUSH
63075: EMPTY
63076: LIST
63077: LIST
63078: PPUSH
63079: CALL_OW 72
63083: NOT
63084: AND
63085: IFFALSE 63157
// begin if eng = tmp then
63087: LD_VAR 0 6
63091: PUSH
63092: LD_VAR 0 4
63096: EQUAL
63097: IFFALSE 63101
// exit ;
63099: GO 65690
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
63101: LD_ADDR_EXP 101
63105: PUSH
63106: LD_EXP 101
63110: PPUSH
63111: LD_VAR 0 1
63115: PPUSH
63116: LD_INT 1
63118: PPUSH
63119: CALL_OW 1
63123: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
63124: LD_ADDR_VAR 0 2
63128: PUSH
63129: LD_INT 0
63131: PUSH
63132: LD_VAR 0 4
63136: PUSH
63137: LD_VAR 0 6
63141: DIFF
63142: PUSH
63143: LD_INT 0
63145: PUSH
63146: LD_INT 0
63148: PUSH
63149: EMPTY
63150: LIST
63151: LIST
63152: LIST
63153: LIST
63154: ST_TO_ADDR
// exit ;
63155: GO 65690
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63157: LD_EXP 86
63161: PUSH
63162: LD_EXP 85
63166: PUSH
63167: LD_VAR 0 1
63171: ARRAY
63172: ARRAY
63173: PUSH
63174: LD_EXP 59
63178: PUSH
63179: LD_VAR 0 1
63183: ARRAY
63184: PPUSH
63185: LD_INT 2
63187: PUSH
63188: LD_INT 30
63190: PUSH
63191: LD_INT 6
63193: PUSH
63194: EMPTY
63195: LIST
63196: LIST
63197: PUSH
63198: LD_INT 30
63200: PUSH
63201: LD_INT 7
63203: PUSH
63204: EMPTY
63205: LIST
63206: LIST
63207: PUSH
63208: LD_INT 30
63210: PUSH
63211: LD_INT 8
63213: PUSH
63214: EMPTY
63215: LIST
63216: LIST
63217: PUSH
63218: EMPTY
63219: LIST
63220: LIST
63221: LIST
63222: LIST
63223: PPUSH
63224: CALL_OW 72
63228: AND
63229: PUSH
63230: LD_EXP 59
63234: PUSH
63235: LD_VAR 0 1
63239: ARRAY
63240: PPUSH
63241: LD_INT 30
63243: PUSH
63244: LD_INT 3
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: PPUSH
63251: CALL_OW 72
63255: NOT
63256: AND
63257: IFFALSE 63471
// begin if sci >= 6 then
63259: LD_VAR 0 8
63263: PUSH
63264: LD_INT 6
63266: GREATEREQUAL
63267: IFFALSE 63271
// exit ;
63269: GO 65690
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
63271: LD_ADDR_EXP 101
63275: PUSH
63276: LD_EXP 101
63280: PPUSH
63281: LD_VAR 0 1
63285: PPUSH
63286: LD_INT 2
63288: PPUSH
63289: CALL_OW 1
63293: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
63294: LD_ADDR_VAR 0 9
63298: PUSH
63299: LD_VAR 0 4
63303: PUSH
63304: LD_VAR 0 8
63308: DIFF
63309: PPUSH
63310: LD_INT 4
63312: PPUSH
63313: CALL 55773 0 2
63317: ST_TO_ADDR
// p := [ ] ;
63318: LD_ADDR_VAR 0 11
63322: PUSH
63323: EMPTY
63324: ST_TO_ADDR
// if sci < 6 and sort > 6 then
63325: LD_VAR 0 8
63329: PUSH
63330: LD_INT 6
63332: LESS
63333: PUSH
63334: LD_VAR 0 9
63338: PUSH
63339: LD_INT 6
63341: GREATER
63342: AND
63343: IFFALSE 63424
// begin for i = 1 to 6 - sci do
63345: LD_ADDR_VAR 0 3
63349: PUSH
63350: DOUBLE
63351: LD_INT 1
63353: DEC
63354: ST_TO_ADDR
63355: LD_INT 6
63357: PUSH
63358: LD_VAR 0 8
63362: MINUS
63363: PUSH
63364: FOR_TO
63365: IFFALSE 63420
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63367: LD_ADDR_VAR 0 11
63371: PUSH
63372: LD_VAR 0 11
63376: PPUSH
63377: LD_VAR 0 11
63381: PUSH
63382: LD_INT 1
63384: PLUS
63385: PPUSH
63386: LD_VAR 0 9
63390: PUSH
63391: LD_INT 1
63393: ARRAY
63394: PPUSH
63395: CALL_OW 2
63399: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63400: LD_ADDR_VAR 0 9
63404: PUSH
63405: LD_VAR 0 9
63409: PPUSH
63410: LD_INT 1
63412: PPUSH
63413: CALL_OW 3
63417: ST_TO_ADDR
// end ;
63418: GO 63364
63420: POP
63421: POP
// end else
63422: GO 63444
// if sort then
63424: LD_VAR 0 9
63428: IFFALSE 63444
// p := sort [ 1 ] ;
63430: LD_ADDR_VAR 0 11
63434: PUSH
63435: LD_VAR 0 9
63439: PUSH
63440: LD_INT 1
63442: ARRAY
63443: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63444: LD_ADDR_VAR 0 2
63448: PUSH
63449: LD_INT 0
63451: PUSH
63452: LD_INT 0
63454: PUSH
63455: LD_INT 0
63457: PUSH
63458: LD_VAR 0 11
63462: PUSH
63463: EMPTY
63464: LIST
63465: LIST
63466: LIST
63467: LIST
63468: ST_TO_ADDR
// exit ;
63469: GO 65690
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63471: LD_EXP 86
63475: PUSH
63476: LD_EXP 85
63480: PUSH
63481: LD_VAR 0 1
63485: ARRAY
63486: ARRAY
63487: PUSH
63488: LD_EXP 59
63492: PUSH
63493: LD_VAR 0 1
63497: ARRAY
63498: PPUSH
63499: LD_INT 2
63501: PUSH
63502: LD_INT 30
63504: PUSH
63505: LD_INT 6
63507: PUSH
63508: EMPTY
63509: LIST
63510: LIST
63511: PUSH
63512: LD_INT 30
63514: PUSH
63515: LD_INT 7
63517: PUSH
63518: EMPTY
63519: LIST
63520: LIST
63521: PUSH
63522: LD_INT 30
63524: PUSH
63525: LD_INT 8
63527: PUSH
63528: EMPTY
63529: LIST
63530: LIST
63531: PUSH
63532: EMPTY
63533: LIST
63534: LIST
63535: LIST
63536: LIST
63537: PPUSH
63538: CALL_OW 72
63542: AND
63543: PUSH
63544: LD_EXP 59
63548: PUSH
63549: LD_VAR 0 1
63553: ARRAY
63554: PPUSH
63555: LD_INT 30
63557: PUSH
63558: LD_INT 3
63560: PUSH
63561: EMPTY
63562: LIST
63563: LIST
63564: PPUSH
63565: CALL_OW 72
63569: AND
63570: IFFALSE 64304
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63572: LD_ADDR_EXP 101
63576: PUSH
63577: LD_EXP 101
63581: PPUSH
63582: LD_VAR 0 1
63586: PPUSH
63587: LD_INT 3
63589: PPUSH
63590: CALL_OW 1
63594: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63595: LD_ADDR_VAR 0 2
63599: PUSH
63600: LD_INT 0
63602: PUSH
63603: LD_INT 0
63605: PUSH
63606: LD_INT 0
63608: PUSH
63609: LD_INT 0
63611: PUSH
63612: EMPTY
63613: LIST
63614: LIST
63615: LIST
63616: LIST
63617: ST_TO_ADDR
// if not eng then
63618: LD_VAR 0 6
63622: NOT
63623: IFFALSE 63686
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63625: LD_ADDR_VAR 0 11
63629: PUSH
63630: LD_VAR 0 4
63634: PPUSH
63635: LD_INT 2
63637: PPUSH
63638: CALL 55773 0 2
63642: PUSH
63643: LD_INT 1
63645: ARRAY
63646: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63647: LD_ADDR_VAR 0 2
63651: PUSH
63652: LD_VAR 0 2
63656: PPUSH
63657: LD_INT 2
63659: PPUSH
63660: LD_VAR 0 11
63664: PPUSH
63665: CALL_OW 1
63669: ST_TO_ADDR
// tmp := tmp diff p ;
63670: LD_ADDR_VAR 0 4
63674: PUSH
63675: LD_VAR 0 4
63679: PUSH
63680: LD_VAR 0 11
63684: DIFF
63685: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63686: LD_VAR 0 4
63690: PUSH
63691: LD_VAR 0 8
63695: PUSH
63696: LD_INT 6
63698: LESS
63699: AND
63700: IFFALSE 63888
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63702: LD_ADDR_VAR 0 9
63706: PUSH
63707: LD_VAR 0 4
63711: PUSH
63712: LD_VAR 0 8
63716: PUSH
63717: LD_VAR 0 7
63721: UNION
63722: DIFF
63723: PPUSH
63724: LD_INT 4
63726: PPUSH
63727: CALL 55773 0 2
63731: ST_TO_ADDR
// p := [ ] ;
63732: LD_ADDR_VAR 0 11
63736: PUSH
63737: EMPTY
63738: ST_TO_ADDR
// if sort then
63739: LD_VAR 0 9
63743: IFFALSE 63859
// for i = 1 to 6 - sci do
63745: LD_ADDR_VAR 0 3
63749: PUSH
63750: DOUBLE
63751: LD_INT 1
63753: DEC
63754: ST_TO_ADDR
63755: LD_INT 6
63757: PUSH
63758: LD_VAR 0 8
63762: MINUS
63763: PUSH
63764: FOR_TO
63765: IFFALSE 63857
// begin if i = sort then
63767: LD_VAR 0 3
63771: PUSH
63772: LD_VAR 0 9
63776: EQUAL
63777: IFFALSE 63781
// break ;
63779: GO 63857
// if GetClass ( i ) = 4 then
63781: LD_VAR 0 3
63785: PPUSH
63786: CALL_OW 257
63790: PUSH
63791: LD_INT 4
63793: EQUAL
63794: IFFALSE 63798
// continue ;
63796: GO 63764
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63798: LD_ADDR_VAR 0 11
63802: PUSH
63803: LD_VAR 0 11
63807: PPUSH
63808: LD_VAR 0 11
63812: PUSH
63813: LD_INT 1
63815: PLUS
63816: PPUSH
63817: LD_VAR 0 9
63821: PUSH
63822: LD_VAR 0 3
63826: ARRAY
63827: PPUSH
63828: CALL_OW 2
63832: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63833: LD_ADDR_VAR 0 4
63837: PUSH
63838: LD_VAR 0 4
63842: PUSH
63843: LD_VAR 0 9
63847: PUSH
63848: LD_VAR 0 3
63852: ARRAY
63853: DIFF
63854: ST_TO_ADDR
// end ;
63855: GO 63764
63857: POP
63858: POP
// if p then
63859: LD_VAR 0 11
63863: IFFALSE 63888
// result := Replace ( result , 4 , p ) ;
63865: LD_ADDR_VAR 0 2
63869: PUSH
63870: LD_VAR 0 2
63874: PPUSH
63875: LD_INT 4
63877: PPUSH
63878: LD_VAR 0 11
63882: PPUSH
63883: CALL_OW 1
63887: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63888: LD_VAR 0 4
63892: PUSH
63893: LD_VAR 0 7
63897: PUSH
63898: LD_INT 6
63900: LESS
63901: AND
63902: IFFALSE 64090
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63904: LD_ADDR_VAR 0 9
63908: PUSH
63909: LD_VAR 0 4
63913: PUSH
63914: LD_VAR 0 8
63918: PUSH
63919: LD_VAR 0 7
63923: UNION
63924: DIFF
63925: PPUSH
63926: LD_INT 3
63928: PPUSH
63929: CALL 55773 0 2
63933: ST_TO_ADDR
// p := [ ] ;
63934: LD_ADDR_VAR 0 11
63938: PUSH
63939: EMPTY
63940: ST_TO_ADDR
// if sort then
63941: LD_VAR 0 9
63945: IFFALSE 64061
// for i = 1 to 6 - mech do
63947: LD_ADDR_VAR 0 3
63951: PUSH
63952: DOUBLE
63953: LD_INT 1
63955: DEC
63956: ST_TO_ADDR
63957: LD_INT 6
63959: PUSH
63960: LD_VAR 0 7
63964: MINUS
63965: PUSH
63966: FOR_TO
63967: IFFALSE 64059
// begin if i = sort then
63969: LD_VAR 0 3
63973: PUSH
63974: LD_VAR 0 9
63978: EQUAL
63979: IFFALSE 63983
// break ;
63981: GO 64059
// if GetClass ( i ) = 3 then
63983: LD_VAR 0 3
63987: PPUSH
63988: CALL_OW 257
63992: PUSH
63993: LD_INT 3
63995: EQUAL
63996: IFFALSE 64000
// continue ;
63998: GO 63966
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64000: LD_ADDR_VAR 0 11
64004: PUSH
64005: LD_VAR 0 11
64009: PPUSH
64010: LD_VAR 0 11
64014: PUSH
64015: LD_INT 1
64017: PLUS
64018: PPUSH
64019: LD_VAR 0 9
64023: PUSH
64024: LD_VAR 0 3
64028: ARRAY
64029: PPUSH
64030: CALL_OW 2
64034: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64035: LD_ADDR_VAR 0 4
64039: PUSH
64040: LD_VAR 0 4
64044: PUSH
64045: LD_VAR 0 9
64049: PUSH
64050: LD_VAR 0 3
64054: ARRAY
64055: DIFF
64056: ST_TO_ADDR
// end ;
64057: GO 63966
64059: POP
64060: POP
// if p then
64061: LD_VAR 0 11
64065: IFFALSE 64090
// result := Replace ( result , 3 , p ) ;
64067: LD_ADDR_VAR 0 2
64071: PUSH
64072: LD_VAR 0 2
64076: PPUSH
64077: LD_INT 3
64079: PPUSH
64080: LD_VAR 0 11
64084: PPUSH
64085: CALL_OW 1
64089: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
64090: LD_VAR 0 4
64094: PUSH
64095: LD_INT 6
64097: GREATER
64098: PUSH
64099: LD_VAR 0 6
64103: PUSH
64104: LD_INT 6
64106: LESS
64107: AND
64108: IFFALSE 64302
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64110: LD_ADDR_VAR 0 9
64114: PUSH
64115: LD_VAR 0 4
64119: PUSH
64120: LD_VAR 0 8
64124: PUSH
64125: LD_VAR 0 7
64129: UNION
64130: PUSH
64131: LD_VAR 0 6
64135: UNION
64136: DIFF
64137: PPUSH
64138: LD_INT 2
64140: PPUSH
64141: CALL 55773 0 2
64145: ST_TO_ADDR
// p := [ ] ;
64146: LD_ADDR_VAR 0 11
64150: PUSH
64151: EMPTY
64152: ST_TO_ADDR
// if sort then
64153: LD_VAR 0 9
64157: IFFALSE 64273
// for i = 1 to 6 - eng do
64159: LD_ADDR_VAR 0 3
64163: PUSH
64164: DOUBLE
64165: LD_INT 1
64167: DEC
64168: ST_TO_ADDR
64169: LD_INT 6
64171: PUSH
64172: LD_VAR 0 6
64176: MINUS
64177: PUSH
64178: FOR_TO
64179: IFFALSE 64271
// begin if i = sort then
64181: LD_VAR 0 3
64185: PUSH
64186: LD_VAR 0 9
64190: EQUAL
64191: IFFALSE 64195
// break ;
64193: GO 64271
// if GetClass ( i ) = 2 then
64195: LD_VAR 0 3
64199: PPUSH
64200: CALL_OW 257
64204: PUSH
64205: LD_INT 2
64207: EQUAL
64208: IFFALSE 64212
// continue ;
64210: GO 64178
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64212: LD_ADDR_VAR 0 11
64216: PUSH
64217: LD_VAR 0 11
64221: PPUSH
64222: LD_VAR 0 11
64226: PUSH
64227: LD_INT 1
64229: PLUS
64230: PPUSH
64231: LD_VAR 0 9
64235: PUSH
64236: LD_VAR 0 3
64240: ARRAY
64241: PPUSH
64242: CALL_OW 2
64246: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64247: LD_ADDR_VAR 0 4
64251: PUSH
64252: LD_VAR 0 4
64256: PUSH
64257: LD_VAR 0 9
64261: PUSH
64262: LD_VAR 0 3
64266: ARRAY
64267: DIFF
64268: ST_TO_ADDR
// end ;
64269: GO 64178
64271: POP
64272: POP
// if p then
64273: LD_VAR 0 11
64277: IFFALSE 64302
// result := Replace ( result , 2 , p ) ;
64279: LD_ADDR_VAR 0 2
64283: PUSH
64284: LD_VAR 0 2
64288: PPUSH
64289: LD_INT 2
64291: PPUSH
64292: LD_VAR 0 11
64296: PPUSH
64297: CALL_OW 1
64301: ST_TO_ADDR
// end ; exit ;
64302: GO 65690
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
64304: LD_EXP 86
64308: PUSH
64309: LD_EXP 85
64313: PUSH
64314: LD_VAR 0 1
64318: ARRAY
64319: ARRAY
64320: NOT
64321: PUSH
64322: LD_EXP 59
64326: PUSH
64327: LD_VAR 0 1
64331: ARRAY
64332: PPUSH
64333: LD_INT 30
64335: PUSH
64336: LD_INT 3
64338: PUSH
64339: EMPTY
64340: LIST
64341: LIST
64342: PPUSH
64343: CALL_OW 72
64347: AND
64348: PUSH
64349: LD_EXP 64
64353: PUSH
64354: LD_VAR 0 1
64358: ARRAY
64359: AND
64360: IFFALSE 64968
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64362: LD_ADDR_EXP 101
64366: PUSH
64367: LD_EXP 101
64371: PPUSH
64372: LD_VAR 0 1
64376: PPUSH
64377: LD_INT 5
64379: PPUSH
64380: CALL_OW 1
64384: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64385: LD_ADDR_VAR 0 2
64389: PUSH
64390: LD_INT 0
64392: PUSH
64393: LD_INT 0
64395: PUSH
64396: LD_INT 0
64398: PUSH
64399: LD_INT 0
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: LIST
64406: LIST
64407: ST_TO_ADDR
// if sci > 1 then
64408: LD_VAR 0 8
64412: PUSH
64413: LD_INT 1
64415: GREATER
64416: IFFALSE 64444
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64418: LD_ADDR_VAR 0 4
64422: PUSH
64423: LD_VAR 0 4
64427: PUSH
64428: LD_VAR 0 8
64432: PUSH
64433: LD_VAR 0 8
64437: PUSH
64438: LD_INT 1
64440: ARRAY
64441: DIFF
64442: DIFF
64443: ST_TO_ADDR
// if tmp and not sci then
64444: LD_VAR 0 4
64448: PUSH
64449: LD_VAR 0 8
64453: NOT
64454: AND
64455: IFFALSE 64524
// begin sort := SortBySkill ( tmp , 4 ) ;
64457: LD_ADDR_VAR 0 9
64461: PUSH
64462: LD_VAR 0 4
64466: PPUSH
64467: LD_INT 4
64469: PPUSH
64470: CALL 55773 0 2
64474: ST_TO_ADDR
// if sort then
64475: LD_VAR 0 9
64479: IFFALSE 64495
// p := sort [ 1 ] ;
64481: LD_ADDR_VAR 0 11
64485: PUSH
64486: LD_VAR 0 9
64490: PUSH
64491: LD_INT 1
64493: ARRAY
64494: ST_TO_ADDR
// if p then
64495: LD_VAR 0 11
64499: IFFALSE 64524
// result := Replace ( result , 4 , p ) ;
64501: LD_ADDR_VAR 0 2
64505: PUSH
64506: LD_VAR 0 2
64510: PPUSH
64511: LD_INT 4
64513: PPUSH
64514: LD_VAR 0 11
64518: PPUSH
64519: CALL_OW 1
64523: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64524: LD_ADDR_VAR 0 4
64528: PUSH
64529: LD_VAR 0 4
64533: PUSH
64534: LD_VAR 0 7
64538: DIFF
64539: ST_TO_ADDR
// if tmp and mech < 6 then
64540: LD_VAR 0 4
64544: PUSH
64545: LD_VAR 0 7
64549: PUSH
64550: LD_INT 6
64552: LESS
64553: AND
64554: IFFALSE 64742
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64556: LD_ADDR_VAR 0 9
64560: PUSH
64561: LD_VAR 0 4
64565: PUSH
64566: LD_VAR 0 8
64570: PUSH
64571: LD_VAR 0 7
64575: UNION
64576: DIFF
64577: PPUSH
64578: LD_INT 3
64580: PPUSH
64581: CALL 55773 0 2
64585: ST_TO_ADDR
// p := [ ] ;
64586: LD_ADDR_VAR 0 11
64590: PUSH
64591: EMPTY
64592: ST_TO_ADDR
// if sort then
64593: LD_VAR 0 9
64597: IFFALSE 64713
// for i = 1 to 6 - mech do
64599: LD_ADDR_VAR 0 3
64603: PUSH
64604: DOUBLE
64605: LD_INT 1
64607: DEC
64608: ST_TO_ADDR
64609: LD_INT 6
64611: PUSH
64612: LD_VAR 0 7
64616: MINUS
64617: PUSH
64618: FOR_TO
64619: IFFALSE 64711
// begin if i = sort then
64621: LD_VAR 0 3
64625: PUSH
64626: LD_VAR 0 9
64630: EQUAL
64631: IFFALSE 64635
// break ;
64633: GO 64711
// if GetClass ( i ) = 3 then
64635: LD_VAR 0 3
64639: PPUSH
64640: CALL_OW 257
64644: PUSH
64645: LD_INT 3
64647: EQUAL
64648: IFFALSE 64652
// continue ;
64650: GO 64618
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64652: LD_ADDR_VAR 0 11
64656: PUSH
64657: LD_VAR 0 11
64661: PPUSH
64662: LD_VAR 0 11
64666: PUSH
64667: LD_INT 1
64669: PLUS
64670: PPUSH
64671: LD_VAR 0 9
64675: PUSH
64676: LD_VAR 0 3
64680: ARRAY
64681: PPUSH
64682: CALL_OW 2
64686: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64687: LD_ADDR_VAR 0 4
64691: PUSH
64692: LD_VAR 0 4
64696: PUSH
64697: LD_VAR 0 9
64701: PUSH
64702: LD_VAR 0 3
64706: ARRAY
64707: DIFF
64708: ST_TO_ADDR
// end ;
64709: GO 64618
64711: POP
64712: POP
// if p then
64713: LD_VAR 0 11
64717: IFFALSE 64742
// result := Replace ( result , 3 , p ) ;
64719: LD_ADDR_VAR 0 2
64723: PUSH
64724: LD_VAR 0 2
64728: PPUSH
64729: LD_INT 3
64731: PPUSH
64732: LD_VAR 0 11
64736: PPUSH
64737: CALL_OW 1
64741: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64742: LD_ADDR_VAR 0 4
64746: PUSH
64747: LD_VAR 0 4
64751: PUSH
64752: LD_VAR 0 6
64756: DIFF
64757: ST_TO_ADDR
// if tmp and eng < 6 then
64758: LD_VAR 0 4
64762: PUSH
64763: LD_VAR 0 6
64767: PUSH
64768: LD_INT 6
64770: LESS
64771: AND
64772: IFFALSE 64966
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64774: LD_ADDR_VAR 0 9
64778: PUSH
64779: LD_VAR 0 4
64783: PUSH
64784: LD_VAR 0 8
64788: PUSH
64789: LD_VAR 0 7
64793: UNION
64794: PUSH
64795: LD_VAR 0 6
64799: UNION
64800: DIFF
64801: PPUSH
64802: LD_INT 2
64804: PPUSH
64805: CALL 55773 0 2
64809: ST_TO_ADDR
// p := [ ] ;
64810: LD_ADDR_VAR 0 11
64814: PUSH
64815: EMPTY
64816: ST_TO_ADDR
// if sort then
64817: LD_VAR 0 9
64821: IFFALSE 64937
// for i = 1 to 6 - eng do
64823: LD_ADDR_VAR 0 3
64827: PUSH
64828: DOUBLE
64829: LD_INT 1
64831: DEC
64832: ST_TO_ADDR
64833: LD_INT 6
64835: PUSH
64836: LD_VAR 0 6
64840: MINUS
64841: PUSH
64842: FOR_TO
64843: IFFALSE 64935
// begin if i = sort then
64845: LD_VAR 0 3
64849: PUSH
64850: LD_VAR 0 9
64854: EQUAL
64855: IFFALSE 64859
// break ;
64857: GO 64935
// if GetClass ( i ) = 2 then
64859: LD_VAR 0 3
64863: PPUSH
64864: CALL_OW 257
64868: PUSH
64869: LD_INT 2
64871: EQUAL
64872: IFFALSE 64876
// continue ;
64874: GO 64842
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64876: LD_ADDR_VAR 0 11
64880: PUSH
64881: LD_VAR 0 11
64885: PPUSH
64886: LD_VAR 0 11
64890: PUSH
64891: LD_INT 1
64893: PLUS
64894: PPUSH
64895: LD_VAR 0 9
64899: PUSH
64900: LD_VAR 0 3
64904: ARRAY
64905: PPUSH
64906: CALL_OW 2
64910: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64911: LD_ADDR_VAR 0 4
64915: PUSH
64916: LD_VAR 0 4
64920: PUSH
64921: LD_VAR 0 9
64925: PUSH
64926: LD_VAR 0 3
64930: ARRAY
64931: DIFF
64932: ST_TO_ADDR
// end ;
64933: GO 64842
64935: POP
64936: POP
// if p then
64937: LD_VAR 0 11
64941: IFFALSE 64966
// result := Replace ( result , 2 , p ) ;
64943: LD_ADDR_VAR 0 2
64947: PUSH
64948: LD_VAR 0 2
64952: PPUSH
64953: LD_INT 2
64955: PPUSH
64956: LD_VAR 0 11
64960: PPUSH
64961: CALL_OW 1
64965: ST_TO_ADDR
// end ; exit ;
64966: GO 65690
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64968: LD_EXP 86
64972: PUSH
64973: LD_EXP 85
64977: PUSH
64978: LD_VAR 0 1
64982: ARRAY
64983: ARRAY
64984: NOT
64985: PUSH
64986: LD_EXP 59
64990: PUSH
64991: LD_VAR 0 1
64995: ARRAY
64996: PPUSH
64997: LD_INT 30
64999: PUSH
65000: LD_INT 3
65002: PUSH
65003: EMPTY
65004: LIST
65005: LIST
65006: PPUSH
65007: CALL_OW 72
65011: AND
65012: PUSH
65013: LD_EXP 64
65017: PUSH
65018: LD_VAR 0 1
65022: ARRAY
65023: NOT
65024: AND
65025: IFFALSE 65690
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
65027: LD_ADDR_EXP 101
65031: PUSH
65032: LD_EXP 101
65036: PPUSH
65037: LD_VAR 0 1
65041: PPUSH
65042: LD_INT 6
65044: PPUSH
65045: CALL_OW 1
65049: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65050: LD_ADDR_VAR 0 2
65054: PUSH
65055: LD_INT 0
65057: PUSH
65058: LD_INT 0
65060: PUSH
65061: LD_INT 0
65063: PUSH
65064: LD_INT 0
65066: PUSH
65067: EMPTY
65068: LIST
65069: LIST
65070: LIST
65071: LIST
65072: ST_TO_ADDR
// if sci >= 1 then
65073: LD_VAR 0 8
65077: PUSH
65078: LD_INT 1
65080: GREATEREQUAL
65081: IFFALSE 65103
// tmp := tmp diff sci [ 1 ] ;
65083: LD_ADDR_VAR 0 4
65087: PUSH
65088: LD_VAR 0 4
65092: PUSH
65093: LD_VAR 0 8
65097: PUSH
65098: LD_INT 1
65100: ARRAY
65101: DIFF
65102: ST_TO_ADDR
// if tmp and not sci then
65103: LD_VAR 0 4
65107: PUSH
65108: LD_VAR 0 8
65112: NOT
65113: AND
65114: IFFALSE 65183
// begin sort := SortBySkill ( tmp , 4 ) ;
65116: LD_ADDR_VAR 0 9
65120: PUSH
65121: LD_VAR 0 4
65125: PPUSH
65126: LD_INT 4
65128: PPUSH
65129: CALL 55773 0 2
65133: ST_TO_ADDR
// if sort then
65134: LD_VAR 0 9
65138: IFFALSE 65154
// p := sort [ 1 ] ;
65140: LD_ADDR_VAR 0 11
65144: PUSH
65145: LD_VAR 0 9
65149: PUSH
65150: LD_INT 1
65152: ARRAY
65153: ST_TO_ADDR
// if p then
65154: LD_VAR 0 11
65158: IFFALSE 65183
// result := Replace ( result , 4 , p ) ;
65160: LD_ADDR_VAR 0 2
65164: PUSH
65165: LD_VAR 0 2
65169: PPUSH
65170: LD_INT 4
65172: PPUSH
65173: LD_VAR 0 11
65177: PPUSH
65178: CALL_OW 1
65182: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
65183: LD_ADDR_VAR 0 4
65187: PUSH
65188: LD_VAR 0 4
65192: PUSH
65193: LD_VAR 0 7
65197: DIFF
65198: ST_TO_ADDR
// if tmp and mech < 6 then
65199: LD_VAR 0 4
65203: PUSH
65204: LD_VAR 0 7
65208: PUSH
65209: LD_INT 6
65211: LESS
65212: AND
65213: IFFALSE 65395
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
65215: LD_ADDR_VAR 0 9
65219: PUSH
65220: LD_VAR 0 4
65224: PUSH
65225: LD_VAR 0 7
65229: DIFF
65230: PPUSH
65231: LD_INT 3
65233: PPUSH
65234: CALL 55773 0 2
65238: ST_TO_ADDR
// p := [ ] ;
65239: LD_ADDR_VAR 0 11
65243: PUSH
65244: EMPTY
65245: ST_TO_ADDR
// if sort then
65246: LD_VAR 0 9
65250: IFFALSE 65366
// for i = 1 to 6 - mech do
65252: LD_ADDR_VAR 0 3
65256: PUSH
65257: DOUBLE
65258: LD_INT 1
65260: DEC
65261: ST_TO_ADDR
65262: LD_INT 6
65264: PUSH
65265: LD_VAR 0 7
65269: MINUS
65270: PUSH
65271: FOR_TO
65272: IFFALSE 65364
// begin if i = sort then
65274: LD_VAR 0 3
65278: PUSH
65279: LD_VAR 0 9
65283: EQUAL
65284: IFFALSE 65288
// break ;
65286: GO 65364
// if GetClass ( i ) = 3 then
65288: LD_VAR 0 3
65292: PPUSH
65293: CALL_OW 257
65297: PUSH
65298: LD_INT 3
65300: EQUAL
65301: IFFALSE 65305
// continue ;
65303: GO 65271
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65305: LD_ADDR_VAR 0 11
65309: PUSH
65310: LD_VAR 0 11
65314: PPUSH
65315: LD_VAR 0 11
65319: PUSH
65320: LD_INT 1
65322: PLUS
65323: PPUSH
65324: LD_VAR 0 9
65328: PUSH
65329: LD_VAR 0 3
65333: ARRAY
65334: PPUSH
65335: CALL_OW 2
65339: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65340: LD_ADDR_VAR 0 4
65344: PUSH
65345: LD_VAR 0 4
65349: PUSH
65350: LD_VAR 0 9
65354: PUSH
65355: LD_VAR 0 3
65359: ARRAY
65360: DIFF
65361: ST_TO_ADDR
// end ;
65362: GO 65271
65364: POP
65365: POP
// if p then
65366: LD_VAR 0 11
65370: IFFALSE 65395
// result := Replace ( result , 3 , p ) ;
65372: LD_ADDR_VAR 0 2
65376: PUSH
65377: LD_VAR 0 2
65381: PPUSH
65382: LD_INT 3
65384: PPUSH
65385: LD_VAR 0 11
65389: PPUSH
65390: CALL_OW 1
65394: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65395: LD_ADDR_VAR 0 4
65399: PUSH
65400: LD_VAR 0 4
65404: PUSH
65405: LD_VAR 0 6
65409: DIFF
65410: ST_TO_ADDR
// if tmp and eng < 4 then
65411: LD_VAR 0 4
65415: PUSH
65416: LD_VAR 0 6
65420: PUSH
65421: LD_INT 4
65423: LESS
65424: AND
65425: IFFALSE 65615
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65427: LD_ADDR_VAR 0 9
65431: PUSH
65432: LD_VAR 0 4
65436: PUSH
65437: LD_VAR 0 7
65441: PUSH
65442: LD_VAR 0 6
65446: UNION
65447: DIFF
65448: PPUSH
65449: LD_INT 2
65451: PPUSH
65452: CALL 55773 0 2
65456: ST_TO_ADDR
// p := [ ] ;
65457: LD_ADDR_VAR 0 11
65461: PUSH
65462: EMPTY
65463: ST_TO_ADDR
// if sort then
65464: LD_VAR 0 9
65468: IFFALSE 65584
// for i = 1 to 4 - eng do
65470: LD_ADDR_VAR 0 3
65474: PUSH
65475: DOUBLE
65476: LD_INT 1
65478: DEC
65479: ST_TO_ADDR
65480: LD_INT 4
65482: PUSH
65483: LD_VAR 0 6
65487: MINUS
65488: PUSH
65489: FOR_TO
65490: IFFALSE 65582
// begin if i = sort then
65492: LD_VAR 0 3
65496: PUSH
65497: LD_VAR 0 9
65501: EQUAL
65502: IFFALSE 65506
// break ;
65504: GO 65582
// if GetClass ( i ) = 2 then
65506: LD_VAR 0 3
65510: PPUSH
65511: CALL_OW 257
65515: PUSH
65516: LD_INT 2
65518: EQUAL
65519: IFFALSE 65523
// continue ;
65521: GO 65489
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65523: LD_ADDR_VAR 0 11
65527: PUSH
65528: LD_VAR 0 11
65532: PPUSH
65533: LD_VAR 0 11
65537: PUSH
65538: LD_INT 1
65540: PLUS
65541: PPUSH
65542: LD_VAR 0 9
65546: PUSH
65547: LD_VAR 0 3
65551: ARRAY
65552: PPUSH
65553: CALL_OW 2
65557: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65558: LD_ADDR_VAR 0 4
65562: PUSH
65563: LD_VAR 0 4
65567: PUSH
65568: LD_VAR 0 9
65572: PUSH
65573: LD_VAR 0 3
65577: ARRAY
65578: DIFF
65579: ST_TO_ADDR
// end ;
65580: GO 65489
65582: POP
65583: POP
// if p then
65584: LD_VAR 0 11
65588: IFFALSE 65613
// result := Replace ( result , 2 , p ) ;
65590: LD_ADDR_VAR 0 2
65594: PUSH
65595: LD_VAR 0 2
65599: PPUSH
65600: LD_INT 2
65602: PPUSH
65603: LD_VAR 0 11
65607: PPUSH
65608: CALL_OW 1
65612: ST_TO_ADDR
// end else
65613: GO 65659
// for i = eng downto 5 do
65615: LD_ADDR_VAR 0 3
65619: PUSH
65620: DOUBLE
65621: LD_VAR 0 6
65625: INC
65626: ST_TO_ADDR
65627: LD_INT 5
65629: PUSH
65630: FOR_DOWNTO
65631: IFFALSE 65657
// tmp := tmp union eng [ i ] ;
65633: LD_ADDR_VAR 0 4
65637: PUSH
65638: LD_VAR 0 4
65642: PUSH
65643: LD_VAR 0 6
65647: PUSH
65648: LD_VAR 0 3
65652: ARRAY
65653: UNION
65654: ST_TO_ADDR
65655: GO 65630
65657: POP
65658: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65659: LD_ADDR_VAR 0 2
65663: PUSH
65664: LD_VAR 0 2
65668: PPUSH
65669: LD_INT 1
65671: PPUSH
65672: LD_VAR 0 4
65676: PUSH
65677: LD_VAR 0 5
65681: DIFF
65682: PPUSH
65683: CALL_OW 1
65687: ST_TO_ADDR
// exit ;
65688: GO 65690
// end ; end ;
65690: LD_VAR 0 2
65694: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65695: LD_INT 0
65697: PPUSH
65698: PPUSH
65699: PPUSH
// if not mc_bases then
65700: LD_EXP 59
65704: NOT
65705: IFFALSE 65709
// exit ;
65707: GO 65815
// for i = 1 to mc_bases do
65709: LD_ADDR_VAR 0 2
65713: PUSH
65714: DOUBLE
65715: LD_INT 1
65717: DEC
65718: ST_TO_ADDR
65719: LD_EXP 59
65723: PUSH
65724: FOR_TO
65725: IFFALSE 65806
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65727: LD_ADDR_VAR 0 3
65731: PUSH
65732: LD_EXP 59
65736: PUSH
65737: LD_VAR 0 2
65741: ARRAY
65742: PPUSH
65743: LD_INT 21
65745: PUSH
65746: LD_INT 3
65748: PUSH
65749: EMPTY
65750: LIST
65751: LIST
65752: PUSH
65753: LD_INT 3
65755: PUSH
65756: LD_INT 24
65758: PUSH
65759: LD_INT 1000
65761: PUSH
65762: EMPTY
65763: LIST
65764: LIST
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: EMPTY
65771: LIST
65772: LIST
65773: PPUSH
65774: CALL_OW 72
65778: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65779: LD_ADDR_EXP 60
65783: PUSH
65784: LD_EXP 60
65788: PPUSH
65789: LD_VAR 0 2
65793: PPUSH
65794: LD_VAR 0 3
65798: PPUSH
65799: CALL_OW 1
65803: ST_TO_ADDR
// end ;
65804: GO 65724
65806: POP
65807: POP
// RaiseSailEvent ( 101 ) ;
65808: LD_INT 101
65810: PPUSH
65811: CALL_OW 427
// end ;
65815: LD_VAR 0 1
65819: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65820: LD_INT 0
65822: PPUSH
65823: PPUSH
65824: PPUSH
65825: PPUSH
65826: PPUSH
65827: PPUSH
65828: PPUSH
// if not mc_bases then
65829: LD_EXP 59
65833: NOT
65834: IFFALSE 65838
// exit ;
65836: GO 66411
// for i = 1 to mc_bases do
65838: LD_ADDR_VAR 0 2
65842: PUSH
65843: DOUBLE
65844: LD_INT 1
65846: DEC
65847: ST_TO_ADDR
65848: LD_EXP 59
65852: PUSH
65853: FOR_TO
65854: IFFALSE 66402
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65856: LD_ADDR_VAR 0 5
65860: PUSH
65861: LD_EXP 59
65865: PUSH
65866: LD_VAR 0 2
65870: ARRAY
65871: PUSH
65872: LD_EXP 88
65876: PUSH
65877: LD_VAR 0 2
65881: ARRAY
65882: UNION
65883: PPUSH
65884: LD_INT 21
65886: PUSH
65887: LD_INT 1
65889: PUSH
65890: EMPTY
65891: LIST
65892: LIST
65893: PUSH
65894: LD_INT 1
65896: PUSH
65897: LD_INT 3
65899: PUSH
65900: LD_INT 54
65902: PUSH
65903: EMPTY
65904: LIST
65905: PUSH
65906: EMPTY
65907: LIST
65908: LIST
65909: PUSH
65910: LD_INT 3
65912: PUSH
65913: LD_INT 24
65915: PUSH
65916: LD_INT 800
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PUSH
65923: EMPTY
65924: LIST
65925: LIST
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: LIST
65931: PUSH
65932: EMPTY
65933: LIST
65934: LIST
65935: PPUSH
65936: CALL_OW 72
65940: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65941: LD_ADDR_VAR 0 6
65945: PUSH
65946: LD_EXP 59
65950: PUSH
65951: LD_VAR 0 2
65955: ARRAY
65956: PPUSH
65957: LD_INT 21
65959: PUSH
65960: LD_INT 1
65962: PUSH
65963: EMPTY
65964: LIST
65965: LIST
65966: PUSH
65967: LD_INT 1
65969: PUSH
65970: LD_INT 3
65972: PUSH
65973: LD_INT 54
65975: PUSH
65976: EMPTY
65977: LIST
65978: PUSH
65979: EMPTY
65980: LIST
65981: LIST
65982: PUSH
65983: LD_INT 3
65985: PUSH
65986: LD_INT 24
65988: PUSH
65989: LD_INT 250
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: PUSH
65996: EMPTY
65997: LIST
65998: LIST
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: LIST
66004: PUSH
66005: EMPTY
66006: LIST
66007: LIST
66008: PPUSH
66009: CALL_OW 72
66013: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
66014: LD_ADDR_VAR 0 7
66018: PUSH
66019: LD_VAR 0 5
66023: PUSH
66024: LD_VAR 0 6
66028: DIFF
66029: ST_TO_ADDR
// if not need_heal_1 then
66030: LD_VAR 0 6
66034: NOT
66035: IFFALSE 66068
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
66037: LD_ADDR_EXP 62
66041: PUSH
66042: LD_EXP 62
66046: PPUSH
66047: LD_VAR 0 2
66051: PUSH
66052: LD_INT 1
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: PPUSH
66059: EMPTY
66060: PPUSH
66061: CALL 21525 0 3
66065: ST_TO_ADDR
66066: GO 66138
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
66068: LD_ADDR_EXP 62
66072: PUSH
66073: LD_EXP 62
66077: PPUSH
66078: LD_VAR 0 2
66082: PUSH
66083: LD_INT 1
66085: PUSH
66086: EMPTY
66087: LIST
66088: LIST
66089: PPUSH
66090: LD_EXP 62
66094: PUSH
66095: LD_VAR 0 2
66099: ARRAY
66100: PUSH
66101: LD_INT 1
66103: ARRAY
66104: PPUSH
66105: LD_INT 3
66107: PUSH
66108: LD_INT 24
66110: PUSH
66111: LD_INT 1000
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: PPUSH
66122: CALL_OW 72
66126: PUSH
66127: LD_VAR 0 6
66131: UNION
66132: PPUSH
66133: CALL 21525 0 3
66137: ST_TO_ADDR
// if not need_heal_2 then
66138: LD_VAR 0 7
66142: NOT
66143: IFFALSE 66176
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
66145: LD_ADDR_EXP 62
66149: PUSH
66150: LD_EXP 62
66154: PPUSH
66155: LD_VAR 0 2
66159: PUSH
66160: LD_INT 2
66162: PUSH
66163: EMPTY
66164: LIST
66165: LIST
66166: PPUSH
66167: EMPTY
66168: PPUSH
66169: CALL 21525 0 3
66173: ST_TO_ADDR
66174: GO 66208
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
66176: LD_ADDR_EXP 62
66180: PUSH
66181: LD_EXP 62
66185: PPUSH
66186: LD_VAR 0 2
66190: PUSH
66191: LD_INT 2
66193: PUSH
66194: EMPTY
66195: LIST
66196: LIST
66197: PPUSH
66198: LD_VAR 0 7
66202: PPUSH
66203: CALL 21525 0 3
66207: ST_TO_ADDR
// if need_heal_2 then
66208: LD_VAR 0 7
66212: IFFALSE 66384
// for j in need_heal_2 do
66214: LD_ADDR_VAR 0 3
66218: PUSH
66219: LD_VAR 0 7
66223: PUSH
66224: FOR_IN
66225: IFFALSE 66382
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
66227: LD_ADDR_VAR 0 5
66231: PUSH
66232: LD_EXP 59
66236: PUSH
66237: LD_VAR 0 2
66241: ARRAY
66242: PPUSH
66243: LD_INT 2
66245: PUSH
66246: LD_INT 30
66248: PUSH
66249: LD_INT 6
66251: PUSH
66252: EMPTY
66253: LIST
66254: LIST
66255: PUSH
66256: LD_INT 30
66258: PUSH
66259: LD_INT 7
66261: PUSH
66262: EMPTY
66263: LIST
66264: LIST
66265: PUSH
66266: LD_INT 30
66268: PUSH
66269: LD_INT 8
66271: PUSH
66272: EMPTY
66273: LIST
66274: LIST
66275: PUSH
66276: LD_INT 30
66278: PUSH
66279: LD_INT 0
66281: PUSH
66282: EMPTY
66283: LIST
66284: LIST
66285: PUSH
66286: LD_INT 30
66288: PUSH
66289: LD_INT 1
66291: PUSH
66292: EMPTY
66293: LIST
66294: LIST
66295: PUSH
66296: LD_INT 25
66298: PUSH
66299: LD_INT 4
66301: PUSH
66302: EMPTY
66303: LIST
66304: LIST
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: LIST
66310: LIST
66311: LIST
66312: LIST
66313: LIST
66314: PPUSH
66315: CALL_OW 72
66319: ST_TO_ADDR
// if tmp then
66320: LD_VAR 0 5
66324: IFFALSE 66380
// begin k := NearestUnitToUnit ( tmp , j ) ;
66326: LD_ADDR_VAR 0 4
66330: PUSH
66331: LD_VAR 0 5
66335: PPUSH
66336: LD_VAR 0 3
66340: PPUSH
66341: CALL_OW 74
66345: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
66346: LD_VAR 0 3
66350: PPUSH
66351: LD_VAR 0 4
66355: PPUSH
66356: CALL_OW 296
66360: PUSH
66361: LD_INT 7
66363: GREATER
66364: IFFALSE 66380
// ComMoveUnit ( j , k ) ;
66366: LD_VAR 0 3
66370: PPUSH
66371: LD_VAR 0 4
66375: PPUSH
66376: CALL_OW 112
// end ; end ;
66380: GO 66224
66382: POP
66383: POP
// if not need_heal_1 and not need_heal_2 then
66384: LD_VAR 0 6
66388: NOT
66389: PUSH
66390: LD_VAR 0 7
66394: NOT
66395: AND
66396: IFFALSE 66400
// continue ;
66398: GO 65853
// end ;
66400: GO 65853
66402: POP
66403: POP
// RaiseSailEvent ( 102 ) ;
66404: LD_INT 102
66406: PPUSH
66407: CALL_OW 427
// end ;
66411: LD_VAR 0 1
66415: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
66416: LD_INT 0
66418: PPUSH
66419: PPUSH
66420: PPUSH
66421: PPUSH
66422: PPUSH
66423: PPUSH
// if not mc_bases then
66424: LD_EXP 59
66428: NOT
66429: IFFALSE 66433
// exit ;
66431: GO 67143
// for i = 1 to mc_bases do
66433: LD_ADDR_VAR 0 2
66437: PUSH
66438: DOUBLE
66439: LD_INT 1
66441: DEC
66442: ST_TO_ADDR
66443: LD_EXP 59
66447: PUSH
66448: FOR_TO
66449: IFFALSE 67141
// begin if not mc_building_need_repair [ i ] then
66451: LD_EXP 60
66455: PUSH
66456: LD_VAR 0 2
66460: ARRAY
66461: NOT
66462: IFFALSE 66636
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
66464: LD_ADDR_VAR 0 6
66468: PUSH
66469: LD_EXP 78
66473: PUSH
66474: LD_VAR 0 2
66478: ARRAY
66479: PPUSH
66480: LD_INT 3
66482: PUSH
66483: LD_INT 24
66485: PUSH
66486: LD_INT 1000
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: EMPTY
66494: LIST
66495: LIST
66496: PUSH
66497: LD_INT 2
66499: PUSH
66500: LD_INT 34
66502: PUSH
66503: LD_INT 13
66505: PUSH
66506: EMPTY
66507: LIST
66508: LIST
66509: PUSH
66510: LD_INT 34
66512: PUSH
66513: LD_INT 52
66515: PUSH
66516: EMPTY
66517: LIST
66518: LIST
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: LIST
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PPUSH
66529: CALL_OW 72
66533: ST_TO_ADDR
// if cranes then
66534: LD_VAR 0 6
66538: IFFALSE 66600
// for j in cranes do
66540: LD_ADDR_VAR 0 3
66544: PUSH
66545: LD_VAR 0 6
66549: PUSH
66550: FOR_IN
66551: IFFALSE 66598
// if not IsInArea ( j , mc_parking [ i ] ) then
66553: LD_VAR 0 3
66557: PPUSH
66558: LD_EXP 83
66562: PUSH
66563: LD_VAR 0 2
66567: ARRAY
66568: PPUSH
66569: CALL_OW 308
66573: NOT
66574: IFFALSE 66596
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66576: LD_VAR 0 3
66580: PPUSH
66581: LD_EXP 83
66585: PUSH
66586: LD_VAR 0 2
66590: ARRAY
66591: PPUSH
66592: CALL_OW 113
66596: GO 66550
66598: POP
66599: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66600: LD_ADDR_EXP 61
66604: PUSH
66605: LD_EXP 61
66609: PPUSH
66610: LD_VAR 0 2
66614: PPUSH
66615: EMPTY
66616: PPUSH
66617: CALL_OW 1
66621: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66622: LD_VAR 0 2
66626: PPUSH
66627: LD_INT 101
66629: PPUSH
66630: CALL 61528 0 2
// continue ;
66634: GO 66448
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66636: LD_ADDR_EXP 65
66640: PUSH
66641: LD_EXP 65
66645: PPUSH
66646: LD_VAR 0 2
66650: PPUSH
66651: EMPTY
66652: PPUSH
66653: CALL_OW 1
66657: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66658: LD_VAR 0 2
66662: PPUSH
66663: LD_INT 103
66665: PPUSH
66666: CALL 61528 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66670: LD_ADDR_VAR 0 5
66674: PUSH
66675: LD_EXP 59
66679: PUSH
66680: LD_VAR 0 2
66684: ARRAY
66685: PUSH
66686: LD_EXP 88
66690: PUSH
66691: LD_VAR 0 2
66695: ARRAY
66696: UNION
66697: PPUSH
66698: LD_INT 2
66700: PUSH
66701: LD_INT 25
66703: PUSH
66704: LD_INT 2
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: PUSH
66711: LD_INT 25
66713: PUSH
66714: LD_INT 16
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: PUSH
66721: EMPTY
66722: LIST
66723: LIST
66724: LIST
66725: PUSH
66726: EMPTY
66727: LIST
66728: PPUSH
66729: CALL_OW 72
66733: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66734: LD_ADDR_VAR 0 6
66738: PUSH
66739: LD_EXP 78
66743: PUSH
66744: LD_VAR 0 2
66748: ARRAY
66749: PPUSH
66750: LD_INT 2
66752: PUSH
66753: LD_INT 34
66755: PUSH
66756: LD_INT 13
66758: PUSH
66759: EMPTY
66760: LIST
66761: LIST
66762: PUSH
66763: LD_INT 34
66765: PUSH
66766: LD_INT 52
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: PUSH
66773: EMPTY
66774: LIST
66775: LIST
66776: LIST
66777: PPUSH
66778: CALL_OW 72
66782: ST_TO_ADDR
// if cranes then
66783: LD_VAR 0 6
66787: IFFALSE 66923
// begin for j in cranes do
66789: LD_ADDR_VAR 0 3
66793: PUSH
66794: LD_VAR 0 6
66798: PUSH
66799: FOR_IN
66800: IFFALSE 66921
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66802: LD_VAR 0 3
66806: PPUSH
66807: CALL_OW 256
66811: PUSH
66812: LD_INT 500
66814: GREATEREQUAL
66815: PUSH
66816: LD_VAR 0 3
66820: PPUSH
66821: CALL_OW 314
66825: NOT
66826: AND
66827: IFFALSE 66861
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66829: LD_VAR 0 3
66833: PPUSH
66834: LD_EXP 60
66838: PUSH
66839: LD_VAR 0 2
66843: ARRAY
66844: PPUSH
66845: LD_VAR 0 3
66849: PPUSH
66850: CALL_OW 74
66854: PPUSH
66855: CALL_OW 130
66859: GO 66919
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66861: LD_VAR 0 3
66865: PPUSH
66866: CALL_OW 256
66870: PUSH
66871: LD_INT 500
66873: LESS
66874: PUSH
66875: LD_VAR 0 3
66879: PPUSH
66880: LD_EXP 83
66884: PUSH
66885: LD_VAR 0 2
66889: ARRAY
66890: PPUSH
66891: CALL_OW 308
66895: NOT
66896: AND
66897: IFFALSE 66919
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66899: LD_VAR 0 3
66903: PPUSH
66904: LD_EXP 83
66908: PUSH
66909: LD_VAR 0 2
66913: ARRAY
66914: PPUSH
66915: CALL_OW 113
66919: GO 66799
66921: POP
66922: POP
// end ; if not tmp then
66923: LD_VAR 0 5
66927: NOT
66928: IFFALSE 66932
// continue ;
66930: GO 66448
// for j in tmp do
66932: LD_ADDR_VAR 0 3
66936: PUSH
66937: LD_VAR 0 5
66941: PUSH
66942: FOR_IN
66943: IFFALSE 67137
// begin if mc_need_heal [ i ] then
66945: LD_EXP 62
66949: PUSH
66950: LD_VAR 0 2
66954: ARRAY
66955: IFFALSE 67003
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
66957: LD_VAR 0 3
66961: PUSH
66962: LD_EXP 62
66966: PUSH
66967: LD_VAR 0 2
66971: ARRAY
66972: PUSH
66973: LD_INT 1
66975: ARRAY
66976: IN
66977: PUSH
66978: LD_VAR 0 3
66982: PUSH
66983: LD_EXP 62
66987: PUSH
66988: LD_VAR 0 2
66992: ARRAY
66993: PUSH
66994: LD_INT 2
66996: ARRAY
66997: IN
66998: OR
66999: IFFALSE 67003
// continue ;
67001: GO 66942
// if IsInUnit ( j ) then
67003: LD_VAR 0 3
67007: PPUSH
67008: CALL_OW 310
67012: IFFALSE 67023
// ComExitBuilding ( j ) ;
67014: LD_VAR 0 3
67018: PPUSH
67019: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
67023: LD_VAR 0 3
67027: PUSH
67028: LD_EXP 61
67032: PUSH
67033: LD_VAR 0 2
67037: ARRAY
67038: IN
67039: NOT
67040: IFFALSE 67098
// begin SetTag ( j , 101 ) ;
67042: LD_VAR 0 3
67046: PPUSH
67047: LD_INT 101
67049: PPUSH
67050: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
67054: LD_ADDR_EXP 61
67058: PUSH
67059: LD_EXP 61
67063: PPUSH
67064: LD_VAR 0 2
67068: PUSH
67069: LD_EXP 61
67073: PUSH
67074: LD_VAR 0 2
67078: ARRAY
67079: PUSH
67080: LD_INT 1
67082: PLUS
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: PPUSH
67088: LD_VAR 0 3
67092: PPUSH
67093: CALL 21525 0 3
67097: ST_TO_ADDR
// end ; wait ( 1 ) ;
67098: LD_INT 1
67100: PPUSH
67101: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
67105: LD_VAR 0 3
67109: PPUSH
67110: LD_EXP 60
67114: PUSH
67115: LD_VAR 0 2
67119: ARRAY
67120: PPUSH
67121: LD_VAR 0 3
67125: PPUSH
67126: CALL_OW 74
67130: PPUSH
67131: CALL_OW 130
// end ;
67135: GO 66942
67137: POP
67138: POP
// end ;
67139: GO 66448
67141: POP
67142: POP
// end ;
67143: LD_VAR 0 1
67147: RET
// export function MC_Heal ; var i , j , tmp ; begin
67148: LD_INT 0
67150: PPUSH
67151: PPUSH
67152: PPUSH
67153: PPUSH
// if not mc_bases then
67154: LD_EXP 59
67158: NOT
67159: IFFALSE 67163
// exit ;
67161: GO 67565
// for i = 1 to mc_bases do
67163: LD_ADDR_VAR 0 2
67167: PUSH
67168: DOUBLE
67169: LD_INT 1
67171: DEC
67172: ST_TO_ADDR
67173: LD_EXP 59
67177: PUSH
67178: FOR_TO
67179: IFFALSE 67563
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
67181: LD_EXP 62
67185: PUSH
67186: LD_VAR 0 2
67190: ARRAY
67191: PUSH
67192: LD_INT 1
67194: ARRAY
67195: NOT
67196: PUSH
67197: LD_EXP 62
67201: PUSH
67202: LD_VAR 0 2
67206: ARRAY
67207: PUSH
67208: LD_INT 2
67210: ARRAY
67211: NOT
67212: AND
67213: IFFALSE 67251
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
67215: LD_ADDR_EXP 63
67219: PUSH
67220: LD_EXP 63
67224: PPUSH
67225: LD_VAR 0 2
67229: PPUSH
67230: EMPTY
67231: PPUSH
67232: CALL_OW 1
67236: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
67237: LD_VAR 0 2
67241: PPUSH
67242: LD_INT 102
67244: PPUSH
67245: CALL 61528 0 2
// continue ;
67249: GO 67178
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67251: LD_ADDR_VAR 0 4
67255: PUSH
67256: LD_EXP 59
67260: PUSH
67261: LD_VAR 0 2
67265: ARRAY
67266: PPUSH
67267: LD_INT 25
67269: PUSH
67270: LD_INT 4
67272: PUSH
67273: EMPTY
67274: LIST
67275: LIST
67276: PPUSH
67277: CALL_OW 72
67281: ST_TO_ADDR
// if not tmp then
67282: LD_VAR 0 4
67286: NOT
67287: IFFALSE 67291
// continue ;
67289: GO 67178
// if mc_taming [ i ] then
67291: LD_EXP 90
67295: PUSH
67296: LD_VAR 0 2
67300: ARRAY
67301: IFFALSE 67325
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67303: LD_ADDR_EXP 90
67307: PUSH
67308: LD_EXP 90
67312: PPUSH
67313: LD_VAR 0 2
67317: PPUSH
67318: EMPTY
67319: PPUSH
67320: CALL_OW 1
67324: ST_TO_ADDR
// for j in tmp do
67325: LD_ADDR_VAR 0 3
67329: PUSH
67330: LD_VAR 0 4
67334: PUSH
67335: FOR_IN
67336: IFFALSE 67559
// begin if IsInUnit ( j ) then
67338: LD_VAR 0 3
67342: PPUSH
67343: CALL_OW 310
67347: IFFALSE 67358
// ComExitBuilding ( j ) ;
67349: LD_VAR 0 3
67353: PPUSH
67354: CALL_OW 122
// if not j in mc_healers [ i ] then
67358: LD_VAR 0 3
67362: PUSH
67363: LD_EXP 63
67367: PUSH
67368: LD_VAR 0 2
67372: ARRAY
67373: IN
67374: NOT
67375: IFFALSE 67421
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67377: LD_ADDR_EXP 63
67381: PUSH
67382: LD_EXP 63
67386: PPUSH
67387: LD_VAR 0 2
67391: PUSH
67392: LD_EXP 63
67396: PUSH
67397: LD_VAR 0 2
67401: ARRAY
67402: PUSH
67403: LD_INT 1
67405: PLUS
67406: PUSH
67407: EMPTY
67408: LIST
67409: LIST
67410: PPUSH
67411: LD_VAR 0 3
67415: PPUSH
67416: CALL 21525 0 3
67420: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67421: LD_VAR 0 3
67425: PPUSH
67426: CALL_OW 110
67430: PUSH
67431: LD_INT 102
67433: NONEQUAL
67434: IFFALSE 67448
// SetTag ( j , 102 ) ;
67436: LD_VAR 0 3
67440: PPUSH
67441: LD_INT 102
67443: PPUSH
67444: CALL_OW 109
// Wait ( 3 ) ;
67448: LD_INT 3
67450: PPUSH
67451: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67455: LD_EXP 62
67459: PUSH
67460: LD_VAR 0 2
67464: ARRAY
67465: PUSH
67466: LD_INT 1
67468: ARRAY
67469: IFFALSE 67501
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67471: LD_VAR 0 3
67475: PPUSH
67476: LD_EXP 62
67480: PUSH
67481: LD_VAR 0 2
67485: ARRAY
67486: PUSH
67487: LD_INT 1
67489: ARRAY
67490: PUSH
67491: LD_INT 1
67493: ARRAY
67494: PPUSH
67495: CALL_OW 128
67499: GO 67557
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67501: LD_VAR 0 3
67505: PPUSH
67506: CALL_OW 314
67510: NOT
67511: PUSH
67512: LD_EXP 62
67516: PUSH
67517: LD_VAR 0 2
67521: ARRAY
67522: PUSH
67523: LD_INT 2
67525: ARRAY
67526: AND
67527: IFFALSE 67557
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67529: LD_VAR 0 3
67533: PPUSH
67534: LD_EXP 62
67538: PUSH
67539: LD_VAR 0 2
67543: ARRAY
67544: PUSH
67545: LD_INT 2
67547: ARRAY
67548: PUSH
67549: LD_INT 1
67551: ARRAY
67552: PPUSH
67553: CALL_OW 128
// end ;
67557: GO 67335
67559: POP
67560: POP
// end ;
67561: GO 67178
67563: POP
67564: POP
// end ;
67565: LD_VAR 0 1
67569: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
67570: LD_INT 0
67572: PPUSH
67573: PPUSH
67574: PPUSH
67575: PPUSH
67576: PPUSH
// if not mc_bases then
67577: LD_EXP 59
67581: NOT
67582: IFFALSE 67586
// exit ;
67584: GO 68729
// for i = 1 to mc_bases do
67586: LD_ADDR_VAR 0 2
67590: PUSH
67591: DOUBLE
67592: LD_INT 1
67594: DEC
67595: ST_TO_ADDR
67596: LD_EXP 59
67600: PUSH
67601: FOR_TO
67602: IFFALSE 68727
// begin if mc_scan [ i ] then
67604: LD_EXP 82
67608: PUSH
67609: LD_VAR 0 2
67613: ARRAY
67614: IFFALSE 67618
// continue ;
67616: GO 67601
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67618: LD_EXP 64
67622: PUSH
67623: LD_VAR 0 2
67627: ARRAY
67628: NOT
67629: PUSH
67630: LD_EXP 66
67634: PUSH
67635: LD_VAR 0 2
67639: ARRAY
67640: NOT
67641: AND
67642: PUSH
67643: LD_EXP 65
67647: PUSH
67648: LD_VAR 0 2
67652: ARRAY
67653: AND
67654: IFFALSE 67692
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67656: LD_ADDR_EXP 65
67660: PUSH
67661: LD_EXP 65
67665: PPUSH
67666: LD_VAR 0 2
67670: PPUSH
67671: EMPTY
67672: PPUSH
67673: CALL_OW 1
67677: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67678: LD_VAR 0 2
67682: PPUSH
67683: LD_INT 103
67685: PPUSH
67686: CALL 61528 0 2
// continue ;
67690: GO 67601
// end ; if mc_construct_list [ i ] then
67692: LD_EXP 66
67696: PUSH
67697: LD_VAR 0 2
67701: ARRAY
67702: IFFALSE 67922
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67704: LD_ADDR_VAR 0 4
67708: PUSH
67709: LD_EXP 59
67713: PUSH
67714: LD_VAR 0 2
67718: ARRAY
67719: PPUSH
67720: LD_INT 25
67722: PUSH
67723: LD_INT 2
67725: PUSH
67726: EMPTY
67727: LIST
67728: LIST
67729: PPUSH
67730: CALL_OW 72
67734: PUSH
67735: LD_EXP 61
67739: PUSH
67740: LD_VAR 0 2
67744: ARRAY
67745: DIFF
67746: ST_TO_ADDR
// if not tmp then
67747: LD_VAR 0 4
67751: NOT
67752: IFFALSE 67756
// continue ;
67754: GO 67601
// for j in tmp do
67756: LD_ADDR_VAR 0 3
67760: PUSH
67761: LD_VAR 0 4
67765: PUSH
67766: FOR_IN
67767: IFFALSE 67918
// begin if not mc_builders [ i ] then
67769: LD_EXP 65
67773: PUSH
67774: LD_VAR 0 2
67778: ARRAY
67779: NOT
67780: IFFALSE 67838
// begin SetTag ( j , 103 ) ;
67782: LD_VAR 0 3
67786: PPUSH
67787: LD_INT 103
67789: PPUSH
67790: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67794: LD_ADDR_EXP 65
67798: PUSH
67799: LD_EXP 65
67803: PPUSH
67804: LD_VAR 0 2
67808: PUSH
67809: LD_EXP 65
67813: PUSH
67814: LD_VAR 0 2
67818: ARRAY
67819: PUSH
67820: LD_INT 1
67822: PLUS
67823: PUSH
67824: EMPTY
67825: LIST
67826: LIST
67827: PPUSH
67828: LD_VAR 0 3
67832: PPUSH
67833: CALL 21525 0 3
67837: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67838: LD_VAR 0 3
67842: PPUSH
67843: CALL_OW 310
67847: IFFALSE 67858
// ComExitBuilding ( j ) ;
67849: LD_VAR 0 3
67853: PPUSH
67854: CALL_OW 122
// wait ( 3 ) ;
67858: LD_INT 3
67860: PPUSH
67861: CALL_OW 67
// if not mc_construct_list [ i ] then
67865: LD_EXP 66
67869: PUSH
67870: LD_VAR 0 2
67874: ARRAY
67875: NOT
67876: IFFALSE 67880
// break ;
67878: GO 67918
// if not HasTask ( j ) then
67880: LD_VAR 0 3
67884: PPUSH
67885: CALL_OW 314
67889: NOT
67890: IFFALSE 67916
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67892: LD_VAR 0 3
67896: PPUSH
67897: LD_EXP 66
67901: PUSH
67902: LD_VAR 0 2
67906: ARRAY
67907: PUSH
67908: LD_INT 1
67910: ARRAY
67911: PPUSH
67912: CALL 24376 0 2
// end ;
67916: GO 67766
67918: POP
67919: POP
// end else
67920: GO 68725
// if mc_build_list [ i ] then
67922: LD_EXP 64
67926: PUSH
67927: LD_VAR 0 2
67931: ARRAY
67932: IFFALSE 68725
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67934: LD_ADDR_VAR 0 5
67938: PUSH
67939: LD_EXP 59
67943: PUSH
67944: LD_VAR 0 2
67948: ARRAY
67949: PPUSH
67950: LD_INT 2
67952: PUSH
67953: LD_INT 30
67955: PUSH
67956: LD_INT 0
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: PUSH
67963: LD_INT 30
67965: PUSH
67966: LD_INT 1
67968: PUSH
67969: EMPTY
67970: LIST
67971: LIST
67972: PUSH
67973: EMPTY
67974: LIST
67975: LIST
67976: LIST
67977: PPUSH
67978: CALL_OW 72
67982: ST_TO_ADDR
// if depot then
67983: LD_VAR 0 5
67987: IFFALSE 68005
// depot := depot [ 1 ] else
67989: LD_ADDR_VAR 0 5
67993: PUSH
67994: LD_VAR 0 5
67998: PUSH
67999: LD_INT 1
68001: ARRAY
68002: ST_TO_ADDR
68003: GO 68013
// depot := 0 ;
68005: LD_ADDR_VAR 0 5
68009: PUSH
68010: LD_INT 0
68012: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
68013: LD_EXP 64
68017: PUSH
68018: LD_VAR 0 2
68022: ARRAY
68023: PUSH
68024: LD_INT 1
68026: ARRAY
68027: PUSH
68028: LD_INT 1
68030: ARRAY
68031: PPUSH
68032: CALL 24206 0 1
68036: PUSH
68037: LD_EXP 59
68041: PUSH
68042: LD_VAR 0 2
68046: ARRAY
68047: PPUSH
68048: LD_INT 2
68050: PUSH
68051: LD_INT 30
68053: PUSH
68054: LD_INT 2
68056: PUSH
68057: EMPTY
68058: LIST
68059: LIST
68060: PUSH
68061: LD_INT 30
68063: PUSH
68064: LD_INT 3
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: LIST
68075: PPUSH
68076: CALL_OW 72
68080: NOT
68081: AND
68082: IFFALSE 68187
// begin for j = 1 to mc_build_list [ i ] do
68084: LD_ADDR_VAR 0 3
68088: PUSH
68089: DOUBLE
68090: LD_INT 1
68092: DEC
68093: ST_TO_ADDR
68094: LD_EXP 64
68098: PUSH
68099: LD_VAR 0 2
68103: ARRAY
68104: PUSH
68105: FOR_TO
68106: IFFALSE 68185
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
68108: LD_EXP 64
68112: PUSH
68113: LD_VAR 0 2
68117: ARRAY
68118: PUSH
68119: LD_VAR 0 3
68123: ARRAY
68124: PUSH
68125: LD_INT 1
68127: ARRAY
68128: PUSH
68129: LD_INT 2
68131: EQUAL
68132: IFFALSE 68183
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
68134: LD_ADDR_EXP 64
68138: PUSH
68139: LD_EXP 64
68143: PPUSH
68144: LD_VAR 0 2
68148: PPUSH
68149: LD_EXP 64
68153: PUSH
68154: LD_VAR 0 2
68158: ARRAY
68159: PPUSH
68160: LD_VAR 0 3
68164: PPUSH
68165: LD_INT 1
68167: PPUSH
68168: LD_INT 0
68170: PPUSH
68171: CALL 20943 0 4
68175: PPUSH
68176: CALL_OW 1
68180: ST_TO_ADDR
// break ;
68181: GO 68185
// end ;
68183: GO 68105
68185: POP
68186: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
68187: LD_EXP 64
68191: PUSH
68192: LD_VAR 0 2
68196: ARRAY
68197: PUSH
68198: LD_INT 1
68200: ARRAY
68201: PUSH
68202: LD_INT 1
68204: ARRAY
68205: PUSH
68206: LD_INT 0
68208: EQUAL
68209: PUSH
68210: LD_VAR 0 5
68214: PUSH
68215: LD_VAR 0 5
68219: PPUSH
68220: LD_EXP 64
68224: PUSH
68225: LD_VAR 0 2
68229: ARRAY
68230: PUSH
68231: LD_INT 1
68233: ARRAY
68234: PUSH
68235: LD_INT 1
68237: ARRAY
68238: PPUSH
68239: LD_EXP 64
68243: PUSH
68244: LD_VAR 0 2
68248: ARRAY
68249: PUSH
68250: LD_INT 1
68252: ARRAY
68253: PUSH
68254: LD_INT 2
68256: ARRAY
68257: PPUSH
68258: LD_EXP 64
68262: PUSH
68263: LD_VAR 0 2
68267: ARRAY
68268: PUSH
68269: LD_INT 1
68271: ARRAY
68272: PUSH
68273: LD_INT 3
68275: ARRAY
68276: PPUSH
68277: LD_EXP 64
68281: PUSH
68282: LD_VAR 0 2
68286: ARRAY
68287: PUSH
68288: LD_INT 1
68290: ARRAY
68291: PUSH
68292: LD_INT 4
68294: ARRAY
68295: PPUSH
68296: CALL 28940 0 5
68300: AND
68301: OR
68302: IFFALSE 68583
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68304: LD_ADDR_VAR 0 4
68308: PUSH
68309: LD_EXP 59
68313: PUSH
68314: LD_VAR 0 2
68318: ARRAY
68319: PPUSH
68320: LD_INT 25
68322: PUSH
68323: LD_INT 2
68325: PUSH
68326: EMPTY
68327: LIST
68328: LIST
68329: PPUSH
68330: CALL_OW 72
68334: PUSH
68335: LD_EXP 61
68339: PUSH
68340: LD_VAR 0 2
68344: ARRAY
68345: DIFF
68346: ST_TO_ADDR
// if not tmp then
68347: LD_VAR 0 4
68351: NOT
68352: IFFALSE 68356
// continue ;
68354: GO 67601
// for j in tmp do
68356: LD_ADDR_VAR 0 3
68360: PUSH
68361: LD_VAR 0 4
68365: PUSH
68366: FOR_IN
68367: IFFALSE 68579
// begin if not mc_builders [ i ] then
68369: LD_EXP 65
68373: PUSH
68374: LD_VAR 0 2
68378: ARRAY
68379: NOT
68380: IFFALSE 68438
// begin SetTag ( j , 103 ) ;
68382: LD_VAR 0 3
68386: PPUSH
68387: LD_INT 103
68389: PPUSH
68390: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68394: LD_ADDR_EXP 65
68398: PUSH
68399: LD_EXP 65
68403: PPUSH
68404: LD_VAR 0 2
68408: PUSH
68409: LD_EXP 65
68413: PUSH
68414: LD_VAR 0 2
68418: ARRAY
68419: PUSH
68420: LD_INT 1
68422: PLUS
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: PPUSH
68428: LD_VAR 0 3
68432: PPUSH
68433: CALL 21525 0 3
68437: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68438: LD_VAR 0 3
68442: PPUSH
68443: CALL_OW 310
68447: IFFALSE 68458
// ComExitBuilding ( j ) ;
68449: LD_VAR 0 3
68453: PPUSH
68454: CALL_OW 122
// wait ( 3 ) ;
68458: LD_INT 3
68460: PPUSH
68461: CALL_OW 67
// if not mc_build_list [ i ] then
68465: LD_EXP 64
68469: PUSH
68470: LD_VAR 0 2
68474: ARRAY
68475: NOT
68476: IFFALSE 68480
// break ;
68478: GO 68579
// if not HasTask ( j ) then
68480: LD_VAR 0 3
68484: PPUSH
68485: CALL_OW 314
68489: NOT
68490: IFFALSE 68577
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68492: LD_VAR 0 3
68496: PPUSH
68497: LD_EXP 64
68501: PUSH
68502: LD_VAR 0 2
68506: ARRAY
68507: PUSH
68508: LD_INT 1
68510: ARRAY
68511: PUSH
68512: LD_INT 1
68514: ARRAY
68515: PPUSH
68516: LD_EXP 64
68520: PUSH
68521: LD_VAR 0 2
68525: ARRAY
68526: PUSH
68527: LD_INT 1
68529: ARRAY
68530: PUSH
68531: LD_INT 2
68533: ARRAY
68534: PPUSH
68535: LD_EXP 64
68539: PUSH
68540: LD_VAR 0 2
68544: ARRAY
68545: PUSH
68546: LD_INT 1
68548: ARRAY
68549: PUSH
68550: LD_INT 3
68552: ARRAY
68553: PPUSH
68554: LD_EXP 64
68558: PUSH
68559: LD_VAR 0 2
68563: ARRAY
68564: PUSH
68565: LD_INT 1
68567: ARRAY
68568: PUSH
68569: LD_INT 4
68571: ARRAY
68572: PPUSH
68573: CALL_OW 145
// end ;
68577: GO 68366
68579: POP
68580: POP
// end else
68581: GO 68725
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68583: LD_EXP 59
68587: PUSH
68588: LD_VAR 0 2
68592: ARRAY
68593: PPUSH
68594: LD_EXP 64
68598: PUSH
68599: LD_VAR 0 2
68603: ARRAY
68604: PUSH
68605: LD_INT 1
68607: ARRAY
68608: PUSH
68609: LD_INT 1
68611: ARRAY
68612: PPUSH
68613: LD_EXP 64
68617: PUSH
68618: LD_VAR 0 2
68622: ARRAY
68623: PUSH
68624: LD_INT 1
68626: ARRAY
68627: PUSH
68628: LD_INT 2
68630: ARRAY
68631: PPUSH
68632: LD_EXP 64
68636: PUSH
68637: LD_VAR 0 2
68641: ARRAY
68642: PUSH
68643: LD_INT 1
68645: ARRAY
68646: PUSH
68647: LD_INT 3
68649: ARRAY
68650: PPUSH
68651: LD_EXP 64
68655: PUSH
68656: LD_VAR 0 2
68660: ARRAY
68661: PUSH
68662: LD_INT 1
68664: ARRAY
68665: PUSH
68666: LD_INT 4
68668: ARRAY
68669: PPUSH
68670: CALL 28276 0 5
68674: NOT
68675: IFFALSE 68725
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68677: LD_ADDR_EXP 64
68681: PUSH
68682: LD_EXP 64
68686: PPUSH
68687: LD_VAR 0 2
68691: PPUSH
68692: LD_EXP 64
68696: PUSH
68697: LD_VAR 0 2
68701: ARRAY
68702: PPUSH
68703: LD_INT 1
68705: PPUSH
68706: LD_INT 1
68708: NEG
68709: PPUSH
68710: LD_INT 0
68712: PPUSH
68713: CALL 20943 0 4
68717: PPUSH
68718: CALL_OW 1
68722: ST_TO_ADDR
// continue ;
68723: GO 67601
// end ; end ; end ;
68725: GO 67601
68727: POP
68728: POP
// end ;
68729: LD_VAR 0 1
68733: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68734: LD_INT 0
68736: PPUSH
68737: PPUSH
68738: PPUSH
68739: PPUSH
68740: PPUSH
68741: PPUSH
// if not mc_bases then
68742: LD_EXP 59
68746: NOT
68747: IFFALSE 68751
// exit ;
68749: GO 69178
// for i = 1 to mc_bases do
68751: LD_ADDR_VAR 0 2
68755: PUSH
68756: DOUBLE
68757: LD_INT 1
68759: DEC
68760: ST_TO_ADDR
68761: LD_EXP 59
68765: PUSH
68766: FOR_TO
68767: IFFALSE 69176
// begin tmp := mc_build_upgrade [ i ] ;
68769: LD_ADDR_VAR 0 4
68773: PUSH
68774: LD_EXP 91
68778: PUSH
68779: LD_VAR 0 2
68783: ARRAY
68784: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68785: LD_ADDR_VAR 0 6
68789: PUSH
68790: LD_EXP 92
68794: PUSH
68795: LD_VAR 0 2
68799: ARRAY
68800: PPUSH
68801: LD_INT 2
68803: PUSH
68804: LD_INT 30
68806: PUSH
68807: LD_INT 6
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: LD_INT 30
68816: PUSH
68817: LD_INT 7
68819: PUSH
68820: EMPTY
68821: LIST
68822: LIST
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: LIST
68828: PPUSH
68829: CALL_OW 72
68833: ST_TO_ADDR
// if not tmp and not lab then
68834: LD_VAR 0 4
68838: NOT
68839: PUSH
68840: LD_VAR 0 6
68844: NOT
68845: AND
68846: IFFALSE 68850
// continue ;
68848: GO 68766
// if tmp then
68850: LD_VAR 0 4
68854: IFFALSE 68974
// for j in tmp do
68856: LD_ADDR_VAR 0 3
68860: PUSH
68861: LD_VAR 0 4
68865: PUSH
68866: FOR_IN
68867: IFFALSE 68972
// begin if UpgradeCost ( j ) then
68869: LD_VAR 0 3
68873: PPUSH
68874: CALL 27936 0 1
68878: IFFALSE 68970
// begin ComUpgrade ( j ) ;
68880: LD_VAR 0 3
68884: PPUSH
68885: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68889: LD_ADDR_EXP 91
68893: PUSH
68894: LD_EXP 91
68898: PPUSH
68899: LD_VAR 0 2
68903: PPUSH
68904: LD_EXP 91
68908: PUSH
68909: LD_VAR 0 2
68913: ARRAY
68914: PUSH
68915: LD_VAR 0 3
68919: DIFF
68920: PPUSH
68921: CALL_OW 1
68925: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68926: LD_ADDR_EXP 66
68930: PUSH
68931: LD_EXP 66
68935: PPUSH
68936: LD_VAR 0 2
68940: PUSH
68941: LD_EXP 66
68945: PUSH
68946: LD_VAR 0 2
68950: ARRAY
68951: PUSH
68952: LD_INT 1
68954: PLUS
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: PPUSH
68960: LD_VAR 0 3
68964: PPUSH
68965: CALL 21525 0 3
68969: ST_TO_ADDR
// end ; end ;
68970: GO 68866
68972: POP
68973: POP
// if not lab or not mc_lab_upgrade [ i ] then
68974: LD_VAR 0 6
68978: NOT
68979: PUSH
68980: LD_EXP 93
68984: PUSH
68985: LD_VAR 0 2
68989: ARRAY
68990: NOT
68991: OR
68992: IFFALSE 68996
// continue ;
68994: GO 68766
// for j in lab do
68996: LD_ADDR_VAR 0 3
69000: PUSH
69001: LD_VAR 0 6
69005: PUSH
69006: FOR_IN
69007: IFFALSE 69172
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
69009: LD_VAR 0 3
69013: PPUSH
69014: CALL_OW 266
69018: PUSH
69019: LD_INT 6
69021: PUSH
69022: LD_INT 7
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: IN
69029: PUSH
69030: LD_VAR 0 3
69034: PPUSH
69035: CALL_OW 461
69039: PUSH
69040: LD_INT 1
69042: NONEQUAL
69043: AND
69044: IFFALSE 69170
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
69046: LD_VAR 0 3
69050: PPUSH
69051: LD_EXP 93
69055: PUSH
69056: LD_VAR 0 2
69060: ARRAY
69061: PUSH
69062: LD_INT 1
69064: ARRAY
69065: PPUSH
69066: CALL 28141 0 2
69070: IFFALSE 69170
// begin ComCancel ( j ) ;
69072: LD_VAR 0 3
69076: PPUSH
69077: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
69081: LD_VAR 0 3
69085: PPUSH
69086: LD_EXP 93
69090: PUSH
69091: LD_VAR 0 2
69095: ARRAY
69096: PUSH
69097: LD_INT 1
69099: ARRAY
69100: PPUSH
69101: CALL_OW 207
// if not j in mc_construct_list [ i ] then
69105: LD_VAR 0 3
69109: PUSH
69110: LD_EXP 66
69114: PUSH
69115: LD_VAR 0 2
69119: ARRAY
69120: IN
69121: NOT
69122: IFFALSE 69168
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69124: LD_ADDR_EXP 66
69128: PUSH
69129: LD_EXP 66
69133: PPUSH
69134: LD_VAR 0 2
69138: PUSH
69139: LD_EXP 66
69143: PUSH
69144: LD_VAR 0 2
69148: ARRAY
69149: PUSH
69150: LD_INT 1
69152: PLUS
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PPUSH
69158: LD_VAR 0 3
69162: PPUSH
69163: CALL 21525 0 3
69167: ST_TO_ADDR
// break ;
69168: GO 69172
// end ; end ; end ;
69170: GO 69006
69172: POP
69173: POP
// end ;
69174: GO 68766
69176: POP
69177: POP
// end ;
69178: LD_VAR 0 1
69182: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
69183: LD_INT 0
69185: PPUSH
69186: PPUSH
69187: PPUSH
69188: PPUSH
69189: PPUSH
69190: PPUSH
69191: PPUSH
69192: PPUSH
69193: PPUSH
// if not mc_bases then
69194: LD_EXP 59
69198: NOT
69199: IFFALSE 69203
// exit ;
69201: GO 69608
// for i = 1 to mc_bases do
69203: LD_ADDR_VAR 0 2
69207: PUSH
69208: DOUBLE
69209: LD_INT 1
69211: DEC
69212: ST_TO_ADDR
69213: LD_EXP 59
69217: PUSH
69218: FOR_TO
69219: IFFALSE 69606
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
69221: LD_EXP 67
69225: PUSH
69226: LD_VAR 0 2
69230: ARRAY
69231: NOT
69232: PUSH
69233: LD_EXP 59
69237: PUSH
69238: LD_VAR 0 2
69242: ARRAY
69243: PPUSH
69244: LD_INT 30
69246: PUSH
69247: LD_INT 3
69249: PUSH
69250: EMPTY
69251: LIST
69252: LIST
69253: PPUSH
69254: CALL_OW 72
69258: NOT
69259: OR
69260: IFFALSE 69264
// continue ;
69262: GO 69218
// busy := false ;
69264: LD_ADDR_VAR 0 8
69268: PUSH
69269: LD_INT 0
69271: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69272: LD_ADDR_VAR 0 4
69276: PUSH
69277: LD_EXP 59
69281: PUSH
69282: LD_VAR 0 2
69286: ARRAY
69287: PPUSH
69288: LD_INT 30
69290: PUSH
69291: LD_INT 3
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PPUSH
69298: CALL_OW 72
69302: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69303: LD_ADDR_VAR 0 6
69307: PUSH
69308: LD_EXP 67
69312: PUSH
69313: LD_VAR 0 2
69317: ARRAY
69318: PPUSH
69319: LD_INT 2
69321: PUSH
69322: LD_INT 30
69324: PUSH
69325: LD_INT 32
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 30
69334: PUSH
69335: LD_INT 33
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: LIST
69346: PPUSH
69347: CALL_OW 72
69351: ST_TO_ADDR
// if not t then
69352: LD_VAR 0 6
69356: NOT
69357: IFFALSE 69361
// continue ;
69359: GO 69218
// for j in tmp do
69361: LD_ADDR_VAR 0 3
69365: PUSH
69366: LD_VAR 0 4
69370: PUSH
69371: FOR_IN
69372: IFFALSE 69402
// if not BuildingStatus ( j ) = bs_idle then
69374: LD_VAR 0 3
69378: PPUSH
69379: CALL_OW 461
69383: PUSH
69384: LD_INT 2
69386: EQUAL
69387: NOT
69388: IFFALSE 69400
// begin busy := true ;
69390: LD_ADDR_VAR 0 8
69394: PUSH
69395: LD_INT 1
69397: ST_TO_ADDR
// break ;
69398: GO 69402
// end ;
69400: GO 69371
69402: POP
69403: POP
// if busy then
69404: LD_VAR 0 8
69408: IFFALSE 69412
// continue ;
69410: GO 69218
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69412: LD_ADDR_VAR 0 7
69416: PUSH
69417: LD_VAR 0 6
69421: PPUSH
69422: LD_INT 35
69424: PUSH
69425: LD_INT 0
69427: PUSH
69428: EMPTY
69429: LIST
69430: LIST
69431: PPUSH
69432: CALL_OW 72
69436: ST_TO_ADDR
// if tw then
69437: LD_VAR 0 7
69441: IFFALSE 69518
// begin tw := tw [ 1 ] ;
69443: LD_ADDR_VAR 0 7
69447: PUSH
69448: LD_VAR 0 7
69452: PUSH
69453: LD_INT 1
69455: ARRAY
69456: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69457: LD_ADDR_VAR 0 9
69461: PUSH
69462: LD_VAR 0 7
69466: PPUSH
69467: LD_EXP 84
69471: PUSH
69472: LD_VAR 0 2
69476: ARRAY
69477: PPUSH
69478: CALL 26495 0 2
69482: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69483: LD_EXP 98
69487: PUSH
69488: LD_VAR 0 2
69492: ARRAY
69493: IFFALSE 69516
// if not weapon in mc_allowed_tower_weapons [ i ] then
69495: LD_VAR 0 9
69499: PUSH
69500: LD_EXP 98
69504: PUSH
69505: LD_VAR 0 2
69509: ARRAY
69510: IN
69511: NOT
69512: IFFALSE 69516
// continue ;
69514: GO 69218
// end else
69516: GO 69581
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69518: LD_ADDR_VAR 0 5
69522: PUSH
69523: LD_EXP 67
69527: PUSH
69528: LD_VAR 0 2
69532: ARRAY
69533: PPUSH
69534: LD_VAR 0 4
69538: PPUSH
69539: CALL 56696 0 2
69543: ST_TO_ADDR
// if not tmp2 then
69544: LD_VAR 0 5
69548: NOT
69549: IFFALSE 69553
// continue ;
69551: GO 69218
// tw := tmp2 [ 1 ] ;
69553: LD_ADDR_VAR 0 7
69557: PUSH
69558: LD_VAR 0 5
69562: PUSH
69563: LD_INT 1
69565: ARRAY
69566: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69567: LD_ADDR_VAR 0 9
69571: PUSH
69572: LD_VAR 0 5
69576: PUSH
69577: LD_INT 2
69579: ARRAY
69580: ST_TO_ADDR
// end ; if not weapon then
69581: LD_VAR 0 9
69585: NOT
69586: IFFALSE 69590
// continue ;
69588: GO 69218
// ComPlaceWeapon ( tw , weapon ) ;
69590: LD_VAR 0 7
69594: PPUSH
69595: LD_VAR 0 9
69599: PPUSH
69600: CALL_OW 148
// end ;
69604: GO 69218
69606: POP
69607: POP
// end ;
69608: LD_VAR 0 1
69612: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
69613: LD_INT 0
69615: PPUSH
69616: PPUSH
69617: PPUSH
69618: PPUSH
69619: PPUSH
69620: PPUSH
// if not mc_bases then
69621: LD_EXP 59
69625: NOT
69626: IFFALSE 69630
// exit ;
69628: GO 70642
// for i = 1 to mc_bases do
69630: LD_ADDR_VAR 0 2
69634: PUSH
69635: DOUBLE
69636: LD_INT 1
69638: DEC
69639: ST_TO_ADDR
69640: LD_EXP 59
69644: PUSH
69645: FOR_TO
69646: IFFALSE 70640
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
69648: LD_EXP 72
69652: PUSH
69653: LD_VAR 0 2
69657: ARRAY
69658: NOT
69659: PUSH
69660: LD_EXP 72
69664: PUSH
69665: LD_VAR 0 2
69669: ARRAY
69670: PUSH
69671: LD_EXP 73
69675: PUSH
69676: LD_VAR 0 2
69680: ARRAY
69681: EQUAL
69682: OR
69683: IFFALSE 69687
// continue ;
69685: GO 69645
// if mc_miners [ i ] then
69687: LD_EXP 73
69691: PUSH
69692: LD_VAR 0 2
69696: ARRAY
69697: IFFALSE 70327
// begin k := 1 ;
69699: LD_ADDR_VAR 0 4
69703: PUSH
69704: LD_INT 1
69706: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
69707: LD_ADDR_VAR 0 3
69711: PUSH
69712: DOUBLE
69713: LD_EXP 73
69717: PUSH
69718: LD_VAR 0 2
69722: ARRAY
69723: INC
69724: ST_TO_ADDR
69725: LD_INT 1
69727: PUSH
69728: FOR_DOWNTO
69729: IFFALSE 70325
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69731: LD_EXP 73
69735: PUSH
69736: LD_VAR 0 2
69740: ARRAY
69741: PUSH
69742: LD_VAR 0 3
69746: ARRAY
69747: PPUSH
69748: CALL_OW 301
69752: PUSH
69753: LD_EXP 73
69757: PUSH
69758: LD_VAR 0 2
69762: ARRAY
69763: PUSH
69764: LD_VAR 0 3
69768: ARRAY
69769: PPUSH
69770: CALL_OW 257
69774: PUSH
69775: LD_INT 1
69777: NONEQUAL
69778: OR
69779: IFFALSE 69842
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69781: LD_ADDR_VAR 0 5
69785: PUSH
69786: LD_EXP 73
69790: PUSH
69791: LD_VAR 0 2
69795: ARRAY
69796: PUSH
69797: LD_EXP 73
69801: PUSH
69802: LD_VAR 0 2
69806: ARRAY
69807: PUSH
69808: LD_VAR 0 3
69812: ARRAY
69813: DIFF
69814: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69815: LD_ADDR_EXP 73
69819: PUSH
69820: LD_EXP 73
69824: PPUSH
69825: LD_VAR 0 2
69829: PPUSH
69830: LD_VAR 0 5
69834: PPUSH
69835: CALL_OW 1
69839: ST_TO_ADDR
// continue ;
69840: GO 69728
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
69842: LD_EXP 73
69846: PUSH
69847: LD_VAR 0 2
69851: ARRAY
69852: PUSH
69853: LD_VAR 0 3
69857: ARRAY
69858: PPUSH
69859: CALL 21461 0 1
69863: PUSH
69864: LD_EXP 73
69868: PUSH
69869: LD_VAR 0 2
69873: ARRAY
69874: PUSH
69875: LD_VAR 0 3
69879: ARRAY
69880: PPUSH
69881: CALL_OW 255
69885: PPUSH
69886: LD_EXP 72
69890: PUSH
69891: LD_VAR 0 2
69895: ARRAY
69896: PUSH
69897: LD_VAR 0 4
69901: ARRAY
69902: PUSH
69903: LD_INT 1
69905: ARRAY
69906: PPUSH
69907: LD_EXP 72
69911: PUSH
69912: LD_VAR 0 2
69916: ARRAY
69917: PUSH
69918: LD_VAR 0 4
69922: ARRAY
69923: PUSH
69924: LD_INT 2
69926: ARRAY
69927: PPUSH
69928: LD_INT 15
69930: PPUSH
69931: CALL 22421 0 4
69935: PUSH
69936: LD_INT 4
69938: ARRAY
69939: PUSH
69940: LD_EXP 73
69944: PUSH
69945: LD_VAR 0 2
69949: ARRAY
69950: PUSH
69951: LD_VAR 0 3
69955: ARRAY
69956: PPUSH
69957: LD_INT 10
69959: PPUSH
69960: CALL 24118 0 2
69964: PUSH
69965: LD_INT 4
69967: ARRAY
69968: OR
69969: AND
69970: IFFALSE 69993
// ComStop ( mc_miners [ i ] [ j ] ) ;
69972: LD_EXP 73
69976: PUSH
69977: LD_VAR 0 2
69981: ARRAY
69982: PUSH
69983: LD_VAR 0 3
69987: ARRAY
69988: PPUSH
69989: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
69993: LD_EXP 73
69997: PUSH
69998: LD_VAR 0 2
70002: ARRAY
70003: PUSH
70004: LD_VAR 0 3
70008: ARRAY
70009: PPUSH
70010: CALL_OW 257
70014: PUSH
70015: LD_INT 1
70017: EQUAL
70018: PUSH
70019: LD_EXP 73
70023: PUSH
70024: LD_VAR 0 2
70028: ARRAY
70029: PUSH
70030: LD_VAR 0 3
70034: ARRAY
70035: PPUSH
70036: CALL_OW 459
70040: NOT
70041: AND
70042: PUSH
70043: LD_EXP 73
70047: PUSH
70048: LD_VAR 0 2
70052: ARRAY
70053: PUSH
70054: LD_VAR 0 3
70058: ARRAY
70059: PPUSH
70060: CALL_OW 255
70064: PPUSH
70065: LD_EXP 72
70069: PUSH
70070: LD_VAR 0 2
70074: ARRAY
70075: PUSH
70076: LD_VAR 0 4
70080: ARRAY
70081: PUSH
70082: LD_INT 1
70084: ARRAY
70085: PPUSH
70086: LD_EXP 72
70090: PUSH
70091: LD_VAR 0 2
70095: ARRAY
70096: PUSH
70097: LD_VAR 0 4
70101: ARRAY
70102: PUSH
70103: LD_INT 2
70105: ARRAY
70106: PPUSH
70107: LD_INT 15
70109: PPUSH
70110: CALL 22421 0 4
70114: PUSH
70115: LD_INT 4
70117: ARRAY
70118: PUSH
70119: LD_INT 0
70121: EQUAL
70122: AND
70123: PUSH
70124: LD_EXP 73
70128: PUSH
70129: LD_VAR 0 2
70133: ARRAY
70134: PUSH
70135: LD_VAR 0 3
70139: ARRAY
70140: PPUSH
70141: CALL_OW 314
70145: NOT
70146: AND
70147: IFFALSE 70323
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
70149: LD_EXP 73
70153: PUSH
70154: LD_VAR 0 2
70158: ARRAY
70159: PUSH
70160: LD_VAR 0 3
70164: ARRAY
70165: PPUSH
70166: CALL_OW 310
70170: IFFALSE 70193
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
70172: LD_EXP 73
70176: PUSH
70177: LD_VAR 0 2
70181: ARRAY
70182: PUSH
70183: LD_VAR 0 3
70187: ARRAY
70188: PPUSH
70189: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
70193: LD_EXP 73
70197: PUSH
70198: LD_VAR 0 2
70202: ARRAY
70203: PUSH
70204: LD_VAR 0 3
70208: ARRAY
70209: PPUSH
70210: CALL_OW 314
70214: NOT
70215: IFFALSE 70283
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
70217: LD_EXP 73
70221: PUSH
70222: LD_VAR 0 2
70226: ARRAY
70227: PUSH
70228: LD_VAR 0 3
70232: ARRAY
70233: PPUSH
70234: LD_EXP 72
70238: PUSH
70239: LD_VAR 0 2
70243: ARRAY
70244: PUSH
70245: LD_VAR 0 4
70249: ARRAY
70250: PUSH
70251: LD_INT 1
70253: ARRAY
70254: PPUSH
70255: LD_EXP 72
70259: PUSH
70260: LD_VAR 0 2
70264: ARRAY
70265: PUSH
70266: LD_VAR 0 4
70270: ARRAY
70271: PUSH
70272: LD_INT 2
70274: ARRAY
70275: PPUSH
70276: LD_INT 0
70278: PPUSH
70279: CALL_OW 193
// k := k + 1 ;
70283: LD_ADDR_VAR 0 4
70287: PUSH
70288: LD_VAR 0 4
70292: PUSH
70293: LD_INT 1
70295: PLUS
70296: ST_TO_ADDR
// if k > mc_mines [ i ] then
70297: LD_VAR 0 4
70301: PUSH
70302: LD_EXP 72
70306: PUSH
70307: LD_VAR 0 2
70311: ARRAY
70312: GREATER
70313: IFFALSE 70323
// k := 1 ;
70315: LD_ADDR_VAR 0 4
70319: PUSH
70320: LD_INT 1
70322: ST_TO_ADDR
// end ; end ;
70323: GO 69728
70325: POP
70326: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70327: LD_ADDR_VAR 0 5
70331: PUSH
70332: LD_EXP 59
70336: PUSH
70337: LD_VAR 0 2
70341: ARRAY
70342: PPUSH
70343: LD_INT 2
70345: PUSH
70346: LD_INT 30
70348: PUSH
70349: LD_INT 4
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PUSH
70356: LD_INT 30
70358: PUSH
70359: LD_INT 5
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: PUSH
70366: LD_INT 30
70368: PUSH
70369: LD_INT 32
70371: PUSH
70372: EMPTY
70373: LIST
70374: LIST
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: LIST
70380: LIST
70381: PPUSH
70382: CALL_OW 72
70386: ST_TO_ADDR
// if not tmp then
70387: LD_VAR 0 5
70391: NOT
70392: IFFALSE 70396
// continue ;
70394: GO 69645
// list := [ ] ;
70396: LD_ADDR_VAR 0 6
70400: PUSH
70401: EMPTY
70402: ST_TO_ADDR
// for j in tmp do
70403: LD_ADDR_VAR 0 3
70407: PUSH
70408: LD_VAR 0 5
70412: PUSH
70413: FOR_IN
70414: IFFALSE 70483
// begin for k in UnitsInside ( j ) do
70416: LD_ADDR_VAR 0 4
70420: PUSH
70421: LD_VAR 0 3
70425: PPUSH
70426: CALL_OW 313
70430: PUSH
70431: FOR_IN
70432: IFFALSE 70479
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70434: LD_VAR 0 4
70438: PPUSH
70439: CALL_OW 257
70443: PUSH
70444: LD_INT 1
70446: EQUAL
70447: PUSH
70448: LD_VAR 0 4
70452: PPUSH
70453: CALL_OW 459
70457: NOT
70458: AND
70459: IFFALSE 70477
// list := list ^ k ;
70461: LD_ADDR_VAR 0 6
70465: PUSH
70466: LD_VAR 0 6
70470: PUSH
70471: LD_VAR 0 4
70475: ADD
70476: ST_TO_ADDR
70477: GO 70431
70479: POP
70480: POP
// end ;
70481: GO 70413
70483: POP
70484: POP
// list := list diff mc_miners [ i ] ;
70485: LD_ADDR_VAR 0 6
70489: PUSH
70490: LD_VAR 0 6
70494: PUSH
70495: LD_EXP 73
70499: PUSH
70500: LD_VAR 0 2
70504: ARRAY
70505: DIFF
70506: ST_TO_ADDR
// if not list then
70507: LD_VAR 0 6
70511: NOT
70512: IFFALSE 70516
// continue ;
70514: GO 69645
// k := mc_mines [ i ] - mc_miners [ i ] ;
70516: LD_ADDR_VAR 0 4
70520: PUSH
70521: LD_EXP 72
70525: PUSH
70526: LD_VAR 0 2
70530: ARRAY
70531: PUSH
70532: LD_EXP 73
70536: PUSH
70537: LD_VAR 0 2
70541: ARRAY
70542: MINUS
70543: ST_TO_ADDR
// if k > list then
70544: LD_VAR 0 4
70548: PUSH
70549: LD_VAR 0 6
70553: GREATER
70554: IFFALSE 70566
// k := list ;
70556: LD_ADDR_VAR 0 4
70560: PUSH
70561: LD_VAR 0 6
70565: ST_TO_ADDR
// for j = 1 to k do
70566: LD_ADDR_VAR 0 3
70570: PUSH
70571: DOUBLE
70572: LD_INT 1
70574: DEC
70575: ST_TO_ADDR
70576: LD_VAR 0 4
70580: PUSH
70581: FOR_TO
70582: IFFALSE 70636
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70584: LD_ADDR_EXP 73
70588: PUSH
70589: LD_EXP 73
70593: PPUSH
70594: LD_VAR 0 2
70598: PUSH
70599: LD_EXP 73
70603: PUSH
70604: LD_VAR 0 2
70608: ARRAY
70609: PUSH
70610: LD_INT 1
70612: PLUS
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PPUSH
70618: LD_VAR 0 6
70622: PUSH
70623: LD_VAR 0 3
70627: ARRAY
70628: PPUSH
70629: CALL 21525 0 3
70633: ST_TO_ADDR
70634: GO 70581
70636: POP
70637: POP
// end ;
70638: GO 69645
70640: POP
70641: POP
// end ;
70642: LD_VAR 0 1
70646: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
70647: LD_INT 0
70649: PPUSH
70650: PPUSH
70651: PPUSH
70652: PPUSH
70653: PPUSH
70654: PPUSH
70655: PPUSH
70656: PPUSH
70657: PPUSH
70658: PPUSH
// if not mc_bases then
70659: LD_EXP 59
70663: NOT
70664: IFFALSE 70668
// exit ;
70666: GO 72418
// for i = 1 to mc_bases do
70668: LD_ADDR_VAR 0 2
70672: PUSH
70673: DOUBLE
70674: LD_INT 1
70676: DEC
70677: ST_TO_ADDR
70678: LD_EXP 59
70682: PUSH
70683: FOR_TO
70684: IFFALSE 72416
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70686: LD_EXP 59
70690: PUSH
70691: LD_VAR 0 2
70695: ARRAY
70696: NOT
70697: PUSH
70698: LD_EXP 66
70702: PUSH
70703: LD_VAR 0 2
70707: ARRAY
70708: OR
70709: IFFALSE 70713
// continue ;
70711: GO 70683
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70713: LD_EXP 75
70717: PUSH
70718: LD_VAR 0 2
70722: ARRAY
70723: NOT
70724: PUSH
70725: LD_EXP 76
70729: PUSH
70730: LD_VAR 0 2
70734: ARRAY
70735: AND
70736: IFFALSE 70774
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70738: LD_ADDR_EXP 76
70742: PUSH
70743: LD_EXP 76
70747: PPUSH
70748: LD_VAR 0 2
70752: PPUSH
70753: EMPTY
70754: PPUSH
70755: CALL_OW 1
70759: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70760: LD_VAR 0 2
70764: PPUSH
70765: LD_INT 107
70767: PPUSH
70768: CALL 61528 0 2
// continue ;
70772: GO 70683
// end ; target := [ ] ;
70774: LD_ADDR_VAR 0 6
70778: PUSH
70779: EMPTY
70780: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70781: LD_ADDR_VAR 0 3
70785: PUSH
70786: DOUBLE
70787: LD_EXP 75
70791: PUSH
70792: LD_VAR 0 2
70796: ARRAY
70797: INC
70798: ST_TO_ADDR
70799: LD_INT 1
70801: PUSH
70802: FOR_DOWNTO
70803: IFFALSE 71063
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70805: LD_EXP 75
70809: PUSH
70810: LD_VAR 0 2
70814: ARRAY
70815: PUSH
70816: LD_VAR 0 3
70820: ARRAY
70821: PUSH
70822: LD_INT 2
70824: ARRAY
70825: PPUSH
70826: LD_EXP 75
70830: PUSH
70831: LD_VAR 0 2
70835: ARRAY
70836: PUSH
70837: LD_VAR 0 3
70841: ARRAY
70842: PUSH
70843: LD_INT 3
70845: ARRAY
70846: PPUSH
70847: CALL_OW 488
70851: PUSH
70852: LD_EXP 75
70856: PUSH
70857: LD_VAR 0 2
70861: ARRAY
70862: PUSH
70863: LD_VAR 0 3
70867: ARRAY
70868: PUSH
70869: LD_INT 2
70871: ARRAY
70872: PPUSH
70873: LD_EXP 75
70877: PUSH
70878: LD_VAR 0 2
70882: ARRAY
70883: PUSH
70884: LD_VAR 0 3
70888: ARRAY
70889: PUSH
70890: LD_INT 3
70892: ARRAY
70893: PPUSH
70894: CALL_OW 284
70898: PUSH
70899: LD_INT 0
70901: EQUAL
70902: AND
70903: IFFALSE 70958
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70905: LD_ADDR_VAR 0 5
70909: PUSH
70910: LD_EXP 75
70914: PUSH
70915: LD_VAR 0 2
70919: ARRAY
70920: PPUSH
70921: LD_VAR 0 3
70925: PPUSH
70926: CALL_OW 3
70930: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70931: LD_ADDR_EXP 75
70935: PUSH
70936: LD_EXP 75
70940: PPUSH
70941: LD_VAR 0 2
70945: PPUSH
70946: LD_VAR 0 5
70950: PPUSH
70951: CALL_OW 1
70955: ST_TO_ADDR
// continue ;
70956: GO 70802
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70958: LD_EXP 59
70962: PUSH
70963: LD_VAR 0 2
70967: ARRAY
70968: PUSH
70969: LD_INT 1
70971: ARRAY
70972: PPUSH
70973: CALL_OW 255
70977: PPUSH
70978: LD_EXP 75
70982: PUSH
70983: LD_VAR 0 2
70987: ARRAY
70988: PUSH
70989: LD_VAR 0 3
70993: ARRAY
70994: PUSH
70995: LD_INT 2
70997: ARRAY
70998: PPUSH
70999: LD_EXP 75
71003: PUSH
71004: LD_VAR 0 2
71008: ARRAY
71009: PUSH
71010: LD_VAR 0 3
71014: ARRAY
71015: PUSH
71016: LD_INT 3
71018: ARRAY
71019: PPUSH
71020: LD_INT 30
71022: PPUSH
71023: CALL 22421 0 4
71027: PUSH
71028: LD_INT 4
71030: ARRAY
71031: PUSH
71032: LD_INT 0
71034: EQUAL
71035: IFFALSE 71061
// begin target := mc_crates [ i ] [ j ] ;
71037: LD_ADDR_VAR 0 6
71041: PUSH
71042: LD_EXP 75
71046: PUSH
71047: LD_VAR 0 2
71051: ARRAY
71052: PUSH
71053: LD_VAR 0 3
71057: ARRAY
71058: ST_TO_ADDR
// break ;
71059: GO 71063
// end ; end ;
71061: GO 70802
71063: POP
71064: POP
// if not target then
71065: LD_VAR 0 6
71069: NOT
71070: IFFALSE 71074
// continue ;
71072: GO 70683
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
71074: LD_ADDR_VAR 0 7
71078: PUSH
71079: LD_EXP 78
71083: PUSH
71084: LD_VAR 0 2
71088: ARRAY
71089: PPUSH
71090: LD_INT 2
71092: PUSH
71093: LD_INT 3
71095: PUSH
71096: LD_INT 58
71098: PUSH
71099: EMPTY
71100: LIST
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: LD_INT 61
71108: PUSH
71109: EMPTY
71110: LIST
71111: PUSH
71112: LD_INT 33
71114: PUSH
71115: LD_INT 5
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: PUSH
71122: LD_INT 33
71124: PUSH
71125: LD_INT 3
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: LIST
71136: LIST
71137: LIST
71138: PUSH
71139: LD_INT 2
71141: PUSH
71142: LD_INT 34
71144: PUSH
71145: LD_INT 32
71147: PUSH
71148: EMPTY
71149: LIST
71150: LIST
71151: PUSH
71152: LD_INT 34
71154: PUSH
71155: LD_INT 51
71157: PUSH
71158: EMPTY
71159: LIST
71160: LIST
71161: PUSH
71162: LD_INT 34
71164: PUSH
71165: LD_INT 12
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: LIST
71176: LIST
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PPUSH
71182: CALL_OW 72
71186: ST_TO_ADDR
// if not cargo then
71187: LD_VAR 0 7
71191: NOT
71192: IFFALSE 71835
// begin if mc_crates_collector [ i ] < 5 then
71194: LD_EXP 76
71198: PUSH
71199: LD_VAR 0 2
71203: ARRAY
71204: PUSH
71205: LD_INT 5
71207: LESS
71208: IFFALSE 71574
// begin if mc_ape [ i ] then
71210: LD_EXP 88
71214: PUSH
71215: LD_VAR 0 2
71219: ARRAY
71220: IFFALSE 71267
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
71222: LD_ADDR_VAR 0 5
71226: PUSH
71227: LD_EXP 88
71231: PUSH
71232: LD_VAR 0 2
71236: ARRAY
71237: PPUSH
71238: LD_INT 25
71240: PUSH
71241: LD_INT 16
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 24
71250: PUSH
71251: LD_INT 750
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PPUSH
71262: CALL_OW 72
71266: ST_TO_ADDR
// if not tmp then
71267: LD_VAR 0 5
71271: NOT
71272: IFFALSE 71319
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
71274: LD_ADDR_VAR 0 5
71278: PUSH
71279: LD_EXP 59
71283: PUSH
71284: LD_VAR 0 2
71288: ARRAY
71289: PPUSH
71290: LD_INT 25
71292: PUSH
71293: LD_INT 2
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 24
71302: PUSH
71303: LD_INT 750
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: EMPTY
71311: LIST
71312: LIST
71313: PPUSH
71314: CALL_OW 72
71318: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71319: LD_EXP 88
71323: PUSH
71324: LD_VAR 0 2
71328: ARRAY
71329: PUSH
71330: LD_EXP 59
71334: PUSH
71335: LD_VAR 0 2
71339: ARRAY
71340: PPUSH
71341: LD_INT 25
71343: PUSH
71344: LD_INT 2
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PUSH
71351: LD_INT 24
71353: PUSH
71354: LD_INT 750
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PPUSH
71365: CALL_OW 72
71369: AND
71370: PUSH
71371: LD_VAR 0 5
71375: PUSH
71376: LD_INT 5
71378: LESS
71379: AND
71380: IFFALSE 71462
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71382: LD_ADDR_VAR 0 3
71386: PUSH
71387: LD_EXP 59
71391: PUSH
71392: LD_VAR 0 2
71396: ARRAY
71397: PPUSH
71398: LD_INT 25
71400: PUSH
71401: LD_INT 2
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PUSH
71408: LD_INT 24
71410: PUSH
71411: LD_INT 750
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PUSH
71418: EMPTY
71419: LIST
71420: LIST
71421: PPUSH
71422: CALL_OW 72
71426: PUSH
71427: FOR_IN
71428: IFFALSE 71460
// begin tmp := tmp union j ;
71430: LD_ADDR_VAR 0 5
71434: PUSH
71435: LD_VAR 0 5
71439: PUSH
71440: LD_VAR 0 3
71444: UNION
71445: ST_TO_ADDR
// if tmp >= 5 then
71446: LD_VAR 0 5
71450: PUSH
71451: LD_INT 5
71453: GREATEREQUAL
71454: IFFALSE 71458
// break ;
71456: GO 71460
// end ;
71458: GO 71427
71460: POP
71461: POP
// end ; if not tmp then
71462: LD_VAR 0 5
71466: NOT
71467: IFFALSE 71471
// continue ;
71469: GO 70683
// for j in tmp do
71471: LD_ADDR_VAR 0 3
71475: PUSH
71476: LD_VAR 0 5
71480: PUSH
71481: FOR_IN
71482: IFFALSE 71572
// if not GetTag ( j ) then
71484: LD_VAR 0 3
71488: PPUSH
71489: CALL_OW 110
71493: NOT
71494: IFFALSE 71570
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71496: LD_ADDR_EXP 76
71500: PUSH
71501: LD_EXP 76
71505: PPUSH
71506: LD_VAR 0 2
71510: PUSH
71511: LD_EXP 76
71515: PUSH
71516: LD_VAR 0 2
71520: ARRAY
71521: PUSH
71522: LD_INT 1
71524: PLUS
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: PPUSH
71530: LD_VAR 0 3
71534: PPUSH
71535: CALL 21525 0 3
71539: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71540: LD_VAR 0 3
71544: PPUSH
71545: LD_INT 107
71547: PPUSH
71548: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71552: LD_EXP 76
71556: PUSH
71557: LD_VAR 0 2
71561: ARRAY
71562: PUSH
71563: LD_INT 5
71565: GREATEREQUAL
71566: IFFALSE 71570
// break ;
71568: GO 71572
// end ;
71570: GO 71481
71572: POP
71573: POP
// end ; if mc_crates_collector [ i ] and target then
71574: LD_EXP 76
71578: PUSH
71579: LD_VAR 0 2
71583: ARRAY
71584: PUSH
71585: LD_VAR 0 6
71589: AND
71590: IFFALSE 71833
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71592: LD_EXP 76
71596: PUSH
71597: LD_VAR 0 2
71601: ARRAY
71602: PUSH
71603: LD_VAR 0 6
71607: PUSH
71608: LD_INT 1
71610: ARRAY
71611: LESS
71612: IFFALSE 71632
// tmp := mc_crates_collector [ i ] else
71614: LD_ADDR_VAR 0 5
71618: PUSH
71619: LD_EXP 76
71623: PUSH
71624: LD_VAR 0 2
71628: ARRAY
71629: ST_TO_ADDR
71630: GO 71646
// tmp := target [ 1 ] ;
71632: LD_ADDR_VAR 0 5
71636: PUSH
71637: LD_VAR 0 6
71641: PUSH
71642: LD_INT 1
71644: ARRAY
71645: ST_TO_ADDR
// k := 0 ;
71646: LD_ADDR_VAR 0 4
71650: PUSH
71651: LD_INT 0
71653: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71654: LD_ADDR_VAR 0 3
71658: PUSH
71659: LD_EXP 76
71663: PUSH
71664: LD_VAR 0 2
71668: ARRAY
71669: PUSH
71670: FOR_IN
71671: IFFALSE 71831
// begin k := k + 1 ;
71673: LD_ADDR_VAR 0 4
71677: PUSH
71678: LD_VAR 0 4
71682: PUSH
71683: LD_INT 1
71685: PLUS
71686: ST_TO_ADDR
// if k > tmp then
71687: LD_VAR 0 4
71691: PUSH
71692: LD_VAR 0 5
71696: GREATER
71697: IFFALSE 71701
// break ;
71699: GO 71831
// if not GetClass ( j ) in [ 2 , 16 ] then
71701: LD_VAR 0 3
71705: PPUSH
71706: CALL_OW 257
71710: PUSH
71711: LD_INT 2
71713: PUSH
71714: LD_INT 16
71716: PUSH
71717: EMPTY
71718: LIST
71719: LIST
71720: IN
71721: NOT
71722: IFFALSE 71775
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71724: LD_ADDR_EXP 76
71728: PUSH
71729: LD_EXP 76
71733: PPUSH
71734: LD_VAR 0 2
71738: PPUSH
71739: LD_EXP 76
71743: PUSH
71744: LD_VAR 0 2
71748: ARRAY
71749: PUSH
71750: LD_VAR 0 3
71754: DIFF
71755: PPUSH
71756: CALL_OW 1
71760: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71761: LD_VAR 0 3
71765: PPUSH
71766: LD_INT 0
71768: PPUSH
71769: CALL_OW 109
// continue ;
71773: GO 71670
// end ; if IsInUnit ( j ) then
71775: LD_VAR 0 3
71779: PPUSH
71780: CALL_OW 310
71784: IFFALSE 71795
// ComExitBuilding ( j ) ;
71786: LD_VAR 0 3
71790: PPUSH
71791: CALL_OW 122
// wait ( 3 ) ;
71795: LD_INT 3
71797: PPUSH
71798: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71802: LD_VAR 0 3
71806: PPUSH
71807: LD_VAR 0 6
71811: PUSH
71812: LD_INT 2
71814: ARRAY
71815: PPUSH
71816: LD_VAR 0 6
71820: PUSH
71821: LD_INT 3
71823: ARRAY
71824: PPUSH
71825: CALL_OW 117
// end ;
71829: GO 71670
71831: POP
71832: POP
// end ; end else
71833: GO 72414
// begin for j in cargo do
71835: LD_ADDR_VAR 0 3
71839: PUSH
71840: LD_VAR 0 7
71844: PUSH
71845: FOR_IN
71846: IFFALSE 72412
// begin if GetTag ( j ) <> 0 then
71848: LD_VAR 0 3
71852: PPUSH
71853: CALL_OW 110
71857: PUSH
71858: LD_INT 0
71860: NONEQUAL
71861: IFFALSE 71865
// continue ;
71863: GO 71845
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71865: LD_VAR 0 3
71869: PPUSH
71870: CALL_OW 256
71874: PUSH
71875: LD_INT 1000
71877: LESS
71878: PUSH
71879: LD_VAR 0 3
71883: PPUSH
71884: LD_EXP 83
71888: PUSH
71889: LD_VAR 0 2
71893: ARRAY
71894: PPUSH
71895: CALL_OW 308
71899: NOT
71900: AND
71901: IFFALSE 71923
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71903: LD_VAR 0 3
71907: PPUSH
71908: LD_EXP 83
71912: PUSH
71913: LD_VAR 0 2
71917: ARRAY
71918: PPUSH
71919: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71923: LD_VAR 0 3
71927: PPUSH
71928: CALL_OW 256
71932: PUSH
71933: LD_INT 1000
71935: LESS
71936: PUSH
71937: LD_VAR 0 3
71941: PPUSH
71942: LD_EXP 83
71946: PUSH
71947: LD_VAR 0 2
71951: ARRAY
71952: PPUSH
71953: CALL_OW 308
71957: AND
71958: IFFALSE 71962
// continue ;
71960: GO 71845
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71962: LD_VAR 0 3
71966: PPUSH
71967: CALL_OW 262
71971: PUSH
71972: LD_INT 2
71974: EQUAL
71975: PUSH
71976: LD_VAR 0 3
71980: PPUSH
71981: CALL_OW 261
71985: PUSH
71986: LD_INT 15
71988: LESS
71989: AND
71990: IFFALSE 71994
// continue ;
71992: GO 71845
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71994: LD_VAR 0 3
71998: PPUSH
71999: CALL_OW 262
72003: PUSH
72004: LD_INT 1
72006: EQUAL
72007: PUSH
72008: LD_VAR 0 3
72012: PPUSH
72013: CALL_OW 261
72017: PUSH
72018: LD_INT 10
72020: LESS
72021: AND
72022: IFFALSE 72351
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72024: LD_ADDR_VAR 0 8
72028: PUSH
72029: LD_EXP 59
72033: PUSH
72034: LD_VAR 0 2
72038: ARRAY
72039: PPUSH
72040: LD_INT 2
72042: PUSH
72043: LD_INT 30
72045: PUSH
72046: LD_INT 0
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 30
72055: PUSH
72056: LD_INT 1
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: LIST
72067: PPUSH
72068: CALL_OW 72
72072: ST_TO_ADDR
// if not depot then
72073: LD_VAR 0 8
72077: NOT
72078: IFFALSE 72082
// continue ;
72080: GO 71845
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
72082: LD_VAR 0 3
72086: PPUSH
72087: LD_VAR 0 8
72091: PPUSH
72092: LD_VAR 0 3
72096: PPUSH
72097: CALL_OW 74
72101: PPUSH
72102: CALL_OW 296
72106: PUSH
72107: LD_INT 6
72109: LESS
72110: IFFALSE 72126
// SetFuel ( j , 100 ) else
72112: LD_VAR 0 3
72116: PPUSH
72117: LD_INT 100
72119: PPUSH
72120: CALL_OW 240
72124: GO 72351
// if GetFuel ( j ) = 0 then
72126: LD_VAR 0 3
72130: PPUSH
72131: CALL_OW 261
72135: PUSH
72136: LD_INT 0
72138: EQUAL
72139: IFFALSE 72351
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
72141: LD_ADDR_EXP 78
72145: PUSH
72146: LD_EXP 78
72150: PPUSH
72151: LD_VAR 0 2
72155: PPUSH
72156: LD_EXP 78
72160: PUSH
72161: LD_VAR 0 2
72165: ARRAY
72166: PUSH
72167: LD_VAR 0 3
72171: DIFF
72172: PPUSH
72173: CALL_OW 1
72177: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
72178: LD_VAR 0 3
72182: PPUSH
72183: CALL_OW 263
72187: PUSH
72188: LD_INT 1
72190: EQUAL
72191: IFFALSE 72207
// ComExitVehicle ( IsInUnit ( j ) ) ;
72193: LD_VAR 0 3
72197: PPUSH
72198: CALL_OW 310
72202: PPUSH
72203: CALL_OW 121
// if GetControl ( j ) = control_remote then
72207: LD_VAR 0 3
72211: PPUSH
72212: CALL_OW 263
72216: PUSH
72217: LD_INT 2
72219: EQUAL
72220: IFFALSE 72231
// ComUnlink ( j ) ;
72222: LD_VAR 0 3
72226: PPUSH
72227: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
72231: LD_ADDR_VAR 0 9
72235: PUSH
72236: LD_VAR 0 2
72240: PPUSH
72241: LD_INT 3
72243: PPUSH
72244: CALL 81704 0 2
72248: ST_TO_ADDR
// if fac then
72249: LD_VAR 0 9
72253: IFFALSE 72349
// begin for k in fac do
72255: LD_ADDR_VAR 0 4
72259: PUSH
72260: LD_VAR 0 9
72264: PUSH
72265: FOR_IN
72266: IFFALSE 72347
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
72268: LD_ADDR_VAR 0 10
72272: PUSH
72273: LD_VAR 0 9
72277: PPUSH
72278: LD_VAR 0 3
72282: PPUSH
72283: CALL_OW 265
72287: PPUSH
72288: LD_VAR 0 3
72292: PPUSH
72293: CALL_OW 262
72297: PPUSH
72298: LD_VAR 0 3
72302: PPUSH
72303: CALL_OW 263
72307: PPUSH
72308: LD_VAR 0 3
72312: PPUSH
72313: CALL_OW 264
72317: PPUSH
72318: CALL 19057 0 5
72322: ST_TO_ADDR
// if components then
72323: LD_VAR 0 10
72327: IFFALSE 72345
// begin MC_InsertProduceList ( i , components ) ;
72329: LD_VAR 0 2
72333: PPUSH
72334: LD_VAR 0 10
72338: PPUSH
72339: CALL 81249 0 2
// break ;
72343: GO 72347
// end ; end ;
72345: GO 72265
72347: POP
72348: POP
// end ; continue ;
72349: GO 71845
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72351: LD_VAR 0 3
72355: PPUSH
72356: LD_INT 1
72358: PPUSH
72359: CALL_OW 289
72363: PUSH
72364: LD_INT 100
72366: LESS
72367: PUSH
72368: LD_VAR 0 3
72372: PPUSH
72373: CALL_OW 314
72377: NOT
72378: AND
72379: IFFALSE 72408
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72381: LD_VAR 0 3
72385: PPUSH
72386: LD_VAR 0 6
72390: PUSH
72391: LD_INT 2
72393: ARRAY
72394: PPUSH
72395: LD_VAR 0 6
72399: PUSH
72400: LD_INT 3
72402: ARRAY
72403: PPUSH
72404: CALL_OW 117
// break ;
72408: GO 72412
// end ;
72410: GO 71845
72412: POP
72413: POP
// end ; end ;
72414: GO 70683
72416: POP
72417: POP
// end ;
72418: LD_VAR 0 1
72422: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72423: LD_INT 0
72425: PPUSH
72426: PPUSH
72427: PPUSH
72428: PPUSH
// if not mc_bases then
72429: LD_EXP 59
72433: NOT
72434: IFFALSE 72438
// exit ;
72436: GO 72599
// for i = 1 to mc_bases do
72438: LD_ADDR_VAR 0 2
72442: PUSH
72443: DOUBLE
72444: LD_INT 1
72446: DEC
72447: ST_TO_ADDR
72448: LD_EXP 59
72452: PUSH
72453: FOR_TO
72454: IFFALSE 72597
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72456: LD_ADDR_VAR 0 4
72460: PUSH
72461: LD_EXP 78
72465: PUSH
72466: LD_VAR 0 2
72470: ARRAY
72471: PUSH
72472: LD_EXP 81
72476: PUSH
72477: LD_VAR 0 2
72481: ARRAY
72482: UNION
72483: PPUSH
72484: LD_INT 33
72486: PUSH
72487: LD_INT 2
72489: PUSH
72490: EMPTY
72491: LIST
72492: LIST
72493: PPUSH
72494: CALL_OW 72
72498: ST_TO_ADDR
// if tmp then
72499: LD_VAR 0 4
72503: IFFALSE 72595
// for j in tmp do
72505: LD_ADDR_VAR 0 3
72509: PUSH
72510: LD_VAR 0 4
72514: PUSH
72515: FOR_IN
72516: IFFALSE 72593
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72518: LD_VAR 0 3
72522: PPUSH
72523: CALL_OW 312
72527: NOT
72528: PUSH
72529: LD_VAR 0 3
72533: PPUSH
72534: CALL_OW 256
72538: PUSH
72539: LD_INT 250
72541: GREATEREQUAL
72542: AND
72543: IFFALSE 72556
// Connect ( j ) else
72545: LD_VAR 0 3
72549: PPUSH
72550: CALL 24458 0 1
72554: GO 72591
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72556: LD_VAR 0 3
72560: PPUSH
72561: CALL_OW 256
72565: PUSH
72566: LD_INT 250
72568: LESS
72569: PUSH
72570: LD_VAR 0 3
72574: PPUSH
72575: CALL_OW 312
72579: AND
72580: IFFALSE 72591
// ComUnlink ( j ) ;
72582: LD_VAR 0 3
72586: PPUSH
72587: CALL_OW 136
72591: GO 72515
72593: POP
72594: POP
// end ;
72595: GO 72453
72597: POP
72598: POP
// end ;
72599: LD_VAR 0 1
72603: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72604: LD_INT 0
72606: PPUSH
72607: PPUSH
72608: PPUSH
72609: PPUSH
72610: PPUSH
// if not mc_bases then
72611: LD_EXP 59
72615: NOT
72616: IFFALSE 72620
// exit ;
72618: GO 73065
// for i = 1 to mc_bases do
72620: LD_ADDR_VAR 0 2
72624: PUSH
72625: DOUBLE
72626: LD_INT 1
72628: DEC
72629: ST_TO_ADDR
72630: LD_EXP 59
72634: PUSH
72635: FOR_TO
72636: IFFALSE 73063
// begin if not mc_produce [ i ] then
72638: LD_EXP 80
72642: PUSH
72643: LD_VAR 0 2
72647: ARRAY
72648: NOT
72649: IFFALSE 72653
// continue ;
72651: GO 72635
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72653: LD_ADDR_VAR 0 5
72657: PUSH
72658: LD_EXP 59
72662: PUSH
72663: LD_VAR 0 2
72667: ARRAY
72668: PPUSH
72669: LD_INT 30
72671: PUSH
72672: LD_INT 3
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PPUSH
72679: CALL_OW 72
72683: ST_TO_ADDR
// if not fac then
72684: LD_VAR 0 5
72688: NOT
72689: IFFALSE 72693
// continue ;
72691: GO 72635
// for j in fac do
72693: LD_ADDR_VAR 0 3
72697: PUSH
72698: LD_VAR 0 5
72702: PUSH
72703: FOR_IN
72704: IFFALSE 73059
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72706: LD_VAR 0 3
72710: PPUSH
72711: CALL_OW 461
72715: PUSH
72716: LD_INT 2
72718: NONEQUAL
72719: PUSH
72720: LD_VAR 0 3
72724: PPUSH
72725: LD_INT 15
72727: PPUSH
72728: CALL 24118 0 2
72732: PUSH
72733: LD_INT 4
72735: ARRAY
72736: OR
72737: IFFALSE 72741
// continue ;
72739: GO 72703
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72741: LD_VAR 0 3
72745: PPUSH
72746: LD_EXP 80
72750: PUSH
72751: LD_VAR 0 2
72755: ARRAY
72756: PUSH
72757: LD_INT 1
72759: ARRAY
72760: PUSH
72761: LD_INT 1
72763: ARRAY
72764: PPUSH
72765: LD_EXP 80
72769: PUSH
72770: LD_VAR 0 2
72774: ARRAY
72775: PUSH
72776: LD_INT 1
72778: ARRAY
72779: PUSH
72780: LD_INT 2
72782: ARRAY
72783: PPUSH
72784: LD_EXP 80
72788: PUSH
72789: LD_VAR 0 2
72793: ARRAY
72794: PUSH
72795: LD_INT 1
72797: ARRAY
72798: PUSH
72799: LD_INT 3
72801: ARRAY
72802: PPUSH
72803: LD_EXP 80
72807: PUSH
72808: LD_VAR 0 2
72812: ARRAY
72813: PUSH
72814: LD_INT 1
72816: ARRAY
72817: PUSH
72818: LD_INT 4
72820: ARRAY
72821: PPUSH
72822: CALL_OW 448
72826: PUSH
72827: LD_VAR 0 3
72831: PPUSH
72832: LD_EXP 80
72836: PUSH
72837: LD_VAR 0 2
72841: ARRAY
72842: PUSH
72843: LD_INT 1
72845: ARRAY
72846: PUSH
72847: LD_INT 1
72849: ARRAY
72850: PUSH
72851: LD_EXP 80
72855: PUSH
72856: LD_VAR 0 2
72860: ARRAY
72861: PUSH
72862: LD_INT 1
72864: ARRAY
72865: PUSH
72866: LD_INT 2
72868: ARRAY
72869: PUSH
72870: LD_EXP 80
72874: PUSH
72875: LD_VAR 0 2
72879: ARRAY
72880: PUSH
72881: LD_INT 1
72883: ARRAY
72884: PUSH
72885: LD_INT 3
72887: ARRAY
72888: PUSH
72889: LD_EXP 80
72893: PUSH
72894: LD_VAR 0 2
72898: ARRAY
72899: PUSH
72900: LD_INT 1
72902: ARRAY
72903: PUSH
72904: LD_INT 4
72906: ARRAY
72907: PUSH
72908: EMPTY
72909: LIST
72910: LIST
72911: LIST
72912: LIST
72913: PPUSH
72914: CALL 27789 0 2
72918: AND
72919: IFFALSE 73057
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72921: LD_VAR 0 3
72925: PPUSH
72926: LD_EXP 80
72930: PUSH
72931: LD_VAR 0 2
72935: ARRAY
72936: PUSH
72937: LD_INT 1
72939: ARRAY
72940: PUSH
72941: LD_INT 1
72943: ARRAY
72944: PPUSH
72945: LD_EXP 80
72949: PUSH
72950: LD_VAR 0 2
72954: ARRAY
72955: PUSH
72956: LD_INT 1
72958: ARRAY
72959: PUSH
72960: LD_INT 2
72962: ARRAY
72963: PPUSH
72964: LD_EXP 80
72968: PUSH
72969: LD_VAR 0 2
72973: ARRAY
72974: PUSH
72975: LD_INT 1
72977: ARRAY
72978: PUSH
72979: LD_INT 3
72981: ARRAY
72982: PPUSH
72983: LD_EXP 80
72987: PUSH
72988: LD_VAR 0 2
72992: ARRAY
72993: PUSH
72994: LD_INT 1
72996: ARRAY
72997: PUSH
72998: LD_INT 4
73000: ARRAY
73001: PPUSH
73002: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
73006: LD_ADDR_VAR 0 4
73010: PUSH
73011: LD_EXP 80
73015: PUSH
73016: LD_VAR 0 2
73020: ARRAY
73021: PPUSH
73022: LD_INT 1
73024: PPUSH
73025: CALL_OW 3
73029: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
73030: LD_ADDR_EXP 80
73034: PUSH
73035: LD_EXP 80
73039: PPUSH
73040: LD_VAR 0 2
73044: PPUSH
73045: LD_VAR 0 4
73049: PPUSH
73050: CALL_OW 1
73054: ST_TO_ADDR
// break ;
73055: GO 73059
// end ; end ;
73057: GO 72703
73059: POP
73060: POP
// end ;
73061: GO 72635
73063: POP
73064: POP
// end ;
73065: LD_VAR 0 1
73069: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
73070: LD_INT 0
73072: PPUSH
73073: PPUSH
73074: PPUSH
// if not mc_bases then
73075: LD_EXP 59
73079: NOT
73080: IFFALSE 73084
// exit ;
73082: GO 73173
// for i = 1 to mc_bases do
73084: LD_ADDR_VAR 0 2
73088: PUSH
73089: DOUBLE
73090: LD_INT 1
73092: DEC
73093: ST_TO_ADDR
73094: LD_EXP 59
73098: PUSH
73099: FOR_TO
73100: IFFALSE 73171
// begin if mc_attack [ i ] then
73102: LD_EXP 79
73106: PUSH
73107: LD_VAR 0 2
73111: ARRAY
73112: IFFALSE 73169
// begin tmp := mc_attack [ i ] [ 1 ] ;
73114: LD_ADDR_VAR 0 3
73118: PUSH
73119: LD_EXP 79
73123: PUSH
73124: LD_VAR 0 2
73128: ARRAY
73129: PUSH
73130: LD_INT 1
73132: ARRAY
73133: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
73134: LD_ADDR_EXP 79
73138: PUSH
73139: LD_EXP 79
73143: PPUSH
73144: LD_VAR 0 2
73148: PPUSH
73149: EMPTY
73150: PPUSH
73151: CALL_OW 1
73155: ST_TO_ADDR
// Attack ( tmp ) ;
73156: LD_VAR 0 3
73160: PPUSH
73161: CALL 50002 0 1
// exit ;
73165: POP
73166: POP
73167: GO 73173
// end ; end ;
73169: GO 73099
73171: POP
73172: POP
// end ;
73173: LD_VAR 0 1
73177: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
73178: LD_INT 0
73180: PPUSH
73181: PPUSH
73182: PPUSH
73183: PPUSH
73184: PPUSH
73185: PPUSH
73186: PPUSH
// if not mc_bases then
73187: LD_EXP 59
73191: NOT
73192: IFFALSE 73196
// exit ;
73194: GO 73778
// for i = 1 to mc_bases do
73196: LD_ADDR_VAR 0 2
73200: PUSH
73201: DOUBLE
73202: LD_INT 1
73204: DEC
73205: ST_TO_ADDR
73206: LD_EXP 59
73210: PUSH
73211: FOR_TO
73212: IFFALSE 73776
// begin if not mc_bases [ i ] then
73214: LD_EXP 59
73218: PUSH
73219: LD_VAR 0 2
73223: ARRAY
73224: NOT
73225: IFFALSE 73229
// continue ;
73227: GO 73211
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
73229: LD_ADDR_VAR 0 7
73233: PUSH
73234: LD_EXP 59
73238: PUSH
73239: LD_VAR 0 2
73243: ARRAY
73244: PUSH
73245: LD_INT 1
73247: ARRAY
73248: PPUSH
73249: CALL 18361 0 1
73253: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
73254: LD_ADDR_EXP 82
73258: PUSH
73259: LD_EXP 82
73263: PPUSH
73264: LD_VAR 0 2
73268: PPUSH
73269: LD_EXP 59
73273: PUSH
73274: LD_VAR 0 2
73278: ARRAY
73279: PUSH
73280: LD_INT 1
73282: ARRAY
73283: PPUSH
73284: CALL_OW 255
73288: PPUSH
73289: LD_EXP 84
73293: PUSH
73294: LD_VAR 0 2
73298: ARRAY
73299: PPUSH
73300: CALL 15915 0 2
73304: PPUSH
73305: CALL_OW 1
73309: ST_TO_ADDR
// if not mc_scan [ i ] then
73310: LD_EXP 82
73314: PUSH
73315: LD_VAR 0 2
73319: ARRAY
73320: NOT
73321: IFFALSE 73476
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73323: LD_ADDR_VAR 0 4
73327: PUSH
73328: LD_EXP 59
73332: PUSH
73333: LD_VAR 0 2
73337: ARRAY
73338: PPUSH
73339: LD_INT 2
73341: PUSH
73342: LD_INT 25
73344: PUSH
73345: LD_INT 5
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 25
73354: PUSH
73355: LD_INT 8
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: LD_INT 25
73364: PUSH
73365: LD_INT 9
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: PPUSH
73378: CALL_OW 72
73382: ST_TO_ADDR
// if not tmp then
73383: LD_VAR 0 4
73387: NOT
73388: IFFALSE 73392
// continue ;
73390: GO 73211
// for j in tmp do
73392: LD_ADDR_VAR 0 3
73396: PUSH
73397: LD_VAR 0 4
73401: PUSH
73402: FOR_IN
73403: IFFALSE 73474
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73405: LD_VAR 0 3
73409: PPUSH
73410: CALL_OW 310
73414: PPUSH
73415: CALL_OW 266
73419: PUSH
73420: LD_INT 5
73422: EQUAL
73423: PUSH
73424: LD_VAR 0 3
73428: PPUSH
73429: CALL_OW 257
73433: PUSH
73434: LD_INT 1
73436: EQUAL
73437: AND
73438: PUSH
73439: LD_VAR 0 3
73443: PPUSH
73444: CALL_OW 459
73448: NOT
73449: AND
73450: PUSH
73451: LD_VAR 0 7
73455: AND
73456: IFFALSE 73472
// ComChangeProfession ( j , class ) ;
73458: LD_VAR 0 3
73462: PPUSH
73463: LD_VAR 0 7
73467: PPUSH
73468: CALL_OW 123
73472: GO 73402
73474: POP
73475: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73476: LD_EXP 82
73480: PUSH
73481: LD_VAR 0 2
73485: ARRAY
73486: PUSH
73487: LD_EXP 81
73491: PUSH
73492: LD_VAR 0 2
73496: ARRAY
73497: NOT
73498: AND
73499: PUSH
73500: LD_EXP 59
73504: PUSH
73505: LD_VAR 0 2
73509: ARRAY
73510: PPUSH
73511: LD_INT 30
73513: PUSH
73514: LD_INT 32
73516: PUSH
73517: EMPTY
73518: LIST
73519: LIST
73520: PPUSH
73521: CALL_OW 72
73525: NOT
73526: AND
73527: PUSH
73528: LD_EXP 59
73532: PUSH
73533: LD_VAR 0 2
73537: ARRAY
73538: PPUSH
73539: LD_INT 2
73541: PUSH
73542: LD_INT 30
73544: PUSH
73545: LD_INT 4
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: PUSH
73552: LD_INT 30
73554: PUSH
73555: LD_INT 5
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: LIST
73566: PPUSH
73567: CALL_OW 72
73571: NOT
73572: AND
73573: IFFALSE 73705
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73575: LD_ADDR_VAR 0 4
73579: PUSH
73580: LD_EXP 59
73584: PUSH
73585: LD_VAR 0 2
73589: ARRAY
73590: PPUSH
73591: LD_INT 2
73593: PUSH
73594: LD_INT 25
73596: PUSH
73597: LD_INT 1
73599: PUSH
73600: EMPTY
73601: LIST
73602: LIST
73603: PUSH
73604: LD_INT 25
73606: PUSH
73607: LD_INT 5
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PUSH
73614: LD_INT 25
73616: PUSH
73617: LD_INT 8
73619: PUSH
73620: EMPTY
73621: LIST
73622: LIST
73623: PUSH
73624: LD_INT 25
73626: PUSH
73627: LD_INT 9
73629: PUSH
73630: EMPTY
73631: LIST
73632: LIST
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: LIST
73638: LIST
73639: LIST
73640: PPUSH
73641: CALL_OW 72
73645: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73646: LD_ADDR_VAR 0 4
73650: PUSH
73651: LD_VAR 0 4
73655: PUSH
73656: LD_VAR 0 4
73660: PPUSH
73661: LD_INT 18
73663: PPUSH
73664: CALL 54785 0 2
73668: DIFF
73669: ST_TO_ADDR
// if tmp then
73670: LD_VAR 0 4
73674: IFFALSE 73705
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
73676: LD_VAR 0 2
73680: PPUSH
73681: LD_VAR 0 4
73685: PPUSH
73686: LD_EXP 84
73690: PUSH
73691: LD_VAR 0 2
73695: ARRAY
73696: PPUSH
73697: CALL 15950 0 3
// exit ;
73701: POP
73702: POP
73703: GO 73778
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73705: LD_EXP 82
73709: PUSH
73710: LD_VAR 0 2
73714: ARRAY
73715: PUSH
73716: LD_EXP 81
73720: PUSH
73721: LD_VAR 0 2
73725: ARRAY
73726: AND
73727: IFFALSE 73774
// begin tmp := mc_defender [ i ] ;
73729: LD_ADDR_VAR 0 4
73733: PUSH
73734: LD_EXP 81
73738: PUSH
73739: LD_VAR 0 2
73743: ARRAY
73744: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73745: LD_VAR 0 2
73749: PPUSH
73750: LD_VAR 0 4
73754: PPUSH
73755: LD_EXP 82
73759: PUSH
73760: LD_VAR 0 2
73764: ARRAY
73765: PPUSH
73766: CALL 16511 0 3
// exit ;
73770: POP
73771: POP
73772: GO 73778
// end ; end ;
73774: GO 73211
73776: POP
73777: POP
// end ;
73778: LD_VAR 0 1
73782: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73783: LD_INT 0
73785: PPUSH
73786: PPUSH
73787: PPUSH
73788: PPUSH
73789: PPUSH
73790: PPUSH
73791: PPUSH
73792: PPUSH
73793: PPUSH
73794: PPUSH
73795: PPUSH
// if not mc_bases then
73796: LD_EXP 59
73800: NOT
73801: IFFALSE 73805
// exit ;
73803: GO 74892
// for i = 1 to mc_bases do
73805: LD_ADDR_VAR 0 2
73809: PUSH
73810: DOUBLE
73811: LD_INT 1
73813: DEC
73814: ST_TO_ADDR
73815: LD_EXP 59
73819: PUSH
73820: FOR_TO
73821: IFFALSE 74890
// begin tmp := mc_lab [ i ] ;
73823: LD_ADDR_VAR 0 6
73827: PUSH
73828: LD_EXP 92
73832: PUSH
73833: LD_VAR 0 2
73837: ARRAY
73838: ST_TO_ADDR
// if not tmp then
73839: LD_VAR 0 6
73843: NOT
73844: IFFALSE 73848
// continue ;
73846: GO 73820
// idle_lab := 0 ;
73848: LD_ADDR_VAR 0 11
73852: PUSH
73853: LD_INT 0
73855: ST_TO_ADDR
// for j in tmp do
73856: LD_ADDR_VAR 0 3
73860: PUSH
73861: LD_VAR 0 6
73865: PUSH
73866: FOR_IN
73867: IFFALSE 74886
// begin researching := false ;
73869: LD_ADDR_VAR 0 10
73873: PUSH
73874: LD_INT 0
73876: ST_TO_ADDR
// side := GetSide ( j ) ;
73877: LD_ADDR_VAR 0 4
73881: PUSH
73882: LD_VAR 0 3
73886: PPUSH
73887: CALL_OW 255
73891: ST_TO_ADDR
// if not mc_tech [ side ] then
73892: LD_EXP 86
73896: PUSH
73897: LD_VAR 0 4
73901: ARRAY
73902: NOT
73903: IFFALSE 73907
// continue ;
73905: GO 73866
// if BuildingStatus ( j ) = bs_idle then
73907: LD_VAR 0 3
73911: PPUSH
73912: CALL_OW 461
73916: PUSH
73917: LD_INT 2
73919: EQUAL
73920: IFFALSE 74108
// begin if idle_lab and UnitsInside ( j ) < 6 then
73922: LD_VAR 0 11
73926: PUSH
73927: LD_VAR 0 3
73931: PPUSH
73932: CALL_OW 313
73936: PUSH
73937: LD_INT 6
73939: LESS
73940: AND
73941: IFFALSE 74012
// begin tmp2 := UnitsInside ( idle_lab ) ;
73943: LD_ADDR_VAR 0 9
73947: PUSH
73948: LD_VAR 0 11
73952: PPUSH
73953: CALL_OW 313
73957: ST_TO_ADDR
// if tmp2 then
73958: LD_VAR 0 9
73962: IFFALSE 74004
// for x in tmp2 do
73964: LD_ADDR_VAR 0 7
73968: PUSH
73969: LD_VAR 0 9
73973: PUSH
73974: FOR_IN
73975: IFFALSE 74002
// begin ComExitBuilding ( x ) ;
73977: LD_VAR 0 7
73981: PPUSH
73982: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73986: LD_VAR 0 7
73990: PPUSH
73991: LD_VAR 0 3
73995: PPUSH
73996: CALL_OW 180
// end ;
74000: GO 73974
74002: POP
74003: POP
// idle_lab := 0 ;
74004: LD_ADDR_VAR 0 11
74008: PUSH
74009: LD_INT 0
74011: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
74012: LD_ADDR_VAR 0 5
74016: PUSH
74017: LD_EXP 86
74021: PUSH
74022: LD_VAR 0 4
74026: ARRAY
74027: PUSH
74028: FOR_IN
74029: IFFALSE 74089
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
74031: LD_VAR 0 3
74035: PPUSH
74036: LD_VAR 0 5
74040: PPUSH
74041: CALL_OW 430
74045: PUSH
74046: LD_VAR 0 4
74050: PPUSH
74051: LD_VAR 0 5
74055: PPUSH
74056: CALL 15020 0 2
74060: AND
74061: IFFALSE 74087
// begin researching := true ;
74063: LD_ADDR_VAR 0 10
74067: PUSH
74068: LD_INT 1
74070: ST_TO_ADDR
// ComResearch ( j , t ) ;
74071: LD_VAR 0 3
74075: PPUSH
74076: LD_VAR 0 5
74080: PPUSH
74081: CALL_OW 124
// break ;
74085: GO 74089
// end ;
74087: GO 74028
74089: POP
74090: POP
// if not researching then
74091: LD_VAR 0 10
74095: NOT
74096: IFFALSE 74108
// idle_lab := j ;
74098: LD_ADDR_VAR 0 11
74102: PUSH
74103: LD_VAR 0 3
74107: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
74108: LD_VAR 0 3
74112: PPUSH
74113: CALL_OW 461
74117: PUSH
74118: LD_INT 10
74120: EQUAL
74121: IFFALSE 74709
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
74123: LD_EXP 88
74127: PUSH
74128: LD_VAR 0 2
74132: ARRAY
74133: NOT
74134: PUSH
74135: LD_EXP 89
74139: PUSH
74140: LD_VAR 0 2
74144: ARRAY
74145: NOT
74146: AND
74147: PUSH
74148: LD_EXP 86
74152: PUSH
74153: LD_VAR 0 4
74157: ARRAY
74158: PUSH
74159: LD_INT 1
74161: GREATER
74162: AND
74163: IFFALSE 74294
// begin ComCancel ( j ) ;
74165: LD_VAR 0 3
74169: PPUSH
74170: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
74174: LD_ADDR_EXP 86
74178: PUSH
74179: LD_EXP 86
74183: PPUSH
74184: LD_VAR 0 4
74188: PPUSH
74189: LD_EXP 86
74193: PUSH
74194: LD_VAR 0 4
74198: ARRAY
74199: PPUSH
74200: LD_EXP 86
74204: PUSH
74205: LD_VAR 0 4
74209: ARRAY
74210: PUSH
74211: LD_INT 1
74213: MINUS
74214: PPUSH
74215: LD_EXP 86
74219: PUSH
74220: LD_VAR 0 4
74224: ARRAY
74225: PPUSH
74226: LD_INT 0
74228: PPUSH
74229: CALL 20943 0 4
74233: PPUSH
74234: CALL_OW 1
74238: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
74239: LD_ADDR_EXP 86
74243: PUSH
74244: LD_EXP 86
74248: PPUSH
74249: LD_VAR 0 4
74253: PPUSH
74254: LD_EXP 86
74258: PUSH
74259: LD_VAR 0 4
74263: ARRAY
74264: PPUSH
74265: LD_EXP 86
74269: PUSH
74270: LD_VAR 0 4
74274: ARRAY
74275: PPUSH
74276: LD_INT 1
74278: PPUSH
74279: LD_INT 0
74281: PPUSH
74282: CALL 20943 0 4
74286: PPUSH
74287: CALL_OW 1
74291: ST_TO_ADDR
// continue ;
74292: GO 73866
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74294: LD_EXP 88
74298: PUSH
74299: LD_VAR 0 2
74303: ARRAY
74304: PUSH
74305: LD_EXP 89
74309: PUSH
74310: LD_VAR 0 2
74314: ARRAY
74315: NOT
74316: AND
74317: IFFALSE 74444
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74319: LD_ADDR_EXP 89
74323: PUSH
74324: LD_EXP 89
74328: PPUSH
74329: LD_VAR 0 2
74333: PUSH
74334: LD_EXP 89
74338: PUSH
74339: LD_VAR 0 2
74343: ARRAY
74344: PUSH
74345: LD_INT 1
74347: PLUS
74348: PUSH
74349: EMPTY
74350: LIST
74351: LIST
74352: PPUSH
74353: LD_EXP 88
74357: PUSH
74358: LD_VAR 0 2
74362: ARRAY
74363: PUSH
74364: LD_INT 1
74366: ARRAY
74367: PPUSH
74368: CALL 21525 0 3
74372: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74373: LD_EXP 88
74377: PUSH
74378: LD_VAR 0 2
74382: ARRAY
74383: PUSH
74384: LD_INT 1
74386: ARRAY
74387: PPUSH
74388: LD_INT 112
74390: PPUSH
74391: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74395: LD_ADDR_VAR 0 9
74399: PUSH
74400: LD_EXP 88
74404: PUSH
74405: LD_VAR 0 2
74409: ARRAY
74410: PPUSH
74411: LD_INT 1
74413: PPUSH
74414: CALL_OW 3
74418: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74419: LD_ADDR_EXP 88
74423: PUSH
74424: LD_EXP 88
74428: PPUSH
74429: LD_VAR 0 2
74433: PPUSH
74434: LD_VAR 0 9
74438: PPUSH
74439: CALL_OW 1
74443: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74444: LD_EXP 88
74448: PUSH
74449: LD_VAR 0 2
74453: ARRAY
74454: PUSH
74455: LD_EXP 89
74459: PUSH
74460: LD_VAR 0 2
74464: ARRAY
74465: AND
74466: PUSH
74467: LD_EXP 89
74471: PUSH
74472: LD_VAR 0 2
74476: ARRAY
74477: PUSH
74478: LD_INT 1
74480: ARRAY
74481: PPUSH
74482: CALL_OW 310
74486: NOT
74487: AND
74488: PUSH
74489: LD_VAR 0 3
74493: PPUSH
74494: CALL_OW 313
74498: PUSH
74499: LD_INT 6
74501: EQUAL
74502: AND
74503: IFFALSE 74559
// begin tmp2 := UnitsInside ( j ) ;
74505: LD_ADDR_VAR 0 9
74509: PUSH
74510: LD_VAR 0 3
74514: PPUSH
74515: CALL_OW 313
74519: ST_TO_ADDR
// if tmp2 = 6 then
74520: LD_VAR 0 9
74524: PUSH
74525: LD_INT 6
74527: EQUAL
74528: IFFALSE 74559
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74530: LD_VAR 0 9
74534: PUSH
74535: LD_INT 1
74537: ARRAY
74538: PPUSH
74539: LD_INT 112
74541: PPUSH
74542: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74546: LD_VAR 0 9
74550: PUSH
74551: LD_INT 1
74553: ARRAY
74554: PPUSH
74555: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74559: LD_EXP 89
74563: PUSH
74564: LD_VAR 0 2
74568: ARRAY
74569: PUSH
74570: LD_EXP 89
74574: PUSH
74575: LD_VAR 0 2
74579: ARRAY
74580: PUSH
74581: LD_INT 1
74583: ARRAY
74584: PPUSH
74585: CALL_OW 314
74589: NOT
74590: AND
74591: PUSH
74592: LD_EXP 89
74596: PUSH
74597: LD_VAR 0 2
74601: ARRAY
74602: PUSH
74603: LD_INT 1
74605: ARRAY
74606: PPUSH
74607: CALL_OW 310
74611: NOT
74612: AND
74613: IFFALSE 74639
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74615: LD_EXP 89
74619: PUSH
74620: LD_VAR 0 2
74624: ARRAY
74625: PUSH
74626: LD_INT 1
74628: ARRAY
74629: PPUSH
74630: LD_VAR 0 3
74634: PPUSH
74635: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74639: LD_EXP 89
74643: PUSH
74644: LD_VAR 0 2
74648: ARRAY
74649: PUSH
74650: LD_INT 1
74652: ARRAY
74653: PPUSH
74654: CALL_OW 310
74658: PUSH
74659: LD_EXP 89
74663: PUSH
74664: LD_VAR 0 2
74668: ARRAY
74669: PUSH
74670: LD_INT 1
74672: ARRAY
74673: PPUSH
74674: CALL_OW 310
74678: PPUSH
74679: CALL_OW 461
74683: PUSH
74684: LD_INT 3
74686: NONEQUAL
74687: AND
74688: IFFALSE 74709
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74690: LD_EXP 89
74694: PUSH
74695: LD_VAR 0 2
74699: ARRAY
74700: PUSH
74701: LD_INT 1
74703: ARRAY
74704: PPUSH
74705: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74709: LD_VAR 0 3
74713: PPUSH
74714: CALL_OW 461
74718: PUSH
74719: LD_INT 6
74721: EQUAL
74722: PUSH
74723: LD_VAR 0 6
74727: PUSH
74728: LD_INT 1
74730: GREATER
74731: AND
74732: IFFALSE 74884
// begin sci := [ ] ;
74734: LD_ADDR_VAR 0 8
74738: PUSH
74739: EMPTY
74740: ST_TO_ADDR
// for x in ( tmp diff j ) do
74741: LD_ADDR_VAR 0 7
74745: PUSH
74746: LD_VAR 0 6
74750: PUSH
74751: LD_VAR 0 3
74755: DIFF
74756: PUSH
74757: FOR_IN
74758: IFFALSE 74810
// begin if sci = 6 then
74760: LD_VAR 0 8
74764: PUSH
74765: LD_INT 6
74767: EQUAL
74768: IFFALSE 74772
// break ;
74770: GO 74810
// if BuildingStatus ( x ) = bs_idle then
74772: LD_VAR 0 7
74776: PPUSH
74777: CALL_OW 461
74781: PUSH
74782: LD_INT 2
74784: EQUAL
74785: IFFALSE 74808
// sci := sci ^ UnitsInside ( x ) ;
74787: LD_ADDR_VAR 0 8
74791: PUSH
74792: LD_VAR 0 8
74796: PUSH
74797: LD_VAR 0 7
74801: PPUSH
74802: CALL_OW 313
74806: ADD
74807: ST_TO_ADDR
// end ;
74808: GO 74757
74810: POP
74811: POP
// if not sci then
74812: LD_VAR 0 8
74816: NOT
74817: IFFALSE 74821
// continue ;
74819: GO 73866
// for x in sci do
74821: LD_ADDR_VAR 0 7
74825: PUSH
74826: LD_VAR 0 8
74830: PUSH
74831: FOR_IN
74832: IFFALSE 74882
// if IsInUnit ( x ) and not HasTask ( x ) then
74834: LD_VAR 0 7
74838: PPUSH
74839: CALL_OW 310
74843: PUSH
74844: LD_VAR 0 7
74848: PPUSH
74849: CALL_OW 314
74853: NOT
74854: AND
74855: IFFALSE 74880
// begin ComExitBuilding ( x ) ;
74857: LD_VAR 0 7
74861: PPUSH
74862: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74866: LD_VAR 0 7
74870: PPUSH
74871: LD_VAR 0 3
74875: PPUSH
74876: CALL_OW 180
// end ;
74880: GO 74831
74882: POP
74883: POP
// end ; end ;
74884: GO 73866
74886: POP
74887: POP
// end ;
74888: GO 73820
74890: POP
74891: POP
// end ;
74892: LD_VAR 0 1
74896: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74897: LD_INT 0
74899: PPUSH
74900: PPUSH
// if not mc_bases then
74901: LD_EXP 59
74905: NOT
74906: IFFALSE 74910
// exit ;
74908: GO 74991
// for i = 1 to mc_bases do
74910: LD_ADDR_VAR 0 2
74914: PUSH
74915: DOUBLE
74916: LD_INT 1
74918: DEC
74919: ST_TO_ADDR
74920: LD_EXP 59
74924: PUSH
74925: FOR_TO
74926: IFFALSE 74989
// if mc_mines [ i ] and mc_miners [ i ] then
74928: LD_EXP 72
74932: PUSH
74933: LD_VAR 0 2
74937: ARRAY
74938: PUSH
74939: LD_EXP 73
74943: PUSH
74944: LD_VAR 0 2
74948: ARRAY
74949: AND
74950: IFFALSE 74987
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74952: LD_EXP 73
74956: PUSH
74957: LD_VAR 0 2
74961: ARRAY
74962: PUSH
74963: LD_INT 1
74965: ARRAY
74966: PPUSH
74967: CALL_OW 255
74971: PPUSH
74972: LD_EXP 72
74976: PUSH
74977: LD_VAR 0 2
74981: ARRAY
74982: PPUSH
74983: CALL 18514 0 2
74987: GO 74925
74989: POP
74990: POP
// end ;
74991: LD_VAR 0 1
74995: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74996: LD_INT 0
74998: PPUSH
74999: PPUSH
75000: PPUSH
75001: PPUSH
75002: PPUSH
75003: PPUSH
75004: PPUSH
75005: PPUSH
// if not mc_bases or not mc_parking then
75006: LD_EXP 59
75010: NOT
75011: PUSH
75012: LD_EXP 83
75016: NOT
75017: OR
75018: IFFALSE 75022
// exit ;
75020: GO 75721
// for i = 1 to mc_bases do
75022: LD_ADDR_VAR 0 2
75026: PUSH
75027: DOUBLE
75028: LD_INT 1
75030: DEC
75031: ST_TO_ADDR
75032: LD_EXP 59
75036: PUSH
75037: FOR_TO
75038: IFFALSE 75719
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
75040: LD_EXP 59
75044: PUSH
75045: LD_VAR 0 2
75049: ARRAY
75050: NOT
75051: PUSH
75052: LD_EXP 83
75056: PUSH
75057: LD_VAR 0 2
75061: ARRAY
75062: NOT
75063: OR
75064: IFFALSE 75068
// continue ;
75066: GO 75037
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
75068: LD_ADDR_VAR 0 5
75072: PUSH
75073: LD_EXP 59
75077: PUSH
75078: LD_VAR 0 2
75082: ARRAY
75083: PUSH
75084: LD_INT 1
75086: ARRAY
75087: PPUSH
75088: CALL_OW 255
75092: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75093: LD_ADDR_VAR 0 6
75097: PUSH
75098: LD_EXP 59
75102: PUSH
75103: LD_VAR 0 2
75107: ARRAY
75108: PPUSH
75109: LD_INT 30
75111: PUSH
75112: LD_INT 3
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PPUSH
75119: CALL_OW 72
75123: ST_TO_ADDR
// if not fac then
75124: LD_VAR 0 6
75128: NOT
75129: IFFALSE 75180
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75131: LD_ADDR_VAR 0 6
75135: PUSH
75136: LD_EXP 59
75140: PUSH
75141: LD_VAR 0 2
75145: ARRAY
75146: PPUSH
75147: LD_INT 2
75149: PUSH
75150: LD_INT 30
75152: PUSH
75153: LD_INT 0
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PUSH
75160: LD_INT 30
75162: PUSH
75163: LD_INT 1
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: EMPTY
75171: LIST
75172: LIST
75173: LIST
75174: PPUSH
75175: CALL_OW 72
75179: ST_TO_ADDR
// if not fac then
75180: LD_VAR 0 6
75184: NOT
75185: IFFALSE 75189
// continue ;
75187: GO 75037
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75189: LD_ADDR_VAR 0 7
75193: PUSH
75194: LD_EXP 83
75198: PUSH
75199: LD_VAR 0 2
75203: ARRAY
75204: PPUSH
75205: LD_INT 22
75207: PUSH
75208: LD_VAR 0 5
75212: PUSH
75213: EMPTY
75214: LIST
75215: LIST
75216: PUSH
75217: LD_INT 21
75219: PUSH
75220: LD_INT 2
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 3
75229: PUSH
75230: LD_INT 24
75232: PUSH
75233: LD_INT 1000
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: EMPTY
75245: LIST
75246: LIST
75247: LIST
75248: PPUSH
75249: CALL_OW 70
75253: ST_TO_ADDR
// for j in fac do
75254: LD_ADDR_VAR 0 3
75258: PUSH
75259: LD_VAR 0 6
75263: PUSH
75264: FOR_IN
75265: IFFALSE 75346
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75267: LD_ADDR_VAR 0 7
75271: PUSH
75272: LD_VAR 0 7
75276: PUSH
75277: LD_INT 22
75279: PUSH
75280: LD_VAR 0 5
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: LD_INT 91
75291: PUSH
75292: LD_VAR 0 3
75296: PUSH
75297: LD_INT 15
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: LIST
75304: PUSH
75305: LD_INT 21
75307: PUSH
75308: LD_INT 2
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: LD_INT 3
75317: PUSH
75318: LD_INT 24
75320: PUSH
75321: LD_INT 1000
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: PUSH
75328: EMPTY
75329: LIST
75330: LIST
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: LIST
75336: LIST
75337: PPUSH
75338: CALL_OW 69
75342: UNION
75343: ST_TO_ADDR
75344: GO 75264
75346: POP
75347: POP
// if not vehs then
75348: LD_VAR 0 7
75352: NOT
75353: IFFALSE 75379
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75355: LD_ADDR_EXP 71
75359: PUSH
75360: LD_EXP 71
75364: PPUSH
75365: LD_VAR 0 2
75369: PPUSH
75370: EMPTY
75371: PPUSH
75372: CALL_OW 1
75376: ST_TO_ADDR
// continue ;
75377: GO 75037
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75379: LD_ADDR_VAR 0 8
75383: PUSH
75384: LD_EXP 59
75388: PUSH
75389: LD_VAR 0 2
75393: ARRAY
75394: PPUSH
75395: LD_INT 30
75397: PUSH
75398: LD_INT 3
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: PPUSH
75405: CALL_OW 72
75409: ST_TO_ADDR
// if tmp then
75410: LD_VAR 0 8
75414: IFFALSE 75517
// begin for j in tmp do
75416: LD_ADDR_VAR 0 3
75420: PUSH
75421: LD_VAR 0 8
75425: PUSH
75426: FOR_IN
75427: IFFALSE 75515
// for k in UnitsInside ( j ) do
75429: LD_ADDR_VAR 0 4
75433: PUSH
75434: LD_VAR 0 3
75438: PPUSH
75439: CALL_OW 313
75443: PUSH
75444: FOR_IN
75445: IFFALSE 75511
// if k then
75447: LD_VAR 0 4
75451: IFFALSE 75509
// if not k in mc_repair_vehicle [ i ] then
75453: LD_VAR 0 4
75457: PUSH
75458: LD_EXP 71
75462: PUSH
75463: LD_VAR 0 2
75467: ARRAY
75468: IN
75469: NOT
75470: IFFALSE 75509
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75472: LD_ADDR_EXP 71
75476: PUSH
75477: LD_EXP 71
75481: PPUSH
75482: LD_VAR 0 2
75486: PPUSH
75487: LD_EXP 71
75491: PUSH
75492: LD_VAR 0 2
75496: ARRAY
75497: PUSH
75498: LD_VAR 0 4
75502: UNION
75503: PPUSH
75504: CALL_OW 1
75508: ST_TO_ADDR
75509: GO 75444
75511: POP
75512: POP
75513: GO 75426
75515: POP
75516: POP
// end ; if not mc_repair_vehicle [ i ] then
75517: LD_EXP 71
75521: PUSH
75522: LD_VAR 0 2
75526: ARRAY
75527: NOT
75528: IFFALSE 75532
// continue ;
75530: GO 75037
// for j in mc_repair_vehicle [ i ] do
75532: LD_ADDR_VAR 0 3
75536: PUSH
75537: LD_EXP 71
75541: PUSH
75542: LD_VAR 0 2
75546: ARRAY
75547: PUSH
75548: FOR_IN
75549: IFFALSE 75715
// begin if GetClass ( j ) <> 3 then
75551: LD_VAR 0 3
75555: PPUSH
75556: CALL_OW 257
75560: PUSH
75561: LD_INT 3
75563: NONEQUAL
75564: IFFALSE 75605
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75566: LD_ADDR_EXP 71
75570: PUSH
75571: LD_EXP 71
75575: PPUSH
75576: LD_VAR 0 2
75580: PPUSH
75581: LD_EXP 71
75585: PUSH
75586: LD_VAR 0 2
75590: ARRAY
75591: PUSH
75592: LD_VAR 0 3
75596: DIFF
75597: PPUSH
75598: CALL_OW 1
75602: ST_TO_ADDR
// continue ;
75603: GO 75548
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75605: LD_VAR 0 3
75609: PPUSH
75610: CALL_OW 311
75614: NOT
75615: PUSH
75616: LD_VAR 0 3
75620: PUSH
75621: LD_EXP 62
75625: PUSH
75626: LD_VAR 0 2
75630: ARRAY
75631: PUSH
75632: LD_INT 1
75634: ARRAY
75635: IN
75636: NOT
75637: AND
75638: PUSH
75639: LD_VAR 0 3
75643: PUSH
75644: LD_EXP 62
75648: PUSH
75649: LD_VAR 0 2
75653: ARRAY
75654: PUSH
75655: LD_INT 2
75657: ARRAY
75658: IN
75659: NOT
75660: AND
75661: IFFALSE 75713
// begin if IsInUnit ( j ) then
75663: LD_VAR 0 3
75667: PPUSH
75668: CALL_OW 310
75672: IFFALSE 75683
// ComExitBuilding ( j ) ;
75674: LD_VAR 0 3
75678: PPUSH
75679: CALL_OW 122
// if not HasTask ( j ) then
75683: LD_VAR 0 3
75687: PPUSH
75688: CALL_OW 314
75692: NOT
75693: IFFALSE 75713
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75695: LD_VAR 0 3
75699: PPUSH
75700: LD_VAR 0 7
75704: PUSH
75705: LD_INT 1
75707: ARRAY
75708: PPUSH
75709: CALL_OW 189
// end ; end ;
75713: GO 75548
75715: POP
75716: POP
// end ;
75717: GO 75037
75719: POP
75720: POP
// end ;
75721: LD_VAR 0 1
75725: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75726: LD_INT 0
75728: PPUSH
75729: PPUSH
75730: PPUSH
75731: PPUSH
75732: PPUSH
75733: PPUSH
75734: PPUSH
75735: PPUSH
75736: PPUSH
75737: PPUSH
75738: PPUSH
// if not mc_bases then
75739: LD_EXP 59
75743: NOT
75744: IFFALSE 75748
// exit ;
75746: GO 76550
// for i = 1 to mc_bases do
75748: LD_ADDR_VAR 0 2
75752: PUSH
75753: DOUBLE
75754: LD_INT 1
75756: DEC
75757: ST_TO_ADDR
75758: LD_EXP 59
75762: PUSH
75763: FOR_TO
75764: IFFALSE 76548
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75766: LD_EXP 87
75770: PUSH
75771: LD_VAR 0 2
75775: ARRAY
75776: NOT
75777: PUSH
75778: LD_EXP 62
75782: PUSH
75783: LD_VAR 0 2
75787: ARRAY
75788: PUSH
75789: LD_INT 1
75791: ARRAY
75792: OR
75793: PUSH
75794: LD_EXP 62
75798: PUSH
75799: LD_VAR 0 2
75803: ARRAY
75804: PUSH
75805: LD_INT 2
75807: ARRAY
75808: OR
75809: PUSH
75810: LD_EXP 85
75814: PUSH
75815: LD_VAR 0 2
75819: ARRAY
75820: PPUSH
75821: LD_INT 1
75823: PPUSH
75824: CALL_OW 325
75828: NOT
75829: OR
75830: PUSH
75831: LD_EXP 82
75835: PUSH
75836: LD_VAR 0 2
75840: ARRAY
75841: OR
75842: IFFALSE 75846
// continue ;
75844: GO 75763
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75846: LD_ADDR_VAR 0 8
75850: PUSH
75851: LD_EXP 59
75855: PUSH
75856: LD_VAR 0 2
75860: ARRAY
75861: PPUSH
75862: LD_INT 25
75864: PUSH
75865: LD_INT 4
75867: PUSH
75868: EMPTY
75869: LIST
75870: LIST
75871: PUSH
75872: LD_INT 50
75874: PUSH
75875: EMPTY
75876: LIST
75877: PUSH
75878: LD_INT 3
75880: PUSH
75881: LD_INT 60
75883: PUSH
75884: EMPTY
75885: LIST
75886: PUSH
75887: EMPTY
75888: LIST
75889: LIST
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: LIST
75895: PPUSH
75896: CALL_OW 72
75900: PUSH
75901: LD_EXP 63
75905: PUSH
75906: LD_VAR 0 2
75910: ARRAY
75911: DIFF
75912: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75913: LD_ADDR_VAR 0 9
75917: PUSH
75918: LD_EXP 59
75922: PUSH
75923: LD_VAR 0 2
75927: ARRAY
75928: PPUSH
75929: LD_INT 2
75931: PUSH
75932: LD_INT 30
75934: PUSH
75935: LD_INT 0
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: PUSH
75942: LD_INT 30
75944: PUSH
75945: LD_INT 1
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: LIST
75956: PPUSH
75957: CALL_OW 72
75961: ST_TO_ADDR
// if not tmp or not dep then
75962: LD_VAR 0 8
75966: NOT
75967: PUSH
75968: LD_VAR 0 9
75972: NOT
75973: OR
75974: IFFALSE 75978
// continue ;
75976: GO 75763
// side := GetSide ( tmp [ 1 ] ) ;
75978: LD_ADDR_VAR 0 11
75982: PUSH
75983: LD_VAR 0 8
75987: PUSH
75988: LD_INT 1
75990: ARRAY
75991: PPUSH
75992: CALL_OW 255
75996: ST_TO_ADDR
// dep := dep [ 1 ] ;
75997: LD_ADDR_VAR 0 9
76001: PUSH
76002: LD_VAR 0 9
76006: PUSH
76007: LD_INT 1
76009: ARRAY
76010: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
76011: LD_ADDR_VAR 0 7
76015: PUSH
76016: LD_EXP 87
76020: PUSH
76021: LD_VAR 0 2
76025: ARRAY
76026: PPUSH
76027: LD_INT 22
76029: PUSH
76030: LD_INT 0
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 25
76039: PUSH
76040: LD_INT 12
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: PUSH
76047: EMPTY
76048: LIST
76049: LIST
76050: PPUSH
76051: CALL_OW 70
76055: PUSH
76056: LD_INT 22
76058: PUSH
76059: LD_INT 0
76061: PUSH
76062: EMPTY
76063: LIST
76064: LIST
76065: PUSH
76066: LD_INT 25
76068: PUSH
76069: LD_INT 12
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PUSH
76076: LD_INT 91
76078: PUSH
76079: LD_VAR 0 9
76083: PUSH
76084: LD_INT 20
76086: PUSH
76087: EMPTY
76088: LIST
76089: LIST
76090: LIST
76091: PUSH
76092: EMPTY
76093: LIST
76094: LIST
76095: LIST
76096: PPUSH
76097: CALL_OW 69
76101: UNION
76102: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
76103: LD_ADDR_VAR 0 10
76107: PUSH
76108: LD_EXP 87
76112: PUSH
76113: LD_VAR 0 2
76117: ARRAY
76118: PPUSH
76119: LD_INT 81
76121: PUSH
76122: LD_VAR 0 11
76126: PUSH
76127: EMPTY
76128: LIST
76129: LIST
76130: PPUSH
76131: CALL_OW 70
76135: ST_TO_ADDR
// if not apes or danger_at_area then
76136: LD_VAR 0 7
76140: NOT
76141: PUSH
76142: LD_VAR 0 10
76146: OR
76147: IFFALSE 76197
// begin if mc_taming [ i ] then
76149: LD_EXP 90
76153: PUSH
76154: LD_VAR 0 2
76158: ARRAY
76159: IFFALSE 76195
// begin MC_Reset ( i , 121 ) ;
76161: LD_VAR 0 2
76165: PPUSH
76166: LD_INT 121
76168: PPUSH
76169: CALL 61528 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
76173: LD_ADDR_EXP 90
76177: PUSH
76178: LD_EXP 90
76182: PPUSH
76183: LD_VAR 0 2
76187: PPUSH
76188: EMPTY
76189: PPUSH
76190: CALL_OW 1
76194: ST_TO_ADDR
// end ; continue ;
76195: GO 75763
// end ; for j in tmp do
76197: LD_ADDR_VAR 0 3
76201: PUSH
76202: LD_VAR 0 8
76206: PUSH
76207: FOR_IN
76208: IFFALSE 76544
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
76210: LD_VAR 0 3
76214: PUSH
76215: LD_EXP 90
76219: PUSH
76220: LD_VAR 0 2
76224: ARRAY
76225: IN
76226: NOT
76227: PUSH
76228: LD_EXP 90
76232: PUSH
76233: LD_VAR 0 2
76237: ARRAY
76238: PUSH
76239: LD_INT 3
76241: LESS
76242: AND
76243: IFFALSE 76301
// begin SetTag ( j , 121 ) ;
76245: LD_VAR 0 3
76249: PPUSH
76250: LD_INT 121
76252: PPUSH
76253: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76257: LD_ADDR_EXP 90
76261: PUSH
76262: LD_EXP 90
76266: PPUSH
76267: LD_VAR 0 2
76271: PUSH
76272: LD_EXP 90
76276: PUSH
76277: LD_VAR 0 2
76281: ARRAY
76282: PUSH
76283: LD_INT 1
76285: PLUS
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: PPUSH
76291: LD_VAR 0 3
76295: PPUSH
76296: CALL 21525 0 3
76300: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76301: LD_VAR 0 3
76305: PUSH
76306: LD_EXP 90
76310: PUSH
76311: LD_VAR 0 2
76315: ARRAY
76316: IN
76317: IFFALSE 76542
// begin if GetClass ( j ) <> 4 then
76319: LD_VAR 0 3
76323: PPUSH
76324: CALL_OW 257
76328: PUSH
76329: LD_INT 4
76331: NONEQUAL
76332: IFFALSE 76385
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76334: LD_ADDR_EXP 90
76338: PUSH
76339: LD_EXP 90
76343: PPUSH
76344: LD_VAR 0 2
76348: PPUSH
76349: LD_EXP 90
76353: PUSH
76354: LD_VAR 0 2
76358: ARRAY
76359: PUSH
76360: LD_VAR 0 3
76364: DIFF
76365: PPUSH
76366: CALL_OW 1
76370: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76371: LD_VAR 0 3
76375: PPUSH
76376: LD_INT 0
76378: PPUSH
76379: CALL_OW 109
// continue ;
76383: GO 76207
// end ; if IsInUnit ( j ) then
76385: LD_VAR 0 3
76389: PPUSH
76390: CALL_OW 310
76394: IFFALSE 76405
// ComExitBuilding ( j ) ;
76396: LD_VAR 0 3
76400: PPUSH
76401: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76405: LD_ADDR_VAR 0 6
76409: PUSH
76410: LD_VAR 0 7
76414: PPUSH
76415: LD_VAR 0 3
76419: PPUSH
76420: CALL_OW 74
76424: ST_TO_ADDR
// if not ape then
76425: LD_VAR 0 6
76429: NOT
76430: IFFALSE 76434
// break ;
76432: GO 76544
// x := GetX ( ape ) ;
76434: LD_ADDR_VAR 0 4
76438: PUSH
76439: LD_VAR 0 6
76443: PPUSH
76444: CALL_OW 250
76448: ST_TO_ADDR
// y := GetY ( ape ) ;
76449: LD_ADDR_VAR 0 5
76453: PUSH
76454: LD_VAR 0 6
76458: PPUSH
76459: CALL_OW 251
76463: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76464: LD_VAR 0 4
76468: PPUSH
76469: LD_VAR 0 5
76473: PPUSH
76474: CALL_OW 488
76478: NOT
76479: PUSH
76480: LD_VAR 0 11
76484: PPUSH
76485: LD_VAR 0 4
76489: PPUSH
76490: LD_VAR 0 5
76494: PPUSH
76495: LD_INT 20
76497: PPUSH
76498: CALL 22421 0 4
76502: PUSH
76503: LD_INT 4
76505: ARRAY
76506: OR
76507: IFFALSE 76511
// break ;
76509: GO 76544
// if not HasTask ( j ) then
76511: LD_VAR 0 3
76515: PPUSH
76516: CALL_OW 314
76520: NOT
76521: IFFALSE 76542
// ComTameXY ( j , x , y ) ;
76523: LD_VAR 0 3
76527: PPUSH
76528: LD_VAR 0 4
76532: PPUSH
76533: LD_VAR 0 5
76537: PPUSH
76538: CALL_OW 131
// end ; end ;
76542: GO 76207
76544: POP
76545: POP
// end ;
76546: GO 75763
76548: POP
76549: POP
// end ;
76550: LD_VAR 0 1
76554: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76555: LD_INT 0
76557: PPUSH
76558: PPUSH
76559: PPUSH
76560: PPUSH
76561: PPUSH
76562: PPUSH
76563: PPUSH
76564: PPUSH
// if not mc_bases then
76565: LD_EXP 59
76569: NOT
76570: IFFALSE 76574
// exit ;
76572: GO 77200
// for i = 1 to mc_bases do
76574: LD_ADDR_VAR 0 2
76578: PUSH
76579: DOUBLE
76580: LD_INT 1
76582: DEC
76583: ST_TO_ADDR
76584: LD_EXP 59
76588: PUSH
76589: FOR_TO
76590: IFFALSE 77198
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76592: LD_EXP 88
76596: PUSH
76597: LD_VAR 0 2
76601: ARRAY
76602: NOT
76603: PUSH
76604: LD_EXP 88
76608: PUSH
76609: LD_VAR 0 2
76613: ARRAY
76614: PPUSH
76615: LD_INT 25
76617: PUSH
76618: LD_INT 12
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PPUSH
76625: CALL_OW 72
76629: NOT
76630: OR
76631: IFFALSE 76635
// continue ;
76633: GO 76589
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76635: LD_ADDR_VAR 0 5
76639: PUSH
76640: LD_EXP 88
76644: PUSH
76645: LD_VAR 0 2
76649: ARRAY
76650: PUSH
76651: LD_INT 1
76653: ARRAY
76654: PPUSH
76655: CALL_OW 255
76659: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76660: LD_VAR 0 5
76664: PPUSH
76665: LD_INT 2
76667: PPUSH
76668: CALL_OW 325
76672: IFFALSE 76925
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76674: LD_ADDR_VAR 0 4
76678: PUSH
76679: LD_EXP 88
76683: PUSH
76684: LD_VAR 0 2
76688: ARRAY
76689: PPUSH
76690: LD_INT 25
76692: PUSH
76693: LD_INT 16
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PPUSH
76700: CALL_OW 72
76704: ST_TO_ADDR
// if tmp < 6 then
76705: LD_VAR 0 4
76709: PUSH
76710: LD_INT 6
76712: LESS
76713: IFFALSE 76925
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76715: LD_ADDR_VAR 0 6
76719: PUSH
76720: LD_EXP 59
76724: PUSH
76725: LD_VAR 0 2
76729: ARRAY
76730: PPUSH
76731: LD_INT 2
76733: PUSH
76734: LD_INT 30
76736: PUSH
76737: LD_INT 0
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 30
76746: PUSH
76747: LD_INT 1
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: LIST
76758: PPUSH
76759: CALL_OW 72
76763: ST_TO_ADDR
// if depot then
76764: LD_VAR 0 6
76768: IFFALSE 76925
// begin selected := 0 ;
76770: LD_ADDR_VAR 0 7
76774: PUSH
76775: LD_INT 0
76777: ST_TO_ADDR
// for j in depot do
76778: LD_ADDR_VAR 0 3
76782: PUSH
76783: LD_VAR 0 6
76787: PUSH
76788: FOR_IN
76789: IFFALSE 76820
// begin if UnitsInside ( j ) < 6 then
76791: LD_VAR 0 3
76795: PPUSH
76796: CALL_OW 313
76800: PUSH
76801: LD_INT 6
76803: LESS
76804: IFFALSE 76818
// begin selected := j ;
76806: LD_ADDR_VAR 0 7
76810: PUSH
76811: LD_VAR 0 3
76815: ST_TO_ADDR
// break ;
76816: GO 76820
// end ; end ;
76818: GO 76788
76820: POP
76821: POP
// if selected then
76822: LD_VAR 0 7
76826: IFFALSE 76925
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76828: LD_ADDR_VAR 0 3
76832: PUSH
76833: LD_EXP 88
76837: PUSH
76838: LD_VAR 0 2
76842: ARRAY
76843: PPUSH
76844: LD_INT 25
76846: PUSH
76847: LD_INT 12
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PPUSH
76854: CALL_OW 72
76858: PUSH
76859: FOR_IN
76860: IFFALSE 76923
// if not HasTask ( j ) then
76862: LD_VAR 0 3
76866: PPUSH
76867: CALL_OW 314
76871: NOT
76872: IFFALSE 76921
// begin if not IsInUnit ( j ) then
76874: LD_VAR 0 3
76878: PPUSH
76879: CALL_OW 310
76883: NOT
76884: IFFALSE 76900
// ComEnterUnit ( j , selected ) ;
76886: LD_VAR 0 3
76890: PPUSH
76891: LD_VAR 0 7
76895: PPUSH
76896: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76900: LD_VAR 0 3
76904: PPUSH
76905: LD_INT 16
76907: PPUSH
76908: CALL_OW 183
// AddComExitBuilding ( j ) ;
76912: LD_VAR 0 3
76916: PPUSH
76917: CALL_OW 182
// end ;
76921: GO 76859
76923: POP
76924: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76925: LD_VAR 0 5
76929: PPUSH
76930: LD_INT 11
76932: PPUSH
76933: CALL_OW 325
76937: IFFALSE 77196
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76939: LD_ADDR_VAR 0 4
76943: PUSH
76944: LD_EXP 88
76948: PUSH
76949: LD_VAR 0 2
76953: ARRAY
76954: PPUSH
76955: LD_INT 25
76957: PUSH
76958: LD_INT 16
76960: PUSH
76961: EMPTY
76962: LIST
76963: LIST
76964: PPUSH
76965: CALL_OW 72
76969: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76970: LD_VAR 0 4
76974: PUSH
76975: LD_INT 6
76977: GREATEREQUAL
76978: PUSH
76979: LD_VAR 0 5
76983: PPUSH
76984: LD_INT 2
76986: PPUSH
76987: CALL_OW 325
76991: NOT
76992: OR
76993: IFFALSE 77196
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76995: LD_ADDR_VAR 0 8
76999: PUSH
77000: LD_EXP 59
77004: PUSH
77005: LD_VAR 0 2
77009: ARRAY
77010: PPUSH
77011: LD_INT 2
77013: PUSH
77014: LD_INT 30
77016: PUSH
77017: LD_INT 4
77019: PUSH
77020: EMPTY
77021: LIST
77022: LIST
77023: PUSH
77024: LD_INT 30
77026: PUSH
77027: LD_INT 5
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: LIST
77038: PPUSH
77039: CALL_OW 72
77043: ST_TO_ADDR
// if barracks then
77044: LD_VAR 0 8
77048: IFFALSE 77196
// begin selected := 0 ;
77050: LD_ADDR_VAR 0 7
77054: PUSH
77055: LD_INT 0
77057: ST_TO_ADDR
// for j in barracks do
77058: LD_ADDR_VAR 0 3
77062: PUSH
77063: LD_VAR 0 8
77067: PUSH
77068: FOR_IN
77069: IFFALSE 77100
// begin if UnitsInside ( j ) < 6 then
77071: LD_VAR 0 3
77075: PPUSH
77076: CALL_OW 313
77080: PUSH
77081: LD_INT 6
77083: LESS
77084: IFFALSE 77098
// begin selected := j ;
77086: LD_ADDR_VAR 0 7
77090: PUSH
77091: LD_VAR 0 3
77095: ST_TO_ADDR
// break ;
77096: GO 77100
// end ; end ;
77098: GO 77068
77100: POP
77101: POP
// if selected then
77102: LD_VAR 0 7
77106: IFFALSE 77196
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
77108: LD_ADDR_VAR 0 3
77112: PUSH
77113: LD_EXP 88
77117: PUSH
77118: LD_VAR 0 2
77122: ARRAY
77123: PPUSH
77124: LD_INT 25
77126: PUSH
77127: LD_INT 12
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PPUSH
77134: CALL_OW 72
77138: PUSH
77139: FOR_IN
77140: IFFALSE 77194
// if not IsInUnit ( j ) and not HasTask ( j ) then
77142: LD_VAR 0 3
77146: PPUSH
77147: CALL_OW 310
77151: NOT
77152: PUSH
77153: LD_VAR 0 3
77157: PPUSH
77158: CALL_OW 314
77162: NOT
77163: AND
77164: IFFALSE 77192
// begin ComEnterUnit ( j , selected ) ;
77166: LD_VAR 0 3
77170: PPUSH
77171: LD_VAR 0 7
77175: PPUSH
77176: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
77180: LD_VAR 0 3
77184: PPUSH
77185: LD_INT 15
77187: PPUSH
77188: CALL_OW 183
// end ;
77192: GO 77139
77194: POP
77195: POP
// end ; end ; end ; end ; end ;
77196: GO 76589
77198: POP
77199: POP
// end ;
77200: LD_VAR 0 1
77204: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
77205: LD_INT 0
77207: PPUSH
77208: PPUSH
77209: PPUSH
77210: PPUSH
// if not mc_bases then
77211: LD_EXP 59
77215: NOT
77216: IFFALSE 77220
// exit ;
77218: GO 77398
// for i = 1 to mc_bases do
77220: LD_ADDR_VAR 0 2
77224: PUSH
77225: DOUBLE
77226: LD_INT 1
77228: DEC
77229: ST_TO_ADDR
77230: LD_EXP 59
77234: PUSH
77235: FOR_TO
77236: IFFALSE 77396
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
77238: LD_ADDR_VAR 0 4
77242: PUSH
77243: LD_EXP 59
77247: PUSH
77248: LD_VAR 0 2
77252: ARRAY
77253: PPUSH
77254: LD_INT 25
77256: PUSH
77257: LD_INT 9
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: PPUSH
77264: CALL_OW 72
77268: ST_TO_ADDR
// if not tmp then
77269: LD_VAR 0 4
77273: NOT
77274: IFFALSE 77278
// continue ;
77276: GO 77235
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77278: LD_EXP 85
77282: PUSH
77283: LD_VAR 0 2
77287: ARRAY
77288: PPUSH
77289: LD_INT 29
77291: PPUSH
77292: CALL_OW 325
77296: NOT
77297: PUSH
77298: LD_EXP 85
77302: PUSH
77303: LD_VAR 0 2
77307: ARRAY
77308: PPUSH
77309: LD_INT 28
77311: PPUSH
77312: CALL_OW 325
77316: NOT
77317: AND
77318: IFFALSE 77322
// continue ;
77320: GO 77235
// for j in tmp do
77322: LD_ADDR_VAR 0 3
77326: PUSH
77327: LD_VAR 0 4
77331: PUSH
77332: FOR_IN
77333: IFFALSE 77392
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77335: LD_VAR 0 3
77339: PUSH
77340: LD_EXP 62
77344: PUSH
77345: LD_VAR 0 2
77349: ARRAY
77350: PUSH
77351: LD_INT 1
77353: ARRAY
77354: IN
77355: NOT
77356: PUSH
77357: LD_VAR 0 3
77361: PUSH
77362: LD_EXP 62
77366: PUSH
77367: LD_VAR 0 2
77371: ARRAY
77372: PUSH
77373: LD_INT 2
77375: ARRAY
77376: IN
77377: NOT
77378: AND
77379: IFFALSE 77390
// ComSpaceTimeShoot ( j ) ;
77381: LD_VAR 0 3
77385: PPUSH
77386: CALL 15111 0 1
77390: GO 77332
77392: POP
77393: POP
// end ;
77394: GO 77235
77396: POP
77397: POP
// end ;
77398: LD_VAR 0 1
77402: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77403: LD_INT 0
77405: PPUSH
77406: PPUSH
77407: PPUSH
77408: PPUSH
77409: PPUSH
77410: PPUSH
77411: PPUSH
77412: PPUSH
77413: PPUSH
// if not mc_bases then
77414: LD_EXP 59
77418: NOT
77419: IFFALSE 77423
// exit ;
77421: GO 78045
// for i = 1 to mc_bases do
77423: LD_ADDR_VAR 0 2
77427: PUSH
77428: DOUBLE
77429: LD_INT 1
77431: DEC
77432: ST_TO_ADDR
77433: LD_EXP 59
77437: PUSH
77438: FOR_TO
77439: IFFALSE 78043
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77441: LD_EXP 94
77445: PUSH
77446: LD_VAR 0 2
77450: ARRAY
77451: NOT
77452: PUSH
77453: LD_INT 38
77455: PPUSH
77456: LD_EXP 85
77460: PUSH
77461: LD_VAR 0 2
77465: ARRAY
77466: PPUSH
77467: CALL_OW 321
77471: PUSH
77472: LD_INT 2
77474: NONEQUAL
77475: OR
77476: IFFALSE 77480
// continue ;
77478: GO 77438
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77480: LD_ADDR_VAR 0 8
77484: PUSH
77485: LD_EXP 59
77489: PUSH
77490: LD_VAR 0 2
77494: ARRAY
77495: PPUSH
77496: LD_INT 30
77498: PUSH
77499: LD_INT 34
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: PPUSH
77506: CALL_OW 72
77510: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77511: LD_ADDR_VAR 0 9
77515: PUSH
77516: LD_EXP 59
77520: PUSH
77521: LD_VAR 0 2
77525: ARRAY
77526: PPUSH
77527: LD_INT 25
77529: PUSH
77530: LD_INT 4
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PPUSH
77537: CALL_OW 72
77541: PPUSH
77542: LD_INT 0
77544: PPUSH
77545: CALL 54785 0 2
77549: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77550: LD_VAR 0 9
77554: NOT
77555: PUSH
77556: LD_VAR 0 8
77560: NOT
77561: OR
77562: PUSH
77563: LD_EXP 59
77567: PUSH
77568: LD_VAR 0 2
77572: ARRAY
77573: PPUSH
77574: LD_INT 124
77576: PPUSH
77577: CALL 54785 0 2
77581: OR
77582: IFFALSE 77586
// continue ;
77584: GO 77438
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77586: LD_EXP 95
77590: PUSH
77591: LD_VAR 0 2
77595: ARRAY
77596: PUSH
77597: LD_EXP 94
77601: PUSH
77602: LD_VAR 0 2
77606: ARRAY
77607: LESS
77608: PUSH
77609: LD_EXP 95
77613: PUSH
77614: LD_VAR 0 2
77618: ARRAY
77619: PUSH
77620: LD_VAR 0 8
77624: LESS
77625: AND
77626: IFFALSE 78041
// begin tmp := sci [ 1 ] ;
77628: LD_ADDR_VAR 0 7
77632: PUSH
77633: LD_VAR 0 9
77637: PUSH
77638: LD_INT 1
77640: ARRAY
77641: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77642: LD_VAR 0 7
77646: PPUSH
77647: LD_INT 124
77649: PPUSH
77650: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77654: LD_ADDR_VAR 0 3
77658: PUSH
77659: DOUBLE
77660: LD_EXP 94
77664: PUSH
77665: LD_VAR 0 2
77669: ARRAY
77670: INC
77671: ST_TO_ADDR
77672: LD_EXP 94
77676: PUSH
77677: LD_VAR 0 2
77681: ARRAY
77682: PUSH
77683: FOR_DOWNTO
77684: IFFALSE 78027
// begin if IsInUnit ( tmp ) then
77686: LD_VAR 0 7
77690: PPUSH
77691: CALL_OW 310
77695: IFFALSE 77706
// ComExitBuilding ( tmp ) ;
77697: LD_VAR 0 7
77701: PPUSH
77702: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77706: LD_INT 35
77708: PPUSH
77709: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77713: LD_VAR 0 7
77717: PPUSH
77718: CALL_OW 310
77722: NOT
77723: PUSH
77724: LD_VAR 0 7
77728: PPUSH
77729: CALL_OW 314
77733: NOT
77734: AND
77735: IFFALSE 77706
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77737: LD_ADDR_VAR 0 6
77741: PUSH
77742: LD_VAR 0 7
77746: PPUSH
77747: CALL_OW 250
77751: PUSH
77752: LD_VAR 0 7
77756: PPUSH
77757: CALL_OW 251
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77766: LD_INT 35
77768: PPUSH
77769: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77773: LD_ADDR_VAR 0 4
77777: PUSH
77778: LD_EXP 94
77782: PUSH
77783: LD_VAR 0 2
77787: ARRAY
77788: PUSH
77789: LD_VAR 0 3
77793: ARRAY
77794: PUSH
77795: LD_INT 1
77797: ARRAY
77798: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77799: LD_ADDR_VAR 0 5
77803: PUSH
77804: LD_EXP 94
77808: PUSH
77809: LD_VAR 0 2
77813: ARRAY
77814: PUSH
77815: LD_VAR 0 3
77819: ARRAY
77820: PUSH
77821: LD_INT 2
77823: ARRAY
77824: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77825: LD_VAR 0 7
77829: PPUSH
77830: LD_INT 10
77832: PPUSH
77833: CALL 24118 0 2
77837: PUSH
77838: LD_INT 4
77840: ARRAY
77841: IFFALSE 77879
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77843: LD_VAR 0 7
77847: PPUSH
77848: LD_VAR 0 6
77852: PUSH
77853: LD_INT 1
77855: ARRAY
77856: PPUSH
77857: LD_VAR 0 6
77861: PUSH
77862: LD_INT 2
77864: ARRAY
77865: PPUSH
77866: CALL_OW 111
// wait ( 0 0$10 ) ;
77870: LD_INT 350
77872: PPUSH
77873: CALL_OW 67
// end else
77877: GO 77905
// begin ComMoveXY ( tmp , x , y ) ;
77879: LD_VAR 0 7
77883: PPUSH
77884: LD_VAR 0 4
77888: PPUSH
77889: LD_VAR 0 5
77893: PPUSH
77894: CALL_OW 111
// wait ( 0 0$3 ) ;
77898: LD_INT 105
77900: PPUSH
77901: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77905: LD_VAR 0 7
77909: PPUSH
77910: LD_VAR 0 4
77914: PPUSH
77915: LD_VAR 0 5
77919: PPUSH
77920: CALL_OW 307
77924: IFFALSE 77766
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77926: LD_VAR 0 7
77930: PPUSH
77931: LD_VAR 0 4
77935: PPUSH
77936: LD_VAR 0 5
77940: PPUSH
77941: LD_VAR 0 8
77945: PUSH
77946: LD_VAR 0 3
77950: ARRAY
77951: PPUSH
77952: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77956: LD_INT 35
77958: PPUSH
77959: CALL_OW 67
// until not HasTask ( tmp ) ;
77963: LD_VAR 0 7
77967: PPUSH
77968: CALL_OW 314
77972: NOT
77973: IFFALSE 77956
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77975: LD_ADDR_EXP 95
77979: PUSH
77980: LD_EXP 95
77984: PPUSH
77985: LD_VAR 0 2
77989: PUSH
77990: LD_EXP 95
77994: PUSH
77995: LD_VAR 0 2
77999: ARRAY
78000: PUSH
78001: LD_INT 1
78003: PLUS
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: PPUSH
78009: LD_VAR 0 8
78013: PUSH
78014: LD_VAR 0 3
78018: ARRAY
78019: PPUSH
78020: CALL 21525 0 3
78024: ST_TO_ADDR
// end ;
78025: GO 77683
78027: POP
78028: POP
// MC_Reset ( i , 124 ) ;
78029: LD_VAR 0 2
78033: PPUSH
78034: LD_INT 124
78036: PPUSH
78037: CALL 61528 0 2
// end ; end ;
78041: GO 77438
78043: POP
78044: POP
// end ;
78045: LD_VAR 0 1
78049: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
78050: LD_INT 0
78052: PPUSH
78053: PPUSH
78054: PPUSH
// if not mc_bases then
78055: LD_EXP 59
78059: NOT
78060: IFFALSE 78064
// exit ;
78062: GO 78670
// for i = 1 to mc_bases do
78064: LD_ADDR_VAR 0 2
78068: PUSH
78069: DOUBLE
78070: LD_INT 1
78072: DEC
78073: ST_TO_ADDR
78074: LD_EXP 59
78078: PUSH
78079: FOR_TO
78080: IFFALSE 78668
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
78082: LD_ADDR_VAR 0 3
78086: PUSH
78087: LD_EXP 59
78091: PUSH
78092: LD_VAR 0 2
78096: ARRAY
78097: PPUSH
78098: LD_INT 25
78100: PUSH
78101: LD_INT 4
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PPUSH
78108: CALL_OW 72
78112: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78113: LD_VAR 0 3
78117: NOT
78118: PUSH
78119: LD_EXP 96
78123: PUSH
78124: LD_VAR 0 2
78128: ARRAY
78129: NOT
78130: OR
78131: PUSH
78132: LD_EXP 59
78136: PUSH
78137: LD_VAR 0 2
78141: ARRAY
78142: PPUSH
78143: LD_INT 2
78145: PUSH
78146: LD_INT 30
78148: PUSH
78149: LD_INT 0
78151: PUSH
78152: EMPTY
78153: LIST
78154: LIST
78155: PUSH
78156: LD_INT 30
78158: PUSH
78159: LD_INT 1
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: LIST
78170: PPUSH
78171: CALL_OW 72
78175: NOT
78176: OR
78177: IFFALSE 78227
// begin if mc_deposits_finder [ i ] then
78179: LD_EXP 97
78183: PUSH
78184: LD_VAR 0 2
78188: ARRAY
78189: IFFALSE 78225
// begin MC_Reset ( i , 125 ) ;
78191: LD_VAR 0 2
78195: PPUSH
78196: LD_INT 125
78198: PPUSH
78199: CALL 61528 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78203: LD_ADDR_EXP 97
78207: PUSH
78208: LD_EXP 97
78212: PPUSH
78213: LD_VAR 0 2
78217: PPUSH
78218: EMPTY
78219: PPUSH
78220: CALL_OW 1
78224: ST_TO_ADDR
// end ; continue ;
78225: GO 78079
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
78227: LD_EXP 96
78231: PUSH
78232: LD_VAR 0 2
78236: ARRAY
78237: PUSH
78238: LD_INT 1
78240: ARRAY
78241: PUSH
78242: LD_INT 3
78244: ARRAY
78245: PUSH
78246: LD_INT 1
78248: EQUAL
78249: PUSH
78250: LD_INT 20
78252: PPUSH
78253: LD_EXP 85
78257: PUSH
78258: LD_VAR 0 2
78262: ARRAY
78263: PPUSH
78264: CALL_OW 321
78268: PUSH
78269: LD_INT 2
78271: NONEQUAL
78272: AND
78273: IFFALSE 78323
// begin if mc_deposits_finder [ i ] then
78275: LD_EXP 97
78279: PUSH
78280: LD_VAR 0 2
78284: ARRAY
78285: IFFALSE 78321
// begin MC_Reset ( i , 125 ) ;
78287: LD_VAR 0 2
78291: PPUSH
78292: LD_INT 125
78294: PPUSH
78295: CALL 61528 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78299: LD_ADDR_EXP 97
78303: PUSH
78304: LD_EXP 97
78308: PPUSH
78309: LD_VAR 0 2
78313: PPUSH
78314: EMPTY
78315: PPUSH
78316: CALL_OW 1
78320: ST_TO_ADDR
// end ; continue ;
78321: GO 78079
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78323: LD_EXP 96
78327: PUSH
78328: LD_VAR 0 2
78332: ARRAY
78333: PUSH
78334: LD_INT 1
78336: ARRAY
78337: PUSH
78338: LD_INT 1
78340: ARRAY
78341: PPUSH
78342: LD_EXP 96
78346: PUSH
78347: LD_VAR 0 2
78351: ARRAY
78352: PUSH
78353: LD_INT 1
78355: ARRAY
78356: PUSH
78357: LD_INT 2
78359: ARRAY
78360: PPUSH
78361: LD_EXP 85
78365: PUSH
78366: LD_VAR 0 2
78370: ARRAY
78371: PPUSH
78372: CALL_OW 440
78376: IFFALSE 78419
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78378: LD_ADDR_EXP 96
78382: PUSH
78383: LD_EXP 96
78387: PPUSH
78388: LD_VAR 0 2
78392: PPUSH
78393: LD_EXP 96
78397: PUSH
78398: LD_VAR 0 2
78402: ARRAY
78403: PPUSH
78404: LD_INT 1
78406: PPUSH
78407: CALL_OW 3
78411: PPUSH
78412: CALL_OW 1
78416: ST_TO_ADDR
78417: GO 78666
// begin if not mc_deposits_finder [ i ] then
78419: LD_EXP 97
78423: PUSH
78424: LD_VAR 0 2
78428: ARRAY
78429: NOT
78430: IFFALSE 78482
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78432: LD_ADDR_EXP 97
78436: PUSH
78437: LD_EXP 97
78441: PPUSH
78442: LD_VAR 0 2
78446: PPUSH
78447: LD_VAR 0 3
78451: PUSH
78452: LD_INT 1
78454: ARRAY
78455: PUSH
78456: EMPTY
78457: LIST
78458: PPUSH
78459: CALL_OW 1
78463: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78464: LD_VAR 0 3
78468: PUSH
78469: LD_INT 1
78471: ARRAY
78472: PPUSH
78473: LD_INT 125
78475: PPUSH
78476: CALL_OW 109
// end else
78480: GO 78666
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78482: LD_EXP 97
78486: PUSH
78487: LD_VAR 0 2
78491: ARRAY
78492: PUSH
78493: LD_INT 1
78495: ARRAY
78496: PPUSH
78497: CALL_OW 310
78501: IFFALSE 78524
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78503: LD_EXP 97
78507: PUSH
78508: LD_VAR 0 2
78512: ARRAY
78513: PUSH
78514: LD_INT 1
78516: ARRAY
78517: PPUSH
78518: CALL_OW 122
78522: GO 78666
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78524: LD_EXP 97
78528: PUSH
78529: LD_VAR 0 2
78533: ARRAY
78534: PUSH
78535: LD_INT 1
78537: ARRAY
78538: PPUSH
78539: CALL_OW 314
78543: NOT
78544: PUSH
78545: LD_EXP 97
78549: PUSH
78550: LD_VAR 0 2
78554: ARRAY
78555: PUSH
78556: LD_INT 1
78558: ARRAY
78559: PPUSH
78560: LD_EXP 96
78564: PUSH
78565: LD_VAR 0 2
78569: ARRAY
78570: PUSH
78571: LD_INT 1
78573: ARRAY
78574: PUSH
78575: LD_INT 1
78577: ARRAY
78578: PPUSH
78579: LD_EXP 96
78583: PUSH
78584: LD_VAR 0 2
78588: ARRAY
78589: PUSH
78590: LD_INT 1
78592: ARRAY
78593: PUSH
78594: LD_INT 2
78596: ARRAY
78597: PPUSH
78598: CALL_OW 297
78602: PUSH
78603: LD_INT 6
78605: GREATER
78606: AND
78607: IFFALSE 78666
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78609: LD_EXP 97
78613: PUSH
78614: LD_VAR 0 2
78618: ARRAY
78619: PUSH
78620: LD_INT 1
78622: ARRAY
78623: PPUSH
78624: LD_EXP 96
78628: PUSH
78629: LD_VAR 0 2
78633: ARRAY
78634: PUSH
78635: LD_INT 1
78637: ARRAY
78638: PUSH
78639: LD_INT 1
78641: ARRAY
78642: PPUSH
78643: LD_EXP 96
78647: PUSH
78648: LD_VAR 0 2
78652: ARRAY
78653: PUSH
78654: LD_INT 1
78656: ARRAY
78657: PUSH
78658: LD_INT 2
78660: ARRAY
78661: PPUSH
78662: CALL_OW 111
// end ; end ; end ;
78666: GO 78079
78668: POP
78669: POP
// end ;
78670: LD_VAR 0 1
78674: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78675: LD_INT 0
78677: PPUSH
78678: PPUSH
78679: PPUSH
78680: PPUSH
78681: PPUSH
78682: PPUSH
78683: PPUSH
78684: PPUSH
78685: PPUSH
78686: PPUSH
78687: PPUSH
// if not mc_bases then
78688: LD_EXP 59
78692: NOT
78693: IFFALSE 78697
// exit ;
78695: GO 79637
// for i = 1 to mc_bases do
78697: LD_ADDR_VAR 0 2
78701: PUSH
78702: DOUBLE
78703: LD_INT 1
78705: DEC
78706: ST_TO_ADDR
78707: LD_EXP 59
78711: PUSH
78712: FOR_TO
78713: IFFALSE 79635
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78715: LD_EXP 59
78719: PUSH
78720: LD_VAR 0 2
78724: ARRAY
78725: NOT
78726: PUSH
78727: LD_EXP 82
78731: PUSH
78732: LD_VAR 0 2
78736: ARRAY
78737: OR
78738: IFFALSE 78742
// continue ;
78740: GO 78712
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78742: LD_ADDR_VAR 0 7
78746: PUSH
78747: LD_EXP 59
78751: PUSH
78752: LD_VAR 0 2
78756: ARRAY
78757: PUSH
78758: LD_INT 1
78760: ARRAY
78761: PPUSH
78762: CALL_OW 248
78766: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78767: LD_VAR 0 7
78771: PUSH
78772: LD_INT 3
78774: EQUAL
78775: PUSH
78776: LD_EXP 78
78780: PUSH
78781: LD_VAR 0 2
78785: ARRAY
78786: PUSH
78787: LD_EXP 81
78791: PUSH
78792: LD_VAR 0 2
78796: ARRAY
78797: UNION
78798: PPUSH
78799: LD_INT 33
78801: PUSH
78802: LD_INT 2
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PPUSH
78809: CALL_OW 72
78813: NOT
78814: OR
78815: IFFALSE 78819
// continue ;
78817: GO 78712
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78819: LD_ADDR_VAR 0 9
78823: PUSH
78824: LD_EXP 59
78828: PUSH
78829: LD_VAR 0 2
78833: ARRAY
78834: PPUSH
78835: LD_INT 30
78837: PUSH
78838: LD_INT 36
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PPUSH
78845: CALL_OW 72
78849: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78850: LD_ADDR_VAR 0 10
78854: PUSH
78855: LD_EXP 78
78859: PUSH
78860: LD_VAR 0 2
78864: ARRAY
78865: PPUSH
78866: LD_INT 34
78868: PUSH
78869: LD_INT 31
78871: PUSH
78872: EMPTY
78873: LIST
78874: LIST
78875: PPUSH
78876: CALL_OW 72
78880: ST_TO_ADDR
// if not cts and not mcts then
78881: LD_VAR 0 9
78885: NOT
78886: PUSH
78887: LD_VAR 0 10
78891: NOT
78892: AND
78893: IFFALSE 78897
// continue ;
78895: GO 78712
// x := cts ;
78897: LD_ADDR_VAR 0 11
78901: PUSH
78902: LD_VAR 0 9
78906: ST_TO_ADDR
// if not x then
78907: LD_VAR 0 11
78911: NOT
78912: IFFALSE 78924
// x := mcts ;
78914: LD_ADDR_VAR 0 11
78918: PUSH
78919: LD_VAR 0 10
78923: ST_TO_ADDR
// if not x then
78924: LD_VAR 0 11
78928: NOT
78929: IFFALSE 78933
// continue ;
78931: GO 78712
// if mc_remote_driver [ i ] then
78933: LD_EXP 99
78937: PUSH
78938: LD_VAR 0 2
78942: ARRAY
78943: IFFALSE 79330
// for j in mc_remote_driver [ i ] do
78945: LD_ADDR_VAR 0 3
78949: PUSH
78950: LD_EXP 99
78954: PUSH
78955: LD_VAR 0 2
78959: ARRAY
78960: PUSH
78961: FOR_IN
78962: IFFALSE 79328
// begin if GetClass ( j ) <> 3 then
78964: LD_VAR 0 3
78968: PPUSH
78969: CALL_OW 257
78973: PUSH
78974: LD_INT 3
78976: NONEQUAL
78977: IFFALSE 79030
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78979: LD_ADDR_EXP 99
78983: PUSH
78984: LD_EXP 99
78988: PPUSH
78989: LD_VAR 0 2
78993: PPUSH
78994: LD_EXP 99
78998: PUSH
78999: LD_VAR 0 2
79003: ARRAY
79004: PUSH
79005: LD_VAR 0 3
79009: DIFF
79010: PPUSH
79011: CALL_OW 1
79015: ST_TO_ADDR
// SetTag ( j , 0 ) ;
79016: LD_VAR 0 3
79020: PPUSH
79021: LD_INT 0
79023: PPUSH
79024: CALL_OW 109
// continue ;
79028: GO 78961
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
79030: LD_EXP 78
79034: PUSH
79035: LD_VAR 0 2
79039: ARRAY
79040: PPUSH
79041: LD_INT 34
79043: PUSH
79044: LD_INT 31
79046: PUSH
79047: EMPTY
79048: LIST
79049: LIST
79050: PUSH
79051: LD_INT 58
79053: PUSH
79054: EMPTY
79055: LIST
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: PPUSH
79061: CALL_OW 72
79065: PUSH
79066: LD_VAR 0 3
79070: PPUSH
79071: CALL 54873 0 1
79075: NOT
79076: AND
79077: IFFALSE 79148
// begin if IsInUnit ( j ) then
79079: LD_VAR 0 3
79083: PPUSH
79084: CALL_OW 310
79088: IFFALSE 79099
// ComExitBuilding ( j ) ;
79090: LD_VAR 0 3
79094: PPUSH
79095: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
79099: LD_VAR 0 3
79103: PPUSH
79104: LD_EXP 78
79108: PUSH
79109: LD_VAR 0 2
79113: ARRAY
79114: PPUSH
79115: LD_INT 34
79117: PUSH
79118: LD_INT 31
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: LD_INT 58
79127: PUSH
79128: EMPTY
79129: LIST
79130: PUSH
79131: EMPTY
79132: LIST
79133: LIST
79134: PPUSH
79135: CALL_OW 72
79139: PUSH
79140: LD_INT 1
79142: ARRAY
79143: PPUSH
79144: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
79148: LD_VAR 0 3
79152: PPUSH
79153: CALL_OW 310
79157: NOT
79158: PUSH
79159: LD_VAR 0 3
79163: PPUSH
79164: CALL_OW 310
79168: PPUSH
79169: CALL_OW 266
79173: PUSH
79174: LD_INT 36
79176: NONEQUAL
79177: PUSH
79178: LD_VAR 0 3
79182: PPUSH
79183: CALL 54873 0 1
79187: NOT
79188: AND
79189: OR
79190: IFFALSE 79326
// begin if IsInUnit ( j ) then
79192: LD_VAR 0 3
79196: PPUSH
79197: CALL_OW 310
79201: IFFALSE 79212
// ComExitBuilding ( j ) ;
79203: LD_VAR 0 3
79207: PPUSH
79208: CALL_OW 122
// ct := 0 ;
79212: LD_ADDR_VAR 0 8
79216: PUSH
79217: LD_INT 0
79219: ST_TO_ADDR
// for k in x do
79220: LD_ADDR_VAR 0 4
79224: PUSH
79225: LD_VAR 0 11
79229: PUSH
79230: FOR_IN
79231: IFFALSE 79304
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
79233: LD_VAR 0 4
79237: PPUSH
79238: CALL_OW 264
79242: PUSH
79243: LD_INT 31
79245: EQUAL
79246: PUSH
79247: LD_VAR 0 4
79251: PPUSH
79252: CALL_OW 311
79256: NOT
79257: AND
79258: PUSH
79259: LD_VAR 0 4
79263: PPUSH
79264: CALL_OW 266
79268: PUSH
79269: LD_INT 36
79271: EQUAL
79272: PUSH
79273: LD_VAR 0 4
79277: PPUSH
79278: CALL_OW 313
79282: PUSH
79283: LD_INT 3
79285: LESS
79286: AND
79287: OR
79288: IFFALSE 79302
// begin ct := k ;
79290: LD_ADDR_VAR 0 8
79294: PUSH
79295: LD_VAR 0 4
79299: ST_TO_ADDR
// break ;
79300: GO 79304
// end ;
79302: GO 79230
79304: POP
79305: POP
// if ct then
79306: LD_VAR 0 8
79310: IFFALSE 79326
// ComEnterUnit ( j , ct ) ;
79312: LD_VAR 0 3
79316: PPUSH
79317: LD_VAR 0 8
79321: PPUSH
79322: CALL_OW 120
// end ; end ;
79326: GO 78961
79328: POP
79329: POP
// places := 0 ;
79330: LD_ADDR_VAR 0 5
79334: PUSH
79335: LD_INT 0
79337: ST_TO_ADDR
// for j = 1 to x do
79338: LD_ADDR_VAR 0 3
79342: PUSH
79343: DOUBLE
79344: LD_INT 1
79346: DEC
79347: ST_TO_ADDR
79348: LD_VAR 0 11
79352: PUSH
79353: FOR_TO
79354: IFFALSE 79430
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79356: LD_VAR 0 11
79360: PUSH
79361: LD_VAR 0 3
79365: ARRAY
79366: PPUSH
79367: CALL_OW 264
79371: PUSH
79372: LD_INT 31
79374: EQUAL
79375: IFFALSE 79393
// places := places + 1 else
79377: LD_ADDR_VAR 0 5
79381: PUSH
79382: LD_VAR 0 5
79386: PUSH
79387: LD_INT 1
79389: PLUS
79390: ST_TO_ADDR
79391: GO 79428
// if GetBType ( x [ j ] ) = b_control_tower then
79393: LD_VAR 0 11
79397: PUSH
79398: LD_VAR 0 3
79402: ARRAY
79403: PPUSH
79404: CALL_OW 266
79408: PUSH
79409: LD_INT 36
79411: EQUAL
79412: IFFALSE 79428
// places := places + 3 ;
79414: LD_ADDR_VAR 0 5
79418: PUSH
79419: LD_VAR 0 5
79423: PUSH
79424: LD_INT 3
79426: PLUS
79427: ST_TO_ADDR
79428: GO 79353
79430: POP
79431: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79432: LD_VAR 0 5
79436: PUSH
79437: LD_INT 0
79439: EQUAL
79440: PUSH
79441: LD_VAR 0 5
79445: PUSH
79446: LD_EXP 99
79450: PUSH
79451: LD_VAR 0 2
79455: ARRAY
79456: LESSEQUAL
79457: OR
79458: IFFALSE 79462
// continue ;
79460: GO 78712
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79462: LD_ADDR_VAR 0 6
79466: PUSH
79467: LD_EXP 59
79471: PUSH
79472: LD_VAR 0 2
79476: ARRAY
79477: PPUSH
79478: LD_INT 25
79480: PUSH
79481: LD_INT 3
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PPUSH
79488: CALL_OW 72
79492: PUSH
79493: LD_EXP 99
79497: PUSH
79498: LD_VAR 0 2
79502: ARRAY
79503: DIFF
79504: PPUSH
79505: LD_INT 3
79507: PPUSH
79508: CALL 55773 0 2
79512: ST_TO_ADDR
// for j in tmp do
79513: LD_ADDR_VAR 0 3
79517: PUSH
79518: LD_VAR 0 6
79522: PUSH
79523: FOR_IN
79524: IFFALSE 79559
// if GetTag ( j ) > 0 then
79526: LD_VAR 0 3
79530: PPUSH
79531: CALL_OW 110
79535: PUSH
79536: LD_INT 0
79538: GREATER
79539: IFFALSE 79557
// tmp := tmp diff j ;
79541: LD_ADDR_VAR 0 6
79545: PUSH
79546: LD_VAR 0 6
79550: PUSH
79551: LD_VAR 0 3
79555: DIFF
79556: ST_TO_ADDR
79557: GO 79523
79559: POP
79560: POP
// if not tmp then
79561: LD_VAR 0 6
79565: NOT
79566: IFFALSE 79570
// continue ;
79568: GO 78712
// if places then
79570: LD_VAR 0 5
79574: IFFALSE 79633
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79576: LD_ADDR_EXP 99
79580: PUSH
79581: LD_EXP 99
79585: PPUSH
79586: LD_VAR 0 2
79590: PPUSH
79591: LD_EXP 99
79595: PUSH
79596: LD_VAR 0 2
79600: ARRAY
79601: PUSH
79602: LD_VAR 0 6
79606: PUSH
79607: LD_INT 1
79609: ARRAY
79610: UNION
79611: PPUSH
79612: CALL_OW 1
79616: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79617: LD_VAR 0 6
79621: PUSH
79622: LD_INT 1
79624: ARRAY
79625: PPUSH
79626: LD_INT 126
79628: PPUSH
79629: CALL_OW 109
// end ; end ;
79633: GO 78712
79635: POP
79636: POP
// end ;
79637: LD_VAR 0 1
79641: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79642: LD_INT 0
79644: PPUSH
79645: PPUSH
79646: PPUSH
79647: PPUSH
79648: PPUSH
79649: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79650: LD_VAR 0 1
79654: NOT
79655: PUSH
79656: LD_VAR 0 2
79660: NOT
79661: OR
79662: PUSH
79663: LD_VAR 0 3
79667: NOT
79668: OR
79669: PUSH
79670: LD_VAR 0 4
79674: PUSH
79675: LD_INT 1
79677: PUSH
79678: LD_INT 2
79680: PUSH
79681: LD_INT 3
79683: PUSH
79684: LD_INT 4
79686: PUSH
79687: LD_INT 5
79689: PUSH
79690: LD_INT 8
79692: PUSH
79693: LD_INT 9
79695: PUSH
79696: LD_INT 15
79698: PUSH
79699: LD_INT 16
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: LIST
79706: LIST
79707: LIST
79708: LIST
79709: LIST
79710: LIST
79711: LIST
79712: IN
79713: NOT
79714: OR
79715: IFFALSE 79719
// exit ;
79717: GO 80619
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79719: LD_ADDR_VAR 0 2
79723: PUSH
79724: LD_VAR 0 2
79728: PPUSH
79729: LD_INT 21
79731: PUSH
79732: LD_INT 3
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 24
79741: PUSH
79742: LD_INT 250
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PPUSH
79753: CALL_OW 72
79757: ST_TO_ADDR
// case class of 1 , 15 :
79758: LD_VAR 0 4
79762: PUSH
79763: LD_INT 1
79765: DOUBLE
79766: EQUAL
79767: IFTRUE 79777
79769: LD_INT 15
79771: DOUBLE
79772: EQUAL
79773: IFTRUE 79777
79775: GO 79862
79777: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79778: LD_ADDR_VAR 0 8
79782: PUSH
79783: LD_VAR 0 2
79787: PPUSH
79788: LD_INT 2
79790: PUSH
79791: LD_INT 30
79793: PUSH
79794: LD_INT 32
79796: PUSH
79797: EMPTY
79798: LIST
79799: LIST
79800: PUSH
79801: LD_INT 30
79803: PUSH
79804: LD_INT 31
79806: PUSH
79807: EMPTY
79808: LIST
79809: LIST
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: LIST
79815: PPUSH
79816: CALL_OW 72
79820: PUSH
79821: LD_VAR 0 2
79825: PPUSH
79826: LD_INT 2
79828: PUSH
79829: LD_INT 30
79831: PUSH
79832: LD_INT 4
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 30
79841: PUSH
79842: LD_INT 5
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: LIST
79853: PPUSH
79854: CALL_OW 72
79858: ADD
79859: ST_TO_ADDR
79860: GO 80108
79862: LD_INT 2
79864: DOUBLE
79865: EQUAL
79866: IFTRUE 79876
79868: LD_INT 16
79870: DOUBLE
79871: EQUAL
79872: IFTRUE 79876
79874: GO 79922
79876: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79877: LD_ADDR_VAR 0 8
79881: PUSH
79882: LD_VAR 0 2
79886: PPUSH
79887: LD_INT 2
79889: PUSH
79890: LD_INT 30
79892: PUSH
79893: LD_INT 0
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: LD_INT 30
79902: PUSH
79903: LD_INT 1
79905: PUSH
79906: EMPTY
79907: LIST
79908: LIST
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: LIST
79914: PPUSH
79915: CALL_OW 72
79919: ST_TO_ADDR
79920: GO 80108
79922: LD_INT 3
79924: DOUBLE
79925: EQUAL
79926: IFTRUE 79930
79928: GO 79976
79930: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79931: LD_ADDR_VAR 0 8
79935: PUSH
79936: LD_VAR 0 2
79940: PPUSH
79941: LD_INT 2
79943: PUSH
79944: LD_INT 30
79946: PUSH
79947: LD_INT 2
79949: PUSH
79950: EMPTY
79951: LIST
79952: LIST
79953: PUSH
79954: LD_INT 30
79956: PUSH
79957: LD_INT 3
79959: PUSH
79960: EMPTY
79961: LIST
79962: LIST
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: LIST
79968: PPUSH
79969: CALL_OW 72
79973: ST_TO_ADDR
79974: GO 80108
79976: LD_INT 4
79978: DOUBLE
79979: EQUAL
79980: IFTRUE 79984
79982: GO 80041
79984: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79985: LD_ADDR_VAR 0 8
79989: PUSH
79990: LD_VAR 0 2
79994: PPUSH
79995: LD_INT 2
79997: PUSH
79998: LD_INT 30
80000: PUSH
80001: LD_INT 6
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: LD_INT 30
80010: PUSH
80011: LD_INT 7
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 30
80020: PUSH
80021: LD_INT 8
80023: PUSH
80024: EMPTY
80025: LIST
80026: LIST
80027: PUSH
80028: EMPTY
80029: LIST
80030: LIST
80031: LIST
80032: LIST
80033: PPUSH
80034: CALL_OW 72
80038: ST_TO_ADDR
80039: GO 80108
80041: LD_INT 5
80043: DOUBLE
80044: EQUAL
80045: IFTRUE 80061
80047: LD_INT 8
80049: DOUBLE
80050: EQUAL
80051: IFTRUE 80061
80053: LD_INT 9
80055: DOUBLE
80056: EQUAL
80057: IFTRUE 80061
80059: GO 80107
80061: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
80062: LD_ADDR_VAR 0 8
80066: PUSH
80067: LD_VAR 0 2
80071: PPUSH
80072: LD_INT 2
80074: PUSH
80075: LD_INT 30
80077: PUSH
80078: LD_INT 4
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 30
80087: PUSH
80088: LD_INT 5
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: EMPTY
80096: LIST
80097: LIST
80098: LIST
80099: PPUSH
80100: CALL_OW 72
80104: ST_TO_ADDR
80105: GO 80108
80107: POP
// if not tmp then
80108: LD_VAR 0 8
80112: NOT
80113: IFFALSE 80117
// exit ;
80115: GO 80619
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
80117: LD_VAR 0 4
80121: PUSH
80122: LD_INT 1
80124: PUSH
80125: LD_INT 15
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: IN
80132: PUSH
80133: LD_EXP 68
80137: PUSH
80138: LD_VAR 0 1
80142: ARRAY
80143: AND
80144: IFFALSE 80300
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
80146: LD_ADDR_VAR 0 9
80150: PUSH
80151: LD_EXP 68
80155: PUSH
80156: LD_VAR 0 1
80160: ARRAY
80161: PUSH
80162: LD_INT 1
80164: ARRAY
80165: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
80166: LD_VAR 0 9
80170: PUSH
80171: LD_EXP 69
80175: PUSH
80176: LD_VAR 0 1
80180: ARRAY
80181: IN
80182: NOT
80183: IFFALSE 80298
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
80185: LD_ADDR_EXP 69
80189: PUSH
80190: LD_EXP 69
80194: PPUSH
80195: LD_VAR 0 1
80199: PUSH
80200: LD_EXP 69
80204: PUSH
80205: LD_VAR 0 1
80209: ARRAY
80210: PUSH
80211: LD_INT 1
80213: PLUS
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: PPUSH
80219: LD_VAR 0 9
80223: PPUSH
80224: CALL 21525 0 3
80228: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
80229: LD_ADDR_EXP 68
80233: PUSH
80234: LD_EXP 68
80238: PPUSH
80239: LD_VAR 0 1
80243: PPUSH
80244: LD_EXP 68
80248: PUSH
80249: LD_VAR 0 1
80253: ARRAY
80254: PUSH
80255: LD_VAR 0 9
80259: DIFF
80260: PPUSH
80261: CALL_OW 1
80265: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80266: LD_VAR 0 3
80270: PPUSH
80271: LD_EXP 69
80275: PUSH
80276: LD_VAR 0 1
80280: ARRAY
80281: PUSH
80282: LD_EXP 69
80286: PUSH
80287: LD_VAR 0 1
80291: ARRAY
80292: ARRAY
80293: PPUSH
80294: CALL_OW 120
// end ; exit ;
80298: GO 80619
// end ; if tmp > 1 then
80300: LD_VAR 0 8
80304: PUSH
80305: LD_INT 1
80307: GREATER
80308: IFFALSE 80412
// for i = 2 to tmp do
80310: LD_ADDR_VAR 0 6
80314: PUSH
80315: DOUBLE
80316: LD_INT 2
80318: DEC
80319: ST_TO_ADDR
80320: LD_VAR 0 8
80324: PUSH
80325: FOR_TO
80326: IFFALSE 80410
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80328: LD_VAR 0 8
80332: PUSH
80333: LD_VAR 0 6
80337: ARRAY
80338: PPUSH
80339: CALL_OW 461
80343: PUSH
80344: LD_INT 6
80346: EQUAL
80347: IFFALSE 80408
// begin x := tmp [ i ] ;
80349: LD_ADDR_VAR 0 9
80353: PUSH
80354: LD_VAR 0 8
80358: PUSH
80359: LD_VAR 0 6
80363: ARRAY
80364: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80365: LD_ADDR_VAR 0 8
80369: PUSH
80370: LD_VAR 0 8
80374: PPUSH
80375: LD_VAR 0 6
80379: PPUSH
80380: CALL_OW 3
80384: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80385: LD_ADDR_VAR 0 8
80389: PUSH
80390: LD_VAR 0 8
80394: PPUSH
80395: LD_INT 1
80397: PPUSH
80398: LD_VAR 0 9
80402: PPUSH
80403: CALL_OW 2
80407: ST_TO_ADDR
// end ;
80408: GO 80325
80410: POP
80411: POP
// for i in tmp do
80412: LD_ADDR_VAR 0 6
80416: PUSH
80417: LD_VAR 0 8
80421: PUSH
80422: FOR_IN
80423: IFFALSE 80492
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
80425: LD_VAR 0 6
80429: PPUSH
80430: CALL_OW 313
80434: PUSH
80435: LD_INT 6
80437: LESS
80438: PUSH
80439: LD_VAR 0 6
80443: PPUSH
80444: CALL_OW 266
80448: PUSH
80449: LD_INT 31
80451: PUSH
80452: LD_INT 32
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: IN
80459: NOT
80460: AND
80461: PUSH
80462: LD_VAR 0 6
80466: PPUSH
80467: CALL_OW 313
80471: PUSH
80472: LD_INT 0
80474: EQUAL
80475: OR
80476: IFFALSE 80490
// begin j := i ;
80478: LD_ADDR_VAR 0 7
80482: PUSH
80483: LD_VAR 0 6
80487: ST_TO_ADDR
// break ;
80488: GO 80492
// end ; end ;
80490: GO 80422
80492: POP
80493: POP
// if j then
80494: LD_VAR 0 7
80498: IFFALSE 80516
// ComEnterUnit ( unit , j ) else
80500: LD_VAR 0 3
80504: PPUSH
80505: LD_VAR 0 7
80509: PPUSH
80510: CALL_OW 120
80514: GO 80619
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80516: LD_ADDR_VAR 0 10
80520: PUSH
80521: LD_VAR 0 2
80525: PPUSH
80526: LD_INT 2
80528: PUSH
80529: LD_INT 30
80531: PUSH
80532: LD_INT 0
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 30
80541: PUSH
80542: LD_INT 1
80544: PUSH
80545: EMPTY
80546: LIST
80547: LIST
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: LIST
80553: PPUSH
80554: CALL_OW 72
80558: ST_TO_ADDR
// if depot then
80559: LD_VAR 0 10
80563: IFFALSE 80619
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80565: LD_ADDR_VAR 0 10
80569: PUSH
80570: LD_VAR 0 10
80574: PPUSH
80575: LD_VAR 0 3
80579: PPUSH
80580: CALL_OW 74
80584: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80585: LD_VAR 0 3
80589: PPUSH
80590: LD_VAR 0 10
80594: PPUSH
80595: CALL_OW 296
80599: PUSH
80600: LD_INT 10
80602: GREATER
80603: IFFALSE 80619
// ComStandNearbyBuilding ( unit , depot ) ;
80605: LD_VAR 0 3
80609: PPUSH
80610: LD_VAR 0 10
80614: PPUSH
80615: CALL 15728 0 2
// end ; end ; end ;
80619: LD_VAR 0 5
80623: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80624: LD_INT 0
80626: PPUSH
80627: PPUSH
80628: PPUSH
80629: PPUSH
// if not mc_bases then
80630: LD_EXP 59
80634: NOT
80635: IFFALSE 80639
// exit ;
80637: GO 80878
// for i = 1 to mc_bases do
80639: LD_ADDR_VAR 0 2
80643: PUSH
80644: DOUBLE
80645: LD_INT 1
80647: DEC
80648: ST_TO_ADDR
80649: LD_EXP 59
80653: PUSH
80654: FOR_TO
80655: IFFALSE 80876
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80657: LD_ADDR_VAR 0 4
80661: PUSH
80662: LD_EXP 59
80666: PUSH
80667: LD_VAR 0 2
80671: ARRAY
80672: PPUSH
80673: LD_INT 21
80675: PUSH
80676: LD_INT 1
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PPUSH
80683: CALL_OW 72
80687: PUSH
80688: LD_EXP 88
80692: PUSH
80693: LD_VAR 0 2
80697: ARRAY
80698: UNION
80699: ST_TO_ADDR
// if not tmp then
80700: LD_VAR 0 4
80704: NOT
80705: IFFALSE 80709
// continue ;
80707: GO 80654
// for j in tmp do
80709: LD_ADDR_VAR 0 3
80713: PUSH
80714: LD_VAR 0 4
80718: PUSH
80719: FOR_IN
80720: IFFALSE 80872
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80722: LD_VAR 0 3
80726: PPUSH
80727: CALL_OW 110
80731: NOT
80732: PUSH
80733: LD_VAR 0 3
80737: PPUSH
80738: CALL_OW 314
80742: NOT
80743: AND
80744: PUSH
80745: LD_VAR 0 3
80749: PPUSH
80750: CALL_OW 311
80754: NOT
80755: AND
80756: PUSH
80757: LD_VAR 0 3
80761: PPUSH
80762: CALL_OW 310
80766: NOT
80767: AND
80768: PUSH
80769: LD_VAR 0 3
80773: PUSH
80774: LD_EXP 62
80778: PUSH
80779: LD_VAR 0 2
80783: ARRAY
80784: PUSH
80785: LD_INT 1
80787: ARRAY
80788: IN
80789: NOT
80790: AND
80791: PUSH
80792: LD_VAR 0 3
80796: PUSH
80797: LD_EXP 62
80801: PUSH
80802: LD_VAR 0 2
80806: ARRAY
80807: PUSH
80808: LD_INT 2
80810: ARRAY
80811: IN
80812: NOT
80813: AND
80814: PUSH
80815: LD_VAR 0 3
80819: PUSH
80820: LD_EXP 71
80824: PUSH
80825: LD_VAR 0 2
80829: ARRAY
80830: IN
80831: NOT
80832: AND
80833: IFFALSE 80870
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80835: LD_VAR 0 2
80839: PPUSH
80840: LD_EXP 59
80844: PUSH
80845: LD_VAR 0 2
80849: ARRAY
80850: PPUSH
80851: LD_VAR 0 3
80855: PPUSH
80856: LD_VAR 0 3
80860: PPUSH
80861: CALL_OW 257
80865: PPUSH
80866: CALL 79642 0 4
// end ;
80870: GO 80719
80872: POP
80873: POP
// end ;
80874: GO 80654
80876: POP
80877: POP
// end ;
80878: LD_VAR 0 1
80882: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80883: LD_INT 0
80885: PPUSH
80886: PPUSH
80887: PPUSH
80888: PPUSH
80889: PPUSH
80890: PPUSH
// if not mc_bases [ base ] then
80891: LD_EXP 59
80895: PUSH
80896: LD_VAR 0 1
80900: ARRAY
80901: NOT
80902: IFFALSE 80906
// exit ;
80904: GO 81088
// tmp := [ ] ;
80906: LD_ADDR_VAR 0 6
80910: PUSH
80911: EMPTY
80912: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80913: LD_ADDR_VAR 0 7
80917: PUSH
80918: LD_VAR 0 3
80922: PPUSH
80923: LD_INT 0
80925: PPUSH
80926: CALL_OW 517
80930: ST_TO_ADDR
// if not list then
80931: LD_VAR 0 7
80935: NOT
80936: IFFALSE 80940
// exit ;
80938: GO 81088
// for i = 1 to amount do
80940: LD_ADDR_VAR 0 5
80944: PUSH
80945: DOUBLE
80946: LD_INT 1
80948: DEC
80949: ST_TO_ADDR
80950: LD_VAR 0 2
80954: PUSH
80955: FOR_TO
80956: IFFALSE 81036
// begin x := rand ( 1 , list [ 1 ] ) ;
80958: LD_ADDR_VAR 0 8
80962: PUSH
80963: LD_INT 1
80965: PPUSH
80966: LD_VAR 0 7
80970: PUSH
80971: LD_INT 1
80973: ARRAY
80974: PPUSH
80975: CALL_OW 12
80979: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80980: LD_ADDR_VAR 0 6
80984: PUSH
80985: LD_VAR 0 6
80989: PPUSH
80990: LD_VAR 0 5
80994: PPUSH
80995: LD_VAR 0 7
80999: PUSH
81000: LD_INT 1
81002: ARRAY
81003: PUSH
81004: LD_VAR 0 8
81008: ARRAY
81009: PUSH
81010: LD_VAR 0 7
81014: PUSH
81015: LD_INT 2
81017: ARRAY
81018: PUSH
81019: LD_VAR 0 8
81023: ARRAY
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: PPUSH
81029: CALL_OW 1
81033: ST_TO_ADDR
// end ;
81034: GO 80955
81036: POP
81037: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
81038: LD_ADDR_EXP 72
81042: PUSH
81043: LD_EXP 72
81047: PPUSH
81048: LD_VAR 0 1
81052: PPUSH
81053: LD_VAR 0 6
81057: PPUSH
81058: CALL_OW 1
81062: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
81063: LD_ADDR_EXP 74
81067: PUSH
81068: LD_EXP 74
81072: PPUSH
81073: LD_VAR 0 1
81077: PPUSH
81078: LD_VAR 0 3
81082: PPUSH
81083: CALL_OW 1
81087: ST_TO_ADDR
// end ;
81088: LD_VAR 0 4
81092: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
81093: LD_INT 0
81095: PPUSH
// if not mc_bases [ base ] then
81096: LD_EXP 59
81100: PUSH
81101: LD_VAR 0 1
81105: ARRAY
81106: NOT
81107: IFFALSE 81111
// exit ;
81109: GO 81136
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
81111: LD_ADDR_EXP 64
81115: PUSH
81116: LD_EXP 64
81120: PPUSH
81121: LD_VAR 0 1
81125: PPUSH
81126: LD_VAR 0 2
81130: PPUSH
81131: CALL_OW 1
81135: ST_TO_ADDR
// end ;
81136: LD_VAR 0 3
81140: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
81141: LD_INT 0
81143: PPUSH
// if not mc_bases [ base ] then
81144: LD_EXP 59
81148: PUSH
81149: LD_VAR 0 1
81153: ARRAY
81154: NOT
81155: IFFALSE 81159
// exit ;
81157: GO 81196
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
81159: LD_ADDR_EXP 64
81163: PUSH
81164: LD_EXP 64
81168: PPUSH
81169: LD_VAR 0 1
81173: PPUSH
81174: LD_EXP 64
81178: PUSH
81179: LD_VAR 0 1
81183: ARRAY
81184: PUSH
81185: LD_VAR 0 2
81189: UNION
81190: PPUSH
81191: CALL_OW 1
81195: ST_TO_ADDR
// end ;
81196: LD_VAR 0 3
81200: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
81201: LD_INT 0
81203: PPUSH
// if not mc_bases [ base ] then
81204: LD_EXP 59
81208: PUSH
81209: LD_VAR 0 1
81213: ARRAY
81214: NOT
81215: IFFALSE 81219
// exit ;
81217: GO 81244
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
81219: LD_ADDR_EXP 80
81223: PUSH
81224: LD_EXP 80
81228: PPUSH
81229: LD_VAR 0 1
81233: PPUSH
81234: LD_VAR 0 2
81238: PPUSH
81239: CALL_OW 1
81243: ST_TO_ADDR
// end ;
81244: LD_VAR 0 3
81248: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81249: LD_INT 0
81251: PPUSH
// if not mc_bases [ base ] then
81252: LD_EXP 59
81256: PUSH
81257: LD_VAR 0 1
81261: ARRAY
81262: NOT
81263: IFFALSE 81267
// exit ;
81265: GO 81304
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81267: LD_ADDR_EXP 80
81271: PUSH
81272: LD_EXP 80
81276: PPUSH
81277: LD_VAR 0 1
81281: PPUSH
81282: LD_EXP 80
81286: PUSH
81287: LD_VAR 0 1
81291: ARRAY
81292: PUSH
81293: LD_VAR 0 2
81297: ADD
81298: PPUSH
81299: CALL_OW 1
81303: ST_TO_ADDR
// end ;
81304: LD_VAR 0 3
81308: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81309: LD_INT 0
81311: PPUSH
// if not mc_bases [ base ] then
81312: LD_EXP 59
81316: PUSH
81317: LD_VAR 0 1
81321: ARRAY
81322: NOT
81323: IFFALSE 81327
// exit ;
81325: GO 81381
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81327: LD_ADDR_EXP 81
81331: PUSH
81332: LD_EXP 81
81336: PPUSH
81337: LD_VAR 0 1
81341: PPUSH
81342: LD_VAR 0 2
81346: PPUSH
81347: CALL_OW 1
81351: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81352: LD_ADDR_EXP 70
81356: PUSH
81357: LD_EXP 70
81361: PPUSH
81362: LD_VAR 0 1
81366: PPUSH
81367: LD_VAR 0 2
81371: PUSH
81372: LD_INT 0
81374: PLUS
81375: PPUSH
81376: CALL_OW 1
81380: ST_TO_ADDR
// end ;
81381: LD_VAR 0 3
81385: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81386: LD_INT 0
81388: PPUSH
// if not mc_bases [ base ] then
81389: LD_EXP 59
81393: PUSH
81394: LD_VAR 0 1
81398: ARRAY
81399: NOT
81400: IFFALSE 81404
// exit ;
81402: GO 81429
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81404: LD_ADDR_EXP 70
81408: PUSH
81409: LD_EXP 70
81413: PPUSH
81414: LD_VAR 0 1
81418: PPUSH
81419: LD_VAR 0 2
81423: PPUSH
81424: CALL_OW 1
81428: ST_TO_ADDR
// end ;
81429: LD_VAR 0 3
81433: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81434: LD_INT 0
81436: PPUSH
81437: PPUSH
81438: PPUSH
81439: PPUSH
// if not mc_bases [ base ] then
81440: LD_EXP 59
81444: PUSH
81445: LD_VAR 0 1
81449: ARRAY
81450: NOT
81451: IFFALSE 81455
// exit ;
81453: GO 81520
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81455: LD_ADDR_EXP 79
81459: PUSH
81460: LD_EXP 79
81464: PPUSH
81465: LD_VAR 0 1
81469: PUSH
81470: LD_EXP 79
81474: PUSH
81475: LD_VAR 0 1
81479: ARRAY
81480: PUSH
81481: LD_INT 1
81483: PLUS
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PPUSH
81489: LD_VAR 0 1
81493: PUSH
81494: LD_VAR 0 2
81498: PUSH
81499: LD_VAR 0 3
81503: PUSH
81504: LD_VAR 0 4
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: LIST
81513: LIST
81514: PPUSH
81515: CALL 21525 0 3
81519: ST_TO_ADDR
// end ;
81520: LD_VAR 0 5
81524: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81525: LD_INT 0
81527: PPUSH
// if not mc_bases [ base ] then
81528: LD_EXP 59
81532: PUSH
81533: LD_VAR 0 1
81537: ARRAY
81538: NOT
81539: IFFALSE 81543
// exit ;
81541: GO 81568
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81543: LD_ADDR_EXP 96
81547: PUSH
81548: LD_EXP 96
81552: PPUSH
81553: LD_VAR 0 1
81557: PPUSH
81558: LD_VAR 0 2
81562: PPUSH
81563: CALL_OW 1
81567: ST_TO_ADDR
// end ;
81568: LD_VAR 0 3
81572: RET
// export function MC_GetMinesField ( base ) ; begin
81573: LD_INT 0
81575: PPUSH
// result := mc_mines [ base ] ;
81576: LD_ADDR_VAR 0 2
81580: PUSH
81581: LD_EXP 72
81585: PUSH
81586: LD_VAR 0 1
81590: ARRAY
81591: ST_TO_ADDR
// end ;
81592: LD_VAR 0 2
81596: RET
// export function MC_GetProduceList ( base ) ; begin
81597: LD_INT 0
81599: PPUSH
// result := mc_produce [ base ] ;
81600: LD_ADDR_VAR 0 2
81604: PUSH
81605: LD_EXP 80
81609: PUSH
81610: LD_VAR 0 1
81614: ARRAY
81615: ST_TO_ADDR
// end ;
81616: LD_VAR 0 2
81620: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81621: LD_INT 0
81623: PPUSH
81624: PPUSH
// if not mc_bases then
81625: LD_EXP 59
81629: NOT
81630: IFFALSE 81634
// exit ;
81632: GO 81699
// if mc_bases [ base ] then
81634: LD_EXP 59
81638: PUSH
81639: LD_VAR 0 1
81643: ARRAY
81644: IFFALSE 81699
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81646: LD_ADDR_VAR 0 3
81650: PUSH
81651: LD_EXP 59
81655: PUSH
81656: LD_VAR 0 1
81660: ARRAY
81661: PPUSH
81662: LD_INT 30
81664: PUSH
81665: LD_VAR 0 2
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: PPUSH
81674: CALL_OW 72
81678: ST_TO_ADDR
// if result then
81679: LD_VAR 0 3
81683: IFFALSE 81699
// result := result [ 1 ] ;
81685: LD_ADDR_VAR 0 3
81689: PUSH
81690: LD_VAR 0 3
81694: PUSH
81695: LD_INT 1
81697: ARRAY
81698: ST_TO_ADDR
// end ; end ;
81699: LD_VAR 0 3
81703: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81704: LD_INT 0
81706: PPUSH
81707: PPUSH
// if not mc_bases then
81708: LD_EXP 59
81712: NOT
81713: IFFALSE 81717
// exit ;
81715: GO 81762
// if mc_bases [ base ] then
81717: LD_EXP 59
81721: PUSH
81722: LD_VAR 0 1
81726: ARRAY
81727: IFFALSE 81762
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81729: LD_ADDR_VAR 0 3
81733: PUSH
81734: LD_EXP 59
81738: PUSH
81739: LD_VAR 0 1
81743: ARRAY
81744: PPUSH
81745: LD_INT 30
81747: PUSH
81748: LD_VAR 0 2
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PPUSH
81757: CALL_OW 72
81761: ST_TO_ADDR
// end ;
81762: LD_VAR 0 3
81766: RET
// export function MC_SetTame ( base , area ) ; begin
81767: LD_INT 0
81769: PPUSH
// if not mc_bases or not base then
81770: LD_EXP 59
81774: NOT
81775: PUSH
81776: LD_VAR 0 1
81780: NOT
81781: OR
81782: IFFALSE 81786
// exit ;
81784: GO 81811
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81786: LD_ADDR_EXP 87
81790: PUSH
81791: LD_EXP 87
81795: PPUSH
81796: LD_VAR 0 1
81800: PPUSH
81801: LD_VAR 0 2
81805: PPUSH
81806: CALL_OW 1
81810: ST_TO_ADDR
// end ;
81811: LD_VAR 0 3
81815: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81816: LD_INT 0
81818: PPUSH
81819: PPUSH
// if not mc_bases or not base then
81820: LD_EXP 59
81824: NOT
81825: PUSH
81826: LD_VAR 0 1
81830: NOT
81831: OR
81832: IFFALSE 81836
// exit ;
81834: GO 81938
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81836: LD_ADDR_VAR 0 4
81840: PUSH
81841: LD_EXP 59
81845: PUSH
81846: LD_VAR 0 1
81850: ARRAY
81851: PPUSH
81852: LD_INT 30
81854: PUSH
81855: LD_VAR 0 2
81859: PUSH
81860: EMPTY
81861: LIST
81862: LIST
81863: PPUSH
81864: CALL_OW 72
81868: ST_TO_ADDR
// if not tmp then
81869: LD_VAR 0 4
81873: NOT
81874: IFFALSE 81878
// exit ;
81876: GO 81938
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81878: LD_ADDR_EXP 91
81882: PUSH
81883: LD_EXP 91
81887: PPUSH
81888: LD_VAR 0 1
81892: PPUSH
81893: LD_EXP 91
81897: PUSH
81898: LD_VAR 0 1
81902: ARRAY
81903: PPUSH
81904: LD_EXP 91
81908: PUSH
81909: LD_VAR 0 1
81913: ARRAY
81914: PUSH
81915: LD_INT 1
81917: PLUS
81918: PPUSH
81919: LD_VAR 0 4
81923: PUSH
81924: LD_INT 1
81926: ARRAY
81927: PPUSH
81928: CALL_OW 2
81932: PPUSH
81933: CALL_OW 1
81937: ST_TO_ADDR
// end ;
81938: LD_VAR 0 3
81942: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81943: LD_INT 0
81945: PPUSH
81946: PPUSH
// if not mc_bases or not base or not kinds then
81947: LD_EXP 59
81951: NOT
81952: PUSH
81953: LD_VAR 0 1
81957: NOT
81958: OR
81959: PUSH
81960: LD_VAR 0 2
81964: NOT
81965: OR
81966: IFFALSE 81970
// exit ;
81968: GO 82031
// for i in kinds do
81970: LD_ADDR_VAR 0 4
81974: PUSH
81975: LD_VAR 0 2
81979: PUSH
81980: FOR_IN
81981: IFFALSE 82029
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81983: LD_ADDR_EXP 93
81987: PUSH
81988: LD_EXP 93
81992: PPUSH
81993: LD_VAR 0 1
81997: PUSH
81998: LD_EXP 93
82002: PUSH
82003: LD_VAR 0 1
82007: ARRAY
82008: PUSH
82009: LD_INT 1
82011: PLUS
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PPUSH
82017: LD_VAR 0 4
82021: PPUSH
82022: CALL 21525 0 3
82026: ST_TO_ADDR
82027: GO 81980
82029: POP
82030: POP
// end ;
82031: LD_VAR 0 3
82035: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
82036: LD_INT 0
82038: PPUSH
// if not mc_bases or not base or not areas then
82039: LD_EXP 59
82043: NOT
82044: PUSH
82045: LD_VAR 0 1
82049: NOT
82050: OR
82051: PUSH
82052: LD_VAR 0 2
82056: NOT
82057: OR
82058: IFFALSE 82062
// exit ;
82060: GO 82087
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
82062: LD_ADDR_EXP 77
82066: PUSH
82067: LD_EXP 77
82071: PPUSH
82072: LD_VAR 0 1
82076: PPUSH
82077: LD_VAR 0 2
82081: PPUSH
82082: CALL_OW 1
82086: ST_TO_ADDR
// end ;
82087: LD_VAR 0 3
82091: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
82092: LD_INT 0
82094: PPUSH
// if not mc_bases or not base or not teleports_exit then
82095: LD_EXP 59
82099: NOT
82100: PUSH
82101: LD_VAR 0 1
82105: NOT
82106: OR
82107: PUSH
82108: LD_VAR 0 2
82112: NOT
82113: OR
82114: IFFALSE 82118
// exit ;
82116: GO 82143
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
82118: LD_ADDR_EXP 94
82122: PUSH
82123: LD_EXP 94
82127: PPUSH
82128: LD_VAR 0 1
82132: PPUSH
82133: LD_VAR 0 2
82137: PPUSH
82138: CALL_OW 1
82142: ST_TO_ADDR
// end ;
82143: LD_VAR 0 3
82147: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
82148: LD_INT 0
82150: PPUSH
82151: PPUSH
82152: PPUSH
// if not mc_bases or not base or not ext_list then
82153: LD_EXP 59
82157: NOT
82158: PUSH
82159: LD_VAR 0 1
82163: NOT
82164: OR
82165: PUSH
82166: LD_VAR 0 5
82170: NOT
82171: OR
82172: IFFALSE 82176
// exit ;
82174: GO 82349
// tmp := GetFacExtXYD ( x , y , d ) ;
82176: LD_ADDR_VAR 0 8
82180: PUSH
82181: LD_VAR 0 2
82185: PPUSH
82186: LD_VAR 0 3
82190: PPUSH
82191: LD_VAR 0 4
82195: PPUSH
82196: CALL 54903 0 3
82200: ST_TO_ADDR
// if not tmp then
82201: LD_VAR 0 8
82205: NOT
82206: IFFALSE 82210
// exit ;
82208: GO 82349
// for i in tmp do
82210: LD_ADDR_VAR 0 7
82214: PUSH
82215: LD_VAR 0 8
82219: PUSH
82220: FOR_IN
82221: IFFALSE 82347
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
82223: LD_ADDR_EXP 64
82227: PUSH
82228: LD_EXP 64
82232: PPUSH
82233: LD_VAR 0 1
82237: PPUSH
82238: LD_EXP 64
82242: PUSH
82243: LD_VAR 0 1
82247: ARRAY
82248: PPUSH
82249: LD_EXP 64
82253: PUSH
82254: LD_VAR 0 1
82258: ARRAY
82259: PUSH
82260: LD_INT 1
82262: PLUS
82263: PPUSH
82264: LD_VAR 0 5
82268: PUSH
82269: LD_INT 1
82271: ARRAY
82272: PUSH
82273: LD_VAR 0 7
82277: PUSH
82278: LD_INT 1
82280: ARRAY
82281: PUSH
82282: LD_VAR 0 7
82286: PUSH
82287: LD_INT 2
82289: ARRAY
82290: PUSH
82291: LD_VAR 0 7
82295: PUSH
82296: LD_INT 3
82298: ARRAY
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: LIST
82304: LIST
82305: PPUSH
82306: CALL_OW 2
82310: PPUSH
82311: CALL_OW 1
82315: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82316: LD_ADDR_VAR 0 5
82320: PUSH
82321: LD_VAR 0 5
82325: PPUSH
82326: LD_INT 1
82328: PPUSH
82329: CALL_OW 3
82333: ST_TO_ADDR
// if not ext_list then
82334: LD_VAR 0 5
82338: NOT
82339: IFFALSE 82345
// exit ;
82341: POP
82342: POP
82343: GO 82349
// end ;
82345: GO 82220
82347: POP
82348: POP
// end ;
82349: LD_VAR 0 6
82353: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82354: LD_INT 0
82356: PPUSH
// if not mc_bases or not base or not weapon_list then
82357: LD_EXP 59
82361: NOT
82362: PUSH
82363: LD_VAR 0 1
82367: NOT
82368: OR
82369: PUSH
82370: LD_VAR 0 2
82374: NOT
82375: OR
82376: IFFALSE 82380
// exit ;
82378: GO 82405
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82380: LD_ADDR_EXP 98
82384: PUSH
82385: LD_EXP 98
82389: PPUSH
82390: LD_VAR 0 1
82394: PPUSH
82395: LD_VAR 0 2
82399: PPUSH
82400: CALL_OW 1
82404: ST_TO_ADDR
// end ;
82405: LD_VAR 0 3
82409: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82410: LD_INT 0
82412: PPUSH
// if not mc_bases or not base or not tech_list then
82413: LD_EXP 59
82417: NOT
82418: PUSH
82419: LD_VAR 0 1
82423: NOT
82424: OR
82425: PUSH
82426: LD_VAR 0 2
82430: NOT
82431: OR
82432: IFFALSE 82436
// exit ;
82434: GO 82461
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82436: LD_ADDR_EXP 86
82440: PUSH
82441: LD_EXP 86
82445: PPUSH
82446: LD_VAR 0 1
82450: PPUSH
82451: LD_VAR 0 2
82455: PPUSH
82456: CALL_OW 1
82460: ST_TO_ADDR
// end ;
82461: LD_VAR 0 3
82465: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82466: LD_INT 0
82468: PPUSH
// if not mc_bases or not parking_area or not base then
82469: LD_EXP 59
82473: NOT
82474: PUSH
82475: LD_VAR 0 2
82479: NOT
82480: OR
82481: PUSH
82482: LD_VAR 0 1
82486: NOT
82487: OR
82488: IFFALSE 82492
// exit ;
82490: GO 82517
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82492: LD_ADDR_EXP 83
82496: PUSH
82497: LD_EXP 83
82501: PPUSH
82502: LD_VAR 0 1
82506: PPUSH
82507: LD_VAR 0 2
82511: PPUSH
82512: CALL_OW 1
82516: ST_TO_ADDR
// end ;
82517: LD_VAR 0 3
82521: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82522: LD_INT 0
82524: PPUSH
// if not mc_bases or not base or not scan_area then
82525: LD_EXP 59
82529: NOT
82530: PUSH
82531: LD_VAR 0 1
82535: NOT
82536: OR
82537: PUSH
82538: LD_VAR 0 2
82542: NOT
82543: OR
82544: IFFALSE 82548
// exit ;
82546: GO 82573
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82548: LD_ADDR_EXP 84
82552: PUSH
82553: LD_EXP 84
82557: PPUSH
82558: LD_VAR 0 1
82562: PPUSH
82563: LD_VAR 0 2
82567: PPUSH
82568: CALL_OW 1
82572: ST_TO_ADDR
// end ;
82573: LD_VAR 0 3
82577: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82578: LD_INT 0
82580: PPUSH
82581: PPUSH
// if not mc_bases or not base then
82582: LD_EXP 59
82586: NOT
82587: PUSH
82588: LD_VAR 0 1
82592: NOT
82593: OR
82594: IFFALSE 82598
// exit ;
82596: GO 82662
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82598: LD_ADDR_VAR 0 3
82602: PUSH
82603: LD_INT 1
82605: PUSH
82606: LD_INT 2
82608: PUSH
82609: LD_INT 3
82611: PUSH
82612: LD_INT 4
82614: PUSH
82615: LD_INT 11
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: LIST
82622: LIST
82623: LIST
82624: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82625: LD_ADDR_EXP 86
82629: PUSH
82630: LD_EXP 86
82634: PPUSH
82635: LD_VAR 0 1
82639: PPUSH
82640: LD_EXP 86
82644: PUSH
82645: LD_VAR 0 1
82649: ARRAY
82650: PUSH
82651: LD_VAR 0 3
82655: DIFF
82656: PPUSH
82657: CALL_OW 1
82661: ST_TO_ADDR
// end ;
82662: LD_VAR 0 2
82666: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82667: LD_INT 0
82669: PPUSH
// result := mc_vehicles [ base ] ;
82670: LD_ADDR_VAR 0 3
82674: PUSH
82675: LD_EXP 78
82679: PUSH
82680: LD_VAR 0 1
82684: ARRAY
82685: ST_TO_ADDR
// if onlyCombat then
82686: LD_VAR 0 2
82690: IFFALSE 82855
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82692: LD_ADDR_VAR 0 3
82696: PUSH
82697: LD_VAR 0 3
82701: PUSH
82702: LD_VAR 0 3
82706: PPUSH
82707: LD_INT 2
82709: PUSH
82710: LD_INT 34
82712: PUSH
82713: LD_INT 12
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PUSH
82720: LD_INT 34
82722: PUSH
82723: LD_INT 51
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 34
82732: PUSH
82733: LD_EXP 103
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 34
82744: PUSH
82745: LD_INT 32
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 34
82754: PUSH
82755: LD_INT 13
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 34
82764: PUSH
82765: LD_INT 52
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: LD_INT 34
82774: PUSH
82775: LD_INT 14
82777: PUSH
82778: EMPTY
82779: LIST
82780: LIST
82781: PUSH
82782: LD_INT 34
82784: PUSH
82785: LD_INT 53
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 34
82794: PUSH
82795: LD_EXP 102
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 34
82806: PUSH
82807: LD_INT 31
82809: PUSH
82810: EMPTY
82811: LIST
82812: LIST
82813: PUSH
82814: LD_INT 34
82816: PUSH
82817: LD_INT 48
82819: PUSH
82820: EMPTY
82821: LIST
82822: LIST
82823: PUSH
82824: LD_INT 34
82826: PUSH
82827: LD_INT 8
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: EMPTY
82835: LIST
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: PPUSH
82849: CALL_OW 72
82853: DIFF
82854: ST_TO_ADDR
// end ; end_of_file
82855: LD_VAR 0 3
82859: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82860: LD_INT 0
82862: PPUSH
82863: PPUSH
82864: PPUSH
// if not mc_bases or not skirmish then
82865: LD_EXP 59
82869: NOT
82870: PUSH
82871: LD_EXP 57
82875: NOT
82876: OR
82877: IFFALSE 82881
// exit ;
82879: GO 83046
// for i = 1 to mc_bases do
82881: LD_ADDR_VAR 0 4
82885: PUSH
82886: DOUBLE
82887: LD_INT 1
82889: DEC
82890: ST_TO_ADDR
82891: LD_EXP 59
82895: PUSH
82896: FOR_TO
82897: IFFALSE 83044
// begin if sci in mc_bases [ i ] then
82899: LD_VAR 0 2
82903: PUSH
82904: LD_EXP 59
82908: PUSH
82909: LD_VAR 0 4
82913: ARRAY
82914: IN
82915: IFFALSE 83042
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82917: LD_ADDR_EXP 88
82921: PUSH
82922: LD_EXP 88
82926: PPUSH
82927: LD_VAR 0 4
82931: PUSH
82932: LD_EXP 88
82936: PUSH
82937: LD_VAR 0 4
82941: ARRAY
82942: PUSH
82943: LD_INT 1
82945: PLUS
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PPUSH
82951: LD_VAR 0 1
82955: PPUSH
82956: CALL 21525 0 3
82960: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82961: LD_ADDR_VAR 0 5
82965: PUSH
82966: LD_EXP 59
82970: PUSH
82971: LD_VAR 0 4
82975: ARRAY
82976: PPUSH
82977: LD_INT 2
82979: PUSH
82980: LD_INT 30
82982: PUSH
82983: LD_INT 0
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 30
82992: PUSH
82993: LD_INT 1
82995: PUSH
82996: EMPTY
82997: LIST
82998: LIST
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: LIST
83004: PPUSH
83005: CALL_OW 72
83009: PPUSH
83010: LD_VAR 0 1
83014: PPUSH
83015: CALL_OW 74
83019: ST_TO_ADDR
// if tmp then
83020: LD_VAR 0 5
83024: IFFALSE 83040
// ComStandNearbyBuilding ( ape , tmp ) ;
83026: LD_VAR 0 1
83030: PPUSH
83031: LD_VAR 0 5
83035: PPUSH
83036: CALL 15728 0 2
// break ;
83040: GO 83044
// end ; end ;
83042: GO 82896
83044: POP
83045: POP
// end ;
83046: LD_VAR 0 3
83050: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
83051: LD_INT 0
83053: PPUSH
83054: PPUSH
83055: PPUSH
// if not mc_bases or not skirmish then
83056: LD_EXP 59
83060: NOT
83061: PUSH
83062: LD_EXP 57
83066: NOT
83067: OR
83068: IFFALSE 83072
// exit ;
83070: GO 83161
// for i = 1 to mc_bases do
83072: LD_ADDR_VAR 0 4
83076: PUSH
83077: DOUBLE
83078: LD_INT 1
83080: DEC
83081: ST_TO_ADDR
83082: LD_EXP 59
83086: PUSH
83087: FOR_TO
83088: IFFALSE 83159
// begin if building in mc_busy_turret_list [ i ] then
83090: LD_VAR 0 1
83094: PUSH
83095: LD_EXP 69
83099: PUSH
83100: LD_VAR 0 4
83104: ARRAY
83105: IN
83106: IFFALSE 83157
// begin tmp := mc_busy_turret_list [ i ] diff building ;
83108: LD_ADDR_VAR 0 5
83112: PUSH
83113: LD_EXP 69
83117: PUSH
83118: LD_VAR 0 4
83122: ARRAY
83123: PUSH
83124: LD_VAR 0 1
83128: DIFF
83129: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
83130: LD_ADDR_EXP 69
83134: PUSH
83135: LD_EXP 69
83139: PPUSH
83140: LD_VAR 0 4
83144: PPUSH
83145: LD_VAR 0 5
83149: PPUSH
83150: CALL_OW 1
83154: ST_TO_ADDR
// break ;
83155: GO 83159
// end ; end ;
83157: GO 83087
83159: POP
83160: POP
// end ;
83161: LD_VAR 0 3
83165: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
83166: LD_INT 0
83168: PPUSH
83169: PPUSH
83170: PPUSH
// if not mc_bases or not skirmish then
83171: LD_EXP 59
83175: NOT
83176: PUSH
83177: LD_EXP 57
83181: NOT
83182: OR
83183: IFFALSE 83187
// exit ;
83185: GO 83386
// for i = 1 to mc_bases do
83187: LD_ADDR_VAR 0 5
83191: PUSH
83192: DOUBLE
83193: LD_INT 1
83195: DEC
83196: ST_TO_ADDR
83197: LD_EXP 59
83201: PUSH
83202: FOR_TO
83203: IFFALSE 83384
// if building in mc_bases [ i ] then
83205: LD_VAR 0 1
83209: PUSH
83210: LD_EXP 59
83214: PUSH
83215: LD_VAR 0 5
83219: ARRAY
83220: IN
83221: IFFALSE 83382
// begin tmp := mc_bases [ i ] diff building ;
83223: LD_ADDR_VAR 0 6
83227: PUSH
83228: LD_EXP 59
83232: PUSH
83233: LD_VAR 0 5
83237: ARRAY
83238: PUSH
83239: LD_VAR 0 1
83243: DIFF
83244: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
83245: LD_ADDR_EXP 59
83249: PUSH
83250: LD_EXP 59
83254: PPUSH
83255: LD_VAR 0 5
83259: PPUSH
83260: LD_VAR 0 6
83264: PPUSH
83265: CALL_OW 1
83269: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83270: LD_VAR 0 1
83274: PUSH
83275: LD_EXP 67
83279: PUSH
83280: LD_VAR 0 5
83284: ARRAY
83285: IN
83286: IFFALSE 83325
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83288: LD_ADDR_EXP 67
83292: PUSH
83293: LD_EXP 67
83297: PPUSH
83298: LD_VAR 0 5
83302: PPUSH
83303: LD_EXP 67
83307: PUSH
83308: LD_VAR 0 5
83312: ARRAY
83313: PUSH
83314: LD_VAR 0 1
83318: DIFF
83319: PPUSH
83320: CALL_OW 1
83324: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83325: LD_VAR 0 1
83329: PUSH
83330: LD_EXP 68
83334: PUSH
83335: LD_VAR 0 5
83339: ARRAY
83340: IN
83341: IFFALSE 83380
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83343: LD_ADDR_EXP 68
83347: PUSH
83348: LD_EXP 68
83352: PPUSH
83353: LD_VAR 0 5
83357: PPUSH
83358: LD_EXP 68
83362: PUSH
83363: LD_VAR 0 5
83367: ARRAY
83368: PUSH
83369: LD_VAR 0 1
83373: DIFF
83374: PPUSH
83375: CALL_OW 1
83379: ST_TO_ADDR
// break ;
83380: GO 83384
// end ;
83382: GO 83202
83384: POP
83385: POP
// end ;
83386: LD_VAR 0 4
83390: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83391: LD_INT 0
83393: PPUSH
83394: PPUSH
83395: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83396: LD_EXP 59
83400: NOT
83401: PUSH
83402: LD_EXP 57
83406: NOT
83407: OR
83408: PUSH
83409: LD_VAR 0 3
83413: PUSH
83414: LD_EXP 85
83418: IN
83419: NOT
83420: OR
83421: IFFALSE 83425
// exit ;
83423: GO 83548
// for i = 1 to mc_vehicles do
83425: LD_ADDR_VAR 0 6
83429: PUSH
83430: DOUBLE
83431: LD_INT 1
83433: DEC
83434: ST_TO_ADDR
83435: LD_EXP 78
83439: PUSH
83440: FOR_TO
83441: IFFALSE 83546
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83443: LD_VAR 0 2
83447: PUSH
83448: LD_EXP 78
83452: PUSH
83453: LD_VAR 0 6
83457: ARRAY
83458: IN
83459: PUSH
83460: LD_VAR 0 1
83464: PUSH
83465: LD_EXP 78
83469: PUSH
83470: LD_VAR 0 6
83474: ARRAY
83475: IN
83476: OR
83477: IFFALSE 83544
// begin tmp := mc_vehicles [ i ] diff old ;
83479: LD_ADDR_VAR 0 7
83483: PUSH
83484: LD_EXP 78
83488: PUSH
83489: LD_VAR 0 6
83493: ARRAY
83494: PUSH
83495: LD_VAR 0 2
83499: DIFF
83500: ST_TO_ADDR
// tmp := tmp diff new ;
83501: LD_ADDR_VAR 0 7
83505: PUSH
83506: LD_VAR 0 7
83510: PUSH
83511: LD_VAR 0 1
83515: DIFF
83516: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83517: LD_ADDR_EXP 78
83521: PUSH
83522: LD_EXP 78
83526: PPUSH
83527: LD_VAR 0 6
83531: PPUSH
83532: LD_VAR 0 7
83536: PPUSH
83537: CALL_OW 1
83541: ST_TO_ADDR
// break ;
83542: GO 83546
// end ;
83544: GO 83440
83546: POP
83547: POP
// end ;
83548: LD_VAR 0 5
83552: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83553: LD_INT 0
83555: PPUSH
83556: PPUSH
83557: PPUSH
83558: PPUSH
// if not mc_bases or not skirmish then
83559: LD_EXP 59
83563: NOT
83564: PUSH
83565: LD_EXP 57
83569: NOT
83570: OR
83571: IFFALSE 83575
// exit ;
83573: GO 83952
// side := GetSide ( vehicle ) ;
83575: LD_ADDR_VAR 0 5
83579: PUSH
83580: LD_VAR 0 1
83584: PPUSH
83585: CALL_OW 255
83589: ST_TO_ADDR
// for i = 1 to mc_bases do
83590: LD_ADDR_VAR 0 4
83594: PUSH
83595: DOUBLE
83596: LD_INT 1
83598: DEC
83599: ST_TO_ADDR
83600: LD_EXP 59
83604: PUSH
83605: FOR_TO
83606: IFFALSE 83950
// begin if factory in mc_bases [ i ] then
83608: LD_VAR 0 2
83612: PUSH
83613: LD_EXP 59
83617: PUSH
83618: LD_VAR 0 4
83622: ARRAY
83623: IN
83624: IFFALSE 83948
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
83626: LD_EXP 81
83630: PUSH
83631: LD_VAR 0 4
83635: ARRAY
83636: PUSH
83637: LD_EXP 70
83641: PUSH
83642: LD_VAR 0 4
83646: ARRAY
83647: LESS
83648: PUSH
83649: LD_VAR 0 1
83653: PPUSH
83654: CALL_OW 264
83658: PUSH
83659: LD_INT 31
83661: PUSH
83662: LD_INT 32
83664: PUSH
83665: LD_INT 51
83667: PUSH
83668: LD_EXP 103
83672: PUSH
83673: LD_INT 12
83675: PUSH
83676: LD_INT 30
83678: PUSH
83679: LD_EXP 102
83683: PUSH
83684: LD_INT 11
83686: PUSH
83687: LD_INT 53
83689: PUSH
83690: LD_INT 14
83692: PUSH
83693: LD_EXP 106
83697: PUSH
83698: LD_INT 29
83700: PUSH
83701: LD_EXP 104
83705: PUSH
83706: LD_INT 13
83708: PUSH
83709: LD_INT 52
83711: PUSH
83712: LD_INT 48
83714: PUSH
83715: LD_INT 8
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: LIST
83722: LIST
83723: LIST
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: LIST
83729: LIST
83730: LIST
83731: LIST
83732: LIST
83733: LIST
83734: LIST
83735: LIST
83736: IN
83737: NOT
83738: AND
83739: IFFALSE 83787
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83741: LD_ADDR_EXP 81
83745: PUSH
83746: LD_EXP 81
83750: PPUSH
83751: LD_VAR 0 4
83755: PUSH
83756: LD_EXP 81
83760: PUSH
83761: LD_VAR 0 4
83765: ARRAY
83766: PUSH
83767: LD_INT 1
83769: PLUS
83770: PUSH
83771: EMPTY
83772: LIST
83773: LIST
83774: PPUSH
83775: LD_VAR 0 1
83779: PPUSH
83780: CALL 21525 0 3
83784: ST_TO_ADDR
83785: GO 83831
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83787: LD_ADDR_EXP 78
83791: PUSH
83792: LD_EXP 78
83796: PPUSH
83797: LD_VAR 0 4
83801: PUSH
83802: LD_EXP 78
83806: PUSH
83807: LD_VAR 0 4
83811: ARRAY
83812: PUSH
83813: LD_INT 1
83815: PLUS
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: PPUSH
83821: LD_VAR 0 1
83825: PPUSH
83826: CALL 21525 0 3
83830: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83831: LD_VAR 0 1
83835: PPUSH
83836: CALL_OW 263
83840: PUSH
83841: LD_INT 2
83843: EQUAL
83844: IFFALSE 83864
// begin repeat wait ( 0 0$1 ) ;
83846: LD_INT 35
83848: PPUSH
83849: CALL_OW 67
// until IsControledBy ( vehicle ) ;
83853: LD_VAR 0 1
83857: PPUSH
83858: CALL_OW 312
83862: IFFALSE 83846
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83864: LD_VAR 0 1
83868: PPUSH
83869: LD_EXP 83
83873: PUSH
83874: LD_VAR 0 4
83878: ARRAY
83879: PPUSH
83880: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83884: LD_VAR 0 1
83888: PPUSH
83889: CALL_OW 263
83893: PUSH
83894: LD_INT 1
83896: NONEQUAL
83897: IFFALSE 83901
// break ;
83899: GO 83950
// repeat wait ( 0 0$1 ) ;
83901: LD_INT 35
83903: PPUSH
83904: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83908: LD_VAR 0 1
83912: PPUSH
83913: LD_EXP 83
83917: PUSH
83918: LD_VAR 0 4
83922: ARRAY
83923: PPUSH
83924: CALL_OW 308
83928: IFFALSE 83901
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83930: LD_VAR 0 1
83934: PPUSH
83935: CALL_OW 311
83939: PPUSH
83940: CALL_OW 121
// exit ;
83944: POP
83945: POP
83946: GO 83952
// end ; end ;
83948: GO 83605
83950: POP
83951: POP
// end ;
83952: LD_VAR 0 3
83956: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83957: LD_INT 0
83959: PPUSH
83960: PPUSH
83961: PPUSH
83962: PPUSH
// if not mc_bases or not skirmish then
83963: LD_EXP 59
83967: NOT
83968: PUSH
83969: LD_EXP 57
83973: NOT
83974: OR
83975: IFFALSE 83979
// exit ;
83977: GO 84332
// repeat wait ( 0 0$1 ) ;
83979: LD_INT 35
83981: PPUSH
83982: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83986: LD_VAR 0 2
83990: PPUSH
83991: LD_VAR 0 3
83995: PPUSH
83996: CALL_OW 284
84000: IFFALSE 83979
// if GetResourceTypeXY ( x , y ) = mat_artefact then
84002: LD_VAR 0 2
84006: PPUSH
84007: LD_VAR 0 3
84011: PPUSH
84012: CALL_OW 283
84016: PUSH
84017: LD_INT 4
84019: EQUAL
84020: IFFALSE 84024
// exit ;
84022: GO 84332
// for i = 1 to mc_bases do
84024: LD_ADDR_VAR 0 7
84028: PUSH
84029: DOUBLE
84030: LD_INT 1
84032: DEC
84033: ST_TO_ADDR
84034: LD_EXP 59
84038: PUSH
84039: FOR_TO
84040: IFFALSE 84330
// begin if mc_crates_area [ i ] then
84042: LD_EXP 77
84046: PUSH
84047: LD_VAR 0 7
84051: ARRAY
84052: IFFALSE 84163
// for j in mc_crates_area [ i ] do
84054: LD_ADDR_VAR 0 8
84058: PUSH
84059: LD_EXP 77
84063: PUSH
84064: LD_VAR 0 7
84068: ARRAY
84069: PUSH
84070: FOR_IN
84071: IFFALSE 84161
// if InArea ( x , y , j ) then
84073: LD_VAR 0 2
84077: PPUSH
84078: LD_VAR 0 3
84082: PPUSH
84083: LD_VAR 0 8
84087: PPUSH
84088: CALL_OW 309
84092: IFFALSE 84159
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84094: LD_ADDR_EXP 75
84098: PUSH
84099: LD_EXP 75
84103: PPUSH
84104: LD_VAR 0 7
84108: PUSH
84109: LD_EXP 75
84113: PUSH
84114: LD_VAR 0 7
84118: ARRAY
84119: PUSH
84120: LD_INT 1
84122: PLUS
84123: PUSH
84124: EMPTY
84125: LIST
84126: LIST
84127: PPUSH
84128: LD_VAR 0 4
84132: PUSH
84133: LD_VAR 0 2
84137: PUSH
84138: LD_VAR 0 3
84142: PUSH
84143: EMPTY
84144: LIST
84145: LIST
84146: LIST
84147: PPUSH
84148: CALL 21525 0 3
84152: ST_TO_ADDR
// exit ;
84153: POP
84154: POP
84155: POP
84156: POP
84157: GO 84332
// end ;
84159: GO 84070
84161: POP
84162: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84163: LD_ADDR_VAR 0 9
84167: PUSH
84168: LD_EXP 59
84172: PUSH
84173: LD_VAR 0 7
84177: ARRAY
84178: PPUSH
84179: LD_INT 2
84181: PUSH
84182: LD_INT 30
84184: PUSH
84185: LD_INT 0
84187: PUSH
84188: EMPTY
84189: LIST
84190: LIST
84191: PUSH
84192: LD_INT 30
84194: PUSH
84195: LD_INT 1
84197: PUSH
84198: EMPTY
84199: LIST
84200: LIST
84201: PUSH
84202: EMPTY
84203: LIST
84204: LIST
84205: LIST
84206: PPUSH
84207: CALL_OW 72
84211: ST_TO_ADDR
// if not depot then
84212: LD_VAR 0 9
84216: NOT
84217: IFFALSE 84221
// continue ;
84219: GO 84039
// for j in depot do
84221: LD_ADDR_VAR 0 8
84225: PUSH
84226: LD_VAR 0 9
84230: PUSH
84231: FOR_IN
84232: IFFALSE 84326
// if GetDistUnitXY ( j , x , y ) < 30 then
84234: LD_VAR 0 8
84238: PPUSH
84239: LD_VAR 0 2
84243: PPUSH
84244: LD_VAR 0 3
84248: PPUSH
84249: CALL_OW 297
84253: PUSH
84254: LD_INT 30
84256: LESS
84257: IFFALSE 84324
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84259: LD_ADDR_EXP 75
84263: PUSH
84264: LD_EXP 75
84268: PPUSH
84269: LD_VAR 0 7
84273: PUSH
84274: LD_EXP 75
84278: PUSH
84279: LD_VAR 0 7
84283: ARRAY
84284: PUSH
84285: LD_INT 1
84287: PLUS
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PPUSH
84293: LD_VAR 0 4
84297: PUSH
84298: LD_VAR 0 2
84302: PUSH
84303: LD_VAR 0 3
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: LIST
84312: PPUSH
84313: CALL 21525 0 3
84317: ST_TO_ADDR
// exit ;
84318: POP
84319: POP
84320: POP
84321: POP
84322: GO 84332
// end ;
84324: GO 84231
84326: POP
84327: POP
// end ;
84328: GO 84039
84330: POP
84331: POP
// end ;
84332: LD_VAR 0 6
84336: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84337: LD_INT 0
84339: PPUSH
84340: PPUSH
84341: PPUSH
84342: PPUSH
// if not mc_bases or not skirmish then
84343: LD_EXP 59
84347: NOT
84348: PUSH
84349: LD_EXP 57
84353: NOT
84354: OR
84355: IFFALSE 84359
// exit ;
84357: GO 84636
// side := GetSide ( lab ) ;
84359: LD_ADDR_VAR 0 4
84363: PUSH
84364: LD_VAR 0 2
84368: PPUSH
84369: CALL_OW 255
84373: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84374: LD_VAR 0 4
84378: PUSH
84379: LD_EXP 85
84383: IN
84384: NOT
84385: PUSH
84386: LD_EXP 86
84390: NOT
84391: OR
84392: PUSH
84393: LD_EXP 59
84397: NOT
84398: OR
84399: IFFALSE 84403
// exit ;
84401: GO 84636
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84403: LD_ADDR_EXP 86
84407: PUSH
84408: LD_EXP 86
84412: PPUSH
84413: LD_VAR 0 4
84417: PPUSH
84418: LD_EXP 86
84422: PUSH
84423: LD_VAR 0 4
84427: ARRAY
84428: PUSH
84429: LD_VAR 0 1
84433: DIFF
84434: PPUSH
84435: CALL_OW 1
84439: ST_TO_ADDR
// for i = 1 to mc_bases do
84440: LD_ADDR_VAR 0 5
84444: PUSH
84445: DOUBLE
84446: LD_INT 1
84448: DEC
84449: ST_TO_ADDR
84450: LD_EXP 59
84454: PUSH
84455: FOR_TO
84456: IFFALSE 84634
// begin if lab in mc_bases [ i ] then
84458: LD_VAR 0 2
84462: PUSH
84463: LD_EXP 59
84467: PUSH
84468: LD_VAR 0 5
84472: ARRAY
84473: IN
84474: IFFALSE 84632
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84476: LD_VAR 0 1
84480: PUSH
84481: LD_INT 11
84483: PUSH
84484: LD_INT 4
84486: PUSH
84487: LD_INT 3
84489: PUSH
84490: LD_INT 2
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: IN
84499: PUSH
84500: LD_EXP 89
84504: PUSH
84505: LD_VAR 0 5
84509: ARRAY
84510: AND
84511: IFFALSE 84632
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84513: LD_ADDR_VAR 0 6
84517: PUSH
84518: LD_EXP 89
84522: PUSH
84523: LD_VAR 0 5
84527: ARRAY
84528: PUSH
84529: LD_INT 1
84531: ARRAY
84532: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84533: LD_ADDR_EXP 89
84537: PUSH
84538: LD_EXP 89
84542: PPUSH
84543: LD_VAR 0 5
84547: PPUSH
84548: EMPTY
84549: PPUSH
84550: CALL_OW 1
84554: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84555: LD_VAR 0 6
84559: PPUSH
84560: LD_INT 0
84562: PPUSH
84563: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84567: LD_VAR 0 6
84571: PPUSH
84572: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84576: LD_ADDR_EXP 88
84580: PUSH
84581: LD_EXP 88
84585: PPUSH
84586: LD_VAR 0 5
84590: PPUSH
84591: LD_EXP 88
84595: PUSH
84596: LD_VAR 0 5
84600: ARRAY
84601: PPUSH
84602: LD_INT 1
84604: PPUSH
84605: LD_VAR 0 6
84609: PPUSH
84610: CALL_OW 2
84614: PPUSH
84615: CALL_OW 1
84619: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84620: LD_VAR 0 5
84624: PPUSH
84625: LD_INT 112
84627: PPUSH
84628: CALL 61528 0 2
// end ; end ; end ;
84632: GO 84455
84634: POP
84635: POP
// end ;
84636: LD_VAR 0 3
84640: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84641: LD_INT 0
84643: PPUSH
84644: PPUSH
84645: PPUSH
84646: PPUSH
84647: PPUSH
84648: PPUSH
84649: PPUSH
84650: PPUSH
// if not mc_bases or not skirmish then
84651: LD_EXP 59
84655: NOT
84656: PUSH
84657: LD_EXP 57
84661: NOT
84662: OR
84663: IFFALSE 84667
// exit ;
84665: GO 86038
// for i = 1 to mc_bases do
84667: LD_ADDR_VAR 0 3
84671: PUSH
84672: DOUBLE
84673: LD_INT 1
84675: DEC
84676: ST_TO_ADDR
84677: LD_EXP 59
84681: PUSH
84682: FOR_TO
84683: IFFALSE 86036
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84685: LD_VAR 0 1
84689: PUSH
84690: LD_EXP 59
84694: PUSH
84695: LD_VAR 0 3
84699: ARRAY
84700: IN
84701: PUSH
84702: LD_VAR 0 1
84706: PUSH
84707: LD_EXP 66
84711: PUSH
84712: LD_VAR 0 3
84716: ARRAY
84717: IN
84718: OR
84719: PUSH
84720: LD_VAR 0 1
84724: PUSH
84725: LD_EXP 81
84729: PUSH
84730: LD_VAR 0 3
84734: ARRAY
84735: IN
84736: OR
84737: PUSH
84738: LD_VAR 0 1
84742: PUSH
84743: LD_EXP 78
84747: PUSH
84748: LD_VAR 0 3
84752: ARRAY
84753: IN
84754: OR
84755: PUSH
84756: LD_VAR 0 1
84760: PUSH
84761: LD_EXP 88
84765: PUSH
84766: LD_VAR 0 3
84770: ARRAY
84771: IN
84772: OR
84773: PUSH
84774: LD_VAR 0 1
84778: PUSH
84779: LD_EXP 89
84783: PUSH
84784: LD_VAR 0 3
84788: ARRAY
84789: IN
84790: OR
84791: IFFALSE 86034
// begin if un in mc_ape [ i ] then
84793: LD_VAR 0 1
84797: PUSH
84798: LD_EXP 88
84802: PUSH
84803: LD_VAR 0 3
84807: ARRAY
84808: IN
84809: IFFALSE 84848
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84811: LD_ADDR_EXP 88
84815: PUSH
84816: LD_EXP 88
84820: PPUSH
84821: LD_VAR 0 3
84825: PPUSH
84826: LD_EXP 88
84830: PUSH
84831: LD_VAR 0 3
84835: ARRAY
84836: PUSH
84837: LD_VAR 0 1
84841: DIFF
84842: PPUSH
84843: CALL_OW 1
84847: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84848: LD_VAR 0 1
84852: PUSH
84853: LD_EXP 89
84857: PUSH
84858: LD_VAR 0 3
84862: ARRAY
84863: IN
84864: IFFALSE 84888
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84866: LD_ADDR_EXP 89
84870: PUSH
84871: LD_EXP 89
84875: PPUSH
84876: LD_VAR 0 3
84880: PPUSH
84881: EMPTY
84882: PPUSH
84883: CALL_OW 1
84887: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84888: LD_VAR 0 1
84892: PPUSH
84893: CALL_OW 247
84897: PUSH
84898: LD_INT 2
84900: EQUAL
84901: PUSH
84902: LD_VAR 0 1
84906: PPUSH
84907: CALL_OW 110
84911: PUSH
84912: LD_INT 20
84914: EQUAL
84915: PUSH
84916: LD_VAR 0 1
84920: PUSH
84921: LD_EXP 81
84925: PUSH
84926: LD_VAR 0 3
84930: ARRAY
84931: IN
84932: OR
84933: PUSH
84934: LD_VAR 0 1
84938: PPUSH
84939: CALL_OW 264
84943: PUSH
84944: LD_INT 12
84946: PUSH
84947: LD_INT 51
84949: PUSH
84950: LD_EXP 103
84954: PUSH
84955: LD_INT 32
84957: PUSH
84958: LD_INT 13
84960: PUSH
84961: LD_INT 52
84963: PUSH
84964: LD_INT 31
84966: PUSH
84967: EMPTY
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: LIST
84973: LIST
84974: LIST
84975: IN
84976: OR
84977: AND
84978: IFFALSE 85286
// begin if un in mc_defender [ i ] then
84980: LD_VAR 0 1
84984: PUSH
84985: LD_EXP 81
84989: PUSH
84990: LD_VAR 0 3
84994: ARRAY
84995: IN
84996: IFFALSE 85035
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84998: LD_ADDR_EXP 81
85002: PUSH
85003: LD_EXP 81
85007: PPUSH
85008: LD_VAR 0 3
85012: PPUSH
85013: LD_EXP 81
85017: PUSH
85018: LD_VAR 0 3
85022: ARRAY
85023: PUSH
85024: LD_VAR 0 1
85028: DIFF
85029: PPUSH
85030: CALL_OW 1
85034: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
85035: LD_ADDR_VAR 0 8
85039: PUSH
85040: LD_VAR 0 3
85044: PPUSH
85045: LD_INT 3
85047: PPUSH
85048: CALL 81704 0 2
85052: ST_TO_ADDR
// if fac then
85053: LD_VAR 0 8
85057: IFFALSE 85286
// begin for j in fac do
85059: LD_ADDR_VAR 0 4
85063: PUSH
85064: LD_VAR 0 8
85068: PUSH
85069: FOR_IN
85070: IFFALSE 85284
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
85072: LD_ADDR_VAR 0 9
85076: PUSH
85077: LD_VAR 0 8
85081: PPUSH
85082: LD_VAR 0 1
85086: PPUSH
85087: CALL_OW 265
85091: PPUSH
85092: LD_VAR 0 1
85096: PPUSH
85097: CALL_OW 262
85101: PPUSH
85102: LD_VAR 0 1
85106: PPUSH
85107: CALL_OW 263
85111: PPUSH
85112: LD_VAR 0 1
85116: PPUSH
85117: CALL_OW 264
85121: PPUSH
85122: CALL 19057 0 5
85126: ST_TO_ADDR
// if components then
85127: LD_VAR 0 9
85131: IFFALSE 85282
// begin if GetWeapon ( un ) = ar_control_tower then
85133: LD_VAR 0 1
85137: PPUSH
85138: CALL_OW 264
85142: PUSH
85143: LD_INT 31
85145: EQUAL
85146: IFFALSE 85263
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
85148: LD_VAR 0 1
85152: PPUSH
85153: CALL_OW 311
85157: PPUSH
85158: LD_INT 0
85160: PPUSH
85161: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
85165: LD_ADDR_EXP 99
85169: PUSH
85170: LD_EXP 99
85174: PPUSH
85175: LD_VAR 0 3
85179: PPUSH
85180: LD_EXP 99
85184: PUSH
85185: LD_VAR 0 3
85189: ARRAY
85190: PUSH
85191: LD_VAR 0 1
85195: PPUSH
85196: CALL_OW 311
85200: DIFF
85201: PPUSH
85202: CALL_OW 1
85206: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
85207: LD_ADDR_VAR 0 7
85211: PUSH
85212: LD_EXP 80
85216: PUSH
85217: LD_VAR 0 3
85221: ARRAY
85222: PPUSH
85223: LD_INT 1
85225: PPUSH
85226: LD_VAR 0 9
85230: PPUSH
85231: CALL_OW 2
85235: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
85236: LD_ADDR_EXP 80
85240: PUSH
85241: LD_EXP 80
85245: PPUSH
85246: LD_VAR 0 3
85250: PPUSH
85251: LD_VAR 0 7
85255: PPUSH
85256: CALL_OW 1
85260: ST_TO_ADDR
// end else
85261: GO 85280
// MC_InsertProduceList ( i , [ components ] ) ;
85263: LD_VAR 0 3
85267: PPUSH
85268: LD_VAR 0 9
85272: PUSH
85273: EMPTY
85274: LIST
85275: PPUSH
85276: CALL 81249 0 2
// break ;
85280: GO 85284
// end ; end ;
85282: GO 85069
85284: POP
85285: POP
// end ; end ; if GetType ( un ) = unit_building then
85286: LD_VAR 0 1
85290: PPUSH
85291: CALL_OW 247
85295: PUSH
85296: LD_INT 3
85298: EQUAL
85299: IFFALSE 85702
// begin btype := GetBType ( un ) ;
85301: LD_ADDR_VAR 0 5
85305: PUSH
85306: LD_VAR 0 1
85310: PPUSH
85311: CALL_OW 266
85315: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85316: LD_VAR 0 5
85320: PUSH
85321: LD_INT 29
85323: PUSH
85324: LD_INT 30
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: IN
85331: IFFALSE 85404
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85333: LD_VAR 0 1
85337: PPUSH
85338: CALL_OW 250
85342: PPUSH
85343: LD_VAR 0 1
85347: PPUSH
85348: CALL_OW 251
85352: PPUSH
85353: LD_VAR 0 1
85357: PPUSH
85358: CALL_OW 255
85362: PPUSH
85363: CALL_OW 440
85367: NOT
85368: IFFALSE 85404
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85370: LD_VAR 0 1
85374: PPUSH
85375: CALL_OW 250
85379: PPUSH
85380: LD_VAR 0 1
85384: PPUSH
85385: CALL_OW 251
85389: PPUSH
85390: LD_VAR 0 1
85394: PPUSH
85395: CALL_OW 255
85399: PPUSH
85400: CALL_OW 441
// end ; if btype = b_warehouse then
85404: LD_VAR 0 5
85408: PUSH
85409: LD_INT 1
85411: EQUAL
85412: IFFALSE 85430
// begin btype := b_depot ;
85414: LD_ADDR_VAR 0 5
85418: PUSH
85419: LD_INT 0
85421: ST_TO_ADDR
// pos := 1 ;
85422: LD_ADDR_VAR 0 6
85426: PUSH
85427: LD_INT 1
85429: ST_TO_ADDR
// end ; if btype = b_factory then
85430: LD_VAR 0 5
85434: PUSH
85435: LD_INT 3
85437: EQUAL
85438: IFFALSE 85456
// begin btype := b_workshop ;
85440: LD_ADDR_VAR 0 5
85444: PUSH
85445: LD_INT 2
85447: ST_TO_ADDR
// pos := 1 ;
85448: LD_ADDR_VAR 0 6
85452: PUSH
85453: LD_INT 1
85455: ST_TO_ADDR
// end ; if btype = b_barracks then
85456: LD_VAR 0 5
85460: PUSH
85461: LD_INT 5
85463: EQUAL
85464: IFFALSE 85474
// btype := b_armoury ;
85466: LD_ADDR_VAR 0 5
85470: PUSH
85471: LD_INT 4
85473: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85474: LD_VAR 0 5
85478: PUSH
85479: LD_INT 7
85481: PUSH
85482: LD_INT 8
85484: PUSH
85485: EMPTY
85486: LIST
85487: LIST
85488: IN
85489: IFFALSE 85499
// btype := b_lab ;
85491: LD_ADDR_VAR 0 5
85495: PUSH
85496: LD_INT 6
85498: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85499: LD_ADDR_EXP 64
85503: PUSH
85504: LD_EXP 64
85508: PPUSH
85509: LD_VAR 0 3
85513: PUSH
85514: LD_EXP 64
85518: PUSH
85519: LD_VAR 0 3
85523: ARRAY
85524: PUSH
85525: LD_INT 1
85527: PLUS
85528: PUSH
85529: EMPTY
85530: LIST
85531: LIST
85532: PPUSH
85533: LD_VAR 0 5
85537: PUSH
85538: LD_VAR 0 1
85542: PPUSH
85543: CALL_OW 250
85547: PUSH
85548: LD_VAR 0 1
85552: PPUSH
85553: CALL_OW 251
85557: PUSH
85558: LD_VAR 0 1
85562: PPUSH
85563: CALL_OW 254
85567: PUSH
85568: EMPTY
85569: LIST
85570: LIST
85571: LIST
85572: LIST
85573: PPUSH
85574: CALL 21525 0 3
85578: ST_TO_ADDR
// if pos = 1 then
85579: LD_VAR 0 6
85583: PUSH
85584: LD_INT 1
85586: EQUAL
85587: IFFALSE 85702
// begin tmp := mc_build_list [ i ] ;
85589: LD_ADDR_VAR 0 7
85593: PUSH
85594: LD_EXP 64
85598: PUSH
85599: LD_VAR 0 3
85603: ARRAY
85604: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85605: LD_VAR 0 7
85609: PPUSH
85610: LD_INT 2
85612: PUSH
85613: LD_INT 30
85615: PUSH
85616: LD_INT 0
85618: PUSH
85619: EMPTY
85620: LIST
85621: LIST
85622: PUSH
85623: LD_INT 30
85625: PUSH
85626: LD_INT 1
85628: PUSH
85629: EMPTY
85630: LIST
85631: LIST
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: LIST
85637: PPUSH
85638: CALL_OW 72
85642: IFFALSE 85652
// pos := 2 ;
85644: LD_ADDR_VAR 0 6
85648: PUSH
85649: LD_INT 2
85651: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85652: LD_ADDR_VAR 0 7
85656: PUSH
85657: LD_VAR 0 7
85661: PPUSH
85662: LD_VAR 0 6
85666: PPUSH
85667: LD_VAR 0 7
85671: PPUSH
85672: CALL 21851 0 3
85676: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85677: LD_ADDR_EXP 64
85681: PUSH
85682: LD_EXP 64
85686: PPUSH
85687: LD_VAR 0 3
85691: PPUSH
85692: LD_VAR 0 7
85696: PPUSH
85697: CALL_OW 1
85701: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85702: LD_VAR 0 1
85706: PUSH
85707: LD_EXP 59
85711: PUSH
85712: LD_VAR 0 3
85716: ARRAY
85717: IN
85718: IFFALSE 85757
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85720: LD_ADDR_EXP 59
85724: PUSH
85725: LD_EXP 59
85729: PPUSH
85730: LD_VAR 0 3
85734: PPUSH
85735: LD_EXP 59
85739: PUSH
85740: LD_VAR 0 3
85744: ARRAY
85745: PUSH
85746: LD_VAR 0 1
85750: DIFF
85751: PPUSH
85752: CALL_OW 1
85756: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85757: LD_VAR 0 1
85761: PUSH
85762: LD_EXP 66
85766: PUSH
85767: LD_VAR 0 3
85771: ARRAY
85772: IN
85773: IFFALSE 85812
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85775: LD_ADDR_EXP 66
85779: PUSH
85780: LD_EXP 66
85784: PPUSH
85785: LD_VAR 0 3
85789: PPUSH
85790: LD_EXP 66
85794: PUSH
85795: LD_VAR 0 3
85799: ARRAY
85800: PUSH
85801: LD_VAR 0 1
85805: DIFF
85806: PPUSH
85807: CALL_OW 1
85811: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85812: LD_VAR 0 1
85816: PUSH
85817: LD_EXP 78
85821: PUSH
85822: LD_VAR 0 3
85826: ARRAY
85827: IN
85828: IFFALSE 85867
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85830: LD_ADDR_EXP 78
85834: PUSH
85835: LD_EXP 78
85839: PPUSH
85840: LD_VAR 0 3
85844: PPUSH
85845: LD_EXP 78
85849: PUSH
85850: LD_VAR 0 3
85854: ARRAY
85855: PUSH
85856: LD_VAR 0 1
85860: DIFF
85861: PPUSH
85862: CALL_OW 1
85866: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85867: LD_VAR 0 1
85871: PUSH
85872: LD_EXP 81
85876: PUSH
85877: LD_VAR 0 3
85881: ARRAY
85882: IN
85883: IFFALSE 85922
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85885: LD_ADDR_EXP 81
85889: PUSH
85890: LD_EXP 81
85894: PPUSH
85895: LD_VAR 0 3
85899: PPUSH
85900: LD_EXP 81
85904: PUSH
85905: LD_VAR 0 3
85909: ARRAY
85910: PUSH
85911: LD_VAR 0 1
85915: DIFF
85916: PPUSH
85917: CALL_OW 1
85921: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85922: LD_VAR 0 1
85926: PUSH
85927: LD_EXP 68
85931: PUSH
85932: LD_VAR 0 3
85936: ARRAY
85937: IN
85938: IFFALSE 85977
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85940: LD_ADDR_EXP 68
85944: PUSH
85945: LD_EXP 68
85949: PPUSH
85950: LD_VAR 0 3
85954: PPUSH
85955: LD_EXP 68
85959: PUSH
85960: LD_VAR 0 3
85964: ARRAY
85965: PUSH
85966: LD_VAR 0 1
85970: DIFF
85971: PPUSH
85972: CALL_OW 1
85976: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85977: LD_VAR 0 1
85981: PUSH
85982: LD_EXP 67
85986: PUSH
85987: LD_VAR 0 3
85991: ARRAY
85992: IN
85993: IFFALSE 86032
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85995: LD_ADDR_EXP 67
85999: PUSH
86000: LD_EXP 67
86004: PPUSH
86005: LD_VAR 0 3
86009: PPUSH
86010: LD_EXP 67
86014: PUSH
86015: LD_VAR 0 3
86019: ARRAY
86020: PUSH
86021: LD_VAR 0 1
86025: DIFF
86026: PPUSH
86027: CALL_OW 1
86031: ST_TO_ADDR
// end ; break ;
86032: GO 86036
// end ;
86034: GO 84682
86036: POP
86037: POP
// end ;
86038: LD_VAR 0 2
86042: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
86043: LD_INT 0
86045: PPUSH
86046: PPUSH
86047: PPUSH
// if not mc_bases or not skirmish then
86048: LD_EXP 59
86052: NOT
86053: PUSH
86054: LD_EXP 57
86058: NOT
86059: OR
86060: IFFALSE 86064
// exit ;
86062: GO 86279
// for i = 1 to mc_bases do
86064: LD_ADDR_VAR 0 3
86068: PUSH
86069: DOUBLE
86070: LD_INT 1
86072: DEC
86073: ST_TO_ADDR
86074: LD_EXP 59
86078: PUSH
86079: FOR_TO
86080: IFFALSE 86277
// begin if building in mc_construct_list [ i ] then
86082: LD_VAR 0 1
86086: PUSH
86087: LD_EXP 66
86091: PUSH
86092: LD_VAR 0 3
86096: ARRAY
86097: IN
86098: IFFALSE 86275
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86100: LD_ADDR_EXP 66
86104: PUSH
86105: LD_EXP 66
86109: PPUSH
86110: LD_VAR 0 3
86114: PPUSH
86115: LD_EXP 66
86119: PUSH
86120: LD_VAR 0 3
86124: ARRAY
86125: PUSH
86126: LD_VAR 0 1
86130: DIFF
86131: PPUSH
86132: CALL_OW 1
86136: ST_TO_ADDR
// if building in mc_lab [ i ] then
86137: LD_VAR 0 1
86141: PUSH
86142: LD_EXP 92
86146: PUSH
86147: LD_VAR 0 3
86151: ARRAY
86152: IN
86153: IFFALSE 86208
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
86155: LD_ADDR_EXP 93
86159: PUSH
86160: LD_EXP 93
86164: PPUSH
86165: LD_VAR 0 3
86169: PPUSH
86170: LD_EXP 93
86174: PUSH
86175: LD_VAR 0 3
86179: ARRAY
86180: PPUSH
86181: LD_INT 1
86183: PPUSH
86184: LD_EXP 93
86188: PUSH
86189: LD_VAR 0 3
86193: ARRAY
86194: PPUSH
86195: LD_INT 0
86197: PPUSH
86198: CALL 20943 0 4
86202: PPUSH
86203: CALL_OW 1
86207: ST_TO_ADDR
// if not building in mc_bases [ i ] then
86208: LD_VAR 0 1
86212: PUSH
86213: LD_EXP 59
86217: PUSH
86218: LD_VAR 0 3
86222: ARRAY
86223: IN
86224: NOT
86225: IFFALSE 86271
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86227: LD_ADDR_EXP 59
86231: PUSH
86232: LD_EXP 59
86236: PPUSH
86237: LD_VAR 0 3
86241: PUSH
86242: LD_EXP 59
86246: PUSH
86247: LD_VAR 0 3
86251: ARRAY
86252: PUSH
86253: LD_INT 1
86255: PLUS
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PPUSH
86261: LD_VAR 0 1
86265: PPUSH
86266: CALL 21525 0 3
86270: ST_TO_ADDR
// exit ;
86271: POP
86272: POP
86273: GO 86279
// end ; end ;
86275: GO 86079
86277: POP
86278: POP
// end ;
86279: LD_VAR 0 2
86283: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86284: LD_INT 0
86286: PPUSH
86287: PPUSH
86288: PPUSH
86289: PPUSH
86290: PPUSH
86291: PPUSH
86292: PPUSH
// if not mc_bases or not skirmish then
86293: LD_EXP 59
86297: NOT
86298: PUSH
86299: LD_EXP 57
86303: NOT
86304: OR
86305: IFFALSE 86309
// exit ;
86307: GO 86970
// for i = 1 to mc_bases do
86309: LD_ADDR_VAR 0 3
86313: PUSH
86314: DOUBLE
86315: LD_INT 1
86317: DEC
86318: ST_TO_ADDR
86319: LD_EXP 59
86323: PUSH
86324: FOR_TO
86325: IFFALSE 86968
// begin if building in mc_construct_list [ i ] then
86327: LD_VAR 0 1
86331: PUSH
86332: LD_EXP 66
86336: PUSH
86337: LD_VAR 0 3
86341: ARRAY
86342: IN
86343: IFFALSE 86966
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86345: LD_ADDR_EXP 66
86349: PUSH
86350: LD_EXP 66
86354: PPUSH
86355: LD_VAR 0 3
86359: PPUSH
86360: LD_EXP 66
86364: PUSH
86365: LD_VAR 0 3
86369: ARRAY
86370: PUSH
86371: LD_VAR 0 1
86375: DIFF
86376: PPUSH
86377: CALL_OW 1
86381: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86382: LD_ADDR_EXP 59
86386: PUSH
86387: LD_EXP 59
86391: PPUSH
86392: LD_VAR 0 3
86396: PUSH
86397: LD_EXP 59
86401: PUSH
86402: LD_VAR 0 3
86406: ARRAY
86407: PUSH
86408: LD_INT 1
86410: PLUS
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PPUSH
86416: LD_VAR 0 1
86420: PPUSH
86421: CALL 21525 0 3
86425: ST_TO_ADDR
// btype := GetBType ( building ) ;
86426: LD_ADDR_VAR 0 5
86430: PUSH
86431: LD_VAR 0 1
86435: PPUSH
86436: CALL_OW 266
86440: ST_TO_ADDR
// side := GetSide ( building ) ;
86441: LD_ADDR_VAR 0 8
86445: PUSH
86446: LD_VAR 0 1
86450: PPUSH
86451: CALL_OW 255
86455: ST_TO_ADDR
// if btype = b_lab then
86456: LD_VAR 0 5
86460: PUSH
86461: LD_INT 6
86463: EQUAL
86464: IFFALSE 86514
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86466: LD_ADDR_EXP 92
86470: PUSH
86471: LD_EXP 92
86475: PPUSH
86476: LD_VAR 0 3
86480: PUSH
86481: LD_EXP 92
86485: PUSH
86486: LD_VAR 0 3
86490: ARRAY
86491: PUSH
86492: LD_INT 1
86494: PLUS
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PPUSH
86500: LD_VAR 0 1
86504: PPUSH
86505: CALL 21525 0 3
86509: ST_TO_ADDR
// exit ;
86510: POP
86511: POP
86512: GO 86970
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86514: LD_VAR 0 5
86518: PUSH
86519: LD_INT 0
86521: PUSH
86522: LD_INT 2
86524: PUSH
86525: LD_INT 4
86527: PUSH
86528: EMPTY
86529: LIST
86530: LIST
86531: LIST
86532: IN
86533: IFFALSE 86657
// begin if btype = b_armoury then
86535: LD_VAR 0 5
86539: PUSH
86540: LD_INT 4
86542: EQUAL
86543: IFFALSE 86553
// btype := b_barracks ;
86545: LD_ADDR_VAR 0 5
86549: PUSH
86550: LD_INT 5
86552: ST_TO_ADDR
// if btype = b_depot then
86553: LD_VAR 0 5
86557: PUSH
86558: LD_INT 0
86560: EQUAL
86561: IFFALSE 86571
// btype := b_warehouse ;
86563: LD_ADDR_VAR 0 5
86567: PUSH
86568: LD_INT 1
86570: ST_TO_ADDR
// if btype = b_workshop then
86571: LD_VAR 0 5
86575: PUSH
86576: LD_INT 2
86578: EQUAL
86579: IFFALSE 86589
// btype := b_factory ;
86581: LD_ADDR_VAR 0 5
86585: PUSH
86586: LD_INT 3
86588: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86589: LD_VAR 0 5
86593: PPUSH
86594: LD_VAR 0 8
86598: PPUSH
86599: CALL_OW 323
86603: PUSH
86604: LD_INT 1
86606: EQUAL
86607: IFFALSE 86653
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86609: LD_ADDR_EXP 91
86613: PUSH
86614: LD_EXP 91
86618: PPUSH
86619: LD_VAR 0 3
86623: PUSH
86624: LD_EXP 91
86628: PUSH
86629: LD_VAR 0 3
86633: ARRAY
86634: PUSH
86635: LD_INT 1
86637: PLUS
86638: PUSH
86639: EMPTY
86640: LIST
86641: LIST
86642: PPUSH
86643: LD_VAR 0 1
86647: PPUSH
86648: CALL 21525 0 3
86652: ST_TO_ADDR
// exit ;
86653: POP
86654: POP
86655: GO 86970
// end ; if btype in [ b_bunker , b_turret ] then
86657: LD_VAR 0 5
86661: PUSH
86662: LD_INT 32
86664: PUSH
86665: LD_INT 33
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: IN
86672: IFFALSE 86962
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86674: LD_ADDR_EXP 67
86678: PUSH
86679: LD_EXP 67
86683: PPUSH
86684: LD_VAR 0 3
86688: PUSH
86689: LD_EXP 67
86693: PUSH
86694: LD_VAR 0 3
86698: ARRAY
86699: PUSH
86700: LD_INT 1
86702: PLUS
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PPUSH
86708: LD_VAR 0 1
86712: PPUSH
86713: CALL 21525 0 3
86717: ST_TO_ADDR
// if btype = b_bunker then
86718: LD_VAR 0 5
86722: PUSH
86723: LD_INT 32
86725: EQUAL
86726: IFFALSE 86962
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86728: LD_ADDR_EXP 68
86732: PUSH
86733: LD_EXP 68
86737: PPUSH
86738: LD_VAR 0 3
86742: PUSH
86743: LD_EXP 68
86747: PUSH
86748: LD_VAR 0 3
86752: ARRAY
86753: PUSH
86754: LD_INT 1
86756: PLUS
86757: PUSH
86758: EMPTY
86759: LIST
86760: LIST
86761: PPUSH
86762: LD_VAR 0 1
86766: PPUSH
86767: CALL 21525 0 3
86771: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86772: LD_ADDR_VAR 0 6
86776: PUSH
86777: LD_EXP 59
86781: PUSH
86782: LD_VAR 0 3
86786: ARRAY
86787: PPUSH
86788: LD_INT 25
86790: PUSH
86791: LD_INT 1
86793: PUSH
86794: EMPTY
86795: LIST
86796: LIST
86797: PUSH
86798: LD_INT 3
86800: PUSH
86801: LD_INT 54
86803: PUSH
86804: EMPTY
86805: LIST
86806: PUSH
86807: EMPTY
86808: LIST
86809: LIST
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PPUSH
86815: CALL_OW 72
86819: ST_TO_ADDR
// if tmp then
86820: LD_VAR 0 6
86824: IFFALSE 86830
// exit ;
86826: POP
86827: POP
86828: GO 86970
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86830: LD_ADDR_VAR 0 6
86834: PUSH
86835: LD_EXP 59
86839: PUSH
86840: LD_VAR 0 3
86844: ARRAY
86845: PPUSH
86846: LD_INT 2
86848: PUSH
86849: LD_INT 30
86851: PUSH
86852: LD_INT 4
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 30
86861: PUSH
86862: LD_INT 5
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: LIST
86873: PPUSH
86874: CALL_OW 72
86878: ST_TO_ADDR
// if not tmp then
86879: LD_VAR 0 6
86883: NOT
86884: IFFALSE 86890
// exit ;
86886: POP
86887: POP
86888: GO 86970
// for j in tmp do
86890: LD_ADDR_VAR 0 4
86894: PUSH
86895: LD_VAR 0 6
86899: PUSH
86900: FOR_IN
86901: IFFALSE 86960
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86903: LD_ADDR_VAR 0 7
86907: PUSH
86908: LD_VAR 0 4
86912: PPUSH
86913: CALL_OW 313
86917: PPUSH
86918: LD_INT 25
86920: PUSH
86921: LD_INT 1
86923: PUSH
86924: EMPTY
86925: LIST
86926: LIST
86927: PPUSH
86928: CALL_OW 72
86932: ST_TO_ADDR
// if units then
86933: LD_VAR 0 7
86937: IFFALSE 86958
// begin ComExitBuilding ( units [ 1 ] ) ;
86939: LD_VAR 0 7
86943: PUSH
86944: LD_INT 1
86946: ARRAY
86947: PPUSH
86948: CALL_OW 122
// exit ;
86952: POP
86953: POP
86954: POP
86955: POP
86956: GO 86970
// end ; end ;
86958: GO 86900
86960: POP
86961: POP
// end ; end ; exit ;
86962: POP
86963: POP
86964: GO 86970
// end ; end ;
86966: GO 86324
86968: POP
86969: POP
// end ;
86970: LD_VAR 0 2
86974: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86975: LD_INT 0
86977: PPUSH
86978: PPUSH
86979: PPUSH
86980: PPUSH
86981: PPUSH
86982: PPUSH
86983: PPUSH
// if not mc_bases or not skirmish then
86984: LD_EXP 59
86988: NOT
86989: PUSH
86990: LD_EXP 57
86994: NOT
86995: OR
86996: IFFALSE 87000
// exit ;
86998: GO 87231
// btype := GetBType ( building ) ;
87000: LD_ADDR_VAR 0 6
87004: PUSH
87005: LD_VAR 0 1
87009: PPUSH
87010: CALL_OW 266
87014: ST_TO_ADDR
// x := GetX ( building ) ;
87015: LD_ADDR_VAR 0 7
87019: PUSH
87020: LD_VAR 0 1
87024: PPUSH
87025: CALL_OW 250
87029: ST_TO_ADDR
// y := GetY ( building ) ;
87030: LD_ADDR_VAR 0 8
87034: PUSH
87035: LD_VAR 0 1
87039: PPUSH
87040: CALL_OW 251
87044: ST_TO_ADDR
// d := GetDir ( building ) ;
87045: LD_ADDR_VAR 0 9
87049: PUSH
87050: LD_VAR 0 1
87054: PPUSH
87055: CALL_OW 254
87059: ST_TO_ADDR
// for i = 1 to mc_bases do
87060: LD_ADDR_VAR 0 4
87064: PUSH
87065: DOUBLE
87066: LD_INT 1
87068: DEC
87069: ST_TO_ADDR
87070: LD_EXP 59
87074: PUSH
87075: FOR_TO
87076: IFFALSE 87229
// begin if not mc_build_list [ i ] then
87078: LD_EXP 64
87082: PUSH
87083: LD_VAR 0 4
87087: ARRAY
87088: NOT
87089: IFFALSE 87093
// continue ;
87091: GO 87075
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
87093: LD_VAR 0 6
87097: PUSH
87098: LD_VAR 0 7
87102: PUSH
87103: LD_VAR 0 8
87107: PUSH
87108: LD_VAR 0 9
87112: PUSH
87113: EMPTY
87114: LIST
87115: LIST
87116: LIST
87117: LIST
87118: PPUSH
87119: LD_EXP 64
87123: PUSH
87124: LD_VAR 0 4
87128: ARRAY
87129: PUSH
87130: LD_INT 1
87132: ARRAY
87133: PPUSH
87134: CALL 27694 0 2
87138: IFFALSE 87227
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
87140: LD_ADDR_EXP 64
87144: PUSH
87145: LD_EXP 64
87149: PPUSH
87150: LD_VAR 0 4
87154: PPUSH
87155: LD_EXP 64
87159: PUSH
87160: LD_VAR 0 4
87164: ARRAY
87165: PPUSH
87166: LD_INT 1
87168: PPUSH
87169: CALL_OW 3
87173: PPUSH
87174: CALL_OW 1
87178: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
87179: LD_ADDR_EXP 66
87183: PUSH
87184: LD_EXP 66
87188: PPUSH
87189: LD_VAR 0 4
87193: PUSH
87194: LD_EXP 66
87198: PUSH
87199: LD_VAR 0 4
87203: ARRAY
87204: PUSH
87205: LD_INT 1
87207: PLUS
87208: PUSH
87209: EMPTY
87210: LIST
87211: LIST
87212: PPUSH
87213: LD_VAR 0 1
87217: PPUSH
87218: CALL 21525 0 3
87222: ST_TO_ADDR
// exit ;
87223: POP
87224: POP
87225: GO 87231
// end ; end ;
87227: GO 87075
87229: POP
87230: POP
// end ;
87231: LD_VAR 0 3
87235: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
87236: LD_INT 0
87238: PPUSH
87239: PPUSH
87240: PPUSH
// if not mc_bases or not skirmish then
87241: LD_EXP 59
87245: NOT
87246: PUSH
87247: LD_EXP 57
87251: NOT
87252: OR
87253: IFFALSE 87257
// exit ;
87255: GO 87447
// for i = 1 to mc_bases do
87257: LD_ADDR_VAR 0 4
87261: PUSH
87262: DOUBLE
87263: LD_INT 1
87265: DEC
87266: ST_TO_ADDR
87267: LD_EXP 59
87271: PUSH
87272: FOR_TO
87273: IFFALSE 87360
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87275: LD_VAR 0 1
87279: PUSH
87280: LD_EXP 67
87284: PUSH
87285: LD_VAR 0 4
87289: ARRAY
87290: IN
87291: PUSH
87292: LD_VAR 0 1
87296: PUSH
87297: LD_EXP 68
87301: PUSH
87302: LD_VAR 0 4
87306: ARRAY
87307: IN
87308: NOT
87309: AND
87310: IFFALSE 87358
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87312: LD_ADDR_EXP 68
87316: PUSH
87317: LD_EXP 68
87321: PPUSH
87322: LD_VAR 0 4
87326: PUSH
87327: LD_EXP 68
87331: PUSH
87332: LD_VAR 0 4
87336: ARRAY
87337: PUSH
87338: LD_INT 1
87340: PLUS
87341: PUSH
87342: EMPTY
87343: LIST
87344: LIST
87345: PPUSH
87346: LD_VAR 0 1
87350: PPUSH
87351: CALL 21525 0 3
87355: ST_TO_ADDR
// break ;
87356: GO 87360
// end ; end ;
87358: GO 87272
87360: POP
87361: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87362: LD_VAR 0 1
87366: PPUSH
87367: CALL_OW 257
87371: PUSH
87372: LD_EXP 85
87376: IN
87377: PUSH
87378: LD_VAR 0 1
87382: PPUSH
87383: CALL_OW 266
87387: PUSH
87388: LD_INT 5
87390: EQUAL
87391: AND
87392: PUSH
87393: LD_VAR 0 2
87397: PPUSH
87398: CALL_OW 110
87402: PUSH
87403: LD_INT 18
87405: NONEQUAL
87406: AND
87407: IFFALSE 87447
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87409: LD_VAR 0 2
87413: PPUSH
87414: CALL_OW 257
87418: PUSH
87419: LD_INT 5
87421: PUSH
87422: LD_INT 8
87424: PUSH
87425: LD_INT 9
87427: PUSH
87428: EMPTY
87429: LIST
87430: LIST
87431: LIST
87432: IN
87433: IFFALSE 87447
// SetClass ( unit , 1 ) ;
87435: LD_VAR 0 2
87439: PPUSH
87440: LD_INT 1
87442: PPUSH
87443: CALL_OW 336
// end ;
87447: LD_VAR 0 3
87451: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87452: LD_INT 0
87454: PPUSH
87455: PPUSH
// if not mc_bases or not skirmish then
87456: LD_EXP 59
87460: NOT
87461: PUSH
87462: LD_EXP 57
87466: NOT
87467: OR
87468: IFFALSE 87472
// exit ;
87470: GO 87588
// if GetLives ( abandoned_vehicle ) > 250 then
87472: LD_VAR 0 2
87476: PPUSH
87477: CALL_OW 256
87481: PUSH
87482: LD_INT 250
87484: GREATER
87485: IFFALSE 87489
// exit ;
87487: GO 87588
// for i = 1 to mc_bases do
87489: LD_ADDR_VAR 0 6
87493: PUSH
87494: DOUBLE
87495: LD_INT 1
87497: DEC
87498: ST_TO_ADDR
87499: LD_EXP 59
87503: PUSH
87504: FOR_TO
87505: IFFALSE 87586
// begin if driver in mc_bases [ i ] then
87507: LD_VAR 0 1
87511: PUSH
87512: LD_EXP 59
87516: PUSH
87517: LD_VAR 0 6
87521: ARRAY
87522: IN
87523: IFFALSE 87584
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87525: LD_VAR 0 1
87529: PPUSH
87530: LD_EXP 59
87534: PUSH
87535: LD_VAR 0 6
87539: ARRAY
87540: PPUSH
87541: LD_INT 2
87543: PUSH
87544: LD_INT 30
87546: PUSH
87547: LD_INT 0
87549: PUSH
87550: EMPTY
87551: LIST
87552: LIST
87553: PUSH
87554: LD_INT 30
87556: PUSH
87557: LD_INT 1
87559: PUSH
87560: EMPTY
87561: LIST
87562: LIST
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: LIST
87568: PPUSH
87569: CALL_OW 72
87573: PUSH
87574: LD_INT 1
87576: ARRAY
87577: PPUSH
87578: CALL_OW 112
// break ;
87582: GO 87586
// end ; end ;
87584: GO 87504
87586: POP
87587: POP
// end ; end_of_file
87588: LD_VAR 0 5
87592: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
87593: GO 87595
87595: DISABLE
// begin ru_radar := 98 ;
87596: LD_ADDR_EXP 102
87600: PUSH
87601: LD_INT 98
87603: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87604: LD_ADDR_EXP 103
87608: PUSH
87609: LD_INT 89
87611: ST_TO_ADDR
// us_hack := 99 ;
87612: LD_ADDR_EXP 104
87616: PUSH
87617: LD_INT 99
87619: ST_TO_ADDR
// us_artillery := 97 ;
87620: LD_ADDR_EXP 105
87624: PUSH
87625: LD_INT 97
87627: ST_TO_ADDR
// ar_bio_bomb := 91 ;
87628: LD_ADDR_EXP 106
87632: PUSH
87633: LD_INT 91
87635: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
87636: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
87637: LD_INT 0
87639: PPUSH
87640: PPUSH
87641: PPUSH
87642: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
87643: LD_VAR 0 1
87647: PPUSH
87648: CALL_OW 264
87652: PUSH
87653: LD_EXP 106
87657: EQUAL
87658: IFFALSE 87730
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
87660: LD_INT 68
87662: PPUSH
87663: LD_VAR 0 1
87667: PPUSH
87668: CALL_OW 255
87672: PPUSH
87673: CALL_OW 321
87677: PUSH
87678: LD_INT 2
87680: EQUAL
87681: IFFALSE 87693
// eff := 70 else
87683: LD_ADDR_VAR 0 6
87687: PUSH
87688: LD_INT 70
87690: ST_TO_ADDR
87691: GO 87701
// eff := 30 ;
87693: LD_ADDR_VAR 0 6
87697: PUSH
87698: LD_INT 30
87700: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
87701: LD_VAR 0 1
87705: PPUSH
87706: CALL_OW 250
87710: PPUSH
87711: LD_VAR 0 1
87715: PPUSH
87716: CALL_OW 251
87720: PPUSH
87721: LD_VAR 0 6
87725: PPUSH
87726: CALL_OW 495
// end ; end ;
87730: LD_VAR 0 4
87734: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
87735: LD_INT 0
87737: PPUSH
87738: PPUSH
87739: PPUSH
87740: PPUSH
87741: PPUSH
87742: PPUSH
// if cmd = 124 then
87743: LD_VAR 0 1
87747: PUSH
87748: LD_INT 124
87750: EQUAL
87751: IFFALSE 87957
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
87753: LD_ADDR_VAR 0 5
87757: PUSH
87758: LD_INT 2
87760: PUSH
87761: LD_INT 34
87763: PUSH
87764: LD_INT 53
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 34
87773: PUSH
87774: LD_INT 14
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: EMPTY
87782: LIST
87783: LIST
87784: LIST
87785: PPUSH
87786: CALL_OW 69
87790: ST_TO_ADDR
// if not tmp then
87791: LD_VAR 0 5
87795: NOT
87796: IFFALSE 87800
// exit ;
87798: GO 87957
// for i in tmp do
87800: LD_ADDR_VAR 0 3
87804: PUSH
87805: LD_VAR 0 5
87809: PUSH
87810: FOR_IN
87811: IFFALSE 87955
// begin taskList := GetTaskList ( i ) ;
87813: LD_ADDR_VAR 0 6
87817: PUSH
87818: LD_VAR 0 3
87822: PPUSH
87823: CALL_OW 437
87827: ST_TO_ADDR
// if not taskList then
87828: LD_VAR 0 6
87832: NOT
87833: IFFALSE 87837
// continue ;
87835: GO 87810
// for j = 1 to taskList do
87837: LD_ADDR_VAR 0 4
87841: PUSH
87842: DOUBLE
87843: LD_INT 1
87845: DEC
87846: ST_TO_ADDR
87847: LD_VAR 0 6
87851: PUSH
87852: FOR_TO
87853: IFFALSE 87951
// if taskList [ j ] [ 1 ] = | then
87855: LD_VAR 0 6
87859: PUSH
87860: LD_VAR 0 4
87864: ARRAY
87865: PUSH
87866: LD_INT 1
87868: ARRAY
87869: PUSH
87870: LD_STRING |
87872: EQUAL
87873: IFFALSE 87949
// begin _taskList := Delete ( taskList , 1 ) ;
87875: LD_ADDR_VAR 0 7
87879: PUSH
87880: LD_VAR 0 6
87884: PPUSH
87885: LD_INT 1
87887: PPUSH
87888: CALL_OW 3
87892: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
87893: LD_VAR 0 3
87897: PPUSH
87898: LD_VAR 0 7
87902: PPUSH
87903: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
87907: LD_VAR 0 3
87911: PPUSH
87912: LD_VAR 0 6
87916: PUSH
87917: LD_VAR 0 4
87921: ARRAY
87922: PUSH
87923: LD_INT 2
87925: ARRAY
87926: PPUSH
87927: LD_VAR 0 6
87931: PUSH
87932: LD_VAR 0 4
87936: ARRAY
87937: PUSH
87938: LD_INT 3
87940: ARRAY
87941: PPUSH
87942: LD_INT 8
87944: PPUSH
87945: CALL 87962 0 4
// end ;
87949: GO 87852
87951: POP
87952: POP
// end ;
87953: GO 87810
87955: POP
87956: POP
// end ; end ;
87957: LD_VAR 0 2
87961: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87962: LD_INT 0
87964: PPUSH
87965: PPUSH
87966: PPUSH
87967: PPUSH
87968: PPUSH
87969: PPUSH
87970: PPUSH
87971: PPUSH
87972: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87973: LD_VAR 0 1
87977: NOT
87978: PUSH
87979: LD_VAR 0 2
87983: PPUSH
87984: LD_VAR 0 3
87988: PPUSH
87989: CALL_OW 488
87993: NOT
87994: OR
87995: PUSH
87996: LD_VAR 0 4
88000: NOT
88001: OR
88002: IFFALSE 88006
// exit ;
88004: GO 88346
// list := [ ] ;
88006: LD_ADDR_VAR 0 13
88010: PUSH
88011: EMPTY
88012: ST_TO_ADDR
// if x - r < 0 then
88013: LD_VAR 0 2
88017: PUSH
88018: LD_VAR 0 4
88022: MINUS
88023: PUSH
88024: LD_INT 0
88026: LESS
88027: IFFALSE 88039
// min_x := 0 else
88029: LD_ADDR_VAR 0 7
88033: PUSH
88034: LD_INT 0
88036: ST_TO_ADDR
88037: GO 88055
// min_x := x - r ;
88039: LD_ADDR_VAR 0 7
88043: PUSH
88044: LD_VAR 0 2
88048: PUSH
88049: LD_VAR 0 4
88053: MINUS
88054: ST_TO_ADDR
// if y - r < 0 then
88055: LD_VAR 0 3
88059: PUSH
88060: LD_VAR 0 4
88064: MINUS
88065: PUSH
88066: LD_INT 0
88068: LESS
88069: IFFALSE 88081
// min_y := 0 else
88071: LD_ADDR_VAR 0 8
88075: PUSH
88076: LD_INT 0
88078: ST_TO_ADDR
88079: GO 88097
// min_y := y - r ;
88081: LD_ADDR_VAR 0 8
88085: PUSH
88086: LD_VAR 0 3
88090: PUSH
88091: LD_VAR 0 4
88095: MINUS
88096: ST_TO_ADDR
// max_x := x + r ;
88097: LD_ADDR_VAR 0 9
88101: PUSH
88102: LD_VAR 0 2
88106: PUSH
88107: LD_VAR 0 4
88111: PLUS
88112: ST_TO_ADDR
// max_y := y + r ;
88113: LD_ADDR_VAR 0 10
88117: PUSH
88118: LD_VAR 0 3
88122: PUSH
88123: LD_VAR 0 4
88127: PLUS
88128: ST_TO_ADDR
// for _x = min_x to max_x do
88129: LD_ADDR_VAR 0 11
88133: PUSH
88134: DOUBLE
88135: LD_VAR 0 7
88139: DEC
88140: ST_TO_ADDR
88141: LD_VAR 0 9
88145: PUSH
88146: FOR_TO
88147: IFFALSE 88264
// for _y = min_y to max_y do
88149: LD_ADDR_VAR 0 12
88153: PUSH
88154: DOUBLE
88155: LD_VAR 0 8
88159: DEC
88160: ST_TO_ADDR
88161: LD_VAR 0 10
88165: PUSH
88166: FOR_TO
88167: IFFALSE 88260
// begin if not ValidHex ( _x , _y ) then
88169: LD_VAR 0 11
88173: PPUSH
88174: LD_VAR 0 12
88178: PPUSH
88179: CALL_OW 488
88183: NOT
88184: IFFALSE 88188
// continue ;
88186: GO 88166
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
88188: LD_VAR 0 11
88192: PPUSH
88193: LD_VAR 0 12
88197: PPUSH
88198: CALL_OW 351
88202: PUSH
88203: LD_VAR 0 11
88207: PPUSH
88208: LD_VAR 0 12
88212: PPUSH
88213: CALL_OW 554
88217: AND
88218: IFFALSE 88258
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
88220: LD_ADDR_VAR 0 13
88224: PUSH
88225: LD_VAR 0 13
88229: PPUSH
88230: LD_VAR 0 13
88234: PUSH
88235: LD_INT 1
88237: PLUS
88238: PPUSH
88239: LD_VAR 0 11
88243: PUSH
88244: LD_VAR 0 12
88248: PUSH
88249: EMPTY
88250: LIST
88251: LIST
88252: PPUSH
88253: CALL_OW 2
88257: ST_TO_ADDR
// end ;
88258: GO 88166
88260: POP
88261: POP
88262: GO 88146
88264: POP
88265: POP
// if not list then
88266: LD_VAR 0 13
88270: NOT
88271: IFFALSE 88275
// exit ;
88273: GO 88346
// for i in list do
88275: LD_ADDR_VAR 0 6
88279: PUSH
88280: LD_VAR 0 13
88284: PUSH
88285: FOR_IN
88286: IFFALSE 88344
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
88288: LD_VAR 0 1
88292: PPUSH
88293: LD_STRING M
88295: PUSH
88296: LD_VAR 0 6
88300: PUSH
88301: LD_INT 1
88303: ARRAY
88304: PUSH
88305: LD_VAR 0 6
88309: PUSH
88310: LD_INT 2
88312: ARRAY
88313: PUSH
88314: LD_INT 0
88316: PUSH
88317: LD_INT 0
88319: PUSH
88320: LD_INT 0
88322: PUSH
88323: LD_INT 0
88325: PUSH
88326: EMPTY
88327: LIST
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: PUSH
88335: EMPTY
88336: LIST
88337: PPUSH
88338: CALL_OW 447
88342: GO 88285
88344: POP
88345: POP
// end ;
88346: LD_VAR 0 5
88350: RET
