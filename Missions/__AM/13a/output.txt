// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 59275 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 50868 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 50868 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 50868 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 50868 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4572 0 0
// PrepareRussian ;
 189: CALL 2997 0 0
// PrepareAlliance ;
 193: CALL 919 0 0
// MC_Start ( ) ;
 197: CALL 61455 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 8546 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 86
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 87
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 83172 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 57
 294: PPUSH
 295: CALL 83617 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 84075 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 84344 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 83557 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 84251 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 54
 401: PPUSH
 402: CALL 83617 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 84075 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 84344 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 83401 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 84662 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 83557 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , ru_active_attack , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 7
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 8
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 55
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 9
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 10
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ru_active_attack := true ;
 775: LD_ADDR_EXP 6
 779: PUSH
 780: LD_INT 1
 782: ST_TO_ADDR
// ar_attackers := [ ] ;
 783: LD_ADDR_EXP 12
 787: PUSH
 788: EMPTY
 789: ST_TO_ADDR
// first_powell_attack := false ;
 790: LD_ADDR_EXP 13
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// masha_killed := false ;
 798: LD_ADDR_EXP 11
 802: PUSH
 803: LD_INT 0
 805: ST_TO_ADDR
// abdul_escaped := true ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 1
 813: ST_TO_ADDR
// loss_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// hack_counter := 0 ;
 822: LD_ADDR_EXP 16
 826: PUSH
 827: LD_INT 0
 829: ST_TO_ADDR
// end ;
 830: LD_VAR 0 1
 834: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 835: LD_EXP 51
 839: PPUSH
 840: CALL_OW 255
 844: PUSH
 845: LD_INT 7
 847: EQUAL
 848: PUSH
 849: LD_EXP 50
 853: PPUSH
 854: CALL_OW 255
 858: PUSH
 859: LD_INT 7
 861: EQUAL
 862: AND
 863: PUSH
 864: LD_EXP 51
 868: PPUSH
 869: CALL_OW 302
 873: AND
 874: PUSH
 875: LD_EXP 50
 879: PPUSH
 880: CALL_OW 302
 884: AND
 885: IFFALSE 897
 887: GO 889
 889: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 890: LD_STRING ACH_COMRADE
 892: PPUSH
 893: CALL_OW 543
 897: END
// every 0 0$1 trigger hack_counter >= 10 do
 898: LD_EXP 16
 902: PUSH
 903: LD_INT 10
 905: GREATEREQUAL
 906: IFFALSE 918
 908: GO 910
 910: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 911: LD_STRING ACH_HACK
 913: PPUSH
 914: CALL_OW 543
 918: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 919: LD_INT 0
 921: PPUSH
 922: PPUSH
 923: PPUSH
 924: PPUSH
// uc_side := 7 ;
 925: LD_ADDR_OWVAR 20
 929: PUSH
 930: LD_INT 7
 932: ST_TO_ADDR
// uc_nation := 1 ;
 933: LD_ADDR_OWVAR 21
 937: PUSH
 938: LD_INT 1
 940: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING JMM
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 16500 0 3
 962: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 963: LD_EXP 17
 967: PPUSH
 968: LD_INT 71
 970: PPUSH
 971: LD_INT 23
 973: PPUSH
 974: LD_INT 0
 976: PPUSH
 977: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 981: LD_EXP 17
 985: PPUSH
 986: LD_INT 2
 988: PPUSH
 989: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 993: LD_ADDR_EXP 18
 997: PUSH
 998: LD_STRING Roth
1000: PPUSH
1001: LD_EXP 1
1005: NOT
1006: PPUSH
1007: LD_STRING 12a_
1009: PPUSH
1010: CALL 16500 0 3
1014: ST_TO_ADDR
// if Roth then
1015: LD_EXP 18
1019: IFFALSE 1039
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1021: LD_EXP 18
1025: PPUSH
1026: LD_INT 71
1028: PPUSH
1029: LD_INT 21
1031: PPUSH
1032: LD_INT 0
1034: PPUSH
1035: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1039: LD_ADDR_EXP 34
1043: PUSH
1044: LD_STRING Mike
1046: PPUSH
1047: LD_EXP 1
1051: NOT
1052: PPUSH
1053: LD_STRING 12a_
1055: PPUSH
1056: CALL 16500 0 3
1060: ST_TO_ADDR
// if Mike then
1061: LD_EXP 34
1065: IFFALSE 1082
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1067: LD_EXP 34
1071: PPUSH
1072: LD_INT 13
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1082: LD_ADDR_EXP 19
1086: PUSH
1087: LD_STRING Lisa
1089: PPUSH
1090: LD_EXP 1
1094: NOT
1095: PPUSH
1096: LD_STRING 12a_
1098: PPUSH
1099: CALL 16500 0 3
1103: ST_TO_ADDR
// if Lisa then
1104: LD_EXP 19
1108: IFFALSE 1125
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1110: LD_EXP 19
1114: PPUSH
1115: LD_INT 13
1117: PPUSH
1118: LD_INT 0
1120: PPUSH
1121: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1125: LD_ADDR_EXP 20
1129: PUSH
1130: LD_STRING Donaldson
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_STRING 12a_
1141: PPUSH
1142: CALL 16500 0 3
1146: ST_TO_ADDR
// if Donaldson then
1147: LD_EXP 20
1151: IFFALSE 1168
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1153: LD_EXP 20
1157: PPUSH
1158: LD_INT 13
1160: PPUSH
1161: LD_INT 0
1163: PPUSH
1164: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1168: LD_ADDR_EXP 21
1172: PUSH
1173: LD_STRING Bobby
1175: PPUSH
1176: LD_EXP 1
1180: NOT
1181: PPUSH
1182: LD_STRING 12a_
1184: PPUSH
1185: CALL 16500 0 3
1189: ST_TO_ADDR
// if Bobby then
1190: LD_EXP 21
1194: IFFALSE 1211
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1196: LD_EXP 21
1200: PPUSH
1201: LD_INT 13
1203: PPUSH
1204: LD_INT 0
1206: PPUSH
1207: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1211: LD_ADDR_EXP 22
1215: PUSH
1216: LD_STRING Cyrus
1218: PPUSH
1219: LD_EXP 1
1223: NOT
1224: PPUSH
1225: LD_STRING 12a_
1227: PPUSH
1228: CALL 16500 0 3
1232: ST_TO_ADDR
// if Cyrus then
1233: LD_EXP 22
1237: IFFALSE 1254
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1239: LD_EXP 22
1243: PPUSH
1244: LD_INT 13
1246: PPUSH
1247: LD_INT 0
1249: PPUSH
1250: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1254: LD_ADDR_EXP 23
1258: PUSH
1259: LD_STRING Denis
1261: PPUSH
1262: LD_EXP 1
1266: NOT
1267: PPUSH
1268: LD_STRING 12a_
1270: PPUSH
1271: CALL 16500 0 3
1275: ST_TO_ADDR
// if Denis then
1276: LD_EXP 23
1280: IFFALSE 1297
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1282: LD_EXP 23
1286: PPUSH
1287: LD_INT 13
1289: PPUSH
1290: LD_INT 0
1292: PPUSH
1293: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1297: LD_ADDR_EXP 24
1301: PUSH
1302: LD_STRING Brown
1304: PPUSH
1305: LD_EXP 1
1309: NOT
1310: PPUSH
1311: LD_STRING 12a_
1313: PPUSH
1314: CALL 16500 0 3
1318: ST_TO_ADDR
// if Brown then
1319: LD_EXP 24
1323: IFFALSE 1340
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1325: LD_EXP 24
1329: PPUSH
1330: LD_INT 13
1332: PPUSH
1333: LD_INT 0
1335: PPUSH
1336: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1340: LD_ADDR_EXP 25
1344: PUSH
1345: LD_STRING Gladstone
1347: PPUSH
1348: LD_EXP 1
1352: NOT
1353: PPUSH
1354: LD_STRING 12a_
1356: PPUSH
1357: CALL 16500 0 3
1361: ST_TO_ADDR
// if Gladstone then
1362: LD_EXP 25
1366: IFFALSE 1383
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1368: LD_EXP 25
1372: PPUSH
1373: LD_INT 13
1375: PPUSH
1376: LD_INT 0
1378: PPUSH
1379: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1383: LD_ADDR_EXP 26
1387: PUSH
1388: LD_STRING Houten
1390: PPUSH
1391: LD_EXP 1
1395: NOT
1396: PPUSH
1397: LD_STRING 12a_
1399: PPUSH
1400: CALL 16500 0 3
1404: ST_TO_ADDR
// if Houten then
1405: LD_EXP 26
1409: IFFALSE 1426
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1411: LD_EXP 26
1415: PPUSH
1416: LD_INT 13
1418: PPUSH
1419: LD_INT 0
1421: PPUSH
1422: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1426: LD_ADDR_EXP 27
1430: PUSH
1431: LD_STRING Cornell
1433: PPUSH
1434: LD_EXP 1
1438: NOT
1439: PPUSH
1440: LD_STRING 12a_
1442: PPUSH
1443: CALL 16500 0 3
1447: ST_TO_ADDR
// if Cornel then
1448: LD_EXP 27
1452: IFFALSE 1469
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1454: LD_EXP 27
1458: PPUSH
1459: LD_INT 13
1461: PPUSH
1462: LD_INT 0
1464: PPUSH
1465: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1469: LD_ADDR_EXP 28
1473: PUSH
1474: LD_STRING Gary
1476: PPUSH
1477: LD_EXP 1
1481: NOT
1482: PPUSH
1483: LD_STRING 12a_
1485: PPUSH
1486: CALL 16500 0 3
1490: ST_TO_ADDR
// if Gary then
1491: LD_EXP 28
1495: IFFALSE 1512
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1497: LD_EXP 28
1501: PPUSH
1502: LD_INT 13
1504: PPUSH
1505: LD_INT 0
1507: PPUSH
1508: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1512: LD_ADDR_EXP 29
1516: PUSH
1517: LD_STRING Frank
1519: PPUSH
1520: LD_EXP 1
1524: NOT
1525: PPUSH
1526: LD_STRING 12a_
1528: PPUSH
1529: CALL 16500 0 3
1533: ST_TO_ADDR
// if Frank then
1534: LD_EXP 29
1538: IFFALSE 1555
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1540: LD_EXP 29
1544: PPUSH
1545: LD_INT 13
1547: PPUSH
1548: LD_INT 0
1550: PPUSH
1551: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1555: LD_ADDR_EXP 30
1559: PUSH
1560: LD_STRING Kikuchi
1562: PPUSH
1563: LD_EXP 1
1567: NOT
1568: PPUSH
1569: LD_STRING 12a_
1571: PPUSH
1572: CALL 16500 0 3
1576: ST_TO_ADDR
// if Kikuchi then
1577: LD_EXP 30
1581: IFFALSE 1598
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1583: LD_EXP 30
1587: PPUSH
1588: LD_INT 13
1590: PPUSH
1591: LD_INT 0
1593: PPUSH
1594: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1598: LD_ADDR_EXP 31
1602: PUSH
1603: LD_STRING Simms
1605: PPUSH
1606: LD_EXP 1
1610: NOT
1611: PPUSH
1612: LD_STRING 12a_
1614: PPUSH
1615: CALL 16500 0 3
1619: ST_TO_ADDR
// if Simms then
1620: LD_EXP 31
1624: IFFALSE 1641
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1626: LD_EXP 31
1630: PPUSH
1631: LD_INT 13
1633: PPUSH
1634: LD_INT 0
1636: PPUSH
1637: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1641: LD_ADDR_EXP 32
1645: PUSH
1646: LD_STRING Joan
1648: PPUSH
1649: LD_EXP 1
1653: NOT
1654: PPUSH
1655: LD_STRING 12a_
1657: PPUSH
1658: CALL 16500 0 3
1662: ST_TO_ADDR
// if Joan then
1663: LD_EXP 32
1667: IFFALSE 1684
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1669: LD_EXP 32
1673: PPUSH
1674: LD_INT 13
1676: PPUSH
1677: LD_INT 0
1679: PPUSH
1680: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1684: LD_ADDR_EXP 33
1688: PUSH
1689: LD_STRING DeltaDoctor
1691: PPUSH
1692: LD_EXP 1
1696: NOT
1697: PPUSH
1698: LD_STRING 12a_
1700: PPUSH
1701: CALL 16500 0 3
1705: ST_TO_ADDR
// if DeltaDoctor then
1706: LD_EXP 33
1710: IFFALSE 1727
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1712: LD_EXP 33
1716: PPUSH
1717: LD_INT 13
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1727: LD_ADDR_VAR 0 4
1731: PUSH
1732: LD_STRING 12a_others
1734: PPUSH
1735: CALL_OW 31
1739: ST_TO_ADDR
// if tmp then
1740: LD_VAR 0 4
1744: IFFALSE 1778
// for i in tmp do
1746: LD_ADDR_VAR 0 3
1750: PUSH
1751: LD_VAR 0 4
1755: PUSH
1756: FOR_IN
1757: IFFALSE 1776
// PlaceUnitArea ( i , alliance_start , false ) ;
1759: LD_VAR 0 3
1763: PPUSH
1764: LD_INT 13
1766: PPUSH
1767: LD_INT 0
1769: PPUSH
1770: CALL_OW 49
1774: GO 1756
1776: POP
1777: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1778: LD_INT 3
1780: PPUSH
1781: LD_INT 3
1783: PPUSH
1784: LD_INT 3
1786: PPUSH
1787: LD_INT 12
1789: PPUSH
1790: LD_INT 100
1792: PPUSH
1793: CALL 21340 0 5
// veh := CreateVehicle ;
1797: LD_ADDR_VAR 0 2
1801: PUSH
1802: CALL_OW 45
1806: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1807: LD_VAR 0 2
1811: PPUSH
1812: LD_INT 2
1814: PPUSH
1815: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1819: LD_VAR 0 2
1823: PPUSH
1824: LD_INT 60
1826: PPUSH
1827: LD_INT 6
1829: PPUSH
1830: LD_INT 0
1832: PPUSH
1833: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1837: LD_VAR 0 2
1841: PPUSH
1842: LD_INT 4
1844: PPUSH
1845: LD_INT 30
1847: PPUSH
1848: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1852: LD_STRING 11_artifact_captured
1854: PPUSH
1855: LD_INT 0
1857: PPUSH
1858: CALL_OW 30
1862: IFFALSE 1938
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1864: LD_INT 3
1866: PPUSH
1867: LD_INT 3
1869: PPUSH
1870: LD_INT 3
1872: PPUSH
1873: LD_INT 12
1875: PPUSH
1876: LD_INT 100
1878: PPUSH
1879: CALL 21340 0 5
// veh := CreateVehicle ;
1883: LD_ADDR_VAR 0 2
1887: PUSH
1888: CALL_OW 45
1892: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1893: LD_VAR 0 2
1897: PPUSH
1898: LD_INT 3
1900: PPUSH
1901: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1905: LD_VAR 0 2
1909: PPUSH
1910: LD_INT 75
1912: PPUSH
1913: LD_INT 6
1915: PPUSH
1916: LD_INT 0
1918: PPUSH
1919: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1923: LD_VAR 0 2
1927: PPUSH
1928: LD_INT 4
1930: PPUSH
1931: LD_INT 50
1933: PPUSH
1934: CALL_OW 290
// end ; end ;
1938: LD_VAR 0 1
1942: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1943: LD_INT 0
1945: PPUSH
1946: PPUSH
1947: PPUSH
1948: PPUSH
// uc_side := 6 ;
1949: LD_ADDR_OWVAR 20
1953: PUSH
1954: LD_INT 6
1956: ST_TO_ADDR
// uc_nation := 3 ;
1957: LD_ADDR_OWVAR 21
1961: PUSH
1962: LD_INT 3
1964: ST_TO_ADDR
// InitHc ;
1965: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1969: LD_ADDR_EXP 35
1973: PUSH
1974: LD_STRING Gossudarov
1976: PPUSH
1977: CALL_OW 25
1981: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1982: LD_ADDR_EXP 36
1986: PUSH
1987: LD_STRING Kirilenkova
1989: PPUSH
1990: CALL_OW 25
1994: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1995: LD_ADDR_EXP 37
1999: PUSH
2000: LD_STRING Titov
2002: PPUSH
2003: CALL_OW 25
2007: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2008: LD_ADDR_EXP 42
2012: PUSH
2013: LD_STRING Oblukov
2015: PPUSH
2016: CALL_OW 25
2020: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2021: LD_ADDR_EXP 39
2025: PUSH
2026: LD_STRING Dolgov
2028: PPUSH
2029: CALL_OW 25
2033: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2034: LD_ADDR_EXP 40
2038: PUSH
2039: LD_STRING Petrosyan
2041: PPUSH
2042: CALL_OW 25
2046: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2047: LD_ADDR_EXP 41
2051: PUSH
2052: LD_STRING Scholtze
2054: PPUSH
2055: CALL_OW 25
2059: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2060: LD_ADDR_EXP 43
2064: PUSH
2065: LD_STRING Kapitsova
2067: PPUSH
2068: CALL_OW 25
2072: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2073: LD_ADDR_VAR 0 2
2077: PUSH
2078: LD_EXP 35
2082: PUSH
2083: LD_EXP 36
2087: PUSH
2088: LD_EXP 37
2092: PUSH
2093: LD_EXP 42
2097: PUSH
2098: LD_EXP 39
2102: PUSH
2103: LD_EXP 40
2107: PUSH
2108: LD_EXP 41
2112: PUSH
2113: LD_EXP 43
2117: PUSH
2118: EMPTY
2119: LIST
2120: LIST
2121: LIST
2122: LIST
2123: LIST
2124: LIST
2125: LIST
2126: LIST
2127: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2128: LD_INT 1
2130: PPUSH
2131: LD_INT 4
2133: PPUSH
2134: LD_INT 8
2136: PPUSH
2137: CALL_OW 380
// un := CreateHuman ;
2141: LD_ADDR_VAR 0 4
2145: PUSH
2146: CALL_OW 44
2150: ST_TO_ADDR
// tmp := tmp ^ un ;
2151: LD_ADDR_VAR 0 2
2155: PUSH
2156: LD_VAR 0 2
2160: PUSH
2161: LD_VAR 0 4
2165: ADD
2166: ST_TO_ADDR
// for i in tmp do
2167: LD_ADDR_VAR 0 3
2171: PUSH
2172: LD_VAR 0 2
2176: PUSH
2177: FOR_IN
2178: IFFALSE 2197
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2180: LD_VAR 0 3
2184: PPUSH
2185: LD_INT 14
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 49
2195: GO 2177
2197: POP
2198: POP
// if freedom then
2199: LD_EXP 3
2203: IFFALSE 2236
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2205: LD_VAR 0 2
2209: PPUSH
2210: LD_EXP 3
2214: PPUSH
2215: CALL_OW 250
2219: PPUSH
2220: LD_EXP 3
2224: PPUSH
2225: CALL_OW 251
2229: PPUSH
2230: CALL_OW 111
2234: GO 2251
// ComMoveXY ( tmp , 70 , 48 ) ;
2236: LD_VAR 0 2
2240: PPUSH
2241: LD_INT 70
2243: PPUSH
2244: LD_INT 48
2246: PPUSH
2247: CALL_OW 111
// end ;
2251: LD_VAR 0 1
2255: RET
// export function PrepareBelkov ; begin
2256: LD_INT 0
2258: PPUSH
// uc_side := 4 ;
2259: LD_ADDR_OWVAR 20
2263: PUSH
2264: LD_INT 4
2266: ST_TO_ADDR
// uc_nation := 3 ;
2267: LD_ADDR_OWVAR 21
2271: PUSH
2272: LD_INT 3
2274: ST_TO_ADDR
// InitHc ;
2275: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2279: LD_ADDR_EXP 50
2283: PUSH
2284: LD_STRING Belkov
2286: PPUSH
2287: CALL_OW 25
2291: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2292: LD_EXP 50
2296: PPUSH
2297: LD_INT 14
2299: PPUSH
2300: LD_INT 0
2302: PPUSH
2303: CALL_OW 49
// end ;
2307: LD_VAR 0 1
2311: RET
// export function PrepareGnyevko ; begin
2312: LD_INT 0
2314: PPUSH
// uc_side := 4 ;
2315: LD_ADDR_OWVAR 20
2319: PUSH
2320: LD_INT 4
2322: ST_TO_ADDR
// uc_nation := 3 ;
2323: LD_ADDR_OWVAR 21
2327: PUSH
2328: LD_INT 3
2330: ST_TO_ADDR
// InitHc ;
2331: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2335: LD_ADDR_EXP 51
2339: PUSH
2340: LD_STRING Gnyevko
2342: PPUSH
2343: CALL_OW 25
2347: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2348: LD_EXP 51
2352: PPUSH
2353: LD_INT 14
2355: PPUSH
2356: LD_INT 0
2358: PPUSH
2359: CALL_OW 49
// end ;
2363: LD_VAR 0 1
2367: RET
// export function PrepareBurlak ; var i , tmp ; begin
2368: LD_INT 0
2370: PPUSH
2371: PPUSH
2372: PPUSH
// uc_side := 4 ;
2373: LD_ADDR_OWVAR 20
2377: PUSH
2378: LD_INT 4
2380: ST_TO_ADDR
// uc_nation := 3 ;
2381: LD_ADDR_OWVAR 21
2385: PUSH
2386: LD_INT 3
2388: ST_TO_ADDR
// InitHc ;
2389: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2393: LD_ADDR_EXP 49
2397: PUSH
2398: LD_STRING Burlak
2400: PPUSH
2401: CALL_OW 25
2405: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2406: LD_INT 24
2408: PUSH
2409: LD_INT 23
2411: PUSH
2412: LD_INT 22
2414: PUSH
2415: LD_INT 22
2417: PUSH
2418: EMPTY
2419: LIST
2420: LIST
2421: LIST
2422: LIST
2423: PUSH
2424: LD_OWVAR 67
2428: ARRAY
2429: PPUSH
2430: LD_INT 1
2432: PPUSH
2433: LD_INT 1
2435: PPUSH
2436: LD_INT 45
2438: PUSH
2439: LD_INT 44
2441: PUSH
2442: LD_INT 43
2444: PUSH
2445: LD_INT 42
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: PUSH
2454: LD_OWVAR 67
2458: ARRAY
2459: PPUSH
2460: LD_INT 0
2462: PPUSH
2463: CALL 21340 0 5
// Masha := CreateVehicle ;
2467: LD_ADDR_EXP 52
2471: PUSH
2472: CALL_OW 45
2476: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2477: LD_EXP 52
2481: PUSH
2482: LD_EXP 49
2486: PUSH
2487: EMPTY
2488: LIST
2489: LIST
2490: PPUSH
2491: LD_INT 499
2493: PPUSH
2494: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2498: LD_EXP 52
2502: PPUSH
2503: LD_INT 3
2505: PPUSH
2506: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2510: LD_EXP 52
2514: PPUSH
2515: LD_INT 1
2517: PPUSH
2518: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2522: LD_INT 1
2524: PPUSH
2525: LD_INT 18
2527: PPUSH
2528: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2532: LD_INT 35
2534: PPUSH
2535: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2539: LD_ADDR_VAR 0 3
2543: PUSH
2544: LD_INT 18
2546: PPUSH
2547: EMPTY
2548: PPUSH
2549: CALL_OW 70
2553: ST_TO_ADDR
// if tmp then
2554: LD_VAR 0 3
2558: IFFALSE 2592
// for i in tmp do
2560: LD_ADDR_VAR 0 2
2564: PUSH
2565: LD_VAR 0 3
2569: PUSH
2570: FOR_IN
2571: IFFALSE 2590
// ComMoveXY ( i , 114 , 9 ) ;
2573: LD_VAR 0 2
2577: PPUSH
2578: LD_INT 114
2580: PPUSH
2581: LD_INT 9
2583: PPUSH
2584: CALL_OW 111
2588: GO 2570
2590: POP
2591: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2592: LD_INT 18
2594: PPUSH
2595: EMPTY
2596: PPUSH
2597: CALL_OW 70
2601: NOT
2602: PUSH
2603: LD_INT 123
2605: PPUSH
2606: LD_INT 3
2608: PPUSH
2609: CALL_OW 428
2613: PUSH
2614: LD_INT 0
2616: EQUAL
2617: AND
2618: IFFALSE 2532
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2620: LD_EXP 52
2624: PPUSH
2625: LD_INT 123
2627: PPUSH
2628: LD_INT 3
2630: PPUSH
2631: LD_INT 0
2633: PPUSH
2634: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2638: LD_EXP 49
2642: PPUSH
2643: LD_INT 125
2645: PPUSH
2646: LD_INT 1
2648: PPUSH
2649: LD_INT 0
2651: PPUSH
2652: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2656: LD_EXP 49
2660: PPUSH
2661: LD_EXP 52
2665: PPUSH
2666: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2670: LD_INT 10
2672: PPUSH
2673: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2677: LD_EXP 52
2681: PPUSH
2682: LD_INT 110
2684: PPUSH
2685: LD_INT 10
2687: PPUSH
2688: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2692: LD_ADDR_EXP 45
2696: PUSH
2697: LD_STRING Petrovova
2699: PPUSH
2700: CALL_OW 25
2704: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2705: LD_ADDR_EXP 47
2709: PUSH
2710: LD_STRING Kuzmov
2712: PPUSH
2713: CALL_OW 25
2717: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2718: LD_ADDR_EXP 46
2722: PUSH
2723: LD_STRING Kovalyuk
2725: PPUSH
2726: CALL_OW 25
2730: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2731: LD_ADDR_EXP 44
2735: PUSH
2736: LD_STRING Lipshchin
2738: PPUSH
2739: CALL_OW 25
2743: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2744: LD_ADDR_EXP 48
2748: PUSH
2749: LD_STRING Karamazov
2751: PPUSH
2752: CALL_OW 25
2756: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2757: LD_ADDR_VAR 0 3
2761: PUSH
2762: LD_EXP 45
2766: PUSH
2767: LD_EXP 47
2771: PUSH
2772: LD_EXP 46
2776: PUSH
2777: LD_EXP 44
2781: PUSH
2782: LD_EXP 48
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: LIST
2791: LIST
2792: LIST
2793: ST_TO_ADDR
// for i in tmp do
2794: LD_ADDR_VAR 0 2
2798: PUSH
2799: LD_VAR 0 3
2803: PUSH
2804: FOR_IN
2805: IFFALSE 2844
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2807: LD_VAR 0 2
2811: PPUSH
2812: LD_INT 399
2814: PPUSH
2815: LD_INT 799
2817: PPUSH
2818: CALL_OW 12
2822: PPUSH
2823: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2827: LD_VAR 0 2
2831: PPUSH
2832: LD_INT 19
2834: PPUSH
2835: LD_INT 0
2837: PPUSH
2838: CALL_OW 49
// end ;
2842: GO 2804
2844: POP
2845: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2846: LD_VAR 0 3
2850: PPUSH
2851: LD_INT 112
2853: PPUSH
2854: LD_INT 5
2856: PPUSH
2857: CALL_OW 111
// AddComHold ( tmp ) ;
2861: LD_VAR 0 3
2865: PPUSH
2866: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2870: LD_ADDR_VAR 0 2
2874: PUSH
2875: LD_VAR 0 3
2879: PPUSH
2880: LD_INT 25
2882: PUSH
2883: LD_INT 1
2885: PUSH
2886: EMPTY
2887: LIST
2888: LIST
2889: PPUSH
2890: CALL_OW 72
2894: PUSH
2895: FOR_IN
2896: IFFALSE 2936
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2898: LD_VAR 0 2
2902: PPUSH
2903: LD_INT 20
2905: PPUSH
2906: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2910: LD_VAR 0 2
2914: PPUSH
2915: LD_INT 147
2917: PPUSH
2918: LD_INT 45
2920: PPUSH
2921: CALL_OW 178
// AddComCrawl ( i ) ;
2925: LD_VAR 0 2
2929: PPUSH
2930: CALL_OW 197
// end ;
2934: GO 2895
2936: POP
2937: POP
// repeat wait ( 0 0$1 ) ;
2938: LD_INT 35
2940: PPUSH
2941: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2945: LD_EXP 52
2949: PPUSH
2950: LD_INT 110
2952: PPUSH
2953: LD_INT 10
2955: PPUSH
2956: CALL_OW 307
2960: PUSH
2961: LD_EXP 52
2965: PPUSH
2966: CALL_OW 305
2970: NOT
2971: OR
2972: IFFALSE 2938
// ComStop ( Burlak ) ;
2974: LD_EXP 49
2978: PPUSH
2979: CALL_OW 141
// AddComHold ( Burlak ) ;
2983: LD_EXP 49
2987: PPUSH
2988: CALL_OW 200
// end ; end_of_file
2992: LD_VAR 0 1
2996: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2997: LD_INT 0
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
3003: PPUSH
// uc_side := 3 ;
3004: LD_ADDR_OWVAR 20
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// uc_nation := 3 ;
3012: LD_ADDR_OWVAR 21
3016: PUSH
3017: LD_INT 3
3019: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3020: LD_ADDR_EXP 53
3024: PUSH
3025: LD_INT 47
3027: PPUSH
3028: LD_INT 4
3030: PPUSH
3031: LD_STRING 
3033: PPUSH
3034: LD_INT 7
3036: PUSH
3037: LD_INT 8
3039: PUSH
3040: LD_INT 9
3042: PUSH
3043: LD_INT 10
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: LD_OWVAR 67
3056: ARRAY
3057: PPUSH
3058: LD_INT 10000
3060: PUSH
3061: LD_INT 3000
3063: PUSH
3064: LD_INT 300
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: PPUSH
3072: LD_INT 9
3074: PUSH
3075: LD_INT 5
3077: PUSH
3078: LD_INT 6
3080: PUSH
3081: LD_INT 6
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: CALL 25161 0 6
3094: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3095: LD_ADDR_EXP 62
3099: PUSH
3100: LD_EXP 62
3104: PPUSH
3105: LD_INT 2
3107: PPUSH
3108: LD_EXP 53
3112: PPUSH
3113: CALL_OW 1
3117: ST_TO_ADDR
// tmp := [ ] ;
3118: LD_ADDR_VAR 0 4
3122: PUSH
3123: EMPTY
3124: ST_TO_ADDR
// for i = 1 to 4 do
3125: LD_ADDR_VAR 0 2
3129: PUSH
3130: DOUBLE
3131: LD_INT 1
3133: DEC
3134: ST_TO_ADDR
3135: LD_INT 4
3137: PUSH
3138: FOR_TO
3139: IFFALSE 3232
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3141: LD_INT 22
3143: PPUSH
3144: LD_INT 3
3146: PPUSH
3147: LD_INT 3
3149: PPUSH
3150: LD_INT 43
3152: PUSH
3153: LD_INT 45
3155: PUSH
3156: LD_INT 45
3158: PUSH
3159: LD_INT 44
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: PUSH
3168: LD_VAR 0 2
3172: PUSH
3173: LD_INT 4
3175: MOD
3176: PUSH
3177: LD_INT 1
3179: PLUS
3180: ARRAY
3181: PPUSH
3182: LD_INT 100
3184: PPUSH
3185: CALL 21340 0 5
// veh := CreateVehicle ;
3189: LD_ADDR_VAR 0 3
3193: PUSH
3194: CALL_OW 45
3198: ST_TO_ADDR
// tmp := tmp ^ veh ;
3199: LD_ADDR_VAR 0 4
3203: PUSH
3204: LD_VAR 0 4
3208: PUSH
3209: LD_VAR 0 3
3213: ADD
3214: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3215: LD_VAR 0 3
3219: PPUSH
3220: LD_INT 2
3222: PPUSH
3223: LD_INT 0
3225: PPUSH
3226: CALL_OW 49
// end ;
3230: GO 3138
3232: POP
3233: POP
// russian_guard := tmp ;
3234: LD_ADDR_EXP 54
3238: PUSH
3239: LD_VAR 0 4
3243: ST_TO_ADDR
// if Difficulty >= 3 then
3244: LD_OWVAR 67
3248: PUSH
3249: LD_INT 3
3251: GREATEREQUAL
3252: IFFALSE 3316
// begin bc_type := b_breastwork ;
3254: LD_ADDR_OWVAR 42
3258: PUSH
3259: LD_INT 31
3261: ST_TO_ADDR
// bc_level := 10 ;
3262: LD_ADDR_OWVAR 43
3266: PUSH
3267: LD_INT 10
3269: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3270: LD_ADDR_VAR 0 5
3274: PUSH
3275: LD_INT 96
3277: PPUSH
3278: LD_INT 105
3280: PPUSH
3281: LD_INT 3
3283: PPUSH
3284: CALL_OW 47
3288: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3289: LD_INT 0
3291: PPUSH
3292: LD_INT 9
3294: PPUSH
3295: LD_INT 10
3297: PPUSH
3298: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3302: CALL_OW 44
3306: PPUSH
3307: LD_VAR 0 5
3311: PPUSH
3312: CALL_OW 52
// end ; end ;
3316: LD_VAR 0 1
3320: RET
// every 5 5$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , _target , attackers , amount ;
3321: LD_INT 47
3323: PPUSH
3324: CALL_OW 302
3328: PUSH
3329: LD_EXP 7
3333: AND
3334: IFFALSE 4088
3336: GO 3338
3338: DISABLE
3339: LD_INT 0
3341: PPUSH
3342: PPUSH
3343: PPUSH
3344: PPUSH
3345: PPUSH
3346: PPUSH
3347: PPUSH
// begin enable ;
3348: ENABLE
// base := 2 ;
3349: LD_ADDR_VAR 0 3
3353: PUSH
3354: LD_INT 2
3356: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3357: LD_ADDR_VAR 0 4
3361: PUSH
3362: LD_INT 22
3364: PUSH
3365: LD_INT 1
3367: PUSH
3368: LD_INT 3
3370: PUSH
3371: LD_INT 45
3373: PUSH
3374: EMPTY
3375: LIST
3376: LIST
3377: LIST
3378: LIST
3379: PUSH
3380: LD_INT 21
3382: PUSH
3383: LD_INT 1
3385: PUSH
3386: LD_INT 3
3388: PUSH
3389: LD_INT 45
3391: PUSH
3392: EMPTY
3393: LIST
3394: LIST
3395: LIST
3396: LIST
3397: PUSH
3398: LD_INT 22
3400: PUSH
3401: LD_INT 1
3403: PUSH
3404: LD_INT 3
3406: PUSH
3407: LD_INT 45
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: PUSH
3416: LD_INT 23
3418: PUSH
3419: LD_INT 1
3421: PUSH
3422: LD_INT 3
3424: PUSH
3425: LD_INT 46
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: PUSH
3434: EMPTY
3435: LIST
3436: LIST
3437: LIST
3438: LIST
3439: ST_TO_ADDR
// amount := Difficulty ;
3440: LD_ADDR_VAR 0 7
3444: PUSH
3445: LD_OWVAR 67
3449: ST_TO_ADDR
// if tick > 30 30$00 then
3450: LD_OWVAR 1
3454: PUSH
3455: LD_INT 63000
3457: GREATER
3458: IFFALSE 3495
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3460: LD_ADDR_VAR 0 7
3464: PUSH
3465: LD_VAR 0 7
3469: PUSH
3470: LD_INT 2
3472: PUSH
3473: LD_INT 3
3475: PUSH
3476: LD_INT 4
3478: PUSH
3479: LD_INT 4
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: PUSH
3488: LD_OWVAR 67
3492: ARRAY
3493: PLUS
3494: ST_TO_ADDR
// for i = 1 to amount do
3495: LD_ADDR_VAR 0 1
3499: PUSH
3500: DOUBLE
3501: LD_INT 1
3503: DEC
3504: ST_TO_ADDR
3505: LD_VAR 0 7
3509: PUSH
3510: FOR_TO
3511: IFFALSE 3599
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3513: LD_ADDR_VAR 0 4
3517: PUSH
3518: LD_VAR 0 4
3522: PPUSH
3523: LD_VAR 0 4
3527: PUSH
3528: LD_INT 1
3530: PLUS
3531: PPUSH
3532: LD_INT 23
3534: PUSH
3535: LD_INT 24
3537: PUSH
3538: EMPTY
3539: LIST
3540: LIST
3541: PUSH
3542: LD_INT 1
3544: PPUSH
3545: LD_INT 2
3547: PPUSH
3548: CALL_OW 12
3552: ARRAY
3553: PUSH
3554: LD_INT 1
3556: PUSH
3557: LD_INT 3
3559: PUSH
3560: LD_INT 46
3562: PUSH
3563: LD_INT 47
3565: PUSH
3566: LD_INT 45
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: LIST
3573: PUSH
3574: LD_INT 1
3576: PPUSH
3577: LD_INT 3
3579: PPUSH
3580: CALL_OW 12
3584: ARRAY
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: LIST
3590: LIST
3591: PPUSH
3592: CALL_OW 2
3596: ST_TO_ADDR
3597: GO 3510
3599: POP
3600: POP
// p := 1 ;
3601: LD_ADDR_VAR 0 2
3605: PUSH
3606: LD_INT 1
3608: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3609: LD_VAR 0 3
3613: PPUSH
3614: LD_VAR 0 4
3618: PPUSH
3619: CALL 83557 0 2
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// p := Inc ( p ) ;
3630: LD_ADDR_VAR 0 2
3634: PUSH
3635: LD_VAR 0 2
3639: PPUSH
3640: CALL 55552 0 1
3644: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 60 ;
3645: LD_VAR 0 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL 84975 0 2
3657: PUSH
3658: LD_VAR 0 7
3662: GREATEREQUAL
3663: PUSH
3664: LD_VAR 0 2
3668: PUSH
3669: LD_INT 60
3671: GREATEREQUAL
3672: OR
3673: IFFALSE 3623
// wait ( 0 0$30 ) ;
3675: LD_INT 1050
3677: PPUSH
3678: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3682: LD_ADDR_VAR 0 5
3686: PUSH
3687: LD_INT 71
3689: PUSH
3690: LD_INT 19
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PUSH
3697: LD_INT 91
3699: PUSH
3700: LD_INT 67
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PUSH
3707: LD_INT 52
3709: PUSH
3710: LD_INT 44
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: PUSH
3717: LD_INT 68
3719: PUSH
3720: LD_INT 48
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: LIST
3732: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] ] ] ] ) diff mc_defender [ base ] ;
3733: LD_ADDR_VAR 0 6
3737: PUSH
3738: LD_INT 22
3740: PUSH
3741: LD_INT 3
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: LD_INT 21
3750: PUSH
3751: LD_INT 2
3753: PUSH
3754: EMPTY
3755: LIST
3756: LIST
3757: PUSH
3758: LD_INT 3
3760: PUSH
3761: LD_INT 2
3763: PUSH
3764: LD_INT 34
3766: PUSH
3767: LD_INT 52
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: PUSH
3774: LD_INT 34
3776: PUSH
3777: LD_INT 51
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: LIST
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: PUSH
3793: EMPTY
3794: LIST
3795: LIST
3796: LIST
3797: PPUSH
3798: CALL_OW 69
3802: PUSH
3803: LD_EXP 84
3807: PUSH
3808: LD_VAR 0 3
3812: ARRAY
3813: DIFF
3814: ST_TO_ADDR
// if not attackers then
3815: LD_VAR 0 6
3819: NOT
3820: IFFALSE 3824
// exit ;
3822: GO 4088
// ru_attackers := attackers ;
3824: LD_ADDR_EXP 55
3828: PUSH
3829: LD_VAR 0 6
3833: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3834: LD_ADDR_EXP 81
3838: PUSH
3839: LD_EXP 81
3843: PPUSH
3844: LD_VAR 0 3
3848: PPUSH
3849: LD_EXP 81
3853: PUSH
3854: LD_VAR 0 3
3858: ARRAY
3859: PUSH
3860: LD_VAR 0 6
3864: DIFF
3865: PPUSH
3866: CALL_OW 1
3870: ST_TO_ADDR
// for i = 1 to attackers do
3871: LD_ADDR_VAR 0 1
3875: PUSH
3876: DOUBLE
3877: LD_INT 1
3879: DEC
3880: ST_TO_ADDR
3881: LD_VAR 0 6
3885: PUSH
3886: FOR_TO
3887: IFFALSE 3964
// begin case i mod 3 of 0 :
3889: LD_VAR 0 1
3893: PUSH
3894: LD_INT 3
3896: MOD
3897: PUSH
3898: LD_INT 0
3900: DOUBLE
3901: EQUAL
3902: IFTRUE 3906
3904: GO 3909
3906: POP
// ; 1 :
3907: GO 3962
3909: LD_INT 1
3911: DOUBLE
3912: EQUAL
3913: IFTRUE 3917
3915: GO 3935
3917: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3918: LD_VAR 0 1
3922: PPUSH
3923: LD_INT 32
3925: PPUSH
3926: LD_INT 49
3928: PPUSH
3929: CALL_OW 114
3933: GO 3962
3935: LD_INT 2
3937: DOUBLE
3938: EQUAL
3939: IFTRUE 3943
3941: GO 3961
3943: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3944: LD_VAR 0 1
3948: PPUSH
3949: LD_INT 117
3951: PPUSH
3952: LD_INT 107
3954: PPUSH
3955: CALL_OW 114
3959: GO 3962
3961: POP
// end ;
3962: GO 3886
3964: POP
3965: POP
// p := 0 ;
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: LD_INT 0
3973: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3974: LD_INT 35
3976: PPUSH
3977: CALL_OW 67
// p := Inc ( p ) ;
3981: LD_ADDR_VAR 0 2
3985: PUSH
3986: LD_VAR 0 2
3990: PPUSH
3991: CALL 55552 0 1
3995: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
3996: LD_VAR 0 6
4000: PPUSH
4001: LD_INT 60
4003: PUSH
4004: EMPTY
4005: LIST
4006: PPUSH
4007: CALL_OW 72
4011: NOT
4012: PUSH
4013: LD_VAR 0 2
4017: PUSH
4018: LD_INT 30
4020: GREATER
4021: OR
4022: IFFALSE 3974
// if not first_attack then
4024: LD_EXP 8
4028: NOT
4029: IFFALSE 4039
// first_attack := true ;
4031: LD_ADDR_EXP 8
4035: PUSH
4036: LD_INT 1
4038: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4039: LD_INT 35
4041: PPUSH
4042: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
4046: LD_ADDR_VAR 0 6
4050: PUSH
4051: LD_VAR 0 6
4055: PPUSH
4056: LD_INT 50
4058: PUSH
4059: EMPTY
4060: LIST
4061: PPUSH
4062: CALL_OW 72
4066: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
4067: LD_VAR 0 6
4071: PPUSH
4072: LD_VAR 0 5
4076: PPUSH
4077: CALL 56795 0 2
// until not attackers ;
4081: LD_VAR 0 6
4085: NOT
4086: IFFALSE 4039
// end ;
4088: PPOPN 7
4090: END
// export function PrepareRussianAttack ; var i , tmp , veh , chassis , weapon ; begin
4091: LD_INT 0
4093: PPUSH
4094: PPUSH
4095: PPUSH
4096: PPUSH
4097: PPUSH
4098: PPUSH
// uc_side := 6 ;
4099: LD_ADDR_OWVAR 20
4103: PUSH
4104: LD_INT 6
4106: ST_TO_ADDR
// uc_nation := 3 ;
4107: LD_ADDR_OWVAR 21
4111: PUSH
4112: LD_INT 3
4114: ST_TO_ADDR
// InitHc ;
4115: CALL_OW 19
// InitVc ;
4119: CALL_OW 20
// tmp := [ ] ;
4123: LD_ADDR_VAR 0 3
4127: PUSH
4128: EMPTY
4129: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
4130: LD_ADDR_VAR 0 2
4134: PUSH
4135: DOUBLE
4136: LD_INT 1
4138: DEC
4139: ST_TO_ADDR
4140: LD_INT 4
4142: PUSH
4143: LD_INT 5
4145: PUSH
4146: LD_INT 6
4148: PUSH
4149: LD_INT 7
4151: PUSH
4152: EMPTY
4153: LIST
4154: LIST
4155: LIST
4156: LIST
4157: PUSH
4158: LD_OWVAR 67
4162: ARRAY
4163: PUSH
4164: FOR_TO
4165: IFFALSE 4419
// begin chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 3 ) ] ;
4167: LD_ADDR_VAR 0 5
4171: PUSH
4172: LD_INT 21
4174: PUSH
4175: LD_INT 22
4177: PUSH
4178: LD_INT 24
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 1
4188: PPUSH
4189: LD_INT 3
4191: PPUSH
4192: CALL_OW 12
4196: ARRAY
4197: ST_TO_ADDR
// case chassis of ru_medium_wheeled , ru_medium_tracked :
4198: LD_VAR 0 5
4202: PUSH
4203: LD_INT 21
4205: DOUBLE
4206: EQUAL
4207: IFTRUE 4217
4209: LD_INT 22
4211: DOUBLE
4212: EQUAL
4213: IFTRUE 4217
4215: GO 4251
4217: POP
// weapon := [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ; ru_heavy_tracked :
4218: LD_ADDR_VAR 0 6
4222: PUSH
4223: LD_INT 45
4225: PUSH
4226: LD_INT 44
4228: PUSH
4229: LD_INT 43
4231: PUSH
4232: EMPTY
4233: LIST
4234: LIST
4235: LIST
4236: PUSH
4237: LD_INT 1
4239: PPUSH
4240: LD_INT 3
4242: PPUSH
4243: CALL_OW 12
4247: ARRAY
4248: ST_TO_ADDR
4249: GO 4298
4251: LD_INT 24
4253: DOUBLE
4254: EQUAL
4255: IFTRUE 4259
4257: GO 4297
4259: POP
// weapon := [ ru_heavy_gun , ru_rocket , ru_rocket_launcher , ru_heavy_gun ] [ rand ( 1 , 4 ) ] ; end ;
4260: LD_ADDR_VAR 0 6
4264: PUSH
4265: LD_INT 46
4267: PUSH
4268: LD_INT 47
4270: PUSH
4271: LD_INT 45
4273: PUSH
4274: LD_INT 46
4276: PUSH
4277: EMPTY
4278: LIST
4279: LIST
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 1
4285: PPUSH
4286: LD_INT 4
4288: PPUSH
4289: CALL_OW 12
4293: ARRAY
4294: ST_TO_ADDR
4295: GO 4298
4297: POP
// uc_side := 6 ;
4298: LD_ADDR_OWVAR 20
4302: PUSH
4303: LD_INT 6
4305: ST_TO_ADDR
// uc_nation := 3 ;
4306: LD_ADDR_OWVAR 21
4310: PUSH
4311: LD_INT 3
4313: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
4314: LD_VAR 0 5
4318: PPUSH
4319: LD_INT 1
4321: PUSH
4322: LD_INT 3
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PUSH
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 2
4334: PPUSH
4335: CALL_OW 12
4339: ARRAY
4340: PPUSH
4341: LD_INT 3
4343: PPUSH
4344: LD_VAR 0 6
4348: PPUSH
4349: LD_INT 70
4351: PPUSH
4352: LD_INT 90
4354: PPUSH
4355: CALL_OW 12
4359: PPUSH
4360: CALL 21340 0 5
// veh := CreateVehicle ;
4364: LD_ADDR_VAR 0 4
4368: PUSH
4369: CALL_OW 45
4373: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
4374: LD_VAR 0 4
4378: PPUSH
4379: LD_INT 5
4381: PPUSH
4382: CALL_OW 233
// PlaceUnitArea ( veh , south_spawn , false ) ;
4386: LD_VAR 0 4
4390: PPUSH
4391: LD_INT 16
4393: PPUSH
4394: LD_INT 0
4396: PPUSH
4397: CALL_OW 49
// tmp := tmp ^ veh ;
4401: LD_ADDR_VAR 0 3
4405: PUSH
4406: LD_VAR 0 3
4410: PUSH
4411: LD_VAR 0 4
4415: ADD
4416: ST_TO_ADDR
// end ;
4417: GO 4164
4419: POP
4420: POP
// if not tmp then
4421: LD_VAR 0 3
4425: NOT
4426: IFFALSE 4430
// exit ;
4428: GO 4524
// repeat wait ( 0 0$2 ) ;
4430: LD_INT 70
4432: PPUSH
4433: CALL_OW 67
// for i in tmp do
4437: LD_ADDR_VAR 0 2
4441: PUSH
4442: LD_VAR 0 3
4446: PUSH
4447: FOR_IN
4448: IFFALSE 4515
// if IsOk ( i ) then
4450: LD_VAR 0 2
4454: PPUSH
4455: CALL_OW 302
4459: IFFALSE 4497
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) else
4461: LD_VAR 0 2
4465: PPUSH
4466: LD_INT 22
4468: PUSH
4469: LD_INT 7
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PPUSH
4476: CALL_OW 69
4480: PPUSH
4481: LD_VAR 0 2
4485: PPUSH
4486: CALL_OW 74
4490: PPUSH
4491: CALL_OW 115
4495: GO 4513
// tmp := tmp diff i ;
4497: LD_ADDR_VAR 0 3
4501: PUSH
4502: LD_VAR 0 3
4506: PUSH
4507: LD_VAR 0 2
4511: DIFF
4512: ST_TO_ADDR
4513: GO 4447
4515: POP
4516: POP
// until not tmp ;
4517: LD_VAR 0 3
4521: NOT
4522: IFFALSE 4430
// end ;
4524: LD_VAR 0 1
4528: RET
// every 10 10$00 + 3 3$00 trigger first_attack and IsOk ( ru_depot ) and GetSide ( ru_depot ) = 3 and ru_active_attack do
4529: LD_EXP 8
4533: PUSH
4534: LD_INT 47
4536: PPUSH
4537: CALL_OW 302
4541: AND
4542: PUSH
4543: LD_INT 47
4545: PPUSH
4546: CALL_OW 255
4550: PUSH
4551: LD_INT 3
4553: EQUAL
4554: AND
4555: PUSH
4556: LD_EXP 6
4560: AND
4561: IFFALSE 4571
4563: GO 4565
4565: DISABLE
// begin enable ;
4566: ENABLE
// PrepareRussianAttack ;
4567: CALL 4091 0 0
// end ; end_of_file
4571: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4572: LD_INT 0
4574: PPUSH
4575: PPUSH
4576: PPUSH
4577: PPUSH
4578: PPUSH
4579: PPUSH
4580: PPUSH
// uc_side := 2 ;
4581: LD_ADDR_OWVAR 20
4585: PUSH
4586: LD_INT 2
4588: ST_TO_ADDR
// uc_nation := 2 ;
4589: LD_ADDR_OWVAR 21
4593: PUSH
4594: LD_INT 2
4596: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4597: LD_ADDR_EXP 58
4601: PUSH
4602: LD_STRING Abdul
4604: PPUSH
4605: CALL_OW 25
4609: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4610: LD_EXP 58
4614: PPUSH
4615: LD_INT 11
4617: PPUSH
4618: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4622: LD_EXP 58
4626: PPUSH
4627: LD_INT 1
4629: PPUSH
4630: CALL_OW 52
// vc_chassis := 31 ;
4634: LD_ADDR_OWVAR 37
4638: PUSH
4639: LD_INT 31
4641: ST_TO_ADDR
// vc_control := control_rider ;
4642: LD_ADDR_OWVAR 38
4646: PUSH
4647: LD_INT 4
4649: ST_TO_ADDR
// mastodont := CreateVehicle ;
4650: LD_ADDR_EXP 59
4654: PUSH
4655: CALL_OW 45
4659: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4660: LD_EXP 59
4664: PPUSH
4665: LD_INT 153
4667: PPUSH
4668: LD_INT 71
4670: PPUSH
4671: LD_INT 0
4673: PPUSH
4674: CALL_OW 48
// InitVc ;
4678: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 11 , 5 , 6 , 7 ] ) ;
4682: LD_ADDR_EXP 56
4686: PUSH
4687: LD_INT 1
4689: PPUSH
4690: LD_INT 3
4692: PPUSH
4693: LD_STRING kaba
4695: PPUSH
4696: LD_INT 7
4698: PUSH
4699: LD_INT 8
4701: PUSH
4702: LD_INT 9
4704: PUSH
4705: LD_INT 10
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: LIST
4713: PUSH
4714: LD_OWVAR 67
4718: ARRAY
4719: PPUSH
4720: LD_INT 5000
4722: PUSH
4723: LD_INT 1000
4725: PUSH
4726: LD_INT 300
4728: PUSH
4729: EMPTY
4730: LIST
4731: LIST
4732: LIST
4733: PPUSH
4734: LD_INT 11
4736: PUSH
4737: LD_INT 5
4739: PUSH
4740: LD_INT 6
4742: PUSH
4743: LD_INT 7
4745: PUSH
4746: EMPTY
4747: LIST
4748: LIST
4749: LIST
4750: LIST
4751: PPUSH
4752: CALL 25161 0 6
4756: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4757: LD_ADDR_EXP 62
4761: PUSH
4762: LD_EXP 62
4766: PPUSH
4767: LD_INT 1
4769: PPUSH
4770: LD_EXP 56
4774: PPUSH
4775: CALL_OW 1
4779: ST_TO_ADDR
// tmp := [ ] ;
4780: LD_ADDR_VAR 0 4
4784: PUSH
4785: EMPTY
4786: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
4787: LD_ADDR_OWVAR 37
4791: PUSH
4792: LD_INT 13
4794: ST_TO_ADDR
// vc_engine := engine_siberite ;
4795: LD_ADDR_OWVAR 39
4799: PUSH
4800: LD_INT 3
4802: ST_TO_ADDR
// vc_control := control_manual ;
4803: LD_ADDR_OWVAR 38
4807: PUSH
4808: LD_INT 1
4810: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4811: LD_ADDR_OWVAR 40
4815: PUSH
4816: LD_INT 31
4818: ST_TO_ADDR
// for i = 1 to 3 do
4819: LD_ADDR_VAR 0 2
4823: PUSH
4824: DOUBLE
4825: LD_INT 1
4827: DEC
4828: ST_TO_ADDR
4829: LD_INT 3
4831: PUSH
4832: FOR_TO
4833: IFFALSE 5081
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4835: LD_ADDR_VAR 0 5
4839: PUSH
4840: LD_INT 153
4842: PUSH
4843: LD_INT 71
4845: PUSH
4846: EMPTY
4847: LIST
4848: LIST
4849: PUSH
4850: LD_INT 155
4852: PUSH
4853: LD_INT 81
4855: PUSH
4856: EMPTY
4857: LIST
4858: LIST
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: LD_VAR 0 2
4868: PUSH
4869: LD_INT 2
4871: MOD
4872: PUSH
4873: LD_INT 1
4875: PLUS
4876: ARRAY
4877: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4878: LD_INT 0
4880: PPUSH
4881: LD_INT 3
4883: PPUSH
4884: LD_INT 7
4886: PUSH
4887: LD_INT 8
4889: PUSH
4890: LD_INT 10
4892: PUSH
4893: LD_INT 10
4895: PUSH
4896: EMPTY
4897: LIST
4898: LIST
4899: LIST
4900: LIST
4901: PUSH
4902: LD_OWVAR 67
4906: ARRAY
4907: PPUSH
4908: CALL_OW 380
// un := CreateVehicle ;
4912: LD_ADDR_VAR 0 6
4916: PUSH
4917: CALL_OW 45
4921: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4922: LD_VAR 0 6
4926: PPUSH
4927: LD_INT 0
4929: PPUSH
4930: LD_INT 5
4932: PPUSH
4933: CALL_OW 12
4937: PPUSH
4938: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4942: LD_VAR 0 6
4946: PPUSH
4947: LD_VAR 0 5
4951: PUSH
4952: LD_INT 1
4954: ARRAY
4955: PPUSH
4956: LD_VAR 0 5
4960: PUSH
4961: LD_INT 2
4963: ARRAY
4964: PPUSH
4965: LD_INT 6
4967: PPUSH
4968: LD_INT 0
4970: PPUSH
4971: CALL_OW 50
// un2 := CreateHuman ;
4975: LD_ADDR_VAR 0 7
4979: PUSH
4980: CALL_OW 44
4984: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4985: LD_VAR 0 7
4989: PPUSH
4990: LD_VAR 0 6
4994: PPUSH
4995: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4999: LD_ADDR_EXP 62
5003: PUSH
5004: LD_EXP 62
5008: PPUSH
5009: LD_INT 1
5011: PUSH
5012: LD_EXP 62
5016: PUSH
5017: LD_INT 1
5019: ARRAY
5020: PUSH
5021: LD_INT 1
5023: PLUS
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PPUSH
5029: LD_VAR 0 6
5033: PPUSH
5034: CALL 21462 0 3
5038: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
5039: LD_ADDR_EXP 62
5043: PUSH
5044: LD_EXP 62
5048: PPUSH
5049: LD_INT 1
5051: PUSH
5052: LD_EXP 62
5056: PUSH
5057: LD_INT 1
5059: ARRAY
5060: PUSH
5061: LD_INT 1
5063: PLUS
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: PPUSH
5069: LD_VAR 0 7
5073: PPUSH
5074: CALL 21462 0 3
5078: ST_TO_ADDR
// end ;
5079: GO 4832
5081: POP
5082: POP
// for i = 1 to 5 do
5083: LD_ADDR_VAR 0 2
5087: PUSH
5088: DOUBLE
5089: LD_INT 1
5091: DEC
5092: ST_TO_ADDR
5093: LD_INT 5
5095: PUSH
5096: FOR_TO
5097: IFFALSE 5190
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
5099: LD_INT 13
5101: PPUSH
5102: LD_INT 3
5104: PPUSH
5105: LD_INT 1
5107: PPUSH
5108: LD_INT 25
5110: PUSH
5111: LD_INT 28
5113: PUSH
5114: LD_INT 28
5116: PUSH
5117: LD_INT 26
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: LIST
5124: LIST
5125: PUSH
5126: LD_VAR 0 2
5130: PUSH
5131: LD_INT 4
5133: MOD
5134: PUSH
5135: LD_INT 1
5137: PLUS
5138: ARRAY
5139: PPUSH
5140: LD_INT 100
5142: PPUSH
5143: CALL 21340 0 5
// veh := CreateVehicle ;
5147: LD_ADDR_VAR 0 3
5151: PUSH
5152: CALL_OW 45
5156: ST_TO_ADDR
// tmp := tmp ^ veh ;
5157: LD_ADDR_VAR 0 4
5161: PUSH
5162: LD_VAR 0 4
5166: PUSH
5167: LD_VAR 0 3
5171: ADD
5172: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
5173: LD_VAR 0 3
5177: PPUSH
5178: LD_INT 1
5180: PPUSH
5181: LD_INT 0
5183: PPUSH
5184: CALL_OW 49
// end ;
5188: GO 5096
5190: POP
5191: POP
// arabian_guard := tmp ;
5192: LD_ADDR_EXP 57
5196: PUSH
5197: LD_VAR 0 4
5201: ST_TO_ADDR
// end ;
5202: LD_VAR 0 1
5206: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
5207: LD_INT 22
5209: PUSH
5210: LD_INT 7
5212: PUSH
5213: EMPTY
5214: LIST
5215: LIST
5216: PUSH
5217: LD_INT 91
5219: PUSH
5220: LD_INT 1
5222: PUSH
5223: LD_INT 12
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: LIST
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: PPUSH
5235: CALL_OW 69
5239: PUSH
5240: LD_EXP 59
5244: PPUSH
5245: CALL_OW 256
5249: PUSH
5250: LD_INT 990
5252: LESS
5253: OR
5254: PUSH
5255: LD_EXP 58
5259: PPUSH
5260: CALL_OW 256
5264: PUSH
5265: LD_INT 990
5267: LESS
5268: OR
5269: IFFALSE 5412
5271: GO 5273
5273: DISABLE
// begin if IsInUnit ( Abdul ) then
5274: LD_EXP 58
5278: PPUSH
5279: CALL_OW 310
5283: IFFALSE 5294
// ComExitBuilding ( Abdul ) ;
5285: LD_EXP 58
5289: PPUSH
5290: CALL_OW 122
// if Mastodont then
5294: LD_EXP 59
5298: IFFALSE 5315
// ComMoveXY ( Mastodont , 205 , 132 ) ;
5300: LD_EXP 59
5304: PPUSH
5305: LD_INT 205
5307: PPUSH
5308: LD_INT 132
5310: PPUSH
5311: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
5315: LD_EXP 58
5319: PPUSH
5320: LD_INT 205
5322: PPUSH
5323: LD_INT 132
5325: PPUSH
5326: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
5330: LD_INT 35
5332: PPUSH
5333: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
5337: LD_EXP 58
5341: PPUSH
5342: LD_INT 21
5344: PPUSH
5345: CALL_OW 308
5349: IFFALSE 5330
// RemoveUnit ( Abdul ) ;
5351: LD_EXP 58
5355: PPUSH
5356: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
5360: LD_INT 35
5362: PPUSH
5363: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
5367: LD_EXP 59
5371: PPUSH
5372: LD_INT 21
5374: PPUSH
5375: CALL_OW 308
5379: PUSH
5380: LD_EXP 59
5384: PPUSH
5385: CALL_OW 301
5389: OR
5390: IFFALSE 5360
// if IsOk ( Mastodont ) then
5392: LD_EXP 59
5396: PPUSH
5397: CALL_OW 302
5401: IFFALSE 5412
// RemoveUnit ( Mastodont ) ;
5403: LD_EXP 59
5407: PPUSH
5408: CALL_OW 64
// end ;
5412: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
5413: LD_EXP 58
5417: PPUSH
5418: CALL_OW 301
5422: PUSH
5423: LD_INT 22
5425: PUSH
5426: LD_INT 2
5428: PUSH
5429: EMPTY
5430: LIST
5431: LIST
5432: PUSH
5433: LD_INT 2
5435: PUSH
5436: LD_INT 25
5438: PUSH
5439: LD_INT 1
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: PUSH
5446: LD_INT 25
5448: PUSH
5449: LD_INT 2
5451: PUSH
5452: EMPTY
5453: LIST
5454: LIST
5455: PUSH
5456: LD_INT 25
5458: PUSH
5459: LD_INT 3
5461: PUSH
5462: EMPTY
5463: LIST
5464: LIST
5465: PUSH
5466: LD_INT 25
5468: PUSH
5469: LD_INT 4
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: PUSH
5476: LD_INT 25
5478: PUSH
5479: LD_INT 8
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: LIST
5491: LIST
5492: LIST
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: PPUSH
5498: CALL_OW 69
5502: PUSH
5503: LD_INT 16
5505: PUSH
5506: LD_INT 19
5508: PUSH
5509: LD_INT 22
5511: PUSH
5512: LD_INT 22
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: LIST
5519: LIST
5520: PUSH
5521: LD_OWVAR 67
5525: ARRAY
5526: LESS
5527: OR
5528: IFFALSE 6201
5530: GO 5532
5532: DISABLE
5533: LD_INT 0
5535: PPUSH
5536: PPUSH
5537: PPUSH
5538: PPUSH
5539: PPUSH
5540: PPUSH
// begin MC_Kill ( 1 ) ;
5541: LD_INT 1
5543: PPUSH
5544: CALL 59532 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5548: LD_ADDR_VAR 0 2
5552: PUSH
5553: LD_INT 22
5555: PUSH
5556: LD_INT 2
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PUSH
5563: LD_INT 2
5565: PUSH
5566: LD_INT 25
5568: PUSH
5569: LD_INT 1
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: PUSH
5576: LD_INT 25
5578: PUSH
5579: LD_INT 2
5581: PUSH
5582: EMPTY
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 25
5588: PUSH
5589: LD_INT 3
5591: PUSH
5592: EMPTY
5593: LIST
5594: LIST
5595: PUSH
5596: LD_INT 25
5598: PUSH
5599: LD_INT 4
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: PUSH
5606: LD_INT 25
5608: PUSH
5609: LD_INT 8
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: LIST
5620: LIST
5621: LIST
5622: LIST
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: PPUSH
5628: CALL_OW 69
5632: ST_TO_ADDR
// for i in tmp do
5633: LD_ADDR_VAR 0 5
5637: PUSH
5638: LD_VAR 0 2
5642: PUSH
5643: FOR_IN
5644: IFFALSE 5660
// SetTag ( i , 10 ) ;
5646: LD_VAR 0 5
5650: PPUSH
5651: LD_INT 10
5653: PPUSH
5654: CALL_OW 109
5658: GO 5643
5660: POP
5661: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5662: LD_ADDR_VAR 0 3
5666: PUSH
5667: LD_INT 22
5669: PUSH
5670: LD_INT 2
5672: PUSH
5673: EMPTY
5674: LIST
5675: LIST
5676: PUSH
5677: LD_INT 21
5679: PUSH
5680: LD_INT 1
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: PPUSH
5691: CALL_OW 69
5695: PUSH
5696: LD_VAR 0 2
5700: DIFF
5701: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5702: LD_ADDR_VAR 0 1
5706: PUSH
5707: LD_INT 22
5709: PUSH
5710: LD_INT 2
5712: PUSH
5713: EMPTY
5714: LIST
5715: LIST
5716: PUSH
5717: LD_INT 21
5719: PUSH
5720: LD_INT 2
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: PUSH
5727: LD_INT 24
5729: PUSH
5730: LD_INT 300
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: PUSH
5737: EMPTY
5738: LIST
5739: LIST
5740: LIST
5741: PPUSH
5742: CALL_OW 69
5746: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5747: LD_ADDR_VAR 0 4
5751: PUSH
5752: LD_VAR 0 1
5756: PPUSH
5757: LD_INT 33
5759: PUSH
5760: LD_INT 1
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: PUSH
5767: LD_INT 58
5769: PUSH
5770: EMPTY
5771: LIST
5772: PUSH
5773: EMPTY
5774: LIST
5775: LIST
5776: PPUSH
5777: CALL_OW 72
5781: ST_TO_ADDR
// for i in tmp do
5782: LD_ADDR_VAR 0 5
5786: PUSH
5787: LD_VAR 0 2
5791: PUSH
5792: FOR_IN
5793: IFFALSE 5977
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5795: LD_VAR 0 5
5799: PUSH
5800: LD_INT 55
5802: PUSH
5803: EMPTY
5804: LIST
5805: PPUSH
5806: CALL_OW 69
5810: IN
5811: IFFALSE 5830
// begin AddComMoveXY ( i , 209 , 132 ) ;
5813: LD_VAR 0 5
5817: PPUSH
5818: LD_INT 209
5820: PPUSH
5821: LD_INT 132
5823: PPUSH
5824: CALL_OW 171
// continue ;
5828: GO 5792
// end ; if IsInUnit ( i ) then
5830: LD_VAR 0 5
5834: PPUSH
5835: CALL_OW 310
5839: IFFALSE 5857
// begin ComExitBuilding ( i ) ;
5841: LD_VAR 0 5
5845: PPUSH
5846: CALL_OW 122
// wait ( 3 ) ;
5850: LD_INT 3
5852: PPUSH
5853: CALL_OW 67
// end ; if tmp_empty then
5857: LD_VAR 0 4
5861: IFFALSE 5960
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5863: LD_VAR 0 5
5867: PPUSH
5868: LD_VAR 0 4
5872: PPUSH
5873: LD_VAR 0 5
5877: PPUSH
5878: CALL_OW 74
5882: PPUSH
5883: CALL_OW 296
5887: PUSH
5888: LD_INT 25
5890: LESS
5891: IFFALSE 5960
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5893: LD_ADDR_VAR 0 6
5897: PUSH
5898: LD_VAR 0 4
5902: PPUSH
5903: LD_VAR 0 5
5907: PPUSH
5908: CALL_OW 74
5912: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5913: LD_VAR 0 5
5917: PPUSH
5918: LD_VAR 0 6
5922: PPUSH
5923: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5927: LD_VAR 0 5
5931: PPUSH
5932: LD_INT 209
5934: PPUSH
5935: LD_INT 132
5937: PPUSH
5938: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5942: LD_ADDR_VAR 0 4
5946: PUSH
5947: LD_VAR 0 4
5951: PUSH
5952: LD_VAR 0 6
5956: DIFF
5957: ST_TO_ADDR
// continue ;
5958: GO 5792
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5960: LD_VAR 0 5
5964: PPUSH
5965: LD_INT 201
5967: PPUSH
5968: LD_INT 132
5970: PPUSH
5971: CALL_OW 171
// end ;
5975: GO 5792
5977: POP
5978: POP
// for i in tmp_ape do
5979: LD_ADDR_VAR 0 5
5983: PUSH
5984: LD_VAR 0 3
5988: PUSH
5989: FOR_IN
5990: IFFALSE 6029
// begin if IsInUnit ( i ) then
5992: LD_VAR 0 5
5996: PPUSH
5997: CALL_OW 310
6001: IFFALSE 6012
// ComExitBuilding ( i ) ;
6003: LD_VAR 0 5
6007: PPUSH
6008: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
6012: LD_VAR 0 5
6016: PPUSH
6017: LD_INT 201
6019: PPUSH
6020: LD_INT 132
6022: PPUSH
6023: CALL_OW 171
// end ;
6027: GO 5989
6029: POP
6030: POP
// repeat wait ( 0 0$1 ) ;
6031: LD_INT 35
6033: PPUSH
6034: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
6038: LD_ADDR_VAR 0 5
6042: PUSH
6043: LD_VAR 0 2
6047: PUSH
6048: LD_VAR 0 3
6052: UNION
6053: PUSH
6054: LD_VAR 0 1
6058: UNION
6059: PUSH
6060: FOR_IN
6061: IFFALSE 6092
// if not HasTask ( i ) then
6063: LD_VAR 0 5
6067: PPUSH
6068: CALL_OW 314
6072: NOT
6073: IFFALSE 6090
// ComMoveXY ( i , 201 , 132 ) ;
6075: LD_VAR 0 5
6079: PPUSH
6080: LD_INT 201
6082: PPUSH
6083: LD_INT 132
6085: PPUSH
6086: CALL_OW 111
6090: GO 6060
6092: POP
6093: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
6094: LD_INT 21
6096: PPUSH
6097: LD_INT 22
6099: PUSH
6100: LD_INT 2
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: PPUSH
6107: CALL_OW 70
6111: IFFALSE 6152
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
6113: LD_ADDR_VAR 0 5
6117: PUSH
6118: LD_INT 21
6120: PPUSH
6121: LD_INT 22
6123: PUSH
6124: LD_INT 2
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PPUSH
6131: CALL_OW 70
6135: PUSH
6136: FOR_IN
6137: IFFALSE 6150
// RemoveUnit ( i ) ;
6139: LD_VAR 0 5
6143: PPUSH
6144: CALL_OW 64
6148: GO 6136
6150: POP
6151: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6152: LD_INT 22
6154: PUSH
6155: LD_INT 2
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: PUSH
6162: LD_INT 2
6164: PUSH
6165: LD_INT 21
6167: PUSH
6168: LD_INT 1
6170: PUSH
6171: EMPTY
6172: LIST
6173: LIST
6174: PUSH
6175: LD_INT 21
6177: PUSH
6178: LD_INT 2
6180: PUSH
6181: EMPTY
6182: LIST
6183: LIST
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: LIST
6189: PUSH
6190: EMPTY
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 69
6198: NOT
6199: IFFALSE 6031
// end ;
6201: PPOPN 6
6203: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
6204: LD_EXP 10
6208: PUSH
6209: LD_INT 92
6211: PPUSH
6212: LD_INT 40
6214: PPUSH
6215: CALL_OW 428
6219: PPUSH
6220: CALL_OW 266
6224: PUSH
6225: LD_INT 30
6227: EQUAL
6228: AND
6229: IFFALSE 6425
6231: GO 6233
6233: DISABLE
6234: LD_INT 0
6236: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
6237: LD_ADDR_VAR 0 1
6241: PUSH
6242: LD_EXP 62
6246: PUSH
6247: LD_INT 1
6249: ARRAY
6250: PPUSH
6251: LD_INT 25
6253: PUSH
6254: LD_INT 4
6256: PUSH
6257: EMPTY
6258: LIST
6259: LIST
6260: PPUSH
6261: CALL_OW 72
6265: ST_TO_ADDR
// if not sci then
6266: LD_VAR 0 1
6270: NOT
6271: IFFALSE 6275
// exit ;
6273: GO 6425
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
6275: LD_ADDR_EXP 62
6279: PUSH
6280: LD_EXP 62
6284: PPUSH
6285: LD_INT 1
6287: PPUSH
6288: LD_EXP 62
6292: PUSH
6293: LD_INT 1
6295: ARRAY
6296: PUSH
6297: LD_VAR 0 1
6301: PUSH
6302: LD_INT 1
6304: ARRAY
6305: DIFF
6306: PPUSH
6307: CALL_OW 1
6311: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
6312: LD_VAR 0 1
6316: PUSH
6317: LD_INT 1
6319: ARRAY
6320: PPUSH
6321: CALL_OW 310
6325: IFFALSE 6340
// ComExitBuilding ( sci [ 1 ] ) ;
6327: LD_VAR 0 1
6331: PUSH
6332: LD_INT 1
6334: ARRAY
6335: PPUSH
6336: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
6340: LD_INT 2
6342: PPUSH
6343: LD_INT 105
6345: PPUSH
6346: LD_INT 14
6348: PPUSH
6349: LD_INT 20
6351: PPUSH
6352: CALL 22726 0 4
6356: PUSH
6357: LD_INT 4
6359: ARRAY
6360: PUSH
6361: LD_INT 10
6363: LESS
6364: IFFALSE 6387
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
6366: LD_VAR 0 1
6370: PUSH
6371: LD_INT 1
6373: ARRAY
6374: PPUSH
6375: LD_INT 105
6377: PPUSH
6378: LD_INT 14
6380: PPUSH
6381: CALL_OW 171
6385: GO 6406
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
6387: LD_VAR 0 1
6391: PUSH
6392: LD_INT 1
6394: ARRAY
6395: PPUSH
6396: LD_INT 118
6398: PPUSH
6399: LD_INT 77
6401: PPUSH
6402: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
6406: LD_VAR 0 1
6410: PUSH
6411: LD_INT 1
6413: ARRAY
6414: PPUSH
6415: LD_INT 92
6417: PPUSH
6418: LD_INT 40
6420: PPUSH
6421: CALL_OW 218
// end ;
6425: PPOPN 1
6427: END
// every 6 6$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
6428: LD_INT 1
6430: PPUSH
6431: CALL_OW 302
6435: PUSH
6436: LD_EXP 10
6440: AND
6441: IFFALSE 7330
6443: GO 6445
6445: DISABLE
6446: LD_INT 0
6448: PPUSH
6449: PPUSH
6450: PPUSH
6451: PPUSH
6452: PPUSH
6453: PPUSH
6454: PPUSH
6455: PPUSH
// begin enable ;
6456: ENABLE
// base := 1 ;
6457: LD_ADDR_VAR 0 3
6461: PUSH
6462: LD_INT 1
6464: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6465: LD_ADDR_VAR 0 5
6469: PUSH
6470: LD_INT 0
6472: PUSH
6473: LD_INT 0
6475: PUSH
6476: LD_INT 0
6478: PUSH
6479: LD_INT 0
6481: PUSH
6482: LD_INT 0
6484: PUSH
6485: LD_INT 0
6487: PUSH
6488: LD_INT 0
6490: PUSH
6491: LD_INT 0
6493: PUSH
6494: LD_INT 1
6496: PUSH
6497: LD_INT 0
6499: PUSH
6500: EMPTY
6501: LIST
6502: LIST
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: LIST
6510: LIST
6511: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6512: LD_ADDR_VAR 0 4
6516: PUSH
6517: LD_INT 13
6519: PUSH
6520: LD_INT 1
6522: PUSH
6523: LD_INT 2
6525: PUSH
6526: LD_INT 26
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: LIST
6533: LIST
6534: PUSH
6535: LD_INT 13
6537: PUSH
6538: LD_INT 1
6540: PUSH
6541: LD_INT 2
6543: PUSH
6544: LD_INT 28
6546: PUSH
6547: EMPTY
6548: LIST
6549: LIST
6550: LIST
6551: LIST
6552: PUSH
6553: LD_INT 13
6555: PUSH
6556: LD_INT 1
6558: PUSH
6559: LD_INT 2
6561: PUSH
6562: LD_INT 29
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: LIST
6569: LIST
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: LIST
6575: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6576: LD_ADDR_VAR 0 1
6580: PUSH
6581: DOUBLE
6582: LD_INT 1
6584: DEC
6585: ST_TO_ADDR
6586: LD_OWVAR 67
6590: PUSH
6591: LD_OWVAR 1
6595: PUSH
6596: LD_INT 21000
6598: DIV
6599: PLUS
6600: PUSH
6601: FOR_TO
6602: IFFALSE 6675
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6604: LD_ADDR_VAR 0 4
6608: PUSH
6609: LD_VAR 0 4
6613: PPUSH
6614: LD_VAR 0 4
6618: PUSH
6619: LD_INT 1
6621: PLUS
6622: PPUSH
6623: LD_INT 13
6625: PUSH
6626: LD_INT 1
6628: PUSH
6629: LD_INT 2
6631: PUSH
6632: LD_INT 28
6634: PUSH
6635: LD_INT 29
6637: PUSH
6638: LD_INT 25
6640: PUSH
6641: LD_INT 26
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: LIST
6648: LIST
6649: PUSH
6650: LD_INT 1
6652: PPUSH
6653: LD_INT 4
6655: PPUSH
6656: CALL_OW 12
6660: ARRAY
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: LIST
6666: LIST
6667: PPUSH
6668: CALL_OW 2
6672: ST_TO_ADDR
6673: GO 6601
6675: POP
6676: POP
// MC_InsertProduceList ( base , tmp ) ;
6677: LD_VAR 0 3
6681: PPUSH
6682: LD_VAR 0 4
6686: PPUSH
6687: CALL 83557 0 2
// wait ( 3 3$20 ) ;
6691: LD_INT 7000
6693: PPUSH
6694: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6698: LD_ADDR_VAR 0 6
6702: PUSH
6703: LD_INT 124
6705: PUSH
6706: LD_INT 85
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PUSH
6713: LD_INT 90
6715: PUSH
6716: LD_INT 61
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 69
6725: PUSH
6726: LD_INT 48
6728: PUSH
6729: EMPTY
6730: LIST
6731: LIST
6732: PUSH
6733: LD_INT 68
6735: PUSH
6736: LD_INT 48
6738: PUSH
6739: EMPTY
6740: LIST
6741: LIST
6742: PUSH
6743: EMPTY
6744: LIST
6745: LIST
6746: LIST
6747: LIST
6748: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ] ] ) diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6749: LD_ADDR_VAR 0 7
6753: PUSH
6754: LD_INT 22
6756: PUSH
6757: LD_INT 2
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: PUSH
6764: LD_INT 23
6766: PUSH
6767: LD_INT 2
6769: PUSH
6770: EMPTY
6771: LIST
6772: LIST
6773: PUSH
6774: LD_INT 21
6776: PUSH
6777: LD_INT 2
6779: PUSH
6780: EMPTY
6781: LIST
6782: LIST
6783: PUSH
6784: LD_INT 3
6786: PUSH
6787: LD_INT 2
6789: PUSH
6790: LD_INT 34
6792: PUSH
6793: LD_INT 31
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PUSH
6800: LD_INT 34
6802: PUSH
6803: LD_INT 88
6805: PUSH
6806: EMPTY
6807: LIST
6808: LIST
6809: PUSH
6810: LD_INT 34
6812: PUSH
6813: LD_INT 32
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PUSH
6820: EMPTY
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: PUSH
6826: EMPTY
6827: LIST
6828: LIST
6829: PUSH
6830: EMPTY
6831: LIST
6832: LIST
6833: LIST
6834: LIST
6835: PPUSH
6836: CALL_OW 69
6840: PUSH
6841: LD_EXP 81
6845: PUSH
6846: LD_VAR 0 3
6850: ARRAY
6851: PPUSH
6852: LD_INT 2
6854: PUSH
6855: LD_INT 34
6857: PUSH
6858: LD_INT 32
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: PUSH
6865: LD_INT 34
6867: PUSH
6868: LD_INT 88
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: PPUSH
6880: CALL_OW 72
6884: DIFF
6885: ST_TO_ADDR
// if rand ( 0 , 1 ) then
6886: LD_INT 0
6888: PPUSH
6889: LD_INT 1
6891: PPUSH
6892: CALL_OW 12
6896: IFFALSE 7046
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
6898: LD_ADDR_VAR 0 1
6902: PUSH
6903: DOUBLE
6904: LD_INT 1
6906: DEC
6907: ST_TO_ADDR
6908: LD_INT 3
6910: PUSH
6911: LD_INT 4
6913: PUSH
6914: LD_INT 5
6916: PUSH
6917: LD_INT 6
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: LIST
6924: LIST
6925: PUSH
6926: LD_OWVAR 67
6930: ARRAY
6931: PUSH
6932: FOR_TO
6933: IFFALSE 7042
// begin uc_side := 2 ;
6935: LD_ADDR_OWVAR 20
6939: PUSH
6940: LD_INT 2
6942: ST_TO_ADDR
// uc_nation := 2 ;
6943: LD_ADDR_OWVAR 21
6947: PUSH
6948: LD_INT 2
6950: ST_TO_ADDR
// InitHc ;
6951: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6955: LD_INT 0
6957: PPUSH
6958: LD_INT 15
6960: PUSH
6961: LD_INT 17
6963: PUSH
6964: EMPTY
6965: LIST
6966: LIST
6967: PUSH
6968: LD_INT 1
6970: PPUSH
6971: LD_INT 2
6973: PPUSH
6974: CALL_OW 12
6978: ARRAY
6979: PPUSH
6980: LD_INT 8
6982: PPUSH
6983: CALL_OW 380
// un := CreateHuman ;
6987: LD_ADDR_VAR 0 2
6991: PUSH
6992: CALL_OW 44
6996: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6997: LD_VAR 0 2
7001: PPUSH
7002: LD_INT 4
7004: PPUSH
7005: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7009: LD_VAR 0 2
7013: PPUSH
7014: LD_INT 23
7016: PPUSH
7017: LD_INT 0
7019: PPUSH
7020: CALL_OW 49
// attackers := attackers union un ;
7024: LD_ADDR_VAR 0 7
7028: PUSH
7029: LD_VAR 0 7
7033: PUSH
7034: LD_VAR 0 2
7038: UNION
7039: ST_TO_ADDR
// end ;
7040: GO 6932
7042: POP
7043: POP
// end else
7044: GO 7204
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
7046: LD_ADDR_VAR 0 1
7050: PUSH
7051: DOUBLE
7052: LD_INT 1
7054: DEC
7055: ST_TO_ADDR
7056: LD_INT 2
7058: PUSH
7059: LD_INT 3
7061: PUSH
7062: LD_INT 4
7064: PUSH
7065: LD_INT 5
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: LIST
7072: LIST
7073: PUSH
7074: LD_OWVAR 67
7078: ARRAY
7079: PUSH
7080: FOR_TO
7081: IFFALSE 7202
// begin uc_side := 2 ;
7083: LD_ADDR_OWVAR 20
7087: PUSH
7088: LD_INT 2
7090: ST_TO_ADDR
// uc_nation := 2 ;
7091: LD_ADDR_OWVAR 21
7095: PUSH
7096: LD_INT 2
7098: ST_TO_ADDR
// InitHc ;
7099: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
7103: LD_INT 14
7105: PPUSH
7106: LD_INT 3
7108: PPUSH
7109: LD_INT 5
7111: PPUSH
7112: LD_INT 29
7114: PUSH
7115: LD_INT 29
7117: PUSH
7118: LD_INT 26
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: LIST
7125: PUSH
7126: LD_VAR 0 1
7130: PUSH
7131: LD_INT 3
7133: MOD
7134: PUSH
7135: LD_INT 1
7137: PLUS
7138: ARRAY
7139: PPUSH
7140: LD_INT 100
7142: PPUSH
7143: CALL 21340 0 5
// un := CreateVehicle ;
7147: LD_ADDR_VAR 0 2
7151: PUSH
7152: CALL_OW 45
7156: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7157: LD_VAR 0 2
7161: PPUSH
7162: LD_INT 4
7164: PPUSH
7165: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7169: LD_VAR 0 2
7173: PPUSH
7174: LD_INT 23
7176: PPUSH
7177: LD_INT 0
7179: PPUSH
7180: CALL_OW 49
// attackers := attackers union un ;
7184: LD_ADDR_VAR 0 7
7188: PUSH
7189: LD_VAR 0 7
7193: PUSH
7194: LD_VAR 0 2
7198: UNION
7199: ST_TO_ADDR
// end ;
7200: GO 7080
7202: POP
7203: POP
// end ; if not attackers then
7204: LD_VAR 0 7
7208: NOT
7209: IFFALSE 7213
// exit ;
7211: GO 7330
// ar_attackers := attackers ;
7213: LD_ADDR_EXP 12
7217: PUSH
7218: LD_VAR 0 7
7222: ST_TO_ADDR
// p := 0 ;
7223: LD_ADDR_VAR 0 8
7227: PUSH
7228: LD_INT 0
7230: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7231: LD_INT 35
7233: PPUSH
7234: CALL_OW 67
// p := Inc ( p ) ;
7238: LD_ADDR_VAR 0 8
7242: PUSH
7243: LD_VAR 0 8
7247: PPUSH
7248: CALL 55552 0 1
7252: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7253: LD_VAR 0 7
7257: PPUSH
7258: LD_INT 60
7260: PUSH
7261: EMPTY
7262: LIST
7263: PPUSH
7264: CALL_OW 72
7268: NOT
7269: PUSH
7270: LD_VAR 0 8
7274: PUSH
7275: LD_INT 30
7277: GREATER
7278: OR
7279: IFFALSE 7231
// repeat wait ( 0 0$1 ) ;
7281: LD_INT 35
7283: PPUSH
7284: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
7288: LD_ADDR_VAR 0 7
7292: PUSH
7293: LD_VAR 0 7
7297: PPUSH
7298: LD_INT 50
7300: PUSH
7301: EMPTY
7302: LIST
7303: PPUSH
7304: CALL_OW 72
7308: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
7309: LD_VAR 0 7
7313: PPUSH
7314: LD_VAR 0 6
7318: PPUSH
7319: CALL 56795 0 2
// until not attackers ;
7323: LD_VAR 0 7
7327: NOT
7328: IFFALSE 7281
// end ;
7330: PPOPN 8
7332: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
7333: LD_INT 1
7335: PPUSH
7336: CALL_OW 302
7340: PUSH
7341: LD_EXP 10
7345: AND
7346: PUSH
7347: LD_EXP 52
7351: PPUSH
7352: LD_INT 22
7354: PPUSH
7355: CALL_OW 308
7359: AND
7360: IFFALSE 7848
7362: GO 7364
7364: DISABLE
7365: LD_INT 0
7367: PPUSH
7368: PPUSH
7369: PPUSH
7370: PPUSH
7371: PPUSH
7372: PPUSH
7373: PPUSH
7374: PPUSH
// begin base := 1 ;
7375: LD_ADDR_VAR 0 2
7379: PUSH
7380: LD_INT 1
7382: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7383: LD_ADDR_VAR 0 4
7387: PUSH
7388: LD_INT 0
7390: PUSH
7391: LD_INT 0
7393: PUSH
7394: LD_INT 0
7396: PUSH
7397: LD_INT 0
7399: PUSH
7400: LD_INT 0
7402: PUSH
7403: LD_INT 0
7405: PUSH
7406: LD_INT 0
7408: PUSH
7409: LD_INT 0
7411: PUSH
7412: LD_INT 1
7414: PUSH
7415: LD_INT 0
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: LIST
7424: LIST
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
7430: LD_ADDR_VAR 0 3
7434: PUSH
7435: LD_INT 13
7437: PUSH
7438: LD_INT 1
7440: PUSH
7441: LD_INT 2
7443: PUSH
7444: LD_INT 28
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: LIST
7451: LIST
7452: PUSH
7453: LD_INT 13
7455: PUSH
7456: LD_INT 1
7458: PUSH
7459: LD_INT 2
7461: PUSH
7462: LD_INT 27
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: PUSH
7471: LD_INT 13
7473: PUSH
7474: LD_INT 1
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 25
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 11
7491: PUSH
7492: LD_INT 2
7494: PUSH
7495: LD_INT 2
7497: PUSH
7498: LD_INT 24
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 11
7509: PUSH
7510: LD_INT 2
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 24
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: LIST
7523: LIST
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: LIST
7529: LIST
7530: LIST
7531: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7532: LD_VAR 0 2
7536: PPUSH
7537: LD_VAR 0 3
7541: PPUSH
7542: CALL 83557 0 2
// wait ( 4 4$20 ) ;
7546: LD_INT 9100
7548: PPUSH
7549: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
7553: LD_ADDR_VAR 0 5
7557: PUSH
7558: LD_INT 119
7560: PUSH
7561: LD_INT 9
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: PUSH
7568: EMPTY
7569: LIST
7570: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7571: LD_ADDR_VAR 0 6
7575: PUSH
7576: LD_EXP 81
7580: PUSH
7581: LD_VAR 0 2
7585: ARRAY
7586: PUSH
7587: LD_EXP 81
7591: PUSH
7592: LD_VAR 0 2
7596: ARRAY
7597: PPUSH
7598: LD_INT 2
7600: PUSH
7601: LD_INT 34
7603: PUSH
7604: LD_INT 32
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: LD_INT 34
7613: PUSH
7614: LD_INT 88
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: LIST
7625: PPUSH
7626: CALL_OW 72
7630: DIFF
7631: ST_TO_ADDR
// uc_side := 2 ;
7632: LD_ADDR_OWVAR 20
7636: PUSH
7637: LD_INT 2
7639: ST_TO_ADDR
// uc_nation := 2 ;
7640: LD_ADDR_OWVAR 21
7644: PUSH
7645: LD_INT 2
7647: ST_TO_ADDR
// InitHc ;
7648: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7652: LD_ADDR_VAR 0 1
7656: PUSH
7657: DOUBLE
7658: LD_INT 1
7660: DEC
7661: ST_TO_ADDR
7662: LD_INT 4
7664: PUSH
7665: LD_INT 5
7667: PUSH
7668: LD_INT 6
7670: PUSH
7671: LD_INT 6
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: LIST
7678: LIST
7679: PUSH
7680: LD_OWVAR 67
7684: ARRAY
7685: PUSH
7686: FOR_TO
7687: IFFALSE 7764
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7689: LD_INT 0
7691: PPUSH
7692: LD_INT 15
7694: PUSH
7695: LD_INT 17
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: PUSH
7702: LD_INT 1
7704: PPUSH
7705: LD_INT 2
7707: PPUSH
7708: CALL_OW 12
7712: ARRAY
7713: PPUSH
7714: LD_INT 8
7716: PPUSH
7717: CALL_OW 380
// un := CreateHuman ;
7721: LD_ADDR_VAR 0 7
7725: PUSH
7726: CALL_OW 44
7730: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7731: LD_VAR 0 7
7735: PPUSH
7736: LD_INT 23
7738: PPUSH
7739: LD_INT 0
7741: PPUSH
7742: CALL_OW 49
// attackers := attackers union un ;
7746: LD_ADDR_VAR 0 6
7750: PUSH
7751: LD_VAR 0 6
7755: PUSH
7756: LD_VAR 0 7
7760: UNION
7761: ST_TO_ADDR
// end ;
7762: GO 7686
7764: POP
7765: POP
// p := 0 ;
7766: LD_ADDR_VAR 0 8
7770: PUSH
7771: LD_INT 0
7773: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7774: LD_INT 35
7776: PPUSH
7777: CALL_OW 67
// p := Inc ( p ) ;
7781: LD_ADDR_VAR 0 8
7785: PUSH
7786: LD_VAR 0 8
7790: PPUSH
7791: CALL 55552 0 1
7795: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7796: LD_VAR 0 6
7800: PPUSH
7801: LD_INT 60
7803: PUSH
7804: EMPTY
7805: LIST
7806: PPUSH
7807: CALL_OW 72
7811: NOT
7812: PUSH
7813: LD_VAR 0 8
7817: PUSH
7818: LD_INT 30
7820: GREATER
7821: OR
7822: IFFALSE 7774
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7824: LD_VAR 0 2
7828: PPUSH
7829: LD_VAR 0 6
7833: PPUSH
7834: LD_VAR 0 5
7838: PPUSH
7839: LD_VAR 0 4
7843: PPUSH
7844: CALL 83742 0 4
// end ; end_of_file
7848: PPOPN 8
7850: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
7851: LD_INT 0
7853: PPUSH
7854: PPUSH
7855: PPUSH
7856: PPUSH
7857: PPUSH
7858: PPUSH
// uc_side := 1 ;
7859: LD_ADDR_OWVAR 20
7863: PUSH
7864: LD_INT 1
7866: ST_TO_ADDR
// uc_nation := 1 ;
7867: LD_ADDR_OWVAR 21
7871: PUSH
7872: LD_INT 1
7874: ST_TO_ADDR
// InitHc ;
7875: CALL_OW 19
// InitVc ;
7879: CALL_OW 20
// tmp := [ ] ;
7883: LD_ADDR_VAR 0 3
7887: PUSH
7888: EMPTY
7889: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
7890: LD_ADDR_VAR 0 2
7894: PUSH
7895: DOUBLE
7896: LD_INT 1
7898: DEC
7899: ST_TO_ADDR
7900: LD_INT 6
7902: PUSH
7903: LD_INT 8
7905: PUSH
7906: LD_INT 10
7908: PUSH
7909: LD_INT 10
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: LIST
7916: LIST
7917: PUSH
7918: LD_OWVAR 67
7922: ARRAY
7923: PUSH
7924: FOR_TO
7925: IFFALSE 8215
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
7927: LD_ADDR_VAR 0 5
7931: PUSH
7932: LD_INT 2
7934: PUSH
7935: LD_INT 4
7937: PUSH
7938: LD_INT 5
7940: PUSH
7941: EMPTY
7942: LIST
7943: LIST
7944: LIST
7945: PUSH
7946: LD_INT 1
7948: PPUSH
7949: LD_INT 3
7951: PPUSH
7952: CALL_OW 12
7956: ARRAY
7957: ST_TO_ADDR
// case chassis of us_medium_wheeled :
7958: LD_VAR 0 5
7962: PUSH
7963: LD_INT 2
7965: DOUBLE
7966: EQUAL
7967: IFTRUE 7971
7969: GO 8005
7971: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7972: LD_ADDR_VAR 0 6
7976: PUSH
7977: LD_INT 9
7979: PUSH
7980: LD_INT 5
7982: PUSH
7983: LD_INT 7
7985: PUSH
7986: EMPTY
7987: LIST
7988: LIST
7989: LIST
7990: PUSH
7991: LD_INT 1
7993: PPUSH
7994: LD_INT 3
7996: PPUSH
7997: CALL_OW 12
8001: ARRAY
8002: ST_TO_ADDR
8003: GO 8094
8005: LD_INT 4
8007: DOUBLE
8008: EQUAL
8009: IFTRUE 8013
8011: GO 8051
8013: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
8014: LD_ADDR_VAR 0 6
8018: PUSH
8019: LD_INT 9
8021: PUSH
8022: LD_INT 6
8024: PUSH
8025: LD_INT 6
8027: PUSH
8028: LD_INT 7
8030: PUSH
8031: EMPTY
8032: LIST
8033: LIST
8034: LIST
8035: LIST
8036: PUSH
8037: LD_INT 1
8039: PPUSH
8040: LD_INT 4
8042: PPUSH
8043: CALL_OW 12
8047: ARRAY
8048: ST_TO_ADDR
8049: GO 8094
8051: LD_INT 5
8053: DOUBLE
8054: EQUAL
8055: IFTRUE 8059
8057: GO 8093
8059: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
8060: LD_ADDR_VAR 0 6
8064: PUSH
8065: LD_INT 9
8067: PUSH
8068: LD_INT 6
8070: PUSH
8071: LD_INT 7
8073: PUSH
8074: EMPTY
8075: LIST
8076: LIST
8077: LIST
8078: PUSH
8079: LD_INT 1
8081: PPUSH
8082: LD_INT 3
8084: PPUSH
8085: CALL_OW 12
8089: ARRAY
8090: ST_TO_ADDR
8091: GO 8094
8093: POP
// uc_side := 1 ;
8094: LD_ADDR_OWVAR 20
8098: PUSH
8099: LD_INT 1
8101: ST_TO_ADDR
// uc_nation := 1 ;
8102: LD_ADDR_OWVAR 21
8106: PUSH
8107: LD_INT 1
8109: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
8110: LD_VAR 0 5
8114: PPUSH
8115: LD_INT 1
8117: PUSH
8118: LD_INT 3
8120: PUSH
8121: EMPTY
8122: LIST
8123: LIST
8124: PUSH
8125: LD_INT 1
8127: PPUSH
8128: LD_INT 2
8130: PPUSH
8131: CALL_OW 12
8135: ARRAY
8136: PPUSH
8137: LD_INT 3
8139: PPUSH
8140: LD_VAR 0 6
8144: PPUSH
8145: LD_INT 70
8147: PPUSH
8148: LD_INT 90
8150: PPUSH
8151: CALL_OW 12
8155: PPUSH
8156: CALL 21340 0 5
// veh := CreateVehicle ;
8160: LD_ADDR_VAR 0 4
8164: PUSH
8165: CALL_OW 45
8169: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8170: LD_VAR 0 4
8174: PPUSH
8175: LD_INT 2
8177: PPUSH
8178: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8182: LD_VAR 0 4
8186: PPUSH
8187: LD_INT 17
8189: PPUSH
8190: LD_INT 0
8192: PPUSH
8193: CALL_OW 49
// tmp := tmp ^ veh ;
8197: LD_ADDR_VAR 0 3
8201: PUSH
8202: LD_VAR 0 3
8206: PUSH
8207: LD_VAR 0 4
8211: ADD
8212: ST_TO_ADDR
// end ;
8213: GO 7924
8215: POP
8216: POP
// if not tmp then
8217: LD_VAR 0 3
8221: NOT
8222: IFFALSE 8226
// exit ;
8224: GO 8335
// if not first_powell_attack then
8226: LD_EXP 13
8230: NOT
8231: IFFALSE 8241
// first_powell_attack := true ;
8233: LD_ADDR_EXP 13
8237: PUSH
8238: LD_INT 1
8240: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
8241: LD_INT 70
8243: PPUSH
8244: CALL_OW 67
// for i in tmp do
8248: LD_ADDR_VAR 0 2
8252: PUSH
8253: LD_VAR 0 3
8257: PUSH
8258: FOR_IN
8259: IFFALSE 8326
// if IsOk ( i ) then
8261: LD_VAR 0 2
8265: PPUSH
8266: CALL_OW 302
8270: IFFALSE 8308
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
8272: LD_VAR 0 2
8276: PPUSH
8277: LD_INT 81
8279: PUSH
8280: LD_INT 1
8282: PUSH
8283: EMPTY
8284: LIST
8285: LIST
8286: PPUSH
8287: CALL_OW 69
8291: PPUSH
8292: LD_VAR 0 2
8296: PPUSH
8297: CALL_OW 74
8301: PPUSH
8302: CALL_OW 115
8306: GO 8324
// tmp := tmp diff i ;
8308: LD_ADDR_VAR 0 3
8312: PUSH
8313: LD_VAR 0 3
8317: PUSH
8318: LD_VAR 0 2
8322: DIFF
8323: ST_TO_ADDR
8324: GO 8258
8326: POP
8327: POP
// until not tmp ;
8328: LD_VAR 0 3
8332: NOT
8333: IFFALSE 8241
// end ;
8335: LD_VAR 0 1
8339: RET
// export function TryToStoleArtifact ( artifact ) ; var veh ; begin
8340: LD_INT 0
8342: PPUSH
8343: PPUSH
// uc_side := 1 ;
8344: LD_ADDR_OWVAR 20
8348: PUSH
8349: LD_INT 1
8351: ST_TO_ADDR
// uc_nation := 1 ;
8352: LD_ADDR_OWVAR 21
8356: PUSH
8357: LD_INT 1
8359: ST_TO_ADDR
// InitHc ;
8360: CALL_OW 19
// InitVc ;
8364: CALL_OW 20
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
8368: LD_INT 5
8370: PPUSH
8371: LD_INT 3
8373: PPUSH
8374: LD_INT 3
8376: PPUSH
8377: LD_INT 12
8379: PPUSH
8380: LD_INT 100
8382: PPUSH
8383: CALL 21340 0 5
// veh := CreateVehicle ;
8387: LD_ADDR_VAR 0 3
8391: PUSH
8392: CALL_OW 45
8396: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8397: LD_VAR 0 3
8401: PPUSH
8402: LD_INT 2
8404: PPUSH
8405: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8409: LD_VAR 0 3
8413: PPUSH
8414: LD_INT 17
8416: PPUSH
8417: LD_INT 0
8419: PPUSH
8420: CALL_OW 49
// ComGet ( veh , artifact [ 1 ] , artifact [ 2 ] ) ;
8424: LD_VAR 0 3
8428: PPUSH
8429: LD_VAR 0 1
8433: PUSH
8434: LD_INT 1
8436: ARRAY
8437: PPUSH
8438: LD_VAR 0 1
8442: PUSH
8443: LD_INT 2
8445: ARRAY
8446: PPUSH
8447: CALL_OW 160
// AddComMoveXY ( veh , 59 , 2 ) ;
8451: LD_VAR 0 3
8455: PPUSH
8456: LD_INT 59
8458: PPUSH
8459: LD_INT 2
8461: PPUSH
8462: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8466: LD_INT 35
8468: PPUSH
8469: CALL_OW 67
// if not IsOk ( veh ) then
8473: LD_VAR 0 3
8477: PPUSH
8478: CALL_OW 302
8482: NOT
8483: IFFALSE 8487
// exit ;
8485: GO 8541
// until IsAt ( veh , 59 , 2 ) ;
8487: LD_VAR 0 3
8491: PPUSH
8492: LD_INT 59
8494: PPUSH
8495: LD_INT 2
8497: PPUSH
8498: CALL_OW 307
8502: IFFALSE 8466
// RemoveUnit ( veh ) ;
8504: LD_VAR 0 3
8508: PPUSH
8509: CALL_OW 64
// if GetCargo ( veh , mat_artifact ) then
8513: LD_VAR 0 3
8517: PPUSH
8518: LD_INT 4
8520: PPUSH
8521: CALL_OW 289
8525: IFFALSE 8541
// begin wait ( 0 0$2 ) ;
8527: LD_INT 70
8529: PPUSH
8530: CALL_OW 67
// YouLost ( Artifact ) ;
8534: LD_STRING Artifact
8536: PPUSH
8537: CALL_OW 104
// end ; end ; end_of_file
8541: LD_VAR 0 2
8545: RET
// export function Action ; var tmp , i , un ; begin
8546: LD_INT 0
8548: PPUSH
8549: PPUSH
8550: PPUSH
8551: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
8552: LD_INT 68
8554: PPUSH
8555: LD_INT 39
8557: PPUSH
8558: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
8562: LD_ADDR_VAR 0 2
8566: PUSH
8567: LD_INT 22
8569: PUSH
8570: LD_INT 7
8572: PUSH
8573: EMPTY
8574: LIST
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: ST_TO_ADDR
// InGameOn ;
8582: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
8586: LD_VAR 0 2
8590: PPUSH
8591: LD_INT 71
8593: PPUSH
8594: LD_INT 49
8596: PPUSH
8597: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8601: LD_INT 35
8603: PPUSH
8604: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
8608: LD_INT 7
8610: PPUSH
8611: LD_INT 71
8613: PPUSH
8614: LD_INT 51
8616: PPUSH
8617: CALL_OW 293
8621: IFFALSE 8601
// DialogueOn ;
8623: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
8627: LD_EXP 17
8631: PPUSH
8632: LD_STRING D1-JMM-1
8634: PPUSH
8635: CALL_OW 88
// if Joan then
8639: LD_EXP 32
8643: IFFALSE 8657
// Say ( Joan , D1-Joan-1 ) ;
8645: LD_EXP 32
8649: PPUSH
8650: LD_STRING D1-Joan-1
8652: PPUSH
8653: CALL_OW 88
// if Lisa then
8657: LD_EXP 19
8661: IFFALSE 8675
// Say ( Lisa , D1-Lisa-1 ) ;
8663: LD_EXP 19
8667: PPUSH
8668: LD_STRING D1-Lisa-1
8670: PPUSH
8671: CALL_OW 88
// if Joan or Lisa then
8675: LD_EXP 32
8679: PUSH
8680: LD_EXP 19
8684: OR
8685: IFFALSE 8699
// Say ( JMM , D1-JMM-2 ) ;
8687: LD_EXP 17
8691: PPUSH
8692: LD_STRING D1-JMM-2
8694: PPUSH
8695: CALL_OW 88
// DialogueOff ;
8699: CALL_OW 7
// InGameOff ;
8703: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
8707: LD_INT 71
8709: PPUSH
8710: LD_INT 50
8712: PPUSH
8713: LD_INT 7
8715: PPUSH
8716: LD_INT 30
8718: NEG
8719: PPUSH
8720: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
8724: LD_INT 71
8726: PPUSH
8727: LD_INT 50
8729: PPUSH
8730: LD_INT 7
8732: PPUSH
8733: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
8737: LD_STRING M1
8739: PPUSH
8740: CALL_OW 337
// SaveForQuickRestart ;
8744: CALL_OW 22
// repeat wait ( 0 0$1 ) ;
8748: LD_INT 35
8750: PPUSH
8751: CALL_OW 67
// until freedom or tick > 1 1$00 ;
8755: LD_EXP 3
8759: PUSH
8760: LD_OWVAR 1
8764: PUSH
8765: LD_INT 2100
8767: GREATER
8768: OR
8769: IFFALSE 8748
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
8771: LD_INT 350
8773: PPUSH
8774: LD_INT 700
8776: PPUSH
8777: CALL_OW 12
8781: PPUSH
8782: CALL_OW 67
// PrepareGossudarov ;
8786: CALL 1943 0 0
// repeat wait ( 0 0$1 ) ;
8790: LD_INT 35
8792: PPUSH
8793: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
8797: LD_INT 22
8799: PUSH
8800: LD_INT 6
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 3
8809: PUSH
8810: LD_INT 24
8812: PUSH
8813: LD_INT 1000
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PUSH
8824: EMPTY
8825: LIST
8826: LIST
8827: PPUSH
8828: CALL_OW 69
8832: PUSH
8833: LD_INT 7
8835: PPUSH
8836: LD_EXP 35
8840: PPUSH
8841: CALL_OW 292
8845: OR
8846: IFFALSE 8790
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
8848: LD_ADDR_VAR 0 2
8852: PUSH
8853: LD_INT 22
8855: PUSH
8856: LD_INT 6
8858: PUSH
8859: EMPTY
8860: LIST
8861: LIST
8862: PPUSH
8863: CALL_OW 69
8867: ST_TO_ADDR
// for i in tmp do
8868: LD_ADDR_VAR 0 3
8872: PUSH
8873: LD_VAR 0 2
8877: PUSH
8878: FOR_IN
8879: IFFALSE 8895
// SetSide ( i , 7 ) ;
8881: LD_VAR 0 3
8885: PPUSH
8886: LD_INT 7
8888: PPUSH
8889: CALL_OW 235
8893: GO 8878
8895: POP
8896: POP
// DialogueOn ;
8897: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
8901: LD_EXP 17
8905: PUSH
8906: LD_EXP 18
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PPUSH
8915: LD_EXP 35
8919: PPUSH
8920: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
8924: LD_EXP 35
8928: PPUSH
8929: CALL_OW 87
// if not Roth then
8933: LD_EXP 18
8937: NOT
8938: IFFALSE 9030
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8940: LD_VAR 0 2
8944: PPUSH
8945: LD_INT 3
8947: PUSH
8948: LD_INT 24
8950: PUSH
8951: LD_INT 1000
8953: PUSH
8954: EMPTY
8955: LIST
8956: LIST
8957: PUSH
8958: EMPTY
8959: LIST
8960: LIST
8961: PPUSH
8962: CALL_OW 72
8966: IFFALSE 8980
// Say ( JMM , D2-JMM-1 ) ;
8968: LD_EXP 17
8972: PPUSH
8973: LD_STRING D2-JMM-1
8975: PPUSH
8976: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
8980: LD_EXP 17
8984: PPUSH
8985: LD_STRING D2-JMM-1b
8987: PPUSH
8988: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
8992: LD_EXP 35
8996: PPUSH
8997: LD_STRING D2-Gos-1
8999: PPUSH
9000: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
9004: LD_EXP 17
9008: PPUSH
9009: LD_STRING D2-JMM-2
9011: PPUSH
9012: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
9016: LD_EXP 35
9020: PPUSH
9021: LD_STRING D2-Gos-2
9023: PPUSH
9024: CALL_OW 88
// end else
9028: GO 9182
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9030: LD_VAR 0 2
9034: PPUSH
9035: LD_INT 3
9037: PUSH
9038: LD_INT 24
9040: PUSH
9041: LD_INT 1000
9043: PUSH
9044: EMPTY
9045: LIST
9046: LIST
9047: PUSH
9048: EMPTY
9049: LIST
9050: LIST
9051: PPUSH
9052: CALL_OW 72
9056: IFFALSE 9082
// begin Say ( Roth , D2-Roth-2 ) ;
9058: LD_EXP 18
9062: PPUSH
9063: LD_STRING D2-Roth-2
9065: PPUSH
9066: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
9070: LD_EXP 17
9074: PPUSH
9075: LD_STRING D2-JMM-1a
9077: PPUSH
9078: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
9082: LD_EXP 18
9086: PPUSH
9087: LD_STRING D2-Roth-2a
9089: PPUSH
9090: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
9094: LD_EXP 18
9098: PPUSH
9099: LD_STRING D2-Roth-2b
9101: PPUSH
9102: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
9106: LD_EXP 17
9110: PPUSH
9111: LD_STRING D2-JMM-3
9113: PPUSH
9114: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9118: LD_VAR 0 2
9122: PPUSH
9123: LD_INT 3
9125: PUSH
9126: LD_INT 24
9128: PUSH
9129: LD_INT 1000
9131: PUSH
9132: EMPTY
9133: LIST
9134: LIST
9135: PUSH
9136: EMPTY
9137: LIST
9138: LIST
9139: PPUSH
9140: CALL_OW 72
9144: IFFALSE 9182
// begin Say ( Gossudarov , D2-Gos-3 ) ;
9146: LD_EXP 35
9150: PPUSH
9151: LD_STRING D2-Gos-3
9153: PPUSH
9154: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
9158: LD_EXP 17
9162: PPUSH
9163: LD_STRING D2-JMM-4
9165: PPUSH
9166: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
9170: LD_EXP 35
9174: PPUSH
9175: LD_STRING D2-Gos-4
9177: PPUSH
9178: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
9182: LD_EXP 17
9186: PPUSH
9187: LD_STRING D2-JMM-5
9189: PPUSH
9190: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
9194: LD_EXP 35
9198: PPUSH
9199: LD_STRING D2-Gos-5
9201: PPUSH
9202: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
9206: LD_EXP 17
9210: PPUSH
9211: LD_STRING D2-JMM-6
9213: PPUSH
9214: CALL_OW 88
// DialogueOff ;
9218: CALL_OW 7
// wait ( 0 0$2 ) ;
9222: LD_INT 70
9224: PPUSH
9225: CALL_OW 67
// if Kirilenkova then
9229: LD_EXP 36
9233: IFFALSE 9247
// Say ( Kirilenkova , D3-Kir-1 ) ;
9235: LD_EXP 36
9239: PPUSH
9240: LD_STRING D3-Kir-1
9242: PPUSH
9243: CALL_OW 88
// gossudarov_arrive := true ;
9247: LD_ADDR_EXP 4
9251: PUSH
9252: LD_INT 1
9254: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9255: LD_INT 35
9257: PPUSH
9258: CALL_OW 67
// until ru_lab_builded ;
9262: LD_EXP 5
9266: IFFALSE 9255
// DialogueOn ;
9268: CALL_OW 6
// if Kirilenkova then
9272: LD_EXP 36
9276: IFFALSE 9292
// Say ( Kirilenkova , D3a-Kir-1 ) else
9278: LD_EXP 36
9282: PPUSH
9283: LD_STRING D3a-Kir-1
9285: PPUSH
9286: CALL_OW 88
9290: GO 9314
// begin un := SciRu ;
9292: LD_ADDR_VAR 0 4
9296: PUSH
9297: CALL 14854 0 0
9301: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
9302: LD_VAR 0 4
9306: PPUSH
9307: LD_STRING D3a-Sci1-1
9309: PPUSH
9310: CALL_OW 88
// end ; if Kirilenkova or un then
9314: LD_EXP 36
9318: PUSH
9319: LD_VAR 0 4
9323: OR
9324: IFFALSE 9338
// Say ( JMM , D3a-JMM-1 ) ;
9326: LD_EXP 17
9330: PPUSH
9331: LD_STRING D3a-JMM-1
9333: PPUSH
9334: CALL_OW 88
// DialogueOff ;
9338: CALL_OW 7
// end ;
9342: LD_VAR 0 1
9346: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
9347: LD_EXP 4
9351: PUSH
9352: LD_INT 22
9354: PUSH
9355: LD_INT 7
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: PUSH
9362: LD_INT 2
9364: PUSH
9365: LD_INT 25
9367: PUSH
9368: LD_INT 1
9370: PUSH
9371: EMPTY
9372: LIST
9373: LIST
9374: PUSH
9375: LD_INT 25
9377: PUSH
9378: LD_INT 2
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: PUSH
9385: LD_INT 25
9387: PUSH
9388: LD_INT 3
9390: PUSH
9391: EMPTY
9392: LIST
9393: LIST
9394: PUSH
9395: LD_INT 25
9397: PUSH
9398: LD_INT 4
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: PUSH
9405: LD_INT 25
9407: PUSH
9408: LD_INT 5
9410: PUSH
9411: EMPTY
9412: LIST
9413: LIST
9414: PUSH
9415: LD_INT 25
9417: PUSH
9418: LD_INT 8
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: PUSH
9425: LD_INT 25
9427: PUSH
9428: LD_INT 9
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: PUSH
9435: EMPTY
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: PPUSH
9449: CALL_OW 69
9453: PUSH
9454: LD_INT 7
9456: LESS
9457: AND
9458: IFFALSE 9470
9460: GO 9462
9462: DISABLE
// YouLost ( TooMany ) ;
9463: LD_STRING TooMany
9465: PPUSH
9466: CALL_OW 104
9470: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
9471: LD_EXP 35
9475: PPUSH
9476: CALL_OW 255
9480: PUSH
9481: LD_INT 7
9483: EQUAL
9484: IFFALSE 9701
9486: GO 9488
9488: DISABLE
9489: LD_INT 0
9491: PPUSH
9492: PPUSH
9493: PPUSH
// begin uc_side := 3 ;
9494: LD_ADDR_OWVAR 20
9498: PUSH
9499: LD_INT 3
9501: ST_TO_ADDR
// uc_nation := 3 ;
9502: LD_ADDR_OWVAR 21
9506: PUSH
9507: LD_INT 3
9509: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
9510: LD_INT 21
9512: PPUSH
9513: LD_INT 3
9515: PPUSH
9516: LD_INT 3
9518: PPUSH
9519: LD_INT 42
9521: PPUSH
9522: LD_INT 100
9524: PPUSH
9525: CALL 21340 0 5
// un := CreateVehicle ;
9529: LD_ADDR_VAR 0 3
9533: PUSH
9534: CALL_OW 45
9538: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
9539: LD_VAR 0 3
9543: PPUSH
9544: LD_INT 15
9546: PPUSH
9547: LD_INT 0
9549: PPUSH
9550: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
9554: LD_VAR 0 3
9558: PPUSH
9559: LD_INT 67
9561: PPUSH
9562: LD_INT 45
9564: PPUSH
9565: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
9569: LD_VAR 0 3
9573: PPUSH
9574: LD_INT 70
9576: PPUSH
9577: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
9581: LD_VAR 0 3
9585: PPUSH
9586: LD_INT 69
9588: PPUSH
9589: LD_INT 18
9591: PPUSH
9592: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
9596: LD_VAR 0 3
9600: PPUSH
9601: LD_INT 60
9603: PPUSH
9604: LD_INT 3
9606: PPUSH
9607: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
9611: LD_INT 35
9613: PPUSH
9614: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
9618: LD_VAR 0 3
9622: PPUSH
9623: CALL_OW 302
9627: NOT
9628: PUSH
9629: LD_VAR 0 3
9633: PPUSH
9634: LD_INT 17
9636: PPUSH
9637: CALL_OW 308
9641: OR
9642: PUSH
9643: LD_VAR 0 3
9647: PPUSH
9648: LD_INT 60
9650: PPUSH
9651: LD_INT 3
9653: PPUSH
9654: CALL_OW 307
9658: OR
9659: IFFALSE 9611
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
9661: LD_VAR 0 3
9665: PPUSH
9666: LD_INT 17
9668: PPUSH
9669: CALL_OW 308
9673: PUSH
9674: LD_VAR 0 3
9678: PPUSH
9679: LD_INT 60
9681: PPUSH
9682: LD_INT 3
9684: PPUSH
9685: CALL_OW 307
9689: OR
9690: IFFALSE 9701
// RemoveUnit ( un ) ;
9692: LD_VAR 0 3
9696: PPUSH
9697: CALL_OW 64
// end ;
9701: PPOPN 3
9703: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
9704: LD_EXP 4
9708: IFFALSE 9950
9710: GO 9712
9712: DISABLE
9713: LD_INT 0
9715: PPUSH
9716: PPUSH
9717: PPUSH
// begin repeat wait ( 0 0$2 ) ;
9718: LD_INT 70
9720: PPUSH
9721: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
9725: LD_ADDR_VAR 0 3
9729: PUSH
9730: LD_INT 22
9732: PUSH
9733: LD_INT 7
9735: PUSH
9736: EMPTY
9737: LIST
9738: LIST
9739: PUSH
9740: LD_INT 101
9742: PUSH
9743: LD_INT 3
9745: PUSH
9746: EMPTY
9747: LIST
9748: LIST
9749: PUSH
9750: EMPTY
9751: LIST
9752: LIST
9753: PPUSH
9754: CALL_OW 69
9758: ST_TO_ADDR
// until tmp ;
9759: LD_VAR 0 3
9763: IFFALSE 9718
// un := NearestUnitToUnit ( tmp , JMM ) ;
9765: LD_ADDR_VAR 0 2
9769: PUSH
9770: LD_VAR 0 3
9774: PPUSH
9775: LD_EXP 17
9779: PPUSH
9780: CALL_OW 74
9784: ST_TO_ADDR
// player_spotted := true ;
9785: LD_ADDR_EXP 7
9789: PUSH
9790: LD_INT 1
9792: ST_TO_ADDR
// tmp := SciRu ;
9793: LD_ADDR_VAR 0 3
9797: PUSH
9798: CALL 14854 0 0
9802: ST_TO_ADDR
// if not tmp then
9803: LD_VAR 0 3
9807: NOT
9808: IFFALSE 9820
// tmp := SolRu ;
9810: LD_ADDR_VAR 0 3
9814: PUSH
9815: CALL 15001 0 0
9819: ST_TO_ADDR
// DialogueOn ;
9820: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
9824: LD_VAR 0 2
9828: PPUSH
9829: CALL_OW 250
9833: PPUSH
9834: LD_VAR 0 2
9838: PPUSH
9839: CALL_OW 251
9843: PPUSH
9844: LD_INT 7
9846: PPUSH
9847: LD_INT 8
9849: NEG
9850: PPUSH
9851: CALL_OW 330
// CenterNowOnUnits ( un ) ;
9855: LD_VAR 0 2
9859: PPUSH
9860: CALL_OW 87
// if tmp then
9864: LD_VAR 0 3
9868: IFFALSE 9882
// Say ( tmp , D4-RSci1-1 ) ;
9870: LD_VAR 0 3
9874: PPUSH
9875: LD_STRING D4-RSci1-1
9877: PPUSH
9878: CALL_OW 88
// if Gossudarov then
9882: LD_EXP 35
9886: IFFALSE 9912
// begin Say ( Gossudarov , D4-Gos-1 ) ;
9888: LD_EXP 35
9892: PPUSH
9893: LD_STRING D4-Gos-1
9895: PPUSH
9896: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
9900: LD_EXP 17
9904: PPUSH
9905: LD_STRING D4-JMM-1
9907: PPUSH
9908: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
9912: LD_VAR 0 2
9916: PPUSH
9917: CALL_OW 250
9921: PPUSH
9922: LD_VAR 0 2
9926: PPUSH
9927: CALL_OW 251
9931: PPUSH
9932: LD_INT 7
9934: PPUSH
9935: CALL_OW 331
// DialogueOff ;
9939: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
9943: LD_STRING M5
9945: PPUSH
9946: CALL_OW 337
// end ;
9950: PPOPN 3
9952: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
9953: LD_EXP 7
9957: IFFALSE 10550
9959: GO 9961
9961: DISABLE
9962: LD_INT 0
9964: PPUSH
9965: PPUSH
9966: PPUSH
// begin PrepareBelkov ;
9967: CALL 2256 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
9971: LD_EXP 50
9975: PPUSH
9976: LD_INT 118
9978: PPUSH
9979: LD_INT 106
9981: PPUSH
9982: CALL_OW 111
// AddComHold ( Belkov ) ;
9986: LD_EXP 50
9990: PPUSH
9991: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
9995: LD_INT 35
9997: PPUSH
9998: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
10002: LD_EXP 50
10006: PPUSH
10007: LD_INT 118
10009: PPUSH
10010: LD_INT 106
10012: PPUSH
10013: CALL_OW 307
10017: IFFALSE 9995
// ChangeSideFog ( 4 , 7 ) ;
10019: LD_INT 4
10021: PPUSH
10022: LD_INT 7
10024: PPUSH
10025: CALL_OW 343
// if IsOk ( Belkov ) then
10029: LD_EXP 50
10033: PPUSH
10034: CALL_OW 302
10038: IFFALSE 10122
// begin InGameOn ;
10040: CALL_OW 8
// DialogueOn ;
10044: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
10048: LD_EXP 50
10052: PPUSH
10053: LD_STRING D5-Bel-1
10055: PPUSH
10056: CALL_OW 94
// if Gossudarov then
10060: LD_EXP 35
10064: IFFALSE 10114
// begin Say ( Gossudarov , D5-Gos-1 ) ;
10066: LD_EXP 35
10070: PPUSH
10071: LD_STRING D5-Gos-1
10073: PPUSH
10074: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
10078: LD_EXP 17
10082: PPUSH
10083: LD_STRING D5-JMM-1
10085: PPUSH
10086: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
10090: LD_EXP 35
10094: PPUSH
10095: LD_STRING D5-Gos-2
10097: PPUSH
10098: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
10102: LD_EXP 17
10106: PPUSH
10107: LD_STRING D5-JMM-2
10109: PPUSH
10110: CALL_OW 88
// end ; DialogueOff ;
10114: CALL_OW 7
// InGameOff ;
10118: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
10122: LD_STRING QSaveBelkov
10124: PPUSH
10125: CALL_OW 97
10129: PUSH
10130: LD_INT 1
10132: DOUBLE
10133: EQUAL
10134: IFTRUE 10138
10136: GO 10188
10138: POP
// begin DialogueOn ;
10139: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
10143: LD_EXP 17
10147: PPUSH
10148: LD_STRING D5a-JMM-1
10150: PPUSH
10151: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
10155: LD_EXP 50
10159: PPUSH
10160: LD_STRING D5a-Bel-1
10162: PPUSH
10163: CALL_OW 94
// DialogueOff ;
10167: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
10171: LD_EXP 50
10175: PPUSH
10176: LD_INT 83
10178: PPUSH
10179: LD_INT 49
10181: PPUSH
10182: CALL_OW 111
// end ; 2 :
10186: GO 10221
10188: LD_INT 2
10190: DOUBLE
10191: EQUAL
10192: IFTRUE 10196
10194: GO 10220
10196: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
10197: LD_EXP 17
10201: PPUSH
10202: LD_STRING D5a-JMM-2
10204: PPUSH
10205: CALL_OW 88
// ComHold ( Belkov ) ;
10209: LD_EXP 50
10213: PPUSH
10214: CALL_OW 140
// end ; end ;
10218: GO 10221
10220: POP
// time := 0 0$00 ;
10221: LD_ADDR_VAR 0 1
10225: PUSH
10226: LD_INT 0
10228: ST_TO_ADDR
// vehSpawned := false ;
10229: LD_ADDR_VAR 0 3
10233: PUSH
10234: LD_INT 0
10236: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10237: LD_INT 35
10239: PPUSH
10240: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
10244: LD_VAR 0 1
10248: PUSH
10249: LD_INT 350
10251: PUSH
10252: LD_INT 175
10254: PUSH
10255: LD_INT 105
10257: PUSH
10258: LD_INT 70
10260: PUSH
10261: EMPTY
10262: LIST
10263: LIST
10264: LIST
10265: LIST
10266: PUSH
10267: LD_OWVAR 67
10271: ARRAY
10272: GREATEREQUAL
10273: PUSH
10274: LD_VAR 0 3
10278: NOT
10279: AND
10280: IFFALSE 10370
// begin vehSpawned := true ;
10282: LD_ADDR_VAR 0 3
10286: PUSH
10287: LD_INT 1
10289: ST_TO_ADDR
// uc_side := 3 ;
10290: LD_ADDR_OWVAR 20
10294: PUSH
10295: LD_INT 3
10297: ST_TO_ADDR
// uc_nation := 3 ;
10298: LD_ADDR_OWVAR 21
10302: PUSH
10303: LD_INT 3
10305: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
10306: LD_INT 22
10308: PPUSH
10309: LD_INT 3
10311: PPUSH
10312: LD_INT 3
10314: PPUSH
10315: LD_INT 43
10317: PPUSH
10318: LD_INT 100
10320: PPUSH
10321: CALL 21340 0 5
// veh := CreateVehicle ;
10325: LD_ADDR_VAR 0 2
10329: PUSH
10330: CALL_OW 45
10334: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
10335: LD_VAR 0 2
10339: PPUSH
10340: LD_INT 130
10342: PPUSH
10343: LD_INT 131
10345: PPUSH
10346: LD_INT 0
10348: PPUSH
10349: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
10353: LD_VAR 0 2
10357: PPUSH
10358: LD_INT 100
10360: PPUSH
10361: LD_INT 82
10363: PPUSH
10364: CALL_OW 114
// end else
10368: GO 10384
// time := time + 0 0$1 ;
10370: LD_ADDR_VAR 0 1
10374: PUSH
10375: LD_VAR 0 1
10379: PUSH
10380: LD_INT 35
10382: PLUS
10383: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
10384: LD_EXP 50
10388: PPUSH
10389: CALL_OW 301
10393: PUSH
10394: LD_EXP 50
10398: PPUSH
10399: CALL_OW 255
10403: PUSH
10404: LD_INT 4
10406: EQUAL
10407: AND
10408: PUSH
10409: LD_INT 22
10411: PUSH
10412: LD_INT 7
10414: PUSH
10415: EMPTY
10416: LIST
10417: LIST
10418: PPUSH
10419: CALL_OW 69
10423: PPUSH
10424: LD_EXP 50
10428: PPUSH
10429: CALL_OW 74
10433: PPUSH
10434: LD_EXP 50
10438: PPUSH
10439: CALL_OW 296
10443: PUSH
10444: LD_INT 10
10446: LESS
10447: OR
10448: IFFALSE 10237
// if IsDead ( Belkov ) then
10450: LD_EXP 50
10454: PPUSH
10455: CALL_OW 301
10459: IFFALSE 10484
// begin CenterNowOnUnits ( Belkov ) ;
10461: LD_EXP 50
10465: PPUSH
10466: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
10470: LD_EXP 17
10474: PPUSH
10475: LD_STRING D5a-JMM-2a
10477: PPUSH
10478: CALL_OW 88
// exit ;
10482: GO 10550
// end ; if See ( 7 , Belkov ) then
10484: LD_INT 7
10486: PPUSH
10487: LD_EXP 50
10491: PPUSH
10492: CALL_OW 292
10496: IFFALSE 10510
// SetSide ( Belkov , 7 ) ;
10498: LD_EXP 50
10502: PPUSH
10503: LD_INT 7
10505: PPUSH
10506: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
10510: LD_INT 35
10512: PPUSH
10513: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
10517: LD_EXP 50
10521: PPUSH
10522: LD_INT 66
10524: PPUSH
10525: LD_INT 45
10527: PPUSH
10528: CALL_OW 297
10532: PUSH
10533: LD_INT 30
10535: LESS
10536: IFFALSE 10510
// Say ( Belkov , D6-Bel-1 ) ;
10538: LD_EXP 50
10542: PPUSH
10543: LD_STRING D6-Bel-1
10545: PPUSH
10546: CALL_OW 88
// end ;
10550: PPOPN 3
10552: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
10553: LD_EXP 50
10557: PPUSH
10558: CALL_OW 302
10562: PUSH
10563: LD_EXP 50
10567: PPUSH
10568: CALL_OW 504
10572: PUSH
10573: LD_INT 2
10575: PUSH
10576: LD_INT 34
10578: PUSH
10579: LD_INT 47
10581: PUSH
10582: EMPTY
10583: LIST
10584: LIST
10585: PUSH
10586: LD_INT 34
10588: PUSH
10589: LD_INT 45
10591: PUSH
10592: EMPTY
10593: LIST
10594: LIST
10595: PUSH
10596: EMPTY
10597: LIST
10598: LIST
10599: LIST
10600: PPUSH
10601: CALL_OW 69
10605: IN
10606: AND
10607: IFFALSE 10624
10609: GO 10611
10611: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
10612: LD_EXP 50
10616: PPUSH
10617: LD_STRING D7-Bel-1
10619: PPUSH
10620: CALL_OW 88
10624: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
10625: LD_INT 22
10627: PUSH
10628: LD_INT 7
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: PUSH
10635: LD_INT 101
10637: PUSH
10638: LD_INT 2
10640: PUSH
10641: EMPTY
10642: LIST
10643: LIST
10644: PUSH
10645: EMPTY
10646: LIST
10647: LIST
10648: PPUSH
10649: CALL_OW 69
10653: PUSH
10654: LD_EXP 9
10658: NOT
10659: AND
10660: PUSH
10661: LD_EXP 49
10665: PPUSH
10666: CALL_OW 305
10670: NOT
10671: AND
10672: IFFALSE 11157
10674: GO 10676
10676: DISABLE
10677: LD_INT 0
10679: PPUSH
// begin ar_base_spotted := true ;
10680: LD_ADDR_EXP 9
10684: PUSH
10685: LD_INT 1
10687: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
10688: LD_ADDR_VAR 0 1
10692: PUSH
10693: LD_INT 22
10695: PUSH
10696: LD_INT 2
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PUSH
10703: LD_INT 21
10705: PUSH
10706: LD_INT 3
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: EMPTY
10714: LIST
10715: LIST
10716: PPUSH
10717: CALL_OW 69
10721: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
10722: LD_ADDR_VAR 0 1
10726: PUSH
10727: LD_VAR 0 1
10731: PPUSH
10732: LD_EXP 17
10736: PPUSH
10737: CALL_OW 74
10741: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
10742: LD_INT 7
10744: PPUSH
10745: LD_INT 3
10747: PPUSH
10748: CALL_OW 332
// DialogueOn ;
10752: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
10756: LD_VAR 0 1
10760: PPUSH
10761: CALL_OW 250
10765: PPUSH
10766: LD_VAR 0 1
10770: PPUSH
10771: CALL_OW 251
10775: PPUSH
10776: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
10780: LD_ADDR_VAR 0 1
10784: PUSH
10785: LD_INT 22
10787: PUSH
10788: LD_INT 7
10790: PUSH
10791: EMPTY
10792: LIST
10793: LIST
10794: PUSH
10795: LD_INT 23
10797: PUSH
10798: LD_INT 1
10800: PUSH
10801: EMPTY
10802: LIST
10803: LIST
10804: PUSH
10805: LD_INT 26
10807: PUSH
10808: LD_INT 1
10810: PUSH
10811: EMPTY
10812: LIST
10813: LIST
10814: PUSH
10815: EMPTY
10816: LIST
10817: LIST
10818: LIST
10819: PPUSH
10820: CALL_OW 69
10824: PUSH
10825: LD_EXP 17
10829: PUSH
10830: LD_EXP 21
10834: PUSH
10835: LD_EXP 22
10839: PUSH
10840: LD_EXP 29
10844: PUSH
10845: LD_EXP 18
10849: PUSH
10850: LD_EXP 27
10854: PUSH
10855: LD_EXP 23
10859: PUSH
10860: LD_EXP 25
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: LIST
10871: LIST
10872: LIST
10873: LIST
10874: DIFF
10875: ST_TO_ADDR
// if not tmp then
10876: LD_VAR 0 1
10880: NOT
10881: IFFALSE 10955
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
10883: LD_ADDR_VAR 0 1
10887: PUSH
10888: LD_INT 22
10890: PUSH
10891: LD_INT 7
10893: PUSH
10894: EMPTY
10895: LIST
10896: LIST
10897: PUSH
10898: LD_INT 23
10900: PUSH
10901: LD_INT 1
10903: PUSH
10904: EMPTY
10905: LIST
10906: LIST
10907: PUSH
10908: LD_INT 26
10910: PUSH
10911: LD_INT 2
10913: PUSH
10914: EMPTY
10915: LIST
10916: LIST
10917: PUSH
10918: EMPTY
10919: LIST
10920: LIST
10921: LIST
10922: PPUSH
10923: CALL_OW 69
10927: PUSH
10928: LD_EXP 32
10932: PUSH
10933: LD_EXP 19
10937: PUSH
10938: LD_EXP 30
10942: PUSH
10943: LD_EXP 31
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: LIST
10952: LIST
10953: DIFF
10954: ST_TO_ADDR
// if tmp then
10955: LD_VAR 0 1
10959: IFFALSE 11030
// case GetSex ( tmp [ 1 ] ) of sex_male :
10961: LD_VAR 0 1
10965: PUSH
10966: LD_INT 1
10968: ARRAY
10969: PPUSH
10970: CALL_OW 258
10974: PUSH
10975: LD_INT 1
10977: DOUBLE
10978: EQUAL
10979: IFTRUE 10983
10981: GO 11002
10983: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
10984: LD_VAR 0 1
10988: PUSH
10989: LD_INT 1
10991: ARRAY
10992: PPUSH
10993: LD_STRING D9-Sol1-1
10995: PPUSH
10996: CALL_OW 88
11000: GO 11030
11002: LD_INT 2
11004: DOUBLE
11005: EQUAL
11006: IFTRUE 11010
11008: GO 11029
11010: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
11011: LD_VAR 0 1
11015: PUSH
11016: LD_INT 1
11018: ARRAY
11019: PPUSH
11020: LD_STRING D9-FSol1-1
11022: PPUSH
11023: CALL_OW 88
11027: GO 11030
11029: POP
// if Frank then
11030: LD_EXP 29
11034: IFFALSE 11138
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
11036: LD_EXP 59
11040: PPUSH
11041: CALL_OW 250
11045: PPUSH
11046: LD_EXP 59
11050: PPUSH
11051: CALL_OW 251
11055: PPUSH
11056: LD_INT 7
11058: PPUSH
11059: LD_INT 8
11061: PPUSH
11062: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
11066: LD_EXP 59
11070: PPUSH
11071: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
11075: LD_EXP 29
11079: PPUSH
11080: LD_STRING D9-Frank-1
11082: PPUSH
11083: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
11087: LD_EXP 17
11091: PPUSH
11092: LD_STRING D9-JMM-1
11094: PPUSH
11095: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
11099: LD_EXP 29
11103: PPUSH
11104: LD_STRING D9-Frank-2
11106: PPUSH
11107: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
11111: LD_EXP 59
11115: PPUSH
11116: CALL_OW 250
11120: PPUSH
11121: LD_EXP 59
11125: PPUSH
11126: CALL_OW 251
11130: PPUSH
11131: LD_INT 7
11133: PPUSH
11134: CALL_OW 331
// end ; DialogueOff ;
11138: CALL_OW 7
// wait ( 1 1$00 ) ;
11142: LD_INT 2100
11144: PPUSH
11145: CALL_OW 67
// ar_active_attack := true ;
11149: LD_ADDR_EXP 10
11153: PUSH
11154: LD_INT 1
11156: ST_TO_ADDR
// end ;
11157: PPOPN 1
11159: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
11160: LD_EXP 8
11164: PUSH
11165: LD_OWVAR 1
11169: PUSH
11170: LD_INT 42000
11172: GREATEREQUAL
11173: OR
11174: IFFALSE 12236
11176: GO 11178
11178: DISABLE
11179: LD_INT 0
11181: PPUSH
11182: PPUSH
// begin selected_option := 1 ;
11183: LD_ADDR_VAR 0 2
11187: PUSH
11188: LD_INT 1
11190: ST_TO_ADDR
// wait ( 5 5$00 ) ;
11191: LD_INT 10500
11193: PPUSH
11194: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11198: LD_INT 35
11200: PPUSH
11201: CALL_OW 67
// until not ru_attackers ;
11205: LD_EXP 55
11209: NOT
11210: IFFALSE 11198
// PrepareBurlak ;
11212: CALL 2368 0 0
// repeat wait ( 0 0$2 ) ;
11216: LD_INT 70
11218: PPUSH
11219: CALL_OW 67
// until not HasTask ( Burlak ) ;
11223: LD_EXP 49
11227: PPUSH
11228: CALL_OW 314
11232: NOT
11233: IFFALSE 11216
// InGameOn ;
11235: CALL_OW 8
// DialogueOn ;
11239: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
11243: LD_EXP 52
11247: PPUSH
11248: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
11252: LD_EXP 49
11256: PPUSH
11257: LD_STRING D10-Bur-1
11259: PPUSH
11260: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
11264: LD_EXP 50
11268: PUSH
11269: LD_EXP 50
11273: PPUSH
11274: CALL_OW 255
11278: PUSH
11279: LD_INT 7
11281: EQUAL
11282: AND
11283: IFFALSE 11297
// Say ( Belkov , D10-Bel-1 ) ;
11285: LD_EXP 50
11289: PPUSH
11290: LD_STRING D10-Bel-1
11292: PPUSH
11293: CALL_OW 88
// if Gossudarov then
11297: LD_EXP 35
11301: IFFALSE 11315
// Say ( Gossudarov , D10-Gos-1 ) ;
11303: LD_EXP 35
11307: PPUSH
11308: LD_STRING D10-Gos-1
11310: PPUSH
11311: CALL_OW 88
// if Kirilenkova then
11315: LD_EXP 36
11319: IFFALSE 11333
// Say ( Kirilenkova , D10-Kir-1 ) ;
11321: LD_EXP 36
11325: PPUSH
11326: LD_STRING D10-Kir-1
11328: PPUSH
11329: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
11333: CALL 15001 0 0
11337: PPUSH
11338: LD_STRING D10-RSol1-1
11340: PPUSH
11341: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
11345: LD_EXP 49
11349: PPUSH
11350: LD_STRING D10-Bur-2
11352: PPUSH
11353: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
11357: LD_EXP 17
11361: PPUSH
11362: LD_STRING D10-JMM-2
11364: PPUSH
11365: CALL_OW 88
// if Kirilenkova then
11369: LD_EXP 36
11373: IFFALSE 11389
// Say ( Kirilenkova , D10-Kir-2 ) else
11375: LD_EXP 36
11379: PPUSH
11380: LD_STRING D10-Kir-2
11382: PPUSH
11383: CALL_OW 88
11387: GO 11401
// Say ( SolRu , D10-RSol1-2 ) ;
11389: CALL 15001 0 0
11393: PPUSH
11394: LD_STRING D10-RSol1-2
11396: PPUSH
11397: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
11401: LD_EXP 17
11405: PPUSH
11406: LD_STRING D10-JMM-3
11408: PPUSH
11409: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
11413: LD_EXP 49
11417: PPUSH
11418: LD_STRING D10-Bur-3
11420: PPUSH
11421: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
11425: LD_EXP 17
11429: PPUSH
11430: LD_STRING D10-JMM-4
11432: PPUSH
11433: CALL_OW 88
// DialogueOff ;
11437: CALL_OW 7
// InGameOff ;
11441: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
11445: LD_STRING M2
11447: PPUSH
11448: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
11452: LD_INT 35
11454: PPUSH
11455: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
11459: LD_INT 22
11461: PUSH
11462: LD_INT 7
11464: PUSH
11465: EMPTY
11466: LIST
11467: LIST
11468: PUSH
11469: LD_INT 91
11471: PUSH
11472: LD_EXP 49
11476: PUSH
11477: LD_INT 8
11479: PUSH
11480: EMPTY
11481: LIST
11482: LIST
11483: LIST
11484: PUSH
11485: EMPTY
11486: LIST
11487: LIST
11488: PPUSH
11489: CALL_OW 69
11493: IFFALSE 11452
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
11495: LD_ADDR_VAR 0 1
11499: PUSH
11500: LD_INT 22
11502: PUSH
11503: LD_INT 4
11505: PUSH
11506: EMPTY
11507: LIST
11508: LIST
11509: PPUSH
11510: CALL_OW 69
11514: PUSH
11515: FOR_IN
11516: IFFALSE 11532
// SetSide ( i , 7 ) ;
11518: LD_VAR 0 1
11522: PPUSH
11523: LD_INT 7
11525: PPUSH
11526: CALL_OW 235
11530: GO 11515
11532: POP
11533: POP
// ChangeMissionObjectives ( M3 ) ;
11534: LD_STRING M3
11536: PPUSH
11537: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
11541: LD_INT 35
11543: PPUSH
11544: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
11548: LD_EXP 17
11552: PPUSH
11553: LD_EXP 49
11557: PPUSH
11558: CALL_OW 296
11562: PUSH
11563: LD_INT 8
11565: LESS
11566: IFFALSE 11541
// ComTurnUnit ( JMM , Burlak ) ;
11568: LD_EXP 17
11572: PPUSH
11573: LD_EXP 49
11577: PPUSH
11578: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
11582: LD_EXP 49
11586: PPUSH
11587: LD_EXP 17
11591: PPUSH
11592: CALL_OW 119
// wait ( 0 0$0.3 ) ;
11596: LD_INT 10
11598: PPUSH
11599: CALL_OW 67
// DialogueOn ;
11603: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
11607: LD_EXP 17
11611: PPUSH
11612: LD_STRING D11-JMM-1
11614: PPUSH
11615: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
11619: LD_EXP 49
11623: PPUSH
11624: LD_STRING D11-Bur-1
11626: PPUSH
11627: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
11631: LD_EXP 17
11635: PPUSH
11636: LD_STRING D11-JMM-2
11638: PPUSH
11639: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
11643: LD_EXP 49
11647: PPUSH
11648: LD_STRING D11-Bur-2
11650: PPUSH
11651: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
11655: LD_EXP 17
11659: PPUSH
11660: LD_STRING D11-JMM-3
11662: PPUSH
11663: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
11667: LD_EXP 49
11671: PPUSH
11672: LD_STRING D11-Bur-3
11674: PPUSH
11675: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
11679: LD_EXP 17
11683: PPUSH
11684: LD_STRING D11-JMM-4
11686: PPUSH
11687: CALL_OW 88
// if ar_base_spotted then
11691: LD_EXP 9
11695: IFFALSE 11711
// Say ( Burlak , D12-Bur-1 ) else
11697: LD_EXP 49
11701: PPUSH
11702: LD_STRING D12-Bur-1
11704: PPUSH
11705: CALL_OW 88
11709: GO 11750
// begin RevealFogArea ( 7 , area_base_arabian ) ;
11711: LD_INT 7
11713: PPUSH
11714: LD_INT 3
11716: PPUSH
11717: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
11721: LD_INT 127
11723: PPUSH
11724: LD_INT 45
11726: PPUSH
11727: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
11731: LD_EXP 49
11735: PPUSH
11736: LD_STRING D12-Bur-1a
11738: PPUSH
11739: CALL_OW 88
// dwait ( 0 0$2 ) ;
11743: LD_INT 70
11745: PPUSH
11746: CALL_OW 68
// end ; if not IsOk ( Abdul ) then
11750: LD_EXP 58
11754: PPUSH
11755: CALL_OW 302
11759: NOT
11760: IFFALSE 11768
// begin DialogueOff ;
11762: CALL_OW 7
// exit ;
11766: GO 12236
// end ; Say ( Burlak , D12-Bur-1b ) ;
11768: LD_EXP 49
11772: PPUSH
11773: LD_STRING D12-Bur-1b
11775: PPUSH
11776: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
11780: LD_EXP 17
11784: PPUSH
11785: LD_STRING D12-JMM-1
11787: PPUSH
11788: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
11792: LD_EXP 49
11796: PPUSH
11797: LD_STRING D12-Bur-2
11799: PPUSH
11800: CALL_OW 88
// if Roth then
11804: LD_EXP 18
11808: IFFALSE 11824
// Say ( Roth , D12-Roth-2 ) else
11810: LD_EXP 18
11814: PPUSH
11815: LD_STRING D12-Roth-2
11817: PPUSH
11818: CALL_OW 88
11822: GO 11836
// Say ( SciRu , D12-RSci1-2 ) ;
11824: CALL 14854 0 0
11828: PPUSH
11829: LD_STRING D12-RSci1-2
11831: PPUSH
11832: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
11836: LD_EXP 17
11840: PPUSH
11841: LD_STRING D12-JMM-2
11843: PPUSH
11844: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
11848: LD_EXP 49
11852: PPUSH
11853: LD_STRING D12-Bur-3
11855: PPUSH
11856: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
11860: LD_EXP 17
11864: PPUSH
11865: LD_STRING D12-JMM-3
11867: PPUSH
11868: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
11872: LD_EXP 49
11876: PPUSH
11877: LD_STRING D12-Bur-4
11879: PPUSH
11880: CALL_OW 88
// case Query ( QBase ) of 1 :
11884: LD_STRING QBase
11886: PPUSH
11887: CALL_OW 97
11891: PUSH
11892: LD_INT 1
11894: DOUBLE
11895: EQUAL
11896: IFTRUE 11900
11898: GO 12018
11900: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
11901: LD_EXP 17
11905: PPUSH
11906: LD_STRING D13a-JMM-1
11908: PPUSH
11909: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
11913: LD_EXP 49
11917: PPUSH
11918: LD_STRING D13a-Bur-1
11920: PPUSH
11921: CALL_OW 88
// if Roth then
11925: LD_EXP 18
11929: IFFALSE 11945
// Say ( Roth , D13a-Roth-1 ) else
11931: LD_EXP 18
11935: PPUSH
11936: LD_STRING D13a-Roth-1
11938: PPUSH
11939: CALL_OW 88
11943: GO 11957
// Say ( SciRu , D13a-RSci1-1 ) ;
11945: CALL 14854 0 0
11949: PPUSH
11950: LD_STRING D13a-RSci1-1
11952: PPUSH
11953: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
11957: LD_EXP 17
11961: PPUSH
11962: LD_STRING D13a-JMM-2
11964: PPUSH
11965: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
11969: LD_STRING QBaseAgain
11971: PPUSH
11972: CALL_OW 97
11976: PUSH
11977: LD_INT 1
11979: DOUBLE
11980: EQUAL
11981: IFTRUE 11985
11983: GO 11996
11985: POP
// selected_option := 2 ; 2 :
11986: LD_ADDR_VAR 0 2
11990: PUSH
11991: LD_INT 2
11993: ST_TO_ADDR
11994: GO 12016
11996: LD_INT 2
11998: DOUBLE
11999: EQUAL
12000: IFTRUE 12004
12002: GO 12015
12004: POP
// selected_option := 3 ; end ;
12005: LD_ADDR_VAR 0 2
12009: PUSH
12010: LD_INT 3
12012: ST_TO_ADDR
12013: GO 12016
12015: POP
// end ; 2 :
12016: GO 12057
12018: LD_INT 2
12020: DOUBLE
12021: EQUAL
12022: IFTRUE 12026
12024: GO 12037
12026: POP
// selected_option := 2 ; 3 :
12027: LD_ADDR_VAR 0 2
12031: PUSH
12032: LD_INT 2
12034: ST_TO_ADDR
12035: GO 12057
12037: LD_INT 3
12039: DOUBLE
12040: EQUAL
12041: IFTRUE 12045
12043: GO 12056
12045: POP
// selected_option := 3 ; end ;
12046: LD_ADDR_VAR 0 2
12050: PUSH
12051: LD_INT 3
12053: ST_TO_ADDR
12054: GO 12057
12056: POP
// if selected_option = 2 then
12057: LD_VAR 0 2
12061: PUSH
12062: LD_INT 2
12064: EQUAL
12065: IFFALSE 12169
// begin Say ( JMM , D13b-JMM-1 ) ;
12067: LD_EXP 17
12071: PPUSH
12072: LD_STRING D13b-JMM-1
12074: PPUSH
12075: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
12079: LD_EXP 49
12083: PPUSH
12084: LD_STRING D13b-Bur-1
12086: PPUSH
12087: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
12091: LD_EXP 17
12095: PPUSH
12096: LD_STRING D13b-JMM-2
12098: PPUSH
12099: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
12103: LD_EXP 58
12107: PPUSH
12108: LD_STRING D13b-Abd-2
12110: PPUSH
12111: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
12115: LD_EXP 17
12119: PPUSH
12120: LD_STRING D13b-JMM-3
12122: PPUSH
12123: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
12127: LD_EXP 58
12131: PPUSH
12132: LD_STRING D13b-Abd-3
12134: PPUSH
12135: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
12139: LD_EXP 17
12143: PPUSH
12144: LD_STRING D13b-JMM-4
12146: PPUSH
12147: CALL_OW 88
// ar_active_attack := true ;
12151: LD_ADDR_EXP 10
12155: PUSH
12156: LD_INT 1
12158: ST_TO_ADDR
// SaveVariable ( true , 13a_negotiationWithArabs ) ;
12159: LD_INT 1
12161: PPUSH
12162: LD_STRING 13a_negotiationWithArabs
12164: PPUSH
12165: CALL_OW 39
// end ; if selected_option = 3 then
12169: LD_VAR 0 2
12173: PUSH
12174: LD_INT 3
12176: EQUAL
12177: IFFALSE 12203
// begin Say ( JMM , D13c-JMM-1 ) ;
12179: LD_EXP 17
12183: PPUSH
12184: LD_STRING D13c-JMM-1
12186: PPUSH
12187: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
12191: LD_EXP 49
12195: PPUSH
12196: LD_STRING D13c-Bur-1
12198: PPUSH
12199: CALL_OW 88
// end ; DialogueOff ;
12203: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
12207: LD_STRING M4
12209: PPUSH
12210: CALL_OW 337
// if not ar_active_attack then
12214: LD_EXP 10
12218: NOT
12219: IFFALSE 12236
// begin wait ( 6 6$00 ) ;
12221: LD_INT 12600
12223: PPUSH
12224: CALL_OW 67
// ar_active_attack := true ;
12228: LD_ADDR_EXP 10
12232: PUSH
12233: LD_INT 1
12235: ST_TO_ADDR
// end ; end ;
12236: PPOPN 2
12238: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
12239: LD_EXP 49
12243: PPUSH
12244: CALL_OW 305
12248: PUSH
12249: LD_EXP 49
12253: PPUSH
12254: CALL_OW 255
12258: PUSH
12259: LD_INT 7
12261: EQUAL
12262: AND
12263: IFFALSE 12486
12265: GO 12267
12267: DISABLE
12268: LD_INT 0
12270: PPUSH
// begin wait ( 4 4$40 ) ;
12271: LD_INT 9800
12273: PPUSH
12274: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
12278: LD_INT 35
12280: PPUSH
12281: CALL_OW 67
// until not ru_attackers and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_ok ] ] ) ;
12285: LD_EXP 55
12289: NOT
12290: PUSH
12291: LD_INT 22
12293: PUSH
12294: LD_INT 6
12296: PUSH
12297: EMPTY
12298: LIST
12299: LIST
12300: PUSH
12301: LD_INT 50
12303: PUSH
12304: EMPTY
12305: LIST
12306: PUSH
12307: EMPTY
12308: LIST
12309: LIST
12310: PPUSH
12311: CALL_OW 69
12315: NOT
12316: AND
12317: IFFALSE 12278
// PrepareGnyevko ;
12319: CALL 2312 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
12323: LD_EXP 51
12327: PPUSH
12328: LD_INT 124
12330: PPUSH
12331: LD_INT 118
12333: PPUSH
12334: CALL_OW 111
// AddComHold ( Gnyevko ) ;
12338: LD_EXP 51
12342: PPUSH
12343: CALL_OW 200
// time := 0 0$00 ;
12347: LD_ADDR_VAR 0 1
12351: PUSH
12352: LD_INT 0
12354: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12355: LD_INT 35
12357: PPUSH
12358: CALL_OW 67
// time := time + 0 0$1 ;
12362: LD_ADDR_VAR 0 1
12366: PUSH
12367: LD_VAR 0 1
12371: PUSH
12372: LD_INT 35
12374: PLUS
12375: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
12376: LD_EXP 51
12380: PPUSH
12381: LD_INT 124
12383: PPUSH
12384: LD_INT 118
12386: PPUSH
12387: CALL_OW 307
12391: PUSH
12392: LD_VAR 0 1
12396: PUSH
12397: LD_INT 1050
12399: GREATEREQUAL
12400: OR
12401: IFFALSE 12355
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
12403: LD_EXP 51
12407: PPUSH
12408: LD_STRING DBelkov-Gny-1
12410: PPUSH
12411: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
12415: LD_EXP 49
12419: PPUSH
12420: LD_STRING DBelkov-Bur-1a
12422: PPUSH
12423: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
12427: LD_INT 35
12429: PPUSH
12430: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
12434: LD_EXP 51
12438: PPUSH
12439: LD_INT 22
12441: PUSH
12442: LD_INT 7
12444: PUSH
12445: EMPTY
12446: LIST
12447: LIST
12448: PPUSH
12449: CALL_OW 69
12453: PPUSH
12454: LD_EXP 51
12458: PPUSH
12459: CALL_OW 74
12463: PPUSH
12464: CALL_OW 296
12468: PUSH
12469: LD_INT 8
12471: LESS
12472: IFFALSE 12427
// SetSide ( Gnyevko , 7 ) ;
12474: LD_EXP 51
12478: PPUSH
12479: LD_INT 7
12481: PPUSH
12482: CALL_OW 235
// end ;
12486: PPOPN 1
12488: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
12489: LD_EXP 49
12493: PPUSH
12494: CALL_OW 255
12498: PUSH
12499: LD_INT 7
12501: EQUAL
12502: IFFALSE 12512
12504: GO 12506
12506: DISABLE
// begin enable ;
12507: ENABLE
// PrepareAmericanAttack ;
12508: CALL 7851 0 0
// end ;
12512: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
12513: LD_INT 22
12515: PUSH
12516: LD_INT 1
12518: PUSH
12519: EMPTY
12520: LIST
12521: LIST
12522: PPUSH
12523: CALL_OW 69
12527: IFFALSE 12711
12529: GO 12531
12531: DISABLE
12532: LD_INT 0
12534: PPUSH
12535: PPUSH
// begin while true do
12536: LD_INT 1
12538: IFFALSE 12595
// begin wait ( 0 0$1 ) ;
12540: LD_INT 35
12542: PPUSH
12543: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
12547: LD_ADDR_VAR 0 2
12551: PUSH
12552: LD_INT 22
12554: PUSH
12555: LD_INT 1
12557: PUSH
12558: EMPTY
12559: LIST
12560: LIST
12561: PPUSH
12562: CALL_OW 69
12566: PPUSH
12567: LD_EXP 17
12571: PPUSH
12572: CALL_OW 74
12576: ST_TO_ADDR
// if See ( 7 , tmp ) then
12577: LD_INT 7
12579: PPUSH
12580: LD_VAR 0 2
12584: PPUSH
12585: CALL_OW 292
12589: IFFALSE 12593
// break ;
12591: GO 12595
// end ;
12593: GO 12536
// DialogueOn ;
12595: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
12599: LD_VAR 0 2
12603: PPUSH
12604: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
12608: LD_VAR 0 2
12612: PPUSH
12613: CALL_OW 250
12617: PPUSH
12618: LD_VAR 0 2
12622: PPUSH
12623: CALL_OW 251
12627: PPUSH
12628: LD_INT 7
12630: PPUSH
12631: LD_INT 8
12633: PPUSH
12634: CALL_OW 330
// if Denis then
12638: LD_EXP 23
12642: IFFALSE 12656
// Say ( Denis , DAmerAttack-Pet-1 ) ;
12644: LD_EXP 23
12648: PPUSH
12649: LD_STRING DAmerAttack-Pet-1
12651: PPUSH
12652: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
12656: LD_EXP 17
12660: PPUSH
12661: LD_STRING DAmerAttack-JMM-1
12663: PPUSH
12664: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
12668: LD_EXP 49
12672: PPUSH
12673: LD_STRING DStop-Bur-1
12675: PPUSH
12676: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
12680: LD_VAR 0 2
12684: PPUSH
12685: CALL_OW 250
12689: PPUSH
12690: LD_VAR 0 2
12694: PPUSH
12695: CALL_OW 251
12699: PPUSH
12700: LD_INT 7
12702: PPUSH
12703: CALL_OW 331
// DialogueOff ;
12707: CALL_OW 7
// end ;
12711: PPOPN 2
12713: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
12714: LD_INT 22
12716: PUSH
12717: LD_INT 3
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: PUSH
12724: LD_INT 21
12726: PUSH
12727: LD_INT 1
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PUSH
12734: EMPTY
12735: LIST
12736: LIST
12737: PPUSH
12738: CALL_OW 69
12742: PUSH
12743: LD_INT 0
12745: EQUAL
12746: IFFALSE 12796
12748: GO 12750
12750: DISABLE
// begin ru_active_attack := false ;
12751: LD_ADDR_EXP 6
12755: PUSH
12756: LD_INT 0
12758: ST_TO_ADDR
// ChangeMissionObjectives ( M5a ) ;
12759: LD_STRING M5a
12761: PPUSH
12762: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
12766: LD_EXP 17
12770: PPUSH
12771: LD_STRING D8-JMM-1
12773: PPUSH
12774: CALL_OW 88
// if Gossudarov then
12778: LD_EXP 35
12782: IFFALSE 12796
// Say ( Gossudarov , D8-Gos-1 ) ;
12784: LD_EXP 35
12788: PPUSH
12789: LD_STRING D8-Gos-1
12791: PPUSH
12792: CALL_OW 88
// end ;
12796: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
12797: LD_INT 22
12799: PUSH
12800: LD_INT 2
12802: PUSH
12803: EMPTY
12804: LIST
12805: LIST
12806: PUSH
12807: LD_INT 21
12809: PUSH
12810: LD_INT 1
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: PPUSH
12821: CALL_OW 69
12825: PUSH
12826: LD_INT 0
12828: EQUAL
12829: IFFALSE 12887
12831: GO 12833
12833: DISABLE
// begin ar_active_attack := false ;
12834: LD_ADDR_EXP 10
12838: PUSH
12839: LD_INT 0
12841: ST_TO_ADDR
// ChangeMissionObjectives ( M4c ) ;
12842: LD_STRING M4c
12844: PPUSH
12845: CALL_OW 337
// if Roth then
12849: LD_EXP 18
12853: IFFALSE 12869
// Say ( Roth , DStop-Roth-1 ) else
12855: LD_EXP 18
12859: PPUSH
12860: LD_STRING DStop-Roth-1
12862: PPUSH
12863: CALL_OW 88
12867: GO 12887
// if Gossudarov then
12869: LD_EXP 35
12873: IFFALSE 12887
// Say ( Gossudarov , D8-Gos-1a ) ;
12875: LD_EXP 35
12879: PPUSH
12880: LD_STRING D8-Gos-1a
12882: PPUSH
12883: CALL_OW 88
// end ;
12887: END
// every 1 1$00 trigger FindArtifact ( 3 ) and first_powell_attack do
12888: LD_INT 3
12890: PPUSH
12891: CALL_OW 469
12895: PUSH
12896: LD_EXP 13
12900: AND
12901: IFFALSE 12956
12903: GO 12905
12905: DISABLE
// begin TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
12906: LD_INT 3
12908: PPUSH
12909: CALL_OW 469
12913: PPUSH
12914: CALL 8340 0 1
// if Difficulty > 2 then
12918: LD_OWVAR 67
12922: PUSH
12923: LD_INT 2
12925: GREATER
12926: IFFALSE 12956
// begin wait ( 5 5$00 ) ;
12928: LD_INT 10500
12930: PPUSH
12931: CALL_OW 67
// if FindArtifact ( 3 ) then
12935: LD_INT 3
12937: PPUSH
12938: CALL_OW 469
12942: IFFALSE 12956
// TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
12944: LD_INT 3
12946: PPUSH
12947: CALL_OW 469
12951: PPUSH
12952: CALL 8340 0 1
// end ; end ;
12956: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
12957: LD_INT 7
12959: PPUSH
12960: LD_INT 1
12962: PPUSH
12963: LD_INT 1
12965: PPUSH
12966: CALL 16563 0 3
12970: PUSH
12971: LD_INT 0
12973: EQUAL
12974: PUSH
12975: LD_INT 7
12977: PPUSH
12978: LD_INT 3
12980: PPUSH
12981: LD_INT 1
12983: PPUSH
12984: CALL 16563 0 3
12988: PUSH
12989: LD_INT 0
12991: EQUAL
12992: AND
12993: IFFALSE 13005
12995: GO 12997
12997: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
12998: LD_STRING M1a
13000: PPUSH
13001: CALL_OW 337
// end ;
13005: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
13006: LD_INT 22
13008: PUSH
13009: LD_INT 2
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: PUSH
13016: LD_INT 23
13018: PUSH
13019: LD_INT 2
13021: PUSH
13022: EMPTY
13023: LIST
13024: LIST
13025: PUSH
13026: LD_INT 21
13028: PUSH
13029: LD_INT 1
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: LIST
13040: PPUSH
13041: CALL_OW 69
13045: PUSH
13046: LD_INT 0
13048: EQUAL
13049: PUSH
13050: LD_INT 22
13052: PUSH
13053: LD_INT 3
13055: PUSH
13056: EMPTY
13057: LIST
13058: LIST
13059: PUSH
13060: LD_INT 23
13062: PUSH
13063: LD_INT 3
13065: PUSH
13066: EMPTY
13067: LIST
13068: LIST
13069: PUSH
13070: LD_INT 21
13072: PUSH
13073: LD_INT 1
13075: PUSH
13076: EMPTY
13077: LIST
13078: LIST
13079: PUSH
13080: EMPTY
13081: LIST
13082: LIST
13083: LIST
13084: PPUSH
13085: CALL_OW 69
13089: PUSH
13090: LD_INT 0
13092: EQUAL
13093: AND
13094: PUSH
13095: LD_INT 22
13097: PUSH
13098: LD_INT 1
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: PPUSH
13105: CALL_OW 69
13109: PUSH
13110: LD_INT 0
13112: EQUAL
13113: AND
13114: PUSH
13115: LD_INT 7
13117: PPUSH
13118: LD_INT 1
13120: PPUSH
13121: LD_INT 1
13123: PPUSH
13124: CALL 16563 0 3
13128: PUSH
13129: LD_INT 0
13131: EQUAL
13132: AND
13133: PUSH
13134: LD_INT 7
13136: PPUSH
13137: LD_INT 3
13139: PPUSH
13140: LD_INT 1
13142: PPUSH
13143: CALL 16563 0 3
13147: PUSH
13148: LD_INT 0
13150: EQUAL
13151: AND
13152: PUSH
13153: LD_EXP 49
13157: PPUSH
13158: CALL_OW 255
13162: PUSH
13163: LD_INT 7
13165: EQUAL
13166: AND
13167: PUSH
13168: LD_EXP 49
13172: PPUSH
13173: CALL_OW 302
13177: AND
13178: IFFALSE 14851
13180: GO 13182
13182: DISABLE
13183: LD_INT 0
13185: PPUSH
13186: PPUSH
13187: PPUSH
13188: PPUSH
13189: PPUSH
13190: PPUSH
// begin m1 := false ;
13191: LD_ADDR_VAR 0 4
13195: PUSH
13196: LD_INT 0
13198: ST_TO_ADDR
// m2 := false ;
13199: LD_ADDR_VAR 0 5
13203: PUSH
13204: LD_INT 0
13206: ST_TO_ADDR
// m3 := false ;
13207: LD_ADDR_VAR 0 6
13211: PUSH
13212: LD_INT 0
13214: ST_TO_ADDR
// if tick < 40 40$00 then
13215: LD_OWVAR 1
13219: PUSH
13220: LD_INT 84000
13222: LESS
13223: IFFALSE 13232
// SetAchievement ( ACH_ASPEED_17 ) ;
13225: LD_STRING ACH_ASPEED_17
13227: PPUSH
13228: CALL_OW 543
// wait ( 0 0$5 ) ;
13232: LD_INT 175
13234: PPUSH
13235: CALL_OW 67
// if not masha_killed then
13239: LD_EXP 11
13243: NOT
13244: IFFALSE 13266
// begin m1 := true ;
13246: LD_ADDR_VAR 0 4
13250: PUSH
13251: LD_INT 1
13253: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
13254: LD_STRING Masha
13256: PPUSH
13257: LD_INT 1
13259: PPUSH
13260: CALL_OW 101
// end else
13264: GO 13277
// AddMedal ( Masha , - 1 ) ;
13266: LD_STRING Masha
13268: PPUSH
13269: LD_INT 1
13271: NEG
13272: PPUSH
13273: CALL_OW 101
// if abdul_escaped then
13277: LD_EXP 14
13281: IFFALSE 13296
// AddMedal ( Abdul , - 1 ) else
13283: LD_STRING Abdul
13285: PPUSH
13286: LD_INT 1
13288: NEG
13289: PPUSH
13290: CALL_OW 101
13294: GO 13314
// begin m2 := true ;
13296: LD_ADDR_VAR 0 5
13300: PUSH
13301: LD_INT 1
13303: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
13304: LD_STRING Abdul
13306: PPUSH
13307: LD_INT 1
13309: PPUSH
13310: CALL_OW 101
// end ; if loss_counter = 0 then
13314: LD_EXP 15
13318: PUSH
13319: LD_INT 0
13321: EQUAL
13322: IFFALSE 13344
// begin m3 := true ;
13324: LD_ADDR_VAR 0 6
13328: PUSH
13329: LD_INT 1
13331: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
13332: LD_STRING People
13334: PPUSH
13335: LD_INT 2
13337: PPUSH
13338: CALL_OW 101
// end else
13342: GO 13406
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
13344: LD_EXP 15
13348: PUSH
13349: LD_INT 3
13351: PUSH
13352: LD_INT 2
13354: PUSH
13355: LD_INT 2
13357: PUSH
13358: LD_INT 1
13360: PUSH
13361: EMPTY
13362: LIST
13363: LIST
13364: LIST
13365: LIST
13366: PUSH
13367: LD_OWVAR 67
13371: ARRAY
13372: LESSEQUAL
13373: IFFALSE 13395
// begin AddMedal ( People , 1 ) ;
13375: LD_STRING People
13377: PPUSH
13378: LD_INT 1
13380: PPUSH
13381: CALL_OW 101
// m3 := true ;
13385: LD_ADDR_VAR 0 6
13389: PUSH
13390: LD_INT 1
13392: ST_TO_ADDR
// end else
13393: GO 13406
// AddMedal ( People , - 1 ) ;
13395: LD_STRING People
13397: PPUSH
13398: LD_INT 1
13400: NEG
13401: PPUSH
13402: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
13406: LD_OWVAR 67
13410: PUSH
13411: LD_INT 3
13413: GREATEREQUAL
13414: PUSH
13415: LD_VAR 0 4
13419: AND
13420: PUSH
13421: LD_VAR 0 5
13425: AND
13426: PUSH
13427: LD_VAR 0 6
13431: AND
13432: IFFALSE 13444
// SetAchievementEX ( ACH_AMER , 17 ) ;
13434: LD_STRING ACH_AMER
13436: PPUSH
13437: LD_INT 17
13439: PPUSH
13440: CALL_OW 564
// GiveMedals ( MAIN ) ;
13444: LD_STRING MAIN
13446: PPUSH
13447: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
13451: LD_ADDR_VAR 0 2
13455: PUSH
13456: LD_INT 22
13458: PUSH
13459: LD_INT 7
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PUSH
13466: LD_INT 50
13468: PUSH
13469: EMPTY
13470: LIST
13471: PUSH
13472: LD_INT 2
13474: PUSH
13475: LD_INT 25
13477: PUSH
13478: LD_INT 1
13480: PUSH
13481: EMPTY
13482: LIST
13483: LIST
13484: PUSH
13485: LD_INT 25
13487: PUSH
13488: LD_INT 2
13490: PUSH
13491: EMPTY
13492: LIST
13493: LIST
13494: PUSH
13495: LD_INT 25
13497: PUSH
13498: LD_INT 3
13500: PUSH
13501: EMPTY
13502: LIST
13503: LIST
13504: PUSH
13505: LD_INT 25
13507: PUSH
13508: LD_INT 4
13510: PUSH
13511: EMPTY
13512: LIST
13513: LIST
13514: PUSH
13515: LD_INT 25
13517: PUSH
13518: LD_INT 5
13520: PUSH
13521: EMPTY
13522: LIST
13523: LIST
13524: PUSH
13525: LD_INT 25
13527: PUSH
13528: LD_INT 8
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: PUSH
13535: LD_INT 25
13537: PUSH
13538: LD_INT 9
13540: PUSH
13541: EMPTY
13542: LIST
13543: LIST
13544: PUSH
13545: EMPTY
13546: LIST
13547: LIST
13548: LIST
13549: LIST
13550: LIST
13551: LIST
13552: LIST
13553: LIST
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: LIST
13559: PPUSH
13560: CALL_OW 69
13564: ST_TO_ADDR
// RewardPeople ( tmp ) ;
13565: LD_VAR 0 2
13569: PPUSH
13570: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
13574: LD_ADDR_VAR 0 3
13578: PUSH
13579: LD_EXP 17
13583: PUSH
13584: LD_EXP 18
13588: PUSH
13589: LD_EXP 19
13593: PUSH
13594: LD_EXP 20
13598: PUSH
13599: LD_EXP 21
13603: PUSH
13604: LD_EXP 22
13608: PUSH
13609: LD_EXP 23
13613: PUSH
13614: LD_EXP 24
13618: PUSH
13619: LD_EXP 25
13623: PUSH
13624: LD_EXP 26
13628: PUSH
13629: LD_EXP 27
13633: PUSH
13634: LD_EXP 28
13638: PUSH
13639: LD_EXP 29
13643: PUSH
13644: LD_EXP 30
13648: PUSH
13649: LD_EXP 31
13653: PUSH
13654: LD_EXP 32
13658: PUSH
13659: LD_EXP 33
13663: PUSH
13664: LD_EXP 35
13668: PUSH
13669: LD_EXP 36
13673: PUSH
13674: LD_EXP 37
13678: PUSH
13679: LD_EXP 39
13683: PUSH
13684: LD_EXP 40
13688: PUSH
13689: LD_EXP 41
13693: PUSH
13694: LD_EXP 42
13698: PUSH
13699: LD_EXP 43
13703: PUSH
13704: LD_EXP 44
13708: PUSH
13709: LD_EXP 45
13713: PUSH
13714: LD_EXP 46
13718: PUSH
13719: LD_EXP 47
13723: PUSH
13724: LD_EXP 48
13728: PUSH
13729: LD_EXP 49
13733: PUSH
13734: LD_EXP 50
13738: PUSH
13739: LD_EXP 51
13743: PUSH
13744: LD_EXP 34
13748: PUSH
13749: EMPTY
13750: LIST
13751: LIST
13752: LIST
13753: LIST
13754: LIST
13755: LIST
13756: LIST
13757: LIST
13758: LIST
13759: LIST
13760: LIST
13761: LIST
13762: LIST
13763: LIST
13764: LIST
13765: LIST
13766: LIST
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: LIST
13772: LIST
13773: LIST
13774: LIST
13775: LIST
13776: LIST
13777: LIST
13778: LIST
13779: LIST
13780: LIST
13781: LIST
13782: LIST
13783: LIST
13784: ST_TO_ADDR
// if tmp diff tmp2 then
13785: LD_VAR 0 2
13789: PUSH
13790: LD_VAR 0 3
13794: DIFF
13795: IFFALSE 13815
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
13797: LD_VAR 0 2
13801: PUSH
13802: LD_VAR 0 3
13806: DIFF
13807: PPUSH
13808: LD_STRING 13a_others
13810: PPUSH
13811: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
13815: LD_EXP 17
13819: PPUSH
13820: LD_STRING 13a_JMM
13822: PPUSH
13823: CALL_OW 38
// if IsOk ( Mike ) then
13827: LD_EXP 34
13831: PPUSH
13832: CALL_OW 302
13836: IFFALSE 13850
// SaveCharacters ( Mike , 13a_Mike ) ;
13838: LD_EXP 34
13842: PPUSH
13843: LD_STRING 13a_Mike
13845: PPUSH
13846: CALL_OW 38
// if IsOk ( Titov ) then
13850: LD_EXP 37
13854: PPUSH
13855: CALL_OW 302
13859: IFFALSE 13873
// SaveCharacters ( Titov , 13a_Titov ) ;
13861: LD_EXP 37
13865: PPUSH
13866: LD_STRING 13a_Titov
13868: PPUSH
13869: CALL_OW 38
// if IsOk ( Dolgov ) then
13873: LD_EXP 39
13877: PPUSH
13878: CALL_OW 302
13882: IFFALSE 13896
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
13884: LD_EXP 39
13888: PPUSH
13889: LD_STRING 13a_Dolgov
13891: PPUSH
13892: CALL_OW 38
// if IsOk ( Petrosyan ) then
13896: LD_EXP 40
13900: PPUSH
13901: CALL_OW 302
13905: IFFALSE 13919
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
13907: LD_EXP 40
13911: PPUSH
13912: LD_STRING 13a_Petrosyan
13914: PPUSH
13915: CALL_OW 38
// if IsOk ( Scholtze ) then
13919: LD_EXP 41
13923: PPUSH
13924: CALL_OW 302
13928: IFFALSE 13942
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
13930: LD_EXP 41
13934: PPUSH
13935: LD_STRING 13a_Scholtze
13937: PPUSH
13938: CALL_OW 38
// if IsOk ( Oblukov ) then
13942: LD_EXP 42
13946: PPUSH
13947: CALL_OW 302
13951: IFFALSE 13965
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
13953: LD_EXP 42
13957: PPUSH
13958: LD_STRING 13a_Oblukov
13960: PPUSH
13961: CALL_OW 38
// if IsOk ( Kapitsova ) then
13965: LD_EXP 43
13969: PPUSH
13970: CALL_OW 302
13974: IFFALSE 13988
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
13976: LD_EXP 43
13980: PPUSH
13981: LD_STRING 13a_Kapitsova
13983: PPUSH
13984: CALL_OW 38
// if IsOk ( Lipshchin ) then
13988: LD_EXP 44
13992: PPUSH
13993: CALL_OW 302
13997: IFFALSE 14011
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
13999: LD_EXP 44
14003: PPUSH
14004: LD_STRING 13a_Lipshchin
14006: PPUSH
14007: CALL_OW 38
// if IsOk ( Petrovova ) then
14011: LD_EXP 45
14015: PPUSH
14016: CALL_OW 302
14020: IFFALSE 14034
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
14022: LD_EXP 45
14026: PPUSH
14027: LD_STRING 13a_Petrovova
14029: PPUSH
14030: CALL_OW 38
// if IsOk ( Kovalyuk ) then
14034: LD_EXP 46
14038: PPUSH
14039: CALL_OW 302
14043: IFFALSE 14057
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
14045: LD_EXP 46
14049: PPUSH
14050: LD_STRING 13a_Kovalyuk
14052: PPUSH
14053: CALL_OW 38
// if IsOk ( Kuzmov ) then
14057: LD_EXP 47
14061: PPUSH
14062: CALL_OW 302
14066: IFFALSE 14080
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
14068: LD_EXP 47
14072: PPUSH
14073: LD_STRING 13a_Kuzmov
14075: PPUSH
14076: CALL_OW 38
// if IsOk ( Karamazov ) then
14080: LD_EXP 48
14084: PPUSH
14085: CALL_OW 302
14089: IFFALSE 14103
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
14091: LD_EXP 48
14095: PPUSH
14096: LD_STRING 13a_Karamazov
14098: PPUSH
14099: CALL_OW 38
// if Burlak then
14103: LD_EXP 49
14107: IFFALSE 14128
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
14109: LD_STRING enableBioCharacter(BIO_GORKI)
14111: PPUSH
14112: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
14116: LD_EXP 49
14120: PPUSH
14121: LD_STRING 13a_Burlak
14123: PPUSH
14124: CALL_OW 38
// end ; if IsOk ( Belkov ) then
14128: LD_EXP 50
14132: PPUSH
14133: CALL_OW 302
14137: IFFALSE 14151
// SaveCharacters ( Belkov , 13a_Belkov ) ;
14139: LD_EXP 50
14143: PPUSH
14144: LD_STRING 13a_Belkov
14146: PPUSH
14147: CALL_OW 38
// if IsOk ( Gnyevko ) then
14151: LD_EXP 51
14155: PPUSH
14156: CALL_OW 302
14160: IFFALSE 14174
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
14162: LD_EXP 51
14166: PPUSH
14167: LD_STRING 13a_Gnyevko
14169: PPUSH
14170: CALL_OW 38
// if IsOk ( Lisa ) then
14174: LD_EXP 19
14178: PPUSH
14179: CALL_OW 302
14183: IFFALSE 14197
// SaveCharacters ( Lisa , 13a_Lisa ) ;
14185: LD_EXP 19
14189: PPUSH
14190: LD_STRING 13a_Lisa
14192: PPUSH
14193: CALL_OW 38
// if IsOk ( Donaldson ) then
14197: LD_EXP 20
14201: PPUSH
14202: CALL_OW 302
14206: IFFALSE 14220
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
14208: LD_EXP 20
14212: PPUSH
14213: LD_STRING 13a_Donaldson
14215: PPUSH
14216: CALL_OW 38
// if IsOk ( Bobby ) then
14220: LD_EXP 21
14224: PPUSH
14225: CALL_OW 302
14229: IFFALSE 14243
// SaveCharacters ( Bobby , 13a_Bobby ) ;
14231: LD_EXP 21
14235: PPUSH
14236: LD_STRING 13a_Bobby
14238: PPUSH
14239: CALL_OW 38
// if IsOk ( Cyrus ) then
14243: LD_EXP 22
14247: PPUSH
14248: CALL_OW 302
14252: IFFALSE 14266
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
14254: LD_EXP 22
14258: PPUSH
14259: LD_STRING 13a_Cyrus
14261: PPUSH
14262: CALL_OW 38
// if IsOk ( Denis ) then
14266: LD_EXP 23
14270: PPUSH
14271: CALL_OW 302
14275: IFFALSE 14289
// SaveCharacters ( Denis , 13a_Denis ) ;
14277: LD_EXP 23
14281: PPUSH
14282: LD_STRING 13a_Denis
14284: PPUSH
14285: CALL_OW 38
// if IsOk ( Brown ) then
14289: LD_EXP 24
14293: PPUSH
14294: CALL_OW 302
14298: IFFALSE 14312
// SaveCharacters ( Brown , 13a_Brown ) ;
14300: LD_EXP 24
14304: PPUSH
14305: LD_STRING 13a_Brown
14307: PPUSH
14308: CALL_OW 38
// if IsOk ( Gladstone ) then
14312: LD_EXP 25
14316: PPUSH
14317: CALL_OW 302
14321: IFFALSE 14335
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
14323: LD_EXP 25
14327: PPUSH
14328: LD_STRING 13a_Gladstone
14330: PPUSH
14331: CALL_OW 38
// if IsOk ( Houten ) then
14335: LD_EXP 26
14339: PPUSH
14340: CALL_OW 302
14344: IFFALSE 14358
// SaveCharacters ( Houten , 13a_Houten ) ;
14346: LD_EXP 26
14350: PPUSH
14351: LD_STRING 13a_Houten
14353: PPUSH
14354: CALL_OW 38
// if IsOk ( Cornel ) then
14358: LD_EXP 27
14362: PPUSH
14363: CALL_OW 302
14367: IFFALSE 14381
// SaveCharacters ( Cornel , 13a_Cornel ) ;
14369: LD_EXP 27
14373: PPUSH
14374: LD_STRING 13a_Cornel
14376: PPUSH
14377: CALL_OW 38
// if IsOk ( Gary ) then
14381: LD_EXP 28
14385: PPUSH
14386: CALL_OW 302
14390: IFFALSE 14404
// SaveCharacters ( Gary , 13a_Gary ) ;
14392: LD_EXP 28
14396: PPUSH
14397: LD_STRING 13a_Gary
14399: PPUSH
14400: CALL_OW 38
// if IsOk ( Frank ) then
14404: LD_EXP 29
14408: PPUSH
14409: CALL_OW 302
14413: IFFALSE 14427
// SaveCharacters ( Frank , 13a_Frank ) ;
14415: LD_EXP 29
14419: PPUSH
14420: LD_STRING 13a_Frank
14422: PPUSH
14423: CALL_OW 38
// if IsOk ( Kikuchi ) then
14427: LD_EXP 30
14431: PPUSH
14432: CALL_OW 302
14436: IFFALSE 14450
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
14438: LD_EXP 30
14442: PPUSH
14443: LD_STRING 13a_Kikuchi
14445: PPUSH
14446: CALL_OW 38
// if IsOk ( Simms ) then
14450: LD_EXP 31
14454: PPUSH
14455: CALL_OW 302
14459: IFFALSE 14473
// SaveCharacters ( Simms , 13a_Simms ) ;
14461: LD_EXP 31
14465: PPUSH
14466: LD_STRING 13a_Simms
14468: PPUSH
14469: CALL_OW 38
// if IsOk ( Joan ) then
14473: LD_EXP 32
14477: PPUSH
14478: CALL_OW 302
14482: IFFALSE 14496
// SaveCharacters ( Joan , 13a_Joan ) ;
14484: LD_EXP 32
14488: PPUSH
14489: LD_STRING 13a_Joan
14491: PPUSH
14492: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
14496: LD_EXP 33
14500: PPUSH
14501: CALL_OW 302
14505: IFFALSE 14519
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
14507: LD_EXP 33
14511: PPUSH
14512: LD_STRING 13a_DeltaDoctor
14514: PPUSH
14515: CALL_OW 38
// if IsOk ( Gossudarov ) then
14519: LD_EXP 35
14523: PPUSH
14524: CALL_OW 302
14528: IFFALSE 14542
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
14530: LD_EXP 35
14534: PPUSH
14535: LD_STRING 13a_Gossudarov
14537: PPUSH
14538: CALL_OW 38
// if IsOk ( Kirilenkova ) then
14542: LD_EXP 36
14546: PPUSH
14547: CALL_OW 302
14551: IFFALSE 14565
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
14553: LD_EXP 36
14557: PPUSH
14558: LD_STRING 13a_Kirilenkova
14560: PPUSH
14561: CALL_OW 38
// if IsOk ( Roth ) then
14565: LD_EXP 18
14569: PPUSH
14570: CALL_OW 302
14574: IFFALSE 14588
// SaveCharacters ( Roth , 13a_Roth ) ;
14576: LD_EXP 18
14580: PPUSH
14581: LD_STRING 13a_Roth
14583: PPUSH
14584: CALL_OW 38
// if Masha then
14588: LD_EXP 52
14592: IFFALSE 14647
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
14594: LD_EXP 52
14598: PPUSH
14599: CALL_OW 265
14603: PUSH
14604: LD_EXP 52
14608: PPUSH
14609: CALL_OW 262
14613: PUSH
14614: LD_EXP 52
14618: PPUSH
14619: CALL_OW 263
14623: PUSH
14624: LD_EXP 52
14628: PPUSH
14629: CALL_OW 264
14633: PUSH
14634: EMPTY
14635: LIST
14636: LIST
14637: LIST
14638: LIST
14639: PPUSH
14640: LD_STRING 13a_Masha
14642: PPUSH
14643: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
14647: LD_ADDR_VAR 0 2
14651: PUSH
14652: LD_INT 21
14654: PUSH
14655: LD_INT 3
14657: PUSH
14658: EMPTY
14659: LIST
14660: LIST
14661: PPUSH
14662: CALL_OW 69
14666: ST_TO_ADDR
// tmp2 := [ ] ;
14667: LD_ADDR_VAR 0 3
14671: PUSH
14672: EMPTY
14673: ST_TO_ADDR
// if tmp then
14674: LD_VAR 0 2
14678: IFFALSE 14829
// for i in tmp do
14680: LD_ADDR_VAR 0 1
14684: PUSH
14685: LD_VAR 0 2
14689: PUSH
14690: FOR_IN
14691: IFFALSE 14827
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
14693: LD_ADDR_VAR 0 3
14697: PUSH
14698: LD_VAR 0 3
14702: PUSH
14703: LD_VAR 0 1
14707: PPUSH
14708: CALL_OW 255
14712: PUSH
14713: LD_VAR 0 1
14717: PPUSH
14718: CALL_OW 248
14722: PUSH
14723: LD_VAR 0 1
14727: PPUSH
14728: CALL_OW 266
14732: PUSH
14733: LD_VAR 0 1
14737: PPUSH
14738: CALL_OW 250
14742: PUSH
14743: LD_VAR 0 1
14747: PPUSH
14748: CALL_OW 251
14752: PUSH
14753: LD_VAR 0 1
14757: PPUSH
14758: CALL_OW 254
14762: PUSH
14763: LD_VAR 0 1
14767: PPUSH
14768: CALL_OW 267
14772: PUSH
14773: LD_VAR 0 1
14777: PPUSH
14778: LD_INT 1
14780: PPUSH
14781: CALL_OW 268
14785: PUSH
14786: LD_VAR 0 1
14790: PPUSH
14791: LD_INT 2
14793: PPUSH
14794: CALL_OW 268
14798: PUSH
14799: LD_VAR 0 1
14803: PPUSH
14804: CALL_OW 269
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: LIST
14817: LIST
14818: LIST
14819: LIST
14820: PUSH
14821: EMPTY
14822: LIST
14823: ADD
14824: ST_TO_ADDR
14825: GO 14690
14827: POP
14828: POP
// if tmp2 then
14829: LD_VAR 0 3
14833: IFFALSE 14847
// SaveVariable ( tmp2 , 13a_buildings ) ;
14835: LD_VAR 0 3
14839: PPUSH
14840: LD_STRING 13a_buildings
14842: PPUSH
14843: CALL_OW 39
// YouWin ;
14847: CALL_OW 103
// end ;
14851: PPOPN 6
14853: END
// export function SciRu ; var tmp , t ; begin
14854: LD_INT 0
14856: PPUSH
14857: PPUSH
14858: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14859: LD_ADDR_VAR 0 3
14863: PUSH
14864: LD_EXP 35
14868: PUSH
14869: LD_EXP 49
14873: PUSH
14874: LD_EXP 37
14878: PUSH
14879: LD_EXP 50
14883: PUSH
14884: LD_EXP 51
14888: PUSH
14889: LD_EXP 40
14893: PUSH
14894: LD_EXP 41
14898: PUSH
14899: LD_EXP 39
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: LIST
14908: LIST
14909: LIST
14910: LIST
14911: LIST
14912: LIST
14913: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
14914: LD_ADDR_VAR 0 2
14918: PUSH
14919: LD_INT 22
14921: PUSH
14922: LD_INT 7
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: PUSH
14929: LD_INT 23
14931: PUSH
14932: LD_INT 3
14934: PUSH
14935: EMPTY
14936: LIST
14937: LIST
14938: PUSH
14939: LD_INT 25
14941: PUSH
14942: LD_INT 4
14944: PUSH
14945: EMPTY
14946: LIST
14947: LIST
14948: PUSH
14949: LD_INT 26
14951: PUSH
14952: LD_INT 1
14954: PUSH
14955: EMPTY
14956: LIST
14957: LIST
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: LIST
14963: LIST
14964: PPUSH
14965: CALL_OW 69
14969: PUSH
14970: LD_VAR 0 3
14974: DIFF
14975: ST_TO_ADDR
// if tmp then
14976: LD_VAR 0 2
14980: IFFALSE 14996
// result := tmp [ 1 ] ;
14982: LD_ADDR_VAR 0 1
14986: PUSH
14987: LD_VAR 0 2
14991: PUSH
14992: LD_INT 1
14994: ARRAY
14995: ST_TO_ADDR
// end ;
14996: LD_VAR 0 1
15000: RET
// export function SolRu ; var tmp , t ; begin
15001: LD_INT 0
15003: PPUSH
15004: PPUSH
15005: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15006: LD_ADDR_VAR 0 3
15010: PUSH
15011: LD_EXP 35
15015: PUSH
15016: LD_EXP 49
15020: PUSH
15021: LD_EXP 37
15025: PUSH
15026: LD_EXP 50
15030: PUSH
15031: LD_EXP 51
15035: PUSH
15036: LD_EXP 40
15040: PUSH
15041: LD_EXP 41
15045: PUSH
15046: LD_EXP 39
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: LIST
15055: LIST
15056: LIST
15057: LIST
15058: LIST
15059: LIST
15060: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
15061: LD_ADDR_VAR 0 2
15065: PUSH
15066: LD_INT 22
15068: PUSH
15069: LD_INT 7
15071: PUSH
15072: EMPTY
15073: LIST
15074: LIST
15075: PUSH
15076: LD_INT 23
15078: PUSH
15079: LD_INT 3
15081: PUSH
15082: EMPTY
15083: LIST
15084: LIST
15085: PUSH
15086: LD_INT 25
15088: PUSH
15089: LD_INT 1
15091: PUSH
15092: EMPTY
15093: LIST
15094: LIST
15095: PUSH
15096: LD_INT 26
15098: PUSH
15099: LD_INT 1
15101: PUSH
15102: EMPTY
15103: LIST
15104: LIST
15105: PUSH
15106: EMPTY
15107: LIST
15108: LIST
15109: LIST
15110: LIST
15111: PPUSH
15112: CALL_OW 69
15116: PUSH
15117: LD_VAR 0 3
15121: DIFF
15122: ST_TO_ADDR
// if tmp then
15123: LD_VAR 0 2
15127: IFFALSE 15143
// result := tmp [ 1 ] ;
15129: LD_ADDR_VAR 0 1
15133: PUSH
15134: LD_VAR 0 2
15138: PUSH
15139: LD_INT 1
15141: ARRAY
15142: ST_TO_ADDR
// end ; end_of_file
15143: LD_VAR 0 1
15147: RET
// export function CustomEvent ( event ) ; begin
15148: LD_INT 0
15150: PPUSH
// end ;
15151: LD_VAR 0 2
15155: RET
// on UnitDestroyed ( un ) do var i , side ;
15156: LD_INT 0
15158: PPUSH
15159: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
15160: LD_VAR 0 1
15164: PPUSH
15165: CALL 105802 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
15169: LD_VAR 0 1
15173: PUSH
15174: LD_INT 22
15176: PUSH
15177: LD_INT 7
15179: PUSH
15180: EMPTY
15181: LIST
15182: LIST
15183: PUSH
15184: LD_INT 2
15186: PUSH
15187: LD_INT 25
15189: PUSH
15190: LD_INT 1
15192: PUSH
15193: EMPTY
15194: LIST
15195: LIST
15196: PUSH
15197: LD_INT 25
15199: PUSH
15200: LD_INT 2
15202: PUSH
15203: EMPTY
15204: LIST
15205: LIST
15206: PUSH
15207: LD_INT 25
15209: PUSH
15210: LD_INT 3
15212: PUSH
15213: EMPTY
15214: LIST
15215: LIST
15216: PUSH
15217: LD_INT 25
15219: PUSH
15220: LD_INT 4
15222: PUSH
15223: EMPTY
15224: LIST
15225: LIST
15226: PUSH
15227: LD_INT 25
15229: PUSH
15230: LD_INT 5
15232: PUSH
15233: EMPTY
15234: LIST
15235: LIST
15236: PUSH
15237: LD_INT 25
15239: PUSH
15240: LD_INT 8
15242: PUSH
15243: EMPTY
15244: LIST
15245: LIST
15246: PUSH
15247: LD_INT 25
15249: PUSH
15250: LD_INT 9
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: PUSH
15257: EMPTY
15258: LIST
15259: LIST
15260: LIST
15261: LIST
15262: LIST
15263: LIST
15264: LIST
15265: LIST
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 69
15275: IN
15276: IFFALSE 15292
// loss_counter := loss_counter + 1 ;
15278: LD_ADDR_EXP 15
15282: PUSH
15283: LD_EXP 15
15287: PUSH
15288: LD_INT 1
15290: PLUS
15291: ST_TO_ADDR
// if un = Abdul then
15292: LD_VAR 0 1
15296: PUSH
15297: LD_EXP 58
15301: EQUAL
15302: IFFALSE 15312
// abdul_escaped := false ;
15304: LD_ADDR_EXP 14
15308: PUSH
15309: LD_INT 0
15311: ST_TO_ADDR
// if un in ru_attackers then
15312: LD_VAR 0 1
15316: PUSH
15317: LD_EXP 55
15321: IN
15322: IFFALSE 15340
// ru_attackers := ru_attackers diff un ;
15324: LD_ADDR_EXP 55
15328: PUSH
15329: LD_EXP 55
15333: PUSH
15334: LD_VAR 0 1
15338: DIFF
15339: ST_TO_ADDR
// if un in ar_attackers then
15340: LD_VAR 0 1
15344: PUSH
15345: LD_EXP 12
15349: IN
15350: IFFALSE 15368
// ar_attackers := ar_attackers diff un ;
15352: LD_ADDR_EXP 12
15356: PUSH
15357: LD_EXP 12
15361: PUSH
15362: LD_VAR 0 1
15366: DIFF
15367: ST_TO_ADDR
// if un = JMM then
15368: LD_VAR 0 1
15372: PUSH
15373: LD_EXP 17
15377: EQUAL
15378: IFFALSE 15389
// begin YouLost ( JMM ) ;
15380: LD_STRING JMM
15382: PPUSH
15383: CALL_OW 104
// exit ;
15387: GO 15486
// end ; if un = Burlak then
15389: LD_VAR 0 1
15393: PUSH
15394: LD_EXP 49
15398: EQUAL
15399: IFFALSE 15410
// begin YouLost ( Burlak ) ;
15401: LD_STRING Burlak
15403: PPUSH
15404: CALL_OW 104
// exit ;
15408: GO 15486
// end ; if un = freedom then
15410: LD_VAR 0 1
15414: PUSH
15415: LD_EXP 3
15419: EQUAL
15420: IFFALSE 15431
// begin YouLost ( Destroyed ) ;
15422: LD_STRING Destroyed
15424: PPUSH
15425: CALL_OW 104
// exit ;
15429: GO 15486
// end ; if un = Masha then
15431: LD_VAR 0 1
15435: PUSH
15436: LD_EXP 52
15440: EQUAL
15441: IFFALSE 15458
// begin ChangeMissionObjectives ( M4b ) ;
15443: LD_STRING M4b
15445: PPUSH
15446: CALL_OW 337
// masha_killed := true ;
15450: LD_ADDR_EXP 11
15454: PUSH
15455: LD_INT 1
15457: ST_TO_ADDR
// end ; if un = Mastodont then
15458: LD_VAR 0 1
15462: PUSH
15463: LD_EXP 59
15467: EQUAL
15468: IFFALSE 15477
// ChangeMissionObjectives ( M4a ) ;
15470: LD_STRING M4a
15472: PPUSH
15473: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
15477: LD_VAR 0 1
15481: PPUSH
15482: CALL 86999 0 1
// end ;
15486: PPOPN 3
15488: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
15489: LD_VAR 0 1
15493: PPUSH
15494: LD_VAR 0 2
15498: PPUSH
15499: CALL 89331 0 2
// end ;
15503: PPOPN 2
15505: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
15506: LD_VAR 0 1
15510: PPUSH
15511: CALL 88399 0 1
// end ;
15515: PPOPN 1
15517: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
15518: LD_VAR 0 1
15522: PUSH
15523: LD_INT 22
15525: PUSH
15526: LD_INT 7
15528: PUSH
15529: EMPTY
15530: LIST
15531: LIST
15532: PUSH
15533: LD_INT 30
15535: PUSH
15536: LD_INT 0
15538: PUSH
15539: EMPTY
15540: LIST
15541: LIST
15542: PUSH
15543: EMPTY
15544: LIST
15545: LIST
15546: PPUSH
15547: CALL_OW 69
15551: IN
15552: IFFALSE 15591
// begin SetBName ( building , freedom ) ;
15554: LD_VAR 0 1
15558: PPUSH
15559: LD_STRING freedom
15561: PPUSH
15562: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
15566: LD_INT 0
15568: PPUSH
15569: LD_INT 7
15571: PPUSH
15572: LD_INT 0
15574: PPUSH
15575: CALL_OW 324
// freedom := building ;
15579: LD_ADDR_EXP 3
15583: PUSH
15584: LD_VAR 0 1
15588: ST_TO_ADDR
// exit ;
15589: GO 15657
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
15591: LD_VAR 0 1
15595: PUSH
15596: LD_INT 22
15598: PUSH
15599: LD_INT 7
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: PUSH
15606: LD_INT 23
15608: PUSH
15609: LD_INT 3
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: PUSH
15616: LD_INT 30
15618: PUSH
15619: LD_INT 6
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: LIST
15630: PPUSH
15631: CALL_OW 69
15635: IN
15636: IFFALSE 15648
// begin ru_lab_builded := true ;
15638: LD_ADDR_EXP 5
15642: PUSH
15643: LD_INT 1
15645: ST_TO_ADDR
// exit ;
15646: GO 15657
// end ; MCE_BuildingComplete ( building ) ;
15648: LD_VAR 0 1
15652: PPUSH
15653: CALL 88640 0 1
// end ;
15657: PPOPN 1
15659: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
15660: LD_VAR 0 1
15664: PPUSH
15665: LD_VAR 0 2
15669: PPUSH
15670: CALL 86695 0 2
// end ;
15674: PPOPN 2
15676: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
15677: LD_VAR 0 1
15681: PPUSH
15682: LD_VAR 0 2
15686: PPUSH
15687: LD_VAR 0 3
15691: PPUSH
15692: LD_VAR 0 4
15696: PPUSH
15697: LD_VAR 0 5
15701: PPUSH
15702: CALL 86315 0 5
// end ;
15706: PPOPN 5
15708: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
15709: LD_VAR 0 1
15713: PPUSH
15714: LD_VAR 0 2
15718: PPUSH
15719: CALL 105922 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
15723: LD_VAR 0 1
15727: PPUSH
15728: LD_VAR 0 2
15732: PPUSH
15733: CALL 85868 0 2
// end ;
15737: PPOPN 2
15739: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
15740: LD_VAR 0 1
15744: PPUSH
15745: CALL_OW 263
15749: PUSH
15750: LD_INT 3
15752: EQUAL
15753: PUSH
15754: LD_VAR 0 2
15758: PPUSH
15759: CALL_OW 263
15763: PUSH
15764: LD_INT 3
15766: EQUAL
15767: OR
15768: IFFALSE 15784
// hack_counter := hack_counter + 1 ;
15770: LD_ADDR_EXP 16
15774: PUSH
15775: LD_EXP 16
15779: PUSH
15780: LD_INT 1
15782: PLUS
15783: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
15784: LD_VAR 0 1
15788: PPUSH
15789: LD_VAR 0 2
15793: PPUSH
15794: LD_VAR 0 3
15798: PPUSH
15799: LD_VAR 0 4
15803: PPUSH
15804: CALL 85706 0 4
// end ;
15808: PPOPN 4
15810: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin if building = ru_depot then
15811: LD_VAR 0 1
15815: PUSH
15816: LD_INT 47
15818: EQUAL
15819: IFFALSE 15841
// SetResourceType ( GetBase ( building ) , mat_cans , 600 ) ;
15821: LD_VAR 0 1
15825: PPUSH
15826: CALL_OW 274
15830: PPUSH
15831: LD_INT 1
15833: PPUSH
15834: LD_INT 600
15836: PPUSH
15837: CALL_OW 277
// MCE_BuildingCaptured ( building , side , capturning_unit ) ;
15841: LD_VAR 0 1
15845: PPUSH
15846: LD_VAR 0 2
15850: PPUSH
15851: LD_VAR 0 3
15855: PPUSH
15856: CALL 85481 0 3
// end ;
15860: PPOPN 3
15862: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
15863: LD_VAR 0 1
15867: PPUSH
15868: LD_VAR 0 2
15872: PPUSH
15873: CALL 85366 0 2
// end ;
15877: PPOPN 2
15879: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
15880: LD_VAR 0 1
15884: PPUSH
15885: LD_VAR 0 2
15889: PPUSH
15890: CALL 89626 0 2
// end ;
15894: PPOPN 2
15896: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
15897: LD_VAR 0 1
15901: PPUSH
15902: LD_VAR 0 2
15906: PPUSH
15907: LD_VAR 0 3
15911: PPUSH
15912: LD_VAR 0 4
15916: PPUSH
15917: CALL 89842 0 4
// end ;
15921: PPOPN 4
15923: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
15924: LD_VAR 0 1
15928: PPUSH
15929: LD_VAR 0 2
15933: PPUSH
15934: CALL 85175 0 2
// end ;
15938: PPOPN 2
15940: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
15941: LD_VAR 0 1
15945: PPUSH
15946: CALL 105906 0 1
// end ; end_of_file
15950: PPOPN 1
15952: END
// every 0 0$30 do var cr , time ;
15953: GO 15955
15955: DISABLE
15956: LD_INT 0
15958: PPUSH
15959: PPUSH
// begin time := 0 0$20 ;
15960: LD_ADDR_VAR 0 2
15964: PUSH
15965: LD_INT 700
15967: ST_TO_ADDR
// while game do
15968: LD_EXP 2
15972: IFFALSE 16075
// begin wait ( time ) ;
15974: LD_VAR 0 2
15978: PPUSH
15979: CALL_OW 67
// if tick > 2 2$00 then
15983: LD_OWVAR 1
15987: PUSH
15988: LD_INT 4200
15990: GREATER
15991: IFFALSE 16028
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
15993: LD_ADDR_VAR 0 2
15997: PUSH
15998: LD_VAR 0 2
16002: PUSH
16003: LD_INT 140
16005: PUSH
16006: LD_INT 140
16008: PUSH
16009: LD_INT 210
16011: PUSH
16012: LD_INT 280
16014: PUSH
16015: EMPTY
16016: LIST
16017: LIST
16018: LIST
16019: LIST
16020: PUSH
16021: LD_OWVAR 67
16025: ARRAY
16026: PLUS
16027: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
16028: LD_INT 1
16030: PPUSH
16031: LD_INT 5
16033: PPUSH
16034: CALL_OW 12
16038: PPUSH
16039: LD_INT 70
16041: PPUSH
16042: LD_INT 49
16044: PPUSH
16045: LD_INT 25
16047: PPUSH
16048: LD_INT 1
16050: PPUSH
16051: CALL_OW 56
// if time > 3 3$00 then
16055: LD_VAR 0 2
16059: PUSH
16060: LD_INT 6300
16062: GREATER
16063: IFFALSE 16073
// time := 0 0$30 ;
16065: LD_ADDR_VAR 0 2
16069: PUSH
16070: LD_INT 1050
16072: ST_TO_ADDR
// end ;
16073: GO 15968
// end ;
16075: PPOPN 2
16077: END
// every 0 0$30 do var cr , time ;
16078: GO 16080
16080: DISABLE
16081: LD_INT 0
16083: PPUSH
16084: PPUSH
// begin time := 0 0$20 ;
16085: LD_ADDR_VAR 0 2
16089: PUSH
16090: LD_INT 700
16092: ST_TO_ADDR
// while game do
16093: LD_EXP 2
16097: IFFALSE 16190
// begin wait ( time ) ;
16099: LD_VAR 0 2
16103: PPUSH
16104: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16108: LD_ADDR_VAR 0 2
16112: PUSH
16113: LD_VAR 0 2
16117: PUSH
16118: LD_INT 140
16120: PUSH
16121: LD_INT 175
16123: PUSH
16124: LD_INT 210
16126: PUSH
16127: LD_INT 280
16129: PUSH
16130: EMPTY
16131: LIST
16132: LIST
16133: LIST
16134: LIST
16135: PUSH
16136: LD_OWVAR 67
16140: ARRAY
16141: PLUS
16142: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
16143: LD_INT 3
16145: PPUSH
16146: LD_INT 5
16148: PPUSH
16149: CALL_OW 12
16153: PPUSH
16154: LD_INT 26
16156: PPUSH
16157: LD_INT 9
16159: PPUSH
16160: LD_INT 30
16162: PPUSH
16163: LD_INT 1
16165: PPUSH
16166: CALL_OW 56
// if time > 3 3$00 then
16170: LD_VAR 0 2
16174: PUSH
16175: LD_INT 6300
16177: GREATER
16178: IFFALSE 16188
// time := 0 0$20 ;
16180: LD_ADDR_VAR 0 2
16184: PUSH
16185: LD_INT 700
16187: ST_TO_ADDR
// end ;
16188: GO 16093
// end ;
16190: PPOPN 2
16192: END
// every 0 0$30 do var cr , time ;
16193: GO 16195
16195: DISABLE
16196: LD_INT 0
16198: PPUSH
16199: PPUSH
// begin time := 0 0$20 ;
16200: LD_ADDR_VAR 0 2
16204: PUSH
16205: LD_INT 700
16207: ST_TO_ADDR
// while game do
16208: LD_EXP 2
16212: IFFALSE 16341
// begin wait ( time ) ;
16214: LD_VAR 0 2
16218: PPUSH
16219: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
16223: LD_ADDR_VAR 0 2
16227: PUSH
16228: LD_VAR 0 2
16232: PUSH
16233: LD_INT 175
16235: PUSH
16236: LD_INT 210
16238: PUSH
16239: LD_INT 280
16241: PUSH
16242: LD_INT 350
16244: PUSH
16245: EMPTY
16246: LIST
16247: LIST
16248: LIST
16249: LIST
16250: PUSH
16251: LD_OWVAR 67
16255: ARRAY
16256: PLUS
16257: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
16258: LD_INT 1
16260: PPUSH
16261: LD_INT 5
16263: PPUSH
16264: CALL_OW 12
16268: PPUSH
16269: LD_INT 179
16271: PPUSH
16272: LD_INT 101
16274: PPUSH
16275: LD_INT 20
16277: PPUSH
16278: LD_INT 1
16280: PPUSH
16281: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
16285: LD_INT 350
16287: PPUSH
16288: LD_INT 525
16290: PPUSH
16291: CALL_OW 12
16295: PPUSH
16296: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
16300: LD_INT 1
16302: PPUSH
16303: LD_INT 5
16305: PPUSH
16306: CALL_OW 12
16310: PPUSH
16311: LD_INT 9
16313: PPUSH
16314: LD_INT 1
16316: PPUSH
16317: CALL_OW 55
// if time > 4 4$00 then
16321: LD_VAR 0 2
16325: PUSH
16326: LD_INT 8400
16328: GREATER
16329: IFFALSE 16339
// time := 0 0$30 ;
16331: LD_ADDR_VAR 0 2
16335: PUSH
16336: LD_INT 1050
16338: ST_TO_ADDR
// end ;
16339: GO 16208
// end ;
16341: PPOPN 2
16343: END
// every 0 0$30 do var cr , time ;
16344: GO 16346
16346: DISABLE
16347: LD_INT 0
16349: PPUSH
16350: PPUSH
// begin time := 0 0$10 ;
16351: LD_ADDR_VAR 0 2
16355: PUSH
16356: LD_INT 350
16358: ST_TO_ADDR
// while game do
16359: LD_EXP 2
16363: IFFALSE 16497
// begin wait ( time ) ;
16365: LD_VAR 0 2
16369: PPUSH
16370: CALL_OW 67
// time := time + 0 0$10 ;
16374: LD_ADDR_VAR 0 2
16378: PUSH
16379: LD_VAR 0 2
16383: PUSH
16384: LD_INT 350
16386: PLUS
16387: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
16388: LD_INT 1
16390: PPUSH
16391: LD_INT 5
16393: PPUSH
16394: CALL_OW 12
16398: PPUSH
16399: LD_INT 11
16401: PPUSH
16402: LD_INT 1
16404: PPUSH
16405: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
16409: LD_ADDR_VAR 0 1
16413: PUSH
16414: LD_INT 1
16416: PPUSH
16417: LD_INT 3
16419: PPUSH
16420: CALL_OW 12
16424: ST_TO_ADDR
// if cr = 1 then
16425: LD_VAR 0 1
16429: PUSH
16430: LD_INT 1
16432: EQUAL
16433: IFFALSE 16477
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
16435: LD_INT 700
16437: PPUSH
16438: LD_INT 1575
16440: PPUSH
16441: CALL_OW 12
16445: PPUSH
16446: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
16450: LD_INT 1
16452: PPUSH
16453: LD_INT 5
16455: PPUSH
16456: CALL_OW 12
16460: PPUSH
16461: LD_INT 34
16463: PPUSH
16464: LD_INT 50
16466: PPUSH
16467: LD_INT 7
16469: PPUSH
16470: LD_INT 1
16472: PPUSH
16473: CALL_OW 56
// end ; if time > 4 4$00 then
16477: LD_VAR 0 2
16481: PUSH
16482: LD_INT 8400
16484: GREATER
16485: IFFALSE 16495
// time := 0 0$40 ;
16487: LD_ADDR_VAR 0 2
16491: PUSH
16492: LD_INT 1400
16494: ST_TO_ADDR
// end ;
16495: GO 16359
// end ; end_of_file
16497: PPOPN 2
16499: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
16500: LD_INT 0
16502: PPUSH
16503: PPUSH
// if exist_mode then
16504: LD_VAR 0 2
16508: IFFALSE 16533
// unit := CreateCharacter ( prefix & ident ) else
16510: LD_ADDR_VAR 0 5
16514: PUSH
16515: LD_VAR 0 3
16519: PUSH
16520: LD_VAR 0 1
16524: STR
16525: PPUSH
16526: CALL_OW 34
16530: ST_TO_ADDR
16531: GO 16548
// unit := NewCharacter ( ident ) ;
16533: LD_ADDR_VAR 0 5
16537: PUSH
16538: LD_VAR 0 1
16542: PPUSH
16543: CALL_OW 25
16547: ST_TO_ADDR
// result := unit ;
16548: LD_ADDR_VAR 0 4
16552: PUSH
16553: LD_VAR 0 5
16557: ST_TO_ADDR
// end ;
16558: LD_VAR 0 4
16562: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
16563: LD_INT 0
16565: PPUSH
16566: PPUSH
// if not side or not nation then
16567: LD_VAR 0 1
16571: NOT
16572: PUSH
16573: LD_VAR 0 2
16577: NOT
16578: OR
16579: IFFALSE 16583
// exit ;
16581: GO 17351
// case nation of nation_american :
16583: LD_VAR 0 2
16587: PUSH
16588: LD_INT 1
16590: DOUBLE
16591: EQUAL
16592: IFTRUE 16596
16594: GO 16810
16596: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
16597: LD_ADDR_VAR 0 4
16601: PUSH
16602: LD_INT 35
16604: PUSH
16605: LD_INT 45
16607: PUSH
16608: LD_INT 46
16610: PUSH
16611: LD_INT 47
16613: PUSH
16614: LD_INT 82
16616: PUSH
16617: LD_INT 83
16619: PUSH
16620: LD_INT 84
16622: PUSH
16623: LD_INT 85
16625: PUSH
16626: LD_INT 86
16628: PUSH
16629: LD_INT 1
16631: PUSH
16632: LD_INT 2
16634: PUSH
16635: LD_INT 6
16637: PUSH
16638: LD_INT 15
16640: PUSH
16641: LD_INT 16
16643: PUSH
16644: LD_INT 7
16646: PUSH
16647: LD_INT 12
16649: PUSH
16650: LD_INT 13
16652: PUSH
16653: LD_INT 10
16655: PUSH
16656: LD_INT 14
16658: PUSH
16659: LD_INT 20
16661: PUSH
16662: LD_INT 21
16664: PUSH
16665: LD_INT 22
16667: PUSH
16668: LD_INT 25
16670: PUSH
16671: LD_INT 32
16673: PUSH
16674: LD_INT 27
16676: PUSH
16677: LD_INT 36
16679: PUSH
16680: LD_INT 69
16682: PUSH
16683: LD_INT 39
16685: PUSH
16686: LD_INT 34
16688: PUSH
16689: LD_INT 40
16691: PUSH
16692: LD_INT 48
16694: PUSH
16695: LD_INT 49
16697: PUSH
16698: LD_INT 50
16700: PUSH
16701: LD_INT 51
16703: PUSH
16704: LD_INT 52
16706: PUSH
16707: LD_INT 53
16709: PUSH
16710: LD_INT 54
16712: PUSH
16713: LD_INT 55
16715: PUSH
16716: LD_INT 56
16718: PUSH
16719: LD_INT 57
16721: PUSH
16722: LD_INT 58
16724: PUSH
16725: LD_INT 59
16727: PUSH
16728: LD_INT 60
16730: PUSH
16731: LD_INT 61
16733: PUSH
16734: LD_INT 62
16736: PUSH
16737: LD_INT 80
16739: PUSH
16740: LD_INT 82
16742: PUSH
16743: LD_INT 83
16745: PUSH
16746: LD_INT 84
16748: PUSH
16749: LD_INT 85
16751: PUSH
16752: LD_INT 86
16754: PUSH
16755: EMPTY
16756: LIST
16757: LIST
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: LIST
16763: LIST
16764: LIST
16765: LIST
16766: LIST
16767: LIST
16768: LIST
16769: LIST
16770: LIST
16771: LIST
16772: LIST
16773: LIST
16774: LIST
16775: LIST
16776: LIST
16777: LIST
16778: LIST
16779: LIST
16780: LIST
16781: LIST
16782: LIST
16783: LIST
16784: LIST
16785: LIST
16786: LIST
16787: LIST
16788: LIST
16789: LIST
16790: LIST
16791: LIST
16792: LIST
16793: LIST
16794: LIST
16795: LIST
16796: LIST
16797: LIST
16798: LIST
16799: LIST
16800: LIST
16801: LIST
16802: LIST
16803: LIST
16804: LIST
16805: LIST
16806: LIST
16807: ST_TO_ADDR
16808: GO 17275
16810: LD_INT 2
16812: DOUBLE
16813: EQUAL
16814: IFTRUE 16818
16816: GO 17044
16818: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
16819: LD_ADDR_VAR 0 4
16823: PUSH
16824: LD_INT 35
16826: PUSH
16827: LD_INT 45
16829: PUSH
16830: LD_INT 46
16832: PUSH
16833: LD_INT 47
16835: PUSH
16836: LD_INT 82
16838: PUSH
16839: LD_INT 83
16841: PUSH
16842: LD_INT 84
16844: PUSH
16845: LD_INT 85
16847: PUSH
16848: LD_INT 87
16850: PUSH
16851: LD_INT 70
16853: PUSH
16854: LD_INT 1
16856: PUSH
16857: LD_INT 11
16859: PUSH
16860: LD_INT 3
16862: PUSH
16863: LD_INT 4
16865: PUSH
16866: LD_INT 5
16868: PUSH
16869: LD_INT 6
16871: PUSH
16872: LD_INT 15
16874: PUSH
16875: LD_INT 18
16877: PUSH
16878: LD_INT 7
16880: PUSH
16881: LD_INT 17
16883: PUSH
16884: LD_INT 8
16886: PUSH
16887: LD_INT 20
16889: PUSH
16890: LD_INT 21
16892: PUSH
16893: LD_INT 22
16895: PUSH
16896: LD_INT 72
16898: PUSH
16899: LD_INT 26
16901: PUSH
16902: LD_INT 69
16904: PUSH
16905: LD_INT 39
16907: PUSH
16908: LD_INT 40
16910: PUSH
16911: LD_INT 41
16913: PUSH
16914: LD_INT 42
16916: PUSH
16917: LD_INT 43
16919: PUSH
16920: LD_INT 48
16922: PUSH
16923: LD_INT 49
16925: PUSH
16926: LD_INT 50
16928: PUSH
16929: LD_INT 51
16931: PUSH
16932: LD_INT 52
16934: PUSH
16935: LD_INT 53
16937: PUSH
16938: LD_INT 54
16940: PUSH
16941: LD_INT 55
16943: PUSH
16944: LD_INT 56
16946: PUSH
16947: LD_INT 60
16949: PUSH
16950: LD_INT 61
16952: PUSH
16953: LD_INT 62
16955: PUSH
16956: LD_INT 66
16958: PUSH
16959: LD_INT 67
16961: PUSH
16962: LD_INT 68
16964: PUSH
16965: LD_INT 81
16967: PUSH
16968: LD_INT 82
16970: PUSH
16971: LD_INT 83
16973: PUSH
16974: LD_INT 84
16976: PUSH
16977: LD_INT 85
16979: PUSH
16980: LD_INT 87
16982: PUSH
16983: LD_INT 88
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: LIST
16993: LIST
16994: LIST
16995: LIST
16996: LIST
16997: LIST
16998: LIST
16999: LIST
17000: LIST
17001: LIST
17002: LIST
17003: LIST
17004: LIST
17005: LIST
17006: LIST
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: LIST
17013: LIST
17014: LIST
17015: LIST
17016: LIST
17017: LIST
17018: LIST
17019: LIST
17020: LIST
17021: LIST
17022: LIST
17023: LIST
17024: LIST
17025: LIST
17026: LIST
17027: LIST
17028: LIST
17029: LIST
17030: LIST
17031: LIST
17032: LIST
17033: LIST
17034: LIST
17035: LIST
17036: LIST
17037: LIST
17038: LIST
17039: LIST
17040: LIST
17041: ST_TO_ADDR
17042: GO 17275
17044: LD_INT 3
17046: DOUBLE
17047: EQUAL
17048: IFTRUE 17052
17050: GO 17274
17052: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
17053: LD_ADDR_VAR 0 4
17057: PUSH
17058: LD_INT 46
17060: PUSH
17061: LD_INT 47
17063: PUSH
17064: LD_INT 1
17066: PUSH
17067: LD_INT 2
17069: PUSH
17070: LD_INT 82
17072: PUSH
17073: LD_INT 83
17075: PUSH
17076: LD_INT 84
17078: PUSH
17079: LD_INT 85
17081: PUSH
17082: LD_INT 86
17084: PUSH
17085: LD_INT 11
17087: PUSH
17088: LD_INT 9
17090: PUSH
17091: LD_INT 20
17093: PUSH
17094: LD_INT 19
17096: PUSH
17097: LD_INT 21
17099: PUSH
17100: LD_INT 24
17102: PUSH
17103: LD_INT 22
17105: PUSH
17106: LD_INT 25
17108: PUSH
17109: LD_INT 28
17111: PUSH
17112: LD_INT 29
17114: PUSH
17115: LD_INT 30
17117: PUSH
17118: LD_INT 31
17120: PUSH
17121: LD_INT 37
17123: PUSH
17124: LD_INT 38
17126: PUSH
17127: LD_INT 32
17129: PUSH
17130: LD_INT 27
17132: PUSH
17133: LD_INT 33
17135: PUSH
17136: LD_INT 69
17138: PUSH
17139: LD_INT 39
17141: PUSH
17142: LD_INT 34
17144: PUSH
17145: LD_INT 40
17147: PUSH
17148: LD_INT 71
17150: PUSH
17151: LD_INT 23
17153: PUSH
17154: LD_INT 44
17156: PUSH
17157: LD_INT 48
17159: PUSH
17160: LD_INT 49
17162: PUSH
17163: LD_INT 50
17165: PUSH
17166: LD_INT 51
17168: PUSH
17169: LD_INT 52
17171: PUSH
17172: LD_INT 53
17174: PUSH
17175: LD_INT 54
17177: PUSH
17178: LD_INT 55
17180: PUSH
17181: LD_INT 56
17183: PUSH
17184: LD_INT 57
17186: PUSH
17187: LD_INT 58
17189: PUSH
17190: LD_INT 59
17192: PUSH
17193: LD_INT 63
17195: PUSH
17196: LD_INT 64
17198: PUSH
17199: LD_INT 65
17201: PUSH
17202: LD_INT 82
17204: PUSH
17205: LD_INT 83
17207: PUSH
17208: LD_INT 84
17210: PUSH
17211: LD_INT 85
17213: PUSH
17214: LD_INT 86
17216: PUSH
17217: EMPTY
17218: LIST
17219: LIST
17220: LIST
17221: LIST
17222: LIST
17223: LIST
17224: LIST
17225: LIST
17226: LIST
17227: LIST
17228: LIST
17229: LIST
17230: LIST
17231: LIST
17232: LIST
17233: LIST
17234: LIST
17235: LIST
17236: LIST
17237: LIST
17238: LIST
17239: LIST
17240: LIST
17241: LIST
17242: LIST
17243: LIST
17244: LIST
17245: LIST
17246: LIST
17247: LIST
17248: LIST
17249: LIST
17250: LIST
17251: LIST
17252: LIST
17253: LIST
17254: LIST
17255: LIST
17256: LIST
17257: LIST
17258: LIST
17259: LIST
17260: LIST
17261: LIST
17262: LIST
17263: LIST
17264: LIST
17265: LIST
17266: LIST
17267: LIST
17268: LIST
17269: LIST
17270: LIST
17271: ST_TO_ADDR
17272: GO 17275
17274: POP
// if state > - 1 and state < 3 then
17275: LD_VAR 0 3
17279: PUSH
17280: LD_INT 1
17282: NEG
17283: GREATER
17284: PUSH
17285: LD_VAR 0 3
17289: PUSH
17290: LD_INT 3
17292: LESS
17293: AND
17294: IFFALSE 17351
// for i in result do
17296: LD_ADDR_VAR 0 5
17300: PUSH
17301: LD_VAR 0 4
17305: PUSH
17306: FOR_IN
17307: IFFALSE 17349
// if GetTech ( i , side ) <> state then
17309: LD_VAR 0 5
17313: PPUSH
17314: LD_VAR 0 1
17318: PPUSH
17319: CALL_OW 321
17323: PUSH
17324: LD_VAR 0 3
17328: NONEQUAL
17329: IFFALSE 17347
// result := result diff i ;
17331: LD_ADDR_VAR 0 4
17335: PUSH
17336: LD_VAR 0 4
17340: PUSH
17341: LD_VAR 0 5
17345: DIFF
17346: ST_TO_ADDR
17347: GO 17306
17349: POP
17350: POP
// end ;
17351: LD_VAR 0 4
17355: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
17356: LD_INT 0
17358: PPUSH
17359: PPUSH
17360: PPUSH
// result := true ;
17361: LD_ADDR_VAR 0 3
17365: PUSH
17366: LD_INT 1
17368: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
17369: LD_ADDR_VAR 0 5
17373: PUSH
17374: LD_VAR 0 2
17378: PPUSH
17379: CALL_OW 480
17383: ST_TO_ADDR
// if not tmp then
17384: LD_VAR 0 5
17388: NOT
17389: IFFALSE 17393
// exit ;
17391: GO 17442
// for i in tmp do
17393: LD_ADDR_VAR 0 4
17397: PUSH
17398: LD_VAR 0 5
17402: PUSH
17403: FOR_IN
17404: IFFALSE 17440
// if GetTech ( i , side ) <> state_researched then
17406: LD_VAR 0 4
17410: PPUSH
17411: LD_VAR 0 1
17415: PPUSH
17416: CALL_OW 321
17420: PUSH
17421: LD_INT 2
17423: NONEQUAL
17424: IFFALSE 17438
// begin result := false ;
17426: LD_ADDR_VAR 0 3
17430: PUSH
17431: LD_INT 0
17433: ST_TO_ADDR
// exit ;
17434: POP
17435: POP
17436: GO 17442
// end ;
17438: GO 17403
17440: POP
17441: POP
// end ;
17442: LD_VAR 0 3
17446: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
17447: LD_INT 0
17449: PPUSH
17450: PPUSH
17451: PPUSH
17452: PPUSH
17453: PPUSH
17454: PPUSH
17455: PPUSH
17456: PPUSH
17457: PPUSH
17458: PPUSH
17459: PPUSH
17460: PPUSH
17461: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
17462: LD_VAR 0 1
17466: NOT
17467: PUSH
17468: LD_VAR 0 1
17472: PPUSH
17473: CALL_OW 257
17477: PUSH
17478: LD_INT 9
17480: NONEQUAL
17481: OR
17482: IFFALSE 17486
// exit ;
17484: GO 18059
// side := GetSide ( unit ) ;
17486: LD_ADDR_VAR 0 9
17490: PUSH
17491: LD_VAR 0 1
17495: PPUSH
17496: CALL_OW 255
17500: ST_TO_ADDR
// tech_space := tech_spacanom ;
17501: LD_ADDR_VAR 0 12
17505: PUSH
17506: LD_INT 29
17508: ST_TO_ADDR
// tech_time := tech_taurad ;
17509: LD_ADDR_VAR 0 13
17513: PUSH
17514: LD_INT 28
17516: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
17517: LD_ADDR_VAR 0 11
17521: PUSH
17522: LD_VAR 0 1
17526: PPUSH
17527: CALL_OW 310
17531: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
17532: LD_VAR 0 11
17536: PPUSH
17537: CALL_OW 247
17541: PUSH
17542: LD_INT 2
17544: EQUAL
17545: IFFALSE 17549
// exit ;
17547: GO 18059
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17549: LD_ADDR_VAR 0 8
17553: PUSH
17554: LD_INT 81
17556: PUSH
17557: LD_VAR 0 9
17561: PUSH
17562: EMPTY
17563: LIST
17564: LIST
17565: PUSH
17566: LD_INT 3
17568: PUSH
17569: LD_INT 21
17571: PUSH
17572: LD_INT 3
17574: PUSH
17575: EMPTY
17576: LIST
17577: LIST
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: PUSH
17583: EMPTY
17584: LIST
17585: LIST
17586: PPUSH
17587: CALL_OW 69
17591: ST_TO_ADDR
// if not tmp then
17592: LD_VAR 0 8
17596: NOT
17597: IFFALSE 17601
// exit ;
17599: GO 18059
// if in_unit then
17601: LD_VAR 0 11
17605: IFFALSE 17629
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
17607: LD_ADDR_VAR 0 10
17611: PUSH
17612: LD_VAR 0 8
17616: PPUSH
17617: LD_VAR 0 11
17621: PPUSH
17622: CALL_OW 74
17626: ST_TO_ADDR
17627: GO 17649
// enemy := NearestUnitToUnit ( tmp , unit ) ;
17629: LD_ADDR_VAR 0 10
17633: PUSH
17634: LD_VAR 0 8
17638: PPUSH
17639: LD_VAR 0 1
17643: PPUSH
17644: CALL_OW 74
17648: ST_TO_ADDR
// if not enemy then
17649: LD_VAR 0 10
17653: NOT
17654: IFFALSE 17658
// exit ;
17656: GO 18059
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
17658: LD_VAR 0 11
17662: PUSH
17663: LD_VAR 0 11
17667: PPUSH
17668: LD_VAR 0 10
17672: PPUSH
17673: CALL_OW 296
17677: PUSH
17678: LD_INT 13
17680: GREATER
17681: AND
17682: PUSH
17683: LD_VAR 0 1
17687: PPUSH
17688: LD_VAR 0 10
17692: PPUSH
17693: CALL_OW 296
17697: PUSH
17698: LD_INT 12
17700: GREATER
17701: OR
17702: IFFALSE 17706
// exit ;
17704: GO 18059
// missile := [ 1 ] ;
17706: LD_ADDR_VAR 0 14
17710: PUSH
17711: LD_INT 1
17713: PUSH
17714: EMPTY
17715: LIST
17716: ST_TO_ADDR
// if Researched ( side , tech_space ) then
17717: LD_VAR 0 9
17721: PPUSH
17722: LD_VAR 0 12
17726: PPUSH
17727: CALL_OW 325
17731: IFFALSE 17760
// missile := Replace ( missile , missile + 1 , 2 ) ;
17733: LD_ADDR_VAR 0 14
17737: PUSH
17738: LD_VAR 0 14
17742: PPUSH
17743: LD_VAR 0 14
17747: PUSH
17748: LD_INT 1
17750: PLUS
17751: PPUSH
17752: LD_INT 2
17754: PPUSH
17755: CALL_OW 1
17759: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
17760: LD_VAR 0 9
17764: PPUSH
17765: LD_VAR 0 13
17769: PPUSH
17770: CALL_OW 325
17774: PUSH
17775: LD_VAR 0 10
17779: PPUSH
17780: CALL_OW 255
17784: PPUSH
17785: LD_VAR 0 13
17789: PPUSH
17790: CALL_OW 325
17794: NOT
17795: AND
17796: IFFALSE 17825
// missile := Replace ( missile , missile + 1 , 3 ) ;
17798: LD_ADDR_VAR 0 14
17802: PUSH
17803: LD_VAR 0 14
17807: PPUSH
17808: LD_VAR 0 14
17812: PUSH
17813: LD_INT 1
17815: PLUS
17816: PPUSH
17817: LD_INT 3
17819: PPUSH
17820: CALL_OW 1
17824: ST_TO_ADDR
// if missile < 2 then
17825: LD_VAR 0 14
17829: PUSH
17830: LD_INT 2
17832: LESS
17833: IFFALSE 17837
// exit ;
17835: GO 18059
// x := GetX ( enemy ) ;
17837: LD_ADDR_VAR 0 4
17841: PUSH
17842: LD_VAR 0 10
17846: PPUSH
17847: CALL_OW 250
17851: ST_TO_ADDR
// y := GetY ( enemy ) ;
17852: LD_ADDR_VAR 0 5
17856: PUSH
17857: LD_VAR 0 10
17861: PPUSH
17862: CALL_OW 251
17866: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
17867: LD_ADDR_VAR 0 6
17871: PUSH
17872: LD_VAR 0 4
17876: PUSH
17877: LD_INT 1
17879: NEG
17880: PPUSH
17881: LD_INT 1
17883: PPUSH
17884: CALL_OW 12
17888: PLUS
17889: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
17890: LD_ADDR_VAR 0 7
17894: PUSH
17895: LD_VAR 0 5
17899: PUSH
17900: LD_INT 1
17902: NEG
17903: PPUSH
17904: LD_INT 1
17906: PPUSH
17907: CALL_OW 12
17911: PLUS
17912: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17913: LD_VAR 0 6
17917: PPUSH
17918: LD_VAR 0 7
17922: PPUSH
17923: CALL_OW 488
17927: NOT
17928: IFFALSE 17950
// begin _x := x ;
17930: LD_ADDR_VAR 0 6
17934: PUSH
17935: LD_VAR 0 4
17939: ST_TO_ADDR
// _y := y ;
17940: LD_ADDR_VAR 0 7
17944: PUSH
17945: LD_VAR 0 5
17949: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
17950: LD_ADDR_VAR 0 3
17954: PUSH
17955: LD_INT 1
17957: PPUSH
17958: LD_VAR 0 14
17962: PPUSH
17963: CALL_OW 12
17967: ST_TO_ADDR
// case i of 1 :
17968: LD_VAR 0 3
17972: PUSH
17973: LD_INT 1
17975: DOUBLE
17976: EQUAL
17977: IFTRUE 17981
17979: GO 17998
17981: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
17982: LD_VAR 0 1
17986: PPUSH
17987: LD_VAR 0 10
17991: PPUSH
17992: CALL_OW 115
17996: GO 18059
17998: LD_INT 2
18000: DOUBLE
18001: EQUAL
18002: IFTRUE 18006
18004: GO 18028
18006: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
18007: LD_VAR 0 1
18011: PPUSH
18012: LD_VAR 0 6
18016: PPUSH
18017: LD_VAR 0 7
18021: PPUSH
18022: CALL_OW 153
18026: GO 18059
18028: LD_INT 3
18030: DOUBLE
18031: EQUAL
18032: IFTRUE 18036
18034: GO 18058
18036: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
18037: LD_VAR 0 1
18041: PPUSH
18042: LD_VAR 0 6
18046: PPUSH
18047: LD_VAR 0 7
18051: PPUSH
18052: CALL_OW 154
18056: GO 18059
18058: POP
// end ;
18059: LD_VAR 0 2
18063: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
18064: LD_INT 0
18066: PPUSH
18067: PPUSH
18068: PPUSH
18069: PPUSH
18070: PPUSH
18071: PPUSH
// if not unit or not building then
18072: LD_VAR 0 1
18076: NOT
18077: PUSH
18078: LD_VAR 0 2
18082: NOT
18083: OR
18084: IFFALSE 18088
// exit ;
18086: GO 18246
// x := GetX ( building ) ;
18088: LD_ADDR_VAR 0 5
18092: PUSH
18093: LD_VAR 0 2
18097: PPUSH
18098: CALL_OW 250
18102: ST_TO_ADDR
// y := GetY ( building ) ;
18103: LD_ADDR_VAR 0 6
18107: PUSH
18108: LD_VAR 0 2
18112: PPUSH
18113: CALL_OW 251
18117: ST_TO_ADDR
// for i = 0 to 5 do
18118: LD_ADDR_VAR 0 4
18122: PUSH
18123: DOUBLE
18124: LD_INT 0
18126: DEC
18127: ST_TO_ADDR
18128: LD_INT 5
18130: PUSH
18131: FOR_TO
18132: IFFALSE 18244
// begin _x := ShiftX ( x , i , 3 ) ;
18134: LD_ADDR_VAR 0 7
18138: PUSH
18139: LD_VAR 0 5
18143: PPUSH
18144: LD_VAR 0 4
18148: PPUSH
18149: LD_INT 3
18151: PPUSH
18152: CALL_OW 272
18156: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
18157: LD_ADDR_VAR 0 8
18161: PUSH
18162: LD_VAR 0 6
18166: PPUSH
18167: LD_VAR 0 4
18171: PPUSH
18172: LD_INT 3
18174: PPUSH
18175: CALL_OW 273
18179: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18180: LD_VAR 0 7
18184: PPUSH
18185: LD_VAR 0 8
18189: PPUSH
18190: CALL_OW 488
18194: NOT
18195: IFFALSE 18199
// continue ;
18197: GO 18131
// if HexInfo ( _x , _y ) = 0 then
18199: LD_VAR 0 7
18203: PPUSH
18204: LD_VAR 0 8
18208: PPUSH
18209: CALL_OW 428
18213: PUSH
18214: LD_INT 0
18216: EQUAL
18217: IFFALSE 18242
// begin ComMoveXY ( unit , _x , _y ) ;
18219: LD_VAR 0 1
18223: PPUSH
18224: LD_VAR 0 7
18228: PPUSH
18229: LD_VAR 0 8
18233: PPUSH
18234: CALL_OW 111
// exit ;
18238: POP
18239: POP
18240: GO 18246
// end ; end ;
18242: GO 18131
18244: POP
18245: POP
// end ;
18246: LD_VAR 0 3
18250: RET
// export function ScanBase ( side , base_area ) ; begin
18251: LD_INT 0
18253: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
18254: LD_ADDR_VAR 0 3
18258: PUSH
18259: LD_VAR 0 2
18263: PPUSH
18264: LD_INT 81
18266: PUSH
18267: LD_VAR 0 1
18271: PUSH
18272: EMPTY
18273: LIST
18274: LIST
18275: PPUSH
18276: CALL_OW 70
18280: ST_TO_ADDR
// end ;
18281: LD_VAR 0 3
18285: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18286: LD_INT 0
18288: PPUSH
18289: PPUSH
18290: PPUSH
18291: PPUSH
// result := false ;
18292: LD_ADDR_VAR 0 2
18296: PUSH
18297: LD_INT 0
18299: ST_TO_ADDR
// side := GetSide ( unit ) ;
18300: LD_ADDR_VAR 0 3
18304: PUSH
18305: LD_VAR 0 1
18309: PPUSH
18310: CALL_OW 255
18314: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18315: LD_ADDR_VAR 0 4
18319: PUSH
18320: LD_VAR 0 1
18324: PPUSH
18325: CALL_OW 248
18329: ST_TO_ADDR
// case nat of 1 :
18330: LD_VAR 0 4
18334: PUSH
18335: LD_INT 1
18337: DOUBLE
18338: EQUAL
18339: IFTRUE 18343
18341: GO 18354
18343: POP
// tech := tech_lassight ; 2 :
18344: LD_ADDR_VAR 0 5
18348: PUSH
18349: LD_INT 12
18351: ST_TO_ADDR
18352: GO 18393
18354: LD_INT 2
18356: DOUBLE
18357: EQUAL
18358: IFTRUE 18362
18360: GO 18373
18362: POP
// tech := tech_mortar ; 3 :
18363: LD_ADDR_VAR 0 5
18367: PUSH
18368: LD_INT 41
18370: ST_TO_ADDR
18371: GO 18393
18373: LD_INT 3
18375: DOUBLE
18376: EQUAL
18377: IFTRUE 18381
18379: GO 18392
18381: POP
// tech := tech_bazooka ; end ;
18382: LD_ADDR_VAR 0 5
18386: PUSH
18387: LD_INT 44
18389: ST_TO_ADDR
18390: GO 18393
18392: POP
// if Researched ( side , tech ) then
18393: LD_VAR 0 3
18397: PPUSH
18398: LD_VAR 0 5
18402: PPUSH
18403: CALL_OW 325
18407: IFFALSE 18434
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18409: LD_ADDR_VAR 0 2
18413: PUSH
18414: LD_INT 5
18416: PUSH
18417: LD_INT 8
18419: PUSH
18420: LD_INT 9
18422: PUSH
18423: EMPTY
18424: LIST
18425: LIST
18426: LIST
18427: PUSH
18428: LD_VAR 0 4
18432: ARRAY
18433: ST_TO_ADDR
// end ;
18434: LD_VAR 0 2
18438: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18439: LD_INT 0
18441: PPUSH
18442: PPUSH
18443: PPUSH
// if not mines then
18444: LD_VAR 0 2
18448: NOT
18449: IFFALSE 18453
// exit ;
18451: GO 18597
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18453: LD_ADDR_VAR 0 5
18457: PUSH
18458: LD_INT 81
18460: PUSH
18461: LD_VAR 0 1
18465: PUSH
18466: EMPTY
18467: LIST
18468: LIST
18469: PUSH
18470: LD_INT 3
18472: PUSH
18473: LD_INT 21
18475: PUSH
18476: LD_INT 3
18478: PUSH
18479: EMPTY
18480: LIST
18481: LIST
18482: PUSH
18483: EMPTY
18484: LIST
18485: LIST
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PPUSH
18491: CALL_OW 69
18495: ST_TO_ADDR
// for i in mines do
18496: LD_ADDR_VAR 0 4
18500: PUSH
18501: LD_VAR 0 2
18505: PUSH
18506: FOR_IN
18507: IFFALSE 18595
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18509: LD_VAR 0 4
18513: PUSH
18514: LD_INT 1
18516: ARRAY
18517: PPUSH
18518: LD_VAR 0 4
18522: PUSH
18523: LD_INT 2
18525: ARRAY
18526: PPUSH
18527: CALL_OW 458
18531: NOT
18532: IFFALSE 18536
// continue ;
18534: GO 18506
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18536: LD_VAR 0 4
18540: PUSH
18541: LD_INT 1
18543: ARRAY
18544: PPUSH
18545: LD_VAR 0 4
18549: PUSH
18550: LD_INT 2
18552: ARRAY
18553: PPUSH
18554: CALL_OW 428
18558: PUSH
18559: LD_VAR 0 5
18563: IN
18564: IFFALSE 18593
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18566: LD_VAR 0 4
18570: PUSH
18571: LD_INT 1
18573: ARRAY
18574: PPUSH
18575: LD_VAR 0 4
18579: PUSH
18580: LD_INT 2
18582: ARRAY
18583: PPUSH
18584: LD_VAR 0 1
18588: PPUSH
18589: CALL_OW 456
// end ;
18593: GO 18506
18595: POP
18596: POP
// end ;
18597: LD_VAR 0 3
18601: RET
// export function Count ( array ) ; begin
18602: LD_INT 0
18604: PPUSH
// result := array + 0 ;
18605: LD_ADDR_VAR 0 2
18609: PUSH
18610: LD_VAR 0 1
18614: PUSH
18615: LD_INT 0
18617: PLUS
18618: ST_TO_ADDR
// end ;
18619: LD_VAR 0 2
18623: RET
// export function IsEmpty ( building ) ; begin
18624: LD_INT 0
18626: PPUSH
// if not building then
18627: LD_VAR 0 1
18631: NOT
18632: IFFALSE 18636
// exit ;
18634: GO 18679
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18636: LD_ADDR_VAR 0 2
18640: PUSH
18641: LD_VAR 0 1
18645: PUSH
18646: LD_INT 22
18648: PUSH
18649: LD_VAR 0 1
18653: PPUSH
18654: CALL_OW 255
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: PUSH
18663: LD_INT 58
18665: PUSH
18666: EMPTY
18667: LIST
18668: PUSH
18669: EMPTY
18670: LIST
18671: LIST
18672: PPUSH
18673: CALL_OW 69
18677: IN
18678: ST_TO_ADDR
// end ;
18679: LD_VAR 0 2
18683: RET
// export function IsNotFull ( building ) ; var places ; begin
18684: LD_INT 0
18686: PPUSH
18687: PPUSH
// if not building then
18688: LD_VAR 0 1
18692: NOT
18693: IFFALSE 18697
// exit ;
18695: GO 18725
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
18697: LD_ADDR_VAR 0 2
18701: PUSH
18702: LD_VAR 0 1
18706: PPUSH
18707: LD_INT 3
18709: PUSH
18710: LD_INT 62
18712: PUSH
18713: EMPTY
18714: LIST
18715: PUSH
18716: EMPTY
18717: LIST
18718: LIST
18719: PPUSH
18720: CALL_OW 72
18724: ST_TO_ADDR
// end ;
18725: LD_VAR 0 2
18729: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18730: LD_INT 0
18732: PPUSH
18733: PPUSH
18734: PPUSH
18735: PPUSH
// tmp := [ ] ;
18736: LD_ADDR_VAR 0 3
18740: PUSH
18741: EMPTY
18742: ST_TO_ADDR
// list := [ ] ;
18743: LD_ADDR_VAR 0 5
18747: PUSH
18748: EMPTY
18749: ST_TO_ADDR
// for i = 16 to 25 do
18750: LD_ADDR_VAR 0 4
18754: PUSH
18755: DOUBLE
18756: LD_INT 16
18758: DEC
18759: ST_TO_ADDR
18760: LD_INT 25
18762: PUSH
18763: FOR_TO
18764: IFFALSE 18837
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18766: LD_ADDR_VAR 0 3
18770: PUSH
18771: LD_VAR 0 3
18775: PUSH
18776: LD_INT 22
18778: PUSH
18779: LD_VAR 0 1
18783: PPUSH
18784: CALL_OW 255
18788: PUSH
18789: EMPTY
18790: LIST
18791: LIST
18792: PUSH
18793: LD_INT 91
18795: PUSH
18796: LD_VAR 0 1
18800: PUSH
18801: LD_INT 6
18803: PUSH
18804: EMPTY
18805: LIST
18806: LIST
18807: LIST
18808: PUSH
18809: LD_INT 30
18811: PUSH
18812: LD_VAR 0 4
18816: PUSH
18817: EMPTY
18818: LIST
18819: LIST
18820: PUSH
18821: EMPTY
18822: LIST
18823: LIST
18824: LIST
18825: PUSH
18826: EMPTY
18827: LIST
18828: PPUSH
18829: CALL_OW 69
18833: ADD
18834: ST_TO_ADDR
18835: GO 18763
18837: POP
18838: POP
// for i = 1 to tmp do
18839: LD_ADDR_VAR 0 4
18843: PUSH
18844: DOUBLE
18845: LD_INT 1
18847: DEC
18848: ST_TO_ADDR
18849: LD_VAR 0 3
18853: PUSH
18854: FOR_TO
18855: IFFALSE 18943
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18857: LD_ADDR_VAR 0 5
18861: PUSH
18862: LD_VAR 0 5
18866: PUSH
18867: LD_VAR 0 3
18871: PUSH
18872: LD_VAR 0 4
18876: ARRAY
18877: PPUSH
18878: CALL_OW 266
18882: PUSH
18883: LD_VAR 0 3
18887: PUSH
18888: LD_VAR 0 4
18892: ARRAY
18893: PPUSH
18894: CALL_OW 250
18898: PUSH
18899: LD_VAR 0 3
18903: PUSH
18904: LD_VAR 0 4
18908: ARRAY
18909: PPUSH
18910: CALL_OW 251
18914: PUSH
18915: LD_VAR 0 3
18919: PUSH
18920: LD_VAR 0 4
18924: ARRAY
18925: PPUSH
18926: CALL_OW 254
18930: PUSH
18931: EMPTY
18932: LIST
18933: LIST
18934: LIST
18935: LIST
18936: PUSH
18937: EMPTY
18938: LIST
18939: ADD
18940: ST_TO_ADDR
18941: GO 18854
18943: POP
18944: POP
// result := list ;
18945: LD_ADDR_VAR 0 2
18949: PUSH
18950: LD_VAR 0 5
18954: ST_TO_ADDR
// end ;
18955: LD_VAR 0 2
18959: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18960: LD_INT 0
18962: PPUSH
18963: PPUSH
18964: PPUSH
18965: PPUSH
18966: PPUSH
18967: PPUSH
18968: PPUSH
// if not factory then
18969: LD_VAR 0 1
18973: NOT
18974: IFFALSE 18978
// exit ;
18976: GO 19571
// if control = control_apeman then
18978: LD_VAR 0 4
18982: PUSH
18983: LD_INT 5
18985: EQUAL
18986: IFFALSE 19095
// begin tmp := UnitsInside ( factory ) ;
18988: LD_ADDR_VAR 0 8
18992: PUSH
18993: LD_VAR 0 1
18997: PPUSH
18998: CALL_OW 313
19002: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
19003: LD_VAR 0 8
19007: PPUSH
19008: LD_INT 25
19010: PUSH
19011: LD_INT 12
19013: PUSH
19014: EMPTY
19015: LIST
19016: LIST
19017: PPUSH
19018: CALL_OW 72
19022: NOT
19023: IFFALSE 19033
// control := control_manual ;
19025: LD_ADDR_VAR 0 4
19029: PUSH
19030: LD_INT 1
19032: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
19033: LD_ADDR_VAR 0 8
19037: PUSH
19038: LD_VAR 0 1
19042: PPUSH
19043: CALL 18730 0 1
19047: ST_TO_ADDR
// if tmp then
19048: LD_VAR 0 8
19052: IFFALSE 19095
// begin for i in tmp do
19054: LD_ADDR_VAR 0 7
19058: PUSH
19059: LD_VAR 0 8
19063: PUSH
19064: FOR_IN
19065: IFFALSE 19093
// if i [ 1 ] = b_ext_radio then
19067: LD_VAR 0 7
19071: PUSH
19072: LD_INT 1
19074: ARRAY
19075: PUSH
19076: LD_INT 22
19078: EQUAL
19079: IFFALSE 19091
// begin control := control_remote ;
19081: LD_ADDR_VAR 0 4
19085: PUSH
19086: LD_INT 2
19088: ST_TO_ADDR
// break ;
19089: GO 19093
// end ;
19091: GO 19064
19093: POP
19094: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19095: LD_VAR 0 1
19099: PPUSH
19100: LD_VAR 0 2
19104: PPUSH
19105: LD_VAR 0 3
19109: PPUSH
19110: LD_VAR 0 4
19114: PPUSH
19115: LD_VAR 0 5
19119: PPUSH
19120: CALL_OW 448
19124: IFFALSE 19159
// begin result := [ chassis , engine , control , weapon ] ;
19126: LD_ADDR_VAR 0 6
19130: PUSH
19131: LD_VAR 0 2
19135: PUSH
19136: LD_VAR 0 3
19140: PUSH
19141: LD_VAR 0 4
19145: PUSH
19146: LD_VAR 0 5
19150: PUSH
19151: EMPTY
19152: LIST
19153: LIST
19154: LIST
19155: LIST
19156: ST_TO_ADDR
// exit ;
19157: GO 19571
// end ; _chassis := AvailableChassisList ( factory ) ;
19159: LD_ADDR_VAR 0 9
19163: PUSH
19164: LD_VAR 0 1
19168: PPUSH
19169: CALL_OW 475
19173: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19174: LD_ADDR_VAR 0 11
19178: PUSH
19179: LD_VAR 0 1
19183: PPUSH
19184: CALL_OW 476
19188: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19189: LD_ADDR_VAR 0 12
19193: PUSH
19194: LD_VAR 0 1
19198: PPUSH
19199: CALL_OW 477
19203: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19204: LD_ADDR_VAR 0 10
19208: PUSH
19209: LD_VAR 0 1
19213: PPUSH
19214: CALL_OW 478
19218: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19219: LD_VAR 0 9
19223: NOT
19224: PUSH
19225: LD_VAR 0 11
19229: NOT
19230: OR
19231: PUSH
19232: LD_VAR 0 12
19236: NOT
19237: OR
19238: PUSH
19239: LD_VAR 0 10
19243: NOT
19244: OR
19245: IFFALSE 19280
// begin result := [ chassis , engine , control , weapon ] ;
19247: LD_ADDR_VAR 0 6
19251: PUSH
19252: LD_VAR 0 2
19256: PUSH
19257: LD_VAR 0 3
19261: PUSH
19262: LD_VAR 0 4
19266: PUSH
19267: LD_VAR 0 5
19271: PUSH
19272: EMPTY
19273: LIST
19274: LIST
19275: LIST
19276: LIST
19277: ST_TO_ADDR
// exit ;
19278: GO 19571
// end ; if not chassis in _chassis then
19280: LD_VAR 0 2
19284: PUSH
19285: LD_VAR 0 9
19289: IN
19290: NOT
19291: IFFALSE 19317
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19293: LD_ADDR_VAR 0 2
19297: PUSH
19298: LD_VAR 0 9
19302: PUSH
19303: LD_INT 1
19305: PPUSH
19306: LD_VAR 0 9
19310: PPUSH
19311: CALL_OW 12
19315: ARRAY
19316: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19317: LD_VAR 0 2
19321: PPUSH
19322: LD_VAR 0 3
19326: PPUSH
19327: CALL 19576 0 2
19331: NOT
19332: IFFALSE 19391
// repeat engine := _engine [ 1 ] ;
19334: LD_ADDR_VAR 0 3
19338: PUSH
19339: LD_VAR 0 11
19343: PUSH
19344: LD_INT 1
19346: ARRAY
19347: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19348: LD_ADDR_VAR 0 11
19352: PUSH
19353: LD_VAR 0 11
19357: PPUSH
19358: LD_INT 1
19360: PPUSH
19361: CALL_OW 3
19365: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19366: LD_VAR 0 2
19370: PPUSH
19371: LD_VAR 0 3
19375: PPUSH
19376: CALL 19576 0 2
19380: PUSH
19381: LD_VAR 0 11
19385: PUSH
19386: EMPTY
19387: EQUAL
19388: OR
19389: IFFALSE 19334
// if not control in _control then
19391: LD_VAR 0 4
19395: PUSH
19396: LD_VAR 0 12
19400: IN
19401: NOT
19402: IFFALSE 19428
// control := _control [ rand ( 1 , _control ) ] ;
19404: LD_ADDR_VAR 0 4
19408: PUSH
19409: LD_VAR 0 12
19413: PUSH
19414: LD_INT 1
19416: PPUSH
19417: LD_VAR 0 12
19421: PPUSH
19422: CALL_OW 12
19426: ARRAY
19427: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19428: LD_VAR 0 2
19432: PPUSH
19433: LD_VAR 0 5
19437: PPUSH
19438: CALL 19796 0 2
19442: NOT
19443: IFFALSE 19502
// repeat weapon := _weapon [ 1 ] ;
19445: LD_ADDR_VAR 0 5
19449: PUSH
19450: LD_VAR 0 10
19454: PUSH
19455: LD_INT 1
19457: ARRAY
19458: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19459: LD_ADDR_VAR 0 10
19463: PUSH
19464: LD_VAR 0 10
19468: PPUSH
19469: LD_INT 1
19471: PPUSH
19472: CALL_OW 3
19476: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19477: LD_VAR 0 2
19481: PPUSH
19482: LD_VAR 0 5
19486: PPUSH
19487: CALL 19796 0 2
19491: PUSH
19492: LD_VAR 0 10
19496: PUSH
19497: EMPTY
19498: EQUAL
19499: OR
19500: IFFALSE 19445
// result := [ ] ;
19502: LD_ADDR_VAR 0 6
19506: PUSH
19507: EMPTY
19508: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19509: LD_VAR 0 1
19513: PPUSH
19514: LD_VAR 0 2
19518: PPUSH
19519: LD_VAR 0 3
19523: PPUSH
19524: LD_VAR 0 4
19528: PPUSH
19529: LD_VAR 0 5
19533: PPUSH
19534: CALL_OW 448
19538: IFFALSE 19571
// result := [ chassis , engine , control , weapon ] ;
19540: LD_ADDR_VAR 0 6
19544: PUSH
19545: LD_VAR 0 2
19549: PUSH
19550: LD_VAR 0 3
19554: PUSH
19555: LD_VAR 0 4
19559: PUSH
19560: LD_VAR 0 5
19564: PUSH
19565: EMPTY
19566: LIST
19567: LIST
19568: LIST
19569: LIST
19570: ST_TO_ADDR
// end ;
19571: LD_VAR 0 6
19575: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19576: LD_INT 0
19578: PPUSH
// if not chassis or not engine then
19579: LD_VAR 0 1
19583: NOT
19584: PUSH
19585: LD_VAR 0 2
19589: NOT
19590: OR
19591: IFFALSE 19595
// exit ;
19593: GO 19791
// case engine of engine_solar :
19595: LD_VAR 0 2
19599: PUSH
19600: LD_INT 2
19602: DOUBLE
19603: EQUAL
19604: IFTRUE 19608
19606: GO 19646
19608: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19609: LD_ADDR_VAR 0 3
19613: PUSH
19614: LD_INT 11
19616: PUSH
19617: LD_INT 12
19619: PUSH
19620: LD_INT 13
19622: PUSH
19623: LD_INT 14
19625: PUSH
19626: LD_INT 1
19628: PUSH
19629: LD_INT 2
19631: PUSH
19632: LD_INT 3
19634: PUSH
19635: EMPTY
19636: LIST
19637: LIST
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: LIST
19643: ST_TO_ADDR
19644: GO 19775
19646: LD_INT 1
19648: DOUBLE
19649: EQUAL
19650: IFTRUE 19654
19652: GO 19716
19654: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19655: LD_ADDR_VAR 0 3
19659: PUSH
19660: LD_INT 11
19662: PUSH
19663: LD_INT 12
19665: PUSH
19666: LD_INT 13
19668: PUSH
19669: LD_INT 14
19671: PUSH
19672: LD_INT 1
19674: PUSH
19675: LD_INT 2
19677: PUSH
19678: LD_INT 3
19680: PUSH
19681: LD_INT 4
19683: PUSH
19684: LD_INT 5
19686: PUSH
19687: LD_INT 21
19689: PUSH
19690: LD_INT 23
19692: PUSH
19693: LD_INT 22
19695: PUSH
19696: LD_INT 24
19698: PUSH
19699: EMPTY
19700: LIST
19701: LIST
19702: LIST
19703: LIST
19704: LIST
19705: LIST
19706: LIST
19707: LIST
19708: LIST
19709: LIST
19710: LIST
19711: LIST
19712: LIST
19713: ST_TO_ADDR
19714: GO 19775
19716: LD_INT 3
19718: DOUBLE
19719: EQUAL
19720: IFTRUE 19724
19722: GO 19774
19724: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19725: LD_ADDR_VAR 0 3
19729: PUSH
19730: LD_INT 13
19732: PUSH
19733: LD_INT 14
19735: PUSH
19736: LD_INT 2
19738: PUSH
19739: LD_INT 3
19741: PUSH
19742: LD_INT 4
19744: PUSH
19745: LD_INT 5
19747: PUSH
19748: LD_INT 21
19750: PUSH
19751: LD_INT 22
19753: PUSH
19754: LD_INT 23
19756: PUSH
19757: LD_INT 24
19759: PUSH
19760: EMPTY
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: LIST
19766: LIST
19767: LIST
19768: LIST
19769: LIST
19770: LIST
19771: ST_TO_ADDR
19772: GO 19775
19774: POP
// result := ( chassis in result ) ;
19775: LD_ADDR_VAR 0 3
19779: PUSH
19780: LD_VAR 0 1
19784: PUSH
19785: LD_VAR 0 3
19789: IN
19790: ST_TO_ADDR
// end ;
19791: LD_VAR 0 3
19795: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19796: LD_INT 0
19798: PPUSH
// if not chassis or not weapon then
19799: LD_VAR 0 1
19803: NOT
19804: PUSH
19805: LD_VAR 0 2
19809: NOT
19810: OR
19811: IFFALSE 19815
// exit ;
19813: GO 20875
// case weapon of us_machine_gun :
19815: LD_VAR 0 2
19819: PUSH
19820: LD_INT 2
19822: DOUBLE
19823: EQUAL
19824: IFTRUE 19828
19826: GO 19858
19828: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19829: LD_ADDR_VAR 0 3
19833: PUSH
19834: LD_INT 1
19836: PUSH
19837: LD_INT 2
19839: PUSH
19840: LD_INT 3
19842: PUSH
19843: LD_INT 4
19845: PUSH
19846: LD_INT 5
19848: PUSH
19849: EMPTY
19850: LIST
19851: LIST
19852: LIST
19853: LIST
19854: LIST
19855: ST_TO_ADDR
19856: GO 20859
19858: LD_INT 3
19860: DOUBLE
19861: EQUAL
19862: IFTRUE 19866
19864: GO 19896
19866: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19867: LD_ADDR_VAR 0 3
19871: PUSH
19872: LD_INT 1
19874: PUSH
19875: LD_INT 2
19877: PUSH
19878: LD_INT 3
19880: PUSH
19881: LD_INT 4
19883: PUSH
19884: LD_INT 5
19886: PUSH
19887: EMPTY
19888: LIST
19889: LIST
19890: LIST
19891: LIST
19892: LIST
19893: ST_TO_ADDR
19894: GO 20859
19896: LD_INT 11
19898: DOUBLE
19899: EQUAL
19900: IFTRUE 19904
19902: GO 19934
19904: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19905: LD_ADDR_VAR 0 3
19909: PUSH
19910: LD_INT 1
19912: PUSH
19913: LD_INT 2
19915: PUSH
19916: LD_INT 3
19918: PUSH
19919: LD_INT 4
19921: PUSH
19922: LD_INT 5
19924: PUSH
19925: EMPTY
19926: LIST
19927: LIST
19928: LIST
19929: LIST
19930: LIST
19931: ST_TO_ADDR
19932: GO 20859
19934: LD_INT 4
19936: DOUBLE
19937: EQUAL
19938: IFTRUE 19942
19940: GO 19968
19942: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19943: LD_ADDR_VAR 0 3
19947: PUSH
19948: LD_INT 2
19950: PUSH
19951: LD_INT 3
19953: PUSH
19954: LD_INT 4
19956: PUSH
19957: LD_INT 5
19959: PUSH
19960: EMPTY
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: ST_TO_ADDR
19966: GO 20859
19968: LD_INT 5
19970: DOUBLE
19971: EQUAL
19972: IFTRUE 19976
19974: GO 20002
19976: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19977: LD_ADDR_VAR 0 3
19981: PUSH
19982: LD_INT 2
19984: PUSH
19985: LD_INT 3
19987: PUSH
19988: LD_INT 4
19990: PUSH
19991: LD_INT 5
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: LIST
19998: LIST
19999: ST_TO_ADDR
20000: GO 20859
20002: LD_INT 9
20004: DOUBLE
20005: EQUAL
20006: IFTRUE 20010
20008: GO 20036
20010: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
20011: LD_ADDR_VAR 0 3
20015: PUSH
20016: LD_INT 2
20018: PUSH
20019: LD_INT 3
20021: PUSH
20022: LD_INT 4
20024: PUSH
20025: LD_INT 5
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: LIST
20032: LIST
20033: ST_TO_ADDR
20034: GO 20859
20036: LD_INT 7
20038: DOUBLE
20039: EQUAL
20040: IFTRUE 20044
20042: GO 20070
20044: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
20045: LD_ADDR_VAR 0 3
20049: PUSH
20050: LD_INT 2
20052: PUSH
20053: LD_INT 3
20055: PUSH
20056: LD_INT 4
20058: PUSH
20059: LD_INT 5
20061: PUSH
20062: EMPTY
20063: LIST
20064: LIST
20065: LIST
20066: LIST
20067: ST_TO_ADDR
20068: GO 20859
20070: LD_INT 12
20072: DOUBLE
20073: EQUAL
20074: IFTRUE 20078
20076: GO 20104
20078: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20079: LD_ADDR_VAR 0 3
20083: PUSH
20084: LD_INT 2
20086: PUSH
20087: LD_INT 3
20089: PUSH
20090: LD_INT 4
20092: PUSH
20093: LD_INT 5
20095: PUSH
20096: EMPTY
20097: LIST
20098: LIST
20099: LIST
20100: LIST
20101: ST_TO_ADDR
20102: GO 20859
20104: LD_INT 13
20106: DOUBLE
20107: EQUAL
20108: IFTRUE 20112
20110: GO 20138
20112: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20113: LD_ADDR_VAR 0 3
20117: PUSH
20118: LD_INT 2
20120: PUSH
20121: LD_INT 3
20123: PUSH
20124: LD_INT 4
20126: PUSH
20127: LD_INT 5
20129: PUSH
20130: EMPTY
20131: LIST
20132: LIST
20133: LIST
20134: LIST
20135: ST_TO_ADDR
20136: GO 20859
20138: LD_INT 14
20140: DOUBLE
20141: EQUAL
20142: IFTRUE 20146
20144: GO 20164
20146: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20147: LD_ADDR_VAR 0 3
20151: PUSH
20152: LD_INT 4
20154: PUSH
20155: LD_INT 5
20157: PUSH
20158: EMPTY
20159: LIST
20160: LIST
20161: ST_TO_ADDR
20162: GO 20859
20164: LD_INT 6
20166: DOUBLE
20167: EQUAL
20168: IFTRUE 20172
20170: GO 20190
20172: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20173: LD_ADDR_VAR 0 3
20177: PUSH
20178: LD_INT 4
20180: PUSH
20181: LD_INT 5
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: ST_TO_ADDR
20188: GO 20859
20190: LD_INT 10
20192: DOUBLE
20193: EQUAL
20194: IFTRUE 20198
20196: GO 20216
20198: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20199: LD_ADDR_VAR 0 3
20203: PUSH
20204: LD_INT 4
20206: PUSH
20207: LD_INT 5
20209: PUSH
20210: EMPTY
20211: LIST
20212: LIST
20213: ST_TO_ADDR
20214: GO 20859
20216: LD_INT 22
20218: DOUBLE
20219: EQUAL
20220: IFTRUE 20224
20222: GO 20250
20224: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20225: LD_ADDR_VAR 0 3
20229: PUSH
20230: LD_INT 11
20232: PUSH
20233: LD_INT 12
20235: PUSH
20236: LD_INT 13
20238: PUSH
20239: LD_INT 14
20241: PUSH
20242: EMPTY
20243: LIST
20244: LIST
20245: LIST
20246: LIST
20247: ST_TO_ADDR
20248: GO 20859
20250: LD_INT 23
20252: DOUBLE
20253: EQUAL
20254: IFTRUE 20258
20256: GO 20284
20258: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20259: LD_ADDR_VAR 0 3
20263: PUSH
20264: LD_INT 11
20266: PUSH
20267: LD_INT 12
20269: PUSH
20270: LD_INT 13
20272: PUSH
20273: LD_INT 14
20275: PUSH
20276: EMPTY
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: ST_TO_ADDR
20282: GO 20859
20284: LD_INT 24
20286: DOUBLE
20287: EQUAL
20288: IFTRUE 20292
20290: GO 20318
20292: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20293: LD_ADDR_VAR 0 3
20297: PUSH
20298: LD_INT 11
20300: PUSH
20301: LD_INT 12
20303: PUSH
20304: LD_INT 13
20306: PUSH
20307: LD_INT 14
20309: PUSH
20310: EMPTY
20311: LIST
20312: LIST
20313: LIST
20314: LIST
20315: ST_TO_ADDR
20316: GO 20859
20318: LD_INT 30
20320: DOUBLE
20321: EQUAL
20322: IFTRUE 20326
20324: GO 20352
20326: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20327: LD_ADDR_VAR 0 3
20331: PUSH
20332: LD_INT 11
20334: PUSH
20335: LD_INT 12
20337: PUSH
20338: LD_INT 13
20340: PUSH
20341: LD_INT 14
20343: PUSH
20344: EMPTY
20345: LIST
20346: LIST
20347: LIST
20348: LIST
20349: ST_TO_ADDR
20350: GO 20859
20352: LD_INT 25
20354: DOUBLE
20355: EQUAL
20356: IFTRUE 20360
20358: GO 20378
20360: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20361: LD_ADDR_VAR 0 3
20365: PUSH
20366: LD_INT 13
20368: PUSH
20369: LD_INT 14
20371: PUSH
20372: EMPTY
20373: LIST
20374: LIST
20375: ST_TO_ADDR
20376: GO 20859
20378: LD_INT 27
20380: DOUBLE
20381: EQUAL
20382: IFTRUE 20386
20384: GO 20404
20386: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
20387: LD_ADDR_VAR 0 3
20391: PUSH
20392: LD_INT 13
20394: PUSH
20395: LD_INT 14
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: ST_TO_ADDR
20402: GO 20859
20404: LD_INT 92
20406: DOUBLE
20407: EQUAL
20408: IFTRUE 20412
20410: GO 20438
20412: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20413: LD_ADDR_VAR 0 3
20417: PUSH
20418: LD_INT 11
20420: PUSH
20421: LD_INT 12
20423: PUSH
20424: LD_INT 13
20426: PUSH
20427: LD_INT 14
20429: PUSH
20430: EMPTY
20431: LIST
20432: LIST
20433: LIST
20434: LIST
20435: ST_TO_ADDR
20436: GO 20859
20438: LD_INT 28
20440: DOUBLE
20441: EQUAL
20442: IFTRUE 20446
20444: GO 20464
20446: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20447: LD_ADDR_VAR 0 3
20451: PUSH
20452: LD_INT 13
20454: PUSH
20455: LD_INT 14
20457: PUSH
20458: EMPTY
20459: LIST
20460: LIST
20461: ST_TO_ADDR
20462: GO 20859
20464: LD_INT 29
20466: DOUBLE
20467: EQUAL
20468: IFTRUE 20472
20470: GO 20490
20472: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20473: LD_ADDR_VAR 0 3
20477: PUSH
20478: LD_INT 13
20480: PUSH
20481: LD_INT 14
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: ST_TO_ADDR
20488: GO 20859
20490: LD_INT 31
20492: DOUBLE
20493: EQUAL
20494: IFTRUE 20498
20496: GO 20516
20498: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20499: LD_ADDR_VAR 0 3
20503: PUSH
20504: LD_INT 13
20506: PUSH
20507: LD_INT 14
20509: PUSH
20510: EMPTY
20511: LIST
20512: LIST
20513: ST_TO_ADDR
20514: GO 20859
20516: LD_INT 26
20518: DOUBLE
20519: EQUAL
20520: IFTRUE 20524
20522: GO 20542
20524: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20525: LD_ADDR_VAR 0 3
20529: PUSH
20530: LD_INT 13
20532: PUSH
20533: LD_INT 14
20535: PUSH
20536: EMPTY
20537: LIST
20538: LIST
20539: ST_TO_ADDR
20540: GO 20859
20542: LD_INT 42
20544: DOUBLE
20545: EQUAL
20546: IFTRUE 20550
20548: GO 20576
20550: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20551: LD_ADDR_VAR 0 3
20555: PUSH
20556: LD_INT 21
20558: PUSH
20559: LD_INT 22
20561: PUSH
20562: LD_INT 23
20564: PUSH
20565: LD_INT 24
20567: PUSH
20568: EMPTY
20569: LIST
20570: LIST
20571: LIST
20572: LIST
20573: ST_TO_ADDR
20574: GO 20859
20576: LD_INT 43
20578: DOUBLE
20579: EQUAL
20580: IFTRUE 20584
20582: GO 20610
20584: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20585: LD_ADDR_VAR 0 3
20589: PUSH
20590: LD_INT 21
20592: PUSH
20593: LD_INT 22
20595: PUSH
20596: LD_INT 23
20598: PUSH
20599: LD_INT 24
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: ST_TO_ADDR
20608: GO 20859
20610: LD_INT 44
20612: DOUBLE
20613: EQUAL
20614: IFTRUE 20618
20616: GO 20644
20618: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20619: LD_ADDR_VAR 0 3
20623: PUSH
20624: LD_INT 21
20626: PUSH
20627: LD_INT 22
20629: PUSH
20630: LD_INT 23
20632: PUSH
20633: LD_INT 24
20635: PUSH
20636: EMPTY
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: ST_TO_ADDR
20642: GO 20859
20644: LD_INT 45
20646: DOUBLE
20647: EQUAL
20648: IFTRUE 20652
20650: GO 20678
20652: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20653: LD_ADDR_VAR 0 3
20657: PUSH
20658: LD_INT 21
20660: PUSH
20661: LD_INT 22
20663: PUSH
20664: LD_INT 23
20666: PUSH
20667: LD_INT 24
20669: PUSH
20670: EMPTY
20671: LIST
20672: LIST
20673: LIST
20674: LIST
20675: ST_TO_ADDR
20676: GO 20859
20678: LD_INT 49
20680: DOUBLE
20681: EQUAL
20682: IFTRUE 20686
20684: GO 20712
20686: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20687: LD_ADDR_VAR 0 3
20691: PUSH
20692: LD_INT 21
20694: PUSH
20695: LD_INT 22
20697: PUSH
20698: LD_INT 23
20700: PUSH
20701: LD_INT 24
20703: PUSH
20704: EMPTY
20705: LIST
20706: LIST
20707: LIST
20708: LIST
20709: ST_TO_ADDR
20710: GO 20859
20712: LD_INT 51
20714: DOUBLE
20715: EQUAL
20716: IFTRUE 20720
20718: GO 20746
20720: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20721: LD_ADDR_VAR 0 3
20725: PUSH
20726: LD_INT 21
20728: PUSH
20729: LD_INT 22
20731: PUSH
20732: LD_INT 23
20734: PUSH
20735: LD_INT 24
20737: PUSH
20738: EMPTY
20739: LIST
20740: LIST
20741: LIST
20742: LIST
20743: ST_TO_ADDR
20744: GO 20859
20746: LD_INT 52
20748: DOUBLE
20749: EQUAL
20750: IFTRUE 20754
20752: GO 20780
20754: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20755: LD_ADDR_VAR 0 3
20759: PUSH
20760: LD_INT 21
20762: PUSH
20763: LD_INT 22
20765: PUSH
20766: LD_INT 23
20768: PUSH
20769: LD_INT 24
20771: PUSH
20772: EMPTY
20773: LIST
20774: LIST
20775: LIST
20776: LIST
20777: ST_TO_ADDR
20778: GO 20859
20780: LD_INT 53
20782: DOUBLE
20783: EQUAL
20784: IFTRUE 20788
20786: GO 20806
20788: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20789: LD_ADDR_VAR 0 3
20793: PUSH
20794: LD_INT 23
20796: PUSH
20797: LD_INT 24
20799: PUSH
20800: EMPTY
20801: LIST
20802: LIST
20803: ST_TO_ADDR
20804: GO 20859
20806: LD_INT 46
20808: DOUBLE
20809: EQUAL
20810: IFTRUE 20814
20812: GO 20832
20814: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20815: LD_ADDR_VAR 0 3
20819: PUSH
20820: LD_INT 23
20822: PUSH
20823: LD_INT 24
20825: PUSH
20826: EMPTY
20827: LIST
20828: LIST
20829: ST_TO_ADDR
20830: GO 20859
20832: LD_INT 47
20834: DOUBLE
20835: EQUAL
20836: IFTRUE 20840
20838: GO 20858
20840: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20841: LD_ADDR_VAR 0 3
20845: PUSH
20846: LD_INT 23
20848: PUSH
20849: LD_INT 24
20851: PUSH
20852: EMPTY
20853: LIST
20854: LIST
20855: ST_TO_ADDR
20856: GO 20859
20858: POP
// result := ( chassis in result ) ;
20859: LD_ADDR_VAR 0 3
20863: PUSH
20864: LD_VAR 0 1
20868: PUSH
20869: LD_VAR 0 3
20873: IN
20874: ST_TO_ADDR
// end ;
20875: LD_VAR 0 3
20879: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20880: LD_INT 0
20882: PPUSH
20883: PPUSH
20884: PPUSH
20885: PPUSH
20886: PPUSH
20887: PPUSH
20888: PPUSH
// result := array ;
20889: LD_ADDR_VAR 0 5
20893: PUSH
20894: LD_VAR 0 1
20898: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20899: LD_VAR 0 1
20903: NOT
20904: PUSH
20905: LD_VAR 0 2
20909: NOT
20910: OR
20911: PUSH
20912: LD_VAR 0 3
20916: NOT
20917: OR
20918: PUSH
20919: LD_VAR 0 2
20923: PUSH
20924: LD_VAR 0 1
20928: GREATER
20929: OR
20930: PUSH
20931: LD_VAR 0 3
20935: PUSH
20936: LD_VAR 0 1
20940: GREATER
20941: OR
20942: IFFALSE 20946
// exit ;
20944: GO 21242
// if direction then
20946: LD_VAR 0 4
20950: IFFALSE 21014
// begin d := 1 ;
20952: LD_ADDR_VAR 0 9
20956: PUSH
20957: LD_INT 1
20959: ST_TO_ADDR
// if i_from > i_to then
20960: LD_VAR 0 2
20964: PUSH
20965: LD_VAR 0 3
20969: GREATER
20970: IFFALSE 20996
// length := ( array - i_from ) + i_to else
20972: LD_ADDR_VAR 0 11
20976: PUSH
20977: LD_VAR 0 1
20981: PUSH
20982: LD_VAR 0 2
20986: MINUS
20987: PUSH
20988: LD_VAR 0 3
20992: PLUS
20993: ST_TO_ADDR
20994: GO 21012
// length := i_to - i_from ;
20996: LD_ADDR_VAR 0 11
21000: PUSH
21001: LD_VAR 0 3
21005: PUSH
21006: LD_VAR 0 2
21010: MINUS
21011: ST_TO_ADDR
// end else
21012: GO 21075
// begin d := - 1 ;
21014: LD_ADDR_VAR 0 9
21018: PUSH
21019: LD_INT 1
21021: NEG
21022: ST_TO_ADDR
// if i_from > i_to then
21023: LD_VAR 0 2
21027: PUSH
21028: LD_VAR 0 3
21032: GREATER
21033: IFFALSE 21053
// length := i_from - i_to else
21035: LD_ADDR_VAR 0 11
21039: PUSH
21040: LD_VAR 0 2
21044: PUSH
21045: LD_VAR 0 3
21049: MINUS
21050: ST_TO_ADDR
21051: GO 21075
// length := ( array - i_to ) + i_from ;
21053: LD_ADDR_VAR 0 11
21057: PUSH
21058: LD_VAR 0 1
21062: PUSH
21063: LD_VAR 0 3
21067: MINUS
21068: PUSH
21069: LD_VAR 0 2
21073: PLUS
21074: ST_TO_ADDR
// end ; if not length then
21075: LD_VAR 0 11
21079: NOT
21080: IFFALSE 21084
// exit ;
21082: GO 21242
// tmp := array ;
21084: LD_ADDR_VAR 0 10
21088: PUSH
21089: LD_VAR 0 1
21093: ST_TO_ADDR
// for i = 1 to length do
21094: LD_ADDR_VAR 0 6
21098: PUSH
21099: DOUBLE
21100: LD_INT 1
21102: DEC
21103: ST_TO_ADDR
21104: LD_VAR 0 11
21108: PUSH
21109: FOR_TO
21110: IFFALSE 21230
// begin for j = 1 to array do
21112: LD_ADDR_VAR 0 7
21116: PUSH
21117: DOUBLE
21118: LD_INT 1
21120: DEC
21121: ST_TO_ADDR
21122: LD_VAR 0 1
21126: PUSH
21127: FOR_TO
21128: IFFALSE 21216
// begin k := j + d ;
21130: LD_ADDR_VAR 0 8
21134: PUSH
21135: LD_VAR 0 7
21139: PUSH
21140: LD_VAR 0 9
21144: PLUS
21145: ST_TO_ADDR
// if k > array then
21146: LD_VAR 0 8
21150: PUSH
21151: LD_VAR 0 1
21155: GREATER
21156: IFFALSE 21166
// k := 1 ;
21158: LD_ADDR_VAR 0 8
21162: PUSH
21163: LD_INT 1
21165: ST_TO_ADDR
// if not k then
21166: LD_VAR 0 8
21170: NOT
21171: IFFALSE 21183
// k := array ;
21173: LD_ADDR_VAR 0 8
21177: PUSH
21178: LD_VAR 0 1
21182: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21183: LD_ADDR_VAR 0 10
21187: PUSH
21188: LD_VAR 0 10
21192: PPUSH
21193: LD_VAR 0 8
21197: PPUSH
21198: LD_VAR 0 1
21202: PUSH
21203: LD_VAR 0 7
21207: ARRAY
21208: PPUSH
21209: CALL_OW 1
21213: ST_TO_ADDR
// end ;
21214: GO 21127
21216: POP
21217: POP
// array := tmp ;
21218: LD_ADDR_VAR 0 1
21222: PUSH
21223: LD_VAR 0 10
21227: ST_TO_ADDR
// end ;
21228: GO 21109
21230: POP
21231: POP
// result := array ;
21232: LD_ADDR_VAR 0 5
21236: PUSH
21237: LD_VAR 0 1
21241: ST_TO_ADDR
// end ;
21242: LD_VAR 0 5
21246: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21247: LD_INT 0
21249: PPUSH
21250: PPUSH
// result := 0 ;
21251: LD_ADDR_VAR 0 3
21255: PUSH
21256: LD_INT 0
21258: ST_TO_ADDR
// if not array or not value in array then
21259: LD_VAR 0 1
21263: NOT
21264: PUSH
21265: LD_VAR 0 2
21269: PUSH
21270: LD_VAR 0 1
21274: IN
21275: NOT
21276: OR
21277: IFFALSE 21281
// exit ;
21279: GO 21335
// for i = 1 to array do
21281: LD_ADDR_VAR 0 4
21285: PUSH
21286: DOUBLE
21287: LD_INT 1
21289: DEC
21290: ST_TO_ADDR
21291: LD_VAR 0 1
21295: PUSH
21296: FOR_TO
21297: IFFALSE 21333
// if value = array [ i ] then
21299: LD_VAR 0 2
21303: PUSH
21304: LD_VAR 0 1
21308: PUSH
21309: LD_VAR 0 4
21313: ARRAY
21314: EQUAL
21315: IFFALSE 21331
// begin result := i ;
21317: LD_ADDR_VAR 0 3
21321: PUSH
21322: LD_VAR 0 4
21326: ST_TO_ADDR
// exit ;
21327: POP
21328: POP
21329: GO 21335
// end ;
21331: GO 21296
21333: POP
21334: POP
// end ;
21335: LD_VAR 0 3
21339: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21340: LD_INT 0
21342: PPUSH
// vc_chassis := chassis ;
21343: LD_ADDR_OWVAR 37
21347: PUSH
21348: LD_VAR 0 1
21352: ST_TO_ADDR
// vc_engine := engine ;
21353: LD_ADDR_OWVAR 39
21357: PUSH
21358: LD_VAR 0 2
21362: ST_TO_ADDR
// vc_control := control ;
21363: LD_ADDR_OWVAR 38
21367: PUSH
21368: LD_VAR 0 3
21372: ST_TO_ADDR
// vc_weapon := weapon ;
21373: LD_ADDR_OWVAR 40
21377: PUSH
21378: LD_VAR 0 4
21382: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21383: LD_ADDR_OWVAR 41
21387: PUSH
21388: LD_VAR 0 5
21392: ST_TO_ADDR
// end ;
21393: LD_VAR 0 6
21397: RET
// export function WantPlant ( unit ) ; var task ; begin
21398: LD_INT 0
21400: PPUSH
21401: PPUSH
// result := false ;
21402: LD_ADDR_VAR 0 2
21406: PUSH
21407: LD_INT 0
21409: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21410: LD_ADDR_VAR 0 3
21414: PUSH
21415: LD_VAR 0 1
21419: PPUSH
21420: CALL_OW 437
21424: ST_TO_ADDR
// if task then
21425: LD_VAR 0 3
21429: IFFALSE 21457
// if task [ 1 ] [ 1 ] = p then
21431: LD_VAR 0 3
21435: PUSH
21436: LD_INT 1
21438: ARRAY
21439: PUSH
21440: LD_INT 1
21442: ARRAY
21443: PUSH
21444: LD_STRING p
21446: EQUAL
21447: IFFALSE 21457
// result := true ;
21449: LD_ADDR_VAR 0 2
21453: PUSH
21454: LD_INT 1
21456: ST_TO_ADDR
// end ;
21457: LD_VAR 0 2
21461: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21462: LD_INT 0
21464: PPUSH
21465: PPUSH
21466: PPUSH
21467: PPUSH
// if pos < 1 then
21468: LD_VAR 0 2
21472: PUSH
21473: LD_INT 1
21475: LESS
21476: IFFALSE 21480
// exit ;
21478: GO 21783
// if pos = 1 then
21480: LD_VAR 0 2
21484: PUSH
21485: LD_INT 1
21487: EQUAL
21488: IFFALSE 21521
// result := Replace ( arr , pos [ 1 ] , value ) else
21490: LD_ADDR_VAR 0 4
21494: PUSH
21495: LD_VAR 0 1
21499: PPUSH
21500: LD_VAR 0 2
21504: PUSH
21505: LD_INT 1
21507: ARRAY
21508: PPUSH
21509: LD_VAR 0 3
21513: PPUSH
21514: CALL_OW 1
21518: ST_TO_ADDR
21519: GO 21783
// begin tmp := arr ;
21521: LD_ADDR_VAR 0 6
21525: PUSH
21526: LD_VAR 0 1
21530: ST_TO_ADDR
// s_arr := [ tmp ] ;
21531: LD_ADDR_VAR 0 7
21535: PUSH
21536: LD_VAR 0 6
21540: PUSH
21541: EMPTY
21542: LIST
21543: ST_TO_ADDR
// for i = 1 to pos - 1 do
21544: LD_ADDR_VAR 0 5
21548: PUSH
21549: DOUBLE
21550: LD_INT 1
21552: DEC
21553: ST_TO_ADDR
21554: LD_VAR 0 2
21558: PUSH
21559: LD_INT 1
21561: MINUS
21562: PUSH
21563: FOR_TO
21564: IFFALSE 21609
// begin tmp := tmp [ pos [ i ] ] ;
21566: LD_ADDR_VAR 0 6
21570: PUSH
21571: LD_VAR 0 6
21575: PUSH
21576: LD_VAR 0 2
21580: PUSH
21581: LD_VAR 0 5
21585: ARRAY
21586: ARRAY
21587: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21588: LD_ADDR_VAR 0 7
21592: PUSH
21593: LD_VAR 0 7
21597: PUSH
21598: LD_VAR 0 6
21602: PUSH
21603: EMPTY
21604: LIST
21605: ADD
21606: ST_TO_ADDR
// end ;
21607: GO 21563
21609: POP
21610: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21611: LD_ADDR_VAR 0 6
21615: PUSH
21616: LD_VAR 0 6
21620: PPUSH
21621: LD_VAR 0 2
21625: PUSH
21626: LD_VAR 0 2
21630: ARRAY
21631: PPUSH
21632: LD_VAR 0 3
21636: PPUSH
21637: CALL_OW 1
21641: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21642: LD_ADDR_VAR 0 7
21646: PUSH
21647: LD_VAR 0 7
21651: PPUSH
21652: LD_VAR 0 7
21656: PPUSH
21657: LD_VAR 0 6
21661: PPUSH
21662: CALL_OW 1
21666: ST_TO_ADDR
// for i = s_arr downto 2 do
21667: LD_ADDR_VAR 0 5
21671: PUSH
21672: DOUBLE
21673: LD_VAR 0 7
21677: INC
21678: ST_TO_ADDR
21679: LD_INT 2
21681: PUSH
21682: FOR_DOWNTO
21683: IFFALSE 21767
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21685: LD_ADDR_VAR 0 6
21689: PUSH
21690: LD_VAR 0 7
21694: PUSH
21695: LD_VAR 0 5
21699: PUSH
21700: LD_INT 1
21702: MINUS
21703: ARRAY
21704: PPUSH
21705: LD_VAR 0 2
21709: PUSH
21710: LD_VAR 0 5
21714: PUSH
21715: LD_INT 1
21717: MINUS
21718: ARRAY
21719: PPUSH
21720: LD_VAR 0 7
21724: PUSH
21725: LD_VAR 0 5
21729: ARRAY
21730: PPUSH
21731: CALL_OW 1
21735: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21736: LD_ADDR_VAR 0 7
21740: PUSH
21741: LD_VAR 0 7
21745: PPUSH
21746: LD_VAR 0 5
21750: PUSH
21751: LD_INT 1
21753: MINUS
21754: PPUSH
21755: LD_VAR 0 6
21759: PPUSH
21760: CALL_OW 1
21764: ST_TO_ADDR
// end ;
21765: GO 21682
21767: POP
21768: POP
// result := s_arr [ 1 ] ;
21769: LD_ADDR_VAR 0 4
21773: PUSH
21774: LD_VAR 0 7
21778: PUSH
21779: LD_INT 1
21781: ARRAY
21782: ST_TO_ADDR
// end ; end ;
21783: LD_VAR 0 4
21787: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21788: LD_INT 0
21790: PPUSH
21791: PPUSH
// if not list then
21792: LD_VAR 0 1
21796: NOT
21797: IFFALSE 21801
// exit ;
21799: GO 21892
// i := list [ pos1 ] ;
21801: LD_ADDR_VAR 0 5
21805: PUSH
21806: LD_VAR 0 1
21810: PUSH
21811: LD_VAR 0 2
21815: ARRAY
21816: ST_TO_ADDR
// if not i then
21817: LD_VAR 0 5
21821: NOT
21822: IFFALSE 21826
// exit ;
21824: GO 21892
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21826: LD_ADDR_VAR 0 1
21830: PUSH
21831: LD_VAR 0 1
21835: PPUSH
21836: LD_VAR 0 2
21840: PPUSH
21841: LD_VAR 0 1
21845: PUSH
21846: LD_VAR 0 3
21850: ARRAY
21851: PPUSH
21852: CALL_OW 1
21856: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21857: LD_ADDR_VAR 0 1
21861: PUSH
21862: LD_VAR 0 1
21866: PPUSH
21867: LD_VAR 0 3
21871: PPUSH
21872: LD_VAR 0 5
21876: PPUSH
21877: CALL_OW 1
21881: ST_TO_ADDR
// result := list ;
21882: LD_ADDR_VAR 0 4
21886: PUSH
21887: LD_VAR 0 1
21891: ST_TO_ADDR
// end ;
21892: LD_VAR 0 4
21896: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21897: LD_INT 0
21899: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21900: LD_ADDR_VAR 0 5
21904: PUSH
21905: LD_VAR 0 1
21909: PPUSH
21910: CALL_OW 250
21914: PPUSH
21915: LD_VAR 0 1
21919: PPUSH
21920: CALL_OW 251
21924: PPUSH
21925: LD_VAR 0 2
21929: PPUSH
21930: LD_VAR 0 3
21934: PPUSH
21935: LD_VAR 0 4
21939: PPUSH
21940: CALL 22318 0 5
21944: ST_TO_ADDR
// end ;
21945: LD_VAR 0 5
21949: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
21950: LD_INT 0
21952: PPUSH
21953: PPUSH
21954: PPUSH
21955: PPUSH
// if not list or not unit then
21956: LD_VAR 0 2
21960: NOT
21961: PUSH
21962: LD_VAR 0 1
21966: NOT
21967: OR
21968: IFFALSE 21972
// exit ;
21970: GO 22313
// result := [ ] ;
21972: LD_ADDR_VAR 0 5
21976: PUSH
21977: EMPTY
21978: ST_TO_ADDR
// for i in list do
21979: LD_ADDR_VAR 0 6
21983: PUSH
21984: LD_VAR 0 2
21988: PUSH
21989: FOR_IN
21990: IFFALSE 22208
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
21992: LD_ADDR_VAR 0 8
21996: PUSH
21997: LD_VAR 0 1
22001: PPUSH
22002: LD_VAR 0 6
22006: PUSH
22007: LD_INT 1
22009: ARRAY
22010: PPUSH
22011: LD_VAR 0 6
22015: PUSH
22016: LD_INT 2
22018: ARRAY
22019: PPUSH
22020: CALL_OW 297
22024: ST_TO_ADDR
// if not Count ( result ) then
22025: LD_VAR 0 5
22029: PPUSH
22030: CALL 18602 0 1
22034: NOT
22035: IFFALSE 22068
// begin result := Join ( result , [ i , tmp ] ) ;
22037: LD_ADDR_VAR 0 5
22041: PUSH
22042: LD_VAR 0 5
22046: PPUSH
22047: LD_VAR 0 6
22051: PUSH
22052: LD_VAR 0 8
22056: PUSH
22057: EMPTY
22058: LIST
22059: LIST
22060: PPUSH
22061: CALL 54191 0 2
22065: ST_TO_ADDR
// continue ;
22066: GO 21989
// end ; if result [ result ] [ 2 ] <= tmp then
22068: LD_VAR 0 5
22072: PUSH
22073: LD_VAR 0 5
22077: ARRAY
22078: PUSH
22079: LD_INT 2
22081: ARRAY
22082: PUSH
22083: LD_VAR 0 8
22087: LESSEQUAL
22088: IFFALSE 22121
// result := Join ( result , [ i , tmp ] ) else
22090: LD_ADDR_VAR 0 5
22094: PUSH
22095: LD_VAR 0 5
22099: PPUSH
22100: LD_VAR 0 6
22104: PUSH
22105: LD_VAR 0 8
22109: PUSH
22110: EMPTY
22111: LIST
22112: LIST
22113: PPUSH
22114: CALL 54191 0 2
22118: ST_TO_ADDR
22119: GO 22206
// begin for j := 1 to Count ( result ) do
22121: LD_ADDR_VAR 0 7
22125: PUSH
22126: DOUBLE
22127: LD_INT 1
22129: DEC
22130: ST_TO_ADDR
22131: LD_VAR 0 5
22135: PPUSH
22136: CALL 18602 0 1
22140: PUSH
22141: FOR_TO
22142: IFFALSE 22204
// begin if tmp < result [ j ] [ 2 ] then
22144: LD_VAR 0 8
22148: PUSH
22149: LD_VAR 0 5
22153: PUSH
22154: LD_VAR 0 7
22158: ARRAY
22159: PUSH
22160: LD_INT 2
22162: ARRAY
22163: LESS
22164: IFFALSE 22202
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22166: LD_ADDR_VAR 0 5
22170: PUSH
22171: LD_VAR 0 5
22175: PPUSH
22176: LD_VAR 0 7
22180: PPUSH
22181: LD_VAR 0 6
22185: PUSH
22186: LD_VAR 0 8
22190: PUSH
22191: EMPTY
22192: LIST
22193: LIST
22194: PPUSH
22195: CALL_OW 2
22199: ST_TO_ADDR
// break ;
22200: GO 22204
// end ; end ;
22202: GO 22141
22204: POP
22205: POP
// end ; end ;
22206: GO 21989
22208: POP
22209: POP
// if result and not asc then
22210: LD_VAR 0 5
22214: PUSH
22215: LD_VAR 0 3
22219: NOT
22220: AND
22221: IFFALSE 22238
// result := ReverseArray ( result ) ;
22223: LD_ADDR_VAR 0 5
22227: PUSH
22228: LD_VAR 0 5
22232: PPUSH
22233: CALL 49478 0 1
22237: ST_TO_ADDR
// tmp := [ ] ;
22238: LD_ADDR_VAR 0 8
22242: PUSH
22243: EMPTY
22244: ST_TO_ADDR
// if mode then
22245: LD_VAR 0 4
22249: IFFALSE 22313
// begin for i := 1 to result do
22251: LD_ADDR_VAR 0 6
22255: PUSH
22256: DOUBLE
22257: LD_INT 1
22259: DEC
22260: ST_TO_ADDR
22261: LD_VAR 0 5
22265: PUSH
22266: FOR_TO
22267: IFFALSE 22301
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
22269: LD_ADDR_VAR 0 8
22273: PUSH
22274: LD_VAR 0 8
22278: PPUSH
22279: LD_VAR 0 5
22283: PUSH
22284: LD_VAR 0 6
22288: ARRAY
22289: PUSH
22290: LD_INT 1
22292: ARRAY
22293: PPUSH
22294: CALL 54191 0 2
22298: ST_TO_ADDR
22299: GO 22266
22301: POP
22302: POP
// result := tmp ;
22303: LD_ADDR_VAR 0 5
22307: PUSH
22308: LD_VAR 0 8
22312: ST_TO_ADDR
// end ; end ;
22313: LD_VAR 0 5
22317: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22318: LD_INT 0
22320: PPUSH
22321: PPUSH
22322: PPUSH
22323: PPUSH
// if not list then
22324: LD_VAR 0 3
22328: NOT
22329: IFFALSE 22333
// exit ;
22331: GO 22721
// result := [ ] ;
22333: LD_ADDR_VAR 0 6
22337: PUSH
22338: EMPTY
22339: ST_TO_ADDR
// for i in list do
22340: LD_ADDR_VAR 0 7
22344: PUSH
22345: LD_VAR 0 3
22349: PUSH
22350: FOR_IN
22351: IFFALSE 22553
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22353: LD_ADDR_VAR 0 9
22357: PUSH
22358: LD_VAR 0 7
22362: PPUSH
22363: LD_VAR 0 1
22367: PPUSH
22368: LD_VAR 0 2
22372: PPUSH
22373: CALL_OW 297
22377: ST_TO_ADDR
// if not result then
22378: LD_VAR 0 6
22382: NOT
22383: IFFALSE 22409
// result := [ [ i , tmp ] ] else
22385: LD_ADDR_VAR 0 6
22389: PUSH
22390: LD_VAR 0 7
22394: PUSH
22395: LD_VAR 0 9
22399: PUSH
22400: EMPTY
22401: LIST
22402: LIST
22403: PUSH
22404: EMPTY
22405: LIST
22406: ST_TO_ADDR
22407: GO 22551
// begin if result [ result ] [ 2 ] < tmp then
22409: LD_VAR 0 6
22413: PUSH
22414: LD_VAR 0 6
22418: ARRAY
22419: PUSH
22420: LD_INT 2
22422: ARRAY
22423: PUSH
22424: LD_VAR 0 9
22428: LESS
22429: IFFALSE 22471
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
22431: LD_ADDR_VAR 0 6
22435: PUSH
22436: LD_VAR 0 6
22440: PPUSH
22441: LD_VAR 0 6
22445: PUSH
22446: LD_INT 1
22448: PLUS
22449: PPUSH
22450: LD_VAR 0 7
22454: PUSH
22455: LD_VAR 0 9
22459: PUSH
22460: EMPTY
22461: LIST
22462: LIST
22463: PPUSH
22464: CALL_OW 2
22468: ST_TO_ADDR
22469: GO 22551
// for j = 1 to result do
22471: LD_ADDR_VAR 0 8
22475: PUSH
22476: DOUBLE
22477: LD_INT 1
22479: DEC
22480: ST_TO_ADDR
22481: LD_VAR 0 6
22485: PUSH
22486: FOR_TO
22487: IFFALSE 22549
// begin if tmp < result [ j ] [ 2 ] then
22489: LD_VAR 0 9
22493: PUSH
22494: LD_VAR 0 6
22498: PUSH
22499: LD_VAR 0 8
22503: ARRAY
22504: PUSH
22505: LD_INT 2
22507: ARRAY
22508: LESS
22509: IFFALSE 22547
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22511: LD_ADDR_VAR 0 6
22515: PUSH
22516: LD_VAR 0 6
22520: PPUSH
22521: LD_VAR 0 8
22525: PPUSH
22526: LD_VAR 0 7
22530: PUSH
22531: LD_VAR 0 9
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: PPUSH
22540: CALL_OW 2
22544: ST_TO_ADDR
// break ;
22545: GO 22549
// end ; end ;
22547: GO 22486
22549: POP
22550: POP
// end ; end ;
22551: GO 22350
22553: POP
22554: POP
// if result and not asc then
22555: LD_VAR 0 6
22559: PUSH
22560: LD_VAR 0 4
22564: NOT
22565: AND
22566: IFFALSE 22641
// begin tmp := result ;
22568: LD_ADDR_VAR 0 9
22572: PUSH
22573: LD_VAR 0 6
22577: ST_TO_ADDR
// for i = tmp downto 1 do
22578: LD_ADDR_VAR 0 7
22582: PUSH
22583: DOUBLE
22584: LD_VAR 0 9
22588: INC
22589: ST_TO_ADDR
22590: LD_INT 1
22592: PUSH
22593: FOR_DOWNTO
22594: IFFALSE 22639
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22596: LD_ADDR_VAR 0 6
22600: PUSH
22601: LD_VAR 0 6
22605: PPUSH
22606: LD_VAR 0 9
22610: PUSH
22611: LD_VAR 0 7
22615: MINUS
22616: PUSH
22617: LD_INT 1
22619: PLUS
22620: PPUSH
22621: LD_VAR 0 9
22625: PUSH
22626: LD_VAR 0 7
22630: ARRAY
22631: PPUSH
22632: CALL_OW 1
22636: ST_TO_ADDR
22637: GO 22593
22639: POP
22640: POP
// end ; tmp := [ ] ;
22641: LD_ADDR_VAR 0 9
22645: PUSH
22646: EMPTY
22647: ST_TO_ADDR
// if mode then
22648: LD_VAR 0 5
22652: IFFALSE 22721
// begin for i = 1 to result do
22654: LD_ADDR_VAR 0 7
22658: PUSH
22659: DOUBLE
22660: LD_INT 1
22662: DEC
22663: ST_TO_ADDR
22664: LD_VAR 0 6
22668: PUSH
22669: FOR_TO
22670: IFFALSE 22709
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22672: LD_ADDR_VAR 0 9
22676: PUSH
22677: LD_VAR 0 9
22681: PPUSH
22682: LD_VAR 0 7
22686: PPUSH
22687: LD_VAR 0 6
22691: PUSH
22692: LD_VAR 0 7
22696: ARRAY
22697: PUSH
22698: LD_INT 1
22700: ARRAY
22701: PPUSH
22702: CALL_OW 1
22706: ST_TO_ADDR
22707: GO 22669
22709: POP
22710: POP
// result := tmp ;
22711: LD_ADDR_VAR 0 6
22715: PUSH
22716: LD_VAR 0 9
22720: ST_TO_ADDR
// end ; end ;
22721: LD_VAR 0 6
22725: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22726: LD_INT 0
22728: PPUSH
22729: PPUSH
22730: PPUSH
22731: PPUSH
22732: PPUSH
22733: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22734: LD_ADDR_VAR 0 5
22738: PUSH
22739: LD_INT 0
22741: PUSH
22742: LD_INT 0
22744: PUSH
22745: LD_INT 0
22747: PUSH
22748: EMPTY
22749: PUSH
22750: EMPTY
22751: LIST
22752: LIST
22753: LIST
22754: LIST
22755: ST_TO_ADDR
// if not x or not y then
22756: LD_VAR 0 2
22760: NOT
22761: PUSH
22762: LD_VAR 0 3
22766: NOT
22767: OR
22768: IFFALSE 22772
// exit ;
22770: GO 24422
// if not range then
22772: LD_VAR 0 4
22776: NOT
22777: IFFALSE 22787
// range := 10 ;
22779: LD_ADDR_VAR 0 4
22783: PUSH
22784: LD_INT 10
22786: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22787: LD_ADDR_VAR 0 8
22791: PUSH
22792: LD_INT 81
22794: PUSH
22795: LD_VAR 0 1
22799: PUSH
22800: EMPTY
22801: LIST
22802: LIST
22803: PUSH
22804: LD_INT 92
22806: PUSH
22807: LD_VAR 0 2
22811: PUSH
22812: LD_VAR 0 3
22816: PUSH
22817: LD_VAR 0 4
22821: PUSH
22822: EMPTY
22823: LIST
22824: LIST
22825: LIST
22826: LIST
22827: PUSH
22828: LD_INT 3
22830: PUSH
22831: LD_INT 21
22833: PUSH
22834: LD_INT 3
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: PUSH
22841: EMPTY
22842: LIST
22843: LIST
22844: PUSH
22845: EMPTY
22846: LIST
22847: LIST
22848: LIST
22849: PPUSH
22850: CALL_OW 69
22854: ST_TO_ADDR
// if not tmp then
22855: LD_VAR 0 8
22859: NOT
22860: IFFALSE 22864
// exit ;
22862: GO 24422
// for i in tmp do
22864: LD_ADDR_VAR 0 6
22868: PUSH
22869: LD_VAR 0 8
22873: PUSH
22874: FOR_IN
22875: IFFALSE 24397
// begin points := [ 0 , 0 , 0 ] ;
22877: LD_ADDR_VAR 0 9
22881: PUSH
22882: LD_INT 0
22884: PUSH
22885: LD_INT 0
22887: PUSH
22888: LD_INT 0
22890: PUSH
22891: EMPTY
22892: LIST
22893: LIST
22894: LIST
22895: ST_TO_ADDR
// bpoints := 1 ;
22896: LD_ADDR_VAR 0 10
22900: PUSH
22901: LD_INT 1
22903: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22904: LD_VAR 0 6
22908: PPUSH
22909: CALL_OW 247
22913: PUSH
22914: LD_INT 1
22916: DOUBLE
22917: EQUAL
22918: IFTRUE 22922
22920: GO 23500
22922: POP
// begin if GetClass ( i ) = 1 then
22923: LD_VAR 0 6
22927: PPUSH
22928: CALL_OW 257
22932: PUSH
22933: LD_INT 1
22935: EQUAL
22936: IFFALSE 22957
// points := [ 10 , 5 , 3 ] ;
22938: LD_ADDR_VAR 0 9
22942: PUSH
22943: LD_INT 10
22945: PUSH
22946: LD_INT 5
22948: PUSH
22949: LD_INT 3
22951: PUSH
22952: EMPTY
22953: LIST
22954: LIST
22955: LIST
22956: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22957: LD_VAR 0 6
22961: PPUSH
22962: CALL_OW 257
22966: PUSH
22967: LD_INT 2
22969: PUSH
22970: LD_INT 3
22972: PUSH
22973: LD_INT 4
22975: PUSH
22976: EMPTY
22977: LIST
22978: LIST
22979: LIST
22980: IN
22981: IFFALSE 23002
// points := [ 3 , 2 , 1 ] ;
22983: LD_ADDR_VAR 0 9
22987: PUSH
22988: LD_INT 3
22990: PUSH
22991: LD_INT 2
22993: PUSH
22994: LD_INT 1
22996: PUSH
22997: EMPTY
22998: LIST
22999: LIST
23000: LIST
23001: ST_TO_ADDR
// if GetClass ( i ) = 5 then
23002: LD_VAR 0 6
23006: PPUSH
23007: CALL_OW 257
23011: PUSH
23012: LD_INT 5
23014: EQUAL
23015: IFFALSE 23036
// points := [ 130 , 5 , 2 ] ;
23017: LD_ADDR_VAR 0 9
23021: PUSH
23022: LD_INT 130
23024: PUSH
23025: LD_INT 5
23027: PUSH
23028: LD_INT 2
23030: PUSH
23031: EMPTY
23032: LIST
23033: LIST
23034: LIST
23035: ST_TO_ADDR
// if GetClass ( i ) = 8 then
23036: LD_VAR 0 6
23040: PPUSH
23041: CALL_OW 257
23045: PUSH
23046: LD_INT 8
23048: EQUAL
23049: IFFALSE 23070
// points := [ 35 , 35 , 30 ] ;
23051: LD_ADDR_VAR 0 9
23055: PUSH
23056: LD_INT 35
23058: PUSH
23059: LD_INT 35
23061: PUSH
23062: LD_INT 30
23064: PUSH
23065: EMPTY
23066: LIST
23067: LIST
23068: LIST
23069: ST_TO_ADDR
// if GetClass ( i ) = 9 then
23070: LD_VAR 0 6
23074: PPUSH
23075: CALL_OW 257
23079: PUSH
23080: LD_INT 9
23082: EQUAL
23083: IFFALSE 23104
// points := [ 20 , 55 , 40 ] ;
23085: LD_ADDR_VAR 0 9
23089: PUSH
23090: LD_INT 20
23092: PUSH
23093: LD_INT 55
23095: PUSH
23096: LD_INT 40
23098: PUSH
23099: EMPTY
23100: LIST
23101: LIST
23102: LIST
23103: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
23104: LD_VAR 0 6
23108: PPUSH
23109: CALL_OW 257
23113: PUSH
23114: LD_INT 12
23116: PUSH
23117: LD_INT 16
23119: PUSH
23120: EMPTY
23121: LIST
23122: LIST
23123: IN
23124: IFFALSE 23145
// points := [ 5 , 3 , 2 ] ;
23126: LD_ADDR_VAR 0 9
23130: PUSH
23131: LD_INT 5
23133: PUSH
23134: LD_INT 3
23136: PUSH
23137: LD_INT 2
23139: PUSH
23140: EMPTY
23141: LIST
23142: LIST
23143: LIST
23144: ST_TO_ADDR
// if GetClass ( i ) = 17 then
23145: LD_VAR 0 6
23149: PPUSH
23150: CALL_OW 257
23154: PUSH
23155: LD_INT 17
23157: EQUAL
23158: IFFALSE 23179
// points := [ 100 , 50 , 75 ] ;
23160: LD_ADDR_VAR 0 9
23164: PUSH
23165: LD_INT 100
23167: PUSH
23168: LD_INT 50
23170: PUSH
23171: LD_INT 75
23173: PUSH
23174: EMPTY
23175: LIST
23176: LIST
23177: LIST
23178: ST_TO_ADDR
// if GetClass ( i ) = 15 then
23179: LD_VAR 0 6
23183: PPUSH
23184: CALL_OW 257
23188: PUSH
23189: LD_INT 15
23191: EQUAL
23192: IFFALSE 23213
// points := [ 10 , 5 , 3 ] ;
23194: LD_ADDR_VAR 0 9
23198: PUSH
23199: LD_INT 10
23201: PUSH
23202: LD_INT 5
23204: PUSH
23205: LD_INT 3
23207: PUSH
23208: EMPTY
23209: LIST
23210: LIST
23211: LIST
23212: ST_TO_ADDR
// if GetClass ( i ) = 14 then
23213: LD_VAR 0 6
23217: PPUSH
23218: CALL_OW 257
23222: PUSH
23223: LD_INT 14
23225: EQUAL
23226: IFFALSE 23247
// points := [ 10 , 0 , 0 ] ;
23228: LD_ADDR_VAR 0 9
23232: PUSH
23233: LD_INT 10
23235: PUSH
23236: LD_INT 0
23238: PUSH
23239: LD_INT 0
23241: PUSH
23242: EMPTY
23243: LIST
23244: LIST
23245: LIST
23246: ST_TO_ADDR
// if GetClass ( i ) = 11 then
23247: LD_VAR 0 6
23251: PPUSH
23252: CALL_OW 257
23256: PUSH
23257: LD_INT 11
23259: EQUAL
23260: IFFALSE 23281
// points := [ 30 , 10 , 5 ] ;
23262: LD_ADDR_VAR 0 9
23266: PUSH
23267: LD_INT 30
23269: PUSH
23270: LD_INT 10
23272: PUSH
23273: LD_INT 5
23275: PUSH
23276: EMPTY
23277: LIST
23278: LIST
23279: LIST
23280: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
23281: LD_VAR 0 1
23285: PPUSH
23286: LD_INT 5
23288: PPUSH
23289: CALL_OW 321
23293: PUSH
23294: LD_INT 2
23296: EQUAL
23297: IFFALSE 23314
// bpoints := bpoints * 1.8 ;
23299: LD_ADDR_VAR 0 10
23303: PUSH
23304: LD_VAR 0 10
23308: PUSH
23309: LD_REAL  1.80000000000000E+0000
23312: MUL
23313: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23314: LD_VAR 0 6
23318: PPUSH
23319: CALL_OW 257
23323: PUSH
23324: LD_INT 1
23326: PUSH
23327: LD_INT 2
23329: PUSH
23330: LD_INT 3
23332: PUSH
23333: LD_INT 4
23335: PUSH
23336: EMPTY
23337: LIST
23338: LIST
23339: LIST
23340: LIST
23341: IN
23342: PUSH
23343: LD_VAR 0 1
23347: PPUSH
23348: LD_INT 51
23350: PPUSH
23351: CALL_OW 321
23355: PUSH
23356: LD_INT 2
23358: EQUAL
23359: AND
23360: IFFALSE 23377
// bpoints := bpoints * 1.2 ;
23362: LD_ADDR_VAR 0 10
23366: PUSH
23367: LD_VAR 0 10
23371: PUSH
23372: LD_REAL  1.20000000000000E+0000
23375: MUL
23376: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23377: LD_VAR 0 6
23381: PPUSH
23382: CALL_OW 257
23386: PUSH
23387: LD_INT 5
23389: PUSH
23390: LD_INT 7
23392: PUSH
23393: LD_INT 9
23395: PUSH
23396: EMPTY
23397: LIST
23398: LIST
23399: LIST
23400: IN
23401: PUSH
23402: LD_VAR 0 1
23406: PPUSH
23407: LD_INT 52
23409: PPUSH
23410: CALL_OW 321
23414: PUSH
23415: LD_INT 2
23417: EQUAL
23418: AND
23419: IFFALSE 23436
// bpoints := bpoints * 1.5 ;
23421: LD_ADDR_VAR 0 10
23425: PUSH
23426: LD_VAR 0 10
23430: PUSH
23431: LD_REAL  1.50000000000000E+0000
23434: MUL
23435: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
23436: LD_VAR 0 1
23440: PPUSH
23441: LD_INT 66
23443: PPUSH
23444: CALL_OW 321
23448: PUSH
23449: LD_INT 2
23451: EQUAL
23452: IFFALSE 23469
// bpoints := bpoints * 1.1 ;
23454: LD_ADDR_VAR 0 10
23458: PUSH
23459: LD_VAR 0 10
23463: PUSH
23464: LD_REAL  1.10000000000000E+0000
23467: MUL
23468: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23469: LD_ADDR_VAR 0 10
23473: PUSH
23474: LD_VAR 0 10
23478: PUSH
23479: LD_VAR 0 6
23483: PPUSH
23484: LD_INT 1
23486: PPUSH
23487: CALL_OW 259
23491: PUSH
23492: LD_REAL  1.15000000000000E+0000
23495: MUL
23496: MUL
23497: ST_TO_ADDR
// end ; unit_vehicle :
23498: GO 24326
23500: LD_INT 2
23502: DOUBLE
23503: EQUAL
23504: IFTRUE 23508
23506: GO 24314
23508: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23509: LD_VAR 0 6
23513: PPUSH
23514: CALL_OW 264
23518: PUSH
23519: LD_INT 2
23521: PUSH
23522: LD_INT 42
23524: PUSH
23525: LD_INT 24
23527: PUSH
23528: EMPTY
23529: LIST
23530: LIST
23531: LIST
23532: IN
23533: IFFALSE 23554
// points := [ 25 , 5 , 3 ] ;
23535: LD_ADDR_VAR 0 9
23539: PUSH
23540: LD_INT 25
23542: PUSH
23543: LD_INT 5
23545: PUSH
23546: LD_INT 3
23548: PUSH
23549: EMPTY
23550: LIST
23551: LIST
23552: LIST
23553: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23554: LD_VAR 0 6
23558: PPUSH
23559: CALL_OW 264
23563: PUSH
23564: LD_INT 4
23566: PUSH
23567: LD_INT 43
23569: PUSH
23570: LD_INT 25
23572: PUSH
23573: EMPTY
23574: LIST
23575: LIST
23576: LIST
23577: IN
23578: IFFALSE 23599
// points := [ 40 , 15 , 5 ] ;
23580: LD_ADDR_VAR 0 9
23584: PUSH
23585: LD_INT 40
23587: PUSH
23588: LD_INT 15
23590: PUSH
23591: LD_INT 5
23593: PUSH
23594: EMPTY
23595: LIST
23596: LIST
23597: LIST
23598: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23599: LD_VAR 0 6
23603: PPUSH
23604: CALL_OW 264
23608: PUSH
23609: LD_INT 3
23611: PUSH
23612: LD_INT 23
23614: PUSH
23615: EMPTY
23616: LIST
23617: LIST
23618: IN
23619: IFFALSE 23640
// points := [ 7 , 25 , 8 ] ;
23621: LD_ADDR_VAR 0 9
23625: PUSH
23626: LD_INT 7
23628: PUSH
23629: LD_INT 25
23631: PUSH
23632: LD_INT 8
23634: PUSH
23635: EMPTY
23636: LIST
23637: LIST
23638: LIST
23639: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23640: LD_VAR 0 6
23644: PPUSH
23645: CALL_OW 264
23649: PUSH
23650: LD_INT 5
23652: PUSH
23653: LD_INT 27
23655: PUSH
23656: LD_INT 44
23658: PUSH
23659: EMPTY
23660: LIST
23661: LIST
23662: LIST
23663: IN
23664: IFFALSE 23685
// points := [ 14 , 50 , 16 ] ;
23666: LD_ADDR_VAR 0 9
23670: PUSH
23671: LD_INT 14
23673: PUSH
23674: LD_INT 50
23676: PUSH
23677: LD_INT 16
23679: PUSH
23680: EMPTY
23681: LIST
23682: LIST
23683: LIST
23684: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23685: LD_VAR 0 6
23689: PPUSH
23690: CALL_OW 264
23694: PUSH
23695: LD_INT 6
23697: PUSH
23698: LD_INT 46
23700: PUSH
23701: EMPTY
23702: LIST
23703: LIST
23704: IN
23705: IFFALSE 23726
// points := [ 32 , 120 , 70 ] ;
23707: LD_ADDR_VAR 0 9
23711: PUSH
23712: LD_INT 32
23714: PUSH
23715: LD_INT 120
23717: PUSH
23718: LD_INT 70
23720: PUSH
23721: EMPTY
23722: LIST
23723: LIST
23724: LIST
23725: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
23726: LD_VAR 0 6
23730: PPUSH
23731: CALL_OW 264
23735: PUSH
23736: LD_INT 7
23738: PUSH
23739: LD_INT 28
23741: PUSH
23742: LD_INT 45
23744: PUSH
23745: LD_INT 92
23747: PUSH
23748: EMPTY
23749: LIST
23750: LIST
23751: LIST
23752: LIST
23753: IN
23754: IFFALSE 23775
// points := [ 35 , 20 , 45 ] ;
23756: LD_ADDR_VAR 0 9
23760: PUSH
23761: LD_INT 35
23763: PUSH
23764: LD_INT 20
23766: PUSH
23767: LD_INT 45
23769: PUSH
23770: EMPTY
23771: LIST
23772: LIST
23773: LIST
23774: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23775: LD_VAR 0 6
23779: PPUSH
23780: CALL_OW 264
23784: PUSH
23785: LD_INT 47
23787: PUSH
23788: EMPTY
23789: LIST
23790: IN
23791: IFFALSE 23812
// points := [ 67 , 45 , 75 ] ;
23793: LD_ADDR_VAR 0 9
23797: PUSH
23798: LD_INT 67
23800: PUSH
23801: LD_INT 45
23803: PUSH
23804: LD_INT 75
23806: PUSH
23807: EMPTY
23808: LIST
23809: LIST
23810: LIST
23811: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23812: LD_VAR 0 6
23816: PPUSH
23817: CALL_OW 264
23821: PUSH
23822: LD_INT 26
23824: PUSH
23825: EMPTY
23826: LIST
23827: IN
23828: IFFALSE 23849
// points := [ 120 , 30 , 80 ] ;
23830: LD_ADDR_VAR 0 9
23834: PUSH
23835: LD_INT 120
23837: PUSH
23838: LD_INT 30
23840: PUSH
23841: LD_INT 80
23843: PUSH
23844: EMPTY
23845: LIST
23846: LIST
23847: LIST
23848: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23849: LD_VAR 0 6
23853: PPUSH
23854: CALL_OW 264
23858: PUSH
23859: LD_INT 22
23861: PUSH
23862: EMPTY
23863: LIST
23864: IN
23865: IFFALSE 23886
// points := [ 40 , 1 , 1 ] ;
23867: LD_ADDR_VAR 0 9
23871: PUSH
23872: LD_INT 40
23874: PUSH
23875: LD_INT 1
23877: PUSH
23878: LD_INT 1
23880: PUSH
23881: EMPTY
23882: LIST
23883: LIST
23884: LIST
23885: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23886: LD_VAR 0 6
23890: PPUSH
23891: CALL_OW 264
23895: PUSH
23896: LD_INT 29
23898: PUSH
23899: EMPTY
23900: LIST
23901: IN
23902: IFFALSE 23923
// points := [ 70 , 200 , 400 ] ;
23904: LD_ADDR_VAR 0 9
23908: PUSH
23909: LD_INT 70
23911: PUSH
23912: LD_INT 200
23914: PUSH
23915: LD_INT 400
23917: PUSH
23918: EMPTY
23919: LIST
23920: LIST
23921: LIST
23922: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23923: LD_VAR 0 6
23927: PPUSH
23928: CALL_OW 264
23932: PUSH
23933: LD_INT 14
23935: PUSH
23936: LD_INT 53
23938: PUSH
23939: EMPTY
23940: LIST
23941: LIST
23942: IN
23943: IFFALSE 23964
// points := [ 40 , 10 , 20 ] ;
23945: LD_ADDR_VAR 0 9
23949: PUSH
23950: LD_INT 40
23952: PUSH
23953: LD_INT 10
23955: PUSH
23956: LD_INT 20
23958: PUSH
23959: EMPTY
23960: LIST
23961: LIST
23962: LIST
23963: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23964: LD_VAR 0 6
23968: PPUSH
23969: CALL_OW 264
23973: PUSH
23974: LD_INT 9
23976: PUSH
23977: EMPTY
23978: LIST
23979: IN
23980: IFFALSE 24001
// points := [ 5 , 70 , 20 ] ;
23982: LD_ADDR_VAR 0 9
23986: PUSH
23987: LD_INT 5
23989: PUSH
23990: LD_INT 70
23992: PUSH
23993: LD_INT 20
23995: PUSH
23996: EMPTY
23997: LIST
23998: LIST
23999: LIST
24000: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
24001: LD_VAR 0 6
24005: PPUSH
24006: CALL_OW 264
24010: PUSH
24011: LD_INT 10
24013: PUSH
24014: EMPTY
24015: LIST
24016: IN
24017: IFFALSE 24038
// points := [ 35 , 110 , 70 ] ;
24019: LD_ADDR_VAR 0 9
24023: PUSH
24024: LD_INT 35
24026: PUSH
24027: LD_INT 110
24029: PUSH
24030: LD_INT 70
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: LIST
24037: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
24038: LD_VAR 0 6
24042: PPUSH
24043: CALL_OW 265
24047: PUSH
24048: LD_INT 25
24050: EQUAL
24051: IFFALSE 24072
// points := [ 80 , 65 , 100 ] ;
24053: LD_ADDR_VAR 0 9
24057: PUSH
24058: LD_INT 80
24060: PUSH
24061: LD_INT 65
24063: PUSH
24064: LD_INT 100
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: LIST
24071: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
24072: LD_VAR 0 6
24076: PPUSH
24077: CALL_OW 263
24081: PUSH
24082: LD_INT 1
24084: EQUAL
24085: IFFALSE 24120
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
24087: LD_ADDR_VAR 0 10
24091: PUSH
24092: LD_VAR 0 10
24096: PUSH
24097: LD_VAR 0 6
24101: PPUSH
24102: CALL_OW 311
24106: PPUSH
24107: LD_INT 3
24109: PPUSH
24110: CALL_OW 259
24114: PUSH
24115: LD_INT 4
24117: MUL
24118: MUL
24119: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
24120: LD_VAR 0 6
24124: PPUSH
24125: CALL_OW 263
24129: PUSH
24130: LD_INT 2
24132: EQUAL
24133: IFFALSE 24184
// begin j := IsControledBy ( i ) ;
24135: LD_ADDR_VAR 0 7
24139: PUSH
24140: LD_VAR 0 6
24144: PPUSH
24145: CALL_OW 312
24149: ST_TO_ADDR
// if j then
24150: LD_VAR 0 7
24154: IFFALSE 24184
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
24156: LD_ADDR_VAR 0 10
24160: PUSH
24161: LD_VAR 0 10
24165: PUSH
24166: LD_VAR 0 7
24170: PPUSH
24171: LD_INT 3
24173: PPUSH
24174: CALL_OW 259
24178: PUSH
24179: LD_INT 3
24181: MUL
24182: MUL
24183: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
24184: LD_VAR 0 6
24188: PPUSH
24189: CALL_OW 264
24193: PUSH
24194: LD_INT 5
24196: PUSH
24197: LD_INT 6
24199: PUSH
24200: LD_INT 46
24202: PUSH
24203: LD_INT 44
24205: PUSH
24206: LD_INT 47
24208: PUSH
24209: LD_INT 45
24211: PUSH
24212: LD_INT 28
24214: PUSH
24215: LD_INT 7
24217: PUSH
24218: LD_INT 27
24220: PUSH
24221: LD_INT 29
24223: PUSH
24224: EMPTY
24225: LIST
24226: LIST
24227: LIST
24228: LIST
24229: LIST
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: LIST
24235: IN
24236: PUSH
24237: LD_VAR 0 1
24241: PPUSH
24242: LD_INT 52
24244: PPUSH
24245: CALL_OW 321
24249: PUSH
24250: LD_INT 2
24252: EQUAL
24253: AND
24254: IFFALSE 24271
// bpoints := bpoints * 1.2 ;
24256: LD_ADDR_VAR 0 10
24260: PUSH
24261: LD_VAR 0 10
24265: PUSH
24266: LD_REAL  1.20000000000000E+0000
24269: MUL
24270: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
24271: LD_VAR 0 6
24275: PPUSH
24276: CALL_OW 264
24280: PUSH
24281: LD_INT 6
24283: PUSH
24284: LD_INT 46
24286: PUSH
24287: LD_INT 47
24289: PUSH
24290: EMPTY
24291: LIST
24292: LIST
24293: LIST
24294: IN
24295: IFFALSE 24312
// bpoints := bpoints * 1.2 ;
24297: LD_ADDR_VAR 0 10
24301: PUSH
24302: LD_VAR 0 10
24306: PUSH
24307: LD_REAL  1.20000000000000E+0000
24310: MUL
24311: ST_TO_ADDR
// end ; unit_building :
24312: GO 24326
24314: LD_INT 3
24316: DOUBLE
24317: EQUAL
24318: IFTRUE 24322
24320: GO 24325
24322: POP
// ; end ;
24323: GO 24326
24325: POP
// for j = 1 to 3 do
24326: LD_ADDR_VAR 0 7
24330: PUSH
24331: DOUBLE
24332: LD_INT 1
24334: DEC
24335: ST_TO_ADDR
24336: LD_INT 3
24338: PUSH
24339: FOR_TO
24340: IFFALSE 24393
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24342: LD_ADDR_VAR 0 5
24346: PUSH
24347: LD_VAR 0 5
24351: PPUSH
24352: LD_VAR 0 7
24356: PPUSH
24357: LD_VAR 0 5
24361: PUSH
24362: LD_VAR 0 7
24366: ARRAY
24367: PUSH
24368: LD_VAR 0 9
24372: PUSH
24373: LD_VAR 0 7
24377: ARRAY
24378: PUSH
24379: LD_VAR 0 10
24383: MUL
24384: PLUS
24385: PPUSH
24386: CALL_OW 1
24390: ST_TO_ADDR
24391: GO 24339
24393: POP
24394: POP
// end ;
24395: GO 22874
24397: POP
24398: POP
// result := Replace ( result , 4 , tmp ) ;
24399: LD_ADDR_VAR 0 5
24403: PUSH
24404: LD_VAR 0 5
24408: PPUSH
24409: LD_INT 4
24411: PPUSH
24412: LD_VAR 0 8
24416: PPUSH
24417: CALL_OW 1
24421: ST_TO_ADDR
// end ;
24422: LD_VAR 0 5
24426: RET
// export function DangerAtRange ( unit , range ) ; begin
24427: LD_INT 0
24429: PPUSH
// if not unit then
24430: LD_VAR 0 1
24434: NOT
24435: IFFALSE 24439
// exit ;
24437: GO 24484
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
24439: LD_ADDR_VAR 0 3
24443: PUSH
24444: LD_VAR 0 1
24448: PPUSH
24449: CALL_OW 255
24453: PPUSH
24454: LD_VAR 0 1
24458: PPUSH
24459: CALL_OW 250
24463: PPUSH
24464: LD_VAR 0 1
24468: PPUSH
24469: CALL_OW 251
24473: PPUSH
24474: LD_VAR 0 2
24478: PPUSH
24479: CALL 22726 0 4
24483: ST_TO_ADDR
// end ;
24484: LD_VAR 0 3
24488: RET
// export function DangerInArea ( side , area ) ; begin
24489: LD_INT 0
24491: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24492: LD_ADDR_VAR 0 3
24496: PUSH
24497: LD_VAR 0 2
24501: PPUSH
24502: LD_INT 81
24504: PUSH
24505: LD_VAR 0 1
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PPUSH
24514: CALL_OW 70
24518: ST_TO_ADDR
// end ;
24519: LD_VAR 0 3
24523: RET
// export function IsExtension ( b ) ; begin
24524: LD_INT 0
24526: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24527: LD_ADDR_VAR 0 2
24531: PUSH
24532: LD_VAR 0 1
24536: PUSH
24537: LD_INT 23
24539: PUSH
24540: LD_INT 20
24542: PUSH
24543: LD_INT 22
24545: PUSH
24546: LD_INT 17
24548: PUSH
24549: LD_INT 24
24551: PUSH
24552: LD_INT 21
24554: PUSH
24555: LD_INT 19
24557: PUSH
24558: LD_INT 16
24560: PUSH
24561: LD_INT 25
24563: PUSH
24564: LD_INT 18
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: LIST
24571: LIST
24572: LIST
24573: LIST
24574: LIST
24575: LIST
24576: LIST
24577: LIST
24578: IN
24579: ST_TO_ADDR
// end ;
24580: LD_VAR 0 2
24584: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
24585: LD_INT 0
24587: PPUSH
24588: PPUSH
24589: PPUSH
// result := [ ] ;
24590: LD_ADDR_VAR 0 4
24594: PUSH
24595: EMPTY
24596: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24597: LD_ADDR_VAR 0 5
24601: PUSH
24602: LD_VAR 0 2
24606: PPUSH
24607: LD_INT 21
24609: PUSH
24610: LD_INT 3
24612: PUSH
24613: EMPTY
24614: LIST
24615: LIST
24616: PPUSH
24617: CALL_OW 70
24621: ST_TO_ADDR
// if not tmp then
24622: LD_VAR 0 5
24626: NOT
24627: IFFALSE 24631
// exit ;
24629: GO 24695
// if checkLink then
24631: LD_VAR 0 3
24635: IFFALSE 24685
// begin for i in tmp do
24637: LD_ADDR_VAR 0 6
24641: PUSH
24642: LD_VAR 0 5
24646: PUSH
24647: FOR_IN
24648: IFFALSE 24683
// if GetBase ( i ) <> base then
24650: LD_VAR 0 6
24654: PPUSH
24655: CALL_OW 274
24659: PUSH
24660: LD_VAR 0 1
24664: NONEQUAL
24665: IFFALSE 24681
// ComLinkToBase ( base , i ) ;
24667: LD_VAR 0 1
24671: PPUSH
24672: LD_VAR 0 6
24676: PPUSH
24677: CALL_OW 169
24681: GO 24647
24683: POP
24684: POP
// end ; result := tmp ;
24685: LD_ADDR_VAR 0 4
24689: PUSH
24690: LD_VAR 0 5
24694: ST_TO_ADDR
// end ;
24695: LD_VAR 0 4
24699: RET
// export function ComComplete ( units , b ) ; var i ; begin
24700: LD_INT 0
24702: PPUSH
24703: PPUSH
// if not units then
24704: LD_VAR 0 1
24708: NOT
24709: IFFALSE 24713
// exit ;
24711: GO 24803
// for i in units do
24713: LD_ADDR_VAR 0 4
24717: PUSH
24718: LD_VAR 0 1
24722: PUSH
24723: FOR_IN
24724: IFFALSE 24801
// if BuildingStatus ( b ) = bs_build then
24726: LD_VAR 0 2
24730: PPUSH
24731: CALL_OW 461
24735: PUSH
24736: LD_INT 1
24738: EQUAL
24739: IFFALSE 24799
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24741: LD_VAR 0 4
24745: PPUSH
24746: LD_STRING h
24748: PUSH
24749: LD_VAR 0 2
24753: PPUSH
24754: CALL_OW 250
24758: PUSH
24759: LD_VAR 0 2
24763: PPUSH
24764: CALL_OW 251
24768: PUSH
24769: LD_VAR 0 2
24773: PUSH
24774: LD_INT 0
24776: PUSH
24777: LD_INT 0
24779: PUSH
24780: LD_INT 0
24782: PUSH
24783: EMPTY
24784: LIST
24785: LIST
24786: LIST
24787: LIST
24788: LIST
24789: LIST
24790: LIST
24791: PUSH
24792: EMPTY
24793: LIST
24794: PPUSH
24795: CALL_OW 446
24799: GO 24723
24801: POP
24802: POP
// end ;
24803: LD_VAR 0 3
24807: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24808: LD_INT 0
24810: PPUSH
24811: PPUSH
24812: PPUSH
24813: PPUSH
24814: PPUSH
24815: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
24816: LD_VAR 0 1
24820: NOT
24821: PUSH
24822: LD_VAR 0 1
24826: PPUSH
24827: CALL_OW 263
24831: PUSH
24832: LD_INT 2
24834: NONEQUAL
24835: OR
24836: IFFALSE 24840
// exit ;
24838: GO 25156
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24840: LD_ADDR_VAR 0 6
24844: PUSH
24845: LD_INT 22
24847: PUSH
24848: LD_VAR 0 1
24852: PPUSH
24853: CALL_OW 255
24857: PUSH
24858: EMPTY
24859: LIST
24860: LIST
24861: PUSH
24862: LD_INT 2
24864: PUSH
24865: LD_INT 30
24867: PUSH
24868: LD_INT 36
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: PUSH
24875: LD_INT 34
24877: PUSH
24878: LD_INT 31
24880: PUSH
24881: EMPTY
24882: LIST
24883: LIST
24884: PUSH
24885: EMPTY
24886: LIST
24887: LIST
24888: LIST
24889: PUSH
24890: EMPTY
24891: LIST
24892: LIST
24893: PPUSH
24894: CALL_OW 69
24898: ST_TO_ADDR
// if not tmp then
24899: LD_VAR 0 6
24903: NOT
24904: IFFALSE 24908
// exit ;
24906: GO 25156
// result := [ ] ;
24908: LD_ADDR_VAR 0 2
24912: PUSH
24913: EMPTY
24914: ST_TO_ADDR
// for i in tmp do
24915: LD_ADDR_VAR 0 3
24919: PUSH
24920: LD_VAR 0 6
24924: PUSH
24925: FOR_IN
24926: IFFALSE 24997
// begin t := UnitsInside ( i ) ;
24928: LD_ADDR_VAR 0 4
24932: PUSH
24933: LD_VAR 0 3
24937: PPUSH
24938: CALL_OW 313
24942: ST_TO_ADDR
// if t then
24943: LD_VAR 0 4
24947: IFFALSE 24995
// for j in t do
24949: LD_ADDR_VAR 0 7
24953: PUSH
24954: LD_VAR 0 4
24958: PUSH
24959: FOR_IN
24960: IFFALSE 24993
// result := Replace ( result , result + 1 , j ) ;
24962: LD_ADDR_VAR 0 2
24966: PUSH
24967: LD_VAR 0 2
24971: PPUSH
24972: LD_VAR 0 2
24976: PUSH
24977: LD_INT 1
24979: PLUS
24980: PPUSH
24981: LD_VAR 0 7
24985: PPUSH
24986: CALL_OW 1
24990: ST_TO_ADDR
24991: GO 24959
24993: POP
24994: POP
// end ;
24995: GO 24925
24997: POP
24998: POP
// if not result then
24999: LD_VAR 0 2
25003: NOT
25004: IFFALSE 25008
// exit ;
25006: GO 25156
// mech := result [ 1 ] ;
25008: LD_ADDR_VAR 0 5
25012: PUSH
25013: LD_VAR 0 2
25017: PUSH
25018: LD_INT 1
25020: ARRAY
25021: ST_TO_ADDR
// if result > 1 then
25022: LD_VAR 0 2
25026: PUSH
25027: LD_INT 1
25029: GREATER
25030: IFFALSE 25142
// begin for i = 2 to result do
25032: LD_ADDR_VAR 0 3
25036: PUSH
25037: DOUBLE
25038: LD_INT 2
25040: DEC
25041: ST_TO_ADDR
25042: LD_VAR 0 2
25046: PUSH
25047: FOR_TO
25048: IFFALSE 25140
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
25050: LD_ADDR_VAR 0 4
25054: PUSH
25055: LD_VAR 0 2
25059: PUSH
25060: LD_VAR 0 3
25064: ARRAY
25065: PPUSH
25066: LD_INT 3
25068: PPUSH
25069: CALL_OW 259
25073: PUSH
25074: LD_VAR 0 2
25078: PUSH
25079: LD_VAR 0 3
25083: ARRAY
25084: PPUSH
25085: CALL_OW 432
25089: MINUS
25090: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
25091: LD_VAR 0 4
25095: PUSH
25096: LD_VAR 0 5
25100: PPUSH
25101: LD_INT 3
25103: PPUSH
25104: CALL_OW 259
25108: PUSH
25109: LD_VAR 0 5
25113: PPUSH
25114: CALL_OW 432
25118: MINUS
25119: GREATEREQUAL
25120: IFFALSE 25138
// mech := result [ i ] ;
25122: LD_ADDR_VAR 0 5
25126: PUSH
25127: LD_VAR 0 2
25131: PUSH
25132: LD_VAR 0 3
25136: ARRAY
25137: ST_TO_ADDR
// end ;
25138: GO 25047
25140: POP
25141: POP
// end ; ComLinkTo ( vehicle , mech ) ;
25142: LD_VAR 0 1
25146: PPUSH
25147: LD_VAR 0 5
25151: PPUSH
25152: CALL_OW 135
// end ;
25156: LD_VAR 0 2
25160: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
25161: LD_INT 0
25163: PPUSH
25164: PPUSH
25165: PPUSH
25166: PPUSH
25167: PPUSH
25168: PPUSH
25169: PPUSH
25170: PPUSH
25171: PPUSH
25172: PPUSH
25173: PPUSH
25174: PPUSH
25175: PPUSH
// result := [ ] ;
25176: LD_ADDR_VAR 0 7
25180: PUSH
25181: EMPTY
25182: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
25183: LD_VAR 0 1
25187: PPUSH
25188: CALL_OW 266
25192: PUSH
25193: LD_INT 0
25195: PUSH
25196: LD_INT 1
25198: PUSH
25199: EMPTY
25200: LIST
25201: LIST
25202: IN
25203: NOT
25204: IFFALSE 25208
// exit ;
25206: GO 26842
// if name then
25208: LD_VAR 0 3
25212: IFFALSE 25228
// SetBName ( base_dep , name ) ;
25214: LD_VAR 0 1
25218: PPUSH
25219: LD_VAR 0 3
25223: PPUSH
25224: CALL_OW 500
// base := GetBase ( base_dep ) ;
25228: LD_ADDR_VAR 0 15
25232: PUSH
25233: LD_VAR 0 1
25237: PPUSH
25238: CALL_OW 274
25242: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
25243: LD_ADDR_VAR 0 16
25247: PUSH
25248: LD_VAR 0 1
25252: PPUSH
25253: CALL_OW 255
25257: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
25258: LD_ADDR_VAR 0 17
25262: PUSH
25263: LD_VAR 0 1
25267: PPUSH
25268: CALL_OW 248
25272: ST_TO_ADDR
// if sources then
25273: LD_VAR 0 5
25277: IFFALSE 25324
// for i = 1 to 3 do
25279: LD_ADDR_VAR 0 8
25283: PUSH
25284: DOUBLE
25285: LD_INT 1
25287: DEC
25288: ST_TO_ADDR
25289: LD_INT 3
25291: PUSH
25292: FOR_TO
25293: IFFALSE 25322
// AddResourceType ( base , i , sources [ i ] ) ;
25295: LD_VAR 0 15
25299: PPUSH
25300: LD_VAR 0 8
25304: PPUSH
25305: LD_VAR 0 5
25309: PUSH
25310: LD_VAR 0 8
25314: ARRAY
25315: PPUSH
25316: CALL_OW 276
25320: GO 25292
25322: POP
25323: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
25324: LD_ADDR_VAR 0 18
25328: PUSH
25329: LD_VAR 0 15
25333: PPUSH
25334: LD_VAR 0 2
25338: PPUSH
25339: LD_INT 1
25341: PPUSH
25342: CALL 24585 0 3
25346: ST_TO_ADDR
// InitHc ;
25347: CALL_OW 19
// InitUc ;
25351: CALL_OW 18
// uc_side := side ;
25355: LD_ADDR_OWVAR 20
25359: PUSH
25360: LD_VAR 0 16
25364: ST_TO_ADDR
// uc_nation := nation ;
25365: LD_ADDR_OWVAR 21
25369: PUSH
25370: LD_VAR 0 17
25374: ST_TO_ADDR
// if buildings then
25375: LD_VAR 0 18
25379: IFFALSE 26701
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25381: LD_ADDR_VAR 0 19
25385: PUSH
25386: LD_VAR 0 18
25390: PPUSH
25391: LD_INT 2
25393: PUSH
25394: LD_INT 30
25396: PUSH
25397: LD_INT 29
25399: PUSH
25400: EMPTY
25401: LIST
25402: LIST
25403: PUSH
25404: LD_INT 30
25406: PUSH
25407: LD_INT 30
25409: PUSH
25410: EMPTY
25411: LIST
25412: LIST
25413: PUSH
25414: EMPTY
25415: LIST
25416: LIST
25417: LIST
25418: PPUSH
25419: CALL_OW 72
25423: ST_TO_ADDR
// if tmp then
25424: LD_VAR 0 19
25428: IFFALSE 25476
// for i in tmp do
25430: LD_ADDR_VAR 0 8
25434: PUSH
25435: LD_VAR 0 19
25439: PUSH
25440: FOR_IN
25441: IFFALSE 25474
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
25443: LD_VAR 0 8
25447: PPUSH
25448: CALL_OW 250
25452: PPUSH
25453: LD_VAR 0 8
25457: PPUSH
25458: CALL_OW 251
25462: PPUSH
25463: LD_VAR 0 16
25467: PPUSH
25468: CALL_OW 441
25472: GO 25440
25474: POP
25475: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
25476: LD_VAR 0 18
25480: PPUSH
25481: LD_INT 2
25483: PUSH
25484: LD_INT 30
25486: PUSH
25487: LD_INT 32
25489: PUSH
25490: EMPTY
25491: LIST
25492: LIST
25493: PUSH
25494: LD_INT 30
25496: PUSH
25497: LD_INT 33
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: PUSH
25504: EMPTY
25505: LIST
25506: LIST
25507: LIST
25508: PPUSH
25509: CALL_OW 72
25513: IFFALSE 25601
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25515: LD_ADDR_VAR 0 8
25519: PUSH
25520: LD_VAR 0 18
25524: PPUSH
25525: LD_INT 2
25527: PUSH
25528: LD_INT 30
25530: PUSH
25531: LD_INT 32
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: PUSH
25538: LD_INT 30
25540: PUSH
25541: LD_INT 33
25543: PUSH
25544: EMPTY
25545: LIST
25546: LIST
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: LIST
25552: PPUSH
25553: CALL_OW 72
25557: PUSH
25558: FOR_IN
25559: IFFALSE 25599
// begin if not GetBWeapon ( i ) then
25561: LD_VAR 0 8
25565: PPUSH
25566: CALL_OW 269
25570: NOT
25571: IFFALSE 25597
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25573: LD_VAR 0 8
25577: PPUSH
25578: LD_VAR 0 8
25582: PPUSH
25583: LD_VAR 0 2
25587: PPUSH
25588: CALL 26847 0 2
25592: PPUSH
25593: CALL_OW 431
// end ;
25597: GO 25558
25599: POP
25600: POP
// end ; for i = 1 to personel do
25601: LD_ADDR_VAR 0 8
25605: PUSH
25606: DOUBLE
25607: LD_INT 1
25609: DEC
25610: ST_TO_ADDR
25611: LD_VAR 0 6
25615: PUSH
25616: FOR_TO
25617: IFFALSE 26681
// begin if i > 4 then
25619: LD_VAR 0 8
25623: PUSH
25624: LD_INT 4
25626: GREATER
25627: IFFALSE 25631
// break ;
25629: GO 26681
// case i of 1 :
25631: LD_VAR 0 8
25635: PUSH
25636: LD_INT 1
25638: DOUBLE
25639: EQUAL
25640: IFTRUE 25644
25642: GO 25724
25644: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25645: LD_ADDR_VAR 0 12
25649: PUSH
25650: LD_VAR 0 18
25654: PPUSH
25655: LD_INT 22
25657: PUSH
25658: LD_VAR 0 16
25662: PUSH
25663: EMPTY
25664: LIST
25665: LIST
25666: PUSH
25667: LD_INT 58
25669: PUSH
25670: EMPTY
25671: LIST
25672: PUSH
25673: LD_INT 2
25675: PUSH
25676: LD_INT 30
25678: PUSH
25679: LD_INT 32
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: PUSH
25686: LD_INT 30
25688: PUSH
25689: LD_INT 4
25691: PUSH
25692: EMPTY
25693: LIST
25694: LIST
25695: PUSH
25696: LD_INT 30
25698: PUSH
25699: LD_INT 5
25701: PUSH
25702: EMPTY
25703: LIST
25704: LIST
25705: PUSH
25706: EMPTY
25707: LIST
25708: LIST
25709: LIST
25710: LIST
25711: PUSH
25712: EMPTY
25713: LIST
25714: LIST
25715: LIST
25716: PPUSH
25717: CALL_OW 72
25721: ST_TO_ADDR
25722: GO 25946
25724: LD_INT 2
25726: DOUBLE
25727: EQUAL
25728: IFTRUE 25732
25730: GO 25794
25732: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25733: LD_ADDR_VAR 0 12
25737: PUSH
25738: LD_VAR 0 18
25742: PPUSH
25743: LD_INT 22
25745: PUSH
25746: LD_VAR 0 16
25750: PUSH
25751: EMPTY
25752: LIST
25753: LIST
25754: PUSH
25755: LD_INT 2
25757: PUSH
25758: LD_INT 30
25760: PUSH
25761: LD_INT 0
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: PUSH
25768: LD_INT 30
25770: PUSH
25771: LD_INT 1
25773: PUSH
25774: EMPTY
25775: LIST
25776: LIST
25777: PUSH
25778: EMPTY
25779: LIST
25780: LIST
25781: LIST
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: PPUSH
25787: CALL_OW 72
25791: ST_TO_ADDR
25792: GO 25946
25794: LD_INT 3
25796: DOUBLE
25797: EQUAL
25798: IFTRUE 25802
25800: GO 25864
25802: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25803: LD_ADDR_VAR 0 12
25807: PUSH
25808: LD_VAR 0 18
25812: PPUSH
25813: LD_INT 22
25815: PUSH
25816: LD_VAR 0 16
25820: PUSH
25821: EMPTY
25822: LIST
25823: LIST
25824: PUSH
25825: LD_INT 2
25827: PUSH
25828: LD_INT 30
25830: PUSH
25831: LD_INT 2
25833: PUSH
25834: EMPTY
25835: LIST
25836: LIST
25837: PUSH
25838: LD_INT 30
25840: PUSH
25841: LD_INT 3
25843: PUSH
25844: EMPTY
25845: LIST
25846: LIST
25847: PUSH
25848: EMPTY
25849: LIST
25850: LIST
25851: LIST
25852: PUSH
25853: EMPTY
25854: LIST
25855: LIST
25856: PPUSH
25857: CALL_OW 72
25861: ST_TO_ADDR
25862: GO 25946
25864: LD_INT 4
25866: DOUBLE
25867: EQUAL
25868: IFTRUE 25872
25870: GO 25945
25872: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25873: LD_ADDR_VAR 0 12
25877: PUSH
25878: LD_VAR 0 18
25882: PPUSH
25883: LD_INT 22
25885: PUSH
25886: LD_VAR 0 16
25890: PUSH
25891: EMPTY
25892: LIST
25893: LIST
25894: PUSH
25895: LD_INT 2
25897: PUSH
25898: LD_INT 30
25900: PUSH
25901: LD_INT 6
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: PUSH
25908: LD_INT 30
25910: PUSH
25911: LD_INT 7
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: PUSH
25918: LD_INT 30
25920: PUSH
25921: LD_INT 8
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: PUSH
25928: EMPTY
25929: LIST
25930: LIST
25931: LIST
25932: LIST
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PPUSH
25938: CALL_OW 72
25942: ST_TO_ADDR
25943: GO 25946
25945: POP
// if i = 1 then
25946: LD_VAR 0 8
25950: PUSH
25951: LD_INT 1
25953: EQUAL
25954: IFFALSE 26065
// begin tmp := [ ] ;
25956: LD_ADDR_VAR 0 19
25960: PUSH
25961: EMPTY
25962: ST_TO_ADDR
// for j in f do
25963: LD_ADDR_VAR 0 9
25967: PUSH
25968: LD_VAR 0 12
25972: PUSH
25973: FOR_IN
25974: IFFALSE 26047
// if GetBType ( j ) = b_bunker then
25976: LD_VAR 0 9
25980: PPUSH
25981: CALL_OW 266
25985: PUSH
25986: LD_INT 32
25988: EQUAL
25989: IFFALSE 26016
// tmp := Insert ( tmp , 1 , j ) else
25991: LD_ADDR_VAR 0 19
25995: PUSH
25996: LD_VAR 0 19
26000: PPUSH
26001: LD_INT 1
26003: PPUSH
26004: LD_VAR 0 9
26008: PPUSH
26009: CALL_OW 2
26013: ST_TO_ADDR
26014: GO 26045
// tmp := Insert ( tmp , tmp + 1 , j ) ;
26016: LD_ADDR_VAR 0 19
26020: PUSH
26021: LD_VAR 0 19
26025: PPUSH
26026: LD_VAR 0 19
26030: PUSH
26031: LD_INT 1
26033: PLUS
26034: PPUSH
26035: LD_VAR 0 9
26039: PPUSH
26040: CALL_OW 2
26044: ST_TO_ADDR
26045: GO 25973
26047: POP
26048: POP
// if tmp then
26049: LD_VAR 0 19
26053: IFFALSE 26065
// f := tmp ;
26055: LD_ADDR_VAR 0 12
26059: PUSH
26060: LD_VAR 0 19
26064: ST_TO_ADDR
// end ; x := personel [ i ] ;
26065: LD_ADDR_VAR 0 13
26069: PUSH
26070: LD_VAR 0 6
26074: PUSH
26075: LD_VAR 0 8
26079: ARRAY
26080: ST_TO_ADDR
// if x = - 1 then
26081: LD_VAR 0 13
26085: PUSH
26086: LD_INT 1
26088: NEG
26089: EQUAL
26090: IFFALSE 26299
// begin for j in f do
26092: LD_ADDR_VAR 0 9
26096: PUSH
26097: LD_VAR 0 12
26101: PUSH
26102: FOR_IN
26103: IFFALSE 26295
// repeat InitHc ;
26105: CALL_OW 19
// if GetBType ( j ) = b_barracks then
26109: LD_VAR 0 9
26113: PPUSH
26114: CALL_OW 266
26118: PUSH
26119: LD_INT 5
26121: EQUAL
26122: IFFALSE 26192
// begin if UnitsInside ( j ) < 3 then
26124: LD_VAR 0 9
26128: PPUSH
26129: CALL_OW 313
26133: PUSH
26134: LD_INT 3
26136: LESS
26137: IFFALSE 26173
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26139: LD_INT 0
26141: PPUSH
26142: LD_INT 5
26144: PUSH
26145: LD_INT 8
26147: PUSH
26148: LD_INT 9
26150: PUSH
26151: EMPTY
26152: LIST
26153: LIST
26154: LIST
26155: PUSH
26156: LD_VAR 0 17
26160: ARRAY
26161: PPUSH
26162: LD_VAR 0 4
26166: PPUSH
26167: CALL_OW 380
26171: GO 26190
// PrepareHuman ( false , i , skill ) ;
26173: LD_INT 0
26175: PPUSH
26176: LD_VAR 0 8
26180: PPUSH
26181: LD_VAR 0 4
26185: PPUSH
26186: CALL_OW 380
// end else
26190: GO 26209
// PrepareHuman ( false , i , skill ) ;
26192: LD_INT 0
26194: PPUSH
26195: LD_VAR 0 8
26199: PPUSH
26200: LD_VAR 0 4
26204: PPUSH
26205: CALL_OW 380
// un := CreateHuman ;
26209: LD_ADDR_VAR 0 14
26213: PUSH
26214: CALL_OW 44
26218: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26219: LD_ADDR_VAR 0 7
26223: PUSH
26224: LD_VAR 0 7
26228: PPUSH
26229: LD_INT 1
26231: PPUSH
26232: LD_VAR 0 14
26236: PPUSH
26237: CALL_OW 2
26241: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
26242: LD_VAR 0 14
26246: PPUSH
26247: LD_VAR 0 9
26251: PPUSH
26252: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
26256: LD_VAR 0 9
26260: PPUSH
26261: CALL_OW 313
26265: PUSH
26266: LD_INT 6
26268: EQUAL
26269: PUSH
26270: LD_VAR 0 9
26274: PPUSH
26275: CALL_OW 266
26279: PUSH
26280: LD_INT 32
26282: PUSH
26283: LD_INT 31
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: IN
26290: OR
26291: IFFALSE 26105
26293: GO 26102
26295: POP
26296: POP
// end else
26297: GO 26679
// for j = 1 to x do
26299: LD_ADDR_VAR 0 9
26303: PUSH
26304: DOUBLE
26305: LD_INT 1
26307: DEC
26308: ST_TO_ADDR
26309: LD_VAR 0 13
26313: PUSH
26314: FOR_TO
26315: IFFALSE 26677
// begin InitHc ;
26317: CALL_OW 19
// if not f then
26321: LD_VAR 0 12
26325: NOT
26326: IFFALSE 26415
// begin PrepareHuman ( false , i , skill ) ;
26328: LD_INT 0
26330: PPUSH
26331: LD_VAR 0 8
26335: PPUSH
26336: LD_VAR 0 4
26340: PPUSH
26341: CALL_OW 380
// un := CreateHuman ;
26345: LD_ADDR_VAR 0 14
26349: PUSH
26350: CALL_OW 44
26354: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26355: LD_ADDR_VAR 0 7
26359: PUSH
26360: LD_VAR 0 7
26364: PPUSH
26365: LD_INT 1
26367: PPUSH
26368: LD_VAR 0 14
26372: PPUSH
26373: CALL_OW 2
26377: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26378: LD_VAR 0 14
26382: PPUSH
26383: LD_VAR 0 1
26387: PPUSH
26388: CALL_OW 250
26392: PPUSH
26393: LD_VAR 0 1
26397: PPUSH
26398: CALL_OW 251
26402: PPUSH
26403: LD_INT 10
26405: PPUSH
26406: LD_INT 0
26408: PPUSH
26409: CALL_OW 50
// continue ;
26413: GO 26314
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26415: LD_VAR 0 12
26419: PUSH
26420: LD_INT 1
26422: ARRAY
26423: PPUSH
26424: CALL_OW 313
26428: PUSH
26429: LD_VAR 0 12
26433: PUSH
26434: LD_INT 1
26436: ARRAY
26437: PPUSH
26438: CALL_OW 266
26442: PUSH
26443: LD_INT 32
26445: PUSH
26446: LD_INT 31
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: IN
26453: AND
26454: PUSH
26455: LD_VAR 0 12
26459: PUSH
26460: LD_INT 1
26462: ARRAY
26463: PPUSH
26464: CALL_OW 313
26468: PUSH
26469: LD_INT 6
26471: EQUAL
26472: OR
26473: IFFALSE 26493
// f := Delete ( f , 1 ) ;
26475: LD_ADDR_VAR 0 12
26479: PUSH
26480: LD_VAR 0 12
26484: PPUSH
26485: LD_INT 1
26487: PPUSH
26488: CALL_OW 3
26492: ST_TO_ADDR
// if not f then
26493: LD_VAR 0 12
26497: NOT
26498: IFFALSE 26516
// begin x := x + 2 ;
26500: LD_ADDR_VAR 0 13
26504: PUSH
26505: LD_VAR 0 13
26509: PUSH
26510: LD_INT 2
26512: PLUS
26513: ST_TO_ADDR
// continue ;
26514: GO 26314
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26516: LD_VAR 0 12
26520: PUSH
26521: LD_INT 1
26523: ARRAY
26524: PPUSH
26525: CALL_OW 266
26529: PUSH
26530: LD_INT 5
26532: EQUAL
26533: IFFALSE 26607
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26535: LD_VAR 0 12
26539: PUSH
26540: LD_INT 1
26542: ARRAY
26543: PPUSH
26544: CALL_OW 313
26548: PUSH
26549: LD_INT 3
26551: LESS
26552: IFFALSE 26588
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26554: LD_INT 0
26556: PPUSH
26557: LD_INT 5
26559: PUSH
26560: LD_INT 8
26562: PUSH
26563: LD_INT 9
26565: PUSH
26566: EMPTY
26567: LIST
26568: LIST
26569: LIST
26570: PUSH
26571: LD_VAR 0 17
26575: ARRAY
26576: PPUSH
26577: LD_VAR 0 4
26581: PPUSH
26582: CALL_OW 380
26586: GO 26605
// PrepareHuman ( false , i , skill ) ;
26588: LD_INT 0
26590: PPUSH
26591: LD_VAR 0 8
26595: PPUSH
26596: LD_VAR 0 4
26600: PPUSH
26601: CALL_OW 380
// end else
26605: GO 26624
// PrepareHuman ( false , i , skill ) ;
26607: LD_INT 0
26609: PPUSH
26610: LD_VAR 0 8
26614: PPUSH
26615: LD_VAR 0 4
26619: PPUSH
26620: CALL_OW 380
// un := CreateHuman ;
26624: LD_ADDR_VAR 0 14
26628: PUSH
26629: CALL_OW 44
26633: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26634: LD_ADDR_VAR 0 7
26638: PUSH
26639: LD_VAR 0 7
26643: PPUSH
26644: LD_INT 1
26646: PPUSH
26647: LD_VAR 0 14
26651: PPUSH
26652: CALL_OW 2
26656: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26657: LD_VAR 0 14
26661: PPUSH
26662: LD_VAR 0 12
26666: PUSH
26667: LD_INT 1
26669: ARRAY
26670: PPUSH
26671: CALL_OW 52
// end ;
26675: GO 26314
26677: POP
26678: POP
// end ;
26679: GO 25616
26681: POP
26682: POP
// result := result ^ buildings ;
26683: LD_ADDR_VAR 0 7
26687: PUSH
26688: LD_VAR 0 7
26692: PUSH
26693: LD_VAR 0 18
26697: ADD
26698: ST_TO_ADDR
// end else
26699: GO 26842
// begin for i = 1 to personel do
26701: LD_ADDR_VAR 0 8
26705: PUSH
26706: DOUBLE
26707: LD_INT 1
26709: DEC
26710: ST_TO_ADDR
26711: LD_VAR 0 6
26715: PUSH
26716: FOR_TO
26717: IFFALSE 26840
// begin if i > 4 then
26719: LD_VAR 0 8
26723: PUSH
26724: LD_INT 4
26726: GREATER
26727: IFFALSE 26731
// break ;
26729: GO 26840
// x := personel [ i ] ;
26731: LD_ADDR_VAR 0 13
26735: PUSH
26736: LD_VAR 0 6
26740: PUSH
26741: LD_VAR 0 8
26745: ARRAY
26746: ST_TO_ADDR
// if x = - 1 then
26747: LD_VAR 0 13
26751: PUSH
26752: LD_INT 1
26754: NEG
26755: EQUAL
26756: IFFALSE 26760
// continue ;
26758: GO 26716
// PrepareHuman ( false , i , skill ) ;
26760: LD_INT 0
26762: PPUSH
26763: LD_VAR 0 8
26767: PPUSH
26768: LD_VAR 0 4
26772: PPUSH
26773: CALL_OW 380
// un := CreateHuman ;
26777: LD_ADDR_VAR 0 14
26781: PUSH
26782: CALL_OW 44
26786: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26787: LD_VAR 0 14
26791: PPUSH
26792: LD_VAR 0 1
26796: PPUSH
26797: CALL_OW 250
26801: PPUSH
26802: LD_VAR 0 1
26806: PPUSH
26807: CALL_OW 251
26811: PPUSH
26812: LD_INT 10
26814: PPUSH
26815: LD_INT 0
26817: PPUSH
26818: CALL_OW 50
// result := result ^ un ;
26822: LD_ADDR_VAR 0 7
26826: PUSH
26827: LD_VAR 0 7
26831: PUSH
26832: LD_VAR 0 14
26836: ADD
26837: ST_TO_ADDR
// end ;
26838: GO 26716
26840: POP
26841: POP
// end ; end ;
26842: LD_VAR 0 7
26846: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26847: LD_INT 0
26849: PPUSH
26850: PPUSH
26851: PPUSH
26852: PPUSH
26853: PPUSH
26854: PPUSH
26855: PPUSH
26856: PPUSH
26857: PPUSH
26858: PPUSH
26859: PPUSH
26860: PPUSH
26861: PPUSH
26862: PPUSH
26863: PPUSH
26864: PPUSH
// result := false ;
26865: LD_ADDR_VAR 0 3
26869: PUSH
26870: LD_INT 0
26872: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26873: LD_VAR 0 1
26877: NOT
26878: PUSH
26879: LD_VAR 0 1
26883: PPUSH
26884: CALL_OW 266
26888: PUSH
26889: LD_INT 32
26891: PUSH
26892: LD_INT 33
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: IN
26899: NOT
26900: OR
26901: IFFALSE 26905
// exit ;
26903: GO 28014
// nat := GetNation ( tower ) ;
26905: LD_ADDR_VAR 0 12
26909: PUSH
26910: LD_VAR 0 1
26914: PPUSH
26915: CALL_OW 248
26919: ST_TO_ADDR
// side := GetSide ( tower ) ;
26920: LD_ADDR_VAR 0 16
26924: PUSH
26925: LD_VAR 0 1
26929: PPUSH
26930: CALL_OW 255
26934: ST_TO_ADDR
// x := GetX ( tower ) ;
26935: LD_ADDR_VAR 0 10
26939: PUSH
26940: LD_VAR 0 1
26944: PPUSH
26945: CALL_OW 250
26949: ST_TO_ADDR
// y := GetY ( tower ) ;
26950: LD_ADDR_VAR 0 11
26954: PUSH
26955: LD_VAR 0 1
26959: PPUSH
26960: CALL_OW 251
26964: ST_TO_ADDR
// if not x or not y then
26965: LD_VAR 0 10
26969: NOT
26970: PUSH
26971: LD_VAR 0 11
26975: NOT
26976: OR
26977: IFFALSE 26981
// exit ;
26979: GO 28014
// weapon := 0 ;
26981: LD_ADDR_VAR 0 18
26985: PUSH
26986: LD_INT 0
26988: ST_TO_ADDR
// fac_list := [ ] ;
26989: LD_ADDR_VAR 0 17
26993: PUSH
26994: EMPTY
26995: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
26996: LD_ADDR_VAR 0 6
27000: PUSH
27001: LD_VAR 0 1
27005: PPUSH
27006: CALL_OW 274
27010: PPUSH
27011: LD_VAR 0 2
27015: PPUSH
27016: LD_INT 0
27018: PPUSH
27019: CALL 24585 0 3
27023: PPUSH
27024: LD_INT 30
27026: PUSH
27027: LD_INT 3
27029: PUSH
27030: EMPTY
27031: LIST
27032: LIST
27033: PPUSH
27034: CALL_OW 72
27038: ST_TO_ADDR
// if not factories then
27039: LD_VAR 0 6
27043: NOT
27044: IFFALSE 27048
// exit ;
27046: GO 28014
// for i in factories do
27048: LD_ADDR_VAR 0 8
27052: PUSH
27053: LD_VAR 0 6
27057: PUSH
27058: FOR_IN
27059: IFFALSE 27084
// fac_list := fac_list union AvailableWeaponList ( i ) ;
27061: LD_ADDR_VAR 0 17
27065: PUSH
27066: LD_VAR 0 17
27070: PUSH
27071: LD_VAR 0 8
27075: PPUSH
27076: CALL_OW 478
27080: UNION
27081: ST_TO_ADDR
27082: GO 27058
27084: POP
27085: POP
// if not fac_list then
27086: LD_VAR 0 17
27090: NOT
27091: IFFALSE 27095
// exit ;
27093: GO 28014
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
27095: LD_ADDR_VAR 0 5
27099: PUSH
27100: LD_INT 4
27102: PUSH
27103: LD_INT 5
27105: PUSH
27106: LD_INT 9
27108: PUSH
27109: LD_INT 10
27111: PUSH
27112: LD_INT 6
27114: PUSH
27115: LD_INT 7
27117: PUSH
27118: LD_INT 11
27120: PUSH
27121: EMPTY
27122: LIST
27123: LIST
27124: LIST
27125: LIST
27126: LIST
27127: LIST
27128: LIST
27129: PUSH
27130: LD_INT 27
27132: PUSH
27133: LD_INT 28
27135: PUSH
27136: LD_INT 26
27138: PUSH
27139: LD_INT 30
27141: PUSH
27142: EMPTY
27143: LIST
27144: LIST
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 43
27150: PUSH
27151: LD_INT 44
27153: PUSH
27154: LD_INT 46
27156: PUSH
27157: LD_INT 45
27159: PUSH
27160: LD_INT 47
27162: PUSH
27163: LD_INT 49
27165: PUSH
27166: EMPTY
27167: LIST
27168: LIST
27169: LIST
27170: LIST
27171: LIST
27172: LIST
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: LIST
27178: PUSH
27179: LD_VAR 0 12
27183: ARRAY
27184: ST_TO_ADDR
// list := list isect fac_list ;
27185: LD_ADDR_VAR 0 5
27189: PUSH
27190: LD_VAR 0 5
27194: PUSH
27195: LD_VAR 0 17
27199: ISECT
27200: ST_TO_ADDR
// if not list then
27201: LD_VAR 0 5
27205: NOT
27206: IFFALSE 27210
// exit ;
27208: GO 28014
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
27210: LD_VAR 0 12
27214: PUSH
27215: LD_INT 3
27217: EQUAL
27218: PUSH
27219: LD_INT 49
27221: PUSH
27222: LD_VAR 0 5
27226: IN
27227: AND
27228: PUSH
27229: LD_INT 31
27231: PPUSH
27232: LD_VAR 0 16
27236: PPUSH
27237: CALL_OW 321
27241: PUSH
27242: LD_INT 2
27244: EQUAL
27245: AND
27246: IFFALSE 27306
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
27248: LD_INT 22
27250: PUSH
27251: LD_VAR 0 16
27255: PUSH
27256: EMPTY
27257: LIST
27258: LIST
27259: PUSH
27260: LD_INT 35
27262: PUSH
27263: LD_INT 49
27265: PUSH
27266: EMPTY
27267: LIST
27268: LIST
27269: PUSH
27270: LD_INT 91
27272: PUSH
27273: LD_VAR 0 1
27277: PUSH
27278: LD_INT 10
27280: PUSH
27281: EMPTY
27282: LIST
27283: LIST
27284: LIST
27285: PUSH
27286: EMPTY
27287: LIST
27288: LIST
27289: LIST
27290: PPUSH
27291: CALL_OW 69
27295: NOT
27296: IFFALSE 27306
// weapon := ru_time_lapser ;
27298: LD_ADDR_VAR 0 18
27302: PUSH
27303: LD_INT 49
27305: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
27306: LD_VAR 0 12
27310: PUSH
27311: LD_INT 1
27313: PUSH
27314: LD_INT 2
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: IN
27321: PUSH
27322: LD_INT 11
27324: PUSH
27325: LD_VAR 0 5
27329: IN
27330: PUSH
27331: LD_INT 30
27333: PUSH
27334: LD_VAR 0 5
27338: IN
27339: OR
27340: AND
27341: PUSH
27342: LD_INT 6
27344: PPUSH
27345: LD_VAR 0 16
27349: PPUSH
27350: CALL_OW 321
27354: PUSH
27355: LD_INT 2
27357: EQUAL
27358: AND
27359: IFFALSE 27524
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27361: LD_INT 22
27363: PUSH
27364: LD_VAR 0 16
27368: PUSH
27369: EMPTY
27370: LIST
27371: LIST
27372: PUSH
27373: LD_INT 2
27375: PUSH
27376: LD_INT 35
27378: PUSH
27379: LD_INT 11
27381: PUSH
27382: EMPTY
27383: LIST
27384: LIST
27385: PUSH
27386: LD_INT 35
27388: PUSH
27389: LD_INT 30
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: PUSH
27396: EMPTY
27397: LIST
27398: LIST
27399: LIST
27400: PUSH
27401: LD_INT 91
27403: PUSH
27404: LD_VAR 0 1
27408: PUSH
27409: LD_INT 18
27411: PUSH
27412: EMPTY
27413: LIST
27414: LIST
27415: LIST
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: LIST
27421: PPUSH
27422: CALL_OW 69
27426: NOT
27427: PUSH
27428: LD_INT 22
27430: PUSH
27431: LD_VAR 0 16
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 2
27442: PUSH
27443: LD_INT 30
27445: PUSH
27446: LD_INT 32
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: LD_INT 30
27455: PUSH
27456: LD_INT 33
27458: PUSH
27459: EMPTY
27460: LIST
27461: LIST
27462: PUSH
27463: EMPTY
27464: LIST
27465: LIST
27466: LIST
27467: PUSH
27468: LD_INT 91
27470: PUSH
27471: LD_VAR 0 1
27475: PUSH
27476: LD_INT 12
27478: PUSH
27479: EMPTY
27480: LIST
27481: LIST
27482: LIST
27483: PUSH
27484: EMPTY
27485: LIST
27486: LIST
27487: LIST
27488: PUSH
27489: EMPTY
27490: LIST
27491: PPUSH
27492: CALL_OW 69
27496: PUSH
27497: LD_INT 2
27499: GREATER
27500: AND
27501: IFFALSE 27524
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27503: LD_ADDR_VAR 0 18
27507: PUSH
27508: LD_INT 11
27510: PUSH
27511: LD_INT 30
27513: PUSH
27514: EMPTY
27515: LIST
27516: LIST
27517: PUSH
27518: LD_VAR 0 12
27522: ARRAY
27523: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27524: LD_VAR 0 18
27528: NOT
27529: PUSH
27530: LD_INT 40
27532: PPUSH
27533: LD_VAR 0 16
27537: PPUSH
27538: CALL_OW 321
27542: PUSH
27543: LD_INT 2
27545: EQUAL
27546: AND
27547: PUSH
27548: LD_INT 7
27550: PUSH
27551: LD_VAR 0 5
27555: IN
27556: PUSH
27557: LD_INT 28
27559: PUSH
27560: LD_VAR 0 5
27564: IN
27565: OR
27566: PUSH
27567: LD_INT 45
27569: PUSH
27570: LD_VAR 0 5
27574: IN
27575: OR
27576: AND
27577: IFFALSE 27831
// begin hex := GetHexInfo ( x , y ) ;
27579: LD_ADDR_VAR 0 4
27583: PUSH
27584: LD_VAR 0 10
27588: PPUSH
27589: LD_VAR 0 11
27593: PPUSH
27594: CALL_OW 546
27598: ST_TO_ADDR
// if hex [ 1 ] then
27599: LD_VAR 0 4
27603: PUSH
27604: LD_INT 1
27606: ARRAY
27607: IFFALSE 27611
// exit ;
27609: GO 28014
// height := hex [ 2 ] ;
27611: LD_ADDR_VAR 0 15
27615: PUSH
27616: LD_VAR 0 4
27620: PUSH
27621: LD_INT 2
27623: ARRAY
27624: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27625: LD_ADDR_VAR 0 14
27629: PUSH
27630: LD_INT 0
27632: PUSH
27633: LD_INT 2
27635: PUSH
27636: LD_INT 3
27638: PUSH
27639: LD_INT 5
27641: PUSH
27642: EMPTY
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: ST_TO_ADDR
// for i in tmp do
27648: LD_ADDR_VAR 0 8
27652: PUSH
27653: LD_VAR 0 14
27657: PUSH
27658: FOR_IN
27659: IFFALSE 27829
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27661: LD_ADDR_VAR 0 9
27665: PUSH
27666: LD_VAR 0 10
27670: PPUSH
27671: LD_VAR 0 8
27675: PPUSH
27676: LD_INT 5
27678: PPUSH
27679: CALL_OW 272
27683: PUSH
27684: LD_VAR 0 11
27688: PPUSH
27689: LD_VAR 0 8
27693: PPUSH
27694: LD_INT 5
27696: PPUSH
27697: CALL_OW 273
27701: PUSH
27702: EMPTY
27703: LIST
27704: LIST
27705: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27706: LD_VAR 0 9
27710: PUSH
27711: LD_INT 1
27713: ARRAY
27714: PPUSH
27715: LD_VAR 0 9
27719: PUSH
27720: LD_INT 2
27722: ARRAY
27723: PPUSH
27724: CALL_OW 488
27728: IFFALSE 27827
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27730: LD_ADDR_VAR 0 4
27734: PUSH
27735: LD_VAR 0 9
27739: PUSH
27740: LD_INT 1
27742: ARRAY
27743: PPUSH
27744: LD_VAR 0 9
27748: PUSH
27749: LD_INT 2
27751: ARRAY
27752: PPUSH
27753: CALL_OW 546
27757: ST_TO_ADDR
// if hex [ 1 ] then
27758: LD_VAR 0 4
27762: PUSH
27763: LD_INT 1
27765: ARRAY
27766: IFFALSE 27770
// continue ;
27768: GO 27658
// h := hex [ 2 ] ;
27770: LD_ADDR_VAR 0 13
27774: PUSH
27775: LD_VAR 0 4
27779: PUSH
27780: LD_INT 2
27782: ARRAY
27783: ST_TO_ADDR
// if h + 7 < height then
27784: LD_VAR 0 13
27788: PUSH
27789: LD_INT 7
27791: PLUS
27792: PUSH
27793: LD_VAR 0 15
27797: LESS
27798: IFFALSE 27827
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27800: LD_ADDR_VAR 0 18
27804: PUSH
27805: LD_INT 7
27807: PUSH
27808: LD_INT 28
27810: PUSH
27811: LD_INT 45
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: LIST
27818: PUSH
27819: LD_VAR 0 12
27823: ARRAY
27824: ST_TO_ADDR
// break ;
27825: GO 27829
// end ; end ; end ;
27827: GO 27658
27829: POP
27830: POP
// end ; if not weapon then
27831: LD_VAR 0 18
27835: NOT
27836: IFFALSE 27896
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27838: LD_ADDR_VAR 0 5
27842: PUSH
27843: LD_VAR 0 5
27847: PUSH
27848: LD_INT 11
27850: PUSH
27851: LD_INT 30
27853: PUSH
27854: LD_INT 49
27856: PUSH
27857: EMPTY
27858: LIST
27859: LIST
27860: LIST
27861: DIFF
27862: ST_TO_ADDR
// if not list then
27863: LD_VAR 0 5
27867: NOT
27868: IFFALSE 27872
// exit ;
27870: GO 28014
// weapon := list [ rand ( 1 , list ) ] ;
27872: LD_ADDR_VAR 0 18
27876: PUSH
27877: LD_VAR 0 5
27881: PUSH
27882: LD_INT 1
27884: PPUSH
27885: LD_VAR 0 5
27889: PPUSH
27890: CALL_OW 12
27894: ARRAY
27895: ST_TO_ADDR
// end ; if weapon then
27896: LD_VAR 0 18
27900: IFFALSE 28014
// begin tmp := CostOfWeapon ( weapon ) ;
27902: LD_ADDR_VAR 0 14
27906: PUSH
27907: LD_VAR 0 18
27911: PPUSH
27912: CALL_OW 451
27916: ST_TO_ADDR
// j := GetBase ( tower ) ;
27917: LD_ADDR_VAR 0 9
27921: PUSH
27922: LD_VAR 0 1
27926: PPUSH
27927: CALL_OW 274
27931: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27932: LD_VAR 0 9
27936: PPUSH
27937: LD_INT 1
27939: PPUSH
27940: CALL_OW 275
27944: PUSH
27945: LD_VAR 0 14
27949: PUSH
27950: LD_INT 1
27952: ARRAY
27953: GREATEREQUAL
27954: PUSH
27955: LD_VAR 0 9
27959: PPUSH
27960: LD_INT 2
27962: PPUSH
27963: CALL_OW 275
27967: PUSH
27968: LD_VAR 0 14
27972: PUSH
27973: LD_INT 2
27975: ARRAY
27976: GREATEREQUAL
27977: AND
27978: PUSH
27979: LD_VAR 0 9
27983: PPUSH
27984: LD_INT 3
27986: PPUSH
27987: CALL_OW 275
27991: PUSH
27992: LD_VAR 0 14
27996: PUSH
27997: LD_INT 3
27999: ARRAY
28000: GREATEREQUAL
28001: AND
28002: IFFALSE 28014
// result := weapon ;
28004: LD_ADDR_VAR 0 3
28008: PUSH
28009: LD_VAR 0 18
28013: ST_TO_ADDR
// end ; end ;
28014: LD_VAR 0 3
28018: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
28019: LD_INT 0
28021: PPUSH
28022: PPUSH
// result := true ;
28023: LD_ADDR_VAR 0 3
28027: PUSH
28028: LD_INT 1
28030: ST_TO_ADDR
// if array1 = array2 then
28031: LD_VAR 0 1
28035: PUSH
28036: LD_VAR 0 2
28040: EQUAL
28041: IFFALSE 28101
// begin for i = 1 to array1 do
28043: LD_ADDR_VAR 0 4
28047: PUSH
28048: DOUBLE
28049: LD_INT 1
28051: DEC
28052: ST_TO_ADDR
28053: LD_VAR 0 1
28057: PUSH
28058: FOR_TO
28059: IFFALSE 28097
// if array1 [ i ] <> array2 [ i ] then
28061: LD_VAR 0 1
28065: PUSH
28066: LD_VAR 0 4
28070: ARRAY
28071: PUSH
28072: LD_VAR 0 2
28076: PUSH
28077: LD_VAR 0 4
28081: ARRAY
28082: NONEQUAL
28083: IFFALSE 28095
// begin result := false ;
28085: LD_ADDR_VAR 0 3
28089: PUSH
28090: LD_INT 0
28092: ST_TO_ADDR
// break ;
28093: GO 28097
// end ;
28095: GO 28058
28097: POP
28098: POP
// end else
28099: GO 28109
// result := false ;
28101: LD_ADDR_VAR 0 3
28105: PUSH
28106: LD_INT 0
28108: ST_TO_ADDR
// end ;
28109: LD_VAR 0 3
28113: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
28114: LD_INT 0
28116: PPUSH
28117: PPUSH
// if not array1 or not array2 then
28118: LD_VAR 0 1
28122: NOT
28123: PUSH
28124: LD_VAR 0 2
28128: NOT
28129: OR
28130: IFFALSE 28134
// exit ;
28132: GO 28198
// result := true ;
28134: LD_ADDR_VAR 0 3
28138: PUSH
28139: LD_INT 1
28141: ST_TO_ADDR
// for i = 1 to array1 do
28142: LD_ADDR_VAR 0 4
28146: PUSH
28147: DOUBLE
28148: LD_INT 1
28150: DEC
28151: ST_TO_ADDR
28152: LD_VAR 0 1
28156: PUSH
28157: FOR_TO
28158: IFFALSE 28196
// if array1 [ i ] <> array2 [ i ] then
28160: LD_VAR 0 1
28164: PUSH
28165: LD_VAR 0 4
28169: ARRAY
28170: PUSH
28171: LD_VAR 0 2
28175: PUSH
28176: LD_VAR 0 4
28180: ARRAY
28181: NONEQUAL
28182: IFFALSE 28194
// begin result := false ;
28184: LD_ADDR_VAR 0 3
28188: PUSH
28189: LD_INT 0
28191: ST_TO_ADDR
// break ;
28192: GO 28196
// end ;
28194: GO 28157
28196: POP
28197: POP
// end ;
28198: LD_VAR 0 3
28202: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
28203: LD_INT 0
28205: PPUSH
28206: PPUSH
28207: PPUSH
// pom := GetBase ( fac ) ;
28208: LD_ADDR_VAR 0 5
28212: PUSH
28213: LD_VAR 0 1
28217: PPUSH
28218: CALL_OW 274
28222: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
28223: LD_ADDR_VAR 0 4
28227: PUSH
28228: LD_VAR 0 2
28232: PUSH
28233: LD_INT 1
28235: ARRAY
28236: PPUSH
28237: LD_VAR 0 2
28241: PUSH
28242: LD_INT 2
28244: ARRAY
28245: PPUSH
28246: LD_VAR 0 2
28250: PUSH
28251: LD_INT 3
28253: ARRAY
28254: PPUSH
28255: LD_VAR 0 2
28259: PUSH
28260: LD_INT 4
28262: ARRAY
28263: PPUSH
28264: CALL_OW 449
28268: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28269: LD_ADDR_VAR 0 3
28273: PUSH
28274: LD_VAR 0 5
28278: PPUSH
28279: LD_INT 1
28281: PPUSH
28282: CALL_OW 275
28286: PUSH
28287: LD_VAR 0 4
28291: PUSH
28292: LD_INT 1
28294: ARRAY
28295: GREATEREQUAL
28296: PUSH
28297: LD_VAR 0 5
28301: PPUSH
28302: LD_INT 2
28304: PPUSH
28305: CALL_OW 275
28309: PUSH
28310: LD_VAR 0 4
28314: PUSH
28315: LD_INT 2
28317: ARRAY
28318: GREATEREQUAL
28319: AND
28320: PUSH
28321: LD_VAR 0 5
28325: PPUSH
28326: LD_INT 3
28328: PPUSH
28329: CALL_OW 275
28333: PUSH
28334: LD_VAR 0 4
28338: PUSH
28339: LD_INT 3
28341: ARRAY
28342: GREATEREQUAL
28343: AND
28344: ST_TO_ADDR
// end ;
28345: LD_VAR 0 3
28349: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
28350: LD_INT 0
28352: PPUSH
28353: PPUSH
28354: PPUSH
28355: PPUSH
// pom := GetBase ( building ) ;
28356: LD_ADDR_VAR 0 3
28360: PUSH
28361: LD_VAR 0 1
28365: PPUSH
28366: CALL_OW 274
28370: ST_TO_ADDR
// if not pom then
28371: LD_VAR 0 3
28375: NOT
28376: IFFALSE 28380
// exit ;
28378: GO 28550
// btype := GetBType ( building ) ;
28380: LD_ADDR_VAR 0 5
28384: PUSH
28385: LD_VAR 0 1
28389: PPUSH
28390: CALL_OW 266
28394: ST_TO_ADDR
// if btype = b_armoury then
28395: LD_VAR 0 5
28399: PUSH
28400: LD_INT 4
28402: EQUAL
28403: IFFALSE 28413
// btype := b_barracks ;
28405: LD_ADDR_VAR 0 5
28409: PUSH
28410: LD_INT 5
28412: ST_TO_ADDR
// if btype = b_depot then
28413: LD_VAR 0 5
28417: PUSH
28418: LD_INT 0
28420: EQUAL
28421: IFFALSE 28431
// btype := b_warehouse ;
28423: LD_ADDR_VAR 0 5
28427: PUSH
28428: LD_INT 1
28430: ST_TO_ADDR
// if btype = b_workshop then
28431: LD_VAR 0 5
28435: PUSH
28436: LD_INT 2
28438: EQUAL
28439: IFFALSE 28449
// btype := b_factory ;
28441: LD_ADDR_VAR 0 5
28445: PUSH
28446: LD_INT 3
28448: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28449: LD_ADDR_VAR 0 4
28453: PUSH
28454: LD_VAR 0 5
28458: PPUSH
28459: LD_VAR 0 1
28463: PPUSH
28464: CALL_OW 248
28468: PPUSH
28469: CALL_OW 450
28473: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28474: LD_ADDR_VAR 0 2
28478: PUSH
28479: LD_VAR 0 3
28483: PPUSH
28484: LD_INT 1
28486: PPUSH
28487: CALL_OW 275
28491: PUSH
28492: LD_VAR 0 4
28496: PUSH
28497: LD_INT 1
28499: ARRAY
28500: GREATEREQUAL
28501: PUSH
28502: LD_VAR 0 3
28506: PPUSH
28507: LD_INT 2
28509: PPUSH
28510: CALL_OW 275
28514: PUSH
28515: LD_VAR 0 4
28519: PUSH
28520: LD_INT 2
28522: ARRAY
28523: GREATEREQUAL
28524: AND
28525: PUSH
28526: LD_VAR 0 3
28530: PPUSH
28531: LD_INT 3
28533: PPUSH
28534: CALL_OW 275
28538: PUSH
28539: LD_VAR 0 4
28543: PUSH
28544: LD_INT 3
28546: ARRAY
28547: GREATEREQUAL
28548: AND
28549: ST_TO_ADDR
// end ;
28550: LD_VAR 0 2
28554: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28555: LD_INT 0
28557: PPUSH
28558: PPUSH
28559: PPUSH
// pom := GetBase ( building ) ;
28560: LD_ADDR_VAR 0 4
28564: PUSH
28565: LD_VAR 0 1
28569: PPUSH
28570: CALL_OW 274
28574: ST_TO_ADDR
// if not pom then
28575: LD_VAR 0 4
28579: NOT
28580: IFFALSE 28584
// exit ;
28582: GO 28685
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28584: LD_ADDR_VAR 0 5
28588: PUSH
28589: LD_VAR 0 2
28593: PPUSH
28594: LD_VAR 0 1
28598: PPUSH
28599: CALL_OW 248
28603: PPUSH
28604: CALL_OW 450
28608: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28609: LD_ADDR_VAR 0 3
28613: PUSH
28614: LD_VAR 0 4
28618: PPUSH
28619: LD_INT 1
28621: PPUSH
28622: CALL_OW 275
28626: PUSH
28627: LD_VAR 0 5
28631: PUSH
28632: LD_INT 1
28634: ARRAY
28635: GREATEREQUAL
28636: PUSH
28637: LD_VAR 0 4
28641: PPUSH
28642: LD_INT 2
28644: PPUSH
28645: CALL_OW 275
28649: PUSH
28650: LD_VAR 0 5
28654: PUSH
28655: LD_INT 2
28657: ARRAY
28658: GREATEREQUAL
28659: AND
28660: PUSH
28661: LD_VAR 0 4
28665: PPUSH
28666: LD_INT 3
28668: PPUSH
28669: CALL_OW 275
28673: PUSH
28674: LD_VAR 0 5
28678: PUSH
28679: LD_INT 3
28681: ARRAY
28682: GREATEREQUAL
28683: AND
28684: ST_TO_ADDR
// end ;
28685: LD_VAR 0 3
28689: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
28690: LD_INT 0
28692: PPUSH
28693: PPUSH
28694: PPUSH
28695: PPUSH
28696: PPUSH
28697: PPUSH
28698: PPUSH
28699: PPUSH
28700: PPUSH
28701: PPUSH
28702: PPUSH
// result := false ;
28703: LD_ADDR_VAR 0 8
28707: PUSH
28708: LD_INT 0
28710: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
28711: LD_VAR 0 5
28715: NOT
28716: PUSH
28717: LD_VAR 0 1
28721: NOT
28722: OR
28723: PUSH
28724: LD_VAR 0 2
28728: NOT
28729: OR
28730: PUSH
28731: LD_VAR 0 3
28735: NOT
28736: OR
28737: IFFALSE 28741
// exit ;
28739: GO 29555
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
28741: LD_ADDR_VAR 0 14
28745: PUSH
28746: LD_VAR 0 1
28750: PPUSH
28751: LD_VAR 0 2
28755: PPUSH
28756: LD_VAR 0 3
28760: PPUSH
28761: LD_VAR 0 4
28765: PPUSH
28766: LD_VAR 0 5
28770: PUSH
28771: LD_INT 1
28773: ARRAY
28774: PPUSH
28775: CALL_OW 248
28779: PPUSH
28780: LD_INT 0
28782: PPUSH
28783: CALL 30808 0 6
28787: ST_TO_ADDR
// if not hexes then
28788: LD_VAR 0 14
28792: NOT
28793: IFFALSE 28797
// exit ;
28795: GO 29555
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28797: LD_ADDR_VAR 0 17
28801: PUSH
28802: LD_VAR 0 5
28806: PPUSH
28807: LD_INT 22
28809: PUSH
28810: LD_VAR 0 13
28814: PPUSH
28815: CALL_OW 255
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: PUSH
28824: LD_INT 2
28826: PUSH
28827: LD_INT 30
28829: PUSH
28830: LD_INT 0
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: PUSH
28837: LD_INT 30
28839: PUSH
28840: LD_INT 1
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: PUSH
28847: EMPTY
28848: LIST
28849: LIST
28850: LIST
28851: PUSH
28852: EMPTY
28853: LIST
28854: LIST
28855: PPUSH
28856: CALL_OW 72
28860: ST_TO_ADDR
// for i = 1 to hexes do
28861: LD_ADDR_VAR 0 9
28865: PUSH
28866: DOUBLE
28867: LD_INT 1
28869: DEC
28870: ST_TO_ADDR
28871: LD_VAR 0 14
28875: PUSH
28876: FOR_TO
28877: IFFALSE 29553
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28879: LD_ADDR_VAR 0 13
28883: PUSH
28884: LD_VAR 0 14
28888: PUSH
28889: LD_VAR 0 9
28893: ARRAY
28894: PUSH
28895: LD_INT 1
28897: ARRAY
28898: PPUSH
28899: LD_VAR 0 14
28903: PUSH
28904: LD_VAR 0 9
28908: ARRAY
28909: PUSH
28910: LD_INT 2
28912: ARRAY
28913: PPUSH
28914: CALL_OW 428
28918: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28919: LD_VAR 0 14
28923: PUSH
28924: LD_VAR 0 9
28928: ARRAY
28929: PUSH
28930: LD_INT 1
28932: ARRAY
28933: PPUSH
28934: LD_VAR 0 14
28938: PUSH
28939: LD_VAR 0 9
28943: ARRAY
28944: PUSH
28945: LD_INT 2
28947: ARRAY
28948: PPUSH
28949: CALL_OW 351
28953: PUSH
28954: LD_VAR 0 14
28958: PUSH
28959: LD_VAR 0 9
28963: ARRAY
28964: PUSH
28965: LD_INT 1
28967: ARRAY
28968: PPUSH
28969: LD_VAR 0 14
28973: PUSH
28974: LD_VAR 0 9
28978: ARRAY
28979: PUSH
28980: LD_INT 2
28982: ARRAY
28983: PPUSH
28984: CALL_OW 488
28988: NOT
28989: OR
28990: PUSH
28991: LD_VAR 0 13
28995: PPUSH
28996: CALL_OW 247
29000: PUSH
29001: LD_INT 3
29003: EQUAL
29004: OR
29005: IFFALSE 29011
// exit ;
29007: POP
29008: POP
29009: GO 29555
// if not tmp then
29011: LD_VAR 0 13
29015: NOT
29016: IFFALSE 29020
// continue ;
29018: GO 28876
// result := true ;
29020: LD_ADDR_VAR 0 8
29024: PUSH
29025: LD_INT 1
29027: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
29028: LD_VAR 0 6
29032: PUSH
29033: LD_VAR 0 13
29037: PPUSH
29038: CALL_OW 247
29042: PUSH
29043: LD_INT 2
29045: EQUAL
29046: AND
29047: PUSH
29048: LD_VAR 0 13
29052: PPUSH
29053: CALL_OW 263
29057: PUSH
29058: LD_INT 1
29060: EQUAL
29061: AND
29062: IFFALSE 29226
// begin if IsDrivenBy ( tmp ) then
29064: LD_VAR 0 13
29068: PPUSH
29069: CALL_OW 311
29073: IFFALSE 29077
// continue ;
29075: GO 28876
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
29077: LD_VAR 0 6
29081: PPUSH
29082: LD_INT 3
29084: PUSH
29085: LD_INT 60
29087: PUSH
29088: EMPTY
29089: LIST
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 3
29097: PUSH
29098: LD_INT 55
29100: PUSH
29101: EMPTY
29102: LIST
29103: PUSH
29104: EMPTY
29105: LIST
29106: LIST
29107: PUSH
29108: EMPTY
29109: LIST
29110: LIST
29111: PPUSH
29112: CALL_OW 72
29116: IFFALSE 29224
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
29118: LD_ADDR_VAR 0 18
29122: PUSH
29123: LD_VAR 0 6
29127: PPUSH
29128: LD_INT 3
29130: PUSH
29131: LD_INT 60
29133: PUSH
29134: EMPTY
29135: LIST
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PUSH
29141: LD_INT 3
29143: PUSH
29144: LD_INT 55
29146: PUSH
29147: EMPTY
29148: LIST
29149: PUSH
29150: EMPTY
29151: LIST
29152: LIST
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PPUSH
29158: CALL_OW 72
29162: PUSH
29163: LD_INT 1
29165: ARRAY
29166: ST_TO_ADDR
// if IsInUnit ( driver ) then
29167: LD_VAR 0 18
29171: PPUSH
29172: CALL_OW 310
29176: IFFALSE 29187
// ComExit ( driver ) ;
29178: LD_VAR 0 18
29182: PPUSH
29183: CALL 54589 0 1
// AddComEnterUnit ( driver , tmp ) ;
29187: LD_VAR 0 18
29191: PPUSH
29192: LD_VAR 0 13
29196: PPUSH
29197: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
29201: LD_VAR 0 18
29205: PPUSH
29206: LD_VAR 0 7
29210: PPUSH
29211: CALL_OW 173
// AddComExitVehicle ( driver ) ;
29215: LD_VAR 0 18
29219: PPUSH
29220: CALL_OW 181
// end ; continue ;
29224: GO 28876
// end ; if not cleaners or not tmp in cleaners then
29226: LD_VAR 0 6
29230: NOT
29231: PUSH
29232: LD_VAR 0 13
29236: PUSH
29237: LD_VAR 0 6
29241: IN
29242: NOT
29243: OR
29244: IFFALSE 29551
// begin if dep then
29246: LD_VAR 0 17
29250: IFFALSE 29386
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
29252: LD_ADDR_VAR 0 16
29256: PUSH
29257: LD_VAR 0 17
29261: PUSH
29262: LD_INT 1
29264: ARRAY
29265: PPUSH
29266: CALL_OW 250
29270: PPUSH
29271: LD_VAR 0 17
29275: PUSH
29276: LD_INT 1
29278: ARRAY
29279: PPUSH
29280: CALL_OW 254
29284: PPUSH
29285: LD_INT 5
29287: PPUSH
29288: CALL_OW 272
29292: PUSH
29293: LD_VAR 0 17
29297: PUSH
29298: LD_INT 1
29300: ARRAY
29301: PPUSH
29302: CALL_OW 251
29306: PPUSH
29307: LD_VAR 0 17
29311: PUSH
29312: LD_INT 1
29314: ARRAY
29315: PPUSH
29316: CALL_OW 254
29320: PPUSH
29321: LD_INT 5
29323: PPUSH
29324: CALL_OW 273
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
29333: LD_VAR 0 16
29337: PUSH
29338: LD_INT 1
29340: ARRAY
29341: PPUSH
29342: LD_VAR 0 16
29346: PUSH
29347: LD_INT 2
29349: ARRAY
29350: PPUSH
29351: CALL_OW 488
29355: IFFALSE 29386
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
29357: LD_VAR 0 13
29361: PPUSH
29362: LD_VAR 0 16
29366: PUSH
29367: LD_INT 1
29369: ARRAY
29370: PPUSH
29371: LD_VAR 0 16
29375: PUSH
29376: LD_INT 2
29378: ARRAY
29379: PPUSH
29380: CALL_OW 111
// continue ;
29384: GO 28876
// end ; end ; r := GetDir ( tmp ) ;
29386: LD_ADDR_VAR 0 15
29390: PUSH
29391: LD_VAR 0 13
29395: PPUSH
29396: CALL_OW 254
29400: ST_TO_ADDR
// if r = 5 then
29401: LD_VAR 0 15
29405: PUSH
29406: LD_INT 5
29408: EQUAL
29409: IFFALSE 29419
// r := 0 ;
29411: LD_ADDR_VAR 0 15
29415: PUSH
29416: LD_INT 0
29418: ST_TO_ADDR
// for j = r to 5 do
29419: LD_ADDR_VAR 0 10
29423: PUSH
29424: DOUBLE
29425: LD_VAR 0 15
29429: DEC
29430: ST_TO_ADDR
29431: LD_INT 5
29433: PUSH
29434: FOR_TO
29435: IFFALSE 29549
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
29437: LD_ADDR_VAR 0 11
29441: PUSH
29442: LD_VAR 0 13
29446: PPUSH
29447: CALL_OW 250
29451: PPUSH
29452: LD_VAR 0 10
29456: PPUSH
29457: LD_INT 2
29459: PPUSH
29460: CALL_OW 272
29464: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
29465: LD_ADDR_VAR 0 12
29469: PUSH
29470: LD_VAR 0 13
29474: PPUSH
29475: CALL_OW 251
29479: PPUSH
29480: LD_VAR 0 10
29484: PPUSH
29485: LD_INT 2
29487: PPUSH
29488: CALL_OW 273
29492: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
29493: LD_VAR 0 11
29497: PPUSH
29498: LD_VAR 0 12
29502: PPUSH
29503: CALL_OW 488
29507: PUSH
29508: LD_VAR 0 11
29512: PPUSH
29513: LD_VAR 0 12
29517: PPUSH
29518: CALL_OW 428
29522: NOT
29523: AND
29524: IFFALSE 29547
// begin ComMoveXY ( tmp , _x , _y ) ;
29526: LD_VAR 0 13
29530: PPUSH
29531: LD_VAR 0 11
29535: PPUSH
29536: LD_VAR 0 12
29540: PPUSH
29541: CALL_OW 111
// break ;
29545: GO 29549
// end ; end ;
29547: GO 29434
29549: POP
29550: POP
// end ; end ;
29551: GO 28876
29553: POP
29554: POP
// end ;
29555: LD_VAR 0 8
29559: RET
// export function BuildingTechInvented ( side , btype ) ; begin
29560: LD_INT 0
29562: PPUSH
// result := true ;
29563: LD_ADDR_VAR 0 3
29567: PUSH
29568: LD_INT 1
29570: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
29571: LD_VAR 0 2
29575: PUSH
29576: LD_INT 24
29578: DOUBLE
29579: EQUAL
29580: IFTRUE 29590
29582: LD_INT 33
29584: DOUBLE
29585: EQUAL
29586: IFTRUE 29590
29588: GO 29615
29590: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
29591: LD_ADDR_VAR 0 3
29595: PUSH
29596: LD_INT 32
29598: PPUSH
29599: LD_VAR 0 1
29603: PPUSH
29604: CALL_OW 321
29608: PUSH
29609: LD_INT 2
29611: EQUAL
29612: ST_TO_ADDR
29613: GO 29931
29615: LD_INT 20
29617: DOUBLE
29618: EQUAL
29619: IFTRUE 29623
29621: GO 29648
29623: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
29624: LD_ADDR_VAR 0 3
29628: PUSH
29629: LD_INT 6
29631: PPUSH
29632: LD_VAR 0 1
29636: PPUSH
29637: CALL_OW 321
29641: PUSH
29642: LD_INT 2
29644: EQUAL
29645: ST_TO_ADDR
29646: GO 29931
29648: LD_INT 22
29650: DOUBLE
29651: EQUAL
29652: IFTRUE 29662
29654: LD_INT 36
29656: DOUBLE
29657: EQUAL
29658: IFTRUE 29662
29660: GO 29687
29662: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
29663: LD_ADDR_VAR 0 3
29667: PUSH
29668: LD_INT 15
29670: PPUSH
29671: LD_VAR 0 1
29675: PPUSH
29676: CALL_OW 321
29680: PUSH
29681: LD_INT 2
29683: EQUAL
29684: ST_TO_ADDR
29685: GO 29931
29687: LD_INT 30
29689: DOUBLE
29690: EQUAL
29691: IFTRUE 29695
29693: GO 29720
29695: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
29696: LD_ADDR_VAR 0 3
29700: PUSH
29701: LD_INT 20
29703: PPUSH
29704: LD_VAR 0 1
29708: PPUSH
29709: CALL_OW 321
29713: PUSH
29714: LD_INT 2
29716: EQUAL
29717: ST_TO_ADDR
29718: GO 29931
29720: LD_INT 28
29722: DOUBLE
29723: EQUAL
29724: IFTRUE 29734
29726: LD_INT 21
29728: DOUBLE
29729: EQUAL
29730: IFTRUE 29734
29732: GO 29759
29734: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
29735: LD_ADDR_VAR 0 3
29739: PUSH
29740: LD_INT 21
29742: PPUSH
29743: LD_VAR 0 1
29747: PPUSH
29748: CALL_OW 321
29752: PUSH
29753: LD_INT 2
29755: EQUAL
29756: ST_TO_ADDR
29757: GO 29931
29759: LD_INT 16
29761: DOUBLE
29762: EQUAL
29763: IFTRUE 29767
29765: GO 29792
29767: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
29768: LD_ADDR_VAR 0 3
29772: PUSH
29773: LD_INT 84
29775: PPUSH
29776: LD_VAR 0 1
29780: PPUSH
29781: CALL_OW 321
29785: PUSH
29786: LD_INT 2
29788: EQUAL
29789: ST_TO_ADDR
29790: GO 29931
29792: LD_INT 19
29794: DOUBLE
29795: EQUAL
29796: IFTRUE 29806
29798: LD_INT 23
29800: DOUBLE
29801: EQUAL
29802: IFTRUE 29806
29804: GO 29831
29806: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
29807: LD_ADDR_VAR 0 3
29811: PUSH
29812: LD_INT 83
29814: PPUSH
29815: LD_VAR 0 1
29819: PPUSH
29820: CALL_OW 321
29824: PUSH
29825: LD_INT 2
29827: EQUAL
29828: ST_TO_ADDR
29829: GO 29931
29831: LD_INT 17
29833: DOUBLE
29834: EQUAL
29835: IFTRUE 29839
29837: GO 29864
29839: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
29840: LD_ADDR_VAR 0 3
29844: PUSH
29845: LD_INT 39
29847: PPUSH
29848: LD_VAR 0 1
29852: PPUSH
29853: CALL_OW 321
29857: PUSH
29858: LD_INT 2
29860: EQUAL
29861: ST_TO_ADDR
29862: GO 29931
29864: LD_INT 18
29866: DOUBLE
29867: EQUAL
29868: IFTRUE 29872
29870: GO 29897
29872: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
29873: LD_ADDR_VAR 0 3
29877: PUSH
29878: LD_INT 40
29880: PPUSH
29881: LD_VAR 0 1
29885: PPUSH
29886: CALL_OW 321
29890: PUSH
29891: LD_INT 2
29893: EQUAL
29894: ST_TO_ADDR
29895: GO 29931
29897: LD_INT 27
29899: DOUBLE
29900: EQUAL
29901: IFTRUE 29905
29903: GO 29930
29905: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
29906: LD_ADDR_VAR 0 3
29910: PUSH
29911: LD_INT 35
29913: PPUSH
29914: LD_VAR 0 1
29918: PPUSH
29919: CALL_OW 321
29923: PUSH
29924: LD_INT 2
29926: EQUAL
29927: ST_TO_ADDR
29928: GO 29931
29930: POP
// end ;
29931: LD_VAR 0 3
29935: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
29936: LD_INT 0
29938: PPUSH
29939: PPUSH
29940: PPUSH
29941: PPUSH
29942: PPUSH
29943: PPUSH
29944: PPUSH
29945: PPUSH
29946: PPUSH
29947: PPUSH
29948: PPUSH
// result := false ;
29949: LD_ADDR_VAR 0 6
29953: PUSH
29954: LD_INT 0
29956: ST_TO_ADDR
// if btype = b_depot then
29957: LD_VAR 0 2
29961: PUSH
29962: LD_INT 0
29964: EQUAL
29965: IFFALSE 29977
// begin result := true ;
29967: LD_ADDR_VAR 0 6
29971: PUSH
29972: LD_INT 1
29974: ST_TO_ADDR
// exit ;
29975: GO 30803
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
29977: LD_VAR 0 1
29981: NOT
29982: PUSH
29983: LD_VAR 0 1
29987: PPUSH
29988: CALL_OW 266
29992: PUSH
29993: LD_INT 0
29995: PUSH
29996: LD_INT 1
29998: PUSH
29999: EMPTY
30000: LIST
30001: LIST
30002: IN
30003: NOT
30004: OR
30005: PUSH
30006: LD_VAR 0 2
30010: NOT
30011: OR
30012: PUSH
30013: LD_VAR 0 5
30017: PUSH
30018: LD_INT 0
30020: PUSH
30021: LD_INT 1
30023: PUSH
30024: LD_INT 2
30026: PUSH
30027: LD_INT 3
30029: PUSH
30030: LD_INT 4
30032: PUSH
30033: LD_INT 5
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: IN
30044: NOT
30045: OR
30046: PUSH
30047: LD_VAR 0 3
30051: PPUSH
30052: LD_VAR 0 4
30056: PPUSH
30057: CALL_OW 488
30061: NOT
30062: OR
30063: IFFALSE 30067
// exit ;
30065: GO 30803
// side := GetSide ( depot ) ;
30067: LD_ADDR_VAR 0 9
30071: PUSH
30072: LD_VAR 0 1
30076: PPUSH
30077: CALL_OW 255
30081: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
30082: LD_VAR 0 9
30086: PPUSH
30087: LD_VAR 0 2
30091: PPUSH
30092: CALL 29560 0 2
30096: NOT
30097: IFFALSE 30101
// exit ;
30099: GO 30803
// pom := GetBase ( depot ) ;
30101: LD_ADDR_VAR 0 10
30105: PUSH
30106: LD_VAR 0 1
30110: PPUSH
30111: CALL_OW 274
30115: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
30116: LD_ADDR_VAR 0 11
30120: PUSH
30121: LD_VAR 0 2
30125: PPUSH
30126: LD_VAR 0 1
30130: PPUSH
30131: CALL_OW 248
30135: PPUSH
30136: CALL_OW 450
30140: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
30141: LD_VAR 0 10
30145: PPUSH
30146: LD_INT 1
30148: PPUSH
30149: CALL_OW 275
30153: PUSH
30154: LD_VAR 0 11
30158: PUSH
30159: LD_INT 1
30161: ARRAY
30162: GREATEREQUAL
30163: PUSH
30164: LD_VAR 0 10
30168: PPUSH
30169: LD_INT 2
30171: PPUSH
30172: CALL_OW 275
30176: PUSH
30177: LD_VAR 0 11
30181: PUSH
30182: LD_INT 2
30184: ARRAY
30185: GREATEREQUAL
30186: AND
30187: PUSH
30188: LD_VAR 0 10
30192: PPUSH
30193: LD_INT 3
30195: PPUSH
30196: CALL_OW 275
30200: PUSH
30201: LD_VAR 0 11
30205: PUSH
30206: LD_INT 3
30208: ARRAY
30209: GREATEREQUAL
30210: AND
30211: NOT
30212: IFFALSE 30216
// exit ;
30214: GO 30803
// if GetBType ( depot ) = b_depot then
30216: LD_VAR 0 1
30220: PPUSH
30221: CALL_OW 266
30225: PUSH
30226: LD_INT 0
30228: EQUAL
30229: IFFALSE 30241
// dist := 28 else
30231: LD_ADDR_VAR 0 14
30235: PUSH
30236: LD_INT 28
30238: ST_TO_ADDR
30239: GO 30249
// dist := 36 ;
30241: LD_ADDR_VAR 0 14
30245: PUSH
30246: LD_INT 36
30248: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
30249: LD_VAR 0 1
30253: PPUSH
30254: LD_VAR 0 3
30258: PPUSH
30259: LD_VAR 0 4
30263: PPUSH
30264: CALL_OW 297
30268: PUSH
30269: LD_VAR 0 14
30273: GREATER
30274: IFFALSE 30278
// exit ;
30276: GO 30803
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
30278: LD_ADDR_VAR 0 12
30282: PUSH
30283: LD_VAR 0 2
30287: PPUSH
30288: LD_VAR 0 3
30292: PPUSH
30293: LD_VAR 0 4
30297: PPUSH
30298: LD_VAR 0 5
30302: PPUSH
30303: LD_VAR 0 1
30307: PPUSH
30308: CALL_OW 248
30312: PPUSH
30313: LD_INT 0
30315: PPUSH
30316: CALL 30808 0 6
30320: ST_TO_ADDR
// if not hexes then
30321: LD_VAR 0 12
30325: NOT
30326: IFFALSE 30330
// exit ;
30328: GO 30803
// hex := GetHexInfo ( x , y ) ;
30330: LD_ADDR_VAR 0 15
30334: PUSH
30335: LD_VAR 0 3
30339: PPUSH
30340: LD_VAR 0 4
30344: PPUSH
30345: CALL_OW 546
30349: ST_TO_ADDR
// if hex [ 1 ] then
30350: LD_VAR 0 15
30354: PUSH
30355: LD_INT 1
30357: ARRAY
30358: IFFALSE 30362
// exit ;
30360: GO 30803
// height := hex [ 2 ] ;
30362: LD_ADDR_VAR 0 13
30366: PUSH
30367: LD_VAR 0 15
30371: PUSH
30372: LD_INT 2
30374: ARRAY
30375: ST_TO_ADDR
// for i = 1 to hexes do
30376: LD_ADDR_VAR 0 7
30380: PUSH
30381: DOUBLE
30382: LD_INT 1
30384: DEC
30385: ST_TO_ADDR
30386: LD_VAR 0 12
30390: PUSH
30391: FOR_TO
30392: IFFALSE 30722
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
30394: LD_VAR 0 12
30398: PUSH
30399: LD_VAR 0 7
30403: ARRAY
30404: PUSH
30405: LD_INT 1
30407: ARRAY
30408: PPUSH
30409: LD_VAR 0 12
30413: PUSH
30414: LD_VAR 0 7
30418: ARRAY
30419: PUSH
30420: LD_INT 2
30422: ARRAY
30423: PPUSH
30424: CALL_OW 488
30428: NOT
30429: PUSH
30430: LD_VAR 0 12
30434: PUSH
30435: LD_VAR 0 7
30439: ARRAY
30440: PUSH
30441: LD_INT 1
30443: ARRAY
30444: PPUSH
30445: LD_VAR 0 12
30449: PUSH
30450: LD_VAR 0 7
30454: ARRAY
30455: PUSH
30456: LD_INT 2
30458: ARRAY
30459: PPUSH
30460: CALL_OW 428
30464: PUSH
30465: LD_INT 0
30467: GREATER
30468: OR
30469: PUSH
30470: LD_VAR 0 12
30474: PUSH
30475: LD_VAR 0 7
30479: ARRAY
30480: PUSH
30481: LD_INT 1
30483: ARRAY
30484: PPUSH
30485: LD_VAR 0 12
30489: PUSH
30490: LD_VAR 0 7
30494: ARRAY
30495: PUSH
30496: LD_INT 2
30498: ARRAY
30499: PPUSH
30500: CALL_OW 351
30504: OR
30505: IFFALSE 30511
// exit ;
30507: POP
30508: POP
30509: GO 30803
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
30511: LD_ADDR_VAR 0 8
30515: PUSH
30516: LD_VAR 0 12
30520: PUSH
30521: LD_VAR 0 7
30525: ARRAY
30526: PUSH
30527: LD_INT 1
30529: ARRAY
30530: PPUSH
30531: LD_VAR 0 12
30535: PUSH
30536: LD_VAR 0 7
30540: ARRAY
30541: PUSH
30542: LD_INT 2
30544: ARRAY
30545: PPUSH
30546: CALL_OW 546
30550: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
30551: LD_VAR 0 8
30555: PUSH
30556: LD_INT 1
30558: ARRAY
30559: PUSH
30560: LD_VAR 0 8
30564: PUSH
30565: LD_INT 2
30567: ARRAY
30568: PUSH
30569: LD_VAR 0 13
30573: PUSH
30574: LD_INT 2
30576: PLUS
30577: GREATER
30578: OR
30579: PUSH
30580: LD_VAR 0 8
30584: PUSH
30585: LD_INT 2
30587: ARRAY
30588: PUSH
30589: LD_VAR 0 13
30593: PUSH
30594: LD_INT 2
30596: MINUS
30597: LESS
30598: OR
30599: PUSH
30600: LD_VAR 0 8
30604: PUSH
30605: LD_INT 3
30607: ARRAY
30608: PUSH
30609: LD_INT 0
30611: PUSH
30612: LD_INT 8
30614: PUSH
30615: LD_INT 9
30617: PUSH
30618: LD_INT 10
30620: PUSH
30621: LD_INT 11
30623: PUSH
30624: LD_INT 12
30626: PUSH
30627: LD_INT 13
30629: PUSH
30630: LD_INT 16
30632: PUSH
30633: LD_INT 17
30635: PUSH
30636: LD_INT 18
30638: PUSH
30639: LD_INT 19
30641: PUSH
30642: LD_INT 20
30644: PUSH
30645: LD_INT 21
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: LIST
30652: LIST
30653: LIST
30654: LIST
30655: LIST
30656: LIST
30657: LIST
30658: LIST
30659: LIST
30660: LIST
30661: LIST
30662: IN
30663: NOT
30664: OR
30665: PUSH
30666: LD_VAR 0 8
30670: PUSH
30671: LD_INT 5
30673: ARRAY
30674: NOT
30675: OR
30676: PUSH
30677: LD_VAR 0 8
30681: PUSH
30682: LD_INT 6
30684: ARRAY
30685: PUSH
30686: LD_INT 1
30688: PUSH
30689: LD_INT 2
30691: PUSH
30692: LD_INT 7
30694: PUSH
30695: LD_INT 9
30697: PUSH
30698: LD_INT 10
30700: PUSH
30701: LD_INT 11
30703: PUSH
30704: EMPTY
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: LIST
30711: IN
30712: NOT
30713: OR
30714: IFFALSE 30720
// exit ;
30716: POP
30717: POP
30718: GO 30803
// end ;
30720: GO 30391
30722: POP
30723: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
30724: LD_VAR 0 9
30728: PPUSH
30729: LD_VAR 0 3
30733: PPUSH
30734: LD_VAR 0 4
30738: PPUSH
30739: LD_INT 20
30741: PPUSH
30742: CALL 22726 0 4
30746: PUSH
30747: LD_INT 4
30749: ARRAY
30750: IFFALSE 30754
// exit ;
30752: GO 30803
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
30754: LD_VAR 0 2
30758: PUSH
30759: LD_INT 29
30761: PUSH
30762: LD_INT 30
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: IN
30769: PUSH
30770: LD_VAR 0 3
30774: PPUSH
30775: LD_VAR 0 4
30779: PPUSH
30780: LD_VAR 0 9
30784: PPUSH
30785: CALL_OW 440
30789: NOT
30790: AND
30791: IFFALSE 30795
// exit ;
30793: GO 30803
// result := true ;
30795: LD_ADDR_VAR 0 6
30799: PUSH
30800: LD_INT 1
30802: ST_TO_ADDR
// end ;
30803: LD_VAR 0 6
30807: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
30808: LD_INT 0
30810: PPUSH
30811: PPUSH
30812: PPUSH
30813: PPUSH
30814: PPUSH
30815: PPUSH
30816: PPUSH
30817: PPUSH
30818: PPUSH
30819: PPUSH
30820: PPUSH
30821: PPUSH
30822: PPUSH
30823: PPUSH
30824: PPUSH
30825: PPUSH
30826: PPUSH
30827: PPUSH
30828: PPUSH
30829: PPUSH
30830: PPUSH
30831: PPUSH
30832: PPUSH
30833: PPUSH
30834: PPUSH
30835: PPUSH
30836: PPUSH
30837: PPUSH
30838: PPUSH
30839: PPUSH
30840: PPUSH
30841: PPUSH
30842: PPUSH
30843: PPUSH
30844: PPUSH
30845: PPUSH
30846: PPUSH
30847: PPUSH
30848: PPUSH
30849: PPUSH
30850: PPUSH
30851: PPUSH
30852: PPUSH
30853: PPUSH
30854: PPUSH
30855: PPUSH
30856: PPUSH
30857: PPUSH
30858: PPUSH
30859: PPUSH
30860: PPUSH
30861: PPUSH
30862: PPUSH
30863: PPUSH
30864: PPUSH
30865: PPUSH
30866: PPUSH
30867: PPUSH
// result = [ ] ;
30868: LD_ADDR_VAR 0 7
30872: PUSH
30873: EMPTY
30874: ST_TO_ADDR
// temp_list = [ ] ;
30875: LD_ADDR_VAR 0 9
30879: PUSH
30880: EMPTY
30881: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
30882: LD_VAR 0 4
30886: PUSH
30887: LD_INT 0
30889: PUSH
30890: LD_INT 1
30892: PUSH
30893: LD_INT 2
30895: PUSH
30896: LD_INT 3
30898: PUSH
30899: LD_INT 4
30901: PUSH
30902: LD_INT 5
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: IN
30913: NOT
30914: PUSH
30915: LD_VAR 0 1
30919: PUSH
30920: LD_INT 0
30922: PUSH
30923: LD_INT 1
30925: PUSH
30926: EMPTY
30927: LIST
30928: LIST
30929: IN
30930: PUSH
30931: LD_VAR 0 5
30935: PUSH
30936: LD_INT 1
30938: PUSH
30939: LD_INT 2
30941: PUSH
30942: LD_INT 3
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: LIST
30949: IN
30950: NOT
30951: AND
30952: OR
30953: IFFALSE 30957
// exit ;
30955: GO 49348
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
30957: LD_VAR 0 1
30961: PUSH
30962: LD_INT 6
30964: PUSH
30965: LD_INT 7
30967: PUSH
30968: LD_INT 8
30970: PUSH
30971: LD_INT 13
30973: PUSH
30974: LD_INT 12
30976: PUSH
30977: LD_INT 15
30979: PUSH
30980: LD_INT 11
30982: PUSH
30983: LD_INT 14
30985: PUSH
30986: LD_INT 10
30988: PUSH
30989: EMPTY
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: LIST
30995: LIST
30996: LIST
30997: LIST
30998: LIST
30999: IN
31000: IFFALSE 31010
// btype = b_lab ;
31002: LD_ADDR_VAR 0 1
31006: PUSH
31007: LD_INT 6
31009: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
31010: LD_VAR 0 6
31014: PUSH
31015: LD_INT 0
31017: PUSH
31018: LD_INT 1
31020: PUSH
31021: LD_INT 2
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: LIST
31028: IN
31029: NOT
31030: PUSH
31031: LD_VAR 0 1
31035: PUSH
31036: LD_INT 0
31038: PUSH
31039: LD_INT 1
31041: PUSH
31042: LD_INT 2
31044: PUSH
31045: LD_INT 3
31047: PUSH
31048: LD_INT 6
31050: PUSH
31051: LD_INT 36
31053: PUSH
31054: LD_INT 4
31056: PUSH
31057: LD_INT 5
31059: PUSH
31060: LD_INT 31
31062: PUSH
31063: LD_INT 32
31065: PUSH
31066: LD_INT 33
31068: PUSH
31069: EMPTY
31070: LIST
31071: LIST
31072: LIST
31073: LIST
31074: LIST
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: IN
31082: NOT
31083: PUSH
31084: LD_VAR 0 6
31088: PUSH
31089: LD_INT 1
31091: EQUAL
31092: AND
31093: OR
31094: PUSH
31095: LD_VAR 0 1
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: LD_INT 3
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: IN
31110: NOT
31111: PUSH
31112: LD_VAR 0 6
31116: PUSH
31117: LD_INT 2
31119: EQUAL
31120: AND
31121: OR
31122: IFFALSE 31132
// mode = 0 ;
31124: LD_ADDR_VAR 0 6
31128: PUSH
31129: LD_INT 0
31131: ST_TO_ADDR
// case mode of 0 :
31132: LD_VAR 0 6
31136: PUSH
31137: LD_INT 0
31139: DOUBLE
31140: EQUAL
31141: IFTRUE 31145
31143: GO 42598
31145: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31146: LD_ADDR_VAR 0 11
31150: PUSH
31151: LD_INT 0
31153: PUSH
31154: LD_INT 0
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: PUSH
31161: LD_INT 0
31163: PUSH
31164: LD_INT 1
31166: NEG
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 1
31174: PUSH
31175: LD_INT 0
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 1
31184: PUSH
31185: LD_INT 1
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 0
31194: PUSH
31195: LD_INT 1
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 1
31204: NEG
31205: PUSH
31206: LD_INT 0
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 1
31215: NEG
31216: PUSH
31217: LD_INT 1
31219: NEG
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 1
31227: NEG
31228: PUSH
31229: LD_INT 2
31231: NEG
31232: PUSH
31233: EMPTY
31234: LIST
31235: LIST
31236: PUSH
31237: LD_INT 0
31239: PUSH
31240: LD_INT 2
31242: NEG
31243: PUSH
31244: EMPTY
31245: LIST
31246: LIST
31247: PUSH
31248: LD_INT 1
31250: PUSH
31251: LD_INT 1
31253: NEG
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 1
31261: PUSH
31262: LD_INT 2
31264: PUSH
31265: EMPTY
31266: LIST
31267: LIST
31268: PUSH
31269: LD_INT 0
31271: PUSH
31272: LD_INT 2
31274: PUSH
31275: EMPTY
31276: LIST
31277: LIST
31278: PUSH
31279: LD_INT 1
31281: NEG
31282: PUSH
31283: LD_INT 1
31285: PUSH
31286: EMPTY
31287: LIST
31288: LIST
31289: PUSH
31290: LD_INT 1
31292: PUSH
31293: LD_INT 3
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 0
31302: PUSH
31303: LD_INT 3
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 1
31312: NEG
31313: PUSH
31314: LD_INT 2
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: LIST
31338: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31339: LD_ADDR_VAR 0 12
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: LD_INT 0
31349: PUSH
31350: EMPTY
31351: LIST
31352: LIST
31353: PUSH
31354: LD_INT 0
31356: PUSH
31357: LD_INT 1
31359: NEG
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 1
31367: PUSH
31368: LD_INT 0
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 1
31377: PUSH
31378: LD_INT 1
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 0
31387: PUSH
31388: LD_INT 1
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 1
31397: NEG
31398: PUSH
31399: LD_INT 0
31401: PUSH
31402: EMPTY
31403: LIST
31404: LIST
31405: PUSH
31406: LD_INT 1
31408: NEG
31409: PUSH
31410: LD_INT 1
31412: NEG
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: PUSH
31421: LD_INT 1
31423: NEG
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 2
31431: PUSH
31432: LD_INT 0
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: PUSH
31439: LD_INT 2
31441: PUSH
31442: LD_INT 1
31444: PUSH
31445: EMPTY
31446: LIST
31447: LIST
31448: PUSH
31449: LD_INT 1
31451: NEG
31452: PUSH
31453: LD_INT 1
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: LD_INT 2
31462: NEG
31463: PUSH
31464: LD_INT 0
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 2
31473: NEG
31474: PUSH
31475: LD_INT 1
31477: NEG
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 2
31485: NEG
31486: PUSH
31487: LD_INT 1
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 3
31496: NEG
31497: PUSH
31498: LD_INT 0
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 3
31507: NEG
31508: PUSH
31509: LD_INT 1
31511: NEG
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: LIST
31521: LIST
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31535: LD_ADDR_VAR 0 13
31539: PUSH
31540: LD_INT 0
31542: PUSH
31543: LD_INT 0
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 0
31552: PUSH
31553: LD_INT 1
31555: NEG
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: LD_INT 1
31563: PUSH
31564: LD_INT 0
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 1
31573: PUSH
31574: LD_INT 1
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 0
31583: PUSH
31584: LD_INT 1
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: PUSH
31591: LD_INT 1
31593: NEG
31594: PUSH
31595: LD_INT 0
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: PUSH
31602: LD_INT 1
31604: NEG
31605: PUSH
31606: LD_INT 1
31608: NEG
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 1
31616: NEG
31617: PUSH
31618: LD_INT 2
31620: NEG
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: LD_INT 2
31628: PUSH
31629: LD_INT 1
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 2
31638: PUSH
31639: LD_INT 2
31641: PUSH
31642: EMPTY
31643: LIST
31644: LIST
31645: PUSH
31646: LD_INT 1
31648: PUSH
31649: LD_INT 2
31651: PUSH
31652: EMPTY
31653: LIST
31654: LIST
31655: PUSH
31656: LD_INT 2
31658: NEG
31659: PUSH
31660: LD_INT 1
31662: NEG
31663: PUSH
31664: EMPTY
31665: LIST
31666: LIST
31667: PUSH
31668: LD_INT 2
31670: NEG
31671: PUSH
31672: LD_INT 2
31674: NEG
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 2
31682: NEG
31683: PUSH
31684: LD_INT 3
31686: NEG
31687: PUSH
31688: EMPTY
31689: LIST
31690: LIST
31691: PUSH
31692: LD_INT 3
31694: NEG
31695: PUSH
31696: LD_INT 2
31698: NEG
31699: PUSH
31700: EMPTY
31701: LIST
31702: LIST
31703: PUSH
31704: LD_INT 3
31706: NEG
31707: PUSH
31708: LD_INT 3
31710: NEG
31711: PUSH
31712: EMPTY
31713: LIST
31714: LIST
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31734: LD_ADDR_VAR 0 14
31738: PUSH
31739: LD_INT 0
31741: PUSH
31742: LD_INT 0
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 0
31751: PUSH
31752: LD_INT 1
31754: NEG
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: PUSH
31760: LD_INT 1
31762: PUSH
31763: LD_INT 0
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: PUSH
31770: LD_INT 1
31772: PUSH
31773: LD_INT 1
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 0
31782: PUSH
31783: LD_INT 1
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 1
31792: NEG
31793: PUSH
31794: LD_INT 0
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PUSH
31801: LD_INT 1
31803: NEG
31804: PUSH
31805: LD_INT 1
31807: NEG
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 1
31815: NEG
31816: PUSH
31817: LD_INT 2
31819: NEG
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: LD_INT 0
31827: PUSH
31828: LD_INT 2
31830: NEG
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: LD_INT 1
31838: PUSH
31839: LD_INT 1
31841: NEG
31842: PUSH
31843: EMPTY
31844: LIST
31845: LIST
31846: PUSH
31847: LD_INT 1
31849: PUSH
31850: LD_INT 2
31852: PUSH
31853: EMPTY
31854: LIST
31855: LIST
31856: PUSH
31857: LD_INT 0
31859: PUSH
31860: LD_INT 2
31862: PUSH
31863: EMPTY
31864: LIST
31865: LIST
31866: PUSH
31867: LD_INT 1
31869: NEG
31870: PUSH
31871: LD_INT 1
31873: PUSH
31874: EMPTY
31875: LIST
31876: LIST
31877: PUSH
31878: LD_INT 1
31880: NEG
31881: PUSH
31882: LD_INT 3
31884: NEG
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: PUSH
31890: LD_INT 0
31892: PUSH
31893: LD_INT 3
31895: NEG
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 1
31903: PUSH
31904: LD_INT 2
31906: NEG
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: LIST
31916: LIST
31917: LIST
31918: LIST
31919: LIST
31920: LIST
31921: LIST
31922: LIST
31923: LIST
31924: LIST
31925: LIST
31926: LIST
31927: LIST
31928: LIST
31929: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31930: LD_ADDR_VAR 0 15
31934: PUSH
31935: LD_INT 0
31937: PUSH
31938: LD_INT 0
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: LD_INT 0
31947: PUSH
31948: LD_INT 1
31950: NEG
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 1
31958: PUSH
31959: LD_INT 0
31961: PUSH
31962: EMPTY
31963: LIST
31964: LIST
31965: PUSH
31966: LD_INT 1
31968: PUSH
31969: LD_INT 1
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: PUSH
31976: LD_INT 0
31978: PUSH
31979: LD_INT 1
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 1
31988: NEG
31989: PUSH
31990: LD_INT 0
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: LD_INT 1
31999: NEG
32000: PUSH
32001: LD_INT 1
32003: NEG
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 1
32011: PUSH
32012: LD_INT 1
32014: NEG
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 2
32022: PUSH
32023: LD_INT 0
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 2
32032: PUSH
32033: LD_INT 1
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: LD_INT 1
32042: NEG
32043: PUSH
32044: LD_INT 1
32046: PUSH
32047: EMPTY
32048: LIST
32049: LIST
32050: PUSH
32051: LD_INT 2
32053: NEG
32054: PUSH
32055: LD_INT 0
32057: PUSH
32058: EMPTY
32059: LIST
32060: LIST
32061: PUSH
32062: LD_INT 2
32064: NEG
32065: PUSH
32066: LD_INT 1
32068: NEG
32069: PUSH
32070: EMPTY
32071: LIST
32072: LIST
32073: PUSH
32074: LD_INT 2
32076: PUSH
32077: LD_INT 1
32079: NEG
32080: PUSH
32081: EMPTY
32082: LIST
32083: LIST
32084: PUSH
32085: LD_INT 3
32087: PUSH
32088: LD_INT 0
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PUSH
32095: LD_INT 3
32097: PUSH
32098: LD_INT 1
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: LIST
32109: LIST
32110: LIST
32111: LIST
32112: LIST
32113: LIST
32114: LIST
32115: LIST
32116: LIST
32117: LIST
32118: LIST
32119: LIST
32120: LIST
32121: LIST
32122: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
32123: LD_ADDR_VAR 0 16
32127: PUSH
32128: LD_INT 0
32130: PUSH
32131: LD_INT 0
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: LD_INT 0
32140: PUSH
32141: LD_INT 1
32143: NEG
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: PUSH
32149: LD_INT 1
32151: PUSH
32152: LD_INT 0
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 1
32161: PUSH
32162: LD_INT 1
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: PUSH
32169: LD_INT 0
32171: PUSH
32172: LD_INT 1
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: LD_INT 1
32181: NEG
32182: PUSH
32183: LD_INT 0
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 1
32192: NEG
32193: PUSH
32194: LD_INT 1
32196: NEG
32197: PUSH
32198: EMPTY
32199: LIST
32200: LIST
32201: PUSH
32202: LD_INT 1
32204: NEG
32205: PUSH
32206: LD_INT 2
32208: NEG
32209: PUSH
32210: EMPTY
32211: LIST
32212: LIST
32213: PUSH
32214: LD_INT 2
32216: PUSH
32217: LD_INT 1
32219: PUSH
32220: EMPTY
32221: LIST
32222: LIST
32223: PUSH
32224: LD_INT 2
32226: PUSH
32227: LD_INT 2
32229: PUSH
32230: EMPTY
32231: LIST
32232: LIST
32233: PUSH
32234: LD_INT 1
32236: PUSH
32237: LD_INT 2
32239: PUSH
32240: EMPTY
32241: LIST
32242: LIST
32243: PUSH
32244: LD_INT 2
32246: NEG
32247: PUSH
32248: LD_INT 1
32250: NEG
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 2
32258: NEG
32259: PUSH
32260: LD_INT 2
32262: NEG
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: PUSH
32268: LD_INT 3
32270: PUSH
32271: LD_INT 2
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 3
32280: PUSH
32281: LD_INT 3
32283: PUSH
32284: EMPTY
32285: LIST
32286: LIST
32287: PUSH
32288: LD_INT 2
32290: PUSH
32291: LD_INT 3
32293: PUSH
32294: EMPTY
32295: LIST
32296: LIST
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: LIST
32305: LIST
32306: LIST
32307: LIST
32308: LIST
32309: LIST
32310: LIST
32311: LIST
32312: LIST
32313: LIST
32314: LIST
32315: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32316: LD_ADDR_VAR 0 17
32320: PUSH
32321: LD_INT 0
32323: PUSH
32324: LD_INT 0
32326: PUSH
32327: EMPTY
32328: LIST
32329: LIST
32330: PUSH
32331: LD_INT 0
32333: PUSH
32334: LD_INT 1
32336: NEG
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: LD_INT 1
32344: PUSH
32345: LD_INT 0
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PUSH
32352: LD_INT 1
32354: PUSH
32355: LD_INT 1
32357: PUSH
32358: EMPTY
32359: LIST
32360: LIST
32361: PUSH
32362: LD_INT 0
32364: PUSH
32365: LD_INT 1
32367: PUSH
32368: EMPTY
32369: LIST
32370: LIST
32371: PUSH
32372: LD_INT 1
32374: NEG
32375: PUSH
32376: LD_INT 0
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: LD_INT 1
32385: NEG
32386: PUSH
32387: LD_INT 1
32389: NEG
32390: PUSH
32391: EMPTY
32392: LIST
32393: LIST
32394: PUSH
32395: LD_INT 1
32397: NEG
32398: PUSH
32399: LD_INT 2
32401: NEG
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: LD_INT 2
32412: NEG
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 1
32420: PUSH
32421: LD_INT 1
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 2
32431: PUSH
32432: LD_INT 0
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 2
32441: PUSH
32442: LD_INT 1
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 2
32451: PUSH
32452: LD_INT 2
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: PUSH
32459: LD_INT 1
32461: PUSH
32462: LD_INT 2
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: LD_INT 2
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 1
32481: NEG
32482: PUSH
32483: LD_INT 1
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 2
32492: NEG
32493: PUSH
32494: LD_INT 0
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 2
32503: NEG
32504: PUSH
32505: LD_INT 1
32507: NEG
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: PUSH
32513: LD_INT 2
32515: NEG
32516: PUSH
32517: LD_INT 2
32519: NEG
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: LIST
32531: LIST
32532: LIST
32533: LIST
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: LIST
32545: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32546: LD_ADDR_VAR 0 18
32550: PUSH
32551: LD_INT 0
32553: PUSH
32554: LD_INT 0
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 0
32563: PUSH
32564: LD_INT 1
32566: NEG
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 1
32574: PUSH
32575: LD_INT 0
32577: PUSH
32578: EMPTY
32579: LIST
32580: LIST
32581: PUSH
32582: LD_INT 1
32584: PUSH
32585: LD_INT 1
32587: PUSH
32588: EMPTY
32589: LIST
32590: LIST
32591: PUSH
32592: LD_INT 0
32594: PUSH
32595: LD_INT 1
32597: PUSH
32598: EMPTY
32599: LIST
32600: LIST
32601: PUSH
32602: LD_INT 1
32604: NEG
32605: PUSH
32606: LD_INT 0
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 1
32615: NEG
32616: PUSH
32617: LD_INT 1
32619: NEG
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 1
32627: NEG
32628: PUSH
32629: LD_INT 2
32631: NEG
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 0
32639: PUSH
32640: LD_INT 2
32642: NEG
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 1
32650: PUSH
32651: LD_INT 1
32653: NEG
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 2
32661: PUSH
32662: LD_INT 0
32664: PUSH
32665: EMPTY
32666: LIST
32667: LIST
32668: PUSH
32669: LD_INT 2
32671: PUSH
32672: LD_INT 1
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 2
32681: PUSH
32682: LD_INT 2
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 1
32691: PUSH
32692: LD_INT 2
32694: PUSH
32695: EMPTY
32696: LIST
32697: LIST
32698: PUSH
32699: LD_INT 0
32701: PUSH
32702: LD_INT 2
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 1
32711: NEG
32712: PUSH
32713: LD_INT 1
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 2
32722: NEG
32723: PUSH
32724: LD_INT 0
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: LD_INT 2
32733: NEG
32734: PUSH
32735: LD_INT 1
32737: NEG
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 2
32745: NEG
32746: PUSH
32747: LD_INT 2
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: EMPTY
32756: LIST
32757: LIST
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: LIST
32773: LIST
32774: LIST
32775: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32776: LD_ADDR_VAR 0 19
32780: PUSH
32781: LD_INT 0
32783: PUSH
32784: LD_INT 0
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 0
32793: PUSH
32794: LD_INT 1
32796: NEG
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: LD_INT 1
32804: PUSH
32805: LD_INT 0
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: LD_INT 1
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 0
32824: PUSH
32825: LD_INT 1
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: PUSH
32832: LD_INT 1
32834: NEG
32835: PUSH
32836: LD_INT 0
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 1
32845: NEG
32846: PUSH
32847: LD_INT 1
32849: NEG
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 1
32857: NEG
32858: PUSH
32859: LD_INT 2
32861: NEG
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 0
32869: PUSH
32870: LD_INT 2
32872: NEG
32873: PUSH
32874: EMPTY
32875: LIST
32876: LIST
32877: PUSH
32878: LD_INT 1
32880: PUSH
32881: LD_INT 1
32883: NEG
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: PUSH
32889: LD_INT 2
32891: PUSH
32892: LD_INT 0
32894: PUSH
32895: EMPTY
32896: LIST
32897: LIST
32898: PUSH
32899: LD_INT 2
32901: PUSH
32902: LD_INT 1
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 2
32911: PUSH
32912: LD_INT 2
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 1
32921: PUSH
32922: LD_INT 2
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 0
32931: PUSH
32932: LD_INT 2
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 1
32941: NEG
32942: PUSH
32943: LD_INT 1
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 2
32952: NEG
32953: PUSH
32954: LD_INT 0
32956: PUSH
32957: EMPTY
32958: LIST
32959: LIST
32960: PUSH
32961: LD_INT 2
32963: NEG
32964: PUSH
32965: LD_INT 1
32967: NEG
32968: PUSH
32969: EMPTY
32970: LIST
32971: LIST
32972: PUSH
32973: LD_INT 2
32975: NEG
32976: PUSH
32977: LD_INT 2
32979: NEG
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: LIST
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33006: LD_ADDR_VAR 0 20
33010: PUSH
33011: LD_INT 0
33013: PUSH
33014: LD_INT 0
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PUSH
33021: LD_INT 0
33023: PUSH
33024: LD_INT 1
33026: NEG
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 1
33034: PUSH
33035: LD_INT 0
33037: PUSH
33038: EMPTY
33039: LIST
33040: LIST
33041: PUSH
33042: LD_INT 1
33044: PUSH
33045: LD_INT 1
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: LD_INT 0
33054: PUSH
33055: LD_INT 1
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 1
33064: NEG
33065: PUSH
33066: LD_INT 0
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 1
33075: NEG
33076: PUSH
33077: LD_INT 1
33079: NEG
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 1
33087: NEG
33088: PUSH
33089: LD_INT 2
33091: NEG
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 0
33099: PUSH
33100: LD_INT 2
33102: NEG
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PUSH
33108: LD_INT 1
33110: PUSH
33111: LD_INT 1
33113: NEG
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: PUSH
33119: LD_INT 2
33121: PUSH
33122: LD_INT 0
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PUSH
33129: LD_INT 2
33131: PUSH
33132: LD_INT 1
33134: PUSH
33135: EMPTY
33136: LIST
33137: LIST
33138: PUSH
33139: LD_INT 2
33141: PUSH
33142: LD_INT 2
33144: PUSH
33145: EMPTY
33146: LIST
33147: LIST
33148: PUSH
33149: LD_INT 1
33151: PUSH
33152: LD_INT 2
33154: PUSH
33155: EMPTY
33156: LIST
33157: LIST
33158: PUSH
33159: LD_INT 0
33161: PUSH
33162: LD_INT 2
33164: PUSH
33165: EMPTY
33166: LIST
33167: LIST
33168: PUSH
33169: LD_INT 1
33171: NEG
33172: PUSH
33173: LD_INT 1
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 2
33182: NEG
33183: PUSH
33184: LD_INT 0
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 2
33193: NEG
33194: PUSH
33195: LD_INT 1
33197: NEG
33198: PUSH
33199: EMPTY
33200: LIST
33201: LIST
33202: PUSH
33203: LD_INT 2
33205: NEG
33206: PUSH
33207: LD_INT 2
33209: NEG
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: LIST
33232: LIST
33233: LIST
33234: LIST
33235: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33236: LD_ADDR_VAR 0 21
33240: PUSH
33241: LD_INT 0
33243: PUSH
33244: LD_INT 0
33246: PUSH
33247: EMPTY
33248: LIST
33249: LIST
33250: PUSH
33251: LD_INT 0
33253: PUSH
33254: LD_INT 1
33256: NEG
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: PUSH
33262: LD_INT 1
33264: PUSH
33265: LD_INT 0
33267: PUSH
33268: EMPTY
33269: LIST
33270: LIST
33271: PUSH
33272: LD_INT 1
33274: PUSH
33275: LD_INT 1
33277: PUSH
33278: EMPTY
33279: LIST
33280: LIST
33281: PUSH
33282: LD_INT 0
33284: PUSH
33285: LD_INT 1
33287: PUSH
33288: EMPTY
33289: LIST
33290: LIST
33291: PUSH
33292: LD_INT 1
33294: NEG
33295: PUSH
33296: LD_INT 0
33298: PUSH
33299: EMPTY
33300: LIST
33301: LIST
33302: PUSH
33303: LD_INT 1
33305: NEG
33306: PUSH
33307: LD_INT 1
33309: NEG
33310: PUSH
33311: EMPTY
33312: LIST
33313: LIST
33314: PUSH
33315: LD_INT 1
33317: NEG
33318: PUSH
33319: LD_INT 2
33321: NEG
33322: PUSH
33323: EMPTY
33324: LIST
33325: LIST
33326: PUSH
33327: LD_INT 0
33329: PUSH
33330: LD_INT 2
33332: NEG
33333: PUSH
33334: EMPTY
33335: LIST
33336: LIST
33337: PUSH
33338: LD_INT 1
33340: PUSH
33341: LD_INT 1
33343: NEG
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 2
33351: PUSH
33352: LD_INT 0
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: LD_INT 2
33361: PUSH
33362: LD_INT 1
33364: PUSH
33365: EMPTY
33366: LIST
33367: LIST
33368: PUSH
33369: LD_INT 2
33371: PUSH
33372: LD_INT 2
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: LD_INT 1
33381: PUSH
33382: LD_INT 2
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 0
33391: PUSH
33392: LD_INT 2
33394: PUSH
33395: EMPTY
33396: LIST
33397: LIST
33398: PUSH
33399: LD_INT 1
33401: NEG
33402: PUSH
33403: LD_INT 1
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 2
33412: NEG
33413: PUSH
33414: LD_INT 0
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 2
33423: NEG
33424: PUSH
33425: LD_INT 1
33427: NEG
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: LD_INT 2
33435: NEG
33436: PUSH
33437: LD_INT 2
33439: NEG
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: EMPTY
33446: LIST
33447: LIST
33448: LIST
33449: LIST
33450: LIST
33451: LIST
33452: LIST
33453: LIST
33454: LIST
33455: LIST
33456: LIST
33457: LIST
33458: LIST
33459: LIST
33460: LIST
33461: LIST
33462: LIST
33463: LIST
33464: LIST
33465: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33466: LD_ADDR_VAR 0 22
33470: PUSH
33471: LD_INT 0
33473: PUSH
33474: LD_INT 0
33476: PUSH
33477: EMPTY
33478: LIST
33479: LIST
33480: PUSH
33481: LD_INT 0
33483: PUSH
33484: LD_INT 1
33486: NEG
33487: PUSH
33488: EMPTY
33489: LIST
33490: LIST
33491: PUSH
33492: LD_INT 1
33494: PUSH
33495: LD_INT 0
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: LD_INT 1
33504: PUSH
33505: LD_INT 1
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 0
33514: PUSH
33515: LD_INT 1
33517: PUSH
33518: EMPTY
33519: LIST
33520: LIST
33521: PUSH
33522: LD_INT 1
33524: NEG
33525: PUSH
33526: LD_INT 0
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 1
33535: NEG
33536: PUSH
33537: LD_INT 1
33539: NEG
33540: PUSH
33541: EMPTY
33542: LIST
33543: LIST
33544: PUSH
33545: LD_INT 1
33547: NEG
33548: PUSH
33549: LD_INT 2
33551: NEG
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PUSH
33557: LD_INT 0
33559: PUSH
33560: LD_INT 2
33562: NEG
33563: PUSH
33564: EMPTY
33565: LIST
33566: LIST
33567: PUSH
33568: LD_INT 1
33570: PUSH
33571: LD_INT 1
33573: NEG
33574: PUSH
33575: EMPTY
33576: LIST
33577: LIST
33578: PUSH
33579: LD_INT 2
33581: PUSH
33582: LD_INT 0
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: LD_INT 2
33591: PUSH
33592: LD_INT 1
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: LD_INT 2
33601: PUSH
33602: LD_INT 2
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 1
33611: PUSH
33612: LD_INT 2
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 0
33621: PUSH
33622: LD_INT 2
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 1
33631: NEG
33632: PUSH
33633: LD_INT 1
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 2
33642: NEG
33643: PUSH
33644: LD_INT 0
33646: PUSH
33647: EMPTY
33648: LIST
33649: LIST
33650: PUSH
33651: LD_INT 2
33653: NEG
33654: PUSH
33655: LD_INT 1
33657: NEG
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 2
33665: NEG
33666: PUSH
33667: LD_INT 2
33669: NEG
33670: PUSH
33671: EMPTY
33672: LIST
33673: LIST
33674: PUSH
33675: EMPTY
33676: LIST
33677: LIST
33678: LIST
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
33696: LD_ADDR_VAR 0 23
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: LD_INT 0
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 0
33713: PUSH
33714: LD_INT 1
33716: NEG
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 1
33724: PUSH
33725: LD_INT 0
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 1
33734: PUSH
33735: LD_INT 1
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PUSH
33742: LD_INT 0
33744: PUSH
33745: LD_INT 1
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: PUSH
33752: LD_INT 1
33754: NEG
33755: PUSH
33756: LD_INT 0
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 1
33765: NEG
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 1
33777: NEG
33778: PUSH
33779: LD_INT 2
33781: NEG
33782: PUSH
33783: EMPTY
33784: LIST
33785: LIST
33786: PUSH
33787: LD_INT 0
33789: PUSH
33790: LD_INT 2
33792: NEG
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: LD_INT 1
33803: NEG
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 2
33811: PUSH
33812: LD_INT 0
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 2
33821: PUSH
33822: LD_INT 1
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 2
33831: PUSH
33832: LD_INT 2
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: LD_INT 1
33841: PUSH
33842: LD_INT 2
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 0
33851: PUSH
33852: LD_INT 2
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 1
33861: NEG
33862: PUSH
33863: LD_INT 1
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: PUSH
33870: LD_INT 2
33872: NEG
33873: PUSH
33874: LD_INT 0
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 2
33883: NEG
33884: PUSH
33885: LD_INT 1
33887: NEG
33888: PUSH
33889: EMPTY
33890: LIST
33891: LIST
33892: PUSH
33893: LD_INT 2
33895: NEG
33896: PUSH
33897: LD_INT 2
33899: NEG
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 2
33907: NEG
33908: PUSH
33909: LD_INT 3
33911: NEG
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 1
33919: NEG
33920: PUSH
33921: LD_INT 3
33923: NEG
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 1
33931: PUSH
33932: LD_INT 2
33934: NEG
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: PUSH
33940: LD_INT 2
33942: PUSH
33943: LD_INT 1
33945: NEG
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: EMPTY
33952: LIST
33953: LIST
33954: LIST
33955: LIST
33956: LIST
33957: LIST
33958: LIST
33959: LIST
33960: LIST
33961: LIST
33962: LIST
33963: LIST
33964: LIST
33965: LIST
33966: LIST
33967: LIST
33968: LIST
33969: LIST
33970: LIST
33971: LIST
33972: LIST
33973: LIST
33974: LIST
33975: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
33976: LD_ADDR_VAR 0 24
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: LD_INT 0
33986: PUSH
33987: EMPTY
33988: LIST
33989: LIST
33990: PUSH
33991: LD_INT 0
33993: PUSH
33994: LD_INT 1
33996: NEG
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 1
34004: PUSH
34005: LD_INT 0
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 1
34014: PUSH
34015: LD_INT 1
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: LD_INT 1
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 1
34034: NEG
34035: PUSH
34036: LD_INT 0
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: NEG
34046: PUSH
34047: LD_INT 1
34049: NEG
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: PUSH
34055: LD_INT 1
34057: NEG
34058: PUSH
34059: LD_INT 2
34061: NEG
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: PUSH
34067: LD_INT 0
34069: PUSH
34070: LD_INT 2
34072: NEG
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: LD_INT 1
34080: PUSH
34081: LD_INT 1
34083: NEG
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 2
34091: PUSH
34092: LD_INT 0
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 2
34101: PUSH
34102: LD_INT 1
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PUSH
34109: LD_INT 2
34111: PUSH
34112: LD_INT 2
34114: PUSH
34115: EMPTY
34116: LIST
34117: LIST
34118: PUSH
34119: LD_INT 1
34121: PUSH
34122: LD_INT 2
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: PUSH
34129: LD_INT 0
34131: PUSH
34132: LD_INT 2
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 1
34141: NEG
34142: PUSH
34143: LD_INT 1
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: LD_INT 2
34152: NEG
34153: PUSH
34154: LD_INT 0
34156: PUSH
34157: EMPTY
34158: LIST
34159: LIST
34160: PUSH
34161: LD_INT 2
34163: NEG
34164: PUSH
34165: LD_INT 1
34167: NEG
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 2
34175: NEG
34176: PUSH
34177: LD_INT 2
34179: NEG
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 1
34187: PUSH
34188: LD_INT 2
34190: NEG
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 2
34198: PUSH
34199: LD_INT 1
34201: NEG
34202: PUSH
34203: EMPTY
34204: LIST
34205: LIST
34206: PUSH
34207: LD_INT 3
34209: PUSH
34210: LD_INT 1
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 3
34219: PUSH
34220: LD_INT 2
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: EMPTY
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: LIST
34248: LIST
34249: LIST
34250: LIST
34251: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
34252: LD_ADDR_VAR 0 25
34256: PUSH
34257: LD_INT 0
34259: PUSH
34260: LD_INT 0
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: LD_INT 0
34269: PUSH
34270: LD_INT 1
34272: NEG
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 1
34280: PUSH
34281: LD_INT 0
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: LD_INT 1
34290: PUSH
34291: LD_INT 1
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: PUSH
34298: LD_INT 0
34300: PUSH
34301: LD_INT 1
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PUSH
34308: LD_INT 1
34310: NEG
34311: PUSH
34312: LD_INT 0
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 1
34321: NEG
34322: PUSH
34323: LD_INT 1
34325: NEG
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 1
34333: NEG
34334: PUSH
34335: LD_INT 2
34337: NEG
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 0
34345: PUSH
34346: LD_INT 2
34348: NEG
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: PUSH
34357: LD_INT 1
34359: NEG
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 2
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 2
34377: PUSH
34378: LD_INT 1
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 2
34387: PUSH
34388: LD_INT 2
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 1
34397: PUSH
34398: LD_INT 2
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 0
34407: PUSH
34408: LD_INT 2
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: LD_INT 1
34417: NEG
34418: PUSH
34419: LD_INT 1
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: LD_INT 2
34428: NEG
34429: PUSH
34430: LD_INT 0
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 2
34439: NEG
34440: PUSH
34441: LD_INT 1
34443: NEG
34444: PUSH
34445: EMPTY
34446: LIST
34447: LIST
34448: PUSH
34449: LD_INT 2
34451: NEG
34452: PUSH
34453: LD_INT 2
34455: NEG
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 3
34463: PUSH
34464: LD_INT 1
34466: PUSH
34467: EMPTY
34468: LIST
34469: LIST
34470: PUSH
34471: LD_INT 3
34473: PUSH
34474: LD_INT 2
34476: PUSH
34477: EMPTY
34478: LIST
34479: LIST
34480: PUSH
34481: LD_INT 2
34483: PUSH
34484: LD_INT 3
34486: PUSH
34487: EMPTY
34488: LIST
34489: LIST
34490: PUSH
34491: LD_INT 1
34493: PUSH
34494: LD_INT 3
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: LIST
34505: LIST
34506: LIST
34507: LIST
34508: LIST
34509: LIST
34510: LIST
34511: LIST
34512: LIST
34513: LIST
34514: LIST
34515: LIST
34516: LIST
34517: LIST
34518: LIST
34519: LIST
34520: LIST
34521: LIST
34522: LIST
34523: LIST
34524: LIST
34525: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
34526: LD_ADDR_VAR 0 26
34530: PUSH
34531: LD_INT 0
34533: PUSH
34534: LD_INT 0
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: PUSH
34541: LD_INT 0
34543: PUSH
34544: LD_INT 1
34546: NEG
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 1
34554: PUSH
34555: LD_INT 0
34557: PUSH
34558: EMPTY
34559: LIST
34560: LIST
34561: PUSH
34562: LD_INT 1
34564: PUSH
34565: LD_INT 1
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: LD_INT 0
34574: PUSH
34575: LD_INT 1
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: PUSH
34582: LD_INT 1
34584: NEG
34585: PUSH
34586: LD_INT 0
34588: PUSH
34589: EMPTY
34590: LIST
34591: LIST
34592: PUSH
34593: LD_INT 1
34595: NEG
34596: PUSH
34597: LD_INT 1
34599: NEG
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 1
34607: NEG
34608: PUSH
34609: LD_INT 2
34611: NEG
34612: PUSH
34613: EMPTY
34614: LIST
34615: LIST
34616: PUSH
34617: LD_INT 0
34619: PUSH
34620: LD_INT 2
34622: NEG
34623: PUSH
34624: EMPTY
34625: LIST
34626: LIST
34627: PUSH
34628: LD_INT 1
34630: PUSH
34631: LD_INT 1
34633: NEG
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: LD_INT 2
34641: PUSH
34642: LD_INT 0
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: PUSH
34649: LD_INT 2
34651: PUSH
34652: LD_INT 1
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 2
34661: PUSH
34662: LD_INT 2
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: LD_INT 1
34671: PUSH
34672: LD_INT 2
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: LD_INT 0
34681: PUSH
34682: LD_INT 2
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 1
34691: NEG
34692: PUSH
34693: LD_INT 1
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 2
34702: NEG
34703: PUSH
34704: LD_INT 0
34706: PUSH
34707: EMPTY
34708: LIST
34709: LIST
34710: PUSH
34711: LD_INT 2
34713: NEG
34714: PUSH
34715: LD_INT 1
34717: NEG
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 2
34725: NEG
34726: PUSH
34727: LD_INT 2
34729: NEG
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: LD_INT 2
34737: PUSH
34738: LD_INT 3
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 1
34747: PUSH
34748: LD_INT 3
34750: PUSH
34751: EMPTY
34752: LIST
34753: LIST
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: LD_INT 2
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 2
34768: NEG
34769: PUSH
34770: LD_INT 1
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: LIST
34787: LIST
34788: LIST
34789: LIST
34790: LIST
34791: LIST
34792: LIST
34793: LIST
34794: LIST
34795: LIST
34796: LIST
34797: LIST
34798: LIST
34799: LIST
34800: LIST
34801: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34802: LD_ADDR_VAR 0 27
34806: PUSH
34807: LD_INT 0
34809: PUSH
34810: LD_INT 0
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 0
34819: PUSH
34820: LD_INT 1
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 1
34830: PUSH
34831: LD_INT 0
34833: PUSH
34834: EMPTY
34835: LIST
34836: LIST
34837: PUSH
34838: LD_INT 1
34840: PUSH
34841: LD_INT 1
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 0
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 1
34860: NEG
34861: PUSH
34862: LD_INT 0
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 1
34871: NEG
34872: PUSH
34873: LD_INT 1
34875: NEG
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 1
34883: NEG
34884: PUSH
34885: LD_INT 2
34887: NEG
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 0
34895: PUSH
34896: LD_INT 2
34898: NEG
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 1
34906: PUSH
34907: LD_INT 1
34909: NEG
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 2
34917: PUSH
34918: LD_INT 0
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 2
34927: PUSH
34928: LD_INT 1
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 2
34937: PUSH
34938: LD_INT 2
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: LD_INT 2
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 0
34957: PUSH
34958: LD_INT 2
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 1
34967: NEG
34968: PUSH
34969: LD_INT 1
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PUSH
34976: LD_INT 2
34978: NEG
34979: PUSH
34980: LD_INT 0
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 2
34989: NEG
34990: PUSH
34991: LD_INT 1
34993: NEG
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 2
35001: NEG
35002: PUSH
35003: LD_INT 2
35005: NEG
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: LD_INT 2
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 2
35024: NEG
35025: PUSH
35026: LD_INT 1
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 3
35035: NEG
35036: PUSH
35037: LD_INT 1
35039: NEG
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: LD_INT 3
35047: NEG
35048: PUSH
35049: LD_INT 2
35051: NEG
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: LIST
35063: LIST
35064: LIST
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35082: LD_ADDR_VAR 0 28
35086: PUSH
35087: LD_INT 0
35089: PUSH
35090: LD_INT 0
35092: PUSH
35093: EMPTY
35094: LIST
35095: LIST
35096: PUSH
35097: LD_INT 0
35099: PUSH
35100: LD_INT 1
35102: NEG
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 1
35110: PUSH
35111: LD_INT 0
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 1
35120: PUSH
35121: LD_INT 1
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 0
35130: PUSH
35131: LD_INT 1
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 1
35140: NEG
35141: PUSH
35142: LD_INT 0
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: PUSH
35149: LD_INT 1
35151: NEG
35152: PUSH
35153: LD_INT 1
35155: NEG
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: LD_INT 1
35163: NEG
35164: PUSH
35165: LD_INT 2
35167: NEG
35168: PUSH
35169: EMPTY
35170: LIST
35171: LIST
35172: PUSH
35173: LD_INT 0
35175: PUSH
35176: LD_INT 2
35178: NEG
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 1
35186: PUSH
35187: LD_INT 1
35189: NEG
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 2
35197: PUSH
35198: LD_INT 0
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PUSH
35205: LD_INT 2
35207: PUSH
35208: LD_INT 1
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 2
35217: PUSH
35218: LD_INT 2
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PUSH
35225: LD_INT 1
35227: PUSH
35228: LD_INT 2
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: LD_INT 0
35237: PUSH
35238: LD_INT 2
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 1
35247: NEG
35248: PUSH
35249: LD_INT 1
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 2
35258: NEG
35259: PUSH
35260: LD_INT 0
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 2
35269: NEG
35270: PUSH
35271: LD_INT 1
35273: NEG
35274: PUSH
35275: EMPTY
35276: LIST
35277: LIST
35278: PUSH
35279: LD_INT 2
35281: NEG
35282: PUSH
35283: LD_INT 2
35285: NEG
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: PUSH
35291: LD_INT 2
35293: NEG
35294: PUSH
35295: LD_INT 3
35297: NEG
35298: PUSH
35299: EMPTY
35300: LIST
35301: LIST
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: LD_INT 3
35309: NEG
35310: PUSH
35311: EMPTY
35312: LIST
35313: LIST
35314: PUSH
35315: LD_INT 3
35317: NEG
35318: PUSH
35319: LD_INT 1
35321: NEG
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 3
35329: NEG
35330: PUSH
35331: LD_INT 2
35333: NEG
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: LIST
35343: LIST
35344: LIST
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: LIST
35357: LIST
35358: LIST
35359: LIST
35360: LIST
35361: LIST
35362: LIST
35363: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35364: LD_ADDR_VAR 0 29
35368: PUSH
35369: LD_INT 0
35371: PUSH
35372: LD_INT 0
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 0
35381: PUSH
35382: LD_INT 1
35384: NEG
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 1
35392: PUSH
35393: LD_INT 0
35395: PUSH
35396: EMPTY
35397: LIST
35398: LIST
35399: PUSH
35400: LD_INT 1
35402: PUSH
35403: LD_INT 1
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: LD_INT 0
35412: PUSH
35413: LD_INT 1
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: LD_INT 1
35422: NEG
35423: PUSH
35424: LD_INT 0
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: PUSH
35431: LD_INT 1
35433: NEG
35434: PUSH
35435: LD_INT 1
35437: NEG
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: PUSH
35443: LD_INT 1
35445: NEG
35446: PUSH
35447: LD_INT 2
35449: NEG
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 0
35457: PUSH
35458: LD_INT 2
35460: NEG
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: PUSH
35469: LD_INT 1
35471: NEG
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 2
35479: PUSH
35480: LD_INT 0
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 2
35489: PUSH
35490: LD_INT 1
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: LD_INT 2
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: LD_INT 2
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 1
35519: NEG
35520: PUSH
35521: LD_INT 1
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 2
35530: NEG
35531: PUSH
35532: LD_INT 1
35534: NEG
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: PUSH
35540: LD_INT 2
35542: NEG
35543: PUSH
35544: LD_INT 2
35546: NEG
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 2
35554: NEG
35555: PUSH
35556: LD_INT 3
35558: NEG
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: PUSH
35564: LD_INT 2
35566: PUSH
35567: LD_INT 1
35569: NEG
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 3
35577: PUSH
35578: LD_INT 1
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 1
35587: PUSH
35588: LD_INT 3
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 1
35597: NEG
35598: PUSH
35599: LD_INT 2
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 3
35608: NEG
35609: PUSH
35610: LD_INT 2
35612: NEG
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: EMPTY
35619: LIST
35620: LIST
35621: LIST
35622: LIST
35623: LIST
35624: LIST
35625: LIST
35626: LIST
35627: LIST
35628: LIST
35629: LIST
35630: LIST
35631: LIST
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: LIST
35637: LIST
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35643: LD_ADDR_VAR 0 30
35647: PUSH
35648: LD_INT 0
35650: PUSH
35651: LD_INT 0
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 0
35660: PUSH
35661: LD_INT 1
35663: NEG
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: LD_INT 1
35671: PUSH
35672: LD_INT 0
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 1
35681: PUSH
35682: LD_INT 1
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 0
35691: PUSH
35692: LD_INT 1
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: LD_INT 1
35701: NEG
35702: PUSH
35703: LD_INT 0
35705: PUSH
35706: EMPTY
35707: LIST
35708: LIST
35709: PUSH
35710: LD_INT 1
35712: NEG
35713: PUSH
35714: LD_INT 1
35716: NEG
35717: PUSH
35718: EMPTY
35719: LIST
35720: LIST
35721: PUSH
35722: LD_INT 1
35724: NEG
35725: PUSH
35726: LD_INT 2
35728: NEG
35729: PUSH
35730: EMPTY
35731: LIST
35732: LIST
35733: PUSH
35734: LD_INT 0
35736: PUSH
35737: LD_INT 2
35739: NEG
35740: PUSH
35741: EMPTY
35742: LIST
35743: LIST
35744: PUSH
35745: LD_INT 1
35747: PUSH
35748: LD_INT 1
35750: NEG
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 2
35758: PUSH
35759: LD_INT 0
35761: PUSH
35762: EMPTY
35763: LIST
35764: LIST
35765: PUSH
35766: LD_INT 2
35768: PUSH
35769: LD_INT 1
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PUSH
35776: LD_INT 2
35778: PUSH
35779: LD_INT 2
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PUSH
35786: LD_INT 1
35788: PUSH
35789: LD_INT 2
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: LD_INT 1
35798: NEG
35799: PUSH
35800: LD_INT 1
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 2
35809: NEG
35810: PUSH
35811: LD_INT 0
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 2
35820: NEG
35821: PUSH
35822: LD_INT 1
35824: NEG
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 1
35832: NEG
35833: PUSH
35834: LD_INT 3
35836: NEG
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: LD_INT 1
35844: PUSH
35845: LD_INT 2
35847: NEG
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: LD_INT 3
35855: PUSH
35856: LD_INT 2
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: LD_INT 2
35865: PUSH
35866: LD_INT 3
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PUSH
35873: LD_INT 2
35875: NEG
35876: PUSH
35877: LD_INT 1
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: PUSH
35884: LD_INT 3
35886: NEG
35887: PUSH
35888: LD_INT 1
35890: NEG
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: EMPTY
35897: LIST
35898: LIST
35899: LIST
35900: LIST
35901: LIST
35902: LIST
35903: LIST
35904: LIST
35905: LIST
35906: LIST
35907: LIST
35908: LIST
35909: LIST
35910: LIST
35911: LIST
35912: LIST
35913: LIST
35914: LIST
35915: LIST
35916: LIST
35917: LIST
35918: LIST
35919: LIST
35920: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35921: LD_ADDR_VAR 0 31
35925: PUSH
35926: LD_INT 0
35928: PUSH
35929: LD_INT 0
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 0
35938: PUSH
35939: LD_INT 1
35941: NEG
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 1
35949: PUSH
35950: LD_INT 0
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 1
35959: PUSH
35960: LD_INT 1
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: LD_INT 0
35969: PUSH
35970: LD_INT 1
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 1
35979: NEG
35980: PUSH
35981: LD_INT 0
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 1
35990: NEG
35991: PUSH
35992: LD_INT 1
35994: NEG
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 1
36002: NEG
36003: PUSH
36004: LD_INT 2
36006: NEG
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 1
36014: PUSH
36015: LD_INT 1
36017: NEG
36018: PUSH
36019: EMPTY
36020: LIST
36021: LIST
36022: PUSH
36023: LD_INT 2
36025: PUSH
36026: LD_INT 0
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 2
36035: PUSH
36036: LD_INT 1
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: PUSH
36043: LD_INT 2
36045: PUSH
36046: LD_INT 2
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 1
36055: PUSH
36056: LD_INT 2
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: LD_INT 0
36065: PUSH
36066: LD_INT 2
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: LD_INT 1
36075: NEG
36076: PUSH
36077: LD_INT 1
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 2
36086: NEG
36087: PUSH
36088: LD_INT 1
36090: NEG
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 2
36098: NEG
36099: PUSH
36100: LD_INT 2
36102: NEG
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 2
36110: NEG
36111: PUSH
36112: LD_INT 3
36114: NEG
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: LD_INT 2
36122: PUSH
36123: LD_INT 1
36125: NEG
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 3
36133: PUSH
36134: LD_INT 1
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 1
36143: PUSH
36144: LD_INT 3
36146: PUSH
36147: EMPTY
36148: LIST
36149: LIST
36150: PUSH
36151: LD_INT 1
36153: NEG
36154: PUSH
36155: LD_INT 2
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PUSH
36162: LD_INT 3
36164: NEG
36165: PUSH
36166: LD_INT 2
36168: NEG
36169: PUSH
36170: EMPTY
36171: LIST
36172: LIST
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: LIST
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36199: LD_ADDR_VAR 0 32
36203: PUSH
36204: LD_INT 0
36206: PUSH
36207: LD_INT 0
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 0
36216: PUSH
36217: LD_INT 1
36219: NEG
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 1
36227: PUSH
36228: LD_INT 0
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 1
36237: PUSH
36238: LD_INT 1
36240: PUSH
36241: EMPTY
36242: LIST
36243: LIST
36244: PUSH
36245: LD_INT 0
36247: PUSH
36248: LD_INT 1
36250: PUSH
36251: EMPTY
36252: LIST
36253: LIST
36254: PUSH
36255: LD_INT 1
36257: NEG
36258: PUSH
36259: LD_INT 0
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 1
36268: NEG
36269: PUSH
36270: LD_INT 1
36272: NEG
36273: PUSH
36274: EMPTY
36275: LIST
36276: LIST
36277: PUSH
36278: LD_INT 1
36280: NEG
36281: PUSH
36282: LD_INT 2
36284: NEG
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 0
36292: PUSH
36293: LD_INT 2
36295: NEG
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 1
36303: PUSH
36304: LD_INT 1
36306: NEG
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: PUSH
36312: LD_INT 2
36314: PUSH
36315: LD_INT 1
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: LD_INT 2
36324: PUSH
36325: LD_INT 2
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: LD_INT 2
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 0
36344: PUSH
36345: LD_INT 2
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: PUSH
36352: LD_INT 1
36354: NEG
36355: PUSH
36356: LD_INT 1
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: LD_INT 2
36365: NEG
36366: PUSH
36367: LD_INT 0
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: PUSH
36374: LD_INT 2
36376: NEG
36377: PUSH
36378: LD_INT 1
36380: NEG
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: PUSH
36386: LD_INT 1
36388: NEG
36389: PUSH
36390: LD_INT 3
36392: NEG
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 1
36400: PUSH
36401: LD_INT 2
36403: NEG
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 3
36411: PUSH
36412: LD_INT 2
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 2
36421: PUSH
36422: LD_INT 3
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 2
36431: NEG
36432: PUSH
36433: LD_INT 1
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: LD_INT 3
36442: NEG
36443: PUSH
36444: LD_INT 1
36446: NEG
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: LIST
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36477: LD_ADDR_VAR 0 33
36481: PUSH
36482: LD_INT 0
36484: PUSH
36485: LD_INT 0
36487: PUSH
36488: EMPTY
36489: LIST
36490: LIST
36491: PUSH
36492: LD_INT 0
36494: PUSH
36495: LD_INT 1
36497: NEG
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 1
36505: PUSH
36506: LD_INT 0
36508: PUSH
36509: EMPTY
36510: LIST
36511: LIST
36512: PUSH
36513: LD_INT 1
36515: PUSH
36516: LD_INT 1
36518: PUSH
36519: EMPTY
36520: LIST
36521: LIST
36522: PUSH
36523: LD_INT 0
36525: PUSH
36526: LD_INT 1
36528: PUSH
36529: EMPTY
36530: LIST
36531: LIST
36532: PUSH
36533: LD_INT 1
36535: NEG
36536: PUSH
36537: LD_INT 0
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: PUSH
36544: LD_INT 1
36546: NEG
36547: PUSH
36548: LD_INT 1
36550: NEG
36551: PUSH
36552: EMPTY
36553: LIST
36554: LIST
36555: PUSH
36556: LD_INT 1
36558: NEG
36559: PUSH
36560: LD_INT 2
36562: NEG
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 1
36570: PUSH
36571: LD_INT 1
36573: NEG
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 2
36581: PUSH
36582: LD_INT 0
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: PUSH
36589: LD_INT 2
36591: PUSH
36592: LD_INT 1
36594: PUSH
36595: EMPTY
36596: LIST
36597: LIST
36598: PUSH
36599: LD_INT 1
36601: PUSH
36602: LD_INT 2
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: LD_INT 0
36611: PUSH
36612: LD_INT 2
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 1
36621: NEG
36622: PUSH
36623: LD_INT 1
36625: PUSH
36626: EMPTY
36627: LIST
36628: LIST
36629: PUSH
36630: LD_INT 2
36632: NEG
36633: PUSH
36634: LD_INT 0
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 2
36643: NEG
36644: PUSH
36645: LD_INT 1
36647: NEG
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 2
36655: NEG
36656: PUSH
36657: LD_INT 2
36659: NEG
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 2
36667: NEG
36668: PUSH
36669: LD_INT 3
36671: NEG
36672: PUSH
36673: EMPTY
36674: LIST
36675: LIST
36676: PUSH
36677: LD_INT 2
36679: PUSH
36680: LD_INT 1
36682: NEG
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 3
36690: PUSH
36691: LD_INT 1
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 1
36700: PUSH
36701: LD_INT 3
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 1
36710: NEG
36711: PUSH
36712: LD_INT 2
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 3
36721: NEG
36722: PUSH
36723: LD_INT 2
36725: NEG
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: EMPTY
36732: LIST
36733: LIST
36734: LIST
36735: LIST
36736: LIST
36737: LIST
36738: LIST
36739: LIST
36740: LIST
36741: LIST
36742: LIST
36743: LIST
36744: LIST
36745: LIST
36746: LIST
36747: LIST
36748: LIST
36749: LIST
36750: LIST
36751: LIST
36752: LIST
36753: LIST
36754: LIST
36755: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36756: LD_ADDR_VAR 0 34
36760: PUSH
36761: LD_INT 0
36763: PUSH
36764: LD_INT 0
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 0
36773: PUSH
36774: LD_INT 1
36776: NEG
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: LD_INT 1
36784: PUSH
36785: LD_INT 0
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 1
36794: PUSH
36795: LD_INT 1
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 0
36804: PUSH
36805: LD_INT 1
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 1
36814: NEG
36815: PUSH
36816: LD_INT 0
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 1
36825: NEG
36826: PUSH
36827: LD_INT 1
36829: NEG
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 1
36837: NEG
36838: PUSH
36839: LD_INT 2
36841: NEG
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PUSH
36847: LD_INT 0
36849: PUSH
36850: LD_INT 2
36852: NEG
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 1
36860: PUSH
36861: LD_INT 1
36863: NEG
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 2
36871: PUSH
36872: LD_INT 1
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 2
36881: PUSH
36882: LD_INT 2
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 1
36891: PUSH
36892: LD_INT 2
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 1
36901: NEG
36902: PUSH
36903: LD_INT 1
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PUSH
36910: LD_INT 2
36912: NEG
36913: PUSH
36914: LD_INT 0
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: LD_INT 2
36923: NEG
36924: PUSH
36925: LD_INT 1
36927: NEG
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: PUSH
36933: LD_INT 2
36935: NEG
36936: PUSH
36937: LD_INT 2
36939: NEG
36940: PUSH
36941: EMPTY
36942: LIST
36943: LIST
36944: PUSH
36945: LD_INT 1
36947: NEG
36948: PUSH
36949: LD_INT 3
36951: NEG
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 1
36959: PUSH
36960: LD_INT 2
36962: NEG
36963: PUSH
36964: EMPTY
36965: LIST
36966: LIST
36967: PUSH
36968: LD_INT 3
36970: PUSH
36971: LD_INT 2
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: LD_INT 2
36980: PUSH
36981: LD_INT 3
36983: PUSH
36984: EMPTY
36985: LIST
36986: LIST
36987: PUSH
36988: LD_INT 2
36990: NEG
36991: PUSH
36992: LD_INT 1
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: PUSH
36999: LD_INT 3
37001: NEG
37002: PUSH
37003: LD_INT 1
37005: NEG
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: LIST
37022: LIST
37023: LIST
37024: LIST
37025: LIST
37026: LIST
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: LIST
37034: LIST
37035: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37036: LD_ADDR_VAR 0 35
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: LD_INT 0
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 0
37053: PUSH
37054: LD_INT 1
37056: NEG
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: LD_INT 1
37064: PUSH
37065: LD_INT 0
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: LD_INT 1
37074: PUSH
37075: LD_INT 1
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 0
37084: PUSH
37085: LD_INT 1
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 1
37094: NEG
37095: PUSH
37096: LD_INT 0
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 1
37105: NEG
37106: PUSH
37107: LD_INT 1
37109: NEG
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: PUSH
37115: LD_INT 2
37117: PUSH
37118: LD_INT 1
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: PUSH
37125: LD_INT 2
37127: NEG
37128: PUSH
37129: LD_INT 1
37131: NEG
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: EMPTY
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: LIST
37145: LIST
37146: LIST
37147: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37148: LD_ADDR_VAR 0 36
37152: PUSH
37153: LD_INT 0
37155: PUSH
37156: LD_INT 0
37158: PUSH
37159: EMPTY
37160: LIST
37161: LIST
37162: PUSH
37163: LD_INT 0
37165: PUSH
37166: LD_INT 1
37168: NEG
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: LD_INT 0
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 1
37186: PUSH
37187: LD_INT 1
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 0
37196: PUSH
37197: LD_INT 1
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 1
37206: NEG
37207: PUSH
37208: LD_INT 0
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 1
37217: NEG
37218: PUSH
37219: LD_INT 1
37221: NEG
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: LD_INT 1
37229: NEG
37230: PUSH
37231: LD_INT 2
37233: NEG
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 1
37241: PUSH
37242: LD_INT 2
37244: PUSH
37245: EMPTY
37246: LIST
37247: LIST
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: LIST
37253: LIST
37254: LIST
37255: LIST
37256: LIST
37257: LIST
37258: LIST
37259: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37260: LD_ADDR_VAR 0 37
37264: PUSH
37265: LD_INT 0
37267: PUSH
37268: LD_INT 0
37270: PUSH
37271: EMPTY
37272: LIST
37273: LIST
37274: PUSH
37275: LD_INT 0
37277: PUSH
37278: LD_INT 1
37280: NEG
37281: PUSH
37282: EMPTY
37283: LIST
37284: LIST
37285: PUSH
37286: LD_INT 1
37288: PUSH
37289: LD_INT 0
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: LD_INT 1
37298: PUSH
37299: LD_INT 1
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 0
37308: PUSH
37309: LD_INT 1
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 1
37318: NEG
37319: PUSH
37320: LD_INT 0
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 1
37329: NEG
37330: PUSH
37331: LD_INT 1
37333: NEG
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: LD_INT 1
37341: PUSH
37342: LD_INT 1
37344: NEG
37345: PUSH
37346: EMPTY
37347: LIST
37348: LIST
37349: PUSH
37350: LD_INT 1
37352: NEG
37353: PUSH
37354: LD_INT 1
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: LIST
37368: LIST
37369: LIST
37370: LIST
37371: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37372: LD_ADDR_VAR 0 38
37376: PUSH
37377: LD_INT 0
37379: PUSH
37380: LD_INT 0
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: PUSH
37387: LD_INT 0
37389: PUSH
37390: LD_INT 1
37392: NEG
37393: PUSH
37394: EMPTY
37395: LIST
37396: LIST
37397: PUSH
37398: LD_INT 1
37400: PUSH
37401: LD_INT 0
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: LD_INT 1
37410: PUSH
37411: LD_INT 1
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: PUSH
37418: LD_INT 0
37420: PUSH
37421: LD_INT 1
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: PUSH
37428: LD_INT 1
37430: NEG
37431: PUSH
37432: LD_INT 0
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: LD_INT 1
37441: NEG
37442: PUSH
37443: LD_INT 1
37445: NEG
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: LD_INT 2
37453: PUSH
37454: LD_INT 1
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: LD_INT 2
37463: NEG
37464: PUSH
37465: LD_INT 1
37467: NEG
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: LIST
37477: LIST
37478: LIST
37479: LIST
37480: LIST
37481: LIST
37482: LIST
37483: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37484: LD_ADDR_VAR 0 39
37488: PUSH
37489: LD_INT 0
37491: PUSH
37492: LD_INT 0
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 0
37501: PUSH
37502: LD_INT 1
37504: NEG
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 1
37512: PUSH
37513: LD_INT 0
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 1
37522: PUSH
37523: LD_INT 1
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 0
37532: PUSH
37533: LD_INT 1
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: NEG
37543: PUSH
37544: LD_INT 0
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: LD_INT 1
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 1
37565: NEG
37566: PUSH
37567: LD_INT 2
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 1
37577: PUSH
37578: LD_INT 2
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: LIST
37592: LIST
37593: LIST
37594: LIST
37595: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37596: LD_ADDR_VAR 0 40
37600: PUSH
37601: LD_INT 0
37603: PUSH
37604: LD_INT 0
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 0
37613: PUSH
37614: LD_INT 1
37616: NEG
37617: PUSH
37618: EMPTY
37619: LIST
37620: LIST
37621: PUSH
37622: LD_INT 1
37624: PUSH
37625: LD_INT 0
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: LD_INT 1
37634: PUSH
37635: LD_INT 1
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 0
37644: PUSH
37645: LD_INT 1
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 1
37654: NEG
37655: PUSH
37656: LD_INT 0
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: LD_INT 1
37665: NEG
37666: PUSH
37667: LD_INT 1
37669: NEG
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 1
37677: PUSH
37678: LD_INT 1
37680: NEG
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 1
37688: NEG
37689: PUSH
37690: LD_INT 1
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: EMPTY
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37708: LD_ADDR_VAR 0 41
37712: PUSH
37713: LD_INT 0
37715: PUSH
37716: LD_INT 0
37718: PUSH
37719: EMPTY
37720: LIST
37721: LIST
37722: PUSH
37723: LD_INT 0
37725: PUSH
37726: LD_INT 1
37728: NEG
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: LD_INT 0
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 1
37746: PUSH
37747: LD_INT 1
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PUSH
37754: LD_INT 0
37756: PUSH
37757: LD_INT 1
37759: PUSH
37760: EMPTY
37761: LIST
37762: LIST
37763: PUSH
37764: LD_INT 1
37766: NEG
37767: PUSH
37768: LD_INT 0
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 1
37777: NEG
37778: PUSH
37779: LD_INT 1
37781: NEG
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: LD_INT 1
37789: NEG
37790: PUSH
37791: LD_INT 2
37793: NEG
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 1
37801: PUSH
37802: LD_INT 1
37804: NEG
37805: PUSH
37806: EMPTY
37807: LIST
37808: LIST
37809: PUSH
37810: LD_INT 2
37812: PUSH
37813: LD_INT 0
37815: PUSH
37816: EMPTY
37817: LIST
37818: LIST
37819: PUSH
37820: LD_INT 2
37822: PUSH
37823: LD_INT 1
37825: PUSH
37826: EMPTY
37827: LIST
37828: LIST
37829: PUSH
37830: LD_INT 2
37832: PUSH
37833: LD_INT 2
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: LD_INT 1
37842: PUSH
37843: LD_INT 2
37845: PUSH
37846: EMPTY
37847: LIST
37848: LIST
37849: PUSH
37850: LD_INT 1
37852: NEG
37853: PUSH
37854: LD_INT 1
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 2
37863: NEG
37864: PUSH
37865: LD_INT 0
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 2
37874: NEG
37875: PUSH
37876: LD_INT 1
37878: NEG
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 2
37886: NEG
37887: PUSH
37888: LD_INT 2
37890: NEG
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 2
37898: NEG
37899: PUSH
37900: LD_INT 3
37902: NEG
37903: PUSH
37904: EMPTY
37905: LIST
37906: LIST
37907: PUSH
37908: LD_INT 2
37910: PUSH
37911: LD_INT 1
37913: NEG
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 3
37921: PUSH
37922: LD_INT 0
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 3
37931: PUSH
37932: LD_INT 1
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 3
37941: PUSH
37942: LD_INT 2
37944: PUSH
37945: EMPTY
37946: LIST
37947: LIST
37948: PUSH
37949: LD_INT 3
37951: PUSH
37952: LD_INT 3
37954: PUSH
37955: EMPTY
37956: LIST
37957: LIST
37958: PUSH
37959: LD_INT 2
37961: PUSH
37962: LD_INT 3
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: PUSH
37969: LD_INT 2
37971: NEG
37972: PUSH
37973: LD_INT 1
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: PUSH
37980: LD_INT 3
37982: NEG
37983: PUSH
37984: LD_INT 0
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: PUSH
37991: LD_INT 3
37993: NEG
37994: PUSH
37995: LD_INT 1
37997: NEG
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 3
38005: NEG
38006: PUSH
38007: LD_INT 2
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 3
38017: NEG
38018: PUSH
38019: LD_INT 3
38021: NEG
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: LIST
38031: LIST
38032: LIST
38033: LIST
38034: LIST
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38058: LD_ADDR_VAR 0 42
38062: PUSH
38063: LD_INT 0
38065: PUSH
38066: LD_INT 0
38068: PUSH
38069: EMPTY
38070: LIST
38071: LIST
38072: PUSH
38073: LD_INT 0
38075: PUSH
38076: LD_INT 1
38078: NEG
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 1
38086: PUSH
38087: LD_INT 0
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: PUSH
38094: LD_INT 1
38096: PUSH
38097: LD_INT 1
38099: PUSH
38100: EMPTY
38101: LIST
38102: LIST
38103: PUSH
38104: LD_INT 0
38106: PUSH
38107: LD_INT 1
38109: PUSH
38110: EMPTY
38111: LIST
38112: LIST
38113: PUSH
38114: LD_INT 1
38116: NEG
38117: PUSH
38118: LD_INT 0
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: LD_INT 1
38127: NEG
38128: PUSH
38129: LD_INT 1
38131: NEG
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 1
38139: NEG
38140: PUSH
38141: LD_INT 2
38143: NEG
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 0
38151: PUSH
38152: LD_INT 2
38154: NEG
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 1
38162: PUSH
38163: LD_INT 1
38165: NEG
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 2
38173: PUSH
38174: LD_INT 1
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 2
38183: PUSH
38184: LD_INT 2
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 1
38193: PUSH
38194: LD_INT 2
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: LD_INT 0
38203: PUSH
38204: LD_INT 2
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: PUSH
38211: LD_INT 1
38213: NEG
38214: PUSH
38215: LD_INT 1
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 2
38224: NEG
38225: PUSH
38226: LD_INT 1
38228: NEG
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: LD_INT 2
38236: NEG
38237: PUSH
38238: LD_INT 2
38240: NEG
38241: PUSH
38242: EMPTY
38243: LIST
38244: LIST
38245: PUSH
38246: LD_INT 2
38248: NEG
38249: PUSH
38250: LD_INT 3
38252: NEG
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 1
38260: NEG
38261: PUSH
38262: LD_INT 3
38264: NEG
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: LD_INT 0
38272: PUSH
38273: LD_INT 3
38275: NEG
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PUSH
38281: LD_INT 1
38283: PUSH
38284: LD_INT 2
38286: NEG
38287: PUSH
38288: EMPTY
38289: LIST
38290: LIST
38291: PUSH
38292: LD_INT 3
38294: PUSH
38295: LD_INT 2
38297: PUSH
38298: EMPTY
38299: LIST
38300: LIST
38301: PUSH
38302: LD_INT 3
38304: PUSH
38305: LD_INT 3
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: PUSH
38312: LD_INT 2
38314: PUSH
38315: LD_INT 3
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: PUSH
38322: LD_INT 1
38324: PUSH
38325: LD_INT 3
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: LD_INT 0
38334: PUSH
38335: LD_INT 3
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 1
38344: NEG
38345: PUSH
38346: LD_INT 2
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 3
38355: NEG
38356: PUSH
38357: LD_INT 2
38359: NEG
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: LD_INT 3
38367: NEG
38368: PUSH
38369: LD_INT 3
38371: NEG
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: EMPTY
38378: LIST
38379: LIST
38380: LIST
38381: LIST
38382: LIST
38383: LIST
38384: LIST
38385: LIST
38386: LIST
38387: LIST
38388: LIST
38389: LIST
38390: LIST
38391: LIST
38392: LIST
38393: LIST
38394: LIST
38395: LIST
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38408: LD_ADDR_VAR 0 43
38412: PUSH
38413: LD_INT 0
38415: PUSH
38416: LD_INT 0
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: LD_INT 0
38425: PUSH
38426: LD_INT 1
38428: NEG
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 1
38436: PUSH
38437: LD_INT 0
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 1
38446: PUSH
38447: LD_INT 1
38449: PUSH
38450: EMPTY
38451: LIST
38452: LIST
38453: PUSH
38454: LD_INT 0
38456: PUSH
38457: LD_INT 1
38459: PUSH
38460: EMPTY
38461: LIST
38462: LIST
38463: PUSH
38464: LD_INT 1
38466: NEG
38467: PUSH
38468: LD_INT 0
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: PUSH
38475: LD_INT 1
38477: NEG
38478: PUSH
38479: LD_INT 1
38481: NEG
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: LD_INT 1
38489: NEG
38490: PUSH
38491: LD_INT 2
38493: NEG
38494: PUSH
38495: EMPTY
38496: LIST
38497: LIST
38498: PUSH
38499: LD_INT 0
38501: PUSH
38502: LD_INT 2
38504: NEG
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 1
38512: PUSH
38513: LD_INT 1
38515: NEG
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PUSH
38521: LD_INT 2
38523: PUSH
38524: LD_INT 0
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: LD_INT 2
38533: PUSH
38534: LD_INT 1
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: PUSH
38544: LD_INT 2
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 0
38553: PUSH
38554: LD_INT 2
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 1
38563: NEG
38564: PUSH
38565: LD_INT 1
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 2
38574: NEG
38575: PUSH
38576: LD_INT 0
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 2
38585: NEG
38586: PUSH
38587: LD_INT 1
38589: NEG
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 1
38597: NEG
38598: PUSH
38599: LD_INT 3
38601: NEG
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 0
38609: PUSH
38610: LD_INT 3
38612: NEG
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 1
38620: PUSH
38621: LD_INT 2
38623: NEG
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 2
38631: PUSH
38632: LD_INT 1
38634: NEG
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: LD_INT 3
38642: PUSH
38643: LD_INT 0
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: PUSH
38650: LD_INT 3
38652: PUSH
38653: LD_INT 1
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: LD_INT 1
38662: PUSH
38663: LD_INT 3
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: PUSH
38670: LD_INT 0
38672: PUSH
38673: LD_INT 3
38675: PUSH
38676: EMPTY
38677: LIST
38678: LIST
38679: PUSH
38680: LD_INT 1
38682: NEG
38683: PUSH
38684: LD_INT 2
38686: PUSH
38687: EMPTY
38688: LIST
38689: LIST
38690: PUSH
38691: LD_INT 2
38693: NEG
38694: PUSH
38695: LD_INT 1
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 3
38704: NEG
38705: PUSH
38706: LD_INT 0
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PUSH
38713: LD_INT 3
38715: NEG
38716: PUSH
38717: LD_INT 1
38719: NEG
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38756: LD_ADDR_VAR 0 44
38760: PUSH
38761: LD_INT 0
38763: PUSH
38764: LD_INT 0
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 0
38773: PUSH
38774: LD_INT 1
38776: NEG
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 1
38784: PUSH
38785: LD_INT 0
38787: PUSH
38788: EMPTY
38789: LIST
38790: LIST
38791: PUSH
38792: LD_INT 1
38794: PUSH
38795: LD_INT 1
38797: PUSH
38798: EMPTY
38799: LIST
38800: LIST
38801: PUSH
38802: LD_INT 0
38804: PUSH
38805: LD_INT 1
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 1
38814: NEG
38815: PUSH
38816: LD_INT 0
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: PUSH
38823: LD_INT 1
38825: NEG
38826: PUSH
38827: LD_INT 1
38829: NEG
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 1
38837: NEG
38838: PUSH
38839: LD_INT 2
38841: NEG
38842: PUSH
38843: EMPTY
38844: LIST
38845: LIST
38846: PUSH
38847: LD_INT 1
38849: PUSH
38850: LD_INT 1
38852: NEG
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PUSH
38858: LD_INT 2
38860: PUSH
38861: LD_INT 0
38863: PUSH
38864: EMPTY
38865: LIST
38866: LIST
38867: PUSH
38868: LD_INT 2
38870: PUSH
38871: LD_INT 1
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: PUSH
38878: LD_INT 2
38880: PUSH
38881: LD_INT 2
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PUSH
38888: LD_INT 1
38890: PUSH
38891: LD_INT 2
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: PUSH
38898: LD_INT 1
38900: NEG
38901: PUSH
38902: LD_INT 1
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PUSH
38909: LD_INT 2
38911: NEG
38912: PUSH
38913: LD_INT 0
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PUSH
38920: LD_INT 2
38922: NEG
38923: PUSH
38924: LD_INT 1
38926: NEG
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 2
38934: NEG
38935: PUSH
38936: LD_INT 2
38938: NEG
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: LD_INT 2
38946: NEG
38947: PUSH
38948: LD_INT 3
38950: NEG
38951: PUSH
38952: EMPTY
38953: LIST
38954: LIST
38955: PUSH
38956: LD_INT 2
38958: PUSH
38959: LD_INT 1
38961: NEG
38962: PUSH
38963: EMPTY
38964: LIST
38965: LIST
38966: PUSH
38967: LD_INT 3
38969: PUSH
38970: LD_INT 0
38972: PUSH
38973: EMPTY
38974: LIST
38975: LIST
38976: PUSH
38977: LD_INT 3
38979: PUSH
38980: LD_INT 1
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: PUSH
38987: LD_INT 3
38989: PUSH
38990: LD_INT 2
38992: PUSH
38993: EMPTY
38994: LIST
38995: LIST
38996: PUSH
38997: LD_INT 3
38999: PUSH
39000: LD_INT 3
39002: PUSH
39003: EMPTY
39004: LIST
39005: LIST
39006: PUSH
39007: LD_INT 2
39009: PUSH
39010: LD_INT 3
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: PUSH
39017: LD_INT 2
39019: NEG
39020: PUSH
39021: LD_INT 1
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 3
39030: NEG
39031: PUSH
39032: LD_INT 0
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 3
39041: NEG
39042: PUSH
39043: LD_INT 1
39045: NEG
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: PUSH
39051: LD_INT 3
39053: NEG
39054: PUSH
39055: LD_INT 2
39057: NEG
39058: PUSH
39059: EMPTY
39060: LIST
39061: LIST
39062: PUSH
39063: LD_INT 3
39065: NEG
39066: PUSH
39067: LD_INT 3
39069: NEG
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: LIST
39083: LIST
39084: LIST
39085: LIST
39086: LIST
39087: LIST
39088: LIST
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: LIST
39097: LIST
39098: LIST
39099: LIST
39100: LIST
39101: LIST
39102: LIST
39103: LIST
39104: LIST
39105: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39106: LD_ADDR_VAR 0 45
39110: PUSH
39111: LD_INT 0
39113: PUSH
39114: LD_INT 0
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PUSH
39121: LD_INT 0
39123: PUSH
39124: LD_INT 1
39126: NEG
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 1
39134: PUSH
39135: LD_INT 0
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: PUSH
39142: LD_INT 1
39144: PUSH
39145: LD_INT 1
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 0
39154: PUSH
39155: LD_INT 1
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 1
39164: NEG
39165: PUSH
39166: LD_INT 0
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: LD_INT 1
39175: NEG
39176: PUSH
39177: LD_INT 1
39179: NEG
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 1
39187: NEG
39188: PUSH
39189: LD_INT 2
39191: NEG
39192: PUSH
39193: EMPTY
39194: LIST
39195: LIST
39196: PUSH
39197: LD_INT 0
39199: PUSH
39200: LD_INT 2
39202: NEG
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 1
39210: PUSH
39211: LD_INT 1
39213: NEG
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: PUSH
39219: LD_INT 2
39221: PUSH
39222: LD_INT 1
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 2
39231: PUSH
39232: LD_INT 2
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: LD_INT 1
39241: PUSH
39242: LD_INT 2
39244: PUSH
39245: EMPTY
39246: LIST
39247: LIST
39248: PUSH
39249: LD_INT 0
39251: PUSH
39252: LD_INT 2
39254: PUSH
39255: EMPTY
39256: LIST
39257: LIST
39258: PUSH
39259: LD_INT 1
39261: NEG
39262: PUSH
39263: LD_INT 1
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 2
39272: NEG
39273: PUSH
39274: LD_INT 1
39276: NEG
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 2
39284: NEG
39285: PUSH
39286: LD_INT 2
39288: NEG
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: PUSH
39294: LD_INT 2
39296: NEG
39297: PUSH
39298: LD_INT 3
39300: NEG
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: LD_INT 1
39308: NEG
39309: PUSH
39310: LD_INT 3
39312: NEG
39313: PUSH
39314: EMPTY
39315: LIST
39316: LIST
39317: PUSH
39318: LD_INT 0
39320: PUSH
39321: LD_INT 3
39323: NEG
39324: PUSH
39325: EMPTY
39326: LIST
39327: LIST
39328: PUSH
39329: LD_INT 1
39331: PUSH
39332: LD_INT 2
39334: NEG
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: PUSH
39340: LD_INT 3
39342: PUSH
39343: LD_INT 2
39345: PUSH
39346: EMPTY
39347: LIST
39348: LIST
39349: PUSH
39350: LD_INT 3
39352: PUSH
39353: LD_INT 3
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: LD_INT 2
39362: PUSH
39363: LD_INT 3
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 1
39372: PUSH
39373: LD_INT 3
39375: PUSH
39376: EMPTY
39377: LIST
39378: LIST
39379: PUSH
39380: LD_INT 0
39382: PUSH
39383: LD_INT 3
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 1
39392: NEG
39393: PUSH
39394: LD_INT 2
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 3
39403: NEG
39404: PUSH
39405: LD_INT 2
39407: NEG
39408: PUSH
39409: EMPTY
39410: LIST
39411: LIST
39412: PUSH
39413: LD_INT 3
39415: NEG
39416: PUSH
39417: LD_INT 3
39419: NEG
39420: PUSH
39421: EMPTY
39422: LIST
39423: LIST
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: LIST
39429: LIST
39430: LIST
39431: LIST
39432: LIST
39433: LIST
39434: LIST
39435: LIST
39436: LIST
39437: LIST
39438: LIST
39439: LIST
39440: LIST
39441: LIST
39442: LIST
39443: LIST
39444: LIST
39445: LIST
39446: LIST
39447: LIST
39448: LIST
39449: LIST
39450: LIST
39451: LIST
39452: LIST
39453: LIST
39454: LIST
39455: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39456: LD_ADDR_VAR 0 46
39460: PUSH
39461: LD_INT 0
39463: PUSH
39464: LD_INT 0
39466: PUSH
39467: EMPTY
39468: LIST
39469: LIST
39470: PUSH
39471: LD_INT 0
39473: PUSH
39474: LD_INT 1
39476: NEG
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 1
39484: PUSH
39485: LD_INT 0
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 1
39494: PUSH
39495: LD_INT 1
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 0
39504: PUSH
39505: LD_INT 1
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 1
39514: NEG
39515: PUSH
39516: LD_INT 0
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 1
39525: NEG
39526: PUSH
39527: LD_INT 1
39529: NEG
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 1
39537: NEG
39538: PUSH
39539: LD_INT 2
39541: NEG
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PUSH
39547: LD_INT 0
39549: PUSH
39550: LD_INT 2
39552: NEG
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: LD_INT 1
39560: PUSH
39561: LD_INT 1
39563: NEG
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: LD_INT 2
39571: PUSH
39572: LD_INT 0
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 2
39581: PUSH
39582: LD_INT 1
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 1
39591: PUSH
39592: LD_INT 2
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 0
39601: PUSH
39602: LD_INT 2
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: LD_INT 1
39611: NEG
39612: PUSH
39613: LD_INT 1
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: LD_INT 2
39622: NEG
39623: PUSH
39624: LD_INT 0
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 2
39633: NEG
39634: PUSH
39635: LD_INT 1
39637: NEG
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 1
39645: NEG
39646: PUSH
39647: LD_INT 3
39649: NEG
39650: PUSH
39651: EMPTY
39652: LIST
39653: LIST
39654: PUSH
39655: LD_INT 0
39657: PUSH
39658: LD_INT 3
39660: NEG
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: LD_INT 1
39668: PUSH
39669: LD_INT 2
39671: NEG
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 2
39679: PUSH
39680: LD_INT 1
39682: NEG
39683: PUSH
39684: EMPTY
39685: LIST
39686: LIST
39687: PUSH
39688: LD_INT 3
39690: PUSH
39691: LD_INT 0
39693: PUSH
39694: EMPTY
39695: LIST
39696: LIST
39697: PUSH
39698: LD_INT 3
39700: PUSH
39701: LD_INT 1
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 1
39710: PUSH
39711: LD_INT 3
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: LD_INT 0
39720: PUSH
39721: LD_INT 3
39723: PUSH
39724: EMPTY
39725: LIST
39726: LIST
39727: PUSH
39728: LD_INT 1
39730: NEG
39731: PUSH
39732: LD_INT 2
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PUSH
39739: LD_INT 2
39741: NEG
39742: PUSH
39743: LD_INT 1
39745: PUSH
39746: EMPTY
39747: LIST
39748: LIST
39749: PUSH
39750: LD_INT 3
39752: NEG
39753: PUSH
39754: LD_INT 0
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 3
39763: NEG
39764: PUSH
39765: LD_INT 1
39767: NEG
39768: PUSH
39769: EMPTY
39770: LIST
39771: LIST
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: LIST
39777: LIST
39778: LIST
39779: LIST
39780: LIST
39781: LIST
39782: LIST
39783: LIST
39784: LIST
39785: LIST
39786: LIST
39787: LIST
39788: LIST
39789: LIST
39790: LIST
39791: LIST
39792: LIST
39793: LIST
39794: LIST
39795: LIST
39796: LIST
39797: LIST
39798: LIST
39799: LIST
39800: LIST
39801: LIST
39802: LIST
39803: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39804: LD_ADDR_VAR 0 47
39808: PUSH
39809: LD_INT 0
39811: PUSH
39812: LD_INT 0
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: PUSH
39819: LD_INT 0
39821: PUSH
39822: LD_INT 1
39824: NEG
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 1
39832: PUSH
39833: LD_INT 0
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PUSH
39840: LD_INT 1
39842: PUSH
39843: LD_INT 1
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 0
39852: PUSH
39853: LD_INT 1
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 1
39862: NEG
39863: PUSH
39864: LD_INT 0
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: PUSH
39871: LD_INT 1
39873: NEG
39874: PUSH
39875: LD_INT 1
39877: NEG
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: LD_INT 2
39889: NEG
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: PUSH
39895: LD_INT 0
39897: PUSH
39898: LD_INT 2
39900: NEG
39901: PUSH
39902: EMPTY
39903: LIST
39904: LIST
39905: PUSH
39906: LD_INT 1
39908: PUSH
39909: LD_INT 1
39911: NEG
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 2
39919: NEG
39920: PUSH
39921: LD_INT 1
39923: NEG
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: PUSH
39929: LD_INT 2
39931: NEG
39932: PUSH
39933: LD_INT 2
39935: NEG
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39955: LD_ADDR_VAR 0 48
39959: PUSH
39960: LD_INT 0
39962: PUSH
39963: LD_INT 0
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 0
39972: PUSH
39973: LD_INT 1
39975: NEG
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 1
39983: PUSH
39984: LD_INT 0
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 1
39993: PUSH
39994: LD_INT 1
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 0
40003: PUSH
40004: LD_INT 1
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: PUSH
40011: LD_INT 1
40013: NEG
40014: PUSH
40015: LD_INT 0
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: LD_INT 1
40024: NEG
40025: PUSH
40026: LD_INT 1
40028: NEG
40029: PUSH
40030: EMPTY
40031: LIST
40032: LIST
40033: PUSH
40034: LD_INT 1
40036: NEG
40037: PUSH
40038: LD_INT 2
40040: NEG
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: PUSH
40046: LD_INT 0
40048: PUSH
40049: LD_INT 2
40051: NEG
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: LD_INT 1
40059: PUSH
40060: LD_INT 1
40062: NEG
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: LD_INT 2
40070: PUSH
40071: LD_INT 0
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: LD_INT 2
40080: PUSH
40081: LD_INT 1
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: LIST
40092: LIST
40093: LIST
40094: LIST
40095: LIST
40096: LIST
40097: LIST
40098: LIST
40099: LIST
40100: LIST
40101: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40102: LD_ADDR_VAR 0 49
40106: PUSH
40107: LD_INT 0
40109: PUSH
40110: LD_INT 0
40112: PUSH
40113: EMPTY
40114: LIST
40115: LIST
40116: PUSH
40117: LD_INT 0
40119: PUSH
40120: LD_INT 1
40122: NEG
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 1
40130: PUSH
40131: LD_INT 0
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 1
40140: PUSH
40141: LD_INT 1
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: PUSH
40148: LD_INT 0
40150: PUSH
40151: LD_INT 1
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: PUSH
40158: LD_INT 1
40160: NEG
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 1
40171: NEG
40172: PUSH
40173: LD_INT 1
40175: NEG
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 1
40183: PUSH
40184: LD_INT 1
40186: NEG
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: PUSH
40192: LD_INT 2
40194: PUSH
40195: LD_INT 0
40197: PUSH
40198: EMPTY
40199: LIST
40200: LIST
40201: PUSH
40202: LD_INT 2
40204: PUSH
40205: LD_INT 1
40207: PUSH
40208: EMPTY
40209: LIST
40210: LIST
40211: PUSH
40212: LD_INT 2
40214: PUSH
40215: LD_INT 2
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: PUSH
40222: LD_INT 1
40224: PUSH
40225: LD_INT 2
40227: PUSH
40228: EMPTY
40229: LIST
40230: LIST
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: LIST
40236: LIST
40237: LIST
40238: LIST
40239: LIST
40240: LIST
40241: LIST
40242: LIST
40243: LIST
40244: LIST
40245: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40246: LD_ADDR_VAR 0 50
40250: PUSH
40251: LD_INT 0
40253: PUSH
40254: LD_INT 0
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 0
40263: PUSH
40264: LD_INT 1
40266: NEG
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: LD_INT 1
40274: PUSH
40275: LD_INT 0
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: PUSH
40282: LD_INT 1
40284: PUSH
40285: LD_INT 1
40287: PUSH
40288: EMPTY
40289: LIST
40290: LIST
40291: PUSH
40292: LD_INT 0
40294: PUSH
40295: LD_INT 1
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 1
40304: NEG
40305: PUSH
40306: LD_INT 0
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 1
40315: NEG
40316: PUSH
40317: LD_INT 1
40319: NEG
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 2
40327: PUSH
40328: LD_INT 1
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PUSH
40335: LD_INT 2
40337: PUSH
40338: LD_INT 2
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: PUSH
40345: LD_INT 1
40347: PUSH
40348: LD_INT 2
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: PUSH
40355: LD_INT 0
40357: PUSH
40358: LD_INT 2
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: PUSH
40365: LD_INT 1
40367: NEG
40368: PUSH
40369: LD_INT 1
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: LIST
40380: LIST
40381: LIST
40382: LIST
40383: LIST
40384: LIST
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40390: LD_ADDR_VAR 0 51
40394: PUSH
40395: LD_INT 0
40397: PUSH
40398: LD_INT 0
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 0
40407: PUSH
40408: LD_INT 1
40410: NEG
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: LD_INT 1
40418: PUSH
40419: LD_INT 0
40421: PUSH
40422: EMPTY
40423: LIST
40424: LIST
40425: PUSH
40426: LD_INT 1
40428: PUSH
40429: LD_INT 1
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 0
40438: PUSH
40439: LD_INT 1
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: LD_INT 1
40448: NEG
40449: PUSH
40450: LD_INT 0
40452: PUSH
40453: EMPTY
40454: LIST
40455: LIST
40456: PUSH
40457: LD_INT 1
40459: NEG
40460: PUSH
40461: LD_INT 1
40463: NEG
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 1
40471: PUSH
40472: LD_INT 2
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 0
40481: PUSH
40482: LD_INT 2
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: LD_INT 1
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: LD_INT 2
40502: NEG
40503: PUSH
40504: LD_INT 0
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: LD_INT 2
40513: NEG
40514: PUSH
40515: LD_INT 1
40517: NEG
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40537: LD_ADDR_VAR 0 52
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: LD_INT 0
40547: PUSH
40548: EMPTY
40549: LIST
40550: LIST
40551: PUSH
40552: LD_INT 0
40554: PUSH
40555: LD_INT 1
40557: NEG
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: PUSH
40563: LD_INT 1
40565: PUSH
40566: LD_INT 0
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: LD_INT 1
40575: PUSH
40576: LD_INT 1
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: LD_INT 0
40585: PUSH
40586: LD_INT 1
40588: PUSH
40589: EMPTY
40590: LIST
40591: LIST
40592: PUSH
40593: LD_INT 1
40595: NEG
40596: PUSH
40597: LD_INT 0
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 1
40606: NEG
40607: PUSH
40608: LD_INT 1
40610: NEG
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 1
40618: NEG
40619: PUSH
40620: LD_INT 2
40622: NEG
40623: PUSH
40624: EMPTY
40625: LIST
40626: LIST
40627: PUSH
40628: LD_INT 1
40630: NEG
40631: PUSH
40632: LD_INT 1
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: LD_INT 2
40641: NEG
40642: PUSH
40643: LD_INT 0
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 2
40652: NEG
40653: PUSH
40654: LD_INT 1
40656: NEG
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PUSH
40662: LD_INT 2
40664: NEG
40665: PUSH
40666: LD_INT 2
40668: NEG
40669: PUSH
40670: EMPTY
40671: LIST
40672: LIST
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40688: LD_ADDR_VAR 0 53
40692: PUSH
40693: LD_INT 0
40695: PUSH
40696: LD_INT 0
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 0
40705: PUSH
40706: LD_INT 1
40708: NEG
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 1
40716: PUSH
40717: LD_INT 0
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: PUSH
40724: LD_INT 1
40726: PUSH
40727: LD_INT 1
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: LD_INT 0
40736: PUSH
40737: LD_INT 1
40739: PUSH
40740: EMPTY
40741: LIST
40742: LIST
40743: PUSH
40744: LD_INT 1
40746: NEG
40747: PUSH
40748: LD_INT 0
40750: PUSH
40751: EMPTY
40752: LIST
40753: LIST
40754: PUSH
40755: LD_INT 1
40757: NEG
40758: PUSH
40759: LD_INT 1
40761: NEG
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: PUSH
40767: LD_INT 1
40769: NEG
40770: PUSH
40771: LD_INT 2
40773: NEG
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: PUSH
40779: LD_INT 0
40781: PUSH
40782: LD_INT 2
40784: NEG
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 1
40792: PUSH
40793: LD_INT 1
40795: NEG
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 2
40803: PUSH
40804: LD_INT 0
40806: PUSH
40807: EMPTY
40808: LIST
40809: LIST
40810: PUSH
40811: LD_INT 2
40813: PUSH
40814: LD_INT 1
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: LD_INT 2
40823: PUSH
40824: LD_INT 2
40826: PUSH
40827: EMPTY
40828: LIST
40829: LIST
40830: PUSH
40831: LD_INT 1
40833: PUSH
40834: LD_INT 2
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: PUSH
40841: LD_INT 0
40843: PUSH
40844: LD_INT 2
40846: PUSH
40847: EMPTY
40848: LIST
40849: LIST
40850: PUSH
40851: LD_INT 1
40853: NEG
40854: PUSH
40855: LD_INT 1
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PUSH
40862: LD_INT 2
40864: NEG
40865: PUSH
40866: LD_INT 0
40868: PUSH
40869: EMPTY
40870: LIST
40871: LIST
40872: PUSH
40873: LD_INT 2
40875: NEG
40876: PUSH
40877: LD_INT 1
40879: NEG
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 2
40887: NEG
40888: PUSH
40889: LD_INT 2
40891: NEG
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: LIST
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: LIST
40913: LIST
40914: LIST
40915: LIST
40916: LIST
40917: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40918: LD_ADDR_VAR 0 54
40922: PUSH
40923: LD_INT 0
40925: PUSH
40926: LD_INT 0
40928: PUSH
40929: EMPTY
40930: LIST
40931: LIST
40932: PUSH
40933: LD_INT 0
40935: PUSH
40936: LD_INT 1
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 1
40946: PUSH
40947: LD_INT 0
40949: PUSH
40950: EMPTY
40951: LIST
40952: LIST
40953: PUSH
40954: LD_INT 1
40956: PUSH
40957: LD_INT 1
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PUSH
40964: LD_INT 0
40966: PUSH
40967: LD_INT 1
40969: PUSH
40970: EMPTY
40971: LIST
40972: LIST
40973: PUSH
40974: LD_INT 1
40976: NEG
40977: PUSH
40978: LD_INT 0
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 1
40987: NEG
40988: PUSH
40989: LD_INT 1
40991: NEG
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 1
40999: NEG
41000: PUSH
41001: LD_INT 2
41003: NEG
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 0
41011: PUSH
41012: LD_INT 2
41014: NEG
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 1
41022: PUSH
41023: LD_INT 1
41025: NEG
41026: PUSH
41027: EMPTY
41028: LIST
41029: LIST
41030: PUSH
41031: LD_INT 2
41033: PUSH
41034: LD_INT 0
41036: PUSH
41037: EMPTY
41038: LIST
41039: LIST
41040: PUSH
41041: LD_INT 2
41043: PUSH
41044: LD_INT 1
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: PUSH
41051: LD_INT 2
41053: PUSH
41054: LD_INT 2
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PUSH
41061: LD_INT 1
41063: PUSH
41064: LD_INT 2
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 0
41073: PUSH
41074: LD_INT 2
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 1
41083: NEG
41084: PUSH
41085: LD_INT 1
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: PUSH
41092: LD_INT 2
41094: NEG
41095: PUSH
41096: LD_INT 0
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 2
41105: NEG
41106: PUSH
41107: LD_INT 1
41109: NEG
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: LD_INT 2
41117: NEG
41118: PUSH
41119: LD_INT 2
41121: NEG
41122: PUSH
41123: EMPTY
41124: LIST
41125: LIST
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: LIST
41131: LIST
41132: LIST
41133: LIST
41134: LIST
41135: LIST
41136: LIST
41137: LIST
41138: LIST
41139: LIST
41140: LIST
41141: LIST
41142: LIST
41143: LIST
41144: LIST
41145: LIST
41146: LIST
41147: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41148: LD_ADDR_VAR 0 55
41152: PUSH
41153: LD_INT 0
41155: PUSH
41156: LD_INT 0
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: LD_INT 0
41165: PUSH
41166: LD_INT 1
41168: NEG
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 1
41176: PUSH
41177: LD_INT 0
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: PUSH
41184: LD_INT 1
41186: PUSH
41187: LD_INT 1
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: LD_INT 0
41196: PUSH
41197: LD_INT 1
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 1
41206: NEG
41207: PUSH
41208: LD_INT 0
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 1
41217: NEG
41218: PUSH
41219: LD_INT 1
41221: NEG
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 1
41229: NEG
41230: PUSH
41231: LD_INT 2
41233: NEG
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: PUSH
41239: LD_INT 0
41241: PUSH
41242: LD_INT 2
41244: NEG
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: PUSH
41250: LD_INT 1
41252: PUSH
41253: LD_INT 1
41255: NEG
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: LD_INT 2
41263: PUSH
41264: LD_INT 0
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 2
41273: PUSH
41274: LD_INT 1
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 2
41283: PUSH
41284: LD_INT 2
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 1
41293: PUSH
41294: LD_INT 2
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 0
41303: PUSH
41304: LD_INT 2
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: PUSH
41311: LD_INT 1
41313: NEG
41314: PUSH
41315: LD_INT 1
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 2
41324: NEG
41325: PUSH
41326: LD_INT 0
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 2
41335: NEG
41336: PUSH
41337: LD_INT 1
41339: NEG
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 2
41347: NEG
41348: PUSH
41349: LD_INT 2
41351: NEG
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: EMPTY
41358: LIST
41359: LIST
41360: LIST
41361: LIST
41362: LIST
41363: LIST
41364: LIST
41365: LIST
41366: LIST
41367: LIST
41368: LIST
41369: LIST
41370: LIST
41371: LIST
41372: LIST
41373: LIST
41374: LIST
41375: LIST
41376: LIST
41377: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41378: LD_ADDR_VAR 0 56
41382: PUSH
41383: LD_INT 0
41385: PUSH
41386: LD_INT 0
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: PUSH
41393: LD_INT 0
41395: PUSH
41396: LD_INT 1
41398: NEG
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: PUSH
41404: LD_INT 1
41406: PUSH
41407: LD_INT 0
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: PUSH
41414: LD_INT 1
41416: PUSH
41417: LD_INT 1
41419: PUSH
41420: EMPTY
41421: LIST
41422: LIST
41423: PUSH
41424: LD_INT 0
41426: PUSH
41427: LD_INT 1
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 1
41436: NEG
41437: PUSH
41438: LD_INT 0
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: PUSH
41445: LD_INT 1
41447: NEG
41448: PUSH
41449: LD_INT 1
41451: NEG
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: PUSH
41457: LD_INT 1
41459: NEG
41460: PUSH
41461: LD_INT 2
41463: NEG
41464: PUSH
41465: EMPTY
41466: LIST
41467: LIST
41468: PUSH
41469: LD_INT 0
41471: PUSH
41472: LD_INT 2
41474: NEG
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 1
41482: PUSH
41483: LD_INT 1
41485: NEG
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: LD_INT 2
41493: PUSH
41494: LD_INT 0
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: PUSH
41501: LD_INT 2
41503: PUSH
41504: LD_INT 1
41506: PUSH
41507: EMPTY
41508: LIST
41509: LIST
41510: PUSH
41511: LD_INT 2
41513: PUSH
41514: LD_INT 2
41516: PUSH
41517: EMPTY
41518: LIST
41519: LIST
41520: PUSH
41521: LD_INT 1
41523: PUSH
41524: LD_INT 2
41526: PUSH
41527: EMPTY
41528: LIST
41529: LIST
41530: PUSH
41531: LD_INT 0
41533: PUSH
41534: LD_INT 2
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: PUSH
41541: LD_INT 1
41543: NEG
41544: PUSH
41545: LD_INT 1
41547: PUSH
41548: EMPTY
41549: LIST
41550: LIST
41551: PUSH
41552: LD_INT 2
41554: NEG
41555: PUSH
41556: LD_INT 0
41558: PUSH
41559: EMPTY
41560: LIST
41561: LIST
41562: PUSH
41563: LD_INT 2
41565: NEG
41566: PUSH
41567: LD_INT 1
41569: NEG
41570: PUSH
41571: EMPTY
41572: LIST
41573: LIST
41574: PUSH
41575: LD_INT 2
41577: NEG
41578: PUSH
41579: LD_INT 2
41581: NEG
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41608: LD_ADDR_VAR 0 57
41612: PUSH
41613: LD_INT 0
41615: PUSH
41616: LD_INT 0
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PUSH
41623: LD_INT 0
41625: PUSH
41626: LD_INT 1
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 1
41636: PUSH
41637: LD_INT 0
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: LD_INT 1
41646: PUSH
41647: LD_INT 1
41649: PUSH
41650: EMPTY
41651: LIST
41652: LIST
41653: PUSH
41654: LD_INT 0
41656: PUSH
41657: LD_INT 1
41659: PUSH
41660: EMPTY
41661: LIST
41662: LIST
41663: PUSH
41664: LD_INT 1
41666: NEG
41667: PUSH
41668: LD_INT 0
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 1
41677: NEG
41678: PUSH
41679: LD_INT 1
41681: NEG
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: LD_INT 1
41689: NEG
41690: PUSH
41691: LD_INT 2
41693: NEG
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: PUSH
41699: LD_INT 0
41701: PUSH
41702: LD_INT 2
41704: NEG
41705: PUSH
41706: EMPTY
41707: LIST
41708: LIST
41709: PUSH
41710: LD_INT 1
41712: PUSH
41713: LD_INT 1
41715: NEG
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: PUSH
41721: LD_INT 2
41723: PUSH
41724: LD_INT 0
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: PUSH
41731: LD_INT 2
41733: PUSH
41734: LD_INT 1
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: LD_INT 2
41743: PUSH
41744: LD_INT 2
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: PUSH
41751: LD_INT 1
41753: PUSH
41754: LD_INT 2
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: PUSH
41761: LD_INT 0
41763: PUSH
41764: LD_INT 2
41766: PUSH
41767: EMPTY
41768: LIST
41769: LIST
41770: PUSH
41771: LD_INT 1
41773: NEG
41774: PUSH
41775: LD_INT 1
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 2
41784: NEG
41785: PUSH
41786: LD_INT 0
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: LD_INT 2
41795: NEG
41796: PUSH
41797: LD_INT 1
41799: NEG
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: PUSH
41805: LD_INT 2
41807: NEG
41808: PUSH
41809: LD_INT 2
41811: NEG
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: EMPTY
41818: LIST
41819: LIST
41820: LIST
41821: LIST
41822: LIST
41823: LIST
41824: LIST
41825: LIST
41826: LIST
41827: LIST
41828: LIST
41829: LIST
41830: LIST
41831: LIST
41832: LIST
41833: LIST
41834: LIST
41835: LIST
41836: LIST
41837: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41838: LD_ADDR_VAR 0 58
41842: PUSH
41843: LD_INT 0
41845: PUSH
41846: LD_INT 0
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: LD_INT 0
41855: PUSH
41856: LD_INT 1
41858: NEG
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 1
41866: PUSH
41867: LD_INT 0
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: LD_INT 1
41876: PUSH
41877: LD_INT 1
41879: PUSH
41880: EMPTY
41881: LIST
41882: LIST
41883: PUSH
41884: LD_INT 0
41886: PUSH
41887: LD_INT 1
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PUSH
41894: LD_INT 1
41896: NEG
41897: PUSH
41898: LD_INT 0
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PUSH
41905: LD_INT 1
41907: NEG
41908: PUSH
41909: LD_INT 1
41911: NEG
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: PUSH
41917: LD_INT 1
41919: NEG
41920: PUSH
41921: LD_INT 2
41923: NEG
41924: PUSH
41925: EMPTY
41926: LIST
41927: LIST
41928: PUSH
41929: LD_INT 0
41931: PUSH
41932: LD_INT 2
41934: NEG
41935: PUSH
41936: EMPTY
41937: LIST
41938: LIST
41939: PUSH
41940: LD_INT 1
41942: PUSH
41943: LD_INT 1
41945: NEG
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 2
41953: PUSH
41954: LD_INT 0
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: PUSH
41961: LD_INT 2
41963: PUSH
41964: LD_INT 1
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PUSH
41971: LD_INT 2
41973: PUSH
41974: LD_INT 2
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 1
41983: PUSH
41984: LD_INT 2
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 0
41993: PUSH
41994: LD_INT 2
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: LD_INT 1
42003: NEG
42004: PUSH
42005: LD_INT 1
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: LD_INT 2
42014: NEG
42015: PUSH
42016: LD_INT 0
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 2
42025: NEG
42026: PUSH
42027: LD_INT 1
42029: NEG
42030: PUSH
42031: EMPTY
42032: LIST
42033: LIST
42034: PUSH
42035: LD_INT 2
42037: NEG
42038: PUSH
42039: LD_INT 2
42041: NEG
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: PUSH
42047: EMPTY
42048: LIST
42049: LIST
42050: LIST
42051: LIST
42052: LIST
42053: LIST
42054: LIST
42055: LIST
42056: LIST
42057: LIST
42058: LIST
42059: LIST
42060: LIST
42061: LIST
42062: LIST
42063: LIST
42064: LIST
42065: LIST
42066: LIST
42067: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42068: LD_ADDR_VAR 0 59
42072: PUSH
42073: LD_INT 0
42075: PUSH
42076: LD_INT 0
42078: PUSH
42079: EMPTY
42080: LIST
42081: LIST
42082: PUSH
42083: LD_INT 0
42085: PUSH
42086: LD_INT 1
42088: NEG
42089: PUSH
42090: EMPTY
42091: LIST
42092: LIST
42093: PUSH
42094: LD_INT 1
42096: PUSH
42097: LD_INT 0
42099: PUSH
42100: EMPTY
42101: LIST
42102: LIST
42103: PUSH
42104: LD_INT 1
42106: PUSH
42107: LD_INT 1
42109: PUSH
42110: EMPTY
42111: LIST
42112: LIST
42113: PUSH
42114: LD_INT 0
42116: PUSH
42117: LD_INT 1
42119: PUSH
42120: EMPTY
42121: LIST
42122: LIST
42123: PUSH
42124: LD_INT 1
42126: NEG
42127: PUSH
42128: LD_INT 0
42130: PUSH
42131: EMPTY
42132: LIST
42133: LIST
42134: PUSH
42135: LD_INT 1
42137: NEG
42138: PUSH
42139: LD_INT 1
42141: NEG
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: LIST
42151: LIST
42152: LIST
42153: LIST
42154: LIST
42155: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42156: LD_ADDR_VAR 0 60
42160: PUSH
42161: LD_INT 0
42163: PUSH
42164: LD_INT 0
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 0
42173: PUSH
42174: LD_INT 1
42176: NEG
42177: PUSH
42178: EMPTY
42179: LIST
42180: LIST
42181: PUSH
42182: LD_INT 1
42184: PUSH
42185: LD_INT 0
42187: PUSH
42188: EMPTY
42189: LIST
42190: LIST
42191: PUSH
42192: LD_INT 1
42194: PUSH
42195: LD_INT 1
42197: PUSH
42198: EMPTY
42199: LIST
42200: LIST
42201: PUSH
42202: LD_INT 0
42204: PUSH
42205: LD_INT 1
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: PUSH
42212: LD_INT 1
42214: NEG
42215: PUSH
42216: LD_INT 0
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 1
42225: NEG
42226: PUSH
42227: LD_INT 1
42229: NEG
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: EMPTY
42236: LIST
42237: LIST
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42244: LD_ADDR_VAR 0 61
42248: PUSH
42249: LD_INT 0
42251: PUSH
42252: LD_INT 0
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: PUSH
42259: LD_INT 0
42261: PUSH
42262: LD_INT 1
42264: NEG
42265: PUSH
42266: EMPTY
42267: LIST
42268: LIST
42269: PUSH
42270: LD_INT 1
42272: PUSH
42273: LD_INT 0
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: LD_INT 1
42282: PUSH
42283: LD_INT 1
42285: PUSH
42286: EMPTY
42287: LIST
42288: LIST
42289: PUSH
42290: LD_INT 0
42292: PUSH
42293: LD_INT 1
42295: PUSH
42296: EMPTY
42297: LIST
42298: LIST
42299: PUSH
42300: LD_INT 1
42302: NEG
42303: PUSH
42304: LD_INT 0
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: LD_INT 1
42313: NEG
42314: PUSH
42315: LD_INT 1
42317: NEG
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: LIST
42327: LIST
42328: LIST
42329: LIST
42330: LIST
42331: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42332: LD_ADDR_VAR 0 62
42336: PUSH
42337: LD_INT 0
42339: PUSH
42340: LD_INT 0
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 0
42349: PUSH
42350: LD_INT 1
42352: NEG
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 1
42360: PUSH
42361: LD_INT 0
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 1
42370: PUSH
42371: LD_INT 1
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: PUSH
42378: LD_INT 0
42380: PUSH
42381: LD_INT 1
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 1
42390: NEG
42391: PUSH
42392: LD_INT 0
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 1
42401: NEG
42402: PUSH
42403: LD_INT 1
42405: NEG
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: LIST
42415: LIST
42416: LIST
42417: LIST
42418: LIST
42419: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42420: LD_ADDR_VAR 0 63
42424: PUSH
42425: LD_INT 0
42427: PUSH
42428: LD_INT 0
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 0
42437: PUSH
42438: LD_INT 1
42440: NEG
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 1
42448: PUSH
42449: LD_INT 0
42451: PUSH
42452: EMPTY
42453: LIST
42454: LIST
42455: PUSH
42456: LD_INT 1
42458: PUSH
42459: LD_INT 1
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: PUSH
42466: LD_INT 0
42468: PUSH
42469: LD_INT 1
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: LD_INT 1
42478: NEG
42479: PUSH
42480: LD_INT 0
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: LD_INT 1
42489: NEG
42490: PUSH
42491: LD_INT 1
42493: NEG
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: LIST
42503: LIST
42504: LIST
42505: LIST
42506: LIST
42507: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42508: LD_ADDR_VAR 0 64
42512: PUSH
42513: LD_INT 0
42515: PUSH
42516: LD_INT 0
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 0
42525: PUSH
42526: LD_INT 1
42528: NEG
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 1
42536: PUSH
42537: LD_INT 0
42539: PUSH
42540: EMPTY
42541: LIST
42542: LIST
42543: PUSH
42544: LD_INT 1
42546: PUSH
42547: LD_INT 1
42549: PUSH
42550: EMPTY
42551: LIST
42552: LIST
42553: PUSH
42554: LD_INT 0
42556: PUSH
42557: LD_INT 1
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: LD_INT 1
42566: NEG
42567: PUSH
42568: LD_INT 0
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: PUSH
42575: LD_INT 1
42577: NEG
42578: PUSH
42579: LD_INT 1
42581: NEG
42582: PUSH
42583: EMPTY
42584: LIST
42585: LIST
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: ST_TO_ADDR
// end ; 1 :
42596: GO 48493
42598: LD_INT 1
42600: DOUBLE
42601: EQUAL
42602: IFTRUE 42606
42604: GO 45229
42606: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42607: LD_ADDR_VAR 0 11
42611: PUSH
42612: LD_INT 1
42614: NEG
42615: PUSH
42616: LD_INT 3
42618: NEG
42619: PUSH
42620: EMPTY
42621: LIST
42622: LIST
42623: PUSH
42624: LD_INT 0
42626: PUSH
42627: LD_INT 3
42629: NEG
42630: PUSH
42631: EMPTY
42632: LIST
42633: LIST
42634: PUSH
42635: LD_INT 1
42637: PUSH
42638: LD_INT 2
42640: NEG
42641: PUSH
42642: EMPTY
42643: LIST
42644: LIST
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: LIST
42650: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42651: LD_ADDR_VAR 0 12
42655: PUSH
42656: LD_INT 2
42658: PUSH
42659: LD_INT 1
42661: NEG
42662: PUSH
42663: EMPTY
42664: LIST
42665: LIST
42666: PUSH
42667: LD_INT 3
42669: PUSH
42670: LD_INT 0
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 3
42679: PUSH
42680: LD_INT 1
42682: PUSH
42683: EMPTY
42684: LIST
42685: LIST
42686: PUSH
42687: EMPTY
42688: LIST
42689: LIST
42690: LIST
42691: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42692: LD_ADDR_VAR 0 13
42696: PUSH
42697: LD_INT 3
42699: PUSH
42700: LD_INT 2
42702: PUSH
42703: EMPTY
42704: LIST
42705: LIST
42706: PUSH
42707: LD_INT 3
42709: PUSH
42710: LD_INT 3
42712: PUSH
42713: EMPTY
42714: LIST
42715: LIST
42716: PUSH
42717: LD_INT 2
42719: PUSH
42720: LD_INT 3
42722: PUSH
42723: EMPTY
42724: LIST
42725: LIST
42726: PUSH
42727: EMPTY
42728: LIST
42729: LIST
42730: LIST
42731: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42732: LD_ADDR_VAR 0 14
42736: PUSH
42737: LD_INT 1
42739: PUSH
42740: LD_INT 3
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: LD_INT 0
42749: PUSH
42750: LD_INT 3
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: LD_INT 1
42759: NEG
42760: PUSH
42761: LD_INT 2
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: LIST
42772: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42773: LD_ADDR_VAR 0 15
42777: PUSH
42778: LD_INT 2
42780: NEG
42781: PUSH
42782: LD_INT 1
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PUSH
42789: LD_INT 3
42791: NEG
42792: PUSH
42793: LD_INT 0
42795: PUSH
42796: EMPTY
42797: LIST
42798: LIST
42799: PUSH
42800: LD_INT 3
42802: NEG
42803: PUSH
42804: LD_INT 1
42806: NEG
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: LIST
42816: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42817: LD_ADDR_VAR 0 16
42821: PUSH
42822: LD_INT 2
42824: NEG
42825: PUSH
42826: LD_INT 3
42828: NEG
42829: PUSH
42830: EMPTY
42831: LIST
42832: LIST
42833: PUSH
42834: LD_INT 3
42836: NEG
42837: PUSH
42838: LD_INT 2
42840: NEG
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: PUSH
42846: LD_INT 3
42848: NEG
42849: PUSH
42850: LD_INT 3
42852: NEG
42853: PUSH
42854: EMPTY
42855: LIST
42856: LIST
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: LIST
42862: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42863: LD_ADDR_VAR 0 17
42867: PUSH
42868: LD_INT 1
42870: NEG
42871: PUSH
42872: LD_INT 3
42874: NEG
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 0
42882: PUSH
42883: LD_INT 3
42885: NEG
42886: PUSH
42887: EMPTY
42888: LIST
42889: LIST
42890: PUSH
42891: LD_INT 1
42893: PUSH
42894: LD_INT 2
42896: NEG
42897: PUSH
42898: EMPTY
42899: LIST
42900: LIST
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: LIST
42906: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42907: LD_ADDR_VAR 0 18
42911: PUSH
42912: LD_INT 2
42914: PUSH
42915: LD_INT 1
42917: NEG
42918: PUSH
42919: EMPTY
42920: LIST
42921: LIST
42922: PUSH
42923: LD_INT 3
42925: PUSH
42926: LD_INT 0
42928: PUSH
42929: EMPTY
42930: LIST
42931: LIST
42932: PUSH
42933: LD_INT 3
42935: PUSH
42936: LD_INT 1
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: PUSH
42943: EMPTY
42944: LIST
42945: LIST
42946: LIST
42947: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42948: LD_ADDR_VAR 0 19
42952: PUSH
42953: LD_INT 3
42955: PUSH
42956: LD_INT 2
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: PUSH
42963: LD_INT 3
42965: PUSH
42966: LD_INT 3
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 2
42975: PUSH
42976: LD_INT 3
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: LIST
42987: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42988: LD_ADDR_VAR 0 20
42992: PUSH
42993: LD_INT 1
42995: PUSH
42996: LD_INT 3
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: LD_INT 0
43005: PUSH
43006: LD_INT 3
43008: PUSH
43009: EMPTY
43010: LIST
43011: LIST
43012: PUSH
43013: LD_INT 1
43015: NEG
43016: PUSH
43017: LD_INT 2
43019: PUSH
43020: EMPTY
43021: LIST
43022: LIST
43023: PUSH
43024: EMPTY
43025: LIST
43026: LIST
43027: LIST
43028: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43029: LD_ADDR_VAR 0 21
43033: PUSH
43034: LD_INT 2
43036: NEG
43037: PUSH
43038: LD_INT 1
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 3
43047: NEG
43048: PUSH
43049: LD_INT 0
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: PUSH
43056: LD_INT 3
43058: NEG
43059: PUSH
43060: LD_INT 1
43062: NEG
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: PUSH
43068: EMPTY
43069: LIST
43070: LIST
43071: LIST
43072: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43073: LD_ADDR_VAR 0 22
43077: PUSH
43078: LD_INT 2
43080: NEG
43081: PUSH
43082: LD_INT 3
43084: NEG
43085: PUSH
43086: EMPTY
43087: LIST
43088: LIST
43089: PUSH
43090: LD_INT 3
43092: NEG
43093: PUSH
43094: LD_INT 2
43096: NEG
43097: PUSH
43098: EMPTY
43099: LIST
43100: LIST
43101: PUSH
43102: LD_INT 3
43104: NEG
43105: PUSH
43106: LD_INT 3
43108: NEG
43109: PUSH
43110: EMPTY
43111: LIST
43112: LIST
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: LIST
43118: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
43119: LD_ADDR_VAR 0 23
43123: PUSH
43124: LD_INT 0
43126: PUSH
43127: LD_INT 3
43129: NEG
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: LD_INT 1
43137: NEG
43138: PUSH
43139: LD_INT 4
43141: NEG
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: LD_INT 3
43152: NEG
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: EMPTY
43159: LIST
43160: LIST
43161: LIST
43162: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
43163: LD_ADDR_VAR 0 24
43167: PUSH
43168: LD_INT 3
43170: PUSH
43171: LD_INT 0
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PUSH
43178: LD_INT 3
43180: PUSH
43181: LD_INT 1
43183: NEG
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 4
43191: PUSH
43192: LD_INT 1
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: EMPTY
43200: LIST
43201: LIST
43202: LIST
43203: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
43204: LD_ADDR_VAR 0 25
43208: PUSH
43209: LD_INT 3
43211: PUSH
43212: LD_INT 3
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 4
43221: PUSH
43222: LD_INT 3
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: PUSH
43229: LD_INT 3
43231: PUSH
43232: LD_INT 4
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: EMPTY
43240: LIST
43241: LIST
43242: LIST
43243: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
43244: LD_ADDR_VAR 0 26
43248: PUSH
43249: LD_INT 0
43251: PUSH
43252: LD_INT 3
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PUSH
43259: LD_INT 1
43261: PUSH
43262: LD_INT 4
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 1
43271: NEG
43272: PUSH
43273: LD_INT 3
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: LIST
43284: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
43285: LD_ADDR_VAR 0 27
43289: PUSH
43290: LD_INT 3
43292: NEG
43293: PUSH
43294: LD_INT 0
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 3
43303: NEG
43304: PUSH
43305: LD_INT 1
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PUSH
43312: LD_INT 4
43314: NEG
43315: PUSH
43316: LD_INT 1
43318: NEG
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: EMPTY
43325: LIST
43326: LIST
43327: LIST
43328: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
43329: LD_ADDR_VAR 0 28
43333: PUSH
43334: LD_INT 3
43336: NEG
43337: PUSH
43338: LD_INT 3
43340: NEG
43341: PUSH
43342: EMPTY
43343: LIST
43344: LIST
43345: PUSH
43346: LD_INT 3
43348: NEG
43349: PUSH
43350: LD_INT 4
43352: NEG
43353: PUSH
43354: EMPTY
43355: LIST
43356: LIST
43357: PUSH
43358: LD_INT 4
43360: NEG
43361: PUSH
43362: LD_INT 3
43364: NEG
43365: PUSH
43366: EMPTY
43367: LIST
43368: LIST
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: LIST
43374: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
43375: LD_ADDR_VAR 0 29
43379: PUSH
43380: LD_INT 1
43382: NEG
43383: PUSH
43384: LD_INT 3
43386: NEG
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: LD_INT 0
43394: PUSH
43395: LD_INT 3
43397: NEG
43398: PUSH
43399: EMPTY
43400: LIST
43401: LIST
43402: PUSH
43403: LD_INT 1
43405: PUSH
43406: LD_INT 2
43408: NEG
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: PUSH
43414: LD_INT 1
43416: NEG
43417: PUSH
43418: LD_INT 4
43420: NEG
43421: PUSH
43422: EMPTY
43423: LIST
43424: LIST
43425: PUSH
43426: LD_INT 0
43428: PUSH
43429: LD_INT 4
43431: NEG
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: LD_INT 1
43439: PUSH
43440: LD_INT 3
43442: NEG
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PUSH
43448: LD_INT 1
43450: NEG
43451: PUSH
43452: LD_INT 5
43454: NEG
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: LD_INT 0
43462: PUSH
43463: LD_INT 5
43465: NEG
43466: PUSH
43467: EMPTY
43468: LIST
43469: LIST
43470: PUSH
43471: LD_INT 1
43473: PUSH
43474: LD_INT 4
43476: NEG
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 1
43484: NEG
43485: PUSH
43486: LD_INT 6
43488: NEG
43489: PUSH
43490: EMPTY
43491: LIST
43492: LIST
43493: PUSH
43494: LD_INT 0
43496: PUSH
43497: LD_INT 6
43499: NEG
43500: PUSH
43501: EMPTY
43502: LIST
43503: LIST
43504: PUSH
43505: LD_INT 1
43507: PUSH
43508: LD_INT 5
43510: NEG
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: LIST
43520: LIST
43521: LIST
43522: LIST
43523: LIST
43524: LIST
43525: LIST
43526: LIST
43527: LIST
43528: LIST
43529: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
43530: LD_ADDR_VAR 0 30
43534: PUSH
43535: LD_INT 2
43537: PUSH
43538: LD_INT 1
43540: NEG
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PUSH
43546: LD_INT 3
43548: PUSH
43549: LD_INT 0
43551: PUSH
43552: EMPTY
43553: LIST
43554: LIST
43555: PUSH
43556: LD_INT 3
43558: PUSH
43559: LD_INT 1
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: LD_INT 3
43568: PUSH
43569: LD_INT 1
43571: NEG
43572: PUSH
43573: EMPTY
43574: LIST
43575: LIST
43576: PUSH
43577: LD_INT 4
43579: PUSH
43580: LD_INT 0
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PUSH
43587: LD_INT 4
43589: PUSH
43590: LD_INT 1
43592: PUSH
43593: EMPTY
43594: LIST
43595: LIST
43596: PUSH
43597: LD_INT 4
43599: PUSH
43600: LD_INT 1
43602: NEG
43603: PUSH
43604: EMPTY
43605: LIST
43606: LIST
43607: PUSH
43608: LD_INT 5
43610: PUSH
43611: LD_INT 0
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 5
43620: PUSH
43621: LD_INT 1
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 5
43630: PUSH
43631: LD_INT 1
43633: NEG
43634: PUSH
43635: EMPTY
43636: LIST
43637: LIST
43638: PUSH
43639: LD_INT 6
43641: PUSH
43642: LD_INT 0
43644: PUSH
43645: EMPTY
43646: LIST
43647: LIST
43648: PUSH
43649: LD_INT 6
43651: PUSH
43652: LD_INT 1
43654: PUSH
43655: EMPTY
43656: LIST
43657: LIST
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: LIST
43663: LIST
43664: LIST
43665: LIST
43666: LIST
43667: LIST
43668: LIST
43669: LIST
43670: LIST
43671: LIST
43672: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
43673: LD_ADDR_VAR 0 31
43677: PUSH
43678: LD_INT 3
43680: PUSH
43681: LD_INT 2
43683: PUSH
43684: EMPTY
43685: LIST
43686: LIST
43687: PUSH
43688: LD_INT 3
43690: PUSH
43691: LD_INT 3
43693: PUSH
43694: EMPTY
43695: LIST
43696: LIST
43697: PUSH
43698: LD_INT 2
43700: PUSH
43701: LD_INT 3
43703: PUSH
43704: EMPTY
43705: LIST
43706: LIST
43707: PUSH
43708: LD_INT 4
43710: PUSH
43711: LD_INT 3
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PUSH
43718: LD_INT 4
43720: PUSH
43721: LD_INT 4
43723: PUSH
43724: EMPTY
43725: LIST
43726: LIST
43727: PUSH
43728: LD_INT 3
43730: PUSH
43731: LD_INT 4
43733: PUSH
43734: EMPTY
43735: LIST
43736: LIST
43737: PUSH
43738: LD_INT 5
43740: PUSH
43741: LD_INT 4
43743: PUSH
43744: EMPTY
43745: LIST
43746: LIST
43747: PUSH
43748: LD_INT 5
43750: PUSH
43751: LD_INT 5
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_INT 4
43760: PUSH
43761: LD_INT 5
43763: PUSH
43764: EMPTY
43765: LIST
43766: LIST
43767: PUSH
43768: LD_INT 6
43770: PUSH
43771: LD_INT 5
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: LD_INT 6
43780: PUSH
43781: LD_INT 6
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PUSH
43788: LD_INT 5
43790: PUSH
43791: LD_INT 6
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: EMPTY
43799: LIST
43800: LIST
43801: LIST
43802: LIST
43803: LIST
43804: LIST
43805: LIST
43806: LIST
43807: LIST
43808: LIST
43809: LIST
43810: LIST
43811: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
43812: LD_ADDR_VAR 0 32
43816: PUSH
43817: LD_INT 1
43819: PUSH
43820: LD_INT 3
43822: PUSH
43823: EMPTY
43824: LIST
43825: LIST
43826: PUSH
43827: LD_INT 0
43829: PUSH
43830: LD_INT 3
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PUSH
43837: LD_INT 1
43839: NEG
43840: PUSH
43841: LD_INT 2
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: LD_INT 1
43850: PUSH
43851: LD_INT 4
43853: PUSH
43854: EMPTY
43855: LIST
43856: LIST
43857: PUSH
43858: LD_INT 0
43860: PUSH
43861: LD_INT 4
43863: PUSH
43864: EMPTY
43865: LIST
43866: LIST
43867: PUSH
43868: LD_INT 1
43870: NEG
43871: PUSH
43872: LD_INT 3
43874: PUSH
43875: EMPTY
43876: LIST
43877: LIST
43878: PUSH
43879: LD_INT 1
43881: PUSH
43882: LD_INT 5
43884: PUSH
43885: EMPTY
43886: LIST
43887: LIST
43888: PUSH
43889: LD_INT 0
43891: PUSH
43892: LD_INT 5
43894: PUSH
43895: EMPTY
43896: LIST
43897: LIST
43898: PUSH
43899: LD_INT 1
43901: NEG
43902: PUSH
43903: LD_INT 4
43905: PUSH
43906: EMPTY
43907: LIST
43908: LIST
43909: PUSH
43910: LD_INT 1
43912: PUSH
43913: LD_INT 6
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 0
43922: PUSH
43923: LD_INT 6
43925: PUSH
43926: EMPTY
43927: LIST
43928: LIST
43929: PUSH
43930: LD_INT 1
43932: NEG
43933: PUSH
43934: LD_INT 5
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: EMPTY
43942: LIST
43943: LIST
43944: LIST
43945: LIST
43946: LIST
43947: LIST
43948: LIST
43949: LIST
43950: LIST
43951: LIST
43952: LIST
43953: LIST
43954: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
43955: LD_ADDR_VAR 0 33
43959: PUSH
43960: LD_INT 2
43962: NEG
43963: PUSH
43964: LD_INT 1
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: PUSH
43971: LD_INT 3
43973: NEG
43974: PUSH
43975: LD_INT 0
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: PUSH
43982: LD_INT 3
43984: NEG
43985: PUSH
43986: LD_INT 1
43988: NEG
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: PUSH
43994: LD_INT 3
43996: NEG
43997: PUSH
43998: LD_INT 1
44000: PUSH
44001: EMPTY
44002: LIST
44003: LIST
44004: PUSH
44005: LD_INT 4
44007: NEG
44008: PUSH
44009: LD_INT 0
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: LD_INT 4
44018: NEG
44019: PUSH
44020: LD_INT 1
44022: NEG
44023: PUSH
44024: EMPTY
44025: LIST
44026: LIST
44027: PUSH
44028: LD_INT 4
44030: NEG
44031: PUSH
44032: LD_INT 1
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 5
44041: NEG
44042: PUSH
44043: LD_INT 0
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: LD_INT 5
44052: NEG
44053: PUSH
44054: LD_INT 1
44056: NEG
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 5
44064: NEG
44065: PUSH
44066: LD_INT 1
44068: PUSH
44069: EMPTY
44070: LIST
44071: LIST
44072: PUSH
44073: LD_INT 6
44075: NEG
44076: PUSH
44077: LD_INT 0
44079: PUSH
44080: EMPTY
44081: LIST
44082: LIST
44083: PUSH
44084: LD_INT 6
44086: NEG
44087: PUSH
44088: LD_INT 1
44090: NEG
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: PUSH
44096: EMPTY
44097: LIST
44098: LIST
44099: LIST
44100: LIST
44101: LIST
44102: LIST
44103: LIST
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: LIST
44109: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
44110: LD_ADDR_VAR 0 34
44114: PUSH
44115: LD_INT 2
44117: NEG
44118: PUSH
44119: LD_INT 3
44121: NEG
44122: PUSH
44123: EMPTY
44124: LIST
44125: LIST
44126: PUSH
44127: LD_INT 3
44129: NEG
44130: PUSH
44131: LD_INT 2
44133: NEG
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 3
44141: NEG
44142: PUSH
44143: LD_INT 3
44145: NEG
44146: PUSH
44147: EMPTY
44148: LIST
44149: LIST
44150: PUSH
44151: LD_INT 3
44153: NEG
44154: PUSH
44155: LD_INT 4
44157: NEG
44158: PUSH
44159: EMPTY
44160: LIST
44161: LIST
44162: PUSH
44163: LD_INT 4
44165: NEG
44166: PUSH
44167: LD_INT 3
44169: NEG
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 4
44177: NEG
44178: PUSH
44179: LD_INT 4
44181: NEG
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: LD_INT 4
44189: NEG
44190: PUSH
44191: LD_INT 5
44193: NEG
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 5
44201: NEG
44202: PUSH
44203: LD_INT 4
44205: NEG
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 5
44213: NEG
44214: PUSH
44215: LD_INT 5
44217: NEG
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 5
44225: NEG
44226: PUSH
44227: LD_INT 6
44229: NEG
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: LD_INT 6
44237: NEG
44238: PUSH
44239: LD_INT 5
44241: NEG
44242: PUSH
44243: EMPTY
44244: LIST
44245: LIST
44246: PUSH
44247: LD_INT 6
44249: NEG
44250: PUSH
44251: LD_INT 6
44253: NEG
44254: PUSH
44255: EMPTY
44256: LIST
44257: LIST
44258: PUSH
44259: EMPTY
44260: LIST
44261: LIST
44262: LIST
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: LIST
44271: LIST
44272: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
44273: LD_ADDR_VAR 0 41
44277: PUSH
44278: LD_INT 0
44280: PUSH
44281: LD_INT 2
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: LD_INT 1
44291: NEG
44292: PUSH
44293: LD_INT 3
44295: NEG
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: PUSH
44301: LD_INT 1
44303: PUSH
44304: LD_INT 2
44306: NEG
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: LIST
44316: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
44317: LD_ADDR_VAR 0 42
44321: PUSH
44322: LD_INT 2
44324: PUSH
44325: LD_INT 0
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: PUSH
44332: LD_INT 2
44334: PUSH
44335: LD_INT 1
44337: NEG
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: PUSH
44343: LD_INT 3
44345: PUSH
44346: LD_INT 1
44348: PUSH
44349: EMPTY
44350: LIST
44351: LIST
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: LIST
44357: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
44358: LD_ADDR_VAR 0 43
44362: PUSH
44363: LD_INT 2
44365: PUSH
44366: LD_INT 2
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 3
44375: PUSH
44376: LD_INT 2
44378: PUSH
44379: EMPTY
44380: LIST
44381: LIST
44382: PUSH
44383: LD_INT 2
44385: PUSH
44386: LD_INT 3
44388: PUSH
44389: EMPTY
44390: LIST
44391: LIST
44392: PUSH
44393: EMPTY
44394: LIST
44395: LIST
44396: LIST
44397: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
44398: LD_ADDR_VAR 0 44
44402: PUSH
44403: LD_INT 0
44405: PUSH
44406: LD_INT 2
44408: PUSH
44409: EMPTY
44410: LIST
44411: LIST
44412: PUSH
44413: LD_INT 1
44415: PUSH
44416: LD_INT 3
44418: PUSH
44419: EMPTY
44420: LIST
44421: LIST
44422: PUSH
44423: LD_INT 1
44425: NEG
44426: PUSH
44427: LD_INT 2
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: EMPTY
44435: LIST
44436: LIST
44437: LIST
44438: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
44439: LD_ADDR_VAR 0 45
44443: PUSH
44444: LD_INT 2
44446: NEG
44447: PUSH
44448: LD_INT 0
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 2
44457: NEG
44458: PUSH
44459: LD_INT 1
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: PUSH
44466: LD_INT 3
44468: NEG
44469: PUSH
44470: LD_INT 1
44472: NEG
44473: PUSH
44474: EMPTY
44475: LIST
44476: LIST
44477: PUSH
44478: EMPTY
44479: LIST
44480: LIST
44481: LIST
44482: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
44483: LD_ADDR_VAR 0 46
44487: PUSH
44488: LD_INT 2
44490: NEG
44491: PUSH
44492: LD_INT 2
44494: NEG
44495: PUSH
44496: EMPTY
44497: LIST
44498: LIST
44499: PUSH
44500: LD_INT 2
44502: NEG
44503: PUSH
44504: LD_INT 3
44506: NEG
44507: PUSH
44508: EMPTY
44509: LIST
44510: LIST
44511: PUSH
44512: LD_INT 3
44514: NEG
44515: PUSH
44516: LD_INT 2
44518: NEG
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: LIST
44528: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
44529: LD_ADDR_VAR 0 47
44533: PUSH
44534: LD_INT 2
44536: NEG
44537: PUSH
44538: LD_INT 3
44540: NEG
44541: PUSH
44542: EMPTY
44543: LIST
44544: LIST
44545: PUSH
44546: LD_INT 1
44548: NEG
44549: PUSH
44550: LD_INT 3
44552: NEG
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: PUSH
44558: EMPTY
44559: LIST
44560: LIST
44561: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
44562: LD_ADDR_VAR 0 48
44566: PUSH
44567: LD_INT 1
44569: PUSH
44570: LD_INT 2
44572: NEG
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 2
44580: PUSH
44581: LD_INT 1
44583: NEG
44584: PUSH
44585: EMPTY
44586: LIST
44587: LIST
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
44593: LD_ADDR_VAR 0 49
44597: PUSH
44598: LD_INT 3
44600: PUSH
44601: LD_INT 1
44603: PUSH
44604: EMPTY
44605: LIST
44606: LIST
44607: PUSH
44608: LD_INT 3
44610: PUSH
44611: LD_INT 2
44613: PUSH
44614: EMPTY
44615: LIST
44616: LIST
44617: PUSH
44618: EMPTY
44619: LIST
44620: LIST
44621: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
44622: LD_ADDR_VAR 0 50
44626: PUSH
44627: LD_INT 2
44629: PUSH
44630: LD_INT 3
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 1
44639: PUSH
44640: LD_INT 3
44642: PUSH
44643: EMPTY
44644: LIST
44645: LIST
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
44651: LD_ADDR_VAR 0 51
44655: PUSH
44656: LD_INT 1
44658: NEG
44659: PUSH
44660: LD_INT 2
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 2
44669: NEG
44670: PUSH
44671: LD_INT 1
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: EMPTY
44679: LIST
44680: LIST
44681: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
44682: LD_ADDR_VAR 0 52
44686: PUSH
44687: LD_INT 3
44689: NEG
44690: PUSH
44691: LD_INT 1
44693: NEG
44694: PUSH
44695: EMPTY
44696: LIST
44697: LIST
44698: PUSH
44699: LD_INT 3
44701: NEG
44702: PUSH
44703: LD_INT 2
44705: NEG
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44715: LD_ADDR_VAR 0 53
44719: PUSH
44720: LD_INT 1
44722: NEG
44723: PUSH
44724: LD_INT 3
44726: NEG
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: PUSH
44732: LD_INT 0
44734: PUSH
44735: LD_INT 3
44737: NEG
44738: PUSH
44739: EMPTY
44740: LIST
44741: LIST
44742: PUSH
44743: LD_INT 1
44745: PUSH
44746: LD_INT 2
44748: NEG
44749: PUSH
44750: EMPTY
44751: LIST
44752: LIST
44753: PUSH
44754: EMPTY
44755: LIST
44756: LIST
44757: LIST
44758: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44759: LD_ADDR_VAR 0 54
44763: PUSH
44764: LD_INT 2
44766: PUSH
44767: LD_INT 1
44769: NEG
44770: PUSH
44771: EMPTY
44772: LIST
44773: LIST
44774: PUSH
44775: LD_INT 3
44777: PUSH
44778: LD_INT 0
44780: PUSH
44781: EMPTY
44782: LIST
44783: LIST
44784: PUSH
44785: LD_INT 3
44787: PUSH
44788: LD_INT 1
44790: PUSH
44791: EMPTY
44792: LIST
44793: LIST
44794: PUSH
44795: EMPTY
44796: LIST
44797: LIST
44798: LIST
44799: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44800: LD_ADDR_VAR 0 55
44804: PUSH
44805: LD_INT 3
44807: PUSH
44808: LD_INT 2
44810: PUSH
44811: EMPTY
44812: LIST
44813: LIST
44814: PUSH
44815: LD_INT 3
44817: PUSH
44818: LD_INT 3
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: LD_INT 2
44827: PUSH
44828: LD_INT 3
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PUSH
44835: EMPTY
44836: LIST
44837: LIST
44838: LIST
44839: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44840: LD_ADDR_VAR 0 56
44844: PUSH
44845: LD_INT 1
44847: PUSH
44848: LD_INT 3
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: LD_INT 0
44857: PUSH
44858: LD_INT 3
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_INT 1
44867: NEG
44868: PUSH
44869: LD_INT 2
44871: PUSH
44872: EMPTY
44873: LIST
44874: LIST
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: LIST
44880: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44881: LD_ADDR_VAR 0 57
44885: PUSH
44886: LD_INT 2
44888: NEG
44889: PUSH
44890: LD_INT 1
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: PUSH
44897: LD_INT 3
44899: NEG
44900: PUSH
44901: LD_INT 0
44903: PUSH
44904: EMPTY
44905: LIST
44906: LIST
44907: PUSH
44908: LD_INT 3
44910: NEG
44911: PUSH
44912: LD_INT 1
44914: NEG
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: LIST
44924: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44925: LD_ADDR_VAR 0 58
44929: PUSH
44930: LD_INT 2
44932: NEG
44933: PUSH
44934: LD_INT 3
44936: NEG
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 3
44944: NEG
44945: PUSH
44946: LD_INT 2
44948: NEG
44949: PUSH
44950: EMPTY
44951: LIST
44952: LIST
44953: PUSH
44954: LD_INT 3
44956: NEG
44957: PUSH
44958: LD_INT 3
44960: NEG
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: LIST
44970: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
44971: LD_ADDR_VAR 0 59
44975: PUSH
44976: LD_INT 1
44978: NEG
44979: PUSH
44980: LD_INT 2
44982: NEG
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: PUSH
44988: LD_INT 0
44990: PUSH
44991: LD_INT 2
44993: NEG
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 1
45001: PUSH
45002: LD_INT 1
45004: NEG
45005: PUSH
45006: EMPTY
45007: LIST
45008: LIST
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: LIST
45014: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
45015: LD_ADDR_VAR 0 60
45019: PUSH
45020: LD_INT 1
45022: PUSH
45023: LD_INT 1
45025: NEG
45026: PUSH
45027: EMPTY
45028: LIST
45029: LIST
45030: PUSH
45031: LD_INT 2
45033: PUSH
45034: LD_INT 0
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: PUSH
45041: LD_INT 2
45043: PUSH
45044: LD_INT 1
45046: PUSH
45047: EMPTY
45048: LIST
45049: LIST
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: LIST
45055: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
45056: LD_ADDR_VAR 0 61
45060: PUSH
45061: LD_INT 2
45063: PUSH
45064: LD_INT 1
45066: PUSH
45067: EMPTY
45068: LIST
45069: LIST
45070: PUSH
45071: LD_INT 2
45073: PUSH
45074: LD_INT 2
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: PUSH
45081: LD_INT 1
45083: PUSH
45084: LD_INT 2
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: PUSH
45091: EMPTY
45092: LIST
45093: LIST
45094: LIST
45095: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
45096: LD_ADDR_VAR 0 62
45100: PUSH
45101: LD_INT 1
45103: PUSH
45104: LD_INT 2
45106: PUSH
45107: EMPTY
45108: LIST
45109: LIST
45110: PUSH
45111: LD_INT 0
45113: PUSH
45114: LD_INT 2
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: LD_INT 1
45123: NEG
45124: PUSH
45125: LD_INT 1
45127: PUSH
45128: EMPTY
45129: LIST
45130: LIST
45131: PUSH
45132: EMPTY
45133: LIST
45134: LIST
45135: LIST
45136: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
45137: LD_ADDR_VAR 0 63
45141: PUSH
45142: LD_INT 1
45144: NEG
45145: PUSH
45146: LD_INT 1
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: PUSH
45153: LD_INT 2
45155: NEG
45156: PUSH
45157: LD_INT 0
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 2
45166: NEG
45167: PUSH
45168: LD_INT 1
45170: NEG
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: PUSH
45176: EMPTY
45177: LIST
45178: LIST
45179: LIST
45180: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45181: LD_ADDR_VAR 0 64
45185: PUSH
45186: LD_INT 1
45188: NEG
45189: PUSH
45190: LD_INT 2
45192: NEG
45193: PUSH
45194: EMPTY
45195: LIST
45196: LIST
45197: PUSH
45198: LD_INT 2
45200: NEG
45201: PUSH
45202: LD_INT 1
45204: NEG
45205: PUSH
45206: EMPTY
45207: LIST
45208: LIST
45209: PUSH
45210: LD_INT 2
45212: NEG
45213: PUSH
45214: LD_INT 2
45216: NEG
45217: PUSH
45218: EMPTY
45219: LIST
45220: LIST
45221: PUSH
45222: EMPTY
45223: LIST
45224: LIST
45225: LIST
45226: ST_TO_ADDR
// end ; 2 :
45227: GO 48493
45229: LD_INT 2
45231: DOUBLE
45232: EQUAL
45233: IFTRUE 45237
45235: GO 48492
45237: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
45238: LD_ADDR_VAR 0 29
45242: PUSH
45243: LD_INT 4
45245: PUSH
45246: LD_INT 0
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: PUSH
45253: LD_INT 4
45255: PUSH
45256: LD_INT 1
45258: NEG
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 5
45266: PUSH
45267: LD_INT 0
45269: PUSH
45270: EMPTY
45271: LIST
45272: LIST
45273: PUSH
45274: LD_INT 5
45276: PUSH
45277: LD_INT 1
45279: PUSH
45280: EMPTY
45281: LIST
45282: LIST
45283: PUSH
45284: LD_INT 4
45286: PUSH
45287: LD_INT 1
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: PUSH
45294: LD_INT 3
45296: PUSH
45297: LD_INT 0
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: PUSH
45304: LD_INT 3
45306: PUSH
45307: LD_INT 1
45309: NEG
45310: PUSH
45311: EMPTY
45312: LIST
45313: LIST
45314: PUSH
45315: LD_INT 3
45317: PUSH
45318: LD_INT 2
45320: NEG
45321: PUSH
45322: EMPTY
45323: LIST
45324: LIST
45325: PUSH
45326: LD_INT 5
45328: PUSH
45329: LD_INT 2
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 3
45338: PUSH
45339: LD_INT 3
45341: PUSH
45342: EMPTY
45343: LIST
45344: LIST
45345: PUSH
45346: LD_INT 3
45348: PUSH
45349: LD_INT 2
45351: PUSH
45352: EMPTY
45353: LIST
45354: LIST
45355: PUSH
45356: LD_INT 4
45358: PUSH
45359: LD_INT 3
45361: PUSH
45362: EMPTY
45363: LIST
45364: LIST
45365: PUSH
45366: LD_INT 4
45368: PUSH
45369: LD_INT 4
45371: PUSH
45372: EMPTY
45373: LIST
45374: LIST
45375: PUSH
45376: LD_INT 3
45378: PUSH
45379: LD_INT 4
45381: PUSH
45382: EMPTY
45383: LIST
45384: LIST
45385: PUSH
45386: LD_INT 2
45388: PUSH
45389: LD_INT 3
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: PUSH
45396: LD_INT 2
45398: PUSH
45399: LD_INT 2
45401: PUSH
45402: EMPTY
45403: LIST
45404: LIST
45405: PUSH
45406: LD_INT 4
45408: PUSH
45409: LD_INT 2
45411: PUSH
45412: EMPTY
45413: LIST
45414: LIST
45415: PUSH
45416: LD_INT 2
45418: PUSH
45419: LD_INT 4
45421: PUSH
45422: EMPTY
45423: LIST
45424: LIST
45425: PUSH
45426: LD_INT 0
45428: PUSH
45429: LD_INT 4
45431: PUSH
45432: EMPTY
45433: LIST
45434: LIST
45435: PUSH
45436: LD_INT 0
45438: PUSH
45439: LD_INT 3
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: PUSH
45446: LD_INT 1
45448: PUSH
45449: LD_INT 4
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: LD_INT 1
45458: PUSH
45459: LD_INT 5
45461: PUSH
45462: EMPTY
45463: LIST
45464: LIST
45465: PUSH
45466: LD_INT 0
45468: PUSH
45469: LD_INT 5
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: PUSH
45476: LD_INT 1
45478: NEG
45479: PUSH
45480: LD_INT 4
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: PUSH
45487: LD_INT 1
45489: NEG
45490: PUSH
45491: LD_INT 3
45493: PUSH
45494: EMPTY
45495: LIST
45496: LIST
45497: PUSH
45498: LD_INT 2
45500: PUSH
45501: LD_INT 5
45503: PUSH
45504: EMPTY
45505: LIST
45506: LIST
45507: PUSH
45508: LD_INT 2
45510: NEG
45511: PUSH
45512: LD_INT 3
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: LD_INT 3
45521: NEG
45522: PUSH
45523: LD_INT 0
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: LD_INT 3
45532: NEG
45533: PUSH
45534: LD_INT 1
45536: NEG
45537: PUSH
45538: EMPTY
45539: LIST
45540: LIST
45541: PUSH
45542: LD_INT 2
45544: NEG
45545: PUSH
45546: LD_INT 0
45548: PUSH
45549: EMPTY
45550: LIST
45551: LIST
45552: PUSH
45553: LD_INT 2
45555: NEG
45556: PUSH
45557: LD_INT 1
45559: PUSH
45560: EMPTY
45561: LIST
45562: LIST
45563: PUSH
45564: LD_INT 3
45566: NEG
45567: PUSH
45568: LD_INT 1
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: PUSH
45575: LD_INT 4
45577: NEG
45578: PUSH
45579: LD_INT 0
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 4
45588: NEG
45589: PUSH
45590: LD_INT 1
45592: NEG
45593: PUSH
45594: EMPTY
45595: LIST
45596: LIST
45597: PUSH
45598: LD_INT 4
45600: NEG
45601: PUSH
45602: LD_INT 2
45604: NEG
45605: PUSH
45606: EMPTY
45607: LIST
45608: LIST
45609: PUSH
45610: LD_INT 2
45612: NEG
45613: PUSH
45614: LD_INT 2
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PUSH
45621: LD_INT 4
45623: NEG
45624: PUSH
45625: LD_INT 4
45627: NEG
45628: PUSH
45629: EMPTY
45630: LIST
45631: LIST
45632: PUSH
45633: LD_INT 4
45635: NEG
45636: PUSH
45637: LD_INT 5
45639: NEG
45640: PUSH
45641: EMPTY
45642: LIST
45643: LIST
45644: PUSH
45645: LD_INT 3
45647: NEG
45648: PUSH
45649: LD_INT 4
45651: NEG
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: PUSH
45657: LD_INT 3
45659: NEG
45660: PUSH
45661: LD_INT 3
45663: NEG
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: LD_INT 4
45671: NEG
45672: PUSH
45673: LD_INT 3
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: LD_INT 5
45683: NEG
45684: PUSH
45685: LD_INT 4
45687: NEG
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: PUSH
45693: LD_INT 5
45695: NEG
45696: PUSH
45697: LD_INT 5
45699: NEG
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: PUSH
45705: LD_INT 3
45707: NEG
45708: PUSH
45709: LD_INT 5
45711: NEG
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: PUSH
45717: LD_INT 5
45719: NEG
45720: PUSH
45721: LD_INT 3
45723: NEG
45724: PUSH
45725: EMPTY
45726: LIST
45727: LIST
45728: PUSH
45729: EMPTY
45730: LIST
45731: LIST
45732: LIST
45733: LIST
45734: LIST
45735: LIST
45736: LIST
45737: LIST
45738: LIST
45739: LIST
45740: LIST
45741: LIST
45742: LIST
45743: LIST
45744: LIST
45745: LIST
45746: LIST
45747: LIST
45748: LIST
45749: LIST
45750: LIST
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: LIST
45757: LIST
45758: LIST
45759: LIST
45760: LIST
45761: LIST
45762: LIST
45763: LIST
45764: LIST
45765: LIST
45766: LIST
45767: LIST
45768: LIST
45769: LIST
45770: LIST
45771: LIST
45772: LIST
45773: LIST
45774: LIST
45775: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
45776: LD_ADDR_VAR 0 30
45780: PUSH
45781: LD_INT 4
45783: PUSH
45784: LD_INT 4
45786: PUSH
45787: EMPTY
45788: LIST
45789: LIST
45790: PUSH
45791: LD_INT 4
45793: PUSH
45794: LD_INT 3
45796: PUSH
45797: EMPTY
45798: LIST
45799: LIST
45800: PUSH
45801: LD_INT 5
45803: PUSH
45804: LD_INT 4
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 5
45813: PUSH
45814: LD_INT 5
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 4
45823: PUSH
45824: LD_INT 5
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 3
45833: PUSH
45834: LD_INT 4
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: LD_INT 3
45843: PUSH
45844: LD_INT 3
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 5
45853: PUSH
45854: LD_INT 3
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: PUSH
45861: LD_INT 3
45863: PUSH
45864: LD_INT 5
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: PUSH
45871: LD_INT 0
45873: PUSH
45874: LD_INT 3
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PUSH
45881: LD_INT 0
45883: PUSH
45884: LD_INT 2
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: PUSH
45891: LD_INT 1
45893: PUSH
45894: LD_INT 3
45896: PUSH
45897: EMPTY
45898: LIST
45899: LIST
45900: PUSH
45901: LD_INT 1
45903: PUSH
45904: LD_INT 4
45906: PUSH
45907: EMPTY
45908: LIST
45909: LIST
45910: PUSH
45911: LD_INT 0
45913: PUSH
45914: LD_INT 4
45916: PUSH
45917: EMPTY
45918: LIST
45919: LIST
45920: PUSH
45921: LD_INT 1
45923: NEG
45924: PUSH
45925: LD_INT 3
45927: PUSH
45928: EMPTY
45929: LIST
45930: LIST
45931: PUSH
45932: LD_INT 1
45934: NEG
45935: PUSH
45936: LD_INT 2
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: PUSH
45943: LD_INT 2
45945: PUSH
45946: LD_INT 4
45948: PUSH
45949: EMPTY
45950: LIST
45951: LIST
45952: PUSH
45953: LD_INT 2
45955: NEG
45956: PUSH
45957: LD_INT 2
45959: PUSH
45960: EMPTY
45961: LIST
45962: LIST
45963: PUSH
45964: LD_INT 4
45966: NEG
45967: PUSH
45968: LD_INT 0
45970: PUSH
45971: EMPTY
45972: LIST
45973: LIST
45974: PUSH
45975: LD_INT 4
45977: NEG
45978: PUSH
45979: LD_INT 1
45981: NEG
45982: PUSH
45983: EMPTY
45984: LIST
45985: LIST
45986: PUSH
45987: LD_INT 3
45989: NEG
45990: PUSH
45991: LD_INT 0
45993: PUSH
45994: EMPTY
45995: LIST
45996: LIST
45997: PUSH
45998: LD_INT 3
46000: NEG
46001: PUSH
46002: LD_INT 1
46004: PUSH
46005: EMPTY
46006: LIST
46007: LIST
46008: PUSH
46009: LD_INT 4
46011: NEG
46012: PUSH
46013: LD_INT 1
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: PUSH
46020: LD_INT 5
46022: NEG
46023: PUSH
46024: LD_INT 0
46026: PUSH
46027: EMPTY
46028: LIST
46029: LIST
46030: PUSH
46031: LD_INT 5
46033: NEG
46034: PUSH
46035: LD_INT 1
46037: NEG
46038: PUSH
46039: EMPTY
46040: LIST
46041: LIST
46042: PUSH
46043: LD_INT 5
46045: NEG
46046: PUSH
46047: LD_INT 2
46049: NEG
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: LD_INT 3
46057: NEG
46058: PUSH
46059: LD_INT 2
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: LD_INT 3
46068: NEG
46069: PUSH
46070: LD_INT 3
46072: NEG
46073: PUSH
46074: EMPTY
46075: LIST
46076: LIST
46077: PUSH
46078: LD_INT 3
46080: NEG
46081: PUSH
46082: LD_INT 4
46084: NEG
46085: PUSH
46086: EMPTY
46087: LIST
46088: LIST
46089: PUSH
46090: LD_INT 2
46092: NEG
46093: PUSH
46094: LD_INT 3
46096: NEG
46097: PUSH
46098: EMPTY
46099: LIST
46100: LIST
46101: PUSH
46102: LD_INT 2
46104: NEG
46105: PUSH
46106: LD_INT 2
46108: NEG
46109: PUSH
46110: EMPTY
46111: LIST
46112: LIST
46113: PUSH
46114: LD_INT 3
46116: NEG
46117: PUSH
46118: LD_INT 2
46120: NEG
46121: PUSH
46122: EMPTY
46123: LIST
46124: LIST
46125: PUSH
46126: LD_INT 4
46128: NEG
46129: PUSH
46130: LD_INT 3
46132: NEG
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: PUSH
46138: LD_INT 4
46140: NEG
46141: PUSH
46142: LD_INT 4
46144: NEG
46145: PUSH
46146: EMPTY
46147: LIST
46148: LIST
46149: PUSH
46150: LD_INT 2
46152: NEG
46153: PUSH
46154: LD_INT 4
46156: NEG
46157: PUSH
46158: EMPTY
46159: LIST
46160: LIST
46161: PUSH
46162: LD_INT 4
46164: NEG
46165: PUSH
46166: LD_INT 2
46168: NEG
46169: PUSH
46170: EMPTY
46171: LIST
46172: LIST
46173: PUSH
46174: LD_INT 0
46176: PUSH
46177: LD_INT 4
46179: NEG
46180: PUSH
46181: EMPTY
46182: LIST
46183: LIST
46184: PUSH
46185: LD_INT 0
46187: PUSH
46188: LD_INT 5
46190: NEG
46191: PUSH
46192: EMPTY
46193: LIST
46194: LIST
46195: PUSH
46196: LD_INT 1
46198: PUSH
46199: LD_INT 4
46201: NEG
46202: PUSH
46203: EMPTY
46204: LIST
46205: LIST
46206: PUSH
46207: LD_INT 1
46209: PUSH
46210: LD_INT 3
46212: NEG
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 0
46220: PUSH
46221: LD_INT 3
46223: NEG
46224: PUSH
46225: EMPTY
46226: LIST
46227: LIST
46228: PUSH
46229: LD_INT 1
46231: NEG
46232: PUSH
46233: LD_INT 4
46235: NEG
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PUSH
46241: LD_INT 1
46243: NEG
46244: PUSH
46245: LD_INT 5
46247: NEG
46248: PUSH
46249: EMPTY
46250: LIST
46251: LIST
46252: PUSH
46253: LD_INT 2
46255: PUSH
46256: LD_INT 3
46258: NEG
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 2
46266: NEG
46267: PUSH
46268: LD_INT 5
46270: NEG
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: LIST
46280: LIST
46281: LIST
46282: LIST
46283: LIST
46284: LIST
46285: LIST
46286: LIST
46287: LIST
46288: LIST
46289: LIST
46290: LIST
46291: LIST
46292: LIST
46293: LIST
46294: LIST
46295: LIST
46296: LIST
46297: LIST
46298: LIST
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: LIST
46312: LIST
46313: LIST
46314: LIST
46315: LIST
46316: LIST
46317: LIST
46318: LIST
46319: LIST
46320: LIST
46321: LIST
46322: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
46323: LD_ADDR_VAR 0 31
46327: PUSH
46328: LD_INT 0
46330: PUSH
46331: LD_INT 4
46333: PUSH
46334: EMPTY
46335: LIST
46336: LIST
46337: PUSH
46338: LD_INT 0
46340: PUSH
46341: LD_INT 3
46343: PUSH
46344: EMPTY
46345: LIST
46346: LIST
46347: PUSH
46348: LD_INT 1
46350: PUSH
46351: LD_INT 4
46353: PUSH
46354: EMPTY
46355: LIST
46356: LIST
46357: PUSH
46358: LD_INT 1
46360: PUSH
46361: LD_INT 5
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 0
46370: PUSH
46371: LD_INT 5
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PUSH
46378: LD_INT 1
46380: NEG
46381: PUSH
46382: LD_INT 4
46384: PUSH
46385: EMPTY
46386: LIST
46387: LIST
46388: PUSH
46389: LD_INT 1
46391: NEG
46392: PUSH
46393: LD_INT 3
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: PUSH
46400: LD_INT 2
46402: PUSH
46403: LD_INT 5
46405: PUSH
46406: EMPTY
46407: LIST
46408: LIST
46409: PUSH
46410: LD_INT 2
46412: NEG
46413: PUSH
46414: LD_INT 3
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PUSH
46421: LD_INT 3
46423: NEG
46424: PUSH
46425: LD_INT 0
46427: PUSH
46428: EMPTY
46429: LIST
46430: LIST
46431: PUSH
46432: LD_INT 3
46434: NEG
46435: PUSH
46436: LD_INT 1
46438: NEG
46439: PUSH
46440: EMPTY
46441: LIST
46442: LIST
46443: PUSH
46444: LD_INT 2
46446: NEG
46447: PUSH
46448: LD_INT 0
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: PUSH
46455: LD_INT 2
46457: NEG
46458: PUSH
46459: LD_INT 1
46461: PUSH
46462: EMPTY
46463: LIST
46464: LIST
46465: PUSH
46466: LD_INT 3
46468: NEG
46469: PUSH
46470: LD_INT 1
46472: PUSH
46473: EMPTY
46474: LIST
46475: LIST
46476: PUSH
46477: LD_INT 4
46479: NEG
46480: PUSH
46481: LD_INT 0
46483: PUSH
46484: EMPTY
46485: LIST
46486: LIST
46487: PUSH
46488: LD_INT 4
46490: NEG
46491: PUSH
46492: LD_INT 1
46494: NEG
46495: PUSH
46496: EMPTY
46497: LIST
46498: LIST
46499: PUSH
46500: LD_INT 4
46502: NEG
46503: PUSH
46504: LD_INT 2
46506: NEG
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: PUSH
46512: LD_INT 2
46514: NEG
46515: PUSH
46516: LD_INT 2
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 4
46525: NEG
46526: PUSH
46527: LD_INT 4
46529: NEG
46530: PUSH
46531: EMPTY
46532: LIST
46533: LIST
46534: PUSH
46535: LD_INT 4
46537: NEG
46538: PUSH
46539: LD_INT 5
46541: NEG
46542: PUSH
46543: EMPTY
46544: LIST
46545: LIST
46546: PUSH
46547: LD_INT 3
46549: NEG
46550: PUSH
46551: LD_INT 4
46553: NEG
46554: PUSH
46555: EMPTY
46556: LIST
46557: LIST
46558: PUSH
46559: LD_INT 3
46561: NEG
46562: PUSH
46563: LD_INT 3
46565: NEG
46566: PUSH
46567: EMPTY
46568: LIST
46569: LIST
46570: PUSH
46571: LD_INT 4
46573: NEG
46574: PUSH
46575: LD_INT 3
46577: NEG
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PUSH
46583: LD_INT 5
46585: NEG
46586: PUSH
46587: LD_INT 4
46589: NEG
46590: PUSH
46591: EMPTY
46592: LIST
46593: LIST
46594: PUSH
46595: LD_INT 5
46597: NEG
46598: PUSH
46599: LD_INT 5
46601: NEG
46602: PUSH
46603: EMPTY
46604: LIST
46605: LIST
46606: PUSH
46607: LD_INT 3
46609: NEG
46610: PUSH
46611: LD_INT 5
46613: NEG
46614: PUSH
46615: EMPTY
46616: LIST
46617: LIST
46618: PUSH
46619: LD_INT 5
46621: NEG
46622: PUSH
46623: LD_INT 3
46625: NEG
46626: PUSH
46627: EMPTY
46628: LIST
46629: LIST
46630: PUSH
46631: LD_INT 0
46633: PUSH
46634: LD_INT 3
46636: NEG
46637: PUSH
46638: EMPTY
46639: LIST
46640: LIST
46641: PUSH
46642: LD_INT 0
46644: PUSH
46645: LD_INT 4
46647: NEG
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: PUSH
46653: LD_INT 1
46655: PUSH
46656: LD_INT 3
46658: NEG
46659: PUSH
46660: EMPTY
46661: LIST
46662: LIST
46663: PUSH
46664: LD_INT 1
46666: PUSH
46667: LD_INT 2
46669: NEG
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: PUSH
46675: LD_INT 0
46677: PUSH
46678: LD_INT 2
46680: NEG
46681: PUSH
46682: EMPTY
46683: LIST
46684: LIST
46685: PUSH
46686: LD_INT 1
46688: NEG
46689: PUSH
46690: LD_INT 3
46692: NEG
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: PUSH
46698: LD_INT 1
46700: NEG
46701: PUSH
46702: LD_INT 4
46704: NEG
46705: PUSH
46706: EMPTY
46707: LIST
46708: LIST
46709: PUSH
46710: LD_INT 2
46712: PUSH
46713: LD_INT 2
46715: NEG
46716: PUSH
46717: EMPTY
46718: LIST
46719: LIST
46720: PUSH
46721: LD_INT 2
46723: NEG
46724: PUSH
46725: LD_INT 4
46727: NEG
46728: PUSH
46729: EMPTY
46730: LIST
46731: LIST
46732: PUSH
46733: LD_INT 4
46735: PUSH
46736: LD_INT 0
46738: PUSH
46739: EMPTY
46740: LIST
46741: LIST
46742: PUSH
46743: LD_INT 4
46745: PUSH
46746: LD_INT 1
46748: NEG
46749: PUSH
46750: EMPTY
46751: LIST
46752: LIST
46753: PUSH
46754: LD_INT 5
46756: PUSH
46757: LD_INT 0
46759: PUSH
46760: EMPTY
46761: LIST
46762: LIST
46763: PUSH
46764: LD_INT 5
46766: PUSH
46767: LD_INT 1
46769: PUSH
46770: EMPTY
46771: LIST
46772: LIST
46773: PUSH
46774: LD_INT 4
46776: PUSH
46777: LD_INT 1
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: PUSH
46784: LD_INT 3
46786: PUSH
46787: LD_INT 0
46789: PUSH
46790: EMPTY
46791: LIST
46792: LIST
46793: PUSH
46794: LD_INT 3
46796: PUSH
46797: LD_INT 1
46799: NEG
46800: PUSH
46801: EMPTY
46802: LIST
46803: LIST
46804: PUSH
46805: LD_INT 3
46807: PUSH
46808: LD_INT 2
46810: NEG
46811: PUSH
46812: EMPTY
46813: LIST
46814: LIST
46815: PUSH
46816: LD_INT 5
46818: PUSH
46819: LD_INT 2
46821: PUSH
46822: EMPTY
46823: LIST
46824: LIST
46825: PUSH
46826: EMPTY
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: LIST
46835: LIST
46836: LIST
46837: LIST
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: LIST
46844: LIST
46845: LIST
46846: LIST
46847: LIST
46848: LIST
46849: LIST
46850: LIST
46851: LIST
46852: LIST
46853: LIST
46854: LIST
46855: LIST
46856: LIST
46857: LIST
46858: LIST
46859: LIST
46860: LIST
46861: LIST
46862: LIST
46863: LIST
46864: LIST
46865: LIST
46866: LIST
46867: LIST
46868: LIST
46869: LIST
46870: LIST
46871: LIST
46872: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
46873: LD_ADDR_VAR 0 32
46877: PUSH
46878: LD_INT 4
46880: NEG
46881: PUSH
46882: LD_INT 0
46884: PUSH
46885: EMPTY
46886: LIST
46887: LIST
46888: PUSH
46889: LD_INT 4
46891: NEG
46892: PUSH
46893: LD_INT 1
46895: NEG
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PUSH
46901: LD_INT 3
46903: NEG
46904: PUSH
46905: LD_INT 0
46907: PUSH
46908: EMPTY
46909: LIST
46910: LIST
46911: PUSH
46912: LD_INT 3
46914: NEG
46915: PUSH
46916: LD_INT 1
46918: PUSH
46919: EMPTY
46920: LIST
46921: LIST
46922: PUSH
46923: LD_INT 4
46925: NEG
46926: PUSH
46927: LD_INT 1
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: PUSH
46934: LD_INT 5
46936: NEG
46937: PUSH
46938: LD_INT 0
46940: PUSH
46941: EMPTY
46942: LIST
46943: LIST
46944: PUSH
46945: LD_INT 5
46947: NEG
46948: PUSH
46949: LD_INT 1
46951: NEG
46952: PUSH
46953: EMPTY
46954: LIST
46955: LIST
46956: PUSH
46957: LD_INT 5
46959: NEG
46960: PUSH
46961: LD_INT 2
46963: NEG
46964: PUSH
46965: EMPTY
46966: LIST
46967: LIST
46968: PUSH
46969: LD_INT 3
46971: NEG
46972: PUSH
46973: LD_INT 2
46975: PUSH
46976: EMPTY
46977: LIST
46978: LIST
46979: PUSH
46980: LD_INT 3
46982: NEG
46983: PUSH
46984: LD_INT 3
46986: NEG
46987: PUSH
46988: EMPTY
46989: LIST
46990: LIST
46991: PUSH
46992: LD_INT 3
46994: NEG
46995: PUSH
46996: LD_INT 4
46998: NEG
46999: PUSH
47000: EMPTY
47001: LIST
47002: LIST
47003: PUSH
47004: LD_INT 2
47006: NEG
47007: PUSH
47008: LD_INT 3
47010: NEG
47011: PUSH
47012: EMPTY
47013: LIST
47014: LIST
47015: PUSH
47016: LD_INT 2
47018: NEG
47019: PUSH
47020: LD_INT 2
47022: NEG
47023: PUSH
47024: EMPTY
47025: LIST
47026: LIST
47027: PUSH
47028: LD_INT 3
47030: NEG
47031: PUSH
47032: LD_INT 2
47034: NEG
47035: PUSH
47036: EMPTY
47037: LIST
47038: LIST
47039: PUSH
47040: LD_INT 4
47042: NEG
47043: PUSH
47044: LD_INT 3
47046: NEG
47047: PUSH
47048: EMPTY
47049: LIST
47050: LIST
47051: PUSH
47052: LD_INT 4
47054: NEG
47055: PUSH
47056: LD_INT 4
47058: NEG
47059: PUSH
47060: EMPTY
47061: LIST
47062: LIST
47063: PUSH
47064: LD_INT 2
47066: NEG
47067: PUSH
47068: LD_INT 4
47070: NEG
47071: PUSH
47072: EMPTY
47073: LIST
47074: LIST
47075: PUSH
47076: LD_INT 4
47078: NEG
47079: PUSH
47080: LD_INT 2
47082: NEG
47083: PUSH
47084: EMPTY
47085: LIST
47086: LIST
47087: PUSH
47088: LD_INT 0
47090: PUSH
47091: LD_INT 4
47093: NEG
47094: PUSH
47095: EMPTY
47096: LIST
47097: LIST
47098: PUSH
47099: LD_INT 0
47101: PUSH
47102: LD_INT 5
47104: NEG
47105: PUSH
47106: EMPTY
47107: LIST
47108: LIST
47109: PUSH
47110: LD_INT 1
47112: PUSH
47113: LD_INT 4
47115: NEG
47116: PUSH
47117: EMPTY
47118: LIST
47119: LIST
47120: PUSH
47121: LD_INT 1
47123: PUSH
47124: LD_INT 3
47126: NEG
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: PUSH
47132: LD_INT 0
47134: PUSH
47135: LD_INT 3
47137: NEG
47138: PUSH
47139: EMPTY
47140: LIST
47141: LIST
47142: PUSH
47143: LD_INT 1
47145: NEG
47146: PUSH
47147: LD_INT 4
47149: NEG
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: LD_INT 1
47157: NEG
47158: PUSH
47159: LD_INT 5
47161: NEG
47162: PUSH
47163: EMPTY
47164: LIST
47165: LIST
47166: PUSH
47167: LD_INT 2
47169: PUSH
47170: LD_INT 3
47172: NEG
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: LD_INT 2
47180: NEG
47181: PUSH
47182: LD_INT 5
47184: NEG
47185: PUSH
47186: EMPTY
47187: LIST
47188: LIST
47189: PUSH
47190: LD_INT 3
47192: PUSH
47193: LD_INT 0
47195: PUSH
47196: EMPTY
47197: LIST
47198: LIST
47199: PUSH
47200: LD_INT 3
47202: PUSH
47203: LD_INT 1
47205: NEG
47206: PUSH
47207: EMPTY
47208: LIST
47209: LIST
47210: PUSH
47211: LD_INT 4
47213: PUSH
47214: LD_INT 0
47216: PUSH
47217: EMPTY
47218: LIST
47219: LIST
47220: PUSH
47221: LD_INT 4
47223: PUSH
47224: LD_INT 1
47226: PUSH
47227: EMPTY
47228: LIST
47229: LIST
47230: PUSH
47231: LD_INT 3
47233: PUSH
47234: LD_INT 1
47236: PUSH
47237: EMPTY
47238: LIST
47239: LIST
47240: PUSH
47241: LD_INT 2
47243: PUSH
47244: LD_INT 0
47246: PUSH
47247: EMPTY
47248: LIST
47249: LIST
47250: PUSH
47251: LD_INT 2
47253: PUSH
47254: LD_INT 1
47256: NEG
47257: PUSH
47258: EMPTY
47259: LIST
47260: LIST
47261: PUSH
47262: LD_INT 2
47264: PUSH
47265: LD_INT 2
47267: NEG
47268: PUSH
47269: EMPTY
47270: LIST
47271: LIST
47272: PUSH
47273: LD_INT 4
47275: PUSH
47276: LD_INT 2
47278: PUSH
47279: EMPTY
47280: LIST
47281: LIST
47282: PUSH
47283: LD_INT 4
47285: PUSH
47286: LD_INT 4
47288: PUSH
47289: EMPTY
47290: LIST
47291: LIST
47292: PUSH
47293: LD_INT 4
47295: PUSH
47296: LD_INT 3
47298: PUSH
47299: EMPTY
47300: LIST
47301: LIST
47302: PUSH
47303: LD_INT 5
47305: PUSH
47306: LD_INT 4
47308: PUSH
47309: EMPTY
47310: LIST
47311: LIST
47312: PUSH
47313: LD_INT 5
47315: PUSH
47316: LD_INT 5
47318: PUSH
47319: EMPTY
47320: LIST
47321: LIST
47322: PUSH
47323: LD_INT 4
47325: PUSH
47326: LD_INT 5
47328: PUSH
47329: EMPTY
47330: LIST
47331: LIST
47332: PUSH
47333: LD_INT 3
47335: PUSH
47336: LD_INT 4
47338: PUSH
47339: EMPTY
47340: LIST
47341: LIST
47342: PUSH
47343: LD_INT 3
47345: PUSH
47346: LD_INT 3
47348: PUSH
47349: EMPTY
47350: LIST
47351: LIST
47352: PUSH
47353: LD_INT 5
47355: PUSH
47356: LD_INT 3
47358: PUSH
47359: EMPTY
47360: LIST
47361: LIST
47362: PUSH
47363: LD_INT 3
47365: PUSH
47366: LD_INT 5
47368: PUSH
47369: EMPTY
47370: LIST
47371: LIST
47372: PUSH
47373: EMPTY
47374: LIST
47375: LIST
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: LIST
47382: LIST
47383: LIST
47384: LIST
47385: LIST
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: LIST
47391: LIST
47392: LIST
47393: LIST
47394: LIST
47395: LIST
47396: LIST
47397: LIST
47398: LIST
47399: LIST
47400: LIST
47401: LIST
47402: LIST
47403: LIST
47404: LIST
47405: LIST
47406: LIST
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
47420: LD_ADDR_VAR 0 33
47424: PUSH
47425: LD_INT 4
47427: NEG
47428: PUSH
47429: LD_INT 4
47431: NEG
47432: PUSH
47433: EMPTY
47434: LIST
47435: LIST
47436: PUSH
47437: LD_INT 4
47439: NEG
47440: PUSH
47441: LD_INT 5
47443: NEG
47444: PUSH
47445: EMPTY
47446: LIST
47447: LIST
47448: PUSH
47449: LD_INT 3
47451: NEG
47452: PUSH
47453: LD_INT 4
47455: NEG
47456: PUSH
47457: EMPTY
47458: LIST
47459: LIST
47460: PUSH
47461: LD_INT 3
47463: NEG
47464: PUSH
47465: LD_INT 3
47467: NEG
47468: PUSH
47469: EMPTY
47470: LIST
47471: LIST
47472: PUSH
47473: LD_INT 4
47475: NEG
47476: PUSH
47477: LD_INT 3
47479: NEG
47480: PUSH
47481: EMPTY
47482: LIST
47483: LIST
47484: PUSH
47485: LD_INT 5
47487: NEG
47488: PUSH
47489: LD_INT 4
47491: NEG
47492: PUSH
47493: EMPTY
47494: LIST
47495: LIST
47496: PUSH
47497: LD_INT 5
47499: NEG
47500: PUSH
47501: LD_INT 5
47503: NEG
47504: PUSH
47505: EMPTY
47506: LIST
47507: LIST
47508: PUSH
47509: LD_INT 3
47511: NEG
47512: PUSH
47513: LD_INT 5
47515: NEG
47516: PUSH
47517: EMPTY
47518: LIST
47519: LIST
47520: PUSH
47521: LD_INT 5
47523: NEG
47524: PUSH
47525: LD_INT 3
47527: NEG
47528: PUSH
47529: EMPTY
47530: LIST
47531: LIST
47532: PUSH
47533: LD_INT 0
47535: PUSH
47536: LD_INT 3
47538: NEG
47539: PUSH
47540: EMPTY
47541: LIST
47542: LIST
47543: PUSH
47544: LD_INT 0
47546: PUSH
47547: LD_INT 4
47549: NEG
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: LD_INT 1
47557: PUSH
47558: LD_INT 3
47560: NEG
47561: PUSH
47562: EMPTY
47563: LIST
47564: LIST
47565: PUSH
47566: LD_INT 1
47568: PUSH
47569: LD_INT 2
47571: NEG
47572: PUSH
47573: EMPTY
47574: LIST
47575: LIST
47576: PUSH
47577: LD_INT 0
47579: PUSH
47580: LD_INT 2
47582: NEG
47583: PUSH
47584: EMPTY
47585: LIST
47586: LIST
47587: PUSH
47588: LD_INT 1
47590: NEG
47591: PUSH
47592: LD_INT 3
47594: NEG
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: PUSH
47600: LD_INT 1
47602: NEG
47603: PUSH
47604: LD_INT 4
47606: NEG
47607: PUSH
47608: EMPTY
47609: LIST
47610: LIST
47611: PUSH
47612: LD_INT 2
47614: PUSH
47615: LD_INT 2
47617: NEG
47618: PUSH
47619: EMPTY
47620: LIST
47621: LIST
47622: PUSH
47623: LD_INT 2
47625: NEG
47626: PUSH
47627: LD_INT 4
47629: NEG
47630: PUSH
47631: EMPTY
47632: LIST
47633: LIST
47634: PUSH
47635: LD_INT 4
47637: PUSH
47638: LD_INT 0
47640: PUSH
47641: EMPTY
47642: LIST
47643: LIST
47644: PUSH
47645: LD_INT 4
47647: PUSH
47648: LD_INT 1
47650: NEG
47651: PUSH
47652: EMPTY
47653: LIST
47654: LIST
47655: PUSH
47656: LD_INT 5
47658: PUSH
47659: LD_INT 0
47661: PUSH
47662: EMPTY
47663: LIST
47664: LIST
47665: PUSH
47666: LD_INT 5
47668: PUSH
47669: LD_INT 1
47671: PUSH
47672: EMPTY
47673: LIST
47674: LIST
47675: PUSH
47676: LD_INT 4
47678: PUSH
47679: LD_INT 1
47681: PUSH
47682: EMPTY
47683: LIST
47684: LIST
47685: PUSH
47686: LD_INT 3
47688: PUSH
47689: LD_INT 0
47691: PUSH
47692: EMPTY
47693: LIST
47694: LIST
47695: PUSH
47696: LD_INT 3
47698: PUSH
47699: LD_INT 1
47701: NEG
47702: PUSH
47703: EMPTY
47704: LIST
47705: LIST
47706: PUSH
47707: LD_INT 3
47709: PUSH
47710: LD_INT 2
47712: NEG
47713: PUSH
47714: EMPTY
47715: LIST
47716: LIST
47717: PUSH
47718: LD_INT 5
47720: PUSH
47721: LD_INT 2
47723: PUSH
47724: EMPTY
47725: LIST
47726: LIST
47727: PUSH
47728: LD_INT 3
47730: PUSH
47731: LD_INT 3
47733: PUSH
47734: EMPTY
47735: LIST
47736: LIST
47737: PUSH
47738: LD_INT 3
47740: PUSH
47741: LD_INT 2
47743: PUSH
47744: EMPTY
47745: LIST
47746: LIST
47747: PUSH
47748: LD_INT 4
47750: PUSH
47751: LD_INT 3
47753: PUSH
47754: EMPTY
47755: LIST
47756: LIST
47757: PUSH
47758: LD_INT 4
47760: PUSH
47761: LD_INT 4
47763: PUSH
47764: EMPTY
47765: LIST
47766: LIST
47767: PUSH
47768: LD_INT 3
47770: PUSH
47771: LD_INT 4
47773: PUSH
47774: EMPTY
47775: LIST
47776: LIST
47777: PUSH
47778: LD_INT 2
47780: PUSH
47781: LD_INT 3
47783: PUSH
47784: EMPTY
47785: LIST
47786: LIST
47787: PUSH
47788: LD_INT 2
47790: PUSH
47791: LD_INT 2
47793: PUSH
47794: EMPTY
47795: LIST
47796: LIST
47797: PUSH
47798: LD_INT 4
47800: PUSH
47801: LD_INT 2
47803: PUSH
47804: EMPTY
47805: LIST
47806: LIST
47807: PUSH
47808: LD_INT 2
47810: PUSH
47811: LD_INT 4
47813: PUSH
47814: EMPTY
47815: LIST
47816: LIST
47817: PUSH
47818: LD_INT 0
47820: PUSH
47821: LD_INT 4
47823: PUSH
47824: EMPTY
47825: LIST
47826: LIST
47827: PUSH
47828: LD_INT 0
47830: PUSH
47831: LD_INT 3
47833: PUSH
47834: EMPTY
47835: LIST
47836: LIST
47837: PUSH
47838: LD_INT 1
47840: PUSH
47841: LD_INT 4
47843: PUSH
47844: EMPTY
47845: LIST
47846: LIST
47847: PUSH
47848: LD_INT 1
47850: PUSH
47851: LD_INT 5
47853: PUSH
47854: EMPTY
47855: LIST
47856: LIST
47857: PUSH
47858: LD_INT 0
47860: PUSH
47861: LD_INT 5
47863: PUSH
47864: EMPTY
47865: LIST
47866: LIST
47867: PUSH
47868: LD_INT 1
47870: NEG
47871: PUSH
47872: LD_INT 4
47874: PUSH
47875: EMPTY
47876: LIST
47877: LIST
47878: PUSH
47879: LD_INT 1
47881: NEG
47882: PUSH
47883: LD_INT 3
47885: PUSH
47886: EMPTY
47887: LIST
47888: LIST
47889: PUSH
47890: LD_INT 2
47892: PUSH
47893: LD_INT 5
47895: PUSH
47896: EMPTY
47897: LIST
47898: LIST
47899: PUSH
47900: LD_INT 2
47902: NEG
47903: PUSH
47904: LD_INT 3
47906: PUSH
47907: EMPTY
47908: LIST
47909: LIST
47910: PUSH
47911: EMPTY
47912: LIST
47913: LIST
47914: LIST
47915: LIST
47916: LIST
47917: LIST
47918: LIST
47919: LIST
47920: LIST
47921: LIST
47922: LIST
47923: LIST
47924: LIST
47925: LIST
47926: LIST
47927: LIST
47928: LIST
47929: LIST
47930: LIST
47931: LIST
47932: LIST
47933: LIST
47934: LIST
47935: LIST
47936: LIST
47937: LIST
47938: LIST
47939: LIST
47940: LIST
47941: LIST
47942: LIST
47943: LIST
47944: LIST
47945: LIST
47946: LIST
47947: LIST
47948: LIST
47949: LIST
47950: LIST
47951: LIST
47952: LIST
47953: LIST
47954: LIST
47955: LIST
47956: LIST
47957: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
47958: LD_ADDR_VAR 0 34
47962: PUSH
47963: LD_INT 0
47965: PUSH
47966: LD_INT 4
47968: NEG
47969: PUSH
47970: EMPTY
47971: LIST
47972: LIST
47973: PUSH
47974: LD_INT 0
47976: PUSH
47977: LD_INT 5
47979: NEG
47980: PUSH
47981: EMPTY
47982: LIST
47983: LIST
47984: PUSH
47985: LD_INT 1
47987: PUSH
47988: LD_INT 4
47990: NEG
47991: PUSH
47992: EMPTY
47993: LIST
47994: LIST
47995: PUSH
47996: LD_INT 1
47998: PUSH
47999: LD_INT 3
48001: NEG
48002: PUSH
48003: EMPTY
48004: LIST
48005: LIST
48006: PUSH
48007: LD_INT 0
48009: PUSH
48010: LD_INT 3
48012: NEG
48013: PUSH
48014: EMPTY
48015: LIST
48016: LIST
48017: PUSH
48018: LD_INT 1
48020: NEG
48021: PUSH
48022: LD_INT 4
48024: NEG
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: PUSH
48030: LD_INT 1
48032: NEG
48033: PUSH
48034: LD_INT 5
48036: NEG
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: PUSH
48042: LD_INT 2
48044: PUSH
48045: LD_INT 3
48047: NEG
48048: PUSH
48049: EMPTY
48050: LIST
48051: LIST
48052: PUSH
48053: LD_INT 2
48055: NEG
48056: PUSH
48057: LD_INT 5
48059: NEG
48060: PUSH
48061: EMPTY
48062: LIST
48063: LIST
48064: PUSH
48065: LD_INT 3
48067: PUSH
48068: LD_INT 0
48070: PUSH
48071: EMPTY
48072: LIST
48073: LIST
48074: PUSH
48075: LD_INT 3
48077: PUSH
48078: LD_INT 1
48080: NEG
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: PUSH
48086: LD_INT 4
48088: PUSH
48089: LD_INT 0
48091: PUSH
48092: EMPTY
48093: LIST
48094: LIST
48095: PUSH
48096: LD_INT 4
48098: PUSH
48099: LD_INT 1
48101: PUSH
48102: EMPTY
48103: LIST
48104: LIST
48105: PUSH
48106: LD_INT 3
48108: PUSH
48109: LD_INT 1
48111: PUSH
48112: EMPTY
48113: LIST
48114: LIST
48115: PUSH
48116: LD_INT 2
48118: PUSH
48119: LD_INT 0
48121: PUSH
48122: EMPTY
48123: LIST
48124: LIST
48125: PUSH
48126: LD_INT 2
48128: PUSH
48129: LD_INT 1
48131: NEG
48132: PUSH
48133: EMPTY
48134: LIST
48135: LIST
48136: PUSH
48137: LD_INT 2
48139: PUSH
48140: LD_INT 2
48142: NEG
48143: PUSH
48144: EMPTY
48145: LIST
48146: LIST
48147: PUSH
48148: LD_INT 4
48150: PUSH
48151: LD_INT 2
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: PUSH
48158: LD_INT 4
48160: PUSH
48161: LD_INT 4
48163: PUSH
48164: EMPTY
48165: LIST
48166: LIST
48167: PUSH
48168: LD_INT 4
48170: PUSH
48171: LD_INT 3
48173: PUSH
48174: EMPTY
48175: LIST
48176: LIST
48177: PUSH
48178: LD_INT 5
48180: PUSH
48181: LD_INT 4
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PUSH
48188: LD_INT 5
48190: PUSH
48191: LD_INT 5
48193: PUSH
48194: EMPTY
48195: LIST
48196: LIST
48197: PUSH
48198: LD_INT 4
48200: PUSH
48201: LD_INT 5
48203: PUSH
48204: EMPTY
48205: LIST
48206: LIST
48207: PUSH
48208: LD_INT 3
48210: PUSH
48211: LD_INT 4
48213: PUSH
48214: EMPTY
48215: LIST
48216: LIST
48217: PUSH
48218: LD_INT 3
48220: PUSH
48221: LD_INT 3
48223: PUSH
48224: EMPTY
48225: LIST
48226: LIST
48227: PUSH
48228: LD_INT 5
48230: PUSH
48231: LD_INT 3
48233: PUSH
48234: EMPTY
48235: LIST
48236: LIST
48237: PUSH
48238: LD_INT 3
48240: PUSH
48241: LD_INT 5
48243: PUSH
48244: EMPTY
48245: LIST
48246: LIST
48247: PUSH
48248: LD_INT 0
48250: PUSH
48251: LD_INT 3
48253: PUSH
48254: EMPTY
48255: LIST
48256: LIST
48257: PUSH
48258: LD_INT 0
48260: PUSH
48261: LD_INT 2
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: PUSH
48268: LD_INT 1
48270: PUSH
48271: LD_INT 3
48273: PUSH
48274: EMPTY
48275: LIST
48276: LIST
48277: PUSH
48278: LD_INT 1
48280: PUSH
48281: LD_INT 4
48283: PUSH
48284: EMPTY
48285: LIST
48286: LIST
48287: PUSH
48288: LD_INT 0
48290: PUSH
48291: LD_INT 4
48293: PUSH
48294: EMPTY
48295: LIST
48296: LIST
48297: PUSH
48298: LD_INT 1
48300: NEG
48301: PUSH
48302: LD_INT 3
48304: PUSH
48305: EMPTY
48306: LIST
48307: LIST
48308: PUSH
48309: LD_INT 1
48311: NEG
48312: PUSH
48313: LD_INT 2
48315: PUSH
48316: EMPTY
48317: LIST
48318: LIST
48319: PUSH
48320: LD_INT 2
48322: PUSH
48323: LD_INT 4
48325: PUSH
48326: EMPTY
48327: LIST
48328: LIST
48329: PUSH
48330: LD_INT 2
48332: NEG
48333: PUSH
48334: LD_INT 2
48336: PUSH
48337: EMPTY
48338: LIST
48339: LIST
48340: PUSH
48341: LD_INT 4
48343: NEG
48344: PUSH
48345: LD_INT 0
48347: PUSH
48348: EMPTY
48349: LIST
48350: LIST
48351: PUSH
48352: LD_INT 4
48354: NEG
48355: PUSH
48356: LD_INT 1
48358: NEG
48359: PUSH
48360: EMPTY
48361: LIST
48362: LIST
48363: PUSH
48364: LD_INT 3
48366: NEG
48367: PUSH
48368: LD_INT 0
48370: PUSH
48371: EMPTY
48372: LIST
48373: LIST
48374: PUSH
48375: LD_INT 3
48377: NEG
48378: PUSH
48379: LD_INT 1
48381: PUSH
48382: EMPTY
48383: LIST
48384: LIST
48385: PUSH
48386: LD_INT 4
48388: NEG
48389: PUSH
48390: LD_INT 1
48392: PUSH
48393: EMPTY
48394: LIST
48395: LIST
48396: PUSH
48397: LD_INT 5
48399: NEG
48400: PUSH
48401: LD_INT 0
48403: PUSH
48404: EMPTY
48405: LIST
48406: LIST
48407: PUSH
48408: LD_INT 5
48410: NEG
48411: PUSH
48412: LD_INT 1
48414: NEG
48415: PUSH
48416: EMPTY
48417: LIST
48418: LIST
48419: PUSH
48420: LD_INT 5
48422: NEG
48423: PUSH
48424: LD_INT 2
48426: NEG
48427: PUSH
48428: EMPTY
48429: LIST
48430: LIST
48431: PUSH
48432: LD_INT 3
48434: NEG
48435: PUSH
48436: LD_INT 2
48438: PUSH
48439: EMPTY
48440: LIST
48441: LIST
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: LIST
48447: LIST
48448: LIST
48449: LIST
48450: LIST
48451: LIST
48452: LIST
48453: LIST
48454: LIST
48455: LIST
48456: LIST
48457: LIST
48458: LIST
48459: LIST
48460: LIST
48461: LIST
48462: LIST
48463: LIST
48464: LIST
48465: LIST
48466: LIST
48467: LIST
48468: LIST
48469: LIST
48470: LIST
48471: LIST
48472: LIST
48473: LIST
48474: LIST
48475: LIST
48476: LIST
48477: LIST
48478: LIST
48479: LIST
48480: LIST
48481: LIST
48482: LIST
48483: LIST
48484: LIST
48485: LIST
48486: LIST
48487: LIST
48488: LIST
48489: ST_TO_ADDR
// end ; end ;
48490: GO 48493
48492: POP
// case btype of b_depot , b_warehouse :
48493: LD_VAR 0 1
48497: PUSH
48498: LD_INT 0
48500: DOUBLE
48501: EQUAL
48502: IFTRUE 48512
48504: LD_INT 1
48506: DOUBLE
48507: EQUAL
48508: IFTRUE 48512
48510: GO 48713
48512: POP
// case nation of nation_american :
48513: LD_VAR 0 5
48517: PUSH
48518: LD_INT 1
48520: DOUBLE
48521: EQUAL
48522: IFTRUE 48526
48524: GO 48582
48526: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
48527: LD_ADDR_VAR 0 9
48531: PUSH
48532: LD_VAR 0 11
48536: PUSH
48537: LD_VAR 0 12
48541: PUSH
48542: LD_VAR 0 13
48546: PUSH
48547: LD_VAR 0 14
48551: PUSH
48552: LD_VAR 0 15
48556: PUSH
48557: LD_VAR 0 16
48561: PUSH
48562: EMPTY
48563: LIST
48564: LIST
48565: LIST
48566: LIST
48567: LIST
48568: LIST
48569: PUSH
48570: LD_VAR 0 4
48574: PUSH
48575: LD_INT 1
48577: PLUS
48578: ARRAY
48579: ST_TO_ADDR
48580: GO 48711
48582: LD_INT 2
48584: DOUBLE
48585: EQUAL
48586: IFTRUE 48590
48588: GO 48646
48590: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
48591: LD_ADDR_VAR 0 9
48595: PUSH
48596: LD_VAR 0 17
48600: PUSH
48601: LD_VAR 0 18
48605: PUSH
48606: LD_VAR 0 19
48610: PUSH
48611: LD_VAR 0 20
48615: PUSH
48616: LD_VAR 0 21
48620: PUSH
48621: LD_VAR 0 22
48625: PUSH
48626: EMPTY
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: LIST
48632: LIST
48633: PUSH
48634: LD_VAR 0 4
48638: PUSH
48639: LD_INT 1
48641: PLUS
48642: ARRAY
48643: ST_TO_ADDR
48644: GO 48711
48646: LD_INT 3
48648: DOUBLE
48649: EQUAL
48650: IFTRUE 48654
48652: GO 48710
48654: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
48655: LD_ADDR_VAR 0 9
48659: PUSH
48660: LD_VAR 0 23
48664: PUSH
48665: LD_VAR 0 24
48669: PUSH
48670: LD_VAR 0 25
48674: PUSH
48675: LD_VAR 0 26
48679: PUSH
48680: LD_VAR 0 27
48684: PUSH
48685: LD_VAR 0 28
48689: PUSH
48690: EMPTY
48691: LIST
48692: LIST
48693: LIST
48694: LIST
48695: LIST
48696: LIST
48697: PUSH
48698: LD_VAR 0 4
48702: PUSH
48703: LD_INT 1
48705: PLUS
48706: ARRAY
48707: ST_TO_ADDR
48708: GO 48711
48710: POP
48711: GO 49266
48713: LD_INT 2
48715: DOUBLE
48716: EQUAL
48717: IFTRUE 48727
48719: LD_INT 3
48721: DOUBLE
48722: EQUAL
48723: IFTRUE 48727
48725: GO 48783
48727: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
48728: LD_ADDR_VAR 0 9
48732: PUSH
48733: LD_VAR 0 29
48737: PUSH
48738: LD_VAR 0 30
48742: PUSH
48743: LD_VAR 0 31
48747: PUSH
48748: LD_VAR 0 32
48752: PUSH
48753: LD_VAR 0 33
48757: PUSH
48758: LD_VAR 0 34
48762: PUSH
48763: EMPTY
48764: LIST
48765: LIST
48766: LIST
48767: LIST
48768: LIST
48769: LIST
48770: PUSH
48771: LD_VAR 0 4
48775: PUSH
48776: LD_INT 1
48778: PLUS
48779: ARRAY
48780: ST_TO_ADDR
48781: GO 49266
48783: LD_INT 16
48785: DOUBLE
48786: EQUAL
48787: IFTRUE 48845
48789: LD_INT 17
48791: DOUBLE
48792: EQUAL
48793: IFTRUE 48845
48795: LD_INT 18
48797: DOUBLE
48798: EQUAL
48799: IFTRUE 48845
48801: LD_INT 19
48803: DOUBLE
48804: EQUAL
48805: IFTRUE 48845
48807: LD_INT 22
48809: DOUBLE
48810: EQUAL
48811: IFTRUE 48845
48813: LD_INT 20
48815: DOUBLE
48816: EQUAL
48817: IFTRUE 48845
48819: LD_INT 21
48821: DOUBLE
48822: EQUAL
48823: IFTRUE 48845
48825: LD_INT 23
48827: DOUBLE
48828: EQUAL
48829: IFTRUE 48845
48831: LD_INT 24
48833: DOUBLE
48834: EQUAL
48835: IFTRUE 48845
48837: LD_INT 25
48839: DOUBLE
48840: EQUAL
48841: IFTRUE 48845
48843: GO 48901
48845: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
48846: LD_ADDR_VAR 0 9
48850: PUSH
48851: LD_VAR 0 35
48855: PUSH
48856: LD_VAR 0 36
48860: PUSH
48861: LD_VAR 0 37
48865: PUSH
48866: LD_VAR 0 38
48870: PUSH
48871: LD_VAR 0 39
48875: PUSH
48876: LD_VAR 0 40
48880: PUSH
48881: EMPTY
48882: LIST
48883: LIST
48884: LIST
48885: LIST
48886: LIST
48887: LIST
48888: PUSH
48889: LD_VAR 0 4
48893: PUSH
48894: LD_INT 1
48896: PLUS
48897: ARRAY
48898: ST_TO_ADDR
48899: GO 49266
48901: LD_INT 6
48903: DOUBLE
48904: EQUAL
48905: IFTRUE 48957
48907: LD_INT 7
48909: DOUBLE
48910: EQUAL
48911: IFTRUE 48957
48913: LD_INT 8
48915: DOUBLE
48916: EQUAL
48917: IFTRUE 48957
48919: LD_INT 13
48921: DOUBLE
48922: EQUAL
48923: IFTRUE 48957
48925: LD_INT 12
48927: DOUBLE
48928: EQUAL
48929: IFTRUE 48957
48931: LD_INT 15
48933: DOUBLE
48934: EQUAL
48935: IFTRUE 48957
48937: LD_INT 11
48939: DOUBLE
48940: EQUAL
48941: IFTRUE 48957
48943: LD_INT 14
48945: DOUBLE
48946: EQUAL
48947: IFTRUE 48957
48949: LD_INT 10
48951: DOUBLE
48952: EQUAL
48953: IFTRUE 48957
48955: GO 49013
48957: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
48958: LD_ADDR_VAR 0 9
48962: PUSH
48963: LD_VAR 0 41
48967: PUSH
48968: LD_VAR 0 42
48972: PUSH
48973: LD_VAR 0 43
48977: PUSH
48978: LD_VAR 0 44
48982: PUSH
48983: LD_VAR 0 45
48987: PUSH
48988: LD_VAR 0 46
48992: PUSH
48993: EMPTY
48994: LIST
48995: LIST
48996: LIST
48997: LIST
48998: LIST
48999: LIST
49000: PUSH
49001: LD_VAR 0 4
49005: PUSH
49006: LD_INT 1
49008: PLUS
49009: ARRAY
49010: ST_TO_ADDR
49011: GO 49266
49013: LD_INT 36
49015: DOUBLE
49016: EQUAL
49017: IFTRUE 49021
49019: GO 49077
49021: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
49022: LD_ADDR_VAR 0 9
49026: PUSH
49027: LD_VAR 0 47
49031: PUSH
49032: LD_VAR 0 48
49036: PUSH
49037: LD_VAR 0 49
49041: PUSH
49042: LD_VAR 0 50
49046: PUSH
49047: LD_VAR 0 51
49051: PUSH
49052: LD_VAR 0 52
49056: PUSH
49057: EMPTY
49058: LIST
49059: LIST
49060: LIST
49061: LIST
49062: LIST
49063: LIST
49064: PUSH
49065: LD_VAR 0 4
49069: PUSH
49070: LD_INT 1
49072: PLUS
49073: ARRAY
49074: ST_TO_ADDR
49075: GO 49266
49077: LD_INT 4
49079: DOUBLE
49080: EQUAL
49081: IFTRUE 49103
49083: LD_INT 5
49085: DOUBLE
49086: EQUAL
49087: IFTRUE 49103
49089: LD_INT 34
49091: DOUBLE
49092: EQUAL
49093: IFTRUE 49103
49095: LD_INT 37
49097: DOUBLE
49098: EQUAL
49099: IFTRUE 49103
49101: GO 49159
49103: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
49104: LD_ADDR_VAR 0 9
49108: PUSH
49109: LD_VAR 0 53
49113: PUSH
49114: LD_VAR 0 54
49118: PUSH
49119: LD_VAR 0 55
49123: PUSH
49124: LD_VAR 0 56
49128: PUSH
49129: LD_VAR 0 57
49133: PUSH
49134: LD_VAR 0 58
49138: PUSH
49139: EMPTY
49140: LIST
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: PUSH
49147: LD_VAR 0 4
49151: PUSH
49152: LD_INT 1
49154: PLUS
49155: ARRAY
49156: ST_TO_ADDR
49157: GO 49266
49159: LD_INT 31
49161: DOUBLE
49162: EQUAL
49163: IFTRUE 49209
49165: LD_INT 32
49167: DOUBLE
49168: EQUAL
49169: IFTRUE 49209
49171: LD_INT 33
49173: DOUBLE
49174: EQUAL
49175: IFTRUE 49209
49177: LD_INT 27
49179: DOUBLE
49180: EQUAL
49181: IFTRUE 49209
49183: LD_INT 26
49185: DOUBLE
49186: EQUAL
49187: IFTRUE 49209
49189: LD_INT 28
49191: DOUBLE
49192: EQUAL
49193: IFTRUE 49209
49195: LD_INT 29
49197: DOUBLE
49198: EQUAL
49199: IFTRUE 49209
49201: LD_INT 30
49203: DOUBLE
49204: EQUAL
49205: IFTRUE 49209
49207: GO 49265
49209: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
49210: LD_ADDR_VAR 0 9
49214: PUSH
49215: LD_VAR 0 59
49219: PUSH
49220: LD_VAR 0 60
49224: PUSH
49225: LD_VAR 0 61
49229: PUSH
49230: LD_VAR 0 62
49234: PUSH
49235: LD_VAR 0 63
49239: PUSH
49240: LD_VAR 0 64
49244: PUSH
49245: EMPTY
49246: LIST
49247: LIST
49248: LIST
49249: LIST
49250: LIST
49251: LIST
49252: PUSH
49253: LD_VAR 0 4
49257: PUSH
49258: LD_INT 1
49260: PLUS
49261: ARRAY
49262: ST_TO_ADDR
49263: GO 49266
49265: POP
// temp_list2 = [ ] ;
49266: LD_ADDR_VAR 0 10
49270: PUSH
49271: EMPTY
49272: ST_TO_ADDR
// for i in temp_list do
49273: LD_ADDR_VAR 0 8
49277: PUSH
49278: LD_VAR 0 9
49282: PUSH
49283: FOR_IN
49284: IFFALSE 49336
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
49286: LD_ADDR_VAR 0 10
49290: PUSH
49291: LD_VAR 0 10
49295: PUSH
49296: LD_VAR 0 8
49300: PUSH
49301: LD_INT 1
49303: ARRAY
49304: PUSH
49305: LD_VAR 0 2
49309: PLUS
49310: PUSH
49311: LD_VAR 0 8
49315: PUSH
49316: LD_INT 2
49318: ARRAY
49319: PUSH
49320: LD_VAR 0 3
49324: PLUS
49325: PUSH
49326: EMPTY
49327: LIST
49328: LIST
49329: PUSH
49330: EMPTY
49331: LIST
49332: ADD
49333: ST_TO_ADDR
49334: GO 49283
49336: POP
49337: POP
// result = temp_list2 ;
49338: LD_ADDR_VAR 0 7
49342: PUSH
49343: LD_VAR 0 10
49347: ST_TO_ADDR
// end ;
49348: LD_VAR 0 7
49352: RET
// export function EnemyInRange ( unit , dist ) ; begin
49353: LD_INT 0
49355: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
49356: LD_ADDR_VAR 0 3
49360: PUSH
49361: LD_VAR 0 1
49365: PPUSH
49366: CALL_OW 255
49370: PPUSH
49371: LD_VAR 0 1
49375: PPUSH
49376: CALL_OW 250
49380: PPUSH
49381: LD_VAR 0 1
49385: PPUSH
49386: CALL_OW 251
49390: PPUSH
49391: LD_VAR 0 2
49395: PPUSH
49396: CALL 22726 0 4
49400: PUSH
49401: LD_INT 4
49403: ARRAY
49404: ST_TO_ADDR
// end ;
49405: LD_VAR 0 3
49409: RET
// export function PlayerSeeMe ( unit ) ; begin
49410: LD_INT 0
49412: PPUSH
// result := See ( your_side , unit ) ;
49413: LD_ADDR_VAR 0 2
49417: PUSH
49418: LD_OWVAR 2
49422: PPUSH
49423: LD_VAR 0 1
49427: PPUSH
49428: CALL_OW 292
49432: ST_TO_ADDR
// end ;
49433: LD_VAR 0 2
49437: RET
// export function ReverseDir ( unit ) ; begin
49438: LD_INT 0
49440: PPUSH
// if not unit then
49441: LD_VAR 0 1
49445: NOT
49446: IFFALSE 49450
// exit ;
49448: GO 49473
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
49450: LD_ADDR_VAR 0 2
49454: PUSH
49455: LD_VAR 0 1
49459: PPUSH
49460: CALL_OW 254
49464: PUSH
49465: LD_INT 3
49467: PLUS
49468: PUSH
49469: LD_INT 6
49471: MOD
49472: ST_TO_ADDR
// end ;
49473: LD_VAR 0 2
49477: RET
// export function ReverseArray ( array ) ; var i ; begin
49478: LD_INT 0
49480: PPUSH
49481: PPUSH
// if not array then
49482: LD_VAR 0 1
49486: NOT
49487: IFFALSE 49491
// exit ;
49489: GO 49546
// result := [ ] ;
49491: LD_ADDR_VAR 0 2
49495: PUSH
49496: EMPTY
49497: ST_TO_ADDR
// for i := array downto 1 do
49498: LD_ADDR_VAR 0 3
49502: PUSH
49503: DOUBLE
49504: LD_VAR 0 1
49508: INC
49509: ST_TO_ADDR
49510: LD_INT 1
49512: PUSH
49513: FOR_DOWNTO
49514: IFFALSE 49544
// result := Join ( result , array [ i ] ) ;
49516: LD_ADDR_VAR 0 2
49520: PUSH
49521: LD_VAR 0 2
49525: PPUSH
49526: LD_VAR 0 1
49530: PUSH
49531: LD_VAR 0 3
49535: ARRAY
49536: PPUSH
49537: CALL 54191 0 2
49541: ST_TO_ADDR
49542: GO 49513
49544: POP
49545: POP
// end ;
49546: LD_VAR 0 2
49550: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
49551: LD_INT 0
49553: PPUSH
49554: PPUSH
49555: PPUSH
49556: PPUSH
49557: PPUSH
49558: PPUSH
// if not unit or not hexes then
49559: LD_VAR 0 1
49563: NOT
49564: PUSH
49565: LD_VAR 0 2
49569: NOT
49570: OR
49571: IFFALSE 49575
// exit ;
49573: GO 49698
// dist := 9999 ;
49575: LD_ADDR_VAR 0 5
49579: PUSH
49580: LD_INT 9999
49582: ST_TO_ADDR
// for i = 1 to hexes do
49583: LD_ADDR_VAR 0 4
49587: PUSH
49588: DOUBLE
49589: LD_INT 1
49591: DEC
49592: ST_TO_ADDR
49593: LD_VAR 0 2
49597: PUSH
49598: FOR_TO
49599: IFFALSE 49686
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
49601: LD_ADDR_VAR 0 6
49605: PUSH
49606: LD_VAR 0 1
49610: PPUSH
49611: LD_VAR 0 2
49615: PUSH
49616: LD_VAR 0 4
49620: ARRAY
49621: PUSH
49622: LD_INT 1
49624: ARRAY
49625: PPUSH
49626: LD_VAR 0 2
49630: PUSH
49631: LD_VAR 0 4
49635: ARRAY
49636: PUSH
49637: LD_INT 2
49639: ARRAY
49640: PPUSH
49641: CALL_OW 297
49645: ST_TO_ADDR
// if tdist < dist then
49646: LD_VAR 0 6
49650: PUSH
49651: LD_VAR 0 5
49655: LESS
49656: IFFALSE 49684
// begin hex := hexes [ i ] ;
49658: LD_ADDR_VAR 0 8
49662: PUSH
49663: LD_VAR 0 2
49667: PUSH
49668: LD_VAR 0 4
49672: ARRAY
49673: ST_TO_ADDR
// dist := tdist ;
49674: LD_ADDR_VAR 0 5
49678: PUSH
49679: LD_VAR 0 6
49683: ST_TO_ADDR
// end ; end ;
49684: GO 49598
49686: POP
49687: POP
// result := hex ;
49688: LD_ADDR_VAR 0 3
49692: PUSH
49693: LD_VAR 0 8
49697: ST_TO_ADDR
// end ;
49698: LD_VAR 0 3
49702: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
49703: LD_INT 0
49705: PPUSH
49706: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
49707: LD_VAR 0 1
49711: NOT
49712: PUSH
49713: LD_VAR 0 1
49717: PUSH
49718: LD_INT 21
49720: PUSH
49721: LD_INT 2
49723: PUSH
49724: EMPTY
49725: LIST
49726: LIST
49727: PUSH
49728: LD_INT 23
49730: PUSH
49731: LD_INT 2
49733: PUSH
49734: EMPTY
49735: LIST
49736: LIST
49737: PUSH
49738: EMPTY
49739: LIST
49740: LIST
49741: PPUSH
49742: CALL_OW 69
49746: IN
49747: NOT
49748: OR
49749: IFFALSE 49753
// exit ;
49751: GO 49800
// for i = 1 to 3 do
49753: LD_ADDR_VAR 0 3
49757: PUSH
49758: DOUBLE
49759: LD_INT 1
49761: DEC
49762: ST_TO_ADDR
49763: LD_INT 3
49765: PUSH
49766: FOR_TO
49767: IFFALSE 49798
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
49769: LD_VAR 0 1
49773: PPUSH
49774: CALL_OW 250
49778: PPUSH
49779: LD_VAR 0 1
49783: PPUSH
49784: CALL_OW 251
49788: PPUSH
49789: LD_INT 1
49791: PPUSH
49792: CALL_OW 453
49796: GO 49766
49798: POP
49799: POP
// end ;
49800: LD_VAR 0 2
49804: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
49805: LD_INT 0
49807: PPUSH
49808: PPUSH
49809: PPUSH
49810: PPUSH
49811: PPUSH
49812: PPUSH
// if not unit or not enemy_unit then
49813: LD_VAR 0 1
49817: NOT
49818: PUSH
49819: LD_VAR 0 2
49823: NOT
49824: OR
49825: IFFALSE 49829
// exit ;
49827: GO 50296
// if GetLives ( i ) < 250 then
49829: LD_VAR 0 4
49833: PPUSH
49834: CALL_OW 256
49838: PUSH
49839: LD_INT 250
49841: LESS
49842: IFFALSE 49855
// begin ComAutodestruct ( i ) ;
49844: LD_VAR 0 4
49848: PPUSH
49849: CALL 49703 0 1
// exit ;
49853: GO 50296
// end ; x := GetX ( enemy_unit ) ;
49855: LD_ADDR_VAR 0 7
49859: PUSH
49860: LD_VAR 0 2
49864: PPUSH
49865: CALL_OW 250
49869: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
49870: LD_ADDR_VAR 0 8
49874: PUSH
49875: LD_VAR 0 2
49879: PPUSH
49880: CALL_OW 251
49884: ST_TO_ADDR
// if not x or not y then
49885: LD_VAR 0 7
49889: NOT
49890: PUSH
49891: LD_VAR 0 8
49895: NOT
49896: OR
49897: IFFALSE 49901
// exit ;
49899: GO 50296
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
49901: LD_ADDR_VAR 0 6
49905: PUSH
49906: LD_VAR 0 7
49910: PPUSH
49911: LD_INT 0
49913: PPUSH
49914: LD_INT 4
49916: PPUSH
49917: CALL_OW 272
49921: PUSH
49922: LD_VAR 0 8
49926: PPUSH
49927: LD_INT 0
49929: PPUSH
49930: LD_INT 4
49932: PPUSH
49933: CALL_OW 273
49937: PUSH
49938: EMPTY
49939: LIST
49940: LIST
49941: PUSH
49942: LD_VAR 0 7
49946: PPUSH
49947: LD_INT 1
49949: PPUSH
49950: LD_INT 4
49952: PPUSH
49953: CALL_OW 272
49957: PUSH
49958: LD_VAR 0 8
49962: PPUSH
49963: LD_INT 1
49965: PPUSH
49966: LD_INT 4
49968: PPUSH
49969: CALL_OW 273
49973: PUSH
49974: EMPTY
49975: LIST
49976: LIST
49977: PUSH
49978: LD_VAR 0 7
49982: PPUSH
49983: LD_INT 2
49985: PPUSH
49986: LD_INT 4
49988: PPUSH
49989: CALL_OW 272
49993: PUSH
49994: LD_VAR 0 8
49998: PPUSH
49999: LD_INT 2
50001: PPUSH
50002: LD_INT 4
50004: PPUSH
50005: CALL_OW 273
50009: PUSH
50010: EMPTY
50011: LIST
50012: LIST
50013: PUSH
50014: LD_VAR 0 7
50018: PPUSH
50019: LD_INT 3
50021: PPUSH
50022: LD_INT 4
50024: PPUSH
50025: CALL_OW 272
50029: PUSH
50030: LD_VAR 0 8
50034: PPUSH
50035: LD_INT 3
50037: PPUSH
50038: LD_INT 4
50040: PPUSH
50041: CALL_OW 273
50045: PUSH
50046: EMPTY
50047: LIST
50048: LIST
50049: PUSH
50050: LD_VAR 0 7
50054: PPUSH
50055: LD_INT 4
50057: PPUSH
50058: LD_INT 4
50060: PPUSH
50061: CALL_OW 272
50065: PUSH
50066: LD_VAR 0 8
50070: PPUSH
50071: LD_INT 4
50073: PPUSH
50074: LD_INT 4
50076: PPUSH
50077: CALL_OW 273
50081: PUSH
50082: EMPTY
50083: LIST
50084: LIST
50085: PUSH
50086: LD_VAR 0 7
50090: PPUSH
50091: LD_INT 5
50093: PPUSH
50094: LD_INT 4
50096: PPUSH
50097: CALL_OW 272
50101: PUSH
50102: LD_VAR 0 8
50106: PPUSH
50107: LD_INT 5
50109: PPUSH
50110: LD_INT 4
50112: PPUSH
50113: CALL_OW 273
50117: PUSH
50118: EMPTY
50119: LIST
50120: LIST
50121: PUSH
50122: EMPTY
50123: LIST
50124: LIST
50125: LIST
50126: LIST
50127: LIST
50128: LIST
50129: ST_TO_ADDR
// for i = tmp downto 1 do
50130: LD_ADDR_VAR 0 4
50134: PUSH
50135: DOUBLE
50136: LD_VAR 0 6
50140: INC
50141: ST_TO_ADDR
50142: LD_INT 1
50144: PUSH
50145: FOR_DOWNTO
50146: IFFALSE 50247
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
50148: LD_VAR 0 6
50152: PUSH
50153: LD_VAR 0 4
50157: ARRAY
50158: PUSH
50159: LD_INT 1
50161: ARRAY
50162: PPUSH
50163: LD_VAR 0 6
50167: PUSH
50168: LD_VAR 0 4
50172: ARRAY
50173: PUSH
50174: LD_INT 2
50176: ARRAY
50177: PPUSH
50178: CALL_OW 488
50182: NOT
50183: PUSH
50184: LD_VAR 0 6
50188: PUSH
50189: LD_VAR 0 4
50193: ARRAY
50194: PUSH
50195: LD_INT 1
50197: ARRAY
50198: PPUSH
50199: LD_VAR 0 6
50203: PUSH
50204: LD_VAR 0 4
50208: ARRAY
50209: PUSH
50210: LD_INT 2
50212: ARRAY
50213: PPUSH
50214: CALL_OW 428
50218: PUSH
50219: LD_INT 0
50221: NONEQUAL
50222: OR
50223: IFFALSE 50245
// tmp := Delete ( tmp , i ) ;
50225: LD_ADDR_VAR 0 6
50229: PUSH
50230: LD_VAR 0 6
50234: PPUSH
50235: LD_VAR 0 4
50239: PPUSH
50240: CALL_OW 3
50244: ST_TO_ADDR
50245: GO 50145
50247: POP
50248: POP
// j := GetClosestHex ( unit , tmp ) ;
50249: LD_ADDR_VAR 0 5
50253: PUSH
50254: LD_VAR 0 1
50258: PPUSH
50259: LD_VAR 0 6
50263: PPUSH
50264: CALL 49551 0 2
50268: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
50269: LD_VAR 0 1
50273: PPUSH
50274: LD_VAR 0 5
50278: PUSH
50279: LD_INT 1
50281: ARRAY
50282: PPUSH
50283: LD_VAR 0 5
50287: PUSH
50288: LD_INT 2
50290: ARRAY
50291: PPUSH
50292: CALL_OW 111
// end ;
50296: LD_VAR 0 3
50300: RET
// export function PrepareApemanSoldier ( ) ; begin
50301: LD_INT 0
50303: PPUSH
// uc_nation := 0 ;
50304: LD_ADDR_OWVAR 21
50308: PUSH
50309: LD_INT 0
50311: ST_TO_ADDR
// hc_sex := sex_male ;
50312: LD_ADDR_OWVAR 27
50316: PUSH
50317: LD_INT 1
50319: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
50320: LD_ADDR_OWVAR 28
50324: PUSH
50325: LD_INT 15
50327: ST_TO_ADDR
// hc_gallery :=  ;
50328: LD_ADDR_OWVAR 33
50332: PUSH
50333: LD_STRING 
50335: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50336: LD_ADDR_OWVAR 31
50340: PUSH
50341: LD_INT 0
50343: PPUSH
50344: LD_INT 3
50346: PPUSH
50347: CALL_OW 12
50351: PUSH
50352: LD_INT 0
50354: PPUSH
50355: LD_INT 3
50357: PPUSH
50358: CALL_OW 12
50362: PUSH
50363: LD_INT 0
50365: PUSH
50366: LD_INT 0
50368: PUSH
50369: EMPTY
50370: LIST
50371: LIST
50372: LIST
50373: LIST
50374: ST_TO_ADDR
// end ;
50375: LD_VAR 0 1
50379: RET
// export function PrepareApemanEngineer ( ) ; begin
50380: LD_INT 0
50382: PPUSH
// uc_nation := 0 ;
50383: LD_ADDR_OWVAR 21
50387: PUSH
50388: LD_INT 0
50390: ST_TO_ADDR
// hc_sex := sex_male ;
50391: LD_ADDR_OWVAR 27
50395: PUSH
50396: LD_INT 1
50398: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
50399: LD_ADDR_OWVAR 28
50403: PUSH
50404: LD_INT 16
50406: ST_TO_ADDR
// hc_gallery :=  ;
50407: LD_ADDR_OWVAR 33
50411: PUSH
50412: LD_STRING 
50414: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50415: LD_ADDR_OWVAR 31
50419: PUSH
50420: LD_INT 0
50422: PPUSH
50423: LD_INT 3
50425: PPUSH
50426: CALL_OW 12
50430: PUSH
50431: LD_INT 0
50433: PPUSH
50434: LD_INT 3
50436: PPUSH
50437: CALL_OW 12
50441: PUSH
50442: LD_INT 0
50444: PUSH
50445: LD_INT 0
50447: PUSH
50448: EMPTY
50449: LIST
50450: LIST
50451: LIST
50452: LIST
50453: ST_TO_ADDR
// end ;
50454: LD_VAR 0 1
50458: RET
// export function PrepareApeman ( agressivity ) ; begin
50459: LD_INT 0
50461: PPUSH
// uc_side := 0 ;
50462: LD_ADDR_OWVAR 20
50466: PUSH
50467: LD_INT 0
50469: ST_TO_ADDR
// uc_nation := 0 ;
50470: LD_ADDR_OWVAR 21
50474: PUSH
50475: LD_INT 0
50477: ST_TO_ADDR
// hc_sex := sex_male ;
50478: LD_ADDR_OWVAR 27
50482: PUSH
50483: LD_INT 1
50485: ST_TO_ADDR
// hc_class := class_apeman ;
50486: LD_ADDR_OWVAR 28
50490: PUSH
50491: LD_INT 12
50493: ST_TO_ADDR
// hc_gallery :=  ;
50494: LD_ADDR_OWVAR 33
50498: PUSH
50499: LD_STRING 
50501: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
50502: LD_ADDR_OWVAR 35
50506: PUSH
50507: LD_VAR 0 1
50511: NEG
50512: PPUSH
50513: LD_VAR 0 1
50517: PPUSH
50518: CALL_OW 12
50522: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50523: LD_ADDR_OWVAR 31
50527: PUSH
50528: LD_INT 0
50530: PPUSH
50531: LD_INT 3
50533: PPUSH
50534: CALL_OW 12
50538: PUSH
50539: LD_INT 0
50541: PPUSH
50542: LD_INT 3
50544: PPUSH
50545: CALL_OW 12
50549: PUSH
50550: LD_INT 0
50552: PUSH
50553: LD_INT 0
50555: PUSH
50556: EMPTY
50557: LIST
50558: LIST
50559: LIST
50560: LIST
50561: ST_TO_ADDR
// end ;
50562: LD_VAR 0 2
50566: RET
// export function PrepareTiger ( agressivity ) ; begin
50567: LD_INT 0
50569: PPUSH
// uc_side := 0 ;
50570: LD_ADDR_OWVAR 20
50574: PUSH
50575: LD_INT 0
50577: ST_TO_ADDR
// uc_nation := 0 ;
50578: LD_ADDR_OWVAR 21
50582: PUSH
50583: LD_INT 0
50585: ST_TO_ADDR
// hc_class := class_tiger ;
50586: LD_ADDR_OWVAR 28
50590: PUSH
50591: LD_INT 14
50593: ST_TO_ADDR
// hc_gallery :=  ;
50594: LD_ADDR_OWVAR 33
50598: PUSH
50599: LD_STRING 
50601: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
50602: LD_ADDR_OWVAR 35
50606: PUSH
50607: LD_VAR 0 1
50611: NEG
50612: PPUSH
50613: LD_VAR 0 1
50617: PPUSH
50618: CALL_OW 12
50622: ST_TO_ADDR
// end ;
50623: LD_VAR 0 2
50627: RET
// export function PrepareEnchidna ( ) ; begin
50628: LD_INT 0
50630: PPUSH
// uc_side := 0 ;
50631: LD_ADDR_OWVAR 20
50635: PUSH
50636: LD_INT 0
50638: ST_TO_ADDR
// uc_nation := 0 ;
50639: LD_ADDR_OWVAR 21
50643: PUSH
50644: LD_INT 0
50646: ST_TO_ADDR
// hc_class := class_baggie ;
50647: LD_ADDR_OWVAR 28
50651: PUSH
50652: LD_INT 13
50654: ST_TO_ADDR
// hc_gallery :=  ;
50655: LD_ADDR_OWVAR 33
50659: PUSH
50660: LD_STRING 
50662: ST_TO_ADDR
// end ;
50663: LD_VAR 0 1
50667: RET
// export function PrepareFrog ( ) ; begin
50668: LD_INT 0
50670: PPUSH
// uc_side := 0 ;
50671: LD_ADDR_OWVAR 20
50675: PUSH
50676: LD_INT 0
50678: ST_TO_ADDR
// uc_nation := 0 ;
50679: LD_ADDR_OWVAR 21
50683: PUSH
50684: LD_INT 0
50686: ST_TO_ADDR
// hc_class := class_frog ;
50687: LD_ADDR_OWVAR 28
50691: PUSH
50692: LD_INT 19
50694: ST_TO_ADDR
// hc_gallery :=  ;
50695: LD_ADDR_OWVAR 33
50699: PUSH
50700: LD_STRING 
50702: ST_TO_ADDR
// end ;
50703: LD_VAR 0 1
50707: RET
// export function PrepareFish ( ) ; begin
50708: LD_INT 0
50710: PPUSH
// uc_side := 0 ;
50711: LD_ADDR_OWVAR 20
50715: PUSH
50716: LD_INT 0
50718: ST_TO_ADDR
// uc_nation := 0 ;
50719: LD_ADDR_OWVAR 21
50723: PUSH
50724: LD_INT 0
50726: ST_TO_ADDR
// hc_class := class_fish ;
50727: LD_ADDR_OWVAR 28
50731: PUSH
50732: LD_INT 20
50734: ST_TO_ADDR
// hc_gallery :=  ;
50735: LD_ADDR_OWVAR 33
50739: PUSH
50740: LD_STRING 
50742: ST_TO_ADDR
// end ;
50743: LD_VAR 0 1
50747: RET
// export function PrepareBird ( ) ; begin
50748: LD_INT 0
50750: PPUSH
// uc_side := 0 ;
50751: LD_ADDR_OWVAR 20
50755: PUSH
50756: LD_INT 0
50758: ST_TO_ADDR
// uc_nation := 0 ;
50759: LD_ADDR_OWVAR 21
50763: PUSH
50764: LD_INT 0
50766: ST_TO_ADDR
// hc_class := class_phororhacos ;
50767: LD_ADDR_OWVAR 28
50771: PUSH
50772: LD_INT 18
50774: ST_TO_ADDR
// hc_gallery :=  ;
50775: LD_ADDR_OWVAR 33
50779: PUSH
50780: LD_STRING 
50782: ST_TO_ADDR
// end ;
50783: LD_VAR 0 1
50787: RET
// export function PrepareHorse ( ) ; begin
50788: LD_INT 0
50790: PPUSH
// uc_side := 0 ;
50791: LD_ADDR_OWVAR 20
50795: PUSH
50796: LD_INT 0
50798: ST_TO_ADDR
// uc_nation := 0 ;
50799: LD_ADDR_OWVAR 21
50803: PUSH
50804: LD_INT 0
50806: ST_TO_ADDR
// hc_class := class_horse ;
50807: LD_ADDR_OWVAR 28
50811: PUSH
50812: LD_INT 21
50814: ST_TO_ADDR
// hc_gallery :=  ;
50815: LD_ADDR_OWVAR 33
50819: PUSH
50820: LD_STRING 
50822: ST_TO_ADDR
// end ;
50823: LD_VAR 0 1
50827: RET
// export function PrepareMastodont ( ) ; begin
50828: LD_INT 0
50830: PPUSH
// uc_side := 0 ;
50831: LD_ADDR_OWVAR 20
50835: PUSH
50836: LD_INT 0
50838: ST_TO_ADDR
// uc_nation := 0 ;
50839: LD_ADDR_OWVAR 21
50843: PUSH
50844: LD_INT 0
50846: ST_TO_ADDR
// vc_chassis := class_mastodont ;
50847: LD_ADDR_OWVAR 37
50851: PUSH
50852: LD_INT 31
50854: ST_TO_ADDR
// vc_control := control_rider ;
50855: LD_ADDR_OWVAR 38
50859: PUSH
50860: LD_INT 4
50862: ST_TO_ADDR
// end ;
50863: LD_VAR 0 1
50867: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
50868: LD_INT 0
50870: PPUSH
50871: PPUSH
50872: PPUSH
// uc_side = 0 ;
50873: LD_ADDR_OWVAR 20
50877: PUSH
50878: LD_INT 0
50880: ST_TO_ADDR
// uc_nation = 0 ;
50881: LD_ADDR_OWVAR 21
50885: PUSH
50886: LD_INT 0
50888: ST_TO_ADDR
// InitHc_All ( ) ;
50889: CALL_OW 584
// InitVc ;
50893: CALL_OW 20
// if mastodonts then
50897: LD_VAR 0 6
50901: IFFALSE 50968
// for i = 1 to mastodonts do
50903: LD_ADDR_VAR 0 11
50907: PUSH
50908: DOUBLE
50909: LD_INT 1
50911: DEC
50912: ST_TO_ADDR
50913: LD_VAR 0 6
50917: PUSH
50918: FOR_TO
50919: IFFALSE 50966
// begin vc_chassis := 31 ;
50921: LD_ADDR_OWVAR 37
50925: PUSH
50926: LD_INT 31
50928: ST_TO_ADDR
// vc_control := control_rider ;
50929: LD_ADDR_OWVAR 38
50933: PUSH
50934: LD_INT 4
50936: ST_TO_ADDR
// animal := CreateVehicle ;
50937: LD_ADDR_VAR 0 12
50941: PUSH
50942: CALL_OW 45
50946: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50947: LD_VAR 0 12
50951: PPUSH
50952: LD_VAR 0 8
50956: PPUSH
50957: LD_INT 0
50959: PPUSH
50960: CALL 53096 0 3
// end ;
50964: GO 50918
50966: POP
50967: POP
// if horses then
50968: LD_VAR 0 5
50972: IFFALSE 51039
// for i = 1 to horses do
50974: LD_ADDR_VAR 0 11
50978: PUSH
50979: DOUBLE
50980: LD_INT 1
50982: DEC
50983: ST_TO_ADDR
50984: LD_VAR 0 5
50988: PUSH
50989: FOR_TO
50990: IFFALSE 51037
// begin hc_class := 21 ;
50992: LD_ADDR_OWVAR 28
50996: PUSH
50997: LD_INT 21
50999: ST_TO_ADDR
// hc_gallery :=  ;
51000: LD_ADDR_OWVAR 33
51004: PUSH
51005: LD_STRING 
51007: ST_TO_ADDR
// animal := CreateHuman ;
51008: LD_ADDR_VAR 0 12
51012: PUSH
51013: CALL_OW 44
51017: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51018: LD_VAR 0 12
51022: PPUSH
51023: LD_VAR 0 8
51027: PPUSH
51028: LD_INT 0
51030: PPUSH
51031: CALL 53096 0 3
// end ;
51035: GO 50989
51037: POP
51038: POP
// if birds then
51039: LD_VAR 0 1
51043: IFFALSE 51110
// for i = 1 to birds do
51045: LD_ADDR_VAR 0 11
51049: PUSH
51050: DOUBLE
51051: LD_INT 1
51053: DEC
51054: ST_TO_ADDR
51055: LD_VAR 0 1
51059: PUSH
51060: FOR_TO
51061: IFFALSE 51108
// begin hc_class := 18 ;
51063: LD_ADDR_OWVAR 28
51067: PUSH
51068: LD_INT 18
51070: ST_TO_ADDR
// hc_gallery =  ;
51071: LD_ADDR_OWVAR 33
51075: PUSH
51076: LD_STRING 
51078: ST_TO_ADDR
// animal := CreateHuman ;
51079: LD_ADDR_VAR 0 12
51083: PUSH
51084: CALL_OW 44
51088: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51089: LD_VAR 0 12
51093: PPUSH
51094: LD_VAR 0 8
51098: PPUSH
51099: LD_INT 0
51101: PPUSH
51102: CALL 53096 0 3
// end ;
51106: GO 51060
51108: POP
51109: POP
// if tigers then
51110: LD_VAR 0 2
51114: IFFALSE 51198
// for i = 1 to tigers do
51116: LD_ADDR_VAR 0 11
51120: PUSH
51121: DOUBLE
51122: LD_INT 1
51124: DEC
51125: ST_TO_ADDR
51126: LD_VAR 0 2
51130: PUSH
51131: FOR_TO
51132: IFFALSE 51196
// begin hc_class = class_tiger ;
51134: LD_ADDR_OWVAR 28
51138: PUSH
51139: LD_INT 14
51141: ST_TO_ADDR
// hc_gallery =  ;
51142: LD_ADDR_OWVAR 33
51146: PUSH
51147: LD_STRING 
51149: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
51150: LD_ADDR_OWVAR 35
51154: PUSH
51155: LD_INT 7
51157: NEG
51158: PPUSH
51159: LD_INT 7
51161: PPUSH
51162: CALL_OW 12
51166: ST_TO_ADDR
// animal := CreateHuman ;
51167: LD_ADDR_VAR 0 12
51171: PUSH
51172: CALL_OW 44
51176: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51177: LD_VAR 0 12
51181: PPUSH
51182: LD_VAR 0 8
51186: PPUSH
51187: LD_INT 0
51189: PPUSH
51190: CALL 53096 0 3
// end ;
51194: GO 51131
51196: POP
51197: POP
// if apemans then
51198: LD_VAR 0 3
51202: IFFALSE 51325
// for i = 1 to apemans do
51204: LD_ADDR_VAR 0 11
51208: PUSH
51209: DOUBLE
51210: LD_INT 1
51212: DEC
51213: ST_TO_ADDR
51214: LD_VAR 0 3
51218: PUSH
51219: FOR_TO
51220: IFFALSE 51323
// begin hc_class = class_apeman ;
51222: LD_ADDR_OWVAR 28
51226: PUSH
51227: LD_INT 12
51229: ST_TO_ADDR
// hc_gallery =  ;
51230: LD_ADDR_OWVAR 33
51234: PUSH
51235: LD_STRING 
51237: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
51238: LD_ADDR_OWVAR 35
51242: PUSH
51243: LD_INT 2
51245: NEG
51246: PPUSH
51247: LD_INT 2
51249: PPUSH
51250: CALL_OW 12
51254: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
51255: LD_ADDR_OWVAR 31
51259: PUSH
51260: LD_INT 1
51262: PPUSH
51263: LD_INT 3
51265: PPUSH
51266: CALL_OW 12
51270: PUSH
51271: LD_INT 1
51273: PPUSH
51274: LD_INT 3
51276: PPUSH
51277: CALL_OW 12
51281: PUSH
51282: LD_INT 0
51284: PUSH
51285: LD_INT 0
51287: PUSH
51288: EMPTY
51289: LIST
51290: LIST
51291: LIST
51292: LIST
51293: ST_TO_ADDR
// animal := CreateHuman ;
51294: LD_ADDR_VAR 0 12
51298: PUSH
51299: CALL_OW 44
51303: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51304: LD_VAR 0 12
51308: PPUSH
51309: LD_VAR 0 8
51313: PPUSH
51314: LD_INT 0
51316: PPUSH
51317: CALL 53096 0 3
// end ;
51321: GO 51219
51323: POP
51324: POP
// if enchidnas then
51325: LD_VAR 0 4
51329: IFFALSE 51396
// for i = 1 to enchidnas do
51331: LD_ADDR_VAR 0 11
51335: PUSH
51336: DOUBLE
51337: LD_INT 1
51339: DEC
51340: ST_TO_ADDR
51341: LD_VAR 0 4
51345: PUSH
51346: FOR_TO
51347: IFFALSE 51394
// begin hc_class = 13 ;
51349: LD_ADDR_OWVAR 28
51353: PUSH
51354: LD_INT 13
51356: ST_TO_ADDR
// hc_gallery =  ;
51357: LD_ADDR_OWVAR 33
51361: PUSH
51362: LD_STRING 
51364: ST_TO_ADDR
// animal := CreateHuman ;
51365: LD_ADDR_VAR 0 12
51369: PUSH
51370: CALL_OW 44
51374: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51375: LD_VAR 0 12
51379: PPUSH
51380: LD_VAR 0 8
51384: PPUSH
51385: LD_INT 0
51387: PPUSH
51388: CALL 53096 0 3
// end ;
51392: GO 51346
51394: POP
51395: POP
// if fishes then
51396: LD_VAR 0 7
51400: IFFALSE 51467
// for i = 1 to fishes do
51402: LD_ADDR_VAR 0 11
51406: PUSH
51407: DOUBLE
51408: LD_INT 1
51410: DEC
51411: ST_TO_ADDR
51412: LD_VAR 0 7
51416: PUSH
51417: FOR_TO
51418: IFFALSE 51465
// begin hc_class = 20 ;
51420: LD_ADDR_OWVAR 28
51424: PUSH
51425: LD_INT 20
51427: ST_TO_ADDR
// hc_gallery =  ;
51428: LD_ADDR_OWVAR 33
51432: PUSH
51433: LD_STRING 
51435: ST_TO_ADDR
// animal := CreateHuman ;
51436: LD_ADDR_VAR 0 12
51440: PUSH
51441: CALL_OW 44
51445: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
51446: LD_VAR 0 12
51450: PPUSH
51451: LD_VAR 0 9
51455: PPUSH
51456: LD_INT 0
51458: PPUSH
51459: CALL 53096 0 3
// end ;
51463: GO 51417
51465: POP
51466: POP
// end ;
51467: LD_VAR 0 10
51471: RET
// export function WantHeal ( sci , unit ) ; begin
51472: LD_INT 0
51474: PPUSH
// if GetTaskList ( sci ) > 0 then
51475: LD_VAR 0 1
51479: PPUSH
51480: CALL_OW 437
51484: PUSH
51485: LD_INT 0
51487: GREATER
51488: IFFALSE 51558
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
51490: LD_VAR 0 1
51494: PPUSH
51495: CALL_OW 437
51499: PUSH
51500: LD_INT 1
51502: ARRAY
51503: PUSH
51504: LD_INT 1
51506: ARRAY
51507: PUSH
51508: LD_STRING l
51510: EQUAL
51511: PUSH
51512: LD_VAR 0 1
51516: PPUSH
51517: CALL_OW 437
51521: PUSH
51522: LD_INT 1
51524: ARRAY
51525: PUSH
51526: LD_INT 4
51528: ARRAY
51529: PUSH
51530: LD_VAR 0 2
51534: EQUAL
51535: AND
51536: IFFALSE 51548
// result := true else
51538: LD_ADDR_VAR 0 3
51542: PUSH
51543: LD_INT 1
51545: ST_TO_ADDR
51546: GO 51556
// result := false ;
51548: LD_ADDR_VAR 0 3
51552: PUSH
51553: LD_INT 0
51555: ST_TO_ADDR
// end else
51556: GO 51566
// result := false ;
51558: LD_ADDR_VAR 0 3
51562: PUSH
51563: LD_INT 0
51565: ST_TO_ADDR
// end ;
51566: LD_VAR 0 3
51570: RET
// export function HealTarget ( sci ) ; begin
51571: LD_INT 0
51573: PPUSH
// if not sci then
51574: LD_VAR 0 1
51578: NOT
51579: IFFALSE 51583
// exit ;
51581: GO 51648
// result := 0 ;
51583: LD_ADDR_VAR 0 2
51587: PUSH
51588: LD_INT 0
51590: ST_TO_ADDR
// if GetTaskList ( sci ) then
51591: LD_VAR 0 1
51595: PPUSH
51596: CALL_OW 437
51600: IFFALSE 51648
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
51602: LD_VAR 0 1
51606: PPUSH
51607: CALL_OW 437
51611: PUSH
51612: LD_INT 1
51614: ARRAY
51615: PUSH
51616: LD_INT 1
51618: ARRAY
51619: PUSH
51620: LD_STRING l
51622: EQUAL
51623: IFFALSE 51648
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
51625: LD_ADDR_VAR 0 2
51629: PUSH
51630: LD_VAR 0 1
51634: PPUSH
51635: CALL_OW 437
51639: PUSH
51640: LD_INT 1
51642: ARRAY
51643: PUSH
51644: LD_INT 4
51646: ARRAY
51647: ST_TO_ADDR
// end ;
51648: LD_VAR 0 2
51652: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
51653: LD_INT 0
51655: PPUSH
51656: PPUSH
51657: PPUSH
51658: PPUSH
// if not base_units then
51659: LD_VAR 0 1
51663: NOT
51664: IFFALSE 51668
// exit ;
51666: GO 51755
// result := false ;
51668: LD_ADDR_VAR 0 2
51672: PUSH
51673: LD_INT 0
51675: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
51676: LD_ADDR_VAR 0 5
51680: PUSH
51681: LD_VAR 0 1
51685: PPUSH
51686: LD_INT 21
51688: PUSH
51689: LD_INT 3
51691: PUSH
51692: EMPTY
51693: LIST
51694: LIST
51695: PPUSH
51696: CALL_OW 72
51700: ST_TO_ADDR
// if not tmp then
51701: LD_VAR 0 5
51705: NOT
51706: IFFALSE 51710
// exit ;
51708: GO 51755
// for i in tmp do
51710: LD_ADDR_VAR 0 3
51714: PUSH
51715: LD_VAR 0 5
51719: PUSH
51720: FOR_IN
51721: IFFALSE 51753
// begin result := EnemyInRange ( i , 22 ) ;
51723: LD_ADDR_VAR 0 2
51727: PUSH
51728: LD_VAR 0 3
51732: PPUSH
51733: LD_INT 22
51735: PPUSH
51736: CALL 49353 0 2
51740: ST_TO_ADDR
// if result then
51741: LD_VAR 0 2
51745: IFFALSE 51751
// exit ;
51747: POP
51748: POP
51749: GO 51755
// end ;
51751: GO 51720
51753: POP
51754: POP
// end ;
51755: LD_VAR 0 2
51759: RET
// export function FilterByTag ( units , tag ) ; begin
51760: LD_INT 0
51762: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
51763: LD_ADDR_VAR 0 3
51767: PUSH
51768: LD_VAR 0 1
51772: PPUSH
51773: LD_INT 120
51775: PUSH
51776: LD_VAR 0 2
51780: PUSH
51781: EMPTY
51782: LIST
51783: LIST
51784: PPUSH
51785: CALL_OW 72
51789: ST_TO_ADDR
// end ;
51790: LD_VAR 0 3
51794: RET
// export function IsDriver ( un ) ; begin
51795: LD_INT 0
51797: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
51798: LD_ADDR_VAR 0 2
51802: PUSH
51803: LD_VAR 0 1
51807: PUSH
51808: LD_INT 55
51810: PUSH
51811: EMPTY
51812: LIST
51813: PPUSH
51814: CALL_OW 69
51818: IN
51819: ST_TO_ADDR
// end ;
51820: LD_VAR 0 2
51824: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
51825: LD_INT 0
51827: PPUSH
51828: PPUSH
// list := [ ] ;
51829: LD_ADDR_VAR 0 5
51833: PUSH
51834: EMPTY
51835: ST_TO_ADDR
// case d of 0 :
51836: LD_VAR 0 3
51840: PUSH
51841: LD_INT 0
51843: DOUBLE
51844: EQUAL
51845: IFTRUE 51849
51847: GO 51982
51849: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
51850: LD_ADDR_VAR 0 5
51854: PUSH
51855: LD_VAR 0 1
51859: PUSH
51860: LD_INT 4
51862: MINUS
51863: PUSH
51864: LD_VAR 0 2
51868: PUSH
51869: LD_INT 4
51871: MINUS
51872: PUSH
51873: LD_INT 2
51875: PUSH
51876: EMPTY
51877: LIST
51878: LIST
51879: LIST
51880: PUSH
51881: LD_VAR 0 1
51885: PUSH
51886: LD_INT 3
51888: MINUS
51889: PUSH
51890: LD_VAR 0 2
51894: PUSH
51895: LD_INT 1
51897: PUSH
51898: EMPTY
51899: LIST
51900: LIST
51901: LIST
51902: PUSH
51903: LD_VAR 0 1
51907: PUSH
51908: LD_INT 4
51910: PLUS
51911: PUSH
51912: LD_VAR 0 2
51916: PUSH
51917: LD_INT 4
51919: PUSH
51920: EMPTY
51921: LIST
51922: LIST
51923: LIST
51924: PUSH
51925: LD_VAR 0 1
51929: PUSH
51930: LD_INT 3
51932: PLUS
51933: PUSH
51934: LD_VAR 0 2
51938: PUSH
51939: LD_INT 3
51941: PLUS
51942: PUSH
51943: LD_INT 5
51945: PUSH
51946: EMPTY
51947: LIST
51948: LIST
51949: LIST
51950: PUSH
51951: LD_VAR 0 1
51955: PUSH
51956: LD_VAR 0 2
51960: PUSH
51961: LD_INT 4
51963: PLUS
51964: PUSH
51965: LD_INT 0
51967: PUSH
51968: EMPTY
51969: LIST
51970: LIST
51971: LIST
51972: PUSH
51973: EMPTY
51974: LIST
51975: LIST
51976: LIST
51977: LIST
51978: LIST
51979: ST_TO_ADDR
// end ; 1 :
51980: GO 52680
51982: LD_INT 1
51984: DOUBLE
51985: EQUAL
51986: IFTRUE 51990
51988: GO 52123
51990: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51991: LD_ADDR_VAR 0 5
51995: PUSH
51996: LD_VAR 0 1
52000: PUSH
52001: LD_VAR 0 2
52005: PUSH
52006: LD_INT 4
52008: MINUS
52009: PUSH
52010: LD_INT 3
52012: PUSH
52013: EMPTY
52014: LIST
52015: LIST
52016: LIST
52017: PUSH
52018: LD_VAR 0 1
52022: PUSH
52023: LD_INT 3
52025: MINUS
52026: PUSH
52027: LD_VAR 0 2
52031: PUSH
52032: LD_INT 3
52034: MINUS
52035: PUSH
52036: LD_INT 2
52038: PUSH
52039: EMPTY
52040: LIST
52041: LIST
52042: LIST
52043: PUSH
52044: LD_VAR 0 1
52048: PUSH
52049: LD_INT 4
52051: MINUS
52052: PUSH
52053: LD_VAR 0 2
52057: PUSH
52058: LD_INT 1
52060: PUSH
52061: EMPTY
52062: LIST
52063: LIST
52064: LIST
52065: PUSH
52066: LD_VAR 0 1
52070: PUSH
52071: LD_VAR 0 2
52075: PUSH
52076: LD_INT 3
52078: PLUS
52079: PUSH
52080: LD_INT 0
52082: PUSH
52083: EMPTY
52084: LIST
52085: LIST
52086: LIST
52087: PUSH
52088: LD_VAR 0 1
52092: PUSH
52093: LD_INT 4
52095: PLUS
52096: PUSH
52097: LD_VAR 0 2
52101: PUSH
52102: LD_INT 4
52104: PLUS
52105: PUSH
52106: LD_INT 5
52108: PUSH
52109: EMPTY
52110: LIST
52111: LIST
52112: LIST
52113: PUSH
52114: EMPTY
52115: LIST
52116: LIST
52117: LIST
52118: LIST
52119: LIST
52120: ST_TO_ADDR
// end ; 2 :
52121: GO 52680
52123: LD_INT 2
52125: DOUBLE
52126: EQUAL
52127: IFTRUE 52131
52129: GO 52260
52131: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
52132: LD_ADDR_VAR 0 5
52136: PUSH
52137: LD_VAR 0 1
52141: PUSH
52142: LD_VAR 0 2
52146: PUSH
52147: LD_INT 3
52149: MINUS
52150: PUSH
52151: LD_INT 3
52153: PUSH
52154: EMPTY
52155: LIST
52156: LIST
52157: LIST
52158: PUSH
52159: LD_VAR 0 1
52163: PUSH
52164: LD_INT 4
52166: PLUS
52167: PUSH
52168: LD_VAR 0 2
52172: PUSH
52173: LD_INT 4
52175: PUSH
52176: EMPTY
52177: LIST
52178: LIST
52179: LIST
52180: PUSH
52181: LD_VAR 0 1
52185: PUSH
52186: LD_VAR 0 2
52190: PUSH
52191: LD_INT 4
52193: PLUS
52194: PUSH
52195: LD_INT 0
52197: PUSH
52198: EMPTY
52199: LIST
52200: LIST
52201: LIST
52202: PUSH
52203: LD_VAR 0 1
52207: PUSH
52208: LD_INT 3
52210: MINUS
52211: PUSH
52212: LD_VAR 0 2
52216: PUSH
52217: LD_INT 1
52219: PUSH
52220: EMPTY
52221: LIST
52222: LIST
52223: LIST
52224: PUSH
52225: LD_VAR 0 1
52229: PUSH
52230: LD_INT 4
52232: MINUS
52233: PUSH
52234: LD_VAR 0 2
52238: PUSH
52239: LD_INT 4
52241: MINUS
52242: PUSH
52243: LD_INT 2
52245: PUSH
52246: EMPTY
52247: LIST
52248: LIST
52249: LIST
52250: PUSH
52251: EMPTY
52252: LIST
52253: LIST
52254: LIST
52255: LIST
52256: LIST
52257: ST_TO_ADDR
// end ; 3 :
52258: GO 52680
52260: LD_INT 3
52262: DOUBLE
52263: EQUAL
52264: IFTRUE 52268
52266: GO 52401
52268: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
52269: LD_ADDR_VAR 0 5
52273: PUSH
52274: LD_VAR 0 1
52278: PUSH
52279: LD_INT 3
52281: PLUS
52282: PUSH
52283: LD_VAR 0 2
52287: PUSH
52288: LD_INT 4
52290: PUSH
52291: EMPTY
52292: LIST
52293: LIST
52294: LIST
52295: PUSH
52296: LD_VAR 0 1
52300: PUSH
52301: LD_INT 4
52303: PLUS
52304: PUSH
52305: LD_VAR 0 2
52309: PUSH
52310: LD_INT 4
52312: PLUS
52313: PUSH
52314: LD_INT 5
52316: PUSH
52317: EMPTY
52318: LIST
52319: LIST
52320: LIST
52321: PUSH
52322: LD_VAR 0 1
52326: PUSH
52327: LD_INT 4
52329: MINUS
52330: PUSH
52331: LD_VAR 0 2
52335: PUSH
52336: LD_INT 1
52338: PUSH
52339: EMPTY
52340: LIST
52341: LIST
52342: LIST
52343: PUSH
52344: LD_VAR 0 1
52348: PUSH
52349: LD_VAR 0 2
52353: PUSH
52354: LD_INT 4
52356: MINUS
52357: PUSH
52358: LD_INT 3
52360: PUSH
52361: EMPTY
52362: LIST
52363: LIST
52364: LIST
52365: PUSH
52366: LD_VAR 0 1
52370: PUSH
52371: LD_INT 3
52373: MINUS
52374: PUSH
52375: LD_VAR 0 2
52379: PUSH
52380: LD_INT 3
52382: MINUS
52383: PUSH
52384: LD_INT 2
52386: PUSH
52387: EMPTY
52388: LIST
52389: LIST
52390: LIST
52391: PUSH
52392: EMPTY
52393: LIST
52394: LIST
52395: LIST
52396: LIST
52397: LIST
52398: ST_TO_ADDR
// end ; 4 :
52399: GO 52680
52401: LD_INT 4
52403: DOUBLE
52404: EQUAL
52405: IFTRUE 52409
52407: GO 52542
52409: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
52410: LD_ADDR_VAR 0 5
52414: PUSH
52415: LD_VAR 0 1
52419: PUSH
52420: LD_VAR 0 2
52424: PUSH
52425: LD_INT 4
52427: PLUS
52428: PUSH
52429: LD_INT 0
52431: PUSH
52432: EMPTY
52433: LIST
52434: LIST
52435: LIST
52436: PUSH
52437: LD_VAR 0 1
52441: PUSH
52442: LD_INT 3
52444: PLUS
52445: PUSH
52446: LD_VAR 0 2
52450: PUSH
52451: LD_INT 3
52453: PLUS
52454: PUSH
52455: LD_INT 5
52457: PUSH
52458: EMPTY
52459: LIST
52460: LIST
52461: LIST
52462: PUSH
52463: LD_VAR 0 1
52467: PUSH
52468: LD_INT 4
52470: PLUS
52471: PUSH
52472: LD_VAR 0 2
52476: PUSH
52477: LD_INT 4
52479: PUSH
52480: EMPTY
52481: LIST
52482: LIST
52483: LIST
52484: PUSH
52485: LD_VAR 0 1
52489: PUSH
52490: LD_VAR 0 2
52494: PUSH
52495: LD_INT 3
52497: MINUS
52498: PUSH
52499: LD_INT 3
52501: PUSH
52502: EMPTY
52503: LIST
52504: LIST
52505: LIST
52506: PUSH
52507: LD_VAR 0 1
52511: PUSH
52512: LD_INT 4
52514: MINUS
52515: PUSH
52516: LD_VAR 0 2
52520: PUSH
52521: LD_INT 4
52523: MINUS
52524: PUSH
52525: LD_INT 2
52527: PUSH
52528: EMPTY
52529: LIST
52530: LIST
52531: LIST
52532: PUSH
52533: EMPTY
52534: LIST
52535: LIST
52536: LIST
52537: LIST
52538: LIST
52539: ST_TO_ADDR
// end ; 5 :
52540: GO 52680
52542: LD_INT 5
52544: DOUBLE
52545: EQUAL
52546: IFTRUE 52550
52548: GO 52679
52550: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
52551: LD_ADDR_VAR 0 5
52555: PUSH
52556: LD_VAR 0 1
52560: PUSH
52561: LD_INT 4
52563: MINUS
52564: PUSH
52565: LD_VAR 0 2
52569: PUSH
52570: LD_INT 1
52572: PUSH
52573: EMPTY
52574: LIST
52575: LIST
52576: LIST
52577: PUSH
52578: LD_VAR 0 1
52582: PUSH
52583: LD_VAR 0 2
52587: PUSH
52588: LD_INT 4
52590: MINUS
52591: PUSH
52592: LD_INT 3
52594: PUSH
52595: EMPTY
52596: LIST
52597: LIST
52598: LIST
52599: PUSH
52600: LD_VAR 0 1
52604: PUSH
52605: LD_INT 4
52607: PLUS
52608: PUSH
52609: LD_VAR 0 2
52613: PUSH
52614: LD_INT 4
52616: PLUS
52617: PUSH
52618: LD_INT 5
52620: PUSH
52621: EMPTY
52622: LIST
52623: LIST
52624: LIST
52625: PUSH
52626: LD_VAR 0 1
52630: PUSH
52631: LD_INT 3
52633: PLUS
52634: PUSH
52635: LD_VAR 0 2
52639: PUSH
52640: LD_INT 4
52642: PUSH
52643: EMPTY
52644: LIST
52645: LIST
52646: LIST
52647: PUSH
52648: LD_VAR 0 1
52652: PUSH
52653: LD_VAR 0 2
52657: PUSH
52658: LD_INT 3
52660: PLUS
52661: PUSH
52662: LD_INT 0
52664: PUSH
52665: EMPTY
52666: LIST
52667: LIST
52668: LIST
52669: PUSH
52670: EMPTY
52671: LIST
52672: LIST
52673: LIST
52674: LIST
52675: LIST
52676: ST_TO_ADDR
// end ; end ;
52677: GO 52680
52679: POP
// result := list ;
52680: LD_ADDR_VAR 0 4
52684: PUSH
52685: LD_VAR 0 5
52689: ST_TO_ADDR
// end ;
52690: LD_VAR 0 4
52694: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
52695: LD_INT 0
52697: PPUSH
52698: PPUSH
52699: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
52700: LD_VAR 0 1
52704: NOT
52705: PUSH
52706: LD_VAR 0 2
52710: PUSH
52711: LD_INT 1
52713: PUSH
52714: LD_INT 2
52716: PUSH
52717: LD_INT 3
52719: PUSH
52720: LD_INT 4
52722: PUSH
52723: EMPTY
52724: LIST
52725: LIST
52726: LIST
52727: LIST
52728: IN
52729: NOT
52730: OR
52731: IFFALSE 52735
// exit ;
52733: GO 52818
// tmp := [ ] ;
52735: LD_ADDR_VAR 0 5
52739: PUSH
52740: EMPTY
52741: ST_TO_ADDR
// for i in units do
52742: LD_ADDR_VAR 0 4
52746: PUSH
52747: LD_VAR 0 1
52751: PUSH
52752: FOR_IN
52753: IFFALSE 52787
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
52755: LD_ADDR_VAR 0 5
52759: PUSH
52760: LD_VAR 0 5
52764: PPUSH
52765: LD_VAR 0 4
52769: PPUSH
52770: LD_VAR 0 2
52774: PPUSH
52775: CALL_OW 259
52779: PPUSH
52780: CALL 54191 0 2
52784: ST_TO_ADDR
52785: GO 52752
52787: POP
52788: POP
// if not tmp then
52789: LD_VAR 0 5
52793: NOT
52794: IFFALSE 52798
// exit ;
52796: GO 52818
// result := SortListByListDesc ( units , tmp ) ;
52798: LD_ADDR_VAR 0 3
52802: PUSH
52803: LD_VAR 0 1
52807: PPUSH
52808: LD_VAR 0 5
52812: PPUSH
52813: CALL_OW 77
52817: ST_TO_ADDR
// end ;
52818: LD_VAR 0 3
52822: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
52823: LD_INT 0
52825: PPUSH
52826: PPUSH
52827: PPUSH
// result := false ;
52828: LD_ADDR_VAR 0 3
52832: PUSH
52833: LD_INT 0
52835: ST_TO_ADDR
// if not building then
52836: LD_VAR 0 2
52840: NOT
52841: IFFALSE 52845
// exit ;
52843: GO 52983
// x := GetX ( building ) ;
52845: LD_ADDR_VAR 0 4
52849: PUSH
52850: LD_VAR 0 2
52854: PPUSH
52855: CALL_OW 250
52859: ST_TO_ADDR
// y := GetY ( building ) ;
52860: LD_ADDR_VAR 0 5
52864: PUSH
52865: LD_VAR 0 2
52869: PPUSH
52870: CALL_OW 251
52874: ST_TO_ADDR
// if not x or not y then
52875: LD_VAR 0 4
52879: NOT
52880: PUSH
52881: LD_VAR 0 5
52885: NOT
52886: OR
52887: IFFALSE 52891
// exit ;
52889: GO 52983
// if GetTaskList ( unit ) then
52891: LD_VAR 0 1
52895: PPUSH
52896: CALL_OW 437
52900: IFFALSE 52983
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52902: LD_STRING e
52904: PUSH
52905: LD_VAR 0 1
52909: PPUSH
52910: CALL_OW 437
52914: PUSH
52915: LD_INT 1
52917: ARRAY
52918: PUSH
52919: LD_INT 1
52921: ARRAY
52922: EQUAL
52923: PUSH
52924: LD_VAR 0 4
52928: PUSH
52929: LD_VAR 0 1
52933: PPUSH
52934: CALL_OW 437
52938: PUSH
52939: LD_INT 1
52941: ARRAY
52942: PUSH
52943: LD_INT 2
52945: ARRAY
52946: EQUAL
52947: AND
52948: PUSH
52949: LD_VAR 0 5
52953: PUSH
52954: LD_VAR 0 1
52958: PPUSH
52959: CALL_OW 437
52963: PUSH
52964: LD_INT 1
52966: ARRAY
52967: PUSH
52968: LD_INT 3
52970: ARRAY
52971: EQUAL
52972: AND
52973: IFFALSE 52983
// result := true end ;
52975: LD_ADDR_VAR 0 3
52979: PUSH
52980: LD_INT 1
52982: ST_TO_ADDR
// end ;
52983: LD_VAR 0 3
52987: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
52988: LD_INT 0
52990: PPUSH
// result := false ;
52991: LD_ADDR_VAR 0 4
52995: PUSH
52996: LD_INT 0
52998: ST_TO_ADDR
// if GetTaskList ( unit ) then
52999: LD_VAR 0 1
53003: PPUSH
53004: CALL_OW 437
53008: IFFALSE 53091
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
53010: LD_STRING M
53012: PUSH
53013: LD_VAR 0 1
53017: PPUSH
53018: CALL_OW 437
53022: PUSH
53023: LD_INT 1
53025: ARRAY
53026: PUSH
53027: LD_INT 1
53029: ARRAY
53030: EQUAL
53031: PUSH
53032: LD_VAR 0 2
53036: PUSH
53037: LD_VAR 0 1
53041: PPUSH
53042: CALL_OW 437
53046: PUSH
53047: LD_INT 1
53049: ARRAY
53050: PUSH
53051: LD_INT 2
53053: ARRAY
53054: EQUAL
53055: AND
53056: PUSH
53057: LD_VAR 0 3
53061: PUSH
53062: LD_VAR 0 1
53066: PPUSH
53067: CALL_OW 437
53071: PUSH
53072: LD_INT 1
53074: ARRAY
53075: PUSH
53076: LD_INT 3
53078: ARRAY
53079: EQUAL
53080: AND
53081: IFFALSE 53091
// result := true ;
53083: LD_ADDR_VAR 0 4
53087: PUSH
53088: LD_INT 1
53090: ST_TO_ADDR
// end ; end ;
53091: LD_VAR 0 4
53095: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
53096: LD_INT 0
53098: PPUSH
53099: PPUSH
53100: PPUSH
53101: PPUSH
// if not unit or not area then
53102: LD_VAR 0 1
53106: NOT
53107: PUSH
53108: LD_VAR 0 2
53112: NOT
53113: OR
53114: IFFALSE 53118
// exit ;
53116: GO 53294
// tmp := AreaToList ( area , i ) ;
53118: LD_ADDR_VAR 0 6
53122: PUSH
53123: LD_VAR 0 2
53127: PPUSH
53128: LD_VAR 0 5
53132: PPUSH
53133: CALL_OW 517
53137: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
53138: LD_ADDR_VAR 0 5
53142: PUSH
53143: DOUBLE
53144: LD_INT 1
53146: DEC
53147: ST_TO_ADDR
53148: LD_VAR 0 6
53152: PUSH
53153: LD_INT 1
53155: ARRAY
53156: PUSH
53157: FOR_TO
53158: IFFALSE 53292
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
53160: LD_ADDR_VAR 0 7
53164: PUSH
53165: LD_VAR 0 6
53169: PUSH
53170: LD_INT 1
53172: ARRAY
53173: PUSH
53174: LD_VAR 0 5
53178: ARRAY
53179: PUSH
53180: LD_VAR 0 6
53184: PUSH
53185: LD_INT 2
53187: ARRAY
53188: PUSH
53189: LD_VAR 0 5
53193: ARRAY
53194: PUSH
53195: EMPTY
53196: LIST
53197: LIST
53198: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
53199: LD_INT 92
53201: PUSH
53202: LD_VAR 0 7
53206: PUSH
53207: LD_INT 1
53209: ARRAY
53210: PUSH
53211: LD_VAR 0 7
53215: PUSH
53216: LD_INT 2
53218: ARRAY
53219: PUSH
53220: LD_INT 2
53222: PUSH
53223: EMPTY
53224: LIST
53225: LIST
53226: LIST
53227: LIST
53228: PPUSH
53229: CALL_OW 69
53233: PUSH
53234: LD_INT 0
53236: EQUAL
53237: IFFALSE 53290
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
53239: LD_VAR 0 1
53243: PPUSH
53244: LD_VAR 0 7
53248: PUSH
53249: LD_INT 1
53251: ARRAY
53252: PPUSH
53253: LD_VAR 0 7
53257: PUSH
53258: LD_INT 2
53260: ARRAY
53261: PPUSH
53262: LD_VAR 0 3
53266: PPUSH
53267: CALL_OW 48
// result := IsPlaced ( unit ) ;
53271: LD_ADDR_VAR 0 4
53275: PUSH
53276: LD_VAR 0 1
53280: PPUSH
53281: CALL_OW 305
53285: ST_TO_ADDR
// exit ;
53286: POP
53287: POP
53288: GO 53294
// end ; end ;
53290: GO 53157
53292: POP
53293: POP
// end ;
53294: LD_VAR 0 4
53298: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
53299: LD_INT 0
53301: PPUSH
53302: PPUSH
53303: PPUSH
// if not side or side > 8 then
53304: LD_VAR 0 1
53308: NOT
53309: PUSH
53310: LD_VAR 0 1
53314: PUSH
53315: LD_INT 8
53317: GREATER
53318: OR
53319: IFFALSE 53323
// exit ;
53321: GO 53510
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
53323: LD_ADDR_VAR 0 4
53327: PUSH
53328: LD_INT 22
53330: PUSH
53331: LD_VAR 0 1
53335: PUSH
53336: EMPTY
53337: LIST
53338: LIST
53339: PUSH
53340: LD_INT 21
53342: PUSH
53343: LD_INT 3
53345: PUSH
53346: EMPTY
53347: LIST
53348: LIST
53349: PUSH
53350: EMPTY
53351: LIST
53352: LIST
53353: PPUSH
53354: CALL_OW 69
53358: ST_TO_ADDR
// if not tmp then
53359: LD_VAR 0 4
53363: NOT
53364: IFFALSE 53368
// exit ;
53366: GO 53510
// enable_addtolog := true ;
53368: LD_ADDR_OWVAR 81
53372: PUSH
53373: LD_INT 1
53375: ST_TO_ADDR
// AddToLog ( [ ) ;
53376: LD_STRING [
53378: PPUSH
53379: CALL_OW 561
// for i in tmp do
53383: LD_ADDR_VAR 0 3
53387: PUSH
53388: LD_VAR 0 4
53392: PUSH
53393: FOR_IN
53394: IFFALSE 53501
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
53396: LD_STRING [
53398: PUSH
53399: LD_VAR 0 3
53403: PPUSH
53404: CALL_OW 266
53408: STR
53409: PUSH
53410: LD_STRING , 
53412: STR
53413: PUSH
53414: LD_VAR 0 3
53418: PPUSH
53419: CALL_OW 250
53423: STR
53424: PUSH
53425: LD_STRING , 
53427: STR
53428: PUSH
53429: LD_VAR 0 3
53433: PPUSH
53434: CALL_OW 251
53438: STR
53439: PUSH
53440: LD_STRING , 
53442: STR
53443: PUSH
53444: LD_VAR 0 3
53448: PPUSH
53449: CALL_OW 254
53453: STR
53454: PUSH
53455: LD_STRING , 
53457: STR
53458: PUSH
53459: LD_VAR 0 3
53463: PPUSH
53464: LD_INT 1
53466: PPUSH
53467: CALL_OW 268
53471: STR
53472: PUSH
53473: LD_STRING , 
53475: STR
53476: PUSH
53477: LD_VAR 0 3
53481: PPUSH
53482: LD_INT 2
53484: PPUSH
53485: CALL_OW 268
53489: STR
53490: PUSH
53491: LD_STRING ],
53493: STR
53494: PPUSH
53495: CALL_OW 561
// end ;
53499: GO 53393
53501: POP
53502: POP
// AddToLog ( ]; ) ;
53503: LD_STRING ];
53505: PPUSH
53506: CALL_OW 561
// end ;
53510: LD_VAR 0 2
53514: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
53515: LD_INT 0
53517: PPUSH
53518: PPUSH
53519: PPUSH
53520: PPUSH
53521: PPUSH
// if not area or not rate or not max then
53522: LD_VAR 0 1
53526: NOT
53527: PUSH
53528: LD_VAR 0 2
53532: NOT
53533: OR
53534: PUSH
53535: LD_VAR 0 4
53539: NOT
53540: OR
53541: IFFALSE 53545
// exit ;
53543: GO 53734
// while 1 do
53545: LD_INT 1
53547: IFFALSE 53734
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
53549: LD_ADDR_VAR 0 9
53553: PUSH
53554: LD_VAR 0 1
53558: PPUSH
53559: LD_INT 1
53561: PPUSH
53562: CALL_OW 287
53566: PUSH
53567: LD_INT 10
53569: MUL
53570: ST_TO_ADDR
// r := rate / 10 ;
53571: LD_ADDR_VAR 0 7
53575: PUSH
53576: LD_VAR 0 2
53580: PUSH
53581: LD_INT 10
53583: DIVREAL
53584: ST_TO_ADDR
// time := 1 1$00 ;
53585: LD_ADDR_VAR 0 8
53589: PUSH
53590: LD_INT 2100
53592: ST_TO_ADDR
// if amount < min then
53593: LD_VAR 0 9
53597: PUSH
53598: LD_VAR 0 3
53602: LESS
53603: IFFALSE 53621
// r := r * 2 else
53605: LD_ADDR_VAR 0 7
53609: PUSH
53610: LD_VAR 0 7
53614: PUSH
53615: LD_INT 2
53617: MUL
53618: ST_TO_ADDR
53619: GO 53647
// if amount > max then
53621: LD_VAR 0 9
53625: PUSH
53626: LD_VAR 0 4
53630: GREATER
53631: IFFALSE 53647
// r := r / 2 ;
53633: LD_ADDR_VAR 0 7
53637: PUSH
53638: LD_VAR 0 7
53642: PUSH
53643: LD_INT 2
53645: DIVREAL
53646: ST_TO_ADDR
// time := time / r ;
53647: LD_ADDR_VAR 0 8
53651: PUSH
53652: LD_VAR 0 8
53656: PUSH
53657: LD_VAR 0 7
53661: DIVREAL
53662: ST_TO_ADDR
// if time < 0 then
53663: LD_VAR 0 8
53667: PUSH
53668: LD_INT 0
53670: LESS
53671: IFFALSE 53688
// time := time * - 1 ;
53673: LD_ADDR_VAR 0 8
53677: PUSH
53678: LD_VAR 0 8
53682: PUSH
53683: LD_INT 1
53685: NEG
53686: MUL
53687: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
53688: LD_VAR 0 8
53692: PUSH
53693: LD_INT 35
53695: PPUSH
53696: LD_INT 875
53698: PPUSH
53699: CALL_OW 12
53703: PLUS
53704: PPUSH
53705: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
53709: LD_INT 1
53711: PPUSH
53712: LD_INT 5
53714: PPUSH
53715: CALL_OW 12
53719: PPUSH
53720: LD_VAR 0 1
53724: PPUSH
53725: LD_INT 1
53727: PPUSH
53728: CALL_OW 55
// end ;
53732: GO 53545
// end ;
53734: LD_VAR 0 5
53738: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
53739: LD_INT 0
53741: PPUSH
53742: PPUSH
53743: PPUSH
53744: PPUSH
53745: PPUSH
53746: PPUSH
53747: PPUSH
53748: PPUSH
// if not turrets or not factories then
53749: LD_VAR 0 1
53753: NOT
53754: PUSH
53755: LD_VAR 0 2
53759: NOT
53760: OR
53761: IFFALSE 53765
// exit ;
53763: GO 54072
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
53765: LD_ADDR_VAR 0 10
53769: PUSH
53770: LD_INT 5
53772: PUSH
53773: LD_INT 6
53775: PUSH
53776: EMPTY
53777: LIST
53778: LIST
53779: PUSH
53780: LD_INT 2
53782: PUSH
53783: LD_INT 4
53785: PUSH
53786: EMPTY
53787: LIST
53788: LIST
53789: PUSH
53790: LD_INT 3
53792: PUSH
53793: LD_INT 5
53795: PUSH
53796: EMPTY
53797: LIST
53798: LIST
53799: PUSH
53800: EMPTY
53801: LIST
53802: LIST
53803: LIST
53804: PUSH
53805: LD_INT 24
53807: PUSH
53808: LD_INT 25
53810: PUSH
53811: EMPTY
53812: LIST
53813: LIST
53814: PUSH
53815: LD_INT 23
53817: PUSH
53818: LD_INT 27
53820: PUSH
53821: EMPTY
53822: LIST
53823: LIST
53824: PUSH
53825: EMPTY
53826: LIST
53827: LIST
53828: PUSH
53829: LD_INT 42
53831: PUSH
53832: LD_INT 43
53834: PUSH
53835: EMPTY
53836: LIST
53837: LIST
53838: PUSH
53839: LD_INT 44
53841: PUSH
53842: LD_INT 46
53844: PUSH
53845: EMPTY
53846: LIST
53847: LIST
53848: PUSH
53849: LD_INT 45
53851: PUSH
53852: LD_INT 47
53854: PUSH
53855: EMPTY
53856: LIST
53857: LIST
53858: PUSH
53859: EMPTY
53860: LIST
53861: LIST
53862: LIST
53863: PUSH
53864: EMPTY
53865: LIST
53866: LIST
53867: LIST
53868: ST_TO_ADDR
// result := [ ] ;
53869: LD_ADDR_VAR 0 3
53873: PUSH
53874: EMPTY
53875: ST_TO_ADDR
// for i in turrets do
53876: LD_ADDR_VAR 0 4
53880: PUSH
53881: LD_VAR 0 1
53885: PUSH
53886: FOR_IN
53887: IFFALSE 54070
// begin nat := GetNation ( i ) ;
53889: LD_ADDR_VAR 0 7
53893: PUSH
53894: LD_VAR 0 4
53898: PPUSH
53899: CALL_OW 248
53903: ST_TO_ADDR
// weapon := 0 ;
53904: LD_ADDR_VAR 0 8
53908: PUSH
53909: LD_INT 0
53911: ST_TO_ADDR
// if not nat then
53912: LD_VAR 0 7
53916: NOT
53917: IFFALSE 53921
// continue ;
53919: GO 53886
// for j in list [ nat ] do
53921: LD_ADDR_VAR 0 5
53925: PUSH
53926: LD_VAR 0 10
53930: PUSH
53931: LD_VAR 0 7
53935: ARRAY
53936: PUSH
53937: FOR_IN
53938: IFFALSE 53979
// if GetBWeapon ( i ) = j [ 1 ] then
53940: LD_VAR 0 4
53944: PPUSH
53945: CALL_OW 269
53949: PUSH
53950: LD_VAR 0 5
53954: PUSH
53955: LD_INT 1
53957: ARRAY
53958: EQUAL
53959: IFFALSE 53977
// begin weapon := j [ 2 ] ;
53961: LD_ADDR_VAR 0 8
53965: PUSH
53966: LD_VAR 0 5
53970: PUSH
53971: LD_INT 2
53973: ARRAY
53974: ST_TO_ADDR
// break ;
53975: GO 53979
// end ;
53977: GO 53937
53979: POP
53980: POP
// if not weapon then
53981: LD_VAR 0 8
53985: NOT
53986: IFFALSE 53990
// continue ;
53988: GO 53886
// for k in factories do
53990: LD_ADDR_VAR 0 6
53994: PUSH
53995: LD_VAR 0 2
53999: PUSH
54000: FOR_IN
54001: IFFALSE 54066
// begin weapons := AvailableWeaponList ( k ) ;
54003: LD_ADDR_VAR 0 9
54007: PUSH
54008: LD_VAR 0 6
54012: PPUSH
54013: CALL_OW 478
54017: ST_TO_ADDR
// if not weapons then
54018: LD_VAR 0 9
54022: NOT
54023: IFFALSE 54027
// continue ;
54025: GO 54000
// if weapon in weapons then
54027: LD_VAR 0 8
54031: PUSH
54032: LD_VAR 0 9
54036: IN
54037: IFFALSE 54064
// begin result := [ i , weapon ] ;
54039: LD_ADDR_VAR 0 3
54043: PUSH
54044: LD_VAR 0 4
54048: PUSH
54049: LD_VAR 0 8
54053: PUSH
54054: EMPTY
54055: LIST
54056: LIST
54057: ST_TO_ADDR
// exit ;
54058: POP
54059: POP
54060: POP
54061: POP
54062: GO 54072
// end ; end ;
54064: GO 54000
54066: POP
54067: POP
// end ;
54068: GO 53886
54070: POP
54071: POP
// end ;
54072: LD_VAR 0 3
54076: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
54077: LD_INT 0
54079: PPUSH
// if not side or side > 8 then
54080: LD_VAR 0 3
54084: NOT
54085: PUSH
54086: LD_VAR 0 3
54090: PUSH
54091: LD_INT 8
54093: GREATER
54094: OR
54095: IFFALSE 54099
// exit ;
54097: GO 54158
// if not range then
54099: LD_VAR 0 4
54103: NOT
54104: IFFALSE 54115
// range := - 12 ;
54106: LD_ADDR_VAR 0 4
54110: PUSH
54111: LD_INT 12
54113: NEG
54114: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
54115: LD_VAR 0 1
54119: PPUSH
54120: LD_VAR 0 2
54124: PPUSH
54125: LD_VAR 0 3
54129: PPUSH
54130: LD_VAR 0 4
54134: PPUSH
54135: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
54139: LD_VAR 0 1
54143: PPUSH
54144: LD_VAR 0 2
54148: PPUSH
54149: LD_VAR 0 3
54153: PPUSH
54154: CALL_OW 331
// end ;
54158: LD_VAR 0 5
54162: RET
// export function Video ( mode ) ; begin
54163: LD_INT 0
54165: PPUSH
// ingame_video = mode ;
54166: LD_ADDR_OWVAR 52
54170: PUSH
54171: LD_VAR 0 1
54175: ST_TO_ADDR
// interface_hidden = mode ;
54176: LD_ADDR_OWVAR 54
54180: PUSH
54181: LD_VAR 0 1
54185: ST_TO_ADDR
// end ;
54186: LD_VAR 0 2
54190: RET
// export function Join ( array , element ) ; begin
54191: LD_INT 0
54193: PPUSH
// result := Replace ( array , array + 1 , element ) ;
54194: LD_ADDR_VAR 0 3
54198: PUSH
54199: LD_VAR 0 1
54203: PPUSH
54204: LD_VAR 0 1
54208: PUSH
54209: LD_INT 1
54211: PLUS
54212: PPUSH
54213: LD_VAR 0 2
54217: PPUSH
54218: CALL_OW 1
54222: ST_TO_ADDR
// end ;
54223: LD_VAR 0 3
54227: RET
// export function JoinUnion ( array , element ) ; begin
54228: LD_INT 0
54230: PPUSH
// result := array union element ;
54231: LD_ADDR_VAR 0 3
54235: PUSH
54236: LD_VAR 0 1
54240: PUSH
54241: LD_VAR 0 2
54245: UNION
54246: ST_TO_ADDR
// end ;
54247: LD_VAR 0 3
54251: RET
// export function GetBehemoths ( side ) ; begin
54252: LD_INT 0
54254: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
54255: LD_ADDR_VAR 0 2
54259: PUSH
54260: LD_INT 22
54262: PUSH
54263: LD_VAR 0 1
54267: PUSH
54268: EMPTY
54269: LIST
54270: LIST
54271: PUSH
54272: LD_INT 31
54274: PUSH
54275: LD_INT 25
54277: PUSH
54278: EMPTY
54279: LIST
54280: LIST
54281: PUSH
54282: EMPTY
54283: LIST
54284: LIST
54285: PPUSH
54286: CALL_OW 69
54290: ST_TO_ADDR
// end ;
54291: LD_VAR 0 2
54295: RET
// export function Shuffle ( array ) ; var i , index ; begin
54296: LD_INT 0
54298: PPUSH
54299: PPUSH
54300: PPUSH
// result := [ ] ;
54301: LD_ADDR_VAR 0 2
54305: PUSH
54306: EMPTY
54307: ST_TO_ADDR
// if not array then
54308: LD_VAR 0 1
54312: NOT
54313: IFFALSE 54317
// exit ;
54315: GO 54416
// Randomize ;
54317: CALL_OW 10
// for i = array downto 1 do
54321: LD_ADDR_VAR 0 3
54325: PUSH
54326: DOUBLE
54327: LD_VAR 0 1
54331: INC
54332: ST_TO_ADDR
54333: LD_INT 1
54335: PUSH
54336: FOR_DOWNTO
54337: IFFALSE 54414
// begin index := rand ( 1 , array ) ;
54339: LD_ADDR_VAR 0 4
54343: PUSH
54344: LD_INT 1
54346: PPUSH
54347: LD_VAR 0 1
54351: PPUSH
54352: CALL_OW 12
54356: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
54357: LD_ADDR_VAR 0 2
54361: PUSH
54362: LD_VAR 0 2
54366: PPUSH
54367: LD_VAR 0 2
54371: PUSH
54372: LD_INT 1
54374: PLUS
54375: PPUSH
54376: LD_VAR 0 1
54380: PUSH
54381: LD_VAR 0 4
54385: ARRAY
54386: PPUSH
54387: CALL_OW 2
54391: ST_TO_ADDR
// array := Delete ( array , index ) ;
54392: LD_ADDR_VAR 0 1
54396: PUSH
54397: LD_VAR 0 1
54401: PPUSH
54402: LD_VAR 0 4
54406: PPUSH
54407: CALL_OW 3
54411: ST_TO_ADDR
// end ;
54412: GO 54336
54414: POP
54415: POP
// end ;
54416: LD_VAR 0 2
54420: RET
// export function GetBaseMaterials ( base ) ; begin
54421: LD_INT 0
54423: PPUSH
// result := [ 0 , 0 , 0 ] ;
54424: LD_ADDR_VAR 0 2
54428: PUSH
54429: LD_INT 0
54431: PUSH
54432: LD_INT 0
54434: PUSH
54435: LD_INT 0
54437: PUSH
54438: EMPTY
54439: LIST
54440: LIST
54441: LIST
54442: ST_TO_ADDR
// if not base then
54443: LD_VAR 0 1
54447: NOT
54448: IFFALSE 54452
// exit ;
54450: GO 54501
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
54452: LD_ADDR_VAR 0 2
54456: PUSH
54457: LD_VAR 0 1
54461: PPUSH
54462: LD_INT 1
54464: PPUSH
54465: CALL_OW 275
54469: PUSH
54470: LD_VAR 0 1
54474: PPUSH
54475: LD_INT 2
54477: PPUSH
54478: CALL_OW 275
54482: PUSH
54483: LD_VAR 0 1
54487: PPUSH
54488: LD_INT 3
54490: PPUSH
54491: CALL_OW 275
54495: PUSH
54496: EMPTY
54497: LIST
54498: LIST
54499: LIST
54500: ST_TO_ADDR
// end ;
54501: LD_VAR 0 2
54505: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
54506: LD_INT 0
54508: PPUSH
54509: PPUSH
// result := array ;
54510: LD_ADDR_VAR 0 3
54514: PUSH
54515: LD_VAR 0 1
54519: ST_TO_ADDR
// if size >= result then
54520: LD_VAR 0 2
54524: PUSH
54525: LD_VAR 0 3
54529: GREATEREQUAL
54530: IFFALSE 54534
// exit ;
54532: GO 54584
// if size then
54534: LD_VAR 0 2
54538: IFFALSE 54584
// for i := array downto size do
54540: LD_ADDR_VAR 0 4
54544: PUSH
54545: DOUBLE
54546: LD_VAR 0 1
54550: INC
54551: ST_TO_ADDR
54552: LD_VAR 0 2
54556: PUSH
54557: FOR_DOWNTO
54558: IFFALSE 54582
// result := Delete ( result , result ) ;
54560: LD_ADDR_VAR 0 3
54564: PUSH
54565: LD_VAR 0 3
54569: PPUSH
54570: LD_VAR 0 3
54574: PPUSH
54575: CALL_OW 3
54579: ST_TO_ADDR
54580: GO 54557
54582: POP
54583: POP
// end ;
54584: LD_VAR 0 3
54588: RET
// export function ComExit ( unit ) ; var tmp ; begin
54589: LD_INT 0
54591: PPUSH
54592: PPUSH
// if not IsInUnit ( unit ) then
54593: LD_VAR 0 1
54597: PPUSH
54598: CALL_OW 310
54602: NOT
54603: IFFALSE 54607
// exit ;
54605: GO 54667
// tmp := IsInUnit ( unit ) ;
54607: LD_ADDR_VAR 0 3
54611: PUSH
54612: LD_VAR 0 1
54616: PPUSH
54617: CALL_OW 310
54621: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
54622: LD_VAR 0 3
54626: PPUSH
54627: CALL_OW 247
54631: PUSH
54632: LD_INT 2
54634: EQUAL
54635: IFFALSE 54648
// ComExitVehicle ( unit ) else
54637: LD_VAR 0 1
54641: PPUSH
54642: CALL_OW 121
54646: GO 54657
// ComExitBuilding ( unit ) ;
54648: LD_VAR 0 1
54652: PPUSH
54653: CALL_OW 122
// result := tmp ;
54657: LD_ADDR_VAR 0 2
54661: PUSH
54662: LD_VAR 0 3
54666: ST_TO_ADDR
// end ;
54667: LD_VAR 0 2
54671: RET
// export function ComExitAll ( units ) ; var i ; begin
54672: LD_INT 0
54674: PPUSH
54675: PPUSH
// if not units then
54676: LD_VAR 0 1
54680: NOT
54681: IFFALSE 54685
// exit ;
54683: GO 54711
// for i in units do
54685: LD_ADDR_VAR 0 3
54689: PUSH
54690: LD_VAR 0 1
54694: PUSH
54695: FOR_IN
54696: IFFALSE 54709
// ComExit ( i ) ;
54698: LD_VAR 0 3
54702: PPUSH
54703: CALL 54589 0 1
54707: GO 54695
54709: POP
54710: POP
// end ;
54711: LD_VAR 0 2
54715: RET
// export function ResetHc ; begin
54716: LD_INT 0
54718: PPUSH
// InitHc ;
54719: CALL_OW 19
// hc_importance := 0 ;
54723: LD_ADDR_OWVAR 32
54727: PUSH
54728: LD_INT 0
54730: ST_TO_ADDR
// end ;
54731: LD_VAR 0 1
54735: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
54736: LD_INT 0
54738: PPUSH
54739: PPUSH
54740: PPUSH
// _x := ( x1 + x2 ) div 2 ;
54741: LD_ADDR_VAR 0 6
54745: PUSH
54746: LD_VAR 0 1
54750: PUSH
54751: LD_VAR 0 3
54755: PLUS
54756: PUSH
54757: LD_INT 2
54759: DIV
54760: ST_TO_ADDR
// if _x < 0 then
54761: LD_VAR 0 6
54765: PUSH
54766: LD_INT 0
54768: LESS
54769: IFFALSE 54786
// _x := _x * - 1 ;
54771: LD_ADDR_VAR 0 6
54775: PUSH
54776: LD_VAR 0 6
54780: PUSH
54781: LD_INT 1
54783: NEG
54784: MUL
54785: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
54786: LD_ADDR_VAR 0 7
54790: PUSH
54791: LD_VAR 0 2
54795: PUSH
54796: LD_VAR 0 4
54800: PLUS
54801: PUSH
54802: LD_INT 2
54804: DIV
54805: ST_TO_ADDR
// if _y < 0 then
54806: LD_VAR 0 7
54810: PUSH
54811: LD_INT 0
54813: LESS
54814: IFFALSE 54831
// _y := _y * - 1 ;
54816: LD_ADDR_VAR 0 7
54820: PUSH
54821: LD_VAR 0 7
54825: PUSH
54826: LD_INT 1
54828: NEG
54829: MUL
54830: ST_TO_ADDR
// result := [ _x , _y ] ;
54831: LD_ADDR_VAR 0 5
54835: PUSH
54836: LD_VAR 0 6
54840: PUSH
54841: LD_VAR 0 7
54845: PUSH
54846: EMPTY
54847: LIST
54848: LIST
54849: ST_TO_ADDR
// end ;
54850: LD_VAR 0 5
54854: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
54855: LD_INT 0
54857: PPUSH
54858: PPUSH
54859: PPUSH
54860: PPUSH
// task := GetTaskList ( unit ) ;
54861: LD_ADDR_VAR 0 7
54865: PUSH
54866: LD_VAR 0 1
54870: PPUSH
54871: CALL_OW 437
54875: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
54876: LD_VAR 0 7
54880: NOT
54881: PUSH
54882: LD_VAR 0 1
54886: PPUSH
54887: LD_VAR 0 2
54891: PPUSH
54892: CALL_OW 308
54896: NOT
54897: AND
54898: IFFALSE 54902
// exit ;
54900: GO 55020
// if IsInArea ( unit , area ) then
54902: LD_VAR 0 1
54906: PPUSH
54907: LD_VAR 0 2
54911: PPUSH
54912: CALL_OW 308
54916: IFFALSE 54934
// begin ComMoveToArea ( unit , goAway ) ;
54918: LD_VAR 0 1
54922: PPUSH
54923: LD_VAR 0 3
54927: PPUSH
54928: CALL_OW 113
// exit ;
54932: GO 55020
// end ; if task [ 1 ] [ 1 ] <> M then
54934: LD_VAR 0 7
54938: PUSH
54939: LD_INT 1
54941: ARRAY
54942: PUSH
54943: LD_INT 1
54945: ARRAY
54946: PUSH
54947: LD_STRING M
54949: NONEQUAL
54950: IFFALSE 54954
// exit ;
54952: GO 55020
// x := task [ 1 ] [ 2 ] ;
54954: LD_ADDR_VAR 0 5
54958: PUSH
54959: LD_VAR 0 7
54963: PUSH
54964: LD_INT 1
54966: ARRAY
54967: PUSH
54968: LD_INT 2
54970: ARRAY
54971: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
54972: LD_ADDR_VAR 0 6
54976: PUSH
54977: LD_VAR 0 7
54981: PUSH
54982: LD_INT 1
54984: ARRAY
54985: PUSH
54986: LD_INT 3
54988: ARRAY
54989: ST_TO_ADDR
// if InArea ( x , y , area ) then
54990: LD_VAR 0 5
54994: PPUSH
54995: LD_VAR 0 6
54999: PPUSH
55000: LD_VAR 0 2
55004: PPUSH
55005: CALL_OW 309
55009: IFFALSE 55020
// ComStop ( unit ) ;
55011: LD_VAR 0 1
55015: PPUSH
55016: CALL_OW 141
// end ;
55020: LD_VAR 0 4
55024: RET
// export function Abs ( value ) ; begin
55025: LD_INT 0
55027: PPUSH
// result := value ;
55028: LD_ADDR_VAR 0 2
55032: PUSH
55033: LD_VAR 0 1
55037: ST_TO_ADDR
// if value < 0 then
55038: LD_VAR 0 1
55042: PUSH
55043: LD_INT 0
55045: LESS
55046: IFFALSE 55063
// result := value * - 1 ;
55048: LD_ADDR_VAR 0 2
55052: PUSH
55053: LD_VAR 0 1
55057: PUSH
55058: LD_INT 1
55060: NEG
55061: MUL
55062: ST_TO_ADDR
// end ;
55063: LD_VAR 0 2
55067: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
55068: LD_INT 0
55070: PPUSH
55071: PPUSH
55072: PPUSH
55073: PPUSH
55074: PPUSH
55075: PPUSH
55076: PPUSH
55077: PPUSH
// if not unit or not building then
55078: LD_VAR 0 1
55082: NOT
55083: PUSH
55084: LD_VAR 0 2
55088: NOT
55089: OR
55090: IFFALSE 55094
// exit ;
55092: GO 55320
// x := GetX ( building ) ;
55094: LD_ADDR_VAR 0 4
55098: PUSH
55099: LD_VAR 0 2
55103: PPUSH
55104: CALL_OW 250
55108: ST_TO_ADDR
// y := GetY ( building ) ;
55109: LD_ADDR_VAR 0 6
55113: PUSH
55114: LD_VAR 0 2
55118: PPUSH
55119: CALL_OW 251
55123: ST_TO_ADDR
// d := GetDir ( building ) ;
55124: LD_ADDR_VAR 0 8
55128: PUSH
55129: LD_VAR 0 2
55133: PPUSH
55134: CALL_OW 254
55138: ST_TO_ADDR
// r := 4 ;
55139: LD_ADDR_VAR 0 9
55143: PUSH
55144: LD_INT 4
55146: ST_TO_ADDR
// for i := 1 to 5 do
55147: LD_ADDR_VAR 0 10
55151: PUSH
55152: DOUBLE
55153: LD_INT 1
55155: DEC
55156: ST_TO_ADDR
55157: LD_INT 5
55159: PUSH
55160: FOR_TO
55161: IFFALSE 55318
// begin _x := ShiftX ( x , d , r + i ) ;
55163: LD_ADDR_VAR 0 5
55167: PUSH
55168: LD_VAR 0 4
55172: PPUSH
55173: LD_VAR 0 8
55177: PPUSH
55178: LD_VAR 0 9
55182: PUSH
55183: LD_VAR 0 10
55187: PLUS
55188: PPUSH
55189: CALL_OW 272
55193: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
55194: LD_ADDR_VAR 0 7
55198: PUSH
55199: LD_VAR 0 6
55203: PPUSH
55204: LD_VAR 0 8
55208: PPUSH
55209: LD_VAR 0 9
55213: PUSH
55214: LD_VAR 0 10
55218: PLUS
55219: PPUSH
55220: CALL_OW 273
55224: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
55225: LD_VAR 0 5
55229: PPUSH
55230: LD_VAR 0 7
55234: PPUSH
55235: CALL_OW 488
55239: PUSH
55240: LD_VAR 0 5
55244: PPUSH
55245: LD_VAR 0 7
55249: PPUSH
55250: CALL_OW 428
55254: PPUSH
55255: CALL_OW 247
55259: PUSH
55260: LD_INT 3
55262: PUSH
55263: LD_INT 2
55265: PUSH
55266: EMPTY
55267: LIST
55268: LIST
55269: IN
55270: NOT
55271: AND
55272: IFFALSE 55316
// begin ComMoveXY ( unit , _x , _y ) ;
55274: LD_VAR 0 1
55278: PPUSH
55279: LD_VAR 0 5
55283: PPUSH
55284: LD_VAR 0 7
55288: PPUSH
55289: CALL_OW 111
// result := [ _x , _y ] ;
55293: LD_ADDR_VAR 0 3
55297: PUSH
55298: LD_VAR 0 5
55302: PUSH
55303: LD_VAR 0 7
55307: PUSH
55308: EMPTY
55309: LIST
55310: LIST
55311: ST_TO_ADDR
// exit ;
55312: POP
55313: POP
55314: GO 55320
// end ; end ;
55316: GO 55160
55318: POP
55319: POP
// end ;
55320: LD_VAR 0 3
55324: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
55325: LD_INT 0
55327: PPUSH
55328: PPUSH
55329: PPUSH
// result := 0 ;
55330: LD_ADDR_VAR 0 3
55334: PUSH
55335: LD_INT 0
55337: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
55338: LD_VAR 0 1
55342: PUSH
55343: LD_INT 0
55345: LESS
55346: PUSH
55347: LD_VAR 0 1
55351: PUSH
55352: LD_INT 8
55354: GREATER
55355: OR
55356: PUSH
55357: LD_VAR 0 2
55361: PUSH
55362: LD_INT 0
55364: LESS
55365: OR
55366: PUSH
55367: LD_VAR 0 2
55371: PUSH
55372: LD_INT 8
55374: GREATER
55375: OR
55376: IFFALSE 55380
// exit ;
55378: GO 55455
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
55380: LD_ADDR_VAR 0 4
55384: PUSH
55385: LD_INT 22
55387: PUSH
55388: LD_VAR 0 2
55392: PUSH
55393: EMPTY
55394: LIST
55395: LIST
55396: PPUSH
55397: CALL_OW 69
55401: PUSH
55402: FOR_IN
55403: IFFALSE 55453
// begin un := UnitShoot ( i ) ;
55405: LD_ADDR_VAR 0 5
55409: PUSH
55410: LD_VAR 0 4
55414: PPUSH
55415: CALL_OW 504
55419: ST_TO_ADDR
// if GetSide ( un ) = side1 then
55420: LD_VAR 0 5
55424: PPUSH
55425: CALL_OW 255
55429: PUSH
55430: LD_VAR 0 1
55434: EQUAL
55435: IFFALSE 55451
// begin result := un ;
55437: LD_ADDR_VAR 0 3
55441: PUSH
55442: LD_VAR 0 5
55446: ST_TO_ADDR
// exit ;
55447: POP
55448: POP
55449: GO 55455
// end ; end ;
55451: GO 55402
55453: POP
55454: POP
// end ;
55455: LD_VAR 0 3
55459: RET
// export function GetCargoBay ( units ) ; begin
55460: LD_INT 0
55462: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
55463: LD_ADDR_VAR 0 2
55467: PUSH
55468: LD_VAR 0 1
55472: PPUSH
55473: LD_INT 2
55475: PUSH
55476: LD_INT 34
55478: PUSH
55479: LD_INT 12
55481: PUSH
55482: EMPTY
55483: LIST
55484: LIST
55485: PUSH
55486: LD_INT 34
55488: PUSH
55489: LD_INT 51
55491: PUSH
55492: EMPTY
55493: LIST
55494: LIST
55495: PUSH
55496: LD_INT 34
55498: PUSH
55499: LD_INT 32
55501: PUSH
55502: EMPTY
55503: LIST
55504: LIST
55505: PUSH
55506: LD_INT 34
55508: PUSH
55509: LD_INT 89
55511: PUSH
55512: EMPTY
55513: LIST
55514: LIST
55515: PUSH
55516: EMPTY
55517: LIST
55518: LIST
55519: LIST
55520: LIST
55521: LIST
55522: PPUSH
55523: CALL_OW 72
55527: ST_TO_ADDR
// end ;
55528: LD_VAR 0 2
55532: RET
// export function Negate ( value ) ; begin
55533: LD_INT 0
55535: PPUSH
// result := not value ;
55536: LD_ADDR_VAR 0 2
55540: PUSH
55541: LD_VAR 0 1
55545: NOT
55546: ST_TO_ADDR
// end ;
55547: LD_VAR 0 2
55551: RET
// export function Inc ( value ) ; begin
55552: LD_INT 0
55554: PPUSH
// result := value + 1 ;
55555: LD_ADDR_VAR 0 2
55559: PUSH
55560: LD_VAR 0 1
55564: PUSH
55565: LD_INT 1
55567: PLUS
55568: ST_TO_ADDR
// end ;
55569: LD_VAR 0 2
55573: RET
// export function Dec ( value ) ; begin
55574: LD_INT 0
55576: PPUSH
// result := value - 1 ;
55577: LD_ADDR_VAR 0 2
55581: PUSH
55582: LD_VAR 0 1
55586: PUSH
55587: LD_INT 1
55589: MINUS
55590: ST_TO_ADDR
// end ;
55591: LD_VAR 0 2
55595: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
55596: LD_INT 0
55598: PPUSH
55599: PPUSH
55600: PPUSH
55601: PPUSH
55602: PPUSH
55603: PPUSH
55604: PPUSH
55605: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
55606: LD_VAR 0 1
55610: PPUSH
55611: LD_VAR 0 2
55615: PPUSH
55616: CALL_OW 488
55620: NOT
55621: PUSH
55622: LD_VAR 0 3
55626: PPUSH
55627: LD_VAR 0 4
55631: PPUSH
55632: CALL_OW 488
55636: NOT
55637: OR
55638: IFFALSE 55651
// begin result := - 1 ;
55640: LD_ADDR_VAR 0 5
55644: PUSH
55645: LD_INT 1
55647: NEG
55648: ST_TO_ADDR
// exit ;
55649: GO 55886
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
55651: LD_ADDR_VAR 0 12
55655: PUSH
55656: LD_VAR 0 1
55660: PPUSH
55661: LD_VAR 0 2
55665: PPUSH
55666: LD_VAR 0 3
55670: PPUSH
55671: LD_VAR 0 4
55675: PPUSH
55676: CALL 54736 0 4
55680: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
55681: LD_ADDR_VAR 0 11
55685: PUSH
55686: LD_VAR 0 1
55690: PPUSH
55691: LD_VAR 0 2
55695: PPUSH
55696: LD_VAR 0 12
55700: PUSH
55701: LD_INT 1
55703: ARRAY
55704: PPUSH
55705: LD_VAR 0 12
55709: PUSH
55710: LD_INT 2
55712: ARRAY
55713: PPUSH
55714: CALL_OW 298
55718: ST_TO_ADDR
// distance := 9999 ;
55719: LD_ADDR_VAR 0 10
55723: PUSH
55724: LD_INT 9999
55726: ST_TO_ADDR
// for i := 0 to 5 do
55727: LD_ADDR_VAR 0 6
55731: PUSH
55732: DOUBLE
55733: LD_INT 0
55735: DEC
55736: ST_TO_ADDR
55737: LD_INT 5
55739: PUSH
55740: FOR_TO
55741: IFFALSE 55884
// begin _x := ShiftX ( x1 , i , centerDist ) ;
55743: LD_ADDR_VAR 0 7
55747: PUSH
55748: LD_VAR 0 1
55752: PPUSH
55753: LD_VAR 0 6
55757: PPUSH
55758: LD_VAR 0 11
55762: PPUSH
55763: CALL_OW 272
55767: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
55768: LD_ADDR_VAR 0 8
55772: PUSH
55773: LD_VAR 0 2
55777: PPUSH
55778: LD_VAR 0 6
55782: PPUSH
55783: LD_VAR 0 11
55787: PPUSH
55788: CALL_OW 273
55792: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55793: LD_VAR 0 7
55797: PPUSH
55798: LD_VAR 0 8
55802: PPUSH
55803: CALL_OW 488
55807: NOT
55808: IFFALSE 55812
// continue ;
55810: GO 55740
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
55812: LD_ADDR_VAR 0 9
55816: PUSH
55817: LD_VAR 0 12
55821: PUSH
55822: LD_INT 1
55824: ARRAY
55825: PPUSH
55826: LD_VAR 0 12
55830: PUSH
55831: LD_INT 2
55833: ARRAY
55834: PPUSH
55835: LD_VAR 0 7
55839: PPUSH
55840: LD_VAR 0 8
55844: PPUSH
55845: CALL_OW 298
55849: ST_TO_ADDR
// if tmp < distance then
55850: LD_VAR 0 9
55854: PUSH
55855: LD_VAR 0 10
55859: LESS
55860: IFFALSE 55882
// begin result := i ;
55862: LD_ADDR_VAR 0 5
55866: PUSH
55867: LD_VAR 0 6
55871: ST_TO_ADDR
// distance := tmp ;
55872: LD_ADDR_VAR 0 10
55876: PUSH
55877: LD_VAR 0 9
55881: ST_TO_ADDR
// end ; end ;
55882: GO 55740
55884: POP
55885: POP
// end ;
55886: LD_VAR 0 5
55890: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
55891: LD_INT 0
55893: PPUSH
55894: PPUSH
// if not driver or not IsInUnit ( driver ) then
55895: LD_VAR 0 1
55899: NOT
55900: PUSH
55901: LD_VAR 0 1
55905: PPUSH
55906: CALL_OW 310
55910: NOT
55911: OR
55912: IFFALSE 55916
// exit ;
55914: GO 56006
// vehicle := IsInUnit ( driver ) ;
55916: LD_ADDR_VAR 0 3
55920: PUSH
55921: LD_VAR 0 1
55925: PPUSH
55926: CALL_OW 310
55930: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
55931: LD_VAR 0 1
55935: PPUSH
55936: LD_STRING \
55938: PUSH
55939: LD_INT 0
55941: PUSH
55942: LD_INT 0
55944: PUSH
55945: LD_INT 0
55947: PUSH
55948: LD_INT 0
55950: PUSH
55951: LD_INT 0
55953: PUSH
55954: LD_INT 0
55956: PUSH
55957: EMPTY
55958: LIST
55959: LIST
55960: LIST
55961: LIST
55962: LIST
55963: LIST
55964: LIST
55965: PUSH
55966: LD_STRING E
55968: PUSH
55969: LD_INT 0
55971: PUSH
55972: LD_INT 0
55974: PUSH
55975: LD_VAR 0 3
55979: PUSH
55980: LD_INT 0
55982: PUSH
55983: LD_INT 0
55985: PUSH
55986: LD_INT 0
55988: PUSH
55989: EMPTY
55990: LIST
55991: LIST
55992: LIST
55993: LIST
55994: LIST
55995: LIST
55996: LIST
55997: PUSH
55998: EMPTY
55999: LIST
56000: LIST
56001: PPUSH
56002: CALL_OW 446
// end ;
56006: LD_VAR 0 2
56010: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
56011: LD_INT 0
56013: PPUSH
56014: PPUSH
// if not driver or not IsInUnit ( driver ) then
56015: LD_VAR 0 1
56019: NOT
56020: PUSH
56021: LD_VAR 0 1
56025: PPUSH
56026: CALL_OW 310
56030: NOT
56031: OR
56032: IFFALSE 56036
// exit ;
56034: GO 56126
// vehicle := IsInUnit ( driver ) ;
56036: LD_ADDR_VAR 0 3
56040: PUSH
56041: LD_VAR 0 1
56045: PPUSH
56046: CALL_OW 310
56050: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
56051: LD_VAR 0 1
56055: PPUSH
56056: LD_STRING \
56058: PUSH
56059: LD_INT 0
56061: PUSH
56062: LD_INT 0
56064: PUSH
56065: LD_INT 0
56067: PUSH
56068: LD_INT 0
56070: PUSH
56071: LD_INT 0
56073: PUSH
56074: LD_INT 0
56076: PUSH
56077: EMPTY
56078: LIST
56079: LIST
56080: LIST
56081: LIST
56082: LIST
56083: LIST
56084: LIST
56085: PUSH
56086: LD_STRING E
56088: PUSH
56089: LD_INT 0
56091: PUSH
56092: LD_INT 0
56094: PUSH
56095: LD_VAR 0 3
56099: PUSH
56100: LD_INT 0
56102: PUSH
56103: LD_INT 0
56105: PUSH
56106: LD_INT 0
56108: PUSH
56109: EMPTY
56110: LIST
56111: LIST
56112: LIST
56113: LIST
56114: LIST
56115: LIST
56116: LIST
56117: PUSH
56118: EMPTY
56119: LIST
56120: LIST
56121: PPUSH
56122: CALL_OW 447
// end ;
56126: LD_VAR 0 2
56130: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
56131: LD_INT 0
56133: PPUSH
56134: PPUSH
56135: PPUSH
// tmp := [ ] ;
56136: LD_ADDR_VAR 0 5
56140: PUSH
56141: EMPTY
56142: ST_TO_ADDR
// for i in units do
56143: LD_ADDR_VAR 0 4
56147: PUSH
56148: LD_VAR 0 1
56152: PUSH
56153: FOR_IN
56154: IFFALSE 56192
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
56156: LD_ADDR_VAR 0 5
56160: PUSH
56161: LD_VAR 0 5
56165: PPUSH
56166: LD_VAR 0 5
56170: PUSH
56171: LD_INT 1
56173: PLUS
56174: PPUSH
56175: LD_VAR 0 4
56179: PPUSH
56180: CALL_OW 256
56184: PPUSH
56185: CALL_OW 2
56189: ST_TO_ADDR
56190: GO 56153
56192: POP
56193: POP
// if not tmp then
56194: LD_VAR 0 5
56198: NOT
56199: IFFALSE 56203
// exit ;
56201: GO 56251
// if asc then
56203: LD_VAR 0 2
56207: IFFALSE 56231
// result := SortListByListAsc ( units , tmp ) else
56209: LD_ADDR_VAR 0 3
56213: PUSH
56214: LD_VAR 0 1
56218: PPUSH
56219: LD_VAR 0 5
56223: PPUSH
56224: CALL_OW 76
56228: ST_TO_ADDR
56229: GO 56251
// result := SortListByListDesc ( units , tmp ) ;
56231: LD_ADDR_VAR 0 3
56235: PUSH
56236: LD_VAR 0 1
56240: PPUSH
56241: LD_VAR 0 5
56245: PPUSH
56246: CALL_OW 77
56250: ST_TO_ADDR
// end ;
56251: LD_VAR 0 3
56255: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
56256: LD_INT 0
56258: PPUSH
56259: PPUSH
// task := GetTaskList ( mech ) ;
56260: LD_ADDR_VAR 0 4
56264: PUSH
56265: LD_VAR 0 1
56269: PPUSH
56270: CALL_OW 437
56274: ST_TO_ADDR
// if not task then
56275: LD_VAR 0 4
56279: NOT
56280: IFFALSE 56284
// exit ;
56282: GO 56326
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
56284: LD_ADDR_VAR 0 3
56288: PUSH
56289: LD_VAR 0 4
56293: PUSH
56294: LD_INT 1
56296: ARRAY
56297: PUSH
56298: LD_INT 1
56300: ARRAY
56301: PUSH
56302: LD_STRING r
56304: EQUAL
56305: PUSH
56306: LD_VAR 0 4
56310: PUSH
56311: LD_INT 1
56313: ARRAY
56314: PUSH
56315: LD_INT 4
56317: ARRAY
56318: PUSH
56319: LD_VAR 0 2
56323: EQUAL
56324: AND
56325: ST_TO_ADDR
// end ;
56326: LD_VAR 0 3
56330: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
56331: LD_INT 0
56333: PPUSH
// SetDir ( unit , d ) ;
56334: LD_VAR 0 1
56338: PPUSH
56339: LD_VAR 0 4
56343: PPUSH
56344: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
56348: LD_VAR 0 1
56352: PPUSH
56353: LD_VAR 0 2
56357: PPUSH
56358: LD_VAR 0 3
56362: PPUSH
56363: LD_VAR 0 5
56367: PPUSH
56368: CALL_OW 48
// end ;
56372: LD_VAR 0 6
56376: RET
// export function ToNaturalNumber ( number ) ; begin
56377: LD_INT 0
56379: PPUSH
// result := number div 1 ;
56380: LD_ADDR_VAR 0 2
56384: PUSH
56385: LD_VAR 0 1
56389: PUSH
56390: LD_INT 1
56392: DIV
56393: ST_TO_ADDR
// if number < 0 then
56394: LD_VAR 0 1
56398: PUSH
56399: LD_INT 0
56401: LESS
56402: IFFALSE 56412
// result := 0 ;
56404: LD_ADDR_VAR 0 2
56408: PUSH
56409: LD_INT 0
56411: ST_TO_ADDR
// end ;
56412: LD_VAR 0 2
56416: RET
// export function SortByClass ( units , class ) ; var un ; begin
56417: LD_INT 0
56419: PPUSH
56420: PPUSH
// if not units or not class then
56421: LD_VAR 0 1
56425: NOT
56426: PUSH
56427: LD_VAR 0 2
56431: NOT
56432: OR
56433: IFFALSE 56437
// exit ;
56435: GO 56532
// result := [ ] ;
56437: LD_ADDR_VAR 0 3
56441: PUSH
56442: EMPTY
56443: ST_TO_ADDR
// for un in units do
56444: LD_ADDR_VAR 0 4
56448: PUSH
56449: LD_VAR 0 1
56453: PUSH
56454: FOR_IN
56455: IFFALSE 56530
// if GetClass ( un ) = class then
56457: LD_VAR 0 4
56461: PPUSH
56462: CALL_OW 257
56466: PUSH
56467: LD_VAR 0 2
56471: EQUAL
56472: IFFALSE 56499
// result := Insert ( result , 1 , un ) else
56474: LD_ADDR_VAR 0 3
56478: PUSH
56479: LD_VAR 0 3
56483: PPUSH
56484: LD_INT 1
56486: PPUSH
56487: LD_VAR 0 4
56491: PPUSH
56492: CALL_OW 2
56496: ST_TO_ADDR
56497: GO 56528
// result := Replace ( result , result + 1 , un ) ;
56499: LD_ADDR_VAR 0 3
56503: PUSH
56504: LD_VAR 0 3
56508: PPUSH
56509: LD_VAR 0 3
56513: PUSH
56514: LD_INT 1
56516: PLUS
56517: PPUSH
56518: LD_VAR 0 4
56522: PPUSH
56523: CALL_OW 1
56527: ST_TO_ADDR
56528: GO 56454
56530: POP
56531: POP
// end ;
56532: LD_VAR 0 3
56536: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
56537: LD_INT 0
56539: PPUSH
56540: PPUSH
56541: PPUSH
56542: PPUSH
56543: PPUSH
56544: PPUSH
56545: PPUSH
// result := [ ] ;
56546: LD_ADDR_VAR 0 4
56550: PUSH
56551: EMPTY
56552: ST_TO_ADDR
// if x - r < 0 then
56553: LD_VAR 0 1
56557: PUSH
56558: LD_VAR 0 3
56562: MINUS
56563: PUSH
56564: LD_INT 0
56566: LESS
56567: IFFALSE 56579
// min_x := 0 else
56569: LD_ADDR_VAR 0 8
56573: PUSH
56574: LD_INT 0
56576: ST_TO_ADDR
56577: GO 56595
// min_x := x - r ;
56579: LD_ADDR_VAR 0 8
56583: PUSH
56584: LD_VAR 0 1
56588: PUSH
56589: LD_VAR 0 3
56593: MINUS
56594: ST_TO_ADDR
// if y - r < 0 then
56595: LD_VAR 0 2
56599: PUSH
56600: LD_VAR 0 3
56604: MINUS
56605: PUSH
56606: LD_INT 0
56608: LESS
56609: IFFALSE 56621
// min_y := 0 else
56611: LD_ADDR_VAR 0 7
56615: PUSH
56616: LD_INT 0
56618: ST_TO_ADDR
56619: GO 56637
// min_y := y - r ;
56621: LD_ADDR_VAR 0 7
56625: PUSH
56626: LD_VAR 0 2
56630: PUSH
56631: LD_VAR 0 3
56635: MINUS
56636: ST_TO_ADDR
// max_x := x + r ;
56637: LD_ADDR_VAR 0 9
56641: PUSH
56642: LD_VAR 0 1
56646: PUSH
56647: LD_VAR 0 3
56651: PLUS
56652: ST_TO_ADDR
// max_y := y + r ;
56653: LD_ADDR_VAR 0 10
56657: PUSH
56658: LD_VAR 0 2
56662: PUSH
56663: LD_VAR 0 3
56667: PLUS
56668: ST_TO_ADDR
// for _x = min_x to max_x do
56669: LD_ADDR_VAR 0 5
56673: PUSH
56674: DOUBLE
56675: LD_VAR 0 8
56679: DEC
56680: ST_TO_ADDR
56681: LD_VAR 0 9
56685: PUSH
56686: FOR_TO
56687: IFFALSE 56788
// for _y = min_y to max_y do
56689: LD_ADDR_VAR 0 6
56693: PUSH
56694: DOUBLE
56695: LD_VAR 0 7
56699: DEC
56700: ST_TO_ADDR
56701: LD_VAR 0 10
56705: PUSH
56706: FOR_TO
56707: IFFALSE 56784
// begin if not ValidHex ( _x , _y ) then
56709: LD_VAR 0 5
56713: PPUSH
56714: LD_VAR 0 6
56718: PPUSH
56719: CALL_OW 488
56723: NOT
56724: IFFALSE 56728
// continue ;
56726: GO 56706
// if GetResourceTypeXY ( _x , _y ) then
56728: LD_VAR 0 5
56732: PPUSH
56733: LD_VAR 0 6
56737: PPUSH
56738: CALL_OW 283
56742: IFFALSE 56782
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
56744: LD_ADDR_VAR 0 4
56748: PUSH
56749: LD_VAR 0 4
56753: PPUSH
56754: LD_VAR 0 4
56758: PUSH
56759: LD_INT 1
56761: PLUS
56762: PPUSH
56763: LD_VAR 0 5
56767: PUSH
56768: LD_VAR 0 6
56772: PUSH
56773: EMPTY
56774: LIST
56775: LIST
56776: PPUSH
56777: CALL_OW 1
56781: ST_TO_ADDR
// end ;
56782: GO 56706
56784: POP
56785: POP
56786: GO 56686
56788: POP
56789: POP
// end ;
56790: LD_VAR 0 4
56794: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
56795: LD_INT 0
56797: PPUSH
56798: PPUSH
56799: PPUSH
56800: PPUSH
56801: PPUSH
56802: PPUSH
56803: PPUSH
56804: PPUSH
// if not units then
56805: LD_VAR 0 1
56809: NOT
56810: IFFALSE 56814
// exit ;
56812: GO 57342
// result := UnitFilter ( units , [ f_ok ] ) ;
56814: LD_ADDR_VAR 0 3
56818: PUSH
56819: LD_VAR 0 1
56823: PPUSH
56824: LD_INT 50
56826: PUSH
56827: EMPTY
56828: LIST
56829: PPUSH
56830: CALL_OW 72
56834: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
56835: LD_ADDR_VAR 0 8
56839: PUSH
56840: LD_VAR 0 1
56844: PUSH
56845: LD_INT 1
56847: ARRAY
56848: PPUSH
56849: CALL_OW 255
56853: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
56854: LD_ADDR_VAR 0 10
56858: PUSH
56859: LD_INT 29
56861: PUSH
56862: LD_INT 91
56864: PUSH
56865: LD_INT 49
56867: PUSH
56868: EMPTY
56869: LIST
56870: LIST
56871: LIST
56872: ST_TO_ADDR
// if not result then
56873: LD_VAR 0 3
56877: NOT
56878: IFFALSE 56882
// exit ;
56880: GO 57342
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
56882: LD_ADDR_VAR 0 5
56886: PUSH
56887: LD_INT 81
56889: PUSH
56890: LD_VAR 0 8
56894: PUSH
56895: EMPTY
56896: LIST
56897: LIST
56898: PPUSH
56899: CALL_OW 69
56903: ST_TO_ADDR
// for i in result do
56904: LD_ADDR_VAR 0 4
56908: PUSH
56909: LD_VAR 0 3
56913: PUSH
56914: FOR_IN
56915: IFFALSE 57340
// begin tag := GetTag ( i ) + 1 ;
56917: LD_ADDR_VAR 0 9
56921: PUSH
56922: LD_VAR 0 4
56926: PPUSH
56927: CALL_OW 110
56931: PUSH
56932: LD_INT 1
56934: PLUS
56935: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
56936: LD_ADDR_VAR 0 7
56940: PUSH
56941: LD_VAR 0 4
56945: PPUSH
56946: CALL_OW 250
56950: PPUSH
56951: LD_VAR 0 4
56955: PPUSH
56956: CALL_OW 251
56960: PPUSH
56961: LD_INT 4
56963: PPUSH
56964: CALL 56537 0 3
56968: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
56969: LD_VAR 0 4
56973: PPUSH
56974: CALL_OW 247
56978: PUSH
56979: LD_INT 2
56981: EQUAL
56982: PUSH
56983: LD_VAR 0 7
56987: PUSH
56988: LD_INT 2
56990: GREATER
56991: AND
56992: PUSH
56993: LD_VAR 0 4
56997: PPUSH
56998: CALL_OW 264
57002: PUSH
57003: LD_VAR 0 10
57007: IN
57008: NOT
57009: AND
57010: IFFALSE 57049
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
57012: LD_VAR 0 4
57016: PPUSH
57017: LD_VAR 0 7
57021: PUSH
57022: LD_INT 1
57024: ARRAY
57025: PUSH
57026: LD_INT 1
57028: ARRAY
57029: PPUSH
57030: LD_VAR 0 7
57034: PUSH
57035: LD_INT 1
57037: ARRAY
57038: PUSH
57039: LD_INT 2
57041: ARRAY
57042: PPUSH
57043: CALL_OW 116
57047: GO 57338
// if path > tag then
57049: LD_VAR 0 2
57053: PUSH
57054: LD_VAR 0 9
57058: GREATER
57059: IFFALSE 57267
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
57061: LD_ADDR_VAR 0 6
57065: PUSH
57066: LD_VAR 0 5
57070: PPUSH
57071: LD_INT 91
57073: PUSH
57074: LD_VAR 0 4
57078: PUSH
57079: LD_INT 8
57081: PUSH
57082: EMPTY
57083: LIST
57084: LIST
57085: LIST
57086: PPUSH
57087: CALL_OW 72
57091: ST_TO_ADDR
// if nearEnemy then
57092: LD_VAR 0 6
57096: IFFALSE 57165
// begin if GetWeapon ( i ) = ru_time_lapser then
57098: LD_VAR 0 4
57102: PPUSH
57103: CALL_OW 264
57107: PUSH
57108: LD_INT 49
57110: EQUAL
57111: IFFALSE 57139
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
57113: LD_VAR 0 4
57117: PPUSH
57118: LD_VAR 0 6
57122: PPUSH
57123: LD_VAR 0 4
57127: PPUSH
57128: CALL_OW 74
57132: PPUSH
57133: CALL_OW 112
57137: GO 57163
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
57139: LD_VAR 0 4
57143: PPUSH
57144: LD_VAR 0 6
57148: PPUSH
57149: LD_VAR 0 4
57153: PPUSH
57154: CALL_OW 74
57158: PPUSH
57159: CALL 58413 0 2
// end else
57163: GO 57265
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
57165: LD_VAR 0 4
57169: PPUSH
57170: LD_VAR 0 2
57174: PUSH
57175: LD_VAR 0 9
57179: ARRAY
57180: PUSH
57181: LD_INT 1
57183: ARRAY
57184: PPUSH
57185: LD_VAR 0 2
57189: PUSH
57190: LD_VAR 0 9
57194: ARRAY
57195: PUSH
57196: LD_INT 2
57198: ARRAY
57199: PPUSH
57200: CALL_OW 297
57204: PUSH
57205: LD_INT 6
57207: GREATER
57208: IFFALSE 57251
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
57210: LD_VAR 0 4
57214: PPUSH
57215: LD_VAR 0 2
57219: PUSH
57220: LD_VAR 0 9
57224: ARRAY
57225: PUSH
57226: LD_INT 1
57228: ARRAY
57229: PPUSH
57230: LD_VAR 0 2
57234: PUSH
57235: LD_VAR 0 9
57239: ARRAY
57240: PUSH
57241: LD_INT 2
57243: ARRAY
57244: PPUSH
57245: CALL_OW 114
57249: GO 57265
// SetTag ( i , tag ) ;
57251: LD_VAR 0 4
57255: PPUSH
57256: LD_VAR 0 9
57260: PPUSH
57261: CALL_OW 109
// end else
57265: GO 57338
// if enemy then
57267: LD_VAR 0 5
57271: IFFALSE 57338
// begin if GetWeapon ( i ) = ru_time_lapser then
57273: LD_VAR 0 4
57277: PPUSH
57278: CALL_OW 264
57282: PUSH
57283: LD_INT 49
57285: EQUAL
57286: IFFALSE 57314
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
57288: LD_VAR 0 4
57292: PPUSH
57293: LD_VAR 0 5
57297: PPUSH
57298: LD_VAR 0 4
57302: PPUSH
57303: CALL_OW 74
57307: PPUSH
57308: CALL_OW 112
57312: GO 57338
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
57314: LD_VAR 0 4
57318: PPUSH
57319: LD_VAR 0 5
57323: PPUSH
57324: LD_VAR 0 4
57328: PPUSH
57329: CALL_OW 74
57333: PPUSH
57334: CALL 58413 0 2
// end ; end ;
57338: GO 56914
57340: POP
57341: POP
// end ;
57342: LD_VAR 0 3
57346: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
57347: LD_INT 0
57349: PPUSH
57350: PPUSH
57351: PPUSH
// if not unit or IsInUnit ( unit ) then
57352: LD_VAR 0 1
57356: NOT
57357: PUSH
57358: LD_VAR 0 1
57362: PPUSH
57363: CALL_OW 310
57367: OR
57368: IFFALSE 57372
// exit ;
57370: GO 57463
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
57372: LD_ADDR_VAR 0 4
57376: PUSH
57377: LD_VAR 0 1
57381: PPUSH
57382: CALL_OW 250
57386: PPUSH
57387: LD_VAR 0 2
57391: PPUSH
57392: LD_INT 1
57394: PPUSH
57395: CALL_OW 272
57399: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
57400: LD_ADDR_VAR 0 5
57404: PUSH
57405: LD_VAR 0 1
57409: PPUSH
57410: CALL_OW 251
57414: PPUSH
57415: LD_VAR 0 2
57419: PPUSH
57420: LD_INT 1
57422: PPUSH
57423: CALL_OW 273
57427: ST_TO_ADDR
// if ValidHex ( x , y ) then
57428: LD_VAR 0 4
57432: PPUSH
57433: LD_VAR 0 5
57437: PPUSH
57438: CALL_OW 488
57442: IFFALSE 57463
// ComTurnXY ( unit , x , y ) ;
57444: LD_VAR 0 1
57448: PPUSH
57449: LD_VAR 0 4
57453: PPUSH
57454: LD_VAR 0 5
57458: PPUSH
57459: CALL_OW 118
// end ;
57463: LD_VAR 0 3
57467: RET
// export function SeeUnits ( side , units ) ; var i ; begin
57468: LD_INT 0
57470: PPUSH
57471: PPUSH
// result := false ;
57472: LD_ADDR_VAR 0 3
57476: PUSH
57477: LD_INT 0
57479: ST_TO_ADDR
// if not units then
57480: LD_VAR 0 2
57484: NOT
57485: IFFALSE 57489
// exit ;
57487: GO 57534
// for i in units do
57489: LD_ADDR_VAR 0 4
57493: PUSH
57494: LD_VAR 0 2
57498: PUSH
57499: FOR_IN
57500: IFFALSE 57532
// if See ( side , i ) then
57502: LD_VAR 0 1
57506: PPUSH
57507: LD_VAR 0 4
57511: PPUSH
57512: CALL_OW 292
57516: IFFALSE 57530
// begin result := true ;
57518: LD_ADDR_VAR 0 3
57522: PUSH
57523: LD_INT 1
57525: ST_TO_ADDR
// exit ;
57526: POP
57527: POP
57528: GO 57534
// end ;
57530: GO 57499
57532: POP
57533: POP
// end ;
57534: LD_VAR 0 3
57538: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
57539: LD_INT 0
57541: PPUSH
57542: PPUSH
57543: PPUSH
57544: PPUSH
// if not unit or not points then
57545: LD_VAR 0 1
57549: NOT
57550: PUSH
57551: LD_VAR 0 2
57555: NOT
57556: OR
57557: IFFALSE 57561
// exit ;
57559: GO 57651
// dist := 99999 ;
57561: LD_ADDR_VAR 0 5
57565: PUSH
57566: LD_INT 99999
57568: ST_TO_ADDR
// for i in points do
57569: LD_ADDR_VAR 0 4
57573: PUSH
57574: LD_VAR 0 2
57578: PUSH
57579: FOR_IN
57580: IFFALSE 57649
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
57582: LD_ADDR_VAR 0 6
57586: PUSH
57587: LD_VAR 0 1
57591: PPUSH
57592: LD_VAR 0 4
57596: PUSH
57597: LD_INT 1
57599: ARRAY
57600: PPUSH
57601: LD_VAR 0 4
57605: PUSH
57606: LD_INT 2
57608: ARRAY
57609: PPUSH
57610: CALL_OW 297
57614: ST_TO_ADDR
// if tmpDist < dist then
57615: LD_VAR 0 6
57619: PUSH
57620: LD_VAR 0 5
57624: LESS
57625: IFFALSE 57647
// begin result := i ;
57627: LD_ADDR_VAR 0 3
57631: PUSH
57632: LD_VAR 0 4
57636: ST_TO_ADDR
// dist := tmpDist ;
57637: LD_ADDR_VAR 0 5
57641: PUSH
57642: LD_VAR 0 6
57646: ST_TO_ADDR
// end ; end ;
57647: GO 57579
57649: POP
57650: POP
// end ;
57651: LD_VAR 0 3
57655: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
57656: LD_INT 0
57658: PPUSH
// uc_side := side ;
57659: LD_ADDR_OWVAR 20
57663: PUSH
57664: LD_VAR 0 1
57668: ST_TO_ADDR
// uc_nation := 3 ;
57669: LD_ADDR_OWVAR 21
57673: PUSH
57674: LD_INT 3
57676: ST_TO_ADDR
// vc_chassis := 25 ;
57677: LD_ADDR_OWVAR 37
57681: PUSH
57682: LD_INT 25
57684: ST_TO_ADDR
// vc_engine := engine_siberite ;
57685: LD_ADDR_OWVAR 39
57689: PUSH
57690: LD_INT 3
57692: ST_TO_ADDR
// vc_control := control_computer ;
57693: LD_ADDR_OWVAR 38
57697: PUSH
57698: LD_INT 3
57700: ST_TO_ADDR
// vc_weapon := 59 ;
57701: LD_ADDR_OWVAR 40
57705: PUSH
57706: LD_INT 59
57708: ST_TO_ADDR
// result := CreateVehicle ;
57709: LD_ADDR_VAR 0 5
57713: PUSH
57714: CALL_OW 45
57718: ST_TO_ADDR
// SetDir ( result , d ) ;
57719: LD_VAR 0 5
57723: PPUSH
57724: LD_VAR 0 4
57728: PPUSH
57729: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
57733: LD_VAR 0 5
57737: PPUSH
57738: LD_VAR 0 2
57742: PPUSH
57743: LD_VAR 0 3
57747: PPUSH
57748: LD_INT 0
57750: PPUSH
57751: CALL_OW 48
// end ;
57755: LD_VAR 0 5
57759: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
57760: LD_INT 0
57762: PPUSH
57763: PPUSH
57764: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
57765: LD_ADDR_VAR 0 2
57769: PUSH
57770: LD_INT 0
57772: PUSH
57773: LD_INT 0
57775: PUSH
57776: LD_INT 0
57778: PUSH
57779: LD_INT 0
57781: PUSH
57782: EMPTY
57783: LIST
57784: LIST
57785: LIST
57786: LIST
57787: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
57788: LD_VAR 0 1
57792: NOT
57793: PUSH
57794: LD_VAR 0 1
57798: PPUSH
57799: CALL_OW 264
57803: PUSH
57804: LD_INT 12
57806: PUSH
57807: LD_INT 51
57809: PUSH
57810: LD_INT 32
57812: PUSH
57813: LD_INT 89
57815: PUSH
57816: EMPTY
57817: LIST
57818: LIST
57819: LIST
57820: LIST
57821: IN
57822: NOT
57823: OR
57824: IFFALSE 57828
// exit ;
57826: GO 57926
// for i := 1 to 3 do
57828: LD_ADDR_VAR 0 3
57832: PUSH
57833: DOUBLE
57834: LD_INT 1
57836: DEC
57837: ST_TO_ADDR
57838: LD_INT 3
57840: PUSH
57841: FOR_TO
57842: IFFALSE 57924
// begin tmp := GetCargo ( cargo , i ) ;
57844: LD_ADDR_VAR 0 4
57848: PUSH
57849: LD_VAR 0 1
57853: PPUSH
57854: LD_VAR 0 3
57858: PPUSH
57859: CALL_OW 289
57863: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
57864: LD_ADDR_VAR 0 2
57868: PUSH
57869: LD_VAR 0 2
57873: PPUSH
57874: LD_VAR 0 3
57878: PPUSH
57879: LD_VAR 0 4
57883: PPUSH
57884: CALL_OW 1
57888: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
57889: LD_ADDR_VAR 0 2
57893: PUSH
57894: LD_VAR 0 2
57898: PPUSH
57899: LD_INT 4
57901: PPUSH
57902: LD_VAR 0 2
57906: PUSH
57907: LD_INT 4
57909: ARRAY
57910: PUSH
57911: LD_VAR 0 4
57915: PLUS
57916: PPUSH
57917: CALL_OW 1
57921: ST_TO_ADDR
// end ;
57922: GO 57841
57924: POP
57925: POP
// end ;
57926: LD_VAR 0 2
57930: RET
// export function Length ( array ) ; begin
57931: LD_INT 0
57933: PPUSH
// result := array + 0 ;
57934: LD_ADDR_VAR 0 2
57938: PUSH
57939: LD_VAR 0 1
57943: PUSH
57944: LD_INT 0
57946: PLUS
57947: ST_TO_ADDR
// end ;
57948: LD_VAR 0 2
57952: RET
// export function PrepareArray ( array ) ; begin
57953: LD_INT 0
57955: PPUSH
// result := array diff 0 ;
57956: LD_ADDR_VAR 0 2
57960: PUSH
57961: LD_VAR 0 1
57965: PUSH
57966: LD_INT 0
57968: DIFF
57969: ST_TO_ADDR
// if not result [ 1 ] then
57970: LD_VAR 0 2
57974: PUSH
57975: LD_INT 1
57977: ARRAY
57978: NOT
57979: IFFALSE 57999
// result := Delete ( result , 1 ) ;
57981: LD_ADDR_VAR 0 2
57985: PUSH
57986: LD_VAR 0 2
57990: PPUSH
57991: LD_INT 1
57993: PPUSH
57994: CALL_OW 3
57998: ST_TO_ADDR
// end ;
57999: LD_VAR 0 2
58003: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
58004: LD_INT 0
58006: PPUSH
58007: PPUSH
58008: PPUSH
58009: PPUSH
// sibRocketRange := 25 ;
58010: LD_ADDR_VAR 0 6
58014: PUSH
58015: LD_INT 25
58017: ST_TO_ADDR
// result := false ;
58018: LD_ADDR_VAR 0 4
58022: PUSH
58023: LD_INT 0
58025: ST_TO_ADDR
// for i := 0 to 5 do
58026: LD_ADDR_VAR 0 5
58030: PUSH
58031: DOUBLE
58032: LD_INT 0
58034: DEC
58035: ST_TO_ADDR
58036: LD_INT 5
58038: PUSH
58039: FOR_TO
58040: IFFALSE 58107
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
58042: LD_VAR 0 1
58046: PPUSH
58047: LD_VAR 0 5
58051: PPUSH
58052: LD_VAR 0 6
58056: PPUSH
58057: CALL_OW 272
58061: PPUSH
58062: LD_VAR 0 2
58066: PPUSH
58067: LD_VAR 0 5
58071: PPUSH
58072: LD_VAR 0 6
58076: PPUSH
58077: CALL_OW 273
58081: PPUSH
58082: LD_VAR 0 3
58086: PPUSH
58087: CALL_OW 309
58091: IFFALSE 58105
// begin result := true ;
58093: LD_ADDR_VAR 0 4
58097: PUSH
58098: LD_INT 1
58100: ST_TO_ADDR
// exit ;
58101: POP
58102: POP
58103: GO 58109
// end ;
58105: GO 58039
58107: POP
58108: POP
// end ;
58109: LD_VAR 0 4
58113: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
58114: LD_INT 0
58116: PPUSH
58117: PPUSH
58118: PPUSH
// if btype = b_depot then
58119: LD_VAR 0 2
58123: PUSH
58124: LD_INT 0
58126: EQUAL
58127: IFFALSE 58139
// begin result := true ;
58129: LD_ADDR_VAR 0 3
58133: PUSH
58134: LD_INT 1
58136: ST_TO_ADDR
// exit ;
58137: GO 58255
// end ; pom := GetBase ( depot ) ;
58139: LD_ADDR_VAR 0 4
58143: PUSH
58144: LD_VAR 0 1
58148: PPUSH
58149: CALL_OW 274
58153: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
58154: LD_ADDR_VAR 0 5
58158: PUSH
58159: LD_VAR 0 2
58163: PPUSH
58164: LD_VAR 0 1
58168: PPUSH
58169: CALL_OW 248
58173: PPUSH
58174: CALL_OW 450
58178: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
58179: LD_ADDR_VAR 0 3
58183: PUSH
58184: LD_VAR 0 4
58188: PPUSH
58189: LD_INT 1
58191: PPUSH
58192: CALL_OW 275
58196: PUSH
58197: LD_VAR 0 5
58201: PUSH
58202: LD_INT 1
58204: ARRAY
58205: GREATEREQUAL
58206: PUSH
58207: LD_VAR 0 4
58211: PPUSH
58212: LD_INT 2
58214: PPUSH
58215: CALL_OW 275
58219: PUSH
58220: LD_VAR 0 5
58224: PUSH
58225: LD_INT 2
58227: ARRAY
58228: GREATEREQUAL
58229: AND
58230: PUSH
58231: LD_VAR 0 4
58235: PPUSH
58236: LD_INT 3
58238: PPUSH
58239: CALL_OW 275
58243: PUSH
58244: LD_VAR 0 5
58248: PUSH
58249: LD_INT 3
58251: ARRAY
58252: GREATEREQUAL
58253: AND
58254: ST_TO_ADDR
// end ;
58255: LD_VAR 0 3
58259: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
58260: LD_INT 0
58262: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
58263: LD_VAR 0 1
58267: PPUSH
58268: LD_VAR 0 2
58272: PPUSH
58273: LD_INT 0
58275: PPUSH
58276: LD_INT 0
58278: PPUSH
58279: LD_INT 1
58281: PPUSH
58282: LD_INT 0
58284: PPUSH
58285: CALL_OW 587
// end ;
58289: LD_VAR 0 3
58293: RET
// export function CenterOnNow ( unit ) ; begin
58294: LD_INT 0
58296: PPUSH
// result := IsInUnit ( unit ) ;
58297: LD_ADDR_VAR 0 2
58301: PUSH
58302: LD_VAR 0 1
58306: PPUSH
58307: CALL_OW 310
58311: ST_TO_ADDR
// if not result then
58312: LD_VAR 0 2
58316: NOT
58317: IFFALSE 58329
// result := unit ;
58319: LD_ADDR_VAR 0 2
58323: PUSH
58324: LD_VAR 0 1
58328: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
58329: LD_VAR 0 1
58333: PPUSH
58334: CALL_OW 87
// end ;
58338: LD_VAR 0 2
58342: RET
// export function ComMoveHex ( unit , hex ) ; begin
58343: LD_INT 0
58345: PPUSH
// if not hex then
58346: LD_VAR 0 2
58350: NOT
58351: IFFALSE 58355
// exit ;
58353: GO 58408
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
58355: LD_VAR 0 2
58359: PUSH
58360: LD_INT 1
58362: ARRAY
58363: PPUSH
58364: LD_VAR 0 2
58368: PUSH
58369: LD_INT 2
58371: ARRAY
58372: PPUSH
58373: CALL_OW 428
58377: IFFALSE 58381
// exit ;
58379: GO 58408
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
58381: LD_VAR 0 1
58385: PPUSH
58386: LD_VAR 0 2
58390: PUSH
58391: LD_INT 1
58393: ARRAY
58394: PPUSH
58395: LD_VAR 0 2
58399: PUSH
58400: LD_INT 2
58402: ARRAY
58403: PPUSH
58404: CALL_OW 111
// end ;
58408: LD_VAR 0 3
58412: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
58413: LD_INT 0
58415: PPUSH
58416: PPUSH
58417: PPUSH
// if not unit or not enemy then
58418: LD_VAR 0 1
58422: NOT
58423: PUSH
58424: LD_VAR 0 2
58428: NOT
58429: OR
58430: IFFALSE 58434
// exit ;
58432: GO 58558
// x := GetX ( enemy ) ;
58434: LD_ADDR_VAR 0 4
58438: PUSH
58439: LD_VAR 0 2
58443: PPUSH
58444: CALL_OW 250
58448: ST_TO_ADDR
// y := GetY ( enemy ) ;
58449: LD_ADDR_VAR 0 5
58453: PUSH
58454: LD_VAR 0 2
58458: PPUSH
58459: CALL_OW 251
58463: ST_TO_ADDR
// if ValidHex ( x , y ) then
58464: LD_VAR 0 4
58468: PPUSH
58469: LD_VAR 0 5
58473: PPUSH
58474: CALL_OW 488
58478: IFFALSE 58558
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
58480: LD_VAR 0 2
58484: PPUSH
58485: CALL_OW 247
58489: PUSH
58490: LD_INT 3
58492: PUSH
58493: LD_INT 2
58495: PUSH
58496: EMPTY
58497: LIST
58498: LIST
58499: IN
58500: PUSH
58501: LD_VAR 0 1
58505: PPUSH
58506: CALL_OW 255
58510: PPUSH
58511: LD_VAR 0 2
58515: PPUSH
58516: CALL_OW 292
58520: OR
58521: IFFALSE 58539
// ComAttackUnit ( unit , enemy ) else
58523: LD_VAR 0 1
58527: PPUSH
58528: LD_VAR 0 2
58532: PPUSH
58533: CALL_OW 115
58537: GO 58558
// ComAgressiveMove ( unit , x , y ) ;
58539: LD_VAR 0 1
58543: PPUSH
58544: LD_VAR 0 4
58548: PPUSH
58549: LD_VAR 0 5
58553: PPUSH
58554: CALL_OW 114
// end ;
58558: LD_VAR 0 3
58562: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
58563: LD_INT 0
58565: PPUSH
58566: PPUSH
58567: PPUSH
// list := AreaToList ( area , 0 ) ;
58568: LD_ADDR_VAR 0 5
58572: PUSH
58573: LD_VAR 0 1
58577: PPUSH
58578: LD_INT 0
58580: PPUSH
58581: CALL_OW 517
58585: ST_TO_ADDR
// if not list then
58586: LD_VAR 0 5
58590: NOT
58591: IFFALSE 58595
// exit ;
58593: GO 58725
// if all then
58595: LD_VAR 0 2
58599: IFFALSE 58687
// begin for i := 1 to list [ 1 ] do
58601: LD_ADDR_VAR 0 4
58605: PUSH
58606: DOUBLE
58607: LD_INT 1
58609: DEC
58610: ST_TO_ADDR
58611: LD_VAR 0 5
58615: PUSH
58616: LD_INT 1
58618: ARRAY
58619: PUSH
58620: FOR_TO
58621: IFFALSE 58683
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
58623: LD_ADDR_VAR 0 3
58627: PUSH
58628: LD_VAR 0 3
58632: PPUSH
58633: LD_VAR 0 3
58637: PUSH
58638: LD_INT 1
58640: PLUS
58641: PPUSH
58642: LD_VAR 0 5
58646: PUSH
58647: LD_INT 1
58649: ARRAY
58650: PUSH
58651: LD_VAR 0 4
58655: ARRAY
58656: PUSH
58657: LD_VAR 0 5
58661: PUSH
58662: LD_INT 2
58664: ARRAY
58665: PUSH
58666: LD_VAR 0 4
58670: ARRAY
58671: PUSH
58672: EMPTY
58673: LIST
58674: LIST
58675: PPUSH
58676: CALL_OW 1
58680: ST_TO_ADDR
58681: GO 58620
58683: POP
58684: POP
// exit ;
58685: GO 58725
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
58687: LD_ADDR_VAR 0 3
58691: PUSH
58692: LD_VAR 0 5
58696: PUSH
58697: LD_INT 1
58699: ARRAY
58700: PUSH
58701: LD_INT 1
58703: ARRAY
58704: PUSH
58705: LD_VAR 0 5
58709: PUSH
58710: LD_INT 2
58712: ARRAY
58713: PUSH
58714: LD_INT 1
58716: ARRAY
58717: PUSH
58718: EMPTY
58719: LIST
58720: LIST
58721: PUSH
58722: EMPTY
58723: LIST
58724: ST_TO_ADDR
// end ;
58725: LD_VAR 0 3
58729: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
58730: LD_INT 0
58732: PPUSH
58733: PPUSH
// list := AreaToList ( area , 0 ) ;
58734: LD_ADDR_VAR 0 4
58738: PUSH
58739: LD_VAR 0 1
58743: PPUSH
58744: LD_INT 0
58746: PPUSH
58747: CALL_OW 517
58751: ST_TO_ADDR
// if not list then
58752: LD_VAR 0 4
58756: NOT
58757: IFFALSE 58761
// exit ;
58759: GO 58802
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
58761: LD_ADDR_VAR 0 3
58765: PUSH
58766: LD_VAR 0 4
58770: PUSH
58771: LD_INT 1
58773: ARRAY
58774: PUSH
58775: LD_INT 1
58777: ARRAY
58778: PUSH
58779: LD_VAR 0 4
58783: PUSH
58784: LD_INT 2
58786: ARRAY
58787: PUSH
58788: LD_INT 1
58790: ARRAY
58791: PUSH
58792: LD_VAR 0 2
58796: PUSH
58797: EMPTY
58798: LIST
58799: LIST
58800: LIST
58801: ST_TO_ADDR
// end ;
58802: LD_VAR 0 3
58806: RET
// export function First ( array ) ; begin
58807: LD_INT 0
58809: PPUSH
// if not array then
58810: LD_VAR 0 1
58814: NOT
58815: IFFALSE 58819
// exit ;
58817: GO 58833
// result := array [ 1 ] ;
58819: LD_ADDR_VAR 0 2
58823: PUSH
58824: LD_VAR 0 1
58828: PUSH
58829: LD_INT 1
58831: ARRAY
58832: ST_TO_ADDR
// end ;
58833: LD_VAR 0 2
58837: RET
// export function Last ( array ) ; begin
58838: LD_INT 0
58840: PPUSH
// if not array then
58841: LD_VAR 0 1
58845: NOT
58846: IFFALSE 58850
// exit ;
58848: GO 58866
// result := array [ array ] ;
58850: LD_ADDR_VAR 0 2
58854: PUSH
58855: LD_VAR 0 1
58859: PUSH
58860: LD_VAR 0 1
58864: ARRAY
58865: ST_TO_ADDR
// end ;
58866: LD_VAR 0 2
58870: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
58871: LD_INT 0
58873: PPUSH
58874: PPUSH
// result := [ ] ;
58875: LD_ADDR_VAR 0 5
58879: PUSH
58880: EMPTY
58881: ST_TO_ADDR
// if not array then
58882: LD_VAR 0 1
58886: NOT
58887: IFFALSE 58891
// exit ;
58889: GO 59003
// for i := 1 to array do
58891: LD_ADDR_VAR 0 6
58895: PUSH
58896: DOUBLE
58897: LD_INT 1
58899: DEC
58900: ST_TO_ADDR
58901: LD_VAR 0 1
58905: PUSH
58906: FOR_TO
58907: IFFALSE 59001
// if array [ i ] [ index ] = value then
58909: LD_VAR 0 1
58913: PUSH
58914: LD_VAR 0 6
58918: ARRAY
58919: PUSH
58920: LD_VAR 0 2
58924: ARRAY
58925: PUSH
58926: LD_VAR 0 3
58930: EQUAL
58931: IFFALSE 58999
// begin if indexColumn then
58933: LD_VAR 0 4
58937: IFFALSE 58973
// result := Join ( result , array [ i ] [ indexColumn ] ) else
58939: LD_ADDR_VAR 0 5
58943: PUSH
58944: LD_VAR 0 5
58948: PPUSH
58949: LD_VAR 0 1
58953: PUSH
58954: LD_VAR 0 6
58958: ARRAY
58959: PUSH
58960: LD_VAR 0 4
58964: ARRAY
58965: PPUSH
58966: CALL 54191 0 2
58970: ST_TO_ADDR
58971: GO 58999
// result := Join ( result , array [ i ] ) ;
58973: LD_ADDR_VAR 0 5
58977: PUSH
58978: LD_VAR 0 5
58982: PPUSH
58983: LD_VAR 0 1
58987: PUSH
58988: LD_VAR 0 6
58992: ARRAY
58993: PPUSH
58994: CALL 54191 0 2
58998: ST_TO_ADDR
// end ;
58999: GO 58906
59001: POP
59002: POP
// end ;
59003: LD_VAR 0 5
59007: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
59008: LD_INT 0
59010: PPUSH
// if not vehicles or not parkingPoint then
59011: LD_VAR 0 1
59015: NOT
59016: PUSH
59017: LD_VAR 0 2
59021: NOT
59022: OR
59023: IFFALSE 59027
// exit ;
59025: GO 59125
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
59027: LD_ADDR_VAR 0 1
59031: PUSH
59032: LD_VAR 0 1
59036: PPUSH
59037: LD_INT 50
59039: PUSH
59040: EMPTY
59041: LIST
59042: PUSH
59043: LD_INT 3
59045: PUSH
59046: LD_INT 92
59048: PUSH
59049: LD_VAR 0 2
59053: PUSH
59054: LD_INT 1
59056: ARRAY
59057: PUSH
59058: LD_VAR 0 2
59062: PUSH
59063: LD_INT 2
59065: ARRAY
59066: PUSH
59067: LD_INT 8
59069: PUSH
59070: EMPTY
59071: LIST
59072: LIST
59073: LIST
59074: LIST
59075: PUSH
59076: EMPTY
59077: LIST
59078: LIST
59079: PUSH
59080: EMPTY
59081: LIST
59082: LIST
59083: PPUSH
59084: CALL_OW 72
59088: ST_TO_ADDR
// if not vehicles then
59089: LD_VAR 0 1
59093: NOT
59094: IFFALSE 59098
// exit ;
59096: GO 59125
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
59098: LD_VAR 0 1
59102: PPUSH
59103: LD_VAR 0 2
59107: PUSH
59108: LD_INT 1
59110: ARRAY
59111: PPUSH
59112: LD_VAR 0 2
59116: PUSH
59117: LD_INT 2
59119: ARRAY
59120: PPUSH
59121: CALL_OW 111
// end ;
59125: LD_VAR 0 3
59129: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
59130: LD_INT 0
59132: PPUSH
59133: PPUSH
59134: PPUSH
// if not side or not area then
59135: LD_VAR 0 1
59139: NOT
59140: PUSH
59141: LD_VAR 0 2
59145: NOT
59146: OR
59147: IFFALSE 59151
// exit ;
59149: GO 59270
// tmp := AreaToList ( area , 0 ) ;
59151: LD_ADDR_VAR 0 5
59155: PUSH
59156: LD_VAR 0 2
59160: PPUSH
59161: LD_INT 0
59163: PPUSH
59164: CALL_OW 517
59168: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
59169: LD_ADDR_VAR 0 4
59173: PUSH
59174: DOUBLE
59175: LD_INT 1
59177: DEC
59178: ST_TO_ADDR
59179: LD_VAR 0 5
59183: PUSH
59184: LD_INT 1
59186: ARRAY
59187: PUSH
59188: FOR_TO
59189: IFFALSE 59268
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
59191: LD_VAR 0 5
59195: PUSH
59196: LD_INT 1
59198: ARRAY
59199: PUSH
59200: LD_VAR 0 4
59204: ARRAY
59205: PPUSH
59206: LD_VAR 0 5
59210: PUSH
59211: LD_INT 2
59213: ARRAY
59214: PUSH
59215: LD_VAR 0 4
59219: ARRAY
59220: PPUSH
59221: CALL_OW 351
59225: IFFALSE 59266
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
59227: LD_VAR 0 5
59231: PUSH
59232: LD_INT 1
59234: ARRAY
59235: PUSH
59236: LD_VAR 0 4
59240: ARRAY
59241: PPUSH
59242: LD_VAR 0 5
59246: PUSH
59247: LD_INT 2
59249: ARRAY
59250: PUSH
59251: LD_VAR 0 4
59255: ARRAY
59256: PPUSH
59257: LD_VAR 0 1
59261: PPUSH
59262: CALL_OW 244
// end ;
59266: GO 59188
59268: POP
59269: POP
// end ; end_of_file
59270: LD_VAR 0 3
59274: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
59275: LD_INT 0
59277: PPUSH
59278: PPUSH
// skirmish := false ;
59279: LD_ADDR_EXP 60
59283: PUSH
59284: LD_INT 0
59286: ST_TO_ADDR
// debug_mc := false ;
59287: LD_ADDR_EXP 61
59291: PUSH
59292: LD_INT 0
59294: ST_TO_ADDR
// mc_bases := [ ] ;
59295: LD_ADDR_EXP 62
59299: PUSH
59300: EMPTY
59301: ST_TO_ADDR
// mc_sides := [ ] ;
59302: LD_ADDR_EXP 88
59306: PUSH
59307: EMPTY
59308: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
59309: LD_ADDR_EXP 63
59313: PUSH
59314: EMPTY
59315: ST_TO_ADDR
// mc_building_repairs := [ ] ;
59316: LD_ADDR_EXP 64
59320: PUSH
59321: EMPTY
59322: ST_TO_ADDR
// mc_need_heal := [ ] ;
59323: LD_ADDR_EXP 65
59327: PUSH
59328: EMPTY
59329: ST_TO_ADDR
// mc_healers := [ ] ;
59330: LD_ADDR_EXP 66
59334: PUSH
59335: EMPTY
59336: ST_TO_ADDR
// mc_build_list := [ ] ;
59337: LD_ADDR_EXP 67
59341: PUSH
59342: EMPTY
59343: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
59344: LD_ADDR_EXP 94
59348: PUSH
59349: EMPTY
59350: ST_TO_ADDR
// mc_builders := [ ] ;
59351: LD_ADDR_EXP 68
59355: PUSH
59356: EMPTY
59357: ST_TO_ADDR
// mc_construct_list := [ ] ;
59358: LD_ADDR_EXP 69
59362: PUSH
59363: EMPTY
59364: ST_TO_ADDR
// mc_turret_list := [ ] ;
59365: LD_ADDR_EXP 70
59369: PUSH
59370: EMPTY
59371: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
59372: LD_ADDR_EXP 71
59376: PUSH
59377: EMPTY
59378: ST_TO_ADDR
// mc_miners := [ ] ;
59379: LD_ADDR_EXP 76
59383: PUSH
59384: EMPTY
59385: ST_TO_ADDR
// mc_mines := [ ] ;
59386: LD_ADDR_EXP 75
59390: PUSH
59391: EMPTY
59392: ST_TO_ADDR
// mc_minefields := [ ] ;
59393: LD_ADDR_EXP 77
59397: PUSH
59398: EMPTY
59399: ST_TO_ADDR
// mc_crates := [ ] ;
59400: LD_ADDR_EXP 78
59404: PUSH
59405: EMPTY
59406: ST_TO_ADDR
// mc_crates_collector := [ ] ;
59407: LD_ADDR_EXP 79
59411: PUSH
59412: EMPTY
59413: ST_TO_ADDR
// mc_crates_area := [ ] ;
59414: LD_ADDR_EXP 80
59418: PUSH
59419: EMPTY
59420: ST_TO_ADDR
// mc_vehicles := [ ] ;
59421: LD_ADDR_EXP 81
59425: PUSH
59426: EMPTY
59427: ST_TO_ADDR
// mc_attack := [ ] ;
59428: LD_ADDR_EXP 82
59432: PUSH
59433: EMPTY
59434: ST_TO_ADDR
// mc_produce := [ ] ;
59435: LD_ADDR_EXP 83
59439: PUSH
59440: EMPTY
59441: ST_TO_ADDR
// mc_defender := [ ] ;
59442: LD_ADDR_EXP 84
59446: PUSH
59447: EMPTY
59448: ST_TO_ADDR
// mc_parking := [ ] ;
59449: LD_ADDR_EXP 86
59453: PUSH
59454: EMPTY
59455: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
59456: LD_ADDR_EXP 72
59460: PUSH
59461: EMPTY
59462: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
59463: LD_ADDR_EXP 74
59467: PUSH
59468: EMPTY
59469: ST_TO_ADDR
// mc_scan := [ ] ;
59470: LD_ADDR_EXP 85
59474: PUSH
59475: EMPTY
59476: ST_TO_ADDR
// mc_scan_area := [ ] ;
59477: LD_ADDR_EXP 87
59481: PUSH
59482: EMPTY
59483: ST_TO_ADDR
// mc_tech := [ ] ;
59484: LD_ADDR_EXP 89
59488: PUSH
59489: EMPTY
59490: ST_TO_ADDR
// mc_class := [ ] ;
59491: LD_ADDR_EXP 103
59495: PUSH
59496: EMPTY
59497: ST_TO_ADDR
// mc_class_case_use := [ ] ;
59498: LD_ADDR_EXP 104
59502: PUSH
59503: EMPTY
59504: ST_TO_ADDR
// mc_is_defending := [ ] ;
59505: LD_ADDR_EXP 105
59509: PUSH
59510: EMPTY
59511: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
59512: LD_ADDR_EXP 96
59516: PUSH
59517: EMPTY
59518: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
59519: LD_ADDR_EXP 106
59523: PUSH
59524: LD_INT 0
59526: ST_TO_ADDR
// end ;
59527: LD_VAR 0 1
59531: RET
// export function MC_Kill ( base ) ; begin
59532: LD_INT 0
59534: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
59535: LD_ADDR_EXP 62
59539: PUSH
59540: LD_EXP 62
59544: PPUSH
59545: LD_VAR 0 1
59549: PPUSH
59550: EMPTY
59551: PPUSH
59552: CALL_OW 1
59556: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
59557: LD_ADDR_EXP 63
59561: PUSH
59562: LD_EXP 63
59566: PPUSH
59567: LD_VAR 0 1
59571: PPUSH
59572: EMPTY
59573: PPUSH
59574: CALL_OW 1
59578: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
59579: LD_ADDR_EXP 64
59583: PUSH
59584: LD_EXP 64
59588: PPUSH
59589: LD_VAR 0 1
59593: PPUSH
59594: EMPTY
59595: PPUSH
59596: CALL_OW 1
59600: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
59601: LD_ADDR_EXP 65
59605: PUSH
59606: LD_EXP 65
59610: PPUSH
59611: LD_VAR 0 1
59615: PPUSH
59616: EMPTY
59617: PPUSH
59618: CALL_OW 1
59622: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
59623: LD_ADDR_EXP 66
59627: PUSH
59628: LD_EXP 66
59632: PPUSH
59633: LD_VAR 0 1
59637: PPUSH
59638: EMPTY
59639: PPUSH
59640: CALL_OW 1
59644: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
59645: LD_ADDR_EXP 67
59649: PUSH
59650: LD_EXP 67
59654: PPUSH
59655: LD_VAR 0 1
59659: PPUSH
59660: EMPTY
59661: PPUSH
59662: CALL_OW 1
59666: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
59667: LD_ADDR_EXP 68
59671: PUSH
59672: LD_EXP 68
59676: PPUSH
59677: LD_VAR 0 1
59681: PPUSH
59682: EMPTY
59683: PPUSH
59684: CALL_OW 1
59688: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
59689: LD_ADDR_EXP 69
59693: PUSH
59694: LD_EXP 69
59698: PPUSH
59699: LD_VAR 0 1
59703: PPUSH
59704: EMPTY
59705: PPUSH
59706: CALL_OW 1
59710: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
59711: LD_ADDR_EXP 70
59715: PUSH
59716: LD_EXP 70
59720: PPUSH
59721: LD_VAR 0 1
59725: PPUSH
59726: EMPTY
59727: PPUSH
59728: CALL_OW 1
59732: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
59733: LD_ADDR_EXP 71
59737: PUSH
59738: LD_EXP 71
59742: PPUSH
59743: LD_VAR 0 1
59747: PPUSH
59748: EMPTY
59749: PPUSH
59750: CALL_OW 1
59754: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
59755: LD_ADDR_EXP 72
59759: PUSH
59760: LD_EXP 72
59764: PPUSH
59765: LD_VAR 0 1
59769: PPUSH
59770: EMPTY
59771: PPUSH
59772: CALL_OW 1
59776: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
59777: LD_ADDR_EXP 73
59781: PUSH
59782: LD_EXP 73
59786: PPUSH
59787: LD_VAR 0 1
59791: PPUSH
59792: LD_INT 0
59794: PPUSH
59795: CALL_OW 1
59799: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
59800: LD_ADDR_EXP 74
59804: PUSH
59805: LD_EXP 74
59809: PPUSH
59810: LD_VAR 0 1
59814: PPUSH
59815: EMPTY
59816: PPUSH
59817: CALL_OW 1
59821: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
59822: LD_ADDR_EXP 75
59826: PUSH
59827: LD_EXP 75
59831: PPUSH
59832: LD_VAR 0 1
59836: PPUSH
59837: EMPTY
59838: PPUSH
59839: CALL_OW 1
59843: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
59844: LD_ADDR_EXP 76
59848: PUSH
59849: LD_EXP 76
59853: PPUSH
59854: LD_VAR 0 1
59858: PPUSH
59859: EMPTY
59860: PPUSH
59861: CALL_OW 1
59865: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
59866: LD_ADDR_EXP 77
59870: PUSH
59871: LD_EXP 77
59875: PPUSH
59876: LD_VAR 0 1
59880: PPUSH
59881: EMPTY
59882: PPUSH
59883: CALL_OW 1
59887: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
59888: LD_ADDR_EXP 78
59892: PUSH
59893: LD_EXP 78
59897: PPUSH
59898: LD_VAR 0 1
59902: PPUSH
59903: EMPTY
59904: PPUSH
59905: CALL_OW 1
59909: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59910: LD_ADDR_EXP 79
59914: PUSH
59915: LD_EXP 79
59919: PPUSH
59920: LD_VAR 0 1
59924: PPUSH
59925: EMPTY
59926: PPUSH
59927: CALL_OW 1
59931: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59932: LD_ADDR_EXP 80
59936: PUSH
59937: LD_EXP 80
59941: PPUSH
59942: LD_VAR 0 1
59946: PPUSH
59947: EMPTY
59948: PPUSH
59949: CALL_OW 1
59953: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59954: LD_ADDR_EXP 81
59958: PUSH
59959: LD_EXP 81
59963: PPUSH
59964: LD_VAR 0 1
59968: PPUSH
59969: EMPTY
59970: PPUSH
59971: CALL_OW 1
59975: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59976: LD_ADDR_EXP 82
59980: PUSH
59981: LD_EXP 82
59985: PPUSH
59986: LD_VAR 0 1
59990: PPUSH
59991: EMPTY
59992: PPUSH
59993: CALL_OW 1
59997: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59998: LD_ADDR_EXP 83
60002: PUSH
60003: LD_EXP 83
60007: PPUSH
60008: LD_VAR 0 1
60012: PPUSH
60013: EMPTY
60014: PPUSH
60015: CALL_OW 1
60019: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
60020: LD_ADDR_EXP 84
60024: PUSH
60025: LD_EXP 84
60029: PPUSH
60030: LD_VAR 0 1
60034: PPUSH
60035: EMPTY
60036: PPUSH
60037: CALL_OW 1
60041: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
60042: LD_ADDR_EXP 85
60046: PUSH
60047: LD_EXP 85
60051: PPUSH
60052: LD_VAR 0 1
60056: PPUSH
60057: EMPTY
60058: PPUSH
60059: CALL_OW 1
60063: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
60064: LD_ADDR_EXP 86
60068: PUSH
60069: LD_EXP 86
60073: PPUSH
60074: LD_VAR 0 1
60078: PPUSH
60079: EMPTY
60080: PPUSH
60081: CALL_OW 1
60085: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
60086: LD_ADDR_EXP 87
60090: PUSH
60091: LD_EXP 87
60095: PPUSH
60096: LD_VAR 0 1
60100: PPUSH
60101: EMPTY
60102: PPUSH
60103: CALL_OW 1
60107: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
60108: LD_ADDR_EXP 89
60112: PUSH
60113: LD_EXP 89
60117: PPUSH
60118: LD_VAR 0 1
60122: PPUSH
60123: EMPTY
60124: PPUSH
60125: CALL_OW 1
60129: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
60130: LD_ADDR_EXP 91
60134: PUSH
60135: LD_EXP 91
60139: PPUSH
60140: LD_VAR 0 1
60144: PPUSH
60145: EMPTY
60146: PPUSH
60147: CALL_OW 1
60151: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
60152: LD_ADDR_EXP 92
60156: PUSH
60157: LD_EXP 92
60161: PPUSH
60162: LD_VAR 0 1
60166: PPUSH
60167: EMPTY
60168: PPUSH
60169: CALL_OW 1
60173: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
60174: LD_ADDR_EXP 93
60178: PUSH
60179: LD_EXP 93
60183: PPUSH
60184: LD_VAR 0 1
60188: PPUSH
60189: EMPTY
60190: PPUSH
60191: CALL_OW 1
60195: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
60196: LD_ADDR_EXP 94
60200: PUSH
60201: LD_EXP 94
60205: PPUSH
60206: LD_VAR 0 1
60210: PPUSH
60211: EMPTY
60212: PPUSH
60213: CALL_OW 1
60217: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
60218: LD_ADDR_EXP 95
60222: PUSH
60223: LD_EXP 95
60227: PPUSH
60228: LD_VAR 0 1
60232: PPUSH
60233: EMPTY
60234: PPUSH
60235: CALL_OW 1
60239: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
60240: LD_ADDR_EXP 96
60244: PUSH
60245: LD_EXP 96
60249: PPUSH
60250: LD_VAR 0 1
60254: PPUSH
60255: EMPTY
60256: PPUSH
60257: CALL_OW 1
60261: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
60262: LD_ADDR_EXP 97
60266: PUSH
60267: LD_EXP 97
60271: PPUSH
60272: LD_VAR 0 1
60276: PPUSH
60277: EMPTY
60278: PPUSH
60279: CALL_OW 1
60283: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
60284: LD_ADDR_EXP 98
60288: PUSH
60289: LD_EXP 98
60293: PPUSH
60294: LD_VAR 0 1
60298: PPUSH
60299: EMPTY
60300: PPUSH
60301: CALL_OW 1
60305: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
60306: LD_ADDR_EXP 99
60310: PUSH
60311: LD_EXP 99
60315: PPUSH
60316: LD_VAR 0 1
60320: PPUSH
60321: EMPTY
60322: PPUSH
60323: CALL_OW 1
60327: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
60328: LD_ADDR_EXP 100
60332: PUSH
60333: LD_EXP 100
60337: PPUSH
60338: LD_VAR 0 1
60342: PPUSH
60343: EMPTY
60344: PPUSH
60345: CALL_OW 1
60349: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
60350: LD_ADDR_EXP 101
60354: PUSH
60355: LD_EXP 101
60359: PPUSH
60360: LD_VAR 0 1
60364: PPUSH
60365: EMPTY
60366: PPUSH
60367: CALL_OW 1
60371: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
60372: LD_ADDR_EXP 102
60376: PUSH
60377: LD_EXP 102
60381: PPUSH
60382: LD_VAR 0 1
60386: PPUSH
60387: EMPTY
60388: PPUSH
60389: CALL_OW 1
60393: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
60394: LD_ADDR_EXP 103
60398: PUSH
60399: LD_EXP 103
60403: PPUSH
60404: LD_VAR 0 1
60408: PPUSH
60409: EMPTY
60410: PPUSH
60411: CALL_OW 1
60415: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
60416: LD_ADDR_EXP 104
60420: PUSH
60421: LD_EXP 104
60425: PPUSH
60426: LD_VAR 0 1
60430: PPUSH
60431: LD_INT 0
60433: PPUSH
60434: CALL_OW 1
60438: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
60439: LD_ADDR_EXP 105
60443: PUSH
60444: LD_EXP 105
60448: PPUSH
60449: LD_VAR 0 1
60453: PPUSH
60454: LD_INT 0
60456: PPUSH
60457: CALL_OW 1
60461: ST_TO_ADDR
// end ;
60462: LD_VAR 0 2
60466: RET
// export function MC_Add ( side , units ) ; var base ; begin
60467: LD_INT 0
60469: PPUSH
60470: PPUSH
// base := mc_bases + 1 ;
60471: LD_ADDR_VAR 0 4
60475: PUSH
60476: LD_EXP 62
60480: PUSH
60481: LD_INT 1
60483: PLUS
60484: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
60485: LD_ADDR_EXP 88
60489: PUSH
60490: LD_EXP 88
60494: PPUSH
60495: LD_VAR 0 4
60499: PPUSH
60500: LD_VAR 0 1
60504: PPUSH
60505: CALL_OW 1
60509: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
60510: LD_ADDR_EXP 62
60514: PUSH
60515: LD_EXP 62
60519: PPUSH
60520: LD_VAR 0 4
60524: PPUSH
60525: LD_VAR 0 2
60529: PPUSH
60530: CALL_OW 1
60534: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
60535: LD_ADDR_EXP 63
60539: PUSH
60540: LD_EXP 63
60544: PPUSH
60545: LD_VAR 0 4
60549: PPUSH
60550: EMPTY
60551: PPUSH
60552: CALL_OW 1
60556: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
60557: LD_ADDR_EXP 64
60561: PUSH
60562: LD_EXP 64
60566: PPUSH
60567: LD_VAR 0 4
60571: PPUSH
60572: EMPTY
60573: PPUSH
60574: CALL_OW 1
60578: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
60579: LD_ADDR_EXP 65
60583: PUSH
60584: LD_EXP 65
60588: PPUSH
60589: LD_VAR 0 4
60593: PPUSH
60594: EMPTY
60595: PPUSH
60596: CALL_OW 1
60600: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
60601: LD_ADDR_EXP 66
60605: PUSH
60606: LD_EXP 66
60610: PPUSH
60611: LD_VAR 0 4
60615: PPUSH
60616: EMPTY
60617: PPUSH
60618: CALL_OW 1
60622: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
60623: LD_ADDR_EXP 67
60627: PUSH
60628: LD_EXP 67
60632: PPUSH
60633: LD_VAR 0 4
60637: PPUSH
60638: EMPTY
60639: PPUSH
60640: CALL_OW 1
60644: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
60645: LD_ADDR_EXP 68
60649: PUSH
60650: LD_EXP 68
60654: PPUSH
60655: LD_VAR 0 4
60659: PPUSH
60660: EMPTY
60661: PPUSH
60662: CALL_OW 1
60666: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
60667: LD_ADDR_EXP 69
60671: PUSH
60672: LD_EXP 69
60676: PPUSH
60677: LD_VAR 0 4
60681: PPUSH
60682: EMPTY
60683: PPUSH
60684: CALL_OW 1
60688: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
60689: LD_ADDR_EXP 70
60693: PUSH
60694: LD_EXP 70
60698: PPUSH
60699: LD_VAR 0 4
60703: PPUSH
60704: EMPTY
60705: PPUSH
60706: CALL_OW 1
60710: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
60711: LD_ADDR_EXP 71
60715: PUSH
60716: LD_EXP 71
60720: PPUSH
60721: LD_VAR 0 4
60725: PPUSH
60726: EMPTY
60727: PPUSH
60728: CALL_OW 1
60732: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
60733: LD_ADDR_EXP 72
60737: PUSH
60738: LD_EXP 72
60742: PPUSH
60743: LD_VAR 0 4
60747: PPUSH
60748: EMPTY
60749: PPUSH
60750: CALL_OW 1
60754: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
60755: LD_ADDR_EXP 73
60759: PUSH
60760: LD_EXP 73
60764: PPUSH
60765: LD_VAR 0 4
60769: PPUSH
60770: LD_INT 0
60772: PPUSH
60773: CALL_OW 1
60777: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
60778: LD_ADDR_EXP 74
60782: PUSH
60783: LD_EXP 74
60787: PPUSH
60788: LD_VAR 0 4
60792: PPUSH
60793: EMPTY
60794: PPUSH
60795: CALL_OW 1
60799: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
60800: LD_ADDR_EXP 75
60804: PUSH
60805: LD_EXP 75
60809: PPUSH
60810: LD_VAR 0 4
60814: PPUSH
60815: EMPTY
60816: PPUSH
60817: CALL_OW 1
60821: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
60822: LD_ADDR_EXP 76
60826: PUSH
60827: LD_EXP 76
60831: PPUSH
60832: LD_VAR 0 4
60836: PPUSH
60837: EMPTY
60838: PPUSH
60839: CALL_OW 1
60843: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
60844: LD_ADDR_EXP 77
60848: PUSH
60849: LD_EXP 77
60853: PPUSH
60854: LD_VAR 0 4
60858: PPUSH
60859: EMPTY
60860: PPUSH
60861: CALL_OW 1
60865: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
60866: LD_ADDR_EXP 78
60870: PUSH
60871: LD_EXP 78
60875: PPUSH
60876: LD_VAR 0 4
60880: PPUSH
60881: EMPTY
60882: PPUSH
60883: CALL_OW 1
60887: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
60888: LD_ADDR_EXP 79
60892: PUSH
60893: LD_EXP 79
60897: PPUSH
60898: LD_VAR 0 4
60902: PPUSH
60903: EMPTY
60904: PPUSH
60905: CALL_OW 1
60909: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
60910: LD_ADDR_EXP 80
60914: PUSH
60915: LD_EXP 80
60919: PPUSH
60920: LD_VAR 0 4
60924: PPUSH
60925: EMPTY
60926: PPUSH
60927: CALL_OW 1
60931: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
60932: LD_ADDR_EXP 81
60936: PUSH
60937: LD_EXP 81
60941: PPUSH
60942: LD_VAR 0 4
60946: PPUSH
60947: EMPTY
60948: PPUSH
60949: CALL_OW 1
60953: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
60954: LD_ADDR_EXP 82
60958: PUSH
60959: LD_EXP 82
60963: PPUSH
60964: LD_VAR 0 4
60968: PPUSH
60969: EMPTY
60970: PPUSH
60971: CALL_OW 1
60975: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
60976: LD_ADDR_EXP 83
60980: PUSH
60981: LD_EXP 83
60985: PPUSH
60986: LD_VAR 0 4
60990: PPUSH
60991: EMPTY
60992: PPUSH
60993: CALL_OW 1
60997: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
60998: LD_ADDR_EXP 84
61002: PUSH
61003: LD_EXP 84
61007: PPUSH
61008: LD_VAR 0 4
61012: PPUSH
61013: EMPTY
61014: PPUSH
61015: CALL_OW 1
61019: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
61020: LD_ADDR_EXP 85
61024: PUSH
61025: LD_EXP 85
61029: PPUSH
61030: LD_VAR 0 4
61034: PPUSH
61035: EMPTY
61036: PPUSH
61037: CALL_OW 1
61041: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
61042: LD_ADDR_EXP 86
61046: PUSH
61047: LD_EXP 86
61051: PPUSH
61052: LD_VAR 0 4
61056: PPUSH
61057: EMPTY
61058: PPUSH
61059: CALL_OW 1
61063: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
61064: LD_ADDR_EXP 87
61068: PUSH
61069: LD_EXP 87
61073: PPUSH
61074: LD_VAR 0 4
61078: PPUSH
61079: EMPTY
61080: PPUSH
61081: CALL_OW 1
61085: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
61086: LD_ADDR_EXP 89
61090: PUSH
61091: LD_EXP 89
61095: PPUSH
61096: LD_VAR 0 4
61100: PPUSH
61101: EMPTY
61102: PPUSH
61103: CALL_OW 1
61107: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
61108: LD_ADDR_EXP 91
61112: PUSH
61113: LD_EXP 91
61117: PPUSH
61118: LD_VAR 0 4
61122: PPUSH
61123: EMPTY
61124: PPUSH
61125: CALL_OW 1
61129: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
61130: LD_ADDR_EXP 92
61134: PUSH
61135: LD_EXP 92
61139: PPUSH
61140: LD_VAR 0 4
61144: PPUSH
61145: EMPTY
61146: PPUSH
61147: CALL_OW 1
61151: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
61152: LD_ADDR_EXP 93
61156: PUSH
61157: LD_EXP 93
61161: PPUSH
61162: LD_VAR 0 4
61166: PPUSH
61167: EMPTY
61168: PPUSH
61169: CALL_OW 1
61173: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
61174: LD_ADDR_EXP 94
61178: PUSH
61179: LD_EXP 94
61183: PPUSH
61184: LD_VAR 0 4
61188: PPUSH
61189: EMPTY
61190: PPUSH
61191: CALL_OW 1
61195: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
61196: LD_ADDR_EXP 95
61200: PUSH
61201: LD_EXP 95
61205: PPUSH
61206: LD_VAR 0 4
61210: PPUSH
61211: EMPTY
61212: PPUSH
61213: CALL_OW 1
61217: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
61218: LD_ADDR_EXP 96
61222: PUSH
61223: LD_EXP 96
61227: PPUSH
61228: LD_VAR 0 4
61232: PPUSH
61233: EMPTY
61234: PPUSH
61235: CALL_OW 1
61239: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
61240: LD_ADDR_EXP 97
61244: PUSH
61245: LD_EXP 97
61249: PPUSH
61250: LD_VAR 0 4
61254: PPUSH
61255: EMPTY
61256: PPUSH
61257: CALL_OW 1
61261: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
61262: LD_ADDR_EXP 98
61266: PUSH
61267: LD_EXP 98
61271: PPUSH
61272: LD_VAR 0 4
61276: PPUSH
61277: EMPTY
61278: PPUSH
61279: CALL_OW 1
61283: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
61284: LD_ADDR_EXP 99
61288: PUSH
61289: LD_EXP 99
61293: PPUSH
61294: LD_VAR 0 4
61298: PPUSH
61299: EMPTY
61300: PPUSH
61301: CALL_OW 1
61305: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
61306: LD_ADDR_EXP 100
61310: PUSH
61311: LD_EXP 100
61315: PPUSH
61316: LD_VAR 0 4
61320: PPUSH
61321: EMPTY
61322: PPUSH
61323: CALL_OW 1
61327: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
61328: LD_ADDR_EXP 101
61332: PUSH
61333: LD_EXP 101
61337: PPUSH
61338: LD_VAR 0 4
61342: PPUSH
61343: EMPTY
61344: PPUSH
61345: CALL_OW 1
61349: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
61350: LD_ADDR_EXP 102
61354: PUSH
61355: LD_EXP 102
61359: PPUSH
61360: LD_VAR 0 4
61364: PPUSH
61365: EMPTY
61366: PPUSH
61367: CALL_OW 1
61371: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
61372: LD_ADDR_EXP 103
61376: PUSH
61377: LD_EXP 103
61381: PPUSH
61382: LD_VAR 0 4
61386: PPUSH
61387: EMPTY
61388: PPUSH
61389: CALL_OW 1
61393: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
61394: LD_ADDR_EXP 104
61398: PUSH
61399: LD_EXP 104
61403: PPUSH
61404: LD_VAR 0 4
61408: PPUSH
61409: LD_INT 0
61411: PPUSH
61412: CALL_OW 1
61416: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
61417: LD_ADDR_EXP 105
61421: PUSH
61422: LD_EXP 105
61426: PPUSH
61427: LD_VAR 0 4
61431: PPUSH
61432: LD_INT 0
61434: PPUSH
61435: CALL_OW 1
61439: ST_TO_ADDR
// result := base ;
61440: LD_ADDR_VAR 0 3
61444: PUSH
61445: LD_VAR 0 4
61449: ST_TO_ADDR
// end ;
61450: LD_VAR 0 3
61454: RET
// export function MC_Start ( ) ; var i ; begin
61455: LD_INT 0
61457: PPUSH
61458: PPUSH
// for i = 1 to mc_bases do
61459: LD_ADDR_VAR 0 2
61463: PUSH
61464: DOUBLE
61465: LD_INT 1
61467: DEC
61468: ST_TO_ADDR
61469: LD_EXP 62
61473: PUSH
61474: FOR_TO
61475: IFFALSE 62575
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
61477: LD_ADDR_EXP 62
61481: PUSH
61482: LD_EXP 62
61486: PPUSH
61487: LD_VAR 0 2
61491: PPUSH
61492: LD_EXP 62
61496: PUSH
61497: LD_VAR 0 2
61501: ARRAY
61502: PUSH
61503: LD_INT 0
61505: DIFF
61506: PPUSH
61507: CALL_OW 1
61511: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
61512: LD_ADDR_EXP 63
61516: PUSH
61517: LD_EXP 63
61521: PPUSH
61522: LD_VAR 0 2
61526: PPUSH
61527: EMPTY
61528: PPUSH
61529: CALL_OW 1
61533: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61534: LD_ADDR_EXP 64
61538: PUSH
61539: LD_EXP 64
61543: PPUSH
61544: LD_VAR 0 2
61548: PPUSH
61549: EMPTY
61550: PPUSH
61551: CALL_OW 1
61555: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
61556: LD_ADDR_EXP 65
61560: PUSH
61561: LD_EXP 65
61565: PPUSH
61566: LD_VAR 0 2
61570: PPUSH
61571: EMPTY
61572: PPUSH
61573: CALL_OW 1
61577: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
61578: LD_ADDR_EXP 66
61582: PUSH
61583: LD_EXP 66
61587: PPUSH
61588: LD_VAR 0 2
61592: PPUSH
61593: EMPTY
61594: PUSH
61595: EMPTY
61596: PUSH
61597: EMPTY
61598: LIST
61599: LIST
61600: PPUSH
61601: CALL_OW 1
61605: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
61606: LD_ADDR_EXP 67
61610: PUSH
61611: LD_EXP 67
61615: PPUSH
61616: LD_VAR 0 2
61620: PPUSH
61621: EMPTY
61622: PPUSH
61623: CALL_OW 1
61627: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
61628: LD_ADDR_EXP 94
61632: PUSH
61633: LD_EXP 94
61637: PPUSH
61638: LD_VAR 0 2
61642: PPUSH
61643: EMPTY
61644: PPUSH
61645: CALL_OW 1
61649: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
61650: LD_ADDR_EXP 68
61654: PUSH
61655: LD_EXP 68
61659: PPUSH
61660: LD_VAR 0 2
61664: PPUSH
61665: EMPTY
61666: PPUSH
61667: CALL_OW 1
61671: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
61672: LD_ADDR_EXP 69
61676: PUSH
61677: LD_EXP 69
61681: PPUSH
61682: LD_VAR 0 2
61686: PPUSH
61687: EMPTY
61688: PPUSH
61689: CALL_OW 1
61693: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
61694: LD_ADDR_EXP 70
61698: PUSH
61699: LD_EXP 70
61703: PPUSH
61704: LD_VAR 0 2
61708: PPUSH
61709: LD_EXP 62
61713: PUSH
61714: LD_VAR 0 2
61718: ARRAY
61719: PPUSH
61720: LD_INT 2
61722: PUSH
61723: LD_INT 30
61725: PUSH
61726: LD_INT 32
61728: PUSH
61729: EMPTY
61730: LIST
61731: LIST
61732: PUSH
61733: LD_INT 30
61735: PUSH
61736: LD_INT 33
61738: PUSH
61739: EMPTY
61740: LIST
61741: LIST
61742: PUSH
61743: EMPTY
61744: LIST
61745: LIST
61746: LIST
61747: PPUSH
61748: CALL_OW 72
61752: PPUSH
61753: CALL_OW 1
61757: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
61758: LD_ADDR_EXP 71
61762: PUSH
61763: LD_EXP 71
61767: PPUSH
61768: LD_VAR 0 2
61772: PPUSH
61773: LD_EXP 62
61777: PUSH
61778: LD_VAR 0 2
61782: ARRAY
61783: PPUSH
61784: LD_INT 2
61786: PUSH
61787: LD_INT 30
61789: PUSH
61790: LD_INT 32
61792: PUSH
61793: EMPTY
61794: LIST
61795: LIST
61796: PUSH
61797: LD_INT 30
61799: PUSH
61800: LD_INT 31
61802: PUSH
61803: EMPTY
61804: LIST
61805: LIST
61806: PUSH
61807: EMPTY
61808: LIST
61809: LIST
61810: LIST
61811: PUSH
61812: LD_INT 58
61814: PUSH
61815: EMPTY
61816: LIST
61817: PUSH
61818: EMPTY
61819: LIST
61820: LIST
61821: PPUSH
61822: CALL_OW 72
61826: PPUSH
61827: CALL_OW 1
61831: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
61832: LD_ADDR_EXP 72
61836: PUSH
61837: LD_EXP 72
61841: PPUSH
61842: LD_VAR 0 2
61846: PPUSH
61847: EMPTY
61848: PPUSH
61849: CALL_OW 1
61853: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
61854: LD_ADDR_EXP 76
61858: PUSH
61859: LD_EXP 76
61863: PPUSH
61864: LD_VAR 0 2
61868: PPUSH
61869: EMPTY
61870: PPUSH
61871: CALL_OW 1
61875: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
61876: LD_ADDR_EXP 75
61880: PUSH
61881: LD_EXP 75
61885: PPUSH
61886: LD_VAR 0 2
61890: PPUSH
61891: EMPTY
61892: PPUSH
61893: CALL_OW 1
61897: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
61898: LD_ADDR_EXP 77
61902: PUSH
61903: LD_EXP 77
61907: PPUSH
61908: LD_VAR 0 2
61912: PPUSH
61913: EMPTY
61914: PPUSH
61915: CALL_OW 1
61919: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
61920: LD_ADDR_EXP 78
61924: PUSH
61925: LD_EXP 78
61929: PPUSH
61930: LD_VAR 0 2
61934: PPUSH
61935: EMPTY
61936: PPUSH
61937: CALL_OW 1
61941: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
61942: LD_ADDR_EXP 79
61946: PUSH
61947: LD_EXP 79
61951: PPUSH
61952: LD_VAR 0 2
61956: PPUSH
61957: EMPTY
61958: PPUSH
61959: CALL_OW 1
61963: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
61964: LD_ADDR_EXP 80
61968: PUSH
61969: LD_EXP 80
61973: PPUSH
61974: LD_VAR 0 2
61978: PPUSH
61979: EMPTY
61980: PPUSH
61981: CALL_OW 1
61985: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
61986: LD_ADDR_EXP 81
61990: PUSH
61991: LD_EXP 81
61995: PPUSH
61996: LD_VAR 0 2
62000: PPUSH
62001: EMPTY
62002: PPUSH
62003: CALL_OW 1
62007: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
62008: LD_ADDR_EXP 82
62012: PUSH
62013: LD_EXP 82
62017: PPUSH
62018: LD_VAR 0 2
62022: PPUSH
62023: EMPTY
62024: PPUSH
62025: CALL_OW 1
62029: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
62030: LD_ADDR_EXP 83
62034: PUSH
62035: LD_EXP 83
62039: PPUSH
62040: LD_VAR 0 2
62044: PPUSH
62045: EMPTY
62046: PPUSH
62047: CALL_OW 1
62051: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
62052: LD_ADDR_EXP 84
62056: PUSH
62057: LD_EXP 84
62061: PPUSH
62062: LD_VAR 0 2
62066: PPUSH
62067: EMPTY
62068: PPUSH
62069: CALL_OW 1
62073: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
62074: LD_ADDR_EXP 73
62078: PUSH
62079: LD_EXP 73
62083: PPUSH
62084: LD_VAR 0 2
62088: PPUSH
62089: LD_INT 0
62091: PPUSH
62092: CALL_OW 1
62096: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
62097: LD_ADDR_EXP 86
62101: PUSH
62102: LD_EXP 86
62106: PPUSH
62107: LD_VAR 0 2
62111: PPUSH
62112: LD_INT 0
62114: PPUSH
62115: CALL_OW 1
62119: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
62120: LD_ADDR_EXP 74
62124: PUSH
62125: LD_EXP 74
62129: PPUSH
62130: LD_VAR 0 2
62134: PPUSH
62135: EMPTY
62136: PPUSH
62137: CALL_OW 1
62141: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
62142: LD_ADDR_EXP 85
62146: PUSH
62147: LD_EXP 85
62151: PPUSH
62152: LD_VAR 0 2
62156: PPUSH
62157: LD_INT 0
62159: PPUSH
62160: CALL_OW 1
62164: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
62165: LD_ADDR_EXP 87
62169: PUSH
62170: LD_EXP 87
62174: PPUSH
62175: LD_VAR 0 2
62179: PPUSH
62180: EMPTY
62181: PPUSH
62182: CALL_OW 1
62186: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
62187: LD_ADDR_EXP 90
62191: PUSH
62192: LD_EXP 90
62196: PPUSH
62197: LD_VAR 0 2
62201: PPUSH
62202: LD_INT 0
62204: PPUSH
62205: CALL_OW 1
62209: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
62210: LD_ADDR_EXP 91
62214: PUSH
62215: LD_EXP 91
62219: PPUSH
62220: LD_VAR 0 2
62224: PPUSH
62225: EMPTY
62226: PPUSH
62227: CALL_OW 1
62231: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62232: LD_ADDR_EXP 92
62236: PUSH
62237: LD_EXP 92
62241: PPUSH
62242: LD_VAR 0 2
62246: PPUSH
62247: EMPTY
62248: PPUSH
62249: CALL_OW 1
62253: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62254: LD_ADDR_EXP 93
62258: PUSH
62259: LD_EXP 93
62263: PPUSH
62264: LD_VAR 0 2
62268: PPUSH
62269: EMPTY
62270: PPUSH
62271: CALL_OW 1
62275: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
62276: LD_ADDR_EXP 95
62280: PUSH
62281: LD_EXP 95
62285: PPUSH
62286: LD_VAR 0 2
62290: PPUSH
62291: LD_EXP 62
62295: PUSH
62296: LD_VAR 0 2
62300: ARRAY
62301: PPUSH
62302: LD_INT 2
62304: PUSH
62305: LD_INT 30
62307: PUSH
62308: LD_INT 6
62310: PUSH
62311: EMPTY
62312: LIST
62313: LIST
62314: PUSH
62315: LD_INT 30
62317: PUSH
62318: LD_INT 7
62320: PUSH
62321: EMPTY
62322: LIST
62323: LIST
62324: PUSH
62325: LD_INT 30
62327: PUSH
62328: LD_INT 8
62330: PUSH
62331: EMPTY
62332: LIST
62333: LIST
62334: PUSH
62335: EMPTY
62336: LIST
62337: LIST
62338: LIST
62339: LIST
62340: PPUSH
62341: CALL_OW 72
62345: PPUSH
62346: CALL_OW 1
62350: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
62351: LD_ADDR_EXP 96
62355: PUSH
62356: LD_EXP 96
62360: PPUSH
62361: LD_VAR 0 2
62365: PPUSH
62366: EMPTY
62367: PPUSH
62368: CALL_OW 1
62372: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
62373: LD_ADDR_EXP 97
62377: PUSH
62378: LD_EXP 97
62382: PPUSH
62383: LD_VAR 0 2
62387: PPUSH
62388: EMPTY
62389: PPUSH
62390: CALL_OW 1
62394: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
62395: LD_ADDR_EXP 98
62399: PUSH
62400: LD_EXP 98
62404: PPUSH
62405: LD_VAR 0 2
62409: PPUSH
62410: EMPTY
62411: PPUSH
62412: CALL_OW 1
62416: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
62417: LD_ADDR_EXP 99
62421: PUSH
62422: LD_EXP 99
62426: PPUSH
62427: LD_VAR 0 2
62431: PPUSH
62432: EMPTY
62433: PPUSH
62434: CALL_OW 1
62438: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
62439: LD_ADDR_EXP 100
62443: PUSH
62444: LD_EXP 100
62448: PPUSH
62449: LD_VAR 0 2
62453: PPUSH
62454: EMPTY
62455: PPUSH
62456: CALL_OW 1
62460: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
62461: LD_ADDR_EXP 101
62465: PUSH
62466: LD_EXP 101
62470: PPUSH
62471: LD_VAR 0 2
62475: PPUSH
62476: EMPTY
62477: PPUSH
62478: CALL_OW 1
62482: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
62483: LD_ADDR_EXP 102
62487: PUSH
62488: LD_EXP 102
62492: PPUSH
62493: LD_VAR 0 2
62497: PPUSH
62498: EMPTY
62499: PPUSH
62500: CALL_OW 1
62504: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
62505: LD_ADDR_EXP 103
62509: PUSH
62510: LD_EXP 103
62514: PPUSH
62515: LD_VAR 0 2
62519: PPUSH
62520: EMPTY
62521: PPUSH
62522: CALL_OW 1
62526: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
62527: LD_ADDR_EXP 104
62531: PUSH
62532: LD_EXP 104
62536: PPUSH
62537: LD_VAR 0 2
62541: PPUSH
62542: LD_INT 0
62544: PPUSH
62545: CALL_OW 1
62549: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
62550: LD_ADDR_EXP 105
62554: PUSH
62555: LD_EXP 105
62559: PPUSH
62560: LD_VAR 0 2
62564: PPUSH
62565: LD_INT 0
62567: PPUSH
62568: CALL_OW 1
62572: ST_TO_ADDR
// end ;
62573: GO 61474
62575: POP
62576: POP
// MC_InitSides ( ) ;
62577: CALL 62863 0 0
// MC_InitResearch ( ) ;
62581: CALL 62602 0 0
// CustomInitMacro ( ) ;
62585: CALL 219 0 0
// skirmish := true ;
62589: LD_ADDR_EXP 60
62593: PUSH
62594: LD_INT 1
62596: ST_TO_ADDR
// end ;
62597: LD_VAR 0 1
62601: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
62602: LD_INT 0
62604: PPUSH
62605: PPUSH
62606: PPUSH
62607: PPUSH
62608: PPUSH
62609: PPUSH
// if not mc_bases then
62610: LD_EXP 62
62614: NOT
62615: IFFALSE 62619
// exit ;
62617: GO 62858
// for i = 1 to 8 do
62619: LD_ADDR_VAR 0 2
62623: PUSH
62624: DOUBLE
62625: LD_INT 1
62627: DEC
62628: ST_TO_ADDR
62629: LD_INT 8
62631: PUSH
62632: FOR_TO
62633: IFFALSE 62659
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
62635: LD_ADDR_EXP 89
62639: PUSH
62640: LD_EXP 89
62644: PPUSH
62645: LD_VAR 0 2
62649: PPUSH
62650: EMPTY
62651: PPUSH
62652: CALL_OW 1
62656: ST_TO_ADDR
62657: GO 62632
62659: POP
62660: POP
// tmp := [ ] ;
62661: LD_ADDR_VAR 0 5
62665: PUSH
62666: EMPTY
62667: ST_TO_ADDR
// for i = 1 to mc_sides do
62668: LD_ADDR_VAR 0 2
62672: PUSH
62673: DOUBLE
62674: LD_INT 1
62676: DEC
62677: ST_TO_ADDR
62678: LD_EXP 88
62682: PUSH
62683: FOR_TO
62684: IFFALSE 62742
// if not mc_sides [ i ] in tmp then
62686: LD_EXP 88
62690: PUSH
62691: LD_VAR 0 2
62695: ARRAY
62696: PUSH
62697: LD_VAR 0 5
62701: IN
62702: NOT
62703: IFFALSE 62740
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
62705: LD_ADDR_VAR 0 5
62709: PUSH
62710: LD_VAR 0 5
62714: PPUSH
62715: LD_VAR 0 5
62719: PUSH
62720: LD_INT 1
62722: PLUS
62723: PPUSH
62724: LD_EXP 88
62728: PUSH
62729: LD_VAR 0 2
62733: ARRAY
62734: PPUSH
62735: CALL_OW 2
62739: ST_TO_ADDR
62740: GO 62683
62742: POP
62743: POP
// if not tmp then
62744: LD_VAR 0 5
62748: NOT
62749: IFFALSE 62753
// exit ;
62751: GO 62858
// for j in tmp do
62753: LD_ADDR_VAR 0 3
62757: PUSH
62758: LD_VAR 0 5
62762: PUSH
62763: FOR_IN
62764: IFFALSE 62856
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
62766: LD_ADDR_VAR 0 6
62770: PUSH
62771: LD_INT 22
62773: PUSH
62774: LD_VAR 0 3
62778: PUSH
62779: EMPTY
62780: LIST
62781: LIST
62782: PPUSH
62783: CALL_OW 69
62787: ST_TO_ADDR
// if not un then
62788: LD_VAR 0 6
62792: NOT
62793: IFFALSE 62797
// continue ;
62795: GO 62763
// nation := GetNation ( un [ 1 ] ) ;
62797: LD_ADDR_VAR 0 4
62801: PUSH
62802: LD_VAR 0 6
62806: PUSH
62807: LD_INT 1
62809: ARRAY
62810: PPUSH
62811: CALL_OW 248
62815: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
62816: LD_ADDR_EXP 89
62820: PUSH
62821: LD_EXP 89
62825: PPUSH
62826: LD_VAR 0 3
62830: PPUSH
62831: LD_VAR 0 3
62835: PPUSH
62836: LD_VAR 0 4
62840: PPUSH
62841: LD_INT 1
62843: PPUSH
62844: CALL 16563 0 3
62848: PPUSH
62849: CALL_OW 1
62853: ST_TO_ADDR
// end ;
62854: GO 62763
62856: POP
62857: POP
// end ;
62858: LD_VAR 0 1
62862: RET
// export function MC_InitSides ( ) ; var i ; begin
62863: LD_INT 0
62865: PPUSH
62866: PPUSH
// if not mc_bases then
62867: LD_EXP 62
62871: NOT
62872: IFFALSE 62876
// exit ;
62874: GO 62950
// for i = 1 to mc_bases do
62876: LD_ADDR_VAR 0 2
62880: PUSH
62881: DOUBLE
62882: LD_INT 1
62884: DEC
62885: ST_TO_ADDR
62886: LD_EXP 62
62890: PUSH
62891: FOR_TO
62892: IFFALSE 62948
// if mc_bases [ i ] then
62894: LD_EXP 62
62898: PUSH
62899: LD_VAR 0 2
62903: ARRAY
62904: IFFALSE 62946
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
62906: LD_ADDR_EXP 88
62910: PUSH
62911: LD_EXP 88
62915: PPUSH
62916: LD_VAR 0 2
62920: PPUSH
62921: LD_EXP 62
62925: PUSH
62926: LD_VAR 0 2
62930: ARRAY
62931: PUSH
62932: LD_INT 1
62934: ARRAY
62935: PPUSH
62936: CALL_OW 255
62940: PPUSH
62941: CALL_OW 1
62945: ST_TO_ADDR
62946: GO 62891
62948: POP
62949: POP
// end ;
62950: LD_VAR 0 1
62954: RET
// every 0 0$03 trigger skirmish do
62955: LD_EXP 60
62959: IFFALSE 63113
62961: GO 62963
62963: DISABLE
// begin enable ;
62964: ENABLE
// MC_CheckBuildings ( ) ;
62965: CALL 67625 0 0
// MC_CheckPeopleLife ( ) ;
62969: CALL 67786 0 0
// RaiseSailEvent ( 100 ) ;
62973: LD_INT 100
62975: PPUSH
62976: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
62980: LD_INT 103
62982: PPUSH
62983: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
62987: LD_INT 104
62989: PPUSH
62990: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
62994: LD_INT 105
62996: PPUSH
62997: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
63001: LD_INT 106
63003: PPUSH
63004: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
63008: LD_INT 107
63010: PPUSH
63011: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
63015: LD_INT 108
63017: PPUSH
63018: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
63022: LD_INT 109
63024: PPUSH
63025: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
63029: LD_INT 110
63031: PPUSH
63032: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
63036: LD_INT 111
63038: PPUSH
63039: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
63043: LD_INT 112
63045: PPUSH
63046: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
63050: LD_INT 113
63052: PPUSH
63053: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
63057: LD_INT 120
63059: PPUSH
63060: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
63064: LD_INT 121
63066: PPUSH
63067: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
63071: LD_INT 122
63073: PPUSH
63074: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
63078: LD_INT 123
63080: PPUSH
63081: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
63085: LD_INT 124
63087: PPUSH
63088: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
63092: LD_INT 125
63094: PPUSH
63095: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
63099: LD_INT 126
63101: PPUSH
63102: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
63106: LD_INT 200
63108: PPUSH
63109: CALL_OW 427
// end ;
63113: END
// on SailEvent ( event ) do begin if event < 100 then
63114: LD_VAR 0 1
63118: PUSH
63119: LD_INT 100
63121: LESS
63122: IFFALSE 63133
// CustomEvent ( event ) ;
63124: LD_VAR 0 1
63128: PPUSH
63129: CALL 15148 0 1
// if event = 100 then
63133: LD_VAR 0 1
63137: PUSH
63138: LD_INT 100
63140: EQUAL
63141: IFFALSE 63147
// MC_ClassManager ( ) ;
63143: CALL 63539 0 0
// if event = 101 then
63147: LD_VAR 0 1
63151: PUSH
63152: LD_INT 101
63154: EQUAL
63155: IFFALSE 63161
// MC_RepairBuildings ( ) ;
63157: CALL 68371 0 0
// if event = 102 then
63161: LD_VAR 0 1
63165: PUSH
63166: LD_INT 102
63168: EQUAL
63169: IFFALSE 63175
// MC_Heal ( ) ;
63171: CALL 69306 0 0
// if event = 103 then
63175: LD_VAR 0 1
63179: PUSH
63180: LD_INT 103
63182: EQUAL
63183: IFFALSE 63189
// MC_Build ( ) ;
63185: CALL 69728 0 0
// if event = 104 then
63189: LD_VAR 0 1
63193: PUSH
63194: LD_INT 104
63196: EQUAL
63197: IFFALSE 63203
// MC_TurretWeapon ( ) ;
63199: CALL 71362 0 0
// if event = 105 then
63203: LD_VAR 0 1
63207: PUSH
63208: LD_INT 105
63210: EQUAL
63211: IFFALSE 63217
// MC_BuildUpgrade ( ) ;
63213: CALL 70913 0 0
// if event = 106 then
63217: LD_VAR 0 1
63221: PUSH
63222: LD_INT 106
63224: EQUAL
63225: IFFALSE 63231
// MC_PlantMines ( ) ;
63227: CALL 71792 0 0
// if event = 107 then
63231: LD_VAR 0 1
63235: PUSH
63236: LD_INT 107
63238: EQUAL
63239: IFFALSE 63245
// MC_CollectCrates ( ) ;
63241: CALL 72590 0 0
// if event = 108 then
63245: LD_VAR 0 1
63249: PUSH
63250: LD_INT 108
63252: EQUAL
63253: IFFALSE 63259
// MC_LinkRemoteControl ( ) ;
63255: CALL 74440 0 0
// if event = 109 then
63259: LD_VAR 0 1
63263: PUSH
63264: LD_INT 109
63266: EQUAL
63267: IFFALSE 63273
// MC_ProduceVehicle ( ) ;
63269: CALL 74621 0 0
// if event = 110 then
63273: LD_VAR 0 1
63277: PUSH
63278: LD_INT 110
63280: EQUAL
63281: IFFALSE 63287
// MC_SendAttack ( ) ;
63283: CALL 75087 0 0
// if event = 111 then
63287: LD_VAR 0 1
63291: PUSH
63292: LD_INT 111
63294: EQUAL
63295: IFFALSE 63301
// MC_Defend ( ) ;
63297: CALL 75195 0 0
// if event = 112 then
63301: LD_VAR 0 1
63305: PUSH
63306: LD_INT 112
63308: EQUAL
63309: IFFALSE 63315
// MC_Research ( ) ;
63311: CALL 76075 0 0
// if event = 113 then
63315: LD_VAR 0 1
63319: PUSH
63320: LD_INT 113
63322: EQUAL
63323: IFFALSE 63329
// MC_MinesTrigger ( ) ;
63325: CALL 77189 0 0
// if event = 120 then
63329: LD_VAR 0 1
63333: PUSH
63334: LD_INT 120
63336: EQUAL
63337: IFFALSE 63343
// MC_RepairVehicle ( ) ;
63339: CALL 77288 0 0
// if event = 121 then
63343: LD_VAR 0 1
63347: PUSH
63348: LD_INT 121
63350: EQUAL
63351: IFFALSE 63357
// MC_TameApe ( ) ;
63353: CALL 78057 0 0
// if event = 122 then
63357: LD_VAR 0 1
63361: PUSH
63362: LD_INT 122
63364: EQUAL
63365: IFFALSE 63371
// MC_ChangeApeClass ( ) ;
63367: CALL 78886 0 0
// if event = 123 then
63371: LD_VAR 0 1
63375: PUSH
63376: LD_INT 123
63378: EQUAL
63379: IFFALSE 63385
// MC_Bazooka ( ) ;
63381: CALL 79536 0 0
// if event = 124 then
63385: LD_VAR 0 1
63389: PUSH
63390: LD_INT 124
63392: EQUAL
63393: IFFALSE 63399
// MC_TeleportExit ( ) ;
63395: CALL 79734 0 0
// if event = 125 then
63399: LD_VAR 0 1
63403: PUSH
63404: LD_INT 125
63406: EQUAL
63407: IFFALSE 63413
// MC_Deposits ( ) ;
63409: CALL 80381 0 0
// if event = 126 then
63413: LD_VAR 0 1
63417: PUSH
63418: LD_INT 126
63420: EQUAL
63421: IFFALSE 63427
// MC_RemoteDriver ( ) ;
63423: CALL 81006 0 0
// if event = 200 then
63427: LD_VAR 0 1
63431: PUSH
63432: LD_INT 200
63434: EQUAL
63435: IFFALSE 63441
// MC_Idle ( ) ;
63437: CALL 82913 0 0
// end ;
63441: PPOPN 1
63443: END
// export function MC_Reset ( base , tag ) ; var i ; begin
63444: LD_INT 0
63446: PPUSH
63447: PPUSH
// if not mc_bases [ base ] or not tag then
63448: LD_EXP 62
63452: PUSH
63453: LD_VAR 0 1
63457: ARRAY
63458: NOT
63459: PUSH
63460: LD_VAR 0 2
63464: NOT
63465: OR
63466: IFFALSE 63470
// exit ;
63468: GO 63534
// for i in mc_bases [ base ] union mc_ape [ base ] do
63470: LD_ADDR_VAR 0 4
63474: PUSH
63475: LD_EXP 62
63479: PUSH
63480: LD_VAR 0 1
63484: ARRAY
63485: PUSH
63486: LD_EXP 91
63490: PUSH
63491: LD_VAR 0 1
63495: ARRAY
63496: UNION
63497: PUSH
63498: FOR_IN
63499: IFFALSE 63532
// if GetTag ( i ) = tag then
63501: LD_VAR 0 4
63505: PPUSH
63506: CALL_OW 110
63510: PUSH
63511: LD_VAR 0 2
63515: EQUAL
63516: IFFALSE 63530
// SetTag ( i , 0 ) ;
63518: LD_VAR 0 4
63522: PPUSH
63523: LD_INT 0
63525: PPUSH
63526: CALL_OW 109
63530: GO 63498
63532: POP
63533: POP
// end ;
63534: LD_VAR 0 3
63538: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
63539: LD_INT 0
63541: PPUSH
63542: PPUSH
63543: PPUSH
63544: PPUSH
63545: PPUSH
63546: PPUSH
63547: PPUSH
63548: PPUSH
// if not mc_bases then
63549: LD_EXP 62
63553: NOT
63554: IFFALSE 63558
// exit ;
63556: GO 64007
// for i = 1 to mc_bases do
63558: LD_ADDR_VAR 0 2
63562: PUSH
63563: DOUBLE
63564: LD_INT 1
63566: DEC
63567: ST_TO_ADDR
63568: LD_EXP 62
63572: PUSH
63573: FOR_TO
63574: IFFALSE 64005
// begin tmp := MC_ClassCheckReq ( i ) ;
63576: LD_ADDR_VAR 0 4
63580: PUSH
63581: LD_VAR 0 2
63585: PPUSH
63586: CALL 64012 0 1
63590: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
63591: LD_ADDR_EXP 103
63595: PUSH
63596: LD_EXP 103
63600: PPUSH
63601: LD_VAR 0 2
63605: PPUSH
63606: LD_VAR 0 4
63610: PPUSH
63611: CALL_OW 1
63615: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
63616: LD_ADDR_VAR 0 6
63620: PUSH
63621: LD_EXP 62
63625: PUSH
63626: LD_VAR 0 2
63630: ARRAY
63631: PPUSH
63632: LD_INT 2
63634: PUSH
63635: LD_INT 30
63637: PUSH
63638: LD_INT 4
63640: PUSH
63641: EMPTY
63642: LIST
63643: LIST
63644: PUSH
63645: LD_INT 30
63647: PUSH
63648: LD_INT 5
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: PUSH
63655: EMPTY
63656: LIST
63657: LIST
63658: LIST
63659: PPUSH
63660: CALL_OW 72
63664: PUSH
63665: LD_EXP 62
63669: PUSH
63670: LD_VAR 0 2
63674: ARRAY
63675: PPUSH
63676: LD_INT 2
63678: PUSH
63679: LD_INT 30
63681: PUSH
63682: LD_INT 0
63684: PUSH
63685: EMPTY
63686: LIST
63687: LIST
63688: PUSH
63689: LD_INT 30
63691: PUSH
63692: LD_INT 1
63694: PUSH
63695: EMPTY
63696: LIST
63697: LIST
63698: PUSH
63699: EMPTY
63700: LIST
63701: LIST
63702: LIST
63703: PPUSH
63704: CALL_OW 72
63708: PUSH
63709: LD_EXP 62
63713: PUSH
63714: LD_VAR 0 2
63718: ARRAY
63719: PPUSH
63720: LD_INT 30
63722: PUSH
63723: LD_INT 3
63725: PUSH
63726: EMPTY
63727: LIST
63728: LIST
63729: PPUSH
63730: CALL_OW 72
63734: PUSH
63735: LD_EXP 62
63739: PUSH
63740: LD_VAR 0 2
63744: ARRAY
63745: PPUSH
63746: LD_INT 2
63748: PUSH
63749: LD_INT 30
63751: PUSH
63752: LD_INT 6
63754: PUSH
63755: EMPTY
63756: LIST
63757: LIST
63758: PUSH
63759: LD_INT 30
63761: PUSH
63762: LD_INT 7
63764: PUSH
63765: EMPTY
63766: LIST
63767: LIST
63768: PUSH
63769: LD_INT 30
63771: PUSH
63772: LD_INT 8
63774: PUSH
63775: EMPTY
63776: LIST
63777: LIST
63778: PUSH
63779: EMPTY
63780: LIST
63781: LIST
63782: LIST
63783: LIST
63784: PPUSH
63785: CALL_OW 72
63789: PUSH
63790: EMPTY
63791: LIST
63792: LIST
63793: LIST
63794: LIST
63795: ST_TO_ADDR
// for j := 1 to 4 do
63796: LD_ADDR_VAR 0 3
63800: PUSH
63801: DOUBLE
63802: LD_INT 1
63804: DEC
63805: ST_TO_ADDR
63806: LD_INT 4
63808: PUSH
63809: FOR_TO
63810: IFFALSE 64001
// begin if not tmp [ j ] then
63812: LD_VAR 0 4
63816: PUSH
63817: LD_VAR 0 3
63821: ARRAY
63822: NOT
63823: IFFALSE 63827
// continue ;
63825: GO 63809
// for p in tmp [ j ] do
63827: LD_ADDR_VAR 0 5
63831: PUSH
63832: LD_VAR 0 4
63836: PUSH
63837: LD_VAR 0 3
63841: ARRAY
63842: PUSH
63843: FOR_IN
63844: IFFALSE 63997
// begin if not b [ j ] then
63846: LD_VAR 0 6
63850: PUSH
63851: LD_VAR 0 3
63855: ARRAY
63856: NOT
63857: IFFALSE 63861
// break ;
63859: GO 63997
// e := 0 ;
63861: LD_ADDR_VAR 0 7
63865: PUSH
63866: LD_INT 0
63868: ST_TO_ADDR
// for k in b [ j ] do
63869: LD_ADDR_VAR 0 8
63873: PUSH
63874: LD_VAR 0 6
63878: PUSH
63879: LD_VAR 0 3
63883: ARRAY
63884: PUSH
63885: FOR_IN
63886: IFFALSE 63913
// if IsNotFull ( k ) then
63888: LD_VAR 0 8
63892: PPUSH
63893: CALL 18684 0 1
63897: IFFALSE 63911
// begin e := k ;
63899: LD_ADDR_VAR 0 7
63903: PUSH
63904: LD_VAR 0 8
63908: ST_TO_ADDR
// break ;
63909: GO 63913
// end ;
63911: GO 63885
63913: POP
63914: POP
// if e and not UnitGoingToBuilding ( p , e ) then
63915: LD_VAR 0 7
63919: PUSH
63920: LD_VAR 0 5
63924: PPUSH
63925: LD_VAR 0 7
63929: PPUSH
63930: CALL 52823 0 2
63934: NOT
63935: AND
63936: IFFALSE 63995
// begin if IsInUnit ( p ) then
63938: LD_VAR 0 5
63942: PPUSH
63943: CALL_OW 310
63947: IFFALSE 63958
// ComExitBuilding ( p ) ;
63949: LD_VAR 0 5
63953: PPUSH
63954: CALL_OW 122
// ComEnterUnit ( p , e ) ;
63958: LD_VAR 0 5
63962: PPUSH
63963: LD_VAR 0 7
63967: PPUSH
63968: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
63972: LD_VAR 0 5
63976: PPUSH
63977: LD_VAR 0 3
63981: PPUSH
63982: CALL_OW 183
// AddComExitBuilding ( p ) ;
63986: LD_VAR 0 5
63990: PPUSH
63991: CALL_OW 182
// end ; end ;
63995: GO 63843
63997: POP
63998: POP
// end ;
63999: GO 63809
64001: POP
64002: POP
// end ;
64003: GO 63573
64005: POP
64006: POP
// end ;
64007: LD_VAR 0 1
64011: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
64012: LD_INT 0
64014: PPUSH
64015: PPUSH
64016: PPUSH
64017: PPUSH
64018: PPUSH
64019: PPUSH
64020: PPUSH
64021: PPUSH
64022: PPUSH
64023: PPUSH
64024: PPUSH
64025: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
64026: LD_ADDR_VAR 0 2
64030: PUSH
64031: LD_INT 0
64033: PUSH
64034: LD_INT 0
64036: PUSH
64037: LD_INT 0
64039: PUSH
64040: LD_INT 0
64042: PUSH
64043: EMPTY
64044: LIST
64045: LIST
64046: LIST
64047: LIST
64048: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
64049: LD_VAR 0 1
64053: NOT
64054: PUSH
64055: LD_EXP 62
64059: PUSH
64060: LD_VAR 0 1
64064: ARRAY
64065: NOT
64066: OR
64067: PUSH
64068: LD_EXP 62
64072: PUSH
64073: LD_VAR 0 1
64077: ARRAY
64078: PPUSH
64079: LD_INT 2
64081: PUSH
64082: LD_INT 30
64084: PUSH
64085: LD_INT 0
64087: PUSH
64088: EMPTY
64089: LIST
64090: LIST
64091: PUSH
64092: LD_INT 30
64094: PUSH
64095: LD_INT 1
64097: PUSH
64098: EMPTY
64099: LIST
64100: LIST
64101: PUSH
64102: EMPTY
64103: LIST
64104: LIST
64105: LIST
64106: PPUSH
64107: CALL_OW 72
64111: NOT
64112: OR
64113: IFFALSE 64117
// exit ;
64115: GO 67620
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64117: LD_ADDR_VAR 0 4
64121: PUSH
64122: LD_EXP 62
64126: PUSH
64127: LD_VAR 0 1
64131: ARRAY
64132: PPUSH
64133: LD_INT 2
64135: PUSH
64136: LD_INT 25
64138: PUSH
64139: LD_INT 1
64141: PUSH
64142: EMPTY
64143: LIST
64144: LIST
64145: PUSH
64146: LD_INT 25
64148: PUSH
64149: LD_INT 2
64151: PUSH
64152: EMPTY
64153: LIST
64154: LIST
64155: PUSH
64156: LD_INT 25
64158: PUSH
64159: LD_INT 3
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: PUSH
64166: LD_INT 25
64168: PUSH
64169: LD_INT 4
64171: PUSH
64172: EMPTY
64173: LIST
64174: LIST
64175: PUSH
64176: LD_INT 25
64178: PUSH
64179: LD_INT 5
64181: PUSH
64182: EMPTY
64183: LIST
64184: LIST
64185: PUSH
64186: LD_INT 25
64188: PUSH
64189: LD_INT 8
64191: PUSH
64192: EMPTY
64193: LIST
64194: LIST
64195: PUSH
64196: LD_INT 25
64198: PUSH
64199: LD_INT 9
64201: PUSH
64202: EMPTY
64203: LIST
64204: LIST
64205: PUSH
64206: EMPTY
64207: LIST
64208: LIST
64209: LIST
64210: LIST
64211: LIST
64212: LIST
64213: LIST
64214: LIST
64215: PPUSH
64216: CALL_OW 72
64220: ST_TO_ADDR
// if not tmp then
64221: LD_VAR 0 4
64225: NOT
64226: IFFALSE 64230
// exit ;
64228: GO 67620
// for i in tmp do
64230: LD_ADDR_VAR 0 3
64234: PUSH
64235: LD_VAR 0 4
64239: PUSH
64240: FOR_IN
64241: IFFALSE 64272
// if GetTag ( i ) then
64243: LD_VAR 0 3
64247: PPUSH
64248: CALL_OW 110
64252: IFFALSE 64270
// tmp := tmp diff i ;
64254: LD_ADDR_VAR 0 4
64258: PUSH
64259: LD_VAR 0 4
64263: PUSH
64264: LD_VAR 0 3
64268: DIFF
64269: ST_TO_ADDR
64270: GO 64240
64272: POP
64273: POP
// if not tmp then
64274: LD_VAR 0 4
64278: NOT
64279: IFFALSE 64283
// exit ;
64281: GO 67620
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64283: LD_ADDR_VAR 0 5
64287: PUSH
64288: LD_EXP 62
64292: PUSH
64293: LD_VAR 0 1
64297: ARRAY
64298: PPUSH
64299: LD_INT 2
64301: PUSH
64302: LD_INT 25
64304: PUSH
64305: LD_INT 1
64307: PUSH
64308: EMPTY
64309: LIST
64310: LIST
64311: PUSH
64312: LD_INT 25
64314: PUSH
64315: LD_INT 5
64317: PUSH
64318: EMPTY
64319: LIST
64320: LIST
64321: PUSH
64322: LD_INT 25
64324: PUSH
64325: LD_INT 8
64327: PUSH
64328: EMPTY
64329: LIST
64330: LIST
64331: PUSH
64332: LD_INT 25
64334: PUSH
64335: LD_INT 9
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PUSH
64342: EMPTY
64343: LIST
64344: LIST
64345: LIST
64346: LIST
64347: LIST
64348: PPUSH
64349: CALL_OW 72
64353: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
64354: LD_ADDR_VAR 0 6
64358: PUSH
64359: LD_EXP 62
64363: PUSH
64364: LD_VAR 0 1
64368: ARRAY
64369: PPUSH
64370: LD_INT 25
64372: PUSH
64373: LD_INT 2
64375: PUSH
64376: EMPTY
64377: LIST
64378: LIST
64379: PPUSH
64380: CALL_OW 72
64384: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
64385: LD_ADDR_VAR 0 7
64389: PUSH
64390: LD_EXP 62
64394: PUSH
64395: LD_VAR 0 1
64399: ARRAY
64400: PPUSH
64401: LD_INT 25
64403: PUSH
64404: LD_INT 3
64406: PUSH
64407: EMPTY
64408: LIST
64409: LIST
64410: PPUSH
64411: CALL_OW 72
64415: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
64416: LD_ADDR_VAR 0 8
64420: PUSH
64421: LD_EXP 62
64425: PUSH
64426: LD_VAR 0 1
64430: ARRAY
64431: PPUSH
64432: LD_INT 25
64434: PUSH
64435: LD_INT 4
64437: PUSH
64438: EMPTY
64439: LIST
64440: LIST
64441: PUSH
64442: LD_INT 24
64444: PUSH
64445: LD_INT 251
64447: PUSH
64448: EMPTY
64449: LIST
64450: LIST
64451: PUSH
64452: EMPTY
64453: LIST
64454: LIST
64455: PPUSH
64456: CALL_OW 72
64460: ST_TO_ADDR
// if mc_is_defending [ base ] then
64461: LD_EXP 105
64465: PUSH
64466: LD_VAR 0 1
64470: ARRAY
64471: IFFALSE 64932
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
64473: LD_ADDR_EXP 104
64477: PUSH
64478: LD_EXP 104
64482: PPUSH
64483: LD_VAR 0 1
64487: PPUSH
64488: LD_INT 4
64490: PPUSH
64491: CALL_OW 1
64495: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64496: LD_ADDR_VAR 0 12
64500: PUSH
64501: LD_EXP 62
64505: PUSH
64506: LD_VAR 0 1
64510: ARRAY
64511: PPUSH
64512: LD_INT 2
64514: PUSH
64515: LD_INT 30
64517: PUSH
64518: LD_INT 4
64520: PUSH
64521: EMPTY
64522: LIST
64523: LIST
64524: PUSH
64525: LD_INT 30
64527: PUSH
64528: LD_INT 5
64530: PUSH
64531: EMPTY
64532: LIST
64533: LIST
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: LIST
64539: PPUSH
64540: CALL_OW 72
64544: ST_TO_ADDR
// if not b then
64545: LD_VAR 0 12
64549: NOT
64550: IFFALSE 64554
// exit ;
64552: GO 67620
// p := [ ] ;
64554: LD_ADDR_VAR 0 11
64558: PUSH
64559: EMPTY
64560: ST_TO_ADDR
// if sci >= 2 then
64561: LD_VAR 0 8
64565: PUSH
64566: LD_INT 2
64568: GREATEREQUAL
64569: IFFALSE 64600
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
64571: LD_ADDR_VAR 0 8
64575: PUSH
64576: LD_VAR 0 8
64580: PUSH
64581: LD_INT 1
64583: ARRAY
64584: PUSH
64585: LD_VAR 0 8
64589: PUSH
64590: LD_INT 2
64592: ARRAY
64593: PUSH
64594: EMPTY
64595: LIST
64596: LIST
64597: ST_TO_ADDR
64598: GO 64661
// if sci = 1 then
64600: LD_VAR 0 8
64604: PUSH
64605: LD_INT 1
64607: EQUAL
64608: IFFALSE 64629
// sci := [ sci [ 1 ] ] else
64610: LD_ADDR_VAR 0 8
64614: PUSH
64615: LD_VAR 0 8
64619: PUSH
64620: LD_INT 1
64622: ARRAY
64623: PUSH
64624: EMPTY
64625: LIST
64626: ST_TO_ADDR
64627: GO 64661
// if sci = 0 then
64629: LD_VAR 0 8
64633: PUSH
64634: LD_INT 0
64636: EQUAL
64637: IFFALSE 64661
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
64639: LD_ADDR_VAR 0 11
64643: PUSH
64644: LD_VAR 0 4
64648: PPUSH
64649: LD_INT 4
64651: PPUSH
64652: CALL 52695 0 2
64656: PUSH
64657: LD_INT 1
64659: ARRAY
64660: ST_TO_ADDR
// if eng > 4 then
64661: LD_VAR 0 6
64665: PUSH
64666: LD_INT 4
64668: GREATER
64669: IFFALSE 64715
// for i = eng downto 4 do
64671: LD_ADDR_VAR 0 3
64675: PUSH
64676: DOUBLE
64677: LD_VAR 0 6
64681: INC
64682: ST_TO_ADDR
64683: LD_INT 4
64685: PUSH
64686: FOR_DOWNTO
64687: IFFALSE 64713
// eng := eng diff eng [ i ] ;
64689: LD_ADDR_VAR 0 6
64693: PUSH
64694: LD_VAR 0 6
64698: PUSH
64699: LD_VAR 0 6
64703: PUSH
64704: LD_VAR 0 3
64708: ARRAY
64709: DIFF
64710: ST_TO_ADDR
64711: GO 64686
64713: POP
64714: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
64715: LD_ADDR_VAR 0 4
64719: PUSH
64720: LD_VAR 0 4
64724: PUSH
64725: LD_VAR 0 5
64729: PUSH
64730: LD_VAR 0 6
64734: UNION
64735: PUSH
64736: LD_VAR 0 7
64740: UNION
64741: PUSH
64742: LD_VAR 0 8
64746: UNION
64747: DIFF
64748: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
64749: LD_ADDR_VAR 0 13
64753: PUSH
64754: LD_EXP 62
64758: PUSH
64759: LD_VAR 0 1
64763: ARRAY
64764: PPUSH
64765: LD_INT 2
64767: PUSH
64768: LD_INT 30
64770: PUSH
64771: LD_INT 32
64773: PUSH
64774: EMPTY
64775: LIST
64776: LIST
64777: PUSH
64778: LD_INT 30
64780: PUSH
64781: LD_INT 31
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: LIST
64792: PPUSH
64793: CALL_OW 72
64797: PUSH
64798: LD_EXP 62
64802: PUSH
64803: LD_VAR 0 1
64807: ARRAY
64808: PPUSH
64809: LD_INT 2
64811: PUSH
64812: LD_INT 30
64814: PUSH
64815: LD_INT 4
64817: PUSH
64818: EMPTY
64819: LIST
64820: LIST
64821: PUSH
64822: LD_INT 30
64824: PUSH
64825: LD_INT 5
64827: PUSH
64828: EMPTY
64829: LIST
64830: LIST
64831: PUSH
64832: EMPTY
64833: LIST
64834: LIST
64835: LIST
64836: PPUSH
64837: CALL_OW 72
64841: PUSH
64842: LD_INT 6
64844: MUL
64845: PLUS
64846: ST_TO_ADDR
// if bcount < tmp then
64847: LD_VAR 0 13
64851: PUSH
64852: LD_VAR 0 4
64856: LESS
64857: IFFALSE 64903
// for i = tmp downto bcount do
64859: LD_ADDR_VAR 0 3
64863: PUSH
64864: DOUBLE
64865: LD_VAR 0 4
64869: INC
64870: ST_TO_ADDR
64871: LD_VAR 0 13
64875: PUSH
64876: FOR_DOWNTO
64877: IFFALSE 64901
// tmp := Delete ( tmp , tmp ) ;
64879: LD_ADDR_VAR 0 4
64883: PUSH
64884: LD_VAR 0 4
64888: PPUSH
64889: LD_VAR 0 4
64893: PPUSH
64894: CALL_OW 3
64898: ST_TO_ADDR
64899: GO 64876
64901: POP
64902: POP
// result := [ tmp , 0 , 0 , p ] ;
64903: LD_ADDR_VAR 0 2
64907: PUSH
64908: LD_VAR 0 4
64912: PUSH
64913: LD_INT 0
64915: PUSH
64916: LD_INT 0
64918: PUSH
64919: LD_VAR 0 11
64923: PUSH
64924: EMPTY
64925: LIST
64926: LIST
64927: LIST
64928: LIST
64929: ST_TO_ADDR
// exit ;
64930: GO 67620
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
64932: LD_EXP 62
64936: PUSH
64937: LD_VAR 0 1
64941: ARRAY
64942: PPUSH
64943: LD_INT 2
64945: PUSH
64946: LD_INT 30
64948: PUSH
64949: LD_INT 6
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: PUSH
64956: LD_INT 30
64958: PUSH
64959: LD_INT 7
64961: PUSH
64962: EMPTY
64963: LIST
64964: LIST
64965: PUSH
64966: LD_INT 30
64968: PUSH
64969: LD_INT 8
64971: PUSH
64972: EMPTY
64973: LIST
64974: LIST
64975: PUSH
64976: EMPTY
64977: LIST
64978: LIST
64979: LIST
64980: LIST
64981: PPUSH
64982: CALL_OW 72
64986: NOT
64987: PUSH
64988: LD_EXP 62
64992: PUSH
64993: LD_VAR 0 1
64997: ARRAY
64998: PPUSH
64999: LD_INT 30
65001: PUSH
65002: LD_INT 3
65004: PUSH
65005: EMPTY
65006: LIST
65007: LIST
65008: PPUSH
65009: CALL_OW 72
65013: NOT
65014: AND
65015: IFFALSE 65087
// begin if eng = tmp then
65017: LD_VAR 0 6
65021: PUSH
65022: LD_VAR 0 4
65026: EQUAL
65027: IFFALSE 65031
// exit ;
65029: GO 67620
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
65031: LD_ADDR_EXP 104
65035: PUSH
65036: LD_EXP 104
65040: PPUSH
65041: LD_VAR 0 1
65045: PPUSH
65046: LD_INT 1
65048: PPUSH
65049: CALL_OW 1
65053: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
65054: LD_ADDR_VAR 0 2
65058: PUSH
65059: LD_INT 0
65061: PUSH
65062: LD_VAR 0 4
65066: PUSH
65067: LD_VAR 0 6
65071: DIFF
65072: PUSH
65073: LD_INT 0
65075: PUSH
65076: LD_INT 0
65078: PUSH
65079: EMPTY
65080: LIST
65081: LIST
65082: LIST
65083: LIST
65084: ST_TO_ADDR
// exit ;
65085: GO 67620
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65087: LD_EXP 89
65091: PUSH
65092: LD_EXP 88
65096: PUSH
65097: LD_VAR 0 1
65101: ARRAY
65102: ARRAY
65103: PUSH
65104: LD_EXP 62
65108: PUSH
65109: LD_VAR 0 1
65113: ARRAY
65114: PPUSH
65115: LD_INT 2
65117: PUSH
65118: LD_INT 30
65120: PUSH
65121: LD_INT 6
65123: PUSH
65124: EMPTY
65125: LIST
65126: LIST
65127: PUSH
65128: LD_INT 30
65130: PUSH
65131: LD_INT 7
65133: PUSH
65134: EMPTY
65135: LIST
65136: LIST
65137: PUSH
65138: LD_INT 30
65140: PUSH
65141: LD_INT 8
65143: PUSH
65144: EMPTY
65145: LIST
65146: LIST
65147: PUSH
65148: EMPTY
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: PPUSH
65154: CALL_OW 72
65158: AND
65159: PUSH
65160: LD_EXP 62
65164: PUSH
65165: LD_VAR 0 1
65169: ARRAY
65170: PPUSH
65171: LD_INT 30
65173: PUSH
65174: LD_INT 3
65176: PUSH
65177: EMPTY
65178: LIST
65179: LIST
65180: PPUSH
65181: CALL_OW 72
65185: NOT
65186: AND
65187: IFFALSE 65401
// begin if sci >= 6 then
65189: LD_VAR 0 8
65193: PUSH
65194: LD_INT 6
65196: GREATEREQUAL
65197: IFFALSE 65201
// exit ;
65199: GO 67620
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
65201: LD_ADDR_EXP 104
65205: PUSH
65206: LD_EXP 104
65210: PPUSH
65211: LD_VAR 0 1
65215: PPUSH
65216: LD_INT 2
65218: PPUSH
65219: CALL_OW 1
65223: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
65224: LD_ADDR_VAR 0 9
65228: PUSH
65229: LD_VAR 0 4
65233: PUSH
65234: LD_VAR 0 8
65238: DIFF
65239: PPUSH
65240: LD_INT 4
65242: PPUSH
65243: CALL 52695 0 2
65247: ST_TO_ADDR
// p := [ ] ;
65248: LD_ADDR_VAR 0 11
65252: PUSH
65253: EMPTY
65254: ST_TO_ADDR
// if sci < 6 and sort > 6 then
65255: LD_VAR 0 8
65259: PUSH
65260: LD_INT 6
65262: LESS
65263: PUSH
65264: LD_VAR 0 9
65268: PUSH
65269: LD_INT 6
65271: GREATER
65272: AND
65273: IFFALSE 65354
// begin for i = 1 to 6 - sci do
65275: LD_ADDR_VAR 0 3
65279: PUSH
65280: DOUBLE
65281: LD_INT 1
65283: DEC
65284: ST_TO_ADDR
65285: LD_INT 6
65287: PUSH
65288: LD_VAR 0 8
65292: MINUS
65293: PUSH
65294: FOR_TO
65295: IFFALSE 65350
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
65297: LD_ADDR_VAR 0 11
65301: PUSH
65302: LD_VAR 0 11
65306: PPUSH
65307: LD_VAR 0 11
65311: PUSH
65312: LD_INT 1
65314: PLUS
65315: PPUSH
65316: LD_VAR 0 9
65320: PUSH
65321: LD_INT 1
65323: ARRAY
65324: PPUSH
65325: CALL_OW 2
65329: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
65330: LD_ADDR_VAR 0 9
65334: PUSH
65335: LD_VAR 0 9
65339: PPUSH
65340: LD_INT 1
65342: PPUSH
65343: CALL_OW 3
65347: ST_TO_ADDR
// end ;
65348: GO 65294
65350: POP
65351: POP
// end else
65352: GO 65374
// if sort then
65354: LD_VAR 0 9
65358: IFFALSE 65374
// p := sort [ 1 ] ;
65360: LD_ADDR_VAR 0 11
65364: PUSH
65365: LD_VAR 0 9
65369: PUSH
65370: LD_INT 1
65372: ARRAY
65373: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
65374: LD_ADDR_VAR 0 2
65378: PUSH
65379: LD_INT 0
65381: PUSH
65382: LD_INT 0
65384: PUSH
65385: LD_INT 0
65387: PUSH
65388: LD_VAR 0 11
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: ST_TO_ADDR
// exit ;
65399: GO 67620
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65401: LD_EXP 89
65405: PUSH
65406: LD_EXP 88
65410: PUSH
65411: LD_VAR 0 1
65415: ARRAY
65416: ARRAY
65417: PUSH
65418: LD_EXP 62
65422: PUSH
65423: LD_VAR 0 1
65427: ARRAY
65428: PPUSH
65429: LD_INT 2
65431: PUSH
65432: LD_INT 30
65434: PUSH
65435: LD_INT 6
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: PUSH
65442: LD_INT 30
65444: PUSH
65445: LD_INT 7
65447: PUSH
65448: EMPTY
65449: LIST
65450: LIST
65451: PUSH
65452: LD_INT 30
65454: PUSH
65455: LD_INT 8
65457: PUSH
65458: EMPTY
65459: LIST
65460: LIST
65461: PUSH
65462: EMPTY
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: PPUSH
65468: CALL_OW 72
65472: AND
65473: PUSH
65474: LD_EXP 62
65478: PUSH
65479: LD_VAR 0 1
65483: ARRAY
65484: PPUSH
65485: LD_INT 30
65487: PUSH
65488: LD_INT 3
65490: PUSH
65491: EMPTY
65492: LIST
65493: LIST
65494: PPUSH
65495: CALL_OW 72
65499: AND
65500: IFFALSE 66234
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
65502: LD_ADDR_EXP 104
65506: PUSH
65507: LD_EXP 104
65511: PPUSH
65512: LD_VAR 0 1
65516: PPUSH
65517: LD_INT 3
65519: PPUSH
65520: CALL_OW 1
65524: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65525: LD_ADDR_VAR 0 2
65529: PUSH
65530: LD_INT 0
65532: PUSH
65533: LD_INT 0
65535: PUSH
65536: LD_INT 0
65538: PUSH
65539: LD_INT 0
65541: PUSH
65542: EMPTY
65543: LIST
65544: LIST
65545: LIST
65546: LIST
65547: ST_TO_ADDR
// if not eng then
65548: LD_VAR 0 6
65552: NOT
65553: IFFALSE 65616
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
65555: LD_ADDR_VAR 0 11
65559: PUSH
65560: LD_VAR 0 4
65564: PPUSH
65565: LD_INT 2
65567: PPUSH
65568: CALL 52695 0 2
65572: PUSH
65573: LD_INT 1
65575: ARRAY
65576: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
65577: LD_ADDR_VAR 0 2
65581: PUSH
65582: LD_VAR 0 2
65586: PPUSH
65587: LD_INT 2
65589: PPUSH
65590: LD_VAR 0 11
65594: PPUSH
65595: CALL_OW 1
65599: ST_TO_ADDR
// tmp := tmp diff p ;
65600: LD_ADDR_VAR 0 4
65604: PUSH
65605: LD_VAR 0 4
65609: PUSH
65610: LD_VAR 0 11
65614: DIFF
65615: ST_TO_ADDR
// end ; if tmp and sci < 6 then
65616: LD_VAR 0 4
65620: PUSH
65621: LD_VAR 0 8
65625: PUSH
65626: LD_INT 6
65628: LESS
65629: AND
65630: IFFALSE 65818
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
65632: LD_ADDR_VAR 0 9
65636: PUSH
65637: LD_VAR 0 4
65641: PUSH
65642: LD_VAR 0 8
65646: PUSH
65647: LD_VAR 0 7
65651: UNION
65652: DIFF
65653: PPUSH
65654: LD_INT 4
65656: PPUSH
65657: CALL 52695 0 2
65661: ST_TO_ADDR
// p := [ ] ;
65662: LD_ADDR_VAR 0 11
65666: PUSH
65667: EMPTY
65668: ST_TO_ADDR
// if sort then
65669: LD_VAR 0 9
65673: IFFALSE 65789
// for i = 1 to 6 - sci do
65675: LD_ADDR_VAR 0 3
65679: PUSH
65680: DOUBLE
65681: LD_INT 1
65683: DEC
65684: ST_TO_ADDR
65685: LD_INT 6
65687: PUSH
65688: LD_VAR 0 8
65692: MINUS
65693: PUSH
65694: FOR_TO
65695: IFFALSE 65787
// begin if i = sort then
65697: LD_VAR 0 3
65701: PUSH
65702: LD_VAR 0 9
65706: EQUAL
65707: IFFALSE 65711
// break ;
65709: GO 65787
// if GetClass ( i ) = 4 then
65711: LD_VAR 0 3
65715: PPUSH
65716: CALL_OW 257
65720: PUSH
65721: LD_INT 4
65723: EQUAL
65724: IFFALSE 65728
// continue ;
65726: GO 65694
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65728: LD_ADDR_VAR 0 11
65732: PUSH
65733: LD_VAR 0 11
65737: PPUSH
65738: LD_VAR 0 11
65742: PUSH
65743: LD_INT 1
65745: PLUS
65746: PPUSH
65747: LD_VAR 0 9
65751: PUSH
65752: LD_VAR 0 3
65756: ARRAY
65757: PPUSH
65758: CALL_OW 2
65762: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65763: LD_ADDR_VAR 0 4
65767: PUSH
65768: LD_VAR 0 4
65772: PUSH
65773: LD_VAR 0 9
65777: PUSH
65778: LD_VAR 0 3
65782: ARRAY
65783: DIFF
65784: ST_TO_ADDR
// end ;
65785: GO 65694
65787: POP
65788: POP
// if p then
65789: LD_VAR 0 11
65793: IFFALSE 65818
// result := Replace ( result , 4 , p ) ;
65795: LD_ADDR_VAR 0 2
65799: PUSH
65800: LD_VAR 0 2
65804: PPUSH
65805: LD_INT 4
65807: PPUSH
65808: LD_VAR 0 11
65812: PPUSH
65813: CALL_OW 1
65817: ST_TO_ADDR
// end ; if tmp and mech < 6 then
65818: LD_VAR 0 4
65822: PUSH
65823: LD_VAR 0 7
65827: PUSH
65828: LD_INT 6
65830: LESS
65831: AND
65832: IFFALSE 66020
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
65834: LD_ADDR_VAR 0 9
65838: PUSH
65839: LD_VAR 0 4
65843: PUSH
65844: LD_VAR 0 8
65848: PUSH
65849: LD_VAR 0 7
65853: UNION
65854: DIFF
65855: PPUSH
65856: LD_INT 3
65858: PPUSH
65859: CALL 52695 0 2
65863: ST_TO_ADDR
// p := [ ] ;
65864: LD_ADDR_VAR 0 11
65868: PUSH
65869: EMPTY
65870: ST_TO_ADDR
// if sort then
65871: LD_VAR 0 9
65875: IFFALSE 65991
// for i = 1 to 6 - mech do
65877: LD_ADDR_VAR 0 3
65881: PUSH
65882: DOUBLE
65883: LD_INT 1
65885: DEC
65886: ST_TO_ADDR
65887: LD_INT 6
65889: PUSH
65890: LD_VAR 0 7
65894: MINUS
65895: PUSH
65896: FOR_TO
65897: IFFALSE 65989
// begin if i = sort then
65899: LD_VAR 0 3
65903: PUSH
65904: LD_VAR 0 9
65908: EQUAL
65909: IFFALSE 65913
// break ;
65911: GO 65989
// if GetClass ( i ) = 3 then
65913: LD_VAR 0 3
65917: PPUSH
65918: CALL_OW 257
65922: PUSH
65923: LD_INT 3
65925: EQUAL
65926: IFFALSE 65930
// continue ;
65928: GO 65896
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65930: LD_ADDR_VAR 0 11
65934: PUSH
65935: LD_VAR 0 11
65939: PPUSH
65940: LD_VAR 0 11
65944: PUSH
65945: LD_INT 1
65947: PLUS
65948: PPUSH
65949: LD_VAR 0 9
65953: PUSH
65954: LD_VAR 0 3
65958: ARRAY
65959: PPUSH
65960: CALL_OW 2
65964: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65965: LD_ADDR_VAR 0 4
65969: PUSH
65970: LD_VAR 0 4
65974: PUSH
65975: LD_VAR 0 9
65979: PUSH
65980: LD_VAR 0 3
65984: ARRAY
65985: DIFF
65986: ST_TO_ADDR
// end ;
65987: GO 65896
65989: POP
65990: POP
// if p then
65991: LD_VAR 0 11
65995: IFFALSE 66020
// result := Replace ( result , 3 , p ) ;
65997: LD_ADDR_VAR 0 2
66001: PUSH
66002: LD_VAR 0 2
66006: PPUSH
66007: LD_INT 3
66009: PPUSH
66010: LD_VAR 0 11
66014: PPUSH
66015: CALL_OW 1
66019: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
66020: LD_VAR 0 4
66024: PUSH
66025: LD_INT 6
66027: GREATER
66028: PUSH
66029: LD_VAR 0 6
66033: PUSH
66034: LD_INT 6
66036: LESS
66037: AND
66038: IFFALSE 66232
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
66040: LD_ADDR_VAR 0 9
66044: PUSH
66045: LD_VAR 0 4
66049: PUSH
66050: LD_VAR 0 8
66054: PUSH
66055: LD_VAR 0 7
66059: UNION
66060: PUSH
66061: LD_VAR 0 6
66065: UNION
66066: DIFF
66067: PPUSH
66068: LD_INT 2
66070: PPUSH
66071: CALL 52695 0 2
66075: ST_TO_ADDR
// p := [ ] ;
66076: LD_ADDR_VAR 0 11
66080: PUSH
66081: EMPTY
66082: ST_TO_ADDR
// if sort then
66083: LD_VAR 0 9
66087: IFFALSE 66203
// for i = 1 to 6 - eng do
66089: LD_ADDR_VAR 0 3
66093: PUSH
66094: DOUBLE
66095: LD_INT 1
66097: DEC
66098: ST_TO_ADDR
66099: LD_INT 6
66101: PUSH
66102: LD_VAR 0 6
66106: MINUS
66107: PUSH
66108: FOR_TO
66109: IFFALSE 66201
// begin if i = sort then
66111: LD_VAR 0 3
66115: PUSH
66116: LD_VAR 0 9
66120: EQUAL
66121: IFFALSE 66125
// break ;
66123: GO 66201
// if GetClass ( i ) = 2 then
66125: LD_VAR 0 3
66129: PPUSH
66130: CALL_OW 257
66134: PUSH
66135: LD_INT 2
66137: EQUAL
66138: IFFALSE 66142
// continue ;
66140: GO 66108
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66142: LD_ADDR_VAR 0 11
66146: PUSH
66147: LD_VAR 0 11
66151: PPUSH
66152: LD_VAR 0 11
66156: PUSH
66157: LD_INT 1
66159: PLUS
66160: PPUSH
66161: LD_VAR 0 9
66165: PUSH
66166: LD_VAR 0 3
66170: ARRAY
66171: PPUSH
66172: CALL_OW 2
66176: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66177: LD_ADDR_VAR 0 4
66181: PUSH
66182: LD_VAR 0 4
66186: PUSH
66187: LD_VAR 0 9
66191: PUSH
66192: LD_VAR 0 3
66196: ARRAY
66197: DIFF
66198: ST_TO_ADDR
// end ;
66199: GO 66108
66201: POP
66202: POP
// if p then
66203: LD_VAR 0 11
66207: IFFALSE 66232
// result := Replace ( result , 2 , p ) ;
66209: LD_ADDR_VAR 0 2
66213: PUSH
66214: LD_VAR 0 2
66218: PPUSH
66219: LD_INT 2
66221: PPUSH
66222: LD_VAR 0 11
66226: PPUSH
66227: CALL_OW 1
66231: ST_TO_ADDR
// end ; exit ;
66232: GO 67620
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
66234: LD_EXP 89
66238: PUSH
66239: LD_EXP 88
66243: PUSH
66244: LD_VAR 0 1
66248: ARRAY
66249: ARRAY
66250: NOT
66251: PUSH
66252: LD_EXP 62
66256: PUSH
66257: LD_VAR 0 1
66261: ARRAY
66262: PPUSH
66263: LD_INT 30
66265: PUSH
66266: LD_INT 3
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PPUSH
66273: CALL_OW 72
66277: AND
66278: PUSH
66279: LD_EXP 67
66283: PUSH
66284: LD_VAR 0 1
66288: ARRAY
66289: AND
66290: IFFALSE 66898
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
66292: LD_ADDR_EXP 104
66296: PUSH
66297: LD_EXP 104
66301: PPUSH
66302: LD_VAR 0 1
66306: PPUSH
66307: LD_INT 5
66309: PPUSH
66310: CALL_OW 1
66314: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66315: LD_ADDR_VAR 0 2
66319: PUSH
66320: LD_INT 0
66322: PUSH
66323: LD_INT 0
66325: PUSH
66326: LD_INT 0
66328: PUSH
66329: LD_INT 0
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: LIST
66336: LIST
66337: ST_TO_ADDR
// if sci > 1 then
66338: LD_VAR 0 8
66342: PUSH
66343: LD_INT 1
66345: GREATER
66346: IFFALSE 66374
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
66348: LD_ADDR_VAR 0 4
66352: PUSH
66353: LD_VAR 0 4
66357: PUSH
66358: LD_VAR 0 8
66362: PUSH
66363: LD_VAR 0 8
66367: PUSH
66368: LD_INT 1
66370: ARRAY
66371: DIFF
66372: DIFF
66373: ST_TO_ADDR
// if tmp and not sci then
66374: LD_VAR 0 4
66378: PUSH
66379: LD_VAR 0 8
66383: NOT
66384: AND
66385: IFFALSE 66454
// begin sort := SortBySkill ( tmp , 4 ) ;
66387: LD_ADDR_VAR 0 9
66391: PUSH
66392: LD_VAR 0 4
66396: PPUSH
66397: LD_INT 4
66399: PPUSH
66400: CALL 52695 0 2
66404: ST_TO_ADDR
// if sort then
66405: LD_VAR 0 9
66409: IFFALSE 66425
// p := sort [ 1 ] ;
66411: LD_ADDR_VAR 0 11
66415: PUSH
66416: LD_VAR 0 9
66420: PUSH
66421: LD_INT 1
66423: ARRAY
66424: ST_TO_ADDR
// if p then
66425: LD_VAR 0 11
66429: IFFALSE 66454
// result := Replace ( result , 4 , p ) ;
66431: LD_ADDR_VAR 0 2
66435: PUSH
66436: LD_VAR 0 2
66440: PPUSH
66441: LD_INT 4
66443: PPUSH
66444: LD_VAR 0 11
66448: PPUSH
66449: CALL_OW 1
66453: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
66454: LD_ADDR_VAR 0 4
66458: PUSH
66459: LD_VAR 0 4
66463: PUSH
66464: LD_VAR 0 7
66468: DIFF
66469: ST_TO_ADDR
// if tmp and mech < 6 then
66470: LD_VAR 0 4
66474: PUSH
66475: LD_VAR 0 7
66479: PUSH
66480: LD_INT 6
66482: LESS
66483: AND
66484: IFFALSE 66672
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
66486: LD_ADDR_VAR 0 9
66490: PUSH
66491: LD_VAR 0 4
66495: PUSH
66496: LD_VAR 0 8
66500: PUSH
66501: LD_VAR 0 7
66505: UNION
66506: DIFF
66507: PPUSH
66508: LD_INT 3
66510: PPUSH
66511: CALL 52695 0 2
66515: ST_TO_ADDR
// p := [ ] ;
66516: LD_ADDR_VAR 0 11
66520: PUSH
66521: EMPTY
66522: ST_TO_ADDR
// if sort then
66523: LD_VAR 0 9
66527: IFFALSE 66643
// for i = 1 to 6 - mech do
66529: LD_ADDR_VAR 0 3
66533: PUSH
66534: DOUBLE
66535: LD_INT 1
66537: DEC
66538: ST_TO_ADDR
66539: LD_INT 6
66541: PUSH
66542: LD_VAR 0 7
66546: MINUS
66547: PUSH
66548: FOR_TO
66549: IFFALSE 66641
// begin if i = sort then
66551: LD_VAR 0 3
66555: PUSH
66556: LD_VAR 0 9
66560: EQUAL
66561: IFFALSE 66565
// break ;
66563: GO 66641
// if GetClass ( i ) = 3 then
66565: LD_VAR 0 3
66569: PPUSH
66570: CALL_OW 257
66574: PUSH
66575: LD_INT 3
66577: EQUAL
66578: IFFALSE 66582
// continue ;
66580: GO 66548
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66582: LD_ADDR_VAR 0 11
66586: PUSH
66587: LD_VAR 0 11
66591: PPUSH
66592: LD_VAR 0 11
66596: PUSH
66597: LD_INT 1
66599: PLUS
66600: PPUSH
66601: LD_VAR 0 9
66605: PUSH
66606: LD_VAR 0 3
66610: ARRAY
66611: PPUSH
66612: CALL_OW 2
66616: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66617: LD_ADDR_VAR 0 4
66621: PUSH
66622: LD_VAR 0 4
66626: PUSH
66627: LD_VAR 0 9
66631: PUSH
66632: LD_VAR 0 3
66636: ARRAY
66637: DIFF
66638: ST_TO_ADDR
// end ;
66639: GO 66548
66641: POP
66642: POP
// if p then
66643: LD_VAR 0 11
66647: IFFALSE 66672
// result := Replace ( result , 3 , p ) ;
66649: LD_ADDR_VAR 0 2
66653: PUSH
66654: LD_VAR 0 2
66658: PPUSH
66659: LD_INT 3
66661: PPUSH
66662: LD_VAR 0 11
66666: PPUSH
66667: CALL_OW 1
66671: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
66672: LD_ADDR_VAR 0 4
66676: PUSH
66677: LD_VAR 0 4
66681: PUSH
66682: LD_VAR 0 6
66686: DIFF
66687: ST_TO_ADDR
// if tmp and eng < 6 then
66688: LD_VAR 0 4
66692: PUSH
66693: LD_VAR 0 6
66697: PUSH
66698: LD_INT 6
66700: LESS
66701: AND
66702: IFFALSE 66896
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
66704: LD_ADDR_VAR 0 9
66708: PUSH
66709: LD_VAR 0 4
66713: PUSH
66714: LD_VAR 0 8
66718: PUSH
66719: LD_VAR 0 7
66723: UNION
66724: PUSH
66725: LD_VAR 0 6
66729: UNION
66730: DIFF
66731: PPUSH
66732: LD_INT 2
66734: PPUSH
66735: CALL 52695 0 2
66739: ST_TO_ADDR
// p := [ ] ;
66740: LD_ADDR_VAR 0 11
66744: PUSH
66745: EMPTY
66746: ST_TO_ADDR
// if sort then
66747: LD_VAR 0 9
66751: IFFALSE 66867
// for i = 1 to 6 - eng do
66753: LD_ADDR_VAR 0 3
66757: PUSH
66758: DOUBLE
66759: LD_INT 1
66761: DEC
66762: ST_TO_ADDR
66763: LD_INT 6
66765: PUSH
66766: LD_VAR 0 6
66770: MINUS
66771: PUSH
66772: FOR_TO
66773: IFFALSE 66865
// begin if i = sort then
66775: LD_VAR 0 3
66779: PUSH
66780: LD_VAR 0 9
66784: EQUAL
66785: IFFALSE 66789
// break ;
66787: GO 66865
// if GetClass ( i ) = 2 then
66789: LD_VAR 0 3
66793: PPUSH
66794: CALL_OW 257
66798: PUSH
66799: LD_INT 2
66801: EQUAL
66802: IFFALSE 66806
// continue ;
66804: GO 66772
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66806: LD_ADDR_VAR 0 11
66810: PUSH
66811: LD_VAR 0 11
66815: PPUSH
66816: LD_VAR 0 11
66820: PUSH
66821: LD_INT 1
66823: PLUS
66824: PPUSH
66825: LD_VAR 0 9
66829: PUSH
66830: LD_VAR 0 3
66834: ARRAY
66835: PPUSH
66836: CALL_OW 2
66840: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66841: LD_ADDR_VAR 0 4
66845: PUSH
66846: LD_VAR 0 4
66850: PUSH
66851: LD_VAR 0 9
66855: PUSH
66856: LD_VAR 0 3
66860: ARRAY
66861: DIFF
66862: ST_TO_ADDR
// end ;
66863: GO 66772
66865: POP
66866: POP
// if p then
66867: LD_VAR 0 11
66871: IFFALSE 66896
// result := Replace ( result , 2 , p ) ;
66873: LD_ADDR_VAR 0 2
66877: PUSH
66878: LD_VAR 0 2
66882: PPUSH
66883: LD_INT 2
66885: PPUSH
66886: LD_VAR 0 11
66890: PPUSH
66891: CALL_OW 1
66895: ST_TO_ADDR
// end ; exit ;
66896: GO 67620
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
66898: LD_EXP 89
66902: PUSH
66903: LD_EXP 88
66907: PUSH
66908: LD_VAR 0 1
66912: ARRAY
66913: ARRAY
66914: NOT
66915: PUSH
66916: LD_EXP 62
66920: PUSH
66921: LD_VAR 0 1
66925: ARRAY
66926: PPUSH
66927: LD_INT 30
66929: PUSH
66930: LD_INT 3
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PPUSH
66937: CALL_OW 72
66941: AND
66942: PUSH
66943: LD_EXP 67
66947: PUSH
66948: LD_VAR 0 1
66952: ARRAY
66953: NOT
66954: AND
66955: IFFALSE 67620
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
66957: LD_ADDR_EXP 104
66961: PUSH
66962: LD_EXP 104
66966: PPUSH
66967: LD_VAR 0 1
66971: PPUSH
66972: LD_INT 6
66974: PPUSH
66975: CALL_OW 1
66979: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66980: LD_ADDR_VAR 0 2
66984: PUSH
66985: LD_INT 0
66987: PUSH
66988: LD_INT 0
66990: PUSH
66991: LD_INT 0
66993: PUSH
66994: LD_INT 0
66996: PUSH
66997: EMPTY
66998: LIST
66999: LIST
67000: LIST
67001: LIST
67002: ST_TO_ADDR
// if sci >= 1 then
67003: LD_VAR 0 8
67007: PUSH
67008: LD_INT 1
67010: GREATEREQUAL
67011: IFFALSE 67033
// tmp := tmp diff sci [ 1 ] ;
67013: LD_ADDR_VAR 0 4
67017: PUSH
67018: LD_VAR 0 4
67022: PUSH
67023: LD_VAR 0 8
67027: PUSH
67028: LD_INT 1
67030: ARRAY
67031: DIFF
67032: ST_TO_ADDR
// if tmp and not sci then
67033: LD_VAR 0 4
67037: PUSH
67038: LD_VAR 0 8
67042: NOT
67043: AND
67044: IFFALSE 67113
// begin sort := SortBySkill ( tmp , 4 ) ;
67046: LD_ADDR_VAR 0 9
67050: PUSH
67051: LD_VAR 0 4
67055: PPUSH
67056: LD_INT 4
67058: PPUSH
67059: CALL 52695 0 2
67063: ST_TO_ADDR
// if sort then
67064: LD_VAR 0 9
67068: IFFALSE 67084
// p := sort [ 1 ] ;
67070: LD_ADDR_VAR 0 11
67074: PUSH
67075: LD_VAR 0 9
67079: PUSH
67080: LD_INT 1
67082: ARRAY
67083: ST_TO_ADDR
// if p then
67084: LD_VAR 0 11
67088: IFFALSE 67113
// result := Replace ( result , 4 , p ) ;
67090: LD_ADDR_VAR 0 2
67094: PUSH
67095: LD_VAR 0 2
67099: PPUSH
67100: LD_INT 4
67102: PPUSH
67103: LD_VAR 0 11
67107: PPUSH
67108: CALL_OW 1
67112: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
67113: LD_ADDR_VAR 0 4
67117: PUSH
67118: LD_VAR 0 4
67122: PUSH
67123: LD_VAR 0 7
67127: DIFF
67128: ST_TO_ADDR
// if tmp and mech < 6 then
67129: LD_VAR 0 4
67133: PUSH
67134: LD_VAR 0 7
67138: PUSH
67139: LD_INT 6
67141: LESS
67142: AND
67143: IFFALSE 67325
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
67145: LD_ADDR_VAR 0 9
67149: PUSH
67150: LD_VAR 0 4
67154: PUSH
67155: LD_VAR 0 7
67159: DIFF
67160: PPUSH
67161: LD_INT 3
67163: PPUSH
67164: CALL 52695 0 2
67168: ST_TO_ADDR
// p := [ ] ;
67169: LD_ADDR_VAR 0 11
67173: PUSH
67174: EMPTY
67175: ST_TO_ADDR
// if sort then
67176: LD_VAR 0 9
67180: IFFALSE 67296
// for i = 1 to 6 - mech do
67182: LD_ADDR_VAR 0 3
67186: PUSH
67187: DOUBLE
67188: LD_INT 1
67190: DEC
67191: ST_TO_ADDR
67192: LD_INT 6
67194: PUSH
67195: LD_VAR 0 7
67199: MINUS
67200: PUSH
67201: FOR_TO
67202: IFFALSE 67294
// begin if i = sort then
67204: LD_VAR 0 3
67208: PUSH
67209: LD_VAR 0 9
67213: EQUAL
67214: IFFALSE 67218
// break ;
67216: GO 67294
// if GetClass ( i ) = 3 then
67218: LD_VAR 0 3
67222: PPUSH
67223: CALL_OW 257
67227: PUSH
67228: LD_INT 3
67230: EQUAL
67231: IFFALSE 67235
// continue ;
67233: GO 67201
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67235: LD_ADDR_VAR 0 11
67239: PUSH
67240: LD_VAR 0 11
67244: PPUSH
67245: LD_VAR 0 11
67249: PUSH
67250: LD_INT 1
67252: PLUS
67253: PPUSH
67254: LD_VAR 0 9
67258: PUSH
67259: LD_VAR 0 3
67263: ARRAY
67264: PPUSH
67265: CALL_OW 2
67269: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67270: LD_ADDR_VAR 0 4
67274: PUSH
67275: LD_VAR 0 4
67279: PUSH
67280: LD_VAR 0 9
67284: PUSH
67285: LD_VAR 0 3
67289: ARRAY
67290: DIFF
67291: ST_TO_ADDR
// end ;
67292: GO 67201
67294: POP
67295: POP
// if p then
67296: LD_VAR 0 11
67300: IFFALSE 67325
// result := Replace ( result , 3 , p ) ;
67302: LD_ADDR_VAR 0 2
67306: PUSH
67307: LD_VAR 0 2
67311: PPUSH
67312: LD_INT 3
67314: PPUSH
67315: LD_VAR 0 11
67319: PPUSH
67320: CALL_OW 1
67324: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
67325: LD_ADDR_VAR 0 4
67329: PUSH
67330: LD_VAR 0 4
67334: PUSH
67335: LD_VAR 0 6
67339: DIFF
67340: ST_TO_ADDR
// if tmp and eng < 4 then
67341: LD_VAR 0 4
67345: PUSH
67346: LD_VAR 0 6
67350: PUSH
67351: LD_INT 4
67353: LESS
67354: AND
67355: IFFALSE 67545
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
67357: LD_ADDR_VAR 0 9
67361: PUSH
67362: LD_VAR 0 4
67366: PUSH
67367: LD_VAR 0 7
67371: PUSH
67372: LD_VAR 0 6
67376: UNION
67377: DIFF
67378: PPUSH
67379: LD_INT 2
67381: PPUSH
67382: CALL 52695 0 2
67386: ST_TO_ADDR
// p := [ ] ;
67387: LD_ADDR_VAR 0 11
67391: PUSH
67392: EMPTY
67393: ST_TO_ADDR
// if sort then
67394: LD_VAR 0 9
67398: IFFALSE 67514
// for i = 1 to 4 - eng do
67400: LD_ADDR_VAR 0 3
67404: PUSH
67405: DOUBLE
67406: LD_INT 1
67408: DEC
67409: ST_TO_ADDR
67410: LD_INT 4
67412: PUSH
67413: LD_VAR 0 6
67417: MINUS
67418: PUSH
67419: FOR_TO
67420: IFFALSE 67512
// begin if i = sort then
67422: LD_VAR 0 3
67426: PUSH
67427: LD_VAR 0 9
67431: EQUAL
67432: IFFALSE 67436
// break ;
67434: GO 67512
// if GetClass ( i ) = 2 then
67436: LD_VAR 0 3
67440: PPUSH
67441: CALL_OW 257
67445: PUSH
67446: LD_INT 2
67448: EQUAL
67449: IFFALSE 67453
// continue ;
67451: GO 67419
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67453: LD_ADDR_VAR 0 11
67457: PUSH
67458: LD_VAR 0 11
67462: PPUSH
67463: LD_VAR 0 11
67467: PUSH
67468: LD_INT 1
67470: PLUS
67471: PPUSH
67472: LD_VAR 0 9
67476: PUSH
67477: LD_VAR 0 3
67481: ARRAY
67482: PPUSH
67483: CALL_OW 2
67487: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67488: LD_ADDR_VAR 0 4
67492: PUSH
67493: LD_VAR 0 4
67497: PUSH
67498: LD_VAR 0 9
67502: PUSH
67503: LD_VAR 0 3
67507: ARRAY
67508: DIFF
67509: ST_TO_ADDR
// end ;
67510: GO 67419
67512: POP
67513: POP
// if p then
67514: LD_VAR 0 11
67518: IFFALSE 67543
// result := Replace ( result , 2 , p ) ;
67520: LD_ADDR_VAR 0 2
67524: PUSH
67525: LD_VAR 0 2
67529: PPUSH
67530: LD_INT 2
67532: PPUSH
67533: LD_VAR 0 11
67537: PPUSH
67538: CALL_OW 1
67542: ST_TO_ADDR
// end else
67543: GO 67589
// for i = eng downto 5 do
67545: LD_ADDR_VAR 0 3
67549: PUSH
67550: DOUBLE
67551: LD_VAR 0 6
67555: INC
67556: ST_TO_ADDR
67557: LD_INT 5
67559: PUSH
67560: FOR_DOWNTO
67561: IFFALSE 67587
// tmp := tmp union eng [ i ] ;
67563: LD_ADDR_VAR 0 4
67567: PUSH
67568: LD_VAR 0 4
67572: PUSH
67573: LD_VAR 0 6
67577: PUSH
67578: LD_VAR 0 3
67582: ARRAY
67583: UNION
67584: ST_TO_ADDR
67585: GO 67560
67587: POP
67588: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
67589: LD_ADDR_VAR 0 2
67593: PUSH
67594: LD_VAR 0 2
67598: PPUSH
67599: LD_INT 1
67601: PPUSH
67602: LD_VAR 0 4
67606: PUSH
67607: LD_VAR 0 5
67611: DIFF
67612: PPUSH
67613: CALL_OW 1
67617: ST_TO_ADDR
// exit ;
67618: GO 67620
// end ; end ;
67620: LD_VAR 0 2
67624: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
67625: LD_INT 0
67627: PPUSH
67628: PPUSH
67629: PPUSH
// if not mc_bases then
67630: LD_EXP 62
67634: NOT
67635: IFFALSE 67639
// exit ;
67637: GO 67781
// for i = 1 to mc_bases do
67639: LD_ADDR_VAR 0 2
67643: PUSH
67644: DOUBLE
67645: LD_INT 1
67647: DEC
67648: ST_TO_ADDR
67649: LD_EXP 62
67653: PUSH
67654: FOR_TO
67655: IFFALSE 67772
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67657: LD_ADDR_VAR 0 3
67661: PUSH
67662: LD_EXP 62
67666: PUSH
67667: LD_VAR 0 2
67671: ARRAY
67672: PPUSH
67673: LD_INT 21
67675: PUSH
67676: LD_INT 3
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: LD_INT 3
67685: PUSH
67686: LD_INT 2
67688: PUSH
67689: LD_INT 30
67691: PUSH
67692: LD_INT 29
67694: PUSH
67695: EMPTY
67696: LIST
67697: LIST
67698: PUSH
67699: LD_INT 30
67701: PUSH
67702: LD_INT 30
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: PUSH
67709: EMPTY
67710: LIST
67711: LIST
67712: LIST
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: PUSH
67718: LD_INT 3
67720: PUSH
67721: LD_INT 24
67723: PUSH
67724: LD_INT 1000
67726: PUSH
67727: EMPTY
67728: LIST
67729: LIST
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: LIST
67739: PPUSH
67740: CALL_OW 72
67744: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
67745: LD_ADDR_EXP 63
67749: PUSH
67750: LD_EXP 63
67754: PPUSH
67755: LD_VAR 0 2
67759: PPUSH
67760: LD_VAR 0 3
67764: PPUSH
67765: CALL_OW 1
67769: ST_TO_ADDR
// end ;
67770: GO 67654
67772: POP
67773: POP
// RaiseSailEvent ( 101 ) ;
67774: LD_INT 101
67776: PPUSH
67777: CALL_OW 427
// end ;
67781: LD_VAR 0 1
67785: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
67786: LD_INT 0
67788: PPUSH
67789: PPUSH
67790: PPUSH
67791: PPUSH
67792: PPUSH
67793: PPUSH
67794: PPUSH
// if not mc_bases then
67795: LD_EXP 62
67799: NOT
67800: IFFALSE 67804
// exit ;
67802: GO 68366
// for i = 1 to mc_bases do
67804: LD_ADDR_VAR 0 2
67808: PUSH
67809: DOUBLE
67810: LD_INT 1
67812: DEC
67813: ST_TO_ADDR
67814: LD_EXP 62
67818: PUSH
67819: FOR_TO
67820: IFFALSE 68357
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
67822: LD_ADDR_VAR 0 5
67826: PUSH
67827: LD_EXP 62
67831: PUSH
67832: LD_VAR 0 2
67836: ARRAY
67837: PUSH
67838: LD_EXP 91
67842: PUSH
67843: LD_VAR 0 2
67847: ARRAY
67848: UNION
67849: PPUSH
67850: LD_INT 21
67852: PUSH
67853: LD_INT 1
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: PUSH
67860: LD_INT 1
67862: PUSH
67863: LD_INT 3
67865: PUSH
67866: LD_INT 54
67868: PUSH
67869: EMPTY
67870: LIST
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PUSH
67876: LD_INT 3
67878: PUSH
67879: LD_INT 24
67881: PUSH
67882: LD_INT 1000
67884: PUSH
67885: EMPTY
67886: LIST
67887: LIST
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: LIST
67897: PUSH
67898: EMPTY
67899: LIST
67900: LIST
67901: PPUSH
67902: CALL_OW 72
67906: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
67907: LD_ADDR_VAR 0 6
67911: PUSH
67912: LD_EXP 62
67916: PUSH
67917: LD_VAR 0 2
67921: ARRAY
67922: PPUSH
67923: LD_INT 21
67925: PUSH
67926: LD_INT 1
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: PUSH
67933: LD_INT 1
67935: PUSH
67936: LD_INT 3
67938: PUSH
67939: LD_INT 54
67941: PUSH
67942: EMPTY
67943: LIST
67944: PUSH
67945: EMPTY
67946: LIST
67947: LIST
67948: PUSH
67949: LD_INT 3
67951: PUSH
67952: LD_INT 24
67954: PUSH
67955: LD_INT 250
67957: PUSH
67958: EMPTY
67959: LIST
67960: LIST
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: EMPTY
67967: LIST
67968: LIST
67969: LIST
67970: PUSH
67971: EMPTY
67972: LIST
67973: LIST
67974: PPUSH
67975: CALL_OW 72
67979: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
67980: LD_ADDR_VAR 0 7
67984: PUSH
67985: LD_VAR 0 5
67989: PUSH
67990: LD_VAR 0 6
67994: DIFF
67995: ST_TO_ADDR
// if not need_heal_1 then
67996: LD_VAR 0 6
68000: NOT
68001: IFFALSE 68034
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
68003: LD_ADDR_EXP 65
68007: PUSH
68008: LD_EXP 65
68012: PPUSH
68013: LD_VAR 0 2
68017: PUSH
68018: LD_INT 1
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PPUSH
68025: EMPTY
68026: PPUSH
68027: CALL 21462 0 3
68031: ST_TO_ADDR
68032: GO 68104
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
68034: LD_ADDR_EXP 65
68038: PUSH
68039: LD_EXP 65
68043: PPUSH
68044: LD_VAR 0 2
68048: PUSH
68049: LD_INT 1
68051: PUSH
68052: EMPTY
68053: LIST
68054: LIST
68055: PPUSH
68056: LD_EXP 65
68060: PUSH
68061: LD_VAR 0 2
68065: ARRAY
68066: PUSH
68067: LD_INT 1
68069: ARRAY
68070: PPUSH
68071: LD_INT 3
68073: PUSH
68074: LD_INT 24
68076: PUSH
68077: LD_INT 1000
68079: PUSH
68080: EMPTY
68081: LIST
68082: LIST
68083: PUSH
68084: EMPTY
68085: LIST
68086: LIST
68087: PPUSH
68088: CALL_OW 72
68092: PUSH
68093: LD_VAR 0 6
68097: UNION
68098: PPUSH
68099: CALL 21462 0 3
68103: ST_TO_ADDR
// if not need_heal_2 then
68104: LD_VAR 0 7
68108: NOT
68109: IFFALSE 68142
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
68111: LD_ADDR_EXP 65
68115: PUSH
68116: LD_EXP 65
68120: PPUSH
68121: LD_VAR 0 2
68125: PUSH
68126: LD_INT 2
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PPUSH
68133: EMPTY
68134: PPUSH
68135: CALL 21462 0 3
68139: ST_TO_ADDR
68140: GO 68174
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
68142: LD_ADDR_EXP 65
68146: PUSH
68147: LD_EXP 65
68151: PPUSH
68152: LD_VAR 0 2
68156: PUSH
68157: LD_INT 2
68159: PUSH
68160: EMPTY
68161: LIST
68162: LIST
68163: PPUSH
68164: LD_VAR 0 7
68168: PPUSH
68169: CALL 21462 0 3
68173: ST_TO_ADDR
// if need_heal_2 then
68174: LD_VAR 0 7
68178: IFFALSE 68339
// for j in need_heal_2 do
68180: LD_ADDR_VAR 0 3
68184: PUSH
68185: LD_VAR 0 7
68189: PUSH
68190: FOR_IN
68191: IFFALSE 68337
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68193: LD_ADDR_VAR 0 5
68197: PUSH
68198: LD_EXP 62
68202: PUSH
68203: LD_VAR 0 2
68207: ARRAY
68208: PPUSH
68209: LD_INT 2
68211: PUSH
68212: LD_INT 30
68214: PUSH
68215: LD_INT 6
68217: PUSH
68218: EMPTY
68219: LIST
68220: LIST
68221: PUSH
68222: LD_INT 30
68224: PUSH
68225: LD_INT 7
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: LD_INT 30
68234: PUSH
68235: LD_INT 8
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: PUSH
68242: LD_INT 30
68244: PUSH
68245: LD_INT 0
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: LD_INT 30
68254: PUSH
68255: LD_INT 1
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PUSH
68262: EMPTY
68263: LIST
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: PPUSH
68270: CALL_OW 72
68274: ST_TO_ADDR
// if tmp then
68275: LD_VAR 0 5
68279: IFFALSE 68335
// begin k := NearestUnitToUnit ( tmp , j ) ;
68281: LD_ADDR_VAR 0 4
68285: PUSH
68286: LD_VAR 0 5
68290: PPUSH
68291: LD_VAR 0 3
68295: PPUSH
68296: CALL_OW 74
68300: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
68301: LD_VAR 0 3
68305: PPUSH
68306: LD_VAR 0 4
68310: PPUSH
68311: CALL_OW 296
68315: PUSH
68316: LD_INT 5
68318: GREATER
68319: IFFALSE 68335
// ComMoveToNearbyEntrance ( j , k ) ;
68321: LD_VAR 0 3
68325: PPUSH
68326: LD_VAR 0 4
68330: PPUSH
68331: CALL 55068 0 2
// end ; end ;
68335: GO 68190
68337: POP
68338: POP
// if not need_heal_1 and not need_heal_2 then
68339: LD_VAR 0 6
68343: NOT
68344: PUSH
68345: LD_VAR 0 7
68349: NOT
68350: AND
68351: IFFALSE 68355
// continue ;
68353: GO 67819
// end ;
68355: GO 67819
68357: POP
68358: POP
// RaiseSailEvent ( 102 ) ;
68359: LD_INT 102
68361: PPUSH
68362: CALL_OW 427
// end ;
68366: LD_VAR 0 1
68370: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
68371: LD_INT 0
68373: PPUSH
68374: PPUSH
68375: PPUSH
68376: PPUSH
68377: PPUSH
68378: PPUSH
68379: PPUSH
68380: PPUSH
// if not mc_bases then
68381: LD_EXP 62
68385: NOT
68386: IFFALSE 68390
// exit ;
68388: GO 69301
// for i = 1 to mc_bases do
68390: LD_ADDR_VAR 0 2
68394: PUSH
68395: DOUBLE
68396: LD_INT 1
68398: DEC
68399: ST_TO_ADDR
68400: LD_EXP 62
68404: PUSH
68405: FOR_TO
68406: IFFALSE 69299
// begin if not mc_building_need_repair [ i ] then
68408: LD_EXP 63
68412: PUSH
68413: LD_VAR 0 2
68417: ARRAY
68418: NOT
68419: IFFALSE 68604
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
68421: LD_ADDR_VAR 0 6
68425: PUSH
68426: LD_EXP 81
68430: PUSH
68431: LD_VAR 0 2
68435: ARRAY
68436: PPUSH
68437: LD_INT 3
68439: PUSH
68440: LD_INT 24
68442: PUSH
68443: LD_INT 1000
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: PUSH
68454: LD_INT 2
68456: PUSH
68457: LD_INT 34
68459: PUSH
68460: LD_INT 13
68462: PUSH
68463: EMPTY
68464: LIST
68465: LIST
68466: PUSH
68467: LD_INT 34
68469: PUSH
68470: LD_INT 52
68472: PUSH
68473: EMPTY
68474: LIST
68475: LIST
68476: PUSH
68477: LD_INT 34
68479: PUSH
68480: LD_INT 88
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: PUSH
68487: EMPTY
68488: LIST
68489: LIST
68490: LIST
68491: LIST
68492: PUSH
68493: EMPTY
68494: LIST
68495: LIST
68496: PPUSH
68497: CALL_OW 72
68501: ST_TO_ADDR
// if cranes then
68502: LD_VAR 0 6
68506: IFFALSE 68568
// for j in cranes do
68508: LD_ADDR_VAR 0 3
68512: PUSH
68513: LD_VAR 0 6
68517: PUSH
68518: FOR_IN
68519: IFFALSE 68566
// if not IsInArea ( j , mc_parking [ i ] ) then
68521: LD_VAR 0 3
68525: PPUSH
68526: LD_EXP 86
68530: PUSH
68531: LD_VAR 0 2
68535: ARRAY
68536: PPUSH
68537: CALL_OW 308
68541: NOT
68542: IFFALSE 68564
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68544: LD_VAR 0 3
68548: PPUSH
68549: LD_EXP 86
68553: PUSH
68554: LD_VAR 0 2
68558: ARRAY
68559: PPUSH
68560: CALL_OW 113
68564: GO 68518
68566: POP
68567: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
68568: LD_ADDR_EXP 64
68572: PUSH
68573: LD_EXP 64
68577: PPUSH
68578: LD_VAR 0 2
68582: PPUSH
68583: EMPTY
68584: PPUSH
68585: CALL_OW 1
68589: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
68590: LD_VAR 0 2
68594: PPUSH
68595: LD_INT 101
68597: PPUSH
68598: CALL 63444 0 2
// continue ;
68602: GO 68405
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
68604: LD_ADDR_EXP 68
68608: PUSH
68609: LD_EXP 68
68613: PPUSH
68614: LD_VAR 0 2
68618: PPUSH
68619: EMPTY
68620: PPUSH
68621: CALL_OW 1
68625: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
68626: LD_VAR 0 2
68630: PPUSH
68631: LD_INT 103
68633: PPUSH
68634: CALL 63444 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
68638: LD_ADDR_VAR 0 5
68642: PUSH
68643: LD_EXP 62
68647: PUSH
68648: LD_VAR 0 2
68652: ARRAY
68653: PUSH
68654: LD_EXP 91
68658: PUSH
68659: LD_VAR 0 2
68663: ARRAY
68664: UNION
68665: PPUSH
68666: LD_INT 2
68668: PUSH
68669: LD_INT 25
68671: PUSH
68672: LD_INT 2
68674: PUSH
68675: EMPTY
68676: LIST
68677: LIST
68678: PUSH
68679: LD_INT 25
68681: PUSH
68682: LD_INT 16
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: LIST
68693: PUSH
68694: EMPTY
68695: LIST
68696: PPUSH
68697: CALL_OW 72
68701: ST_TO_ADDR
// if mc_need_heal [ i ] then
68702: LD_EXP 65
68706: PUSH
68707: LD_VAR 0 2
68711: ARRAY
68712: IFFALSE 68756
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
68714: LD_ADDR_VAR 0 5
68718: PUSH
68719: LD_VAR 0 5
68723: PUSH
68724: LD_EXP 65
68728: PUSH
68729: LD_VAR 0 2
68733: ARRAY
68734: PUSH
68735: LD_INT 1
68737: ARRAY
68738: PUSH
68739: LD_EXP 65
68743: PUSH
68744: LD_VAR 0 2
68748: ARRAY
68749: PUSH
68750: LD_INT 2
68752: ARRAY
68753: UNION
68754: DIFF
68755: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
68756: LD_ADDR_VAR 0 6
68760: PUSH
68761: LD_EXP 81
68765: PUSH
68766: LD_VAR 0 2
68770: ARRAY
68771: PPUSH
68772: LD_INT 2
68774: PUSH
68775: LD_INT 34
68777: PUSH
68778: LD_INT 13
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: LD_INT 34
68787: PUSH
68788: LD_INT 52
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: LD_INT 34
68797: PUSH
68798: LD_INT 88
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: EMPTY
68806: LIST
68807: LIST
68808: LIST
68809: LIST
68810: PPUSH
68811: CALL_OW 72
68815: ST_TO_ADDR
// if cranes then
68816: LD_VAR 0 6
68820: IFFALSE 68988
// begin for j in cranes do
68822: LD_ADDR_VAR 0 3
68826: PUSH
68827: LD_VAR 0 6
68831: PUSH
68832: FOR_IN
68833: IFFALSE 68986
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
68835: LD_VAR 0 3
68839: PPUSH
68840: CALL_OW 256
68844: PUSH
68845: LD_INT 1000
68847: EQUAL
68848: PUSH
68849: LD_VAR 0 3
68853: PPUSH
68854: CALL_OW 314
68858: NOT
68859: AND
68860: IFFALSE 68926
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
68862: LD_ADDR_VAR 0 8
68866: PUSH
68867: LD_EXP 63
68871: PUSH
68872: LD_VAR 0 2
68876: ARRAY
68877: PPUSH
68878: LD_VAR 0 3
68882: PPUSH
68883: CALL_OW 74
68887: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
68888: LD_VAR 0 8
68892: PPUSH
68893: LD_INT 16
68895: PPUSH
68896: CALL 24427 0 2
68900: PUSH
68901: LD_INT 4
68903: ARRAY
68904: PUSH
68905: LD_INT 10
68907: LESS
68908: IFFALSE 68924
// ComRepairBuilding ( j , to_repair ) ;
68910: LD_VAR 0 3
68914: PPUSH
68915: LD_VAR 0 8
68919: PPUSH
68920: CALL_OW 130
// end else
68924: GO 68984
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
68926: LD_VAR 0 3
68930: PPUSH
68931: CALL_OW 256
68935: PUSH
68936: LD_INT 500
68938: LESS
68939: PUSH
68940: LD_VAR 0 3
68944: PPUSH
68945: LD_EXP 86
68949: PUSH
68950: LD_VAR 0 2
68954: ARRAY
68955: PPUSH
68956: CALL_OW 308
68960: NOT
68961: AND
68962: IFFALSE 68984
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68964: LD_VAR 0 3
68968: PPUSH
68969: LD_EXP 86
68973: PUSH
68974: LD_VAR 0 2
68978: ARRAY
68979: PPUSH
68980: CALL_OW 113
// end ;
68984: GO 68832
68986: POP
68987: POP
// end ; if tmp > 3 then
68988: LD_VAR 0 5
68992: PUSH
68993: LD_INT 3
68995: GREATER
68996: IFFALSE 69016
// tmp := ShrinkArray ( tmp , 4 ) ;
68998: LD_ADDR_VAR 0 5
69002: PUSH
69003: LD_VAR 0 5
69007: PPUSH
69008: LD_INT 4
69010: PPUSH
69011: CALL 54506 0 2
69015: ST_TO_ADDR
// if not tmp then
69016: LD_VAR 0 5
69020: NOT
69021: IFFALSE 69025
// continue ;
69023: GO 68405
// for j in tmp do
69025: LD_ADDR_VAR 0 3
69029: PUSH
69030: LD_VAR 0 5
69034: PUSH
69035: FOR_IN
69036: IFFALSE 69295
// begin if IsInUnit ( j ) then
69038: LD_VAR 0 3
69042: PPUSH
69043: CALL_OW 310
69047: IFFALSE 69058
// ComExitBuilding ( j ) ;
69049: LD_VAR 0 3
69053: PPUSH
69054: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
69058: LD_VAR 0 3
69062: PUSH
69063: LD_EXP 64
69067: PUSH
69068: LD_VAR 0 2
69072: ARRAY
69073: IN
69074: NOT
69075: IFFALSE 69133
// begin SetTag ( j , 101 ) ;
69077: LD_VAR 0 3
69081: PPUSH
69082: LD_INT 101
69084: PPUSH
69085: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
69089: LD_ADDR_EXP 64
69093: PUSH
69094: LD_EXP 64
69098: PPUSH
69099: LD_VAR 0 2
69103: PUSH
69104: LD_EXP 64
69108: PUSH
69109: LD_VAR 0 2
69113: ARRAY
69114: PUSH
69115: LD_INT 1
69117: PLUS
69118: PUSH
69119: EMPTY
69120: LIST
69121: LIST
69122: PPUSH
69123: LD_VAR 0 3
69127: PPUSH
69128: CALL 21462 0 3
69132: ST_TO_ADDR
// end ; wait ( 1 ) ;
69133: LD_INT 1
69135: PPUSH
69136: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
69140: LD_ADDR_VAR 0 7
69144: PUSH
69145: LD_EXP 63
69149: PUSH
69150: LD_VAR 0 2
69154: ARRAY
69155: ST_TO_ADDR
// if mc_scan [ i ] then
69156: LD_EXP 85
69160: PUSH
69161: LD_VAR 0 2
69165: ARRAY
69166: IFFALSE 69228
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
69168: LD_ADDR_VAR 0 7
69172: PUSH
69173: LD_EXP 63
69177: PUSH
69178: LD_VAR 0 2
69182: ARRAY
69183: PPUSH
69184: LD_INT 3
69186: PUSH
69187: LD_INT 30
69189: PUSH
69190: LD_INT 32
69192: PUSH
69193: EMPTY
69194: LIST
69195: LIST
69196: PUSH
69197: LD_INT 30
69199: PUSH
69200: LD_INT 33
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: PUSH
69207: LD_INT 30
69209: PUSH
69210: LD_INT 31
69212: PUSH
69213: EMPTY
69214: LIST
69215: LIST
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: LIST
69221: LIST
69222: PPUSH
69223: CALL_OW 72
69227: ST_TO_ADDR
// if not to_repair_tmp then
69228: LD_VAR 0 7
69232: NOT
69233: IFFALSE 69237
// continue ;
69235: GO 69035
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
69237: LD_ADDR_VAR 0 8
69241: PUSH
69242: LD_VAR 0 7
69246: PPUSH
69247: LD_VAR 0 3
69251: PPUSH
69252: CALL_OW 74
69256: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
69257: LD_VAR 0 8
69261: PPUSH
69262: LD_INT 16
69264: PPUSH
69265: CALL 24427 0 2
69269: PUSH
69270: LD_INT 4
69272: ARRAY
69273: PUSH
69274: LD_INT 14
69276: LESS
69277: IFFALSE 69293
// ComRepairBuilding ( j , to_repair ) ;
69279: LD_VAR 0 3
69283: PPUSH
69284: LD_VAR 0 8
69288: PPUSH
69289: CALL_OW 130
// end ;
69293: GO 69035
69295: POP
69296: POP
// end ;
69297: GO 68405
69299: POP
69300: POP
// end ;
69301: LD_VAR 0 1
69305: RET
// export function MC_Heal ; var i , j , tmp ; begin
69306: LD_INT 0
69308: PPUSH
69309: PPUSH
69310: PPUSH
69311: PPUSH
// if not mc_bases then
69312: LD_EXP 62
69316: NOT
69317: IFFALSE 69321
// exit ;
69319: GO 69723
// for i = 1 to mc_bases do
69321: LD_ADDR_VAR 0 2
69325: PUSH
69326: DOUBLE
69327: LD_INT 1
69329: DEC
69330: ST_TO_ADDR
69331: LD_EXP 62
69335: PUSH
69336: FOR_TO
69337: IFFALSE 69721
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
69339: LD_EXP 65
69343: PUSH
69344: LD_VAR 0 2
69348: ARRAY
69349: PUSH
69350: LD_INT 1
69352: ARRAY
69353: NOT
69354: PUSH
69355: LD_EXP 65
69359: PUSH
69360: LD_VAR 0 2
69364: ARRAY
69365: PUSH
69366: LD_INT 2
69368: ARRAY
69369: NOT
69370: AND
69371: IFFALSE 69409
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
69373: LD_ADDR_EXP 66
69377: PUSH
69378: LD_EXP 66
69382: PPUSH
69383: LD_VAR 0 2
69387: PPUSH
69388: EMPTY
69389: PPUSH
69390: CALL_OW 1
69394: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
69395: LD_VAR 0 2
69399: PPUSH
69400: LD_INT 102
69402: PPUSH
69403: CALL 63444 0 2
// continue ;
69407: GO 69336
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
69409: LD_ADDR_VAR 0 4
69413: PUSH
69414: LD_EXP 62
69418: PUSH
69419: LD_VAR 0 2
69423: ARRAY
69424: PPUSH
69425: LD_INT 25
69427: PUSH
69428: LD_INT 4
69430: PUSH
69431: EMPTY
69432: LIST
69433: LIST
69434: PPUSH
69435: CALL_OW 72
69439: ST_TO_ADDR
// if not tmp then
69440: LD_VAR 0 4
69444: NOT
69445: IFFALSE 69449
// continue ;
69447: GO 69336
// if mc_taming [ i ] then
69449: LD_EXP 93
69453: PUSH
69454: LD_VAR 0 2
69458: ARRAY
69459: IFFALSE 69483
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69461: LD_ADDR_EXP 93
69465: PUSH
69466: LD_EXP 93
69470: PPUSH
69471: LD_VAR 0 2
69475: PPUSH
69476: EMPTY
69477: PPUSH
69478: CALL_OW 1
69482: ST_TO_ADDR
// for j in tmp do
69483: LD_ADDR_VAR 0 3
69487: PUSH
69488: LD_VAR 0 4
69492: PUSH
69493: FOR_IN
69494: IFFALSE 69717
// begin if IsInUnit ( j ) then
69496: LD_VAR 0 3
69500: PPUSH
69501: CALL_OW 310
69505: IFFALSE 69516
// ComExitBuilding ( j ) ;
69507: LD_VAR 0 3
69511: PPUSH
69512: CALL_OW 122
// if not j in mc_healers [ i ] then
69516: LD_VAR 0 3
69520: PUSH
69521: LD_EXP 66
69525: PUSH
69526: LD_VAR 0 2
69530: ARRAY
69531: IN
69532: NOT
69533: IFFALSE 69579
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
69535: LD_ADDR_EXP 66
69539: PUSH
69540: LD_EXP 66
69544: PPUSH
69545: LD_VAR 0 2
69549: PUSH
69550: LD_EXP 66
69554: PUSH
69555: LD_VAR 0 2
69559: ARRAY
69560: PUSH
69561: LD_INT 1
69563: PLUS
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: PPUSH
69569: LD_VAR 0 3
69573: PPUSH
69574: CALL 21462 0 3
69578: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
69579: LD_VAR 0 3
69583: PPUSH
69584: CALL_OW 110
69588: PUSH
69589: LD_INT 102
69591: NONEQUAL
69592: IFFALSE 69606
// SetTag ( j , 102 ) ;
69594: LD_VAR 0 3
69598: PPUSH
69599: LD_INT 102
69601: PPUSH
69602: CALL_OW 109
// Wait ( 3 ) ;
69606: LD_INT 3
69608: PPUSH
69609: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
69613: LD_EXP 65
69617: PUSH
69618: LD_VAR 0 2
69622: ARRAY
69623: PUSH
69624: LD_INT 1
69626: ARRAY
69627: IFFALSE 69659
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
69629: LD_VAR 0 3
69633: PPUSH
69634: LD_EXP 65
69638: PUSH
69639: LD_VAR 0 2
69643: ARRAY
69644: PUSH
69645: LD_INT 1
69647: ARRAY
69648: PUSH
69649: LD_INT 1
69651: ARRAY
69652: PPUSH
69653: CALL_OW 128
69657: GO 69715
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
69659: LD_VAR 0 3
69663: PPUSH
69664: CALL_OW 314
69668: NOT
69669: PUSH
69670: LD_EXP 65
69674: PUSH
69675: LD_VAR 0 2
69679: ARRAY
69680: PUSH
69681: LD_INT 2
69683: ARRAY
69684: AND
69685: IFFALSE 69715
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
69687: LD_VAR 0 3
69691: PPUSH
69692: LD_EXP 65
69696: PUSH
69697: LD_VAR 0 2
69701: ARRAY
69702: PUSH
69703: LD_INT 2
69705: ARRAY
69706: PUSH
69707: LD_INT 1
69709: ARRAY
69710: PPUSH
69711: CALL_OW 128
// end ;
69715: GO 69493
69717: POP
69718: POP
// end ;
69719: GO 69336
69721: POP
69722: POP
// end ;
69723: LD_VAR 0 1
69727: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
69728: LD_INT 0
69730: PPUSH
69731: PPUSH
69732: PPUSH
69733: PPUSH
69734: PPUSH
69735: PPUSH
// if not mc_bases then
69736: LD_EXP 62
69740: NOT
69741: IFFALSE 69745
// exit ;
69743: GO 70908
// for i = 1 to mc_bases do
69745: LD_ADDR_VAR 0 2
69749: PUSH
69750: DOUBLE
69751: LD_INT 1
69753: DEC
69754: ST_TO_ADDR
69755: LD_EXP 62
69759: PUSH
69760: FOR_TO
69761: IFFALSE 70906
// begin if mc_scan [ i ] then
69763: LD_EXP 85
69767: PUSH
69768: LD_VAR 0 2
69772: ARRAY
69773: IFFALSE 69777
// continue ;
69775: GO 69760
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
69777: LD_EXP 67
69781: PUSH
69782: LD_VAR 0 2
69786: ARRAY
69787: NOT
69788: PUSH
69789: LD_EXP 69
69793: PUSH
69794: LD_VAR 0 2
69798: ARRAY
69799: NOT
69800: AND
69801: PUSH
69802: LD_EXP 68
69806: PUSH
69807: LD_VAR 0 2
69811: ARRAY
69812: AND
69813: IFFALSE 69851
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
69815: LD_ADDR_EXP 68
69819: PUSH
69820: LD_EXP 68
69824: PPUSH
69825: LD_VAR 0 2
69829: PPUSH
69830: EMPTY
69831: PPUSH
69832: CALL_OW 1
69836: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
69837: LD_VAR 0 2
69841: PPUSH
69842: LD_INT 103
69844: PPUSH
69845: CALL 63444 0 2
// continue ;
69849: GO 69760
// end ; if mc_construct_list [ i ] then
69851: LD_EXP 69
69855: PUSH
69856: LD_VAR 0 2
69860: ARRAY
69861: IFFALSE 70081
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
69863: LD_ADDR_VAR 0 5
69867: PUSH
69868: LD_EXP 62
69872: PUSH
69873: LD_VAR 0 2
69877: ARRAY
69878: PPUSH
69879: LD_INT 25
69881: PUSH
69882: LD_INT 2
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PPUSH
69889: CALL_OW 72
69893: PUSH
69894: LD_EXP 64
69898: PUSH
69899: LD_VAR 0 2
69903: ARRAY
69904: DIFF
69905: ST_TO_ADDR
// if not tmp then
69906: LD_VAR 0 5
69910: NOT
69911: IFFALSE 69915
// continue ;
69913: GO 69760
// for j in tmp do
69915: LD_ADDR_VAR 0 3
69919: PUSH
69920: LD_VAR 0 5
69924: PUSH
69925: FOR_IN
69926: IFFALSE 70077
// begin if not mc_builders [ i ] then
69928: LD_EXP 68
69932: PUSH
69933: LD_VAR 0 2
69937: ARRAY
69938: NOT
69939: IFFALSE 69997
// begin SetTag ( j , 103 ) ;
69941: LD_VAR 0 3
69945: PPUSH
69946: LD_INT 103
69948: PPUSH
69949: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
69953: LD_ADDR_EXP 68
69957: PUSH
69958: LD_EXP 68
69962: PPUSH
69963: LD_VAR 0 2
69967: PUSH
69968: LD_EXP 68
69972: PUSH
69973: LD_VAR 0 2
69977: ARRAY
69978: PUSH
69979: LD_INT 1
69981: PLUS
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PPUSH
69987: LD_VAR 0 3
69991: PPUSH
69992: CALL 21462 0 3
69996: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
69997: LD_VAR 0 3
70001: PPUSH
70002: CALL_OW 310
70006: IFFALSE 70017
// ComExitBuilding ( j ) ;
70008: LD_VAR 0 3
70012: PPUSH
70013: CALL_OW 122
// wait ( 3 ) ;
70017: LD_INT 3
70019: PPUSH
70020: CALL_OW 67
// if not mc_construct_list [ i ] then
70024: LD_EXP 69
70028: PUSH
70029: LD_VAR 0 2
70033: ARRAY
70034: NOT
70035: IFFALSE 70039
// break ;
70037: GO 70077
// if not HasTask ( j ) then
70039: LD_VAR 0 3
70043: PPUSH
70044: CALL_OW 314
70048: NOT
70049: IFFALSE 70075
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
70051: LD_VAR 0 3
70055: PPUSH
70056: LD_EXP 69
70060: PUSH
70061: LD_VAR 0 2
70065: ARRAY
70066: PUSH
70067: LD_INT 1
70069: ARRAY
70070: PPUSH
70071: CALL 24700 0 2
// end ;
70075: GO 69925
70077: POP
70078: POP
// end else
70079: GO 70904
// if mc_build_list [ i ] then
70081: LD_EXP 67
70085: PUSH
70086: LD_VAR 0 2
70090: ARRAY
70091: IFFALSE 70904
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
70093: LD_EXP 67
70097: PUSH
70098: LD_VAR 0 2
70102: ARRAY
70103: PUSH
70104: LD_INT 1
70106: ARRAY
70107: PUSH
70108: LD_INT 1
70110: ARRAY
70111: PPUSH
70112: CALL 24524 0 1
70116: PUSH
70117: LD_EXP 62
70121: PUSH
70122: LD_VAR 0 2
70126: ARRAY
70127: PPUSH
70128: LD_INT 2
70130: PUSH
70131: LD_INT 30
70133: PUSH
70134: LD_INT 2
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 30
70143: PUSH
70144: LD_INT 3
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: LIST
70155: PPUSH
70156: CALL_OW 72
70160: NOT
70161: AND
70162: IFFALSE 70267
// begin for j = 1 to mc_build_list [ i ] do
70164: LD_ADDR_VAR 0 3
70168: PUSH
70169: DOUBLE
70170: LD_INT 1
70172: DEC
70173: ST_TO_ADDR
70174: LD_EXP 67
70178: PUSH
70179: LD_VAR 0 2
70183: ARRAY
70184: PUSH
70185: FOR_TO
70186: IFFALSE 70265
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
70188: LD_EXP 67
70192: PUSH
70193: LD_VAR 0 2
70197: ARRAY
70198: PUSH
70199: LD_VAR 0 3
70203: ARRAY
70204: PUSH
70205: LD_INT 1
70207: ARRAY
70208: PUSH
70209: LD_INT 2
70211: EQUAL
70212: IFFALSE 70263
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
70214: LD_ADDR_EXP 67
70218: PUSH
70219: LD_EXP 67
70223: PPUSH
70224: LD_VAR 0 2
70228: PPUSH
70229: LD_EXP 67
70233: PUSH
70234: LD_VAR 0 2
70238: ARRAY
70239: PPUSH
70240: LD_VAR 0 3
70244: PPUSH
70245: LD_INT 1
70247: PPUSH
70248: LD_INT 0
70250: PPUSH
70251: CALL 20880 0 4
70255: PPUSH
70256: CALL_OW 1
70260: ST_TO_ADDR
// break ;
70261: GO 70265
// end ;
70263: GO 70185
70265: POP
70266: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70267: LD_ADDR_VAR 0 6
70271: PUSH
70272: LD_EXP 62
70276: PUSH
70277: LD_VAR 0 2
70281: ARRAY
70282: PPUSH
70283: LD_INT 2
70285: PUSH
70286: LD_INT 30
70288: PUSH
70289: LD_INT 0
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: PUSH
70296: LD_INT 30
70298: PUSH
70299: LD_INT 1
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: LIST
70310: PPUSH
70311: CALL_OW 72
70315: ST_TO_ADDR
// for k := 1 to depot do
70316: LD_ADDR_VAR 0 4
70320: PUSH
70321: DOUBLE
70322: LD_INT 1
70324: DEC
70325: ST_TO_ADDR
70326: LD_VAR 0 6
70330: PUSH
70331: FOR_TO
70332: IFFALSE 70902
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
70334: LD_EXP 67
70338: PUSH
70339: LD_VAR 0 2
70343: ARRAY
70344: PUSH
70345: LD_INT 1
70347: ARRAY
70348: PUSH
70349: LD_INT 1
70351: ARRAY
70352: PUSH
70353: LD_INT 0
70355: EQUAL
70356: PUSH
70357: LD_VAR 0 6
70361: PUSH
70362: LD_VAR 0 4
70366: ARRAY
70367: PPUSH
70368: LD_EXP 67
70372: PUSH
70373: LD_VAR 0 2
70377: ARRAY
70378: PUSH
70379: LD_INT 1
70381: ARRAY
70382: PUSH
70383: LD_INT 1
70385: ARRAY
70386: PPUSH
70387: LD_EXP 67
70391: PUSH
70392: LD_VAR 0 2
70396: ARRAY
70397: PUSH
70398: LD_INT 1
70400: ARRAY
70401: PUSH
70402: LD_INT 2
70404: ARRAY
70405: PPUSH
70406: LD_EXP 67
70410: PUSH
70411: LD_VAR 0 2
70415: ARRAY
70416: PUSH
70417: LD_INT 1
70419: ARRAY
70420: PUSH
70421: LD_INT 3
70423: ARRAY
70424: PPUSH
70425: LD_EXP 67
70429: PUSH
70430: LD_VAR 0 2
70434: ARRAY
70435: PUSH
70436: LD_INT 1
70438: ARRAY
70439: PUSH
70440: LD_INT 4
70442: ARRAY
70443: PPUSH
70444: CALL 29936 0 5
70448: OR
70449: IFFALSE 70730
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
70451: LD_ADDR_VAR 0 5
70455: PUSH
70456: LD_EXP 62
70460: PUSH
70461: LD_VAR 0 2
70465: ARRAY
70466: PPUSH
70467: LD_INT 25
70469: PUSH
70470: LD_INT 2
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PPUSH
70477: CALL_OW 72
70481: PUSH
70482: LD_EXP 64
70486: PUSH
70487: LD_VAR 0 2
70491: ARRAY
70492: DIFF
70493: ST_TO_ADDR
// if not tmp then
70494: LD_VAR 0 5
70498: NOT
70499: IFFALSE 70503
// continue ;
70501: GO 70331
// for j in tmp do
70503: LD_ADDR_VAR 0 3
70507: PUSH
70508: LD_VAR 0 5
70512: PUSH
70513: FOR_IN
70514: IFFALSE 70726
// begin if not mc_builders [ i ] then
70516: LD_EXP 68
70520: PUSH
70521: LD_VAR 0 2
70525: ARRAY
70526: NOT
70527: IFFALSE 70585
// begin SetTag ( j , 103 ) ;
70529: LD_VAR 0 3
70533: PPUSH
70534: LD_INT 103
70536: PPUSH
70537: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
70541: LD_ADDR_EXP 68
70545: PUSH
70546: LD_EXP 68
70550: PPUSH
70551: LD_VAR 0 2
70555: PUSH
70556: LD_EXP 68
70560: PUSH
70561: LD_VAR 0 2
70565: ARRAY
70566: PUSH
70567: LD_INT 1
70569: PLUS
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: PPUSH
70575: LD_VAR 0 3
70579: PPUSH
70580: CALL 21462 0 3
70584: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
70585: LD_VAR 0 3
70589: PPUSH
70590: CALL_OW 310
70594: IFFALSE 70605
// ComExitBuilding ( j ) ;
70596: LD_VAR 0 3
70600: PPUSH
70601: CALL_OW 122
// wait ( 3 ) ;
70605: LD_INT 3
70607: PPUSH
70608: CALL_OW 67
// if not mc_build_list [ i ] then
70612: LD_EXP 67
70616: PUSH
70617: LD_VAR 0 2
70621: ARRAY
70622: NOT
70623: IFFALSE 70627
// break ;
70625: GO 70726
// if not HasTask ( j ) then
70627: LD_VAR 0 3
70631: PPUSH
70632: CALL_OW 314
70636: NOT
70637: IFFALSE 70724
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
70639: LD_VAR 0 3
70643: PPUSH
70644: LD_EXP 67
70648: PUSH
70649: LD_VAR 0 2
70653: ARRAY
70654: PUSH
70655: LD_INT 1
70657: ARRAY
70658: PUSH
70659: LD_INT 1
70661: ARRAY
70662: PPUSH
70663: LD_EXP 67
70667: PUSH
70668: LD_VAR 0 2
70672: ARRAY
70673: PUSH
70674: LD_INT 1
70676: ARRAY
70677: PUSH
70678: LD_INT 2
70680: ARRAY
70681: PPUSH
70682: LD_EXP 67
70686: PUSH
70687: LD_VAR 0 2
70691: ARRAY
70692: PUSH
70693: LD_INT 1
70695: ARRAY
70696: PUSH
70697: LD_INT 3
70699: ARRAY
70700: PPUSH
70701: LD_EXP 67
70705: PUSH
70706: LD_VAR 0 2
70710: ARRAY
70711: PUSH
70712: LD_INT 1
70714: ARRAY
70715: PUSH
70716: LD_INT 4
70718: ARRAY
70719: PPUSH
70720: CALL_OW 145
// end ;
70724: GO 70513
70726: POP
70727: POP
// end else
70728: GO 70900
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
70730: LD_EXP 62
70734: PUSH
70735: LD_VAR 0 2
70739: ARRAY
70740: PPUSH
70741: LD_EXP 67
70745: PUSH
70746: LD_VAR 0 2
70750: ARRAY
70751: PUSH
70752: LD_INT 1
70754: ARRAY
70755: PUSH
70756: LD_INT 1
70758: ARRAY
70759: PPUSH
70760: LD_EXP 67
70764: PUSH
70765: LD_VAR 0 2
70769: ARRAY
70770: PUSH
70771: LD_INT 1
70773: ARRAY
70774: PUSH
70775: LD_INT 2
70777: ARRAY
70778: PPUSH
70779: LD_EXP 67
70783: PUSH
70784: LD_VAR 0 2
70788: ARRAY
70789: PUSH
70790: LD_INT 1
70792: ARRAY
70793: PUSH
70794: LD_INT 3
70796: ARRAY
70797: PPUSH
70798: LD_EXP 67
70802: PUSH
70803: LD_VAR 0 2
70807: ARRAY
70808: PUSH
70809: LD_INT 1
70811: ARRAY
70812: PUSH
70813: LD_INT 4
70815: ARRAY
70816: PPUSH
70817: LD_EXP 62
70821: PUSH
70822: LD_VAR 0 2
70826: ARRAY
70827: PPUSH
70828: LD_INT 21
70830: PUSH
70831: LD_INT 3
70833: PUSH
70834: EMPTY
70835: LIST
70836: LIST
70837: PPUSH
70838: CALL_OW 72
70842: PPUSH
70843: EMPTY
70844: PPUSH
70845: CALL 28690 0 7
70849: NOT
70850: IFFALSE 70900
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
70852: LD_ADDR_EXP 67
70856: PUSH
70857: LD_EXP 67
70861: PPUSH
70862: LD_VAR 0 2
70866: PPUSH
70867: LD_EXP 67
70871: PUSH
70872: LD_VAR 0 2
70876: ARRAY
70877: PPUSH
70878: LD_INT 1
70880: PPUSH
70881: LD_INT 1
70883: NEG
70884: PPUSH
70885: LD_INT 0
70887: PPUSH
70888: CALL 20880 0 4
70892: PPUSH
70893: CALL_OW 1
70897: ST_TO_ADDR
// continue ;
70898: GO 70331
// end ; end ;
70900: GO 70331
70902: POP
70903: POP
// end ; end ;
70904: GO 69760
70906: POP
70907: POP
// end ;
70908: LD_VAR 0 1
70912: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
70913: LD_INT 0
70915: PPUSH
70916: PPUSH
70917: PPUSH
70918: PPUSH
70919: PPUSH
70920: PPUSH
// if not mc_bases then
70921: LD_EXP 62
70925: NOT
70926: IFFALSE 70930
// exit ;
70928: GO 71357
// for i = 1 to mc_bases do
70930: LD_ADDR_VAR 0 2
70934: PUSH
70935: DOUBLE
70936: LD_INT 1
70938: DEC
70939: ST_TO_ADDR
70940: LD_EXP 62
70944: PUSH
70945: FOR_TO
70946: IFFALSE 71355
// begin tmp := mc_build_upgrade [ i ] ;
70948: LD_ADDR_VAR 0 4
70952: PUSH
70953: LD_EXP 94
70957: PUSH
70958: LD_VAR 0 2
70962: ARRAY
70963: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
70964: LD_ADDR_VAR 0 6
70968: PUSH
70969: LD_EXP 95
70973: PUSH
70974: LD_VAR 0 2
70978: ARRAY
70979: PPUSH
70980: LD_INT 2
70982: PUSH
70983: LD_INT 30
70985: PUSH
70986: LD_INT 6
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 30
70995: PUSH
70996: LD_INT 7
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: LIST
71007: PPUSH
71008: CALL_OW 72
71012: ST_TO_ADDR
// if not tmp and not lab then
71013: LD_VAR 0 4
71017: NOT
71018: PUSH
71019: LD_VAR 0 6
71023: NOT
71024: AND
71025: IFFALSE 71029
// continue ;
71027: GO 70945
// if tmp then
71029: LD_VAR 0 4
71033: IFFALSE 71153
// for j in tmp do
71035: LD_ADDR_VAR 0 3
71039: PUSH
71040: LD_VAR 0 4
71044: PUSH
71045: FOR_IN
71046: IFFALSE 71151
// begin if UpgradeCost ( j ) then
71048: LD_VAR 0 3
71052: PPUSH
71053: CALL 28350 0 1
71057: IFFALSE 71149
// begin ComUpgrade ( j ) ;
71059: LD_VAR 0 3
71063: PPUSH
71064: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
71068: LD_ADDR_EXP 94
71072: PUSH
71073: LD_EXP 94
71077: PPUSH
71078: LD_VAR 0 2
71082: PPUSH
71083: LD_EXP 94
71087: PUSH
71088: LD_VAR 0 2
71092: ARRAY
71093: PUSH
71094: LD_VAR 0 3
71098: DIFF
71099: PPUSH
71100: CALL_OW 1
71104: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
71105: LD_ADDR_EXP 69
71109: PUSH
71110: LD_EXP 69
71114: PPUSH
71115: LD_VAR 0 2
71119: PUSH
71120: LD_EXP 69
71124: PUSH
71125: LD_VAR 0 2
71129: ARRAY
71130: PUSH
71131: LD_INT 1
71133: PLUS
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PPUSH
71139: LD_VAR 0 3
71143: PPUSH
71144: CALL 21462 0 3
71148: ST_TO_ADDR
// end ; end ;
71149: GO 71045
71151: POP
71152: POP
// if not lab or not mc_lab_upgrade [ i ] then
71153: LD_VAR 0 6
71157: NOT
71158: PUSH
71159: LD_EXP 96
71163: PUSH
71164: LD_VAR 0 2
71168: ARRAY
71169: NOT
71170: OR
71171: IFFALSE 71175
// continue ;
71173: GO 70945
// for j in lab do
71175: LD_ADDR_VAR 0 3
71179: PUSH
71180: LD_VAR 0 6
71184: PUSH
71185: FOR_IN
71186: IFFALSE 71351
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
71188: LD_VAR 0 3
71192: PPUSH
71193: CALL_OW 266
71197: PUSH
71198: LD_INT 6
71200: PUSH
71201: LD_INT 7
71203: PUSH
71204: EMPTY
71205: LIST
71206: LIST
71207: IN
71208: PUSH
71209: LD_VAR 0 3
71213: PPUSH
71214: CALL_OW 461
71218: PUSH
71219: LD_INT 1
71221: NONEQUAL
71222: AND
71223: IFFALSE 71349
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
71225: LD_VAR 0 3
71229: PPUSH
71230: LD_EXP 96
71234: PUSH
71235: LD_VAR 0 2
71239: ARRAY
71240: PUSH
71241: LD_INT 1
71243: ARRAY
71244: PPUSH
71245: CALL 28555 0 2
71249: IFFALSE 71349
// begin ComCancel ( j ) ;
71251: LD_VAR 0 3
71255: PPUSH
71256: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
71260: LD_VAR 0 3
71264: PPUSH
71265: LD_EXP 96
71269: PUSH
71270: LD_VAR 0 2
71274: ARRAY
71275: PUSH
71276: LD_INT 1
71278: ARRAY
71279: PPUSH
71280: CALL_OW 207
// if not j in mc_construct_list [ i ] then
71284: LD_VAR 0 3
71288: PUSH
71289: LD_EXP 69
71293: PUSH
71294: LD_VAR 0 2
71298: ARRAY
71299: IN
71300: NOT
71301: IFFALSE 71347
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
71303: LD_ADDR_EXP 69
71307: PUSH
71308: LD_EXP 69
71312: PPUSH
71313: LD_VAR 0 2
71317: PUSH
71318: LD_EXP 69
71322: PUSH
71323: LD_VAR 0 2
71327: ARRAY
71328: PUSH
71329: LD_INT 1
71331: PLUS
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: PPUSH
71337: LD_VAR 0 3
71341: PPUSH
71342: CALL 21462 0 3
71346: ST_TO_ADDR
// break ;
71347: GO 71351
// end ; end ; end ;
71349: GO 71185
71351: POP
71352: POP
// end ;
71353: GO 70945
71355: POP
71356: POP
// end ;
71357: LD_VAR 0 1
71361: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
71362: LD_INT 0
71364: PPUSH
71365: PPUSH
71366: PPUSH
71367: PPUSH
71368: PPUSH
71369: PPUSH
71370: PPUSH
71371: PPUSH
71372: PPUSH
// if not mc_bases then
71373: LD_EXP 62
71377: NOT
71378: IFFALSE 71382
// exit ;
71380: GO 71787
// for i = 1 to mc_bases do
71382: LD_ADDR_VAR 0 2
71386: PUSH
71387: DOUBLE
71388: LD_INT 1
71390: DEC
71391: ST_TO_ADDR
71392: LD_EXP 62
71396: PUSH
71397: FOR_TO
71398: IFFALSE 71785
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
71400: LD_EXP 70
71404: PUSH
71405: LD_VAR 0 2
71409: ARRAY
71410: NOT
71411: PUSH
71412: LD_EXP 62
71416: PUSH
71417: LD_VAR 0 2
71421: ARRAY
71422: PPUSH
71423: LD_INT 30
71425: PUSH
71426: LD_INT 3
71428: PUSH
71429: EMPTY
71430: LIST
71431: LIST
71432: PPUSH
71433: CALL_OW 72
71437: NOT
71438: OR
71439: IFFALSE 71443
// continue ;
71441: GO 71397
// busy := false ;
71443: LD_ADDR_VAR 0 8
71447: PUSH
71448: LD_INT 0
71450: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71451: LD_ADDR_VAR 0 4
71455: PUSH
71456: LD_EXP 62
71460: PUSH
71461: LD_VAR 0 2
71465: ARRAY
71466: PPUSH
71467: LD_INT 30
71469: PUSH
71470: LD_INT 3
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PPUSH
71477: CALL_OW 72
71481: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
71482: LD_ADDR_VAR 0 6
71486: PUSH
71487: LD_EXP 70
71491: PUSH
71492: LD_VAR 0 2
71496: ARRAY
71497: PPUSH
71498: LD_INT 2
71500: PUSH
71501: LD_INT 30
71503: PUSH
71504: LD_INT 32
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 30
71513: PUSH
71514: LD_INT 33
71516: PUSH
71517: EMPTY
71518: LIST
71519: LIST
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: LIST
71525: PPUSH
71526: CALL_OW 72
71530: ST_TO_ADDR
// if not t then
71531: LD_VAR 0 6
71535: NOT
71536: IFFALSE 71540
// continue ;
71538: GO 71397
// for j in tmp do
71540: LD_ADDR_VAR 0 3
71544: PUSH
71545: LD_VAR 0 4
71549: PUSH
71550: FOR_IN
71551: IFFALSE 71581
// if not BuildingStatus ( j ) = bs_idle then
71553: LD_VAR 0 3
71557: PPUSH
71558: CALL_OW 461
71562: PUSH
71563: LD_INT 2
71565: EQUAL
71566: NOT
71567: IFFALSE 71579
// begin busy := true ;
71569: LD_ADDR_VAR 0 8
71573: PUSH
71574: LD_INT 1
71576: ST_TO_ADDR
// break ;
71577: GO 71581
// end ;
71579: GO 71550
71581: POP
71582: POP
// if busy then
71583: LD_VAR 0 8
71587: IFFALSE 71591
// continue ;
71589: GO 71397
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
71591: LD_ADDR_VAR 0 7
71595: PUSH
71596: LD_VAR 0 6
71600: PPUSH
71601: LD_INT 35
71603: PUSH
71604: LD_INT 0
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: PPUSH
71611: CALL_OW 72
71615: ST_TO_ADDR
// if tw then
71616: LD_VAR 0 7
71620: IFFALSE 71697
// begin tw := tw [ 1 ] ;
71622: LD_ADDR_VAR 0 7
71626: PUSH
71627: LD_VAR 0 7
71631: PUSH
71632: LD_INT 1
71634: ARRAY
71635: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
71636: LD_ADDR_VAR 0 9
71640: PUSH
71641: LD_VAR 0 7
71645: PPUSH
71646: LD_EXP 87
71650: PUSH
71651: LD_VAR 0 2
71655: ARRAY
71656: PPUSH
71657: CALL 26847 0 2
71661: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
71662: LD_EXP 101
71666: PUSH
71667: LD_VAR 0 2
71671: ARRAY
71672: IFFALSE 71695
// if not weapon in mc_allowed_tower_weapons [ i ] then
71674: LD_VAR 0 9
71678: PUSH
71679: LD_EXP 101
71683: PUSH
71684: LD_VAR 0 2
71688: ARRAY
71689: IN
71690: NOT
71691: IFFALSE 71695
// continue ;
71693: GO 71397
// end else
71695: GO 71760
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
71697: LD_ADDR_VAR 0 5
71701: PUSH
71702: LD_EXP 70
71706: PUSH
71707: LD_VAR 0 2
71711: ARRAY
71712: PPUSH
71713: LD_VAR 0 4
71717: PPUSH
71718: CALL 53739 0 2
71722: ST_TO_ADDR
// if not tmp2 then
71723: LD_VAR 0 5
71727: NOT
71728: IFFALSE 71732
// continue ;
71730: GO 71397
// tw := tmp2 [ 1 ] ;
71732: LD_ADDR_VAR 0 7
71736: PUSH
71737: LD_VAR 0 5
71741: PUSH
71742: LD_INT 1
71744: ARRAY
71745: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
71746: LD_ADDR_VAR 0 9
71750: PUSH
71751: LD_VAR 0 5
71755: PUSH
71756: LD_INT 2
71758: ARRAY
71759: ST_TO_ADDR
// end ; if not weapon then
71760: LD_VAR 0 9
71764: NOT
71765: IFFALSE 71769
// continue ;
71767: GO 71397
// ComPlaceWeapon ( tw , weapon ) ;
71769: LD_VAR 0 7
71773: PPUSH
71774: LD_VAR 0 9
71778: PPUSH
71779: CALL_OW 148
// end ;
71783: GO 71397
71785: POP
71786: POP
// end ;
71787: LD_VAR 0 1
71791: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
71792: LD_INT 0
71794: PPUSH
71795: PPUSH
71796: PPUSH
71797: PPUSH
71798: PPUSH
71799: PPUSH
71800: PPUSH
// if not mc_bases then
71801: LD_EXP 62
71805: NOT
71806: IFFALSE 71810
// exit ;
71808: GO 72585
// for i = 1 to mc_bases do
71810: LD_ADDR_VAR 0 2
71814: PUSH
71815: DOUBLE
71816: LD_INT 1
71818: DEC
71819: ST_TO_ADDR
71820: LD_EXP 62
71824: PUSH
71825: FOR_TO
71826: IFFALSE 72583
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
71828: LD_EXP 75
71832: PUSH
71833: LD_VAR 0 2
71837: ARRAY
71838: NOT
71839: PUSH
71840: LD_EXP 75
71844: PUSH
71845: LD_VAR 0 2
71849: ARRAY
71850: PUSH
71851: LD_EXP 76
71855: PUSH
71856: LD_VAR 0 2
71860: ARRAY
71861: EQUAL
71862: OR
71863: PUSH
71864: LD_EXP 85
71868: PUSH
71869: LD_VAR 0 2
71873: ARRAY
71874: OR
71875: IFFALSE 71879
// continue ;
71877: GO 71825
// if mc_miners [ i ] then
71879: LD_EXP 76
71883: PUSH
71884: LD_VAR 0 2
71888: ARRAY
71889: IFFALSE 72270
// begin for j = mc_miners [ i ] downto 1 do
71891: LD_ADDR_VAR 0 3
71895: PUSH
71896: DOUBLE
71897: LD_EXP 76
71901: PUSH
71902: LD_VAR 0 2
71906: ARRAY
71907: INC
71908: ST_TO_ADDR
71909: LD_INT 1
71911: PUSH
71912: FOR_DOWNTO
71913: IFFALSE 72268
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
71915: LD_EXP 76
71919: PUSH
71920: LD_VAR 0 2
71924: ARRAY
71925: PUSH
71926: LD_VAR 0 3
71930: ARRAY
71931: PPUSH
71932: CALL_OW 301
71936: PUSH
71937: LD_EXP 76
71941: PUSH
71942: LD_VAR 0 2
71946: ARRAY
71947: PUSH
71948: LD_VAR 0 3
71952: ARRAY
71953: PPUSH
71954: CALL_OW 257
71958: PUSH
71959: LD_INT 1
71961: NONEQUAL
71962: OR
71963: IFFALSE 72026
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
71965: LD_ADDR_VAR 0 5
71969: PUSH
71970: LD_EXP 76
71974: PUSH
71975: LD_VAR 0 2
71979: ARRAY
71980: PUSH
71981: LD_EXP 76
71985: PUSH
71986: LD_VAR 0 2
71990: ARRAY
71991: PUSH
71992: LD_VAR 0 3
71996: ARRAY
71997: DIFF
71998: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
71999: LD_ADDR_EXP 76
72003: PUSH
72004: LD_EXP 76
72008: PPUSH
72009: LD_VAR 0 2
72013: PPUSH
72014: LD_VAR 0 5
72018: PPUSH
72019: CALL_OW 1
72023: ST_TO_ADDR
// continue ;
72024: GO 71912
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
72026: LD_EXP 76
72030: PUSH
72031: LD_VAR 0 2
72035: ARRAY
72036: PUSH
72037: LD_VAR 0 3
72041: ARRAY
72042: PPUSH
72043: CALL_OW 257
72047: PUSH
72048: LD_INT 1
72050: EQUAL
72051: PUSH
72052: LD_EXP 76
72056: PUSH
72057: LD_VAR 0 2
72061: ARRAY
72062: PUSH
72063: LD_VAR 0 3
72067: ARRAY
72068: PPUSH
72069: CALL_OW 459
72073: NOT
72074: AND
72075: PUSH
72076: LD_EXP 76
72080: PUSH
72081: LD_VAR 0 2
72085: ARRAY
72086: PUSH
72087: LD_VAR 0 3
72091: ARRAY
72092: PPUSH
72093: CALL_OW 314
72097: NOT
72098: AND
72099: IFFALSE 72266
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
72101: LD_EXP 76
72105: PUSH
72106: LD_VAR 0 2
72110: ARRAY
72111: PUSH
72112: LD_VAR 0 3
72116: ARRAY
72117: PPUSH
72118: CALL_OW 310
72122: IFFALSE 72145
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
72124: LD_EXP 76
72128: PUSH
72129: LD_VAR 0 2
72133: ARRAY
72134: PUSH
72135: LD_VAR 0 3
72139: ARRAY
72140: PPUSH
72141: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
72145: LD_EXP 76
72149: PUSH
72150: LD_VAR 0 2
72154: ARRAY
72155: PUSH
72156: LD_VAR 0 3
72160: ARRAY
72161: PPUSH
72162: CALL_OW 314
72166: NOT
72167: IFFALSE 72266
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
72169: LD_ADDR_VAR 0 7
72173: PUSH
72174: LD_VAR 0 3
72178: PUSH
72179: LD_EXP 75
72183: PUSH
72184: LD_VAR 0 2
72188: ARRAY
72189: PPUSH
72190: CALL 18602 0 1
72194: MOD
72195: PUSH
72196: LD_INT 1
72198: PLUS
72199: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
72200: LD_EXP 76
72204: PUSH
72205: LD_VAR 0 2
72209: ARRAY
72210: PUSH
72211: LD_VAR 0 3
72215: ARRAY
72216: PPUSH
72217: LD_EXP 75
72221: PUSH
72222: LD_VAR 0 2
72226: ARRAY
72227: PUSH
72228: LD_VAR 0 7
72232: ARRAY
72233: PUSH
72234: LD_INT 1
72236: ARRAY
72237: PPUSH
72238: LD_EXP 75
72242: PUSH
72243: LD_VAR 0 2
72247: ARRAY
72248: PUSH
72249: LD_VAR 0 7
72253: ARRAY
72254: PUSH
72255: LD_INT 2
72257: ARRAY
72258: PPUSH
72259: LD_INT 0
72261: PPUSH
72262: CALL_OW 193
// end ; end ; end ;
72266: GO 71912
72268: POP
72269: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
72270: LD_ADDR_VAR 0 5
72274: PUSH
72275: LD_EXP 62
72279: PUSH
72280: LD_VAR 0 2
72284: ARRAY
72285: PPUSH
72286: LD_INT 2
72288: PUSH
72289: LD_INT 30
72291: PUSH
72292: LD_INT 4
72294: PUSH
72295: EMPTY
72296: LIST
72297: LIST
72298: PUSH
72299: LD_INT 30
72301: PUSH
72302: LD_INT 5
72304: PUSH
72305: EMPTY
72306: LIST
72307: LIST
72308: PUSH
72309: LD_INT 30
72311: PUSH
72312: LD_INT 32
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: LIST
72323: LIST
72324: PPUSH
72325: CALL_OW 72
72329: ST_TO_ADDR
// if not tmp then
72330: LD_VAR 0 5
72334: NOT
72335: IFFALSE 72339
// continue ;
72337: GO 71825
// list := [ ] ;
72339: LD_ADDR_VAR 0 6
72343: PUSH
72344: EMPTY
72345: ST_TO_ADDR
// for j in tmp do
72346: LD_ADDR_VAR 0 3
72350: PUSH
72351: LD_VAR 0 5
72355: PUSH
72356: FOR_IN
72357: IFFALSE 72426
// begin for k in UnitsInside ( j ) do
72359: LD_ADDR_VAR 0 4
72363: PUSH
72364: LD_VAR 0 3
72368: PPUSH
72369: CALL_OW 313
72373: PUSH
72374: FOR_IN
72375: IFFALSE 72422
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
72377: LD_VAR 0 4
72381: PPUSH
72382: CALL_OW 257
72386: PUSH
72387: LD_INT 1
72389: EQUAL
72390: PUSH
72391: LD_VAR 0 4
72395: PPUSH
72396: CALL_OW 459
72400: NOT
72401: AND
72402: IFFALSE 72420
// list := list ^ k ;
72404: LD_ADDR_VAR 0 6
72408: PUSH
72409: LD_VAR 0 6
72413: PUSH
72414: LD_VAR 0 4
72418: ADD
72419: ST_TO_ADDR
72420: GO 72374
72422: POP
72423: POP
// end ;
72424: GO 72356
72426: POP
72427: POP
// list := list diff mc_miners [ i ] ;
72428: LD_ADDR_VAR 0 6
72432: PUSH
72433: LD_VAR 0 6
72437: PUSH
72438: LD_EXP 76
72442: PUSH
72443: LD_VAR 0 2
72447: ARRAY
72448: DIFF
72449: ST_TO_ADDR
// if not list then
72450: LD_VAR 0 6
72454: NOT
72455: IFFALSE 72459
// continue ;
72457: GO 71825
// k := mc_mines [ i ] - mc_miners [ i ] ;
72459: LD_ADDR_VAR 0 4
72463: PUSH
72464: LD_EXP 75
72468: PUSH
72469: LD_VAR 0 2
72473: ARRAY
72474: PUSH
72475: LD_EXP 76
72479: PUSH
72480: LD_VAR 0 2
72484: ARRAY
72485: MINUS
72486: ST_TO_ADDR
// if k > list then
72487: LD_VAR 0 4
72491: PUSH
72492: LD_VAR 0 6
72496: GREATER
72497: IFFALSE 72509
// k := list ;
72499: LD_ADDR_VAR 0 4
72503: PUSH
72504: LD_VAR 0 6
72508: ST_TO_ADDR
// for j = 1 to k do
72509: LD_ADDR_VAR 0 3
72513: PUSH
72514: DOUBLE
72515: LD_INT 1
72517: DEC
72518: ST_TO_ADDR
72519: LD_VAR 0 4
72523: PUSH
72524: FOR_TO
72525: IFFALSE 72579
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
72527: LD_ADDR_EXP 76
72531: PUSH
72532: LD_EXP 76
72536: PPUSH
72537: LD_VAR 0 2
72541: PUSH
72542: LD_EXP 76
72546: PUSH
72547: LD_VAR 0 2
72551: ARRAY
72552: PUSH
72553: LD_INT 1
72555: PLUS
72556: PUSH
72557: EMPTY
72558: LIST
72559: LIST
72560: PPUSH
72561: LD_VAR 0 6
72565: PUSH
72566: LD_VAR 0 3
72570: ARRAY
72571: PPUSH
72572: CALL 21462 0 3
72576: ST_TO_ADDR
72577: GO 72524
72579: POP
72580: POP
// end ;
72581: GO 71825
72583: POP
72584: POP
// end ;
72585: LD_VAR 0 1
72589: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
72590: LD_INT 0
72592: PPUSH
72593: PPUSH
72594: PPUSH
72595: PPUSH
72596: PPUSH
72597: PPUSH
72598: PPUSH
72599: PPUSH
72600: PPUSH
72601: PPUSH
72602: PPUSH
// if not mc_bases then
72603: LD_EXP 62
72607: NOT
72608: IFFALSE 72612
// exit ;
72610: GO 74435
// for i = 1 to mc_bases do
72612: LD_ADDR_VAR 0 2
72616: PUSH
72617: DOUBLE
72618: LD_INT 1
72620: DEC
72621: ST_TO_ADDR
72622: LD_EXP 62
72626: PUSH
72627: FOR_TO
72628: IFFALSE 74433
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
72630: LD_EXP 62
72634: PUSH
72635: LD_VAR 0 2
72639: ARRAY
72640: NOT
72641: PUSH
72642: LD_EXP 69
72646: PUSH
72647: LD_VAR 0 2
72651: ARRAY
72652: OR
72653: IFFALSE 72657
// continue ;
72655: GO 72627
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
72657: LD_EXP 78
72661: PUSH
72662: LD_VAR 0 2
72666: ARRAY
72667: NOT
72668: PUSH
72669: LD_EXP 79
72673: PUSH
72674: LD_VAR 0 2
72678: ARRAY
72679: AND
72680: IFFALSE 72718
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
72682: LD_ADDR_EXP 79
72686: PUSH
72687: LD_EXP 79
72691: PPUSH
72692: LD_VAR 0 2
72696: PPUSH
72697: EMPTY
72698: PPUSH
72699: CALL_OW 1
72703: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
72704: LD_VAR 0 2
72708: PPUSH
72709: LD_INT 107
72711: PPUSH
72712: CALL 63444 0 2
// continue ;
72716: GO 72627
// end ; target := [ ] ;
72718: LD_ADDR_VAR 0 7
72722: PUSH
72723: EMPTY
72724: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72725: LD_ADDR_VAR 0 6
72729: PUSH
72730: LD_EXP 62
72734: PUSH
72735: LD_VAR 0 2
72739: ARRAY
72740: PUSH
72741: LD_INT 1
72743: ARRAY
72744: PPUSH
72745: CALL_OW 255
72749: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72750: LD_ADDR_VAR 0 9
72754: PUSH
72755: LD_EXP 62
72759: PUSH
72760: LD_VAR 0 2
72764: ARRAY
72765: PPUSH
72766: LD_INT 2
72768: PUSH
72769: LD_INT 30
72771: PUSH
72772: LD_INT 0
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: PUSH
72779: LD_INT 30
72781: PUSH
72782: LD_INT 1
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: PUSH
72789: EMPTY
72790: LIST
72791: LIST
72792: LIST
72793: PPUSH
72794: CALL_OW 72
72798: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
72799: LD_ADDR_VAR 0 3
72803: PUSH
72804: DOUBLE
72805: LD_EXP 78
72809: PUSH
72810: LD_VAR 0 2
72814: ARRAY
72815: INC
72816: ST_TO_ADDR
72817: LD_INT 1
72819: PUSH
72820: FOR_DOWNTO
72821: IFFALSE 73066
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
72823: LD_EXP 78
72827: PUSH
72828: LD_VAR 0 2
72832: ARRAY
72833: PUSH
72834: LD_VAR 0 3
72838: ARRAY
72839: PUSH
72840: LD_INT 2
72842: ARRAY
72843: PPUSH
72844: LD_EXP 78
72848: PUSH
72849: LD_VAR 0 2
72853: ARRAY
72854: PUSH
72855: LD_VAR 0 3
72859: ARRAY
72860: PUSH
72861: LD_INT 3
72863: ARRAY
72864: PPUSH
72865: CALL_OW 488
72869: PUSH
72870: LD_EXP 78
72874: PUSH
72875: LD_VAR 0 2
72879: ARRAY
72880: PUSH
72881: LD_VAR 0 3
72885: ARRAY
72886: PUSH
72887: LD_INT 2
72889: ARRAY
72890: PPUSH
72891: LD_EXP 78
72895: PUSH
72896: LD_VAR 0 2
72900: ARRAY
72901: PUSH
72902: LD_VAR 0 3
72906: ARRAY
72907: PUSH
72908: LD_INT 3
72910: ARRAY
72911: PPUSH
72912: CALL_OW 284
72916: PUSH
72917: LD_INT 0
72919: EQUAL
72920: AND
72921: IFFALSE 72976
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
72923: LD_ADDR_VAR 0 5
72927: PUSH
72928: LD_EXP 78
72932: PUSH
72933: LD_VAR 0 2
72937: ARRAY
72938: PPUSH
72939: LD_VAR 0 3
72943: PPUSH
72944: CALL_OW 3
72948: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
72949: LD_ADDR_EXP 78
72953: PUSH
72954: LD_EXP 78
72958: PPUSH
72959: LD_VAR 0 2
72963: PPUSH
72964: LD_VAR 0 5
72968: PPUSH
72969: CALL_OW 1
72973: ST_TO_ADDR
// continue ;
72974: GO 72820
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
72976: LD_VAR 0 6
72980: PPUSH
72981: LD_EXP 78
72985: PUSH
72986: LD_VAR 0 2
72990: ARRAY
72991: PUSH
72992: LD_VAR 0 3
72996: ARRAY
72997: PUSH
72998: LD_INT 2
73000: ARRAY
73001: PPUSH
73002: LD_EXP 78
73006: PUSH
73007: LD_VAR 0 2
73011: ARRAY
73012: PUSH
73013: LD_VAR 0 3
73017: ARRAY
73018: PUSH
73019: LD_INT 3
73021: ARRAY
73022: PPUSH
73023: LD_INT 30
73025: PPUSH
73026: CALL 22726 0 4
73030: PUSH
73031: LD_INT 4
73033: ARRAY
73034: PUSH
73035: LD_INT 0
73037: EQUAL
73038: IFFALSE 73064
// begin target := mc_crates [ i ] [ j ] ;
73040: LD_ADDR_VAR 0 7
73044: PUSH
73045: LD_EXP 78
73049: PUSH
73050: LD_VAR 0 2
73054: ARRAY
73055: PUSH
73056: LD_VAR 0 3
73060: ARRAY
73061: ST_TO_ADDR
// break ;
73062: GO 73066
// end ; end ;
73064: GO 72820
73066: POP
73067: POP
// if not target then
73068: LD_VAR 0 7
73072: NOT
73073: IFFALSE 73077
// continue ;
73075: GO 72627
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
73077: LD_ADDR_VAR 0 8
73081: PUSH
73082: LD_EXP 81
73086: PUSH
73087: LD_VAR 0 2
73091: ARRAY
73092: PPUSH
73093: LD_INT 2
73095: PUSH
73096: LD_INT 3
73098: PUSH
73099: LD_INT 58
73101: PUSH
73102: EMPTY
73103: LIST
73104: PUSH
73105: EMPTY
73106: LIST
73107: LIST
73108: PUSH
73109: LD_INT 61
73111: PUSH
73112: EMPTY
73113: LIST
73114: PUSH
73115: LD_INT 33
73117: PUSH
73118: LD_INT 5
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: PUSH
73125: LD_INT 33
73127: PUSH
73128: LD_INT 3
73130: PUSH
73131: EMPTY
73132: LIST
73133: LIST
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: PUSH
73142: LD_INT 2
73144: PUSH
73145: LD_INT 34
73147: PUSH
73148: LD_INT 32
73150: PUSH
73151: EMPTY
73152: LIST
73153: LIST
73154: PUSH
73155: LD_INT 34
73157: PUSH
73158: LD_INT 51
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 34
73167: PUSH
73168: LD_INT 12
73170: PUSH
73171: EMPTY
73172: LIST
73173: LIST
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: LIST
73179: LIST
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PPUSH
73185: CALL_OW 72
73189: ST_TO_ADDR
// if not cargo then
73190: LD_VAR 0 8
73194: NOT
73195: IFFALSE 73901
// begin if mc_crates_collector [ i ] < 5 then
73197: LD_EXP 79
73201: PUSH
73202: LD_VAR 0 2
73206: ARRAY
73207: PUSH
73208: LD_INT 5
73210: LESS
73211: IFFALSE 73577
// begin if mc_ape [ i ] then
73213: LD_EXP 91
73217: PUSH
73218: LD_VAR 0 2
73222: ARRAY
73223: IFFALSE 73270
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
73225: LD_ADDR_VAR 0 5
73229: PUSH
73230: LD_EXP 91
73234: PUSH
73235: LD_VAR 0 2
73239: ARRAY
73240: PPUSH
73241: LD_INT 25
73243: PUSH
73244: LD_INT 16
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PUSH
73251: LD_INT 24
73253: PUSH
73254: LD_INT 750
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PPUSH
73265: CALL_OW 72
73269: ST_TO_ADDR
// if not tmp then
73270: LD_VAR 0 5
73274: NOT
73275: IFFALSE 73322
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
73277: LD_ADDR_VAR 0 5
73281: PUSH
73282: LD_EXP 62
73286: PUSH
73287: LD_VAR 0 2
73291: ARRAY
73292: PPUSH
73293: LD_INT 25
73295: PUSH
73296: LD_INT 2
73298: PUSH
73299: EMPTY
73300: LIST
73301: LIST
73302: PUSH
73303: LD_INT 24
73305: PUSH
73306: LD_INT 750
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: PUSH
73313: EMPTY
73314: LIST
73315: LIST
73316: PPUSH
73317: CALL_OW 72
73321: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
73322: LD_EXP 91
73326: PUSH
73327: LD_VAR 0 2
73331: ARRAY
73332: PUSH
73333: LD_EXP 62
73337: PUSH
73338: LD_VAR 0 2
73342: ARRAY
73343: PPUSH
73344: LD_INT 25
73346: PUSH
73347: LD_INT 2
73349: PUSH
73350: EMPTY
73351: LIST
73352: LIST
73353: PUSH
73354: LD_INT 24
73356: PUSH
73357: LD_INT 750
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: PPUSH
73368: CALL_OW 72
73372: AND
73373: PUSH
73374: LD_VAR 0 5
73378: PUSH
73379: LD_INT 5
73381: LESS
73382: AND
73383: IFFALSE 73465
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
73385: LD_ADDR_VAR 0 3
73389: PUSH
73390: LD_EXP 62
73394: PUSH
73395: LD_VAR 0 2
73399: ARRAY
73400: PPUSH
73401: LD_INT 25
73403: PUSH
73404: LD_INT 2
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 24
73413: PUSH
73414: LD_INT 750
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: PPUSH
73425: CALL_OW 72
73429: PUSH
73430: FOR_IN
73431: IFFALSE 73463
// begin tmp := tmp union j ;
73433: LD_ADDR_VAR 0 5
73437: PUSH
73438: LD_VAR 0 5
73442: PUSH
73443: LD_VAR 0 3
73447: UNION
73448: ST_TO_ADDR
// if tmp >= 5 then
73449: LD_VAR 0 5
73453: PUSH
73454: LD_INT 5
73456: GREATEREQUAL
73457: IFFALSE 73461
// break ;
73459: GO 73463
// end ;
73461: GO 73430
73463: POP
73464: POP
// end ; if not tmp then
73465: LD_VAR 0 5
73469: NOT
73470: IFFALSE 73474
// continue ;
73472: GO 72627
// for j in tmp do
73474: LD_ADDR_VAR 0 3
73478: PUSH
73479: LD_VAR 0 5
73483: PUSH
73484: FOR_IN
73485: IFFALSE 73575
// if not GetTag ( j ) then
73487: LD_VAR 0 3
73491: PPUSH
73492: CALL_OW 110
73496: NOT
73497: IFFALSE 73573
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
73499: LD_ADDR_EXP 79
73503: PUSH
73504: LD_EXP 79
73508: PPUSH
73509: LD_VAR 0 2
73513: PUSH
73514: LD_EXP 79
73518: PUSH
73519: LD_VAR 0 2
73523: ARRAY
73524: PUSH
73525: LD_INT 1
73527: PLUS
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: PPUSH
73533: LD_VAR 0 3
73537: PPUSH
73538: CALL 21462 0 3
73542: ST_TO_ADDR
// SetTag ( j , 107 ) ;
73543: LD_VAR 0 3
73547: PPUSH
73548: LD_INT 107
73550: PPUSH
73551: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
73555: LD_EXP 79
73559: PUSH
73560: LD_VAR 0 2
73564: ARRAY
73565: PUSH
73566: LD_INT 5
73568: GREATEREQUAL
73569: IFFALSE 73573
// break ;
73571: GO 73575
// end ;
73573: GO 73484
73575: POP
73576: POP
// end ; if mc_crates_collector [ i ] and target then
73577: LD_EXP 79
73581: PUSH
73582: LD_VAR 0 2
73586: ARRAY
73587: PUSH
73588: LD_VAR 0 7
73592: AND
73593: IFFALSE 73899
// begin if mc_crates_collector [ i ] < target [ 1 ] then
73595: LD_EXP 79
73599: PUSH
73600: LD_VAR 0 2
73604: ARRAY
73605: PUSH
73606: LD_VAR 0 7
73610: PUSH
73611: LD_INT 1
73613: ARRAY
73614: LESS
73615: IFFALSE 73635
// tmp := mc_crates_collector [ i ] else
73617: LD_ADDR_VAR 0 5
73621: PUSH
73622: LD_EXP 79
73626: PUSH
73627: LD_VAR 0 2
73631: ARRAY
73632: ST_TO_ADDR
73633: GO 73649
// tmp := target [ 1 ] ;
73635: LD_ADDR_VAR 0 5
73639: PUSH
73640: LD_VAR 0 7
73644: PUSH
73645: LD_INT 1
73647: ARRAY
73648: ST_TO_ADDR
// k := 0 ;
73649: LD_ADDR_VAR 0 4
73653: PUSH
73654: LD_INT 0
73656: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
73657: LD_ADDR_VAR 0 3
73661: PUSH
73662: LD_EXP 79
73666: PUSH
73667: LD_VAR 0 2
73671: ARRAY
73672: PUSH
73673: FOR_IN
73674: IFFALSE 73897
// begin k := k + 1 ;
73676: LD_ADDR_VAR 0 4
73680: PUSH
73681: LD_VAR 0 4
73685: PUSH
73686: LD_INT 1
73688: PLUS
73689: ST_TO_ADDR
// if k > tmp then
73690: LD_VAR 0 4
73694: PUSH
73695: LD_VAR 0 5
73699: GREATER
73700: IFFALSE 73704
// break ;
73702: GO 73897
// if not GetClass ( j ) in [ 2 , 16 ] then
73704: LD_VAR 0 3
73708: PPUSH
73709: CALL_OW 257
73713: PUSH
73714: LD_INT 2
73716: PUSH
73717: LD_INT 16
73719: PUSH
73720: EMPTY
73721: LIST
73722: LIST
73723: IN
73724: NOT
73725: IFFALSE 73778
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
73727: LD_ADDR_EXP 79
73731: PUSH
73732: LD_EXP 79
73736: PPUSH
73737: LD_VAR 0 2
73741: PPUSH
73742: LD_EXP 79
73746: PUSH
73747: LD_VAR 0 2
73751: ARRAY
73752: PUSH
73753: LD_VAR 0 3
73757: DIFF
73758: PPUSH
73759: CALL_OW 1
73763: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73764: LD_VAR 0 3
73768: PPUSH
73769: LD_INT 0
73771: PPUSH
73772: CALL_OW 109
// continue ;
73776: GO 73673
// end ; if IsInUnit ( j ) then
73778: LD_VAR 0 3
73782: PPUSH
73783: CALL_OW 310
73787: IFFALSE 73798
// ComExitBuilding ( j ) ;
73789: LD_VAR 0 3
73793: PPUSH
73794: CALL_OW 122
// wait ( 3 ) ;
73798: LD_INT 3
73800: PPUSH
73801: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
73805: LD_VAR 0 3
73809: PPUSH
73810: CALL_OW 314
73814: PUSH
73815: LD_VAR 0 6
73819: PPUSH
73820: LD_VAR 0 7
73824: PUSH
73825: LD_INT 2
73827: ARRAY
73828: PPUSH
73829: LD_VAR 0 7
73833: PUSH
73834: LD_INT 3
73836: ARRAY
73837: PPUSH
73838: LD_INT 30
73840: PPUSH
73841: CALL 22726 0 4
73845: PUSH
73846: LD_INT 4
73848: ARRAY
73849: AND
73850: IFFALSE 73868
// ComStandNearbyBuilding ( j , depot ) else
73852: LD_VAR 0 3
73856: PPUSH
73857: LD_VAR 0 9
73861: PPUSH
73862: CALL 18064 0 2
73866: GO 73895
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
73868: LD_VAR 0 3
73872: PPUSH
73873: LD_VAR 0 7
73877: PUSH
73878: LD_INT 2
73880: ARRAY
73881: PPUSH
73882: LD_VAR 0 7
73886: PUSH
73887: LD_INT 3
73889: ARRAY
73890: PPUSH
73891: CALL_OW 117
// end ;
73895: GO 73673
73897: POP
73898: POP
// end ; end else
73899: GO 74431
// begin for j in cargo do
73901: LD_ADDR_VAR 0 3
73905: PUSH
73906: LD_VAR 0 8
73910: PUSH
73911: FOR_IN
73912: IFFALSE 74429
// begin if GetTag ( j ) <> 0 then
73914: LD_VAR 0 3
73918: PPUSH
73919: CALL_OW 110
73923: PUSH
73924: LD_INT 0
73926: NONEQUAL
73927: IFFALSE 73931
// continue ;
73929: GO 73911
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
73931: LD_VAR 0 3
73935: PPUSH
73936: CALL_OW 256
73940: PUSH
73941: LD_INT 1000
73943: LESS
73944: PUSH
73945: LD_VAR 0 3
73949: PPUSH
73950: LD_EXP 86
73954: PUSH
73955: LD_VAR 0 2
73959: ARRAY
73960: PPUSH
73961: CALL_OW 308
73965: NOT
73966: AND
73967: IFFALSE 73989
// ComMoveToArea ( j , mc_parking [ i ] ) ;
73969: LD_VAR 0 3
73973: PPUSH
73974: LD_EXP 86
73978: PUSH
73979: LD_VAR 0 2
73983: ARRAY
73984: PPUSH
73985: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
73989: LD_VAR 0 3
73993: PPUSH
73994: CALL_OW 256
73998: PUSH
73999: LD_INT 1000
74001: LESS
74002: PUSH
74003: LD_VAR 0 3
74007: PPUSH
74008: LD_EXP 86
74012: PUSH
74013: LD_VAR 0 2
74017: ARRAY
74018: PPUSH
74019: CALL_OW 308
74023: AND
74024: IFFALSE 74028
// continue ;
74026: GO 73911
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
74028: LD_VAR 0 3
74032: PPUSH
74033: CALL_OW 262
74037: PUSH
74038: LD_INT 2
74040: EQUAL
74041: PUSH
74042: LD_VAR 0 3
74046: PPUSH
74047: CALL_OW 261
74051: PUSH
74052: LD_INT 15
74054: LESS
74055: AND
74056: IFFALSE 74060
// continue ;
74058: GO 73911
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
74060: LD_VAR 0 3
74064: PPUSH
74065: CALL_OW 262
74069: PUSH
74070: LD_INT 1
74072: EQUAL
74073: PUSH
74074: LD_VAR 0 3
74078: PPUSH
74079: CALL_OW 261
74083: PUSH
74084: LD_INT 10
74086: LESS
74087: AND
74088: IFFALSE 74368
// begin if not depot then
74090: LD_VAR 0 9
74094: NOT
74095: IFFALSE 74099
// continue ;
74097: GO 73911
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
74099: LD_VAR 0 3
74103: PPUSH
74104: LD_VAR 0 9
74108: PPUSH
74109: LD_VAR 0 3
74113: PPUSH
74114: CALL_OW 74
74118: PPUSH
74119: CALL_OW 296
74123: PUSH
74124: LD_INT 6
74126: LESS
74127: IFFALSE 74143
// SetFuel ( j , 100 ) else
74129: LD_VAR 0 3
74133: PPUSH
74134: LD_INT 100
74136: PPUSH
74137: CALL_OW 240
74141: GO 74368
// if GetFuel ( j ) = 0 then
74143: LD_VAR 0 3
74147: PPUSH
74148: CALL_OW 261
74152: PUSH
74153: LD_INT 0
74155: EQUAL
74156: IFFALSE 74368
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
74158: LD_ADDR_EXP 81
74162: PUSH
74163: LD_EXP 81
74167: PPUSH
74168: LD_VAR 0 2
74172: PPUSH
74173: LD_EXP 81
74177: PUSH
74178: LD_VAR 0 2
74182: ARRAY
74183: PUSH
74184: LD_VAR 0 3
74188: DIFF
74189: PPUSH
74190: CALL_OW 1
74194: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
74195: LD_VAR 0 3
74199: PPUSH
74200: CALL_OW 263
74204: PUSH
74205: LD_INT 1
74207: EQUAL
74208: IFFALSE 74224
// ComExitVehicle ( IsInUnit ( j ) ) ;
74210: LD_VAR 0 3
74214: PPUSH
74215: CALL_OW 310
74219: PPUSH
74220: CALL_OW 121
// if GetControl ( j ) = control_remote then
74224: LD_VAR 0 3
74228: PPUSH
74229: CALL_OW 263
74233: PUSH
74234: LD_INT 2
74236: EQUAL
74237: IFFALSE 74248
// ComUnlink ( j ) ;
74239: LD_VAR 0 3
74243: PPUSH
74244: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
74248: LD_ADDR_VAR 0 10
74252: PUSH
74253: LD_VAR 0 2
74257: PPUSH
74258: LD_INT 3
74260: PPUSH
74261: CALL 84012 0 2
74265: ST_TO_ADDR
// if fac then
74266: LD_VAR 0 10
74270: IFFALSE 74366
// begin for k in fac do
74272: LD_ADDR_VAR 0 4
74276: PUSH
74277: LD_VAR 0 10
74281: PUSH
74282: FOR_IN
74283: IFFALSE 74364
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
74285: LD_ADDR_VAR 0 11
74289: PUSH
74290: LD_VAR 0 10
74294: PPUSH
74295: LD_VAR 0 3
74299: PPUSH
74300: CALL_OW 265
74304: PPUSH
74305: LD_VAR 0 3
74309: PPUSH
74310: CALL_OW 262
74314: PPUSH
74315: LD_VAR 0 3
74319: PPUSH
74320: CALL_OW 263
74324: PPUSH
74325: LD_VAR 0 3
74329: PPUSH
74330: CALL_OW 264
74334: PPUSH
74335: CALL 18960 0 5
74339: ST_TO_ADDR
// if components then
74340: LD_VAR 0 11
74344: IFFALSE 74362
// begin MC_InsertProduceList ( i , components ) ;
74346: LD_VAR 0 2
74350: PPUSH
74351: LD_VAR 0 11
74355: PPUSH
74356: CALL 83557 0 2
// break ;
74360: GO 74364
// end ; end ;
74362: GO 74282
74364: POP
74365: POP
// end ; continue ;
74366: GO 73911
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
74368: LD_VAR 0 3
74372: PPUSH
74373: LD_INT 1
74375: PPUSH
74376: CALL_OW 289
74380: PUSH
74381: LD_INT 100
74383: LESS
74384: PUSH
74385: LD_VAR 0 3
74389: PPUSH
74390: CALL_OW 314
74394: NOT
74395: AND
74396: IFFALSE 74425
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
74398: LD_VAR 0 3
74402: PPUSH
74403: LD_VAR 0 7
74407: PUSH
74408: LD_INT 2
74410: ARRAY
74411: PPUSH
74412: LD_VAR 0 7
74416: PUSH
74417: LD_INT 3
74419: ARRAY
74420: PPUSH
74421: CALL_OW 117
// break ;
74425: GO 74429
// end ;
74427: GO 73911
74429: POP
74430: POP
// end ; end ;
74431: GO 72627
74433: POP
74434: POP
// end ;
74435: LD_VAR 0 1
74439: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
74440: LD_INT 0
74442: PPUSH
74443: PPUSH
74444: PPUSH
74445: PPUSH
// if not mc_bases then
74446: LD_EXP 62
74450: NOT
74451: IFFALSE 74455
// exit ;
74453: GO 74616
// for i = 1 to mc_bases do
74455: LD_ADDR_VAR 0 2
74459: PUSH
74460: DOUBLE
74461: LD_INT 1
74463: DEC
74464: ST_TO_ADDR
74465: LD_EXP 62
74469: PUSH
74470: FOR_TO
74471: IFFALSE 74614
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
74473: LD_ADDR_VAR 0 4
74477: PUSH
74478: LD_EXP 81
74482: PUSH
74483: LD_VAR 0 2
74487: ARRAY
74488: PUSH
74489: LD_EXP 84
74493: PUSH
74494: LD_VAR 0 2
74498: ARRAY
74499: UNION
74500: PPUSH
74501: LD_INT 33
74503: PUSH
74504: LD_INT 2
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PPUSH
74511: CALL_OW 72
74515: ST_TO_ADDR
// if tmp then
74516: LD_VAR 0 4
74520: IFFALSE 74612
// for j in tmp do
74522: LD_ADDR_VAR 0 3
74526: PUSH
74527: LD_VAR 0 4
74531: PUSH
74532: FOR_IN
74533: IFFALSE 74610
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
74535: LD_VAR 0 3
74539: PPUSH
74540: CALL_OW 312
74544: NOT
74545: PUSH
74546: LD_VAR 0 3
74550: PPUSH
74551: CALL_OW 256
74555: PUSH
74556: LD_INT 250
74558: GREATEREQUAL
74559: AND
74560: IFFALSE 74573
// Connect ( j ) else
74562: LD_VAR 0 3
74566: PPUSH
74567: CALL 24808 0 1
74571: GO 74608
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
74573: LD_VAR 0 3
74577: PPUSH
74578: CALL_OW 256
74582: PUSH
74583: LD_INT 250
74585: LESS
74586: PUSH
74587: LD_VAR 0 3
74591: PPUSH
74592: CALL_OW 312
74596: AND
74597: IFFALSE 74608
// ComUnlink ( j ) ;
74599: LD_VAR 0 3
74603: PPUSH
74604: CALL_OW 136
74608: GO 74532
74610: POP
74611: POP
// end ;
74612: GO 74470
74614: POP
74615: POP
// end ;
74616: LD_VAR 0 1
74620: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
74621: LD_INT 0
74623: PPUSH
74624: PPUSH
74625: PPUSH
74626: PPUSH
74627: PPUSH
// if not mc_bases then
74628: LD_EXP 62
74632: NOT
74633: IFFALSE 74637
// exit ;
74635: GO 75082
// for i = 1 to mc_bases do
74637: LD_ADDR_VAR 0 2
74641: PUSH
74642: DOUBLE
74643: LD_INT 1
74645: DEC
74646: ST_TO_ADDR
74647: LD_EXP 62
74651: PUSH
74652: FOR_TO
74653: IFFALSE 75080
// begin if not mc_produce [ i ] then
74655: LD_EXP 83
74659: PUSH
74660: LD_VAR 0 2
74664: ARRAY
74665: NOT
74666: IFFALSE 74670
// continue ;
74668: GO 74652
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74670: LD_ADDR_VAR 0 5
74674: PUSH
74675: LD_EXP 62
74679: PUSH
74680: LD_VAR 0 2
74684: ARRAY
74685: PPUSH
74686: LD_INT 30
74688: PUSH
74689: LD_INT 3
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: PPUSH
74696: CALL_OW 72
74700: ST_TO_ADDR
// if not fac then
74701: LD_VAR 0 5
74705: NOT
74706: IFFALSE 74710
// continue ;
74708: GO 74652
// for j in fac do
74710: LD_ADDR_VAR 0 3
74714: PUSH
74715: LD_VAR 0 5
74719: PUSH
74720: FOR_IN
74721: IFFALSE 75076
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
74723: LD_VAR 0 3
74727: PPUSH
74728: CALL_OW 461
74732: PUSH
74733: LD_INT 2
74735: NONEQUAL
74736: PUSH
74737: LD_VAR 0 3
74741: PPUSH
74742: LD_INT 15
74744: PPUSH
74745: CALL 24427 0 2
74749: PUSH
74750: LD_INT 4
74752: ARRAY
74753: OR
74754: IFFALSE 74758
// continue ;
74756: GO 74720
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
74758: LD_VAR 0 3
74762: PPUSH
74763: LD_EXP 83
74767: PUSH
74768: LD_VAR 0 2
74772: ARRAY
74773: PUSH
74774: LD_INT 1
74776: ARRAY
74777: PUSH
74778: LD_INT 1
74780: ARRAY
74781: PPUSH
74782: LD_EXP 83
74786: PUSH
74787: LD_VAR 0 2
74791: ARRAY
74792: PUSH
74793: LD_INT 1
74795: ARRAY
74796: PUSH
74797: LD_INT 2
74799: ARRAY
74800: PPUSH
74801: LD_EXP 83
74805: PUSH
74806: LD_VAR 0 2
74810: ARRAY
74811: PUSH
74812: LD_INT 1
74814: ARRAY
74815: PUSH
74816: LD_INT 3
74818: ARRAY
74819: PPUSH
74820: LD_EXP 83
74824: PUSH
74825: LD_VAR 0 2
74829: ARRAY
74830: PUSH
74831: LD_INT 1
74833: ARRAY
74834: PUSH
74835: LD_INT 4
74837: ARRAY
74838: PPUSH
74839: CALL_OW 448
74843: PUSH
74844: LD_VAR 0 3
74848: PPUSH
74849: LD_EXP 83
74853: PUSH
74854: LD_VAR 0 2
74858: ARRAY
74859: PUSH
74860: LD_INT 1
74862: ARRAY
74863: PUSH
74864: LD_INT 1
74866: ARRAY
74867: PUSH
74868: LD_EXP 83
74872: PUSH
74873: LD_VAR 0 2
74877: ARRAY
74878: PUSH
74879: LD_INT 1
74881: ARRAY
74882: PUSH
74883: LD_INT 2
74885: ARRAY
74886: PUSH
74887: LD_EXP 83
74891: PUSH
74892: LD_VAR 0 2
74896: ARRAY
74897: PUSH
74898: LD_INT 1
74900: ARRAY
74901: PUSH
74902: LD_INT 3
74904: ARRAY
74905: PUSH
74906: LD_EXP 83
74910: PUSH
74911: LD_VAR 0 2
74915: ARRAY
74916: PUSH
74917: LD_INT 1
74919: ARRAY
74920: PUSH
74921: LD_INT 4
74923: ARRAY
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: LIST
74929: LIST
74930: PPUSH
74931: CALL 28203 0 2
74935: AND
74936: IFFALSE 75074
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
74938: LD_VAR 0 3
74942: PPUSH
74943: LD_EXP 83
74947: PUSH
74948: LD_VAR 0 2
74952: ARRAY
74953: PUSH
74954: LD_INT 1
74956: ARRAY
74957: PUSH
74958: LD_INT 1
74960: ARRAY
74961: PPUSH
74962: LD_EXP 83
74966: PUSH
74967: LD_VAR 0 2
74971: ARRAY
74972: PUSH
74973: LD_INT 1
74975: ARRAY
74976: PUSH
74977: LD_INT 2
74979: ARRAY
74980: PPUSH
74981: LD_EXP 83
74985: PUSH
74986: LD_VAR 0 2
74990: ARRAY
74991: PUSH
74992: LD_INT 1
74994: ARRAY
74995: PUSH
74996: LD_INT 3
74998: ARRAY
74999: PPUSH
75000: LD_EXP 83
75004: PUSH
75005: LD_VAR 0 2
75009: ARRAY
75010: PUSH
75011: LD_INT 1
75013: ARRAY
75014: PUSH
75015: LD_INT 4
75017: ARRAY
75018: PPUSH
75019: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
75023: LD_ADDR_VAR 0 4
75027: PUSH
75028: LD_EXP 83
75032: PUSH
75033: LD_VAR 0 2
75037: ARRAY
75038: PPUSH
75039: LD_INT 1
75041: PPUSH
75042: CALL_OW 3
75046: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
75047: LD_ADDR_EXP 83
75051: PUSH
75052: LD_EXP 83
75056: PPUSH
75057: LD_VAR 0 2
75061: PPUSH
75062: LD_VAR 0 4
75066: PPUSH
75067: CALL_OW 1
75071: ST_TO_ADDR
// break ;
75072: GO 75076
// end ; end ;
75074: GO 74720
75076: POP
75077: POP
// end ;
75078: GO 74652
75080: POP
75081: POP
// end ;
75082: LD_VAR 0 1
75086: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
75087: LD_INT 0
75089: PPUSH
75090: PPUSH
75091: PPUSH
// if not mc_bases then
75092: LD_EXP 62
75096: NOT
75097: IFFALSE 75101
// exit ;
75099: GO 75190
// for i = 1 to mc_bases do
75101: LD_ADDR_VAR 0 2
75105: PUSH
75106: DOUBLE
75107: LD_INT 1
75109: DEC
75110: ST_TO_ADDR
75111: LD_EXP 62
75115: PUSH
75116: FOR_TO
75117: IFFALSE 75188
// begin if mc_attack [ i ] then
75119: LD_EXP 82
75123: PUSH
75124: LD_VAR 0 2
75128: ARRAY
75129: IFFALSE 75186
// begin tmp := mc_attack [ i ] [ 1 ] ;
75131: LD_ADDR_VAR 0 3
75135: PUSH
75136: LD_EXP 82
75140: PUSH
75141: LD_VAR 0 2
75145: ARRAY
75146: PUSH
75147: LD_INT 1
75149: ARRAY
75150: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
75151: LD_ADDR_EXP 82
75155: PUSH
75156: LD_EXP 82
75160: PPUSH
75161: LD_VAR 0 2
75165: PPUSH
75166: EMPTY
75167: PPUSH
75168: CALL_OW 1
75172: ST_TO_ADDR
// Attack ( tmp ) ;
75173: LD_VAR 0 3
75177: PPUSH
75178: CALL 110708 0 1
// exit ;
75182: POP
75183: POP
75184: GO 75190
// end ; end ;
75186: GO 75116
75188: POP
75189: POP
// end ;
75190: LD_VAR 0 1
75194: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
75195: LD_INT 0
75197: PPUSH
75198: PPUSH
75199: PPUSH
75200: PPUSH
75201: PPUSH
75202: PPUSH
75203: PPUSH
// if not mc_bases then
75204: LD_EXP 62
75208: NOT
75209: IFFALSE 75213
// exit ;
75211: GO 76070
// for i = 1 to mc_bases do
75213: LD_ADDR_VAR 0 2
75217: PUSH
75218: DOUBLE
75219: LD_INT 1
75221: DEC
75222: ST_TO_ADDR
75223: LD_EXP 62
75227: PUSH
75228: FOR_TO
75229: IFFALSE 76068
// begin if not mc_bases [ i ] then
75231: LD_EXP 62
75235: PUSH
75236: LD_VAR 0 2
75240: ARRAY
75241: NOT
75242: IFFALSE 75246
// continue ;
75244: GO 75228
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
75246: LD_ADDR_VAR 0 7
75250: PUSH
75251: LD_EXP 62
75255: PUSH
75256: LD_VAR 0 2
75260: ARRAY
75261: PUSH
75262: LD_INT 1
75264: ARRAY
75265: PPUSH
75266: CALL 18286 0 1
75270: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
75271: LD_ADDR_EXP 85
75275: PUSH
75276: LD_EXP 85
75280: PPUSH
75281: LD_VAR 0 2
75285: PPUSH
75286: LD_EXP 62
75290: PUSH
75291: LD_VAR 0 2
75295: ARRAY
75296: PUSH
75297: LD_INT 1
75299: ARRAY
75300: PPUSH
75301: CALL_OW 255
75305: PPUSH
75306: LD_EXP 87
75310: PUSH
75311: LD_VAR 0 2
75315: ARRAY
75316: PPUSH
75317: CALL 18251 0 2
75321: PPUSH
75322: CALL_OW 1
75326: ST_TO_ADDR
// if not mc_scan [ i ] then
75327: LD_EXP 85
75331: PUSH
75332: LD_VAR 0 2
75336: ARRAY
75337: NOT
75338: IFFALSE 75516
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
75340: LD_ADDR_EXP 105
75344: PUSH
75345: LD_EXP 105
75349: PPUSH
75350: LD_VAR 0 2
75354: PPUSH
75355: LD_INT 0
75357: PPUSH
75358: CALL_OW 1
75362: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
75363: LD_ADDR_VAR 0 4
75367: PUSH
75368: LD_EXP 62
75372: PUSH
75373: LD_VAR 0 2
75377: ARRAY
75378: PPUSH
75379: LD_INT 2
75381: PUSH
75382: LD_INT 25
75384: PUSH
75385: LD_INT 5
75387: PUSH
75388: EMPTY
75389: LIST
75390: LIST
75391: PUSH
75392: LD_INT 25
75394: PUSH
75395: LD_INT 8
75397: PUSH
75398: EMPTY
75399: LIST
75400: LIST
75401: PUSH
75402: LD_INT 25
75404: PUSH
75405: LD_INT 9
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: LIST
75416: LIST
75417: PPUSH
75418: CALL_OW 72
75422: ST_TO_ADDR
// if not tmp then
75423: LD_VAR 0 4
75427: NOT
75428: IFFALSE 75432
// continue ;
75430: GO 75228
// for j in tmp do
75432: LD_ADDR_VAR 0 3
75436: PUSH
75437: LD_VAR 0 4
75441: PUSH
75442: FOR_IN
75443: IFFALSE 75514
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
75445: LD_VAR 0 3
75449: PPUSH
75450: CALL_OW 310
75454: PPUSH
75455: CALL_OW 266
75459: PUSH
75460: LD_INT 5
75462: EQUAL
75463: PUSH
75464: LD_VAR 0 3
75468: PPUSH
75469: CALL_OW 257
75473: PUSH
75474: LD_INT 1
75476: EQUAL
75477: AND
75478: PUSH
75479: LD_VAR 0 3
75483: PPUSH
75484: CALL_OW 459
75488: NOT
75489: AND
75490: PUSH
75491: LD_VAR 0 7
75495: AND
75496: IFFALSE 75512
// ComChangeProfession ( j , class ) ;
75498: LD_VAR 0 3
75502: PPUSH
75503: LD_VAR 0 7
75507: PPUSH
75508: CALL_OW 123
75512: GO 75442
75514: POP
75515: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
75516: LD_EXP 85
75520: PUSH
75521: LD_VAR 0 2
75525: ARRAY
75526: PUSH
75527: LD_EXP 105
75531: PUSH
75532: LD_VAR 0 2
75536: ARRAY
75537: NOT
75538: AND
75539: PUSH
75540: LD_EXP 84
75544: PUSH
75545: LD_VAR 0 2
75549: ARRAY
75550: NOT
75551: AND
75552: PUSH
75553: LD_EXP 62
75557: PUSH
75558: LD_VAR 0 2
75562: ARRAY
75563: PPUSH
75564: LD_INT 50
75566: PUSH
75567: EMPTY
75568: LIST
75569: PUSH
75570: LD_INT 2
75572: PUSH
75573: LD_INT 30
75575: PUSH
75576: LD_INT 32
75578: PUSH
75579: EMPTY
75580: LIST
75581: LIST
75582: PUSH
75583: LD_INT 30
75585: PUSH
75586: LD_INT 33
75588: PUSH
75589: EMPTY
75590: LIST
75591: LIST
75592: PUSH
75593: LD_INT 30
75595: PUSH
75596: LD_INT 4
75598: PUSH
75599: EMPTY
75600: LIST
75601: LIST
75602: PUSH
75603: LD_INT 30
75605: PUSH
75606: LD_INT 5
75608: PUSH
75609: EMPTY
75610: LIST
75611: LIST
75612: PUSH
75613: EMPTY
75614: LIST
75615: LIST
75616: LIST
75617: LIST
75618: LIST
75619: PUSH
75620: EMPTY
75621: LIST
75622: LIST
75623: PPUSH
75624: CALL_OW 72
75628: PUSH
75629: LD_INT 4
75631: LESS
75632: PUSH
75633: LD_EXP 62
75637: PUSH
75638: LD_VAR 0 2
75642: ARRAY
75643: PPUSH
75644: LD_INT 3
75646: PUSH
75647: LD_INT 24
75649: PUSH
75650: LD_INT 1000
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 2
75663: PUSH
75664: LD_INT 30
75666: PUSH
75667: LD_INT 0
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PUSH
75674: LD_INT 30
75676: PUSH
75677: LD_INT 1
75679: PUSH
75680: EMPTY
75681: LIST
75682: LIST
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: LIST
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PPUSH
75693: CALL_OW 72
75697: OR
75698: AND
75699: IFFALSE 75950
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
75701: LD_ADDR_EXP 105
75705: PUSH
75706: LD_EXP 105
75710: PPUSH
75711: LD_VAR 0 2
75715: PPUSH
75716: LD_INT 1
75718: PPUSH
75719: CALL_OW 1
75723: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
75724: LD_ADDR_VAR 0 4
75728: PUSH
75729: LD_EXP 62
75733: PUSH
75734: LD_VAR 0 2
75738: ARRAY
75739: PPUSH
75740: LD_INT 2
75742: PUSH
75743: LD_INT 25
75745: PUSH
75746: LD_INT 1
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: LD_INT 25
75755: PUSH
75756: LD_INT 5
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: LD_INT 25
75765: PUSH
75766: LD_INT 8
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: PUSH
75773: LD_INT 25
75775: PUSH
75776: LD_INT 9
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: LIST
75787: LIST
75788: LIST
75789: PPUSH
75790: CALL_OW 72
75794: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
75795: LD_ADDR_VAR 0 4
75799: PUSH
75800: LD_VAR 0 4
75804: PUSH
75805: LD_VAR 0 4
75809: PPUSH
75810: LD_INT 18
75812: PPUSH
75813: CALL 51760 0 2
75817: DIFF
75818: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
75819: LD_VAR 0 4
75823: NOT
75824: PUSH
75825: LD_EXP 62
75829: PUSH
75830: LD_VAR 0 2
75834: ARRAY
75835: PPUSH
75836: LD_INT 2
75838: PUSH
75839: LD_INT 30
75841: PUSH
75842: LD_INT 4
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PUSH
75849: LD_INT 30
75851: PUSH
75852: LD_INT 5
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: LIST
75863: PPUSH
75864: CALL_OW 72
75868: NOT
75869: AND
75870: IFFALSE 75932
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
75872: LD_ADDR_VAR 0 4
75876: PUSH
75877: LD_EXP 62
75881: PUSH
75882: LD_VAR 0 2
75886: ARRAY
75887: PPUSH
75888: LD_INT 2
75890: PUSH
75891: LD_INT 25
75893: PUSH
75894: LD_INT 2
75896: PUSH
75897: EMPTY
75898: LIST
75899: LIST
75900: PUSH
75901: LD_INT 25
75903: PUSH
75904: LD_INT 3
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: PUSH
75911: LD_INT 25
75913: PUSH
75914: LD_INT 4
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: PUSH
75921: EMPTY
75922: LIST
75923: LIST
75924: LIST
75925: LIST
75926: PPUSH
75927: CALL_OW 72
75931: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
75932: LD_VAR 0 2
75936: PPUSH
75937: LD_VAR 0 4
75941: PPUSH
75942: CALL 115417 0 2
// exit ;
75946: POP
75947: POP
75948: GO 76070
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
75950: LD_EXP 85
75954: PUSH
75955: LD_VAR 0 2
75959: ARRAY
75960: PUSH
75961: LD_EXP 105
75965: PUSH
75966: LD_VAR 0 2
75970: ARRAY
75971: NOT
75972: AND
75973: PUSH
75974: LD_EXP 84
75978: PUSH
75979: LD_VAR 0 2
75983: ARRAY
75984: AND
75985: IFFALSE 76066
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
75987: LD_ADDR_EXP 105
75991: PUSH
75992: LD_EXP 105
75996: PPUSH
75997: LD_VAR 0 2
76001: PPUSH
76002: LD_INT 1
76004: PPUSH
76005: CALL_OW 1
76009: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
76010: LD_ADDR_VAR 0 4
76014: PUSH
76015: LD_EXP 84
76019: PUSH
76020: LD_VAR 0 2
76024: ARRAY
76025: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
76026: LD_ADDR_EXP 84
76030: PUSH
76031: LD_EXP 84
76035: PPUSH
76036: LD_VAR 0 2
76040: PPUSH
76041: EMPTY
76042: PPUSH
76043: CALL_OW 1
76047: ST_TO_ADDR
// Defend ( i , tmp ) ;
76048: LD_VAR 0 2
76052: PPUSH
76053: LD_VAR 0 4
76057: PPUSH
76058: CALL 116013 0 2
// exit ;
76062: POP
76063: POP
76064: GO 76070
// end ; end ;
76066: GO 75228
76068: POP
76069: POP
// end ;
76070: LD_VAR 0 1
76074: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
76075: LD_INT 0
76077: PPUSH
76078: PPUSH
76079: PPUSH
76080: PPUSH
76081: PPUSH
76082: PPUSH
76083: PPUSH
76084: PPUSH
76085: PPUSH
76086: PPUSH
76087: PPUSH
// if not mc_bases then
76088: LD_EXP 62
76092: NOT
76093: IFFALSE 76097
// exit ;
76095: GO 77184
// for i = 1 to mc_bases do
76097: LD_ADDR_VAR 0 2
76101: PUSH
76102: DOUBLE
76103: LD_INT 1
76105: DEC
76106: ST_TO_ADDR
76107: LD_EXP 62
76111: PUSH
76112: FOR_TO
76113: IFFALSE 77182
// begin tmp := mc_lab [ i ] ;
76115: LD_ADDR_VAR 0 6
76119: PUSH
76120: LD_EXP 95
76124: PUSH
76125: LD_VAR 0 2
76129: ARRAY
76130: ST_TO_ADDR
// if not tmp then
76131: LD_VAR 0 6
76135: NOT
76136: IFFALSE 76140
// continue ;
76138: GO 76112
// idle_lab := 0 ;
76140: LD_ADDR_VAR 0 11
76144: PUSH
76145: LD_INT 0
76147: ST_TO_ADDR
// for j in tmp do
76148: LD_ADDR_VAR 0 3
76152: PUSH
76153: LD_VAR 0 6
76157: PUSH
76158: FOR_IN
76159: IFFALSE 77178
// begin researching := false ;
76161: LD_ADDR_VAR 0 10
76165: PUSH
76166: LD_INT 0
76168: ST_TO_ADDR
// side := GetSide ( j ) ;
76169: LD_ADDR_VAR 0 4
76173: PUSH
76174: LD_VAR 0 3
76178: PPUSH
76179: CALL_OW 255
76183: ST_TO_ADDR
// if not mc_tech [ side ] then
76184: LD_EXP 89
76188: PUSH
76189: LD_VAR 0 4
76193: ARRAY
76194: NOT
76195: IFFALSE 76199
// continue ;
76197: GO 76158
// if BuildingStatus ( j ) = bs_idle then
76199: LD_VAR 0 3
76203: PPUSH
76204: CALL_OW 461
76208: PUSH
76209: LD_INT 2
76211: EQUAL
76212: IFFALSE 76400
// begin if idle_lab and UnitsInside ( j ) < 6 then
76214: LD_VAR 0 11
76218: PUSH
76219: LD_VAR 0 3
76223: PPUSH
76224: CALL_OW 313
76228: PUSH
76229: LD_INT 6
76231: LESS
76232: AND
76233: IFFALSE 76304
// begin tmp2 := UnitsInside ( idle_lab ) ;
76235: LD_ADDR_VAR 0 9
76239: PUSH
76240: LD_VAR 0 11
76244: PPUSH
76245: CALL_OW 313
76249: ST_TO_ADDR
// if tmp2 then
76250: LD_VAR 0 9
76254: IFFALSE 76296
// for x in tmp2 do
76256: LD_ADDR_VAR 0 7
76260: PUSH
76261: LD_VAR 0 9
76265: PUSH
76266: FOR_IN
76267: IFFALSE 76294
// begin ComExitBuilding ( x ) ;
76269: LD_VAR 0 7
76273: PPUSH
76274: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
76278: LD_VAR 0 7
76282: PPUSH
76283: LD_VAR 0 3
76287: PPUSH
76288: CALL_OW 180
// end ;
76292: GO 76266
76294: POP
76295: POP
// idle_lab := 0 ;
76296: LD_ADDR_VAR 0 11
76300: PUSH
76301: LD_INT 0
76303: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
76304: LD_ADDR_VAR 0 5
76308: PUSH
76309: LD_EXP 89
76313: PUSH
76314: LD_VAR 0 4
76318: ARRAY
76319: PUSH
76320: FOR_IN
76321: IFFALSE 76381
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
76323: LD_VAR 0 3
76327: PPUSH
76328: LD_VAR 0 5
76332: PPUSH
76333: CALL_OW 430
76337: PUSH
76338: LD_VAR 0 4
76342: PPUSH
76343: LD_VAR 0 5
76347: PPUSH
76348: CALL 17356 0 2
76352: AND
76353: IFFALSE 76379
// begin researching := true ;
76355: LD_ADDR_VAR 0 10
76359: PUSH
76360: LD_INT 1
76362: ST_TO_ADDR
// ComResearch ( j , t ) ;
76363: LD_VAR 0 3
76367: PPUSH
76368: LD_VAR 0 5
76372: PPUSH
76373: CALL_OW 124
// break ;
76377: GO 76381
// end ;
76379: GO 76320
76381: POP
76382: POP
// if not researching then
76383: LD_VAR 0 10
76387: NOT
76388: IFFALSE 76400
// idle_lab := j ;
76390: LD_ADDR_VAR 0 11
76394: PUSH
76395: LD_VAR 0 3
76399: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
76400: LD_VAR 0 3
76404: PPUSH
76405: CALL_OW 461
76409: PUSH
76410: LD_INT 10
76412: EQUAL
76413: IFFALSE 77001
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
76415: LD_EXP 91
76419: PUSH
76420: LD_VAR 0 2
76424: ARRAY
76425: NOT
76426: PUSH
76427: LD_EXP 92
76431: PUSH
76432: LD_VAR 0 2
76436: ARRAY
76437: NOT
76438: AND
76439: PUSH
76440: LD_EXP 89
76444: PUSH
76445: LD_VAR 0 4
76449: ARRAY
76450: PUSH
76451: LD_INT 1
76453: GREATER
76454: AND
76455: IFFALSE 76586
// begin ComCancel ( j ) ;
76457: LD_VAR 0 3
76461: PPUSH
76462: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
76466: LD_ADDR_EXP 89
76470: PUSH
76471: LD_EXP 89
76475: PPUSH
76476: LD_VAR 0 4
76480: PPUSH
76481: LD_EXP 89
76485: PUSH
76486: LD_VAR 0 4
76490: ARRAY
76491: PPUSH
76492: LD_EXP 89
76496: PUSH
76497: LD_VAR 0 4
76501: ARRAY
76502: PUSH
76503: LD_INT 1
76505: MINUS
76506: PPUSH
76507: LD_EXP 89
76511: PUSH
76512: LD_VAR 0 4
76516: ARRAY
76517: PPUSH
76518: LD_INT 0
76520: PPUSH
76521: CALL 20880 0 4
76525: PPUSH
76526: CALL_OW 1
76530: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
76531: LD_ADDR_EXP 89
76535: PUSH
76536: LD_EXP 89
76540: PPUSH
76541: LD_VAR 0 4
76545: PPUSH
76546: LD_EXP 89
76550: PUSH
76551: LD_VAR 0 4
76555: ARRAY
76556: PPUSH
76557: LD_EXP 89
76561: PUSH
76562: LD_VAR 0 4
76566: ARRAY
76567: PPUSH
76568: LD_INT 1
76570: PPUSH
76571: LD_INT 0
76573: PPUSH
76574: CALL 20880 0 4
76578: PPUSH
76579: CALL_OW 1
76583: ST_TO_ADDR
// continue ;
76584: GO 76158
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
76586: LD_EXP 91
76590: PUSH
76591: LD_VAR 0 2
76595: ARRAY
76596: PUSH
76597: LD_EXP 92
76601: PUSH
76602: LD_VAR 0 2
76606: ARRAY
76607: NOT
76608: AND
76609: IFFALSE 76736
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
76611: LD_ADDR_EXP 92
76615: PUSH
76616: LD_EXP 92
76620: PPUSH
76621: LD_VAR 0 2
76625: PUSH
76626: LD_EXP 92
76630: PUSH
76631: LD_VAR 0 2
76635: ARRAY
76636: PUSH
76637: LD_INT 1
76639: PLUS
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PPUSH
76645: LD_EXP 91
76649: PUSH
76650: LD_VAR 0 2
76654: ARRAY
76655: PUSH
76656: LD_INT 1
76658: ARRAY
76659: PPUSH
76660: CALL 21462 0 3
76664: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
76665: LD_EXP 91
76669: PUSH
76670: LD_VAR 0 2
76674: ARRAY
76675: PUSH
76676: LD_INT 1
76678: ARRAY
76679: PPUSH
76680: LD_INT 112
76682: PPUSH
76683: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
76687: LD_ADDR_VAR 0 9
76691: PUSH
76692: LD_EXP 91
76696: PUSH
76697: LD_VAR 0 2
76701: ARRAY
76702: PPUSH
76703: LD_INT 1
76705: PPUSH
76706: CALL_OW 3
76710: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
76711: LD_ADDR_EXP 91
76715: PUSH
76716: LD_EXP 91
76720: PPUSH
76721: LD_VAR 0 2
76725: PPUSH
76726: LD_VAR 0 9
76730: PPUSH
76731: CALL_OW 1
76735: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
76736: LD_EXP 91
76740: PUSH
76741: LD_VAR 0 2
76745: ARRAY
76746: PUSH
76747: LD_EXP 92
76751: PUSH
76752: LD_VAR 0 2
76756: ARRAY
76757: AND
76758: PUSH
76759: LD_EXP 92
76763: PUSH
76764: LD_VAR 0 2
76768: ARRAY
76769: PUSH
76770: LD_INT 1
76772: ARRAY
76773: PPUSH
76774: CALL_OW 310
76778: NOT
76779: AND
76780: PUSH
76781: LD_VAR 0 3
76785: PPUSH
76786: CALL_OW 313
76790: PUSH
76791: LD_INT 6
76793: EQUAL
76794: AND
76795: IFFALSE 76851
// begin tmp2 := UnitsInside ( j ) ;
76797: LD_ADDR_VAR 0 9
76801: PUSH
76802: LD_VAR 0 3
76806: PPUSH
76807: CALL_OW 313
76811: ST_TO_ADDR
// if tmp2 = 6 then
76812: LD_VAR 0 9
76816: PUSH
76817: LD_INT 6
76819: EQUAL
76820: IFFALSE 76851
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
76822: LD_VAR 0 9
76826: PUSH
76827: LD_INT 1
76829: ARRAY
76830: PPUSH
76831: LD_INT 112
76833: PPUSH
76834: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
76838: LD_VAR 0 9
76842: PUSH
76843: LD_INT 1
76845: ARRAY
76846: PPUSH
76847: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
76851: LD_EXP 92
76855: PUSH
76856: LD_VAR 0 2
76860: ARRAY
76861: PUSH
76862: LD_EXP 92
76866: PUSH
76867: LD_VAR 0 2
76871: ARRAY
76872: PUSH
76873: LD_INT 1
76875: ARRAY
76876: PPUSH
76877: CALL_OW 314
76881: NOT
76882: AND
76883: PUSH
76884: LD_EXP 92
76888: PUSH
76889: LD_VAR 0 2
76893: ARRAY
76894: PUSH
76895: LD_INT 1
76897: ARRAY
76898: PPUSH
76899: CALL_OW 310
76903: NOT
76904: AND
76905: IFFALSE 76931
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
76907: LD_EXP 92
76911: PUSH
76912: LD_VAR 0 2
76916: ARRAY
76917: PUSH
76918: LD_INT 1
76920: ARRAY
76921: PPUSH
76922: LD_VAR 0 3
76926: PPUSH
76927: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
76931: LD_EXP 92
76935: PUSH
76936: LD_VAR 0 2
76940: ARRAY
76941: PUSH
76942: LD_INT 1
76944: ARRAY
76945: PPUSH
76946: CALL_OW 310
76950: PUSH
76951: LD_EXP 92
76955: PUSH
76956: LD_VAR 0 2
76960: ARRAY
76961: PUSH
76962: LD_INT 1
76964: ARRAY
76965: PPUSH
76966: CALL_OW 310
76970: PPUSH
76971: CALL_OW 461
76975: PUSH
76976: LD_INT 3
76978: NONEQUAL
76979: AND
76980: IFFALSE 77001
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
76982: LD_EXP 92
76986: PUSH
76987: LD_VAR 0 2
76991: ARRAY
76992: PUSH
76993: LD_INT 1
76995: ARRAY
76996: PPUSH
76997: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
77001: LD_VAR 0 3
77005: PPUSH
77006: CALL_OW 461
77010: PUSH
77011: LD_INT 6
77013: EQUAL
77014: PUSH
77015: LD_VAR 0 6
77019: PUSH
77020: LD_INT 1
77022: GREATER
77023: AND
77024: IFFALSE 77176
// begin sci := [ ] ;
77026: LD_ADDR_VAR 0 8
77030: PUSH
77031: EMPTY
77032: ST_TO_ADDR
// for x in ( tmp diff j ) do
77033: LD_ADDR_VAR 0 7
77037: PUSH
77038: LD_VAR 0 6
77042: PUSH
77043: LD_VAR 0 3
77047: DIFF
77048: PUSH
77049: FOR_IN
77050: IFFALSE 77102
// begin if sci = 6 then
77052: LD_VAR 0 8
77056: PUSH
77057: LD_INT 6
77059: EQUAL
77060: IFFALSE 77064
// break ;
77062: GO 77102
// if BuildingStatus ( x ) = bs_idle then
77064: LD_VAR 0 7
77068: PPUSH
77069: CALL_OW 461
77073: PUSH
77074: LD_INT 2
77076: EQUAL
77077: IFFALSE 77100
// sci := sci ^ UnitsInside ( x ) ;
77079: LD_ADDR_VAR 0 8
77083: PUSH
77084: LD_VAR 0 8
77088: PUSH
77089: LD_VAR 0 7
77093: PPUSH
77094: CALL_OW 313
77098: ADD
77099: ST_TO_ADDR
// end ;
77100: GO 77049
77102: POP
77103: POP
// if not sci then
77104: LD_VAR 0 8
77108: NOT
77109: IFFALSE 77113
// continue ;
77111: GO 76158
// for x in sci do
77113: LD_ADDR_VAR 0 7
77117: PUSH
77118: LD_VAR 0 8
77122: PUSH
77123: FOR_IN
77124: IFFALSE 77174
// if IsInUnit ( x ) and not HasTask ( x ) then
77126: LD_VAR 0 7
77130: PPUSH
77131: CALL_OW 310
77135: PUSH
77136: LD_VAR 0 7
77140: PPUSH
77141: CALL_OW 314
77145: NOT
77146: AND
77147: IFFALSE 77172
// begin ComExitBuilding ( x ) ;
77149: LD_VAR 0 7
77153: PPUSH
77154: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
77158: LD_VAR 0 7
77162: PPUSH
77163: LD_VAR 0 3
77167: PPUSH
77168: CALL_OW 180
// end ;
77172: GO 77123
77174: POP
77175: POP
// end ; end ;
77176: GO 76158
77178: POP
77179: POP
// end ;
77180: GO 76112
77182: POP
77183: POP
// end ;
77184: LD_VAR 0 1
77188: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
77189: LD_INT 0
77191: PPUSH
77192: PPUSH
// if not mc_bases then
77193: LD_EXP 62
77197: NOT
77198: IFFALSE 77202
// exit ;
77200: GO 77283
// for i = 1 to mc_bases do
77202: LD_ADDR_VAR 0 2
77206: PUSH
77207: DOUBLE
77208: LD_INT 1
77210: DEC
77211: ST_TO_ADDR
77212: LD_EXP 62
77216: PUSH
77217: FOR_TO
77218: IFFALSE 77281
// if mc_mines [ i ] and mc_miners [ i ] then
77220: LD_EXP 75
77224: PUSH
77225: LD_VAR 0 2
77229: ARRAY
77230: PUSH
77231: LD_EXP 76
77235: PUSH
77236: LD_VAR 0 2
77240: ARRAY
77241: AND
77242: IFFALSE 77279
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
77244: LD_EXP 76
77248: PUSH
77249: LD_VAR 0 2
77253: ARRAY
77254: PUSH
77255: LD_INT 1
77257: ARRAY
77258: PPUSH
77259: CALL_OW 255
77263: PPUSH
77264: LD_EXP 75
77268: PUSH
77269: LD_VAR 0 2
77273: ARRAY
77274: PPUSH
77275: CALL 18439 0 2
77279: GO 77217
77281: POP
77282: POP
// end ;
77283: LD_VAR 0 1
77287: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
77288: LD_INT 0
77290: PPUSH
77291: PPUSH
77292: PPUSH
77293: PPUSH
77294: PPUSH
77295: PPUSH
77296: PPUSH
77297: PPUSH
// if not mc_bases or not mc_parking then
77298: LD_EXP 62
77302: NOT
77303: PUSH
77304: LD_EXP 86
77308: NOT
77309: OR
77310: IFFALSE 77314
// exit ;
77312: GO 78052
// for i = 1 to mc_bases do
77314: LD_ADDR_VAR 0 2
77318: PUSH
77319: DOUBLE
77320: LD_INT 1
77322: DEC
77323: ST_TO_ADDR
77324: LD_EXP 62
77328: PUSH
77329: FOR_TO
77330: IFFALSE 78050
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
77332: LD_EXP 62
77336: PUSH
77337: LD_VAR 0 2
77341: ARRAY
77342: NOT
77343: PUSH
77344: LD_EXP 86
77348: PUSH
77349: LD_VAR 0 2
77353: ARRAY
77354: NOT
77355: OR
77356: IFFALSE 77360
// continue ;
77358: GO 77329
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
77360: LD_ADDR_VAR 0 5
77364: PUSH
77365: LD_EXP 62
77369: PUSH
77370: LD_VAR 0 2
77374: ARRAY
77375: PUSH
77376: LD_INT 1
77378: ARRAY
77379: PPUSH
77380: CALL_OW 255
77384: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
77385: LD_ADDR_VAR 0 6
77389: PUSH
77390: LD_EXP 62
77394: PUSH
77395: LD_VAR 0 2
77399: ARRAY
77400: PPUSH
77401: LD_INT 30
77403: PUSH
77404: LD_INT 3
77406: PUSH
77407: EMPTY
77408: LIST
77409: LIST
77410: PPUSH
77411: CALL_OW 72
77415: ST_TO_ADDR
// if not fac then
77416: LD_VAR 0 6
77420: NOT
77421: IFFALSE 77472
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77423: LD_ADDR_VAR 0 6
77427: PUSH
77428: LD_EXP 62
77432: PUSH
77433: LD_VAR 0 2
77437: ARRAY
77438: PPUSH
77439: LD_INT 2
77441: PUSH
77442: LD_INT 30
77444: PUSH
77445: LD_INT 0
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 30
77454: PUSH
77455: LD_INT 1
77457: PUSH
77458: EMPTY
77459: LIST
77460: LIST
77461: PUSH
77462: EMPTY
77463: LIST
77464: LIST
77465: LIST
77466: PPUSH
77467: CALL_OW 72
77471: ST_TO_ADDR
// if not fac then
77472: LD_VAR 0 6
77476: NOT
77477: IFFALSE 77481
// continue ;
77479: GO 77329
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
77481: LD_ADDR_VAR 0 7
77485: PUSH
77486: LD_EXP 86
77490: PUSH
77491: LD_VAR 0 2
77495: ARRAY
77496: PPUSH
77497: LD_INT 22
77499: PUSH
77500: LD_VAR 0 5
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PUSH
77509: LD_INT 21
77511: PUSH
77512: LD_INT 2
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 3
77521: PUSH
77522: LD_INT 60
77524: PUSH
77525: EMPTY
77526: LIST
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: PUSH
77532: LD_INT 3
77534: PUSH
77535: LD_INT 24
77537: PUSH
77538: LD_INT 1000
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: EMPTY
77550: LIST
77551: LIST
77552: LIST
77553: LIST
77554: PPUSH
77555: CALL_OW 70
77559: ST_TO_ADDR
// for j in fac do
77560: LD_ADDR_VAR 0 3
77564: PUSH
77565: LD_VAR 0 6
77569: PUSH
77570: FOR_IN
77571: IFFALSE 77666
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
77573: LD_ADDR_VAR 0 7
77577: PUSH
77578: LD_VAR 0 7
77582: PUSH
77583: LD_INT 22
77585: PUSH
77586: LD_VAR 0 5
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 91
77597: PUSH
77598: LD_VAR 0 3
77602: PUSH
77603: LD_INT 15
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: LIST
77610: PUSH
77611: LD_INT 21
77613: PUSH
77614: LD_INT 2
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: LD_INT 3
77623: PUSH
77624: LD_INT 60
77626: PUSH
77627: EMPTY
77628: LIST
77629: PUSH
77630: EMPTY
77631: LIST
77632: LIST
77633: PUSH
77634: LD_INT 3
77636: PUSH
77637: LD_INT 24
77639: PUSH
77640: LD_INT 1000
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: LIST
77655: LIST
77656: LIST
77657: PPUSH
77658: CALL_OW 69
77662: UNION
77663: ST_TO_ADDR
77664: GO 77570
77666: POP
77667: POP
// if not vehs then
77668: LD_VAR 0 7
77672: NOT
77673: IFFALSE 77699
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
77675: LD_ADDR_EXP 74
77679: PUSH
77680: LD_EXP 74
77684: PPUSH
77685: LD_VAR 0 2
77689: PPUSH
77690: EMPTY
77691: PPUSH
77692: CALL_OW 1
77696: ST_TO_ADDR
// continue ;
77697: GO 77329
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
77699: LD_ADDR_VAR 0 8
77703: PUSH
77704: LD_EXP 62
77708: PUSH
77709: LD_VAR 0 2
77713: ARRAY
77714: PPUSH
77715: LD_INT 30
77717: PUSH
77718: LD_INT 3
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: PPUSH
77725: CALL_OW 72
77729: ST_TO_ADDR
// if tmp then
77730: LD_VAR 0 8
77734: IFFALSE 77837
// begin for j in tmp do
77736: LD_ADDR_VAR 0 3
77740: PUSH
77741: LD_VAR 0 8
77745: PUSH
77746: FOR_IN
77747: IFFALSE 77835
// for k in UnitsInside ( j ) do
77749: LD_ADDR_VAR 0 4
77753: PUSH
77754: LD_VAR 0 3
77758: PPUSH
77759: CALL_OW 313
77763: PUSH
77764: FOR_IN
77765: IFFALSE 77831
// if k then
77767: LD_VAR 0 4
77771: IFFALSE 77829
// if not k in mc_repair_vehicle [ i ] then
77773: LD_VAR 0 4
77777: PUSH
77778: LD_EXP 74
77782: PUSH
77783: LD_VAR 0 2
77787: ARRAY
77788: IN
77789: NOT
77790: IFFALSE 77829
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
77792: LD_ADDR_EXP 74
77796: PUSH
77797: LD_EXP 74
77801: PPUSH
77802: LD_VAR 0 2
77806: PPUSH
77807: LD_EXP 74
77811: PUSH
77812: LD_VAR 0 2
77816: ARRAY
77817: PUSH
77818: LD_VAR 0 4
77822: UNION
77823: PPUSH
77824: CALL_OW 1
77828: ST_TO_ADDR
77829: GO 77764
77831: POP
77832: POP
77833: GO 77746
77835: POP
77836: POP
// end ; if not mc_repair_vehicle [ i ] then
77837: LD_EXP 74
77841: PUSH
77842: LD_VAR 0 2
77846: ARRAY
77847: NOT
77848: IFFALSE 77852
// continue ;
77850: GO 77329
// for j in mc_repair_vehicle [ i ] do
77852: LD_ADDR_VAR 0 3
77856: PUSH
77857: LD_EXP 74
77861: PUSH
77862: LD_VAR 0 2
77866: ARRAY
77867: PUSH
77868: FOR_IN
77869: IFFALSE 78046
// begin if GetClass ( j ) <> 3 then
77871: LD_VAR 0 3
77875: PPUSH
77876: CALL_OW 257
77880: PUSH
77881: LD_INT 3
77883: NONEQUAL
77884: IFFALSE 77925
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
77886: LD_ADDR_EXP 74
77890: PUSH
77891: LD_EXP 74
77895: PPUSH
77896: LD_VAR 0 2
77900: PPUSH
77901: LD_EXP 74
77905: PUSH
77906: LD_VAR 0 2
77910: ARRAY
77911: PUSH
77912: LD_VAR 0 3
77916: DIFF
77917: PPUSH
77918: CALL_OW 1
77922: ST_TO_ADDR
// continue ;
77923: GO 77868
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77925: LD_VAR 0 3
77929: PPUSH
77930: CALL_OW 311
77934: NOT
77935: PUSH
77936: LD_VAR 0 3
77940: PUSH
77941: LD_EXP 65
77945: PUSH
77946: LD_VAR 0 2
77950: ARRAY
77951: PUSH
77952: LD_INT 1
77954: ARRAY
77955: IN
77956: NOT
77957: AND
77958: PUSH
77959: LD_VAR 0 3
77963: PUSH
77964: LD_EXP 65
77968: PUSH
77969: LD_VAR 0 2
77973: ARRAY
77974: PUSH
77975: LD_INT 2
77977: ARRAY
77978: IN
77979: NOT
77980: AND
77981: IFFALSE 78044
// begin if IsInUnit ( j ) then
77983: LD_VAR 0 3
77987: PPUSH
77988: CALL_OW 310
77992: IFFALSE 78005
// ComExitBuilding ( j ) else
77994: LD_VAR 0 3
77998: PPUSH
77999: CALL_OW 122
78003: GO 78044
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
78005: LD_VAR 0 3
78009: PPUSH
78010: LD_VAR 0 7
78014: PUSH
78015: LD_INT 1
78017: ARRAY
78018: PPUSH
78019: CALL 56256 0 2
78023: NOT
78024: IFFALSE 78044
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
78026: LD_VAR 0 3
78030: PPUSH
78031: LD_VAR 0 7
78035: PUSH
78036: LD_INT 1
78038: ARRAY
78039: PPUSH
78040: CALL_OW 129
// end ; end ;
78044: GO 77868
78046: POP
78047: POP
// end ;
78048: GO 77329
78050: POP
78051: POP
// end ;
78052: LD_VAR 0 1
78056: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
78057: LD_INT 0
78059: PPUSH
78060: PPUSH
78061: PPUSH
78062: PPUSH
78063: PPUSH
78064: PPUSH
78065: PPUSH
78066: PPUSH
78067: PPUSH
78068: PPUSH
78069: PPUSH
// if not mc_bases then
78070: LD_EXP 62
78074: NOT
78075: IFFALSE 78079
// exit ;
78077: GO 78881
// for i = 1 to mc_bases do
78079: LD_ADDR_VAR 0 2
78083: PUSH
78084: DOUBLE
78085: LD_INT 1
78087: DEC
78088: ST_TO_ADDR
78089: LD_EXP 62
78093: PUSH
78094: FOR_TO
78095: IFFALSE 78879
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
78097: LD_EXP 90
78101: PUSH
78102: LD_VAR 0 2
78106: ARRAY
78107: NOT
78108: PUSH
78109: LD_EXP 65
78113: PUSH
78114: LD_VAR 0 2
78118: ARRAY
78119: PUSH
78120: LD_INT 1
78122: ARRAY
78123: OR
78124: PUSH
78125: LD_EXP 65
78129: PUSH
78130: LD_VAR 0 2
78134: ARRAY
78135: PUSH
78136: LD_INT 2
78138: ARRAY
78139: OR
78140: PUSH
78141: LD_EXP 88
78145: PUSH
78146: LD_VAR 0 2
78150: ARRAY
78151: PPUSH
78152: LD_INT 1
78154: PPUSH
78155: CALL_OW 325
78159: NOT
78160: OR
78161: PUSH
78162: LD_EXP 85
78166: PUSH
78167: LD_VAR 0 2
78171: ARRAY
78172: OR
78173: IFFALSE 78177
// continue ;
78175: GO 78094
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
78177: LD_ADDR_VAR 0 8
78181: PUSH
78182: LD_EXP 62
78186: PUSH
78187: LD_VAR 0 2
78191: ARRAY
78192: PPUSH
78193: LD_INT 25
78195: PUSH
78196: LD_INT 4
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PUSH
78203: LD_INT 50
78205: PUSH
78206: EMPTY
78207: LIST
78208: PUSH
78209: LD_INT 3
78211: PUSH
78212: LD_INT 60
78214: PUSH
78215: EMPTY
78216: LIST
78217: PUSH
78218: EMPTY
78219: LIST
78220: LIST
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: LIST
78226: PPUSH
78227: CALL_OW 72
78231: PUSH
78232: LD_EXP 66
78236: PUSH
78237: LD_VAR 0 2
78241: ARRAY
78242: DIFF
78243: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78244: LD_ADDR_VAR 0 9
78248: PUSH
78249: LD_EXP 62
78253: PUSH
78254: LD_VAR 0 2
78258: ARRAY
78259: PPUSH
78260: LD_INT 2
78262: PUSH
78263: LD_INT 30
78265: PUSH
78266: LD_INT 0
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: PUSH
78273: LD_INT 30
78275: PUSH
78276: LD_INT 1
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: LIST
78287: PPUSH
78288: CALL_OW 72
78292: ST_TO_ADDR
// if not tmp or not dep then
78293: LD_VAR 0 8
78297: NOT
78298: PUSH
78299: LD_VAR 0 9
78303: NOT
78304: OR
78305: IFFALSE 78309
// continue ;
78307: GO 78094
// side := GetSide ( tmp [ 1 ] ) ;
78309: LD_ADDR_VAR 0 11
78313: PUSH
78314: LD_VAR 0 8
78318: PUSH
78319: LD_INT 1
78321: ARRAY
78322: PPUSH
78323: CALL_OW 255
78327: ST_TO_ADDR
// dep := dep [ 1 ] ;
78328: LD_ADDR_VAR 0 9
78332: PUSH
78333: LD_VAR 0 9
78337: PUSH
78338: LD_INT 1
78340: ARRAY
78341: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
78342: LD_ADDR_VAR 0 7
78346: PUSH
78347: LD_EXP 90
78351: PUSH
78352: LD_VAR 0 2
78356: ARRAY
78357: PPUSH
78358: LD_INT 22
78360: PUSH
78361: LD_INT 0
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: PUSH
78368: LD_INT 25
78370: PUSH
78371: LD_INT 12
78373: PUSH
78374: EMPTY
78375: LIST
78376: LIST
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PPUSH
78382: CALL_OW 70
78386: PUSH
78387: LD_INT 22
78389: PUSH
78390: LD_INT 0
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: LD_INT 25
78399: PUSH
78400: LD_INT 12
78402: PUSH
78403: EMPTY
78404: LIST
78405: LIST
78406: PUSH
78407: LD_INT 91
78409: PUSH
78410: LD_VAR 0 9
78414: PUSH
78415: LD_INT 20
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: LIST
78422: PUSH
78423: EMPTY
78424: LIST
78425: LIST
78426: LIST
78427: PPUSH
78428: CALL_OW 69
78432: UNION
78433: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
78434: LD_ADDR_VAR 0 10
78438: PUSH
78439: LD_EXP 90
78443: PUSH
78444: LD_VAR 0 2
78448: ARRAY
78449: PPUSH
78450: LD_INT 81
78452: PUSH
78453: LD_VAR 0 11
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PPUSH
78462: CALL_OW 70
78466: ST_TO_ADDR
// if not apes or danger_at_area then
78467: LD_VAR 0 7
78471: NOT
78472: PUSH
78473: LD_VAR 0 10
78477: OR
78478: IFFALSE 78528
// begin if mc_taming [ i ] then
78480: LD_EXP 93
78484: PUSH
78485: LD_VAR 0 2
78489: ARRAY
78490: IFFALSE 78526
// begin MC_Reset ( i , 121 ) ;
78492: LD_VAR 0 2
78496: PPUSH
78497: LD_INT 121
78499: PPUSH
78500: CALL 63444 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
78504: LD_ADDR_EXP 93
78508: PUSH
78509: LD_EXP 93
78513: PPUSH
78514: LD_VAR 0 2
78518: PPUSH
78519: EMPTY
78520: PPUSH
78521: CALL_OW 1
78525: ST_TO_ADDR
// end ; continue ;
78526: GO 78094
// end ; for j in tmp do
78528: LD_ADDR_VAR 0 3
78532: PUSH
78533: LD_VAR 0 8
78537: PUSH
78538: FOR_IN
78539: IFFALSE 78875
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
78541: LD_VAR 0 3
78545: PUSH
78546: LD_EXP 93
78550: PUSH
78551: LD_VAR 0 2
78555: ARRAY
78556: IN
78557: NOT
78558: PUSH
78559: LD_EXP 93
78563: PUSH
78564: LD_VAR 0 2
78568: ARRAY
78569: PUSH
78570: LD_INT 3
78572: LESS
78573: AND
78574: IFFALSE 78632
// begin SetTag ( j , 121 ) ;
78576: LD_VAR 0 3
78580: PPUSH
78581: LD_INT 121
78583: PPUSH
78584: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
78588: LD_ADDR_EXP 93
78592: PUSH
78593: LD_EXP 93
78597: PPUSH
78598: LD_VAR 0 2
78602: PUSH
78603: LD_EXP 93
78607: PUSH
78608: LD_VAR 0 2
78612: ARRAY
78613: PUSH
78614: LD_INT 1
78616: PLUS
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PPUSH
78622: LD_VAR 0 3
78626: PPUSH
78627: CALL 21462 0 3
78631: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
78632: LD_VAR 0 3
78636: PUSH
78637: LD_EXP 93
78641: PUSH
78642: LD_VAR 0 2
78646: ARRAY
78647: IN
78648: IFFALSE 78873
// begin if GetClass ( j ) <> 4 then
78650: LD_VAR 0 3
78654: PPUSH
78655: CALL_OW 257
78659: PUSH
78660: LD_INT 4
78662: NONEQUAL
78663: IFFALSE 78716
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
78665: LD_ADDR_EXP 93
78669: PUSH
78670: LD_EXP 93
78674: PPUSH
78675: LD_VAR 0 2
78679: PPUSH
78680: LD_EXP 93
78684: PUSH
78685: LD_VAR 0 2
78689: ARRAY
78690: PUSH
78691: LD_VAR 0 3
78695: DIFF
78696: PPUSH
78697: CALL_OW 1
78701: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78702: LD_VAR 0 3
78706: PPUSH
78707: LD_INT 0
78709: PPUSH
78710: CALL_OW 109
// continue ;
78714: GO 78538
// end ; if IsInUnit ( j ) then
78716: LD_VAR 0 3
78720: PPUSH
78721: CALL_OW 310
78725: IFFALSE 78736
// ComExitBuilding ( j ) ;
78727: LD_VAR 0 3
78731: PPUSH
78732: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
78736: LD_ADDR_VAR 0 6
78740: PUSH
78741: LD_VAR 0 7
78745: PPUSH
78746: LD_VAR 0 3
78750: PPUSH
78751: CALL_OW 74
78755: ST_TO_ADDR
// if not ape then
78756: LD_VAR 0 6
78760: NOT
78761: IFFALSE 78765
// break ;
78763: GO 78875
// x := GetX ( ape ) ;
78765: LD_ADDR_VAR 0 4
78769: PUSH
78770: LD_VAR 0 6
78774: PPUSH
78775: CALL_OW 250
78779: ST_TO_ADDR
// y := GetY ( ape ) ;
78780: LD_ADDR_VAR 0 5
78784: PUSH
78785: LD_VAR 0 6
78789: PPUSH
78790: CALL_OW 251
78794: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78795: LD_VAR 0 4
78799: PPUSH
78800: LD_VAR 0 5
78804: PPUSH
78805: CALL_OW 488
78809: NOT
78810: PUSH
78811: LD_VAR 0 11
78815: PPUSH
78816: LD_VAR 0 4
78820: PPUSH
78821: LD_VAR 0 5
78825: PPUSH
78826: LD_INT 20
78828: PPUSH
78829: CALL 22726 0 4
78833: PUSH
78834: LD_INT 4
78836: ARRAY
78837: OR
78838: IFFALSE 78842
// break ;
78840: GO 78875
// if not HasTask ( j ) then
78842: LD_VAR 0 3
78846: PPUSH
78847: CALL_OW 314
78851: NOT
78852: IFFALSE 78873
// ComTameXY ( j , x , y ) ;
78854: LD_VAR 0 3
78858: PPUSH
78859: LD_VAR 0 4
78863: PPUSH
78864: LD_VAR 0 5
78868: PPUSH
78869: CALL_OW 131
// end ; end ;
78873: GO 78538
78875: POP
78876: POP
// end ;
78877: GO 78094
78879: POP
78880: POP
// end ;
78881: LD_VAR 0 1
78885: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
78886: LD_INT 0
78888: PPUSH
78889: PPUSH
78890: PPUSH
78891: PPUSH
78892: PPUSH
78893: PPUSH
78894: PPUSH
78895: PPUSH
// if not mc_bases then
78896: LD_EXP 62
78900: NOT
78901: IFFALSE 78905
// exit ;
78903: GO 79531
// for i = 1 to mc_bases do
78905: LD_ADDR_VAR 0 2
78909: PUSH
78910: DOUBLE
78911: LD_INT 1
78913: DEC
78914: ST_TO_ADDR
78915: LD_EXP 62
78919: PUSH
78920: FOR_TO
78921: IFFALSE 79529
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
78923: LD_EXP 91
78927: PUSH
78928: LD_VAR 0 2
78932: ARRAY
78933: NOT
78934: PUSH
78935: LD_EXP 91
78939: PUSH
78940: LD_VAR 0 2
78944: ARRAY
78945: PPUSH
78946: LD_INT 25
78948: PUSH
78949: LD_INT 12
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: PPUSH
78956: CALL_OW 72
78960: NOT
78961: OR
78962: IFFALSE 78966
// continue ;
78964: GO 78920
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
78966: LD_ADDR_VAR 0 5
78970: PUSH
78971: LD_EXP 91
78975: PUSH
78976: LD_VAR 0 2
78980: ARRAY
78981: PUSH
78982: LD_INT 1
78984: ARRAY
78985: PPUSH
78986: CALL_OW 255
78990: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
78991: LD_VAR 0 5
78995: PPUSH
78996: LD_INT 2
78998: PPUSH
78999: CALL_OW 325
79003: IFFALSE 79256
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
79005: LD_ADDR_VAR 0 4
79009: PUSH
79010: LD_EXP 91
79014: PUSH
79015: LD_VAR 0 2
79019: ARRAY
79020: PPUSH
79021: LD_INT 25
79023: PUSH
79024: LD_INT 16
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: PPUSH
79031: CALL_OW 72
79035: ST_TO_ADDR
// if tmp < 6 then
79036: LD_VAR 0 4
79040: PUSH
79041: LD_INT 6
79043: LESS
79044: IFFALSE 79256
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79046: LD_ADDR_VAR 0 6
79050: PUSH
79051: LD_EXP 62
79055: PUSH
79056: LD_VAR 0 2
79060: ARRAY
79061: PPUSH
79062: LD_INT 2
79064: PUSH
79065: LD_INT 30
79067: PUSH
79068: LD_INT 0
79070: PUSH
79071: EMPTY
79072: LIST
79073: LIST
79074: PUSH
79075: LD_INT 30
79077: PUSH
79078: LD_INT 1
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: LIST
79089: PPUSH
79090: CALL_OW 72
79094: ST_TO_ADDR
// if depot then
79095: LD_VAR 0 6
79099: IFFALSE 79256
// begin selected := 0 ;
79101: LD_ADDR_VAR 0 7
79105: PUSH
79106: LD_INT 0
79108: ST_TO_ADDR
// for j in depot do
79109: LD_ADDR_VAR 0 3
79113: PUSH
79114: LD_VAR 0 6
79118: PUSH
79119: FOR_IN
79120: IFFALSE 79151
// begin if UnitsInside ( j ) < 6 then
79122: LD_VAR 0 3
79126: PPUSH
79127: CALL_OW 313
79131: PUSH
79132: LD_INT 6
79134: LESS
79135: IFFALSE 79149
// begin selected := j ;
79137: LD_ADDR_VAR 0 7
79141: PUSH
79142: LD_VAR 0 3
79146: ST_TO_ADDR
// break ;
79147: GO 79151
// end ; end ;
79149: GO 79119
79151: POP
79152: POP
// if selected then
79153: LD_VAR 0 7
79157: IFFALSE 79256
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
79159: LD_ADDR_VAR 0 3
79163: PUSH
79164: LD_EXP 91
79168: PUSH
79169: LD_VAR 0 2
79173: ARRAY
79174: PPUSH
79175: LD_INT 25
79177: PUSH
79178: LD_INT 12
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PPUSH
79185: CALL_OW 72
79189: PUSH
79190: FOR_IN
79191: IFFALSE 79254
// if not HasTask ( j ) then
79193: LD_VAR 0 3
79197: PPUSH
79198: CALL_OW 314
79202: NOT
79203: IFFALSE 79252
// begin if not IsInUnit ( j ) then
79205: LD_VAR 0 3
79209: PPUSH
79210: CALL_OW 310
79214: NOT
79215: IFFALSE 79231
// ComEnterUnit ( j , selected ) ;
79217: LD_VAR 0 3
79221: PPUSH
79222: LD_VAR 0 7
79226: PPUSH
79227: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
79231: LD_VAR 0 3
79235: PPUSH
79236: LD_INT 16
79238: PPUSH
79239: CALL_OW 183
// AddComExitBuilding ( j ) ;
79243: LD_VAR 0 3
79247: PPUSH
79248: CALL_OW 182
// end ;
79252: GO 79190
79254: POP
79255: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
79256: LD_VAR 0 5
79260: PPUSH
79261: LD_INT 11
79263: PPUSH
79264: CALL_OW 325
79268: IFFALSE 79527
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
79270: LD_ADDR_VAR 0 4
79274: PUSH
79275: LD_EXP 91
79279: PUSH
79280: LD_VAR 0 2
79284: ARRAY
79285: PPUSH
79286: LD_INT 25
79288: PUSH
79289: LD_INT 16
79291: PUSH
79292: EMPTY
79293: LIST
79294: LIST
79295: PPUSH
79296: CALL_OW 72
79300: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
79301: LD_VAR 0 4
79305: PUSH
79306: LD_INT 6
79308: GREATEREQUAL
79309: PUSH
79310: LD_VAR 0 5
79314: PPUSH
79315: LD_INT 2
79317: PPUSH
79318: CALL_OW 325
79322: NOT
79323: OR
79324: IFFALSE 79527
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79326: LD_ADDR_VAR 0 8
79330: PUSH
79331: LD_EXP 62
79335: PUSH
79336: LD_VAR 0 2
79340: ARRAY
79341: PPUSH
79342: LD_INT 2
79344: PUSH
79345: LD_INT 30
79347: PUSH
79348: LD_INT 4
79350: PUSH
79351: EMPTY
79352: LIST
79353: LIST
79354: PUSH
79355: LD_INT 30
79357: PUSH
79358: LD_INT 5
79360: PUSH
79361: EMPTY
79362: LIST
79363: LIST
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: LIST
79369: PPUSH
79370: CALL_OW 72
79374: ST_TO_ADDR
// if barracks then
79375: LD_VAR 0 8
79379: IFFALSE 79527
// begin selected := 0 ;
79381: LD_ADDR_VAR 0 7
79385: PUSH
79386: LD_INT 0
79388: ST_TO_ADDR
// for j in barracks do
79389: LD_ADDR_VAR 0 3
79393: PUSH
79394: LD_VAR 0 8
79398: PUSH
79399: FOR_IN
79400: IFFALSE 79431
// begin if UnitsInside ( j ) < 6 then
79402: LD_VAR 0 3
79406: PPUSH
79407: CALL_OW 313
79411: PUSH
79412: LD_INT 6
79414: LESS
79415: IFFALSE 79429
// begin selected := j ;
79417: LD_ADDR_VAR 0 7
79421: PUSH
79422: LD_VAR 0 3
79426: ST_TO_ADDR
// break ;
79427: GO 79431
// end ; end ;
79429: GO 79399
79431: POP
79432: POP
// if selected then
79433: LD_VAR 0 7
79437: IFFALSE 79527
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
79439: LD_ADDR_VAR 0 3
79443: PUSH
79444: LD_EXP 91
79448: PUSH
79449: LD_VAR 0 2
79453: ARRAY
79454: PPUSH
79455: LD_INT 25
79457: PUSH
79458: LD_INT 12
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PPUSH
79465: CALL_OW 72
79469: PUSH
79470: FOR_IN
79471: IFFALSE 79525
// if not IsInUnit ( j ) and not HasTask ( j ) then
79473: LD_VAR 0 3
79477: PPUSH
79478: CALL_OW 310
79482: NOT
79483: PUSH
79484: LD_VAR 0 3
79488: PPUSH
79489: CALL_OW 314
79493: NOT
79494: AND
79495: IFFALSE 79523
// begin ComEnterUnit ( j , selected ) ;
79497: LD_VAR 0 3
79501: PPUSH
79502: LD_VAR 0 7
79506: PPUSH
79507: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
79511: LD_VAR 0 3
79515: PPUSH
79516: LD_INT 15
79518: PPUSH
79519: CALL_OW 183
// end ;
79523: GO 79470
79525: POP
79526: POP
// end ; end ; end ; end ; end ;
79527: GO 78920
79529: POP
79530: POP
// end ;
79531: LD_VAR 0 1
79535: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
79536: LD_INT 0
79538: PPUSH
79539: PPUSH
79540: PPUSH
79541: PPUSH
// if not mc_bases then
79542: LD_EXP 62
79546: NOT
79547: IFFALSE 79551
// exit ;
79549: GO 79729
// for i = 1 to mc_bases do
79551: LD_ADDR_VAR 0 2
79555: PUSH
79556: DOUBLE
79557: LD_INT 1
79559: DEC
79560: ST_TO_ADDR
79561: LD_EXP 62
79565: PUSH
79566: FOR_TO
79567: IFFALSE 79727
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
79569: LD_ADDR_VAR 0 4
79573: PUSH
79574: LD_EXP 62
79578: PUSH
79579: LD_VAR 0 2
79583: ARRAY
79584: PPUSH
79585: LD_INT 25
79587: PUSH
79588: LD_INT 9
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PPUSH
79595: CALL_OW 72
79599: ST_TO_ADDR
// if not tmp then
79600: LD_VAR 0 4
79604: NOT
79605: IFFALSE 79609
// continue ;
79607: GO 79566
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
79609: LD_EXP 88
79613: PUSH
79614: LD_VAR 0 2
79618: ARRAY
79619: PPUSH
79620: LD_INT 29
79622: PPUSH
79623: CALL_OW 325
79627: NOT
79628: PUSH
79629: LD_EXP 88
79633: PUSH
79634: LD_VAR 0 2
79638: ARRAY
79639: PPUSH
79640: LD_INT 28
79642: PPUSH
79643: CALL_OW 325
79647: NOT
79648: AND
79649: IFFALSE 79653
// continue ;
79651: GO 79566
// for j in tmp do
79653: LD_ADDR_VAR 0 3
79657: PUSH
79658: LD_VAR 0 4
79662: PUSH
79663: FOR_IN
79664: IFFALSE 79723
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79666: LD_VAR 0 3
79670: PUSH
79671: LD_EXP 65
79675: PUSH
79676: LD_VAR 0 2
79680: ARRAY
79681: PUSH
79682: LD_INT 1
79684: ARRAY
79685: IN
79686: NOT
79687: PUSH
79688: LD_VAR 0 3
79692: PUSH
79693: LD_EXP 65
79697: PUSH
79698: LD_VAR 0 2
79702: ARRAY
79703: PUSH
79704: LD_INT 2
79706: ARRAY
79707: IN
79708: NOT
79709: AND
79710: IFFALSE 79721
// ComSpaceTimeShoot ( j ) ;
79712: LD_VAR 0 3
79716: PPUSH
79717: CALL 17447 0 1
79721: GO 79663
79723: POP
79724: POP
// end ;
79725: GO 79566
79727: POP
79728: POP
// end ;
79729: LD_VAR 0 1
79733: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
79734: LD_INT 0
79736: PPUSH
79737: PPUSH
79738: PPUSH
79739: PPUSH
79740: PPUSH
79741: PPUSH
79742: PPUSH
79743: PPUSH
79744: PPUSH
// if not mc_bases then
79745: LD_EXP 62
79749: NOT
79750: IFFALSE 79754
// exit ;
79752: GO 80376
// for i = 1 to mc_bases do
79754: LD_ADDR_VAR 0 2
79758: PUSH
79759: DOUBLE
79760: LD_INT 1
79762: DEC
79763: ST_TO_ADDR
79764: LD_EXP 62
79768: PUSH
79769: FOR_TO
79770: IFFALSE 80374
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
79772: LD_EXP 97
79776: PUSH
79777: LD_VAR 0 2
79781: ARRAY
79782: NOT
79783: PUSH
79784: LD_INT 38
79786: PPUSH
79787: LD_EXP 88
79791: PUSH
79792: LD_VAR 0 2
79796: ARRAY
79797: PPUSH
79798: CALL_OW 321
79802: PUSH
79803: LD_INT 2
79805: NONEQUAL
79806: OR
79807: IFFALSE 79811
// continue ;
79809: GO 79769
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
79811: LD_ADDR_VAR 0 8
79815: PUSH
79816: LD_EXP 62
79820: PUSH
79821: LD_VAR 0 2
79825: ARRAY
79826: PPUSH
79827: LD_INT 30
79829: PUSH
79830: LD_INT 34
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PPUSH
79837: CALL_OW 72
79841: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
79842: LD_ADDR_VAR 0 9
79846: PUSH
79847: LD_EXP 62
79851: PUSH
79852: LD_VAR 0 2
79856: ARRAY
79857: PPUSH
79858: LD_INT 25
79860: PUSH
79861: LD_INT 4
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: PPUSH
79868: CALL_OW 72
79872: PPUSH
79873: LD_INT 0
79875: PPUSH
79876: CALL 51760 0 2
79880: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
79881: LD_VAR 0 9
79885: NOT
79886: PUSH
79887: LD_VAR 0 8
79891: NOT
79892: OR
79893: PUSH
79894: LD_EXP 62
79898: PUSH
79899: LD_VAR 0 2
79903: ARRAY
79904: PPUSH
79905: LD_INT 124
79907: PPUSH
79908: CALL 51760 0 2
79912: OR
79913: IFFALSE 79917
// continue ;
79915: GO 79769
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
79917: LD_EXP 98
79921: PUSH
79922: LD_VAR 0 2
79926: ARRAY
79927: PUSH
79928: LD_EXP 97
79932: PUSH
79933: LD_VAR 0 2
79937: ARRAY
79938: LESS
79939: PUSH
79940: LD_EXP 98
79944: PUSH
79945: LD_VAR 0 2
79949: ARRAY
79950: PUSH
79951: LD_VAR 0 8
79955: LESS
79956: AND
79957: IFFALSE 80372
// begin tmp := sci [ 1 ] ;
79959: LD_ADDR_VAR 0 7
79963: PUSH
79964: LD_VAR 0 9
79968: PUSH
79969: LD_INT 1
79971: ARRAY
79972: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
79973: LD_VAR 0 7
79977: PPUSH
79978: LD_INT 124
79980: PPUSH
79981: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
79985: LD_ADDR_VAR 0 3
79989: PUSH
79990: DOUBLE
79991: LD_EXP 97
79995: PUSH
79996: LD_VAR 0 2
80000: ARRAY
80001: INC
80002: ST_TO_ADDR
80003: LD_EXP 97
80007: PUSH
80008: LD_VAR 0 2
80012: ARRAY
80013: PUSH
80014: FOR_DOWNTO
80015: IFFALSE 80358
// begin if IsInUnit ( tmp ) then
80017: LD_VAR 0 7
80021: PPUSH
80022: CALL_OW 310
80026: IFFALSE 80037
// ComExitBuilding ( tmp ) ;
80028: LD_VAR 0 7
80032: PPUSH
80033: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
80037: LD_INT 35
80039: PPUSH
80040: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
80044: LD_VAR 0 7
80048: PPUSH
80049: CALL_OW 310
80053: NOT
80054: PUSH
80055: LD_VAR 0 7
80059: PPUSH
80060: CALL_OW 314
80064: NOT
80065: AND
80066: IFFALSE 80037
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
80068: LD_ADDR_VAR 0 6
80072: PUSH
80073: LD_VAR 0 7
80077: PPUSH
80078: CALL_OW 250
80082: PUSH
80083: LD_VAR 0 7
80087: PPUSH
80088: CALL_OW 251
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
80097: LD_INT 35
80099: PPUSH
80100: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
80104: LD_ADDR_VAR 0 4
80108: PUSH
80109: LD_EXP 97
80113: PUSH
80114: LD_VAR 0 2
80118: ARRAY
80119: PUSH
80120: LD_VAR 0 3
80124: ARRAY
80125: PUSH
80126: LD_INT 1
80128: ARRAY
80129: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
80130: LD_ADDR_VAR 0 5
80134: PUSH
80135: LD_EXP 97
80139: PUSH
80140: LD_VAR 0 2
80144: ARRAY
80145: PUSH
80146: LD_VAR 0 3
80150: ARRAY
80151: PUSH
80152: LD_INT 2
80154: ARRAY
80155: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
80156: LD_VAR 0 7
80160: PPUSH
80161: LD_INT 10
80163: PPUSH
80164: CALL 24427 0 2
80168: PUSH
80169: LD_INT 4
80171: ARRAY
80172: IFFALSE 80210
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
80174: LD_VAR 0 7
80178: PPUSH
80179: LD_VAR 0 6
80183: PUSH
80184: LD_INT 1
80186: ARRAY
80187: PPUSH
80188: LD_VAR 0 6
80192: PUSH
80193: LD_INT 2
80195: ARRAY
80196: PPUSH
80197: CALL_OW 111
// wait ( 0 0$10 ) ;
80201: LD_INT 350
80203: PPUSH
80204: CALL_OW 67
// end else
80208: GO 80236
// begin ComMoveXY ( tmp , x , y ) ;
80210: LD_VAR 0 7
80214: PPUSH
80215: LD_VAR 0 4
80219: PPUSH
80220: LD_VAR 0 5
80224: PPUSH
80225: CALL_OW 111
// wait ( 0 0$3 ) ;
80229: LD_INT 105
80231: PPUSH
80232: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
80236: LD_VAR 0 7
80240: PPUSH
80241: LD_VAR 0 4
80245: PPUSH
80246: LD_VAR 0 5
80250: PPUSH
80251: CALL_OW 307
80255: IFFALSE 80097
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
80257: LD_VAR 0 7
80261: PPUSH
80262: LD_VAR 0 4
80266: PPUSH
80267: LD_VAR 0 5
80271: PPUSH
80272: LD_VAR 0 8
80276: PUSH
80277: LD_VAR 0 3
80281: ARRAY
80282: PPUSH
80283: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
80287: LD_INT 35
80289: PPUSH
80290: CALL_OW 67
// until not HasTask ( tmp ) ;
80294: LD_VAR 0 7
80298: PPUSH
80299: CALL_OW 314
80303: NOT
80304: IFFALSE 80287
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
80306: LD_ADDR_EXP 98
80310: PUSH
80311: LD_EXP 98
80315: PPUSH
80316: LD_VAR 0 2
80320: PUSH
80321: LD_EXP 98
80325: PUSH
80326: LD_VAR 0 2
80330: ARRAY
80331: PUSH
80332: LD_INT 1
80334: PLUS
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: PPUSH
80340: LD_VAR 0 8
80344: PUSH
80345: LD_VAR 0 3
80349: ARRAY
80350: PPUSH
80351: CALL 21462 0 3
80355: ST_TO_ADDR
// end ;
80356: GO 80014
80358: POP
80359: POP
// MC_Reset ( i , 124 ) ;
80360: LD_VAR 0 2
80364: PPUSH
80365: LD_INT 124
80367: PPUSH
80368: CALL 63444 0 2
// end ; end ;
80372: GO 79769
80374: POP
80375: POP
// end ;
80376: LD_VAR 0 1
80380: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
80381: LD_INT 0
80383: PPUSH
80384: PPUSH
80385: PPUSH
// if not mc_bases then
80386: LD_EXP 62
80390: NOT
80391: IFFALSE 80395
// exit ;
80393: GO 81001
// for i = 1 to mc_bases do
80395: LD_ADDR_VAR 0 2
80399: PUSH
80400: DOUBLE
80401: LD_INT 1
80403: DEC
80404: ST_TO_ADDR
80405: LD_EXP 62
80409: PUSH
80410: FOR_TO
80411: IFFALSE 80999
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
80413: LD_ADDR_VAR 0 3
80417: PUSH
80418: LD_EXP 62
80422: PUSH
80423: LD_VAR 0 2
80427: ARRAY
80428: PPUSH
80429: LD_INT 25
80431: PUSH
80432: LD_INT 4
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PPUSH
80439: CALL_OW 72
80443: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80444: LD_VAR 0 3
80448: NOT
80449: PUSH
80450: LD_EXP 99
80454: PUSH
80455: LD_VAR 0 2
80459: ARRAY
80460: NOT
80461: OR
80462: PUSH
80463: LD_EXP 62
80467: PUSH
80468: LD_VAR 0 2
80472: ARRAY
80473: PPUSH
80474: LD_INT 2
80476: PUSH
80477: LD_INT 30
80479: PUSH
80480: LD_INT 0
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 30
80489: PUSH
80490: LD_INT 1
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: LIST
80501: PPUSH
80502: CALL_OW 72
80506: NOT
80507: OR
80508: IFFALSE 80558
// begin if mc_deposits_finder [ i ] then
80510: LD_EXP 100
80514: PUSH
80515: LD_VAR 0 2
80519: ARRAY
80520: IFFALSE 80556
// begin MC_Reset ( i , 125 ) ;
80522: LD_VAR 0 2
80526: PPUSH
80527: LD_INT 125
80529: PPUSH
80530: CALL 63444 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
80534: LD_ADDR_EXP 100
80538: PUSH
80539: LD_EXP 100
80543: PPUSH
80544: LD_VAR 0 2
80548: PPUSH
80549: EMPTY
80550: PPUSH
80551: CALL_OW 1
80555: ST_TO_ADDR
// end ; continue ;
80556: GO 80410
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
80558: LD_EXP 99
80562: PUSH
80563: LD_VAR 0 2
80567: ARRAY
80568: PUSH
80569: LD_INT 1
80571: ARRAY
80572: PUSH
80573: LD_INT 3
80575: ARRAY
80576: PUSH
80577: LD_INT 1
80579: EQUAL
80580: PUSH
80581: LD_INT 20
80583: PPUSH
80584: LD_EXP 88
80588: PUSH
80589: LD_VAR 0 2
80593: ARRAY
80594: PPUSH
80595: CALL_OW 321
80599: PUSH
80600: LD_INT 2
80602: NONEQUAL
80603: AND
80604: IFFALSE 80654
// begin if mc_deposits_finder [ i ] then
80606: LD_EXP 100
80610: PUSH
80611: LD_VAR 0 2
80615: ARRAY
80616: IFFALSE 80652
// begin MC_Reset ( i , 125 ) ;
80618: LD_VAR 0 2
80622: PPUSH
80623: LD_INT 125
80625: PPUSH
80626: CALL 63444 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
80630: LD_ADDR_EXP 100
80634: PUSH
80635: LD_EXP 100
80639: PPUSH
80640: LD_VAR 0 2
80644: PPUSH
80645: EMPTY
80646: PPUSH
80647: CALL_OW 1
80651: ST_TO_ADDR
// end ; continue ;
80652: GO 80410
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
80654: LD_EXP 99
80658: PUSH
80659: LD_VAR 0 2
80663: ARRAY
80664: PUSH
80665: LD_INT 1
80667: ARRAY
80668: PUSH
80669: LD_INT 1
80671: ARRAY
80672: PPUSH
80673: LD_EXP 99
80677: PUSH
80678: LD_VAR 0 2
80682: ARRAY
80683: PUSH
80684: LD_INT 1
80686: ARRAY
80687: PUSH
80688: LD_INT 2
80690: ARRAY
80691: PPUSH
80692: LD_EXP 88
80696: PUSH
80697: LD_VAR 0 2
80701: ARRAY
80702: PPUSH
80703: CALL_OW 440
80707: IFFALSE 80750
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
80709: LD_ADDR_EXP 99
80713: PUSH
80714: LD_EXP 99
80718: PPUSH
80719: LD_VAR 0 2
80723: PPUSH
80724: LD_EXP 99
80728: PUSH
80729: LD_VAR 0 2
80733: ARRAY
80734: PPUSH
80735: LD_INT 1
80737: PPUSH
80738: CALL_OW 3
80742: PPUSH
80743: CALL_OW 1
80747: ST_TO_ADDR
80748: GO 80997
// begin if not mc_deposits_finder [ i ] then
80750: LD_EXP 100
80754: PUSH
80755: LD_VAR 0 2
80759: ARRAY
80760: NOT
80761: IFFALSE 80813
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
80763: LD_ADDR_EXP 100
80767: PUSH
80768: LD_EXP 100
80772: PPUSH
80773: LD_VAR 0 2
80777: PPUSH
80778: LD_VAR 0 3
80782: PUSH
80783: LD_INT 1
80785: ARRAY
80786: PUSH
80787: EMPTY
80788: LIST
80789: PPUSH
80790: CALL_OW 1
80794: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
80795: LD_VAR 0 3
80799: PUSH
80800: LD_INT 1
80802: ARRAY
80803: PPUSH
80804: LD_INT 125
80806: PPUSH
80807: CALL_OW 109
// end else
80811: GO 80997
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
80813: LD_EXP 100
80817: PUSH
80818: LD_VAR 0 2
80822: ARRAY
80823: PUSH
80824: LD_INT 1
80826: ARRAY
80827: PPUSH
80828: CALL_OW 310
80832: IFFALSE 80855
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
80834: LD_EXP 100
80838: PUSH
80839: LD_VAR 0 2
80843: ARRAY
80844: PUSH
80845: LD_INT 1
80847: ARRAY
80848: PPUSH
80849: CALL_OW 122
80853: GO 80997
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
80855: LD_EXP 100
80859: PUSH
80860: LD_VAR 0 2
80864: ARRAY
80865: PUSH
80866: LD_INT 1
80868: ARRAY
80869: PPUSH
80870: CALL_OW 314
80874: NOT
80875: PUSH
80876: LD_EXP 100
80880: PUSH
80881: LD_VAR 0 2
80885: ARRAY
80886: PUSH
80887: LD_INT 1
80889: ARRAY
80890: PPUSH
80891: LD_EXP 99
80895: PUSH
80896: LD_VAR 0 2
80900: ARRAY
80901: PUSH
80902: LD_INT 1
80904: ARRAY
80905: PUSH
80906: LD_INT 1
80908: ARRAY
80909: PPUSH
80910: LD_EXP 99
80914: PUSH
80915: LD_VAR 0 2
80919: ARRAY
80920: PUSH
80921: LD_INT 1
80923: ARRAY
80924: PUSH
80925: LD_INT 2
80927: ARRAY
80928: PPUSH
80929: CALL_OW 297
80933: PUSH
80934: LD_INT 6
80936: GREATER
80937: AND
80938: IFFALSE 80997
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
80940: LD_EXP 100
80944: PUSH
80945: LD_VAR 0 2
80949: ARRAY
80950: PUSH
80951: LD_INT 1
80953: ARRAY
80954: PPUSH
80955: LD_EXP 99
80959: PUSH
80960: LD_VAR 0 2
80964: ARRAY
80965: PUSH
80966: LD_INT 1
80968: ARRAY
80969: PUSH
80970: LD_INT 1
80972: ARRAY
80973: PPUSH
80974: LD_EXP 99
80978: PUSH
80979: LD_VAR 0 2
80983: ARRAY
80984: PUSH
80985: LD_INT 1
80987: ARRAY
80988: PUSH
80989: LD_INT 2
80991: ARRAY
80992: PPUSH
80993: CALL_OW 111
// end ; end ; end ;
80997: GO 80410
80999: POP
81000: POP
// end ;
81001: LD_VAR 0 1
81005: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
81006: LD_INT 0
81008: PPUSH
81009: PPUSH
81010: PPUSH
81011: PPUSH
81012: PPUSH
81013: PPUSH
81014: PPUSH
81015: PPUSH
81016: PPUSH
81017: PPUSH
81018: PPUSH
// if not mc_bases then
81019: LD_EXP 62
81023: NOT
81024: IFFALSE 81028
// exit ;
81026: GO 81968
// for i = 1 to mc_bases do
81028: LD_ADDR_VAR 0 2
81032: PUSH
81033: DOUBLE
81034: LD_INT 1
81036: DEC
81037: ST_TO_ADDR
81038: LD_EXP 62
81042: PUSH
81043: FOR_TO
81044: IFFALSE 81966
// begin if not mc_bases [ i ] or mc_scan [ i ] then
81046: LD_EXP 62
81050: PUSH
81051: LD_VAR 0 2
81055: ARRAY
81056: NOT
81057: PUSH
81058: LD_EXP 85
81062: PUSH
81063: LD_VAR 0 2
81067: ARRAY
81068: OR
81069: IFFALSE 81073
// continue ;
81071: GO 81043
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
81073: LD_ADDR_VAR 0 7
81077: PUSH
81078: LD_EXP 62
81082: PUSH
81083: LD_VAR 0 2
81087: ARRAY
81088: PUSH
81089: LD_INT 1
81091: ARRAY
81092: PPUSH
81093: CALL_OW 248
81097: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
81098: LD_VAR 0 7
81102: PUSH
81103: LD_INT 3
81105: EQUAL
81106: PUSH
81107: LD_EXP 81
81111: PUSH
81112: LD_VAR 0 2
81116: ARRAY
81117: PUSH
81118: LD_EXP 84
81122: PUSH
81123: LD_VAR 0 2
81127: ARRAY
81128: UNION
81129: PPUSH
81130: LD_INT 33
81132: PUSH
81133: LD_INT 2
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: PPUSH
81140: CALL_OW 72
81144: NOT
81145: OR
81146: IFFALSE 81150
// continue ;
81148: GO 81043
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
81150: LD_ADDR_VAR 0 9
81154: PUSH
81155: LD_EXP 62
81159: PUSH
81160: LD_VAR 0 2
81164: ARRAY
81165: PPUSH
81166: LD_INT 30
81168: PUSH
81169: LD_INT 36
81171: PUSH
81172: EMPTY
81173: LIST
81174: LIST
81175: PPUSH
81176: CALL_OW 72
81180: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
81181: LD_ADDR_VAR 0 10
81185: PUSH
81186: LD_EXP 81
81190: PUSH
81191: LD_VAR 0 2
81195: ARRAY
81196: PPUSH
81197: LD_INT 34
81199: PUSH
81200: LD_INT 31
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PPUSH
81207: CALL_OW 72
81211: ST_TO_ADDR
// if not cts and not mcts then
81212: LD_VAR 0 9
81216: NOT
81217: PUSH
81218: LD_VAR 0 10
81222: NOT
81223: AND
81224: IFFALSE 81228
// continue ;
81226: GO 81043
// x := cts ;
81228: LD_ADDR_VAR 0 11
81232: PUSH
81233: LD_VAR 0 9
81237: ST_TO_ADDR
// if not x then
81238: LD_VAR 0 11
81242: NOT
81243: IFFALSE 81255
// x := mcts ;
81245: LD_ADDR_VAR 0 11
81249: PUSH
81250: LD_VAR 0 10
81254: ST_TO_ADDR
// if not x then
81255: LD_VAR 0 11
81259: NOT
81260: IFFALSE 81264
// continue ;
81262: GO 81043
// if mc_remote_driver [ i ] then
81264: LD_EXP 102
81268: PUSH
81269: LD_VAR 0 2
81273: ARRAY
81274: IFFALSE 81661
// for j in mc_remote_driver [ i ] do
81276: LD_ADDR_VAR 0 3
81280: PUSH
81281: LD_EXP 102
81285: PUSH
81286: LD_VAR 0 2
81290: ARRAY
81291: PUSH
81292: FOR_IN
81293: IFFALSE 81659
// begin if GetClass ( j ) <> 3 then
81295: LD_VAR 0 3
81299: PPUSH
81300: CALL_OW 257
81304: PUSH
81305: LD_INT 3
81307: NONEQUAL
81308: IFFALSE 81361
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
81310: LD_ADDR_EXP 102
81314: PUSH
81315: LD_EXP 102
81319: PPUSH
81320: LD_VAR 0 2
81324: PPUSH
81325: LD_EXP 102
81329: PUSH
81330: LD_VAR 0 2
81334: ARRAY
81335: PUSH
81336: LD_VAR 0 3
81340: DIFF
81341: PPUSH
81342: CALL_OW 1
81346: ST_TO_ADDR
// SetTag ( j , 0 ) ;
81347: LD_VAR 0 3
81351: PPUSH
81352: LD_INT 0
81354: PPUSH
81355: CALL_OW 109
// continue ;
81359: GO 81292
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
81361: LD_EXP 81
81365: PUSH
81366: LD_VAR 0 2
81370: ARRAY
81371: PPUSH
81372: LD_INT 34
81374: PUSH
81375: LD_INT 31
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: PUSH
81382: LD_INT 58
81384: PUSH
81385: EMPTY
81386: LIST
81387: PUSH
81388: EMPTY
81389: LIST
81390: LIST
81391: PPUSH
81392: CALL_OW 72
81396: PUSH
81397: LD_VAR 0 3
81401: PPUSH
81402: CALL 51795 0 1
81406: NOT
81407: AND
81408: IFFALSE 81479
// begin if IsInUnit ( j ) then
81410: LD_VAR 0 3
81414: PPUSH
81415: CALL_OW 310
81419: IFFALSE 81430
// ComExitBuilding ( j ) ;
81421: LD_VAR 0 3
81425: PPUSH
81426: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
81430: LD_VAR 0 3
81434: PPUSH
81435: LD_EXP 81
81439: PUSH
81440: LD_VAR 0 2
81444: ARRAY
81445: PPUSH
81446: LD_INT 34
81448: PUSH
81449: LD_INT 31
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: PUSH
81456: LD_INT 58
81458: PUSH
81459: EMPTY
81460: LIST
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: PPUSH
81466: CALL_OW 72
81470: PUSH
81471: LD_INT 1
81473: ARRAY
81474: PPUSH
81475: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
81479: LD_VAR 0 3
81483: PPUSH
81484: CALL_OW 310
81488: NOT
81489: PUSH
81490: LD_VAR 0 3
81494: PPUSH
81495: CALL_OW 310
81499: PPUSH
81500: CALL_OW 266
81504: PUSH
81505: LD_INT 36
81507: NONEQUAL
81508: PUSH
81509: LD_VAR 0 3
81513: PPUSH
81514: CALL 51795 0 1
81518: NOT
81519: AND
81520: OR
81521: IFFALSE 81657
// begin if IsInUnit ( j ) then
81523: LD_VAR 0 3
81527: PPUSH
81528: CALL_OW 310
81532: IFFALSE 81543
// ComExitBuilding ( j ) ;
81534: LD_VAR 0 3
81538: PPUSH
81539: CALL_OW 122
// ct := 0 ;
81543: LD_ADDR_VAR 0 8
81547: PUSH
81548: LD_INT 0
81550: ST_TO_ADDR
// for k in x do
81551: LD_ADDR_VAR 0 4
81555: PUSH
81556: LD_VAR 0 11
81560: PUSH
81561: FOR_IN
81562: IFFALSE 81635
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
81564: LD_VAR 0 4
81568: PPUSH
81569: CALL_OW 264
81573: PUSH
81574: LD_INT 31
81576: EQUAL
81577: PUSH
81578: LD_VAR 0 4
81582: PPUSH
81583: CALL_OW 311
81587: NOT
81588: AND
81589: PUSH
81590: LD_VAR 0 4
81594: PPUSH
81595: CALL_OW 266
81599: PUSH
81600: LD_INT 36
81602: EQUAL
81603: PUSH
81604: LD_VAR 0 4
81608: PPUSH
81609: CALL_OW 313
81613: PUSH
81614: LD_INT 3
81616: LESS
81617: AND
81618: OR
81619: IFFALSE 81633
// begin ct := k ;
81621: LD_ADDR_VAR 0 8
81625: PUSH
81626: LD_VAR 0 4
81630: ST_TO_ADDR
// break ;
81631: GO 81635
// end ;
81633: GO 81561
81635: POP
81636: POP
// if ct then
81637: LD_VAR 0 8
81641: IFFALSE 81657
// ComEnterUnit ( j , ct ) ;
81643: LD_VAR 0 3
81647: PPUSH
81648: LD_VAR 0 8
81652: PPUSH
81653: CALL_OW 120
// end ; end ;
81657: GO 81292
81659: POP
81660: POP
// places := 0 ;
81661: LD_ADDR_VAR 0 5
81665: PUSH
81666: LD_INT 0
81668: ST_TO_ADDR
// for j = 1 to x do
81669: LD_ADDR_VAR 0 3
81673: PUSH
81674: DOUBLE
81675: LD_INT 1
81677: DEC
81678: ST_TO_ADDR
81679: LD_VAR 0 11
81683: PUSH
81684: FOR_TO
81685: IFFALSE 81761
// if GetWeapon ( x [ j ] ) = ar_control_tower then
81687: LD_VAR 0 11
81691: PUSH
81692: LD_VAR 0 3
81696: ARRAY
81697: PPUSH
81698: CALL_OW 264
81702: PUSH
81703: LD_INT 31
81705: EQUAL
81706: IFFALSE 81724
// places := places + 1 else
81708: LD_ADDR_VAR 0 5
81712: PUSH
81713: LD_VAR 0 5
81717: PUSH
81718: LD_INT 1
81720: PLUS
81721: ST_TO_ADDR
81722: GO 81759
// if GetBType ( x [ j ] ) = b_control_tower then
81724: LD_VAR 0 11
81728: PUSH
81729: LD_VAR 0 3
81733: ARRAY
81734: PPUSH
81735: CALL_OW 266
81739: PUSH
81740: LD_INT 36
81742: EQUAL
81743: IFFALSE 81759
// places := places + 3 ;
81745: LD_ADDR_VAR 0 5
81749: PUSH
81750: LD_VAR 0 5
81754: PUSH
81755: LD_INT 3
81757: PLUS
81758: ST_TO_ADDR
81759: GO 81684
81761: POP
81762: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
81763: LD_VAR 0 5
81767: PUSH
81768: LD_INT 0
81770: EQUAL
81771: PUSH
81772: LD_VAR 0 5
81776: PUSH
81777: LD_EXP 102
81781: PUSH
81782: LD_VAR 0 2
81786: ARRAY
81787: LESSEQUAL
81788: OR
81789: IFFALSE 81793
// continue ;
81791: GO 81043
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
81793: LD_ADDR_VAR 0 6
81797: PUSH
81798: LD_EXP 62
81802: PUSH
81803: LD_VAR 0 2
81807: ARRAY
81808: PPUSH
81809: LD_INT 25
81811: PUSH
81812: LD_INT 3
81814: PUSH
81815: EMPTY
81816: LIST
81817: LIST
81818: PPUSH
81819: CALL_OW 72
81823: PUSH
81824: LD_EXP 102
81828: PUSH
81829: LD_VAR 0 2
81833: ARRAY
81834: DIFF
81835: PPUSH
81836: LD_INT 3
81838: PPUSH
81839: CALL 52695 0 2
81843: ST_TO_ADDR
// for j in tmp do
81844: LD_ADDR_VAR 0 3
81848: PUSH
81849: LD_VAR 0 6
81853: PUSH
81854: FOR_IN
81855: IFFALSE 81890
// if GetTag ( j ) > 0 then
81857: LD_VAR 0 3
81861: PPUSH
81862: CALL_OW 110
81866: PUSH
81867: LD_INT 0
81869: GREATER
81870: IFFALSE 81888
// tmp := tmp diff j ;
81872: LD_ADDR_VAR 0 6
81876: PUSH
81877: LD_VAR 0 6
81881: PUSH
81882: LD_VAR 0 3
81886: DIFF
81887: ST_TO_ADDR
81888: GO 81854
81890: POP
81891: POP
// if not tmp then
81892: LD_VAR 0 6
81896: NOT
81897: IFFALSE 81901
// continue ;
81899: GO 81043
// if places then
81901: LD_VAR 0 5
81905: IFFALSE 81964
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
81907: LD_ADDR_EXP 102
81911: PUSH
81912: LD_EXP 102
81916: PPUSH
81917: LD_VAR 0 2
81921: PPUSH
81922: LD_EXP 102
81926: PUSH
81927: LD_VAR 0 2
81931: ARRAY
81932: PUSH
81933: LD_VAR 0 6
81937: PUSH
81938: LD_INT 1
81940: ARRAY
81941: UNION
81942: PPUSH
81943: CALL_OW 1
81947: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
81948: LD_VAR 0 6
81952: PUSH
81953: LD_INT 1
81955: ARRAY
81956: PPUSH
81957: LD_INT 126
81959: PPUSH
81960: CALL_OW 109
// end ; end ;
81964: GO 81043
81966: POP
81967: POP
// end ;
81968: LD_VAR 0 1
81972: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
81973: LD_INT 0
81975: PPUSH
81976: PPUSH
81977: PPUSH
81978: PPUSH
81979: PPUSH
81980: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
81981: LD_VAR 0 1
81985: NOT
81986: PUSH
81987: LD_VAR 0 2
81991: NOT
81992: OR
81993: PUSH
81994: LD_VAR 0 3
81998: NOT
81999: OR
82000: PUSH
82001: LD_VAR 0 4
82005: PUSH
82006: LD_INT 1
82008: PUSH
82009: LD_INT 2
82011: PUSH
82012: LD_INT 3
82014: PUSH
82015: LD_INT 4
82017: PUSH
82018: LD_INT 5
82020: PUSH
82021: LD_INT 8
82023: PUSH
82024: LD_INT 9
82026: PUSH
82027: LD_INT 15
82029: PUSH
82030: LD_INT 16
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: IN
82044: NOT
82045: OR
82046: IFFALSE 82050
// exit ;
82048: GO 82908
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
82050: LD_ADDR_VAR 0 2
82054: PUSH
82055: LD_VAR 0 2
82059: PPUSH
82060: LD_INT 21
82062: PUSH
82063: LD_INT 3
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 24
82072: PUSH
82073: LD_INT 250
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: EMPTY
82081: LIST
82082: LIST
82083: PPUSH
82084: CALL_OW 72
82088: ST_TO_ADDR
// case class of 1 , 15 :
82089: LD_VAR 0 4
82093: PUSH
82094: LD_INT 1
82096: DOUBLE
82097: EQUAL
82098: IFTRUE 82108
82100: LD_INT 15
82102: DOUBLE
82103: EQUAL
82104: IFTRUE 82108
82106: GO 82193
82108: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
82109: LD_ADDR_VAR 0 8
82113: PUSH
82114: LD_VAR 0 2
82118: PPUSH
82119: LD_INT 2
82121: PUSH
82122: LD_INT 30
82124: PUSH
82125: LD_INT 32
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: PUSH
82132: LD_INT 30
82134: PUSH
82135: LD_INT 31
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: EMPTY
82143: LIST
82144: LIST
82145: LIST
82146: PPUSH
82147: CALL_OW 72
82151: PUSH
82152: LD_VAR 0 2
82156: PPUSH
82157: LD_INT 2
82159: PUSH
82160: LD_INT 30
82162: PUSH
82163: LD_INT 4
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PUSH
82170: LD_INT 30
82172: PUSH
82173: LD_INT 5
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: EMPTY
82181: LIST
82182: LIST
82183: LIST
82184: PPUSH
82185: CALL_OW 72
82189: ADD
82190: ST_TO_ADDR
82191: GO 82439
82193: LD_INT 2
82195: DOUBLE
82196: EQUAL
82197: IFTRUE 82207
82199: LD_INT 16
82201: DOUBLE
82202: EQUAL
82203: IFTRUE 82207
82205: GO 82253
82207: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
82208: LD_ADDR_VAR 0 8
82212: PUSH
82213: LD_VAR 0 2
82217: PPUSH
82218: LD_INT 2
82220: PUSH
82221: LD_INT 30
82223: PUSH
82224: LD_INT 0
82226: PUSH
82227: EMPTY
82228: LIST
82229: LIST
82230: PUSH
82231: LD_INT 30
82233: PUSH
82234: LD_INT 1
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: PUSH
82241: EMPTY
82242: LIST
82243: LIST
82244: LIST
82245: PPUSH
82246: CALL_OW 72
82250: ST_TO_ADDR
82251: GO 82439
82253: LD_INT 3
82255: DOUBLE
82256: EQUAL
82257: IFTRUE 82261
82259: GO 82307
82261: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
82262: LD_ADDR_VAR 0 8
82266: PUSH
82267: LD_VAR 0 2
82271: PPUSH
82272: LD_INT 2
82274: PUSH
82275: LD_INT 30
82277: PUSH
82278: LD_INT 2
82280: PUSH
82281: EMPTY
82282: LIST
82283: LIST
82284: PUSH
82285: LD_INT 30
82287: PUSH
82288: LD_INT 3
82290: PUSH
82291: EMPTY
82292: LIST
82293: LIST
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: LIST
82299: PPUSH
82300: CALL_OW 72
82304: ST_TO_ADDR
82305: GO 82439
82307: LD_INT 4
82309: DOUBLE
82310: EQUAL
82311: IFTRUE 82315
82313: GO 82372
82315: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
82316: LD_ADDR_VAR 0 8
82320: PUSH
82321: LD_VAR 0 2
82325: PPUSH
82326: LD_INT 2
82328: PUSH
82329: LD_INT 30
82331: PUSH
82332: LD_INT 6
82334: PUSH
82335: EMPTY
82336: LIST
82337: LIST
82338: PUSH
82339: LD_INT 30
82341: PUSH
82342: LD_INT 7
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 30
82351: PUSH
82352: LD_INT 8
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: EMPTY
82360: LIST
82361: LIST
82362: LIST
82363: LIST
82364: PPUSH
82365: CALL_OW 72
82369: ST_TO_ADDR
82370: GO 82439
82372: LD_INT 5
82374: DOUBLE
82375: EQUAL
82376: IFTRUE 82392
82378: LD_INT 8
82380: DOUBLE
82381: EQUAL
82382: IFTRUE 82392
82384: LD_INT 9
82386: DOUBLE
82387: EQUAL
82388: IFTRUE 82392
82390: GO 82438
82392: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
82393: LD_ADDR_VAR 0 8
82397: PUSH
82398: LD_VAR 0 2
82402: PPUSH
82403: LD_INT 2
82405: PUSH
82406: LD_INT 30
82408: PUSH
82409: LD_INT 4
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: PUSH
82416: LD_INT 30
82418: PUSH
82419: LD_INT 5
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: EMPTY
82427: LIST
82428: LIST
82429: LIST
82430: PPUSH
82431: CALL_OW 72
82435: ST_TO_ADDR
82436: GO 82439
82438: POP
// if not tmp then
82439: LD_VAR 0 8
82443: NOT
82444: IFFALSE 82448
// exit ;
82446: GO 82908
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
82448: LD_VAR 0 4
82452: PUSH
82453: LD_INT 1
82455: PUSH
82456: LD_INT 15
82458: PUSH
82459: EMPTY
82460: LIST
82461: LIST
82462: IN
82463: PUSH
82464: LD_EXP 71
82468: PUSH
82469: LD_VAR 0 1
82473: ARRAY
82474: AND
82475: IFFALSE 82631
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
82477: LD_ADDR_VAR 0 9
82481: PUSH
82482: LD_EXP 71
82486: PUSH
82487: LD_VAR 0 1
82491: ARRAY
82492: PUSH
82493: LD_INT 1
82495: ARRAY
82496: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
82497: LD_VAR 0 9
82501: PUSH
82502: LD_EXP 72
82506: PUSH
82507: LD_VAR 0 1
82511: ARRAY
82512: IN
82513: NOT
82514: IFFALSE 82629
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
82516: LD_ADDR_EXP 72
82520: PUSH
82521: LD_EXP 72
82525: PPUSH
82526: LD_VAR 0 1
82530: PUSH
82531: LD_EXP 72
82535: PUSH
82536: LD_VAR 0 1
82540: ARRAY
82541: PUSH
82542: LD_INT 1
82544: PLUS
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: PPUSH
82550: LD_VAR 0 9
82554: PPUSH
82555: CALL 21462 0 3
82559: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
82560: LD_ADDR_EXP 71
82564: PUSH
82565: LD_EXP 71
82569: PPUSH
82570: LD_VAR 0 1
82574: PPUSH
82575: LD_EXP 71
82579: PUSH
82580: LD_VAR 0 1
82584: ARRAY
82585: PUSH
82586: LD_VAR 0 9
82590: DIFF
82591: PPUSH
82592: CALL_OW 1
82596: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
82597: LD_VAR 0 3
82601: PPUSH
82602: LD_EXP 72
82606: PUSH
82607: LD_VAR 0 1
82611: ARRAY
82612: PUSH
82613: LD_EXP 72
82617: PUSH
82618: LD_VAR 0 1
82622: ARRAY
82623: ARRAY
82624: PPUSH
82625: CALL_OW 120
// end ; exit ;
82629: GO 82908
// end ; if tmp > 1 then
82631: LD_VAR 0 8
82635: PUSH
82636: LD_INT 1
82638: GREATER
82639: IFFALSE 82743
// for i = 2 to tmp do
82641: LD_ADDR_VAR 0 6
82645: PUSH
82646: DOUBLE
82647: LD_INT 2
82649: DEC
82650: ST_TO_ADDR
82651: LD_VAR 0 8
82655: PUSH
82656: FOR_TO
82657: IFFALSE 82741
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
82659: LD_VAR 0 8
82663: PUSH
82664: LD_VAR 0 6
82668: ARRAY
82669: PPUSH
82670: CALL_OW 461
82674: PUSH
82675: LD_INT 6
82677: EQUAL
82678: IFFALSE 82739
// begin x := tmp [ i ] ;
82680: LD_ADDR_VAR 0 9
82684: PUSH
82685: LD_VAR 0 8
82689: PUSH
82690: LD_VAR 0 6
82694: ARRAY
82695: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
82696: LD_ADDR_VAR 0 8
82700: PUSH
82701: LD_VAR 0 8
82705: PPUSH
82706: LD_VAR 0 6
82710: PPUSH
82711: CALL_OW 3
82715: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
82716: LD_ADDR_VAR 0 8
82720: PUSH
82721: LD_VAR 0 8
82725: PPUSH
82726: LD_INT 1
82728: PPUSH
82729: LD_VAR 0 9
82733: PPUSH
82734: CALL_OW 2
82738: ST_TO_ADDR
// end ;
82739: GO 82656
82741: POP
82742: POP
// for i in tmp do
82743: LD_ADDR_VAR 0 6
82747: PUSH
82748: LD_VAR 0 8
82752: PUSH
82753: FOR_IN
82754: IFFALSE 82781
// begin if IsNotFull ( i ) then
82756: LD_VAR 0 6
82760: PPUSH
82761: CALL 18684 0 1
82765: IFFALSE 82779
// begin j := i ;
82767: LD_ADDR_VAR 0 7
82771: PUSH
82772: LD_VAR 0 6
82776: ST_TO_ADDR
// break ;
82777: GO 82781
// end ; end ;
82779: GO 82753
82781: POP
82782: POP
// if j then
82783: LD_VAR 0 7
82787: IFFALSE 82805
// ComEnterUnit ( unit , j ) else
82789: LD_VAR 0 3
82793: PPUSH
82794: LD_VAR 0 7
82798: PPUSH
82799: CALL_OW 120
82803: GO 82908
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82805: LD_ADDR_VAR 0 10
82809: PUSH
82810: LD_VAR 0 2
82814: PPUSH
82815: LD_INT 2
82817: PUSH
82818: LD_INT 30
82820: PUSH
82821: LD_INT 0
82823: PUSH
82824: EMPTY
82825: LIST
82826: LIST
82827: PUSH
82828: LD_INT 30
82830: PUSH
82831: LD_INT 1
82833: PUSH
82834: EMPTY
82835: LIST
82836: LIST
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: LIST
82842: PPUSH
82843: CALL_OW 72
82847: ST_TO_ADDR
// if depot then
82848: LD_VAR 0 10
82852: IFFALSE 82908
// begin depot := NearestUnitToUnit ( depot , unit ) ;
82854: LD_ADDR_VAR 0 10
82858: PUSH
82859: LD_VAR 0 10
82863: PPUSH
82864: LD_VAR 0 3
82868: PPUSH
82869: CALL_OW 74
82873: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
82874: LD_VAR 0 3
82878: PPUSH
82879: LD_VAR 0 10
82883: PPUSH
82884: CALL_OW 296
82888: PUSH
82889: LD_INT 10
82891: GREATER
82892: IFFALSE 82908
// ComStandNearbyBuilding ( unit , depot ) ;
82894: LD_VAR 0 3
82898: PPUSH
82899: LD_VAR 0 10
82903: PPUSH
82904: CALL 18064 0 2
// end ; end ; end ;
82908: LD_VAR 0 5
82912: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
82913: LD_INT 0
82915: PPUSH
82916: PPUSH
82917: PPUSH
82918: PPUSH
// if not mc_bases then
82919: LD_EXP 62
82923: NOT
82924: IFFALSE 82928
// exit ;
82926: GO 83167
// for i = 1 to mc_bases do
82928: LD_ADDR_VAR 0 2
82932: PUSH
82933: DOUBLE
82934: LD_INT 1
82936: DEC
82937: ST_TO_ADDR
82938: LD_EXP 62
82942: PUSH
82943: FOR_TO
82944: IFFALSE 83165
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
82946: LD_ADDR_VAR 0 4
82950: PUSH
82951: LD_EXP 62
82955: PUSH
82956: LD_VAR 0 2
82960: ARRAY
82961: PPUSH
82962: LD_INT 21
82964: PUSH
82965: LD_INT 1
82967: PUSH
82968: EMPTY
82969: LIST
82970: LIST
82971: PPUSH
82972: CALL_OW 72
82976: PUSH
82977: LD_EXP 91
82981: PUSH
82982: LD_VAR 0 2
82986: ARRAY
82987: UNION
82988: ST_TO_ADDR
// if not tmp then
82989: LD_VAR 0 4
82993: NOT
82994: IFFALSE 82998
// continue ;
82996: GO 82943
// for j in tmp do
82998: LD_ADDR_VAR 0 3
83002: PUSH
83003: LD_VAR 0 4
83007: PUSH
83008: FOR_IN
83009: IFFALSE 83161
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
83011: LD_VAR 0 3
83015: PPUSH
83016: CALL_OW 110
83020: NOT
83021: PUSH
83022: LD_VAR 0 3
83026: PPUSH
83027: CALL_OW 314
83031: NOT
83032: AND
83033: PUSH
83034: LD_VAR 0 3
83038: PPUSH
83039: CALL_OW 311
83043: NOT
83044: AND
83045: PUSH
83046: LD_VAR 0 3
83050: PPUSH
83051: CALL_OW 310
83055: NOT
83056: AND
83057: PUSH
83058: LD_VAR 0 3
83062: PUSH
83063: LD_EXP 65
83067: PUSH
83068: LD_VAR 0 2
83072: ARRAY
83073: PUSH
83074: LD_INT 1
83076: ARRAY
83077: IN
83078: NOT
83079: AND
83080: PUSH
83081: LD_VAR 0 3
83085: PUSH
83086: LD_EXP 65
83090: PUSH
83091: LD_VAR 0 2
83095: ARRAY
83096: PUSH
83097: LD_INT 2
83099: ARRAY
83100: IN
83101: NOT
83102: AND
83103: PUSH
83104: LD_VAR 0 3
83108: PUSH
83109: LD_EXP 74
83113: PUSH
83114: LD_VAR 0 2
83118: ARRAY
83119: IN
83120: NOT
83121: AND
83122: IFFALSE 83159
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
83124: LD_VAR 0 2
83128: PPUSH
83129: LD_EXP 62
83133: PUSH
83134: LD_VAR 0 2
83138: ARRAY
83139: PPUSH
83140: LD_VAR 0 3
83144: PPUSH
83145: LD_VAR 0 3
83149: PPUSH
83150: CALL_OW 257
83154: PPUSH
83155: CALL 81973 0 4
// end ;
83159: GO 83008
83161: POP
83162: POP
// end ;
83163: GO 82943
83165: POP
83166: POP
// end ;
83167: LD_VAR 0 1
83171: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
83172: LD_INT 0
83174: PPUSH
83175: PPUSH
83176: PPUSH
83177: PPUSH
83178: PPUSH
83179: PPUSH
// if not mc_bases [ base ] then
83180: LD_EXP 62
83184: PUSH
83185: LD_VAR 0 1
83189: ARRAY
83190: NOT
83191: IFFALSE 83195
// exit ;
83193: GO 83396
// tmp := [ ] ;
83195: LD_ADDR_VAR 0 6
83199: PUSH
83200: EMPTY
83201: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
83202: LD_ADDR_VAR 0 7
83206: PUSH
83207: LD_VAR 0 3
83211: PPUSH
83212: LD_INT 0
83214: PPUSH
83215: CALL_OW 517
83219: ST_TO_ADDR
// if not list then
83220: LD_VAR 0 7
83224: NOT
83225: IFFALSE 83229
// exit ;
83227: GO 83396
// c := Count ( list [ 1 ] ) ;
83229: LD_ADDR_VAR 0 9
83233: PUSH
83234: LD_VAR 0 7
83238: PUSH
83239: LD_INT 1
83241: ARRAY
83242: PPUSH
83243: CALL 18602 0 1
83247: ST_TO_ADDR
// if amount > c then
83248: LD_VAR 0 2
83252: PUSH
83253: LD_VAR 0 9
83257: GREATER
83258: IFFALSE 83270
// amount := c ;
83260: LD_ADDR_VAR 0 2
83264: PUSH
83265: LD_VAR 0 9
83269: ST_TO_ADDR
// for i := 1 to amount do
83270: LD_ADDR_VAR 0 5
83274: PUSH
83275: DOUBLE
83276: LD_INT 1
83278: DEC
83279: ST_TO_ADDR
83280: LD_VAR 0 2
83284: PUSH
83285: FOR_TO
83286: IFFALSE 83344
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
83288: LD_ADDR_VAR 0 6
83292: PUSH
83293: LD_VAR 0 6
83297: PPUSH
83298: LD_VAR 0 5
83302: PPUSH
83303: LD_VAR 0 7
83307: PUSH
83308: LD_INT 1
83310: ARRAY
83311: PUSH
83312: LD_VAR 0 5
83316: ARRAY
83317: PUSH
83318: LD_VAR 0 7
83322: PUSH
83323: LD_INT 2
83325: ARRAY
83326: PUSH
83327: LD_VAR 0 5
83331: ARRAY
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PPUSH
83337: CALL_OW 1
83341: ST_TO_ADDR
83342: GO 83285
83344: POP
83345: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
83346: LD_ADDR_EXP 75
83350: PUSH
83351: LD_EXP 75
83355: PPUSH
83356: LD_VAR 0 1
83360: PPUSH
83361: LD_VAR 0 6
83365: PPUSH
83366: CALL_OW 1
83370: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
83371: LD_ADDR_EXP 77
83375: PUSH
83376: LD_EXP 77
83380: PPUSH
83381: LD_VAR 0 1
83385: PPUSH
83386: LD_VAR 0 3
83390: PPUSH
83391: CALL_OW 1
83395: ST_TO_ADDR
// end ;
83396: LD_VAR 0 4
83400: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
83401: LD_INT 0
83403: PPUSH
// if not mc_bases [ base ] then
83404: LD_EXP 62
83408: PUSH
83409: LD_VAR 0 1
83413: ARRAY
83414: NOT
83415: IFFALSE 83419
// exit ;
83417: GO 83444
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
83419: LD_ADDR_EXP 67
83423: PUSH
83424: LD_EXP 67
83428: PPUSH
83429: LD_VAR 0 1
83433: PPUSH
83434: LD_VAR 0 2
83438: PPUSH
83439: CALL_OW 1
83443: ST_TO_ADDR
// end ;
83444: LD_VAR 0 3
83448: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
83449: LD_INT 0
83451: PPUSH
// if not mc_bases [ base ] then
83452: LD_EXP 62
83456: PUSH
83457: LD_VAR 0 1
83461: ARRAY
83462: NOT
83463: IFFALSE 83467
// exit ;
83465: GO 83504
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
83467: LD_ADDR_EXP 67
83471: PUSH
83472: LD_EXP 67
83476: PPUSH
83477: LD_VAR 0 1
83481: PPUSH
83482: LD_EXP 67
83486: PUSH
83487: LD_VAR 0 1
83491: ARRAY
83492: PUSH
83493: LD_VAR 0 2
83497: UNION
83498: PPUSH
83499: CALL_OW 1
83503: ST_TO_ADDR
// end ;
83504: LD_VAR 0 3
83508: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
83509: LD_INT 0
83511: PPUSH
// if not mc_bases [ base ] then
83512: LD_EXP 62
83516: PUSH
83517: LD_VAR 0 1
83521: ARRAY
83522: NOT
83523: IFFALSE 83527
// exit ;
83525: GO 83552
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
83527: LD_ADDR_EXP 83
83531: PUSH
83532: LD_EXP 83
83536: PPUSH
83537: LD_VAR 0 1
83541: PPUSH
83542: LD_VAR 0 2
83546: PPUSH
83547: CALL_OW 1
83551: ST_TO_ADDR
// end ;
83552: LD_VAR 0 3
83556: RET
// export function MC_InsertProduceList ( base , components ) ; begin
83557: LD_INT 0
83559: PPUSH
// if not mc_bases [ base ] then
83560: LD_EXP 62
83564: PUSH
83565: LD_VAR 0 1
83569: ARRAY
83570: NOT
83571: IFFALSE 83575
// exit ;
83573: GO 83612
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
83575: LD_ADDR_EXP 83
83579: PUSH
83580: LD_EXP 83
83584: PPUSH
83585: LD_VAR 0 1
83589: PPUSH
83590: LD_EXP 83
83594: PUSH
83595: LD_VAR 0 1
83599: ARRAY
83600: PUSH
83601: LD_VAR 0 2
83605: ADD
83606: PPUSH
83607: CALL_OW 1
83611: ST_TO_ADDR
// end ;
83612: LD_VAR 0 3
83616: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
83617: LD_INT 0
83619: PPUSH
// if not mc_bases [ base ] then
83620: LD_EXP 62
83624: PUSH
83625: LD_VAR 0 1
83629: ARRAY
83630: NOT
83631: IFFALSE 83635
// exit ;
83633: GO 83689
// mc_defender := Replace ( mc_defender , base , deflist ) ;
83635: LD_ADDR_EXP 84
83639: PUSH
83640: LD_EXP 84
83644: PPUSH
83645: LD_VAR 0 1
83649: PPUSH
83650: LD_VAR 0 2
83654: PPUSH
83655: CALL_OW 1
83659: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
83660: LD_ADDR_EXP 73
83664: PUSH
83665: LD_EXP 73
83669: PPUSH
83670: LD_VAR 0 1
83674: PPUSH
83675: LD_VAR 0 2
83679: PUSH
83680: LD_INT 0
83682: PLUS
83683: PPUSH
83684: CALL_OW 1
83688: ST_TO_ADDR
// end ;
83689: LD_VAR 0 3
83693: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
83694: LD_INT 0
83696: PPUSH
// if not mc_bases [ base ] then
83697: LD_EXP 62
83701: PUSH
83702: LD_VAR 0 1
83706: ARRAY
83707: NOT
83708: IFFALSE 83712
// exit ;
83710: GO 83737
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
83712: LD_ADDR_EXP 73
83716: PUSH
83717: LD_EXP 73
83721: PPUSH
83722: LD_VAR 0 1
83726: PPUSH
83727: LD_VAR 0 2
83731: PPUSH
83732: CALL_OW 1
83736: ST_TO_ADDR
// end ;
83737: LD_VAR 0 3
83741: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
83742: LD_INT 0
83744: PPUSH
83745: PPUSH
83746: PPUSH
83747: PPUSH
// if not mc_bases [ base ] then
83748: LD_EXP 62
83752: PUSH
83753: LD_VAR 0 1
83757: ARRAY
83758: NOT
83759: IFFALSE 83763
// exit ;
83761: GO 83828
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
83763: LD_ADDR_EXP 82
83767: PUSH
83768: LD_EXP 82
83772: PPUSH
83773: LD_VAR 0 1
83777: PUSH
83778: LD_EXP 82
83782: PUSH
83783: LD_VAR 0 1
83787: ARRAY
83788: PUSH
83789: LD_INT 1
83791: PLUS
83792: PUSH
83793: EMPTY
83794: LIST
83795: LIST
83796: PPUSH
83797: LD_VAR 0 1
83801: PUSH
83802: LD_VAR 0 2
83806: PUSH
83807: LD_VAR 0 3
83811: PUSH
83812: LD_VAR 0 4
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: PPUSH
83823: CALL 21462 0 3
83827: ST_TO_ADDR
// end ;
83828: LD_VAR 0 5
83832: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
83833: LD_INT 0
83835: PPUSH
// if not mc_bases [ base ] then
83836: LD_EXP 62
83840: PUSH
83841: LD_VAR 0 1
83845: ARRAY
83846: NOT
83847: IFFALSE 83851
// exit ;
83849: GO 83876
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
83851: LD_ADDR_EXP 99
83855: PUSH
83856: LD_EXP 99
83860: PPUSH
83861: LD_VAR 0 1
83865: PPUSH
83866: LD_VAR 0 2
83870: PPUSH
83871: CALL_OW 1
83875: ST_TO_ADDR
// end ;
83876: LD_VAR 0 3
83880: RET
// export function MC_GetMinesField ( base ) ; begin
83881: LD_INT 0
83883: PPUSH
// result := mc_mines [ base ] ;
83884: LD_ADDR_VAR 0 2
83888: PUSH
83889: LD_EXP 75
83893: PUSH
83894: LD_VAR 0 1
83898: ARRAY
83899: ST_TO_ADDR
// end ;
83900: LD_VAR 0 2
83904: RET
// export function MC_GetProduceList ( base ) ; begin
83905: LD_INT 0
83907: PPUSH
// result := mc_produce [ base ] ;
83908: LD_ADDR_VAR 0 2
83912: PUSH
83913: LD_EXP 83
83917: PUSH
83918: LD_VAR 0 1
83922: ARRAY
83923: ST_TO_ADDR
// end ;
83924: LD_VAR 0 2
83928: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
83929: LD_INT 0
83931: PPUSH
83932: PPUSH
// if not mc_bases then
83933: LD_EXP 62
83937: NOT
83938: IFFALSE 83942
// exit ;
83940: GO 84007
// if mc_bases [ base ] then
83942: LD_EXP 62
83946: PUSH
83947: LD_VAR 0 1
83951: ARRAY
83952: IFFALSE 84007
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
83954: LD_ADDR_VAR 0 3
83958: PUSH
83959: LD_EXP 62
83963: PUSH
83964: LD_VAR 0 1
83968: ARRAY
83969: PPUSH
83970: LD_INT 30
83972: PUSH
83973: LD_VAR 0 2
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: PPUSH
83982: CALL_OW 72
83986: ST_TO_ADDR
// if result then
83987: LD_VAR 0 3
83991: IFFALSE 84007
// result := result [ 1 ] ;
83993: LD_ADDR_VAR 0 3
83997: PUSH
83998: LD_VAR 0 3
84002: PUSH
84003: LD_INT 1
84005: ARRAY
84006: ST_TO_ADDR
// end ; end ;
84007: LD_VAR 0 3
84011: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
84012: LD_INT 0
84014: PPUSH
84015: PPUSH
// if not mc_bases then
84016: LD_EXP 62
84020: NOT
84021: IFFALSE 84025
// exit ;
84023: GO 84070
// if mc_bases [ base ] then
84025: LD_EXP 62
84029: PUSH
84030: LD_VAR 0 1
84034: ARRAY
84035: IFFALSE 84070
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84037: LD_ADDR_VAR 0 3
84041: PUSH
84042: LD_EXP 62
84046: PUSH
84047: LD_VAR 0 1
84051: ARRAY
84052: PPUSH
84053: LD_INT 30
84055: PUSH
84056: LD_VAR 0 2
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PPUSH
84065: CALL_OW 72
84069: ST_TO_ADDR
// end ;
84070: LD_VAR 0 3
84074: RET
// export function MC_SetTame ( base , area ) ; begin
84075: LD_INT 0
84077: PPUSH
// if not mc_bases or not base then
84078: LD_EXP 62
84082: NOT
84083: PUSH
84084: LD_VAR 0 1
84088: NOT
84089: OR
84090: IFFALSE 84094
// exit ;
84092: GO 84119
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
84094: LD_ADDR_EXP 90
84098: PUSH
84099: LD_EXP 90
84103: PPUSH
84104: LD_VAR 0 1
84108: PPUSH
84109: LD_VAR 0 2
84113: PPUSH
84114: CALL_OW 1
84118: ST_TO_ADDR
// end ;
84119: LD_VAR 0 3
84123: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
84124: LD_INT 0
84126: PPUSH
84127: PPUSH
// if not mc_bases or not base then
84128: LD_EXP 62
84132: NOT
84133: PUSH
84134: LD_VAR 0 1
84138: NOT
84139: OR
84140: IFFALSE 84144
// exit ;
84142: GO 84246
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84144: LD_ADDR_VAR 0 4
84148: PUSH
84149: LD_EXP 62
84153: PUSH
84154: LD_VAR 0 1
84158: ARRAY
84159: PPUSH
84160: LD_INT 30
84162: PUSH
84163: LD_VAR 0 2
84167: PUSH
84168: EMPTY
84169: LIST
84170: LIST
84171: PPUSH
84172: CALL_OW 72
84176: ST_TO_ADDR
// if not tmp then
84177: LD_VAR 0 4
84181: NOT
84182: IFFALSE 84186
// exit ;
84184: GO 84246
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
84186: LD_ADDR_EXP 94
84190: PUSH
84191: LD_EXP 94
84195: PPUSH
84196: LD_VAR 0 1
84200: PPUSH
84201: LD_EXP 94
84205: PUSH
84206: LD_VAR 0 1
84210: ARRAY
84211: PPUSH
84212: LD_EXP 94
84216: PUSH
84217: LD_VAR 0 1
84221: ARRAY
84222: PUSH
84223: LD_INT 1
84225: PLUS
84226: PPUSH
84227: LD_VAR 0 4
84231: PUSH
84232: LD_INT 1
84234: ARRAY
84235: PPUSH
84236: CALL_OW 2
84240: PPUSH
84241: CALL_OW 1
84245: ST_TO_ADDR
// end ;
84246: LD_VAR 0 3
84250: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
84251: LD_INT 0
84253: PPUSH
84254: PPUSH
// if not mc_bases or not base or not kinds then
84255: LD_EXP 62
84259: NOT
84260: PUSH
84261: LD_VAR 0 1
84265: NOT
84266: OR
84267: PUSH
84268: LD_VAR 0 2
84272: NOT
84273: OR
84274: IFFALSE 84278
// exit ;
84276: GO 84339
// for i in kinds do
84278: LD_ADDR_VAR 0 4
84282: PUSH
84283: LD_VAR 0 2
84287: PUSH
84288: FOR_IN
84289: IFFALSE 84337
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
84291: LD_ADDR_EXP 96
84295: PUSH
84296: LD_EXP 96
84300: PPUSH
84301: LD_VAR 0 1
84305: PUSH
84306: LD_EXP 96
84310: PUSH
84311: LD_VAR 0 1
84315: ARRAY
84316: PUSH
84317: LD_INT 1
84319: PLUS
84320: PUSH
84321: EMPTY
84322: LIST
84323: LIST
84324: PPUSH
84325: LD_VAR 0 4
84329: PPUSH
84330: CALL 21462 0 3
84334: ST_TO_ADDR
84335: GO 84288
84337: POP
84338: POP
// end ;
84339: LD_VAR 0 3
84343: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
84344: LD_INT 0
84346: PPUSH
// if not mc_bases or not base or not areas then
84347: LD_EXP 62
84351: NOT
84352: PUSH
84353: LD_VAR 0 1
84357: NOT
84358: OR
84359: PUSH
84360: LD_VAR 0 2
84364: NOT
84365: OR
84366: IFFALSE 84370
// exit ;
84368: GO 84395
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
84370: LD_ADDR_EXP 80
84374: PUSH
84375: LD_EXP 80
84379: PPUSH
84380: LD_VAR 0 1
84384: PPUSH
84385: LD_VAR 0 2
84389: PPUSH
84390: CALL_OW 1
84394: ST_TO_ADDR
// end ;
84395: LD_VAR 0 3
84399: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
84400: LD_INT 0
84402: PPUSH
// if not mc_bases or not base or not teleports_exit then
84403: LD_EXP 62
84407: NOT
84408: PUSH
84409: LD_VAR 0 1
84413: NOT
84414: OR
84415: PUSH
84416: LD_VAR 0 2
84420: NOT
84421: OR
84422: IFFALSE 84426
// exit ;
84424: GO 84451
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
84426: LD_ADDR_EXP 97
84430: PUSH
84431: LD_EXP 97
84435: PPUSH
84436: LD_VAR 0 1
84440: PPUSH
84441: LD_VAR 0 2
84445: PPUSH
84446: CALL_OW 1
84450: ST_TO_ADDR
// end ;
84451: LD_VAR 0 3
84455: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
84456: LD_INT 0
84458: PPUSH
84459: PPUSH
84460: PPUSH
// if not mc_bases or not base or not ext_list then
84461: LD_EXP 62
84465: NOT
84466: PUSH
84467: LD_VAR 0 1
84471: NOT
84472: OR
84473: PUSH
84474: LD_VAR 0 5
84478: NOT
84479: OR
84480: IFFALSE 84484
// exit ;
84482: GO 84657
// tmp := GetFacExtXYD ( x , y , d ) ;
84484: LD_ADDR_VAR 0 8
84488: PUSH
84489: LD_VAR 0 2
84493: PPUSH
84494: LD_VAR 0 3
84498: PPUSH
84499: LD_VAR 0 4
84503: PPUSH
84504: CALL 51825 0 3
84508: ST_TO_ADDR
// if not tmp then
84509: LD_VAR 0 8
84513: NOT
84514: IFFALSE 84518
// exit ;
84516: GO 84657
// for i in tmp do
84518: LD_ADDR_VAR 0 7
84522: PUSH
84523: LD_VAR 0 8
84527: PUSH
84528: FOR_IN
84529: IFFALSE 84655
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
84531: LD_ADDR_EXP 67
84535: PUSH
84536: LD_EXP 67
84540: PPUSH
84541: LD_VAR 0 1
84545: PPUSH
84546: LD_EXP 67
84550: PUSH
84551: LD_VAR 0 1
84555: ARRAY
84556: PPUSH
84557: LD_EXP 67
84561: PUSH
84562: LD_VAR 0 1
84566: ARRAY
84567: PUSH
84568: LD_INT 1
84570: PLUS
84571: PPUSH
84572: LD_VAR 0 5
84576: PUSH
84577: LD_INT 1
84579: ARRAY
84580: PUSH
84581: LD_VAR 0 7
84585: PUSH
84586: LD_INT 1
84588: ARRAY
84589: PUSH
84590: LD_VAR 0 7
84594: PUSH
84595: LD_INT 2
84597: ARRAY
84598: PUSH
84599: LD_VAR 0 7
84603: PUSH
84604: LD_INT 3
84606: ARRAY
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: LIST
84612: LIST
84613: PPUSH
84614: CALL_OW 2
84618: PPUSH
84619: CALL_OW 1
84623: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
84624: LD_ADDR_VAR 0 5
84628: PUSH
84629: LD_VAR 0 5
84633: PPUSH
84634: LD_INT 1
84636: PPUSH
84637: CALL_OW 3
84641: ST_TO_ADDR
// if not ext_list then
84642: LD_VAR 0 5
84646: NOT
84647: IFFALSE 84653
// exit ;
84649: POP
84650: POP
84651: GO 84657
// end ;
84653: GO 84528
84655: POP
84656: POP
// end ;
84657: LD_VAR 0 6
84661: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
84662: LD_INT 0
84664: PPUSH
// if not mc_bases or not base or not weapon_list then
84665: LD_EXP 62
84669: NOT
84670: PUSH
84671: LD_VAR 0 1
84675: NOT
84676: OR
84677: PUSH
84678: LD_VAR 0 2
84682: NOT
84683: OR
84684: IFFALSE 84688
// exit ;
84686: GO 84713
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
84688: LD_ADDR_EXP 101
84692: PUSH
84693: LD_EXP 101
84697: PPUSH
84698: LD_VAR 0 1
84702: PPUSH
84703: LD_VAR 0 2
84707: PPUSH
84708: CALL_OW 1
84712: ST_TO_ADDR
// end ;
84713: LD_VAR 0 3
84717: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
84718: LD_INT 0
84720: PPUSH
// if not mc_bases or not base or not tech_list then
84721: LD_EXP 62
84725: NOT
84726: PUSH
84727: LD_VAR 0 1
84731: NOT
84732: OR
84733: PUSH
84734: LD_VAR 0 2
84738: NOT
84739: OR
84740: IFFALSE 84744
// exit ;
84742: GO 84769
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
84744: LD_ADDR_EXP 89
84748: PUSH
84749: LD_EXP 89
84753: PPUSH
84754: LD_VAR 0 1
84758: PPUSH
84759: LD_VAR 0 2
84763: PPUSH
84764: CALL_OW 1
84768: ST_TO_ADDR
// end ;
84769: LD_VAR 0 3
84773: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
84774: LD_INT 0
84776: PPUSH
// if not mc_bases or not parking_area or not base then
84777: LD_EXP 62
84781: NOT
84782: PUSH
84783: LD_VAR 0 2
84787: NOT
84788: OR
84789: PUSH
84790: LD_VAR 0 1
84794: NOT
84795: OR
84796: IFFALSE 84800
// exit ;
84798: GO 84825
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
84800: LD_ADDR_EXP 86
84804: PUSH
84805: LD_EXP 86
84809: PPUSH
84810: LD_VAR 0 1
84814: PPUSH
84815: LD_VAR 0 2
84819: PPUSH
84820: CALL_OW 1
84824: ST_TO_ADDR
// end ;
84825: LD_VAR 0 3
84829: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
84830: LD_INT 0
84832: PPUSH
// if not mc_bases or not base or not scan_area then
84833: LD_EXP 62
84837: NOT
84838: PUSH
84839: LD_VAR 0 1
84843: NOT
84844: OR
84845: PUSH
84846: LD_VAR 0 2
84850: NOT
84851: OR
84852: IFFALSE 84856
// exit ;
84854: GO 84881
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
84856: LD_ADDR_EXP 87
84860: PUSH
84861: LD_EXP 87
84865: PPUSH
84866: LD_VAR 0 1
84870: PPUSH
84871: LD_VAR 0 2
84875: PPUSH
84876: CALL_OW 1
84880: ST_TO_ADDR
// end ;
84881: LD_VAR 0 3
84885: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
84886: LD_INT 0
84888: PPUSH
84889: PPUSH
// if not mc_bases or not base then
84890: LD_EXP 62
84894: NOT
84895: PUSH
84896: LD_VAR 0 1
84900: NOT
84901: OR
84902: IFFALSE 84906
// exit ;
84904: GO 84970
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
84906: LD_ADDR_VAR 0 3
84910: PUSH
84911: LD_INT 1
84913: PUSH
84914: LD_INT 2
84916: PUSH
84917: LD_INT 3
84919: PUSH
84920: LD_INT 4
84922: PUSH
84923: LD_INT 11
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
84933: LD_ADDR_EXP 89
84937: PUSH
84938: LD_EXP 89
84942: PPUSH
84943: LD_VAR 0 1
84947: PPUSH
84948: LD_EXP 89
84952: PUSH
84953: LD_VAR 0 1
84957: ARRAY
84958: PUSH
84959: LD_VAR 0 3
84963: DIFF
84964: PPUSH
84965: CALL_OW 1
84969: ST_TO_ADDR
// end ;
84970: LD_VAR 0 2
84974: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
84975: LD_INT 0
84977: PPUSH
// result := mc_vehicles [ base ] ;
84978: LD_ADDR_VAR 0 3
84982: PUSH
84983: LD_EXP 81
84987: PUSH
84988: LD_VAR 0 1
84992: ARRAY
84993: ST_TO_ADDR
// if onlyCombat then
84994: LD_VAR 0 2
84998: IFFALSE 85170
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
85000: LD_ADDR_VAR 0 3
85004: PUSH
85005: LD_VAR 0 3
85009: PUSH
85010: LD_VAR 0 3
85014: PPUSH
85015: LD_INT 2
85017: PUSH
85018: LD_INT 34
85020: PUSH
85021: LD_INT 12
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_INT 34
85030: PUSH
85031: LD_INT 51
85033: PUSH
85034: EMPTY
85035: LIST
85036: LIST
85037: PUSH
85038: LD_INT 34
85040: PUSH
85041: LD_INT 89
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 34
85050: PUSH
85051: LD_INT 32
85053: PUSH
85054: EMPTY
85055: LIST
85056: LIST
85057: PUSH
85058: LD_INT 34
85060: PUSH
85061: LD_INT 13
85063: PUSH
85064: EMPTY
85065: LIST
85066: LIST
85067: PUSH
85068: LD_INT 34
85070: PUSH
85071: LD_INT 52
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: PUSH
85078: LD_INT 34
85080: PUSH
85081: LD_INT 88
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_INT 34
85090: PUSH
85091: LD_INT 14
85093: PUSH
85094: EMPTY
85095: LIST
85096: LIST
85097: PUSH
85098: LD_INT 34
85100: PUSH
85101: LD_INT 53
85103: PUSH
85104: EMPTY
85105: LIST
85106: LIST
85107: PUSH
85108: LD_INT 34
85110: PUSH
85111: LD_INT 98
85113: PUSH
85114: EMPTY
85115: LIST
85116: LIST
85117: PUSH
85118: LD_INT 34
85120: PUSH
85121: LD_INT 31
85123: PUSH
85124: EMPTY
85125: LIST
85126: LIST
85127: PUSH
85128: LD_INT 34
85130: PUSH
85131: LD_INT 48
85133: PUSH
85134: EMPTY
85135: LIST
85136: LIST
85137: PUSH
85138: LD_INT 34
85140: PUSH
85141: LD_INT 8
85143: PUSH
85144: EMPTY
85145: LIST
85146: LIST
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: LIST
85156: LIST
85157: LIST
85158: LIST
85159: LIST
85160: LIST
85161: LIST
85162: LIST
85163: PPUSH
85164: CALL_OW 72
85168: DIFF
85169: ST_TO_ADDR
// end ; end_of_file
85170: LD_VAR 0 3
85174: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
85175: LD_INT 0
85177: PPUSH
85178: PPUSH
85179: PPUSH
// if not mc_bases or not skirmish then
85180: LD_EXP 62
85184: NOT
85185: PUSH
85186: LD_EXP 60
85190: NOT
85191: OR
85192: IFFALSE 85196
// exit ;
85194: GO 85361
// for i = 1 to mc_bases do
85196: LD_ADDR_VAR 0 4
85200: PUSH
85201: DOUBLE
85202: LD_INT 1
85204: DEC
85205: ST_TO_ADDR
85206: LD_EXP 62
85210: PUSH
85211: FOR_TO
85212: IFFALSE 85359
// begin if sci in mc_bases [ i ] then
85214: LD_VAR 0 2
85218: PUSH
85219: LD_EXP 62
85223: PUSH
85224: LD_VAR 0 4
85228: ARRAY
85229: IN
85230: IFFALSE 85357
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
85232: LD_ADDR_EXP 91
85236: PUSH
85237: LD_EXP 91
85241: PPUSH
85242: LD_VAR 0 4
85246: PUSH
85247: LD_EXP 91
85251: PUSH
85252: LD_VAR 0 4
85256: ARRAY
85257: PUSH
85258: LD_INT 1
85260: PLUS
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PPUSH
85266: LD_VAR 0 1
85270: PPUSH
85271: CALL 21462 0 3
85275: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
85276: LD_ADDR_VAR 0 5
85280: PUSH
85281: LD_EXP 62
85285: PUSH
85286: LD_VAR 0 4
85290: ARRAY
85291: PPUSH
85292: LD_INT 2
85294: PUSH
85295: LD_INT 30
85297: PUSH
85298: LD_INT 0
85300: PUSH
85301: EMPTY
85302: LIST
85303: LIST
85304: PUSH
85305: LD_INT 30
85307: PUSH
85308: LD_INT 1
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: LIST
85319: PPUSH
85320: CALL_OW 72
85324: PPUSH
85325: LD_VAR 0 1
85329: PPUSH
85330: CALL_OW 74
85334: ST_TO_ADDR
// if tmp then
85335: LD_VAR 0 5
85339: IFFALSE 85355
// ComStandNearbyBuilding ( ape , tmp ) ;
85341: LD_VAR 0 1
85345: PPUSH
85346: LD_VAR 0 5
85350: PPUSH
85351: CALL 18064 0 2
// break ;
85355: GO 85359
// end ; end ;
85357: GO 85211
85359: POP
85360: POP
// end ;
85361: LD_VAR 0 3
85365: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
85366: LD_INT 0
85368: PPUSH
85369: PPUSH
85370: PPUSH
// if not mc_bases or not skirmish then
85371: LD_EXP 62
85375: NOT
85376: PUSH
85377: LD_EXP 60
85381: NOT
85382: OR
85383: IFFALSE 85387
// exit ;
85385: GO 85476
// for i = 1 to mc_bases do
85387: LD_ADDR_VAR 0 4
85391: PUSH
85392: DOUBLE
85393: LD_INT 1
85395: DEC
85396: ST_TO_ADDR
85397: LD_EXP 62
85401: PUSH
85402: FOR_TO
85403: IFFALSE 85474
// begin if building in mc_busy_turret_list [ i ] then
85405: LD_VAR 0 1
85409: PUSH
85410: LD_EXP 72
85414: PUSH
85415: LD_VAR 0 4
85419: ARRAY
85420: IN
85421: IFFALSE 85472
// begin tmp := mc_busy_turret_list [ i ] diff building ;
85423: LD_ADDR_VAR 0 5
85427: PUSH
85428: LD_EXP 72
85432: PUSH
85433: LD_VAR 0 4
85437: ARRAY
85438: PUSH
85439: LD_VAR 0 1
85443: DIFF
85444: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
85445: LD_ADDR_EXP 72
85449: PUSH
85450: LD_EXP 72
85454: PPUSH
85455: LD_VAR 0 4
85459: PPUSH
85460: LD_VAR 0 5
85464: PPUSH
85465: CALL_OW 1
85469: ST_TO_ADDR
// break ;
85470: GO 85474
// end ; end ;
85472: GO 85402
85474: POP
85475: POP
// end ;
85476: LD_VAR 0 3
85480: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
85481: LD_INT 0
85483: PPUSH
85484: PPUSH
85485: PPUSH
// if not mc_bases or not skirmish then
85486: LD_EXP 62
85490: NOT
85491: PUSH
85492: LD_EXP 60
85496: NOT
85497: OR
85498: IFFALSE 85502
// exit ;
85500: GO 85701
// for i = 1 to mc_bases do
85502: LD_ADDR_VAR 0 5
85506: PUSH
85507: DOUBLE
85508: LD_INT 1
85510: DEC
85511: ST_TO_ADDR
85512: LD_EXP 62
85516: PUSH
85517: FOR_TO
85518: IFFALSE 85699
// if building in mc_bases [ i ] then
85520: LD_VAR 0 1
85524: PUSH
85525: LD_EXP 62
85529: PUSH
85530: LD_VAR 0 5
85534: ARRAY
85535: IN
85536: IFFALSE 85697
// begin tmp := mc_bases [ i ] diff building ;
85538: LD_ADDR_VAR 0 6
85542: PUSH
85543: LD_EXP 62
85547: PUSH
85548: LD_VAR 0 5
85552: ARRAY
85553: PUSH
85554: LD_VAR 0 1
85558: DIFF
85559: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
85560: LD_ADDR_EXP 62
85564: PUSH
85565: LD_EXP 62
85569: PPUSH
85570: LD_VAR 0 5
85574: PPUSH
85575: LD_VAR 0 6
85579: PPUSH
85580: CALL_OW 1
85584: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
85585: LD_VAR 0 1
85589: PUSH
85590: LD_EXP 70
85594: PUSH
85595: LD_VAR 0 5
85599: ARRAY
85600: IN
85601: IFFALSE 85640
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
85603: LD_ADDR_EXP 70
85607: PUSH
85608: LD_EXP 70
85612: PPUSH
85613: LD_VAR 0 5
85617: PPUSH
85618: LD_EXP 70
85622: PUSH
85623: LD_VAR 0 5
85627: ARRAY
85628: PUSH
85629: LD_VAR 0 1
85633: DIFF
85634: PPUSH
85635: CALL_OW 1
85639: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
85640: LD_VAR 0 1
85644: PUSH
85645: LD_EXP 71
85649: PUSH
85650: LD_VAR 0 5
85654: ARRAY
85655: IN
85656: IFFALSE 85695
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
85658: LD_ADDR_EXP 71
85662: PUSH
85663: LD_EXP 71
85667: PPUSH
85668: LD_VAR 0 5
85672: PPUSH
85673: LD_EXP 71
85677: PUSH
85678: LD_VAR 0 5
85682: ARRAY
85683: PUSH
85684: LD_VAR 0 1
85688: DIFF
85689: PPUSH
85690: CALL_OW 1
85694: ST_TO_ADDR
// break ;
85695: GO 85699
// end ;
85697: GO 85517
85699: POP
85700: POP
// end ;
85701: LD_VAR 0 4
85705: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
85706: LD_INT 0
85708: PPUSH
85709: PPUSH
85710: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
85711: LD_EXP 62
85715: NOT
85716: PUSH
85717: LD_EXP 60
85721: NOT
85722: OR
85723: PUSH
85724: LD_VAR 0 3
85728: PUSH
85729: LD_EXP 88
85733: IN
85734: NOT
85735: OR
85736: IFFALSE 85740
// exit ;
85738: GO 85863
// for i = 1 to mc_vehicles do
85740: LD_ADDR_VAR 0 6
85744: PUSH
85745: DOUBLE
85746: LD_INT 1
85748: DEC
85749: ST_TO_ADDR
85750: LD_EXP 81
85754: PUSH
85755: FOR_TO
85756: IFFALSE 85861
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
85758: LD_VAR 0 2
85762: PUSH
85763: LD_EXP 81
85767: PUSH
85768: LD_VAR 0 6
85772: ARRAY
85773: IN
85774: PUSH
85775: LD_VAR 0 1
85779: PUSH
85780: LD_EXP 81
85784: PUSH
85785: LD_VAR 0 6
85789: ARRAY
85790: IN
85791: OR
85792: IFFALSE 85859
// begin tmp := mc_vehicles [ i ] diff old ;
85794: LD_ADDR_VAR 0 7
85798: PUSH
85799: LD_EXP 81
85803: PUSH
85804: LD_VAR 0 6
85808: ARRAY
85809: PUSH
85810: LD_VAR 0 2
85814: DIFF
85815: ST_TO_ADDR
// tmp := tmp diff new ;
85816: LD_ADDR_VAR 0 7
85820: PUSH
85821: LD_VAR 0 7
85825: PUSH
85826: LD_VAR 0 1
85830: DIFF
85831: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
85832: LD_ADDR_EXP 81
85836: PUSH
85837: LD_EXP 81
85841: PPUSH
85842: LD_VAR 0 6
85846: PPUSH
85847: LD_VAR 0 7
85851: PPUSH
85852: CALL_OW 1
85856: ST_TO_ADDR
// break ;
85857: GO 85861
// end ;
85859: GO 85755
85861: POP
85862: POP
// end ;
85863: LD_VAR 0 5
85867: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
85868: LD_INT 0
85870: PPUSH
85871: PPUSH
85872: PPUSH
85873: PPUSH
// if not mc_bases or not skirmish then
85874: LD_EXP 62
85878: NOT
85879: PUSH
85880: LD_EXP 60
85884: NOT
85885: OR
85886: IFFALSE 85890
// exit ;
85888: GO 86310
// repeat wait ( 0 0$1 ) ;
85890: LD_INT 35
85892: PPUSH
85893: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
85897: LD_EXP 106
85901: NOT
85902: IFFALSE 85890
// mc_block_vehicle_constructed_thread := true ;
85904: LD_ADDR_EXP 106
85908: PUSH
85909: LD_INT 1
85911: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
85912: LD_ADDR_VAR 0 5
85916: PUSH
85917: LD_VAR 0 1
85921: PPUSH
85922: CALL_OW 255
85926: ST_TO_ADDR
// for i = 1 to mc_bases do
85927: LD_ADDR_VAR 0 4
85931: PUSH
85932: DOUBLE
85933: LD_INT 1
85935: DEC
85936: ST_TO_ADDR
85937: LD_EXP 62
85941: PUSH
85942: FOR_TO
85943: IFFALSE 86300
// begin if factory in mc_bases [ i ] then
85945: LD_VAR 0 2
85949: PUSH
85950: LD_EXP 62
85954: PUSH
85955: LD_VAR 0 4
85959: ARRAY
85960: IN
85961: IFFALSE 86298
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
85963: LD_EXP 84
85967: PUSH
85968: LD_VAR 0 4
85972: ARRAY
85973: PUSH
85974: LD_EXP 73
85978: PUSH
85979: LD_VAR 0 4
85983: ARRAY
85984: LESS
85985: PUSH
85986: LD_VAR 0 1
85990: PPUSH
85991: CALL_OW 264
85995: PUSH
85996: LD_INT 31
85998: PUSH
85999: LD_INT 32
86001: PUSH
86002: LD_INT 51
86004: PUSH
86005: LD_INT 89
86007: PUSH
86008: LD_INT 12
86010: PUSH
86011: LD_INT 30
86013: PUSH
86014: LD_INT 98
86016: PUSH
86017: LD_INT 11
86019: PUSH
86020: LD_INT 53
86022: PUSH
86023: LD_INT 14
86025: PUSH
86026: LD_INT 91
86028: PUSH
86029: LD_INT 29
86031: PUSH
86032: LD_INT 99
86034: PUSH
86035: LD_INT 13
86037: PUSH
86038: LD_INT 52
86040: PUSH
86041: LD_INT 88
86043: PUSH
86044: LD_INT 48
86046: PUSH
86047: LD_INT 8
86049: PUSH
86050: EMPTY
86051: LIST
86052: LIST
86053: LIST
86054: LIST
86055: LIST
86056: LIST
86057: LIST
86058: LIST
86059: LIST
86060: LIST
86061: LIST
86062: LIST
86063: LIST
86064: LIST
86065: LIST
86066: LIST
86067: LIST
86068: LIST
86069: IN
86070: NOT
86071: AND
86072: IFFALSE 86120
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
86074: LD_ADDR_EXP 84
86078: PUSH
86079: LD_EXP 84
86083: PPUSH
86084: LD_VAR 0 4
86088: PUSH
86089: LD_EXP 84
86093: PUSH
86094: LD_VAR 0 4
86098: ARRAY
86099: PUSH
86100: LD_INT 1
86102: PLUS
86103: PUSH
86104: EMPTY
86105: LIST
86106: LIST
86107: PPUSH
86108: LD_VAR 0 1
86112: PPUSH
86113: CALL 21462 0 3
86117: ST_TO_ADDR
86118: GO 86164
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
86120: LD_ADDR_EXP 81
86124: PUSH
86125: LD_EXP 81
86129: PPUSH
86130: LD_VAR 0 4
86134: PUSH
86135: LD_EXP 81
86139: PUSH
86140: LD_VAR 0 4
86144: ARRAY
86145: PUSH
86146: LD_INT 1
86148: PLUS
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: PPUSH
86154: LD_VAR 0 1
86158: PPUSH
86159: CALL 21462 0 3
86163: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
86164: LD_ADDR_EXP 106
86168: PUSH
86169: LD_INT 0
86171: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
86172: LD_VAR 0 1
86176: PPUSH
86177: CALL_OW 263
86181: PUSH
86182: LD_INT 2
86184: EQUAL
86185: IFFALSE 86214
// begin repeat wait ( 0 0$3 ) ;
86187: LD_INT 105
86189: PPUSH
86190: CALL_OW 67
// Connect ( vehicle ) ;
86194: LD_VAR 0 1
86198: PPUSH
86199: CALL 24808 0 1
// until IsControledBy ( vehicle ) ;
86203: LD_VAR 0 1
86207: PPUSH
86208: CALL_OW 312
86212: IFFALSE 86187
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
86214: LD_VAR 0 1
86218: PPUSH
86219: LD_EXP 86
86223: PUSH
86224: LD_VAR 0 4
86228: ARRAY
86229: PPUSH
86230: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
86234: LD_VAR 0 1
86238: PPUSH
86239: CALL_OW 263
86243: PUSH
86244: LD_INT 1
86246: NONEQUAL
86247: IFFALSE 86251
// break ;
86249: GO 86300
// repeat wait ( 0 0$1 ) ;
86251: LD_INT 35
86253: PPUSH
86254: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
86258: LD_VAR 0 1
86262: PPUSH
86263: LD_EXP 86
86267: PUSH
86268: LD_VAR 0 4
86272: ARRAY
86273: PPUSH
86274: CALL_OW 308
86278: IFFALSE 86251
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
86280: LD_VAR 0 1
86284: PPUSH
86285: CALL_OW 311
86289: PPUSH
86290: CALL_OW 121
// exit ;
86294: POP
86295: POP
86296: GO 86310
// end ; end ;
86298: GO 85942
86300: POP
86301: POP
// mc_block_vehicle_constructed_thread := false ;
86302: LD_ADDR_EXP 106
86306: PUSH
86307: LD_INT 0
86309: ST_TO_ADDR
// end ;
86310: LD_VAR 0 3
86314: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
86315: LD_INT 0
86317: PPUSH
86318: PPUSH
86319: PPUSH
86320: PPUSH
// if not mc_bases or not skirmish then
86321: LD_EXP 62
86325: NOT
86326: PUSH
86327: LD_EXP 60
86331: NOT
86332: OR
86333: IFFALSE 86337
// exit ;
86335: GO 86690
// repeat wait ( 0 0$1 ) ;
86337: LD_INT 35
86339: PPUSH
86340: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
86344: LD_VAR 0 2
86348: PPUSH
86349: LD_VAR 0 3
86353: PPUSH
86354: CALL_OW 284
86358: IFFALSE 86337
// if GetResourceTypeXY ( x , y ) = mat_artefact then
86360: LD_VAR 0 2
86364: PPUSH
86365: LD_VAR 0 3
86369: PPUSH
86370: CALL_OW 283
86374: PUSH
86375: LD_INT 4
86377: EQUAL
86378: IFFALSE 86382
// exit ;
86380: GO 86690
// for i = 1 to mc_bases do
86382: LD_ADDR_VAR 0 7
86386: PUSH
86387: DOUBLE
86388: LD_INT 1
86390: DEC
86391: ST_TO_ADDR
86392: LD_EXP 62
86396: PUSH
86397: FOR_TO
86398: IFFALSE 86688
// begin if mc_crates_area [ i ] then
86400: LD_EXP 80
86404: PUSH
86405: LD_VAR 0 7
86409: ARRAY
86410: IFFALSE 86521
// for j in mc_crates_area [ i ] do
86412: LD_ADDR_VAR 0 8
86416: PUSH
86417: LD_EXP 80
86421: PUSH
86422: LD_VAR 0 7
86426: ARRAY
86427: PUSH
86428: FOR_IN
86429: IFFALSE 86519
// if InArea ( x , y , j ) then
86431: LD_VAR 0 2
86435: PPUSH
86436: LD_VAR 0 3
86440: PPUSH
86441: LD_VAR 0 8
86445: PPUSH
86446: CALL_OW 309
86450: IFFALSE 86517
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
86452: LD_ADDR_EXP 78
86456: PUSH
86457: LD_EXP 78
86461: PPUSH
86462: LD_VAR 0 7
86466: PUSH
86467: LD_EXP 78
86471: PUSH
86472: LD_VAR 0 7
86476: ARRAY
86477: PUSH
86478: LD_INT 1
86480: PLUS
86481: PUSH
86482: EMPTY
86483: LIST
86484: LIST
86485: PPUSH
86486: LD_VAR 0 4
86490: PUSH
86491: LD_VAR 0 2
86495: PUSH
86496: LD_VAR 0 3
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: LIST
86505: PPUSH
86506: CALL 21462 0 3
86510: ST_TO_ADDR
// exit ;
86511: POP
86512: POP
86513: POP
86514: POP
86515: GO 86690
// end ;
86517: GO 86428
86519: POP
86520: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86521: LD_ADDR_VAR 0 9
86525: PUSH
86526: LD_EXP 62
86530: PUSH
86531: LD_VAR 0 7
86535: ARRAY
86536: PPUSH
86537: LD_INT 2
86539: PUSH
86540: LD_INT 30
86542: PUSH
86543: LD_INT 0
86545: PUSH
86546: EMPTY
86547: LIST
86548: LIST
86549: PUSH
86550: LD_INT 30
86552: PUSH
86553: LD_INT 1
86555: PUSH
86556: EMPTY
86557: LIST
86558: LIST
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: LIST
86564: PPUSH
86565: CALL_OW 72
86569: ST_TO_ADDR
// if not depot then
86570: LD_VAR 0 9
86574: NOT
86575: IFFALSE 86579
// continue ;
86577: GO 86397
// for j in depot do
86579: LD_ADDR_VAR 0 8
86583: PUSH
86584: LD_VAR 0 9
86588: PUSH
86589: FOR_IN
86590: IFFALSE 86684
// if GetDistUnitXY ( j , x , y ) < 30 then
86592: LD_VAR 0 8
86596: PPUSH
86597: LD_VAR 0 2
86601: PPUSH
86602: LD_VAR 0 3
86606: PPUSH
86607: CALL_OW 297
86611: PUSH
86612: LD_INT 30
86614: LESS
86615: IFFALSE 86682
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
86617: LD_ADDR_EXP 78
86621: PUSH
86622: LD_EXP 78
86626: PPUSH
86627: LD_VAR 0 7
86631: PUSH
86632: LD_EXP 78
86636: PUSH
86637: LD_VAR 0 7
86641: ARRAY
86642: PUSH
86643: LD_INT 1
86645: PLUS
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PPUSH
86651: LD_VAR 0 4
86655: PUSH
86656: LD_VAR 0 2
86660: PUSH
86661: LD_VAR 0 3
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: LIST
86670: PPUSH
86671: CALL 21462 0 3
86675: ST_TO_ADDR
// exit ;
86676: POP
86677: POP
86678: POP
86679: POP
86680: GO 86690
// end ;
86682: GO 86589
86684: POP
86685: POP
// end ;
86686: GO 86397
86688: POP
86689: POP
// end ;
86690: LD_VAR 0 6
86694: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
86695: LD_INT 0
86697: PPUSH
86698: PPUSH
86699: PPUSH
86700: PPUSH
// if not mc_bases or not skirmish then
86701: LD_EXP 62
86705: NOT
86706: PUSH
86707: LD_EXP 60
86711: NOT
86712: OR
86713: IFFALSE 86717
// exit ;
86715: GO 86994
// side := GetSide ( lab ) ;
86717: LD_ADDR_VAR 0 4
86721: PUSH
86722: LD_VAR 0 2
86726: PPUSH
86727: CALL_OW 255
86731: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
86732: LD_VAR 0 4
86736: PUSH
86737: LD_EXP 88
86741: IN
86742: NOT
86743: PUSH
86744: LD_EXP 89
86748: NOT
86749: OR
86750: PUSH
86751: LD_EXP 62
86755: NOT
86756: OR
86757: IFFALSE 86761
// exit ;
86759: GO 86994
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
86761: LD_ADDR_EXP 89
86765: PUSH
86766: LD_EXP 89
86770: PPUSH
86771: LD_VAR 0 4
86775: PPUSH
86776: LD_EXP 89
86780: PUSH
86781: LD_VAR 0 4
86785: ARRAY
86786: PUSH
86787: LD_VAR 0 1
86791: DIFF
86792: PPUSH
86793: CALL_OW 1
86797: ST_TO_ADDR
// for i = 1 to mc_bases do
86798: LD_ADDR_VAR 0 5
86802: PUSH
86803: DOUBLE
86804: LD_INT 1
86806: DEC
86807: ST_TO_ADDR
86808: LD_EXP 62
86812: PUSH
86813: FOR_TO
86814: IFFALSE 86992
// begin if lab in mc_bases [ i ] then
86816: LD_VAR 0 2
86820: PUSH
86821: LD_EXP 62
86825: PUSH
86826: LD_VAR 0 5
86830: ARRAY
86831: IN
86832: IFFALSE 86990
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
86834: LD_VAR 0 1
86838: PUSH
86839: LD_INT 11
86841: PUSH
86842: LD_INT 4
86844: PUSH
86845: LD_INT 3
86847: PUSH
86848: LD_INT 2
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: IN
86857: PUSH
86858: LD_EXP 92
86862: PUSH
86863: LD_VAR 0 5
86867: ARRAY
86868: AND
86869: IFFALSE 86990
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
86871: LD_ADDR_VAR 0 6
86875: PUSH
86876: LD_EXP 92
86880: PUSH
86881: LD_VAR 0 5
86885: ARRAY
86886: PUSH
86887: LD_INT 1
86889: ARRAY
86890: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
86891: LD_ADDR_EXP 92
86895: PUSH
86896: LD_EXP 92
86900: PPUSH
86901: LD_VAR 0 5
86905: PPUSH
86906: EMPTY
86907: PPUSH
86908: CALL_OW 1
86912: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
86913: LD_VAR 0 6
86917: PPUSH
86918: LD_INT 0
86920: PPUSH
86921: CALL_OW 109
// ComExitBuilding ( tmp ) ;
86925: LD_VAR 0 6
86929: PPUSH
86930: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
86934: LD_ADDR_EXP 91
86938: PUSH
86939: LD_EXP 91
86943: PPUSH
86944: LD_VAR 0 5
86948: PPUSH
86949: LD_EXP 91
86953: PUSH
86954: LD_VAR 0 5
86958: ARRAY
86959: PPUSH
86960: LD_INT 1
86962: PPUSH
86963: LD_VAR 0 6
86967: PPUSH
86968: CALL_OW 2
86972: PPUSH
86973: CALL_OW 1
86977: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
86978: LD_VAR 0 5
86982: PPUSH
86983: LD_INT 112
86985: PPUSH
86986: CALL 63444 0 2
// end ; end ; end ;
86990: GO 86813
86992: POP
86993: POP
// end ;
86994: LD_VAR 0 3
86998: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
86999: LD_INT 0
87001: PPUSH
87002: PPUSH
87003: PPUSH
87004: PPUSH
87005: PPUSH
87006: PPUSH
87007: PPUSH
87008: PPUSH
// if not mc_bases or not skirmish then
87009: LD_EXP 62
87013: NOT
87014: PUSH
87015: LD_EXP 60
87019: NOT
87020: OR
87021: IFFALSE 87025
// exit ;
87023: GO 88394
// for i = 1 to mc_bases do
87025: LD_ADDR_VAR 0 3
87029: PUSH
87030: DOUBLE
87031: LD_INT 1
87033: DEC
87034: ST_TO_ADDR
87035: LD_EXP 62
87039: PUSH
87040: FOR_TO
87041: IFFALSE 88392
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
87043: LD_VAR 0 1
87047: PUSH
87048: LD_EXP 62
87052: PUSH
87053: LD_VAR 0 3
87057: ARRAY
87058: IN
87059: PUSH
87060: LD_VAR 0 1
87064: PUSH
87065: LD_EXP 69
87069: PUSH
87070: LD_VAR 0 3
87074: ARRAY
87075: IN
87076: OR
87077: PUSH
87078: LD_VAR 0 1
87082: PUSH
87083: LD_EXP 84
87087: PUSH
87088: LD_VAR 0 3
87092: ARRAY
87093: IN
87094: OR
87095: PUSH
87096: LD_VAR 0 1
87100: PUSH
87101: LD_EXP 81
87105: PUSH
87106: LD_VAR 0 3
87110: ARRAY
87111: IN
87112: OR
87113: PUSH
87114: LD_VAR 0 1
87118: PUSH
87119: LD_EXP 91
87123: PUSH
87124: LD_VAR 0 3
87128: ARRAY
87129: IN
87130: OR
87131: PUSH
87132: LD_VAR 0 1
87136: PUSH
87137: LD_EXP 92
87141: PUSH
87142: LD_VAR 0 3
87146: ARRAY
87147: IN
87148: OR
87149: IFFALSE 88390
// begin if un in mc_ape [ i ] then
87151: LD_VAR 0 1
87155: PUSH
87156: LD_EXP 91
87160: PUSH
87161: LD_VAR 0 3
87165: ARRAY
87166: IN
87167: IFFALSE 87206
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
87169: LD_ADDR_EXP 91
87173: PUSH
87174: LD_EXP 91
87178: PPUSH
87179: LD_VAR 0 3
87183: PPUSH
87184: LD_EXP 91
87188: PUSH
87189: LD_VAR 0 3
87193: ARRAY
87194: PUSH
87195: LD_VAR 0 1
87199: DIFF
87200: PPUSH
87201: CALL_OW 1
87205: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
87206: LD_VAR 0 1
87210: PUSH
87211: LD_EXP 92
87215: PUSH
87216: LD_VAR 0 3
87220: ARRAY
87221: IN
87222: IFFALSE 87246
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
87224: LD_ADDR_EXP 92
87228: PUSH
87229: LD_EXP 92
87233: PPUSH
87234: LD_VAR 0 3
87238: PPUSH
87239: EMPTY
87240: PPUSH
87241: CALL_OW 1
87245: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
87246: LD_VAR 0 1
87250: PPUSH
87251: CALL_OW 247
87255: PUSH
87256: LD_INT 2
87258: EQUAL
87259: PUSH
87260: LD_VAR 0 1
87264: PPUSH
87265: CALL_OW 110
87269: PUSH
87270: LD_INT 20
87272: EQUAL
87273: PUSH
87274: LD_VAR 0 1
87278: PUSH
87279: LD_EXP 84
87283: PUSH
87284: LD_VAR 0 3
87288: ARRAY
87289: IN
87290: OR
87291: PUSH
87292: LD_VAR 0 1
87296: PPUSH
87297: CALL_OW 264
87301: PUSH
87302: LD_INT 12
87304: PUSH
87305: LD_INT 51
87307: PUSH
87308: LD_INT 89
87310: PUSH
87311: LD_INT 32
87313: PUSH
87314: LD_INT 13
87316: PUSH
87317: LD_INT 52
87319: PUSH
87320: LD_INT 31
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: LIST
87327: LIST
87328: LIST
87329: LIST
87330: LIST
87331: IN
87332: OR
87333: AND
87334: IFFALSE 87642
// begin if un in mc_defender [ i ] then
87336: LD_VAR 0 1
87340: PUSH
87341: LD_EXP 84
87345: PUSH
87346: LD_VAR 0 3
87350: ARRAY
87351: IN
87352: IFFALSE 87391
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
87354: LD_ADDR_EXP 84
87358: PUSH
87359: LD_EXP 84
87363: PPUSH
87364: LD_VAR 0 3
87368: PPUSH
87369: LD_EXP 84
87373: PUSH
87374: LD_VAR 0 3
87378: ARRAY
87379: PUSH
87380: LD_VAR 0 1
87384: DIFF
87385: PPUSH
87386: CALL_OW 1
87390: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
87391: LD_ADDR_VAR 0 8
87395: PUSH
87396: LD_VAR 0 3
87400: PPUSH
87401: LD_INT 3
87403: PPUSH
87404: CALL 84012 0 2
87408: ST_TO_ADDR
// if fac then
87409: LD_VAR 0 8
87413: IFFALSE 87642
// begin for j in fac do
87415: LD_ADDR_VAR 0 4
87419: PUSH
87420: LD_VAR 0 8
87424: PUSH
87425: FOR_IN
87426: IFFALSE 87640
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
87428: LD_ADDR_VAR 0 9
87432: PUSH
87433: LD_VAR 0 8
87437: PPUSH
87438: LD_VAR 0 1
87442: PPUSH
87443: CALL_OW 265
87447: PPUSH
87448: LD_VAR 0 1
87452: PPUSH
87453: CALL_OW 262
87457: PPUSH
87458: LD_VAR 0 1
87462: PPUSH
87463: CALL_OW 263
87467: PPUSH
87468: LD_VAR 0 1
87472: PPUSH
87473: CALL_OW 264
87477: PPUSH
87478: CALL 18960 0 5
87482: ST_TO_ADDR
// if components then
87483: LD_VAR 0 9
87487: IFFALSE 87638
// begin if GetWeapon ( un ) = ar_control_tower then
87489: LD_VAR 0 1
87493: PPUSH
87494: CALL_OW 264
87498: PUSH
87499: LD_INT 31
87501: EQUAL
87502: IFFALSE 87619
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
87504: LD_VAR 0 1
87508: PPUSH
87509: CALL_OW 311
87513: PPUSH
87514: LD_INT 0
87516: PPUSH
87517: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
87521: LD_ADDR_EXP 102
87525: PUSH
87526: LD_EXP 102
87530: PPUSH
87531: LD_VAR 0 3
87535: PPUSH
87536: LD_EXP 102
87540: PUSH
87541: LD_VAR 0 3
87545: ARRAY
87546: PUSH
87547: LD_VAR 0 1
87551: PPUSH
87552: CALL_OW 311
87556: DIFF
87557: PPUSH
87558: CALL_OW 1
87562: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
87563: LD_ADDR_VAR 0 7
87567: PUSH
87568: LD_EXP 83
87572: PUSH
87573: LD_VAR 0 3
87577: ARRAY
87578: PPUSH
87579: LD_INT 1
87581: PPUSH
87582: LD_VAR 0 9
87586: PPUSH
87587: CALL_OW 2
87591: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
87592: LD_ADDR_EXP 83
87596: PUSH
87597: LD_EXP 83
87601: PPUSH
87602: LD_VAR 0 3
87606: PPUSH
87607: LD_VAR 0 7
87611: PPUSH
87612: CALL_OW 1
87616: ST_TO_ADDR
// end else
87617: GO 87636
// MC_InsertProduceList ( i , [ components ] ) ;
87619: LD_VAR 0 3
87623: PPUSH
87624: LD_VAR 0 9
87628: PUSH
87629: EMPTY
87630: LIST
87631: PPUSH
87632: CALL 83557 0 2
// break ;
87636: GO 87640
// end ; end ;
87638: GO 87425
87640: POP
87641: POP
// end ; end ; if GetType ( un ) = unit_building then
87642: LD_VAR 0 1
87646: PPUSH
87647: CALL_OW 247
87651: PUSH
87652: LD_INT 3
87654: EQUAL
87655: IFFALSE 88058
// begin btype := GetBType ( un ) ;
87657: LD_ADDR_VAR 0 5
87661: PUSH
87662: LD_VAR 0 1
87666: PPUSH
87667: CALL_OW 266
87671: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
87672: LD_VAR 0 5
87676: PUSH
87677: LD_INT 29
87679: PUSH
87680: LD_INT 30
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: IN
87687: IFFALSE 87760
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
87689: LD_VAR 0 1
87693: PPUSH
87694: CALL_OW 250
87698: PPUSH
87699: LD_VAR 0 1
87703: PPUSH
87704: CALL_OW 251
87708: PPUSH
87709: LD_VAR 0 1
87713: PPUSH
87714: CALL_OW 255
87718: PPUSH
87719: CALL_OW 440
87723: NOT
87724: IFFALSE 87760
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
87726: LD_VAR 0 1
87730: PPUSH
87731: CALL_OW 250
87735: PPUSH
87736: LD_VAR 0 1
87740: PPUSH
87741: CALL_OW 251
87745: PPUSH
87746: LD_VAR 0 1
87750: PPUSH
87751: CALL_OW 255
87755: PPUSH
87756: CALL_OW 441
// end ; if btype = b_warehouse then
87760: LD_VAR 0 5
87764: PUSH
87765: LD_INT 1
87767: EQUAL
87768: IFFALSE 87786
// begin btype := b_depot ;
87770: LD_ADDR_VAR 0 5
87774: PUSH
87775: LD_INT 0
87777: ST_TO_ADDR
// pos := 1 ;
87778: LD_ADDR_VAR 0 6
87782: PUSH
87783: LD_INT 1
87785: ST_TO_ADDR
// end ; if btype = b_factory then
87786: LD_VAR 0 5
87790: PUSH
87791: LD_INT 3
87793: EQUAL
87794: IFFALSE 87812
// begin btype := b_workshop ;
87796: LD_ADDR_VAR 0 5
87800: PUSH
87801: LD_INT 2
87803: ST_TO_ADDR
// pos := 1 ;
87804: LD_ADDR_VAR 0 6
87808: PUSH
87809: LD_INT 1
87811: ST_TO_ADDR
// end ; if btype = b_barracks then
87812: LD_VAR 0 5
87816: PUSH
87817: LD_INT 5
87819: EQUAL
87820: IFFALSE 87830
// btype := b_armoury ;
87822: LD_ADDR_VAR 0 5
87826: PUSH
87827: LD_INT 4
87829: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
87830: LD_VAR 0 5
87834: PUSH
87835: LD_INT 7
87837: PUSH
87838: LD_INT 8
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: IN
87845: IFFALSE 87855
// btype := b_lab ;
87847: LD_ADDR_VAR 0 5
87851: PUSH
87852: LD_INT 6
87854: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
87855: LD_ADDR_EXP 67
87859: PUSH
87860: LD_EXP 67
87864: PPUSH
87865: LD_VAR 0 3
87869: PUSH
87870: LD_EXP 67
87874: PUSH
87875: LD_VAR 0 3
87879: ARRAY
87880: PUSH
87881: LD_INT 1
87883: PLUS
87884: PUSH
87885: EMPTY
87886: LIST
87887: LIST
87888: PPUSH
87889: LD_VAR 0 5
87893: PUSH
87894: LD_VAR 0 1
87898: PPUSH
87899: CALL_OW 250
87903: PUSH
87904: LD_VAR 0 1
87908: PPUSH
87909: CALL_OW 251
87913: PUSH
87914: LD_VAR 0 1
87918: PPUSH
87919: CALL_OW 254
87923: PUSH
87924: EMPTY
87925: LIST
87926: LIST
87927: LIST
87928: LIST
87929: PPUSH
87930: CALL 21462 0 3
87934: ST_TO_ADDR
// if pos = 1 then
87935: LD_VAR 0 6
87939: PUSH
87940: LD_INT 1
87942: EQUAL
87943: IFFALSE 88058
// begin tmp := mc_build_list [ i ] ;
87945: LD_ADDR_VAR 0 7
87949: PUSH
87950: LD_EXP 67
87954: PUSH
87955: LD_VAR 0 3
87959: ARRAY
87960: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
87961: LD_VAR 0 7
87965: PPUSH
87966: LD_INT 2
87968: PUSH
87969: LD_INT 30
87971: PUSH
87972: LD_INT 0
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: PUSH
87979: LD_INT 30
87981: PUSH
87982: LD_INT 1
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: EMPTY
87990: LIST
87991: LIST
87992: LIST
87993: PPUSH
87994: CALL_OW 72
87998: IFFALSE 88008
// pos := 2 ;
88000: LD_ADDR_VAR 0 6
88004: PUSH
88005: LD_INT 2
88007: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
88008: LD_ADDR_VAR 0 7
88012: PUSH
88013: LD_VAR 0 7
88017: PPUSH
88018: LD_VAR 0 6
88022: PPUSH
88023: LD_VAR 0 7
88027: PPUSH
88028: CALL 21788 0 3
88032: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
88033: LD_ADDR_EXP 67
88037: PUSH
88038: LD_EXP 67
88042: PPUSH
88043: LD_VAR 0 3
88047: PPUSH
88048: LD_VAR 0 7
88052: PPUSH
88053: CALL_OW 1
88057: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
88058: LD_VAR 0 1
88062: PUSH
88063: LD_EXP 62
88067: PUSH
88068: LD_VAR 0 3
88072: ARRAY
88073: IN
88074: IFFALSE 88113
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
88076: LD_ADDR_EXP 62
88080: PUSH
88081: LD_EXP 62
88085: PPUSH
88086: LD_VAR 0 3
88090: PPUSH
88091: LD_EXP 62
88095: PUSH
88096: LD_VAR 0 3
88100: ARRAY
88101: PUSH
88102: LD_VAR 0 1
88106: DIFF
88107: PPUSH
88108: CALL_OW 1
88112: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
88113: LD_VAR 0 1
88117: PUSH
88118: LD_EXP 69
88122: PUSH
88123: LD_VAR 0 3
88127: ARRAY
88128: IN
88129: IFFALSE 88168
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
88131: LD_ADDR_EXP 69
88135: PUSH
88136: LD_EXP 69
88140: PPUSH
88141: LD_VAR 0 3
88145: PPUSH
88146: LD_EXP 69
88150: PUSH
88151: LD_VAR 0 3
88155: ARRAY
88156: PUSH
88157: LD_VAR 0 1
88161: DIFF
88162: PPUSH
88163: CALL_OW 1
88167: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
88168: LD_VAR 0 1
88172: PUSH
88173: LD_EXP 81
88177: PUSH
88178: LD_VAR 0 3
88182: ARRAY
88183: IN
88184: IFFALSE 88223
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
88186: LD_ADDR_EXP 81
88190: PUSH
88191: LD_EXP 81
88195: PPUSH
88196: LD_VAR 0 3
88200: PPUSH
88201: LD_EXP 81
88205: PUSH
88206: LD_VAR 0 3
88210: ARRAY
88211: PUSH
88212: LD_VAR 0 1
88216: DIFF
88217: PPUSH
88218: CALL_OW 1
88222: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
88223: LD_VAR 0 1
88227: PUSH
88228: LD_EXP 84
88232: PUSH
88233: LD_VAR 0 3
88237: ARRAY
88238: IN
88239: IFFALSE 88278
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
88241: LD_ADDR_EXP 84
88245: PUSH
88246: LD_EXP 84
88250: PPUSH
88251: LD_VAR 0 3
88255: PPUSH
88256: LD_EXP 84
88260: PUSH
88261: LD_VAR 0 3
88265: ARRAY
88266: PUSH
88267: LD_VAR 0 1
88271: DIFF
88272: PPUSH
88273: CALL_OW 1
88277: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
88278: LD_VAR 0 1
88282: PUSH
88283: LD_EXP 71
88287: PUSH
88288: LD_VAR 0 3
88292: ARRAY
88293: IN
88294: IFFALSE 88333
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
88296: LD_ADDR_EXP 71
88300: PUSH
88301: LD_EXP 71
88305: PPUSH
88306: LD_VAR 0 3
88310: PPUSH
88311: LD_EXP 71
88315: PUSH
88316: LD_VAR 0 3
88320: ARRAY
88321: PUSH
88322: LD_VAR 0 1
88326: DIFF
88327: PPUSH
88328: CALL_OW 1
88332: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
88333: LD_VAR 0 1
88337: PUSH
88338: LD_EXP 70
88342: PUSH
88343: LD_VAR 0 3
88347: ARRAY
88348: IN
88349: IFFALSE 88388
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
88351: LD_ADDR_EXP 70
88355: PUSH
88356: LD_EXP 70
88360: PPUSH
88361: LD_VAR 0 3
88365: PPUSH
88366: LD_EXP 70
88370: PUSH
88371: LD_VAR 0 3
88375: ARRAY
88376: PUSH
88377: LD_VAR 0 1
88381: DIFF
88382: PPUSH
88383: CALL_OW 1
88387: ST_TO_ADDR
// end ; break ;
88388: GO 88392
// end ;
88390: GO 87040
88392: POP
88393: POP
// end ;
88394: LD_VAR 0 2
88398: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
88399: LD_INT 0
88401: PPUSH
88402: PPUSH
88403: PPUSH
// if not mc_bases or not skirmish then
88404: LD_EXP 62
88408: NOT
88409: PUSH
88410: LD_EXP 60
88414: NOT
88415: OR
88416: IFFALSE 88420
// exit ;
88418: GO 88635
// for i = 1 to mc_bases do
88420: LD_ADDR_VAR 0 3
88424: PUSH
88425: DOUBLE
88426: LD_INT 1
88428: DEC
88429: ST_TO_ADDR
88430: LD_EXP 62
88434: PUSH
88435: FOR_TO
88436: IFFALSE 88633
// begin if building in mc_construct_list [ i ] then
88438: LD_VAR 0 1
88442: PUSH
88443: LD_EXP 69
88447: PUSH
88448: LD_VAR 0 3
88452: ARRAY
88453: IN
88454: IFFALSE 88631
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
88456: LD_ADDR_EXP 69
88460: PUSH
88461: LD_EXP 69
88465: PPUSH
88466: LD_VAR 0 3
88470: PPUSH
88471: LD_EXP 69
88475: PUSH
88476: LD_VAR 0 3
88480: ARRAY
88481: PUSH
88482: LD_VAR 0 1
88486: DIFF
88487: PPUSH
88488: CALL_OW 1
88492: ST_TO_ADDR
// if building in mc_lab [ i ] then
88493: LD_VAR 0 1
88497: PUSH
88498: LD_EXP 95
88502: PUSH
88503: LD_VAR 0 3
88507: ARRAY
88508: IN
88509: IFFALSE 88564
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
88511: LD_ADDR_EXP 96
88515: PUSH
88516: LD_EXP 96
88520: PPUSH
88521: LD_VAR 0 3
88525: PPUSH
88526: LD_EXP 96
88530: PUSH
88531: LD_VAR 0 3
88535: ARRAY
88536: PPUSH
88537: LD_INT 1
88539: PPUSH
88540: LD_EXP 96
88544: PUSH
88545: LD_VAR 0 3
88549: ARRAY
88550: PPUSH
88551: LD_INT 0
88553: PPUSH
88554: CALL 20880 0 4
88558: PPUSH
88559: CALL_OW 1
88563: ST_TO_ADDR
// if not building in mc_bases [ i ] then
88564: LD_VAR 0 1
88568: PUSH
88569: LD_EXP 62
88573: PUSH
88574: LD_VAR 0 3
88578: ARRAY
88579: IN
88580: NOT
88581: IFFALSE 88627
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
88583: LD_ADDR_EXP 62
88587: PUSH
88588: LD_EXP 62
88592: PPUSH
88593: LD_VAR 0 3
88597: PUSH
88598: LD_EXP 62
88602: PUSH
88603: LD_VAR 0 3
88607: ARRAY
88608: PUSH
88609: LD_INT 1
88611: PLUS
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PPUSH
88617: LD_VAR 0 1
88621: PPUSH
88622: CALL 21462 0 3
88626: ST_TO_ADDR
// exit ;
88627: POP
88628: POP
88629: GO 88635
// end ; end ;
88631: GO 88435
88633: POP
88634: POP
// end ;
88635: LD_VAR 0 2
88639: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
88640: LD_INT 0
88642: PPUSH
88643: PPUSH
88644: PPUSH
88645: PPUSH
88646: PPUSH
88647: PPUSH
88648: PPUSH
// if not mc_bases or not skirmish then
88649: LD_EXP 62
88653: NOT
88654: PUSH
88655: LD_EXP 60
88659: NOT
88660: OR
88661: IFFALSE 88665
// exit ;
88663: GO 89326
// for i = 1 to mc_bases do
88665: LD_ADDR_VAR 0 3
88669: PUSH
88670: DOUBLE
88671: LD_INT 1
88673: DEC
88674: ST_TO_ADDR
88675: LD_EXP 62
88679: PUSH
88680: FOR_TO
88681: IFFALSE 89324
// begin if building in mc_construct_list [ i ] then
88683: LD_VAR 0 1
88687: PUSH
88688: LD_EXP 69
88692: PUSH
88693: LD_VAR 0 3
88697: ARRAY
88698: IN
88699: IFFALSE 89322
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
88701: LD_ADDR_EXP 69
88705: PUSH
88706: LD_EXP 69
88710: PPUSH
88711: LD_VAR 0 3
88715: PPUSH
88716: LD_EXP 69
88720: PUSH
88721: LD_VAR 0 3
88725: ARRAY
88726: PUSH
88727: LD_VAR 0 1
88731: DIFF
88732: PPUSH
88733: CALL_OW 1
88737: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
88738: LD_ADDR_EXP 62
88742: PUSH
88743: LD_EXP 62
88747: PPUSH
88748: LD_VAR 0 3
88752: PUSH
88753: LD_EXP 62
88757: PUSH
88758: LD_VAR 0 3
88762: ARRAY
88763: PUSH
88764: LD_INT 1
88766: PLUS
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PPUSH
88772: LD_VAR 0 1
88776: PPUSH
88777: CALL 21462 0 3
88781: ST_TO_ADDR
// btype := GetBType ( building ) ;
88782: LD_ADDR_VAR 0 5
88786: PUSH
88787: LD_VAR 0 1
88791: PPUSH
88792: CALL_OW 266
88796: ST_TO_ADDR
// side := GetSide ( building ) ;
88797: LD_ADDR_VAR 0 8
88801: PUSH
88802: LD_VAR 0 1
88806: PPUSH
88807: CALL_OW 255
88811: ST_TO_ADDR
// if btype = b_lab then
88812: LD_VAR 0 5
88816: PUSH
88817: LD_INT 6
88819: EQUAL
88820: IFFALSE 88870
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
88822: LD_ADDR_EXP 95
88826: PUSH
88827: LD_EXP 95
88831: PPUSH
88832: LD_VAR 0 3
88836: PUSH
88837: LD_EXP 95
88841: PUSH
88842: LD_VAR 0 3
88846: ARRAY
88847: PUSH
88848: LD_INT 1
88850: PLUS
88851: PUSH
88852: EMPTY
88853: LIST
88854: LIST
88855: PPUSH
88856: LD_VAR 0 1
88860: PPUSH
88861: CALL 21462 0 3
88865: ST_TO_ADDR
// exit ;
88866: POP
88867: POP
88868: GO 89326
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
88870: LD_VAR 0 5
88874: PUSH
88875: LD_INT 0
88877: PUSH
88878: LD_INT 2
88880: PUSH
88881: LD_INT 4
88883: PUSH
88884: EMPTY
88885: LIST
88886: LIST
88887: LIST
88888: IN
88889: IFFALSE 89013
// begin if btype = b_armoury then
88891: LD_VAR 0 5
88895: PUSH
88896: LD_INT 4
88898: EQUAL
88899: IFFALSE 88909
// btype := b_barracks ;
88901: LD_ADDR_VAR 0 5
88905: PUSH
88906: LD_INT 5
88908: ST_TO_ADDR
// if btype = b_depot then
88909: LD_VAR 0 5
88913: PUSH
88914: LD_INT 0
88916: EQUAL
88917: IFFALSE 88927
// btype := b_warehouse ;
88919: LD_ADDR_VAR 0 5
88923: PUSH
88924: LD_INT 1
88926: ST_TO_ADDR
// if btype = b_workshop then
88927: LD_VAR 0 5
88931: PUSH
88932: LD_INT 2
88934: EQUAL
88935: IFFALSE 88945
// btype := b_factory ;
88937: LD_ADDR_VAR 0 5
88941: PUSH
88942: LD_INT 3
88944: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
88945: LD_VAR 0 5
88949: PPUSH
88950: LD_VAR 0 8
88954: PPUSH
88955: CALL_OW 323
88959: PUSH
88960: LD_INT 1
88962: EQUAL
88963: IFFALSE 89009
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
88965: LD_ADDR_EXP 94
88969: PUSH
88970: LD_EXP 94
88974: PPUSH
88975: LD_VAR 0 3
88979: PUSH
88980: LD_EXP 94
88984: PUSH
88985: LD_VAR 0 3
88989: ARRAY
88990: PUSH
88991: LD_INT 1
88993: PLUS
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PPUSH
88999: LD_VAR 0 1
89003: PPUSH
89004: CALL 21462 0 3
89008: ST_TO_ADDR
// exit ;
89009: POP
89010: POP
89011: GO 89326
// end ; if btype in [ b_bunker , b_turret ] then
89013: LD_VAR 0 5
89017: PUSH
89018: LD_INT 32
89020: PUSH
89021: LD_INT 33
89023: PUSH
89024: EMPTY
89025: LIST
89026: LIST
89027: IN
89028: IFFALSE 89318
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
89030: LD_ADDR_EXP 70
89034: PUSH
89035: LD_EXP 70
89039: PPUSH
89040: LD_VAR 0 3
89044: PUSH
89045: LD_EXP 70
89049: PUSH
89050: LD_VAR 0 3
89054: ARRAY
89055: PUSH
89056: LD_INT 1
89058: PLUS
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PPUSH
89064: LD_VAR 0 1
89068: PPUSH
89069: CALL 21462 0 3
89073: ST_TO_ADDR
// if btype = b_bunker then
89074: LD_VAR 0 5
89078: PUSH
89079: LD_INT 32
89081: EQUAL
89082: IFFALSE 89318
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
89084: LD_ADDR_EXP 71
89088: PUSH
89089: LD_EXP 71
89093: PPUSH
89094: LD_VAR 0 3
89098: PUSH
89099: LD_EXP 71
89103: PUSH
89104: LD_VAR 0 3
89108: ARRAY
89109: PUSH
89110: LD_INT 1
89112: PLUS
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: PPUSH
89118: LD_VAR 0 1
89122: PPUSH
89123: CALL 21462 0 3
89127: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
89128: LD_ADDR_VAR 0 6
89132: PUSH
89133: LD_EXP 62
89137: PUSH
89138: LD_VAR 0 3
89142: ARRAY
89143: PPUSH
89144: LD_INT 25
89146: PUSH
89147: LD_INT 1
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 3
89156: PUSH
89157: LD_INT 54
89159: PUSH
89160: EMPTY
89161: LIST
89162: PUSH
89163: EMPTY
89164: LIST
89165: LIST
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PPUSH
89171: CALL_OW 72
89175: ST_TO_ADDR
// if tmp then
89176: LD_VAR 0 6
89180: IFFALSE 89186
// exit ;
89182: POP
89183: POP
89184: GO 89326
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
89186: LD_ADDR_VAR 0 6
89190: PUSH
89191: LD_EXP 62
89195: PUSH
89196: LD_VAR 0 3
89200: ARRAY
89201: PPUSH
89202: LD_INT 2
89204: PUSH
89205: LD_INT 30
89207: PUSH
89208: LD_INT 4
89210: PUSH
89211: EMPTY
89212: LIST
89213: LIST
89214: PUSH
89215: LD_INT 30
89217: PUSH
89218: LD_INT 5
89220: PUSH
89221: EMPTY
89222: LIST
89223: LIST
89224: PUSH
89225: EMPTY
89226: LIST
89227: LIST
89228: LIST
89229: PPUSH
89230: CALL_OW 72
89234: ST_TO_ADDR
// if not tmp then
89235: LD_VAR 0 6
89239: NOT
89240: IFFALSE 89246
// exit ;
89242: POP
89243: POP
89244: GO 89326
// for j in tmp do
89246: LD_ADDR_VAR 0 4
89250: PUSH
89251: LD_VAR 0 6
89255: PUSH
89256: FOR_IN
89257: IFFALSE 89316
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
89259: LD_ADDR_VAR 0 7
89263: PUSH
89264: LD_VAR 0 4
89268: PPUSH
89269: CALL_OW 313
89273: PPUSH
89274: LD_INT 25
89276: PUSH
89277: LD_INT 1
89279: PUSH
89280: EMPTY
89281: LIST
89282: LIST
89283: PPUSH
89284: CALL_OW 72
89288: ST_TO_ADDR
// if units then
89289: LD_VAR 0 7
89293: IFFALSE 89314
// begin ComExitBuilding ( units [ 1 ] ) ;
89295: LD_VAR 0 7
89299: PUSH
89300: LD_INT 1
89302: ARRAY
89303: PPUSH
89304: CALL_OW 122
// exit ;
89308: POP
89309: POP
89310: POP
89311: POP
89312: GO 89326
// end ; end ;
89314: GO 89256
89316: POP
89317: POP
// end ; end ; exit ;
89318: POP
89319: POP
89320: GO 89326
// end ; end ;
89322: GO 88680
89324: POP
89325: POP
// end ;
89326: LD_VAR 0 2
89330: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
89331: LD_INT 0
89333: PPUSH
89334: PPUSH
89335: PPUSH
89336: PPUSH
89337: PPUSH
89338: PPUSH
89339: PPUSH
// if not mc_bases or not skirmish then
89340: LD_EXP 62
89344: NOT
89345: PUSH
89346: LD_EXP 60
89350: NOT
89351: OR
89352: IFFALSE 89356
// exit ;
89354: GO 89621
// btype := GetBType ( building ) ;
89356: LD_ADDR_VAR 0 6
89360: PUSH
89361: LD_VAR 0 1
89365: PPUSH
89366: CALL_OW 266
89370: ST_TO_ADDR
// x := GetX ( building ) ;
89371: LD_ADDR_VAR 0 7
89375: PUSH
89376: LD_VAR 0 1
89380: PPUSH
89381: CALL_OW 250
89385: ST_TO_ADDR
// y := GetY ( building ) ;
89386: LD_ADDR_VAR 0 8
89390: PUSH
89391: LD_VAR 0 1
89395: PPUSH
89396: CALL_OW 251
89400: ST_TO_ADDR
// d := GetDir ( building ) ;
89401: LD_ADDR_VAR 0 9
89405: PUSH
89406: LD_VAR 0 1
89410: PPUSH
89411: CALL_OW 254
89415: ST_TO_ADDR
// for i = 1 to mc_bases do
89416: LD_ADDR_VAR 0 4
89420: PUSH
89421: DOUBLE
89422: LD_INT 1
89424: DEC
89425: ST_TO_ADDR
89426: LD_EXP 62
89430: PUSH
89431: FOR_TO
89432: IFFALSE 89619
// begin if not mc_build_list [ i ] then
89434: LD_EXP 67
89438: PUSH
89439: LD_VAR 0 4
89443: ARRAY
89444: NOT
89445: IFFALSE 89449
// continue ;
89447: GO 89431
// for j := 1 to mc_build_list [ i ] do
89449: LD_ADDR_VAR 0 5
89453: PUSH
89454: DOUBLE
89455: LD_INT 1
89457: DEC
89458: ST_TO_ADDR
89459: LD_EXP 67
89463: PUSH
89464: LD_VAR 0 4
89468: ARRAY
89469: PUSH
89470: FOR_TO
89471: IFFALSE 89615
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
89473: LD_VAR 0 6
89477: PUSH
89478: LD_VAR 0 7
89482: PUSH
89483: LD_VAR 0 8
89487: PUSH
89488: LD_VAR 0 9
89492: PUSH
89493: EMPTY
89494: LIST
89495: LIST
89496: LIST
89497: LIST
89498: PPUSH
89499: LD_EXP 67
89503: PUSH
89504: LD_VAR 0 4
89508: ARRAY
89509: PUSH
89510: LD_VAR 0 5
89514: ARRAY
89515: PPUSH
89516: CALL 28019 0 2
89520: IFFALSE 89613
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
89522: LD_ADDR_EXP 67
89526: PUSH
89527: LD_EXP 67
89531: PPUSH
89532: LD_VAR 0 4
89536: PPUSH
89537: LD_EXP 67
89541: PUSH
89542: LD_VAR 0 4
89546: ARRAY
89547: PPUSH
89548: LD_VAR 0 5
89552: PPUSH
89553: CALL_OW 3
89557: PPUSH
89558: CALL_OW 1
89562: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
89563: LD_ADDR_EXP 69
89567: PUSH
89568: LD_EXP 69
89572: PPUSH
89573: LD_VAR 0 4
89577: PUSH
89578: LD_EXP 69
89582: PUSH
89583: LD_VAR 0 4
89587: ARRAY
89588: PUSH
89589: LD_INT 1
89591: PLUS
89592: PUSH
89593: EMPTY
89594: LIST
89595: LIST
89596: PPUSH
89597: LD_VAR 0 1
89601: PPUSH
89602: CALL 21462 0 3
89606: ST_TO_ADDR
// exit ;
89607: POP
89608: POP
89609: POP
89610: POP
89611: GO 89621
// end ;
89613: GO 89470
89615: POP
89616: POP
// end ;
89617: GO 89431
89619: POP
89620: POP
// end ;
89621: LD_VAR 0 3
89625: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
89626: LD_INT 0
89628: PPUSH
89629: PPUSH
89630: PPUSH
// if not mc_bases or not skirmish then
89631: LD_EXP 62
89635: NOT
89636: PUSH
89637: LD_EXP 60
89641: NOT
89642: OR
89643: IFFALSE 89647
// exit ;
89645: GO 89837
// for i = 1 to mc_bases do
89647: LD_ADDR_VAR 0 4
89651: PUSH
89652: DOUBLE
89653: LD_INT 1
89655: DEC
89656: ST_TO_ADDR
89657: LD_EXP 62
89661: PUSH
89662: FOR_TO
89663: IFFALSE 89750
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
89665: LD_VAR 0 1
89669: PUSH
89670: LD_EXP 70
89674: PUSH
89675: LD_VAR 0 4
89679: ARRAY
89680: IN
89681: PUSH
89682: LD_VAR 0 1
89686: PUSH
89687: LD_EXP 71
89691: PUSH
89692: LD_VAR 0 4
89696: ARRAY
89697: IN
89698: NOT
89699: AND
89700: IFFALSE 89748
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
89702: LD_ADDR_EXP 71
89706: PUSH
89707: LD_EXP 71
89711: PPUSH
89712: LD_VAR 0 4
89716: PUSH
89717: LD_EXP 71
89721: PUSH
89722: LD_VAR 0 4
89726: ARRAY
89727: PUSH
89728: LD_INT 1
89730: PLUS
89731: PUSH
89732: EMPTY
89733: LIST
89734: LIST
89735: PPUSH
89736: LD_VAR 0 1
89740: PPUSH
89741: CALL 21462 0 3
89745: ST_TO_ADDR
// break ;
89746: GO 89750
// end ; end ;
89748: GO 89662
89750: POP
89751: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
89752: LD_VAR 0 1
89756: PPUSH
89757: CALL_OW 257
89761: PUSH
89762: LD_EXP 88
89766: IN
89767: PUSH
89768: LD_VAR 0 1
89772: PPUSH
89773: CALL_OW 266
89777: PUSH
89778: LD_INT 5
89780: EQUAL
89781: AND
89782: PUSH
89783: LD_VAR 0 2
89787: PPUSH
89788: CALL_OW 110
89792: PUSH
89793: LD_INT 18
89795: NONEQUAL
89796: AND
89797: IFFALSE 89837
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
89799: LD_VAR 0 2
89803: PPUSH
89804: CALL_OW 257
89808: PUSH
89809: LD_INT 5
89811: PUSH
89812: LD_INT 8
89814: PUSH
89815: LD_INT 9
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: LIST
89822: IN
89823: IFFALSE 89837
// SetClass ( unit , 1 ) ;
89825: LD_VAR 0 2
89829: PPUSH
89830: LD_INT 1
89832: PPUSH
89833: CALL_OW 336
// end ;
89837: LD_VAR 0 3
89841: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
89842: LD_INT 0
89844: PPUSH
89845: PPUSH
// if not mc_bases or not skirmish then
89846: LD_EXP 62
89850: NOT
89851: PUSH
89852: LD_EXP 60
89856: NOT
89857: OR
89858: IFFALSE 89862
// exit ;
89860: GO 89978
// if GetLives ( abandoned_vehicle ) > 250 then
89862: LD_VAR 0 2
89866: PPUSH
89867: CALL_OW 256
89871: PUSH
89872: LD_INT 250
89874: GREATER
89875: IFFALSE 89879
// exit ;
89877: GO 89978
// for i = 1 to mc_bases do
89879: LD_ADDR_VAR 0 6
89883: PUSH
89884: DOUBLE
89885: LD_INT 1
89887: DEC
89888: ST_TO_ADDR
89889: LD_EXP 62
89893: PUSH
89894: FOR_TO
89895: IFFALSE 89976
// begin if driver in mc_bases [ i ] then
89897: LD_VAR 0 1
89901: PUSH
89902: LD_EXP 62
89906: PUSH
89907: LD_VAR 0 6
89911: ARRAY
89912: IN
89913: IFFALSE 89974
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
89915: LD_VAR 0 1
89919: PPUSH
89920: LD_EXP 62
89924: PUSH
89925: LD_VAR 0 6
89929: ARRAY
89930: PPUSH
89931: LD_INT 2
89933: PUSH
89934: LD_INT 30
89936: PUSH
89937: LD_INT 0
89939: PUSH
89940: EMPTY
89941: LIST
89942: LIST
89943: PUSH
89944: LD_INT 30
89946: PUSH
89947: LD_INT 1
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: PUSH
89954: EMPTY
89955: LIST
89956: LIST
89957: LIST
89958: PPUSH
89959: CALL_OW 72
89963: PUSH
89964: LD_INT 1
89966: ARRAY
89967: PPUSH
89968: CALL 55068 0 2
// break ;
89972: GO 89976
// end ; end ;
89974: GO 89894
89976: POP
89977: POP
// end ; end_of_file end_of_file
89978: LD_VAR 0 5
89982: RET
// export globalGameSaveCounter ; every 0 0$1 do
89983: GO 89985
89985: DISABLE
// begin enable ;
89986: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
89987: LD_STRING updateTimer(
89989: PUSH
89990: LD_OWVAR 1
89994: STR
89995: PUSH
89996: LD_STRING );
89998: STR
89999: PPUSH
90000: CALL_OW 559
// end ;
90004: END
// every 0 0$1 do
90005: GO 90007
90007: DISABLE
// begin globalGameSaveCounter := 0 ;
90008: LD_ADDR_EXP 107
90012: PUSH
90013: LD_INT 0
90015: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
90016: LD_STRING setGameSaveCounter(0)
90018: PPUSH
90019: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
90023: LD_STRING initStreamRollete();
90025: PPUSH
90026: CALL_OW 559
// InitStreamMode ;
90030: CALL 91373 0 0
// DefineStreamItems ( false ) ;
90034: LD_INT 0
90036: PPUSH
90037: CALL 91837 0 1
// end ;
90041: END
// export function SOS_MapStart ( ) ; begin
90042: LD_INT 0
90044: PPUSH
// if streamModeActive then
90045: LD_EXP 108
90049: IFFALSE 90058
// DefineStreamItems ( true ) ;
90051: LD_INT 1
90053: PPUSH
90054: CALL 91837 0 1
// UpdateLuaVariables ( ) ;
90058: CALL 90075 0 0
// UpdateFactoryWaypoints ( ) ;
90062: CALL 104706 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90066: CALL 104963 0 0
// end ;
90070: LD_VAR 0 1
90074: RET
// function UpdateLuaVariables ( ) ; begin
90075: LD_INT 0
90077: PPUSH
// if globalGameSaveCounter then
90078: LD_EXP 107
90082: IFFALSE 90116
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
90084: LD_ADDR_EXP 107
90088: PUSH
90089: LD_EXP 107
90093: PPUSH
90094: CALL 55552 0 1
90098: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90099: LD_STRING setGameSaveCounter(
90101: PUSH
90102: LD_EXP 107
90106: STR
90107: PUSH
90108: LD_STRING )
90110: STR
90111: PPUSH
90112: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
90116: LD_STRING setGameDifficulty(
90118: PUSH
90119: LD_OWVAR 67
90123: STR
90124: PUSH
90125: LD_STRING )
90127: STR
90128: PPUSH
90129: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
90133: LD_STRING displayDifficulty(
90135: PUSH
90136: LD_OWVAR 67
90140: STR
90141: PUSH
90142: LD_STRING )
90144: STR
90145: PPUSH
90146: CALL_OW 559
// end ;
90150: LD_VAR 0 1
90154: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90155: LD_INT 0
90157: PPUSH
// if p2 = stream_mode then
90158: LD_VAR 0 2
90162: PUSH
90163: LD_INT 100
90165: EQUAL
90166: IFFALSE 91169
// begin if not StreamModeActive then
90168: LD_EXP 108
90172: NOT
90173: IFFALSE 90183
// StreamModeActive := true ;
90175: LD_ADDR_EXP 108
90179: PUSH
90180: LD_INT 1
90182: ST_TO_ADDR
// if p3 = 0 then
90183: LD_VAR 0 3
90187: PUSH
90188: LD_INT 0
90190: EQUAL
90191: IFFALSE 90197
// InitStreamMode ;
90193: CALL 91373 0 0
// if p3 = 1 then
90197: LD_VAR 0 3
90201: PUSH
90202: LD_INT 1
90204: EQUAL
90205: IFFALSE 90215
// sRocket := true ;
90207: LD_ADDR_EXP 113
90211: PUSH
90212: LD_INT 1
90214: ST_TO_ADDR
// if p3 = 2 then
90215: LD_VAR 0 3
90219: PUSH
90220: LD_INT 2
90222: EQUAL
90223: IFFALSE 90233
// sSpeed := true ;
90225: LD_ADDR_EXP 112
90229: PUSH
90230: LD_INT 1
90232: ST_TO_ADDR
// if p3 = 3 then
90233: LD_VAR 0 3
90237: PUSH
90238: LD_INT 3
90240: EQUAL
90241: IFFALSE 90251
// sEngine := true ;
90243: LD_ADDR_EXP 114
90247: PUSH
90248: LD_INT 1
90250: ST_TO_ADDR
// if p3 = 4 then
90251: LD_VAR 0 3
90255: PUSH
90256: LD_INT 4
90258: EQUAL
90259: IFFALSE 90269
// sSpec := true ;
90261: LD_ADDR_EXP 111
90265: PUSH
90266: LD_INT 1
90268: ST_TO_ADDR
// if p3 = 5 then
90269: LD_VAR 0 3
90273: PUSH
90274: LD_INT 5
90276: EQUAL
90277: IFFALSE 90287
// sLevel := true ;
90279: LD_ADDR_EXP 115
90283: PUSH
90284: LD_INT 1
90286: ST_TO_ADDR
// if p3 = 6 then
90287: LD_VAR 0 3
90291: PUSH
90292: LD_INT 6
90294: EQUAL
90295: IFFALSE 90305
// sArmoury := true ;
90297: LD_ADDR_EXP 116
90301: PUSH
90302: LD_INT 1
90304: ST_TO_ADDR
// if p3 = 7 then
90305: LD_VAR 0 3
90309: PUSH
90310: LD_INT 7
90312: EQUAL
90313: IFFALSE 90323
// sRadar := true ;
90315: LD_ADDR_EXP 117
90319: PUSH
90320: LD_INT 1
90322: ST_TO_ADDR
// if p3 = 8 then
90323: LD_VAR 0 3
90327: PUSH
90328: LD_INT 8
90330: EQUAL
90331: IFFALSE 90341
// sBunker := true ;
90333: LD_ADDR_EXP 118
90337: PUSH
90338: LD_INT 1
90340: ST_TO_ADDR
// if p3 = 9 then
90341: LD_VAR 0 3
90345: PUSH
90346: LD_INT 9
90348: EQUAL
90349: IFFALSE 90359
// sHack := true ;
90351: LD_ADDR_EXP 119
90355: PUSH
90356: LD_INT 1
90358: ST_TO_ADDR
// if p3 = 10 then
90359: LD_VAR 0 3
90363: PUSH
90364: LD_INT 10
90366: EQUAL
90367: IFFALSE 90377
// sFire := true ;
90369: LD_ADDR_EXP 120
90373: PUSH
90374: LD_INT 1
90376: ST_TO_ADDR
// if p3 = 11 then
90377: LD_VAR 0 3
90381: PUSH
90382: LD_INT 11
90384: EQUAL
90385: IFFALSE 90395
// sRefresh := true ;
90387: LD_ADDR_EXP 121
90391: PUSH
90392: LD_INT 1
90394: ST_TO_ADDR
// if p3 = 12 then
90395: LD_VAR 0 3
90399: PUSH
90400: LD_INT 12
90402: EQUAL
90403: IFFALSE 90413
// sExp := true ;
90405: LD_ADDR_EXP 122
90409: PUSH
90410: LD_INT 1
90412: ST_TO_ADDR
// if p3 = 13 then
90413: LD_VAR 0 3
90417: PUSH
90418: LD_INT 13
90420: EQUAL
90421: IFFALSE 90431
// sDepot := true ;
90423: LD_ADDR_EXP 123
90427: PUSH
90428: LD_INT 1
90430: ST_TO_ADDR
// if p3 = 14 then
90431: LD_VAR 0 3
90435: PUSH
90436: LD_INT 14
90438: EQUAL
90439: IFFALSE 90449
// sFlag := true ;
90441: LD_ADDR_EXP 124
90445: PUSH
90446: LD_INT 1
90448: ST_TO_ADDR
// if p3 = 15 then
90449: LD_VAR 0 3
90453: PUSH
90454: LD_INT 15
90456: EQUAL
90457: IFFALSE 90467
// sKamikadze := true ;
90459: LD_ADDR_EXP 132
90463: PUSH
90464: LD_INT 1
90466: ST_TO_ADDR
// if p3 = 16 then
90467: LD_VAR 0 3
90471: PUSH
90472: LD_INT 16
90474: EQUAL
90475: IFFALSE 90485
// sTroll := true ;
90477: LD_ADDR_EXP 133
90481: PUSH
90482: LD_INT 1
90484: ST_TO_ADDR
// if p3 = 17 then
90485: LD_VAR 0 3
90489: PUSH
90490: LD_INT 17
90492: EQUAL
90493: IFFALSE 90503
// sSlow := true ;
90495: LD_ADDR_EXP 134
90499: PUSH
90500: LD_INT 1
90502: ST_TO_ADDR
// if p3 = 18 then
90503: LD_VAR 0 3
90507: PUSH
90508: LD_INT 18
90510: EQUAL
90511: IFFALSE 90521
// sLack := true ;
90513: LD_ADDR_EXP 135
90517: PUSH
90518: LD_INT 1
90520: ST_TO_ADDR
// if p3 = 19 then
90521: LD_VAR 0 3
90525: PUSH
90526: LD_INT 19
90528: EQUAL
90529: IFFALSE 90539
// sTank := true ;
90531: LD_ADDR_EXP 137
90535: PUSH
90536: LD_INT 1
90538: ST_TO_ADDR
// if p3 = 20 then
90539: LD_VAR 0 3
90543: PUSH
90544: LD_INT 20
90546: EQUAL
90547: IFFALSE 90557
// sRemote := true ;
90549: LD_ADDR_EXP 138
90553: PUSH
90554: LD_INT 1
90556: ST_TO_ADDR
// if p3 = 21 then
90557: LD_VAR 0 3
90561: PUSH
90562: LD_INT 21
90564: EQUAL
90565: IFFALSE 90575
// sPowell := true ;
90567: LD_ADDR_EXP 139
90571: PUSH
90572: LD_INT 1
90574: ST_TO_ADDR
// if p3 = 22 then
90575: LD_VAR 0 3
90579: PUSH
90580: LD_INT 22
90582: EQUAL
90583: IFFALSE 90593
// sTeleport := true ;
90585: LD_ADDR_EXP 142
90589: PUSH
90590: LD_INT 1
90592: ST_TO_ADDR
// if p3 = 23 then
90593: LD_VAR 0 3
90597: PUSH
90598: LD_INT 23
90600: EQUAL
90601: IFFALSE 90611
// sOilTower := true ;
90603: LD_ADDR_EXP 144
90607: PUSH
90608: LD_INT 1
90610: ST_TO_ADDR
// if p3 = 24 then
90611: LD_VAR 0 3
90615: PUSH
90616: LD_INT 24
90618: EQUAL
90619: IFFALSE 90629
// sShovel := true ;
90621: LD_ADDR_EXP 145
90625: PUSH
90626: LD_INT 1
90628: ST_TO_ADDR
// if p3 = 25 then
90629: LD_VAR 0 3
90633: PUSH
90634: LD_INT 25
90636: EQUAL
90637: IFFALSE 90647
// sSheik := true ;
90639: LD_ADDR_EXP 146
90643: PUSH
90644: LD_INT 1
90646: ST_TO_ADDR
// if p3 = 26 then
90647: LD_VAR 0 3
90651: PUSH
90652: LD_INT 26
90654: EQUAL
90655: IFFALSE 90665
// sEarthquake := true ;
90657: LD_ADDR_EXP 148
90661: PUSH
90662: LD_INT 1
90664: ST_TO_ADDR
// if p3 = 27 then
90665: LD_VAR 0 3
90669: PUSH
90670: LD_INT 27
90672: EQUAL
90673: IFFALSE 90683
// sAI := true ;
90675: LD_ADDR_EXP 149
90679: PUSH
90680: LD_INT 1
90682: ST_TO_ADDR
// if p3 = 28 then
90683: LD_VAR 0 3
90687: PUSH
90688: LD_INT 28
90690: EQUAL
90691: IFFALSE 90701
// sCargo := true ;
90693: LD_ADDR_EXP 152
90697: PUSH
90698: LD_INT 1
90700: ST_TO_ADDR
// if p3 = 29 then
90701: LD_VAR 0 3
90705: PUSH
90706: LD_INT 29
90708: EQUAL
90709: IFFALSE 90719
// sDLaser := true ;
90711: LD_ADDR_EXP 153
90715: PUSH
90716: LD_INT 1
90718: ST_TO_ADDR
// if p3 = 30 then
90719: LD_VAR 0 3
90723: PUSH
90724: LD_INT 30
90726: EQUAL
90727: IFFALSE 90737
// sExchange := true ;
90729: LD_ADDR_EXP 154
90733: PUSH
90734: LD_INT 1
90736: ST_TO_ADDR
// if p3 = 31 then
90737: LD_VAR 0 3
90741: PUSH
90742: LD_INT 31
90744: EQUAL
90745: IFFALSE 90755
// sFac := true ;
90747: LD_ADDR_EXP 155
90751: PUSH
90752: LD_INT 1
90754: ST_TO_ADDR
// if p3 = 32 then
90755: LD_VAR 0 3
90759: PUSH
90760: LD_INT 32
90762: EQUAL
90763: IFFALSE 90773
// sPower := true ;
90765: LD_ADDR_EXP 156
90769: PUSH
90770: LD_INT 1
90772: ST_TO_ADDR
// if p3 = 33 then
90773: LD_VAR 0 3
90777: PUSH
90778: LD_INT 33
90780: EQUAL
90781: IFFALSE 90791
// sRandom := true ;
90783: LD_ADDR_EXP 157
90787: PUSH
90788: LD_INT 1
90790: ST_TO_ADDR
// if p3 = 34 then
90791: LD_VAR 0 3
90795: PUSH
90796: LD_INT 34
90798: EQUAL
90799: IFFALSE 90809
// sShield := true ;
90801: LD_ADDR_EXP 158
90805: PUSH
90806: LD_INT 1
90808: ST_TO_ADDR
// if p3 = 35 then
90809: LD_VAR 0 3
90813: PUSH
90814: LD_INT 35
90816: EQUAL
90817: IFFALSE 90827
// sTime := true ;
90819: LD_ADDR_EXP 159
90823: PUSH
90824: LD_INT 1
90826: ST_TO_ADDR
// if p3 = 36 then
90827: LD_VAR 0 3
90831: PUSH
90832: LD_INT 36
90834: EQUAL
90835: IFFALSE 90845
// sTools := true ;
90837: LD_ADDR_EXP 160
90841: PUSH
90842: LD_INT 1
90844: ST_TO_ADDR
// if p3 = 101 then
90845: LD_VAR 0 3
90849: PUSH
90850: LD_INT 101
90852: EQUAL
90853: IFFALSE 90863
// sSold := true ;
90855: LD_ADDR_EXP 125
90859: PUSH
90860: LD_INT 1
90862: ST_TO_ADDR
// if p3 = 102 then
90863: LD_VAR 0 3
90867: PUSH
90868: LD_INT 102
90870: EQUAL
90871: IFFALSE 90881
// sDiff := true ;
90873: LD_ADDR_EXP 126
90877: PUSH
90878: LD_INT 1
90880: ST_TO_ADDR
// if p3 = 103 then
90881: LD_VAR 0 3
90885: PUSH
90886: LD_INT 103
90888: EQUAL
90889: IFFALSE 90899
// sFog := true ;
90891: LD_ADDR_EXP 129
90895: PUSH
90896: LD_INT 1
90898: ST_TO_ADDR
// if p3 = 104 then
90899: LD_VAR 0 3
90903: PUSH
90904: LD_INT 104
90906: EQUAL
90907: IFFALSE 90917
// sReset := true ;
90909: LD_ADDR_EXP 130
90913: PUSH
90914: LD_INT 1
90916: ST_TO_ADDR
// if p3 = 105 then
90917: LD_VAR 0 3
90921: PUSH
90922: LD_INT 105
90924: EQUAL
90925: IFFALSE 90935
// sSun := true ;
90927: LD_ADDR_EXP 131
90931: PUSH
90932: LD_INT 1
90934: ST_TO_ADDR
// if p3 = 106 then
90935: LD_VAR 0 3
90939: PUSH
90940: LD_INT 106
90942: EQUAL
90943: IFFALSE 90953
// sTiger := true ;
90945: LD_ADDR_EXP 127
90949: PUSH
90950: LD_INT 1
90952: ST_TO_ADDR
// if p3 = 107 then
90953: LD_VAR 0 3
90957: PUSH
90958: LD_INT 107
90960: EQUAL
90961: IFFALSE 90971
// sBomb := true ;
90963: LD_ADDR_EXP 128
90967: PUSH
90968: LD_INT 1
90970: ST_TO_ADDR
// if p3 = 108 then
90971: LD_VAR 0 3
90975: PUSH
90976: LD_INT 108
90978: EQUAL
90979: IFFALSE 90989
// sWound := true ;
90981: LD_ADDR_EXP 136
90985: PUSH
90986: LD_INT 1
90988: ST_TO_ADDR
// if p3 = 109 then
90989: LD_VAR 0 3
90993: PUSH
90994: LD_INT 109
90996: EQUAL
90997: IFFALSE 91007
// sBetray := true ;
90999: LD_ADDR_EXP 140
91003: PUSH
91004: LD_INT 1
91006: ST_TO_ADDR
// if p3 = 110 then
91007: LD_VAR 0 3
91011: PUSH
91012: LD_INT 110
91014: EQUAL
91015: IFFALSE 91025
// sContamin := true ;
91017: LD_ADDR_EXP 141
91021: PUSH
91022: LD_INT 1
91024: ST_TO_ADDR
// if p3 = 111 then
91025: LD_VAR 0 3
91029: PUSH
91030: LD_INT 111
91032: EQUAL
91033: IFFALSE 91043
// sOil := true ;
91035: LD_ADDR_EXP 143
91039: PUSH
91040: LD_INT 1
91042: ST_TO_ADDR
// if p3 = 112 then
91043: LD_VAR 0 3
91047: PUSH
91048: LD_INT 112
91050: EQUAL
91051: IFFALSE 91061
// sStu := true ;
91053: LD_ADDR_EXP 147
91057: PUSH
91058: LD_INT 1
91060: ST_TO_ADDR
// if p3 = 113 then
91061: LD_VAR 0 3
91065: PUSH
91066: LD_INT 113
91068: EQUAL
91069: IFFALSE 91079
// sBazooka := true ;
91071: LD_ADDR_EXP 150
91075: PUSH
91076: LD_INT 1
91078: ST_TO_ADDR
// if p3 = 114 then
91079: LD_VAR 0 3
91083: PUSH
91084: LD_INT 114
91086: EQUAL
91087: IFFALSE 91097
// sMortar := true ;
91089: LD_ADDR_EXP 151
91093: PUSH
91094: LD_INT 1
91096: ST_TO_ADDR
// if p3 = 115 then
91097: LD_VAR 0 3
91101: PUSH
91102: LD_INT 115
91104: EQUAL
91105: IFFALSE 91115
// sRanger := true ;
91107: LD_ADDR_EXP 161
91111: PUSH
91112: LD_INT 1
91114: ST_TO_ADDR
// if p3 = 116 then
91115: LD_VAR 0 3
91119: PUSH
91120: LD_INT 116
91122: EQUAL
91123: IFFALSE 91133
// sComputer := true ;
91125: LD_ADDR_EXP 162
91129: PUSH
91130: LD_INT 1
91132: ST_TO_ADDR
// if p3 = 117 then
91133: LD_VAR 0 3
91137: PUSH
91138: LD_INT 117
91140: EQUAL
91141: IFFALSE 91151
// s30 := true ;
91143: LD_ADDR_EXP 163
91147: PUSH
91148: LD_INT 1
91150: ST_TO_ADDR
// if p3 = 118 then
91151: LD_VAR 0 3
91155: PUSH
91156: LD_INT 118
91158: EQUAL
91159: IFFALSE 91169
// s60 := true ;
91161: LD_ADDR_EXP 164
91165: PUSH
91166: LD_INT 1
91168: ST_TO_ADDR
// end ; if p2 = hack_mode then
91169: LD_VAR 0 2
91173: PUSH
91174: LD_INT 101
91176: EQUAL
91177: IFFALSE 91305
// begin case p3 of 1 :
91179: LD_VAR 0 3
91183: PUSH
91184: LD_INT 1
91186: DOUBLE
91187: EQUAL
91188: IFTRUE 91192
91190: GO 91199
91192: POP
// hHackUnlimitedResources ; 2 :
91193: CALL 103452 0 0
91197: GO 91305
91199: LD_INT 2
91201: DOUBLE
91202: EQUAL
91203: IFTRUE 91207
91205: GO 91214
91207: POP
// hHackSetLevel10 ; 3 :
91208: CALL 103585 0 0
91212: GO 91305
91214: LD_INT 3
91216: DOUBLE
91217: EQUAL
91218: IFTRUE 91222
91220: GO 91229
91222: POP
// hHackSetLevel10YourUnits ; 4 :
91223: CALL 103670 0 0
91227: GO 91305
91229: LD_INT 4
91231: DOUBLE
91232: EQUAL
91233: IFTRUE 91237
91235: GO 91244
91237: POP
// hHackInvincible ; 5 :
91238: CALL 104118 0 0
91242: GO 91305
91244: LD_INT 5
91246: DOUBLE
91247: EQUAL
91248: IFTRUE 91252
91250: GO 91259
91252: POP
// hHackInvisible ; 6 :
91253: CALL 104229 0 0
91257: GO 91305
91259: LD_INT 6
91261: DOUBLE
91262: EQUAL
91263: IFTRUE 91267
91265: GO 91274
91267: POP
// hHackChangeYourSide ; 7 :
91268: CALL 104286 0 0
91272: GO 91305
91274: LD_INT 7
91276: DOUBLE
91277: EQUAL
91278: IFTRUE 91282
91280: GO 91289
91282: POP
// hHackChangeUnitSide ; 8 :
91283: CALL 104328 0 0
91287: GO 91305
91289: LD_INT 8
91291: DOUBLE
91292: EQUAL
91293: IFTRUE 91297
91295: GO 91304
91297: POP
// hHackFog ; end ;
91298: CALL 104429 0 0
91302: GO 91305
91304: POP
// end ; if p2 = game_save_mode then
91305: LD_VAR 0 2
91309: PUSH
91310: LD_INT 102
91312: EQUAL
91313: IFFALSE 91368
// begin if p3 = 1 then
91315: LD_VAR 0 3
91319: PUSH
91320: LD_INT 1
91322: EQUAL
91323: IFFALSE 91335
// globalGameSaveCounter := p4 ;
91325: LD_ADDR_EXP 107
91329: PUSH
91330: LD_VAR 0 4
91334: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
91335: LD_VAR 0 3
91339: PUSH
91340: LD_INT 2
91342: EQUAL
91343: PUSH
91344: LD_EXP 107
91348: AND
91349: IFFALSE 91368
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91351: LD_STRING setGameSaveCounter(
91353: PUSH
91354: LD_EXP 107
91358: STR
91359: PUSH
91360: LD_STRING )
91362: STR
91363: PPUSH
91364: CALL_OW 559
// end ; end ;
91368: LD_VAR 0 7
91372: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
91373: LD_INT 0
91375: PPUSH
// streamModeActive := false ;
91376: LD_ADDR_EXP 108
91380: PUSH
91381: LD_INT 0
91383: ST_TO_ADDR
// normalCounter := 36 ;
91384: LD_ADDR_EXP 109
91388: PUSH
91389: LD_INT 36
91391: ST_TO_ADDR
// hardcoreCounter := 18 ;
91392: LD_ADDR_EXP 110
91396: PUSH
91397: LD_INT 18
91399: ST_TO_ADDR
// sRocket := false ;
91400: LD_ADDR_EXP 113
91404: PUSH
91405: LD_INT 0
91407: ST_TO_ADDR
// sSpeed := false ;
91408: LD_ADDR_EXP 112
91412: PUSH
91413: LD_INT 0
91415: ST_TO_ADDR
// sEngine := false ;
91416: LD_ADDR_EXP 114
91420: PUSH
91421: LD_INT 0
91423: ST_TO_ADDR
// sSpec := false ;
91424: LD_ADDR_EXP 111
91428: PUSH
91429: LD_INT 0
91431: ST_TO_ADDR
// sLevel := false ;
91432: LD_ADDR_EXP 115
91436: PUSH
91437: LD_INT 0
91439: ST_TO_ADDR
// sArmoury := false ;
91440: LD_ADDR_EXP 116
91444: PUSH
91445: LD_INT 0
91447: ST_TO_ADDR
// sRadar := false ;
91448: LD_ADDR_EXP 117
91452: PUSH
91453: LD_INT 0
91455: ST_TO_ADDR
// sBunker := false ;
91456: LD_ADDR_EXP 118
91460: PUSH
91461: LD_INT 0
91463: ST_TO_ADDR
// sHack := false ;
91464: LD_ADDR_EXP 119
91468: PUSH
91469: LD_INT 0
91471: ST_TO_ADDR
// sFire := false ;
91472: LD_ADDR_EXP 120
91476: PUSH
91477: LD_INT 0
91479: ST_TO_ADDR
// sRefresh := false ;
91480: LD_ADDR_EXP 121
91484: PUSH
91485: LD_INT 0
91487: ST_TO_ADDR
// sExp := false ;
91488: LD_ADDR_EXP 122
91492: PUSH
91493: LD_INT 0
91495: ST_TO_ADDR
// sDepot := false ;
91496: LD_ADDR_EXP 123
91500: PUSH
91501: LD_INT 0
91503: ST_TO_ADDR
// sFlag := false ;
91504: LD_ADDR_EXP 124
91508: PUSH
91509: LD_INT 0
91511: ST_TO_ADDR
// sKamikadze := false ;
91512: LD_ADDR_EXP 132
91516: PUSH
91517: LD_INT 0
91519: ST_TO_ADDR
// sTroll := false ;
91520: LD_ADDR_EXP 133
91524: PUSH
91525: LD_INT 0
91527: ST_TO_ADDR
// sSlow := false ;
91528: LD_ADDR_EXP 134
91532: PUSH
91533: LD_INT 0
91535: ST_TO_ADDR
// sLack := false ;
91536: LD_ADDR_EXP 135
91540: PUSH
91541: LD_INT 0
91543: ST_TO_ADDR
// sTank := false ;
91544: LD_ADDR_EXP 137
91548: PUSH
91549: LD_INT 0
91551: ST_TO_ADDR
// sRemote := false ;
91552: LD_ADDR_EXP 138
91556: PUSH
91557: LD_INT 0
91559: ST_TO_ADDR
// sPowell := false ;
91560: LD_ADDR_EXP 139
91564: PUSH
91565: LD_INT 0
91567: ST_TO_ADDR
// sTeleport := false ;
91568: LD_ADDR_EXP 142
91572: PUSH
91573: LD_INT 0
91575: ST_TO_ADDR
// sOilTower := false ;
91576: LD_ADDR_EXP 144
91580: PUSH
91581: LD_INT 0
91583: ST_TO_ADDR
// sShovel := false ;
91584: LD_ADDR_EXP 145
91588: PUSH
91589: LD_INT 0
91591: ST_TO_ADDR
// sSheik := false ;
91592: LD_ADDR_EXP 146
91596: PUSH
91597: LD_INT 0
91599: ST_TO_ADDR
// sEarthquake := false ;
91600: LD_ADDR_EXP 148
91604: PUSH
91605: LD_INT 0
91607: ST_TO_ADDR
// sAI := false ;
91608: LD_ADDR_EXP 149
91612: PUSH
91613: LD_INT 0
91615: ST_TO_ADDR
// sCargo := false ;
91616: LD_ADDR_EXP 152
91620: PUSH
91621: LD_INT 0
91623: ST_TO_ADDR
// sDLaser := false ;
91624: LD_ADDR_EXP 153
91628: PUSH
91629: LD_INT 0
91631: ST_TO_ADDR
// sExchange := false ;
91632: LD_ADDR_EXP 154
91636: PUSH
91637: LD_INT 0
91639: ST_TO_ADDR
// sFac := false ;
91640: LD_ADDR_EXP 155
91644: PUSH
91645: LD_INT 0
91647: ST_TO_ADDR
// sPower := false ;
91648: LD_ADDR_EXP 156
91652: PUSH
91653: LD_INT 0
91655: ST_TO_ADDR
// sRandom := false ;
91656: LD_ADDR_EXP 157
91660: PUSH
91661: LD_INT 0
91663: ST_TO_ADDR
// sShield := false ;
91664: LD_ADDR_EXP 158
91668: PUSH
91669: LD_INT 0
91671: ST_TO_ADDR
// sTime := false ;
91672: LD_ADDR_EXP 159
91676: PUSH
91677: LD_INT 0
91679: ST_TO_ADDR
// sTools := false ;
91680: LD_ADDR_EXP 160
91684: PUSH
91685: LD_INT 0
91687: ST_TO_ADDR
// sSold := false ;
91688: LD_ADDR_EXP 125
91692: PUSH
91693: LD_INT 0
91695: ST_TO_ADDR
// sDiff := false ;
91696: LD_ADDR_EXP 126
91700: PUSH
91701: LD_INT 0
91703: ST_TO_ADDR
// sFog := false ;
91704: LD_ADDR_EXP 129
91708: PUSH
91709: LD_INT 0
91711: ST_TO_ADDR
// sReset := false ;
91712: LD_ADDR_EXP 130
91716: PUSH
91717: LD_INT 0
91719: ST_TO_ADDR
// sSun := false ;
91720: LD_ADDR_EXP 131
91724: PUSH
91725: LD_INT 0
91727: ST_TO_ADDR
// sTiger := false ;
91728: LD_ADDR_EXP 127
91732: PUSH
91733: LD_INT 0
91735: ST_TO_ADDR
// sBomb := false ;
91736: LD_ADDR_EXP 128
91740: PUSH
91741: LD_INT 0
91743: ST_TO_ADDR
// sWound := false ;
91744: LD_ADDR_EXP 136
91748: PUSH
91749: LD_INT 0
91751: ST_TO_ADDR
// sBetray := false ;
91752: LD_ADDR_EXP 140
91756: PUSH
91757: LD_INT 0
91759: ST_TO_ADDR
// sContamin := false ;
91760: LD_ADDR_EXP 141
91764: PUSH
91765: LD_INT 0
91767: ST_TO_ADDR
// sOil := false ;
91768: LD_ADDR_EXP 143
91772: PUSH
91773: LD_INT 0
91775: ST_TO_ADDR
// sStu := false ;
91776: LD_ADDR_EXP 147
91780: PUSH
91781: LD_INT 0
91783: ST_TO_ADDR
// sBazooka := false ;
91784: LD_ADDR_EXP 150
91788: PUSH
91789: LD_INT 0
91791: ST_TO_ADDR
// sMortar := false ;
91792: LD_ADDR_EXP 151
91796: PUSH
91797: LD_INT 0
91799: ST_TO_ADDR
// sRanger := false ;
91800: LD_ADDR_EXP 161
91804: PUSH
91805: LD_INT 0
91807: ST_TO_ADDR
// sComputer := false ;
91808: LD_ADDR_EXP 162
91812: PUSH
91813: LD_INT 0
91815: ST_TO_ADDR
// s30 := false ;
91816: LD_ADDR_EXP 163
91820: PUSH
91821: LD_INT 0
91823: ST_TO_ADDR
// s60 := false ;
91824: LD_ADDR_EXP 164
91828: PUSH
91829: LD_INT 0
91831: ST_TO_ADDR
// end ;
91832: LD_VAR 0 1
91836: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
91837: LD_INT 0
91839: PPUSH
91840: PPUSH
91841: PPUSH
91842: PPUSH
91843: PPUSH
91844: PPUSH
91845: PPUSH
// result := [ ] ;
91846: LD_ADDR_VAR 0 2
91850: PUSH
91851: EMPTY
91852: ST_TO_ADDR
// if campaign_id = 1 then
91853: LD_OWVAR 69
91857: PUSH
91858: LD_INT 1
91860: EQUAL
91861: IFFALSE 95027
// begin case mission_number of 1 :
91863: LD_OWVAR 70
91867: PUSH
91868: LD_INT 1
91870: DOUBLE
91871: EQUAL
91872: IFTRUE 91876
91874: GO 91952
91876: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
91877: LD_ADDR_VAR 0 2
91881: PUSH
91882: LD_INT 2
91884: PUSH
91885: LD_INT 4
91887: PUSH
91888: LD_INT 11
91890: PUSH
91891: LD_INT 12
91893: PUSH
91894: LD_INT 15
91896: PUSH
91897: LD_INT 16
91899: PUSH
91900: LD_INT 22
91902: PUSH
91903: LD_INT 23
91905: PUSH
91906: LD_INT 26
91908: PUSH
91909: EMPTY
91910: LIST
91911: LIST
91912: LIST
91913: LIST
91914: LIST
91915: LIST
91916: LIST
91917: LIST
91918: LIST
91919: PUSH
91920: LD_INT 101
91922: PUSH
91923: LD_INT 102
91925: PUSH
91926: LD_INT 106
91928: PUSH
91929: LD_INT 116
91931: PUSH
91932: LD_INT 117
91934: PUSH
91935: LD_INT 118
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: LIST
91942: LIST
91943: LIST
91944: LIST
91945: PUSH
91946: EMPTY
91947: LIST
91948: LIST
91949: ST_TO_ADDR
91950: GO 95025
91952: LD_INT 2
91954: DOUBLE
91955: EQUAL
91956: IFTRUE 91960
91958: GO 92044
91960: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
91961: LD_ADDR_VAR 0 2
91965: PUSH
91966: LD_INT 2
91968: PUSH
91969: LD_INT 4
91971: PUSH
91972: LD_INT 11
91974: PUSH
91975: LD_INT 12
91977: PUSH
91978: LD_INT 15
91980: PUSH
91981: LD_INT 16
91983: PUSH
91984: LD_INT 22
91986: PUSH
91987: LD_INT 23
91989: PUSH
91990: LD_INT 26
91992: PUSH
91993: EMPTY
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: LIST
92001: LIST
92002: LIST
92003: PUSH
92004: LD_INT 101
92006: PUSH
92007: LD_INT 102
92009: PUSH
92010: LD_INT 105
92012: PUSH
92013: LD_INT 106
92015: PUSH
92016: LD_INT 108
92018: PUSH
92019: LD_INT 116
92021: PUSH
92022: LD_INT 117
92024: PUSH
92025: LD_INT 118
92027: PUSH
92028: EMPTY
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: LIST
92037: PUSH
92038: EMPTY
92039: LIST
92040: LIST
92041: ST_TO_ADDR
92042: GO 95025
92044: LD_INT 3
92046: DOUBLE
92047: EQUAL
92048: IFTRUE 92052
92050: GO 92140
92052: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
92053: LD_ADDR_VAR 0 2
92057: PUSH
92058: LD_INT 2
92060: PUSH
92061: LD_INT 4
92063: PUSH
92064: LD_INT 5
92066: PUSH
92067: LD_INT 11
92069: PUSH
92070: LD_INT 12
92072: PUSH
92073: LD_INT 15
92075: PUSH
92076: LD_INT 16
92078: PUSH
92079: LD_INT 22
92081: PUSH
92082: LD_INT 26
92084: PUSH
92085: LD_INT 36
92087: PUSH
92088: EMPTY
92089: LIST
92090: LIST
92091: LIST
92092: LIST
92093: LIST
92094: LIST
92095: LIST
92096: LIST
92097: LIST
92098: LIST
92099: PUSH
92100: LD_INT 101
92102: PUSH
92103: LD_INT 102
92105: PUSH
92106: LD_INT 105
92108: PUSH
92109: LD_INT 106
92111: PUSH
92112: LD_INT 108
92114: PUSH
92115: LD_INT 116
92117: PUSH
92118: LD_INT 117
92120: PUSH
92121: LD_INT 118
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: LIST
92128: LIST
92129: LIST
92130: LIST
92131: LIST
92132: LIST
92133: PUSH
92134: EMPTY
92135: LIST
92136: LIST
92137: ST_TO_ADDR
92138: GO 95025
92140: LD_INT 4
92142: DOUBLE
92143: EQUAL
92144: IFTRUE 92148
92146: GO 92244
92148: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92149: LD_ADDR_VAR 0 2
92153: PUSH
92154: LD_INT 2
92156: PUSH
92157: LD_INT 4
92159: PUSH
92160: LD_INT 5
92162: PUSH
92163: LD_INT 8
92165: PUSH
92166: LD_INT 11
92168: PUSH
92169: LD_INT 12
92171: PUSH
92172: LD_INT 15
92174: PUSH
92175: LD_INT 16
92177: PUSH
92178: LD_INT 22
92180: PUSH
92181: LD_INT 23
92183: PUSH
92184: LD_INT 26
92186: PUSH
92187: LD_INT 36
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: LIST
92194: LIST
92195: LIST
92196: LIST
92197: LIST
92198: LIST
92199: LIST
92200: LIST
92201: LIST
92202: LIST
92203: PUSH
92204: LD_INT 101
92206: PUSH
92207: LD_INT 102
92209: PUSH
92210: LD_INT 105
92212: PUSH
92213: LD_INT 106
92215: PUSH
92216: LD_INT 108
92218: PUSH
92219: LD_INT 116
92221: PUSH
92222: LD_INT 117
92224: PUSH
92225: LD_INT 118
92227: PUSH
92228: EMPTY
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: PUSH
92238: EMPTY
92239: LIST
92240: LIST
92241: ST_TO_ADDR
92242: GO 95025
92244: LD_INT 5
92246: DOUBLE
92247: EQUAL
92248: IFTRUE 92252
92250: GO 92364
92252: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92253: LD_ADDR_VAR 0 2
92257: PUSH
92258: LD_INT 2
92260: PUSH
92261: LD_INT 4
92263: PUSH
92264: LD_INT 5
92266: PUSH
92267: LD_INT 6
92269: PUSH
92270: LD_INT 8
92272: PUSH
92273: LD_INT 11
92275: PUSH
92276: LD_INT 12
92278: PUSH
92279: LD_INT 15
92281: PUSH
92282: LD_INT 16
92284: PUSH
92285: LD_INT 22
92287: PUSH
92288: LD_INT 23
92290: PUSH
92291: LD_INT 25
92293: PUSH
92294: LD_INT 26
92296: PUSH
92297: LD_INT 36
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: PUSH
92316: LD_INT 101
92318: PUSH
92319: LD_INT 102
92321: PUSH
92322: LD_INT 105
92324: PUSH
92325: LD_INT 106
92327: PUSH
92328: LD_INT 108
92330: PUSH
92331: LD_INT 109
92333: PUSH
92334: LD_INT 112
92336: PUSH
92337: LD_INT 116
92339: PUSH
92340: LD_INT 117
92342: PUSH
92343: LD_INT 118
92345: PUSH
92346: EMPTY
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: LIST
92352: LIST
92353: LIST
92354: LIST
92355: LIST
92356: LIST
92357: PUSH
92358: EMPTY
92359: LIST
92360: LIST
92361: ST_TO_ADDR
92362: GO 95025
92364: LD_INT 6
92366: DOUBLE
92367: EQUAL
92368: IFTRUE 92372
92370: GO 92504
92372: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92373: LD_ADDR_VAR 0 2
92377: PUSH
92378: LD_INT 2
92380: PUSH
92381: LD_INT 4
92383: PUSH
92384: LD_INT 5
92386: PUSH
92387: LD_INT 6
92389: PUSH
92390: LD_INT 8
92392: PUSH
92393: LD_INT 11
92395: PUSH
92396: LD_INT 12
92398: PUSH
92399: LD_INT 15
92401: PUSH
92402: LD_INT 16
92404: PUSH
92405: LD_INT 20
92407: PUSH
92408: LD_INT 21
92410: PUSH
92411: LD_INT 22
92413: PUSH
92414: LD_INT 23
92416: PUSH
92417: LD_INT 25
92419: PUSH
92420: LD_INT 26
92422: PUSH
92423: LD_INT 30
92425: PUSH
92426: LD_INT 31
92428: PUSH
92429: LD_INT 32
92431: PUSH
92432: LD_INT 36
92434: PUSH
92435: EMPTY
92436: LIST
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: LIST
92455: PUSH
92456: LD_INT 101
92458: PUSH
92459: LD_INT 102
92461: PUSH
92462: LD_INT 105
92464: PUSH
92465: LD_INT 106
92467: PUSH
92468: LD_INT 108
92470: PUSH
92471: LD_INT 109
92473: PUSH
92474: LD_INT 112
92476: PUSH
92477: LD_INT 116
92479: PUSH
92480: LD_INT 117
92482: PUSH
92483: LD_INT 118
92485: PUSH
92486: EMPTY
92487: LIST
92488: LIST
92489: LIST
92490: LIST
92491: LIST
92492: LIST
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: PUSH
92498: EMPTY
92499: LIST
92500: LIST
92501: ST_TO_ADDR
92502: GO 95025
92504: LD_INT 7
92506: DOUBLE
92507: EQUAL
92508: IFTRUE 92512
92510: GO 92624
92512: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92513: LD_ADDR_VAR 0 2
92517: PUSH
92518: LD_INT 2
92520: PUSH
92521: LD_INT 4
92523: PUSH
92524: LD_INT 5
92526: PUSH
92527: LD_INT 7
92529: PUSH
92530: LD_INT 11
92532: PUSH
92533: LD_INT 12
92535: PUSH
92536: LD_INT 15
92538: PUSH
92539: LD_INT 16
92541: PUSH
92542: LD_INT 20
92544: PUSH
92545: LD_INT 21
92547: PUSH
92548: LD_INT 22
92550: PUSH
92551: LD_INT 23
92553: PUSH
92554: LD_INT 25
92556: PUSH
92557: LD_INT 26
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: PUSH
92576: LD_INT 101
92578: PUSH
92579: LD_INT 102
92581: PUSH
92582: LD_INT 103
92584: PUSH
92585: LD_INT 105
92587: PUSH
92588: LD_INT 106
92590: PUSH
92591: LD_INT 108
92593: PUSH
92594: LD_INT 112
92596: PUSH
92597: LD_INT 116
92599: PUSH
92600: LD_INT 117
92602: PUSH
92603: LD_INT 118
92605: PUSH
92606: EMPTY
92607: LIST
92608: LIST
92609: LIST
92610: LIST
92611: LIST
92612: LIST
92613: LIST
92614: LIST
92615: LIST
92616: LIST
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: ST_TO_ADDR
92622: GO 95025
92624: LD_INT 8
92626: DOUBLE
92627: EQUAL
92628: IFTRUE 92632
92630: GO 92772
92632: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
92633: LD_ADDR_VAR 0 2
92637: PUSH
92638: LD_INT 2
92640: PUSH
92641: LD_INT 4
92643: PUSH
92644: LD_INT 5
92646: PUSH
92647: LD_INT 6
92649: PUSH
92650: LD_INT 7
92652: PUSH
92653: LD_INT 8
92655: PUSH
92656: LD_INT 11
92658: PUSH
92659: LD_INT 12
92661: PUSH
92662: LD_INT 15
92664: PUSH
92665: LD_INT 16
92667: PUSH
92668: LD_INT 20
92670: PUSH
92671: LD_INT 21
92673: PUSH
92674: LD_INT 22
92676: PUSH
92677: LD_INT 23
92679: PUSH
92680: LD_INT 25
92682: PUSH
92683: LD_INT 26
92685: PUSH
92686: LD_INT 30
92688: PUSH
92689: LD_INT 31
92691: PUSH
92692: LD_INT 32
92694: PUSH
92695: LD_INT 36
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: LIST
92702: LIST
92703: LIST
92704: LIST
92705: LIST
92706: LIST
92707: LIST
92708: LIST
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: LIST
92714: LIST
92715: LIST
92716: LIST
92717: LIST
92718: LIST
92719: PUSH
92720: LD_INT 101
92722: PUSH
92723: LD_INT 102
92725: PUSH
92726: LD_INT 103
92728: PUSH
92729: LD_INT 105
92731: PUSH
92732: LD_INT 106
92734: PUSH
92735: LD_INT 108
92737: PUSH
92738: LD_INT 109
92740: PUSH
92741: LD_INT 112
92743: PUSH
92744: LD_INT 116
92746: PUSH
92747: LD_INT 117
92749: PUSH
92750: LD_INT 118
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: LIST
92757: LIST
92758: LIST
92759: LIST
92760: LIST
92761: LIST
92762: LIST
92763: LIST
92764: LIST
92765: PUSH
92766: EMPTY
92767: LIST
92768: LIST
92769: ST_TO_ADDR
92770: GO 95025
92772: LD_INT 9
92774: DOUBLE
92775: EQUAL
92776: IFTRUE 92780
92778: GO 92928
92780: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
92781: LD_ADDR_VAR 0 2
92785: PUSH
92786: LD_INT 2
92788: PUSH
92789: LD_INT 4
92791: PUSH
92792: LD_INT 5
92794: PUSH
92795: LD_INT 6
92797: PUSH
92798: LD_INT 7
92800: PUSH
92801: LD_INT 8
92803: PUSH
92804: LD_INT 11
92806: PUSH
92807: LD_INT 12
92809: PUSH
92810: LD_INT 15
92812: PUSH
92813: LD_INT 16
92815: PUSH
92816: LD_INT 20
92818: PUSH
92819: LD_INT 21
92821: PUSH
92822: LD_INT 22
92824: PUSH
92825: LD_INT 23
92827: PUSH
92828: LD_INT 25
92830: PUSH
92831: LD_INT 26
92833: PUSH
92834: LD_INT 28
92836: PUSH
92837: LD_INT 30
92839: PUSH
92840: LD_INT 31
92842: PUSH
92843: LD_INT 32
92845: PUSH
92846: LD_INT 36
92848: PUSH
92849: EMPTY
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: PUSH
92872: LD_INT 101
92874: PUSH
92875: LD_INT 102
92877: PUSH
92878: LD_INT 103
92880: PUSH
92881: LD_INT 105
92883: PUSH
92884: LD_INT 106
92886: PUSH
92887: LD_INT 108
92889: PUSH
92890: LD_INT 109
92892: PUSH
92893: LD_INT 112
92895: PUSH
92896: LD_INT 114
92898: PUSH
92899: LD_INT 116
92901: PUSH
92902: LD_INT 117
92904: PUSH
92905: LD_INT 118
92907: PUSH
92908: EMPTY
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: PUSH
92922: EMPTY
92923: LIST
92924: LIST
92925: ST_TO_ADDR
92926: GO 95025
92928: LD_INT 10
92930: DOUBLE
92931: EQUAL
92932: IFTRUE 92936
92934: GO 93132
92936: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
92937: LD_ADDR_VAR 0 2
92941: PUSH
92942: LD_INT 2
92944: PUSH
92945: LD_INT 4
92947: PUSH
92948: LD_INT 5
92950: PUSH
92951: LD_INT 6
92953: PUSH
92954: LD_INT 7
92956: PUSH
92957: LD_INT 8
92959: PUSH
92960: LD_INT 9
92962: PUSH
92963: LD_INT 10
92965: PUSH
92966: LD_INT 11
92968: PUSH
92969: LD_INT 12
92971: PUSH
92972: LD_INT 13
92974: PUSH
92975: LD_INT 14
92977: PUSH
92978: LD_INT 15
92980: PUSH
92981: LD_INT 16
92983: PUSH
92984: LD_INT 17
92986: PUSH
92987: LD_INT 18
92989: PUSH
92990: LD_INT 19
92992: PUSH
92993: LD_INT 20
92995: PUSH
92996: LD_INT 21
92998: PUSH
92999: LD_INT 22
93001: PUSH
93002: LD_INT 23
93004: PUSH
93005: LD_INT 24
93007: PUSH
93008: LD_INT 25
93010: PUSH
93011: LD_INT 26
93013: PUSH
93014: LD_INT 28
93016: PUSH
93017: LD_INT 30
93019: PUSH
93020: LD_INT 31
93022: PUSH
93023: LD_INT 32
93025: PUSH
93026: LD_INT 36
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: LIST
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: LIST
93046: LIST
93047: LIST
93048: LIST
93049: LIST
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: LIST
93058: LIST
93059: PUSH
93060: LD_INT 101
93062: PUSH
93063: LD_INT 102
93065: PUSH
93066: LD_INT 103
93068: PUSH
93069: LD_INT 104
93071: PUSH
93072: LD_INT 105
93074: PUSH
93075: LD_INT 106
93077: PUSH
93078: LD_INT 107
93080: PUSH
93081: LD_INT 108
93083: PUSH
93084: LD_INT 109
93086: PUSH
93087: LD_INT 110
93089: PUSH
93090: LD_INT 111
93092: PUSH
93093: LD_INT 112
93095: PUSH
93096: LD_INT 114
93098: PUSH
93099: LD_INT 116
93101: PUSH
93102: LD_INT 117
93104: PUSH
93105: LD_INT 118
93107: PUSH
93108: EMPTY
93109: LIST
93110: LIST
93111: LIST
93112: LIST
93113: LIST
93114: LIST
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: PUSH
93126: EMPTY
93127: LIST
93128: LIST
93129: ST_TO_ADDR
93130: GO 95025
93132: LD_INT 11
93134: DOUBLE
93135: EQUAL
93136: IFTRUE 93140
93138: GO 93344
93140: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93141: LD_ADDR_VAR 0 2
93145: PUSH
93146: LD_INT 2
93148: PUSH
93149: LD_INT 3
93151: PUSH
93152: LD_INT 4
93154: PUSH
93155: LD_INT 5
93157: PUSH
93158: LD_INT 6
93160: PUSH
93161: LD_INT 7
93163: PUSH
93164: LD_INT 8
93166: PUSH
93167: LD_INT 9
93169: PUSH
93170: LD_INT 10
93172: PUSH
93173: LD_INT 11
93175: PUSH
93176: LD_INT 12
93178: PUSH
93179: LD_INT 13
93181: PUSH
93182: LD_INT 14
93184: PUSH
93185: LD_INT 15
93187: PUSH
93188: LD_INT 16
93190: PUSH
93191: LD_INT 17
93193: PUSH
93194: LD_INT 18
93196: PUSH
93197: LD_INT 19
93199: PUSH
93200: LD_INT 20
93202: PUSH
93203: LD_INT 21
93205: PUSH
93206: LD_INT 22
93208: PUSH
93209: LD_INT 23
93211: PUSH
93212: LD_INT 24
93214: PUSH
93215: LD_INT 25
93217: PUSH
93218: LD_INT 26
93220: PUSH
93221: LD_INT 28
93223: PUSH
93224: LD_INT 30
93226: PUSH
93227: LD_INT 31
93229: PUSH
93230: LD_INT 32
93232: PUSH
93233: LD_INT 34
93235: PUSH
93236: LD_INT 36
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 101
93274: PUSH
93275: LD_INT 102
93277: PUSH
93278: LD_INT 103
93280: PUSH
93281: LD_INT 104
93283: PUSH
93284: LD_INT 105
93286: PUSH
93287: LD_INT 106
93289: PUSH
93290: LD_INT 107
93292: PUSH
93293: LD_INT 108
93295: PUSH
93296: LD_INT 109
93298: PUSH
93299: LD_INT 110
93301: PUSH
93302: LD_INT 111
93304: PUSH
93305: LD_INT 112
93307: PUSH
93308: LD_INT 114
93310: PUSH
93311: LD_INT 116
93313: PUSH
93314: LD_INT 117
93316: PUSH
93317: LD_INT 118
93319: PUSH
93320: EMPTY
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: ST_TO_ADDR
93342: GO 95025
93344: LD_INT 12
93346: DOUBLE
93347: EQUAL
93348: IFTRUE 93352
93350: GO 93572
93352: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93353: LD_ADDR_VAR 0 2
93357: PUSH
93358: LD_INT 1
93360: PUSH
93361: LD_INT 2
93363: PUSH
93364: LD_INT 3
93366: PUSH
93367: LD_INT 4
93369: PUSH
93370: LD_INT 5
93372: PUSH
93373: LD_INT 6
93375: PUSH
93376: LD_INT 7
93378: PUSH
93379: LD_INT 8
93381: PUSH
93382: LD_INT 9
93384: PUSH
93385: LD_INT 10
93387: PUSH
93388: LD_INT 11
93390: PUSH
93391: LD_INT 12
93393: PUSH
93394: LD_INT 13
93396: PUSH
93397: LD_INT 14
93399: PUSH
93400: LD_INT 15
93402: PUSH
93403: LD_INT 16
93405: PUSH
93406: LD_INT 17
93408: PUSH
93409: LD_INT 18
93411: PUSH
93412: LD_INT 19
93414: PUSH
93415: LD_INT 20
93417: PUSH
93418: LD_INT 21
93420: PUSH
93421: LD_INT 22
93423: PUSH
93424: LD_INT 23
93426: PUSH
93427: LD_INT 24
93429: PUSH
93430: LD_INT 25
93432: PUSH
93433: LD_INT 26
93435: PUSH
93436: LD_INT 27
93438: PUSH
93439: LD_INT 28
93441: PUSH
93442: LD_INT 30
93444: PUSH
93445: LD_INT 31
93447: PUSH
93448: LD_INT 32
93450: PUSH
93451: LD_INT 33
93453: PUSH
93454: LD_INT 34
93456: PUSH
93457: LD_INT 36
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: PUSH
93496: LD_INT 101
93498: PUSH
93499: LD_INT 102
93501: PUSH
93502: LD_INT 103
93504: PUSH
93505: LD_INT 104
93507: PUSH
93508: LD_INT 105
93510: PUSH
93511: LD_INT 106
93513: PUSH
93514: LD_INT 107
93516: PUSH
93517: LD_INT 108
93519: PUSH
93520: LD_INT 109
93522: PUSH
93523: LD_INT 110
93525: PUSH
93526: LD_INT 111
93528: PUSH
93529: LD_INT 112
93531: PUSH
93532: LD_INT 113
93534: PUSH
93535: LD_INT 114
93537: PUSH
93538: LD_INT 116
93540: PUSH
93541: LD_INT 117
93543: PUSH
93544: LD_INT 118
93546: PUSH
93547: EMPTY
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: ST_TO_ADDR
93570: GO 95025
93572: LD_INT 13
93574: DOUBLE
93575: EQUAL
93576: IFTRUE 93580
93578: GO 93788
93580: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
93581: LD_ADDR_VAR 0 2
93585: PUSH
93586: LD_INT 1
93588: PUSH
93589: LD_INT 2
93591: PUSH
93592: LD_INT 3
93594: PUSH
93595: LD_INT 4
93597: PUSH
93598: LD_INT 5
93600: PUSH
93601: LD_INT 8
93603: PUSH
93604: LD_INT 9
93606: PUSH
93607: LD_INT 10
93609: PUSH
93610: LD_INT 11
93612: PUSH
93613: LD_INT 12
93615: PUSH
93616: LD_INT 14
93618: PUSH
93619: LD_INT 15
93621: PUSH
93622: LD_INT 16
93624: PUSH
93625: LD_INT 17
93627: PUSH
93628: LD_INT 18
93630: PUSH
93631: LD_INT 19
93633: PUSH
93634: LD_INT 20
93636: PUSH
93637: LD_INT 21
93639: PUSH
93640: LD_INT 22
93642: PUSH
93643: LD_INT 23
93645: PUSH
93646: LD_INT 24
93648: PUSH
93649: LD_INT 25
93651: PUSH
93652: LD_INT 26
93654: PUSH
93655: LD_INT 27
93657: PUSH
93658: LD_INT 28
93660: PUSH
93661: LD_INT 30
93663: PUSH
93664: LD_INT 31
93666: PUSH
93667: LD_INT 32
93669: PUSH
93670: LD_INT 33
93672: PUSH
93673: LD_INT 34
93675: PUSH
93676: LD_INT 36
93678: PUSH
93679: EMPTY
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: PUSH
93712: LD_INT 101
93714: PUSH
93715: LD_INT 102
93717: PUSH
93718: LD_INT 103
93720: PUSH
93721: LD_INT 104
93723: PUSH
93724: LD_INT 105
93726: PUSH
93727: LD_INT 106
93729: PUSH
93730: LD_INT 107
93732: PUSH
93733: LD_INT 108
93735: PUSH
93736: LD_INT 109
93738: PUSH
93739: LD_INT 110
93741: PUSH
93742: LD_INT 111
93744: PUSH
93745: LD_INT 112
93747: PUSH
93748: LD_INT 113
93750: PUSH
93751: LD_INT 114
93753: PUSH
93754: LD_INT 116
93756: PUSH
93757: LD_INT 117
93759: PUSH
93760: LD_INT 118
93762: PUSH
93763: EMPTY
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: ST_TO_ADDR
93786: GO 95025
93788: LD_INT 14
93790: DOUBLE
93791: EQUAL
93792: IFTRUE 93796
93794: GO 94020
93796: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
93797: LD_ADDR_VAR 0 2
93801: PUSH
93802: LD_INT 1
93804: PUSH
93805: LD_INT 2
93807: PUSH
93808: LD_INT 3
93810: PUSH
93811: LD_INT 4
93813: PUSH
93814: LD_INT 5
93816: PUSH
93817: LD_INT 6
93819: PUSH
93820: LD_INT 7
93822: PUSH
93823: LD_INT 8
93825: PUSH
93826: LD_INT 9
93828: PUSH
93829: LD_INT 10
93831: PUSH
93832: LD_INT 11
93834: PUSH
93835: LD_INT 12
93837: PUSH
93838: LD_INT 13
93840: PUSH
93841: LD_INT 14
93843: PUSH
93844: LD_INT 15
93846: PUSH
93847: LD_INT 16
93849: PUSH
93850: LD_INT 17
93852: PUSH
93853: LD_INT 18
93855: PUSH
93856: LD_INT 19
93858: PUSH
93859: LD_INT 20
93861: PUSH
93862: LD_INT 21
93864: PUSH
93865: LD_INT 22
93867: PUSH
93868: LD_INT 23
93870: PUSH
93871: LD_INT 24
93873: PUSH
93874: LD_INT 25
93876: PUSH
93877: LD_INT 26
93879: PUSH
93880: LD_INT 27
93882: PUSH
93883: LD_INT 28
93885: PUSH
93886: LD_INT 29
93888: PUSH
93889: LD_INT 30
93891: PUSH
93892: LD_INT 31
93894: PUSH
93895: LD_INT 32
93897: PUSH
93898: LD_INT 33
93900: PUSH
93901: LD_INT 34
93903: PUSH
93904: LD_INT 36
93906: PUSH
93907: EMPTY
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: PUSH
93944: LD_INT 101
93946: PUSH
93947: LD_INT 102
93949: PUSH
93950: LD_INT 103
93952: PUSH
93953: LD_INT 104
93955: PUSH
93956: LD_INT 105
93958: PUSH
93959: LD_INT 106
93961: PUSH
93962: LD_INT 107
93964: PUSH
93965: LD_INT 108
93967: PUSH
93968: LD_INT 109
93970: PUSH
93971: LD_INT 110
93973: PUSH
93974: LD_INT 111
93976: PUSH
93977: LD_INT 112
93979: PUSH
93980: LD_INT 113
93982: PUSH
93983: LD_INT 114
93985: PUSH
93986: LD_INT 116
93988: PUSH
93989: LD_INT 117
93991: PUSH
93992: LD_INT 118
93994: PUSH
93995: EMPTY
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: ST_TO_ADDR
94018: GO 95025
94020: LD_INT 15
94022: DOUBLE
94023: EQUAL
94024: IFTRUE 94028
94026: GO 94252
94028: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
94029: LD_ADDR_VAR 0 2
94033: PUSH
94034: LD_INT 1
94036: PUSH
94037: LD_INT 2
94039: PUSH
94040: LD_INT 3
94042: PUSH
94043: LD_INT 4
94045: PUSH
94046: LD_INT 5
94048: PUSH
94049: LD_INT 6
94051: PUSH
94052: LD_INT 7
94054: PUSH
94055: LD_INT 8
94057: PUSH
94058: LD_INT 9
94060: PUSH
94061: LD_INT 10
94063: PUSH
94064: LD_INT 11
94066: PUSH
94067: LD_INT 12
94069: PUSH
94070: LD_INT 13
94072: PUSH
94073: LD_INT 14
94075: PUSH
94076: LD_INT 15
94078: PUSH
94079: LD_INT 16
94081: PUSH
94082: LD_INT 17
94084: PUSH
94085: LD_INT 18
94087: PUSH
94088: LD_INT 19
94090: PUSH
94091: LD_INT 20
94093: PUSH
94094: LD_INT 21
94096: PUSH
94097: LD_INT 22
94099: PUSH
94100: LD_INT 23
94102: PUSH
94103: LD_INT 24
94105: PUSH
94106: LD_INT 25
94108: PUSH
94109: LD_INT 26
94111: PUSH
94112: LD_INT 27
94114: PUSH
94115: LD_INT 28
94117: PUSH
94118: LD_INT 29
94120: PUSH
94121: LD_INT 30
94123: PUSH
94124: LD_INT 31
94126: PUSH
94127: LD_INT 32
94129: PUSH
94130: LD_INT 33
94132: PUSH
94133: LD_INT 34
94135: PUSH
94136: LD_INT 36
94138: PUSH
94139: EMPTY
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: LIST
94157: LIST
94158: LIST
94159: LIST
94160: LIST
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: PUSH
94176: LD_INT 101
94178: PUSH
94179: LD_INT 102
94181: PUSH
94182: LD_INT 103
94184: PUSH
94185: LD_INT 104
94187: PUSH
94188: LD_INT 105
94190: PUSH
94191: LD_INT 106
94193: PUSH
94194: LD_INT 107
94196: PUSH
94197: LD_INT 108
94199: PUSH
94200: LD_INT 109
94202: PUSH
94203: LD_INT 110
94205: PUSH
94206: LD_INT 111
94208: PUSH
94209: LD_INT 112
94211: PUSH
94212: LD_INT 113
94214: PUSH
94215: LD_INT 114
94217: PUSH
94218: LD_INT 116
94220: PUSH
94221: LD_INT 117
94223: PUSH
94224: LD_INT 118
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: LIST
94234: LIST
94235: LIST
94236: LIST
94237: LIST
94238: LIST
94239: LIST
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: LIST
94245: PUSH
94246: EMPTY
94247: LIST
94248: LIST
94249: ST_TO_ADDR
94250: GO 95025
94252: LD_INT 16
94254: DOUBLE
94255: EQUAL
94256: IFTRUE 94260
94258: GO 94396
94260: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94261: LD_ADDR_VAR 0 2
94265: PUSH
94266: LD_INT 2
94268: PUSH
94269: LD_INT 4
94271: PUSH
94272: LD_INT 5
94274: PUSH
94275: LD_INT 7
94277: PUSH
94278: LD_INT 11
94280: PUSH
94281: LD_INT 12
94283: PUSH
94284: LD_INT 15
94286: PUSH
94287: LD_INT 16
94289: PUSH
94290: LD_INT 20
94292: PUSH
94293: LD_INT 21
94295: PUSH
94296: LD_INT 22
94298: PUSH
94299: LD_INT 23
94301: PUSH
94302: LD_INT 25
94304: PUSH
94305: LD_INT 26
94307: PUSH
94308: LD_INT 30
94310: PUSH
94311: LD_INT 31
94313: PUSH
94314: LD_INT 32
94316: PUSH
94317: LD_INT 33
94319: PUSH
94320: LD_INT 34
94322: PUSH
94323: EMPTY
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: PUSH
94344: LD_INT 101
94346: PUSH
94347: LD_INT 102
94349: PUSH
94350: LD_INT 103
94352: PUSH
94353: LD_INT 106
94355: PUSH
94356: LD_INT 108
94358: PUSH
94359: LD_INT 112
94361: PUSH
94362: LD_INT 113
94364: PUSH
94365: LD_INT 114
94367: PUSH
94368: LD_INT 116
94370: PUSH
94371: LD_INT 117
94373: PUSH
94374: LD_INT 118
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: PUSH
94390: EMPTY
94391: LIST
94392: LIST
94393: ST_TO_ADDR
94394: GO 95025
94396: LD_INT 17
94398: DOUBLE
94399: EQUAL
94400: IFTRUE 94404
94402: GO 94628
94404: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
94405: LD_ADDR_VAR 0 2
94409: PUSH
94410: LD_INT 1
94412: PUSH
94413: LD_INT 2
94415: PUSH
94416: LD_INT 3
94418: PUSH
94419: LD_INT 4
94421: PUSH
94422: LD_INT 5
94424: PUSH
94425: LD_INT 6
94427: PUSH
94428: LD_INT 7
94430: PUSH
94431: LD_INT 8
94433: PUSH
94434: LD_INT 9
94436: PUSH
94437: LD_INT 10
94439: PUSH
94440: LD_INT 11
94442: PUSH
94443: LD_INT 12
94445: PUSH
94446: LD_INT 13
94448: PUSH
94449: LD_INT 14
94451: PUSH
94452: LD_INT 15
94454: PUSH
94455: LD_INT 16
94457: PUSH
94458: LD_INT 17
94460: PUSH
94461: LD_INT 18
94463: PUSH
94464: LD_INT 19
94466: PUSH
94467: LD_INT 20
94469: PUSH
94470: LD_INT 21
94472: PUSH
94473: LD_INT 22
94475: PUSH
94476: LD_INT 23
94478: PUSH
94479: LD_INT 24
94481: PUSH
94482: LD_INT 25
94484: PUSH
94485: LD_INT 26
94487: PUSH
94488: LD_INT 27
94490: PUSH
94491: LD_INT 28
94493: PUSH
94494: LD_INT 29
94496: PUSH
94497: LD_INT 30
94499: PUSH
94500: LD_INT 31
94502: PUSH
94503: LD_INT 32
94505: PUSH
94506: LD_INT 33
94508: PUSH
94509: LD_INT 34
94511: PUSH
94512: LD_INT 36
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: PUSH
94552: LD_INT 101
94554: PUSH
94555: LD_INT 102
94557: PUSH
94558: LD_INT 103
94560: PUSH
94561: LD_INT 104
94563: PUSH
94564: LD_INT 105
94566: PUSH
94567: LD_INT 106
94569: PUSH
94570: LD_INT 107
94572: PUSH
94573: LD_INT 108
94575: PUSH
94576: LD_INT 109
94578: PUSH
94579: LD_INT 110
94581: PUSH
94582: LD_INT 111
94584: PUSH
94585: LD_INT 112
94587: PUSH
94588: LD_INT 113
94590: PUSH
94591: LD_INT 114
94593: PUSH
94594: LD_INT 116
94596: PUSH
94597: LD_INT 117
94599: PUSH
94600: LD_INT 118
94602: PUSH
94603: EMPTY
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: PUSH
94622: EMPTY
94623: LIST
94624: LIST
94625: ST_TO_ADDR
94626: GO 95025
94628: LD_INT 18
94630: DOUBLE
94631: EQUAL
94632: IFTRUE 94636
94634: GO 94784
94636: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
94637: LD_ADDR_VAR 0 2
94641: PUSH
94642: LD_INT 2
94644: PUSH
94645: LD_INT 4
94647: PUSH
94648: LD_INT 5
94650: PUSH
94651: LD_INT 7
94653: PUSH
94654: LD_INT 11
94656: PUSH
94657: LD_INT 12
94659: PUSH
94660: LD_INT 15
94662: PUSH
94663: LD_INT 16
94665: PUSH
94666: LD_INT 20
94668: PUSH
94669: LD_INT 21
94671: PUSH
94672: LD_INT 22
94674: PUSH
94675: LD_INT 23
94677: PUSH
94678: LD_INT 25
94680: PUSH
94681: LD_INT 26
94683: PUSH
94684: LD_INT 30
94686: PUSH
94687: LD_INT 31
94689: PUSH
94690: LD_INT 32
94692: PUSH
94693: LD_INT 33
94695: PUSH
94696: LD_INT 34
94698: PUSH
94699: LD_INT 35
94701: PUSH
94702: LD_INT 36
94704: PUSH
94705: EMPTY
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: LIST
94713: LIST
94714: LIST
94715: LIST
94716: LIST
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 101
94730: PUSH
94731: LD_INT 102
94733: PUSH
94734: LD_INT 103
94736: PUSH
94737: LD_INT 106
94739: PUSH
94740: LD_INT 108
94742: PUSH
94743: LD_INT 112
94745: PUSH
94746: LD_INT 113
94748: PUSH
94749: LD_INT 114
94751: PUSH
94752: LD_INT 115
94754: PUSH
94755: LD_INT 116
94757: PUSH
94758: LD_INT 117
94760: PUSH
94761: LD_INT 118
94763: PUSH
94764: EMPTY
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: PUSH
94778: EMPTY
94779: LIST
94780: LIST
94781: ST_TO_ADDR
94782: GO 95025
94784: LD_INT 19
94786: DOUBLE
94787: EQUAL
94788: IFTRUE 94792
94790: GO 95024
94792: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
94793: LD_ADDR_VAR 0 2
94797: PUSH
94798: LD_INT 1
94800: PUSH
94801: LD_INT 2
94803: PUSH
94804: LD_INT 3
94806: PUSH
94807: LD_INT 4
94809: PUSH
94810: LD_INT 5
94812: PUSH
94813: LD_INT 6
94815: PUSH
94816: LD_INT 7
94818: PUSH
94819: LD_INT 8
94821: PUSH
94822: LD_INT 9
94824: PUSH
94825: LD_INT 10
94827: PUSH
94828: LD_INT 11
94830: PUSH
94831: LD_INT 12
94833: PUSH
94834: LD_INT 13
94836: PUSH
94837: LD_INT 14
94839: PUSH
94840: LD_INT 15
94842: PUSH
94843: LD_INT 16
94845: PUSH
94846: LD_INT 17
94848: PUSH
94849: LD_INT 18
94851: PUSH
94852: LD_INT 19
94854: PUSH
94855: LD_INT 20
94857: PUSH
94858: LD_INT 21
94860: PUSH
94861: LD_INT 22
94863: PUSH
94864: LD_INT 23
94866: PUSH
94867: LD_INT 24
94869: PUSH
94870: LD_INT 25
94872: PUSH
94873: LD_INT 26
94875: PUSH
94876: LD_INT 27
94878: PUSH
94879: LD_INT 28
94881: PUSH
94882: LD_INT 29
94884: PUSH
94885: LD_INT 30
94887: PUSH
94888: LD_INT 31
94890: PUSH
94891: LD_INT 32
94893: PUSH
94894: LD_INT 33
94896: PUSH
94897: LD_INT 34
94899: PUSH
94900: LD_INT 35
94902: PUSH
94903: LD_INT 36
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: LIST
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: PUSH
94944: LD_INT 101
94946: PUSH
94947: LD_INT 102
94949: PUSH
94950: LD_INT 103
94952: PUSH
94953: LD_INT 104
94955: PUSH
94956: LD_INT 105
94958: PUSH
94959: LD_INT 106
94961: PUSH
94962: LD_INT 107
94964: PUSH
94965: LD_INT 108
94967: PUSH
94968: LD_INT 109
94970: PUSH
94971: LD_INT 110
94973: PUSH
94974: LD_INT 111
94976: PUSH
94977: LD_INT 112
94979: PUSH
94980: LD_INT 113
94982: PUSH
94983: LD_INT 114
94985: PUSH
94986: LD_INT 115
94988: PUSH
94989: LD_INT 116
94991: PUSH
94992: LD_INT 117
94994: PUSH
94995: LD_INT 118
94997: PUSH
94998: EMPTY
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: ST_TO_ADDR
95022: GO 95025
95024: POP
// end else
95025: GO 95256
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
95027: LD_ADDR_VAR 0 2
95031: PUSH
95032: LD_INT 1
95034: PUSH
95035: LD_INT 2
95037: PUSH
95038: LD_INT 3
95040: PUSH
95041: LD_INT 4
95043: PUSH
95044: LD_INT 5
95046: PUSH
95047: LD_INT 6
95049: PUSH
95050: LD_INT 7
95052: PUSH
95053: LD_INT 8
95055: PUSH
95056: LD_INT 9
95058: PUSH
95059: LD_INT 10
95061: PUSH
95062: LD_INT 11
95064: PUSH
95065: LD_INT 12
95067: PUSH
95068: LD_INT 13
95070: PUSH
95071: LD_INT 14
95073: PUSH
95074: LD_INT 15
95076: PUSH
95077: LD_INT 16
95079: PUSH
95080: LD_INT 17
95082: PUSH
95083: LD_INT 18
95085: PUSH
95086: LD_INT 19
95088: PUSH
95089: LD_INT 20
95091: PUSH
95092: LD_INT 21
95094: PUSH
95095: LD_INT 22
95097: PUSH
95098: LD_INT 23
95100: PUSH
95101: LD_INT 24
95103: PUSH
95104: LD_INT 25
95106: PUSH
95107: LD_INT 26
95109: PUSH
95110: LD_INT 27
95112: PUSH
95113: LD_INT 28
95115: PUSH
95116: LD_INT 29
95118: PUSH
95119: LD_INT 30
95121: PUSH
95122: LD_INT 31
95124: PUSH
95125: LD_INT 32
95127: PUSH
95128: LD_INT 33
95130: PUSH
95131: LD_INT 34
95133: PUSH
95134: LD_INT 35
95136: PUSH
95137: LD_INT 36
95139: PUSH
95140: EMPTY
95141: LIST
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: LIST
95163: LIST
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: PUSH
95178: LD_INT 101
95180: PUSH
95181: LD_INT 102
95183: PUSH
95184: LD_INT 103
95186: PUSH
95187: LD_INT 104
95189: PUSH
95190: LD_INT 105
95192: PUSH
95193: LD_INT 106
95195: PUSH
95196: LD_INT 107
95198: PUSH
95199: LD_INT 108
95201: PUSH
95202: LD_INT 109
95204: PUSH
95205: LD_INT 110
95207: PUSH
95208: LD_INT 111
95210: PUSH
95211: LD_INT 112
95213: PUSH
95214: LD_INT 113
95216: PUSH
95217: LD_INT 114
95219: PUSH
95220: LD_INT 115
95222: PUSH
95223: LD_INT 116
95225: PUSH
95226: LD_INT 117
95228: PUSH
95229: LD_INT 118
95231: PUSH
95232: EMPTY
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: PUSH
95252: EMPTY
95253: LIST
95254: LIST
95255: ST_TO_ADDR
// if result then
95256: LD_VAR 0 2
95260: IFFALSE 96046
// begin normal :=  ;
95262: LD_ADDR_VAR 0 5
95266: PUSH
95267: LD_STRING 
95269: ST_TO_ADDR
// hardcore :=  ;
95270: LD_ADDR_VAR 0 6
95274: PUSH
95275: LD_STRING 
95277: ST_TO_ADDR
// active :=  ;
95278: LD_ADDR_VAR 0 7
95282: PUSH
95283: LD_STRING 
95285: ST_TO_ADDR
// for i = 1 to normalCounter do
95286: LD_ADDR_VAR 0 8
95290: PUSH
95291: DOUBLE
95292: LD_INT 1
95294: DEC
95295: ST_TO_ADDR
95296: LD_EXP 109
95300: PUSH
95301: FOR_TO
95302: IFFALSE 95403
// begin tmp := 0 ;
95304: LD_ADDR_VAR 0 3
95308: PUSH
95309: LD_STRING 0
95311: ST_TO_ADDR
// if result [ 1 ] then
95312: LD_VAR 0 2
95316: PUSH
95317: LD_INT 1
95319: ARRAY
95320: IFFALSE 95385
// if result [ 1 ] [ 1 ] = i then
95322: LD_VAR 0 2
95326: PUSH
95327: LD_INT 1
95329: ARRAY
95330: PUSH
95331: LD_INT 1
95333: ARRAY
95334: PUSH
95335: LD_VAR 0 8
95339: EQUAL
95340: IFFALSE 95385
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95342: LD_ADDR_VAR 0 2
95346: PUSH
95347: LD_VAR 0 2
95351: PPUSH
95352: LD_INT 1
95354: PPUSH
95355: LD_VAR 0 2
95359: PUSH
95360: LD_INT 1
95362: ARRAY
95363: PPUSH
95364: LD_INT 1
95366: PPUSH
95367: CALL_OW 3
95371: PPUSH
95372: CALL_OW 1
95376: ST_TO_ADDR
// tmp := 1 ;
95377: LD_ADDR_VAR 0 3
95381: PUSH
95382: LD_STRING 1
95384: ST_TO_ADDR
// end ; normal := normal & tmp ;
95385: LD_ADDR_VAR 0 5
95389: PUSH
95390: LD_VAR 0 5
95394: PUSH
95395: LD_VAR 0 3
95399: STR
95400: ST_TO_ADDR
// end ;
95401: GO 95301
95403: POP
95404: POP
// for i = 1 to hardcoreCounter do
95405: LD_ADDR_VAR 0 8
95409: PUSH
95410: DOUBLE
95411: LD_INT 1
95413: DEC
95414: ST_TO_ADDR
95415: LD_EXP 110
95419: PUSH
95420: FOR_TO
95421: IFFALSE 95526
// begin tmp := 0 ;
95423: LD_ADDR_VAR 0 3
95427: PUSH
95428: LD_STRING 0
95430: ST_TO_ADDR
// if result [ 2 ] then
95431: LD_VAR 0 2
95435: PUSH
95436: LD_INT 2
95438: ARRAY
95439: IFFALSE 95508
// if result [ 2 ] [ 1 ] = 100 + i then
95441: LD_VAR 0 2
95445: PUSH
95446: LD_INT 2
95448: ARRAY
95449: PUSH
95450: LD_INT 1
95452: ARRAY
95453: PUSH
95454: LD_INT 100
95456: PUSH
95457: LD_VAR 0 8
95461: PLUS
95462: EQUAL
95463: IFFALSE 95508
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95465: LD_ADDR_VAR 0 2
95469: PUSH
95470: LD_VAR 0 2
95474: PPUSH
95475: LD_INT 2
95477: PPUSH
95478: LD_VAR 0 2
95482: PUSH
95483: LD_INT 2
95485: ARRAY
95486: PPUSH
95487: LD_INT 1
95489: PPUSH
95490: CALL_OW 3
95494: PPUSH
95495: CALL_OW 1
95499: ST_TO_ADDR
// tmp := 1 ;
95500: LD_ADDR_VAR 0 3
95504: PUSH
95505: LD_STRING 1
95507: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95508: LD_ADDR_VAR 0 6
95512: PUSH
95513: LD_VAR 0 6
95517: PUSH
95518: LD_VAR 0 3
95522: STR
95523: ST_TO_ADDR
// end ;
95524: GO 95420
95526: POP
95527: POP
// if isGameLoad then
95528: LD_VAR 0 1
95532: IFFALSE 96007
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95534: LD_ADDR_VAR 0 4
95538: PUSH
95539: LD_EXP 113
95543: PUSH
95544: LD_EXP 112
95548: PUSH
95549: LD_EXP 114
95553: PUSH
95554: LD_EXP 111
95558: PUSH
95559: LD_EXP 115
95563: PUSH
95564: LD_EXP 116
95568: PUSH
95569: LD_EXP 117
95573: PUSH
95574: LD_EXP 118
95578: PUSH
95579: LD_EXP 119
95583: PUSH
95584: LD_EXP 120
95588: PUSH
95589: LD_EXP 121
95593: PUSH
95594: LD_EXP 122
95598: PUSH
95599: LD_EXP 123
95603: PUSH
95604: LD_EXP 124
95608: PUSH
95609: LD_EXP 132
95613: PUSH
95614: LD_EXP 133
95618: PUSH
95619: LD_EXP 134
95623: PUSH
95624: LD_EXP 135
95628: PUSH
95629: LD_EXP 137
95633: PUSH
95634: LD_EXP 138
95638: PUSH
95639: LD_EXP 139
95643: PUSH
95644: LD_EXP 142
95648: PUSH
95649: LD_EXP 144
95653: PUSH
95654: LD_EXP 145
95658: PUSH
95659: LD_EXP 146
95663: PUSH
95664: LD_EXP 148
95668: PUSH
95669: LD_EXP 149
95673: PUSH
95674: LD_EXP 152
95678: PUSH
95679: LD_EXP 153
95683: PUSH
95684: LD_EXP 154
95688: PUSH
95689: LD_EXP 155
95693: PUSH
95694: LD_EXP 156
95698: PUSH
95699: LD_EXP 157
95703: PUSH
95704: LD_EXP 158
95708: PUSH
95709: LD_EXP 159
95713: PUSH
95714: LD_EXP 160
95718: PUSH
95719: LD_EXP 125
95723: PUSH
95724: LD_EXP 126
95728: PUSH
95729: LD_EXP 129
95733: PUSH
95734: LD_EXP 130
95738: PUSH
95739: LD_EXP 131
95743: PUSH
95744: LD_EXP 127
95748: PUSH
95749: LD_EXP 128
95753: PUSH
95754: LD_EXP 136
95758: PUSH
95759: LD_EXP 140
95763: PUSH
95764: LD_EXP 141
95768: PUSH
95769: LD_EXP 143
95773: PUSH
95774: LD_EXP 147
95778: PUSH
95779: LD_EXP 150
95783: PUSH
95784: LD_EXP 151
95788: PUSH
95789: LD_EXP 161
95793: PUSH
95794: LD_EXP 162
95798: PUSH
95799: LD_EXP 163
95803: PUSH
95804: LD_EXP 164
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: LIST
95813: LIST
95814: LIST
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: LIST
95835: LIST
95836: LIST
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: LIST
95863: LIST
95864: ST_TO_ADDR
// tmp :=  ;
95865: LD_ADDR_VAR 0 3
95869: PUSH
95870: LD_STRING 
95872: ST_TO_ADDR
// for i = 1 to normalCounter do
95873: LD_ADDR_VAR 0 8
95877: PUSH
95878: DOUBLE
95879: LD_INT 1
95881: DEC
95882: ST_TO_ADDR
95883: LD_EXP 109
95887: PUSH
95888: FOR_TO
95889: IFFALSE 95925
// begin if flags [ i ] then
95891: LD_VAR 0 4
95895: PUSH
95896: LD_VAR 0 8
95900: ARRAY
95901: IFFALSE 95923
// tmp := tmp & i & ; ;
95903: LD_ADDR_VAR 0 3
95907: PUSH
95908: LD_VAR 0 3
95912: PUSH
95913: LD_VAR 0 8
95917: STR
95918: PUSH
95919: LD_STRING ;
95921: STR
95922: ST_TO_ADDR
// end ;
95923: GO 95888
95925: POP
95926: POP
// for i = 1 to hardcoreCounter do
95927: LD_ADDR_VAR 0 8
95931: PUSH
95932: DOUBLE
95933: LD_INT 1
95935: DEC
95936: ST_TO_ADDR
95937: LD_EXP 110
95941: PUSH
95942: FOR_TO
95943: IFFALSE 95989
// begin if flags [ normalCounter + i ] then
95945: LD_VAR 0 4
95949: PUSH
95950: LD_EXP 109
95954: PUSH
95955: LD_VAR 0 8
95959: PLUS
95960: ARRAY
95961: IFFALSE 95987
// tmp := tmp & ( 100 + i ) & ; ;
95963: LD_ADDR_VAR 0 3
95967: PUSH
95968: LD_VAR 0 3
95972: PUSH
95973: LD_INT 100
95975: PUSH
95976: LD_VAR 0 8
95980: PLUS
95981: STR
95982: PUSH
95983: LD_STRING ;
95985: STR
95986: ST_TO_ADDR
// end ;
95987: GO 95942
95989: POP
95990: POP
// if tmp then
95991: LD_VAR 0 3
95995: IFFALSE 96007
// active := tmp ;
95997: LD_ADDR_VAR 0 7
96001: PUSH
96002: LD_VAR 0 3
96006: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
96007: LD_STRING getStreamItemsFromMission("
96009: PUSH
96010: LD_VAR 0 5
96014: STR
96015: PUSH
96016: LD_STRING ","
96018: STR
96019: PUSH
96020: LD_VAR 0 6
96024: STR
96025: PUSH
96026: LD_STRING ","
96028: STR
96029: PUSH
96030: LD_VAR 0 7
96034: STR
96035: PUSH
96036: LD_STRING ")
96038: STR
96039: PPUSH
96040: CALL_OW 559
// end else
96044: GO 96053
// ToLua ( getStreamItemsFromMission("","","") ) ;
96046: LD_STRING getStreamItemsFromMission("","","")
96048: PPUSH
96049: CALL_OW 559
// end ;
96053: LD_VAR 0 2
96057: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96058: LD_EXP 108
96062: PUSH
96063: LD_EXP 113
96067: AND
96068: IFFALSE 96192
96070: GO 96072
96072: DISABLE
96073: LD_INT 0
96075: PPUSH
96076: PPUSH
// begin enable ;
96077: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96078: LD_ADDR_VAR 0 2
96082: PUSH
96083: LD_INT 22
96085: PUSH
96086: LD_OWVAR 2
96090: PUSH
96091: EMPTY
96092: LIST
96093: LIST
96094: PUSH
96095: LD_INT 2
96097: PUSH
96098: LD_INT 34
96100: PUSH
96101: LD_INT 7
96103: PUSH
96104: EMPTY
96105: LIST
96106: LIST
96107: PUSH
96108: LD_INT 34
96110: PUSH
96111: LD_INT 45
96113: PUSH
96114: EMPTY
96115: LIST
96116: LIST
96117: PUSH
96118: LD_INT 34
96120: PUSH
96121: LD_INT 28
96123: PUSH
96124: EMPTY
96125: LIST
96126: LIST
96127: PUSH
96128: LD_INT 34
96130: PUSH
96131: LD_INT 47
96133: PUSH
96134: EMPTY
96135: LIST
96136: LIST
96137: PUSH
96138: EMPTY
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: PUSH
96145: EMPTY
96146: LIST
96147: LIST
96148: PPUSH
96149: CALL_OW 69
96153: ST_TO_ADDR
// if not tmp then
96154: LD_VAR 0 2
96158: NOT
96159: IFFALSE 96163
// exit ;
96161: GO 96192
// for i in tmp do
96163: LD_ADDR_VAR 0 1
96167: PUSH
96168: LD_VAR 0 2
96172: PUSH
96173: FOR_IN
96174: IFFALSE 96190
// begin SetLives ( i , 0 ) ;
96176: LD_VAR 0 1
96180: PPUSH
96181: LD_INT 0
96183: PPUSH
96184: CALL_OW 234
// end ;
96188: GO 96173
96190: POP
96191: POP
// end ;
96192: PPOPN 2
96194: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96195: LD_EXP 108
96199: PUSH
96200: LD_EXP 114
96204: AND
96205: IFFALSE 96289
96207: GO 96209
96209: DISABLE
96210: LD_INT 0
96212: PPUSH
96213: PPUSH
// begin enable ;
96214: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96215: LD_ADDR_VAR 0 2
96219: PUSH
96220: LD_INT 22
96222: PUSH
96223: LD_OWVAR 2
96227: PUSH
96228: EMPTY
96229: LIST
96230: LIST
96231: PUSH
96232: LD_INT 32
96234: PUSH
96235: LD_INT 3
96237: PUSH
96238: EMPTY
96239: LIST
96240: LIST
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: PPUSH
96246: CALL_OW 69
96250: ST_TO_ADDR
// if not tmp then
96251: LD_VAR 0 2
96255: NOT
96256: IFFALSE 96260
// exit ;
96258: GO 96289
// for i in tmp do
96260: LD_ADDR_VAR 0 1
96264: PUSH
96265: LD_VAR 0 2
96269: PUSH
96270: FOR_IN
96271: IFFALSE 96287
// begin SetLives ( i , 0 ) ;
96273: LD_VAR 0 1
96277: PPUSH
96278: LD_INT 0
96280: PPUSH
96281: CALL_OW 234
// end ;
96285: GO 96270
96287: POP
96288: POP
// end ;
96289: PPOPN 2
96291: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96292: LD_EXP 108
96296: PUSH
96297: LD_EXP 111
96301: AND
96302: IFFALSE 96395
96304: GO 96306
96306: DISABLE
96307: LD_INT 0
96309: PPUSH
// begin enable ;
96310: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96311: LD_ADDR_VAR 0 1
96315: PUSH
96316: LD_INT 22
96318: PUSH
96319: LD_OWVAR 2
96323: PUSH
96324: EMPTY
96325: LIST
96326: LIST
96327: PUSH
96328: LD_INT 2
96330: PUSH
96331: LD_INT 25
96333: PUSH
96334: LD_INT 5
96336: PUSH
96337: EMPTY
96338: LIST
96339: LIST
96340: PUSH
96341: LD_INT 25
96343: PUSH
96344: LD_INT 9
96346: PUSH
96347: EMPTY
96348: LIST
96349: LIST
96350: PUSH
96351: LD_INT 25
96353: PUSH
96354: LD_INT 8
96356: PUSH
96357: EMPTY
96358: LIST
96359: LIST
96360: PUSH
96361: EMPTY
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: PPUSH
96371: CALL_OW 69
96375: PUSH
96376: FOR_IN
96377: IFFALSE 96393
// begin SetClass ( i , 1 ) ;
96379: LD_VAR 0 1
96383: PPUSH
96384: LD_INT 1
96386: PPUSH
96387: CALL_OW 336
// end ;
96391: GO 96376
96393: POP
96394: POP
// end ;
96395: PPOPN 1
96397: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96398: LD_EXP 108
96402: PUSH
96403: LD_EXP 112
96407: AND
96408: PUSH
96409: LD_OWVAR 65
96413: PUSH
96414: LD_INT 7
96416: LESS
96417: AND
96418: IFFALSE 96432
96420: GO 96422
96422: DISABLE
// begin enable ;
96423: ENABLE
// game_speed := 7 ;
96424: LD_ADDR_OWVAR 65
96428: PUSH
96429: LD_INT 7
96431: ST_TO_ADDR
// end ;
96432: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96433: LD_EXP 108
96437: PUSH
96438: LD_EXP 115
96442: AND
96443: IFFALSE 96645
96445: GO 96447
96447: DISABLE
96448: LD_INT 0
96450: PPUSH
96451: PPUSH
96452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96453: LD_ADDR_VAR 0 3
96457: PUSH
96458: LD_INT 81
96460: PUSH
96461: LD_OWVAR 2
96465: PUSH
96466: EMPTY
96467: LIST
96468: LIST
96469: PUSH
96470: LD_INT 21
96472: PUSH
96473: LD_INT 1
96475: PUSH
96476: EMPTY
96477: LIST
96478: LIST
96479: PUSH
96480: EMPTY
96481: LIST
96482: LIST
96483: PPUSH
96484: CALL_OW 69
96488: ST_TO_ADDR
// if not tmp then
96489: LD_VAR 0 3
96493: NOT
96494: IFFALSE 96498
// exit ;
96496: GO 96645
// if tmp > 5 then
96498: LD_VAR 0 3
96502: PUSH
96503: LD_INT 5
96505: GREATER
96506: IFFALSE 96518
// k := 5 else
96508: LD_ADDR_VAR 0 2
96512: PUSH
96513: LD_INT 5
96515: ST_TO_ADDR
96516: GO 96528
// k := tmp ;
96518: LD_ADDR_VAR 0 2
96522: PUSH
96523: LD_VAR 0 3
96527: ST_TO_ADDR
// for i := 1 to k do
96528: LD_ADDR_VAR 0 1
96532: PUSH
96533: DOUBLE
96534: LD_INT 1
96536: DEC
96537: ST_TO_ADDR
96538: LD_VAR 0 2
96542: PUSH
96543: FOR_TO
96544: IFFALSE 96643
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96546: LD_VAR 0 3
96550: PUSH
96551: LD_VAR 0 1
96555: ARRAY
96556: PPUSH
96557: LD_VAR 0 1
96561: PUSH
96562: LD_INT 4
96564: MOD
96565: PUSH
96566: LD_INT 1
96568: PLUS
96569: PPUSH
96570: CALL_OW 259
96574: PUSH
96575: LD_INT 10
96577: LESS
96578: IFFALSE 96641
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96580: LD_VAR 0 3
96584: PUSH
96585: LD_VAR 0 1
96589: ARRAY
96590: PPUSH
96591: LD_VAR 0 1
96595: PUSH
96596: LD_INT 4
96598: MOD
96599: PUSH
96600: LD_INT 1
96602: PLUS
96603: PPUSH
96604: LD_VAR 0 3
96608: PUSH
96609: LD_VAR 0 1
96613: ARRAY
96614: PPUSH
96615: LD_VAR 0 1
96619: PUSH
96620: LD_INT 4
96622: MOD
96623: PUSH
96624: LD_INT 1
96626: PLUS
96627: PPUSH
96628: CALL_OW 259
96632: PUSH
96633: LD_INT 1
96635: PLUS
96636: PPUSH
96637: CALL_OW 237
96641: GO 96543
96643: POP
96644: POP
// end ;
96645: PPOPN 3
96647: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96648: LD_EXP 108
96652: PUSH
96653: LD_EXP 116
96657: AND
96658: IFFALSE 96678
96660: GO 96662
96662: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96663: LD_INT 4
96665: PPUSH
96666: LD_OWVAR 2
96670: PPUSH
96671: LD_INT 0
96673: PPUSH
96674: CALL_OW 324
96678: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96679: LD_EXP 108
96683: PUSH
96684: LD_EXP 145
96688: AND
96689: IFFALSE 96709
96691: GO 96693
96693: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96694: LD_INT 19
96696: PPUSH
96697: LD_OWVAR 2
96701: PPUSH
96702: LD_INT 0
96704: PPUSH
96705: CALL_OW 324
96709: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96710: LD_EXP 108
96714: PUSH
96715: LD_EXP 117
96719: AND
96720: IFFALSE 96822
96722: GO 96724
96724: DISABLE
96725: LD_INT 0
96727: PPUSH
96728: PPUSH
// begin enable ;
96729: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96730: LD_ADDR_VAR 0 2
96734: PUSH
96735: LD_INT 22
96737: PUSH
96738: LD_OWVAR 2
96742: PUSH
96743: EMPTY
96744: LIST
96745: LIST
96746: PUSH
96747: LD_INT 2
96749: PUSH
96750: LD_INT 34
96752: PUSH
96753: LD_INT 11
96755: PUSH
96756: EMPTY
96757: LIST
96758: LIST
96759: PUSH
96760: LD_INT 34
96762: PUSH
96763: LD_INT 30
96765: PUSH
96766: EMPTY
96767: LIST
96768: LIST
96769: PUSH
96770: EMPTY
96771: LIST
96772: LIST
96773: LIST
96774: PUSH
96775: EMPTY
96776: LIST
96777: LIST
96778: PPUSH
96779: CALL_OW 69
96783: ST_TO_ADDR
// if not tmp then
96784: LD_VAR 0 2
96788: NOT
96789: IFFALSE 96793
// exit ;
96791: GO 96822
// for i in tmp do
96793: LD_ADDR_VAR 0 1
96797: PUSH
96798: LD_VAR 0 2
96802: PUSH
96803: FOR_IN
96804: IFFALSE 96820
// begin SetLives ( i , 0 ) ;
96806: LD_VAR 0 1
96810: PPUSH
96811: LD_INT 0
96813: PPUSH
96814: CALL_OW 234
// end ;
96818: GO 96803
96820: POP
96821: POP
// end ;
96822: PPOPN 2
96824: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96825: LD_EXP 108
96829: PUSH
96830: LD_EXP 118
96834: AND
96835: IFFALSE 96855
96837: GO 96839
96839: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96840: LD_INT 32
96842: PPUSH
96843: LD_OWVAR 2
96847: PPUSH
96848: LD_INT 0
96850: PPUSH
96851: CALL_OW 324
96855: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96856: LD_EXP 108
96860: PUSH
96861: LD_EXP 119
96865: AND
96866: IFFALSE 97047
96868: GO 96870
96870: DISABLE
96871: LD_INT 0
96873: PPUSH
96874: PPUSH
96875: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96876: LD_ADDR_VAR 0 2
96880: PUSH
96881: LD_INT 22
96883: PUSH
96884: LD_OWVAR 2
96888: PUSH
96889: EMPTY
96890: LIST
96891: LIST
96892: PUSH
96893: LD_INT 33
96895: PUSH
96896: LD_INT 3
96898: PUSH
96899: EMPTY
96900: LIST
96901: LIST
96902: PUSH
96903: EMPTY
96904: LIST
96905: LIST
96906: PPUSH
96907: CALL_OW 69
96911: ST_TO_ADDR
// if not tmp then
96912: LD_VAR 0 2
96916: NOT
96917: IFFALSE 96921
// exit ;
96919: GO 97047
// side := 0 ;
96921: LD_ADDR_VAR 0 3
96925: PUSH
96926: LD_INT 0
96928: ST_TO_ADDR
// for i := 1 to 8 do
96929: LD_ADDR_VAR 0 1
96933: PUSH
96934: DOUBLE
96935: LD_INT 1
96937: DEC
96938: ST_TO_ADDR
96939: LD_INT 8
96941: PUSH
96942: FOR_TO
96943: IFFALSE 96991
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96945: LD_OWVAR 2
96949: PUSH
96950: LD_VAR 0 1
96954: NONEQUAL
96955: PUSH
96956: LD_OWVAR 2
96960: PPUSH
96961: LD_VAR 0 1
96965: PPUSH
96966: CALL_OW 81
96970: PUSH
96971: LD_INT 2
96973: EQUAL
96974: AND
96975: IFFALSE 96989
// begin side := i ;
96977: LD_ADDR_VAR 0 3
96981: PUSH
96982: LD_VAR 0 1
96986: ST_TO_ADDR
// break ;
96987: GO 96991
// end ;
96989: GO 96942
96991: POP
96992: POP
// if not side then
96993: LD_VAR 0 3
96997: NOT
96998: IFFALSE 97002
// exit ;
97000: GO 97047
// for i := 1 to tmp do
97002: LD_ADDR_VAR 0 1
97006: PUSH
97007: DOUBLE
97008: LD_INT 1
97010: DEC
97011: ST_TO_ADDR
97012: LD_VAR 0 2
97016: PUSH
97017: FOR_TO
97018: IFFALSE 97045
// if Prob ( 60 ) then
97020: LD_INT 60
97022: PPUSH
97023: CALL_OW 13
97027: IFFALSE 97043
// SetSide ( i , side ) ;
97029: LD_VAR 0 1
97033: PPUSH
97034: LD_VAR 0 3
97038: PPUSH
97039: CALL_OW 235
97043: GO 97017
97045: POP
97046: POP
// end ;
97047: PPOPN 3
97049: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97050: LD_EXP 108
97054: PUSH
97055: LD_EXP 121
97059: AND
97060: IFFALSE 97179
97062: GO 97064
97064: DISABLE
97065: LD_INT 0
97067: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97068: LD_ADDR_VAR 0 1
97072: PUSH
97073: LD_INT 22
97075: PUSH
97076: LD_OWVAR 2
97080: PUSH
97081: EMPTY
97082: LIST
97083: LIST
97084: PUSH
97085: LD_INT 21
97087: PUSH
97088: LD_INT 1
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 3
97097: PUSH
97098: LD_INT 23
97100: PUSH
97101: LD_INT 0
97103: PUSH
97104: EMPTY
97105: LIST
97106: LIST
97107: PUSH
97108: EMPTY
97109: LIST
97110: LIST
97111: PUSH
97112: EMPTY
97113: LIST
97114: LIST
97115: LIST
97116: PPUSH
97117: CALL_OW 69
97121: PUSH
97122: FOR_IN
97123: IFFALSE 97177
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97125: LD_VAR 0 1
97129: PPUSH
97130: CALL_OW 257
97134: PUSH
97135: LD_INT 1
97137: PUSH
97138: LD_INT 2
97140: PUSH
97141: LD_INT 3
97143: PUSH
97144: LD_INT 4
97146: PUSH
97147: EMPTY
97148: LIST
97149: LIST
97150: LIST
97151: LIST
97152: IN
97153: IFFALSE 97175
// SetClass ( un , rand ( 1 , 4 ) ) ;
97155: LD_VAR 0 1
97159: PPUSH
97160: LD_INT 1
97162: PPUSH
97163: LD_INT 4
97165: PPUSH
97166: CALL_OW 12
97170: PPUSH
97171: CALL_OW 336
97175: GO 97122
97177: POP
97178: POP
// end ;
97179: PPOPN 1
97181: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97182: LD_EXP 108
97186: PUSH
97187: LD_EXP 120
97191: AND
97192: IFFALSE 97271
97194: GO 97196
97196: DISABLE
97197: LD_INT 0
97199: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97200: LD_ADDR_VAR 0 1
97204: PUSH
97205: LD_INT 22
97207: PUSH
97208: LD_OWVAR 2
97212: PUSH
97213: EMPTY
97214: LIST
97215: LIST
97216: PUSH
97217: LD_INT 21
97219: PUSH
97220: LD_INT 3
97222: PUSH
97223: EMPTY
97224: LIST
97225: LIST
97226: PUSH
97227: EMPTY
97228: LIST
97229: LIST
97230: PPUSH
97231: CALL_OW 69
97235: ST_TO_ADDR
// if not tmp then
97236: LD_VAR 0 1
97240: NOT
97241: IFFALSE 97245
// exit ;
97243: GO 97271
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97245: LD_VAR 0 1
97249: PUSH
97250: LD_INT 1
97252: PPUSH
97253: LD_VAR 0 1
97257: PPUSH
97258: CALL_OW 12
97262: ARRAY
97263: PPUSH
97264: LD_INT 100
97266: PPUSH
97267: CALL_OW 234
// end ;
97271: PPOPN 1
97273: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97274: LD_EXP 108
97278: PUSH
97279: LD_EXP 122
97283: AND
97284: IFFALSE 97382
97286: GO 97288
97288: DISABLE
97289: LD_INT 0
97291: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97292: LD_ADDR_VAR 0 1
97296: PUSH
97297: LD_INT 22
97299: PUSH
97300: LD_OWVAR 2
97304: PUSH
97305: EMPTY
97306: LIST
97307: LIST
97308: PUSH
97309: LD_INT 21
97311: PUSH
97312: LD_INT 1
97314: PUSH
97315: EMPTY
97316: LIST
97317: LIST
97318: PUSH
97319: EMPTY
97320: LIST
97321: LIST
97322: PPUSH
97323: CALL_OW 69
97327: ST_TO_ADDR
// if not tmp then
97328: LD_VAR 0 1
97332: NOT
97333: IFFALSE 97337
// exit ;
97335: GO 97382
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97337: LD_VAR 0 1
97341: PUSH
97342: LD_INT 1
97344: PPUSH
97345: LD_VAR 0 1
97349: PPUSH
97350: CALL_OW 12
97354: ARRAY
97355: PPUSH
97356: LD_INT 1
97358: PPUSH
97359: LD_INT 4
97361: PPUSH
97362: CALL_OW 12
97366: PPUSH
97367: LD_INT 3000
97369: PPUSH
97370: LD_INT 9000
97372: PPUSH
97373: CALL_OW 12
97377: PPUSH
97378: CALL_OW 492
// end ;
97382: PPOPN 1
97384: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97385: LD_EXP 108
97389: PUSH
97390: LD_EXP 123
97394: AND
97395: IFFALSE 97415
97397: GO 97399
97399: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97400: LD_INT 1
97402: PPUSH
97403: LD_OWVAR 2
97407: PPUSH
97408: LD_INT 0
97410: PPUSH
97411: CALL_OW 324
97415: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97416: LD_EXP 108
97420: PUSH
97421: LD_EXP 124
97425: AND
97426: IFFALSE 97509
97428: GO 97430
97430: DISABLE
97431: LD_INT 0
97433: PPUSH
97434: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97435: LD_ADDR_VAR 0 2
97439: PUSH
97440: LD_INT 22
97442: PUSH
97443: LD_OWVAR 2
97447: PUSH
97448: EMPTY
97449: LIST
97450: LIST
97451: PUSH
97452: LD_INT 21
97454: PUSH
97455: LD_INT 3
97457: PUSH
97458: EMPTY
97459: LIST
97460: LIST
97461: PUSH
97462: EMPTY
97463: LIST
97464: LIST
97465: PPUSH
97466: CALL_OW 69
97470: ST_TO_ADDR
// if not tmp then
97471: LD_VAR 0 2
97475: NOT
97476: IFFALSE 97480
// exit ;
97478: GO 97509
// for i in tmp do
97480: LD_ADDR_VAR 0 1
97484: PUSH
97485: LD_VAR 0 2
97489: PUSH
97490: FOR_IN
97491: IFFALSE 97507
// SetBLevel ( i , 10 ) ;
97493: LD_VAR 0 1
97497: PPUSH
97498: LD_INT 10
97500: PPUSH
97501: CALL_OW 241
97505: GO 97490
97507: POP
97508: POP
// end ;
97509: PPOPN 2
97511: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97512: LD_EXP 108
97516: PUSH
97517: LD_EXP 125
97521: AND
97522: IFFALSE 97633
97524: GO 97526
97526: DISABLE
97527: LD_INT 0
97529: PPUSH
97530: PPUSH
97531: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97532: LD_ADDR_VAR 0 3
97536: PUSH
97537: LD_INT 22
97539: PUSH
97540: LD_OWVAR 2
97544: PUSH
97545: EMPTY
97546: LIST
97547: LIST
97548: PUSH
97549: LD_INT 25
97551: PUSH
97552: LD_INT 1
97554: PUSH
97555: EMPTY
97556: LIST
97557: LIST
97558: PUSH
97559: EMPTY
97560: LIST
97561: LIST
97562: PPUSH
97563: CALL_OW 69
97567: ST_TO_ADDR
// if not tmp then
97568: LD_VAR 0 3
97572: NOT
97573: IFFALSE 97577
// exit ;
97575: GO 97633
// un := tmp [ rand ( 1 , tmp ) ] ;
97577: LD_ADDR_VAR 0 2
97581: PUSH
97582: LD_VAR 0 3
97586: PUSH
97587: LD_INT 1
97589: PPUSH
97590: LD_VAR 0 3
97594: PPUSH
97595: CALL_OW 12
97599: ARRAY
97600: ST_TO_ADDR
// if Crawls ( un ) then
97601: LD_VAR 0 2
97605: PPUSH
97606: CALL_OW 318
97610: IFFALSE 97621
// ComWalk ( un ) ;
97612: LD_VAR 0 2
97616: PPUSH
97617: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97621: LD_VAR 0 2
97625: PPUSH
97626: LD_INT 5
97628: PPUSH
97629: CALL_OW 336
// end ;
97633: PPOPN 3
97635: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97636: LD_EXP 108
97640: PUSH
97641: LD_EXP 126
97645: AND
97646: PUSH
97647: LD_OWVAR 67
97651: PUSH
97652: LD_INT 4
97654: LESS
97655: AND
97656: IFFALSE 97675
97658: GO 97660
97660: DISABLE
// begin Difficulty := Difficulty + 1 ;
97661: LD_ADDR_OWVAR 67
97665: PUSH
97666: LD_OWVAR 67
97670: PUSH
97671: LD_INT 1
97673: PLUS
97674: ST_TO_ADDR
// end ;
97675: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97676: LD_EXP 108
97680: PUSH
97681: LD_EXP 127
97685: AND
97686: IFFALSE 97789
97688: GO 97690
97690: DISABLE
97691: LD_INT 0
97693: PPUSH
// begin for i := 1 to 5 do
97694: LD_ADDR_VAR 0 1
97698: PUSH
97699: DOUBLE
97700: LD_INT 1
97702: DEC
97703: ST_TO_ADDR
97704: LD_INT 5
97706: PUSH
97707: FOR_TO
97708: IFFALSE 97787
// begin uc_nation := nation_nature ;
97710: LD_ADDR_OWVAR 21
97714: PUSH
97715: LD_INT 0
97717: ST_TO_ADDR
// uc_side := 0 ;
97718: LD_ADDR_OWVAR 20
97722: PUSH
97723: LD_INT 0
97725: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97726: LD_ADDR_OWVAR 29
97730: PUSH
97731: LD_INT 12
97733: PUSH
97734: LD_INT 12
97736: PUSH
97737: EMPTY
97738: LIST
97739: LIST
97740: ST_TO_ADDR
// hc_agressivity := 20 ;
97741: LD_ADDR_OWVAR 35
97745: PUSH
97746: LD_INT 20
97748: ST_TO_ADDR
// hc_class := class_tiger ;
97749: LD_ADDR_OWVAR 28
97753: PUSH
97754: LD_INT 14
97756: ST_TO_ADDR
// hc_gallery :=  ;
97757: LD_ADDR_OWVAR 33
97761: PUSH
97762: LD_STRING 
97764: ST_TO_ADDR
// hc_name :=  ;
97765: LD_ADDR_OWVAR 26
97769: PUSH
97770: LD_STRING 
97772: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97773: CALL_OW 44
97777: PPUSH
97778: LD_INT 0
97780: PPUSH
97781: CALL_OW 51
// end ;
97785: GO 97707
97787: POP
97788: POP
// end ;
97789: PPOPN 1
97791: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97792: LD_EXP 108
97796: PUSH
97797: LD_EXP 128
97801: AND
97802: IFFALSE 97811
97804: GO 97806
97806: DISABLE
// StreamSibBomb ;
97807: CALL 97812 0 0
97811: END
// export function StreamSibBomb ; var i , x , y ; begin
97812: LD_INT 0
97814: PPUSH
97815: PPUSH
97816: PPUSH
97817: PPUSH
// result := false ;
97818: LD_ADDR_VAR 0 1
97822: PUSH
97823: LD_INT 0
97825: ST_TO_ADDR
// for i := 1 to 16 do
97826: LD_ADDR_VAR 0 2
97830: PUSH
97831: DOUBLE
97832: LD_INT 1
97834: DEC
97835: ST_TO_ADDR
97836: LD_INT 16
97838: PUSH
97839: FOR_TO
97840: IFFALSE 98039
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97842: LD_ADDR_VAR 0 3
97846: PUSH
97847: LD_INT 10
97849: PUSH
97850: LD_INT 20
97852: PUSH
97853: LD_INT 30
97855: PUSH
97856: LD_INT 40
97858: PUSH
97859: LD_INT 50
97861: PUSH
97862: LD_INT 60
97864: PUSH
97865: LD_INT 70
97867: PUSH
97868: LD_INT 80
97870: PUSH
97871: LD_INT 90
97873: PUSH
97874: LD_INT 100
97876: PUSH
97877: LD_INT 110
97879: PUSH
97880: LD_INT 120
97882: PUSH
97883: LD_INT 130
97885: PUSH
97886: LD_INT 140
97888: PUSH
97889: LD_INT 150
97891: PUSH
97892: EMPTY
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: PUSH
97909: LD_INT 1
97911: PPUSH
97912: LD_INT 15
97914: PPUSH
97915: CALL_OW 12
97919: ARRAY
97920: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97921: LD_ADDR_VAR 0 4
97925: PUSH
97926: LD_INT 10
97928: PUSH
97929: LD_INT 20
97931: PUSH
97932: LD_INT 30
97934: PUSH
97935: LD_INT 40
97937: PUSH
97938: LD_INT 50
97940: PUSH
97941: LD_INT 60
97943: PUSH
97944: LD_INT 70
97946: PUSH
97947: LD_INT 80
97949: PUSH
97950: LD_INT 90
97952: PUSH
97953: LD_INT 100
97955: PUSH
97956: LD_INT 110
97958: PUSH
97959: LD_INT 120
97961: PUSH
97962: LD_INT 130
97964: PUSH
97965: LD_INT 140
97967: PUSH
97968: LD_INT 150
97970: PUSH
97971: EMPTY
97972: LIST
97973: LIST
97974: LIST
97975: LIST
97976: LIST
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: LIST
97987: PUSH
97988: LD_INT 1
97990: PPUSH
97991: LD_INT 15
97993: PPUSH
97994: CALL_OW 12
97998: ARRAY
97999: ST_TO_ADDR
// if ValidHex ( x , y ) then
98000: LD_VAR 0 3
98004: PPUSH
98005: LD_VAR 0 4
98009: PPUSH
98010: CALL_OW 488
98014: IFFALSE 98037
// begin result := [ x , y ] ;
98016: LD_ADDR_VAR 0 1
98020: PUSH
98021: LD_VAR 0 3
98025: PUSH
98026: LD_VAR 0 4
98030: PUSH
98031: EMPTY
98032: LIST
98033: LIST
98034: ST_TO_ADDR
// break ;
98035: GO 98039
// end ; end ;
98037: GO 97839
98039: POP
98040: POP
// if result then
98041: LD_VAR 0 1
98045: IFFALSE 98105
// begin ToLua ( playSibBomb() ) ;
98047: LD_STRING playSibBomb()
98049: PPUSH
98050: CALL_OW 559
// wait ( 0 0$14 ) ;
98054: LD_INT 490
98056: PPUSH
98057: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98061: LD_VAR 0 1
98065: PUSH
98066: LD_INT 1
98068: ARRAY
98069: PPUSH
98070: LD_VAR 0 1
98074: PUSH
98075: LD_INT 2
98077: ARRAY
98078: PPUSH
98079: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98083: LD_VAR 0 1
98087: PUSH
98088: LD_INT 1
98090: ARRAY
98091: PPUSH
98092: LD_VAR 0 1
98096: PUSH
98097: LD_INT 2
98099: ARRAY
98100: PPUSH
98101: CALL_OW 429
// end ; end ;
98105: LD_VAR 0 1
98109: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98110: LD_EXP 108
98114: PUSH
98115: LD_EXP 130
98119: AND
98120: IFFALSE 98132
98122: GO 98124
98124: DISABLE
// YouLost (  ) ;
98125: LD_STRING 
98127: PPUSH
98128: CALL_OW 104
98132: END
// every 0 0$1 trigger StreamModeActive and sFog do
98133: LD_EXP 108
98137: PUSH
98138: LD_EXP 129
98142: AND
98143: IFFALSE 98157
98145: GO 98147
98147: DISABLE
// FogOff ( your_side ) ;
98148: LD_OWVAR 2
98152: PPUSH
98153: CALL_OW 344
98157: END
// every 0 0$1 trigger StreamModeActive and sSun do
98158: LD_EXP 108
98162: PUSH
98163: LD_EXP 131
98167: AND
98168: IFFALSE 98196
98170: GO 98172
98172: DISABLE
// begin solar_recharge_percent := 0 ;
98173: LD_ADDR_OWVAR 79
98177: PUSH
98178: LD_INT 0
98180: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98181: LD_INT 10500
98183: PPUSH
98184: CALL_OW 67
// solar_recharge_percent := 100 ;
98188: LD_ADDR_OWVAR 79
98192: PUSH
98193: LD_INT 100
98195: ST_TO_ADDR
// end ;
98196: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98197: LD_EXP 108
98201: PUSH
98202: LD_EXP 132
98206: AND
98207: IFFALSE 98446
98209: GO 98211
98211: DISABLE
98212: LD_INT 0
98214: PPUSH
98215: PPUSH
98216: PPUSH
// begin tmp := [ ] ;
98217: LD_ADDR_VAR 0 3
98221: PUSH
98222: EMPTY
98223: ST_TO_ADDR
// for i := 1 to 6 do
98224: LD_ADDR_VAR 0 1
98228: PUSH
98229: DOUBLE
98230: LD_INT 1
98232: DEC
98233: ST_TO_ADDR
98234: LD_INT 6
98236: PUSH
98237: FOR_TO
98238: IFFALSE 98343
// begin uc_nation := nation_nature ;
98240: LD_ADDR_OWVAR 21
98244: PUSH
98245: LD_INT 0
98247: ST_TO_ADDR
// uc_side := 0 ;
98248: LD_ADDR_OWVAR 20
98252: PUSH
98253: LD_INT 0
98255: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98256: LD_ADDR_OWVAR 29
98260: PUSH
98261: LD_INT 12
98263: PUSH
98264: LD_INT 12
98266: PUSH
98267: EMPTY
98268: LIST
98269: LIST
98270: ST_TO_ADDR
// hc_agressivity := 20 ;
98271: LD_ADDR_OWVAR 35
98275: PUSH
98276: LD_INT 20
98278: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98279: LD_ADDR_OWVAR 28
98283: PUSH
98284: LD_INT 17
98286: ST_TO_ADDR
// hc_gallery :=  ;
98287: LD_ADDR_OWVAR 33
98291: PUSH
98292: LD_STRING 
98294: ST_TO_ADDR
// hc_name :=  ;
98295: LD_ADDR_OWVAR 26
98299: PUSH
98300: LD_STRING 
98302: ST_TO_ADDR
// un := CreateHuman ;
98303: LD_ADDR_VAR 0 2
98307: PUSH
98308: CALL_OW 44
98312: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98313: LD_VAR 0 2
98317: PPUSH
98318: LD_INT 1
98320: PPUSH
98321: CALL_OW 51
// tmp := tmp ^ un ;
98325: LD_ADDR_VAR 0 3
98329: PUSH
98330: LD_VAR 0 3
98334: PUSH
98335: LD_VAR 0 2
98339: ADD
98340: ST_TO_ADDR
// end ;
98341: GO 98237
98343: POP
98344: POP
// repeat wait ( 0 0$1 ) ;
98345: LD_INT 35
98347: PPUSH
98348: CALL_OW 67
// for un in tmp do
98352: LD_ADDR_VAR 0 2
98356: PUSH
98357: LD_VAR 0 3
98361: PUSH
98362: FOR_IN
98363: IFFALSE 98437
// begin if IsDead ( un ) then
98365: LD_VAR 0 2
98369: PPUSH
98370: CALL_OW 301
98374: IFFALSE 98394
// begin tmp := tmp diff un ;
98376: LD_ADDR_VAR 0 3
98380: PUSH
98381: LD_VAR 0 3
98385: PUSH
98386: LD_VAR 0 2
98390: DIFF
98391: ST_TO_ADDR
// continue ;
98392: GO 98362
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98394: LD_VAR 0 2
98398: PPUSH
98399: LD_INT 3
98401: PUSH
98402: LD_INT 22
98404: PUSH
98405: LD_INT 0
98407: PUSH
98408: EMPTY
98409: LIST
98410: LIST
98411: PUSH
98412: EMPTY
98413: LIST
98414: LIST
98415: PPUSH
98416: CALL_OW 69
98420: PPUSH
98421: LD_VAR 0 2
98425: PPUSH
98426: CALL_OW 74
98430: PPUSH
98431: CALL_OW 115
// end ;
98435: GO 98362
98437: POP
98438: POP
// until not tmp ;
98439: LD_VAR 0 3
98443: NOT
98444: IFFALSE 98345
// end ;
98446: PPOPN 3
98448: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98449: LD_EXP 108
98453: PUSH
98454: LD_EXP 133
98458: AND
98459: IFFALSE 98513
98461: GO 98463
98463: DISABLE
// begin ToLua ( displayTroll(); ) ;
98464: LD_STRING displayTroll();
98466: PPUSH
98467: CALL_OW 559
// wait ( 3 3$00 ) ;
98471: LD_INT 6300
98473: PPUSH
98474: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98478: LD_STRING hideTroll();
98480: PPUSH
98481: CALL_OW 559
// wait ( 1 1$00 ) ;
98485: LD_INT 2100
98487: PPUSH
98488: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98492: LD_STRING displayTroll();
98494: PPUSH
98495: CALL_OW 559
// wait ( 1 1$00 ) ;
98499: LD_INT 2100
98501: PPUSH
98502: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98506: LD_STRING hideTroll();
98508: PPUSH
98509: CALL_OW 559
// end ;
98513: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98514: LD_EXP 108
98518: PUSH
98519: LD_EXP 134
98523: AND
98524: IFFALSE 98587
98526: GO 98528
98528: DISABLE
98529: LD_INT 0
98531: PPUSH
// begin p := 0 ;
98532: LD_ADDR_VAR 0 1
98536: PUSH
98537: LD_INT 0
98539: ST_TO_ADDR
// repeat game_speed := 1 ;
98540: LD_ADDR_OWVAR 65
98544: PUSH
98545: LD_INT 1
98547: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98548: LD_INT 35
98550: PPUSH
98551: CALL_OW 67
// p := p + 1 ;
98555: LD_ADDR_VAR 0 1
98559: PUSH
98560: LD_VAR 0 1
98564: PUSH
98565: LD_INT 1
98567: PLUS
98568: ST_TO_ADDR
// until p >= 60 ;
98569: LD_VAR 0 1
98573: PUSH
98574: LD_INT 60
98576: GREATEREQUAL
98577: IFFALSE 98540
// game_speed := 4 ;
98579: LD_ADDR_OWVAR 65
98583: PUSH
98584: LD_INT 4
98586: ST_TO_ADDR
// end ;
98587: PPOPN 1
98589: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98590: LD_EXP 108
98594: PUSH
98595: LD_EXP 135
98599: AND
98600: IFFALSE 98746
98602: GO 98604
98604: DISABLE
98605: LD_INT 0
98607: PPUSH
98608: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98609: LD_ADDR_VAR 0 1
98613: PUSH
98614: LD_INT 22
98616: PUSH
98617: LD_OWVAR 2
98621: PUSH
98622: EMPTY
98623: LIST
98624: LIST
98625: PUSH
98626: LD_INT 2
98628: PUSH
98629: LD_INT 30
98631: PUSH
98632: LD_INT 0
98634: PUSH
98635: EMPTY
98636: LIST
98637: LIST
98638: PUSH
98639: LD_INT 30
98641: PUSH
98642: LD_INT 1
98644: PUSH
98645: EMPTY
98646: LIST
98647: LIST
98648: PUSH
98649: EMPTY
98650: LIST
98651: LIST
98652: LIST
98653: PUSH
98654: EMPTY
98655: LIST
98656: LIST
98657: PPUSH
98658: CALL_OW 69
98662: ST_TO_ADDR
// if not depot then
98663: LD_VAR 0 1
98667: NOT
98668: IFFALSE 98672
// exit ;
98670: GO 98746
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98672: LD_ADDR_VAR 0 2
98676: PUSH
98677: LD_VAR 0 1
98681: PUSH
98682: LD_INT 1
98684: PPUSH
98685: LD_VAR 0 1
98689: PPUSH
98690: CALL_OW 12
98694: ARRAY
98695: PPUSH
98696: CALL_OW 274
98700: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98701: LD_VAR 0 2
98705: PPUSH
98706: LD_INT 1
98708: PPUSH
98709: LD_INT 0
98711: PPUSH
98712: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98716: LD_VAR 0 2
98720: PPUSH
98721: LD_INT 2
98723: PPUSH
98724: LD_INT 0
98726: PPUSH
98727: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98731: LD_VAR 0 2
98735: PPUSH
98736: LD_INT 3
98738: PPUSH
98739: LD_INT 0
98741: PPUSH
98742: CALL_OW 277
// end ;
98746: PPOPN 2
98748: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98749: LD_EXP 108
98753: PUSH
98754: LD_EXP 136
98758: AND
98759: IFFALSE 98856
98761: GO 98763
98763: DISABLE
98764: LD_INT 0
98766: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98767: LD_ADDR_VAR 0 1
98771: PUSH
98772: LD_INT 22
98774: PUSH
98775: LD_OWVAR 2
98779: PUSH
98780: EMPTY
98781: LIST
98782: LIST
98783: PUSH
98784: LD_INT 21
98786: PUSH
98787: LD_INT 1
98789: PUSH
98790: EMPTY
98791: LIST
98792: LIST
98793: PUSH
98794: LD_INT 3
98796: PUSH
98797: LD_INT 23
98799: PUSH
98800: LD_INT 0
98802: PUSH
98803: EMPTY
98804: LIST
98805: LIST
98806: PUSH
98807: EMPTY
98808: LIST
98809: LIST
98810: PUSH
98811: EMPTY
98812: LIST
98813: LIST
98814: LIST
98815: PPUSH
98816: CALL_OW 69
98820: ST_TO_ADDR
// if not tmp then
98821: LD_VAR 0 1
98825: NOT
98826: IFFALSE 98830
// exit ;
98828: GO 98856
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98830: LD_VAR 0 1
98834: PUSH
98835: LD_INT 1
98837: PPUSH
98838: LD_VAR 0 1
98842: PPUSH
98843: CALL_OW 12
98847: ARRAY
98848: PPUSH
98849: LD_INT 200
98851: PPUSH
98852: CALL_OW 234
// end ;
98856: PPOPN 1
98858: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98859: LD_EXP 108
98863: PUSH
98864: LD_EXP 137
98868: AND
98869: IFFALSE 98948
98871: GO 98873
98873: DISABLE
98874: LD_INT 0
98876: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98877: LD_ADDR_VAR 0 1
98881: PUSH
98882: LD_INT 22
98884: PUSH
98885: LD_OWVAR 2
98889: PUSH
98890: EMPTY
98891: LIST
98892: LIST
98893: PUSH
98894: LD_INT 21
98896: PUSH
98897: LD_INT 2
98899: PUSH
98900: EMPTY
98901: LIST
98902: LIST
98903: PUSH
98904: EMPTY
98905: LIST
98906: LIST
98907: PPUSH
98908: CALL_OW 69
98912: ST_TO_ADDR
// if not tmp then
98913: LD_VAR 0 1
98917: NOT
98918: IFFALSE 98922
// exit ;
98920: GO 98948
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98922: LD_VAR 0 1
98926: PUSH
98927: LD_INT 1
98929: PPUSH
98930: LD_VAR 0 1
98934: PPUSH
98935: CALL_OW 12
98939: ARRAY
98940: PPUSH
98941: LD_INT 60
98943: PPUSH
98944: CALL_OW 234
// end ;
98948: PPOPN 1
98950: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98951: LD_EXP 108
98955: PUSH
98956: LD_EXP 138
98960: AND
98961: IFFALSE 99060
98963: GO 98965
98965: DISABLE
98966: LD_INT 0
98968: PPUSH
98969: PPUSH
// begin enable ;
98970: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98971: LD_ADDR_VAR 0 1
98975: PUSH
98976: LD_INT 22
98978: PUSH
98979: LD_OWVAR 2
98983: PUSH
98984: EMPTY
98985: LIST
98986: LIST
98987: PUSH
98988: LD_INT 61
98990: PUSH
98991: EMPTY
98992: LIST
98993: PUSH
98994: LD_INT 33
98996: PUSH
98997: LD_INT 2
98999: PUSH
99000: EMPTY
99001: LIST
99002: LIST
99003: PUSH
99004: EMPTY
99005: LIST
99006: LIST
99007: LIST
99008: PPUSH
99009: CALL_OW 69
99013: ST_TO_ADDR
// if not tmp then
99014: LD_VAR 0 1
99018: NOT
99019: IFFALSE 99023
// exit ;
99021: GO 99060
// for i in tmp do
99023: LD_ADDR_VAR 0 2
99027: PUSH
99028: LD_VAR 0 1
99032: PUSH
99033: FOR_IN
99034: IFFALSE 99058
// if IsControledBy ( i ) then
99036: LD_VAR 0 2
99040: PPUSH
99041: CALL_OW 312
99045: IFFALSE 99056
// ComUnlink ( i ) ;
99047: LD_VAR 0 2
99051: PPUSH
99052: CALL_OW 136
99056: GO 99033
99058: POP
99059: POP
// end ;
99060: PPOPN 2
99062: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99063: LD_EXP 108
99067: PUSH
99068: LD_EXP 139
99072: AND
99073: IFFALSE 99213
99075: GO 99077
99077: DISABLE
99078: LD_INT 0
99080: PPUSH
99081: PPUSH
// begin ToLua ( displayPowell(); ) ;
99082: LD_STRING displayPowell();
99084: PPUSH
99085: CALL_OW 559
// uc_side := 0 ;
99089: LD_ADDR_OWVAR 20
99093: PUSH
99094: LD_INT 0
99096: ST_TO_ADDR
// uc_nation := 2 ;
99097: LD_ADDR_OWVAR 21
99101: PUSH
99102: LD_INT 2
99104: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99105: LD_ADDR_OWVAR 37
99109: PUSH
99110: LD_INT 14
99112: ST_TO_ADDR
// vc_engine := engine_siberite ;
99113: LD_ADDR_OWVAR 39
99117: PUSH
99118: LD_INT 3
99120: ST_TO_ADDR
// vc_control := control_apeman ;
99121: LD_ADDR_OWVAR 38
99125: PUSH
99126: LD_INT 5
99128: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99129: LD_ADDR_OWVAR 40
99133: PUSH
99134: LD_INT 29
99136: ST_TO_ADDR
// un := CreateVehicle ;
99137: LD_ADDR_VAR 0 2
99141: PUSH
99142: CALL_OW 45
99146: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99147: LD_VAR 0 2
99151: PPUSH
99152: LD_INT 1
99154: PPUSH
99155: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99159: LD_INT 35
99161: PPUSH
99162: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99166: LD_VAR 0 2
99170: PPUSH
99171: LD_INT 22
99173: PUSH
99174: LD_OWVAR 2
99178: PUSH
99179: EMPTY
99180: LIST
99181: LIST
99182: PPUSH
99183: CALL_OW 69
99187: PPUSH
99188: LD_VAR 0 2
99192: PPUSH
99193: CALL_OW 74
99197: PPUSH
99198: CALL_OW 115
// until IsDead ( un ) ;
99202: LD_VAR 0 2
99206: PPUSH
99207: CALL_OW 301
99211: IFFALSE 99159
// end ;
99213: PPOPN 2
99215: END
// every 0 0$1 trigger StreamModeActive and sStu do
99216: LD_EXP 108
99220: PUSH
99221: LD_EXP 147
99225: AND
99226: IFFALSE 99242
99228: GO 99230
99230: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99231: LD_STRING displayStucuk();
99233: PPUSH
99234: CALL_OW 559
// ResetFog ;
99238: CALL_OW 335
// end ;
99242: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99243: LD_EXP 108
99247: PUSH
99248: LD_EXP 140
99252: AND
99253: IFFALSE 99394
99255: GO 99257
99257: DISABLE
99258: LD_INT 0
99260: PPUSH
99261: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99262: LD_ADDR_VAR 0 2
99266: PUSH
99267: LD_INT 22
99269: PUSH
99270: LD_OWVAR 2
99274: PUSH
99275: EMPTY
99276: LIST
99277: LIST
99278: PUSH
99279: LD_INT 21
99281: PUSH
99282: LD_INT 1
99284: PUSH
99285: EMPTY
99286: LIST
99287: LIST
99288: PUSH
99289: EMPTY
99290: LIST
99291: LIST
99292: PPUSH
99293: CALL_OW 69
99297: ST_TO_ADDR
// if not tmp then
99298: LD_VAR 0 2
99302: NOT
99303: IFFALSE 99307
// exit ;
99305: GO 99394
// un := tmp [ rand ( 1 , tmp ) ] ;
99307: LD_ADDR_VAR 0 1
99311: PUSH
99312: LD_VAR 0 2
99316: PUSH
99317: LD_INT 1
99319: PPUSH
99320: LD_VAR 0 2
99324: PPUSH
99325: CALL_OW 12
99329: ARRAY
99330: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99331: LD_VAR 0 1
99335: PPUSH
99336: LD_INT 0
99338: PPUSH
99339: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99343: LD_VAR 0 1
99347: PPUSH
99348: LD_OWVAR 3
99352: PUSH
99353: LD_VAR 0 1
99357: DIFF
99358: PPUSH
99359: LD_VAR 0 1
99363: PPUSH
99364: CALL_OW 74
99368: PPUSH
99369: CALL_OW 115
// wait ( 0 0$20 ) ;
99373: LD_INT 700
99375: PPUSH
99376: CALL_OW 67
// SetSide ( un , your_side ) ;
99380: LD_VAR 0 1
99384: PPUSH
99385: LD_OWVAR 2
99389: PPUSH
99390: CALL_OW 235
// end ;
99394: PPOPN 2
99396: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99397: LD_EXP 108
99401: PUSH
99402: LD_EXP 141
99406: AND
99407: IFFALSE 99513
99409: GO 99411
99411: DISABLE
99412: LD_INT 0
99414: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99415: LD_ADDR_VAR 0 1
99419: PUSH
99420: LD_INT 22
99422: PUSH
99423: LD_OWVAR 2
99427: PUSH
99428: EMPTY
99429: LIST
99430: LIST
99431: PUSH
99432: LD_INT 2
99434: PUSH
99435: LD_INT 30
99437: PUSH
99438: LD_INT 0
99440: PUSH
99441: EMPTY
99442: LIST
99443: LIST
99444: PUSH
99445: LD_INT 30
99447: PUSH
99448: LD_INT 1
99450: PUSH
99451: EMPTY
99452: LIST
99453: LIST
99454: PUSH
99455: EMPTY
99456: LIST
99457: LIST
99458: LIST
99459: PUSH
99460: EMPTY
99461: LIST
99462: LIST
99463: PPUSH
99464: CALL_OW 69
99468: ST_TO_ADDR
// if not depot then
99469: LD_VAR 0 1
99473: NOT
99474: IFFALSE 99478
// exit ;
99476: GO 99513
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99478: LD_VAR 0 1
99482: PUSH
99483: LD_INT 1
99485: ARRAY
99486: PPUSH
99487: CALL_OW 250
99491: PPUSH
99492: LD_VAR 0 1
99496: PUSH
99497: LD_INT 1
99499: ARRAY
99500: PPUSH
99501: CALL_OW 251
99505: PPUSH
99506: LD_INT 70
99508: PPUSH
99509: CALL_OW 495
// end ;
99513: PPOPN 1
99515: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99516: LD_EXP 108
99520: PUSH
99521: LD_EXP 142
99525: AND
99526: IFFALSE 99737
99528: GO 99530
99530: DISABLE
99531: LD_INT 0
99533: PPUSH
99534: PPUSH
99535: PPUSH
99536: PPUSH
99537: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99538: LD_ADDR_VAR 0 5
99542: PUSH
99543: LD_INT 22
99545: PUSH
99546: LD_OWVAR 2
99550: PUSH
99551: EMPTY
99552: LIST
99553: LIST
99554: PUSH
99555: LD_INT 21
99557: PUSH
99558: LD_INT 1
99560: PUSH
99561: EMPTY
99562: LIST
99563: LIST
99564: PUSH
99565: EMPTY
99566: LIST
99567: LIST
99568: PPUSH
99569: CALL_OW 69
99573: ST_TO_ADDR
// if not tmp then
99574: LD_VAR 0 5
99578: NOT
99579: IFFALSE 99583
// exit ;
99581: GO 99737
// for i in tmp do
99583: LD_ADDR_VAR 0 1
99587: PUSH
99588: LD_VAR 0 5
99592: PUSH
99593: FOR_IN
99594: IFFALSE 99735
// begin d := rand ( 0 , 5 ) ;
99596: LD_ADDR_VAR 0 4
99600: PUSH
99601: LD_INT 0
99603: PPUSH
99604: LD_INT 5
99606: PPUSH
99607: CALL_OW 12
99611: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99612: LD_ADDR_VAR 0 2
99616: PUSH
99617: LD_VAR 0 1
99621: PPUSH
99622: CALL_OW 250
99626: PPUSH
99627: LD_VAR 0 4
99631: PPUSH
99632: LD_INT 3
99634: PPUSH
99635: LD_INT 12
99637: PPUSH
99638: CALL_OW 12
99642: PPUSH
99643: CALL_OW 272
99647: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99648: LD_ADDR_VAR 0 3
99652: PUSH
99653: LD_VAR 0 1
99657: PPUSH
99658: CALL_OW 251
99662: PPUSH
99663: LD_VAR 0 4
99667: PPUSH
99668: LD_INT 3
99670: PPUSH
99671: LD_INT 12
99673: PPUSH
99674: CALL_OW 12
99678: PPUSH
99679: CALL_OW 273
99683: ST_TO_ADDR
// if ValidHex ( x , y ) then
99684: LD_VAR 0 2
99688: PPUSH
99689: LD_VAR 0 3
99693: PPUSH
99694: CALL_OW 488
99698: IFFALSE 99733
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99700: LD_VAR 0 1
99704: PPUSH
99705: LD_VAR 0 2
99709: PPUSH
99710: LD_VAR 0 3
99714: PPUSH
99715: LD_INT 3
99717: PPUSH
99718: LD_INT 6
99720: PPUSH
99721: CALL_OW 12
99725: PPUSH
99726: LD_INT 1
99728: PPUSH
99729: CALL_OW 483
// end ;
99733: GO 99593
99735: POP
99736: POP
// end ;
99737: PPOPN 5
99739: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99740: LD_EXP 108
99744: PUSH
99745: LD_EXP 143
99749: AND
99750: IFFALSE 99844
99752: GO 99754
99754: DISABLE
99755: LD_INT 0
99757: PPUSH
99758: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99759: LD_ADDR_VAR 0 2
99763: PUSH
99764: LD_INT 22
99766: PUSH
99767: LD_OWVAR 2
99771: PUSH
99772: EMPTY
99773: LIST
99774: LIST
99775: PUSH
99776: LD_INT 32
99778: PUSH
99779: LD_INT 1
99781: PUSH
99782: EMPTY
99783: LIST
99784: LIST
99785: PUSH
99786: LD_INT 21
99788: PUSH
99789: LD_INT 2
99791: PUSH
99792: EMPTY
99793: LIST
99794: LIST
99795: PUSH
99796: EMPTY
99797: LIST
99798: LIST
99799: LIST
99800: PPUSH
99801: CALL_OW 69
99805: ST_TO_ADDR
// if not tmp then
99806: LD_VAR 0 2
99810: NOT
99811: IFFALSE 99815
// exit ;
99813: GO 99844
// for i in tmp do
99815: LD_ADDR_VAR 0 1
99819: PUSH
99820: LD_VAR 0 2
99824: PUSH
99825: FOR_IN
99826: IFFALSE 99842
// SetFuel ( i , 0 ) ;
99828: LD_VAR 0 1
99832: PPUSH
99833: LD_INT 0
99835: PPUSH
99836: CALL_OW 240
99840: GO 99825
99842: POP
99843: POP
// end ;
99844: PPOPN 2
99846: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99847: LD_EXP 108
99851: PUSH
99852: LD_EXP 144
99856: AND
99857: IFFALSE 99923
99859: GO 99861
99861: DISABLE
99862: LD_INT 0
99864: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99865: LD_ADDR_VAR 0 1
99869: PUSH
99870: LD_INT 22
99872: PUSH
99873: LD_OWVAR 2
99877: PUSH
99878: EMPTY
99879: LIST
99880: LIST
99881: PUSH
99882: LD_INT 30
99884: PUSH
99885: LD_INT 29
99887: PUSH
99888: EMPTY
99889: LIST
99890: LIST
99891: PUSH
99892: EMPTY
99893: LIST
99894: LIST
99895: PPUSH
99896: CALL_OW 69
99900: ST_TO_ADDR
// if not tmp then
99901: LD_VAR 0 1
99905: NOT
99906: IFFALSE 99910
// exit ;
99908: GO 99923
// DestroyUnit ( tmp [ 1 ] ) ;
99910: LD_VAR 0 1
99914: PUSH
99915: LD_INT 1
99917: ARRAY
99918: PPUSH
99919: CALL_OW 65
// end ;
99923: PPOPN 1
99925: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99926: LD_EXP 108
99930: PUSH
99931: LD_EXP 146
99935: AND
99936: IFFALSE 100065
99938: GO 99940
99940: DISABLE
99941: LD_INT 0
99943: PPUSH
// begin uc_side := 0 ;
99944: LD_ADDR_OWVAR 20
99948: PUSH
99949: LD_INT 0
99951: ST_TO_ADDR
// uc_nation := nation_arabian ;
99952: LD_ADDR_OWVAR 21
99956: PUSH
99957: LD_INT 2
99959: ST_TO_ADDR
// hc_gallery :=  ;
99960: LD_ADDR_OWVAR 33
99964: PUSH
99965: LD_STRING 
99967: ST_TO_ADDR
// hc_name :=  ;
99968: LD_ADDR_OWVAR 26
99972: PUSH
99973: LD_STRING 
99975: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99976: LD_INT 1
99978: PPUSH
99979: LD_INT 11
99981: PPUSH
99982: LD_INT 10
99984: PPUSH
99985: CALL_OW 380
// un := CreateHuman ;
99989: LD_ADDR_VAR 0 1
99993: PUSH
99994: CALL_OW 44
99998: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99999: LD_VAR 0 1
100003: PPUSH
100004: LD_INT 1
100006: PPUSH
100007: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100011: LD_INT 35
100013: PPUSH
100014: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100018: LD_VAR 0 1
100022: PPUSH
100023: LD_INT 22
100025: PUSH
100026: LD_OWVAR 2
100030: PUSH
100031: EMPTY
100032: LIST
100033: LIST
100034: PPUSH
100035: CALL_OW 69
100039: PPUSH
100040: LD_VAR 0 1
100044: PPUSH
100045: CALL_OW 74
100049: PPUSH
100050: CALL_OW 115
// until IsDead ( un ) ;
100054: LD_VAR 0 1
100058: PPUSH
100059: CALL_OW 301
100063: IFFALSE 100011
// end ;
100065: PPOPN 1
100067: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100068: LD_EXP 108
100072: PUSH
100073: LD_EXP 148
100077: AND
100078: IFFALSE 100090
100080: GO 100082
100082: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100083: LD_STRING earthquake(getX(game), 0, 32)
100085: PPUSH
100086: CALL_OW 559
100090: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100091: LD_EXP 108
100095: PUSH
100096: LD_EXP 149
100100: AND
100101: IFFALSE 100192
100103: GO 100105
100105: DISABLE
100106: LD_INT 0
100108: PPUSH
// begin enable ;
100109: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100110: LD_ADDR_VAR 0 1
100114: PUSH
100115: LD_INT 22
100117: PUSH
100118: LD_OWVAR 2
100122: PUSH
100123: EMPTY
100124: LIST
100125: LIST
100126: PUSH
100127: LD_INT 21
100129: PUSH
100130: LD_INT 2
100132: PUSH
100133: EMPTY
100134: LIST
100135: LIST
100136: PUSH
100137: LD_INT 33
100139: PUSH
100140: LD_INT 3
100142: PUSH
100143: EMPTY
100144: LIST
100145: LIST
100146: PUSH
100147: EMPTY
100148: LIST
100149: LIST
100150: LIST
100151: PPUSH
100152: CALL_OW 69
100156: ST_TO_ADDR
// if not tmp then
100157: LD_VAR 0 1
100161: NOT
100162: IFFALSE 100166
// exit ;
100164: GO 100192
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100166: LD_VAR 0 1
100170: PUSH
100171: LD_INT 1
100173: PPUSH
100174: LD_VAR 0 1
100178: PPUSH
100179: CALL_OW 12
100183: ARRAY
100184: PPUSH
100185: LD_INT 1
100187: PPUSH
100188: CALL_OW 234
// end ;
100192: PPOPN 1
100194: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100195: LD_EXP 108
100199: PUSH
100200: LD_EXP 150
100204: AND
100205: IFFALSE 100346
100207: GO 100209
100209: DISABLE
100210: LD_INT 0
100212: PPUSH
100213: PPUSH
100214: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100215: LD_ADDR_VAR 0 3
100219: PUSH
100220: LD_INT 22
100222: PUSH
100223: LD_OWVAR 2
100227: PUSH
100228: EMPTY
100229: LIST
100230: LIST
100231: PUSH
100232: LD_INT 25
100234: PUSH
100235: LD_INT 1
100237: PUSH
100238: EMPTY
100239: LIST
100240: LIST
100241: PUSH
100242: EMPTY
100243: LIST
100244: LIST
100245: PPUSH
100246: CALL_OW 69
100250: ST_TO_ADDR
// if not tmp then
100251: LD_VAR 0 3
100255: NOT
100256: IFFALSE 100260
// exit ;
100258: GO 100346
// un := tmp [ rand ( 1 , tmp ) ] ;
100260: LD_ADDR_VAR 0 2
100264: PUSH
100265: LD_VAR 0 3
100269: PUSH
100270: LD_INT 1
100272: PPUSH
100273: LD_VAR 0 3
100277: PPUSH
100278: CALL_OW 12
100282: ARRAY
100283: ST_TO_ADDR
// if Crawls ( un ) then
100284: LD_VAR 0 2
100288: PPUSH
100289: CALL_OW 318
100293: IFFALSE 100304
// ComWalk ( un ) ;
100295: LD_VAR 0 2
100299: PPUSH
100300: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100304: LD_VAR 0 2
100308: PPUSH
100309: LD_INT 9
100311: PPUSH
100312: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100316: LD_INT 28
100318: PPUSH
100319: LD_OWVAR 2
100323: PPUSH
100324: LD_INT 2
100326: PPUSH
100327: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100331: LD_INT 29
100333: PPUSH
100334: LD_OWVAR 2
100338: PPUSH
100339: LD_INT 2
100341: PPUSH
100342: CALL_OW 322
// end ;
100346: PPOPN 3
100348: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100349: LD_EXP 108
100353: PUSH
100354: LD_EXP 151
100358: AND
100359: IFFALSE 100470
100361: GO 100363
100363: DISABLE
100364: LD_INT 0
100366: PPUSH
100367: PPUSH
100368: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100369: LD_ADDR_VAR 0 3
100373: PUSH
100374: LD_INT 22
100376: PUSH
100377: LD_OWVAR 2
100381: PUSH
100382: EMPTY
100383: LIST
100384: LIST
100385: PUSH
100386: LD_INT 25
100388: PUSH
100389: LD_INT 1
100391: PUSH
100392: EMPTY
100393: LIST
100394: LIST
100395: PUSH
100396: EMPTY
100397: LIST
100398: LIST
100399: PPUSH
100400: CALL_OW 69
100404: ST_TO_ADDR
// if not tmp then
100405: LD_VAR 0 3
100409: NOT
100410: IFFALSE 100414
// exit ;
100412: GO 100470
// un := tmp [ rand ( 1 , tmp ) ] ;
100414: LD_ADDR_VAR 0 2
100418: PUSH
100419: LD_VAR 0 3
100423: PUSH
100424: LD_INT 1
100426: PPUSH
100427: LD_VAR 0 3
100431: PPUSH
100432: CALL_OW 12
100436: ARRAY
100437: ST_TO_ADDR
// if Crawls ( un ) then
100438: LD_VAR 0 2
100442: PPUSH
100443: CALL_OW 318
100447: IFFALSE 100458
// ComWalk ( un ) ;
100449: LD_VAR 0 2
100453: PPUSH
100454: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100458: LD_VAR 0 2
100462: PPUSH
100463: LD_INT 8
100465: PPUSH
100466: CALL_OW 336
// end ;
100470: PPOPN 3
100472: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100473: LD_EXP 108
100477: PUSH
100478: LD_EXP 152
100482: AND
100483: IFFALSE 100627
100485: GO 100487
100487: DISABLE
100488: LD_INT 0
100490: PPUSH
100491: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100492: LD_ADDR_VAR 0 2
100496: PUSH
100497: LD_INT 22
100499: PUSH
100500: LD_OWVAR 2
100504: PUSH
100505: EMPTY
100506: LIST
100507: LIST
100508: PUSH
100509: LD_INT 21
100511: PUSH
100512: LD_INT 2
100514: PUSH
100515: EMPTY
100516: LIST
100517: LIST
100518: PUSH
100519: LD_INT 2
100521: PUSH
100522: LD_INT 34
100524: PUSH
100525: LD_INT 12
100527: PUSH
100528: EMPTY
100529: LIST
100530: LIST
100531: PUSH
100532: LD_INT 34
100534: PUSH
100535: LD_INT 51
100537: PUSH
100538: EMPTY
100539: LIST
100540: LIST
100541: PUSH
100542: LD_INT 34
100544: PUSH
100545: LD_INT 32
100547: PUSH
100548: EMPTY
100549: LIST
100550: LIST
100551: PUSH
100552: EMPTY
100553: LIST
100554: LIST
100555: LIST
100556: LIST
100557: PUSH
100558: EMPTY
100559: LIST
100560: LIST
100561: LIST
100562: PPUSH
100563: CALL_OW 69
100567: ST_TO_ADDR
// if not tmp then
100568: LD_VAR 0 2
100572: NOT
100573: IFFALSE 100577
// exit ;
100575: GO 100627
// for i in tmp do
100577: LD_ADDR_VAR 0 1
100581: PUSH
100582: LD_VAR 0 2
100586: PUSH
100587: FOR_IN
100588: IFFALSE 100625
// if GetCargo ( i , mat_artifact ) = 0 then
100590: LD_VAR 0 1
100594: PPUSH
100595: LD_INT 4
100597: PPUSH
100598: CALL_OW 289
100602: PUSH
100603: LD_INT 0
100605: EQUAL
100606: IFFALSE 100623
// SetCargo ( i , mat_siberit , 100 ) ;
100608: LD_VAR 0 1
100612: PPUSH
100613: LD_INT 3
100615: PPUSH
100616: LD_INT 100
100618: PPUSH
100619: CALL_OW 290
100623: GO 100587
100625: POP
100626: POP
// end ;
100627: PPOPN 2
100629: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100630: LD_EXP 108
100634: PUSH
100635: LD_EXP 153
100639: AND
100640: IFFALSE 100823
100642: GO 100644
100644: DISABLE
100645: LD_INT 0
100647: PPUSH
100648: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100649: LD_ADDR_VAR 0 2
100653: PUSH
100654: LD_INT 22
100656: PUSH
100657: LD_OWVAR 2
100661: PUSH
100662: EMPTY
100663: LIST
100664: LIST
100665: PPUSH
100666: CALL_OW 69
100670: ST_TO_ADDR
// if not tmp then
100671: LD_VAR 0 2
100675: NOT
100676: IFFALSE 100680
// exit ;
100678: GO 100823
// for i := 1 to 2 do
100680: LD_ADDR_VAR 0 1
100684: PUSH
100685: DOUBLE
100686: LD_INT 1
100688: DEC
100689: ST_TO_ADDR
100690: LD_INT 2
100692: PUSH
100693: FOR_TO
100694: IFFALSE 100821
// begin uc_side := your_side ;
100696: LD_ADDR_OWVAR 20
100700: PUSH
100701: LD_OWVAR 2
100705: ST_TO_ADDR
// uc_nation := nation_american ;
100706: LD_ADDR_OWVAR 21
100710: PUSH
100711: LD_INT 1
100713: ST_TO_ADDR
// vc_chassis := us_morphling ;
100714: LD_ADDR_OWVAR 37
100718: PUSH
100719: LD_INT 5
100721: ST_TO_ADDR
// vc_engine := engine_siberite ;
100722: LD_ADDR_OWVAR 39
100726: PUSH
100727: LD_INT 3
100729: ST_TO_ADDR
// vc_control := control_computer ;
100730: LD_ADDR_OWVAR 38
100734: PUSH
100735: LD_INT 3
100737: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100738: LD_ADDR_OWVAR 40
100742: PUSH
100743: LD_INT 10
100745: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100746: LD_VAR 0 2
100750: PUSH
100751: LD_INT 1
100753: ARRAY
100754: PPUSH
100755: CALL_OW 310
100759: NOT
100760: IFFALSE 100807
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100762: CALL_OW 45
100766: PPUSH
100767: LD_VAR 0 2
100771: PUSH
100772: LD_INT 1
100774: ARRAY
100775: PPUSH
100776: CALL_OW 250
100780: PPUSH
100781: LD_VAR 0 2
100785: PUSH
100786: LD_INT 1
100788: ARRAY
100789: PPUSH
100790: CALL_OW 251
100794: PPUSH
100795: LD_INT 12
100797: PPUSH
100798: LD_INT 1
100800: PPUSH
100801: CALL_OW 50
100805: GO 100819
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100807: CALL_OW 45
100811: PPUSH
100812: LD_INT 1
100814: PPUSH
100815: CALL_OW 51
// end ;
100819: GO 100693
100821: POP
100822: POP
// end ;
100823: PPOPN 2
100825: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100826: LD_EXP 108
100830: PUSH
100831: LD_EXP 154
100835: AND
100836: IFFALSE 101058
100838: GO 100840
100840: DISABLE
100841: LD_INT 0
100843: PPUSH
100844: PPUSH
100845: PPUSH
100846: PPUSH
100847: PPUSH
100848: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100849: LD_ADDR_VAR 0 6
100853: PUSH
100854: LD_INT 22
100856: PUSH
100857: LD_OWVAR 2
100861: PUSH
100862: EMPTY
100863: LIST
100864: LIST
100865: PUSH
100866: LD_INT 21
100868: PUSH
100869: LD_INT 1
100871: PUSH
100872: EMPTY
100873: LIST
100874: LIST
100875: PUSH
100876: LD_INT 3
100878: PUSH
100879: LD_INT 23
100881: PUSH
100882: LD_INT 0
100884: PUSH
100885: EMPTY
100886: LIST
100887: LIST
100888: PUSH
100889: EMPTY
100890: LIST
100891: LIST
100892: PUSH
100893: EMPTY
100894: LIST
100895: LIST
100896: LIST
100897: PPUSH
100898: CALL_OW 69
100902: ST_TO_ADDR
// if not tmp then
100903: LD_VAR 0 6
100907: NOT
100908: IFFALSE 100912
// exit ;
100910: GO 101058
// s1 := rand ( 1 , 4 ) ;
100912: LD_ADDR_VAR 0 2
100916: PUSH
100917: LD_INT 1
100919: PPUSH
100920: LD_INT 4
100922: PPUSH
100923: CALL_OW 12
100927: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100928: LD_ADDR_VAR 0 4
100932: PUSH
100933: LD_VAR 0 6
100937: PUSH
100938: LD_INT 1
100940: ARRAY
100941: PPUSH
100942: LD_VAR 0 2
100946: PPUSH
100947: CALL_OW 259
100951: ST_TO_ADDR
// if s1 = 1 then
100952: LD_VAR 0 2
100956: PUSH
100957: LD_INT 1
100959: EQUAL
100960: IFFALSE 100980
// s2 := rand ( 2 , 4 ) else
100962: LD_ADDR_VAR 0 3
100966: PUSH
100967: LD_INT 2
100969: PPUSH
100970: LD_INT 4
100972: PPUSH
100973: CALL_OW 12
100977: ST_TO_ADDR
100978: GO 100988
// s2 := 1 ;
100980: LD_ADDR_VAR 0 3
100984: PUSH
100985: LD_INT 1
100987: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100988: LD_ADDR_VAR 0 5
100992: PUSH
100993: LD_VAR 0 6
100997: PUSH
100998: LD_INT 1
101000: ARRAY
101001: PPUSH
101002: LD_VAR 0 3
101006: PPUSH
101007: CALL_OW 259
101011: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101012: LD_VAR 0 6
101016: PUSH
101017: LD_INT 1
101019: ARRAY
101020: PPUSH
101021: LD_VAR 0 2
101025: PPUSH
101026: LD_VAR 0 5
101030: PPUSH
101031: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101035: LD_VAR 0 6
101039: PUSH
101040: LD_INT 1
101042: ARRAY
101043: PPUSH
101044: LD_VAR 0 3
101048: PPUSH
101049: LD_VAR 0 4
101053: PPUSH
101054: CALL_OW 237
// end ;
101058: PPOPN 6
101060: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101061: LD_EXP 108
101065: PUSH
101066: LD_EXP 155
101070: AND
101071: IFFALSE 101150
101073: GO 101075
101075: DISABLE
101076: LD_INT 0
101078: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101079: LD_ADDR_VAR 0 1
101083: PUSH
101084: LD_INT 22
101086: PUSH
101087: LD_OWVAR 2
101091: PUSH
101092: EMPTY
101093: LIST
101094: LIST
101095: PUSH
101096: LD_INT 30
101098: PUSH
101099: LD_INT 3
101101: PUSH
101102: EMPTY
101103: LIST
101104: LIST
101105: PUSH
101106: EMPTY
101107: LIST
101108: LIST
101109: PPUSH
101110: CALL_OW 69
101114: ST_TO_ADDR
// if not tmp then
101115: LD_VAR 0 1
101119: NOT
101120: IFFALSE 101124
// exit ;
101122: GO 101150
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101124: LD_VAR 0 1
101128: PUSH
101129: LD_INT 1
101131: PPUSH
101132: LD_VAR 0 1
101136: PPUSH
101137: CALL_OW 12
101141: ARRAY
101142: PPUSH
101143: LD_INT 1
101145: PPUSH
101146: CALL_OW 234
// end ;
101150: PPOPN 1
101152: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101153: LD_EXP 108
101157: PUSH
101158: LD_EXP 156
101162: AND
101163: IFFALSE 101275
101165: GO 101167
101167: DISABLE
101168: LD_INT 0
101170: PPUSH
101171: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101172: LD_ADDR_VAR 0 2
101176: PUSH
101177: LD_INT 22
101179: PUSH
101180: LD_OWVAR 2
101184: PUSH
101185: EMPTY
101186: LIST
101187: LIST
101188: PUSH
101189: LD_INT 2
101191: PUSH
101192: LD_INT 30
101194: PUSH
101195: LD_INT 27
101197: PUSH
101198: EMPTY
101199: LIST
101200: LIST
101201: PUSH
101202: LD_INT 30
101204: PUSH
101205: LD_INT 26
101207: PUSH
101208: EMPTY
101209: LIST
101210: LIST
101211: PUSH
101212: LD_INT 30
101214: PUSH
101215: LD_INT 28
101217: PUSH
101218: EMPTY
101219: LIST
101220: LIST
101221: PUSH
101222: EMPTY
101223: LIST
101224: LIST
101225: LIST
101226: LIST
101227: PUSH
101228: EMPTY
101229: LIST
101230: LIST
101231: PPUSH
101232: CALL_OW 69
101236: ST_TO_ADDR
// if not tmp then
101237: LD_VAR 0 2
101241: NOT
101242: IFFALSE 101246
// exit ;
101244: GO 101275
// for i in tmp do
101246: LD_ADDR_VAR 0 1
101250: PUSH
101251: LD_VAR 0 2
101255: PUSH
101256: FOR_IN
101257: IFFALSE 101273
// SetLives ( i , 1 ) ;
101259: LD_VAR 0 1
101263: PPUSH
101264: LD_INT 1
101266: PPUSH
101267: CALL_OW 234
101271: GO 101256
101273: POP
101274: POP
// end ;
101275: PPOPN 2
101277: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101278: LD_EXP 108
101282: PUSH
101283: LD_EXP 157
101287: AND
101288: IFFALSE 101575
101290: GO 101292
101292: DISABLE
101293: LD_INT 0
101295: PPUSH
101296: PPUSH
101297: PPUSH
// begin i := rand ( 1 , 7 ) ;
101298: LD_ADDR_VAR 0 1
101302: PUSH
101303: LD_INT 1
101305: PPUSH
101306: LD_INT 7
101308: PPUSH
101309: CALL_OW 12
101313: ST_TO_ADDR
// case i of 1 :
101314: LD_VAR 0 1
101318: PUSH
101319: LD_INT 1
101321: DOUBLE
101322: EQUAL
101323: IFTRUE 101327
101325: GO 101337
101327: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101328: LD_STRING earthquake(getX(game), 0, 32)
101330: PPUSH
101331: CALL_OW 559
101335: GO 101575
101337: LD_INT 2
101339: DOUBLE
101340: EQUAL
101341: IFTRUE 101345
101343: GO 101359
101345: POP
// begin ToLua ( displayStucuk(); ) ;
101346: LD_STRING displayStucuk();
101348: PPUSH
101349: CALL_OW 559
// ResetFog ;
101353: CALL_OW 335
// end ; 3 :
101357: GO 101575
101359: LD_INT 3
101361: DOUBLE
101362: EQUAL
101363: IFTRUE 101367
101365: GO 101471
101367: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101368: LD_ADDR_VAR 0 2
101372: PUSH
101373: LD_INT 22
101375: PUSH
101376: LD_OWVAR 2
101380: PUSH
101381: EMPTY
101382: LIST
101383: LIST
101384: PUSH
101385: LD_INT 25
101387: PUSH
101388: LD_INT 1
101390: PUSH
101391: EMPTY
101392: LIST
101393: LIST
101394: PUSH
101395: EMPTY
101396: LIST
101397: LIST
101398: PPUSH
101399: CALL_OW 69
101403: ST_TO_ADDR
// if not tmp then
101404: LD_VAR 0 2
101408: NOT
101409: IFFALSE 101413
// exit ;
101411: GO 101575
// un := tmp [ rand ( 1 , tmp ) ] ;
101413: LD_ADDR_VAR 0 3
101417: PUSH
101418: LD_VAR 0 2
101422: PUSH
101423: LD_INT 1
101425: PPUSH
101426: LD_VAR 0 2
101430: PPUSH
101431: CALL_OW 12
101435: ARRAY
101436: ST_TO_ADDR
// if Crawls ( un ) then
101437: LD_VAR 0 3
101441: PPUSH
101442: CALL_OW 318
101446: IFFALSE 101457
// ComWalk ( un ) ;
101448: LD_VAR 0 3
101452: PPUSH
101453: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101457: LD_VAR 0 3
101461: PPUSH
101462: LD_INT 8
101464: PPUSH
101465: CALL_OW 336
// end ; 4 :
101469: GO 101575
101471: LD_INT 4
101473: DOUBLE
101474: EQUAL
101475: IFTRUE 101479
101477: GO 101553
101479: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101480: LD_ADDR_VAR 0 2
101484: PUSH
101485: LD_INT 22
101487: PUSH
101488: LD_OWVAR 2
101492: PUSH
101493: EMPTY
101494: LIST
101495: LIST
101496: PUSH
101497: LD_INT 30
101499: PUSH
101500: LD_INT 29
101502: PUSH
101503: EMPTY
101504: LIST
101505: LIST
101506: PUSH
101507: EMPTY
101508: LIST
101509: LIST
101510: PPUSH
101511: CALL_OW 69
101515: ST_TO_ADDR
// if not tmp then
101516: LD_VAR 0 2
101520: NOT
101521: IFFALSE 101525
// exit ;
101523: GO 101575
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101525: LD_VAR 0 2
101529: PUSH
101530: LD_INT 1
101532: ARRAY
101533: PPUSH
101534: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101538: LD_VAR 0 2
101542: PUSH
101543: LD_INT 1
101545: ARRAY
101546: PPUSH
101547: CALL_OW 65
// end ; 5 .. 7 :
101551: GO 101575
101553: LD_INT 5
101555: DOUBLE
101556: GREATEREQUAL
101557: IFFALSE 101565
101559: LD_INT 7
101561: DOUBLE
101562: LESSEQUAL
101563: IFTRUE 101567
101565: GO 101574
101567: POP
// StreamSibBomb ; end ;
101568: CALL 97812 0 0
101572: GO 101575
101574: POP
// end ;
101575: PPOPN 3
101577: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101578: LD_EXP 108
101582: PUSH
101583: LD_EXP 158
101587: AND
101588: IFFALSE 101744
101590: GO 101592
101592: DISABLE
101593: LD_INT 0
101595: PPUSH
101596: PPUSH
101597: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101598: LD_ADDR_VAR 0 2
101602: PUSH
101603: LD_INT 81
101605: PUSH
101606: LD_OWVAR 2
101610: PUSH
101611: EMPTY
101612: LIST
101613: LIST
101614: PUSH
101615: LD_INT 2
101617: PUSH
101618: LD_INT 21
101620: PUSH
101621: LD_INT 1
101623: PUSH
101624: EMPTY
101625: LIST
101626: LIST
101627: PUSH
101628: LD_INT 21
101630: PUSH
101631: LD_INT 2
101633: PUSH
101634: EMPTY
101635: LIST
101636: LIST
101637: PUSH
101638: EMPTY
101639: LIST
101640: LIST
101641: LIST
101642: PUSH
101643: EMPTY
101644: LIST
101645: LIST
101646: PPUSH
101647: CALL_OW 69
101651: ST_TO_ADDR
// if not tmp then
101652: LD_VAR 0 2
101656: NOT
101657: IFFALSE 101661
// exit ;
101659: GO 101744
// p := 0 ;
101661: LD_ADDR_VAR 0 3
101665: PUSH
101666: LD_INT 0
101668: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101669: LD_INT 35
101671: PPUSH
101672: CALL_OW 67
// p := p + 1 ;
101676: LD_ADDR_VAR 0 3
101680: PUSH
101681: LD_VAR 0 3
101685: PUSH
101686: LD_INT 1
101688: PLUS
101689: ST_TO_ADDR
// for i in tmp do
101690: LD_ADDR_VAR 0 1
101694: PUSH
101695: LD_VAR 0 2
101699: PUSH
101700: FOR_IN
101701: IFFALSE 101732
// if GetLives ( i ) < 1000 then
101703: LD_VAR 0 1
101707: PPUSH
101708: CALL_OW 256
101712: PUSH
101713: LD_INT 1000
101715: LESS
101716: IFFALSE 101730
// SetLives ( i , 1000 ) ;
101718: LD_VAR 0 1
101722: PPUSH
101723: LD_INT 1000
101725: PPUSH
101726: CALL_OW 234
101730: GO 101700
101732: POP
101733: POP
// until p > 20 ;
101734: LD_VAR 0 3
101738: PUSH
101739: LD_INT 20
101741: GREATER
101742: IFFALSE 101669
// end ;
101744: PPOPN 3
101746: END
// every 0 0$1 trigger StreamModeActive and sTime do
101747: LD_EXP 108
101751: PUSH
101752: LD_EXP 159
101756: AND
101757: IFFALSE 101792
101759: GO 101761
101761: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101762: LD_INT 28
101764: PPUSH
101765: LD_OWVAR 2
101769: PPUSH
101770: LD_INT 2
101772: PPUSH
101773: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101777: LD_INT 30
101779: PPUSH
101780: LD_OWVAR 2
101784: PPUSH
101785: LD_INT 2
101787: PPUSH
101788: CALL_OW 322
// end ;
101792: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101793: LD_EXP 108
101797: PUSH
101798: LD_EXP 160
101802: AND
101803: IFFALSE 101924
101805: GO 101807
101807: DISABLE
101808: LD_INT 0
101810: PPUSH
101811: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101812: LD_ADDR_VAR 0 2
101816: PUSH
101817: LD_INT 22
101819: PUSH
101820: LD_OWVAR 2
101824: PUSH
101825: EMPTY
101826: LIST
101827: LIST
101828: PUSH
101829: LD_INT 21
101831: PUSH
101832: LD_INT 1
101834: PUSH
101835: EMPTY
101836: LIST
101837: LIST
101838: PUSH
101839: LD_INT 3
101841: PUSH
101842: LD_INT 23
101844: PUSH
101845: LD_INT 0
101847: PUSH
101848: EMPTY
101849: LIST
101850: LIST
101851: PUSH
101852: EMPTY
101853: LIST
101854: LIST
101855: PUSH
101856: EMPTY
101857: LIST
101858: LIST
101859: LIST
101860: PPUSH
101861: CALL_OW 69
101865: ST_TO_ADDR
// if not tmp then
101866: LD_VAR 0 2
101870: NOT
101871: IFFALSE 101875
// exit ;
101873: GO 101924
// for i in tmp do
101875: LD_ADDR_VAR 0 1
101879: PUSH
101880: LD_VAR 0 2
101884: PUSH
101885: FOR_IN
101886: IFFALSE 101922
// begin if Crawls ( i ) then
101888: LD_VAR 0 1
101892: PPUSH
101893: CALL_OW 318
101897: IFFALSE 101908
// ComWalk ( i ) ;
101899: LD_VAR 0 1
101903: PPUSH
101904: CALL_OW 138
// SetClass ( i , 2 ) ;
101908: LD_VAR 0 1
101912: PPUSH
101913: LD_INT 2
101915: PPUSH
101916: CALL_OW 336
// end ;
101920: GO 101885
101922: POP
101923: POP
// end ;
101924: PPOPN 2
101926: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101927: LD_EXP 108
101931: PUSH
101932: LD_EXP 161
101936: AND
101937: IFFALSE 102225
101939: GO 101941
101941: DISABLE
101942: LD_INT 0
101944: PPUSH
101945: PPUSH
101946: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101947: LD_OWVAR 2
101951: PPUSH
101952: LD_INT 9
101954: PPUSH
101955: LD_INT 1
101957: PPUSH
101958: LD_INT 1
101960: PPUSH
101961: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101965: LD_INT 9
101967: PPUSH
101968: LD_OWVAR 2
101972: PPUSH
101973: CALL_OW 343
// uc_side := 9 ;
101977: LD_ADDR_OWVAR 20
101981: PUSH
101982: LD_INT 9
101984: ST_TO_ADDR
// uc_nation := 2 ;
101985: LD_ADDR_OWVAR 21
101989: PUSH
101990: LD_INT 2
101992: ST_TO_ADDR
// hc_name := Dark Warrior ;
101993: LD_ADDR_OWVAR 26
101997: PUSH
101998: LD_STRING Dark Warrior
102000: ST_TO_ADDR
// hc_gallery :=  ;
102001: LD_ADDR_OWVAR 33
102005: PUSH
102006: LD_STRING 
102008: ST_TO_ADDR
// hc_noskilllimit := true ;
102009: LD_ADDR_OWVAR 76
102013: PUSH
102014: LD_INT 1
102016: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102017: LD_ADDR_OWVAR 31
102021: PUSH
102022: LD_INT 30
102024: PUSH
102025: LD_INT 30
102027: PUSH
102028: LD_INT 30
102030: PUSH
102031: LD_INT 30
102033: PUSH
102034: EMPTY
102035: LIST
102036: LIST
102037: LIST
102038: LIST
102039: ST_TO_ADDR
// un := CreateHuman ;
102040: LD_ADDR_VAR 0 3
102044: PUSH
102045: CALL_OW 44
102049: ST_TO_ADDR
// hc_noskilllimit := false ;
102050: LD_ADDR_OWVAR 76
102054: PUSH
102055: LD_INT 0
102057: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102058: LD_VAR 0 3
102062: PPUSH
102063: LD_INT 1
102065: PPUSH
102066: CALL_OW 51
// ToLua ( playRanger() ) ;
102070: LD_STRING playRanger()
102072: PPUSH
102073: CALL_OW 559
// p := 0 ;
102077: LD_ADDR_VAR 0 2
102081: PUSH
102082: LD_INT 0
102084: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102085: LD_INT 35
102087: PPUSH
102088: CALL_OW 67
// p := p + 1 ;
102092: LD_ADDR_VAR 0 2
102096: PUSH
102097: LD_VAR 0 2
102101: PUSH
102102: LD_INT 1
102104: PLUS
102105: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102106: LD_VAR 0 3
102110: PPUSH
102111: CALL_OW 256
102115: PUSH
102116: LD_INT 1000
102118: LESS
102119: IFFALSE 102133
// SetLives ( un , 1000 ) ;
102121: LD_VAR 0 3
102125: PPUSH
102126: LD_INT 1000
102128: PPUSH
102129: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102133: LD_VAR 0 3
102137: PPUSH
102138: LD_INT 81
102140: PUSH
102141: LD_OWVAR 2
102145: PUSH
102146: EMPTY
102147: LIST
102148: LIST
102149: PUSH
102150: LD_INT 91
102152: PUSH
102153: LD_VAR 0 3
102157: PUSH
102158: LD_INT 30
102160: PUSH
102161: EMPTY
102162: LIST
102163: LIST
102164: LIST
102165: PUSH
102166: EMPTY
102167: LIST
102168: LIST
102169: PPUSH
102170: CALL_OW 69
102174: PPUSH
102175: LD_VAR 0 3
102179: PPUSH
102180: CALL_OW 74
102184: PPUSH
102185: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102189: LD_VAR 0 2
102193: PUSH
102194: LD_INT 80
102196: GREATER
102197: PUSH
102198: LD_VAR 0 3
102202: PPUSH
102203: CALL_OW 301
102207: OR
102208: IFFALSE 102085
// if un then
102210: LD_VAR 0 3
102214: IFFALSE 102225
// RemoveUnit ( un ) ;
102216: LD_VAR 0 3
102220: PPUSH
102221: CALL_OW 64
// end ;
102225: PPOPN 3
102227: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102228: LD_EXP 162
102232: IFFALSE 102348
102234: GO 102236
102236: DISABLE
102237: LD_INT 0
102239: PPUSH
102240: PPUSH
102241: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102242: LD_ADDR_VAR 0 2
102246: PUSH
102247: LD_INT 81
102249: PUSH
102250: LD_OWVAR 2
102254: PUSH
102255: EMPTY
102256: LIST
102257: LIST
102258: PUSH
102259: LD_INT 21
102261: PUSH
102262: LD_INT 1
102264: PUSH
102265: EMPTY
102266: LIST
102267: LIST
102268: PUSH
102269: EMPTY
102270: LIST
102271: LIST
102272: PPUSH
102273: CALL_OW 69
102277: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102278: LD_STRING playComputer()
102280: PPUSH
102281: CALL_OW 559
// if not tmp then
102285: LD_VAR 0 2
102289: NOT
102290: IFFALSE 102294
// exit ;
102292: GO 102348
// for i in tmp do
102294: LD_ADDR_VAR 0 1
102298: PUSH
102299: LD_VAR 0 2
102303: PUSH
102304: FOR_IN
102305: IFFALSE 102346
// for j := 1 to 4 do
102307: LD_ADDR_VAR 0 3
102311: PUSH
102312: DOUBLE
102313: LD_INT 1
102315: DEC
102316: ST_TO_ADDR
102317: LD_INT 4
102319: PUSH
102320: FOR_TO
102321: IFFALSE 102342
// SetSkill ( i , j , 10 ) ;
102323: LD_VAR 0 1
102327: PPUSH
102328: LD_VAR 0 3
102332: PPUSH
102333: LD_INT 10
102335: PPUSH
102336: CALL_OW 237
102340: GO 102320
102342: POP
102343: POP
102344: GO 102304
102346: POP
102347: POP
// end ;
102348: PPOPN 3
102350: END
// every 0 0$1 trigger s30 do var i , tmp ;
102351: LD_EXP 163
102355: IFFALSE 102424
102357: GO 102359
102359: DISABLE
102360: LD_INT 0
102362: PPUSH
102363: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102364: LD_ADDR_VAR 0 2
102368: PUSH
102369: LD_INT 22
102371: PUSH
102372: LD_OWVAR 2
102376: PUSH
102377: EMPTY
102378: LIST
102379: LIST
102380: PPUSH
102381: CALL_OW 69
102385: ST_TO_ADDR
// if not tmp then
102386: LD_VAR 0 2
102390: NOT
102391: IFFALSE 102395
// exit ;
102393: GO 102424
// for i in tmp do
102395: LD_ADDR_VAR 0 1
102399: PUSH
102400: LD_VAR 0 2
102404: PUSH
102405: FOR_IN
102406: IFFALSE 102422
// SetLives ( i , 300 ) ;
102408: LD_VAR 0 1
102412: PPUSH
102413: LD_INT 300
102415: PPUSH
102416: CALL_OW 234
102420: GO 102405
102422: POP
102423: POP
// end ;
102424: PPOPN 2
102426: END
// every 0 0$1 trigger s60 do var i , tmp ;
102427: LD_EXP 164
102431: IFFALSE 102500
102433: GO 102435
102435: DISABLE
102436: LD_INT 0
102438: PPUSH
102439: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102440: LD_ADDR_VAR 0 2
102444: PUSH
102445: LD_INT 22
102447: PUSH
102448: LD_OWVAR 2
102452: PUSH
102453: EMPTY
102454: LIST
102455: LIST
102456: PPUSH
102457: CALL_OW 69
102461: ST_TO_ADDR
// if not tmp then
102462: LD_VAR 0 2
102466: NOT
102467: IFFALSE 102471
// exit ;
102469: GO 102500
// for i in tmp do
102471: LD_ADDR_VAR 0 1
102475: PUSH
102476: LD_VAR 0 2
102480: PUSH
102481: FOR_IN
102482: IFFALSE 102498
// SetLives ( i , 600 ) ;
102484: LD_VAR 0 1
102488: PPUSH
102489: LD_INT 600
102491: PPUSH
102492: CALL_OW 234
102496: GO 102481
102498: POP
102499: POP
// end ;
102500: PPOPN 2
102502: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102503: LD_INT 0
102505: PPUSH
// case cmd of 301 :
102506: LD_VAR 0 1
102510: PUSH
102511: LD_INT 301
102513: DOUBLE
102514: EQUAL
102515: IFTRUE 102519
102517: GO 102551
102519: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102520: LD_VAR 0 6
102524: PPUSH
102525: LD_VAR 0 7
102529: PPUSH
102530: LD_VAR 0 8
102534: PPUSH
102535: LD_VAR 0 4
102539: PPUSH
102540: LD_VAR 0 5
102544: PPUSH
102545: CALL 103760 0 5
102549: GO 102672
102551: LD_INT 302
102553: DOUBLE
102554: EQUAL
102555: IFTRUE 102559
102557: GO 102596
102559: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102560: LD_VAR 0 6
102564: PPUSH
102565: LD_VAR 0 7
102569: PPUSH
102570: LD_VAR 0 8
102574: PPUSH
102575: LD_VAR 0 9
102579: PPUSH
102580: LD_VAR 0 4
102584: PPUSH
102585: LD_VAR 0 5
102589: PPUSH
102590: CALL 103851 0 6
102594: GO 102672
102596: LD_INT 303
102598: DOUBLE
102599: EQUAL
102600: IFTRUE 102604
102602: GO 102641
102604: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102605: LD_VAR 0 6
102609: PPUSH
102610: LD_VAR 0 7
102614: PPUSH
102615: LD_VAR 0 8
102619: PPUSH
102620: LD_VAR 0 9
102624: PPUSH
102625: LD_VAR 0 4
102629: PPUSH
102630: LD_VAR 0 5
102634: PPUSH
102635: CALL 102677 0 6
102639: GO 102672
102641: LD_INT 304
102643: DOUBLE
102644: EQUAL
102645: IFTRUE 102649
102647: GO 102671
102649: POP
// hHackTeleport ( unit , x , y ) ; end ;
102650: LD_VAR 0 2
102654: PPUSH
102655: LD_VAR 0 4
102659: PPUSH
102660: LD_VAR 0 5
102664: PPUSH
102665: CALL 104444 0 3
102669: GO 102672
102671: POP
// end ;
102672: LD_VAR 0 12
102676: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102677: LD_INT 0
102679: PPUSH
102680: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102681: LD_VAR 0 1
102685: PUSH
102686: LD_INT 1
102688: LESS
102689: PUSH
102690: LD_VAR 0 1
102694: PUSH
102695: LD_INT 3
102697: GREATER
102698: OR
102699: PUSH
102700: LD_VAR 0 5
102704: PPUSH
102705: LD_VAR 0 6
102709: PPUSH
102710: CALL_OW 428
102714: OR
102715: IFFALSE 102719
// exit ;
102717: GO 103447
// uc_side := your_side ;
102719: LD_ADDR_OWVAR 20
102723: PUSH
102724: LD_OWVAR 2
102728: ST_TO_ADDR
// uc_nation := nation ;
102729: LD_ADDR_OWVAR 21
102733: PUSH
102734: LD_VAR 0 1
102738: ST_TO_ADDR
// bc_level = 1 ;
102739: LD_ADDR_OWVAR 43
102743: PUSH
102744: LD_INT 1
102746: ST_TO_ADDR
// case btype of 1 :
102747: LD_VAR 0 2
102751: PUSH
102752: LD_INT 1
102754: DOUBLE
102755: EQUAL
102756: IFTRUE 102760
102758: GO 102771
102760: POP
// bc_type := b_depot ; 2 :
102761: LD_ADDR_OWVAR 42
102765: PUSH
102766: LD_INT 0
102768: ST_TO_ADDR
102769: GO 103391
102771: LD_INT 2
102773: DOUBLE
102774: EQUAL
102775: IFTRUE 102779
102777: GO 102790
102779: POP
// bc_type := b_warehouse ; 3 :
102780: LD_ADDR_OWVAR 42
102784: PUSH
102785: LD_INT 1
102787: ST_TO_ADDR
102788: GO 103391
102790: LD_INT 3
102792: DOUBLE
102793: EQUAL
102794: IFTRUE 102798
102796: GO 102809
102798: POP
// bc_type := b_lab ; 4 .. 9 :
102799: LD_ADDR_OWVAR 42
102803: PUSH
102804: LD_INT 6
102806: ST_TO_ADDR
102807: GO 103391
102809: LD_INT 4
102811: DOUBLE
102812: GREATEREQUAL
102813: IFFALSE 102821
102815: LD_INT 9
102817: DOUBLE
102818: LESSEQUAL
102819: IFTRUE 102823
102821: GO 102883
102823: POP
// begin bc_type := b_lab_half ;
102824: LD_ADDR_OWVAR 42
102828: PUSH
102829: LD_INT 7
102831: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102832: LD_ADDR_OWVAR 44
102836: PUSH
102837: LD_INT 10
102839: PUSH
102840: LD_INT 11
102842: PUSH
102843: LD_INT 12
102845: PUSH
102846: LD_INT 15
102848: PUSH
102849: LD_INT 14
102851: PUSH
102852: LD_INT 13
102854: PUSH
102855: EMPTY
102856: LIST
102857: LIST
102858: LIST
102859: LIST
102860: LIST
102861: LIST
102862: PUSH
102863: LD_VAR 0 2
102867: PUSH
102868: LD_INT 3
102870: MINUS
102871: ARRAY
102872: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
102873: LD_ADDR_OWVAR 45
102877: PUSH
102878: LD_INT 9
102880: ST_TO_ADDR
// end ; 10 .. 13 :
102881: GO 103391
102883: LD_INT 10
102885: DOUBLE
102886: GREATEREQUAL
102887: IFFALSE 102895
102889: LD_INT 13
102891: DOUBLE
102892: LESSEQUAL
102893: IFTRUE 102897
102895: GO 102974
102897: POP
// begin bc_type := b_lab_full ;
102898: LD_ADDR_OWVAR 42
102902: PUSH
102903: LD_INT 8
102905: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102906: LD_ADDR_OWVAR 44
102910: PUSH
102911: LD_INT 10
102913: PUSH
102914: LD_INT 12
102916: PUSH
102917: LD_INT 14
102919: PUSH
102920: LD_INT 13
102922: PUSH
102923: EMPTY
102924: LIST
102925: LIST
102926: LIST
102927: LIST
102928: PUSH
102929: LD_VAR 0 2
102933: PUSH
102934: LD_INT 9
102936: MINUS
102937: ARRAY
102938: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102939: LD_ADDR_OWVAR 45
102943: PUSH
102944: LD_INT 11
102946: PUSH
102947: LD_INT 15
102949: PUSH
102950: LD_INT 12
102952: PUSH
102953: LD_INT 15
102955: PUSH
102956: EMPTY
102957: LIST
102958: LIST
102959: LIST
102960: LIST
102961: PUSH
102962: LD_VAR 0 2
102966: PUSH
102967: LD_INT 9
102969: MINUS
102970: ARRAY
102971: ST_TO_ADDR
// end ; 14 :
102972: GO 103391
102974: LD_INT 14
102976: DOUBLE
102977: EQUAL
102978: IFTRUE 102982
102980: GO 102993
102982: POP
// bc_type := b_workshop ; 15 :
102983: LD_ADDR_OWVAR 42
102987: PUSH
102988: LD_INT 2
102990: ST_TO_ADDR
102991: GO 103391
102993: LD_INT 15
102995: DOUBLE
102996: EQUAL
102997: IFTRUE 103001
102999: GO 103012
103001: POP
// bc_type := b_factory ; 16 :
103002: LD_ADDR_OWVAR 42
103006: PUSH
103007: LD_INT 3
103009: ST_TO_ADDR
103010: GO 103391
103012: LD_INT 16
103014: DOUBLE
103015: EQUAL
103016: IFTRUE 103020
103018: GO 103031
103020: POP
// bc_type := b_ext_gun ; 17 :
103021: LD_ADDR_OWVAR 42
103025: PUSH
103026: LD_INT 17
103028: ST_TO_ADDR
103029: GO 103391
103031: LD_INT 17
103033: DOUBLE
103034: EQUAL
103035: IFTRUE 103039
103037: GO 103067
103039: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103040: LD_ADDR_OWVAR 42
103044: PUSH
103045: LD_INT 19
103047: PUSH
103048: LD_INT 23
103050: PUSH
103051: LD_INT 19
103053: PUSH
103054: EMPTY
103055: LIST
103056: LIST
103057: LIST
103058: PUSH
103059: LD_VAR 0 1
103063: ARRAY
103064: ST_TO_ADDR
103065: GO 103391
103067: LD_INT 18
103069: DOUBLE
103070: EQUAL
103071: IFTRUE 103075
103073: GO 103086
103075: POP
// bc_type := b_ext_radar ; 19 :
103076: LD_ADDR_OWVAR 42
103080: PUSH
103081: LD_INT 20
103083: ST_TO_ADDR
103084: GO 103391
103086: LD_INT 19
103088: DOUBLE
103089: EQUAL
103090: IFTRUE 103094
103092: GO 103105
103094: POP
// bc_type := b_ext_radio ; 20 :
103095: LD_ADDR_OWVAR 42
103099: PUSH
103100: LD_INT 22
103102: ST_TO_ADDR
103103: GO 103391
103105: LD_INT 20
103107: DOUBLE
103108: EQUAL
103109: IFTRUE 103113
103111: GO 103124
103113: POP
// bc_type := b_ext_siberium ; 21 :
103114: LD_ADDR_OWVAR 42
103118: PUSH
103119: LD_INT 21
103121: ST_TO_ADDR
103122: GO 103391
103124: LD_INT 21
103126: DOUBLE
103127: EQUAL
103128: IFTRUE 103132
103130: GO 103143
103132: POP
// bc_type := b_ext_computer ; 22 :
103133: LD_ADDR_OWVAR 42
103137: PUSH
103138: LD_INT 24
103140: ST_TO_ADDR
103141: GO 103391
103143: LD_INT 22
103145: DOUBLE
103146: EQUAL
103147: IFTRUE 103151
103149: GO 103162
103151: POP
// bc_type := b_ext_track ; 23 :
103152: LD_ADDR_OWVAR 42
103156: PUSH
103157: LD_INT 16
103159: ST_TO_ADDR
103160: GO 103391
103162: LD_INT 23
103164: DOUBLE
103165: EQUAL
103166: IFTRUE 103170
103168: GO 103181
103170: POP
// bc_type := b_ext_laser ; 24 :
103171: LD_ADDR_OWVAR 42
103175: PUSH
103176: LD_INT 25
103178: ST_TO_ADDR
103179: GO 103391
103181: LD_INT 24
103183: DOUBLE
103184: EQUAL
103185: IFTRUE 103189
103187: GO 103200
103189: POP
// bc_type := b_control_tower ; 25 :
103190: LD_ADDR_OWVAR 42
103194: PUSH
103195: LD_INT 36
103197: ST_TO_ADDR
103198: GO 103391
103200: LD_INT 25
103202: DOUBLE
103203: EQUAL
103204: IFTRUE 103208
103206: GO 103219
103208: POP
// bc_type := b_breastwork ; 26 :
103209: LD_ADDR_OWVAR 42
103213: PUSH
103214: LD_INT 31
103216: ST_TO_ADDR
103217: GO 103391
103219: LD_INT 26
103221: DOUBLE
103222: EQUAL
103223: IFTRUE 103227
103225: GO 103238
103227: POP
// bc_type := b_bunker ; 27 :
103228: LD_ADDR_OWVAR 42
103232: PUSH
103233: LD_INT 32
103235: ST_TO_ADDR
103236: GO 103391
103238: LD_INT 27
103240: DOUBLE
103241: EQUAL
103242: IFTRUE 103246
103244: GO 103257
103246: POP
// bc_type := b_turret ; 28 :
103247: LD_ADDR_OWVAR 42
103251: PUSH
103252: LD_INT 33
103254: ST_TO_ADDR
103255: GO 103391
103257: LD_INT 28
103259: DOUBLE
103260: EQUAL
103261: IFTRUE 103265
103263: GO 103276
103265: POP
// bc_type := b_armoury ; 29 :
103266: LD_ADDR_OWVAR 42
103270: PUSH
103271: LD_INT 4
103273: ST_TO_ADDR
103274: GO 103391
103276: LD_INT 29
103278: DOUBLE
103279: EQUAL
103280: IFTRUE 103284
103282: GO 103295
103284: POP
// bc_type := b_barracks ; 30 :
103285: LD_ADDR_OWVAR 42
103289: PUSH
103290: LD_INT 5
103292: ST_TO_ADDR
103293: GO 103391
103295: LD_INT 30
103297: DOUBLE
103298: EQUAL
103299: IFTRUE 103303
103301: GO 103314
103303: POP
// bc_type := b_solar_power ; 31 :
103304: LD_ADDR_OWVAR 42
103308: PUSH
103309: LD_INT 27
103311: ST_TO_ADDR
103312: GO 103391
103314: LD_INT 31
103316: DOUBLE
103317: EQUAL
103318: IFTRUE 103322
103320: GO 103333
103322: POP
// bc_type := b_oil_power ; 32 :
103323: LD_ADDR_OWVAR 42
103327: PUSH
103328: LD_INT 26
103330: ST_TO_ADDR
103331: GO 103391
103333: LD_INT 32
103335: DOUBLE
103336: EQUAL
103337: IFTRUE 103341
103339: GO 103352
103341: POP
// bc_type := b_siberite_power ; 33 :
103342: LD_ADDR_OWVAR 42
103346: PUSH
103347: LD_INT 28
103349: ST_TO_ADDR
103350: GO 103391
103352: LD_INT 33
103354: DOUBLE
103355: EQUAL
103356: IFTRUE 103360
103358: GO 103371
103360: POP
// bc_type := b_oil_mine ; 34 :
103361: LD_ADDR_OWVAR 42
103365: PUSH
103366: LD_INT 29
103368: ST_TO_ADDR
103369: GO 103391
103371: LD_INT 34
103373: DOUBLE
103374: EQUAL
103375: IFTRUE 103379
103377: GO 103390
103379: POP
// bc_type := b_siberite_mine ; end ;
103380: LD_ADDR_OWVAR 42
103384: PUSH
103385: LD_INT 30
103387: ST_TO_ADDR
103388: GO 103391
103390: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103391: LD_ADDR_VAR 0 8
103395: PUSH
103396: LD_VAR 0 5
103400: PPUSH
103401: LD_VAR 0 6
103405: PPUSH
103406: LD_VAR 0 3
103410: PPUSH
103411: CALL_OW 47
103415: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103416: LD_OWVAR 42
103420: PUSH
103421: LD_INT 32
103423: PUSH
103424: LD_INT 33
103426: PUSH
103427: EMPTY
103428: LIST
103429: LIST
103430: IN
103431: IFFALSE 103447
// PlaceWeaponTurret ( b , weapon ) ;
103433: LD_VAR 0 8
103437: PPUSH
103438: LD_VAR 0 4
103442: PPUSH
103443: CALL_OW 431
// end ;
103447: LD_VAR 0 7
103451: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103452: LD_INT 0
103454: PPUSH
103455: PPUSH
103456: PPUSH
103457: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103458: LD_ADDR_VAR 0 4
103462: PUSH
103463: LD_INT 22
103465: PUSH
103466: LD_OWVAR 2
103470: PUSH
103471: EMPTY
103472: LIST
103473: LIST
103474: PUSH
103475: LD_INT 2
103477: PUSH
103478: LD_INT 30
103480: PUSH
103481: LD_INT 0
103483: PUSH
103484: EMPTY
103485: LIST
103486: LIST
103487: PUSH
103488: LD_INT 30
103490: PUSH
103491: LD_INT 1
103493: PUSH
103494: EMPTY
103495: LIST
103496: LIST
103497: PUSH
103498: EMPTY
103499: LIST
103500: LIST
103501: LIST
103502: PUSH
103503: EMPTY
103504: LIST
103505: LIST
103506: PPUSH
103507: CALL_OW 69
103511: ST_TO_ADDR
// if not tmp then
103512: LD_VAR 0 4
103516: NOT
103517: IFFALSE 103521
// exit ;
103519: GO 103580
// for i in tmp do
103521: LD_ADDR_VAR 0 2
103525: PUSH
103526: LD_VAR 0 4
103530: PUSH
103531: FOR_IN
103532: IFFALSE 103578
// for j = 1 to 3 do
103534: LD_ADDR_VAR 0 3
103538: PUSH
103539: DOUBLE
103540: LD_INT 1
103542: DEC
103543: ST_TO_ADDR
103544: LD_INT 3
103546: PUSH
103547: FOR_TO
103548: IFFALSE 103574
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103550: LD_VAR 0 2
103554: PPUSH
103555: CALL_OW 274
103559: PPUSH
103560: LD_VAR 0 3
103564: PPUSH
103565: LD_INT 99999
103567: PPUSH
103568: CALL_OW 277
103572: GO 103547
103574: POP
103575: POP
103576: GO 103531
103578: POP
103579: POP
// end ;
103580: LD_VAR 0 1
103584: RET
// export function hHackSetLevel10 ; var i , j ; begin
103585: LD_INT 0
103587: PPUSH
103588: PPUSH
103589: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103590: LD_ADDR_VAR 0 2
103594: PUSH
103595: LD_INT 21
103597: PUSH
103598: LD_INT 1
103600: PUSH
103601: EMPTY
103602: LIST
103603: LIST
103604: PPUSH
103605: CALL_OW 69
103609: PUSH
103610: FOR_IN
103611: IFFALSE 103663
// if IsSelected ( i ) then
103613: LD_VAR 0 2
103617: PPUSH
103618: CALL_OW 306
103622: IFFALSE 103661
// begin for j := 1 to 4 do
103624: LD_ADDR_VAR 0 3
103628: PUSH
103629: DOUBLE
103630: LD_INT 1
103632: DEC
103633: ST_TO_ADDR
103634: LD_INT 4
103636: PUSH
103637: FOR_TO
103638: IFFALSE 103659
// SetSkill ( i , j , 10 ) ;
103640: LD_VAR 0 2
103644: PPUSH
103645: LD_VAR 0 3
103649: PPUSH
103650: LD_INT 10
103652: PPUSH
103653: CALL_OW 237
103657: GO 103637
103659: POP
103660: POP
// end ;
103661: GO 103610
103663: POP
103664: POP
// end ;
103665: LD_VAR 0 1
103669: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103670: LD_INT 0
103672: PPUSH
103673: PPUSH
103674: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103675: LD_ADDR_VAR 0 2
103679: PUSH
103680: LD_INT 22
103682: PUSH
103683: LD_OWVAR 2
103687: PUSH
103688: EMPTY
103689: LIST
103690: LIST
103691: PUSH
103692: LD_INT 21
103694: PUSH
103695: LD_INT 1
103697: PUSH
103698: EMPTY
103699: LIST
103700: LIST
103701: PUSH
103702: EMPTY
103703: LIST
103704: LIST
103705: PPUSH
103706: CALL_OW 69
103710: PUSH
103711: FOR_IN
103712: IFFALSE 103753
// begin for j := 1 to 4 do
103714: LD_ADDR_VAR 0 3
103718: PUSH
103719: DOUBLE
103720: LD_INT 1
103722: DEC
103723: ST_TO_ADDR
103724: LD_INT 4
103726: PUSH
103727: FOR_TO
103728: IFFALSE 103749
// SetSkill ( i , j , 10 ) ;
103730: LD_VAR 0 2
103734: PPUSH
103735: LD_VAR 0 3
103739: PPUSH
103740: LD_INT 10
103742: PPUSH
103743: CALL_OW 237
103747: GO 103727
103749: POP
103750: POP
// end ;
103751: GO 103711
103753: POP
103754: POP
// end ;
103755: LD_VAR 0 1
103759: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103760: LD_INT 0
103762: PPUSH
// uc_side := your_side ;
103763: LD_ADDR_OWVAR 20
103767: PUSH
103768: LD_OWVAR 2
103772: ST_TO_ADDR
// uc_nation := nation ;
103773: LD_ADDR_OWVAR 21
103777: PUSH
103778: LD_VAR 0 1
103782: ST_TO_ADDR
// InitHc ;
103783: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103787: LD_INT 0
103789: PPUSH
103790: LD_VAR 0 2
103794: PPUSH
103795: LD_VAR 0 3
103799: PPUSH
103800: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103804: LD_VAR 0 4
103808: PPUSH
103809: LD_VAR 0 5
103813: PPUSH
103814: CALL_OW 428
103818: PUSH
103819: LD_INT 0
103821: EQUAL
103822: IFFALSE 103846
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103824: CALL_OW 44
103828: PPUSH
103829: LD_VAR 0 4
103833: PPUSH
103834: LD_VAR 0 5
103838: PPUSH
103839: LD_INT 1
103841: PPUSH
103842: CALL_OW 48
// end ;
103846: LD_VAR 0 6
103850: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103851: LD_INT 0
103853: PPUSH
103854: PPUSH
// uc_side := your_side ;
103855: LD_ADDR_OWVAR 20
103859: PUSH
103860: LD_OWVAR 2
103864: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103865: LD_VAR 0 1
103869: PUSH
103870: LD_INT 1
103872: PUSH
103873: LD_INT 2
103875: PUSH
103876: LD_INT 3
103878: PUSH
103879: LD_INT 4
103881: PUSH
103882: LD_INT 5
103884: PUSH
103885: EMPTY
103886: LIST
103887: LIST
103888: LIST
103889: LIST
103890: LIST
103891: IN
103892: IFFALSE 103904
// uc_nation := nation_american else
103894: LD_ADDR_OWVAR 21
103898: PUSH
103899: LD_INT 1
103901: ST_TO_ADDR
103902: GO 103947
// if chassis in [ 11 , 12 , 13 , 14 ] then
103904: LD_VAR 0 1
103908: PUSH
103909: LD_INT 11
103911: PUSH
103912: LD_INT 12
103914: PUSH
103915: LD_INT 13
103917: PUSH
103918: LD_INT 14
103920: PUSH
103921: EMPTY
103922: LIST
103923: LIST
103924: LIST
103925: LIST
103926: IN
103927: IFFALSE 103939
// uc_nation := nation_arabian else
103929: LD_ADDR_OWVAR 21
103933: PUSH
103934: LD_INT 2
103936: ST_TO_ADDR
103937: GO 103947
// uc_nation := nation_russian ;
103939: LD_ADDR_OWVAR 21
103943: PUSH
103944: LD_INT 3
103946: ST_TO_ADDR
// vc_chassis := chassis ;
103947: LD_ADDR_OWVAR 37
103951: PUSH
103952: LD_VAR 0 1
103956: ST_TO_ADDR
// vc_engine := engine ;
103957: LD_ADDR_OWVAR 39
103961: PUSH
103962: LD_VAR 0 2
103966: ST_TO_ADDR
// vc_control := control ;
103967: LD_ADDR_OWVAR 38
103971: PUSH
103972: LD_VAR 0 3
103976: ST_TO_ADDR
// vc_weapon := weapon ;
103977: LD_ADDR_OWVAR 40
103981: PUSH
103982: LD_VAR 0 4
103986: ST_TO_ADDR
// un := CreateVehicle ;
103987: LD_ADDR_VAR 0 8
103991: PUSH
103992: CALL_OW 45
103996: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103997: LD_VAR 0 8
104001: PPUSH
104002: LD_INT 0
104004: PPUSH
104005: LD_INT 5
104007: PPUSH
104008: CALL_OW 12
104012: PPUSH
104013: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104017: LD_VAR 0 8
104021: PPUSH
104022: LD_VAR 0 5
104026: PPUSH
104027: LD_VAR 0 6
104031: PPUSH
104032: LD_INT 1
104034: PPUSH
104035: CALL_OW 48
// end ;
104039: LD_VAR 0 7
104043: RET
// export hInvincible ; every 1 do
104044: GO 104046
104046: DISABLE
// hInvincible := [ ] ;
104047: LD_ADDR_EXP 165
104051: PUSH
104052: EMPTY
104053: ST_TO_ADDR
104054: END
// every 10 do var i ;
104055: GO 104057
104057: DISABLE
104058: LD_INT 0
104060: PPUSH
// begin enable ;
104061: ENABLE
// if not hInvincible then
104062: LD_EXP 165
104066: NOT
104067: IFFALSE 104071
// exit ;
104069: GO 104115
// for i in hInvincible do
104071: LD_ADDR_VAR 0 1
104075: PUSH
104076: LD_EXP 165
104080: PUSH
104081: FOR_IN
104082: IFFALSE 104113
// if GetLives ( i ) < 1000 then
104084: LD_VAR 0 1
104088: PPUSH
104089: CALL_OW 256
104093: PUSH
104094: LD_INT 1000
104096: LESS
104097: IFFALSE 104111
// SetLives ( i , 1000 ) ;
104099: LD_VAR 0 1
104103: PPUSH
104104: LD_INT 1000
104106: PPUSH
104107: CALL_OW 234
104111: GO 104081
104113: POP
104114: POP
// end ;
104115: PPOPN 1
104117: END
// export function hHackInvincible ; var i ; begin
104118: LD_INT 0
104120: PPUSH
104121: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104122: LD_ADDR_VAR 0 2
104126: PUSH
104127: LD_INT 2
104129: PUSH
104130: LD_INT 21
104132: PUSH
104133: LD_INT 1
104135: PUSH
104136: EMPTY
104137: LIST
104138: LIST
104139: PUSH
104140: LD_INT 21
104142: PUSH
104143: LD_INT 2
104145: PUSH
104146: EMPTY
104147: LIST
104148: LIST
104149: PUSH
104150: EMPTY
104151: LIST
104152: LIST
104153: LIST
104154: PPUSH
104155: CALL_OW 69
104159: PUSH
104160: FOR_IN
104161: IFFALSE 104222
// if IsSelected ( i ) then
104163: LD_VAR 0 2
104167: PPUSH
104168: CALL_OW 306
104172: IFFALSE 104220
// begin if i in hInvincible then
104174: LD_VAR 0 2
104178: PUSH
104179: LD_EXP 165
104183: IN
104184: IFFALSE 104204
// hInvincible := hInvincible diff i else
104186: LD_ADDR_EXP 165
104190: PUSH
104191: LD_EXP 165
104195: PUSH
104196: LD_VAR 0 2
104200: DIFF
104201: ST_TO_ADDR
104202: GO 104220
// hInvincible := hInvincible union i ;
104204: LD_ADDR_EXP 165
104208: PUSH
104209: LD_EXP 165
104213: PUSH
104214: LD_VAR 0 2
104218: UNION
104219: ST_TO_ADDR
// end ;
104220: GO 104160
104222: POP
104223: POP
// end ;
104224: LD_VAR 0 1
104228: RET
// export function hHackInvisible ; var i , j ; begin
104229: LD_INT 0
104231: PPUSH
104232: PPUSH
104233: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104234: LD_ADDR_VAR 0 2
104238: PUSH
104239: LD_INT 21
104241: PUSH
104242: LD_INT 1
104244: PUSH
104245: EMPTY
104246: LIST
104247: LIST
104248: PPUSH
104249: CALL_OW 69
104253: PUSH
104254: FOR_IN
104255: IFFALSE 104279
// if IsSelected ( i ) then
104257: LD_VAR 0 2
104261: PPUSH
104262: CALL_OW 306
104266: IFFALSE 104277
// ComForceInvisible ( i ) ;
104268: LD_VAR 0 2
104272: PPUSH
104273: CALL_OW 496
104277: GO 104254
104279: POP
104280: POP
// end ;
104281: LD_VAR 0 1
104285: RET
// export function hHackChangeYourSide ; begin
104286: LD_INT 0
104288: PPUSH
// if your_side = 8 then
104289: LD_OWVAR 2
104293: PUSH
104294: LD_INT 8
104296: EQUAL
104297: IFFALSE 104309
// your_side := 0 else
104299: LD_ADDR_OWVAR 2
104303: PUSH
104304: LD_INT 0
104306: ST_TO_ADDR
104307: GO 104323
// your_side := your_side + 1 ;
104309: LD_ADDR_OWVAR 2
104313: PUSH
104314: LD_OWVAR 2
104318: PUSH
104319: LD_INT 1
104321: PLUS
104322: ST_TO_ADDR
// end ;
104323: LD_VAR 0 1
104327: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104328: LD_INT 0
104330: PPUSH
104331: PPUSH
104332: PPUSH
// for i in all_units do
104333: LD_ADDR_VAR 0 2
104337: PUSH
104338: LD_OWVAR 3
104342: PUSH
104343: FOR_IN
104344: IFFALSE 104422
// if IsSelected ( i ) then
104346: LD_VAR 0 2
104350: PPUSH
104351: CALL_OW 306
104355: IFFALSE 104420
// begin j := GetSide ( i ) ;
104357: LD_ADDR_VAR 0 3
104361: PUSH
104362: LD_VAR 0 2
104366: PPUSH
104367: CALL_OW 255
104371: ST_TO_ADDR
// if j = 8 then
104372: LD_VAR 0 3
104376: PUSH
104377: LD_INT 8
104379: EQUAL
104380: IFFALSE 104392
// j := 0 else
104382: LD_ADDR_VAR 0 3
104386: PUSH
104387: LD_INT 0
104389: ST_TO_ADDR
104390: GO 104406
// j := j + 1 ;
104392: LD_ADDR_VAR 0 3
104396: PUSH
104397: LD_VAR 0 3
104401: PUSH
104402: LD_INT 1
104404: PLUS
104405: ST_TO_ADDR
// SetSide ( i , j ) ;
104406: LD_VAR 0 2
104410: PPUSH
104411: LD_VAR 0 3
104415: PPUSH
104416: CALL_OW 235
// end ;
104420: GO 104343
104422: POP
104423: POP
// end ;
104424: LD_VAR 0 1
104428: RET
// export function hHackFog ; begin
104429: LD_INT 0
104431: PPUSH
// FogOff ( true ) ;
104432: LD_INT 1
104434: PPUSH
104435: CALL_OW 344
// end ;
104439: LD_VAR 0 1
104443: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104444: LD_INT 0
104446: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104447: LD_VAR 0 1
104451: PPUSH
104452: LD_VAR 0 2
104456: PPUSH
104457: LD_VAR 0 3
104461: PPUSH
104462: LD_INT 1
104464: PPUSH
104465: LD_INT 1
104467: PPUSH
104468: CALL_OW 483
// CenterOnXY ( x , y ) ;
104472: LD_VAR 0 2
104476: PPUSH
104477: LD_VAR 0 3
104481: PPUSH
104482: CALL_OW 84
// end ;
104486: LD_VAR 0 4
104490: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104491: LD_INT 0
104493: PPUSH
104494: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104495: LD_VAR 0 1
104499: NOT
104500: PUSH
104501: LD_VAR 0 2
104505: PPUSH
104506: LD_VAR 0 3
104510: PPUSH
104511: CALL_OW 488
104515: NOT
104516: OR
104517: PUSH
104518: LD_VAR 0 1
104522: PPUSH
104523: CALL_OW 266
104527: PUSH
104528: LD_INT 3
104530: NONEQUAL
104531: PUSH
104532: LD_VAR 0 1
104536: PPUSH
104537: CALL_OW 247
104541: PUSH
104542: LD_INT 1
104544: EQUAL
104545: NOT
104546: AND
104547: OR
104548: IFFALSE 104552
// exit ;
104550: GO 104701
// if GetType ( factory ) = unit_human then
104552: LD_VAR 0 1
104556: PPUSH
104557: CALL_OW 247
104561: PUSH
104562: LD_INT 1
104564: EQUAL
104565: IFFALSE 104582
// factory := IsInUnit ( factory ) ;
104567: LD_ADDR_VAR 0 1
104571: PUSH
104572: LD_VAR 0 1
104576: PPUSH
104577: CALL_OW 310
104581: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
104582: LD_VAR 0 1
104586: PPUSH
104587: CALL_OW 266
104591: PUSH
104592: LD_INT 3
104594: NONEQUAL
104595: IFFALSE 104599
// exit ;
104597: GO 104701
// if HexInfo ( x , y ) = factory then
104599: LD_VAR 0 2
104603: PPUSH
104604: LD_VAR 0 3
104608: PPUSH
104609: CALL_OW 428
104613: PUSH
104614: LD_VAR 0 1
104618: EQUAL
104619: IFFALSE 104646
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
104621: LD_ADDR_EXP 166
104625: PUSH
104626: LD_EXP 166
104630: PPUSH
104631: LD_VAR 0 1
104635: PPUSH
104636: LD_INT 0
104638: PPUSH
104639: CALL_OW 1
104643: ST_TO_ADDR
104644: GO 104697
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104646: LD_ADDR_EXP 166
104650: PUSH
104651: LD_EXP 166
104655: PPUSH
104656: LD_VAR 0 1
104660: PPUSH
104661: LD_VAR 0 1
104665: PPUSH
104666: CALL_OW 255
104670: PUSH
104671: LD_VAR 0 1
104675: PUSH
104676: LD_VAR 0 2
104680: PUSH
104681: LD_VAR 0 3
104685: PUSH
104686: EMPTY
104687: LIST
104688: LIST
104689: LIST
104690: LIST
104691: PPUSH
104692: CALL_OW 1
104696: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104697: CALL 104706 0 0
// end ;
104701: LD_VAR 0 4
104705: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
104706: LD_INT 0
104708: PPUSH
104709: PPUSH
104710: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104711: LD_STRING resetFactoryWaypoint();
104713: PPUSH
104714: CALL_OW 559
// if factoryWaypoints then
104718: LD_EXP 166
104722: IFFALSE 104848
// begin list := PrepareArray ( factoryWaypoints ) ;
104724: LD_ADDR_VAR 0 3
104728: PUSH
104729: LD_EXP 166
104733: PPUSH
104734: CALL 57953 0 1
104738: ST_TO_ADDR
// for i := 1 to list do
104739: LD_ADDR_VAR 0 2
104743: PUSH
104744: DOUBLE
104745: LD_INT 1
104747: DEC
104748: ST_TO_ADDR
104749: LD_VAR 0 3
104753: PUSH
104754: FOR_TO
104755: IFFALSE 104846
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104757: LD_STRING setFactoryWaypointXY(
104759: PUSH
104760: LD_VAR 0 3
104764: PUSH
104765: LD_VAR 0 2
104769: ARRAY
104770: PUSH
104771: LD_INT 1
104773: ARRAY
104774: STR
104775: PUSH
104776: LD_STRING ,
104778: STR
104779: PUSH
104780: LD_VAR 0 3
104784: PUSH
104785: LD_VAR 0 2
104789: ARRAY
104790: PUSH
104791: LD_INT 2
104793: ARRAY
104794: STR
104795: PUSH
104796: LD_STRING ,
104798: STR
104799: PUSH
104800: LD_VAR 0 3
104804: PUSH
104805: LD_VAR 0 2
104809: ARRAY
104810: PUSH
104811: LD_INT 3
104813: ARRAY
104814: STR
104815: PUSH
104816: LD_STRING ,
104818: STR
104819: PUSH
104820: LD_VAR 0 3
104824: PUSH
104825: LD_VAR 0 2
104829: ARRAY
104830: PUSH
104831: LD_INT 4
104833: ARRAY
104834: STR
104835: PUSH
104836: LD_STRING )
104838: STR
104839: PPUSH
104840: CALL_OW 559
104844: GO 104754
104846: POP
104847: POP
// end ; end ;
104848: LD_VAR 0 1
104852: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
104853: LD_INT 0
104855: PPUSH
// if HexInfo ( x , y ) = warehouse then
104856: LD_VAR 0 2
104860: PPUSH
104861: LD_VAR 0 3
104865: PPUSH
104866: CALL_OW 428
104870: PUSH
104871: LD_VAR 0 1
104875: EQUAL
104876: IFFALSE 104903
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
104878: LD_ADDR_EXP 167
104882: PUSH
104883: LD_EXP 167
104887: PPUSH
104888: LD_VAR 0 1
104892: PPUSH
104893: LD_INT 0
104895: PPUSH
104896: CALL_OW 1
104900: ST_TO_ADDR
104901: GO 104954
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
104903: LD_ADDR_EXP 167
104907: PUSH
104908: LD_EXP 167
104912: PPUSH
104913: LD_VAR 0 1
104917: PPUSH
104918: LD_VAR 0 1
104922: PPUSH
104923: CALL_OW 255
104927: PUSH
104928: LD_VAR 0 1
104932: PUSH
104933: LD_VAR 0 2
104937: PUSH
104938: LD_VAR 0 3
104942: PUSH
104943: EMPTY
104944: LIST
104945: LIST
104946: LIST
104947: LIST
104948: PPUSH
104949: CALL_OW 1
104953: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
104954: CALL 104963 0 0
// end ;
104958: LD_VAR 0 4
104962: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
104963: LD_INT 0
104965: PPUSH
104966: PPUSH
104967: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
104968: LD_STRING resetWarehouseGatheringPoints();
104970: PPUSH
104971: CALL_OW 559
// if warehouseGatheringPoints then
104975: LD_EXP 167
104979: IFFALSE 105105
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
104981: LD_ADDR_VAR 0 3
104985: PUSH
104986: LD_EXP 167
104990: PPUSH
104991: CALL 57953 0 1
104995: ST_TO_ADDR
// for i := 1 to list do
104996: LD_ADDR_VAR 0 2
105000: PUSH
105001: DOUBLE
105002: LD_INT 1
105004: DEC
105005: ST_TO_ADDR
105006: LD_VAR 0 3
105010: PUSH
105011: FOR_TO
105012: IFFALSE 105103
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105014: LD_STRING setWarehouseGatheringPointXY(
105016: PUSH
105017: LD_VAR 0 3
105021: PUSH
105022: LD_VAR 0 2
105026: ARRAY
105027: PUSH
105028: LD_INT 1
105030: ARRAY
105031: STR
105032: PUSH
105033: LD_STRING ,
105035: STR
105036: PUSH
105037: LD_VAR 0 3
105041: PUSH
105042: LD_VAR 0 2
105046: ARRAY
105047: PUSH
105048: LD_INT 2
105050: ARRAY
105051: STR
105052: PUSH
105053: LD_STRING ,
105055: STR
105056: PUSH
105057: LD_VAR 0 3
105061: PUSH
105062: LD_VAR 0 2
105066: ARRAY
105067: PUSH
105068: LD_INT 3
105070: ARRAY
105071: STR
105072: PUSH
105073: LD_STRING ,
105075: STR
105076: PUSH
105077: LD_VAR 0 3
105081: PUSH
105082: LD_VAR 0 2
105086: ARRAY
105087: PUSH
105088: LD_INT 4
105090: ARRAY
105091: STR
105092: PUSH
105093: LD_STRING )
105095: STR
105096: PPUSH
105097: CALL_OW 559
105101: GO 105011
105103: POP
105104: POP
// end ; end ;
105105: LD_VAR 0 1
105109: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
105110: LD_EXP 167
105114: IFFALSE 105799
105116: GO 105118
105118: DISABLE
105119: LD_INT 0
105121: PPUSH
105122: PPUSH
105123: PPUSH
105124: PPUSH
105125: PPUSH
105126: PPUSH
105127: PPUSH
105128: PPUSH
105129: PPUSH
// begin enable ;
105130: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
105131: LD_ADDR_VAR 0 3
105135: PUSH
105136: LD_EXP 167
105140: PPUSH
105141: CALL 57953 0 1
105145: ST_TO_ADDR
// if not list then
105146: LD_VAR 0 3
105150: NOT
105151: IFFALSE 105155
// exit ;
105153: GO 105799
// for i := 1 to list do
105155: LD_ADDR_VAR 0 1
105159: PUSH
105160: DOUBLE
105161: LD_INT 1
105163: DEC
105164: ST_TO_ADDR
105165: LD_VAR 0 3
105169: PUSH
105170: FOR_TO
105171: IFFALSE 105797
// begin depot := list [ i ] [ 2 ] ;
105173: LD_ADDR_VAR 0 8
105177: PUSH
105178: LD_VAR 0 3
105182: PUSH
105183: LD_VAR 0 1
105187: ARRAY
105188: PUSH
105189: LD_INT 2
105191: ARRAY
105192: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105193: LD_ADDR_VAR 0 5
105197: PUSH
105198: LD_VAR 0 3
105202: PUSH
105203: LD_VAR 0 1
105207: ARRAY
105208: PUSH
105209: LD_INT 1
105211: ARRAY
105212: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105213: LD_VAR 0 8
105217: PPUSH
105218: CALL_OW 301
105222: PUSH
105223: LD_VAR 0 5
105227: PUSH
105228: LD_VAR 0 8
105232: PPUSH
105233: CALL_OW 255
105237: NONEQUAL
105238: OR
105239: IFFALSE 105268
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105241: LD_ADDR_EXP 167
105245: PUSH
105246: LD_EXP 167
105250: PPUSH
105251: LD_VAR 0 8
105255: PPUSH
105256: LD_INT 0
105258: PPUSH
105259: CALL_OW 1
105263: ST_TO_ADDR
// exit ;
105264: POP
105265: POP
105266: GO 105799
// end ; x := list [ i ] [ 3 ] ;
105268: LD_ADDR_VAR 0 6
105272: PUSH
105273: LD_VAR 0 3
105277: PUSH
105278: LD_VAR 0 1
105282: ARRAY
105283: PUSH
105284: LD_INT 3
105286: ARRAY
105287: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105288: LD_ADDR_VAR 0 7
105292: PUSH
105293: LD_VAR 0 3
105297: PUSH
105298: LD_VAR 0 1
105302: ARRAY
105303: PUSH
105304: LD_INT 4
105306: ARRAY
105307: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105308: LD_ADDR_VAR 0 9
105312: PUSH
105313: LD_VAR 0 6
105317: PPUSH
105318: LD_VAR 0 7
105322: PPUSH
105323: LD_INT 16
105325: PPUSH
105326: CALL 56537 0 3
105330: ST_TO_ADDR
// if not cratesNearbyPoint then
105331: LD_VAR 0 9
105335: NOT
105336: IFFALSE 105342
// exit ;
105338: POP
105339: POP
105340: GO 105799
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105342: LD_ADDR_VAR 0 4
105346: PUSH
105347: LD_INT 22
105349: PUSH
105350: LD_VAR 0 5
105354: PUSH
105355: EMPTY
105356: LIST
105357: LIST
105358: PUSH
105359: LD_INT 3
105361: PUSH
105362: LD_INT 60
105364: PUSH
105365: EMPTY
105366: LIST
105367: PUSH
105368: EMPTY
105369: LIST
105370: LIST
105371: PUSH
105372: LD_INT 91
105374: PUSH
105375: LD_VAR 0 8
105379: PUSH
105380: LD_INT 6
105382: PUSH
105383: EMPTY
105384: LIST
105385: LIST
105386: LIST
105387: PUSH
105388: LD_INT 2
105390: PUSH
105391: LD_INT 25
105393: PUSH
105394: LD_INT 2
105396: PUSH
105397: EMPTY
105398: LIST
105399: LIST
105400: PUSH
105401: LD_INT 25
105403: PUSH
105404: LD_INT 16
105406: PUSH
105407: EMPTY
105408: LIST
105409: LIST
105410: PUSH
105411: EMPTY
105412: LIST
105413: LIST
105414: LIST
105415: PUSH
105416: EMPTY
105417: LIST
105418: LIST
105419: LIST
105420: LIST
105421: PPUSH
105422: CALL_OW 69
105426: PUSH
105427: LD_VAR 0 8
105431: PPUSH
105432: CALL_OW 313
105436: PPUSH
105437: LD_INT 3
105439: PUSH
105440: LD_INT 60
105442: PUSH
105443: EMPTY
105444: LIST
105445: PUSH
105446: EMPTY
105447: LIST
105448: LIST
105449: PUSH
105450: LD_INT 2
105452: PUSH
105453: LD_INT 25
105455: PUSH
105456: LD_INT 2
105458: PUSH
105459: EMPTY
105460: LIST
105461: LIST
105462: PUSH
105463: LD_INT 25
105465: PUSH
105466: LD_INT 16
105468: PUSH
105469: EMPTY
105470: LIST
105471: LIST
105472: PUSH
105473: EMPTY
105474: LIST
105475: LIST
105476: LIST
105477: PUSH
105478: EMPTY
105479: LIST
105480: LIST
105481: PPUSH
105482: CALL_OW 72
105486: UNION
105487: ST_TO_ADDR
// if tmp then
105488: LD_VAR 0 4
105492: IFFALSE 105572
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105494: LD_ADDR_VAR 0 4
105498: PUSH
105499: LD_VAR 0 4
105503: PPUSH
105504: LD_INT 3
105506: PPUSH
105507: CALL 54506 0 2
105511: ST_TO_ADDR
// for j in tmp do
105512: LD_ADDR_VAR 0 2
105516: PUSH
105517: LD_VAR 0 4
105521: PUSH
105522: FOR_IN
105523: IFFALSE 105566
// begin if IsInUnit ( j ) then
105525: LD_VAR 0 2
105529: PPUSH
105530: CALL_OW 310
105534: IFFALSE 105545
// ComExit ( j ) ;
105536: LD_VAR 0 2
105540: PPUSH
105541: CALL 54589 0 1
// AddComCollect ( j , x , y ) ;
105545: LD_VAR 0 2
105549: PPUSH
105550: LD_VAR 0 6
105554: PPUSH
105555: LD_VAR 0 7
105559: PPUSH
105560: CALL_OW 177
// end ;
105564: GO 105522
105566: POP
105567: POP
// exit ;
105568: POP
105569: POP
105570: GO 105799
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
105572: LD_ADDR_VAR 0 4
105576: PUSH
105577: LD_INT 22
105579: PUSH
105580: LD_VAR 0 5
105584: PUSH
105585: EMPTY
105586: LIST
105587: LIST
105588: PUSH
105589: LD_INT 91
105591: PUSH
105592: LD_VAR 0 8
105596: PUSH
105597: LD_INT 8
105599: PUSH
105600: EMPTY
105601: LIST
105602: LIST
105603: LIST
105604: PUSH
105605: LD_INT 2
105607: PUSH
105608: LD_INT 34
105610: PUSH
105611: LD_INT 12
105613: PUSH
105614: EMPTY
105615: LIST
105616: LIST
105617: PUSH
105618: LD_INT 34
105620: PUSH
105621: LD_INT 51
105623: PUSH
105624: EMPTY
105625: LIST
105626: LIST
105627: PUSH
105628: LD_INT 34
105630: PUSH
105631: LD_INT 32
105633: PUSH
105634: EMPTY
105635: LIST
105636: LIST
105637: PUSH
105638: LD_INT 34
105640: PUSH
105641: LD_INT 89
105643: PUSH
105644: EMPTY
105645: LIST
105646: LIST
105647: PUSH
105648: EMPTY
105649: LIST
105650: LIST
105651: LIST
105652: LIST
105653: LIST
105654: PUSH
105655: EMPTY
105656: LIST
105657: LIST
105658: LIST
105659: PPUSH
105660: CALL_OW 69
105664: ST_TO_ADDR
// if tmp then
105665: LD_VAR 0 4
105669: IFFALSE 105795
// begin for j in tmp do
105671: LD_ADDR_VAR 0 2
105675: PUSH
105676: LD_VAR 0 4
105680: PUSH
105681: FOR_IN
105682: IFFALSE 105793
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
105684: LD_VAR 0 2
105688: PPUSH
105689: CALL_OW 262
105693: PUSH
105694: LD_INT 3
105696: EQUAL
105697: PUSH
105698: LD_VAR 0 2
105702: PPUSH
105703: CALL_OW 261
105707: PUSH
105708: LD_INT 20
105710: GREATER
105711: OR
105712: PUSH
105713: LD_VAR 0 2
105717: PPUSH
105718: CALL_OW 314
105722: NOT
105723: AND
105724: PUSH
105725: LD_VAR 0 2
105729: PPUSH
105730: CALL_OW 263
105734: PUSH
105735: LD_INT 1
105737: NONEQUAL
105738: PUSH
105739: LD_VAR 0 2
105743: PPUSH
105744: CALL_OW 311
105748: OR
105749: AND
105750: IFFALSE 105791
// begin ComCollect ( j , x , y ) ;
105752: LD_VAR 0 2
105756: PPUSH
105757: LD_VAR 0 6
105761: PPUSH
105762: LD_VAR 0 7
105766: PPUSH
105767: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
105771: LD_VAR 0 2
105775: PPUSH
105776: LD_VAR 0 8
105780: PPUSH
105781: CALL_OW 172
// exit ;
105785: POP
105786: POP
105787: POP
105788: POP
105789: GO 105799
// end ;
105791: GO 105681
105793: POP
105794: POP
// end ; end ;
105795: GO 105170
105797: POP
105798: POP
// end ; end_of_file
105799: PPOPN 9
105801: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105802: LD_INT 0
105804: PPUSH
105805: PPUSH
105806: PPUSH
105807: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105808: LD_VAR 0 1
105812: PPUSH
105813: CALL_OW 264
105817: PUSH
105818: LD_INT 91
105820: EQUAL
105821: IFFALSE 105893
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105823: LD_INT 68
105825: PPUSH
105826: LD_VAR 0 1
105830: PPUSH
105831: CALL_OW 255
105835: PPUSH
105836: CALL_OW 321
105840: PUSH
105841: LD_INT 2
105843: EQUAL
105844: IFFALSE 105856
// eff := 70 else
105846: LD_ADDR_VAR 0 4
105850: PUSH
105851: LD_INT 70
105853: ST_TO_ADDR
105854: GO 105864
// eff := 30 ;
105856: LD_ADDR_VAR 0 4
105860: PUSH
105861: LD_INT 30
105863: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105864: LD_VAR 0 1
105868: PPUSH
105869: CALL_OW 250
105873: PPUSH
105874: LD_VAR 0 1
105878: PPUSH
105879: CALL_OW 251
105883: PPUSH
105884: LD_VAR 0 4
105888: PPUSH
105889: CALL_OW 495
// end ; end ;
105893: LD_VAR 0 2
105897: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105898: LD_INT 0
105900: PPUSH
// end ;
105901: LD_VAR 0 4
105905: RET
// export function SOS_Command ( cmd ) ; begin
105906: LD_INT 0
105908: PPUSH
// end ;
105909: LD_VAR 0 2
105913: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105914: LD_INT 0
105916: PPUSH
// end ;
105917: LD_VAR 0 6
105921: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
105922: LD_INT 0
105924: PPUSH
105925: PPUSH
// if not vehicle or not factory then
105926: LD_VAR 0 1
105930: NOT
105931: PUSH
105932: LD_VAR 0 2
105936: NOT
105937: OR
105938: IFFALSE 105942
// exit ;
105940: GO 106185
// if factoryWaypoints >= factory then
105942: LD_EXP 166
105946: PUSH
105947: LD_VAR 0 2
105951: GREATEREQUAL
105952: IFFALSE 106185
// if factoryWaypoints [ factory ] then
105954: LD_EXP 166
105958: PUSH
105959: LD_VAR 0 2
105963: ARRAY
105964: IFFALSE 106185
// begin if GetControl ( vehicle ) = control_manual then
105966: LD_VAR 0 1
105970: PPUSH
105971: CALL_OW 263
105975: PUSH
105976: LD_INT 1
105978: EQUAL
105979: IFFALSE 106072
// begin driver := IsDrivenBy ( vehicle ) ;
105981: LD_ADDR_VAR 0 4
105985: PUSH
105986: LD_VAR 0 1
105990: PPUSH
105991: CALL_OW 311
105995: ST_TO_ADDR
// if not HasTask ( driver ) then
105996: LD_VAR 0 4
106000: PPUSH
106001: CALL_OW 314
106005: NOT
106006: IFFALSE 106070
// begin ComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106008: LD_VAR 0 4
106012: PPUSH
106013: LD_EXP 166
106017: PUSH
106018: LD_VAR 0 2
106022: ARRAY
106023: PUSH
106024: LD_INT 3
106026: ARRAY
106027: PPUSH
106028: LD_EXP 166
106032: PUSH
106033: LD_VAR 0 2
106037: ARRAY
106038: PUSH
106039: LD_INT 4
106041: ARRAY
106042: PPUSH
106043: CALL_OW 111
// AddComExitVehicle ( driver ) ;
106047: LD_VAR 0 4
106051: PPUSH
106052: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
106056: LD_VAR 0 4
106060: PPUSH
106061: LD_VAR 0 2
106065: PPUSH
106066: CALL_OW 180
// end ; end else
106070: GO 106185
// if GetControl ( vehicle ) = control_remote then
106072: LD_VAR 0 1
106076: PPUSH
106077: CALL_OW 263
106081: PUSH
106082: LD_INT 2
106084: EQUAL
106085: IFFALSE 106146
// begin wait ( 0 0$2 ) ;
106087: LD_INT 70
106089: PPUSH
106090: CALL_OW 67
// if Connect ( vehicle ) then
106094: LD_VAR 0 1
106098: PPUSH
106099: CALL 24808 0 1
106103: IFFALSE 106144
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106105: LD_VAR 0 1
106109: PPUSH
106110: LD_EXP 166
106114: PUSH
106115: LD_VAR 0 2
106119: ARRAY
106120: PUSH
106121: LD_INT 3
106123: ARRAY
106124: PPUSH
106125: LD_EXP 166
106129: PUSH
106130: LD_VAR 0 2
106134: ARRAY
106135: PUSH
106136: LD_INT 4
106138: ARRAY
106139: PPUSH
106140: CALL_OW 171
// end else
106144: GO 106185
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106146: LD_VAR 0 1
106150: PPUSH
106151: LD_EXP 166
106155: PUSH
106156: LD_VAR 0 2
106160: ARRAY
106161: PUSH
106162: LD_INT 3
106164: ARRAY
106165: PPUSH
106166: LD_EXP 166
106170: PUSH
106171: LD_VAR 0 2
106175: ARRAY
106176: PUSH
106177: LD_INT 4
106179: ARRAY
106180: PPUSH
106181: CALL_OW 171
// end ; end ;
106185: LD_VAR 0 3
106189: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106190: LD_INT 0
106192: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106193: LD_VAR 0 1
106197: PUSH
106198: LD_INT 250
106200: EQUAL
106201: PUSH
106202: LD_VAR 0 2
106206: PPUSH
106207: CALL_OW 264
106211: PUSH
106212: LD_INT 81
106214: EQUAL
106215: AND
106216: IFFALSE 106237
// MinerPlaceMine ( unit , x , y ) ;
106218: LD_VAR 0 2
106222: PPUSH
106223: LD_VAR 0 4
106227: PPUSH
106228: LD_VAR 0 5
106232: PPUSH
106233: CALL 109227 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106237: LD_VAR 0 1
106241: PUSH
106242: LD_INT 251
106244: EQUAL
106245: PUSH
106246: LD_VAR 0 2
106250: PPUSH
106251: CALL_OW 264
106255: PUSH
106256: LD_INT 81
106258: EQUAL
106259: AND
106260: IFFALSE 106281
// MinerDetonateMine ( unit , x , y ) ;
106262: LD_VAR 0 2
106266: PPUSH
106267: LD_VAR 0 4
106271: PPUSH
106272: LD_VAR 0 5
106276: PPUSH
106277: CALL 109502 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106281: LD_VAR 0 1
106285: PUSH
106286: LD_INT 252
106288: EQUAL
106289: PUSH
106290: LD_VAR 0 2
106294: PPUSH
106295: CALL_OW 264
106299: PUSH
106300: LD_INT 81
106302: EQUAL
106303: AND
106304: IFFALSE 106325
// MinerCreateMinefield ( unit , x , y ) ;
106306: LD_VAR 0 2
106310: PPUSH
106311: LD_VAR 0 4
106315: PPUSH
106316: LD_VAR 0 5
106320: PPUSH
106321: CALL 109919 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106325: LD_VAR 0 1
106329: PUSH
106330: LD_INT 253
106332: EQUAL
106333: PUSH
106334: LD_VAR 0 2
106338: PPUSH
106339: CALL_OW 257
106343: PUSH
106344: LD_INT 5
106346: EQUAL
106347: AND
106348: IFFALSE 106369
// ComBinocular ( unit , x , y ) ;
106350: LD_VAR 0 2
106354: PPUSH
106355: LD_VAR 0 4
106359: PPUSH
106360: LD_VAR 0 5
106364: PPUSH
106365: CALL 110288 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106369: LD_VAR 0 1
106373: PUSH
106374: LD_INT 254
106376: EQUAL
106377: PUSH
106378: LD_VAR 0 2
106382: PPUSH
106383: CALL_OW 264
106387: PUSH
106388: LD_INT 99
106390: EQUAL
106391: AND
106392: PUSH
106393: LD_VAR 0 3
106397: PPUSH
106398: CALL_OW 263
106402: PUSH
106403: LD_INT 3
106405: EQUAL
106406: AND
106407: IFFALSE 106423
// HackDestroyVehicle ( unit , selectedUnit ) ;
106409: LD_VAR 0 2
106413: PPUSH
106414: LD_VAR 0 3
106418: PPUSH
106419: CALL 108591 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
106423: LD_VAR 0 1
106427: PUSH
106428: LD_INT 255
106430: EQUAL
106431: PUSH
106432: LD_VAR 0 2
106436: PPUSH
106437: CALL_OW 264
106441: PUSH
106442: LD_INT 14
106444: PUSH
106445: LD_INT 53
106447: PUSH
106448: EMPTY
106449: LIST
106450: LIST
106451: IN
106452: AND
106453: PUSH
106454: LD_VAR 0 4
106458: PPUSH
106459: LD_VAR 0 5
106463: PPUSH
106464: CALL_OW 488
106468: AND
106469: IFFALSE 106493
// CutTreeXYR ( unit , x , y , 12 ) ;
106471: LD_VAR 0 2
106475: PPUSH
106476: LD_VAR 0 4
106480: PPUSH
106481: LD_VAR 0 5
106485: PPUSH
106486: LD_INT 12
106488: PPUSH
106489: CALL 106588 0 4
// if cmd = 256 then
106493: LD_VAR 0 1
106497: PUSH
106498: LD_INT 256
106500: EQUAL
106501: IFFALSE 106522
// SetFactoryWaypoint ( unit , x , y ) ;
106503: LD_VAR 0 2
106507: PPUSH
106508: LD_VAR 0 4
106512: PPUSH
106513: LD_VAR 0 5
106517: PPUSH
106518: CALL 104491 0 3
// if cmd = 257 then
106522: LD_VAR 0 1
106526: PUSH
106527: LD_INT 257
106529: EQUAL
106530: IFFALSE 106551
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106532: LD_VAR 0 2
106536: PPUSH
106537: LD_VAR 0 4
106541: PPUSH
106542: LD_VAR 0 5
106546: PPUSH
106547: CALL 104853 0 3
// if cmd = 258 then
106551: LD_VAR 0 1
106555: PUSH
106556: LD_INT 258
106558: EQUAL
106559: IFFALSE 106583
// BurnTreeXYR ( unit , x , y , 8 ) ;
106561: LD_VAR 0 2
106565: PPUSH
106566: LD_VAR 0 4
106570: PPUSH
106571: LD_VAR 0 5
106575: PPUSH
106576: LD_INT 8
106578: PPUSH
106579: CALL 106982 0 4
// end ;
106583: LD_VAR 0 6
106587: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106588: LD_INT 0
106590: PPUSH
106591: PPUSH
106592: PPUSH
106593: PPUSH
106594: PPUSH
106595: PPUSH
106596: PPUSH
106597: PPUSH
106598: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
106599: LD_VAR 0 1
106603: PPUSH
106604: CALL_OW 302
106608: NOT
106609: PUSH
106610: LD_VAR 0 2
106614: PPUSH
106615: LD_VAR 0 3
106619: PPUSH
106620: CALL_OW 488
106624: NOT
106625: OR
106626: PUSH
106627: LD_VAR 0 4
106631: NOT
106632: OR
106633: IFFALSE 106637
// exit ;
106635: GO 106977
// list := [ ] ;
106637: LD_ADDR_VAR 0 13
106641: PUSH
106642: EMPTY
106643: ST_TO_ADDR
// if x - r < 0 then
106644: LD_VAR 0 2
106648: PUSH
106649: LD_VAR 0 4
106653: MINUS
106654: PUSH
106655: LD_INT 0
106657: LESS
106658: IFFALSE 106670
// min_x := 0 else
106660: LD_ADDR_VAR 0 7
106664: PUSH
106665: LD_INT 0
106667: ST_TO_ADDR
106668: GO 106686
// min_x := x - r ;
106670: LD_ADDR_VAR 0 7
106674: PUSH
106675: LD_VAR 0 2
106679: PUSH
106680: LD_VAR 0 4
106684: MINUS
106685: ST_TO_ADDR
// if y - r < 0 then
106686: LD_VAR 0 3
106690: PUSH
106691: LD_VAR 0 4
106695: MINUS
106696: PUSH
106697: LD_INT 0
106699: LESS
106700: IFFALSE 106712
// min_y := 0 else
106702: LD_ADDR_VAR 0 8
106706: PUSH
106707: LD_INT 0
106709: ST_TO_ADDR
106710: GO 106728
// min_y := y - r ;
106712: LD_ADDR_VAR 0 8
106716: PUSH
106717: LD_VAR 0 3
106721: PUSH
106722: LD_VAR 0 4
106726: MINUS
106727: ST_TO_ADDR
// max_x := x + r ;
106728: LD_ADDR_VAR 0 9
106732: PUSH
106733: LD_VAR 0 2
106737: PUSH
106738: LD_VAR 0 4
106742: PLUS
106743: ST_TO_ADDR
// max_y := y + r ;
106744: LD_ADDR_VAR 0 10
106748: PUSH
106749: LD_VAR 0 3
106753: PUSH
106754: LD_VAR 0 4
106758: PLUS
106759: ST_TO_ADDR
// for _x = min_x to max_x do
106760: LD_ADDR_VAR 0 11
106764: PUSH
106765: DOUBLE
106766: LD_VAR 0 7
106770: DEC
106771: ST_TO_ADDR
106772: LD_VAR 0 9
106776: PUSH
106777: FOR_TO
106778: IFFALSE 106895
// for _y = min_y to max_y do
106780: LD_ADDR_VAR 0 12
106784: PUSH
106785: DOUBLE
106786: LD_VAR 0 8
106790: DEC
106791: ST_TO_ADDR
106792: LD_VAR 0 10
106796: PUSH
106797: FOR_TO
106798: IFFALSE 106891
// begin if not ValidHex ( _x , _y ) then
106800: LD_VAR 0 11
106804: PPUSH
106805: LD_VAR 0 12
106809: PPUSH
106810: CALL_OW 488
106814: NOT
106815: IFFALSE 106819
// continue ;
106817: GO 106797
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106819: LD_VAR 0 11
106823: PPUSH
106824: LD_VAR 0 12
106828: PPUSH
106829: CALL_OW 351
106833: PUSH
106834: LD_VAR 0 11
106838: PPUSH
106839: LD_VAR 0 12
106843: PPUSH
106844: CALL_OW 554
106848: AND
106849: IFFALSE 106889
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106851: LD_ADDR_VAR 0 13
106855: PUSH
106856: LD_VAR 0 13
106860: PPUSH
106861: LD_VAR 0 13
106865: PUSH
106866: LD_INT 1
106868: PLUS
106869: PPUSH
106870: LD_VAR 0 11
106874: PUSH
106875: LD_VAR 0 12
106879: PUSH
106880: EMPTY
106881: LIST
106882: LIST
106883: PPUSH
106884: CALL_OW 2
106888: ST_TO_ADDR
// end ;
106889: GO 106797
106891: POP
106892: POP
106893: GO 106777
106895: POP
106896: POP
// if not list then
106897: LD_VAR 0 13
106901: NOT
106902: IFFALSE 106906
// exit ;
106904: GO 106977
// for i in list do
106906: LD_ADDR_VAR 0 6
106910: PUSH
106911: LD_VAR 0 13
106915: PUSH
106916: FOR_IN
106917: IFFALSE 106975
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106919: LD_VAR 0 1
106923: PPUSH
106924: LD_STRING M
106926: PUSH
106927: LD_VAR 0 6
106931: PUSH
106932: LD_INT 1
106934: ARRAY
106935: PUSH
106936: LD_VAR 0 6
106940: PUSH
106941: LD_INT 2
106943: ARRAY
106944: PUSH
106945: LD_INT 0
106947: PUSH
106948: LD_INT 0
106950: PUSH
106951: LD_INT 0
106953: PUSH
106954: LD_INT 0
106956: PUSH
106957: EMPTY
106958: LIST
106959: LIST
106960: LIST
106961: LIST
106962: LIST
106963: LIST
106964: LIST
106965: PUSH
106966: EMPTY
106967: LIST
106968: PPUSH
106969: CALL_OW 447
106973: GO 106916
106975: POP
106976: POP
// end ;
106977: LD_VAR 0 5
106981: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
106982: LD_INT 0
106984: PPUSH
106985: PPUSH
106986: PPUSH
106987: PPUSH
106988: PPUSH
106989: PPUSH
106990: PPUSH
106991: PPUSH
106992: PPUSH
106993: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
106994: LD_VAR 0 1
106998: PPUSH
106999: CALL_OW 302
107003: NOT
107004: PUSH
107005: LD_VAR 0 2
107009: PPUSH
107010: LD_VAR 0 3
107014: PPUSH
107015: CALL_OW 488
107019: NOT
107020: OR
107021: PUSH
107022: LD_VAR 0 4
107026: NOT
107027: OR
107028: IFFALSE 107032
// exit ;
107030: GO 107545
// list := [ ] ;
107032: LD_ADDR_VAR 0 13
107036: PUSH
107037: EMPTY
107038: ST_TO_ADDR
// if x - r < 0 then
107039: LD_VAR 0 2
107043: PUSH
107044: LD_VAR 0 4
107048: MINUS
107049: PUSH
107050: LD_INT 0
107052: LESS
107053: IFFALSE 107065
// min_x := 0 else
107055: LD_ADDR_VAR 0 7
107059: PUSH
107060: LD_INT 0
107062: ST_TO_ADDR
107063: GO 107081
// min_x := x - r ;
107065: LD_ADDR_VAR 0 7
107069: PUSH
107070: LD_VAR 0 2
107074: PUSH
107075: LD_VAR 0 4
107079: MINUS
107080: ST_TO_ADDR
// if y - r < 0 then
107081: LD_VAR 0 3
107085: PUSH
107086: LD_VAR 0 4
107090: MINUS
107091: PUSH
107092: LD_INT 0
107094: LESS
107095: IFFALSE 107107
// min_y := 0 else
107097: LD_ADDR_VAR 0 8
107101: PUSH
107102: LD_INT 0
107104: ST_TO_ADDR
107105: GO 107123
// min_y := y - r ;
107107: LD_ADDR_VAR 0 8
107111: PUSH
107112: LD_VAR 0 3
107116: PUSH
107117: LD_VAR 0 4
107121: MINUS
107122: ST_TO_ADDR
// max_x := x + r ;
107123: LD_ADDR_VAR 0 9
107127: PUSH
107128: LD_VAR 0 2
107132: PUSH
107133: LD_VAR 0 4
107137: PLUS
107138: ST_TO_ADDR
// max_y := y + r ;
107139: LD_ADDR_VAR 0 10
107143: PUSH
107144: LD_VAR 0 3
107148: PUSH
107149: LD_VAR 0 4
107153: PLUS
107154: ST_TO_ADDR
// for _x = min_x to max_x do
107155: LD_ADDR_VAR 0 11
107159: PUSH
107160: DOUBLE
107161: LD_VAR 0 7
107165: DEC
107166: ST_TO_ADDR
107167: LD_VAR 0 9
107171: PUSH
107172: FOR_TO
107173: IFFALSE 107290
// for _y = min_y to max_y do
107175: LD_ADDR_VAR 0 12
107179: PUSH
107180: DOUBLE
107181: LD_VAR 0 8
107185: DEC
107186: ST_TO_ADDR
107187: LD_VAR 0 10
107191: PUSH
107192: FOR_TO
107193: IFFALSE 107286
// begin if not ValidHex ( _x , _y ) then
107195: LD_VAR 0 11
107199: PPUSH
107200: LD_VAR 0 12
107204: PPUSH
107205: CALL_OW 488
107209: NOT
107210: IFFALSE 107214
// continue ;
107212: GO 107192
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107214: LD_VAR 0 11
107218: PPUSH
107219: LD_VAR 0 12
107223: PPUSH
107224: CALL_OW 351
107228: PUSH
107229: LD_VAR 0 11
107233: PPUSH
107234: LD_VAR 0 12
107238: PPUSH
107239: CALL_OW 554
107243: AND
107244: IFFALSE 107284
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107246: LD_ADDR_VAR 0 13
107250: PUSH
107251: LD_VAR 0 13
107255: PPUSH
107256: LD_VAR 0 13
107260: PUSH
107261: LD_INT 1
107263: PLUS
107264: PPUSH
107265: LD_VAR 0 11
107269: PUSH
107270: LD_VAR 0 12
107274: PUSH
107275: EMPTY
107276: LIST
107277: LIST
107278: PPUSH
107279: CALL_OW 2
107283: ST_TO_ADDR
// end ;
107284: GO 107192
107286: POP
107287: POP
107288: GO 107172
107290: POP
107291: POP
// if not list then
107292: LD_VAR 0 13
107296: NOT
107297: IFFALSE 107301
// exit ;
107299: GO 107545
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
107301: LD_ADDR_VAR 0 13
107305: PUSH
107306: LD_VAR 0 1
107310: PPUSH
107311: LD_VAR 0 13
107315: PPUSH
107316: LD_INT 1
107318: PPUSH
107319: LD_INT 1
107321: PPUSH
107322: CALL 21950 0 4
107326: ST_TO_ADDR
// ComStop ( flame ) ;
107327: LD_VAR 0 1
107331: PPUSH
107332: CALL_OW 141
// for i in list do
107336: LD_ADDR_VAR 0 6
107340: PUSH
107341: LD_VAR 0 13
107345: PUSH
107346: FOR_IN
107347: IFFALSE 107378
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
107349: LD_VAR 0 1
107353: PPUSH
107354: LD_VAR 0 6
107358: PUSH
107359: LD_INT 1
107361: ARRAY
107362: PPUSH
107363: LD_VAR 0 6
107367: PUSH
107368: LD_INT 2
107370: ARRAY
107371: PPUSH
107372: CALL_OW 176
107376: GO 107346
107378: POP
107379: POP
// repeat wait ( 0 0$1 ) ;
107380: LD_INT 35
107382: PPUSH
107383: CALL_OW 67
// task := GetTaskList ( flame ) ;
107387: LD_ADDR_VAR 0 14
107391: PUSH
107392: LD_VAR 0 1
107396: PPUSH
107397: CALL_OW 437
107401: ST_TO_ADDR
// if not task then
107402: LD_VAR 0 14
107406: NOT
107407: IFFALSE 107411
// exit ;
107409: GO 107545
// if task [ 1 ] [ 1 ] <> | then
107411: LD_VAR 0 14
107415: PUSH
107416: LD_INT 1
107418: ARRAY
107419: PUSH
107420: LD_INT 1
107422: ARRAY
107423: PUSH
107424: LD_STRING |
107426: NONEQUAL
107427: IFFALSE 107431
// exit ;
107429: GO 107545
// _x := task [ 1 ] [ 2 ] ;
107431: LD_ADDR_VAR 0 11
107435: PUSH
107436: LD_VAR 0 14
107440: PUSH
107441: LD_INT 1
107443: ARRAY
107444: PUSH
107445: LD_INT 2
107447: ARRAY
107448: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
107449: LD_ADDR_VAR 0 12
107453: PUSH
107454: LD_VAR 0 14
107458: PUSH
107459: LD_INT 1
107461: ARRAY
107462: PUSH
107463: LD_INT 3
107465: ARRAY
107466: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
107467: LD_VAR 0 11
107471: PPUSH
107472: LD_VAR 0 12
107476: PPUSH
107477: CALL_OW 351
107481: NOT
107482: PUSH
107483: LD_VAR 0 11
107487: PPUSH
107488: LD_VAR 0 12
107492: PPUSH
107493: CALL_OW 554
107497: NOT
107498: OR
107499: IFFALSE 107533
// begin task := Delete ( task , 1 ) ;
107501: LD_ADDR_VAR 0 14
107505: PUSH
107506: LD_VAR 0 14
107510: PPUSH
107511: LD_INT 1
107513: PPUSH
107514: CALL_OW 3
107518: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
107519: LD_VAR 0 1
107523: PPUSH
107524: LD_VAR 0 14
107528: PPUSH
107529: CALL_OW 446
// end ; until not HasTask ( flame ) ;
107533: LD_VAR 0 1
107537: PPUSH
107538: CALL_OW 314
107542: NOT
107543: IFFALSE 107380
// end ;
107545: LD_VAR 0 5
107549: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
107550: LD_EXP 169
107554: NOT
107555: IFFALSE 107605
107557: GO 107559
107559: DISABLE
// begin initHack := true ;
107560: LD_ADDR_EXP 169
107564: PUSH
107565: LD_INT 1
107567: ST_TO_ADDR
// hackTanks := [ ] ;
107568: LD_ADDR_EXP 170
107572: PUSH
107573: EMPTY
107574: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
107575: LD_ADDR_EXP 171
107579: PUSH
107580: EMPTY
107581: ST_TO_ADDR
// hackLimit := 3 ;
107582: LD_ADDR_EXP 172
107586: PUSH
107587: LD_INT 3
107589: ST_TO_ADDR
// hackDist := 12 ;
107590: LD_ADDR_EXP 173
107594: PUSH
107595: LD_INT 12
107597: ST_TO_ADDR
// hackCounter := [ ] ;
107598: LD_ADDR_EXP 174
107602: PUSH
107603: EMPTY
107604: ST_TO_ADDR
// end ;
107605: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
107606: LD_EXP 169
107610: PUSH
107611: LD_INT 34
107613: PUSH
107614: LD_INT 99
107616: PUSH
107617: EMPTY
107618: LIST
107619: LIST
107620: PPUSH
107621: CALL_OW 69
107625: AND
107626: IFFALSE 107879
107628: GO 107630
107630: DISABLE
107631: LD_INT 0
107633: PPUSH
107634: PPUSH
// begin enable ;
107635: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
107636: LD_ADDR_VAR 0 1
107640: PUSH
107641: LD_INT 34
107643: PUSH
107644: LD_INT 99
107646: PUSH
107647: EMPTY
107648: LIST
107649: LIST
107650: PPUSH
107651: CALL_OW 69
107655: PUSH
107656: FOR_IN
107657: IFFALSE 107877
// begin if not i in hackTanks then
107659: LD_VAR 0 1
107663: PUSH
107664: LD_EXP 170
107668: IN
107669: NOT
107670: IFFALSE 107753
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
107672: LD_ADDR_EXP 170
107676: PUSH
107677: LD_EXP 170
107681: PPUSH
107682: LD_EXP 170
107686: PUSH
107687: LD_INT 1
107689: PLUS
107690: PPUSH
107691: LD_VAR 0 1
107695: PPUSH
107696: CALL_OW 1
107700: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
107701: LD_ADDR_EXP 171
107705: PUSH
107706: LD_EXP 171
107710: PPUSH
107711: LD_EXP 171
107715: PUSH
107716: LD_INT 1
107718: PLUS
107719: PPUSH
107720: EMPTY
107721: PPUSH
107722: CALL_OW 1
107726: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
107727: LD_ADDR_EXP 174
107731: PUSH
107732: LD_EXP 174
107736: PPUSH
107737: LD_EXP 174
107741: PUSH
107742: LD_INT 1
107744: PLUS
107745: PPUSH
107746: EMPTY
107747: PPUSH
107748: CALL_OW 1
107752: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107753: LD_VAR 0 1
107757: PPUSH
107758: CALL_OW 302
107762: NOT
107763: IFFALSE 107776
// begin HackUnlinkAll ( i ) ;
107765: LD_VAR 0 1
107769: PPUSH
107770: CALL 107882 0 1
// continue ;
107774: GO 107656
// end ; HackCheckCapturedStatus ( i ) ;
107776: LD_VAR 0 1
107780: PPUSH
107781: CALL 108325 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107785: LD_ADDR_VAR 0 2
107789: PUSH
107790: LD_INT 81
107792: PUSH
107793: LD_VAR 0 1
107797: PPUSH
107798: CALL_OW 255
107802: PUSH
107803: EMPTY
107804: LIST
107805: LIST
107806: PUSH
107807: LD_INT 33
107809: PUSH
107810: LD_INT 3
107812: PUSH
107813: EMPTY
107814: LIST
107815: LIST
107816: PUSH
107817: LD_INT 91
107819: PUSH
107820: LD_VAR 0 1
107824: PUSH
107825: LD_EXP 173
107829: PUSH
107830: EMPTY
107831: LIST
107832: LIST
107833: LIST
107834: PUSH
107835: LD_INT 50
107837: PUSH
107838: EMPTY
107839: LIST
107840: PUSH
107841: EMPTY
107842: LIST
107843: LIST
107844: LIST
107845: LIST
107846: PPUSH
107847: CALL_OW 69
107851: ST_TO_ADDR
// if not tmp then
107852: LD_VAR 0 2
107856: NOT
107857: IFFALSE 107861
// continue ;
107859: GO 107656
// HackLink ( i , tmp ) ;
107861: LD_VAR 0 1
107865: PPUSH
107866: LD_VAR 0 2
107870: PPUSH
107871: CALL 108018 0 2
// end ;
107875: GO 107656
107877: POP
107878: POP
// end ;
107879: PPOPN 2
107881: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107882: LD_INT 0
107884: PPUSH
107885: PPUSH
107886: PPUSH
// if not hack in hackTanks then
107887: LD_VAR 0 1
107891: PUSH
107892: LD_EXP 170
107896: IN
107897: NOT
107898: IFFALSE 107902
// exit ;
107900: GO 108013
// index := GetElementIndex ( hackTanks , hack ) ;
107902: LD_ADDR_VAR 0 4
107906: PUSH
107907: LD_EXP 170
107911: PPUSH
107912: LD_VAR 0 1
107916: PPUSH
107917: CALL 21247 0 2
107921: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107922: LD_EXP 171
107926: PUSH
107927: LD_VAR 0 4
107931: ARRAY
107932: IFFALSE 108013
// begin for i in hackTanksCaptured [ index ] do
107934: LD_ADDR_VAR 0 3
107938: PUSH
107939: LD_EXP 171
107943: PUSH
107944: LD_VAR 0 4
107948: ARRAY
107949: PUSH
107950: FOR_IN
107951: IFFALSE 107977
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107953: LD_VAR 0 3
107957: PUSH
107958: LD_INT 1
107960: ARRAY
107961: PPUSH
107962: LD_VAR 0 3
107966: PUSH
107967: LD_INT 2
107969: ARRAY
107970: PPUSH
107971: CALL_OW 235
107975: GO 107950
107977: POP
107978: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107979: LD_ADDR_EXP 171
107983: PUSH
107984: LD_EXP 171
107988: PPUSH
107989: LD_VAR 0 4
107993: PPUSH
107994: EMPTY
107995: PPUSH
107996: CALL_OW 1
108000: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
108001: LD_VAR 0 1
108005: PPUSH
108006: LD_INT 0
108008: PPUSH
108009: CALL_OW 505
// end ; end ;
108013: LD_VAR 0 2
108017: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
108018: LD_INT 0
108020: PPUSH
108021: PPUSH
108022: PPUSH
// if not hack in hackTanks or not vehicles then
108023: LD_VAR 0 1
108027: PUSH
108028: LD_EXP 170
108032: IN
108033: NOT
108034: PUSH
108035: LD_VAR 0 2
108039: NOT
108040: OR
108041: IFFALSE 108045
// exit ;
108043: GO 108320
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
108045: LD_ADDR_VAR 0 2
108049: PUSH
108050: LD_VAR 0 1
108054: PPUSH
108055: LD_VAR 0 2
108059: PPUSH
108060: LD_INT 1
108062: PPUSH
108063: LD_INT 1
108065: PPUSH
108066: CALL 21897 0 4
108070: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
108071: LD_ADDR_VAR 0 5
108075: PUSH
108076: LD_EXP 170
108080: PPUSH
108081: LD_VAR 0 1
108085: PPUSH
108086: CALL 21247 0 2
108090: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
108091: LD_EXP 171
108095: PUSH
108096: LD_VAR 0 5
108100: ARRAY
108101: PUSH
108102: LD_EXP 172
108106: LESS
108107: IFFALSE 108296
// begin for i := 1 to vehicles do
108109: LD_ADDR_VAR 0 4
108113: PUSH
108114: DOUBLE
108115: LD_INT 1
108117: DEC
108118: ST_TO_ADDR
108119: LD_VAR 0 2
108123: PUSH
108124: FOR_TO
108125: IFFALSE 108294
// begin if hackTanksCaptured [ index ] = hackLimit then
108127: LD_EXP 171
108131: PUSH
108132: LD_VAR 0 5
108136: ARRAY
108137: PUSH
108138: LD_EXP 172
108142: EQUAL
108143: IFFALSE 108147
// break ;
108145: GO 108294
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
108147: LD_ADDR_EXP 174
108151: PUSH
108152: LD_EXP 174
108156: PPUSH
108157: LD_VAR 0 5
108161: PPUSH
108162: LD_EXP 174
108166: PUSH
108167: LD_VAR 0 5
108171: ARRAY
108172: PUSH
108173: LD_INT 1
108175: PLUS
108176: PPUSH
108177: CALL_OW 1
108181: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
108182: LD_ADDR_EXP 171
108186: PUSH
108187: LD_EXP 171
108191: PPUSH
108192: LD_VAR 0 5
108196: PUSH
108197: LD_EXP 171
108201: PUSH
108202: LD_VAR 0 5
108206: ARRAY
108207: PUSH
108208: LD_INT 1
108210: PLUS
108211: PUSH
108212: EMPTY
108213: LIST
108214: LIST
108215: PPUSH
108216: LD_VAR 0 2
108220: PUSH
108221: LD_VAR 0 4
108225: ARRAY
108226: PUSH
108227: LD_VAR 0 2
108231: PUSH
108232: LD_VAR 0 4
108236: ARRAY
108237: PPUSH
108238: CALL_OW 255
108242: PUSH
108243: EMPTY
108244: LIST
108245: LIST
108246: PPUSH
108247: CALL 21462 0 3
108251: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
108252: LD_VAR 0 2
108256: PUSH
108257: LD_VAR 0 4
108261: ARRAY
108262: PPUSH
108263: LD_VAR 0 1
108267: PPUSH
108268: CALL_OW 255
108272: PPUSH
108273: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
108277: LD_VAR 0 2
108281: PUSH
108282: LD_VAR 0 4
108286: ARRAY
108287: PPUSH
108288: CALL_OW 141
// end ;
108292: GO 108124
108294: POP
108295: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108296: LD_VAR 0 1
108300: PPUSH
108301: LD_EXP 171
108305: PUSH
108306: LD_VAR 0 5
108310: ARRAY
108311: PUSH
108312: LD_INT 0
108314: PLUS
108315: PPUSH
108316: CALL_OW 505
// end ;
108320: LD_VAR 0 3
108324: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
108325: LD_INT 0
108327: PPUSH
108328: PPUSH
108329: PPUSH
108330: PPUSH
// if not hack in hackTanks then
108331: LD_VAR 0 1
108335: PUSH
108336: LD_EXP 170
108340: IN
108341: NOT
108342: IFFALSE 108346
// exit ;
108344: GO 108586
// index := GetElementIndex ( hackTanks , hack ) ;
108346: LD_ADDR_VAR 0 4
108350: PUSH
108351: LD_EXP 170
108355: PPUSH
108356: LD_VAR 0 1
108360: PPUSH
108361: CALL 21247 0 2
108365: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
108366: LD_ADDR_VAR 0 3
108370: PUSH
108371: DOUBLE
108372: LD_EXP 171
108376: PUSH
108377: LD_VAR 0 4
108381: ARRAY
108382: INC
108383: ST_TO_ADDR
108384: LD_INT 1
108386: PUSH
108387: FOR_DOWNTO
108388: IFFALSE 108560
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
108390: LD_ADDR_VAR 0 5
108394: PUSH
108395: LD_EXP 171
108399: PUSH
108400: LD_VAR 0 4
108404: ARRAY
108405: PUSH
108406: LD_VAR 0 3
108410: ARRAY
108411: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
108412: LD_VAR 0 5
108416: PUSH
108417: LD_INT 1
108419: ARRAY
108420: PPUSH
108421: CALL_OW 302
108425: NOT
108426: PUSH
108427: LD_VAR 0 5
108431: PUSH
108432: LD_INT 1
108434: ARRAY
108435: PPUSH
108436: CALL_OW 255
108440: PUSH
108441: LD_VAR 0 1
108445: PPUSH
108446: CALL_OW 255
108450: NONEQUAL
108451: OR
108452: IFFALSE 108558
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
108454: LD_VAR 0 5
108458: PUSH
108459: LD_INT 1
108461: ARRAY
108462: PPUSH
108463: CALL_OW 305
108467: PUSH
108468: LD_VAR 0 5
108472: PUSH
108473: LD_INT 1
108475: ARRAY
108476: PPUSH
108477: CALL_OW 255
108481: PUSH
108482: LD_VAR 0 1
108486: PPUSH
108487: CALL_OW 255
108491: EQUAL
108492: AND
108493: IFFALSE 108517
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
108495: LD_VAR 0 5
108499: PUSH
108500: LD_INT 1
108502: ARRAY
108503: PPUSH
108504: LD_VAR 0 5
108508: PUSH
108509: LD_INT 2
108511: ARRAY
108512: PPUSH
108513: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
108517: LD_ADDR_EXP 171
108521: PUSH
108522: LD_EXP 171
108526: PPUSH
108527: LD_VAR 0 4
108531: PPUSH
108532: LD_EXP 171
108536: PUSH
108537: LD_VAR 0 4
108541: ARRAY
108542: PPUSH
108543: LD_VAR 0 3
108547: PPUSH
108548: CALL_OW 3
108552: PPUSH
108553: CALL_OW 1
108557: ST_TO_ADDR
// end ; end ;
108558: GO 108387
108560: POP
108561: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108562: LD_VAR 0 1
108566: PPUSH
108567: LD_EXP 171
108571: PUSH
108572: LD_VAR 0 4
108576: ARRAY
108577: PUSH
108578: LD_INT 0
108580: PLUS
108581: PPUSH
108582: CALL_OW 505
// end ;
108586: LD_VAR 0 2
108590: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
108591: LD_INT 0
108593: PPUSH
108594: PPUSH
108595: PPUSH
108596: PPUSH
// if not hack in hackTanks then
108597: LD_VAR 0 1
108601: PUSH
108602: LD_EXP 170
108606: IN
108607: NOT
108608: IFFALSE 108612
// exit ;
108610: GO 108697
// index := GetElementIndex ( hackTanks , hack ) ;
108612: LD_ADDR_VAR 0 5
108616: PUSH
108617: LD_EXP 170
108621: PPUSH
108622: LD_VAR 0 1
108626: PPUSH
108627: CALL 21247 0 2
108631: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
108632: LD_ADDR_VAR 0 4
108636: PUSH
108637: DOUBLE
108638: LD_INT 1
108640: DEC
108641: ST_TO_ADDR
108642: LD_EXP 171
108646: PUSH
108647: LD_VAR 0 5
108651: ARRAY
108652: PUSH
108653: FOR_TO
108654: IFFALSE 108695
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
108656: LD_EXP 171
108660: PUSH
108661: LD_VAR 0 5
108665: ARRAY
108666: PUSH
108667: LD_VAR 0 4
108671: ARRAY
108672: PUSH
108673: LD_INT 1
108675: ARRAY
108676: PUSH
108677: LD_VAR 0 2
108681: EQUAL
108682: IFFALSE 108693
// KillUnit ( vehicle ) ;
108684: LD_VAR 0 2
108688: PPUSH
108689: CALL_OW 66
108693: GO 108653
108695: POP
108696: POP
// end ;
108697: LD_VAR 0 3
108701: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
108702: LD_EXP 175
108706: NOT
108707: IFFALSE 108742
108709: GO 108711
108711: DISABLE
// begin initMiner := true ;
108712: LD_ADDR_EXP 175
108716: PUSH
108717: LD_INT 1
108719: ST_TO_ADDR
// minersList := [ ] ;
108720: LD_ADDR_EXP 176
108724: PUSH
108725: EMPTY
108726: ST_TO_ADDR
// minerMinesList := [ ] ;
108727: LD_ADDR_EXP 177
108731: PUSH
108732: EMPTY
108733: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
108734: LD_ADDR_EXP 178
108738: PUSH
108739: LD_INT 5
108741: ST_TO_ADDR
// end ;
108742: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
108743: LD_EXP 175
108747: PUSH
108748: LD_INT 34
108750: PUSH
108751: LD_INT 81
108753: PUSH
108754: EMPTY
108755: LIST
108756: LIST
108757: PPUSH
108758: CALL_OW 69
108762: AND
108763: IFFALSE 109224
108765: GO 108767
108767: DISABLE
108768: LD_INT 0
108770: PPUSH
108771: PPUSH
108772: PPUSH
108773: PPUSH
// begin enable ;
108774: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108775: LD_ADDR_VAR 0 1
108779: PUSH
108780: LD_INT 34
108782: PUSH
108783: LD_INT 81
108785: PUSH
108786: EMPTY
108787: LIST
108788: LIST
108789: PPUSH
108790: CALL_OW 69
108794: PUSH
108795: FOR_IN
108796: IFFALSE 108868
// begin if not i in minersList then
108798: LD_VAR 0 1
108802: PUSH
108803: LD_EXP 176
108807: IN
108808: NOT
108809: IFFALSE 108866
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108811: LD_ADDR_EXP 176
108815: PUSH
108816: LD_EXP 176
108820: PPUSH
108821: LD_EXP 176
108825: PUSH
108826: LD_INT 1
108828: PLUS
108829: PPUSH
108830: LD_VAR 0 1
108834: PPUSH
108835: CALL_OW 1
108839: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108840: LD_ADDR_EXP 177
108844: PUSH
108845: LD_EXP 177
108849: PPUSH
108850: LD_EXP 177
108854: PUSH
108855: LD_INT 1
108857: PLUS
108858: PPUSH
108859: EMPTY
108860: PPUSH
108861: CALL_OW 1
108865: ST_TO_ADDR
// end end ;
108866: GO 108795
108868: POP
108869: POP
// for i := minerMinesList downto 1 do
108870: LD_ADDR_VAR 0 1
108874: PUSH
108875: DOUBLE
108876: LD_EXP 177
108880: INC
108881: ST_TO_ADDR
108882: LD_INT 1
108884: PUSH
108885: FOR_DOWNTO
108886: IFFALSE 109222
// begin if IsLive ( minersList [ i ] ) then
108888: LD_EXP 176
108892: PUSH
108893: LD_VAR 0 1
108897: ARRAY
108898: PPUSH
108899: CALL_OW 300
108903: IFFALSE 108931
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108905: LD_EXP 176
108909: PUSH
108910: LD_VAR 0 1
108914: ARRAY
108915: PPUSH
108916: LD_EXP 177
108920: PUSH
108921: LD_VAR 0 1
108925: ARRAY
108926: PPUSH
108927: CALL_OW 505
// if not minerMinesList [ i ] then
108931: LD_EXP 177
108935: PUSH
108936: LD_VAR 0 1
108940: ARRAY
108941: NOT
108942: IFFALSE 108946
// continue ;
108944: GO 108885
// for j := minerMinesList [ i ] downto 1 do
108946: LD_ADDR_VAR 0 2
108950: PUSH
108951: DOUBLE
108952: LD_EXP 177
108956: PUSH
108957: LD_VAR 0 1
108961: ARRAY
108962: INC
108963: ST_TO_ADDR
108964: LD_INT 1
108966: PUSH
108967: FOR_DOWNTO
108968: IFFALSE 109218
// begin side := GetSide ( minersList [ i ] ) ;
108970: LD_ADDR_VAR 0 3
108974: PUSH
108975: LD_EXP 176
108979: PUSH
108980: LD_VAR 0 1
108984: ARRAY
108985: PPUSH
108986: CALL_OW 255
108990: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108991: LD_ADDR_VAR 0 4
108995: PUSH
108996: LD_EXP 177
109000: PUSH
109001: LD_VAR 0 1
109005: ARRAY
109006: PUSH
109007: LD_VAR 0 2
109011: ARRAY
109012: PUSH
109013: LD_INT 1
109015: ARRAY
109016: PPUSH
109017: LD_EXP 177
109021: PUSH
109022: LD_VAR 0 1
109026: ARRAY
109027: PUSH
109028: LD_VAR 0 2
109032: ARRAY
109033: PUSH
109034: LD_INT 2
109036: ARRAY
109037: PPUSH
109038: CALL_OW 428
109042: ST_TO_ADDR
// if not tmp then
109043: LD_VAR 0 4
109047: NOT
109048: IFFALSE 109052
// continue ;
109050: GO 108967
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
109052: LD_VAR 0 4
109056: PUSH
109057: LD_INT 81
109059: PUSH
109060: LD_VAR 0 3
109064: PUSH
109065: EMPTY
109066: LIST
109067: LIST
109068: PPUSH
109069: CALL_OW 69
109073: IN
109074: PUSH
109075: LD_EXP 177
109079: PUSH
109080: LD_VAR 0 1
109084: ARRAY
109085: PUSH
109086: LD_VAR 0 2
109090: ARRAY
109091: PUSH
109092: LD_INT 1
109094: ARRAY
109095: PPUSH
109096: LD_EXP 177
109100: PUSH
109101: LD_VAR 0 1
109105: ARRAY
109106: PUSH
109107: LD_VAR 0 2
109111: ARRAY
109112: PUSH
109113: LD_INT 2
109115: ARRAY
109116: PPUSH
109117: CALL_OW 458
109121: AND
109122: IFFALSE 109216
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
109124: LD_EXP 177
109128: PUSH
109129: LD_VAR 0 1
109133: ARRAY
109134: PUSH
109135: LD_VAR 0 2
109139: ARRAY
109140: PUSH
109141: LD_INT 1
109143: ARRAY
109144: PPUSH
109145: LD_EXP 177
109149: PUSH
109150: LD_VAR 0 1
109154: ARRAY
109155: PUSH
109156: LD_VAR 0 2
109160: ARRAY
109161: PUSH
109162: LD_INT 2
109164: ARRAY
109165: PPUSH
109166: LD_VAR 0 3
109170: PPUSH
109171: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
109175: LD_ADDR_EXP 177
109179: PUSH
109180: LD_EXP 177
109184: PPUSH
109185: LD_VAR 0 1
109189: PPUSH
109190: LD_EXP 177
109194: PUSH
109195: LD_VAR 0 1
109199: ARRAY
109200: PPUSH
109201: LD_VAR 0 2
109205: PPUSH
109206: CALL_OW 3
109210: PPUSH
109211: CALL_OW 1
109215: ST_TO_ADDR
// end ; end ;
109216: GO 108967
109218: POP
109219: POP
// end ;
109220: GO 108885
109222: POP
109223: POP
// end ;
109224: PPOPN 4
109226: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
109227: LD_INT 0
109229: PPUSH
109230: PPUSH
// result := false ;
109231: LD_ADDR_VAR 0 4
109235: PUSH
109236: LD_INT 0
109238: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
109239: LD_VAR 0 1
109243: PPUSH
109244: CALL_OW 264
109248: PUSH
109249: LD_INT 81
109251: EQUAL
109252: NOT
109253: IFFALSE 109257
// exit ;
109255: GO 109497
// index := GetElementIndex ( minersList , unit ) ;
109257: LD_ADDR_VAR 0 5
109261: PUSH
109262: LD_EXP 176
109266: PPUSH
109267: LD_VAR 0 1
109271: PPUSH
109272: CALL 21247 0 2
109276: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
109277: LD_EXP 177
109281: PUSH
109282: LD_VAR 0 5
109286: ARRAY
109287: PUSH
109288: LD_EXP 178
109292: GREATEREQUAL
109293: IFFALSE 109297
// exit ;
109295: GO 109497
// ComMoveXY ( unit , x , y ) ;
109297: LD_VAR 0 1
109301: PPUSH
109302: LD_VAR 0 2
109306: PPUSH
109307: LD_VAR 0 3
109311: PPUSH
109312: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109316: LD_INT 35
109318: PPUSH
109319: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
109323: LD_VAR 0 1
109327: PPUSH
109328: LD_VAR 0 2
109332: PPUSH
109333: LD_VAR 0 3
109337: PPUSH
109338: CALL 52988 0 3
109342: NOT
109343: PUSH
109344: LD_VAR 0 1
109348: PPUSH
109349: CALL_OW 314
109353: AND
109354: IFFALSE 109358
// exit ;
109356: GO 109497
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
109358: LD_VAR 0 2
109362: PPUSH
109363: LD_VAR 0 3
109367: PPUSH
109368: CALL_OW 428
109372: PUSH
109373: LD_VAR 0 1
109377: EQUAL
109378: PUSH
109379: LD_VAR 0 1
109383: PPUSH
109384: CALL_OW 314
109388: NOT
109389: AND
109390: IFFALSE 109316
// PlaySoundXY ( x , y , PlantMine ) ;
109392: LD_VAR 0 2
109396: PPUSH
109397: LD_VAR 0 3
109401: PPUSH
109402: LD_STRING PlantMine
109404: PPUSH
109405: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
109409: LD_VAR 0 2
109413: PPUSH
109414: LD_VAR 0 3
109418: PPUSH
109419: LD_VAR 0 1
109423: PPUSH
109424: CALL_OW 255
109428: PPUSH
109429: LD_INT 0
109431: PPUSH
109432: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
109436: LD_ADDR_EXP 177
109440: PUSH
109441: LD_EXP 177
109445: PPUSH
109446: LD_VAR 0 5
109450: PUSH
109451: LD_EXP 177
109455: PUSH
109456: LD_VAR 0 5
109460: ARRAY
109461: PUSH
109462: LD_INT 1
109464: PLUS
109465: PUSH
109466: EMPTY
109467: LIST
109468: LIST
109469: PPUSH
109470: LD_VAR 0 2
109474: PUSH
109475: LD_VAR 0 3
109479: PUSH
109480: EMPTY
109481: LIST
109482: LIST
109483: PPUSH
109484: CALL 21462 0 3
109488: ST_TO_ADDR
// result := true ;
109489: LD_ADDR_VAR 0 4
109493: PUSH
109494: LD_INT 1
109496: ST_TO_ADDR
// end ;
109497: LD_VAR 0 4
109501: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
109502: LD_INT 0
109504: PPUSH
109505: PPUSH
109506: PPUSH
// if not unit in minersList then
109507: LD_VAR 0 1
109511: PUSH
109512: LD_EXP 176
109516: IN
109517: NOT
109518: IFFALSE 109522
// exit ;
109520: GO 109914
// index := GetElementIndex ( minersList , unit ) ;
109522: LD_ADDR_VAR 0 6
109526: PUSH
109527: LD_EXP 176
109531: PPUSH
109532: LD_VAR 0 1
109536: PPUSH
109537: CALL 21247 0 2
109541: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
109542: LD_ADDR_VAR 0 5
109546: PUSH
109547: DOUBLE
109548: LD_EXP 177
109552: PUSH
109553: LD_VAR 0 6
109557: ARRAY
109558: INC
109559: ST_TO_ADDR
109560: LD_INT 1
109562: PUSH
109563: FOR_DOWNTO
109564: IFFALSE 109725
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
109566: LD_EXP 177
109570: PUSH
109571: LD_VAR 0 6
109575: ARRAY
109576: PUSH
109577: LD_VAR 0 5
109581: ARRAY
109582: PUSH
109583: LD_INT 1
109585: ARRAY
109586: PUSH
109587: LD_VAR 0 2
109591: EQUAL
109592: PUSH
109593: LD_EXP 177
109597: PUSH
109598: LD_VAR 0 6
109602: ARRAY
109603: PUSH
109604: LD_VAR 0 5
109608: ARRAY
109609: PUSH
109610: LD_INT 2
109612: ARRAY
109613: PUSH
109614: LD_VAR 0 3
109618: EQUAL
109619: AND
109620: IFFALSE 109723
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109622: LD_EXP 177
109626: PUSH
109627: LD_VAR 0 6
109631: ARRAY
109632: PUSH
109633: LD_VAR 0 5
109637: ARRAY
109638: PUSH
109639: LD_INT 1
109641: ARRAY
109642: PPUSH
109643: LD_EXP 177
109647: PUSH
109648: LD_VAR 0 6
109652: ARRAY
109653: PUSH
109654: LD_VAR 0 5
109658: ARRAY
109659: PUSH
109660: LD_INT 2
109662: ARRAY
109663: PPUSH
109664: LD_VAR 0 1
109668: PPUSH
109669: CALL_OW 255
109673: PPUSH
109674: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109678: LD_ADDR_EXP 177
109682: PUSH
109683: LD_EXP 177
109687: PPUSH
109688: LD_VAR 0 6
109692: PPUSH
109693: LD_EXP 177
109697: PUSH
109698: LD_VAR 0 6
109702: ARRAY
109703: PPUSH
109704: LD_VAR 0 5
109708: PPUSH
109709: CALL_OW 3
109713: PPUSH
109714: CALL_OW 1
109718: ST_TO_ADDR
// exit ;
109719: POP
109720: POP
109721: GO 109914
// end ; end ;
109723: GO 109563
109725: POP
109726: POP
// for i := minerMinesList [ index ] downto 1 do
109727: LD_ADDR_VAR 0 5
109731: PUSH
109732: DOUBLE
109733: LD_EXP 177
109737: PUSH
109738: LD_VAR 0 6
109742: ARRAY
109743: INC
109744: ST_TO_ADDR
109745: LD_INT 1
109747: PUSH
109748: FOR_DOWNTO
109749: IFFALSE 109912
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109751: LD_EXP 177
109755: PUSH
109756: LD_VAR 0 6
109760: ARRAY
109761: PUSH
109762: LD_VAR 0 5
109766: ARRAY
109767: PUSH
109768: LD_INT 1
109770: ARRAY
109771: PPUSH
109772: LD_EXP 177
109776: PUSH
109777: LD_VAR 0 6
109781: ARRAY
109782: PUSH
109783: LD_VAR 0 5
109787: ARRAY
109788: PUSH
109789: LD_INT 2
109791: ARRAY
109792: PPUSH
109793: LD_VAR 0 2
109797: PPUSH
109798: LD_VAR 0 3
109802: PPUSH
109803: CALL_OW 298
109807: PUSH
109808: LD_INT 6
109810: LESS
109811: IFFALSE 109910
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109813: LD_EXP 177
109817: PUSH
109818: LD_VAR 0 6
109822: ARRAY
109823: PUSH
109824: LD_VAR 0 5
109828: ARRAY
109829: PUSH
109830: LD_INT 1
109832: ARRAY
109833: PPUSH
109834: LD_EXP 177
109838: PUSH
109839: LD_VAR 0 6
109843: ARRAY
109844: PUSH
109845: LD_VAR 0 5
109849: ARRAY
109850: PUSH
109851: LD_INT 2
109853: ARRAY
109854: PPUSH
109855: LD_VAR 0 1
109859: PPUSH
109860: CALL_OW 255
109864: PPUSH
109865: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109869: LD_ADDR_EXP 177
109873: PUSH
109874: LD_EXP 177
109878: PPUSH
109879: LD_VAR 0 6
109883: PPUSH
109884: LD_EXP 177
109888: PUSH
109889: LD_VAR 0 6
109893: ARRAY
109894: PPUSH
109895: LD_VAR 0 5
109899: PPUSH
109900: CALL_OW 3
109904: PPUSH
109905: CALL_OW 1
109909: ST_TO_ADDR
// end ; end ;
109910: GO 109748
109912: POP
109913: POP
// end ;
109914: LD_VAR 0 4
109918: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109919: LD_INT 0
109921: PPUSH
109922: PPUSH
109923: PPUSH
109924: PPUSH
109925: PPUSH
109926: PPUSH
109927: PPUSH
109928: PPUSH
109929: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109930: LD_VAR 0 1
109934: PPUSH
109935: CALL_OW 264
109939: PUSH
109940: LD_INT 81
109942: EQUAL
109943: NOT
109944: PUSH
109945: LD_VAR 0 1
109949: PUSH
109950: LD_EXP 176
109954: IN
109955: NOT
109956: OR
109957: IFFALSE 109961
// exit ;
109959: GO 110283
// index := GetElementIndex ( minersList , unit ) ;
109961: LD_ADDR_VAR 0 6
109965: PUSH
109966: LD_EXP 176
109970: PPUSH
109971: LD_VAR 0 1
109975: PPUSH
109976: CALL 21247 0 2
109980: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109981: LD_ADDR_VAR 0 8
109985: PUSH
109986: LD_EXP 178
109990: PUSH
109991: LD_EXP 177
109995: PUSH
109996: LD_VAR 0 6
110000: ARRAY
110001: MINUS
110002: ST_TO_ADDR
// if not minesFreeAmount then
110003: LD_VAR 0 8
110007: NOT
110008: IFFALSE 110012
// exit ;
110010: GO 110283
// tmp := [ ] ;
110012: LD_ADDR_VAR 0 7
110016: PUSH
110017: EMPTY
110018: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
110019: LD_ADDR_VAR 0 5
110023: PUSH
110024: DOUBLE
110025: LD_INT 1
110027: DEC
110028: ST_TO_ADDR
110029: LD_VAR 0 8
110033: PUSH
110034: FOR_TO
110035: IFFALSE 110230
// begin _d := rand ( 0 , 5 ) ;
110037: LD_ADDR_VAR 0 11
110041: PUSH
110042: LD_INT 0
110044: PPUSH
110045: LD_INT 5
110047: PPUSH
110048: CALL_OW 12
110052: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
110053: LD_ADDR_VAR 0 12
110057: PUSH
110058: LD_INT 2
110060: PPUSH
110061: LD_INT 6
110063: PPUSH
110064: CALL_OW 12
110068: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
110069: LD_ADDR_VAR 0 9
110073: PUSH
110074: LD_VAR 0 2
110078: PPUSH
110079: LD_VAR 0 11
110083: PPUSH
110084: LD_VAR 0 12
110088: PPUSH
110089: CALL_OW 272
110093: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
110094: LD_ADDR_VAR 0 10
110098: PUSH
110099: LD_VAR 0 3
110103: PPUSH
110104: LD_VAR 0 11
110108: PPUSH
110109: LD_VAR 0 12
110113: PPUSH
110114: CALL_OW 273
110118: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
110119: LD_VAR 0 9
110123: PPUSH
110124: LD_VAR 0 10
110128: PPUSH
110129: CALL_OW 488
110133: PUSH
110134: LD_VAR 0 9
110138: PUSH
110139: LD_VAR 0 10
110143: PUSH
110144: EMPTY
110145: LIST
110146: LIST
110147: PUSH
110148: LD_VAR 0 7
110152: IN
110153: NOT
110154: AND
110155: PUSH
110156: LD_VAR 0 9
110160: PPUSH
110161: LD_VAR 0 10
110165: PPUSH
110166: CALL_OW 458
110170: NOT
110171: AND
110172: IFFALSE 110214
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
110174: LD_ADDR_VAR 0 7
110178: PUSH
110179: LD_VAR 0 7
110183: PPUSH
110184: LD_VAR 0 7
110188: PUSH
110189: LD_INT 1
110191: PLUS
110192: PPUSH
110193: LD_VAR 0 9
110197: PUSH
110198: LD_VAR 0 10
110202: PUSH
110203: EMPTY
110204: LIST
110205: LIST
110206: PPUSH
110207: CALL_OW 1
110211: ST_TO_ADDR
110212: GO 110228
// i := i - 1 ;
110214: LD_ADDR_VAR 0 5
110218: PUSH
110219: LD_VAR 0 5
110223: PUSH
110224: LD_INT 1
110226: MINUS
110227: ST_TO_ADDR
// end ;
110228: GO 110034
110230: POP
110231: POP
// for i in tmp do
110232: LD_ADDR_VAR 0 5
110236: PUSH
110237: LD_VAR 0 7
110241: PUSH
110242: FOR_IN
110243: IFFALSE 110281
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
110245: LD_VAR 0 1
110249: PPUSH
110250: LD_VAR 0 5
110254: PUSH
110255: LD_INT 1
110257: ARRAY
110258: PPUSH
110259: LD_VAR 0 5
110263: PUSH
110264: LD_INT 2
110266: ARRAY
110267: PPUSH
110268: CALL 109227 0 3
110272: NOT
110273: IFFALSE 110279
// exit ;
110275: POP
110276: POP
110277: GO 110283
110279: GO 110242
110281: POP
110282: POP
// end ;
110283: LD_VAR 0 4
110287: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
110288: LD_INT 0
110290: PPUSH
110291: PPUSH
110292: PPUSH
110293: PPUSH
110294: PPUSH
110295: PPUSH
110296: PPUSH
// if not GetClass ( unit ) = class_sniper then
110297: LD_VAR 0 1
110301: PPUSH
110302: CALL_OW 257
110306: PUSH
110307: LD_INT 5
110309: EQUAL
110310: NOT
110311: IFFALSE 110315
// exit ;
110313: GO 110703
// dist := 8 ;
110315: LD_ADDR_VAR 0 5
110319: PUSH
110320: LD_INT 8
110322: ST_TO_ADDR
// viewRange := 12 ;
110323: LD_ADDR_VAR 0 7
110327: PUSH
110328: LD_INT 12
110330: ST_TO_ADDR
// side := GetSide ( unit ) ;
110331: LD_ADDR_VAR 0 6
110335: PUSH
110336: LD_VAR 0 1
110340: PPUSH
110341: CALL_OW 255
110345: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
110346: LD_INT 61
110348: PPUSH
110349: LD_VAR 0 6
110353: PPUSH
110354: CALL_OW 321
110358: PUSH
110359: LD_INT 2
110361: EQUAL
110362: IFFALSE 110372
// viewRange := 16 ;
110364: LD_ADDR_VAR 0 7
110368: PUSH
110369: LD_INT 16
110371: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
110372: LD_VAR 0 1
110376: PPUSH
110377: LD_VAR 0 2
110381: PPUSH
110382: LD_VAR 0 3
110386: PPUSH
110387: CALL_OW 297
110391: PUSH
110392: LD_VAR 0 5
110396: GREATER
110397: IFFALSE 110476
// begin ComMoveXY ( unit , x , y ) ;
110399: LD_VAR 0 1
110403: PPUSH
110404: LD_VAR 0 2
110408: PPUSH
110409: LD_VAR 0 3
110413: PPUSH
110414: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110418: LD_INT 35
110420: PPUSH
110421: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
110425: LD_VAR 0 1
110429: PPUSH
110430: LD_VAR 0 2
110434: PPUSH
110435: LD_VAR 0 3
110439: PPUSH
110440: CALL 52988 0 3
110444: NOT
110445: IFFALSE 110449
// exit ;
110447: GO 110703
// until GetDistUnitXY ( unit , x , y ) < dist ;
110449: LD_VAR 0 1
110453: PPUSH
110454: LD_VAR 0 2
110458: PPUSH
110459: LD_VAR 0 3
110463: PPUSH
110464: CALL_OW 297
110468: PUSH
110469: LD_VAR 0 5
110473: LESS
110474: IFFALSE 110418
// end ; ComTurnXY ( unit , x , y ) ;
110476: LD_VAR 0 1
110480: PPUSH
110481: LD_VAR 0 2
110485: PPUSH
110486: LD_VAR 0 3
110490: PPUSH
110491: CALL_OW 118
// wait ( 5 ) ;
110495: LD_INT 5
110497: PPUSH
110498: CALL_OW 67
// _d := GetDir ( unit ) ;
110502: LD_ADDR_VAR 0 10
110506: PUSH
110507: LD_VAR 0 1
110511: PPUSH
110512: CALL_OW 254
110516: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
110517: LD_ADDR_VAR 0 8
110521: PUSH
110522: LD_VAR 0 1
110526: PPUSH
110527: CALL_OW 250
110531: PPUSH
110532: LD_VAR 0 10
110536: PPUSH
110537: LD_VAR 0 5
110541: PPUSH
110542: CALL_OW 272
110546: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
110547: LD_ADDR_VAR 0 9
110551: PUSH
110552: LD_VAR 0 1
110556: PPUSH
110557: CALL_OW 251
110561: PPUSH
110562: LD_VAR 0 10
110566: PPUSH
110567: LD_VAR 0 5
110571: PPUSH
110572: CALL_OW 273
110576: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110577: LD_VAR 0 8
110581: PPUSH
110582: LD_VAR 0 9
110586: PPUSH
110587: CALL_OW 488
110591: NOT
110592: IFFALSE 110596
// exit ;
110594: GO 110703
// ComAnimCustom ( unit , 1 ) ;
110596: LD_VAR 0 1
110600: PPUSH
110601: LD_INT 1
110603: PPUSH
110604: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
110608: LD_VAR 0 8
110612: PPUSH
110613: LD_VAR 0 9
110617: PPUSH
110618: LD_VAR 0 6
110622: PPUSH
110623: LD_VAR 0 7
110627: PPUSH
110628: CALL_OW 330
// repeat wait ( 1 ) ;
110632: LD_INT 1
110634: PPUSH
110635: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
110639: LD_VAR 0 1
110643: PPUSH
110644: CALL_OW 316
110648: PUSH
110649: LD_VAR 0 1
110653: PPUSH
110654: CALL_OW 314
110658: OR
110659: PUSH
110660: LD_VAR 0 1
110664: PPUSH
110665: CALL_OW 302
110669: NOT
110670: OR
110671: PUSH
110672: LD_VAR 0 1
110676: PPUSH
110677: CALL_OW 301
110681: OR
110682: IFFALSE 110632
// RemoveSeeing ( _x , _y , side ) ;
110684: LD_VAR 0 8
110688: PPUSH
110689: LD_VAR 0 9
110693: PPUSH
110694: LD_VAR 0 6
110698: PPUSH
110699: CALL_OW 331
// end ; end_of_file
110703: LD_VAR 0 4
110707: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
110708: LD_INT 0
110710: PPUSH
110711: PPUSH
110712: PPUSH
110713: PPUSH
110714: PPUSH
110715: PPUSH
110716: PPUSH
110717: PPUSH
110718: PPUSH
110719: PPUSH
110720: PPUSH
110721: PPUSH
110722: PPUSH
110723: PPUSH
110724: PPUSH
110725: PPUSH
110726: PPUSH
110727: PPUSH
110728: PPUSH
110729: PPUSH
110730: PPUSH
110731: PPUSH
110732: PPUSH
110733: PPUSH
110734: PPUSH
110735: PPUSH
110736: PPUSH
110737: PPUSH
110738: PPUSH
110739: PPUSH
110740: PPUSH
110741: PPUSH
110742: PPUSH
110743: PPUSH
// if not list then
110744: LD_VAR 0 1
110748: NOT
110749: IFFALSE 110753
// exit ;
110751: GO 115412
// base := list [ 1 ] ;
110753: LD_ADDR_VAR 0 3
110757: PUSH
110758: LD_VAR 0 1
110762: PUSH
110763: LD_INT 1
110765: ARRAY
110766: ST_TO_ADDR
// group := list [ 2 ] ;
110767: LD_ADDR_VAR 0 4
110771: PUSH
110772: LD_VAR 0 1
110776: PUSH
110777: LD_INT 2
110779: ARRAY
110780: ST_TO_ADDR
// path := list [ 3 ] ;
110781: LD_ADDR_VAR 0 5
110785: PUSH
110786: LD_VAR 0 1
110790: PUSH
110791: LD_INT 3
110793: ARRAY
110794: ST_TO_ADDR
// flags := list [ 4 ] ;
110795: LD_ADDR_VAR 0 6
110799: PUSH
110800: LD_VAR 0 1
110804: PUSH
110805: LD_INT 4
110807: ARRAY
110808: ST_TO_ADDR
// mined := [ ] ;
110809: LD_ADDR_VAR 0 27
110813: PUSH
110814: EMPTY
110815: ST_TO_ADDR
// bombed := [ ] ;
110816: LD_ADDR_VAR 0 28
110820: PUSH
110821: EMPTY
110822: ST_TO_ADDR
// healers := [ ] ;
110823: LD_ADDR_VAR 0 31
110827: PUSH
110828: EMPTY
110829: ST_TO_ADDR
// to_heal := [ ] ;
110830: LD_ADDR_VAR 0 30
110834: PUSH
110835: EMPTY
110836: ST_TO_ADDR
// repairs := [ ] ;
110837: LD_ADDR_VAR 0 33
110841: PUSH
110842: EMPTY
110843: ST_TO_ADDR
// to_repair := [ ] ;
110844: LD_ADDR_VAR 0 32
110848: PUSH
110849: EMPTY
110850: ST_TO_ADDR
// if not group or not path then
110851: LD_VAR 0 4
110855: NOT
110856: PUSH
110857: LD_VAR 0 5
110861: NOT
110862: OR
110863: IFFALSE 110867
// exit ;
110865: GO 115412
// side := GetSide ( group [ 1 ] ) ;
110867: LD_ADDR_VAR 0 35
110871: PUSH
110872: LD_VAR 0 4
110876: PUSH
110877: LD_INT 1
110879: ARRAY
110880: PPUSH
110881: CALL_OW 255
110885: ST_TO_ADDR
// if flags then
110886: LD_VAR 0 6
110890: IFFALSE 111034
// begin f_ignore_area := flags [ 1 ] ;
110892: LD_ADDR_VAR 0 17
110896: PUSH
110897: LD_VAR 0 6
110901: PUSH
110902: LD_INT 1
110904: ARRAY
110905: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110906: LD_ADDR_VAR 0 18
110910: PUSH
110911: LD_VAR 0 6
110915: PUSH
110916: LD_INT 2
110918: ARRAY
110919: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110920: LD_ADDR_VAR 0 19
110924: PUSH
110925: LD_VAR 0 6
110929: PUSH
110930: LD_INT 3
110932: ARRAY
110933: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110934: LD_ADDR_VAR 0 20
110938: PUSH
110939: LD_VAR 0 6
110943: PUSH
110944: LD_INT 4
110946: ARRAY
110947: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110948: LD_ADDR_VAR 0 21
110952: PUSH
110953: LD_VAR 0 6
110957: PUSH
110958: LD_INT 5
110960: ARRAY
110961: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110962: LD_ADDR_VAR 0 22
110966: PUSH
110967: LD_VAR 0 6
110971: PUSH
110972: LD_INT 6
110974: ARRAY
110975: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110976: LD_ADDR_VAR 0 23
110980: PUSH
110981: LD_VAR 0 6
110985: PUSH
110986: LD_INT 7
110988: ARRAY
110989: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110990: LD_ADDR_VAR 0 24
110994: PUSH
110995: LD_VAR 0 6
110999: PUSH
111000: LD_INT 8
111002: ARRAY
111003: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
111004: LD_ADDR_VAR 0 25
111008: PUSH
111009: LD_VAR 0 6
111013: PUSH
111014: LD_INT 9
111016: ARRAY
111017: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
111018: LD_ADDR_VAR 0 26
111022: PUSH
111023: LD_VAR 0 6
111027: PUSH
111028: LD_INT 10
111030: ARRAY
111031: ST_TO_ADDR
// end else
111032: GO 111114
// begin f_ignore_area := false ;
111034: LD_ADDR_VAR 0 17
111038: PUSH
111039: LD_INT 0
111041: ST_TO_ADDR
// f_capture := false ;
111042: LD_ADDR_VAR 0 18
111046: PUSH
111047: LD_INT 0
111049: ST_TO_ADDR
// f_ignore_civ := false ;
111050: LD_ADDR_VAR 0 19
111054: PUSH
111055: LD_INT 0
111057: ST_TO_ADDR
// f_murder := false ;
111058: LD_ADDR_VAR 0 20
111062: PUSH
111063: LD_INT 0
111065: ST_TO_ADDR
// f_mines := false ;
111066: LD_ADDR_VAR 0 21
111070: PUSH
111071: LD_INT 0
111073: ST_TO_ADDR
// f_repair := false ;
111074: LD_ADDR_VAR 0 22
111078: PUSH
111079: LD_INT 0
111081: ST_TO_ADDR
// f_heal := false ;
111082: LD_ADDR_VAR 0 23
111086: PUSH
111087: LD_INT 0
111089: ST_TO_ADDR
// f_spacetime := false ;
111090: LD_ADDR_VAR 0 24
111094: PUSH
111095: LD_INT 0
111097: ST_TO_ADDR
// f_attack_depot := false ;
111098: LD_ADDR_VAR 0 25
111102: PUSH
111103: LD_INT 0
111105: ST_TO_ADDR
// f_crawl := false ;
111106: LD_ADDR_VAR 0 26
111110: PUSH
111111: LD_INT 0
111113: ST_TO_ADDR
// end ; if f_heal then
111114: LD_VAR 0 23
111118: IFFALSE 111145
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
111120: LD_ADDR_VAR 0 31
111124: PUSH
111125: LD_VAR 0 4
111129: PPUSH
111130: LD_INT 25
111132: PUSH
111133: LD_INT 4
111135: PUSH
111136: EMPTY
111137: LIST
111138: LIST
111139: PPUSH
111140: CALL_OW 72
111144: ST_TO_ADDR
// if f_repair then
111145: LD_VAR 0 22
111149: IFFALSE 111176
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
111151: LD_ADDR_VAR 0 33
111155: PUSH
111156: LD_VAR 0 4
111160: PPUSH
111161: LD_INT 25
111163: PUSH
111164: LD_INT 3
111166: PUSH
111167: EMPTY
111168: LIST
111169: LIST
111170: PPUSH
111171: CALL_OW 72
111175: ST_TO_ADDR
// units_path := [ ] ;
111176: LD_ADDR_VAR 0 16
111180: PUSH
111181: EMPTY
111182: ST_TO_ADDR
// for i = 1 to group do
111183: LD_ADDR_VAR 0 7
111187: PUSH
111188: DOUBLE
111189: LD_INT 1
111191: DEC
111192: ST_TO_ADDR
111193: LD_VAR 0 4
111197: PUSH
111198: FOR_TO
111199: IFFALSE 111228
// units_path := Replace ( units_path , i , path ) ;
111201: LD_ADDR_VAR 0 16
111205: PUSH
111206: LD_VAR 0 16
111210: PPUSH
111211: LD_VAR 0 7
111215: PPUSH
111216: LD_VAR 0 5
111220: PPUSH
111221: CALL_OW 1
111225: ST_TO_ADDR
111226: GO 111198
111228: POP
111229: POP
// repeat for i = group downto 1 do
111230: LD_ADDR_VAR 0 7
111234: PUSH
111235: DOUBLE
111236: LD_VAR 0 4
111240: INC
111241: ST_TO_ADDR
111242: LD_INT 1
111244: PUSH
111245: FOR_DOWNTO
111246: IFFALSE 115368
// begin wait ( 5 ) ;
111248: LD_INT 5
111250: PPUSH
111251: CALL_OW 67
// tmp := [ ] ;
111255: LD_ADDR_VAR 0 14
111259: PUSH
111260: EMPTY
111261: ST_TO_ADDR
// attacking := false ;
111262: LD_ADDR_VAR 0 29
111266: PUSH
111267: LD_INT 0
111269: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
111270: LD_VAR 0 4
111274: PUSH
111275: LD_VAR 0 7
111279: ARRAY
111280: PPUSH
111281: CALL_OW 301
111285: PUSH
111286: LD_VAR 0 4
111290: PUSH
111291: LD_VAR 0 7
111295: ARRAY
111296: NOT
111297: OR
111298: IFFALSE 111407
// begin if GetType ( group [ i ] ) = unit_human then
111300: LD_VAR 0 4
111304: PUSH
111305: LD_VAR 0 7
111309: ARRAY
111310: PPUSH
111311: CALL_OW 247
111315: PUSH
111316: LD_INT 1
111318: EQUAL
111319: IFFALSE 111365
// begin to_heal := to_heal diff group [ i ] ;
111321: LD_ADDR_VAR 0 30
111325: PUSH
111326: LD_VAR 0 30
111330: PUSH
111331: LD_VAR 0 4
111335: PUSH
111336: LD_VAR 0 7
111340: ARRAY
111341: DIFF
111342: ST_TO_ADDR
// healers := healers diff group [ i ] ;
111343: LD_ADDR_VAR 0 31
111347: PUSH
111348: LD_VAR 0 31
111352: PUSH
111353: LD_VAR 0 4
111357: PUSH
111358: LD_VAR 0 7
111362: ARRAY
111363: DIFF
111364: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
111365: LD_ADDR_VAR 0 4
111369: PUSH
111370: LD_VAR 0 4
111374: PPUSH
111375: LD_VAR 0 7
111379: PPUSH
111380: CALL_OW 3
111384: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
111385: LD_ADDR_VAR 0 16
111389: PUSH
111390: LD_VAR 0 16
111394: PPUSH
111395: LD_VAR 0 7
111399: PPUSH
111400: CALL_OW 3
111404: ST_TO_ADDR
// continue ;
111405: GO 111245
// end ; if f_repair then
111407: LD_VAR 0 22
111411: IFFALSE 111900
// begin if GetType ( group [ i ] ) = unit_vehicle then
111413: LD_VAR 0 4
111417: PUSH
111418: LD_VAR 0 7
111422: ARRAY
111423: PPUSH
111424: CALL_OW 247
111428: PUSH
111429: LD_INT 2
111431: EQUAL
111432: IFFALSE 111622
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
111434: LD_VAR 0 4
111438: PUSH
111439: LD_VAR 0 7
111443: ARRAY
111444: PPUSH
111445: CALL_OW 256
111449: PUSH
111450: LD_INT 700
111452: LESS
111453: PUSH
111454: LD_VAR 0 4
111458: PUSH
111459: LD_VAR 0 7
111463: ARRAY
111464: PUSH
111465: LD_VAR 0 32
111469: IN
111470: NOT
111471: AND
111472: IFFALSE 111496
// to_repair := to_repair union group [ i ] ;
111474: LD_ADDR_VAR 0 32
111478: PUSH
111479: LD_VAR 0 32
111483: PUSH
111484: LD_VAR 0 4
111488: PUSH
111489: LD_VAR 0 7
111493: ARRAY
111494: UNION
111495: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
111496: LD_VAR 0 4
111500: PUSH
111501: LD_VAR 0 7
111505: ARRAY
111506: PPUSH
111507: CALL_OW 256
111511: PUSH
111512: LD_INT 1000
111514: EQUAL
111515: PUSH
111516: LD_VAR 0 4
111520: PUSH
111521: LD_VAR 0 7
111525: ARRAY
111526: PUSH
111527: LD_VAR 0 32
111531: IN
111532: AND
111533: IFFALSE 111557
// to_repair := to_repair diff group [ i ] ;
111535: LD_ADDR_VAR 0 32
111539: PUSH
111540: LD_VAR 0 32
111544: PUSH
111545: LD_VAR 0 4
111549: PUSH
111550: LD_VAR 0 7
111554: ARRAY
111555: DIFF
111556: ST_TO_ADDR
// if group [ i ] in to_repair then
111557: LD_VAR 0 4
111561: PUSH
111562: LD_VAR 0 7
111566: ARRAY
111567: PUSH
111568: LD_VAR 0 32
111572: IN
111573: IFFALSE 111620
// begin if not IsInArea ( group [ i ] , f_repair ) then
111575: LD_VAR 0 4
111579: PUSH
111580: LD_VAR 0 7
111584: ARRAY
111585: PPUSH
111586: LD_VAR 0 22
111590: PPUSH
111591: CALL_OW 308
111595: NOT
111596: IFFALSE 111618
// ComMoveToArea ( group [ i ] , f_repair ) ;
111598: LD_VAR 0 4
111602: PUSH
111603: LD_VAR 0 7
111607: ARRAY
111608: PPUSH
111609: LD_VAR 0 22
111613: PPUSH
111614: CALL_OW 113
// continue ;
111618: GO 111245
// end ; end else
111620: GO 111900
// if group [ i ] in repairs then
111622: LD_VAR 0 4
111626: PUSH
111627: LD_VAR 0 7
111631: ARRAY
111632: PUSH
111633: LD_VAR 0 33
111637: IN
111638: IFFALSE 111900
// begin if IsInUnit ( group [ i ] ) then
111640: LD_VAR 0 4
111644: PUSH
111645: LD_VAR 0 7
111649: ARRAY
111650: PPUSH
111651: CALL_OW 310
111655: IFFALSE 111723
// begin z := IsInUnit ( group [ i ] ) ;
111657: LD_ADDR_VAR 0 13
111661: PUSH
111662: LD_VAR 0 4
111666: PUSH
111667: LD_VAR 0 7
111671: ARRAY
111672: PPUSH
111673: CALL_OW 310
111677: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
111678: LD_VAR 0 13
111682: PUSH
111683: LD_VAR 0 32
111687: IN
111688: PUSH
111689: LD_VAR 0 13
111693: PPUSH
111694: LD_VAR 0 22
111698: PPUSH
111699: CALL_OW 308
111703: AND
111704: IFFALSE 111721
// ComExitVehicle ( group [ i ] ) ;
111706: LD_VAR 0 4
111710: PUSH
111711: LD_VAR 0 7
111715: ARRAY
111716: PPUSH
111717: CALL_OW 121
// end else
111721: GO 111900
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
111723: LD_ADDR_VAR 0 13
111727: PUSH
111728: LD_VAR 0 4
111732: PPUSH
111733: LD_INT 95
111735: PUSH
111736: LD_VAR 0 22
111740: PUSH
111741: EMPTY
111742: LIST
111743: LIST
111744: PUSH
111745: LD_INT 58
111747: PUSH
111748: EMPTY
111749: LIST
111750: PUSH
111751: EMPTY
111752: LIST
111753: LIST
111754: PPUSH
111755: CALL_OW 72
111759: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111760: LD_VAR 0 4
111764: PUSH
111765: LD_VAR 0 7
111769: ARRAY
111770: PPUSH
111771: CALL_OW 314
111775: NOT
111776: IFFALSE 111898
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111778: LD_ADDR_VAR 0 10
111782: PUSH
111783: LD_VAR 0 13
111787: PPUSH
111788: LD_VAR 0 4
111792: PUSH
111793: LD_VAR 0 7
111797: ARRAY
111798: PPUSH
111799: CALL_OW 74
111803: ST_TO_ADDR
// if not x then
111804: LD_VAR 0 10
111808: NOT
111809: IFFALSE 111813
// continue ;
111811: GO 111245
// if GetLives ( x ) < 1000 then
111813: LD_VAR 0 10
111817: PPUSH
111818: CALL_OW 256
111822: PUSH
111823: LD_INT 1000
111825: LESS
111826: IFFALSE 111850
// ComRepairVehicle ( group [ i ] , x ) else
111828: LD_VAR 0 4
111832: PUSH
111833: LD_VAR 0 7
111837: ARRAY
111838: PPUSH
111839: LD_VAR 0 10
111843: PPUSH
111844: CALL_OW 129
111848: GO 111898
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111850: LD_VAR 0 23
111854: PUSH
111855: LD_VAR 0 4
111859: PUSH
111860: LD_VAR 0 7
111864: ARRAY
111865: PPUSH
111866: CALL_OW 256
111870: PUSH
111871: LD_INT 1000
111873: LESS
111874: AND
111875: NOT
111876: IFFALSE 111898
// ComEnterUnit ( group [ i ] , x ) ;
111878: LD_VAR 0 4
111882: PUSH
111883: LD_VAR 0 7
111887: ARRAY
111888: PPUSH
111889: LD_VAR 0 10
111893: PPUSH
111894: CALL_OW 120
// end ; continue ;
111898: GO 111245
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111900: LD_VAR 0 23
111904: PUSH
111905: LD_VAR 0 4
111909: PUSH
111910: LD_VAR 0 7
111914: ARRAY
111915: PPUSH
111916: CALL_OW 247
111920: PUSH
111921: LD_INT 1
111923: EQUAL
111924: AND
111925: IFFALSE 112403
// begin if group [ i ] in healers then
111927: LD_VAR 0 4
111931: PUSH
111932: LD_VAR 0 7
111936: ARRAY
111937: PUSH
111938: LD_VAR 0 31
111942: IN
111943: IFFALSE 112216
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111945: LD_VAR 0 4
111949: PUSH
111950: LD_VAR 0 7
111954: ARRAY
111955: PPUSH
111956: LD_VAR 0 23
111960: PPUSH
111961: CALL_OW 308
111965: NOT
111966: PUSH
111967: LD_VAR 0 4
111971: PUSH
111972: LD_VAR 0 7
111976: ARRAY
111977: PPUSH
111978: CALL_OW 314
111982: NOT
111983: AND
111984: IFFALSE 112008
// ComMoveToArea ( group [ i ] , f_heal ) else
111986: LD_VAR 0 4
111990: PUSH
111991: LD_VAR 0 7
111995: ARRAY
111996: PPUSH
111997: LD_VAR 0 23
112001: PPUSH
112002: CALL_OW 113
112006: GO 112214
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
112008: LD_VAR 0 4
112012: PUSH
112013: LD_VAR 0 7
112017: ARRAY
112018: PPUSH
112019: CALL 51571 0 1
112023: PPUSH
112024: CALL_OW 256
112028: PUSH
112029: LD_INT 1000
112031: EQUAL
112032: IFFALSE 112051
// ComStop ( group [ i ] ) else
112034: LD_VAR 0 4
112038: PUSH
112039: LD_VAR 0 7
112043: ARRAY
112044: PPUSH
112045: CALL_OW 141
112049: GO 112214
// if not HasTask ( group [ i ] ) and to_heal then
112051: LD_VAR 0 4
112055: PUSH
112056: LD_VAR 0 7
112060: ARRAY
112061: PPUSH
112062: CALL_OW 314
112066: NOT
112067: PUSH
112068: LD_VAR 0 30
112072: AND
112073: IFFALSE 112214
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
112075: LD_ADDR_VAR 0 13
112079: PUSH
112080: LD_VAR 0 30
112084: PPUSH
112085: LD_INT 3
112087: PUSH
112088: LD_INT 54
112090: PUSH
112091: EMPTY
112092: LIST
112093: PUSH
112094: EMPTY
112095: LIST
112096: LIST
112097: PPUSH
112098: CALL_OW 72
112102: PPUSH
112103: LD_VAR 0 4
112107: PUSH
112108: LD_VAR 0 7
112112: ARRAY
112113: PPUSH
112114: CALL_OW 74
112118: ST_TO_ADDR
// if z then
112119: LD_VAR 0 13
112123: IFFALSE 112214
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
112125: LD_INT 91
112127: PUSH
112128: LD_VAR 0 13
112132: PUSH
112133: LD_INT 10
112135: PUSH
112136: EMPTY
112137: LIST
112138: LIST
112139: LIST
112140: PUSH
112141: LD_INT 81
112143: PUSH
112144: LD_VAR 0 13
112148: PPUSH
112149: CALL_OW 255
112153: PUSH
112154: EMPTY
112155: LIST
112156: LIST
112157: PUSH
112158: EMPTY
112159: LIST
112160: LIST
112161: PPUSH
112162: CALL_OW 69
112166: PUSH
112167: LD_INT 0
112169: EQUAL
112170: IFFALSE 112194
// ComHeal ( group [ i ] , z ) else
112172: LD_VAR 0 4
112176: PUSH
112177: LD_VAR 0 7
112181: ARRAY
112182: PPUSH
112183: LD_VAR 0 13
112187: PPUSH
112188: CALL_OW 128
112192: GO 112214
// ComMoveToArea ( group [ i ] , f_heal ) ;
112194: LD_VAR 0 4
112198: PUSH
112199: LD_VAR 0 7
112203: ARRAY
112204: PPUSH
112205: LD_VAR 0 23
112209: PPUSH
112210: CALL_OW 113
// end ; continue ;
112214: GO 111245
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
112216: LD_VAR 0 4
112220: PUSH
112221: LD_VAR 0 7
112225: ARRAY
112226: PPUSH
112227: CALL_OW 256
112231: PUSH
112232: LD_INT 700
112234: LESS
112235: PUSH
112236: LD_VAR 0 4
112240: PUSH
112241: LD_VAR 0 7
112245: ARRAY
112246: PUSH
112247: LD_VAR 0 30
112251: IN
112252: NOT
112253: AND
112254: IFFALSE 112278
// to_heal := to_heal union group [ i ] ;
112256: LD_ADDR_VAR 0 30
112260: PUSH
112261: LD_VAR 0 30
112265: PUSH
112266: LD_VAR 0 4
112270: PUSH
112271: LD_VAR 0 7
112275: ARRAY
112276: UNION
112277: ST_TO_ADDR
// if group [ i ] in to_heal then
112278: LD_VAR 0 4
112282: PUSH
112283: LD_VAR 0 7
112287: ARRAY
112288: PUSH
112289: LD_VAR 0 30
112293: IN
112294: IFFALSE 112403
// begin if GetLives ( group [ i ] ) = 1000 then
112296: LD_VAR 0 4
112300: PUSH
112301: LD_VAR 0 7
112305: ARRAY
112306: PPUSH
112307: CALL_OW 256
112311: PUSH
112312: LD_INT 1000
112314: EQUAL
112315: IFFALSE 112341
// to_heal := to_heal diff group [ i ] else
112317: LD_ADDR_VAR 0 30
112321: PUSH
112322: LD_VAR 0 30
112326: PUSH
112327: LD_VAR 0 4
112331: PUSH
112332: LD_VAR 0 7
112336: ARRAY
112337: DIFF
112338: ST_TO_ADDR
112339: GO 112403
// begin if not IsInArea ( group [ i ] , to_heal ) then
112341: LD_VAR 0 4
112345: PUSH
112346: LD_VAR 0 7
112350: ARRAY
112351: PPUSH
112352: LD_VAR 0 30
112356: PPUSH
112357: CALL_OW 308
112361: NOT
112362: IFFALSE 112386
// ComMoveToArea ( group [ i ] , f_heal ) else
112364: LD_VAR 0 4
112368: PUSH
112369: LD_VAR 0 7
112373: ARRAY
112374: PPUSH
112375: LD_VAR 0 23
112379: PPUSH
112380: CALL_OW 113
112384: GO 112401
// ComHold ( group [ i ] ) ;
112386: LD_VAR 0 4
112390: PUSH
112391: LD_VAR 0 7
112395: ARRAY
112396: PPUSH
112397: CALL_OW 140
// continue ;
112401: GO 111245
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
112403: LD_VAR 0 4
112407: PUSH
112408: LD_VAR 0 7
112412: ARRAY
112413: PPUSH
112414: LD_INT 10
112416: PPUSH
112417: CALL 49353 0 2
112421: NOT
112422: PUSH
112423: LD_VAR 0 16
112427: PUSH
112428: LD_VAR 0 7
112432: ARRAY
112433: PUSH
112434: EMPTY
112435: EQUAL
112436: NOT
112437: AND
112438: IFFALSE 112704
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
112440: LD_VAR 0 4
112444: PUSH
112445: LD_VAR 0 7
112449: ARRAY
112450: PPUSH
112451: CALL_OW 262
112455: PUSH
112456: LD_INT 1
112458: PUSH
112459: LD_INT 2
112461: PUSH
112462: EMPTY
112463: LIST
112464: LIST
112465: IN
112466: IFFALSE 112507
// if GetFuel ( group [ i ] ) < 10 then
112468: LD_VAR 0 4
112472: PUSH
112473: LD_VAR 0 7
112477: ARRAY
112478: PPUSH
112479: CALL_OW 261
112483: PUSH
112484: LD_INT 10
112486: LESS
112487: IFFALSE 112507
// SetFuel ( group [ i ] , 12 ) ;
112489: LD_VAR 0 4
112493: PUSH
112494: LD_VAR 0 7
112498: ARRAY
112499: PPUSH
112500: LD_INT 12
112502: PPUSH
112503: CALL_OW 240
// if units_path [ i ] then
112507: LD_VAR 0 16
112511: PUSH
112512: LD_VAR 0 7
112516: ARRAY
112517: IFFALSE 112702
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
112519: LD_VAR 0 4
112523: PUSH
112524: LD_VAR 0 7
112528: ARRAY
112529: PPUSH
112530: LD_VAR 0 16
112534: PUSH
112535: LD_VAR 0 7
112539: ARRAY
112540: PUSH
112541: LD_INT 1
112543: ARRAY
112544: PUSH
112545: LD_INT 1
112547: ARRAY
112548: PPUSH
112549: LD_VAR 0 16
112553: PUSH
112554: LD_VAR 0 7
112558: ARRAY
112559: PUSH
112560: LD_INT 1
112562: ARRAY
112563: PUSH
112564: LD_INT 2
112566: ARRAY
112567: PPUSH
112568: CALL_OW 297
112572: PUSH
112573: LD_INT 6
112575: GREATER
112576: IFFALSE 112651
// begin if not HasTask ( group [ i ] ) then
112578: LD_VAR 0 4
112582: PUSH
112583: LD_VAR 0 7
112587: ARRAY
112588: PPUSH
112589: CALL_OW 314
112593: NOT
112594: IFFALSE 112649
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
112596: LD_VAR 0 4
112600: PUSH
112601: LD_VAR 0 7
112605: ARRAY
112606: PPUSH
112607: LD_VAR 0 16
112611: PUSH
112612: LD_VAR 0 7
112616: ARRAY
112617: PUSH
112618: LD_INT 1
112620: ARRAY
112621: PUSH
112622: LD_INT 1
112624: ARRAY
112625: PPUSH
112626: LD_VAR 0 16
112630: PUSH
112631: LD_VAR 0 7
112635: ARRAY
112636: PUSH
112637: LD_INT 1
112639: ARRAY
112640: PUSH
112641: LD_INT 2
112643: ARRAY
112644: PPUSH
112645: CALL_OW 114
// end else
112649: GO 112702
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
112651: LD_ADDR_VAR 0 15
112655: PUSH
112656: LD_VAR 0 16
112660: PUSH
112661: LD_VAR 0 7
112665: ARRAY
112666: PPUSH
112667: LD_INT 1
112669: PPUSH
112670: CALL_OW 3
112674: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
112675: LD_ADDR_VAR 0 16
112679: PUSH
112680: LD_VAR 0 16
112684: PPUSH
112685: LD_VAR 0 7
112689: PPUSH
112690: LD_VAR 0 15
112694: PPUSH
112695: CALL_OW 1
112699: ST_TO_ADDR
// continue ;
112700: GO 111245
// end ; end ; end else
112702: GO 115366
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
112704: LD_ADDR_VAR 0 14
112708: PUSH
112709: LD_INT 81
112711: PUSH
112712: LD_VAR 0 4
112716: PUSH
112717: LD_VAR 0 7
112721: ARRAY
112722: PPUSH
112723: CALL_OW 255
112727: PUSH
112728: EMPTY
112729: LIST
112730: LIST
112731: PPUSH
112732: CALL_OW 69
112736: ST_TO_ADDR
// if not tmp then
112737: LD_VAR 0 14
112741: NOT
112742: IFFALSE 112746
// continue ;
112744: GO 111245
// if f_ignore_area then
112746: LD_VAR 0 17
112750: IFFALSE 112838
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112752: LD_ADDR_VAR 0 15
112756: PUSH
112757: LD_VAR 0 14
112761: PPUSH
112762: LD_INT 3
112764: PUSH
112765: LD_INT 92
112767: PUSH
112768: LD_VAR 0 17
112772: PUSH
112773: LD_INT 1
112775: ARRAY
112776: PUSH
112777: LD_VAR 0 17
112781: PUSH
112782: LD_INT 2
112784: ARRAY
112785: PUSH
112786: LD_VAR 0 17
112790: PUSH
112791: LD_INT 3
112793: ARRAY
112794: PUSH
112795: EMPTY
112796: LIST
112797: LIST
112798: LIST
112799: LIST
112800: PUSH
112801: EMPTY
112802: LIST
112803: LIST
112804: PPUSH
112805: CALL_OW 72
112809: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112810: LD_VAR 0 14
112814: PUSH
112815: LD_VAR 0 15
112819: DIFF
112820: IFFALSE 112838
// tmp := tmp diff tmp2 ;
112822: LD_ADDR_VAR 0 14
112826: PUSH
112827: LD_VAR 0 14
112831: PUSH
112832: LD_VAR 0 15
112836: DIFF
112837: ST_TO_ADDR
// end ; if not f_murder then
112838: LD_VAR 0 20
112842: NOT
112843: IFFALSE 112901
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112845: LD_ADDR_VAR 0 15
112849: PUSH
112850: LD_VAR 0 14
112854: PPUSH
112855: LD_INT 3
112857: PUSH
112858: LD_INT 50
112860: PUSH
112861: EMPTY
112862: LIST
112863: PUSH
112864: EMPTY
112865: LIST
112866: LIST
112867: PPUSH
112868: CALL_OW 72
112872: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112873: LD_VAR 0 14
112877: PUSH
112878: LD_VAR 0 15
112882: DIFF
112883: IFFALSE 112901
// tmp := tmp diff tmp2 ;
112885: LD_ADDR_VAR 0 14
112889: PUSH
112890: LD_VAR 0 14
112894: PUSH
112895: LD_VAR 0 15
112899: DIFF
112900: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112901: LD_ADDR_VAR 0 14
112905: PUSH
112906: LD_VAR 0 4
112910: PUSH
112911: LD_VAR 0 7
112915: ARRAY
112916: PPUSH
112917: LD_VAR 0 14
112921: PPUSH
112922: LD_INT 1
112924: PPUSH
112925: LD_INT 1
112927: PPUSH
112928: CALL 21897 0 4
112932: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112933: LD_VAR 0 4
112937: PUSH
112938: LD_VAR 0 7
112942: ARRAY
112943: PPUSH
112944: CALL_OW 257
112948: PUSH
112949: LD_INT 1
112951: EQUAL
112952: IFFALSE 113400
// begin if WantPlant ( group [ i ] ) then
112954: LD_VAR 0 4
112958: PUSH
112959: LD_VAR 0 7
112963: ARRAY
112964: PPUSH
112965: CALL 21398 0 1
112969: IFFALSE 112973
// continue ;
112971: GO 111245
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112973: LD_VAR 0 18
112977: PUSH
112978: LD_VAR 0 4
112982: PUSH
112983: LD_VAR 0 7
112987: ARRAY
112988: PPUSH
112989: CALL_OW 310
112993: NOT
112994: AND
112995: PUSH
112996: LD_VAR 0 14
113000: PUSH
113001: LD_INT 1
113003: ARRAY
113004: PUSH
113005: LD_VAR 0 14
113009: PPUSH
113010: LD_INT 21
113012: PUSH
113013: LD_INT 2
113015: PUSH
113016: EMPTY
113017: LIST
113018: LIST
113019: PUSH
113020: LD_INT 58
113022: PUSH
113023: EMPTY
113024: LIST
113025: PUSH
113026: EMPTY
113027: LIST
113028: LIST
113029: PPUSH
113030: CALL_OW 72
113034: IN
113035: AND
113036: IFFALSE 113072
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
113038: LD_VAR 0 4
113042: PUSH
113043: LD_VAR 0 7
113047: ARRAY
113048: PPUSH
113049: LD_VAR 0 14
113053: PUSH
113054: LD_INT 1
113056: ARRAY
113057: PPUSH
113058: CALL_OW 120
// attacking := true ;
113062: LD_ADDR_VAR 0 29
113066: PUSH
113067: LD_INT 1
113069: ST_TO_ADDR
// continue ;
113070: GO 111245
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
113072: LD_VAR 0 26
113076: PUSH
113077: LD_VAR 0 4
113081: PUSH
113082: LD_VAR 0 7
113086: ARRAY
113087: PPUSH
113088: CALL_OW 257
113092: PUSH
113093: LD_INT 1
113095: EQUAL
113096: AND
113097: PUSH
113098: LD_VAR 0 4
113102: PUSH
113103: LD_VAR 0 7
113107: ARRAY
113108: PPUSH
113109: CALL_OW 256
113113: PUSH
113114: LD_INT 800
113116: LESS
113117: AND
113118: PUSH
113119: LD_VAR 0 4
113123: PUSH
113124: LD_VAR 0 7
113128: ARRAY
113129: PPUSH
113130: CALL_OW 318
113134: NOT
113135: AND
113136: IFFALSE 113153
// ComCrawl ( group [ i ] ) ;
113138: LD_VAR 0 4
113142: PUSH
113143: LD_VAR 0 7
113147: ARRAY
113148: PPUSH
113149: CALL_OW 137
// if f_mines then
113153: LD_VAR 0 21
113157: IFFALSE 113400
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
113159: LD_VAR 0 14
113163: PUSH
113164: LD_INT 1
113166: ARRAY
113167: PPUSH
113168: CALL_OW 247
113172: PUSH
113173: LD_INT 3
113175: EQUAL
113176: PUSH
113177: LD_VAR 0 14
113181: PUSH
113182: LD_INT 1
113184: ARRAY
113185: PUSH
113186: LD_VAR 0 27
113190: IN
113191: NOT
113192: AND
113193: IFFALSE 113400
// begin x := GetX ( tmp [ 1 ] ) ;
113195: LD_ADDR_VAR 0 10
113199: PUSH
113200: LD_VAR 0 14
113204: PUSH
113205: LD_INT 1
113207: ARRAY
113208: PPUSH
113209: CALL_OW 250
113213: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
113214: LD_ADDR_VAR 0 11
113218: PUSH
113219: LD_VAR 0 14
113223: PUSH
113224: LD_INT 1
113226: ARRAY
113227: PPUSH
113228: CALL_OW 251
113232: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
113233: LD_ADDR_VAR 0 12
113237: PUSH
113238: LD_VAR 0 4
113242: PUSH
113243: LD_VAR 0 7
113247: ARRAY
113248: PPUSH
113249: CALL 49438 0 1
113253: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
113254: LD_VAR 0 4
113258: PUSH
113259: LD_VAR 0 7
113263: ARRAY
113264: PPUSH
113265: LD_VAR 0 10
113269: PPUSH
113270: LD_VAR 0 11
113274: PPUSH
113275: LD_VAR 0 14
113279: PUSH
113280: LD_INT 1
113282: ARRAY
113283: PPUSH
113284: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
113288: LD_VAR 0 4
113292: PUSH
113293: LD_VAR 0 7
113297: ARRAY
113298: PPUSH
113299: LD_VAR 0 10
113303: PPUSH
113304: LD_VAR 0 12
113308: PPUSH
113309: LD_INT 7
113311: PPUSH
113312: CALL_OW 272
113316: PPUSH
113317: LD_VAR 0 11
113321: PPUSH
113322: LD_VAR 0 12
113326: PPUSH
113327: LD_INT 7
113329: PPUSH
113330: CALL_OW 273
113334: PPUSH
113335: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
113339: LD_VAR 0 4
113343: PUSH
113344: LD_VAR 0 7
113348: ARRAY
113349: PPUSH
113350: LD_INT 71
113352: PPUSH
113353: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
113357: LD_ADDR_VAR 0 27
113361: PUSH
113362: LD_VAR 0 27
113366: PPUSH
113367: LD_VAR 0 27
113371: PUSH
113372: LD_INT 1
113374: PLUS
113375: PPUSH
113376: LD_VAR 0 14
113380: PUSH
113381: LD_INT 1
113383: ARRAY
113384: PPUSH
113385: CALL_OW 1
113389: ST_TO_ADDR
// attacking := true ;
113390: LD_ADDR_VAR 0 29
113394: PUSH
113395: LD_INT 1
113397: ST_TO_ADDR
// continue ;
113398: GO 111245
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
113400: LD_VAR 0 4
113404: PUSH
113405: LD_VAR 0 7
113409: ARRAY
113410: PPUSH
113411: CALL_OW 257
113415: PUSH
113416: LD_INT 17
113418: EQUAL
113419: PUSH
113420: LD_VAR 0 4
113424: PUSH
113425: LD_VAR 0 7
113429: ARRAY
113430: PPUSH
113431: CALL_OW 110
113435: PUSH
113436: LD_INT 71
113438: EQUAL
113439: NOT
113440: AND
113441: IFFALSE 113587
// begin attacking := false ;
113443: LD_ADDR_VAR 0 29
113447: PUSH
113448: LD_INT 0
113450: ST_TO_ADDR
// k := 5 ;
113451: LD_ADDR_VAR 0 9
113455: PUSH
113456: LD_INT 5
113458: ST_TO_ADDR
// if tmp < k then
113459: LD_VAR 0 14
113463: PUSH
113464: LD_VAR 0 9
113468: LESS
113469: IFFALSE 113481
// k := tmp ;
113471: LD_ADDR_VAR 0 9
113475: PUSH
113476: LD_VAR 0 14
113480: ST_TO_ADDR
// for j = 1 to k do
113481: LD_ADDR_VAR 0 8
113485: PUSH
113486: DOUBLE
113487: LD_INT 1
113489: DEC
113490: ST_TO_ADDR
113491: LD_VAR 0 9
113495: PUSH
113496: FOR_TO
113497: IFFALSE 113585
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
113499: LD_VAR 0 14
113503: PUSH
113504: LD_VAR 0 8
113508: ARRAY
113509: PUSH
113510: LD_VAR 0 14
113514: PPUSH
113515: LD_INT 58
113517: PUSH
113518: EMPTY
113519: LIST
113520: PPUSH
113521: CALL_OW 72
113525: IN
113526: NOT
113527: IFFALSE 113583
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113529: LD_VAR 0 4
113533: PUSH
113534: LD_VAR 0 7
113538: ARRAY
113539: PPUSH
113540: LD_VAR 0 14
113544: PUSH
113545: LD_VAR 0 8
113549: ARRAY
113550: PPUSH
113551: CALL_OW 115
// attacking := true ;
113555: LD_ADDR_VAR 0 29
113559: PUSH
113560: LD_INT 1
113562: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
113563: LD_VAR 0 4
113567: PUSH
113568: LD_VAR 0 7
113572: ARRAY
113573: PPUSH
113574: LD_INT 71
113576: PPUSH
113577: CALL_OW 109
// continue ;
113581: GO 113496
// end ; end ;
113583: GO 113496
113585: POP
113586: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
113587: LD_VAR 0 4
113591: PUSH
113592: LD_VAR 0 7
113596: ARRAY
113597: PPUSH
113598: CALL_OW 257
113602: PUSH
113603: LD_INT 8
113605: EQUAL
113606: PUSH
113607: LD_VAR 0 4
113611: PUSH
113612: LD_VAR 0 7
113616: ARRAY
113617: PPUSH
113618: CALL_OW 264
113622: PUSH
113623: LD_INT 28
113625: PUSH
113626: LD_INT 45
113628: PUSH
113629: LD_INT 7
113631: PUSH
113632: LD_INT 47
113634: PUSH
113635: EMPTY
113636: LIST
113637: LIST
113638: LIST
113639: LIST
113640: IN
113641: OR
113642: IFFALSE 113898
// begin attacking := false ;
113644: LD_ADDR_VAR 0 29
113648: PUSH
113649: LD_INT 0
113651: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
113652: LD_VAR 0 14
113656: PUSH
113657: LD_INT 1
113659: ARRAY
113660: PPUSH
113661: CALL_OW 266
113665: PUSH
113666: LD_INT 32
113668: PUSH
113669: LD_INT 31
113671: PUSH
113672: LD_INT 33
113674: PUSH
113675: LD_INT 4
113677: PUSH
113678: LD_INT 5
113680: PUSH
113681: EMPTY
113682: LIST
113683: LIST
113684: LIST
113685: LIST
113686: LIST
113687: IN
113688: IFFALSE 113874
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
113690: LD_ADDR_VAR 0 9
113694: PUSH
113695: LD_VAR 0 14
113699: PUSH
113700: LD_INT 1
113702: ARRAY
113703: PPUSH
113704: CALL_OW 266
113708: PPUSH
113709: LD_VAR 0 14
113713: PUSH
113714: LD_INT 1
113716: ARRAY
113717: PPUSH
113718: CALL_OW 250
113722: PPUSH
113723: LD_VAR 0 14
113727: PUSH
113728: LD_INT 1
113730: ARRAY
113731: PPUSH
113732: CALL_OW 251
113736: PPUSH
113737: LD_VAR 0 14
113741: PUSH
113742: LD_INT 1
113744: ARRAY
113745: PPUSH
113746: CALL_OW 254
113750: PPUSH
113751: LD_VAR 0 14
113755: PUSH
113756: LD_INT 1
113758: ARRAY
113759: PPUSH
113760: CALL_OW 248
113764: PPUSH
113765: LD_INT 0
113767: PPUSH
113768: CALL 30808 0 6
113772: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113773: LD_ADDR_VAR 0 8
113777: PUSH
113778: LD_VAR 0 4
113782: PUSH
113783: LD_VAR 0 7
113787: ARRAY
113788: PPUSH
113789: LD_VAR 0 9
113793: PPUSH
113794: CALL 49551 0 2
113798: ST_TO_ADDR
// if j then
113799: LD_VAR 0 8
113803: IFFALSE 113872
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113805: LD_VAR 0 8
113809: PUSH
113810: LD_INT 1
113812: ARRAY
113813: PPUSH
113814: LD_VAR 0 8
113818: PUSH
113819: LD_INT 2
113821: ARRAY
113822: PPUSH
113823: CALL_OW 488
113827: IFFALSE 113872
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113829: LD_VAR 0 4
113833: PUSH
113834: LD_VAR 0 7
113838: ARRAY
113839: PPUSH
113840: LD_VAR 0 8
113844: PUSH
113845: LD_INT 1
113847: ARRAY
113848: PPUSH
113849: LD_VAR 0 8
113853: PUSH
113854: LD_INT 2
113856: ARRAY
113857: PPUSH
113858: CALL_OW 116
// attacking := true ;
113862: LD_ADDR_VAR 0 29
113866: PUSH
113867: LD_INT 1
113869: ST_TO_ADDR
// continue ;
113870: GO 111245
// end ; end else
113872: GO 113898
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113874: LD_VAR 0 4
113878: PUSH
113879: LD_VAR 0 7
113883: ARRAY
113884: PPUSH
113885: LD_VAR 0 14
113889: PUSH
113890: LD_INT 1
113892: ARRAY
113893: PPUSH
113894: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113898: LD_VAR 0 4
113902: PUSH
113903: LD_VAR 0 7
113907: ARRAY
113908: PPUSH
113909: CALL_OW 265
113913: PUSH
113914: LD_INT 11
113916: EQUAL
113917: IFFALSE 114195
// begin k := 10 ;
113919: LD_ADDR_VAR 0 9
113923: PUSH
113924: LD_INT 10
113926: ST_TO_ADDR
// x := 0 ;
113927: LD_ADDR_VAR 0 10
113931: PUSH
113932: LD_INT 0
113934: ST_TO_ADDR
// if tmp < k then
113935: LD_VAR 0 14
113939: PUSH
113940: LD_VAR 0 9
113944: LESS
113945: IFFALSE 113957
// k := tmp ;
113947: LD_ADDR_VAR 0 9
113951: PUSH
113952: LD_VAR 0 14
113956: ST_TO_ADDR
// for j = k downto 1 do
113957: LD_ADDR_VAR 0 8
113961: PUSH
113962: DOUBLE
113963: LD_VAR 0 9
113967: INC
113968: ST_TO_ADDR
113969: LD_INT 1
113971: PUSH
113972: FOR_DOWNTO
113973: IFFALSE 114048
// begin if GetType ( tmp [ j ] ) = unit_human then
113975: LD_VAR 0 14
113979: PUSH
113980: LD_VAR 0 8
113984: ARRAY
113985: PPUSH
113986: CALL_OW 247
113990: PUSH
113991: LD_INT 1
113993: EQUAL
113994: IFFALSE 114046
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113996: LD_VAR 0 4
114000: PUSH
114001: LD_VAR 0 7
114005: ARRAY
114006: PPUSH
114007: LD_VAR 0 14
114011: PUSH
114012: LD_VAR 0 8
114016: ARRAY
114017: PPUSH
114018: CALL 49805 0 2
// x := tmp [ j ] ;
114022: LD_ADDR_VAR 0 10
114026: PUSH
114027: LD_VAR 0 14
114031: PUSH
114032: LD_VAR 0 8
114036: ARRAY
114037: ST_TO_ADDR
// attacking := true ;
114038: LD_ADDR_VAR 0 29
114042: PUSH
114043: LD_INT 1
114045: ST_TO_ADDR
// end ; end ;
114046: GO 113972
114048: POP
114049: POP
// if not x then
114050: LD_VAR 0 10
114054: NOT
114055: IFFALSE 114195
// begin attacking := true ;
114057: LD_ADDR_VAR 0 29
114061: PUSH
114062: LD_INT 1
114064: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
114065: LD_VAR 0 4
114069: PUSH
114070: LD_VAR 0 7
114074: ARRAY
114075: PPUSH
114076: CALL_OW 250
114080: PPUSH
114081: LD_VAR 0 4
114085: PUSH
114086: LD_VAR 0 7
114090: ARRAY
114091: PPUSH
114092: CALL_OW 251
114096: PPUSH
114097: CALL_OW 546
114101: PUSH
114102: LD_INT 2
114104: ARRAY
114105: PUSH
114106: LD_VAR 0 14
114110: PUSH
114111: LD_INT 1
114113: ARRAY
114114: PPUSH
114115: CALL_OW 250
114119: PPUSH
114120: LD_VAR 0 14
114124: PUSH
114125: LD_INT 1
114127: ARRAY
114128: PPUSH
114129: CALL_OW 251
114133: PPUSH
114134: CALL_OW 546
114138: PUSH
114139: LD_INT 2
114141: ARRAY
114142: EQUAL
114143: IFFALSE 114171
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
114145: LD_VAR 0 4
114149: PUSH
114150: LD_VAR 0 7
114154: ARRAY
114155: PPUSH
114156: LD_VAR 0 14
114160: PUSH
114161: LD_INT 1
114163: ARRAY
114164: PPUSH
114165: CALL 49805 0 2
114169: GO 114195
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114171: LD_VAR 0 4
114175: PUSH
114176: LD_VAR 0 7
114180: ARRAY
114181: PPUSH
114182: LD_VAR 0 14
114186: PUSH
114187: LD_INT 1
114189: ARRAY
114190: PPUSH
114191: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
114195: LD_VAR 0 4
114199: PUSH
114200: LD_VAR 0 7
114204: ARRAY
114205: PPUSH
114206: CALL_OW 264
114210: PUSH
114211: LD_INT 29
114213: EQUAL
114214: IFFALSE 114580
// begin if WantsToAttack ( group [ i ] ) in bombed then
114216: LD_VAR 0 4
114220: PUSH
114221: LD_VAR 0 7
114225: ARRAY
114226: PPUSH
114227: CALL_OW 319
114231: PUSH
114232: LD_VAR 0 28
114236: IN
114237: IFFALSE 114241
// continue ;
114239: GO 111245
// k := 8 ;
114241: LD_ADDR_VAR 0 9
114245: PUSH
114246: LD_INT 8
114248: ST_TO_ADDR
// x := 0 ;
114249: LD_ADDR_VAR 0 10
114253: PUSH
114254: LD_INT 0
114256: ST_TO_ADDR
// if tmp < k then
114257: LD_VAR 0 14
114261: PUSH
114262: LD_VAR 0 9
114266: LESS
114267: IFFALSE 114279
// k := tmp ;
114269: LD_ADDR_VAR 0 9
114273: PUSH
114274: LD_VAR 0 14
114278: ST_TO_ADDR
// for j = 1 to k do
114279: LD_ADDR_VAR 0 8
114283: PUSH
114284: DOUBLE
114285: LD_INT 1
114287: DEC
114288: ST_TO_ADDR
114289: LD_VAR 0 9
114293: PUSH
114294: FOR_TO
114295: IFFALSE 114427
// begin if GetType ( tmp [ j ] ) = unit_building then
114297: LD_VAR 0 14
114301: PUSH
114302: LD_VAR 0 8
114306: ARRAY
114307: PPUSH
114308: CALL_OW 247
114312: PUSH
114313: LD_INT 3
114315: EQUAL
114316: IFFALSE 114425
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
114318: LD_VAR 0 14
114322: PUSH
114323: LD_VAR 0 8
114327: ARRAY
114328: PUSH
114329: LD_VAR 0 28
114333: IN
114334: NOT
114335: PUSH
114336: LD_VAR 0 14
114340: PUSH
114341: LD_VAR 0 8
114345: ARRAY
114346: PPUSH
114347: CALL_OW 313
114351: AND
114352: IFFALSE 114425
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114354: LD_VAR 0 4
114358: PUSH
114359: LD_VAR 0 7
114363: ARRAY
114364: PPUSH
114365: LD_VAR 0 14
114369: PUSH
114370: LD_VAR 0 8
114374: ARRAY
114375: PPUSH
114376: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
114380: LD_ADDR_VAR 0 28
114384: PUSH
114385: LD_VAR 0 28
114389: PPUSH
114390: LD_VAR 0 28
114394: PUSH
114395: LD_INT 1
114397: PLUS
114398: PPUSH
114399: LD_VAR 0 14
114403: PUSH
114404: LD_VAR 0 8
114408: ARRAY
114409: PPUSH
114410: CALL_OW 1
114414: ST_TO_ADDR
// attacking := true ;
114415: LD_ADDR_VAR 0 29
114419: PUSH
114420: LD_INT 1
114422: ST_TO_ADDR
// break ;
114423: GO 114427
// end ; end ;
114425: GO 114294
114427: POP
114428: POP
// if not attacking and f_attack_depot then
114429: LD_VAR 0 29
114433: NOT
114434: PUSH
114435: LD_VAR 0 25
114439: AND
114440: IFFALSE 114535
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114442: LD_ADDR_VAR 0 13
114446: PUSH
114447: LD_VAR 0 14
114451: PPUSH
114452: LD_INT 2
114454: PUSH
114455: LD_INT 30
114457: PUSH
114458: LD_INT 0
114460: PUSH
114461: EMPTY
114462: LIST
114463: LIST
114464: PUSH
114465: LD_INT 30
114467: PUSH
114468: LD_INT 1
114470: PUSH
114471: EMPTY
114472: LIST
114473: LIST
114474: PUSH
114475: EMPTY
114476: LIST
114477: LIST
114478: LIST
114479: PPUSH
114480: CALL_OW 72
114484: ST_TO_ADDR
// if z then
114485: LD_VAR 0 13
114489: IFFALSE 114535
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
114491: LD_VAR 0 4
114495: PUSH
114496: LD_VAR 0 7
114500: ARRAY
114501: PPUSH
114502: LD_VAR 0 13
114506: PPUSH
114507: LD_VAR 0 4
114511: PUSH
114512: LD_VAR 0 7
114516: ARRAY
114517: PPUSH
114518: CALL_OW 74
114522: PPUSH
114523: CALL_OW 115
// attacking := true ;
114527: LD_ADDR_VAR 0 29
114531: PUSH
114532: LD_INT 1
114534: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
114535: LD_VAR 0 4
114539: PUSH
114540: LD_VAR 0 7
114544: ARRAY
114545: PPUSH
114546: CALL_OW 256
114550: PUSH
114551: LD_INT 500
114553: LESS
114554: IFFALSE 114580
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114556: LD_VAR 0 4
114560: PUSH
114561: LD_VAR 0 7
114565: ARRAY
114566: PPUSH
114567: LD_VAR 0 14
114571: PUSH
114572: LD_INT 1
114574: ARRAY
114575: PPUSH
114576: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
114580: LD_VAR 0 4
114584: PUSH
114585: LD_VAR 0 7
114589: ARRAY
114590: PPUSH
114591: CALL_OW 264
114595: PUSH
114596: LD_INT 49
114598: EQUAL
114599: IFFALSE 114720
// begin if not HasTask ( group [ i ] ) then
114601: LD_VAR 0 4
114605: PUSH
114606: LD_VAR 0 7
114610: ARRAY
114611: PPUSH
114612: CALL_OW 314
114616: NOT
114617: IFFALSE 114720
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
114619: LD_ADDR_VAR 0 9
114623: PUSH
114624: LD_INT 81
114626: PUSH
114627: LD_VAR 0 4
114631: PUSH
114632: LD_VAR 0 7
114636: ARRAY
114637: PPUSH
114638: CALL_OW 255
114642: PUSH
114643: EMPTY
114644: LIST
114645: LIST
114646: PPUSH
114647: CALL_OW 69
114651: PPUSH
114652: LD_VAR 0 4
114656: PUSH
114657: LD_VAR 0 7
114661: ARRAY
114662: PPUSH
114663: CALL_OW 74
114667: ST_TO_ADDR
// if k then
114668: LD_VAR 0 9
114672: IFFALSE 114720
// if GetDistUnits ( group [ i ] , k ) > 10 then
114674: LD_VAR 0 4
114678: PUSH
114679: LD_VAR 0 7
114683: ARRAY
114684: PPUSH
114685: LD_VAR 0 9
114689: PPUSH
114690: CALL_OW 296
114694: PUSH
114695: LD_INT 10
114697: GREATER
114698: IFFALSE 114720
// ComMoveUnit ( group [ i ] , k ) ;
114700: LD_VAR 0 4
114704: PUSH
114705: LD_VAR 0 7
114709: ARRAY
114710: PPUSH
114711: LD_VAR 0 9
114715: PPUSH
114716: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
114720: LD_VAR 0 4
114724: PUSH
114725: LD_VAR 0 7
114729: ARRAY
114730: PPUSH
114731: CALL_OW 256
114735: PUSH
114736: LD_INT 250
114738: LESS
114739: PUSH
114740: LD_VAR 0 4
114744: PUSH
114745: LD_VAR 0 7
114749: ARRAY
114750: PUSH
114751: LD_INT 21
114753: PUSH
114754: LD_INT 2
114756: PUSH
114757: EMPTY
114758: LIST
114759: LIST
114760: PUSH
114761: LD_INT 23
114763: PUSH
114764: LD_INT 2
114766: PUSH
114767: EMPTY
114768: LIST
114769: LIST
114770: PUSH
114771: EMPTY
114772: LIST
114773: LIST
114774: PPUSH
114775: CALL_OW 69
114779: IN
114780: AND
114781: IFFALSE 114906
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114783: LD_ADDR_VAR 0 9
114787: PUSH
114788: LD_OWVAR 3
114792: PUSH
114793: LD_VAR 0 4
114797: PUSH
114798: LD_VAR 0 7
114802: ARRAY
114803: DIFF
114804: PPUSH
114805: LD_VAR 0 4
114809: PUSH
114810: LD_VAR 0 7
114814: ARRAY
114815: PPUSH
114816: CALL_OW 74
114820: ST_TO_ADDR
// if not k then
114821: LD_VAR 0 9
114825: NOT
114826: IFFALSE 114830
// continue ;
114828: GO 111245
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114830: LD_VAR 0 9
114834: PUSH
114835: LD_INT 81
114837: PUSH
114838: LD_VAR 0 4
114842: PUSH
114843: LD_VAR 0 7
114847: ARRAY
114848: PPUSH
114849: CALL_OW 255
114853: PUSH
114854: EMPTY
114855: LIST
114856: LIST
114857: PPUSH
114858: CALL_OW 69
114862: IN
114863: PUSH
114864: LD_VAR 0 9
114868: PPUSH
114869: LD_VAR 0 4
114873: PUSH
114874: LD_VAR 0 7
114878: ARRAY
114879: PPUSH
114880: CALL_OW 296
114884: PUSH
114885: LD_INT 5
114887: LESS
114888: AND
114889: IFFALSE 114906
// ComAutodestruct ( group [ i ] ) ;
114891: LD_VAR 0 4
114895: PUSH
114896: LD_VAR 0 7
114900: ARRAY
114901: PPUSH
114902: CALL 49703 0 1
// end ; if f_attack_depot then
114906: LD_VAR 0 25
114910: IFFALSE 115022
// begin k := 6 ;
114912: LD_ADDR_VAR 0 9
114916: PUSH
114917: LD_INT 6
114919: ST_TO_ADDR
// if tmp < k then
114920: LD_VAR 0 14
114924: PUSH
114925: LD_VAR 0 9
114929: LESS
114930: IFFALSE 114942
// k := tmp ;
114932: LD_ADDR_VAR 0 9
114936: PUSH
114937: LD_VAR 0 14
114941: ST_TO_ADDR
// for j = 1 to k do
114942: LD_ADDR_VAR 0 8
114946: PUSH
114947: DOUBLE
114948: LD_INT 1
114950: DEC
114951: ST_TO_ADDR
114952: LD_VAR 0 9
114956: PUSH
114957: FOR_TO
114958: IFFALSE 115020
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114960: LD_VAR 0 8
114964: PPUSH
114965: CALL_OW 266
114969: PUSH
114970: LD_INT 0
114972: PUSH
114973: LD_INT 1
114975: PUSH
114976: EMPTY
114977: LIST
114978: LIST
114979: IN
114980: IFFALSE 115018
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114982: LD_VAR 0 4
114986: PUSH
114987: LD_VAR 0 7
114991: ARRAY
114992: PPUSH
114993: LD_VAR 0 14
114997: PUSH
114998: LD_VAR 0 8
115002: ARRAY
115003: PPUSH
115004: CALL_OW 115
// attacking := true ;
115008: LD_ADDR_VAR 0 29
115012: PUSH
115013: LD_INT 1
115015: ST_TO_ADDR
// break ;
115016: GO 115020
// end ;
115018: GO 114957
115020: POP
115021: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
115022: LD_VAR 0 4
115026: PUSH
115027: LD_VAR 0 7
115031: ARRAY
115032: PPUSH
115033: CALL_OW 302
115037: PUSH
115038: LD_VAR 0 29
115042: NOT
115043: AND
115044: IFFALSE 115366
// begin if GetTag ( group [ i ] ) = 71 then
115046: LD_VAR 0 4
115050: PUSH
115051: LD_VAR 0 7
115055: ARRAY
115056: PPUSH
115057: CALL_OW 110
115061: PUSH
115062: LD_INT 71
115064: EQUAL
115065: IFFALSE 115106
// begin if HasTask ( group [ i ] ) then
115067: LD_VAR 0 4
115071: PUSH
115072: LD_VAR 0 7
115076: ARRAY
115077: PPUSH
115078: CALL_OW 314
115082: IFFALSE 115088
// continue else
115084: GO 111245
115086: GO 115106
// SetTag ( group [ i ] , 0 ) ;
115088: LD_VAR 0 4
115092: PUSH
115093: LD_VAR 0 7
115097: ARRAY
115098: PPUSH
115099: LD_INT 0
115101: PPUSH
115102: CALL_OW 109
// end ; k := 8 ;
115106: LD_ADDR_VAR 0 9
115110: PUSH
115111: LD_INT 8
115113: ST_TO_ADDR
// x := 0 ;
115114: LD_ADDR_VAR 0 10
115118: PUSH
115119: LD_INT 0
115121: ST_TO_ADDR
// if tmp < k then
115122: LD_VAR 0 14
115126: PUSH
115127: LD_VAR 0 9
115131: LESS
115132: IFFALSE 115144
// k := tmp ;
115134: LD_ADDR_VAR 0 9
115138: PUSH
115139: LD_VAR 0 14
115143: ST_TO_ADDR
// for j = 1 to k do
115144: LD_ADDR_VAR 0 8
115148: PUSH
115149: DOUBLE
115150: LD_INT 1
115152: DEC
115153: ST_TO_ADDR
115154: LD_VAR 0 9
115158: PUSH
115159: FOR_TO
115160: IFFALSE 115258
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
115162: LD_VAR 0 14
115166: PUSH
115167: LD_VAR 0 8
115171: ARRAY
115172: PPUSH
115173: CALL_OW 247
115177: PUSH
115178: LD_INT 1
115180: EQUAL
115181: PUSH
115182: LD_VAR 0 14
115186: PUSH
115187: LD_VAR 0 8
115191: ARRAY
115192: PPUSH
115193: CALL_OW 256
115197: PUSH
115198: LD_INT 250
115200: LESS
115201: PUSH
115202: LD_VAR 0 20
115206: AND
115207: PUSH
115208: LD_VAR 0 20
115212: NOT
115213: PUSH
115214: LD_VAR 0 14
115218: PUSH
115219: LD_VAR 0 8
115223: ARRAY
115224: PPUSH
115225: CALL_OW 256
115229: PUSH
115230: LD_INT 250
115232: GREATEREQUAL
115233: AND
115234: OR
115235: AND
115236: IFFALSE 115256
// begin x := tmp [ j ] ;
115238: LD_ADDR_VAR 0 10
115242: PUSH
115243: LD_VAR 0 14
115247: PUSH
115248: LD_VAR 0 8
115252: ARRAY
115253: ST_TO_ADDR
// break ;
115254: GO 115258
// end ;
115256: GO 115159
115258: POP
115259: POP
// if x then
115260: LD_VAR 0 10
115264: IFFALSE 115288
// ComAttackUnit ( group [ i ] , x ) else
115266: LD_VAR 0 4
115270: PUSH
115271: LD_VAR 0 7
115275: ARRAY
115276: PPUSH
115277: LD_VAR 0 10
115281: PPUSH
115282: CALL_OW 115
115286: GO 115312
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115288: LD_VAR 0 4
115292: PUSH
115293: LD_VAR 0 7
115297: ARRAY
115298: PPUSH
115299: LD_VAR 0 14
115303: PUSH
115304: LD_INT 1
115306: ARRAY
115307: PPUSH
115308: CALL_OW 115
// if not HasTask ( group [ i ] ) then
115312: LD_VAR 0 4
115316: PUSH
115317: LD_VAR 0 7
115321: ARRAY
115322: PPUSH
115323: CALL_OW 314
115327: NOT
115328: IFFALSE 115366
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
115330: LD_VAR 0 4
115334: PUSH
115335: LD_VAR 0 7
115339: ARRAY
115340: PPUSH
115341: LD_VAR 0 14
115345: PPUSH
115346: LD_VAR 0 4
115350: PUSH
115351: LD_VAR 0 7
115355: ARRAY
115356: PPUSH
115357: CALL_OW 74
115361: PPUSH
115362: CALL_OW 115
// end ; end ; end ;
115366: GO 111245
115368: POP
115369: POP
// wait ( 0 0$2 ) ;
115370: LD_INT 70
115372: PPUSH
115373: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
115377: LD_VAR 0 4
115381: NOT
115382: PUSH
115383: LD_VAR 0 4
115387: PUSH
115388: EMPTY
115389: EQUAL
115390: OR
115391: PUSH
115392: LD_INT 81
115394: PUSH
115395: LD_VAR 0 35
115399: PUSH
115400: EMPTY
115401: LIST
115402: LIST
115403: PPUSH
115404: CALL_OW 69
115408: NOT
115409: OR
115410: IFFALSE 111230
// end ;
115412: LD_VAR 0 2
115416: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
115417: LD_INT 0
115419: PPUSH
115420: PPUSH
115421: PPUSH
115422: PPUSH
115423: PPUSH
115424: PPUSH
// if not base or not mc_bases [ base ] or not solds then
115425: LD_VAR 0 1
115429: NOT
115430: PUSH
115431: LD_EXP 62
115435: PUSH
115436: LD_VAR 0 1
115440: ARRAY
115441: NOT
115442: OR
115443: PUSH
115444: LD_VAR 0 2
115448: NOT
115449: OR
115450: IFFALSE 115454
// exit ;
115452: GO 116008
// side := mc_sides [ base ] ;
115454: LD_ADDR_VAR 0 6
115458: PUSH
115459: LD_EXP 88
115463: PUSH
115464: LD_VAR 0 1
115468: ARRAY
115469: ST_TO_ADDR
// if not side then
115470: LD_VAR 0 6
115474: NOT
115475: IFFALSE 115479
// exit ;
115477: GO 116008
// for i in solds do
115479: LD_ADDR_VAR 0 7
115483: PUSH
115484: LD_VAR 0 2
115488: PUSH
115489: FOR_IN
115490: IFFALSE 115551
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
115492: LD_VAR 0 7
115496: PPUSH
115497: CALL_OW 310
115501: PPUSH
115502: CALL_OW 266
115506: PUSH
115507: LD_INT 32
115509: PUSH
115510: LD_INT 31
115512: PUSH
115513: EMPTY
115514: LIST
115515: LIST
115516: IN
115517: IFFALSE 115537
// solds := solds diff i else
115519: LD_ADDR_VAR 0 2
115523: PUSH
115524: LD_VAR 0 2
115528: PUSH
115529: LD_VAR 0 7
115533: DIFF
115534: ST_TO_ADDR
115535: GO 115549
// SetTag ( i , 18 ) ;
115537: LD_VAR 0 7
115541: PPUSH
115542: LD_INT 18
115544: PPUSH
115545: CALL_OW 109
115549: GO 115489
115551: POP
115552: POP
// if not solds then
115553: LD_VAR 0 2
115557: NOT
115558: IFFALSE 115562
// exit ;
115560: GO 116008
// repeat wait ( 0 0$2 ) ;
115562: LD_INT 70
115564: PPUSH
115565: CALL_OW 67
// enemy := mc_scan [ base ] ;
115569: LD_ADDR_VAR 0 4
115573: PUSH
115574: LD_EXP 85
115578: PUSH
115579: LD_VAR 0 1
115583: ARRAY
115584: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115585: LD_EXP 62
115589: PUSH
115590: LD_VAR 0 1
115594: ARRAY
115595: NOT
115596: PUSH
115597: LD_EXP 62
115601: PUSH
115602: LD_VAR 0 1
115606: ARRAY
115607: PUSH
115608: EMPTY
115609: EQUAL
115610: OR
115611: IFFALSE 115648
// begin for i in solds do
115613: LD_ADDR_VAR 0 7
115617: PUSH
115618: LD_VAR 0 2
115622: PUSH
115623: FOR_IN
115624: IFFALSE 115637
// ComStop ( i ) ;
115626: LD_VAR 0 7
115630: PPUSH
115631: CALL_OW 141
115635: GO 115623
115637: POP
115638: POP
// solds := [ ] ;
115639: LD_ADDR_VAR 0 2
115643: PUSH
115644: EMPTY
115645: ST_TO_ADDR
// exit ;
115646: GO 116008
// end ; for i in solds do
115648: LD_ADDR_VAR 0 7
115652: PUSH
115653: LD_VAR 0 2
115657: PUSH
115658: FOR_IN
115659: IFFALSE 115980
// begin if IsInUnit ( i ) then
115661: LD_VAR 0 7
115665: PPUSH
115666: CALL_OW 310
115670: IFFALSE 115681
// ComExitBuilding ( i ) ;
115672: LD_VAR 0 7
115676: PPUSH
115677: CALL_OW 122
// if GetLives ( i ) > 500 then
115681: LD_VAR 0 7
115685: PPUSH
115686: CALL_OW 256
115690: PUSH
115691: LD_INT 500
115693: GREATER
115694: IFFALSE 115747
// begin e := NearestUnitToUnit ( enemy , i ) ;
115696: LD_ADDR_VAR 0 5
115700: PUSH
115701: LD_VAR 0 4
115705: PPUSH
115706: LD_VAR 0 7
115710: PPUSH
115711: CALL_OW 74
115715: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
115716: LD_VAR 0 7
115720: PPUSH
115721: LD_VAR 0 5
115725: PPUSH
115726: CALL_OW 250
115730: PPUSH
115731: LD_VAR 0 5
115735: PPUSH
115736: CALL_OW 251
115740: PPUSH
115741: CALL_OW 114
// end else
115745: GO 115978
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115747: LD_VAR 0 7
115751: PPUSH
115752: LD_EXP 62
115756: PUSH
115757: LD_VAR 0 1
115761: ARRAY
115762: PPUSH
115763: LD_INT 2
115765: PUSH
115766: LD_INT 30
115768: PUSH
115769: LD_INT 0
115771: PUSH
115772: EMPTY
115773: LIST
115774: LIST
115775: PUSH
115776: LD_INT 30
115778: PUSH
115779: LD_INT 1
115781: PUSH
115782: EMPTY
115783: LIST
115784: LIST
115785: PUSH
115786: LD_INT 30
115788: PUSH
115789: LD_INT 6
115791: PUSH
115792: EMPTY
115793: LIST
115794: LIST
115795: PUSH
115796: EMPTY
115797: LIST
115798: LIST
115799: LIST
115800: LIST
115801: PPUSH
115802: CALL_OW 72
115806: PPUSH
115807: LD_VAR 0 7
115811: PPUSH
115812: CALL_OW 74
115816: PPUSH
115817: CALL_OW 296
115821: PUSH
115822: LD_INT 10
115824: GREATER
115825: IFFALSE 115978
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115827: LD_ADDR_VAR 0 8
115831: PUSH
115832: LD_EXP 62
115836: PUSH
115837: LD_VAR 0 1
115841: ARRAY
115842: PPUSH
115843: LD_INT 2
115845: PUSH
115846: LD_INT 30
115848: PUSH
115849: LD_INT 0
115851: PUSH
115852: EMPTY
115853: LIST
115854: LIST
115855: PUSH
115856: LD_INT 30
115858: PUSH
115859: LD_INT 1
115861: PUSH
115862: EMPTY
115863: LIST
115864: LIST
115865: PUSH
115866: LD_INT 30
115868: PUSH
115869: LD_INT 6
115871: PUSH
115872: EMPTY
115873: LIST
115874: LIST
115875: PUSH
115876: EMPTY
115877: LIST
115878: LIST
115879: LIST
115880: LIST
115881: PPUSH
115882: CALL_OW 72
115886: PPUSH
115887: LD_VAR 0 7
115891: PPUSH
115892: CALL_OW 74
115896: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115897: LD_VAR 0 7
115901: PPUSH
115902: LD_VAR 0 8
115906: PPUSH
115907: CALL_OW 250
115911: PPUSH
115912: LD_INT 3
115914: PPUSH
115915: LD_INT 5
115917: PPUSH
115918: CALL_OW 272
115922: PPUSH
115923: LD_VAR 0 8
115927: PPUSH
115928: CALL_OW 251
115932: PPUSH
115933: LD_INT 3
115935: PPUSH
115936: LD_INT 5
115938: PPUSH
115939: CALL_OW 273
115943: PPUSH
115944: CALL_OW 111
// SetTag ( i , 0 ) ;
115948: LD_VAR 0 7
115952: PPUSH
115953: LD_INT 0
115955: PPUSH
115956: CALL_OW 109
// solds := solds diff i ;
115960: LD_ADDR_VAR 0 2
115964: PUSH
115965: LD_VAR 0 2
115969: PUSH
115970: LD_VAR 0 7
115974: DIFF
115975: ST_TO_ADDR
// continue ;
115976: GO 115658
// end ; end ;
115978: GO 115658
115980: POP
115981: POP
// until not solds or not enemy ;
115982: LD_VAR 0 2
115986: NOT
115987: PUSH
115988: LD_VAR 0 4
115992: NOT
115993: OR
115994: IFFALSE 115562
// MC_Reset ( base , 18 ) ;
115996: LD_VAR 0 1
116000: PPUSH
116001: LD_INT 18
116003: PPUSH
116004: CALL 63444 0 2
// end ;
116008: LD_VAR 0 3
116012: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
116013: LD_INT 0
116015: PPUSH
116016: PPUSH
116017: PPUSH
116018: PPUSH
116019: PPUSH
116020: PPUSH
116021: PPUSH
116022: PPUSH
116023: PPUSH
116024: PPUSH
116025: PPUSH
116026: PPUSH
116027: PPUSH
116028: PPUSH
116029: PPUSH
116030: PPUSH
116031: PPUSH
116032: PPUSH
116033: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
116034: LD_ADDR_VAR 0 12
116038: PUSH
116039: LD_EXP 62
116043: PUSH
116044: LD_VAR 0 1
116048: ARRAY
116049: PPUSH
116050: LD_INT 25
116052: PUSH
116053: LD_INT 3
116055: PUSH
116056: EMPTY
116057: LIST
116058: LIST
116059: PPUSH
116060: CALL_OW 72
116064: ST_TO_ADDR
// if mc_remote_driver [ base ] then
116065: LD_EXP 102
116069: PUSH
116070: LD_VAR 0 1
116074: ARRAY
116075: IFFALSE 116099
// mechs := mechs diff mc_remote_driver [ base ] ;
116077: LD_ADDR_VAR 0 12
116081: PUSH
116082: LD_VAR 0 12
116086: PUSH
116087: LD_EXP 102
116091: PUSH
116092: LD_VAR 0 1
116096: ARRAY
116097: DIFF
116098: ST_TO_ADDR
// for i in mechs do
116099: LD_ADDR_VAR 0 4
116103: PUSH
116104: LD_VAR 0 12
116108: PUSH
116109: FOR_IN
116110: IFFALSE 116145
// if GetTag ( i ) > 0 then
116112: LD_VAR 0 4
116116: PPUSH
116117: CALL_OW 110
116121: PUSH
116122: LD_INT 0
116124: GREATER
116125: IFFALSE 116143
// mechs := mechs diff i ;
116127: LD_ADDR_VAR 0 12
116131: PUSH
116132: LD_VAR 0 12
116136: PUSH
116137: LD_VAR 0 4
116141: DIFF
116142: ST_TO_ADDR
116143: GO 116109
116145: POP
116146: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116147: LD_ADDR_VAR 0 8
116151: PUSH
116152: LD_EXP 62
116156: PUSH
116157: LD_VAR 0 1
116161: ARRAY
116162: PPUSH
116163: LD_INT 2
116165: PUSH
116166: LD_INT 25
116168: PUSH
116169: LD_INT 1
116171: PUSH
116172: EMPTY
116173: LIST
116174: LIST
116175: PUSH
116176: LD_INT 25
116178: PUSH
116179: LD_INT 5
116181: PUSH
116182: EMPTY
116183: LIST
116184: LIST
116185: PUSH
116186: LD_INT 25
116188: PUSH
116189: LD_INT 8
116191: PUSH
116192: EMPTY
116193: LIST
116194: LIST
116195: PUSH
116196: LD_INT 25
116198: PUSH
116199: LD_INT 9
116201: PUSH
116202: EMPTY
116203: LIST
116204: LIST
116205: PUSH
116206: EMPTY
116207: LIST
116208: LIST
116209: LIST
116210: LIST
116211: LIST
116212: PPUSH
116213: CALL_OW 72
116217: ST_TO_ADDR
// if not defenders and not solds then
116218: LD_VAR 0 2
116222: NOT
116223: PUSH
116224: LD_VAR 0 8
116228: NOT
116229: AND
116230: IFFALSE 116234
// exit ;
116232: GO 118004
// depot_under_attack := false ;
116234: LD_ADDR_VAR 0 16
116238: PUSH
116239: LD_INT 0
116241: ST_TO_ADDR
// sold_defenders := [ ] ;
116242: LD_ADDR_VAR 0 17
116246: PUSH
116247: EMPTY
116248: ST_TO_ADDR
// if mechs then
116249: LD_VAR 0 12
116253: IFFALSE 116406
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
116255: LD_ADDR_VAR 0 4
116259: PUSH
116260: LD_VAR 0 2
116264: PPUSH
116265: LD_INT 21
116267: PUSH
116268: LD_INT 2
116270: PUSH
116271: EMPTY
116272: LIST
116273: LIST
116274: PPUSH
116275: CALL_OW 72
116279: PUSH
116280: FOR_IN
116281: IFFALSE 116404
// begin if GetTag ( i ) <> 20 then
116283: LD_VAR 0 4
116287: PPUSH
116288: CALL_OW 110
116292: PUSH
116293: LD_INT 20
116295: NONEQUAL
116296: IFFALSE 116310
// SetTag ( i , 20 ) ;
116298: LD_VAR 0 4
116302: PPUSH
116303: LD_INT 20
116305: PPUSH
116306: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
116310: LD_VAR 0 4
116314: PPUSH
116315: CALL_OW 263
116319: PUSH
116320: LD_INT 1
116322: EQUAL
116323: PUSH
116324: LD_VAR 0 4
116328: PPUSH
116329: CALL_OW 311
116333: NOT
116334: AND
116335: IFFALSE 116402
// begin un := mechs [ 1 ] ;
116337: LD_ADDR_VAR 0 10
116341: PUSH
116342: LD_VAR 0 12
116346: PUSH
116347: LD_INT 1
116349: ARRAY
116350: ST_TO_ADDR
// ComExit ( un ) ;
116351: LD_VAR 0 10
116355: PPUSH
116356: CALL 54589 0 1
// AddComEnterUnit ( un , i ) ;
116360: LD_VAR 0 10
116364: PPUSH
116365: LD_VAR 0 4
116369: PPUSH
116370: CALL_OW 180
// SetTag ( un , 19 ) ;
116374: LD_VAR 0 10
116378: PPUSH
116379: LD_INT 19
116381: PPUSH
116382: CALL_OW 109
// mechs := mechs diff un ;
116386: LD_ADDR_VAR 0 12
116390: PUSH
116391: LD_VAR 0 12
116395: PUSH
116396: LD_VAR 0 10
116400: DIFF
116401: ST_TO_ADDR
// end ; end ;
116402: GO 116280
116404: POP
116405: POP
// if solds then
116406: LD_VAR 0 8
116410: IFFALSE 116469
// for i in solds do
116412: LD_ADDR_VAR 0 4
116416: PUSH
116417: LD_VAR 0 8
116421: PUSH
116422: FOR_IN
116423: IFFALSE 116467
// if not GetTag ( i ) then
116425: LD_VAR 0 4
116429: PPUSH
116430: CALL_OW 110
116434: NOT
116435: IFFALSE 116465
// begin defenders := defenders union i ;
116437: LD_ADDR_VAR 0 2
116441: PUSH
116442: LD_VAR 0 2
116446: PUSH
116447: LD_VAR 0 4
116451: UNION
116452: ST_TO_ADDR
// SetTag ( i , 18 ) ;
116453: LD_VAR 0 4
116457: PPUSH
116458: LD_INT 18
116460: PPUSH
116461: CALL_OW 109
// end ;
116465: GO 116422
116467: POP
116468: POP
// repeat wait ( 0 0$2 ) ;
116469: LD_INT 70
116471: PPUSH
116472: CALL_OW 67
// enemy := mc_scan [ base ] ;
116476: LD_ADDR_VAR 0 21
116480: PUSH
116481: LD_EXP 85
116485: PUSH
116486: LD_VAR 0 1
116490: ARRAY
116491: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116492: LD_EXP 62
116496: PUSH
116497: LD_VAR 0 1
116501: ARRAY
116502: NOT
116503: PUSH
116504: LD_EXP 62
116508: PUSH
116509: LD_VAR 0 1
116513: ARRAY
116514: PUSH
116515: EMPTY
116516: EQUAL
116517: OR
116518: IFFALSE 116555
// begin for i in defenders do
116520: LD_ADDR_VAR 0 4
116524: PUSH
116525: LD_VAR 0 2
116529: PUSH
116530: FOR_IN
116531: IFFALSE 116544
// ComStop ( i ) ;
116533: LD_VAR 0 4
116537: PPUSH
116538: CALL_OW 141
116542: GO 116530
116544: POP
116545: POP
// defenders := [ ] ;
116546: LD_ADDR_VAR 0 2
116550: PUSH
116551: EMPTY
116552: ST_TO_ADDR
// exit ;
116553: GO 118004
// end ; for i in defenders do
116555: LD_ADDR_VAR 0 4
116559: PUSH
116560: LD_VAR 0 2
116564: PUSH
116565: FOR_IN
116566: IFFALSE 117464
// begin e := NearestUnitToUnit ( enemy , i ) ;
116568: LD_ADDR_VAR 0 13
116572: PUSH
116573: LD_VAR 0 21
116577: PPUSH
116578: LD_VAR 0 4
116582: PPUSH
116583: CALL_OW 74
116587: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116588: LD_ADDR_VAR 0 7
116592: PUSH
116593: LD_EXP 62
116597: PUSH
116598: LD_VAR 0 1
116602: ARRAY
116603: PPUSH
116604: LD_INT 2
116606: PUSH
116607: LD_INT 30
116609: PUSH
116610: LD_INT 0
116612: PUSH
116613: EMPTY
116614: LIST
116615: LIST
116616: PUSH
116617: LD_INT 30
116619: PUSH
116620: LD_INT 1
116622: PUSH
116623: EMPTY
116624: LIST
116625: LIST
116626: PUSH
116627: EMPTY
116628: LIST
116629: LIST
116630: LIST
116631: PPUSH
116632: CALL_OW 72
116636: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
116637: LD_ADDR_VAR 0 16
116641: PUSH
116642: LD_VAR 0 7
116646: NOT
116647: PUSH
116648: LD_VAR 0 7
116652: PPUSH
116653: LD_INT 3
116655: PUSH
116656: LD_INT 24
116658: PUSH
116659: LD_INT 600
116661: PUSH
116662: EMPTY
116663: LIST
116664: LIST
116665: PUSH
116666: EMPTY
116667: LIST
116668: LIST
116669: PPUSH
116670: CALL_OW 72
116674: OR
116675: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
116676: LD_VAR 0 4
116680: PPUSH
116681: CALL_OW 247
116685: PUSH
116686: LD_INT 2
116688: DOUBLE
116689: EQUAL
116690: IFTRUE 116694
116692: GO 117090
116694: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
116695: LD_VAR 0 4
116699: PPUSH
116700: CALL_OW 256
116704: PUSH
116705: LD_INT 1000
116707: EQUAL
116708: PUSH
116709: LD_VAR 0 4
116713: PPUSH
116714: LD_VAR 0 13
116718: PPUSH
116719: CALL_OW 296
116723: PUSH
116724: LD_INT 40
116726: LESS
116727: PUSH
116728: LD_VAR 0 13
116732: PPUSH
116733: LD_EXP 87
116737: PUSH
116738: LD_VAR 0 1
116742: ARRAY
116743: PPUSH
116744: CALL_OW 308
116748: OR
116749: AND
116750: IFFALSE 116872
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116752: LD_VAR 0 4
116756: PPUSH
116757: CALL_OW 262
116761: PUSH
116762: LD_INT 1
116764: EQUAL
116765: PUSH
116766: LD_VAR 0 4
116770: PPUSH
116771: CALL_OW 261
116775: PUSH
116776: LD_INT 30
116778: LESS
116779: AND
116780: PUSH
116781: LD_VAR 0 7
116785: AND
116786: IFFALSE 116856
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116788: LD_VAR 0 4
116792: PPUSH
116793: LD_VAR 0 7
116797: PPUSH
116798: LD_VAR 0 4
116802: PPUSH
116803: CALL_OW 74
116807: PPUSH
116808: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116812: LD_VAR 0 4
116816: PPUSH
116817: LD_VAR 0 7
116821: PPUSH
116822: LD_VAR 0 4
116826: PPUSH
116827: CALL_OW 74
116831: PPUSH
116832: CALL_OW 296
116836: PUSH
116837: LD_INT 6
116839: LESS
116840: IFFALSE 116854
// SetFuel ( i , 100 ) ;
116842: LD_VAR 0 4
116846: PPUSH
116847: LD_INT 100
116849: PPUSH
116850: CALL_OW 240
// end else
116854: GO 116870
// ComAttackUnit ( i , e ) ;
116856: LD_VAR 0 4
116860: PPUSH
116861: LD_VAR 0 13
116865: PPUSH
116866: CALL_OW 115
// end else
116870: GO 116973
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116872: LD_VAR 0 13
116876: PPUSH
116877: LD_EXP 87
116881: PUSH
116882: LD_VAR 0 1
116886: ARRAY
116887: PPUSH
116888: CALL_OW 308
116892: NOT
116893: PUSH
116894: LD_VAR 0 4
116898: PPUSH
116899: LD_VAR 0 13
116903: PPUSH
116904: CALL_OW 296
116908: PUSH
116909: LD_INT 40
116911: GREATEREQUAL
116912: AND
116913: PUSH
116914: LD_VAR 0 4
116918: PPUSH
116919: CALL_OW 256
116923: PUSH
116924: LD_INT 650
116926: LESSEQUAL
116927: OR
116928: PUSH
116929: LD_VAR 0 4
116933: PPUSH
116934: LD_EXP 86
116938: PUSH
116939: LD_VAR 0 1
116943: ARRAY
116944: PPUSH
116945: CALL_OW 308
116949: NOT
116950: AND
116951: IFFALSE 116973
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116953: LD_VAR 0 4
116957: PPUSH
116958: LD_EXP 86
116962: PUSH
116963: LD_VAR 0 1
116967: ARRAY
116968: PPUSH
116969: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116973: LD_VAR 0 4
116977: PPUSH
116978: CALL_OW 256
116982: PUSH
116983: LD_INT 1000
116985: LESS
116986: PUSH
116987: LD_VAR 0 4
116991: PPUSH
116992: CALL_OW 263
116996: PUSH
116997: LD_INT 1
116999: EQUAL
117000: AND
117001: PUSH
117002: LD_VAR 0 4
117006: PPUSH
117007: CALL_OW 311
117011: AND
117012: PUSH
117013: LD_VAR 0 4
117017: PPUSH
117018: LD_EXP 86
117022: PUSH
117023: LD_VAR 0 1
117027: ARRAY
117028: PPUSH
117029: CALL_OW 308
117033: AND
117034: IFFALSE 117088
// begin mech := IsDrivenBy ( i ) ;
117036: LD_ADDR_VAR 0 9
117040: PUSH
117041: LD_VAR 0 4
117045: PPUSH
117046: CALL_OW 311
117050: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
117051: LD_VAR 0 9
117055: PPUSH
117056: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
117060: LD_VAR 0 9
117064: PPUSH
117065: LD_VAR 0 4
117069: PPUSH
117070: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
117074: LD_VAR 0 9
117078: PPUSH
117079: LD_VAR 0 4
117083: PPUSH
117084: CALL_OW 180
// end ; end ; unit_human :
117088: GO 117435
117090: LD_INT 1
117092: DOUBLE
117093: EQUAL
117094: IFTRUE 117098
117096: GO 117434
117098: POP
// begin b := IsInUnit ( i ) ;
117099: LD_ADDR_VAR 0 18
117103: PUSH
117104: LD_VAR 0 4
117108: PPUSH
117109: CALL_OW 310
117113: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
117114: LD_ADDR_VAR 0 19
117118: PUSH
117119: LD_VAR 0 18
117123: NOT
117124: PUSH
117125: LD_VAR 0 18
117129: PPUSH
117130: CALL_OW 266
117134: PUSH
117135: LD_INT 32
117137: PUSH
117138: LD_INT 31
117140: PUSH
117141: EMPTY
117142: LIST
117143: LIST
117144: IN
117145: OR
117146: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
117147: LD_VAR 0 18
117151: PPUSH
117152: CALL_OW 266
117156: PUSH
117157: LD_INT 5
117159: EQUAL
117160: PUSH
117161: LD_VAR 0 4
117165: PPUSH
117166: CALL_OW 257
117170: PUSH
117171: LD_INT 1
117173: PUSH
117174: LD_INT 2
117176: PUSH
117177: LD_INT 3
117179: PUSH
117180: LD_INT 4
117182: PUSH
117183: EMPTY
117184: LIST
117185: LIST
117186: LIST
117187: LIST
117188: IN
117189: AND
117190: IFFALSE 117227
// begin class := AllowSpecClass ( i ) ;
117192: LD_ADDR_VAR 0 20
117196: PUSH
117197: LD_VAR 0 4
117201: PPUSH
117202: CALL 18286 0 1
117206: ST_TO_ADDR
// if class then
117207: LD_VAR 0 20
117211: IFFALSE 117227
// ComChangeProfession ( i , class ) ;
117213: LD_VAR 0 4
117217: PPUSH
117218: LD_VAR 0 20
117222: PPUSH
117223: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
117227: LD_VAR 0 16
117231: PUSH
117232: LD_VAR 0 2
117236: PPUSH
117237: LD_INT 21
117239: PUSH
117240: LD_INT 2
117242: PUSH
117243: EMPTY
117244: LIST
117245: LIST
117246: PPUSH
117247: CALL_OW 72
117251: PUSH
117252: LD_INT 1
117254: LESSEQUAL
117255: OR
117256: PUSH
117257: LD_VAR 0 19
117261: AND
117262: PUSH
117263: LD_VAR 0 4
117267: PUSH
117268: LD_VAR 0 17
117272: IN
117273: NOT
117274: AND
117275: IFFALSE 117368
// begin if b then
117277: LD_VAR 0 18
117281: IFFALSE 117330
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
117283: LD_VAR 0 18
117287: PPUSH
117288: LD_VAR 0 21
117292: PPUSH
117293: LD_VAR 0 18
117297: PPUSH
117298: CALL_OW 74
117302: PPUSH
117303: CALL_OW 296
117307: PUSH
117308: LD_INT 10
117310: LESS
117311: PUSH
117312: LD_VAR 0 18
117316: PPUSH
117317: CALL_OW 461
117321: PUSH
117322: LD_INT 7
117324: NONEQUAL
117325: AND
117326: IFFALSE 117330
// continue ;
117328: GO 116565
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
117330: LD_ADDR_VAR 0 17
117334: PUSH
117335: LD_VAR 0 17
117339: PPUSH
117340: LD_VAR 0 17
117344: PUSH
117345: LD_INT 1
117347: PLUS
117348: PPUSH
117349: LD_VAR 0 4
117353: PPUSH
117354: CALL_OW 1
117358: ST_TO_ADDR
// ComExitBuilding ( i ) ;
117359: LD_VAR 0 4
117363: PPUSH
117364: CALL_OW 122
// end ; if sold_defenders then
117368: LD_VAR 0 17
117372: IFFALSE 117432
// if i in sold_defenders then
117374: LD_VAR 0 4
117378: PUSH
117379: LD_VAR 0 17
117383: IN
117384: IFFALSE 117432
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
117386: LD_VAR 0 4
117390: PPUSH
117391: CALL_OW 314
117395: NOT
117396: PUSH
117397: LD_VAR 0 4
117401: PPUSH
117402: LD_VAR 0 13
117406: PPUSH
117407: CALL_OW 296
117411: PUSH
117412: LD_INT 30
117414: LESS
117415: AND
117416: IFFALSE 117432
// ComAttackUnit ( i , e ) ;
117418: LD_VAR 0 4
117422: PPUSH
117423: LD_VAR 0 13
117427: PPUSH
117428: CALL_OW 115
// end ; end ; end ;
117432: GO 117435
117434: POP
// if IsDead ( i ) then
117435: LD_VAR 0 4
117439: PPUSH
117440: CALL_OW 301
117444: IFFALSE 117462
// defenders := defenders diff i ;
117446: LD_ADDR_VAR 0 2
117450: PUSH
117451: LD_VAR 0 2
117455: PUSH
117456: LD_VAR 0 4
117460: DIFF
117461: ST_TO_ADDR
// end ;
117462: GO 116565
117464: POP
117465: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
117466: LD_VAR 0 21
117470: NOT
117471: PUSH
117472: LD_VAR 0 2
117476: NOT
117477: OR
117478: PUSH
117479: LD_EXP 62
117483: PUSH
117484: LD_VAR 0 1
117488: ARRAY
117489: NOT
117490: OR
117491: IFFALSE 116469
// MC_Reset ( base , 18 ) ;
117493: LD_VAR 0 1
117497: PPUSH
117498: LD_INT 18
117500: PPUSH
117501: CALL 63444 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117505: LD_ADDR_VAR 0 2
117509: PUSH
117510: LD_VAR 0 2
117514: PUSH
117515: LD_VAR 0 2
117519: PPUSH
117520: LD_INT 2
117522: PUSH
117523: LD_INT 25
117525: PUSH
117526: LD_INT 1
117528: PUSH
117529: EMPTY
117530: LIST
117531: LIST
117532: PUSH
117533: LD_INT 25
117535: PUSH
117536: LD_INT 5
117538: PUSH
117539: EMPTY
117540: LIST
117541: LIST
117542: PUSH
117543: LD_INT 25
117545: PUSH
117546: LD_INT 8
117548: PUSH
117549: EMPTY
117550: LIST
117551: LIST
117552: PUSH
117553: LD_INT 25
117555: PUSH
117556: LD_INT 9
117558: PUSH
117559: EMPTY
117560: LIST
117561: LIST
117562: PUSH
117563: EMPTY
117564: LIST
117565: LIST
117566: LIST
117567: LIST
117568: LIST
117569: PPUSH
117570: CALL_OW 72
117574: DIFF
117575: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
117576: LD_VAR 0 21
117580: NOT
117581: PUSH
117582: LD_VAR 0 2
117586: PPUSH
117587: LD_INT 21
117589: PUSH
117590: LD_INT 2
117592: PUSH
117593: EMPTY
117594: LIST
117595: LIST
117596: PPUSH
117597: CALL_OW 72
117601: AND
117602: IFFALSE 117940
// begin tmp := FilterByTag ( defenders , 19 ) ;
117604: LD_ADDR_VAR 0 11
117608: PUSH
117609: LD_VAR 0 2
117613: PPUSH
117614: LD_INT 19
117616: PPUSH
117617: CALL 51760 0 2
117621: ST_TO_ADDR
// if tmp then
117622: LD_VAR 0 11
117626: IFFALSE 117696
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
117628: LD_ADDR_VAR 0 11
117632: PUSH
117633: LD_VAR 0 11
117637: PPUSH
117638: LD_INT 25
117640: PUSH
117641: LD_INT 3
117643: PUSH
117644: EMPTY
117645: LIST
117646: LIST
117647: PPUSH
117648: CALL_OW 72
117652: ST_TO_ADDR
// if tmp then
117653: LD_VAR 0 11
117657: IFFALSE 117696
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
117659: LD_ADDR_EXP 74
117663: PUSH
117664: LD_EXP 74
117668: PPUSH
117669: LD_VAR 0 1
117673: PPUSH
117674: LD_EXP 74
117678: PUSH
117679: LD_VAR 0 1
117683: ARRAY
117684: PUSH
117685: LD_VAR 0 11
117689: UNION
117690: PPUSH
117691: CALL_OW 1
117695: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
117696: LD_VAR 0 1
117700: PPUSH
117701: LD_INT 19
117703: PPUSH
117704: CALL 63444 0 2
// repeat wait ( 0 0$1 ) ;
117708: LD_INT 35
117710: PPUSH
117711: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117715: LD_EXP 62
117719: PUSH
117720: LD_VAR 0 1
117724: ARRAY
117725: NOT
117726: PUSH
117727: LD_EXP 62
117731: PUSH
117732: LD_VAR 0 1
117736: ARRAY
117737: PUSH
117738: EMPTY
117739: EQUAL
117740: OR
117741: IFFALSE 117778
// begin for i in defenders do
117743: LD_ADDR_VAR 0 4
117747: PUSH
117748: LD_VAR 0 2
117752: PUSH
117753: FOR_IN
117754: IFFALSE 117767
// ComStop ( i ) ;
117756: LD_VAR 0 4
117760: PPUSH
117761: CALL_OW 141
117765: GO 117753
117767: POP
117768: POP
// defenders := [ ] ;
117769: LD_ADDR_VAR 0 2
117773: PUSH
117774: EMPTY
117775: ST_TO_ADDR
// exit ;
117776: GO 118004
// end ; for i in defenders do
117778: LD_ADDR_VAR 0 4
117782: PUSH
117783: LD_VAR 0 2
117787: PUSH
117788: FOR_IN
117789: IFFALSE 117878
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117791: LD_VAR 0 4
117795: PPUSH
117796: LD_EXP 86
117800: PUSH
117801: LD_VAR 0 1
117805: ARRAY
117806: PPUSH
117807: CALL_OW 308
117811: NOT
117812: IFFALSE 117836
// ComMoveToArea ( i , mc_parking [ base ] ) else
117814: LD_VAR 0 4
117818: PPUSH
117819: LD_EXP 86
117823: PUSH
117824: LD_VAR 0 1
117828: ARRAY
117829: PPUSH
117830: CALL_OW 113
117834: GO 117876
// if GetControl ( i ) = control_manual then
117836: LD_VAR 0 4
117840: PPUSH
117841: CALL_OW 263
117845: PUSH
117846: LD_INT 1
117848: EQUAL
117849: IFFALSE 117876
// if IsDrivenBy ( i ) then
117851: LD_VAR 0 4
117855: PPUSH
117856: CALL_OW 311
117860: IFFALSE 117876
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117862: LD_VAR 0 4
117866: PPUSH
117867: CALL_OW 311
117871: PPUSH
117872: CALL_OW 121
// end ;
117876: GO 117788
117878: POP
117879: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117880: LD_VAR 0 2
117884: PPUSH
117885: LD_INT 95
117887: PUSH
117888: LD_EXP 86
117892: PUSH
117893: LD_VAR 0 1
117897: ARRAY
117898: PUSH
117899: EMPTY
117900: LIST
117901: LIST
117902: PPUSH
117903: CALL_OW 72
117907: PUSH
117908: LD_VAR 0 2
117912: EQUAL
117913: PUSH
117914: LD_EXP 85
117918: PUSH
117919: LD_VAR 0 1
117923: ARRAY
117924: OR
117925: PUSH
117926: LD_EXP 62
117930: PUSH
117931: LD_VAR 0 1
117935: ARRAY
117936: NOT
117937: OR
117938: IFFALSE 117708
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117940: LD_ADDR_EXP 84
117944: PUSH
117945: LD_EXP 84
117949: PPUSH
117950: LD_VAR 0 1
117954: PPUSH
117955: LD_VAR 0 2
117959: PPUSH
117960: LD_INT 21
117962: PUSH
117963: LD_INT 2
117965: PUSH
117966: EMPTY
117967: LIST
117968: LIST
117969: PPUSH
117970: CALL_OW 72
117974: PPUSH
117975: CALL_OW 1
117979: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117980: LD_VAR 0 1
117984: PPUSH
117985: LD_INT 19
117987: PPUSH
117988: CALL 63444 0 2
// MC_Reset ( base , 20 ) ;
117992: LD_VAR 0 1
117996: PPUSH
117997: LD_INT 20
117999: PPUSH
118000: CALL 63444 0 2
// end ; end_of_file
118004: LD_VAR 0 3
118008: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
118009: LD_VAR 0 1
118013: PUSH
118014: LD_INT 200
118016: DOUBLE
118017: GREATEREQUAL
118018: IFFALSE 118026
118020: LD_INT 299
118022: DOUBLE
118023: LESSEQUAL
118024: IFTRUE 118028
118026: GO 118060
118028: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
118029: LD_VAR 0 1
118033: PPUSH
118034: LD_VAR 0 2
118038: PPUSH
118039: LD_VAR 0 3
118043: PPUSH
118044: LD_VAR 0 4
118048: PPUSH
118049: LD_VAR 0 5
118053: PPUSH
118054: CALL 106190 0 5
118058: GO 118137
118060: LD_INT 300
118062: DOUBLE
118063: GREATEREQUAL
118064: IFFALSE 118072
118066: LD_INT 399
118068: DOUBLE
118069: LESSEQUAL
118070: IFTRUE 118074
118072: GO 118136
118074: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
118075: LD_VAR 0 1
118079: PPUSH
118080: LD_VAR 0 2
118084: PPUSH
118085: LD_VAR 0 3
118089: PPUSH
118090: LD_VAR 0 4
118094: PPUSH
118095: LD_VAR 0 5
118099: PPUSH
118100: LD_VAR 0 6
118104: PPUSH
118105: LD_VAR 0 7
118109: PPUSH
118110: LD_VAR 0 8
118114: PPUSH
118115: LD_VAR 0 9
118119: PPUSH
118120: LD_VAR 0 10
118124: PPUSH
118125: LD_VAR 0 11
118129: PPUSH
118130: CALL 102503 0 11
118134: GO 118137
118136: POP
// end ;
118137: PPOPN 11
118139: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
118140: LD_VAR 0 1
118144: PPUSH
118145: LD_VAR 0 2
118149: PPUSH
118150: LD_VAR 0 3
118154: PPUSH
118155: LD_VAR 0 4
118159: PPUSH
118160: LD_VAR 0 5
118164: PPUSH
118165: CALL 105914 0 5
// end ; end_of_file
118169: PPOPN 5
118171: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
118172: LD_VAR 0 1
118176: PPUSH
118177: LD_VAR 0 2
118181: PPUSH
118182: LD_VAR 0 3
118186: PPUSH
118187: LD_VAR 0 4
118191: PPUSH
118192: LD_VAR 0 5
118196: PPUSH
118197: LD_VAR 0 6
118201: PPUSH
118202: CALL 90155 0 6
// end ;
118206: PPOPN 6
118208: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
118209: LD_INT 0
118211: PPUSH
// begin if not units then
118212: LD_VAR 0 1
118216: NOT
118217: IFFALSE 118221
// exit ;
118219: GO 118221
// end ;
118221: PPOPN 7
118223: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
118224: CALL 90042 0 0
// end ;
118228: PPOPN 1
118230: END
