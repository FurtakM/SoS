// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 644 0 0
// InitGlobalVariables ;
  19: CALL 81476 0 0
// InitMacro ;
  23: CALL 51386 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 46932 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 46932 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 46932 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 5
 128: PPUSH
 129: LD_INT 0
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 12
 143: PPUSH
 144: LD_INT 0
 146: PPUSH
 147: CALL 46932 0 9
// PrepareArabian ;
 151: CALL 3715 0 0
// PrepareRussian ;
 155: CALL 2850 0 0
// PrepareAlliance ;
 159: CALL 846 0 0
// MC_Start ( ) ;
 163: CALL 53498 0 0
// if debug then
 167: LD_EXP 1
 171: IFFALSE 180
// FogOff ( 1 ) ;
 173: LD_INT 1
 175: PPUSH
 176: CALL_OW 344
// Action ;
 180: CALL 6878 0 0
// end ;
 184: END
// export function CustomInitMacro ; var i ; begin
 185: LD_INT 0
 187: PPUSH
 188: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 189: LD_ADDR_EXP 83
 193: PUSH
 194: LD_INT 1
 196: PUSH
 197: LD_INT 2
 199: PUSH
 200: EMPTY
 201: LIST
 202: LIST
 203: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 204: LD_ADDR_EXP 84
 208: PUSH
 209: LD_INT 3
 211: PUSH
 212: LD_INT 4
 214: PUSH
 215: EMPTY
 216: LIST
 217: LIST
 218: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 219: LD_INT 1
 221: PPUSH
 222: LD_INT 12
 224: PUSH
 225: LD_INT 15
 227: PUSH
 228: LD_INT 18
 230: PUSH
 231: EMPTY
 232: LIST
 233: LIST
 234: LIST
 235: PUSH
 236: LD_OWVAR 67
 240: ARRAY
 241: PPUSH
 242: LD_INT 7
 244: PPUSH
 245: CALL 74747 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 249: LD_INT 1
 251: PPUSH
 252: LD_EXP 54
 256: PPUSH
 257: CALL 75173 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 261: LD_INT 1
 263: PPUSH
 264: LD_INT 6
 266: PPUSH
 267: CALL 75631 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 271: LD_INT 1
 273: PPUSH
 274: LD_INT 9
 276: PUSH
 277: EMPTY
 278: LIST
 279: PPUSH
 280: CALL 75900 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 284: LD_INT 1
 286: PPUSH
 287: LD_INT 13
 289: PUSH
 290: LD_INT 1
 292: PUSH
 293: LD_INT 2
 295: PUSH
 296: LD_INT 32
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: PUSH
 305: LD_INT 13
 307: PUSH
 308: LD_INT 1
 310: PUSH
 311: LD_INT 2
 313: PUSH
 314: LD_EXP 108
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: LIST
 323: LIST
 324: PUSH
 325: EMPTY
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 75113 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_INT 12
 338: PUSH
 339: LD_INT 14
 341: PUSH
 342: LD_INT 10
 344: PUSH
 345: LD_INT 11
 347: PUSH
 348: EMPTY
 349: LIST
 350: LIST
 351: LIST
 352: LIST
 353: PPUSH
 354: CALL 75807 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 358: LD_INT 2
 360: PPUSH
 361: LD_EXP 51
 365: PPUSH
 366: CALL 75173 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 370: LD_INT 2
 372: PPUSH
 373: LD_INT 8
 375: PPUSH
 376: CALL 75631 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 10
 385: PUSH
 386: EMPTY
 387: LIST
 388: PPUSH
 389: CALL 75900 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 393: LD_INT 2
 395: PPUSH
 396: LD_INT 6
 398: PUSH
 399: LD_INT 71
 401: PUSH
 402: LD_INT 116
 404: PUSH
 405: LD_INT 4
 407: PUSH
 408: EMPTY
 409: LIST
 410: LIST
 411: LIST
 412: LIST
 413: PUSH
 414: LD_INT 4
 416: PUSH
 417: LD_INT 85
 419: PUSH
 420: LD_INT 116
 422: PUSH
 423: LD_INT 4
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: LIST
 430: LIST
 431: PUSH
 432: LD_INT 32
 434: PUSH
 435: LD_INT 83
 437: PUSH
 438: LD_INT 111
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 32
 452: PUSH
 453: LD_INT 87
 455: PUSH
 456: LD_INT 121
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 33
 470: PUSH
 471: LD_INT 88
 473: PUSH
 474: LD_INT 128
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 59
 491: PUSH
 492: LD_INT 89
 494: PUSH
 495: LD_INT 3
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 69
 509: PUSH
 510: LD_INT 98
 512: PUSH
 513: LD_INT 3
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 33
 524: PUSH
 525: LD_INT 77
 527: PUSH
 528: LD_INT 103
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 83
 545: PUSH
 546: LD_INT 105
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 71
 563: PUSH
 564: LD_INT 125
 566: PUSH
 567: LD_INT 5
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PPUSH
 588: CALL 74957 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 592: LD_INT 2
 594: PPUSH
 595: LD_INT 21
 597: PUSH
 598: LD_INT 1
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 51
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 22
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 52
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: PPUSH
 635: CALL 75113 0 2
// end ;
 639: LD_VAR 0 1
 643: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 644: LD_INT 0
 646: PPUSH
// debug := false ;
 647: LD_ADDR_EXP 1
 651: PUSH
 652: LD_INT 0
 654: ST_TO_ADDR
// game := true ;
 655: LD_ADDR_EXP 2
 659: PUSH
 660: LD_INT 1
 662: ST_TO_ADDR
// gossudarov_arrive := false ;
 663: LD_ADDR_EXP 4
 667: PUSH
 668: LD_INT 0
 670: ST_TO_ADDR
// ru_lab_builded := false ;
 671: LD_ADDR_EXP 5
 675: PUSH
 676: LD_INT 0
 678: ST_TO_ADDR
// player_spotted := false ;
 679: LD_ADDR_EXP 6
 683: PUSH
 684: LD_INT 0
 686: ST_TO_ADDR
// first_attack := false ;
 687: LD_ADDR_EXP 7
 691: PUSH
 692: LD_INT 0
 694: ST_TO_ADDR
// ru_attackers := [ ] ;
 695: LD_ADDR_EXP 52
 699: PUSH
 700: EMPTY
 701: ST_TO_ADDR
// ar_base_spotted := false ;
 702: LD_ADDR_EXP 8
 706: PUSH
 707: LD_INT 0
 709: ST_TO_ADDR
// ar_active_attack := false ;
 710: LD_ADDR_EXP 9
 714: PUSH
 715: LD_INT 0
 717: ST_TO_ADDR
// ar_attackers := [ ] ;
 718: LD_ADDR_EXP 10
 722: PUSH
 723: EMPTY
 724: ST_TO_ADDR
// first_powell_attack := false ;
 725: LD_ADDR_EXP 11
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// abdul_escaped := true ;
 733: LD_ADDR_EXP 12
 737: PUSH
 738: LD_INT 1
 740: ST_TO_ADDR
// loss_counter := 0 ;
 741: LD_ADDR_EXP 13
 745: PUSH
 746: LD_INT 0
 748: ST_TO_ADDR
// hack_counter := 0 ;
 749: LD_ADDR_EXP 14
 753: PUSH
 754: LD_INT 0
 756: ST_TO_ADDR
// end ;
 757: LD_VAR 0 1
 761: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 762: LD_EXP 48
 766: PPUSH
 767: CALL_OW 255
 771: PUSH
 772: LD_INT 7
 774: EQUAL
 775: PUSH
 776: LD_EXP 47
 780: PPUSH
 781: CALL_OW 255
 785: PUSH
 786: LD_INT 7
 788: EQUAL
 789: AND
 790: PUSH
 791: LD_EXP 48
 795: PPUSH
 796: CALL_OW 302
 800: AND
 801: PUSH
 802: LD_EXP 47
 806: PPUSH
 807: CALL_OW 302
 811: AND
 812: IFFALSE 824
 814: GO 816
 816: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 817: LD_STRING ACH_COMRADE
 819: PPUSH
 820: CALL_OW 543
 824: END
// every 0 0$1 trigger hack_counter >= 10 do
 825: LD_EXP 14
 829: PUSH
 830: LD_INT 10
 832: GREATEREQUAL
 833: IFFALSE 845
 835: GO 837
 837: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 838: LD_STRING ACH_HACK
 840: PPUSH
 841: CALL_OW 543
 845: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 846: LD_INT 0
 848: PPUSH
 849: PPUSH
 850: PPUSH
 851: PPUSH
// uc_side := 7 ;
 852: LD_ADDR_OWVAR 20
 856: PUSH
 857: LD_INT 7
 859: ST_TO_ADDR
// uc_nation := 1 ;
 860: LD_ADDR_OWVAR 21
 864: PUSH
 865: LD_INT 1
 867: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 868: LD_ADDR_EXP 15
 872: PUSH
 873: LD_STRING JMM
 875: PPUSH
 876: LD_EXP 1
 880: NOT
 881: PPUSH
 882: LD_STRING 12a_
 884: PPUSH
 885: CALL 14317 0 3
 889: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 890: LD_EXP 15
 894: PPUSH
 895: LD_INT 71
 897: PPUSH
 898: LD_INT 23
 900: PPUSH
 901: LD_INT 0
 903: PPUSH
 904: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 908: LD_EXP 15
 912: PPUSH
 913: LD_INT 2
 915: PPUSH
 916: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 920: LD_ADDR_EXP 16
 924: PUSH
 925: LD_STRING Roth
 927: PPUSH
 928: LD_EXP 1
 932: NOT
 933: PPUSH
 934: LD_STRING 12a_
 936: PPUSH
 937: CALL 14317 0 3
 941: ST_TO_ADDR
// if Roth then
 942: LD_EXP 16
 946: IFFALSE 966
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 948: LD_EXP 16
 952: PPUSH
 953: LD_INT 71
 955: PPUSH
 956: LD_INT 21
 958: PPUSH
 959: LD_INT 0
 961: PPUSH
 962: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 966: LD_ADDR_EXP 17
 970: PUSH
 971: LD_STRING Lisa
 973: PPUSH
 974: LD_EXP 1
 978: NOT
 979: PPUSH
 980: LD_STRING 12a_
 982: PPUSH
 983: CALL 14317 0 3
 987: ST_TO_ADDR
// if Lisa then
 988: LD_EXP 17
 992: IFFALSE 1009
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 994: LD_EXP 17
 998: PPUSH
 999: LD_INT 13
1001: PPUSH
1002: LD_INT 0
1004: PPUSH
1005: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1009: LD_ADDR_EXP 18
1013: PUSH
1014: LD_STRING Donaldson
1016: PPUSH
1017: LD_EXP 1
1021: NOT
1022: PPUSH
1023: LD_STRING 12a_
1025: PPUSH
1026: CALL 14317 0 3
1030: ST_TO_ADDR
// if Donaldson then
1031: LD_EXP 18
1035: IFFALSE 1052
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1037: LD_EXP 18
1041: PPUSH
1042: LD_INT 13
1044: PPUSH
1045: LD_INT 0
1047: PPUSH
1048: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1052: LD_ADDR_EXP 19
1056: PUSH
1057: LD_STRING Bobby
1059: PPUSH
1060: LD_EXP 1
1064: NOT
1065: PPUSH
1066: LD_STRING 12a_
1068: PPUSH
1069: CALL 14317 0 3
1073: ST_TO_ADDR
// if Bobby then
1074: LD_EXP 19
1078: IFFALSE 1095
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1080: LD_EXP 19
1084: PPUSH
1085: LD_INT 13
1087: PPUSH
1088: LD_INT 0
1090: PPUSH
1091: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1095: LD_ADDR_EXP 20
1099: PUSH
1100: LD_STRING Cyrus
1102: PPUSH
1103: LD_EXP 1
1107: NOT
1108: PPUSH
1109: LD_STRING 12a_
1111: PPUSH
1112: CALL 14317 0 3
1116: ST_TO_ADDR
// if Cyrus then
1117: LD_EXP 20
1121: IFFALSE 1138
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1123: LD_EXP 20
1127: PPUSH
1128: LD_INT 13
1130: PPUSH
1131: LD_INT 0
1133: PPUSH
1134: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1138: LD_ADDR_EXP 21
1142: PUSH
1143: LD_STRING Denis
1145: PPUSH
1146: LD_EXP 1
1150: NOT
1151: PPUSH
1152: LD_STRING 12a_
1154: PPUSH
1155: CALL 14317 0 3
1159: ST_TO_ADDR
// if Denis then
1160: LD_EXP 21
1164: IFFALSE 1181
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1166: LD_EXP 21
1170: PPUSH
1171: LD_INT 13
1173: PPUSH
1174: LD_INT 0
1176: PPUSH
1177: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1181: LD_ADDR_EXP 22
1185: PUSH
1186: LD_STRING Brown
1188: PPUSH
1189: LD_EXP 1
1193: NOT
1194: PPUSH
1195: LD_STRING 12a_
1197: PPUSH
1198: CALL 14317 0 3
1202: ST_TO_ADDR
// if Brown then
1203: LD_EXP 22
1207: IFFALSE 1224
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1209: LD_EXP 22
1213: PPUSH
1214: LD_INT 13
1216: PPUSH
1217: LD_INT 0
1219: PPUSH
1220: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1224: LD_ADDR_EXP 23
1228: PUSH
1229: LD_STRING Gladstone
1231: PPUSH
1232: LD_EXP 1
1236: NOT
1237: PPUSH
1238: LD_STRING 12a_
1240: PPUSH
1241: CALL 14317 0 3
1245: ST_TO_ADDR
// if Gladstone then
1246: LD_EXP 23
1250: IFFALSE 1267
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1252: LD_EXP 23
1256: PPUSH
1257: LD_INT 13
1259: PPUSH
1260: LD_INT 0
1262: PPUSH
1263: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1267: LD_ADDR_EXP 24
1271: PUSH
1272: LD_STRING Houten
1274: PPUSH
1275: LD_EXP 1
1279: NOT
1280: PPUSH
1281: LD_STRING 12a_
1283: PPUSH
1284: CALL 14317 0 3
1288: ST_TO_ADDR
// if Houten then
1289: LD_EXP 24
1293: IFFALSE 1310
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1295: LD_EXP 24
1299: PPUSH
1300: LD_INT 13
1302: PPUSH
1303: LD_INT 0
1305: PPUSH
1306: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1310: LD_ADDR_EXP 25
1314: PUSH
1315: LD_STRING Cornell
1317: PPUSH
1318: LD_EXP 1
1322: NOT
1323: PPUSH
1324: LD_STRING 12a_
1326: PPUSH
1327: CALL 14317 0 3
1331: ST_TO_ADDR
// if Cornel then
1332: LD_EXP 25
1336: IFFALSE 1353
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1338: LD_EXP 25
1342: PPUSH
1343: LD_INT 13
1345: PPUSH
1346: LD_INT 0
1348: PPUSH
1349: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1353: LD_ADDR_EXP 26
1357: PUSH
1358: LD_STRING Gary
1360: PPUSH
1361: LD_EXP 1
1365: NOT
1366: PPUSH
1367: LD_STRING 12a_
1369: PPUSH
1370: CALL 14317 0 3
1374: ST_TO_ADDR
// if Gary then
1375: LD_EXP 26
1379: IFFALSE 1396
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1381: LD_EXP 26
1385: PPUSH
1386: LD_INT 13
1388: PPUSH
1389: LD_INT 0
1391: PPUSH
1392: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1396: LD_ADDR_EXP 27
1400: PUSH
1401: LD_STRING Frank
1403: PPUSH
1404: LD_EXP 1
1408: NOT
1409: PPUSH
1410: LD_STRING 12a_
1412: PPUSH
1413: CALL 14317 0 3
1417: ST_TO_ADDR
// if Frank then
1418: LD_EXP 27
1422: IFFALSE 1439
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1424: LD_EXP 27
1428: PPUSH
1429: LD_INT 13
1431: PPUSH
1432: LD_INT 0
1434: PPUSH
1435: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1439: LD_ADDR_EXP 28
1443: PUSH
1444: LD_STRING Kikuchi
1446: PPUSH
1447: LD_EXP 1
1451: NOT
1452: PPUSH
1453: LD_STRING 12a_
1455: PPUSH
1456: CALL 14317 0 3
1460: ST_TO_ADDR
// if Kikuchi then
1461: LD_EXP 28
1465: IFFALSE 1482
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1467: LD_EXP 28
1471: PPUSH
1472: LD_INT 13
1474: PPUSH
1475: LD_INT 0
1477: PPUSH
1478: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1482: LD_ADDR_EXP 29
1486: PUSH
1487: LD_STRING Simms
1489: PPUSH
1490: LD_EXP 1
1494: NOT
1495: PPUSH
1496: LD_STRING 12a_
1498: PPUSH
1499: CALL 14317 0 3
1503: ST_TO_ADDR
// if Simms then
1504: LD_EXP 29
1508: IFFALSE 1525
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1510: LD_EXP 29
1514: PPUSH
1515: LD_INT 13
1517: PPUSH
1518: LD_INT 0
1520: PPUSH
1521: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1525: LD_ADDR_EXP 30
1529: PUSH
1530: LD_STRING Joan
1532: PPUSH
1533: LD_EXP 1
1537: NOT
1538: PPUSH
1539: LD_STRING 12a_
1541: PPUSH
1542: CALL 14317 0 3
1546: ST_TO_ADDR
// if Joan then
1547: LD_EXP 30
1551: IFFALSE 1568
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1553: LD_EXP 30
1557: PPUSH
1558: LD_INT 13
1560: PPUSH
1561: LD_INT 0
1563: PPUSH
1564: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1568: LD_ADDR_EXP 31
1572: PUSH
1573: LD_STRING DeltaDoctor
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 12a_
1584: PPUSH
1585: CALL 14317 0 3
1589: ST_TO_ADDR
// if DeltaDoctor then
1590: LD_EXP 31
1594: IFFALSE 1611
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1596: LD_EXP 31
1600: PPUSH
1601: LD_INT 13
1603: PPUSH
1604: LD_INT 0
1606: PPUSH
1607: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1611: LD_ADDR_VAR 0 4
1615: PUSH
1616: LD_STRING 12a_others
1618: PPUSH
1619: CALL_OW 31
1623: ST_TO_ADDR
// if tmp then
1624: LD_VAR 0 4
1628: IFFALSE 1662
// for i in tmp do
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: LD_VAR 0 4
1639: PUSH
1640: FOR_IN
1641: IFFALSE 1660
// PlaceUnitArea ( i , alliance_start , false ) ;
1643: LD_VAR 0 3
1647: PPUSH
1648: LD_INT 13
1650: PPUSH
1651: LD_INT 0
1653: PPUSH
1654: CALL_OW 49
1658: GO 1640
1660: POP
1661: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1662: LD_INT 3
1664: PPUSH
1665: LD_INT 3
1667: PPUSH
1668: LD_INT 3
1670: PPUSH
1671: LD_INT 12
1673: PPUSH
1674: LD_INT 100
1676: PPUSH
1677: CALL 19141 0 5
// veh := CreateVehicle ;
1681: LD_ADDR_VAR 0 2
1685: PUSH
1686: CALL_OW 45
1690: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1691: LD_VAR 0 2
1695: PPUSH
1696: LD_INT 2
1698: PPUSH
1699: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1703: LD_VAR 0 2
1707: PPUSH
1708: LD_INT 60
1710: PPUSH
1711: LD_INT 6
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1721: LD_VAR 0 2
1725: PPUSH
1726: LD_INT 4
1728: PPUSH
1729: LD_INT 30
1731: PPUSH
1732: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1736: LD_STRING 11_artifact_captured
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: CALL_OW 30
1746: IFFALSE 1822
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1748: LD_INT 3
1750: PPUSH
1751: LD_INT 3
1753: PPUSH
1754: LD_INT 3
1756: PPUSH
1757: LD_INT 12
1759: PPUSH
1760: LD_INT 100
1762: PPUSH
1763: CALL 19141 0 5
// veh := CreateVehicle ;
1767: LD_ADDR_VAR 0 2
1771: PUSH
1772: CALL_OW 45
1776: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1777: LD_VAR 0 2
1781: PPUSH
1782: LD_INT 3
1784: PPUSH
1785: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1789: LD_VAR 0 2
1793: PPUSH
1794: LD_INT 75
1796: PPUSH
1797: LD_INT 6
1799: PPUSH
1800: LD_INT 0
1802: PPUSH
1803: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1807: LD_VAR 0 2
1811: PPUSH
1812: LD_INT 4
1814: PPUSH
1815: LD_INT 50
1817: PPUSH
1818: CALL_OW 290
// end ; end ;
1822: LD_VAR 0 1
1826: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1827: LD_INT 0
1829: PPUSH
1830: PPUSH
1831: PPUSH
1832: PPUSH
// uc_side := 6 ;
1833: LD_ADDR_OWVAR 20
1837: PUSH
1838: LD_INT 6
1840: ST_TO_ADDR
// uc_nation := 3 ;
1841: LD_ADDR_OWVAR 21
1845: PUSH
1846: LD_INT 3
1848: ST_TO_ADDR
// InitHc ;
1849: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1853: LD_ADDR_EXP 32
1857: PUSH
1858: LD_STRING Gossudarov
1860: PPUSH
1861: CALL_OW 25
1865: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1866: LD_ADDR_EXP 33
1870: PUSH
1871: LD_STRING Kirilenkova
1873: PPUSH
1874: CALL_OW 25
1878: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1879: LD_ADDR_EXP 34
1883: PUSH
1884: LD_STRING Titov
1886: PPUSH
1887: CALL_OW 25
1891: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1892: LD_ADDR_EXP 39
1896: PUSH
1897: LD_STRING Oblukov
1899: PPUSH
1900: CALL_OW 25
1904: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1905: LD_ADDR_EXP 36
1909: PUSH
1910: LD_STRING Dolgov
1912: PPUSH
1913: CALL_OW 25
1917: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1918: LD_ADDR_EXP 37
1922: PUSH
1923: LD_STRING Petrosyan
1925: PPUSH
1926: CALL_OW 25
1930: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1931: LD_ADDR_EXP 38
1935: PUSH
1936: LD_STRING Scholtze
1938: PPUSH
1939: CALL_OW 25
1943: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1944: LD_ADDR_EXP 40
1948: PUSH
1949: LD_STRING Kapitsova
1951: PPUSH
1952: CALL_OW 25
1956: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1957: LD_ADDR_VAR 0 2
1961: PUSH
1962: LD_EXP 32
1966: PUSH
1967: LD_EXP 33
1971: PUSH
1972: LD_EXP 34
1976: PUSH
1977: LD_EXP 39
1981: PUSH
1982: LD_EXP 36
1986: PUSH
1987: LD_EXP 37
1991: PUSH
1992: LD_EXP 38
1996: PUSH
1997: LD_EXP 40
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2012: LD_INT 1
2014: PPUSH
2015: LD_INT 4
2017: PPUSH
2018: LD_INT 8
2020: PPUSH
2021: CALL_OW 380
// un := CreateHuman ;
2025: LD_ADDR_VAR 0 4
2029: PUSH
2030: CALL_OW 44
2034: ST_TO_ADDR
// tmp := tmp ^ un ;
2035: LD_ADDR_VAR 0 2
2039: PUSH
2040: LD_VAR 0 2
2044: PUSH
2045: LD_VAR 0 4
2049: ADD
2050: ST_TO_ADDR
// for i in tmp do
2051: LD_ADDR_VAR 0 3
2055: PUSH
2056: LD_VAR 0 2
2060: PUSH
2061: FOR_IN
2062: IFFALSE 2081
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2064: LD_VAR 0 3
2068: PPUSH
2069: LD_INT 14
2071: PPUSH
2072: LD_INT 0
2074: PPUSH
2075: CALL_OW 49
2079: GO 2061
2081: POP
2082: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2083: LD_VAR 0 2
2087: PPUSH
2088: LD_EXP 3
2092: PPUSH
2093: CALL_OW 250
2097: PPUSH
2098: LD_EXP 3
2102: PPUSH
2103: CALL_OW 251
2107: PPUSH
2108: CALL_OW 111
// end ;
2112: LD_VAR 0 1
2116: RET
// export function PrepareBelkov ; begin
2117: LD_INT 0
2119: PPUSH
// uc_side := 4 ;
2120: LD_ADDR_OWVAR 20
2124: PUSH
2125: LD_INT 4
2127: ST_TO_ADDR
// uc_nation := 3 ;
2128: LD_ADDR_OWVAR 21
2132: PUSH
2133: LD_INT 3
2135: ST_TO_ADDR
// InitHc ;
2136: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2140: LD_ADDR_EXP 47
2144: PUSH
2145: LD_STRING Belkov
2147: PPUSH
2148: CALL_OW 25
2152: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2153: LD_EXP 47
2157: PPUSH
2158: LD_INT 14
2160: PPUSH
2161: LD_INT 0
2163: PPUSH
2164: CALL_OW 49
// end ;
2168: LD_VAR 0 1
2172: RET
// export function PrepareGnyevko ; begin
2173: LD_INT 0
2175: PPUSH
// uc_side := 4 ;
2176: LD_ADDR_OWVAR 20
2180: PUSH
2181: LD_INT 4
2183: ST_TO_ADDR
// uc_nation := 3 ;
2184: LD_ADDR_OWVAR 21
2188: PUSH
2189: LD_INT 3
2191: ST_TO_ADDR
// InitHc ;
2192: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2196: LD_ADDR_EXP 48
2200: PUSH
2201: LD_STRING Gnyevko
2203: PPUSH
2204: CALL_OW 25
2208: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2209: LD_EXP 48
2213: PPUSH
2214: LD_INT 14
2216: PPUSH
2217: LD_INT 0
2219: PPUSH
2220: CALL_OW 49
// end ;
2224: LD_VAR 0 1
2228: RET
// export function PrepareBurlak ; var i , tmp ; begin
2229: LD_INT 0
2231: PPUSH
2232: PPUSH
2233: PPUSH
// uc_side := 4 ;
2234: LD_ADDR_OWVAR 20
2238: PUSH
2239: LD_INT 4
2241: ST_TO_ADDR
// uc_nation := 3 ;
2242: LD_ADDR_OWVAR 21
2246: PUSH
2247: LD_INT 3
2249: ST_TO_ADDR
// InitHc ;
2250: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2254: LD_ADDR_EXP 46
2258: PUSH
2259: LD_STRING Burlak
2261: PPUSH
2262: CALL_OW 25
2266: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2267: LD_INT 24
2269: PUSH
2270: LD_INT 23
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: EMPTY
2277: LIST
2278: LIST
2279: LIST
2280: PUSH
2281: LD_OWVAR 67
2285: ARRAY
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 1
2292: PPUSH
2293: LD_INT 45
2295: PUSH
2296: LD_INT 44
2298: PUSH
2299: LD_INT 43
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: LIST
2306: PUSH
2307: LD_OWVAR 67
2311: ARRAY
2312: PPUSH
2313: LD_INT 0
2315: PPUSH
2316: CALL 19141 0 5
// Masha := CreateVehicle ;
2320: LD_ADDR_EXP 49
2324: PUSH
2325: CALL_OW 45
2329: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2330: LD_EXP 49
2334: PUSH
2335: LD_EXP 46
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: PPUSH
2344: LD_INT 499
2346: PPUSH
2347: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2351: LD_EXP 49
2355: PPUSH
2356: LD_INT 3
2358: PPUSH
2359: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2363: LD_EXP 49
2367: PPUSH
2368: LD_INT 1
2370: PPUSH
2371: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2375: LD_INT 1
2377: PPUSH
2378: LD_INT 18
2380: PPUSH
2381: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2385: LD_INT 35
2387: PPUSH
2388: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2392: LD_ADDR_VAR 0 3
2396: PUSH
2397: LD_INT 18
2399: PPUSH
2400: EMPTY
2401: PPUSH
2402: CALL_OW 70
2406: ST_TO_ADDR
// if tmp then
2407: LD_VAR 0 3
2411: IFFALSE 2445
// for i in tmp do
2413: LD_ADDR_VAR 0 2
2417: PUSH
2418: LD_VAR 0 3
2422: PUSH
2423: FOR_IN
2424: IFFALSE 2443
// ComMoveXY ( i , 114 , 9 ) ;
2426: LD_VAR 0 2
2430: PPUSH
2431: LD_INT 114
2433: PPUSH
2434: LD_INT 9
2436: PPUSH
2437: CALL_OW 111
2441: GO 2423
2443: POP
2444: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2445: LD_INT 18
2447: PPUSH
2448: EMPTY
2449: PPUSH
2450: CALL_OW 70
2454: NOT
2455: PUSH
2456: LD_INT 123
2458: PPUSH
2459: LD_INT 3
2461: PPUSH
2462: CALL_OW 428
2466: PUSH
2467: LD_INT 0
2469: EQUAL
2470: AND
2471: IFFALSE 2385
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2473: LD_EXP 49
2477: PPUSH
2478: LD_INT 123
2480: PPUSH
2481: LD_INT 3
2483: PPUSH
2484: LD_INT 0
2486: PPUSH
2487: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2491: LD_EXP 46
2495: PPUSH
2496: LD_INT 125
2498: PPUSH
2499: LD_INT 1
2501: PPUSH
2502: LD_INT 0
2504: PPUSH
2505: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2509: LD_EXP 46
2513: PPUSH
2514: LD_EXP 49
2518: PPUSH
2519: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2523: LD_INT 10
2525: PPUSH
2526: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2530: LD_EXP 49
2534: PPUSH
2535: LD_INT 110
2537: PPUSH
2538: LD_INT 10
2540: PPUSH
2541: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2545: LD_ADDR_EXP 42
2549: PUSH
2550: LD_STRING Petrovova
2552: PPUSH
2553: CALL_OW 25
2557: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2558: LD_ADDR_EXP 44
2562: PUSH
2563: LD_STRING Kuzmov
2565: PPUSH
2566: CALL_OW 25
2570: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2571: LD_ADDR_EXP 43
2575: PUSH
2576: LD_STRING Kovalyuk
2578: PPUSH
2579: CALL_OW 25
2583: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2584: LD_ADDR_EXP 41
2588: PUSH
2589: LD_STRING Lipshchin
2591: PPUSH
2592: CALL_OW 25
2596: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2597: LD_ADDR_EXP 45
2601: PUSH
2602: LD_STRING Karamazov
2604: PPUSH
2605: CALL_OW 25
2609: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2610: LD_ADDR_VAR 0 3
2614: PUSH
2615: LD_EXP 42
2619: PUSH
2620: LD_EXP 44
2624: PUSH
2625: LD_EXP 43
2629: PUSH
2630: LD_EXP 41
2634: PUSH
2635: LD_EXP 45
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: LIST
2646: ST_TO_ADDR
// for i in tmp do
2647: LD_ADDR_VAR 0 2
2651: PUSH
2652: LD_VAR 0 3
2656: PUSH
2657: FOR_IN
2658: IFFALSE 2697
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2660: LD_VAR 0 2
2664: PPUSH
2665: LD_INT 399
2667: PPUSH
2668: LD_INT 799
2670: PPUSH
2671: CALL_OW 12
2675: PPUSH
2676: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2680: LD_VAR 0 2
2684: PPUSH
2685: LD_INT 19
2687: PPUSH
2688: LD_INT 0
2690: PPUSH
2691: CALL_OW 49
// end ;
2695: GO 2657
2697: POP
2698: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2699: LD_VAR 0 3
2703: PPUSH
2704: LD_INT 116
2706: PPUSH
2707: LD_INT 8
2709: PPUSH
2710: CALL_OW 111
// AddComHold ( tmp ) ;
2714: LD_VAR 0 3
2718: PPUSH
2719: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2723: LD_ADDR_VAR 0 2
2727: PUSH
2728: LD_VAR 0 3
2732: PPUSH
2733: LD_INT 25
2735: PUSH
2736: LD_INT 1
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 72
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2789
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: LD_INT 20
2758: PPUSH
2759: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2763: LD_VAR 0 2
2767: PPUSH
2768: LD_INT 147
2770: PPUSH
2771: LD_INT 45
2773: PPUSH
2774: CALL_OW 178
// AddComCrawl ( i ) ;
2778: LD_VAR 0 2
2782: PPUSH
2783: CALL_OW 197
// end ;
2787: GO 2748
2789: POP
2790: POP
// repeat wait ( 0 0$1 ) ;
2791: LD_INT 35
2793: PPUSH
2794: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2798: LD_EXP 49
2802: PPUSH
2803: LD_INT 110
2805: PPUSH
2806: LD_INT 10
2808: PPUSH
2809: CALL_OW 307
2813: PUSH
2814: LD_EXP 49
2818: PPUSH
2819: CALL_OW 305
2823: NOT
2824: OR
2825: IFFALSE 2791
// ComStop ( Burlak ) ;
2827: LD_EXP 46
2831: PPUSH
2832: CALL_OW 141
// AddComHold ( Burlak ) ;
2836: LD_EXP 46
2840: PPUSH
2841: CALL_OW 200
// end ; end_of_file
2845: LD_VAR 0 1
2849: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2850: LD_INT 0
2852: PPUSH
2853: PPUSH
2854: PPUSH
2855: PPUSH
// uc_side := 3 ;
2856: LD_ADDR_OWVAR 20
2860: PUSH
2861: LD_INT 3
2863: ST_TO_ADDR
// uc_nation := 3 ;
2864: LD_ADDR_OWVAR 21
2868: PUSH
2869: LD_INT 3
2871: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2872: LD_ADDR_EXP 50
2876: PUSH
2877: LD_INT 47
2879: PPUSH
2880: LD_INT 4
2882: PPUSH
2883: LD_STRING 
2885: PPUSH
2886: LD_INT 7
2888: PUSH
2889: LD_INT 8
2891: PUSH
2892: LD_INT 9
2894: PUSH
2895: EMPTY
2896: LIST
2897: LIST
2898: LIST
2899: PUSH
2900: LD_OWVAR 67
2904: ARRAY
2905: PPUSH
2906: LD_INT 10000
2908: PUSH
2909: LD_INT 3000
2911: PUSH
2912: LD_INT 300
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: LIST
2919: PPUSH
2920: LD_INT 9
2922: PUSH
2923: LD_INT 5
2925: PUSH
2926: LD_INT 6
2928: PUSH
2929: LD_INT 6
2931: PUSH
2932: EMPTY
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: PPUSH
2938: CALL 22550 0 6
2942: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2943: LD_ADDR_EXP 59
2947: PUSH
2948: LD_EXP 59
2952: PPUSH
2953: LD_INT 2
2955: PPUSH
2956: LD_EXP 50
2960: PPUSH
2961: CALL_OW 1
2965: ST_TO_ADDR
// tmp := [ ] ;
2966: LD_ADDR_VAR 0 4
2970: PUSH
2971: EMPTY
2972: ST_TO_ADDR
// for i = 1 to 4 do
2973: LD_ADDR_VAR 0 2
2977: PUSH
2978: DOUBLE
2979: LD_INT 1
2981: DEC
2982: ST_TO_ADDR
2983: LD_INT 4
2985: PUSH
2986: FOR_TO
2987: IFFALSE 3080
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2989: LD_INT 22
2991: PPUSH
2992: LD_INT 3
2994: PPUSH
2995: LD_INT 3
2997: PPUSH
2998: LD_INT 43
3000: PUSH
3001: LD_INT 45
3003: PUSH
3004: LD_INT 45
3006: PUSH
3007: LD_INT 44
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_VAR 0 2
3020: PUSH
3021: LD_INT 4
3023: MOD
3024: PUSH
3025: LD_INT 1
3027: PLUS
3028: ARRAY
3029: PPUSH
3030: LD_INT 100
3032: PPUSH
3033: CALL 19141 0 5
// veh := CreateVehicle ;
3037: LD_ADDR_VAR 0 3
3041: PUSH
3042: CALL_OW 45
3046: ST_TO_ADDR
// tmp := tmp ^ veh ;
3047: LD_ADDR_VAR 0 4
3051: PUSH
3052: LD_VAR 0 4
3056: PUSH
3057: LD_VAR 0 3
3061: ADD
3062: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3063: LD_VAR 0 3
3067: PPUSH
3068: LD_INT 2
3070: PPUSH
3071: LD_INT 0
3073: PPUSH
3074: CALL_OW 49
// end ;
3078: GO 2986
3080: POP
3081: POP
// russian_guard := tmp ;
3082: LD_ADDR_EXP 51
3086: PUSH
3087: LD_VAR 0 4
3091: ST_TO_ADDR
// end ;
3092: LD_VAR 0 1
3096: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3097: LD_INT 47
3099: PPUSH
3100: CALL_OW 302
3104: PUSH
3105: LD_EXP 6
3109: AND
3110: IFFALSE 3712
3112: GO 3114
3114: DISABLE
3115: LD_INT 0
3117: PPUSH
3118: PPUSH
3119: PPUSH
3120: PPUSH
3121: PPUSH
3122: PPUSH
// begin enable ;
3123: ENABLE
// base := 2 ;
3124: LD_ADDR_VAR 0 2
3128: PUSH
3129: LD_INT 2
3131: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3132: LD_ADDR_VAR 0 4
3136: PUSH
3137: LD_INT 0
3139: PUSH
3140: LD_INT 0
3142: PUSH
3143: LD_INT 0
3145: PUSH
3146: LD_INT 0
3148: PUSH
3149: LD_INT 0
3151: PUSH
3152: LD_INT 0
3154: PUSH
3155: LD_INT 0
3157: PUSH
3158: LD_INT 0
3160: PUSH
3161: LD_INT 1
3163: PUSH
3164: LD_INT 0
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: LIST
3178: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3179: LD_ADDR_VAR 0 3
3183: PUSH
3184: LD_INT 22
3186: PUSH
3187: LD_INT 1
3189: PUSH
3190: LD_INT 3
3192: PUSH
3193: LD_INT 45
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: PUSH
3202: LD_INT 21
3204: PUSH
3205: LD_INT 1
3207: PUSH
3208: LD_INT 3
3210: PUSH
3211: LD_INT 45
3213: PUSH
3214: EMPTY
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: PUSH
3220: LD_INT 22
3222: PUSH
3223: LD_INT 1
3225: PUSH
3226: LD_INT 3
3228: PUSH
3229: LD_INT 45
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: PUSH
3238: LD_INT 23
3240: PUSH
3241: LD_INT 1
3243: PUSH
3244: LD_INT 3
3246: PUSH
3247: LD_INT 46
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: LIST
3261: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3262: LD_ADDR_VAR 0 1
3266: PUSH
3267: DOUBLE
3268: LD_INT 1
3270: DEC
3271: ST_TO_ADDR
3272: LD_OWVAR 67
3276: PUSH
3277: LD_OWVAR 1
3281: PUSH
3282: LD_INT 21000
3284: DIV
3285: PLUS
3286: PUSH
3287: FOR_TO
3288: IFFALSE 3376
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3290: LD_ADDR_VAR 0 3
3294: PUSH
3295: LD_VAR 0 3
3299: PPUSH
3300: LD_VAR 0 3
3304: PUSH
3305: LD_INT 1
3307: PLUS
3308: PPUSH
3309: LD_INT 23
3311: PUSH
3312: LD_INT 24
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: PUSH
3319: LD_INT 1
3321: PPUSH
3322: LD_INT 2
3324: PPUSH
3325: CALL_OW 12
3329: ARRAY
3330: PUSH
3331: LD_INT 1
3333: PUSH
3334: LD_INT 3
3336: PUSH
3337: LD_INT 46
3339: PUSH
3340: LD_INT 47
3342: PUSH
3343: LD_INT 45
3345: PUSH
3346: EMPTY
3347: LIST
3348: LIST
3349: LIST
3350: PUSH
3351: LD_INT 1
3353: PPUSH
3354: LD_INT 3
3356: PPUSH
3357: CALL_OW 12
3361: ARRAY
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: LIST
3368: PPUSH
3369: CALL_OW 2
3373: ST_TO_ADDR
3374: GO 3287
3376: POP
3377: POP
// MC_InsertProduceList ( base , tmp ) ;
3378: LD_VAR 0 2
3382: PPUSH
3383: LD_VAR 0 3
3387: PPUSH
3388: CALL 75113 0 2
// repeat wait ( 0 0$1 ) ;
3392: LD_INT 35
3394: PPUSH
3395: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3399: LD_EXP 78
3403: PUSH
3404: LD_VAR 0 2
3408: ARRAY
3409: PUSH
3410: LD_INT 6
3412: GREATER
3413: IFFALSE 3392
// wait ( 0 0$20 ) ;
3415: LD_INT 700
3417: PPUSH
3418: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3422: LD_ADDR_VAR 0 5
3426: PUSH
3427: LD_INT 71
3429: PUSH
3430: LD_INT 19
3432: PUSH
3433: EMPTY
3434: LIST
3435: LIST
3436: PUSH
3437: LD_INT 91
3439: PUSH
3440: LD_INT 67
3442: PUSH
3443: EMPTY
3444: LIST
3445: LIST
3446: PUSH
3447: LD_INT 52
3449: PUSH
3450: LD_INT 44
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: PUSH
3457: LD_INT 68
3459: PUSH
3460: LD_INT 48
3462: PUSH
3463: EMPTY
3464: LIST
3465: LIST
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3473: LD_ADDR_VAR 0 6
3477: PUSH
3478: LD_EXP 78
3482: PUSH
3483: LD_VAR 0 2
3487: ARRAY
3488: PUSH
3489: LD_EXP 78
3493: PUSH
3494: LD_VAR 0 2
3498: ARRAY
3499: PPUSH
3500: LD_INT 2
3502: PUSH
3503: LD_INT 34
3505: PUSH
3506: LD_INT 51
3508: PUSH
3509: EMPTY
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 34
3515: PUSH
3516: LD_INT 52
3518: PUSH
3519: EMPTY
3520: LIST
3521: LIST
3522: PUSH
3523: EMPTY
3524: LIST
3525: LIST
3526: LIST
3527: PPUSH
3528: CALL_OW 72
3532: DIFF
3533: ST_TO_ADDR
// if not attackers then
3534: LD_VAR 0 6
3538: NOT
3539: IFFALSE 3543
// exit ;
3541: GO 3712
// ru_attackers := attackers ;
3543: LD_ADDR_EXP 52
3547: PUSH
3548: LD_VAR 0 6
3552: ST_TO_ADDR
// for i = 1 to attackers do
3553: LD_ADDR_VAR 0 1
3557: PUSH
3558: DOUBLE
3559: LD_INT 1
3561: DEC
3562: ST_TO_ADDR
3563: LD_VAR 0 6
3567: PUSH
3568: FOR_TO
3569: IFFALSE 3646
// begin case i mod 3 of 0 :
3571: LD_VAR 0 1
3575: PUSH
3576: LD_INT 3
3578: MOD
3579: PUSH
3580: LD_INT 0
3582: DOUBLE
3583: EQUAL
3584: IFTRUE 3588
3586: GO 3591
3588: POP
// ; 1 :
3589: GO 3644
3591: LD_INT 1
3593: DOUBLE
3594: EQUAL
3595: IFTRUE 3599
3597: GO 3617
3599: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3600: LD_VAR 0 1
3604: PPUSH
3605: LD_INT 32
3607: PPUSH
3608: LD_INT 49
3610: PPUSH
3611: CALL_OW 114
3615: GO 3644
3617: LD_INT 2
3619: DOUBLE
3620: EQUAL
3621: IFTRUE 3625
3623: GO 3643
3625: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3626: LD_VAR 0 1
3630: PPUSH
3631: LD_INT 117
3633: PPUSH
3634: LD_INT 107
3636: PPUSH
3637: CALL_OW 114
3641: GO 3644
3643: POP
// end ;
3644: GO 3568
3646: POP
3647: POP
// repeat wait ( 0 0$1 ) ;
3648: LD_INT 35
3650: PPUSH
3651: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3655: LD_VAR 0 6
3659: PPUSH
3660: LD_INT 60
3662: PUSH
3663: EMPTY
3664: LIST
3665: PPUSH
3666: CALL_OW 72
3670: NOT
3671: IFFALSE 3648
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3673: LD_VAR 0 2
3677: PPUSH
3678: LD_VAR 0 6
3682: PPUSH
3683: LD_VAR 0 5
3687: PPUSH
3688: LD_VAR 0 4
3692: PPUSH
3693: CALL 75298 0 4
// if not first_attack then
3697: LD_EXP 7
3701: NOT
3702: IFFALSE 3712
// first_attack := true ;
3704: LD_ADDR_EXP 7
3708: PUSH
3709: LD_INT 1
3711: ST_TO_ADDR
// end ; end_of_file
3712: PPOPN 6
3714: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3715: LD_INT 0
3717: PPUSH
3718: PPUSH
3719: PPUSH
3720: PPUSH
3721: PPUSH
3722: PPUSH
3723: PPUSH
// uc_side := 2 ;
3724: LD_ADDR_OWVAR 20
3728: PUSH
3729: LD_INT 2
3731: ST_TO_ADDR
// uc_nation := 2 ;
3732: LD_ADDR_OWVAR 21
3736: PUSH
3737: LD_INT 2
3739: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3740: LD_ADDR_EXP 55
3744: PUSH
3745: LD_STRING Abdul
3747: PPUSH
3748: CALL_OW 25
3752: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3753: LD_EXP 55
3757: PPUSH
3758: LD_INT 11
3760: PPUSH
3761: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3765: LD_EXP 55
3769: PPUSH
3770: LD_INT 1
3772: PPUSH
3773: CALL_OW 52
// vc_chassis := 31 ;
3777: LD_ADDR_OWVAR 37
3781: PUSH
3782: LD_INT 31
3784: ST_TO_ADDR
// vc_control := control_rider ;
3785: LD_ADDR_OWVAR 38
3789: PUSH
3790: LD_INT 4
3792: ST_TO_ADDR
// mastodont := CreateVehicle ;
3793: LD_ADDR_EXP 56
3797: PUSH
3798: CALL_OW 45
3802: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3803: LD_EXP 56
3807: PPUSH
3808: LD_INT 153
3810: PPUSH
3811: LD_INT 71
3813: PPUSH
3814: LD_INT 0
3816: PPUSH
3817: CALL_OW 48
// InitVc ;
3821: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3825: LD_ADDR_EXP 53
3829: PUSH
3830: LD_INT 1
3832: PPUSH
3833: LD_INT 3
3835: PPUSH
3836: LD_STRING 
3838: PPUSH
3839: LD_INT 7
3841: PUSH
3842: LD_INT 8
3844: PUSH
3845: LD_INT 9
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: LIST
3852: PUSH
3853: LD_OWVAR 67
3857: ARRAY
3858: PPUSH
3859: LD_INT 5000
3861: PUSH
3862: LD_INT 1000
3864: PUSH
3865: LD_INT 300
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: LIST
3872: PPUSH
3873: LD_INT 22
3875: PUSH
3876: LD_INT 5
3878: PUSH
3879: LD_INT 6
3881: PUSH
3882: LD_INT 9
3884: PUSH
3885: EMPTY
3886: LIST
3887: LIST
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL 22550 0 6
3895: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3896: LD_ADDR_EXP 59
3900: PUSH
3901: LD_EXP 59
3905: PPUSH
3906: LD_INT 1
3908: PPUSH
3909: LD_EXP 53
3913: PPUSH
3914: CALL_OW 1
3918: ST_TO_ADDR
// tmp := [ ] ;
3919: LD_ADDR_VAR 0 4
3923: PUSH
3924: EMPTY
3925: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3926: LD_ADDR_OWVAR 37
3930: PUSH
3931: LD_INT 14
3933: ST_TO_ADDR
// vc_engine := engine_siberite ;
3934: LD_ADDR_OWVAR 39
3938: PUSH
3939: LD_INT 3
3941: ST_TO_ADDR
// vc_control := control_manual ;
3942: LD_ADDR_OWVAR 38
3946: PUSH
3947: LD_INT 1
3949: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3950: LD_ADDR_OWVAR 40
3954: PUSH
3955: LD_INT 31
3957: ST_TO_ADDR
// for i = 1 to 3 do
3958: LD_ADDR_VAR 0 2
3962: PUSH
3963: DOUBLE
3964: LD_INT 1
3966: DEC
3967: ST_TO_ADDR
3968: LD_INT 3
3970: PUSH
3971: FOR_TO
3972: IFFALSE 4216
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3974: LD_ADDR_VAR 0 5
3978: PUSH
3979: LD_INT 153
3981: PUSH
3982: LD_INT 71
3984: PUSH
3985: EMPTY
3986: LIST
3987: LIST
3988: PUSH
3989: LD_INT 155
3991: PUSH
3992: LD_INT 81
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: PUSH
4003: LD_VAR 0 2
4007: PUSH
4008: LD_INT 2
4010: MOD
4011: PUSH
4012: LD_INT 1
4014: PLUS
4015: ARRAY
4016: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
4017: LD_INT 0
4019: PPUSH
4020: LD_INT 3
4022: PPUSH
4023: LD_INT 7
4025: PUSH
4026: LD_INT 8
4028: PUSH
4029: LD_INT 9
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: LIST
4036: PUSH
4037: LD_OWVAR 67
4041: ARRAY
4042: PPUSH
4043: CALL_OW 380
// un := CreateVehicle ;
4047: LD_ADDR_VAR 0 6
4051: PUSH
4052: CALL_OW 45
4056: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4057: LD_VAR 0 6
4061: PPUSH
4062: LD_INT 0
4064: PPUSH
4065: LD_INT 5
4067: PPUSH
4068: CALL_OW 12
4072: PPUSH
4073: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4077: LD_VAR 0 6
4081: PPUSH
4082: LD_VAR 0 5
4086: PUSH
4087: LD_INT 1
4089: ARRAY
4090: PPUSH
4091: LD_VAR 0 5
4095: PUSH
4096: LD_INT 2
4098: ARRAY
4099: PPUSH
4100: LD_INT 6
4102: PPUSH
4103: LD_INT 0
4105: PPUSH
4106: CALL_OW 50
// un2 := CreateHuman ;
4110: LD_ADDR_VAR 0 7
4114: PUSH
4115: CALL_OW 44
4119: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4120: LD_VAR 0 7
4124: PPUSH
4125: LD_VAR 0 6
4129: PPUSH
4130: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4134: LD_ADDR_EXP 59
4138: PUSH
4139: LD_EXP 59
4143: PPUSH
4144: LD_INT 1
4146: PUSH
4147: LD_EXP 59
4151: PUSH
4152: LD_INT 1
4154: ARRAY
4155: PUSH
4156: LD_INT 1
4158: PLUS
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PPUSH
4164: LD_VAR 0 6
4168: PPUSH
4169: CALL 19263 0 3
4173: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4174: LD_ADDR_EXP 59
4178: PUSH
4179: LD_EXP 59
4183: PPUSH
4184: LD_INT 1
4186: PUSH
4187: LD_EXP 59
4191: PUSH
4192: LD_INT 1
4194: ARRAY
4195: PUSH
4196: LD_INT 1
4198: PLUS
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PPUSH
4204: LD_VAR 0 7
4208: PPUSH
4209: CALL 19263 0 3
4213: ST_TO_ADDR
// end ;
4214: GO 3971
4216: POP
4217: POP
// for i = 1 to 5 do
4218: LD_ADDR_VAR 0 2
4222: PUSH
4223: DOUBLE
4224: LD_INT 1
4226: DEC
4227: ST_TO_ADDR
4228: LD_INT 5
4230: PUSH
4231: FOR_TO
4232: IFFALSE 4325
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4234: LD_INT 14
4236: PPUSH
4237: LD_INT 3
4239: PPUSH
4240: LD_INT 1
4242: PPUSH
4243: LD_INT 25
4245: PUSH
4246: LD_INT 28
4248: PUSH
4249: LD_INT 28
4251: PUSH
4252: LD_INT 26
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: LIST
4259: LIST
4260: PUSH
4261: LD_VAR 0 2
4265: PUSH
4266: LD_INT 4
4268: MOD
4269: PUSH
4270: LD_INT 1
4272: PLUS
4273: ARRAY
4274: PPUSH
4275: LD_INT 100
4277: PPUSH
4278: CALL 19141 0 5
// veh := CreateVehicle ;
4282: LD_ADDR_VAR 0 3
4286: PUSH
4287: CALL_OW 45
4291: ST_TO_ADDR
// tmp := tmp ^ veh ;
4292: LD_ADDR_VAR 0 4
4296: PUSH
4297: LD_VAR 0 4
4301: PUSH
4302: LD_VAR 0 3
4306: ADD
4307: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4308: LD_VAR 0 3
4312: PPUSH
4313: LD_INT 1
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: CALL_OW 49
// end ;
4323: GO 4231
4325: POP
4326: POP
// arabian_guard := tmp ;
4327: LD_ADDR_EXP 54
4331: PUSH
4332: LD_VAR 0 4
4336: ST_TO_ADDR
// end ;
4337: LD_VAR 0 1
4341: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4342: LD_INT 22
4344: PUSH
4345: LD_INT 7
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: PUSH
4352: LD_INT 91
4354: PUSH
4355: LD_INT 1
4357: PUSH
4358: LD_INT 12
4360: PUSH
4361: EMPTY
4362: LIST
4363: LIST
4364: LIST
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PPUSH
4370: CALL_OW 69
4374: PUSH
4375: LD_EXP 56
4379: PPUSH
4380: CALL_OW 256
4384: PUSH
4385: LD_INT 990
4387: LESS
4388: OR
4389: PUSH
4390: LD_EXP 55
4394: PPUSH
4395: CALL_OW 256
4399: PUSH
4400: LD_INT 990
4402: LESS
4403: OR
4404: IFFALSE 4547
4406: GO 4408
4408: DISABLE
// begin if IsInUnit ( Abdul ) then
4409: LD_EXP 55
4413: PPUSH
4414: CALL_OW 310
4418: IFFALSE 4429
// ComExitBuilding ( Abdul ) ;
4420: LD_EXP 55
4424: PPUSH
4425: CALL_OW 122
// if Mastodont then
4429: LD_EXP 56
4433: IFFALSE 4450
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4435: LD_EXP 56
4439: PPUSH
4440: LD_INT 205
4442: PPUSH
4443: LD_INT 132
4445: PPUSH
4446: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4450: LD_EXP 55
4454: PPUSH
4455: LD_INT 205
4457: PPUSH
4458: LD_INT 132
4460: PPUSH
4461: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4465: LD_INT 35
4467: PPUSH
4468: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4472: LD_EXP 55
4476: PPUSH
4477: LD_INT 21
4479: PPUSH
4480: CALL_OW 308
4484: IFFALSE 4465
// RemoveUnit ( Abdul ) ;
4486: LD_EXP 55
4490: PPUSH
4491: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4495: LD_INT 35
4497: PPUSH
4498: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4502: LD_EXP 56
4506: PPUSH
4507: LD_INT 21
4509: PPUSH
4510: CALL_OW 308
4514: PUSH
4515: LD_EXP 56
4519: PPUSH
4520: CALL_OW 301
4524: OR
4525: IFFALSE 4495
// if IsOk ( Mastodont ) then
4527: LD_EXP 56
4531: PPUSH
4532: CALL_OW 302
4536: IFFALSE 4547
// RemoveUnit ( Mastodont ) ;
4538: LD_EXP 56
4542: PPUSH
4543: CALL_OW 64
// end ;
4547: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4548: LD_EXP 55
4552: PPUSH
4553: CALL_OW 301
4557: PUSH
4558: LD_INT 22
4560: PUSH
4561: LD_INT 2
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: PUSH
4568: LD_INT 2
4570: PUSH
4571: LD_INT 25
4573: PUSH
4574: LD_INT 1
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: LD_INT 25
4583: PUSH
4584: LD_INT 2
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: PUSH
4591: LD_INT 25
4593: PUSH
4594: LD_INT 3
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: PUSH
4601: LD_INT 25
4603: PUSH
4604: LD_INT 4
4606: PUSH
4607: EMPTY
4608: LIST
4609: LIST
4610: PUSH
4611: LD_INT 25
4613: PUSH
4614: LD_INT 8
4616: PUSH
4617: EMPTY
4618: LIST
4619: LIST
4620: PUSH
4621: EMPTY
4622: LIST
4623: LIST
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: PUSH
4629: EMPTY
4630: LIST
4631: LIST
4632: PPUSH
4633: CALL_OW 69
4637: PUSH
4638: LD_INT 16
4640: PUSH
4641: LD_INT 19
4643: PUSH
4644: LD_INT 22
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: LIST
4651: PUSH
4652: LD_OWVAR 67
4656: ARRAY
4657: LESS
4658: OR
4659: IFFALSE 5332
4661: GO 4663
4663: DISABLE
4664: LD_INT 0
4666: PPUSH
4667: PPUSH
4668: PPUSH
4669: PPUSH
4670: PPUSH
4671: PPUSH
// begin MC_Kill ( 1 ) ;
4672: LD_INT 1
4674: PPUSH
4675: CALL 51621 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4679: LD_ADDR_VAR 0 2
4683: PUSH
4684: LD_INT 22
4686: PUSH
4687: LD_INT 2
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: PUSH
4694: LD_INT 2
4696: PUSH
4697: LD_INT 25
4699: PUSH
4700: LD_INT 1
4702: PUSH
4703: EMPTY
4704: LIST
4705: LIST
4706: PUSH
4707: LD_INT 25
4709: PUSH
4710: LD_INT 2
4712: PUSH
4713: EMPTY
4714: LIST
4715: LIST
4716: PUSH
4717: LD_INT 25
4719: PUSH
4720: LD_INT 3
4722: PUSH
4723: EMPTY
4724: LIST
4725: LIST
4726: PUSH
4727: LD_INT 25
4729: PUSH
4730: LD_INT 4
4732: PUSH
4733: EMPTY
4734: LIST
4735: LIST
4736: PUSH
4737: LD_INT 25
4739: PUSH
4740: LD_INT 8
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: LIST
4751: LIST
4752: LIST
4753: LIST
4754: PUSH
4755: EMPTY
4756: LIST
4757: LIST
4758: PPUSH
4759: CALL_OW 69
4763: ST_TO_ADDR
// for i in tmp do
4764: LD_ADDR_VAR 0 5
4768: PUSH
4769: LD_VAR 0 2
4773: PUSH
4774: FOR_IN
4775: IFFALSE 4791
// SetTag ( i , 10 ) ;
4777: LD_VAR 0 5
4781: PPUSH
4782: LD_INT 10
4784: PPUSH
4785: CALL_OW 109
4789: GO 4774
4791: POP
4792: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4793: LD_ADDR_VAR 0 3
4797: PUSH
4798: LD_INT 22
4800: PUSH
4801: LD_INT 2
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 21
4810: PUSH
4811: LD_INT 1
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PPUSH
4822: CALL_OW 69
4826: PUSH
4827: LD_VAR 0 2
4831: DIFF
4832: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4833: LD_ADDR_VAR 0 1
4837: PUSH
4838: LD_INT 22
4840: PUSH
4841: LD_INT 2
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 21
4850: PUSH
4851: LD_INT 2
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 24
4860: PUSH
4861: LD_INT 300
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: LIST
4872: PPUSH
4873: CALL_OW 69
4877: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4878: LD_ADDR_VAR 0 4
4882: PUSH
4883: LD_VAR 0 1
4887: PPUSH
4888: LD_INT 33
4890: PUSH
4891: LD_INT 1
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 58
4900: PUSH
4901: EMPTY
4902: LIST
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PPUSH
4908: CALL_OW 72
4912: ST_TO_ADDR
// for i in tmp do
4913: LD_ADDR_VAR 0 5
4917: PUSH
4918: LD_VAR 0 2
4922: PUSH
4923: FOR_IN
4924: IFFALSE 5108
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4926: LD_VAR 0 5
4930: PUSH
4931: LD_INT 55
4933: PUSH
4934: EMPTY
4935: LIST
4936: PPUSH
4937: CALL_OW 69
4941: IN
4942: IFFALSE 4961
// begin AddComMoveXY ( i , 209 , 132 ) ;
4944: LD_VAR 0 5
4948: PPUSH
4949: LD_INT 209
4951: PPUSH
4952: LD_INT 132
4954: PPUSH
4955: CALL_OW 171
// continue ;
4959: GO 4923
// end ; if IsInUnit ( i ) then
4961: LD_VAR 0 5
4965: PPUSH
4966: CALL_OW 310
4970: IFFALSE 4988
// begin ComExitBuilding ( i ) ;
4972: LD_VAR 0 5
4976: PPUSH
4977: CALL_OW 122
// wait ( 3 ) ;
4981: LD_INT 3
4983: PPUSH
4984: CALL_OW 67
// end ; if tmp_empty then
4988: LD_VAR 0 4
4992: IFFALSE 5091
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4994: LD_VAR 0 5
4998: PPUSH
4999: LD_VAR 0 4
5003: PPUSH
5004: LD_VAR 0 5
5008: PPUSH
5009: CALL_OW 74
5013: PPUSH
5014: CALL_OW 296
5018: PUSH
5019: LD_INT 25
5021: LESS
5022: IFFALSE 5091
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5024: LD_ADDR_VAR 0 6
5028: PUSH
5029: LD_VAR 0 4
5033: PPUSH
5034: LD_VAR 0 5
5038: PPUSH
5039: CALL_OW 74
5043: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5044: LD_VAR 0 5
5048: PPUSH
5049: LD_VAR 0 6
5053: PPUSH
5054: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5058: LD_VAR 0 5
5062: PPUSH
5063: LD_INT 209
5065: PPUSH
5066: LD_INT 132
5068: PPUSH
5069: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5073: LD_ADDR_VAR 0 4
5077: PUSH
5078: LD_VAR 0 4
5082: PUSH
5083: LD_VAR 0 6
5087: DIFF
5088: ST_TO_ADDR
// continue ;
5089: GO 4923
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5091: LD_VAR 0 5
5095: PPUSH
5096: LD_INT 201
5098: PPUSH
5099: LD_INT 132
5101: PPUSH
5102: CALL_OW 171
// end ;
5106: GO 4923
5108: POP
5109: POP
// for i in tmp_ape do
5110: LD_ADDR_VAR 0 5
5114: PUSH
5115: LD_VAR 0 3
5119: PUSH
5120: FOR_IN
5121: IFFALSE 5160
// begin if IsInUnit ( i ) then
5123: LD_VAR 0 5
5127: PPUSH
5128: CALL_OW 310
5132: IFFALSE 5143
// ComExitBuilding ( i ) ;
5134: LD_VAR 0 5
5138: PPUSH
5139: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5143: LD_VAR 0 5
5147: PPUSH
5148: LD_INT 201
5150: PPUSH
5151: LD_INT 132
5153: PPUSH
5154: CALL_OW 171
// end ;
5158: GO 5120
5160: POP
5161: POP
// repeat wait ( 0 0$1 ) ;
5162: LD_INT 35
5164: PPUSH
5165: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5169: LD_ADDR_VAR 0 5
5173: PUSH
5174: LD_VAR 0 2
5178: PUSH
5179: LD_VAR 0 3
5183: UNION
5184: PUSH
5185: LD_VAR 0 1
5189: UNION
5190: PUSH
5191: FOR_IN
5192: IFFALSE 5223
// if not HasTask ( i ) then
5194: LD_VAR 0 5
5198: PPUSH
5199: CALL_OW 314
5203: NOT
5204: IFFALSE 5221
// ComMoveXY ( i , 201 , 132 ) ;
5206: LD_VAR 0 5
5210: PPUSH
5211: LD_INT 201
5213: PPUSH
5214: LD_INT 132
5216: PPUSH
5217: CALL_OW 111
5221: GO 5191
5223: POP
5224: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5225: LD_INT 21
5227: PPUSH
5228: LD_INT 22
5230: PUSH
5231: LD_INT 2
5233: PUSH
5234: EMPTY
5235: LIST
5236: LIST
5237: PPUSH
5238: CALL_OW 70
5242: IFFALSE 5283
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5244: LD_ADDR_VAR 0 5
5248: PUSH
5249: LD_INT 21
5251: PPUSH
5252: LD_INT 22
5254: PUSH
5255: LD_INT 2
5257: PUSH
5258: EMPTY
5259: LIST
5260: LIST
5261: PPUSH
5262: CALL_OW 70
5266: PUSH
5267: FOR_IN
5268: IFFALSE 5281
// RemoveUnit ( i ) ;
5270: LD_VAR 0 5
5274: PPUSH
5275: CALL_OW 64
5279: GO 5267
5281: POP
5282: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5283: LD_INT 22
5285: PUSH
5286: LD_INT 2
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 2
5295: PUSH
5296: LD_INT 21
5298: PUSH
5299: LD_INT 1
5301: PUSH
5302: EMPTY
5303: LIST
5304: LIST
5305: PUSH
5306: LD_INT 21
5308: PUSH
5309: LD_INT 2
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: LIST
5320: PUSH
5321: EMPTY
5322: LIST
5323: LIST
5324: PPUSH
5325: CALL_OW 69
5329: NOT
5330: IFFALSE 5162
// end ;
5332: PPOPN 6
5334: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5335: LD_EXP 9
5339: PUSH
5340: LD_INT 92
5342: PPUSH
5343: LD_INT 40
5345: PPUSH
5346: CALL_OW 428
5350: PPUSH
5351: CALL_OW 266
5355: PUSH
5356: LD_INT 30
5358: EQUAL
5359: AND
5360: IFFALSE 5556
5362: GO 5364
5364: DISABLE
5365: LD_INT 0
5367: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5368: LD_ADDR_VAR 0 1
5372: PUSH
5373: LD_EXP 59
5377: PUSH
5378: LD_INT 1
5380: ARRAY
5381: PPUSH
5382: LD_INT 25
5384: PUSH
5385: LD_INT 4
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: PPUSH
5392: CALL_OW 72
5396: ST_TO_ADDR
// if not sci then
5397: LD_VAR 0 1
5401: NOT
5402: IFFALSE 5406
// exit ;
5404: GO 5556
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5406: LD_ADDR_EXP 59
5410: PUSH
5411: LD_EXP 59
5415: PPUSH
5416: LD_INT 1
5418: PPUSH
5419: LD_EXP 59
5423: PUSH
5424: LD_INT 1
5426: ARRAY
5427: PUSH
5428: LD_VAR 0 1
5432: PUSH
5433: LD_INT 1
5435: ARRAY
5436: DIFF
5437: PPUSH
5438: CALL_OW 1
5442: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5443: LD_VAR 0 1
5447: PUSH
5448: LD_INT 1
5450: ARRAY
5451: PPUSH
5452: CALL_OW 310
5456: IFFALSE 5471
// ComExitBuilding ( sci [ 1 ] ) ;
5458: LD_VAR 0 1
5462: PUSH
5463: LD_INT 1
5465: ARRAY
5466: PPUSH
5467: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5471: LD_INT 2
5473: PPUSH
5474: LD_INT 105
5476: PPUSH
5477: LD_INT 14
5479: PPUSH
5480: LD_INT 20
5482: PPUSH
5483: CALL 20159 0 4
5487: PUSH
5488: LD_INT 4
5490: ARRAY
5491: PUSH
5492: LD_INT 10
5494: LESS
5495: IFFALSE 5518
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5497: LD_VAR 0 1
5501: PUSH
5502: LD_INT 1
5504: ARRAY
5505: PPUSH
5506: LD_INT 105
5508: PPUSH
5509: LD_INT 14
5511: PPUSH
5512: CALL_OW 171
5516: GO 5537
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5518: LD_VAR 0 1
5522: PUSH
5523: LD_INT 1
5525: ARRAY
5526: PPUSH
5527: LD_INT 118
5529: PPUSH
5530: LD_INT 77
5532: PPUSH
5533: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5537: LD_VAR 0 1
5541: PUSH
5542: LD_INT 1
5544: ARRAY
5545: PPUSH
5546: LD_INT 92
5548: PPUSH
5549: LD_INT 40
5551: PPUSH
5552: CALL_OW 218
// end ;
5556: PPOPN 1
5558: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5559: LD_INT 1
5561: PPUSH
5562: CALL_OW 302
5566: PUSH
5567: LD_EXP 9
5571: AND
5572: IFFALSE 6031
5574: GO 5576
5576: DISABLE
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// begin enable ;
5585: ENABLE
// base := 1 ;
5586: LD_ADDR_VAR 0 2
5590: PUSH
5591: LD_INT 1
5593: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5594: LD_ADDR_VAR 0 4
5598: PUSH
5599: LD_INT 0
5601: PUSH
5602: LD_INT 0
5604: PUSH
5605: LD_INT 0
5607: PUSH
5608: LD_INT 0
5610: PUSH
5611: LD_INT 0
5613: PUSH
5614: LD_INT 0
5616: PUSH
5617: LD_INT 0
5619: PUSH
5620: LD_INT 0
5622: PUSH
5623: LD_INT 1
5625: PUSH
5626: LD_INT 0
5628: PUSH
5629: EMPTY
5630: LIST
5631: LIST
5632: LIST
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5641: LD_ADDR_VAR 0 3
5645: PUSH
5646: LD_INT 14
5648: PUSH
5649: LD_INT 1
5651: PUSH
5652: LD_INT 2
5654: PUSH
5655: LD_INT 26
5657: PUSH
5658: EMPTY
5659: LIST
5660: LIST
5661: LIST
5662: LIST
5663: PUSH
5664: LD_INT 14
5666: PUSH
5667: LD_INT 1
5669: PUSH
5670: LD_INT 2
5672: PUSH
5673: LD_INT 28
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: LIST
5681: PUSH
5682: LD_INT 13
5684: PUSH
5685: LD_INT 1
5687: PUSH
5688: LD_INT 2
5690: PUSH
5691: LD_INT 29
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: LIST
5698: LIST
5699: PUSH
5700: EMPTY
5701: LIST
5702: LIST
5703: LIST
5704: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5705: LD_ADDR_VAR 0 1
5709: PUSH
5710: DOUBLE
5711: LD_INT 1
5713: DEC
5714: ST_TO_ADDR
5715: LD_OWVAR 67
5719: PUSH
5720: LD_OWVAR 1
5724: PUSH
5725: LD_INT 21000
5727: DIV
5728: PLUS
5729: PUSH
5730: FOR_TO
5731: IFFALSE 5823
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5733: LD_ADDR_VAR 0 3
5737: PUSH
5738: LD_VAR 0 3
5742: PPUSH
5743: LD_VAR 0 3
5747: PUSH
5748: LD_INT 1
5750: PLUS
5751: PPUSH
5752: LD_INT 13
5754: PUSH
5755: LD_INT 14
5757: PUSH
5758: EMPTY
5759: LIST
5760: LIST
5761: PUSH
5762: LD_INT 1
5764: PPUSH
5765: LD_INT 2
5767: PPUSH
5768: CALL_OW 12
5772: ARRAY
5773: PUSH
5774: LD_INT 1
5776: PUSH
5777: LD_INT 2
5779: PUSH
5780: LD_INT 28
5782: PUSH
5783: LD_INT 29
5785: PUSH
5786: LD_INT 25
5788: PUSH
5789: LD_INT 26
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: LIST
5796: LIST
5797: PUSH
5798: LD_INT 1
5800: PPUSH
5801: LD_INT 4
5803: PPUSH
5804: CALL_OW 12
5808: ARRAY
5809: PUSH
5810: EMPTY
5811: LIST
5812: LIST
5813: LIST
5814: LIST
5815: PPUSH
5816: CALL_OW 2
5820: ST_TO_ADDR
5821: GO 5730
5823: POP
5824: POP
// MC_InsertProduceList ( base , tmp ) ;
5825: LD_VAR 0 2
5829: PPUSH
5830: LD_VAR 0 3
5834: PPUSH
5835: CALL 75113 0 2
// repeat wait ( 0 0$1 ) ;
5839: LD_INT 35
5841: PPUSH
5842: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5846: LD_EXP 78
5850: PUSH
5851: LD_VAR 0 2
5855: ARRAY
5856: PUSH
5857: LD_INT 6
5859: GREATER
5860: IFFALSE 5839
// wait ( 0 0$20 ) ;
5862: LD_INT 700
5864: PPUSH
5865: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5869: LD_ADDR_VAR 0 5
5873: PUSH
5874: LD_INT 124
5876: PUSH
5877: LD_INT 85
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: PUSH
5884: LD_INT 90
5886: PUSH
5887: LD_INT 61
5889: PUSH
5890: EMPTY
5891: LIST
5892: LIST
5893: PUSH
5894: LD_INT 69
5896: PUSH
5897: LD_INT 48
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: PUSH
5904: LD_INT 68
5906: PUSH
5907: LD_INT 48
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: LIST
5918: LIST
5919: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5920: LD_ADDR_VAR 0 6
5924: PUSH
5925: LD_EXP 78
5929: PUSH
5930: LD_VAR 0 2
5934: ARRAY
5935: PUSH
5936: LD_EXP 78
5940: PUSH
5941: LD_VAR 0 2
5945: ARRAY
5946: PPUSH
5947: LD_INT 34
5949: PUSH
5950: LD_INT 32
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: PPUSH
5957: CALL_OW 72
5961: DIFF
5962: ST_TO_ADDR
// if not attackers then
5963: LD_VAR 0 6
5967: NOT
5968: IFFALSE 5972
// exit ;
5970: GO 6031
// ar_attackers := attackers ;
5972: LD_ADDR_EXP 10
5976: PUSH
5977: LD_VAR 0 6
5981: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5982: LD_INT 35
5984: PPUSH
5985: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5989: LD_VAR 0 6
5993: PPUSH
5994: LD_INT 60
5996: PUSH
5997: EMPTY
5998: LIST
5999: PPUSH
6000: CALL_OW 72
6004: NOT
6005: IFFALSE 5982
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6007: LD_VAR 0 2
6011: PPUSH
6012: LD_VAR 0 6
6016: PPUSH
6017: LD_VAR 0 5
6021: PPUSH
6022: LD_VAR 0 4
6026: PPUSH
6027: CALL 75298 0 4
// end ;
6031: PPOPN 6
6033: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6034: LD_INT 1
6036: PPUSH
6037: CALL_OW 302
6041: PUSH
6042: LD_EXP 9
6046: AND
6047: PUSH
6048: LD_EXP 49
6052: PPUSH
6053: LD_INT 22
6055: PPUSH
6056: CALL_OW 308
6060: AND
6061: PUSH
6062: LD_INT 1
6064: PPUSH
6065: CALL 75461 0 1
6069: PUSH
6070: LD_INT 0
6072: EQUAL
6073: AND
6074: PUSH
6075: LD_EXP 10
6079: NOT
6080: AND
6081: IFFALSE 6545
6083: GO 6085
6085: DISABLE
6086: LD_INT 0
6088: PPUSH
6089: PPUSH
6090: PPUSH
6091: PPUSH
6092: PPUSH
6093: PPUSH
6094: PPUSH
// begin base := 1 ;
6095: LD_ADDR_VAR 0 2
6099: PUSH
6100: LD_INT 1
6102: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6103: LD_ADDR_VAR 0 4
6107: PUSH
6108: LD_INT 0
6110: PUSH
6111: LD_INT 0
6113: PUSH
6114: LD_INT 0
6116: PUSH
6117: LD_INT 0
6119: PUSH
6120: LD_INT 0
6122: PUSH
6123: LD_INT 0
6125: PUSH
6126: LD_INT 0
6128: PUSH
6129: LD_INT 0
6131: PUSH
6132: LD_INT 1
6134: PUSH
6135: LD_INT 0
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: LIST
6148: LIST
6149: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6150: LD_ADDR_VAR 0 3
6154: PUSH
6155: LD_INT 13
6157: PUSH
6158: LD_INT 1
6160: PUSH
6161: LD_INT 2
6163: PUSH
6164: LD_INT 28
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: LIST
6171: LIST
6172: PUSH
6173: LD_INT 13
6175: PUSH
6176: LD_INT 1
6178: PUSH
6179: LD_INT 2
6181: PUSH
6182: LD_INT 27
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: PUSH
6191: LD_INT 13
6193: PUSH
6194: LD_INT 1
6196: PUSH
6197: LD_INT 2
6199: PUSH
6200: LD_INT 25
6202: PUSH
6203: EMPTY
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 11
6211: PUSH
6212: LD_INT 2
6214: PUSH
6215: LD_INT 2
6217: PUSH
6218: LD_INT 24
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 11
6229: PUSH
6230: LD_INT 2
6232: PUSH
6233: LD_INT 2
6235: PUSH
6236: LD_INT 24
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: LIST
6251: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6252: LD_VAR 0 2
6256: PPUSH
6257: LD_VAR 0 3
6261: PPUSH
6262: CALL 75113 0 2
// repeat wait ( 0 0$1 ) ;
6266: LD_INT 35
6268: PPUSH
6269: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6273: LD_EXP 78
6277: PUSH
6278: LD_VAR 0 2
6282: ARRAY
6283: PUSH
6284: LD_INT 6
6286: GREATEREQUAL
6287: IFFALSE 6266
// wait ( 0 0$20 ) ;
6289: LD_INT 700
6291: PPUSH
6292: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6296: LD_ADDR_VAR 0 5
6300: PUSH
6301: LD_INT 119
6303: PUSH
6304: LD_INT 9
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PUSH
6311: EMPTY
6312: LIST
6313: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6314: LD_ADDR_VAR 0 6
6318: PUSH
6319: LD_EXP 78
6323: PUSH
6324: LD_VAR 0 2
6328: ARRAY
6329: PUSH
6330: LD_EXP 78
6334: PUSH
6335: LD_VAR 0 2
6339: ARRAY
6340: PPUSH
6341: LD_INT 34
6343: PUSH
6344: LD_INT 32
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: PPUSH
6351: CALL_OW 72
6355: DIFF
6356: ST_TO_ADDR
// if not attackers then
6357: LD_VAR 0 6
6361: NOT
6362: IFFALSE 6366
// exit ;
6364: GO 6545
// uc_side := 2 ;
6366: LD_ADDR_OWVAR 20
6370: PUSH
6371: LD_INT 2
6373: ST_TO_ADDR
// uc_nation := 2 ;
6374: LD_ADDR_OWVAR 21
6378: PUSH
6379: LD_INT 2
6381: ST_TO_ADDR
// InitHc ;
6382: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6386: LD_ADDR_VAR 0 1
6390: PUSH
6391: DOUBLE
6392: LD_INT 1
6394: DEC
6395: ST_TO_ADDR
6396: LD_INT 4
6398: PUSH
6399: LD_INT 5
6401: PUSH
6402: LD_INT 6
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: LIST
6409: PUSH
6410: LD_OWVAR 67
6414: ARRAY
6415: PUSH
6416: FOR_TO
6417: IFFALSE 6494
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6419: LD_INT 0
6421: PPUSH
6422: LD_INT 15
6424: PUSH
6425: LD_INT 17
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: PUSH
6432: LD_INT 1
6434: PPUSH
6435: LD_INT 2
6437: PPUSH
6438: CALL_OW 12
6442: ARRAY
6443: PPUSH
6444: LD_INT 8
6446: PPUSH
6447: CALL_OW 380
// un := CreateHuman ;
6451: LD_ADDR_VAR 0 7
6455: PUSH
6456: CALL_OW 44
6460: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6461: LD_VAR 0 7
6465: PPUSH
6466: LD_INT 23
6468: PPUSH
6469: LD_INT 0
6471: PPUSH
6472: CALL_OW 49
// attackers := attackers union un ;
6476: LD_ADDR_VAR 0 6
6480: PUSH
6481: LD_VAR 0 6
6485: PUSH
6486: LD_VAR 0 7
6490: UNION
6491: ST_TO_ADDR
// end ;
6492: GO 6416
6494: POP
6495: POP
// repeat wait ( 0 0$1 ) ;
6496: LD_INT 35
6498: PPUSH
6499: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6503: LD_VAR 0 6
6507: PPUSH
6508: LD_INT 60
6510: PUSH
6511: EMPTY
6512: LIST
6513: PPUSH
6514: CALL_OW 72
6518: NOT
6519: IFFALSE 6496
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6521: LD_VAR 0 2
6525: PPUSH
6526: LD_VAR 0 6
6530: PPUSH
6531: LD_VAR 0 5
6535: PPUSH
6536: LD_VAR 0 4
6540: PPUSH
6541: CALL 75298 0 4
// end ; end_of_file
6545: PPOPN 7
6547: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6548: LD_INT 0
6550: PPUSH
6551: PPUSH
6552: PPUSH
6553: PPUSH
// uc_side := 1 ;
6554: LD_ADDR_OWVAR 20
6558: PUSH
6559: LD_INT 1
6561: ST_TO_ADDR
// uc_nation := 1 ;
6562: LD_ADDR_OWVAR 21
6566: PUSH
6567: LD_INT 1
6569: ST_TO_ADDR
// InitHc ;
6570: CALL_OW 19
// InitVc ;
6574: CALL_OW 20
// tmp := [ ] ;
6578: LD_ADDR_VAR 0 3
6582: PUSH
6583: EMPTY
6584: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6585: LD_ADDR_VAR 0 2
6589: PUSH
6590: DOUBLE
6591: LD_INT 1
6593: DEC
6594: ST_TO_ADDR
6595: LD_INT 5
6597: PUSH
6598: LD_INT 6
6600: PUSH
6601: LD_INT 6
6603: PUSH
6604: EMPTY
6605: LIST
6606: LIST
6607: LIST
6608: PUSH
6609: LD_OWVAR 67
6613: ARRAY
6614: PUSH
6615: FOR_TO
6616: IFFALSE 6753
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6618: LD_INT 2
6620: PUSH
6621: LD_INT 4
6623: PUSH
6624: LD_INT 5
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: PUSH
6632: LD_INT 1
6634: PPUSH
6635: LD_INT 3
6637: PPUSH
6638: CALL_OW 12
6642: ARRAY
6643: PPUSH
6644: LD_INT 1
6646: PUSH
6647: LD_INT 3
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 1
6656: PPUSH
6657: LD_INT 2
6659: PPUSH
6660: CALL_OW 12
6664: ARRAY
6665: PPUSH
6666: LD_INT 3
6668: PPUSH
6669: LD_INT 9
6671: PUSH
6672: LD_INT 7
6674: PUSH
6675: EMPTY
6676: LIST
6677: LIST
6678: PUSH
6679: LD_INT 1
6681: PPUSH
6682: LD_INT 2
6684: PPUSH
6685: CALL_OW 12
6689: ARRAY
6690: PPUSH
6691: LD_INT 78
6693: PPUSH
6694: CALL 19141 0 5
// veh := CreateVehicle ;
6698: LD_ADDR_VAR 0 4
6702: PUSH
6703: CALL_OW 45
6707: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6708: LD_VAR 0 4
6712: PPUSH
6713: LD_INT 2
6715: PPUSH
6716: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6720: LD_VAR 0 4
6724: PPUSH
6725: LD_INT 17
6727: PPUSH
6728: LD_INT 0
6730: PPUSH
6731: CALL_OW 49
// tmp := tmp ^ veh ;
6735: LD_ADDR_VAR 0 3
6739: PUSH
6740: LD_VAR 0 3
6744: PUSH
6745: LD_VAR 0 4
6749: ADD
6750: ST_TO_ADDR
// end ;
6751: GO 6615
6753: POP
6754: POP
// if not tmp then
6755: LD_VAR 0 3
6759: NOT
6760: IFFALSE 6764
// exit ;
6762: GO 6873
// if not first_powell_attack then
6764: LD_EXP 11
6768: NOT
6769: IFFALSE 6779
// first_powell_attack := true ;
6771: LD_ADDR_EXP 11
6775: PUSH
6776: LD_INT 1
6778: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6779: LD_INT 70
6781: PPUSH
6782: CALL_OW 67
// for i in tmp do
6786: LD_ADDR_VAR 0 2
6790: PUSH
6791: LD_VAR 0 3
6795: PUSH
6796: FOR_IN
6797: IFFALSE 6864
// if IsOk ( i ) then
6799: LD_VAR 0 2
6803: PPUSH
6804: CALL_OW 302
6808: IFFALSE 6846
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6810: LD_VAR 0 2
6814: PPUSH
6815: LD_INT 81
6817: PUSH
6818: LD_INT 1
6820: PUSH
6821: EMPTY
6822: LIST
6823: LIST
6824: PPUSH
6825: CALL_OW 69
6829: PPUSH
6830: LD_VAR 0 2
6834: PPUSH
6835: CALL_OW 74
6839: PPUSH
6840: CALL_OW 115
6844: GO 6862
// tmp := tmp diff i ;
6846: LD_ADDR_VAR 0 3
6850: PUSH
6851: LD_VAR 0 3
6855: PUSH
6856: LD_VAR 0 2
6860: DIFF
6861: ST_TO_ADDR
6862: GO 6796
6864: POP
6865: POP
// until not tmp ;
6866: LD_VAR 0 3
6870: NOT
6871: IFFALSE 6779
// end ; end_of_file
6873: LD_VAR 0 1
6877: RET
// export function Action ; var tmp , i , un ; begin
6878: LD_INT 0
6880: PPUSH
6881: PPUSH
6882: PPUSH
6883: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6884: LD_INT 68
6886: PPUSH
6887: LD_INT 39
6889: PPUSH
6890: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6894: LD_ADDR_VAR 0 2
6898: PUSH
6899: LD_INT 22
6901: PUSH
6902: LD_INT 7
6904: PUSH
6905: EMPTY
6906: LIST
6907: LIST
6908: PPUSH
6909: CALL_OW 69
6913: ST_TO_ADDR
// InGameOn ;
6914: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6918: LD_VAR 0 2
6922: PPUSH
6923: LD_INT 71
6925: PPUSH
6926: LD_INT 49
6928: PPUSH
6929: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6933: LD_INT 35
6935: PPUSH
6936: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6940: LD_INT 7
6942: PPUSH
6943: LD_INT 71
6945: PPUSH
6946: LD_INT 51
6948: PPUSH
6949: CALL_OW 293
6953: IFFALSE 6933
// DialogueOn ;
6955: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6959: LD_EXP 15
6963: PPUSH
6964: LD_STRING D1-JMM-1
6966: PPUSH
6967: CALL_OW 88
// if Joan then
6971: LD_EXP 30
6975: IFFALSE 6989
// Say ( Joan , D1-Joan-1 ) ;
6977: LD_EXP 30
6981: PPUSH
6982: LD_STRING D1-Joan-1
6984: PPUSH
6985: CALL_OW 88
// if Lisa then
6989: LD_EXP 17
6993: IFFALSE 7007
// Say ( Lisa , D1-Lisa-1 ) ;
6995: LD_EXP 17
6999: PPUSH
7000: LD_STRING D1-Lisa-1
7002: PPUSH
7003: CALL_OW 88
// if Joan or Lisa then
7007: LD_EXP 30
7011: PUSH
7012: LD_EXP 17
7016: OR
7017: IFFALSE 7031
// Say ( JMM , D1-JMM-2 ) ;
7019: LD_EXP 15
7023: PPUSH
7024: LD_STRING D1-JMM-2
7026: PPUSH
7027: CALL_OW 88
// DialogueOff ;
7031: CALL_OW 7
// InGameOff ;
7035: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7039: LD_INT 71
7041: PPUSH
7042: LD_INT 50
7044: PPUSH
7045: LD_INT 7
7047: PPUSH
7048: LD_INT 30
7050: NEG
7051: PPUSH
7052: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7056: LD_INT 71
7058: PPUSH
7059: LD_INT 50
7061: PPUSH
7062: LD_INT 7
7064: PPUSH
7065: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7069: LD_STRING M1
7071: PPUSH
7072: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7076: LD_INT 35
7078: PPUSH
7079: CALL_OW 67
// until freedom ;
7083: LD_EXP 3
7087: IFFALSE 7076
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7089: LD_INT 350
7091: PPUSH
7092: LD_INT 700
7094: PPUSH
7095: CALL_OW 12
7099: PPUSH
7100: CALL_OW 67
// PrepareGossudarov ;
7104: CALL 1827 0 0
// repeat wait ( 0 0$1 ) ;
7108: LD_INT 35
7110: PPUSH
7111: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7115: LD_INT 22
7117: PUSH
7118: LD_INT 6
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 3
7127: PUSH
7128: LD_INT 24
7130: PUSH
7131: LD_INT 1000
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: PPUSH
7146: CALL_OW 69
7150: PUSH
7151: LD_INT 7
7153: PPUSH
7154: LD_EXP 32
7158: PPUSH
7159: CALL_OW 292
7163: OR
7164: IFFALSE 7108
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7166: LD_ADDR_VAR 0 2
7170: PUSH
7171: LD_INT 22
7173: PUSH
7174: LD_INT 6
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: PPUSH
7181: CALL_OW 69
7185: ST_TO_ADDR
// for i in tmp do
7186: LD_ADDR_VAR 0 3
7190: PUSH
7191: LD_VAR 0 2
7195: PUSH
7196: FOR_IN
7197: IFFALSE 7213
// SetSide ( i , 7 ) ;
7199: LD_VAR 0 3
7203: PPUSH
7204: LD_INT 7
7206: PPUSH
7207: CALL_OW 235
7211: GO 7196
7213: POP
7214: POP
// DialogueOn ;
7215: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7219: LD_EXP 15
7223: PUSH
7224: LD_EXP 16
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: PPUSH
7233: LD_EXP 32
7237: PPUSH
7238: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7242: LD_EXP 32
7246: PPUSH
7247: CALL_OW 87
// if not Roth then
7251: LD_EXP 16
7255: NOT
7256: IFFALSE 7348
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7258: LD_VAR 0 2
7262: PPUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 24
7268: PUSH
7269: LD_INT 1000
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: PUSH
7276: EMPTY
7277: LIST
7278: LIST
7279: PPUSH
7280: CALL_OW 72
7284: IFFALSE 7298
// Say ( JMM , D2-JMM-1 ) ;
7286: LD_EXP 15
7290: PPUSH
7291: LD_STRING D2-JMM-1
7293: PPUSH
7294: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7298: LD_EXP 15
7302: PPUSH
7303: LD_STRING D2-JMM-1b
7305: PPUSH
7306: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7310: LD_EXP 32
7314: PPUSH
7315: LD_STRING D2-Gos-1
7317: PPUSH
7318: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7322: LD_EXP 15
7326: PPUSH
7327: LD_STRING D2-JMM-2
7329: PPUSH
7330: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7334: LD_EXP 32
7338: PPUSH
7339: LD_STRING D2-Gos-2
7341: PPUSH
7342: CALL_OW 88
// end else
7346: GO 7500
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7348: LD_VAR 0 2
7352: PPUSH
7353: LD_INT 3
7355: PUSH
7356: LD_INT 24
7358: PUSH
7359: LD_INT 1000
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: PUSH
7366: EMPTY
7367: LIST
7368: LIST
7369: PPUSH
7370: CALL_OW 72
7374: IFFALSE 7400
// begin Say ( Roth , D2-Roth-2 ) ;
7376: LD_EXP 16
7380: PPUSH
7381: LD_STRING D2-Roth-2
7383: PPUSH
7384: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7388: LD_EXP 15
7392: PPUSH
7393: LD_STRING D2-JMM-1a
7395: PPUSH
7396: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7400: LD_EXP 16
7404: PPUSH
7405: LD_STRING D2-Roth-2a
7407: PPUSH
7408: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7412: LD_EXP 16
7416: PPUSH
7417: LD_STRING D2-Roth-2b
7419: PPUSH
7420: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7424: LD_EXP 15
7428: PPUSH
7429: LD_STRING D2-JMM-3
7431: PPUSH
7432: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7436: LD_VAR 0 2
7440: PPUSH
7441: LD_INT 3
7443: PUSH
7444: LD_INT 24
7446: PUSH
7447: LD_INT 1000
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: PPUSH
7458: CALL_OW 72
7462: IFFALSE 7500
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7464: LD_EXP 32
7468: PPUSH
7469: LD_STRING D2-Gos-3
7471: PPUSH
7472: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7476: LD_EXP 15
7480: PPUSH
7481: LD_STRING D2-JMM-4
7483: PPUSH
7484: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7488: LD_EXP 32
7492: PPUSH
7493: LD_STRING D2-Gos-4
7495: PPUSH
7496: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7500: LD_EXP 15
7504: PPUSH
7505: LD_STRING D2-JMM-5
7507: PPUSH
7508: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7512: LD_EXP 32
7516: PPUSH
7517: LD_STRING D2-Gos-5
7519: PPUSH
7520: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7524: LD_EXP 15
7528: PPUSH
7529: LD_STRING D2-JMM-6
7531: PPUSH
7532: CALL_OW 88
// DialogueOff ;
7536: CALL_OW 7
// wait ( 0 0$2 ) ;
7540: LD_INT 70
7542: PPUSH
7543: CALL_OW 67
// if Kirilenkova then
7547: LD_EXP 33
7551: IFFALSE 7565
// Say ( Kirilenkova , D3-Kir-1 ) ;
7553: LD_EXP 33
7557: PPUSH
7558: LD_STRING D3-Kir-1
7560: PPUSH
7561: CALL_OW 88
// gossudarov_arrive := true ;
7565: LD_ADDR_EXP 4
7569: PUSH
7570: LD_INT 1
7572: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7573: LD_INT 35
7575: PPUSH
7576: CALL_OW 67
// until ru_lab_builded ;
7580: LD_EXP 5
7584: IFFALSE 7573
// DialogueOn ;
7586: CALL_OW 6
// if Kirilenkova then
7590: LD_EXP 33
7594: IFFALSE 7610
// Say ( Kirilenkova , D3a-Kir-1 ) else
7596: LD_EXP 33
7600: PPUSH
7601: LD_STRING D3a-Kir-1
7603: PPUSH
7604: CALL_OW 88
7608: GO 7632
// begin un := SciRu ;
7610: LD_ADDR_VAR 0 4
7614: PUSH
7615: CALL 12744 0 0
7619: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7620: LD_VAR 0 4
7624: PPUSH
7625: LD_STRING D3a-Sci1-1
7627: PPUSH
7628: CALL_OW 88
// end ; if Kirilenkova or un then
7632: LD_EXP 33
7636: PUSH
7637: LD_VAR 0 4
7641: OR
7642: IFFALSE 7656
// Say ( JMM , D3a-JMM-1 ) ;
7644: LD_EXP 15
7648: PPUSH
7649: LD_STRING D3a-JMM-1
7651: PPUSH
7652: CALL_OW 88
// DialogueOff ;
7656: CALL_OW 7
// end ;
7660: LD_VAR 0 1
7664: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7665: LD_EXP 4
7669: PUSH
7670: LD_INT 22
7672: PUSH
7673: LD_INT 7
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: PUSH
7680: LD_INT 2
7682: PUSH
7683: LD_INT 25
7685: PUSH
7686: LD_INT 1
7688: PUSH
7689: EMPTY
7690: LIST
7691: LIST
7692: PUSH
7693: LD_INT 25
7695: PUSH
7696: LD_INT 2
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: PUSH
7703: LD_INT 25
7705: PUSH
7706: LD_INT 3
7708: PUSH
7709: EMPTY
7710: LIST
7711: LIST
7712: PUSH
7713: LD_INT 25
7715: PUSH
7716: LD_INT 4
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: PUSH
7723: LD_INT 25
7725: PUSH
7726: LD_INT 5
7728: PUSH
7729: EMPTY
7730: LIST
7731: LIST
7732: PUSH
7733: LD_INT 25
7735: PUSH
7736: LD_INT 8
7738: PUSH
7739: EMPTY
7740: LIST
7741: LIST
7742: PUSH
7743: LD_INT 25
7745: PUSH
7746: LD_INT 9
7748: PUSH
7749: EMPTY
7750: LIST
7751: LIST
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: LIST
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: PPUSH
7767: CALL_OW 69
7771: PUSH
7772: LD_INT 7
7774: LESS
7775: AND
7776: IFFALSE 7788
7778: GO 7780
7780: DISABLE
// YouLost ( TooMany ) ;
7781: LD_STRING TooMany
7783: PPUSH
7784: CALL_OW 104
7788: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7789: LD_EXP 32
7793: PPUSH
7794: CALL_OW 255
7798: PUSH
7799: LD_INT 7
7801: EQUAL
7802: IFFALSE 8002
7804: GO 7806
7806: DISABLE
7807: LD_INT 0
7809: PPUSH
7810: PPUSH
7811: PPUSH
// begin uc_side := 3 ;
7812: LD_ADDR_OWVAR 20
7816: PUSH
7817: LD_INT 3
7819: ST_TO_ADDR
// uc_nation := 3 ;
7820: LD_ADDR_OWVAR 21
7824: PUSH
7825: LD_INT 3
7827: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7828: LD_INT 21
7830: PPUSH
7831: LD_INT 3
7833: PPUSH
7834: LD_INT 3
7836: PPUSH
7837: LD_INT 42
7839: PPUSH
7840: LD_INT 100
7842: PPUSH
7843: CALL 19141 0 5
// un := CreateVehicle ;
7847: LD_ADDR_VAR 0 3
7851: PUSH
7852: CALL_OW 45
7856: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7857: LD_VAR 0 3
7861: PPUSH
7862: LD_INT 15
7864: PPUSH
7865: LD_INT 0
7867: PPUSH
7868: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7872: LD_VAR 0 3
7876: PPUSH
7877: LD_INT 67
7879: PPUSH
7880: LD_INT 45
7882: PPUSH
7883: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7887: LD_VAR 0 3
7891: PPUSH
7892: LD_INT 70
7894: PPUSH
7895: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7899: LD_VAR 0 3
7903: PPUSH
7904: LD_INT 69
7906: PPUSH
7907: LD_INT 18
7909: PPUSH
7910: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7914: LD_VAR 0 3
7918: PPUSH
7919: LD_INT 60
7921: PPUSH
7922: LD_INT 2
7924: PPUSH
7925: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7929: LD_INT 35
7931: PPUSH
7932: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7936: LD_VAR 0 3
7940: PPUSH
7941: CALL_OW 302
7945: NOT
7946: PUSH
7947: LD_VAR 0 3
7951: PPUSH
7952: LD_INT 17
7954: PPUSH
7955: CALL_OW 308
7959: OR
7960: IFFALSE 7929
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7962: LD_VAR 0 3
7966: PPUSH
7967: LD_INT 17
7969: PPUSH
7970: CALL_OW 308
7974: PUSH
7975: LD_VAR 0 3
7979: PPUSH
7980: LD_INT 60
7982: PPUSH
7983: LD_INT 2
7985: PPUSH
7986: CALL_OW 307
7990: OR
7991: IFFALSE 8002
// RemoveUnit ( un ) ;
7993: LD_VAR 0 3
7997: PPUSH
7998: CALL_OW 64
// end ;
8002: PPOPN 3
8004: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8005: LD_EXP 4
8009: IFFALSE 8251
8011: GO 8013
8013: DISABLE
8014: LD_INT 0
8016: PPUSH
8017: PPUSH
8018: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8019: LD_INT 70
8021: PPUSH
8022: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8026: LD_ADDR_VAR 0 3
8030: PUSH
8031: LD_INT 22
8033: PUSH
8034: LD_INT 7
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PUSH
8041: LD_INT 101
8043: PUSH
8044: LD_INT 3
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PPUSH
8055: CALL_OW 69
8059: ST_TO_ADDR
// until tmp ;
8060: LD_VAR 0 3
8064: IFFALSE 8019
// un := NearestUnitToUnit ( tmp , JMM ) ;
8066: LD_ADDR_VAR 0 2
8070: PUSH
8071: LD_VAR 0 3
8075: PPUSH
8076: LD_EXP 15
8080: PPUSH
8081: CALL_OW 74
8085: ST_TO_ADDR
// player_spotted := true ;
8086: LD_ADDR_EXP 6
8090: PUSH
8091: LD_INT 1
8093: ST_TO_ADDR
// tmp := SciRu ;
8094: LD_ADDR_VAR 0 3
8098: PUSH
8099: CALL 12744 0 0
8103: ST_TO_ADDR
// if not tmp then
8104: LD_VAR 0 3
8108: NOT
8109: IFFALSE 8121
// tmp := SolRu ;
8111: LD_ADDR_VAR 0 3
8115: PUSH
8116: CALL 12891 0 0
8120: ST_TO_ADDR
// DialogueOn ;
8121: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8125: LD_VAR 0 2
8129: PPUSH
8130: CALL_OW 250
8134: PPUSH
8135: LD_VAR 0 2
8139: PPUSH
8140: CALL_OW 251
8144: PPUSH
8145: LD_INT 7
8147: PPUSH
8148: LD_INT 8
8150: NEG
8151: PPUSH
8152: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8156: LD_VAR 0 2
8160: PPUSH
8161: CALL_OW 87
// if tmp then
8165: LD_VAR 0 3
8169: IFFALSE 8183
// Say ( tmp , D4-RSci1-1 ) ;
8171: LD_VAR 0 3
8175: PPUSH
8176: LD_STRING D4-RSci1-1
8178: PPUSH
8179: CALL_OW 88
// if Gossudarov then
8183: LD_EXP 32
8187: IFFALSE 8213
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8189: LD_EXP 32
8193: PPUSH
8194: LD_STRING D4-Gos-1
8196: PPUSH
8197: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8201: LD_EXP 15
8205: PPUSH
8206: LD_STRING D4-JMM-1
8208: PPUSH
8209: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8213: LD_VAR 0 2
8217: PPUSH
8218: CALL_OW 250
8222: PPUSH
8223: LD_VAR 0 2
8227: PPUSH
8228: CALL_OW 251
8232: PPUSH
8233: LD_INT 7
8235: PPUSH
8236: CALL_OW 331
// DialogueOff ;
8240: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8244: LD_STRING M5
8246: PPUSH
8247: CALL_OW 337
// end ;
8251: PPOPN 3
8253: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8254: LD_EXP 6
8258: IFFALSE 8847
8260: GO 8262
8262: DISABLE
8263: LD_INT 0
8265: PPUSH
8266: PPUSH
8267: PPUSH
// begin PrepareBelkov ;
8268: CALL 2117 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8272: LD_EXP 47
8276: PPUSH
8277: LD_INT 118
8279: PPUSH
8280: LD_INT 106
8282: PPUSH
8283: CALL_OW 111
// AddComHold ( Belkov ) ;
8287: LD_EXP 47
8291: PPUSH
8292: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8296: LD_INT 35
8298: PPUSH
8299: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8303: LD_EXP 47
8307: PPUSH
8308: LD_INT 118
8310: PPUSH
8311: LD_INT 106
8313: PPUSH
8314: CALL_OW 307
8318: IFFALSE 8296
// ChangeSideFog ( 4 , 7 ) ;
8320: LD_INT 4
8322: PPUSH
8323: LD_INT 7
8325: PPUSH
8326: CALL_OW 343
// if IsOk ( Belkov ) then
8330: LD_EXP 47
8334: PPUSH
8335: CALL_OW 302
8339: IFFALSE 8423
// begin InGameOn ;
8341: CALL_OW 8
// DialogueOn ;
8345: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8349: LD_EXP 47
8353: PPUSH
8354: LD_STRING D5-Bel-1
8356: PPUSH
8357: CALL_OW 94
// if Gossudarov then
8361: LD_EXP 32
8365: IFFALSE 8415
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8367: LD_EXP 32
8371: PPUSH
8372: LD_STRING D5-Gos-1
8374: PPUSH
8375: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8379: LD_EXP 15
8383: PPUSH
8384: LD_STRING D5-JMM-1
8386: PPUSH
8387: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8391: LD_EXP 32
8395: PPUSH
8396: LD_STRING D5-Gos-2
8398: PPUSH
8399: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8403: LD_EXP 15
8407: PPUSH
8408: LD_STRING D5-JMM-2
8410: PPUSH
8411: CALL_OW 88
// end ; DialogueOff ;
8415: CALL_OW 7
// InGameOff ;
8419: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8423: LD_STRING QSaveBelkov
8425: PPUSH
8426: CALL_OW 97
8430: PUSH
8431: LD_INT 1
8433: DOUBLE
8434: EQUAL
8435: IFTRUE 8439
8437: GO 8489
8439: POP
// begin DialogueOn ;
8440: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8444: LD_EXP 15
8448: PPUSH
8449: LD_STRING D5a-JMM-1
8451: PPUSH
8452: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8456: LD_EXP 47
8460: PPUSH
8461: LD_STRING D5a-Bel-1
8463: PPUSH
8464: CALL_OW 94
// DialogueOff ;
8468: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8472: LD_EXP 47
8476: PPUSH
8477: LD_INT 83
8479: PPUSH
8480: LD_INT 49
8482: PPUSH
8483: CALL_OW 111
// end ; 2 :
8487: GO 8522
8489: LD_INT 2
8491: DOUBLE
8492: EQUAL
8493: IFTRUE 8497
8495: GO 8521
8497: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8498: LD_EXP 15
8502: PPUSH
8503: LD_STRING D5a-JMM-2
8505: PPUSH
8506: CALL_OW 88
// ComHold ( Belkov ) ;
8510: LD_EXP 47
8514: PPUSH
8515: CALL_OW 140
// end ; end ;
8519: GO 8522
8521: POP
// time := 0 0$00 ;
8522: LD_ADDR_VAR 0 1
8526: PUSH
8527: LD_INT 0
8529: ST_TO_ADDR
// vehSpawned := false ;
8530: LD_ADDR_VAR 0 3
8534: PUSH
8535: LD_INT 0
8537: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8538: LD_INT 35
8540: PPUSH
8541: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8545: LD_VAR 0 1
8549: PUSH
8550: LD_INT 350
8552: PUSH
8553: LD_INT 175
8555: PUSH
8556: LD_INT 70
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: LIST
8563: PUSH
8564: LD_OWVAR 67
8568: ARRAY
8569: GREATEREQUAL
8570: PUSH
8571: LD_VAR 0 3
8575: NOT
8576: AND
8577: IFFALSE 8667
// begin vehSpawned := true ;
8579: LD_ADDR_VAR 0 3
8583: PUSH
8584: LD_INT 1
8586: ST_TO_ADDR
// uc_side := 3 ;
8587: LD_ADDR_OWVAR 20
8591: PUSH
8592: LD_INT 3
8594: ST_TO_ADDR
// uc_nation := 3 ;
8595: LD_ADDR_OWVAR 21
8599: PUSH
8600: LD_INT 3
8602: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8603: LD_INT 22
8605: PPUSH
8606: LD_INT 3
8608: PPUSH
8609: LD_INT 3
8611: PPUSH
8612: LD_INT 43
8614: PPUSH
8615: LD_INT 100
8617: PPUSH
8618: CALL 19141 0 5
// veh := CreateVehicle ;
8622: LD_ADDR_VAR 0 2
8626: PUSH
8627: CALL_OW 45
8631: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8632: LD_VAR 0 2
8636: PPUSH
8637: LD_INT 130
8639: PPUSH
8640: LD_INT 131
8642: PPUSH
8643: LD_INT 0
8645: PPUSH
8646: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8650: LD_VAR 0 2
8654: PPUSH
8655: LD_INT 100
8657: PPUSH
8658: LD_INT 82
8660: PPUSH
8661: CALL_OW 114
// end else
8665: GO 8681
// time := time + 0 0$1 ;
8667: LD_ADDR_VAR 0 1
8671: PUSH
8672: LD_VAR 0 1
8676: PUSH
8677: LD_INT 35
8679: PLUS
8680: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8681: LD_EXP 47
8685: PPUSH
8686: CALL_OW 301
8690: PUSH
8691: LD_EXP 47
8695: PPUSH
8696: CALL_OW 255
8700: PUSH
8701: LD_INT 4
8703: EQUAL
8704: AND
8705: PUSH
8706: LD_INT 22
8708: PUSH
8709: LD_INT 7
8711: PUSH
8712: EMPTY
8713: LIST
8714: LIST
8715: PPUSH
8716: CALL_OW 69
8720: PPUSH
8721: LD_EXP 47
8725: PPUSH
8726: CALL_OW 74
8730: PPUSH
8731: LD_EXP 47
8735: PPUSH
8736: CALL_OW 296
8740: PUSH
8741: LD_INT 10
8743: LESS
8744: OR
8745: IFFALSE 8538
// if IsDead ( Belkov ) then
8747: LD_EXP 47
8751: PPUSH
8752: CALL_OW 301
8756: IFFALSE 8781
// begin CenterNowOnUnits ( Belkov ) ;
8758: LD_EXP 47
8762: PPUSH
8763: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8767: LD_EXP 15
8771: PPUSH
8772: LD_STRING D5a-JMM-2a
8774: PPUSH
8775: CALL_OW 88
// exit ;
8779: GO 8847
// end ; if See ( 7 , Belkov ) then
8781: LD_INT 7
8783: PPUSH
8784: LD_EXP 47
8788: PPUSH
8789: CALL_OW 292
8793: IFFALSE 8807
// SetSide ( Belkov , 7 ) ;
8795: LD_EXP 47
8799: PPUSH
8800: LD_INT 7
8802: PPUSH
8803: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8807: LD_INT 35
8809: PPUSH
8810: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8814: LD_EXP 47
8818: PPUSH
8819: LD_INT 66
8821: PPUSH
8822: LD_INT 45
8824: PPUSH
8825: CALL_OW 297
8829: PUSH
8830: LD_INT 30
8832: LESS
8833: IFFALSE 8807
// Say ( Belkov , D6-Bel-1 ) ;
8835: LD_EXP 47
8839: PPUSH
8840: LD_STRING D6-Bel-1
8842: PPUSH
8843: CALL_OW 88
// end ;
8847: PPOPN 3
8849: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8850: LD_EXP 47
8854: PPUSH
8855: CALL_OW 302
8859: PUSH
8860: LD_EXP 47
8864: PPUSH
8865: CALL_OW 504
8869: PUSH
8870: LD_INT 2
8872: PUSH
8873: LD_INT 34
8875: PUSH
8876: LD_INT 47
8878: PUSH
8879: EMPTY
8880: LIST
8881: LIST
8882: PUSH
8883: LD_INT 34
8885: PUSH
8886: LD_INT 45
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: LIST
8897: PPUSH
8898: CALL_OW 69
8902: IN
8903: AND
8904: IFFALSE 8921
8906: GO 8908
8908: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8909: LD_EXP 47
8913: PPUSH
8914: LD_STRING D7-Bel-1
8916: PPUSH
8917: CALL_OW 88
8921: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8922: LD_INT 22
8924: PUSH
8925: LD_INT 7
8927: PUSH
8928: EMPTY
8929: LIST
8930: LIST
8931: PUSH
8932: LD_INT 101
8934: PUSH
8935: LD_INT 2
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: PPUSH
8946: CALL_OW 69
8950: PUSH
8951: LD_EXP 8
8955: NOT
8956: AND
8957: PUSH
8958: LD_EXP 46
8962: PPUSH
8963: CALL_OW 305
8967: NOT
8968: AND
8969: IFFALSE 9439
8971: GO 8973
8973: DISABLE
8974: LD_INT 0
8976: PPUSH
// begin ar_base_spotted := true ;
8977: LD_ADDR_EXP 8
8981: PUSH
8982: LD_INT 1
8984: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8985: LD_ADDR_VAR 0 1
8989: PUSH
8990: LD_INT 22
8992: PUSH
8993: LD_INT 2
8995: PUSH
8996: EMPTY
8997: LIST
8998: LIST
8999: PUSH
9000: LD_INT 21
9002: PUSH
9003: LD_INT 3
9005: PUSH
9006: EMPTY
9007: LIST
9008: LIST
9009: PUSH
9010: EMPTY
9011: LIST
9012: LIST
9013: PPUSH
9014: CALL_OW 69
9018: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9019: LD_ADDR_VAR 0 1
9023: PUSH
9024: LD_VAR 0 1
9028: PPUSH
9029: LD_EXP 15
9033: PPUSH
9034: CALL_OW 74
9038: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9039: LD_INT 7
9041: PPUSH
9042: LD_INT 3
9044: PPUSH
9045: CALL_OW 332
// DialogueOn ;
9049: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9053: LD_VAR 0 1
9057: PPUSH
9058: CALL_OW 250
9062: PPUSH
9063: LD_VAR 0 1
9067: PPUSH
9068: CALL_OW 251
9072: PPUSH
9073: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9077: LD_ADDR_VAR 0 1
9081: PUSH
9082: LD_INT 22
9084: PUSH
9085: LD_INT 7
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 23
9094: PUSH
9095: LD_INT 1
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: LD_INT 26
9104: PUSH
9105: LD_INT 1
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PUSH
9112: EMPTY
9113: LIST
9114: LIST
9115: LIST
9116: PPUSH
9117: CALL_OW 69
9121: PUSH
9122: LD_EXP 15
9126: PUSH
9127: LD_EXP 19
9131: PUSH
9132: LD_EXP 20
9136: PUSH
9137: LD_EXP 27
9141: PUSH
9142: LD_EXP 16
9146: PUSH
9147: LD_EXP 25
9151: PUSH
9152: LD_EXP 21
9156: PUSH
9157: LD_EXP 23
9161: PUSH
9162: EMPTY
9163: LIST
9164: LIST
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: LIST
9171: DIFF
9172: ST_TO_ADDR
// if not tmp then
9173: LD_VAR 0 1
9177: NOT
9178: IFFALSE 9252
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9180: LD_ADDR_VAR 0 1
9184: PUSH
9185: LD_INT 22
9187: PUSH
9188: LD_INT 7
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: PUSH
9195: LD_INT 23
9197: PUSH
9198: LD_INT 1
9200: PUSH
9201: EMPTY
9202: LIST
9203: LIST
9204: PUSH
9205: LD_INT 26
9207: PUSH
9208: LD_INT 2
9210: PUSH
9211: EMPTY
9212: LIST
9213: LIST
9214: PUSH
9215: EMPTY
9216: LIST
9217: LIST
9218: LIST
9219: PPUSH
9220: CALL_OW 69
9224: PUSH
9225: LD_EXP 30
9229: PUSH
9230: LD_EXP 17
9234: PUSH
9235: LD_EXP 28
9239: PUSH
9240: LD_EXP 29
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: LIST
9249: LIST
9250: DIFF
9251: ST_TO_ADDR
// if tmp then
9252: LD_VAR 0 1
9256: IFFALSE 9327
// case GetSex ( tmp [ 1 ] ) of sex_male :
9258: LD_VAR 0 1
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: CALL_OW 258
9271: PUSH
9272: LD_INT 1
9274: DOUBLE
9275: EQUAL
9276: IFTRUE 9280
9278: GO 9299
9280: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9281: LD_VAR 0 1
9285: PUSH
9286: LD_INT 1
9288: ARRAY
9289: PPUSH
9290: LD_STRING D9-Sol1-1
9292: PPUSH
9293: CALL_OW 88
9297: GO 9327
9299: LD_INT 2
9301: DOUBLE
9302: EQUAL
9303: IFTRUE 9307
9305: GO 9326
9307: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9308: LD_VAR 0 1
9312: PUSH
9313: LD_INT 1
9315: ARRAY
9316: PPUSH
9317: LD_STRING D9-FSol1-1
9319: PPUSH
9320: CALL_OW 88
9324: GO 9327
9326: POP
// if Frank then
9327: LD_EXP 27
9331: IFFALSE 9435
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9333: LD_EXP 56
9337: PPUSH
9338: CALL_OW 250
9342: PPUSH
9343: LD_EXP 56
9347: PPUSH
9348: CALL_OW 251
9352: PPUSH
9353: LD_INT 7
9355: PPUSH
9356: LD_INT 8
9358: PPUSH
9359: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9363: LD_EXP 56
9367: PPUSH
9368: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9372: LD_EXP 27
9376: PPUSH
9377: LD_STRING D9-Frank-1
9379: PPUSH
9380: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9384: LD_EXP 15
9388: PPUSH
9389: LD_STRING D9-JMM-1
9391: PPUSH
9392: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9396: LD_EXP 27
9400: PPUSH
9401: LD_STRING D9-Frank-2
9403: PPUSH
9404: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9408: LD_EXP 56
9412: PPUSH
9413: CALL_OW 250
9417: PPUSH
9418: LD_EXP 56
9422: PPUSH
9423: CALL_OW 251
9427: PPUSH
9428: LD_INT 7
9430: PPUSH
9431: CALL_OW 331
// end ; DialogueOff ;
9435: CALL_OW 7
// end ;
9439: PPOPN 1
9441: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9442: LD_EXP 7
9446: PUSH
9447: LD_OWVAR 1
9451: PUSH
9452: LD_INT 42000
9454: GREATEREQUAL
9455: OR
9456: IFFALSE 10483
9458: GO 9460
9460: DISABLE
9461: LD_INT 0
9463: PPUSH
9464: PPUSH
// begin selected_option := 1 ;
9465: LD_ADDR_VAR 0 2
9469: PUSH
9470: LD_INT 1
9472: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9473: LD_INT 10500
9475: PPUSH
9476: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9480: LD_INT 35
9482: PPUSH
9483: CALL_OW 67
// until not ru_attackers ;
9487: LD_EXP 52
9491: NOT
9492: IFFALSE 9480
// PrepareBurlak ;
9494: CALL 2229 0 0
// repeat wait ( 0 0$2 ) ;
9498: LD_INT 70
9500: PPUSH
9501: CALL_OW 67
// until not HasTask ( Burlak ) ;
9505: LD_EXP 46
9509: PPUSH
9510: CALL_OW 314
9514: NOT
9515: IFFALSE 9498
// InGameOn ;
9517: CALL_OW 8
// DialogueOn ;
9521: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9525: LD_EXP 49
9529: PPUSH
9530: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9534: LD_EXP 46
9538: PPUSH
9539: LD_STRING D10-Bur-1
9541: PPUSH
9542: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9546: LD_EXP 47
9550: PUSH
9551: LD_EXP 47
9555: PPUSH
9556: CALL_OW 255
9560: PUSH
9561: LD_INT 7
9563: EQUAL
9564: AND
9565: IFFALSE 9579
// Say ( Belkov , D10-Bel-1 ) ;
9567: LD_EXP 47
9571: PPUSH
9572: LD_STRING D10-Bel-1
9574: PPUSH
9575: CALL_OW 88
// if Gossudarov then
9579: LD_EXP 32
9583: IFFALSE 9597
// Say ( Gossudarov , D10-Gos-1 ) ;
9585: LD_EXP 32
9589: PPUSH
9590: LD_STRING D10-Gos-1
9592: PPUSH
9593: CALL_OW 88
// if Kirilenkova then
9597: LD_EXP 33
9601: IFFALSE 9615
// Say ( Kirilenkova , D10-Kir-1 ) ;
9603: LD_EXP 33
9607: PPUSH
9608: LD_STRING D10-Kir-1
9610: PPUSH
9611: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9615: CALL 12891 0 0
9619: PPUSH
9620: LD_STRING D10-RSol1-1
9622: PPUSH
9623: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9627: LD_EXP 46
9631: PPUSH
9632: LD_STRING D10-Bur-2
9634: PPUSH
9635: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9639: LD_EXP 15
9643: PPUSH
9644: LD_STRING D10-JMM-2
9646: PPUSH
9647: CALL_OW 88
// if Kirilenkova then
9651: LD_EXP 33
9655: IFFALSE 9671
// Say ( Kirilenkova , D10-Kir-2 ) else
9657: LD_EXP 33
9661: PPUSH
9662: LD_STRING D10-Kir-2
9664: PPUSH
9665: CALL_OW 88
9669: GO 9683
// Say ( SolRu , D10-RSol1-2 ) ;
9671: CALL 12891 0 0
9675: PPUSH
9676: LD_STRING D10-RSol1-2
9678: PPUSH
9679: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9683: LD_EXP 15
9687: PPUSH
9688: LD_STRING D10-JMM-3
9690: PPUSH
9691: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9695: LD_EXP 46
9699: PPUSH
9700: LD_STRING D10-Bur-3
9702: PPUSH
9703: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9707: LD_EXP 15
9711: PPUSH
9712: LD_STRING D10-JMM-4
9714: PPUSH
9715: CALL_OW 88
// DialogueOff ;
9719: CALL_OW 7
// InGameOff ;
9723: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9727: LD_STRING M2
9729: PPUSH
9730: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9734: LD_INT 35
9736: PPUSH
9737: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9741: LD_INT 22
9743: PUSH
9744: LD_INT 7
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: PUSH
9751: LD_INT 91
9753: PUSH
9754: LD_EXP 46
9758: PUSH
9759: LD_INT 8
9761: PUSH
9762: EMPTY
9763: LIST
9764: LIST
9765: LIST
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: PPUSH
9771: CALL_OW 69
9775: IFFALSE 9734
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9777: LD_ADDR_VAR 0 1
9781: PUSH
9782: LD_INT 22
9784: PUSH
9785: LD_INT 4
9787: PUSH
9788: EMPTY
9789: LIST
9790: LIST
9791: PPUSH
9792: CALL_OW 69
9796: PUSH
9797: FOR_IN
9798: IFFALSE 9814
// SetSide ( i , 7 ) ;
9800: LD_VAR 0 1
9804: PPUSH
9805: LD_INT 7
9807: PPUSH
9808: CALL_OW 235
9812: GO 9797
9814: POP
9815: POP
// ChangeMissionObjectives ( M3 ) ;
9816: LD_STRING M3
9818: PPUSH
9819: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9823: LD_INT 35
9825: PPUSH
9826: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9830: LD_EXP 15
9834: PPUSH
9835: LD_EXP 46
9839: PPUSH
9840: CALL_OW 296
9844: PUSH
9845: LD_INT 8
9847: LESS
9848: IFFALSE 9823
// ComTurnUnit ( JMM , Burlak ) ;
9850: LD_EXP 15
9854: PPUSH
9855: LD_EXP 46
9859: PPUSH
9860: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9864: LD_EXP 46
9868: PPUSH
9869: LD_EXP 15
9873: PPUSH
9874: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9878: LD_INT 10
9880: PPUSH
9881: CALL_OW 67
// DialogueOn ;
9885: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9889: LD_EXP 15
9893: PPUSH
9894: LD_STRING D11-JMM-1
9896: PPUSH
9897: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9901: LD_EXP 46
9905: PPUSH
9906: LD_STRING D11-Bur-1
9908: PPUSH
9909: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9913: LD_EXP 15
9917: PPUSH
9918: LD_STRING D11-JMM-2
9920: PPUSH
9921: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9925: LD_EXP 46
9929: PPUSH
9930: LD_STRING D11-Bur-2
9932: PPUSH
9933: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9937: LD_EXP 15
9941: PPUSH
9942: LD_STRING D11-JMM-3
9944: PPUSH
9945: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9949: LD_EXP 46
9953: PPUSH
9954: LD_STRING D11-Bur-3
9956: PPUSH
9957: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9961: LD_EXP 15
9965: PPUSH
9966: LD_STRING D11-JMM-4
9968: PPUSH
9969: CALL_OW 88
// if ar_base_spotted then
9973: LD_EXP 8
9977: IFFALSE 9993
// Say ( Burlak , D12-Bur-1 ) else
9979: LD_EXP 46
9983: PPUSH
9984: LD_STRING D12-Bur-1
9986: PPUSH
9987: CALL_OW 88
9991: GO 10032
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9993: LD_INT 7
9995: PPUSH
9996: LD_INT 3
9998: PPUSH
9999: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10003: LD_INT 127
10005: PPUSH
10006: LD_INT 45
10008: PPUSH
10009: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10013: LD_EXP 46
10017: PPUSH
10018: LD_STRING D12-Bur-1a
10020: PPUSH
10021: CALL_OW 88
// dwait ( 0 0$2 ) ;
10025: LD_INT 70
10027: PPUSH
10028: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10032: LD_EXP 46
10036: PPUSH
10037: LD_STRING D12-Bur-1b
10039: PPUSH
10040: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10044: LD_EXP 15
10048: PPUSH
10049: LD_STRING D12-JMM-1
10051: PPUSH
10052: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10056: LD_EXP 46
10060: PPUSH
10061: LD_STRING D12-Bur-2
10063: PPUSH
10064: CALL_OW 88
// if Roth then
10068: LD_EXP 16
10072: IFFALSE 10088
// Say ( Roth , D12-Roth-2 ) else
10074: LD_EXP 16
10078: PPUSH
10079: LD_STRING D12-Roth-2
10081: PPUSH
10082: CALL_OW 88
10086: GO 10100
// Say ( SciRu , D12-RSci1-2 ) ;
10088: CALL 12744 0 0
10092: PPUSH
10093: LD_STRING D12-RSci1-2
10095: PPUSH
10096: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10100: LD_EXP 15
10104: PPUSH
10105: LD_STRING D12-JMM-2
10107: PPUSH
10108: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10112: LD_EXP 46
10116: PPUSH
10117: LD_STRING D12-Bur-3
10119: PPUSH
10120: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10124: LD_EXP 15
10128: PPUSH
10129: LD_STRING D12-JMM-3
10131: PPUSH
10132: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10136: LD_EXP 46
10140: PPUSH
10141: LD_STRING D12-Bur-4
10143: PPUSH
10144: CALL_OW 88
// case Query ( QBase ) of 1 :
10148: LD_STRING QBase
10150: PPUSH
10151: CALL_OW 97
10155: PUSH
10156: LD_INT 1
10158: DOUBLE
10159: EQUAL
10160: IFTRUE 10164
10162: GO 10282
10164: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10165: LD_EXP 15
10169: PPUSH
10170: LD_STRING D13a-JMM-1
10172: PPUSH
10173: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10177: LD_EXP 46
10181: PPUSH
10182: LD_STRING D13a-Bur-1
10184: PPUSH
10185: CALL_OW 88
// if Roth then
10189: LD_EXP 16
10193: IFFALSE 10209
// Say ( Roth , D13a-Roth-1 ) else
10195: LD_EXP 16
10199: PPUSH
10200: LD_STRING D13a-Roth-1
10202: PPUSH
10203: CALL_OW 88
10207: GO 10221
// Say ( SciRu , D13a-RSci1-1 ) ;
10209: CALL 12744 0 0
10213: PPUSH
10214: LD_STRING D13a-RSci1-1
10216: PPUSH
10217: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10221: LD_EXP 15
10225: PPUSH
10226: LD_STRING D13a-JMM-2
10228: PPUSH
10229: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10233: LD_STRING QBaseAgain
10235: PPUSH
10236: CALL_OW 97
10240: PUSH
10241: LD_INT 1
10243: DOUBLE
10244: EQUAL
10245: IFTRUE 10249
10247: GO 10260
10249: POP
// selected_option := 2 ; 2 :
10250: LD_ADDR_VAR 0 2
10254: PUSH
10255: LD_INT 2
10257: ST_TO_ADDR
10258: GO 10280
10260: LD_INT 2
10262: DOUBLE
10263: EQUAL
10264: IFTRUE 10268
10266: GO 10279
10268: POP
// selected_option := 3 ; end ;
10269: LD_ADDR_VAR 0 2
10273: PUSH
10274: LD_INT 3
10276: ST_TO_ADDR
10277: GO 10280
10279: POP
// end ; 2 :
10280: GO 10321
10282: LD_INT 2
10284: DOUBLE
10285: EQUAL
10286: IFTRUE 10290
10288: GO 10301
10290: POP
// selected_option := 2 ; 3 :
10291: LD_ADDR_VAR 0 2
10295: PUSH
10296: LD_INT 2
10298: ST_TO_ADDR
10299: GO 10321
10301: LD_INT 3
10303: DOUBLE
10304: EQUAL
10305: IFTRUE 10309
10307: GO 10320
10309: POP
// selected_option := 3 ; end ;
10310: LD_ADDR_VAR 0 2
10314: PUSH
10315: LD_INT 3
10317: ST_TO_ADDR
10318: GO 10321
10320: POP
// if selected_option = 2 then
10321: LD_VAR 0 2
10325: PUSH
10326: LD_INT 2
10328: EQUAL
10329: IFFALSE 10423
// begin Say ( JMM , D13b-JMM-1 ) ;
10331: LD_EXP 15
10335: PPUSH
10336: LD_STRING D13b-JMM-1
10338: PPUSH
10339: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10343: LD_EXP 46
10347: PPUSH
10348: LD_STRING D13b-Bur-1
10350: PPUSH
10351: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10355: LD_EXP 15
10359: PPUSH
10360: LD_STRING D13b-JMM-2
10362: PPUSH
10363: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10367: LD_EXP 55
10371: PPUSH
10372: LD_STRING D13b-Abd-2
10374: PPUSH
10375: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10379: LD_EXP 15
10383: PPUSH
10384: LD_STRING D13b-JMM-3
10386: PPUSH
10387: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10391: LD_EXP 55
10395: PPUSH
10396: LD_STRING D13b-Abd-3
10398: PPUSH
10399: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10403: LD_EXP 15
10407: PPUSH
10408: LD_STRING D13b-JMM-4
10410: PPUSH
10411: CALL_OW 88
// ar_active_attack := true ;
10415: LD_ADDR_EXP 9
10419: PUSH
10420: LD_INT 1
10422: ST_TO_ADDR
// end ; if selected_option = 3 then
10423: LD_VAR 0 2
10427: PUSH
10428: LD_INT 3
10430: EQUAL
10431: IFFALSE 10457
// begin Say ( JMM , D13c-JMM-1 ) ;
10433: LD_EXP 15
10437: PPUSH
10438: LD_STRING D13c-JMM-1
10440: PPUSH
10441: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10445: LD_EXP 46
10449: PPUSH
10450: LD_STRING D13c-Bur-1
10452: PPUSH
10453: CALL_OW 88
// end ; DialogueOff ;
10457: CALL_OW 7
// if not ar_active_attack then
10461: LD_EXP 9
10465: NOT
10466: IFFALSE 10483
// begin wait ( 6 6$00 ) ;
10468: LD_INT 12600
10470: PPUSH
10471: CALL_OW 67
// ar_active_attack := true ;
10475: LD_ADDR_EXP 9
10479: PUSH
10480: LD_INT 1
10482: ST_TO_ADDR
// end ; end ;
10483: PPOPN 2
10485: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10486: LD_EXP 46
10490: PPUSH
10491: CALL_OW 305
10495: PUSH
10496: LD_EXP 46
10500: PPUSH
10501: CALL_OW 255
10505: PUSH
10506: LD_INT 7
10508: EQUAL
10509: AND
10510: IFFALSE 10706
10512: GO 10514
10514: DISABLE
10515: LD_INT 0
10517: PPUSH
// begin wait ( 4 4$40 ) ;
10518: LD_INT 9800
10520: PPUSH
10521: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10525: LD_INT 35
10527: PPUSH
10528: CALL_OW 67
// until not ru_attackers ;
10532: LD_EXP 52
10536: NOT
10537: IFFALSE 10525
// PrepareGnyevko ;
10539: CALL 2173 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10543: LD_EXP 48
10547: PPUSH
10548: LD_INT 124
10550: PPUSH
10551: LD_INT 118
10553: PPUSH
10554: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10558: LD_EXP 48
10562: PPUSH
10563: CALL_OW 200
// time := 0 0$00 ;
10567: LD_ADDR_VAR 0 1
10571: PUSH
10572: LD_INT 0
10574: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10575: LD_INT 35
10577: PPUSH
10578: CALL_OW 67
// time := time + 0 0$1 ;
10582: LD_ADDR_VAR 0 1
10586: PUSH
10587: LD_VAR 0 1
10591: PUSH
10592: LD_INT 35
10594: PLUS
10595: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10596: LD_EXP 48
10600: PPUSH
10601: LD_INT 124
10603: PPUSH
10604: LD_INT 118
10606: PPUSH
10607: CALL_OW 307
10611: PUSH
10612: LD_VAR 0 1
10616: PUSH
10617: LD_INT 1050
10619: GREATEREQUAL
10620: OR
10621: IFFALSE 10575
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10623: LD_EXP 48
10627: PPUSH
10628: LD_STRING DBelkov-Gny-1
10630: PPUSH
10631: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10635: LD_EXP 46
10639: PPUSH
10640: LD_STRING DBelkov-Bur-1a
10642: PPUSH
10643: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10647: LD_INT 35
10649: PPUSH
10650: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10654: LD_EXP 48
10658: PPUSH
10659: LD_INT 22
10661: PUSH
10662: LD_INT 7
10664: PUSH
10665: EMPTY
10666: LIST
10667: LIST
10668: PPUSH
10669: CALL_OW 69
10673: PPUSH
10674: LD_EXP 48
10678: PPUSH
10679: CALL_OW 74
10683: PPUSH
10684: CALL_OW 296
10688: PUSH
10689: LD_INT 8
10691: LESS
10692: IFFALSE 10647
// SetSide ( Gnyevko , 7 ) ;
10694: LD_EXP 48
10698: PPUSH
10699: LD_INT 7
10701: PPUSH
10702: CALL_OW 235
// end ;
10706: PPOPN 1
10708: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10709: LD_EXP 46
10713: PPUSH
10714: CALL_OW 255
10718: PUSH
10719: LD_INT 7
10721: EQUAL
10722: IFFALSE 10732
10724: GO 10726
10726: DISABLE
// begin enable ;
10727: ENABLE
// PrepareAmericanAttack ;
10728: CALL 6548 0 0
// end ;
10732: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10733: LD_INT 22
10735: PUSH
10736: LD_INT 1
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: CALL_OW 69
10747: IFFALSE 10931
10749: GO 10751
10751: DISABLE
10752: LD_INT 0
10754: PPUSH
10755: PPUSH
// begin while true do
10756: LD_INT 1
10758: IFFALSE 10815
// begin wait ( 0 0$1 ) ;
10760: LD_INT 35
10762: PPUSH
10763: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10767: LD_ADDR_VAR 0 2
10771: PUSH
10772: LD_INT 22
10774: PUSH
10775: LD_INT 1
10777: PUSH
10778: EMPTY
10779: LIST
10780: LIST
10781: PPUSH
10782: CALL_OW 69
10786: PPUSH
10787: LD_EXP 15
10791: PPUSH
10792: CALL_OW 74
10796: ST_TO_ADDR
// if See ( 7 , tmp ) then
10797: LD_INT 7
10799: PPUSH
10800: LD_VAR 0 2
10804: PPUSH
10805: CALL_OW 292
10809: IFFALSE 10813
// break ;
10811: GO 10815
// end ;
10813: GO 10756
// DialogueOn ;
10815: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10819: LD_VAR 0 2
10823: PPUSH
10824: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10828: LD_VAR 0 2
10832: PPUSH
10833: CALL_OW 250
10837: PPUSH
10838: LD_VAR 0 2
10842: PPUSH
10843: CALL_OW 251
10847: PPUSH
10848: LD_INT 7
10850: PPUSH
10851: LD_INT 8
10853: PPUSH
10854: CALL_OW 330
// if Denis then
10858: LD_EXP 21
10862: IFFALSE 10876
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10864: LD_EXP 21
10868: PPUSH
10869: LD_STRING DAmerAttack-Pet-1
10871: PPUSH
10872: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10876: LD_EXP 15
10880: PPUSH
10881: LD_STRING DAmerAttack-JMM-1
10883: PPUSH
10884: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10888: LD_EXP 46
10892: PPUSH
10893: LD_STRING DStop-Bur-1
10895: PPUSH
10896: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10900: LD_VAR 0 2
10904: PPUSH
10905: CALL_OW 250
10909: PPUSH
10910: LD_VAR 0 2
10914: PPUSH
10915: CALL_OW 251
10919: PPUSH
10920: LD_INT 7
10922: PPUSH
10923: CALL_OW 331
// DialogueOff ;
10927: CALL_OW 7
// end ;
10931: PPOPN 2
10933: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10934: LD_INT 22
10936: PUSH
10937: LD_INT 3
10939: PUSH
10940: EMPTY
10941: LIST
10942: LIST
10943: PUSH
10944: LD_INT 21
10946: PUSH
10947: LD_INT 1
10949: PUSH
10950: EMPTY
10951: LIST
10952: LIST
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PPUSH
10958: CALL_OW 69
10962: PUSH
10963: LD_INT 0
10965: EQUAL
10966: IFFALSE 11008
10968: GO 10970
10970: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10971: LD_STRING M5a
10973: PPUSH
10974: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10978: LD_EXP 15
10982: PPUSH
10983: LD_STRING D8-JMM-1
10985: PPUSH
10986: CALL_OW 88
// if Gossudarov then
10990: LD_EXP 32
10994: IFFALSE 11008
// Say ( Gossudarov , D8-Gos-1 ) ;
10996: LD_EXP 32
11000: PPUSH
11001: LD_STRING D8-Gos-1
11003: PPUSH
11004: CALL_OW 88
// end ;
11008: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11009: LD_INT 22
11011: PUSH
11012: LD_INT 2
11014: PUSH
11015: EMPTY
11016: LIST
11017: LIST
11018: PUSH
11019: LD_INT 21
11021: PUSH
11022: LD_INT 1
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: PUSH
11029: EMPTY
11030: LIST
11031: LIST
11032: PPUSH
11033: CALL_OW 69
11037: PUSH
11038: LD_INT 0
11040: EQUAL
11041: IFFALSE 11091
11043: GO 11045
11045: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11046: LD_STRING M4c
11048: PPUSH
11049: CALL_OW 337
// if Roth then
11053: LD_EXP 16
11057: IFFALSE 11073
// Say ( Roth , DStop-Roth-1 ) else
11059: LD_EXP 16
11063: PPUSH
11064: LD_STRING DStop-Roth-1
11066: PPUSH
11067: CALL_OW 88
11071: GO 11091
// if Gossudarov then
11073: LD_EXP 32
11077: IFFALSE 11091
// Say ( Gossudarov , D8-Gos-1a ) ;
11079: LD_EXP 32
11083: PPUSH
11084: LD_STRING D8-Gos-1a
11086: PPUSH
11087: CALL_OW 88
// end ;
11091: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11092: LD_INT 7
11094: PPUSH
11095: LD_INT 1
11097: PPUSH
11098: LD_INT 1
11100: PPUSH
11101: CALL 14380 0 3
11105: PUSH
11106: LD_INT 0
11108: EQUAL
11109: PUSH
11110: LD_INT 7
11112: PPUSH
11113: LD_INT 3
11115: PPUSH
11116: LD_INT 1
11118: PPUSH
11119: CALL 14380 0 3
11123: PUSH
11124: LD_INT 0
11126: EQUAL
11127: AND
11128: IFFALSE 11140
11130: GO 11132
11132: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11133: LD_STRING M1a
11135: PPUSH
11136: CALL_OW 337
// end ;
11140: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11141: LD_INT 22
11143: PUSH
11144: LD_INT 2
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: PUSH
11151: LD_INT 21
11153: PUSH
11154: LD_INT 1
11156: PUSH
11157: EMPTY
11158: LIST
11159: LIST
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PPUSH
11165: CALL_OW 69
11169: PUSH
11170: LD_INT 0
11172: EQUAL
11173: PUSH
11174: LD_INT 22
11176: PUSH
11177: LD_INT 3
11179: PUSH
11180: EMPTY
11181: LIST
11182: LIST
11183: PUSH
11184: LD_INT 21
11186: PUSH
11187: LD_INT 1
11189: PUSH
11190: EMPTY
11191: LIST
11192: LIST
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PPUSH
11198: CALL_OW 69
11202: PUSH
11203: LD_INT 0
11205: EQUAL
11206: AND
11207: PUSH
11208: LD_INT 22
11210: PUSH
11211: LD_INT 1
11213: PUSH
11214: EMPTY
11215: LIST
11216: LIST
11217: PPUSH
11218: CALL_OW 69
11222: PUSH
11223: LD_INT 0
11225: EQUAL
11226: AND
11227: PUSH
11228: LD_INT 7
11230: PPUSH
11231: LD_INT 1
11233: PPUSH
11234: LD_INT 1
11236: PPUSH
11237: CALL 14380 0 3
11241: PUSH
11242: LD_INT 0
11244: EQUAL
11245: AND
11246: PUSH
11247: LD_INT 7
11249: PPUSH
11250: LD_INT 3
11252: PPUSH
11253: LD_INT 1
11255: PPUSH
11256: CALL 14380 0 3
11260: PUSH
11261: LD_INT 0
11263: EQUAL
11264: AND
11265: IFFALSE 12741
11267: GO 11269
11269: DISABLE
11270: LD_INT 0
11272: PPUSH
11273: PPUSH
11274: PPUSH
11275: PPUSH
11276: PPUSH
11277: PPUSH
// begin m1 := false ;
11278: LD_ADDR_VAR 0 4
11282: PUSH
11283: LD_INT 0
11285: ST_TO_ADDR
// m2 := false ;
11286: LD_ADDR_VAR 0 5
11290: PUSH
11291: LD_INT 0
11293: ST_TO_ADDR
// m3 := false ;
11294: LD_ADDR_VAR 0 6
11298: PUSH
11299: LD_INT 0
11301: ST_TO_ADDR
// if tick < 40 40$00 then
11302: LD_OWVAR 1
11306: PUSH
11307: LD_INT 84000
11309: LESS
11310: IFFALSE 11319
// SetAchievement ( ACH_ASPEED_17 ) ;
11312: LD_STRING ACH_ASPEED_17
11314: PPUSH
11315: CALL_OW 543
// wait ( 0 0$1 ) ;
11319: LD_INT 35
11321: PPUSH
11322: CALL_OW 67
// if not IsDead ( Masha ) then
11326: LD_EXP 49
11330: PPUSH
11331: CALL_OW 301
11335: NOT
11336: IFFALSE 11358
// begin m1 := true ;
11338: LD_ADDR_VAR 0 4
11342: PUSH
11343: LD_INT 1
11345: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11346: LD_STRING Masha
11348: PPUSH
11349: LD_INT 1
11351: PPUSH
11352: CALL_OW 101
// end else
11356: GO 11369
// AddMedal ( Masha , - 1 ) ;
11358: LD_STRING Masha
11360: PPUSH
11361: LD_INT 1
11363: NEG
11364: PPUSH
11365: CALL_OW 101
// if abdul_escaped then
11369: LD_EXP 12
11373: IFFALSE 11388
// AddMedal ( Abdul , - 1 ) else
11375: LD_STRING Abdul
11377: PPUSH
11378: LD_INT 1
11380: NEG
11381: PPUSH
11382: CALL_OW 101
11386: GO 11406
// begin m2 := true ;
11388: LD_ADDR_VAR 0 5
11392: PUSH
11393: LD_INT 1
11395: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11396: LD_STRING Abdul
11398: PPUSH
11399: LD_INT 1
11401: PPUSH
11402: CALL_OW 101
// end ; if loss_counter = 0 then
11406: LD_EXP 13
11410: PUSH
11411: LD_INT 0
11413: EQUAL
11414: IFFALSE 11436
// begin m3 := true ;
11416: LD_ADDR_VAR 0 6
11420: PUSH
11421: LD_INT 1
11423: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11424: LD_STRING People
11426: PPUSH
11427: LD_INT 2
11429: PPUSH
11430: CALL_OW 101
// end else
11434: GO 11494
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11436: LD_EXP 13
11440: PUSH
11441: LD_INT 3
11443: PUSH
11444: LD_INT 2
11446: PUSH
11447: LD_INT 2
11449: PUSH
11450: EMPTY
11451: LIST
11452: LIST
11453: LIST
11454: PUSH
11455: LD_OWVAR 67
11459: ARRAY
11460: LESSEQUAL
11461: IFFALSE 11483
// begin AddMedal ( People , 1 ) ;
11463: LD_STRING People
11465: PPUSH
11466: LD_INT 1
11468: PPUSH
11469: CALL_OW 101
// m3 := true ;
11473: LD_ADDR_VAR 0 6
11477: PUSH
11478: LD_INT 1
11480: ST_TO_ADDR
// end else
11481: GO 11494
// AddMedal ( People , - 1 ) ;
11483: LD_STRING People
11485: PPUSH
11486: LD_INT 1
11488: NEG
11489: PPUSH
11490: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11494: LD_OWVAR 67
11498: PUSH
11499: LD_INT 3
11501: EQUAL
11502: PUSH
11503: LD_VAR 0 4
11507: AND
11508: PUSH
11509: LD_VAR 0 5
11513: AND
11514: PUSH
11515: LD_VAR 0 6
11519: AND
11520: IFFALSE 11532
// SetAchievementEX ( ACH_AMER , 17 ) ;
11522: LD_STRING ACH_AMER
11524: PPUSH
11525: LD_INT 17
11527: PPUSH
11528: CALL_OW 564
// GiveMedals ( MAIN ) ;
11532: LD_STRING MAIN
11534: PPUSH
11535: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11539: LD_ADDR_VAR 0 2
11543: PUSH
11544: LD_INT 22
11546: PUSH
11547: LD_INT 7
11549: PUSH
11550: EMPTY
11551: LIST
11552: LIST
11553: PUSH
11554: LD_INT 2
11556: PUSH
11557: LD_INT 25
11559: PUSH
11560: LD_INT 1
11562: PUSH
11563: EMPTY
11564: LIST
11565: LIST
11566: PUSH
11567: LD_INT 25
11569: PUSH
11570: LD_INT 2
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: PUSH
11577: LD_INT 25
11579: PUSH
11580: LD_INT 3
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: PUSH
11587: LD_INT 25
11589: PUSH
11590: LD_INT 4
11592: PUSH
11593: EMPTY
11594: LIST
11595: LIST
11596: PUSH
11597: LD_INT 25
11599: PUSH
11600: LD_INT 5
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_INT 25
11609: PUSH
11610: LD_INT 8
11612: PUSH
11613: EMPTY
11614: LIST
11615: LIST
11616: PUSH
11617: LD_INT 25
11619: PUSH
11620: LD_INT 9
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: PUSH
11627: EMPTY
11628: LIST
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PPUSH
11641: CALL_OW 69
11645: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11646: LD_VAR 0 2
11650: PPUSH
11651: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11655: LD_ADDR_VAR 0 3
11659: PUSH
11660: LD_EXP 15
11664: PUSH
11665: LD_EXP 16
11669: PUSH
11670: LD_EXP 17
11674: PUSH
11675: LD_EXP 18
11679: PUSH
11680: LD_EXP 19
11684: PUSH
11685: LD_EXP 20
11689: PUSH
11690: LD_EXP 21
11694: PUSH
11695: LD_EXP 22
11699: PUSH
11700: LD_EXP 23
11704: PUSH
11705: LD_EXP 24
11709: PUSH
11710: LD_EXP 25
11714: PUSH
11715: LD_EXP 26
11719: PUSH
11720: LD_EXP 27
11724: PUSH
11725: LD_EXP 28
11729: PUSH
11730: LD_EXP 29
11734: PUSH
11735: LD_EXP 30
11739: PUSH
11740: LD_EXP 31
11744: PUSH
11745: LD_EXP 32
11749: PUSH
11750: LD_EXP 33
11754: PUSH
11755: LD_EXP 34
11759: PUSH
11760: LD_EXP 36
11764: PUSH
11765: LD_EXP 37
11769: PUSH
11770: LD_EXP 38
11774: PUSH
11775: LD_EXP 39
11779: PUSH
11780: LD_EXP 40
11784: PUSH
11785: LD_EXP 41
11789: PUSH
11790: LD_EXP 42
11794: PUSH
11795: LD_EXP 43
11799: PUSH
11800: LD_EXP 44
11804: PUSH
11805: LD_EXP 45
11809: PUSH
11810: LD_EXP 46
11814: PUSH
11815: LD_EXP 47
11819: PUSH
11820: LD_EXP 48
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: LIST
11835: LIST
11836: LIST
11837: LIST
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: LIST
11843: LIST
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: ST_TO_ADDR
// if tmp diff tmp2 then
11860: LD_VAR 0 2
11864: PUSH
11865: LD_VAR 0 3
11869: DIFF
11870: IFFALSE 11890
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11872: LD_VAR 0 2
11876: PUSH
11877: LD_VAR 0 3
11881: DIFF
11882: PPUSH
11883: LD_STRING 13a_others
11885: PPUSH
11886: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11890: LD_EXP 15
11894: PPUSH
11895: LD_STRING 13a_JMM
11897: PPUSH
11898: CALL_OW 38
// if Titov then
11902: LD_EXP 34
11906: IFFALSE 11920
// SaveCharacters ( Titov , 13a_Titov ) ;
11908: LD_EXP 34
11912: PPUSH
11913: LD_STRING 13a_Titov
11915: PPUSH
11916: CALL_OW 38
// if Dolgov then
11920: LD_EXP 36
11924: IFFALSE 11938
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11926: LD_EXP 36
11930: PPUSH
11931: LD_STRING 13a_Dolgov
11933: PPUSH
11934: CALL_OW 38
// if Petrosyan then
11938: LD_EXP 37
11942: IFFALSE 11956
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11944: LD_EXP 37
11948: PPUSH
11949: LD_STRING 13a_Petrosyan
11951: PPUSH
11952: CALL_OW 38
// if Scholtze then
11956: LD_EXP 38
11960: IFFALSE 11974
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11962: LD_EXP 38
11966: PPUSH
11967: LD_STRING 13a_Scholtze
11969: PPUSH
11970: CALL_OW 38
// if Oblukov then
11974: LD_EXP 39
11978: IFFALSE 11992
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11980: LD_EXP 39
11984: PPUSH
11985: LD_STRING 13a_Oblukov
11987: PPUSH
11988: CALL_OW 38
// if Kapitsova then
11992: LD_EXP 40
11996: IFFALSE 12010
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11998: LD_EXP 40
12002: PPUSH
12003: LD_STRING 13a_Kapitsova
12005: PPUSH
12006: CALL_OW 38
// if Lipshchin then
12010: LD_EXP 41
12014: IFFALSE 12028
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12016: LD_EXP 41
12020: PPUSH
12021: LD_STRING 13a_Lipshchin
12023: PPUSH
12024: CALL_OW 38
// if Petrovova then
12028: LD_EXP 42
12032: IFFALSE 12046
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12034: LD_EXP 42
12038: PPUSH
12039: LD_STRING 13a_Petrovova
12041: PPUSH
12042: CALL_OW 38
// if Kovalyuk then
12046: LD_EXP 43
12050: IFFALSE 12064
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12052: LD_EXP 43
12056: PPUSH
12057: LD_STRING 13a_Kovalyuk
12059: PPUSH
12060: CALL_OW 38
// if Kuzmov then
12064: LD_EXP 44
12068: IFFALSE 12082
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12070: LD_EXP 44
12074: PPUSH
12075: LD_STRING 13a_Kuzmov
12077: PPUSH
12078: CALL_OW 38
// if Karamazov then
12082: LD_EXP 45
12086: IFFALSE 12100
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12088: LD_EXP 45
12092: PPUSH
12093: LD_STRING 13a_Karamazov
12095: PPUSH
12096: CALL_OW 38
// if Burlak then
12100: LD_EXP 46
12104: IFFALSE 12118
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12106: LD_EXP 46
12110: PPUSH
12111: LD_STRING 13a_Burlak
12113: PPUSH
12114: CALL_OW 38
// if Belkov then
12118: LD_EXP 47
12122: IFFALSE 12136
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12124: LD_EXP 47
12128: PPUSH
12129: LD_STRING 13a_Belkov
12131: PPUSH
12132: CALL_OW 38
// if Gnyevko then
12136: LD_EXP 48
12140: IFFALSE 12154
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12142: LD_EXP 48
12146: PPUSH
12147: LD_STRING 13a_Gnyevko
12149: PPUSH
12150: CALL_OW 38
// if Lisa then
12154: LD_EXP 17
12158: IFFALSE 12172
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12160: LD_EXP 17
12164: PPUSH
12165: LD_STRING 13a_Lisa
12167: PPUSH
12168: CALL_OW 38
// if Donaldson then
12172: LD_EXP 18
12176: IFFALSE 12190
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12178: LD_EXP 18
12182: PPUSH
12183: LD_STRING 13a_Donaldson
12185: PPUSH
12186: CALL_OW 38
// if Bobby then
12190: LD_EXP 19
12194: IFFALSE 12208
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12196: LD_EXP 19
12200: PPUSH
12201: LD_STRING 13a_Bobby
12203: PPUSH
12204: CALL_OW 38
// if Cyrus then
12208: LD_EXP 20
12212: IFFALSE 12226
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12214: LD_EXP 20
12218: PPUSH
12219: LD_STRING 13a_Cyrus
12221: PPUSH
12222: CALL_OW 38
// if Denis then
12226: LD_EXP 21
12230: IFFALSE 12244
// SaveCharacters ( Denis , 13a_Denis ) ;
12232: LD_EXP 21
12236: PPUSH
12237: LD_STRING 13a_Denis
12239: PPUSH
12240: CALL_OW 38
// if Brown then
12244: LD_EXP 22
12248: IFFALSE 12262
// SaveCharacters ( Brown , 13a_Brown ) ;
12250: LD_EXP 22
12254: PPUSH
12255: LD_STRING 13a_Brown
12257: PPUSH
12258: CALL_OW 38
// if Gladstone then
12262: LD_EXP 23
12266: IFFALSE 12280
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12268: LD_EXP 23
12272: PPUSH
12273: LD_STRING 13a_Gladstone
12275: PPUSH
12276: CALL_OW 38
// if Houten then
12280: LD_EXP 24
12284: IFFALSE 12298
// SaveCharacters ( Houten , 13a_Houten ) ;
12286: LD_EXP 24
12290: PPUSH
12291: LD_STRING 13a_Houten
12293: PPUSH
12294: CALL_OW 38
// if Cornel then
12298: LD_EXP 25
12302: IFFALSE 12316
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12304: LD_EXP 25
12308: PPUSH
12309: LD_STRING 13a_Cornel
12311: PPUSH
12312: CALL_OW 38
// if Gary then
12316: LD_EXP 26
12320: IFFALSE 12334
// SaveCharacters ( Gary , 13a_Gary ) ;
12322: LD_EXP 26
12326: PPUSH
12327: LD_STRING 13a_Gary
12329: PPUSH
12330: CALL_OW 38
// if Frank then
12334: LD_EXP 27
12338: IFFALSE 12352
// SaveCharacters ( Frank , 13a_Frank ) ;
12340: LD_EXP 27
12344: PPUSH
12345: LD_STRING 13a_Frank
12347: PPUSH
12348: CALL_OW 38
// if Kikuchi then
12352: LD_EXP 28
12356: IFFALSE 12370
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12358: LD_EXP 28
12362: PPUSH
12363: LD_STRING 13a_Kikuchi
12365: PPUSH
12366: CALL_OW 38
// if Simms then
12370: LD_EXP 29
12374: IFFALSE 12388
// SaveCharacters ( Simms , 13a_Simms ) ;
12376: LD_EXP 29
12380: PPUSH
12381: LD_STRING 13a_Simms
12383: PPUSH
12384: CALL_OW 38
// if Joan then
12388: LD_EXP 30
12392: IFFALSE 12406
// SaveCharacters ( Joan , 13a_Joan ) ;
12394: LD_EXP 30
12398: PPUSH
12399: LD_STRING 13a_Joan
12401: PPUSH
12402: CALL_OW 38
// if DeltaDoctor then
12406: LD_EXP 31
12410: IFFALSE 12424
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12412: LD_EXP 31
12416: PPUSH
12417: LD_STRING 13a_DeltaDoctor
12419: PPUSH
12420: CALL_OW 38
// if Gossudarov then
12424: LD_EXP 32
12428: IFFALSE 12442
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12430: LD_EXP 32
12434: PPUSH
12435: LD_STRING 13a_Gossudarov
12437: PPUSH
12438: CALL_OW 38
// if Kirilenkova then
12442: LD_EXP 33
12446: IFFALSE 12460
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12448: LD_EXP 33
12452: PPUSH
12453: LD_STRING 13a_Kirilenkova
12455: PPUSH
12456: CALL_OW 38
// if Roth then
12460: LD_EXP 16
12464: IFFALSE 12478
// SaveCharacters ( Roth , 13a_Roth ) ;
12466: LD_EXP 16
12470: PPUSH
12471: LD_STRING 13a_Roth
12473: PPUSH
12474: CALL_OW 38
// if Masha then
12478: LD_EXP 49
12482: IFFALSE 12537
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12484: LD_EXP 49
12488: PPUSH
12489: CALL_OW 265
12493: PUSH
12494: LD_EXP 49
12498: PPUSH
12499: CALL_OW 262
12503: PUSH
12504: LD_EXP 49
12508: PPUSH
12509: CALL_OW 263
12513: PUSH
12514: LD_EXP 49
12518: PPUSH
12519: CALL_OW 264
12523: PUSH
12524: EMPTY
12525: LIST
12526: LIST
12527: LIST
12528: LIST
12529: PPUSH
12530: LD_STRING 13a_Masha
12532: PPUSH
12533: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12537: LD_ADDR_VAR 0 2
12541: PUSH
12542: LD_INT 21
12544: PUSH
12545: LD_INT 3
12547: PUSH
12548: EMPTY
12549: LIST
12550: LIST
12551: PPUSH
12552: CALL_OW 69
12556: ST_TO_ADDR
// tmp2 := [ ] ;
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: EMPTY
12563: ST_TO_ADDR
// if tmp then
12564: LD_VAR 0 2
12568: IFFALSE 12719
// for i in tmp do
12570: LD_ADDR_VAR 0 1
12574: PUSH
12575: LD_VAR 0 2
12579: PUSH
12580: FOR_IN
12581: IFFALSE 12717
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12583: LD_ADDR_VAR 0 3
12587: PUSH
12588: LD_VAR 0 3
12592: PUSH
12593: LD_VAR 0 1
12597: PPUSH
12598: CALL_OW 255
12602: PUSH
12603: LD_VAR 0 1
12607: PPUSH
12608: CALL_OW 248
12612: PUSH
12613: LD_VAR 0 1
12617: PPUSH
12618: CALL_OW 266
12622: PUSH
12623: LD_VAR 0 1
12627: PPUSH
12628: CALL_OW 250
12632: PUSH
12633: LD_VAR 0 1
12637: PPUSH
12638: CALL_OW 251
12642: PUSH
12643: LD_VAR 0 1
12647: PPUSH
12648: CALL_OW 254
12652: PUSH
12653: LD_VAR 0 1
12657: PPUSH
12658: CALL_OW 267
12662: PUSH
12663: LD_VAR 0 1
12667: PPUSH
12668: LD_INT 1
12670: PPUSH
12671: CALL_OW 268
12675: PUSH
12676: LD_VAR 0 1
12680: PPUSH
12681: LD_INT 2
12683: PPUSH
12684: CALL_OW 268
12688: PUSH
12689: LD_VAR 0 1
12693: PPUSH
12694: CALL_OW 269
12698: PUSH
12699: EMPTY
12700: LIST
12701: LIST
12702: LIST
12703: LIST
12704: LIST
12705: LIST
12706: LIST
12707: LIST
12708: LIST
12709: LIST
12710: PUSH
12711: EMPTY
12712: LIST
12713: ADD
12714: ST_TO_ADDR
12715: GO 12580
12717: POP
12718: POP
// if tmp2 then
12719: LD_VAR 0 3
12723: IFFALSE 12737
// SaveVariable ( tmp2 , 13a_buildings ) ;
12725: LD_VAR 0 3
12729: PPUSH
12730: LD_STRING 13a_buildings
12732: PPUSH
12733: CALL_OW 39
// YouWin ;
12737: CALL_OW 103
// end ;
12741: PPOPN 6
12743: END
// export function SciRu ; var tmp , t ; begin
12744: LD_INT 0
12746: PPUSH
12747: PPUSH
12748: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12749: LD_ADDR_VAR 0 3
12753: PUSH
12754: LD_EXP 32
12758: PUSH
12759: LD_EXP 46
12763: PUSH
12764: LD_EXP 34
12768: PUSH
12769: LD_EXP 47
12773: PUSH
12774: LD_EXP 48
12778: PUSH
12779: LD_EXP 37
12783: PUSH
12784: LD_EXP 38
12788: PUSH
12789: LD_EXP 36
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12804: LD_ADDR_VAR 0 2
12808: PUSH
12809: LD_INT 22
12811: PUSH
12812: LD_INT 7
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PUSH
12819: LD_INT 23
12821: PUSH
12822: LD_INT 3
12824: PUSH
12825: EMPTY
12826: LIST
12827: LIST
12828: PUSH
12829: LD_INT 25
12831: PUSH
12832: LD_INT 4
12834: PUSH
12835: EMPTY
12836: LIST
12837: LIST
12838: PUSH
12839: LD_INT 26
12841: PUSH
12842: LD_INT 1
12844: PUSH
12845: EMPTY
12846: LIST
12847: LIST
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: LIST
12853: LIST
12854: PPUSH
12855: CALL_OW 69
12859: PUSH
12860: LD_VAR 0 3
12864: DIFF
12865: ST_TO_ADDR
// if tmp then
12866: LD_VAR 0 2
12870: IFFALSE 12886
// result := tmp [ 1 ] ;
12872: LD_ADDR_VAR 0 1
12876: PUSH
12877: LD_VAR 0 2
12881: PUSH
12882: LD_INT 1
12884: ARRAY
12885: ST_TO_ADDR
// end ;
12886: LD_VAR 0 1
12890: RET
// export function SolRu ; var tmp , t ; begin
12891: LD_INT 0
12893: PPUSH
12894: PPUSH
12895: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12896: LD_ADDR_VAR 0 3
12900: PUSH
12901: LD_EXP 32
12905: PUSH
12906: LD_EXP 46
12910: PUSH
12911: LD_EXP 34
12915: PUSH
12916: LD_EXP 47
12920: PUSH
12921: LD_EXP 48
12925: PUSH
12926: LD_EXP 37
12930: PUSH
12931: LD_EXP 38
12935: PUSH
12936: LD_EXP 36
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: LIST
12947: LIST
12948: LIST
12949: LIST
12950: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12951: LD_ADDR_VAR 0 2
12955: PUSH
12956: LD_INT 22
12958: PUSH
12959: LD_INT 7
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PUSH
12966: LD_INT 23
12968: PUSH
12969: LD_INT 3
12971: PUSH
12972: EMPTY
12973: LIST
12974: LIST
12975: PUSH
12976: LD_INT 25
12978: PUSH
12979: LD_INT 1
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: PUSH
12986: LD_INT 26
12988: PUSH
12989: LD_INT 1
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: PPUSH
13002: CALL_OW 69
13006: PUSH
13007: LD_VAR 0 3
13011: DIFF
13012: ST_TO_ADDR
// if tmp then
13013: LD_VAR 0 2
13017: IFFALSE 13033
// result := tmp [ 1 ] ;
13019: LD_ADDR_VAR 0 1
13023: PUSH
13024: LD_VAR 0 2
13028: PUSH
13029: LD_INT 1
13031: ARRAY
13032: ST_TO_ADDR
// end ; end_of_file
13033: LD_VAR 0 1
13037: RET
// export function CustomEvent ( event ) ; begin
13038: LD_INT 0
13040: PPUSH
// end ;
13041: LD_VAR 0 2
13045: RET
// on UnitDestroyed ( un ) do var i , side ;
13046: LD_INT 0
13048: PPUSH
13049: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13050: LD_VAR 0 1
13054: PUSH
13055: LD_INT 22
13057: PUSH
13058: LD_INT 7
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: PUSH
13065: LD_INT 2
13067: PUSH
13068: LD_INT 25
13070: PUSH
13071: LD_INT 1
13073: PUSH
13074: EMPTY
13075: LIST
13076: LIST
13077: PUSH
13078: LD_INT 25
13080: PUSH
13081: LD_INT 2
13083: PUSH
13084: EMPTY
13085: LIST
13086: LIST
13087: PUSH
13088: LD_INT 25
13090: PUSH
13091: LD_INT 3
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: PUSH
13098: LD_INT 25
13100: PUSH
13101: LD_INT 4
13103: PUSH
13104: EMPTY
13105: LIST
13106: LIST
13107: PUSH
13108: LD_INT 25
13110: PUSH
13111: LD_INT 5
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: PUSH
13118: LD_INT 25
13120: PUSH
13121: LD_INT 8
13123: PUSH
13124: EMPTY
13125: LIST
13126: LIST
13127: PUSH
13128: LD_INT 25
13130: PUSH
13131: LD_INT 9
13133: PUSH
13134: EMPTY
13135: LIST
13136: LIST
13137: PUSH
13138: EMPTY
13139: LIST
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: PUSH
13148: EMPTY
13149: LIST
13150: LIST
13151: PPUSH
13152: CALL_OW 69
13156: IN
13157: IFFALSE 13173
// loss_counter := loss_counter + 1 ;
13159: LD_ADDR_EXP 13
13163: PUSH
13164: LD_EXP 13
13168: PUSH
13169: LD_INT 1
13171: PLUS
13172: ST_TO_ADDR
// if un = Abdul then
13173: LD_VAR 0 1
13177: PUSH
13178: LD_EXP 55
13182: EQUAL
13183: IFFALSE 13193
// abdul_escaped := false ;
13185: LD_ADDR_EXP 12
13189: PUSH
13190: LD_INT 0
13192: ST_TO_ADDR
// if un in ru_attackers then
13193: LD_VAR 0 1
13197: PUSH
13198: LD_EXP 52
13202: IN
13203: IFFALSE 13221
// ru_attackers := ru_attackers diff un ;
13205: LD_ADDR_EXP 52
13209: PUSH
13210: LD_EXP 52
13214: PUSH
13215: LD_VAR 0 1
13219: DIFF
13220: ST_TO_ADDR
// if un in ar_attackers then
13221: LD_VAR 0 1
13225: PUSH
13226: LD_EXP 10
13230: IN
13231: IFFALSE 13249
// ar_attackers := ar_attackers diff un ;
13233: LD_ADDR_EXP 10
13237: PUSH
13238: LD_EXP 10
13242: PUSH
13243: LD_VAR 0 1
13247: DIFF
13248: ST_TO_ADDR
// if un = JMM then
13249: LD_VAR 0 1
13253: PUSH
13254: LD_EXP 15
13258: EQUAL
13259: IFFALSE 13270
// begin YouLost ( JMM ) ;
13261: LD_STRING JMM
13263: PPUSH
13264: CALL_OW 104
// exit ;
13268: GO 13359
// end ; if un = Burlak then
13270: LD_VAR 0 1
13274: PUSH
13275: LD_EXP 46
13279: EQUAL
13280: IFFALSE 13291
// begin YouLost ( Burlak ) ;
13282: LD_STRING Burlak
13284: PPUSH
13285: CALL_OW 104
// exit ;
13289: GO 13359
// end ; if un = freedom then
13291: LD_VAR 0 1
13295: PUSH
13296: LD_EXP 3
13300: EQUAL
13301: IFFALSE 13312
// begin YouLost ( Destroyed ) ;
13303: LD_STRING Destroyed
13305: PPUSH
13306: CALL_OW 104
// exit ;
13310: GO 13359
// end ; if un = Masha then
13312: LD_VAR 0 1
13316: PUSH
13317: LD_EXP 49
13321: EQUAL
13322: IFFALSE 13331
// ChangeMissionObjectives ( M4b ) ;
13324: LD_STRING M4b
13326: PPUSH
13327: CALL_OW 337
// if un = Mastodont then
13331: LD_VAR 0 1
13335: PUSH
13336: LD_EXP 56
13340: EQUAL
13341: IFFALSE 13350
// ChangeMissionObjectives ( M4a ) ;
13343: LD_STRING M4a
13345: PPUSH
13346: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13350: LD_VAR 0 1
13354: PPUSH
13355: CALL 78524 0 1
// end ;
13359: PPOPN 3
13361: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13362: LD_VAR 0 1
13366: PPUSH
13367: LD_VAR 0 2
13371: PPUSH
13372: CALL 80858 0 2
// end ;
13376: PPOPN 2
13378: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13379: LD_VAR 0 1
13383: PPUSH
13384: CALL 79926 0 1
// end ;
13388: PPOPN 1
13390: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13391: LD_VAR 0 1
13395: PUSH
13396: LD_INT 22
13398: PUSH
13399: LD_INT 7
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: PUSH
13406: LD_INT 30
13408: PUSH
13409: LD_INT 0
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: PPUSH
13420: CALL_OW 69
13424: IN
13425: IFFALSE 13464
// begin SetBName ( building , freedom ) ;
13427: LD_VAR 0 1
13431: PPUSH
13432: LD_STRING freedom
13434: PPUSH
13435: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13439: LD_INT 0
13441: PPUSH
13442: LD_INT 7
13444: PPUSH
13445: LD_INT 0
13447: PPUSH
13448: CALL_OW 324
// freedom := building ;
13452: LD_ADDR_EXP 3
13456: PUSH
13457: LD_VAR 0 1
13461: ST_TO_ADDR
// exit ;
13462: GO 13530
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13464: LD_VAR 0 1
13468: PUSH
13469: LD_INT 22
13471: PUSH
13472: LD_INT 7
13474: PUSH
13475: EMPTY
13476: LIST
13477: LIST
13478: PUSH
13479: LD_INT 23
13481: PUSH
13482: LD_INT 3
13484: PUSH
13485: EMPTY
13486: LIST
13487: LIST
13488: PUSH
13489: LD_INT 30
13491: PUSH
13492: LD_INT 6
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: LIST
13503: PPUSH
13504: CALL_OW 69
13508: IN
13509: IFFALSE 13521
// begin ru_lab_builded := true ;
13511: LD_ADDR_EXP 5
13515: PUSH
13516: LD_INT 1
13518: ST_TO_ADDR
// exit ;
13519: GO 13530
// end ; MCE_BuildingComplete ( building ) ;
13521: LD_VAR 0 1
13525: PPUSH
13526: CALL 80167 0 1
// end ;
13530: PPOPN 1
13532: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13533: LD_VAR 0 1
13537: PPUSH
13538: LD_VAR 0 2
13542: PPUSH
13543: CALL 78220 0 2
// end ;
13547: PPOPN 2
13549: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13550: LD_VAR 0 1
13554: PPUSH
13555: LD_VAR 0 2
13559: PPUSH
13560: LD_VAR 0 3
13564: PPUSH
13565: LD_VAR 0 4
13569: PPUSH
13570: LD_VAR 0 5
13574: PPUSH
13575: CALL 77840 0 5
// end ;
13579: PPOPN 5
13581: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13582: LD_VAR 0 1
13586: PPUSH
13587: LD_VAR 0 2
13591: PPUSH
13592: CALL 77430 0 2
// end ;
13596: PPOPN 2
13598: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13599: LD_VAR 0 1
13603: PPUSH
13604: CALL_OW 263
13608: PUSH
13609: LD_INT 3
13611: EQUAL
13612: PUSH
13613: LD_VAR 0 2
13617: PPUSH
13618: CALL_OW 263
13622: PUSH
13623: LD_INT 3
13625: EQUAL
13626: OR
13627: IFFALSE 13643
// hack_counter := hack_counter + 1 ;
13629: LD_ADDR_EXP 14
13633: PUSH
13634: LD_EXP 14
13638: PUSH
13639: LD_INT 1
13641: PLUS
13642: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13643: LD_VAR 0 1
13647: PPUSH
13648: LD_VAR 0 2
13652: PPUSH
13653: LD_VAR 0 3
13657: PPUSH
13658: LD_VAR 0 4
13662: PPUSH
13663: CALL 77268 0 4
// end ;
13667: PPOPN 4
13669: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13670: LD_VAR 0 1
13674: PPUSH
13675: LD_VAR 0 2
13679: PPUSH
13680: LD_VAR 0 3
13684: PPUSH
13685: CALL 77043 0 3
// end ;
13689: PPOPN 3
13691: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13692: LD_VAR 0 1
13696: PPUSH
13697: LD_VAR 0 2
13701: PPUSH
13702: CALL 76928 0 2
// end ;
13706: PPOPN 2
13708: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13709: LD_VAR 0 1
13713: PPUSH
13714: LD_VAR 0 2
13718: PPUSH
13719: CALL 81119 0 2
// end ;
13723: PPOPN 2
13725: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13726: LD_VAR 0 1
13730: PPUSH
13731: LD_VAR 0 2
13735: PPUSH
13736: LD_VAR 0 3
13740: PPUSH
13741: LD_VAR 0 4
13745: PPUSH
13746: CALL 81335 0 4
// end ;
13750: PPOPN 4
13752: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13753: LD_VAR 0 1
13757: PPUSH
13758: LD_VAR 0 2
13762: PPUSH
13763: CALL 76737 0 2
// end ;
13767: PPOPN 2
13769: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13770: LD_VAR 0 1
13774: PPUSH
13775: CALL 94893 0 1
// end ; end_of_file
13779: PPOPN 1
13781: END
// every 0 0$30 do var cr , time ;
13782: GO 13784
13784: DISABLE
13785: LD_INT 0
13787: PPUSH
13788: PPUSH
// begin time := 0 0$30 ;
13789: LD_ADDR_VAR 0 2
13793: PUSH
13794: LD_INT 1050
13796: ST_TO_ADDR
// while game do
13797: LD_EXP 2
13801: IFFALSE 13900
// begin wait ( time ) ;
13803: LD_VAR 0 2
13807: PPUSH
13808: CALL_OW 67
// if tick > 2 2$00 then
13812: LD_OWVAR 1
13816: PUSH
13817: LD_INT 4200
13819: GREATER
13820: IFFALSE 13853
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13822: LD_ADDR_VAR 0 2
13826: PUSH
13827: LD_VAR 0 2
13831: PUSH
13832: LD_INT 280
13834: PUSH
13835: LD_INT 420
13837: PUSH
13838: LD_INT 630
13840: PUSH
13841: EMPTY
13842: LIST
13843: LIST
13844: LIST
13845: PUSH
13846: LD_OWVAR 67
13850: ARRAY
13851: PLUS
13852: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13853: LD_INT 1
13855: PPUSH
13856: LD_INT 5
13858: PPUSH
13859: CALL_OW 12
13863: PPUSH
13864: LD_INT 70
13866: PPUSH
13867: LD_INT 49
13869: PPUSH
13870: LD_INT 25
13872: PPUSH
13873: LD_INT 1
13875: PPUSH
13876: CALL_OW 56
// if time > 5 5$00 then
13880: LD_VAR 0 2
13884: PUSH
13885: LD_INT 10500
13887: GREATER
13888: IFFALSE 13898
// time := 0 0$30 ;
13890: LD_ADDR_VAR 0 2
13894: PUSH
13895: LD_INT 1050
13897: ST_TO_ADDR
// end ;
13898: GO 13797
// end ;
13900: PPOPN 2
13902: END
// every 0 0$30 do var cr , time ;
13903: GO 13905
13905: DISABLE
13906: LD_INT 0
13908: PPUSH
13909: PPUSH
// begin time := 0 0$20 ;
13910: LD_ADDR_VAR 0 2
13914: PUSH
13915: LD_INT 700
13917: ST_TO_ADDR
// while game do
13918: LD_EXP 2
13922: IFFALSE 14011
// begin wait ( time ) ;
13924: LD_VAR 0 2
13928: PPUSH
13929: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13933: LD_ADDR_VAR 0 2
13937: PUSH
13938: LD_VAR 0 2
13942: PUSH
13943: LD_INT 490
13945: PUSH
13946: LD_INT 525
13948: PUSH
13949: LD_INT 560
13951: PUSH
13952: EMPTY
13953: LIST
13954: LIST
13955: LIST
13956: PUSH
13957: LD_OWVAR 67
13961: ARRAY
13962: PLUS
13963: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13964: LD_INT 3
13966: PPUSH
13967: LD_INT 5
13969: PPUSH
13970: CALL_OW 12
13974: PPUSH
13975: LD_INT 26
13977: PPUSH
13978: LD_INT 9
13980: PPUSH
13981: LD_INT 30
13983: PPUSH
13984: LD_INT 1
13986: PPUSH
13987: CALL_OW 56
// if time > 3 3$00 then
13991: LD_VAR 0 2
13995: PUSH
13996: LD_INT 6300
13998: GREATER
13999: IFFALSE 14009
// time := 0 0$20 ;
14001: LD_ADDR_VAR 0 2
14005: PUSH
14006: LD_INT 700
14008: ST_TO_ADDR
// end ;
14009: GO 13918
// end ;
14011: PPOPN 2
14013: END
// every 0 0$30 do var cr , time ;
14014: GO 14016
14016: DISABLE
14017: LD_INT 0
14019: PPUSH
14020: PPUSH
// begin time := 0 0$20 ;
14021: LD_ADDR_VAR 0 2
14025: PUSH
14026: LD_INT 700
14028: ST_TO_ADDR
// while game do
14029: LD_EXP 2
14033: IFFALSE 14158
// begin wait ( time ) ;
14035: LD_VAR 0 2
14039: PPUSH
14040: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14044: LD_ADDR_VAR 0 2
14048: PUSH
14049: LD_VAR 0 2
14053: PUSH
14054: LD_INT 175
14056: PUSH
14057: LD_INT 210
14059: PUSH
14060: LD_INT 280
14062: PUSH
14063: EMPTY
14064: LIST
14065: LIST
14066: LIST
14067: PUSH
14068: LD_OWVAR 67
14072: ARRAY
14073: PLUS
14074: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14075: LD_INT 1
14077: PPUSH
14078: LD_INT 5
14080: PPUSH
14081: CALL_OW 12
14085: PPUSH
14086: LD_INT 179
14088: PPUSH
14089: LD_INT 101
14091: PPUSH
14092: LD_INT 20
14094: PPUSH
14095: LD_INT 1
14097: PPUSH
14098: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14102: LD_INT 350
14104: PPUSH
14105: LD_INT 525
14107: PPUSH
14108: CALL_OW 12
14112: PPUSH
14113: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14117: LD_INT 1
14119: PPUSH
14120: LD_INT 5
14122: PPUSH
14123: CALL_OW 12
14127: PPUSH
14128: LD_INT 9
14130: PPUSH
14131: LD_INT 1
14133: PPUSH
14134: CALL_OW 55
// if time > 4 4$00 then
14138: LD_VAR 0 2
14142: PUSH
14143: LD_INT 8400
14145: GREATER
14146: IFFALSE 14156
// time := 0 0$30 ;
14148: LD_ADDR_VAR 0 2
14152: PUSH
14153: LD_INT 1050
14155: ST_TO_ADDR
// end ;
14156: GO 14029
// end ;
14158: PPOPN 2
14160: END
// every 0 0$30 do var cr , time ;
14161: GO 14163
14163: DISABLE
14164: LD_INT 0
14166: PPUSH
14167: PPUSH
// begin time := 0 0$10 ;
14168: LD_ADDR_VAR 0 2
14172: PUSH
14173: LD_INT 350
14175: ST_TO_ADDR
// while game do
14176: LD_EXP 2
14180: IFFALSE 14314
// begin wait ( time ) ;
14182: LD_VAR 0 2
14186: PPUSH
14187: CALL_OW 67
// time := time + 0 0$10 ;
14191: LD_ADDR_VAR 0 2
14195: PUSH
14196: LD_VAR 0 2
14200: PUSH
14201: LD_INT 350
14203: PLUS
14204: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14205: LD_INT 1
14207: PPUSH
14208: LD_INT 5
14210: PPUSH
14211: CALL_OW 12
14215: PPUSH
14216: LD_INT 11
14218: PPUSH
14219: LD_INT 1
14221: PPUSH
14222: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14226: LD_ADDR_VAR 0 1
14230: PUSH
14231: LD_INT 1
14233: PPUSH
14234: LD_INT 3
14236: PPUSH
14237: CALL_OW 12
14241: ST_TO_ADDR
// if cr = 1 then
14242: LD_VAR 0 1
14246: PUSH
14247: LD_INT 1
14249: EQUAL
14250: IFFALSE 14294
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14252: LD_INT 700
14254: PPUSH
14255: LD_INT 1575
14257: PPUSH
14258: CALL_OW 12
14262: PPUSH
14263: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14267: LD_INT 1
14269: PPUSH
14270: LD_INT 5
14272: PPUSH
14273: CALL_OW 12
14277: PPUSH
14278: LD_INT 34
14280: PPUSH
14281: LD_INT 50
14283: PPUSH
14284: LD_INT 7
14286: PPUSH
14287: LD_INT 1
14289: PPUSH
14290: CALL_OW 56
// end ; if time > 8 8$00 then
14294: LD_VAR 0 2
14298: PUSH
14299: LD_INT 16800
14301: GREATER
14302: IFFALSE 14312
// time := 0 0$40 ;
14304: LD_ADDR_VAR 0 2
14308: PUSH
14309: LD_INT 1400
14311: ST_TO_ADDR
// end ;
14312: GO 14176
// end ; end_of_file
14314: PPOPN 2
14316: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14317: LD_INT 0
14319: PPUSH
14320: PPUSH
// if exist_mode then
14321: LD_VAR 0 2
14325: IFFALSE 14350
// unit := CreateCharacter ( prefix & ident ) else
14327: LD_ADDR_VAR 0 5
14331: PUSH
14332: LD_VAR 0 3
14336: PUSH
14337: LD_VAR 0 1
14341: STR
14342: PPUSH
14343: CALL_OW 34
14347: ST_TO_ADDR
14348: GO 14365
// unit := NewCharacter ( ident ) ;
14350: LD_ADDR_VAR 0 5
14354: PUSH
14355: LD_VAR 0 1
14359: PPUSH
14360: CALL_OW 25
14364: ST_TO_ADDR
// result := unit ;
14365: LD_ADDR_VAR 0 4
14369: PUSH
14370: LD_VAR 0 5
14374: ST_TO_ADDR
// end ;
14375: LD_VAR 0 4
14379: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14380: LD_INT 0
14382: PPUSH
14383: PPUSH
// if not side or not nation then
14384: LD_VAR 0 1
14388: NOT
14389: PUSH
14390: LD_VAR 0 2
14394: NOT
14395: OR
14396: IFFALSE 14400
// exit ;
14398: GO 15164
// case nation of nation_american :
14400: LD_VAR 0 2
14404: PUSH
14405: LD_INT 1
14407: DOUBLE
14408: EQUAL
14409: IFTRUE 14413
14411: GO 14627
14413: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14414: LD_ADDR_VAR 0 4
14418: PUSH
14419: LD_INT 35
14421: PUSH
14422: LD_INT 45
14424: PUSH
14425: LD_INT 46
14427: PUSH
14428: LD_INT 47
14430: PUSH
14431: LD_INT 82
14433: PUSH
14434: LD_INT 83
14436: PUSH
14437: LD_INT 84
14439: PUSH
14440: LD_INT 85
14442: PUSH
14443: LD_INT 86
14445: PUSH
14446: LD_INT 1
14448: PUSH
14449: LD_INT 2
14451: PUSH
14452: LD_INT 6
14454: PUSH
14455: LD_INT 15
14457: PUSH
14458: LD_INT 16
14460: PUSH
14461: LD_INT 7
14463: PUSH
14464: LD_INT 12
14466: PUSH
14467: LD_INT 13
14469: PUSH
14470: LD_INT 10
14472: PUSH
14473: LD_INT 14
14475: PUSH
14476: LD_INT 20
14478: PUSH
14479: LD_INT 21
14481: PUSH
14482: LD_INT 22
14484: PUSH
14485: LD_INT 25
14487: PUSH
14488: LD_INT 32
14490: PUSH
14491: LD_INT 27
14493: PUSH
14494: LD_INT 36
14496: PUSH
14497: LD_INT 69
14499: PUSH
14500: LD_INT 39
14502: PUSH
14503: LD_INT 34
14505: PUSH
14506: LD_INT 40
14508: PUSH
14509: LD_INT 48
14511: PUSH
14512: LD_INT 49
14514: PUSH
14515: LD_INT 50
14517: PUSH
14518: LD_INT 51
14520: PUSH
14521: LD_INT 52
14523: PUSH
14524: LD_INT 53
14526: PUSH
14527: LD_INT 54
14529: PUSH
14530: LD_INT 55
14532: PUSH
14533: LD_INT 56
14535: PUSH
14536: LD_INT 57
14538: PUSH
14539: LD_INT 58
14541: PUSH
14542: LD_INT 59
14544: PUSH
14545: LD_INT 60
14547: PUSH
14548: LD_INT 61
14550: PUSH
14551: LD_INT 62
14553: PUSH
14554: LD_INT 80
14556: PUSH
14557: LD_INT 82
14559: PUSH
14560: LD_INT 83
14562: PUSH
14563: LD_INT 84
14565: PUSH
14566: LD_INT 85
14568: PUSH
14569: LD_INT 86
14571: PUSH
14572: EMPTY
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: LIST
14604: LIST
14605: LIST
14606: LIST
14607: LIST
14608: LIST
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: LIST
14617: LIST
14618: LIST
14619: LIST
14620: LIST
14621: LIST
14622: LIST
14623: LIST
14624: ST_TO_ADDR
14625: GO 15088
14627: LD_INT 2
14629: DOUBLE
14630: EQUAL
14631: IFTRUE 14635
14633: GO 14857
14635: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
14636: LD_ADDR_VAR 0 4
14640: PUSH
14641: LD_INT 35
14643: PUSH
14644: LD_INT 45
14646: PUSH
14647: LD_INT 46
14649: PUSH
14650: LD_INT 47
14652: PUSH
14653: LD_INT 82
14655: PUSH
14656: LD_INT 83
14658: PUSH
14659: LD_INT 84
14661: PUSH
14662: LD_INT 85
14664: PUSH
14665: LD_INT 87
14667: PUSH
14668: LD_INT 70
14670: PUSH
14671: LD_INT 1
14673: PUSH
14674: LD_INT 11
14676: PUSH
14677: LD_INT 3
14679: PUSH
14680: LD_INT 4
14682: PUSH
14683: LD_INT 5
14685: PUSH
14686: LD_INT 6
14688: PUSH
14689: LD_INT 15
14691: PUSH
14692: LD_INT 18
14694: PUSH
14695: LD_INT 7
14697: PUSH
14698: LD_INT 17
14700: PUSH
14701: LD_INT 8
14703: PUSH
14704: LD_INT 20
14706: PUSH
14707: LD_INT 21
14709: PUSH
14710: LD_INT 22
14712: PUSH
14713: LD_INT 72
14715: PUSH
14716: LD_INT 26
14718: PUSH
14719: LD_INT 69
14721: PUSH
14722: LD_INT 39
14724: PUSH
14725: LD_INT 40
14727: PUSH
14728: LD_INT 41
14730: PUSH
14731: LD_INT 42
14733: PUSH
14734: LD_INT 43
14736: PUSH
14737: LD_INT 48
14739: PUSH
14740: LD_INT 49
14742: PUSH
14743: LD_INT 50
14745: PUSH
14746: LD_INT 51
14748: PUSH
14749: LD_INT 52
14751: PUSH
14752: LD_INT 53
14754: PUSH
14755: LD_INT 54
14757: PUSH
14758: LD_INT 55
14760: PUSH
14761: LD_INT 56
14763: PUSH
14764: LD_INT 60
14766: PUSH
14767: LD_INT 61
14769: PUSH
14770: LD_INT 62
14772: PUSH
14773: LD_INT 66
14775: PUSH
14776: LD_INT 67
14778: PUSH
14779: LD_INT 68
14781: PUSH
14782: LD_INT 81
14784: PUSH
14785: LD_INT 82
14787: PUSH
14788: LD_INT 83
14790: PUSH
14791: LD_INT 84
14793: PUSH
14794: LD_INT 85
14796: PUSH
14797: LD_INT 87
14799: PUSH
14800: EMPTY
14801: LIST
14802: LIST
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: LIST
14808: LIST
14809: LIST
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: LIST
14817: LIST
14818: LIST
14819: LIST
14820: LIST
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: LIST
14826: LIST
14827: LIST
14828: LIST
14829: LIST
14830: LIST
14831: LIST
14832: LIST
14833: LIST
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: LIST
14839: LIST
14840: LIST
14841: LIST
14842: LIST
14843: LIST
14844: LIST
14845: LIST
14846: LIST
14847: LIST
14848: LIST
14849: LIST
14850: LIST
14851: LIST
14852: LIST
14853: LIST
14854: ST_TO_ADDR
14855: GO 15088
14857: LD_INT 3
14859: DOUBLE
14860: EQUAL
14861: IFTRUE 14865
14863: GO 15087
14865: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14866: LD_ADDR_VAR 0 4
14870: PUSH
14871: LD_INT 46
14873: PUSH
14874: LD_INT 47
14876: PUSH
14877: LD_INT 1
14879: PUSH
14880: LD_INT 2
14882: PUSH
14883: LD_INT 82
14885: PUSH
14886: LD_INT 83
14888: PUSH
14889: LD_INT 84
14891: PUSH
14892: LD_INT 85
14894: PUSH
14895: LD_INT 86
14897: PUSH
14898: LD_INT 11
14900: PUSH
14901: LD_INT 9
14903: PUSH
14904: LD_INT 20
14906: PUSH
14907: LD_INT 19
14909: PUSH
14910: LD_INT 21
14912: PUSH
14913: LD_INT 24
14915: PUSH
14916: LD_INT 22
14918: PUSH
14919: LD_INT 25
14921: PUSH
14922: LD_INT 28
14924: PUSH
14925: LD_INT 29
14927: PUSH
14928: LD_INT 30
14930: PUSH
14931: LD_INT 31
14933: PUSH
14934: LD_INT 37
14936: PUSH
14937: LD_INT 38
14939: PUSH
14940: LD_INT 32
14942: PUSH
14943: LD_INT 27
14945: PUSH
14946: LD_INT 33
14948: PUSH
14949: LD_INT 69
14951: PUSH
14952: LD_INT 39
14954: PUSH
14955: LD_INT 34
14957: PUSH
14958: LD_INT 40
14960: PUSH
14961: LD_INT 71
14963: PUSH
14964: LD_INT 23
14966: PUSH
14967: LD_INT 44
14969: PUSH
14970: LD_INT 48
14972: PUSH
14973: LD_INT 49
14975: PUSH
14976: LD_INT 50
14978: PUSH
14979: LD_INT 51
14981: PUSH
14982: LD_INT 52
14984: PUSH
14985: LD_INT 53
14987: PUSH
14988: LD_INT 54
14990: PUSH
14991: LD_INT 55
14993: PUSH
14994: LD_INT 56
14996: PUSH
14997: LD_INT 57
14999: PUSH
15000: LD_INT 58
15002: PUSH
15003: LD_INT 59
15005: PUSH
15006: LD_INT 63
15008: PUSH
15009: LD_INT 64
15011: PUSH
15012: LD_INT 65
15014: PUSH
15015: LD_INT 82
15017: PUSH
15018: LD_INT 83
15020: PUSH
15021: LD_INT 84
15023: PUSH
15024: LD_INT 85
15026: PUSH
15027: LD_INT 86
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: LIST
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: LIST
15052: LIST
15053: LIST
15054: LIST
15055: LIST
15056: LIST
15057: LIST
15058: LIST
15059: LIST
15060: LIST
15061: LIST
15062: LIST
15063: LIST
15064: LIST
15065: LIST
15066: LIST
15067: LIST
15068: LIST
15069: LIST
15070: LIST
15071: LIST
15072: LIST
15073: LIST
15074: LIST
15075: LIST
15076: LIST
15077: LIST
15078: LIST
15079: LIST
15080: LIST
15081: LIST
15082: LIST
15083: LIST
15084: ST_TO_ADDR
15085: GO 15088
15087: POP
// if state > - 1 and state < 3 then
15088: LD_VAR 0 3
15092: PUSH
15093: LD_INT 1
15095: NEG
15096: GREATER
15097: PUSH
15098: LD_VAR 0 3
15102: PUSH
15103: LD_INT 3
15105: LESS
15106: AND
15107: IFFALSE 15164
// for i in result do
15109: LD_ADDR_VAR 0 5
15113: PUSH
15114: LD_VAR 0 4
15118: PUSH
15119: FOR_IN
15120: IFFALSE 15162
// if GetTech ( i , side ) <> state then
15122: LD_VAR 0 5
15126: PPUSH
15127: LD_VAR 0 1
15131: PPUSH
15132: CALL_OW 321
15136: PUSH
15137: LD_VAR 0 3
15141: NONEQUAL
15142: IFFALSE 15160
// result := result diff i ;
15144: LD_ADDR_VAR 0 4
15148: PUSH
15149: LD_VAR 0 4
15153: PUSH
15154: LD_VAR 0 5
15158: DIFF
15159: ST_TO_ADDR
15160: GO 15119
15162: POP
15163: POP
// end ;
15164: LD_VAR 0 4
15168: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15169: LD_INT 0
15171: PPUSH
15172: PPUSH
15173: PPUSH
// result := true ;
15174: LD_ADDR_VAR 0 3
15178: PUSH
15179: LD_INT 1
15181: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15182: LD_ADDR_VAR 0 5
15186: PUSH
15187: LD_VAR 0 2
15191: PPUSH
15192: CALL_OW 480
15196: ST_TO_ADDR
// if not tmp then
15197: LD_VAR 0 5
15201: NOT
15202: IFFALSE 15206
// exit ;
15204: GO 15255
// for i in tmp do
15206: LD_ADDR_VAR 0 4
15210: PUSH
15211: LD_VAR 0 5
15215: PUSH
15216: FOR_IN
15217: IFFALSE 15253
// if GetTech ( i , side ) <> state_researched then
15219: LD_VAR 0 4
15223: PPUSH
15224: LD_VAR 0 1
15228: PPUSH
15229: CALL_OW 321
15233: PUSH
15234: LD_INT 2
15236: NONEQUAL
15237: IFFALSE 15251
// begin result := false ;
15239: LD_ADDR_VAR 0 3
15243: PUSH
15244: LD_INT 0
15246: ST_TO_ADDR
// exit ;
15247: POP
15248: POP
15249: GO 15255
// end ;
15251: GO 15216
15253: POP
15254: POP
// end ;
15255: LD_VAR 0 3
15259: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15260: LD_INT 0
15262: PPUSH
15263: PPUSH
15264: PPUSH
15265: PPUSH
15266: PPUSH
15267: PPUSH
15268: PPUSH
15269: PPUSH
15270: PPUSH
15271: PPUSH
15272: PPUSH
15273: PPUSH
15274: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15275: LD_VAR 0 1
15279: NOT
15280: PUSH
15281: LD_VAR 0 1
15285: PPUSH
15286: CALL_OW 257
15290: PUSH
15291: LD_INT 9
15293: NONEQUAL
15294: OR
15295: IFFALSE 15299
// exit ;
15297: GO 15872
// side := GetSide ( unit ) ;
15299: LD_ADDR_VAR 0 9
15303: PUSH
15304: LD_VAR 0 1
15308: PPUSH
15309: CALL_OW 255
15313: ST_TO_ADDR
// tech_space := tech_spacanom ;
15314: LD_ADDR_VAR 0 12
15318: PUSH
15319: LD_INT 29
15321: ST_TO_ADDR
// tech_time := tech_taurad ;
15322: LD_ADDR_VAR 0 13
15326: PUSH
15327: LD_INT 28
15329: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15330: LD_ADDR_VAR 0 11
15334: PUSH
15335: LD_VAR 0 1
15339: PPUSH
15340: CALL_OW 310
15344: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15345: LD_VAR 0 11
15349: PPUSH
15350: CALL_OW 247
15354: PUSH
15355: LD_INT 2
15357: EQUAL
15358: IFFALSE 15362
// exit ;
15360: GO 15872
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15362: LD_ADDR_VAR 0 8
15366: PUSH
15367: LD_INT 81
15369: PUSH
15370: LD_VAR 0 9
15374: PUSH
15375: EMPTY
15376: LIST
15377: LIST
15378: PUSH
15379: LD_INT 3
15381: PUSH
15382: LD_INT 21
15384: PUSH
15385: LD_INT 3
15387: PUSH
15388: EMPTY
15389: LIST
15390: LIST
15391: PUSH
15392: EMPTY
15393: LIST
15394: LIST
15395: PUSH
15396: EMPTY
15397: LIST
15398: LIST
15399: PPUSH
15400: CALL_OW 69
15404: ST_TO_ADDR
// if not tmp then
15405: LD_VAR 0 8
15409: NOT
15410: IFFALSE 15414
// exit ;
15412: GO 15872
// if in_unit then
15414: LD_VAR 0 11
15418: IFFALSE 15442
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15420: LD_ADDR_VAR 0 10
15424: PUSH
15425: LD_VAR 0 8
15429: PPUSH
15430: LD_VAR 0 11
15434: PPUSH
15435: CALL_OW 74
15439: ST_TO_ADDR
15440: GO 15462
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15442: LD_ADDR_VAR 0 10
15446: PUSH
15447: LD_VAR 0 8
15451: PPUSH
15452: LD_VAR 0 1
15456: PPUSH
15457: CALL_OW 74
15461: ST_TO_ADDR
// if not enemy then
15462: LD_VAR 0 10
15466: NOT
15467: IFFALSE 15471
// exit ;
15469: GO 15872
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15471: LD_VAR 0 11
15475: PUSH
15476: LD_VAR 0 11
15480: PPUSH
15481: LD_VAR 0 10
15485: PPUSH
15486: CALL_OW 296
15490: PUSH
15491: LD_INT 13
15493: GREATER
15494: AND
15495: PUSH
15496: LD_VAR 0 1
15500: PPUSH
15501: LD_VAR 0 10
15505: PPUSH
15506: CALL_OW 296
15510: PUSH
15511: LD_INT 12
15513: GREATER
15514: OR
15515: IFFALSE 15519
// exit ;
15517: GO 15872
// missile := [ 1 ] ;
15519: LD_ADDR_VAR 0 14
15523: PUSH
15524: LD_INT 1
15526: PUSH
15527: EMPTY
15528: LIST
15529: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15530: LD_VAR 0 9
15534: PPUSH
15535: LD_VAR 0 12
15539: PPUSH
15540: CALL_OW 325
15544: IFFALSE 15573
// missile := Insert ( missile , missile + 1 , 2 ) ;
15546: LD_ADDR_VAR 0 14
15550: PUSH
15551: LD_VAR 0 14
15555: PPUSH
15556: LD_VAR 0 14
15560: PUSH
15561: LD_INT 1
15563: PLUS
15564: PPUSH
15565: LD_INT 2
15567: PPUSH
15568: CALL_OW 2
15572: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15573: LD_VAR 0 9
15577: PPUSH
15578: LD_VAR 0 13
15582: PPUSH
15583: CALL_OW 325
15587: PUSH
15588: LD_VAR 0 10
15592: PPUSH
15593: CALL_OW 255
15597: PPUSH
15598: LD_VAR 0 13
15602: PPUSH
15603: CALL_OW 325
15607: NOT
15608: AND
15609: IFFALSE 15638
// missile := Insert ( missile , missile + 1 , 3 ) ;
15611: LD_ADDR_VAR 0 14
15615: PUSH
15616: LD_VAR 0 14
15620: PPUSH
15621: LD_VAR 0 14
15625: PUSH
15626: LD_INT 1
15628: PLUS
15629: PPUSH
15630: LD_INT 3
15632: PPUSH
15633: CALL_OW 2
15637: ST_TO_ADDR
// if missile < 2 then
15638: LD_VAR 0 14
15642: PUSH
15643: LD_INT 2
15645: LESS
15646: IFFALSE 15650
// exit ;
15648: GO 15872
// x := GetX ( enemy ) ;
15650: LD_ADDR_VAR 0 4
15654: PUSH
15655: LD_VAR 0 10
15659: PPUSH
15660: CALL_OW 250
15664: ST_TO_ADDR
// y := GetY ( enemy ) ;
15665: LD_ADDR_VAR 0 5
15669: PUSH
15670: LD_VAR 0 10
15674: PPUSH
15675: CALL_OW 251
15679: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15680: LD_ADDR_VAR 0 6
15684: PUSH
15685: LD_VAR 0 4
15689: PUSH
15690: LD_INT 1
15692: NEG
15693: PPUSH
15694: LD_INT 1
15696: PPUSH
15697: CALL_OW 12
15701: PLUS
15702: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15703: LD_ADDR_VAR 0 7
15707: PUSH
15708: LD_VAR 0 5
15712: PUSH
15713: LD_INT 1
15715: NEG
15716: PPUSH
15717: LD_INT 1
15719: PPUSH
15720: CALL_OW 12
15724: PLUS
15725: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15726: LD_VAR 0 6
15730: PPUSH
15731: LD_VAR 0 7
15735: PPUSH
15736: CALL_OW 488
15740: NOT
15741: IFFALSE 15763
// begin _x := x ;
15743: LD_ADDR_VAR 0 6
15747: PUSH
15748: LD_VAR 0 4
15752: ST_TO_ADDR
// _y := y ;
15753: LD_ADDR_VAR 0 7
15757: PUSH
15758: LD_VAR 0 5
15762: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15763: LD_ADDR_VAR 0 3
15767: PUSH
15768: LD_INT 1
15770: PPUSH
15771: LD_VAR 0 14
15775: PPUSH
15776: CALL_OW 12
15780: ST_TO_ADDR
// case i of 1 :
15781: LD_VAR 0 3
15785: PUSH
15786: LD_INT 1
15788: DOUBLE
15789: EQUAL
15790: IFTRUE 15794
15792: GO 15811
15794: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15795: LD_VAR 0 1
15799: PPUSH
15800: LD_VAR 0 10
15804: PPUSH
15805: CALL_OW 115
15809: GO 15872
15811: LD_INT 2
15813: DOUBLE
15814: EQUAL
15815: IFTRUE 15819
15817: GO 15841
15819: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15820: LD_VAR 0 1
15824: PPUSH
15825: LD_VAR 0 6
15829: PPUSH
15830: LD_VAR 0 7
15834: PPUSH
15835: CALL_OW 153
15839: GO 15872
15841: LD_INT 3
15843: DOUBLE
15844: EQUAL
15845: IFTRUE 15849
15847: GO 15871
15849: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15850: LD_VAR 0 1
15854: PPUSH
15855: LD_VAR 0 6
15859: PPUSH
15860: LD_VAR 0 7
15864: PPUSH
15865: CALL_OW 154
15869: GO 15872
15871: POP
// end ;
15872: LD_VAR 0 2
15876: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15877: LD_INT 0
15879: PPUSH
15880: PPUSH
15881: PPUSH
15882: PPUSH
15883: PPUSH
15884: PPUSH
// if not unit or not building then
15885: LD_VAR 0 1
15889: NOT
15890: PUSH
15891: LD_VAR 0 2
15895: NOT
15896: OR
15897: IFFALSE 15901
// exit ;
15899: GO 16059
// x := GetX ( building ) ;
15901: LD_ADDR_VAR 0 5
15905: PUSH
15906: LD_VAR 0 2
15910: PPUSH
15911: CALL_OW 250
15915: ST_TO_ADDR
// y := GetY ( building ) ;
15916: LD_ADDR_VAR 0 6
15920: PUSH
15921: LD_VAR 0 2
15925: PPUSH
15926: CALL_OW 251
15930: ST_TO_ADDR
// for i = 0 to 5 do
15931: LD_ADDR_VAR 0 4
15935: PUSH
15936: DOUBLE
15937: LD_INT 0
15939: DEC
15940: ST_TO_ADDR
15941: LD_INT 5
15943: PUSH
15944: FOR_TO
15945: IFFALSE 16057
// begin _x := ShiftX ( x , i , 3 ) ;
15947: LD_ADDR_VAR 0 7
15951: PUSH
15952: LD_VAR 0 5
15956: PPUSH
15957: LD_VAR 0 4
15961: PPUSH
15962: LD_INT 3
15964: PPUSH
15965: CALL_OW 272
15969: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15970: LD_ADDR_VAR 0 8
15974: PUSH
15975: LD_VAR 0 6
15979: PPUSH
15980: LD_VAR 0 4
15984: PPUSH
15985: LD_INT 3
15987: PPUSH
15988: CALL_OW 273
15992: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15993: LD_VAR 0 7
15997: PPUSH
15998: LD_VAR 0 8
16002: PPUSH
16003: CALL_OW 488
16007: NOT
16008: IFFALSE 16012
// continue ;
16010: GO 15944
// if HexInfo ( _x , _y ) = 0 then
16012: LD_VAR 0 7
16016: PPUSH
16017: LD_VAR 0 8
16021: PPUSH
16022: CALL_OW 428
16026: PUSH
16027: LD_INT 0
16029: EQUAL
16030: IFFALSE 16055
// begin ComMoveXY ( unit , _x , _y ) ;
16032: LD_VAR 0 1
16036: PPUSH
16037: LD_VAR 0 7
16041: PPUSH
16042: LD_VAR 0 8
16046: PPUSH
16047: CALL_OW 111
// exit ;
16051: POP
16052: POP
16053: GO 16059
// end ; end ;
16055: GO 15944
16057: POP
16058: POP
// end ;
16059: LD_VAR 0 3
16063: RET
// export function ScanBase ( side , base_area ) ; begin
16064: LD_INT 0
16066: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16067: LD_ADDR_VAR 0 3
16071: PUSH
16072: LD_VAR 0 2
16076: PPUSH
16077: LD_INT 81
16079: PUSH
16080: LD_VAR 0 1
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: PPUSH
16089: CALL_OW 70
16093: ST_TO_ADDR
// end ;
16094: LD_VAR 0 3
16098: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16099: LD_INT 0
16101: PPUSH
16102: PPUSH
16103: PPUSH
16104: PPUSH
// result := false ;
16105: LD_ADDR_VAR 0 2
16109: PUSH
16110: LD_INT 0
16112: ST_TO_ADDR
// side := GetSide ( unit ) ;
16113: LD_ADDR_VAR 0 3
16117: PUSH
16118: LD_VAR 0 1
16122: PPUSH
16123: CALL_OW 255
16127: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16128: LD_ADDR_VAR 0 4
16132: PUSH
16133: LD_VAR 0 1
16137: PPUSH
16138: CALL_OW 248
16142: ST_TO_ADDR
// case nat of 1 :
16143: LD_VAR 0 4
16147: PUSH
16148: LD_INT 1
16150: DOUBLE
16151: EQUAL
16152: IFTRUE 16156
16154: GO 16167
16156: POP
// tech := tech_lassight ; 2 :
16157: LD_ADDR_VAR 0 5
16161: PUSH
16162: LD_INT 12
16164: ST_TO_ADDR
16165: GO 16206
16167: LD_INT 2
16169: DOUBLE
16170: EQUAL
16171: IFTRUE 16175
16173: GO 16186
16175: POP
// tech := tech_mortar ; 3 :
16176: LD_ADDR_VAR 0 5
16180: PUSH
16181: LD_INT 41
16183: ST_TO_ADDR
16184: GO 16206
16186: LD_INT 3
16188: DOUBLE
16189: EQUAL
16190: IFTRUE 16194
16192: GO 16205
16194: POP
// tech := tech_bazooka ; end ;
16195: LD_ADDR_VAR 0 5
16199: PUSH
16200: LD_INT 44
16202: ST_TO_ADDR
16203: GO 16206
16205: POP
// if Researched ( side , tech ) then
16206: LD_VAR 0 3
16210: PPUSH
16211: LD_VAR 0 5
16215: PPUSH
16216: CALL_OW 325
16220: IFFALSE 16247
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16222: LD_ADDR_VAR 0 2
16226: PUSH
16227: LD_INT 5
16229: PUSH
16230: LD_INT 8
16232: PUSH
16233: LD_INT 9
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: LIST
16240: PUSH
16241: LD_VAR 0 4
16245: ARRAY
16246: ST_TO_ADDR
// end ;
16247: LD_VAR 0 2
16251: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16252: LD_INT 0
16254: PPUSH
16255: PPUSH
16256: PPUSH
// if not mines then
16257: LD_VAR 0 2
16261: NOT
16262: IFFALSE 16266
// exit ;
16264: GO 16410
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16266: LD_ADDR_VAR 0 5
16270: PUSH
16271: LD_INT 81
16273: PUSH
16274: LD_VAR 0 1
16278: PUSH
16279: EMPTY
16280: LIST
16281: LIST
16282: PUSH
16283: LD_INT 3
16285: PUSH
16286: LD_INT 21
16288: PUSH
16289: LD_INT 3
16291: PUSH
16292: EMPTY
16293: LIST
16294: LIST
16295: PUSH
16296: EMPTY
16297: LIST
16298: LIST
16299: PUSH
16300: EMPTY
16301: LIST
16302: LIST
16303: PPUSH
16304: CALL_OW 69
16308: ST_TO_ADDR
// for i in mines do
16309: LD_ADDR_VAR 0 4
16313: PUSH
16314: LD_VAR 0 2
16318: PUSH
16319: FOR_IN
16320: IFFALSE 16408
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16322: LD_VAR 0 4
16326: PUSH
16327: LD_INT 1
16329: ARRAY
16330: PPUSH
16331: LD_VAR 0 4
16335: PUSH
16336: LD_INT 2
16338: ARRAY
16339: PPUSH
16340: CALL_OW 458
16344: NOT
16345: IFFALSE 16349
// continue ;
16347: GO 16319
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16349: LD_VAR 0 4
16353: PUSH
16354: LD_INT 1
16356: ARRAY
16357: PPUSH
16358: LD_VAR 0 4
16362: PUSH
16363: LD_INT 2
16365: ARRAY
16366: PPUSH
16367: CALL_OW 428
16371: PUSH
16372: LD_VAR 0 5
16376: IN
16377: IFFALSE 16406
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16379: LD_VAR 0 4
16383: PUSH
16384: LD_INT 1
16386: ARRAY
16387: PPUSH
16388: LD_VAR 0 4
16392: PUSH
16393: LD_INT 2
16395: ARRAY
16396: PPUSH
16397: LD_VAR 0 1
16401: PPUSH
16402: CALL_OW 456
// end ;
16406: GO 16319
16408: POP
16409: POP
// end ;
16410: LD_VAR 0 3
16414: RET
// export function Count ( array ) ; var i ; begin
16415: LD_INT 0
16417: PPUSH
16418: PPUSH
// result := 0 ;
16419: LD_ADDR_VAR 0 2
16423: PUSH
16424: LD_INT 0
16426: ST_TO_ADDR
// for i in array do
16427: LD_ADDR_VAR 0 3
16431: PUSH
16432: LD_VAR 0 1
16436: PUSH
16437: FOR_IN
16438: IFFALSE 16462
// if i then
16440: LD_VAR 0 3
16444: IFFALSE 16460
// result := result + 1 ;
16446: LD_ADDR_VAR 0 2
16450: PUSH
16451: LD_VAR 0 2
16455: PUSH
16456: LD_INT 1
16458: PLUS
16459: ST_TO_ADDR
16460: GO 16437
16462: POP
16463: POP
// end ;
16464: LD_VAR 0 2
16468: RET
// export function IsEmpty ( building ) ; begin
16469: LD_INT 0
16471: PPUSH
// if not building then
16472: LD_VAR 0 1
16476: NOT
16477: IFFALSE 16481
// exit ;
16479: GO 16524
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16481: LD_ADDR_VAR 0 2
16485: PUSH
16486: LD_VAR 0 1
16490: PUSH
16491: LD_INT 22
16493: PUSH
16494: LD_VAR 0 1
16498: PPUSH
16499: CALL_OW 255
16503: PUSH
16504: EMPTY
16505: LIST
16506: LIST
16507: PUSH
16508: LD_INT 58
16510: PUSH
16511: EMPTY
16512: LIST
16513: PUSH
16514: EMPTY
16515: LIST
16516: LIST
16517: PPUSH
16518: CALL_OW 69
16522: IN
16523: ST_TO_ADDR
// end ;
16524: LD_VAR 0 2
16528: RET
// export function IsNotFull ( building ) ; begin
16529: LD_INT 0
16531: PPUSH
// if not building then
16532: LD_VAR 0 1
16536: NOT
16537: IFFALSE 16541
// exit ;
16539: GO 16560
// result := UnitsInside ( building ) < 6 ;
16541: LD_ADDR_VAR 0 2
16545: PUSH
16546: LD_VAR 0 1
16550: PPUSH
16551: CALL_OW 313
16555: PUSH
16556: LD_INT 6
16558: LESS
16559: ST_TO_ADDR
// end ;
16560: LD_VAR 0 2
16564: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16565: LD_INT 0
16567: PPUSH
16568: PPUSH
16569: PPUSH
16570: PPUSH
// tmp := [ ] ;
16571: LD_ADDR_VAR 0 3
16575: PUSH
16576: EMPTY
16577: ST_TO_ADDR
// list := [ ] ;
16578: LD_ADDR_VAR 0 5
16582: PUSH
16583: EMPTY
16584: ST_TO_ADDR
// for i = 16 to 25 do
16585: LD_ADDR_VAR 0 4
16589: PUSH
16590: DOUBLE
16591: LD_INT 16
16593: DEC
16594: ST_TO_ADDR
16595: LD_INT 25
16597: PUSH
16598: FOR_TO
16599: IFFALSE 16672
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
16601: LD_ADDR_VAR 0 3
16605: PUSH
16606: LD_VAR 0 3
16610: PUSH
16611: LD_INT 22
16613: PUSH
16614: LD_VAR 0 1
16618: PPUSH
16619: CALL_OW 255
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: PUSH
16628: LD_INT 91
16630: PUSH
16631: LD_VAR 0 1
16635: PUSH
16636: LD_INT 6
16638: PUSH
16639: EMPTY
16640: LIST
16641: LIST
16642: LIST
16643: PUSH
16644: LD_INT 30
16646: PUSH
16647: LD_VAR 0 4
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: LIST
16660: PUSH
16661: EMPTY
16662: LIST
16663: PPUSH
16664: CALL_OW 69
16668: ADD
16669: ST_TO_ADDR
16670: GO 16598
16672: POP
16673: POP
// for i = 1 to tmp do
16674: LD_ADDR_VAR 0 4
16678: PUSH
16679: DOUBLE
16680: LD_INT 1
16682: DEC
16683: ST_TO_ADDR
16684: LD_VAR 0 3
16688: PUSH
16689: FOR_TO
16690: IFFALSE 16778
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
16692: LD_ADDR_VAR 0 5
16696: PUSH
16697: LD_VAR 0 5
16701: PUSH
16702: LD_VAR 0 3
16706: PUSH
16707: LD_VAR 0 4
16711: ARRAY
16712: PPUSH
16713: CALL_OW 266
16717: PUSH
16718: LD_VAR 0 3
16722: PUSH
16723: LD_VAR 0 4
16727: ARRAY
16728: PPUSH
16729: CALL_OW 250
16733: PUSH
16734: LD_VAR 0 3
16738: PUSH
16739: LD_VAR 0 4
16743: ARRAY
16744: PPUSH
16745: CALL_OW 251
16749: PUSH
16750: LD_VAR 0 3
16754: PUSH
16755: LD_VAR 0 4
16759: ARRAY
16760: PPUSH
16761: CALL_OW 254
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: LIST
16770: LIST
16771: PUSH
16772: EMPTY
16773: LIST
16774: ADD
16775: ST_TO_ADDR
16776: GO 16689
16778: POP
16779: POP
// result := list ;
16780: LD_ADDR_VAR 0 2
16784: PUSH
16785: LD_VAR 0 5
16789: ST_TO_ADDR
// end ;
16790: LD_VAR 0 2
16794: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16795: LD_INT 0
16797: PPUSH
16798: PPUSH
16799: PPUSH
16800: PPUSH
16801: PPUSH
16802: PPUSH
16803: PPUSH
// if not factory then
16804: LD_VAR 0 1
16808: NOT
16809: IFFALSE 16813
// exit ;
16811: GO 17406
// if control = control_apeman then
16813: LD_VAR 0 4
16817: PUSH
16818: LD_INT 5
16820: EQUAL
16821: IFFALSE 16930
// begin tmp := UnitsInside ( factory ) ;
16823: LD_ADDR_VAR 0 8
16827: PUSH
16828: LD_VAR 0 1
16832: PPUSH
16833: CALL_OW 313
16837: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16838: LD_VAR 0 8
16842: PPUSH
16843: LD_INT 25
16845: PUSH
16846: LD_INT 12
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PPUSH
16853: CALL_OW 72
16857: NOT
16858: IFFALSE 16868
// control := control_manual ;
16860: LD_ADDR_VAR 0 4
16864: PUSH
16865: LD_INT 1
16867: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16868: LD_ADDR_VAR 0 8
16872: PUSH
16873: LD_VAR 0 1
16877: PPUSH
16878: CALL 16565 0 1
16882: ST_TO_ADDR
// if tmp then
16883: LD_VAR 0 8
16887: IFFALSE 16930
// begin for i in tmp do
16889: LD_ADDR_VAR 0 7
16893: PUSH
16894: LD_VAR 0 8
16898: PUSH
16899: FOR_IN
16900: IFFALSE 16928
// if i [ 1 ] = b_ext_radio then
16902: LD_VAR 0 7
16906: PUSH
16907: LD_INT 1
16909: ARRAY
16910: PUSH
16911: LD_INT 22
16913: EQUAL
16914: IFFALSE 16926
// begin control := control_remote ;
16916: LD_ADDR_VAR 0 4
16920: PUSH
16921: LD_INT 2
16923: ST_TO_ADDR
// break ;
16924: GO 16928
// end ;
16926: GO 16899
16928: POP
16929: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16930: LD_VAR 0 1
16934: PPUSH
16935: LD_VAR 0 2
16939: PPUSH
16940: LD_VAR 0 3
16944: PPUSH
16945: LD_VAR 0 4
16949: PPUSH
16950: LD_VAR 0 5
16954: PPUSH
16955: CALL_OW 448
16959: IFFALSE 16994
// begin result := [ chassis , engine , control , weapon ] ;
16961: LD_ADDR_VAR 0 6
16965: PUSH
16966: LD_VAR 0 2
16970: PUSH
16971: LD_VAR 0 3
16975: PUSH
16976: LD_VAR 0 4
16980: PUSH
16981: LD_VAR 0 5
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: ST_TO_ADDR
// exit ;
16992: GO 17406
// end ; _chassis := AvailableChassisList ( factory ) ;
16994: LD_ADDR_VAR 0 9
16998: PUSH
16999: LD_VAR 0 1
17003: PPUSH
17004: CALL_OW 475
17008: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17009: LD_ADDR_VAR 0 11
17013: PUSH
17014: LD_VAR 0 1
17018: PPUSH
17019: CALL_OW 476
17023: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17024: LD_ADDR_VAR 0 12
17028: PUSH
17029: LD_VAR 0 1
17033: PPUSH
17034: CALL_OW 477
17038: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17039: LD_ADDR_VAR 0 10
17043: PUSH
17044: LD_VAR 0 1
17048: PPUSH
17049: CALL_OW 478
17053: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17054: LD_VAR 0 9
17058: NOT
17059: PUSH
17060: LD_VAR 0 11
17064: NOT
17065: OR
17066: PUSH
17067: LD_VAR 0 12
17071: NOT
17072: OR
17073: PUSH
17074: LD_VAR 0 10
17078: NOT
17079: OR
17080: IFFALSE 17115
// begin result := [ chassis , engine , control , weapon ] ;
17082: LD_ADDR_VAR 0 6
17086: PUSH
17087: LD_VAR 0 2
17091: PUSH
17092: LD_VAR 0 3
17096: PUSH
17097: LD_VAR 0 4
17101: PUSH
17102: LD_VAR 0 5
17106: PUSH
17107: EMPTY
17108: LIST
17109: LIST
17110: LIST
17111: LIST
17112: ST_TO_ADDR
// exit ;
17113: GO 17406
// end ; if not chassis in _chassis then
17115: LD_VAR 0 2
17119: PUSH
17120: LD_VAR 0 9
17124: IN
17125: NOT
17126: IFFALSE 17152
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17128: LD_ADDR_VAR 0 2
17132: PUSH
17133: LD_VAR 0 9
17137: PUSH
17138: LD_INT 1
17140: PPUSH
17141: LD_VAR 0 9
17145: PPUSH
17146: CALL_OW 12
17150: ARRAY
17151: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17152: LD_VAR 0 2
17156: PPUSH
17157: LD_VAR 0 3
17161: PPUSH
17162: CALL 17411 0 2
17166: NOT
17167: IFFALSE 17226
// repeat engine := _engine [ 1 ] ;
17169: LD_ADDR_VAR 0 3
17173: PUSH
17174: LD_VAR 0 11
17178: PUSH
17179: LD_INT 1
17181: ARRAY
17182: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17183: LD_ADDR_VAR 0 11
17187: PUSH
17188: LD_VAR 0 11
17192: PPUSH
17193: LD_INT 1
17195: PPUSH
17196: CALL_OW 3
17200: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17201: LD_VAR 0 2
17205: PPUSH
17206: LD_VAR 0 3
17210: PPUSH
17211: CALL 17411 0 2
17215: PUSH
17216: LD_VAR 0 11
17220: PUSH
17221: EMPTY
17222: EQUAL
17223: OR
17224: IFFALSE 17169
// if not control in _control then
17226: LD_VAR 0 4
17230: PUSH
17231: LD_VAR 0 12
17235: IN
17236: NOT
17237: IFFALSE 17263
// control := _control [ rand ( 1 , _control ) ] ;
17239: LD_ADDR_VAR 0 4
17243: PUSH
17244: LD_VAR 0 12
17248: PUSH
17249: LD_INT 1
17251: PPUSH
17252: LD_VAR 0 12
17256: PPUSH
17257: CALL_OW 12
17261: ARRAY
17262: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17263: LD_VAR 0 2
17267: PPUSH
17268: LD_VAR 0 5
17272: PPUSH
17273: CALL 17631 0 2
17277: NOT
17278: IFFALSE 17337
// repeat weapon := _weapon [ 1 ] ;
17280: LD_ADDR_VAR 0 5
17284: PUSH
17285: LD_VAR 0 10
17289: PUSH
17290: LD_INT 1
17292: ARRAY
17293: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17294: LD_ADDR_VAR 0 10
17298: PUSH
17299: LD_VAR 0 10
17303: PPUSH
17304: LD_INT 1
17306: PPUSH
17307: CALL_OW 3
17311: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17312: LD_VAR 0 2
17316: PPUSH
17317: LD_VAR 0 5
17321: PPUSH
17322: CALL 17631 0 2
17326: PUSH
17327: LD_VAR 0 10
17331: PUSH
17332: EMPTY
17333: EQUAL
17334: OR
17335: IFFALSE 17280
// result := [ ] ;
17337: LD_ADDR_VAR 0 6
17341: PUSH
17342: EMPTY
17343: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17344: LD_VAR 0 1
17348: PPUSH
17349: LD_VAR 0 2
17353: PPUSH
17354: LD_VAR 0 3
17358: PPUSH
17359: LD_VAR 0 4
17363: PPUSH
17364: LD_VAR 0 5
17368: PPUSH
17369: CALL_OW 448
17373: IFFALSE 17406
// result := [ chassis , engine , control , weapon ] ;
17375: LD_ADDR_VAR 0 6
17379: PUSH
17380: LD_VAR 0 2
17384: PUSH
17385: LD_VAR 0 3
17389: PUSH
17390: LD_VAR 0 4
17394: PUSH
17395: LD_VAR 0 5
17399: PUSH
17400: EMPTY
17401: LIST
17402: LIST
17403: LIST
17404: LIST
17405: ST_TO_ADDR
// end ;
17406: LD_VAR 0 6
17410: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17411: LD_INT 0
17413: PPUSH
// if not chassis or not engine then
17414: LD_VAR 0 1
17418: NOT
17419: PUSH
17420: LD_VAR 0 2
17424: NOT
17425: OR
17426: IFFALSE 17430
// exit ;
17428: GO 17626
// case engine of engine_solar :
17430: LD_VAR 0 2
17434: PUSH
17435: LD_INT 2
17437: DOUBLE
17438: EQUAL
17439: IFTRUE 17443
17441: GO 17481
17443: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17444: LD_ADDR_VAR 0 3
17448: PUSH
17449: LD_INT 11
17451: PUSH
17452: LD_INT 12
17454: PUSH
17455: LD_INT 13
17457: PUSH
17458: LD_INT 14
17460: PUSH
17461: LD_INT 1
17463: PUSH
17464: LD_INT 2
17466: PUSH
17467: LD_INT 3
17469: PUSH
17470: EMPTY
17471: LIST
17472: LIST
17473: LIST
17474: LIST
17475: LIST
17476: LIST
17477: LIST
17478: ST_TO_ADDR
17479: GO 17610
17481: LD_INT 1
17483: DOUBLE
17484: EQUAL
17485: IFTRUE 17489
17487: GO 17551
17489: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17490: LD_ADDR_VAR 0 3
17494: PUSH
17495: LD_INT 11
17497: PUSH
17498: LD_INT 12
17500: PUSH
17501: LD_INT 13
17503: PUSH
17504: LD_INT 14
17506: PUSH
17507: LD_INT 1
17509: PUSH
17510: LD_INT 2
17512: PUSH
17513: LD_INT 3
17515: PUSH
17516: LD_INT 4
17518: PUSH
17519: LD_INT 5
17521: PUSH
17522: LD_INT 21
17524: PUSH
17525: LD_INT 23
17527: PUSH
17528: LD_INT 22
17530: PUSH
17531: LD_INT 24
17533: PUSH
17534: EMPTY
17535: LIST
17536: LIST
17537: LIST
17538: LIST
17539: LIST
17540: LIST
17541: LIST
17542: LIST
17543: LIST
17544: LIST
17545: LIST
17546: LIST
17547: LIST
17548: ST_TO_ADDR
17549: GO 17610
17551: LD_INT 3
17553: DOUBLE
17554: EQUAL
17555: IFTRUE 17559
17557: GO 17609
17559: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17560: LD_ADDR_VAR 0 3
17564: PUSH
17565: LD_INT 13
17567: PUSH
17568: LD_INT 14
17570: PUSH
17571: LD_INT 2
17573: PUSH
17574: LD_INT 3
17576: PUSH
17577: LD_INT 4
17579: PUSH
17580: LD_INT 5
17582: PUSH
17583: LD_INT 21
17585: PUSH
17586: LD_INT 22
17588: PUSH
17589: LD_INT 23
17591: PUSH
17592: LD_INT 24
17594: PUSH
17595: EMPTY
17596: LIST
17597: LIST
17598: LIST
17599: LIST
17600: LIST
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: ST_TO_ADDR
17607: GO 17610
17609: POP
// result := ( chassis in result ) ;
17610: LD_ADDR_VAR 0 3
17614: PUSH
17615: LD_VAR 0 1
17619: PUSH
17620: LD_VAR 0 3
17624: IN
17625: ST_TO_ADDR
// end ;
17626: LD_VAR 0 3
17630: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
17631: LD_INT 0
17633: PPUSH
// if not chassis or not weapon then
17634: LD_VAR 0 1
17638: NOT
17639: PUSH
17640: LD_VAR 0 2
17644: NOT
17645: OR
17646: IFFALSE 17650
// exit ;
17648: GO 18676
// case weapon of us_machine_gun :
17650: LD_VAR 0 2
17654: PUSH
17655: LD_INT 2
17657: DOUBLE
17658: EQUAL
17659: IFTRUE 17663
17661: GO 17693
17663: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
17664: LD_ADDR_VAR 0 3
17668: PUSH
17669: LD_INT 1
17671: PUSH
17672: LD_INT 2
17674: PUSH
17675: LD_INT 3
17677: PUSH
17678: LD_INT 4
17680: PUSH
17681: LD_INT 5
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: LIST
17688: LIST
17689: LIST
17690: ST_TO_ADDR
17691: GO 18660
17693: LD_INT 3
17695: DOUBLE
17696: EQUAL
17697: IFTRUE 17701
17699: GO 17731
17701: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17702: LD_ADDR_VAR 0 3
17706: PUSH
17707: LD_INT 1
17709: PUSH
17710: LD_INT 2
17712: PUSH
17713: LD_INT 3
17715: PUSH
17716: LD_INT 4
17718: PUSH
17719: LD_INT 5
17721: PUSH
17722: EMPTY
17723: LIST
17724: LIST
17725: LIST
17726: LIST
17727: LIST
17728: ST_TO_ADDR
17729: GO 18660
17731: LD_INT 11
17733: DOUBLE
17734: EQUAL
17735: IFTRUE 17739
17737: GO 17769
17739: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17740: LD_ADDR_VAR 0 3
17744: PUSH
17745: LD_INT 1
17747: PUSH
17748: LD_INT 2
17750: PUSH
17751: LD_INT 3
17753: PUSH
17754: LD_INT 4
17756: PUSH
17757: LD_INT 5
17759: PUSH
17760: EMPTY
17761: LIST
17762: LIST
17763: LIST
17764: LIST
17765: LIST
17766: ST_TO_ADDR
17767: GO 18660
17769: LD_INT 4
17771: DOUBLE
17772: EQUAL
17773: IFTRUE 17777
17775: GO 17803
17777: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17778: LD_ADDR_VAR 0 3
17782: PUSH
17783: LD_INT 2
17785: PUSH
17786: LD_INT 3
17788: PUSH
17789: LD_INT 4
17791: PUSH
17792: LD_INT 5
17794: PUSH
17795: EMPTY
17796: LIST
17797: LIST
17798: LIST
17799: LIST
17800: ST_TO_ADDR
17801: GO 18660
17803: LD_INT 5
17805: DOUBLE
17806: EQUAL
17807: IFTRUE 17811
17809: GO 17837
17811: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17812: LD_ADDR_VAR 0 3
17816: PUSH
17817: LD_INT 2
17819: PUSH
17820: LD_INT 3
17822: PUSH
17823: LD_INT 4
17825: PUSH
17826: LD_INT 5
17828: PUSH
17829: EMPTY
17830: LIST
17831: LIST
17832: LIST
17833: LIST
17834: ST_TO_ADDR
17835: GO 18660
17837: LD_INT 9
17839: DOUBLE
17840: EQUAL
17841: IFTRUE 17845
17843: GO 17871
17845: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17846: LD_ADDR_VAR 0 3
17850: PUSH
17851: LD_INT 2
17853: PUSH
17854: LD_INT 3
17856: PUSH
17857: LD_INT 4
17859: PUSH
17860: LD_INT 5
17862: PUSH
17863: EMPTY
17864: LIST
17865: LIST
17866: LIST
17867: LIST
17868: ST_TO_ADDR
17869: GO 18660
17871: LD_INT 7
17873: DOUBLE
17874: EQUAL
17875: IFTRUE 17879
17877: GO 17905
17879: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17880: LD_ADDR_VAR 0 3
17884: PUSH
17885: LD_INT 2
17887: PUSH
17888: LD_INT 3
17890: PUSH
17891: LD_INT 4
17893: PUSH
17894: LD_INT 5
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: LIST
17901: LIST
17902: ST_TO_ADDR
17903: GO 18660
17905: LD_INT 12
17907: DOUBLE
17908: EQUAL
17909: IFTRUE 17913
17911: GO 17939
17913: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17914: LD_ADDR_VAR 0 3
17918: PUSH
17919: LD_INT 2
17921: PUSH
17922: LD_INT 3
17924: PUSH
17925: LD_INT 4
17927: PUSH
17928: LD_INT 5
17930: PUSH
17931: EMPTY
17932: LIST
17933: LIST
17934: LIST
17935: LIST
17936: ST_TO_ADDR
17937: GO 18660
17939: LD_INT 13
17941: DOUBLE
17942: EQUAL
17943: IFTRUE 17947
17945: GO 17973
17947: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17948: LD_ADDR_VAR 0 3
17952: PUSH
17953: LD_INT 2
17955: PUSH
17956: LD_INT 3
17958: PUSH
17959: LD_INT 4
17961: PUSH
17962: LD_INT 5
17964: PUSH
17965: EMPTY
17966: LIST
17967: LIST
17968: LIST
17969: LIST
17970: ST_TO_ADDR
17971: GO 18660
17973: LD_INT 14
17975: DOUBLE
17976: EQUAL
17977: IFTRUE 17981
17979: GO 17999
17981: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17982: LD_ADDR_VAR 0 3
17986: PUSH
17987: LD_INT 4
17989: PUSH
17990: LD_INT 5
17992: PUSH
17993: EMPTY
17994: LIST
17995: LIST
17996: ST_TO_ADDR
17997: GO 18660
17999: LD_INT 6
18001: DOUBLE
18002: EQUAL
18003: IFTRUE 18007
18005: GO 18025
18007: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18008: LD_ADDR_VAR 0 3
18012: PUSH
18013: LD_INT 4
18015: PUSH
18016: LD_INT 5
18018: PUSH
18019: EMPTY
18020: LIST
18021: LIST
18022: ST_TO_ADDR
18023: GO 18660
18025: LD_INT 10
18027: DOUBLE
18028: EQUAL
18029: IFTRUE 18033
18031: GO 18051
18033: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18034: LD_ADDR_VAR 0 3
18038: PUSH
18039: LD_INT 4
18041: PUSH
18042: LD_INT 5
18044: PUSH
18045: EMPTY
18046: LIST
18047: LIST
18048: ST_TO_ADDR
18049: GO 18660
18051: LD_INT 22
18053: DOUBLE
18054: EQUAL
18055: IFTRUE 18059
18057: GO 18085
18059: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18060: LD_ADDR_VAR 0 3
18064: PUSH
18065: LD_INT 11
18067: PUSH
18068: LD_INT 12
18070: PUSH
18071: LD_INT 13
18073: PUSH
18074: LD_INT 14
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: LIST
18081: LIST
18082: ST_TO_ADDR
18083: GO 18660
18085: LD_INT 23
18087: DOUBLE
18088: EQUAL
18089: IFTRUE 18093
18091: GO 18119
18093: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18094: LD_ADDR_VAR 0 3
18098: PUSH
18099: LD_INT 11
18101: PUSH
18102: LD_INT 12
18104: PUSH
18105: LD_INT 13
18107: PUSH
18108: LD_INT 14
18110: PUSH
18111: EMPTY
18112: LIST
18113: LIST
18114: LIST
18115: LIST
18116: ST_TO_ADDR
18117: GO 18660
18119: LD_INT 24
18121: DOUBLE
18122: EQUAL
18123: IFTRUE 18127
18125: GO 18153
18127: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18128: LD_ADDR_VAR 0 3
18132: PUSH
18133: LD_INT 11
18135: PUSH
18136: LD_INT 12
18138: PUSH
18139: LD_INT 13
18141: PUSH
18142: LD_INT 14
18144: PUSH
18145: EMPTY
18146: LIST
18147: LIST
18148: LIST
18149: LIST
18150: ST_TO_ADDR
18151: GO 18660
18153: LD_INT 30
18155: DOUBLE
18156: EQUAL
18157: IFTRUE 18161
18159: GO 18187
18161: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18162: LD_ADDR_VAR 0 3
18166: PUSH
18167: LD_INT 11
18169: PUSH
18170: LD_INT 12
18172: PUSH
18173: LD_INT 13
18175: PUSH
18176: LD_INT 14
18178: PUSH
18179: EMPTY
18180: LIST
18181: LIST
18182: LIST
18183: LIST
18184: ST_TO_ADDR
18185: GO 18660
18187: LD_INT 25
18189: DOUBLE
18190: EQUAL
18191: IFTRUE 18195
18193: GO 18213
18195: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18196: LD_ADDR_VAR 0 3
18200: PUSH
18201: LD_INT 13
18203: PUSH
18204: LD_INT 14
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: ST_TO_ADDR
18211: GO 18660
18213: LD_INT 27
18215: DOUBLE
18216: EQUAL
18217: IFTRUE 18221
18219: GO 18239
18221: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18222: LD_ADDR_VAR 0 3
18226: PUSH
18227: LD_INT 13
18229: PUSH
18230: LD_INT 14
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: ST_TO_ADDR
18237: GO 18660
18239: LD_INT 28
18241: DOUBLE
18242: EQUAL
18243: IFTRUE 18247
18245: GO 18265
18247: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18248: LD_ADDR_VAR 0 3
18252: PUSH
18253: LD_INT 13
18255: PUSH
18256: LD_INT 14
18258: PUSH
18259: EMPTY
18260: LIST
18261: LIST
18262: ST_TO_ADDR
18263: GO 18660
18265: LD_INT 29
18267: DOUBLE
18268: EQUAL
18269: IFTRUE 18273
18271: GO 18291
18273: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18274: LD_ADDR_VAR 0 3
18278: PUSH
18279: LD_INT 13
18281: PUSH
18282: LD_INT 14
18284: PUSH
18285: EMPTY
18286: LIST
18287: LIST
18288: ST_TO_ADDR
18289: GO 18660
18291: LD_INT 31
18293: DOUBLE
18294: EQUAL
18295: IFTRUE 18299
18297: GO 18317
18299: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18300: LD_ADDR_VAR 0 3
18304: PUSH
18305: LD_INT 13
18307: PUSH
18308: LD_INT 14
18310: PUSH
18311: EMPTY
18312: LIST
18313: LIST
18314: ST_TO_ADDR
18315: GO 18660
18317: LD_INT 26
18319: DOUBLE
18320: EQUAL
18321: IFTRUE 18325
18323: GO 18343
18325: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18326: LD_ADDR_VAR 0 3
18330: PUSH
18331: LD_INT 13
18333: PUSH
18334: LD_INT 14
18336: PUSH
18337: EMPTY
18338: LIST
18339: LIST
18340: ST_TO_ADDR
18341: GO 18660
18343: LD_INT 42
18345: DOUBLE
18346: EQUAL
18347: IFTRUE 18351
18349: GO 18377
18351: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18352: LD_ADDR_VAR 0 3
18356: PUSH
18357: LD_INT 21
18359: PUSH
18360: LD_INT 22
18362: PUSH
18363: LD_INT 23
18365: PUSH
18366: LD_INT 24
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: LIST
18373: LIST
18374: ST_TO_ADDR
18375: GO 18660
18377: LD_INT 43
18379: DOUBLE
18380: EQUAL
18381: IFTRUE 18385
18383: GO 18411
18385: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18386: LD_ADDR_VAR 0 3
18390: PUSH
18391: LD_INT 21
18393: PUSH
18394: LD_INT 22
18396: PUSH
18397: LD_INT 23
18399: PUSH
18400: LD_INT 24
18402: PUSH
18403: EMPTY
18404: LIST
18405: LIST
18406: LIST
18407: LIST
18408: ST_TO_ADDR
18409: GO 18660
18411: LD_INT 44
18413: DOUBLE
18414: EQUAL
18415: IFTRUE 18419
18417: GO 18445
18419: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18420: LD_ADDR_VAR 0 3
18424: PUSH
18425: LD_INT 21
18427: PUSH
18428: LD_INT 22
18430: PUSH
18431: LD_INT 23
18433: PUSH
18434: LD_INT 24
18436: PUSH
18437: EMPTY
18438: LIST
18439: LIST
18440: LIST
18441: LIST
18442: ST_TO_ADDR
18443: GO 18660
18445: LD_INT 45
18447: DOUBLE
18448: EQUAL
18449: IFTRUE 18453
18451: GO 18479
18453: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18454: LD_ADDR_VAR 0 3
18458: PUSH
18459: LD_INT 21
18461: PUSH
18462: LD_INT 22
18464: PUSH
18465: LD_INT 23
18467: PUSH
18468: LD_INT 24
18470: PUSH
18471: EMPTY
18472: LIST
18473: LIST
18474: LIST
18475: LIST
18476: ST_TO_ADDR
18477: GO 18660
18479: LD_INT 49
18481: DOUBLE
18482: EQUAL
18483: IFTRUE 18487
18485: GO 18513
18487: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
18488: LD_ADDR_VAR 0 3
18492: PUSH
18493: LD_INT 21
18495: PUSH
18496: LD_INT 22
18498: PUSH
18499: LD_INT 23
18501: PUSH
18502: LD_INT 24
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: LIST
18509: LIST
18510: ST_TO_ADDR
18511: GO 18660
18513: LD_INT 51
18515: DOUBLE
18516: EQUAL
18517: IFTRUE 18521
18519: GO 18547
18521: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18522: LD_ADDR_VAR 0 3
18526: PUSH
18527: LD_INT 21
18529: PUSH
18530: LD_INT 22
18532: PUSH
18533: LD_INT 23
18535: PUSH
18536: LD_INT 24
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: LIST
18543: LIST
18544: ST_TO_ADDR
18545: GO 18660
18547: LD_INT 52
18549: DOUBLE
18550: EQUAL
18551: IFTRUE 18555
18553: GO 18581
18555: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18556: LD_ADDR_VAR 0 3
18560: PUSH
18561: LD_INT 21
18563: PUSH
18564: LD_INT 22
18566: PUSH
18567: LD_INT 23
18569: PUSH
18570: LD_INT 24
18572: PUSH
18573: EMPTY
18574: LIST
18575: LIST
18576: LIST
18577: LIST
18578: ST_TO_ADDR
18579: GO 18660
18581: LD_INT 53
18583: DOUBLE
18584: EQUAL
18585: IFTRUE 18589
18587: GO 18607
18589: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
18590: LD_ADDR_VAR 0 3
18594: PUSH
18595: LD_INT 23
18597: PUSH
18598: LD_INT 24
18600: PUSH
18601: EMPTY
18602: LIST
18603: LIST
18604: ST_TO_ADDR
18605: GO 18660
18607: LD_INT 46
18609: DOUBLE
18610: EQUAL
18611: IFTRUE 18615
18613: GO 18633
18615: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
18616: LD_ADDR_VAR 0 3
18620: PUSH
18621: LD_INT 23
18623: PUSH
18624: LD_INT 24
18626: PUSH
18627: EMPTY
18628: LIST
18629: LIST
18630: ST_TO_ADDR
18631: GO 18660
18633: LD_INT 47
18635: DOUBLE
18636: EQUAL
18637: IFTRUE 18641
18639: GO 18659
18641: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18642: LD_ADDR_VAR 0 3
18646: PUSH
18647: LD_INT 23
18649: PUSH
18650: LD_INT 24
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: ST_TO_ADDR
18657: GO 18660
18659: POP
// result := ( chassis in result ) ;
18660: LD_ADDR_VAR 0 3
18664: PUSH
18665: LD_VAR 0 1
18669: PUSH
18670: LD_VAR 0 3
18674: IN
18675: ST_TO_ADDR
// end ;
18676: LD_VAR 0 3
18680: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18681: LD_INT 0
18683: PPUSH
18684: PPUSH
18685: PPUSH
18686: PPUSH
18687: PPUSH
18688: PPUSH
18689: PPUSH
// result := array ;
18690: LD_ADDR_VAR 0 5
18694: PUSH
18695: LD_VAR 0 1
18699: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18700: LD_VAR 0 1
18704: NOT
18705: PUSH
18706: LD_VAR 0 2
18710: NOT
18711: OR
18712: PUSH
18713: LD_VAR 0 3
18717: NOT
18718: OR
18719: PUSH
18720: LD_VAR 0 2
18724: PUSH
18725: LD_VAR 0 1
18729: GREATER
18730: OR
18731: PUSH
18732: LD_VAR 0 3
18736: PUSH
18737: LD_VAR 0 1
18741: GREATER
18742: OR
18743: IFFALSE 18747
// exit ;
18745: GO 19043
// if direction then
18747: LD_VAR 0 4
18751: IFFALSE 18815
// begin d := 1 ;
18753: LD_ADDR_VAR 0 9
18757: PUSH
18758: LD_INT 1
18760: ST_TO_ADDR
// if i_from > i_to then
18761: LD_VAR 0 2
18765: PUSH
18766: LD_VAR 0 3
18770: GREATER
18771: IFFALSE 18797
// length := ( array - i_from ) + i_to else
18773: LD_ADDR_VAR 0 11
18777: PUSH
18778: LD_VAR 0 1
18782: PUSH
18783: LD_VAR 0 2
18787: MINUS
18788: PUSH
18789: LD_VAR 0 3
18793: PLUS
18794: ST_TO_ADDR
18795: GO 18813
// length := i_to - i_from ;
18797: LD_ADDR_VAR 0 11
18801: PUSH
18802: LD_VAR 0 3
18806: PUSH
18807: LD_VAR 0 2
18811: MINUS
18812: ST_TO_ADDR
// end else
18813: GO 18876
// begin d := - 1 ;
18815: LD_ADDR_VAR 0 9
18819: PUSH
18820: LD_INT 1
18822: NEG
18823: ST_TO_ADDR
// if i_from > i_to then
18824: LD_VAR 0 2
18828: PUSH
18829: LD_VAR 0 3
18833: GREATER
18834: IFFALSE 18854
// length := i_from - i_to else
18836: LD_ADDR_VAR 0 11
18840: PUSH
18841: LD_VAR 0 2
18845: PUSH
18846: LD_VAR 0 3
18850: MINUS
18851: ST_TO_ADDR
18852: GO 18876
// length := ( array - i_to ) + i_from ;
18854: LD_ADDR_VAR 0 11
18858: PUSH
18859: LD_VAR 0 1
18863: PUSH
18864: LD_VAR 0 3
18868: MINUS
18869: PUSH
18870: LD_VAR 0 2
18874: PLUS
18875: ST_TO_ADDR
// end ; if not length then
18876: LD_VAR 0 11
18880: NOT
18881: IFFALSE 18885
// exit ;
18883: GO 19043
// tmp := array ;
18885: LD_ADDR_VAR 0 10
18889: PUSH
18890: LD_VAR 0 1
18894: ST_TO_ADDR
// for i = 1 to length do
18895: LD_ADDR_VAR 0 6
18899: PUSH
18900: DOUBLE
18901: LD_INT 1
18903: DEC
18904: ST_TO_ADDR
18905: LD_VAR 0 11
18909: PUSH
18910: FOR_TO
18911: IFFALSE 19031
// begin for j = 1 to array do
18913: LD_ADDR_VAR 0 7
18917: PUSH
18918: DOUBLE
18919: LD_INT 1
18921: DEC
18922: ST_TO_ADDR
18923: LD_VAR 0 1
18927: PUSH
18928: FOR_TO
18929: IFFALSE 19017
// begin k := j + d ;
18931: LD_ADDR_VAR 0 8
18935: PUSH
18936: LD_VAR 0 7
18940: PUSH
18941: LD_VAR 0 9
18945: PLUS
18946: ST_TO_ADDR
// if k > array then
18947: LD_VAR 0 8
18951: PUSH
18952: LD_VAR 0 1
18956: GREATER
18957: IFFALSE 18967
// k := 1 ;
18959: LD_ADDR_VAR 0 8
18963: PUSH
18964: LD_INT 1
18966: ST_TO_ADDR
// if not k then
18967: LD_VAR 0 8
18971: NOT
18972: IFFALSE 18984
// k := array ;
18974: LD_ADDR_VAR 0 8
18978: PUSH
18979: LD_VAR 0 1
18983: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18984: LD_ADDR_VAR 0 10
18988: PUSH
18989: LD_VAR 0 10
18993: PPUSH
18994: LD_VAR 0 8
18998: PPUSH
18999: LD_VAR 0 1
19003: PUSH
19004: LD_VAR 0 7
19008: ARRAY
19009: PPUSH
19010: CALL_OW 1
19014: ST_TO_ADDR
// end ;
19015: GO 18928
19017: POP
19018: POP
// array := tmp ;
19019: LD_ADDR_VAR 0 1
19023: PUSH
19024: LD_VAR 0 10
19028: ST_TO_ADDR
// end ;
19029: GO 18910
19031: POP
19032: POP
// result := array ;
19033: LD_ADDR_VAR 0 5
19037: PUSH
19038: LD_VAR 0 1
19042: ST_TO_ADDR
// end ;
19043: LD_VAR 0 5
19047: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19048: LD_INT 0
19050: PPUSH
19051: PPUSH
// result := 0 ;
19052: LD_ADDR_VAR 0 3
19056: PUSH
19057: LD_INT 0
19059: ST_TO_ADDR
// if not array or not value in array then
19060: LD_VAR 0 1
19064: NOT
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 1
19075: IN
19076: NOT
19077: OR
19078: IFFALSE 19082
// exit ;
19080: GO 19136
// for i = 1 to array do
19082: LD_ADDR_VAR 0 4
19086: PUSH
19087: DOUBLE
19088: LD_INT 1
19090: DEC
19091: ST_TO_ADDR
19092: LD_VAR 0 1
19096: PUSH
19097: FOR_TO
19098: IFFALSE 19134
// if value = array [ i ] then
19100: LD_VAR 0 2
19104: PUSH
19105: LD_VAR 0 1
19109: PUSH
19110: LD_VAR 0 4
19114: ARRAY
19115: EQUAL
19116: IFFALSE 19132
// begin result := i ;
19118: LD_ADDR_VAR 0 3
19122: PUSH
19123: LD_VAR 0 4
19127: ST_TO_ADDR
// exit ;
19128: POP
19129: POP
19130: GO 19136
// end ;
19132: GO 19097
19134: POP
19135: POP
// end ;
19136: LD_VAR 0 3
19140: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19141: LD_INT 0
19143: PPUSH
// vc_chassis := chassis ;
19144: LD_ADDR_OWVAR 37
19148: PUSH
19149: LD_VAR 0 1
19153: ST_TO_ADDR
// vc_engine := engine ;
19154: LD_ADDR_OWVAR 39
19158: PUSH
19159: LD_VAR 0 2
19163: ST_TO_ADDR
// vc_control := control ;
19164: LD_ADDR_OWVAR 38
19168: PUSH
19169: LD_VAR 0 3
19173: ST_TO_ADDR
// vc_weapon := weapon ;
19174: LD_ADDR_OWVAR 40
19178: PUSH
19179: LD_VAR 0 4
19183: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19184: LD_ADDR_OWVAR 41
19188: PUSH
19189: LD_VAR 0 5
19193: ST_TO_ADDR
// end ;
19194: LD_VAR 0 6
19198: RET
// export function WantPlant ( unit ) ; var task ; begin
19199: LD_INT 0
19201: PPUSH
19202: PPUSH
// result := false ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_INT 0
19210: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19211: LD_ADDR_VAR 0 3
19215: PUSH
19216: LD_VAR 0 1
19220: PPUSH
19221: CALL_OW 437
19225: ST_TO_ADDR
// if task then
19226: LD_VAR 0 3
19230: IFFALSE 19258
// if task [ 1 ] [ 1 ] = p then
19232: LD_VAR 0 3
19236: PUSH
19237: LD_INT 1
19239: ARRAY
19240: PUSH
19241: LD_INT 1
19243: ARRAY
19244: PUSH
19245: LD_STRING p
19247: EQUAL
19248: IFFALSE 19258
// result := true ;
19250: LD_ADDR_VAR 0 2
19254: PUSH
19255: LD_INT 1
19257: ST_TO_ADDR
// end ;
19258: LD_VAR 0 2
19262: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19263: LD_INT 0
19265: PPUSH
19266: PPUSH
19267: PPUSH
19268: PPUSH
// if pos < 1 then
19269: LD_VAR 0 2
19273: PUSH
19274: LD_INT 1
19276: LESS
19277: IFFALSE 19281
// exit ;
19279: GO 19584
// if pos = 1 then
19281: LD_VAR 0 2
19285: PUSH
19286: LD_INT 1
19288: EQUAL
19289: IFFALSE 19322
// result := Replace ( arr , pos [ 1 ] , value ) else
19291: LD_ADDR_VAR 0 4
19295: PUSH
19296: LD_VAR 0 1
19300: PPUSH
19301: LD_VAR 0 2
19305: PUSH
19306: LD_INT 1
19308: ARRAY
19309: PPUSH
19310: LD_VAR 0 3
19314: PPUSH
19315: CALL_OW 1
19319: ST_TO_ADDR
19320: GO 19584
// begin tmp := arr ;
19322: LD_ADDR_VAR 0 6
19326: PUSH
19327: LD_VAR 0 1
19331: ST_TO_ADDR
// s_arr := [ tmp ] ;
19332: LD_ADDR_VAR 0 7
19336: PUSH
19337: LD_VAR 0 6
19341: PUSH
19342: EMPTY
19343: LIST
19344: ST_TO_ADDR
// for i = 1 to pos - 1 do
19345: LD_ADDR_VAR 0 5
19349: PUSH
19350: DOUBLE
19351: LD_INT 1
19353: DEC
19354: ST_TO_ADDR
19355: LD_VAR 0 2
19359: PUSH
19360: LD_INT 1
19362: MINUS
19363: PUSH
19364: FOR_TO
19365: IFFALSE 19410
// begin tmp := tmp [ pos [ i ] ] ;
19367: LD_ADDR_VAR 0 6
19371: PUSH
19372: LD_VAR 0 6
19376: PUSH
19377: LD_VAR 0 2
19381: PUSH
19382: LD_VAR 0 5
19386: ARRAY
19387: ARRAY
19388: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19389: LD_ADDR_VAR 0 7
19393: PUSH
19394: LD_VAR 0 7
19398: PUSH
19399: LD_VAR 0 6
19403: PUSH
19404: EMPTY
19405: LIST
19406: ADD
19407: ST_TO_ADDR
// end ;
19408: GO 19364
19410: POP
19411: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19412: LD_ADDR_VAR 0 6
19416: PUSH
19417: LD_VAR 0 6
19421: PPUSH
19422: LD_VAR 0 2
19426: PUSH
19427: LD_VAR 0 2
19431: ARRAY
19432: PPUSH
19433: LD_VAR 0 3
19437: PPUSH
19438: CALL_OW 1
19442: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19443: LD_ADDR_VAR 0 7
19447: PUSH
19448: LD_VAR 0 7
19452: PPUSH
19453: LD_VAR 0 7
19457: PPUSH
19458: LD_VAR 0 6
19462: PPUSH
19463: CALL_OW 1
19467: ST_TO_ADDR
// for i = s_arr downto 2 do
19468: LD_ADDR_VAR 0 5
19472: PUSH
19473: DOUBLE
19474: LD_VAR 0 7
19478: INC
19479: ST_TO_ADDR
19480: LD_INT 2
19482: PUSH
19483: FOR_DOWNTO
19484: IFFALSE 19568
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
19486: LD_ADDR_VAR 0 6
19490: PUSH
19491: LD_VAR 0 7
19495: PUSH
19496: LD_VAR 0 5
19500: PUSH
19501: LD_INT 1
19503: MINUS
19504: ARRAY
19505: PPUSH
19506: LD_VAR 0 2
19510: PUSH
19511: LD_VAR 0 5
19515: PUSH
19516: LD_INT 1
19518: MINUS
19519: ARRAY
19520: PPUSH
19521: LD_VAR 0 7
19525: PUSH
19526: LD_VAR 0 5
19530: ARRAY
19531: PPUSH
19532: CALL_OW 1
19536: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19537: LD_ADDR_VAR 0 7
19541: PUSH
19542: LD_VAR 0 7
19546: PPUSH
19547: LD_VAR 0 5
19551: PUSH
19552: LD_INT 1
19554: MINUS
19555: PPUSH
19556: LD_VAR 0 6
19560: PPUSH
19561: CALL_OW 1
19565: ST_TO_ADDR
// end ;
19566: GO 19483
19568: POP
19569: POP
// result := s_arr [ 1 ] ;
19570: LD_ADDR_VAR 0 4
19574: PUSH
19575: LD_VAR 0 7
19579: PUSH
19580: LD_INT 1
19582: ARRAY
19583: ST_TO_ADDR
// end ; end ;
19584: LD_VAR 0 4
19588: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
19589: LD_INT 0
19591: PPUSH
19592: PPUSH
// if not list then
19593: LD_VAR 0 1
19597: NOT
19598: IFFALSE 19602
// exit ;
19600: GO 19693
// i := list [ pos1 ] ;
19602: LD_ADDR_VAR 0 5
19606: PUSH
19607: LD_VAR 0 1
19611: PUSH
19612: LD_VAR 0 2
19616: ARRAY
19617: ST_TO_ADDR
// if not i then
19618: LD_VAR 0 5
19622: NOT
19623: IFFALSE 19627
// exit ;
19625: GO 19693
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
19627: LD_ADDR_VAR 0 1
19631: PUSH
19632: LD_VAR 0 1
19636: PPUSH
19637: LD_VAR 0 2
19641: PPUSH
19642: LD_VAR 0 1
19646: PUSH
19647: LD_VAR 0 3
19651: ARRAY
19652: PPUSH
19653: CALL_OW 1
19657: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
19658: LD_ADDR_VAR 0 1
19662: PUSH
19663: LD_VAR 0 1
19667: PPUSH
19668: LD_VAR 0 3
19672: PPUSH
19673: LD_VAR 0 5
19677: PPUSH
19678: CALL_OW 1
19682: ST_TO_ADDR
// result := list ;
19683: LD_ADDR_VAR 0 4
19687: PUSH
19688: LD_VAR 0 1
19692: ST_TO_ADDR
// end ;
19693: LD_VAR 0 4
19697: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19698: LD_INT 0
19700: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19701: LD_ADDR_VAR 0 5
19705: PUSH
19706: LD_VAR 0 1
19710: PPUSH
19711: CALL_OW 250
19715: PPUSH
19716: LD_VAR 0 1
19720: PPUSH
19721: CALL_OW 251
19725: PPUSH
19726: LD_VAR 0 2
19730: PPUSH
19731: LD_VAR 0 3
19735: PPUSH
19736: LD_VAR 0 4
19740: PPUSH
19741: CALL 19751 0 5
19745: ST_TO_ADDR
// end ;
19746: LD_VAR 0 5
19750: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19751: LD_INT 0
19753: PPUSH
19754: PPUSH
19755: PPUSH
19756: PPUSH
// if not list then
19757: LD_VAR 0 3
19761: NOT
19762: IFFALSE 19766
// exit ;
19764: GO 20154
// result := [ ] ;
19766: LD_ADDR_VAR 0 6
19770: PUSH
19771: EMPTY
19772: ST_TO_ADDR
// for i in list do
19773: LD_ADDR_VAR 0 7
19777: PUSH
19778: LD_VAR 0 3
19782: PUSH
19783: FOR_IN
19784: IFFALSE 19986
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19786: LD_ADDR_VAR 0 9
19790: PUSH
19791: LD_VAR 0 7
19795: PPUSH
19796: LD_VAR 0 1
19800: PPUSH
19801: LD_VAR 0 2
19805: PPUSH
19806: CALL_OW 297
19810: ST_TO_ADDR
// if not result then
19811: LD_VAR 0 6
19815: NOT
19816: IFFALSE 19842
// result := [ [ i , tmp ] ] else
19818: LD_ADDR_VAR 0 6
19822: PUSH
19823: LD_VAR 0 7
19827: PUSH
19828: LD_VAR 0 9
19832: PUSH
19833: EMPTY
19834: LIST
19835: LIST
19836: PUSH
19837: EMPTY
19838: LIST
19839: ST_TO_ADDR
19840: GO 19984
// begin if result [ result ] [ 2 ] < tmp then
19842: LD_VAR 0 6
19846: PUSH
19847: LD_VAR 0 6
19851: ARRAY
19852: PUSH
19853: LD_INT 2
19855: ARRAY
19856: PUSH
19857: LD_VAR 0 9
19861: LESS
19862: IFFALSE 19904
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19864: LD_ADDR_VAR 0 6
19868: PUSH
19869: LD_VAR 0 6
19873: PPUSH
19874: LD_VAR 0 6
19878: PUSH
19879: LD_INT 1
19881: PLUS
19882: PPUSH
19883: LD_VAR 0 7
19887: PUSH
19888: LD_VAR 0 9
19892: PUSH
19893: EMPTY
19894: LIST
19895: LIST
19896: PPUSH
19897: CALL_OW 2
19901: ST_TO_ADDR
19902: GO 19984
// for j = 1 to result do
19904: LD_ADDR_VAR 0 8
19908: PUSH
19909: DOUBLE
19910: LD_INT 1
19912: DEC
19913: ST_TO_ADDR
19914: LD_VAR 0 6
19918: PUSH
19919: FOR_TO
19920: IFFALSE 19982
// begin if tmp < result [ j ] [ 2 ] then
19922: LD_VAR 0 9
19926: PUSH
19927: LD_VAR 0 6
19931: PUSH
19932: LD_VAR 0 8
19936: ARRAY
19937: PUSH
19938: LD_INT 2
19940: ARRAY
19941: LESS
19942: IFFALSE 19980
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19944: LD_ADDR_VAR 0 6
19948: PUSH
19949: LD_VAR 0 6
19953: PPUSH
19954: LD_VAR 0 8
19958: PPUSH
19959: LD_VAR 0 7
19963: PUSH
19964: LD_VAR 0 9
19968: PUSH
19969: EMPTY
19970: LIST
19971: LIST
19972: PPUSH
19973: CALL_OW 2
19977: ST_TO_ADDR
// break ;
19978: GO 19982
// end ; end ;
19980: GO 19919
19982: POP
19983: POP
// end ; end ;
19984: GO 19783
19986: POP
19987: POP
// if result and not asc then
19988: LD_VAR 0 6
19992: PUSH
19993: LD_VAR 0 4
19997: NOT
19998: AND
19999: IFFALSE 20074
// begin tmp := result ;
20001: LD_ADDR_VAR 0 9
20005: PUSH
20006: LD_VAR 0 6
20010: ST_TO_ADDR
// for i = tmp downto 1 do
20011: LD_ADDR_VAR 0 7
20015: PUSH
20016: DOUBLE
20017: LD_VAR 0 9
20021: INC
20022: ST_TO_ADDR
20023: LD_INT 1
20025: PUSH
20026: FOR_DOWNTO
20027: IFFALSE 20072
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20029: LD_ADDR_VAR 0 6
20033: PUSH
20034: LD_VAR 0 6
20038: PPUSH
20039: LD_VAR 0 9
20043: PUSH
20044: LD_VAR 0 7
20048: MINUS
20049: PUSH
20050: LD_INT 1
20052: PLUS
20053: PPUSH
20054: LD_VAR 0 9
20058: PUSH
20059: LD_VAR 0 7
20063: ARRAY
20064: PPUSH
20065: CALL_OW 1
20069: ST_TO_ADDR
20070: GO 20026
20072: POP
20073: POP
// end ; tmp := [ ] ;
20074: LD_ADDR_VAR 0 9
20078: PUSH
20079: EMPTY
20080: ST_TO_ADDR
// if mode then
20081: LD_VAR 0 5
20085: IFFALSE 20154
// begin for i = 1 to result do
20087: LD_ADDR_VAR 0 7
20091: PUSH
20092: DOUBLE
20093: LD_INT 1
20095: DEC
20096: ST_TO_ADDR
20097: LD_VAR 0 6
20101: PUSH
20102: FOR_TO
20103: IFFALSE 20142
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20105: LD_ADDR_VAR 0 9
20109: PUSH
20110: LD_VAR 0 9
20114: PPUSH
20115: LD_VAR 0 7
20119: PPUSH
20120: LD_VAR 0 6
20124: PUSH
20125: LD_VAR 0 7
20129: ARRAY
20130: PUSH
20131: LD_INT 1
20133: ARRAY
20134: PPUSH
20135: CALL_OW 1
20139: ST_TO_ADDR
20140: GO 20102
20142: POP
20143: POP
// result := tmp ;
20144: LD_ADDR_VAR 0 6
20148: PUSH
20149: LD_VAR 0 9
20153: ST_TO_ADDR
// end ; end ;
20154: LD_VAR 0 6
20158: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20159: LD_INT 0
20161: PPUSH
20162: PPUSH
20163: PPUSH
20164: PPUSH
20165: PPUSH
20166: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20167: LD_ADDR_VAR 0 5
20171: PUSH
20172: LD_INT 0
20174: PUSH
20175: LD_INT 0
20177: PUSH
20178: LD_INT 0
20180: PUSH
20181: EMPTY
20182: PUSH
20183: EMPTY
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: ST_TO_ADDR
// if not x or not y then
20189: LD_VAR 0 2
20193: NOT
20194: PUSH
20195: LD_VAR 0 3
20199: NOT
20200: OR
20201: IFFALSE 20205
// exit ;
20203: GO 21851
// if not range then
20205: LD_VAR 0 4
20209: NOT
20210: IFFALSE 20220
// range := 10 ;
20212: LD_ADDR_VAR 0 4
20216: PUSH
20217: LD_INT 10
20219: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20220: LD_ADDR_VAR 0 8
20224: PUSH
20225: LD_INT 81
20227: PUSH
20228: LD_VAR 0 1
20232: PUSH
20233: EMPTY
20234: LIST
20235: LIST
20236: PUSH
20237: LD_INT 92
20239: PUSH
20240: LD_VAR 0 2
20244: PUSH
20245: LD_VAR 0 3
20249: PUSH
20250: LD_VAR 0 4
20254: PUSH
20255: EMPTY
20256: LIST
20257: LIST
20258: LIST
20259: LIST
20260: PUSH
20261: LD_INT 3
20263: PUSH
20264: LD_INT 21
20266: PUSH
20267: LD_INT 3
20269: PUSH
20270: EMPTY
20271: LIST
20272: LIST
20273: PUSH
20274: EMPTY
20275: LIST
20276: LIST
20277: PUSH
20278: EMPTY
20279: LIST
20280: LIST
20281: LIST
20282: PPUSH
20283: CALL_OW 69
20287: ST_TO_ADDR
// if not tmp then
20288: LD_VAR 0 8
20292: NOT
20293: IFFALSE 20297
// exit ;
20295: GO 21851
// for i in tmp do
20297: LD_ADDR_VAR 0 6
20301: PUSH
20302: LD_VAR 0 8
20306: PUSH
20307: FOR_IN
20308: IFFALSE 21826
// begin points := [ 0 , 0 , 0 ] ;
20310: LD_ADDR_VAR 0 9
20314: PUSH
20315: LD_INT 0
20317: PUSH
20318: LD_INT 0
20320: PUSH
20321: LD_INT 0
20323: PUSH
20324: EMPTY
20325: LIST
20326: LIST
20327: LIST
20328: ST_TO_ADDR
// bpoints := 1 ;
20329: LD_ADDR_VAR 0 10
20333: PUSH
20334: LD_INT 1
20336: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20337: LD_VAR 0 6
20341: PPUSH
20342: CALL_OW 247
20346: PUSH
20347: LD_INT 1
20349: DOUBLE
20350: EQUAL
20351: IFTRUE 20355
20353: GO 20933
20355: POP
// begin if GetClass ( i ) = 1 then
20356: LD_VAR 0 6
20360: PPUSH
20361: CALL_OW 257
20365: PUSH
20366: LD_INT 1
20368: EQUAL
20369: IFFALSE 20390
// points := [ 10 , 5 , 3 ] ;
20371: LD_ADDR_VAR 0 9
20375: PUSH
20376: LD_INT 10
20378: PUSH
20379: LD_INT 5
20381: PUSH
20382: LD_INT 3
20384: PUSH
20385: EMPTY
20386: LIST
20387: LIST
20388: LIST
20389: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20390: LD_VAR 0 6
20394: PPUSH
20395: CALL_OW 257
20399: PUSH
20400: LD_INT 2
20402: PUSH
20403: LD_INT 3
20405: PUSH
20406: LD_INT 4
20408: PUSH
20409: EMPTY
20410: LIST
20411: LIST
20412: LIST
20413: IN
20414: IFFALSE 20435
// points := [ 3 , 2 , 1 ] ;
20416: LD_ADDR_VAR 0 9
20420: PUSH
20421: LD_INT 3
20423: PUSH
20424: LD_INT 2
20426: PUSH
20427: LD_INT 1
20429: PUSH
20430: EMPTY
20431: LIST
20432: LIST
20433: LIST
20434: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20435: LD_VAR 0 6
20439: PPUSH
20440: CALL_OW 257
20444: PUSH
20445: LD_INT 5
20447: EQUAL
20448: IFFALSE 20469
// points := [ 130 , 5 , 2 ] ;
20450: LD_ADDR_VAR 0 9
20454: PUSH
20455: LD_INT 130
20457: PUSH
20458: LD_INT 5
20460: PUSH
20461: LD_INT 2
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: LIST
20468: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20469: LD_VAR 0 6
20473: PPUSH
20474: CALL_OW 257
20478: PUSH
20479: LD_INT 8
20481: EQUAL
20482: IFFALSE 20503
// points := [ 35 , 35 , 30 ] ;
20484: LD_ADDR_VAR 0 9
20488: PUSH
20489: LD_INT 35
20491: PUSH
20492: LD_INT 35
20494: PUSH
20495: LD_INT 30
20497: PUSH
20498: EMPTY
20499: LIST
20500: LIST
20501: LIST
20502: ST_TO_ADDR
// if GetClass ( i ) = 9 then
20503: LD_VAR 0 6
20507: PPUSH
20508: CALL_OW 257
20512: PUSH
20513: LD_INT 9
20515: EQUAL
20516: IFFALSE 20537
// points := [ 20 , 55 , 40 ] ;
20518: LD_ADDR_VAR 0 9
20522: PUSH
20523: LD_INT 20
20525: PUSH
20526: LD_INT 55
20528: PUSH
20529: LD_INT 40
20531: PUSH
20532: EMPTY
20533: LIST
20534: LIST
20535: LIST
20536: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20537: LD_VAR 0 6
20541: PPUSH
20542: CALL_OW 257
20546: PUSH
20547: LD_INT 12
20549: PUSH
20550: LD_INT 16
20552: PUSH
20553: EMPTY
20554: LIST
20555: LIST
20556: IN
20557: IFFALSE 20578
// points := [ 5 , 3 , 2 ] ;
20559: LD_ADDR_VAR 0 9
20563: PUSH
20564: LD_INT 5
20566: PUSH
20567: LD_INT 3
20569: PUSH
20570: LD_INT 2
20572: PUSH
20573: EMPTY
20574: LIST
20575: LIST
20576: LIST
20577: ST_TO_ADDR
// if GetClass ( i ) = 17 then
20578: LD_VAR 0 6
20582: PPUSH
20583: CALL_OW 257
20587: PUSH
20588: LD_INT 17
20590: EQUAL
20591: IFFALSE 20612
// points := [ 100 , 50 , 75 ] ;
20593: LD_ADDR_VAR 0 9
20597: PUSH
20598: LD_INT 100
20600: PUSH
20601: LD_INT 50
20603: PUSH
20604: LD_INT 75
20606: PUSH
20607: EMPTY
20608: LIST
20609: LIST
20610: LIST
20611: ST_TO_ADDR
// if GetClass ( i ) = 15 then
20612: LD_VAR 0 6
20616: PPUSH
20617: CALL_OW 257
20621: PUSH
20622: LD_INT 15
20624: EQUAL
20625: IFFALSE 20646
// points := [ 10 , 5 , 3 ] ;
20627: LD_ADDR_VAR 0 9
20631: PUSH
20632: LD_INT 10
20634: PUSH
20635: LD_INT 5
20637: PUSH
20638: LD_INT 3
20640: PUSH
20641: EMPTY
20642: LIST
20643: LIST
20644: LIST
20645: ST_TO_ADDR
// if GetClass ( i ) = 14 then
20646: LD_VAR 0 6
20650: PPUSH
20651: CALL_OW 257
20655: PUSH
20656: LD_INT 14
20658: EQUAL
20659: IFFALSE 20680
// points := [ 10 , 0 , 0 ] ;
20661: LD_ADDR_VAR 0 9
20665: PUSH
20666: LD_INT 10
20668: PUSH
20669: LD_INT 0
20671: PUSH
20672: LD_INT 0
20674: PUSH
20675: EMPTY
20676: LIST
20677: LIST
20678: LIST
20679: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20680: LD_VAR 0 6
20684: PPUSH
20685: CALL_OW 257
20689: PUSH
20690: LD_INT 11
20692: EQUAL
20693: IFFALSE 20714
// points := [ 30 , 10 , 5 ] ;
20695: LD_ADDR_VAR 0 9
20699: PUSH
20700: LD_INT 30
20702: PUSH
20703: LD_INT 10
20705: PUSH
20706: LD_INT 5
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: LIST
20713: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20714: LD_VAR 0 1
20718: PPUSH
20719: LD_INT 5
20721: PPUSH
20722: CALL_OW 321
20726: PUSH
20727: LD_INT 2
20729: EQUAL
20730: IFFALSE 20747
// bpoints := bpoints * 1.8 ;
20732: LD_ADDR_VAR 0 10
20736: PUSH
20737: LD_VAR 0 10
20741: PUSH
20742: LD_REAL  1.80000000000000E+0000
20745: MUL
20746: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20747: LD_VAR 0 6
20751: PPUSH
20752: CALL_OW 257
20756: PUSH
20757: LD_INT 1
20759: PUSH
20760: LD_INT 2
20762: PUSH
20763: LD_INT 3
20765: PUSH
20766: LD_INT 4
20768: PUSH
20769: EMPTY
20770: LIST
20771: LIST
20772: LIST
20773: LIST
20774: IN
20775: PUSH
20776: LD_VAR 0 1
20780: PPUSH
20781: LD_INT 51
20783: PPUSH
20784: CALL_OW 321
20788: PUSH
20789: LD_INT 2
20791: EQUAL
20792: AND
20793: IFFALSE 20810
// bpoints := bpoints * 1.2 ;
20795: LD_ADDR_VAR 0 10
20799: PUSH
20800: LD_VAR 0 10
20804: PUSH
20805: LD_REAL  1.20000000000000E+0000
20808: MUL
20809: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20810: LD_VAR 0 6
20814: PPUSH
20815: CALL_OW 257
20819: PUSH
20820: LD_INT 5
20822: PUSH
20823: LD_INT 7
20825: PUSH
20826: LD_INT 9
20828: PUSH
20829: EMPTY
20830: LIST
20831: LIST
20832: LIST
20833: IN
20834: PUSH
20835: LD_VAR 0 1
20839: PPUSH
20840: LD_INT 52
20842: PPUSH
20843: CALL_OW 321
20847: PUSH
20848: LD_INT 2
20850: EQUAL
20851: AND
20852: IFFALSE 20869
// bpoints := bpoints * 1.5 ;
20854: LD_ADDR_VAR 0 10
20858: PUSH
20859: LD_VAR 0 10
20863: PUSH
20864: LD_REAL  1.50000000000000E+0000
20867: MUL
20868: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20869: LD_VAR 0 1
20873: PPUSH
20874: LD_INT 66
20876: PPUSH
20877: CALL_OW 321
20881: PUSH
20882: LD_INT 2
20884: EQUAL
20885: IFFALSE 20902
// bpoints := bpoints * 1.1 ;
20887: LD_ADDR_VAR 0 10
20891: PUSH
20892: LD_VAR 0 10
20896: PUSH
20897: LD_REAL  1.10000000000000E+0000
20900: MUL
20901: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20902: LD_ADDR_VAR 0 10
20906: PUSH
20907: LD_VAR 0 10
20911: PUSH
20912: LD_VAR 0 6
20916: PPUSH
20917: LD_INT 1
20919: PPUSH
20920: CALL_OW 259
20924: PUSH
20925: LD_REAL  1.15000000000000E+0000
20928: MUL
20929: MUL
20930: ST_TO_ADDR
// end ; unit_vehicle :
20931: GO 21755
20933: LD_INT 2
20935: DOUBLE
20936: EQUAL
20937: IFTRUE 20941
20939: GO 21743
20941: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20942: LD_VAR 0 6
20946: PPUSH
20947: CALL_OW 264
20951: PUSH
20952: LD_INT 2
20954: PUSH
20955: LD_INT 42
20957: PUSH
20958: LD_INT 24
20960: PUSH
20961: EMPTY
20962: LIST
20963: LIST
20964: LIST
20965: IN
20966: IFFALSE 20987
// points := [ 25 , 5 , 3 ] ;
20968: LD_ADDR_VAR 0 9
20972: PUSH
20973: LD_INT 25
20975: PUSH
20976: LD_INT 5
20978: PUSH
20979: LD_INT 3
20981: PUSH
20982: EMPTY
20983: LIST
20984: LIST
20985: LIST
20986: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20987: LD_VAR 0 6
20991: PPUSH
20992: CALL_OW 264
20996: PUSH
20997: LD_INT 4
20999: PUSH
21000: LD_INT 43
21002: PUSH
21003: LD_INT 25
21005: PUSH
21006: EMPTY
21007: LIST
21008: LIST
21009: LIST
21010: IN
21011: IFFALSE 21032
// points := [ 40 , 15 , 5 ] ;
21013: LD_ADDR_VAR 0 9
21017: PUSH
21018: LD_INT 40
21020: PUSH
21021: LD_INT 15
21023: PUSH
21024: LD_INT 5
21026: PUSH
21027: EMPTY
21028: LIST
21029: LIST
21030: LIST
21031: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21032: LD_VAR 0 6
21036: PPUSH
21037: CALL_OW 264
21041: PUSH
21042: LD_INT 3
21044: PUSH
21045: LD_INT 23
21047: PUSH
21048: EMPTY
21049: LIST
21050: LIST
21051: IN
21052: IFFALSE 21073
// points := [ 7 , 25 , 8 ] ;
21054: LD_ADDR_VAR 0 9
21058: PUSH
21059: LD_INT 7
21061: PUSH
21062: LD_INT 25
21064: PUSH
21065: LD_INT 8
21067: PUSH
21068: EMPTY
21069: LIST
21070: LIST
21071: LIST
21072: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21073: LD_VAR 0 6
21077: PPUSH
21078: CALL_OW 264
21082: PUSH
21083: LD_INT 5
21085: PUSH
21086: LD_INT 27
21088: PUSH
21089: LD_INT 44
21091: PUSH
21092: EMPTY
21093: LIST
21094: LIST
21095: LIST
21096: IN
21097: IFFALSE 21118
// points := [ 14 , 50 , 16 ] ;
21099: LD_ADDR_VAR 0 9
21103: PUSH
21104: LD_INT 14
21106: PUSH
21107: LD_INT 50
21109: PUSH
21110: LD_INT 16
21112: PUSH
21113: EMPTY
21114: LIST
21115: LIST
21116: LIST
21117: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21118: LD_VAR 0 6
21122: PPUSH
21123: CALL_OW 264
21127: PUSH
21128: LD_INT 6
21130: PUSH
21131: LD_INT 46
21133: PUSH
21134: EMPTY
21135: LIST
21136: LIST
21137: IN
21138: IFFALSE 21159
// points := [ 32 , 120 , 70 ] ;
21140: LD_ADDR_VAR 0 9
21144: PUSH
21145: LD_INT 32
21147: PUSH
21148: LD_INT 120
21150: PUSH
21151: LD_INT 70
21153: PUSH
21154: EMPTY
21155: LIST
21156: LIST
21157: LIST
21158: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
21159: LD_VAR 0 6
21163: PPUSH
21164: CALL_OW 264
21168: PUSH
21169: LD_INT 7
21171: PUSH
21172: LD_INT 28
21174: PUSH
21175: LD_INT 45
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: LIST
21182: IN
21183: IFFALSE 21204
// points := [ 35 , 20 , 45 ] ;
21185: LD_ADDR_VAR 0 9
21189: PUSH
21190: LD_INT 35
21192: PUSH
21193: LD_INT 20
21195: PUSH
21196: LD_INT 45
21198: PUSH
21199: EMPTY
21200: LIST
21201: LIST
21202: LIST
21203: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21204: LD_VAR 0 6
21208: PPUSH
21209: CALL_OW 264
21213: PUSH
21214: LD_INT 47
21216: PUSH
21217: EMPTY
21218: LIST
21219: IN
21220: IFFALSE 21241
// points := [ 67 , 45 , 75 ] ;
21222: LD_ADDR_VAR 0 9
21226: PUSH
21227: LD_INT 67
21229: PUSH
21230: LD_INT 45
21232: PUSH
21233: LD_INT 75
21235: PUSH
21236: EMPTY
21237: LIST
21238: LIST
21239: LIST
21240: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21241: LD_VAR 0 6
21245: PPUSH
21246: CALL_OW 264
21250: PUSH
21251: LD_INT 26
21253: PUSH
21254: EMPTY
21255: LIST
21256: IN
21257: IFFALSE 21278
// points := [ 120 , 30 , 80 ] ;
21259: LD_ADDR_VAR 0 9
21263: PUSH
21264: LD_INT 120
21266: PUSH
21267: LD_INT 30
21269: PUSH
21270: LD_INT 80
21272: PUSH
21273: EMPTY
21274: LIST
21275: LIST
21276: LIST
21277: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21278: LD_VAR 0 6
21282: PPUSH
21283: CALL_OW 264
21287: PUSH
21288: LD_INT 22
21290: PUSH
21291: EMPTY
21292: LIST
21293: IN
21294: IFFALSE 21315
// points := [ 40 , 1 , 1 ] ;
21296: LD_ADDR_VAR 0 9
21300: PUSH
21301: LD_INT 40
21303: PUSH
21304: LD_INT 1
21306: PUSH
21307: LD_INT 1
21309: PUSH
21310: EMPTY
21311: LIST
21312: LIST
21313: LIST
21314: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21315: LD_VAR 0 6
21319: PPUSH
21320: CALL_OW 264
21324: PUSH
21325: LD_INT 29
21327: PUSH
21328: EMPTY
21329: LIST
21330: IN
21331: IFFALSE 21352
// points := [ 70 , 200 , 400 ] ;
21333: LD_ADDR_VAR 0 9
21337: PUSH
21338: LD_INT 70
21340: PUSH
21341: LD_INT 200
21343: PUSH
21344: LD_INT 400
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: LIST
21351: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21352: LD_VAR 0 6
21356: PPUSH
21357: CALL_OW 264
21361: PUSH
21362: LD_INT 14
21364: PUSH
21365: LD_INT 53
21367: PUSH
21368: EMPTY
21369: LIST
21370: LIST
21371: IN
21372: IFFALSE 21393
// points := [ 40 , 10 , 20 ] ;
21374: LD_ADDR_VAR 0 9
21378: PUSH
21379: LD_INT 40
21381: PUSH
21382: LD_INT 10
21384: PUSH
21385: LD_INT 20
21387: PUSH
21388: EMPTY
21389: LIST
21390: LIST
21391: LIST
21392: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21393: LD_VAR 0 6
21397: PPUSH
21398: CALL_OW 264
21402: PUSH
21403: LD_INT 9
21405: PUSH
21406: EMPTY
21407: LIST
21408: IN
21409: IFFALSE 21430
// points := [ 5 , 70 , 20 ] ;
21411: LD_ADDR_VAR 0 9
21415: PUSH
21416: LD_INT 5
21418: PUSH
21419: LD_INT 70
21421: PUSH
21422: LD_INT 20
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: LIST
21429: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21430: LD_VAR 0 6
21434: PPUSH
21435: CALL_OW 264
21439: PUSH
21440: LD_INT 10
21442: PUSH
21443: EMPTY
21444: LIST
21445: IN
21446: IFFALSE 21467
// points := [ 35 , 110 , 70 ] ;
21448: LD_ADDR_VAR 0 9
21452: PUSH
21453: LD_INT 35
21455: PUSH
21456: LD_INT 110
21458: PUSH
21459: LD_INT 70
21461: PUSH
21462: EMPTY
21463: LIST
21464: LIST
21465: LIST
21466: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
21467: LD_VAR 0 6
21471: PPUSH
21472: CALL_OW 265
21476: PUSH
21477: LD_INT 25
21479: EQUAL
21480: IFFALSE 21501
// points := [ 80 , 65 , 100 ] ;
21482: LD_ADDR_VAR 0 9
21486: PUSH
21487: LD_INT 80
21489: PUSH
21490: LD_INT 65
21492: PUSH
21493: LD_INT 100
21495: PUSH
21496: EMPTY
21497: LIST
21498: LIST
21499: LIST
21500: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
21501: LD_VAR 0 6
21505: PPUSH
21506: CALL_OW 263
21510: PUSH
21511: LD_INT 1
21513: EQUAL
21514: IFFALSE 21549
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21516: LD_ADDR_VAR 0 10
21520: PUSH
21521: LD_VAR 0 10
21525: PUSH
21526: LD_VAR 0 6
21530: PPUSH
21531: CALL_OW 311
21535: PPUSH
21536: LD_INT 3
21538: PPUSH
21539: CALL_OW 259
21543: PUSH
21544: LD_INT 4
21546: MUL
21547: MUL
21548: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21549: LD_VAR 0 6
21553: PPUSH
21554: CALL_OW 263
21558: PUSH
21559: LD_INT 2
21561: EQUAL
21562: IFFALSE 21613
// begin j := IsControledBy ( i ) ;
21564: LD_ADDR_VAR 0 7
21568: PUSH
21569: LD_VAR 0 6
21573: PPUSH
21574: CALL_OW 312
21578: ST_TO_ADDR
// if j then
21579: LD_VAR 0 7
21583: IFFALSE 21613
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
21585: LD_ADDR_VAR 0 10
21589: PUSH
21590: LD_VAR 0 10
21594: PUSH
21595: LD_VAR 0 7
21599: PPUSH
21600: LD_INT 3
21602: PPUSH
21603: CALL_OW 259
21607: PUSH
21608: LD_INT 3
21610: MUL
21611: MUL
21612: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
21613: LD_VAR 0 6
21617: PPUSH
21618: CALL_OW 264
21622: PUSH
21623: LD_INT 5
21625: PUSH
21626: LD_INT 6
21628: PUSH
21629: LD_INT 46
21631: PUSH
21632: LD_INT 44
21634: PUSH
21635: LD_INT 47
21637: PUSH
21638: LD_INT 45
21640: PUSH
21641: LD_INT 28
21643: PUSH
21644: LD_INT 7
21646: PUSH
21647: LD_INT 27
21649: PUSH
21650: LD_INT 29
21652: PUSH
21653: EMPTY
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: IN
21665: PUSH
21666: LD_VAR 0 1
21670: PPUSH
21671: LD_INT 52
21673: PPUSH
21674: CALL_OW 321
21678: PUSH
21679: LD_INT 2
21681: EQUAL
21682: AND
21683: IFFALSE 21700
// bpoints := bpoints * 1.2 ;
21685: LD_ADDR_VAR 0 10
21689: PUSH
21690: LD_VAR 0 10
21694: PUSH
21695: LD_REAL  1.20000000000000E+0000
21698: MUL
21699: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21700: LD_VAR 0 6
21704: PPUSH
21705: CALL_OW 264
21709: PUSH
21710: LD_INT 6
21712: PUSH
21713: LD_INT 46
21715: PUSH
21716: LD_INT 47
21718: PUSH
21719: EMPTY
21720: LIST
21721: LIST
21722: LIST
21723: IN
21724: IFFALSE 21741
// bpoints := bpoints * 1.2 ;
21726: LD_ADDR_VAR 0 10
21730: PUSH
21731: LD_VAR 0 10
21735: PUSH
21736: LD_REAL  1.20000000000000E+0000
21739: MUL
21740: ST_TO_ADDR
// end ; unit_building :
21741: GO 21755
21743: LD_INT 3
21745: DOUBLE
21746: EQUAL
21747: IFTRUE 21751
21749: GO 21754
21751: POP
// ; end ;
21752: GO 21755
21754: POP
// for j = 1 to 3 do
21755: LD_ADDR_VAR 0 7
21759: PUSH
21760: DOUBLE
21761: LD_INT 1
21763: DEC
21764: ST_TO_ADDR
21765: LD_INT 3
21767: PUSH
21768: FOR_TO
21769: IFFALSE 21822
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21771: LD_ADDR_VAR 0 5
21775: PUSH
21776: LD_VAR 0 5
21780: PPUSH
21781: LD_VAR 0 7
21785: PPUSH
21786: LD_VAR 0 5
21790: PUSH
21791: LD_VAR 0 7
21795: ARRAY
21796: PUSH
21797: LD_VAR 0 9
21801: PUSH
21802: LD_VAR 0 7
21806: ARRAY
21807: PUSH
21808: LD_VAR 0 10
21812: MUL
21813: PLUS
21814: PPUSH
21815: CALL_OW 1
21819: ST_TO_ADDR
21820: GO 21768
21822: POP
21823: POP
// end ;
21824: GO 20307
21826: POP
21827: POP
// result := Replace ( result , 4 , tmp ) ;
21828: LD_ADDR_VAR 0 5
21832: PUSH
21833: LD_VAR 0 5
21837: PPUSH
21838: LD_INT 4
21840: PPUSH
21841: LD_VAR 0 8
21845: PPUSH
21846: CALL_OW 1
21850: ST_TO_ADDR
// end ;
21851: LD_VAR 0 5
21855: RET
// export function DangerAtRange ( unit , range ) ; begin
21856: LD_INT 0
21858: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21859: LD_ADDR_VAR 0 3
21863: PUSH
21864: LD_VAR 0 1
21868: PPUSH
21869: CALL_OW 255
21873: PPUSH
21874: LD_VAR 0 1
21878: PPUSH
21879: CALL_OW 250
21883: PPUSH
21884: LD_VAR 0 1
21888: PPUSH
21889: CALL_OW 251
21893: PPUSH
21894: LD_VAR 0 2
21898: PPUSH
21899: CALL 20159 0 4
21903: ST_TO_ADDR
// end ;
21904: LD_VAR 0 3
21908: RET
// export function DangerInArea ( side , area ) ; begin
21909: LD_INT 0
21911: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21912: LD_ADDR_VAR 0 3
21916: PUSH
21917: LD_VAR 0 2
21921: PPUSH
21922: LD_INT 81
21924: PUSH
21925: LD_VAR 0 1
21929: PUSH
21930: EMPTY
21931: LIST
21932: LIST
21933: PPUSH
21934: CALL_OW 70
21938: ST_TO_ADDR
// end ;
21939: LD_VAR 0 3
21943: RET
// export function IsExtension ( b ) ; begin
21944: LD_INT 0
21946: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21947: LD_ADDR_VAR 0 2
21951: PUSH
21952: LD_VAR 0 1
21956: PUSH
21957: LD_INT 23
21959: PUSH
21960: LD_INT 20
21962: PUSH
21963: LD_INT 22
21965: PUSH
21966: LD_INT 17
21968: PUSH
21969: LD_INT 24
21971: PUSH
21972: LD_INT 21
21974: PUSH
21975: LD_INT 19
21977: PUSH
21978: LD_INT 16
21980: PUSH
21981: LD_INT 25
21983: PUSH
21984: LD_INT 18
21986: PUSH
21987: EMPTY
21988: LIST
21989: LIST
21990: LIST
21991: LIST
21992: LIST
21993: LIST
21994: LIST
21995: LIST
21996: LIST
21997: LIST
21998: IN
21999: ST_TO_ADDR
// end ;
22000: LD_VAR 0 2
22004: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
22005: LD_INT 0
22007: PPUSH
22008: PPUSH
22009: PPUSH
// result := [ ] ;
22010: LD_ADDR_VAR 0 3
22014: PUSH
22015: EMPTY
22016: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22017: LD_ADDR_VAR 0 4
22021: PUSH
22022: LD_VAR 0 2
22026: PPUSH
22027: LD_INT 21
22029: PUSH
22030: LD_INT 3
22032: PUSH
22033: EMPTY
22034: LIST
22035: LIST
22036: PPUSH
22037: CALL_OW 70
22041: ST_TO_ADDR
// if not tmp then
22042: LD_VAR 0 4
22046: NOT
22047: IFFALSE 22051
// exit ;
22049: GO 22109
// for i in tmp do
22051: LD_ADDR_VAR 0 5
22055: PUSH
22056: LD_VAR 0 4
22060: PUSH
22061: FOR_IN
22062: IFFALSE 22097
// if GetBase ( i ) <> base then
22064: LD_VAR 0 5
22068: PPUSH
22069: CALL_OW 274
22073: PUSH
22074: LD_VAR 0 1
22078: NONEQUAL
22079: IFFALSE 22095
// ComLinkToBase ( base , i ) ;
22081: LD_VAR 0 1
22085: PPUSH
22086: LD_VAR 0 5
22090: PPUSH
22091: CALL_OW 169
22095: GO 22061
22097: POP
22098: POP
// result := tmp ;
22099: LD_ADDR_VAR 0 3
22103: PUSH
22104: LD_VAR 0 4
22108: ST_TO_ADDR
// end ;
22109: LD_VAR 0 3
22113: RET
// export function ComComplete ( unit , b ) ; var i ; begin
22114: LD_INT 0
22116: PPUSH
22117: PPUSH
// if BuildingStatus ( b ) = bs_build then
22118: LD_VAR 0 2
22122: PPUSH
22123: CALL_OW 461
22127: PUSH
22128: LD_INT 1
22130: EQUAL
22131: IFFALSE 22191
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22133: LD_VAR 0 1
22137: PPUSH
22138: LD_STRING h
22140: PUSH
22141: LD_VAR 0 2
22145: PPUSH
22146: CALL_OW 250
22150: PUSH
22151: LD_VAR 0 2
22155: PPUSH
22156: CALL_OW 251
22160: PUSH
22161: LD_VAR 0 2
22165: PUSH
22166: LD_INT 0
22168: PUSH
22169: LD_INT 0
22171: PUSH
22172: LD_INT 0
22174: PUSH
22175: EMPTY
22176: LIST
22177: LIST
22178: LIST
22179: LIST
22180: LIST
22181: LIST
22182: LIST
22183: PUSH
22184: EMPTY
22185: LIST
22186: PPUSH
22187: CALL_OW 446
// end ;
22191: LD_VAR 0 3
22195: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22196: LD_INT 0
22198: PPUSH
22199: PPUSH
22200: PPUSH
22201: PPUSH
22202: PPUSH
22203: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
22204: LD_VAR 0 1
22208: NOT
22209: PUSH
22210: LD_VAR 0 1
22214: PPUSH
22215: CALL_OW 263
22219: PUSH
22220: LD_INT 2
22222: EQUAL
22223: NOT
22224: OR
22225: IFFALSE 22229
// exit ;
22227: GO 22545
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22229: LD_ADDR_VAR 0 6
22233: PUSH
22234: LD_INT 22
22236: PUSH
22237: LD_VAR 0 1
22241: PPUSH
22242: CALL_OW 255
22246: PUSH
22247: EMPTY
22248: LIST
22249: LIST
22250: PUSH
22251: LD_INT 2
22253: PUSH
22254: LD_INT 30
22256: PUSH
22257: LD_INT 36
22259: PUSH
22260: EMPTY
22261: LIST
22262: LIST
22263: PUSH
22264: LD_INT 34
22266: PUSH
22267: LD_INT 31
22269: PUSH
22270: EMPTY
22271: LIST
22272: LIST
22273: PUSH
22274: EMPTY
22275: LIST
22276: LIST
22277: LIST
22278: PUSH
22279: EMPTY
22280: LIST
22281: LIST
22282: PPUSH
22283: CALL_OW 69
22287: ST_TO_ADDR
// if not tmp then
22288: LD_VAR 0 6
22292: NOT
22293: IFFALSE 22297
// exit ;
22295: GO 22545
// result := [ ] ;
22297: LD_ADDR_VAR 0 2
22301: PUSH
22302: EMPTY
22303: ST_TO_ADDR
// for i in tmp do
22304: LD_ADDR_VAR 0 3
22308: PUSH
22309: LD_VAR 0 6
22313: PUSH
22314: FOR_IN
22315: IFFALSE 22386
// begin t := UnitsInside ( i ) ;
22317: LD_ADDR_VAR 0 4
22321: PUSH
22322: LD_VAR 0 3
22326: PPUSH
22327: CALL_OW 313
22331: ST_TO_ADDR
// if t then
22332: LD_VAR 0 4
22336: IFFALSE 22384
// for j in t do
22338: LD_ADDR_VAR 0 7
22342: PUSH
22343: LD_VAR 0 4
22347: PUSH
22348: FOR_IN
22349: IFFALSE 22382
// result := Insert ( result , result + 1 , j ) ;
22351: LD_ADDR_VAR 0 2
22355: PUSH
22356: LD_VAR 0 2
22360: PPUSH
22361: LD_VAR 0 2
22365: PUSH
22366: LD_INT 1
22368: PLUS
22369: PPUSH
22370: LD_VAR 0 7
22374: PPUSH
22375: CALL_OW 2
22379: ST_TO_ADDR
22380: GO 22348
22382: POP
22383: POP
// end ;
22384: GO 22314
22386: POP
22387: POP
// if not result then
22388: LD_VAR 0 2
22392: NOT
22393: IFFALSE 22397
// exit ;
22395: GO 22545
// mech := result [ 1 ] ;
22397: LD_ADDR_VAR 0 5
22401: PUSH
22402: LD_VAR 0 2
22406: PUSH
22407: LD_INT 1
22409: ARRAY
22410: ST_TO_ADDR
// if result > 1 then
22411: LD_VAR 0 2
22415: PUSH
22416: LD_INT 1
22418: GREATER
22419: IFFALSE 22531
// for i = 2 to result do
22421: LD_ADDR_VAR 0 3
22425: PUSH
22426: DOUBLE
22427: LD_INT 2
22429: DEC
22430: ST_TO_ADDR
22431: LD_VAR 0 2
22435: PUSH
22436: FOR_TO
22437: IFFALSE 22529
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
22439: LD_ADDR_VAR 0 4
22443: PUSH
22444: LD_VAR 0 2
22448: PUSH
22449: LD_VAR 0 3
22453: ARRAY
22454: PPUSH
22455: LD_INT 3
22457: PPUSH
22458: CALL_OW 259
22462: PUSH
22463: LD_VAR 0 2
22467: PUSH
22468: LD_VAR 0 3
22472: ARRAY
22473: PPUSH
22474: CALL_OW 432
22478: MINUS
22479: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22480: LD_VAR 0 4
22484: PUSH
22485: LD_VAR 0 5
22489: PPUSH
22490: LD_INT 3
22492: PPUSH
22493: CALL_OW 259
22497: PUSH
22498: LD_VAR 0 5
22502: PPUSH
22503: CALL_OW 432
22507: MINUS
22508: GREATEREQUAL
22509: IFFALSE 22527
// mech := result [ i ] ;
22511: LD_ADDR_VAR 0 5
22515: PUSH
22516: LD_VAR 0 2
22520: PUSH
22521: LD_VAR 0 3
22525: ARRAY
22526: ST_TO_ADDR
// end ;
22527: GO 22436
22529: POP
22530: POP
// ComLinkTo ( vehicle , mech ) ;
22531: LD_VAR 0 1
22535: PPUSH
22536: LD_VAR 0 5
22540: PPUSH
22541: CALL_OW 135
// end ;
22545: LD_VAR 0 2
22549: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
22550: LD_INT 0
22552: PPUSH
22553: PPUSH
22554: PPUSH
22555: PPUSH
22556: PPUSH
22557: PPUSH
22558: PPUSH
22559: PPUSH
22560: PPUSH
22561: PPUSH
22562: PPUSH
22563: PPUSH
22564: PPUSH
// result := [ ] ;
22565: LD_ADDR_VAR 0 7
22569: PUSH
22570: EMPTY
22571: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
22572: LD_VAR 0 1
22576: PPUSH
22577: CALL_OW 266
22581: PUSH
22582: LD_INT 0
22584: PUSH
22585: LD_INT 1
22587: PUSH
22588: EMPTY
22589: LIST
22590: LIST
22591: IN
22592: NOT
22593: IFFALSE 22597
// exit ;
22595: GO 24228
// if name then
22597: LD_VAR 0 3
22601: IFFALSE 22617
// SetBName ( base_dep , name ) ;
22603: LD_VAR 0 1
22607: PPUSH
22608: LD_VAR 0 3
22612: PPUSH
22613: CALL_OW 500
// base := GetBase ( base_dep ) ;
22617: LD_ADDR_VAR 0 15
22621: PUSH
22622: LD_VAR 0 1
22626: PPUSH
22627: CALL_OW 274
22631: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
22632: LD_ADDR_VAR 0 16
22636: PUSH
22637: LD_VAR 0 1
22641: PPUSH
22642: CALL_OW 255
22646: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22647: LD_ADDR_VAR 0 17
22651: PUSH
22652: LD_VAR 0 1
22656: PPUSH
22657: CALL_OW 248
22661: ST_TO_ADDR
// if sources then
22662: LD_VAR 0 5
22666: IFFALSE 22713
// for i = 1 to 3 do
22668: LD_ADDR_VAR 0 8
22672: PUSH
22673: DOUBLE
22674: LD_INT 1
22676: DEC
22677: ST_TO_ADDR
22678: LD_INT 3
22680: PUSH
22681: FOR_TO
22682: IFFALSE 22711
// AddResourceType ( base , i , sources [ i ] ) ;
22684: LD_VAR 0 15
22688: PPUSH
22689: LD_VAR 0 8
22693: PPUSH
22694: LD_VAR 0 5
22698: PUSH
22699: LD_VAR 0 8
22703: ARRAY
22704: PPUSH
22705: CALL_OW 276
22709: GO 22681
22711: POP
22712: POP
// buildings := GetBaseBuildings ( base , area ) ;
22713: LD_ADDR_VAR 0 18
22717: PUSH
22718: LD_VAR 0 15
22722: PPUSH
22723: LD_VAR 0 2
22727: PPUSH
22728: CALL 22005 0 2
22732: ST_TO_ADDR
// InitHc ;
22733: CALL_OW 19
// InitUc ;
22737: CALL_OW 18
// uc_side := side ;
22741: LD_ADDR_OWVAR 20
22745: PUSH
22746: LD_VAR 0 16
22750: ST_TO_ADDR
// uc_nation := nation ;
22751: LD_ADDR_OWVAR 21
22755: PUSH
22756: LD_VAR 0 17
22760: ST_TO_ADDR
// if buildings then
22761: LD_VAR 0 18
22765: IFFALSE 24087
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22767: LD_ADDR_VAR 0 19
22771: PUSH
22772: LD_VAR 0 18
22776: PPUSH
22777: LD_INT 2
22779: PUSH
22780: LD_INT 30
22782: PUSH
22783: LD_INT 29
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: PUSH
22790: LD_INT 30
22792: PUSH
22793: LD_INT 30
22795: PUSH
22796: EMPTY
22797: LIST
22798: LIST
22799: PUSH
22800: EMPTY
22801: LIST
22802: LIST
22803: LIST
22804: PPUSH
22805: CALL_OW 72
22809: ST_TO_ADDR
// if tmp then
22810: LD_VAR 0 19
22814: IFFALSE 22862
// for i in tmp do
22816: LD_ADDR_VAR 0 8
22820: PUSH
22821: LD_VAR 0 19
22825: PUSH
22826: FOR_IN
22827: IFFALSE 22860
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22829: LD_VAR 0 8
22833: PPUSH
22834: CALL_OW 250
22838: PPUSH
22839: LD_VAR 0 8
22843: PPUSH
22844: CALL_OW 251
22848: PPUSH
22849: LD_VAR 0 16
22853: PPUSH
22854: CALL_OW 441
22858: GO 22826
22860: POP
22861: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22862: LD_VAR 0 18
22866: PPUSH
22867: LD_INT 2
22869: PUSH
22870: LD_INT 30
22872: PUSH
22873: LD_INT 32
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: PUSH
22880: LD_INT 30
22882: PUSH
22883: LD_INT 33
22885: PUSH
22886: EMPTY
22887: LIST
22888: LIST
22889: PUSH
22890: EMPTY
22891: LIST
22892: LIST
22893: LIST
22894: PPUSH
22895: CALL_OW 72
22899: IFFALSE 22987
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22901: LD_ADDR_VAR 0 8
22905: PUSH
22906: LD_VAR 0 18
22910: PPUSH
22911: LD_INT 2
22913: PUSH
22914: LD_INT 30
22916: PUSH
22917: LD_INT 32
22919: PUSH
22920: EMPTY
22921: LIST
22922: LIST
22923: PUSH
22924: LD_INT 30
22926: PUSH
22927: LD_INT 33
22929: PUSH
22930: EMPTY
22931: LIST
22932: LIST
22933: PUSH
22934: EMPTY
22935: LIST
22936: LIST
22937: LIST
22938: PPUSH
22939: CALL_OW 72
22943: PUSH
22944: FOR_IN
22945: IFFALSE 22985
// begin if not GetBWeapon ( i ) then
22947: LD_VAR 0 8
22951: PPUSH
22952: CALL_OW 269
22956: NOT
22957: IFFALSE 22983
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22959: LD_VAR 0 8
22963: PPUSH
22964: LD_VAR 0 8
22968: PPUSH
22969: LD_VAR 0 2
22973: PPUSH
22974: CALL 24233 0 2
22978: PPUSH
22979: CALL_OW 431
// end ;
22983: GO 22944
22985: POP
22986: POP
// end ; for i = 1 to personel do
22987: LD_ADDR_VAR 0 8
22991: PUSH
22992: DOUBLE
22993: LD_INT 1
22995: DEC
22996: ST_TO_ADDR
22997: LD_VAR 0 6
23001: PUSH
23002: FOR_TO
23003: IFFALSE 24067
// begin if i > 4 then
23005: LD_VAR 0 8
23009: PUSH
23010: LD_INT 4
23012: GREATER
23013: IFFALSE 23017
// break ;
23015: GO 24067
// case i of 1 :
23017: LD_VAR 0 8
23021: PUSH
23022: LD_INT 1
23024: DOUBLE
23025: EQUAL
23026: IFTRUE 23030
23028: GO 23110
23030: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23031: LD_ADDR_VAR 0 12
23035: PUSH
23036: LD_VAR 0 18
23040: PPUSH
23041: LD_INT 22
23043: PUSH
23044: LD_VAR 0 16
23048: PUSH
23049: EMPTY
23050: LIST
23051: LIST
23052: PUSH
23053: LD_INT 58
23055: PUSH
23056: EMPTY
23057: LIST
23058: PUSH
23059: LD_INT 2
23061: PUSH
23062: LD_INT 30
23064: PUSH
23065: LD_INT 32
23067: PUSH
23068: EMPTY
23069: LIST
23070: LIST
23071: PUSH
23072: LD_INT 30
23074: PUSH
23075: LD_INT 4
23077: PUSH
23078: EMPTY
23079: LIST
23080: LIST
23081: PUSH
23082: LD_INT 30
23084: PUSH
23085: LD_INT 5
23087: PUSH
23088: EMPTY
23089: LIST
23090: LIST
23091: PUSH
23092: EMPTY
23093: LIST
23094: LIST
23095: LIST
23096: LIST
23097: PUSH
23098: EMPTY
23099: LIST
23100: LIST
23101: LIST
23102: PPUSH
23103: CALL_OW 72
23107: ST_TO_ADDR
23108: GO 23332
23110: LD_INT 2
23112: DOUBLE
23113: EQUAL
23114: IFTRUE 23118
23116: GO 23180
23118: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23119: LD_ADDR_VAR 0 12
23123: PUSH
23124: LD_VAR 0 18
23128: PPUSH
23129: LD_INT 22
23131: PUSH
23132: LD_VAR 0 16
23136: PUSH
23137: EMPTY
23138: LIST
23139: LIST
23140: PUSH
23141: LD_INT 2
23143: PUSH
23144: LD_INT 30
23146: PUSH
23147: LD_INT 0
23149: PUSH
23150: EMPTY
23151: LIST
23152: LIST
23153: PUSH
23154: LD_INT 30
23156: PUSH
23157: LD_INT 1
23159: PUSH
23160: EMPTY
23161: LIST
23162: LIST
23163: PUSH
23164: EMPTY
23165: LIST
23166: LIST
23167: LIST
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: PPUSH
23173: CALL_OW 72
23177: ST_TO_ADDR
23178: GO 23332
23180: LD_INT 3
23182: DOUBLE
23183: EQUAL
23184: IFTRUE 23188
23186: GO 23250
23188: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23189: LD_ADDR_VAR 0 12
23193: PUSH
23194: LD_VAR 0 18
23198: PPUSH
23199: LD_INT 22
23201: PUSH
23202: LD_VAR 0 16
23206: PUSH
23207: EMPTY
23208: LIST
23209: LIST
23210: PUSH
23211: LD_INT 2
23213: PUSH
23214: LD_INT 30
23216: PUSH
23217: LD_INT 2
23219: PUSH
23220: EMPTY
23221: LIST
23222: LIST
23223: PUSH
23224: LD_INT 30
23226: PUSH
23227: LD_INT 3
23229: PUSH
23230: EMPTY
23231: LIST
23232: LIST
23233: PUSH
23234: EMPTY
23235: LIST
23236: LIST
23237: LIST
23238: PUSH
23239: EMPTY
23240: LIST
23241: LIST
23242: PPUSH
23243: CALL_OW 72
23247: ST_TO_ADDR
23248: GO 23332
23250: LD_INT 4
23252: DOUBLE
23253: EQUAL
23254: IFTRUE 23258
23256: GO 23331
23258: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23259: LD_ADDR_VAR 0 12
23263: PUSH
23264: LD_VAR 0 18
23268: PPUSH
23269: LD_INT 22
23271: PUSH
23272: LD_VAR 0 16
23276: PUSH
23277: EMPTY
23278: LIST
23279: LIST
23280: PUSH
23281: LD_INT 2
23283: PUSH
23284: LD_INT 30
23286: PUSH
23287: LD_INT 6
23289: PUSH
23290: EMPTY
23291: LIST
23292: LIST
23293: PUSH
23294: LD_INT 30
23296: PUSH
23297: LD_INT 7
23299: PUSH
23300: EMPTY
23301: LIST
23302: LIST
23303: PUSH
23304: LD_INT 30
23306: PUSH
23307: LD_INT 8
23309: PUSH
23310: EMPTY
23311: LIST
23312: LIST
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: LIST
23318: LIST
23319: PUSH
23320: EMPTY
23321: LIST
23322: LIST
23323: PPUSH
23324: CALL_OW 72
23328: ST_TO_ADDR
23329: GO 23332
23331: POP
// if i = 1 then
23332: LD_VAR 0 8
23336: PUSH
23337: LD_INT 1
23339: EQUAL
23340: IFFALSE 23451
// begin tmp := [ ] ;
23342: LD_ADDR_VAR 0 19
23346: PUSH
23347: EMPTY
23348: ST_TO_ADDR
// for j in f do
23349: LD_ADDR_VAR 0 9
23353: PUSH
23354: LD_VAR 0 12
23358: PUSH
23359: FOR_IN
23360: IFFALSE 23433
// if GetBType ( j ) = b_bunker then
23362: LD_VAR 0 9
23366: PPUSH
23367: CALL_OW 266
23371: PUSH
23372: LD_INT 32
23374: EQUAL
23375: IFFALSE 23402
// tmp := Insert ( tmp , 1 , j ) else
23377: LD_ADDR_VAR 0 19
23381: PUSH
23382: LD_VAR 0 19
23386: PPUSH
23387: LD_INT 1
23389: PPUSH
23390: LD_VAR 0 9
23394: PPUSH
23395: CALL_OW 2
23399: ST_TO_ADDR
23400: GO 23431
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23402: LD_ADDR_VAR 0 19
23406: PUSH
23407: LD_VAR 0 19
23411: PPUSH
23412: LD_VAR 0 19
23416: PUSH
23417: LD_INT 1
23419: PLUS
23420: PPUSH
23421: LD_VAR 0 9
23425: PPUSH
23426: CALL_OW 2
23430: ST_TO_ADDR
23431: GO 23359
23433: POP
23434: POP
// if tmp then
23435: LD_VAR 0 19
23439: IFFALSE 23451
// f := tmp ;
23441: LD_ADDR_VAR 0 12
23445: PUSH
23446: LD_VAR 0 19
23450: ST_TO_ADDR
// end ; x := personel [ i ] ;
23451: LD_ADDR_VAR 0 13
23455: PUSH
23456: LD_VAR 0 6
23460: PUSH
23461: LD_VAR 0 8
23465: ARRAY
23466: ST_TO_ADDR
// if x = - 1 then
23467: LD_VAR 0 13
23471: PUSH
23472: LD_INT 1
23474: NEG
23475: EQUAL
23476: IFFALSE 23685
// begin for j in f do
23478: LD_ADDR_VAR 0 9
23482: PUSH
23483: LD_VAR 0 12
23487: PUSH
23488: FOR_IN
23489: IFFALSE 23681
// repeat InitHc ;
23491: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23495: LD_VAR 0 9
23499: PPUSH
23500: CALL_OW 266
23504: PUSH
23505: LD_INT 5
23507: EQUAL
23508: IFFALSE 23578
// begin if UnitsInside ( j ) < 3 then
23510: LD_VAR 0 9
23514: PPUSH
23515: CALL_OW 313
23519: PUSH
23520: LD_INT 3
23522: LESS
23523: IFFALSE 23559
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23525: LD_INT 0
23527: PPUSH
23528: LD_INT 5
23530: PUSH
23531: LD_INT 8
23533: PUSH
23534: LD_INT 9
23536: PUSH
23537: EMPTY
23538: LIST
23539: LIST
23540: LIST
23541: PUSH
23542: LD_VAR 0 17
23546: ARRAY
23547: PPUSH
23548: LD_VAR 0 4
23552: PPUSH
23553: CALL_OW 380
23557: GO 23576
// PrepareHuman ( false , i , skill ) ;
23559: LD_INT 0
23561: PPUSH
23562: LD_VAR 0 8
23566: PPUSH
23567: LD_VAR 0 4
23571: PPUSH
23572: CALL_OW 380
// end else
23576: GO 23595
// PrepareHuman ( false , i , skill ) ;
23578: LD_INT 0
23580: PPUSH
23581: LD_VAR 0 8
23585: PPUSH
23586: LD_VAR 0 4
23590: PPUSH
23591: CALL_OW 380
// un := CreateHuman ;
23595: LD_ADDR_VAR 0 14
23599: PUSH
23600: CALL_OW 44
23604: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23605: LD_ADDR_VAR 0 7
23609: PUSH
23610: LD_VAR 0 7
23614: PPUSH
23615: LD_INT 1
23617: PPUSH
23618: LD_VAR 0 14
23622: PPUSH
23623: CALL_OW 2
23627: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
23628: LD_VAR 0 14
23632: PPUSH
23633: LD_VAR 0 9
23637: PPUSH
23638: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23642: LD_VAR 0 9
23646: PPUSH
23647: CALL_OW 313
23651: PUSH
23652: LD_INT 6
23654: EQUAL
23655: PUSH
23656: LD_VAR 0 9
23660: PPUSH
23661: CALL_OW 266
23665: PUSH
23666: LD_INT 32
23668: PUSH
23669: LD_INT 31
23671: PUSH
23672: EMPTY
23673: LIST
23674: LIST
23675: IN
23676: OR
23677: IFFALSE 23491
23679: GO 23488
23681: POP
23682: POP
// end else
23683: GO 24065
// for j = 1 to x do
23685: LD_ADDR_VAR 0 9
23689: PUSH
23690: DOUBLE
23691: LD_INT 1
23693: DEC
23694: ST_TO_ADDR
23695: LD_VAR 0 13
23699: PUSH
23700: FOR_TO
23701: IFFALSE 24063
// begin InitHc ;
23703: CALL_OW 19
// if not f then
23707: LD_VAR 0 12
23711: NOT
23712: IFFALSE 23801
// begin PrepareHuman ( false , i , skill ) ;
23714: LD_INT 0
23716: PPUSH
23717: LD_VAR 0 8
23721: PPUSH
23722: LD_VAR 0 4
23726: PPUSH
23727: CALL_OW 380
// un := CreateHuman ;
23731: LD_ADDR_VAR 0 14
23735: PUSH
23736: CALL_OW 44
23740: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23741: LD_ADDR_VAR 0 7
23745: PUSH
23746: LD_VAR 0 7
23750: PPUSH
23751: LD_INT 1
23753: PPUSH
23754: LD_VAR 0 14
23758: PPUSH
23759: CALL_OW 2
23763: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23764: LD_VAR 0 14
23768: PPUSH
23769: LD_VAR 0 1
23773: PPUSH
23774: CALL_OW 250
23778: PPUSH
23779: LD_VAR 0 1
23783: PPUSH
23784: CALL_OW 251
23788: PPUSH
23789: LD_INT 10
23791: PPUSH
23792: LD_INT 0
23794: PPUSH
23795: CALL_OW 50
// continue ;
23799: GO 23700
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23801: LD_VAR 0 12
23805: PUSH
23806: LD_INT 1
23808: ARRAY
23809: PPUSH
23810: CALL_OW 313
23814: PUSH
23815: LD_VAR 0 12
23819: PUSH
23820: LD_INT 1
23822: ARRAY
23823: PPUSH
23824: CALL_OW 266
23828: PUSH
23829: LD_INT 32
23831: PUSH
23832: LD_INT 31
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: IN
23839: AND
23840: PUSH
23841: LD_VAR 0 12
23845: PUSH
23846: LD_INT 1
23848: ARRAY
23849: PPUSH
23850: CALL_OW 313
23854: PUSH
23855: LD_INT 6
23857: EQUAL
23858: OR
23859: IFFALSE 23879
// f := Delete ( f , 1 ) ;
23861: LD_ADDR_VAR 0 12
23865: PUSH
23866: LD_VAR 0 12
23870: PPUSH
23871: LD_INT 1
23873: PPUSH
23874: CALL_OW 3
23878: ST_TO_ADDR
// if not f then
23879: LD_VAR 0 12
23883: NOT
23884: IFFALSE 23902
// begin x := x + 2 ;
23886: LD_ADDR_VAR 0 13
23890: PUSH
23891: LD_VAR 0 13
23895: PUSH
23896: LD_INT 2
23898: PLUS
23899: ST_TO_ADDR
// continue ;
23900: GO 23700
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23902: LD_VAR 0 12
23906: PUSH
23907: LD_INT 1
23909: ARRAY
23910: PPUSH
23911: CALL_OW 266
23915: PUSH
23916: LD_INT 5
23918: EQUAL
23919: IFFALSE 23993
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23921: LD_VAR 0 12
23925: PUSH
23926: LD_INT 1
23928: ARRAY
23929: PPUSH
23930: CALL_OW 313
23934: PUSH
23935: LD_INT 3
23937: LESS
23938: IFFALSE 23974
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23940: LD_INT 0
23942: PPUSH
23943: LD_INT 5
23945: PUSH
23946: LD_INT 8
23948: PUSH
23949: LD_INT 9
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: LIST
23956: PUSH
23957: LD_VAR 0 17
23961: ARRAY
23962: PPUSH
23963: LD_VAR 0 4
23967: PPUSH
23968: CALL_OW 380
23972: GO 23991
// PrepareHuman ( false , i , skill ) ;
23974: LD_INT 0
23976: PPUSH
23977: LD_VAR 0 8
23981: PPUSH
23982: LD_VAR 0 4
23986: PPUSH
23987: CALL_OW 380
// end else
23991: GO 24010
// PrepareHuman ( false , i , skill ) ;
23993: LD_INT 0
23995: PPUSH
23996: LD_VAR 0 8
24000: PPUSH
24001: LD_VAR 0 4
24005: PPUSH
24006: CALL_OW 380
// un := CreateHuman ;
24010: LD_ADDR_VAR 0 14
24014: PUSH
24015: CALL_OW 44
24019: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24020: LD_ADDR_VAR 0 7
24024: PUSH
24025: LD_VAR 0 7
24029: PPUSH
24030: LD_INT 1
24032: PPUSH
24033: LD_VAR 0 14
24037: PPUSH
24038: CALL_OW 2
24042: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24043: LD_VAR 0 14
24047: PPUSH
24048: LD_VAR 0 12
24052: PUSH
24053: LD_INT 1
24055: ARRAY
24056: PPUSH
24057: CALL_OW 52
// end ;
24061: GO 23700
24063: POP
24064: POP
// end ;
24065: GO 23002
24067: POP
24068: POP
// result := result ^ buildings ;
24069: LD_ADDR_VAR 0 7
24073: PUSH
24074: LD_VAR 0 7
24078: PUSH
24079: LD_VAR 0 18
24083: ADD
24084: ST_TO_ADDR
// end else
24085: GO 24228
// begin for i = 1 to personel do
24087: LD_ADDR_VAR 0 8
24091: PUSH
24092: DOUBLE
24093: LD_INT 1
24095: DEC
24096: ST_TO_ADDR
24097: LD_VAR 0 6
24101: PUSH
24102: FOR_TO
24103: IFFALSE 24226
// begin if i > 4 then
24105: LD_VAR 0 8
24109: PUSH
24110: LD_INT 4
24112: GREATER
24113: IFFALSE 24117
// break ;
24115: GO 24226
// x := personel [ i ] ;
24117: LD_ADDR_VAR 0 13
24121: PUSH
24122: LD_VAR 0 6
24126: PUSH
24127: LD_VAR 0 8
24131: ARRAY
24132: ST_TO_ADDR
// if x = - 1 then
24133: LD_VAR 0 13
24137: PUSH
24138: LD_INT 1
24140: NEG
24141: EQUAL
24142: IFFALSE 24146
// continue ;
24144: GO 24102
// PrepareHuman ( false , i , skill ) ;
24146: LD_INT 0
24148: PPUSH
24149: LD_VAR 0 8
24153: PPUSH
24154: LD_VAR 0 4
24158: PPUSH
24159: CALL_OW 380
// un := CreateHuman ;
24163: LD_ADDR_VAR 0 14
24167: PUSH
24168: CALL_OW 44
24172: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24173: LD_VAR 0 14
24177: PPUSH
24178: LD_VAR 0 1
24182: PPUSH
24183: CALL_OW 250
24187: PPUSH
24188: LD_VAR 0 1
24192: PPUSH
24193: CALL_OW 251
24197: PPUSH
24198: LD_INT 10
24200: PPUSH
24201: LD_INT 0
24203: PPUSH
24204: CALL_OW 50
// result := result ^ un ;
24208: LD_ADDR_VAR 0 7
24212: PUSH
24213: LD_VAR 0 7
24217: PUSH
24218: LD_VAR 0 14
24222: ADD
24223: ST_TO_ADDR
// end ;
24224: GO 24102
24226: POP
24227: POP
// end ; end ;
24228: LD_VAR 0 7
24232: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24233: LD_INT 0
24235: PPUSH
24236: PPUSH
24237: PPUSH
24238: PPUSH
24239: PPUSH
24240: PPUSH
24241: PPUSH
24242: PPUSH
24243: PPUSH
24244: PPUSH
24245: PPUSH
24246: PPUSH
24247: PPUSH
24248: PPUSH
24249: PPUSH
24250: PPUSH
// result := false ;
24251: LD_ADDR_VAR 0 3
24255: PUSH
24256: LD_INT 0
24258: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24259: LD_VAR 0 1
24263: NOT
24264: PUSH
24265: LD_VAR 0 1
24269: PPUSH
24270: CALL_OW 266
24274: PUSH
24275: LD_INT 32
24277: PUSH
24278: LD_INT 33
24280: PUSH
24281: EMPTY
24282: LIST
24283: LIST
24284: IN
24285: NOT
24286: OR
24287: IFFALSE 24291
// exit ;
24289: GO 25427
// nat := GetNation ( tower ) ;
24291: LD_ADDR_VAR 0 12
24295: PUSH
24296: LD_VAR 0 1
24300: PPUSH
24301: CALL_OW 248
24305: ST_TO_ADDR
// side := GetSide ( tower ) ;
24306: LD_ADDR_VAR 0 16
24310: PUSH
24311: LD_VAR 0 1
24315: PPUSH
24316: CALL_OW 255
24320: ST_TO_ADDR
// x := GetX ( tower ) ;
24321: LD_ADDR_VAR 0 10
24325: PUSH
24326: LD_VAR 0 1
24330: PPUSH
24331: CALL_OW 250
24335: ST_TO_ADDR
// y := GetY ( tower ) ;
24336: LD_ADDR_VAR 0 11
24340: PUSH
24341: LD_VAR 0 1
24345: PPUSH
24346: CALL_OW 251
24350: ST_TO_ADDR
// if not x or not y then
24351: LD_VAR 0 10
24355: NOT
24356: PUSH
24357: LD_VAR 0 11
24361: NOT
24362: OR
24363: IFFALSE 24367
// exit ;
24365: GO 25427
// weapon := 0 ;
24367: LD_ADDR_VAR 0 18
24371: PUSH
24372: LD_INT 0
24374: ST_TO_ADDR
// fac_list := [ ] ;
24375: LD_ADDR_VAR 0 17
24379: PUSH
24380: EMPTY
24381: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
24382: LD_ADDR_VAR 0 6
24386: PUSH
24387: LD_VAR 0 1
24391: PPUSH
24392: CALL_OW 274
24396: PPUSH
24397: LD_VAR 0 2
24401: PPUSH
24402: CALL 22005 0 2
24406: PPUSH
24407: LD_INT 30
24409: PUSH
24410: LD_INT 3
24412: PUSH
24413: EMPTY
24414: LIST
24415: LIST
24416: PPUSH
24417: CALL_OW 72
24421: ST_TO_ADDR
// if not factories then
24422: LD_VAR 0 6
24426: NOT
24427: IFFALSE 24431
// exit ;
24429: GO 25427
// for i in factories do
24431: LD_ADDR_VAR 0 8
24435: PUSH
24436: LD_VAR 0 6
24440: PUSH
24441: FOR_IN
24442: IFFALSE 24467
// fac_list := fac_list union AvailableWeaponList ( i ) ;
24444: LD_ADDR_VAR 0 17
24448: PUSH
24449: LD_VAR 0 17
24453: PUSH
24454: LD_VAR 0 8
24458: PPUSH
24459: CALL_OW 478
24463: UNION
24464: ST_TO_ADDR
24465: GO 24441
24467: POP
24468: POP
// if not fac_list then
24469: LD_VAR 0 17
24473: NOT
24474: IFFALSE 24478
// exit ;
24476: GO 25427
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24478: LD_ADDR_VAR 0 5
24482: PUSH
24483: LD_INT 4
24485: PUSH
24486: LD_INT 5
24488: PUSH
24489: LD_INT 9
24491: PUSH
24492: LD_INT 10
24494: PUSH
24495: LD_INT 6
24497: PUSH
24498: LD_INT 7
24500: PUSH
24501: LD_INT 11
24503: PUSH
24504: EMPTY
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: PUSH
24513: LD_INT 27
24515: PUSH
24516: LD_INT 28
24518: PUSH
24519: LD_INT 26
24521: PUSH
24522: LD_INT 30
24524: PUSH
24525: EMPTY
24526: LIST
24527: LIST
24528: LIST
24529: LIST
24530: PUSH
24531: LD_INT 43
24533: PUSH
24534: LD_INT 44
24536: PUSH
24537: LD_INT 46
24539: PUSH
24540: LD_INT 45
24542: PUSH
24543: LD_INT 47
24545: PUSH
24546: LD_INT 49
24548: PUSH
24549: EMPTY
24550: LIST
24551: LIST
24552: LIST
24553: LIST
24554: LIST
24555: LIST
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: LIST
24561: PUSH
24562: LD_VAR 0 12
24566: ARRAY
24567: ST_TO_ADDR
// for i in list do
24568: LD_ADDR_VAR 0 8
24572: PUSH
24573: LD_VAR 0 5
24577: PUSH
24578: FOR_IN
24579: IFFALSE 24612
// if not i in fac_list then
24581: LD_VAR 0 8
24585: PUSH
24586: LD_VAR 0 17
24590: IN
24591: NOT
24592: IFFALSE 24610
// list := list diff i ;
24594: LD_ADDR_VAR 0 5
24598: PUSH
24599: LD_VAR 0 5
24603: PUSH
24604: LD_VAR 0 8
24608: DIFF
24609: ST_TO_ADDR
24610: GO 24578
24612: POP
24613: POP
// if not list then
24614: LD_VAR 0 5
24618: NOT
24619: IFFALSE 24623
// exit ;
24621: GO 25427
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
24623: LD_VAR 0 12
24627: PUSH
24628: LD_INT 3
24630: EQUAL
24631: PUSH
24632: LD_INT 49
24634: PUSH
24635: LD_VAR 0 5
24639: IN
24640: AND
24641: PUSH
24642: LD_INT 31
24644: PPUSH
24645: LD_VAR 0 16
24649: PPUSH
24650: CALL_OW 321
24654: PUSH
24655: LD_INT 2
24657: EQUAL
24658: AND
24659: IFFALSE 24719
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
24661: LD_INT 22
24663: PUSH
24664: LD_VAR 0 16
24668: PUSH
24669: EMPTY
24670: LIST
24671: LIST
24672: PUSH
24673: LD_INT 35
24675: PUSH
24676: LD_INT 49
24678: PUSH
24679: EMPTY
24680: LIST
24681: LIST
24682: PUSH
24683: LD_INT 91
24685: PUSH
24686: LD_VAR 0 1
24690: PUSH
24691: LD_INT 10
24693: PUSH
24694: EMPTY
24695: LIST
24696: LIST
24697: LIST
24698: PUSH
24699: EMPTY
24700: LIST
24701: LIST
24702: LIST
24703: PPUSH
24704: CALL_OW 69
24708: NOT
24709: IFFALSE 24719
// weapon := ru_time_lapser ;
24711: LD_ADDR_VAR 0 18
24715: PUSH
24716: LD_INT 49
24718: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24719: LD_VAR 0 12
24723: PUSH
24724: LD_INT 1
24726: PUSH
24727: LD_INT 2
24729: PUSH
24730: EMPTY
24731: LIST
24732: LIST
24733: IN
24734: PUSH
24735: LD_INT 11
24737: PUSH
24738: LD_VAR 0 5
24742: IN
24743: PUSH
24744: LD_INT 30
24746: PUSH
24747: LD_VAR 0 5
24751: IN
24752: OR
24753: AND
24754: PUSH
24755: LD_INT 6
24757: PPUSH
24758: LD_VAR 0 16
24762: PPUSH
24763: CALL_OW 321
24767: PUSH
24768: LD_INT 2
24770: EQUAL
24771: AND
24772: IFFALSE 24937
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24774: LD_INT 22
24776: PUSH
24777: LD_VAR 0 16
24781: PUSH
24782: EMPTY
24783: LIST
24784: LIST
24785: PUSH
24786: LD_INT 2
24788: PUSH
24789: LD_INT 35
24791: PUSH
24792: LD_INT 11
24794: PUSH
24795: EMPTY
24796: LIST
24797: LIST
24798: PUSH
24799: LD_INT 35
24801: PUSH
24802: LD_INT 30
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: LIST
24813: PUSH
24814: LD_INT 91
24816: PUSH
24817: LD_VAR 0 1
24821: PUSH
24822: LD_INT 18
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: LIST
24829: PUSH
24830: EMPTY
24831: LIST
24832: LIST
24833: LIST
24834: PPUSH
24835: CALL_OW 69
24839: NOT
24840: PUSH
24841: LD_INT 22
24843: PUSH
24844: LD_VAR 0 16
24848: PUSH
24849: EMPTY
24850: LIST
24851: LIST
24852: PUSH
24853: LD_INT 2
24855: PUSH
24856: LD_INT 30
24858: PUSH
24859: LD_INT 32
24861: PUSH
24862: EMPTY
24863: LIST
24864: LIST
24865: PUSH
24866: LD_INT 30
24868: PUSH
24869: LD_INT 33
24871: PUSH
24872: EMPTY
24873: LIST
24874: LIST
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: LIST
24880: PUSH
24881: LD_INT 91
24883: PUSH
24884: LD_VAR 0 1
24888: PUSH
24889: LD_INT 12
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: LIST
24896: PUSH
24897: EMPTY
24898: LIST
24899: LIST
24900: LIST
24901: PUSH
24902: EMPTY
24903: LIST
24904: PPUSH
24905: CALL_OW 69
24909: PUSH
24910: LD_INT 2
24912: GREATER
24913: AND
24914: IFFALSE 24937
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24916: LD_ADDR_VAR 0 18
24920: PUSH
24921: LD_INT 11
24923: PUSH
24924: LD_INT 30
24926: PUSH
24927: EMPTY
24928: LIST
24929: LIST
24930: PUSH
24931: LD_VAR 0 12
24935: ARRAY
24936: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24937: LD_VAR 0 18
24941: NOT
24942: PUSH
24943: LD_INT 40
24945: PPUSH
24946: LD_VAR 0 16
24950: PPUSH
24951: CALL_OW 321
24955: PUSH
24956: LD_INT 2
24958: EQUAL
24959: AND
24960: PUSH
24961: LD_INT 7
24963: PUSH
24964: LD_VAR 0 5
24968: IN
24969: PUSH
24970: LD_INT 28
24972: PUSH
24973: LD_VAR 0 5
24977: IN
24978: OR
24979: PUSH
24980: LD_INT 45
24982: PUSH
24983: LD_VAR 0 5
24987: IN
24988: OR
24989: AND
24990: IFFALSE 25244
// begin hex := GetHexInfo ( x , y ) ;
24992: LD_ADDR_VAR 0 4
24996: PUSH
24997: LD_VAR 0 10
25001: PPUSH
25002: LD_VAR 0 11
25006: PPUSH
25007: CALL_OW 546
25011: ST_TO_ADDR
// if hex [ 1 ] then
25012: LD_VAR 0 4
25016: PUSH
25017: LD_INT 1
25019: ARRAY
25020: IFFALSE 25024
// exit ;
25022: GO 25427
// height := hex [ 2 ] ;
25024: LD_ADDR_VAR 0 15
25028: PUSH
25029: LD_VAR 0 4
25033: PUSH
25034: LD_INT 2
25036: ARRAY
25037: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25038: LD_ADDR_VAR 0 14
25042: PUSH
25043: LD_INT 0
25045: PUSH
25046: LD_INT 2
25048: PUSH
25049: LD_INT 3
25051: PUSH
25052: LD_INT 5
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: LIST
25059: LIST
25060: ST_TO_ADDR
// for i in tmp do
25061: LD_ADDR_VAR 0 8
25065: PUSH
25066: LD_VAR 0 14
25070: PUSH
25071: FOR_IN
25072: IFFALSE 25242
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25074: LD_ADDR_VAR 0 9
25078: PUSH
25079: LD_VAR 0 10
25083: PPUSH
25084: LD_VAR 0 8
25088: PPUSH
25089: LD_INT 5
25091: PPUSH
25092: CALL_OW 272
25096: PUSH
25097: LD_VAR 0 11
25101: PPUSH
25102: LD_VAR 0 8
25106: PPUSH
25107: LD_INT 5
25109: PPUSH
25110: CALL_OW 273
25114: PUSH
25115: EMPTY
25116: LIST
25117: LIST
25118: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25119: LD_VAR 0 9
25123: PUSH
25124: LD_INT 1
25126: ARRAY
25127: PPUSH
25128: LD_VAR 0 9
25132: PUSH
25133: LD_INT 2
25135: ARRAY
25136: PPUSH
25137: CALL_OW 488
25141: IFFALSE 25240
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25143: LD_ADDR_VAR 0 4
25147: PUSH
25148: LD_VAR 0 9
25152: PUSH
25153: LD_INT 1
25155: ARRAY
25156: PPUSH
25157: LD_VAR 0 9
25161: PUSH
25162: LD_INT 2
25164: ARRAY
25165: PPUSH
25166: CALL_OW 546
25170: ST_TO_ADDR
// if hex [ 1 ] then
25171: LD_VAR 0 4
25175: PUSH
25176: LD_INT 1
25178: ARRAY
25179: IFFALSE 25183
// continue ;
25181: GO 25071
// h := hex [ 2 ] ;
25183: LD_ADDR_VAR 0 13
25187: PUSH
25188: LD_VAR 0 4
25192: PUSH
25193: LD_INT 2
25195: ARRAY
25196: ST_TO_ADDR
// if h + 7 < height then
25197: LD_VAR 0 13
25201: PUSH
25202: LD_INT 7
25204: PLUS
25205: PUSH
25206: LD_VAR 0 15
25210: LESS
25211: IFFALSE 25240
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25213: LD_ADDR_VAR 0 18
25217: PUSH
25218: LD_INT 7
25220: PUSH
25221: LD_INT 28
25223: PUSH
25224: LD_INT 45
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: LIST
25231: PUSH
25232: LD_VAR 0 12
25236: ARRAY
25237: ST_TO_ADDR
// break ;
25238: GO 25242
// end ; end ; end ;
25240: GO 25071
25242: POP
25243: POP
// end ; if not weapon then
25244: LD_VAR 0 18
25248: NOT
25249: IFFALSE 25309
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25251: LD_ADDR_VAR 0 5
25255: PUSH
25256: LD_VAR 0 5
25260: PUSH
25261: LD_INT 11
25263: PUSH
25264: LD_INT 30
25266: PUSH
25267: LD_INT 49
25269: PUSH
25270: EMPTY
25271: LIST
25272: LIST
25273: LIST
25274: DIFF
25275: ST_TO_ADDR
// if not list then
25276: LD_VAR 0 5
25280: NOT
25281: IFFALSE 25285
// exit ;
25283: GO 25427
// weapon := list [ rand ( 1 , list ) ] ;
25285: LD_ADDR_VAR 0 18
25289: PUSH
25290: LD_VAR 0 5
25294: PUSH
25295: LD_INT 1
25297: PPUSH
25298: LD_VAR 0 5
25302: PPUSH
25303: CALL_OW 12
25307: ARRAY
25308: ST_TO_ADDR
// end ; if weapon then
25309: LD_VAR 0 18
25313: IFFALSE 25427
// begin tmp := CostOfWeapon ( weapon ) ;
25315: LD_ADDR_VAR 0 14
25319: PUSH
25320: LD_VAR 0 18
25324: PPUSH
25325: CALL_OW 451
25329: ST_TO_ADDR
// j := GetBase ( tower ) ;
25330: LD_ADDR_VAR 0 9
25334: PUSH
25335: LD_VAR 0 1
25339: PPUSH
25340: CALL_OW 274
25344: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25345: LD_VAR 0 9
25349: PPUSH
25350: LD_INT 1
25352: PPUSH
25353: CALL_OW 275
25357: PUSH
25358: LD_VAR 0 14
25362: PUSH
25363: LD_INT 1
25365: ARRAY
25366: GREATEREQUAL
25367: PUSH
25368: LD_VAR 0 9
25372: PPUSH
25373: LD_INT 2
25375: PPUSH
25376: CALL_OW 275
25380: PUSH
25381: LD_VAR 0 14
25385: PUSH
25386: LD_INT 2
25388: ARRAY
25389: GREATEREQUAL
25390: AND
25391: PUSH
25392: LD_VAR 0 9
25396: PPUSH
25397: LD_INT 3
25399: PPUSH
25400: CALL_OW 275
25404: PUSH
25405: LD_VAR 0 14
25409: PUSH
25410: LD_INT 3
25412: ARRAY
25413: GREATEREQUAL
25414: AND
25415: IFFALSE 25427
// result := weapon ;
25417: LD_ADDR_VAR 0 3
25421: PUSH
25422: LD_VAR 0 18
25426: ST_TO_ADDR
// end ; end ;
25427: LD_VAR 0 3
25431: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25432: LD_INT 0
25434: PPUSH
25435: PPUSH
// result := true ;
25436: LD_ADDR_VAR 0 3
25440: PUSH
25441: LD_INT 1
25443: ST_TO_ADDR
// if array1 = array2 then
25444: LD_VAR 0 1
25448: PUSH
25449: LD_VAR 0 2
25453: EQUAL
25454: IFFALSE 25514
// begin for i = 1 to array1 do
25456: LD_ADDR_VAR 0 4
25460: PUSH
25461: DOUBLE
25462: LD_INT 1
25464: DEC
25465: ST_TO_ADDR
25466: LD_VAR 0 1
25470: PUSH
25471: FOR_TO
25472: IFFALSE 25510
// if array1 [ i ] <> array2 [ i ] then
25474: LD_VAR 0 1
25478: PUSH
25479: LD_VAR 0 4
25483: ARRAY
25484: PUSH
25485: LD_VAR 0 2
25489: PUSH
25490: LD_VAR 0 4
25494: ARRAY
25495: NONEQUAL
25496: IFFALSE 25508
// begin result := false ;
25498: LD_ADDR_VAR 0 3
25502: PUSH
25503: LD_INT 0
25505: ST_TO_ADDR
// break ;
25506: GO 25510
// end ;
25508: GO 25471
25510: POP
25511: POP
// end else
25512: GO 25522
// result := false ;
25514: LD_ADDR_VAR 0 3
25518: PUSH
25519: LD_INT 0
25521: ST_TO_ADDR
// end ;
25522: LD_VAR 0 3
25526: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
25527: LD_INT 0
25529: PPUSH
25530: PPUSH
25531: PPUSH
// pom := GetBase ( fac ) ;
25532: LD_ADDR_VAR 0 5
25536: PUSH
25537: LD_VAR 0 1
25541: PPUSH
25542: CALL_OW 274
25546: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25547: LD_ADDR_VAR 0 4
25551: PUSH
25552: LD_VAR 0 2
25556: PUSH
25557: LD_INT 1
25559: ARRAY
25560: PPUSH
25561: LD_VAR 0 2
25565: PUSH
25566: LD_INT 2
25568: ARRAY
25569: PPUSH
25570: LD_VAR 0 2
25574: PUSH
25575: LD_INT 3
25577: ARRAY
25578: PPUSH
25579: LD_VAR 0 2
25583: PUSH
25584: LD_INT 4
25586: ARRAY
25587: PPUSH
25588: CALL_OW 449
25592: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25593: LD_ADDR_VAR 0 3
25597: PUSH
25598: LD_VAR 0 5
25602: PPUSH
25603: LD_INT 1
25605: PPUSH
25606: CALL_OW 275
25610: PUSH
25611: LD_VAR 0 4
25615: PUSH
25616: LD_INT 1
25618: ARRAY
25619: GREATEREQUAL
25620: PUSH
25621: LD_VAR 0 5
25625: PPUSH
25626: LD_INT 2
25628: PPUSH
25629: CALL_OW 275
25633: PUSH
25634: LD_VAR 0 4
25638: PUSH
25639: LD_INT 2
25641: ARRAY
25642: GREATEREQUAL
25643: AND
25644: PUSH
25645: LD_VAR 0 5
25649: PPUSH
25650: LD_INT 3
25652: PPUSH
25653: CALL_OW 275
25657: PUSH
25658: LD_VAR 0 4
25662: PUSH
25663: LD_INT 3
25665: ARRAY
25666: GREATEREQUAL
25667: AND
25668: ST_TO_ADDR
// end ;
25669: LD_VAR 0 3
25673: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25674: LD_INT 0
25676: PPUSH
25677: PPUSH
25678: PPUSH
25679: PPUSH
// pom := GetBase ( building ) ;
25680: LD_ADDR_VAR 0 3
25684: PUSH
25685: LD_VAR 0 1
25689: PPUSH
25690: CALL_OW 274
25694: ST_TO_ADDR
// if not pom then
25695: LD_VAR 0 3
25699: NOT
25700: IFFALSE 25704
// exit ;
25702: GO 25874
// btype := GetBType ( building ) ;
25704: LD_ADDR_VAR 0 5
25708: PUSH
25709: LD_VAR 0 1
25713: PPUSH
25714: CALL_OW 266
25718: ST_TO_ADDR
// if btype = b_armoury then
25719: LD_VAR 0 5
25723: PUSH
25724: LD_INT 4
25726: EQUAL
25727: IFFALSE 25737
// btype := b_barracks ;
25729: LD_ADDR_VAR 0 5
25733: PUSH
25734: LD_INT 5
25736: ST_TO_ADDR
// if btype = b_depot then
25737: LD_VAR 0 5
25741: PUSH
25742: LD_INT 0
25744: EQUAL
25745: IFFALSE 25755
// btype := b_warehouse ;
25747: LD_ADDR_VAR 0 5
25751: PUSH
25752: LD_INT 1
25754: ST_TO_ADDR
// if btype = b_workshop then
25755: LD_VAR 0 5
25759: PUSH
25760: LD_INT 2
25762: EQUAL
25763: IFFALSE 25773
// btype := b_factory ;
25765: LD_ADDR_VAR 0 5
25769: PUSH
25770: LD_INT 3
25772: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25773: LD_ADDR_VAR 0 4
25777: PUSH
25778: LD_VAR 0 5
25782: PPUSH
25783: LD_VAR 0 1
25787: PPUSH
25788: CALL_OW 248
25792: PPUSH
25793: CALL_OW 450
25797: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25798: LD_ADDR_VAR 0 2
25802: PUSH
25803: LD_VAR 0 3
25807: PPUSH
25808: LD_INT 1
25810: PPUSH
25811: CALL_OW 275
25815: PUSH
25816: LD_VAR 0 4
25820: PUSH
25821: LD_INT 1
25823: ARRAY
25824: GREATEREQUAL
25825: PUSH
25826: LD_VAR 0 3
25830: PPUSH
25831: LD_INT 2
25833: PPUSH
25834: CALL_OW 275
25838: PUSH
25839: LD_VAR 0 4
25843: PUSH
25844: LD_INT 2
25846: ARRAY
25847: GREATEREQUAL
25848: AND
25849: PUSH
25850: LD_VAR 0 3
25854: PPUSH
25855: LD_INT 3
25857: PPUSH
25858: CALL_OW 275
25862: PUSH
25863: LD_VAR 0 4
25867: PUSH
25868: LD_INT 3
25870: ARRAY
25871: GREATEREQUAL
25872: AND
25873: ST_TO_ADDR
// end ;
25874: LD_VAR 0 2
25878: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25879: LD_INT 0
25881: PPUSH
25882: PPUSH
25883: PPUSH
// pom := GetBase ( building ) ;
25884: LD_ADDR_VAR 0 4
25888: PUSH
25889: LD_VAR 0 1
25893: PPUSH
25894: CALL_OW 274
25898: ST_TO_ADDR
// if not pom then
25899: LD_VAR 0 4
25903: NOT
25904: IFFALSE 25908
// exit ;
25906: GO 26009
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25908: LD_ADDR_VAR 0 5
25912: PUSH
25913: LD_VAR 0 2
25917: PPUSH
25918: LD_VAR 0 1
25922: PPUSH
25923: CALL_OW 248
25927: PPUSH
25928: CALL_OW 450
25932: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25933: LD_ADDR_VAR 0 3
25937: PUSH
25938: LD_VAR 0 4
25942: PPUSH
25943: LD_INT 1
25945: PPUSH
25946: CALL_OW 275
25950: PUSH
25951: LD_VAR 0 5
25955: PUSH
25956: LD_INT 1
25958: ARRAY
25959: GREATEREQUAL
25960: PUSH
25961: LD_VAR 0 4
25965: PPUSH
25966: LD_INT 2
25968: PPUSH
25969: CALL_OW 275
25973: PUSH
25974: LD_VAR 0 5
25978: PUSH
25979: LD_INT 2
25981: ARRAY
25982: GREATEREQUAL
25983: AND
25984: PUSH
25985: LD_VAR 0 4
25989: PPUSH
25990: LD_INT 3
25992: PPUSH
25993: CALL_OW 275
25997: PUSH
25998: LD_VAR 0 5
26002: PUSH
26003: LD_INT 3
26005: ARRAY
26006: GREATEREQUAL
26007: AND
26008: ST_TO_ADDR
// end ;
26009: LD_VAR 0 3
26013: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
26014: LD_INT 0
26016: PPUSH
26017: PPUSH
26018: PPUSH
26019: PPUSH
26020: PPUSH
26021: PPUSH
26022: PPUSH
26023: PPUSH
26024: PPUSH
26025: PPUSH
// result := false ;
26026: LD_ADDR_VAR 0 6
26030: PUSH
26031: LD_INT 0
26033: ST_TO_ADDR
// if not base or not btype or not x or not y then
26034: LD_VAR 0 1
26038: NOT
26039: PUSH
26040: LD_VAR 0 2
26044: NOT
26045: OR
26046: PUSH
26047: LD_VAR 0 3
26051: NOT
26052: OR
26053: PUSH
26054: LD_VAR 0 4
26058: NOT
26059: OR
26060: IFFALSE 26064
// exit ;
26062: GO 26673
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
26064: LD_ADDR_VAR 0 12
26068: PUSH
26069: LD_VAR 0 2
26073: PPUSH
26074: LD_VAR 0 3
26078: PPUSH
26079: LD_VAR 0 4
26083: PPUSH
26084: LD_VAR 0 5
26088: PPUSH
26089: LD_VAR 0 1
26093: PUSH
26094: LD_INT 1
26096: ARRAY
26097: PPUSH
26098: CALL_OW 248
26102: PPUSH
26103: LD_INT 0
26105: PPUSH
26106: CALL 27510 0 6
26110: ST_TO_ADDR
// if not hexes then
26111: LD_VAR 0 12
26115: NOT
26116: IFFALSE 26120
// exit ;
26118: GO 26673
// for i = 1 to hexes do
26120: LD_ADDR_VAR 0 7
26124: PUSH
26125: DOUBLE
26126: LD_INT 1
26128: DEC
26129: ST_TO_ADDR
26130: LD_VAR 0 12
26134: PUSH
26135: FOR_TO
26136: IFFALSE 26671
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26138: LD_ADDR_VAR 0 11
26142: PUSH
26143: LD_VAR 0 12
26147: PUSH
26148: LD_VAR 0 7
26152: ARRAY
26153: PUSH
26154: LD_INT 1
26156: ARRAY
26157: PPUSH
26158: LD_VAR 0 12
26162: PUSH
26163: LD_VAR 0 7
26167: ARRAY
26168: PUSH
26169: LD_INT 2
26171: ARRAY
26172: PPUSH
26173: CALL_OW 428
26177: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26178: LD_VAR 0 12
26182: PUSH
26183: LD_VAR 0 7
26187: ARRAY
26188: PUSH
26189: LD_INT 1
26191: ARRAY
26192: PPUSH
26193: LD_VAR 0 12
26197: PUSH
26198: LD_VAR 0 7
26202: ARRAY
26203: PUSH
26204: LD_INT 2
26206: ARRAY
26207: PPUSH
26208: CALL_OW 351
26212: PUSH
26213: LD_VAR 0 12
26217: PUSH
26218: LD_VAR 0 7
26222: ARRAY
26223: PUSH
26224: LD_INT 1
26226: ARRAY
26227: PPUSH
26228: LD_VAR 0 12
26232: PUSH
26233: LD_VAR 0 7
26237: ARRAY
26238: PUSH
26239: LD_INT 2
26241: ARRAY
26242: PPUSH
26243: CALL_OW 488
26247: NOT
26248: OR
26249: PUSH
26250: LD_VAR 0 11
26254: PPUSH
26255: CALL_OW 247
26259: PUSH
26260: LD_INT 3
26262: EQUAL
26263: OR
26264: IFFALSE 26270
// exit ;
26266: POP
26267: POP
26268: GO 26673
// if not tmp or not tmp in base then
26270: LD_VAR 0 11
26274: NOT
26275: PUSH
26276: LD_VAR 0 11
26280: PUSH
26281: LD_VAR 0 1
26285: IN
26286: NOT
26287: OR
26288: IFFALSE 26292
// continue ;
26290: GO 26135
// result := true ;
26292: LD_ADDR_VAR 0 6
26296: PUSH
26297: LD_INT 1
26299: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26300: LD_ADDR_VAR 0 15
26304: PUSH
26305: LD_VAR 0 1
26309: PPUSH
26310: LD_INT 22
26312: PUSH
26313: LD_VAR 0 11
26317: PPUSH
26318: CALL_OW 255
26322: PUSH
26323: EMPTY
26324: LIST
26325: LIST
26326: PUSH
26327: LD_INT 2
26329: PUSH
26330: LD_INT 30
26332: PUSH
26333: LD_INT 0
26335: PUSH
26336: EMPTY
26337: LIST
26338: LIST
26339: PUSH
26340: LD_INT 30
26342: PUSH
26343: LD_INT 1
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: LIST
26354: PUSH
26355: EMPTY
26356: LIST
26357: LIST
26358: PPUSH
26359: CALL_OW 72
26363: ST_TO_ADDR
// if dep then
26364: LD_VAR 0 15
26368: IFFALSE 26504
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26370: LD_ADDR_VAR 0 14
26374: PUSH
26375: LD_VAR 0 15
26379: PUSH
26380: LD_INT 1
26382: ARRAY
26383: PPUSH
26384: CALL_OW 250
26388: PPUSH
26389: LD_VAR 0 15
26393: PUSH
26394: LD_INT 1
26396: ARRAY
26397: PPUSH
26398: CALL_OW 254
26402: PPUSH
26403: LD_INT 5
26405: PPUSH
26406: CALL_OW 272
26410: PUSH
26411: LD_VAR 0 15
26415: PUSH
26416: LD_INT 1
26418: ARRAY
26419: PPUSH
26420: CALL_OW 251
26424: PPUSH
26425: LD_VAR 0 15
26429: PUSH
26430: LD_INT 1
26432: ARRAY
26433: PPUSH
26434: CALL_OW 254
26438: PPUSH
26439: LD_INT 5
26441: PPUSH
26442: CALL_OW 273
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26451: LD_VAR 0 14
26455: PUSH
26456: LD_INT 1
26458: ARRAY
26459: PPUSH
26460: LD_VAR 0 14
26464: PUSH
26465: LD_INT 2
26467: ARRAY
26468: PPUSH
26469: CALL_OW 488
26473: IFFALSE 26504
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26475: LD_VAR 0 11
26479: PPUSH
26480: LD_VAR 0 14
26484: PUSH
26485: LD_INT 1
26487: ARRAY
26488: PPUSH
26489: LD_VAR 0 14
26493: PUSH
26494: LD_INT 2
26496: ARRAY
26497: PPUSH
26498: CALL_OW 111
// continue ;
26502: GO 26135
// end ; end ; r := GetDir ( tmp ) ;
26504: LD_ADDR_VAR 0 13
26508: PUSH
26509: LD_VAR 0 11
26513: PPUSH
26514: CALL_OW 254
26518: ST_TO_ADDR
// if r = 5 then
26519: LD_VAR 0 13
26523: PUSH
26524: LD_INT 5
26526: EQUAL
26527: IFFALSE 26537
// r := 0 ;
26529: LD_ADDR_VAR 0 13
26533: PUSH
26534: LD_INT 0
26536: ST_TO_ADDR
// for j = r to 5 do
26537: LD_ADDR_VAR 0 8
26541: PUSH
26542: DOUBLE
26543: LD_VAR 0 13
26547: DEC
26548: ST_TO_ADDR
26549: LD_INT 5
26551: PUSH
26552: FOR_TO
26553: IFFALSE 26667
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26555: LD_ADDR_VAR 0 9
26559: PUSH
26560: LD_VAR 0 11
26564: PPUSH
26565: CALL_OW 250
26569: PPUSH
26570: LD_VAR 0 8
26574: PPUSH
26575: LD_INT 2
26577: PPUSH
26578: CALL_OW 272
26582: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26583: LD_ADDR_VAR 0 10
26587: PUSH
26588: LD_VAR 0 11
26592: PPUSH
26593: CALL_OW 251
26597: PPUSH
26598: LD_VAR 0 8
26602: PPUSH
26603: LD_INT 2
26605: PPUSH
26606: CALL_OW 273
26610: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26611: LD_VAR 0 9
26615: PPUSH
26616: LD_VAR 0 10
26620: PPUSH
26621: CALL_OW 488
26625: PUSH
26626: LD_VAR 0 9
26630: PPUSH
26631: LD_VAR 0 10
26635: PPUSH
26636: CALL_OW 428
26640: NOT
26641: AND
26642: IFFALSE 26665
// begin ComMoveXY ( tmp , _x , _y ) ;
26644: LD_VAR 0 11
26648: PPUSH
26649: LD_VAR 0 9
26653: PPUSH
26654: LD_VAR 0 10
26658: PPUSH
26659: CALL_OW 111
// break ;
26663: GO 26667
// end ; end ;
26665: GO 26552
26667: POP
26668: POP
// end ;
26669: GO 26135
26671: POP
26672: POP
// end ;
26673: LD_VAR 0 6
26677: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
26678: LD_INT 0
26680: PPUSH
26681: PPUSH
26682: PPUSH
26683: PPUSH
26684: PPUSH
26685: PPUSH
26686: PPUSH
26687: PPUSH
26688: PPUSH
26689: PPUSH
// result := false ;
26690: LD_ADDR_VAR 0 6
26694: PUSH
26695: LD_INT 0
26697: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26698: LD_VAR 0 1
26702: NOT
26703: PUSH
26704: LD_VAR 0 1
26708: PPUSH
26709: CALL_OW 266
26713: PUSH
26714: LD_INT 0
26716: PUSH
26717: LD_INT 1
26719: PUSH
26720: EMPTY
26721: LIST
26722: LIST
26723: IN
26724: NOT
26725: OR
26726: PUSH
26727: LD_VAR 0 2
26731: NOT
26732: OR
26733: PUSH
26734: LD_VAR 0 5
26738: PUSH
26739: LD_INT 0
26741: PUSH
26742: LD_INT 1
26744: PUSH
26745: LD_INT 2
26747: PUSH
26748: LD_INT 3
26750: PUSH
26751: LD_INT 4
26753: PUSH
26754: LD_INT 5
26756: PUSH
26757: EMPTY
26758: LIST
26759: LIST
26760: LIST
26761: LIST
26762: LIST
26763: LIST
26764: IN
26765: NOT
26766: OR
26767: PUSH
26768: LD_VAR 0 3
26772: PPUSH
26773: LD_VAR 0 4
26777: PPUSH
26778: CALL_OW 488
26782: NOT
26783: OR
26784: IFFALSE 26788
// exit ;
26786: GO 27505
// pom := GetBase ( depot ) ;
26788: LD_ADDR_VAR 0 10
26792: PUSH
26793: LD_VAR 0 1
26797: PPUSH
26798: CALL_OW 274
26802: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26803: LD_ADDR_VAR 0 11
26807: PUSH
26808: LD_VAR 0 2
26812: PPUSH
26813: LD_VAR 0 1
26817: PPUSH
26818: CALL_OW 248
26822: PPUSH
26823: CALL_OW 450
26827: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26828: LD_VAR 0 10
26832: PPUSH
26833: LD_INT 1
26835: PPUSH
26836: CALL_OW 275
26840: PUSH
26841: LD_VAR 0 11
26845: PUSH
26846: LD_INT 1
26848: ARRAY
26849: GREATEREQUAL
26850: PUSH
26851: LD_VAR 0 10
26855: PPUSH
26856: LD_INT 2
26858: PPUSH
26859: CALL_OW 275
26863: PUSH
26864: LD_VAR 0 11
26868: PUSH
26869: LD_INT 2
26871: ARRAY
26872: GREATEREQUAL
26873: AND
26874: PUSH
26875: LD_VAR 0 10
26879: PPUSH
26880: LD_INT 3
26882: PPUSH
26883: CALL_OW 275
26887: PUSH
26888: LD_VAR 0 11
26892: PUSH
26893: LD_INT 3
26895: ARRAY
26896: GREATEREQUAL
26897: AND
26898: NOT
26899: IFFALSE 26903
// exit ;
26901: GO 27505
// if GetBType ( depot ) = b_depot then
26903: LD_VAR 0 1
26907: PPUSH
26908: CALL_OW 266
26912: PUSH
26913: LD_INT 0
26915: EQUAL
26916: IFFALSE 26928
// dist := 28 else
26918: LD_ADDR_VAR 0 14
26922: PUSH
26923: LD_INT 28
26925: ST_TO_ADDR
26926: GO 26936
// dist := 36 ;
26928: LD_ADDR_VAR 0 14
26932: PUSH
26933: LD_INT 36
26935: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26936: LD_VAR 0 1
26940: PPUSH
26941: LD_VAR 0 3
26945: PPUSH
26946: LD_VAR 0 4
26950: PPUSH
26951: CALL_OW 297
26955: PUSH
26956: LD_VAR 0 14
26960: GREATER
26961: IFFALSE 26965
// exit ;
26963: GO 27505
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26965: LD_ADDR_VAR 0 12
26969: PUSH
26970: LD_VAR 0 2
26974: PPUSH
26975: LD_VAR 0 3
26979: PPUSH
26980: LD_VAR 0 4
26984: PPUSH
26985: LD_VAR 0 5
26989: PPUSH
26990: LD_VAR 0 1
26994: PPUSH
26995: CALL_OW 248
26999: PPUSH
27000: LD_INT 0
27002: PPUSH
27003: CALL 27510 0 6
27007: ST_TO_ADDR
// if not hexes then
27008: LD_VAR 0 12
27012: NOT
27013: IFFALSE 27017
// exit ;
27015: GO 27505
// hex := GetHexInfo ( x , y ) ;
27017: LD_ADDR_VAR 0 15
27021: PUSH
27022: LD_VAR 0 3
27026: PPUSH
27027: LD_VAR 0 4
27031: PPUSH
27032: CALL_OW 546
27036: ST_TO_ADDR
// if hex [ 1 ] then
27037: LD_VAR 0 15
27041: PUSH
27042: LD_INT 1
27044: ARRAY
27045: IFFALSE 27049
// exit ;
27047: GO 27505
// height := hex [ 2 ] ;
27049: LD_ADDR_VAR 0 13
27053: PUSH
27054: LD_VAR 0 15
27058: PUSH
27059: LD_INT 2
27061: ARRAY
27062: ST_TO_ADDR
// for i = 1 to hexes do
27063: LD_ADDR_VAR 0 7
27067: PUSH
27068: DOUBLE
27069: LD_INT 1
27071: DEC
27072: ST_TO_ADDR
27073: LD_VAR 0 12
27077: PUSH
27078: FOR_TO
27079: IFFALSE 27409
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27081: LD_VAR 0 12
27085: PUSH
27086: LD_VAR 0 7
27090: ARRAY
27091: PUSH
27092: LD_INT 1
27094: ARRAY
27095: PPUSH
27096: LD_VAR 0 12
27100: PUSH
27101: LD_VAR 0 7
27105: ARRAY
27106: PUSH
27107: LD_INT 2
27109: ARRAY
27110: PPUSH
27111: CALL_OW 488
27115: NOT
27116: PUSH
27117: LD_VAR 0 12
27121: PUSH
27122: LD_VAR 0 7
27126: ARRAY
27127: PUSH
27128: LD_INT 1
27130: ARRAY
27131: PPUSH
27132: LD_VAR 0 12
27136: PUSH
27137: LD_VAR 0 7
27141: ARRAY
27142: PUSH
27143: LD_INT 2
27145: ARRAY
27146: PPUSH
27147: CALL_OW 428
27151: PUSH
27152: LD_INT 0
27154: GREATER
27155: OR
27156: PUSH
27157: LD_VAR 0 12
27161: PUSH
27162: LD_VAR 0 7
27166: ARRAY
27167: PUSH
27168: LD_INT 1
27170: ARRAY
27171: PPUSH
27172: LD_VAR 0 12
27176: PUSH
27177: LD_VAR 0 7
27181: ARRAY
27182: PUSH
27183: LD_INT 2
27185: ARRAY
27186: PPUSH
27187: CALL_OW 351
27191: OR
27192: IFFALSE 27198
// exit ;
27194: POP
27195: POP
27196: GO 27505
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27198: LD_ADDR_VAR 0 8
27202: PUSH
27203: LD_VAR 0 12
27207: PUSH
27208: LD_VAR 0 7
27212: ARRAY
27213: PUSH
27214: LD_INT 1
27216: ARRAY
27217: PPUSH
27218: LD_VAR 0 12
27222: PUSH
27223: LD_VAR 0 7
27227: ARRAY
27228: PUSH
27229: LD_INT 2
27231: ARRAY
27232: PPUSH
27233: CALL_OW 546
27237: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27238: LD_VAR 0 8
27242: PUSH
27243: LD_INT 1
27245: ARRAY
27246: PUSH
27247: LD_VAR 0 8
27251: PUSH
27252: LD_INT 2
27254: ARRAY
27255: PUSH
27256: LD_VAR 0 13
27260: PUSH
27261: LD_INT 2
27263: PLUS
27264: GREATER
27265: OR
27266: PUSH
27267: LD_VAR 0 8
27271: PUSH
27272: LD_INT 2
27274: ARRAY
27275: PUSH
27276: LD_VAR 0 13
27280: PUSH
27281: LD_INT 2
27283: MINUS
27284: LESS
27285: OR
27286: PUSH
27287: LD_VAR 0 8
27291: PUSH
27292: LD_INT 3
27294: ARRAY
27295: PUSH
27296: LD_INT 0
27298: PUSH
27299: LD_INT 8
27301: PUSH
27302: LD_INT 9
27304: PUSH
27305: LD_INT 10
27307: PUSH
27308: LD_INT 11
27310: PUSH
27311: LD_INT 12
27313: PUSH
27314: LD_INT 13
27316: PUSH
27317: LD_INT 16
27319: PUSH
27320: LD_INT 17
27322: PUSH
27323: LD_INT 18
27325: PUSH
27326: LD_INT 19
27328: PUSH
27329: LD_INT 20
27331: PUSH
27332: LD_INT 21
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: LIST
27339: LIST
27340: LIST
27341: LIST
27342: LIST
27343: LIST
27344: LIST
27345: LIST
27346: LIST
27347: LIST
27348: LIST
27349: IN
27350: NOT
27351: OR
27352: PUSH
27353: LD_VAR 0 8
27357: PUSH
27358: LD_INT 5
27360: ARRAY
27361: NOT
27362: OR
27363: PUSH
27364: LD_VAR 0 8
27368: PUSH
27369: LD_INT 6
27371: ARRAY
27372: PUSH
27373: LD_INT 1
27375: PUSH
27376: LD_INT 2
27378: PUSH
27379: LD_INT 7
27381: PUSH
27382: LD_INT 9
27384: PUSH
27385: LD_INT 10
27387: PUSH
27388: LD_INT 11
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: IN
27399: NOT
27400: OR
27401: IFFALSE 27407
// exit ;
27403: POP
27404: POP
27405: GO 27505
// end ;
27407: GO 27078
27409: POP
27410: POP
// side := GetSide ( depot ) ;
27411: LD_ADDR_VAR 0 9
27415: PUSH
27416: LD_VAR 0 1
27420: PPUSH
27421: CALL_OW 255
27425: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27426: LD_VAR 0 9
27430: PPUSH
27431: LD_VAR 0 3
27435: PPUSH
27436: LD_VAR 0 4
27440: PPUSH
27441: LD_INT 20
27443: PPUSH
27444: CALL 20159 0 4
27448: PUSH
27449: LD_INT 4
27451: ARRAY
27452: IFFALSE 27456
// exit ;
27454: GO 27505
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27456: LD_VAR 0 2
27460: PUSH
27461: LD_INT 29
27463: PUSH
27464: LD_INT 30
27466: PUSH
27467: EMPTY
27468: LIST
27469: LIST
27470: IN
27471: PUSH
27472: LD_VAR 0 3
27476: PPUSH
27477: LD_VAR 0 4
27481: PPUSH
27482: LD_VAR 0 9
27486: PPUSH
27487: CALL_OW 440
27491: NOT
27492: AND
27493: IFFALSE 27497
// exit ;
27495: GO 27505
// result := true ;
27497: LD_ADDR_VAR 0 6
27501: PUSH
27502: LD_INT 1
27504: ST_TO_ADDR
// end ;
27505: LD_VAR 0 6
27509: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27510: LD_INT 0
27512: PPUSH
27513: PPUSH
27514: PPUSH
27515: PPUSH
27516: PPUSH
27517: PPUSH
27518: PPUSH
27519: PPUSH
27520: PPUSH
27521: PPUSH
27522: PPUSH
27523: PPUSH
27524: PPUSH
27525: PPUSH
27526: PPUSH
27527: PPUSH
27528: PPUSH
27529: PPUSH
27530: PPUSH
27531: PPUSH
27532: PPUSH
27533: PPUSH
27534: PPUSH
27535: PPUSH
27536: PPUSH
27537: PPUSH
27538: PPUSH
27539: PPUSH
27540: PPUSH
27541: PPUSH
27542: PPUSH
27543: PPUSH
27544: PPUSH
27545: PPUSH
27546: PPUSH
27547: PPUSH
27548: PPUSH
27549: PPUSH
27550: PPUSH
27551: PPUSH
27552: PPUSH
27553: PPUSH
27554: PPUSH
27555: PPUSH
27556: PPUSH
27557: PPUSH
27558: PPUSH
27559: PPUSH
27560: PPUSH
27561: PPUSH
27562: PPUSH
27563: PPUSH
27564: PPUSH
27565: PPUSH
27566: PPUSH
27567: PPUSH
27568: PPUSH
27569: PPUSH
// result = [ ] ;
27570: LD_ADDR_VAR 0 7
27574: PUSH
27575: EMPTY
27576: ST_TO_ADDR
// temp_list = [ ] ;
27577: LD_ADDR_VAR 0 9
27581: PUSH
27582: EMPTY
27583: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27584: LD_VAR 0 4
27588: PUSH
27589: LD_INT 0
27591: PUSH
27592: LD_INT 1
27594: PUSH
27595: LD_INT 2
27597: PUSH
27598: LD_INT 3
27600: PUSH
27601: LD_INT 4
27603: PUSH
27604: LD_INT 5
27606: PUSH
27607: EMPTY
27608: LIST
27609: LIST
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: IN
27615: NOT
27616: PUSH
27617: LD_VAR 0 1
27621: PUSH
27622: LD_INT 0
27624: PUSH
27625: LD_INT 1
27627: PUSH
27628: EMPTY
27629: LIST
27630: LIST
27631: IN
27632: PUSH
27633: LD_VAR 0 5
27637: PUSH
27638: LD_INT 1
27640: PUSH
27641: LD_INT 2
27643: PUSH
27644: LD_INT 3
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: LIST
27651: IN
27652: NOT
27653: AND
27654: OR
27655: IFFALSE 27659
// exit ;
27657: GO 46050
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27659: LD_VAR 0 1
27663: PUSH
27664: LD_INT 6
27666: PUSH
27667: LD_INT 7
27669: PUSH
27670: LD_INT 8
27672: PUSH
27673: LD_INT 13
27675: PUSH
27676: LD_INT 12
27678: PUSH
27679: LD_INT 15
27681: PUSH
27682: LD_INT 11
27684: PUSH
27685: LD_INT 14
27687: PUSH
27688: LD_INT 10
27690: PUSH
27691: EMPTY
27692: LIST
27693: LIST
27694: LIST
27695: LIST
27696: LIST
27697: LIST
27698: LIST
27699: LIST
27700: LIST
27701: IN
27702: IFFALSE 27712
// btype = b_lab ;
27704: LD_ADDR_VAR 0 1
27708: PUSH
27709: LD_INT 6
27711: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27712: LD_VAR 0 6
27716: PUSH
27717: LD_INT 0
27719: PUSH
27720: LD_INT 1
27722: PUSH
27723: LD_INT 2
27725: PUSH
27726: EMPTY
27727: LIST
27728: LIST
27729: LIST
27730: IN
27731: NOT
27732: PUSH
27733: LD_VAR 0 1
27737: PUSH
27738: LD_INT 0
27740: PUSH
27741: LD_INT 1
27743: PUSH
27744: LD_INT 2
27746: PUSH
27747: LD_INT 3
27749: PUSH
27750: LD_INT 6
27752: PUSH
27753: LD_INT 36
27755: PUSH
27756: LD_INT 4
27758: PUSH
27759: LD_INT 5
27761: PUSH
27762: LD_INT 31
27764: PUSH
27765: LD_INT 32
27767: PUSH
27768: LD_INT 33
27770: PUSH
27771: EMPTY
27772: LIST
27773: LIST
27774: LIST
27775: LIST
27776: LIST
27777: LIST
27778: LIST
27779: LIST
27780: LIST
27781: LIST
27782: LIST
27783: IN
27784: NOT
27785: PUSH
27786: LD_VAR 0 6
27790: PUSH
27791: LD_INT 1
27793: EQUAL
27794: AND
27795: OR
27796: PUSH
27797: LD_VAR 0 1
27801: PUSH
27802: LD_INT 2
27804: PUSH
27805: LD_INT 3
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: IN
27812: NOT
27813: PUSH
27814: LD_VAR 0 6
27818: PUSH
27819: LD_INT 2
27821: EQUAL
27822: AND
27823: OR
27824: IFFALSE 27834
// mode = 0 ;
27826: LD_ADDR_VAR 0 6
27830: PUSH
27831: LD_INT 0
27833: ST_TO_ADDR
// case mode of 0 :
27834: LD_VAR 0 6
27838: PUSH
27839: LD_INT 0
27841: DOUBLE
27842: EQUAL
27843: IFTRUE 27847
27845: GO 39300
27847: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27848: LD_ADDR_VAR 0 11
27852: PUSH
27853: LD_INT 0
27855: PUSH
27856: LD_INT 0
27858: PUSH
27859: EMPTY
27860: LIST
27861: LIST
27862: PUSH
27863: LD_INT 0
27865: PUSH
27866: LD_INT 1
27868: NEG
27869: PUSH
27870: EMPTY
27871: LIST
27872: LIST
27873: PUSH
27874: LD_INT 1
27876: PUSH
27877: LD_INT 0
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: PUSH
27884: LD_INT 1
27886: PUSH
27887: LD_INT 1
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: PUSH
27894: LD_INT 0
27896: PUSH
27897: LD_INT 1
27899: PUSH
27900: EMPTY
27901: LIST
27902: LIST
27903: PUSH
27904: LD_INT 1
27906: NEG
27907: PUSH
27908: LD_INT 0
27910: PUSH
27911: EMPTY
27912: LIST
27913: LIST
27914: PUSH
27915: LD_INT 1
27917: NEG
27918: PUSH
27919: LD_INT 1
27921: NEG
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: LD_INT 1
27929: NEG
27930: PUSH
27931: LD_INT 2
27933: NEG
27934: PUSH
27935: EMPTY
27936: LIST
27937: LIST
27938: PUSH
27939: LD_INT 0
27941: PUSH
27942: LD_INT 2
27944: NEG
27945: PUSH
27946: EMPTY
27947: LIST
27948: LIST
27949: PUSH
27950: LD_INT 1
27952: PUSH
27953: LD_INT 1
27955: NEG
27956: PUSH
27957: EMPTY
27958: LIST
27959: LIST
27960: PUSH
27961: LD_INT 1
27963: PUSH
27964: LD_INT 2
27966: PUSH
27967: EMPTY
27968: LIST
27969: LIST
27970: PUSH
27971: LD_INT 0
27973: PUSH
27974: LD_INT 2
27976: PUSH
27977: EMPTY
27978: LIST
27979: LIST
27980: PUSH
27981: LD_INT 1
27983: NEG
27984: PUSH
27985: LD_INT 1
27987: PUSH
27988: EMPTY
27989: LIST
27990: LIST
27991: PUSH
27992: LD_INT 1
27994: PUSH
27995: LD_INT 3
27997: PUSH
27998: EMPTY
27999: LIST
28000: LIST
28001: PUSH
28002: LD_INT 0
28004: PUSH
28005: LD_INT 3
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 1
28014: NEG
28015: PUSH
28016: LD_INT 2
28018: PUSH
28019: EMPTY
28020: LIST
28021: LIST
28022: PUSH
28023: EMPTY
28024: LIST
28025: LIST
28026: LIST
28027: LIST
28028: LIST
28029: LIST
28030: LIST
28031: LIST
28032: LIST
28033: LIST
28034: LIST
28035: LIST
28036: LIST
28037: LIST
28038: LIST
28039: LIST
28040: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28041: LD_ADDR_VAR 0 12
28045: PUSH
28046: LD_INT 0
28048: PUSH
28049: LD_INT 0
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: LD_INT 0
28058: PUSH
28059: LD_INT 1
28061: NEG
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: LD_INT 1
28069: PUSH
28070: LD_INT 0
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PUSH
28077: LD_INT 1
28079: PUSH
28080: LD_INT 1
28082: PUSH
28083: EMPTY
28084: LIST
28085: LIST
28086: PUSH
28087: LD_INT 0
28089: PUSH
28090: LD_INT 1
28092: PUSH
28093: EMPTY
28094: LIST
28095: LIST
28096: PUSH
28097: LD_INT 1
28099: NEG
28100: PUSH
28101: LD_INT 0
28103: PUSH
28104: EMPTY
28105: LIST
28106: LIST
28107: PUSH
28108: LD_INT 1
28110: NEG
28111: PUSH
28112: LD_INT 1
28114: NEG
28115: PUSH
28116: EMPTY
28117: LIST
28118: LIST
28119: PUSH
28120: LD_INT 1
28122: PUSH
28123: LD_INT 1
28125: NEG
28126: PUSH
28127: EMPTY
28128: LIST
28129: LIST
28130: PUSH
28131: LD_INT 2
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: PUSH
28141: LD_INT 2
28143: PUSH
28144: LD_INT 1
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: PUSH
28151: LD_INT 1
28153: NEG
28154: PUSH
28155: LD_INT 1
28157: PUSH
28158: EMPTY
28159: LIST
28160: LIST
28161: PUSH
28162: LD_INT 2
28164: NEG
28165: PUSH
28166: LD_INT 0
28168: PUSH
28169: EMPTY
28170: LIST
28171: LIST
28172: PUSH
28173: LD_INT 2
28175: NEG
28176: PUSH
28177: LD_INT 1
28179: NEG
28180: PUSH
28181: EMPTY
28182: LIST
28183: LIST
28184: PUSH
28185: LD_INT 2
28187: NEG
28188: PUSH
28189: LD_INT 1
28191: PUSH
28192: EMPTY
28193: LIST
28194: LIST
28195: PUSH
28196: LD_INT 3
28198: NEG
28199: PUSH
28200: LD_INT 0
28202: PUSH
28203: EMPTY
28204: LIST
28205: LIST
28206: PUSH
28207: LD_INT 3
28209: NEG
28210: PUSH
28211: LD_INT 1
28213: NEG
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: PUSH
28219: EMPTY
28220: LIST
28221: LIST
28222: LIST
28223: LIST
28224: LIST
28225: LIST
28226: LIST
28227: LIST
28228: LIST
28229: LIST
28230: LIST
28231: LIST
28232: LIST
28233: LIST
28234: LIST
28235: LIST
28236: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28237: LD_ADDR_VAR 0 13
28241: PUSH
28242: LD_INT 0
28244: PUSH
28245: LD_INT 0
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: PUSH
28252: LD_INT 0
28254: PUSH
28255: LD_INT 1
28257: NEG
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: LD_INT 1
28265: PUSH
28266: LD_INT 0
28268: PUSH
28269: EMPTY
28270: LIST
28271: LIST
28272: PUSH
28273: LD_INT 1
28275: PUSH
28276: LD_INT 1
28278: PUSH
28279: EMPTY
28280: LIST
28281: LIST
28282: PUSH
28283: LD_INT 0
28285: PUSH
28286: LD_INT 1
28288: PUSH
28289: EMPTY
28290: LIST
28291: LIST
28292: PUSH
28293: LD_INT 1
28295: NEG
28296: PUSH
28297: LD_INT 0
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PUSH
28304: LD_INT 1
28306: NEG
28307: PUSH
28308: LD_INT 1
28310: NEG
28311: PUSH
28312: EMPTY
28313: LIST
28314: LIST
28315: PUSH
28316: LD_INT 1
28318: NEG
28319: PUSH
28320: LD_INT 2
28322: NEG
28323: PUSH
28324: EMPTY
28325: LIST
28326: LIST
28327: PUSH
28328: LD_INT 2
28330: PUSH
28331: LD_INT 1
28333: PUSH
28334: EMPTY
28335: LIST
28336: LIST
28337: PUSH
28338: LD_INT 2
28340: PUSH
28341: LD_INT 2
28343: PUSH
28344: EMPTY
28345: LIST
28346: LIST
28347: PUSH
28348: LD_INT 1
28350: PUSH
28351: LD_INT 2
28353: PUSH
28354: EMPTY
28355: LIST
28356: LIST
28357: PUSH
28358: LD_INT 2
28360: NEG
28361: PUSH
28362: LD_INT 1
28364: NEG
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: LD_INT 2
28372: NEG
28373: PUSH
28374: LD_INT 2
28376: NEG
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 2
28384: NEG
28385: PUSH
28386: LD_INT 3
28388: NEG
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 3
28396: NEG
28397: PUSH
28398: LD_INT 2
28400: NEG
28401: PUSH
28402: EMPTY
28403: LIST
28404: LIST
28405: PUSH
28406: LD_INT 3
28408: NEG
28409: PUSH
28410: LD_INT 3
28412: NEG
28413: PUSH
28414: EMPTY
28415: LIST
28416: LIST
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: LIST
28422: LIST
28423: LIST
28424: LIST
28425: LIST
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: LIST
28431: LIST
28432: LIST
28433: LIST
28434: LIST
28435: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28436: LD_ADDR_VAR 0 14
28440: PUSH
28441: LD_INT 0
28443: PUSH
28444: LD_INT 0
28446: PUSH
28447: EMPTY
28448: LIST
28449: LIST
28450: PUSH
28451: LD_INT 0
28453: PUSH
28454: LD_INT 1
28456: NEG
28457: PUSH
28458: EMPTY
28459: LIST
28460: LIST
28461: PUSH
28462: LD_INT 1
28464: PUSH
28465: LD_INT 0
28467: PUSH
28468: EMPTY
28469: LIST
28470: LIST
28471: PUSH
28472: LD_INT 1
28474: PUSH
28475: LD_INT 1
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PUSH
28482: LD_INT 0
28484: PUSH
28485: LD_INT 1
28487: PUSH
28488: EMPTY
28489: LIST
28490: LIST
28491: PUSH
28492: LD_INT 1
28494: NEG
28495: PUSH
28496: LD_INT 0
28498: PUSH
28499: EMPTY
28500: LIST
28501: LIST
28502: PUSH
28503: LD_INT 1
28505: NEG
28506: PUSH
28507: LD_INT 1
28509: NEG
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: PUSH
28515: LD_INT 1
28517: NEG
28518: PUSH
28519: LD_INT 2
28521: NEG
28522: PUSH
28523: EMPTY
28524: LIST
28525: LIST
28526: PUSH
28527: LD_INT 0
28529: PUSH
28530: LD_INT 2
28532: NEG
28533: PUSH
28534: EMPTY
28535: LIST
28536: LIST
28537: PUSH
28538: LD_INT 1
28540: PUSH
28541: LD_INT 1
28543: NEG
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: PUSH
28549: LD_INT 1
28551: PUSH
28552: LD_INT 2
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 0
28561: PUSH
28562: LD_INT 2
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 1
28571: NEG
28572: PUSH
28573: LD_INT 1
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: LD_INT 1
28582: NEG
28583: PUSH
28584: LD_INT 3
28586: NEG
28587: PUSH
28588: EMPTY
28589: LIST
28590: LIST
28591: PUSH
28592: LD_INT 0
28594: PUSH
28595: LD_INT 3
28597: NEG
28598: PUSH
28599: EMPTY
28600: LIST
28601: LIST
28602: PUSH
28603: LD_INT 1
28605: PUSH
28606: LD_INT 2
28608: NEG
28609: PUSH
28610: EMPTY
28611: LIST
28612: LIST
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: LIST
28618: LIST
28619: LIST
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: LIST
28627: LIST
28628: LIST
28629: LIST
28630: LIST
28631: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28632: LD_ADDR_VAR 0 15
28636: PUSH
28637: LD_INT 0
28639: PUSH
28640: LD_INT 0
28642: PUSH
28643: EMPTY
28644: LIST
28645: LIST
28646: PUSH
28647: LD_INT 0
28649: PUSH
28650: LD_INT 1
28652: NEG
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: PUSH
28658: LD_INT 1
28660: PUSH
28661: LD_INT 0
28663: PUSH
28664: EMPTY
28665: LIST
28666: LIST
28667: PUSH
28668: LD_INT 1
28670: PUSH
28671: LD_INT 1
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PUSH
28678: LD_INT 0
28680: PUSH
28681: LD_INT 1
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 1
28690: NEG
28691: PUSH
28692: LD_INT 0
28694: PUSH
28695: EMPTY
28696: LIST
28697: LIST
28698: PUSH
28699: LD_INT 1
28701: NEG
28702: PUSH
28703: LD_INT 1
28705: NEG
28706: PUSH
28707: EMPTY
28708: LIST
28709: LIST
28710: PUSH
28711: LD_INT 1
28713: PUSH
28714: LD_INT 1
28716: NEG
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 2
28724: PUSH
28725: LD_INT 0
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 2
28734: PUSH
28735: LD_INT 1
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 1
28744: NEG
28745: PUSH
28746: LD_INT 1
28748: PUSH
28749: EMPTY
28750: LIST
28751: LIST
28752: PUSH
28753: LD_INT 2
28755: NEG
28756: PUSH
28757: LD_INT 0
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PUSH
28764: LD_INT 2
28766: NEG
28767: PUSH
28768: LD_INT 1
28770: NEG
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 2
28778: PUSH
28779: LD_INT 1
28781: NEG
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PUSH
28787: LD_INT 3
28789: PUSH
28790: LD_INT 0
28792: PUSH
28793: EMPTY
28794: LIST
28795: LIST
28796: PUSH
28797: LD_INT 3
28799: PUSH
28800: LD_INT 1
28802: PUSH
28803: EMPTY
28804: LIST
28805: LIST
28806: PUSH
28807: EMPTY
28808: LIST
28809: LIST
28810: LIST
28811: LIST
28812: LIST
28813: LIST
28814: LIST
28815: LIST
28816: LIST
28817: LIST
28818: LIST
28819: LIST
28820: LIST
28821: LIST
28822: LIST
28823: LIST
28824: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28825: LD_ADDR_VAR 0 16
28829: PUSH
28830: LD_INT 0
28832: PUSH
28833: LD_INT 0
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: LD_INT 0
28842: PUSH
28843: LD_INT 1
28845: NEG
28846: PUSH
28847: EMPTY
28848: LIST
28849: LIST
28850: PUSH
28851: LD_INT 1
28853: PUSH
28854: LD_INT 0
28856: PUSH
28857: EMPTY
28858: LIST
28859: LIST
28860: PUSH
28861: LD_INT 1
28863: PUSH
28864: LD_INT 1
28866: PUSH
28867: EMPTY
28868: LIST
28869: LIST
28870: PUSH
28871: LD_INT 0
28873: PUSH
28874: LD_INT 1
28876: PUSH
28877: EMPTY
28878: LIST
28879: LIST
28880: PUSH
28881: LD_INT 1
28883: NEG
28884: PUSH
28885: LD_INT 0
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PUSH
28892: LD_INT 1
28894: NEG
28895: PUSH
28896: LD_INT 1
28898: NEG
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 1
28906: NEG
28907: PUSH
28908: LD_INT 2
28910: NEG
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 2
28918: PUSH
28919: LD_INT 1
28921: PUSH
28922: EMPTY
28923: LIST
28924: LIST
28925: PUSH
28926: LD_INT 2
28928: PUSH
28929: LD_INT 2
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: PUSH
28936: LD_INT 1
28938: PUSH
28939: LD_INT 2
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: PUSH
28946: LD_INT 2
28948: NEG
28949: PUSH
28950: LD_INT 1
28952: NEG
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: PUSH
28958: LD_INT 2
28960: NEG
28961: PUSH
28962: LD_INT 2
28964: NEG
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: LD_INT 3
28972: PUSH
28973: LD_INT 2
28975: PUSH
28976: EMPTY
28977: LIST
28978: LIST
28979: PUSH
28980: LD_INT 3
28982: PUSH
28983: LD_INT 3
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: PUSH
28990: LD_INT 2
28992: PUSH
28993: LD_INT 3
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: LIST
29004: LIST
29005: LIST
29006: LIST
29007: LIST
29008: LIST
29009: LIST
29010: LIST
29011: LIST
29012: LIST
29013: LIST
29014: LIST
29015: LIST
29016: LIST
29017: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29018: LD_ADDR_VAR 0 17
29022: PUSH
29023: LD_INT 0
29025: PUSH
29026: LD_INT 0
29028: PUSH
29029: EMPTY
29030: LIST
29031: LIST
29032: PUSH
29033: LD_INT 0
29035: PUSH
29036: LD_INT 1
29038: NEG
29039: PUSH
29040: EMPTY
29041: LIST
29042: LIST
29043: PUSH
29044: LD_INT 1
29046: PUSH
29047: LD_INT 0
29049: PUSH
29050: EMPTY
29051: LIST
29052: LIST
29053: PUSH
29054: LD_INT 1
29056: PUSH
29057: LD_INT 1
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PUSH
29064: LD_INT 0
29066: PUSH
29067: LD_INT 1
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: PUSH
29074: LD_INT 1
29076: NEG
29077: PUSH
29078: LD_INT 0
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PUSH
29085: LD_INT 1
29087: NEG
29088: PUSH
29089: LD_INT 1
29091: NEG
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: PUSH
29097: LD_INT 1
29099: NEG
29100: PUSH
29101: LD_INT 2
29103: NEG
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: LD_INT 2
29114: NEG
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 1
29122: PUSH
29123: LD_INT 1
29125: NEG
29126: PUSH
29127: EMPTY
29128: LIST
29129: LIST
29130: PUSH
29131: LD_INT 2
29133: PUSH
29134: LD_INT 0
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PUSH
29141: LD_INT 2
29143: PUSH
29144: LD_INT 1
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: PUSH
29151: LD_INT 2
29153: PUSH
29154: LD_INT 2
29156: PUSH
29157: EMPTY
29158: LIST
29159: LIST
29160: PUSH
29161: LD_INT 1
29163: PUSH
29164: LD_INT 2
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: PUSH
29171: LD_INT 0
29173: PUSH
29174: LD_INT 2
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: PUSH
29181: LD_INT 1
29183: NEG
29184: PUSH
29185: LD_INT 1
29187: PUSH
29188: EMPTY
29189: LIST
29190: LIST
29191: PUSH
29192: LD_INT 2
29194: NEG
29195: PUSH
29196: LD_INT 0
29198: PUSH
29199: EMPTY
29200: LIST
29201: LIST
29202: PUSH
29203: LD_INT 2
29205: NEG
29206: PUSH
29207: LD_INT 1
29209: NEG
29210: PUSH
29211: EMPTY
29212: LIST
29213: LIST
29214: PUSH
29215: LD_INT 2
29217: NEG
29218: PUSH
29219: LD_INT 2
29221: NEG
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: PUSH
29227: EMPTY
29228: LIST
29229: LIST
29230: LIST
29231: LIST
29232: LIST
29233: LIST
29234: LIST
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: LIST
29240: LIST
29241: LIST
29242: LIST
29243: LIST
29244: LIST
29245: LIST
29246: LIST
29247: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29248: LD_ADDR_VAR 0 18
29252: PUSH
29253: LD_INT 0
29255: PUSH
29256: LD_INT 0
29258: PUSH
29259: EMPTY
29260: LIST
29261: LIST
29262: PUSH
29263: LD_INT 0
29265: PUSH
29266: LD_INT 1
29268: NEG
29269: PUSH
29270: EMPTY
29271: LIST
29272: LIST
29273: PUSH
29274: LD_INT 1
29276: PUSH
29277: LD_INT 0
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: LD_INT 1
29286: PUSH
29287: LD_INT 1
29289: PUSH
29290: EMPTY
29291: LIST
29292: LIST
29293: PUSH
29294: LD_INT 0
29296: PUSH
29297: LD_INT 1
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 1
29306: NEG
29307: PUSH
29308: LD_INT 0
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: PUSH
29315: LD_INT 1
29317: NEG
29318: PUSH
29319: LD_INT 1
29321: NEG
29322: PUSH
29323: EMPTY
29324: LIST
29325: LIST
29326: PUSH
29327: LD_INT 1
29329: NEG
29330: PUSH
29331: LD_INT 2
29333: NEG
29334: PUSH
29335: EMPTY
29336: LIST
29337: LIST
29338: PUSH
29339: LD_INT 0
29341: PUSH
29342: LD_INT 2
29344: NEG
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: PUSH
29350: LD_INT 1
29352: PUSH
29353: LD_INT 1
29355: NEG
29356: PUSH
29357: EMPTY
29358: LIST
29359: LIST
29360: PUSH
29361: LD_INT 2
29363: PUSH
29364: LD_INT 0
29366: PUSH
29367: EMPTY
29368: LIST
29369: LIST
29370: PUSH
29371: LD_INT 2
29373: PUSH
29374: LD_INT 1
29376: PUSH
29377: EMPTY
29378: LIST
29379: LIST
29380: PUSH
29381: LD_INT 2
29383: PUSH
29384: LD_INT 2
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: LD_INT 1
29393: PUSH
29394: LD_INT 2
29396: PUSH
29397: EMPTY
29398: LIST
29399: LIST
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: LD_INT 2
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: PUSH
29411: LD_INT 1
29413: NEG
29414: PUSH
29415: LD_INT 1
29417: PUSH
29418: EMPTY
29419: LIST
29420: LIST
29421: PUSH
29422: LD_INT 2
29424: NEG
29425: PUSH
29426: LD_INT 0
29428: PUSH
29429: EMPTY
29430: LIST
29431: LIST
29432: PUSH
29433: LD_INT 2
29435: NEG
29436: PUSH
29437: LD_INT 1
29439: NEG
29440: PUSH
29441: EMPTY
29442: LIST
29443: LIST
29444: PUSH
29445: LD_INT 2
29447: NEG
29448: PUSH
29449: LD_INT 2
29451: NEG
29452: PUSH
29453: EMPTY
29454: LIST
29455: LIST
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: LIST
29461: LIST
29462: LIST
29463: LIST
29464: LIST
29465: LIST
29466: LIST
29467: LIST
29468: LIST
29469: LIST
29470: LIST
29471: LIST
29472: LIST
29473: LIST
29474: LIST
29475: LIST
29476: LIST
29477: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29478: LD_ADDR_VAR 0 19
29482: PUSH
29483: LD_INT 0
29485: PUSH
29486: LD_INT 0
29488: PUSH
29489: EMPTY
29490: LIST
29491: LIST
29492: PUSH
29493: LD_INT 0
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: EMPTY
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 1
29506: PUSH
29507: LD_INT 0
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: PUSH
29514: LD_INT 1
29516: PUSH
29517: LD_INT 1
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: LD_INT 0
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PUSH
29534: LD_INT 1
29536: NEG
29537: PUSH
29538: LD_INT 0
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: PUSH
29545: LD_INT 1
29547: NEG
29548: PUSH
29549: LD_INT 1
29551: NEG
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 1
29559: NEG
29560: PUSH
29561: LD_INT 2
29563: NEG
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: LD_INT 2
29574: NEG
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 1
29582: PUSH
29583: LD_INT 1
29585: NEG
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: LD_INT 2
29593: PUSH
29594: LD_INT 0
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: PUSH
29601: LD_INT 2
29603: PUSH
29604: LD_INT 1
29606: PUSH
29607: EMPTY
29608: LIST
29609: LIST
29610: PUSH
29611: LD_INT 2
29613: PUSH
29614: LD_INT 2
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 1
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PUSH
29631: LD_INT 0
29633: PUSH
29634: LD_INT 2
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: PUSH
29641: LD_INT 1
29643: NEG
29644: PUSH
29645: LD_INT 1
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 2
29654: NEG
29655: PUSH
29656: LD_INT 0
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: PUSH
29663: LD_INT 2
29665: NEG
29666: PUSH
29667: LD_INT 1
29669: NEG
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: LD_INT 2
29677: NEG
29678: PUSH
29679: LD_INT 2
29681: NEG
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: LIST
29691: LIST
29692: LIST
29693: LIST
29694: LIST
29695: LIST
29696: LIST
29697: LIST
29698: LIST
29699: LIST
29700: LIST
29701: LIST
29702: LIST
29703: LIST
29704: LIST
29705: LIST
29706: LIST
29707: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29708: LD_ADDR_VAR 0 20
29712: PUSH
29713: LD_INT 0
29715: PUSH
29716: LD_INT 0
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 0
29725: PUSH
29726: LD_INT 1
29728: NEG
29729: PUSH
29730: EMPTY
29731: LIST
29732: LIST
29733: PUSH
29734: LD_INT 1
29736: PUSH
29737: LD_INT 0
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: PUSH
29744: LD_INT 1
29746: PUSH
29747: LD_INT 1
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: PUSH
29754: LD_INT 0
29756: PUSH
29757: LD_INT 1
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 1
29766: NEG
29767: PUSH
29768: LD_INT 0
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 1
29777: NEG
29778: PUSH
29779: LD_INT 1
29781: NEG
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: PUSH
29787: LD_INT 1
29789: NEG
29790: PUSH
29791: LD_INT 2
29793: NEG
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: PUSH
29799: LD_INT 0
29801: PUSH
29802: LD_INT 2
29804: NEG
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 1
29812: PUSH
29813: LD_INT 1
29815: NEG
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PUSH
29821: LD_INT 2
29823: PUSH
29824: LD_INT 0
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 2
29833: PUSH
29834: LD_INT 1
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 2
29843: PUSH
29844: LD_INT 2
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: LD_INT 1
29853: PUSH
29854: LD_INT 2
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: LD_INT 2
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 1
29873: NEG
29874: PUSH
29875: LD_INT 1
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 2
29884: NEG
29885: PUSH
29886: LD_INT 0
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 2
29895: NEG
29896: PUSH
29897: LD_INT 1
29899: NEG
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: LD_INT 2
29907: NEG
29908: PUSH
29909: LD_INT 2
29911: NEG
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: LIST
29921: LIST
29922: LIST
29923: LIST
29924: LIST
29925: LIST
29926: LIST
29927: LIST
29928: LIST
29929: LIST
29930: LIST
29931: LIST
29932: LIST
29933: LIST
29934: LIST
29935: LIST
29936: LIST
29937: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29938: LD_ADDR_VAR 0 21
29942: PUSH
29943: LD_INT 0
29945: PUSH
29946: LD_INT 0
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 0
29955: PUSH
29956: LD_INT 1
29958: NEG
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: LD_INT 1
29966: PUSH
29967: LD_INT 0
29969: PUSH
29970: EMPTY
29971: LIST
29972: LIST
29973: PUSH
29974: LD_INT 1
29976: PUSH
29977: LD_INT 1
29979: PUSH
29980: EMPTY
29981: LIST
29982: LIST
29983: PUSH
29984: LD_INT 0
29986: PUSH
29987: LD_INT 1
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 1
29996: NEG
29997: PUSH
29998: LD_INT 0
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: PUSH
30005: LD_INT 1
30007: NEG
30008: PUSH
30009: LD_INT 1
30011: NEG
30012: PUSH
30013: EMPTY
30014: LIST
30015: LIST
30016: PUSH
30017: LD_INT 1
30019: NEG
30020: PUSH
30021: LD_INT 2
30023: NEG
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 0
30031: PUSH
30032: LD_INT 2
30034: NEG
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: LD_INT 1
30045: NEG
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PUSH
30051: LD_INT 2
30053: PUSH
30054: LD_INT 0
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: PUSH
30061: LD_INT 2
30063: PUSH
30064: LD_INT 1
30066: PUSH
30067: EMPTY
30068: LIST
30069: LIST
30070: PUSH
30071: LD_INT 2
30073: PUSH
30074: LD_INT 2
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 1
30083: PUSH
30084: LD_INT 2
30086: PUSH
30087: EMPTY
30088: LIST
30089: LIST
30090: PUSH
30091: LD_INT 0
30093: PUSH
30094: LD_INT 2
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: LD_INT 1
30103: NEG
30104: PUSH
30105: LD_INT 1
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PUSH
30112: LD_INT 2
30114: NEG
30115: PUSH
30116: LD_INT 0
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: LD_INT 2
30125: NEG
30126: PUSH
30127: LD_INT 1
30129: NEG
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PUSH
30135: LD_INT 2
30137: NEG
30138: PUSH
30139: LD_INT 2
30141: NEG
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: EMPTY
30148: LIST
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: LIST
30167: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30168: LD_ADDR_VAR 0 22
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: LD_INT 0
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 0
30185: PUSH
30186: LD_INT 1
30188: NEG
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 1
30196: PUSH
30197: LD_INT 0
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 1
30206: PUSH
30207: LD_INT 1
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PUSH
30214: LD_INT 0
30216: PUSH
30217: LD_INT 1
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 1
30226: NEG
30227: PUSH
30228: LD_INT 0
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 1
30237: NEG
30238: PUSH
30239: LD_INT 1
30241: NEG
30242: PUSH
30243: EMPTY
30244: LIST
30245: LIST
30246: PUSH
30247: LD_INT 1
30249: NEG
30250: PUSH
30251: LD_INT 2
30253: NEG
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: PUSH
30259: LD_INT 0
30261: PUSH
30262: LD_INT 2
30264: NEG
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 1
30272: PUSH
30273: LD_INT 1
30275: NEG
30276: PUSH
30277: EMPTY
30278: LIST
30279: LIST
30280: PUSH
30281: LD_INT 2
30283: PUSH
30284: LD_INT 0
30286: PUSH
30287: EMPTY
30288: LIST
30289: LIST
30290: PUSH
30291: LD_INT 2
30293: PUSH
30294: LD_INT 1
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 2
30303: PUSH
30304: LD_INT 2
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 1
30313: PUSH
30314: LD_INT 2
30316: PUSH
30317: EMPTY
30318: LIST
30319: LIST
30320: PUSH
30321: LD_INT 0
30323: PUSH
30324: LD_INT 2
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: PUSH
30331: LD_INT 1
30333: NEG
30334: PUSH
30335: LD_INT 1
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 2
30344: NEG
30345: PUSH
30346: LD_INT 0
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: PUSH
30353: LD_INT 2
30355: NEG
30356: PUSH
30357: LD_INT 1
30359: NEG
30360: PUSH
30361: EMPTY
30362: LIST
30363: LIST
30364: PUSH
30365: LD_INT 2
30367: NEG
30368: PUSH
30369: LD_INT 2
30371: NEG
30372: PUSH
30373: EMPTY
30374: LIST
30375: LIST
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: LIST
30381: LIST
30382: LIST
30383: LIST
30384: LIST
30385: LIST
30386: LIST
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: LIST
30397: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30398: LD_ADDR_VAR 0 23
30402: PUSH
30403: LD_INT 0
30405: PUSH
30406: LD_INT 0
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 0
30415: PUSH
30416: LD_INT 1
30418: NEG
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 1
30426: PUSH
30427: LD_INT 0
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 1
30436: PUSH
30437: LD_INT 1
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PUSH
30444: LD_INT 0
30446: PUSH
30447: LD_INT 1
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 1
30456: NEG
30457: PUSH
30458: LD_INT 0
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 1
30467: NEG
30468: PUSH
30469: LD_INT 1
30471: NEG
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 1
30479: NEG
30480: PUSH
30481: LD_INT 2
30483: NEG
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 0
30491: PUSH
30492: LD_INT 2
30494: NEG
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 1
30502: PUSH
30503: LD_INT 1
30505: NEG
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 2
30513: PUSH
30514: LD_INT 0
30516: PUSH
30517: EMPTY
30518: LIST
30519: LIST
30520: PUSH
30521: LD_INT 2
30523: PUSH
30524: LD_INT 1
30526: PUSH
30527: EMPTY
30528: LIST
30529: LIST
30530: PUSH
30531: LD_INT 2
30533: PUSH
30534: LD_INT 2
30536: PUSH
30537: EMPTY
30538: LIST
30539: LIST
30540: PUSH
30541: LD_INT 1
30543: PUSH
30544: LD_INT 2
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: PUSH
30551: LD_INT 0
30553: PUSH
30554: LD_INT 2
30556: PUSH
30557: EMPTY
30558: LIST
30559: LIST
30560: PUSH
30561: LD_INT 1
30563: NEG
30564: PUSH
30565: LD_INT 1
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: LD_INT 2
30574: NEG
30575: PUSH
30576: LD_INT 0
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 2
30585: NEG
30586: PUSH
30587: LD_INT 1
30589: NEG
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PUSH
30595: LD_INT 2
30597: NEG
30598: PUSH
30599: LD_INT 2
30601: NEG
30602: PUSH
30603: EMPTY
30604: LIST
30605: LIST
30606: PUSH
30607: LD_INT 2
30609: NEG
30610: PUSH
30611: LD_INT 3
30613: NEG
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 1
30621: NEG
30622: PUSH
30623: LD_INT 3
30625: NEG
30626: PUSH
30627: EMPTY
30628: LIST
30629: LIST
30630: PUSH
30631: LD_INT 1
30633: PUSH
30634: LD_INT 2
30636: NEG
30637: PUSH
30638: EMPTY
30639: LIST
30640: LIST
30641: PUSH
30642: LD_INT 2
30644: PUSH
30645: LD_INT 1
30647: NEG
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: LIST
30657: LIST
30658: LIST
30659: LIST
30660: LIST
30661: LIST
30662: LIST
30663: LIST
30664: LIST
30665: LIST
30666: LIST
30667: LIST
30668: LIST
30669: LIST
30670: LIST
30671: LIST
30672: LIST
30673: LIST
30674: LIST
30675: LIST
30676: LIST
30677: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30678: LD_ADDR_VAR 0 24
30682: PUSH
30683: LD_INT 0
30685: PUSH
30686: LD_INT 0
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 0
30695: PUSH
30696: LD_INT 1
30698: NEG
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: PUSH
30704: LD_INT 1
30706: PUSH
30707: LD_INT 0
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: PUSH
30714: LD_INT 1
30716: PUSH
30717: LD_INT 1
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: PUSH
30724: LD_INT 0
30726: PUSH
30727: LD_INT 1
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: PUSH
30734: LD_INT 1
30736: NEG
30737: PUSH
30738: LD_INT 0
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 1
30747: NEG
30748: PUSH
30749: LD_INT 1
30751: NEG
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 1
30759: NEG
30760: PUSH
30761: LD_INT 2
30763: NEG
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 0
30771: PUSH
30772: LD_INT 2
30774: NEG
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 1
30782: PUSH
30783: LD_INT 1
30785: NEG
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 2
30793: PUSH
30794: LD_INT 0
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: LD_INT 2
30803: PUSH
30804: LD_INT 1
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PUSH
30811: LD_INT 2
30813: PUSH
30814: LD_INT 2
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: LD_INT 1
30823: PUSH
30824: LD_INT 2
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: PUSH
30831: LD_INT 0
30833: PUSH
30834: LD_INT 2
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: LD_INT 1
30843: NEG
30844: PUSH
30845: LD_INT 1
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: PUSH
30852: LD_INT 2
30854: NEG
30855: PUSH
30856: LD_INT 0
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: PUSH
30863: LD_INT 2
30865: NEG
30866: PUSH
30867: LD_INT 1
30869: NEG
30870: PUSH
30871: EMPTY
30872: LIST
30873: LIST
30874: PUSH
30875: LD_INT 2
30877: NEG
30878: PUSH
30879: LD_INT 2
30881: NEG
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: LD_INT 1
30889: PUSH
30890: LD_INT 2
30892: NEG
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 2
30900: PUSH
30901: LD_INT 1
30903: NEG
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: PUSH
30909: LD_INT 3
30911: PUSH
30912: LD_INT 1
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 3
30921: PUSH
30922: LD_INT 2
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: LIST
30933: LIST
30934: LIST
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: LIST
30940: LIST
30941: LIST
30942: LIST
30943: LIST
30944: LIST
30945: LIST
30946: LIST
30947: LIST
30948: LIST
30949: LIST
30950: LIST
30951: LIST
30952: LIST
30953: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30954: LD_ADDR_VAR 0 25
30958: PUSH
30959: LD_INT 0
30961: PUSH
30962: LD_INT 0
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 0
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: LD_INT 1
30982: PUSH
30983: LD_INT 0
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 1
30992: PUSH
30993: LD_INT 1
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: LD_INT 0
31002: PUSH
31003: LD_INT 1
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 1
31012: NEG
31013: PUSH
31014: LD_INT 0
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 1
31023: NEG
31024: PUSH
31025: LD_INT 1
31027: NEG
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 1
31035: NEG
31036: PUSH
31037: LD_INT 2
31039: NEG
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 0
31047: PUSH
31048: LD_INT 2
31050: NEG
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PUSH
31056: LD_INT 1
31058: PUSH
31059: LD_INT 1
31061: NEG
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: LD_INT 2
31069: PUSH
31070: LD_INT 0
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 2
31079: PUSH
31080: LD_INT 1
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: PUSH
31087: LD_INT 2
31089: PUSH
31090: LD_INT 2
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PUSH
31097: LD_INT 1
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: LD_INT 2
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 1
31119: NEG
31120: PUSH
31121: LD_INT 1
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 2
31130: NEG
31131: PUSH
31132: LD_INT 0
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: PUSH
31139: LD_INT 2
31141: NEG
31142: PUSH
31143: LD_INT 1
31145: NEG
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: PUSH
31151: LD_INT 2
31153: NEG
31154: PUSH
31155: LD_INT 2
31157: NEG
31158: PUSH
31159: EMPTY
31160: LIST
31161: LIST
31162: PUSH
31163: LD_INT 3
31165: PUSH
31166: LD_INT 1
31168: PUSH
31169: EMPTY
31170: LIST
31171: LIST
31172: PUSH
31173: LD_INT 3
31175: PUSH
31176: LD_INT 2
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 2
31185: PUSH
31186: LD_INT 3
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: LD_INT 1
31195: PUSH
31196: LD_INT 3
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PUSH
31203: EMPTY
31204: LIST
31205: LIST
31206: LIST
31207: LIST
31208: LIST
31209: LIST
31210: LIST
31211: LIST
31212: LIST
31213: LIST
31214: LIST
31215: LIST
31216: LIST
31217: LIST
31218: LIST
31219: LIST
31220: LIST
31221: LIST
31222: LIST
31223: LIST
31224: LIST
31225: LIST
31226: LIST
31227: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31228: LD_ADDR_VAR 0 26
31232: PUSH
31233: LD_INT 0
31235: PUSH
31236: LD_INT 0
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 0
31245: PUSH
31246: LD_INT 1
31248: NEG
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 1
31256: PUSH
31257: LD_INT 0
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: LD_INT 1
31266: PUSH
31267: LD_INT 1
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: LD_INT 0
31276: PUSH
31277: LD_INT 1
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 1
31286: NEG
31287: PUSH
31288: LD_INT 0
31290: PUSH
31291: EMPTY
31292: LIST
31293: LIST
31294: PUSH
31295: LD_INT 1
31297: NEG
31298: PUSH
31299: LD_INT 1
31301: NEG
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 1
31309: NEG
31310: PUSH
31311: LD_INT 2
31313: NEG
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: PUSH
31319: LD_INT 0
31321: PUSH
31322: LD_INT 2
31324: NEG
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 1
31332: PUSH
31333: LD_INT 1
31335: NEG
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 2
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 2
31353: PUSH
31354: LD_INT 1
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: PUSH
31361: LD_INT 2
31363: PUSH
31364: LD_INT 2
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 1
31373: PUSH
31374: LD_INT 2
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: PUSH
31381: LD_INT 0
31383: PUSH
31384: LD_INT 2
31386: PUSH
31387: EMPTY
31388: LIST
31389: LIST
31390: PUSH
31391: LD_INT 1
31393: NEG
31394: PUSH
31395: LD_INT 1
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 2
31404: NEG
31405: PUSH
31406: LD_INT 0
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: PUSH
31413: LD_INT 2
31415: NEG
31416: PUSH
31417: LD_INT 1
31419: NEG
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PUSH
31425: LD_INT 2
31427: NEG
31428: PUSH
31429: LD_INT 2
31431: NEG
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PUSH
31437: LD_INT 2
31439: PUSH
31440: LD_INT 3
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: PUSH
31447: LD_INT 1
31449: PUSH
31450: LD_INT 3
31452: PUSH
31453: EMPTY
31454: LIST
31455: LIST
31456: PUSH
31457: LD_INT 1
31459: NEG
31460: PUSH
31461: LD_INT 2
31463: PUSH
31464: EMPTY
31465: LIST
31466: LIST
31467: PUSH
31468: LD_INT 2
31470: NEG
31471: PUSH
31472: LD_INT 1
31474: PUSH
31475: EMPTY
31476: LIST
31477: LIST
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: LIST
31483: LIST
31484: LIST
31485: LIST
31486: LIST
31487: LIST
31488: LIST
31489: LIST
31490: LIST
31491: LIST
31492: LIST
31493: LIST
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: LIST
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31504: LD_ADDR_VAR 0 27
31508: PUSH
31509: LD_INT 0
31511: PUSH
31512: LD_INT 0
31514: PUSH
31515: EMPTY
31516: LIST
31517: LIST
31518: PUSH
31519: LD_INT 0
31521: PUSH
31522: LD_INT 1
31524: NEG
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: PUSH
31530: LD_INT 1
31532: PUSH
31533: LD_INT 0
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 1
31542: PUSH
31543: LD_INT 1
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 0
31552: PUSH
31553: LD_INT 1
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 1
31562: NEG
31563: PUSH
31564: LD_INT 0
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 1
31573: NEG
31574: PUSH
31575: LD_INT 1
31577: NEG
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 1
31585: NEG
31586: PUSH
31587: LD_INT 2
31589: NEG
31590: PUSH
31591: EMPTY
31592: LIST
31593: LIST
31594: PUSH
31595: LD_INT 0
31597: PUSH
31598: LD_INT 2
31600: NEG
31601: PUSH
31602: EMPTY
31603: LIST
31604: LIST
31605: PUSH
31606: LD_INT 1
31608: PUSH
31609: LD_INT 1
31611: NEG
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PUSH
31617: LD_INT 2
31619: PUSH
31620: LD_INT 0
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 2
31629: PUSH
31630: LD_INT 1
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 2
31639: PUSH
31640: LD_INT 2
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: LD_INT 2
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 0
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 1
31669: NEG
31670: PUSH
31671: LD_INT 1
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: PUSH
31678: LD_INT 2
31680: NEG
31681: PUSH
31682: LD_INT 0
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: PUSH
31689: LD_INT 2
31691: NEG
31692: PUSH
31693: LD_INT 1
31695: NEG
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: LD_INT 2
31703: NEG
31704: PUSH
31705: LD_INT 2
31707: NEG
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: PUSH
31713: LD_INT 1
31715: NEG
31716: PUSH
31717: LD_INT 2
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: PUSH
31724: LD_INT 2
31726: NEG
31727: PUSH
31728: LD_INT 1
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 3
31737: NEG
31738: PUSH
31739: LD_INT 1
31741: NEG
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 3
31749: NEG
31750: PUSH
31751: LD_INT 2
31753: NEG
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: LIST
31763: LIST
31764: LIST
31765: LIST
31766: LIST
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: LIST
31778: LIST
31779: LIST
31780: LIST
31781: LIST
31782: LIST
31783: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31784: LD_ADDR_VAR 0 28
31788: PUSH
31789: LD_INT 0
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: EMPTY
31796: LIST
31797: LIST
31798: PUSH
31799: LD_INT 0
31801: PUSH
31802: LD_INT 1
31804: NEG
31805: PUSH
31806: EMPTY
31807: LIST
31808: LIST
31809: PUSH
31810: LD_INT 1
31812: PUSH
31813: LD_INT 0
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 1
31822: PUSH
31823: LD_INT 1
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 0
31832: PUSH
31833: LD_INT 1
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: PUSH
31840: LD_INT 1
31842: NEG
31843: PUSH
31844: LD_INT 0
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: PUSH
31851: LD_INT 1
31853: NEG
31854: PUSH
31855: LD_INT 1
31857: NEG
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: LD_INT 1
31865: NEG
31866: PUSH
31867: LD_INT 2
31869: NEG
31870: PUSH
31871: EMPTY
31872: LIST
31873: LIST
31874: PUSH
31875: LD_INT 0
31877: PUSH
31878: LD_INT 2
31880: NEG
31881: PUSH
31882: EMPTY
31883: LIST
31884: LIST
31885: PUSH
31886: LD_INT 1
31888: PUSH
31889: LD_INT 1
31891: NEG
31892: PUSH
31893: EMPTY
31894: LIST
31895: LIST
31896: PUSH
31897: LD_INT 2
31899: PUSH
31900: LD_INT 0
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: PUSH
31907: LD_INT 2
31909: PUSH
31910: LD_INT 1
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: LD_INT 2
31919: PUSH
31920: LD_INT 2
31922: PUSH
31923: EMPTY
31924: LIST
31925: LIST
31926: PUSH
31927: LD_INT 1
31929: PUSH
31930: LD_INT 2
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 0
31939: PUSH
31940: LD_INT 2
31942: PUSH
31943: EMPTY
31944: LIST
31945: LIST
31946: PUSH
31947: LD_INT 1
31949: NEG
31950: PUSH
31951: LD_INT 1
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 2
31960: NEG
31961: PUSH
31962: LD_INT 0
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 2
31971: NEG
31972: PUSH
31973: LD_INT 1
31975: NEG
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 2
31983: NEG
31984: PUSH
31985: LD_INT 2
31987: NEG
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PUSH
31993: LD_INT 2
31995: NEG
31996: PUSH
31997: LD_INT 3
31999: NEG
32000: PUSH
32001: EMPTY
32002: LIST
32003: LIST
32004: PUSH
32005: LD_INT 1
32007: NEG
32008: PUSH
32009: LD_INT 3
32011: NEG
32012: PUSH
32013: EMPTY
32014: LIST
32015: LIST
32016: PUSH
32017: LD_INT 3
32019: NEG
32020: PUSH
32021: LD_INT 1
32023: NEG
32024: PUSH
32025: EMPTY
32026: LIST
32027: LIST
32028: PUSH
32029: LD_INT 3
32031: NEG
32032: PUSH
32033: LD_INT 2
32035: NEG
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: LIST
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32066: LD_ADDR_VAR 0 29
32070: PUSH
32071: LD_INT 0
32073: PUSH
32074: LD_INT 0
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 0
32083: PUSH
32084: LD_INT 1
32086: NEG
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 1
32094: PUSH
32095: LD_INT 0
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: PUSH
32102: LD_INT 1
32104: PUSH
32105: LD_INT 1
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 0
32114: PUSH
32115: LD_INT 1
32117: PUSH
32118: EMPTY
32119: LIST
32120: LIST
32121: PUSH
32122: LD_INT 1
32124: NEG
32125: PUSH
32126: LD_INT 0
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 1
32135: NEG
32136: PUSH
32137: LD_INT 1
32139: NEG
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: PUSH
32145: LD_INT 1
32147: NEG
32148: PUSH
32149: LD_INT 2
32151: NEG
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 0
32159: PUSH
32160: LD_INT 2
32162: NEG
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 1
32170: PUSH
32171: LD_INT 1
32173: NEG
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: LD_INT 2
32181: PUSH
32182: LD_INT 0
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 2
32191: PUSH
32192: LD_INT 1
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: PUSH
32199: LD_INT 1
32201: PUSH
32202: LD_INT 2
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: PUSH
32209: LD_INT 0
32211: PUSH
32212: LD_INT 2
32214: PUSH
32215: EMPTY
32216: LIST
32217: LIST
32218: PUSH
32219: LD_INT 1
32221: NEG
32222: PUSH
32223: LD_INT 1
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PUSH
32230: LD_INT 2
32232: NEG
32233: PUSH
32234: LD_INT 1
32236: NEG
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 2
32244: NEG
32245: PUSH
32246: LD_INT 2
32248: NEG
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 2
32256: NEG
32257: PUSH
32258: LD_INT 3
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 2
32268: PUSH
32269: LD_INT 1
32271: NEG
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 3
32279: PUSH
32280: LD_INT 1
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 1
32289: PUSH
32290: LD_INT 3
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: NEG
32300: PUSH
32301: LD_INT 2
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 3
32310: NEG
32311: PUSH
32312: LD_INT 2
32314: NEG
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: LIST
32344: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32345: LD_ADDR_VAR 0 30
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 0
32362: PUSH
32363: LD_INT 1
32365: NEG
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 1
32373: PUSH
32374: LD_INT 0
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 1
32383: PUSH
32384: LD_INT 1
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 0
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 1
32403: NEG
32404: PUSH
32405: LD_INT 0
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: PUSH
32412: LD_INT 1
32414: NEG
32415: PUSH
32416: LD_INT 1
32418: NEG
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 1
32426: NEG
32427: PUSH
32428: LD_INT 2
32430: NEG
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 0
32438: PUSH
32439: LD_INT 2
32441: NEG
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PUSH
32447: LD_INT 1
32449: PUSH
32450: LD_INT 1
32452: NEG
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 2
32460: PUSH
32461: LD_INT 0
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: LD_INT 2
32470: PUSH
32471: LD_INT 1
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 2
32480: PUSH
32481: LD_INT 2
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: LD_INT 1
32490: PUSH
32491: LD_INT 2
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PUSH
32498: LD_INT 1
32500: NEG
32501: PUSH
32502: LD_INT 1
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 2
32511: NEG
32512: PUSH
32513: LD_INT 0
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PUSH
32520: LD_INT 2
32522: NEG
32523: PUSH
32524: LD_INT 1
32526: NEG
32527: PUSH
32528: EMPTY
32529: LIST
32530: LIST
32531: PUSH
32532: LD_INT 1
32534: NEG
32535: PUSH
32536: LD_INT 3
32538: NEG
32539: PUSH
32540: EMPTY
32541: LIST
32542: LIST
32543: PUSH
32544: LD_INT 1
32546: PUSH
32547: LD_INT 2
32549: NEG
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 3
32557: PUSH
32558: LD_INT 2
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 2
32567: PUSH
32568: LD_INT 3
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: PUSH
32575: LD_INT 2
32577: NEG
32578: PUSH
32579: LD_INT 1
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 3
32588: NEG
32589: PUSH
32590: LD_INT 1
32592: NEG
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: PUSH
32598: EMPTY
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: LIST
32611: LIST
32612: LIST
32613: LIST
32614: LIST
32615: LIST
32616: LIST
32617: LIST
32618: LIST
32619: LIST
32620: LIST
32621: LIST
32622: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32623: LD_ADDR_VAR 0 31
32627: PUSH
32628: LD_INT 0
32630: PUSH
32631: LD_INT 0
32633: PUSH
32634: EMPTY
32635: LIST
32636: LIST
32637: PUSH
32638: LD_INT 0
32640: PUSH
32641: LD_INT 1
32643: NEG
32644: PUSH
32645: EMPTY
32646: LIST
32647: LIST
32648: PUSH
32649: LD_INT 1
32651: PUSH
32652: LD_INT 0
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 1
32661: PUSH
32662: LD_INT 1
32664: PUSH
32665: EMPTY
32666: LIST
32667: LIST
32668: PUSH
32669: LD_INT 0
32671: PUSH
32672: LD_INT 1
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 1
32681: NEG
32682: PUSH
32683: LD_INT 0
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: LD_INT 1
32692: NEG
32693: PUSH
32694: LD_INT 1
32696: NEG
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: NEG
32705: PUSH
32706: LD_INT 2
32708: NEG
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 1
32716: PUSH
32717: LD_INT 1
32719: NEG
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 2
32727: PUSH
32728: LD_INT 0
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 2
32737: PUSH
32738: LD_INT 1
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 2
32747: PUSH
32748: LD_INT 2
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: PUSH
32758: LD_INT 2
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: PUSH
32765: LD_INT 0
32767: PUSH
32768: LD_INT 2
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 1
32777: NEG
32778: PUSH
32779: LD_INT 1
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 2
32788: NEG
32789: PUSH
32790: LD_INT 1
32792: NEG
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 2
32800: NEG
32801: PUSH
32802: LD_INT 2
32804: NEG
32805: PUSH
32806: EMPTY
32807: LIST
32808: LIST
32809: PUSH
32810: LD_INT 2
32812: NEG
32813: PUSH
32814: LD_INT 3
32816: NEG
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 2
32824: PUSH
32825: LD_INT 1
32827: NEG
32828: PUSH
32829: EMPTY
32830: LIST
32831: LIST
32832: PUSH
32833: LD_INT 3
32835: PUSH
32836: LD_INT 1
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 1
32845: PUSH
32846: LD_INT 3
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: LD_INT 1
32855: NEG
32856: PUSH
32857: LD_INT 2
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 3
32866: NEG
32867: PUSH
32868: LD_INT 2
32870: NEG
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: LIST
32894: LIST
32895: LIST
32896: LIST
32897: LIST
32898: LIST
32899: LIST
32900: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32901: LD_ADDR_VAR 0 32
32905: PUSH
32906: LD_INT 0
32908: PUSH
32909: LD_INT 0
32911: PUSH
32912: EMPTY
32913: LIST
32914: LIST
32915: PUSH
32916: LD_INT 0
32918: PUSH
32919: LD_INT 1
32921: NEG
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PUSH
32927: LD_INT 1
32929: PUSH
32930: LD_INT 0
32932: PUSH
32933: EMPTY
32934: LIST
32935: LIST
32936: PUSH
32937: LD_INT 1
32939: PUSH
32940: LD_INT 1
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 0
32949: PUSH
32950: LD_INT 1
32952: PUSH
32953: EMPTY
32954: LIST
32955: LIST
32956: PUSH
32957: LD_INT 1
32959: NEG
32960: PUSH
32961: LD_INT 0
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: PUSH
32968: LD_INT 1
32970: NEG
32971: PUSH
32972: LD_INT 1
32974: NEG
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 1
32982: NEG
32983: PUSH
32984: LD_INT 2
32986: NEG
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: LD_INT 0
32994: PUSH
32995: LD_INT 2
32997: NEG
32998: PUSH
32999: EMPTY
33000: LIST
33001: LIST
33002: PUSH
33003: LD_INT 1
33005: PUSH
33006: LD_INT 1
33008: NEG
33009: PUSH
33010: EMPTY
33011: LIST
33012: LIST
33013: PUSH
33014: LD_INT 2
33016: PUSH
33017: LD_INT 1
33019: PUSH
33020: EMPTY
33021: LIST
33022: LIST
33023: PUSH
33024: LD_INT 2
33026: PUSH
33027: LD_INT 2
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: PUSH
33034: LD_INT 1
33036: PUSH
33037: LD_INT 2
33039: PUSH
33040: EMPTY
33041: LIST
33042: LIST
33043: PUSH
33044: LD_INT 0
33046: PUSH
33047: LD_INT 2
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 1
33056: NEG
33057: PUSH
33058: LD_INT 1
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 2
33067: NEG
33068: PUSH
33069: LD_INT 0
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: PUSH
33076: LD_INT 2
33078: NEG
33079: PUSH
33080: LD_INT 1
33082: NEG
33083: PUSH
33084: EMPTY
33085: LIST
33086: LIST
33087: PUSH
33088: LD_INT 1
33090: NEG
33091: PUSH
33092: LD_INT 3
33094: NEG
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 1
33102: PUSH
33103: LD_INT 2
33105: NEG
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: PUSH
33111: LD_INT 3
33113: PUSH
33114: LD_INT 2
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 2
33123: PUSH
33124: LD_INT 3
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 2
33133: NEG
33134: PUSH
33135: LD_INT 1
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 3
33144: NEG
33145: PUSH
33146: LD_INT 1
33148: NEG
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: EMPTY
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: LIST
33173: LIST
33174: LIST
33175: LIST
33176: LIST
33177: LIST
33178: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33179: LD_ADDR_VAR 0 33
33183: PUSH
33184: LD_INT 0
33186: PUSH
33187: LD_INT 0
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: PUSH
33194: LD_INT 0
33196: PUSH
33197: LD_INT 1
33199: NEG
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 1
33207: PUSH
33208: LD_INT 0
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 1
33217: PUSH
33218: LD_INT 1
33220: PUSH
33221: EMPTY
33222: LIST
33223: LIST
33224: PUSH
33225: LD_INT 0
33227: PUSH
33228: LD_INT 1
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 1
33237: NEG
33238: PUSH
33239: LD_INT 0
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PUSH
33246: LD_INT 1
33248: NEG
33249: PUSH
33250: LD_INT 1
33252: NEG
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 1
33260: NEG
33261: PUSH
33262: LD_INT 2
33264: NEG
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 1
33272: PUSH
33273: LD_INT 1
33275: NEG
33276: PUSH
33277: EMPTY
33278: LIST
33279: LIST
33280: PUSH
33281: LD_INT 2
33283: PUSH
33284: LD_INT 0
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 2
33293: PUSH
33294: LD_INT 1
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: LD_INT 1
33303: PUSH
33304: LD_INT 2
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 0
33313: PUSH
33314: LD_INT 2
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 1
33323: NEG
33324: PUSH
33325: LD_INT 1
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PUSH
33332: LD_INT 2
33334: NEG
33335: PUSH
33336: LD_INT 0
33338: PUSH
33339: EMPTY
33340: LIST
33341: LIST
33342: PUSH
33343: LD_INT 2
33345: NEG
33346: PUSH
33347: LD_INT 1
33349: NEG
33350: PUSH
33351: EMPTY
33352: LIST
33353: LIST
33354: PUSH
33355: LD_INT 2
33357: NEG
33358: PUSH
33359: LD_INT 2
33361: NEG
33362: PUSH
33363: EMPTY
33364: LIST
33365: LIST
33366: PUSH
33367: LD_INT 2
33369: NEG
33370: PUSH
33371: LD_INT 3
33373: NEG
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: LD_INT 2
33381: PUSH
33382: LD_INT 1
33384: NEG
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 3
33392: PUSH
33393: LD_INT 1
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: LD_INT 3
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 1
33412: NEG
33413: PUSH
33414: LD_INT 2
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 3
33423: NEG
33424: PUSH
33425: LD_INT 2
33427: NEG
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: LIST
33439: LIST
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: LIST
33450: LIST
33451: LIST
33452: LIST
33453: LIST
33454: LIST
33455: LIST
33456: LIST
33457: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33458: LD_ADDR_VAR 0 34
33462: PUSH
33463: LD_INT 0
33465: PUSH
33466: LD_INT 0
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 0
33475: PUSH
33476: LD_INT 1
33478: NEG
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 1
33486: PUSH
33487: LD_INT 0
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 1
33496: PUSH
33497: LD_INT 1
33499: PUSH
33500: EMPTY
33501: LIST
33502: LIST
33503: PUSH
33504: LD_INT 0
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 1
33516: NEG
33517: PUSH
33518: LD_INT 0
33520: PUSH
33521: EMPTY
33522: LIST
33523: LIST
33524: PUSH
33525: LD_INT 1
33527: NEG
33528: PUSH
33529: LD_INT 1
33531: NEG
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 1
33539: NEG
33540: PUSH
33541: LD_INT 2
33543: NEG
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 0
33551: PUSH
33552: LD_INT 2
33554: NEG
33555: PUSH
33556: EMPTY
33557: LIST
33558: LIST
33559: PUSH
33560: LD_INT 1
33562: PUSH
33563: LD_INT 1
33565: NEG
33566: PUSH
33567: EMPTY
33568: LIST
33569: LIST
33570: PUSH
33571: LD_INT 2
33573: PUSH
33574: LD_INT 1
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 2
33583: PUSH
33584: LD_INT 2
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: PUSH
33591: LD_INT 1
33593: PUSH
33594: LD_INT 2
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 1
33603: NEG
33604: PUSH
33605: LD_INT 1
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 2
33614: NEG
33615: PUSH
33616: LD_INT 0
33618: PUSH
33619: EMPTY
33620: LIST
33621: LIST
33622: PUSH
33623: LD_INT 2
33625: NEG
33626: PUSH
33627: LD_INT 1
33629: NEG
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PUSH
33635: LD_INT 2
33637: NEG
33638: PUSH
33639: LD_INT 2
33641: NEG
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: NEG
33650: PUSH
33651: LD_INT 3
33653: NEG
33654: PUSH
33655: EMPTY
33656: LIST
33657: LIST
33658: PUSH
33659: LD_INT 1
33661: PUSH
33662: LD_INT 2
33664: NEG
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 3
33672: PUSH
33673: LD_INT 2
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: PUSH
33680: LD_INT 2
33682: PUSH
33683: LD_INT 3
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: LD_INT 2
33692: NEG
33693: PUSH
33694: LD_INT 1
33696: PUSH
33697: EMPTY
33698: LIST
33699: LIST
33700: PUSH
33701: LD_INT 3
33703: NEG
33704: PUSH
33705: LD_INT 1
33707: NEG
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PUSH
33713: EMPTY
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: LIST
33737: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33738: LD_ADDR_VAR 0 35
33742: PUSH
33743: LD_INT 0
33745: PUSH
33746: LD_INT 0
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 0
33755: PUSH
33756: LD_INT 1
33758: NEG
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 1
33766: PUSH
33767: LD_INT 0
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: LD_INT 1
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 0
33786: PUSH
33787: LD_INT 1
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 1
33796: NEG
33797: PUSH
33798: LD_INT 0
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 1
33807: NEG
33808: PUSH
33809: LD_INT 1
33811: NEG
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 2
33819: PUSH
33820: LD_INT 1
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 2
33829: NEG
33830: PUSH
33831: LD_INT 1
33833: NEG
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: EMPTY
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: LIST
33849: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33850: LD_ADDR_VAR 0 36
33854: PUSH
33855: LD_INT 0
33857: PUSH
33858: LD_INT 0
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 0
33867: PUSH
33868: LD_INT 1
33870: NEG
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: PUSH
33876: LD_INT 1
33878: PUSH
33879: LD_INT 0
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: LD_INT 1
33888: PUSH
33889: LD_INT 1
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PUSH
33896: LD_INT 0
33898: PUSH
33899: LD_INT 1
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 1
33908: NEG
33909: PUSH
33910: LD_INT 0
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 1
33919: NEG
33920: PUSH
33921: LD_INT 1
33923: NEG
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 1
33931: NEG
33932: PUSH
33933: LD_INT 2
33935: NEG
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: LD_INT 2
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: EMPTY
33952: LIST
33953: LIST
33954: LIST
33955: LIST
33956: LIST
33957: LIST
33958: LIST
33959: LIST
33960: LIST
33961: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33962: LD_ADDR_VAR 0 37
33966: PUSH
33967: LD_INT 0
33969: PUSH
33970: LD_INT 0
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 0
33979: PUSH
33980: LD_INT 1
33982: NEG
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: LD_INT 1
33990: PUSH
33991: LD_INT 0
33993: PUSH
33994: EMPTY
33995: LIST
33996: LIST
33997: PUSH
33998: LD_INT 1
34000: PUSH
34001: LD_INT 1
34003: PUSH
34004: EMPTY
34005: LIST
34006: LIST
34007: PUSH
34008: LD_INT 0
34010: PUSH
34011: LD_INT 1
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: PUSH
34018: LD_INT 1
34020: NEG
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: LD_INT 1
34031: NEG
34032: PUSH
34033: LD_INT 1
34035: NEG
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 1
34043: PUSH
34044: LD_INT 1
34046: NEG
34047: PUSH
34048: EMPTY
34049: LIST
34050: LIST
34051: PUSH
34052: LD_INT 1
34054: NEG
34055: PUSH
34056: LD_INT 1
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34074: LD_ADDR_VAR 0 38
34078: PUSH
34079: LD_INT 0
34081: PUSH
34082: LD_INT 0
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 0
34091: PUSH
34092: LD_INT 1
34094: NEG
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 1
34102: PUSH
34103: LD_INT 0
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 1
34112: PUSH
34113: LD_INT 1
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: LD_INT 1
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 1
34132: NEG
34133: PUSH
34134: LD_INT 0
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: PUSH
34141: LD_INT 1
34143: NEG
34144: PUSH
34145: LD_INT 1
34147: NEG
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 2
34155: PUSH
34156: LD_INT 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 2
34165: NEG
34166: PUSH
34167: LD_INT 1
34169: NEG
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: LIST
34179: LIST
34180: LIST
34181: LIST
34182: LIST
34183: LIST
34184: LIST
34185: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34186: LD_ADDR_VAR 0 39
34190: PUSH
34191: LD_INT 0
34193: PUSH
34194: LD_INT 0
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: PUSH
34201: LD_INT 0
34203: PUSH
34204: LD_INT 1
34206: NEG
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: PUSH
34212: LD_INT 1
34214: PUSH
34215: LD_INT 0
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: PUSH
34222: LD_INT 1
34224: PUSH
34225: LD_INT 1
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PUSH
34232: LD_INT 0
34234: PUSH
34235: LD_INT 1
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: LD_INT 1
34244: NEG
34245: PUSH
34246: LD_INT 0
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PUSH
34253: LD_INT 1
34255: NEG
34256: PUSH
34257: LD_INT 1
34259: NEG
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 1
34267: NEG
34268: PUSH
34269: LD_INT 2
34271: NEG
34272: PUSH
34273: EMPTY
34274: LIST
34275: LIST
34276: PUSH
34277: LD_INT 1
34279: PUSH
34280: LD_INT 2
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: LIST
34291: LIST
34292: LIST
34293: LIST
34294: LIST
34295: LIST
34296: LIST
34297: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34298: LD_ADDR_VAR 0 40
34302: PUSH
34303: LD_INT 0
34305: PUSH
34306: LD_INT 0
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 0
34315: PUSH
34316: LD_INT 1
34318: NEG
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PUSH
34324: LD_INT 1
34326: PUSH
34327: LD_INT 0
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: LD_INT 1
34336: PUSH
34337: LD_INT 1
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 0
34346: PUSH
34347: LD_INT 1
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: NEG
34357: PUSH
34358: LD_INT 0
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 1
34367: NEG
34368: PUSH
34369: LD_INT 1
34371: NEG
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 1
34379: PUSH
34380: LD_INT 1
34382: NEG
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 1
34390: NEG
34391: PUSH
34392: LD_INT 1
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34410: LD_ADDR_VAR 0 41
34414: PUSH
34415: LD_INT 0
34417: PUSH
34418: LD_INT 0
34420: PUSH
34421: EMPTY
34422: LIST
34423: LIST
34424: PUSH
34425: LD_INT 0
34427: PUSH
34428: LD_INT 1
34430: NEG
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: PUSH
34436: LD_INT 1
34438: PUSH
34439: LD_INT 0
34441: PUSH
34442: EMPTY
34443: LIST
34444: LIST
34445: PUSH
34446: LD_INT 1
34448: PUSH
34449: LD_INT 1
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: LD_INT 1
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: LD_INT 0
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PUSH
34477: LD_INT 1
34479: NEG
34480: PUSH
34481: LD_INT 1
34483: NEG
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 1
34491: NEG
34492: PUSH
34493: LD_INT 2
34495: NEG
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: LD_INT 1
34503: PUSH
34504: LD_INT 1
34506: NEG
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 2
34514: PUSH
34515: LD_INT 0
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 2
34524: PUSH
34525: LD_INT 1
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 2
34534: PUSH
34535: LD_INT 2
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 1
34544: PUSH
34545: LD_INT 2
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 1
34554: NEG
34555: PUSH
34556: LD_INT 1
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 2
34565: NEG
34566: PUSH
34567: LD_INT 0
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 2
34576: NEG
34577: PUSH
34578: LD_INT 1
34580: NEG
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 2
34588: NEG
34589: PUSH
34590: LD_INT 2
34592: NEG
34593: PUSH
34594: EMPTY
34595: LIST
34596: LIST
34597: PUSH
34598: LD_INT 2
34600: NEG
34601: PUSH
34602: LD_INT 3
34604: NEG
34605: PUSH
34606: EMPTY
34607: LIST
34608: LIST
34609: PUSH
34610: LD_INT 2
34612: PUSH
34613: LD_INT 1
34615: NEG
34616: PUSH
34617: EMPTY
34618: LIST
34619: LIST
34620: PUSH
34621: LD_INT 3
34623: PUSH
34624: LD_INT 0
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: PUSH
34631: LD_INT 3
34633: PUSH
34634: LD_INT 1
34636: PUSH
34637: EMPTY
34638: LIST
34639: LIST
34640: PUSH
34641: LD_INT 3
34643: PUSH
34644: LD_INT 2
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 3
34653: PUSH
34654: LD_INT 3
34656: PUSH
34657: EMPTY
34658: LIST
34659: LIST
34660: PUSH
34661: LD_INT 2
34663: PUSH
34664: LD_INT 3
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: PUSH
34671: LD_INT 2
34673: NEG
34674: PUSH
34675: LD_INT 1
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 3
34684: NEG
34685: PUSH
34686: LD_INT 0
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 3
34695: NEG
34696: PUSH
34697: LD_INT 1
34699: NEG
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 3
34707: NEG
34708: PUSH
34709: LD_INT 2
34711: NEG
34712: PUSH
34713: EMPTY
34714: LIST
34715: LIST
34716: PUSH
34717: LD_INT 3
34719: NEG
34720: PUSH
34721: LD_INT 3
34723: NEG
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: LIST
34744: LIST
34745: LIST
34746: LIST
34747: LIST
34748: LIST
34749: LIST
34750: LIST
34751: LIST
34752: LIST
34753: LIST
34754: LIST
34755: LIST
34756: LIST
34757: LIST
34758: LIST
34759: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34760: LD_ADDR_VAR 0 42
34764: PUSH
34765: LD_INT 0
34767: PUSH
34768: LD_INT 0
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 0
34777: PUSH
34778: LD_INT 1
34780: NEG
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 1
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 1
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 0
34808: PUSH
34809: LD_INT 1
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: LD_INT 0
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 1
34829: NEG
34830: PUSH
34831: LD_INT 1
34833: NEG
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 1
34841: NEG
34842: PUSH
34843: LD_INT 2
34845: NEG
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: LD_INT 2
34856: NEG
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: LD_INT 1
34867: NEG
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: PUSH
34873: LD_INT 2
34875: PUSH
34876: LD_INT 1
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PUSH
34883: LD_INT 2
34885: PUSH
34886: LD_INT 2
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 1
34895: PUSH
34896: LD_INT 2
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: LD_INT 0
34905: PUSH
34906: LD_INT 2
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 1
34915: NEG
34916: PUSH
34917: LD_INT 1
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: LD_INT 2
34926: NEG
34927: PUSH
34928: LD_INT 1
34930: NEG
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 2
34938: NEG
34939: PUSH
34940: LD_INT 2
34942: NEG
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 2
34950: NEG
34951: PUSH
34952: LD_INT 3
34954: NEG
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 1
34962: NEG
34963: PUSH
34964: LD_INT 3
34966: NEG
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 0
34974: PUSH
34975: LD_INT 3
34977: NEG
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: LD_INT 1
34985: PUSH
34986: LD_INT 2
34988: NEG
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 3
34996: PUSH
34997: LD_INT 2
34999: PUSH
35000: EMPTY
35001: LIST
35002: LIST
35003: PUSH
35004: LD_INT 3
35006: PUSH
35007: LD_INT 3
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 2
35016: PUSH
35017: LD_INT 3
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: LD_INT 1
35026: PUSH
35027: LD_INT 3
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 0
35036: PUSH
35037: LD_INT 3
35039: PUSH
35040: EMPTY
35041: LIST
35042: LIST
35043: PUSH
35044: LD_INT 1
35046: NEG
35047: PUSH
35048: LD_INT 2
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: PUSH
35055: LD_INT 3
35057: NEG
35058: PUSH
35059: LD_INT 2
35061: NEG
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 3
35069: NEG
35070: PUSH
35071: LD_INT 3
35073: NEG
35074: PUSH
35075: EMPTY
35076: LIST
35077: LIST
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: LIST
35092: LIST
35093: LIST
35094: LIST
35095: LIST
35096: LIST
35097: LIST
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35110: LD_ADDR_VAR 0 43
35114: PUSH
35115: LD_INT 0
35117: PUSH
35118: LD_INT 0
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PUSH
35125: LD_INT 0
35127: PUSH
35128: LD_INT 1
35130: NEG
35131: PUSH
35132: EMPTY
35133: LIST
35134: LIST
35135: PUSH
35136: LD_INT 1
35138: PUSH
35139: LD_INT 0
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 1
35148: PUSH
35149: LD_INT 1
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PUSH
35156: LD_INT 0
35158: PUSH
35159: LD_INT 1
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 1
35168: NEG
35169: PUSH
35170: LD_INT 0
35172: PUSH
35173: EMPTY
35174: LIST
35175: LIST
35176: PUSH
35177: LD_INT 1
35179: NEG
35180: PUSH
35181: LD_INT 1
35183: NEG
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 2
35195: NEG
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 0
35203: PUSH
35204: LD_INT 2
35206: NEG
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 1
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 2
35225: PUSH
35226: LD_INT 0
35228: PUSH
35229: EMPTY
35230: LIST
35231: LIST
35232: PUSH
35233: LD_INT 2
35235: PUSH
35236: LD_INT 1
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 1
35245: PUSH
35246: LD_INT 2
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 0
35255: PUSH
35256: LD_INT 2
35258: PUSH
35259: EMPTY
35260: LIST
35261: LIST
35262: PUSH
35263: LD_INT 1
35265: NEG
35266: PUSH
35267: LD_INT 1
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 2
35276: NEG
35277: PUSH
35278: LD_INT 0
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: LD_INT 2
35287: NEG
35288: PUSH
35289: LD_INT 1
35291: NEG
35292: PUSH
35293: EMPTY
35294: LIST
35295: LIST
35296: PUSH
35297: LD_INT 1
35299: NEG
35300: PUSH
35301: LD_INT 3
35303: NEG
35304: PUSH
35305: EMPTY
35306: LIST
35307: LIST
35308: PUSH
35309: LD_INT 0
35311: PUSH
35312: LD_INT 3
35314: NEG
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 1
35322: PUSH
35323: LD_INT 2
35325: NEG
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 2
35333: PUSH
35334: LD_INT 1
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 3
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 3
35354: PUSH
35355: LD_INT 1
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 1
35364: PUSH
35365: LD_INT 3
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 0
35374: PUSH
35375: LD_INT 3
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 1
35384: NEG
35385: PUSH
35386: LD_INT 2
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 2
35395: NEG
35396: PUSH
35397: LD_INT 1
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 3
35406: NEG
35407: PUSH
35408: LD_INT 0
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 3
35417: NEG
35418: PUSH
35419: LD_INT 1
35421: NEG
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: LIST
35440: LIST
35441: LIST
35442: LIST
35443: LIST
35444: LIST
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35458: LD_ADDR_VAR 0 44
35462: PUSH
35463: LD_INT 0
35465: PUSH
35466: LD_INT 0
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PUSH
35473: LD_INT 0
35475: PUSH
35476: LD_INT 1
35478: NEG
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 1
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: LD_INT 1
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: NEG
35517: PUSH
35518: LD_INT 0
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: LD_INT 1
35531: NEG
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 1
35539: NEG
35540: PUSH
35541: LD_INT 2
35543: NEG
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 1
35551: PUSH
35552: LD_INT 1
35554: NEG
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 2
35562: PUSH
35563: LD_INT 0
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: LD_INT 2
35572: PUSH
35573: LD_INT 1
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 2
35582: PUSH
35583: LD_INT 2
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 1
35592: PUSH
35593: LD_INT 2
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 1
35602: NEG
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 2
35613: NEG
35614: PUSH
35615: LD_INT 0
35617: PUSH
35618: EMPTY
35619: LIST
35620: LIST
35621: PUSH
35622: LD_INT 2
35624: NEG
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 2
35636: NEG
35637: PUSH
35638: LD_INT 2
35640: NEG
35641: PUSH
35642: EMPTY
35643: LIST
35644: LIST
35645: PUSH
35646: LD_INT 2
35648: NEG
35649: PUSH
35650: LD_INT 3
35652: NEG
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 2
35660: PUSH
35661: LD_INT 1
35663: NEG
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: LD_INT 3
35671: PUSH
35672: LD_INT 0
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 3
35681: PUSH
35682: LD_INT 1
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 3
35691: PUSH
35692: LD_INT 2
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: LD_INT 3
35701: PUSH
35702: LD_INT 3
35704: PUSH
35705: EMPTY
35706: LIST
35707: LIST
35708: PUSH
35709: LD_INT 2
35711: PUSH
35712: LD_INT 3
35714: PUSH
35715: EMPTY
35716: LIST
35717: LIST
35718: PUSH
35719: LD_INT 2
35721: NEG
35722: PUSH
35723: LD_INT 1
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: PUSH
35730: LD_INT 3
35732: NEG
35733: PUSH
35734: LD_INT 0
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 3
35743: NEG
35744: PUSH
35745: LD_INT 1
35747: NEG
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 3
35755: NEG
35756: PUSH
35757: LD_INT 2
35759: NEG
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: PUSH
35765: LD_INT 3
35767: NEG
35768: PUSH
35769: LD_INT 3
35771: NEG
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: LIST
35781: LIST
35782: LIST
35783: LIST
35784: LIST
35785: LIST
35786: LIST
35787: LIST
35788: LIST
35789: LIST
35790: LIST
35791: LIST
35792: LIST
35793: LIST
35794: LIST
35795: LIST
35796: LIST
35797: LIST
35798: LIST
35799: LIST
35800: LIST
35801: LIST
35802: LIST
35803: LIST
35804: LIST
35805: LIST
35806: LIST
35807: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35808: LD_ADDR_VAR 0 45
35812: PUSH
35813: LD_INT 0
35815: PUSH
35816: LD_INT 0
35818: PUSH
35819: EMPTY
35820: LIST
35821: LIST
35822: PUSH
35823: LD_INT 0
35825: PUSH
35826: LD_INT 1
35828: NEG
35829: PUSH
35830: EMPTY
35831: LIST
35832: LIST
35833: PUSH
35834: LD_INT 1
35836: PUSH
35837: LD_INT 0
35839: PUSH
35840: EMPTY
35841: LIST
35842: LIST
35843: PUSH
35844: LD_INT 1
35846: PUSH
35847: LD_INT 1
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: LD_INT 1
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: LD_INT 1
35866: NEG
35867: PUSH
35868: LD_INT 0
35870: PUSH
35871: EMPTY
35872: LIST
35873: LIST
35874: PUSH
35875: LD_INT 1
35877: NEG
35878: PUSH
35879: LD_INT 1
35881: NEG
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 1
35889: NEG
35890: PUSH
35891: LD_INT 2
35893: NEG
35894: PUSH
35895: EMPTY
35896: LIST
35897: LIST
35898: PUSH
35899: LD_INT 0
35901: PUSH
35902: LD_INT 2
35904: NEG
35905: PUSH
35906: EMPTY
35907: LIST
35908: LIST
35909: PUSH
35910: LD_INT 1
35912: PUSH
35913: LD_INT 1
35915: NEG
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: PUSH
35921: LD_INT 2
35923: PUSH
35924: LD_INT 1
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: PUSH
35931: LD_INT 2
35933: PUSH
35934: LD_INT 2
35936: PUSH
35937: EMPTY
35938: LIST
35939: LIST
35940: PUSH
35941: LD_INT 1
35943: PUSH
35944: LD_INT 2
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: LD_INT 0
35953: PUSH
35954: LD_INT 2
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 1
35963: NEG
35964: PUSH
35965: LD_INT 1
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 2
35974: NEG
35975: PUSH
35976: LD_INT 1
35978: NEG
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 2
35986: NEG
35987: PUSH
35988: LD_INT 2
35990: NEG
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: PUSH
35996: LD_INT 2
35998: NEG
35999: PUSH
36000: LD_INT 3
36002: NEG
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 1
36010: NEG
36011: PUSH
36012: LD_INT 3
36014: NEG
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 0
36022: PUSH
36023: LD_INT 3
36025: NEG
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 1
36033: PUSH
36034: LD_INT 2
36036: NEG
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 3
36044: PUSH
36045: LD_INT 2
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 3
36054: PUSH
36055: LD_INT 3
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 2
36064: PUSH
36065: LD_INT 3
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 1
36074: PUSH
36075: LD_INT 3
36077: PUSH
36078: EMPTY
36079: LIST
36080: LIST
36081: PUSH
36082: LD_INT 0
36084: PUSH
36085: LD_INT 3
36087: PUSH
36088: EMPTY
36089: LIST
36090: LIST
36091: PUSH
36092: LD_INT 1
36094: NEG
36095: PUSH
36096: LD_INT 2
36098: PUSH
36099: EMPTY
36100: LIST
36101: LIST
36102: PUSH
36103: LD_INT 3
36105: NEG
36106: PUSH
36107: LD_INT 2
36109: NEG
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 3
36117: NEG
36118: PUSH
36119: LD_INT 3
36121: NEG
36122: PUSH
36123: EMPTY
36124: LIST
36125: LIST
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: LIST
36144: LIST
36145: LIST
36146: LIST
36147: LIST
36148: LIST
36149: LIST
36150: LIST
36151: LIST
36152: LIST
36153: LIST
36154: LIST
36155: LIST
36156: LIST
36157: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36158: LD_ADDR_VAR 0 46
36162: PUSH
36163: LD_INT 0
36165: PUSH
36166: LD_INT 0
36168: PUSH
36169: EMPTY
36170: LIST
36171: LIST
36172: PUSH
36173: LD_INT 0
36175: PUSH
36176: LD_INT 1
36178: NEG
36179: PUSH
36180: EMPTY
36181: LIST
36182: LIST
36183: PUSH
36184: LD_INT 1
36186: PUSH
36187: LD_INT 0
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 1
36196: PUSH
36197: LD_INT 1
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: LD_INT 0
36206: PUSH
36207: LD_INT 1
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 1
36216: NEG
36217: PUSH
36218: LD_INT 0
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 1
36227: NEG
36228: PUSH
36229: LD_INT 1
36231: NEG
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 1
36239: NEG
36240: PUSH
36241: LD_INT 2
36243: NEG
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: PUSH
36249: LD_INT 0
36251: PUSH
36252: LD_INT 2
36254: NEG
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: PUSH
36260: LD_INT 1
36262: PUSH
36263: LD_INT 1
36265: NEG
36266: PUSH
36267: EMPTY
36268: LIST
36269: LIST
36270: PUSH
36271: LD_INT 2
36273: PUSH
36274: LD_INT 0
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: PUSH
36281: LD_INT 2
36283: PUSH
36284: LD_INT 1
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 1
36293: PUSH
36294: LD_INT 2
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: LD_INT 2
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 1
36313: NEG
36314: PUSH
36315: LD_INT 1
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: LD_INT 2
36324: NEG
36325: PUSH
36326: LD_INT 0
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: PUSH
36333: LD_INT 2
36335: NEG
36336: PUSH
36337: LD_INT 1
36339: NEG
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: PUSH
36345: LD_INT 1
36347: NEG
36348: PUSH
36349: LD_INT 3
36351: NEG
36352: PUSH
36353: EMPTY
36354: LIST
36355: LIST
36356: PUSH
36357: LD_INT 0
36359: PUSH
36360: LD_INT 3
36362: NEG
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: LD_INT 1
36370: PUSH
36371: LD_INT 2
36373: NEG
36374: PUSH
36375: EMPTY
36376: LIST
36377: LIST
36378: PUSH
36379: LD_INT 2
36381: PUSH
36382: LD_INT 1
36384: NEG
36385: PUSH
36386: EMPTY
36387: LIST
36388: LIST
36389: PUSH
36390: LD_INT 3
36392: PUSH
36393: LD_INT 0
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 3
36402: PUSH
36403: LD_INT 1
36405: PUSH
36406: EMPTY
36407: LIST
36408: LIST
36409: PUSH
36410: LD_INT 1
36412: PUSH
36413: LD_INT 3
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 0
36422: PUSH
36423: LD_INT 3
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: LD_INT 1
36432: NEG
36433: PUSH
36434: LD_INT 2
36436: PUSH
36437: EMPTY
36438: LIST
36439: LIST
36440: PUSH
36441: LD_INT 2
36443: NEG
36444: PUSH
36445: LD_INT 1
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: PUSH
36452: LD_INT 3
36454: NEG
36455: PUSH
36456: LD_INT 0
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: LD_INT 3
36465: NEG
36466: PUSH
36467: LD_INT 1
36469: NEG
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: LIST
36494: LIST
36495: LIST
36496: LIST
36497: LIST
36498: LIST
36499: LIST
36500: LIST
36501: LIST
36502: LIST
36503: LIST
36504: LIST
36505: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36506: LD_ADDR_VAR 0 47
36510: PUSH
36511: LD_INT 0
36513: PUSH
36514: LD_INT 0
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: LD_INT 1
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 1
36534: PUSH
36535: LD_INT 0
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 1
36544: PUSH
36545: LD_INT 1
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: LD_INT 1
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 1
36564: NEG
36565: PUSH
36566: LD_INT 0
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 1
36575: NEG
36576: PUSH
36577: LD_INT 1
36579: NEG
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 1
36587: NEG
36588: PUSH
36589: LD_INT 2
36591: NEG
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 0
36599: PUSH
36600: LD_INT 2
36602: NEG
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 1
36610: PUSH
36611: LD_INT 1
36613: NEG
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 2
36621: NEG
36622: PUSH
36623: LD_INT 1
36625: NEG
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 2
36633: NEG
36634: PUSH
36635: LD_INT 2
36637: NEG
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: LIST
36647: LIST
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36657: LD_ADDR_VAR 0 48
36661: PUSH
36662: LD_INT 0
36664: PUSH
36665: LD_INT 0
36667: PUSH
36668: EMPTY
36669: LIST
36670: LIST
36671: PUSH
36672: LD_INT 0
36674: PUSH
36675: LD_INT 1
36677: NEG
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 1
36685: PUSH
36686: LD_INT 0
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 1
36695: PUSH
36696: LD_INT 1
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 0
36705: PUSH
36706: LD_INT 1
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: PUSH
36713: LD_INT 1
36715: NEG
36716: PUSH
36717: LD_INT 0
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 1
36726: NEG
36727: PUSH
36728: LD_INT 1
36730: NEG
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 1
36738: NEG
36739: PUSH
36740: LD_INT 2
36742: NEG
36743: PUSH
36744: EMPTY
36745: LIST
36746: LIST
36747: PUSH
36748: LD_INT 0
36750: PUSH
36751: LD_INT 2
36753: NEG
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 1
36761: PUSH
36762: LD_INT 1
36764: NEG
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 2
36772: PUSH
36773: LD_INT 0
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 2
36782: PUSH
36783: LD_INT 1
36785: PUSH
36786: EMPTY
36787: LIST
36788: LIST
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: LIST
36796: LIST
36797: LIST
36798: LIST
36799: LIST
36800: LIST
36801: LIST
36802: LIST
36803: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36804: LD_ADDR_VAR 0 49
36808: PUSH
36809: LD_INT 0
36811: PUSH
36812: LD_INT 0
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: PUSH
36819: LD_INT 0
36821: PUSH
36822: LD_INT 1
36824: NEG
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: PUSH
36830: LD_INT 1
36832: PUSH
36833: LD_INT 0
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: PUSH
36840: LD_INT 1
36842: PUSH
36843: LD_INT 1
36845: PUSH
36846: EMPTY
36847: LIST
36848: LIST
36849: PUSH
36850: LD_INT 0
36852: PUSH
36853: LD_INT 1
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PUSH
36860: LD_INT 1
36862: NEG
36863: PUSH
36864: LD_INT 0
36866: PUSH
36867: EMPTY
36868: LIST
36869: LIST
36870: PUSH
36871: LD_INT 1
36873: NEG
36874: PUSH
36875: LD_INT 1
36877: NEG
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 1
36885: PUSH
36886: LD_INT 1
36888: NEG
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 2
36896: PUSH
36897: LD_INT 0
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 2
36906: PUSH
36907: LD_INT 1
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 2
36916: PUSH
36917: LD_INT 2
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 1
36926: PUSH
36927: LD_INT 2
36929: PUSH
36930: EMPTY
36931: LIST
36932: LIST
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: LIST
36938: LIST
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36948: LD_ADDR_VAR 0 50
36952: PUSH
36953: LD_INT 0
36955: PUSH
36956: LD_INT 0
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: PUSH
36963: LD_INT 0
36965: PUSH
36966: LD_INT 1
36968: NEG
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 1
36976: PUSH
36977: LD_INT 0
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 1
36986: PUSH
36987: LD_INT 1
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: LD_INT 0
36996: PUSH
36997: LD_INT 1
36999: PUSH
37000: EMPTY
37001: LIST
37002: LIST
37003: PUSH
37004: LD_INT 1
37006: NEG
37007: PUSH
37008: LD_INT 0
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: LD_INT 1
37017: NEG
37018: PUSH
37019: LD_INT 1
37021: NEG
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 2
37029: PUSH
37030: LD_INT 1
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 2
37039: PUSH
37040: LD_INT 2
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: LD_INT 1
37049: PUSH
37050: LD_INT 2
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 0
37059: PUSH
37060: LD_INT 2
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 1
37069: NEG
37070: PUSH
37071: LD_INT 1
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: LIST
37082: LIST
37083: LIST
37084: LIST
37085: LIST
37086: LIST
37087: LIST
37088: LIST
37089: LIST
37090: LIST
37091: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37092: LD_ADDR_VAR 0 51
37096: PUSH
37097: LD_INT 0
37099: PUSH
37100: LD_INT 0
37102: PUSH
37103: EMPTY
37104: LIST
37105: LIST
37106: PUSH
37107: LD_INT 0
37109: PUSH
37110: LD_INT 1
37112: NEG
37113: PUSH
37114: EMPTY
37115: LIST
37116: LIST
37117: PUSH
37118: LD_INT 1
37120: PUSH
37121: LD_INT 0
37123: PUSH
37124: EMPTY
37125: LIST
37126: LIST
37127: PUSH
37128: LD_INT 1
37130: PUSH
37131: LD_INT 1
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 0
37140: PUSH
37141: LD_INT 1
37143: PUSH
37144: EMPTY
37145: LIST
37146: LIST
37147: PUSH
37148: LD_INT 1
37150: NEG
37151: PUSH
37152: LD_INT 0
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 1
37161: NEG
37162: PUSH
37163: LD_INT 1
37165: NEG
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: PUSH
37174: LD_INT 2
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: LD_INT 2
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 2
37204: NEG
37205: PUSH
37206: LD_INT 0
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 2
37215: NEG
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37239: LD_ADDR_VAR 0 52
37243: PUSH
37244: LD_INT 0
37246: PUSH
37247: LD_INT 0
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 0
37256: PUSH
37257: LD_INT 1
37259: NEG
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: LD_INT 1
37267: PUSH
37268: LD_INT 0
37270: PUSH
37271: EMPTY
37272: LIST
37273: LIST
37274: PUSH
37275: LD_INT 1
37277: PUSH
37278: LD_INT 1
37280: PUSH
37281: EMPTY
37282: LIST
37283: LIST
37284: PUSH
37285: LD_INT 0
37287: PUSH
37288: LD_INT 1
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: LD_INT 1
37297: NEG
37298: PUSH
37299: LD_INT 0
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 1
37308: NEG
37309: PUSH
37310: LD_INT 1
37312: NEG
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: PUSH
37318: LD_INT 1
37320: NEG
37321: PUSH
37322: LD_INT 2
37324: NEG
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 1
37332: NEG
37333: PUSH
37334: LD_INT 1
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: LD_INT 2
37343: NEG
37344: PUSH
37345: LD_INT 0
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: LD_INT 2
37354: NEG
37355: PUSH
37356: LD_INT 1
37358: NEG
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: PUSH
37364: LD_INT 2
37366: NEG
37367: PUSH
37368: LD_INT 2
37370: NEG
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: LIST
37380: LIST
37381: LIST
37382: LIST
37383: LIST
37384: LIST
37385: LIST
37386: LIST
37387: LIST
37388: LIST
37389: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37390: LD_ADDR_VAR 0 53
37394: PUSH
37395: LD_INT 0
37397: PUSH
37398: LD_INT 0
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: LD_INT 0
37407: PUSH
37408: LD_INT 1
37410: NEG
37411: PUSH
37412: EMPTY
37413: LIST
37414: LIST
37415: PUSH
37416: LD_INT 1
37418: PUSH
37419: LD_INT 0
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: PUSH
37426: LD_INT 1
37428: PUSH
37429: LD_INT 1
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 0
37438: PUSH
37439: LD_INT 1
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: PUSH
37446: LD_INT 1
37448: NEG
37449: PUSH
37450: LD_INT 0
37452: PUSH
37453: EMPTY
37454: LIST
37455: LIST
37456: PUSH
37457: LD_INT 1
37459: NEG
37460: PUSH
37461: LD_INT 1
37463: NEG
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: PUSH
37469: LD_INT 1
37471: NEG
37472: PUSH
37473: LD_INT 2
37475: NEG
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 0
37483: PUSH
37484: LD_INT 2
37486: NEG
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: PUSH
37492: LD_INT 1
37494: PUSH
37495: LD_INT 1
37497: NEG
37498: PUSH
37499: EMPTY
37500: LIST
37501: LIST
37502: PUSH
37503: LD_INT 2
37505: PUSH
37506: LD_INT 0
37508: PUSH
37509: EMPTY
37510: LIST
37511: LIST
37512: PUSH
37513: LD_INT 2
37515: PUSH
37516: LD_INT 1
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 2
37525: PUSH
37526: LD_INT 2
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: LD_INT 1
37535: PUSH
37536: LD_INT 2
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: LD_INT 0
37545: PUSH
37546: LD_INT 2
37548: PUSH
37549: EMPTY
37550: LIST
37551: LIST
37552: PUSH
37553: LD_INT 1
37555: NEG
37556: PUSH
37557: LD_INT 1
37559: PUSH
37560: EMPTY
37561: LIST
37562: LIST
37563: PUSH
37564: LD_INT 2
37566: NEG
37567: PUSH
37568: LD_INT 0
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 2
37577: NEG
37578: PUSH
37579: LD_INT 1
37581: NEG
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: LD_INT 2
37589: NEG
37590: PUSH
37591: LD_INT 2
37593: NEG
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: EMPTY
37600: LIST
37601: LIST
37602: LIST
37603: LIST
37604: LIST
37605: LIST
37606: LIST
37607: LIST
37608: LIST
37609: LIST
37610: LIST
37611: LIST
37612: LIST
37613: LIST
37614: LIST
37615: LIST
37616: LIST
37617: LIST
37618: LIST
37619: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37620: LD_ADDR_VAR 0 54
37624: PUSH
37625: LD_INT 0
37627: PUSH
37628: LD_INT 0
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: PUSH
37635: LD_INT 0
37637: PUSH
37638: LD_INT 1
37640: NEG
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PUSH
37646: LD_INT 1
37648: PUSH
37649: LD_INT 0
37651: PUSH
37652: EMPTY
37653: LIST
37654: LIST
37655: PUSH
37656: LD_INT 1
37658: PUSH
37659: LD_INT 1
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: LD_INT 0
37668: PUSH
37669: LD_INT 1
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 1
37678: NEG
37679: PUSH
37680: LD_INT 0
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 1
37689: NEG
37690: PUSH
37691: LD_INT 1
37693: NEG
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 1
37701: NEG
37702: PUSH
37703: LD_INT 2
37705: NEG
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: LD_INT 2
37716: NEG
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 1
37724: PUSH
37725: LD_INT 1
37727: NEG
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: PUSH
37733: LD_INT 2
37735: PUSH
37736: LD_INT 0
37738: PUSH
37739: EMPTY
37740: LIST
37741: LIST
37742: PUSH
37743: LD_INT 2
37745: PUSH
37746: LD_INT 1
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: LD_INT 2
37755: PUSH
37756: LD_INT 2
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 1
37765: PUSH
37766: LD_INT 2
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: PUSH
37773: LD_INT 0
37775: PUSH
37776: LD_INT 2
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PUSH
37783: LD_INT 1
37785: NEG
37786: PUSH
37787: LD_INT 1
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: PUSH
37794: LD_INT 2
37796: NEG
37797: PUSH
37798: LD_INT 0
37800: PUSH
37801: EMPTY
37802: LIST
37803: LIST
37804: PUSH
37805: LD_INT 2
37807: NEG
37808: PUSH
37809: LD_INT 1
37811: NEG
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: LD_INT 2
37819: NEG
37820: PUSH
37821: LD_INT 2
37823: NEG
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: LIST
37833: LIST
37834: LIST
37835: LIST
37836: LIST
37837: LIST
37838: LIST
37839: LIST
37840: LIST
37841: LIST
37842: LIST
37843: LIST
37844: LIST
37845: LIST
37846: LIST
37847: LIST
37848: LIST
37849: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37850: LD_ADDR_VAR 0 55
37854: PUSH
37855: LD_INT 0
37857: PUSH
37858: LD_INT 0
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 0
37867: PUSH
37868: LD_INT 1
37870: NEG
37871: PUSH
37872: EMPTY
37873: LIST
37874: LIST
37875: PUSH
37876: LD_INT 1
37878: PUSH
37879: LD_INT 0
37881: PUSH
37882: EMPTY
37883: LIST
37884: LIST
37885: PUSH
37886: LD_INT 1
37888: PUSH
37889: LD_INT 1
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 0
37898: PUSH
37899: LD_INT 1
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: LD_INT 1
37908: NEG
37909: PUSH
37910: LD_INT 0
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 1
37919: NEG
37920: PUSH
37921: LD_INT 1
37923: NEG
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 1
37931: NEG
37932: PUSH
37933: LD_INT 2
37935: NEG
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: LD_INT 2
37946: NEG
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: PUSH
37955: LD_INT 1
37957: NEG
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 2
37965: PUSH
37966: LD_INT 0
37968: PUSH
37969: EMPTY
37970: LIST
37971: LIST
37972: PUSH
37973: LD_INT 2
37975: PUSH
37976: LD_INT 1
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 2
37985: PUSH
37986: LD_INT 2
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: PUSH
37993: LD_INT 1
37995: PUSH
37996: LD_INT 2
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 0
38005: PUSH
38006: LD_INT 2
38008: PUSH
38009: EMPTY
38010: LIST
38011: LIST
38012: PUSH
38013: LD_INT 1
38015: NEG
38016: PUSH
38017: LD_INT 1
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: PUSH
38024: LD_INT 2
38026: NEG
38027: PUSH
38028: LD_INT 0
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 2
38037: NEG
38038: PUSH
38039: LD_INT 1
38041: NEG
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: PUSH
38047: LD_INT 2
38049: NEG
38050: PUSH
38051: LD_INT 2
38053: NEG
38054: PUSH
38055: EMPTY
38056: LIST
38057: LIST
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: LIST
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38080: LD_ADDR_VAR 0 56
38084: PUSH
38085: LD_INT 0
38087: PUSH
38088: LD_INT 0
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 0
38097: PUSH
38098: LD_INT 1
38100: NEG
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 1
38108: PUSH
38109: LD_INT 0
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: LD_INT 1
38118: PUSH
38119: LD_INT 1
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: PUSH
38126: LD_INT 0
38128: PUSH
38129: LD_INT 1
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 1
38138: NEG
38139: PUSH
38140: LD_INT 0
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: LD_INT 1
38149: NEG
38150: PUSH
38151: LD_INT 1
38153: NEG
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 1
38161: NEG
38162: PUSH
38163: LD_INT 2
38165: NEG
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: LD_INT 2
38176: NEG
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: LD_INT 1
38184: PUSH
38185: LD_INT 1
38187: NEG
38188: PUSH
38189: EMPTY
38190: LIST
38191: LIST
38192: PUSH
38193: LD_INT 2
38195: PUSH
38196: LD_INT 0
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 2
38205: PUSH
38206: LD_INT 1
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: PUSH
38213: LD_INT 2
38215: PUSH
38216: LD_INT 2
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 1
38225: PUSH
38226: LD_INT 2
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: LD_INT 2
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 1
38245: NEG
38246: PUSH
38247: LD_INT 1
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 2
38256: NEG
38257: PUSH
38258: LD_INT 0
38260: PUSH
38261: EMPTY
38262: LIST
38263: LIST
38264: PUSH
38265: LD_INT 2
38267: NEG
38268: PUSH
38269: LD_INT 1
38271: NEG
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 2
38279: NEG
38280: PUSH
38281: LD_INT 2
38283: NEG
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: LIST
38293: LIST
38294: LIST
38295: LIST
38296: LIST
38297: LIST
38298: LIST
38299: LIST
38300: LIST
38301: LIST
38302: LIST
38303: LIST
38304: LIST
38305: LIST
38306: LIST
38307: LIST
38308: LIST
38309: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38310: LD_ADDR_VAR 0 57
38314: PUSH
38315: LD_INT 0
38317: PUSH
38318: LD_INT 0
38320: PUSH
38321: EMPTY
38322: LIST
38323: LIST
38324: PUSH
38325: LD_INT 0
38327: PUSH
38328: LD_INT 1
38330: NEG
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 1
38338: PUSH
38339: LD_INT 0
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: LD_INT 1
38348: PUSH
38349: LD_INT 1
38351: PUSH
38352: EMPTY
38353: LIST
38354: LIST
38355: PUSH
38356: LD_INT 0
38358: PUSH
38359: LD_INT 1
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 1
38368: NEG
38369: PUSH
38370: LD_INT 0
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 1
38379: NEG
38380: PUSH
38381: LD_INT 1
38383: NEG
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 1
38391: NEG
38392: PUSH
38393: LD_INT 2
38395: NEG
38396: PUSH
38397: EMPTY
38398: LIST
38399: LIST
38400: PUSH
38401: LD_INT 0
38403: PUSH
38404: LD_INT 2
38406: NEG
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: PUSH
38412: LD_INT 1
38414: PUSH
38415: LD_INT 1
38417: NEG
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: LD_INT 2
38425: PUSH
38426: LD_INT 0
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 2
38435: PUSH
38436: LD_INT 1
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: LD_INT 2
38445: PUSH
38446: LD_INT 2
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 1
38455: PUSH
38456: LD_INT 2
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 0
38465: PUSH
38466: LD_INT 2
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: PUSH
38473: LD_INT 1
38475: NEG
38476: PUSH
38477: LD_INT 1
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: LD_INT 2
38486: NEG
38487: PUSH
38488: LD_INT 0
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 2
38497: NEG
38498: PUSH
38499: LD_INT 1
38501: NEG
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 2
38509: NEG
38510: PUSH
38511: LD_INT 2
38513: NEG
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: LIST
38525: LIST
38526: LIST
38527: LIST
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38540: LD_ADDR_VAR 0 58
38544: PUSH
38545: LD_INT 0
38547: PUSH
38548: LD_INT 0
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: LD_INT 1
38560: NEG
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 1
38568: PUSH
38569: LD_INT 0
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: PUSH
38579: LD_INT 1
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: LD_INT 1
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 1
38598: NEG
38599: PUSH
38600: LD_INT 0
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 1
38609: NEG
38610: PUSH
38611: LD_INT 1
38613: NEG
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: PUSH
38619: LD_INT 1
38621: NEG
38622: PUSH
38623: LD_INT 2
38625: NEG
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: PUSH
38631: LD_INT 0
38633: PUSH
38634: LD_INT 2
38636: NEG
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: LD_INT 1
38644: PUSH
38645: LD_INT 1
38647: NEG
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PUSH
38653: LD_INT 2
38655: PUSH
38656: LD_INT 0
38658: PUSH
38659: EMPTY
38660: LIST
38661: LIST
38662: PUSH
38663: LD_INT 2
38665: PUSH
38666: LD_INT 1
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PUSH
38673: LD_INT 2
38675: PUSH
38676: LD_INT 2
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 1
38685: PUSH
38686: LD_INT 2
38688: PUSH
38689: EMPTY
38690: LIST
38691: LIST
38692: PUSH
38693: LD_INT 0
38695: PUSH
38696: LD_INT 2
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: LD_INT 1
38705: NEG
38706: PUSH
38707: LD_INT 1
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 2
38716: NEG
38717: PUSH
38718: LD_INT 0
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 2
38727: NEG
38728: PUSH
38729: LD_INT 1
38731: NEG
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 2
38739: NEG
38740: PUSH
38741: LD_INT 2
38743: NEG
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: LIST
38760: LIST
38761: LIST
38762: LIST
38763: LIST
38764: LIST
38765: LIST
38766: LIST
38767: LIST
38768: LIST
38769: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38770: LD_ADDR_VAR 0 59
38774: PUSH
38775: LD_INT 0
38777: PUSH
38778: LD_INT 0
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: PUSH
38785: LD_INT 0
38787: PUSH
38788: LD_INT 1
38790: NEG
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: PUSH
38796: LD_INT 1
38798: PUSH
38799: LD_INT 0
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 1
38808: PUSH
38809: LD_INT 1
38811: PUSH
38812: EMPTY
38813: LIST
38814: LIST
38815: PUSH
38816: LD_INT 0
38818: PUSH
38819: LD_INT 1
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: PUSH
38826: LD_INT 1
38828: NEG
38829: PUSH
38830: LD_INT 0
38832: PUSH
38833: EMPTY
38834: LIST
38835: LIST
38836: PUSH
38837: LD_INT 1
38839: NEG
38840: PUSH
38841: LD_INT 1
38843: NEG
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PUSH
38849: EMPTY
38850: LIST
38851: LIST
38852: LIST
38853: LIST
38854: LIST
38855: LIST
38856: LIST
38857: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38858: LD_ADDR_VAR 0 60
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: LD_INT 0
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PUSH
38873: LD_INT 0
38875: PUSH
38876: LD_INT 1
38878: NEG
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: PUSH
38887: LD_INT 0
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 1
38896: PUSH
38897: LD_INT 1
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PUSH
38904: LD_INT 0
38906: PUSH
38907: LD_INT 1
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 1
38916: NEG
38917: PUSH
38918: LD_INT 0
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 1
38927: NEG
38928: PUSH
38929: LD_INT 1
38931: NEG
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: LIST
38941: LIST
38942: LIST
38943: LIST
38944: LIST
38945: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38946: LD_ADDR_VAR 0 61
38950: PUSH
38951: LD_INT 0
38953: PUSH
38954: LD_INT 0
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: PUSH
38961: LD_INT 0
38963: PUSH
38964: LD_INT 1
38966: NEG
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 1
38974: PUSH
38975: LD_INT 0
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: LD_INT 1
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 1
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 0
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 1
39015: NEG
39016: PUSH
39017: LD_INT 1
39019: NEG
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: LIST
39029: LIST
39030: LIST
39031: LIST
39032: LIST
39033: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39034: LD_ADDR_VAR 0 62
39038: PUSH
39039: LD_INT 0
39041: PUSH
39042: LD_INT 0
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: LD_INT 0
39051: PUSH
39052: LD_INT 1
39054: NEG
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 1
39062: PUSH
39063: LD_INT 0
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: LD_INT 1
39072: PUSH
39073: LD_INT 1
39075: PUSH
39076: EMPTY
39077: LIST
39078: LIST
39079: PUSH
39080: LD_INT 0
39082: PUSH
39083: LD_INT 1
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 1
39092: NEG
39093: PUSH
39094: LD_INT 0
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 1
39103: NEG
39104: PUSH
39105: LD_INT 1
39107: NEG
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: EMPTY
39114: LIST
39115: LIST
39116: LIST
39117: LIST
39118: LIST
39119: LIST
39120: LIST
39121: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39122: LD_ADDR_VAR 0 63
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: LD_INT 0
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 0
39139: PUSH
39140: LD_INT 1
39142: NEG
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 1
39150: PUSH
39151: LD_INT 0
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: PUSH
39158: LD_INT 1
39160: PUSH
39161: LD_INT 1
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 0
39170: PUSH
39171: LD_INT 1
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 1
39180: NEG
39181: PUSH
39182: LD_INT 0
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 1
39191: NEG
39192: PUSH
39193: LD_INT 1
39195: NEG
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: LIST
39205: LIST
39206: LIST
39207: LIST
39208: LIST
39209: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39210: LD_ADDR_VAR 0 64
39214: PUSH
39215: LD_INT 0
39217: PUSH
39218: LD_INT 0
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 0
39227: PUSH
39228: LD_INT 1
39230: NEG
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 1
39238: PUSH
39239: LD_INT 0
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 1
39248: PUSH
39249: LD_INT 1
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 0
39258: PUSH
39259: LD_INT 1
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 1
39268: NEG
39269: PUSH
39270: LD_INT 0
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 1
39279: NEG
39280: PUSH
39281: LD_INT 1
39283: NEG
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: ST_TO_ADDR
// end ; 1 :
39298: GO 45195
39300: LD_INT 1
39302: DOUBLE
39303: EQUAL
39304: IFTRUE 39308
39306: GO 41931
39308: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39309: LD_ADDR_VAR 0 11
39313: PUSH
39314: LD_INT 1
39316: NEG
39317: PUSH
39318: LD_INT 3
39320: NEG
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: PUSH
39326: LD_INT 0
39328: PUSH
39329: LD_INT 3
39331: NEG
39332: PUSH
39333: EMPTY
39334: LIST
39335: LIST
39336: PUSH
39337: LD_INT 1
39339: PUSH
39340: LD_INT 2
39342: NEG
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: LIST
39352: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39353: LD_ADDR_VAR 0 12
39357: PUSH
39358: LD_INT 2
39360: PUSH
39361: LD_INT 1
39363: NEG
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: LD_INT 3
39371: PUSH
39372: LD_INT 0
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 3
39381: PUSH
39382: LD_INT 1
39384: PUSH
39385: EMPTY
39386: LIST
39387: LIST
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: LIST
39393: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39394: LD_ADDR_VAR 0 13
39398: PUSH
39399: LD_INT 3
39401: PUSH
39402: LD_INT 2
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: PUSH
39409: LD_INT 3
39411: PUSH
39412: LD_INT 3
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 2
39421: PUSH
39422: LD_INT 3
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: LIST
39433: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39434: LD_ADDR_VAR 0 14
39438: PUSH
39439: LD_INT 1
39441: PUSH
39442: LD_INT 3
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 0
39451: PUSH
39452: LD_INT 3
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: LD_INT 1
39461: NEG
39462: PUSH
39463: LD_INT 2
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: LIST
39474: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39475: LD_ADDR_VAR 0 15
39479: PUSH
39480: LD_INT 2
39482: NEG
39483: PUSH
39484: LD_INT 1
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: LD_INT 3
39493: NEG
39494: PUSH
39495: LD_INT 0
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 3
39504: NEG
39505: PUSH
39506: LD_INT 1
39508: NEG
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: LIST
39518: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39519: LD_ADDR_VAR 0 16
39523: PUSH
39524: LD_INT 2
39526: NEG
39527: PUSH
39528: LD_INT 3
39530: NEG
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 3
39538: NEG
39539: PUSH
39540: LD_INT 2
39542: NEG
39543: PUSH
39544: EMPTY
39545: LIST
39546: LIST
39547: PUSH
39548: LD_INT 3
39550: NEG
39551: PUSH
39552: LD_INT 3
39554: NEG
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: LIST
39564: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39565: LD_ADDR_VAR 0 17
39569: PUSH
39570: LD_INT 1
39572: NEG
39573: PUSH
39574: LD_INT 3
39576: NEG
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 0
39584: PUSH
39585: LD_INT 3
39587: NEG
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 1
39595: PUSH
39596: LD_INT 2
39598: NEG
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: LIST
39608: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39609: LD_ADDR_VAR 0 18
39613: PUSH
39614: LD_INT 2
39616: PUSH
39617: LD_INT 1
39619: NEG
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 3
39627: PUSH
39628: LD_INT 0
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 3
39637: PUSH
39638: LD_INT 1
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: LIST
39649: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39650: LD_ADDR_VAR 0 19
39654: PUSH
39655: LD_INT 3
39657: PUSH
39658: LD_INT 2
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 3
39667: PUSH
39668: LD_INT 3
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 2
39677: PUSH
39678: LD_INT 3
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: LIST
39689: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39690: LD_ADDR_VAR 0 20
39694: PUSH
39695: LD_INT 1
39697: PUSH
39698: LD_INT 3
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 0
39707: PUSH
39708: LD_INT 3
39710: PUSH
39711: EMPTY
39712: LIST
39713: LIST
39714: PUSH
39715: LD_INT 1
39717: NEG
39718: PUSH
39719: LD_INT 2
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: LIST
39730: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39731: LD_ADDR_VAR 0 21
39735: PUSH
39736: LD_INT 2
39738: NEG
39739: PUSH
39740: LD_INT 1
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 3
39749: NEG
39750: PUSH
39751: LD_INT 0
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 3
39760: NEG
39761: PUSH
39762: LD_INT 1
39764: NEG
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: LIST
39774: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39775: LD_ADDR_VAR 0 22
39779: PUSH
39780: LD_INT 2
39782: NEG
39783: PUSH
39784: LD_INT 3
39786: NEG
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 3
39794: NEG
39795: PUSH
39796: LD_INT 2
39798: NEG
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 3
39806: NEG
39807: PUSH
39808: LD_INT 3
39810: NEG
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: LIST
39820: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39821: LD_ADDR_VAR 0 23
39825: PUSH
39826: LD_INT 0
39828: PUSH
39829: LD_INT 3
39831: NEG
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: LD_INT 4
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 1
39851: PUSH
39852: LD_INT 3
39854: NEG
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: LIST
39864: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39865: LD_ADDR_VAR 0 24
39869: PUSH
39870: LD_INT 3
39872: PUSH
39873: LD_INT 0
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: LD_INT 3
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 4
39893: PUSH
39894: LD_INT 1
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: EMPTY
39902: LIST
39903: LIST
39904: LIST
39905: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39906: LD_ADDR_VAR 0 25
39910: PUSH
39911: LD_INT 3
39913: PUSH
39914: LD_INT 3
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: LD_INT 4
39923: PUSH
39924: LD_INT 3
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: LD_INT 3
39933: PUSH
39934: LD_INT 4
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: LIST
39945: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39946: LD_ADDR_VAR 0 26
39950: PUSH
39951: LD_INT 0
39953: PUSH
39954: LD_INT 3
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 1
39963: PUSH
39964: LD_INT 4
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 1
39973: NEG
39974: PUSH
39975: LD_INT 3
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: LIST
39986: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39987: LD_ADDR_VAR 0 27
39991: PUSH
39992: LD_INT 3
39994: NEG
39995: PUSH
39996: LD_INT 0
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 3
40005: NEG
40006: PUSH
40007: LD_INT 1
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: LD_INT 4
40016: NEG
40017: PUSH
40018: LD_INT 1
40020: NEG
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: LIST
40030: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40031: LD_ADDR_VAR 0 28
40035: PUSH
40036: LD_INT 3
40038: NEG
40039: PUSH
40040: LD_INT 3
40042: NEG
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 3
40050: NEG
40051: PUSH
40052: LD_INT 4
40054: NEG
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 4
40062: NEG
40063: PUSH
40064: LD_INT 3
40066: NEG
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: LIST
40076: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40077: LD_ADDR_VAR 0 29
40081: PUSH
40082: LD_INT 1
40084: NEG
40085: PUSH
40086: LD_INT 3
40088: NEG
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 0
40096: PUSH
40097: LD_INT 3
40099: NEG
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 1
40107: PUSH
40108: LD_INT 2
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: LD_INT 4
40122: NEG
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 0
40130: PUSH
40131: LD_INT 4
40133: NEG
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: PUSH
40139: LD_INT 1
40141: PUSH
40142: LD_INT 3
40144: NEG
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 1
40152: NEG
40153: PUSH
40154: LD_INT 5
40156: NEG
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: LD_INT 5
40167: NEG
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: LD_INT 1
40175: PUSH
40176: LD_INT 4
40178: NEG
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: PUSH
40184: LD_INT 1
40186: NEG
40187: PUSH
40188: LD_INT 6
40190: NEG
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 0
40198: PUSH
40199: LD_INT 6
40201: NEG
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 1
40209: PUSH
40210: LD_INT 5
40212: NEG
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: LIST
40222: LIST
40223: LIST
40224: LIST
40225: LIST
40226: LIST
40227: LIST
40228: LIST
40229: LIST
40230: LIST
40231: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40232: LD_ADDR_VAR 0 30
40236: PUSH
40237: LD_INT 2
40239: PUSH
40240: LD_INT 1
40242: NEG
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 3
40250: PUSH
40251: LD_INT 0
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: LD_INT 3
40260: PUSH
40261: LD_INT 1
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: LD_INT 3
40270: PUSH
40271: LD_INT 1
40273: NEG
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: PUSH
40279: LD_INT 4
40281: PUSH
40282: LD_INT 0
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 4
40291: PUSH
40292: LD_INT 1
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: LD_INT 4
40301: PUSH
40302: LD_INT 1
40304: NEG
40305: PUSH
40306: EMPTY
40307: LIST
40308: LIST
40309: PUSH
40310: LD_INT 5
40312: PUSH
40313: LD_INT 0
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 5
40322: PUSH
40323: LD_INT 1
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: LD_INT 5
40332: PUSH
40333: LD_INT 1
40335: NEG
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: LD_INT 6
40343: PUSH
40344: LD_INT 0
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 6
40353: PUSH
40354: LD_INT 1
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: LIST
40367: LIST
40368: LIST
40369: LIST
40370: LIST
40371: LIST
40372: LIST
40373: LIST
40374: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40375: LD_ADDR_VAR 0 31
40379: PUSH
40380: LD_INT 3
40382: PUSH
40383: LD_INT 2
40385: PUSH
40386: EMPTY
40387: LIST
40388: LIST
40389: PUSH
40390: LD_INT 3
40392: PUSH
40393: LD_INT 3
40395: PUSH
40396: EMPTY
40397: LIST
40398: LIST
40399: PUSH
40400: LD_INT 2
40402: PUSH
40403: LD_INT 3
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 4
40412: PUSH
40413: LD_INT 3
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: PUSH
40420: LD_INT 4
40422: PUSH
40423: LD_INT 4
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 3
40432: PUSH
40433: LD_INT 4
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 5
40442: PUSH
40443: LD_INT 4
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: LD_INT 5
40452: PUSH
40453: LD_INT 5
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: LD_INT 4
40462: PUSH
40463: LD_INT 5
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: LD_INT 6
40472: PUSH
40473: LD_INT 5
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 6
40482: PUSH
40483: LD_INT 6
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 5
40492: PUSH
40493: LD_INT 6
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: LIST
40504: LIST
40505: LIST
40506: LIST
40507: LIST
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: LIST
40513: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40514: LD_ADDR_VAR 0 32
40518: PUSH
40519: LD_INT 1
40521: PUSH
40522: LD_INT 3
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: LD_INT 0
40531: PUSH
40532: LD_INT 3
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: NEG
40542: PUSH
40543: LD_INT 2
40545: PUSH
40546: EMPTY
40547: LIST
40548: LIST
40549: PUSH
40550: LD_INT 1
40552: PUSH
40553: LD_INT 4
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 0
40562: PUSH
40563: LD_INT 4
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 1
40572: NEG
40573: PUSH
40574: LD_INT 3
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 1
40583: PUSH
40584: LD_INT 5
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 0
40593: PUSH
40594: LD_INT 5
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: LD_INT 1
40603: NEG
40604: PUSH
40605: LD_INT 4
40607: PUSH
40608: EMPTY
40609: LIST
40610: LIST
40611: PUSH
40612: LD_INT 1
40614: PUSH
40615: LD_INT 6
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 0
40624: PUSH
40625: LD_INT 6
40627: PUSH
40628: EMPTY
40629: LIST
40630: LIST
40631: PUSH
40632: LD_INT 1
40634: NEG
40635: PUSH
40636: LD_INT 5
40638: PUSH
40639: EMPTY
40640: LIST
40641: LIST
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: LIST
40647: LIST
40648: LIST
40649: LIST
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: LIST
40656: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40657: LD_ADDR_VAR 0 33
40661: PUSH
40662: LD_INT 2
40664: NEG
40665: PUSH
40666: LD_INT 1
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 3
40675: NEG
40676: PUSH
40677: LD_INT 0
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 3
40686: NEG
40687: PUSH
40688: LD_INT 1
40690: NEG
40691: PUSH
40692: EMPTY
40693: LIST
40694: LIST
40695: PUSH
40696: LD_INT 3
40698: NEG
40699: PUSH
40700: LD_INT 1
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 4
40709: NEG
40710: PUSH
40711: LD_INT 0
40713: PUSH
40714: EMPTY
40715: LIST
40716: LIST
40717: PUSH
40718: LD_INT 4
40720: NEG
40721: PUSH
40722: LD_INT 1
40724: NEG
40725: PUSH
40726: EMPTY
40727: LIST
40728: LIST
40729: PUSH
40730: LD_INT 4
40732: NEG
40733: PUSH
40734: LD_INT 1
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: PUSH
40741: LD_INT 5
40743: NEG
40744: PUSH
40745: LD_INT 0
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 5
40754: NEG
40755: PUSH
40756: LD_INT 1
40758: NEG
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 5
40766: NEG
40767: PUSH
40768: LD_INT 1
40770: PUSH
40771: EMPTY
40772: LIST
40773: LIST
40774: PUSH
40775: LD_INT 6
40777: NEG
40778: PUSH
40779: LD_INT 0
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 6
40788: NEG
40789: PUSH
40790: LD_INT 1
40792: NEG
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: LIST
40802: LIST
40803: LIST
40804: LIST
40805: LIST
40806: LIST
40807: LIST
40808: LIST
40809: LIST
40810: LIST
40811: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40812: LD_ADDR_VAR 0 34
40816: PUSH
40817: LD_INT 2
40819: NEG
40820: PUSH
40821: LD_INT 3
40823: NEG
40824: PUSH
40825: EMPTY
40826: LIST
40827: LIST
40828: PUSH
40829: LD_INT 3
40831: NEG
40832: PUSH
40833: LD_INT 2
40835: NEG
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: PUSH
40841: LD_INT 3
40843: NEG
40844: PUSH
40845: LD_INT 3
40847: NEG
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: PUSH
40853: LD_INT 3
40855: NEG
40856: PUSH
40857: LD_INT 4
40859: NEG
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: LD_INT 4
40867: NEG
40868: PUSH
40869: LD_INT 3
40871: NEG
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: LD_INT 4
40879: NEG
40880: PUSH
40881: LD_INT 4
40883: NEG
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 4
40891: NEG
40892: PUSH
40893: LD_INT 5
40895: NEG
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: PUSH
40901: LD_INT 5
40903: NEG
40904: PUSH
40905: LD_INT 4
40907: NEG
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 5
40915: NEG
40916: PUSH
40917: LD_INT 5
40919: NEG
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: LD_INT 5
40927: NEG
40928: PUSH
40929: LD_INT 6
40931: NEG
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 6
40939: NEG
40940: PUSH
40941: LD_INT 5
40943: NEG
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 6
40951: NEG
40952: PUSH
40953: LD_INT 6
40955: NEG
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: LIST
40965: LIST
40966: LIST
40967: LIST
40968: LIST
40969: LIST
40970: LIST
40971: LIST
40972: LIST
40973: LIST
40974: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40975: LD_ADDR_VAR 0 41
40979: PUSH
40980: LD_INT 0
40982: PUSH
40983: LD_INT 2
40985: NEG
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 1
40993: NEG
40994: PUSH
40995: LD_INT 3
40997: NEG
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: PUSH
41003: LD_INT 1
41005: PUSH
41006: LD_INT 2
41008: NEG
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PUSH
41014: EMPTY
41015: LIST
41016: LIST
41017: LIST
41018: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41019: LD_ADDR_VAR 0 42
41023: PUSH
41024: LD_INT 2
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: PUSH
41034: LD_INT 2
41036: PUSH
41037: LD_INT 1
41039: NEG
41040: PUSH
41041: EMPTY
41042: LIST
41043: LIST
41044: PUSH
41045: LD_INT 3
41047: PUSH
41048: LD_INT 1
41050: PUSH
41051: EMPTY
41052: LIST
41053: LIST
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: LIST
41059: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41060: LD_ADDR_VAR 0 43
41064: PUSH
41065: LD_INT 2
41067: PUSH
41068: LD_INT 2
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: PUSH
41075: LD_INT 3
41077: PUSH
41078: LD_INT 2
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PUSH
41085: LD_INT 2
41087: PUSH
41088: LD_INT 3
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: LIST
41099: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41100: LD_ADDR_VAR 0 44
41104: PUSH
41105: LD_INT 0
41107: PUSH
41108: LD_INT 2
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: LD_INT 1
41117: PUSH
41118: LD_INT 3
41120: PUSH
41121: EMPTY
41122: LIST
41123: LIST
41124: PUSH
41125: LD_INT 1
41127: NEG
41128: PUSH
41129: LD_INT 2
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: LIST
41140: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41141: LD_ADDR_VAR 0 45
41145: PUSH
41146: LD_INT 2
41148: NEG
41149: PUSH
41150: LD_INT 0
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: PUSH
41157: LD_INT 2
41159: NEG
41160: PUSH
41161: LD_INT 1
41163: PUSH
41164: EMPTY
41165: LIST
41166: LIST
41167: PUSH
41168: LD_INT 3
41170: NEG
41171: PUSH
41172: LD_INT 1
41174: NEG
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: LIST
41184: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41185: LD_ADDR_VAR 0 46
41189: PUSH
41190: LD_INT 2
41192: NEG
41193: PUSH
41194: LD_INT 2
41196: NEG
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 2
41204: NEG
41205: PUSH
41206: LD_INT 3
41208: NEG
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PUSH
41214: LD_INT 3
41216: NEG
41217: PUSH
41218: LD_INT 2
41220: NEG
41221: PUSH
41222: EMPTY
41223: LIST
41224: LIST
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: LIST
41230: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41231: LD_ADDR_VAR 0 47
41235: PUSH
41236: LD_INT 2
41238: NEG
41239: PUSH
41240: LD_INT 3
41242: NEG
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: PUSH
41248: LD_INT 1
41250: NEG
41251: PUSH
41252: LD_INT 3
41254: NEG
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41264: LD_ADDR_VAR 0 48
41268: PUSH
41269: LD_INT 1
41271: PUSH
41272: LD_INT 2
41274: NEG
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 2
41282: PUSH
41283: LD_INT 1
41285: NEG
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41295: LD_ADDR_VAR 0 49
41299: PUSH
41300: LD_INT 3
41302: PUSH
41303: LD_INT 1
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 3
41312: PUSH
41313: LD_INT 2
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41324: LD_ADDR_VAR 0 50
41328: PUSH
41329: LD_INT 2
41331: PUSH
41332: LD_INT 3
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 1
41341: PUSH
41342: LD_INT 3
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41353: LD_ADDR_VAR 0 51
41357: PUSH
41358: LD_INT 1
41360: NEG
41361: PUSH
41362: LD_INT 2
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 2
41371: NEG
41372: PUSH
41373: LD_INT 1
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41384: LD_ADDR_VAR 0 52
41388: PUSH
41389: LD_INT 3
41391: NEG
41392: PUSH
41393: LD_INT 1
41395: NEG
41396: PUSH
41397: EMPTY
41398: LIST
41399: LIST
41400: PUSH
41401: LD_INT 3
41403: NEG
41404: PUSH
41405: LD_INT 2
41407: NEG
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41417: LD_ADDR_VAR 0 53
41421: PUSH
41422: LD_INT 1
41424: NEG
41425: PUSH
41426: LD_INT 3
41428: NEG
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 0
41436: PUSH
41437: LD_INT 3
41439: NEG
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: PUSH
41445: LD_INT 1
41447: PUSH
41448: LD_INT 2
41450: NEG
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: LIST
41460: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41461: LD_ADDR_VAR 0 54
41465: PUSH
41466: LD_INT 2
41468: PUSH
41469: LD_INT 1
41471: NEG
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: PUSH
41477: LD_INT 3
41479: PUSH
41480: LD_INT 0
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 3
41489: PUSH
41490: LD_INT 1
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: LIST
41501: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41502: LD_ADDR_VAR 0 55
41506: PUSH
41507: LD_INT 3
41509: PUSH
41510: LD_INT 2
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PUSH
41517: LD_INT 3
41519: PUSH
41520: LD_INT 3
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 2
41529: PUSH
41530: LD_INT 3
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: LIST
41541: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41542: LD_ADDR_VAR 0 56
41546: PUSH
41547: LD_INT 1
41549: PUSH
41550: LD_INT 3
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 0
41559: PUSH
41560: LD_INT 3
41562: PUSH
41563: EMPTY
41564: LIST
41565: LIST
41566: PUSH
41567: LD_INT 1
41569: NEG
41570: PUSH
41571: LD_INT 2
41573: PUSH
41574: EMPTY
41575: LIST
41576: LIST
41577: PUSH
41578: EMPTY
41579: LIST
41580: LIST
41581: LIST
41582: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41583: LD_ADDR_VAR 0 57
41587: PUSH
41588: LD_INT 2
41590: NEG
41591: PUSH
41592: LD_INT 1
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 3
41601: NEG
41602: PUSH
41603: LD_INT 0
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 3
41612: NEG
41613: PUSH
41614: LD_INT 1
41616: NEG
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: LIST
41626: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41627: LD_ADDR_VAR 0 58
41631: PUSH
41632: LD_INT 2
41634: NEG
41635: PUSH
41636: LD_INT 3
41638: NEG
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: LD_INT 3
41646: NEG
41647: PUSH
41648: LD_INT 2
41650: NEG
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 3
41658: NEG
41659: PUSH
41660: LD_INT 3
41662: NEG
41663: PUSH
41664: EMPTY
41665: LIST
41666: LIST
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: LIST
41672: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41673: LD_ADDR_VAR 0 59
41677: PUSH
41678: LD_INT 1
41680: NEG
41681: PUSH
41682: LD_INT 2
41684: NEG
41685: PUSH
41686: EMPTY
41687: LIST
41688: LIST
41689: PUSH
41690: LD_INT 0
41692: PUSH
41693: LD_INT 2
41695: NEG
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: LD_INT 1
41703: PUSH
41704: LD_INT 1
41706: NEG
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: LIST
41716: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41717: LD_ADDR_VAR 0 60
41721: PUSH
41722: LD_INT 1
41724: PUSH
41725: LD_INT 1
41727: NEG
41728: PUSH
41729: EMPTY
41730: LIST
41731: LIST
41732: PUSH
41733: LD_INT 2
41735: PUSH
41736: LD_INT 0
41738: PUSH
41739: EMPTY
41740: LIST
41741: LIST
41742: PUSH
41743: LD_INT 2
41745: PUSH
41746: LD_INT 1
41748: PUSH
41749: EMPTY
41750: LIST
41751: LIST
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: LIST
41757: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41758: LD_ADDR_VAR 0 61
41762: PUSH
41763: LD_INT 2
41765: PUSH
41766: LD_INT 1
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: PUSH
41773: LD_INT 2
41775: PUSH
41776: LD_INT 2
41778: PUSH
41779: EMPTY
41780: LIST
41781: LIST
41782: PUSH
41783: LD_INT 1
41785: PUSH
41786: LD_INT 2
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: LIST
41797: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41798: LD_ADDR_VAR 0 62
41802: PUSH
41803: LD_INT 1
41805: PUSH
41806: LD_INT 2
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: PUSH
41813: LD_INT 0
41815: PUSH
41816: LD_INT 2
41818: PUSH
41819: EMPTY
41820: LIST
41821: LIST
41822: PUSH
41823: LD_INT 1
41825: NEG
41826: PUSH
41827: LD_INT 1
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: LIST
41838: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41839: LD_ADDR_VAR 0 63
41843: PUSH
41844: LD_INT 1
41846: NEG
41847: PUSH
41848: LD_INT 1
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: PUSH
41855: LD_INT 2
41857: NEG
41858: PUSH
41859: LD_INT 0
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: PUSH
41866: LD_INT 2
41868: NEG
41869: PUSH
41870: LD_INT 1
41872: NEG
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: EMPTY
41879: LIST
41880: LIST
41881: LIST
41882: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41883: LD_ADDR_VAR 0 64
41887: PUSH
41888: LD_INT 1
41890: NEG
41891: PUSH
41892: LD_INT 2
41894: NEG
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PUSH
41900: LD_INT 2
41902: NEG
41903: PUSH
41904: LD_INT 1
41906: NEG
41907: PUSH
41908: EMPTY
41909: LIST
41910: LIST
41911: PUSH
41912: LD_INT 2
41914: NEG
41915: PUSH
41916: LD_INT 2
41918: NEG
41919: PUSH
41920: EMPTY
41921: LIST
41922: LIST
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: LIST
41928: ST_TO_ADDR
// end ; 2 :
41929: GO 45195
41931: LD_INT 2
41933: DOUBLE
41934: EQUAL
41935: IFTRUE 41939
41937: GO 45194
41939: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41940: LD_ADDR_VAR 0 29
41944: PUSH
41945: LD_INT 4
41947: PUSH
41948: LD_INT 0
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: LD_INT 4
41957: PUSH
41958: LD_INT 1
41960: NEG
41961: PUSH
41962: EMPTY
41963: LIST
41964: LIST
41965: PUSH
41966: LD_INT 5
41968: PUSH
41969: LD_INT 0
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PUSH
41976: LD_INT 5
41978: PUSH
41979: LD_INT 1
41981: PUSH
41982: EMPTY
41983: LIST
41984: LIST
41985: PUSH
41986: LD_INT 4
41988: PUSH
41989: LD_INT 1
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 3
41998: PUSH
41999: LD_INT 0
42001: PUSH
42002: EMPTY
42003: LIST
42004: LIST
42005: PUSH
42006: LD_INT 3
42008: PUSH
42009: LD_INT 1
42011: NEG
42012: PUSH
42013: EMPTY
42014: LIST
42015: LIST
42016: PUSH
42017: LD_INT 3
42019: PUSH
42020: LD_INT 2
42022: NEG
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: LD_INT 5
42030: PUSH
42031: LD_INT 2
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: LD_INT 3
42040: PUSH
42041: LD_INT 3
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: LD_INT 3
42050: PUSH
42051: LD_INT 2
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: PUSH
42058: LD_INT 4
42060: PUSH
42061: LD_INT 3
42063: PUSH
42064: EMPTY
42065: LIST
42066: LIST
42067: PUSH
42068: LD_INT 4
42070: PUSH
42071: LD_INT 4
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: PUSH
42078: LD_INT 3
42080: PUSH
42081: LD_INT 4
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: PUSH
42088: LD_INT 2
42090: PUSH
42091: LD_INT 3
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 2
42100: PUSH
42101: LD_INT 2
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 4
42110: PUSH
42111: LD_INT 2
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 2
42120: PUSH
42121: LD_INT 4
42123: PUSH
42124: EMPTY
42125: LIST
42126: LIST
42127: PUSH
42128: LD_INT 0
42130: PUSH
42131: LD_INT 4
42133: PUSH
42134: EMPTY
42135: LIST
42136: LIST
42137: PUSH
42138: LD_INT 0
42140: PUSH
42141: LD_INT 3
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 1
42150: PUSH
42151: LD_INT 4
42153: PUSH
42154: EMPTY
42155: LIST
42156: LIST
42157: PUSH
42158: LD_INT 1
42160: PUSH
42161: LD_INT 5
42163: PUSH
42164: EMPTY
42165: LIST
42166: LIST
42167: PUSH
42168: LD_INT 0
42170: PUSH
42171: LD_INT 5
42173: PUSH
42174: EMPTY
42175: LIST
42176: LIST
42177: PUSH
42178: LD_INT 1
42180: NEG
42181: PUSH
42182: LD_INT 4
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: LD_INT 1
42191: NEG
42192: PUSH
42193: LD_INT 3
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 2
42202: PUSH
42203: LD_INT 5
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: LD_INT 2
42212: NEG
42213: PUSH
42214: LD_INT 3
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 3
42223: NEG
42224: PUSH
42225: LD_INT 0
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PUSH
42232: LD_INT 3
42234: NEG
42235: PUSH
42236: LD_INT 1
42238: NEG
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: LD_INT 2
42246: NEG
42247: PUSH
42248: LD_INT 0
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: PUSH
42255: LD_INT 2
42257: NEG
42258: PUSH
42259: LD_INT 1
42261: PUSH
42262: EMPTY
42263: LIST
42264: LIST
42265: PUSH
42266: LD_INT 3
42268: NEG
42269: PUSH
42270: LD_INT 1
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: LD_INT 4
42279: NEG
42280: PUSH
42281: LD_INT 0
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: LD_INT 4
42290: NEG
42291: PUSH
42292: LD_INT 1
42294: NEG
42295: PUSH
42296: EMPTY
42297: LIST
42298: LIST
42299: PUSH
42300: LD_INT 4
42302: NEG
42303: PUSH
42304: LD_INT 2
42306: NEG
42307: PUSH
42308: EMPTY
42309: LIST
42310: LIST
42311: PUSH
42312: LD_INT 2
42314: NEG
42315: PUSH
42316: LD_INT 2
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: LD_INT 4
42325: NEG
42326: PUSH
42327: LD_INT 4
42329: NEG
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 4
42337: NEG
42338: PUSH
42339: LD_INT 5
42341: NEG
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 3
42349: NEG
42350: PUSH
42351: LD_INT 4
42353: NEG
42354: PUSH
42355: EMPTY
42356: LIST
42357: LIST
42358: PUSH
42359: LD_INT 3
42361: NEG
42362: PUSH
42363: LD_INT 3
42365: NEG
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: LD_INT 4
42373: NEG
42374: PUSH
42375: LD_INT 3
42377: NEG
42378: PUSH
42379: EMPTY
42380: LIST
42381: LIST
42382: PUSH
42383: LD_INT 5
42385: NEG
42386: PUSH
42387: LD_INT 4
42389: NEG
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: LD_INT 5
42397: NEG
42398: PUSH
42399: LD_INT 5
42401: NEG
42402: PUSH
42403: EMPTY
42404: LIST
42405: LIST
42406: PUSH
42407: LD_INT 3
42409: NEG
42410: PUSH
42411: LD_INT 5
42413: NEG
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 5
42421: NEG
42422: PUSH
42423: LD_INT 3
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: LIST
42443: LIST
42444: LIST
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: LIST
42459: LIST
42460: LIST
42461: LIST
42462: LIST
42463: LIST
42464: LIST
42465: LIST
42466: LIST
42467: LIST
42468: LIST
42469: LIST
42470: LIST
42471: LIST
42472: LIST
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42478: LD_ADDR_VAR 0 30
42482: PUSH
42483: LD_INT 4
42485: PUSH
42486: LD_INT 4
42488: PUSH
42489: EMPTY
42490: LIST
42491: LIST
42492: PUSH
42493: LD_INT 4
42495: PUSH
42496: LD_INT 3
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: LD_INT 5
42505: PUSH
42506: LD_INT 4
42508: PUSH
42509: EMPTY
42510: LIST
42511: LIST
42512: PUSH
42513: LD_INT 5
42515: PUSH
42516: LD_INT 5
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 4
42525: PUSH
42526: LD_INT 5
42528: PUSH
42529: EMPTY
42530: LIST
42531: LIST
42532: PUSH
42533: LD_INT 3
42535: PUSH
42536: LD_INT 4
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: LD_INT 3
42545: PUSH
42546: LD_INT 3
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: PUSH
42553: LD_INT 5
42555: PUSH
42556: LD_INT 3
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 3
42565: PUSH
42566: LD_INT 5
42568: PUSH
42569: EMPTY
42570: LIST
42571: LIST
42572: PUSH
42573: LD_INT 0
42575: PUSH
42576: LD_INT 3
42578: PUSH
42579: EMPTY
42580: LIST
42581: LIST
42582: PUSH
42583: LD_INT 0
42585: PUSH
42586: LD_INT 2
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: PUSH
42593: LD_INT 1
42595: PUSH
42596: LD_INT 3
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: PUSH
42603: LD_INT 1
42605: PUSH
42606: LD_INT 4
42608: PUSH
42609: EMPTY
42610: LIST
42611: LIST
42612: PUSH
42613: LD_INT 0
42615: PUSH
42616: LD_INT 4
42618: PUSH
42619: EMPTY
42620: LIST
42621: LIST
42622: PUSH
42623: LD_INT 1
42625: NEG
42626: PUSH
42627: LD_INT 3
42629: PUSH
42630: EMPTY
42631: LIST
42632: LIST
42633: PUSH
42634: LD_INT 1
42636: NEG
42637: PUSH
42638: LD_INT 2
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 2
42647: PUSH
42648: LD_INT 4
42650: PUSH
42651: EMPTY
42652: LIST
42653: LIST
42654: PUSH
42655: LD_INT 2
42657: NEG
42658: PUSH
42659: LD_INT 2
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 4
42668: NEG
42669: PUSH
42670: LD_INT 0
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 4
42679: NEG
42680: PUSH
42681: LD_INT 1
42683: NEG
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: LD_INT 3
42691: NEG
42692: PUSH
42693: LD_INT 0
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: PUSH
42700: LD_INT 3
42702: NEG
42703: PUSH
42704: LD_INT 1
42706: PUSH
42707: EMPTY
42708: LIST
42709: LIST
42710: PUSH
42711: LD_INT 4
42713: NEG
42714: PUSH
42715: LD_INT 1
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 5
42724: NEG
42725: PUSH
42726: LD_INT 0
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 5
42735: NEG
42736: PUSH
42737: LD_INT 1
42739: NEG
42740: PUSH
42741: EMPTY
42742: LIST
42743: LIST
42744: PUSH
42745: LD_INT 5
42747: NEG
42748: PUSH
42749: LD_INT 2
42751: NEG
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: LD_INT 3
42759: NEG
42760: PUSH
42761: LD_INT 2
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PUSH
42768: LD_INT 3
42770: NEG
42771: PUSH
42772: LD_INT 3
42774: NEG
42775: PUSH
42776: EMPTY
42777: LIST
42778: LIST
42779: PUSH
42780: LD_INT 3
42782: NEG
42783: PUSH
42784: LD_INT 4
42786: NEG
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 2
42794: NEG
42795: PUSH
42796: LD_INT 3
42798: NEG
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: PUSH
42804: LD_INT 2
42806: NEG
42807: PUSH
42808: LD_INT 2
42810: NEG
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: PUSH
42816: LD_INT 3
42818: NEG
42819: PUSH
42820: LD_INT 2
42822: NEG
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: LD_INT 4
42830: NEG
42831: PUSH
42832: LD_INT 3
42834: NEG
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: PUSH
42840: LD_INT 4
42842: NEG
42843: PUSH
42844: LD_INT 4
42846: NEG
42847: PUSH
42848: EMPTY
42849: LIST
42850: LIST
42851: PUSH
42852: LD_INT 2
42854: NEG
42855: PUSH
42856: LD_INT 4
42858: NEG
42859: PUSH
42860: EMPTY
42861: LIST
42862: LIST
42863: PUSH
42864: LD_INT 4
42866: NEG
42867: PUSH
42868: LD_INT 2
42870: NEG
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 0
42878: PUSH
42879: LD_INT 4
42881: NEG
42882: PUSH
42883: EMPTY
42884: LIST
42885: LIST
42886: PUSH
42887: LD_INT 0
42889: PUSH
42890: LD_INT 5
42892: NEG
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: PUSH
42898: LD_INT 1
42900: PUSH
42901: LD_INT 4
42903: NEG
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 1
42911: PUSH
42912: LD_INT 3
42914: NEG
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: LD_INT 0
42922: PUSH
42923: LD_INT 3
42925: NEG
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: PUSH
42931: LD_INT 1
42933: NEG
42934: PUSH
42935: LD_INT 4
42937: NEG
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: PUSH
42943: LD_INT 1
42945: NEG
42946: PUSH
42947: LD_INT 5
42949: NEG
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 2
42957: PUSH
42958: LD_INT 3
42960: NEG
42961: PUSH
42962: EMPTY
42963: LIST
42964: LIST
42965: PUSH
42966: LD_INT 2
42968: NEG
42969: PUSH
42970: LD_INT 5
42972: NEG
42973: PUSH
42974: EMPTY
42975: LIST
42976: LIST
42977: PUSH
42978: EMPTY
42979: LIST
42980: LIST
42981: LIST
42982: LIST
42983: LIST
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: LIST
42989: LIST
42990: LIST
42991: LIST
42992: LIST
42993: LIST
42994: LIST
42995: LIST
42996: LIST
42997: LIST
42998: LIST
42999: LIST
43000: LIST
43001: LIST
43002: LIST
43003: LIST
43004: LIST
43005: LIST
43006: LIST
43007: LIST
43008: LIST
43009: LIST
43010: LIST
43011: LIST
43012: LIST
43013: LIST
43014: LIST
43015: LIST
43016: LIST
43017: LIST
43018: LIST
43019: LIST
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43025: LD_ADDR_VAR 0 31
43029: PUSH
43030: LD_INT 0
43032: PUSH
43033: LD_INT 4
43035: PUSH
43036: EMPTY
43037: LIST
43038: LIST
43039: PUSH
43040: LD_INT 0
43042: PUSH
43043: LD_INT 3
43045: PUSH
43046: EMPTY
43047: LIST
43048: LIST
43049: PUSH
43050: LD_INT 1
43052: PUSH
43053: LD_INT 4
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: PUSH
43060: LD_INT 1
43062: PUSH
43063: LD_INT 5
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PUSH
43070: LD_INT 0
43072: PUSH
43073: LD_INT 5
43075: PUSH
43076: EMPTY
43077: LIST
43078: LIST
43079: PUSH
43080: LD_INT 1
43082: NEG
43083: PUSH
43084: LD_INT 4
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 1
43093: NEG
43094: PUSH
43095: LD_INT 3
43097: PUSH
43098: EMPTY
43099: LIST
43100: LIST
43101: PUSH
43102: LD_INT 2
43104: PUSH
43105: LD_INT 5
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: LD_INT 2
43114: NEG
43115: PUSH
43116: LD_INT 3
43118: PUSH
43119: EMPTY
43120: LIST
43121: LIST
43122: PUSH
43123: LD_INT 3
43125: NEG
43126: PUSH
43127: LD_INT 0
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 3
43136: NEG
43137: PUSH
43138: LD_INT 1
43140: NEG
43141: PUSH
43142: EMPTY
43143: LIST
43144: LIST
43145: PUSH
43146: LD_INT 2
43148: NEG
43149: PUSH
43150: LD_INT 0
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 2
43159: NEG
43160: PUSH
43161: LD_INT 1
43163: PUSH
43164: EMPTY
43165: LIST
43166: LIST
43167: PUSH
43168: LD_INT 3
43170: NEG
43171: PUSH
43172: LD_INT 1
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 4
43181: NEG
43182: PUSH
43183: LD_INT 0
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PUSH
43190: LD_INT 4
43192: NEG
43193: PUSH
43194: LD_INT 1
43196: NEG
43197: PUSH
43198: EMPTY
43199: LIST
43200: LIST
43201: PUSH
43202: LD_INT 4
43204: NEG
43205: PUSH
43206: LD_INT 2
43208: NEG
43209: PUSH
43210: EMPTY
43211: LIST
43212: LIST
43213: PUSH
43214: LD_INT 2
43216: NEG
43217: PUSH
43218: LD_INT 2
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: PUSH
43225: LD_INT 4
43227: NEG
43228: PUSH
43229: LD_INT 4
43231: NEG
43232: PUSH
43233: EMPTY
43234: LIST
43235: LIST
43236: PUSH
43237: LD_INT 4
43239: NEG
43240: PUSH
43241: LD_INT 5
43243: NEG
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 3
43251: NEG
43252: PUSH
43253: LD_INT 4
43255: NEG
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: LD_INT 3
43263: NEG
43264: PUSH
43265: LD_INT 3
43267: NEG
43268: PUSH
43269: EMPTY
43270: LIST
43271: LIST
43272: PUSH
43273: LD_INT 4
43275: NEG
43276: PUSH
43277: LD_INT 3
43279: NEG
43280: PUSH
43281: EMPTY
43282: LIST
43283: LIST
43284: PUSH
43285: LD_INT 5
43287: NEG
43288: PUSH
43289: LD_INT 4
43291: NEG
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PUSH
43297: LD_INT 5
43299: NEG
43300: PUSH
43301: LD_INT 5
43303: NEG
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: PUSH
43309: LD_INT 3
43311: NEG
43312: PUSH
43313: LD_INT 5
43315: NEG
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 5
43323: NEG
43324: PUSH
43325: LD_INT 3
43327: NEG
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: PUSH
43333: LD_INT 0
43335: PUSH
43336: LD_INT 3
43338: NEG
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: LD_INT 0
43346: PUSH
43347: LD_INT 4
43349: NEG
43350: PUSH
43351: EMPTY
43352: LIST
43353: LIST
43354: PUSH
43355: LD_INT 1
43357: PUSH
43358: LD_INT 3
43360: NEG
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 1
43368: PUSH
43369: LD_INT 2
43371: NEG
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 0
43379: PUSH
43380: LD_INT 2
43382: NEG
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 1
43390: NEG
43391: PUSH
43392: LD_INT 3
43394: NEG
43395: PUSH
43396: EMPTY
43397: LIST
43398: LIST
43399: PUSH
43400: LD_INT 1
43402: NEG
43403: PUSH
43404: LD_INT 4
43406: NEG
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: PUSH
43412: LD_INT 2
43414: PUSH
43415: LD_INT 2
43417: NEG
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: LD_INT 2
43425: NEG
43426: PUSH
43427: LD_INT 4
43429: NEG
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 4
43437: PUSH
43438: LD_INT 0
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PUSH
43445: LD_INT 4
43447: PUSH
43448: LD_INT 1
43450: NEG
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 5
43458: PUSH
43459: LD_INT 0
43461: PUSH
43462: EMPTY
43463: LIST
43464: LIST
43465: PUSH
43466: LD_INT 5
43468: PUSH
43469: LD_INT 1
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 4
43478: PUSH
43479: LD_INT 1
43481: PUSH
43482: EMPTY
43483: LIST
43484: LIST
43485: PUSH
43486: LD_INT 3
43488: PUSH
43489: LD_INT 0
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PUSH
43496: LD_INT 3
43498: PUSH
43499: LD_INT 1
43501: NEG
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 3
43509: PUSH
43510: LD_INT 2
43512: NEG
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: PUSH
43518: LD_INT 5
43520: PUSH
43521: LD_INT 2
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: LIST
43532: LIST
43533: LIST
43534: LIST
43535: LIST
43536: LIST
43537: LIST
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: LIST
43550: LIST
43551: LIST
43552: LIST
43553: LIST
43554: LIST
43555: LIST
43556: LIST
43557: LIST
43558: LIST
43559: LIST
43560: LIST
43561: LIST
43562: LIST
43563: LIST
43564: LIST
43565: LIST
43566: LIST
43567: LIST
43568: LIST
43569: LIST
43570: LIST
43571: LIST
43572: LIST
43573: LIST
43574: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43575: LD_ADDR_VAR 0 32
43579: PUSH
43580: LD_INT 4
43582: NEG
43583: PUSH
43584: LD_INT 0
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: PUSH
43591: LD_INT 4
43593: NEG
43594: PUSH
43595: LD_INT 1
43597: NEG
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: PUSH
43603: LD_INT 3
43605: NEG
43606: PUSH
43607: LD_INT 0
43609: PUSH
43610: EMPTY
43611: LIST
43612: LIST
43613: PUSH
43614: LD_INT 3
43616: NEG
43617: PUSH
43618: LD_INT 1
43620: PUSH
43621: EMPTY
43622: LIST
43623: LIST
43624: PUSH
43625: LD_INT 4
43627: NEG
43628: PUSH
43629: LD_INT 1
43631: PUSH
43632: EMPTY
43633: LIST
43634: LIST
43635: PUSH
43636: LD_INT 5
43638: NEG
43639: PUSH
43640: LD_INT 0
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PUSH
43647: LD_INT 5
43649: NEG
43650: PUSH
43651: LD_INT 1
43653: NEG
43654: PUSH
43655: EMPTY
43656: LIST
43657: LIST
43658: PUSH
43659: LD_INT 5
43661: NEG
43662: PUSH
43663: LD_INT 2
43665: NEG
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: LD_INT 3
43673: NEG
43674: PUSH
43675: LD_INT 2
43677: PUSH
43678: EMPTY
43679: LIST
43680: LIST
43681: PUSH
43682: LD_INT 3
43684: NEG
43685: PUSH
43686: LD_INT 3
43688: NEG
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 3
43696: NEG
43697: PUSH
43698: LD_INT 4
43700: NEG
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: PUSH
43706: LD_INT 2
43708: NEG
43709: PUSH
43710: LD_INT 3
43712: NEG
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PUSH
43718: LD_INT 2
43720: NEG
43721: PUSH
43722: LD_INT 2
43724: NEG
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PUSH
43730: LD_INT 3
43732: NEG
43733: PUSH
43734: LD_INT 2
43736: NEG
43737: PUSH
43738: EMPTY
43739: LIST
43740: LIST
43741: PUSH
43742: LD_INT 4
43744: NEG
43745: PUSH
43746: LD_INT 3
43748: NEG
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PUSH
43754: LD_INT 4
43756: NEG
43757: PUSH
43758: LD_INT 4
43760: NEG
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: LD_INT 2
43768: NEG
43769: PUSH
43770: LD_INT 4
43772: NEG
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: LD_INT 4
43780: NEG
43781: PUSH
43782: LD_INT 2
43784: NEG
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PUSH
43790: LD_INT 0
43792: PUSH
43793: LD_INT 4
43795: NEG
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 0
43803: PUSH
43804: LD_INT 5
43806: NEG
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: PUSH
43812: LD_INT 1
43814: PUSH
43815: LD_INT 4
43817: NEG
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PUSH
43823: LD_INT 1
43825: PUSH
43826: LD_INT 3
43828: NEG
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: PUSH
43834: LD_INT 0
43836: PUSH
43837: LD_INT 3
43839: NEG
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 1
43847: NEG
43848: PUSH
43849: LD_INT 4
43851: NEG
43852: PUSH
43853: EMPTY
43854: LIST
43855: LIST
43856: PUSH
43857: LD_INT 1
43859: NEG
43860: PUSH
43861: LD_INT 5
43863: NEG
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PUSH
43869: LD_INT 2
43871: PUSH
43872: LD_INT 3
43874: NEG
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: LD_INT 2
43882: NEG
43883: PUSH
43884: LD_INT 5
43886: NEG
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: PUSH
43892: LD_INT 3
43894: PUSH
43895: LD_INT 0
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: LD_INT 3
43904: PUSH
43905: LD_INT 1
43907: NEG
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: LD_INT 4
43915: PUSH
43916: LD_INT 0
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 4
43925: PUSH
43926: LD_INT 1
43928: PUSH
43929: EMPTY
43930: LIST
43931: LIST
43932: PUSH
43933: LD_INT 3
43935: PUSH
43936: LD_INT 1
43938: PUSH
43939: EMPTY
43940: LIST
43941: LIST
43942: PUSH
43943: LD_INT 2
43945: PUSH
43946: LD_INT 0
43948: PUSH
43949: EMPTY
43950: LIST
43951: LIST
43952: PUSH
43953: LD_INT 2
43955: PUSH
43956: LD_INT 1
43958: NEG
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: PUSH
43964: LD_INT 2
43966: PUSH
43967: LD_INT 2
43969: NEG
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: PUSH
43975: LD_INT 4
43977: PUSH
43978: LD_INT 2
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 4
43987: PUSH
43988: LD_INT 4
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: PUSH
43995: LD_INT 4
43997: PUSH
43998: LD_INT 3
44000: PUSH
44001: EMPTY
44002: LIST
44003: LIST
44004: PUSH
44005: LD_INT 5
44007: PUSH
44008: LD_INT 4
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: PUSH
44015: LD_INT 5
44017: PUSH
44018: LD_INT 5
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: PUSH
44025: LD_INT 4
44027: PUSH
44028: LD_INT 5
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 3
44037: PUSH
44038: LD_INT 4
44040: PUSH
44041: EMPTY
44042: LIST
44043: LIST
44044: PUSH
44045: LD_INT 3
44047: PUSH
44048: LD_INT 3
44050: PUSH
44051: EMPTY
44052: LIST
44053: LIST
44054: PUSH
44055: LD_INT 5
44057: PUSH
44058: LD_INT 3
44060: PUSH
44061: EMPTY
44062: LIST
44063: LIST
44064: PUSH
44065: LD_INT 3
44067: PUSH
44068: LD_INT 5
44070: PUSH
44071: EMPTY
44072: LIST
44073: LIST
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: LIST
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: LIST
44085: LIST
44086: LIST
44087: LIST
44088: LIST
44089: LIST
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: LIST
44096: LIST
44097: LIST
44098: LIST
44099: LIST
44100: LIST
44101: LIST
44102: LIST
44103: LIST
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: LIST
44109: LIST
44110: LIST
44111: LIST
44112: LIST
44113: LIST
44114: LIST
44115: LIST
44116: LIST
44117: LIST
44118: LIST
44119: LIST
44120: LIST
44121: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44122: LD_ADDR_VAR 0 33
44126: PUSH
44127: LD_INT 4
44129: NEG
44130: PUSH
44131: LD_INT 4
44133: NEG
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 4
44141: NEG
44142: PUSH
44143: LD_INT 5
44145: NEG
44146: PUSH
44147: EMPTY
44148: LIST
44149: LIST
44150: PUSH
44151: LD_INT 3
44153: NEG
44154: PUSH
44155: LD_INT 4
44157: NEG
44158: PUSH
44159: EMPTY
44160: LIST
44161: LIST
44162: PUSH
44163: LD_INT 3
44165: NEG
44166: PUSH
44167: LD_INT 3
44169: NEG
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 4
44177: NEG
44178: PUSH
44179: LD_INT 3
44181: NEG
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: LD_INT 5
44189: NEG
44190: PUSH
44191: LD_INT 4
44193: NEG
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 5
44201: NEG
44202: PUSH
44203: LD_INT 5
44205: NEG
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 3
44213: NEG
44214: PUSH
44215: LD_INT 5
44217: NEG
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 5
44225: NEG
44226: PUSH
44227: LD_INT 3
44229: NEG
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: LD_INT 0
44237: PUSH
44238: LD_INT 3
44240: NEG
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PUSH
44246: LD_INT 0
44248: PUSH
44249: LD_INT 4
44251: NEG
44252: PUSH
44253: EMPTY
44254: LIST
44255: LIST
44256: PUSH
44257: LD_INT 1
44259: PUSH
44260: LD_INT 3
44262: NEG
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: PUSH
44268: LD_INT 1
44270: PUSH
44271: LD_INT 2
44273: NEG
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PUSH
44279: LD_INT 0
44281: PUSH
44282: LD_INT 2
44284: NEG
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PUSH
44290: LD_INT 1
44292: NEG
44293: PUSH
44294: LD_INT 3
44296: NEG
44297: PUSH
44298: EMPTY
44299: LIST
44300: LIST
44301: PUSH
44302: LD_INT 1
44304: NEG
44305: PUSH
44306: LD_INT 4
44308: NEG
44309: PUSH
44310: EMPTY
44311: LIST
44312: LIST
44313: PUSH
44314: LD_INT 2
44316: PUSH
44317: LD_INT 2
44319: NEG
44320: PUSH
44321: EMPTY
44322: LIST
44323: LIST
44324: PUSH
44325: LD_INT 2
44327: NEG
44328: PUSH
44329: LD_INT 4
44331: NEG
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: PUSH
44337: LD_INT 4
44339: PUSH
44340: LD_INT 0
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: LD_INT 4
44349: PUSH
44350: LD_INT 1
44352: NEG
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 5
44360: PUSH
44361: LD_INT 0
44363: PUSH
44364: EMPTY
44365: LIST
44366: LIST
44367: PUSH
44368: LD_INT 5
44370: PUSH
44371: LD_INT 1
44373: PUSH
44374: EMPTY
44375: LIST
44376: LIST
44377: PUSH
44378: LD_INT 4
44380: PUSH
44381: LD_INT 1
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: PUSH
44388: LD_INT 3
44390: PUSH
44391: LD_INT 0
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: PUSH
44398: LD_INT 3
44400: PUSH
44401: LD_INT 1
44403: NEG
44404: PUSH
44405: EMPTY
44406: LIST
44407: LIST
44408: PUSH
44409: LD_INT 3
44411: PUSH
44412: LD_INT 2
44414: NEG
44415: PUSH
44416: EMPTY
44417: LIST
44418: LIST
44419: PUSH
44420: LD_INT 5
44422: PUSH
44423: LD_INT 2
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PUSH
44430: LD_INT 3
44432: PUSH
44433: LD_INT 3
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 3
44442: PUSH
44443: LD_INT 2
44445: PUSH
44446: EMPTY
44447: LIST
44448: LIST
44449: PUSH
44450: LD_INT 4
44452: PUSH
44453: LD_INT 3
44455: PUSH
44456: EMPTY
44457: LIST
44458: LIST
44459: PUSH
44460: LD_INT 4
44462: PUSH
44463: LD_INT 4
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: PUSH
44470: LD_INT 3
44472: PUSH
44473: LD_INT 4
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: PUSH
44480: LD_INT 2
44482: PUSH
44483: LD_INT 3
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: PUSH
44490: LD_INT 2
44492: PUSH
44493: LD_INT 2
44495: PUSH
44496: EMPTY
44497: LIST
44498: LIST
44499: PUSH
44500: LD_INT 4
44502: PUSH
44503: LD_INT 2
44505: PUSH
44506: EMPTY
44507: LIST
44508: LIST
44509: PUSH
44510: LD_INT 2
44512: PUSH
44513: LD_INT 4
44515: PUSH
44516: EMPTY
44517: LIST
44518: LIST
44519: PUSH
44520: LD_INT 0
44522: PUSH
44523: LD_INT 4
44525: PUSH
44526: EMPTY
44527: LIST
44528: LIST
44529: PUSH
44530: LD_INT 0
44532: PUSH
44533: LD_INT 3
44535: PUSH
44536: EMPTY
44537: LIST
44538: LIST
44539: PUSH
44540: LD_INT 1
44542: PUSH
44543: LD_INT 4
44545: PUSH
44546: EMPTY
44547: LIST
44548: LIST
44549: PUSH
44550: LD_INT 1
44552: PUSH
44553: LD_INT 5
44555: PUSH
44556: EMPTY
44557: LIST
44558: LIST
44559: PUSH
44560: LD_INT 0
44562: PUSH
44563: LD_INT 5
44565: PUSH
44566: EMPTY
44567: LIST
44568: LIST
44569: PUSH
44570: LD_INT 1
44572: NEG
44573: PUSH
44574: LD_INT 4
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PUSH
44581: LD_INT 1
44583: NEG
44584: PUSH
44585: LD_INT 3
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: LD_INT 2
44594: PUSH
44595: LD_INT 5
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PUSH
44602: LD_INT 2
44604: NEG
44605: PUSH
44606: LD_INT 3
44608: PUSH
44609: EMPTY
44610: LIST
44611: LIST
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: LIST
44617: LIST
44618: LIST
44619: LIST
44620: LIST
44621: LIST
44622: LIST
44623: LIST
44624: LIST
44625: LIST
44626: LIST
44627: LIST
44628: LIST
44629: LIST
44630: LIST
44631: LIST
44632: LIST
44633: LIST
44634: LIST
44635: LIST
44636: LIST
44637: LIST
44638: LIST
44639: LIST
44640: LIST
44641: LIST
44642: LIST
44643: LIST
44644: LIST
44645: LIST
44646: LIST
44647: LIST
44648: LIST
44649: LIST
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: LIST
44655: LIST
44656: LIST
44657: LIST
44658: LIST
44659: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44660: LD_ADDR_VAR 0 34
44664: PUSH
44665: LD_INT 0
44667: PUSH
44668: LD_INT 4
44670: NEG
44671: PUSH
44672: EMPTY
44673: LIST
44674: LIST
44675: PUSH
44676: LD_INT 0
44678: PUSH
44679: LD_INT 5
44681: NEG
44682: PUSH
44683: EMPTY
44684: LIST
44685: LIST
44686: PUSH
44687: LD_INT 1
44689: PUSH
44690: LD_INT 4
44692: NEG
44693: PUSH
44694: EMPTY
44695: LIST
44696: LIST
44697: PUSH
44698: LD_INT 1
44700: PUSH
44701: LD_INT 3
44703: NEG
44704: PUSH
44705: EMPTY
44706: LIST
44707: LIST
44708: PUSH
44709: LD_INT 0
44711: PUSH
44712: LD_INT 3
44714: NEG
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 1
44722: NEG
44723: PUSH
44724: LD_INT 4
44726: NEG
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: PUSH
44732: LD_INT 1
44734: NEG
44735: PUSH
44736: LD_INT 5
44738: NEG
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: PUSH
44744: LD_INT 2
44746: PUSH
44747: LD_INT 3
44749: NEG
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 2
44757: NEG
44758: PUSH
44759: LD_INT 5
44761: NEG
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: PUSH
44767: LD_INT 3
44769: PUSH
44770: LD_INT 0
44772: PUSH
44773: EMPTY
44774: LIST
44775: LIST
44776: PUSH
44777: LD_INT 3
44779: PUSH
44780: LD_INT 1
44782: NEG
44783: PUSH
44784: EMPTY
44785: LIST
44786: LIST
44787: PUSH
44788: LD_INT 4
44790: PUSH
44791: LD_INT 0
44793: PUSH
44794: EMPTY
44795: LIST
44796: LIST
44797: PUSH
44798: LD_INT 4
44800: PUSH
44801: LD_INT 1
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: PUSH
44808: LD_INT 3
44810: PUSH
44811: LD_INT 1
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: PUSH
44818: LD_INT 2
44820: PUSH
44821: LD_INT 0
44823: PUSH
44824: EMPTY
44825: LIST
44826: LIST
44827: PUSH
44828: LD_INT 2
44830: PUSH
44831: LD_INT 1
44833: NEG
44834: PUSH
44835: EMPTY
44836: LIST
44837: LIST
44838: PUSH
44839: LD_INT 2
44841: PUSH
44842: LD_INT 2
44844: NEG
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: PUSH
44850: LD_INT 4
44852: PUSH
44853: LD_INT 2
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 4
44862: PUSH
44863: LD_INT 4
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 4
44872: PUSH
44873: LD_INT 3
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 5
44882: PUSH
44883: LD_INT 4
44885: PUSH
44886: EMPTY
44887: LIST
44888: LIST
44889: PUSH
44890: LD_INT 5
44892: PUSH
44893: LD_INT 5
44895: PUSH
44896: EMPTY
44897: LIST
44898: LIST
44899: PUSH
44900: LD_INT 4
44902: PUSH
44903: LD_INT 5
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: PUSH
44910: LD_INT 3
44912: PUSH
44913: LD_INT 4
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PUSH
44920: LD_INT 3
44922: PUSH
44923: LD_INT 3
44925: PUSH
44926: EMPTY
44927: LIST
44928: LIST
44929: PUSH
44930: LD_INT 5
44932: PUSH
44933: LD_INT 3
44935: PUSH
44936: EMPTY
44937: LIST
44938: LIST
44939: PUSH
44940: LD_INT 3
44942: PUSH
44943: LD_INT 5
44945: PUSH
44946: EMPTY
44947: LIST
44948: LIST
44949: PUSH
44950: LD_INT 0
44952: PUSH
44953: LD_INT 3
44955: PUSH
44956: EMPTY
44957: LIST
44958: LIST
44959: PUSH
44960: LD_INT 0
44962: PUSH
44963: LD_INT 2
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: PUSH
44970: LD_INT 1
44972: PUSH
44973: LD_INT 3
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: PUSH
44980: LD_INT 1
44982: PUSH
44983: LD_INT 4
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PUSH
44990: LD_INT 0
44992: PUSH
44993: LD_INT 4
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: PUSH
45000: LD_INT 1
45002: NEG
45003: PUSH
45004: LD_INT 3
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 1
45013: NEG
45014: PUSH
45015: LD_INT 2
45017: PUSH
45018: EMPTY
45019: LIST
45020: LIST
45021: PUSH
45022: LD_INT 2
45024: PUSH
45025: LD_INT 4
45027: PUSH
45028: EMPTY
45029: LIST
45030: LIST
45031: PUSH
45032: LD_INT 2
45034: NEG
45035: PUSH
45036: LD_INT 2
45038: PUSH
45039: EMPTY
45040: LIST
45041: LIST
45042: PUSH
45043: LD_INT 4
45045: NEG
45046: PUSH
45047: LD_INT 0
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PUSH
45054: LD_INT 4
45056: NEG
45057: PUSH
45058: LD_INT 1
45060: NEG
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PUSH
45066: LD_INT 3
45068: NEG
45069: PUSH
45070: LD_INT 0
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 3
45079: NEG
45080: PUSH
45081: LD_INT 1
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: PUSH
45088: LD_INT 4
45090: NEG
45091: PUSH
45092: LD_INT 1
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: LD_INT 5
45101: NEG
45102: PUSH
45103: LD_INT 0
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 5
45112: NEG
45113: PUSH
45114: LD_INT 1
45116: NEG
45117: PUSH
45118: EMPTY
45119: LIST
45120: LIST
45121: PUSH
45122: LD_INT 5
45124: NEG
45125: PUSH
45126: LD_INT 2
45128: NEG
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 3
45136: NEG
45137: PUSH
45138: LD_INT 2
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: LIST
45149: LIST
45150: LIST
45151: LIST
45152: LIST
45153: LIST
45154: LIST
45155: LIST
45156: LIST
45157: LIST
45158: LIST
45159: LIST
45160: LIST
45161: LIST
45162: LIST
45163: LIST
45164: LIST
45165: LIST
45166: LIST
45167: LIST
45168: LIST
45169: LIST
45170: LIST
45171: LIST
45172: LIST
45173: LIST
45174: LIST
45175: LIST
45176: LIST
45177: LIST
45178: LIST
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: LIST
45188: LIST
45189: LIST
45190: LIST
45191: ST_TO_ADDR
// end ; end ;
45192: GO 45195
45194: POP
// case btype of b_depot , b_warehouse :
45195: LD_VAR 0 1
45199: PUSH
45200: LD_INT 0
45202: DOUBLE
45203: EQUAL
45204: IFTRUE 45214
45206: LD_INT 1
45208: DOUBLE
45209: EQUAL
45210: IFTRUE 45214
45212: GO 45415
45214: POP
// case nation of nation_american :
45215: LD_VAR 0 5
45219: PUSH
45220: LD_INT 1
45222: DOUBLE
45223: EQUAL
45224: IFTRUE 45228
45226: GO 45284
45228: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45229: LD_ADDR_VAR 0 9
45233: PUSH
45234: LD_VAR 0 11
45238: PUSH
45239: LD_VAR 0 12
45243: PUSH
45244: LD_VAR 0 13
45248: PUSH
45249: LD_VAR 0 14
45253: PUSH
45254: LD_VAR 0 15
45258: PUSH
45259: LD_VAR 0 16
45263: PUSH
45264: EMPTY
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: PUSH
45272: LD_VAR 0 4
45276: PUSH
45277: LD_INT 1
45279: PLUS
45280: ARRAY
45281: ST_TO_ADDR
45282: GO 45413
45284: LD_INT 2
45286: DOUBLE
45287: EQUAL
45288: IFTRUE 45292
45290: GO 45348
45292: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45293: LD_ADDR_VAR 0 9
45297: PUSH
45298: LD_VAR 0 17
45302: PUSH
45303: LD_VAR 0 18
45307: PUSH
45308: LD_VAR 0 19
45312: PUSH
45313: LD_VAR 0 20
45317: PUSH
45318: LD_VAR 0 21
45322: PUSH
45323: LD_VAR 0 22
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: PUSH
45336: LD_VAR 0 4
45340: PUSH
45341: LD_INT 1
45343: PLUS
45344: ARRAY
45345: ST_TO_ADDR
45346: GO 45413
45348: LD_INT 3
45350: DOUBLE
45351: EQUAL
45352: IFTRUE 45356
45354: GO 45412
45356: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45357: LD_ADDR_VAR 0 9
45361: PUSH
45362: LD_VAR 0 23
45366: PUSH
45367: LD_VAR 0 24
45371: PUSH
45372: LD_VAR 0 25
45376: PUSH
45377: LD_VAR 0 26
45381: PUSH
45382: LD_VAR 0 27
45386: PUSH
45387: LD_VAR 0 28
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: LIST
45398: LIST
45399: PUSH
45400: LD_VAR 0 4
45404: PUSH
45405: LD_INT 1
45407: PLUS
45408: ARRAY
45409: ST_TO_ADDR
45410: GO 45413
45412: POP
45413: GO 45968
45415: LD_INT 2
45417: DOUBLE
45418: EQUAL
45419: IFTRUE 45429
45421: LD_INT 3
45423: DOUBLE
45424: EQUAL
45425: IFTRUE 45429
45427: GO 45485
45429: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45430: LD_ADDR_VAR 0 9
45434: PUSH
45435: LD_VAR 0 29
45439: PUSH
45440: LD_VAR 0 30
45444: PUSH
45445: LD_VAR 0 31
45449: PUSH
45450: LD_VAR 0 32
45454: PUSH
45455: LD_VAR 0 33
45459: PUSH
45460: LD_VAR 0 34
45464: PUSH
45465: EMPTY
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: PUSH
45473: LD_VAR 0 4
45477: PUSH
45478: LD_INT 1
45480: PLUS
45481: ARRAY
45482: ST_TO_ADDR
45483: GO 45968
45485: LD_INT 16
45487: DOUBLE
45488: EQUAL
45489: IFTRUE 45547
45491: LD_INT 17
45493: DOUBLE
45494: EQUAL
45495: IFTRUE 45547
45497: LD_INT 18
45499: DOUBLE
45500: EQUAL
45501: IFTRUE 45547
45503: LD_INT 19
45505: DOUBLE
45506: EQUAL
45507: IFTRUE 45547
45509: LD_INT 22
45511: DOUBLE
45512: EQUAL
45513: IFTRUE 45547
45515: LD_INT 20
45517: DOUBLE
45518: EQUAL
45519: IFTRUE 45547
45521: LD_INT 21
45523: DOUBLE
45524: EQUAL
45525: IFTRUE 45547
45527: LD_INT 23
45529: DOUBLE
45530: EQUAL
45531: IFTRUE 45547
45533: LD_INT 24
45535: DOUBLE
45536: EQUAL
45537: IFTRUE 45547
45539: LD_INT 25
45541: DOUBLE
45542: EQUAL
45543: IFTRUE 45547
45545: GO 45603
45547: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45548: LD_ADDR_VAR 0 9
45552: PUSH
45553: LD_VAR 0 35
45557: PUSH
45558: LD_VAR 0 36
45562: PUSH
45563: LD_VAR 0 37
45567: PUSH
45568: LD_VAR 0 38
45572: PUSH
45573: LD_VAR 0 39
45577: PUSH
45578: LD_VAR 0 40
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: LIST
45587: LIST
45588: LIST
45589: LIST
45590: PUSH
45591: LD_VAR 0 4
45595: PUSH
45596: LD_INT 1
45598: PLUS
45599: ARRAY
45600: ST_TO_ADDR
45601: GO 45968
45603: LD_INT 6
45605: DOUBLE
45606: EQUAL
45607: IFTRUE 45659
45609: LD_INT 7
45611: DOUBLE
45612: EQUAL
45613: IFTRUE 45659
45615: LD_INT 8
45617: DOUBLE
45618: EQUAL
45619: IFTRUE 45659
45621: LD_INT 13
45623: DOUBLE
45624: EQUAL
45625: IFTRUE 45659
45627: LD_INT 12
45629: DOUBLE
45630: EQUAL
45631: IFTRUE 45659
45633: LD_INT 15
45635: DOUBLE
45636: EQUAL
45637: IFTRUE 45659
45639: LD_INT 11
45641: DOUBLE
45642: EQUAL
45643: IFTRUE 45659
45645: LD_INT 14
45647: DOUBLE
45648: EQUAL
45649: IFTRUE 45659
45651: LD_INT 10
45653: DOUBLE
45654: EQUAL
45655: IFTRUE 45659
45657: GO 45715
45659: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45660: LD_ADDR_VAR 0 9
45664: PUSH
45665: LD_VAR 0 41
45669: PUSH
45670: LD_VAR 0 42
45674: PUSH
45675: LD_VAR 0 43
45679: PUSH
45680: LD_VAR 0 44
45684: PUSH
45685: LD_VAR 0 45
45689: PUSH
45690: LD_VAR 0 46
45694: PUSH
45695: EMPTY
45696: LIST
45697: LIST
45698: LIST
45699: LIST
45700: LIST
45701: LIST
45702: PUSH
45703: LD_VAR 0 4
45707: PUSH
45708: LD_INT 1
45710: PLUS
45711: ARRAY
45712: ST_TO_ADDR
45713: GO 45968
45715: LD_INT 36
45717: DOUBLE
45718: EQUAL
45719: IFTRUE 45723
45721: GO 45779
45723: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45724: LD_ADDR_VAR 0 9
45728: PUSH
45729: LD_VAR 0 47
45733: PUSH
45734: LD_VAR 0 48
45738: PUSH
45739: LD_VAR 0 49
45743: PUSH
45744: LD_VAR 0 50
45748: PUSH
45749: LD_VAR 0 51
45753: PUSH
45754: LD_VAR 0 52
45758: PUSH
45759: EMPTY
45760: LIST
45761: LIST
45762: LIST
45763: LIST
45764: LIST
45765: LIST
45766: PUSH
45767: LD_VAR 0 4
45771: PUSH
45772: LD_INT 1
45774: PLUS
45775: ARRAY
45776: ST_TO_ADDR
45777: GO 45968
45779: LD_INT 4
45781: DOUBLE
45782: EQUAL
45783: IFTRUE 45805
45785: LD_INT 5
45787: DOUBLE
45788: EQUAL
45789: IFTRUE 45805
45791: LD_INT 34
45793: DOUBLE
45794: EQUAL
45795: IFTRUE 45805
45797: LD_INT 37
45799: DOUBLE
45800: EQUAL
45801: IFTRUE 45805
45803: GO 45861
45805: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45806: LD_ADDR_VAR 0 9
45810: PUSH
45811: LD_VAR 0 53
45815: PUSH
45816: LD_VAR 0 54
45820: PUSH
45821: LD_VAR 0 55
45825: PUSH
45826: LD_VAR 0 56
45830: PUSH
45831: LD_VAR 0 57
45835: PUSH
45836: LD_VAR 0 58
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: LIST
45848: PUSH
45849: LD_VAR 0 4
45853: PUSH
45854: LD_INT 1
45856: PLUS
45857: ARRAY
45858: ST_TO_ADDR
45859: GO 45968
45861: LD_INT 31
45863: DOUBLE
45864: EQUAL
45865: IFTRUE 45911
45867: LD_INT 32
45869: DOUBLE
45870: EQUAL
45871: IFTRUE 45911
45873: LD_INT 33
45875: DOUBLE
45876: EQUAL
45877: IFTRUE 45911
45879: LD_INT 27
45881: DOUBLE
45882: EQUAL
45883: IFTRUE 45911
45885: LD_INT 26
45887: DOUBLE
45888: EQUAL
45889: IFTRUE 45911
45891: LD_INT 28
45893: DOUBLE
45894: EQUAL
45895: IFTRUE 45911
45897: LD_INT 29
45899: DOUBLE
45900: EQUAL
45901: IFTRUE 45911
45903: LD_INT 30
45905: DOUBLE
45906: EQUAL
45907: IFTRUE 45911
45909: GO 45967
45911: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45912: LD_ADDR_VAR 0 9
45916: PUSH
45917: LD_VAR 0 59
45921: PUSH
45922: LD_VAR 0 60
45926: PUSH
45927: LD_VAR 0 61
45931: PUSH
45932: LD_VAR 0 62
45936: PUSH
45937: LD_VAR 0 63
45941: PUSH
45942: LD_VAR 0 64
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: LIST
45951: LIST
45952: LIST
45953: LIST
45954: PUSH
45955: LD_VAR 0 4
45959: PUSH
45960: LD_INT 1
45962: PLUS
45963: ARRAY
45964: ST_TO_ADDR
45965: GO 45968
45967: POP
// temp_list2 = [ ] ;
45968: LD_ADDR_VAR 0 10
45972: PUSH
45973: EMPTY
45974: ST_TO_ADDR
// for i in temp_list do
45975: LD_ADDR_VAR 0 8
45979: PUSH
45980: LD_VAR 0 9
45984: PUSH
45985: FOR_IN
45986: IFFALSE 46038
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45988: LD_ADDR_VAR 0 10
45992: PUSH
45993: LD_VAR 0 10
45997: PUSH
45998: LD_VAR 0 8
46002: PUSH
46003: LD_INT 1
46005: ARRAY
46006: PUSH
46007: LD_VAR 0 2
46011: PLUS
46012: PUSH
46013: LD_VAR 0 8
46017: PUSH
46018: LD_INT 2
46020: ARRAY
46021: PUSH
46022: LD_VAR 0 3
46026: PLUS
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: PUSH
46032: EMPTY
46033: LIST
46034: ADD
46035: ST_TO_ADDR
46036: GO 45985
46038: POP
46039: POP
// result = temp_list2 ;
46040: LD_ADDR_VAR 0 7
46044: PUSH
46045: LD_VAR 0 10
46049: ST_TO_ADDR
// end ;
46050: LD_VAR 0 7
46054: RET
// export function EnemyInRange ( unit , dist ) ; begin
46055: LD_INT 0
46057: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46058: LD_ADDR_VAR 0 3
46062: PUSH
46063: LD_VAR 0 1
46067: PPUSH
46068: CALL_OW 255
46072: PPUSH
46073: LD_VAR 0 1
46077: PPUSH
46078: CALL_OW 250
46082: PPUSH
46083: LD_VAR 0 1
46087: PPUSH
46088: CALL_OW 251
46092: PPUSH
46093: LD_VAR 0 2
46097: PPUSH
46098: CALL 20159 0 4
46102: PUSH
46103: LD_INT 4
46105: ARRAY
46106: ST_TO_ADDR
// end ;
46107: LD_VAR 0 3
46111: RET
// export function PlayerSeeMe ( unit ) ; begin
46112: LD_INT 0
46114: PPUSH
// result := See ( your_side , unit ) ;
46115: LD_ADDR_VAR 0 2
46119: PUSH
46120: LD_OWVAR 2
46124: PPUSH
46125: LD_VAR 0 1
46129: PPUSH
46130: CALL_OW 292
46134: ST_TO_ADDR
// end ;
46135: LD_VAR 0 2
46139: RET
// export function ReverseDir ( unit ) ; begin
46140: LD_INT 0
46142: PPUSH
// if not unit then
46143: LD_VAR 0 1
46147: NOT
46148: IFFALSE 46152
// exit ;
46150: GO 46175
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46152: LD_ADDR_VAR 0 2
46156: PUSH
46157: LD_VAR 0 1
46161: PPUSH
46162: CALL_OW 254
46166: PUSH
46167: LD_INT 3
46169: PLUS
46170: PUSH
46171: LD_INT 6
46173: MOD
46174: ST_TO_ADDR
// end ;
46175: LD_VAR 0 2
46179: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46180: LD_INT 0
46182: PPUSH
46183: PPUSH
46184: PPUSH
46185: PPUSH
46186: PPUSH
// if not hexes then
46187: LD_VAR 0 2
46191: NOT
46192: IFFALSE 46196
// exit ;
46194: GO 46344
// dist := 9999 ;
46196: LD_ADDR_VAR 0 5
46200: PUSH
46201: LD_INT 9999
46203: ST_TO_ADDR
// for i = 1 to hexes do
46204: LD_ADDR_VAR 0 4
46208: PUSH
46209: DOUBLE
46210: LD_INT 1
46212: DEC
46213: ST_TO_ADDR
46214: LD_VAR 0 2
46218: PUSH
46219: FOR_TO
46220: IFFALSE 46332
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46222: LD_VAR 0 1
46226: PPUSH
46227: LD_VAR 0 2
46231: PUSH
46232: LD_VAR 0 4
46236: ARRAY
46237: PUSH
46238: LD_INT 1
46240: ARRAY
46241: PPUSH
46242: LD_VAR 0 2
46246: PUSH
46247: LD_VAR 0 4
46251: ARRAY
46252: PUSH
46253: LD_INT 2
46255: ARRAY
46256: PPUSH
46257: CALL_OW 297
46261: PUSH
46262: LD_VAR 0 5
46266: LESS
46267: IFFALSE 46330
// begin hex := hexes [ i ] ;
46269: LD_ADDR_VAR 0 7
46273: PUSH
46274: LD_VAR 0 2
46278: PUSH
46279: LD_VAR 0 4
46283: ARRAY
46284: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46285: LD_ADDR_VAR 0 5
46289: PUSH
46290: LD_VAR 0 1
46294: PPUSH
46295: LD_VAR 0 2
46299: PUSH
46300: LD_VAR 0 4
46304: ARRAY
46305: PUSH
46306: LD_INT 1
46308: ARRAY
46309: PPUSH
46310: LD_VAR 0 2
46314: PUSH
46315: LD_VAR 0 4
46319: ARRAY
46320: PUSH
46321: LD_INT 2
46323: ARRAY
46324: PPUSH
46325: CALL_OW 297
46329: ST_TO_ADDR
// end ; end ;
46330: GO 46219
46332: POP
46333: POP
// result := hex ;
46334: LD_ADDR_VAR 0 3
46338: PUSH
46339: LD_VAR 0 7
46343: ST_TO_ADDR
// end ;
46344: LD_VAR 0 3
46348: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46349: LD_INT 0
46351: PPUSH
46352: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46353: LD_VAR 0 1
46357: NOT
46358: PUSH
46359: LD_VAR 0 1
46363: PUSH
46364: LD_INT 21
46366: PUSH
46367: LD_INT 2
46369: PUSH
46370: EMPTY
46371: LIST
46372: LIST
46373: PUSH
46374: LD_INT 23
46376: PUSH
46377: LD_INT 2
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: PUSH
46384: EMPTY
46385: LIST
46386: LIST
46387: PPUSH
46388: CALL_OW 69
46392: IN
46393: NOT
46394: OR
46395: IFFALSE 46399
// exit ;
46397: GO 46446
// for i = 1 to 3 do
46399: LD_ADDR_VAR 0 3
46403: PUSH
46404: DOUBLE
46405: LD_INT 1
46407: DEC
46408: ST_TO_ADDR
46409: LD_INT 3
46411: PUSH
46412: FOR_TO
46413: IFFALSE 46444
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46415: LD_VAR 0 1
46419: PPUSH
46420: CALL_OW 250
46424: PPUSH
46425: LD_VAR 0 1
46429: PPUSH
46430: CALL_OW 251
46434: PPUSH
46435: LD_INT 1
46437: PPUSH
46438: CALL_OW 453
46442: GO 46412
46444: POP
46445: POP
// end ;
46446: LD_VAR 0 2
46450: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46451: LD_INT 0
46453: PPUSH
46454: PPUSH
46455: PPUSH
46456: PPUSH
46457: PPUSH
46458: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46459: LD_VAR 0 1
46463: NOT
46464: PUSH
46465: LD_VAR 0 2
46469: NOT
46470: OR
46471: PUSH
46472: LD_VAR 0 1
46476: PPUSH
46477: CALL_OW 314
46481: OR
46482: IFFALSE 46486
// exit ;
46484: GO 46927
// x := GetX ( enemy_unit ) ;
46486: LD_ADDR_VAR 0 7
46490: PUSH
46491: LD_VAR 0 2
46495: PPUSH
46496: CALL_OW 250
46500: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46501: LD_ADDR_VAR 0 8
46505: PUSH
46506: LD_VAR 0 2
46510: PPUSH
46511: CALL_OW 251
46515: ST_TO_ADDR
// if not x or not y then
46516: LD_VAR 0 7
46520: NOT
46521: PUSH
46522: LD_VAR 0 8
46526: NOT
46527: OR
46528: IFFALSE 46532
// exit ;
46530: GO 46927
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46532: LD_ADDR_VAR 0 6
46536: PUSH
46537: LD_VAR 0 7
46541: PPUSH
46542: LD_INT 0
46544: PPUSH
46545: LD_INT 4
46547: PPUSH
46548: CALL_OW 272
46552: PUSH
46553: LD_VAR 0 8
46557: PPUSH
46558: LD_INT 0
46560: PPUSH
46561: LD_INT 4
46563: PPUSH
46564: CALL_OW 273
46568: PUSH
46569: EMPTY
46570: LIST
46571: LIST
46572: PUSH
46573: LD_VAR 0 7
46577: PPUSH
46578: LD_INT 1
46580: PPUSH
46581: LD_INT 4
46583: PPUSH
46584: CALL_OW 272
46588: PUSH
46589: LD_VAR 0 8
46593: PPUSH
46594: LD_INT 1
46596: PPUSH
46597: LD_INT 4
46599: PPUSH
46600: CALL_OW 273
46604: PUSH
46605: EMPTY
46606: LIST
46607: LIST
46608: PUSH
46609: LD_VAR 0 7
46613: PPUSH
46614: LD_INT 2
46616: PPUSH
46617: LD_INT 4
46619: PPUSH
46620: CALL_OW 272
46624: PUSH
46625: LD_VAR 0 8
46629: PPUSH
46630: LD_INT 2
46632: PPUSH
46633: LD_INT 4
46635: PPUSH
46636: CALL_OW 273
46640: PUSH
46641: EMPTY
46642: LIST
46643: LIST
46644: PUSH
46645: LD_VAR 0 7
46649: PPUSH
46650: LD_INT 3
46652: PPUSH
46653: LD_INT 4
46655: PPUSH
46656: CALL_OW 272
46660: PUSH
46661: LD_VAR 0 8
46665: PPUSH
46666: LD_INT 3
46668: PPUSH
46669: LD_INT 4
46671: PPUSH
46672: CALL_OW 273
46676: PUSH
46677: EMPTY
46678: LIST
46679: LIST
46680: PUSH
46681: LD_VAR 0 7
46685: PPUSH
46686: LD_INT 4
46688: PPUSH
46689: LD_INT 4
46691: PPUSH
46692: CALL_OW 272
46696: PUSH
46697: LD_VAR 0 8
46701: PPUSH
46702: LD_INT 4
46704: PPUSH
46705: LD_INT 4
46707: PPUSH
46708: CALL_OW 273
46712: PUSH
46713: EMPTY
46714: LIST
46715: LIST
46716: PUSH
46717: LD_VAR 0 7
46721: PPUSH
46722: LD_INT 5
46724: PPUSH
46725: LD_INT 4
46727: PPUSH
46728: CALL_OW 272
46732: PUSH
46733: LD_VAR 0 8
46737: PPUSH
46738: LD_INT 5
46740: PPUSH
46741: LD_INT 4
46743: PPUSH
46744: CALL_OW 273
46748: PUSH
46749: EMPTY
46750: LIST
46751: LIST
46752: PUSH
46753: EMPTY
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: ST_TO_ADDR
// for i = tmp downto 1 do
46761: LD_ADDR_VAR 0 4
46765: PUSH
46766: DOUBLE
46767: LD_VAR 0 6
46771: INC
46772: ST_TO_ADDR
46773: LD_INT 1
46775: PUSH
46776: FOR_DOWNTO
46777: IFFALSE 46878
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46779: LD_VAR 0 6
46783: PUSH
46784: LD_VAR 0 4
46788: ARRAY
46789: PUSH
46790: LD_INT 1
46792: ARRAY
46793: PPUSH
46794: LD_VAR 0 6
46798: PUSH
46799: LD_VAR 0 4
46803: ARRAY
46804: PUSH
46805: LD_INT 2
46807: ARRAY
46808: PPUSH
46809: CALL_OW 488
46813: NOT
46814: PUSH
46815: LD_VAR 0 6
46819: PUSH
46820: LD_VAR 0 4
46824: ARRAY
46825: PUSH
46826: LD_INT 1
46828: ARRAY
46829: PPUSH
46830: LD_VAR 0 6
46834: PUSH
46835: LD_VAR 0 4
46839: ARRAY
46840: PUSH
46841: LD_INT 2
46843: ARRAY
46844: PPUSH
46845: CALL_OW 428
46849: PUSH
46850: LD_INT 0
46852: NONEQUAL
46853: OR
46854: IFFALSE 46876
// tmp := Delete ( tmp , i ) ;
46856: LD_ADDR_VAR 0 6
46860: PUSH
46861: LD_VAR 0 6
46865: PPUSH
46866: LD_VAR 0 4
46870: PPUSH
46871: CALL_OW 3
46875: ST_TO_ADDR
46876: GO 46776
46878: POP
46879: POP
// j := GetClosestHex ( unit , tmp ) ;
46880: LD_ADDR_VAR 0 5
46884: PUSH
46885: LD_VAR 0 1
46889: PPUSH
46890: LD_VAR 0 6
46894: PPUSH
46895: CALL 46180 0 2
46899: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46900: LD_VAR 0 1
46904: PPUSH
46905: LD_VAR 0 5
46909: PUSH
46910: LD_INT 1
46912: ARRAY
46913: PPUSH
46914: LD_VAR 0 5
46918: PUSH
46919: LD_INT 2
46921: ARRAY
46922: PPUSH
46923: CALL_OW 111
// end ;
46927: LD_VAR 0 3
46931: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46932: LD_INT 0
46934: PPUSH
46935: PPUSH
46936: PPUSH
// uc_side = 0 ;
46937: LD_ADDR_OWVAR 20
46941: PUSH
46942: LD_INT 0
46944: ST_TO_ADDR
// uc_nation = 0 ;
46945: LD_ADDR_OWVAR 21
46949: PUSH
46950: LD_INT 0
46952: ST_TO_ADDR
// InitHc_All ( ) ;
46953: CALL_OW 584
// InitVc ;
46957: CALL_OW 20
// if mastodonts then
46961: LD_VAR 0 6
46965: IFFALSE 47032
// for i = 1 to mastodonts do
46967: LD_ADDR_VAR 0 11
46971: PUSH
46972: DOUBLE
46973: LD_INT 1
46975: DEC
46976: ST_TO_ADDR
46977: LD_VAR 0 6
46981: PUSH
46982: FOR_TO
46983: IFFALSE 47030
// begin vc_chassis := 31 ;
46985: LD_ADDR_OWVAR 37
46989: PUSH
46990: LD_INT 31
46992: ST_TO_ADDR
// vc_control := control_rider ;
46993: LD_ADDR_OWVAR 38
46997: PUSH
46998: LD_INT 4
47000: ST_TO_ADDR
// animal := CreateVehicle ;
47001: LD_ADDR_VAR 0 12
47005: PUSH
47006: CALL_OW 45
47010: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47011: LD_VAR 0 12
47015: PPUSH
47016: LD_VAR 0 8
47020: PPUSH
47021: LD_INT 0
47023: PPUSH
47024: CALL 49220 0 3
// end ;
47028: GO 46982
47030: POP
47031: POP
// if horses then
47032: LD_VAR 0 5
47036: IFFALSE 47103
// for i = 1 to horses do
47038: LD_ADDR_VAR 0 11
47042: PUSH
47043: DOUBLE
47044: LD_INT 1
47046: DEC
47047: ST_TO_ADDR
47048: LD_VAR 0 5
47052: PUSH
47053: FOR_TO
47054: IFFALSE 47101
// begin hc_class := 21 ;
47056: LD_ADDR_OWVAR 28
47060: PUSH
47061: LD_INT 21
47063: ST_TO_ADDR
// hc_gallery :=  ;
47064: LD_ADDR_OWVAR 33
47068: PUSH
47069: LD_STRING 
47071: ST_TO_ADDR
// animal := CreateHuman ;
47072: LD_ADDR_VAR 0 12
47076: PUSH
47077: CALL_OW 44
47081: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47082: LD_VAR 0 12
47086: PPUSH
47087: LD_VAR 0 8
47091: PPUSH
47092: LD_INT 0
47094: PPUSH
47095: CALL 49220 0 3
// end ;
47099: GO 47053
47101: POP
47102: POP
// if birds then
47103: LD_VAR 0 1
47107: IFFALSE 47174
// for i = 1 to birds do
47109: LD_ADDR_VAR 0 11
47113: PUSH
47114: DOUBLE
47115: LD_INT 1
47117: DEC
47118: ST_TO_ADDR
47119: LD_VAR 0 1
47123: PUSH
47124: FOR_TO
47125: IFFALSE 47172
// begin hc_class = 18 ;
47127: LD_ADDR_OWVAR 28
47131: PUSH
47132: LD_INT 18
47134: ST_TO_ADDR
// hc_gallery =  ;
47135: LD_ADDR_OWVAR 33
47139: PUSH
47140: LD_STRING 
47142: ST_TO_ADDR
// animal := CreateHuman ;
47143: LD_ADDR_VAR 0 12
47147: PUSH
47148: CALL_OW 44
47152: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47153: LD_VAR 0 12
47157: PPUSH
47158: LD_VAR 0 8
47162: PPUSH
47163: LD_INT 0
47165: PPUSH
47166: CALL 49220 0 3
// end ;
47170: GO 47124
47172: POP
47173: POP
// if tigers then
47174: LD_VAR 0 2
47178: IFFALSE 47262
// for i = 1 to tigers do
47180: LD_ADDR_VAR 0 11
47184: PUSH
47185: DOUBLE
47186: LD_INT 1
47188: DEC
47189: ST_TO_ADDR
47190: LD_VAR 0 2
47194: PUSH
47195: FOR_TO
47196: IFFALSE 47260
// begin hc_class = class_tiger ;
47198: LD_ADDR_OWVAR 28
47202: PUSH
47203: LD_INT 14
47205: ST_TO_ADDR
// hc_gallery =  ;
47206: LD_ADDR_OWVAR 33
47210: PUSH
47211: LD_STRING 
47213: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47214: LD_ADDR_OWVAR 35
47218: PUSH
47219: LD_INT 7
47221: NEG
47222: PPUSH
47223: LD_INT 7
47225: PPUSH
47226: CALL_OW 12
47230: ST_TO_ADDR
// animal := CreateHuman ;
47231: LD_ADDR_VAR 0 12
47235: PUSH
47236: CALL_OW 44
47240: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47241: LD_VAR 0 12
47245: PPUSH
47246: LD_VAR 0 8
47250: PPUSH
47251: LD_INT 0
47253: PPUSH
47254: CALL 49220 0 3
// end ;
47258: GO 47195
47260: POP
47261: POP
// if apemans then
47262: LD_VAR 0 3
47266: IFFALSE 47389
// for i = 1 to apemans do
47268: LD_ADDR_VAR 0 11
47272: PUSH
47273: DOUBLE
47274: LD_INT 1
47276: DEC
47277: ST_TO_ADDR
47278: LD_VAR 0 3
47282: PUSH
47283: FOR_TO
47284: IFFALSE 47387
// begin hc_class = class_apeman ;
47286: LD_ADDR_OWVAR 28
47290: PUSH
47291: LD_INT 12
47293: ST_TO_ADDR
// hc_gallery =  ;
47294: LD_ADDR_OWVAR 33
47298: PUSH
47299: LD_STRING 
47301: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
47302: LD_ADDR_OWVAR 35
47306: PUSH
47307: LD_INT 5
47309: NEG
47310: PPUSH
47311: LD_INT 5
47313: PPUSH
47314: CALL_OW 12
47318: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
47319: LD_ADDR_OWVAR 31
47323: PUSH
47324: LD_INT 1
47326: PPUSH
47327: LD_INT 3
47329: PPUSH
47330: CALL_OW 12
47334: PUSH
47335: LD_INT 1
47337: PPUSH
47338: LD_INT 3
47340: PPUSH
47341: CALL_OW 12
47345: PUSH
47346: LD_INT 0
47348: PUSH
47349: LD_INT 0
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: LIST
47356: LIST
47357: ST_TO_ADDR
// animal := CreateHuman ;
47358: LD_ADDR_VAR 0 12
47362: PUSH
47363: CALL_OW 44
47367: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47368: LD_VAR 0 12
47372: PPUSH
47373: LD_VAR 0 8
47377: PPUSH
47378: LD_INT 0
47380: PPUSH
47381: CALL 49220 0 3
// end ;
47385: GO 47283
47387: POP
47388: POP
// if enchidnas then
47389: LD_VAR 0 4
47393: IFFALSE 47460
// for i = 1 to enchidnas do
47395: LD_ADDR_VAR 0 11
47399: PUSH
47400: DOUBLE
47401: LD_INT 1
47403: DEC
47404: ST_TO_ADDR
47405: LD_VAR 0 4
47409: PUSH
47410: FOR_TO
47411: IFFALSE 47458
// begin hc_class = 13 ;
47413: LD_ADDR_OWVAR 28
47417: PUSH
47418: LD_INT 13
47420: ST_TO_ADDR
// hc_gallery =  ;
47421: LD_ADDR_OWVAR 33
47425: PUSH
47426: LD_STRING 
47428: ST_TO_ADDR
// animal := CreateHuman ;
47429: LD_ADDR_VAR 0 12
47433: PUSH
47434: CALL_OW 44
47438: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47439: LD_VAR 0 12
47443: PPUSH
47444: LD_VAR 0 8
47448: PPUSH
47449: LD_INT 0
47451: PPUSH
47452: CALL 49220 0 3
// end ;
47456: GO 47410
47458: POP
47459: POP
// if fishes then
47460: LD_VAR 0 7
47464: IFFALSE 47531
// for i = 1 to fishes do
47466: LD_ADDR_VAR 0 11
47470: PUSH
47471: DOUBLE
47472: LD_INT 1
47474: DEC
47475: ST_TO_ADDR
47476: LD_VAR 0 7
47480: PUSH
47481: FOR_TO
47482: IFFALSE 47529
// begin hc_class = 20 ;
47484: LD_ADDR_OWVAR 28
47488: PUSH
47489: LD_INT 20
47491: ST_TO_ADDR
// hc_gallery =  ;
47492: LD_ADDR_OWVAR 33
47496: PUSH
47497: LD_STRING 
47499: ST_TO_ADDR
// animal := CreateHuman ;
47500: LD_ADDR_VAR 0 12
47504: PUSH
47505: CALL_OW 44
47509: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47510: LD_VAR 0 12
47514: PPUSH
47515: LD_VAR 0 9
47519: PPUSH
47520: LD_INT 0
47522: PPUSH
47523: CALL 49220 0 3
// end ;
47527: GO 47481
47529: POP
47530: POP
// end ;
47531: LD_VAR 0 10
47535: RET
// export function WantHeal ( sci , unit ) ; begin
47536: LD_INT 0
47538: PPUSH
// if GetTaskList ( sci ) > 0 then
47539: LD_VAR 0 1
47543: PPUSH
47544: CALL_OW 437
47548: PUSH
47549: LD_INT 0
47551: GREATER
47552: IFFALSE 47622
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47554: LD_VAR 0 1
47558: PPUSH
47559: CALL_OW 437
47563: PUSH
47564: LD_INT 1
47566: ARRAY
47567: PUSH
47568: LD_INT 1
47570: ARRAY
47571: PUSH
47572: LD_STRING l
47574: EQUAL
47575: PUSH
47576: LD_VAR 0 1
47580: PPUSH
47581: CALL_OW 437
47585: PUSH
47586: LD_INT 1
47588: ARRAY
47589: PUSH
47590: LD_INT 4
47592: ARRAY
47593: PUSH
47594: LD_VAR 0 2
47598: EQUAL
47599: AND
47600: IFFALSE 47612
// result := true else
47602: LD_ADDR_VAR 0 3
47606: PUSH
47607: LD_INT 1
47609: ST_TO_ADDR
47610: GO 47620
// result := false ;
47612: LD_ADDR_VAR 0 3
47616: PUSH
47617: LD_INT 0
47619: ST_TO_ADDR
// end else
47620: GO 47630
// result := false ;
47622: LD_ADDR_VAR 0 3
47626: PUSH
47627: LD_INT 0
47629: ST_TO_ADDR
// end ;
47630: LD_VAR 0 3
47634: RET
// export function HealTarget ( sci ) ; begin
47635: LD_INT 0
47637: PPUSH
// if not sci then
47638: LD_VAR 0 1
47642: NOT
47643: IFFALSE 47647
// exit ;
47645: GO 47712
// result := 0 ;
47647: LD_ADDR_VAR 0 2
47651: PUSH
47652: LD_INT 0
47654: ST_TO_ADDR
// if GetTaskList ( sci ) then
47655: LD_VAR 0 1
47659: PPUSH
47660: CALL_OW 437
47664: IFFALSE 47712
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
47666: LD_VAR 0 1
47670: PPUSH
47671: CALL_OW 437
47675: PUSH
47676: LD_INT 1
47678: ARRAY
47679: PUSH
47680: LD_INT 1
47682: ARRAY
47683: PUSH
47684: LD_STRING l
47686: EQUAL
47687: IFFALSE 47712
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47689: LD_ADDR_VAR 0 2
47693: PUSH
47694: LD_VAR 0 1
47698: PPUSH
47699: CALL_OW 437
47703: PUSH
47704: LD_INT 1
47706: ARRAY
47707: PUSH
47708: LD_INT 4
47710: ARRAY
47711: ST_TO_ADDR
// end ;
47712: LD_VAR 0 2
47716: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47717: LD_INT 0
47719: PPUSH
47720: PPUSH
47721: PPUSH
47722: PPUSH
// if not base_units then
47723: LD_VAR 0 1
47727: NOT
47728: IFFALSE 47732
// exit ;
47730: GO 47819
// result := false ;
47732: LD_ADDR_VAR 0 2
47736: PUSH
47737: LD_INT 0
47739: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47740: LD_ADDR_VAR 0 5
47744: PUSH
47745: LD_VAR 0 1
47749: PPUSH
47750: LD_INT 21
47752: PUSH
47753: LD_INT 3
47755: PUSH
47756: EMPTY
47757: LIST
47758: LIST
47759: PPUSH
47760: CALL_OW 72
47764: ST_TO_ADDR
// if not tmp then
47765: LD_VAR 0 5
47769: NOT
47770: IFFALSE 47774
// exit ;
47772: GO 47819
// for i in tmp do
47774: LD_ADDR_VAR 0 3
47778: PUSH
47779: LD_VAR 0 5
47783: PUSH
47784: FOR_IN
47785: IFFALSE 47817
// begin result := EnemyInRange ( i , 22 ) ;
47787: LD_ADDR_VAR 0 2
47791: PUSH
47792: LD_VAR 0 3
47796: PPUSH
47797: LD_INT 22
47799: PPUSH
47800: CALL 46055 0 2
47804: ST_TO_ADDR
// if result then
47805: LD_VAR 0 2
47809: IFFALSE 47815
// exit ;
47811: POP
47812: POP
47813: GO 47819
// end ;
47815: GO 47784
47817: POP
47818: POP
// end ;
47819: LD_VAR 0 2
47823: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47824: LD_INT 0
47826: PPUSH
47827: PPUSH
// if not units then
47828: LD_VAR 0 1
47832: NOT
47833: IFFALSE 47837
// exit ;
47835: GO 47907
// result := [ ] ;
47837: LD_ADDR_VAR 0 3
47841: PUSH
47842: EMPTY
47843: ST_TO_ADDR
// for i in units do
47844: LD_ADDR_VAR 0 4
47848: PUSH
47849: LD_VAR 0 1
47853: PUSH
47854: FOR_IN
47855: IFFALSE 47905
// if GetTag ( i ) = tag then
47857: LD_VAR 0 4
47861: PPUSH
47862: CALL_OW 110
47866: PUSH
47867: LD_VAR 0 2
47871: EQUAL
47872: IFFALSE 47903
// result := Insert ( result , result + 1 , i ) ;
47874: LD_ADDR_VAR 0 3
47878: PUSH
47879: LD_VAR 0 3
47883: PPUSH
47884: LD_VAR 0 3
47888: PUSH
47889: LD_INT 1
47891: PLUS
47892: PPUSH
47893: LD_VAR 0 4
47897: PPUSH
47898: CALL_OW 2
47902: ST_TO_ADDR
47903: GO 47854
47905: POP
47906: POP
// end ;
47907: LD_VAR 0 3
47911: RET
// export function IsDriver ( un ) ; begin
47912: LD_INT 0
47914: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47915: LD_ADDR_VAR 0 2
47919: PUSH
47920: LD_VAR 0 1
47924: PUSH
47925: LD_INT 55
47927: PUSH
47928: EMPTY
47929: LIST
47930: PPUSH
47931: CALL_OW 69
47935: IN
47936: ST_TO_ADDR
// end ;
47937: LD_VAR 0 2
47941: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47942: LD_INT 0
47944: PPUSH
47945: PPUSH
// list := [ ] ;
47946: LD_ADDR_VAR 0 5
47950: PUSH
47951: EMPTY
47952: ST_TO_ADDR
// case d of 0 :
47953: LD_VAR 0 3
47957: PUSH
47958: LD_INT 0
47960: DOUBLE
47961: EQUAL
47962: IFTRUE 47966
47964: GO 48099
47966: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47967: LD_ADDR_VAR 0 5
47971: PUSH
47972: LD_VAR 0 1
47976: PUSH
47977: LD_INT 4
47979: MINUS
47980: PUSH
47981: LD_VAR 0 2
47985: PUSH
47986: LD_INT 4
47988: MINUS
47989: PUSH
47990: LD_INT 2
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: LIST
47997: PUSH
47998: LD_VAR 0 1
48002: PUSH
48003: LD_INT 3
48005: MINUS
48006: PUSH
48007: LD_VAR 0 2
48011: PUSH
48012: LD_INT 1
48014: PUSH
48015: EMPTY
48016: LIST
48017: LIST
48018: LIST
48019: PUSH
48020: LD_VAR 0 1
48024: PUSH
48025: LD_INT 4
48027: PLUS
48028: PUSH
48029: LD_VAR 0 2
48033: PUSH
48034: LD_INT 4
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: LIST
48041: PUSH
48042: LD_VAR 0 1
48046: PUSH
48047: LD_INT 3
48049: PLUS
48050: PUSH
48051: LD_VAR 0 2
48055: PUSH
48056: LD_INT 3
48058: PLUS
48059: PUSH
48060: LD_INT 5
48062: PUSH
48063: EMPTY
48064: LIST
48065: LIST
48066: LIST
48067: PUSH
48068: LD_VAR 0 1
48072: PUSH
48073: LD_VAR 0 2
48077: PUSH
48078: LD_INT 4
48080: PLUS
48081: PUSH
48082: LD_INT 0
48084: PUSH
48085: EMPTY
48086: LIST
48087: LIST
48088: LIST
48089: PUSH
48090: EMPTY
48091: LIST
48092: LIST
48093: LIST
48094: LIST
48095: LIST
48096: ST_TO_ADDR
// end ; 1 :
48097: GO 48797
48099: LD_INT 1
48101: DOUBLE
48102: EQUAL
48103: IFTRUE 48107
48105: GO 48240
48107: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48108: LD_ADDR_VAR 0 5
48112: PUSH
48113: LD_VAR 0 1
48117: PUSH
48118: LD_VAR 0 2
48122: PUSH
48123: LD_INT 4
48125: MINUS
48126: PUSH
48127: LD_INT 3
48129: PUSH
48130: EMPTY
48131: LIST
48132: LIST
48133: LIST
48134: PUSH
48135: LD_VAR 0 1
48139: PUSH
48140: LD_INT 3
48142: MINUS
48143: PUSH
48144: LD_VAR 0 2
48148: PUSH
48149: LD_INT 3
48151: MINUS
48152: PUSH
48153: LD_INT 2
48155: PUSH
48156: EMPTY
48157: LIST
48158: LIST
48159: LIST
48160: PUSH
48161: LD_VAR 0 1
48165: PUSH
48166: LD_INT 4
48168: MINUS
48169: PUSH
48170: LD_VAR 0 2
48174: PUSH
48175: LD_INT 1
48177: PUSH
48178: EMPTY
48179: LIST
48180: LIST
48181: LIST
48182: PUSH
48183: LD_VAR 0 1
48187: PUSH
48188: LD_VAR 0 2
48192: PUSH
48193: LD_INT 3
48195: PLUS
48196: PUSH
48197: LD_INT 0
48199: PUSH
48200: EMPTY
48201: LIST
48202: LIST
48203: LIST
48204: PUSH
48205: LD_VAR 0 1
48209: PUSH
48210: LD_INT 4
48212: PLUS
48213: PUSH
48214: LD_VAR 0 2
48218: PUSH
48219: LD_INT 4
48221: PLUS
48222: PUSH
48223: LD_INT 5
48225: PUSH
48226: EMPTY
48227: LIST
48228: LIST
48229: LIST
48230: PUSH
48231: EMPTY
48232: LIST
48233: LIST
48234: LIST
48235: LIST
48236: LIST
48237: ST_TO_ADDR
// end ; 2 :
48238: GO 48797
48240: LD_INT 2
48242: DOUBLE
48243: EQUAL
48244: IFTRUE 48248
48246: GO 48377
48248: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48249: LD_ADDR_VAR 0 5
48253: PUSH
48254: LD_VAR 0 1
48258: PUSH
48259: LD_VAR 0 2
48263: PUSH
48264: LD_INT 3
48266: MINUS
48267: PUSH
48268: LD_INT 3
48270: PUSH
48271: EMPTY
48272: LIST
48273: LIST
48274: LIST
48275: PUSH
48276: LD_VAR 0 1
48280: PUSH
48281: LD_INT 4
48283: PLUS
48284: PUSH
48285: LD_VAR 0 2
48289: PUSH
48290: LD_INT 4
48292: PUSH
48293: EMPTY
48294: LIST
48295: LIST
48296: LIST
48297: PUSH
48298: LD_VAR 0 1
48302: PUSH
48303: LD_VAR 0 2
48307: PUSH
48308: LD_INT 4
48310: PLUS
48311: PUSH
48312: LD_INT 0
48314: PUSH
48315: EMPTY
48316: LIST
48317: LIST
48318: LIST
48319: PUSH
48320: LD_VAR 0 1
48324: PUSH
48325: LD_INT 3
48327: MINUS
48328: PUSH
48329: LD_VAR 0 2
48333: PUSH
48334: LD_INT 1
48336: PUSH
48337: EMPTY
48338: LIST
48339: LIST
48340: LIST
48341: PUSH
48342: LD_VAR 0 1
48346: PUSH
48347: LD_INT 4
48349: MINUS
48350: PUSH
48351: LD_VAR 0 2
48355: PUSH
48356: LD_INT 4
48358: MINUS
48359: PUSH
48360: LD_INT 2
48362: PUSH
48363: EMPTY
48364: LIST
48365: LIST
48366: LIST
48367: PUSH
48368: EMPTY
48369: LIST
48370: LIST
48371: LIST
48372: LIST
48373: LIST
48374: ST_TO_ADDR
// end ; 3 :
48375: GO 48797
48377: LD_INT 3
48379: DOUBLE
48380: EQUAL
48381: IFTRUE 48385
48383: GO 48518
48385: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48386: LD_ADDR_VAR 0 5
48390: PUSH
48391: LD_VAR 0 1
48395: PUSH
48396: LD_INT 3
48398: PLUS
48399: PUSH
48400: LD_VAR 0 2
48404: PUSH
48405: LD_INT 4
48407: PUSH
48408: EMPTY
48409: LIST
48410: LIST
48411: LIST
48412: PUSH
48413: LD_VAR 0 1
48417: PUSH
48418: LD_INT 4
48420: PLUS
48421: PUSH
48422: LD_VAR 0 2
48426: PUSH
48427: LD_INT 4
48429: PLUS
48430: PUSH
48431: LD_INT 5
48433: PUSH
48434: EMPTY
48435: LIST
48436: LIST
48437: LIST
48438: PUSH
48439: LD_VAR 0 1
48443: PUSH
48444: LD_INT 4
48446: MINUS
48447: PUSH
48448: LD_VAR 0 2
48452: PUSH
48453: LD_INT 1
48455: PUSH
48456: EMPTY
48457: LIST
48458: LIST
48459: LIST
48460: PUSH
48461: LD_VAR 0 1
48465: PUSH
48466: LD_VAR 0 2
48470: PUSH
48471: LD_INT 4
48473: MINUS
48474: PUSH
48475: LD_INT 3
48477: PUSH
48478: EMPTY
48479: LIST
48480: LIST
48481: LIST
48482: PUSH
48483: LD_VAR 0 1
48487: PUSH
48488: LD_INT 3
48490: MINUS
48491: PUSH
48492: LD_VAR 0 2
48496: PUSH
48497: LD_INT 3
48499: MINUS
48500: PUSH
48501: LD_INT 2
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: LIST
48508: PUSH
48509: EMPTY
48510: LIST
48511: LIST
48512: LIST
48513: LIST
48514: LIST
48515: ST_TO_ADDR
// end ; 4 :
48516: GO 48797
48518: LD_INT 4
48520: DOUBLE
48521: EQUAL
48522: IFTRUE 48526
48524: GO 48659
48526: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48527: LD_ADDR_VAR 0 5
48531: PUSH
48532: LD_VAR 0 1
48536: PUSH
48537: LD_VAR 0 2
48541: PUSH
48542: LD_INT 4
48544: PLUS
48545: PUSH
48546: LD_INT 0
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: LIST
48553: PUSH
48554: LD_VAR 0 1
48558: PUSH
48559: LD_INT 3
48561: PLUS
48562: PUSH
48563: LD_VAR 0 2
48567: PUSH
48568: LD_INT 3
48570: PLUS
48571: PUSH
48572: LD_INT 5
48574: PUSH
48575: EMPTY
48576: LIST
48577: LIST
48578: LIST
48579: PUSH
48580: LD_VAR 0 1
48584: PUSH
48585: LD_INT 4
48587: PLUS
48588: PUSH
48589: LD_VAR 0 2
48593: PUSH
48594: LD_INT 4
48596: PUSH
48597: EMPTY
48598: LIST
48599: LIST
48600: LIST
48601: PUSH
48602: LD_VAR 0 1
48606: PUSH
48607: LD_VAR 0 2
48611: PUSH
48612: LD_INT 3
48614: MINUS
48615: PUSH
48616: LD_INT 3
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: LIST
48623: PUSH
48624: LD_VAR 0 1
48628: PUSH
48629: LD_INT 4
48631: MINUS
48632: PUSH
48633: LD_VAR 0 2
48637: PUSH
48638: LD_INT 4
48640: MINUS
48641: PUSH
48642: LD_INT 2
48644: PUSH
48645: EMPTY
48646: LIST
48647: LIST
48648: LIST
48649: PUSH
48650: EMPTY
48651: LIST
48652: LIST
48653: LIST
48654: LIST
48655: LIST
48656: ST_TO_ADDR
// end ; 5 :
48657: GO 48797
48659: LD_INT 5
48661: DOUBLE
48662: EQUAL
48663: IFTRUE 48667
48665: GO 48796
48667: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
48668: LD_ADDR_VAR 0 5
48672: PUSH
48673: LD_VAR 0 1
48677: PUSH
48678: LD_INT 4
48680: MINUS
48681: PUSH
48682: LD_VAR 0 2
48686: PUSH
48687: LD_INT 1
48689: PUSH
48690: EMPTY
48691: LIST
48692: LIST
48693: LIST
48694: PUSH
48695: LD_VAR 0 1
48699: PUSH
48700: LD_VAR 0 2
48704: PUSH
48705: LD_INT 4
48707: MINUS
48708: PUSH
48709: LD_INT 3
48711: PUSH
48712: EMPTY
48713: LIST
48714: LIST
48715: LIST
48716: PUSH
48717: LD_VAR 0 1
48721: PUSH
48722: LD_INT 4
48724: PLUS
48725: PUSH
48726: LD_VAR 0 2
48730: PUSH
48731: LD_INT 4
48733: PLUS
48734: PUSH
48735: LD_INT 5
48737: PUSH
48738: EMPTY
48739: LIST
48740: LIST
48741: LIST
48742: PUSH
48743: LD_VAR 0 1
48747: PUSH
48748: LD_INT 3
48750: PLUS
48751: PUSH
48752: LD_VAR 0 2
48756: PUSH
48757: LD_INT 4
48759: PUSH
48760: EMPTY
48761: LIST
48762: LIST
48763: LIST
48764: PUSH
48765: LD_VAR 0 1
48769: PUSH
48770: LD_VAR 0 2
48774: PUSH
48775: LD_INT 3
48777: PLUS
48778: PUSH
48779: LD_INT 0
48781: PUSH
48782: EMPTY
48783: LIST
48784: LIST
48785: LIST
48786: PUSH
48787: EMPTY
48788: LIST
48789: LIST
48790: LIST
48791: LIST
48792: LIST
48793: ST_TO_ADDR
// end ; end ;
48794: GO 48797
48796: POP
// result := list ;
48797: LD_ADDR_VAR 0 4
48801: PUSH
48802: LD_VAR 0 5
48806: ST_TO_ADDR
// end ;
48807: LD_VAR 0 4
48811: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48812: LD_INT 0
48814: PPUSH
48815: PPUSH
48816: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48817: LD_VAR 0 1
48821: NOT
48822: PUSH
48823: LD_VAR 0 2
48827: PUSH
48828: LD_INT 1
48830: PUSH
48831: LD_INT 2
48833: PUSH
48834: LD_INT 3
48836: PUSH
48837: LD_INT 4
48839: PUSH
48840: EMPTY
48841: LIST
48842: LIST
48843: LIST
48844: LIST
48845: IN
48846: NOT
48847: OR
48848: IFFALSE 48852
// exit ;
48850: GO 48944
// tmp := [ ] ;
48852: LD_ADDR_VAR 0 5
48856: PUSH
48857: EMPTY
48858: ST_TO_ADDR
// for i in units do
48859: LD_ADDR_VAR 0 4
48863: PUSH
48864: LD_VAR 0 1
48868: PUSH
48869: FOR_IN
48870: IFFALSE 48913
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48872: LD_ADDR_VAR 0 5
48876: PUSH
48877: LD_VAR 0 5
48881: PPUSH
48882: LD_VAR 0 5
48886: PUSH
48887: LD_INT 1
48889: PLUS
48890: PPUSH
48891: LD_VAR 0 4
48895: PPUSH
48896: LD_VAR 0 2
48900: PPUSH
48901: CALL_OW 259
48905: PPUSH
48906: CALL_OW 2
48910: ST_TO_ADDR
48911: GO 48869
48913: POP
48914: POP
// if not tmp then
48915: LD_VAR 0 5
48919: NOT
48920: IFFALSE 48924
// exit ;
48922: GO 48944
// result := SortListByListDesc ( units , tmp ) ;
48924: LD_ADDR_VAR 0 3
48928: PUSH
48929: LD_VAR 0 1
48933: PPUSH
48934: LD_VAR 0 5
48938: PPUSH
48939: CALL_OW 77
48943: ST_TO_ADDR
// end ;
48944: LD_VAR 0 3
48948: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48949: LD_INT 0
48951: PPUSH
48952: PPUSH
48953: PPUSH
// result := false ;
48954: LD_ADDR_VAR 0 3
48958: PUSH
48959: LD_INT 0
48961: ST_TO_ADDR
// x := GetX ( building ) ;
48962: LD_ADDR_VAR 0 4
48966: PUSH
48967: LD_VAR 0 2
48971: PPUSH
48972: CALL_OW 250
48976: ST_TO_ADDR
// y := GetY ( building ) ;
48977: LD_ADDR_VAR 0 5
48981: PUSH
48982: LD_VAR 0 2
48986: PPUSH
48987: CALL_OW 251
48991: ST_TO_ADDR
// if not building or not x or not y then
48992: LD_VAR 0 2
48996: NOT
48997: PUSH
48998: LD_VAR 0 4
49002: NOT
49003: OR
49004: PUSH
49005: LD_VAR 0 5
49009: NOT
49010: OR
49011: IFFALSE 49015
// exit ;
49013: GO 49107
// if GetTaskList ( unit ) then
49015: LD_VAR 0 1
49019: PPUSH
49020: CALL_OW 437
49024: IFFALSE 49107
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49026: LD_STRING e
49028: PUSH
49029: LD_VAR 0 1
49033: PPUSH
49034: CALL_OW 437
49038: PUSH
49039: LD_INT 1
49041: ARRAY
49042: PUSH
49043: LD_INT 1
49045: ARRAY
49046: EQUAL
49047: PUSH
49048: LD_VAR 0 4
49052: PUSH
49053: LD_VAR 0 1
49057: PPUSH
49058: CALL_OW 437
49062: PUSH
49063: LD_INT 1
49065: ARRAY
49066: PUSH
49067: LD_INT 2
49069: ARRAY
49070: EQUAL
49071: AND
49072: PUSH
49073: LD_VAR 0 5
49077: PUSH
49078: LD_VAR 0 1
49082: PPUSH
49083: CALL_OW 437
49087: PUSH
49088: LD_INT 1
49090: ARRAY
49091: PUSH
49092: LD_INT 3
49094: ARRAY
49095: EQUAL
49096: AND
49097: IFFALSE 49107
// result := true end ;
49099: LD_ADDR_VAR 0 3
49103: PUSH
49104: LD_INT 1
49106: ST_TO_ADDR
// end ;
49107: LD_VAR 0 3
49111: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49112: LD_INT 0
49114: PPUSH
// result := false ;
49115: LD_ADDR_VAR 0 4
49119: PUSH
49120: LD_INT 0
49122: ST_TO_ADDR
// if GetTaskList ( unit ) then
49123: LD_VAR 0 1
49127: PPUSH
49128: CALL_OW 437
49132: IFFALSE 49215
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49134: LD_STRING M
49136: PUSH
49137: LD_VAR 0 1
49141: PPUSH
49142: CALL_OW 437
49146: PUSH
49147: LD_INT 1
49149: ARRAY
49150: PUSH
49151: LD_INT 1
49153: ARRAY
49154: EQUAL
49155: PUSH
49156: LD_VAR 0 2
49160: PUSH
49161: LD_VAR 0 1
49165: PPUSH
49166: CALL_OW 437
49170: PUSH
49171: LD_INT 1
49173: ARRAY
49174: PUSH
49175: LD_INT 2
49177: ARRAY
49178: EQUAL
49179: AND
49180: PUSH
49181: LD_VAR 0 3
49185: PUSH
49186: LD_VAR 0 1
49190: PPUSH
49191: CALL_OW 437
49195: PUSH
49196: LD_INT 1
49198: ARRAY
49199: PUSH
49200: LD_INT 3
49202: ARRAY
49203: EQUAL
49204: AND
49205: IFFALSE 49215
// result := true ;
49207: LD_ADDR_VAR 0 4
49211: PUSH
49212: LD_INT 1
49214: ST_TO_ADDR
// end ; end ;
49215: LD_VAR 0 4
49219: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49220: LD_INT 0
49222: PPUSH
49223: PPUSH
49224: PPUSH
49225: PPUSH
// if not unit or not area then
49226: LD_VAR 0 1
49230: NOT
49231: PUSH
49232: LD_VAR 0 2
49236: NOT
49237: OR
49238: IFFALSE 49242
// exit ;
49240: GO 49406
// tmp := AreaToList ( area , i ) ;
49242: LD_ADDR_VAR 0 6
49246: PUSH
49247: LD_VAR 0 2
49251: PPUSH
49252: LD_VAR 0 5
49256: PPUSH
49257: CALL_OW 517
49261: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49262: LD_ADDR_VAR 0 5
49266: PUSH
49267: DOUBLE
49268: LD_INT 1
49270: DEC
49271: ST_TO_ADDR
49272: LD_VAR 0 6
49276: PUSH
49277: LD_INT 1
49279: ARRAY
49280: PUSH
49281: FOR_TO
49282: IFFALSE 49404
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49284: LD_ADDR_VAR 0 7
49288: PUSH
49289: LD_VAR 0 6
49293: PUSH
49294: LD_INT 1
49296: ARRAY
49297: PUSH
49298: LD_VAR 0 5
49302: ARRAY
49303: PUSH
49304: LD_VAR 0 6
49308: PUSH
49309: LD_INT 2
49311: ARRAY
49312: PUSH
49313: LD_VAR 0 5
49317: ARRAY
49318: PUSH
49319: EMPTY
49320: LIST
49321: LIST
49322: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
49323: LD_VAR 0 7
49327: PUSH
49328: LD_INT 1
49330: ARRAY
49331: PPUSH
49332: LD_VAR 0 7
49336: PUSH
49337: LD_INT 2
49339: ARRAY
49340: PPUSH
49341: CALL_OW 428
49345: PUSH
49346: LD_INT 0
49348: EQUAL
49349: IFFALSE 49402
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
49351: LD_VAR 0 1
49355: PPUSH
49356: LD_VAR 0 7
49360: PUSH
49361: LD_INT 1
49363: ARRAY
49364: PPUSH
49365: LD_VAR 0 7
49369: PUSH
49370: LD_INT 2
49372: ARRAY
49373: PPUSH
49374: LD_VAR 0 3
49378: PPUSH
49379: CALL_OW 48
// result := IsPlaced ( unit ) ;
49383: LD_ADDR_VAR 0 4
49387: PUSH
49388: LD_VAR 0 1
49392: PPUSH
49393: CALL_OW 305
49397: ST_TO_ADDR
// exit ;
49398: POP
49399: POP
49400: GO 49406
// end ; end ;
49402: GO 49281
49404: POP
49405: POP
// end ;
49406: LD_VAR 0 4
49410: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49411: LD_INT 0
49413: PPUSH
49414: PPUSH
49415: PPUSH
// if not side or side > 8 then
49416: LD_VAR 0 1
49420: NOT
49421: PUSH
49422: LD_VAR 0 1
49426: PUSH
49427: LD_INT 8
49429: GREATER
49430: OR
49431: IFFALSE 49435
// exit ;
49433: GO 49622
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49435: LD_ADDR_VAR 0 4
49439: PUSH
49440: LD_INT 22
49442: PUSH
49443: LD_VAR 0 1
49447: PUSH
49448: EMPTY
49449: LIST
49450: LIST
49451: PUSH
49452: LD_INT 21
49454: PUSH
49455: LD_INT 3
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: PUSH
49462: EMPTY
49463: LIST
49464: LIST
49465: PPUSH
49466: CALL_OW 69
49470: ST_TO_ADDR
// if not tmp then
49471: LD_VAR 0 4
49475: NOT
49476: IFFALSE 49480
// exit ;
49478: GO 49622
// enable_addtolog := true ;
49480: LD_ADDR_OWVAR 81
49484: PUSH
49485: LD_INT 1
49487: ST_TO_ADDR
// AddToLog ( [ ) ;
49488: LD_STRING [
49490: PPUSH
49491: CALL_OW 561
// for i in tmp do
49495: LD_ADDR_VAR 0 3
49499: PUSH
49500: LD_VAR 0 4
49504: PUSH
49505: FOR_IN
49506: IFFALSE 49613
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49508: LD_STRING [
49510: PUSH
49511: LD_VAR 0 3
49515: PPUSH
49516: CALL_OW 266
49520: STR
49521: PUSH
49522: LD_STRING , 
49524: STR
49525: PUSH
49526: LD_VAR 0 3
49530: PPUSH
49531: CALL_OW 250
49535: STR
49536: PUSH
49537: LD_STRING , 
49539: STR
49540: PUSH
49541: LD_VAR 0 3
49545: PPUSH
49546: CALL_OW 251
49550: STR
49551: PUSH
49552: LD_STRING , 
49554: STR
49555: PUSH
49556: LD_VAR 0 3
49560: PPUSH
49561: CALL_OW 254
49565: STR
49566: PUSH
49567: LD_STRING , 
49569: STR
49570: PUSH
49571: LD_VAR 0 3
49575: PPUSH
49576: LD_INT 1
49578: PPUSH
49579: CALL_OW 268
49583: STR
49584: PUSH
49585: LD_STRING , 
49587: STR
49588: PUSH
49589: LD_VAR 0 3
49593: PPUSH
49594: LD_INT 2
49596: PPUSH
49597: CALL_OW 268
49601: STR
49602: PUSH
49603: LD_STRING ],
49605: STR
49606: PPUSH
49607: CALL_OW 561
// end ;
49611: GO 49505
49613: POP
49614: POP
// AddToLog ( ]; ) ;
49615: LD_STRING ];
49617: PPUSH
49618: CALL_OW 561
// end ;
49622: LD_VAR 0 2
49626: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49627: LD_INT 0
49629: PPUSH
49630: PPUSH
49631: PPUSH
49632: PPUSH
49633: PPUSH
// if not area or not rate or not max then
49634: LD_VAR 0 1
49638: NOT
49639: PUSH
49640: LD_VAR 0 2
49644: NOT
49645: OR
49646: PUSH
49647: LD_VAR 0 4
49651: NOT
49652: OR
49653: IFFALSE 49657
// exit ;
49655: GO 49849
// while 1 do
49657: LD_INT 1
49659: IFFALSE 49849
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
49661: LD_ADDR_VAR 0 9
49665: PUSH
49666: LD_VAR 0 1
49670: PPUSH
49671: LD_INT 1
49673: PPUSH
49674: CALL_OW 287
49678: PUSH
49679: LD_INT 10
49681: MUL
49682: ST_TO_ADDR
// r := rate / 10 ;
49683: LD_ADDR_VAR 0 7
49687: PUSH
49688: LD_VAR 0 2
49692: PUSH
49693: LD_INT 10
49695: DIVREAL
49696: ST_TO_ADDR
// time := 1 1$00 ;
49697: LD_ADDR_VAR 0 8
49701: PUSH
49702: LD_INT 2100
49704: ST_TO_ADDR
// if amount < min then
49705: LD_VAR 0 9
49709: PUSH
49710: LD_VAR 0 3
49714: LESS
49715: IFFALSE 49733
// r := r * 2 else
49717: LD_ADDR_VAR 0 7
49721: PUSH
49722: LD_VAR 0 7
49726: PUSH
49727: LD_INT 2
49729: MUL
49730: ST_TO_ADDR
49731: GO 49759
// if amount > max then
49733: LD_VAR 0 9
49737: PUSH
49738: LD_VAR 0 4
49742: GREATER
49743: IFFALSE 49759
// r := r / 2 ;
49745: LD_ADDR_VAR 0 7
49749: PUSH
49750: LD_VAR 0 7
49754: PUSH
49755: LD_INT 2
49757: DIVREAL
49758: ST_TO_ADDR
// time := time / r ;
49759: LD_ADDR_VAR 0 8
49763: PUSH
49764: LD_VAR 0 8
49768: PUSH
49769: LD_VAR 0 7
49773: DIVREAL
49774: ST_TO_ADDR
// if time < 0 then
49775: LD_VAR 0 8
49779: PUSH
49780: LD_INT 0
49782: LESS
49783: IFFALSE 49800
// time := time * - 1 ;
49785: LD_ADDR_VAR 0 8
49789: PUSH
49790: LD_VAR 0 8
49794: PUSH
49795: LD_INT 1
49797: NEG
49798: MUL
49799: ST_TO_ADDR
// wait ( time ) ;
49800: LD_VAR 0 8
49804: PPUSH
49805: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49809: LD_INT 35
49811: PPUSH
49812: LD_INT 875
49814: PPUSH
49815: CALL_OW 12
49819: PPUSH
49820: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49824: LD_INT 1
49826: PPUSH
49827: LD_INT 5
49829: PPUSH
49830: CALL_OW 12
49834: PPUSH
49835: LD_VAR 0 1
49839: PPUSH
49840: LD_INT 1
49842: PPUSH
49843: CALL_OW 55
// end ;
49847: GO 49657
// end ;
49849: LD_VAR 0 5
49853: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49854: LD_INT 0
49856: PPUSH
49857: PPUSH
49858: PPUSH
49859: PPUSH
49860: PPUSH
49861: PPUSH
49862: PPUSH
49863: PPUSH
// if not turrets or not factories then
49864: LD_VAR 0 1
49868: NOT
49869: PUSH
49870: LD_VAR 0 2
49874: NOT
49875: OR
49876: IFFALSE 49880
// exit ;
49878: GO 50187
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49880: LD_ADDR_VAR 0 10
49884: PUSH
49885: LD_INT 5
49887: PUSH
49888: LD_INT 6
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PUSH
49895: LD_INT 2
49897: PUSH
49898: LD_INT 4
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PUSH
49905: LD_INT 3
49907: PUSH
49908: LD_INT 5
49910: PUSH
49911: EMPTY
49912: LIST
49913: LIST
49914: PUSH
49915: EMPTY
49916: LIST
49917: LIST
49918: LIST
49919: PUSH
49920: LD_INT 24
49922: PUSH
49923: LD_INT 25
49925: PUSH
49926: EMPTY
49927: LIST
49928: LIST
49929: PUSH
49930: LD_INT 23
49932: PUSH
49933: LD_INT 27
49935: PUSH
49936: EMPTY
49937: LIST
49938: LIST
49939: PUSH
49940: EMPTY
49941: LIST
49942: LIST
49943: PUSH
49944: LD_INT 42
49946: PUSH
49947: LD_INT 43
49949: PUSH
49950: EMPTY
49951: LIST
49952: LIST
49953: PUSH
49954: LD_INT 44
49956: PUSH
49957: LD_INT 46
49959: PUSH
49960: EMPTY
49961: LIST
49962: LIST
49963: PUSH
49964: LD_INT 45
49966: PUSH
49967: LD_INT 47
49969: PUSH
49970: EMPTY
49971: LIST
49972: LIST
49973: PUSH
49974: EMPTY
49975: LIST
49976: LIST
49977: LIST
49978: PUSH
49979: EMPTY
49980: LIST
49981: LIST
49982: LIST
49983: ST_TO_ADDR
// result := [ ] ;
49984: LD_ADDR_VAR 0 3
49988: PUSH
49989: EMPTY
49990: ST_TO_ADDR
// for i in turrets do
49991: LD_ADDR_VAR 0 4
49995: PUSH
49996: LD_VAR 0 1
50000: PUSH
50001: FOR_IN
50002: IFFALSE 50185
// begin nat := GetNation ( i ) ;
50004: LD_ADDR_VAR 0 7
50008: PUSH
50009: LD_VAR 0 4
50013: PPUSH
50014: CALL_OW 248
50018: ST_TO_ADDR
// weapon := 0 ;
50019: LD_ADDR_VAR 0 8
50023: PUSH
50024: LD_INT 0
50026: ST_TO_ADDR
// if not nat then
50027: LD_VAR 0 7
50031: NOT
50032: IFFALSE 50036
// continue ;
50034: GO 50001
// for j in list [ nat ] do
50036: LD_ADDR_VAR 0 5
50040: PUSH
50041: LD_VAR 0 10
50045: PUSH
50046: LD_VAR 0 7
50050: ARRAY
50051: PUSH
50052: FOR_IN
50053: IFFALSE 50094
// if GetBWeapon ( i ) = j [ 1 ] then
50055: LD_VAR 0 4
50059: PPUSH
50060: CALL_OW 269
50064: PUSH
50065: LD_VAR 0 5
50069: PUSH
50070: LD_INT 1
50072: ARRAY
50073: EQUAL
50074: IFFALSE 50092
// begin weapon := j [ 2 ] ;
50076: LD_ADDR_VAR 0 8
50080: PUSH
50081: LD_VAR 0 5
50085: PUSH
50086: LD_INT 2
50088: ARRAY
50089: ST_TO_ADDR
// break ;
50090: GO 50094
// end ;
50092: GO 50052
50094: POP
50095: POP
// if not weapon then
50096: LD_VAR 0 8
50100: NOT
50101: IFFALSE 50105
// continue ;
50103: GO 50001
// for k in factories do
50105: LD_ADDR_VAR 0 6
50109: PUSH
50110: LD_VAR 0 2
50114: PUSH
50115: FOR_IN
50116: IFFALSE 50181
// begin weapons := AvailableWeaponList ( k ) ;
50118: LD_ADDR_VAR 0 9
50122: PUSH
50123: LD_VAR 0 6
50127: PPUSH
50128: CALL_OW 478
50132: ST_TO_ADDR
// if not weapons then
50133: LD_VAR 0 9
50137: NOT
50138: IFFALSE 50142
// continue ;
50140: GO 50115
// if weapon in weapons then
50142: LD_VAR 0 8
50146: PUSH
50147: LD_VAR 0 9
50151: IN
50152: IFFALSE 50179
// begin result := [ i , weapon ] ;
50154: LD_ADDR_VAR 0 3
50158: PUSH
50159: LD_VAR 0 4
50163: PUSH
50164: LD_VAR 0 8
50168: PUSH
50169: EMPTY
50170: LIST
50171: LIST
50172: ST_TO_ADDR
// exit ;
50173: POP
50174: POP
50175: POP
50176: POP
50177: GO 50187
// end ; end ;
50179: GO 50115
50181: POP
50182: POP
// end ;
50183: GO 50001
50185: POP
50186: POP
// end ;
50187: LD_VAR 0 3
50191: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50192: LD_INT 0
50194: PPUSH
// if not side or side > 8 then
50195: LD_VAR 0 3
50199: NOT
50200: PUSH
50201: LD_VAR 0 3
50205: PUSH
50206: LD_INT 8
50208: GREATER
50209: OR
50210: IFFALSE 50214
// exit ;
50212: GO 50273
// if not range then
50214: LD_VAR 0 4
50218: NOT
50219: IFFALSE 50230
// range := - 12 ;
50221: LD_ADDR_VAR 0 4
50225: PUSH
50226: LD_INT 12
50228: NEG
50229: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50230: LD_VAR 0 1
50234: PPUSH
50235: LD_VAR 0 2
50239: PPUSH
50240: LD_VAR 0 3
50244: PPUSH
50245: LD_VAR 0 4
50249: PPUSH
50250: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50254: LD_VAR 0 1
50258: PPUSH
50259: LD_VAR 0 2
50263: PPUSH
50264: LD_VAR 0 3
50268: PPUSH
50269: CALL_OW 331
// end ;
50273: LD_VAR 0 5
50277: RET
// export function Video ( mode ) ; begin
50278: LD_INT 0
50280: PPUSH
// ingame_video = mode ;
50281: LD_ADDR_OWVAR 52
50285: PUSH
50286: LD_VAR 0 1
50290: ST_TO_ADDR
// interface_hidden = mode ;
50291: LD_ADDR_OWVAR 54
50295: PUSH
50296: LD_VAR 0 1
50300: ST_TO_ADDR
// end ;
50301: LD_VAR 0 2
50305: RET
// export function Join ( array , element ) ; begin
50306: LD_INT 0
50308: PPUSH
// result := Replace ( array , array + 1 , element ) ;
50309: LD_ADDR_VAR 0 3
50313: PUSH
50314: LD_VAR 0 1
50318: PPUSH
50319: LD_VAR 0 1
50323: PUSH
50324: LD_INT 1
50326: PLUS
50327: PPUSH
50328: LD_VAR 0 2
50332: PPUSH
50333: CALL_OW 1
50337: ST_TO_ADDR
// end ;
50338: LD_VAR 0 3
50342: RET
// export function JoinUnion ( array , element ) ; begin
50343: LD_INT 0
50345: PPUSH
// result := array union element ;
50346: LD_ADDR_VAR 0 3
50350: PUSH
50351: LD_VAR 0 1
50355: PUSH
50356: LD_VAR 0 2
50360: UNION
50361: ST_TO_ADDR
// end ;
50362: LD_VAR 0 3
50366: RET
// export function GetBehemoths ( side ) ; begin
50367: LD_INT 0
50369: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
50370: LD_ADDR_VAR 0 2
50374: PUSH
50375: LD_INT 22
50377: PUSH
50378: LD_VAR 0 1
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: PUSH
50387: LD_INT 31
50389: PUSH
50390: LD_INT 25
50392: PUSH
50393: EMPTY
50394: LIST
50395: LIST
50396: PUSH
50397: EMPTY
50398: LIST
50399: LIST
50400: PPUSH
50401: CALL_OW 69
50405: ST_TO_ADDR
// end ;
50406: LD_VAR 0 2
50410: RET
// export function Shuffle ( array ) ; var i , index ; begin
50411: LD_INT 0
50413: PPUSH
50414: PPUSH
50415: PPUSH
// result := [ ] ;
50416: LD_ADDR_VAR 0 2
50420: PUSH
50421: EMPTY
50422: ST_TO_ADDR
// if not array then
50423: LD_VAR 0 1
50427: NOT
50428: IFFALSE 50432
// exit ;
50430: GO 50531
// Randomize ;
50432: CALL_OW 10
// for i = array downto 1 do
50436: LD_ADDR_VAR 0 3
50440: PUSH
50441: DOUBLE
50442: LD_VAR 0 1
50446: INC
50447: ST_TO_ADDR
50448: LD_INT 1
50450: PUSH
50451: FOR_DOWNTO
50452: IFFALSE 50529
// begin index := rand ( 1 , array ) ;
50454: LD_ADDR_VAR 0 4
50458: PUSH
50459: LD_INT 1
50461: PPUSH
50462: LD_VAR 0 1
50466: PPUSH
50467: CALL_OW 12
50471: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50472: LD_ADDR_VAR 0 2
50476: PUSH
50477: LD_VAR 0 2
50481: PPUSH
50482: LD_VAR 0 2
50486: PUSH
50487: LD_INT 1
50489: PLUS
50490: PPUSH
50491: LD_VAR 0 1
50495: PUSH
50496: LD_VAR 0 4
50500: ARRAY
50501: PPUSH
50502: CALL_OW 2
50506: ST_TO_ADDR
// array := Delete ( array , index ) ;
50507: LD_ADDR_VAR 0 1
50511: PUSH
50512: LD_VAR 0 1
50516: PPUSH
50517: LD_VAR 0 4
50521: PPUSH
50522: CALL_OW 3
50526: ST_TO_ADDR
// end ;
50527: GO 50451
50529: POP
50530: POP
// end ;
50531: LD_VAR 0 2
50535: RET
// export function GetBaseMaterials ( base ) ; begin
50536: LD_INT 0
50538: PPUSH
// result := [ 0 , 0 , 0 ] ;
50539: LD_ADDR_VAR 0 2
50543: PUSH
50544: LD_INT 0
50546: PUSH
50547: LD_INT 0
50549: PUSH
50550: LD_INT 0
50552: PUSH
50553: EMPTY
50554: LIST
50555: LIST
50556: LIST
50557: ST_TO_ADDR
// if not base then
50558: LD_VAR 0 1
50562: NOT
50563: IFFALSE 50567
// exit ;
50565: GO 50616
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50567: LD_ADDR_VAR 0 2
50571: PUSH
50572: LD_VAR 0 1
50576: PPUSH
50577: LD_INT 1
50579: PPUSH
50580: CALL_OW 275
50584: PUSH
50585: LD_VAR 0 1
50589: PPUSH
50590: LD_INT 2
50592: PPUSH
50593: CALL_OW 275
50597: PUSH
50598: LD_VAR 0 1
50602: PPUSH
50603: LD_INT 3
50605: PPUSH
50606: CALL_OW 275
50610: PUSH
50611: EMPTY
50612: LIST
50613: LIST
50614: LIST
50615: ST_TO_ADDR
// end ;
50616: LD_VAR 0 2
50620: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50621: LD_INT 0
50623: PPUSH
50624: PPUSH
// result := array ;
50625: LD_ADDR_VAR 0 3
50629: PUSH
50630: LD_VAR 0 1
50634: ST_TO_ADDR
// if size > 0 then
50635: LD_VAR 0 2
50639: PUSH
50640: LD_INT 0
50642: GREATER
50643: IFFALSE 50689
// for i := array downto size do
50645: LD_ADDR_VAR 0 4
50649: PUSH
50650: DOUBLE
50651: LD_VAR 0 1
50655: INC
50656: ST_TO_ADDR
50657: LD_VAR 0 2
50661: PUSH
50662: FOR_DOWNTO
50663: IFFALSE 50687
// result := Delete ( result , result ) ;
50665: LD_ADDR_VAR 0 3
50669: PUSH
50670: LD_VAR 0 3
50674: PPUSH
50675: LD_VAR 0 3
50679: PPUSH
50680: CALL_OW 3
50684: ST_TO_ADDR
50685: GO 50662
50687: POP
50688: POP
// end ;
50689: LD_VAR 0 3
50693: RET
// export function ComExit ( unit ) ; var tmp ; begin
50694: LD_INT 0
50696: PPUSH
50697: PPUSH
// if not IsInUnit ( unit ) then
50698: LD_VAR 0 1
50702: PPUSH
50703: CALL_OW 310
50707: NOT
50708: IFFALSE 50712
// exit ;
50710: GO 50772
// tmp := IsInUnit ( unit ) ;
50712: LD_ADDR_VAR 0 3
50716: PUSH
50717: LD_VAR 0 1
50721: PPUSH
50722: CALL_OW 310
50726: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
50727: LD_VAR 0 3
50731: PPUSH
50732: CALL_OW 247
50736: PUSH
50737: LD_INT 2
50739: EQUAL
50740: IFFALSE 50753
// ComExitVehicle ( unit ) else
50742: LD_VAR 0 1
50746: PPUSH
50747: CALL_OW 121
50751: GO 50762
// ComExitBuilding ( unit ) ;
50753: LD_VAR 0 1
50757: PPUSH
50758: CALL_OW 122
// result := tmp ;
50762: LD_ADDR_VAR 0 2
50766: PUSH
50767: LD_VAR 0 3
50771: ST_TO_ADDR
// end ;
50772: LD_VAR 0 2
50776: RET
// export function ResetHc ; begin
50777: LD_INT 0
50779: PPUSH
// InitHc ;
50780: CALL_OW 19
// hc_importance := 0 ;
50784: LD_ADDR_OWVAR 32
50788: PUSH
50789: LD_INT 0
50791: ST_TO_ADDR
// end ;
50792: LD_VAR 0 1
50796: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
50797: LD_INT 0
50799: PPUSH
50800: PPUSH
50801: PPUSH
// _x := ( x1 + x2 ) div 2 ;
50802: LD_ADDR_VAR 0 6
50806: PUSH
50807: LD_VAR 0 1
50811: PUSH
50812: LD_VAR 0 3
50816: PLUS
50817: PUSH
50818: LD_INT 2
50820: DIV
50821: ST_TO_ADDR
// if _x < 0 then
50822: LD_VAR 0 6
50826: PUSH
50827: LD_INT 0
50829: LESS
50830: IFFALSE 50847
// _x := _x * - 1 ;
50832: LD_ADDR_VAR 0 6
50836: PUSH
50837: LD_VAR 0 6
50841: PUSH
50842: LD_INT 1
50844: NEG
50845: MUL
50846: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
50847: LD_ADDR_VAR 0 7
50851: PUSH
50852: LD_VAR 0 2
50856: PUSH
50857: LD_VAR 0 4
50861: PLUS
50862: PUSH
50863: LD_INT 2
50865: DIV
50866: ST_TO_ADDR
// if _y < 0 then
50867: LD_VAR 0 7
50871: PUSH
50872: LD_INT 0
50874: LESS
50875: IFFALSE 50892
// _y := _y * - 1 ;
50877: LD_ADDR_VAR 0 7
50881: PUSH
50882: LD_VAR 0 7
50886: PUSH
50887: LD_INT 1
50889: NEG
50890: MUL
50891: ST_TO_ADDR
// result := [ _x , _y ] ;
50892: LD_ADDR_VAR 0 5
50896: PUSH
50897: LD_VAR 0 6
50901: PUSH
50902: LD_VAR 0 7
50906: PUSH
50907: EMPTY
50908: LIST
50909: LIST
50910: ST_TO_ADDR
// end ;
50911: LD_VAR 0 5
50915: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50916: LD_INT 0
50918: PPUSH
50919: PPUSH
50920: PPUSH
50921: PPUSH
// task := GetTaskList ( unit ) ;
50922: LD_ADDR_VAR 0 7
50926: PUSH
50927: LD_VAR 0 1
50931: PPUSH
50932: CALL_OW 437
50936: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
50937: LD_VAR 0 7
50941: NOT
50942: PUSH
50943: LD_VAR 0 1
50947: PPUSH
50948: LD_VAR 0 2
50952: PPUSH
50953: CALL_OW 308
50957: NOT
50958: AND
50959: IFFALSE 50963
// exit ;
50961: GO 51081
// if IsInArea ( unit , area ) then
50963: LD_VAR 0 1
50967: PPUSH
50968: LD_VAR 0 2
50972: PPUSH
50973: CALL_OW 308
50977: IFFALSE 50995
// begin ComMoveToArea ( unit , goAway ) ;
50979: LD_VAR 0 1
50983: PPUSH
50984: LD_VAR 0 3
50988: PPUSH
50989: CALL_OW 113
// exit ;
50993: GO 51081
// end ; if task [ 1 ] [ 1 ] <> M then
50995: LD_VAR 0 7
50999: PUSH
51000: LD_INT 1
51002: ARRAY
51003: PUSH
51004: LD_INT 1
51006: ARRAY
51007: PUSH
51008: LD_STRING M
51010: NONEQUAL
51011: IFFALSE 51015
// exit ;
51013: GO 51081
// x := task [ 1 ] [ 2 ] ;
51015: LD_ADDR_VAR 0 5
51019: PUSH
51020: LD_VAR 0 7
51024: PUSH
51025: LD_INT 1
51027: ARRAY
51028: PUSH
51029: LD_INT 2
51031: ARRAY
51032: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51033: LD_ADDR_VAR 0 6
51037: PUSH
51038: LD_VAR 0 7
51042: PUSH
51043: LD_INT 1
51045: ARRAY
51046: PUSH
51047: LD_INT 3
51049: ARRAY
51050: ST_TO_ADDR
// if InArea ( x , y , area ) then
51051: LD_VAR 0 5
51055: PPUSH
51056: LD_VAR 0 6
51060: PPUSH
51061: LD_VAR 0 2
51065: PPUSH
51066: CALL_OW 309
51070: IFFALSE 51081
// ComStop ( unit ) ;
51072: LD_VAR 0 1
51076: PPUSH
51077: CALL_OW 141
// end ;
51081: LD_VAR 0 4
51085: RET
// export function Abs ( value ) ; begin
51086: LD_INT 0
51088: PPUSH
// result := value ;
51089: LD_ADDR_VAR 0 2
51093: PUSH
51094: LD_VAR 0 1
51098: ST_TO_ADDR
// if value < 0 then
51099: LD_VAR 0 1
51103: PUSH
51104: LD_INT 0
51106: LESS
51107: IFFALSE 51124
// result := value * - 1 ;
51109: LD_ADDR_VAR 0 2
51113: PUSH
51114: LD_VAR 0 1
51118: PUSH
51119: LD_INT 1
51121: NEG
51122: MUL
51123: ST_TO_ADDR
// end ;
51124: LD_VAR 0 2
51128: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51129: LD_INT 0
51131: PPUSH
51132: PPUSH
51133: PPUSH
51134: PPUSH
51135: PPUSH
51136: PPUSH
51137: PPUSH
51138: PPUSH
// if not unit or not building then
51139: LD_VAR 0 1
51143: NOT
51144: PUSH
51145: LD_VAR 0 2
51149: NOT
51150: OR
51151: IFFALSE 51155
// exit ;
51153: GO 51381
// x := GetX ( building ) ;
51155: LD_ADDR_VAR 0 4
51159: PUSH
51160: LD_VAR 0 2
51164: PPUSH
51165: CALL_OW 250
51169: ST_TO_ADDR
// y := GetY ( building ) ;
51170: LD_ADDR_VAR 0 6
51174: PUSH
51175: LD_VAR 0 2
51179: PPUSH
51180: CALL_OW 251
51184: ST_TO_ADDR
// d := GetDir ( building ) ;
51185: LD_ADDR_VAR 0 8
51189: PUSH
51190: LD_VAR 0 2
51194: PPUSH
51195: CALL_OW 254
51199: ST_TO_ADDR
// r := 4 ;
51200: LD_ADDR_VAR 0 9
51204: PUSH
51205: LD_INT 4
51207: ST_TO_ADDR
// for i := 1 to 5 do
51208: LD_ADDR_VAR 0 10
51212: PUSH
51213: DOUBLE
51214: LD_INT 1
51216: DEC
51217: ST_TO_ADDR
51218: LD_INT 5
51220: PUSH
51221: FOR_TO
51222: IFFALSE 51379
// begin _x := ShiftX ( x , d , r + i ) ;
51224: LD_ADDR_VAR 0 5
51228: PUSH
51229: LD_VAR 0 4
51233: PPUSH
51234: LD_VAR 0 8
51238: PPUSH
51239: LD_VAR 0 9
51243: PUSH
51244: LD_VAR 0 10
51248: PLUS
51249: PPUSH
51250: CALL_OW 272
51254: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
51255: LD_ADDR_VAR 0 7
51259: PUSH
51260: LD_VAR 0 6
51264: PPUSH
51265: LD_VAR 0 8
51269: PPUSH
51270: LD_VAR 0 9
51274: PUSH
51275: LD_VAR 0 10
51279: PLUS
51280: PPUSH
51281: CALL_OW 273
51285: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
51286: LD_VAR 0 5
51290: PPUSH
51291: LD_VAR 0 7
51295: PPUSH
51296: CALL_OW 488
51300: PUSH
51301: LD_VAR 0 5
51305: PPUSH
51306: LD_VAR 0 7
51310: PPUSH
51311: CALL_OW 428
51315: PPUSH
51316: CALL_OW 247
51320: PUSH
51321: LD_INT 3
51323: PUSH
51324: LD_INT 2
51326: PUSH
51327: EMPTY
51328: LIST
51329: LIST
51330: IN
51331: NOT
51332: AND
51333: IFFALSE 51377
// begin ComMoveXY ( unit , _x , _y ) ;
51335: LD_VAR 0 1
51339: PPUSH
51340: LD_VAR 0 5
51344: PPUSH
51345: LD_VAR 0 7
51349: PPUSH
51350: CALL_OW 111
// result := [ _x , _y ] ;
51354: LD_ADDR_VAR 0 3
51358: PUSH
51359: LD_VAR 0 5
51363: PUSH
51364: LD_VAR 0 7
51368: PUSH
51369: EMPTY
51370: LIST
51371: LIST
51372: ST_TO_ADDR
// exit ;
51373: POP
51374: POP
51375: GO 51381
// end ; end ;
51377: GO 51221
51379: POP
51380: POP
// end ; end_of_file
51381: LD_VAR 0 3
51385: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
51386: LD_INT 0
51388: PPUSH
51389: PPUSH
// skirmish := false ;
51390: LD_ADDR_EXP 57
51394: PUSH
51395: LD_INT 0
51397: ST_TO_ADDR
// debug_mc := false ;
51398: LD_ADDR_EXP 58
51402: PUSH
51403: LD_INT 0
51405: ST_TO_ADDR
// mc_bases := [ ] ;
51406: LD_ADDR_EXP 59
51410: PUSH
51411: EMPTY
51412: ST_TO_ADDR
// mc_sides := [ ] ;
51413: LD_ADDR_EXP 85
51417: PUSH
51418: EMPTY
51419: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51420: LD_ADDR_EXP 60
51424: PUSH
51425: EMPTY
51426: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51427: LD_ADDR_EXP 61
51431: PUSH
51432: EMPTY
51433: ST_TO_ADDR
// mc_need_heal := [ ] ;
51434: LD_ADDR_EXP 62
51438: PUSH
51439: EMPTY
51440: ST_TO_ADDR
// mc_healers := [ ] ;
51441: LD_ADDR_EXP 63
51445: PUSH
51446: EMPTY
51447: ST_TO_ADDR
// mc_build_list := [ ] ;
51448: LD_ADDR_EXP 64
51452: PUSH
51453: EMPTY
51454: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51455: LD_ADDR_EXP 91
51459: PUSH
51460: EMPTY
51461: ST_TO_ADDR
// mc_builders := [ ] ;
51462: LD_ADDR_EXP 65
51466: PUSH
51467: EMPTY
51468: ST_TO_ADDR
// mc_construct_list := [ ] ;
51469: LD_ADDR_EXP 66
51473: PUSH
51474: EMPTY
51475: ST_TO_ADDR
// mc_turret_list := [ ] ;
51476: LD_ADDR_EXP 67
51480: PUSH
51481: EMPTY
51482: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51483: LD_ADDR_EXP 68
51487: PUSH
51488: EMPTY
51489: ST_TO_ADDR
// mc_miners := [ ] ;
51490: LD_ADDR_EXP 73
51494: PUSH
51495: EMPTY
51496: ST_TO_ADDR
// mc_mines := [ ] ;
51497: LD_ADDR_EXP 72
51501: PUSH
51502: EMPTY
51503: ST_TO_ADDR
// mc_minefields := [ ] ;
51504: LD_ADDR_EXP 74
51508: PUSH
51509: EMPTY
51510: ST_TO_ADDR
// mc_crates := [ ] ;
51511: LD_ADDR_EXP 75
51515: PUSH
51516: EMPTY
51517: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51518: LD_ADDR_EXP 76
51522: PUSH
51523: EMPTY
51524: ST_TO_ADDR
// mc_crates_area := [ ] ;
51525: LD_ADDR_EXP 77
51529: PUSH
51530: EMPTY
51531: ST_TO_ADDR
// mc_vehicles := [ ] ;
51532: LD_ADDR_EXP 78
51536: PUSH
51537: EMPTY
51538: ST_TO_ADDR
// mc_attack := [ ] ;
51539: LD_ADDR_EXP 79
51543: PUSH
51544: EMPTY
51545: ST_TO_ADDR
// mc_produce := [ ] ;
51546: LD_ADDR_EXP 80
51550: PUSH
51551: EMPTY
51552: ST_TO_ADDR
// mc_defender := [ ] ;
51553: LD_ADDR_EXP 81
51557: PUSH
51558: EMPTY
51559: ST_TO_ADDR
// mc_parking := [ ] ;
51560: LD_ADDR_EXP 83
51564: PUSH
51565: EMPTY
51566: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51567: LD_ADDR_EXP 69
51571: PUSH
51572: EMPTY
51573: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51574: LD_ADDR_EXP 71
51578: PUSH
51579: EMPTY
51580: ST_TO_ADDR
// mc_scan := [ ] ;
51581: LD_ADDR_EXP 82
51585: PUSH
51586: EMPTY
51587: ST_TO_ADDR
// mc_scan_area := [ ] ;
51588: LD_ADDR_EXP 84
51592: PUSH
51593: EMPTY
51594: ST_TO_ADDR
// mc_tech := [ ] ;
51595: LD_ADDR_EXP 86
51599: PUSH
51600: EMPTY
51601: ST_TO_ADDR
// mc_class := [ ] ;
51602: LD_ADDR_EXP 100
51606: PUSH
51607: EMPTY
51608: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51609: LD_ADDR_EXP 101
51613: PUSH
51614: EMPTY
51615: ST_TO_ADDR
// end ;
51616: LD_VAR 0 1
51620: RET
// export function MC_Kill ( base ) ; begin
51621: LD_INT 0
51623: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51624: LD_ADDR_EXP 59
51628: PUSH
51629: LD_EXP 59
51633: PPUSH
51634: LD_VAR 0 1
51638: PPUSH
51639: EMPTY
51640: PPUSH
51641: CALL_OW 1
51645: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51646: LD_ADDR_EXP 60
51650: PUSH
51651: LD_EXP 60
51655: PPUSH
51656: LD_VAR 0 1
51660: PPUSH
51661: EMPTY
51662: PPUSH
51663: CALL_OW 1
51667: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51668: LD_ADDR_EXP 61
51672: PUSH
51673: LD_EXP 61
51677: PPUSH
51678: LD_VAR 0 1
51682: PPUSH
51683: EMPTY
51684: PPUSH
51685: CALL_OW 1
51689: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51690: LD_ADDR_EXP 62
51694: PUSH
51695: LD_EXP 62
51699: PPUSH
51700: LD_VAR 0 1
51704: PPUSH
51705: EMPTY
51706: PPUSH
51707: CALL_OW 1
51711: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51712: LD_ADDR_EXP 63
51716: PUSH
51717: LD_EXP 63
51721: PPUSH
51722: LD_VAR 0 1
51726: PPUSH
51727: EMPTY
51728: PPUSH
51729: CALL_OW 1
51733: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51734: LD_ADDR_EXP 64
51738: PUSH
51739: LD_EXP 64
51743: PPUSH
51744: LD_VAR 0 1
51748: PPUSH
51749: EMPTY
51750: PPUSH
51751: CALL_OW 1
51755: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51756: LD_ADDR_EXP 65
51760: PUSH
51761: LD_EXP 65
51765: PPUSH
51766: LD_VAR 0 1
51770: PPUSH
51771: EMPTY
51772: PPUSH
51773: CALL_OW 1
51777: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51778: LD_ADDR_EXP 66
51782: PUSH
51783: LD_EXP 66
51787: PPUSH
51788: LD_VAR 0 1
51792: PPUSH
51793: EMPTY
51794: PPUSH
51795: CALL_OW 1
51799: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51800: LD_ADDR_EXP 67
51804: PUSH
51805: LD_EXP 67
51809: PPUSH
51810: LD_VAR 0 1
51814: PPUSH
51815: EMPTY
51816: PPUSH
51817: CALL_OW 1
51821: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51822: LD_ADDR_EXP 68
51826: PUSH
51827: LD_EXP 68
51831: PPUSH
51832: LD_VAR 0 1
51836: PPUSH
51837: EMPTY
51838: PPUSH
51839: CALL_OW 1
51843: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51844: LD_ADDR_EXP 69
51848: PUSH
51849: LD_EXP 69
51853: PPUSH
51854: LD_VAR 0 1
51858: PPUSH
51859: EMPTY
51860: PPUSH
51861: CALL_OW 1
51865: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51866: LD_ADDR_EXP 70
51870: PUSH
51871: LD_EXP 70
51875: PPUSH
51876: LD_VAR 0 1
51880: PPUSH
51881: LD_INT 0
51883: PPUSH
51884: CALL_OW 1
51888: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51889: LD_ADDR_EXP 71
51893: PUSH
51894: LD_EXP 71
51898: PPUSH
51899: LD_VAR 0 1
51903: PPUSH
51904: EMPTY
51905: PPUSH
51906: CALL_OW 1
51910: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51911: LD_ADDR_EXP 72
51915: PUSH
51916: LD_EXP 72
51920: PPUSH
51921: LD_VAR 0 1
51925: PPUSH
51926: EMPTY
51927: PPUSH
51928: CALL_OW 1
51932: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51933: LD_ADDR_EXP 73
51937: PUSH
51938: LD_EXP 73
51942: PPUSH
51943: LD_VAR 0 1
51947: PPUSH
51948: EMPTY
51949: PPUSH
51950: CALL_OW 1
51954: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51955: LD_ADDR_EXP 74
51959: PUSH
51960: LD_EXP 74
51964: PPUSH
51965: LD_VAR 0 1
51969: PPUSH
51970: EMPTY
51971: PPUSH
51972: CALL_OW 1
51976: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51977: LD_ADDR_EXP 75
51981: PUSH
51982: LD_EXP 75
51986: PPUSH
51987: LD_VAR 0 1
51991: PPUSH
51992: EMPTY
51993: PPUSH
51994: CALL_OW 1
51998: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51999: LD_ADDR_EXP 76
52003: PUSH
52004: LD_EXP 76
52008: PPUSH
52009: LD_VAR 0 1
52013: PPUSH
52014: EMPTY
52015: PPUSH
52016: CALL_OW 1
52020: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52021: LD_ADDR_EXP 77
52025: PUSH
52026: LD_EXP 77
52030: PPUSH
52031: LD_VAR 0 1
52035: PPUSH
52036: EMPTY
52037: PPUSH
52038: CALL_OW 1
52042: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52043: LD_ADDR_EXP 78
52047: PUSH
52048: LD_EXP 78
52052: PPUSH
52053: LD_VAR 0 1
52057: PPUSH
52058: EMPTY
52059: PPUSH
52060: CALL_OW 1
52064: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52065: LD_ADDR_EXP 79
52069: PUSH
52070: LD_EXP 79
52074: PPUSH
52075: LD_VAR 0 1
52079: PPUSH
52080: EMPTY
52081: PPUSH
52082: CALL_OW 1
52086: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52087: LD_ADDR_EXP 80
52091: PUSH
52092: LD_EXP 80
52096: PPUSH
52097: LD_VAR 0 1
52101: PPUSH
52102: EMPTY
52103: PPUSH
52104: CALL_OW 1
52108: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52109: LD_ADDR_EXP 81
52113: PUSH
52114: LD_EXP 81
52118: PPUSH
52119: LD_VAR 0 1
52123: PPUSH
52124: EMPTY
52125: PPUSH
52126: CALL_OW 1
52130: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52131: LD_ADDR_EXP 82
52135: PUSH
52136: LD_EXP 82
52140: PPUSH
52141: LD_VAR 0 1
52145: PPUSH
52146: EMPTY
52147: PPUSH
52148: CALL_OW 1
52152: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52153: LD_ADDR_EXP 83
52157: PUSH
52158: LD_EXP 83
52162: PPUSH
52163: LD_VAR 0 1
52167: PPUSH
52168: EMPTY
52169: PPUSH
52170: CALL_OW 1
52174: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52175: LD_ADDR_EXP 84
52179: PUSH
52180: LD_EXP 84
52184: PPUSH
52185: LD_VAR 0 1
52189: PPUSH
52190: EMPTY
52191: PPUSH
52192: CALL_OW 1
52196: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52197: LD_ADDR_EXP 86
52201: PUSH
52202: LD_EXP 86
52206: PPUSH
52207: LD_VAR 0 1
52211: PPUSH
52212: EMPTY
52213: PPUSH
52214: CALL_OW 1
52218: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52219: LD_ADDR_EXP 88
52223: PUSH
52224: LD_EXP 88
52228: PPUSH
52229: LD_VAR 0 1
52233: PPUSH
52234: EMPTY
52235: PPUSH
52236: CALL_OW 1
52240: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52241: LD_ADDR_EXP 89
52245: PUSH
52246: LD_EXP 89
52250: PPUSH
52251: LD_VAR 0 1
52255: PPUSH
52256: EMPTY
52257: PPUSH
52258: CALL_OW 1
52262: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52263: LD_ADDR_EXP 90
52267: PUSH
52268: LD_EXP 90
52272: PPUSH
52273: LD_VAR 0 1
52277: PPUSH
52278: EMPTY
52279: PPUSH
52280: CALL_OW 1
52284: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52285: LD_ADDR_EXP 91
52289: PUSH
52290: LD_EXP 91
52294: PPUSH
52295: LD_VAR 0 1
52299: PPUSH
52300: EMPTY
52301: PPUSH
52302: CALL_OW 1
52306: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52307: LD_ADDR_EXP 92
52311: PUSH
52312: LD_EXP 92
52316: PPUSH
52317: LD_VAR 0 1
52321: PPUSH
52322: EMPTY
52323: PPUSH
52324: CALL_OW 1
52328: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52329: LD_ADDR_EXP 93
52333: PUSH
52334: LD_EXP 93
52338: PPUSH
52339: LD_VAR 0 1
52343: PPUSH
52344: EMPTY
52345: PPUSH
52346: CALL_OW 1
52350: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52351: LD_ADDR_EXP 94
52355: PUSH
52356: LD_EXP 94
52360: PPUSH
52361: LD_VAR 0 1
52365: PPUSH
52366: EMPTY
52367: PPUSH
52368: CALL_OW 1
52372: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52373: LD_ADDR_EXP 95
52377: PUSH
52378: LD_EXP 95
52382: PPUSH
52383: LD_VAR 0 1
52387: PPUSH
52388: EMPTY
52389: PPUSH
52390: CALL_OW 1
52394: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52395: LD_ADDR_EXP 96
52399: PUSH
52400: LD_EXP 96
52404: PPUSH
52405: LD_VAR 0 1
52409: PPUSH
52410: EMPTY
52411: PPUSH
52412: CALL_OW 1
52416: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52417: LD_ADDR_EXP 97
52421: PUSH
52422: LD_EXP 97
52426: PPUSH
52427: LD_VAR 0 1
52431: PPUSH
52432: EMPTY
52433: PPUSH
52434: CALL_OW 1
52438: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52439: LD_ADDR_EXP 98
52443: PUSH
52444: LD_EXP 98
52448: PPUSH
52449: LD_VAR 0 1
52453: PPUSH
52454: EMPTY
52455: PPUSH
52456: CALL_OW 1
52460: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52461: LD_ADDR_EXP 99
52465: PUSH
52466: LD_EXP 99
52470: PPUSH
52471: LD_VAR 0 1
52475: PPUSH
52476: EMPTY
52477: PPUSH
52478: CALL_OW 1
52482: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52483: LD_ADDR_EXP 100
52487: PUSH
52488: LD_EXP 100
52492: PPUSH
52493: LD_VAR 0 1
52497: PPUSH
52498: EMPTY
52499: PPUSH
52500: CALL_OW 1
52504: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52505: LD_ADDR_EXP 101
52509: PUSH
52510: LD_EXP 101
52514: PPUSH
52515: LD_VAR 0 1
52519: PPUSH
52520: LD_INT 0
52522: PPUSH
52523: CALL_OW 1
52527: ST_TO_ADDR
// end ;
52528: LD_VAR 0 2
52532: RET
// export function MC_Add ( side , units ) ; var base ; begin
52533: LD_INT 0
52535: PPUSH
52536: PPUSH
// base := mc_bases + 1 ;
52537: LD_ADDR_VAR 0 4
52541: PUSH
52542: LD_EXP 59
52546: PUSH
52547: LD_INT 1
52549: PLUS
52550: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52551: LD_ADDR_EXP 85
52555: PUSH
52556: LD_EXP 85
52560: PPUSH
52561: LD_VAR 0 4
52565: PPUSH
52566: LD_VAR 0 1
52570: PPUSH
52571: CALL_OW 1
52575: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52576: LD_ADDR_EXP 59
52580: PUSH
52581: LD_EXP 59
52585: PPUSH
52586: LD_VAR 0 4
52590: PPUSH
52591: LD_VAR 0 2
52595: PPUSH
52596: CALL_OW 1
52600: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52601: LD_ADDR_EXP 60
52605: PUSH
52606: LD_EXP 60
52610: PPUSH
52611: LD_VAR 0 4
52615: PPUSH
52616: EMPTY
52617: PPUSH
52618: CALL_OW 1
52622: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52623: LD_ADDR_EXP 61
52627: PUSH
52628: LD_EXP 61
52632: PPUSH
52633: LD_VAR 0 4
52637: PPUSH
52638: EMPTY
52639: PPUSH
52640: CALL_OW 1
52644: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52645: LD_ADDR_EXP 62
52649: PUSH
52650: LD_EXP 62
52654: PPUSH
52655: LD_VAR 0 4
52659: PPUSH
52660: EMPTY
52661: PPUSH
52662: CALL_OW 1
52666: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52667: LD_ADDR_EXP 63
52671: PUSH
52672: LD_EXP 63
52676: PPUSH
52677: LD_VAR 0 4
52681: PPUSH
52682: EMPTY
52683: PPUSH
52684: CALL_OW 1
52688: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52689: LD_ADDR_EXP 64
52693: PUSH
52694: LD_EXP 64
52698: PPUSH
52699: LD_VAR 0 4
52703: PPUSH
52704: EMPTY
52705: PPUSH
52706: CALL_OW 1
52710: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52711: LD_ADDR_EXP 65
52715: PUSH
52716: LD_EXP 65
52720: PPUSH
52721: LD_VAR 0 4
52725: PPUSH
52726: EMPTY
52727: PPUSH
52728: CALL_OW 1
52732: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52733: LD_ADDR_EXP 66
52737: PUSH
52738: LD_EXP 66
52742: PPUSH
52743: LD_VAR 0 4
52747: PPUSH
52748: EMPTY
52749: PPUSH
52750: CALL_OW 1
52754: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52755: LD_ADDR_EXP 67
52759: PUSH
52760: LD_EXP 67
52764: PPUSH
52765: LD_VAR 0 4
52769: PPUSH
52770: EMPTY
52771: PPUSH
52772: CALL_OW 1
52776: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52777: LD_ADDR_EXP 68
52781: PUSH
52782: LD_EXP 68
52786: PPUSH
52787: LD_VAR 0 4
52791: PPUSH
52792: EMPTY
52793: PPUSH
52794: CALL_OW 1
52798: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52799: LD_ADDR_EXP 69
52803: PUSH
52804: LD_EXP 69
52808: PPUSH
52809: LD_VAR 0 4
52813: PPUSH
52814: EMPTY
52815: PPUSH
52816: CALL_OW 1
52820: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52821: LD_ADDR_EXP 70
52825: PUSH
52826: LD_EXP 70
52830: PPUSH
52831: LD_VAR 0 4
52835: PPUSH
52836: LD_INT 0
52838: PPUSH
52839: CALL_OW 1
52843: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52844: LD_ADDR_EXP 71
52848: PUSH
52849: LD_EXP 71
52853: PPUSH
52854: LD_VAR 0 4
52858: PPUSH
52859: EMPTY
52860: PPUSH
52861: CALL_OW 1
52865: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52866: LD_ADDR_EXP 72
52870: PUSH
52871: LD_EXP 72
52875: PPUSH
52876: LD_VAR 0 4
52880: PPUSH
52881: EMPTY
52882: PPUSH
52883: CALL_OW 1
52887: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52888: LD_ADDR_EXP 73
52892: PUSH
52893: LD_EXP 73
52897: PPUSH
52898: LD_VAR 0 4
52902: PPUSH
52903: EMPTY
52904: PPUSH
52905: CALL_OW 1
52909: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52910: LD_ADDR_EXP 74
52914: PUSH
52915: LD_EXP 74
52919: PPUSH
52920: LD_VAR 0 4
52924: PPUSH
52925: EMPTY
52926: PPUSH
52927: CALL_OW 1
52931: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52932: LD_ADDR_EXP 75
52936: PUSH
52937: LD_EXP 75
52941: PPUSH
52942: LD_VAR 0 4
52946: PPUSH
52947: EMPTY
52948: PPUSH
52949: CALL_OW 1
52953: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52954: LD_ADDR_EXP 76
52958: PUSH
52959: LD_EXP 76
52963: PPUSH
52964: LD_VAR 0 4
52968: PPUSH
52969: EMPTY
52970: PPUSH
52971: CALL_OW 1
52975: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52976: LD_ADDR_EXP 77
52980: PUSH
52981: LD_EXP 77
52985: PPUSH
52986: LD_VAR 0 4
52990: PPUSH
52991: EMPTY
52992: PPUSH
52993: CALL_OW 1
52997: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52998: LD_ADDR_EXP 78
53002: PUSH
53003: LD_EXP 78
53007: PPUSH
53008: LD_VAR 0 4
53012: PPUSH
53013: EMPTY
53014: PPUSH
53015: CALL_OW 1
53019: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53020: LD_ADDR_EXP 79
53024: PUSH
53025: LD_EXP 79
53029: PPUSH
53030: LD_VAR 0 4
53034: PPUSH
53035: EMPTY
53036: PPUSH
53037: CALL_OW 1
53041: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53042: LD_ADDR_EXP 80
53046: PUSH
53047: LD_EXP 80
53051: PPUSH
53052: LD_VAR 0 4
53056: PPUSH
53057: EMPTY
53058: PPUSH
53059: CALL_OW 1
53063: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53064: LD_ADDR_EXP 81
53068: PUSH
53069: LD_EXP 81
53073: PPUSH
53074: LD_VAR 0 4
53078: PPUSH
53079: EMPTY
53080: PPUSH
53081: CALL_OW 1
53085: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53086: LD_ADDR_EXP 82
53090: PUSH
53091: LD_EXP 82
53095: PPUSH
53096: LD_VAR 0 4
53100: PPUSH
53101: EMPTY
53102: PPUSH
53103: CALL_OW 1
53107: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53108: LD_ADDR_EXP 83
53112: PUSH
53113: LD_EXP 83
53117: PPUSH
53118: LD_VAR 0 4
53122: PPUSH
53123: EMPTY
53124: PPUSH
53125: CALL_OW 1
53129: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53130: LD_ADDR_EXP 84
53134: PUSH
53135: LD_EXP 84
53139: PPUSH
53140: LD_VAR 0 4
53144: PPUSH
53145: EMPTY
53146: PPUSH
53147: CALL_OW 1
53151: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53152: LD_ADDR_EXP 86
53156: PUSH
53157: LD_EXP 86
53161: PPUSH
53162: LD_VAR 0 4
53166: PPUSH
53167: EMPTY
53168: PPUSH
53169: CALL_OW 1
53173: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53174: LD_ADDR_EXP 88
53178: PUSH
53179: LD_EXP 88
53183: PPUSH
53184: LD_VAR 0 4
53188: PPUSH
53189: EMPTY
53190: PPUSH
53191: CALL_OW 1
53195: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53196: LD_ADDR_EXP 89
53200: PUSH
53201: LD_EXP 89
53205: PPUSH
53206: LD_VAR 0 4
53210: PPUSH
53211: EMPTY
53212: PPUSH
53213: CALL_OW 1
53217: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53218: LD_ADDR_EXP 90
53222: PUSH
53223: LD_EXP 90
53227: PPUSH
53228: LD_VAR 0 4
53232: PPUSH
53233: EMPTY
53234: PPUSH
53235: CALL_OW 1
53239: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53240: LD_ADDR_EXP 91
53244: PUSH
53245: LD_EXP 91
53249: PPUSH
53250: LD_VAR 0 4
53254: PPUSH
53255: EMPTY
53256: PPUSH
53257: CALL_OW 1
53261: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53262: LD_ADDR_EXP 92
53266: PUSH
53267: LD_EXP 92
53271: PPUSH
53272: LD_VAR 0 4
53276: PPUSH
53277: EMPTY
53278: PPUSH
53279: CALL_OW 1
53283: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53284: LD_ADDR_EXP 93
53288: PUSH
53289: LD_EXP 93
53293: PPUSH
53294: LD_VAR 0 4
53298: PPUSH
53299: EMPTY
53300: PPUSH
53301: CALL_OW 1
53305: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53306: LD_ADDR_EXP 94
53310: PUSH
53311: LD_EXP 94
53315: PPUSH
53316: LD_VAR 0 4
53320: PPUSH
53321: EMPTY
53322: PPUSH
53323: CALL_OW 1
53327: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53328: LD_ADDR_EXP 95
53332: PUSH
53333: LD_EXP 95
53337: PPUSH
53338: LD_VAR 0 4
53342: PPUSH
53343: EMPTY
53344: PPUSH
53345: CALL_OW 1
53349: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53350: LD_ADDR_EXP 96
53354: PUSH
53355: LD_EXP 96
53359: PPUSH
53360: LD_VAR 0 4
53364: PPUSH
53365: EMPTY
53366: PPUSH
53367: CALL_OW 1
53371: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53372: LD_ADDR_EXP 97
53376: PUSH
53377: LD_EXP 97
53381: PPUSH
53382: LD_VAR 0 4
53386: PPUSH
53387: EMPTY
53388: PPUSH
53389: CALL_OW 1
53393: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53394: LD_ADDR_EXP 98
53398: PUSH
53399: LD_EXP 98
53403: PPUSH
53404: LD_VAR 0 4
53408: PPUSH
53409: EMPTY
53410: PPUSH
53411: CALL_OW 1
53415: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53416: LD_ADDR_EXP 99
53420: PUSH
53421: LD_EXP 99
53425: PPUSH
53426: LD_VAR 0 4
53430: PPUSH
53431: EMPTY
53432: PPUSH
53433: CALL_OW 1
53437: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53438: LD_ADDR_EXP 100
53442: PUSH
53443: LD_EXP 100
53447: PPUSH
53448: LD_VAR 0 4
53452: PPUSH
53453: EMPTY
53454: PPUSH
53455: CALL_OW 1
53459: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53460: LD_ADDR_EXP 101
53464: PUSH
53465: LD_EXP 101
53469: PPUSH
53470: LD_VAR 0 4
53474: PPUSH
53475: LD_INT 0
53477: PPUSH
53478: CALL_OW 1
53482: ST_TO_ADDR
// result := base ;
53483: LD_ADDR_VAR 0 3
53487: PUSH
53488: LD_VAR 0 4
53492: ST_TO_ADDR
// end ;
53493: LD_VAR 0 3
53497: RET
// export function MC_Start ( ) ; var i ; begin
53498: LD_INT 0
53500: PPUSH
53501: PPUSH
// for i = 1 to mc_bases do
53502: LD_ADDR_VAR 0 2
53506: PUSH
53507: DOUBLE
53508: LD_INT 1
53510: DEC
53511: ST_TO_ADDR
53512: LD_EXP 59
53516: PUSH
53517: FOR_TO
53518: IFFALSE 54595
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53520: LD_ADDR_EXP 59
53524: PUSH
53525: LD_EXP 59
53529: PPUSH
53530: LD_VAR 0 2
53534: PPUSH
53535: LD_EXP 59
53539: PUSH
53540: LD_VAR 0 2
53544: ARRAY
53545: PUSH
53546: LD_INT 0
53548: DIFF
53549: PPUSH
53550: CALL_OW 1
53554: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53555: LD_ADDR_EXP 60
53559: PUSH
53560: LD_EXP 60
53564: PPUSH
53565: LD_VAR 0 2
53569: PPUSH
53570: EMPTY
53571: PPUSH
53572: CALL_OW 1
53576: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53577: LD_ADDR_EXP 61
53581: PUSH
53582: LD_EXP 61
53586: PPUSH
53587: LD_VAR 0 2
53591: PPUSH
53592: EMPTY
53593: PPUSH
53594: CALL_OW 1
53598: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53599: LD_ADDR_EXP 62
53603: PUSH
53604: LD_EXP 62
53608: PPUSH
53609: LD_VAR 0 2
53613: PPUSH
53614: EMPTY
53615: PPUSH
53616: CALL_OW 1
53620: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53621: LD_ADDR_EXP 63
53625: PUSH
53626: LD_EXP 63
53630: PPUSH
53631: LD_VAR 0 2
53635: PPUSH
53636: EMPTY
53637: PUSH
53638: EMPTY
53639: PUSH
53640: EMPTY
53641: LIST
53642: LIST
53643: PPUSH
53644: CALL_OW 1
53648: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53649: LD_ADDR_EXP 64
53653: PUSH
53654: LD_EXP 64
53658: PPUSH
53659: LD_VAR 0 2
53663: PPUSH
53664: EMPTY
53665: PPUSH
53666: CALL_OW 1
53670: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53671: LD_ADDR_EXP 91
53675: PUSH
53676: LD_EXP 91
53680: PPUSH
53681: LD_VAR 0 2
53685: PPUSH
53686: EMPTY
53687: PPUSH
53688: CALL_OW 1
53692: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53693: LD_ADDR_EXP 65
53697: PUSH
53698: LD_EXP 65
53702: PPUSH
53703: LD_VAR 0 2
53707: PPUSH
53708: EMPTY
53709: PPUSH
53710: CALL_OW 1
53714: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53715: LD_ADDR_EXP 66
53719: PUSH
53720: LD_EXP 66
53724: PPUSH
53725: LD_VAR 0 2
53729: PPUSH
53730: EMPTY
53731: PPUSH
53732: CALL_OW 1
53736: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53737: LD_ADDR_EXP 67
53741: PUSH
53742: LD_EXP 67
53746: PPUSH
53747: LD_VAR 0 2
53751: PPUSH
53752: LD_EXP 59
53756: PUSH
53757: LD_VAR 0 2
53761: ARRAY
53762: PPUSH
53763: LD_INT 2
53765: PUSH
53766: LD_INT 30
53768: PUSH
53769: LD_INT 32
53771: PUSH
53772: EMPTY
53773: LIST
53774: LIST
53775: PUSH
53776: LD_INT 30
53778: PUSH
53779: LD_INT 33
53781: PUSH
53782: EMPTY
53783: LIST
53784: LIST
53785: PUSH
53786: EMPTY
53787: LIST
53788: LIST
53789: LIST
53790: PPUSH
53791: CALL_OW 72
53795: PPUSH
53796: CALL_OW 1
53800: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53801: LD_ADDR_EXP 68
53805: PUSH
53806: LD_EXP 68
53810: PPUSH
53811: LD_VAR 0 2
53815: PPUSH
53816: LD_EXP 59
53820: PUSH
53821: LD_VAR 0 2
53825: ARRAY
53826: PPUSH
53827: LD_INT 2
53829: PUSH
53830: LD_INT 30
53832: PUSH
53833: LD_INT 32
53835: PUSH
53836: EMPTY
53837: LIST
53838: LIST
53839: PUSH
53840: LD_INT 30
53842: PUSH
53843: LD_INT 31
53845: PUSH
53846: EMPTY
53847: LIST
53848: LIST
53849: PUSH
53850: EMPTY
53851: LIST
53852: LIST
53853: LIST
53854: PUSH
53855: LD_INT 58
53857: PUSH
53858: EMPTY
53859: LIST
53860: PUSH
53861: EMPTY
53862: LIST
53863: LIST
53864: PPUSH
53865: CALL_OW 72
53869: PPUSH
53870: CALL_OW 1
53874: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53875: LD_ADDR_EXP 69
53879: PUSH
53880: LD_EXP 69
53884: PPUSH
53885: LD_VAR 0 2
53889: PPUSH
53890: EMPTY
53891: PPUSH
53892: CALL_OW 1
53896: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53897: LD_ADDR_EXP 73
53901: PUSH
53902: LD_EXP 73
53906: PPUSH
53907: LD_VAR 0 2
53911: PPUSH
53912: EMPTY
53913: PPUSH
53914: CALL_OW 1
53918: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53919: LD_ADDR_EXP 72
53923: PUSH
53924: LD_EXP 72
53928: PPUSH
53929: LD_VAR 0 2
53933: PPUSH
53934: EMPTY
53935: PPUSH
53936: CALL_OW 1
53940: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53941: LD_ADDR_EXP 74
53945: PUSH
53946: LD_EXP 74
53950: PPUSH
53951: LD_VAR 0 2
53955: PPUSH
53956: EMPTY
53957: PPUSH
53958: CALL_OW 1
53962: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53963: LD_ADDR_EXP 75
53967: PUSH
53968: LD_EXP 75
53972: PPUSH
53973: LD_VAR 0 2
53977: PPUSH
53978: EMPTY
53979: PPUSH
53980: CALL_OW 1
53984: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53985: LD_ADDR_EXP 76
53989: PUSH
53990: LD_EXP 76
53994: PPUSH
53995: LD_VAR 0 2
53999: PPUSH
54000: EMPTY
54001: PPUSH
54002: CALL_OW 1
54006: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
54007: LD_ADDR_EXP 77
54011: PUSH
54012: LD_EXP 77
54016: PPUSH
54017: LD_VAR 0 2
54021: PPUSH
54022: EMPTY
54023: PPUSH
54024: CALL_OW 1
54028: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
54029: LD_ADDR_EXP 78
54033: PUSH
54034: LD_EXP 78
54038: PPUSH
54039: LD_VAR 0 2
54043: PPUSH
54044: EMPTY
54045: PPUSH
54046: CALL_OW 1
54050: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54051: LD_ADDR_EXP 79
54055: PUSH
54056: LD_EXP 79
54060: PPUSH
54061: LD_VAR 0 2
54065: PPUSH
54066: EMPTY
54067: PPUSH
54068: CALL_OW 1
54072: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54073: LD_ADDR_EXP 80
54077: PUSH
54078: LD_EXP 80
54082: PPUSH
54083: LD_VAR 0 2
54087: PPUSH
54088: EMPTY
54089: PPUSH
54090: CALL_OW 1
54094: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54095: LD_ADDR_EXP 81
54099: PUSH
54100: LD_EXP 81
54104: PPUSH
54105: LD_VAR 0 2
54109: PPUSH
54110: EMPTY
54111: PPUSH
54112: CALL_OW 1
54116: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54117: LD_ADDR_EXP 70
54121: PUSH
54122: LD_EXP 70
54126: PPUSH
54127: LD_VAR 0 2
54131: PPUSH
54132: LD_INT 0
54134: PPUSH
54135: CALL_OW 1
54139: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
54140: LD_ADDR_EXP 83
54144: PUSH
54145: LD_EXP 83
54149: PPUSH
54150: LD_VAR 0 2
54154: PPUSH
54155: LD_INT 0
54157: PPUSH
54158: CALL_OW 1
54162: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54163: LD_ADDR_EXP 71
54167: PUSH
54168: LD_EXP 71
54172: PPUSH
54173: LD_VAR 0 2
54177: PPUSH
54178: EMPTY
54179: PPUSH
54180: CALL_OW 1
54184: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
54185: LD_ADDR_EXP 82
54189: PUSH
54190: LD_EXP 82
54194: PPUSH
54195: LD_VAR 0 2
54199: PPUSH
54200: LD_INT 0
54202: PPUSH
54203: CALL_OW 1
54207: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
54208: LD_ADDR_EXP 84
54212: PUSH
54213: LD_EXP 84
54217: PPUSH
54218: LD_VAR 0 2
54222: PPUSH
54223: EMPTY
54224: PPUSH
54225: CALL_OW 1
54229: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
54230: LD_ADDR_EXP 87
54234: PUSH
54235: LD_EXP 87
54239: PPUSH
54240: LD_VAR 0 2
54244: PPUSH
54245: LD_INT 0
54247: PPUSH
54248: CALL_OW 1
54252: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54253: LD_ADDR_EXP 88
54257: PUSH
54258: LD_EXP 88
54262: PPUSH
54263: LD_VAR 0 2
54267: PPUSH
54268: EMPTY
54269: PPUSH
54270: CALL_OW 1
54274: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54275: LD_ADDR_EXP 89
54279: PUSH
54280: LD_EXP 89
54284: PPUSH
54285: LD_VAR 0 2
54289: PPUSH
54290: EMPTY
54291: PPUSH
54292: CALL_OW 1
54296: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54297: LD_ADDR_EXP 90
54301: PUSH
54302: LD_EXP 90
54306: PPUSH
54307: LD_VAR 0 2
54311: PPUSH
54312: EMPTY
54313: PPUSH
54314: CALL_OW 1
54318: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54319: LD_ADDR_EXP 92
54323: PUSH
54324: LD_EXP 92
54328: PPUSH
54329: LD_VAR 0 2
54333: PPUSH
54334: LD_EXP 59
54338: PUSH
54339: LD_VAR 0 2
54343: ARRAY
54344: PPUSH
54345: LD_INT 2
54347: PUSH
54348: LD_INT 30
54350: PUSH
54351: LD_INT 6
54353: PUSH
54354: EMPTY
54355: LIST
54356: LIST
54357: PUSH
54358: LD_INT 30
54360: PUSH
54361: LD_INT 7
54363: PUSH
54364: EMPTY
54365: LIST
54366: LIST
54367: PUSH
54368: LD_INT 30
54370: PUSH
54371: LD_INT 8
54373: PUSH
54374: EMPTY
54375: LIST
54376: LIST
54377: PUSH
54378: EMPTY
54379: LIST
54380: LIST
54381: LIST
54382: LIST
54383: PPUSH
54384: CALL_OW 72
54388: PPUSH
54389: CALL_OW 1
54393: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54394: LD_ADDR_EXP 93
54398: PUSH
54399: LD_EXP 93
54403: PPUSH
54404: LD_VAR 0 2
54408: PPUSH
54409: EMPTY
54410: PPUSH
54411: CALL_OW 1
54415: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54416: LD_ADDR_EXP 94
54420: PUSH
54421: LD_EXP 94
54425: PPUSH
54426: LD_VAR 0 2
54430: PPUSH
54431: EMPTY
54432: PPUSH
54433: CALL_OW 1
54437: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54438: LD_ADDR_EXP 95
54442: PUSH
54443: LD_EXP 95
54447: PPUSH
54448: LD_VAR 0 2
54452: PPUSH
54453: EMPTY
54454: PPUSH
54455: CALL_OW 1
54459: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54460: LD_ADDR_EXP 96
54464: PUSH
54465: LD_EXP 96
54469: PPUSH
54470: LD_VAR 0 2
54474: PPUSH
54475: EMPTY
54476: PPUSH
54477: CALL_OW 1
54481: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54482: LD_ADDR_EXP 97
54486: PUSH
54487: LD_EXP 97
54491: PPUSH
54492: LD_VAR 0 2
54496: PPUSH
54497: EMPTY
54498: PPUSH
54499: CALL_OW 1
54503: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54504: LD_ADDR_EXP 98
54508: PUSH
54509: LD_EXP 98
54513: PPUSH
54514: LD_VAR 0 2
54518: PPUSH
54519: EMPTY
54520: PPUSH
54521: CALL_OW 1
54525: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54526: LD_ADDR_EXP 99
54530: PUSH
54531: LD_EXP 99
54535: PPUSH
54536: LD_VAR 0 2
54540: PPUSH
54541: EMPTY
54542: PPUSH
54543: CALL_OW 1
54547: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54548: LD_ADDR_EXP 100
54552: PUSH
54553: LD_EXP 100
54557: PPUSH
54558: LD_VAR 0 2
54562: PPUSH
54563: EMPTY
54564: PPUSH
54565: CALL_OW 1
54569: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54570: LD_ADDR_EXP 101
54574: PUSH
54575: LD_EXP 101
54579: PPUSH
54580: LD_VAR 0 2
54584: PPUSH
54585: LD_INT 0
54587: PPUSH
54588: CALL_OW 1
54592: ST_TO_ADDR
// end ;
54593: GO 53517
54595: POP
54596: POP
// MC_InitSides ( ) ;
54597: CALL 54883 0 0
// MC_InitResearch ( ) ;
54601: CALL 54622 0 0
// CustomInitMacro ( ) ;
54605: CALL 185 0 0
// skirmish := true ;
54609: LD_ADDR_EXP 57
54613: PUSH
54614: LD_INT 1
54616: ST_TO_ADDR
// end ;
54617: LD_VAR 0 1
54621: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54622: LD_INT 0
54624: PPUSH
54625: PPUSH
54626: PPUSH
54627: PPUSH
54628: PPUSH
54629: PPUSH
// if not mc_bases then
54630: LD_EXP 59
54634: NOT
54635: IFFALSE 54639
// exit ;
54637: GO 54878
// for i = 1 to 8 do
54639: LD_ADDR_VAR 0 2
54643: PUSH
54644: DOUBLE
54645: LD_INT 1
54647: DEC
54648: ST_TO_ADDR
54649: LD_INT 8
54651: PUSH
54652: FOR_TO
54653: IFFALSE 54679
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54655: LD_ADDR_EXP 86
54659: PUSH
54660: LD_EXP 86
54664: PPUSH
54665: LD_VAR 0 2
54669: PPUSH
54670: EMPTY
54671: PPUSH
54672: CALL_OW 1
54676: ST_TO_ADDR
54677: GO 54652
54679: POP
54680: POP
// tmp := [ ] ;
54681: LD_ADDR_VAR 0 5
54685: PUSH
54686: EMPTY
54687: ST_TO_ADDR
// for i = 1 to mc_sides do
54688: LD_ADDR_VAR 0 2
54692: PUSH
54693: DOUBLE
54694: LD_INT 1
54696: DEC
54697: ST_TO_ADDR
54698: LD_EXP 85
54702: PUSH
54703: FOR_TO
54704: IFFALSE 54762
// if not mc_sides [ i ] in tmp then
54706: LD_EXP 85
54710: PUSH
54711: LD_VAR 0 2
54715: ARRAY
54716: PUSH
54717: LD_VAR 0 5
54721: IN
54722: NOT
54723: IFFALSE 54760
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54725: LD_ADDR_VAR 0 5
54729: PUSH
54730: LD_VAR 0 5
54734: PPUSH
54735: LD_VAR 0 5
54739: PUSH
54740: LD_INT 1
54742: PLUS
54743: PPUSH
54744: LD_EXP 85
54748: PUSH
54749: LD_VAR 0 2
54753: ARRAY
54754: PPUSH
54755: CALL_OW 2
54759: ST_TO_ADDR
54760: GO 54703
54762: POP
54763: POP
// if not tmp then
54764: LD_VAR 0 5
54768: NOT
54769: IFFALSE 54773
// exit ;
54771: GO 54878
// for j in tmp do
54773: LD_ADDR_VAR 0 3
54777: PUSH
54778: LD_VAR 0 5
54782: PUSH
54783: FOR_IN
54784: IFFALSE 54876
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54786: LD_ADDR_VAR 0 6
54790: PUSH
54791: LD_INT 22
54793: PUSH
54794: LD_VAR 0 3
54798: PUSH
54799: EMPTY
54800: LIST
54801: LIST
54802: PPUSH
54803: CALL_OW 69
54807: ST_TO_ADDR
// if not un then
54808: LD_VAR 0 6
54812: NOT
54813: IFFALSE 54817
// continue ;
54815: GO 54783
// nation := GetNation ( un [ 1 ] ) ;
54817: LD_ADDR_VAR 0 4
54821: PUSH
54822: LD_VAR 0 6
54826: PUSH
54827: LD_INT 1
54829: ARRAY
54830: PPUSH
54831: CALL_OW 248
54835: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54836: LD_ADDR_EXP 86
54840: PUSH
54841: LD_EXP 86
54845: PPUSH
54846: LD_VAR 0 3
54850: PPUSH
54851: LD_VAR 0 3
54855: PPUSH
54856: LD_VAR 0 4
54860: PPUSH
54861: LD_INT 1
54863: PPUSH
54864: CALL 14380 0 3
54868: PPUSH
54869: CALL_OW 1
54873: ST_TO_ADDR
// end ;
54874: GO 54783
54876: POP
54877: POP
// end ;
54878: LD_VAR 0 1
54882: RET
// export function MC_InitSides ( ) ; var i ; begin
54883: LD_INT 0
54885: PPUSH
54886: PPUSH
// if not mc_bases then
54887: LD_EXP 59
54891: NOT
54892: IFFALSE 54896
// exit ;
54894: GO 54970
// for i = 1 to mc_bases do
54896: LD_ADDR_VAR 0 2
54900: PUSH
54901: DOUBLE
54902: LD_INT 1
54904: DEC
54905: ST_TO_ADDR
54906: LD_EXP 59
54910: PUSH
54911: FOR_TO
54912: IFFALSE 54968
// if mc_bases [ i ] then
54914: LD_EXP 59
54918: PUSH
54919: LD_VAR 0 2
54923: ARRAY
54924: IFFALSE 54966
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54926: LD_ADDR_EXP 85
54930: PUSH
54931: LD_EXP 85
54935: PPUSH
54936: LD_VAR 0 2
54940: PPUSH
54941: LD_EXP 59
54945: PUSH
54946: LD_VAR 0 2
54950: ARRAY
54951: PUSH
54952: LD_INT 1
54954: ARRAY
54955: PPUSH
54956: CALL_OW 255
54960: PPUSH
54961: CALL_OW 1
54965: ST_TO_ADDR
54966: GO 54911
54968: POP
54969: POP
// end ;
54970: LD_VAR 0 1
54974: RET
// every 0 0$01 trigger skirmish do
54975: LD_EXP 57
54979: IFFALSE 55133
54981: GO 54983
54983: DISABLE
// begin enable ;
54984: ENABLE
// MC_CheckBuildings ( ) ;
54985: CALL 59631 0 0
// MC_CheckPeopleLife ( ) ;
54989: CALL 59756 0 0
// RaiseSailEvent ( 100 ) ;
54993: LD_INT 100
54995: PPUSH
54996: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
55000: LD_INT 103
55002: PPUSH
55003: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
55007: LD_INT 104
55009: PPUSH
55010: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
55014: LD_INT 105
55016: PPUSH
55017: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
55021: LD_INT 106
55023: PPUSH
55024: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
55028: LD_INT 107
55030: PPUSH
55031: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
55035: LD_INT 108
55037: PPUSH
55038: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
55042: LD_INT 109
55044: PPUSH
55045: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55049: LD_INT 110
55051: PPUSH
55052: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55056: LD_INT 111
55058: PPUSH
55059: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55063: LD_INT 112
55065: PPUSH
55066: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55070: LD_INT 113
55072: PPUSH
55073: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55077: LD_INT 120
55079: PPUSH
55080: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55084: LD_INT 121
55086: PPUSH
55087: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55091: LD_INT 122
55093: PPUSH
55094: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55098: LD_INT 123
55100: PPUSH
55101: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55105: LD_INT 124
55107: PPUSH
55108: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
55112: LD_INT 125
55114: PPUSH
55115: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
55119: LD_INT 126
55121: PPUSH
55122: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
55126: LD_INT 200
55128: PPUSH
55129: CALL_OW 427
// end ;
55133: END
// on SailEvent ( event ) do begin if event < 100 then
55134: LD_VAR 0 1
55138: PUSH
55139: LD_INT 100
55141: LESS
55142: IFFALSE 55153
// CustomEvent ( event ) ;
55144: LD_VAR 0 1
55148: PPUSH
55149: CALL 13038 0 1
// if event = 100 then
55153: LD_VAR 0 1
55157: PUSH
55158: LD_INT 100
55160: EQUAL
55161: IFFALSE 55167
// MC_ClassManager ( ) ;
55163: CALL 55559 0 0
// if event = 101 then
55167: LD_VAR 0 1
55171: PUSH
55172: LD_INT 101
55174: EQUAL
55175: IFFALSE 55181
// MC_RepairBuildings ( ) ;
55177: CALL 60341 0 0
// if event = 102 then
55181: LD_VAR 0 1
55185: PUSH
55186: LD_INT 102
55188: EQUAL
55189: IFFALSE 55195
// MC_Heal ( ) ;
55191: CALL 61226 0 0
// if event = 103 then
55195: LD_VAR 0 1
55199: PUSH
55200: LD_INT 103
55202: EQUAL
55203: IFFALSE 55209
// MC_Build ( ) ;
55205: CALL 61648 0 0
// if event = 104 then
55209: LD_VAR 0 1
55213: PUSH
55214: LD_INT 104
55216: EQUAL
55217: IFFALSE 55223
// MC_TurretWeapon ( ) ;
55219: CALL 63261 0 0
// if event = 105 then
55223: LD_VAR 0 1
55227: PUSH
55228: LD_INT 105
55230: EQUAL
55231: IFFALSE 55237
// MC_BuildUpgrade ( ) ;
55233: CALL 62812 0 0
// if event = 106 then
55237: LD_VAR 0 1
55241: PUSH
55242: LD_INT 106
55244: EQUAL
55245: IFFALSE 55251
// MC_PlantMines ( ) ;
55247: CALL 63691 0 0
// if event = 107 then
55251: LD_VAR 0 1
55255: PUSH
55256: LD_INT 107
55258: EQUAL
55259: IFFALSE 55265
// MC_CollectCrates ( ) ;
55261: CALL 64489 0 0
// if event = 108 then
55265: LD_VAR 0 1
55269: PUSH
55270: LD_INT 108
55272: EQUAL
55273: IFFALSE 55279
// MC_LinkRemoteControl ( ) ;
55275: CALL 66265 0 0
// if event = 109 then
55279: LD_VAR 0 1
55283: PUSH
55284: LD_INT 109
55286: EQUAL
55287: IFFALSE 55293
// MC_ProduceVehicle ( ) ;
55289: CALL 66446 0 0
// if event = 110 then
55293: LD_VAR 0 1
55297: PUSH
55298: LD_INT 110
55300: EQUAL
55301: IFFALSE 55307
// MC_SendAttack ( ) ;
55303: CALL 66912 0 0
// if event = 111 then
55307: LD_VAR 0 1
55311: PUSH
55312: LD_INT 111
55314: EQUAL
55315: IFFALSE 55321
// MC_Defend ( ) ;
55317: CALL 67020 0 0
// if event = 112 then
55321: LD_VAR 0 1
55325: PUSH
55326: LD_INT 112
55328: EQUAL
55329: IFFALSE 55335
// MC_Research ( ) ;
55331: CALL 67647 0 0
// if event = 113 then
55335: LD_VAR 0 1
55339: PUSH
55340: LD_INT 113
55342: EQUAL
55343: IFFALSE 55349
// MC_MinesTrigger ( ) ;
55345: CALL 68761 0 0
// if event = 120 then
55349: LD_VAR 0 1
55353: PUSH
55354: LD_INT 120
55356: EQUAL
55357: IFFALSE 55363
// MC_RepairVehicle ( ) ;
55359: CALL 68860 0 0
// if event = 121 then
55363: LD_VAR 0 1
55367: PUSH
55368: LD_INT 121
55370: EQUAL
55371: IFFALSE 55377
// MC_TameApe ( ) ;
55373: CALL 69590 0 0
// if event = 122 then
55377: LD_VAR 0 1
55381: PUSH
55382: LD_INT 122
55384: EQUAL
55385: IFFALSE 55391
// MC_ChangeApeClass ( ) ;
55387: CALL 70419 0 0
// if event = 123 then
55391: LD_VAR 0 1
55395: PUSH
55396: LD_INT 123
55398: EQUAL
55399: IFFALSE 55405
// MC_Bazooka ( ) ;
55401: CALL 71069 0 0
// if event = 124 then
55405: LD_VAR 0 1
55409: PUSH
55410: LD_INT 124
55412: EQUAL
55413: IFFALSE 55419
// MC_TeleportExit ( ) ;
55415: CALL 71267 0 0
// if event = 125 then
55419: LD_VAR 0 1
55423: PUSH
55424: LD_INT 125
55426: EQUAL
55427: IFFALSE 55433
// MC_Deposits ( ) ;
55429: CALL 71914 0 0
// if event = 126 then
55433: LD_VAR 0 1
55437: PUSH
55438: LD_INT 126
55440: EQUAL
55441: IFFALSE 55447
// MC_RemoteDriver ( ) ;
55443: CALL 72539 0 0
// if event = 200 then
55447: LD_VAR 0 1
55451: PUSH
55452: LD_INT 200
55454: EQUAL
55455: IFFALSE 55461
// MC_Idle ( ) ;
55457: CALL 74488 0 0
// end ;
55461: PPOPN 1
55463: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55464: LD_INT 0
55466: PPUSH
55467: PPUSH
// if not mc_bases [ base ] or not tag then
55468: LD_EXP 59
55472: PUSH
55473: LD_VAR 0 1
55477: ARRAY
55478: NOT
55479: PUSH
55480: LD_VAR 0 2
55484: NOT
55485: OR
55486: IFFALSE 55490
// exit ;
55488: GO 55554
// for i in mc_bases [ base ] union mc_ape [ base ] do
55490: LD_ADDR_VAR 0 4
55494: PUSH
55495: LD_EXP 59
55499: PUSH
55500: LD_VAR 0 1
55504: ARRAY
55505: PUSH
55506: LD_EXP 88
55510: PUSH
55511: LD_VAR 0 1
55515: ARRAY
55516: UNION
55517: PUSH
55518: FOR_IN
55519: IFFALSE 55552
// if GetTag ( i ) = tag then
55521: LD_VAR 0 4
55525: PPUSH
55526: CALL_OW 110
55530: PUSH
55531: LD_VAR 0 2
55535: EQUAL
55536: IFFALSE 55550
// SetTag ( i , 0 ) ;
55538: LD_VAR 0 4
55542: PPUSH
55543: LD_INT 0
55545: PPUSH
55546: CALL_OW 109
55550: GO 55518
55552: POP
55553: POP
// end ;
55554: LD_VAR 0 3
55558: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55559: LD_INT 0
55561: PPUSH
55562: PPUSH
55563: PPUSH
55564: PPUSH
55565: PPUSH
55566: PPUSH
55567: PPUSH
55568: PPUSH
// if not mc_bases then
55569: LD_EXP 59
55573: NOT
55574: IFFALSE 55578
// exit ;
55576: GO 56036
// for i = 1 to mc_bases do
55578: LD_ADDR_VAR 0 2
55582: PUSH
55583: DOUBLE
55584: LD_INT 1
55586: DEC
55587: ST_TO_ADDR
55588: LD_EXP 59
55592: PUSH
55593: FOR_TO
55594: IFFALSE 56034
// begin tmp := MC_ClassCheckReq ( i ) ;
55596: LD_ADDR_VAR 0 4
55600: PUSH
55601: LD_VAR 0 2
55605: PPUSH
55606: CALL 56041 0 1
55610: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55611: LD_ADDR_EXP 100
55615: PUSH
55616: LD_EXP 100
55620: PPUSH
55621: LD_VAR 0 2
55625: PPUSH
55626: LD_VAR 0 4
55630: PPUSH
55631: CALL_OW 1
55635: ST_TO_ADDR
// if not tmp then
55636: LD_VAR 0 4
55640: NOT
55641: IFFALSE 55645
// continue ;
55643: GO 55593
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55645: LD_ADDR_VAR 0 6
55649: PUSH
55650: LD_EXP 59
55654: PUSH
55655: LD_VAR 0 2
55659: ARRAY
55660: PPUSH
55661: LD_INT 2
55663: PUSH
55664: LD_INT 30
55666: PUSH
55667: LD_INT 4
55669: PUSH
55670: EMPTY
55671: LIST
55672: LIST
55673: PUSH
55674: LD_INT 30
55676: PUSH
55677: LD_INT 5
55679: PUSH
55680: EMPTY
55681: LIST
55682: LIST
55683: PUSH
55684: EMPTY
55685: LIST
55686: LIST
55687: LIST
55688: PPUSH
55689: CALL_OW 72
55693: PUSH
55694: LD_EXP 59
55698: PUSH
55699: LD_VAR 0 2
55703: ARRAY
55704: PPUSH
55705: LD_INT 2
55707: PUSH
55708: LD_INT 30
55710: PUSH
55711: LD_INT 0
55713: PUSH
55714: EMPTY
55715: LIST
55716: LIST
55717: PUSH
55718: LD_INT 30
55720: PUSH
55721: LD_INT 1
55723: PUSH
55724: EMPTY
55725: LIST
55726: LIST
55727: PUSH
55728: EMPTY
55729: LIST
55730: LIST
55731: LIST
55732: PPUSH
55733: CALL_OW 72
55737: PUSH
55738: LD_EXP 59
55742: PUSH
55743: LD_VAR 0 2
55747: ARRAY
55748: PPUSH
55749: LD_INT 30
55751: PUSH
55752: LD_INT 3
55754: PUSH
55755: EMPTY
55756: LIST
55757: LIST
55758: PPUSH
55759: CALL_OW 72
55763: PUSH
55764: LD_EXP 59
55768: PUSH
55769: LD_VAR 0 2
55773: ARRAY
55774: PPUSH
55775: LD_INT 2
55777: PUSH
55778: LD_INT 30
55780: PUSH
55781: LD_INT 6
55783: PUSH
55784: EMPTY
55785: LIST
55786: LIST
55787: PUSH
55788: LD_INT 30
55790: PUSH
55791: LD_INT 7
55793: PUSH
55794: EMPTY
55795: LIST
55796: LIST
55797: PUSH
55798: LD_INT 30
55800: PUSH
55801: LD_INT 8
55803: PUSH
55804: EMPTY
55805: LIST
55806: LIST
55807: PUSH
55808: EMPTY
55809: LIST
55810: LIST
55811: LIST
55812: LIST
55813: PPUSH
55814: CALL_OW 72
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: LIST
55823: LIST
55824: ST_TO_ADDR
// for j = 1 to 4 do
55825: LD_ADDR_VAR 0 3
55829: PUSH
55830: DOUBLE
55831: LD_INT 1
55833: DEC
55834: ST_TO_ADDR
55835: LD_INT 4
55837: PUSH
55838: FOR_TO
55839: IFFALSE 56030
// begin if not tmp [ j ] then
55841: LD_VAR 0 4
55845: PUSH
55846: LD_VAR 0 3
55850: ARRAY
55851: NOT
55852: IFFALSE 55856
// continue ;
55854: GO 55838
// for p in tmp [ j ] do
55856: LD_ADDR_VAR 0 5
55860: PUSH
55861: LD_VAR 0 4
55865: PUSH
55866: LD_VAR 0 3
55870: ARRAY
55871: PUSH
55872: FOR_IN
55873: IFFALSE 56026
// begin if not b [ j ] then
55875: LD_VAR 0 6
55879: PUSH
55880: LD_VAR 0 3
55884: ARRAY
55885: NOT
55886: IFFALSE 55890
// break ;
55888: GO 56026
// e := 0 ;
55890: LD_ADDR_VAR 0 7
55894: PUSH
55895: LD_INT 0
55897: ST_TO_ADDR
// for k in b [ j ] do
55898: LD_ADDR_VAR 0 8
55902: PUSH
55903: LD_VAR 0 6
55907: PUSH
55908: LD_VAR 0 3
55912: ARRAY
55913: PUSH
55914: FOR_IN
55915: IFFALSE 55942
// if IsNotFull ( k ) then
55917: LD_VAR 0 8
55921: PPUSH
55922: CALL 16529 0 1
55926: IFFALSE 55940
// begin e := k ;
55928: LD_ADDR_VAR 0 7
55932: PUSH
55933: LD_VAR 0 8
55937: ST_TO_ADDR
// break ;
55938: GO 55942
// end ;
55940: GO 55914
55942: POP
55943: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55944: LD_VAR 0 7
55948: PUSH
55949: LD_VAR 0 5
55953: PPUSH
55954: LD_VAR 0 7
55958: PPUSH
55959: CALL 48949 0 2
55963: NOT
55964: AND
55965: IFFALSE 56024
// begin if IsInUnit ( p ) then
55967: LD_VAR 0 5
55971: PPUSH
55972: CALL_OW 310
55976: IFFALSE 55987
// ComExitBuilding ( p ) ;
55978: LD_VAR 0 5
55982: PPUSH
55983: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55987: LD_VAR 0 5
55991: PPUSH
55992: LD_VAR 0 7
55996: PPUSH
55997: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
56001: LD_VAR 0 5
56005: PPUSH
56006: LD_VAR 0 3
56010: PPUSH
56011: CALL_OW 183
// AddComExitBuilding ( p ) ;
56015: LD_VAR 0 5
56019: PPUSH
56020: CALL_OW 182
// end ; end ;
56024: GO 55872
56026: POP
56027: POP
// end ;
56028: GO 55838
56030: POP
56031: POP
// end ;
56032: GO 55593
56034: POP
56035: POP
// end ;
56036: LD_VAR 0 1
56040: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
56041: LD_INT 0
56043: PPUSH
56044: PPUSH
56045: PPUSH
56046: PPUSH
56047: PPUSH
56048: PPUSH
56049: PPUSH
56050: PPUSH
56051: PPUSH
56052: PPUSH
56053: PPUSH
56054: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56055: LD_VAR 0 1
56059: NOT
56060: PUSH
56061: LD_EXP 59
56065: PUSH
56066: LD_VAR 0 1
56070: ARRAY
56071: NOT
56072: OR
56073: PUSH
56074: LD_EXP 59
56078: PUSH
56079: LD_VAR 0 1
56083: ARRAY
56084: PPUSH
56085: LD_INT 2
56087: PUSH
56088: LD_INT 30
56090: PUSH
56091: LD_INT 0
56093: PUSH
56094: EMPTY
56095: LIST
56096: LIST
56097: PUSH
56098: LD_INT 30
56100: PUSH
56101: LD_INT 1
56103: PUSH
56104: EMPTY
56105: LIST
56106: LIST
56107: PUSH
56108: EMPTY
56109: LIST
56110: LIST
56111: LIST
56112: PPUSH
56113: CALL_OW 72
56117: NOT
56118: OR
56119: IFFALSE 56123
// exit ;
56121: GO 59626
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56123: LD_ADDR_VAR 0 4
56127: PUSH
56128: LD_EXP 59
56132: PUSH
56133: LD_VAR 0 1
56137: ARRAY
56138: PPUSH
56139: LD_INT 2
56141: PUSH
56142: LD_INT 25
56144: PUSH
56145: LD_INT 1
56147: PUSH
56148: EMPTY
56149: LIST
56150: LIST
56151: PUSH
56152: LD_INT 25
56154: PUSH
56155: LD_INT 2
56157: PUSH
56158: EMPTY
56159: LIST
56160: LIST
56161: PUSH
56162: LD_INT 25
56164: PUSH
56165: LD_INT 3
56167: PUSH
56168: EMPTY
56169: LIST
56170: LIST
56171: PUSH
56172: LD_INT 25
56174: PUSH
56175: LD_INT 4
56177: PUSH
56178: EMPTY
56179: LIST
56180: LIST
56181: PUSH
56182: LD_INT 25
56184: PUSH
56185: LD_INT 5
56187: PUSH
56188: EMPTY
56189: LIST
56190: LIST
56191: PUSH
56192: LD_INT 25
56194: PUSH
56195: LD_INT 8
56197: PUSH
56198: EMPTY
56199: LIST
56200: LIST
56201: PUSH
56202: LD_INT 25
56204: PUSH
56205: LD_INT 9
56207: PUSH
56208: EMPTY
56209: LIST
56210: LIST
56211: PUSH
56212: EMPTY
56213: LIST
56214: LIST
56215: LIST
56216: LIST
56217: LIST
56218: LIST
56219: LIST
56220: LIST
56221: PPUSH
56222: CALL_OW 72
56226: ST_TO_ADDR
// if not tmp then
56227: LD_VAR 0 4
56231: NOT
56232: IFFALSE 56236
// exit ;
56234: GO 59626
// for i in tmp do
56236: LD_ADDR_VAR 0 3
56240: PUSH
56241: LD_VAR 0 4
56245: PUSH
56246: FOR_IN
56247: IFFALSE 56278
// if GetTag ( i ) then
56249: LD_VAR 0 3
56253: PPUSH
56254: CALL_OW 110
56258: IFFALSE 56276
// tmp := tmp diff i ;
56260: LD_ADDR_VAR 0 4
56264: PUSH
56265: LD_VAR 0 4
56269: PUSH
56270: LD_VAR 0 3
56274: DIFF
56275: ST_TO_ADDR
56276: GO 56246
56278: POP
56279: POP
// if not tmp then
56280: LD_VAR 0 4
56284: NOT
56285: IFFALSE 56289
// exit ;
56287: GO 59626
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56289: LD_ADDR_VAR 0 5
56293: PUSH
56294: LD_EXP 59
56298: PUSH
56299: LD_VAR 0 1
56303: ARRAY
56304: PPUSH
56305: LD_INT 2
56307: PUSH
56308: LD_INT 25
56310: PUSH
56311: LD_INT 1
56313: PUSH
56314: EMPTY
56315: LIST
56316: LIST
56317: PUSH
56318: LD_INT 25
56320: PUSH
56321: LD_INT 5
56323: PUSH
56324: EMPTY
56325: LIST
56326: LIST
56327: PUSH
56328: LD_INT 25
56330: PUSH
56331: LD_INT 8
56333: PUSH
56334: EMPTY
56335: LIST
56336: LIST
56337: PUSH
56338: LD_INT 25
56340: PUSH
56341: LD_INT 9
56343: PUSH
56344: EMPTY
56345: LIST
56346: LIST
56347: PUSH
56348: EMPTY
56349: LIST
56350: LIST
56351: LIST
56352: LIST
56353: LIST
56354: PPUSH
56355: CALL_OW 72
56359: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56360: LD_ADDR_VAR 0 6
56364: PUSH
56365: LD_EXP 59
56369: PUSH
56370: LD_VAR 0 1
56374: ARRAY
56375: PPUSH
56376: LD_INT 25
56378: PUSH
56379: LD_INT 2
56381: PUSH
56382: EMPTY
56383: LIST
56384: LIST
56385: PPUSH
56386: CALL_OW 72
56390: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56391: LD_ADDR_VAR 0 7
56395: PUSH
56396: LD_EXP 59
56400: PUSH
56401: LD_VAR 0 1
56405: ARRAY
56406: PPUSH
56407: LD_INT 25
56409: PUSH
56410: LD_INT 3
56412: PUSH
56413: EMPTY
56414: LIST
56415: LIST
56416: PPUSH
56417: CALL_OW 72
56421: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56422: LD_ADDR_VAR 0 8
56426: PUSH
56427: LD_EXP 59
56431: PUSH
56432: LD_VAR 0 1
56436: ARRAY
56437: PPUSH
56438: LD_INT 25
56440: PUSH
56441: LD_INT 4
56443: PUSH
56444: EMPTY
56445: LIST
56446: LIST
56447: PUSH
56448: LD_INT 24
56450: PUSH
56451: LD_INT 251
56453: PUSH
56454: EMPTY
56455: LIST
56456: LIST
56457: PUSH
56458: EMPTY
56459: LIST
56460: LIST
56461: PPUSH
56462: CALL_OW 72
56466: ST_TO_ADDR
// if mc_scan [ base ] then
56467: LD_EXP 82
56471: PUSH
56472: LD_VAR 0 1
56476: ARRAY
56477: IFFALSE 56938
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56479: LD_ADDR_EXP 101
56483: PUSH
56484: LD_EXP 101
56488: PPUSH
56489: LD_VAR 0 1
56493: PPUSH
56494: LD_INT 4
56496: PPUSH
56497: CALL_OW 1
56501: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56502: LD_ADDR_VAR 0 12
56506: PUSH
56507: LD_EXP 59
56511: PUSH
56512: LD_VAR 0 1
56516: ARRAY
56517: PPUSH
56518: LD_INT 2
56520: PUSH
56521: LD_INT 30
56523: PUSH
56524: LD_INT 4
56526: PUSH
56527: EMPTY
56528: LIST
56529: LIST
56530: PUSH
56531: LD_INT 30
56533: PUSH
56534: LD_INT 5
56536: PUSH
56537: EMPTY
56538: LIST
56539: LIST
56540: PUSH
56541: EMPTY
56542: LIST
56543: LIST
56544: LIST
56545: PPUSH
56546: CALL_OW 72
56550: ST_TO_ADDR
// if not b then
56551: LD_VAR 0 12
56555: NOT
56556: IFFALSE 56560
// exit ;
56558: GO 59626
// p := [ ] ;
56560: LD_ADDR_VAR 0 11
56564: PUSH
56565: EMPTY
56566: ST_TO_ADDR
// if sci >= 2 then
56567: LD_VAR 0 8
56571: PUSH
56572: LD_INT 2
56574: GREATEREQUAL
56575: IFFALSE 56606
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56577: LD_ADDR_VAR 0 8
56581: PUSH
56582: LD_VAR 0 8
56586: PUSH
56587: LD_INT 1
56589: ARRAY
56590: PUSH
56591: LD_VAR 0 8
56595: PUSH
56596: LD_INT 2
56598: ARRAY
56599: PUSH
56600: EMPTY
56601: LIST
56602: LIST
56603: ST_TO_ADDR
56604: GO 56667
// if sci = 1 then
56606: LD_VAR 0 8
56610: PUSH
56611: LD_INT 1
56613: EQUAL
56614: IFFALSE 56635
// sci := [ sci [ 1 ] ] else
56616: LD_ADDR_VAR 0 8
56620: PUSH
56621: LD_VAR 0 8
56625: PUSH
56626: LD_INT 1
56628: ARRAY
56629: PUSH
56630: EMPTY
56631: LIST
56632: ST_TO_ADDR
56633: GO 56667
// if sci = 0 then
56635: LD_VAR 0 8
56639: PUSH
56640: LD_INT 0
56642: EQUAL
56643: IFFALSE 56667
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56645: LD_ADDR_VAR 0 11
56649: PUSH
56650: LD_VAR 0 4
56654: PPUSH
56655: LD_INT 4
56657: PPUSH
56658: CALL 48812 0 2
56662: PUSH
56663: LD_INT 1
56665: ARRAY
56666: ST_TO_ADDR
// if eng > 4 then
56667: LD_VAR 0 6
56671: PUSH
56672: LD_INT 4
56674: GREATER
56675: IFFALSE 56721
// for i = eng downto 4 do
56677: LD_ADDR_VAR 0 3
56681: PUSH
56682: DOUBLE
56683: LD_VAR 0 6
56687: INC
56688: ST_TO_ADDR
56689: LD_INT 4
56691: PUSH
56692: FOR_DOWNTO
56693: IFFALSE 56719
// eng := eng diff eng [ i ] ;
56695: LD_ADDR_VAR 0 6
56699: PUSH
56700: LD_VAR 0 6
56704: PUSH
56705: LD_VAR 0 6
56709: PUSH
56710: LD_VAR 0 3
56714: ARRAY
56715: DIFF
56716: ST_TO_ADDR
56717: GO 56692
56719: POP
56720: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56721: LD_ADDR_VAR 0 4
56725: PUSH
56726: LD_VAR 0 4
56730: PUSH
56731: LD_VAR 0 5
56735: PUSH
56736: LD_VAR 0 6
56740: UNION
56741: PUSH
56742: LD_VAR 0 7
56746: UNION
56747: PUSH
56748: LD_VAR 0 8
56752: UNION
56753: DIFF
56754: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56755: LD_ADDR_VAR 0 13
56759: PUSH
56760: LD_EXP 59
56764: PUSH
56765: LD_VAR 0 1
56769: ARRAY
56770: PPUSH
56771: LD_INT 2
56773: PUSH
56774: LD_INT 30
56776: PUSH
56777: LD_INT 32
56779: PUSH
56780: EMPTY
56781: LIST
56782: LIST
56783: PUSH
56784: LD_INT 30
56786: PUSH
56787: LD_INT 31
56789: PUSH
56790: EMPTY
56791: LIST
56792: LIST
56793: PUSH
56794: EMPTY
56795: LIST
56796: LIST
56797: LIST
56798: PPUSH
56799: CALL_OW 72
56803: PUSH
56804: LD_EXP 59
56808: PUSH
56809: LD_VAR 0 1
56813: ARRAY
56814: PPUSH
56815: LD_INT 2
56817: PUSH
56818: LD_INT 30
56820: PUSH
56821: LD_INT 4
56823: PUSH
56824: EMPTY
56825: LIST
56826: LIST
56827: PUSH
56828: LD_INT 30
56830: PUSH
56831: LD_INT 5
56833: PUSH
56834: EMPTY
56835: LIST
56836: LIST
56837: PUSH
56838: EMPTY
56839: LIST
56840: LIST
56841: LIST
56842: PPUSH
56843: CALL_OW 72
56847: PUSH
56848: LD_INT 6
56850: MUL
56851: PLUS
56852: ST_TO_ADDR
// if bcount < tmp then
56853: LD_VAR 0 13
56857: PUSH
56858: LD_VAR 0 4
56862: LESS
56863: IFFALSE 56909
// for i = tmp downto bcount do
56865: LD_ADDR_VAR 0 3
56869: PUSH
56870: DOUBLE
56871: LD_VAR 0 4
56875: INC
56876: ST_TO_ADDR
56877: LD_VAR 0 13
56881: PUSH
56882: FOR_DOWNTO
56883: IFFALSE 56907
// tmp := Delete ( tmp , tmp ) ;
56885: LD_ADDR_VAR 0 4
56889: PUSH
56890: LD_VAR 0 4
56894: PPUSH
56895: LD_VAR 0 4
56899: PPUSH
56900: CALL_OW 3
56904: ST_TO_ADDR
56905: GO 56882
56907: POP
56908: POP
// result := [ tmp , 0 , 0 , p ] ;
56909: LD_ADDR_VAR 0 2
56913: PUSH
56914: LD_VAR 0 4
56918: PUSH
56919: LD_INT 0
56921: PUSH
56922: LD_INT 0
56924: PUSH
56925: LD_VAR 0 11
56929: PUSH
56930: EMPTY
56931: LIST
56932: LIST
56933: LIST
56934: LIST
56935: ST_TO_ADDR
// exit ;
56936: GO 59626
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56938: LD_EXP 59
56942: PUSH
56943: LD_VAR 0 1
56947: ARRAY
56948: PPUSH
56949: LD_INT 2
56951: PUSH
56952: LD_INT 30
56954: PUSH
56955: LD_INT 6
56957: PUSH
56958: EMPTY
56959: LIST
56960: LIST
56961: PUSH
56962: LD_INT 30
56964: PUSH
56965: LD_INT 7
56967: PUSH
56968: EMPTY
56969: LIST
56970: LIST
56971: PUSH
56972: LD_INT 30
56974: PUSH
56975: LD_INT 8
56977: PUSH
56978: EMPTY
56979: LIST
56980: LIST
56981: PUSH
56982: EMPTY
56983: LIST
56984: LIST
56985: LIST
56986: LIST
56987: PPUSH
56988: CALL_OW 72
56992: NOT
56993: PUSH
56994: LD_EXP 59
56998: PUSH
56999: LD_VAR 0 1
57003: ARRAY
57004: PPUSH
57005: LD_INT 30
57007: PUSH
57008: LD_INT 3
57010: PUSH
57011: EMPTY
57012: LIST
57013: LIST
57014: PPUSH
57015: CALL_OW 72
57019: NOT
57020: AND
57021: IFFALSE 57093
// begin if eng = tmp then
57023: LD_VAR 0 6
57027: PUSH
57028: LD_VAR 0 4
57032: EQUAL
57033: IFFALSE 57037
// exit ;
57035: GO 59626
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
57037: LD_ADDR_EXP 101
57041: PUSH
57042: LD_EXP 101
57046: PPUSH
57047: LD_VAR 0 1
57051: PPUSH
57052: LD_INT 1
57054: PPUSH
57055: CALL_OW 1
57059: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57060: LD_ADDR_VAR 0 2
57064: PUSH
57065: LD_INT 0
57067: PUSH
57068: LD_VAR 0 4
57072: PUSH
57073: LD_VAR 0 6
57077: DIFF
57078: PUSH
57079: LD_INT 0
57081: PUSH
57082: LD_INT 0
57084: PUSH
57085: EMPTY
57086: LIST
57087: LIST
57088: LIST
57089: LIST
57090: ST_TO_ADDR
// exit ;
57091: GO 59626
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57093: LD_EXP 86
57097: PUSH
57098: LD_EXP 85
57102: PUSH
57103: LD_VAR 0 1
57107: ARRAY
57108: ARRAY
57109: PUSH
57110: LD_EXP 59
57114: PUSH
57115: LD_VAR 0 1
57119: ARRAY
57120: PPUSH
57121: LD_INT 2
57123: PUSH
57124: LD_INT 30
57126: PUSH
57127: LD_INT 6
57129: PUSH
57130: EMPTY
57131: LIST
57132: LIST
57133: PUSH
57134: LD_INT 30
57136: PUSH
57137: LD_INT 7
57139: PUSH
57140: EMPTY
57141: LIST
57142: LIST
57143: PUSH
57144: LD_INT 30
57146: PUSH
57147: LD_INT 8
57149: PUSH
57150: EMPTY
57151: LIST
57152: LIST
57153: PUSH
57154: EMPTY
57155: LIST
57156: LIST
57157: LIST
57158: LIST
57159: PPUSH
57160: CALL_OW 72
57164: AND
57165: PUSH
57166: LD_EXP 59
57170: PUSH
57171: LD_VAR 0 1
57175: ARRAY
57176: PPUSH
57177: LD_INT 30
57179: PUSH
57180: LD_INT 3
57182: PUSH
57183: EMPTY
57184: LIST
57185: LIST
57186: PPUSH
57187: CALL_OW 72
57191: NOT
57192: AND
57193: IFFALSE 57407
// begin if sci >= 6 then
57195: LD_VAR 0 8
57199: PUSH
57200: LD_INT 6
57202: GREATEREQUAL
57203: IFFALSE 57207
// exit ;
57205: GO 59626
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
57207: LD_ADDR_EXP 101
57211: PUSH
57212: LD_EXP 101
57216: PPUSH
57217: LD_VAR 0 1
57221: PPUSH
57222: LD_INT 2
57224: PPUSH
57225: CALL_OW 1
57229: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57230: LD_ADDR_VAR 0 9
57234: PUSH
57235: LD_VAR 0 4
57239: PUSH
57240: LD_VAR 0 8
57244: DIFF
57245: PPUSH
57246: LD_INT 4
57248: PPUSH
57249: CALL 48812 0 2
57253: ST_TO_ADDR
// p := [ ] ;
57254: LD_ADDR_VAR 0 11
57258: PUSH
57259: EMPTY
57260: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57261: LD_VAR 0 8
57265: PUSH
57266: LD_INT 6
57268: LESS
57269: PUSH
57270: LD_VAR 0 9
57274: PUSH
57275: LD_INT 6
57277: GREATER
57278: AND
57279: IFFALSE 57360
// begin for i = 1 to 6 - sci do
57281: LD_ADDR_VAR 0 3
57285: PUSH
57286: DOUBLE
57287: LD_INT 1
57289: DEC
57290: ST_TO_ADDR
57291: LD_INT 6
57293: PUSH
57294: LD_VAR 0 8
57298: MINUS
57299: PUSH
57300: FOR_TO
57301: IFFALSE 57356
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57303: LD_ADDR_VAR 0 11
57307: PUSH
57308: LD_VAR 0 11
57312: PPUSH
57313: LD_VAR 0 11
57317: PUSH
57318: LD_INT 1
57320: PLUS
57321: PPUSH
57322: LD_VAR 0 9
57326: PUSH
57327: LD_INT 1
57329: ARRAY
57330: PPUSH
57331: CALL_OW 2
57335: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57336: LD_ADDR_VAR 0 9
57340: PUSH
57341: LD_VAR 0 9
57345: PPUSH
57346: LD_INT 1
57348: PPUSH
57349: CALL_OW 3
57353: ST_TO_ADDR
// end ;
57354: GO 57300
57356: POP
57357: POP
// end else
57358: GO 57380
// if sort then
57360: LD_VAR 0 9
57364: IFFALSE 57380
// p := sort [ 1 ] ;
57366: LD_ADDR_VAR 0 11
57370: PUSH
57371: LD_VAR 0 9
57375: PUSH
57376: LD_INT 1
57378: ARRAY
57379: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57380: LD_ADDR_VAR 0 2
57384: PUSH
57385: LD_INT 0
57387: PUSH
57388: LD_INT 0
57390: PUSH
57391: LD_INT 0
57393: PUSH
57394: LD_VAR 0 11
57398: PUSH
57399: EMPTY
57400: LIST
57401: LIST
57402: LIST
57403: LIST
57404: ST_TO_ADDR
// exit ;
57405: GO 59626
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57407: LD_EXP 86
57411: PUSH
57412: LD_EXP 85
57416: PUSH
57417: LD_VAR 0 1
57421: ARRAY
57422: ARRAY
57423: PUSH
57424: LD_EXP 59
57428: PUSH
57429: LD_VAR 0 1
57433: ARRAY
57434: PPUSH
57435: LD_INT 2
57437: PUSH
57438: LD_INT 30
57440: PUSH
57441: LD_INT 6
57443: PUSH
57444: EMPTY
57445: LIST
57446: LIST
57447: PUSH
57448: LD_INT 30
57450: PUSH
57451: LD_INT 7
57453: PUSH
57454: EMPTY
57455: LIST
57456: LIST
57457: PUSH
57458: LD_INT 30
57460: PUSH
57461: LD_INT 8
57463: PUSH
57464: EMPTY
57465: LIST
57466: LIST
57467: PUSH
57468: EMPTY
57469: LIST
57470: LIST
57471: LIST
57472: LIST
57473: PPUSH
57474: CALL_OW 72
57478: AND
57479: PUSH
57480: LD_EXP 59
57484: PUSH
57485: LD_VAR 0 1
57489: ARRAY
57490: PPUSH
57491: LD_INT 30
57493: PUSH
57494: LD_INT 3
57496: PUSH
57497: EMPTY
57498: LIST
57499: LIST
57500: PPUSH
57501: CALL_OW 72
57505: AND
57506: IFFALSE 58240
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57508: LD_ADDR_EXP 101
57512: PUSH
57513: LD_EXP 101
57517: PPUSH
57518: LD_VAR 0 1
57522: PPUSH
57523: LD_INT 3
57525: PPUSH
57526: CALL_OW 1
57530: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57531: LD_ADDR_VAR 0 2
57535: PUSH
57536: LD_INT 0
57538: PUSH
57539: LD_INT 0
57541: PUSH
57542: LD_INT 0
57544: PUSH
57545: LD_INT 0
57547: PUSH
57548: EMPTY
57549: LIST
57550: LIST
57551: LIST
57552: LIST
57553: ST_TO_ADDR
// if not eng then
57554: LD_VAR 0 6
57558: NOT
57559: IFFALSE 57622
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57561: LD_ADDR_VAR 0 11
57565: PUSH
57566: LD_VAR 0 4
57570: PPUSH
57571: LD_INT 2
57573: PPUSH
57574: CALL 48812 0 2
57578: PUSH
57579: LD_INT 1
57581: ARRAY
57582: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57583: LD_ADDR_VAR 0 2
57587: PUSH
57588: LD_VAR 0 2
57592: PPUSH
57593: LD_INT 2
57595: PPUSH
57596: LD_VAR 0 11
57600: PPUSH
57601: CALL_OW 1
57605: ST_TO_ADDR
// tmp := tmp diff p ;
57606: LD_ADDR_VAR 0 4
57610: PUSH
57611: LD_VAR 0 4
57615: PUSH
57616: LD_VAR 0 11
57620: DIFF
57621: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57622: LD_VAR 0 4
57626: PUSH
57627: LD_VAR 0 8
57631: PUSH
57632: LD_INT 6
57634: LESS
57635: AND
57636: IFFALSE 57824
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57638: LD_ADDR_VAR 0 9
57642: PUSH
57643: LD_VAR 0 4
57647: PUSH
57648: LD_VAR 0 8
57652: PUSH
57653: LD_VAR 0 7
57657: UNION
57658: DIFF
57659: PPUSH
57660: LD_INT 4
57662: PPUSH
57663: CALL 48812 0 2
57667: ST_TO_ADDR
// p := [ ] ;
57668: LD_ADDR_VAR 0 11
57672: PUSH
57673: EMPTY
57674: ST_TO_ADDR
// if sort then
57675: LD_VAR 0 9
57679: IFFALSE 57795
// for i = 1 to 6 - sci do
57681: LD_ADDR_VAR 0 3
57685: PUSH
57686: DOUBLE
57687: LD_INT 1
57689: DEC
57690: ST_TO_ADDR
57691: LD_INT 6
57693: PUSH
57694: LD_VAR 0 8
57698: MINUS
57699: PUSH
57700: FOR_TO
57701: IFFALSE 57793
// begin if i = sort then
57703: LD_VAR 0 3
57707: PUSH
57708: LD_VAR 0 9
57712: EQUAL
57713: IFFALSE 57717
// break ;
57715: GO 57793
// if GetClass ( i ) = 4 then
57717: LD_VAR 0 3
57721: PPUSH
57722: CALL_OW 257
57726: PUSH
57727: LD_INT 4
57729: EQUAL
57730: IFFALSE 57734
// continue ;
57732: GO 57700
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57734: LD_ADDR_VAR 0 11
57738: PUSH
57739: LD_VAR 0 11
57743: PPUSH
57744: LD_VAR 0 11
57748: PUSH
57749: LD_INT 1
57751: PLUS
57752: PPUSH
57753: LD_VAR 0 9
57757: PUSH
57758: LD_VAR 0 3
57762: ARRAY
57763: PPUSH
57764: CALL_OW 2
57768: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57769: LD_ADDR_VAR 0 4
57773: PUSH
57774: LD_VAR 0 4
57778: PUSH
57779: LD_VAR 0 9
57783: PUSH
57784: LD_VAR 0 3
57788: ARRAY
57789: DIFF
57790: ST_TO_ADDR
// end ;
57791: GO 57700
57793: POP
57794: POP
// if p then
57795: LD_VAR 0 11
57799: IFFALSE 57824
// result := Replace ( result , 4 , p ) ;
57801: LD_ADDR_VAR 0 2
57805: PUSH
57806: LD_VAR 0 2
57810: PPUSH
57811: LD_INT 4
57813: PPUSH
57814: LD_VAR 0 11
57818: PPUSH
57819: CALL_OW 1
57823: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57824: LD_VAR 0 4
57828: PUSH
57829: LD_VAR 0 7
57833: PUSH
57834: LD_INT 6
57836: LESS
57837: AND
57838: IFFALSE 58026
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57840: LD_ADDR_VAR 0 9
57844: PUSH
57845: LD_VAR 0 4
57849: PUSH
57850: LD_VAR 0 8
57854: PUSH
57855: LD_VAR 0 7
57859: UNION
57860: DIFF
57861: PPUSH
57862: LD_INT 3
57864: PPUSH
57865: CALL 48812 0 2
57869: ST_TO_ADDR
// p := [ ] ;
57870: LD_ADDR_VAR 0 11
57874: PUSH
57875: EMPTY
57876: ST_TO_ADDR
// if sort then
57877: LD_VAR 0 9
57881: IFFALSE 57997
// for i = 1 to 6 - mech do
57883: LD_ADDR_VAR 0 3
57887: PUSH
57888: DOUBLE
57889: LD_INT 1
57891: DEC
57892: ST_TO_ADDR
57893: LD_INT 6
57895: PUSH
57896: LD_VAR 0 7
57900: MINUS
57901: PUSH
57902: FOR_TO
57903: IFFALSE 57995
// begin if i = sort then
57905: LD_VAR 0 3
57909: PUSH
57910: LD_VAR 0 9
57914: EQUAL
57915: IFFALSE 57919
// break ;
57917: GO 57995
// if GetClass ( i ) = 3 then
57919: LD_VAR 0 3
57923: PPUSH
57924: CALL_OW 257
57928: PUSH
57929: LD_INT 3
57931: EQUAL
57932: IFFALSE 57936
// continue ;
57934: GO 57902
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57936: LD_ADDR_VAR 0 11
57940: PUSH
57941: LD_VAR 0 11
57945: PPUSH
57946: LD_VAR 0 11
57950: PUSH
57951: LD_INT 1
57953: PLUS
57954: PPUSH
57955: LD_VAR 0 9
57959: PUSH
57960: LD_VAR 0 3
57964: ARRAY
57965: PPUSH
57966: CALL_OW 2
57970: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57971: LD_ADDR_VAR 0 4
57975: PUSH
57976: LD_VAR 0 4
57980: PUSH
57981: LD_VAR 0 9
57985: PUSH
57986: LD_VAR 0 3
57990: ARRAY
57991: DIFF
57992: ST_TO_ADDR
// end ;
57993: GO 57902
57995: POP
57996: POP
// if p then
57997: LD_VAR 0 11
58001: IFFALSE 58026
// result := Replace ( result , 3 , p ) ;
58003: LD_ADDR_VAR 0 2
58007: PUSH
58008: LD_VAR 0 2
58012: PPUSH
58013: LD_INT 3
58015: PPUSH
58016: LD_VAR 0 11
58020: PPUSH
58021: CALL_OW 1
58025: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
58026: LD_VAR 0 4
58030: PUSH
58031: LD_INT 6
58033: GREATER
58034: PUSH
58035: LD_VAR 0 6
58039: PUSH
58040: LD_INT 6
58042: LESS
58043: AND
58044: IFFALSE 58238
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58046: LD_ADDR_VAR 0 9
58050: PUSH
58051: LD_VAR 0 4
58055: PUSH
58056: LD_VAR 0 8
58060: PUSH
58061: LD_VAR 0 7
58065: UNION
58066: PUSH
58067: LD_VAR 0 6
58071: UNION
58072: DIFF
58073: PPUSH
58074: LD_INT 2
58076: PPUSH
58077: CALL 48812 0 2
58081: ST_TO_ADDR
// p := [ ] ;
58082: LD_ADDR_VAR 0 11
58086: PUSH
58087: EMPTY
58088: ST_TO_ADDR
// if sort then
58089: LD_VAR 0 9
58093: IFFALSE 58209
// for i = 1 to 6 - eng do
58095: LD_ADDR_VAR 0 3
58099: PUSH
58100: DOUBLE
58101: LD_INT 1
58103: DEC
58104: ST_TO_ADDR
58105: LD_INT 6
58107: PUSH
58108: LD_VAR 0 6
58112: MINUS
58113: PUSH
58114: FOR_TO
58115: IFFALSE 58207
// begin if i = sort then
58117: LD_VAR 0 3
58121: PUSH
58122: LD_VAR 0 9
58126: EQUAL
58127: IFFALSE 58131
// break ;
58129: GO 58207
// if GetClass ( i ) = 2 then
58131: LD_VAR 0 3
58135: PPUSH
58136: CALL_OW 257
58140: PUSH
58141: LD_INT 2
58143: EQUAL
58144: IFFALSE 58148
// continue ;
58146: GO 58114
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58148: LD_ADDR_VAR 0 11
58152: PUSH
58153: LD_VAR 0 11
58157: PPUSH
58158: LD_VAR 0 11
58162: PUSH
58163: LD_INT 1
58165: PLUS
58166: PPUSH
58167: LD_VAR 0 9
58171: PUSH
58172: LD_VAR 0 3
58176: ARRAY
58177: PPUSH
58178: CALL_OW 2
58182: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58183: LD_ADDR_VAR 0 4
58187: PUSH
58188: LD_VAR 0 4
58192: PUSH
58193: LD_VAR 0 9
58197: PUSH
58198: LD_VAR 0 3
58202: ARRAY
58203: DIFF
58204: ST_TO_ADDR
// end ;
58205: GO 58114
58207: POP
58208: POP
// if p then
58209: LD_VAR 0 11
58213: IFFALSE 58238
// result := Replace ( result , 2 , p ) ;
58215: LD_ADDR_VAR 0 2
58219: PUSH
58220: LD_VAR 0 2
58224: PPUSH
58225: LD_INT 2
58227: PPUSH
58228: LD_VAR 0 11
58232: PPUSH
58233: CALL_OW 1
58237: ST_TO_ADDR
// end ; exit ;
58238: GO 59626
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58240: LD_EXP 86
58244: PUSH
58245: LD_EXP 85
58249: PUSH
58250: LD_VAR 0 1
58254: ARRAY
58255: ARRAY
58256: NOT
58257: PUSH
58258: LD_EXP 59
58262: PUSH
58263: LD_VAR 0 1
58267: ARRAY
58268: PPUSH
58269: LD_INT 30
58271: PUSH
58272: LD_INT 3
58274: PUSH
58275: EMPTY
58276: LIST
58277: LIST
58278: PPUSH
58279: CALL_OW 72
58283: AND
58284: PUSH
58285: LD_EXP 64
58289: PUSH
58290: LD_VAR 0 1
58294: ARRAY
58295: AND
58296: IFFALSE 58904
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58298: LD_ADDR_EXP 101
58302: PUSH
58303: LD_EXP 101
58307: PPUSH
58308: LD_VAR 0 1
58312: PPUSH
58313: LD_INT 5
58315: PPUSH
58316: CALL_OW 1
58320: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58321: LD_ADDR_VAR 0 2
58325: PUSH
58326: LD_INT 0
58328: PUSH
58329: LD_INT 0
58331: PUSH
58332: LD_INT 0
58334: PUSH
58335: LD_INT 0
58337: PUSH
58338: EMPTY
58339: LIST
58340: LIST
58341: LIST
58342: LIST
58343: ST_TO_ADDR
// if sci > 1 then
58344: LD_VAR 0 8
58348: PUSH
58349: LD_INT 1
58351: GREATER
58352: IFFALSE 58380
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58354: LD_ADDR_VAR 0 4
58358: PUSH
58359: LD_VAR 0 4
58363: PUSH
58364: LD_VAR 0 8
58368: PUSH
58369: LD_VAR 0 8
58373: PUSH
58374: LD_INT 1
58376: ARRAY
58377: DIFF
58378: DIFF
58379: ST_TO_ADDR
// if tmp and not sci then
58380: LD_VAR 0 4
58384: PUSH
58385: LD_VAR 0 8
58389: NOT
58390: AND
58391: IFFALSE 58460
// begin sort := SortBySkill ( tmp , 4 ) ;
58393: LD_ADDR_VAR 0 9
58397: PUSH
58398: LD_VAR 0 4
58402: PPUSH
58403: LD_INT 4
58405: PPUSH
58406: CALL 48812 0 2
58410: ST_TO_ADDR
// if sort then
58411: LD_VAR 0 9
58415: IFFALSE 58431
// p := sort [ 1 ] ;
58417: LD_ADDR_VAR 0 11
58421: PUSH
58422: LD_VAR 0 9
58426: PUSH
58427: LD_INT 1
58429: ARRAY
58430: ST_TO_ADDR
// if p then
58431: LD_VAR 0 11
58435: IFFALSE 58460
// result := Replace ( result , 4 , p ) ;
58437: LD_ADDR_VAR 0 2
58441: PUSH
58442: LD_VAR 0 2
58446: PPUSH
58447: LD_INT 4
58449: PPUSH
58450: LD_VAR 0 11
58454: PPUSH
58455: CALL_OW 1
58459: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58460: LD_ADDR_VAR 0 4
58464: PUSH
58465: LD_VAR 0 4
58469: PUSH
58470: LD_VAR 0 7
58474: DIFF
58475: ST_TO_ADDR
// if tmp and mech < 6 then
58476: LD_VAR 0 4
58480: PUSH
58481: LD_VAR 0 7
58485: PUSH
58486: LD_INT 6
58488: LESS
58489: AND
58490: IFFALSE 58678
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58492: LD_ADDR_VAR 0 9
58496: PUSH
58497: LD_VAR 0 4
58501: PUSH
58502: LD_VAR 0 8
58506: PUSH
58507: LD_VAR 0 7
58511: UNION
58512: DIFF
58513: PPUSH
58514: LD_INT 3
58516: PPUSH
58517: CALL 48812 0 2
58521: ST_TO_ADDR
// p := [ ] ;
58522: LD_ADDR_VAR 0 11
58526: PUSH
58527: EMPTY
58528: ST_TO_ADDR
// if sort then
58529: LD_VAR 0 9
58533: IFFALSE 58649
// for i = 1 to 6 - mech do
58535: LD_ADDR_VAR 0 3
58539: PUSH
58540: DOUBLE
58541: LD_INT 1
58543: DEC
58544: ST_TO_ADDR
58545: LD_INT 6
58547: PUSH
58548: LD_VAR 0 7
58552: MINUS
58553: PUSH
58554: FOR_TO
58555: IFFALSE 58647
// begin if i = sort then
58557: LD_VAR 0 3
58561: PUSH
58562: LD_VAR 0 9
58566: EQUAL
58567: IFFALSE 58571
// break ;
58569: GO 58647
// if GetClass ( i ) = 3 then
58571: LD_VAR 0 3
58575: PPUSH
58576: CALL_OW 257
58580: PUSH
58581: LD_INT 3
58583: EQUAL
58584: IFFALSE 58588
// continue ;
58586: GO 58554
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58588: LD_ADDR_VAR 0 11
58592: PUSH
58593: LD_VAR 0 11
58597: PPUSH
58598: LD_VAR 0 11
58602: PUSH
58603: LD_INT 1
58605: PLUS
58606: PPUSH
58607: LD_VAR 0 9
58611: PUSH
58612: LD_VAR 0 3
58616: ARRAY
58617: PPUSH
58618: CALL_OW 2
58622: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58623: LD_ADDR_VAR 0 4
58627: PUSH
58628: LD_VAR 0 4
58632: PUSH
58633: LD_VAR 0 9
58637: PUSH
58638: LD_VAR 0 3
58642: ARRAY
58643: DIFF
58644: ST_TO_ADDR
// end ;
58645: GO 58554
58647: POP
58648: POP
// if p then
58649: LD_VAR 0 11
58653: IFFALSE 58678
// result := Replace ( result , 3 , p ) ;
58655: LD_ADDR_VAR 0 2
58659: PUSH
58660: LD_VAR 0 2
58664: PPUSH
58665: LD_INT 3
58667: PPUSH
58668: LD_VAR 0 11
58672: PPUSH
58673: CALL_OW 1
58677: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58678: LD_ADDR_VAR 0 4
58682: PUSH
58683: LD_VAR 0 4
58687: PUSH
58688: LD_VAR 0 6
58692: DIFF
58693: ST_TO_ADDR
// if tmp and eng < 6 then
58694: LD_VAR 0 4
58698: PUSH
58699: LD_VAR 0 6
58703: PUSH
58704: LD_INT 6
58706: LESS
58707: AND
58708: IFFALSE 58902
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58710: LD_ADDR_VAR 0 9
58714: PUSH
58715: LD_VAR 0 4
58719: PUSH
58720: LD_VAR 0 8
58724: PUSH
58725: LD_VAR 0 7
58729: UNION
58730: PUSH
58731: LD_VAR 0 6
58735: UNION
58736: DIFF
58737: PPUSH
58738: LD_INT 2
58740: PPUSH
58741: CALL 48812 0 2
58745: ST_TO_ADDR
// p := [ ] ;
58746: LD_ADDR_VAR 0 11
58750: PUSH
58751: EMPTY
58752: ST_TO_ADDR
// if sort then
58753: LD_VAR 0 9
58757: IFFALSE 58873
// for i = 1 to 6 - eng do
58759: LD_ADDR_VAR 0 3
58763: PUSH
58764: DOUBLE
58765: LD_INT 1
58767: DEC
58768: ST_TO_ADDR
58769: LD_INT 6
58771: PUSH
58772: LD_VAR 0 6
58776: MINUS
58777: PUSH
58778: FOR_TO
58779: IFFALSE 58871
// begin if i = sort then
58781: LD_VAR 0 3
58785: PUSH
58786: LD_VAR 0 9
58790: EQUAL
58791: IFFALSE 58795
// break ;
58793: GO 58871
// if GetClass ( i ) = 2 then
58795: LD_VAR 0 3
58799: PPUSH
58800: CALL_OW 257
58804: PUSH
58805: LD_INT 2
58807: EQUAL
58808: IFFALSE 58812
// continue ;
58810: GO 58778
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58812: LD_ADDR_VAR 0 11
58816: PUSH
58817: LD_VAR 0 11
58821: PPUSH
58822: LD_VAR 0 11
58826: PUSH
58827: LD_INT 1
58829: PLUS
58830: PPUSH
58831: LD_VAR 0 9
58835: PUSH
58836: LD_VAR 0 3
58840: ARRAY
58841: PPUSH
58842: CALL_OW 2
58846: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58847: LD_ADDR_VAR 0 4
58851: PUSH
58852: LD_VAR 0 4
58856: PUSH
58857: LD_VAR 0 9
58861: PUSH
58862: LD_VAR 0 3
58866: ARRAY
58867: DIFF
58868: ST_TO_ADDR
// end ;
58869: GO 58778
58871: POP
58872: POP
// if p then
58873: LD_VAR 0 11
58877: IFFALSE 58902
// result := Replace ( result , 2 , p ) ;
58879: LD_ADDR_VAR 0 2
58883: PUSH
58884: LD_VAR 0 2
58888: PPUSH
58889: LD_INT 2
58891: PPUSH
58892: LD_VAR 0 11
58896: PPUSH
58897: CALL_OW 1
58901: ST_TO_ADDR
// end ; exit ;
58902: GO 59626
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58904: LD_EXP 86
58908: PUSH
58909: LD_EXP 85
58913: PUSH
58914: LD_VAR 0 1
58918: ARRAY
58919: ARRAY
58920: NOT
58921: PUSH
58922: LD_EXP 59
58926: PUSH
58927: LD_VAR 0 1
58931: ARRAY
58932: PPUSH
58933: LD_INT 30
58935: PUSH
58936: LD_INT 3
58938: PUSH
58939: EMPTY
58940: LIST
58941: LIST
58942: PPUSH
58943: CALL_OW 72
58947: AND
58948: PUSH
58949: LD_EXP 64
58953: PUSH
58954: LD_VAR 0 1
58958: ARRAY
58959: NOT
58960: AND
58961: IFFALSE 59626
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58963: LD_ADDR_EXP 101
58967: PUSH
58968: LD_EXP 101
58972: PPUSH
58973: LD_VAR 0 1
58977: PPUSH
58978: LD_INT 6
58980: PPUSH
58981: CALL_OW 1
58985: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58986: LD_ADDR_VAR 0 2
58990: PUSH
58991: LD_INT 0
58993: PUSH
58994: LD_INT 0
58996: PUSH
58997: LD_INT 0
58999: PUSH
59000: LD_INT 0
59002: PUSH
59003: EMPTY
59004: LIST
59005: LIST
59006: LIST
59007: LIST
59008: ST_TO_ADDR
// if sci >= 1 then
59009: LD_VAR 0 8
59013: PUSH
59014: LD_INT 1
59016: GREATEREQUAL
59017: IFFALSE 59039
// tmp := tmp diff sci [ 1 ] ;
59019: LD_ADDR_VAR 0 4
59023: PUSH
59024: LD_VAR 0 4
59028: PUSH
59029: LD_VAR 0 8
59033: PUSH
59034: LD_INT 1
59036: ARRAY
59037: DIFF
59038: ST_TO_ADDR
// if tmp and not sci then
59039: LD_VAR 0 4
59043: PUSH
59044: LD_VAR 0 8
59048: NOT
59049: AND
59050: IFFALSE 59119
// begin sort := SortBySkill ( tmp , 4 ) ;
59052: LD_ADDR_VAR 0 9
59056: PUSH
59057: LD_VAR 0 4
59061: PPUSH
59062: LD_INT 4
59064: PPUSH
59065: CALL 48812 0 2
59069: ST_TO_ADDR
// if sort then
59070: LD_VAR 0 9
59074: IFFALSE 59090
// p := sort [ 1 ] ;
59076: LD_ADDR_VAR 0 11
59080: PUSH
59081: LD_VAR 0 9
59085: PUSH
59086: LD_INT 1
59088: ARRAY
59089: ST_TO_ADDR
// if p then
59090: LD_VAR 0 11
59094: IFFALSE 59119
// result := Replace ( result , 4 , p ) ;
59096: LD_ADDR_VAR 0 2
59100: PUSH
59101: LD_VAR 0 2
59105: PPUSH
59106: LD_INT 4
59108: PPUSH
59109: LD_VAR 0 11
59113: PPUSH
59114: CALL_OW 1
59118: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59119: LD_ADDR_VAR 0 4
59123: PUSH
59124: LD_VAR 0 4
59128: PUSH
59129: LD_VAR 0 7
59133: DIFF
59134: ST_TO_ADDR
// if tmp and mech < 6 then
59135: LD_VAR 0 4
59139: PUSH
59140: LD_VAR 0 7
59144: PUSH
59145: LD_INT 6
59147: LESS
59148: AND
59149: IFFALSE 59331
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
59151: LD_ADDR_VAR 0 9
59155: PUSH
59156: LD_VAR 0 4
59160: PUSH
59161: LD_VAR 0 7
59165: DIFF
59166: PPUSH
59167: LD_INT 3
59169: PPUSH
59170: CALL 48812 0 2
59174: ST_TO_ADDR
// p := [ ] ;
59175: LD_ADDR_VAR 0 11
59179: PUSH
59180: EMPTY
59181: ST_TO_ADDR
// if sort then
59182: LD_VAR 0 9
59186: IFFALSE 59302
// for i = 1 to 6 - mech do
59188: LD_ADDR_VAR 0 3
59192: PUSH
59193: DOUBLE
59194: LD_INT 1
59196: DEC
59197: ST_TO_ADDR
59198: LD_INT 6
59200: PUSH
59201: LD_VAR 0 7
59205: MINUS
59206: PUSH
59207: FOR_TO
59208: IFFALSE 59300
// begin if i = sort then
59210: LD_VAR 0 3
59214: PUSH
59215: LD_VAR 0 9
59219: EQUAL
59220: IFFALSE 59224
// break ;
59222: GO 59300
// if GetClass ( i ) = 3 then
59224: LD_VAR 0 3
59228: PPUSH
59229: CALL_OW 257
59233: PUSH
59234: LD_INT 3
59236: EQUAL
59237: IFFALSE 59241
// continue ;
59239: GO 59207
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59241: LD_ADDR_VAR 0 11
59245: PUSH
59246: LD_VAR 0 11
59250: PPUSH
59251: LD_VAR 0 11
59255: PUSH
59256: LD_INT 1
59258: PLUS
59259: PPUSH
59260: LD_VAR 0 9
59264: PUSH
59265: LD_VAR 0 3
59269: ARRAY
59270: PPUSH
59271: CALL_OW 2
59275: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59276: LD_ADDR_VAR 0 4
59280: PUSH
59281: LD_VAR 0 4
59285: PUSH
59286: LD_VAR 0 9
59290: PUSH
59291: LD_VAR 0 3
59295: ARRAY
59296: DIFF
59297: ST_TO_ADDR
// end ;
59298: GO 59207
59300: POP
59301: POP
// if p then
59302: LD_VAR 0 11
59306: IFFALSE 59331
// result := Replace ( result , 3 , p ) ;
59308: LD_ADDR_VAR 0 2
59312: PUSH
59313: LD_VAR 0 2
59317: PPUSH
59318: LD_INT 3
59320: PPUSH
59321: LD_VAR 0 11
59325: PPUSH
59326: CALL_OW 1
59330: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59331: LD_ADDR_VAR 0 4
59335: PUSH
59336: LD_VAR 0 4
59340: PUSH
59341: LD_VAR 0 6
59345: DIFF
59346: ST_TO_ADDR
// if tmp and eng < 4 then
59347: LD_VAR 0 4
59351: PUSH
59352: LD_VAR 0 6
59356: PUSH
59357: LD_INT 4
59359: LESS
59360: AND
59361: IFFALSE 59551
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59363: LD_ADDR_VAR 0 9
59367: PUSH
59368: LD_VAR 0 4
59372: PUSH
59373: LD_VAR 0 7
59377: PUSH
59378: LD_VAR 0 6
59382: UNION
59383: DIFF
59384: PPUSH
59385: LD_INT 2
59387: PPUSH
59388: CALL 48812 0 2
59392: ST_TO_ADDR
// p := [ ] ;
59393: LD_ADDR_VAR 0 11
59397: PUSH
59398: EMPTY
59399: ST_TO_ADDR
// if sort then
59400: LD_VAR 0 9
59404: IFFALSE 59520
// for i = 1 to 4 - eng do
59406: LD_ADDR_VAR 0 3
59410: PUSH
59411: DOUBLE
59412: LD_INT 1
59414: DEC
59415: ST_TO_ADDR
59416: LD_INT 4
59418: PUSH
59419: LD_VAR 0 6
59423: MINUS
59424: PUSH
59425: FOR_TO
59426: IFFALSE 59518
// begin if i = sort then
59428: LD_VAR 0 3
59432: PUSH
59433: LD_VAR 0 9
59437: EQUAL
59438: IFFALSE 59442
// break ;
59440: GO 59518
// if GetClass ( i ) = 2 then
59442: LD_VAR 0 3
59446: PPUSH
59447: CALL_OW 257
59451: PUSH
59452: LD_INT 2
59454: EQUAL
59455: IFFALSE 59459
// continue ;
59457: GO 59425
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59459: LD_ADDR_VAR 0 11
59463: PUSH
59464: LD_VAR 0 11
59468: PPUSH
59469: LD_VAR 0 11
59473: PUSH
59474: LD_INT 1
59476: PLUS
59477: PPUSH
59478: LD_VAR 0 9
59482: PUSH
59483: LD_VAR 0 3
59487: ARRAY
59488: PPUSH
59489: CALL_OW 2
59493: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59494: LD_ADDR_VAR 0 4
59498: PUSH
59499: LD_VAR 0 4
59503: PUSH
59504: LD_VAR 0 9
59508: PUSH
59509: LD_VAR 0 3
59513: ARRAY
59514: DIFF
59515: ST_TO_ADDR
// end ;
59516: GO 59425
59518: POP
59519: POP
// if p then
59520: LD_VAR 0 11
59524: IFFALSE 59549
// result := Replace ( result , 2 , p ) ;
59526: LD_ADDR_VAR 0 2
59530: PUSH
59531: LD_VAR 0 2
59535: PPUSH
59536: LD_INT 2
59538: PPUSH
59539: LD_VAR 0 11
59543: PPUSH
59544: CALL_OW 1
59548: ST_TO_ADDR
// end else
59549: GO 59595
// for i = eng downto 5 do
59551: LD_ADDR_VAR 0 3
59555: PUSH
59556: DOUBLE
59557: LD_VAR 0 6
59561: INC
59562: ST_TO_ADDR
59563: LD_INT 5
59565: PUSH
59566: FOR_DOWNTO
59567: IFFALSE 59593
// tmp := tmp union eng [ i ] ;
59569: LD_ADDR_VAR 0 4
59573: PUSH
59574: LD_VAR 0 4
59578: PUSH
59579: LD_VAR 0 6
59583: PUSH
59584: LD_VAR 0 3
59588: ARRAY
59589: UNION
59590: ST_TO_ADDR
59591: GO 59566
59593: POP
59594: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59595: LD_ADDR_VAR 0 2
59599: PUSH
59600: LD_VAR 0 2
59604: PPUSH
59605: LD_INT 1
59607: PPUSH
59608: LD_VAR 0 4
59612: PUSH
59613: LD_VAR 0 5
59617: DIFF
59618: PPUSH
59619: CALL_OW 1
59623: ST_TO_ADDR
// exit ;
59624: GO 59626
// end ; end ;
59626: LD_VAR 0 2
59630: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59631: LD_INT 0
59633: PPUSH
59634: PPUSH
59635: PPUSH
// if not mc_bases then
59636: LD_EXP 59
59640: NOT
59641: IFFALSE 59645
// exit ;
59643: GO 59751
// for i = 1 to mc_bases do
59645: LD_ADDR_VAR 0 2
59649: PUSH
59650: DOUBLE
59651: LD_INT 1
59653: DEC
59654: ST_TO_ADDR
59655: LD_EXP 59
59659: PUSH
59660: FOR_TO
59661: IFFALSE 59742
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59663: LD_ADDR_VAR 0 3
59667: PUSH
59668: LD_EXP 59
59672: PUSH
59673: LD_VAR 0 2
59677: ARRAY
59678: PPUSH
59679: LD_INT 21
59681: PUSH
59682: LD_INT 3
59684: PUSH
59685: EMPTY
59686: LIST
59687: LIST
59688: PUSH
59689: LD_INT 3
59691: PUSH
59692: LD_INT 24
59694: PUSH
59695: LD_INT 1000
59697: PUSH
59698: EMPTY
59699: LIST
59700: LIST
59701: PUSH
59702: EMPTY
59703: LIST
59704: LIST
59705: PUSH
59706: EMPTY
59707: LIST
59708: LIST
59709: PPUSH
59710: CALL_OW 72
59714: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59715: LD_ADDR_EXP 60
59719: PUSH
59720: LD_EXP 60
59724: PPUSH
59725: LD_VAR 0 2
59729: PPUSH
59730: LD_VAR 0 3
59734: PPUSH
59735: CALL_OW 1
59739: ST_TO_ADDR
// end ;
59740: GO 59660
59742: POP
59743: POP
// RaiseSailEvent ( 101 ) ;
59744: LD_INT 101
59746: PPUSH
59747: CALL_OW 427
// end ;
59751: LD_VAR 0 1
59755: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59756: LD_INT 0
59758: PPUSH
59759: PPUSH
59760: PPUSH
59761: PPUSH
59762: PPUSH
59763: PPUSH
59764: PPUSH
// if not mc_bases then
59765: LD_EXP 59
59769: NOT
59770: IFFALSE 59774
// exit ;
59772: GO 60336
// for i = 1 to mc_bases do
59774: LD_ADDR_VAR 0 2
59778: PUSH
59779: DOUBLE
59780: LD_INT 1
59782: DEC
59783: ST_TO_ADDR
59784: LD_EXP 59
59788: PUSH
59789: FOR_TO
59790: IFFALSE 60327
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
59792: LD_ADDR_VAR 0 5
59796: PUSH
59797: LD_EXP 59
59801: PUSH
59802: LD_VAR 0 2
59806: ARRAY
59807: PUSH
59808: LD_EXP 88
59812: PUSH
59813: LD_VAR 0 2
59817: ARRAY
59818: UNION
59819: PPUSH
59820: LD_INT 21
59822: PUSH
59823: LD_INT 1
59825: PUSH
59826: EMPTY
59827: LIST
59828: LIST
59829: PUSH
59830: LD_INT 1
59832: PUSH
59833: LD_INT 3
59835: PUSH
59836: LD_INT 54
59838: PUSH
59839: EMPTY
59840: LIST
59841: PUSH
59842: EMPTY
59843: LIST
59844: LIST
59845: PUSH
59846: LD_INT 3
59848: PUSH
59849: LD_INT 24
59851: PUSH
59852: LD_INT 800
59854: PUSH
59855: EMPTY
59856: LIST
59857: LIST
59858: PUSH
59859: EMPTY
59860: LIST
59861: LIST
59862: PUSH
59863: EMPTY
59864: LIST
59865: LIST
59866: LIST
59867: PUSH
59868: EMPTY
59869: LIST
59870: LIST
59871: PPUSH
59872: CALL_OW 72
59876: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59877: LD_ADDR_VAR 0 6
59881: PUSH
59882: LD_EXP 59
59886: PUSH
59887: LD_VAR 0 2
59891: ARRAY
59892: PPUSH
59893: LD_INT 21
59895: PUSH
59896: LD_INT 1
59898: PUSH
59899: EMPTY
59900: LIST
59901: LIST
59902: PUSH
59903: LD_INT 1
59905: PUSH
59906: LD_INT 3
59908: PUSH
59909: LD_INT 54
59911: PUSH
59912: EMPTY
59913: LIST
59914: PUSH
59915: EMPTY
59916: LIST
59917: LIST
59918: PUSH
59919: LD_INT 3
59921: PUSH
59922: LD_INT 24
59924: PUSH
59925: LD_INT 250
59927: PUSH
59928: EMPTY
59929: LIST
59930: LIST
59931: PUSH
59932: EMPTY
59933: LIST
59934: LIST
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: LIST
59940: PUSH
59941: EMPTY
59942: LIST
59943: LIST
59944: PPUSH
59945: CALL_OW 72
59949: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59950: LD_ADDR_VAR 0 7
59954: PUSH
59955: LD_VAR 0 5
59959: PUSH
59960: LD_VAR 0 6
59964: DIFF
59965: ST_TO_ADDR
// if not need_heal_1 then
59966: LD_VAR 0 6
59970: NOT
59971: IFFALSE 60004
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59973: LD_ADDR_EXP 62
59977: PUSH
59978: LD_EXP 62
59982: PPUSH
59983: LD_VAR 0 2
59987: PUSH
59988: LD_INT 1
59990: PUSH
59991: EMPTY
59992: LIST
59993: LIST
59994: PPUSH
59995: EMPTY
59996: PPUSH
59997: CALL 19263 0 3
60001: ST_TO_ADDR
60002: GO 60074
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
60004: LD_ADDR_EXP 62
60008: PUSH
60009: LD_EXP 62
60013: PPUSH
60014: LD_VAR 0 2
60018: PUSH
60019: LD_INT 1
60021: PUSH
60022: EMPTY
60023: LIST
60024: LIST
60025: PPUSH
60026: LD_EXP 62
60030: PUSH
60031: LD_VAR 0 2
60035: ARRAY
60036: PUSH
60037: LD_INT 1
60039: ARRAY
60040: PPUSH
60041: LD_INT 3
60043: PUSH
60044: LD_INT 24
60046: PUSH
60047: LD_INT 1000
60049: PUSH
60050: EMPTY
60051: LIST
60052: LIST
60053: PUSH
60054: EMPTY
60055: LIST
60056: LIST
60057: PPUSH
60058: CALL_OW 72
60062: PUSH
60063: LD_VAR 0 6
60067: UNION
60068: PPUSH
60069: CALL 19263 0 3
60073: ST_TO_ADDR
// if not need_heal_2 then
60074: LD_VAR 0 7
60078: NOT
60079: IFFALSE 60112
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
60081: LD_ADDR_EXP 62
60085: PUSH
60086: LD_EXP 62
60090: PPUSH
60091: LD_VAR 0 2
60095: PUSH
60096: LD_INT 2
60098: PUSH
60099: EMPTY
60100: LIST
60101: LIST
60102: PPUSH
60103: EMPTY
60104: PPUSH
60105: CALL 19263 0 3
60109: ST_TO_ADDR
60110: GO 60144
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
60112: LD_ADDR_EXP 62
60116: PUSH
60117: LD_EXP 62
60121: PPUSH
60122: LD_VAR 0 2
60126: PUSH
60127: LD_INT 2
60129: PUSH
60130: EMPTY
60131: LIST
60132: LIST
60133: PPUSH
60134: LD_VAR 0 7
60138: PPUSH
60139: CALL 19263 0 3
60143: ST_TO_ADDR
// if need_heal_2 then
60144: LD_VAR 0 7
60148: IFFALSE 60309
// for j in need_heal_2 do
60150: LD_ADDR_VAR 0 3
60154: PUSH
60155: LD_VAR 0 7
60159: PUSH
60160: FOR_IN
60161: IFFALSE 60307
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60163: LD_ADDR_VAR 0 5
60167: PUSH
60168: LD_EXP 59
60172: PUSH
60173: LD_VAR 0 2
60177: ARRAY
60178: PPUSH
60179: LD_INT 2
60181: PUSH
60182: LD_INT 30
60184: PUSH
60185: LD_INT 6
60187: PUSH
60188: EMPTY
60189: LIST
60190: LIST
60191: PUSH
60192: LD_INT 30
60194: PUSH
60195: LD_INT 7
60197: PUSH
60198: EMPTY
60199: LIST
60200: LIST
60201: PUSH
60202: LD_INT 30
60204: PUSH
60205: LD_INT 8
60207: PUSH
60208: EMPTY
60209: LIST
60210: LIST
60211: PUSH
60212: LD_INT 30
60214: PUSH
60215: LD_INT 0
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: PUSH
60222: LD_INT 30
60224: PUSH
60225: LD_INT 1
60227: PUSH
60228: EMPTY
60229: LIST
60230: LIST
60231: PUSH
60232: EMPTY
60233: LIST
60234: LIST
60235: LIST
60236: LIST
60237: LIST
60238: LIST
60239: PPUSH
60240: CALL_OW 72
60244: ST_TO_ADDR
// if tmp then
60245: LD_VAR 0 5
60249: IFFALSE 60305
// begin k := NearestUnitToUnit ( tmp , j ) ;
60251: LD_ADDR_VAR 0 4
60255: PUSH
60256: LD_VAR 0 5
60260: PPUSH
60261: LD_VAR 0 3
60265: PPUSH
60266: CALL_OW 74
60270: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60271: LD_VAR 0 3
60275: PPUSH
60276: LD_VAR 0 4
60280: PPUSH
60281: CALL_OW 296
60285: PUSH
60286: LD_INT 5
60288: GREATER
60289: IFFALSE 60305
// ComMoveToNearbyEntrance ( j , k ) ;
60291: LD_VAR 0 3
60295: PPUSH
60296: LD_VAR 0 4
60300: PPUSH
60301: CALL 51129 0 2
// end ; end ;
60305: GO 60160
60307: POP
60308: POP
// if not need_heal_1 and not need_heal_2 then
60309: LD_VAR 0 6
60313: NOT
60314: PUSH
60315: LD_VAR 0 7
60319: NOT
60320: AND
60321: IFFALSE 60325
// continue ;
60323: GO 59789
// end ;
60325: GO 59789
60327: POP
60328: POP
// RaiseSailEvent ( 102 ) ;
60329: LD_INT 102
60331: PPUSH
60332: CALL_OW 427
// end ;
60336: LD_VAR 0 1
60340: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60341: LD_INT 0
60343: PPUSH
60344: PPUSH
60345: PPUSH
60346: PPUSH
60347: PPUSH
60348: PPUSH
60349: PPUSH
60350: PPUSH
// if not mc_bases then
60351: LD_EXP 59
60355: NOT
60356: IFFALSE 60360
// exit ;
60358: GO 61221
// for i = 1 to mc_bases do
60360: LD_ADDR_VAR 0 2
60364: PUSH
60365: DOUBLE
60366: LD_INT 1
60368: DEC
60369: ST_TO_ADDR
60370: LD_EXP 59
60374: PUSH
60375: FOR_TO
60376: IFFALSE 61219
// begin if not mc_building_need_repair [ i ] then
60378: LD_EXP 60
60382: PUSH
60383: LD_VAR 0 2
60387: ARRAY
60388: NOT
60389: IFFALSE 60576
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60391: LD_ADDR_VAR 0 6
60395: PUSH
60396: LD_EXP 78
60400: PUSH
60401: LD_VAR 0 2
60405: ARRAY
60406: PPUSH
60407: LD_INT 3
60409: PUSH
60410: LD_INT 24
60412: PUSH
60413: LD_INT 1000
60415: PUSH
60416: EMPTY
60417: LIST
60418: LIST
60419: PUSH
60420: EMPTY
60421: LIST
60422: LIST
60423: PUSH
60424: LD_INT 2
60426: PUSH
60427: LD_INT 34
60429: PUSH
60430: LD_INT 13
60432: PUSH
60433: EMPTY
60434: LIST
60435: LIST
60436: PUSH
60437: LD_INT 34
60439: PUSH
60440: LD_INT 52
60442: PUSH
60443: EMPTY
60444: LIST
60445: LIST
60446: PUSH
60447: LD_INT 34
60449: PUSH
60450: LD_EXP 108
60454: PUSH
60455: EMPTY
60456: LIST
60457: LIST
60458: PUSH
60459: EMPTY
60460: LIST
60461: LIST
60462: LIST
60463: LIST
60464: PUSH
60465: EMPTY
60466: LIST
60467: LIST
60468: PPUSH
60469: CALL_OW 72
60473: ST_TO_ADDR
// if cranes then
60474: LD_VAR 0 6
60478: IFFALSE 60540
// for j in cranes do
60480: LD_ADDR_VAR 0 3
60484: PUSH
60485: LD_VAR 0 6
60489: PUSH
60490: FOR_IN
60491: IFFALSE 60538
// if not IsInArea ( j , mc_parking [ i ] ) then
60493: LD_VAR 0 3
60497: PPUSH
60498: LD_EXP 83
60502: PUSH
60503: LD_VAR 0 2
60507: ARRAY
60508: PPUSH
60509: CALL_OW 308
60513: NOT
60514: IFFALSE 60536
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60516: LD_VAR 0 3
60520: PPUSH
60521: LD_EXP 83
60525: PUSH
60526: LD_VAR 0 2
60530: ARRAY
60531: PPUSH
60532: CALL_OW 113
60536: GO 60490
60538: POP
60539: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60540: LD_ADDR_EXP 61
60544: PUSH
60545: LD_EXP 61
60549: PPUSH
60550: LD_VAR 0 2
60554: PPUSH
60555: EMPTY
60556: PPUSH
60557: CALL_OW 1
60561: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60562: LD_VAR 0 2
60566: PPUSH
60567: LD_INT 101
60569: PPUSH
60570: CALL 55464 0 2
// continue ;
60574: GO 60375
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60576: LD_ADDR_EXP 65
60580: PUSH
60581: LD_EXP 65
60585: PPUSH
60586: LD_VAR 0 2
60590: PPUSH
60591: EMPTY
60592: PPUSH
60593: CALL_OW 1
60597: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60598: LD_VAR 0 2
60602: PPUSH
60603: LD_INT 103
60605: PPUSH
60606: CALL 55464 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60610: LD_ADDR_VAR 0 5
60614: PUSH
60615: LD_EXP 59
60619: PUSH
60620: LD_VAR 0 2
60624: ARRAY
60625: PUSH
60626: LD_EXP 88
60630: PUSH
60631: LD_VAR 0 2
60635: ARRAY
60636: UNION
60637: PPUSH
60638: LD_INT 2
60640: PUSH
60641: LD_INT 25
60643: PUSH
60644: LD_INT 2
60646: PUSH
60647: EMPTY
60648: LIST
60649: LIST
60650: PUSH
60651: LD_INT 25
60653: PUSH
60654: LD_INT 16
60656: PUSH
60657: EMPTY
60658: LIST
60659: LIST
60660: PUSH
60661: EMPTY
60662: LIST
60663: LIST
60664: LIST
60665: PUSH
60666: EMPTY
60667: LIST
60668: PPUSH
60669: CALL_OW 72
60673: PUSH
60674: LD_EXP 62
60678: PUSH
60679: LD_VAR 0 2
60683: ARRAY
60684: PUSH
60685: LD_INT 1
60687: ARRAY
60688: PUSH
60689: LD_EXP 62
60693: PUSH
60694: LD_VAR 0 2
60698: ARRAY
60699: PUSH
60700: LD_INT 2
60702: ARRAY
60703: UNION
60704: DIFF
60705: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60706: LD_ADDR_VAR 0 6
60710: PUSH
60711: LD_EXP 78
60715: PUSH
60716: LD_VAR 0 2
60720: ARRAY
60721: PPUSH
60722: LD_INT 2
60724: PUSH
60725: LD_INT 34
60727: PUSH
60728: LD_INT 13
60730: PUSH
60731: EMPTY
60732: LIST
60733: LIST
60734: PUSH
60735: LD_INT 34
60737: PUSH
60738: LD_INT 52
60740: PUSH
60741: EMPTY
60742: LIST
60743: LIST
60744: PUSH
60745: LD_INT 34
60747: PUSH
60748: LD_EXP 108
60752: PUSH
60753: EMPTY
60754: LIST
60755: LIST
60756: PUSH
60757: EMPTY
60758: LIST
60759: LIST
60760: LIST
60761: LIST
60762: PPUSH
60763: CALL_OW 72
60767: ST_TO_ADDR
// if cranes then
60768: LD_VAR 0 6
60772: IFFALSE 60908
// begin for j in cranes do
60774: LD_ADDR_VAR 0 3
60778: PUSH
60779: LD_VAR 0 6
60783: PUSH
60784: FOR_IN
60785: IFFALSE 60906
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60787: LD_VAR 0 3
60791: PPUSH
60792: CALL_OW 256
60796: PUSH
60797: LD_INT 1000
60799: EQUAL
60800: PUSH
60801: LD_VAR 0 3
60805: PPUSH
60806: CALL_OW 314
60810: NOT
60811: AND
60812: IFFALSE 60846
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60814: LD_VAR 0 3
60818: PPUSH
60819: LD_EXP 60
60823: PUSH
60824: LD_VAR 0 2
60828: ARRAY
60829: PPUSH
60830: LD_VAR 0 3
60834: PPUSH
60835: CALL_OW 74
60839: PPUSH
60840: CALL_OW 130
60844: GO 60904
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60846: LD_VAR 0 3
60850: PPUSH
60851: CALL_OW 256
60855: PUSH
60856: LD_INT 500
60858: LESS
60859: PUSH
60860: LD_VAR 0 3
60864: PPUSH
60865: LD_EXP 83
60869: PUSH
60870: LD_VAR 0 2
60874: ARRAY
60875: PPUSH
60876: CALL_OW 308
60880: NOT
60881: AND
60882: IFFALSE 60904
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60884: LD_VAR 0 3
60888: PPUSH
60889: LD_EXP 83
60893: PUSH
60894: LD_VAR 0 2
60898: ARRAY
60899: PPUSH
60900: CALL_OW 113
// end ;
60904: GO 60784
60906: POP
60907: POP
// end ; if tmp > 3 then
60908: LD_VAR 0 5
60912: PUSH
60913: LD_INT 3
60915: GREATER
60916: IFFALSE 60936
// tmp := ShrinkArray ( tmp , 4 ) ;
60918: LD_ADDR_VAR 0 5
60922: PUSH
60923: LD_VAR 0 5
60927: PPUSH
60928: LD_INT 4
60930: PPUSH
60931: CALL 50621 0 2
60935: ST_TO_ADDR
// if not tmp then
60936: LD_VAR 0 5
60940: NOT
60941: IFFALSE 60945
// continue ;
60943: GO 60375
// for j in tmp do
60945: LD_ADDR_VAR 0 3
60949: PUSH
60950: LD_VAR 0 5
60954: PUSH
60955: FOR_IN
60956: IFFALSE 61215
// begin if IsInUnit ( j ) then
60958: LD_VAR 0 3
60962: PPUSH
60963: CALL_OW 310
60967: IFFALSE 60978
// ComExitBuilding ( j ) ;
60969: LD_VAR 0 3
60973: PPUSH
60974: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60978: LD_VAR 0 3
60982: PUSH
60983: LD_EXP 61
60987: PUSH
60988: LD_VAR 0 2
60992: ARRAY
60993: IN
60994: NOT
60995: IFFALSE 61053
// begin SetTag ( j , 101 ) ;
60997: LD_VAR 0 3
61001: PPUSH
61002: LD_INT 101
61004: PPUSH
61005: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61009: LD_ADDR_EXP 61
61013: PUSH
61014: LD_EXP 61
61018: PPUSH
61019: LD_VAR 0 2
61023: PUSH
61024: LD_EXP 61
61028: PUSH
61029: LD_VAR 0 2
61033: ARRAY
61034: PUSH
61035: LD_INT 1
61037: PLUS
61038: PUSH
61039: EMPTY
61040: LIST
61041: LIST
61042: PPUSH
61043: LD_VAR 0 3
61047: PPUSH
61048: CALL 19263 0 3
61052: ST_TO_ADDR
// end ; wait ( 1 ) ;
61053: LD_INT 1
61055: PPUSH
61056: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
61060: LD_ADDR_VAR 0 7
61064: PUSH
61065: LD_EXP 60
61069: PUSH
61070: LD_VAR 0 2
61074: ARRAY
61075: ST_TO_ADDR
// if mc_scan [ i ] then
61076: LD_EXP 82
61080: PUSH
61081: LD_VAR 0 2
61085: ARRAY
61086: IFFALSE 61148
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
61088: LD_ADDR_VAR 0 7
61092: PUSH
61093: LD_EXP 60
61097: PUSH
61098: LD_VAR 0 2
61102: ARRAY
61103: PPUSH
61104: LD_INT 3
61106: PUSH
61107: LD_INT 30
61109: PUSH
61110: LD_INT 32
61112: PUSH
61113: EMPTY
61114: LIST
61115: LIST
61116: PUSH
61117: LD_INT 30
61119: PUSH
61120: LD_INT 33
61122: PUSH
61123: EMPTY
61124: LIST
61125: LIST
61126: PUSH
61127: LD_INT 30
61129: PUSH
61130: LD_INT 31
61132: PUSH
61133: EMPTY
61134: LIST
61135: LIST
61136: PUSH
61137: EMPTY
61138: LIST
61139: LIST
61140: LIST
61141: LIST
61142: PPUSH
61143: CALL_OW 72
61147: ST_TO_ADDR
// if not to_repair_tmp then
61148: LD_VAR 0 7
61152: NOT
61153: IFFALSE 61157
// continue ;
61155: GO 60955
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61157: LD_ADDR_VAR 0 8
61161: PUSH
61162: LD_VAR 0 7
61166: PPUSH
61167: LD_VAR 0 3
61171: PPUSH
61172: CALL_OW 74
61176: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
61177: LD_VAR 0 8
61181: PPUSH
61182: LD_INT 16
61184: PPUSH
61185: CALL 21856 0 2
61189: PUSH
61190: LD_INT 4
61192: ARRAY
61193: PUSH
61194: LD_INT 10
61196: LESS
61197: IFFALSE 61213
// ComRepairBuilding ( j , to_repair ) ;
61199: LD_VAR 0 3
61203: PPUSH
61204: LD_VAR 0 8
61208: PPUSH
61209: CALL_OW 130
// end ;
61213: GO 60955
61215: POP
61216: POP
// end ;
61217: GO 60375
61219: POP
61220: POP
// end ;
61221: LD_VAR 0 1
61225: RET
// export function MC_Heal ; var i , j , tmp ; begin
61226: LD_INT 0
61228: PPUSH
61229: PPUSH
61230: PPUSH
61231: PPUSH
// if not mc_bases then
61232: LD_EXP 59
61236: NOT
61237: IFFALSE 61241
// exit ;
61239: GO 61643
// for i = 1 to mc_bases do
61241: LD_ADDR_VAR 0 2
61245: PUSH
61246: DOUBLE
61247: LD_INT 1
61249: DEC
61250: ST_TO_ADDR
61251: LD_EXP 59
61255: PUSH
61256: FOR_TO
61257: IFFALSE 61641
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61259: LD_EXP 62
61263: PUSH
61264: LD_VAR 0 2
61268: ARRAY
61269: PUSH
61270: LD_INT 1
61272: ARRAY
61273: NOT
61274: PUSH
61275: LD_EXP 62
61279: PUSH
61280: LD_VAR 0 2
61284: ARRAY
61285: PUSH
61286: LD_INT 2
61288: ARRAY
61289: NOT
61290: AND
61291: IFFALSE 61329
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61293: LD_ADDR_EXP 63
61297: PUSH
61298: LD_EXP 63
61302: PPUSH
61303: LD_VAR 0 2
61307: PPUSH
61308: EMPTY
61309: PPUSH
61310: CALL_OW 1
61314: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61315: LD_VAR 0 2
61319: PPUSH
61320: LD_INT 102
61322: PPUSH
61323: CALL 55464 0 2
// continue ;
61327: GO 61256
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61329: LD_ADDR_VAR 0 4
61333: PUSH
61334: LD_EXP 59
61338: PUSH
61339: LD_VAR 0 2
61343: ARRAY
61344: PPUSH
61345: LD_INT 25
61347: PUSH
61348: LD_INT 4
61350: PUSH
61351: EMPTY
61352: LIST
61353: LIST
61354: PPUSH
61355: CALL_OW 72
61359: ST_TO_ADDR
// if not tmp then
61360: LD_VAR 0 4
61364: NOT
61365: IFFALSE 61369
// continue ;
61367: GO 61256
// if mc_taming [ i ] then
61369: LD_EXP 90
61373: PUSH
61374: LD_VAR 0 2
61378: ARRAY
61379: IFFALSE 61403
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61381: LD_ADDR_EXP 90
61385: PUSH
61386: LD_EXP 90
61390: PPUSH
61391: LD_VAR 0 2
61395: PPUSH
61396: EMPTY
61397: PPUSH
61398: CALL_OW 1
61402: ST_TO_ADDR
// for j in tmp do
61403: LD_ADDR_VAR 0 3
61407: PUSH
61408: LD_VAR 0 4
61412: PUSH
61413: FOR_IN
61414: IFFALSE 61637
// begin if IsInUnit ( j ) then
61416: LD_VAR 0 3
61420: PPUSH
61421: CALL_OW 310
61425: IFFALSE 61436
// ComExitBuilding ( j ) ;
61427: LD_VAR 0 3
61431: PPUSH
61432: CALL_OW 122
// if not j in mc_healers [ i ] then
61436: LD_VAR 0 3
61440: PUSH
61441: LD_EXP 63
61445: PUSH
61446: LD_VAR 0 2
61450: ARRAY
61451: IN
61452: NOT
61453: IFFALSE 61499
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61455: LD_ADDR_EXP 63
61459: PUSH
61460: LD_EXP 63
61464: PPUSH
61465: LD_VAR 0 2
61469: PUSH
61470: LD_EXP 63
61474: PUSH
61475: LD_VAR 0 2
61479: ARRAY
61480: PUSH
61481: LD_INT 1
61483: PLUS
61484: PUSH
61485: EMPTY
61486: LIST
61487: LIST
61488: PPUSH
61489: LD_VAR 0 3
61493: PPUSH
61494: CALL 19263 0 3
61498: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61499: LD_VAR 0 3
61503: PPUSH
61504: CALL_OW 110
61508: PUSH
61509: LD_INT 102
61511: NONEQUAL
61512: IFFALSE 61526
// SetTag ( j , 102 ) ;
61514: LD_VAR 0 3
61518: PPUSH
61519: LD_INT 102
61521: PPUSH
61522: CALL_OW 109
// Wait ( 3 ) ;
61526: LD_INT 3
61528: PPUSH
61529: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61533: LD_EXP 62
61537: PUSH
61538: LD_VAR 0 2
61542: ARRAY
61543: PUSH
61544: LD_INT 1
61546: ARRAY
61547: IFFALSE 61579
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61549: LD_VAR 0 3
61553: PPUSH
61554: LD_EXP 62
61558: PUSH
61559: LD_VAR 0 2
61563: ARRAY
61564: PUSH
61565: LD_INT 1
61567: ARRAY
61568: PUSH
61569: LD_INT 1
61571: ARRAY
61572: PPUSH
61573: CALL_OW 128
61577: GO 61635
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61579: LD_VAR 0 3
61583: PPUSH
61584: CALL_OW 314
61588: NOT
61589: PUSH
61590: LD_EXP 62
61594: PUSH
61595: LD_VAR 0 2
61599: ARRAY
61600: PUSH
61601: LD_INT 2
61603: ARRAY
61604: AND
61605: IFFALSE 61635
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61607: LD_VAR 0 3
61611: PPUSH
61612: LD_EXP 62
61616: PUSH
61617: LD_VAR 0 2
61621: ARRAY
61622: PUSH
61623: LD_INT 2
61625: ARRAY
61626: PUSH
61627: LD_INT 1
61629: ARRAY
61630: PPUSH
61631: CALL_OW 128
// end ;
61635: GO 61413
61637: POP
61638: POP
// end ;
61639: GO 61256
61641: POP
61642: POP
// end ;
61643: LD_VAR 0 1
61647: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
61648: LD_INT 0
61650: PPUSH
61651: PPUSH
61652: PPUSH
61653: PPUSH
61654: PPUSH
// if not mc_bases then
61655: LD_EXP 59
61659: NOT
61660: IFFALSE 61664
// exit ;
61662: GO 62807
// for i = 1 to mc_bases do
61664: LD_ADDR_VAR 0 2
61668: PUSH
61669: DOUBLE
61670: LD_INT 1
61672: DEC
61673: ST_TO_ADDR
61674: LD_EXP 59
61678: PUSH
61679: FOR_TO
61680: IFFALSE 62805
// begin if mc_scan [ i ] then
61682: LD_EXP 82
61686: PUSH
61687: LD_VAR 0 2
61691: ARRAY
61692: IFFALSE 61696
// continue ;
61694: GO 61679
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61696: LD_EXP 64
61700: PUSH
61701: LD_VAR 0 2
61705: ARRAY
61706: NOT
61707: PUSH
61708: LD_EXP 66
61712: PUSH
61713: LD_VAR 0 2
61717: ARRAY
61718: NOT
61719: AND
61720: PUSH
61721: LD_EXP 65
61725: PUSH
61726: LD_VAR 0 2
61730: ARRAY
61731: AND
61732: IFFALSE 61770
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61734: LD_ADDR_EXP 65
61738: PUSH
61739: LD_EXP 65
61743: PPUSH
61744: LD_VAR 0 2
61748: PPUSH
61749: EMPTY
61750: PPUSH
61751: CALL_OW 1
61755: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61756: LD_VAR 0 2
61760: PPUSH
61761: LD_INT 103
61763: PPUSH
61764: CALL 55464 0 2
// continue ;
61768: GO 61679
// end ; if mc_construct_list [ i ] then
61770: LD_EXP 66
61774: PUSH
61775: LD_VAR 0 2
61779: ARRAY
61780: IFFALSE 62000
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61782: LD_ADDR_VAR 0 4
61786: PUSH
61787: LD_EXP 59
61791: PUSH
61792: LD_VAR 0 2
61796: ARRAY
61797: PPUSH
61798: LD_INT 25
61800: PUSH
61801: LD_INT 2
61803: PUSH
61804: EMPTY
61805: LIST
61806: LIST
61807: PPUSH
61808: CALL_OW 72
61812: PUSH
61813: LD_EXP 61
61817: PUSH
61818: LD_VAR 0 2
61822: ARRAY
61823: DIFF
61824: ST_TO_ADDR
// if not tmp then
61825: LD_VAR 0 4
61829: NOT
61830: IFFALSE 61834
// continue ;
61832: GO 61679
// for j in tmp do
61834: LD_ADDR_VAR 0 3
61838: PUSH
61839: LD_VAR 0 4
61843: PUSH
61844: FOR_IN
61845: IFFALSE 61996
// begin if not mc_builders [ i ] then
61847: LD_EXP 65
61851: PUSH
61852: LD_VAR 0 2
61856: ARRAY
61857: NOT
61858: IFFALSE 61916
// begin SetTag ( j , 103 ) ;
61860: LD_VAR 0 3
61864: PPUSH
61865: LD_INT 103
61867: PPUSH
61868: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61872: LD_ADDR_EXP 65
61876: PUSH
61877: LD_EXP 65
61881: PPUSH
61882: LD_VAR 0 2
61886: PUSH
61887: LD_EXP 65
61891: PUSH
61892: LD_VAR 0 2
61896: ARRAY
61897: PUSH
61898: LD_INT 1
61900: PLUS
61901: PUSH
61902: EMPTY
61903: LIST
61904: LIST
61905: PPUSH
61906: LD_VAR 0 3
61910: PPUSH
61911: CALL 19263 0 3
61915: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61916: LD_VAR 0 3
61920: PPUSH
61921: CALL_OW 310
61925: IFFALSE 61936
// ComExitBuilding ( j ) ;
61927: LD_VAR 0 3
61931: PPUSH
61932: CALL_OW 122
// wait ( 3 ) ;
61936: LD_INT 3
61938: PPUSH
61939: CALL_OW 67
// if not mc_construct_list [ i ] then
61943: LD_EXP 66
61947: PUSH
61948: LD_VAR 0 2
61952: ARRAY
61953: NOT
61954: IFFALSE 61958
// break ;
61956: GO 61996
// if not HasTask ( j ) then
61958: LD_VAR 0 3
61962: PPUSH
61963: CALL_OW 314
61967: NOT
61968: IFFALSE 61994
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61970: LD_VAR 0 3
61974: PPUSH
61975: LD_EXP 66
61979: PUSH
61980: LD_VAR 0 2
61984: ARRAY
61985: PUSH
61986: LD_INT 1
61988: ARRAY
61989: PPUSH
61990: CALL 22114 0 2
// end ;
61994: GO 61844
61996: POP
61997: POP
// end else
61998: GO 62803
// if mc_build_list [ i ] then
62000: LD_EXP 64
62004: PUSH
62005: LD_VAR 0 2
62009: ARRAY
62010: IFFALSE 62803
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62012: LD_ADDR_VAR 0 5
62016: PUSH
62017: LD_EXP 59
62021: PUSH
62022: LD_VAR 0 2
62026: ARRAY
62027: PPUSH
62028: LD_INT 2
62030: PUSH
62031: LD_INT 30
62033: PUSH
62034: LD_INT 0
62036: PUSH
62037: EMPTY
62038: LIST
62039: LIST
62040: PUSH
62041: LD_INT 30
62043: PUSH
62044: LD_INT 1
62046: PUSH
62047: EMPTY
62048: LIST
62049: LIST
62050: PUSH
62051: EMPTY
62052: LIST
62053: LIST
62054: LIST
62055: PPUSH
62056: CALL_OW 72
62060: ST_TO_ADDR
// if depot then
62061: LD_VAR 0 5
62065: IFFALSE 62083
// depot := depot [ 1 ] else
62067: LD_ADDR_VAR 0 5
62071: PUSH
62072: LD_VAR 0 5
62076: PUSH
62077: LD_INT 1
62079: ARRAY
62080: ST_TO_ADDR
62081: GO 62091
// depot := 0 ;
62083: LD_ADDR_VAR 0 5
62087: PUSH
62088: LD_INT 0
62090: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
62091: LD_EXP 64
62095: PUSH
62096: LD_VAR 0 2
62100: ARRAY
62101: PUSH
62102: LD_INT 1
62104: ARRAY
62105: PUSH
62106: LD_INT 1
62108: ARRAY
62109: PPUSH
62110: CALL 21944 0 1
62114: PUSH
62115: LD_EXP 59
62119: PUSH
62120: LD_VAR 0 2
62124: ARRAY
62125: PPUSH
62126: LD_INT 2
62128: PUSH
62129: LD_INT 30
62131: PUSH
62132: LD_INT 2
62134: PUSH
62135: EMPTY
62136: LIST
62137: LIST
62138: PUSH
62139: LD_INT 30
62141: PUSH
62142: LD_INT 3
62144: PUSH
62145: EMPTY
62146: LIST
62147: LIST
62148: PUSH
62149: EMPTY
62150: LIST
62151: LIST
62152: LIST
62153: PPUSH
62154: CALL_OW 72
62158: NOT
62159: AND
62160: IFFALSE 62265
// begin for j = 1 to mc_build_list [ i ] do
62162: LD_ADDR_VAR 0 3
62166: PUSH
62167: DOUBLE
62168: LD_INT 1
62170: DEC
62171: ST_TO_ADDR
62172: LD_EXP 64
62176: PUSH
62177: LD_VAR 0 2
62181: ARRAY
62182: PUSH
62183: FOR_TO
62184: IFFALSE 62263
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62186: LD_EXP 64
62190: PUSH
62191: LD_VAR 0 2
62195: ARRAY
62196: PUSH
62197: LD_VAR 0 3
62201: ARRAY
62202: PUSH
62203: LD_INT 1
62205: ARRAY
62206: PUSH
62207: LD_INT 2
62209: EQUAL
62210: IFFALSE 62261
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62212: LD_ADDR_EXP 64
62216: PUSH
62217: LD_EXP 64
62221: PPUSH
62222: LD_VAR 0 2
62226: PPUSH
62227: LD_EXP 64
62231: PUSH
62232: LD_VAR 0 2
62236: ARRAY
62237: PPUSH
62238: LD_VAR 0 3
62242: PPUSH
62243: LD_INT 1
62245: PPUSH
62246: LD_INT 0
62248: PPUSH
62249: CALL 18681 0 4
62253: PPUSH
62254: CALL_OW 1
62258: ST_TO_ADDR
// break ;
62259: GO 62263
// end ;
62261: GO 62183
62263: POP
62264: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
62265: LD_EXP 64
62269: PUSH
62270: LD_VAR 0 2
62274: ARRAY
62275: PUSH
62276: LD_INT 1
62278: ARRAY
62279: PUSH
62280: LD_INT 1
62282: ARRAY
62283: PUSH
62284: LD_INT 0
62286: EQUAL
62287: PUSH
62288: LD_VAR 0 5
62292: PUSH
62293: LD_VAR 0 5
62297: PPUSH
62298: LD_EXP 64
62302: PUSH
62303: LD_VAR 0 2
62307: ARRAY
62308: PUSH
62309: LD_INT 1
62311: ARRAY
62312: PUSH
62313: LD_INT 1
62315: ARRAY
62316: PPUSH
62317: LD_EXP 64
62321: PUSH
62322: LD_VAR 0 2
62326: ARRAY
62327: PUSH
62328: LD_INT 1
62330: ARRAY
62331: PUSH
62332: LD_INT 2
62334: ARRAY
62335: PPUSH
62336: LD_EXP 64
62340: PUSH
62341: LD_VAR 0 2
62345: ARRAY
62346: PUSH
62347: LD_INT 1
62349: ARRAY
62350: PUSH
62351: LD_INT 3
62353: ARRAY
62354: PPUSH
62355: LD_EXP 64
62359: PUSH
62360: LD_VAR 0 2
62364: ARRAY
62365: PUSH
62366: LD_INT 1
62368: ARRAY
62369: PUSH
62370: LD_INT 4
62372: ARRAY
62373: PPUSH
62374: CALL 26678 0 5
62378: AND
62379: OR
62380: IFFALSE 62661
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62382: LD_ADDR_VAR 0 4
62386: PUSH
62387: LD_EXP 59
62391: PUSH
62392: LD_VAR 0 2
62396: ARRAY
62397: PPUSH
62398: LD_INT 25
62400: PUSH
62401: LD_INT 2
62403: PUSH
62404: EMPTY
62405: LIST
62406: LIST
62407: PPUSH
62408: CALL_OW 72
62412: PUSH
62413: LD_EXP 61
62417: PUSH
62418: LD_VAR 0 2
62422: ARRAY
62423: DIFF
62424: ST_TO_ADDR
// if not tmp then
62425: LD_VAR 0 4
62429: NOT
62430: IFFALSE 62434
// continue ;
62432: GO 61679
// for j in tmp do
62434: LD_ADDR_VAR 0 3
62438: PUSH
62439: LD_VAR 0 4
62443: PUSH
62444: FOR_IN
62445: IFFALSE 62657
// begin if not mc_builders [ i ] then
62447: LD_EXP 65
62451: PUSH
62452: LD_VAR 0 2
62456: ARRAY
62457: NOT
62458: IFFALSE 62516
// begin SetTag ( j , 103 ) ;
62460: LD_VAR 0 3
62464: PPUSH
62465: LD_INT 103
62467: PPUSH
62468: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62472: LD_ADDR_EXP 65
62476: PUSH
62477: LD_EXP 65
62481: PPUSH
62482: LD_VAR 0 2
62486: PUSH
62487: LD_EXP 65
62491: PUSH
62492: LD_VAR 0 2
62496: ARRAY
62497: PUSH
62498: LD_INT 1
62500: PLUS
62501: PUSH
62502: EMPTY
62503: LIST
62504: LIST
62505: PPUSH
62506: LD_VAR 0 3
62510: PPUSH
62511: CALL 19263 0 3
62515: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62516: LD_VAR 0 3
62520: PPUSH
62521: CALL_OW 310
62525: IFFALSE 62536
// ComExitBuilding ( j ) ;
62527: LD_VAR 0 3
62531: PPUSH
62532: CALL_OW 122
// wait ( 3 ) ;
62536: LD_INT 3
62538: PPUSH
62539: CALL_OW 67
// if not mc_build_list [ i ] then
62543: LD_EXP 64
62547: PUSH
62548: LD_VAR 0 2
62552: ARRAY
62553: NOT
62554: IFFALSE 62558
// break ;
62556: GO 62657
// if not HasTask ( j ) then
62558: LD_VAR 0 3
62562: PPUSH
62563: CALL_OW 314
62567: NOT
62568: IFFALSE 62655
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62570: LD_VAR 0 3
62574: PPUSH
62575: LD_EXP 64
62579: PUSH
62580: LD_VAR 0 2
62584: ARRAY
62585: PUSH
62586: LD_INT 1
62588: ARRAY
62589: PUSH
62590: LD_INT 1
62592: ARRAY
62593: PPUSH
62594: LD_EXP 64
62598: PUSH
62599: LD_VAR 0 2
62603: ARRAY
62604: PUSH
62605: LD_INT 1
62607: ARRAY
62608: PUSH
62609: LD_INT 2
62611: ARRAY
62612: PPUSH
62613: LD_EXP 64
62617: PUSH
62618: LD_VAR 0 2
62622: ARRAY
62623: PUSH
62624: LD_INT 1
62626: ARRAY
62627: PUSH
62628: LD_INT 3
62630: ARRAY
62631: PPUSH
62632: LD_EXP 64
62636: PUSH
62637: LD_VAR 0 2
62641: ARRAY
62642: PUSH
62643: LD_INT 1
62645: ARRAY
62646: PUSH
62647: LD_INT 4
62649: ARRAY
62650: PPUSH
62651: CALL_OW 145
// end ;
62655: GO 62444
62657: POP
62658: POP
// end else
62659: GO 62803
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
62661: LD_EXP 59
62665: PUSH
62666: LD_VAR 0 2
62670: ARRAY
62671: PPUSH
62672: LD_EXP 64
62676: PUSH
62677: LD_VAR 0 2
62681: ARRAY
62682: PUSH
62683: LD_INT 1
62685: ARRAY
62686: PUSH
62687: LD_INT 1
62689: ARRAY
62690: PPUSH
62691: LD_EXP 64
62695: PUSH
62696: LD_VAR 0 2
62700: ARRAY
62701: PUSH
62702: LD_INT 1
62704: ARRAY
62705: PUSH
62706: LD_INT 2
62708: ARRAY
62709: PPUSH
62710: LD_EXP 64
62714: PUSH
62715: LD_VAR 0 2
62719: ARRAY
62720: PUSH
62721: LD_INT 1
62723: ARRAY
62724: PUSH
62725: LD_INT 3
62727: ARRAY
62728: PPUSH
62729: LD_EXP 64
62733: PUSH
62734: LD_VAR 0 2
62738: ARRAY
62739: PUSH
62740: LD_INT 1
62742: ARRAY
62743: PUSH
62744: LD_INT 4
62746: ARRAY
62747: PPUSH
62748: CALL 26014 0 5
62752: NOT
62753: IFFALSE 62803
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62755: LD_ADDR_EXP 64
62759: PUSH
62760: LD_EXP 64
62764: PPUSH
62765: LD_VAR 0 2
62769: PPUSH
62770: LD_EXP 64
62774: PUSH
62775: LD_VAR 0 2
62779: ARRAY
62780: PPUSH
62781: LD_INT 1
62783: PPUSH
62784: LD_INT 1
62786: NEG
62787: PPUSH
62788: LD_INT 0
62790: PPUSH
62791: CALL 18681 0 4
62795: PPUSH
62796: CALL_OW 1
62800: ST_TO_ADDR
// continue ;
62801: GO 61679
// end ; end ; end ;
62803: GO 61679
62805: POP
62806: POP
// end ;
62807: LD_VAR 0 1
62811: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62812: LD_INT 0
62814: PPUSH
62815: PPUSH
62816: PPUSH
62817: PPUSH
62818: PPUSH
62819: PPUSH
// if not mc_bases then
62820: LD_EXP 59
62824: NOT
62825: IFFALSE 62829
// exit ;
62827: GO 63256
// for i = 1 to mc_bases do
62829: LD_ADDR_VAR 0 2
62833: PUSH
62834: DOUBLE
62835: LD_INT 1
62837: DEC
62838: ST_TO_ADDR
62839: LD_EXP 59
62843: PUSH
62844: FOR_TO
62845: IFFALSE 63254
// begin tmp := mc_build_upgrade [ i ] ;
62847: LD_ADDR_VAR 0 4
62851: PUSH
62852: LD_EXP 91
62856: PUSH
62857: LD_VAR 0 2
62861: ARRAY
62862: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62863: LD_ADDR_VAR 0 6
62867: PUSH
62868: LD_EXP 92
62872: PUSH
62873: LD_VAR 0 2
62877: ARRAY
62878: PPUSH
62879: LD_INT 2
62881: PUSH
62882: LD_INT 30
62884: PUSH
62885: LD_INT 6
62887: PUSH
62888: EMPTY
62889: LIST
62890: LIST
62891: PUSH
62892: LD_INT 30
62894: PUSH
62895: LD_INT 7
62897: PUSH
62898: EMPTY
62899: LIST
62900: LIST
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: LIST
62906: PPUSH
62907: CALL_OW 72
62911: ST_TO_ADDR
// if not tmp and not lab then
62912: LD_VAR 0 4
62916: NOT
62917: PUSH
62918: LD_VAR 0 6
62922: NOT
62923: AND
62924: IFFALSE 62928
// continue ;
62926: GO 62844
// if tmp then
62928: LD_VAR 0 4
62932: IFFALSE 63052
// for j in tmp do
62934: LD_ADDR_VAR 0 3
62938: PUSH
62939: LD_VAR 0 4
62943: PUSH
62944: FOR_IN
62945: IFFALSE 63050
// begin if UpgradeCost ( j ) then
62947: LD_VAR 0 3
62951: PPUSH
62952: CALL 25674 0 1
62956: IFFALSE 63048
// begin ComUpgrade ( j ) ;
62958: LD_VAR 0 3
62962: PPUSH
62963: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62967: LD_ADDR_EXP 91
62971: PUSH
62972: LD_EXP 91
62976: PPUSH
62977: LD_VAR 0 2
62981: PPUSH
62982: LD_EXP 91
62986: PUSH
62987: LD_VAR 0 2
62991: ARRAY
62992: PUSH
62993: LD_VAR 0 3
62997: DIFF
62998: PPUSH
62999: CALL_OW 1
63003: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63004: LD_ADDR_EXP 66
63008: PUSH
63009: LD_EXP 66
63013: PPUSH
63014: LD_VAR 0 2
63018: PUSH
63019: LD_EXP 66
63023: PUSH
63024: LD_VAR 0 2
63028: ARRAY
63029: PUSH
63030: LD_INT 1
63032: PLUS
63033: PUSH
63034: EMPTY
63035: LIST
63036: LIST
63037: PPUSH
63038: LD_VAR 0 3
63042: PPUSH
63043: CALL 19263 0 3
63047: ST_TO_ADDR
// end ; end ;
63048: GO 62944
63050: POP
63051: POP
// if not lab or not mc_lab_upgrade [ i ] then
63052: LD_VAR 0 6
63056: NOT
63057: PUSH
63058: LD_EXP 93
63062: PUSH
63063: LD_VAR 0 2
63067: ARRAY
63068: NOT
63069: OR
63070: IFFALSE 63074
// continue ;
63072: GO 62844
// for j in lab do
63074: LD_ADDR_VAR 0 3
63078: PUSH
63079: LD_VAR 0 6
63083: PUSH
63084: FOR_IN
63085: IFFALSE 63250
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
63087: LD_VAR 0 3
63091: PPUSH
63092: CALL_OW 266
63096: PUSH
63097: LD_INT 6
63099: PUSH
63100: LD_INT 7
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: IN
63107: PUSH
63108: LD_VAR 0 3
63112: PPUSH
63113: CALL_OW 461
63117: PUSH
63118: LD_INT 1
63120: NONEQUAL
63121: AND
63122: IFFALSE 63248
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
63124: LD_VAR 0 3
63128: PPUSH
63129: LD_EXP 93
63133: PUSH
63134: LD_VAR 0 2
63138: ARRAY
63139: PUSH
63140: LD_INT 1
63142: ARRAY
63143: PPUSH
63144: CALL 25879 0 2
63148: IFFALSE 63248
// begin ComCancel ( j ) ;
63150: LD_VAR 0 3
63154: PPUSH
63155: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63159: LD_VAR 0 3
63163: PPUSH
63164: LD_EXP 93
63168: PUSH
63169: LD_VAR 0 2
63173: ARRAY
63174: PUSH
63175: LD_INT 1
63177: ARRAY
63178: PPUSH
63179: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63183: LD_VAR 0 3
63187: PUSH
63188: LD_EXP 66
63192: PUSH
63193: LD_VAR 0 2
63197: ARRAY
63198: IN
63199: NOT
63200: IFFALSE 63246
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63202: LD_ADDR_EXP 66
63206: PUSH
63207: LD_EXP 66
63211: PPUSH
63212: LD_VAR 0 2
63216: PUSH
63217: LD_EXP 66
63221: PUSH
63222: LD_VAR 0 2
63226: ARRAY
63227: PUSH
63228: LD_INT 1
63230: PLUS
63231: PUSH
63232: EMPTY
63233: LIST
63234: LIST
63235: PPUSH
63236: LD_VAR 0 3
63240: PPUSH
63241: CALL 19263 0 3
63245: ST_TO_ADDR
// break ;
63246: GO 63250
// end ; end ; end ;
63248: GO 63084
63250: POP
63251: POP
// end ;
63252: GO 62844
63254: POP
63255: POP
// end ;
63256: LD_VAR 0 1
63260: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63261: LD_INT 0
63263: PPUSH
63264: PPUSH
63265: PPUSH
63266: PPUSH
63267: PPUSH
63268: PPUSH
63269: PPUSH
63270: PPUSH
63271: PPUSH
// if not mc_bases then
63272: LD_EXP 59
63276: NOT
63277: IFFALSE 63281
// exit ;
63279: GO 63686
// for i = 1 to mc_bases do
63281: LD_ADDR_VAR 0 2
63285: PUSH
63286: DOUBLE
63287: LD_INT 1
63289: DEC
63290: ST_TO_ADDR
63291: LD_EXP 59
63295: PUSH
63296: FOR_TO
63297: IFFALSE 63684
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63299: LD_EXP 67
63303: PUSH
63304: LD_VAR 0 2
63308: ARRAY
63309: NOT
63310: PUSH
63311: LD_EXP 59
63315: PUSH
63316: LD_VAR 0 2
63320: ARRAY
63321: PPUSH
63322: LD_INT 30
63324: PUSH
63325: LD_INT 3
63327: PUSH
63328: EMPTY
63329: LIST
63330: LIST
63331: PPUSH
63332: CALL_OW 72
63336: NOT
63337: OR
63338: IFFALSE 63342
// continue ;
63340: GO 63296
// busy := false ;
63342: LD_ADDR_VAR 0 8
63346: PUSH
63347: LD_INT 0
63349: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63350: LD_ADDR_VAR 0 4
63354: PUSH
63355: LD_EXP 59
63359: PUSH
63360: LD_VAR 0 2
63364: ARRAY
63365: PPUSH
63366: LD_INT 30
63368: PUSH
63369: LD_INT 3
63371: PUSH
63372: EMPTY
63373: LIST
63374: LIST
63375: PPUSH
63376: CALL_OW 72
63380: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63381: LD_ADDR_VAR 0 6
63385: PUSH
63386: LD_EXP 67
63390: PUSH
63391: LD_VAR 0 2
63395: ARRAY
63396: PPUSH
63397: LD_INT 2
63399: PUSH
63400: LD_INT 30
63402: PUSH
63403: LD_INT 32
63405: PUSH
63406: EMPTY
63407: LIST
63408: LIST
63409: PUSH
63410: LD_INT 30
63412: PUSH
63413: LD_INT 33
63415: PUSH
63416: EMPTY
63417: LIST
63418: LIST
63419: PUSH
63420: EMPTY
63421: LIST
63422: LIST
63423: LIST
63424: PPUSH
63425: CALL_OW 72
63429: ST_TO_ADDR
// if not t then
63430: LD_VAR 0 6
63434: NOT
63435: IFFALSE 63439
// continue ;
63437: GO 63296
// for j in tmp do
63439: LD_ADDR_VAR 0 3
63443: PUSH
63444: LD_VAR 0 4
63448: PUSH
63449: FOR_IN
63450: IFFALSE 63480
// if not BuildingStatus ( j ) = bs_idle then
63452: LD_VAR 0 3
63456: PPUSH
63457: CALL_OW 461
63461: PUSH
63462: LD_INT 2
63464: EQUAL
63465: NOT
63466: IFFALSE 63478
// begin busy := true ;
63468: LD_ADDR_VAR 0 8
63472: PUSH
63473: LD_INT 1
63475: ST_TO_ADDR
// break ;
63476: GO 63480
// end ;
63478: GO 63449
63480: POP
63481: POP
// if busy then
63482: LD_VAR 0 8
63486: IFFALSE 63490
// continue ;
63488: GO 63296
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63490: LD_ADDR_VAR 0 7
63494: PUSH
63495: LD_VAR 0 6
63499: PPUSH
63500: LD_INT 35
63502: PUSH
63503: LD_INT 0
63505: PUSH
63506: EMPTY
63507: LIST
63508: LIST
63509: PPUSH
63510: CALL_OW 72
63514: ST_TO_ADDR
// if tw then
63515: LD_VAR 0 7
63519: IFFALSE 63596
// begin tw := tw [ 1 ] ;
63521: LD_ADDR_VAR 0 7
63525: PUSH
63526: LD_VAR 0 7
63530: PUSH
63531: LD_INT 1
63533: ARRAY
63534: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63535: LD_ADDR_VAR 0 9
63539: PUSH
63540: LD_VAR 0 7
63544: PPUSH
63545: LD_EXP 84
63549: PUSH
63550: LD_VAR 0 2
63554: ARRAY
63555: PPUSH
63556: CALL 24233 0 2
63560: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63561: LD_EXP 98
63565: PUSH
63566: LD_VAR 0 2
63570: ARRAY
63571: IFFALSE 63594
// if not weapon in mc_allowed_tower_weapons [ i ] then
63573: LD_VAR 0 9
63577: PUSH
63578: LD_EXP 98
63582: PUSH
63583: LD_VAR 0 2
63587: ARRAY
63588: IN
63589: NOT
63590: IFFALSE 63594
// continue ;
63592: GO 63296
// end else
63594: GO 63659
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63596: LD_ADDR_VAR 0 5
63600: PUSH
63601: LD_EXP 67
63605: PUSH
63606: LD_VAR 0 2
63610: ARRAY
63611: PPUSH
63612: LD_VAR 0 4
63616: PPUSH
63617: CALL 49854 0 2
63621: ST_TO_ADDR
// if not tmp2 then
63622: LD_VAR 0 5
63626: NOT
63627: IFFALSE 63631
// continue ;
63629: GO 63296
// tw := tmp2 [ 1 ] ;
63631: LD_ADDR_VAR 0 7
63635: PUSH
63636: LD_VAR 0 5
63640: PUSH
63641: LD_INT 1
63643: ARRAY
63644: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63645: LD_ADDR_VAR 0 9
63649: PUSH
63650: LD_VAR 0 5
63654: PUSH
63655: LD_INT 2
63657: ARRAY
63658: ST_TO_ADDR
// end ; if not weapon then
63659: LD_VAR 0 9
63663: NOT
63664: IFFALSE 63668
// continue ;
63666: GO 63296
// ComPlaceWeapon ( tw , weapon ) ;
63668: LD_VAR 0 7
63672: PPUSH
63673: LD_VAR 0 9
63677: PPUSH
63678: CALL_OW 148
// end ;
63682: GO 63296
63684: POP
63685: POP
// end ;
63686: LD_VAR 0 1
63690: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
63691: LD_INT 0
63693: PPUSH
63694: PPUSH
63695: PPUSH
63696: PPUSH
63697: PPUSH
63698: PPUSH
// if not mc_bases then
63699: LD_EXP 59
63703: NOT
63704: IFFALSE 63708
// exit ;
63706: GO 64484
// for i = 1 to mc_bases do
63708: LD_ADDR_VAR 0 2
63712: PUSH
63713: DOUBLE
63714: LD_INT 1
63716: DEC
63717: ST_TO_ADDR
63718: LD_EXP 59
63722: PUSH
63723: FOR_TO
63724: IFFALSE 64482
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63726: LD_EXP 72
63730: PUSH
63731: LD_VAR 0 2
63735: ARRAY
63736: NOT
63737: PUSH
63738: LD_EXP 72
63742: PUSH
63743: LD_VAR 0 2
63747: ARRAY
63748: PUSH
63749: LD_EXP 73
63753: PUSH
63754: LD_VAR 0 2
63758: ARRAY
63759: EQUAL
63760: OR
63761: PUSH
63762: LD_EXP 82
63766: PUSH
63767: LD_VAR 0 2
63771: ARRAY
63772: OR
63773: IFFALSE 63777
// continue ;
63775: GO 63723
// if mc_miners [ i ] then
63777: LD_EXP 73
63781: PUSH
63782: LD_VAR 0 2
63786: ARRAY
63787: IFFALSE 64169
// begin for j = mc_miners [ i ] downto 1 do
63789: LD_ADDR_VAR 0 3
63793: PUSH
63794: DOUBLE
63795: LD_EXP 73
63799: PUSH
63800: LD_VAR 0 2
63804: ARRAY
63805: INC
63806: ST_TO_ADDR
63807: LD_INT 1
63809: PUSH
63810: FOR_DOWNTO
63811: IFFALSE 64167
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63813: LD_EXP 73
63817: PUSH
63818: LD_VAR 0 2
63822: ARRAY
63823: PUSH
63824: LD_VAR 0 3
63828: ARRAY
63829: PPUSH
63830: CALL_OW 301
63834: PUSH
63835: LD_EXP 73
63839: PUSH
63840: LD_VAR 0 2
63844: ARRAY
63845: PUSH
63846: LD_VAR 0 3
63850: ARRAY
63851: PPUSH
63852: CALL_OW 257
63856: PUSH
63857: LD_INT 1
63859: NONEQUAL
63860: OR
63861: IFFALSE 63924
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63863: LD_ADDR_VAR 0 5
63867: PUSH
63868: LD_EXP 73
63872: PUSH
63873: LD_VAR 0 2
63877: ARRAY
63878: PUSH
63879: LD_EXP 73
63883: PUSH
63884: LD_VAR 0 2
63888: ARRAY
63889: PUSH
63890: LD_VAR 0 3
63894: ARRAY
63895: DIFF
63896: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63897: LD_ADDR_EXP 73
63901: PUSH
63902: LD_EXP 73
63906: PPUSH
63907: LD_VAR 0 2
63911: PPUSH
63912: LD_VAR 0 5
63916: PPUSH
63917: CALL_OW 1
63921: ST_TO_ADDR
// continue ;
63922: GO 63810
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63924: LD_EXP 73
63928: PUSH
63929: LD_VAR 0 2
63933: ARRAY
63934: PUSH
63935: LD_VAR 0 3
63939: ARRAY
63940: PPUSH
63941: CALL_OW 257
63945: PUSH
63946: LD_INT 1
63948: EQUAL
63949: PUSH
63950: LD_EXP 73
63954: PUSH
63955: LD_VAR 0 2
63959: ARRAY
63960: PUSH
63961: LD_VAR 0 3
63965: ARRAY
63966: PPUSH
63967: CALL_OW 459
63971: NOT
63972: AND
63973: PUSH
63974: LD_EXP 73
63978: PUSH
63979: LD_VAR 0 2
63983: ARRAY
63984: PUSH
63985: LD_VAR 0 3
63989: ARRAY
63990: PPUSH
63991: CALL_OW 314
63995: NOT
63996: AND
63997: IFFALSE 64165
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63999: LD_EXP 73
64003: PUSH
64004: LD_VAR 0 2
64008: ARRAY
64009: PUSH
64010: LD_VAR 0 3
64014: ARRAY
64015: PPUSH
64016: CALL_OW 310
64020: IFFALSE 64043
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64022: LD_EXP 73
64026: PUSH
64027: LD_VAR 0 2
64031: ARRAY
64032: PUSH
64033: LD_VAR 0 3
64037: ARRAY
64038: PPUSH
64039: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
64043: LD_EXP 73
64047: PUSH
64048: LD_VAR 0 2
64052: ARRAY
64053: PUSH
64054: LD_VAR 0 3
64058: ARRAY
64059: PPUSH
64060: CALL_OW 314
64064: NOT
64065: IFFALSE 64165
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
64067: LD_EXP 73
64071: PUSH
64072: LD_VAR 0 2
64076: ARRAY
64077: PUSH
64078: LD_VAR 0 3
64082: ARRAY
64083: PPUSH
64084: LD_EXP 72
64088: PUSH
64089: LD_VAR 0 2
64093: ARRAY
64094: PUSH
64095: LD_VAR 0 3
64099: PUSH
64100: LD_EXP 72
64104: PUSH
64105: LD_VAR 0 2
64109: ARRAY
64110: MOD
64111: PUSH
64112: LD_INT 1
64114: PLUS
64115: ARRAY
64116: PUSH
64117: LD_INT 1
64119: ARRAY
64120: PPUSH
64121: LD_EXP 72
64125: PUSH
64126: LD_VAR 0 2
64130: ARRAY
64131: PUSH
64132: LD_VAR 0 3
64136: PUSH
64137: LD_EXP 72
64141: PUSH
64142: LD_VAR 0 2
64146: ARRAY
64147: MOD
64148: PUSH
64149: LD_INT 1
64151: PLUS
64152: ARRAY
64153: PUSH
64154: LD_INT 2
64156: ARRAY
64157: PPUSH
64158: LD_INT 0
64160: PPUSH
64161: CALL_OW 193
// end ; end ;
64165: GO 63810
64167: POP
64168: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64169: LD_ADDR_VAR 0 5
64173: PUSH
64174: LD_EXP 59
64178: PUSH
64179: LD_VAR 0 2
64183: ARRAY
64184: PPUSH
64185: LD_INT 2
64187: PUSH
64188: LD_INT 30
64190: PUSH
64191: LD_INT 4
64193: PUSH
64194: EMPTY
64195: LIST
64196: LIST
64197: PUSH
64198: LD_INT 30
64200: PUSH
64201: LD_INT 5
64203: PUSH
64204: EMPTY
64205: LIST
64206: LIST
64207: PUSH
64208: LD_INT 30
64210: PUSH
64211: LD_INT 32
64213: PUSH
64214: EMPTY
64215: LIST
64216: LIST
64217: PUSH
64218: EMPTY
64219: LIST
64220: LIST
64221: LIST
64222: LIST
64223: PPUSH
64224: CALL_OW 72
64228: ST_TO_ADDR
// if not tmp then
64229: LD_VAR 0 5
64233: NOT
64234: IFFALSE 64238
// continue ;
64236: GO 63723
// list := [ ] ;
64238: LD_ADDR_VAR 0 6
64242: PUSH
64243: EMPTY
64244: ST_TO_ADDR
// for j in tmp do
64245: LD_ADDR_VAR 0 3
64249: PUSH
64250: LD_VAR 0 5
64254: PUSH
64255: FOR_IN
64256: IFFALSE 64325
// begin for k in UnitsInside ( j ) do
64258: LD_ADDR_VAR 0 4
64262: PUSH
64263: LD_VAR 0 3
64267: PPUSH
64268: CALL_OW 313
64272: PUSH
64273: FOR_IN
64274: IFFALSE 64321
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64276: LD_VAR 0 4
64280: PPUSH
64281: CALL_OW 257
64285: PUSH
64286: LD_INT 1
64288: EQUAL
64289: PUSH
64290: LD_VAR 0 4
64294: PPUSH
64295: CALL_OW 459
64299: NOT
64300: AND
64301: IFFALSE 64319
// list := list ^ k ;
64303: LD_ADDR_VAR 0 6
64307: PUSH
64308: LD_VAR 0 6
64312: PUSH
64313: LD_VAR 0 4
64317: ADD
64318: ST_TO_ADDR
64319: GO 64273
64321: POP
64322: POP
// end ;
64323: GO 64255
64325: POP
64326: POP
// list := list diff mc_miners [ i ] ;
64327: LD_ADDR_VAR 0 6
64331: PUSH
64332: LD_VAR 0 6
64336: PUSH
64337: LD_EXP 73
64341: PUSH
64342: LD_VAR 0 2
64346: ARRAY
64347: DIFF
64348: ST_TO_ADDR
// if not list then
64349: LD_VAR 0 6
64353: NOT
64354: IFFALSE 64358
// continue ;
64356: GO 63723
// k := mc_mines [ i ] - mc_miners [ i ] ;
64358: LD_ADDR_VAR 0 4
64362: PUSH
64363: LD_EXP 72
64367: PUSH
64368: LD_VAR 0 2
64372: ARRAY
64373: PUSH
64374: LD_EXP 73
64378: PUSH
64379: LD_VAR 0 2
64383: ARRAY
64384: MINUS
64385: ST_TO_ADDR
// if k > list then
64386: LD_VAR 0 4
64390: PUSH
64391: LD_VAR 0 6
64395: GREATER
64396: IFFALSE 64408
// k := list ;
64398: LD_ADDR_VAR 0 4
64402: PUSH
64403: LD_VAR 0 6
64407: ST_TO_ADDR
// for j = 1 to k do
64408: LD_ADDR_VAR 0 3
64412: PUSH
64413: DOUBLE
64414: LD_INT 1
64416: DEC
64417: ST_TO_ADDR
64418: LD_VAR 0 4
64422: PUSH
64423: FOR_TO
64424: IFFALSE 64478
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64426: LD_ADDR_EXP 73
64430: PUSH
64431: LD_EXP 73
64435: PPUSH
64436: LD_VAR 0 2
64440: PUSH
64441: LD_EXP 73
64445: PUSH
64446: LD_VAR 0 2
64450: ARRAY
64451: PUSH
64452: LD_INT 1
64454: PLUS
64455: PUSH
64456: EMPTY
64457: LIST
64458: LIST
64459: PPUSH
64460: LD_VAR 0 6
64464: PUSH
64465: LD_VAR 0 3
64469: ARRAY
64470: PPUSH
64471: CALL 19263 0 3
64475: ST_TO_ADDR
64476: GO 64423
64478: POP
64479: POP
// end ;
64480: GO 63723
64482: POP
64483: POP
// end ;
64484: LD_VAR 0 1
64488: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
64489: LD_INT 0
64491: PPUSH
64492: PPUSH
64493: PPUSH
64494: PPUSH
64495: PPUSH
64496: PPUSH
64497: PPUSH
64498: PPUSH
64499: PPUSH
64500: PPUSH
// if not mc_bases then
64501: LD_EXP 59
64505: NOT
64506: IFFALSE 64510
// exit ;
64508: GO 66260
// for i = 1 to mc_bases do
64510: LD_ADDR_VAR 0 2
64514: PUSH
64515: DOUBLE
64516: LD_INT 1
64518: DEC
64519: ST_TO_ADDR
64520: LD_EXP 59
64524: PUSH
64525: FOR_TO
64526: IFFALSE 66258
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64528: LD_EXP 59
64532: PUSH
64533: LD_VAR 0 2
64537: ARRAY
64538: NOT
64539: PUSH
64540: LD_EXP 66
64544: PUSH
64545: LD_VAR 0 2
64549: ARRAY
64550: OR
64551: IFFALSE 64555
// continue ;
64553: GO 64525
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64555: LD_EXP 75
64559: PUSH
64560: LD_VAR 0 2
64564: ARRAY
64565: NOT
64566: PUSH
64567: LD_EXP 76
64571: PUSH
64572: LD_VAR 0 2
64576: ARRAY
64577: AND
64578: IFFALSE 64616
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64580: LD_ADDR_EXP 76
64584: PUSH
64585: LD_EXP 76
64589: PPUSH
64590: LD_VAR 0 2
64594: PPUSH
64595: EMPTY
64596: PPUSH
64597: CALL_OW 1
64601: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64602: LD_VAR 0 2
64606: PPUSH
64607: LD_INT 107
64609: PPUSH
64610: CALL 55464 0 2
// continue ;
64614: GO 64525
// end ; target := [ ] ;
64616: LD_ADDR_VAR 0 6
64620: PUSH
64621: EMPTY
64622: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64623: LD_ADDR_VAR 0 3
64627: PUSH
64628: DOUBLE
64629: LD_EXP 75
64633: PUSH
64634: LD_VAR 0 2
64638: ARRAY
64639: INC
64640: ST_TO_ADDR
64641: LD_INT 1
64643: PUSH
64644: FOR_DOWNTO
64645: IFFALSE 64905
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64647: LD_EXP 75
64651: PUSH
64652: LD_VAR 0 2
64656: ARRAY
64657: PUSH
64658: LD_VAR 0 3
64662: ARRAY
64663: PUSH
64664: LD_INT 2
64666: ARRAY
64667: PPUSH
64668: LD_EXP 75
64672: PUSH
64673: LD_VAR 0 2
64677: ARRAY
64678: PUSH
64679: LD_VAR 0 3
64683: ARRAY
64684: PUSH
64685: LD_INT 3
64687: ARRAY
64688: PPUSH
64689: CALL_OW 488
64693: PUSH
64694: LD_EXP 75
64698: PUSH
64699: LD_VAR 0 2
64703: ARRAY
64704: PUSH
64705: LD_VAR 0 3
64709: ARRAY
64710: PUSH
64711: LD_INT 2
64713: ARRAY
64714: PPUSH
64715: LD_EXP 75
64719: PUSH
64720: LD_VAR 0 2
64724: ARRAY
64725: PUSH
64726: LD_VAR 0 3
64730: ARRAY
64731: PUSH
64732: LD_INT 3
64734: ARRAY
64735: PPUSH
64736: CALL_OW 284
64740: PUSH
64741: LD_INT 0
64743: EQUAL
64744: AND
64745: IFFALSE 64800
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64747: LD_ADDR_VAR 0 5
64751: PUSH
64752: LD_EXP 75
64756: PUSH
64757: LD_VAR 0 2
64761: ARRAY
64762: PPUSH
64763: LD_VAR 0 3
64767: PPUSH
64768: CALL_OW 3
64772: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64773: LD_ADDR_EXP 75
64777: PUSH
64778: LD_EXP 75
64782: PPUSH
64783: LD_VAR 0 2
64787: PPUSH
64788: LD_VAR 0 5
64792: PPUSH
64793: CALL_OW 1
64797: ST_TO_ADDR
// continue ;
64798: GO 64644
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64800: LD_EXP 59
64804: PUSH
64805: LD_VAR 0 2
64809: ARRAY
64810: PUSH
64811: LD_INT 1
64813: ARRAY
64814: PPUSH
64815: CALL_OW 255
64819: PPUSH
64820: LD_EXP 75
64824: PUSH
64825: LD_VAR 0 2
64829: ARRAY
64830: PUSH
64831: LD_VAR 0 3
64835: ARRAY
64836: PUSH
64837: LD_INT 2
64839: ARRAY
64840: PPUSH
64841: LD_EXP 75
64845: PUSH
64846: LD_VAR 0 2
64850: ARRAY
64851: PUSH
64852: LD_VAR 0 3
64856: ARRAY
64857: PUSH
64858: LD_INT 3
64860: ARRAY
64861: PPUSH
64862: LD_INT 30
64864: PPUSH
64865: CALL 20159 0 4
64869: PUSH
64870: LD_INT 4
64872: ARRAY
64873: PUSH
64874: LD_INT 0
64876: EQUAL
64877: IFFALSE 64903
// begin target := mc_crates [ i ] [ j ] ;
64879: LD_ADDR_VAR 0 6
64883: PUSH
64884: LD_EXP 75
64888: PUSH
64889: LD_VAR 0 2
64893: ARRAY
64894: PUSH
64895: LD_VAR 0 3
64899: ARRAY
64900: ST_TO_ADDR
// break ;
64901: GO 64905
// end ; end ;
64903: GO 64644
64905: POP
64906: POP
// if not target then
64907: LD_VAR 0 6
64911: NOT
64912: IFFALSE 64916
// continue ;
64914: GO 64525
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64916: LD_ADDR_VAR 0 7
64920: PUSH
64921: LD_EXP 78
64925: PUSH
64926: LD_VAR 0 2
64930: ARRAY
64931: PPUSH
64932: LD_INT 2
64934: PUSH
64935: LD_INT 3
64937: PUSH
64938: LD_INT 58
64940: PUSH
64941: EMPTY
64942: LIST
64943: PUSH
64944: EMPTY
64945: LIST
64946: LIST
64947: PUSH
64948: LD_INT 61
64950: PUSH
64951: EMPTY
64952: LIST
64953: PUSH
64954: LD_INT 33
64956: PUSH
64957: LD_INT 5
64959: PUSH
64960: EMPTY
64961: LIST
64962: LIST
64963: PUSH
64964: LD_INT 33
64966: PUSH
64967: LD_INT 3
64969: PUSH
64970: EMPTY
64971: LIST
64972: LIST
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: LIST
64978: LIST
64979: LIST
64980: PUSH
64981: LD_INT 2
64983: PUSH
64984: LD_INT 34
64986: PUSH
64987: LD_INT 32
64989: PUSH
64990: EMPTY
64991: LIST
64992: LIST
64993: PUSH
64994: LD_INT 34
64996: PUSH
64997: LD_INT 51
64999: PUSH
65000: EMPTY
65001: LIST
65002: LIST
65003: PUSH
65004: LD_INT 34
65006: PUSH
65007: LD_INT 12
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: LIST
65018: LIST
65019: PUSH
65020: EMPTY
65021: LIST
65022: LIST
65023: PPUSH
65024: CALL_OW 72
65028: ST_TO_ADDR
// if not cargo then
65029: LD_VAR 0 7
65033: NOT
65034: IFFALSE 65677
// begin if mc_crates_collector [ i ] < 5 then
65036: LD_EXP 76
65040: PUSH
65041: LD_VAR 0 2
65045: ARRAY
65046: PUSH
65047: LD_INT 5
65049: LESS
65050: IFFALSE 65416
// begin if mc_ape [ i ] then
65052: LD_EXP 88
65056: PUSH
65057: LD_VAR 0 2
65061: ARRAY
65062: IFFALSE 65109
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
65064: LD_ADDR_VAR 0 5
65068: PUSH
65069: LD_EXP 88
65073: PUSH
65074: LD_VAR 0 2
65078: ARRAY
65079: PPUSH
65080: LD_INT 25
65082: PUSH
65083: LD_INT 16
65085: PUSH
65086: EMPTY
65087: LIST
65088: LIST
65089: PUSH
65090: LD_INT 24
65092: PUSH
65093: LD_INT 750
65095: PUSH
65096: EMPTY
65097: LIST
65098: LIST
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PPUSH
65104: CALL_OW 72
65108: ST_TO_ADDR
// if not tmp then
65109: LD_VAR 0 5
65113: NOT
65114: IFFALSE 65161
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65116: LD_ADDR_VAR 0 5
65120: PUSH
65121: LD_EXP 59
65125: PUSH
65126: LD_VAR 0 2
65130: ARRAY
65131: PPUSH
65132: LD_INT 25
65134: PUSH
65135: LD_INT 2
65137: PUSH
65138: EMPTY
65139: LIST
65140: LIST
65141: PUSH
65142: LD_INT 24
65144: PUSH
65145: LD_INT 750
65147: PUSH
65148: EMPTY
65149: LIST
65150: LIST
65151: PUSH
65152: EMPTY
65153: LIST
65154: LIST
65155: PPUSH
65156: CALL_OW 72
65160: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65161: LD_EXP 88
65165: PUSH
65166: LD_VAR 0 2
65170: ARRAY
65171: PUSH
65172: LD_EXP 59
65176: PUSH
65177: LD_VAR 0 2
65181: ARRAY
65182: PPUSH
65183: LD_INT 25
65185: PUSH
65186: LD_INT 2
65188: PUSH
65189: EMPTY
65190: LIST
65191: LIST
65192: PUSH
65193: LD_INT 24
65195: PUSH
65196: LD_INT 750
65198: PUSH
65199: EMPTY
65200: LIST
65201: LIST
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PPUSH
65207: CALL_OW 72
65211: AND
65212: PUSH
65213: LD_VAR 0 5
65217: PUSH
65218: LD_INT 5
65220: LESS
65221: AND
65222: IFFALSE 65304
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65224: LD_ADDR_VAR 0 3
65228: PUSH
65229: LD_EXP 59
65233: PUSH
65234: LD_VAR 0 2
65238: ARRAY
65239: PPUSH
65240: LD_INT 25
65242: PUSH
65243: LD_INT 2
65245: PUSH
65246: EMPTY
65247: LIST
65248: LIST
65249: PUSH
65250: LD_INT 24
65252: PUSH
65253: LD_INT 750
65255: PUSH
65256: EMPTY
65257: LIST
65258: LIST
65259: PUSH
65260: EMPTY
65261: LIST
65262: LIST
65263: PPUSH
65264: CALL_OW 72
65268: PUSH
65269: FOR_IN
65270: IFFALSE 65302
// begin tmp := tmp union j ;
65272: LD_ADDR_VAR 0 5
65276: PUSH
65277: LD_VAR 0 5
65281: PUSH
65282: LD_VAR 0 3
65286: UNION
65287: ST_TO_ADDR
// if tmp >= 5 then
65288: LD_VAR 0 5
65292: PUSH
65293: LD_INT 5
65295: GREATEREQUAL
65296: IFFALSE 65300
// break ;
65298: GO 65302
// end ;
65300: GO 65269
65302: POP
65303: POP
// end ; if not tmp then
65304: LD_VAR 0 5
65308: NOT
65309: IFFALSE 65313
// continue ;
65311: GO 64525
// for j in tmp do
65313: LD_ADDR_VAR 0 3
65317: PUSH
65318: LD_VAR 0 5
65322: PUSH
65323: FOR_IN
65324: IFFALSE 65414
// if not GetTag ( j ) then
65326: LD_VAR 0 3
65330: PPUSH
65331: CALL_OW 110
65335: NOT
65336: IFFALSE 65412
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65338: LD_ADDR_EXP 76
65342: PUSH
65343: LD_EXP 76
65347: PPUSH
65348: LD_VAR 0 2
65352: PUSH
65353: LD_EXP 76
65357: PUSH
65358: LD_VAR 0 2
65362: ARRAY
65363: PUSH
65364: LD_INT 1
65366: PLUS
65367: PUSH
65368: EMPTY
65369: LIST
65370: LIST
65371: PPUSH
65372: LD_VAR 0 3
65376: PPUSH
65377: CALL 19263 0 3
65381: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65382: LD_VAR 0 3
65386: PPUSH
65387: LD_INT 107
65389: PPUSH
65390: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65394: LD_EXP 76
65398: PUSH
65399: LD_VAR 0 2
65403: ARRAY
65404: PUSH
65405: LD_INT 5
65407: GREATEREQUAL
65408: IFFALSE 65412
// break ;
65410: GO 65414
// end ;
65412: GO 65323
65414: POP
65415: POP
// end ; if mc_crates_collector [ i ] and target then
65416: LD_EXP 76
65420: PUSH
65421: LD_VAR 0 2
65425: ARRAY
65426: PUSH
65427: LD_VAR 0 6
65431: AND
65432: IFFALSE 65675
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65434: LD_EXP 76
65438: PUSH
65439: LD_VAR 0 2
65443: ARRAY
65444: PUSH
65445: LD_VAR 0 6
65449: PUSH
65450: LD_INT 1
65452: ARRAY
65453: LESS
65454: IFFALSE 65474
// tmp := mc_crates_collector [ i ] else
65456: LD_ADDR_VAR 0 5
65460: PUSH
65461: LD_EXP 76
65465: PUSH
65466: LD_VAR 0 2
65470: ARRAY
65471: ST_TO_ADDR
65472: GO 65488
// tmp := target [ 1 ] ;
65474: LD_ADDR_VAR 0 5
65478: PUSH
65479: LD_VAR 0 6
65483: PUSH
65484: LD_INT 1
65486: ARRAY
65487: ST_TO_ADDR
// k := 0 ;
65488: LD_ADDR_VAR 0 4
65492: PUSH
65493: LD_INT 0
65495: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65496: LD_ADDR_VAR 0 3
65500: PUSH
65501: LD_EXP 76
65505: PUSH
65506: LD_VAR 0 2
65510: ARRAY
65511: PUSH
65512: FOR_IN
65513: IFFALSE 65673
// begin k := k + 1 ;
65515: LD_ADDR_VAR 0 4
65519: PUSH
65520: LD_VAR 0 4
65524: PUSH
65525: LD_INT 1
65527: PLUS
65528: ST_TO_ADDR
// if k > tmp then
65529: LD_VAR 0 4
65533: PUSH
65534: LD_VAR 0 5
65538: GREATER
65539: IFFALSE 65543
// break ;
65541: GO 65673
// if not GetClass ( j ) in [ 2 , 16 ] then
65543: LD_VAR 0 3
65547: PPUSH
65548: CALL_OW 257
65552: PUSH
65553: LD_INT 2
65555: PUSH
65556: LD_INT 16
65558: PUSH
65559: EMPTY
65560: LIST
65561: LIST
65562: IN
65563: NOT
65564: IFFALSE 65617
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65566: LD_ADDR_EXP 76
65570: PUSH
65571: LD_EXP 76
65575: PPUSH
65576: LD_VAR 0 2
65580: PPUSH
65581: LD_EXP 76
65585: PUSH
65586: LD_VAR 0 2
65590: ARRAY
65591: PUSH
65592: LD_VAR 0 3
65596: DIFF
65597: PPUSH
65598: CALL_OW 1
65602: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65603: LD_VAR 0 3
65607: PPUSH
65608: LD_INT 0
65610: PPUSH
65611: CALL_OW 109
// continue ;
65615: GO 65512
// end ; if IsInUnit ( j ) then
65617: LD_VAR 0 3
65621: PPUSH
65622: CALL_OW 310
65626: IFFALSE 65637
// ComExitBuilding ( j ) ;
65628: LD_VAR 0 3
65632: PPUSH
65633: CALL_OW 122
// wait ( 3 ) ;
65637: LD_INT 3
65639: PPUSH
65640: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65644: LD_VAR 0 3
65648: PPUSH
65649: LD_VAR 0 6
65653: PUSH
65654: LD_INT 2
65656: ARRAY
65657: PPUSH
65658: LD_VAR 0 6
65662: PUSH
65663: LD_INT 3
65665: ARRAY
65666: PPUSH
65667: CALL_OW 117
// end ;
65671: GO 65512
65673: POP
65674: POP
// end ; end else
65675: GO 66256
// begin for j in cargo do
65677: LD_ADDR_VAR 0 3
65681: PUSH
65682: LD_VAR 0 7
65686: PUSH
65687: FOR_IN
65688: IFFALSE 66254
// begin if GetTag ( j ) <> 0 then
65690: LD_VAR 0 3
65694: PPUSH
65695: CALL_OW 110
65699: PUSH
65700: LD_INT 0
65702: NONEQUAL
65703: IFFALSE 65707
// continue ;
65705: GO 65687
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65707: LD_VAR 0 3
65711: PPUSH
65712: CALL_OW 256
65716: PUSH
65717: LD_INT 1000
65719: LESS
65720: PUSH
65721: LD_VAR 0 3
65725: PPUSH
65726: LD_EXP 83
65730: PUSH
65731: LD_VAR 0 2
65735: ARRAY
65736: PPUSH
65737: CALL_OW 308
65741: NOT
65742: AND
65743: IFFALSE 65765
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65745: LD_VAR 0 3
65749: PPUSH
65750: LD_EXP 83
65754: PUSH
65755: LD_VAR 0 2
65759: ARRAY
65760: PPUSH
65761: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65765: LD_VAR 0 3
65769: PPUSH
65770: CALL_OW 256
65774: PUSH
65775: LD_INT 1000
65777: LESS
65778: PUSH
65779: LD_VAR 0 3
65783: PPUSH
65784: LD_EXP 83
65788: PUSH
65789: LD_VAR 0 2
65793: ARRAY
65794: PPUSH
65795: CALL_OW 308
65799: AND
65800: IFFALSE 65804
// continue ;
65802: GO 65687
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65804: LD_VAR 0 3
65808: PPUSH
65809: CALL_OW 262
65813: PUSH
65814: LD_INT 2
65816: EQUAL
65817: PUSH
65818: LD_VAR 0 3
65822: PPUSH
65823: CALL_OW 261
65827: PUSH
65828: LD_INT 15
65830: LESS
65831: AND
65832: IFFALSE 65836
// continue ;
65834: GO 65687
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65836: LD_VAR 0 3
65840: PPUSH
65841: CALL_OW 262
65845: PUSH
65846: LD_INT 1
65848: EQUAL
65849: PUSH
65850: LD_VAR 0 3
65854: PPUSH
65855: CALL_OW 261
65859: PUSH
65860: LD_INT 10
65862: LESS
65863: AND
65864: IFFALSE 66193
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65866: LD_ADDR_VAR 0 8
65870: PUSH
65871: LD_EXP 59
65875: PUSH
65876: LD_VAR 0 2
65880: ARRAY
65881: PPUSH
65882: LD_INT 2
65884: PUSH
65885: LD_INT 30
65887: PUSH
65888: LD_INT 0
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: LD_INT 30
65897: PUSH
65898: LD_INT 1
65900: PUSH
65901: EMPTY
65902: LIST
65903: LIST
65904: PUSH
65905: EMPTY
65906: LIST
65907: LIST
65908: LIST
65909: PPUSH
65910: CALL_OW 72
65914: ST_TO_ADDR
// if not depot then
65915: LD_VAR 0 8
65919: NOT
65920: IFFALSE 65924
// continue ;
65922: GO 65687
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65924: LD_VAR 0 3
65928: PPUSH
65929: LD_VAR 0 8
65933: PPUSH
65934: LD_VAR 0 3
65938: PPUSH
65939: CALL_OW 74
65943: PPUSH
65944: CALL_OW 296
65948: PUSH
65949: LD_INT 6
65951: LESS
65952: IFFALSE 65968
// SetFuel ( j , 100 ) else
65954: LD_VAR 0 3
65958: PPUSH
65959: LD_INT 100
65961: PPUSH
65962: CALL_OW 240
65966: GO 66193
// if GetFuel ( j ) = 0 then
65968: LD_VAR 0 3
65972: PPUSH
65973: CALL_OW 261
65977: PUSH
65978: LD_INT 0
65980: EQUAL
65981: IFFALSE 66193
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65983: LD_ADDR_EXP 78
65987: PUSH
65988: LD_EXP 78
65992: PPUSH
65993: LD_VAR 0 2
65997: PPUSH
65998: LD_EXP 78
66002: PUSH
66003: LD_VAR 0 2
66007: ARRAY
66008: PUSH
66009: LD_VAR 0 3
66013: DIFF
66014: PPUSH
66015: CALL_OW 1
66019: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
66020: LD_VAR 0 3
66024: PPUSH
66025: CALL_OW 263
66029: PUSH
66030: LD_INT 1
66032: EQUAL
66033: IFFALSE 66049
// ComExitVehicle ( IsInUnit ( j ) ) ;
66035: LD_VAR 0 3
66039: PPUSH
66040: CALL_OW 310
66044: PPUSH
66045: CALL_OW 121
// if GetControl ( j ) = control_remote then
66049: LD_VAR 0 3
66053: PPUSH
66054: CALL_OW 263
66058: PUSH
66059: LD_INT 2
66061: EQUAL
66062: IFFALSE 66073
// ComUnlink ( j ) ;
66064: LD_VAR 0 3
66068: PPUSH
66069: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66073: LD_ADDR_VAR 0 9
66077: PUSH
66078: LD_VAR 0 2
66082: PPUSH
66083: LD_INT 3
66085: PPUSH
66086: CALL 75568 0 2
66090: ST_TO_ADDR
// if fac then
66091: LD_VAR 0 9
66095: IFFALSE 66191
// begin for k in fac do
66097: LD_ADDR_VAR 0 4
66101: PUSH
66102: LD_VAR 0 9
66106: PUSH
66107: FOR_IN
66108: IFFALSE 66189
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66110: LD_ADDR_VAR 0 10
66114: PUSH
66115: LD_VAR 0 9
66119: PPUSH
66120: LD_VAR 0 3
66124: PPUSH
66125: CALL_OW 265
66129: PPUSH
66130: LD_VAR 0 3
66134: PPUSH
66135: CALL_OW 262
66139: PPUSH
66140: LD_VAR 0 3
66144: PPUSH
66145: CALL_OW 263
66149: PPUSH
66150: LD_VAR 0 3
66154: PPUSH
66155: CALL_OW 264
66159: PPUSH
66160: CALL 16795 0 5
66164: ST_TO_ADDR
// if components then
66165: LD_VAR 0 10
66169: IFFALSE 66187
// begin MC_InsertProduceList ( i , components ) ;
66171: LD_VAR 0 2
66175: PPUSH
66176: LD_VAR 0 10
66180: PPUSH
66181: CALL 75113 0 2
// break ;
66185: GO 66189
// end ; end ;
66187: GO 66107
66189: POP
66190: POP
// end ; continue ;
66191: GO 65687
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66193: LD_VAR 0 3
66197: PPUSH
66198: LD_INT 1
66200: PPUSH
66201: CALL_OW 289
66205: PUSH
66206: LD_INT 100
66208: LESS
66209: PUSH
66210: LD_VAR 0 3
66214: PPUSH
66215: CALL_OW 314
66219: NOT
66220: AND
66221: IFFALSE 66250
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66223: LD_VAR 0 3
66227: PPUSH
66228: LD_VAR 0 6
66232: PUSH
66233: LD_INT 2
66235: ARRAY
66236: PPUSH
66237: LD_VAR 0 6
66241: PUSH
66242: LD_INT 3
66244: ARRAY
66245: PPUSH
66246: CALL_OW 117
// break ;
66250: GO 66254
// end ;
66252: GO 65687
66254: POP
66255: POP
// end ; end ;
66256: GO 64525
66258: POP
66259: POP
// end ;
66260: LD_VAR 0 1
66264: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66265: LD_INT 0
66267: PPUSH
66268: PPUSH
66269: PPUSH
66270: PPUSH
// if not mc_bases then
66271: LD_EXP 59
66275: NOT
66276: IFFALSE 66280
// exit ;
66278: GO 66441
// for i = 1 to mc_bases do
66280: LD_ADDR_VAR 0 2
66284: PUSH
66285: DOUBLE
66286: LD_INT 1
66288: DEC
66289: ST_TO_ADDR
66290: LD_EXP 59
66294: PUSH
66295: FOR_TO
66296: IFFALSE 66439
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66298: LD_ADDR_VAR 0 4
66302: PUSH
66303: LD_EXP 78
66307: PUSH
66308: LD_VAR 0 2
66312: ARRAY
66313: PUSH
66314: LD_EXP 81
66318: PUSH
66319: LD_VAR 0 2
66323: ARRAY
66324: UNION
66325: PPUSH
66326: LD_INT 33
66328: PUSH
66329: LD_INT 2
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PPUSH
66336: CALL_OW 72
66340: ST_TO_ADDR
// if tmp then
66341: LD_VAR 0 4
66345: IFFALSE 66437
// for j in tmp do
66347: LD_ADDR_VAR 0 3
66351: PUSH
66352: LD_VAR 0 4
66356: PUSH
66357: FOR_IN
66358: IFFALSE 66435
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66360: LD_VAR 0 3
66364: PPUSH
66365: CALL_OW 312
66369: NOT
66370: PUSH
66371: LD_VAR 0 3
66375: PPUSH
66376: CALL_OW 256
66380: PUSH
66381: LD_INT 250
66383: GREATEREQUAL
66384: AND
66385: IFFALSE 66398
// Connect ( j ) else
66387: LD_VAR 0 3
66391: PPUSH
66392: CALL 22196 0 1
66396: GO 66433
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66398: LD_VAR 0 3
66402: PPUSH
66403: CALL_OW 256
66407: PUSH
66408: LD_INT 250
66410: LESS
66411: PUSH
66412: LD_VAR 0 3
66416: PPUSH
66417: CALL_OW 312
66421: AND
66422: IFFALSE 66433
// ComUnlink ( j ) ;
66424: LD_VAR 0 3
66428: PPUSH
66429: CALL_OW 136
66433: GO 66357
66435: POP
66436: POP
// end ;
66437: GO 66295
66439: POP
66440: POP
// end ;
66441: LD_VAR 0 1
66445: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66446: LD_INT 0
66448: PPUSH
66449: PPUSH
66450: PPUSH
66451: PPUSH
66452: PPUSH
// if not mc_bases then
66453: LD_EXP 59
66457: NOT
66458: IFFALSE 66462
// exit ;
66460: GO 66907
// for i = 1 to mc_bases do
66462: LD_ADDR_VAR 0 2
66466: PUSH
66467: DOUBLE
66468: LD_INT 1
66470: DEC
66471: ST_TO_ADDR
66472: LD_EXP 59
66476: PUSH
66477: FOR_TO
66478: IFFALSE 66905
// begin if not mc_produce [ i ] then
66480: LD_EXP 80
66484: PUSH
66485: LD_VAR 0 2
66489: ARRAY
66490: NOT
66491: IFFALSE 66495
// continue ;
66493: GO 66477
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66495: LD_ADDR_VAR 0 5
66499: PUSH
66500: LD_EXP 59
66504: PUSH
66505: LD_VAR 0 2
66509: ARRAY
66510: PPUSH
66511: LD_INT 30
66513: PUSH
66514: LD_INT 3
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: PPUSH
66521: CALL_OW 72
66525: ST_TO_ADDR
// if not fac then
66526: LD_VAR 0 5
66530: NOT
66531: IFFALSE 66535
// continue ;
66533: GO 66477
// for j in fac do
66535: LD_ADDR_VAR 0 3
66539: PUSH
66540: LD_VAR 0 5
66544: PUSH
66545: FOR_IN
66546: IFFALSE 66901
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66548: LD_VAR 0 3
66552: PPUSH
66553: CALL_OW 461
66557: PUSH
66558: LD_INT 2
66560: NONEQUAL
66561: PUSH
66562: LD_VAR 0 3
66566: PPUSH
66567: LD_INT 15
66569: PPUSH
66570: CALL 21856 0 2
66574: PUSH
66575: LD_INT 4
66577: ARRAY
66578: OR
66579: IFFALSE 66583
// continue ;
66581: GO 66545
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66583: LD_VAR 0 3
66587: PPUSH
66588: LD_EXP 80
66592: PUSH
66593: LD_VAR 0 2
66597: ARRAY
66598: PUSH
66599: LD_INT 1
66601: ARRAY
66602: PUSH
66603: LD_INT 1
66605: ARRAY
66606: PPUSH
66607: LD_EXP 80
66611: PUSH
66612: LD_VAR 0 2
66616: ARRAY
66617: PUSH
66618: LD_INT 1
66620: ARRAY
66621: PUSH
66622: LD_INT 2
66624: ARRAY
66625: PPUSH
66626: LD_EXP 80
66630: PUSH
66631: LD_VAR 0 2
66635: ARRAY
66636: PUSH
66637: LD_INT 1
66639: ARRAY
66640: PUSH
66641: LD_INT 3
66643: ARRAY
66644: PPUSH
66645: LD_EXP 80
66649: PUSH
66650: LD_VAR 0 2
66654: ARRAY
66655: PUSH
66656: LD_INT 1
66658: ARRAY
66659: PUSH
66660: LD_INT 4
66662: ARRAY
66663: PPUSH
66664: CALL_OW 448
66668: PUSH
66669: LD_VAR 0 3
66673: PPUSH
66674: LD_EXP 80
66678: PUSH
66679: LD_VAR 0 2
66683: ARRAY
66684: PUSH
66685: LD_INT 1
66687: ARRAY
66688: PUSH
66689: LD_INT 1
66691: ARRAY
66692: PUSH
66693: LD_EXP 80
66697: PUSH
66698: LD_VAR 0 2
66702: ARRAY
66703: PUSH
66704: LD_INT 1
66706: ARRAY
66707: PUSH
66708: LD_INT 2
66710: ARRAY
66711: PUSH
66712: LD_EXP 80
66716: PUSH
66717: LD_VAR 0 2
66721: ARRAY
66722: PUSH
66723: LD_INT 1
66725: ARRAY
66726: PUSH
66727: LD_INT 3
66729: ARRAY
66730: PUSH
66731: LD_EXP 80
66735: PUSH
66736: LD_VAR 0 2
66740: ARRAY
66741: PUSH
66742: LD_INT 1
66744: ARRAY
66745: PUSH
66746: LD_INT 4
66748: ARRAY
66749: PUSH
66750: EMPTY
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: PPUSH
66756: CALL 25527 0 2
66760: AND
66761: IFFALSE 66899
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66763: LD_VAR 0 3
66767: PPUSH
66768: LD_EXP 80
66772: PUSH
66773: LD_VAR 0 2
66777: ARRAY
66778: PUSH
66779: LD_INT 1
66781: ARRAY
66782: PUSH
66783: LD_INT 1
66785: ARRAY
66786: PPUSH
66787: LD_EXP 80
66791: PUSH
66792: LD_VAR 0 2
66796: ARRAY
66797: PUSH
66798: LD_INT 1
66800: ARRAY
66801: PUSH
66802: LD_INT 2
66804: ARRAY
66805: PPUSH
66806: LD_EXP 80
66810: PUSH
66811: LD_VAR 0 2
66815: ARRAY
66816: PUSH
66817: LD_INT 1
66819: ARRAY
66820: PUSH
66821: LD_INT 3
66823: ARRAY
66824: PPUSH
66825: LD_EXP 80
66829: PUSH
66830: LD_VAR 0 2
66834: ARRAY
66835: PUSH
66836: LD_INT 1
66838: ARRAY
66839: PUSH
66840: LD_INT 4
66842: ARRAY
66843: PPUSH
66844: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66848: LD_ADDR_VAR 0 4
66852: PUSH
66853: LD_EXP 80
66857: PUSH
66858: LD_VAR 0 2
66862: ARRAY
66863: PPUSH
66864: LD_INT 1
66866: PPUSH
66867: CALL_OW 3
66871: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66872: LD_ADDR_EXP 80
66876: PUSH
66877: LD_EXP 80
66881: PPUSH
66882: LD_VAR 0 2
66886: PPUSH
66887: LD_VAR 0 4
66891: PPUSH
66892: CALL_OW 1
66896: ST_TO_ADDR
// break ;
66897: GO 66901
// end ; end ;
66899: GO 66545
66901: POP
66902: POP
// end ;
66903: GO 66477
66905: POP
66906: POP
// end ;
66907: LD_VAR 0 1
66911: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66912: LD_INT 0
66914: PPUSH
66915: PPUSH
66916: PPUSH
// if not mc_bases then
66917: LD_EXP 59
66921: NOT
66922: IFFALSE 66926
// exit ;
66924: GO 67015
// for i = 1 to mc_bases do
66926: LD_ADDR_VAR 0 2
66930: PUSH
66931: DOUBLE
66932: LD_INT 1
66934: DEC
66935: ST_TO_ADDR
66936: LD_EXP 59
66940: PUSH
66941: FOR_TO
66942: IFFALSE 67013
// begin if mc_attack [ i ] then
66944: LD_EXP 79
66948: PUSH
66949: LD_VAR 0 2
66953: ARRAY
66954: IFFALSE 67011
// begin tmp := mc_attack [ i ] [ 1 ] ;
66956: LD_ADDR_VAR 0 3
66960: PUSH
66961: LD_EXP 79
66965: PUSH
66966: LD_VAR 0 2
66970: ARRAY
66971: PUSH
66972: LD_INT 1
66974: ARRAY
66975: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66976: LD_ADDR_EXP 79
66980: PUSH
66981: LD_EXP 79
66985: PPUSH
66986: LD_VAR 0 2
66990: PPUSH
66991: EMPTY
66992: PPUSH
66993: CALL_OW 1
66997: ST_TO_ADDR
// Attack ( tmp ) ;
66998: LD_VAR 0 3
67002: PPUSH
67003: CALL 98776 0 1
// exit ;
67007: POP
67008: POP
67009: GO 67015
// end ; end ;
67011: GO 66941
67013: POP
67014: POP
// end ;
67015: LD_VAR 0 1
67019: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
67020: LD_INT 0
67022: PPUSH
67023: PPUSH
67024: PPUSH
67025: PPUSH
67026: PPUSH
67027: PPUSH
67028: PPUSH
// if not mc_bases then
67029: LD_EXP 59
67033: NOT
67034: IFFALSE 67038
// exit ;
67036: GO 67642
// for i = 1 to mc_bases do
67038: LD_ADDR_VAR 0 2
67042: PUSH
67043: DOUBLE
67044: LD_INT 1
67046: DEC
67047: ST_TO_ADDR
67048: LD_EXP 59
67052: PUSH
67053: FOR_TO
67054: IFFALSE 67640
// begin if not mc_bases [ i ] then
67056: LD_EXP 59
67060: PUSH
67061: LD_VAR 0 2
67065: ARRAY
67066: NOT
67067: IFFALSE 67071
// continue ;
67069: GO 67053
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67071: LD_ADDR_VAR 0 7
67075: PUSH
67076: LD_EXP 59
67080: PUSH
67081: LD_VAR 0 2
67085: ARRAY
67086: PUSH
67087: LD_INT 1
67089: ARRAY
67090: PPUSH
67091: CALL 16099 0 1
67095: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67096: LD_ADDR_EXP 82
67100: PUSH
67101: LD_EXP 82
67105: PPUSH
67106: LD_VAR 0 2
67110: PPUSH
67111: LD_EXP 59
67115: PUSH
67116: LD_VAR 0 2
67120: ARRAY
67121: PUSH
67122: LD_INT 1
67124: ARRAY
67125: PPUSH
67126: CALL_OW 255
67130: PPUSH
67131: LD_EXP 84
67135: PUSH
67136: LD_VAR 0 2
67140: ARRAY
67141: PPUSH
67142: CALL 16064 0 2
67146: PPUSH
67147: CALL_OW 1
67151: ST_TO_ADDR
// if not mc_scan [ i ] then
67152: LD_EXP 82
67156: PUSH
67157: LD_VAR 0 2
67161: ARRAY
67162: NOT
67163: IFFALSE 67318
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67165: LD_ADDR_VAR 0 4
67169: PUSH
67170: LD_EXP 59
67174: PUSH
67175: LD_VAR 0 2
67179: ARRAY
67180: PPUSH
67181: LD_INT 2
67183: PUSH
67184: LD_INT 25
67186: PUSH
67187: LD_INT 5
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: LD_INT 25
67196: PUSH
67197: LD_INT 8
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PUSH
67204: LD_INT 25
67206: PUSH
67207: LD_INT 9
67209: PUSH
67210: EMPTY
67211: LIST
67212: LIST
67213: PUSH
67214: EMPTY
67215: LIST
67216: LIST
67217: LIST
67218: LIST
67219: PPUSH
67220: CALL_OW 72
67224: ST_TO_ADDR
// if not tmp then
67225: LD_VAR 0 4
67229: NOT
67230: IFFALSE 67234
// continue ;
67232: GO 67053
// for j in tmp do
67234: LD_ADDR_VAR 0 3
67238: PUSH
67239: LD_VAR 0 4
67243: PUSH
67244: FOR_IN
67245: IFFALSE 67316
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67247: LD_VAR 0 3
67251: PPUSH
67252: CALL_OW 310
67256: PPUSH
67257: CALL_OW 266
67261: PUSH
67262: LD_INT 5
67264: EQUAL
67265: PUSH
67266: LD_VAR 0 3
67270: PPUSH
67271: CALL_OW 257
67275: PUSH
67276: LD_INT 1
67278: EQUAL
67279: AND
67280: PUSH
67281: LD_VAR 0 3
67285: PPUSH
67286: CALL_OW 459
67290: NOT
67291: AND
67292: PUSH
67293: LD_VAR 0 7
67297: AND
67298: IFFALSE 67314
// ComChangeProfession ( j , class ) ;
67300: LD_VAR 0 3
67304: PPUSH
67305: LD_VAR 0 7
67309: PPUSH
67310: CALL_OW 123
67314: GO 67244
67316: POP
67317: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67318: LD_EXP 82
67322: PUSH
67323: LD_VAR 0 2
67327: ARRAY
67328: PUSH
67329: LD_EXP 81
67333: PUSH
67334: LD_VAR 0 2
67338: ARRAY
67339: NOT
67340: AND
67341: PUSH
67342: LD_EXP 59
67346: PUSH
67347: LD_VAR 0 2
67351: ARRAY
67352: PPUSH
67353: LD_INT 30
67355: PUSH
67356: LD_INT 32
67358: PUSH
67359: EMPTY
67360: LIST
67361: LIST
67362: PPUSH
67363: CALL_OW 72
67367: NOT
67368: AND
67369: PUSH
67370: LD_EXP 59
67374: PUSH
67375: LD_VAR 0 2
67379: ARRAY
67380: PPUSH
67381: LD_INT 2
67383: PUSH
67384: LD_INT 30
67386: PUSH
67387: LD_INT 4
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PUSH
67394: LD_INT 30
67396: PUSH
67397: LD_INT 5
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: EMPTY
67405: LIST
67406: LIST
67407: LIST
67408: PPUSH
67409: CALL_OW 72
67413: NOT
67414: AND
67415: IFFALSE 67547
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67417: LD_ADDR_VAR 0 4
67421: PUSH
67422: LD_EXP 59
67426: PUSH
67427: LD_VAR 0 2
67431: ARRAY
67432: PPUSH
67433: LD_INT 2
67435: PUSH
67436: LD_INT 25
67438: PUSH
67439: LD_INT 1
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: PUSH
67446: LD_INT 25
67448: PUSH
67449: LD_INT 5
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: PUSH
67456: LD_INT 25
67458: PUSH
67459: LD_INT 8
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 25
67468: PUSH
67469: LD_INT 9
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: PUSH
67476: EMPTY
67477: LIST
67478: LIST
67479: LIST
67480: LIST
67481: LIST
67482: PPUSH
67483: CALL_OW 72
67487: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67488: LD_ADDR_VAR 0 4
67492: PUSH
67493: LD_VAR 0 4
67497: PUSH
67498: LD_VAR 0 4
67502: PPUSH
67503: LD_INT 18
67505: PPUSH
67506: CALL 47824 0 2
67510: DIFF
67511: ST_TO_ADDR
// if tmp then
67512: LD_VAR 0 4
67516: IFFALSE 67547
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
67518: LD_VAR 0 2
67522: PPUSH
67523: LD_VAR 0 4
67527: PPUSH
67528: LD_EXP 84
67532: PUSH
67533: LD_VAR 0 2
67537: ARRAY
67538: PPUSH
67539: CALL 103485 0 3
// exit ;
67543: POP
67544: POP
67545: GO 67642
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
67547: LD_EXP 82
67551: PUSH
67552: LD_VAR 0 2
67556: ARRAY
67557: PUSH
67558: LD_EXP 81
67562: PUSH
67563: LD_VAR 0 2
67567: ARRAY
67568: AND
67569: IFFALSE 67638
// begin tmp := mc_defender [ i ] ;
67571: LD_ADDR_VAR 0 4
67575: PUSH
67576: LD_EXP 81
67580: PUSH
67581: LD_VAR 0 2
67585: ARRAY
67586: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67587: LD_ADDR_EXP 81
67591: PUSH
67592: LD_EXP 81
67596: PPUSH
67597: LD_VAR 0 2
67601: PPUSH
67602: EMPTY
67603: PPUSH
67604: CALL_OW 1
67608: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
67609: LD_VAR 0 2
67613: PPUSH
67614: LD_VAR 0 4
67618: PPUSH
67619: LD_EXP 82
67623: PUSH
67624: LD_VAR 0 2
67628: ARRAY
67629: PPUSH
67630: CALL 104046 0 3
// exit ;
67634: POP
67635: POP
67636: GO 67642
// end ; end ;
67638: GO 67053
67640: POP
67641: POP
// end ;
67642: LD_VAR 0 1
67646: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
67647: LD_INT 0
67649: PPUSH
67650: PPUSH
67651: PPUSH
67652: PPUSH
67653: PPUSH
67654: PPUSH
67655: PPUSH
67656: PPUSH
67657: PPUSH
67658: PPUSH
67659: PPUSH
// if not mc_bases then
67660: LD_EXP 59
67664: NOT
67665: IFFALSE 67669
// exit ;
67667: GO 68756
// for i = 1 to mc_bases do
67669: LD_ADDR_VAR 0 2
67673: PUSH
67674: DOUBLE
67675: LD_INT 1
67677: DEC
67678: ST_TO_ADDR
67679: LD_EXP 59
67683: PUSH
67684: FOR_TO
67685: IFFALSE 68754
// begin tmp := mc_lab [ i ] ;
67687: LD_ADDR_VAR 0 6
67691: PUSH
67692: LD_EXP 92
67696: PUSH
67697: LD_VAR 0 2
67701: ARRAY
67702: ST_TO_ADDR
// if not tmp then
67703: LD_VAR 0 6
67707: NOT
67708: IFFALSE 67712
// continue ;
67710: GO 67684
// idle_lab := 0 ;
67712: LD_ADDR_VAR 0 11
67716: PUSH
67717: LD_INT 0
67719: ST_TO_ADDR
// for j in tmp do
67720: LD_ADDR_VAR 0 3
67724: PUSH
67725: LD_VAR 0 6
67729: PUSH
67730: FOR_IN
67731: IFFALSE 68750
// begin researching := false ;
67733: LD_ADDR_VAR 0 10
67737: PUSH
67738: LD_INT 0
67740: ST_TO_ADDR
// side := GetSide ( j ) ;
67741: LD_ADDR_VAR 0 4
67745: PUSH
67746: LD_VAR 0 3
67750: PPUSH
67751: CALL_OW 255
67755: ST_TO_ADDR
// if not mc_tech [ side ] then
67756: LD_EXP 86
67760: PUSH
67761: LD_VAR 0 4
67765: ARRAY
67766: NOT
67767: IFFALSE 67771
// continue ;
67769: GO 67730
// if BuildingStatus ( j ) = bs_idle then
67771: LD_VAR 0 3
67775: PPUSH
67776: CALL_OW 461
67780: PUSH
67781: LD_INT 2
67783: EQUAL
67784: IFFALSE 67972
// begin if idle_lab and UnitsInside ( j ) < 6 then
67786: LD_VAR 0 11
67790: PUSH
67791: LD_VAR 0 3
67795: PPUSH
67796: CALL_OW 313
67800: PUSH
67801: LD_INT 6
67803: LESS
67804: AND
67805: IFFALSE 67876
// begin tmp2 := UnitsInside ( idle_lab ) ;
67807: LD_ADDR_VAR 0 9
67811: PUSH
67812: LD_VAR 0 11
67816: PPUSH
67817: CALL_OW 313
67821: ST_TO_ADDR
// if tmp2 then
67822: LD_VAR 0 9
67826: IFFALSE 67868
// for x in tmp2 do
67828: LD_ADDR_VAR 0 7
67832: PUSH
67833: LD_VAR 0 9
67837: PUSH
67838: FOR_IN
67839: IFFALSE 67866
// begin ComExitBuilding ( x ) ;
67841: LD_VAR 0 7
67845: PPUSH
67846: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67850: LD_VAR 0 7
67854: PPUSH
67855: LD_VAR 0 3
67859: PPUSH
67860: CALL_OW 180
// end ;
67864: GO 67838
67866: POP
67867: POP
// idle_lab := 0 ;
67868: LD_ADDR_VAR 0 11
67872: PUSH
67873: LD_INT 0
67875: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
67876: LD_ADDR_VAR 0 5
67880: PUSH
67881: LD_EXP 86
67885: PUSH
67886: LD_VAR 0 4
67890: ARRAY
67891: PUSH
67892: FOR_IN
67893: IFFALSE 67953
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
67895: LD_VAR 0 3
67899: PPUSH
67900: LD_VAR 0 5
67904: PPUSH
67905: CALL_OW 430
67909: PUSH
67910: LD_VAR 0 4
67914: PPUSH
67915: LD_VAR 0 5
67919: PPUSH
67920: CALL 15169 0 2
67924: AND
67925: IFFALSE 67951
// begin researching := true ;
67927: LD_ADDR_VAR 0 10
67931: PUSH
67932: LD_INT 1
67934: ST_TO_ADDR
// ComResearch ( j , t ) ;
67935: LD_VAR 0 3
67939: PPUSH
67940: LD_VAR 0 5
67944: PPUSH
67945: CALL_OW 124
// break ;
67949: GO 67953
// end ;
67951: GO 67892
67953: POP
67954: POP
// if not researching then
67955: LD_VAR 0 10
67959: NOT
67960: IFFALSE 67972
// idle_lab := j ;
67962: LD_ADDR_VAR 0 11
67966: PUSH
67967: LD_VAR 0 3
67971: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
67972: LD_VAR 0 3
67976: PPUSH
67977: CALL_OW 461
67981: PUSH
67982: LD_INT 10
67984: EQUAL
67985: IFFALSE 68573
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
67987: LD_EXP 88
67991: PUSH
67992: LD_VAR 0 2
67996: ARRAY
67997: NOT
67998: PUSH
67999: LD_EXP 89
68003: PUSH
68004: LD_VAR 0 2
68008: ARRAY
68009: NOT
68010: AND
68011: PUSH
68012: LD_EXP 86
68016: PUSH
68017: LD_VAR 0 4
68021: ARRAY
68022: PUSH
68023: LD_INT 1
68025: GREATER
68026: AND
68027: IFFALSE 68158
// begin ComCancel ( j ) ;
68029: LD_VAR 0 3
68033: PPUSH
68034: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68038: LD_ADDR_EXP 86
68042: PUSH
68043: LD_EXP 86
68047: PPUSH
68048: LD_VAR 0 4
68052: PPUSH
68053: LD_EXP 86
68057: PUSH
68058: LD_VAR 0 4
68062: ARRAY
68063: PPUSH
68064: LD_EXP 86
68068: PUSH
68069: LD_VAR 0 4
68073: ARRAY
68074: PUSH
68075: LD_INT 1
68077: MINUS
68078: PPUSH
68079: LD_EXP 86
68083: PUSH
68084: LD_VAR 0 4
68088: ARRAY
68089: PPUSH
68090: LD_INT 0
68092: PPUSH
68093: CALL 18681 0 4
68097: PPUSH
68098: CALL_OW 1
68102: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68103: LD_ADDR_EXP 86
68107: PUSH
68108: LD_EXP 86
68112: PPUSH
68113: LD_VAR 0 4
68117: PPUSH
68118: LD_EXP 86
68122: PUSH
68123: LD_VAR 0 4
68127: ARRAY
68128: PPUSH
68129: LD_EXP 86
68133: PUSH
68134: LD_VAR 0 4
68138: ARRAY
68139: PPUSH
68140: LD_INT 1
68142: PPUSH
68143: LD_INT 0
68145: PPUSH
68146: CALL 18681 0 4
68150: PPUSH
68151: CALL_OW 1
68155: ST_TO_ADDR
// continue ;
68156: GO 67730
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68158: LD_EXP 88
68162: PUSH
68163: LD_VAR 0 2
68167: ARRAY
68168: PUSH
68169: LD_EXP 89
68173: PUSH
68174: LD_VAR 0 2
68178: ARRAY
68179: NOT
68180: AND
68181: IFFALSE 68308
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68183: LD_ADDR_EXP 89
68187: PUSH
68188: LD_EXP 89
68192: PPUSH
68193: LD_VAR 0 2
68197: PUSH
68198: LD_EXP 89
68202: PUSH
68203: LD_VAR 0 2
68207: ARRAY
68208: PUSH
68209: LD_INT 1
68211: PLUS
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: PPUSH
68217: LD_EXP 88
68221: PUSH
68222: LD_VAR 0 2
68226: ARRAY
68227: PUSH
68228: LD_INT 1
68230: ARRAY
68231: PPUSH
68232: CALL 19263 0 3
68236: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68237: LD_EXP 88
68241: PUSH
68242: LD_VAR 0 2
68246: ARRAY
68247: PUSH
68248: LD_INT 1
68250: ARRAY
68251: PPUSH
68252: LD_INT 112
68254: PPUSH
68255: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68259: LD_ADDR_VAR 0 9
68263: PUSH
68264: LD_EXP 88
68268: PUSH
68269: LD_VAR 0 2
68273: ARRAY
68274: PPUSH
68275: LD_INT 1
68277: PPUSH
68278: CALL_OW 3
68282: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68283: LD_ADDR_EXP 88
68287: PUSH
68288: LD_EXP 88
68292: PPUSH
68293: LD_VAR 0 2
68297: PPUSH
68298: LD_VAR 0 9
68302: PPUSH
68303: CALL_OW 1
68307: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68308: LD_EXP 88
68312: PUSH
68313: LD_VAR 0 2
68317: ARRAY
68318: PUSH
68319: LD_EXP 89
68323: PUSH
68324: LD_VAR 0 2
68328: ARRAY
68329: AND
68330: PUSH
68331: LD_EXP 89
68335: PUSH
68336: LD_VAR 0 2
68340: ARRAY
68341: PUSH
68342: LD_INT 1
68344: ARRAY
68345: PPUSH
68346: CALL_OW 310
68350: NOT
68351: AND
68352: PUSH
68353: LD_VAR 0 3
68357: PPUSH
68358: CALL_OW 313
68362: PUSH
68363: LD_INT 6
68365: EQUAL
68366: AND
68367: IFFALSE 68423
// begin tmp2 := UnitsInside ( j ) ;
68369: LD_ADDR_VAR 0 9
68373: PUSH
68374: LD_VAR 0 3
68378: PPUSH
68379: CALL_OW 313
68383: ST_TO_ADDR
// if tmp2 = 6 then
68384: LD_VAR 0 9
68388: PUSH
68389: LD_INT 6
68391: EQUAL
68392: IFFALSE 68423
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68394: LD_VAR 0 9
68398: PUSH
68399: LD_INT 1
68401: ARRAY
68402: PPUSH
68403: LD_INT 112
68405: PPUSH
68406: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68410: LD_VAR 0 9
68414: PUSH
68415: LD_INT 1
68417: ARRAY
68418: PPUSH
68419: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68423: LD_EXP 89
68427: PUSH
68428: LD_VAR 0 2
68432: ARRAY
68433: PUSH
68434: LD_EXP 89
68438: PUSH
68439: LD_VAR 0 2
68443: ARRAY
68444: PUSH
68445: LD_INT 1
68447: ARRAY
68448: PPUSH
68449: CALL_OW 314
68453: NOT
68454: AND
68455: PUSH
68456: LD_EXP 89
68460: PUSH
68461: LD_VAR 0 2
68465: ARRAY
68466: PUSH
68467: LD_INT 1
68469: ARRAY
68470: PPUSH
68471: CALL_OW 310
68475: NOT
68476: AND
68477: IFFALSE 68503
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68479: LD_EXP 89
68483: PUSH
68484: LD_VAR 0 2
68488: ARRAY
68489: PUSH
68490: LD_INT 1
68492: ARRAY
68493: PPUSH
68494: LD_VAR 0 3
68498: PPUSH
68499: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68503: LD_EXP 89
68507: PUSH
68508: LD_VAR 0 2
68512: ARRAY
68513: PUSH
68514: LD_INT 1
68516: ARRAY
68517: PPUSH
68518: CALL_OW 310
68522: PUSH
68523: LD_EXP 89
68527: PUSH
68528: LD_VAR 0 2
68532: ARRAY
68533: PUSH
68534: LD_INT 1
68536: ARRAY
68537: PPUSH
68538: CALL_OW 310
68542: PPUSH
68543: CALL_OW 461
68547: PUSH
68548: LD_INT 3
68550: NONEQUAL
68551: AND
68552: IFFALSE 68573
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68554: LD_EXP 89
68558: PUSH
68559: LD_VAR 0 2
68563: ARRAY
68564: PUSH
68565: LD_INT 1
68567: ARRAY
68568: PPUSH
68569: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68573: LD_VAR 0 3
68577: PPUSH
68578: CALL_OW 461
68582: PUSH
68583: LD_INT 6
68585: EQUAL
68586: PUSH
68587: LD_VAR 0 6
68591: PUSH
68592: LD_INT 1
68594: GREATER
68595: AND
68596: IFFALSE 68748
// begin sci := [ ] ;
68598: LD_ADDR_VAR 0 8
68602: PUSH
68603: EMPTY
68604: ST_TO_ADDR
// for x in ( tmp diff j ) do
68605: LD_ADDR_VAR 0 7
68609: PUSH
68610: LD_VAR 0 6
68614: PUSH
68615: LD_VAR 0 3
68619: DIFF
68620: PUSH
68621: FOR_IN
68622: IFFALSE 68674
// begin if sci = 6 then
68624: LD_VAR 0 8
68628: PUSH
68629: LD_INT 6
68631: EQUAL
68632: IFFALSE 68636
// break ;
68634: GO 68674
// if BuildingStatus ( x ) = bs_idle then
68636: LD_VAR 0 7
68640: PPUSH
68641: CALL_OW 461
68645: PUSH
68646: LD_INT 2
68648: EQUAL
68649: IFFALSE 68672
// sci := sci ^ UnitsInside ( x ) ;
68651: LD_ADDR_VAR 0 8
68655: PUSH
68656: LD_VAR 0 8
68660: PUSH
68661: LD_VAR 0 7
68665: PPUSH
68666: CALL_OW 313
68670: ADD
68671: ST_TO_ADDR
// end ;
68672: GO 68621
68674: POP
68675: POP
// if not sci then
68676: LD_VAR 0 8
68680: NOT
68681: IFFALSE 68685
// continue ;
68683: GO 67730
// for x in sci do
68685: LD_ADDR_VAR 0 7
68689: PUSH
68690: LD_VAR 0 8
68694: PUSH
68695: FOR_IN
68696: IFFALSE 68746
// if IsInUnit ( x ) and not HasTask ( x ) then
68698: LD_VAR 0 7
68702: PPUSH
68703: CALL_OW 310
68707: PUSH
68708: LD_VAR 0 7
68712: PPUSH
68713: CALL_OW 314
68717: NOT
68718: AND
68719: IFFALSE 68744
// begin ComExitBuilding ( x ) ;
68721: LD_VAR 0 7
68725: PPUSH
68726: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68730: LD_VAR 0 7
68734: PPUSH
68735: LD_VAR 0 3
68739: PPUSH
68740: CALL_OW 180
// end ;
68744: GO 68695
68746: POP
68747: POP
// end ; end ;
68748: GO 67730
68750: POP
68751: POP
// end ;
68752: GO 67684
68754: POP
68755: POP
// end ;
68756: LD_VAR 0 1
68760: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
68761: LD_INT 0
68763: PPUSH
68764: PPUSH
// if not mc_bases then
68765: LD_EXP 59
68769: NOT
68770: IFFALSE 68774
// exit ;
68772: GO 68855
// for i = 1 to mc_bases do
68774: LD_ADDR_VAR 0 2
68778: PUSH
68779: DOUBLE
68780: LD_INT 1
68782: DEC
68783: ST_TO_ADDR
68784: LD_EXP 59
68788: PUSH
68789: FOR_TO
68790: IFFALSE 68853
// if mc_mines [ i ] and mc_miners [ i ] then
68792: LD_EXP 72
68796: PUSH
68797: LD_VAR 0 2
68801: ARRAY
68802: PUSH
68803: LD_EXP 73
68807: PUSH
68808: LD_VAR 0 2
68812: ARRAY
68813: AND
68814: IFFALSE 68851
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
68816: LD_EXP 73
68820: PUSH
68821: LD_VAR 0 2
68825: ARRAY
68826: PUSH
68827: LD_INT 1
68829: ARRAY
68830: PPUSH
68831: CALL_OW 255
68835: PPUSH
68836: LD_EXP 72
68840: PUSH
68841: LD_VAR 0 2
68845: ARRAY
68846: PPUSH
68847: CALL 16252 0 2
68851: GO 68789
68853: POP
68854: POP
// end ;
68855: LD_VAR 0 1
68859: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
68860: LD_INT 0
68862: PPUSH
68863: PPUSH
68864: PPUSH
68865: PPUSH
68866: PPUSH
68867: PPUSH
68868: PPUSH
68869: PPUSH
// if not mc_bases or not mc_parking then
68870: LD_EXP 59
68874: NOT
68875: PUSH
68876: LD_EXP 83
68880: NOT
68881: OR
68882: IFFALSE 68886
// exit ;
68884: GO 69585
// for i = 1 to mc_bases do
68886: LD_ADDR_VAR 0 2
68890: PUSH
68891: DOUBLE
68892: LD_INT 1
68894: DEC
68895: ST_TO_ADDR
68896: LD_EXP 59
68900: PUSH
68901: FOR_TO
68902: IFFALSE 69583
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
68904: LD_EXP 59
68908: PUSH
68909: LD_VAR 0 2
68913: ARRAY
68914: NOT
68915: PUSH
68916: LD_EXP 83
68920: PUSH
68921: LD_VAR 0 2
68925: ARRAY
68926: NOT
68927: OR
68928: IFFALSE 68932
// continue ;
68930: GO 68901
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68932: LD_ADDR_VAR 0 5
68936: PUSH
68937: LD_EXP 59
68941: PUSH
68942: LD_VAR 0 2
68946: ARRAY
68947: PUSH
68948: LD_INT 1
68950: ARRAY
68951: PPUSH
68952: CALL_OW 255
68956: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68957: LD_ADDR_VAR 0 6
68961: PUSH
68962: LD_EXP 59
68966: PUSH
68967: LD_VAR 0 2
68971: ARRAY
68972: PPUSH
68973: LD_INT 30
68975: PUSH
68976: LD_INT 3
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PPUSH
68983: CALL_OW 72
68987: ST_TO_ADDR
// if not fac then
68988: LD_VAR 0 6
68992: NOT
68993: IFFALSE 69044
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68995: LD_ADDR_VAR 0 6
68999: PUSH
69000: LD_EXP 59
69004: PUSH
69005: LD_VAR 0 2
69009: ARRAY
69010: PPUSH
69011: LD_INT 2
69013: PUSH
69014: LD_INT 30
69016: PUSH
69017: LD_INT 0
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: PUSH
69024: LD_INT 30
69026: PUSH
69027: LD_INT 1
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: LIST
69038: PPUSH
69039: CALL_OW 72
69043: ST_TO_ADDR
// if not fac then
69044: LD_VAR 0 6
69048: NOT
69049: IFFALSE 69053
// continue ;
69051: GO 68901
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69053: LD_ADDR_VAR 0 7
69057: PUSH
69058: LD_EXP 83
69062: PUSH
69063: LD_VAR 0 2
69067: ARRAY
69068: PPUSH
69069: LD_INT 22
69071: PUSH
69072: LD_VAR 0 5
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: PUSH
69081: LD_INT 21
69083: PUSH
69084: LD_INT 2
69086: PUSH
69087: EMPTY
69088: LIST
69089: LIST
69090: PUSH
69091: LD_INT 3
69093: PUSH
69094: LD_INT 24
69096: PUSH
69097: LD_INT 1000
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: PUSH
69104: EMPTY
69105: LIST
69106: LIST
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: LIST
69112: PPUSH
69113: CALL_OW 70
69117: ST_TO_ADDR
// for j in fac do
69118: LD_ADDR_VAR 0 3
69122: PUSH
69123: LD_VAR 0 6
69127: PUSH
69128: FOR_IN
69129: IFFALSE 69210
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69131: LD_ADDR_VAR 0 7
69135: PUSH
69136: LD_VAR 0 7
69140: PUSH
69141: LD_INT 22
69143: PUSH
69144: LD_VAR 0 5
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 91
69155: PUSH
69156: LD_VAR 0 3
69160: PUSH
69161: LD_INT 15
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 21
69171: PUSH
69172: LD_INT 2
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: PUSH
69179: LD_INT 3
69181: PUSH
69182: LD_INT 24
69184: PUSH
69185: LD_INT 1000
69187: PUSH
69188: EMPTY
69189: LIST
69190: LIST
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: PUSH
69196: EMPTY
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: PPUSH
69202: CALL_OW 69
69206: UNION
69207: ST_TO_ADDR
69208: GO 69128
69210: POP
69211: POP
// if not vehs then
69212: LD_VAR 0 7
69216: NOT
69217: IFFALSE 69243
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69219: LD_ADDR_EXP 71
69223: PUSH
69224: LD_EXP 71
69228: PPUSH
69229: LD_VAR 0 2
69233: PPUSH
69234: EMPTY
69235: PPUSH
69236: CALL_OW 1
69240: ST_TO_ADDR
// continue ;
69241: GO 68901
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69243: LD_ADDR_VAR 0 8
69247: PUSH
69248: LD_EXP 59
69252: PUSH
69253: LD_VAR 0 2
69257: ARRAY
69258: PPUSH
69259: LD_INT 30
69261: PUSH
69262: LD_INT 3
69264: PUSH
69265: EMPTY
69266: LIST
69267: LIST
69268: PPUSH
69269: CALL_OW 72
69273: ST_TO_ADDR
// if tmp then
69274: LD_VAR 0 8
69278: IFFALSE 69381
// begin for j in tmp do
69280: LD_ADDR_VAR 0 3
69284: PUSH
69285: LD_VAR 0 8
69289: PUSH
69290: FOR_IN
69291: IFFALSE 69379
// for k in UnitsInside ( j ) do
69293: LD_ADDR_VAR 0 4
69297: PUSH
69298: LD_VAR 0 3
69302: PPUSH
69303: CALL_OW 313
69307: PUSH
69308: FOR_IN
69309: IFFALSE 69375
// if k then
69311: LD_VAR 0 4
69315: IFFALSE 69373
// if not k in mc_repair_vehicle [ i ] then
69317: LD_VAR 0 4
69321: PUSH
69322: LD_EXP 71
69326: PUSH
69327: LD_VAR 0 2
69331: ARRAY
69332: IN
69333: NOT
69334: IFFALSE 69373
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69336: LD_ADDR_EXP 71
69340: PUSH
69341: LD_EXP 71
69345: PPUSH
69346: LD_VAR 0 2
69350: PPUSH
69351: LD_EXP 71
69355: PUSH
69356: LD_VAR 0 2
69360: ARRAY
69361: PUSH
69362: LD_VAR 0 4
69366: UNION
69367: PPUSH
69368: CALL_OW 1
69372: ST_TO_ADDR
69373: GO 69308
69375: POP
69376: POP
69377: GO 69290
69379: POP
69380: POP
// end ; if not mc_repair_vehicle [ i ] then
69381: LD_EXP 71
69385: PUSH
69386: LD_VAR 0 2
69390: ARRAY
69391: NOT
69392: IFFALSE 69396
// continue ;
69394: GO 68901
// for j in mc_repair_vehicle [ i ] do
69396: LD_ADDR_VAR 0 3
69400: PUSH
69401: LD_EXP 71
69405: PUSH
69406: LD_VAR 0 2
69410: ARRAY
69411: PUSH
69412: FOR_IN
69413: IFFALSE 69579
// begin if GetClass ( j ) <> 3 then
69415: LD_VAR 0 3
69419: PPUSH
69420: CALL_OW 257
69424: PUSH
69425: LD_INT 3
69427: NONEQUAL
69428: IFFALSE 69469
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69430: LD_ADDR_EXP 71
69434: PUSH
69435: LD_EXP 71
69439: PPUSH
69440: LD_VAR 0 2
69444: PPUSH
69445: LD_EXP 71
69449: PUSH
69450: LD_VAR 0 2
69454: ARRAY
69455: PUSH
69456: LD_VAR 0 3
69460: DIFF
69461: PPUSH
69462: CALL_OW 1
69466: ST_TO_ADDR
// continue ;
69467: GO 69412
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69469: LD_VAR 0 3
69473: PPUSH
69474: CALL_OW 311
69478: NOT
69479: PUSH
69480: LD_VAR 0 3
69484: PUSH
69485: LD_EXP 62
69489: PUSH
69490: LD_VAR 0 2
69494: ARRAY
69495: PUSH
69496: LD_INT 1
69498: ARRAY
69499: IN
69500: NOT
69501: AND
69502: PUSH
69503: LD_VAR 0 3
69507: PUSH
69508: LD_EXP 62
69512: PUSH
69513: LD_VAR 0 2
69517: ARRAY
69518: PUSH
69519: LD_INT 2
69521: ARRAY
69522: IN
69523: NOT
69524: AND
69525: IFFALSE 69577
// begin if IsInUnit ( j ) then
69527: LD_VAR 0 3
69531: PPUSH
69532: CALL_OW 310
69536: IFFALSE 69547
// ComExitBuilding ( j ) ;
69538: LD_VAR 0 3
69542: PPUSH
69543: CALL_OW 122
// if not HasTask ( j ) then
69547: LD_VAR 0 3
69551: PPUSH
69552: CALL_OW 314
69556: NOT
69557: IFFALSE 69577
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
69559: LD_VAR 0 3
69563: PPUSH
69564: LD_VAR 0 7
69568: PUSH
69569: LD_INT 1
69571: ARRAY
69572: PPUSH
69573: CALL_OW 189
// end ; end ;
69577: GO 69412
69579: POP
69580: POP
// end ;
69581: GO 68901
69583: POP
69584: POP
// end ;
69585: LD_VAR 0 1
69589: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69590: LD_INT 0
69592: PPUSH
69593: PPUSH
69594: PPUSH
69595: PPUSH
69596: PPUSH
69597: PPUSH
69598: PPUSH
69599: PPUSH
69600: PPUSH
69601: PPUSH
69602: PPUSH
// if not mc_bases then
69603: LD_EXP 59
69607: NOT
69608: IFFALSE 69612
// exit ;
69610: GO 70414
// for i = 1 to mc_bases do
69612: LD_ADDR_VAR 0 2
69616: PUSH
69617: DOUBLE
69618: LD_INT 1
69620: DEC
69621: ST_TO_ADDR
69622: LD_EXP 59
69626: PUSH
69627: FOR_TO
69628: IFFALSE 70412
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
69630: LD_EXP 87
69634: PUSH
69635: LD_VAR 0 2
69639: ARRAY
69640: NOT
69641: PUSH
69642: LD_EXP 62
69646: PUSH
69647: LD_VAR 0 2
69651: ARRAY
69652: PUSH
69653: LD_INT 1
69655: ARRAY
69656: OR
69657: PUSH
69658: LD_EXP 62
69662: PUSH
69663: LD_VAR 0 2
69667: ARRAY
69668: PUSH
69669: LD_INT 2
69671: ARRAY
69672: OR
69673: PUSH
69674: LD_EXP 85
69678: PUSH
69679: LD_VAR 0 2
69683: ARRAY
69684: PPUSH
69685: LD_INT 1
69687: PPUSH
69688: CALL_OW 325
69692: NOT
69693: OR
69694: PUSH
69695: LD_EXP 82
69699: PUSH
69700: LD_VAR 0 2
69704: ARRAY
69705: OR
69706: IFFALSE 69710
// continue ;
69708: GO 69627
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
69710: LD_ADDR_VAR 0 8
69714: PUSH
69715: LD_EXP 59
69719: PUSH
69720: LD_VAR 0 2
69724: ARRAY
69725: PPUSH
69726: LD_INT 25
69728: PUSH
69729: LD_INT 4
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: LD_INT 50
69738: PUSH
69739: EMPTY
69740: LIST
69741: PUSH
69742: LD_INT 3
69744: PUSH
69745: LD_INT 60
69747: PUSH
69748: EMPTY
69749: LIST
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: PUSH
69755: EMPTY
69756: LIST
69757: LIST
69758: LIST
69759: PPUSH
69760: CALL_OW 72
69764: PUSH
69765: LD_EXP 63
69769: PUSH
69770: LD_VAR 0 2
69774: ARRAY
69775: DIFF
69776: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69777: LD_ADDR_VAR 0 9
69781: PUSH
69782: LD_EXP 59
69786: PUSH
69787: LD_VAR 0 2
69791: ARRAY
69792: PPUSH
69793: LD_INT 2
69795: PUSH
69796: LD_INT 30
69798: PUSH
69799: LD_INT 0
69801: PUSH
69802: EMPTY
69803: LIST
69804: LIST
69805: PUSH
69806: LD_INT 30
69808: PUSH
69809: LD_INT 1
69811: PUSH
69812: EMPTY
69813: LIST
69814: LIST
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: LIST
69820: PPUSH
69821: CALL_OW 72
69825: ST_TO_ADDR
// if not tmp or not dep then
69826: LD_VAR 0 8
69830: NOT
69831: PUSH
69832: LD_VAR 0 9
69836: NOT
69837: OR
69838: IFFALSE 69842
// continue ;
69840: GO 69627
// side := GetSide ( tmp [ 1 ] ) ;
69842: LD_ADDR_VAR 0 11
69846: PUSH
69847: LD_VAR 0 8
69851: PUSH
69852: LD_INT 1
69854: ARRAY
69855: PPUSH
69856: CALL_OW 255
69860: ST_TO_ADDR
// dep := dep [ 1 ] ;
69861: LD_ADDR_VAR 0 9
69865: PUSH
69866: LD_VAR 0 9
69870: PUSH
69871: LD_INT 1
69873: ARRAY
69874: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
69875: LD_ADDR_VAR 0 7
69879: PUSH
69880: LD_EXP 87
69884: PUSH
69885: LD_VAR 0 2
69889: ARRAY
69890: PPUSH
69891: LD_INT 22
69893: PUSH
69894: LD_INT 0
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: LD_INT 25
69903: PUSH
69904: LD_INT 12
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: EMPTY
69912: LIST
69913: LIST
69914: PPUSH
69915: CALL_OW 70
69919: PUSH
69920: LD_INT 22
69922: PUSH
69923: LD_INT 0
69925: PUSH
69926: EMPTY
69927: LIST
69928: LIST
69929: PUSH
69930: LD_INT 25
69932: PUSH
69933: LD_INT 12
69935: PUSH
69936: EMPTY
69937: LIST
69938: LIST
69939: PUSH
69940: LD_INT 91
69942: PUSH
69943: LD_VAR 0 9
69947: PUSH
69948: LD_INT 20
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: LIST
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: LIST
69960: PPUSH
69961: CALL_OW 69
69965: UNION
69966: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
69967: LD_ADDR_VAR 0 10
69971: PUSH
69972: LD_EXP 87
69976: PUSH
69977: LD_VAR 0 2
69981: ARRAY
69982: PPUSH
69983: LD_INT 81
69985: PUSH
69986: LD_VAR 0 11
69990: PUSH
69991: EMPTY
69992: LIST
69993: LIST
69994: PPUSH
69995: CALL_OW 70
69999: ST_TO_ADDR
// if not apes or danger_at_area then
70000: LD_VAR 0 7
70004: NOT
70005: PUSH
70006: LD_VAR 0 10
70010: OR
70011: IFFALSE 70061
// begin if mc_taming [ i ] then
70013: LD_EXP 90
70017: PUSH
70018: LD_VAR 0 2
70022: ARRAY
70023: IFFALSE 70059
// begin MC_Reset ( i , 121 ) ;
70025: LD_VAR 0 2
70029: PPUSH
70030: LD_INT 121
70032: PPUSH
70033: CALL 55464 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70037: LD_ADDR_EXP 90
70041: PUSH
70042: LD_EXP 90
70046: PPUSH
70047: LD_VAR 0 2
70051: PPUSH
70052: EMPTY
70053: PPUSH
70054: CALL_OW 1
70058: ST_TO_ADDR
// end ; continue ;
70059: GO 69627
// end ; for j in tmp do
70061: LD_ADDR_VAR 0 3
70065: PUSH
70066: LD_VAR 0 8
70070: PUSH
70071: FOR_IN
70072: IFFALSE 70408
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70074: LD_VAR 0 3
70078: PUSH
70079: LD_EXP 90
70083: PUSH
70084: LD_VAR 0 2
70088: ARRAY
70089: IN
70090: NOT
70091: PUSH
70092: LD_EXP 90
70096: PUSH
70097: LD_VAR 0 2
70101: ARRAY
70102: PUSH
70103: LD_INT 3
70105: LESS
70106: AND
70107: IFFALSE 70165
// begin SetTag ( j , 121 ) ;
70109: LD_VAR 0 3
70113: PPUSH
70114: LD_INT 121
70116: PPUSH
70117: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70121: LD_ADDR_EXP 90
70125: PUSH
70126: LD_EXP 90
70130: PPUSH
70131: LD_VAR 0 2
70135: PUSH
70136: LD_EXP 90
70140: PUSH
70141: LD_VAR 0 2
70145: ARRAY
70146: PUSH
70147: LD_INT 1
70149: PLUS
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: PPUSH
70155: LD_VAR 0 3
70159: PPUSH
70160: CALL 19263 0 3
70164: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70165: LD_VAR 0 3
70169: PUSH
70170: LD_EXP 90
70174: PUSH
70175: LD_VAR 0 2
70179: ARRAY
70180: IN
70181: IFFALSE 70406
// begin if GetClass ( j ) <> 4 then
70183: LD_VAR 0 3
70187: PPUSH
70188: CALL_OW 257
70192: PUSH
70193: LD_INT 4
70195: NONEQUAL
70196: IFFALSE 70249
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70198: LD_ADDR_EXP 90
70202: PUSH
70203: LD_EXP 90
70207: PPUSH
70208: LD_VAR 0 2
70212: PPUSH
70213: LD_EXP 90
70217: PUSH
70218: LD_VAR 0 2
70222: ARRAY
70223: PUSH
70224: LD_VAR 0 3
70228: DIFF
70229: PPUSH
70230: CALL_OW 1
70234: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70235: LD_VAR 0 3
70239: PPUSH
70240: LD_INT 0
70242: PPUSH
70243: CALL_OW 109
// continue ;
70247: GO 70071
// end ; if IsInUnit ( j ) then
70249: LD_VAR 0 3
70253: PPUSH
70254: CALL_OW 310
70258: IFFALSE 70269
// ComExitBuilding ( j ) ;
70260: LD_VAR 0 3
70264: PPUSH
70265: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70269: LD_ADDR_VAR 0 6
70273: PUSH
70274: LD_VAR 0 7
70278: PPUSH
70279: LD_VAR 0 3
70283: PPUSH
70284: CALL_OW 74
70288: ST_TO_ADDR
// if not ape then
70289: LD_VAR 0 6
70293: NOT
70294: IFFALSE 70298
// break ;
70296: GO 70408
// x := GetX ( ape ) ;
70298: LD_ADDR_VAR 0 4
70302: PUSH
70303: LD_VAR 0 6
70307: PPUSH
70308: CALL_OW 250
70312: ST_TO_ADDR
// y := GetY ( ape ) ;
70313: LD_ADDR_VAR 0 5
70317: PUSH
70318: LD_VAR 0 6
70322: PPUSH
70323: CALL_OW 251
70327: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70328: LD_VAR 0 4
70332: PPUSH
70333: LD_VAR 0 5
70337: PPUSH
70338: CALL_OW 488
70342: NOT
70343: PUSH
70344: LD_VAR 0 11
70348: PPUSH
70349: LD_VAR 0 4
70353: PPUSH
70354: LD_VAR 0 5
70358: PPUSH
70359: LD_INT 20
70361: PPUSH
70362: CALL 20159 0 4
70366: PUSH
70367: LD_INT 4
70369: ARRAY
70370: OR
70371: IFFALSE 70375
// break ;
70373: GO 70408
// if not HasTask ( j ) then
70375: LD_VAR 0 3
70379: PPUSH
70380: CALL_OW 314
70384: NOT
70385: IFFALSE 70406
// ComTameXY ( j , x , y ) ;
70387: LD_VAR 0 3
70391: PPUSH
70392: LD_VAR 0 4
70396: PPUSH
70397: LD_VAR 0 5
70401: PPUSH
70402: CALL_OW 131
// end ; end ;
70406: GO 70071
70408: POP
70409: POP
// end ;
70410: GO 69627
70412: POP
70413: POP
// end ;
70414: LD_VAR 0 1
70418: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70419: LD_INT 0
70421: PPUSH
70422: PPUSH
70423: PPUSH
70424: PPUSH
70425: PPUSH
70426: PPUSH
70427: PPUSH
70428: PPUSH
// if not mc_bases then
70429: LD_EXP 59
70433: NOT
70434: IFFALSE 70438
// exit ;
70436: GO 71064
// for i = 1 to mc_bases do
70438: LD_ADDR_VAR 0 2
70442: PUSH
70443: DOUBLE
70444: LD_INT 1
70446: DEC
70447: ST_TO_ADDR
70448: LD_EXP 59
70452: PUSH
70453: FOR_TO
70454: IFFALSE 71062
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70456: LD_EXP 88
70460: PUSH
70461: LD_VAR 0 2
70465: ARRAY
70466: NOT
70467: PUSH
70468: LD_EXP 88
70472: PUSH
70473: LD_VAR 0 2
70477: ARRAY
70478: PPUSH
70479: LD_INT 25
70481: PUSH
70482: LD_INT 12
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PPUSH
70489: CALL_OW 72
70493: NOT
70494: OR
70495: IFFALSE 70499
// continue ;
70497: GO 70453
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70499: LD_ADDR_VAR 0 5
70503: PUSH
70504: LD_EXP 88
70508: PUSH
70509: LD_VAR 0 2
70513: ARRAY
70514: PUSH
70515: LD_INT 1
70517: ARRAY
70518: PPUSH
70519: CALL_OW 255
70523: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70524: LD_VAR 0 5
70528: PPUSH
70529: LD_INT 2
70531: PPUSH
70532: CALL_OW 325
70536: IFFALSE 70789
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70538: LD_ADDR_VAR 0 4
70542: PUSH
70543: LD_EXP 88
70547: PUSH
70548: LD_VAR 0 2
70552: ARRAY
70553: PPUSH
70554: LD_INT 25
70556: PUSH
70557: LD_INT 16
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PPUSH
70564: CALL_OW 72
70568: ST_TO_ADDR
// if tmp < 6 then
70569: LD_VAR 0 4
70573: PUSH
70574: LD_INT 6
70576: LESS
70577: IFFALSE 70789
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70579: LD_ADDR_VAR 0 6
70583: PUSH
70584: LD_EXP 59
70588: PUSH
70589: LD_VAR 0 2
70593: ARRAY
70594: PPUSH
70595: LD_INT 2
70597: PUSH
70598: LD_INT 30
70600: PUSH
70601: LD_INT 0
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 30
70610: PUSH
70611: LD_INT 1
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: LIST
70622: PPUSH
70623: CALL_OW 72
70627: ST_TO_ADDR
// if depot then
70628: LD_VAR 0 6
70632: IFFALSE 70789
// begin selected := 0 ;
70634: LD_ADDR_VAR 0 7
70638: PUSH
70639: LD_INT 0
70641: ST_TO_ADDR
// for j in depot do
70642: LD_ADDR_VAR 0 3
70646: PUSH
70647: LD_VAR 0 6
70651: PUSH
70652: FOR_IN
70653: IFFALSE 70684
// begin if UnitsInside ( j ) < 6 then
70655: LD_VAR 0 3
70659: PPUSH
70660: CALL_OW 313
70664: PUSH
70665: LD_INT 6
70667: LESS
70668: IFFALSE 70682
// begin selected := j ;
70670: LD_ADDR_VAR 0 7
70674: PUSH
70675: LD_VAR 0 3
70679: ST_TO_ADDR
// break ;
70680: GO 70684
// end ; end ;
70682: GO 70652
70684: POP
70685: POP
// if selected then
70686: LD_VAR 0 7
70690: IFFALSE 70789
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70692: LD_ADDR_VAR 0 3
70696: PUSH
70697: LD_EXP 88
70701: PUSH
70702: LD_VAR 0 2
70706: ARRAY
70707: PPUSH
70708: LD_INT 25
70710: PUSH
70711: LD_INT 12
70713: PUSH
70714: EMPTY
70715: LIST
70716: LIST
70717: PPUSH
70718: CALL_OW 72
70722: PUSH
70723: FOR_IN
70724: IFFALSE 70787
// if not HasTask ( j ) then
70726: LD_VAR 0 3
70730: PPUSH
70731: CALL_OW 314
70735: NOT
70736: IFFALSE 70785
// begin if not IsInUnit ( j ) then
70738: LD_VAR 0 3
70742: PPUSH
70743: CALL_OW 310
70747: NOT
70748: IFFALSE 70764
// ComEnterUnit ( j , selected ) ;
70750: LD_VAR 0 3
70754: PPUSH
70755: LD_VAR 0 7
70759: PPUSH
70760: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
70764: LD_VAR 0 3
70768: PPUSH
70769: LD_INT 16
70771: PPUSH
70772: CALL_OW 183
// AddComExitBuilding ( j ) ;
70776: LD_VAR 0 3
70780: PPUSH
70781: CALL_OW 182
// end ;
70785: GO 70723
70787: POP
70788: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70789: LD_VAR 0 5
70793: PPUSH
70794: LD_INT 11
70796: PPUSH
70797: CALL_OW 325
70801: IFFALSE 71060
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70803: LD_ADDR_VAR 0 4
70807: PUSH
70808: LD_EXP 88
70812: PUSH
70813: LD_VAR 0 2
70817: ARRAY
70818: PPUSH
70819: LD_INT 25
70821: PUSH
70822: LD_INT 16
70824: PUSH
70825: EMPTY
70826: LIST
70827: LIST
70828: PPUSH
70829: CALL_OW 72
70833: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
70834: LD_VAR 0 4
70838: PUSH
70839: LD_INT 6
70841: GREATEREQUAL
70842: PUSH
70843: LD_VAR 0 5
70847: PPUSH
70848: LD_INT 2
70850: PPUSH
70851: CALL_OW 325
70855: NOT
70856: OR
70857: IFFALSE 71060
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70859: LD_ADDR_VAR 0 8
70863: PUSH
70864: LD_EXP 59
70868: PUSH
70869: LD_VAR 0 2
70873: ARRAY
70874: PPUSH
70875: LD_INT 2
70877: PUSH
70878: LD_INT 30
70880: PUSH
70881: LD_INT 4
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: PUSH
70888: LD_INT 30
70890: PUSH
70891: LD_INT 5
70893: PUSH
70894: EMPTY
70895: LIST
70896: LIST
70897: PUSH
70898: EMPTY
70899: LIST
70900: LIST
70901: LIST
70902: PPUSH
70903: CALL_OW 72
70907: ST_TO_ADDR
// if barracks then
70908: LD_VAR 0 8
70912: IFFALSE 71060
// begin selected := 0 ;
70914: LD_ADDR_VAR 0 7
70918: PUSH
70919: LD_INT 0
70921: ST_TO_ADDR
// for j in barracks do
70922: LD_ADDR_VAR 0 3
70926: PUSH
70927: LD_VAR 0 8
70931: PUSH
70932: FOR_IN
70933: IFFALSE 70964
// begin if UnitsInside ( j ) < 6 then
70935: LD_VAR 0 3
70939: PPUSH
70940: CALL_OW 313
70944: PUSH
70945: LD_INT 6
70947: LESS
70948: IFFALSE 70962
// begin selected := j ;
70950: LD_ADDR_VAR 0 7
70954: PUSH
70955: LD_VAR 0 3
70959: ST_TO_ADDR
// break ;
70960: GO 70964
// end ; end ;
70962: GO 70932
70964: POP
70965: POP
// if selected then
70966: LD_VAR 0 7
70970: IFFALSE 71060
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70972: LD_ADDR_VAR 0 3
70976: PUSH
70977: LD_EXP 88
70981: PUSH
70982: LD_VAR 0 2
70986: ARRAY
70987: PPUSH
70988: LD_INT 25
70990: PUSH
70991: LD_INT 12
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: PPUSH
70998: CALL_OW 72
71002: PUSH
71003: FOR_IN
71004: IFFALSE 71058
// if not IsInUnit ( j ) and not HasTask ( j ) then
71006: LD_VAR 0 3
71010: PPUSH
71011: CALL_OW 310
71015: NOT
71016: PUSH
71017: LD_VAR 0 3
71021: PPUSH
71022: CALL_OW 314
71026: NOT
71027: AND
71028: IFFALSE 71056
// begin ComEnterUnit ( j , selected ) ;
71030: LD_VAR 0 3
71034: PPUSH
71035: LD_VAR 0 7
71039: PPUSH
71040: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71044: LD_VAR 0 3
71048: PPUSH
71049: LD_INT 15
71051: PPUSH
71052: CALL_OW 183
// end ;
71056: GO 71003
71058: POP
71059: POP
// end ; end ; end ; end ; end ;
71060: GO 70453
71062: POP
71063: POP
// end ;
71064: LD_VAR 0 1
71068: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71069: LD_INT 0
71071: PPUSH
71072: PPUSH
71073: PPUSH
71074: PPUSH
// if not mc_bases then
71075: LD_EXP 59
71079: NOT
71080: IFFALSE 71084
// exit ;
71082: GO 71262
// for i = 1 to mc_bases do
71084: LD_ADDR_VAR 0 2
71088: PUSH
71089: DOUBLE
71090: LD_INT 1
71092: DEC
71093: ST_TO_ADDR
71094: LD_EXP 59
71098: PUSH
71099: FOR_TO
71100: IFFALSE 71260
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71102: LD_ADDR_VAR 0 4
71106: PUSH
71107: LD_EXP 59
71111: PUSH
71112: LD_VAR 0 2
71116: ARRAY
71117: PPUSH
71118: LD_INT 25
71120: PUSH
71121: LD_INT 9
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PPUSH
71128: CALL_OW 72
71132: ST_TO_ADDR
// if not tmp then
71133: LD_VAR 0 4
71137: NOT
71138: IFFALSE 71142
// continue ;
71140: GO 71099
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71142: LD_EXP 85
71146: PUSH
71147: LD_VAR 0 2
71151: ARRAY
71152: PPUSH
71153: LD_INT 29
71155: PPUSH
71156: CALL_OW 325
71160: NOT
71161: PUSH
71162: LD_EXP 85
71166: PUSH
71167: LD_VAR 0 2
71171: ARRAY
71172: PPUSH
71173: LD_INT 28
71175: PPUSH
71176: CALL_OW 325
71180: NOT
71181: AND
71182: IFFALSE 71186
// continue ;
71184: GO 71099
// for j in tmp do
71186: LD_ADDR_VAR 0 3
71190: PUSH
71191: LD_VAR 0 4
71195: PUSH
71196: FOR_IN
71197: IFFALSE 71256
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71199: LD_VAR 0 3
71203: PUSH
71204: LD_EXP 62
71208: PUSH
71209: LD_VAR 0 2
71213: ARRAY
71214: PUSH
71215: LD_INT 1
71217: ARRAY
71218: IN
71219: NOT
71220: PUSH
71221: LD_VAR 0 3
71225: PUSH
71226: LD_EXP 62
71230: PUSH
71231: LD_VAR 0 2
71235: ARRAY
71236: PUSH
71237: LD_INT 2
71239: ARRAY
71240: IN
71241: NOT
71242: AND
71243: IFFALSE 71254
// ComSpaceTimeShoot ( j ) ;
71245: LD_VAR 0 3
71249: PPUSH
71250: CALL 15260 0 1
71254: GO 71196
71256: POP
71257: POP
// end ;
71258: GO 71099
71260: POP
71261: POP
// end ;
71262: LD_VAR 0 1
71266: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71267: LD_INT 0
71269: PPUSH
71270: PPUSH
71271: PPUSH
71272: PPUSH
71273: PPUSH
71274: PPUSH
71275: PPUSH
71276: PPUSH
71277: PPUSH
// if not mc_bases then
71278: LD_EXP 59
71282: NOT
71283: IFFALSE 71287
// exit ;
71285: GO 71909
// for i = 1 to mc_bases do
71287: LD_ADDR_VAR 0 2
71291: PUSH
71292: DOUBLE
71293: LD_INT 1
71295: DEC
71296: ST_TO_ADDR
71297: LD_EXP 59
71301: PUSH
71302: FOR_TO
71303: IFFALSE 71907
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71305: LD_EXP 94
71309: PUSH
71310: LD_VAR 0 2
71314: ARRAY
71315: NOT
71316: PUSH
71317: LD_INT 38
71319: PPUSH
71320: LD_EXP 85
71324: PUSH
71325: LD_VAR 0 2
71329: ARRAY
71330: PPUSH
71331: CALL_OW 321
71335: PUSH
71336: LD_INT 2
71338: NONEQUAL
71339: OR
71340: IFFALSE 71344
// continue ;
71342: GO 71302
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71344: LD_ADDR_VAR 0 8
71348: PUSH
71349: LD_EXP 59
71353: PUSH
71354: LD_VAR 0 2
71358: ARRAY
71359: PPUSH
71360: LD_INT 30
71362: PUSH
71363: LD_INT 34
71365: PUSH
71366: EMPTY
71367: LIST
71368: LIST
71369: PPUSH
71370: CALL_OW 72
71374: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71375: LD_ADDR_VAR 0 9
71379: PUSH
71380: LD_EXP 59
71384: PUSH
71385: LD_VAR 0 2
71389: ARRAY
71390: PPUSH
71391: LD_INT 25
71393: PUSH
71394: LD_INT 4
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: PPUSH
71401: CALL_OW 72
71405: PPUSH
71406: LD_INT 0
71408: PPUSH
71409: CALL 47824 0 2
71413: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71414: LD_VAR 0 9
71418: NOT
71419: PUSH
71420: LD_VAR 0 8
71424: NOT
71425: OR
71426: PUSH
71427: LD_EXP 59
71431: PUSH
71432: LD_VAR 0 2
71436: ARRAY
71437: PPUSH
71438: LD_INT 124
71440: PPUSH
71441: CALL 47824 0 2
71445: OR
71446: IFFALSE 71450
// continue ;
71448: GO 71302
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71450: LD_EXP 95
71454: PUSH
71455: LD_VAR 0 2
71459: ARRAY
71460: PUSH
71461: LD_EXP 94
71465: PUSH
71466: LD_VAR 0 2
71470: ARRAY
71471: LESS
71472: PUSH
71473: LD_EXP 95
71477: PUSH
71478: LD_VAR 0 2
71482: ARRAY
71483: PUSH
71484: LD_VAR 0 8
71488: LESS
71489: AND
71490: IFFALSE 71905
// begin tmp := sci [ 1 ] ;
71492: LD_ADDR_VAR 0 7
71496: PUSH
71497: LD_VAR 0 9
71501: PUSH
71502: LD_INT 1
71504: ARRAY
71505: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71506: LD_VAR 0 7
71510: PPUSH
71511: LD_INT 124
71513: PPUSH
71514: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71518: LD_ADDR_VAR 0 3
71522: PUSH
71523: DOUBLE
71524: LD_EXP 94
71528: PUSH
71529: LD_VAR 0 2
71533: ARRAY
71534: INC
71535: ST_TO_ADDR
71536: LD_EXP 94
71540: PUSH
71541: LD_VAR 0 2
71545: ARRAY
71546: PUSH
71547: FOR_DOWNTO
71548: IFFALSE 71891
// begin if IsInUnit ( tmp ) then
71550: LD_VAR 0 7
71554: PPUSH
71555: CALL_OW 310
71559: IFFALSE 71570
// ComExitBuilding ( tmp ) ;
71561: LD_VAR 0 7
71565: PPUSH
71566: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
71570: LD_INT 35
71572: PPUSH
71573: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71577: LD_VAR 0 7
71581: PPUSH
71582: CALL_OW 310
71586: NOT
71587: PUSH
71588: LD_VAR 0 7
71592: PPUSH
71593: CALL_OW 314
71597: NOT
71598: AND
71599: IFFALSE 71570
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
71601: LD_ADDR_VAR 0 6
71605: PUSH
71606: LD_VAR 0 7
71610: PPUSH
71611: CALL_OW 250
71615: PUSH
71616: LD_VAR 0 7
71620: PPUSH
71621: CALL_OW 251
71625: PUSH
71626: EMPTY
71627: LIST
71628: LIST
71629: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71630: LD_INT 35
71632: PPUSH
71633: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
71637: LD_ADDR_VAR 0 4
71641: PUSH
71642: LD_EXP 94
71646: PUSH
71647: LD_VAR 0 2
71651: ARRAY
71652: PUSH
71653: LD_VAR 0 3
71657: ARRAY
71658: PUSH
71659: LD_INT 1
71661: ARRAY
71662: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
71663: LD_ADDR_VAR 0 5
71667: PUSH
71668: LD_EXP 94
71672: PUSH
71673: LD_VAR 0 2
71677: ARRAY
71678: PUSH
71679: LD_VAR 0 3
71683: ARRAY
71684: PUSH
71685: LD_INT 2
71687: ARRAY
71688: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
71689: LD_VAR 0 7
71693: PPUSH
71694: LD_INT 10
71696: PPUSH
71697: CALL 21856 0 2
71701: PUSH
71702: LD_INT 4
71704: ARRAY
71705: IFFALSE 71743
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
71707: LD_VAR 0 7
71711: PPUSH
71712: LD_VAR 0 6
71716: PUSH
71717: LD_INT 1
71719: ARRAY
71720: PPUSH
71721: LD_VAR 0 6
71725: PUSH
71726: LD_INT 2
71728: ARRAY
71729: PPUSH
71730: CALL_OW 111
// wait ( 0 0$10 ) ;
71734: LD_INT 350
71736: PPUSH
71737: CALL_OW 67
// end else
71741: GO 71769
// begin ComMoveXY ( tmp , x , y ) ;
71743: LD_VAR 0 7
71747: PPUSH
71748: LD_VAR 0 4
71752: PPUSH
71753: LD_VAR 0 5
71757: PPUSH
71758: CALL_OW 111
// wait ( 0 0$3 ) ;
71762: LD_INT 105
71764: PPUSH
71765: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
71769: LD_VAR 0 7
71773: PPUSH
71774: LD_VAR 0 4
71778: PPUSH
71779: LD_VAR 0 5
71783: PPUSH
71784: CALL_OW 307
71788: IFFALSE 71630
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71790: LD_VAR 0 7
71794: PPUSH
71795: LD_VAR 0 4
71799: PPUSH
71800: LD_VAR 0 5
71804: PPUSH
71805: LD_VAR 0 8
71809: PUSH
71810: LD_VAR 0 3
71814: ARRAY
71815: PPUSH
71816: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
71820: LD_INT 35
71822: PPUSH
71823: CALL_OW 67
// until not HasTask ( tmp ) ;
71827: LD_VAR 0 7
71831: PPUSH
71832: CALL_OW 314
71836: NOT
71837: IFFALSE 71820
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
71839: LD_ADDR_EXP 95
71843: PUSH
71844: LD_EXP 95
71848: PPUSH
71849: LD_VAR 0 2
71853: PUSH
71854: LD_EXP 95
71858: PUSH
71859: LD_VAR 0 2
71863: ARRAY
71864: PUSH
71865: LD_INT 1
71867: PLUS
71868: PUSH
71869: EMPTY
71870: LIST
71871: LIST
71872: PPUSH
71873: LD_VAR 0 8
71877: PUSH
71878: LD_VAR 0 3
71882: ARRAY
71883: PPUSH
71884: CALL 19263 0 3
71888: ST_TO_ADDR
// end ;
71889: GO 71547
71891: POP
71892: POP
// MC_Reset ( i , 124 ) ;
71893: LD_VAR 0 2
71897: PPUSH
71898: LD_INT 124
71900: PPUSH
71901: CALL 55464 0 2
// end ; end ;
71905: GO 71302
71907: POP
71908: POP
// end ;
71909: LD_VAR 0 1
71913: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
71914: LD_INT 0
71916: PPUSH
71917: PPUSH
71918: PPUSH
// if not mc_bases then
71919: LD_EXP 59
71923: NOT
71924: IFFALSE 71928
// exit ;
71926: GO 72534
// for i = 1 to mc_bases do
71928: LD_ADDR_VAR 0 2
71932: PUSH
71933: DOUBLE
71934: LD_INT 1
71936: DEC
71937: ST_TO_ADDR
71938: LD_EXP 59
71942: PUSH
71943: FOR_TO
71944: IFFALSE 72532
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71946: LD_ADDR_VAR 0 3
71950: PUSH
71951: LD_EXP 59
71955: PUSH
71956: LD_VAR 0 2
71960: ARRAY
71961: PPUSH
71962: LD_INT 25
71964: PUSH
71965: LD_INT 4
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: PPUSH
71972: CALL_OW 72
71976: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71977: LD_VAR 0 3
71981: NOT
71982: PUSH
71983: LD_EXP 96
71987: PUSH
71988: LD_VAR 0 2
71992: ARRAY
71993: NOT
71994: OR
71995: PUSH
71996: LD_EXP 59
72000: PUSH
72001: LD_VAR 0 2
72005: ARRAY
72006: PPUSH
72007: LD_INT 2
72009: PUSH
72010: LD_INT 30
72012: PUSH
72013: LD_INT 0
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: LD_INT 30
72022: PUSH
72023: LD_INT 1
72025: PUSH
72026: EMPTY
72027: LIST
72028: LIST
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: LIST
72034: PPUSH
72035: CALL_OW 72
72039: NOT
72040: OR
72041: IFFALSE 72091
// begin if mc_deposits_finder [ i ] then
72043: LD_EXP 97
72047: PUSH
72048: LD_VAR 0 2
72052: ARRAY
72053: IFFALSE 72089
// begin MC_Reset ( i , 125 ) ;
72055: LD_VAR 0 2
72059: PPUSH
72060: LD_INT 125
72062: PPUSH
72063: CALL 55464 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72067: LD_ADDR_EXP 97
72071: PUSH
72072: LD_EXP 97
72076: PPUSH
72077: LD_VAR 0 2
72081: PPUSH
72082: EMPTY
72083: PPUSH
72084: CALL_OW 1
72088: ST_TO_ADDR
// end ; continue ;
72089: GO 71943
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72091: LD_EXP 96
72095: PUSH
72096: LD_VAR 0 2
72100: ARRAY
72101: PUSH
72102: LD_INT 1
72104: ARRAY
72105: PUSH
72106: LD_INT 3
72108: ARRAY
72109: PUSH
72110: LD_INT 1
72112: EQUAL
72113: PUSH
72114: LD_INT 20
72116: PPUSH
72117: LD_EXP 85
72121: PUSH
72122: LD_VAR 0 2
72126: ARRAY
72127: PPUSH
72128: CALL_OW 321
72132: PUSH
72133: LD_INT 2
72135: NONEQUAL
72136: AND
72137: IFFALSE 72187
// begin if mc_deposits_finder [ i ] then
72139: LD_EXP 97
72143: PUSH
72144: LD_VAR 0 2
72148: ARRAY
72149: IFFALSE 72185
// begin MC_Reset ( i , 125 ) ;
72151: LD_VAR 0 2
72155: PPUSH
72156: LD_INT 125
72158: PPUSH
72159: CALL 55464 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72163: LD_ADDR_EXP 97
72167: PUSH
72168: LD_EXP 97
72172: PPUSH
72173: LD_VAR 0 2
72177: PPUSH
72178: EMPTY
72179: PPUSH
72180: CALL_OW 1
72184: ST_TO_ADDR
// end ; continue ;
72185: GO 71943
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72187: LD_EXP 96
72191: PUSH
72192: LD_VAR 0 2
72196: ARRAY
72197: PUSH
72198: LD_INT 1
72200: ARRAY
72201: PUSH
72202: LD_INT 1
72204: ARRAY
72205: PPUSH
72206: LD_EXP 96
72210: PUSH
72211: LD_VAR 0 2
72215: ARRAY
72216: PUSH
72217: LD_INT 1
72219: ARRAY
72220: PUSH
72221: LD_INT 2
72223: ARRAY
72224: PPUSH
72225: LD_EXP 85
72229: PUSH
72230: LD_VAR 0 2
72234: ARRAY
72235: PPUSH
72236: CALL_OW 440
72240: IFFALSE 72283
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72242: LD_ADDR_EXP 96
72246: PUSH
72247: LD_EXP 96
72251: PPUSH
72252: LD_VAR 0 2
72256: PPUSH
72257: LD_EXP 96
72261: PUSH
72262: LD_VAR 0 2
72266: ARRAY
72267: PPUSH
72268: LD_INT 1
72270: PPUSH
72271: CALL_OW 3
72275: PPUSH
72276: CALL_OW 1
72280: ST_TO_ADDR
72281: GO 72530
// begin if not mc_deposits_finder [ i ] then
72283: LD_EXP 97
72287: PUSH
72288: LD_VAR 0 2
72292: ARRAY
72293: NOT
72294: IFFALSE 72346
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72296: LD_ADDR_EXP 97
72300: PUSH
72301: LD_EXP 97
72305: PPUSH
72306: LD_VAR 0 2
72310: PPUSH
72311: LD_VAR 0 3
72315: PUSH
72316: LD_INT 1
72318: ARRAY
72319: PUSH
72320: EMPTY
72321: LIST
72322: PPUSH
72323: CALL_OW 1
72327: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72328: LD_VAR 0 3
72332: PUSH
72333: LD_INT 1
72335: ARRAY
72336: PPUSH
72337: LD_INT 125
72339: PPUSH
72340: CALL_OW 109
// end else
72344: GO 72530
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72346: LD_EXP 97
72350: PUSH
72351: LD_VAR 0 2
72355: ARRAY
72356: PUSH
72357: LD_INT 1
72359: ARRAY
72360: PPUSH
72361: CALL_OW 310
72365: IFFALSE 72388
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72367: LD_EXP 97
72371: PUSH
72372: LD_VAR 0 2
72376: ARRAY
72377: PUSH
72378: LD_INT 1
72380: ARRAY
72381: PPUSH
72382: CALL_OW 122
72386: GO 72530
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72388: LD_EXP 97
72392: PUSH
72393: LD_VAR 0 2
72397: ARRAY
72398: PUSH
72399: LD_INT 1
72401: ARRAY
72402: PPUSH
72403: CALL_OW 314
72407: NOT
72408: PUSH
72409: LD_EXP 97
72413: PUSH
72414: LD_VAR 0 2
72418: ARRAY
72419: PUSH
72420: LD_INT 1
72422: ARRAY
72423: PPUSH
72424: LD_EXP 96
72428: PUSH
72429: LD_VAR 0 2
72433: ARRAY
72434: PUSH
72435: LD_INT 1
72437: ARRAY
72438: PUSH
72439: LD_INT 1
72441: ARRAY
72442: PPUSH
72443: LD_EXP 96
72447: PUSH
72448: LD_VAR 0 2
72452: ARRAY
72453: PUSH
72454: LD_INT 1
72456: ARRAY
72457: PUSH
72458: LD_INT 2
72460: ARRAY
72461: PPUSH
72462: CALL_OW 297
72466: PUSH
72467: LD_INT 6
72469: GREATER
72470: AND
72471: IFFALSE 72530
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72473: LD_EXP 97
72477: PUSH
72478: LD_VAR 0 2
72482: ARRAY
72483: PUSH
72484: LD_INT 1
72486: ARRAY
72487: PPUSH
72488: LD_EXP 96
72492: PUSH
72493: LD_VAR 0 2
72497: ARRAY
72498: PUSH
72499: LD_INT 1
72501: ARRAY
72502: PUSH
72503: LD_INT 1
72505: ARRAY
72506: PPUSH
72507: LD_EXP 96
72511: PUSH
72512: LD_VAR 0 2
72516: ARRAY
72517: PUSH
72518: LD_INT 1
72520: ARRAY
72521: PUSH
72522: LD_INT 2
72524: ARRAY
72525: PPUSH
72526: CALL_OW 111
// end ; end ; end ;
72530: GO 71943
72532: POP
72533: POP
// end ;
72534: LD_VAR 0 1
72538: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72539: LD_INT 0
72541: PPUSH
72542: PPUSH
72543: PPUSH
72544: PPUSH
72545: PPUSH
72546: PPUSH
72547: PPUSH
72548: PPUSH
72549: PPUSH
72550: PPUSH
72551: PPUSH
// if not mc_bases then
72552: LD_EXP 59
72556: NOT
72557: IFFALSE 72561
// exit ;
72559: GO 73501
// for i = 1 to mc_bases do
72561: LD_ADDR_VAR 0 2
72565: PUSH
72566: DOUBLE
72567: LD_INT 1
72569: DEC
72570: ST_TO_ADDR
72571: LD_EXP 59
72575: PUSH
72576: FOR_TO
72577: IFFALSE 73499
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72579: LD_EXP 59
72583: PUSH
72584: LD_VAR 0 2
72588: ARRAY
72589: NOT
72590: PUSH
72591: LD_EXP 82
72595: PUSH
72596: LD_VAR 0 2
72600: ARRAY
72601: OR
72602: IFFALSE 72606
// continue ;
72604: GO 72576
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
72606: LD_ADDR_VAR 0 7
72610: PUSH
72611: LD_EXP 59
72615: PUSH
72616: LD_VAR 0 2
72620: ARRAY
72621: PUSH
72622: LD_INT 1
72624: ARRAY
72625: PPUSH
72626: CALL_OW 248
72630: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
72631: LD_VAR 0 7
72635: PUSH
72636: LD_INT 3
72638: EQUAL
72639: PUSH
72640: LD_EXP 78
72644: PUSH
72645: LD_VAR 0 2
72649: ARRAY
72650: PUSH
72651: LD_EXP 81
72655: PUSH
72656: LD_VAR 0 2
72660: ARRAY
72661: UNION
72662: PPUSH
72663: LD_INT 33
72665: PUSH
72666: LD_INT 2
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PPUSH
72673: CALL_OW 72
72677: NOT
72678: OR
72679: IFFALSE 72683
// continue ;
72681: GO 72576
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
72683: LD_ADDR_VAR 0 9
72687: PUSH
72688: LD_EXP 59
72692: PUSH
72693: LD_VAR 0 2
72697: ARRAY
72698: PPUSH
72699: LD_INT 30
72701: PUSH
72702: LD_INT 36
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PPUSH
72709: CALL_OW 72
72713: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
72714: LD_ADDR_VAR 0 10
72718: PUSH
72719: LD_EXP 78
72723: PUSH
72724: LD_VAR 0 2
72728: ARRAY
72729: PPUSH
72730: LD_INT 34
72732: PUSH
72733: LD_INT 31
72735: PUSH
72736: EMPTY
72737: LIST
72738: LIST
72739: PPUSH
72740: CALL_OW 72
72744: ST_TO_ADDR
// if not cts and not mcts then
72745: LD_VAR 0 9
72749: NOT
72750: PUSH
72751: LD_VAR 0 10
72755: NOT
72756: AND
72757: IFFALSE 72761
// continue ;
72759: GO 72576
// x := cts ;
72761: LD_ADDR_VAR 0 11
72765: PUSH
72766: LD_VAR 0 9
72770: ST_TO_ADDR
// if not x then
72771: LD_VAR 0 11
72775: NOT
72776: IFFALSE 72788
// x := mcts ;
72778: LD_ADDR_VAR 0 11
72782: PUSH
72783: LD_VAR 0 10
72787: ST_TO_ADDR
// if not x then
72788: LD_VAR 0 11
72792: NOT
72793: IFFALSE 72797
// continue ;
72795: GO 72576
// if mc_remote_driver [ i ] then
72797: LD_EXP 99
72801: PUSH
72802: LD_VAR 0 2
72806: ARRAY
72807: IFFALSE 73194
// for j in mc_remote_driver [ i ] do
72809: LD_ADDR_VAR 0 3
72813: PUSH
72814: LD_EXP 99
72818: PUSH
72819: LD_VAR 0 2
72823: ARRAY
72824: PUSH
72825: FOR_IN
72826: IFFALSE 73192
// begin if GetClass ( j ) <> 3 then
72828: LD_VAR 0 3
72832: PPUSH
72833: CALL_OW 257
72837: PUSH
72838: LD_INT 3
72840: NONEQUAL
72841: IFFALSE 72894
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
72843: LD_ADDR_EXP 99
72847: PUSH
72848: LD_EXP 99
72852: PPUSH
72853: LD_VAR 0 2
72857: PPUSH
72858: LD_EXP 99
72862: PUSH
72863: LD_VAR 0 2
72867: ARRAY
72868: PUSH
72869: LD_VAR 0 3
72873: DIFF
72874: PPUSH
72875: CALL_OW 1
72879: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72880: LD_VAR 0 3
72884: PPUSH
72885: LD_INT 0
72887: PPUSH
72888: CALL_OW 109
// continue ;
72892: GO 72825
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
72894: LD_EXP 78
72898: PUSH
72899: LD_VAR 0 2
72903: ARRAY
72904: PPUSH
72905: LD_INT 34
72907: PUSH
72908: LD_INT 31
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 58
72917: PUSH
72918: EMPTY
72919: LIST
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PPUSH
72925: CALL_OW 72
72929: PUSH
72930: LD_VAR 0 3
72934: PPUSH
72935: CALL 47912 0 1
72939: NOT
72940: AND
72941: IFFALSE 73012
// begin if IsInUnit ( j ) then
72943: LD_VAR 0 3
72947: PPUSH
72948: CALL_OW 310
72952: IFFALSE 72963
// ComExitBuilding ( j ) ;
72954: LD_VAR 0 3
72958: PPUSH
72959: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
72963: LD_VAR 0 3
72967: PPUSH
72968: LD_EXP 78
72972: PUSH
72973: LD_VAR 0 2
72977: ARRAY
72978: PPUSH
72979: LD_INT 34
72981: PUSH
72982: LD_INT 31
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: LD_INT 58
72991: PUSH
72992: EMPTY
72993: LIST
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: PPUSH
72999: CALL_OW 72
73003: PUSH
73004: LD_INT 1
73006: ARRAY
73007: PPUSH
73008: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73012: LD_VAR 0 3
73016: PPUSH
73017: CALL_OW 310
73021: NOT
73022: PUSH
73023: LD_VAR 0 3
73027: PPUSH
73028: CALL_OW 310
73032: PPUSH
73033: CALL_OW 266
73037: PUSH
73038: LD_INT 36
73040: NONEQUAL
73041: PUSH
73042: LD_VAR 0 3
73046: PPUSH
73047: CALL 47912 0 1
73051: NOT
73052: AND
73053: OR
73054: IFFALSE 73190
// begin if IsInUnit ( j ) then
73056: LD_VAR 0 3
73060: PPUSH
73061: CALL_OW 310
73065: IFFALSE 73076
// ComExitBuilding ( j ) ;
73067: LD_VAR 0 3
73071: PPUSH
73072: CALL_OW 122
// ct := 0 ;
73076: LD_ADDR_VAR 0 8
73080: PUSH
73081: LD_INT 0
73083: ST_TO_ADDR
// for k in x do
73084: LD_ADDR_VAR 0 4
73088: PUSH
73089: LD_VAR 0 11
73093: PUSH
73094: FOR_IN
73095: IFFALSE 73168
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73097: LD_VAR 0 4
73101: PPUSH
73102: CALL_OW 264
73106: PUSH
73107: LD_INT 31
73109: EQUAL
73110: PUSH
73111: LD_VAR 0 4
73115: PPUSH
73116: CALL_OW 311
73120: NOT
73121: AND
73122: PUSH
73123: LD_VAR 0 4
73127: PPUSH
73128: CALL_OW 266
73132: PUSH
73133: LD_INT 36
73135: EQUAL
73136: PUSH
73137: LD_VAR 0 4
73141: PPUSH
73142: CALL_OW 313
73146: PUSH
73147: LD_INT 3
73149: LESS
73150: AND
73151: OR
73152: IFFALSE 73166
// begin ct := k ;
73154: LD_ADDR_VAR 0 8
73158: PUSH
73159: LD_VAR 0 4
73163: ST_TO_ADDR
// break ;
73164: GO 73168
// end ;
73166: GO 73094
73168: POP
73169: POP
// if ct then
73170: LD_VAR 0 8
73174: IFFALSE 73190
// ComEnterUnit ( j , ct ) ;
73176: LD_VAR 0 3
73180: PPUSH
73181: LD_VAR 0 8
73185: PPUSH
73186: CALL_OW 120
// end ; end ;
73190: GO 72825
73192: POP
73193: POP
// places := 0 ;
73194: LD_ADDR_VAR 0 5
73198: PUSH
73199: LD_INT 0
73201: ST_TO_ADDR
// for j = 1 to x do
73202: LD_ADDR_VAR 0 3
73206: PUSH
73207: DOUBLE
73208: LD_INT 1
73210: DEC
73211: ST_TO_ADDR
73212: LD_VAR 0 11
73216: PUSH
73217: FOR_TO
73218: IFFALSE 73294
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73220: LD_VAR 0 11
73224: PUSH
73225: LD_VAR 0 3
73229: ARRAY
73230: PPUSH
73231: CALL_OW 264
73235: PUSH
73236: LD_INT 31
73238: EQUAL
73239: IFFALSE 73257
// places := places + 1 else
73241: LD_ADDR_VAR 0 5
73245: PUSH
73246: LD_VAR 0 5
73250: PUSH
73251: LD_INT 1
73253: PLUS
73254: ST_TO_ADDR
73255: GO 73292
// if GetBType ( x [ j ] ) = b_control_tower then
73257: LD_VAR 0 11
73261: PUSH
73262: LD_VAR 0 3
73266: ARRAY
73267: PPUSH
73268: CALL_OW 266
73272: PUSH
73273: LD_INT 36
73275: EQUAL
73276: IFFALSE 73292
// places := places + 3 ;
73278: LD_ADDR_VAR 0 5
73282: PUSH
73283: LD_VAR 0 5
73287: PUSH
73288: LD_INT 3
73290: PLUS
73291: ST_TO_ADDR
73292: GO 73217
73294: POP
73295: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73296: LD_VAR 0 5
73300: PUSH
73301: LD_INT 0
73303: EQUAL
73304: PUSH
73305: LD_VAR 0 5
73309: PUSH
73310: LD_EXP 99
73314: PUSH
73315: LD_VAR 0 2
73319: ARRAY
73320: LESSEQUAL
73321: OR
73322: IFFALSE 73326
// continue ;
73324: GO 72576
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73326: LD_ADDR_VAR 0 6
73330: PUSH
73331: LD_EXP 59
73335: PUSH
73336: LD_VAR 0 2
73340: ARRAY
73341: PPUSH
73342: LD_INT 25
73344: PUSH
73345: LD_INT 3
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PPUSH
73352: CALL_OW 72
73356: PUSH
73357: LD_EXP 99
73361: PUSH
73362: LD_VAR 0 2
73366: ARRAY
73367: DIFF
73368: PPUSH
73369: LD_INT 3
73371: PPUSH
73372: CALL 48812 0 2
73376: ST_TO_ADDR
// for j in tmp do
73377: LD_ADDR_VAR 0 3
73381: PUSH
73382: LD_VAR 0 6
73386: PUSH
73387: FOR_IN
73388: IFFALSE 73423
// if GetTag ( j ) > 0 then
73390: LD_VAR 0 3
73394: PPUSH
73395: CALL_OW 110
73399: PUSH
73400: LD_INT 0
73402: GREATER
73403: IFFALSE 73421
// tmp := tmp diff j ;
73405: LD_ADDR_VAR 0 6
73409: PUSH
73410: LD_VAR 0 6
73414: PUSH
73415: LD_VAR 0 3
73419: DIFF
73420: ST_TO_ADDR
73421: GO 73387
73423: POP
73424: POP
// if not tmp then
73425: LD_VAR 0 6
73429: NOT
73430: IFFALSE 73434
// continue ;
73432: GO 72576
// if places then
73434: LD_VAR 0 5
73438: IFFALSE 73497
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73440: LD_ADDR_EXP 99
73444: PUSH
73445: LD_EXP 99
73449: PPUSH
73450: LD_VAR 0 2
73454: PPUSH
73455: LD_EXP 99
73459: PUSH
73460: LD_VAR 0 2
73464: ARRAY
73465: PUSH
73466: LD_VAR 0 6
73470: PUSH
73471: LD_INT 1
73473: ARRAY
73474: UNION
73475: PPUSH
73476: CALL_OW 1
73480: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73481: LD_VAR 0 6
73485: PUSH
73486: LD_INT 1
73488: ARRAY
73489: PPUSH
73490: LD_INT 126
73492: PPUSH
73493: CALL_OW 109
// end ; end ;
73497: GO 72576
73499: POP
73500: POP
// end ;
73501: LD_VAR 0 1
73505: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73506: LD_INT 0
73508: PPUSH
73509: PPUSH
73510: PPUSH
73511: PPUSH
73512: PPUSH
73513: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73514: LD_VAR 0 1
73518: NOT
73519: PUSH
73520: LD_VAR 0 2
73524: NOT
73525: OR
73526: PUSH
73527: LD_VAR 0 3
73531: NOT
73532: OR
73533: PUSH
73534: LD_VAR 0 4
73538: PUSH
73539: LD_INT 1
73541: PUSH
73542: LD_INT 2
73544: PUSH
73545: LD_INT 3
73547: PUSH
73548: LD_INT 4
73550: PUSH
73551: LD_INT 5
73553: PUSH
73554: LD_INT 8
73556: PUSH
73557: LD_INT 9
73559: PUSH
73560: LD_INT 15
73562: PUSH
73563: LD_INT 16
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: LIST
73575: LIST
73576: IN
73577: NOT
73578: OR
73579: IFFALSE 73583
// exit ;
73581: GO 74483
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73583: LD_ADDR_VAR 0 2
73587: PUSH
73588: LD_VAR 0 2
73592: PPUSH
73593: LD_INT 21
73595: PUSH
73596: LD_INT 3
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: PUSH
73603: LD_INT 24
73605: PUSH
73606: LD_INT 250
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PPUSH
73617: CALL_OW 72
73621: ST_TO_ADDR
// case class of 1 , 15 :
73622: LD_VAR 0 4
73626: PUSH
73627: LD_INT 1
73629: DOUBLE
73630: EQUAL
73631: IFTRUE 73641
73633: LD_INT 15
73635: DOUBLE
73636: EQUAL
73637: IFTRUE 73641
73639: GO 73726
73641: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
73642: LD_ADDR_VAR 0 8
73646: PUSH
73647: LD_VAR 0 2
73651: PPUSH
73652: LD_INT 2
73654: PUSH
73655: LD_INT 30
73657: PUSH
73658: LD_INT 32
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: PUSH
73665: LD_INT 30
73667: PUSH
73668: LD_INT 31
73670: PUSH
73671: EMPTY
73672: LIST
73673: LIST
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: LIST
73679: PPUSH
73680: CALL_OW 72
73684: PUSH
73685: LD_VAR 0 2
73689: PPUSH
73690: LD_INT 2
73692: PUSH
73693: LD_INT 30
73695: PUSH
73696: LD_INT 4
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: PUSH
73703: LD_INT 30
73705: PUSH
73706: LD_INT 5
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: PUSH
73713: EMPTY
73714: LIST
73715: LIST
73716: LIST
73717: PPUSH
73718: CALL_OW 72
73722: ADD
73723: ST_TO_ADDR
73724: GO 73972
73726: LD_INT 2
73728: DOUBLE
73729: EQUAL
73730: IFTRUE 73740
73732: LD_INT 16
73734: DOUBLE
73735: EQUAL
73736: IFTRUE 73740
73738: GO 73786
73740: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
73741: LD_ADDR_VAR 0 8
73745: PUSH
73746: LD_VAR 0 2
73750: PPUSH
73751: LD_INT 2
73753: PUSH
73754: LD_INT 30
73756: PUSH
73757: LD_INT 0
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: PUSH
73764: LD_INT 30
73766: PUSH
73767: LD_INT 1
73769: PUSH
73770: EMPTY
73771: LIST
73772: LIST
73773: PUSH
73774: EMPTY
73775: LIST
73776: LIST
73777: LIST
73778: PPUSH
73779: CALL_OW 72
73783: ST_TO_ADDR
73784: GO 73972
73786: LD_INT 3
73788: DOUBLE
73789: EQUAL
73790: IFTRUE 73794
73792: GO 73840
73794: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73795: LD_ADDR_VAR 0 8
73799: PUSH
73800: LD_VAR 0 2
73804: PPUSH
73805: LD_INT 2
73807: PUSH
73808: LD_INT 30
73810: PUSH
73811: LD_INT 2
73813: PUSH
73814: EMPTY
73815: LIST
73816: LIST
73817: PUSH
73818: LD_INT 30
73820: PUSH
73821: LD_INT 3
73823: PUSH
73824: EMPTY
73825: LIST
73826: LIST
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: LIST
73832: PPUSH
73833: CALL_OW 72
73837: ST_TO_ADDR
73838: GO 73972
73840: LD_INT 4
73842: DOUBLE
73843: EQUAL
73844: IFTRUE 73848
73846: GO 73905
73848: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
73849: LD_ADDR_VAR 0 8
73853: PUSH
73854: LD_VAR 0 2
73858: PPUSH
73859: LD_INT 2
73861: PUSH
73862: LD_INT 30
73864: PUSH
73865: LD_INT 6
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PUSH
73872: LD_INT 30
73874: PUSH
73875: LD_INT 7
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 30
73884: PUSH
73885: LD_INT 8
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: EMPTY
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: PPUSH
73898: CALL_OW 72
73902: ST_TO_ADDR
73903: GO 73972
73905: LD_INT 5
73907: DOUBLE
73908: EQUAL
73909: IFTRUE 73925
73911: LD_INT 8
73913: DOUBLE
73914: EQUAL
73915: IFTRUE 73925
73917: LD_INT 9
73919: DOUBLE
73920: EQUAL
73921: IFTRUE 73925
73923: GO 73971
73925: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
73926: LD_ADDR_VAR 0 8
73930: PUSH
73931: LD_VAR 0 2
73935: PPUSH
73936: LD_INT 2
73938: PUSH
73939: LD_INT 30
73941: PUSH
73942: LD_INT 4
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: PUSH
73949: LD_INT 30
73951: PUSH
73952: LD_INT 5
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: PUSH
73959: EMPTY
73960: LIST
73961: LIST
73962: LIST
73963: PPUSH
73964: CALL_OW 72
73968: ST_TO_ADDR
73969: GO 73972
73971: POP
// if not tmp then
73972: LD_VAR 0 8
73976: NOT
73977: IFFALSE 73981
// exit ;
73979: GO 74483
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
73981: LD_VAR 0 4
73985: PUSH
73986: LD_INT 1
73988: PUSH
73989: LD_INT 15
73991: PUSH
73992: EMPTY
73993: LIST
73994: LIST
73995: IN
73996: PUSH
73997: LD_EXP 68
74001: PUSH
74002: LD_VAR 0 1
74006: ARRAY
74007: AND
74008: IFFALSE 74164
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74010: LD_ADDR_VAR 0 9
74014: PUSH
74015: LD_EXP 68
74019: PUSH
74020: LD_VAR 0 1
74024: ARRAY
74025: PUSH
74026: LD_INT 1
74028: ARRAY
74029: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74030: LD_VAR 0 9
74034: PUSH
74035: LD_EXP 69
74039: PUSH
74040: LD_VAR 0 1
74044: ARRAY
74045: IN
74046: NOT
74047: IFFALSE 74162
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74049: LD_ADDR_EXP 69
74053: PUSH
74054: LD_EXP 69
74058: PPUSH
74059: LD_VAR 0 1
74063: PUSH
74064: LD_EXP 69
74068: PUSH
74069: LD_VAR 0 1
74073: ARRAY
74074: PUSH
74075: LD_INT 1
74077: PLUS
74078: PUSH
74079: EMPTY
74080: LIST
74081: LIST
74082: PPUSH
74083: LD_VAR 0 9
74087: PPUSH
74088: CALL 19263 0 3
74092: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74093: LD_ADDR_EXP 68
74097: PUSH
74098: LD_EXP 68
74102: PPUSH
74103: LD_VAR 0 1
74107: PPUSH
74108: LD_EXP 68
74112: PUSH
74113: LD_VAR 0 1
74117: ARRAY
74118: PUSH
74119: LD_VAR 0 9
74123: DIFF
74124: PPUSH
74125: CALL_OW 1
74129: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74130: LD_VAR 0 3
74134: PPUSH
74135: LD_EXP 69
74139: PUSH
74140: LD_VAR 0 1
74144: ARRAY
74145: PUSH
74146: LD_EXP 69
74150: PUSH
74151: LD_VAR 0 1
74155: ARRAY
74156: ARRAY
74157: PPUSH
74158: CALL_OW 120
// end ; exit ;
74162: GO 74483
// end ; if tmp > 1 then
74164: LD_VAR 0 8
74168: PUSH
74169: LD_INT 1
74171: GREATER
74172: IFFALSE 74276
// for i = 2 to tmp do
74174: LD_ADDR_VAR 0 6
74178: PUSH
74179: DOUBLE
74180: LD_INT 2
74182: DEC
74183: ST_TO_ADDR
74184: LD_VAR 0 8
74188: PUSH
74189: FOR_TO
74190: IFFALSE 74274
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74192: LD_VAR 0 8
74196: PUSH
74197: LD_VAR 0 6
74201: ARRAY
74202: PPUSH
74203: CALL_OW 461
74207: PUSH
74208: LD_INT 6
74210: EQUAL
74211: IFFALSE 74272
// begin x := tmp [ i ] ;
74213: LD_ADDR_VAR 0 9
74217: PUSH
74218: LD_VAR 0 8
74222: PUSH
74223: LD_VAR 0 6
74227: ARRAY
74228: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74229: LD_ADDR_VAR 0 8
74233: PUSH
74234: LD_VAR 0 8
74238: PPUSH
74239: LD_VAR 0 6
74243: PPUSH
74244: CALL_OW 3
74248: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74249: LD_ADDR_VAR 0 8
74253: PUSH
74254: LD_VAR 0 8
74258: PPUSH
74259: LD_INT 1
74261: PPUSH
74262: LD_VAR 0 9
74266: PPUSH
74267: CALL_OW 2
74271: ST_TO_ADDR
// end ;
74272: GO 74189
74274: POP
74275: POP
// for i in tmp do
74276: LD_ADDR_VAR 0 6
74280: PUSH
74281: LD_VAR 0 8
74285: PUSH
74286: FOR_IN
74287: IFFALSE 74356
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74289: LD_VAR 0 6
74293: PPUSH
74294: CALL_OW 313
74298: PUSH
74299: LD_INT 6
74301: LESS
74302: PUSH
74303: LD_VAR 0 6
74307: PPUSH
74308: CALL_OW 266
74312: PUSH
74313: LD_INT 31
74315: PUSH
74316: LD_INT 32
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: IN
74323: NOT
74324: AND
74325: PUSH
74326: LD_VAR 0 6
74330: PPUSH
74331: CALL_OW 313
74335: PUSH
74336: LD_INT 0
74338: EQUAL
74339: OR
74340: IFFALSE 74354
// begin j := i ;
74342: LD_ADDR_VAR 0 7
74346: PUSH
74347: LD_VAR 0 6
74351: ST_TO_ADDR
// break ;
74352: GO 74356
// end ; end ;
74354: GO 74286
74356: POP
74357: POP
// if j then
74358: LD_VAR 0 7
74362: IFFALSE 74380
// ComEnterUnit ( unit , j ) else
74364: LD_VAR 0 3
74368: PPUSH
74369: LD_VAR 0 7
74373: PPUSH
74374: CALL_OW 120
74378: GO 74483
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74380: LD_ADDR_VAR 0 10
74384: PUSH
74385: LD_VAR 0 2
74389: PPUSH
74390: LD_INT 2
74392: PUSH
74393: LD_INT 30
74395: PUSH
74396: LD_INT 0
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 30
74405: PUSH
74406: LD_INT 1
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: LIST
74417: PPUSH
74418: CALL_OW 72
74422: ST_TO_ADDR
// if depot then
74423: LD_VAR 0 10
74427: IFFALSE 74483
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74429: LD_ADDR_VAR 0 10
74433: PUSH
74434: LD_VAR 0 10
74438: PPUSH
74439: LD_VAR 0 3
74443: PPUSH
74444: CALL_OW 74
74448: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74449: LD_VAR 0 3
74453: PPUSH
74454: LD_VAR 0 10
74458: PPUSH
74459: CALL_OW 296
74463: PUSH
74464: LD_INT 10
74466: GREATER
74467: IFFALSE 74483
// ComStandNearbyBuilding ( unit , depot ) ;
74469: LD_VAR 0 3
74473: PPUSH
74474: LD_VAR 0 10
74478: PPUSH
74479: CALL 15877 0 2
// end ; end ; end ;
74483: LD_VAR 0 5
74487: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74488: LD_INT 0
74490: PPUSH
74491: PPUSH
74492: PPUSH
74493: PPUSH
// if not mc_bases then
74494: LD_EXP 59
74498: NOT
74499: IFFALSE 74503
// exit ;
74501: GO 74742
// for i = 1 to mc_bases do
74503: LD_ADDR_VAR 0 2
74507: PUSH
74508: DOUBLE
74509: LD_INT 1
74511: DEC
74512: ST_TO_ADDR
74513: LD_EXP 59
74517: PUSH
74518: FOR_TO
74519: IFFALSE 74740
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74521: LD_ADDR_VAR 0 4
74525: PUSH
74526: LD_EXP 59
74530: PUSH
74531: LD_VAR 0 2
74535: ARRAY
74536: PPUSH
74537: LD_INT 21
74539: PUSH
74540: LD_INT 1
74542: PUSH
74543: EMPTY
74544: LIST
74545: LIST
74546: PPUSH
74547: CALL_OW 72
74551: PUSH
74552: LD_EXP 88
74556: PUSH
74557: LD_VAR 0 2
74561: ARRAY
74562: UNION
74563: ST_TO_ADDR
// if not tmp then
74564: LD_VAR 0 4
74568: NOT
74569: IFFALSE 74573
// continue ;
74571: GO 74518
// for j in tmp do
74573: LD_ADDR_VAR 0 3
74577: PUSH
74578: LD_VAR 0 4
74582: PUSH
74583: FOR_IN
74584: IFFALSE 74736
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74586: LD_VAR 0 3
74590: PPUSH
74591: CALL_OW 110
74595: NOT
74596: PUSH
74597: LD_VAR 0 3
74601: PPUSH
74602: CALL_OW 314
74606: NOT
74607: AND
74608: PUSH
74609: LD_VAR 0 3
74613: PPUSH
74614: CALL_OW 311
74618: NOT
74619: AND
74620: PUSH
74621: LD_VAR 0 3
74625: PPUSH
74626: CALL_OW 310
74630: NOT
74631: AND
74632: PUSH
74633: LD_VAR 0 3
74637: PUSH
74638: LD_EXP 62
74642: PUSH
74643: LD_VAR 0 2
74647: ARRAY
74648: PUSH
74649: LD_INT 1
74651: ARRAY
74652: IN
74653: NOT
74654: AND
74655: PUSH
74656: LD_VAR 0 3
74660: PUSH
74661: LD_EXP 62
74665: PUSH
74666: LD_VAR 0 2
74670: ARRAY
74671: PUSH
74672: LD_INT 2
74674: ARRAY
74675: IN
74676: NOT
74677: AND
74678: PUSH
74679: LD_VAR 0 3
74683: PUSH
74684: LD_EXP 71
74688: PUSH
74689: LD_VAR 0 2
74693: ARRAY
74694: IN
74695: NOT
74696: AND
74697: IFFALSE 74734
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
74699: LD_VAR 0 2
74703: PPUSH
74704: LD_EXP 59
74708: PUSH
74709: LD_VAR 0 2
74713: ARRAY
74714: PPUSH
74715: LD_VAR 0 3
74719: PPUSH
74720: LD_VAR 0 3
74724: PPUSH
74725: CALL_OW 257
74729: PPUSH
74730: CALL 73506 0 4
// end ;
74734: GO 74583
74736: POP
74737: POP
// end ;
74738: GO 74518
74740: POP
74741: POP
// end ;
74742: LD_VAR 0 1
74746: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
74747: LD_INT 0
74749: PPUSH
74750: PPUSH
74751: PPUSH
74752: PPUSH
74753: PPUSH
74754: PPUSH
// if not mc_bases [ base ] then
74755: LD_EXP 59
74759: PUSH
74760: LD_VAR 0 1
74764: ARRAY
74765: NOT
74766: IFFALSE 74770
// exit ;
74768: GO 74952
// tmp := [ ] ;
74770: LD_ADDR_VAR 0 6
74774: PUSH
74775: EMPTY
74776: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
74777: LD_ADDR_VAR 0 7
74781: PUSH
74782: LD_VAR 0 3
74786: PPUSH
74787: LD_INT 0
74789: PPUSH
74790: CALL_OW 517
74794: ST_TO_ADDR
// if not list then
74795: LD_VAR 0 7
74799: NOT
74800: IFFALSE 74804
// exit ;
74802: GO 74952
// for i = 1 to amount do
74804: LD_ADDR_VAR 0 5
74808: PUSH
74809: DOUBLE
74810: LD_INT 1
74812: DEC
74813: ST_TO_ADDR
74814: LD_VAR 0 2
74818: PUSH
74819: FOR_TO
74820: IFFALSE 74900
// begin x := rand ( 1 , list [ 1 ] ) ;
74822: LD_ADDR_VAR 0 8
74826: PUSH
74827: LD_INT 1
74829: PPUSH
74830: LD_VAR 0 7
74834: PUSH
74835: LD_INT 1
74837: ARRAY
74838: PPUSH
74839: CALL_OW 12
74843: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
74844: LD_ADDR_VAR 0 6
74848: PUSH
74849: LD_VAR 0 6
74853: PPUSH
74854: LD_VAR 0 5
74858: PPUSH
74859: LD_VAR 0 7
74863: PUSH
74864: LD_INT 1
74866: ARRAY
74867: PUSH
74868: LD_VAR 0 8
74872: ARRAY
74873: PUSH
74874: LD_VAR 0 7
74878: PUSH
74879: LD_INT 2
74881: ARRAY
74882: PUSH
74883: LD_VAR 0 8
74887: ARRAY
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: PPUSH
74893: CALL_OW 1
74897: ST_TO_ADDR
// end ;
74898: GO 74819
74900: POP
74901: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
74902: LD_ADDR_EXP 72
74906: PUSH
74907: LD_EXP 72
74911: PPUSH
74912: LD_VAR 0 1
74916: PPUSH
74917: LD_VAR 0 6
74921: PPUSH
74922: CALL_OW 1
74926: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
74927: LD_ADDR_EXP 74
74931: PUSH
74932: LD_EXP 74
74936: PPUSH
74937: LD_VAR 0 1
74941: PPUSH
74942: LD_VAR 0 3
74946: PPUSH
74947: CALL_OW 1
74951: ST_TO_ADDR
// end ;
74952: LD_VAR 0 4
74956: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74957: LD_INT 0
74959: PPUSH
// if not mc_bases [ base ] then
74960: LD_EXP 59
74964: PUSH
74965: LD_VAR 0 1
74969: ARRAY
74970: NOT
74971: IFFALSE 74975
// exit ;
74973: GO 75000
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
74975: LD_ADDR_EXP 64
74979: PUSH
74980: LD_EXP 64
74984: PPUSH
74985: LD_VAR 0 1
74989: PPUSH
74990: LD_VAR 0 2
74994: PPUSH
74995: CALL_OW 1
74999: ST_TO_ADDR
// end ;
75000: LD_VAR 0 3
75004: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75005: LD_INT 0
75007: PPUSH
// if not mc_bases [ base ] then
75008: LD_EXP 59
75012: PUSH
75013: LD_VAR 0 1
75017: ARRAY
75018: NOT
75019: IFFALSE 75023
// exit ;
75021: GO 75060
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75023: LD_ADDR_EXP 64
75027: PUSH
75028: LD_EXP 64
75032: PPUSH
75033: LD_VAR 0 1
75037: PPUSH
75038: LD_EXP 64
75042: PUSH
75043: LD_VAR 0 1
75047: ARRAY
75048: PUSH
75049: LD_VAR 0 2
75053: UNION
75054: PPUSH
75055: CALL_OW 1
75059: ST_TO_ADDR
// end ;
75060: LD_VAR 0 3
75064: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75065: LD_INT 0
75067: PPUSH
// if not mc_bases [ base ] then
75068: LD_EXP 59
75072: PUSH
75073: LD_VAR 0 1
75077: ARRAY
75078: NOT
75079: IFFALSE 75083
// exit ;
75081: GO 75108
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75083: LD_ADDR_EXP 80
75087: PUSH
75088: LD_EXP 80
75092: PPUSH
75093: LD_VAR 0 1
75097: PPUSH
75098: LD_VAR 0 2
75102: PPUSH
75103: CALL_OW 1
75107: ST_TO_ADDR
// end ;
75108: LD_VAR 0 3
75112: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75113: LD_INT 0
75115: PPUSH
// if not mc_bases [ base ] then
75116: LD_EXP 59
75120: PUSH
75121: LD_VAR 0 1
75125: ARRAY
75126: NOT
75127: IFFALSE 75131
// exit ;
75129: GO 75168
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75131: LD_ADDR_EXP 80
75135: PUSH
75136: LD_EXP 80
75140: PPUSH
75141: LD_VAR 0 1
75145: PPUSH
75146: LD_EXP 80
75150: PUSH
75151: LD_VAR 0 1
75155: ARRAY
75156: PUSH
75157: LD_VAR 0 2
75161: ADD
75162: PPUSH
75163: CALL_OW 1
75167: ST_TO_ADDR
// end ;
75168: LD_VAR 0 3
75172: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75173: LD_INT 0
75175: PPUSH
// if not mc_bases [ base ] then
75176: LD_EXP 59
75180: PUSH
75181: LD_VAR 0 1
75185: ARRAY
75186: NOT
75187: IFFALSE 75191
// exit ;
75189: GO 75245
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75191: LD_ADDR_EXP 81
75195: PUSH
75196: LD_EXP 81
75200: PPUSH
75201: LD_VAR 0 1
75205: PPUSH
75206: LD_VAR 0 2
75210: PPUSH
75211: CALL_OW 1
75215: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75216: LD_ADDR_EXP 70
75220: PUSH
75221: LD_EXP 70
75225: PPUSH
75226: LD_VAR 0 1
75230: PPUSH
75231: LD_VAR 0 2
75235: PUSH
75236: LD_INT 0
75238: PLUS
75239: PPUSH
75240: CALL_OW 1
75244: ST_TO_ADDR
// end ;
75245: LD_VAR 0 3
75249: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75250: LD_INT 0
75252: PPUSH
// if not mc_bases [ base ] then
75253: LD_EXP 59
75257: PUSH
75258: LD_VAR 0 1
75262: ARRAY
75263: NOT
75264: IFFALSE 75268
// exit ;
75266: GO 75293
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75268: LD_ADDR_EXP 70
75272: PUSH
75273: LD_EXP 70
75277: PPUSH
75278: LD_VAR 0 1
75282: PPUSH
75283: LD_VAR 0 2
75287: PPUSH
75288: CALL_OW 1
75292: ST_TO_ADDR
// end ;
75293: LD_VAR 0 3
75297: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75298: LD_INT 0
75300: PPUSH
75301: PPUSH
75302: PPUSH
75303: PPUSH
// if not mc_bases [ base ] then
75304: LD_EXP 59
75308: PUSH
75309: LD_VAR 0 1
75313: ARRAY
75314: NOT
75315: IFFALSE 75319
// exit ;
75317: GO 75384
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75319: LD_ADDR_EXP 79
75323: PUSH
75324: LD_EXP 79
75328: PPUSH
75329: LD_VAR 0 1
75333: PUSH
75334: LD_EXP 79
75338: PUSH
75339: LD_VAR 0 1
75343: ARRAY
75344: PUSH
75345: LD_INT 1
75347: PLUS
75348: PUSH
75349: EMPTY
75350: LIST
75351: LIST
75352: PPUSH
75353: LD_VAR 0 1
75357: PUSH
75358: LD_VAR 0 2
75362: PUSH
75363: LD_VAR 0 3
75367: PUSH
75368: LD_VAR 0 4
75372: PUSH
75373: EMPTY
75374: LIST
75375: LIST
75376: LIST
75377: LIST
75378: PPUSH
75379: CALL 19263 0 3
75383: ST_TO_ADDR
// end ;
75384: LD_VAR 0 5
75388: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75389: LD_INT 0
75391: PPUSH
// if not mc_bases [ base ] then
75392: LD_EXP 59
75396: PUSH
75397: LD_VAR 0 1
75401: ARRAY
75402: NOT
75403: IFFALSE 75407
// exit ;
75405: GO 75432
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75407: LD_ADDR_EXP 96
75411: PUSH
75412: LD_EXP 96
75416: PPUSH
75417: LD_VAR 0 1
75421: PPUSH
75422: LD_VAR 0 2
75426: PPUSH
75427: CALL_OW 1
75431: ST_TO_ADDR
// end ;
75432: LD_VAR 0 3
75436: RET
// export function MC_GetMinesField ( base ) ; begin
75437: LD_INT 0
75439: PPUSH
// result := mc_mines [ base ] ;
75440: LD_ADDR_VAR 0 2
75444: PUSH
75445: LD_EXP 72
75449: PUSH
75450: LD_VAR 0 1
75454: ARRAY
75455: ST_TO_ADDR
// end ;
75456: LD_VAR 0 2
75460: RET
// export function MC_GetProduceList ( base ) ; begin
75461: LD_INT 0
75463: PPUSH
// result := mc_produce [ base ] ;
75464: LD_ADDR_VAR 0 2
75468: PUSH
75469: LD_EXP 80
75473: PUSH
75474: LD_VAR 0 1
75478: ARRAY
75479: ST_TO_ADDR
// end ;
75480: LD_VAR 0 2
75484: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75485: LD_INT 0
75487: PPUSH
75488: PPUSH
// if not mc_bases then
75489: LD_EXP 59
75493: NOT
75494: IFFALSE 75498
// exit ;
75496: GO 75563
// if mc_bases [ base ] then
75498: LD_EXP 59
75502: PUSH
75503: LD_VAR 0 1
75507: ARRAY
75508: IFFALSE 75563
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75510: LD_ADDR_VAR 0 3
75514: PUSH
75515: LD_EXP 59
75519: PUSH
75520: LD_VAR 0 1
75524: ARRAY
75525: PPUSH
75526: LD_INT 30
75528: PUSH
75529: LD_VAR 0 2
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PPUSH
75538: CALL_OW 72
75542: ST_TO_ADDR
// if result then
75543: LD_VAR 0 3
75547: IFFALSE 75563
// result := result [ 1 ] ;
75549: LD_ADDR_VAR 0 3
75553: PUSH
75554: LD_VAR 0 3
75558: PUSH
75559: LD_INT 1
75561: ARRAY
75562: ST_TO_ADDR
// end ; end ;
75563: LD_VAR 0 3
75567: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75568: LD_INT 0
75570: PPUSH
75571: PPUSH
// if not mc_bases then
75572: LD_EXP 59
75576: NOT
75577: IFFALSE 75581
// exit ;
75579: GO 75626
// if mc_bases [ base ] then
75581: LD_EXP 59
75585: PUSH
75586: LD_VAR 0 1
75590: ARRAY
75591: IFFALSE 75626
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75593: LD_ADDR_VAR 0 3
75597: PUSH
75598: LD_EXP 59
75602: PUSH
75603: LD_VAR 0 1
75607: ARRAY
75608: PPUSH
75609: LD_INT 30
75611: PUSH
75612: LD_VAR 0 2
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PPUSH
75621: CALL_OW 72
75625: ST_TO_ADDR
// end ;
75626: LD_VAR 0 3
75630: RET
// export function MC_SetTame ( base , area ) ; begin
75631: LD_INT 0
75633: PPUSH
// if not mc_bases or not base then
75634: LD_EXP 59
75638: NOT
75639: PUSH
75640: LD_VAR 0 1
75644: NOT
75645: OR
75646: IFFALSE 75650
// exit ;
75648: GO 75675
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
75650: LD_ADDR_EXP 87
75654: PUSH
75655: LD_EXP 87
75659: PPUSH
75660: LD_VAR 0 1
75664: PPUSH
75665: LD_VAR 0 2
75669: PPUSH
75670: CALL_OW 1
75674: ST_TO_ADDR
// end ;
75675: LD_VAR 0 3
75679: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
75680: LD_INT 0
75682: PPUSH
75683: PPUSH
// if not mc_bases or not base then
75684: LD_EXP 59
75688: NOT
75689: PUSH
75690: LD_VAR 0 1
75694: NOT
75695: OR
75696: IFFALSE 75700
// exit ;
75698: GO 75802
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75700: LD_ADDR_VAR 0 4
75704: PUSH
75705: LD_EXP 59
75709: PUSH
75710: LD_VAR 0 1
75714: ARRAY
75715: PPUSH
75716: LD_INT 30
75718: PUSH
75719: LD_VAR 0 2
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: PPUSH
75728: CALL_OW 72
75732: ST_TO_ADDR
// if not tmp then
75733: LD_VAR 0 4
75737: NOT
75738: IFFALSE 75742
// exit ;
75740: GO 75802
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
75742: LD_ADDR_EXP 91
75746: PUSH
75747: LD_EXP 91
75751: PPUSH
75752: LD_VAR 0 1
75756: PPUSH
75757: LD_EXP 91
75761: PUSH
75762: LD_VAR 0 1
75766: ARRAY
75767: PPUSH
75768: LD_EXP 91
75772: PUSH
75773: LD_VAR 0 1
75777: ARRAY
75778: PUSH
75779: LD_INT 1
75781: PLUS
75782: PPUSH
75783: LD_VAR 0 4
75787: PUSH
75788: LD_INT 1
75790: ARRAY
75791: PPUSH
75792: CALL_OW 2
75796: PPUSH
75797: CALL_OW 1
75801: ST_TO_ADDR
// end ;
75802: LD_VAR 0 3
75806: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
75807: LD_INT 0
75809: PPUSH
75810: PPUSH
// if not mc_bases or not base or not kinds then
75811: LD_EXP 59
75815: NOT
75816: PUSH
75817: LD_VAR 0 1
75821: NOT
75822: OR
75823: PUSH
75824: LD_VAR 0 2
75828: NOT
75829: OR
75830: IFFALSE 75834
// exit ;
75832: GO 75895
// for i in kinds do
75834: LD_ADDR_VAR 0 4
75838: PUSH
75839: LD_VAR 0 2
75843: PUSH
75844: FOR_IN
75845: IFFALSE 75893
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
75847: LD_ADDR_EXP 93
75851: PUSH
75852: LD_EXP 93
75856: PPUSH
75857: LD_VAR 0 1
75861: PUSH
75862: LD_EXP 93
75866: PUSH
75867: LD_VAR 0 1
75871: ARRAY
75872: PUSH
75873: LD_INT 1
75875: PLUS
75876: PUSH
75877: EMPTY
75878: LIST
75879: LIST
75880: PPUSH
75881: LD_VAR 0 4
75885: PPUSH
75886: CALL 19263 0 3
75890: ST_TO_ADDR
75891: GO 75844
75893: POP
75894: POP
// end ;
75895: LD_VAR 0 3
75899: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
75900: LD_INT 0
75902: PPUSH
// if not mc_bases or not base or not areas then
75903: LD_EXP 59
75907: NOT
75908: PUSH
75909: LD_VAR 0 1
75913: NOT
75914: OR
75915: PUSH
75916: LD_VAR 0 2
75920: NOT
75921: OR
75922: IFFALSE 75926
// exit ;
75924: GO 75951
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
75926: LD_ADDR_EXP 77
75930: PUSH
75931: LD_EXP 77
75935: PPUSH
75936: LD_VAR 0 1
75940: PPUSH
75941: LD_VAR 0 2
75945: PPUSH
75946: CALL_OW 1
75950: ST_TO_ADDR
// end ;
75951: LD_VAR 0 3
75955: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75956: LD_INT 0
75958: PPUSH
// if not mc_bases or not base or not teleports_exit then
75959: LD_EXP 59
75963: NOT
75964: PUSH
75965: LD_VAR 0 1
75969: NOT
75970: OR
75971: PUSH
75972: LD_VAR 0 2
75976: NOT
75977: OR
75978: IFFALSE 75982
// exit ;
75980: GO 76007
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
75982: LD_ADDR_EXP 94
75986: PUSH
75987: LD_EXP 94
75991: PPUSH
75992: LD_VAR 0 1
75996: PPUSH
75997: LD_VAR 0 2
76001: PPUSH
76002: CALL_OW 1
76006: ST_TO_ADDR
// end ;
76007: LD_VAR 0 3
76011: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76012: LD_INT 0
76014: PPUSH
76015: PPUSH
76016: PPUSH
// if not mc_bases or not base or not ext_list then
76017: LD_EXP 59
76021: NOT
76022: PUSH
76023: LD_VAR 0 1
76027: NOT
76028: OR
76029: PUSH
76030: LD_VAR 0 5
76034: NOT
76035: OR
76036: IFFALSE 76040
// exit ;
76038: GO 76213
// tmp := GetFacExtXYD ( x , y , d ) ;
76040: LD_ADDR_VAR 0 8
76044: PUSH
76045: LD_VAR 0 2
76049: PPUSH
76050: LD_VAR 0 3
76054: PPUSH
76055: LD_VAR 0 4
76059: PPUSH
76060: CALL 47942 0 3
76064: ST_TO_ADDR
// if not tmp then
76065: LD_VAR 0 8
76069: NOT
76070: IFFALSE 76074
// exit ;
76072: GO 76213
// for i in tmp do
76074: LD_ADDR_VAR 0 7
76078: PUSH
76079: LD_VAR 0 8
76083: PUSH
76084: FOR_IN
76085: IFFALSE 76211
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76087: LD_ADDR_EXP 64
76091: PUSH
76092: LD_EXP 64
76096: PPUSH
76097: LD_VAR 0 1
76101: PPUSH
76102: LD_EXP 64
76106: PUSH
76107: LD_VAR 0 1
76111: ARRAY
76112: PPUSH
76113: LD_EXP 64
76117: PUSH
76118: LD_VAR 0 1
76122: ARRAY
76123: PUSH
76124: LD_INT 1
76126: PLUS
76127: PPUSH
76128: LD_VAR 0 5
76132: PUSH
76133: LD_INT 1
76135: ARRAY
76136: PUSH
76137: LD_VAR 0 7
76141: PUSH
76142: LD_INT 1
76144: ARRAY
76145: PUSH
76146: LD_VAR 0 7
76150: PUSH
76151: LD_INT 2
76153: ARRAY
76154: PUSH
76155: LD_VAR 0 7
76159: PUSH
76160: LD_INT 3
76162: ARRAY
76163: PUSH
76164: EMPTY
76165: LIST
76166: LIST
76167: LIST
76168: LIST
76169: PPUSH
76170: CALL_OW 2
76174: PPUSH
76175: CALL_OW 1
76179: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76180: LD_ADDR_VAR 0 5
76184: PUSH
76185: LD_VAR 0 5
76189: PPUSH
76190: LD_INT 1
76192: PPUSH
76193: CALL_OW 3
76197: ST_TO_ADDR
// if not ext_list then
76198: LD_VAR 0 5
76202: NOT
76203: IFFALSE 76209
// exit ;
76205: POP
76206: POP
76207: GO 76213
// end ;
76209: GO 76084
76211: POP
76212: POP
// end ;
76213: LD_VAR 0 6
76217: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76218: LD_INT 0
76220: PPUSH
// if not mc_bases or not base or not weapon_list then
76221: LD_EXP 59
76225: NOT
76226: PUSH
76227: LD_VAR 0 1
76231: NOT
76232: OR
76233: PUSH
76234: LD_VAR 0 2
76238: NOT
76239: OR
76240: IFFALSE 76244
// exit ;
76242: GO 76269
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76244: LD_ADDR_EXP 98
76248: PUSH
76249: LD_EXP 98
76253: PPUSH
76254: LD_VAR 0 1
76258: PPUSH
76259: LD_VAR 0 2
76263: PPUSH
76264: CALL_OW 1
76268: ST_TO_ADDR
// end ;
76269: LD_VAR 0 3
76273: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76274: LD_INT 0
76276: PPUSH
// if not mc_bases or not base or not tech_list then
76277: LD_EXP 59
76281: NOT
76282: PUSH
76283: LD_VAR 0 1
76287: NOT
76288: OR
76289: PUSH
76290: LD_VAR 0 2
76294: NOT
76295: OR
76296: IFFALSE 76300
// exit ;
76298: GO 76325
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76300: LD_ADDR_EXP 86
76304: PUSH
76305: LD_EXP 86
76309: PPUSH
76310: LD_VAR 0 1
76314: PPUSH
76315: LD_VAR 0 2
76319: PPUSH
76320: CALL_OW 1
76324: ST_TO_ADDR
// end ;
76325: LD_VAR 0 3
76329: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76330: LD_INT 0
76332: PPUSH
// if not mc_bases or not parking_area or not base then
76333: LD_EXP 59
76337: NOT
76338: PUSH
76339: LD_VAR 0 2
76343: NOT
76344: OR
76345: PUSH
76346: LD_VAR 0 1
76350: NOT
76351: OR
76352: IFFALSE 76356
// exit ;
76354: GO 76381
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76356: LD_ADDR_EXP 83
76360: PUSH
76361: LD_EXP 83
76365: PPUSH
76366: LD_VAR 0 1
76370: PPUSH
76371: LD_VAR 0 2
76375: PPUSH
76376: CALL_OW 1
76380: ST_TO_ADDR
// end ;
76381: LD_VAR 0 3
76385: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76386: LD_INT 0
76388: PPUSH
// if not mc_bases or not base or not scan_area then
76389: LD_EXP 59
76393: NOT
76394: PUSH
76395: LD_VAR 0 1
76399: NOT
76400: OR
76401: PUSH
76402: LD_VAR 0 2
76406: NOT
76407: OR
76408: IFFALSE 76412
// exit ;
76410: GO 76437
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76412: LD_ADDR_EXP 84
76416: PUSH
76417: LD_EXP 84
76421: PPUSH
76422: LD_VAR 0 1
76426: PPUSH
76427: LD_VAR 0 2
76431: PPUSH
76432: CALL_OW 1
76436: ST_TO_ADDR
// end ;
76437: LD_VAR 0 3
76441: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76442: LD_INT 0
76444: PPUSH
76445: PPUSH
// if not mc_bases or not base then
76446: LD_EXP 59
76450: NOT
76451: PUSH
76452: LD_VAR 0 1
76456: NOT
76457: OR
76458: IFFALSE 76462
// exit ;
76460: GO 76526
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76462: LD_ADDR_VAR 0 3
76466: PUSH
76467: LD_INT 1
76469: PUSH
76470: LD_INT 2
76472: PUSH
76473: LD_INT 3
76475: PUSH
76476: LD_INT 4
76478: PUSH
76479: LD_INT 11
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: LIST
76486: LIST
76487: LIST
76488: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76489: LD_ADDR_EXP 86
76493: PUSH
76494: LD_EXP 86
76498: PPUSH
76499: LD_VAR 0 1
76503: PPUSH
76504: LD_EXP 86
76508: PUSH
76509: LD_VAR 0 1
76513: ARRAY
76514: PUSH
76515: LD_VAR 0 3
76519: DIFF
76520: PPUSH
76521: CALL_OW 1
76525: ST_TO_ADDR
// end ;
76526: LD_VAR 0 2
76530: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76531: LD_INT 0
76533: PPUSH
// result := mc_vehicles [ base ] ;
76534: LD_ADDR_VAR 0 3
76538: PUSH
76539: LD_EXP 78
76543: PUSH
76544: LD_VAR 0 1
76548: ARRAY
76549: ST_TO_ADDR
// if onlyCombat then
76550: LD_VAR 0 2
76554: IFFALSE 76732
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76556: LD_ADDR_VAR 0 3
76560: PUSH
76561: LD_VAR 0 3
76565: PUSH
76566: LD_VAR 0 3
76570: PPUSH
76571: LD_INT 2
76573: PUSH
76574: LD_INT 34
76576: PUSH
76577: LD_INT 12
76579: PUSH
76580: EMPTY
76581: LIST
76582: LIST
76583: PUSH
76584: LD_INT 34
76586: PUSH
76587: LD_INT 51
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: PUSH
76594: LD_INT 34
76596: PUSH
76597: LD_EXP 103
76601: PUSH
76602: EMPTY
76603: LIST
76604: LIST
76605: PUSH
76606: LD_INT 34
76608: PUSH
76609: LD_INT 32
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: PUSH
76616: LD_INT 34
76618: PUSH
76619: LD_INT 13
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: PUSH
76626: LD_INT 34
76628: PUSH
76629: LD_INT 52
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: PUSH
76636: LD_INT 34
76638: PUSH
76639: LD_EXP 108
76643: PUSH
76644: EMPTY
76645: LIST
76646: LIST
76647: PUSH
76648: LD_INT 34
76650: PUSH
76651: LD_INT 14
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: PUSH
76658: LD_INT 34
76660: PUSH
76661: LD_INT 53
76663: PUSH
76664: EMPTY
76665: LIST
76666: LIST
76667: PUSH
76668: LD_INT 34
76670: PUSH
76671: LD_EXP 102
76675: PUSH
76676: EMPTY
76677: LIST
76678: LIST
76679: PUSH
76680: LD_INT 34
76682: PUSH
76683: LD_INT 31
76685: PUSH
76686: EMPTY
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 34
76692: PUSH
76693: LD_INT 48
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: LD_INT 34
76702: PUSH
76703: LD_INT 8
76705: PUSH
76706: EMPTY
76707: LIST
76708: LIST
76709: PUSH
76710: EMPTY
76711: LIST
76712: LIST
76713: LIST
76714: LIST
76715: LIST
76716: LIST
76717: LIST
76718: LIST
76719: LIST
76720: LIST
76721: LIST
76722: LIST
76723: LIST
76724: LIST
76725: PPUSH
76726: CALL_OW 72
76730: DIFF
76731: ST_TO_ADDR
// end ; end_of_file
76732: LD_VAR 0 3
76736: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
76737: LD_INT 0
76739: PPUSH
76740: PPUSH
76741: PPUSH
// if not mc_bases or not skirmish then
76742: LD_EXP 59
76746: NOT
76747: PUSH
76748: LD_EXP 57
76752: NOT
76753: OR
76754: IFFALSE 76758
// exit ;
76756: GO 76923
// for i = 1 to mc_bases do
76758: LD_ADDR_VAR 0 4
76762: PUSH
76763: DOUBLE
76764: LD_INT 1
76766: DEC
76767: ST_TO_ADDR
76768: LD_EXP 59
76772: PUSH
76773: FOR_TO
76774: IFFALSE 76921
// begin if sci in mc_bases [ i ] then
76776: LD_VAR 0 2
76780: PUSH
76781: LD_EXP 59
76785: PUSH
76786: LD_VAR 0 4
76790: ARRAY
76791: IN
76792: IFFALSE 76919
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76794: LD_ADDR_EXP 88
76798: PUSH
76799: LD_EXP 88
76803: PPUSH
76804: LD_VAR 0 4
76808: PUSH
76809: LD_EXP 88
76813: PUSH
76814: LD_VAR 0 4
76818: ARRAY
76819: PUSH
76820: LD_INT 1
76822: PLUS
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: PPUSH
76828: LD_VAR 0 1
76832: PPUSH
76833: CALL 19263 0 3
76837: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
76838: LD_ADDR_VAR 0 5
76842: PUSH
76843: LD_EXP 59
76847: PUSH
76848: LD_VAR 0 4
76852: ARRAY
76853: PPUSH
76854: LD_INT 2
76856: PUSH
76857: LD_INT 30
76859: PUSH
76860: LD_INT 0
76862: PUSH
76863: EMPTY
76864: LIST
76865: LIST
76866: PUSH
76867: LD_INT 30
76869: PUSH
76870: LD_INT 1
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: LIST
76881: PPUSH
76882: CALL_OW 72
76886: PPUSH
76887: LD_VAR 0 1
76891: PPUSH
76892: CALL_OW 74
76896: ST_TO_ADDR
// if tmp then
76897: LD_VAR 0 5
76901: IFFALSE 76917
// ComStandNearbyBuilding ( ape , tmp ) ;
76903: LD_VAR 0 1
76907: PPUSH
76908: LD_VAR 0 5
76912: PPUSH
76913: CALL 15877 0 2
// break ;
76917: GO 76921
// end ; end ;
76919: GO 76773
76921: POP
76922: POP
// end ;
76923: LD_VAR 0 3
76927: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
76928: LD_INT 0
76930: PPUSH
76931: PPUSH
76932: PPUSH
// if not mc_bases or not skirmish then
76933: LD_EXP 59
76937: NOT
76938: PUSH
76939: LD_EXP 57
76943: NOT
76944: OR
76945: IFFALSE 76949
// exit ;
76947: GO 77038
// for i = 1 to mc_bases do
76949: LD_ADDR_VAR 0 4
76953: PUSH
76954: DOUBLE
76955: LD_INT 1
76957: DEC
76958: ST_TO_ADDR
76959: LD_EXP 59
76963: PUSH
76964: FOR_TO
76965: IFFALSE 77036
// begin if building in mc_busy_turret_list [ i ] then
76967: LD_VAR 0 1
76971: PUSH
76972: LD_EXP 69
76976: PUSH
76977: LD_VAR 0 4
76981: ARRAY
76982: IN
76983: IFFALSE 77034
// begin tmp := mc_busy_turret_list [ i ] diff building ;
76985: LD_ADDR_VAR 0 5
76989: PUSH
76990: LD_EXP 69
76994: PUSH
76995: LD_VAR 0 4
76999: ARRAY
77000: PUSH
77001: LD_VAR 0 1
77005: DIFF
77006: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77007: LD_ADDR_EXP 69
77011: PUSH
77012: LD_EXP 69
77016: PPUSH
77017: LD_VAR 0 4
77021: PPUSH
77022: LD_VAR 0 5
77026: PPUSH
77027: CALL_OW 1
77031: ST_TO_ADDR
// break ;
77032: GO 77036
// end ; end ;
77034: GO 76964
77036: POP
77037: POP
// end ;
77038: LD_VAR 0 3
77042: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77043: LD_INT 0
77045: PPUSH
77046: PPUSH
77047: PPUSH
// if not mc_bases or not skirmish then
77048: LD_EXP 59
77052: NOT
77053: PUSH
77054: LD_EXP 57
77058: NOT
77059: OR
77060: IFFALSE 77064
// exit ;
77062: GO 77263
// for i = 1 to mc_bases do
77064: LD_ADDR_VAR 0 5
77068: PUSH
77069: DOUBLE
77070: LD_INT 1
77072: DEC
77073: ST_TO_ADDR
77074: LD_EXP 59
77078: PUSH
77079: FOR_TO
77080: IFFALSE 77261
// if building in mc_bases [ i ] then
77082: LD_VAR 0 1
77086: PUSH
77087: LD_EXP 59
77091: PUSH
77092: LD_VAR 0 5
77096: ARRAY
77097: IN
77098: IFFALSE 77259
// begin tmp := mc_bases [ i ] diff building ;
77100: LD_ADDR_VAR 0 6
77104: PUSH
77105: LD_EXP 59
77109: PUSH
77110: LD_VAR 0 5
77114: ARRAY
77115: PUSH
77116: LD_VAR 0 1
77120: DIFF
77121: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77122: LD_ADDR_EXP 59
77126: PUSH
77127: LD_EXP 59
77131: PPUSH
77132: LD_VAR 0 5
77136: PPUSH
77137: LD_VAR 0 6
77141: PPUSH
77142: CALL_OW 1
77146: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77147: LD_VAR 0 1
77151: PUSH
77152: LD_EXP 67
77156: PUSH
77157: LD_VAR 0 5
77161: ARRAY
77162: IN
77163: IFFALSE 77202
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77165: LD_ADDR_EXP 67
77169: PUSH
77170: LD_EXP 67
77174: PPUSH
77175: LD_VAR 0 5
77179: PPUSH
77180: LD_EXP 67
77184: PUSH
77185: LD_VAR 0 5
77189: ARRAY
77190: PUSH
77191: LD_VAR 0 1
77195: DIFF
77196: PPUSH
77197: CALL_OW 1
77201: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77202: LD_VAR 0 1
77206: PUSH
77207: LD_EXP 68
77211: PUSH
77212: LD_VAR 0 5
77216: ARRAY
77217: IN
77218: IFFALSE 77257
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77220: LD_ADDR_EXP 68
77224: PUSH
77225: LD_EXP 68
77229: PPUSH
77230: LD_VAR 0 5
77234: PPUSH
77235: LD_EXP 68
77239: PUSH
77240: LD_VAR 0 5
77244: ARRAY
77245: PUSH
77246: LD_VAR 0 1
77250: DIFF
77251: PPUSH
77252: CALL_OW 1
77256: ST_TO_ADDR
// break ;
77257: GO 77261
// end ;
77259: GO 77079
77261: POP
77262: POP
// end ;
77263: LD_VAR 0 4
77267: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77268: LD_INT 0
77270: PPUSH
77271: PPUSH
77272: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77273: LD_EXP 59
77277: NOT
77278: PUSH
77279: LD_EXP 57
77283: NOT
77284: OR
77285: PUSH
77286: LD_VAR 0 3
77290: PUSH
77291: LD_EXP 85
77295: IN
77296: NOT
77297: OR
77298: IFFALSE 77302
// exit ;
77300: GO 77425
// for i = 1 to mc_vehicles do
77302: LD_ADDR_VAR 0 6
77306: PUSH
77307: DOUBLE
77308: LD_INT 1
77310: DEC
77311: ST_TO_ADDR
77312: LD_EXP 78
77316: PUSH
77317: FOR_TO
77318: IFFALSE 77423
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77320: LD_VAR 0 2
77324: PUSH
77325: LD_EXP 78
77329: PUSH
77330: LD_VAR 0 6
77334: ARRAY
77335: IN
77336: PUSH
77337: LD_VAR 0 1
77341: PUSH
77342: LD_EXP 78
77346: PUSH
77347: LD_VAR 0 6
77351: ARRAY
77352: IN
77353: OR
77354: IFFALSE 77421
// begin tmp := mc_vehicles [ i ] diff old ;
77356: LD_ADDR_VAR 0 7
77360: PUSH
77361: LD_EXP 78
77365: PUSH
77366: LD_VAR 0 6
77370: ARRAY
77371: PUSH
77372: LD_VAR 0 2
77376: DIFF
77377: ST_TO_ADDR
// tmp := tmp diff new ;
77378: LD_ADDR_VAR 0 7
77382: PUSH
77383: LD_VAR 0 7
77387: PUSH
77388: LD_VAR 0 1
77392: DIFF
77393: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77394: LD_ADDR_EXP 78
77398: PUSH
77399: LD_EXP 78
77403: PPUSH
77404: LD_VAR 0 6
77408: PPUSH
77409: LD_VAR 0 7
77413: PPUSH
77414: CALL_OW 1
77418: ST_TO_ADDR
// break ;
77419: GO 77423
// end ;
77421: GO 77317
77423: POP
77424: POP
// end ;
77425: LD_VAR 0 5
77429: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77430: LD_INT 0
77432: PPUSH
77433: PPUSH
77434: PPUSH
77435: PPUSH
// if not mc_bases or not skirmish then
77436: LD_EXP 59
77440: NOT
77441: PUSH
77442: LD_EXP 57
77446: NOT
77447: OR
77448: IFFALSE 77452
// exit ;
77450: GO 77835
// side := GetSide ( vehicle ) ;
77452: LD_ADDR_VAR 0 5
77456: PUSH
77457: LD_VAR 0 1
77461: PPUSH
77462: CALL_OW 255
77466: ST_TO_ADDR
// for i = 1 to mc_bases do
77467: LD_ADDR_VAR 0 4
77471: PUSH
77472: DOUBLE
77473: LD_INT 1
77475: DEC
77476: ST_TO_ADDR
77477: LD_EXP 59
77481: PUSH
77482: FOR_TO
77483: IFFALSE 77833
// begin if factory in mc_bases [ i ] then
77485: LD_VAR 0 2
77489: PUSH
77490: LD_EXP 59
77494: PUSH
77495: LD_VAR 0 4
77499: ARRAY
77500: IN
77501: IFFALSE 77831
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77503: LD_EXP 81
77507: PUSH
77508: LD_VAR 0 4
77512: ARRAY
77513: PUSH
77514: LD_EXP 70
77518: PUSH
77519: LD_VAR 0 4
77523: ARRAY
77524: LESS
77525: PUSH
77526: LD_VAR 0 1
77530: PPUSH
77531: CALL_OW 264
77535: PUSH
77536: LD_INT 31
77538: PUSH
77539: LD_INT 32
77541: PUSH
77542: LD_INT 51
77544: PUSH
77545: LD_EXP 103
77549: PUSH
77550: LD_INT 12
77552: PUSH
77553: LD_INT 30
77555: PUSH
77556: LD_EXP 102
77560: PUSH
77561: LD_INT 11
77563: PUSH
77564: LD_INT 53
77566: PUSH
77567: LD_INT 14
77569: PUSH
77570: LD_EXP 106
77574: PUSH
77575: LD_INT 29
77577: PUSH
77578: LD_EXP 104
77582: PUSH
77583: LD_INT 13
77585: PUSH
77586: LD_INT 52
77588: PUSH
77589: LD_EXP 108
77593: PUSH
77594: LD_INT 48
77596: PUSH
77597: LD_INT 8
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: LIST
77604: LIST
77605: LIST
77606: LIST
77607: LIST
77608: LIST
77609: LIST
77610: LIST
77611: LIST
77612: LIST
77613: LIST
77614: LIST
77615: LIST
77616: LIST
77617: LIST
77618: LIST
77619: IN
77620: NOT
77621: AND
77622: IFFALSE 77670
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
77624: LD_ADDR_EXP 81
77628: PUSH
77629: LD_EXP 81
77633: PPUSH
77634: LD_VAR 0 4
77638: PUSH
77639: LD_EXP 81
77643: PUSH
77644: LD_VAR 0 4
77648: ARRAY
77649: PUSH
77650: LD_INT 1
77652: PLUS
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: PPUSH
77658: LD_VAR 0 1
77662: PPUSH
77663: CALL 19263 0 3
77667: ST_TO_ADDR
77668: GO 77714
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
77670: LD_ADDR_EXP 78
77674: PUSH
77675: LD_EXP 78
77679: PPUSH
77680: LD_VAR 0 4
77684: PUSH
77685: LD_EXP 78
77689: PUSH
77690: LD_VAR 0 4
77694: ARRAY
77695: PUSH
77696: LD_INT 1
77698: PLUS
77699: PUSH
77700: EMPTY
77701: LIST
77702: LIST
77703: PPUSH
77704: LD_VAR 0 1
77708: PPUSH
77709: CALL 19263 0 3
77713: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
77714: LD_VAR 0 1
77718: PPUSH
77719: CALL_OW 263
77723: PUSH
77724: LD_INT 2
77726: EQUAL
77727: IFFALSE 77747
// begin repeat wait ( 0 0$1 ) ;
77729: LD_INT 35
77731: PPUSH
77732: CALL_OW 67
// until IsControledBy ( vehicle ) ;
77736: LD_VAR 0 1
77740: PPUSH
77741: CALL_OW 312
77745: IFFALSE 77729
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
77747: LD_VAR 0 1
77751: PPUSH
77752: LD_EXP 83
77756: PUSH
77757: LD_VAR 0 4
77761: ARRAY
77762: PPUSH
77763: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
77767: LD_VAR 0 1
77771: PPUSH
77772: CALL_OW 263
77776: PUSH
77777: LD_INT 1
77779: NONEQUAL
77780: IFFALSE 77784
// break ;
77782: GO 77833
// repeat wait ( 0 0$1 ) ;
77784: LD_INT 35
77786: PPUSH
77787: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
77791: LD_VAR 0 1
77795: PPUSH
77796: LD_EXP 83
77800: PUSH
77801: LD_VAR 0 4
77805: ARRAY
77806: PPUSH
77807: CALL_OW 308
77811: IFFALSE 77784
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
77813: LD_VAR 0 1
77817: PPUSH
77818: CALL_OW 311
77822: PPUSH
77823: CALL_OW 121
// exit ;
77827: POP
77828: POP
77829: GO 77835
// end ; end ;
77831: GO 77482
77833: POP
77834: POP
// end ;
77835: LD_VAR 0 3
77839: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
77840: LD_INT 0
77842: PPUSH
77843: PPUSH
77844: PPUSH
77845: PPUSH
// if not mc_bases or not skirmish then
77846: LD_EXP 59
77850: NOT
77851: PUSH
77852: LD_EXP 57
77856: NOT
77857: OR
77858: IFFALSE 77862
// exit ;
77860: GO 78215
// repeat wait ( 0 0$1 ) ;
77862: LD_INT 35
77864: PPUSH
77865: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
77869: LD_VAR 0 2
77873: PPUSH
77874: LD_VAR 0 3
77878: PPUSH
77879: CALL_OW 284
77883: IFFALSE 77862
// if GetResourceTypeXY ( x , y ) = mat_artefact then
77885: LD_VAR 0 2
77889: PPUSH
77890: LD_VAR 0 3
77894: PPUSH
77895: CALL_OW 283
77899: PUSH
77900: LD_INT 4
77902: EQUAL
77903: IFFALSE 77907
// exit ;
77905: GO 78215
// for i = 1 to mc_bases do
77907: LD_ADDR_VAR 0 7
77911: PUSH
77912: DOUBLE
77913: LD_INT 1
77915: DEC
77916: ST_TO_ADDR
77917: LD_EXP 59
77921: PUSH
77922: FOR_TO
77923: IFFALSE 78213
// begin if mc_crates_area [ i ] then
77925: LD_EXP 77
77929: PUSH
77930: LD_VAR 0 7
77934: ARRAY
77935: IFFALSE 78046
// for j in mc_crates_area [ i ] do
77937: LD_ADDR_VAR 0 8
77941: PUSH
77942: LD_EXP 77
77946: PUSH
77947: LD_VAR 0 7
77951: ARRAY
77952: PUSH
77953: FOR_IN
77954: IFFALSE 78044
// if InArea ( x , y , j ) then
77956: LD_VAR 0 2
77960: PPUSH
77961: LD_VAR 0 3
77965: PPUSH
77966: LD_VAR 0 8
77970: PPUSH
77971: CALL_OW 309
77975: IFFALSE 78042
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77977: LD_ADDR_EXP 75
77981: PUSH
77982: LD_EXP 75
77986: PPUSH
77987: LD_VAR 0 7
77991: PUSH
77992: LD_EXP 75
77996: PUSH
77997: LD_VAR 0 7
78001: ARRAY
78002: PUSH
78003: LD_INT 1
78005: PLUS
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PPUSH
78011: LD_VAR 0 4
78015: PUSH
78016: LD_VAR 0 2
78020: PUSH
78021: LD_VAR 0 3
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: LIST
78030: PPUSH
78031: CALL 19263 0 3
78035: ST_TO_ADDR
// exit ;
78036: POP
78037: POP
78038: POP
78039: POP
78040: GO 78215
// end ;
78042: GO 77953
78044: POP
78045: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78046: LD_ADDR_VAR 0 9
78050: PUSH
78051: LD_EXP 59
78055: PUSH
78056: LD_VAR 0 7
78060: ARRAY
78061: PPUSH
78062: LD_INT 2
78064: PUSH
78065: LD_INT 30
78067: PUSH
78068: LD_INT 0
78070: PUSH
78071: EMPTY
78072: LIST
78073: LIST
78074: PUSH
78075: LD_INT 30
78077: PUSH
78078: LD_INT 1
78080: PUSH
78081: EMPTY
78082: LIST
78083: LIST
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: LIST
78089: PPUSH
78090: CALL_OW 72
78094: ST_TO_ADDR
// if not depot then
78095: LD_VAR 0 9
78099: NOT
78100: IFFALSE 78104
// continue ;
78102: GO 77922
// for j in depot do
78104: LD_ADDR_VAR 0 8
78108: PUSH
78109: LD_VAR 0 9
78113: PUSH
78114: FOR_IN
78115: IFFALSE 78209
// if GetDistUnitXY ( j , x , y ) < 30 then
78117: LD_VAR 0 8
78121: PPUSH
78122: LD_VAR 0 2
78126: PPUSH
78127: LD_VAR 0 3
78131: PPUSH
78132: CALL_OW 297
78136: PUSH
78137: LD_INT 30
78139: LESS
78140: IFFALSE 78207
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78142: LD_ADDR_EXP 75
78146: PUSH
78147: LD_EXP 75
78151: PPUSH
78152: LD_VAR 0 7
78156: PUSH
78157: LD_EXP 75
78161: PUSH
78162: LD_VAR 0 7
78166: ARRAY
78167: PUSH
78168: LD_INT 1
78170: PLUS
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PPUSH
78176: LD_VAR 0 4
78180: PUSH
78181: LD_VAR 0 2
78185: PUSH
78186: LD_VAR 0 3
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: LIST
78195: PPUSH
78196: CALL 19263 0 3
78200: ST_TO_ADDR
// exit ;
78201: POP
78202: POP
78203: POP
78204: POP
78205: GO 78215
// end ;
78207: GO 78114
78209: POP
78210: POP
// end ;
78211: GO 77922
78213: POP
78214: POP
// end ;
78215: LD_VAR 0 6
78219: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78220: LD_INT 0
78222: PPUSH
78223: PPUSH
78224: PPUSH
78225: PPUSH
// if not mc_bases or not skirmish then
78226: LD_EXP 59
78230: NOT
78231: PUSH
78232: LD_EXP 57
78236: NOT
78237: OR
78238: IFFALSE 78242
// exit ;
78240: GO 78519
// side := GetSide ( lab ) ;
78242: LD_ADDR_VAR 0 4
78246: PUSH
78247: LD_VAR 0 2
78251: PPUSH
78252: CALL_OW 255
78256: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78257: LD_VAR 0 4
78261: PUSH
78262: LD_EXP 85
78266: IN
78267: NOT
78268: PUSH
78269: LD_EXP 86
78273: NOT
78274: OR
78275: PUSH
78276: LD_EXP 59
78280: NOT
78281: OR
78282: IFFALSE 78286
// exit ;
78284: GO 78519
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78286: LD_ADDR_EXP 86
78290: PUSH
78291: LD_EXP 86
78295: PPUSH
78296: LD_VAR 0 4
78300: PPUSH
78301: LD_EXP 86
78305: PUSH
78306: LD_VAR 0 4
78310: ARRAY
78311: PUSH
78312: LD_VAR 0 1
78316: DIFF
78317: PPUSH
78318: CALL_OW 1
78322: ST_TO_ADDR
// for i = 1 to mc_bases do
78323: LD_ADDR_VAR 0 5
78327: PUSH
78328: DOUBLE
78329: LD_INT 1
78331: DEC
78332: ST_TO_ADDR
78333: LD_EXP 59
78337: PUSH
78338: FOR_TO
78339: IFFALSE 78517
// begin if lab in mc_bases [ i ] then
78341: LD_VAR 0 2
78345: PUSH
78346: LD_EXP 59
78350: PUSH
78351: LD_VAR 0 5
78355: ARRAY
78356: IN
78357: IFFALSE 78515
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78359: LD_VAR 0 1
78363: PUSH
78364: LD_INT 11
78366: PUSH
78367: LD_INT 4
78369: PUSH
78370: LD_INT 3
78372: PUSH
78373: LD_INT 2
78375: PUSH
78376: EMPTY
78377: LIST
78378: LIST
78379: LIST
78380: LIST
78381: IN
78382: PUSH
78383: LD_EXP 89
78387: PUSH
78388: LD_VAR 0 5
78392: ARRAY
78393: AND
78394: IFFALSE 78515
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78396: LD_ADDR_VAR 0 6
78400: PUSH
78401: LD_EXP 89
78405: PUSH
78406: LD_VAR 0 5
78410: ARRAY
78411: PUSH
78412: LD_INT 1
78414: ARRAY
78415: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78416: LD_ADDR_EXP 89
78420: PUSH
78421: LD_EXP 89
78425: PPUSH
78426: LD_VAR 0 5
78430: PPUSH
78431: EMPTY
78432: PPUSH
78433: CALL_OW 1
78437: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78438: LD_VAR 0 6
78442: PPUSH
78443: LD_INT 0
78445: PPUSH
78446: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78450: LD_VAR 0 6
78454: PPUSH
78455: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78459: LD_ADDR_EXP 88
78463: PUSH
78464: LD_EXP 88
78468: PPUSH
78469: LD_VAR 0 5
78473: PPUSH
78474: LD_EXP 88
78478: PUSH
78479: LD_VAR 0 5
78483: ARRAY
78484: PPUSH
78485: LD_INT 1
78487: PPUSH
78488: LD_VAR 0 6
78492: PPUSH
78493: CALL_OW 2
78497: PPUSH
78498: CALL_OW 1
78502: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78503: LD_VAR 0 5
78507: PPUSH
78508: LD_INT 112
78510: PPUSH
78511: CALL 55464 0 2
// end ; end ; end ;
78515: GO 78338
78517: POP
78518: POP
// end ;
78519: LD_VAR 0 3
78523: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78524: LD_INT 0
78526: PPUSH
78527: PPUSH
78528: PPUSH
78529: PPUSH
78530: PPUSH
78531: PPUSH
78532: PPUSH
78533: PPUSH
// if not mc_bases or not skirmish then
78534: LD_EXP 59
78538: NOT
78539: PUSH
78540: LD_EXP 57
78544: NOT
78545: OR
78546: IFFALSE 78550
// exit ;
78548: GO 79921
// for i = 1 to mc_bases do
78550: LD_ADDR_VAR 0 3
78554: PUSH
78555: DOUBLE
78556: LD_INT 1
78558: DEC
78559: ST_TO_ADDR
78560: LD_EXP 59
78564: PUSH
78565: FOR_TO
78566: IFFALSE 79919
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
78568: LD_VAR 0 1
78572: PUSH
78573: LD_EXP 59
78577: PUSH
78578: LD_VAR 0 3
78582: ARRAY
78583: IN
78584: PUSH
78585: LD_VAR 0 1
78589: PUSH
78590: LD_EXP 66
78594: PUSH
78595: LD_VAR 0 3
78599: ARRAY
78600: IN
78601: OR
78602: PUSH
78603: LD_VAR 0 1
78607: PUSH
78608: LD_EXP 81
78612: PUSH
78613: LD_VAR 0 3
78617: ARRAY
78618: IN
78619: OR
78620: PUSH
78621: LD_VAR 0 1
78625: PUSH
78626: LD_EXP 78
78630: PUSH
78631: LD_VAR 0 3
78635: ARRAY
78636: IN
78637: OR
78638: PUSH
78639: LD_VAR 0 1
78643: PUSH
78644: LD_EXP 88
78648: PUSH
78649: LD_VAR 0 3
78653: ARRAY
78654: IN
78655: OR
78656: PUSH
78657: LD_VAR 0 1
78661: PUSH
78662: LD_EXP 89
78666: PUSH
78667: LD_VAR 0 3
78671: ARRAY
78672: IN
78673: OR
78674: IFFALSE 79917
// begin if un in mc_ape [ i ] then
78676: LD_VAR 0 1
78680: PUSH
78681: LD_EXP 88
78685: PUSH
78686: LD_VAR 0 3
78690: ARRAY
78691: IN
78692: IFFALSE 78731
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
78694: LD_ADDR_EXP 88
78698: PUSH
78699: LD_EXP 88
78703: PPUSH
78704: LD_VAR 0 3
78708: PPUSH
78709: LD_EXP 88
78713: PUSH
78714: LD_VAR 0 3
78718: ARRAY
78719: PUSH
78720: LD_VAR 0 1
78724: DIFF
78725: PPUSH
78726: CALL_OW 1
78730: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
78731: LD_VAR 0 1
78735: PUSH
78736: LD_EXP 89
78740: PUSH
78741: LD_VAR 0 3
78745: ARRAY
78746: IN
78747: IFFALSE 78771
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78749: LD_ADDR_EXP 89
78753: PUSH
78754: LD_EXP 89
78758: PPUSH
78759: LD_VAR 0 3
78763: PPUSH
78764: EMPTY
78765: PPUSH
78766: CALL_OW 1
78770: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
78771: LD_VAR 0 1
78775: PPUSH
78776: CALL_OW 247
78780: PUSH
78781: LD_INT 2
78783: EQUAL
78784: PUSH
78785: LD_VAR 0 1
78789: PPUSH
78790: CALL_OW 110
78794: PUSH
78795: LD_INT 20
78797: EQUAL
78798: PUSH
78799: LD_VAR 0 1
78803: PUSH
78804: LD_EXP 81
78808: PUSH
78809: LD_VAR 0 3
78813: ARRAY
78814: IN
78815: OR
78816: PUSH
78817: LD_VAR 0 1
78821: PPUSH
78822: CALL_OW 264
78826: PUSH
78827: LD_INT 12
78829: PUSH
78830: LD_INT 51
78832: PUSH
78833: LD_EXP 103
78837: PUSH
78838: LD_INT 32
78840: PUSH
78841: LD_INT 13
78843: PUSH
78844: LD_INT 52
78846: PUSH
78847: LD_INT 31
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: LIST
78854: LIST
78855: LIST
78856: LIST
78857: LIST
78858: IN
78859: OR
78860: AND
78861: IFFALSE 79169
// begin if un in mc_defender [ i ] then
78863: LD_VAR 0 1
78867: PUSH
78868: LD_EXP 81
78872: PUSH
78873: LD_VAR 0 3
78877: ARRAY
78878: IN
78879: IFFALSE 78918
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78881: LD_ADDR_EXP 81
78885: PUSH
78886: LD_EXP 81
78890: PPUSH
78891: LD_VAR 0 3
78895: PPUSH
78896: LD_EXP 81
78900: PUSH
78901: LD_VAR 0 3
78905: ARRAY
78906: PUSH
78907: LD_VAR 0 1
78911: DIFF
78912: PPUSH
78913: CALL_OW 1
78917: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
78918: LD_ADDR_VAR 0 8
78922: PUSH
78923: LD_VAR 0 3
78927: PPUSH
78928: LD_INT 3
78930: PPUSH
78931: CALL 75568 0 2
78935: ST_TO_ADDR
// if fac then
78936: LD_VAR 0 8
78940: IFFALSE 79169
// begin for j in fac do
78942: LD_ADDR_VAR 0 4
78946: PUSH
78947: LD_VAR 0 8
78951: PUSH
78952: FOR_IN
78953: IFFALSE 79167
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
78955: LD_ADDR_VAR 0 9
78959: PUSH
78960: LD_VAR 0 8
78964: PPUSH
78965: LD_VAR 0 1
78969: PPUSH
78970: CALL_OW 265
78974: PPUSH
78975: LD_VAR 0 1
78979: PPUSH
78980: CALL_OW 262
78984: PPUSH
78985: LD_VAR 0 1
78989: PPUSH
78990: CALL_OW 263
78994: PPUSH
78995: LD_VAR 0 1
78999: PPUSH
79000: CALL_OW 264
79004: PPUSH
79005: CALL 16795 0 5
79009: ST_TO_ADDR
// if components then
79010: LD_VAR 0 9
79014: IFFALSE 79165
// begin if GetWeapon ( un ) = ar_control_tower then
79016: LD_VAR 0 1
79020: PPUSH
79021: CALL_OW 264
79025: PUSH
79026: LD_INT 31
79028: EQUAL
79029: IFFALSE 79146
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79031: LD_VAR 0 1
79035: PPUSH
79036: CALL_OW 311
79040: PPUSH
79041: LD_INT 0
79043: PPUSH
79044: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79048: LD_ADDR_EXP 99
79052: PUSH
79053: LD_EXP 99
79057: PPUSH
79058: LD_VAR 0 3
79062: PPUSH
79063: LD_EXP 99
79067: PUSH
79068: LD_VAR 0 3
79072: ARRAY
79073: PUSH
79074: LD_VAR 0 1
79078: PPUSH
79079: CALL_OW 311
79083: DIFF
79084: PPUSH
79085: CALL_OW 1
79089: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79090: LD_ADDR_VAR 0 7
79094: PUSH
79095: LD_EXP 80
79099: PUSH
79100: LD_VAR 0 3
79104: ARRAY
79105: PPUSH
79106: LD_INT 1
79108: PPUSH
79109: LD_VAR 0 9
79113: PPUSH
79114: CALL_OW 2
79118: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79119: LD_ADDR_EXP 80
79123: PUSH
79124: LD_EXP 80
79128: PPUSH
79129: LD_VAR 0 3
79133: PPUSH
79134: LD_VAR 0 7
79138: PPUSH
79139: CALL_OW 1
79143: ST_TO_ADDR
// end else
79144: GO 79163
// MC_InsertProduceList ( i , [ components ] ) ;
79146: LD_VAR 0 3
79150: PPUSH
79151: LD_VAR 0 9
79155: PUSH
79156: EMPTY
79157: LIST
79158: PPUSH
79159: CALL 75113 0 2
// break ;
79163: GO 79167
// end ; end ;
79165: GO 78952
79167: POP
79168: POP
// end ; end ; if GetType ( un ) = unit_building then
79169: LD_VAR 0 1
79173: PPUSH
79174: CALL_OW 247
79178: PUSH
79179: LD_INT 3
79181: EQUAL
79182: IFFALSE 79585
// begin btype := GetBType ( un ) ;
79184: LD_ADDR_VAR 0 5
79188: PUSH
79189: LD_VAR 0 1
79193: PPUSH
79194: CALL_OW 266
79198: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79199: LD_VAR 0 5
79203: PUSH
79204: LD_INT 29
79206: PUSH
79207: LD_INT 30
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: IN
79214: IFFALSE 79287
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79216: LD_VAR 0 1
79220: PPUSH
79221: CALL_OW 250
79225: PPUSH
79226: LD_VAR 0 1
79230: PPUSH
79231: CALL_OW 251
79235: PPUSH
79236: LD_VAR 0 1
79240: PPUSH
79241: CALL_OW 255
79245: PPUSH
79246: CALL_OW 440
79250: NOT
79251: IFFALSE 79287
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79253: LD_VAR 0 1
79257: PPUSH
79258: CALL_OW 250
79262: PPUSH
79263: LD_VAR 0 1
79267: PPUSH
79268: CALL_OW 251
79272: PPUSH
79273: LD_VAR 0 1
79277: PPUSH
79278: CALL_OW 255
79282: PPUSH
79283: CALL_OW 441
// end ; if btype = b_warehouse then
79287: LD_VAR 0 5
79291: PUSH
79292: LD_INT 1
79294: EQUAL
79295: IFFALSE 79313
// begin btype := b_depot ;
79297: LD_ADDR_VAR 0 5
79301: PUSH
79302: LD_INT 0
79304: ST_TO_ADDR
// pos := 1 ;
79305: LD_ADDR_VAR 0 6
79309: PUSH
79310: LD_INT 1
79312: ST_TO_ADDR
// end ; if btype = b_factory then
79313: LD_VAR 0 5
79317: PUSH
79318: LD_INT 3
79320: EQUAL
79321: IFFALSE 79339
// begin btype := b_workshop ;
79323: LD_ADDR_VAR 0 5
79327: PUSH
79328: LD_INT 2
79330: ST_TO_ADDR
// pos := 1 ;
79331: LD_ADDR_VAR 0 6
79335: PUSH
79336: LD_INT 1
79338: ST_TO_ADDR
// end ; if btype = b_barracks then
79339: LD_VAR 0 5
79343: PUSH
79344: LD_INT 5
79346: EQUAL
79347: IFFALSE 79357
// btype := b_armoury ;
79349: LD_ADDR_VAR 0 5
79353: PUSH
79354: LD_INT 4
79356: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79357: LD_VAR 0 5
79361: PUSH
79362: LD_INT 7
79364: PUSH
79365: LD_INT 8
79367: PUSH
79368: EMPTY
79369: LIST
79370: LIST
79371: IN
79372: IFFALSE 79382
// btype := b_lab ;
79374: LD_ADDR_VAR 0 5
79378: PUSH
79379: LD_INT 6
79381: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79382: LD_ADDR_EXP 64
79386: PUSH
79387: LD_EXP 64
79391: PPUSH
79392: LD_VAR 0 3
79396: PUSH
79397: LD_EXP 64
79401: PUSH
79402: LD_VAR 0 3
79406: ARRAY
79407: PUSH
79408: LD_INT 1
79410: PLUS
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PPUSH
79416: LD_VAR 0 5
79420: PUSH
79421: LD_VAR 0 1
79425: PPUSH
79426: CALL_OW 250
79430: PUSH
79431: LD_VAR 0 1
79435: PPUSH
79436: CALL_OW 251
79440: PUSH
79441: LD_VAR 0 1
79445: PPUSH
79446: CALL_OW 254
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: LIST
79455: LIST
79456: PPUSH
79457: CALL 19263 0 3
79461: ST_TO_ADDR
// if pos = 1 then
79462: LD_VAR 0 6
79466: PUSH
79467: LD_INT 1
79469: EQUAL
79470: IFFALSE 79585
// begin tmp := mc_build_list [ i ] ;
79472: LD_ADDR_VAR 0 7
79476: PUSH
79477: LD_EXP 64
79481: PUSH
79482: LD_VAR 0 3
79486: ARRAY
79487: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79488: LD_VAR 0 7
79492: PPUSH
79493: LD_INT 2
79495: PUSH
79496: LD_INT 30
79498: PUSH
79499: LD_INT 0
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: LD_INT 30
79508: PUSH
79509: LD_INT 1
79511: PUSH
79512: EMPTY
79513: LIST
79514: LIST
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: LIST
79520: PPUSH
79521: CALL_OW 72
79525: IFFALSE 79535
// pos := 2 ;
79527: LD_ADDR_VAR 0 6
79531: PUSH
79532: LD_INT 2
79534: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79535: LD_ADDR_VAR 0 7
79539: PUSH
79540: LD_VAR 0 7
79544: PPUSH
79545: LD_VAR 0 6
79549: PPUSH
79550: LD_VAR 0 7
79554: PPUSH
79555: CALL 19589 0 3
79559: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79560: LD_ADDR_EXP 64
79564: PUSH
79565: LD_EXP 64
79569: PPUSH
79570: LD_VAR 0 3
79574: PPUSH
79575: LD_VAR 0 7
79579: PPUSH
79580: CALL_OW 1
79584: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
79585: LD_VAR 0 1
79589: PUSH
79590: LD_EXP 59
79594: PUSH
79595: LD_VAR 0 3
79599: ARRAY
79600: IN
79601: IFFALSE 79640
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
79603: LD_ADDR_EXP 59
79607: PUSH
79608: LD_EXP 59
79612: PPUSH
79613: LD_VAR 0 3
79617: PPUSH
79618: LD_EXP 59
79622: PUSH
79623: LD_VAR 0 3
79627: ARRAY
79628: PUSH
79629: LD_VAR 0 1
79633: DIFF
79634: PPUSH
79635: CALL_OW 1
79639: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
79640: LD_VAR 0 1
79644: PUSH
79645: LD_EXP 66
79649: PUSH
79650: LD_VAR 0 3
79654: ARRAY
79655: IN
79656: IFFALSE 79695
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
79658: LD_ADDR_EXP 66
79662: PUSH
79663: LD_EXP 66
79667: PPUSH
79668: LD_VAR 0 3
79672: PPUSH
79673: LD_EXP 66
79677: PUSH
79678: LD_VAR 0 3
79682: ARRAY
79683: PUSH
79684: LD_VAR 0 1
79688: DIFF
79689: PPUSH
79690: CALL_OW 1
79694: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
79695: LD_VAR 0 1
79699: PUSH
79700: LD_EXP 78
79704: PUSH
79705: LD_VAR 0 3
79709: ARRAY
79710: IN
79711: IFFALSE 79750
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
79713: LD_ADDR_EXP 78
79717: PUSH
79718: LD_EXP 78
79722: PPUSH
79723: LD_VAR 0 3
79727: PPUSH
79728: LD_EXP 78
79732: PUSH
79733: LD_VAR 0 3
79737: ARRAY
79738: PUSH
79739: LD_VAR 0 1
79743: DIFF
79744: PPUSH
79745: CALL_OW 1
79749: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
79750: LD_VAR 0 1
79754: PUSH
79755: LD_EXP 81
79759: PUSH
79760: LD_VAR 0 3
79764: ARRAY
79765: IN
79766: IFFALSE 79805
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79768: LD_ADDR_EXP 81
79772: PUSH
79773: LD_EXP 81
79777: PPUSH
79778: LD_VAR 0 3
79782: PPUSH
79783: LD_EXP 81
79787: PUSH
79788: LD_VAR 0 3
79792: ARRAY
79793: PUSH
79794: LD_VAR 0 1
79798: DIFF
79799: PPUSH
79800: CALL_OW 1
79804: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
79805: LD_VAR 0 1
79809: PUSH
79810: LD_EXP 68
79814: PUSH
79815: LD_VAR 0 3
79819: ARRAY
79820: IN
79821: IFFALSE 79860
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
79823: LD_ADDR_EXP 68
79827: PUSH
79828: LD_EXP 68
79832: PPUSH
79833: LD_VAR 0 3
79837: PPUSH
79838: LD_EXP 68
79842: PUSH
79843: LD_VAR 0 3
79847: ARRAY
79848: PUSH
79849: LD_VAR 0 1
79853: DIFF
79854: PPUSH
79855: CALL_OW 1
79859: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
79860: LD_VAR 0 1
79864: PUSH
79865: LD_EXP 67
79869: PUSH
79870: LD_VAR 0 3
79874: ARRAY
79875: IN
79876: IFFALSE 79915
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
79878: LD_ADDR_EXP 67
79882: PUSH
79883: LD_EXP 67
79887: PPUSH
79888: LD_VAR 0 3
79892: PPUSH
79893: LD_EXP 67
79897: PUSH
79898: LD_VAR 0 3
79902: ARRAY
79903: PUSH
79904: LD_VAR 0 1
79908: DIFF
79909: PPUSH
79910: CALL_OW 1
79914: ST_TO_ADDR
// end ; break ;
79915: GO 79919
// end ;
79917: GO 78565
79919: POP
79920: POP
// end ;
79921: LD_VAR 0 2
79925: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
79926: LD_INT 0
79928: PPUSH
79929: PPUSH
79930: PPUSH
// if not mc_bases or not skirmish then
79931: LD_EXP 59
79935: NOT
79936: PUSH
79937: LD_EXP 57
79941: NOT
79942: OR
79943: IFFALSE 79947
// exit ;
79945: GO 80162
// for i = 1 to mc_bases do
79947: LD_ADDR_VAR 0 3
79951: PUSH
79952: DOUBLE
79953: LD_INT 1
79955: DEC
79956: ST_TO_ADDR
79957: LD_EXP 59
79961: PUSH
79962: FOR_TO
79963: IFFALSE 80160
// begin if building in mc_construct_list [ i ] then
79965: LD_VAR 0 1
79969: PUSH
79970: LD_EXP 66
79974: PUSH
79975: LD_VAR 0 3
79979: ARRAY
79980: IN
79981: IFFALSE 80158
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79983: LD_ADDR_EXP 66
79987: PUSH
79988: LD_EXP 66
79992: PPUSH
79993: LD_VAR 0 3
79997: PPUSH
79998: LD_EXP 66
80002: PUSH
80003: LD_VAR 0 3
80007: ARRAY
80008: PUSH
80009: LD_VAR 0 1
80013: DIFF
80014: PPUSH
80015: CALL_OW 1
80019: ST_TO_ADDR
// if building in mc_lab [ i ] then
80020: LD_VAR 0 1
80024: PUSH
80025: LD_EXP 92
80029: PUSH
80030: LD_VAR 0 3
80034: ARRAY
80035: IN
80036: IFFALSE 80091
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80038: LD_ADDR_EXP 93
80042: PUSH
80043: LD_EXP 93
80047: PPUSH
80048: LD_VAR 0 3
80052: PPUSH
80053: LD_EXP 93
80057: PUSH
80058: LD_VAR 0 3
80062: ARRAY
80063: PPUSH
80064: LD_INT 1
80066: PPUSH
80067: LD_EXP 93
80071: PUSH
80072: LD_VAR 0 3
80076: ARRAY
80077: PPUSH
80078: LD_INT 0
80080: PPUSH
80081: CALL 18681 0 4
80085: PPUSH
80086: CALL_OW 1
80090: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80091: LD_VAR 0 1
80095: PUSH
80096: LD_EXP 59
80100: PUSH
80101: LD_VAR 0 3
80105: ARRAY
80106: IN
80107: NOT
80108: IFFALSE 80154
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80110: LD_ADDR_EXP 59
80114: PUSH
80115: LD_EXP 59
80119: PPUSH
80120: LD_VAR 0 3
80124: PUSH
80125: LD_EXP 59
80129: PUSH
80130: LD_VAR 0 3
80134: ARRAY
80135: PUSH
80136: LD_INT 1
80138: PLUS
80139: PUSH
80140: EMPTY
80141: LIST
80142: LIST
80143: PPUSH
80144: LD_VAR 0 1
80148: PPUSH
80149: CALL 19263 0 3
80153: ST_TO_ADDR
// exit ;
80154: POP
80155: POP
80156: GO 80162
// end ; end ;
80158: GO 79962
80160: POP
80161: POP
// end ;
80162: LD_VAR 0 2
80166: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80167: LD_INT 0
80169: PPUSH
80170: PPUSH
80171: PPUSH
80172: PPUSH
80173: PPUSH
80174: PPUSH
80175: PPUSH
// if not mc_bases or not skirmish then
80176: LD_EXP 59
80180: NOT
80181: PUSH
80182: LD_EXP 57
80186: NOT
80187: OR
80188: IFFALSE 80192
// exit ;
80190: GO 80853
// for i = 1 to mc_bases do
80192: LD_ADDR_VAR 0 3
80196: PUSH
80197: DOUBLE
80198: LD_INT 1
80200: DEC
80201: ST_TO_ADDR
80202: LD_EXP 59
80206: PUSH
80207: FOR_TO
80208: IFFALSE 80851
// begin if building in mc_construct_list [ i ] then
80210: LD_VAR 0 1
80214: PUSH
80215: LD_EXP 66
80219: PUSH
80220: LD_VAR 0 3
80224: ARRAY
80225: IN
80226: IFFALSE 80849
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80228: LD_ADDR_EXP 66
80232: PUSH
80233: LD_EXP 66
80237: PPUSH
80238: LD_VAR 0 3
80242: PPUSH
80243: LD_EXP 66
80247: PUSH
80248: LD_VAR 0 3
80252: ARRAY
80253: PUSH
80254: LD_VAR 0 1
80258: DIFF
80259: PPUSH
80260: CALL_OW 1
80264: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80265: LD_ADDR_EXP 59
80269: PUSH
80270: LD_EXP 59
80274: PPUSH
80275: LD_VAR 0 3
80279: PUSH
80280: LD_EXP 59
80284: PUSH
80285: LD_VAR 0 3
80289: ARRAY
80290: PUSH
80291: LD_INT 1
80293: PLUS
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PPUSH
80299: LD_VAR 0 1
80303: PPUSH
80304: CALL 19263 0 3
80308: ST_TO_ADDR
// btype := GetBType ( building ) ;
80309: LD_ADDR_VAR 0 5
80313: PUSH
80314: LD_VAR 0 1
80318: PPUSH
80319: CALL_OW 266
80323: ST_TO_ADDR
// side := GetSide ( building ) ;
80324: LD_ADDR_VAR 0 8
80328: PUSH
80329: LD_VAR 0 1
80333: PPUSH
80334: CALL_OW 255
80338: ST_TO_ADDR
// if btype = b_lab then
80339: LD_VAR 0 5
80343: PUSH
80344: LD_INT 6
80346: EQUAL
80347: IFFALSE 80397
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80349: LD_ADDR_EXP 92
80353: PUSH
80354: LD_EXP 92
80358: PPUSH
80359: LD_VAR 0 3
80363: PUSH
80364: LD_EXP 92
80368: PUSH
80369: LD_VAR 0 3
80373: ARRAY
80374: PUSH
80375: LD_INT 1
80377: PLUS
80378: PUSH
80379: EMPTY
80380: LIST
80381: LIST
80382: PPUSH
80383: LD_VAR 0 1
80387: PPUSH
80388: CALL 19263 0 3
80392: ST_TO_ADDR
// exit ;
80393: POP
80394: POP
80395: GO 80853
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80397: LD_VAR 0 5
80401: PUSH
80402: LD_INT 0
80404: PUSH
80405: LD_INT 2
80407: PUSH
80408: LD_INT 4
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: LIST
80415: IN
80416: IFFALSE 80540
// begin if btype = b_armoury then
80418: LD_VAR 0 5
80422: PUSH
80423: LD_INT 4
80425: EQUAL
80426: IFFALSE 80436
// btype := b_barracks ;
80428: LD_ADDR_VAR 0 5
80432: PUSH
80433: LD_INT 5
80435: ST_TO_ADDR
// if btype = b_depot then
80436: LD_VAR 0 5
80440: PUSH
80441: LD_INT 0
80443: EQUAL
80444: IFFALSE 80454
// btype := b_warehouse ;
80446: LD_ADDR_VAR 0 5
80450: PUSH
80451: LD_INT 1
80453: ST_TO_ADDR
// if btype = b_workshop then
80454: LD_VAR 0 5
80458: PUSH
80459: LD_INT 2
80461: EQUAL
80462: IFFALSE 80472
// btype := b_factory ;
80464: LD_ADDR_VAR 0 5
80468: PUSH
80469: LD_INT 3
80471: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80472: LD_VAR 0 5
80476: PPUSH
80477: LD_VAR 0 8
80481: PPUSH
80482: CALL_OW 323
80486: PUSH
80487: LD_INT 1
80489: EQUAL
80490: IFFALSE 80536
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80492: LD_ADDR_EXP 91
80496: PUSH
80497: LD_EXP 91
80501: PPUSH
80502: LD_VAR 0 3
80506: PUSH
80507: LD_EXP 91
80511: PUSH
80512: LD_VAR 0 3
80516: ARRAY
80517: PUSH
80518: LD_INT 1
80520: PLUS
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PPUSH
80526: LD_VAR 0 1
80530: PPUSH
80531: CALL 19263 0 3
80535: ST_TO_ADDR
// exit ;
80536: POP
80537: POP
80538: GO 80853
// end ; if btype in [ b_bunker , b_turret ] then
80540: LD_VAR 0 5
80544: PUSH
80545: LD_INT 32
80547: PUSH
80548: LD_INT 33
80550: PUSH
80551: EMPTY
80552: LIST
80553: LIST
80554: IN
80555: IFFALSE 80845
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80557: LD_ADDR_EXP 67
80561: PUSH
80562: LD_EXP 67
80566: PPUSH
80567: LD_VAR 0 3
80571: PUSH
80572: LD_EXP 67
80576: PUSH
80577: LD_VAR 0 3
80581: ARRAY
80582: PUSH
80583: LD_INT 1
80585: PLUS
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PPUSH
80591: LD_VAR 0 1
80595: PPUSH
80596: CALL 19263 0 3
80600: ST_TO_ADDR
// if btype = b_bunker then
80601: LD_VAR 0 5
80605: PUSH
80606: LD_INT 32
80608: EQUAL
80609: IFFALSE 80845
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80611: LD_ADDR_EXP 68
80615: PUSH
80616: LD_EXP 68
80620: PPUSH
80621: LD_VAR 0 3
80625: PUSH
80626: LD_EXP 68
80630: PUSH
80631: LD_VAR 0 3
80635: ARRAY
80636: PUSH
80637: LD_INT 1
80639: PLUS
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PPUSH
80645: LD_VAR 0 1
80649: PPUSH
80650: CALL 19263 0 3
80654: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
80655: LD_ADDR_VAR 0 6
80659: PUSH
80660: LD_EXP 59
80664: PUSH
80665: LD_VAR 0 3
80669: ARRAY
80670: PPUSH
80671: LD_INT 25
80673: PUSH
80674: LD_INT 1
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 3
80683: PUSH
80684: LD_INT 54
80686: PUSH
80687: EMPTY
80688: LIST
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: PUSH
80694: EMPTY
80695: LIST
80696: LIST
80697: PPUSH
80698: CALL_OW 72
80702: ST_TO_ADDR
// if tmp then
80703: LD_VAR 0 6
80707: IFFALSE 80713
// exit ;
80709: POP
80710: POP
80711: GO 80853
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80713: LD_ADDR_VAR 0 6
80717: PUSH
80718: LD_EXP 59
80722: PUSH
80723: LD_VAR 0 3
80727: ARRAY
80728: PPUSH
80729: LD_INT 2
80731: PUSH
80732: LD_INT 30
80734: PUSH
80735: LD_INT 4
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 30
80744: PUSH
80745: LD_INT 5
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: LIST
80756: PPUSH
80757: CALL_OW 72
80761: ST_TO_ADDR
// if not tmp then
80762: LD_VAR 0 6
80766: NOT
80767: IFFALSE 80773
// exit ;
80769: POP
80770: POP
80771: GO 80853
// for j in tmp do
80773: LD_ADDR_VAR 0 4
80777: PUSH
80778: LD_VAR 0 6
80782: PUSH
80783: FOR_IN
80784: IFFALSE 80843
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
80786: LD_ADDR_VAR 0 7
80790: PUSH
80791: LD_VAR 0 4
80795: PPUSH
80796: CALL_OW 313
80800: PPUSH
80801: LD_INT 25
80803: PUSH
80804: LD_INT 1
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PPUSH
80811: CALL_OW 72
80815: ST_TO_ADDR
// if units then
80816: LD_VAR 0 7
80820: IFFALSE 80841
// begin ComExitBuilding ( units [ 1 ] ) ;
80822: LD_VAR 0 7
80826: PUSH
80827: LD_INT 1
80829: ARRAY
80830: PPUSH
80831: CALL_OW 122
// exit ;
80835: POP
80836: POP
80837: POP
80838: POP
80839: GO 80853
// end ; end ;
80841: GO 80783
80843: POP
80844: POP
// end ; end ; exit ;
80845: POP
80846: POP
80847: GO 80853
// end ; end ;
80849: GO 80207
80851: POP
80852: POP
// end ;
80853: LD_VAR 0 2
80857: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
80858: LD_INT 0
80860: PPUSH
80861: PPUSH
80862: PPUSH
80863: PPUSH
80864: PPUSH
80865: PPUSH
80866: PPUSH
// if not mc_bases or not skirmish then
80867: LD_EXP 59
80871: NOT
80872: PUSH
80873: LD_EXP 57
80877: NOT
80878: OR
80879: IFFALSE 80883
// exit ;
80881: GO 81114
// btype := GetBType ( building ) ;
80883: LD_ADDR_VAR 0 6
80887: PUSH
80888: LD_VAR 0 1
80892: PPUSH
80893: CALL_OW 266
80897: ST_TO_ADDR
// x := GetX ( building ) ;
80898: LD_ADDR_VAR 0 7
80902: PUSH
80903: LD_VAR 0 1
80907: PPUSH
80908: CALL_OW 250
80912: ST_TO_ADDR
// y := GetY ( building ) ;
80913: LD_ADDR_VAR 0 8
80917: PUSH
80918: LD_VAR 0 1
80922: PPUSH
80923: CALL_OW 251
80927: ST_TO_ADDR
// d := GetDir ( building ) ;
80928: LD_ADDR_VAR 0 9
80932: PUSH
80933: LD_VAR 0 1
80937: PPUSH
80938: CALL_OW 254
80942: ST_TO_ADDR
// for i = 1 to mc_bases do
80943: LD_ADDR_VAR 0 4
80947: PUSH
80948: DOUBLE
80949: LD_INT 1
80951: DEC
80952: ST_TO_ADDR
80953: LD_EXP 59
80957: PUSH
80958: FOR_TO
80959: IFFALSE 81112
// begin if not mc_build_list [ i ] then
80961: LD_EXP 64
80965: PUSH
80966: LD_VAR 0 4
80970: ARRAY
80971: NOT
80972: IFFALSE 80976
// continue ;
80974: GO 80958
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
80976: LD_VAR 0 6
80980: PUSH
80981: LD_VAR 0 7
80985: PUSH
80986: LD_VAR 0 8
80990: PUSH
80991: LD_VAR 0 9
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: PPUSH
81002: LD_EXP 64
81006: PUSH
81007: LD_VAR 0 4
81011: ARRAY
81012: PUSH
81013: LD_INT 1
81015: ARRAY
81016: PPUSH
81017: CALL 25432 0 2
81021: IFFALSE 81110
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
81023: LD_ADDR_EXP 64
81027: PUSH
81028: LD_EXP 64
81032: PPUSH
81033: LD_VAR 0 4
81037: PPUSH
81038: LD_EXP 64
81042: PUSH
81043: LD_VAR 0 4
81047: ARRAY
81048: PPUSH
81049: LD_INT 1
81051: PPUSH
81052: CALL_OW 3
81056: PPUSH
81057: CALL_OW 1
81061: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81062: LD_ADDR_EXP 66
81066: PUSH
81067: LD_EXP 66
81071: PPUSH
81072: LD_VAR 0 4
81076: PUSH
81077: LD_EXP 66
81081: PUSH
81082: LD_VAR 0 4
81086: ARRAY
81087: PUSH
81088: LD_INT 1
81090: PLUS
81091: PUSH
81092: EMPTY
81093: LIST
81094: LIST
81095: PPUSH
81096: LD_VAR 0 1
81100: PPUSH
81101: CALL 19263 0 3
81105: ST_TO_ADDR
// exit ;
81106: POP
81107: POP
81108: GO 81114
// end ; end ;
81110: GO 80958
81112: POP
81113: POP
// end ;
81114: LD_VAR 0 3
81118: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81119: LD_INT 0
81121: PPUSH
81122: PPUSH
81123: PPUSH
// if not mc_bases or not skirmish then
81124: LD_EXP 59
81128: NOT
81129: PUSH
81130: LD_EXP 57
81134: NOT
81135: OR
81136: IFFALSE 81140
// exit ;
81138: GO 81330
// for i = 1 to mc_bases do
81140: LD_ADDR_VAR 0 4
81144: PUSH
81145: DOUBLE
81146: LD_INT 1
81148: DEC
81149: ST_TO_ADDR
81150: LD_EXP 59
81154: PUSH
81155: FOR_TO
81156: IFFALSE 81243
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81158: LD_VAR 0 1
81162: PUSH
81163: LD_EXP 67
81167: PUSH
81168: LD_VAR 0 4
81172: ARRAY
81173: IN
81174: PUSH
81175: LD_VAR 0 1
81179: PUSH
81180: LD_EXP 68
81184: PUSH
81185: LD_VAR 0 4
81189: ARRAY
81190: IN
81191: NOT
81192: AND
81193: IFFALSE 81241
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81195: LD_ADDR_EXP 68
81199: PUSH
81200: LD_EXP 68
81204: PPUSH
81205: LD_VAR 0 4
81209: PUSH
81210: LD_EXP 68
81214: PUSH
81215: LD_VAR 0 4
81219: ARRAY
81220: PUSH
81221: LD_INT 1
81223: PLUS
81224: PUSH
81225: EMPTY
81226: LIST
81227: LIST
81228: PPUSH
81229: LD_VAR 0 1
81233: PPUSH
81234: CALL 19263 0 3
81238: ST_TO_ADDR
// break ;
81239: GO 81243
// end ; end ;
81241: GO 81155
81243: POP
81244: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81245: LD_VAR 0 1
81249: PPUSH
81250: CALL_OW 257
81254: PUSH
81255: LD_EXP 85
81259: IN
81260: PUSH
81261: LD_VAR 0 1
81265: PPUSH
81266: CALL_OW 266
81270: PUSH
81271: LD_INT 5
81273: EQUAL
81274: AND
81275: PUSH
81276: LD_VAR 0 2
81280: PPUSH
81281: CALL_OW 110
81285: PUSH
81286: LD_INT 18
81288: NONEQUAL
81289: AND
81290: IFFALSE 81330
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81292: LD_VAR 0 2
81296: PPUSH
81297: CALL_OW 257
81301: PUSH
81302: LD_INT 5
81304: PUSH
81305: LD_INT 8
81307: PUSH
81308: LD_INT 9
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: LIST
81315: IN
81316: IFFALSE 81330
// SetClass ( unit , 1 ) ;
81318: LD_VAR 0 2
81322: PPUSH
81323: LD_INT 1
81325: PPUSH
81326: CALL_OW 336
// end ;
81330: LD_VAR 0 3
81334: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81335: LD_INT 0
81337: PPUSH
81338: PPUSH
// if not mc_bases or not skirmish then
81339: LD_EXP 59
81343: NOT
81344: PUSH
81345: LD_EXP 57
81349: NOT
81350: OR
81351: IFFALSE 81355
// exit ;
81353: GO 81471
// if GetLives ( abandoned_vehicle ) > 250 then
81355: LD_VAR 0 2
81359: PPUSH
81360: CALL_OW 256
81364: PUSH
81365: LD_INT 250
81367: GREATER
81368: IFFALSE 81372
// exit ;
81370: GO 81471
// for i = 1 to mc_bases do
81372: LD_ADDR_VAR 0 6
81376: PUSH
81377: DOUBLE
81378: LD_INT 1
81380: DEC
81381: ST_TO_ADDR
81382: LD_EXP 59
81386: PUSH
81387: FOR_TO
81388: IFFALSE 81469
// begin if driver in mc_bases [ i ] then
81390: LD_VAR 0 1
81394: PUSH
81395: LD_EXP 59
81399: PUSH
81400: LD_VAR 0 6
81404: ARRAY
81405: IN
81406: IFFALSE 81467
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81408: LD_VAR 0 1
81412: PPUSH
81413: LD_EXP 59
81417: PUSH
81418: LD_VAR 0 6
81422: ARRAY
81423: PPUSH
81424: LD_INT 2
81426: PUSH
81427: LD_INT 30
81429: PUSH
81430: LD_INT 0
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: PUSH
81437: LD_INT 30
81439: PUSH
81440: LD_INT 1
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: LIST
81451: PPUSH
81452: CALL_OW 72
81456: PUSH
81457: LD_INT 1
81459: ARRAY
81460: PPUSH
81461: CALL 51129 0 2
// break ;
81465: GO 81469
// end ; end ;
81467: GO 81387
81469: POP
81470: POP
// end ; end_of_file
81471: LD_VAR 0 5
81475: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
81476: LD_INT 0
81478: PPUSH
// ar_miner := 81 ;
81479: LD_ADDR_EXP 109
81483: PUSH
81484: LD_INT 81
81486: ST_TO_ADDR
// ar_crane := 88 ;
81487: LD_ADDR_EXP 108
81491: PUSH
81492: LD_INT 88
81494: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
81495: LD_ADDR_EXP 103
81499: PUSH
81500: LD_INT 89
81502: ST_TO_ADDR
// us_hack := 99 ;
81503: LD_ADDR_EXP 104
81507: PUSH
81508: LD_INT 99
81510: ST_TO_ADDR
// us_artillery := 97 ;
81511: LD_ADDR_EXP 105
81515: PUSH
81516: LD_INT 97
81518: ST_TO_ADDR
// ar_bio_bomb := 91 ;
81519: LD_ADDR_EXP 106
81523: PUSH
81524: LD_INT 91
81526: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
81527: LD_ADDR_EXP 107
81531: PUSH
81532: LD_INT 92
81534: ST_TO_ADDR
// ru_radar := 98 ;
81535: LD_ADDR_EXP 102
81539: PUSH
81540: LD_INT 98
81542: ST_TO_ADDR
// tech_Artillery := 80 ;
81543: LD_ADDR_EXP 110
81547: PUSH
81548: LD_INT 80
81550: ST_TO_ADDR
// tech_RadMat := 81 ;
81551: LD_ADDR_EXP 111
81555: PUSH
81556: LD_INT 81
81558: ST_TO_ADDR
// tech_BasicTools := 82 ;
81559: LD_ADDR_EXP 112
81563: PUSH
81564: LD_INT 82
81566: ST_TO_ADDR
// tech_Cargo := 83 ;
81567: LD_ADDR_EXP 113
81571: PUSH
81572: LD_INT 83
81574: ST_TO_ADDR
// tech_Track := 84 ;
81575: LD_ADDR_EXP 114
81579: PUSH
81580: LD_INT 84
81582: ST_TO_ADDR
// tech_Crane := 85 ;
81583: LD_ADDR_EXP 115
81587: PUSH
81588: LD_INT 85
81590: ST_TO_ADDR
// tech_Bulldozer := 86 ;
81591: LD_ADDR_EXP 116
81595: PUSH
81596: LD_INT 86
81598: ST_TO_ADDR
// tech_Hovercraft := 87 ;
81599: LD_ADDR_EXP 117
81603: PUSH
81604: LD_INT 87
81606: ST_TO_ADDR
// end ;
81607: LD_VAR 0 1
81611: RET
// every 1 do
81612: GO 81614
81614: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
81615: CALL 81476 0 0
81619: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
81620: LD_VAR 0 2
81624: PUSH
81625: LD_INT 100
81627: EQUAL
81628: IFFALSE 82577
// begin if not StreamModeActive then
81630: LD_EXP 118
81634: NOT
81635: IFFALSE 81645
// StreamModeActive := true ;
81637: LD_ADDR_EXP 118
81641: PUSH
81642: LD_INT 1
81644: ST_TO_ADDR
// if p3 = 0 then
81645: LD_VAR 0 3
81649: PUSH
81650: LD_INT 0
81652: EQUAL
81653: IFFALSE 81659
// InitStreamMode ;
81655: CALL 82735 0 0
// if p3 = 1 then
81659: LD_VAR 0 3
81663: PUSH
81664: LD_INT 1
81666: EQUAL
81667: IFFALSE 81677
// sRocket := true ;
81669: LD_ADDR_EXP 123
81673: PUSH
81674: LD_INT 1
81676: ST_TO_ADDR
// if p3 = 2 then
81677: LD_VAR 0 3
81681: PUSH
81682: LD_INT 2
81684: EQUAL
81685: IFFALSE 81695
// sSpeed := true ;
81687: LD_ADDR_EXP 122
81691: PUSH
81692: LD_INT 1
81694: ST_TO_ADDR
// if p3 = 3 then
81695: LD_VAR 0 3
81699: PUSH
81700: LD_INT 3
81702: EQUAL
81703: IFFALSE 81713
// sEngine := true ;
81705: LD_ADDR_EXP 124
81709: PUSH
81710: LD_INT 1
81712: ST_TO_ADDR
// if p3 = 4 then
81713: LD_VAR 0 3
81717: PUSH
81718: LD_INT 4
81720: EQUAL
81721: IFFALSE 81731
// sSpec := true ;
81723: LD_ADDR_EXP 121
81727: PUSH
81728: LD_INT 1
81730: ST_TO_ADDR
// if p3 = 5 then
81731: LD_VAR 0 3
81735: PUSH
81736: LD_INT 5
81738: EQUAL
81739: IFFALSE 81749
// sLevel := true ;
81741: LD_ADDR_EXP 125
81745: PUSH
81746: LD_INT 1
81748: ST_TO_ADDR
// if p3 = 6 then
81749: LD_VAR 0 3
81753: PUSH
81754: LD_INT 6
81756: EQUAL
81757: IFFALSE 81767
// sArmoury := true ;
81759: LD_ADDR_EXP 126
81763: PUSH
81764: LD_INT 1
81766: ST_TO_ADDR
// if p3 = 7 then
81767: LD_VAR 0 3
81771: PUSH
81772: LD_INT 7
81774: EQUAL
81775: IFFALSE 81785
// sRadar := true ;
81777: LD_ADDR_EXP 127
81781: PUSH
81782: LD_INT 1
81784: ST_TO_ADDR
// if p3 = 8 then
81785: LD_VAR 0 3
81789: PUSH
81790: LD_INT 8
81792: EQUAL
81793: IFFALSE 81803
// sBunker := true ;
81795: LD_ADDR_EXP 128
81799: PUSH
81800: LD_INT 1
81802: ST_TO_ADDR
// if p3 = 9 then
81803: LD_VAR 0 3
81807: PUSH
81808: LD_INT 9
81810: EQUAL
81811: IFFALSE 81821
// sHack := true ;
81813: LD_ADDR_EXP 129
81817: PUSH
81818: LD_INT 1
81820: ST_TO_ADDR
// if p3 = 10 then
81821: LD_VAR 0 3
81825: PUSH
81826: LD_INT 10
81828: EQUAL
81829: IFFALSE 81839
// sFire := true ;
81831: LD_ADDR_EXP 130
81835: PUSH
81836: LD_INT 1
81838: ST_TO_ADDR
// if p3 = 11 then
81839: LD_VAR 0 3
81843: PUSH
81844: LD_INT 11
81846: EQUAL
81847: IFFALSE 81857
// sRefresh := true ;
81849: LD_ADDR_EXP 131
81853: PUSH
81854: LD_INT 1
81856: ST_TO_ADDR
// if p3 = 12 then
81857: LD_VAR 0 3
81861: PUSH
81862: LD_INT 12
81864: EQUAL
81865: IFFALSE 81875
// sExp := true ;
81867: LD_ADDR_EXP 132
81871: PUSH
81872: LD_INT 1
81874: ST_TO_ADDR
// if p3 = 13 then
81875: LD_VAR 0 3
81879: PUSH
81880: LD_INT 13
81882: EQUAL
81883: IFFALSE 81893
// sDepot := true ;
81885: LD_ADDR_EXP 133
81889: PUSH
81890: LD_INT 1
81892: ST_TO_ADDR
// if p3 = 14 then
81893: LD_VAR 0 3
81897: PUSH
81898: LD_INT 14
81900: EQUAL
81901: IFFALSE 81911
// sFlag := true ;
81903: LD_ADDR_EXP 134
81907: PUSH
81908: LD_INT 1
81910: ST_TO_ADDR
// if p3 = 15 then
81911: LD_VAR 0 3
81915: PUSH
81916: LD_INT 15
81918: EQUAL
81919: IFFALSE 81929
// sKamikadze := true ;
81921: LD_ADDR_EXP 142
81925: PUSH
81926: LD_INT 1
81928: ST_TO_ADDR
// if p3 = 16 then
81929: LD_VAR 0 3
81933: PUSH
81934: LD_INT 16
81936: EQUAL
81937: IFFALSE 81947
// sTroll := true ;
81939: LD_ADDR_EXP 143
81943: PUSH
81944: LD_INT 1
81946: ST_TO_ADDR
// if p3 = 17 then
81947: LD_VAR 0 3
81951: PUSH
81952: LD_INT 17
81954: EQUAL
81955: IFFALSE 81965
// sSlow := true ;
81957: LD_ADDR_EXP 144
81961: PUSH
81962: LD_INT 1
81964: ST_TO_ADDR
// if p3 = 18 then
81965: LD_VAR 0 3
81969: PUSH
81970: LD_INT 18
81972: EQUAL
81973: IFFALSE 81983
// sLack := true ;
81975: LD_ADDR_EXP 145
81979: PUSH
81980: LD_INT 1
81982: ST_TO_ADDR
// if p3 = 19 then
81983: LD_VAR 0 3
81987: PUSH
81988: LD_INT 19
81990: EQUAL
81991: IFFALSE 82001
// sTank := true ;
81993: LD_ADDR_EXP 147
81997: PUSH
81998: LD_INT 1
82000: ST_TO_ADDR
// if p3 = 20 then
82001: LD_VAR 0 3
82005: PUSH
82006: LD_INT 20
82008: EQUAL
82009: IFFALSE 82019
// sRemote := true ;
82011: LD_ADDR_EXP 148
82015: PUSH
82016: LD_INT 1
82018: ST_TO_ADDR
// if p3 = 21 then
82019: LD_VAR 0 3
82023: PUSH
82024: LD_INT 21
82026: EQUAL
82027: IFFALSE 82037
// sPowell := true ;
82029: LD_ADDR_EXP 149
82033: PUSH
82034: LD_INT 1
82036: ST_TO_ADDR
// if p3 = 22 then
82037: LD_VAR 0 3
82041: PUSH
82042: LD_INT 22
82044: EQUAL
82045: IFFALSE 82055
// sTeleport := true ;
82047: LD_ADDR_EXP 152
82051: PUSH
82052: LD_INT 1
82054: ST_TO_ADDR
// if p3 = 23 then
82055: LD_VAR 0 3
82059: PUSH
82060: LD_INT 23
82062: EQUAL
82063: IFFALSE 82073
// sOilTower := true ;
82065: LD_ADDR_EXP 154
82069: PUSH
82070: LD_INT 1
82072: ST_TO_ADDR
// if p3 = 24 then
82073: LD_VAR 0 3
82077: PUSH
82078: LD_INT 24
82080: EQUAL
82081: IFFALSE 82091
// sShovel := true ;
82083: LD_ADDR_EXP 155
82087: PUSH
82088: LD_INT 1
82090: ST_TO_ADDR
// if p3 = 25 then
82091: LD_VAR 0 3
82095: PUSH
82096: LD_INT 25
82098: EQUAL
82099: IFFALSE 82109
// sSheik := true ;
82101: LD_ADDR_EXP 156
82105: PUSH
82106: LD_INT 1
82108: ST_TO_ADDR
// if p3 = 26 then
82109: LD_VAR 0 3
82113: PUSH
82114: LD_INT 26
82116: EQUAL
82117: IFFALSE 82127
// sEarthquake := true ;
82119: LD_ADDR_EXP 158
82123: PUSH
82124: LD_INT 1
82126: ST_TO_ADDR
// if p3 = 27 then
82127: LD_VAR 0 3
82131: PUSH
82132: LD_INT 27
82134: EQUAL
82135: IFFALSE 82145
// sAI := true ;
82137: LD_ADDR_EXP 159
82141: PUSH
82142: LD_INT 1
82144: ST_TO_ADDR
// if p3 = 28 then
82145: LD_VAR 0 3
82149: PUSH
82150: LD_INT 28
82152: EQUAL
82153: IFFALSE 82163
// sCargo := true ;
82155: LD_ADDR_EXP 162
82159: PUSH
82160: LD_INT 1
82162: ST_TO_ADDR
// if p3 = 29 then
82163: LD_VAR 0 3
82167: PUSH
82168: LD_INT 29
82170: EQUAL
82171: IFFALSE 82181
// sDLaser := true ;
82173: LD_ADDR_EXP 163
82177: PUSH
82178: LD_INT 1
82180: ST_TO_ADDR
// if p3 = 30 then
82181: LD_VAR 0 3
82185: PUSH
82186: LD_INT 30
82188: EQUAL
82189: IFFALSE 82199
// sExchange := true ;
82191: LD_ADDR_EXP 164
82195: PUSH
82196: LD_INT 1
82198: ST_TO_ADDR
// if p3 = 31 then
82199: LD_VAR 0 3
82203: PUSH
82204: LD_INT 31
82206: EQUAL
82207: IFFALSE 82217
// sFac := true ;
82209: LD_ADDR_EXP 165
82213: PUSH
82214: LD_INT 1
82216: ST_TO_ADDR
// if p3 = 32 then
82217: LD_VAR 0 3
82221: PUSH
82222: LD_INT 32
82224: EQUAL
82225: IFFALSE 82235
// sPower := true ;
82227: LD_ADDR_EXP 166
82231: PUSH
82232: LD_INT 1
82234: ST_TO_ADDR
// if p3 = 33 then
82235: LD_VAR 0 3
82239: PUSH
82240: LD_INT 33
82242: EQUAL
82243: IFFALSE 82253
// sRandom := true ;
82245: LD_ADDR_EXP 167
82249: PUSH
82250: LD_INT 1
82252: ST_TO_ADDR
// if p3 = 34 then
82253: LD_VAR 0 3
82257: PUSH
82258: LD_INT 34
82260: EQUAL
82261: IFFALSE 82271
// sShield := true ;
82263: LD_ADDR_EXP 168
82267: PUSH
82268: LD_INT 1
82270: ST_TO_ADDR
// if p3 = 35 then
82271: LD_VAR 0 3
82275: PUSH
82276: LD_INT 35
82278: EQUAL
82279: IFFALSE 82289
// sTime := true ;
82281: LD_ADDR_EXP 169
82285: PUSH
82286: LD_INT 1
82288: ST_TO_ADDR
// if p3 = 36 then
82289: LD_VAR 0 3
82293: PUSH
82294: LD_INT 36
82296: EQUAL
82297: IFFALSE 82307
// sTools := true ;
82299: LD_ADDR_EXP 170
82303: PUSH
82304: LD_INT 1
82306: ST_TO_ADDR
// if p3 = 101 then
82307: LD_VAR 0 3
82311: PUSH
82312: LD_INT 101
82314: EQUAL
82315: IFFALSE 82325
// sSold := true ;
82317: LD_ADDR_EXP 135
82321: PUSH
82322: LD_INT 1
82324: ST_TO_ADDR
// if p3 = 102 then
82325: LD_VAR 0 3
82329: PUSH
82330: LD_INT 102
82332: EQUAL
82333: IFFALSE 82343
// sDiff := true ;
82335: LD_ADDR_EXP 136
82339: PUSH
82340: LD_INT 1
82342: ST_TO_ADDR
// if p3 = 103 then
82343: LD_VAR 0 3
82347: PUSH
82348: LD_INT 103
82350: EQUAL
82351: IFFALSE 82361
// sFog := true ;
82353: LD_ADDR_EXP 139
82357: PUSH
82358: LD_INT 1
82360: ST_TO_ADDR
// if p3 = 104 then
82361: LD_VAR 0 3
82365: PUSH
82366: LD_INT 104
82368: EQUAL
82369: IFFALSE 82379
// sReset := true ;
82371: LD_ADDR_EXP 140
82375: PUSH
82376: LD_INT 1
82378: ST_TO_ADDR
// if p3 = 105 then
82379: LD_VAR 0 3
82383: PUSH
82384: LD_INT 105
82386: EQUAL
82387: IFFALSE 82397
// sSun := true ;
82389: LD_ADDR_EXP 141
82393: PUSH
82394: LD_INT 1
82396: ST_TO_ADDR
// if p3 = 106 then
82397: LD_VAR 0 3
82401: PUSH
82402: LD_INT 106
82404: EQUAL
82405: IFFALSE 82415
// sTiger := true ;
82407: LD_ADDR_EXP 137
82411: PUSH
82412: LD_INT 1
82414: ST_TO_ADDR
// if p3 = 107 then
82415: LD_VAR 0 3
82419: PUSH
82420: LD_INT 107
82422: EQUAL
82423: IFFALSE 82433
// sBomb := true ;
82425: LD_ADDR_EXP 138
82429: PUSH
82430: LD_INT 1
82432: ST_TO_ADDR
// if p3 = 108 then
82433: LD_VAR 0 3
82437: PUSH
82438: LD_INT 108
82440: EQUAL
82441: IFFALSE 82451
// sWound := true ;
82443: LD_ADDR_EXP 146
82447: PUSH
82448: LD_INT 1
82450: ST_TO_ADDR
// if p3 = 109 then
82451: LD_VAR 0 3
82455: PUSH
82456: LD_INT 109
82458: EQUAL
82459: IFFALSE 82469
// sBetray := true ;
82461: LD_ADDR_EXP 150
82465: PUSH
82466: LD_INT 1
82468: ST_TO_ADDR
// if p3 = 110 then
82469: LD_VAR 0 3
82473: PUSH
82474: LD_INT 110
82476: EQUAL
82477: IFFALSE 82487
// sContamin := true ;
82479: LD_ADDR_EXP 151
82483: PUSH
82484: LD_INT 1
82486: ST_TO_ADDR
// if p3 = 111 then
82487: LD_VAR 0 3
82491: PUSH
82492: LD_INT 111
82494: EQUAL
82495: IFFALSE 82505
// sOil := true ;
82497: LD_ADDR_EXP 153
82501: PUSH
82502: LD_INT 1
82504: ST_TO_ADDR
// if p3 = 112 then
82505: LD_VAR 0 3
82509: PUSH
82510: LD_INT 112
82512: EQUAL
82513: IFFALSE 82523
// sStu := true ;
82515: LD_ADDR_EXP 157
82519: PUSH
82520: LD_INT 1
82522: ST_TO_ADDR
// if p3 = 113 then
82523: LD_VAR 0 3
82527: PUSH
82528: LD_INT 113
82530: EQUAL
82531: IFFALSE 82541
// sBazooka := true ;
82533: LD_ADDR_EXP 160
82537: PUSH
82538: LD_INT 1
82540: ST_TO_ADDR
// if p3 = 114 then
82541: LD_VAR 0 3
82545: PUSH
82546: LD_INT 114
82548: EQUAL
82549: IFFALSE 82559
// sMortar := true ;
82551: LD_ADDR_EXP 161
82555: PUSH
82556: LD_INT 1
82558: ST_TO_ADDR
// if p3 = 115 then
82559: LD_VAR 0 3
82563: PUSH
82564: LD_INT 115
82566: EQUAL
82567: IFFALSE 82577
// sRanger := true ;
82569: LD_ADDR_EXP 171
82573: PUSH
82574: LD_INT 1
82576: ST_TO_ADDR
// end ; if p2 = 101 then
82577: LD_VAR 0 2
82581: PUSH
82582: LD_INT 101
82584: EQUAL
82585: IFFALSE 82713
// begin case p3 of 1 :
82587: LD_VAR 0 3
82591: PUSH
82592: LD_INT 1
82594: DOUBLE
82595: EQUAL
82596: IFTRUE 82600
82598: GO 82607
82600: POP
// hHackUnlimitedResources ; 2 :
82601: CALL 93748 0 0
82605: GO 82713
82607: LD_INT 2
82609: DOUBLE
82610: EQUAL
82611: IFTRUE 82615
82613: GO 82622
82615: POP
// hHackSetLevel10 ; 3 :
82616: CALL 93881 0 0
82620: GO 82713
82622: LD_INT 3
82624: DOUBLE
82625: EQUAL
82626: IFTRUE 82630
82628: GO 82637
82630: POP
// hHackSetLevel10YourUnits ; 4 :
82631: CALL 93966 0 0
82635: GO 82713
82637: LD_INT 4
82639: DOUBLE
82640: EQUAL
82641: IFTRUE 82645
82643: GO 82652
82645: POP
// hHackInvincible ; 5 :
82646: CALL 94414 0 0
82650: GO 82713
82652: LD_INT 5
82654: DOUBLE
82655: EQUAL
82656: IFTRUE 82660
82658: GO 82667
82660: POP
// hHackInvisible ; 6 :
82661: CALL 94525 0 0
82665: GO 82713
82667: LD_INT 6
82669: DOUBLE
82670: EQUAL
82671: IFTRUE 82675
82673: GO 82682
82675: POP
// hHackChangeYourSide ; 7 :
82676: CALL 94582 0 0
82680: GO 82713
82682: LD_INT 7
82684: DOUBLE
82685: EQUAL
82686: IFTRUE 82690
82688: GO 82697
82690: POP
// hHackChangeUnitSide ; 8 :
82691: CALL 94624 0 0
82695: GO 82713
82697: LD_INT 8
82699: DOUBLE
82700: EQUAL
82701: IFTRUE 82705
82703: GO 82712
82705: POP
// hHackFog ; end ;
82706: CALL 94725 0 0
82710: GO 82713
82712: POP
// end ; end ;
82713: PPOPN 6
82715: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
82716: GO 82718
82718: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
82719: LD_STRING initStreamRollete();
82721: PPUSH
82722: CALL_OW 559
// InitStreamMode ;
82726: CALL 82735 0 0
// DefineStreamItems ( ) ;
82730: CALL 83175 0 0
// end ;
82734: END
// function InitStreamMode ; begin
82735: LD_INT 0
82737: PPUSH
// streamModeActive := false ;
82738: LD_ADDR_EXP 118
82742: PUSH
82743: LD_INT 0
82745: ST_TO_ADDR
// normalCounter := 36 ;
82746: LD_ADDR_EXP 119
82750: PUSH
82751: LD_INT 36
82753: ST_TO_ADDR
// hardcoreCounter := 16 ;
82754: LD_ADDR_EXP 120
82758: PUSH
82759: LD_INT 16
82761: ST_TO_ADDR
// sRocket := false ;
82762: LD_ADDR_EXP 123
82766: PUSH
82767: LD_INT 0
82769: ST_TO_ADDR
// sSpeed := false ;
82770: LD_ADDR_EXP 122
82774: PUSH
82775: LD_INT 0
82777: ST_TO_ADDR
// sEngine := false ;
82778: LD_ADDR_EXP 124
82782: PUSH
82783: LD_INT 0
82785: ST_TO_ADDR
// sSpec := false ;
82786: LD_ADDR_EXP 121
82790: PUSH
82791: LD_INT 0
82793: ST_TO_ADDR
// sLevel := false ;
82794: LD_ADDR_EXP 125
82798: PUSH
82799: LD_INT 0
82801: ST_TO_ADDR
// sArmoury := false ;
82802: LD_ADDR_EXP 126
82806: PUSH
82807: LD_INT 0
82809: ST_TO_ADDR
// sRadar := false ;
82810: LD_ADDR_EXP 127
82814: PUSH
82815: LD_INT 0
82817: ST_TO_ADDR
// sBunker := false ;
82818: LD_ADDR_EXP 128
82822: PUSH
82823: LD_INT 0
82825: ST_TO_ADDR
// sHack := false ;
82826: LD_ADDR_EXP 129
82830: PUSH
82831: LD_INT 0
82833: ST_TO_ADDR
// sFire := false ;
82834: LD_ADDR_EXP 130
82838: PUSH
82839: LD_INT 0
82841: ST_TO_ADDR
// sRefresh := false ;
82842: LD_ADDR_EXP 131
82846: PUSH
82847: LD_INT 0
82849: ST_TO_ADDR
// sExp := false ;
82850: LD_ADDR_EXP 132
82854: PUSH
82855: LD_INT 0
82857: ST_TO_ADDR
// sDepot := false ;
82858: LD_ADDR_EXP 133
82862: PUSH
82863: LD_INT 0
82865: ST_TO_ADDR
// sFlag := false ;
82866: LD_ADDR_EXP 134
82870: PUSH
82871: LD_INT 0
82873: ST_TO_ADDR
// sKamikadze := false ;
82874: LD_ADDR_EXP 142
82878: PUSH
82879: LD_INT 0
82881: ST_TO_ADDR
// sTroll := false ;
82882: LD_ADDR_EXP 143
82886: PUSH
82887: LD_INT 0
82889: ST_TO_ADDR
// sSlow := false ;
82890: LD_ADDR_EXP 144
82894: PUSH
82895: LD_INT 0
82897: ST_TO_ADDR
// sLack := false ;
82898: LD_ADDR_EXP 145
82902: PUSH
82903: LD_INT 0
82905: ST_TO_ADDR
// sTank := false ;
82906: LD_ADDR_EXP 147
82910: PUSH
82911: LD_INT 0
82913: ST_TO_ADDR
// sRemote := false ;
82914: LD_ADDR_EXP 148
82918: PUSH
82919: LD_INT 0
82921: ST_TO_ADDR
// sPowell := false ;
82922: LD_ADDR_EXP 149
82926: PUSH
82927: LD_INT 0
82929: ST_TO_ADDR
// sTeleport := false ;
82930: LD_ADDR_EXP 152
82934: PUSH
82935: LD_INT 0
82937: ST_TO_ADDR
// sOilTower := false ;
82938: LD_ADDR_EXP 154
82942: PUSH
82943: LD_INT 0
82945: ST_TO_ADDR
// sShovel := false ;
82946: LD_ADDR_EXP 155
82950: PUSH
82951: LD_INT 0
82953: ST_TO_ADDR
// sSheik := false ;
82954: LD_ADDR_EXP 156
82958: PUSH
82959: LD_INT 0
82961: ST_TO_ADDR
// sEarthquake := false ;
82962: LD_ADDR_EXP 158
82966: PUSH
82967: LD_INT 0
82969: ST_TO_ADDR
// sAI := false ;
82970: LD_ADDR_EXP 159
82974: PUSH
82975: LD_INT 0
82977: ST_TO_ADDR
// sCargo := false ;
82978: LD_ADDR_EXP 162
82982: PUSH
82983: LD_INT 0
82985: ST_TO_ADDR
// sDLaser := false ;
82986: LD_ADDR_EXP 163
82990: PUSH
82991: LD_INT 0
82993: ST_TO_ADDR
// sExchange := false ;
82994: LD_ADDR_EXP 164
82998: PUSH
82999: LD_INT 0
83001: ST_TO_ADDR
// sFac := false ;
83002: LD_ADDR_EXP 165
83006: PUSH
83007: LD_INT 0
83009: ST_TO_ADDR
// sPower := false ;
83010: LD_ADDR_EXP 166
83014: PUSH
83015: LD_INT 0
83017: ST_TO_ADDR
// sRandom := false ;
83018: LD_ADDR_EXP 167
83022: PUSH
83023: LD_INT 0
83025: ST_TO_ADDR
// sShield := false ;
83026: LD_ADDR_EXP 168
83030: PUSH
83031: LD_INT 0
83033: ST_TO_ADDR
// sTime := false ;
83034: LD_ADDR_EXP 169
83038: PUSH
83039: LD_INT 0
83041: ST_TO_ADDR
// sTools := false ;
83042: LD_ADDR_EXP 170
83046: PUSH
83047: LD_INT 0
83049: ST_TO_ADDR
// sSold := false ;
83050: LD_ADDR_EXP 135
83054: PUSH
83055: LD_INT 0
83057: ST_TO_ADDR
// sDiff := false ;
83058: LD_ADDR_EXP 136
83062: PUSH
83063: LD_INT 0
83065: ST_TO_ADDR
// sFog := false ;
83066: LD_ADDR_EXP 139
83070: PUSH
83071: LD_INT 0
83073: ST_TO_ADDR
// sReset := false ;
83074: LD_ADDR_EXP 140
83078: PUSH
83079: LD_INT 0
83081: ST_TO_ADDR
// sSun := false ;
83082: LD_ADDR_EXP 141
83086: PUSH
83087: LD_INT 0
83089: ST_TO_ADDR
// sTiger := false ;
83090: LD_ADDR_EXP 137
83094: PUSH
83095: LD_INT 0
83097: ST_TO_ADDR
// sBomb := false ;
83098: LD_ADDR_EXP 138
83102: PUSH
83103: LD_INT 0
83105: ST_TO_ADDR
// sWound := false ;
83106: LD_ADDR_EXP 146
83110: PUSH
83111: LD_INT 0
83113: ST_TO_ADDR
// sBetray := false ;
83114: LD_ADDR_EXP 150
83118: PUSH
83119: LD_INT 0
83121: ST_TO_ADDR
// sContamin := false ;
83122: LD_ADDR_EXP 151
83126: PUSH
83127: LD_INT 0
83129: ST_TO_ADDR
// sOil := false ;
83130: LD_ADDR_EXP 153
83134: PUSH
83135: LD_INT 0
83137: ST_TO_ADDR
// sStu := false ;
83138: LD_ADDR_EXP 157
83142: PUSH
83143: LD_INT 0
83145: ST_TO_ADDR
// sBazooka := false ;
83146: LD_ADDR_EXP 160
83150: PUSH
83151: LD_INT 0
83153: ST_TO_ADDR
// sMortar := false ;
83154: LD_ADDR_EXP 161
83158: PUSH
83159: LD_INT 0
83161: ST_TO_ADDR
// sRanger := false ;
83162: LD_ADDR_EXP 171
83166: PUSH
83167: LD_INT 0
83169: ST_TO_ADDR
// end ;
83170: LD_VAR 0 1
83174: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
83175: LD_INT 0
83177: PPUSH
83178: PPUSH
83179: PPUSH
83180: PPUSH
83181: PPUSH
// result := [ ] ;
83182: LD_ADDR_VAR 0 1
83186: PUSH
83187: EMPTY
83188: ST_TO_ADDR
// if campaign_id = 1 then
83189: LD_OWVAR 69
83193: PUSH
83194: LD_INT 1
83196: EQUAL
83197: IFFALSE 86135
// begin case mission_number of 1 :
83199: LD_OWVAR 70
83203: PUSH
83204: LD_INT 1
83206: DOUBLE
83207: EQUAL
83208: IFTRUE 83212
83210: GO 83276
83212: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
83213: LD_ADDR_VAR 0 1
83217: PUSH
83218: LD_INT 2
83220: PUSH
83221: LD_INT 4
83223: PUSH
83224: LD_INT 11
83226: PUSH
83227: LD_INT 12
83229: PUSH
83230: LD_INT 15
83232: PUSH
83233: LD_INT 16
83235: PUSH
83236: LD_INT 22
83238: PUSH
83239: LD_INT 23
83241: PUSH
83242: LD_INT 26
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: PUSH
83256: LD_INT 101
83258: PUSH
83259: LD_INT 102
83261: PUSH
83262: LD_INT 106
83264: PUSH
83265: EMPTY
83266: LIST
83267: LIST
83268: LIST
83269: PUSH
83270: EMPTY
83271: LIST
83272: LIST
83273: ST_TO_ADDR
83274: GO 86133
83276: LD_INT 2
83278: DOUBLE
83279: EQUAL
83280: IFTRUE 83284
83282: GO 83356
83284: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
83285: LD_ADDR_VAR 0 1
83289: PUSH
83290: LD_INT 2
83292: PUSH
83293: LD_INT 4
83295: PUSH
83296: LD_INT 11
83298: PUSH
83299: LD_INT 12
83301: PUSH
83302: LD_INT 15
83304: PUSH
83305: LD_INT 16
83307: PUSH
83308: LD_INT 22
83310: PUSH
83311: LD_INT 23
83313: PUSH
83314: LD_INT 26
83316: PUSH
83317: EMPTY
83318: LIST
83319: LIST
83320: LIST
83321: LIST
83322: LIST
83323: LIST
83324: LIST
83325: LIST
83326: LIST
83327: PUSH
83328: LD_INT 101
83330: PUSH
83331: LD_INT 102
83333: PUSH
83334: LD_INT 105
83336: PUSH
83337: LD_INT 106
83339: PUSH
83340: LD_INT 108
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: LIST
83347: LIST
83348: LIST
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: ST_TO_ADDR
83354: GO 86133
83356: LD_INT 3
83358: DOUBLE
83359: EQUAL
83360: IFTRUE 83364
83362: GO 83440
83364: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
83365: LD_ADDR_VAR 0 1
83369: PUSH
83370: LD_INT 2
83372: PUSH
83373: LD_INT 4
83375: PUSH
83376: LD_INT 5
83378: PUSH
83379: LD_INT 11
83381: PUSH
83382: LD_INT 12
83384: PUSH
83385: LD_INT 15
83387: PUSH
83388: LD_INT 16
83390: PUSH
83391: LD_INT 22
83393: PUSH
83394: LD_INT 26
83396: PUSH
83397: LD_INT 36
83399: PUSH
83400: EMPTY
83401: LIST
83402: LIST
83403: LIST
83404: LIST
83405: LIST
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: PUSH
83412: LD_INT 101
83414: PUSH
83415: LD_INT 102
83417: PUSH
83418: LD_INT 105
83420: PUSH
83421: LD_INT 106
83423: PUSH
83424: LD_INT 108
83426: PUSH
83427: EMPTY
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: LIST
83433: PUSH
83434: EMPTY
83435: LIST
83436: LIST
83437: ST_TO_ADDR
83438: GO 86133
83440: LD_INT 4
83442: DOUBLE
83443: EQUAL
83444: IFTRUE 83448
83446: GO 83532
83448: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
83449: LD_ADDR_VAR 0 1
83453: PUSH
83454: LD_INT 2
83456: PUSH
83457: LD_INT 4
83459: PUSH
83460: LD_INT 5
83462: PUSH
83463: LD_INT 8
83465: PUSH
83466: LD_INT 11
83468: PUSH
83469: LD_INT 12
83471: PUSH
83472: LD_INT 15
83474: PUSH
83475: LD_INT 16
83477: PUSH
83478: LD_INT 22
83480: PUSH
83481: LD_INT 23
83483: PUSH
83484: LD_INT 26
83486: PUSH
83487: LD_INT 36
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: LIST
83494: LIST
83495: LIST
83496: LIST
83497: LIST
83498: LIST
83499: LIST
83500: LIST
83501: LIST
83502: LIST
83503: PUSH
83504: LD_INT 101
83506: PUSH
83507: LD_INT 102
83509: PUSH
83510: LD_INT 105
83512: PUSH
83513: LD_INT 106
83515: PUSH
83516: LD_INT 108
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: LIST
83523: LIST
83524: LIST
83525: PUSH
83526: EMPTY
83527: LIST
83528: LIST
83529: ST_TO_ADDR
83530: GO 86133
83532: LD_INT 5
83534: DOUBLE
83535: EQUAL
83536: IFTRUE 83540
83538: GO 83640
83540: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
83541: LD_ADDR_VAR 0 1
83545: PUSH
83546: LD_INT 2
83548: PUSH
83549: LD_INT 4
83551: PUSH
83552: LD_INT 5
83554: PUSH
83555: LD_INT 6
83557: PUSH
83558: LD_INT 8
83560: PUSH
83561: LD_INT 11
83563: PUSH
83564: LD_INT 12
83566: PUSH
83567: LD_INT 15
83569: PUSH
83570: LD_INT 16
83572: PUSH
83573: LD_INT 22
83575: PUSH
83576: LD_INT 23
83578: PUSH
83579: LD_INT 25
83581: PUSH
83582: LD_INT 26
83584: PUSH
83585: LD_INT 36
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: LIST
83592: LIST
83593: LIST
83594: LIST
83595: LIST
83596: LIST
83597: LIST
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: PUSH
83604: LD_INT 101
83606: PUSH
83607: LD_INT 102
83609: PUSH
83610: LD_INT 105
83612: PUSH
83613: LD_INT 106
83615: PUSH
83616: LD_INT 108
83618: PUSH
83619: LD_INT 109
83621: PUSH
83622: LD_INT 112
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: PUSH
83634: EMPTY
83635: LIST
83636: LIST
83637: ST_TO_ADDR
83638: GO 86133
83640: LD_INT 6
83642: DOUBLE
83643: EQUAL
83644: IFTRUE 83648
83646: GO 83768
83648: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
83649: LD_ADDR_VAR 0 1
83653: PUSH
83654: LD_INT 2
83656: PUSH
83657: LD_INT 4
83659: PUSH
83660: LD_INT 5
83662: PUSH
83663: LD_INT 6
83665: PUSH
83666: LD_INT 8
83668: PUSH
83669: LD_INT 11
83671: PUSH
83672: LD_INT 12
83674: PUSH
83675: LD_INT 15
83677: PUSH
83678: LD_INT 16
83680: PUSH
83681: LD_INT 20
83683: PUSH
83684: LD_INT 21
83686: PUSH
83687: LD_INT 22
83689: PUSH
83690: LD_INT 23
83692: PUSH
83693: LD_INT 25
83695: PUSH
83696: LD_INT 26
83698: PUSH
83699: LD_INT 30
83701: PUSH
83702: LD_INT 31
83704: PUSH
83705: LD_INT 32
83707: PUSH
83708: LD_INT 36
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: LIST
83715: LIST
83716: LIST
83717: LIST
83718: LIST
83719: LIST
83720: LIST
83721: LIST
83722: LIST
83723: LIST
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: LIST
83729: LIST
83730: LIST
83731: PUSH
83732: LD_INT 101
83734: PUSH
83735: LD_INT 102
83737: PUSH
83738: LD_INT 105
83740: PUSH
83741: LD_INT 106
83743: PUSH
83744: LD_INT 108
83746: PUSH
83747: LD_INT 109
83749: PUSH
83750: LD_INT 112
83752: PUSH
83753: EMPTY
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: ST_TO_ADDR
83766: GO 86133
83768: LD_INT 7
83770: DOUBLE
83771: EQUAL
83772: IFTRUE 83776
83774: GO 83876
83776: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
83777: LD_ADDR_VAR 0 1
83781: PUSH
83782: LD_INT 2
83784: PUSH
83785: LD_INT 4
83787: PUSH
83788: LD_INT 5
83790: PUSH
83791: LD_INT 7
83793: PUSH
83794: LD_INT 11
83796: PUSH
83797: LD_INT 12
83799: PUSH
83800: LD_INT 15
83802: PUSH
83803: LD_INT 16
83805: PUSH
83806: LD_INT 20
83808: PUSH
83809: LD_INT 21
83811: PUSH
83812: LD_INT 22
83814: PUSH
83815: LD_INT 23
83817: PUSH
83818: LD_INT 25
83820: PUSH
83821: LD_INT 26
83823: PUSH
83824: EMPTY
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: LIST
83839: PUSH
83840: LD_INT 101
83842: PUSH
83843: LD_INT 102
83845: PUSH
83846: LD_INT 103
83848: PUSH
83849: LD_INT 105
83851: PUSH
83852: LD_INT 106
83854: PUSH
83855: LD_INT 108
83857: PUSH
83858: LD_INT 112
83860: PUSH
83861: EMPTY
83862: LIST
83863: LIST
83864: LIST
83865: LIST
83866: LIST
83867: LIST
83868: LIST
83869: PUSH
83870: EMPTY
83871: LIST
83872: LIST
83873: ST_TO_ADDR
83874: GO 86133
83876: LD_INT 8
83878: DOUBLE
83879: EQUAL
83880: IFTRUE 83884
83882: GO 84012
83884: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
83885: LD_ADDR_VAR 0 1
83889: PUSH
83890: LD_INT 2
83892: PUSH
83893: LD_INT 4
83895: PUSH
83896: LD_INT 5
83898: PUSH
83899: LD_INT 6
83901: PUSH
83902: LD_INT 7
83904: PUSH
83905: LD_INT 8
83907: PUSH
83908: LD_INT 11
83910: PUSH
83911: LD_INT 12
83913: PUSH
83914: LD_INT 15
83916: PUSH
83917: LD_INT 16
83919: PUSH
83920: LD_INT 20
83922: PUSH
83923: LD_INT 21
83925: PUSH
83926: LD_INT 22
83928: PUSH
83929: LD_INT 23
83931: PUSH
83932: LD_INT 25
83934: PUSH
83935: LD_INT 26
83937: PUSH
83938: LD_INT 30
83940: PUSH
83941: LD_INT 31
83943: PUSH
83944: LD_INT 32
83946: PUSH
83947: LD_INT 36
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: PUSH
83972: LD_INT 101
83974: PUSH
83975: LD_INT 102
83977: PUSH
83978: LD_INT 103
83980: PUSH
83981: LD_INT 105
83983: PUSH
83984: LD_INT 106
83986: PUSH
83987: LD_INT 108
83989: PUSH
83990: LD_INT 109
83992: PUSH
83993: LD_INT 112
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: LIST
84000: LIST
84001: LIST
84002: LIST
84003: LIST
84004: LIST
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: ST_TO_ADDR
84010: GO 86133
84012: LD_INT 9
84014: DOUBLE
84015: EQUAL
84016: IFTRUE 84020
84018: GO 84156
84020: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
84021: LD_ADDR_VAR 0 1
84025: PUSH
84026: LD_INT 2
84028: PUSH
84029: LD_INT 4
84031: PUSH
84032: LD_INT 5
84034: PUSH
84035: LD_INT 6
84037: PUSH
84038: LD_INT 7
84040: PUSH
84041: LD_INT 8
84043: PUSH
84044: LD_INT 11
84046: PUSH
84047: LD_INT 12
84049: PUSH
84050: LD_INT 15
84052: PUSH
84053: LD_INT 16
84055: PUSH
84056: LD_INT 20
84058: PUSH
84059: LD_INT 21
84061: PUSH
84062: LD_INT 22
84064: PUSH
84065: LD_INT 23
84067: PUSH
84068: LD_INT 25
84070: PUSH
84071: LD_INT 26
84073: PUSH
84074: LD_INT 28
84076: PUSH
84077: LD_INT 30
84079: PUSH
84080: LD_INT 31
84082: PUSH
84083: LD_INT 32
84085: PUSH
84086: LD_INT 36
84088: PUSH
84089: EMPTY
84090: LIST
84091: LIST
84092: LIST
84093: LIST
84094: LIST
84095: LIST
84096: LIST
84097: LIST
84098: LIST
84099: LIST
84100: LIST
84101: LIST
84102: LIST
84103: LIST
84104: LIST
84105: LIST
84106: LIST
84107: LIST
84108: LIST
84109: LIST
84110: LIST
84111: PUSH
84112: LD_INT 101
84114: PUSH
84115: LD_INT 102
84117: PUSH
84118: LD_INT 103
84120: PUSH
84121: LD_INT 105
84123: PUSH
84124: LD_INT 106
84126: PUSH
84127: LD_INT 108
84129: PUSH
84130: LD_INT 109
84132: PUSH
84133: LD_INT 112
84135: PUSH
84136: LD_INT 114
84138: PUSH
84139: EMPTY
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: LIST
84148: LIST
84149: PUSH
84150: EMPTY
84151: LIST
84152: LIST
84153: ST_TO_ADDR
84154: GO 86133
84156: LD_INT 10
84158: DOUBLE
84159: EQUAL
84160: IFTRUE 84164
84162: GO 84348
84164: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
84165: LD_ADDR_VAR 0 1
84169: PUSH
84170: LD_INT 2
84172: PUSH
84173: LD_INT 4
84175: PUSH
84176: LD_INT 5
84178: PUSH
84179: LD_INT 6
84181: PUSH
84182: LD_INT 7
84184: PUSH
84185: LD_INT 8
84187: PUSH
84188: LD_INT 9
84190: PUSH
84191: LD_INT 10
84193: PUSH
84194: LD_INT 11
84196: PUSH
84197: LD_INT 12
84199: PUSH
84200: LD_INT 13
84202: PUSH
84203: LD_INT 14
84205: PUSH
84206: LD_INT 15
84208: PUSH
84209: LD_INT 16
84211: PUSH
84212: LD_INT 17
84214: PUSH
84215: LD_INT 18
84217: PUSH
84218: LD_INT 19
84220: PUSH
84221: LD_INT 20
84223: PUSH
84224: LD_INT 21
84226: PUSH
84227: LD_INT 22
84229: PUSH
84230: LD_INT 23
84232: PUSH
84233: LD_INT 24
84235: PUSH
84236: LD_INT 25
84238: PUSH
84239: LD_INT 26
84241: PUSH
84242: LD_INT 28
84244: PUSH
84245: LD_INT 30
84247: PUSH
84248: LD_INT 31
84250: PUSH
84251: LD_INT 32
84253: PUSH
84254: LD_INT 36
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: LIST
84261: LIST
84262: LIST
84263: LIST
84264: LIST
84265: LIST
84266: LIST
84267: LIST
84268: LIST
84269: LIST
84270: LIST
84271: LIST
84272: LIST
84273: LIST
84274: LIST
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: PUSH
84288: LD_INT 101
84290: PUSH
84291: LD_INT 102
84293: PUSH
84294: LD_INT 103
84296: PUSH
84297: LD_INT 104
84299: PUSH
84300: LD_INT 105
84302: PUSH
84303: LD_INT 106
84305: PUSH
84306: LD_INT 107
84308: PUSH
84309: LD_INT 108
84311: PUSH
84312: LD_INT 109
84314: PUSH
84315: LD_INT 110
84317: PUSH
84318: LD_INT 111
84320: PUSH
84321: LD_INT 112
84323: PUSH
84324: LD_INT 114
84326: PUSH
84327: EMPTY
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: LIST
84340: LIST
84341: PUSH
84342: EMPTY
84343: LIST
84344: LIST
84345: ST_TO_ADDR
84346: GO 86133
84348: LD_INT 11
84350: DOUBLE
84351: EQUAL
84352: IFTRUE 84356
84354: GO 84548
84356: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
84357: LD_ADDR_VAR 0 1
84361: PUSH
84362: LD_INT 2
84364: PUSH
84365: LD_INT 3
84367: PUSH
84368: LD_INT 4
84370: PUSH
84371: LD_INT 5
84373: PUSH
84374: LD_INT 6
84376: PUSH
84377: LD_INT 7
84379: PUSH
84380: LD_INT 8
84382: PUSH
84383: LD_INT 9
84385: PUSH
84386: LD_INT 10
84388: PUSH
84389: LD_INT 11
84391: PUSH
84392: LD_INT 12
84394: PUSH
84395: LD_INT 13
84397: PUSH
84398: LD_INT 14
84400: PUSH
84401: LD_INT 15
84403: PUSH
84404: LD_INT 16
84406: PUSH
84407: LD_INT 17
84409: PUSH
84410: LD_INT 18
84412: PUSH
84413: LD_INT 19
84415: PUSH
84416: LD_INT 20
84418: PUSH
84419: LD_INT 21
84421: PUSH
84422: LD_INT 22
84424: PUSH
84425: LD_INT 23
84427: PUSH
84428: LD_INT 24
84430: PUSH
84431: LD_INT 25
84433: PUSH
84434: LD_INT 26
84436: PUSH
84437: LD_INT 28
84439: PUSH
84440: LD_INT 30
84442: PUSH
84443: LD_INT 31
84445: PUSH
84446: LD_INT 32
84448: PUSH
84449: LD_INT 34
84451: PUSH
84452: LD_INT 36
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: LIST
84459: LIST
84460: LIST
84461: LIST
84462: LIST
84463: LIST
84464: LIST
84465: LIST
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: PUSH
84488: LD_INT 101
84490: PUSH
84491: LD_INT 102
84493: PUSH
84494: LD_INT 103
84496: PUSH
84497: LD_INT 104
84499: PUSH
84500: LD_INT 105
84502: PUSH
84503: LD_INT 106
84505: PUSH
84506: LD_INT 107
84508: PUSH
84509: LD_INT 108
84511: PUSH
84512: LD_INT 109
84514: PUSH
84515: LD_INT 110
84517: PUSH
84518: LD_INT 111
84520: PUSH
84521: LD_INT 112
84523: PUSH
84524: LD_INT 114
84526: PUSH
84527: EMPTY
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: ST_TO_ADDR
84546: GO 86133
84548: LD_INT 12
84550: DOUBLE
84551: EQUAL
84552: IFTRUE 84556
84554: GO 84764
84556: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
84557: LD_ADDR_VAR 0 1
84561: PUSH
84562: LD_INT 1
84564: PUSH
84565: LD_INT 2
84567: PUSH
84568: LD_INT 3
84570: PUSH
84571: LD_INT 4
84573: PUSH
84574: LD_INT 5
84576: PUSH
84577: LD_INT 6
84579: PUSH
84580: LD_INT 7
84582: PUSH
84583: LD_INT 8
84585: PUSH
84586: LD_INT 9
84588: PUSH
84589: LD_INT 10
84591: PUSH
84592: LD_INT 11
84594: PUSH
84595: LD_INT 12
84597: PUSH
84598: LD_INT 13
84600: PUSH
84601: LD_INT 14
84603: PUSH
84604: LD_INT 15
84606: PUSH
84607: LD_INT 16
84609: PUSH
84610: LD_INT 17
84612: PUSH
84613: LD_INT 18
84615: PUSH
84616: LD_INT 19
84618: PUSH
84619: LD_INT 20
84621: PUSH
84622: LD_INT 21
84624: PUSH
84625: LD_INT 22
84627: PUSH
84628: LD_INT 23
84630: PUSH
84631: LD_INT 24
84633: PUSH
84634: LD_INT 25
84636: PUSH
84637: LD_INT 26
84639: PUSH
84640: LD_INT 27
84642: PUSH
84643: LD_INT 28
84645: PUSH
84646: LD_INT 30
84648: PUSH
84649: LD_INT 31
84651: PUSH
84652: LD_INT 32
84654: PUSH
84655: LD_INT 33
84657: PUSH
84658: LD_INT 34
84660: PUSH
84661: LD_INT 36
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: LIST
84684: LIST
84685: LIST
84686: LIST
84687: LIST
84688: LIST
84689: LIST
84690: LIST
84691: LIST
84692: LIST
84693: LIST
84694: LIST
84695: LIST
84696: LIST
84697: LIST
84698: LIST
84699: PUSH
84700: LD_INT 101
84702: PUSH
84703: LD_INT 102
84705: PUSH
84706: LD_INT 103
84708: PUSH
84709: LD_INT 104
84711: PUSH
84712: LD_INT 105
84714: PUSH
84715: LD_INT 106
84717: PUSH
84718: LD_INT 107
84720: PUSH
84721: LD_INT 108
84723: PUSH
84724: LD_INT 109
84726: PUSH
84727: LD_INT 110
84729: PUSH
84730: LD_INT 111
84732: PUSH
84733: LD_INT 112
84735: PUSH
84736: LD_INT 113
84738: PUSH
84739: LD_INT 114
84741: PUSH
84742: EMPTY
84743: LIST
84744: LIST
84745: LIST
84746: LIST
84747: LIST
84748: LIST
84749: LIST
84750: LIST
84751: LIST
84752: LIST
84753: LIST
84754: LIST
84755: LIST
84756: LIST
84757: PUSH
84758: EMPTY
84759: LIST
84760: LIST
84761: ST_TO_ADDR
84762: GO 86133
84764: LD_INT 13
84766: DOUBLE
84767: EQUAL
84768: IFTRUE 84772
84770: GO 84968
84772: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
84773: LD_ADDR_VAR 0 1
84777: PUSH
84778: LD_INT 1
84780: PUSH
84781: LD_INT 2
84783: PUSH
84784: LD_INT 3
84786: PUSH
84787: LD_INT 4
84789: PUSH
84790: LD_INT 5
84792: PUSH
84793: LD_INT 8
84795: PUSH
84796: LD_INT 9
84798: PUSH
84799: LD_INT 10
84801: PUSH
84802: LD_INT 11
84804: PUSH
84805: LD_INT 12
84807: PUSH
84808: LD_INT 14
84810: PUSH
84811: LD_INT 15
84813: PUSH
84814: LD_INT 16
84816: PUSH
84817: LD_INT 17
84819: PUSH
84820: LD_INT 18
84822: PUSH
84823: LD_INT 19
84825: PUSH
84826: LD_INT 20
84828: PUSH
84829: LD_INT 21
84831: PUSH
84832: LD_INT 22
84834: PUSH
84835: LD_INT 23
84837: PUSH
84838: LD_INT 24
84840: PUSH
84841: LD_INT 25
84843: PUSH
84844: LD_INT 26
84846: PUSH
84847: LD_INT 27
84849: PUSH
84850: LD_INT 28
84852: PUSH
84853: LD_INT 30
84855: PUSH
84856: LD_INT 31
84858: PUSH
84859: LD_INT 32
84861: PUSH
84862: LD_INT 33
84864: PUSH
84865: LD_INT 34
84867: PUSH
84868: LD_INT 36
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: LIST
84886: LIST
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: LIST
84892: LIST
84893: LIST
84894: LIST
84895: LIST
84896: LIST
84897: LIST
84898: LIST
84899: LIST
84900: LIST
84901: LIST
84902: LIST
84903: PUSH
84904: LD_INT 101
84906: PUSH
84907: LD_INT 102
84909: PUSH
84910: LD_INT 103
84912: PUSH
84913: LD_INT 104
84915: PUSH
84916: LD_INT 105
84918: PUSH
84919: LD_INT 106
84921: PUSH
84922: LD_INT 107
84924: PUSH
84925: LD_INT 108
84927: PUSH
84928: LD_INT 109
84930: PUSH
84931: LD_INT 110
84933: PUSH
84934: LD_INT 111
84936: PUSH
84937: LD_INT 112
84939: PUSH
84940: LD_INT 113
84942: PUSH
84943: LD_INT 114
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: LIST
84961: PUSH
84962: EMPTY
84963: LIST
84964: LIST
84965: ST_TO_ADDR
84966: GO 86133
84968: LD_INT 14
84970: DOUBLE
84971: EQUAL
84972: IFTRUE 84976
84974: GO 85188
84976: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
84977: LD_ADDR_VAR 0 1
84981: PUSH
84982: LD_INT 1
84984: PUSH
84985: LD_INT 2
84987: PUSH
84988: LD_INT 3
84990: PUSH
84991: LD_INT 4
84993: PUSH
84994: LD_INT 5
84996: PUSH
84997: LD_INT 6
84999: PUSH
85000: LD_INT 7
85002: PUSH
85003: LD_INT 8
85005: PUSH
85006: LD_INT 9
85008: PUSH
85009: LD_INT 10
85011: PUSH
85012: LD_INT 11
85014: PUSH
85015: LD_INT 12
85017: PUSH
85018: LD_INT 13
85020: PUSH
85021: LD_INT 14
85023: PUSH
85024: LD_INT 15
85026: PUSH
85027: LD_INT 16
85029: PUSH
85030: LD_INT 17
85032: PUSH
85033: LD_INT 18
85035: PUSH
85036: LD_INT 19
85038: PUSH
85039: LD_INT 20
85041: PUSH
85042: LD_INT 21
85044: PUSH
85045: LD_INT 22
85047: PUSH
85048: LD_INT 23
85050: PUSH
85051: LD_INT 24
85053: PUSH
85054: LD_INT 25
85056: PUSH
85057: LD_INT 26
85059: PUSH
85060: LD_INT 27
85062: PUSH
85063: LD_INT 28
85065: PUSH
85066: LD_INT 29
85068: PUSH
85069: LD_INT 30
85071: PUSH
85072: LD_INT 31
85074: PUSH
85075: LD_INT 32
85077: PUSH
85078: LD_INT 33
85080: PUSH
85081: LD_INT 34
85083: PUSH
85084: LD_INT 36
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: LIST
85102: LIST
85103: LIST
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: PUSH
85124: LD_INT 101
85126: PUSH
85127: LD_INT 102
85129: PUSH
85130: LD_INT 103
85132: PUSH
85133: LD_INT 104
85135: PUSH
85136: LD_INT 105
85138: PUSH
85139: LD_INT 106
85141: PUSH
85142: LD_INT 107
85144: PUSH
85145: LD_INT 108
85147: PUSH
85148: LD_INT 109
85150: PUSH
85151: LD_INT 110
85153: PUSH
85154: LD_INT 111
85156: PUSH
85157: LD_INT 112
85159: PUSH
85160: LD_INT 113
85162: PUSH
85163: LD_INT 114
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: LIST
85170: LIST
85171: LIST
85172: LIST
85173: LIST
85174: LIST
85175: LIST
85176: LIST
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: PUSH
85182: EMPTY
85183: LIST
85184: LIST
85185: ST_TO_ADDR
85186: GO 86133
85188: LD_INT 15
85190: DOUBLE
85191: EQUAL
85192: IFTRUE 85196
85194: GO 85408
85196: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
85197: LD_ADDR_VAR 0 1
85201: PUSH
85202: LD_INT 1
85204: PUSH
85205: LD_INT 2
85207: PUSH
85208: LD_INT 3
85210: PUSH
85211: LD_INT 4
85213: PUSH
85214: LD_INT 5
85216: PUSH
85217: LD_INT 6
85219: PUSH
85220: LD_INT 7
85222: PUSH
85223: LD_INT 8
85225: PUSH
85226: LD_INT 9
85228: PUSH
85229: LD_INT 10
85231: PUSH
85232: LD_INT 11
85234: PUSH
85235: LD_INT 12
85237: PUSH
85238: LD_INT 13
85240: PUSH
85241: LD_INT 14
85243: PUSH
85244: LD_INT 15
85246: PUSH
85247: LD_INT 16
85249: PUSH
85250: LD_INT 17
85252: PUSH
85253: LD_INT 18
85255: PUSH
85256: LD_INT 19
85258: PUSH
85259: LD_INT 20
85261: PUSH
85262: LD_INT 21
85264: PUSH
85265: LD_INT 22
85267: PUSH
85268: LD_INT 23
85270: PUSH
85271: LD_INT 24
85273: PUSH
85274: LD_INT 25
85276: PUSH
85277: LD_INT 26
85279: PUSH
85280: LD_INT 27
85282: PUSH
85283: LD_INT 28
85285: PUSH
85286: LD_INT 29
85288: PUSH
85289: LD_INT 30
85291: PUSH
85292: LD_INT 31
85294: PUSH
85295: LD_INT 32
85297: PUSH
85298: LD_INT 33
85300: PUSH
85301: LD_INT 34
85303: PUSH
85304: LD_INT 36
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: PUSH
85344: LD_INT 101
85346: PUSH
85347: LD_INT 102
85349: PUSH
85350: LD_INT 103
85352: PUSH
85353: LD_INT 104
85355: PUSH
85356: LD_INT 105
85358: PUSH
85359: LD_INT 106
85361: PUSH
85362: LD_INT 107
85364: PUSH
85365: LD_INT 108
85367: PUSH
85368: LD_INT 109
85370: PUSH
85371: LD_INT 110
85373: PUSH
85374: LD_INT 111
85376: PUSH
85377: LD_INT 112
85379: PUSH
85380: LD_INT 113
85382: PUSH
85383: LD_INT 114
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: LIST
85390: LIST
85391: LIST
85392: LIST
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: PUSH
85402: EMPTY
85403: LIST
85404: LIST
85405: ST_TO_ADDR
85406: GO 86133
85408: LD_INT 16
85410: DOUBLE
85411: EQUAL
85412: IFTRUE 85416
85414: GO 85540
85416: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
85417: LD_ADDR_VAR 0 1
85421: PUSH
85422: LD_INT 2
85424: PUSH
85425: LD_INT 4
85427: PUSH
85428: LD_INT 5
85430: PUSH
85431: LD_INT 7
85433: PUSH
85434: LD_INT 11
85436: PUSH
85437: LD_INT 12
85439: PUSH
85440: LD_INT 15
85442: PUSH
85443: LD_INT 16
85445: PUSH
85446: LD_INT 20
85448: PUSH
85449: LD_INT 21
85451: PUSH
85452: LD_INT 22
85454: PUSH
85455: LD_INT 23
85457: PUSH
85458: LD_INT 25
85460: PUSH
85461: LD_INT 26
85463: PUSH
85464: LD_INT 30
85466: PUSH
85467: LD_INT 31
85469: PUSH
85470: LD_INT 32
85472: PUSH
85473: LD_INT 33
85475: PUSH
85476: LD_INT 34
85478: PUSH
85479: EMPTY
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: LIST
85496: LIST
85497: LIST
85498: LIST
85499: PUSH
85500: LD_INT 101
85502: PUSH
85503: LD_INT 102
85505: PUSH
85506: LD_INT 103
85508: PUSH
85509: LD_INT 106
85511: PUSH
85512: LD_INT 108
85514: PUSH
85515: LD_INT 112
85517: PUSH
85518: LD_INT 113
85520: PUSH
85521: LD_INT 114
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: PUSH
85534: EMPTY
85535: LIST
85536: LIST
85537: ST_TO_ADDR
85538: GO 86133
85540: LD_INT 17
85542: DOUBLE
85543: EQUAL
85544: IFTRUE 85548
85546: GO 85760
85548: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
85549: LD_ADDR_VAR 0 1
85553: PUSH
85554: LD_INT 1
85556: PUSH
85557: LD_INT 2
85559: PUSH
85560: LD_INT 3
85562: PUSH
85563: LD_INT 4
85565: PUSH
85566: LD_INT 5
85568: PUSH
85569: LD_INT 6
85571: PUSH
85572: LD_INT 7
85574: PUSH
85575: LD_INT 8
85577: PUSH
85578: LD_INT 9
85580: PUSH
85581: LD_INT 10
85583: PUSH
85584: LD_INT 11
85586: PUSH
85587: LD_INT 12
85589: PUSH
85590: LD_INT 13
85592: PUSH
85593: LD_INT 14
85595: PUSH
85596: LD_INT 15
85598: PUSH
85599: LD_INT 16
85601: PUSH
85602: LD_INT 17
85604: PUSH
85605: LD_INT 18
85607: PUSH
85608: LD_INT 19
85610: PUSH
85611: LD_INT 20
85613: PUSH
85614: LD_INT 21
85616: PUSH
85617: LD_INT 22
85619: PUSH
85620: LD_INT 23
85622: PUSH
85623: LD_INT 24
85625: PUSH
85626: LD_INT 25
85628: PUSH
85629: LD_INT 26
85631: PUSH
85632: LD_INT 27
85634: PUSH
85635: LD_INT 28
85637: PUSH
85638: LD_INT 29
85640: PUSH
85641: LD_INT 30
85643: PUSH
85644: LD_INT 31
85646: PUSH
85647: LD_INT 32
85649: PUSH
85650: LD_INT 33
85652: PUSH
85653: LD_INT 34
85655: PUSH
85656: LD_INT 36
85658: PUSH
85659: EMPTY
85660: LIST
85661: LIST
85662: LIST
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: LIST
85695: PUSH
85696: LD_INT 101
85698: PUSH
85699: LD_INT 102
85701: PUSH
85702: LD_INT 103
85704: PUSH
85705: LD_INT 104
85707: PUSH
85708: LD_INT 105
85710: PUSH
85711: LD_INT 106
85713: PUSH
85714: LD_INT 107
85716: PUSH
85717: LD_INT 108
85719: PUSH
85720: LD_INT 109
85722: PUSH
85723: LD_INT 110
85725: PUSH
85726: LD_INT 111
85728: PUSH
85729: LD_INT 112
85731: PUSH
85732: LD_INT 113
85734: PUSH
85735: LD_INT 114
85737: PUSH
85738: EMPTY
85739: LIST
85740: LIST
85741: LIST
85742: LIST
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: ST_TO_ADDR
85758: GO 86133
85760: LD_INT 18
85762: DOUBLE
85763: EQUAL
85764: IFTRUE 85768
85766: GO 85904
85768: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
85769: LD_ADDR_VAR 0 1
85773: PUSH
85774: LD_INT 2
85776: PUSH
85777: LD_INT 4
85779: PUSH
85780: LD_INT 5
85782: PUSH
85783: LD_INT 7
85785: PUSH
85786: LD_INT 11
85788: PUSH
85789: LD_INT 12
85791: PUSH
85792: LD_INT 15
85794: PUSH
85795: LD_INT 16
85797: PUSH
85798: LD_INT 20
85800: PUSH
85801: LD_INT 21
85803: PUSH
85804: LD_INT 22
85806: PUSH
85807: LD_INT 23
85809: PUSH
85810: LD_INT 25
85812: PUSH
85813: LD_INT 26
85815: PUSH
85816: LD_INT 30
85818: PUSH
85819: LD_INT 31
85821: PUSH
85822: LD_INT 32
85824: PUSH
85825: LD_INT 33
85827: PUSH
85828: LD_INT 34
85830: PUSH
85831: LD_INT 35
85833: PUSH
85834: LD_INT 36
85836: PUSH
85837: EMPTY
85838: LIST
85839: LIST
85840: LIST
85841: LIST
85842: LIST
85843: LIST
85844: LIST
85845: LIST
85846: LIST
85847: LIST
85848: LIST
85849: LIST
85850: LIST
85851: LIST
85852: LIST
85853: LIST
85854: LIST
85855: LIST
85856: LIST
85857: LIST
85858: LIST
85859: PUSH
85860: LD_INT 101
85862: PUSH
85863: LD_INT 102
85865: PUSH
85866: LD_INT 103
85868: PUSH
85869: LD_INT 106
85871: PUSH
85872: LD_INT 108
85874: PUSH
85875: LD_INT 112
85877: PUSH
85878: LD_INT 113
85880: PUSH
85881: LD_INT 114
85883: PUSH
85884: LD_INT 115
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: PUSH
85898: EMPTY
85899: LIST
85900: LIST
85901: ST_TO_ADDR
85902: GO 86133
85904: LD_INT 19
85906: DOUBLE
85907: EQUAL
85908: IFTRUE 85912
85910: GO 86132
85912: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
85913: LD_ADDR_VAR 0 1
85917: PUSH
85918: LD_INT 1
85920: PUSH
85921: LD_INT 2
85923: PUSH
85924: LD_INT 3
85926: PUSH
85927: LD_INT 4
85929: PUSH
85930: LD_INT 5
85932: PUSH
85933: LD_INT 6
85935: PUSH
85936: LD_INT 7
85938: PUSH
85939: LD_INT 8
85941: PUSH
85942: LD_INT 9
85944: PUSH
85945: LD_INT 10
85947: PUSH
85948: LD_INT 11
85950: PUSH
85951: LD_INT 12
85953: PUSH
85954: LD_INT 13
85956: PUSH
85957: LD_INT 14
85959: PUSH
85960: LD_INT 15
85962: PUSH
85963: LD_INT 16
85965: PUSH
85966: LD_INT 17
85968: PUSH
85969: LD_INT 18
85971: PUSH
85972: LD_INT 19
85974: PUSH
85975: LD_INT 20
85977: PUSH
85978: LD_INT 21
85980: PUSH
85981: LD_INT 22
85983: PUSH
85984: LD_INT 23
85986: PUSH
85987: LD_INT 24
85989: PUSH
85990: LD_INT 25
85992: PUSH
85993: LD_INT 26
85995: PUSH
85996: LD_INT 27
85998: PUSH
85999: LD_INT 28
86001: PUSH
86002: LD_INT 29
86004: PUSH
86005: LD_INT 30
86007: PUSH
86008: LD_INT 31
86010: PUSH
86011: LD_INT 32
86013: PUSH
86014: LD_INT 33
86016: PUSH
86017: LD_INT 34
86019: PUSH
86020: LD_INT 35
86022: PUSH
86023: LD_INT 36
86025: PUSH
86026: EMPTY
86027: LIST
86028: LIST
86029: LIST
86030: LIST
86031: LIST
86032: LIST
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: LIST
86046: LIST
86047: LIST
86048: LIST
86049: LIST
86050: LIST
86051: LIST
86052: LIST
86053: LIST
86054: LIST
86055: LIST
86056: LIST
86057: LIST
86058: LIST
86059: LIST
86060: LIST
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 101
86066: PUSH
86067: LD_INT 102
86069: PUSH
86070: LD_INT 103
86072: PUSH
86073: LD_INT 104
86075: PUSH
86076: LD_INT 105
86078: PUSH
86079: LD_INT 106
86081: PUSH
86082: LD_INT 107
86084: PUSH
86085: LD_INT 108
86087: PUSH
86088: LD_INT 109
86090: PUSH
86091: LD_INT 110
86093: PUSH
86094: LD_INT 111
86096: PUSH
86097: LD_INT 112
86099: PUSH
86100: LD_INT 113
86102: PUSH
86103: LD_INT 114
86105: PUSH
86106: LD_INT 115
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: LIST
86113: LIST
86114: LIST
86115: LIST
86116: LIST
86117: LIST
86118: LIST
86119: LIST
86120: LIST
86121: LIST
86122: LIST
86123: LIST
86124: LIST
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: ST_TO_ADDR
86130: GO 86133
86132: POP
// end else
86133: GO 86352
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
86135: LD_ADDR_VAR 0 1
86139: PUSH
86140: LD_INT 1
86142: PUSH
86143: LD_INT 2
86145: PUSH
86146: LD_INT 3
86148: PUSH
86149: LD_INT 4
86151: PUSH
86152: LD_INT 5
86154: PUSH
86155: LD_INT 6
86157: PUSH
86158: LD_INT 7
86160: PUSH
86161: LD_INT 8
86163: PUSH
86164: LD_INT 9
86166: PUSH
86167: LD_INT 10
86169: PUSH
86170: LD_INT 11
86172: PUSH
86173: LD_INT 12
86175: PUSH
86176: LD_INT 13
86178: PUSH
86179: LD_INT 14
86181: PUSH
86182: LD_INT 15
86184: PUSH
86185: LD_INT 16
86187: PUSH
86188: LD_INT 17
86190: PUSH
86191: LD_INT 18
86193: PUSH
86194: LD_INT 19
86196: PUSH
86197: LD_INT 20
86199: PUSH
86200: LD_INT 21
86202: PUSH
86203: LD_INT 22
86205: PUSH
86206: LD_INT 23
86208: PUSH
86209: LD_INT 24
86211: PUSH
86212: LD_INT 25
86214: PUSH
86215: LD_INT 26
86217: PUSH
86218: LD_INT 27
86220: PUSH
86221: LD_INT 28
86223: PUSH
86224: LD_INT 29
86226: PUSH
86227: LD_INT 30
86229: PUSH
86230: LD_INT 31
86232: PUSH
86233: LD_INT 32
86235: PUSH
86236: LD_INT 33
86238: PUSH
86239: LD_INT 34
86241: PUSH
86242: LD_INT 35
86244: PUSH
86245: LD_INT 36
86247: PUSH
86248: EMPTY
86249: LIST
86250: LIST
86251: LIST
86252: LIST
86253: LIST
86254: LIST
86255: LIST
86256: LIST
86257: LIST
86258: LIST
86259: LIST
86260: LIST
86261: LIST
86262: LIST
86263: LIST
86264: LIST
86265: LIST
86266: LIST
86267: LIST
86268: LIST
86269: LIST
86270: LIST
86271: LIST
86272: LIST
86273: LIST
86274: LIST
86275: LIST
86276: LIST
86277: LIST
86278: LIST
86279: LIST
86280: LIST
86281: LIST
86282: LIST
86283: LIST
86284: LIST
86285: PUSH
86286: LD_INT 101
86288: PUSH
86289: LD_INT 102
86291: PUSH
86292: LD_INT 103
86294: PUSH
86295: LD_INT 104
86297: PUSH
86298: LD_INT 105
86300: PUSH
86301: LD_INT 106
86303: PUSH
86304: LD_INT 107
86306: PUSH
86307: LD_INT 108
86309: PUSH
86310: LD_INT 109
86312: PUSH
86313: LD_INT 110
86315: PUSH
86316: LD_INT 111
86318: PUSH
86319: LD_INT 112
86321: PUSH
86322: LD_INT 113
86324: PUSH
86325: LD_INT 114
86327: PUSH
86328: LD_INT 115
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: LIST
86335: LIST
86336: LIST
86337: LIST
86338: LIST
86339: LIST
86340: LIST
86341: LIST
86342: LIST
86343: LIST
86344: LIST
86345: LIST
86346: LIST
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: ST_TO_ADDR
// if result then
86352: LD_VAR 0 1
86356: IFFALSE 86645
// begin normal :=  ;
86358: LD_ADDR_VAR 0 3
86362: PUSH
86363: LD_STRING 
86365: ST_TO_ADDR
// hardcore :=  ;
86366: LD_ADDR_VAR 0 4
86370: PUSH
86371: LD_STRING 
86373: ST_TO_ADDR
// for i = 1 to normalCounter do
86374: LD_ADDR_VAR 0 5
86378: PUSH
86379: DOUBLE
86380: LD_INT 1
86382: DEC
86383: ST_TO_ADDR
86384: LD_EXP 119
86388: PUSH
86389: FOR_TO
86390: IFFALSE 86491
// begin tmp := 0 ;
86392: LD_ADDR_VAR 0 2
86396: PUSH
86397: LD_STRING 0
86399: ST_TO_ADDR
// if result [ 1 ] then
86400: LD_VAR 0 1
86404: PUSH
86405: LD_INT 1
86407: ARRAY
86408: IFFALSE 86473
// if result [ 1 ] [ 1 ] = i then
86410: LD_VAR 0 1
86414: PUSH
86415: LD_INT 1
86417: ARRAY
86418: PUSH
86419: LD_INT 1
86421: ARRAY
86422: PUSH
86423: LD_VAR 0 5
86427: EQUAL
86428: IFFALSE 86473
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
86430: LD_ADDR_VAR 0 1
86434: PUSH
86435: LD_VAR 0 1
86439: PPUSH
86440: LD_INT 1
86442: PPUSH
86443: LD_VAR 0 1
86447: PUSH
86448: LD_INT 1
86450: ARRAY
86451: PPUSH
86452: LD_INT 1
86454: PPUSH
86455: CALL_OW 3
86459: PPUSH
86460: CALL_OW 1
86464: ST_TO_ADDR
// tmp := 1 ;
86465: LD_ADDR_VAR 0 2
86469: PUSH
86470: LD_STRING 1
86472: ST_TO_ADDR
// end ; normal := normal & tmp ;
86473: LD_ADDR_VAR 0 3
86477: PUSH
86478: LD_VAR 0 3
86482: PUSH
86483: LD_VAR 0 2
86487: STR
86488: ST_TO_ADDR
// end ;
86489: GO 86389
86491: POP
86492: POP
// for i = 1 to hardcoreCounter do
86493: LD_ADDR_VAR 0 5
86497: PUSH
86498: DOUBLE
86499: LD_INT 1
86501: DEC
86502: ST_TO_ADDR
86503: LD_EXP 120
86507: PUSH
86508: FOR_TO
86509: IFFALSE 86614
// begin tmp := 0 ;
86511: LD_ADDR_VAR 0 2
86515: PUSH
86516: LD_STRING 0
86518: ST_TO_ADDR
// if result [ 2 ] then
86519: LD_VAR 0 1
86523: PUSH
86524: LD_INT 2
86526: ARRAY
86527: IFFALSE 86596
// if result [ 2 ] [ 1 ] = 100 + i then
86529: LD_VAR 0 1
86533: PUSH
86534: LD_INT 2
86536: ARRAY
86537: PUSH
86538: LD_INT 1
86540: ARRAY
86541: PUSH
86542: LD_INT 100
86544: PUSH
86545: LD_VAR 0 5
86549: PLUS
86550: EQUAL
86551: IFFALSE 86596
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
86553: LD_ADDR_VAR 0 1
86557: PUSH
86558: LD_VAR 0 1
86562: PPUSH
86563: LD_INT 2
86565: PPUSH
86566: LD_VAR 0 1
86570: PUSH
86571: LD_INT 2
86573: ARRAY
86574: PPUSH
86575: LD_INT 1
86577: PPUSH
86578: CALL_OW 3
86582: PPUSH
86583: CALL_OW 1
86587: ST_TO_ADDR
// tmp := 1 ;
86588: LD_ADDR_VAR 0 2
86592: PUSH
86593: LD_STRING 1
86595: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
86596: LD_ADDR_VAR 0 4
86600: PUSH
86601: LD_VAR 0 4
86605: PUSH
86606: LD_VAR 0 2
86610: STR
86611: ST_TO_ADDR
// end ;
86612: GO 86508
86614: POP
86615: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
86616: LD_STRING getStreamItemsFromMission("
86618: PUSH
86619: LD_VAR 0 3
86623: STR
86624: PUSH
86625: LD_STRING ","
86627: STR
86628: PUSH
86629: LD_VAR 0 4
86633: STR
86634: PUSH
86635: LD_STRING ")
86637: STR
86638: PPUSH
86639: CALL_OW 559
// end else
86643: GO 86652
// ToLua ( getStreamItemsFromMission("","") ) ;
86645: LD_STRING getStreamItemsFromMission("","")
86647: PPUSH
86648: CALL_OW 559
// end ;
86652: LD_VAR 0 1
86656: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
86657: LD_EXP 118
86661: PUSH
86662: LD_EXP 123
86666: AND
86667: IFFALSE 86791
86669: GO 86671
86671: DISABLE
86672: LD_INT 0
86674: PPUSH
86675: PPUSH
// begin enable ;
86676: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
86677: LD_ADDR_VAR 0 2
86681: PUSH
86682: LD_INT 22
86684: PUSH
86685: LD_OWVAR 2
86689: PUSH
86690: EMPTY
86691: LIST
86692: LIST
86693: PUSH
86694: LD_INT 2
86696: PUSH
86697: LD_INT 34
86699: PUSH
86700: LD_INT 7
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: PUSH
86707: LD_INT 34
86709: PUSH
86710: LD_INT 45
86712: PUSH
86713: EMPTY
86714: LIST
86715: LIST
86716: PUSH
86717: LD_INT 34
86719: PUSH
86720: LD_INT 28
86722: PUSH
86723: EMPTY
86724: LIST
86725: LIST
86726: PUSH
86727: LD_INT 34
86729: PUSH
86730: LD_INT 47
86732: PUSH
86733: EMPTY
86734: LIST
86735: LIST
86736: PUSH
86737: EMPTY
86738: LIST
86739: LIST
86740: LIST
86741: LIST
86742: LIST
86743: PUSH
86744: EMPTY
86745: LIST
86746: LIST
86747: PPUSH
86748: CALL_OW 69
86752: ST_TO_ADDR
// if not tmp then
86753: LD_VAR 0 2
86757: NOT
86758: IFFALSE 86762
// exit ;
86760: GO 86791
// for i in tmp do
86762: LD_ADDR_VAR 0 1
86766: PUSH
86767: LD_VAR 0 2
86771: PUSH
86772: FOR_IN
86773: IFFALSE 86789
// begin SetLives ( i , 0 ) ;
86775: LD_VAR 0 1
86779: PPUSH
86780: LD_INT 0
86782: PPUSH
86783: CALL_OW 234
// end ;
86787: GO 86772
86789: POP
86790: POP
// end ;
86791: PPOPN 2
86793: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
86794: LD_EXP 118
86798: PUSH
86799: LD_EXP 124
86803: AND
86804: IFFALSE 86888
86806: GO 86808
86808: DISABLE
86809: LD_INT 0
86811: PPUSH
86812: PPUSH
// begin enable ;
86813: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
86814: LD_ADDR_VAR 0 2
86818: PUSH
86819: LD_INT 22
86821: PUSH
86822: LD_OWVAR 2
86826: PUSH
86827: EMPTY
86828: LIST
86829: LIST
86830: PUSH
86831: LD_INT 32
86833: PUSH
86834: LD_INT 3
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PPUSH
86845: CALL_OW 69
86849: ST_TO_ADDR
// if not tmp then
86850: LD_VAR 0 2
86854: NOT
86855: IFFALSE 86859
// exit ;
86857: GO 86888
// for i in tmp do
86859: LD_ADDR_VAR 0 1
86863: PUSH
86864: LD_VAR 0 2
86868: PUSH
86869: FOR_IN
86870: IFFALSE 86886
// begin SetLives ( i , 0 ) ;
86872: LD_VAR 0 1
86876: PPUSH
86877: LD_INT 0
86879: PPUSH
86880: CALL_OW 234
// end ;
86884: GO 86869
86886: POP
86887: POP
// end ;
86888: PPOPN 2
86890: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
86891: LD_EXP 118
86895: PUSH
86896: LD_EXP 121
86900: AND
86901: IFFALSE 86994
86903: GO 86905
86905: DISABLE
86906: LD_INT 0
86908: PPUSH
// begin enable ;
86909: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
86910: LD_ADDR_VAR 0 1
86914: PUSH
86915: LD_INT 22
86917: PUSH
86918: LD_OWVAR 2
86922: PUSH
86923: EMPTY
86924: LIST
86925: LIST
86926: PUSH
86927: LD_INT 2
86929: PUSH
86930: LD_INT 25
86932: PUSH
86933: LD_INT 5
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 25
86942: PUSH
86943: LD_INT 9
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 25
86952: PUSH
86953: LD_INT 8
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: EMPTY
86961: LIST
86962: LIST
86963: LIST
86964: LIST
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PPUSH
86970: CALL_OW 69
86974: PUSH
86975: FOR_IN
86976: IFFALSE 86992
// begin SetClass ( i , 1 ) ;
86978: LD_VAR 0 1
86982: PPUSH
86983: LD_INT 1
86985: PPUSH
86986: CALL_OW 336
// end ;
86990: GO 86975
86992: POP
86993: POP
// end ;
86994: PPOPN 1
86996: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
86997: LD_EXP 118
87001: PUSH
87002: LD_EXP 122
87006: AND
87007: PUSH
87008: LD_OWVAR 65
87012: PUSH
87013: LD_INT 7
87015: LESS
87016: AND
87017: IFFALSE 87031
87019: GO 87021
87021: DISABLE
// begin enable ;
87022: ENABLE
// game_speed := 7 ;
87023: LD_ADDR_OWVAR 65
87027: PUSH
87028: LD_INT 7
87030: ST_TO_ADDR
// end ;
87031: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
87032: LD_EXP 118
87036: PUSH
87037: LD_EXP 125
87041: AND
87042: IFFALSE 87244
87044: GO 87046
87046: DISABLE
87047: LD_INT 0
87049: PPUSH
87050: PPUSH
87051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
87052: LD_ADDR_VAR 0 3
87056: PUSH
87057: LD_INT 81
87059: PUSH
87060: LD_OWVAR 2
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 21
87071: PUSH
87072: LD_INT 1
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: PPUSH
87083: CALL_OW 69
87087: ST_TO_ADDR
// if not tmp then
87088: LD_VAR 0 3
87092: NOT
87093: IFFALSE 87097
// exit ;
87095: GO 87244
// if tmp > 5 then
87097: LD_VAR 0 3
87101: PUSH
87102: LD_INT 5
87104: GREATER
87105: IFFALSE 87117
// k := 5 else
87107: LD_ADDR_VAR 0 2
87111: PUSH
87112: LD_INT 5
87114: ST_TO_ADDR
87115: GO 87127
// k := tmp ;
87117: LD_ADDR_VAR 0 2
87121: PUSH
87122: LD_VAR 0 3
87126: ST_TO_ADDR
// for i := 1 to k do
87127: LD_ADDR_VAR 0 1
87131: PUSH
87132: DOUBLE
87133: LD_INT 1
87135: DEC
87136: ST_TO_ADDR
87137: LD_VAR 0 2
87141: PUSH
87142: FOR_TO
87143: IFFALSE 87242
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
87145: LD_VAR 0 3
87149: PUSH
87150: LD_VAR 0 1
87154: ARRAY
87155: PPUSH
87156: LD_VAR 0 1
87160: PUSH
87161: LD_INT 4
87163: MOD
87164: PUSH
87165: LD_INT 1
87167: PLUS
87168: PPUSH
87169: CALL_OW 259
87173: PUSH
87174: LD_INT 10
87176: LESS
87177: IFFALSE 87240
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
87179: LD_VAR 0 3
87183: PUSH
87184: LD_VAR 0 1
87188: ARRAY
87189: PPUSH
87190: LD_VAR 0 1
87194: PUSH
87195: LD_INT 4
87197: MOD
87198: PUSH
87199: LD_INT 1
87201: PLUS
87202: PPUSH
87203: LD_VAR 0 3
87207: PUSH
87208: LD_VAR 0 1
87212: ARRAY
87213: PPUSH
87214: LD_VAR 0 1
87218: PUSH
87219: LD_INT 4
87221: MOD
87222: PUSH
87223: LD_INT 1
87225: PLUS
87226: PPUSH
87227: CALL_OW 259
87231: PUSH
87232: LD_INT 1
87234: PLUS
87235: PPUSH
87236: CALL_OW 237
87240: GO 87142
87242: POP
87243: POP
// end ;
87244: PPOPN 3
87246: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
87247: LD_EXP 118
87251: PUSH
87252: LD_EXP 126
87256: AND
87257: IFFALSE 87277
87259: GO 87261
87261: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
87262: LD_INT 4
87264: PPUSH
87265: LD_OWVAR 2
87269: PPUSH
87270: LD_INT 0
87272: PPUSH
87273: CALL_OW 324
87277: END
// every 0 0$1 trigger StreamModeActive and sShovel do
87278: LD_EXP 118
87282: PUSH
87283: LD_EXP 155
87287: AND
87288: IFFALSE 87308
87290: GO 87292
87292: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
87293: LD_INT 19
87295: PPUSH
87296: LD_OWVAR 2
87300: PPUSH
87301: LD_INT 0
87303: PPUSH
87304: CALL_OW 324
87308: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
87309: LD_EXP 118
87313: PUSH
87314: LD_EXP 127
87318: AND
87319: IFFALSE 87421
87321: GO 87323
87323: DISABLE
87324: LD_INT 0
87326: PPUSH
87327: PPUSH
// begin enable ;
87328: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
87329: LD_ADDR_VAR 0 2
87333: PUSH
87334: LD_INT 22
87336: PUSH
87337: LD_OWVAR 2
87341: PUSH
87342: EMPTY
87343: LIST
87344: LIST
87345: PUSH
87346: LD_INT 2
87348: PUSH
87349: LD_INT 34
87351: PUSH
87352: LD_INT 11
87354: PUSH
87355: EMPTY
87356: LIST
87357: LIST
87358: PUSH
87359: LD_INT 34
87361: PUSH
87362: LD_INT 30
87364: PUSH
87365: EMPTY
87366: LIST
87367: LIST
87368: PUSH
87369: EMPTY
87370: LIST
87371: LIST
87372: LIST
87373: PUSH
87374: EMPTY
87375: LIST
87376: LIST
87377: PPUSH
87378: CALL_OW 69
87382: ST_TO_ADDR
// if not tmp then
87383: LD_VAR 0 2
87387: NOT
87388: IFFALSE 87392
// exit ;
87390: GO 87421
// for i in tmp do
87392: LD_ADDR_VAR 0 1
87396: PUSH
87397: LD_VAR 0 2
87401: PUSH
87402: FOR_IN
87403: IFFALSE 87419
// begin SetLives ( i , 0 ) ;
87405: LD_VAR 0 1
87409: PPUSH
87410: LD_INT 0
87412: PPUSH
87413: CALL_OW 234
// end ;
87417: GO 87402
87419: POP
87420: POP
// end ;
87421: PPOPN 2
87423: END
// every 0 0$1 trigger StreamModeActive and sBunker do
87424: LD_EXP 118
87428: PUSH
87429: LD_EXP 128
87433: AND
87434: IFFALSE 87454
87436: GO 87438
87438: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
87439: LD_INT 32
87441: PPUSH
87442: LD_OWVAR 2
87446: PPUSH
87447: LD_INT 0
87449: PPUSH
87450: CALL_OW 324
87454: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
87455: LD_EXP 118
87459: PUSH
87460: LD_EXP 129
87464: AND
87465: IFFALSE 87646
87467: GO 87469
87469: DISABLE
87470: LD_INT 0
87472: PPUSH
87473: PPUSH
87474: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
87475: LD_ADDR_VAR 0 2
87479: PUSH
87480: LD_INT 22
87482: PUSH
87483: LD_OWVAR 2
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: PUSH
87492: LD_INT 33
87494: PUSH
87495: LD_INT 3
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PPUSH
87506: CALL_OW 69
87510: ST_TO_ADDR
// if not tmp then
87511: LD_VAR 0 2
87515: NOT
87516: IFFALSE 87520
// exit ;
87518: GO 87646
// side := 0 ;
87520: LD_ADDR_VAR 0 3
87524: PUSH
87525: LD_INT 0
87527: ST_TO_ADDR
// for i := 1 to 8 do
87528: LD_ADDR_VAR 0 1
87532: PUSH
87533: DOUBLE
87534: LD_INT 1
87536: DEC
87537: ST_TO_ADDR
87538: LD_INT 8
87540: PUSH
87541: FOR_TO
87542: IFFALSE 87590
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
87544: LD_OWVAR 2
87548: PUSH
87549: LD_VAR 0 1
87553: NONEQUAL
87554: PUSH
87555: LD_OWVAR 2
87559: PPUSH
87560: LD_VAR 0 1
87564: PPUSH
87565: CALL_OW 81
87569: PUSH
87570: LD_INT 2
87572: EQUAL
87573: AND
87574: IFFALSE 87588
// begin side := i ;
87576: LD_ADDR_VAR 0 3
87580: PUSH
87581: LD_VAR 0 1
87585: ST_TO_ADDR
// break ;
87586: GO 87590
// end ;
87588: GO 87541
87590: POP
87591: POP
// if not side then
87592: LD_VAR 0 3
87596: NOT
87597: IFFALSE 87601
// exit ;
87599: GO 87646
// for i := 1 to tmp do
87601: LD_ADDR_VAR 0 1
87605: PUSH
87606: DOUBLE
87607: LD_INT 1
87609: DEC
87610: ST_TO_ADDR
87611: LD_VAR 0 2
87615: PUSH
87616: FOR_TO
87617: IFFALSE 87644
// if Prob ( 60 ) then
87619: LD_INT 60
87621: PPUSH
87622: CALL_OW 13
87626: IFFALSE 87642
// SetSide ( i , side ) ;
87628: LD_VAR 0 1
87632: PPUSH
87633: LD_VAR 0 3
87637: PPUSH
87638: CALL_OW 235
87642: GO 87616
87644: POP
87645: POP
// end ;
87646: PPOPN 3
87648: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
87649: LD_EXP 118
87653: PUSH
87654: LD_EXP 131
87658: AND
87659: IFFALSE 87778
87661: GO 87663
87663: DISABLE
87664: LD_INT 0
87666: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
87667: LD_ADDR_VAR 0 1
87671: PUSH
87672: LD_INT 22
87674: PUSH
87675: LD_OWVAR 2
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: PUSH
87684: LD_INT 21
87686: PUSH
87687: LD_INT 1
87689: PUSH
87690: EMPTY
87691: LIST
87692: LIST
87693: PUSH
87694: LD_INT 3
87696: PUSH
87697: LD_INT 23
87699: PUSH
87700: LD_INT 0
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: EMPTY
87712: LIST
87713: LIST
87714: LIST
87715: PPUSH
87716: CALL_OW 69
87720: PUSH
87721: FOR_IN
87722: IFFALSE 87776
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
87724: LD_VAR 0 1
87728: PPUSH
87729: CALL_OW 257
87733: PUSH
87734: LD_INT 1
87736: PUSH
87737: LD_INT 2
87739: PUSH
87740: LD_INT 3
87742: PUSH
87743: LD_INT 4
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: IN
87752: IFFALSE 87774
// SetClass ( un , rand ( 1 , 4 ) ) ;
87754: LD_VAR 0 1
87758: PPUSH
87759: LD_INT 1
87761: PPUSH
87762: LD_INT 4
87764: PPUSH
87765: CALL_OW 12
87769: PPUSH
87770: CALL_OW 336
87774: GO 87721
87776: POP
87777: POP
// end ;
87778: PPOPN 1
87780: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
87781: LD_EXP 118
87785: PUSH
87786: LD_EXP 130
87790: AND
87791: IFFALSE 87870
87793: GO 87795
87795: DISABLE
87796: LD_INT 0
87798: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
87799: LD_ADDR_VAR 0 1
87803: PUSH
87804: LD_INT 22
87806: PUSH
87807: LD_OWVAR 2
87811: PUSH
87812: EMPTY
87813: LIST
87814: LIST
87815: PUSH
87816: LD_INT 21
87818: PUSH
87819: LD_INT 3
87821: PUSH
87822: EMPTY
87823: LIST
87824: LIST
87825: PUSH
87826: EMPTY
87827: LIST
87828: LIST
87829: PPUSH
87830: CALL_OW 69
87834: ST_TO_ADDR
// if not tmp then
87835: LD_VAR 0 1
87839: NOT
87840: IFFALSE 87844
// exit ;
87842: GO 87870
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
87844: LD_VAR 0 1
87848: PUSH
87849: LD_INT 1
87851: PPUSH
87852: LD_VAR 0 1
87856: PPUSH
87857: CALL_OW 12
87861: ARRAY
87862: PPUSH
87863: LD_INT 100
87865: PPUSH
87866: CALL_OW 234
// end ;
87870: PPOPN 1
87872: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
87873: LD_EXP 118
87877: PUSH
87878: LD_EXP 132
87882: AND
87883: IFFALSE 87981
87885: GO 87887
87887: DISABLE
87888: LD_INT 0
87890: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
87891: LD_ADDR_VAR 0 1
87895: PUSH
87896: LD_INT 22
87898: PUSH
87899: LD_OWVAR 2
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: PUSH
87908: LD_INT 21
87910: PUSH
87911: LD_INT 1
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PPUSH
87922: CALL_OW 69
87926: ST_TO_ADDR
// if not tmp then
87927: LD_VAR 0 1
87931: NOT
87932: IFFALSE 87936
// exit ;
87934: GO 87981
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
87936: LD_VAR 0 1
87940: PUSH
87941: LD_INT 1
87943: PPUSH
87944: LD_VAR 0 1
87948: PPUSH
87949: CALL_OW 12
87953: ARRAY
87954: PPUSH
87955: LD_INT 1
87957: PPUSH
87958: LD_INT 4
87960: PPUSH
87961: CALL_OW 12
87965: PPUSH
87966: LD_INT 3000
87968: PPUSH
87969: LD_INT 9000
87971: PPUSH
87972: CALL_OW 12
87976: PPUSH
87977: CALL_OW 492
// end ;
87981: PPOPN 1
87983: END
// every 0 0$1 trigger StreamModeActive and sDepot do
87984: LD_EXP 118
87988: PUSH
87989: LD_EXP 133
87993: AND
87994: IFFALSE 88014
87996: GO 87998
87998: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
87999: LD_INT 1
88001: PPUSH
88002: LD_OWVAR 2
88006: PPUSH
88007: LD_INT 0
88009: PPUSH
88010: CALL_OW 324
88014: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
88015: LD_EXP 118
88019: PUSH
88020: LD_EXP 134
88024: AND
88025: IFFALSE 88108
88027: GO 88029
88029: DISABLE
88030: LD_INT 0
88032: PPUSH
88033: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
88034: LD_ADDR_VAR 0 2
88038: PUSH
88039: LD_INT 22
88041: PUSH
88042: LD_OWVAR 2
88046: PUSH
88047: EMPTY
88048: LIST
88049: LIST
88050: PUSH
88051: LD_INT 21
88053: PUSH
88054: LD_INT 3
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: PPUSH
88065: CALL_OW 69
88069: ST_TO_ADDR
// if not tmp then
88070: LD_VAR 0 2
88074: NOT
88075: IFFALSE 88079
// exit ;
88077: GO 88108
// for i in tmp do
88079: LD_ADDR_VAR 0 1
88083: PUSH
88084: LD_VAR 0 2
88088: PUSH
88089: FOR_IN
88090: IFFALSE 88106
// SetBLevel ( i , 10 ) ;
88092: LD_VAR 0 1
88096: PPUSH
88097: LD_INT 10
88099: PPUSH
88100: CALL_OW 241
88104: GO 88089
88106: POP
88107: POP
// end ;
88108: PPOPN 2
88110: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
88111: LD_EXP 118
88115: PUSH
88116: LD_EXP 135
88120: AND
88121: IFFALSE 88232
88123: GO 88125
88125: DISABLE
88126: LD_INT 0
88128: PPUSH
88129: PPUSH
88130: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
88131: LD_ADDR_VAR 0 3
88135: PUSH
88136: LD_INT 22
88138: PUSH
88139: LD_OWVAR 2
88143: PUSH
88144: EMPTY
88145: LIST
88146: LIST
88147: PUSH
88148: LD_INT 25
88150: PUSH
88151: LD_INT 1
88153: PUSH
88154: EMPTY
88155: LIST
88156: LIST
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PPUSH
88162: CALL_OW 69
88166: ST_TO_ADDR
// if not tmp then
88167: LD_VAR 0 3
88171: NOT
88172: IFFALSE 88176
// exit ;
88174: GO 88232
// un := tmp [ rand ( 1 , tmp ) ] ;
88176: LD_ADDR_VAR 0 2
88180: PUSH
88181: LD_VAR 0 3
88185: PUSH
88186: LD_INT 1
88188: PPUSH
88189: LD_VAR 0 3
88193: PPUSH
88194: CALL_OW 12
88198: ARRAY
88199: ST_TO_ADDR
// if Crawls ( un ) then
88200: LD_VAR 0 2
88204: PPUSH
88205: CALL_OW 318
88209: IFFALSE 88220
// ComWalk ( un ) ;
88211: LD_VAR 0 2
88215: PPUSH
88216: CALL_OW 138
// SetClass ( un , class_sniper ) ;
88220: LD_VAR 0 2
88224: PPUSH
88225: LD_INT 5
88227: PPUSH
88228: CALL_OW 336
// end ;
88232: PPOPN 3
88234: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
88235: LD_EXP 118
88239: PUSH
88240: LD_EXP 136
88244: AND
88245: PUSH
88246: LD_OWVAR 67
88250: PUSH
88251: LD_INT 3
88253: LESS
88254: AND
88255: IFFALSE 88274
88257: GO 88259
88259: DISABLE
// Difficulty := Difficulty + 1 ;
88260: LD_ADDR_OWVAR 67
88264: PUSH
88265: LD_OWVAR 67
88269: PUSH
88270: LD_INT 1
88272: PLUS
88273: ST_TO_ADDR
88274: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
88275: LD_EXP 118
88279: PUSH
88280: LD_EXP 137
88284: AND
88285: IFFALSE 88388
88287: GO 88289
88289: DISABLE
88290: LD_INT 0
88292: PPUSH
// begin for i := 1 to 5 do
88293: LD_ADDR_VAR 0 1
88297: PUSH
88298: DOUBLE
88299: LD_INT 1
88301: DEC
88302: ST_TO_ADDR
88303: LD_INT 5
88305: PUSH
88306: FOR_TO
88307: IFFALSE 88386
// begin uc_nation := nation_nature ;
88309: LD_ADDR_OWVAR 21
88313: PUSH
88314: LD_INT 0
88316: ST_TO_ADDR
// uc_side := 0 ;
88317: LD_ADDR_OWVAR 20
88321: PUSH
88322: LD_INT 0
88324: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88325: LD_ADDR_OWVAR 29
88329: PUSH
88330: LD_INT 12
88332: PUSH
88333: LD_INT 12
88335: PUSH
88336: EMPTY
88337: LIST
88338: LIST
88339: ST_TO_ADDR
// hc_agressivity := 20 ;
88340: LD_ADDR_OWVAR 35
88344: PUSH
88345: LD_INT 20
88347: ST_TO_ADDR
// hc_class := class_tiger ;
88348: LD_ADDR_OWVAR 28
88352: PUSH
88353: LD_INT 14
88355: ST_TO_ADDR
// hc_gallery :=  ;
88356: LD_ADDR_OWVAR 33
88360: PUSH
88361: LD_STRING 
88363: ST_TO_ADDR
// hc_name :=  ;
88364: LD_ADDR_OWVAR 26
88368: PUSH
88369: LD_STRING 
88371: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
88372: CALL_OW 44
88376: PPUSH
88377: LD_INT 0
88379: PPUSH
88380: CALL_OW 51
// end ;
88384: GO 88306
88386: POP
88387: POP
// end ;
88388: PPOPN 1
88390: END
// every 0 0$1 trigger StreamModeActive and sBomb do
88391: LD_EXP 118
88395: PUSH
88396: LD_EXP 138
88400: AND
88401: IFFALSE 88410
88403: GO 88405
88405: DISABLE
// StreamSibBomb ;
88406: CALL 88411 0 0
88410: END
// export function StreamSibBomb ; var i , x , y ; begin
88411: LD_INT 0
88413: PPUSH
88414: PPUSH
88415: PPUSH
88416: PPUSH
// result := false ;
88417: LD_ADDR_VAR 0 1
88421: PUSH
88422: LD_INT 0
88424: ST_TO_ADDR
// for i := 1 to 16 do
88425: LD_ADDR_VAR 0 2
88429: PUSH
88430: DOUBLE
88431: LD_INT 1
88433: DEC
88434: ST_TO_ADDR
88435: LD_INT 16
88437: PUSH
88438: FOR_TO
88439: IFFALSE 88638
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
88441: LD_ADDR_VAR 0 3
88445: PUSH
88446: LD_INT 10
88448: PUSH
88449: LD_INT 20
88451: PUSH
88452: LD_INT 30
88454: PUSH
88455: LD_INT 40
88457: PUSH
88458: LD_INT 50
88460: PUSH
88461: LD_INT 60
88463: PUSH
88464: LD_INT 70
88466: PUSH
88467: LD_INT 80
88469: PUSH
88470: LD_INT 90
88472: PUSH
88473: LD_INT 100
88475: PUSH
88476: LD_INT 110
88478: PUSH
88479: LD_INT 120
88481: PUSH
88482: LD_INT 130
88484: PUSH
88485: LD_INT 140
88487: PUSH
88488: LD_INT 150
88490: PUSH
88491: EMPTY
88492: LIST
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: PUSH
88508: LD_INT 1
88510: PPUSH
88511: LD_INT 15
88513: PPUSH
88514: CALL_OW 12
88518: ARRAY
88519: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
88520: LD_ADDR_VAR 0 4
88524: PUSH
88525: LD_INT 10
88527: PUSH
88528: LD_INT 20
88530: PUSH
88531: LD_INT 30
88533: PUSH
88534: LD_INT 40
88536: PUSH
88537: LD_INT 50
88539: PUSH
88540: LD_INT 60
88542: PUSH
88543: LD_INT 70
88545: PUSH
88546: LD_INT 80
88548: PUSH
88549: LD_INT 90
88551: PUSH
88552: LD_INT 100
88554: PUSH
88555: LD_INT 110
88557: PUSH
88558: LD_INT 120
88560: PUSH
88561: LD_INT 130
88563: PUSH
88564: LD_INT 140
88566: PUSH
88567: LD_INT 150
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 1
88589: PPUSH
88590: LD_INT 15
88592: PPUSH
88593: CALL_OW 12
88597: ARRAY
88598: ST_TO_ADDR
// if ValidHex ( x , y ) then
88599: LD_VAR 0 3
88603: PPUSH
88604: LD_VAR 0 4
88608: PPUSH
88609: CALL_OW 488
88613: IFFALSE 88636
// begin result := [ x , y ] ;
88615: LD_ADDR_VAR 0 1
88619: PUSH
88620: LD_VAR 0 3
88624: PUSH
88625: LD_VAR 0 4
88629: PUSH
88630: EMPTY
88631: LIST
88632: LIST
88633: ST_TO_ADDR
// break ;
88634: GO 88638
// end ; end ;
88636: GO 88438
88638: POP
88639: POP
// if result then
88640: LD_VAR 0 1
88644: IFFALSE 88704
// begin ToLua ( playSibBomb() ) ;
88646: LD_STRING playSibBomb()
88648: PPUSH
88649: CALL_OW 559
// wait ( 0 0$14 ) ;
88653: LD_INT 490
88655: PPUSH
88656: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
88660: LD_VAR 0 1
88664: PUSH
88665: LD_INT 1
88667: ARRAY
88668: PPUSH
88669: LD_VAR 0 1
88673: PUSH
88674: LD_INT 2
88676: ARRAY
88677: PPUSH
88678: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
88682: LD_VAR 0 1
88686: PUSH
88687: LD_INT 1
88689: ARRAY
88690: PPUSH
88691: LD_VAR 0 1
88695: PUSH
88696: LD_INT 2
88698: ARRAY
88699: PPUSH
88700: CALL_OW 429
// end ; end ;
88704: LD_VAR 0 1
88708: RET
// every 0 0$1 trigger StreamModeActive and sReset do
88709: LD_EXP 118
88713: PUSH
88714: LD_EXP 140
88718: AND
88719: IFFALSE 88731
88721: GO 88723
88723: DISABLE
// YouLost (  ) ;
88724: LD_STRING 
88726: PPUSH
88727: CALL_OW 104
88731: END
// every 0 0$1 trigger StreamModeActive and sFog do
88732: LD_EXP 118
88736: PUSH
88737: LD_EXP 139
88741: AND
88742: IFFALSE 88756
88744: GO 88746
88746: DISABLE
// FogOff ( your_side ) ;
88747: LD_OWVAR 2
88751: PPUSH
88752: CALL_OW 344
88756: END
// every 0 0$1 trigger StreamModeActive and sSun do
88757: LD_EXP 118
88761: PUSH
88762: LD_EXP 141
88766: AND
88767: IFFALSE 88795
88769: GO 88771
88771: DISABLE
// begin solar_recharge_percent := 0 ;
88772: LD_ADDR_OWVAR 79
88776: PUSH
88777: LD_INT 0
88779: ST_TO_ADDR
// wait ( 5 5$00 ) ;
88780: LD_INT 10500
88782: PPUSH
88783: CALL_OW 67
// solar_recharge_percent := 100 ;
88787: LD_ADDR_OWVAR 79
88791: PUSH
88792: LD_INT 100
88794: ST_TO_ADDR
// end ;
88795: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
88796: LD_EXP 118
88800: PUSH
88801: LD_EXP 142
88805: AND
88806: IFFALSE 89045
88808: GO 88810
88810: DISABLE
88811: LD_INT 0
88813: PPUSH
88814: PPUSH
88815: PPUSH
// begin tmp := [ ] ;
88816: LD_ADDR_VAR 0 3
88820: PUSH
88821: EMPTY
88822: ST_TO_ADDR
// for i := 1 to 6 do
88823: LD_ADDR_VAR 0 1
88827: PUSH
88828: DOUBLE
88829: LD_INT 1
88831: DEC
88832: ST_TO_ADDR
88833: LD_INT 6
88835: PUSH
88836: FOR_TO
88837: IFFALSE 88942
// begin uc_nation := nation_nature ;
88839: LD_ADDR_OWVAR 21
88843: PUSH
88844: LD_INT 0
88846: ST_TO_ADDR
// uc_side := 0 ;
88847: LD_ADDR_OWVAR 20
88851: PUSH
88852: LD_INT 0
88854: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88855: LD_ADDR_OWVAR 29
88859: PUSH
88860: LD_INT 12
88862: PUSH
88863: LD_INT 12
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: ST_TO_ADDR
// hc_agressivity := 20 ;
88870: LD_ADDR_OWVAR 35
88874: PUSH
88875: LD_INT 20
88877: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
88878: LD_ADDR_OWVAR 28
88882: PUSH
88883: LD_INT 17
88885: ST_TO_ADDR
// hc_gallery :=  ;
88886: LD_ADDR_OWVAR 33
88890: PUSH
88891: LD_STRING 
88893: ST_TO_ADDR
// hc_name :=  ;
88894: LD_ADDR_OWVAR 26
88898: PUSH
88899: LD_STRING 
88901: ST_TO_ADDR
// un := CreateHuman ;
88902: LD_ADDR_VAR 0 2
88906: PUSH
88907: CALL_OW 44
88911: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
88912: LD_VAR 0 2
88916: PPUSH
88917: LD_INT 1
88919: PPUSH
88920: CALL_OW 51
// tmp := tmp ^ un ;
88924: LD_ADDR_VAR 0 3
88928: PUSH
88929: LD_VAR 0 3
88933: PUSH
88934: LD_VAR 0 2
88938: ADD
88939: ST_TO_ADDR
// end ;
88940: GO 88836
88942: POP
88943: POP
// repeat wait ( 0 0$1 ) ;
88944: LD_INT 35
88946: PPUSH
88947: CALL_OW 67
// for un in tmp do
88951: LD_ADDR_VAR 0 2
88955: PUSH
88956: LD_VAR 0 3
88960: PUSH
88961: FOR_IN
88962: IFFALSE 89036
// begin if IsDead ( un ) then
88964: LD_VAR 0 2
88968: PPUSH
88969: CALL_OW 301
88973: IFFALSE 88993
// begin tmp := tmp diff un ;
88975: LD_ADDR_VAR 0 3
88979: PUSH
88980: LD_VAR 0 3
88984: PUSH
88985: LD_VAR 0 2
88989: DIFF
88990: ST_TO_ADDR
// continue ;
88991: GO 88961
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
88993: LD_VAR 0 2
88997: PPUSH
88998: LD_INT 3
89000: PUSH
89001: LD_INT 22
89003: PUSH
89004: LD_INT 0
89006: PUSH
89007: EMPTY
89008: LIST
89009: LIST
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PPUSH
89015: CALL_OW 69
89019: PPUSH
89020: LD_VAR 0 2
89024: PPUSH
89025: CALL_OW 74
89029: PPUSH
89030: CALL_OW 115
// end ;
89034: GO 88961
89036: POP
89037: POP
// until not tmp ;
89038: LD_VAR 0 3
89042: NOT
89043: IFFALSE 88944
// end ;
89045: PPOPN 3
89047: END
// every 0 0$1 trigger StreamModeActive and sTroll do
89048: LD_EXP 118
89052: PUSH
89053: LD_EXP 143
89057: AND
89058: IFFALSE 89112
89060: GO 89062
89062: DISABLE
// begin ToLua ( displayTroll(); ) ;
89063: LD_STRING displayTroll();
89065: PPUSH
89066: CALL_OW 559
// wait ( 3 3$00 ) ;
89070: LD_INT 6300
89072: PPUSH
89073: CALL_OW 67
// ToLua ( hideTroll(); ) ;
89077: LD_STRING hideTroll();
89079: PPUSH
89080: CALL_OW 559
// wait ( 1 1$00 ) ;
89084: LD_INT 2100
89086: PPUSH
89087: CALL_OW 67
// ToLua ( displayTroll(); ) ;
89091: LD_STRING displayTroll();
89093: PPUSH
89094: CALL_OW 559
// wait ( 1 1$00 ) ;
89098: LD_INT 2100
89100: PPUSH
89101: CALL_OW 67
// ToLua ( hideTroll(); ) ;
89105: LD_STRING hideTroll();
89107: PPUSH
89108: CALL_OW 559
// end ;
89112: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
89113: LD_EXP 118
89117: PUSH
89118: LD_EXP 144
89122: AND
89123: IFFALSE 89186
89125: GO 89127
89127: DISABLE
89128: LD_INT 0
89130: PPUSH
// begin p := 0 ;
89131: LD_ADDR_VAR 0 1
89135: PUSH
89136: LD_INT 0
89138: ST_TO_ADDR
// repeat game_speed := 1 ;
89139: LD_ADDR_OWVAR 65
89143: PUSH
89144: LD_INT 1
89146: ST_TO_ADDR
// wait ( 0 0$1 ) ;
89147: LD_INT 35
89149: PPUSH
89150: CALL_OW 67
// p := p + 1 ;
89154: LD_ADDR_VAR 0 1
89158: PUSH
89159: LD_VAR 0 1
89163: PUSH
89164: LD_INT 1
89166: PLUS
89167: ST_TO_ADDR
// until p >= 60 ;
89168: LD_VAR 0 1
89172: PUSH
89173: LD_INT 60
89175: GREATEREQUAL
89176: IFFALSE 89139
// game_speed := 4 ;
89178: LD_ADDR_OWVAR 65
89182: PUSH
89183: LD_INT 4
89185: ST_TO_ADDR
// end ;
89186: PPOPN 1
89188: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
89189: LD_EXP 118
89193: PUSH
89194: LD_EXP 145
89198: AND
89199: IFFALSE 89345
89201: GO 89203
89203: DISABLE
89204: LD_INT 0
89206: PPUSH
89207: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
89208: LD_ADDR_VAR 0 1
89212: PUSH
89213: LD_INT 22
89215: PUSH
89216: LD_OWVAR 2
89220: PUSH
89221: EMPTY
89222: LIST
89223: LIST
89224: PUSH
89225: LD_INT 2
89227: PUSH
89228: LD_INT 30
89230: PUSH
89231: LD_INT 0
89233: PUSH
89234: EMPTY
89235: LIST
89236: LIST
89237: PUSH
89238: LD_INT 30
89240: PUSH
89241: LD_INT 1
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: PUSH
89248: EMPTY
89249: LIST
89250: LIST
89251: LIST
89252: PUSH
89253: EMPTY
89254: LIST
89255: LIST
89256: PPUSH
89257: CALL_OW 69
89261: ST_TO_ADDR
// if not depot then
89262: LD_VAR 0 1
89266: NOT
89267: IFFALSE 89271
// exit ;
89269: GO 89345
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
89271: LD_ADDR_VAR 0 2
89275: PUSH
89276: LD_VAR 0 1
89280: PUSH
89281: LD_INT 1
89283: PPUSH
89284: LD_VAR 0 1
89288: PPUSH
89289: CALL_OW 12
89293: ARRAY
89294: PPUSH
89295: CALL_OW 274
89299: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
89300: LD_VAR 0 2
89304: PPUSH
89305: LD_INT 1
89307: PPUSH
89308: LD_INT 0
89310: PPUSH
89311: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
89315: LD_VAR 0 2
89319: PPUSH
89320: LD_INT 2
89322: PPUSH
89323: LD_INT 0
89325: PPUSH
89326: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
89330: LD_VAR 0 2
89334: PPUSH
89335: LD_INT 3
89337: PPUSH
89338: LD_INT 0
89340: PPUSH
89341: CALL_OW 277
// end ;
89345: PPOPN 2
89347: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
89348: LD_EXP 118
89352: PUSH
89353: LD_EXP 146
89357: AND
89358: IFFALSE 89455
89360: GO 89362
89362: DISABLE
89363: LD_INT 0
89365: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
89366: LD_ADDR_VAR 0 1
89370: PUSH
89371: LD_INT 22
89373: PUSH
89374: LD_OWVAR 2
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 21
89385: PUSH
89386: LD_INT 1
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: PUSH
89393: LD_INT 3
89395: PUSH
89396: LD_INT 23
89398: PUSH
89399: LD_INT 0
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: PUSH
89410: EMPTY
89411: LIST
89412: LIST
89413: LIST
89414: PPUSH
89415: CALL_OW 69
89419: ST_TO_ADDR
// if not tmp then
89420: LD_VAR 0 1
89424: NOT
89425: IFFALSE 89429
// exit ;
89427: GO 89455
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
89429: LD_VAR 0 1
89433: PUSH
89434: LD_INT 1
89436: PPUSH
89437: LD_VAR 0 1
89441: PPUSH
89442: CALL_OW 12
89446: ARRAY
89447: PPUSH
89448: LD_INT 200
89450: PPUSH
89451: CALL_OW 234
// end ;
89455: PPOPN 1
89457: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
89458: LD_EXP 118
89462: PUSH
89463: LD_EXP 147
89467: AND
89468: IFFALSE 89547
89470: GO 89472
89472: DISABLE
89473: LD_INT 0
89475: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
89476: LD_ADDR_VAR 0 1
89480: PUSH
89481: LD_INT 22
89483: PUSH
89484: LD_OWVAR 2
89488: PUSH
89489: EMPTY
89490: LIST
89491: LIST
89492: PUSH
89493: LD_INT 21
89495: PUSH
89496: LD_INT 2
89498: PUSH
89499: EMPTY
89500: LIST
89501: LIST
89502: PUSH
89503: EMPTY
89504: LIST
89505: LIST
89506: PPUSH
89507: CALL_OW 69
89511: ST_TO_ADDR
// if not tmp then
89512: LD_VAR 0 1
89516: NOT
89517: IFFALSE 89521
// exit ;
89519: GO 89547
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
89521: LD_VAR 0 1
89525: PUSH
89526: LD_INT 1
89528: PPUSH
89529: LD_VAR 0 1
89533: PPUSH
89534: CALL_OW 12
89538: ARRAY
89539: PPUSH
89540: LD_INT 60
89542: PPUSH
89543: CALL_OW 234
// end ;
89547: PPOPN 1
89549: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
89550: LD_EXP 118
89554: PUSH
89555: LD_EXP 148
89559: AND
89560: IFFALSE 89659
89562: GO 89564
89564: DISABLE
89565: LD_INT 0
89567: PPUSH
89568: PPUSH
// begin enable ;
89569: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
89570: LD_ADDR_VAR 0 1
89574: PUSH
89575: LD_INT 22
89577: PUSH
89578: LD_OWVAR 2
89582: PUSH
89583: EMPTY
89584: LIST
89585: LIST
89586: PUSH
89587: LD_INT 61
89589: PUSH
89590: EMPTY
89591: LIST
89592: PUSH
89593: LD_INT 33
89595: PUSH
89596: LD_INT 2
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: PUSH
89603: EMPTY
89604: LIST
89605: LIST
89606: LIST
89607: PPUSH
89608: CALL_OW 69
89612: ST_TO_ADDR
// if not tmp then
89613: LD_VAR 0 1
89617: NOT
89618: IFFALSE 89622
// exit ;
89620: GO 89659
// for i in tmp do
89622: LD_ADDR_VAR 0 2
89626: PUSH
89627: LD_VAR 0 1
89631: PUSH
89632: FOR_IN
89633: IFFALSE 89657
// if IsControledBy ( i ) then
89635: LD_VAR 0 2
89639: PPUSH
89640: CALL_OW 312
89644: IFFALSE 89655
// ComUnlink ( i ) ;
89646: LD_VAR 0 2
89650: PPUSH
89651: CALL_OW 136
89655: GO 89632
89657: POP
89658: POP
// end ;
89659: PPOPN 2
89661: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
89662: LD_EXP 118
89666: PUSH
89667: LD_EXP 149
89671: AND
89672: IFFALSE 89812
89674: GO 89676
89676: DISABLE
89677: LD_INT 0
89679: PPUSH
89680: PPUSH
// begin ToLua ( displayPowell(); ) ;
89681: LD_STRING displayPowell();
89683: PPUSH
89684: CALL_OW 559
// uc_side := 0 ;
89688: LD_ADDR_OWVAR 20
89692: PUSH
89693: LD_INT 0
89695: ST_TO_ADDR
// uc_nation := 2 ;
89696: LD_ADDR_OWVAR 21
89700: PUSH
89701: LD_INT 2
89703: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
89704: LD_ADDR_OWVAR 37
89708: PUSH
89709: LD_INT 14
89711: ST_TO_ADDR
// vc_engine := engine_siberite ;
89712: LD_ADDR_OWVAR 39
89716: PUSH
89717: LD_INT 3
89719: ST_TO_ADDR
// vc_control := control_apeman ;
89720: LD_ADDR_OWVAR 38
89724: PUSH
89725: LD_INT 5
89727: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
89728: LD_ADDR_OWVAR 40
89732: PUSH
89733: LD_INT 29
89735: ST_TO_ADDR
// un := CreateVehicle ;
89736: LD_ADDR_VAR 0 2
89740: PUSH
89741: CALL_OW 45
89745: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89746: LD_VAR 0 2
89750: PPUSH
89751: LD_INT 1
89753: PPUSH
89754: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89758: LD_INT 35
89760: PPUSH
89761: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89765: LD_VAR 0 2
89769: PPUSH
89770: LD_INT 22
89772: PUSH
89773: LD_OWVAR 2
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PPUSH
89782: CALL_OW 69
89786: PPUSH
89787: LD_VAR 0 2
89791: PPUSH
89792: CALL_OW 74
89796: PPUSH
89797: CALL_OW 115
// until IsDead ( un ) ;
89801: LD_VAR 0 2
89805: PPUSH
89806: CALL_OW 301
89810: IFFALSE 89758
// end ;
89812: PPOPN 2
89814: END
// every 0 0$1 trigger StreamModeActive and sStu do
89815: LD_EXP 118
89819: PUSH
89820: LD_EXP 157
89824: AND
89825: IFFALSE 89841
89827: GO 89829
89829: DISABLE
// begin ToLua ( displayStucuk(); ) ;
89830: LD_STRING displayStucuk();
89832: PPUSH
89833: CALL_OW 559
// ResetFog ;
89837: CALL_OW 335
// end ;
89841: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
89842: LD_EXP 118
89846: PUSH
89847: LD_EXP 150
89851: AND
89852: IFFALSE 89993
89854: GO 89856
89856: DISABLE
89857: LD_INT 0
89859: PPUSH
89860: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89861: LD_ADDR_VAR 0 2
89865: PUSH
89866: LD_INT 22
89868: PUSH
89869: LD_OWVAR 2
89873: PUSH
89874: EMPTY
89875: LIST
89876: LIST
89877: PUSH
89878: LD_INT 21
89880: PUSH
89881: LD_INT 1
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: PPUSH
89892: CALL_OW 69
89896: ST_TO_ADDR
// if not tmp then
89897: LD_VAR 0 2
89901: NOT
89902: IFFALSE 89906
// exit ;
89904: GO 89993
// un := tmp [ rand ( 1 , tmp ) ] ;
89906: LD_ADDR_VAR 0 1
89910: PUSH
89911: LD_VAR 0 2
89915: PUSH
89916: LD_INT 1
89918: PPUSH
89919: LD_VAR 0 2
89923: PPUSH
89924: CALL_OW 12
89928: ARRAY
89929: ST_TO_ADDR
// SetSide ( un , 0 ) ;
89930: LD_VAR 0 1
89934: PPUSH
89935: LD_INT 0
89937: PPUSH
89938: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
89942: LD_VAR 0 1
89946: PPUSH
89947: LD_OWVAR 3
89951: PUSH
89952: LD_VAR 0 1
89956: DIFF
89957: PPUSH
89958: LD_VAR 0 1
89962: PPUSH
89963: CALL_OW 74
89967: PPUSH
89968: CALL_OW 115
// wait ( 0 0$20 ) ;
89972: LD_INT 700
89974: PPUSH
89975: CALL_OW 67
// SetSide ( un , your_side ) ;
89979: LD_VAR 0 1
89983: PPUSH
89984: LD_OWVAR 2
89988: PPUSH
89989: CALL_OW 235
// end ;
89993: PPOPN 2
89995: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
89996: LD_EXP 118
90000: PUSH
90001: LD_EXP 151
90005: AND
90006: IFFALSE 90112
90008: GO 90010
90010: DISABLE
90011: LD_INT 0
90013: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
90014: LD_ADDR_VAR 0 1
90018: PUSH
90019: LD_INT 22
90021: PUSH
90022: LD_OWVAR 2
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: LD_INT 2
90033: PUSH
90034: LD_INT 30
90036: PUSH
90037: LD_INT 0
90039: PUSH
90040: EMPTY
90041: LIST
90042: LIST
90043: PUSH
90044: LD_INT 30
90046: PUSH
90047: LD_INT 1
90049: PUSH
90050: EMPTY
90051: LIST
90052: LIST
90053: PUSH
90054: EMPTY
90055: LIST
90056: LIST
90057: LIST
90058: PUSH
90059: EMPTY
90060: LIST
90061: LIST
90062: PPUSH
90063: CALL_OW 69
90067: ST_TO_ADDR
// if not depot then
90068: LD_VAR 0 1
90072: NOT
90073: IFFALSE 90077
// exit ;
90075: GO 90112
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
90077: LD_VAR 0 1
90081: PUSH
90082: LD_INT 1
90084: ARRAY
90085: PPUSH
90086: CALL_OW 250
90090: PPUSH
90091: LD_VAR 0 1
90095: PUSH
90096: LD_INT 1
90098: ARRAY
90099: PPUSH
90100: CALL_OW 251
90104: PPUSH
90105: LD_INT 70
90107: PPUSH
90108: CALL_OW 495
// end ;
90112: PPOPN 1
90114: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
90115: LD_EXP 118
90119: PUSH
90120: LD_EXP 152
90124: AND
90125: IFFALSE 90336
90127: GO 90129
90129: DISABLE
90130: LD_INT 0
90132: PPUSH
90133: PPUSH
90134: PPUSH
90135: PPUSH
90136: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90137: LD_ADDR_VAR 0 5
90141: PUSH
90142: LD_INT 22
90144: PUSH
90145: LD_OWVAR 2
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PUSH
90154: LD_INT 21
90156: PUSH
90157: LD_INT 1
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: PPUSH
90168: CALL_OW 69
90172: ST_TO_ADDR
// if not tmp then
90173: LD_VAR 0 5
90177: NOT
90178: IFFALSE 90182
// exit ;
90180: GO 90336
// for i in tmp do
90182: LD_ADDR_VAR 0 1
90186: PUSH
90187: LD_VAR 0 5
90191: PUSH
90192: FOR_IN
90193: IFFALSE 90334
// begin d := rand ( 0 , 5 ) ;
90195: LD_ADDR_VAR 0 4
90199: PUSH
90200: LD_INT 0
90202: PPUSH
90203: LD_INT 5
90205: PPUSH
90206: CALL_OW 12
90210: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
90211: LD_ADDR_VAR 0 2
90215: PUSH
90216: LD_VAR 0 1
90220: PPUSH
90221: CALL_OW 250
90225: PPUSH
90226: LD_VAR 0 4
90230: PPUSH
90231: LD_INT 3
90233: PPUSH
90234: LD_INT 12
90236: PPUSH
90237: CALL_OW 12
90241: PPUSH
90242: CALL_OW 272
90246: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
90247: LD_ADDR_VAR 0 3
90251: PUSH
90252: LD_VAR 0 1
90256: PPUSH
90257: CALL_OW 251
90261: PPUSH
90262: LD_VAR 0 4
90266: PPUSH
90267: LD_INT 3
90269: PPUSH
90270: LD_INT 12
90272: PPUSH
90273: CALL_OW 12
90277: PPUSH
90278: CALL_OW 273
90282: ST_TO_ADDR
// if ValidHex ( x , y ) then
90283: LD_VAR 0 2
90287: PPUSH
90288: LD_VAR 0 3
90292: PPUSH
90293: CALL_OW 488
90297: IFFALSE 90332
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
90299: LD_VAR 0 1
90303: PPUSH
90304: LD_VAR 0 2
90308: PPUSH
90309: LD_VAR 0 3
90313: PPUSH
90314: LD_INT 3
90316: PPUSH
90317: LD_INT 6
90319: PPUSH
90320: CALL_OW 12
90324: PPUSH
90325: LD_INT 1
90327: PPUSH
90328: CALL_OW 483
// end ;
90332: GO 90192
90334: POP
90335: POP
// end ;
90336: PPOPN 5
90338: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
90339: LD_EXP 118
90343: PUSH
90344: LD_EXP 153
90348: AND
90349: IFFALSE 90443
90351: GO 90353
90353: DISABLE
90354: LD_INT 0
90356: PPUSH
90357: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
90358: LD_ADDR_VAR 0 2
90362: PUSH
90363: LD_INT 22
90365: PUSH
90366: LD_OWVAR 2
90370: PUSH
90371: EMPTY
90372: LIST
90373: LIST
90374: PUSH
90375: LD_INT 32
90377: PUSH
90378: LD_INT 1
90380: PUSH
90381: EMPTY
90382: LIST
90383: LIST
90384: PUSH
90385: LD_INT 21
90387: PUSH
90388: LD_INT 2
90390: PUSH
90391: EMPTY
90392: LIST
90393: LIST
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: LIST
90399: PPUSH
90400: CALL_OW 69
90404: ST_TO_ADDR
// if not tmp then
90405: LD_VAR 0 2
90409: NOT
90410: IFFALSE 90414
// exit ;
90412: GO 90443
// for i in tmp do
90414: LD_ADDR_VAR 0 1
90418: PUSH
90419: LD_VAR 0 2
90423: PUSH
90424: FOR_IN
90425: IFFALSE 90441
// SetFuel ( i , 0 ) ;
90427: LD_VAR 0 1
90431: PPUSH
90432: LD_INT 0
90434: PPUSH
90435: CALL_OW 240
90439: GO 90424
90441: POP
90442: POP
// end ;
90443: PPOPN 2
90445: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
90446: LD_EXP 118
90450: PUSH
90451: LD_EXP 154
90455: AND
90456: IFFALSE 90522
90458: GO 90460
90460: DISABLE
90461: LD_INT 0
90463: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
90464: LD_ADDR_VAR 0 1
90468: PUSH
90469: LD_INT 22
90471: PUSH
90472: LD_OWVAR 2
90476: PUSH
90477: EMPTY
90478: LIST
90479: LIST
90480: PUSH
90481: LD_INT 30
90483: PUSH
90484: LD_INT 29
90486: PUSH
90487: EMPTY
90488: LIST
90489: LIST
90490: PUSH
90491: EMPTY
90492: LIST
90493: LIST
90494: PPUSH
90495: CALL_OW 69
90499: ST_TO_ADDR
// if not tmp then
90500: LD_VAR 0 1
90504: NOT
90505: IFFALSE 90509
// exit ;
90507: GO 90522
// DestroyUnit ( tmp [ 1 ] ) ;
90509: LD_VAR 0 1
90513: PUSH
90514: LD_INT 1
90516: ARRAY
90517: PPUSH
90518: CALL_OW 65
// end ;
90522: PPOPN 1
90524: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
90525: LD_EXP 118
90529: PUSH
90530: LD_EXP 156
90534: AND
90535: IFFALSE 90664
90537: GO 90539
90539: DISABLE
90540: LD_INT 0
90542: PPUSH
// begin uc_side := 0 ;
90543: LD_ADDR_OWVAR 20
90547: PUSH
90548: LD_INT 0
90550: ST_TO_ADDR
// uc_nation := nation_arabian ;
90551: LD_ADDR_OWVAR 21
90555: PUSH
90556: LD_INT 2
90558: ST_TO_ADDR
// hc_gallery :=  ;
90559: LD_ADDR_OWVAR 33
90563: PUSH
90564: LD_STRING 
90566: ST_TO_ADDR
// hc_name :=  ;
90567: LD_ADDR_OWVAR 26
90571: PUSH
90572: LD_STRING 
90574: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
90575: LD_INT 1
90577: PPUSH
90578: LD_INT 11
90580: PPUSH
90581: LD_INT 10
90583: PPUSH
90584: CALL_OW 380
// un := CreateHuman ;
90588: LD_ADDR_VAR 0 1
90592: PUSH
90593: CALL_OW 44
90597: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
90598: LD_VAR 0 1
90602: PPUSH
90603: LD_INT 1
90605: PPUSH
90606: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
90610: LD_INT 35
90612: PPUSH
90613: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
90617: LD_VAR 0 1
90621: PPUSH
90622: LD_INT 22
90624: PUSH
90625: LD_OWVAR 2
90629: PUSH
90630: EMPTY
90631: LIST
90632: LIST
90633: PPUSH
90634: CALL_OW 69
90638: PPUSH
90639: LD_VAR 0 1
90643: PPUSH
90644: CALL_OW 74
90648: PPUSH
90649: CALL_OW 115
// until IsDead ( un ) ;
90653: LD_VAR 0 1
90657: PPUSH
90658: CALL_OW 301
90662: IFFALSE 90610
// end ;
90664: PPOPN 1
90666: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
90667: LD_EXP 118
90671: PUSH
90672: LD_EXP 158
90676: AND
90677: IFFALSE 90689
90679: GO 90681
90681: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
90682: LD_STRING earthquake(getX(game), 0, 32)
90684: PPUSH
90685: CALL_OW 559
90689: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
90690: LD_EXP 118
90694: PUSH
90695: LD_EXP 159
90699: AND
90700: IFFALSE 90791
90702: GO 90704
90704: DISABLE
90705: LD_INT 0
90707: PPUSH
// begin enable ;
90708: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
90709: LD_ADDR_VAR 0 1
90713: PUSH
90714: LD_INT 22
90716: PUSH
90717: LD_OWVAR 2
90721: PUSH
90722: EMPTY
90723: LIST
90724: LIST
90725: PUSH
90726: LD_INT 21
90728: PUSH
90729: LD_INT 2
90731: PUSH
90732: EMPTY
90733: LIST
90734: LIST
90735: PUSH
90736: LD_INT 33
90738: PUSH
90739: LD_INT 3
90741: PUSH
90742: EMPTY
90743: LIST
90744: LIST
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: LIST
90750: PPUSH
90751: CALL_OW 69
90755: ST_TO_ADDR
// if not tmp then
90756: LD_VAR 0 1
90760: NOT
90761: IFFALSE 90765
// exit ;
90763: GO 90791
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90765: LD_VAR 0 1
90769: PUSH
90770: LD_INT 1
90772: PPUSH
90773: LD_VAR 0 1
90777: PPUSH
90778: CALL_OW 12
90782: ARRAY
90783: PPUSH
90784: LD_INT 1
90786: PPUSH
90787: CALL_OW 234
// end ;
90791: PPOPN 1
90793: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
90794: LD_EXP 118
90798: PUSH
90799: LD_EXP 160
90803: AND
90804: IFFALSE 90945
90806: GO 90808
90808: DISABLE
90809: LD_INT 0
90811: PPUSH
90812: PPUSH
90813: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90814: LD_ADDR_VAR 0 3
90818: PUSH
90819: LD_INT 22
90821: PUSH
90822: LD_OWVAR 2
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: PUSH
90831: LD_INT 25
90833: PUSH
90834: LD_INT 1
90836: PUSH
90837: EMPTY
90838: LIST
90839: LIST
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PPUSH
90845: CALL_OW 69
90849: ST_TO_ADDR
// if not tmp then
90850: LD_VAR 0 3
90854: NOT
90855: IFFALSE 90859
// exit ;
90857: GO 90945
// un := tmp [ rand ( 1 , tmp ) ] ;
90859: LD_ADDR_VAR 0 2
90863: PUSH
90864: LD_VAR 0 3
90868: PUSH
90869: LD_INT 1
90871: PPUSH
90872: LD_VAR 0 3
90876: PPUSH
90877: CALL_OW 12
90881: ARRAY
90882: ST_TO_ADDR
// if Crawls ( un ) then
90883: LD_VAR 0 2
90887: PPUSH
90888: CALL_OW 318
90892: IFFALSE 90903
// ComWalk ( un ) ;
90894: LD_VAR 0 2
90898: PPUSH
90899: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
90903: LD_VAR 0 2
90907: PPUSH
90908: LD_INT 9
90910: PPUSH
90911: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
90915: LD_INT 28
90917: PPUSH
90918: LD_OWVAR 2
90922: PPUSH
90923: LD_INT 2
90925: PPUSH
90926: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
90930: LD_INT 29
90932: PPUSH
90933: LD_OWVAR 2
90937: PPUSH
90938: LD_INT 2
90940: PPUSH
90941: CALL_OW 322
// end ;
90945: PPOPN 3
90947: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
90948: LD_EXP 118
90952: PUSH
90953: LD_EXP 161
90957: AND
90958: IFFALSE 91069
90960: GO 90962
90962: DISABLE
90963: LD_INT 0
90965: PPUSH
90966: PPUSH
90967: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90968: LD_ADDR_VAR 0 3
90972: PUSH
90973: LD_INT 22
90975: PUSH
90976: LD_OWVAR 2
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PUSH
90985: LD_INT 25
90987: PUSH
90988: LD_INT 1
90990: PUSH
90991: EMPTY
90992: LIST
90993: LIST
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PPUSH
90999: CALL_OW 69
91003: ST_TO_ADDR
// if not tmp then
91004: LD_VAR 0 3
91008: NOT
91009: IFFALSE 91013
// exit ;
91011: GO 91069
// un := tmp [ rand ( 1 , tmp ) ] ;
91013: LD_ADDR_VAR 0 2
91017: PUSH
91018: LD_VAR 0 3
91022: PUSH
91023: LD_INT 1
91025: PPUSH
91026: LD_VAR 0 3
91030: PPUSH
91031: CALL_OW 12
91035: ARRAY
91036: ST_TO_ADDR
// if Crawls ( un ) then
91037: LD_VAR 0 2
91041: PPUSH
91042: CALL_OW 318
91046: IFFALSE 91057
// ComWalk ( un ) ;
91048: LD_VAR 0 2
91052: PPUSH
91053: CALL_OW 138
// SetClass ( un , class_mortar ) ;
91057: LD_VAR 0 2
91061: PPUSH
91062: LD_INT 8
91064: PPUSH
91065: CALL_OW 336
// end ;
91069: PPOPN 3
91071: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
91072: LD_EXP 118
91076: PUSH
91077: LD_EXP 162
91081: AND
91082: IFFALSE 91226
91084: GO 91086
91086: DISABLE
91087: LD_INT 0
91089: PPUSH
91090: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
91091: LD_ADDR_VAR 0 2
91095: PUSH
91096: LD_INT 22
91098: PUSH
91099: LD_OWVAR 2
91103: PUSH
91104: EMPTY
91105: LIST
91106: LIST
91107: PUSH
91108: LD_INT 21
91110: PUSH
91111: LD_INT 2
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: PUSH
91118: LD_INT 2
91120: PUSH
91121: LD_INT 34
91123: PUSH
91124: LD_INT 12
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: PUSH
91131: LD_INT 34
91133: PUSH
91134: LD_INT 51
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: PUSH
91141: LD_INT 34
91143: PUSH
91144: LD_INT 32
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: PUSH
91151: EMPTY
91152: LIST
91153: LIST
91154: LIST
91155: LIST
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: LIST
91161: PPUSH
91162: CALL_OW 69
91166: ST_TO_ADDR
// if not tmp then
91167: LD_VAR 0 2
91171: NOT
91172: IFFALSE 91176
// exit ;
91174: GO 91226
// for i in tmp do
91176: LD_ADDR_VAR 0 1
91180: PUSH
91181: LD_VAR 0 2
91185: PUSH
91186: FOR_IN
91187: IFFALSE 91224
// if GetCargo ( i , mat_artifact ) = 0 then
91189: LD_VAR 0 1
91193: PPUSH
91194: LD_INT 4
91196: PPUSH
91197: CALL_OW 289
91201: PUSH
91202: LD_INT 0
91204: EQUAL
91205: IFFALSE 91222
// SetCargo ( i , mat_siberit , 100 ) ;
91207: LD_VAR 0 1
91211: PPUSH
91212: LD_INT 3
91214: PPUSH
91215: LD_INT 100
91217: PPUSH
91218: CALL_OW 290
91222: GO 91186
91224: POP
91225: POP
// end ;
91226: PPOPN 2
91228: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
91229: LD_EXP 118
91233: PUSH
91234: LD_EXP 163
91238: AND
91239: IFFALSE 91422
91241: GO 91243
91243: DISABLE
91244: LD_INT 0
91246: PPUSH
91247: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
91248: LD_ADDR_VAR 0 2
91252: PUSH
91253: LD_INT 22
91255: PUSH
91256: LD_OWVAR 2
91260: PUSH
91261: EMPTY
91262: LIST
91263: LIST
91264: PPUSH
91265: CALL_OW 69
91269: ST_TO_ADDR
// if not tmp then
91270: LD_VAR 0 2
91274: NOT
91275: IFFALSE 91279
// exit ;
91277: GO 91422
// for i := 1 to 2 do
91279: LD_ADDR_VAR 0 1
91283: PUSH
91284: DOUBLE
91285: LD_INT 1
91287: DEC
91288: ST_TO_ADDR
91289: LD_INT 2
91291: PUSH
91292: FOR_TO
91293: IFFALSE 91420
// begin uc_side := your_side ;
91295: LD_ADDR_OWVAR 20
91299: PUSH
91300: LD_OWVAR 2
91304: ST_TO_ADDR
// uc_nation := nation_american ;
91305: LD_ADDR_OWVAR 21
91309: PUSH
91310: LD_INT 1
91312: ST_TO_ADDR
// vc_chassis := us_morphling ;
91313: LD_ADDR_OWVAR 37
91317: PUSH
91318: LD_INT 5
91320: ST_TO_ADDR
// vc_engine := engine_siberite ;
91321: LD_ADDR_OWVAR 39
91325: PUSH
91326: LD_INT 3
91328: ST_TO_ADDR
// vc_control := control_computer ;
91329: LD_ADDR_OWVAR 38
91333: PUSH
91334: LD_INT 3
91336: ST_TO_ADDR
// vc_weapon := us_double_laser ;
91337: LD_ADDR_OWVAR 40
91341: PUSH
91342: LD_INT 10
91344: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
91345: LD_VAR 0 2
91349: PUSH
91350: LD_INT 1
91352: ARRAY
91353: PPUSH
91354: CALL_OW 310
91358: NOT
91359: IFFALSE 91406
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
91361: CALL_OW 45
91365: PPUSH
91366: LD_VAR 0 2
91370: PUSH
91371: LD_INT 1
91373: ARRAY
91374: PPUSH
91375: CALL_OW 250
91379: PPUSH
91380: LD_VAR 0 2
91384: PUSH
91385: LD_INT 1
91387: ARRAY
91388: PPUSH
91389: CALL_OW 251
91393: PPUSH
91394: LD_INT 12
91396: PPUSH
91397: LD_INT 1
91399: PPUSH
91400: CALL_OW 50
91404: GO 91418
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
91406: CALL_OW 45
91410: PPUSH
91411: LD_INT 1
91413: PPUSH
91414: CALL_OW 51
// end ;
91418: GO 91292
91420: POP
91421: POP
// end ;
91422: PPOPN 2
91424: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
91425: LD_EXP 118
91429: PUSH
91430: LD_EXP 164
91434: AND
91435: IFFALSE 91657
91437: GO 91439
91439: DISABLE
91440: LD_INT 0
91442: PPUSH
91443: PPUSH
91444: PPUSH
91445: PPUSH
91446: PPUSH
91447: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91448: LD_ADDR_VAR 0 6
91452: PUSH
91453: LD_INT 22
91455: PUSH
91456: LD_OWVAR 2
91460: PUSH
91461: EMPTY
91462: LIST
91463: LIST
91464: PUSH
91465: LD_INT 21
91467: PUSH
91468: LD_INT 1
91470: PUSH
91471: EMPTY
91472: LIST
91473: LIST
91474: PUSH
91475: LD_INT 3
91477: PUSH
91478: LD_INT 23
91480: PUSH
91481: LD_INT 0
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: PUSH
91488: EMPTY
91489: LIST
91490: LIST
91491: PUSH
91492: EMPTY
91493: LIST
91494: LIST
91495: LIST
91496: PPUSH
91497: CALL_OW 69
91501: ST_TO_ADDR
// if not tmp then
91502: LD_VAR 0 6
91506: NOT
91507: IFFALSE 91511
// exit ;
91509: GO 91657
// s1 := rand ( 1 , 4 ) ;
91511: LD_ADDR_VAR 0 2
91515: PUSH
91516: LD_INT 1
91518: PPUSH
91519: LD_INT 4
91521: PPUSH
91522: CALL_OW 12
91526: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
91527: LD_ADDR_VAR 0 4
91531: PUSH
91532: LD_VAR 0 6
91536: PUSH
91537: LD_INT 1
91539: ARRAY
91540: PPUSH
91541: LD_VAR 0 2
91545: PPUSH
91546: CALL_OW 259
91550: ST_TO_ADDR
// if s1 = 1 then
91551: LD_VAR 0 2
91555: PUSH
91556: LD_INT 1
91558: EQUAL
91559: IFFALSE 91579
// s2 := rand ( 2 , 4 ) else
91561: LD_ADDR_VAR 0 3
91565: PUSH
91566: LD_INT 2
91568: PPUSH
91569: LD_INT 4
91571: PPUSH
91572: CALL_OW 12
91576: ST_TO_ADDR
91577: GO 91587
// s2 := 1 ;
91579: LD_ADDR_VAR 0 3
91583: PUSH
91584: LD_INT 1
91586: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
91587: LD_ADDR_VAR 0 5
91591: PUSH
91592: LD_VAR 0 6
91596: PUSH
91597: LD_INT 1
91599: ARRAY
91600: PPUSH
91601: LD_VAR 0 3
91605: PPUSH
91606: CALL_OW 259
91610: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
91611: LD_VAR 0 6
91615: PUSH
91616: LD_INT 1
91618: ARRAY
91619: PPUSH
91620: LD_VAR 0 2
91624: PPUSH
91625: LD_VAR 0 5
91629: PPUSH
91630: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
91634: LD_VAR 0 6
91638: PUSH
91639: LD_INT 1
91641: ARRAY
91642: PPUSH
91643: LD_VAR 0 3
91647: PPUSH
91648: LD_VAR 0 4
91652: PPUSH
91653: CALL_OW 237
// end ;
91657: PPOPN 6
91659: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
91660: LD_EXP 118
91664: PUSH
91665: LD_EXP 165
91669: AND
91670: IFFALSE 91749
91672: GO 91674
91674: DISABLE
91675: LD_INT 0
91677: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
91678: LD_ADDR_VAR 0 1
91682: PUSH
91683: LD_INT 22
91685: PUSH
91686: LD_OWVAR 2
91690: PUSH
91691: EMPTY
91692: LIST
91693: LIST
91694: PUSH
91695: LD_INT 30
91697: PUSH
91698: LD_INT 3
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: PPUSH
91709: CALL_OW 69
91713: ST_TO_ADDR
// if not tmp then
91714: LD_VAR 0 1
91718: NOT
91719: IFFALSE 91723
// exit ;
91721: GO 91749
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
91723: LD_VAR 0 1
91727: PUSH
91728: LD_INT 1
91730: PPUSH
91731: LD_VAR 0 1
91735: PPUSH
91736: CALL_OW 12
91740: ARRAY
91741: PPUSH
91742: LD_INT 1
91744: PPUSH
91745: CALL_OW 234
// end ;
91749: PPOPN 1
91751: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
91752: LD_EXP 118
91756: PUSH
91757: LD_EXP 166
91761: AND
91762: IFFALSE 91874
91764: GO 91766
91766: DISABLE
91767: LD_INT 0
91769: PPUSH
91770: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
91771: LD_ADDR_VAR 0 2
91775: PUSH
91776: LD_INT 22
91778: PUSH
91779: LD_OWVAR 2
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 2
91790: PUSH
91791: LD_INT 30
91793: PUSH
91794: LD_INT 27
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PUSH
91801: LD_INT 30
91803: PUSH
91804: LD_INT 26
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: PUSH
91811: LD_INT 30
91813: PUSH
91814: LD_INT 28
91816: PUSH
91817: EMPTY
91818: LIST
91819: LIST
91820: PUSH
91821: EMPTY
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: PUSH
91827: EMPTY
91828: LIST
91829: LIST
91830: PPUSH
91831: CALL_OW 69
91835: ST_TO_ADDR
// if not tmp then
91836: LD_VAR 0 2
91840: NOT
91841: IFFALSE 91845
// exit ;
91843: GO 91874
// for i in tmp do
91845: LD_ADDR_VAR 0 1
91849: PUSH
91850: LD_VAR 0 2
91854: PUSH
91855: FOR_IN
91856: IFFALSE 91872
// SetLives ( i , 1 ) ;
91858: LD_VAR 0 1
91862: PPUSH
91863: LD_INT 1
91865: PPUSH
91866: CALL_OW 234
91870: GO 91855
91872: POP
91873: POP
// end ;
91874: PPOPN 2
91876: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
91877: LD_EXP 118
91881: PUSH
91882: LD_EXP 167
91886: AND
91887: IFFALSE 92161
91889: GO 91891
91891: DISABLE
91892: LD_INT 0
91894: PPUSH
91895: PPUSH
91896: PPUSH
// begin i := rand ( 1 , 7 ) ;
91897: LD_ADDR_VAR 0 1
91901: PUSH
91902: LD_INT 1
91904: PPUSH
91905: LD_INT 7
91907: PPUSH
91908: CALL_OW 12
91912: ST_TO_ADDR
// case i of 1 :
91913: LD_VAR 0 1
91917: PUSH
91918: LD_INT 1
91920: DOUBLE
91921: EQUAL
91922: IFTRUE 91926
91924: GO 91936
91926: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
91927: LD_STRING earthquake(getX(game), 0, 32)
91929: PPUSH
91930: CALL_OW 559
91934: GO 92161
91936: LD_INT 2
91938: DOUBLE
91939: EQUAL
91940: IFTRUE 91944
91942: GO 91958
91944: POP
// begin ToLua ( displayStucuk(); ) ;
91945: LD_STRING displayStucuk();
91947: PPUSH
91948: CALL_OW 559
// ResetFog ;
91952: CALL_OW 335
// end ; 3 :
91956: GO 92161
91958: LD_INT 3
91960: DOUBLE
91961: EQUAL
91962: IFTRUE 91966
91964: GO 92070
91966: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91967: LD_ADDR_VAR 0 2
91971: PUSH
91972: LD_INT 22
91974: PUSH
91975: LD_OWVAR 2
91979: PUSH
91980: EMPTY
91981: LIST
91982: LIST
91983: PUSH
91984: LD_INT 25
91986: PUSH
91987: LD_INT 1
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: PUSH
91994: EMPTY
91995: LIST
91996: LIST
91997: PPUSH
91998: CALL_OW 69
92002: ST_TO_ADDR
// if not tmp then
92003: LD_VAR 0 2
92007: NOT
92008: IFFALSE 92012
// exit ;
92010: GO 92161
// un := tmp [ rand ( 1 , tmp ) ] ;
92012: LD_ADDR_VAR 0 3
92016: PUSH
92017: LD_VAR 0 2
92021: PUSH
92022: LD_INT 1
92024: PPUSH
92025: LD_VAR 0 2
92029: PPUSH
92030: CALL_OW 12
92034: ARRAY
92035: ST_TO_ADDR
// if Crawls ( un ) then
92036: LD_VAR 0 3
92040: PPUSH
92041: CALL_OW 318
92045: IFFALSE 92056
// ComWalk ( un ) ;
92047: LD_VAR 0 3
92051: PPUSH
92052: CALL_OW 138
// SetClass ( un , class_mortar ) ;
92056: LD_VAR 0 3
92060: PPUSH
92061: LD_INT 8
92063: PPUSH
92064: CALL_OW 336
// end ; 4 :
92068: GO 92161
92070: LD_INT 4
92072: DOUBLE
92073: EQUAL
92074: IFTRUE 92078
92076: GO 92139
92078: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
92079: LD_ADDR_VAR 0 2
92083: PUSH
92084: LD_INT 22
92086: PUSH
92087: LD_OWVAR 2
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 30
92098: PUSH
92099: LD_INT 29
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: PUSH
92106: EMPTY
92107: LIST
92108: LIST
92109: PPUSH
92110: CALL_OW 69
92114: ST_TO_ADDR
// if not tmp then
92115: LD_VAR 0 2
92119: NOT
92120: IFFALSE 92124
// exit ;
92122: GO 92161
// DestroyUnit ( tmp [ 1 ] ) ;
92124: LD_VAR 0 2
92128: PUSH
92129: LD_INT 1
92131: ARRAY
92132: PPUSH
92133: CALL_OW 65
// end ; 5 .. 7 :
92137: GO 92161
92139: LD_INT 5
92141: DOUBLE
92142: GREATEREQUAL
92143: IFFALSE 92151
92145: LD_INT 7
92147: DOUBLE
92148: LESSEQUAL
92149: IFTRUE 92153
92151: GO 92160
92153: POP
// StreamSibBomb ; end ;
92154: CALL 88411 0 0
92158: GO 92161
92160: POP
// end ;
92161: PPOPN 3
92163: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
92164: LD_EXP 118
92168: PUSH
92169: LD_EXP 168
92173: AND
92174: IFFALSE 92330
92176: GO 92178
92178: DISABLE
92179: LD_INT 0
92181: PPUSH
92182: PPUSH
92183: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
92184: LD_ADDR_VAR 0 2
92188: PUSH
92189: LD_INT 81
92191: PUSH
92192: LD_OWVAR 2
92196: PUSH
92197: EMPTY
92198: LIST
92199: LIST
92200: PUSH
92201: LD_INT 2
92203: PUSH
92204: LD_INT 21
92206: PUSH
92207: LD_INT 1
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: LD_INT 21
92216: PUSH
92217: LD_INT 2
92219: PUSH
92220: EMPTY
92221: LIST
92222: LIST
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: LIST
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PPUSH
92233: CALL_OW 69
92237: ST_TO_ADDR
// if not tmp then
92238: LD_VAR 0 2
92242: NOT
92243: IFFALSE 92247
// exit ;
92245: GO 92330
// p := 0 ;
92247: LD_ADDR_VAR 0 3
92251: PUSH
92252: LD_INT 0
92254: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
92255: LD_INT 35
92257: PPUSH
92258: CALL_OW 67
// p := p + 1 ;
92262: LD_ADDR_VAR 0 3
92266: PUSH
92267: LD_VAR 0 3
92271: PUSH
92272: LD_INT 1
92274: PLUS
92275: ST_TO_ADDR
// for i in tmp do
92276: LD_ADDR_VAR 0 1
92280: PUSH
92281: LD_VAR 0 2
92285: PUSH
92286: FOR_IN
92287: IFFALSE 92318
// if GetLives ( i ) < 1000 then
92289: LD_VAR 0 1
92293: PPUSH
92294: CALL_OW 256
92298: PUSH
92299: LD_INT 1000
92301: LESS
92302: IFFALSE 92316
// SetLives ( i , 1000 ) ;
92304: LD_VAR 0 1
92308: PPUSH
92309: LD_INT 1000
92311: PPUSH
92312: CALL_OW 234
92316: GO 92286
92318: POP
92319: POP
// until p > 20 ;
92320: LD_VAR 0 3
92324: PUSH
92325: LD_INT 20
92327: GREATER
92328: IFFALSE 92255
// end ;
92330: PPOPN 3
92332: END
// every 0 0$1 trigger StreamModeActive and sTime do
92333: LD_EXP 118
92337: PUSH
92338: LD_EXP 169
92342: AND
92343: IFFALSE 92378
92345: GO 92347
92347: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
92348: LD_INT 28
92350: PPUSH
92351: LD_OWVAR 2
92355: PPUSH
92356: LD_INT 2
92358: PPUSH
92359: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
92363: LD_INT 30
92365: PPUSH
92366: LD_OWVAR 2
92370: PPUSH
92371: LD_INT 2
92373: PPUSH
92374: CALL_OW 322
// end ;
92378: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
92379: LD_EXP 118
92383: PUSH
92384: LD_EXP 170
92388: AND
92389: IFFALSE 92510
92391: GO 92393
92393: DISABLE
92394: LD_INT 0
92396: PPUSH
92397: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92398: LD_ADDR_VAR 0 2
92402: PUSH
92403: LD_INT 22
92405: PUSH
92406: LD_OWVAR 2
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PUSH
92415: LD_INT 21
92417: PUSH
92418: LD_INT 1
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: PUSH
92425: LD_INT 3
92427: PUSH
92428: LD_INT 23
92430: PUSH
92431: LD_INT 0
92433: PUSH
92434: EMPTY
92435: LIST
92436: LIST
92437: PUSH
92438: EMPTY
92439: LIST
92440: LIST
92441: PUSH
92442: EMPTY
92443: LIST
92444: LIST
92445: LIST
92446: PPUSH
92447: CALL_OW 69
92451: ST_TO_ADDR
// if not tmp then
92452: LD_VAR 0 2
92456: NOT
92457: IFFALSE 92461
// exit ;
92459: GO 92510
// for i in tmp do
92461: LD_ADDR_VAR 0 1
92465: PUSH
92466: LD_VAR 0 2
92470: PUSH
92471: FOR_IN
92472: IFFALSE 92508
// begin if Crawls ( i ) then
92474: LD_VAR 0 1
92478: PPUSH
92479: CALL_OW 318
92483: IFFALSE 92494
// ComWalk ( i ) ;
92485: LD_VAR 0 1
92489: PPUSH
92490: CALL_OW 138
// SetClass ( i , 2 ) ;
92494: LD_VAR 0 1
92498: PPUSH
92499: LD_INT 2
92501: PPUSH
92502: CALL_OW 336
// end ;
92506: GO 92471
92508: POP
92509: POP
// end ;
92510: PPOPN 2
92512: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
92513: LD_EXP 118
92517: PUSH
92518: LD_EXP 171
92522: AND
92523: IFFALSE 92804
92525: GO 92527
92527: DISABLE
92528: LD_INT 0
92530: PPUSH
92531: PPUSH
92532: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
92533: LD_OWVAR 2
92537: PPUSH
92538: LD_INT 9
92540: PPUSH
92541: LD_INT 1
92543: PPUSH
92544: LD_INT 1
92546: PPUSH
92547: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
92551: LD_INT 9
92553: PPUSH
92554: LD_OWVAR 2
92558: PPUSH
92559: CALL_OW 343
// uc_side := 9 ;
92563: LD_ADDR_OWVAR 20
92567: PUSH
92568: LD_INT 9
92570: ST_TO_ADDR
// uc_nation := 2 ;
92571: LD_ADDR_OWVAR 21
92575: PUSH
92576: LD_INT 2
92578: ST_TO_ADDR
// hc_name := Dark Warrior ;
92579: LD_ADDR_OWVAR 26
92583: PUSH
92584: LD_STRING Dark Warrior
92586: ST_TO_ADDR
// hc_gallery :=  ;
92587: LD_ADDR_OWVAR 33
92591: PUSH
92592: LD_STRING 
92594: ST_TO_ADDR
// hc_noskilllimit := true ;
92595: LD_ADDR_OWVAR 76
92599: PUSH
92600: LD_INT 1
92602: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
92603: LD_ADDR_OWVAR 31
92607: PUSH
92608: LD_INT 30
92610: PUSH
92611: LD_INT 30
92613: PUSH
92614: LD_INT 30
92616: PUSH
92617: LD_INT 30
92619: PUSH
92620: EMPTY
92621: LIST
92622: LIST
92623: LIST
92624: LIST
92625: ST_TO_ADDR
// un := CreateHuman ;
92626: LD_ADDR_VAR 0 3
92630: PUSH
92631: CALL_OW 44
92635: ST_TO_ADDR
// hc_noskilllimit := false ;
92636: LD_ADDR_OWVAR 76
92640: PUSH
92641: LD_INT 0
92643: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92644: LD_VAR 0 3
92648: PPUSH
92649: LD_INT 1
92651: PPUSH
92652: CALL_OW 51
// p := 0 ;
92656: LD_ADDR_VAR 0 2
92660: PUSH
92661: LD_INT 0
92663: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
92664: LD_INT 35
92666: PPUSH
92667: CALL_OW 67
// p := p + 1 ;
92671: LD_ADDR_VAR 0 2
92675: PUSH
92676: LD_VAR 0 2
92680: PUSH
92681: LD_INT 1
92683: PLUS
92684: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
92685: LD_VAR 0 3
92689: PPUSH
92690: CALL_OW 256
92694: PUSH
92695: LD_INT 1000
92697: LESS
92698: IFFALSE 92712
// SetLives ( un , 1000 ) ;
92700: LD_VAR 0 3
92704: PPUSH
92705: LD_INT 1000
92707: PPUSH
92708: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
92712: LD_VAR 0 3
92716: PPUSH
92717: LD_INT 81
92719: PUSH
92720: LD_OWVAR 2
92724: PUSH
92725: EMPTY
92726: LIST
92727: LIST
92728: PUSH
92729: LD_INT 91
92731: PUSH
92732: LD_VAR 0 3
92736: PUSH
92737: LD_INT 30
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: LIST
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PPUSH
92749: CALL_OW 69
92753: PPUSH
92754: LD_VAR 0 3
92758: PPUSH
92759: CALL_OW 74
92763: PPUSH
92764: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
92768: LD_VAR 0 2
92772: PUSH
92773: LD_INT 60
92775: GREATER
92776: PUSH
92777: LD_VAR 0 3
92781: PPUSH
92782: CALL_OW 301
92786: OR
92787: IFFALSE 92664
// if un then
92789: LD_VAR 0 3
92793: IFFALSE 92804
// RemoveUnit ( un ) ;
92795: LD_VAR 0 3
92799: PPUSH
92800: CALL_OW 64
// end ;
92804: PPOPN 3
92806: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92807: LD_INT 0
92809: PPUSH
// case cmd of 301 :
92810: LD_VAR 0 1
92814: PUSH
92815: LD_INT 301
92817: DOUBLE
92818: EQUAL
92819: IFTRUE 92823
92821: GO 92855
92823: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
92824: LD_VAR 0 6
92828: PPUSH
92829: LD_VAR 0 7
92833: PPUSH
92834: LD_VAR 0 8
92838: PPUSH
92839: LD_VAR 0 4
92843: PPUSH
92844: LD_VAR 0 5
92848: PPUSH
92849: CALL 94056 0 5
92853: GO 92976
92855: LD_INT 302
92857: DOUBLE
92858: EQUAL
92859: IFTRUE 92863
92861: GO 92900
92863: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
92864: LD_VAR 0 6
92868: PPUSH
92869: LD_VAR 0 7
92873: PPUSH
92874: LD_VAR 0 8
92878: PPUSH
92879: LD_VAR 0 9
92883: PPUSH
92884: LD_VAR 0 4
92888: PPUSH
92889: LD_VAR 0 5
92893: PPUSH
92894: CALL 94147 0 6
92898: GO 92976
92900: LD_INT 303
92902: DOUBLE
92903: EQUAL
92904: IFTRUE 92908
92906: GO 92945
92908: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
92909: LD_VAR 0 6
92913: PPUSH
92914: LD_VAR 0 7
92918: PPUSH
92919: LD_VAR 0 8
92923: PPUSH
92924: LD_VAR 0 9
92928: PPUSH
92929: LD_VAR 0 4
92933: PPUSH
92934: LD_VAR 0 5
92938: PPUSH
92939: CALL 92981 0 6
92943: GO 92976
92945: LD_INT 304
92947: DOUBLE
92948: EQUAL
92949: IFTRUE 92953
92951: GO 92975
92953: POP
// hHackTeleport ( unit , x , y ) ; end ;
92954: LD_VAR 0 2
92958: PPUSH
92959: LD_VAR 0 4
92963: PPUSH
92964: LD_VAR 0 5
92968: PPUSH
92969: CALL 94740 0 3
92973: GO 92976
92975: POP
// end ;
92976: LD_VAR 0 12
92980: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
92981: LD_INT 0
92983: PPUSH
92984: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
92985: LD_VAR 0 1
92989: PUSH
92990: LD_INT 1
92992: LESS
92993: PUSH
92994: LD_VAR 0 1
92998: PUSH
92999: LD_INT 3
93001: GREATER
93002: OR
93003: PUSH
93004: LD_VAR 0 5
93008: PPUSH
93009: LD_VAR 0 6
93013: PPUSH
93014: CALL_OW 428
93018: OR
93019: IFFALSE 93023
// exit ;
93021: GO 93743
// uc_side := your_side ;
93023: LD_ADDR_OWVAR 20
93027: PUSH
93028: LD_OWVAR 2
93032: ST_TO_ADDR
// uc_nation := nation ;
93033: LD_ADDR_OWVAR 21
93037: PUSH
93038: LD_VAR 0 1
93042: ST_TO_ADDR
// bc_level = 1 ;
93043: LD_ADDR_OWVAR 43
93047: PUSH
93048: LD_INT 1
93050: ST_TO_ADDR
// case btype of 1 :
93051: LD_VAR 0 2
93055: PUSH
93056: LD_INT 1
93058: DOUBLE
93059: EQUAL
93060: IFTRUE 93064
93062: GO 93075
93064: POP
// bc_type := b_depot ; 2 :
93065: LD_ADDR_OWVAR 42
93069: PUSH
93070: LD_INT 0
93072: ST_TO_ADDR
93073: GO 93687
93075: LD_INT 2
93077: DOUBLE
93078: EQUAL
93079: IFTRUE 93083
93081: GO 93094
93083: POP
// bc_type := b_warehouse ; 3 :
93084: LD_ADDR_OWVAR 42
93088: PUSH
93089: LD_INT 1
93091: ST_TO_ADDR
93092: GO 93687
93094: LD_INT 3
93096: DOUBLE
93097: EQUAL
93098: IFTRUE 93102
93100: GO 93113
93102: POP
// bc_type := b_lab ; 4 .. 9 :
93103: LD_ADDR_OWVAR 42
93107: PUSH
93108: LD_INT 6
93110: ST_TO_ADDR
93111: GO 93687
93113: LD_INT 4
93115: DOUBLE
93116: GREATEREQUAL
93117: IFFALSE 93125
93119: LD_INT 9
93121: DOUBLE
93122: LESSEQUAL
93123: IFTRUE 93127
93125: GO 93179
93127: POP
// begin bc_type := b_lab_half ;
93128: LD_ADDR_OWVAR 42
93132: PUSH
93133: LD_INT 7
93135: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
93136: LD_ADDR_OWVAR 44
93140: PUSH
93141: LD_INT 10
93143: PUSH
93144: LD_INT 11
93146: PUSH
93147: LD_INT 12
93149: PUSH
93150: LD_INT 15
93152: PUSH
93153: LD_INT 14
93155: PUSH
93156: LD_INT 13
93158: PUSH
93159: EMPTY
93160: LIST
93161: LIST
93162: LIST
93163: LIST
93164: LIST
93165: LIST
93166: PUSH
93167: LD_VAR 0 2
93171: PUSH
93172: LD_INT 3
93174: MINUS
93175: ARRAY
93176: ST_TO_ADDR
// end ; 10 .. 13 :
93177: GO 93687
93179: LD_INT 10
93181: DOUBLE
93182: GREATEREQUAL
93183: IFFALSE 93191
93185: LD_INT 13
93187: DOUBLE
93188: LESSEQUAL
93189: IFTRUE 93193
93191: GO 93270
93193: POP
// begin bc_type := b_lab_full ;
93194: LD_ADDR_OWVAR 42
93198: PUSH
93199: LD_INT 8
93201: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
93202: LD_ADDR_OWVAR 44
93206: PUSH
93207: LD_INT 10
93209: PUSH
93210: LD_INT 12
93212: PUSH
93213: LD_INT 14
93215: PUSH
93216: LD_INT 13
93218: PUSH
93219: EMPTY
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: PUSH
93225: LD_VAR 0 2
93229: PUSH
93230: LD_INT 9
93232: MINUS
93233: ARRAY
93234: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
93235: LD_ADDR_OWVAR 45
93239: PUSH
93240: LD_INT 11
93242: PUSH
93243: LD_INT 15
93245: PUSH
93246: LD_INT 12
93248: PUSH
93249: LD_INT 15
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: PUSH
93258: LD_VAR 0 2
93262: PUSH
93263: LD_INT 9
93265: MINUS
93266: ARRAY
93267: ST_TO_ADDR
// end ; 14 :
93268: GO 93687
93270: LD_INT 14
93272: DOUBLE
93273: EQUAL
93274: IFTRUE 93278
93276: GO 93289
93278: POP
// bc_type := b_workshop ; 15 :
93279: LD_ADDR_OWVAR 42
93283: PUSH
93284: LD_INT 2
93286: ST_TO_ADDR
93287: GO 93687
93289: LD_INT 15
93291: DOUBLE
93292: EQUAL
93293: IFTRUE 93297
93295: GO 93308
93297: POP
// bc_type := b_factory ; 16 :
93298: LD_ADDR_OWVAR 42
93302: PUSH
93303: LD_INT 3
93305: ST_TO_ADDR
93306: GO 93687
93308: LD_INT 16
93310: DOUBLE
93311: EQUAL
93312: IFTRUE 93316
93314: GO 93327
93316: POP
// bc_type := b_ext_gun ; 17 :
93317: LD_ADDR_OWVAR 42
93321: PUSH
93322: LD_INT 17
93324: ST_TO_ADDR
93325: GO 93687
93327: LD_INT 17
93329: DOUBLE
93330: EQUAL
93331: IFTRUE 93335
93333: GO 93363
93335: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
93336: LD_ADDR_OWVAR 42
93340: PUSH
93341: LD_INT 19
93343: PUSH
93344: LD_INT 23
93346: PUSH
93347: LD_INT 19
93349: PUSH
93350: EMPTY
93351: LIST
93352: LIST
93353: LIST
93354: PUSH
93355: LD_VAR 0 1
93359: ARRAY
93360: ST_TO_ADDR
93361: GO 93687
93363: LD_INT 18
93365: DOUBLE
93366: EQUAL
93367: IFTRUE 93371
93369: GO 93382
93371: POP
// bc_type := b_ext_radar ; 19 :
93372: LD_ADDR_OWVAR 42
93376: PUSH
93377: LD_INT 20
93379: ST_TO_ADDR
93380: GO 93687
93382: LD_INT 19
93384: DOUBLE
93385: EQUAL
93386: IFTRUE 93390
93388: GO 93401
93390: POP
// bc_type := b_ext_radio ; 20 :
93391: LD_ADDR_OWVAR 42
93395: PUSH
93396: LD_INT 22
93398: ST_TO_ADDR
93399: GO 93687
93401: LD_INT 20
93403: DOUBLE
93404: EQUAL
93405: IFTRUE 93409
93407: GO 93420
93409: POP
// bc_type := b_ext_siberium ; 21 :
93410: LD_ADDR_OWVAR 42
93414: PUSH
93415: LD_INT 21
93417: ST_TO_ADDR
93418: GO 93687
93420: LD_INT 21
93422: DOUBLE
93423: EQUAL
93424: IFTRUE 93428
93426: GO 93439
93428: POP
// bc_type := b_ext_computer ; 22 :
93429: LD_ADDR_OWVAR 42
93433: PUSH
93434: LD_INT 24
93436: ST_TO_ADDR
93437: GO 93687
93439: LD_INT 22
93441: DOUBLE
93442: EQUAL
93443: IFTRUE 93447
93445: GO 93458
93447: POP
// bc_type := b_ext_track ; 23 :
93448: LD_ADDR_OWVAR 42
93452: PUSH
93453: LD_INT 16
93455: ST_TO_ADDR
93456: GO 93687
93458: LD_INT 23
93460: DOUBLE
93461: EQUAL
93462: IFTRUE 93466
93464: GO 93477
93466: POP
// bc_type := b_ext_laser ; 24 :
93467: LD_ADDR_OWVAR 42
93471: PUSH
93472: LD_INT 25
93474: ST_TO_ADDR
93475: GO 93687
93477: LD_INT 24
93479: DOUBLE
93480: EQUAL
93481: IFTRUE 93485
93483: GO 93496
93485: POP
// bc_type := b_control_tower ; 25 :
93486: LD_ADDR_OWVAR 42
93490: PUSH
93491: LD_INT 36
93493: ST_TO_ADDR
93494: GO 93687
93496: LD_INT 25
93498: DOUBLE
93499: EQUAL
93500: IFTRUE 93504
93502: GO 93515
93504: POP
// bc_type := b_breastwork ; 26 :
93505: LD_ADDR_OWVAR 42
93509: PUSH
93510: LD_INT 31
93512: ST_TO_ADDR
93513: GO 93687
93515: LD_INT 26
93517: DOUBLE
93518: EQUAL
93519: IFTRUE 93523
93521: GO 93534
93523: POP
// bc_type := b_bunker ; 27 :
93524: LD_ADDR_OWVAR 42
93528: PUSH
93529: LD_INT 32
93531: ST_TO_ADDR
93532: GO 93687
93534: LD_INT 27
93536: DOUBLE
93537: EQUAL
93538: IFTRUE 93542
93540: GO 93553
93542: POP
// bc_type := b_turret ; 28 :
93543: LD_ADDR_OWVAR 42
93547: PUSH
93548: LD_INT 33
93550: ST_TO_ADDR
93551: GO 93687
93553: LD_INT 28
93555: DOUBLE
93556: EQUAL
93557: IFTRUE 93561
93559: GO 93572
93561: POP
// bc_type := b_armoury ; 29 :
93562: LD_ADDR_OWVAR 42
93566: PUSH
93567: LD_INT 4
93569: ST_TO_ADDR
93570: GO 93687
93572: LD_INT 29
93574: DOUBLE
93575: EQUAL
93576: IFTRUE 93580
93578: GO 93591
93580: POP
// bc_type := b_barracks ; 30 :
93581: LD_ADDR_OWVAR 42
93585: PUSH
93586: LD_INT 5
93588: ST_TO_ADDR
93589: GO 93687
93591: LD_INT 30
93593: DOUBLE
93594: EQUAL
93595: IFTRUE 93599
93597: GO 93610
93599: POP
// bc_type := b_solar_power ; 31 :
93600: LD_ADDR_OWVAR 42
93604: PUSH
93605: LD_INT 27
93607: ST_TO_ADDR
93608: GO 93687
93610: LD_INT 31
93612: DOUBLE
93613: EQUAL
93614: IFTRUE 93618
93616: GO 93629
93618: POP
// bc_type := b_oil_power ; 32 :
93619: LD_ADDR_OWVAR 42
93623: PUSH
93624: LD_INT 26
93626: ST_TO_ADDR
93627: GO 93687
93629: LD_INT 32
93631: DOUBLE
93632: EQUAL
93633: IFTRUE 93637
93635: GO 93648
93637: POP
// bc_type := b_siberite_power ; 33 :
93638: LD_ADDR_OWVAR 42
93642: PUSH
93643: LD_INT 28
93645: ST_TO_ADDR
93646: GO 93687
93648: LD_INT 33
93650: DOUBLE
93651: EQUAL
93652: IFTRUE 93656
93654: GO 93667
93656: POP
// bc_type := b_oil_mine ; 34 :
93657: LD_ADDR_OWVAR 42
93661: PUSH
93662: LD_INT 29
93664: ST_TO_ADDR
93665: GO 93687
93667: LD_INT 34
93669: DOUBLE
93670: EQUAL
93671: IFTRUE 93675
93673: GO 93686
93675: POP
// bc_type := b_siberite_mine ; end ;
93676: LD_ADDR_OWVAR 42
93680: PUSH
93681: LD_INT 30
93683: ST_TO_ADDR
93684: GO 93687
93686: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
93687: LD_ADDR_VAR 0 8
93691: PUSH
93692: LD_VAR 0 5
93696: PPUSH
93697: LD_VAR 0 6
93701: PPUSH
93702: LD_VAR 0 3
93706: PPUSH
93707: CALL_OW 47
93711: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
93712: LD_OWVAR 42
93716: PUSH
93717: LD_INT 32
93719: PUSH
93720: LD_INT 33
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: IN
93727: IFFALSE 93743
// PlaceWeaponTurret ( b , weapon ) ;
93729: LD_VAR 0 8
93733: PPUSH
93734: LD_VAR 0 4
93738: PPUSH
93739: CALL_OW 431
// end ;
93743: LD_VAR 0 7
93747: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
93748: LD_INT 0
93750: PPUSH
93751: PPUSH
93752: PPUSH
93753: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93754: LD_ADDR_VAR 0 4
93758: PUSH
93759: LD_INT 22
93761: PUSH
93762: LD_OWVAR 2
93766: PUSH
93767: EMPTY
93768: LIST
93769: LIST
93770: PUSH
93771: LD_INT 2
93773: PUSH
93774: LD_INT 30
93776: PUSH
93777: LD_INT 0
93779: PUSH
93780: EMPTY
93781: LIST
93782: LIST
93783: PUSH
93784: LD_INT 30
93786: PUSH
93787: LD_INT 1
93789: PUSH
93790: EMPTY
93791: LIST
93792: LIST
93793: PUSH
93794: EMPTY
93795: LIST
93796: LIST
93797: LIST
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: PPUSH
93803: CALL_OW 69
93807: ST_TO_ADDR
// if not tmp then
93808: LD_VAR 0 4
93812: NOT
93813: IFFALSE 93817
// exit ;
93815: GO 93876
// for i in tmp do
93817: LD_ADDR_VAR 0 2
93821: PUSH
93822: LD_VAR 0 4
93826: PUSH
93827: FOR_IN
93828: IFFALSE 93874
// for j = 1 to 3 do
93830: LD_ADDR_VAR 0 3
93834: PUSH
93835: DOUBLE
93836: LD_INT 1
93838: DEC
93839: ST_TO_ADDR
93840: LD_INT 3
93842: PUSH
93843: FOR_TO
93844: IFFALSE 93870
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
93846: LD_VAR 0 2
93850: PPUSH
93851: CALL_OW 274
93855: PPUSH
93856: LD_VAR 0 3
93860: PPUSH
93861: LD_INT 99999
93863: PPUSH
93864: CALL_OW 277
93868: GO 93843
93870: POP
93871: POP
93872: GO 93827
93874: POP
93875: POP
// end ;
93876: LD_VAR 0 1
93880: RET
// export function hHackSetLevel10 ; var i , j ; begin
93881: LD_INT 0
93883: PPUSH
93884: PPUSH
93885: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
93886: LD_ADDR_VAR 0 2
93890: PUSH
93891: LD_INT 21
93893: PUSH
93894: LD_INT 1
93896: PUSH
93897: EMPTY
93898: LIST
93899: LIST
93900: PPUSH
93901: CALL_OW 69
93905: PUSH
93906: FOR_IN
93907: IFFALSE 93959
// if IsSelected ( i ) then
93909: LD_VAR 0 2
93913: PPUSH
93914: CALL_OW 306
93918: IFFALSE 93957
// begin for j := 1 to 4 do
93920: LD_ADDR_VAR 0 3
93924: PUSH
93925: DOUBLE
93926: LD_INT 1
93928: DEC
93929: ST_TO_ADDR
93930: LD_INT 4
93932: PUSH
93933: FOR_TO
93934: IFFALSE 93955
// SetSkill ( i , j , 10 ) ;
93936: LD_VAR 0 2
93940: PPUSH
93941: LD_VAR 0 3
93945: PPUSH
93946: LD_INT 10
93948: PPUSH
93949: CALL_OW 237
93953: GO 93933
93955: POP
93956: POP
// end ;
93957: GO 93906
93959: POP
93960: POP
// end ;
93961: LD_VAR 0 1
93965: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
93966: LD_INT 0
93968: PPUSH
93969: PPUSH
93970: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
93971: LD_ADDR_VAR 0 2
93975: PUSH
93976: LD_INT 22
93978: PUSH
93979: LD_OWVAR 2
93983: PUSH
93984: EMPTY
93985: LIST
93986: LIST
93987: PUSH
93988: LD_INT 21
93990: PUSH
93991: LD_INT 1
93993: PUSH
93994: EMPTY
93995: LIST
93996: LIST
93997: PUSH
93998: EMPTY
93999: LIST
94000: LIST
94001: PPUSH
94002: CALL_OW 69
94006: PUSH
94007: FOR_IN
94008: IFFALSE 94049
// begin for j := 1 to 4 do
94010: LD_ADDR_VAR 0 3
94014: PUSH
94015: DOUBLE
94016: LD_INT 1
94018: DEC
94019: ST_TO_ADDR
94020: LD_INT 4
94022: PUSH
94023: FOR_TO
94024: IFFALSE 94045
// SetSkill ( i , j , 10 ) ;
94026: LD_VAR 0 2
94030: PPUSH
94031: LD_VAR 0 3
94035: PPUSH
94036: LD_INT 10
94038: PPUSH
94039: CALL_OW 237
94043: GO 94023
94045: POP
94046: POP
// end ;
94047: GO 94007
94049: POP
94050: POP
// end ;
94051: LD_VAR 0 1
94055: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
94056: LD_INT 0
94058: PPUSH
// uc_side := your_side ;
94059: LD_ADDR_OWVAR 20
94063: PUSH
94064: LD_OWVAR 2
94068: ST_TO_ADDR
// uc_nation := nation ;
94069: LD_ADDR_OWVAR 21
94073: PUSH
94074: LD_VAR 0 1
94078: ST_TO_ADDR
// InitHc ;
94079: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
94083: LD_INT 0
94085: PPUSH
94086: LD_VAR 0 2
94090: PPUSH
94091: LD_VAR 0 3
94095: PPUSH
94096: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
94100: LD_VAR 0 4
94104: PPUSH
94105: LD_VAR 0 5
94109: PPUSH
94110: CALL_OW 428
94114: PUSH
94115: LD_INT 0
94117: EQUAL
94118: IFFALSE 94142
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
94120: CALL_OW 44
94124: PPUSH
94125: LD_VAR 0 4
94129: PPUSH
94130: LD_VAR 0 5
94134: PPUSH
94135: LD_INT 1
94137: PPUSH
94138: CALL_OW 48
// end ;
94142: LD_VAR 0 6
94146: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
94147: LD_INT 0
94149: PPUSH
94150: PPUSH
// uc_side := your_side ;
94151: LD_ADDR_OWVAR 20
94155: PUSH
94156: LD_OWVAR 2
94160: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
94161: LD_VAR 0 1
94165: PUSH
94166: LD_INT 1
94168: PUSH
94169: LD_INT 2
94171: PUSH
94172: LD_INT 3
94174: PUSH
94175: LD_INT 4
94177: PUSH
94178: LD_INT 5
94180: PUSH
94181: EMPTY
94182: LIST
94183: LIST
94184: LIST
94185: LIST
94186: LIST
94187: IN
94188: IFFALSE 94200
// uc_nation := nation_american else
94190: LD_ADDR_OWVAR 21
94194: PUSH
94195: LD_INT 1
94197: ST_TO_ADDR
94198: GO 94243
// if chassis in [ 11 , 12 , 13 , 14 ] then
94200: LD_VAR 0 1
94204: PUSH
94205: LD_INT 11
94207: PUSH
94208: LD_INT 12
94210: PUSH
94211: LD_INT 13
94213: PUSH
94214: LD_INT 14
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: IN
94223: IFFALSE 94235
// uc_nation := nation_arabian else
94225: LD_ADDR_OWVAR 21
94229: PUSH
94230: LD_INT 2
94232: ST_TO_ADDR
94233: GO 94243
// uc_nation := nation_russian ;
94235: LD_ADDR_OWVAR 21
94239: PUSH
94240: LD_INT 3
94242: ST_TO_ADDR
// vc_chassis := chassis ;
94243: LD_ADDR_OWVAR 37
94247: PUSH
94248: LD_VAR 0 1
94252: ST_TO_ADDR
// vc_engine := engine ;
94253: LD_ADDR_OWVAR 39
94257: PUSH
94258: LD_VAR 0 2
94262: ST_TO_ADDR
// vc_control := control ;
94263: LD_ADDR_OWVAR 38
94267: PUSH
94268: LD_VAR 0 3
94272: ST_TO_ADDR
// vc_weapon := weapon ;
94273: LD_ADDR_OWVAR 40
94277: PUSH
94278: LD_VAR 0 4
94282: ST_TO_ADDR
// un := CreateVehicle ;
94283: LD_ADDR_VAR 0 8
94287: PUSH
94288: CALL_OW 45
94292: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
94293: LD_VAR 0 8
94297: PPUSH
94298: LD_INT 0
94300: PPUSH
94301: LD_INT 5
94303: PPUSH
94304: CALL_OW 12
94308: PPUSH
94309: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
94313: LD_VAR 0 8
94317: PPUSH
94318: LD_VAR 0 5
94322: PPUSH
94323: LD_VAR 0 6
94327: PPUSH
94328: LD_INT 1
94330: PPUSH
94331: CALL_OW 48
// end ;
94335: LD_VAR 0 7
94339: RET
// export hInvincible ; every 1 do
94340: GO 94342
94342: DISABLE
// hInvincible := [ ] ;
94343: LD_ADDR_EXP 172
94347: PUSH
94348: EMPTY
94349: ST_TO_ADDR
94350: END
// every 10 do var i ;
94351: GO 94353
94353: DISABLE
94354: LD_INT 0
94356: PPUSH
// begin enable ;
94357: ENABLE
// if not hInvincible then
94358: LD_EXP 172
94362: NOT
94363: IFFALSE 94367
// exit ;
94365: GO 94411
// for i in hInvincible do
94367: LD_ADDR_VAR 0 1
94371: PUSH
94372: LD_EXP 172
94376: PUSH
94377: FOR_IN
94378: IFFALSE 94409
// if GetLives ( i ) < 1000 then
94380: LD_VAR 0 1
94384: PPUSH
94385: CALL_OW 256
94389: PUSH
94390: LD_INT 1000
94392: LESS
94393: IFFALSE 94407
// SetLives ( i , 1000 ) ;
94395: LD_VAR 0 1
94399: PPUSH
94400: LD_INT 1000
94402: PPUSH
94403: CALL_OW 234
94407: GO 94377
94409: POP
94410: POP
// end ;
94411: PPOPN 1
94413: END
// export function hHackInvincible ; var i ; begin
94414: LD_INT 0
94416: PPUSH
94417: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
94418: LD_ADDR_VAR 0 2
94422: PUSH
94423: LD_INT 2
94425: PUSH
94426: LD_INT 21
94428: PUSH
94429: LD_INT 1
94431: PUSH
94432: EMPTY
94433: LIST
94434: LIST
94435: PUSH
94436: LD_INT 21
94438: PUSH
94439: LD_INT 2
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: PUSH
94446: EMPTY
94447: LIST
94448: LIST
94449: LIST
94450: PPUSH
94451: CALL_OW 69
94455: PUSH
94456: FOR_IN
94457: IFFALSE 94518
// if IsSelected ( i ) then
94459: LD_VAR 0 2
94463: PPUSH
94464: CALL_OW 306
94468: IFFALSE 94516
// begin if i in hInvincible then
94470: LD_VAR 0 2
94474: PUSH
94475: LD_EXP 172
94479: IN
94480: IFFALSE 94500
// hInvincible := hInvincible diff i else
94482: LD_ADDR_EXP 172
94486: PUSH
94487: LD_EXP 172
94491: PUSH
94492: LD_VAR 0 2
94496: DIFF
94497: ST_TO_ADDR
94498: GO 94516
// hInvincible := hInvincible union i ;
94500: LD_ADDR_EXP 172
94504: PUSH
94505: LD_EXP 172
94509: PUSH
94510: LD_VAR 0 2
94514: UNION
94515: ST_TO_ADDR
// end ;
94516: GO 94456
94518: POP
94519: POP
// end ;
94520: LD_VAR 0 1
94524: RET
// export function hHackInvisible ; var i , j ; begin
94525: LD_INT 0
94527: PPUSH
94528: PPUSH
94529: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
94530: LD_ADDR_VAR 0 2
94534: PUSH
94535: LD_INT 21
94537: PUSH
94538: LD_INT 1
94540: PUSH
94541: EMPTY
94542: LIST
94543: LIST
94544: PPUSH
94545: CALL_OW 69
94549: PUSH
94550: FOR_IN
94551: IFFALSE 94575
// if IsSelected ( i ) then
94553: LD_VAR 0 2
94557: PPUSH
94558: CALL_OW 306
94562: IFFALSE 94573
// ComForceInvisible ( i ) ;
94564: LD_VAR 0 2
94568: PPUSH
94569: CALL_OW 496
94573: GO 94550
94575: POP
94576: POP
// end ;
94577: LD_VAR 0 1
94581: RET
// export function hHackChangeYourSide ; begin
94582: LD_INT 0
94584: PPUSH
// if your_side = 8 then
94585: LD_OWVAR 2
94589: PUSH
94590: LD_INT 8
94592: EQUAL
94593: IFFALSE 94605
// your_side := 0 else
94595: LD_ADDR_OWVAR 2
94599: PUSH
94600: LD_INT 0
94602: ST_TO_ADDR
94603: GO 94619
// your_side := your_side + 1 ;
94605: LD_ADDR_OWVAR 2
94609: PUSH
94610: LD_OWVAR 2
94614: PUSH
94615: LD_INT 1
94617: PLUS
94618: ST_TO_ADDR
// end ;
94619: LD_VAR 0 1
94623: RET
// export function hHackChangeUnitSide ; var i , j ; begin
94624: LD_INT 0
94626: PPUSH
94627: PPUSH
94628: PPUSH
// for i in all_units do
94629: LD_ADDR_VAR 0 2
94633: PUSH
94634: LD_OWVAR 3
94638: PUSH
94639: FOR_IN
94640: IFFALSE 94718
// if IsSelected ( i ) then
94642: LD_VAR 0 2
94646: PPUSH
94647: CALL_OW 306
94651: IFFALSE 94716
// begin j := GetSide ( i ) ;
94653: LD_ADDR_VAR 0 3
94657: PUSH
94658: LD_VAR 0 2
94662: PPUSH
94663: CALL_OW 255
94667: ST_TO_ADDR
// if j = 8 then
94668: LD_VAR 0 3
94672: PUSH
94673: LD_INT 8
94675: EQUAL
94676: IFFALSE 94688
// j := 0 else
94678: LD_ADDR_VAR 0 3
94682: PUSH
94683: LD_INT 0
94685: ST_TO_ADDR
94686: GO 94702
// j := j + 1 ;
94688: LD_ADDR_VAR 0 3
94692: PUSH
94693: LD_VAR 0 3
94697: PUSH
94698: LD_INT 1
94700: PLUS
94701: ST_TO_ADDR
// SetSide ( i , j ) ;
94702: LD_VAR 0 2
94706: PPUSH
94707: LD_VAR 0 3
94711: PPUSH
94712: CALL_OW 235
// end ;
94716: GO 94639
94718: POP
94719: POP
// end ;
94720: LD_VAR 0 1
94724: RET
// export function hHackFog ; begin
94725: LD_INT 0
94727: PPUSH
// FogOff ( true ) ;
94728: LD_INT 1
94730: PPUSH
94731: CALL_OW 344
// end ;
94735: LD_VAR 0 1
94739: RET
// export function hHackTeleport ( unit , x , y ) ; begin
94740: LD_INT 0
94742: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
94743: LD_VAR 0 1
94747: PPUSH
94748: LD_VAR 0 2
94752: PPUSH
94753: LD_VAR 0 3
94757: PPUSH
94758: LD_INT 1
94760: PPUSH
94761: LD_INT 1
94763: PPUSH
94764: CALL_OW 483
// CenterOnXY ( x , y ) ;
94768: LD_VAR 0 2
94772: PPUSH
94773: LD_VAR 0 3
94777: PPUSH
94778: CALL_OW 84
// end ; end_of_file
94782: LD_VAR 0 4
94786: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
94787: LD_INT 0
94789: PPUSH
94790: PPUSH
94791: PPUSH
94792: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
94793: LD_VAR 0 1
94797: PPUSH
94798: CALL_OW 264
94802: PUSH
94803: LD_EXP 106
94807: EQUAL
94808: IFFALSE 94880
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
94810: LD_INT 68
94812: PPUSH
94813: LD_VAR 0 1
94817: PPUSH
94818: CALL_OW 255
94822: PPUSH
94823: CALL_OW 321
94827: PUSH
94828: LD_INT 2
94830: EQUAL
94831: IFFALSE 94843
// eff := 70 else
94833: LD_ADDR_VAR 0 4
94837: PUSH
94838: LD_INT 70
94840: ST_TO_ADDR
94841: GO 94851
// eff := 30 ;
94843: LD_ADDR_VAR 0 4
94847: PUSH
94848: LD_INT 30
94850: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
94851: LD_VAR 0 1
94855: PPUSH
94856: CALL_OW 250
94860: PPUSH
94861: LD_VAR 0 1
94865: PPUSH
94866: CALL_OW 251
94870: PPUSH
94871: LD_VAR 0 4
94875: PPUSH
94876: CALL_OW 495
// end ; end ;
94880: LD_VAR 0 2
94884: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
94885: LD_INT 0
94887: PPUSH
// end ;
94888: LD_VAR 0 4
94892: RET
// export function SOS_Command ( cmd ) ; begin
94893: LD_INT 0
94895: PPUSH
// end ;
94896: LD_VAR 0 2
94900: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
94901: LD_INT 0
94903: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
94904: LD_VAR 0 1
94908: PUSH
94909: LD_INT 250
94911: EQUAL
94912: PUSH
94913: LD_VAR 0 2
94917: PPUSH
94918: CALL_OW 264
94922: PUSH
94923: LD_EXP 109
94927: EQUAL
94928: AND
94929: IFFALSE 94950
// MinerPlaceMine ( unit , x , y ) ;
94931: LD_VAR 0 2
94935: PPUSH
94936: LD_VAR 0 4
94940: PPUSH
94941: LD_VAR 0 5
94945: PPUSH
94946: CALL 97291 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
94950: LD_VAR 0 1
94954: PUSH
94955: LD_INT 251
94957: EQUAL
94958: PUSH
94959: LD_VAR 0 2
94963: PPUSH
94964: CALL_OW 264
94968: PUSH
94969: LD_EXP 109
94973: EQUAL
94974: AND
94975: IFFALSE 94996
// MinerDetonateMine ( unit , x , y ) ;
94977: LD_VAR 0 2
94981: PPUSH
94982: LD_VAR 0 4
94986: PPUSH
94987: LD_VAR 0 5
94991: PPUSH
94992: CALL 97568 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
94996: LD_VAR 0 1
95000: PUSH
95001: LD_INT 252
95003: EQUAL
95004: PUSH
95005: LD_VAR 0 2
95009: PPUSH
95010: CALL_OW 264
95014: PUSH
95015: LD_EXP 109
95019: EQUAL
95020: AND
95021: IFFALSE 95042
// MinerCreateMinefield ( unit , x , y ) ;
95023: LD_VAR 0 2
95027: PPUSH
95028: LD_VAR 0 4
95032: PPUSH
95033: LD_VAR 0 5
95037: PPUSH
95038: CALL 97985 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
95042: LD_VAR 0 1
95046: PUSH
95047: LD_INT 253
95049: EQUAL
95050: PUSH
95051: LD_VAR 0 2
95055: PPUSH
95056: CALL_OW 257
95060: PUSH
95061: LD_INT 5
95063: EQUAL
95064: AND
95065: IFFALSE 95086
// ComBinocular ( unit , x , y ) ;
95067: LD_VAR 0 2
95071: PPUSH
95072: LD_VAR 0 4
95076: PPUSH
95077: LD_VAR 0 5
95081: PPUSH
95082: CALL 98356 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
95086: LD_VAR 0 1
95090: PUSH
95091: LD_INT 254
95093: EQUAL
95094: PUSH
95095: LD_VAR 0 2
95099: PPUSH
95100: CALL_OW 264
95104: PUSH
95105: LD_EXP 104
95109: EQUAL
95110: AND
95111: PUSH
95112: LD_VAR 0 3
95116: PPUSH
95117: CALL_OW 263
95121: PUSH
95122: LD_INT 3
95124: EQUAL
95125: AND
95126: IFFALSE 95142
// HackDestroyVehicle ( unit , selectedUnit ) ;
95128: LD_VAR 0 2
95132: PPUSH
95133: LD_VAR 0 3
95137: PPUSH
95138: CALL 96651 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
95142: LD_VAR 0 1
95146: PUSH
95147: LD_INT 255
95149: EQUAL
95150: PUSH
95151: LD_VAR 0 2
95155: PPUSH
95156: CALL_OW 264
95160: PUSH
95161: LD_INT 14
95163: PUSH
95164: LD_INT 53
95166: PUSH
95167: EMPTY
95168: LIST
95169: LIST
95170: IN
95171: AND
95172: PUSH
95173: LD_VAR 0 4
95177: PPUSH
95178: LD_VAR 0 5
95182: PPUSH
95183: CALL_OW 488
95187: AND
95188: IFFALSE 95212
// CutTreeXYR ( unit , x , y , 12 ) ;
95190: LD_VAR 0 2
95194: PPUSH
95195: LD_VAR 0 4
95199: PPUSH
95200: LD_VAR 0 5
95204: PPUSH
95205: LD_INT 12
95207: PPUSH
95208: CALL 95217 0 4
// end ;
95212: LD_VAR 0 6
95216: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
95217: LD_INT 0
95219: PPUSH
95220: PPUSH
95221: PPUSH
95222: PPUSH
95223: PPUSH
95224: PPUSH
95225: PPUSH
95226: PPUSH
95227: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
95228: LD_VAR 0 1
95232: NOT
95233: PUSH
95234: LD_VAR 0 2
95238: PPUSH
95239: LD_VAR 0 3
95243: PPUSH
95244: CALL_OW 488
95248: NOT
95249: OR
95250: PUSH
95251: LD_VAR 0 4
95255: NOT
95256: OR
95257: IFFALSE 95261
// exit ;
95259: GO 95601
// list := [ ] ;
95261: LD_ADDR_VAR 0 13
95265: PUSH
95266: EMPTY
95267: ST_TO_ADDR
// if x - r < 0 then
95268: LD_VAR 0 2
95272: PUSH
95273: LD_VAR 0 4
95277: MINUS
95278: PUSH
95279: LD_INT 0
95281: LESS
95282: IFFALSE 95294
// min_x := 0 else
95284: LD_ADDR_VAR 0 7
95288: PUSH
95289: LD_INT 0
95291: ST_TO_ADDR
95292: GO 95310
// min_x := x - r ;
95294: LD_ADDR_VAR 0 7
95298: PUSH
95299: LD_VAR 0 2
95303: PUSH
95304: LD_VAR 0 4
95308: MINUS
95309: ST_TO_ADDR
// if y - r < 0 then
95310: LD_VAR 0 3
95314: PUSH
95315: LD_VAR 0 4
95319: MINUS
95320: PUSH
95321: LD_INT 0
95323: LESS
95324: IFFALSE 95336
// min_y := 0 else
95326: LD_ADDR_VAR 0 8
95330: PUSH
95331: LD_INT 0
95333: ST_TO_ADDR
95334: GO 95352
// min_y := y - r ;
95336: LD_ADDR_VAR 0 8
95340: PUSH
95341: LD_VAR 0 3
95345: PUSH
95346: LD_VAR 0 4
95350: MINUS
95351: ST_TO_ADDR
// max_x := x + r ;
95352: LD_ADDR_VAR 0 9
95356: PUSH
95357: LD_VAR 0 2
95361: PUSH
95362: LD_VAR 0 4
95366: PLUS
95367: ST_TO_ADDR
// max_y := y + r ;
95368: LD_ADDR_VAR 0 10
95372: PUSH
95373: LD_VAR 0 3
95377: PUSH
95378: LD_VAR 0 4
95382: PLUS
95383: ST_TO_ADDR
// for _x = min_x to max_x do
95384: LD_ADDR_VAR 0 11
95388: PUSH
95389: DOUBLE
95390: LD_VAR 0 7
95394: DEC
95395: ST_TO_ADDR
95396: LD_VAR 0 9
95400: PUSH
95401: FOR_TO
95402: IFFALSE 95519
// for _y = min_y to max_y do
95404: LD_ADDR_VAR 0 12
95408: PUSH
95409: DOUBLE
95410: LD_VAR 0 8
95414: DEC
95415: ST_TO_ADDR
95416: LD_VAR 0 10
95420: PUSH
95421: FOR_TO
95422: IFFALSE 95515
// begin if not ValidHex ( _x , _y ) then
95424: LD_VAR 0 11
95428: PPUSH
95429: LD_VAR 0 12
95433: PPUSH
95434: CALL_OW 488
95438: NOT
95439: IFFALSE 95443
// continue ;
95441: GO 95421
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
95443: LD_VAR 0 11
95447: PPUSH
95448: LD_VAR 0 12
95452: PPUSH
95453: CALL_OW 351
95457: PUSH
95458: LD_VAR 0 11
95462: PPUSH
95463: LD_VAR 0 12
95467: PPUSH
95468: CALL_OW 554
95472: AND
95473: IFFALSE 95513
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
95475: LD_ADDR_VAR 0 13
95479: PUSH
95480: LD_VAR 0 13
95484: PPUSH
95485: LD_VAR 0 13
95489: PUSH
95490: LD_INT 1
95492: PLUS
95493: PPUSH
95494: LD_VAR 0 11
95498: PUSH
95499: LD_VAR 0 12
95503: PUSH
95504: EMPTY
95505: LIST
95506: LIST
95507: PPUSH
95508: CALL_OW 2
95512: ST_TO_ADDR
// end ;
95513: GO 95421
95515: POP
95516: POP
95517: GO 95401
95519: POP
95520: POP
// if not list then
95521: LD_VAR 0 13
95525: NOT
95526: IFFALSE 95530
// exit ;
95528: GO 95601
// for i in list do
95530: LD_ADDR_VAR 0 6
95534: PUSH
95535: LD_VAR 0 13
95539: PUSH
95540: FOR_IN
95541: IFFALSE 95599
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
95543: LD_VAR 0 1
95547: PPUSH
95548: LD_STRING M
95550: PUSH
95551: LD_VAR 0 6
95555: PUSH
95556: LD_INT 1
95558: ARRAY
95559: PUSH
95560: LD_VAR 0 6
95564: PUSH
95565: LD_INT 2
95567: ARRAY
95568: PUSH
95569: LD_INT 0
95571: PUSH
95572: LD_INT 0
95574: PUSH
95575: LD_INT 0
95577: PUSH
95578: LD_INT 0
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: PUSH
95590: EMPTY
95591: LIST
95592: PPUSH
95593: CALL_OW 447
95597: GO 95540
95599: POP
95600: POP
// end ;
95601: LD_VAR 0 5
95605: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
95606: LD_EXP 173
95610: NOT
95611: IFFALSE 95661
95613: GO 95615
95615: DISABLE
// begin initHack := true ;
95616: LD_ADDR_EXP 173
95620: PUSH
95621: LD_INT 1
95623: ST_TO_ADDR
// hackTanks := [ ] ;
95624: LD_ADDR_EXP 174
95628: PUSH
95629: EMPTY
95630: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
95631: LD_ADDR_EXP 175
95635: PUSH
95636: EMPTY
95637: ST_TO_ADDR
// hackLimit := 3 ;
95638: LD_ADDR_EXP 176
95642: PUSH
95643: LD_INT 3
95645: ST_TO_ADDR
// hackDist := 12 ;
95646: LD_ADDR_EXP 177
95650: PUSH
95651: LD_INT 12
95653: ST_TO_ADDR
// hackCounter := [ ] ;
95654: LD_ADDR_EXP 178
95658: PUSH
95659: EMPTY
95660: ST_TO_ADDR
// end ;
95661: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
95662: LD_EXP 173
95666: PUSH
95667: LD_INT 34
95669: PUSH
95670: LD_EXP 104
95674: PUSH
95675: EMPTY
95676: LIST
95677: LIST
95678: PPUSH
95679: CALL_OW 69
95683: AND
95684: IFFALSE 95939
95686: GO 95688
95688: DISABLE
95689: LD_INT 0
95691: PPUSH
95692: PPUSH
// begin enable ;
95693: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
95694: LD_ADDR_VAR 0 1
95698: PUSH
95699: LD_INT 34
95701: PUSH
95702: LD_EXP 104
95706: PUSH
95707: EMPTY
95708: LIST
95709: LIST
95710: PPUSH
95711: CALL_OW 69
95715: PUSH
95716: FOR_IN
95717: IFFALSE 95937
// begin if not i in hackTanks then
95719: LD_VAR 0 1
95723: PUSH
95724: LD_EXP 174
95728: IN
95729: NOT
95730: IFFALSE 95813
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
95732: LD_ADDR_EXP 174
95736: PUSH
95737: LD_EXP 174
95741: PPUSH
95742: LD_EXP 174
95746: PUSH
95747: LD_INT 1
95749: PLUS
95750: PPUSH
95751: LD_VAR 0 1
95755: PPUSH
95756: CALL_OW 1
95760: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
95761: LD_ADDR_EXP 175
95765: PUSH
95766: LD_EXP 175
95770: PPUSH
95771: LD_EXP 175
95775: PUSH
95776: LD_INT 1
95778: PLUS
95779: PPUSH
95780: EMPTY
95781: PPUSH
95782: CALL_OW 1
95786: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
95787: LD_ADDR_EXP 178
95791: PUSH
95792: LD_EXP 178
95796: PPUSH
95797: LD_EXP 178
95801: PUSH
95802: LD_INT 1
95804: PLUS
95805: PPUSH
95806: EMPTY
95807: PPUSH
95808: CALL_OW 1
95812: ST_TO_ADDR
// end ; if not IsOk ( i ) then
95813: LD_VAR 0 1
95817: PPUSH
95818: CALL_OW 302
95822: NOT
95823: IFFALSE 95836
// begin HackUnlinkAll ( i ) ;
95825: LD_VAR 0 1
95829: PPUSH
95830: CALL 95942 0 1
// continue ;
95834: GO 95716
// end ; HackCheckCapturedStatus ( i ) ;
95836: LD_VAR 0 1
95840: PPUSH
95841: CALL 96385 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
95845: LD_ADDR_VAR 0 2
95849: PUSH
95850: LD_INT 81
95852: PUSH
95853: LD_VAR 0 1
95857: PPUSH
95858: CALL_OW 255
95862: PUSH
95863: EMPTY
95864: LIST
95865: LIST
95866: PUSH
95867: LD_INT 33
95869: PUSH
95870: LD_INT 3
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: LD_INT 91
95879: PUSH
95880: LD_VAR 0 1
95884: PUSH
95885: LD_EXP 177
95889: PUSH
95890: EMPTY
95891: LIST
95892: LIST
95893: LIST
95894: PUSH
95895: LD_INT 50
95897: PUSH
95898: EMPTY
95899: LIST
95900: PUSH
95901: EMPTY
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: PPUSH
95907: CALL_OW 69
95911: ST_TO_ADDR
// if not tmp then
95912: LD_VAR 0 2
95916: NOT
95917: IFFALSE 95921
// continue ;
95919: GO 95716
// HackLink ( i , tmp ) ;
95921: LD_VAR 0 1
95925: PPUSH
95926: LD_VAR 0 2
95930: PPUSH
95931: CALL 96078 0 2
// end ;
95935: GO 95716
95937: POP
95938: POP
// end ;
95939: PPOPN 2
95941: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
95942: LD_INT 0
95944: PPUSH
95945: PPUSH
95946: PPUSH
// if not hack in hackTanks then
95947: LD_VAR 0 1
95951: PUSH
95952: LD_EXP 174
95956: IN
95957: NOT
95958: IFFALSE 95962
// exit ;
95960: GO 96073
// index := GetElementIndex ( hackTanks , hack ) ;
95962: LD_ADDR_VAR 0 4
95966: PUSH
95967: LD_EXP 174
95971: PPUSH
95972: LD_VAR 0 1
95976: PPUSH
95977: CALL 19048 0 2
95981: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
95982: LD_EXP 175
95986: PUSH
95987: LD_VAR 0 4
95991: ARRAY
95992: IFFALSE 96073
// begin for i in hackTanksCaptured [ index ] do
95994: LD_ADDR_VAR 0 3
95998: PUSH
95999: LD_EXP 175
96003: PUSH
96004: LD_VAR 0 4
96008: ARRAY
96009: PUSH
96010: FOR_IN
96011: IFFALSE 96037
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
96013: LD_VAR 0 3
96017: PUSH
96018: LD_INT 1
96020: ARRAY
96021: PPUSH
96022: LD_VAR 0 3
96026: PUSH
96027: LD_INT 2
96029: ARRAY
96030: PPUSH
96031: CALL_OW 235
96035: GO 96010
96037: POP
96038: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
96039: LD_ADDR_EXP 175
96043: PUSH
96044: LD_EXP 175
96048: PPUSH
96049: LD_VAR 0 4
96053: PPUSH
96054: EMPTY
96055: PPUSH
96056: CALL_OW 1
96060: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
96061: LD_VAR 0 1
96065: PPUSH
96066: LD_INT 0
96068: PPUSH
96069: CALL_OW 505
// end ; end ;
96073: LD_VAR 0 2
96077: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
96078: LD_INT 0
96080: PPUSH
96081: PPUSH
96082: PPUSH
// if not hack in hackTanks or not vehicles then
96083: LD_VAR 0 1
96087: PUSH
96088: LD_EXP 174
96092: IN
96093: NOT
96094: PUSH
96095: LD_VAR 0 2
96099: NOT
96100: OR
96101: IFFALSE 96105
// exit ;
96103: GO 96380
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
96105: LD_ADDR_VAR 0 2
96109: PUSH
96110: LD_VAR 0 1
96114: PPUSH
96115: LD_VAR 0 2
96119: PPUSH
96120: LD_INT 1
96122: PPUSH
96123: LD_INT 1
96125: PPUSH
96126: CALL 19698 0 4
96130: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
96131: LD_ADDR_VAR 0 5
96135: PUSH
96136: LD_EXP 174
96140: PPUSH
96141: LD_VAR 0 1
96145: PPUSH
96146: CALL 19048 0 2
96150: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
96151: LD_EXP 175
96155: PUSH
96156: LD_VAR 0 5
96160: ARRAY
96161: PUSH
96162: LD_EXP 176
96166: LESS
96167: IFFALSE 96356
// begin for i := 1 to vehicles do
96169: LD_ADDR_VAR 0 4
96173: PUSH
96174: DOUBLE
96175: LD_INT 1
96177: DEC
96178: ST_TO_ADDR
96179: LD_VAR 0 2
96183: PUSH
96184: FOR_TO
96185: IFFALSE 96354
// begin if hackTanksCaptured [ index ] = hackLimit then
96187: LD_EXP 175
96191: PUSH
96192: LD_VAR 0 5
96196: ARRAY
96197: PUSH
96198: LD_EXP 176
96202: EQUAL
96203: IFFALSE 96207
// break ;
96205: GO 96354
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
96207: LD_ADDR_EXP 178
96211: PUSH
96212: LD_EXP 178
96216: PPUSH
96217: LD_VAR 0 5
96221: PPUSH
96222: LD_EXP 178
96226: PUSH
96227: LD_VAR 0 5
96231: ARRAY
96232: PUSH
96233: LD_INT 1
96235: PLUS
96236: PPUSH
96237: CALL_OW 1
96241: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
96242: LD_ADDR_EXP 175
96246: PUSH
96247: LD_EXP 175
96251: PPUSH
96252: LD_VAR 0 5
96256: PUSH
96257: LD_EXP 175
96261: PUSH
96262: LD_VAR 0 5
96266: ARRAY
96267: PUSH
96268: LD_INT 1
96270: PLUS
96271: PUSH
96272: EMPTY
96273: LIST
96274: LIST
96275: PPUSH
96276: LD_VAR 0 2
96280: PUSH
96281: LD_VAR 0 4
96285: ARRAY
96286: PUSH
96287: LD_VAR 0 2
96291: PUSH
96292: LD_VAR 0 4
96296: ARRAY
96297: PPUSH
96298: CALL_OW 255
96302: PUSH
96303: EMPTY
96304: LIST
96305: LIST
96306: PPUSH
96307: CALL 19263 0 3
96311: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
96312: LD_VAR 0 2
96316: PUSH
96317: LD_VAR 0 4
96321: ARRAY
96322: PPUSH
96323: LD_VAR 0 1
96327: PPUSH
96328: CALL_OW 255
96332: PPUSH
96333: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
96337: LD_VAR 0 2
96341: PUSH
96342: LD_VAR 0 4
96346: ARRAY
96347: PPUSH
96348: CALL_OW 141
// end ;
96352: GO 96184
96354: POP
96355: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96356: LD_VAR 0 1
96360: PPUSH
96361: LD_EXP 175
96365: PUSH
96366: LD_VAR 0 5
96370: ARRAY
96371: PUSH
96372: LD_INT 0
96374: PLUS
96375: PPUSH
96376: CALL_OW 505
// end ;
96380: LD_VAR 0 3
96384: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
96385: LD_INT 0
96387: PPUSH
96388: PPUSH
96389: PPUSH
96390: PPUSH
// if not hack in hackTanks then
96391: LD_VAR 0 1
96395: PUSH
96396: LD_EXP 174
96400: IN
96401: NOT
96402: IFFALSE 96406
// exit ;
96404: GO 96646
// index := GetElementIndex ( hackTanks , hack ) ;
96406: LD_ADDR_VAR 0 4
96410: PUSH
96411: LD_EXP 174
96415: PPUSH
96416: LD_VAR 0 1
96420: PPUSH
96421: CALL 19048 0 2
96425: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
96426: LD_ADDR_VAR 0 3
96430: PUSH
96431: DOUBLE
96432: LD_EXP 175
96436: PUSH
96437: LD_VAR 0 4
96441: ARRAY
96442: INC
96443: ST_TO_ADDR
96444: LD_INT 1
96446: PUSH
96447: FOR_DOWNTO
96448: IFFALSE 96620
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
96450: LD_ADDR_VAR 0 5
96454: PUSH
96455: LD_EXP 175
96459: PUSH
96460: LD_VAR 0 4
96464: ARRAY
96465: PUSH
96466: LD_VAR 0 3
96470: ARRAY
96471: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
96472: LD_VAR 0 5
96476: PUSH
96477: LD_INT 1
96479: ARRAY
96480: PPUSH
96481: CALL_OW 302
96485: NOT
96486: PUSH
96487: LD_VAR 0 5
96491: PUSH
96492: LD_INT 1
96494: ARRAY
96495: PPUSH
96496: CALL_OW 255
96500: PUSH
96501: LD_VAR 0 1
96505: PPUSH
96506: CALL_OW 255
96510: NONEQUAL
96511: OR
96512: IFFALSE 96618
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
96514: LD_VAR 0 5
96518: PUSH
96519: LD_INT 1
96521: ARRAY
96522: PPUSH
96523: CALL_OW 305
96527: PUSH
96528: LD_VAR 0 5
96532: PUSH
96533: LD_INT 1
96535: ARRAY
96536: PPUSH
96537: CALL_OW 255
96541: PUSH
96542: LD_VAR 0 1
96546: PPUSH
96547: CALL_OW 255
96551: EQUAL
96552: AND
96553: IFFALSE 96577
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
96555: LD_VAR 0 5
96559: PUSH
96560: LD_INT 1
96562: ARRAY
96563: PPUSH
96564: LD_VAR 0 5
96568: PUSH
96569: LD_INT 2
96571: ARRAY
96572: PPUSH
96573: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
96577: LD_ADDR_EXP 175
96581: PUSH
96582: LD_EXP 175
96586: PPUSH
96587: LD_VAR 0 4
96591: PPUSH
96592: LD_EXP 175
96596: PUSH
96597: LD_VAR 0 4
96601: ARRAY
96602: PPUSH
96603: LD_VAR 0 3
96607: PPUSH
96608: CALL_OW 3
96612: PPUSH
96613: CALL_OW 1
96617: ST_TO_ADDR
// end ; end ;
96618: GO 96447
96620: POP
96621: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96622: LD_VAR 0 1
96626: PPUSH
96627: LD_EXP 175
96631: PUSH
96632: LD_VAR 0 4
96636: ARRAY
96637: PUSH
96638: LD_INT 0
96640: PLUS
96641: PPUSH
96642: CALL_OW 505
// end ;
96646: LD_VAR 0 2
96650: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
96651: LD_INT 0
96653: PPUSH
96654: PPUSH
96655: PPUSH
96656: PPUSH
// if not hack in hackTanks then
96657: LD_VAR 0 1
96661: PUSH
96662: LD_EXP 174
96666: IN
96667: NOT
96668: IFFALSE 96672
// exit ;
96670: GO 96757
// index := GetElementIndex ( hackTanks , hack ) ;
96672: LD_ADDR_VAR 0 5
96676: PUSH
96677: LD_EXP 174
96681: PPUSH
96682: LD_VAR 0 1
96686: PPUSH
96687: CALL 19048 0 2
96691: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
96692: LD_ADDR_VAR 0 4
96696: PUSH
96697: DOUBLE
96698: LD_INT 1
96700: DEC
96701: ST_TO_ADDR
96702: LD_EXP 175
96706: PUSH
96707: LD_VAR 0 5
96711: ARRAY
96712: PUSH
96713: FOR_TO
96714: IFFALSE 96755
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
96716: LD_EXP 175
96720: PUSH
96721: LD_VAR 0 5
96725: ARRAY
96726: PUSH
96727: LD_VAR 0 4
96731: ARRAY
96732: PUSH
96733: LD_INT 1
96735: ARRAY
96736: PUSH
96737: LD_VAR 0 2
96741: EQUAL
96742: IFFALSE 96753
// KillUnit ( vehicle ) ;
96744: LD_VAR 0 2
96748: PPUSH
96749: CALL_OW 66
96753: GO 96713
96755: POP
96756: POP
// end ;
96757: LD_VAR 0 3
96761: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
96762: LD_EXP 179
96766: NOT
96767: IFFALSE 96802
96769: GO 96771
96771: DISABLE
// begin initMiner := true ;
96772: LD_ADDR_EXP 179
96776: PUSH
96777: LD_INT 1
96779: ST_TO_ADDR
// minersList := [ ] ;
96780: LD_ADDR_EXP 180
96784: PUSH
96785: EMPTY
96786: ST_TO_ADDR
// minerMinesList := [ ] ;
96787: LD_ADDR_EXP 181
96791: PUSH
96792: EMPTY
96793: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
96794: LD_ADDR_EXP 182
96798: PUSH
96799: LD_INT 5
96801: ST_TO_ADDR
// end ;
96802: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
96803: LD_EXP 179
96807: PUSH
96808: LD_INT 34
96810: PUSH
96811: LD_EXP 109
96815: PUSH
96816: EMPTY
96817: LIST
96818: LIST
96819: PPUSH
96820: CALL_OW 69
96824: AND
96825: IFFALSE 97288
96827: GO 96829
96829: DISABLE
96830: LD_INT 0
96832: PPUSH
96833: PPUSH
96834: PPUSH
96835: PPUSH
// begin enable ;
96836: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
96837: LD_ADDR_VAR 0 1
96841: PUSH
96842: LD_INT 34
96844: PUSH
96845: LD_EXP 109
96849: PUSH
96850: EMPTY
96851: LIST
96852: LIST
96853: PPUSH
96854: CALL_OW 69
96858: PUSH
96859: FOR_IN
96860: IFFALSE 96932
// begin if not i in minersList then
96862: LD_VAR 0 1
96866: PUSH
96867: LD_EXP 180
96871: IN
96872: NOT
96873: IFFALSE 96930
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
96875: LD_ADDR_EXP 180
96879: PUSH
96880: LD_EXP 180
96884: PPUSH
96885: LD_EXP 180
96889: PUSH
96890: LD_INT 1
96892: PLUS
96893: PPUSH
96894: LD_VAR 0 1
96898: PPUSH
96899: CALL_OW 1
96903: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
96904: LD_ADDR_EXP 181
96908: PUSH
96909: LD_EXP 181
96913: PPUSH
96914: LD_EXP 181
96918: PUSH
96919: LD_INT 1
96921: PLUS
96922: PPUSH
96923: EMPTY
96924: PPUSH
96925: CALL_OW 1
96929: ST_TO_ADDR
// end end ;
96930: GO 96859
96932: POP
96933: POP
// for i := minerMinesList downto 1 do
96934: LD_ADDR_VAR 0 1
96938: PUSH
96939: DOUBLE
96940: LD_EXP 181
96944: INC
96945: ST_TO_ADDR
96946: LD_INT 1
96948: PUSH
96949: FOR_DOWNTO
96950: IFFALSE 97286
// begin if IsLive ( minersList [ i ] ) then
96952: LD_EXP 180
96956: PUSH
96957: LD_VAR 0 1
96961: ARRAY
96962: PPUSH
96963: CALL_OW 300
96967: IFFALSE 96995
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
96969: LD_EXP 180
96973: PUSH
96974: LD_VAR 0 1
96978: ARRAY
96979: PPUSH
96980: LD_EXP 181
96984: PUSH
96985: LD_VAR 0 1
96989: ARRAY
96990: PPUSH
96991: CALL_OW 505
// if not minerMinesList [ i ] then
96995: LD_EXP 181
96999: PUSH
97000: LD_VAR 0 1
97004: ARRAY
97005: NOT
97006: IFFALSE 97010
// continue ;
97008: GO 96949
// for j := minerMinesList [ i ] downto 1 do
97010: LD_ADDR_VAR 0 2
97014: PUSH
97015: DOUBLE
97016: LD_EXP 181
97020: PUSH
97021: LD_VAR 0 1
97025: ARRAY
97026: INC
97027: ST_TO_ADDR
97028: LD_INT 1
97030: PUSH
97031: FOR_DOWNTO
97032: IFFALSE 97282
// begin side := GetSide ( minersList [ i ] ) ;
97034: LD_ADDR_VAR 0 3
97038: PUSH
97039: LD_EXP 180
97043: PUSH
97044: LD_VAR 0 1
97048: ARRAY
97049: PPUSH
97050: CALL_OW 255
97054: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
97055: LD_ADDR_VAR 0 4
97059: PUSH
97060: LD_EXP 181
97064: PUSH
97065: LD_VAR 0 1
97069: ARRAY
97070: PUSH
97071: LD_VAR 0 2
97075: ARRAY
97076: PUSH
97077: LD_INT 1
97079: ARRAY
97080: PPUSH
97081: LD_EXP 181
97085: PUSH
97086: LD_VAR 0 1
97090: ARRAY
97091: PUSH
97092: LD_VAR 0 2
97096: ARRAY
97097: PUSH
97098: LD_INT 2
97100: ARRAY
97101: PPUSH
97102: CALL_OW 428
97106: ST_TO_ADDR
// if not tmp then
97107: LD_VAR 0 4
97111: NOT
97112: IFFALSE 97116
// continue ;
97114: GO 97031
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
97116: LD_VAR 0 4
97120: PUSH
97121: LD_INT 81
97123: PUSH
97124: LD_VAR 0 3
97128: PUSH
97129: EMPTY
97130: LIST
97131: LIST
97132: PPUSH
97133: CALL_OW 69
97137: IN
97138: PUSH
97139: LD_EXP 181
97143: PUSH
97144: LD_VAR 0 1
97148: ARRAY
97149: PUSH
97150: LD_VAR 0 2
97154: ARRAY
97155: PUSH
97156: LD_INT 1
97158: ARRAY
97159: PPUSH
97160: LD_EXP 181
97164: PUSH
97165: LD_VAR 0 1
97169: ARRAY
97170: PUSH
97171: LD_VAR 0 2
97175: ARRAY
97176: PUSH
97177: LD_INT 2
97179: ARRAY
97180: PPUSH
97181: CALL_OW 458
97185: AND
97186: IFFALSE 97280
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
97188: LD_EXP 181
97192: PUSH
97193: LD_VAR 0 1
97197: ARRAY
97198: PUSH
97199: LD_VAR 0 2
97203: ARRAY
97204: PUSH
97205: LD_INT 1
97207: ARRAY
97208: PPUSH
97209: LD_EXP 181
97213: PUSH
97214: LD_VAR 0 1
97218: ARRAY
97219: PUSH
97220: LD_VAR 0 2
97224: ARRAY
97225: PUSH
97226: LD_INT 2
97228: ARRAY
97229: PPUSH
97230: LD_VAR 0 3
97234: PPUSH
97235: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
97239: LD_ADDR_EXP 181
97243: PUSH
97244: LD_EXP 181
97248: PPUSH
97249: LD_VAR 0 1
97253: PPUSH
97254: LD_EXP 181
97258: PUSH
97259: LD_VAR 0 1
97263: ARRAY
97264: PPUSH
97265: LD_VAR 0 2
97269: PPUSH
97270: CALL_OW 3
97274: PPUSH
97275: CALL_OW 1
97279: ST_TO_ADDR
// end ; end ;
97280: GO 97031
97282: POP
97283: POP
// end ;
97284: GO 96949
97286: POP
97287: POP
// end ;
97288: PPOPN 4
97290: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
97291: LD_INT 0
97293: PPUSH
97294: PPUSH
// result := false ;
97295: LD_ADDR_VAR 0 4
97299: PUSH
97300: LD_INT 0
97302: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
97303: LD_VAR 0 1
97307: PPUSH
97308: CALL_OW 264
97312: PUSH
97313: LD_EXP 109
97317: EQUAL
97318: NOT
97319: IFFALSE 97323
// exit ;
97321: GO 97563
// index := GetElementIndex ( minersList , unit ) ;
97323: LD_ADDR_VAR 0 5
97327: PUSH
97328: LD_EXP 180
97332: PPUSH
97333: LD_VAR 0 1
97337: PPUSH
97338: CALL 19048 0 2
97342: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
97343: LD_EXP 181
97347: PUSH
97348: LD_VAR 0 5
97352: ARRAY
97353: PUSH
97354: LD_EXP 182
97358: GREATEREQUAL
97359: IFFALSE 97363
// exit ;
97361: GO 97563
// ComMoveXY ( unit , x , y ) ;
97363: LD_VAR 0 1
97367: PPUSH
97368: LD_VAR 0 2
97372: PPUSH
97373: LD_VAR 0 3
97377: PPUSH
97378: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
97382: LD_INT 35
97384: PPUSH
97385: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
97389: LD_VAR 0 1
97393: PPUSH
97394: LD_VAR 0 2
97398: PPUSH
97399: LD_VAR 0 3
97403: PPUSH
97404: CALL 49112 0 3
97408: NOT
97409: PUSH
97410: LD_VAR 0 1
97414: PPUSH
97415: CALL_OW 314
97419: AND
97420: IFFALSE 97424
// exit ;
97422: GO 97563
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
97424: LD_VAR 0 2
97428: PPUSH
97429: LD_VAR 0 3
97433: PPUSH
97434: CALL_OW 428
97438: PUSH
97439: LD_VAR 0 1
97443: EQUAL
97444: PUSH
97445: LD_VAR 0 1
97449: PPUSH
97450: CALL_OW 314
97454: NOT
97455: AND
97456: IFFALSE 97382
// PlaySoundXY ( x , y , PlantMine ) ;
97458: LD_VAR 0 2
97462: PPUSH
97463: LD_VAR 0 3
97467: PPUSH
97468: LD_STRING PlantMine
97470: PPUSH
97471: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
97475: LD_VAR 0 2
97479: PPUSH
97480: LD_VAR 0 3
97484: PPUSH
97485: LD_VAR 0 1
97489: PPUSH
97490: CALL_OW 255
97494: PPUSH
97495: LD_INT 0
97497: PPUSH
97498: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
97502: LD_ADDR_EXP 181
97506: PUSH
97507: LD_EXP 181
97511: PPUSH
97512: LD_VAR 0 5
97516: PUSH
97517: LD_EXP 181
97521: PUSH
97522: LD_VAR 0 5
97526: ARRAY
97527: PUSH
97528: LD_INT 1
97530: PLUS
97531: PUSH
97532: EMPTY
97533: LIST
97534: LIST
97535: PPUSH
97536: LD_VAR 0 2
97540: PUSH
97541: LD_VAR 0 3
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: PPUSH
97550: CALL 19263 0 3
97554: ST_TO_ADDR
// result := true ;
97555: LD_ADDR_VAR 0 4
97559: PUSH
97560: LD_INT 1
97562: ST_TO_ADDR
// end ;
97563: LD_VAR 0 4
97567: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
97568: LD_INT 0
97570: PPUSH
97571: PPUSH
97572: PPUSH
// if not unit in minersList then
97573: LD_VAR 0 1
97577: PUSH
97578: LD_EXP 180
97582: IN
97583: NOT
97584: IFFALSE 97588
// exit ;
97586: GO 97980
// index := GetElementIndex ( minersList , unit ) ;
97588: LD_ADDR_VAR 0 6
97592: PUSH
97593: LD_EXP 180
97597: PPUSH
97598: LD_VAR 0 1
97602: PPUSH
97603: CALL 19048 0 2
97607: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
97608: LD_ADDR_VAR 0 5
97612: PUSH
97613: DOUBLE
97614: LD_EXP 181
97618: PUSH
97619: LD_VAR 0 6
97623: ARRAY
97624: INC
97625: ST_TO_ADDR
97626: LD_INT 1
97628: PUSH
97629: FOR_DOWNTO
97630: IFFALSE 97791
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
97632: LD_EXP 181
97636: PUSH
97637: LD_VAR 0 6
97641: ARRAY
97642: PUSH
97643: LD_VAR 0 5
97647: ARRAY
97648: PUSH
97649: LD_INT 1
97651: ARRAY
97652: PUSH
97653: LD_VAR 0 2
97657: EQUAL
97658: PUSH
97659: LD_EXP 181
97663: PUSH
97664: LD_VAR 0 6
97668: ARRAY
97669: PUSH
97670: LD_VAR 0 5
97674: ARRAY
97675: PUSH
97676: LD_INT 2
97678: ARRAY
97679: PUSH
97680: LD_VAR 0 3
97684: EQUAL
97685: AND
97686: IFFALSE 97789
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97688: LD_EXP 181
97692: PUSH
97693: LD_VAR 0 6
97697: ARRAY
97698: PUSH
97699: LD_VAR 0 5
97703: ARRAY
97704: PUSH
97705: LD_INT 1
97707: ARRAY
97708: PPUSH
97709: LD_EXP 181
97713: PUSH
97714: LD_VAR 0 6
97718: ARRAY
97719: PUSH
97720: LD_VAR 0 5
97724: ARRAY
97725: PUSH
97726: LD_INT 2
97728: ARRAY
97729: PPUSH
97730: LD_VAR 0 1
97734: PPUSH
97735: CALL_OW 255
97739: PPUSH
97740: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97744: LD_ADDR_EXP 181
97748: PUSH
97749: LD_EXP 181
97753: PPUSH
97754: LD_VAR 0 6
97758: PPUSH
97759: LD_EXP 181
97763: PUSH
97764: LD_VAR 0 6
97768: ARRAY
97769: PPUSH
97770: LD_VAR 0 5
97774: PPUSH
97775: CALL_OW 3
97779: PPUSH
97780: CALL_OW 1
97784: ST_TO_ADDR
// exit ;
97785: POP
97786: POP
97787: GO 97980
// end ; end ;
97789: GO 97629
97791: POP
97792: POP
// for i := minerMinesList [ index ] downto 1 do
97793: LD_ADDR_VAR 0 5
97797: PUSH
97798: DOUBLE
97799: LD_EXP 181
97803: PUSH
97804: LD_VAR 0 6
97808: ARRAY
97809: INC
97810: ST_TO_ADDR
97811: LD_INT 1
97813: PUSH
97814: FOR_DOWNTO
97815: IFFALSE 97978
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
97817: LD_EXP 181
97821: PUSH
97822: LD_VAR 0 6
97826: ARRAY
97827: PUSH
97828: LD_VAR 0 5
97832: ARRAY
97833: PUSH
97834: LD_INT 1
97836: ARRAY
97837: PPUSH
97838: LD_EXP 181
97842: PUSH
97843: LD_VAR 0 6
97847: ARRAY
97848: PUSH
97849: LD_VAR 0 5
97853: ARRAY
97854: PUSH
97855: LD_INT 2
97857: ARRAY
97858: PPUSH
97859: LD_VAR 0 2
97863: PPUSH
97864: LD_VAR 0 3
97868: PPUSH
97869: CALL_OW 298
97873: PUSH
97874: LD_INT 6
97876: LESS
97877: IFFALSE 97976
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97879: LD_EXP 181
97883: PUSH
97884: LD_VAR 0 6
97888: ARRAY
97889: PUSH
97890: LD_VAR 0 5
97894: ARRAY
97895: PUSH
97896: LD_INT 1
97898: ARRAY
97899: PPUSH
97900: LD_EXP 181
97904: PUSH
97905: LD_VAR 0 6
97909: ARRAY
97910: PUSH
97911: LD_VAR 0 5
97915: ARRAY
97916: PUSH
97917: LD_INT 2
97919: ARRAY
97920: PPUSH
97921: LD_VAR 0 1
97925: PPUSH
97926: CALL_OW 255
97930: PPUSH
97931: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97935: LD_ADDR_EXP 181
97939: PUSH
97940: LD_EXP 181
97944: PPUSH
97945: LD_VAR 0 6
97949: PPUSH
97950: LD_EXP 181
97954: PUSH
97955: LD_VAR 0 6
97959: ARRAY
97960: PPUSH
97961: LD_VAR 0 5
97965: PPUSH
97966: CALL_OW 3
97970: PPUSH
97971: CALL_OW 1
97975: ST_TO_ADDR
// end ; end ;
97976: GO 97814
97978: POP
97979: POP
// end ;
97980: LD_VAR 0 4
97984: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
97985: LD_INT 0
97987: PPUSH
97988: PPUSH
97989: PPUSH
97990: PPUSH
97991: PPUSH
97992: PPUSH
97993: PPUSH
97994: PPUSH
97995: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
97996: LD_VAR 0 1
98000: PPUSH
98001: CALL_OW 264
98005: PUSH
98006: LD_EXP 109
98010: EQUAL
98011: NOT
98012: PUSH
98013: LD_VAR 0 1
98017: PUSH
98018: LD_EXP 180
98022: IN
98023: NOT
98024: OR
98025: IFFALSE 98029
// exit ;
98027: GO 98351
// index := GetElementIndex ( minersList , unit ) ;
98029: LD_ADDR_VAR 0 6
98033: PUSH
98034: LD_EXP 180
98038: PPUSH
98039: LD_VAR 0 1
98043: PPUSH
98044: CALL 19048 0 2
98048: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
98049: LD_ADDR_VAR 0 8
98053: PUSH
98054: LD_EXP 182
98058: PUSH
98059: LD_EXP 181
98063: PUSH
98064: LD_VAR 0 6
98068: ARRAY
98069: MINUS
98070: ST_TO_ADDR
// if not minesFreeAmount then
98071: LD_VAR 0 8
98075: NOT
98076: IFFALSE 98080
// exit ;
98078: GO 98351
// tmp := [ ] ;
98080: LD_ADDR_VAR 0 7
98084: PUSH
98085: EMPTY
98086: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
98087: LD_ADDR_VAR 0 5
98091: PUSH
98092: DOUBLE
98093: LD_INT 1
98095: DEC
98096: ST_TO_ADDR
98097: LD_VAR 0 8
98101: PUSH
98102: FOR_TO
98103: IFFALSE 98298
// begin _d := rand ( 0 , 5 ) ;
98105: LD_ADDR_VAR 0 11
98109: PUSH
98110: LD_INT 0
98112: PPUSH
98113: LD_INT 5
98115: PPUSH
98116: CALL_OW 12
98120: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
98121: LD_ADDR_VAR 0 12
98125: PUSH
98126: LD_INT 2
98128: PPUSH
98129: LD_INT 6
98131: PPUSH
98132: CALL_OW 12
98136: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
98137: LD_ADDR_VAR 0 9
98141: PUSH
98142: LD_VAR 0 2
98146: PPUSH
98147: LD_VAR 0 11
98151: PPUSH
98152: LD_VAR 0 12
98156: PPUSH
98157: CALL_OW 272
98161: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
98162: LD_ADDR_VAR 0 10
98166: PUSH
98167: LD_VAR 0 3
98171: PPUSH
98172: LD_VAR 0 11
98176: PPUSH
98177: LD_VAR 0 12
98181: PPUSH
98182: CALL_OW 273
98186: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
98187: LD_VAR 0 9
98191: PPUSH
98192: LD_VAR 0 10
98196: PPUSH
98197: CALL_OW 488
98201: PUSH
98202: LD_VAR 0 9
98206: PUSH
98207: LD_VAR 0 10
98211: PUSH
98212: EMPTY
98213: LIST
98214: LIST
98215: PUSH
98216: LD_VAR 0 7
98220: IN
98221: NOT
98222: AND
98223: PUSH
98224: LD_VAR 0 9
98228: PPUSH
98229: LD_VAR 0 10
98233: PPUSH
98234: CALL_OW 458
98238: NOT
98239: AND
98240: IFFALSE 98282
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
98242: LD_ADDR_VAR 0 7
98246: PUSH
98247: LD_VAR 0 7
98251: PPUSH
98252: LD_VAR 0 7
98256: PUSH
98257: LD_INT 1
98259: PLUS
98260: PPUSH
98261: LD_VAR 0 9
98265: PUSH
98266: LD_VAR 0 10
98270: PUSH
98271: EMPTY
98272: LIST
98273: LIST
98274: PPUSH
98275: CALL_OW 1
98279: ST_TO_ADDR
98280: GO 98296
// i := i - 1 ;
98282: LD_ADDR_VAR 0 5
98286: PUSH
98287: LD_VAR 0 5
98291: PUSH
98292: LD_INT 1
98294: MINUS
98295: ST_TO_ADDR
// end ;
98296: GO 98102
98298: POP
98299: POP
// for i in tmp do
98300: LD_ADDR_VAR 0 5
98304: PUSH
98305: LD_VAR 0 7
98309: PUSH
98310: FOR_IN
98311: IFFALSE 98349
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
98313: LD_VAR 0 1
98317: PPUSH
98318: LD_VAR 0 5
98322: PUSH
98323: LD_INT 1
98325: ARRAY
98326: PPUSH
98327: LD_VAR 0 5
98331: PUSH
98332: LD_INT 2
98334: ARRAY
98335: PPUSH
98336: CALL 97291 0 3
98340: NOT
98341: IFFALSE 98347
// exit ;
98343: POP
98344: POP
98345: GO 98351
98347: GO 98310
98349: POP
98350: POP
// end ;
98351: LD_VAR 0 4
98355: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
98356: LD_INT 0
98358: PPUSH
98359: PPUSH
98360: PPUSH
98361: PPUSH
98362: PPUSH
98363: PPUSH
98364: PPUSH
// if not GetClass ( unit ) = class_sniper then
98365: LD_VAR 0 1
98369: PPUSH
98370: CALL_OW 257
98374: PUSH
98375: LD_INT 5
98377: EQUAL
98378: NOT
98379: IFFALSE 98383
// exit ;
98381: GO 98771
// dist := 8 ;
98383: LD_ADDR_VAR 0 5
98387: PUSH
98388: LD_INT 8
98390: ST_TO_ADDR
// viewRange := 12 ;
98391: LD_ADDR_VAR 0 7
98395: PUSH
98396: LD_INT 12
98398: ST_TO_ADDR
// side := GetSide ( unit ) ;
98399: LD_ADDR_VAR 0 6
98403: PUSH
98404: LD_VAR 0 1
98408: PPUSH
98409: CALL_OW 255
98413: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
98414: LD_INT 61
98416: PPUSH
98417: LD_VAR 0 6
98421: PPUSH
98422: CALL_OW 321
98426: PUSH
98427: LD_INT 2
98429: EQUAL
98430: IFFALSE 98440
// viewRange := 16 ;
98432: LD_ADDR_VAR 0 7
98436: PUSH
98437: LD_INT 16
98439: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
98440: LD_VAR 0 1
98444: PPUSH
98445: LD_VAR 0 2
98449: PPUSH
98450: LD_VAR 0 3
98454: PPUSH
98455: CALL_OW 297
98459: PUSH
98460: LD_VAR 0 5
98464: GREATER
98465: IFFALSE 98544
// begin ComMoveXY ( unit , x , y ) ;
98467: LD_VAR 0 1
98471: PPUSH
98472: LD_VAR 0 2
98476: PPUSH
98477: LD_VAR 0 3
98481: PPUSH
98482: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
98486: LD_INT 35
98488: PPUSH
98489: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
98493: LD_VAR 0 1
98497: PPUSH
98498: LD_VAR 0 2
98502: PPUSH
98503: LD_VAR 0 3
98507: PPUSH
98508: CALL 49112 0 3
98512: NOT
98513: IFFALSE 98517
// exit ;
98515: GO 98771
// until GetDistUnitXY ( unit , x , y ) < dist ;
98517: LD_VAR 0 1
98521: PPUSH
98522: LD_VAR 0 2
98526: PPUSH
98527: LD_VAR 0 3
98531: PPUSH
98532: CALL_OW 297
98536: PUSH
98537: LD_VAR 0 5
98541: LESS
98542: IFFALSE 98486
// end ; ComTurnXY ( unit , x , y ) ;
98544: LD_VAR 0 1
98548: PPUSH
98549: LD_VAR 0 2
98553: PPUSH
98554: LD_VAR 0 3
98558: PPUSH
98559: CALL_OW 118
// wait ( 5 ) ;
98563: LD_INT 5
98565: PPUSH
98566: CALL_OW 67
// _d := GetDir ( unit ) ;
98570: LD_ADDR_VAR 0 10
98574: PUSH
98575: LD_VAR 0 1
98579: PPUSH
98580: CALL_OW 254
98584: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
98585: LD_ADDR_VAR 0 8
98589: PUSH
98590: LD_VAR 0 1
98594: PPUSH
98595: CALL_OW 250
98599: PPUSH
98600: LD_VAR 0 10
98604: PPUSH
98605: LD_VAR 0 5
98609: PPUSH
98610: CALL_OW 272
98614: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
98615: LD_ADDR_VAR 0 9
98619: PUSH
98620: LD_VAR 0 1
98624: PPUSH
98625: CALL_OW 251
98629: PPUSH
98630: LD_VAR 0 10
98634: PPUSH
98635: LD_VAR 0 5
98639: PPUSH
98640: CALL_OW 273
98644: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
98645: LD_VAR 0 8
98649: PPUSH
98650: LD_VAR 0 9
98654: PPUSH
98655: CALL_OW 488
98659: NOT
98660: IFFALSE 98664
// exit ;
98662: GO 98771
// ComAnimCustom ( unit , 1 ) ;
98664: LD_VAR 0 1
98668: PPUSH
98669: LD_INT 1
98671: PPUSH
98672: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
98676: LD_VAR 0 8
98680: PPUSH
98681: LD_VAR 0 9
98685: PPUSH
98686: LD_VAR 0 6
98690: PPUSH
98691: LD_VAR 0 7
98695: PPUSH
98696: CALL_OW 330
// repeat wait ( 1 ) ;
98700: LD_INT 1
98702: PPUSH
98703: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
98707: LD_VAR 0 1
98711: PPUSH
98712: CALL_OW 316
98716: PUSH
98717: LD_VAR 0 1
98721: PPUSH
98722: CALL_OW 314
98726: OR
98727: PUSH
98728: LD_VAR 0 1
98732: PPUSH
98733: CALL_OW 302
98737: NOT
98738: OR
98739: PUSH
98740: LD_VAR 0 1
98744: PPUSH
98745: CALL_OW 301
98749: OR
98750: IFFALSE 98700
// RemoveSeeing ( _x , _y , side ) ;
98752: LD_VAR 0 8
98756: PPUSH
98757: LD_VAR 0 9
98761: PPUSH
98762: LD_VAR 0 6
98766: PPUSH
98767: CALL_OW 331
// end ; end_of_file
98771: LD_VAR 0 4
98775: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98776: LD_INT 0
98778: PPUSH
98779: PPUSH
98780: PPUSH
98781: PPUSH
98782: PPUSH
98783: PPUSH
98784: PPUSH
98785: PPUSH
98786: PPUSH
98787: PPUSH
98788: PPUSH
98789: PPUSH
98790: PPUSH
98791: PPUSH
98792: PPUSH
98793: PPUSH
98794: PPUSH
98795: PPUSH
98796: PPUSH
98797: PPUSH
98798: PPUSH
98799: PPUSH
98800: PPUSH
98801: PPUSH
98802: PPUSH
98803: PPUSH
98804: PPUSH
98805: PPUSH
98806: PPUSH
98807: PPUSH
98808: PPUSH
98809: PPUSH
98810: PPUSH
98811: PPUSH
// if not list then
98812: LD_VAR 0 1
98816: NOT
98817: IFFALSE 98821
// exit ;
98819: GO 103480
// base := list [ 1 ] ;
98821: LD_ADDR_VAR 0 3
98825: PUSH
98826: LD_VAR 0 1
98830: PUSH
98831: LD_INT 1
98833: ARRAY
98834: ST_TO_ADDR
// group := list [ 2 ] ;
98835: LD_ADDR_VAR 0 4
98839: PUSH
98840: LD_VAR 0 1
98844: PUSH
98845: LD_INT 2
98847: ARRAY
98848: ST_TO_ADDR
// path := list [ 3 ] ;
98849: LD_ADDR_VAR 0 5
98853: PUSH
98854: LD_VAR 0 1
98858: PUSH
98859: LD_INT 3
98861: ARRAY
98862: ST_TO_ADDR
// flags := list [ 4 ] ;
98863: LD_ADDR_VAR 0 6
98867: PUSH
98868: LD_VAR 0 1
98872: PUSH
98873: LD_INT 4
98875: ARRAY
98876: ST_TO_ADDR
// mined := [ ] ;
98877: LD_ADDR_VAR 0 27
98881: PUSH
98882: EMPTY
98883: ST_TO_ADDR
// bombed := [ ] ;
98884: LD_ADDR_VAR 0 28
98888: PUSH
98889: EMPTY
98890: ST_TO_ADDR
// healers := [ ] ;
98891: LD_ADDR_VAR 0 31
98895: PUSH
98896: EMPTY
98897: ST_TO_ADDR
// to_heal := [ ] ;
98898: LD_ADDR_VAR 0 30
98902: PUSH
98903: EMPTY
98904: ST_TO_ADDR
// repairs := [ ] ;
98905: LD_ADDR_VAR 0 33
98909: PUSH
98910: EMPTY
98911: ST_TO_ADDR
// to_repair := [ ] ;
98912: LD_ADDR_VAR 0 32
98916: PUSH
98917: EMPTY
98918: ST_TO_ADDR
// if not group or not path then
98919: LD_VAR 0 4
98923: NOT
98924: PUSH
98925: LD_VAR 0 5
98929: NOT
98930: OR
98931: IFFALSE 98935
// exit ;
98933: GO 103480
// side := GetSide ( group [ 1 ] ) ;
98935: LD_ADDR_VAR 0 35
98939: PUSH
98940: LD_VAR 0 4
98944: PUSH
98945: LD_INT 1
98947: ARRAY
98948: PPUSH
98949: CALL_OW 255
98953: ST_TO_ADDR
// if flags then
98954: LD_VAR 0 6
98958: IFFALSE 99102
// begin f_ignore_area := flags [ 1 ] ;
98960: LD_ADDR_VAR 0 17
98964: PUSH
98965: LD_VAR 0 6
98969: PUSH
98970: LD_INT 1
98972: ARRAY
98973: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
98974: LD_ADDR_VAR 0 18
98978: PUSH
98979: LD_VAR 0 6
98983: PUSH
98984: LD_INT 2
98986: ARRAY
98987: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
98988: LD_ADDR_VAR 0 19
98992: PUSH
98993: LD_VAR 0 6
98997: PUSH
98998: LD_INT 3
99000: ARRAY
99001: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
99002: LD_ADDR_VAR 0 20
99006: PUSH
99007: LD_VAR 0 6
99011: PUSH
99012: LD_INT 4
99014: ARRAY
99015: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
99016: LD_ADDR_VAR 0 21
99020: PUSH
99021: LD_VAR 0 6
99025: PUSH
99026: LD_INT 5
99028: ARRAY
99029: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
99030: LD_ADDR_VAR 0 22
99034: PUSH
99035: LD_VAR 0 6
99039: PUSH
99040: LD_INT 6
99042: ARRAY
99043: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
99044: LD_ADDR_VAR 0 23
99048: PUSH
99049: LD_VAR 0 6
99053: PUSH
99054: LD_INT 7
99056: ARRAY
99057: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
99058: LD_ADDR_VAR 0 24
99062: PUSH
99063: LD_VAR 0 6
99067: PUSH
99068: LD_INT 8
99070: ARRAY
99071: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
99072: LD_ADDR_VAR 0 25
99076: PUSH
99077: LD_VAR 0 6
99081: PUSH
99082: LD_INT 9
99084: ARRAY
99085: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
99086: LD_ADDR_VAR 0 26
99090: PUSH
99091: LD_VAR 0 6
99095: PUSH
99096: LD_INT 10
99098: ARRAY
99099: ST_TO_ADDR
// end else
99100: GO 99182
// begin f_ignore_area := false ;
99102: LD_ADDR_VAR 0 17
99106: PUSH
99107: LD_INT 0
99109: ST_TO_ADDR
// f_capture := false ;
99110: LD_ADDR_VAR 0 18
99114: PUSH
99115: LD_INT 0
99117: ST_TO_ADDR
// f_ignore_civ := false ;
99118: LD_ADDR_VAR 0 19
99122: PUSH
99123: LD_INT 0
99125: ST_TO_ADDR
// f_murder := false ;
99126: LD_ADDR_VAR 0 20
99130: PUSH
99131: LD_INT 0
99133: ST_TO_ADDR
// f_mines := false ;
99134: LD_ADDR_VAR 0 21
99138: PUSH
99139: LD_INT 0
99141: ST_TO_ADDR
// f_repair := false ;
99142: LD_ADDR_VAR 0 22
99146: PUSH
99147: LD_INT 0
99149: ST_TO_ADDR
// f_heal := false ;
99150: LD_ADDR_VAR 0 23
99154: PUSH
99155: LD_INT 0
99157: ST_TO_ADDR
// f_spacetime := false ;
99158: LD_ADDR_VAR 0 24
99162: PUSH
99163: LD_INT 0
99165: ST_TO_ADDR
// f_attack_depot := false ;
99166: LD_ADDR_VAR 0 25
99170: PUSH
99171: LD_INT 0
99173: ST_TO_ADDR
// f_crawl := false ;
99174: LD_ADDR_VAR 0 26
99178: PUSH
99179: LD_INT 0
99181: ST_TO_ADDR
// end ; if f_heal then
99182: LD_VAR 0 23
99186: IFFALSE 99213
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
99188: LD_ADDR_VAR 0 31
99192: PUSH
99193: LD_VAR 0 4
99197: PPUSH
99198: LD_INT 25
99200: PUSH
99201: LD_INT 4
99203: PUSH
99204: EMPTY
99205: LIST
99206: LIST
99207: PPUSH
99208: CALL_OW 72
99212: ST_TO_ADDR
// if f_repair then
99213: LD_VAR 0 22
99217: IFFALSE 99244
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
99219: LD_ADDR_VAR 0 33
99223: PUSH
99224: LD_VAR 0 4
99228: PPUSH
99229: LD_INT 25
99231: PUSH
99232: LD_INT 3
99234: PUSH
99235: EMPTY
99236: LIST
99237: LIST
99238: PPUSH
99239: CALL_OW 72
99243: ST_TO_ADDR
// units_path := [ ] ;
99244: LD_ADDR_VAR 0 16
99248: PUSH
99249: EMPTY
99250: ST_TO_ADDR
// for i = 1 to group do
99251: LD_ADDR_VAR 0 7
99255: PUSH
99256: DOUBLE
99257: LD_INT 1
99259: DEC
99260: ST_TO_ADDR
99261: LD_VAR 0 4
99265: PUSH
99266: FOR_TO
99267: IFFALSE 99296
// units_path := Replace ( units_path , i , path ) ;
99269: LD_ADDR_VAR 0 16
99273: PUSH
99274: LD_VAR 0 16
99278: PPUSH
99279: LD_VAR 0 7
99283: PPUSH
99284: LD_VAR 0 5
99288: PPUSH
99289: CALL_OW 1
99293: ST_TO_ADDR
99294: GO 99266
99296: POP
99297: POP
// repeat for i = group downto 1 do
99298: LD_ADDR_VAR 0 7
99302: PUSH
99303: DOUBLE
99304: LD_VAR 0 4
99308: INC
99309: ST_TO_ADDR
99310: LD_INT 1
99312: PUSH
99313: FOR_DOWNTO
99314: IFFALSE 103436
// begin wait ( 5 ) ;
99316: LD_INT 5
99318: PPUSH
99319: CALL_OW 67
// tmp := [ ] ;
99323: LD_ADDR_VAR 0 14
99327: PUSH
99328: EMPTY
99329: ST_TO_ADDR
// attacking := false ;
99330: LD_ADDR_VAR 0 29
99334: PUSH
99335: LD_INT 0
99337: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
99338: LD_VAR 0 4
99342: PUSH
99343: LD_VAR 0 7
99347: ARRAY
99348: PPUSH
99349: CALL_OW 301
99353: PUSH
99354: LD_VAR 0 4
99358: PUSH
99359: LD_VAR 0 7
99363: ARRAY
99364: NOT
99365: OR
99366: IFFALSE 99475
// begin if GetType ( group [ i ] ) = unit_human then
99368: LD_VAR 0 4
99372: PUSH
99373: LD_VAR 0 7
99377: ARRAY
99378: PPUSH
99379: CALL_OW 247
99383: PUSH
99384: LD_INT 1
99386: EQUAL
99387: IFFALSE 99433
// begin to_heal := to_heal diff group [ i ] ;
99389: LD_ADDR_VAR 0 30
99393: PUSH
99394: LD_VAR 0 30
99398: PUSH
99399: LD_VAR 0 4
99403: PUSH
99404: LD_VAR 0 7
99408: ARRAY
99409: DIFF
99410: ST_TO_ADDR
// healers := healers diff group [ i ] ;
99411: LD_ADDR_VAR 0 31
99415: PUSH
99416: LD_VAR 0 31
99420: PUSH
99421: LD_VAR 0 4
99425: PUSH
99426: LD_VAR 0 7
99430: ARRAY
99431: DIFF
99432: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
99433: LD_ADDR_VAR 0 4
99437: PUSH
99438: LD_VAR 0 4
99442: PPUSH
99443: LD_VAR 0 7
99447: PPUSH
99448: CALL_OW 3
99452: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
99453: LD_ADDR_VAR 0 16
99457: PUSH
99458: LD_VAR 0 16
99462: PPUSH
99463: LD_VAR 0 7
99467: PPUSH
99468: CALL_OW 3
99472: ST_TO_ADDR
// continue ;
99473: GO 99313
// end ; if f_repair then
99475: LD_VAR 0 22
99479: IFFALSE 99968
// begin if GetType ( group [ i ] ) = unit_vehicle then
99481: LD_VAR 0 4
99485: PUSH
99486: LD_VAR 0 7
99490: ARRAY
99491: PPUSH
99492: CALL_OW 247
99496: PUSH
99497: LD_INT 2
99499: EQUAL
99500: IFFALSE 99690
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
99502: LD_VAR 0 4
99506: PUSH
99507: LD_VAR 0 7
99511: ARRAY
99512: PPUSH
99513: CALL_OW 256
99517: PUSH
99518: LD_INT 700
99520: LESS
99521: PUSH
99522: LD_VAR 0 4
99526: PUSH
99527: LD_VAR 0 7
99531: ARRAY
99532: PUSH
99533: LD_VAR 0 32
99537: IN
99538: NOT
99539: AND
99540: IFFALSE 99564
// to_repair := to_repair union group [ i ] ;
99542: LD_ADDR_VAR 0 32
99546: PUSH
99547: LD_VAR 0 32
99551: PUSH
99552: LD_VAR 0 4
99556: PUSH
99557: LD_VAR 0 7
99561: ARRAY
99562: UNION
99563: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
99564: LD_VAR 0 4
99568: PUSH
99569: LD_VAR 0 7
99573: ARRAY
99574: PPUSH
99575: CALL_OW 256
99579: PUSH
99580: LD_INT 1000
99582: EQUAL
99583: PUSH
99584: LD_VAR 0 4
99588: PUSH
99589: LD_VAR 0 7
99593: ARRAY
99594: PUSH
99595: LD_VAR 0 32
99599: IN
99600: AND
99601: IFFALSE 99625
// to_repair := to_repair diff group [ i ] ;
99603: LD_ADDR_VAR 0 32
99607: PUSH
99608: LD_VAR 0 32
99612: PUSH
99613: LD_VAR 0 4
99617: PUSH
99618: LD_VAR 0 7
99622: ARRAY
99623: DIFF
99624: ST_TO_ADDR
// if group [ i ] in to_repair then
99625: LD_VAR 0 4
99629: PUSH
99630: LD_VAR 0 7
99634: ARRAY
99635: PUSH
99636: LD_VAR 0 32
99640: IN
99641: IFFALSE 99688
// begin if not IsInArea ( group [ i ] , f_repair ) then
99643: LD_VAR 0 4
99647: PUSH
99648: LD_VAR 0 7
99652: ARRAY
99653: PPUSH
99654: LD_VAR 0 22
99658: PPUSH
99659: CALL_OW 308
99663: NOT
99664: IFFALSE 99686
// ComMoveToArea ( group [ i ] , f_repair ) ;
99666: LD_VAR 0 4
99670: PUSH
99671: LD_VAR 0 7
99675: ARRAY
99676: PPUSH
99677: LD_VAR 0 22
99681: PPUSH
99682: CALL_OW 113
// continue ;
99686: GO 99313
// end ; end else
99688: GO 99968
// if group [ i ] in repairs then
99690: LD_VAR 0 4
99694: PUSH
99695: LD_VAR 0 7
99699: ARRAY
99700: PUSH
99701: LD_VAR 0 33
99705: IN
99706: IFFALSE 99968
// begin if IsInUnit ( group [ i ] ) then
99708: LD_VAR 0 4
99712: PUSH
99713: LD_VAR 0 7
99717: ARRAY
99718: PPUSH
99719: CALL_OW 310
99723: IFFALSE 99791
// begin z := IsInUnit ( group [ i ] ) ;
99725: LD_ADDR_VAR 0 13
99729: PUSH
99730: LD_VAR 0 4
99734: PUSH
99735: LD_VAR 0 7
99739: ARRAY
99740: PPUSH
99741: CALL_OW 310
99745: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99746: LD_VAR 0 13
99750: PUSH
99751: LD_VAR 0 32
99755: IN
99756: PUSH
99757: LD_VAR 0 13
99761: PPUSH
99762: LD_VAR 0 22
99766: PPUSH
99767: CALL_OW 308
99771: AND
99772: IFFALSE 99789
// ComExitVehicle ( group [ i ] ) ;
99774: LD_VAR 0 4
99778: PUSH
99779: LD_VAR 0 7
99783: ARRAY
99784: PPUSH
99785: CALL_OW 121
// end else
99789: GO 99968
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99791: LD_ADDR_VAR 0 13
99795: PUSH
99796: LD_VAR 0 4
99800: PPUSH
99801: LD_INT 95
99803: PUSH
99804: LD_VAR 0 22
99808: PUSH
99809: EMPTY
99810: LIST
99811: LIST
99812: PUSH
99813: LD_INT 58
99815: PUSH
99816: EMPTY
99817: LIST
99818: PUSH
99819: EMPTY
99820: LIST
99821: LIST
99822: PPUSH
99823: CALL_OW 72
99827: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99828: LD_VAR 0 4
99832: PUSH
99833: LD_VAR 0 7
99837: ARRAY
99838: PPUSH
99839: CALL_OW 314
99843: NOT
99844: IFFALSE 99966
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99846: LD_ADDR_VAR 0 10
99850: PUSH
99851: LD_VAR 0 13
99855: PPUSH
99856: LD_VAR 0 4
99860: PUSH
99861: LD_VAR 0 7
99865: ARRAY
99866: PPUSH
99867: CALL_OW 74
99871: ST_TO_ADDR
// if not x then
99872: LD_VAR 0 10
99876: NOT
99877: IFFALSE 99881
// continue ;
99879: GO 99313
// if GetLives ( x ) < 1000 then
99881: LD_VAR 0 10
99885: PPUSH
99886: CALL_OW 256
99890: PUSH
99891: LD_INT 1000
99893: LESS
99894: IFFALSE 99918
// ComRepairVehicle ( group [ i ] , x ) else
99896: LD_VAR 0 4
99900: PUSH
99901: LD_VAR 0 7
99905: ARRAY
99906: PPUSH
99907: LD_VAR 0 10
99911: PPUSH
99912: CALL_OW 129
99916: GO 99966
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99918: LD_VAR 0 23
99922: PUSH
99923: LD_VAR 0 4
99927: PUSH
99928: LD_VAR 0 7
99932: ARRAY
99933: PPUSH
99934: CALL_OW 256
99938: PUSH
99939: LD_INT 1000
99941: LESS
99942: AND
99943: NOT
99944: IFFALSE 99966
// ComEnterUnit ( group [ i ] , x ) ;
99946: LD_VAR 0 4
99950: PUSH
99951: LD_VAR 0 7
99955: ARRAY
99956: PPUSH
99957: LD_VAR 0 10
99961: PPUSH
99962: CALL_OW 120
// end ; continue ;
99966: GO 99313
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
99968: LD_VAR 0 23
99972: PUSH
99973: LD_VAR 0 4
99977: PUSH
99978: LD_VAR 0 7
99982: ARRAY
99983: PPUSH
99984: CALL_OW 247
99988: PUSH
99989: LD_INT 1
99991: EQUAL
99992: AND
99993: IFFALSE 100471
// begin if group [ i ] in healers then
99995: LD_VAR 0 4
99999: PUSH
100000: LD_VAR 0 7
100004: ARRAY
100005: PUSH
100006: LD_VAR 0 31
100010: IN
100011: IFFALSE 100284
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
100013: LD_VAR 0 4
100017: PUSH
100018: LD_VAR 0 7
100022: ARRAY
100023: PPUSH
100024: LD_VAR 0 23
100028: PPUSH
100029: CALL_OW 308
100033: NOT
100034: PUSH
100035: LD_VAR 0 4
100039: PUSH
100040: LD_VAR 0 7
100044: ARRAY
100045: PPUSH
100046: CALL_OW 314
100050: NOT
100051: AND
100052: IFFALSE 100076
// ComMoveToArea ( group [ i ] , f_heal ) else
100054: LD_VAR 0 4
100058: PUSH
100059: LD_VAR 0 7
100063: ARRAY
100064: PPUSH
100065: LD_VAR 0 23
100069: PPUSH
100070: CALL_OW 113
100074: GO 100282
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
100076: LD_VAR 0 4
100080: PUSH
100081: LD_VAR 0 7
100085: ARRAY
100086: PPUSH
100087: CALL 47635 0 1
100091: PPUSH
100092: CALL_OW 256
100096: PUSH
100097: LD_INT 1000
100099: EQUAL
100100: IFFALSE 100119
// ComStop ( group [ i ] ) else
100102: LD_VAR 0 4
100106: PUSH
100107: LD_VAR 0 7
100111: ARRAY
100112: PPUSH
100113: CALL_OW 141
100117: GO 100282
// if not HasTask ( group [ i ] ) and to_heal then
100119: LD_VAR 0 4
100123: PUSH
100124: LD_VAR 0 7
100128: ARRAY
100129: PPUSH
100130: CALL_OW 314
100134: NOT
100135: PUSH
100136: LD_VAR 0 30
100140: AND
100141: IFFALSE 100282
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
100143: LD_ADDR_VAR 0 13
100147: PUSH
100148: LD_VAR 0 30
100152: PPUSH
100153: LD_INT 3
100155: PUSH
100156: LD_INT 54
100158: PUSH
100159: EMPTY
100160: LIST
100161: PUSH
100162: EMPTY
100163: LIST
100164: LIST
100165: PPUSH
100166: CALL_OW 72
100170: PPUSH
100171: LD_VAR 0 4
100175: PUSH
100176: LD_VAR 0 7
100180: ARRAY
100181: PPUSH
100182: CALL_OW 74
100186: ST_TO_ADDR
// if z then
100187: LD_VAR 0 13
100191: IFFALSE 100282
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
100193: LD_INT 91
100195: PUSH
100196: LD_VAR 0 13
100200: PUSH
100201: LD_INT 10
100203: PUSH
100204: EMPTY
100205: LIST
100206: LIST
100207: LIST
100208: PUSH
100209: LD_INT 81
100211: PUSH
100212: LD_VAR 0 13
100216: PPUSH
100217: CALL_OW 255
100221: PUSH
100222: EMPTY
100223: LIST
100224: LIST
100225: PUSH
100226: EMPTY
100227: LIST
100228: LIST
100229: PPUSH
100230: CALL_OW 69
100234: PUSH
100235: LD_INT 0
100237: EQUAL
100238: IFFALSE 100262
// ComHeal ( group [ i ] , z ) else
100240: LD_VAR 0 4
100244: PUSH
100245: LD_VAR 0 7
100249: ARRAY
100250: PPUSH
100251: LD_VAR 0 13
100255: PPUSH
100256: CALL_OW 128
100260: GO 100282
// ComMoveToArea ( group [ i ] , f_heal ) ;
100262: LD_VAR 0 4
100266: PUSH
100267: LD_VAR 0 7
100271: ARRAY
100272: PPUSH
100273: LD_VAR 0 23
100277: PPUSH
100278: CALL_OW 113
// end ; continue ;
100282: GO 99313
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
100284: LD_VAR 0 4
100288: PUSH
100289: LD_VAR 0 7
100293: ARRAY
100294: PPUSH
100295: CALL_OW 256
100299: PUSH
100300: LD_INT 700
100302: LESS
100303: PUSH
100304: LD_VAR 0 4
100308: PUSH
100309: LD_VAR 0 7
100313: ARRAY
100314: PUSH
100315: LD_VAR 0 30
100319: IN
100320: NOT
100321: AND
100322: IFFALSE 100346
// to_heal := to_heal union group [ i ] ;
100324: LD_ADDR_VAR 0 30
100328: PUSH
100329: LD_VAR 0 30
100333: PUSH
100334: LD_VAR 0 4
100338: PUSH
100339: LD_VAR 0 7
100343: ARRAY
100344: UNION
100345: ST_TO_ADDR
// if group [ i ] in to_heal then
100346: LD_VAR 0 4
100350: PUSH
100351: LD_VAR 0 7
100355: ARRAY
100356: PUSH
100357: LD_VAR 0 30
100361: IN
100362: IFFALSE 100471
// begin if GetLives ( group [ i ] ) = 1000 then
100364: LD_VAR 0 4
100368: PUSH
100369: LD_VAR 0 7
100373: ARRAY
100374: PPUSH
100375: CALL_OW 256
100379: PUSH
100380: LD_INT 1000
100382: EQUAL
100383: IFFALSE 100409
// to_heal := to_heal diff group [ i ] else
100385: LD_ADDR_VAR 0 30
100389: PUSH
100390: LD_VAR 0 30
100394: PUSH
100395: LD_VAR 0 4
100399: PUSH
100400: LD_VAR 0 7
100404: ARRAY
100405: DIFF
100406: ST_TO_ADDR
100407: GO 100471
// begin if not IsInArea ( group [ i ] , to_heal ) then
100409: LD_VAR 0 4
100413: PUSH
100414: LD_VAR 0 7
100418: ARRAY
100419: PPUSH
100420: LD_VAR 0 30
100424: PPUSH
100425: CALL_OW 308
100429: NOT
100430: IFFALSE 100454
// ComMoveToArea ( group [ i ] , f_heal ) else
100432: LD_VAR 0 4
100436: PUSH
100437: LD_VAR 0 7
100441: ARRAY
100442: PPUSH
100443: LD_VAR 0 23
100447: PPUSH
100448: CALL_OW 113
100452: GO 100469
// ComHold ( group [ i ] ) ;
100454: LD_VAR 0 4
100458: PUSH
100459: LD_VAR 0 7
100463: ARRAY
100464: PPUSH
100465: CALL_OW 140
// continue ;
100469: GO 99313
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
100471: LD_VAR 0 4
100475: PUSH
100476: LD_VAR 0 7
100480: ARRAY
100481: PPUSH
100482: LD_INT 10
100484: PPUSH
100485: CALL 46055 0 2
100489: NOT
100490: PUSH
100491: LD_VAR 0 16
100495: PUSH
100496: LD_VAR 0 7
100500: ARRAY
100501: PUSH
100502: EMPTY
100503: EQUAL
100504: NOT
100505: AND
100506: IFFALSE 100772
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
100508: LD_VAR 0 4
100512: PUSH
100513: LD_VAR 0 7
100517: ARRAY
100518: PPUSH
100519: CALL_OW 262
100523: PUSH
100524: LD_INT 1
100526: PUSH
100527: LD_INT 2
100529: PUSH
100530: EMPTY
100531: LIST
100532: LIST
100533: IN
100534: IFFALSE 100575
// if GetFuel ( group [ i ] ) < 10 then
100536: LD_VAR 0 4
100540: PUSH
100541: LD_VAR 0 7
100545: ARRAY
100546: PPUSH
100547: CALL_OW 261
100551: PUSH
100552: LD_INT 10
100554: LESS
100555: IFFALSE 100575
// SetFuel ( group [ i ] , 12 ) ;
100557: LD_VAR 0 4
100561: PUSH
100562: LD_VAR 0 7
100566: ARRAY
100567: PPUSH
100568: LD_INT 12
100570: PPUSH
100571: CALL_OW 240
// if units_path [ i ] then
100575: LD_VAR 0 16
100579: PUSH
100580: LD_VAR 0 7
100584: ARRAY
100585: IFFALSE 100770
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
100587: LD_VAR 0 4
100591: PUSH
100592: LD_VAR 0 7
100596: ARRAY
100597: PPUSH
100598: LD_VAR 0 16
100602: PUSH
100603: LD_VAR 0 7
100607: ARRAY
100608: PUSH
100609: LD_INT 1
100611: ARRAY
100612: PUSH
100613: LD_INT 1
100615: ARRAY
100616: PPUSH
100617: LD_VAR 0 16
100621: PUSH
100622: LD_VAR 0 7
100626: ARRAY
100627: PUSH
100628: LD_INT 1
100630: ARRAY
100631: PUSH
100632: LD_INT 2
100634: ARRAY
100635: PPUSH
100636: CALL_OW 297
100640: PUSH
100641: LD_INT 6
100643: GREATER
100644: IFFALSE 100719
// begin if not HasTask ( group [ i ] ) then
100646: LD_VAR 0 4
100650: PUSH
100651: LD_VAR 0 7
100655: ARRAY
100656: PPUSH
100657: CALL_OW 314
100661: NOT
100662: IFFALSE 100717
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100664: LD_VAR 0 4
100668: PUSH
100669: LD_VAR 0 7
100673: ARRAY
100674: PPUSH
100675: LD_VAR 0 16
100679: PUSH
100680: LD_VAR 0 7
100684: ARRAY
100685: PUSH
100686: LD_INT 1
100688: ARRAY
100689: PUSH
100690: LD_INT 1
100692: ARRAY
100693: PPUSH
100694: LD_VAR 0 16
100698: PUSH
100699: LD_VAR 0 7
100703: ARRAY
100704: PUSH
100705: LD_INT 1
100707: ARRAY
100708: PUSH
100709: LD_INT 2
100711: ARRAY
100712: PPUSH
100713: CALL_OW 114
// end else
100717: GO 100770
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100719: LD_ADDR_VAR 0 15
100723: PUSH
100724: LD_VAR 0 16
100728: PUSH
100729: LD_VAR 0 7
100733: ARRAY
100734: PPUSH
100735: LD_INT 1
100737: PPUSH
100738: CALL_OW 3
100742: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100743: LD_ADDR_VAR 0 16
100747: PUSH
100748: LD_VAR 0 16
100752: PPUSH
100753: LD_VAR 0 7
100757: PPUSH
100758: LD_VAR 0 15
100762: PPUSH
100763: CALL_OW 1
100767: ST_TO_ADDR
// continue ;
100768: GO 99313
// end ; end ; end else
100770: GO 103434
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100772: LD_ADDR_VAR 0 14
100776: PUSH
100777: LD_INT 81
100779: PUSH
100780: LD_VAR 0 4
100784: PUSH
100785: LD_VAR 0 7
100789: ARRAY
100790: PPUSH
100791: CALL_OW 255
100795: PUSH
100796: EMPTY
100797: LIST
100798: LIST
100799: PPUSH
100800: CALL_OW 69
100804: ST_TO_ADDR
// if not tmp then
100805: LD_VAR 0 14
100809: NOT
100810: IFFALSE 100814
// continue ;
100812: GO 99313
// if f_ignore_area then
100814: LD_VAR 0 17
100818: IFFALSE 100906
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100820: LD_ADDR_VAR 0 15
100824: PUSH
100825: LD_VAR 0 14
100829: PPUSH
100830: LD_INT 3
100832: PUSH
100833: LD_INT 92
100835: PUSH
100836: LD_VAR 0 17
100840: PUSH
100841: LD_INT 1
100843: ARRAY
100844: PUSH
100845: LD_VAR 0 17
100849: PUSH
100850: LD_INT 2
100852: ARRAY
100853: PUSH
100854: LD_VAR 0 17
100858: PUSH
100859: LD_INT 3
100861: ARRAY
100862: PUSH
100863: EMPTY
100864: LIST
100865: LIST
100866: LIST
100867: LIST
100868: PUSH
100869: EMPTY
100870: LIST
100871: LIST
100872: PPUSH
100873: CALL_OW 72
100877: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100878: LD_VAR 0 14
100882: PUSH
100883: LD_VAR 0 15
100887: DIFF
100888: IFFALSE 100906
// tmp := tmp diff tmp2 ;
100890: LD_ADDR_VAR 0 14
100894: PUSH
100895: LD_VAR 0 14
100899: PUSH
100900: LD_VAR 0 15
100904: DIFF
100905: ST_TO_ADDR
// end ; if not f_murder then
100906: LD_VAR 0 20
100910: NOT
100911: IFFALSE 100969
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100913: LD_ADDR_VAR 0 15
100917: PUSH
100918: LD_VAR 0 14
100922: PPUSH
100923: LD_INT 3
100925: PUSH
100926: LD_INT 50
100928: PUSH
100929: EMPTY
100930: LIST
100931: PUSH
100932: EMPTY
100933: LIST
100934: LIST
100935: PPUSH
100936: CALL_OW 72
100940: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100941: LD_VAR 0 14
100945: PUSH
100946: LD_VAR 0 15
100950: DIFF
100951: IFFALSE 100969
// tmp := tmp diff tmp2 ;
100953: LD_ADDR_VAR 0 14
100957: PUSH
100958: LD_VAR 0 14
100962: PUSH
100963: LD_VAR 0 15
100967: DIFF
100968: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
100969: LD_ADDR_VAR 0 14
100973: PUSH
100974: LD_VAR 0 4
100978: PUSH
100979: LD_VAR 0 7
100983: ARRAY
100984: PPUSH
100985: LD_VAR 0 14
100989: PPUSH
100990: LD_INT 1
100992: PPUSH
100993: LD_INT 1
100995: PPUSH
100996: CALL 19698 0 4
101000: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
101001: LD_VAR 0 4
101005: PUSH
101006: LD_VAR 0 7
101010: ARRAY
101011: PPUSH
101012: CALL_OW 257
101016: PUSH
101017: LD_INT 1
101019: EQUAL
101020: IFFALSE 101468
// begin if WantPlant ( group [ i ] ) then
101022: LD_VAR 0 4
101026: PUSH
101027: LD_VAR 0 7
101031: ARRAY
101032: PPUSH
101033: CALL 19199 0 1
101037: IFFALSE 101041
// continue ;
101039: GO 99313
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
101041: LD_VAR 0 18
101045: PUSH
101046: LD_VAR 0 4
101050: PUSH
101051: LD_VAR 0 7
101055: ARRAY
101056: PPUSH
101057: CALL_OW 310
101061: NOT
101062: AND
101063: PUSH
101064: LD_VAR 0 14
101068: PUSH
101069: LD_INT 1
101071: ARRAY
101072: PUSH
101073: LD_VAR 0 14
101077: PPUSH
101078: LD_INT 21
101080: PUSH
101081: LD_INT 2
101083: PUSH
101084: EMPTY
101085: LIST
101086: LIST
101087: PUSH
101088: LD_INT 58
101090: PUSH
101091: EMPTY
101092: LIST
101093: PUSH
101094: EMPTY
101095: LIST
101096: LIST
101097: PPUSH
101098: CALL_OW 72
101102: IN
101103: AND
101104: IFFALSE 101140
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
101106: LD_VAR 0 4
101110: PUSH
101111: LD_VAR 0 7
101115: ARRAY
101116: PPUSH
101117: LD_VAR 0 14
101121: PUSH
101122: LD_INT 1
101124: ARRAY
101125: PPUSH
101126: CALL_OW 120
// attacking := true ;
101130: LD_ADDR_VAR 0 29
101134: PUSH
101135: LD_INT 1
101137: ST_TO_ADDR
// continue ;
101138: GO 99313
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
101140: LD_VAR 0 26
101144: PUSH
101145: LD_VAR 0 4
101149: PUSH
101150: LD_VAR 0 7
101154: ARRAY
101155: PPUSH
101156: CALL_OW 257
101160: PUSH
101161: LD_INT 1
101163: EQUAL
101164: AND
101165: PUSH
101166: LD_VAR 0 4
101170: PUSH
101171: LD_VAR 0 7
101175: ARRAY
101176: PPUSH
101177: CALL_OW 256
101181: PUSH
101182: LD_INT 800
101184: LESS
101185: AND
101186: PUSH
101187: LD_VAR 0 4
101191: PUSH
101192: LD_VAR 0 7
101196: ARRAY
101197: PPUSH
101198: CALL_OW 318
101202: NOT
101203: AND
101204: IFFALSE 101221
// ComCrawl ( group [ i ] ) ;
101206: LD_VAR 0 4
101210: PUSH
101211: LD_VAR 0 7
101215: ARRAY
101216: PPUSH
101217: CALL_OW 137
// if f_mines then
101221: LD_VAR 0 21
101225: IFFALSE 101468
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
101227: LD_VAR 0 14
101231: PUSH
101232: LD_INT 1
101234: ARRAY
101235: PPUSH
101236: CALL_OW 247
101240: PUSH
101241: LD_INT 3
101243: EQUAL
101244: PUSH
101245: LD_VAR 0 14
101249: PUSH
101250: LD_INT 1
101252: ARRAY
101253: PUSH
101254: LD_VAR 0 27
101258: IN
101259: NOT
101260: AND
101261: IFFALSE 101468
// begin x := GetX ( tmp [ 1 ] ) ;
101263: LD_ADDR_VAR 0 10
101267: PUSH
101268: LD_VAR 0 14
101272: PUSH
101273: LD_INT 1
101275: ARRAY
101276: PPUSH
101277: CALL_OW 250
101281: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
101282: LD_ADDR_VAR 0 11
101286: PUSH
101287: LD_VAR 0 14
101291: PUSH
101292: LD_INT 1
101294: ARRAY
101295: PPUSH
101296: CALL_OW 251
101300: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
101301: LD_ADDR_VAR 0 12
101305: PUSH
101306: LD_VAR 0 4
101310: PUSH
101311: LD_VAR 0 7
101315: ARRAY
101316: PPUSH
101317: CALL 46140 0 1
101321: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
101322: LD_VAR 0 4
101326: PUSH
101327: LD_VAR 0 7
101331: ARRAY
101332: PPUSH
101333: LD_VAR 0 10
101337: PPUSH
101338: LD_VAR 0 11
101342: PPUSH
101343: LD_VAR 0 14
101347: PUSH
101348: LD_INT 1
101350: ARRAY
101351: PPUSH
101352: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
101356: LD_VAR 0 4
101360: PUSH
101361: LD_VAR 0 7
101365: ARRAY
101366: PPUSH
101367: LD_VAR 0 10
101371: PPUSH
101372: LD_VAR 0 12
101376: PPUSH
101377: LD_INT 7
101379: PPUSH
101380: CALL_OW 272
101384: PPUSH
101385: LD_VAR 0 11
101389: PPUSH
101390: LD_VAR 0 12
101394: PPUSH
101395: LD_INT 7
101397: PPUSH
101398: CALL_OW 273
101402: PPUSH
101403: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
101407: LD_VAR 0 4
101411: PUSH
101412: LD_VAR 0 7
101416: ARRAY
101417: PPUSH
101418: LD_INT 71
101420: PPUSH
101421: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
101425: LD_ADDR_VAR 0 27
101429: PUSH
101430: LD_VAR 0 27
101434: PPUSH
101435: LD_VAR 0 27
101439: PUSH
101440: LD_INT 1
101442: PLUS
101443: PPUSH
101444: LD_VAR 0 14
101448: PUSH
101449: LD_INT 1
101451: ARRAY
101452: PPUSH
101453: CALL_OW 1
101457: ST_TO_ADDR
// attacking := true ;
101458: LD_ADDR_VAR 0 29
101462: PUSH
101463: LD_INT 1
101465: ST_TO_ADDR
// continue ;
101466: GO 99313
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
101468: LD_VAR 0 4
101472: PUSH
101473: LD_VAR 0 7
101477: ARRAY
101478: PPUSH
101479: CALL_OW 257
101483: PUSH
101484: LD_INT 17
101486: EQUAL
101487: PUSH
101488: LD_VAR 0 4
101492: PUSH
101493: LD_VAR 0 7
101497: ARRAY
101498: PPUSH
101499: CALL_OW 110
101503: PUSH
101504: LD_INT 71
101506: EQUAL
101507: NOT
101508: AND
101509: IFFALSE 101655
// begin attacking := false ;
101511: LD_ADDR_VAR 0 29
101515: PUSH
101516: LD_INT 0
101518: ST_TO_ADDR
// k := 5 ;
101519: LD_ADDR_VAR 0 9
101523: PUSH
101524: LD_INT 5
101526: ST_TO_ADDR
// if tmp < k then
101527: LD_VAR 0 14
101531: PUSH
101532: LD_VAR 0 9
101536: LESS
101537: IFFALSE 101549
// k := tmp ;
101539: LD_ADDR_VAR 0 9
101543: PUSH
101544: LD_VAR 0 14
101548: ST_TO_ADDR
// for j = 1 to k do
101549: LD_ADDR_VAR 0 8
101553: PUSH
101554: DOUBLE
101555: LD_INT 1
101557: DEC
101558: ST_TO_ADDR
101559: LD_VAR 0 9
101563: PUSH
101564: FOR_TO
101565: IFFALSE 101653
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
101567: LD_VAR 0 14
101571: PUSH
101572: LD_VAR 0 8
101576: ARRAY
101577: PUSH
101578: LD_VAR 0 14
101582: PPUSH
101583: LD_INT 58
101585: PUSH
101586: EMPTY
101587: LIST
101588: PPUSH
101589: CALL_OW 72
101593: IN
101594: NOT
101595: IFFALSE 101651
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101597: LD_VAR 0 4
101601: PUSH
101602: LD_VAR 0 7
101606: ARRAY
101607: PPUSH
101608: LD_VAR 0 14
101612: PUSH
101613: LD_VAR 0 8
101617: ARRAY
101618: PPUSH
101619: CALL_OW 115
// attacking := true ;
101623: LD_ADDR_VAR 0 29
101627: PUSH
101628: LD_INT 1
101630: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
101631: LD_VAR 0 4
101635: PUSH
101636: LD_VAR 0 7
101640: ARRAY
101641: PPUSH
101642: LD_INT 71
101644: PPUSH
101645: CALL_OW 109
// continue ;
101649: GO 101564
// end ; end ;
101651: GO 101564
101653: POP
101654: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
101655: LD_VAR 0 4
101659: PUSH
101660: LD_VAR 0 7
101664: ARRAY
101665: PPUSH
101666: CALL_OW 257
101670: PUSH
101671: LD_INT 8
101673: EQUAL
101674: PUSH
101675: LD_VAR 0 4
101679: PUSH
101680: LD_VAR 0 7
101684: ARRAY
101685: PPUSH
101686: CALL_OW 264
101690: PUSH
101691: LD_INT 28
101693: PUSH
101694: LD_INT 45
101696: PUSH
101697: LD_INT 7
101699: PUSH
101700: LD_INT 47
101702: PUSH
101703: EMPTY
101704: LIST
101705: LIST
101706: LIST
101707: LIST
101708: IN
101709: OR
101710: IFFALSE 101966
// begin attacking := false ;
101712: LD_ADDR_VAR 0 29
101716: PUSH
101717: LD_INT 0
101719: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101720: LD_VAR 0 14
101724: PUSH
101725: LD_INT 1
101727: ARRAY
101728: PPUSH
101729: CALL_OW 266
101733: PUSH
101734: LD_INT 32
101736: PUSH
101737: LD_INT 31
101739: PUSH
101740: LD_INT 33
101742: PUSH
101743: LD_INT 4
101745: PUSH
101746: LD_INT 5
101748: PUSH
101749: EMPTY
101750: LIST
101751: LIST
101752: LIST
101753: LIST
101754: LIST
101755: IN
101756: IFFALSE 101942
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101758: LD_ADDR_VAR 0 9
101762: PUSH
101763: LD_VAR 0 14
101767: PUSH
101768: LD_INT 1
101770: ARRAY
101771: PPUSH
101772: CALL_OW 266
101776: PPUSH
101777: LD_VAR 0 14
101781: PUSH
101782: LD_INT 1
101784: ARRAY
101785: PPUSH
101786: CALL_OW 250
101790: PPUSH
101791: LD_VAR 0 14
101795: PUSH
101796: LD_INT 1
101798: ARRAY
101799: PPUSH
101800: CALL_OW 251
101804: PPUSH
101805: LD_VAR 0 14
101809: PUSH
101810: LD_INT 1
101812: ARRAY
101813: PPUSH
101814: CALL_OW 254
101818: PPUSH
101819: LD_VAR 0 14
101823: PUSH
101824: LD_INT 1
101826: ARRAY
101827: PPUSH
101828: CALL_OW 248
101832: PPUSH
101833: LD_INT 0
101835: PPUSH
101836: CALL 27510 0 6
101840: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101841: LD_ADDR_VAR 0 8
101845: PUSH
101846: LD_VAR 0 4
101850: PUSH
101851: LD_VAR 0 7
101855: ARRAY
101856: PPUSH
101857: LD_VAR 0 9
101861: PPUSH
101862: CALL 46180 0 2
101866: ST_TO_ADDR
// if j then
101867: LD_VAR 0 8
101871: IFFALSE 101940
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101873: LD_VAR 0 8
101877: PUSH
101878: LD_INT 1
101880: ARRAY
101881: PPUSH
101882: LD_VAR 0 8
101886: PUSH
101887: LD_INT 2
101889: ARRAY
101890: PPUSH
101891: CALL_OW 488
101895: IFFALSE 101940
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101897: LD_VAR 0 4
101901: PUSH
101902: LD_VAR 0 7
101906: ARRAY
101907: PPUSH
101908: LD_VAR 0 8
101912: PUSH
101913: LD_INT 1
101915: ARRAY
101916: PPUSH
101917: LD_VAR 0 8
101921: PUSH
101922: LD_INT 2
101924: ARRAY
101925: PPUSH
101926: CALL_OW 116
// attacking := true ;
101930: LD_ADDR_VAR 0 29
101934: PUSH
101935: LD_INT 1
101937: ST_TO_ADDR
// continue ;
101938: GO 99313
// end ; end else
101940: GO 101966
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101942: LD_VAR 0 4
101946: PUSH
101947: LD_VAR 0 7
101951: ARRAY
101952: PPUSH
101953: LD_VAR 0 14
101957: PUSH
101958: LD_INT 1
101960: ARRAY
101961: PPUSH
101962: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
101966: LD_VAR 0 4
101970: PUSH
101971: LD_VAR 0 7
101975: ARRAY
101976: PPUSH
101977: CALL_OW 265
101981: PUSH
101982: LD_INT 11
101984: EQUAL
101985: IFFALSE 102263
// begin k := 10 ;
101987: LD_ADDR_VAR 0 9
101991: PUSH
101992: LD_INT 10
101994: ST_TO_ADDR
// x := 0 ;
101995: LD_ADDR_VAR 0 10
101999: PUSH
102000: LD_INT 0
102002: ST_TO_ADDR
// if tmp < k then
102003: LD_VAR 0 14
102007: PUSH
102008: LD_VAR 0 9
102012: LESS
102013: IFFALSE 102025
// k := tmp ;
102015: LD_ADDR_VAR 0 9
102019: PUSH
102020: LD_VAR 0 14
102024: ST_TO_ADDR
// for j = k downto 1 do
102025: LD_ADDR_VAR 0 8
102029: PUSH
102030: DOUBLE
102031: LD_VAR 0 9
102035: INC
102036: ST_TO_ADDR
102037: LD_INT 1
102039: PUSH
102040: FOR_DOWNTO
102041: IFFALSE 102116
// begin if GetType ( tmp [ j ] ) = unit_human then
102043: LD_VAR 0 14
102047: PUSH
102048: LD_VAR 0 8
102052: ARRAY
102053: PPUSH
102054: CALL_OW 247
102058: PUSH
102059: LD_INT 1
102061: EQUAL
102062: IFFALSE 102114
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
102064: LD_VAR 0 4
102068: PUSH
102069: LD_VAR 0 7
102073: ARRAY
102074: PPUSH
102075: LD_VAR 0 14
102079: PUSH
102080: LD_VAR 0 8
102084: ARRAY
102085: PPUSH
102086: CALL 46451 0 2
// x := tmp [ j ] ;
102090: LD_ADDR_VAR 0 10
102094: PUSH
102095: LD_VAR 0 14
102099: PUSH
102100: LD_VAR 0 8
102104: ARRAY
102105: ST_TO_ADDR
// attacking := true ;
102106: LD_ADDR_VAR 0 29
102110: PUSH
102111: LD_INT 1
102113: ST_TO_ADDR
// end ; end ;
102114: GO 102040
102116: POP
102117: POP
// if not x then
102118: LD_VAR 0 10
102122: NOT
102123: IFFALSE 102263
// begin attacking := true ;
102125: LD_ADDR_VAR 0 29
102129: PUSH
102130: LD_INT 1
102132: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
102133: LD_VAR 0 4
102137: PUSH
102138: LD_VAR 0 7
102142: ARRAY
102143: PPUSH
102144: CALL_OW 250
102148: PPUSH
102149: LD_VAR 0 4
102153: PUSH
102154: LD_VAR 0 7
102158: ARRAY
102159: PPUSH
102160: CALL_OW 251
102164: PPUSH
102165: CALL_OW 546
102169: PUSH
102170: LD_INT 2
102172: ARRAY
102173: PUSH
102174: LD_VAR 0 14
102178: PUSH
102179: LD_INT 1
102181: ARRAY
102182: PPUSH
102183: CALL_OW 250
102187: PPUSH
102188: LD_VAR 0 14
102192: PUSH
102193: LD_INT 1
102195: ARRAY
102196: PPUSH
102197: CALL_OW 251
102201: PPUSH
102202: CALL_OW 546
102206: PUSH
102207: LD_INT 2
102209: ARRAY
102210: EQUAL
102211: IFFALSE 102239
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
102213: LD_VAR 0 4
102217: PUSH
102218: LD_VAR 0 7
102222: ARRAY
102223: PPUSH
102224: LD_VAR 0 14
102228: PUSH
102229: LD_INT 1
102231: ARRAY
102232: PPUSH
102233: CALL 46451 0 2
102237: GO 102263
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102239: LD_VAR 0 4
102243: PUSH
102244: LD_VAR 0 7
102248: ARRAY
102249: PPUSH
102250: LD_VAR 0 14
102254: PUSH
102255: LD_INT 1
102257: ARRAY
102258: PPUSH
102259: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
102263: LD_VAR 0 4
102267: PUSH
102268: LD_VAR 0 7
102272: ARRAY
102273: PPUSH
102274: CALL_OW 264
102278: PUSH
102279: LD_INT 29
102281: EQUAL
102282: IFFALSE 102648
// begin if WantsToAttack ( group [ i ] ) in bombed then
102284: LD_VAR 0 4
102288: PUSH
102289: LD_VAR 0 7
102293: ARRAY
102294: PPUSH
102295: CALL_OW 319
102299: PUSH
102300: LD_VAR 0 28
102304: IN
102305: IFFALSE 102309
// continue ;
102307: GO 99313
// k := 8 ;
102309: LD_ADDR_VAR 0 9
102313: PUSH
102314: LD_INT 8
102316: ST_TO_ADDR
// x := 0 ;
102317: LD_ADDR_VAR 0 10
102321: PUSH
102322: LD_INT 0
102324: ST_TO_ADDR
// if tmp < k then
102325: LD_VAR 0 14
102329: PUSH
102330: LD_VAR 0 9
102334: LESS
102335: IFFALSE 102347
// k := tmp ;
102337: LD_ADDR_VAR 0 9
102341: PUSH
102342: LD_VAR 0 14
102346: ST_TO_ADDR
// for j = 1 to k do
102347: LD_ADDR_VAR 0 8
102351: PUSH
102352: DOUBLE
102353: LD_INT 1
102355: DEC
102356: ST_TO_ADDR
102357: LD_VAR 0 9
102361: PUSH
102362: FOR_TO
102363: IFFALSE 102495
// begin if GetType ( tmp [ j ] ) = unit_building then
102365: LD_VAR 0 14
102369: PUSH
102370: LD_VAR 0 8
102374: ARRAY
102375: PPUSH
102376: CALL_OW 247
102380: PUSH
102381: LD_INT 3
102383: EQUAL
102384: IFFALSE 102493
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
102386: LD_VAR 0 14
102390: PUSH
102391: LD_VAR 0 8
102395: ARRAY
102396: PUSH
102397: LD_VAR 0 28
102401: IN
102402: NOT
102403: PUSH
102404: LD_VAR 0 14
102408: PUSH
102409: LD_VAR 0 8
102413: ARRAY
102414: PPUSH
102415: CALL_OW 313
102419: AND
102420: IFFALSE 102493
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102422: LD_VAR 0 4
102426: PUSH
102427: LD_VAR 0 7
102431: ARRAY
102432: PPUSH
102433: LD_VAR 0 14
102437: PUSH
102438: LD_VAR 0 8
102442: ARRAY
102443: PPUSH
102444: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
102448: LD_ADDR_VAR 0 28
102452: PUSH
102453: LD_VAR 0 28
102457: PPUSH
102458: LD_VAR 0 28
102462: PUSH
102463: LD_INT 1
102465: PLUS
102466: PPUSH
102467: LD_VAR 0 14
102471: PUSH
102472: LD_VAR 0 8
102476: ARRAY
102477: PPUSH
102478: CALL_OW 1
102482: ST_TO_ADDR
// attacking := true ;
102483: LD_ADDR_VAR 0 29
102487: PUSH
102488: LD_INT 1
102490: ST_TO_ADDR
// break ;
102491: GO 102495
// end ; end ;
102493: GO 102362
102495: POP
102496: POP
// if not attacking and f_attack_depot then
102497: LD_VAR 0 29
102501: NOT
102502: PUSH
102503: LD_VAR 0 25
102507: AND
102508: IFFALSE 102603
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102510: LD_ADDR_VAR 0 13
102514: PUSH
102515: LD_VAR 0 14
102519: PPUSH
102520: LD_INT 2
102522: PUSH
102523: LD_INT 30
102525: PUSH
102526: LD_INT 0
102528: PUSH
102529: EMPTY
102530: LIST
102531: LIST
102532: PUSH
102533: LD_INT 30
102535: PUSH
102536: LD_INT 1
102538: PUSH
102539: EMPTY
102540: LIST
102541: LIST
102542: PUSH
102543: EMPTY
102544: LIST
102545: LIST
102546: LIST
102547: PPUSH
102548: CALL_OW 72
102552: ST_TO_ADDR
// if z then
102553: LD_VAR 0 13
102557: IFFALSE 102603
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
102559: LD_VAR 0 4
102563: PUSH
102564: LD_VAR 0 7
102568: ARRAY
102569: PPUSH
102570: LD_VAR 0 13
102574: PPUSH
102575: LD_VAR 0 4
102579: PUSH
102580: LD_VAR 0 7
102584: ARRAY
102585: PPUSH
102586: CALL_OW 74
102590: PPUSH
102591: CALL_OW 115
// attacking := true ;
102595: LD_ADDR_VAR 0 29
102599: PUSH
102600: LD_INT 1
102602: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
102603: LD_VAR 0 4
102607: PUSH
102608: LD_VAR 0 7
102612: ARRAY
102613: PPUSH
102614: CALL_OW 256
102618: PUSH
102619: LD_INT 500
102621: LESS
102622: IFFALSE 102648
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102624: LD_VAR 0 4
102628: PUSH
102629: LD_VAR 0 7
102633: ARRAY
102634: PPUSH
102635: LD_VAR 0 14
102639: PUSH
102640: LD_INT 1
102642: ARRAY
102643: PPUSH
102644: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
102648: LD_VAR 0 4
102652: PUSH
102653: LD_VAR 0 7
102657: ARRAY
102658: PPUSH
102659: CALL_OW 264
102663: PUSH
102664: LD_INT 49
102666: EQUAL
102667: IFFALSE 102788
// begin if not HasTask ( group [ i ] ) then
102669: LD_VAR 0 4
102673: PUSH
102674: LD_VAR 0 7
102678: ARRAY
102679: PPUSH
102680: CALL_OW 314
102684: NOT
102685: IFFALSE 102788
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
102687: LD_ADDR_VAR 0 9
102691: PUSH
102692: LD_INT 81
102694: PUSH
102695: LD_VAR 0 4
102699: PUSH
102700: LD_VAR 0 7
102704: ARRAY
102705: PPUSH
102706: CALL_OW 255
102710: PUSH
102711: EMPTY
102712: LIST
102713: LIST
102714: PPUSH
102715: CALL_OW 69
102719: PPUSH
102720: LD_VAR 0 4
102724: PUSH
102725: LD_VAR 0 7
102729: ARRAY
102730: PPUSH
102731: CALL_OW 74
102735: ST_TO_ADDR
// if k then
102736: LD_VAR 0 9
102740: IFFALSE 102788
// if GetDistUnits ( group [ i ] , k ) > 10 then
102742: LD_VAR 0 4
102746: PUSH
102747: LD_VAR 0 7
102751: ARRAY
102752: PPUSH
102753: LD_VAR 0 9
102757: PPUSH
102758: CALL_OW 296
102762: PUSH
102763: LD_INT 10
102765: GREATER
102766: IFFALSE 102788
// ComMoveUnit ( group [ i ] , k ) ;
102768: LD_VAR 0 4
102772: PUSH
102773: LD_VAR 0 7
102777: ARRAY
102778: PPUSH
102779: LD_VAR 0 9
102783: PPUSH
102784: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102788: LD_VAR 0 4
102792: PUSH
102793: LD_VAR 0 7
102797: ARRAY
102798: PPUSH
102799: CALL_OW 256
102803: PUSH
102804: LD_INT 250
102806: LESS
102807: PUSH
102808: LD_VAR 0 4
102812: PUSH
102813: LD_VAR 0 7
102817: ARRAY
102818: PUSH
102819: LD_INT 21
102821: PUSH
102822: LD_INT 2
102824: PUSH
102825: EMPTY
102826: LIST
102827: LIST
102828: PUSH
102829: LD_INT 23
102831: PUSH
102832: LD_INT 2
102834: PUSH
102835: EMPTY
102836: LIST
102837: LIST
102838: PUSH
102839: EMPTY
102840: LIST
102841: LIST
102842: PPUSH
102843: CALL_OW 69
102847: IN
102848: AND
102849: IFFALSE 102974
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102851: LD_ADDR_VAR 0 9
102855: PUSH
102856: LD_OWVAR 3
102860: PUSH
102861: LD_VAR 0 4
102865: PUSH
102866: LD_VAR 0 7
102870: ARRAY
102871: DIFF
102872: PPUSH
102873: LD_VAR 0 4
102877: PUSH
102878: LD_VAR 0 7
102882: ARRAY
102883: PPUSH
102884: CALL_OW 74
102888: ST_TO_ADDR
// if not k then
102889: LD_VAR 0 9
102893: NOT
102894: IFFALSE 102898
// continue ;
102896: GO 99313
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102898: LD_VAR 0 9
102902: PUSH
102903: LD_INT 81
102905: PUSH
102906: LD_VAR 0 4
102910: PUSH
102911: LD_VAR 0 7
102915: ARRAY
102916: PPUSH
102917: CALL_OW 255
102921: PUSH
102922: EMPTY
102923: LIST
102924: LIST
102925: PPUSH
102926: CALL_OW 69
102930: IN
102931: PUSH
102932: LD_VAR 0 9
102936: PPUSH
102937: LD_VAR 0 4
102941: PUSH
102942: LD_VAR 0 7
102946: ARRAY
102947: PPUSH
102948: CALL_OW 296
102952: PUSH
102953: LD_INT 5
102955: LESS
102956: AND
102957: IFFALSE 102974
// ComAutodestruct ( group [ i ] ) ;
102959: LD_VAR 0 4
102963: PUSH
102964: LD_VAR 0 7
102968: ARRAY
102969: PPUSH
102970: CALL 46349 0 1
// end ; if f_attack_depot then
102974: LD_VAR 0 25
102978: IFFALSE 103090
// begin k := 6 ;
102980: LD_ADDR_VAR 0 9
102984: PUSH
102985: LD_INT 6
102987: ST_TO_ADDR
// if tmp < k then
102988: LD_VAR 0 14
102992: PUSH
102993: LD_VAR 0 9
102997: LESS
102998: IFFALSE 103010
// k := tmp ;
103000: LD_ADDR_VAR 0 9
103004: PUSH
103005: LD_VAR 0 14
103009: ST_TO_ADDR
// for j = 1 to k do
103010: LD_ADDR_VAR 0 8
103014: PUSH
103015: DOUBLE
103016: LD_INT 1
103018: DEC
103019: ST_TO_ADDR
103020: LD_VAR 0 9
103024: PUSH
103025: FOR_TO
103026: IFFALSE 103088
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
103028: LD_VAR 0 8
103032: PPUSH
103033: CALL_OW 266
103037: PUSH
103038: LD_INT 0
103040: PUSH
103041: LD_INT 1
103043: PUSH
103044: EMPTY
103045: LIST
103046: LIST
103047: IN
103048: IFFALSE 103086
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103050: LD_VAR 0 4
103054: PUSH
103055: LD_VAR 0 7
103059: ARRAY
103060: PPUSH
103061: LD_VAR 0 14
103065: PUSH
103066: LD_VAR 0 8
103070: ARRAY
103071: PPUSH
103072: CALL_OW 115
// attacking := true ;
103076: LD_ADDR_VAR 0 29
103080: PUSH
103081: LD_INT 1
103083: ST_TO_ADDR
// break ;
103084: GO 103088
// end ;
103086: GO 103025
103088: POP
103089: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
103090: LD_VAR 0 4
103094: PUSH
103095: LD_VAR 0 7
103099: ARRAY
103100: PPUSH
103101: CALL_OW 302
103105: PUSH
103106: LD_VAR 0 29
103110: NOT
103111: AND
103112: IFFALSE 103434
// begin if GetTag ( group [ i ] ) = 71 then
103114: LD_VAR 0 4
103118: PUSH
103119: LD_VAR 0 7
103123: ARRAY
103124: PPUSH
103125: CALL_OW 110
103129: PUSH
103130: LD_INT 71
103132: EQUAL
103133: IFFALSE 103174
// begin if HasTask ( group [ i ] ) then
103135: LD_VAR 0 4
103139: PUSH
103140: LD_VAR 0 7
103144: ARRAY
103145: PPUSH
103146: CALL_OW 314
103150: IFFALSE 103156
// continue else
103152: GO 99313
103154: GO 103174
// SetTag ( group [ i ] , 0 ) ;
103156: LD_VAR 0 4
103160: PUSH
103161: LD_VAR 0 7
103165: ARRAY
103166: PPUSH
103167: LD_INT 0
103169: PPUSH
103170: CALL_OW 109
// end ; k := 8 ;
103174: LD_ADDR_VAR 0 9
103178: PUSH
103179: LD_INT 8
103181: ST_TO_ADDR
// x := 0 ;
103182: LD_ADDR_VAR 0 10
103186: PUSH
103187: LD_INT 0
103189: ST_TO_ADDR
// if tmp < k then
103190: LD_VAR 0 14
103194: PUSH
103195: LD_VAR 0 9
103199: LESS
103200: IFFALSE 103212
// k := tmp ;
103202: LD_ADDR_VAR 0 9
103206: PUSH
103207: LD_VAR 0 14
103211: ST_TO_ADDR
// for j = 1 to k do
103212: LD_ADDR_VAR 0 8
103216: PUSH
103217: DOUBLE
103218: LD_INT 1
103220: DEC
103221: ST_TO_ADDR
103222: LD_VAR 0 9
103226: PUSH
103227: FOR_TO
103228: IFFALSE 103326
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
103230: LD_VAR 0 14
103234: PUSH
103235: LD_VAR 0 8
103239: ARRAY
103240: PPUSH
103241: CALL_OW 247
103245: PUSH
103246: LD_INT 1
103248: EQUAL
103249: PUSH
103250: LD_VAR 0 14
103254: PUSH
103255: LD_VAR 0 8
103259: ARRAY
103260: PPUSH
103261: CALL_OW 256
103265: PUSH
103266: LD_INT 250
103268: LESS
103269: PUSH
103270: LD_VAR 0 20
103274: AND
103275: PUSH
103276: LD_VAR 0 20
103280: NOT
103281: PUSH
103282: LD_VAR 0 14
103286: PUSH
103287: LD_VAR 0 8
103291: ARRAY
103292: PPUSH
103293: CALL_OW 256
103297: PUSH
103298: LD_INT 250
103300: GREATEREQUAL
103301: AND
103302: OR
103303: AND
103304: IFFALSE 103324
// begin x := tmp [ j ] ;
103306: LD_ADDR_VAR 0 10
103310: PUSH
103311: LD_VAR 0 14
103315: PUSH
103316: LD_VAR 0 8
103320: ARRAY
103321: ST_TO_ADDR
// break ;
103322: GO 103326
// end ;
103324: GO 103227
103326: POP
103327: POP
// if x then
103328: LD_VAR 0 10
103332: IFFALSE 103356
// ComAttackUnit ( group [ i ] , x ) else
103334: LD_VAR 0 4
103338: PUSH
103339: LD_VAR 0 7
103343: ARRAY
103344: PPUSH
103345: LD_VAR 0 10
103349: PPUSH
103350: CALL_OW 115
103354: GO 103380
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103356: LD_VAR 0 4
103360: PUSH
103361: LD_VAR 0 7
103365: ARRAY
103366: PPUSH
103367: LD_VAR 0 14
103371: PUSH
103372: LD_INT 1
103374: ARRAY
103375: PPUSH
103376: CALL_OW 115
// if not HasTask ( group [ i ] ) then
103380: LD_VAR 0 4
103384: PUSH
103385: LD_VAR 0 7
103389: ARRAY
103390: PPUSH
103391: CALL_OW 314
103395: NOT
103396: IFFALSE 103434
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
103398: LD_VAR 0 4
103402: PUSH
103403: LD_VAR 0 7
103407: ARRAY
103408: PPUSH
103409: LD_VAR 0 14
103413: PPUSH
103414: LD_VAR 0 4
103418: PUSH
103419: LD_VAR 0 7
103423: ARRAY
103424: PPUSH
103425: CALL_OW 74
103429: PPUSH
103430: CALL_OW 115
// end ; end ; end ;
103434: GO 99313
103436: POP
103437: POP
// wait ( 0 0$2 ) ;
103438: LD_INT 70
103440: PPUSH
103441: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
103445: LD_VAR 0 4
103449: NOT
103450: PUSH
103451: LD_VAR 0 4
103455: PUSH
103456: EMPTY
103457: EQUAL
103458: OR
103459: PUSH
103460: LD_INT 81
103462: PUSH
103463: LD_VAR 0 35
103467: PUSH
103468: EMPTY
103469: LIST
103470: LIST
103471: PPUSH
103472: CALL_OW 69
103476: NOT
103477: OR
103478: IFFALSE 99298
// end ;
103480: LD_VAR 0 2
103484: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
103485: LD_INT 0
103487: PPUSH
103488: PPUSH
103489: PPUSH
103490: PPUSH
103491: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
103492: LD_VAR 0 1
103496: NOT
103497: PUSH
103498: LD_EXP 59
103502: PUSH
103503: LD_VAR 0 1
103507: ARRAY
103508: NOT
103509: OR
103510: PUSH
103511: LD_VAR 0 2
103515: NOT
103516: OR
103517: PUSH
103518: LD_VAR 0 3
103522: NOT
103523: OR
103524: IFFALSE 103528
// exit ;
103526: GO 104041
// side := mc_sides [ base ] ;
103528: LD_ADDR_VAR 0 6
103532: PUSH
103533: LD_EXP 85
103537: PUSH
103538: LD_VAR 0 1
103542: ARRAY
103543: ST_TO_ADDR
// if not side then
103544: LD_VAR 0 6
103548: NOT
103549: IFFALSE 103553
// exit ;
103551: GO 104041
// for i in solds do
103553: LD_ADDR_VAR 0 7
103557: PUSH
103558: LD_VAR 0 2
103562: PUSH
103563: FOR_IN
103564: IFFALSE 103625
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
103566: LD_VAR 0 7
103570: PPUSH
103571: CALL_OW 310
103575: PPUSH
103576: CALL_OW 266
103580: PUSH
103581: LD_INT 32
103583: PUSH
103584: LD_INT 31
103586: PUSH
103587: EMPTY
103588: LIST
103589: LIST
103590: IN
103591: IFFALSE 103611
// solds := solds diff i else
103593: LD_ADDR_VAR 0 2
103597: PUSH
103598: LD_VAR 0 2
103602: PUSH
103603: LD_VAR 0 7
103607: DIFF
103608: ST_TO_ADDR
103609: GO 103623
// SetTag ( i , 18 ) ;
103611: LD_VAR 0 7
103615: PPUSH
103616: LD_INT 18
103618: PPUSH
103619: CALL_OW 109
103623: GO 103563
103625: POP
103626: POP
// if not solds then
103627: LD_VAR 0 2
103631: NOT
103632: IFFALSE 103636
// exit ;
103634: GO 104041
// repeat wait ( 0 0$2 ) ;
103636: LD_INT 70
103638: PPUSH
103639: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
103643: LD_ADDR_VAR 0 5
103647: PUSH
103648: LD_VAR 0 6
103652: PPUSH
103653: LD_VAR 0 3
103657: PPUSH
103658: CALL 16064 0 2
103662: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
103663: LD_EXP 59
103667: PUSH
103668: LD_VAR 0 1
103672: ARRAY
103673: NOT
103674: PUSH
103675: LD_EXP 59
103679: PUSH
103680: LD_VAR 0 1
103684: ARRAY
103685: PUSH
103686: EMPTY
103687: EQUAL
103688: OR
103689: IFFALSE 103726
// begin for i in solds do
103691: LD_ADDR_VAR 0 7
103695: PUSH
103696: LD_VAR 0 2
103700: PUSH
103701: FOR_IN
103702: IFFALSE 103715
// ComStop ( i ) ;
103704: LD_VAR 0 7
103708: PPUSH
103709: CALL_OW 141
103713: GO 103701
103715: POP
103716: POP
// solds := [ ] ;
103717: LD_ADDR_VAR 0 2
103721: PUSH
103722: EMPTY
103723: ST_TO_ADDR
// exit ;
103724: GO 104041
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
103726: LD_VAR 0 5
103730: NOT
103731: PUSH
103732: LD_VAR 0 5
103736: PUSH
103737: LD_INT 3
103739: GREATER
103740: OR
103741: PUSH
103742: LD_EXP 81
103746: PUSH
103747: LD_VAR 0 1
103751: ARRAY
103752: OR
103753: IFFALSE 103794
// begin for i in solds do
103755: LD_ADDR_VAR 0 7
103759: PUSH
103760: LD_VAR 0 2
103764: PUSH
103765: FOR_IN
103766: IFFALSE 103790
// if HasTask ( i ) then
103768: LD_VAR 0 7
103772: PPUSH
103773: CALL_OW 314
103777: IFFALSE 103788
// ComStop ( i ) ;
103779: LD_VAR 0 7
103783: PPUSH
103784: CALL_OW 141
103788: GO 103765
103790: POP
103791: POP
// break ;
103792: GO 104029
// end ; for i in solds do
103794: LD_ADDR_VAR 0 7
103798: PUSH
103799: LD_VAR 0 2
103803: PUSH
103804: FOR_IN
103805: IFFALSE 104021
// begin if IsInUnit ( i ) then
103807: LD_VAR 0 7
103811: PPUSH
103812: CALL_OW 310
103816: IFFALSE 103827
// ComExitBuilding ( i ) ;
103818: LD_VAR 0 7
103822: PPUSH
103823: CALL_OW 122
// if GetLives ( i ) > 333 then
103827: LD_VAR 0 7
103831: PPUSH
103832: CALL_OW 256
103836: PUSH
103837: LD_INT 333
103839: GREATER
103840: IFFALSE 103868
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103842: LD_VAR 0 7
103846: PPUSH
103847: LD_VAR 0 5
103851: PPUSH
103852: LD_VAR 0 7
103856: PPUSH
103857: CALL_OW 74
103861: PPUSH
103862: CALL_OW 115
103866: GO 104019
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
103868: LD_ADDR_VAR 0 8
103872: PUSH
103873: LD_EXP 59
103877: PUSH
103878: LD_VAR 0 1
103882: ARRAY
103883: PPUSH
103884: LD_INT 2
103886: PUSH
103887: LD_INT 30
103889: PUSH
103890: LD_INT 0
103892: PUSH
103893: EMPTY
103894: LIST
103895: LIST
103896: PUSH
103897: LD_INT 30
103899: PUSH
103900: LD_INT 1
103902: PUSH
103903: EMPTY
103904: LIST
103905: LIST
103906: PUSH
103907: LD_INT 30
103909: PUSH
103910: LD_INT 6
103912: PUSH
103913: EMPTY
103914: LIST
103915: LIST
103916: PUSH
103917: EMPTY
103918: LIST
103919: LIST
103920: LIST
103921: LIST
103922: PPUSH
103923: CALL_OW 72
103927: PPUSH
103928: LD_VAR 0 7
103932: PPUSH
103933: CALL_OW 74
103937: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
103938: LD_VAR 0 7
103942: PPUSH
103943: LD_VAR 0 8
103947: PPUSH
103948: CALL_OW 250
103952: PPUSH
103953: LD_INT 3
103955: PPUSH
103956: LD_INT 5
103958: PPUSH
103959: CALL_OW 272
103963: PPUSH
103964: LD_VAR 0 8
103968: PPUSH
103969: CALL_OW 251
103973: PPUSH
103974: LD_INT 3
103976: PPUSH
103977: LD_INT 5
103979: PPUSH
103980: CALL_OW 273
103984: PPUSH
103985: CALL_OW 111
// SetTag ( i , 0 ) ;
103989: LD_VAR 0 7
103993: PPUSH
103994: LD_INT 0
103996: PPUSH
103997: CALL_OW 109
// solds := solds diff i ;
104001: LD_ADDR_VAR 0 2
104005: PUSH
104006: LD_VAR 0 2
104010: PUSH
104011: LD_VAR 0 7
104015: DIFF
104016: ST_TO_ADDR
// continue ;
104017: GO 103804
// end ; end ;
104019: GO 103804
104021: POP
104022: POP
// until solds ;
104023: LD_VAR 0 2
104027: IFFALSE 103636
// MC_Reset ( base , 18 ) ;
104029: LD_VAR 0 1
104033: PPUSH
104034: LD_INT 18
104036: PPUSH
104037: CALL 55464 0 2
// end ;
104041: LD_VAR 0 4
104045: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
104046: LD_INT 0
104048: PPUSH
104049: PPUSH
104050: PPUSH
104051: PPUSH
104052: PPUSH
104053: PPUSH
104054: PPUSH
104055: PPUSH
104056: PPUSH
104057: PPUSH
104058: PPUSH
104059: PPUSH
104060: PPUSH
104061: PPUSH
104062: PPUSH
104063: PPUSH
104064: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
104065: LD_ADDR_VAR 0 13
104069: PUSH
104070: LD_EXP 59
104074: PUSH
104075: LD_VAR 0 1
104079: ARRAY
104080: PPUSH
104081: LD_INT 25
104083: PUSH
104084: LD_INT 3
104086: PUSH
104087: EMPTY
104088: LIST
104089: LIST
104090: PPUSH
104091: CALL_OW 72
104095: ST_TO_ADDR
// if mc_remote_driver [ base ] then
104096: LD_EXP 99
104100: PUSH
104101: LD_VAR 0 1
104105: ARRAY
104106: IFFALSE 104130
// mechs := mechs diff mc_remote_driver [ base ] ;
104108: LD_ADDR_VAR 0 13
104112: PUSH
104113: LD_VAR 0 13
104117: PUSH
104118: LD_EXP 99
104122: PUSH
104123: LD_VAR 0 1
104127: ARRAY
104128: DIFF
104129: ST_TO_ADDR
// for i in mechs do
104130: LD_ADDR_VAR 0 5
104134: PUSH
104135: LD_VAR 0 13
104139: PUSH
104140: FOR_IN
104141: IFFALSE 104176
// if GetTag ( i ) > 0 then
104143: LD_VAR 0 5
104147: PPUSH
104148: CALL_OW 110
104152: PUSH
104153: LD_INT 0
104155: GREATER
104156: IFFALSE 104174
// mechs := mechs diff i ;
104158: LD_ADDR_VAR 0 13
104162: PUSH
104163: LD_VAR 0 13
104167: PUSH
104168: LD_VAR 0 5
104172: DIFF
104173: ST_TO_ADDR
104174: GO 104140
104176: POP
104177: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104178: LD_ADDR_VAR 0 9
104182: PUSH
104183: LD_EXP 59
104187: PUSH
104188: LD_VAR 0 1
104192: ARRAY
104193: PPUSH
104194: LD_INT 2
104196: PUSH
104197: LD_INT 25
104199: PUSH
104200: LD_INT 1
104202: PUSH
104203: EMPTY
104204: LIST
104205: LIST
104206: PUSH
104207: LD_INT 25
104209: PUSH
104210: LD_INT 5
104212: PUSH
104213: EMPTY
104214: LIST
104215: LIST
104216: PUSH
104217: LD_INT 25
104219: PUSH
104220: LD_INT 8
104222: PUSH
104223: EMPTY
104224: LIST
104225: LIST
104226: PUSH
104227: LD_INT 25
104229: PUSH
104230: LD_INT 9
104232: PUSH
104233: EMPTY
104234: LIST
104235: LIST
104236: PUSH
104237: EMPTY
104238: LIST
104239: LIST
104240: LIST
104241: LIST
104242: LIST
104243: PPUSH
104244: CALL_OW 72
104248: ST_TO_ADDR
// if not defenders and not solds then
104249: LD_VAR 0 2
104253: NOT
104254: PUSH
104255: LD_VAR 0 9
104259: NOT
104260: AND
104261: IFFALSE 104265
// exit ;
104263: GO 105955
// depot_under_attack := false ;
104265: LD_ADDR_VAR 0 17
104269: PUSH
104270: LD_INT 0
104272: ST_TO_ADDR
// sold_defenders := [ ] ;
104273: LD_ADDR_VAR 0 18
104277: PUSH
104278: EMPTY
104279: ST_TO_ADDR
// if mechs then
104280: LD_VAR 0 13
104284: IFFALSE 104437
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
104286: LD_ADDR_VAR 0 5
104290: PUSH
104291: LD_VAR 0 2
104295: PPUSH
104296: LD_INT 21
104298: PUSH
104299: LD_INT 2
104301: PUSH
104302: EMPTY
104303: LIST
104304: LIST
104305: PPUSH
104306: CALL_OW 72
104310: PUSH
104311: FOR_IN
104312: IFFALSE 104435
// begin if GetTag ( i ) <> 20 then
104314: LD_VAR 0 5
104318: PPUSH
104319: CALL_OW 110
104323: PUSH
104324: LD_INT 20
104326: NONEQUAL
104327: IFFALSE 104341
// SetTag ( i , 20 ) ;
104329: LD_VAR 0 5
104333: PPUSH
104334: LD_INT 20
104336: PPUSH
104337: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
104341: LD_VAR 0 5
104345: PPUSH
104346: CALL_OW 263
104350: PUSH
104351: LD_INT 1
104353: EQUAL
104354: PUSH
104355: LD_VAR 0 5
104359: PPUSH
104360: CALL_OW 311
104364: NOT
104365: AND
104366: IFFALSE 104433
// begin un := mechs [ 1 ] ;
104368: LD_ADDR_VAR 0 11
104372: PUSH
104373: LD_VAR 0 13
104377: PUSH
104378: LD_INT 1
104380: ARRAY
104381: ST_TO_ADDR
// ComExit ( un ) ;
104382: LD_VAR 0 11
104386: PPUSH
104387: CALL 50694 0 1
// AddComEnterUnit ( un , i ) ;
104391: LD_VAR 0 11
104395: PPUSH
104396: LD_VAR 0 5
104400: PPUSH
104401: CALL_OW 180
// SetTag ( un , 19 ) ;
104405: LD_VAR 0 11
104409: PPUSH
104410: LD_INT 19
104412: PPUSH
104413: CALL_OW 109
// mechs := mechs diff un ;
104417: LD_ADDR_VAR 0 13
104421: PUSH
104422: LD_VAR 0 13
104426: PUSH
104427: LD_VAR 0 11
104431: DIFF
104432: ST_TO_ADDR
// end ; end ;
104433: GO 104311
104435: POP
104436: POP
// if solds then
104437: LD_VAR 0 9
104441: IFFALSE 104500
// for i in solds do
104443: LD_ADDR_VAR 0 5
104447: PUSH
104448: LD_VAR 0 9
104452: PUSH
104453: FOR_IN
104454: IFFALSE 104498
// if not GetTag ( i ) then
104456: LD_VAR 0 5
104460: PPUSH
104461: CALL_OW 110
104465: NOT
104466: IFFALSE 104496
// begin defenders := defenders union i ;
104468: LD_ADDR_VAR 0 2
104472: PUSH
104473: LD_VAR 0 2
104477: PUSH
104478: LD_VAR 0 5
104482: UNION
104483: ST_TO_ADDR
// SetTag ( i , 18 ) ;
104484: LD_VAR 0 5
104488: PPUSH
104489: LD_INT 18
104491: PPUSH
104492: CALL_OW 109
// end ;
104496: GO 104453
104498: POP
104499: POP
// repeat wait ( 0 0$2 ) ;
104500: LD_INT 70
104502: PPUSH
104503: CALL_OW 67
// enemy := mc_scan [ base ] ;
104507: LD_ADDR_VAR 0 3
104511: PUSH
104512: LD_EXP 82
104516: PUSH
104517: LD_VAR 0 1
104521: ARRAY
104522: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104523: LD_EXP 59
104527: PUSH
104528: LD_VAR 0 1
104532: ARRAY
104533: NOT
104534: PUSH
104535: LD_EXP 59
104539: PUSH
104540: LD_VAR 0 1
104544: ARRAY
104545: PUSH
104546: EMPTY
104547: EQUAL
104548: OR
104549: IFFALSE 104586
// begin for i in defenders do
104551: LD_ADDR_VAR 0 5
104555: PUSH
104556: LD_VAR 0 2
104560: PUSH
104561: FOR_IN
104562: IFFALSE 104575
// ComStop ( i ) ;
104564: LD_VAR 0 5
104568: PPUSH
104569: CALL_OW 141
104573: GO 104561
104575: POP
104576: POP
// defenders := [ ] ;
104577: LD_ADDR_VAR 0 2
104581: PUSH
104582: EMPTY
104583: ST_TO_ADDR
// exit ;
104584: GO 105955
// end ; for i in defenders do
104586: LD_ADDR_VAR 0 5
104590: PUSH
104591: LD_VAR 0 2
104595: PUSH
104596: FOR_IN
104597: IFFALSE 105415
// begin e := NearestUnitToUnit ( enemy , i ) ;
104599: LD_ADDR_VAR 0 14
104603: PUSH
104604: LD_VAR 0 3
104608: PPUSH
104609: LD_VAR 0 5
104613: PPUSH
104614: CALL_OW 74
104618: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104619: LD_ADDR_VAR 0 8
104623: PUSH
104624: LD_EXP 59
104628: PUSH
104629: LD_VAR 0 1
104633: ARRAY
104634: PPUSH
104635: LD_INT 2
104637: PUSH
104638: LD_INT 30
104640: PUSH
104641: LD_INT 0
104643: PUSH
104644: EMPTY
104645: LIST
104646: LIST
104647: PUSH
104648: LD_INT 30
104650: PUSH
104651: LD_INT 1
104653: PUSH
104654: EMPTY
104655: LIST
104656: LIST
104657: PUSH
104658: EMPTY
104659: LIST
104660: LIST
104661: LIST
104662: PPUSH
104663: CALL_OW 72
104667: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
104668: LD_ADDR_VAR 0 17
104672: PUSH
104673: LD_VAR 0 8
104677: NOT
104678: PUSH
104679: LD_VAR 0 8
104683: PPUSH
104684: LD_INT 3
104686: PUSH
104687: LD_INT 24
104689: PUSH
104690: LD_INT 600
104692: PUSH
104693: EMPTY
104694: LIST
104695: LIST
104696: PUSH
104697: EMPTY
104698: LIST
104699: LIST
104700: PPUSH
104701: CALL_OW 72
104705: OR
104706: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
104707: LD_VAR 0 5
104711: PPUSH
104712: CALL_OW 247
104716: PUSH
104717: LD_INT 2
104719: DOUBLE
104720: EQUAL
104721: IFTRUE 104725
104723: GO 105121
104725: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
104726: LD_VAR 0 5
104730: PPUSH
104731: CALL_OW 256
104735: PUSH
104736: LD_INT 650
104738: GREATER
104739: PUSH
104740: LD_VAR 0 5
104744: PPUSH
104745: LD_VAR 0 14
104749: PPUSH
104750: CALL_OW 296
104754: PUSH
104755: LD_INT 40
104757: LESS
104758: PUSH
104759: LD_VAR 0 14
104763: PPUSH
104764: LD_EXP 84
104768: PUSH
104769: LD_VAR 0 1
104773: ARRAY
104774: PPUSH
104775: CALL_OW 308
104779: OR
104780: AND
104781: IFFALSE 104903
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
104783: LD_VAR 0 5
104787: PPUSH
104788: CALL_OW 262
104792: PUSH
104793: LD_INT 1
104795: EQUAL
104796: PUSH
104797: LD_VAR 0 5
104801: PPUSH
104802: CALL_OW 261
104806: PUSH
104807: LD_INT 30
104809: LESS
104810: AND
104811: PUSH
104812: LD_VAR 0 8
104816: AND
104817: IFFALSE 104887
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
104819: LD_VAR 0 5
104823: PPUSH
104824: LD_VAR 0 8
104828: PPUSH
104829: LD_VAR 0 5
104833: PPUSH
104834: CALL_OW 74
104838: PPUSH
104839: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
104843: LD_VAR 0 5
104847: PPUSH
104848: LD_VAR 0 8
104852: PPUSH
104853: LD_VAR 0 5
104857: PPUSH
104858: CALL_OW 74
104862: PPUSH
104863: CALL_OW 296
104867: PUSH
104868: LD_INT 6
104870: LESS
104871: IFFALSE 104885
// SetFuel ( i , 100 ) ;
104873: LD_VAR 0 5
104877: PPUSH
104878: LD_INT 100
104880: PPUSH
104881: CALL_OW 240
// end else
104885: GO 104901
// ComAttackUnit ( i , e ) ;
104887: LD_VAR 0 5
104891: PPUSH
104892: LD_VAR 0 14
104896: PPUSH
104897: CALL_OW 115
// end else
104901: GO 105004
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
104903: LD_VAR 0 14
104907: PPUSH
104908: LD_EXP 84
104912: PUSH
104913: LD_VAR 0 1
104917: ARRAY
104918: PPUSH
104919: CALL_OW 308
104923: NOT
104924: PUSH
104925: LD_VAR 0 5
104929: PPUSH
104930: LD_VAR 0 14
104934: PPUSH
104935: CALL_OW 296
104939: PUSH
104940: LD_INT 40
104942: GREATEREQUAL
104943: AND
104944: PUSH
104945: LD_VAR 0 5
104949: PPUSH
104950: CALL_OW 256
104954: PUSH
104955: LD_INT 650
104957: LESSEQUAL
104958: OR
104959: PUSH
104960: LD_VAR 0 5
104964: PPUSH
104965: LD_EXP 83
104969: PUSH
104970: LD_VAR 0 1
104974: ARRAY
104975: PPUSH
104976: CALL_OW 308
104980: NOT
104981: AND
104982: IFFALSE 105004
// ComMoveToArea ( i , mc_parking [ base ] ) ;
104984: LD_VAR 0 5
104988: PPUSH
104989: LD_EXP 83
104993: PUSH
104994: LD_VAR 0 1
104998: ARRAY
104999: PPUSH
105000: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
105004: LD_VAR 0 5
105008: PPUSH
105009: CALL_OW 256
105013: PUSH
105014: LD_INT 998
105016: LESS
105017: PUSH
105018: LD_VAR 0 5
105022: PPUSH
105023: CALL_OW 263
105027: PUSH
105028: LD_INT 1
105030: EQUAL
105031: AND
105032: PUSH
105033: LD_VAR 0 5
105037: PPUSH
105038: CALL_OW 311
105042: AND
105043: PUSH
105044: LD_VAR 0 5
105048: PPUSH
105049: LD_EXP 83
105053: PUSH
105054: LD_VAR 0 1
105058: ARRAY
105059: PPUSH
105060: CALL_OW 308
105064: AND
105065: IFFALSE 105119
// begin mech := IsDrivenBy ( i ) ;
105067: LD_ADDR_VAR 0 10
105071: PUSH
105072: LD_VAR 0 5
105076: PPUSH
105077: CALL_OW 311
105081: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
105082: LD_VAR 0 10
105086: PPUSH
105087: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
105091: LD_VAR 0 10
105095: PPUSH
105096: LD_VAR 0 5
105100: PPUSH
105101: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
105105: LD_VAR 0 10
105109: PPUSH
105110: LD_VAR 0 5
105114: PPUSH
105115: CALL_OW 180
// end ; end ; unit_human :
105119: GO 105386
105121: LD_INT 1
105123: DOUBLE
105124: EQUAL
105125: IFTRUE 105129
105127: GO 105385
105129: POP
// begin b := IsInUnit ( i ) ;
105130: LD_ADDR_VAR 0 19
105134: PUSH
105135: LD_VAR 0 5
105139: PPUSH
105140: CALL_OW 310
105144: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
105145: LD_ADDR_VAR 0 20
105149: PUSH
105150: LD_VAR 0 19
105154: NOT
105155: PUSH
105156: LD_VAR 0 19
105160: PPUSH
105161: CALL_OW 266
105165: PUSH
105166: LD_INT 32
105168: PUSH
105169: LD_INT 31
105171: PUSH
105172: EMPTY
105173: LIST
105174: LIST
105175: IN
105176: OR
105177: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
105178: LD_VAR 0 17
105182: PUSH
105183: LD_VAR 0 2
105187: PPUSH
105188: LD_INT 21
105190: PUSH
105191: LD_INT 2
105193: PUSH
105194: EMPTY
105195: LIST
105196: LIST
105197: PPUSH
105198: CALL_OW 72
105202: PUSH
105203: LD_INT 1
105205: LESSEQUAL
105206: OR
105207: PUSH
105208: LD_VAR 0 20
105212: AND
105213: PUSH
105214: LD_VAR 0 5
105218: PUSH
105219: LD_VAR 0 18
105223: IN
105224: NOT
105225: AND
105226: IFFALSE 105319
// begin if b then
105228: LD_VAR 0 19
105232: IFFALSE 105281
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
105234: LD_VAR 0 19
105238: PPUSH
105239: LD_VAR 0 3
105243: PPUSH
105244: LD_VAR 0 19
105248: PPUSH
105249: CALL_OW 74
105253: PPUSH
105254: CALL_OW 296
105258: PUSH
105259: LD_INT 10
105261: LESS
105262: PUSH
105263: LD_VAR 0 19
105267: PPUSH
105268: CALL_OW 461
105272: PUSH
105273: LD_INT 7
105275: NONEQUAL
105276: AND
105277: IFFALSE 105281
// continue ;
105279: GO 104596
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
105281: LD_ADDR_VAR 0 18
105285: PUSH
105286: LD_VAR 0 18
105290: PPUSH
105291: LD_VAR 0 18
105295: PUSH
105296: LD_INT 1
105298: PLUS
105299: PPUSH
105300: LD_VAR 0 5
105304: PPUSH
105305: CALL_OW 1
105309: ST_TO_ADDR
// ComExitBuilding ( i ) ;
105310: LD_VAR 0 5
105314: PPUSH
105315: CALL_OW 122
// end ; if sold_defenders then
105319: LD_VAR 0 18
105323: IFFALSE 105383
// if i in sold_defenders then
105325: LD_VAR 0 5
105329: PUSH
105330: LD_VAR 0 18
105334: IN
105335: IFFALSE 105383
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
105337: LD_VAR 0 5
105341: PPUSH
105342: CALL_OW 314
105346: NOT
105347: PUSH
105348: LD_VAR 0 5
105352: PPUSH
105353: LD_VAR 0 14
105357: PPUSH
105358: CALL_OW 296
105362: PUSH
105363: LD_INT 30
105365: LESS
105366: AND
105367: IFFALSE 105383
// ComAttackUnit ( i , e ) ;
105369: LD_VAR 0 5
105373: PPUSH
105374: LD_VAR 0 14
105378: PPUSH
105379: CALL_OW 115
// end ; end ; end ;
105383: GO 105386
105385: POP
// if IsDead ( i ) then
105386: LD_VAR 0 5
105390: PPUSH
105391: CALL_OW 301
105395: IFFALSE 105413
// defenders := defenders diff i ;
105397: LD_ADDR_VAR 0 2
105401: PUSH
105402: LD_VAR 0 2
105406: PUSH
105407: LD_VAR 0 5
105411: DIFF
105412: ST_TO_ADDR
// end ;
105413: GO 104596
105415: POP
105416: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
105417: LD_VAR 0 3
105421: NOT
105422: PUSH
105423: LD_VAR 0 2
105427: NOT
105428: OR
105429: PUSH
105430: LD_EXP 59
105434: PUSH
105435: LD_VAR 0 1
105439: ARRAY
105440: NOT
105441: OR
105442: IFFALSE 104500
// MC_Reset ( base , 18 ) ;
105444: LD_VAR 0 1
105448: PPUSH
105449: LD_INT 18
105451: PPUSH
105452: CALL 55464 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
105456: LD_ADDR_VAR 0 2
105460: PUSH
105461: LD_VAR 0 2
105465: PUSH
105466: LD_VAR 0 2
105470: PPUSH
105471: LD_INT 2
105473: PUSH
105474: LD_INT 25
105476: PUSH
105477: LD_INT 1
105479: PUSH
105480: EMPTY
105481: LIST
105482: LIST
105483: PUSH
105484: LD_INT 25
105486: PUSH
105487: LD_INT 5
105489: PUSH
105490: EMPTY
105491: LIST
105492: LIST
105493: PUSH
105494: LD_INT 25
105496: PUSH
105497: LD_INT 8
105499: PUSH
105500: EMPTY
105501: LIST
105502: LIST
105503: PUSH
105504: LD_INT 25
105506: PUSH
105507: LD_INT 9
105509: PUSH
105510: EMPTY
105511: LIST
105512: LIST
105513: PUSH
105514: EMPTY
105515: LIST
105516: LIST
105517: LIST
105518: LIST
105519: LIST
105520: PPUSH
105521: CALL_OW 72
105525: DIFF
105526: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
105527: LD_VAR 0 3
105531: NOT
105532: PUSH
105533: LD_VAR 0 2
105537: PPUSH
105538: LD_INT 21
105540: PUSH
105541: LD_INT 2
105543: PUSH
105544: EMPTY
105545: LIST
105546: LIST
105547: PPUSH
105548: CALL_OW 72
105552: AND
105553: IFFALSE 105891
// begin tmp := FilterByTag ( defenders , 19 ) ;
105555: LD_ADDR_VAR 0 12
105559: PUSH
105560: LD_VAR 0 2
105564: PPUSH
105565: LD_INT 19
105567: PPUSH
105568: CALL 47824 0 2
105572: ST_TO_ADDR
// if tmp then
105573: LD_VAR 0 12
105577: IFFALSE 105647
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
105579: LD_ADDR_VAR 0 12
105583: PUSH
105584: LD_VAR 0 12
105588: PPUSH
105589: LD_INT 25
105591: PUSH
105592: LD_INT 3
105594: PUSH
105595: EMPTY
105596: LIST
105597: LIST
105598: PPUSH
105599: CALL_OW 72
105603: ST_TO_ADDR
// if tmp then
105604: LD_VAR 0 12
105608: IFFALSE 105647
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
105610: LD_ADDR_EXP 71
105614: PUSH
105615: LD_EXP 71
105619: PPUSH
105620: LD_VAR 0 1
105624: PPUSH
105625: LD_EXP 71
105629: PUSH
105630: LD_VAR 0 1
105634: ARRAY
105635: PUSH
105636: LD_VAR 0 12
105640: UNION
105641: PPUSH
105642: CALL_OW 1
105646: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
105647: LD_VAR 0 1
105651: PPUSH
105652: LD_INT 19
105654: PPUSH
105655: CALL 55464 0 2
// repeat wait ( 0 0$1 ) ;
105659: LD_INT 35
105661: PPUSH
105662: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105666: LD_EXP 59
105670: PUSH
105671: LD_VAR 0 1
105675: ARRAY
105676: NOT
105677: PUSH
105678: LD_EXP 59
105682: PUSH
105683: LD_VAR 0 1
105687: ARRAY
105688: PUSH
105689: EMPTY
105690: EQUAL
105691: OR
105692: IFFALSE 105729
// begin for i in defenders do
105694: LD_ADDR_VAR 0 5
105698: PUSH
105699: LD_VAR 0 2
105703: PUSH
105704: FOR_IN
105705: IFFALSE 105718
// ComStop ( i ) ;
105707: LD_VAR 0 5
105711: PPUSH
105712: CALL_OW 141
105716: GO 105704
105718: POP
105719: POP
// defenders := [ ] ;
105720: LD_ADDR_VAR 0 2
105724: PUSH
105725: EMPTY
105726: ST_TO_ADDR
// exit ;
105727: GO 105955
// end ; for i in defenders do
105729: LD_ADDR_VAR 0 5
105733: PUSH
105734: LD_VAR 0 2
105738: PUSH
105739: FOR_IN
105740: IFFALSE 105829
// begin if not IsInArea ( i , mc_parking [ base ] ) then
105742: LD_VAR 0 5
105746: PPUSH
105747: LD_EXP 83
105751: PUSH
105752: LD_VAR 0 1
105756: ARRAY
105757: PPUSH
105758: CALL_OW 308
105762: NOT
105763: IFFALSE 105787
// ComMoveToArea ( i , mc_parking [ base ] ) else
105765: LD_VAR 0 5
105769: PPUSH
105770: LD_EXP 83
105774: PUSH
105775: LD_VAR 0 1
105779: ARRAY
105780: PPUSH
105781: CALL_OW 113
105785: GO 105827
// if GetControl ( i ) = control_manual then
105787: LD_VAR 0 5
105791: PPUSH
105792: CALL_OW 263
105796: PUSH
105797: LD_INT 1
105799: EQUAL
105800: IFFALSE 105827
// if IsDrivenBy ( i ) then
105802: LD_VAR 0 5
105806: PPUSH
105807: CALL_OW 311
105811: IFFALSE 105827
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
105813: LD_VAR 0 5
105817: PPUSH
105818: CALL_OW 311
105822: PPUSH
105823: CALL_OW 121
// end ;
105827: GO 105739
105829: POP
105830: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
105831: LD_VAR 0 2
105835: PPUSH
105836: LD_INT 95
105838: PUSH
105839: LD_EXP 83
105843: PUSH
105844: LD_VAR 0 1
105848: ARRAY
105849: PUSH
105850: EMPTY
105851: LIST
105852: LIST
105853: PPUSH
105854: CALL_OW 72
105858: PUSH
105859: LD_VAR 0 2
105863: EQUAL
105864: PUSH
105865: LD_EXP 82
105869: PUSH
105870: LD_VAR 0 1
105874: ARRAY
105875: OR
105876: PUSH
105877: LD_EXP 59
105881: PUSH
105882: LD_VAR 0 1
105886: ARRAY
105887: NOT
105888: OR
105889: IFFALSE 105659
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
105891: LD_ADDR_EXP 81
105895: PUSH
105896: LD_EXP 81
105900: PPUSH
105901: LD_VAR 0 1
105905: PPUSH
105906: LD_VAR 0 2
105910: PPUSH
105911: LD_INT 21
105913: PUSH
105914: LD_INT 2
105916: PUSH
105917: EMPTY
105918: LIST
105919: LIST
105920: PPUSH
105921: CALL_OW 72
105925: PPUSH
105926: CALL_OW 1
105930: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
105931: LD_VAR 0 1
105935: PPUSH
105936: LD_INT 19
105938: PPUSH
105939: CALL 55464 0 2
// MC_Reset ( base , 20 ) ;
105943: LD_VAR 0 1
105947: PPUSH
105948: LD_INT 20
105950: PPUSH
105951: CALL 55464 0 2
// end ; end_of_file
105955: LD_VAR 0 4
105959: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
105960: LD_VAR 0 1
105964: PUSH
105965: LD_INT 200
105967: DOUBLE
105968: GREATEREQUAL
105969: IFFALSE 105977
105971: LD_INT 299
105973: DOUBLE
105974: LESSEQUAL
105975: IFTRUE 105979
105977: GO 106011
105979: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
105980: LD_VAR 0 1
105984: PPUSH
105985: LD_VAR 0 2
105989: PPUSH
105990: LD_VAR 0 3
105994: PPUSH
105995: LD_VAR 0 4
105999: PPUSH
106000: LD_VAR 0 5
106004: PPUSH
106005: CALL 94901 0 5
106009: GO 106088
106011: LD_INT 300
106013: DOUBLE
106014: GREATEREQUAL
106015: IFFALSE 106023
106017: LD_INT 399
106019: DOUBLE
106020: LESSEQUAL
106021: IFTRUE 106025
106023: GO 106087
106025: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
106026: LD_VAR 0 1
106030: PPUSH
106031: LD_VAR 0 2
106035: PPUSH
106036: LD_VAR 0 3
106040: PPUSH
106041: LD_VAR 0 4
106045: PPUSH
106046: LD_VAR 0 5
106050: PPUSH
106051: LD_VAR 0 6
106055: PPUSH
106056: LD_VAR 0 7
106060: PPUSH
106061: LD_VAR 0 8
106065: PPUSH
106066: LD_VAR 0 9
106070: PPUSH
106071: LD_VAR 0 10
106075: PPUSH
106076: LD_VAR 0 11
106080: PPUSH
106081: CALL 92807 0 11
106085: GO 106088
106087: POP
// end ;
106088: PPOPN 11
106090: END
