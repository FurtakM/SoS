// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 690 0 0
// InitGlobalVariables ;
  19: CALL 85499 0 0
// InitMacro ;
  23: CALL 54873 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 48201 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 48201 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 48201 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 4
 128: PUSH
 129: LD_INT 3
 131: PUSH
 132: LD_INT 2
 134: PUSH
 135: LD_INT 2
 137: PUSH
 138: EMPTY
 139: LIST
 140: LIST
 141: LIST
 142: LIST
 143: PUSH
 144: LD_OWVAR 67
 148: ARRAY
 149: PPUSH
 150: LD_INT 0
 152: PPUSH
 153: LD_INT 0
 155: PPUSH
 156: LD_INT 0
 158: PPUSH
 159: LD_INT 0
 161: PPUSH
 162: LD_INT 12
 164: PPUSH
 165: LD_INT 0
 167: PPUSH
 168: CALL 48201 0 9
// PrepareArabian ;
 172: CALL 3964 0 0
// PrepareRussian ;
 176: CALL 2935 0 0
// PrepareAlliance ;
 180: CALL 900 0 0
// MC_Start ( ) ;
 184: CALL 57038 0 0
// if debug then
 188: LD_EXP 1
 192: IFFALSE 201
// FogOff ( 1 ) ;
 194: LD_INT 1
 196: PPUSH
 197: CALL_OW 344
// Action ;
 201: CALL 7326 0 0
// end ;
 205: END
// export function CustomInitMacro ; var i ; begin
 206: LD_INT 0
 208: PPUSH
 209: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 210: LD_ADDR_EXP 84
 214: PUSH
 215: LD_INT 1
 217: PUSH
 218: LD_INT 2
 220: PUSH
 221: EMPTY
 222: LIST
 223: LIST
 224: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 225: LD_ADDR_EXP 85
 229: PUSH
 230: LD_INT 3
 232: PUSH
 233: LD_INT 4
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 240: LD_INT 1
 242: PPUSH
 243: LD_INT 12
 245: PUSH
 246: LD_INT 15
 248: PUSH
 249: LD_INT 18
 251: PUSH
 252: LD_INT 20
 254: PUSH
 255: EMPTY
 256: LIST
 257: LIST
 258: LIST
 259: LIST
 260: PUSH
 261: LD_OWVAR 67
 265: ARRAY
 266: PPUSH
 267: LD_INT 7
 269: PPUSH
 270: CALL 78727 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 274: LD_INT 1
 276: PPUSH
 277: LD_EXP 55
 281: PPUSH
 282: CALL 79153 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 286: LD_INT 1
 288: PPUSH
 289: LD_INT 6
 291: PPUSH
 292: CALL 79611 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 9
 301: PUSH
 302: EMPTY
 303: LIST
 304: PPUSH
 305: CALL 79880 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 13
 314: PUSH
 315: LD_INT 1
 317: PUSH
 318: LD_INT 2
 320: PUSH
 321: LD_INT 32
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: LIST
 329: PUSH
 330: LD_INT 13
 332: PUSH
 333: LD_INT 1
 335: PUSH
 336: LD_INT 2
 338: PUSH
 339: LD_EXP 110
 343: PUSH
 344: EMPTY
 345: LIST
 346: LIST
 347: LIST
 348: LIST
 349: PUSH
 350: EMPTY
 351: LIST
 352: LIST
 353: PPUSH
 354: CALL 79093 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 358: LD_INT 2
 360: PPUSH
 361: LD_INT 12
 363: PUSH
 364: LD_INT 14
 366: PUSH
 367: LD_INT 10
 369: PUSH
 370: LD_INT 11
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: PPUSH
 379: CALL 79787 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 383: LD_INT 2
 385: PPUSH
 386: LD_EXP 52
 390: PPUSH
 391: CALL 79153 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 395: LD_INT 2
 397: PPUSH
 398: LD_INT 8
 400: PPUSH
 401: CALL 79611 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 405: LD_INT 2
 407: PPUSH
 408: LD_INT 10
 410: PUSH
 411: EMPTY
 412: LIST
 413: PPUSH
 414: CALL 79880 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 418: LD_INT 2
 420: PPUSH
 421: LD_INT 6
 423: PUSH
 424: LD_INT 71
 426: PUSH
 427: LD_INT 116
 429: PUSH
 430: LD_INT 4
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 4
 441: PUSH
 442: LD_INT 85
 444: PUSH
 445: LD_INT 116
 447: PUSH
 448: LD_INT 4
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: LD_INT 32
 459: PUSH
 460: LD_INT 83
 462: PUSH
 463: LD_INT 111
 465: PUSH
 466: LD_INT 4
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: PUSH
 475: LD_INT 32
 477: PUSH
 478: LD_INT 87
 480: PUSH
 481: LD_INT 121
 483: PUSH
 484: LD_INT 4
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 33
 495: PUSH
 496: LD_INT 88
 498: PUSH
 499: LD_INT 128
 501: PUSH
 502: LD_INT 4
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 32
 513: PUSH
 514: LD_INT 59
 516: PUSH
 517: LD_INT 89
 519: PUSH
 520: LD_INT 3
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 33
 531: PUSH
 532: LD_INT 69
 534: PUSH
 535: LD_INT 98
 537: PUSH
 538: LD_INT 3
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 33
 549: PUSH
 550: LD_INT 77
 552: PUSH
 553: LD_INT 103
 555: PUSH
 556: LD_INT 3
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 33
 567: PUSH
 568: LD_INT 83
 570: PUSH
 571: LD_INT 105
 573: PUSH
 574: LD_INT 3
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 33
 585: PUSH
 586: LD_INT 71
 588: PUSH
 589: LD_INT 125
 591: PUSH
 592: LD_INT 5
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PPUSH
 613: CALL 78937 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 617: LD_INT 2
 619: PPUSH
 620: LD_INT 43
 622: PUSH
 623: LD_INT 47
 625: PUSH
 626: LD_INT 46
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: PPUSH
 634: CALL 80198 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 638: LD_INT 2
 640: PPUSH
 641: LD_INT 21
 643: PUSH
 644: LD_INT 1
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 51
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 22
 661: PUSH
 662: LD_INT 1
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 52
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: EMPTY
 678: LIST
 679: LIST
 680: PPUSH
 681: CALL 79093 0 2
// end ;
 685: LD_VAR 0 1
 689: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 690: LD_INT 0
 692: PPUSH
// debug := false ;
 693: LD_ADDR_EXP 1
 697: PUSH
 698: LD_INT 0
 700: ST_TO_ADDR
// game := true ;
 701: LD_ADDR_EXP 2
 705: PUSH
 706: LD_INT 1
 708: ST_TO_ADDR
// gossudarov_arrive := false ;
 709: LD_ADDR_EXP 4
 713: PUSH
 714: LD_INT 0
 716: ST_TO_ADDR
// ru_lab_builded := false ;
 717: LD_ADDR_EXP 5
 721: PUSH
 722: LD_INT 0
 724: ST_TO_ADDR
// player_spotted := false ;
 725: LD_ADDR_EXP 6
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// first_attack := false ;
 733: LD_ADDR_EXP 7
 737: PUSH
 738: LD_INT 0
 740: ST_TO_ADDR
// ru_attackers := [ ] ;
 741: LD_ADDR_EXP 53
 745: PUSH
 746: EMPTY
 747: ST_TO_ADDR
// ar_base_spotted := false ;
 748: LD_ADDR_EXP 8
 752: PUSH
 753: LD_INT 0
 755: ST_TO_ADDR
// ar_active_attack := false ;
 756: LD_ADDR_EXP 9
 760: PUSH
 761: LD_INT 0
 763: ST_TO_ADDR
// ar_attackers := [ ] ;
 764: LD_ADDR_EXP 11
 768: PUSH
 769: EMPTY
 770: ST_TO_ADDR
// first_powell_attack := false ;
 771: LD_ADDR_EXP 12
 775: PUSH
 776: LD_INT 0
 778: ST_TO_ADDR
// masha_killed := false ;
 779: LD_ADDR_EXP 10
 783: PUSH
 784: LD_INT 0
 786: ST_TO_ADDR
// abdul_escaped := true ;
 787: LD_ADDR_EXP 13
 791: PUSH
 792: LD_INT 1
 794: ST_TO_ADDR
// loss_counter := 0 ;
 795: LD_ADDR_EXP 14
 799: PUSH
 800: LD_INT 0
 802: ST_TO_ADDR
// hack_counter := 0 ;
 803: LD_ADDR_EXP 15
 807: PUSH
 808: LD_INT 0
 810: ST_TO_ADDR
// end ;
 811: LD_VAR 0 1
 815: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 816: LD_EXP 49
 820: PPUSH
 821: CALL_OW 255
 825: PUSH
 826: LD_INT 7
 828: EQUAL
 829: PUSH
 830: LD_EXP 48
 834: PPUSH
 835: CALL_OW 255
 839: PUSH
 840: LD_INT 7
 842: EQUAL
 843: AND
 844: PUSH
 845: LD_EXP 49
 849: PPUSH
 850: CALL_OW 302
 854: AND
 855: PUSH
 856: LD_EXP 48
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: IFFALSE 878
 868: GO 870
 870: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 871: LD_STRING ACH_COMRADE
 873: PPUSH
 874: CALL_OW 543
 878: END
// every 0 0$1 trigger hack_counter >= 10 do
 879: LD_EXP 15
 883: PUSH
 884: LD_INT 10
 886: GREATEREQUAL
 887: IFFALSE 899
 889: GO 891
 891: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 892: LD_STRING ACH_HACK
 894: PPUSH
 895: CALL_OW 543
 899: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 900: LD_INT 0
 902: PPUSH
 903: PPUSH
 904: PPUSH
 905: PPUSH
// uc_side := 7 ;
 906: LD_ADDR_OWVAR 20
 910: PUSH
 911: LD_INT 7
 913: ST_TO_ADDR
// uc_nation := 1 ;
 914: LD_ADDR_OWVAR 21
 918: PUSH
 919: LD_INT 1
 921: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 922: LD_ADDR_EXP 16
 926: PUSH
 927: LD_STRING JMM
 929: PPUSH
 930: LD_EXP 1
 934: NOT
 935: PPUSH
 936: LD_STRING 12a_
 938: PPUSH
 939: CALL 14838 0 3
 943: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 944: LD_EXP 16
 948: PPUSH
 949: LD_INT 71
 951: PPUSH
 952: LD_INT 23
 954: PPUSH
 955: LD_INT 0
 957: PPUSH
 958: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 962: LD_EXP 16
 966: PPUSH
 967: LD_INT 2
 969: PPUSH
 970: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 974: LD_ADDR_EXP 17
 978: PUSH
 979: LD_STRING Roth
 981: PPUSH
 982: LD_EXP 1
 986: NOT
 987: PPUSH
 988: LD_STRING 12a_
 990: PPUSH
 991: CALL 14838 0 3
 995: ST_TO_ADDR
// if Roth then
 996: LD_EXP 17
1000: IFFALSE 1020
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1002: LD_EXP 17
1006: PPUSH
1007: LD_INT 71
1009: PPUSH
1010: LD_INT 21
1012: PPUSH
1013: LD_INT 0
1015: PPUSH
1016: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1020: LD_ADDR_EXP 18
1024: PUSH
1025: LD_STRING Lisa
1027: PPUSH
1028: LD_EXP 1
1032: NOT
1033: PPUSH
1034: LD_STRING 12a_
1036: PPUSH
1037: CALL 14838 0 3
1041: ST_TO_ADDR
// if Lisa then
1042: LD_EXP 18
1046: IFFALSE 1063
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1048: LD_EXP 18
1052: PPUSH
1053: LD_INT 13
1055: PPUSH
1056: LD_INT 0
1058: PPUSH
1059: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1063: LD_ADDR_EXP 19
1067: PUSH
1068: LD_STRING Donaldson
1070: PPUSH
1071: LD_EXP 1
1075: NOT
1076: PPUSH
1077: LD_STRING 12a_
1079: PPUSH
1080: CALL 14838 0 3
1084: ST_TO_ADDR
// if Donaldson then
1085: LD_EXP 19
1089: IFFALSE 1106
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1091: LD_EXP 19
1095: PPUSH
1096: LD_INT 13
1098: PPUSH
1099: LD_INT 0
1101: PPUSH
1102: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1106: LD_ADDR_EXP 20
1110: PUSH
1111: LD_STRING Bobby
1113: PPUSH
1114: LD_EXP 1
1118: NOT
1119: PPUSH
1120: LD_STRING 12a_
1122: PPUSH
1123: CALL 14838 0 3
1127: ST_TO_ADDR
// if Bobby then
1128: LD_EXP 20
1132: IFFALSE 1149
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1134: LD_EXP 20
1138: PPUSH
1139: LD_INT 13
1141: PPUSH
1142: LD_INT 0
1144: PPUSH
1145: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1149: LD_ADDR_EXP 21
1153: PUSH
1154: LD_STRING Cyrus
1156: PPUSH
1157: LD_EXP 1
1161: NOT
1162: PPUSH
1163: LD_STRING 12a_
1165: PPUSH
1166: CALL 14838 0 3
1170: ST_TO_ADDR
// if Cyrus then
1171: LD_EXP 21
1175: IFFALSE 1192
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1177: LD_EXP 21
1181: PPUSH
1182: LD_INT 13
1184: PPUSH
1185: LD_INT 0
1187: PPUSH
1188: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1192: LD_ADDR_EXP 22
1196: PUSH
1197: LD_STRING Denis
1199: PPUSH
1200: LD_EXP 1
1204: NOT
1205: PPUSH
1206: LD_STRING 12a_
1208: PPUSH
1209: CALL 14838 0 3
1213: ST_TO_ADDR
// if Denis then
1214: LD_EXP 22
1218: IFFALSE 1235
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1220: LD_EXP 22
1224: PPUSH
1225: LD_INT 13
1227: PPUSH
1228: LD_INT 0
1230: PPUSH
1231: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1235: LD_ADDR_EXP 23
1239: PUSH
1240: LD_STRING Brown
1242: PPUSH
1243: LD_EXP 1
1247: NOT
1248: PPUSH
1249: LD_STRING 12a_
1251: PPUSH
1252: CALL 14838 0 3
1256: ST_TO_ADDR
// if Brown then
1257: LD_EXP 23
1261: IFFALSE 1278
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1263: LD_EXP 23
1267: PPUSH
1268: LD_INT 13
1270: PPUSH
1271: LD_INT 0
1273: PPUSH
1274: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1278: LD_ADDR_EXP 24
1282: PUSH
1283: LD_STRING Gladstone
1285: PPUSH
1286: LD_EXP 1
1290: NOT
1291: PPUSH
1292: LD_STRING 12a_
1294: PPUSH
1295: CALL 14838 0 3
1299: ST_TO_ADDR
// if Gladstone then
1300: LD_EXP 24
1304: IFFALSE 1321
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1306: LD_EXP 24
1310: PPUSH
1311: LD_INT 13
1313: PPUSH
1314: LD_INT 0
1316: PPUSH
1317: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1321: LD_ADDR_EXP 25
1325: PUSH
1326: LD_STRING Houten
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_STRING 12a_
1337: PPUSH
1338: CALL 14838 0 3
1342: ST_TO_ADDR
// if Houten then
1343: LD_EXP 25
1347: IFFALSE 1364
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1349: LD_EXP 25
1353: PPUSH
1354: LD_INT 13
1356: PPUSH
1357: LD_INT 0
1359: PPUSH
1360: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1364: LD_ADDR_EXP 26
1368: PUSH
1369: LD_STRING Cornell
1371: PPUSH
1372: LD_EXP 1
1376: NOT
1377: PPUSH
1378: LD_STRING 12a_
1380: PPUSH
1381: CALL 14838 0 3
1385: ST_TO_ADDR
// if Cornel then
1386: LD_EXP 26
1390: IFFALSE 1407
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1392: LD_EXP 26
1396: PPUSH
1397: LD_INT 13
1399: PPUSH
1400: LD_INT 0
1402: PPUSH
1403: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1407: LD_ADDR_EXP 27
1411: PUSH
1412: LD_STRING Gary
1414: PPUSH
1415: LD_EXP 1
1419: NOT
1420: PPUSH
1421: LD_STRING 12a_
1423: PPUSH
1424: CALL 14838 0 3
1428: ST_TO_ADDR
// if Gary then
1429: LD_EXP 27
1433: IFFALSE 1450
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1435: LD_EXP 27
1439: PPUSH
1440: LD_INT 13
1442: PPUSH
1443: LD_INT 0
1445: PPUSH
1446: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1450: LD_ADDR_EXP 28
1454: PUSH
1455: LD_STRING Frank
1457: PPUSH
1458: LD_EXP 1
1462: NOT
1463: PPUSH
1464: LD_STRING 12a_
1466: PPUSH
1467: CALL 14838 0 3
1471: ST_TO_ADDR
// if Frank then
1472: LD_EXP 28
1476: IFFALSE 1493
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1478: LD_EXP 28
1482: PPUSH
1483: LD_INT 13
1485: PPUSH
1486: LD_INT 0
1488: PPUSH
1489: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1493: LD_ADDR_EXP 29
1497: PUSH
1498: LD_STRING Kikuchi
1500: PPUSH
1501: LD_EXP 1
1505: NOT
1506: PPUSH
1507: LD_STRING 12a_
1509: PPUSH
1510: CALL 14838 0 3
1514: ST_TO_ADDR
// if Kikuchi then
1515: LD_EXP 29
1519: IFFALSE 1536
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1521: LD_EXP 29
1525: PPUSH
1526: LD_INT 13
1528: PPUSH
1529: LD_INT 0
1531: PPUSH
1532: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1536: LD_ADDR_EXP 30
1540: PUSH
1541: LD_STRING Simms
1543: PPUSH
1544: LD_EXP 1
1548: NOT
1549: PPUSH
1550: LD_STRING 12a_
1552: PPUSH
1553: CALL 14838 0 3
1557: ST_TO_ADDR
// if Simms then
1558: LD_EXP 30
1562: IFFALSE 1579
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1564: LD_EXP 30
1568: PPUSH
1569: LD_INT 13
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1579: LD_ADDR_EXP 31
1583: PUSH
1584: LD_STRING Joan
1586: PPUSH
1587: LD_EXP 1
1591: NOT
1592: PPUSH
1593: LD_STRING 12a_
1595: PPUSH
1596: CALL 14838 0 3
1600: ST_TO_ADDR
// if Joan then
1601: LD_EXP 31
1605: IFFALSE 1622
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1607: LD_EXP 31
1611: PPUSH
1612: LD_INT 13
1614: PPUSH
1615: LD_INT 0
1617: PPUSH
1618: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1622: LD_ADDR_EXP 32
1626: PUSH
1627: LD_STRING DeltaDoctor
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 12a_
1638: PPUSH
1639: CALL 14838 0 3
1643: ST_TO_ADDR
// if DeltaDoctor then
1644: LD_EXP 32
1648: IFFALSE 1665
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1650: LD_EXP 32
1654: PPUSH
1655: LD_INT 13
1657: PPUSH
1658: LD_INT 0
1660: PPUSH
1661: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1665: LD_ADDR_VAR 0 4
1669: PUSH
1670: LD_STRING 12a_others
1672: PPUSH
1673: CALL_OW 31
1677: ST_TO_ADDR
// if tmp then
1678: LD_VAR 0 4
1682: IFFALSE 1716
// for i in tmp do
1684: LD_ADDR_VAR 0 3
1688: PUSH
1689: LD_VAR 0 4
1693: PUSH
1694: FOR_IN
1695: IFFALSE 1714
// PlaceUnitArea ( i , alliance_start , false ) ;
1697: LD_VAR 0 3
1701: PPUSH
1702: LD_INT 13
1704: PPUSH
1705: LD_INT 0
1707: PPUSH
1708: CALL_OW 49
1712: GO 1694
1714: POP
1715: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1716: LD_INT 3
1718: PPUSH
1719: LD_INT 3
1721: PPUSH
1722: LD_INT 3
1724: PPUSH
1725: LD_INT 12
1727: PPUSH
1728: LD_INT 100
1730: PPUSH
1731: CALL 19702 0 5
// veh := CreateVehicle ;
1735: LD_ADDR_VAR 0 2
1739: PUSH
1740: CALL_OW 45
1744: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1745: LD_VAR 0 2
1749: PPUSH
1750: LD_INT 2
1752: PPUSH
1753: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1757: LD_VAR 0 2
1761: PPUSH
1762: LD_INT 60
1764: PPUSH
1765: LD_INT 6
1767: PPUSH
1768: LD_INT 0
1770: PPUSH
1771: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1775: LD_VAR 0 2
1779: PPUSH
1780: LD_INT 4
1782: PPUSH
1783: LD_INT 30
1785: PPUSH
1786: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1790: LD_STRING 11_artifact_captured
1792: PPUSH
1793: LD_INT 0
1795: PPUSH
1796: CALL_OW 30
1800: IFFALSE 1876
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1802: LD_INT 3
1804: PPUSH
1805: LD_INT 3
1807: PPUSH
1808: LD_INT 3
1810: PPUSH
1811: LD_INT 12
1813: PPUSH
1814: LD_INT 100
1816: PPUSH
1817: CALL 19702 0 5
// veh := CreateVehicle ;
1821: LD_ADDR_VAR 0 2
1825: PUSH
1826: CALL_OW 45
1830: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1831: LD_VAR 0 2
1835: PPUSH
1836: LD_INT 3
1838: PPUSH
1839: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1843: LD_VAR 0 2
1847: PPUSH
1848: LD_INT 75
1850: PPUSH
1851: LD_INT 6
1853: PPUSH
1854: LD_INT 0
1856: PPUSH
1857: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1861: LD_VAR 0 2
1865: PPUSH
1866: LD_INT 4
1868: PPUSH
1869: LD_INT 50
1871: PPUSH
1872: CALL_OW 290
// end ; end ;
1876: LD_VAR 0 1
1880: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1881: LD_INT 0
1883: PPUSH
1884: PPUSH
1885: PPUSH
1886: PPUSH
// uc_side := 6 ;
1887: LD_ADDR_OWVAR 20
1891: PUSH
1892: LD_INT 6
1894: ST_TO_ADDR
// uc_nation := 3 ;
1895: LD_ADDR_OWVAR 21
1899: PUSH
1900: LD_INT 3
1902: ST_TO_ADDR
// InitHc ;
1903: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1907: LD_ADDR_EXP 33
1911: PUSH
1912: LD_STRING Gossudarov
1914: PPUSH
1915: CALL_OW 25
1919: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1920: LD_ADDR_EXP 34
1924: PUSH
1925: LD_STRING Kirilenkova
1927: PPUSH
1928: CALL_OW 25
1932: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1933: LD_ADDR_EXP 35
1937: PUSH
1938: LD_STRING Titov
1940: PPUSH
1941: CALL_OW 25
1945: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1946: LD_ADDR_EXP 40
1950: PUSH
1951: LD_STRING Oblukov
1953: PPUSH
1954: CALL_OW 25
1958: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1959: LD_ADDR_EXP 37
1963: PUSH
1964: LD_STRING Dolgov
1966: PPUSH
1967: CALL_OW 25
1971: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1972: LD_ADDR_EXP 38
1976: PUSH
1977: LD_STRING Petrosyan
1979: PPUSH
1980: CALL_OW 25
1984: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1985: LD_ADDR_EXP 39
1989: PUSH
1990: LD_STRING Scholtze
1992: PPUSH
1993: CALL_OW 25
1997: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1998: LD_ADDR_EXP 41
2002: PUSH
2003: LD_STRING Kapitsova
2005: PPUSH
2006: CALL_OW 25
2010: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2011: LD_ADDR_VAR 0 2
2015: PUSH
2016: LD_EXP 33
2020: PUSH
2021: LD_EXP 34
2025: PUSH
2026: LD_EXP 35
2030: PUSH
2031: LD_EXP 40
2035: PUSH
2036: LD_EXP 37
2040: PUSH
2041: LD_EXP 38
2045: PUSH
2046: LD_EXP 39
2050: PUSH
2051: LD_EXP 41
2055: PUSH
2056: EMPTY
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: LIST
2064: LIST
2065: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2066: LD_INT 1
2068: PPUSH
2069: LD_INT 4
2071: PPUSH
2072: LD_INT 8
2074: PPUSH
2075: CALL_OW 380
// un := CreateHuman ;
2079: LD_ADDR_VAR 0 4
2083: PUSH
2084: CALL_OW 44
2088: ST_TO_ADDR
// tmp := tmp ^ un ;
2089: LD_ADDR_VAR 0 2
2093: PUSH
2094: LD_VAR 0 2
2098: PUSH
2099: LD_VAR 0 4
2103: ADD
2104: ST_TO_ADDR
// for i in tmp do
2105: LD_ADDR_VAR 0 3
2109: PUSH
2110: LD_VAR 0 2
2114: PUSH
2115: FOR_IN
2116: IFFALSE 2135
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2118: LD_VAR 0 3
2122: PPUSH
2123: LD_INT 14
2125: PPUSH
2126: LD_INT 0
2128: PPUSH
2129: CALL_OW 49
2133: GO 2115
2135: POP
2136: POP
// if freedom then
2137: LD_EXP 3
2141: IFFALSE 2174
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2143: LD_VAR 0 2
2147: PPUSH
2148: LD_EXP 3
2152: PPUSH
2153: CALL_OW 250
2157: PPUSH
2158: LD_EXP 3
2162: PPUSH
2163: CALL_OW 251
2167: PPUSH
2168: CALL_OW 111
2172: GO 2189
// ComMoveXY ( tmp , 70 , 48 ) ;
2174: LD_VAR 0 2
2178: PPUSH
2179: LD_INT 70
2181: PPUSH
2182: LD_INT 48
2184: PPUSH
2185: CALL_OW 111
// end ;
2189: LD_VAR 0 1
2193: RET
// export function PrepareBelkov ; begin
2194: LD_INT 0
2196: PPUSH
// uc_side := 4 ;
2197: LD_ADDR_OWVAR 20
2201: PUSH
2202: LD_INT 4
2204: ST_TO_ADDR
// uc_nation := 3 ;
2205: LD_ADDR_OWVAR 21
2209: PUSH
2210: LD_INT 3
2212: ST_TO_ADDR
// InitHc ;
2213: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2217: LD_ADDR_EXP 48
2221: PUSH
2222: LD_STRING Belkov
2224: PPUSH
2225: CALL_OW 25
2229: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2230: LD_EXP 48
2234: PPUSH
2235: LD_INT 14
2237: PPUSH
2238: LD_INT 0
2240: PPUSH
2241: CALL_OW 49
// end ;
2245: LD_VAR 0 1
2249: RET
// export function PrepareGnyevko ; begin
2250: LD_INT 0
2252: PPUSH
// uc_side := 4 ;
2253: LD_ADDR_OWVAR 20
2257: PUSH
2258: LD_INT 4
2260: ST_TO_ADDR
// uc_nation := 3 ;
2261: LD_ADDR_OWVAR 21
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// InitHc ;
2269: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2273: LD_ADDR_EXP 49
2277: PUSH
2278: LD_STRING Gnyevko
2280: PPUSH
2281: CALL_OW 25
2285: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2286: LD_EXP 49
2290: PPUSH
2291: LD_INT 14
2293: PPUSH
2294: LD_INT 0
2296: PPUSH
2297: CALL_OW 49
// end ;
2301: LD_VAR 0 1
2305: RET
// export function PrepareBurlak ; var i , tmp ; begin
2306: LD_INT 0
2308: PPUSH
2309: PPUSH
2310: PPUSH
// uc_side := 4 ;
2311: LD_ADDR_OWVAR 20
2315: PUSH
2316: LD_INT 4
2318: ST_TO_ADDR
// uc_nation := 3 ;
2319: LD_ADDR_OWVAR 21
2323: PUSH
2324: LD_INT 3
2326: ST_TO_ADDR
// InitHc ;
2327: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2331: LD_ADDR_EXP 47
2335: PUSH
2336: LD_STRING Burlak
2338: PPUSH
2339: CALL_OW 25
2343: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2344: LD_INT 24
2346: PUSH
2347: LD_INT 23
2349: PUSH
2350: LD_INT 22
2352: PUSH
2353: LD_INT 22
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: LIST
2360: LIST
2361: PUSH
2362: LD_OWVAR 67
2366: ARRAY
2367: PPUSH
2368: LD_INT 1
2370: PPUSH
2371: LD_INT 1
2373: PPUSH
2374: LD_INT 45
2376: PUSH
2377: LD_INT 44
2379: PUSH
2380: LD_INT 43
2382: PUSH
2383: LD_INT 42
2385: PUSH
2386: EMPTY
2387: LIST
2388: LIST
2389: LIST
2390: LIST
2391: PUSH
2392: LD_OWVAR 67
2396: ARRAY
2397: PPUSH
2398: LD_INT 0
2400: PPUSH
2401: CALL 19702 0 5
// Masha := CreateVehicle ;
2405: LD_ADDR_EXP 50
2409: PUSH
2410: CALL_OW 45
2414: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2415: LD_EXP 50
2419: PUSH
2420: LD_EXP 47
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PPUSH
2429: LD_INT 499
2431: PPUSH
2432: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2436: LD_EXP 50
2440: PPUSH
2441: LD_INT 3
2443: PPUSH
2444: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2448: LD_EXP 50
2452: PPUSH
2453: LD_INT 1
2455: PPUSH
2456: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 18
2465: PPUSH
2466: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2470: LD_INT 35
2472: PPUSH
2473: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2477: LD_ADDR_VAR 0 3
2481: PUSH
2482: LD_INT 18
2484: PPUSH
2485: EMPTY
2486: PPUSH
2487: CALL_OW 70
2491: ST_TO_ADDR
// if tmp then
2492: LD_VAR 0 3
2496: IFFALSE 2530
// for i in tmp do
2498: LD_ADDR_VAR 0 2
2502: PUSH
2503: LD_VAR 0 3
2507: PUSH
2508: FOR_IN
2509: IFFALSE 2528
// ComMoveXY ( i , 114 , 9 ) ;
2511: LD_VAR 0 2
2515: PPUSH
2516: LD_INT 114
2518: PPUSH
2519: LD_INT 9
2521: PPUSH
2522: CALL_OW 111
2526: GO 2508
2528: POP
2529: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2530: LD_INT 18
2532: PPUSH
2533: EMPTY
2534: PPUSH
2535: CALL_OW 70
2539: NOT
2540: PUSH
2541: LD_INT 123
2543: PPUSH
2544: LD_INT 3
2546: PPUSH
2547: CALL_OW 428
2551: PUSH
2552: LD_INT 0
2554: EQUAL
2555: AND
2556: IFFALSE 2470
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2558: LD_EXP 50
2562: PPUSH
2563: LD_INT 123
2565: PPUSH
2566: LD_INT 3
2568: PPUSH
2569: LD_INT 0
2571: PPUSH
2572: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2576: LD_EXP 47
2580: PPUSH
2581: LD_INT 125
2583: PPUSH
2584: LD_INT 1
2586: PPUSH
2587: LD_INT 0
2589: PPUSH
2590: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2594: LD_EXP 47
2598: PPUSH
2599: LD_EXP 50
2603: PPUSH
2604: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2608: LD_INT 10
2610: PPUSH
2611: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2615: LD_EXP 50
2619: PPUSH
2620: LD_INT 110
2622: PPUSH
2623: LD_INT 10
2625: PPUSH
2626: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2630: LD_ADDR_EXP 43
2634: PUSH
2635: LD_STRING Petrovova
2637: PPUSH
2638: CALL_OW 25
2642: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2643: LD_ADDR_EXP 45
2647: PUSH
2648: LD_STRING Kuzmov
2650: PPUSH
2651: CALL_OW 25
2655: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2656: LD_ADDR_EXP 44
2660: PUSH
2661: LD_STRING Kovalyuk
2663: PPUSH
2664: CALL_OW 25
2668: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2669: LD_ADDR_EXP 42
2673: PUSH
2674: LD_STRING Lipshchin
2676: PPUSH
2677: CALL_OW 25
2681: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2682: LD_ADDR_EXP 46
2686: PUSH
2687: LD_STRING Karamazov
2689: PPUSH
2690: CALL_OW 25
2694: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2695: LD_ADDR_VAR 0 3
2699: PUSH
2700: LD_EXP 43
2704: PUSH
2705: LD_EXP 45
2709: PUSH
2710: LD_EXP 44
2714: PUSH
2715: LD_EXP 42
2719: PUSH
2720: LD_EXP 46
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: ST_TO_ADDR
// for i in tmp do
2732: LD_ADDR_VAR 0 2
2736: PUSH
2737: LD_VAR 0 3
2741: PUSH
2742: FOR_IN
2743: IFFALSE 2782
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2745: LD_VAR 0 2
2749: PPUSH
2750: LD_INT 399
2752: PPUSH
2753: LD_INT 799
2755: PPUSH
2756: CALL_OW 12
2760: PPUSH
2761: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2765: LD_VAR 0 2
2769: PPUSH
2770: LD_INT 19
2772: PPUSH
2773: LD_INT 0
2775: PPUSH
2776: CALL_OW 49
// end ;
2780: GO 2742
2782: POP
2783: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2784: LD_VAR 0 3
2788: PPUSH
2789: LD_INT 112
2791: PPUSH
2792: LD_INT 5
2794: PPUSH
2795: CALL_OW 111
// AddComHold ( tmp ) ;
2799: LD_VAR 0 3
2803: PPUSH
2804: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2808: LD_ADDR_VAR 0 2
2812: PUSH
2813: LD_VAR 0 3
2817: PPUSH
2818: LD_INT 25
2820: PUSH
2821: LD_INT 1
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: PPUSH
2828: CALL_OW 72
2832: PUSH
2833: FOR_IN
2834: IFFALSE 2874
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2836: LD_VAR 0 2
2840: PPUSH
2841: LD_INT 20
2843: PPUSH
2844: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2848: LD_VAR 0 2
2852: PPUSH
2853: LD_INT 147
2855: PPUSH
2856: LD_INT 45
2858: PPUSH
2859: CALL_OW 178
// AddComCrawl ( i ) ;
2863: LD_VAR 0 2
2867: PPUSH
2868: CALL_OW 197
// end ;
2872: GO 2833
2874: POP
2875: POP
// repeat wait ( 0 0$1 ) ;
2876: LD_INT 35
2878: PPUSH
2879: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2883: LD_EXP 50
2887: PPUSH
2888: LD_INT 110
2890: PPUSH
2891: LD_INT 10
2893: PPUSH
2894: CALL_OW 307
2898: PUSH
2899: LD_EXP 50
2903: PPUSH
2904: CALL_OW 305
2908: NOT
2909: OR
2910: IFFALSE 2876
// ComStop ( Burlak ) ;
2912: LD_EXP 47
2916: PPUSH
2917: CALL_OW 141
// AddComHold ( Burlak ) ;
2921: LD_EXP 47
2925: PPUSH
2926: CALL_OW 200
// end ; end_of_file
2930: LD_VAR 0 1
2934: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2935: LD_INT 0
2937: PPUSH
2938: PPUSH
2939: PPUSH
2940: PPUSH
2941: PPUSH
// uc_side := 3 ;
2942: LD_ADDR_OWVAR 20
2946: PUSH
2947: LD_INT 3
2949: ST_TO_ADDR
// uc_nation := 3 ;
2950: LD_ADDR_OWVAR 21
2954: PUSH
2955: LD_INT 3
2957: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2958: LD_ADDR_EXP 51
2962: PUSH
2963: LD_INT 47
2965: PPUSH
2966: LD_INT 4
2968: PPUSH
2969: LD_STRING 
2971: PPUSH
2972: LD_INT 7
2974: PUSH
2975: LD_INT 8
2977: PUSH
2978: LD_INT 9
2980: PUSH
2981: LD_INT 10
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_OWVAR 67
2994: ARRAY
2995: PPUSH
2996: LD_INT 10000
2998: PUSH
2999: LD_INT 3000
3001: PUSH
3002: LD_INT 300
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: LIST
3009: PPUSH
3010: LD_INT 9
3012: PUSH
3013: LD_INT 5
3015: PUSH
3016: LD_INT 6
3018: PUSH
3019: LD_INT 6
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 23148 0 6
3032: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3033: LD_ADDR_EXP 60
3037: PUSH
3038: LD_EXP 60
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_EXP 51
3050: PPUSH
3051: CALL_OW 1
3055: ST_TO_ADDR
// tmp := [ ] ;
3056: LD_ADDR_VAR 0 4
3060: PUSH
3061: EMPTY
3062: ST_TO_ADDR
// for i = 1 to 4 do
3063: LD_ADDR_VAR 0 2
3067: PUSH
3068: DOUBLE
3069: LD_INT 1
3071: DEC
3072: ST_TO_ADDR
3073: LD_INT 4
3075: PUSH
3076: FOR_TO
3077: IFFALSE 3170
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3079: LD_INT 22
3081: PPUSH
3082: LD_INT 3
3084: PPUSH
3085: LD_INT 3
3087: PPUSH
3088: LD_INT 43
3090: PUSH
3091: LD_INT 45
3093: PUSH
3094: LD_INT 45
3096: PUSH
3097: LD_INT 44
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: LIST
3104: LIST
3105: PUSH
3106: LD_VAR 0 2
3110: PUSH
3111: LD_INT 4
3113: MOD
3114: PUSH
3115: LD_INT 1
3117: PLUS
3118: ARRAY
3119: PPUSH
3120: LD_INT 100
3122: PPUSH
3123: CALL 19702 0 5
// veh := CreateVehicle ;
3127: LD_ADDR_VAR 0 3
3131: PUSH
3132: CALL_OW 45
3136: ST_TO_ADDR
// tmp := tmp ^ veh ;
3137: LD_ADDR_VAR 0 4
3141: PUSH
3142: LD_VAR 0 4
3146: PUSH
3147: LD_VAR 0 3
3151: ADD
3152: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3153: LD_VAR 0 3
3157: PPUSH
3158: LD_INT 2
3160: PPUSH
3161: LD_INT 0
3163: PPUSH
3164: CALL_OW 49
// end ;
3168: GO 3076
3170: POP
3171: POP
// russian_guard := tmp ;
3172: LD_ADDR_EXP 52
3176: PUSH
3177: LD_VAR 0 4
3181: ST_TO_ADDR
// if Difficulty >= 3 then
3182: LD_OWVAR 67
3186: PUSH
3187: LD_INT 3
3189: GREATEREQUAL
3190: IFFALSE 3254
// begin bc_type := b_breastwork ;
3192: LD_ADDR_OWVAR 42
3196: PUSH
3197: LD_INT 31
3199: ST_TO_ADDR
// bc_level := 10 ;
3200: LD_ADDR_OWVAR 43
3204: PUSH
3205: LD_INT 10
3207: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3208: LD_ADDR_VAR 0 5
3212: PUSH
3213: LD_INT 96
3215: PPUSH
3216: LD_INT 105
3218: PPUSH
3219: LD_INT 3
3221: PPUSH
3222: CALL_OW 47
3226: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3227: LD_INT 0
3229: PPUSH
3230: LD_INT 9
3232: PPUSH
3233: LD_INT 10
3235: PPUSH
3236: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3240: CALL_OW 44
3244: PPUSH
3245: LD_VAR 0 5
3249: PPUSH
3250: CALL_OW 52
// end ; end ;
3254: LD_VAR 0 1
3258: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3259: LD_INT 47
3261: PPUSH
3262: CALL_OW 302
3266: PUSH
3267: LD_EXP 6
3271: AND
3272: IFFALSE 3961
3274: GO 3276
3276: DISABLE
3277: LD_INT 0
3279: PPUSH
3280: PPUSH
3281: PPUSH
3282: PPUSH
3283: PPUSH
3284: PPUSH
3285: PPUSH
// begin enable ;
3286: ENABLE
// base := 2 ;
3287: LD_ADDR_VAR 0 2
3291: PUSH
3292: LD_INT 2
3294: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3295: LD_ADDR_VAR 0 4
3299: PUSH
3300: LD_INT 0
3302: PUSH
3303: LD_INT 0
3305: PUSH
3306: LD_INT 0
3308: PUSH
3309: LD_INT 0
3311: PUSH
3312: LD_INT 0
3314: PUSH
3315: LD_INT 0
3317: PUSH
3318: LD_INT 0
3320: PUSH
3321: LD_INT 0
3323: PUSH
3324: LD_INT 1
3326: PUSH
3327: LD_INT 0
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: LIST
3334: LIST
3335: LIST
3336: LIST
3337: LIST
3338: LIST
3339: LIST
3340: LIST
3341: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3342: LD_ADDR_VAR 0 3
3346: PUSH
3347: LD_INT 22
3349: PUSH
3350: LD_INT 1
3352: PUSH
3353: LD_INT 3
3355: PUSH
3356: LD_INT 45
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: LIST
3364: PUSH
3365: LD_INT 21
3367: PUSH
3368: LD_INT 1
3370: PUSH
3371: LD_INT 3
3373: PUSH
3374: LD_INT 45
3376: PUSH
3377: EMPTY
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_INT 22
3385: PUSH
3386: LD_INT 1
3388: PUSH
3389: LD_INT 3
3391: PUSH
3392: LD_INT 45
3394: PUSH
3395: EMPTY
3396: LIST
3397: LIST
3398: LIST
3399: LIST
3400: PUSH
3401: LD_INT 23
3403: PUSH
3404: LD_INT 1
3406: PUSH
3407: LD_INT 3
3409: PUSH
3410: LD_INT 46
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: LIST
3423: LIST
3424: ST_TO_ADDR
// amount := Difficulty ;
3425: LD_ADDR_VAR 0 7
3429: PUSH
3430: LD_OWVAR 67
3434: ST_TO_ADDR
// if tick > 30 30$00 then
3435: LD_OWVAR 1
3439: PUSH
3440: LD_INT 63000
3442: GREATER
3443: IFFALSE 3480
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3445: LD_ADDR_VAR 0 7
3449: PUSH
3450: LD_VAR 0 7
3454: PUSH
3455: LD_INT 2
3457: PUSH
3458: LD_INT 3
3460: PUSH
3461: LD_INT 4
3463: PUSH
3464: LD_INT 4
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: PUSH
3473: LD_OWVAR 67
3477: ARRAY
3478: PLUS
3479: ST_TO_ADDR
// for i = 1 to amount do
3480: LD_ADDR_VAR 0 1
3484: PUSH
3485: DOUBLE
3486: LD_INT 1
3488: DEC
3489: ST_TO_ADDR
3490: LD_VAR 0 7
3494: PUSH
3495: FOR_TO
3496: IFFALSE 3584
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: LD_VAR 0 3
3507: PPUSH
3508: LD_VAR 0 3
3512: PUSH
3513: LD_INT 1
3515: PLUS
3516: PPUSH
3517: LD_INT 23
3519: PUSH
3520: LD_INT 24
3522: PUSH
3523: EMPTY
3524: LIST
3525: LIST
3526: PUSH
3527: LD_INT 1
3529: PPUSH
3530: LD_INT 2
3532: PPUSH
3533: CALL_OW 12
3537: ARRAY
3538: PUSH
3539: LD_INT 1
3541: PUSH
3542: LD_INT 3
3544: PUSH
3545: LD_INT 46
3547: PUSH
3548: LD_INT 47
3550: PUSH
3551: LD_INT 45
3553: PUSH
3554: EMPTY
3555: LIST
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 1
3561: PPUSH
3562: LD_INT 3
3564: PPUSH
3565: CALL_OW 12
3569: ARRAY
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: PPUSH
3577: CALL_OW 2
3581: ST_TO_ADDR
3582: GO 3495
3584: POP
3585: POP
// MC_InsertProduceList ( base , tmp ) ;
3586: LD_VAR 0 2
3590: PPUSH
3591: LD_VAR 0 3
3595: PPUSH
3596: CALL 79093 0 2
// repeat wait ( 0 0$1 ) ;
3600: LD_INT 35
3602: PPUSH
3603: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3607: LD_VAR 0 2
3611: PPUSH
3612: LD_INT 1
3614: PPUSH
3615: CALL 80511 0 2
3619: PUSH
3620: LD_VAR 0 7
3624: GREATEREQUAL
3625: IFFALSE 3600
// wait ( 0 0$30 ) ;
3627: LD_INT 1050
3629: PPUSH
3630: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3634: LD_ADDR_VAR 0 5
3638: PUSH
3639: LD_INT 71
3641: PUSH
3642: LD_INT 19
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 91
3651: PUSH
3652: LD_INT 67
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: PUSH
3659: LD_INT 52
3661: PUSH
3662: LD_INT 44
3664: PUSH
3665: EMPTY
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 68
3671: PUSH
3672: LD_INT 48
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3685: LD_ADDR_VAR 0 6
3689: PUSH
3690: LD_EXP 79
3694: PUSH
3695: LD_VAR 0 2
3699: ARRAY
3700: PUSH
3701: LD_EXP 79
3705: PUSH
3706: LD_VAR 0 2
3710: ARRAY
3711: PPUSH
3712: LD_INT 2
3714: PUSH
3715: LD_INT 34
3717: PUSH
3718: LD_INT 51
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: LD_INT 34
3727: PUSH
3728: LD_INT 52
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: LIST
3739: PPUSH
3740: CALL_OW 72
3744: DIFF
3745: ST_TO_ADDR
// if not attackers then
3746: LD_VAR 0 6
3750: NOT
3751: IFFALSE 3755
// exit ;
3753: GO 3961
// ru_attackers := attackers ;
3755: LD_ADDR_EXP 53
3759: PUSH
3760: LD_VAR 0 6
3764: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3765: LD_ADDR_EXP 79
3769: PUSH
3770: LD_EXP 79
3774: PPUSH
3775: LD_VAR 0 2
3779: PPUSH
3780: LD_EXP 79
3784: PUSH
3785: LD_VAR 0 2
3789: ARRAY
3790: PUSH
3791: LD_VAR 0 6
3795: DIFF
3796: PPUSH
3797: CALL_OW 1
3801: ST_TO_ADDR
// for i = 1 to attackers do
3802: LD_ADDR_VAR 0 1
3806: PUSH
3807: DOUBLE
3808: LD_INT 1
3810: DEC
3811: ST_TO_ADDR
3812: LD_VAR 0 6
3816: PUSH
3817: FOR_TO
3818: IFFALSE 3895
// begin case i mod 3 of 0 :
3820: LD_VAR 0 1
3824: PUSH
3825: LD_INT 3
3827: MOD
3828: PUSH
3829: LD_INT 0
3831: DOUBLE
3832: EQUAL
3833: IFTRUE 3837
3835: GO 3840
3837: POP
// ; 1 :
3838: GO 3893
3840: LD_INT 1
3842: DOUBLE
3843: EQUAL
3844: IFTRUE 3848
3846: GO 3866
3848: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3849: LD_VAR 0 1
3853: PPUSH
3854: LD_INT 32
3856: PPUSH
3857: LD_INT 49
3859: PPUSH
3860: CALL_OW 114
3864: GO 3893
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3892
3874: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3875: LD_VAR 0 1
3879: PPUSH
3880: LD_INT 117
3882: PPUSH
3883: LD_INT 107
3885: PPUSH
3886: CALL_OW 114
3890: GO 3893
3892: POP
// end ;
3893: GO 3817
3895: POP
3896: POP
// repeat wait ( 0 0$1 ) ;
3897: LD_INT 35
3899: PPUSH
3900: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3904: LD_VAR 0 6
3908: PPUSH
3909: LD_INT 60
3911: PUSH
3912: EMPTY
3913: LIST
3914: PPUSH
3915: CALL_OW 72
3919: NOT
3920: IFFALSE 3897
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3922: LD_VAR 0 2
3926: PPUSH
3927: LD_VAR 0 6
3931: PPUSH
3932: LD_VAR 0 5
3936: PPUSH
3937: LD_VAR 0 4
3941: PPUSH
3942: CALL 79278 0 4
// if not first_attack then
3946: LD_EXP 7
3950: NOT
3951: IFFALSE 3961
// first_attack := true ;
3953: LD_ADDR_EXP 7
3957: PUSH
3958: LD_INT 1
3960: ST_TO_ADDR
// end ; end_of_file
3961: PPOPN 7
3963: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3964: LD_INT 0
3966: PPUSH
3967: PPUSH
3968: PPUSH
3969: PPUSH
3970: PPUSH
3971: PPUSH
3972: PPUSH
// uc_side := 2 ;
3973: LD_ADDR_OWVAR 20
3977: PUSH
3978: LD_INT 2
3980: ST_TO_ADDR
// uc_nation := 2 ;
3981: LD_ADDR_OWVAR 21
3985: PUSH
3986: LD_INT 2
3988: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3989: LD_ADDR_EXP 56
3993: PUSH
3994: LD_STRING Abdul
3996: PPUSH
3997: CALL_OW 25
4001: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4002: LD_EXP 56
4006: PPUSH
4007: LD_INT 11
4009: PPUSH
4010: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4014: LD_EXP 56
4018: PPUSH
4019: LD_INT 1
4021: PPUSH
4022: CALL_OW 52
// vc_chassis := 31 ;
4026: LD_ADDR_OWVAR 37
4030: PUSH
4031: LD_INT 31
4033: ST_TO_ADDR
// vc_control := control_rider ;
4034: LD_ADDR_OWVAR 38
4038: PUSH
4039: LD_INT 4
4041: ST_TO_ADDR
// mastodont := CreateVehicle ;
4042: LD_ADDR_EXP 57
4046: PUSH
4047: CALL_OW 45
4051: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4052: LD_EXP 57
4056: PPUSH
4057: LD_INT 153
4059: PPUSH
4060: LD_INT 71
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 48
// InitVc ;
4070: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4074: LD_ADDR_EXP 54
4078: PUSH
4079: LD_INT 1
4081: PPUSH
4082: LD_INT 3
4084: PPUSH
4085: LD_STRING 
4087: PPUSH
4088: LD_INT 7
4090: PUSH
4091: LD_INT 8
4093: PUSH
4094: LD_INT 9
4096: PUSH
4097: LD_INT 10
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: PUSH
4106: LD_OWVAR 67
4110: ARRAY
4111: PPUSH
4112: LD_INT 5000
4114: PUSH
4115: LD_INT 1000
4117: PUSH
4118: LD_INT 300
4120: PUSH
4121: EMPTY
4122: LIST
4123: LIST
4124: LIST
4125: PPUSH
4126: LD_INT 18
4128: PUSH
4129: LD_INT 5
4131: PUSH
4132: LD_INT 6
4134: PUSH
4135: LD_INT 9
4137: PUSH
4138: EMPTY
4139: LIST
4140: LIST
4141: LIST
4142: LIST
4143: PPUSH
4144: CALL 23148 0 6
4148: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4149: LD_ADDR_EXP 60
4153: PUSH
4154: LD_EXP 60
4158: PPUSH
4159: LD_INT 1
4161: PPUSH
4162: LD_EXP 54
4166: PPUSH
4167: CALL_OW 1
4171: ST_TO_ADDR
// tmp := [ ] ;
4172: LD_ADDR_VAR 0 4
4176: PUSH
4177: EMPTY
4178: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4179: LD_ADDR_OWVAR 37
4183: PUSH
4184: LD_INT 14
4186: ST_TO_ADDR
// vc_engine := engine_siberite ;
4187: LD_ADDR_OWVAR 39
4191: PUSH
4192: LD_INT 3
4194: ST_TO_ADDR
// vc_control := control_manual ;
4195: LD_ADDR_OWVAR 38
4199: PUSH
4200: LD_INT 1
4202: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4203: LD_ADDR_OWVAR 40
4207: PUSH
4208: LD_INT 31
4210: ST_TO_ADDR
// for i = 1 to 3 do
4211: LD_ADDR_VAR 0 2
4215: PUSH
4216: DOUBLE
4217: LD_INT 1
4219: DEC
4220: ST_TO_ADDR
4221: LD_INT 3
4223: PUSH
4224: FOR_TO
4225: IFFALSE 4473
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4227: LD_ADDR_VAR 0 5
4231: PUSH
4232: LD_INT 153
4234: PUSH
4235: LD_INT 71
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 155
4244: PUSH
4245: LD_INT 81
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_VAR 0 2
4260: PUSH
4261: LD_INT 2
4263: MOD
4264: PUSH
4265: LD_INT 1
4267: PLUS
4268: ARRAY
4269: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4270: LD_INT 0
4272: PPUSH
4273: LD_INT 3
4275: PPUSH
4276: LD_INT 7
4278: PUSH
4279: LD_INT 8
4281: PUSH
4282: LD_INT 10
4284: PUSH
4285: LD_INT 10
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: LIST
4292: LIST
4293: PUSH
4294: LD_OWVAR 67
4298: ARRAY
4299: PPUSH
4300: CALL_OW 380
// un := CreateVehicle ;
4304: LD_ADDR_VAR 0 6
4308: PUSH
4309: CALL_OW 45
4313: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4314: LD_VAR 0 6
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: LD_INT 5
4324: PPUSH
4325: CALL_OW 12
4329: PPUSH
4330: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4334: LD_VAR 0 6
4338: PPUSH
4339: LD_VAR 0 5
4343: PUSH
4344: LD_INT 1
4346: ARRAY
4347: PPUSH
4348: LD_VAR 0 5
4352: PUSH
4353: LD_INT 2
4355: ARRAY
4356: PPUSH
4357: LD_INT 6
4359: PPUSH
4360: LD_INT 0
4362: PPUSH
4363: CALL_OW 50
// un2 := CreateHuman ;
4367: LD_ADDR_VAR 0 7
4371: PUSH
4372: CALL_OW 44
4376: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4377: LD_VAR 0 7
4381: PPUSH
4382: LD_VAR 0 6
4386: PPUSH
4387: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4391: LD_ADDR_EXP 60
4395: PUSH
4396: LD_EXP 60
4400: PPUSH
4401: LD_INT 1
4403: PUSH
4404: LD_EXP 60
4408: PUSH
4409: LD_INT 1
4411: ARRAY
4412: PUSH
4413: LD_INT 1
4415: PLUS
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: LD_VAR 0 6
4425: PPUSH
4426: CALL 19824 0 3
4430: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4431: LD_ADDR_EXP 60
4435: PUSH
4436: LD_EXP 60
4440: PPUSH
4441: LD_INT 1
4443: PUSH
4444: LD_EXP 60
4448: PUSH
4449: LD_INT 1
4451: ARRAY
4452: PUSH
4453: LD_INT 1
4455: PLUS
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PPUSH
4461: LD_VAR 0 7
4465: PPUSH
4466: CALL 19824 0 3
4470: ST_TO_ADDR
// end ;
4471: GO 4224
4473: POP
4474: POP
// for i = 1 to 5 do
4475: LD_ADDR_VAR 0 2
4479: PUSH
4480: DOUBLE
4481: LD_INT 1
4483: DEC
4484: ST_TO_ADDR
4485: LD_INT 5
4487: PUSH
4488: FOR_TO
4489: IFFALSE 4582
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4491: LD_INT 14
4493: PPUSH
4494: LD_INT 3
4496: PPUSH
4497: LD_INT 1
4499: PPUSH
4500: LD_INT 25
4502: PUSH
4503: LD_INT 28
4505: PUSH
4506: LD_INT 28
4508: PUSH
4509: LD_INT 26
4511: PUSH
4512: EMPTY
4513: LIST
4514: LIST
4515: LIST
4516: LIST
4517: PUSH
4518: LD_VAR 0 2
4522: PUSH
4523: LD_INT 4
4525: MOD
4526: PUSH
4527: LD_INT 1
4529: PLUS
4530: ARRAY
4531: PPUSH
4532: LD_INT 100
4534: PPUSH
4535: CALL 19702 0 5
// veh := CreateVehicle ;
4539: LD_ADDR_VAR 0 3
4543: PUSH
4544: CALL_OW 45
4548: ST_TO_ADDR
// tmp := tmp ^ veh ;
4549: LD_ADDR_VAR 0 4
4553: PUSH
4554: LD_VAR 0 4
4558: PUSH
4559: LD_VAR 0 3
4563: ADD
4564: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4565: LD_VAR 0 3
4569: PPUSH
4570: LD_INT 1
4572: PPUSH
4573: LD_INT 0
4575: PPUSH
4576: CALL_OW 49
// end ;
4580: GO 4488
4582: POP
4583: POP
// arabian_guard := tmp ;
4584: LD_ADDR_EXP 55
4588: PUSH
4589: LD_VAR 0 4
4593: ST_TO_ADDR
// end ;
4594: LD_VAR 0 1
4598: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4599: LD_INT 22
4601: PUSH
4602: LD_INT 7
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: PUSH
4609: LD_INT 91
4611: PUSH
4612: LD_INT 1
4614: PUSH
4615: LD_INT 12
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: LIST
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: PPUSH
4627: CALL_OW 69
4631: PUSH
4632: LD_EXP 57
4636: PPUSH
4637: CALL_OW 256
4641: PUSH
4642: LD_INT 990
4644: LESS
4645: OR
4646: PUSH
4647: LD_EXP 56
4651: PPUSH
4652: CALL_OW 256
4656: PUSH
4657: LD_INT 990
4659: LESS
4660: OR
4661: IFFALSE 4804
4663: GO 4665
4665: DISABLE
// begin if IsInUnit ( Abdul ) then
4666: LD_EXP 56
4670: PPUSH
4671: CALL_OW 310
4675: IFFALSE 4686
// ComExitBuilding ( Abdul ) ;
4677: LD_EXP 56
4681: PPUSH
4682: CALL_OW 122
// if Mastodont then
4686: LD_EXP 57
4690: IFFALSE 4707
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4692: LD_EXP 57
4696: PPUSH
4697: LD_INT 205
4699: PPUSH
4700: LD_INT 132
4702: PPUSH
4703: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4707: LD_EXP 56
4711: PPUSH
4712: LD_INT 205
4714: PPUSH
4715: LD_INT 132
4717: PPUSH
4718: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4722: LD_INT 35
4724: PPUSH
4725: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4729: LD_EXP 56
4733: PPUSH
4734: LD_INT 21
4736: PPUSH
4737: CALL_OW 308
4741: IFFALSE 4722
// RemoveUnit ( Abdul ) ;
4743: LD_EXP 56
4747: PPUSH
4748: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4752: LD_INT 35
4754: PPUSH
4755: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4759: LD_EXP 57
4763: PPUSH
4764: LD_INT 21
4766: PPUSH
4767: CALL_OW 308
4771: PUSH
4772: LD_EXP 57
4776: PPUSH
4777: CALL_OW 301
4781: OR
4782: IFFALSE 4752
// if IsOk ( Mastodont ) then
4784: LD_EXP 57
4788: PPUSH
4789: CALL_OW 302
4793: IFFALSE 4804
// RemoveUnit ( Mastodont ) ;
4795: LD_EXP 57
4799: PPUSH
4800: CALL_OW 64
// end ;
4804: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4805: LD_EXP 56
4809: PPUSH
4810: CALL_OW 301
4814: PUSH
4815: LD_INT 22
4817: PUSH
4818: LD_INT 2
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: PUSH
4825: LD_INT 2
4827: PUSH
4828: LD_INT 25
4830: PUSH
4831: LD_INT 1
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: LD_INT 25
4840: PUSH
4841: LD_INT 2
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 25
4850: PUSH
4851: LD_INT 3
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 25
4860: PUSH
4861: LD_INT 4
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 25
4870: PUSH
4871: LD_INT 8
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PPUSH
4890: CALL_OW 69
4894: PUSH
4895: LD_INT 16
4897: PUSH
4898: LD_INT 19
4900: PUSH
4901: LD_INT 22
4903: PUSH
4904: LD_INT 22
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: LIST
4911: LIST
4912: PUSH
4913: LD_OWVAR 67
4917: ARRAY
4918: LESS
4919: OR
4920: IFFALSE 5593
4922: GO 4924
4924: DISABLE
4925: LD_INT 0
4927: PPUSH
4928: PPUSH
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
// begin MC_Kill ( 1 ) ;
4933: LD_INT 1
4935: PPUSH
4936: CALL 55115 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4940: LD_ADDR_VAR 0 2
4944: PUSH
4945: LD_INT 22
4947: PUSH
4948: LD_INT 2
4950: PUSH
4951: EMPTY
4952: LIST
4953: LIST
4954: PUSH
4955: LD_INT 2
4957: PUSH
4958: LD_INT 25
4960: PUSH
4961: LD_INT 1
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: PUSH
4968: LD_INT 25
4970: PUSH
4971: LD_INT 2
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: PUSH
4978: LD_INT 25
4980: PUSH
4981: LD_INT 3
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 25
4990: PUSH
4991: LD_INT 4
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 25
5000: PUSH
5001: LD_INT 8
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PPUSH
5020: CALL_OW 69
5024: ST_TO_ADDR
// for i in tmp do
5025: LD_ADDR_VAR 0 5
5029: PUSH
5030: LD_VAR 0 2
5034: PUSH
5035: FOR_IN
5036: IFFALSE 5052
// SetTag ( i , 10 ) ;
5038: LD_VAR 0 5
5042: PPUSH
5043: LD_INT 10
5045: PPUSH
5046: CALL_OW 109
5050: GO 5035
5052: POP
5053: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5054: LD_ADDR_VAR 0 3
5058: PUSH
5059: LD_INT 22
5061: PUSH
5062: LD_INT 2
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: PUSH
5069: LD_INT 21
5071: PUSH
5072: LD_INT 1
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: PUSH
5079: EMPTY
5080: LIST
5081: LIST
5082: PPUSH
5083: CALL_OW 69
5087: PUSH
5088: LD_VAR 0 2
5092: DIFF
5093: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5094: LD_ADDR_VAR 0 1
5098: PUSH
5099: LD_INT 22
5101: PUSH
5102: LD_INT 2
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PUSH
5109: LD_INT 21
5111: PUSH
5112: LD_INT 2
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 24
5121: PUSH
5122: LD_INT 300
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: LIST
5133: PPUSH
5134: CALL_OW 69
5138: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5139: LD_ADDR_VAR 0 4
5143: PUSH
5144: LD_VAR 0 1
5148: PPUSH
5149: LD_INT 33
5151: PUSH
5152: LD_INT 1
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 58
5161: PUSH
5162: EMPTY
5163: LIST
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PPUSH
5169: CALL_OW 72
5173: ST_TO_ADDR
// for i in tmp do
5174: LD_ADDR_VAR 0 5
5178: PUSH
5179: LD_VAR 0 2
5183: PUSH
5184: FOR_IN
5185: IFFALSE 5369
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5187: LD_VAR 0 5
5191: PUSH
5192: LD_INT 55
5194: PUSH
5195: EMPTY
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: IN
5203: IFFALSE 5222
// begin AddComMoveXY ( i , 209 , 132 ) ;
5205: LD_VAR 0 5
5209: PPUSH
5210: LD_INT 209
5212: PPUSH
5213: LD_INT 132
5215: PPUSH
5216: CALL_OW 171
// continue ;
5220: GO 5184
// end ; if IsInUnit ( i ) then
5222: LD_VAR 0 5
5226: PPUSH
5227: CALL_OW 310
5231: IFFALSE 5249
// begin ComExitBuilding ( i ) ;
5233: LD_VAR 0 5
5237: PPUSH
5238: CALL_OW 122
// wait ( 3 ) ;
5242: LD_INT 3
5244: PPUSH
5245: CALL_OW 67
// end ; if tmp_empty then
5249: LD_VAR 0 4
5253: IFFALSE 5352
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5255: LD_VAR 0 5
5259: PPUSH
5260: LD_VAR 0 4
5264: PPUSH
5265: LD_VAR 0 5
5269: PPUSH
5270: CALL_OW 74
5274: PPUSH
5275: CALL_OW 296
5279: PUSH
5280: LD_INT 25
5282: LESS
5283: IFFALSE 5352
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5285: LD_ADDR_VAR 0 6
5289: PUSH
5290: LD_VAR 0 4
5294: PPUSH
5295: LD_VAR 0 5
5299: PPUSH
5300: CALL_OW 74
5304: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5305: LD_VAR 0 5
5309: PPUSH
5310: LD_VAR 0 6
5314: PPUSH
5315: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5319: LD_VAR 0 5
5323: PPUSH
5324: LD_INT 209
5326: PPUSH
5327: LD_INT 132
5329: PPUSH
5330: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5334: LD_ADDR_VAR 0 4
5338: PUSH
5339: LD_VAR 0 4
5343: PUSH
5344: LD_VAR 0 6
5348: DIFF
5349: ST_TO_ADDR
// continue ;
5350: GO 5184
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5352: LD_VAR 0 5
5356: PPUSH
5357: LD_INT 201
5359: PPUSH
5360: LD_INT 132
5362: PPUSH
5363: CALL_OW 171
// end ;
5367: GO 5184
5369: POP
5370: POP
// for i in tmp_ape do
5371: LD_ADDR_VAR 0 5
5375: PUSH
5376: LD_VAR 0 3
5380: PUSH
5381: FOR_IN
5382: IFFALSE 5421
// begin if IsInUnit ( i ) then
5384: LD_VAR 0 5
5388: PPUSH
5389: CALL_OW 310
5393: IFFALSE 5404
// ComExitBuilding ( i ) ;
5395: LD_VAR 0 5
5399: PPUSH
5400: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5404: LD_VAR 0 5
5408: PPUSH
5409: LD_INT 201
5411: PPUSH
5412: LD_INT 132
5414: PPUSH
5415: CALL_OW 171
// end ;
5419: GO 5381
5421: POP
5422: POP
// repeat wait ( 0 0$1 ) ;
5423: LD_INT 35
5425: PPUSH
5426: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5430: LD_ADDR_VAR 0 5
5434: PUSH
5435: LD_VAR 0 2
5439: PUSH
5440: LD_VAR 0 3
5444: UNION
5445: PUSH
5446: LD_VAR 0 1
5450: UNION
5451: PUSH
5452: FOR_IN
5453: IFFALSE 5484
// if not HasTask ( i ) then
5455: LD_VAR 0 5
5459: PPUSH
5460: CALL_OW 314
5464: NOT
5465: IFFALSE 5482
// ComMoveXY ( i , 201 , 132 ) ;
5467: LD_VAR 0 5
5471: PPUSH
5472: LD_INT 201
5474: PPUSH
5475: LD_INT 132
5477: PPUSH
5478: CALL_OW 111
5482: GO 5452
5484: POP
5485: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5486: LD_INT 21
5488: PPUSH
5489: LD_INT 22
5491: PUSH
5492: LD_INT 2
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: PPUSH
5499: CALL_OW 70
5503: IFFALSE 5544
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5505: LD_ADDR_VAR 0 5
5509: PUSH
5510: LD_INT 21
5512: PPUSH
5513: LD_INT 22
5515: PUSH
5516: LD_INT 2
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 70
5527: PUSH
5528: FOR_IN
5529: IFFALSE 5542
// RemoveUnit ( i ) ;
5531: LD_VAR 0 5
5535: PPUSH
5536: CALL_OW 64
5540: GO 5528
5542: POP
5543: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5544: LD_INT 22
5546: PUSH
5547: LD_INT 2
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 2
5556: PUSH
5557: LD_INT 21
5559: PUSH
5560: LD_INT 1
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: LD_INT 21
5569: PUSH
5570: LD_INT 2
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PUSH
5577: EMPTY
5578: LIST
5579: LIST
5580: LIST
5581: PUSH
5582: EMPTY
5583: LIST
5584: LIST
5585: PPUSH
5586: CALL_OW 69
5590: NOT
5591: IFFALSE 5423
// end ;
5593: PPOPN 6
5595: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5596: LD_EXP 9
5600: PUSH
5601: LD_INT 92
5603: PPUSH
5604: LD_INT 40
5606: PPUSH
5607: CALL_OW 428
5611: PPUSH
5612: CALL_OW 266
5616: PUSH
5617: LD_INT 30
5619: EQUAL
5620: AND
5621: IFFALSE 5817
5623: GO 5625
5625: DISABLE
5626: LD_INT 0
5628: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5629: LD_ADDR_VAR 0 1
5633: PUSH
5634: LD_EXP 60
5638: PUSH
5639: LD_INT 1
5641: ARRAY
5642: PPUSH
5643: LD_INT 25
5645: PUSH
5646: LD_INT 4
5648: PUSH
5649: EMPTY
5650: LIST
5651: LIST
5652: PPUSH
5653: CALL_OW 72
5657: ST_TO_ADDR
// if not sci then
5658: LD_VAR 0 1
5662: NOT
5663: IFFALSE 5667
// exit ;
5665: GO 5817
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5667: LD_ADDR_EXP 60
5671: PUSH
5672: LD_EXP 60
5676: PPUSH
5677: LD_INT 1
5679: PPUSH
5680: LD_EXP 60
5684: PUSH
5685: LD_INT 1
5687: ARRAY
5688: PUSH
5689: LD_VAR 0 1
5693: PUSH
5694: LD_INT 1
5696: ARRAY
5697: DIFF
5698: PPUSH
5699: CALL_OW 1
5703: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5704: LD_VAR 0 1
5708: PUSH
5709: LD_INT 1
5711: ARRAY
5712: PPUSH
5713: CALL_OW 310
5717: IFFALSE 5732
// ComExitBuilding ( sci [ 1 ] ) ;
5719: LD_VAR 0 1
5723: PUSH
5724: LD_INT 1
5726: ARRAY
5727: PPUSH
5728: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5732: LD_INT 2
5734: PPUSH
5735: LD_INT 105
5737: PPUSH
5738: LD_INT 14
5740: PPUSH
5741: LD_INT 20
5743: PPUSH
5744: CALL 20720 0 4
5748: PUSH
5749: LD_INT 4
5751: ARRAY
5752: PUSH
5753: LD_INT 10
5755: LESS
5756: IFFALSE 5779
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5758: LD_VAR 0 1
5762: PUSH
5763: LD_INT 1
5765: ARRAY
5766: PPUSH
5767: LD_INT 105
5769: PPUSH
5770: LD_INT 14
5772: PPUSH
5773: CALL_OW 171
5777: GO 5798
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5779: LD_VAR 0 1
5783: PUSH
5784: LD_INT 1
5786: ARRAY
5787: PPUSH
5788: LD_INT 118
5790: PPUSH
5791: LD_INT 77
5793: PPUSH
5794: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5798: LD_VAR 0 1
5802: PUSH
5803: LD_INT 1
5805: ARRAY
5806: PPUSH
5807: LD_INT 92
5809: PPUSH
5810: LD_INT 40
5812: PPUSH
5813: CALL_OW 218
// end ;
5817: PPOPN 1
5819: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5820: LD_INT 1
5822: PPUSH
5823: CALL_OW 302
5827: PUSH
5828: LD_EXP 9
5832: AND
5833: IFFALSE 6312
5835: GO 5837
5837: DISABLE
5838: LD_INT 0
5840: PPUSH
5841: PPUSH
5842: PPUSH
5843: PPUSH
5844: PPUSH
5845: PPUSH
// begin enable ;
5846: ENABLE
// base := 1 ;
5847: LD_ADDR_VAR 0 2
5851: PUSH
5852: LD_INT 1
5854: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5855: LD_ADDR_VAR 0 4
5859: PUSH
5860: LD_INT 0
5862: PUSH
5863: LD_INT 0
5865: PUSH
5866: LD_INT 0
5868: PUSH
5869: LD_INT 0
5871: PUSH
5872: LD_INT 0
5874: PUSH
5875: LD_INT 0
5877: PUSH
5878: LD_INT 0
5880: PUSH
5881: LD_INT 0
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 0
5889: PUSH
5890: EMPTY
5891: LIST
5892: LIST
5893: LIST
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5902: LD_ADDR_VAR 0 3
5906: PUSH
5907: LD_INT 14
5909: PUSH
5910: LD_INT 1
5912: PUSH
5913: LD_INT 2
5915: PUSH
5916: LD_INT 26
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 14
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 28
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 13
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 29
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5966: LD_ADDR_VAR 0 1
5970: PUSH
5971: DOUBLE
5972: LD_INT 1
5974: DEC
5975: ST_TO_ADDR
5976: LD_OWVAR 67
5980: PUSH
5981: LD_OWVAR 1
5985: PUSH
5986: LD_INT 21000
5988: DIV
5989: PLUS
5990: PUSH
5991: FOR_TO
5992: IFFALSE 6084
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5994: LD_ADDR_VAR 0 3
5998: PUSH
5999: LD_VAR 0 3
6003: PPUSH
6004: LD_VAR 0 3
6008: PUSH
6009: LD_INT 1
6011: PLUS
6012: PPUSH
6013: LD_INT 13
6015: PUSH
6016: LD_INT 14
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 1
6025: PPUSH
6026: LD_INT 2
6028: PPUSH
6029: CALL_OW 12
6033: ARRAY
6034: PUSH
6035: LD_INT 1
6037: PUSH
6038: LD_INT 2
6040: PUSH
6041: LD_INT 28
6043: PUSH
6044: LD_INT 29
6046: PUSH
6047: LD_INT 25
6049: PUSH
6050: LD_INT 26
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: LD_INT 1
6061: PPUSH
6062: LD_INT 4
6064: PPUSH
6065: CALL_OW 12
6069: ARRAY
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: LIST
6076: PPUSH
6077: CALL_OW 2
6081: ST_TO_ADDR
6082: GO 5991
6084: POP
6085: POP
// MC_InsertProduceList ( base , tmp ) ;
6086: LD_VAR 0 2
6090: PPUSH
6091: LD_VAR 0 3
6095: PPUSH
6096: CALL 79093 0 2
// repeat wait ( 0 0$1 ) ;
6100: LD_INT 35
6102: PPUSH
6103: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6107: LD_EXP 79
6111: PUSH
6112: LD_VAR 0 2
6116: ARRAY
6117: PUSH
6118: LD_INT 6
6120: GREATER
6121: IFFALSE 6100
// wait ( 0 0$20 ) ;
6123: LD_INT 700
6125: PPUSH
6126: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6130: LD_ADDR_VAR 0 5
6134: PUSH
6135: LD_INT 124
6137: PUSH
6138: LD_INT 85
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: PUSH
6145: LD_INT 90
6147: PUSH
6148: LD_INT 61
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: PUSH
6155: LD_INT 69
6157: PUSH
6158: LD_INT 48
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PUSH
6165: LD_INT 68
6167: PUSH
6168: LD_INT 48
6170: PUSH
6171: EMPTY
6172: LIST
6173: LIST
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6181: LD_ADDR_VAR 0 6
6185: PUSH
6186: LD_EXP 79
6190: PUSH
6191: LD_VAR 0 2
6195: ARRAY
6196: PUSH
6197: LD_EXP 79
6201: PUSH
6202: LD_VAR 0 2
6206: ARRAY
6207: PPUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 34
6213: PUSH
6214: LD_INT 32
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: PUSH
6221: LD_INT 34
6223: PUSH
6224: LD_EXP 110
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: CALL_OW 72
6242: DIFF
6243: ST_TO_ADDR
// if not attackers then
6244: LD_VAR 0 6
6248: NOT
6249: IFFALSE 6253
// exit ;
6251: GO 6312
// ar_attackers := attackers ;
6253: LD_ADDR_EXP 11
6257: PUSH
6258: LD_VAR 0 6
6262: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6263: LD_INT 35
6265: PPUSH
6266: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6270: LD_VAR 0 6
6274: PPUSH
6275: LD_INT 60
6277: PUSH
6278: EMPTY
6279: LIST
6280: PPUSH
6281: CALL_OW 72
6285: NOT
6286: IFFALSE 6263
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6288: LD_VAR 0 2
6292: PPUSH
6293: LD_VAR 0 6
6297: PPUSH
6298: LD_VAR 0 5
6302: PPUSH
6303: LD_VAR 0 4
6307: PPUSH
6308: CALL 79278 0 4
// end ;
6312: PPOPN 6
6314: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6315: LD_INT 1
6317: PPUSH
6318: CALL_OW 302
6322: PUSH
6323: LD_EXP 9
6327: AND
6328: PUSH
6329: LD_EXP 50
6333: PPUSH
6334: LD_INT 22
6336: PPUSH
6337: CALL_OW 308
6341: AND
6342: PUSH
6343: LD_INT 1
6345: PPUSH
6346: CALL 79441 0 1
6350: PUSH
6351: LD_INT 0
6353: EQUAL
6354: AND
6355: PUSH
6356: LD_EXP 11
6360: NOT
6361: AND
6362: IFFALSE 6850
6364: GO 6366
6366: DISABLE
6367: LD_INT 0
6369: PPUSH
6370: PPUSH
6371: PPUSH
6372: PPUSH
6373: PPUSH
6374: PPUSH
6375: PPUSH
// begin base := 1 ;
6376: LD_ADDR_VAR 0 2
6380: PUSH
6381: LD_INT 1
6383: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6384: LD_ADDR_VAR 0 4
6388: PUSH
6389: LD_INT 0
6391: PUSH
6392: LD_INT 0
6394: PUSH
6395: LD_INT 0
6397: PUSH
6398: LD_INT 0
6400: PUSH
6401: LD_INT 0
6403: PUSH
6404: LD_INT 0
6406: PUSH
6407: LD_INT 0
6409: PUSH
6410: LD_INT 0
6412: PUSH
6413: LD_INT 1
6415: PUSH
6416: LD_INT 0
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6431: LD_ADDR_VAR 0 3
6435: PUSH
6436: LD_INT 13
6438: PUSH
6439: LD_INT 1
6441: PUSH
6442: LD_INT 2
6444: PUSH
6445: LD_INT 28
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 13
6456: PUSH
6457: LD_INT 1
6459: PUSH
6460: LD_INT 2
6462: PUSH
6463: LD_INT 27
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 13
6474: PUSH
6475: LD_INT 1
6477: PUSH
6478: LD_INT 2
6480: PUSH
6481: LD_INT 25
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 11
6492: PUSH
6493: LD_INT 2
6495: PUSH
6496: LD_INT 2
6498: PUSH
6499: LD_INT 24
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 11
6510: PUSH
6511: LD_INT 2
6513: PUSH
6514: LD_INT 2
6516: PUSH
6517: LD_INT 24
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: LIST
6532: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6533: LD_VAR 0 2
6537: PPUSH
6538: LD_VAR 0 3
6542: PPUSH
6543: CALL 79093 0 2
// repeat wait ( 0 0$1 ) ;
6547: LD_INT 35
6549: PPUSH
6550: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6554: LD_EXP 79
6558: PUSH
6559: LD_VAR 0 2
6563: ARRAY
6564: PUSH
6565: LD_INT 6
6567: GREATEREQUAL
6568: IFFALSE 6547
// wait ( 0 0$20 ) ;
6570: LD_INT 700
6572: PPUSH
6573: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6577: LD_ADDR_VAR 0 5
6581: PUSH
6582: LD_INT 119
6584: PUSH
6585: LD_INT 9
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PUSH
6592: EMPTY
6593: LIST
6594: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6595: LD_ADDR_VAR 0 6
6599: PUSH
6600: LD_EXP 79
6604: PUSH
6605: LD_VAR 0 2
6609: ARRAY
6610: PUSH
6611: LD_EXP 79
6615: PUSH
6616: LD_VAR 0 2
6620: ARRAY
6621: PPUSH
6622: LD_INT 2
6624: PUSH
6625: LD_INT 34
6627: PUSH
6628: LD_INT 32
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: PUSH
6635: LD_INT 34
6637: PUSH
6638: LD_EXP 110
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: PPUSH
6652: CALL_OW 72
6656: DIFF
6657: ST_TO_ADDR
// if not attackers then
6658: LD_VAR 0 6
6662: NOT
6663: IFFALSE 6667
// exit ;
6665: GO 6850
// uc_side := 2 ;
6667: LD_ADDR_OWVAR 20
6671: PUSH
6672: LD_INT 2
6674: ST_TO_ADDR
// uc_nation := 2 ;
6675: LD_ADDR_OWVAR 21
6679: PUSH
6680: LD_INT 2
6682: ST_TO_ADDR
// InitHc ;
6683: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
6687: LD_ADDR_VAR 0 1
6691: PUSH
6692: DOUBLE
6693: LD_INT 1
6695: DEC
6696: ST_TO_ADDR
6697: LD_INT 4
6699: PUSH
6700: LD_INT 5
6702: PUSH
6703: LD_INT 6
6705: PUSH
6706: LD_INT 6
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: PUSH
6715: LD_OWVAR 67
6719: ARRAY
6720: PUSH
6721: FOR_TO
6722: IFFALSE 6799
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6724: LD_INT 0
6726: PPUSH
6727: LD_INT 15
6729: PUSH
6730: LD_INT 17
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PUSH
6737: LD_INT 1
6739: PPUSH
6740: LD_INT 2
6742: PPUSH
6743: CALL_OW 12
6747: ARRAY
6748: PPUSH
6749: LD_INT 8
6751: PPUSH
6752: CALL_OW 380
// un := CreateHuman ;
6756: LD_ADDR_VAR 0 7
6760: PUSH
6761: CALL_OW 44
6765: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6766: LD_VAR 0 7
6770: PPUSH
6771: LD_INT 23
6773: PPUSH
6774: LD_INT 0
6776: PPUSH
6777: CALL_OW 49
// attackers := attackers union un ;
6781: LD_ADDR_VAR 0 6
6785: PUSH
6786: LD_VAR 0 6
6790: PUSH
6791: LD_VAR 0 7
6795: UNION
6796: ST_TO_ADDR
// end ;
6797: GO 6721
6799: POP
6800: POP
// repeat wait ( 0 0$1 ) ;
6801: LD_INT 35
6803: PPUSH
6804: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6808: LD_VAR 0 6
6812: PPUSH
6813: LD_INT 60
6815: PUSH
6816: EMPTY
6817: LIST
6818: PPUSH
6819: CALL_OW 72
6823: NOT
6824: IFFALSE 6801
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6826: LD_VAR 0 2
6830: PPUSH
6831: LD_VAR 0 6
6835: PPUSH
6836: LD_VAR 0 5
6840: PPUSH
6841: LD_VAR 0 4
6845: PPUSH
6846: CALL 79278 0 4
// end ; end_of_file
6850: PPOPN 7
6852: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
6859: PPUSH
6860: PPUSH
// uc_side := 1 ;
6861: LD_ADDR_OWVAR 20
6865: PUSH
6866: LD_INT 1
6868: ST_TO_ADDR
// uc_nation := 1 ;
6869: LD_ADDR_OWVAR 21
6873: PUSH
6874: LD_INT 1
6876: ST_TO_ADDR
// InitHc ;
6877: CALL_OW 19
// InitVc ;
6881: CALL_OW 20
// tmp := [ ] ;
6885: LD_ADDR_VAR 0 3
6889: PUSH
6890: EMPTY
6891: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: DOUBLE
6898: LD_INT 1
6900: DEC
6901: ST_TO_ADDR
6902: LD_INT 6
6904: PUSH
6905: LD_INT 8
6907: PUSH
6908: LD_INT 10
6910: PUSH
6911: LD_INT 10
6913: PUSH
6914: EMPTY
6915: LIST
6916: LIST
6917: LIST
6918: LIST
6919: PUSH
6920: LD_OWVAR 67
6924: ARRAY
6925: PUSH
6926: FOR_TO
6927: IFFALSE 7201
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6929: LD_ADDR_VAR 0 5
6933: PUSH
6934: LD_INT 2
6936: PUSH
6937: LD_INT 4
6939: PUSH
6940: LD_INT 5
6942: PUSH
6943: EMPTY
6944: LIST
6945: LIST
6946: LIST
6947: PUSH
6948: LD_INT 1
6950: PPUSH
6951: LD_INT 3
6953: PPUSH
6954: CALL_OW 12
6958: ARRAY
6959: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6960: LD_VAR 0 5
6964: PUSH
6965: LD_INT 2
6967: DOUBLE
6968: EQUAL
6969: IFTRUE 6973
6971: GO 7007
6973: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
6974: LD_ADDR_VAR 0 6
6978: PUSH
6979: LD_INT 9
6981: PUSH
6982: LD_INT 5
6984: PUSH
6985: LD_INT 7
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: LIST
6992: PUSH
6993: LD_INT 1
6995: PPUSH
6996: LD_INT 3
6998: PPUSH
6999: CALL_OW 12
7003: ARRAY
7004: ST_TO_ADDR
7005: GO 7096
7007: LD_INT 4
7009: DOUBLE
7010: EQUAL
7011: IFTRUE 7015
7013: GO 7053
7015: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7016: LD_ADDR_VAR 0 6
7020: PUSH
7021: LD_INT 9
7023: PUSH
7024: LD_INT 6
7026: PUSH
7027: LD_INT 6
7029: PUSH
7030: LD_INT 7
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: LIST
7037: LIST
7038: PUSH
7039: LD_INT 1
7041: PPUSH
7042: LD_INT 4
7044: PPUSH
7045: CALL_OW 12
7049: ARRAY
7050: ST_TO_ADDR
7051: GO 7096
7053: LD_INT 5
7055: DOUBLE
7056: EQUAL
7057: IFTRUE 7061
7059: GO 7095
7061: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7062: LD_ADDR_VAR 0 6
7066: PUSH
7067: LD_INT 9
7069: PUSH
7070: LD_INT 6
7072: PUSH
7073: LD_INT 7
7075: PUSH
7076: EMPTY
7077: LIST
7078: LIST
7079: LIST
7080: PUSH
7081: LD_INT 1
7083: PPUSH
7084: LD_INT 3
7086: PPUSH
7087: CALL_OW 12
7091: ARRAY
7092: ST_TO_ADDR
7093: GO 7096
7095: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7096: LD_VAR 0 5
7100: PPUSH
7101: LD_INT 1
7103: PUSH
7104: LD_INT 3
7106: PUSH
7107: EMPTY
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 1
7113: PPUSH
7114: LD_INT 2
7116: PPUSH
7117: CALL_OW 12
7121: ARRAY
7122: PPUSH
7123: LD_INT 3
7125: PPUSH
7126: LD_VAR 0 6
7130: PPUSH
7131: LD_INT 70
7133: PPUSH
7134: LD_INT 90
7136: PPUSH
7137: CALL_OW 12
7141: PPUSH
7142: CALL 19702 0 5
// veh := CreateVehicle ;
7146: LD_ADDR_VAR 0 4
7150: PUSH
7151: CALL_OW 45
7155: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7156: LD_VAR 0 4
7160: PPUSH
7161: LD_INT 2
7163: PPUSH
7164: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7168: LD_VAR 0 4
7172: PPUSH
7173: LD_INT 17
7175: PPUSH
7176: LD_INT 0
7178: PPUSH
7179: CALL_OW 49
// tmp := tmp ^ veh ;
7183: LD_ADDR_VAR 0 3
7187: PUSH
7188: LD_VAR 0 3
7192: PUSH
7193: LD_VAR 0 4
7197: ADD
7198: ST_TO_ADDR
// end ;
7199: GO 6926
7201: POP
7202: POP
// if not tmp then
7203: LD_VAR 0 3
7207: NOT
7208: IFFALSE 7212
// exit ;
7210: GO 7321
// if not first_powell_attack then
7212: LD_EXP 12
7216: NOT
7217: IFFALSE 7227
// first_powell_attack := true ;
7219: LD_ADDR_EXP 12
7223: PUSH
7224: LD_INT 1
7226: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7227: LD_INT 70
7229: PPUSH
7230: CALL_OW 67
// for i in tmp do
7234: LD_ADDR_VAR 0 2
7238: PUSH
7239: LD_VAR 0 3
7243: PUSH
7244: FOR_IN
7245: IFFALSE 7312
// if IsOk ( i ) then
7247: LD_VAR 0 2
7251: PPUSH
7252: CALL_OW 302
7256: IFFALSE 7294
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7258: LD_VAR 0 2
7262: PPUSH
7263: LD_INT 81
7265: PUSH
7266: LD_INT 1
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: PPUSH
7273: CALL_OW 69
7277: PPUSH
7278: LD_VAR 0 2
7282: PPUSH
7283: CALL_OW 74
7287: PPUSH
7288: CALL_OW 115
7292: GO 7310
// tmp := tmp diff i ;
7294: LD_ADDR_VAR 0 3
7298: PUSH
7299: LD_VAR 0 3
7303: PUSH
7304: LD_VAR 0 2
7308: DIFF
7309: ST_TO_ADDR
7310: GO 7244
7312: POP
7313: POP
// until not tmp ;
7314: LD_VAR 0 3
7318: NOT
7319: IFFALSE 7227
// end ; end_of_file
7321: LD_VAR 0 1
7325: RET
// export function Action ; var tmp , i , un ; begin
7326: LD_INT 0
7328: PPUSH
7329: PPUSH
7330: PPUSH
7331: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7332: LD_INT 68
7334: PPUSH
7335: LD_INT 39
7337: PPUSH
7338: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7342: LD_ADDR_VAR 0 2
7346: PUSH
7347: LD_INT 22
7349: PUSH
7350: LD_INT 7
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: PPUSH
7357: CALL_OW 69
7361: ST_TO_ADDR
// InGameOn ;
7362: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7366: LD_VAR 0 2
7370: PPUSH
7371: LD_INT 71
7373: PPUSH
7374: LD_INT 49
7376: PPUSH
7377: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7381: LD_INT 35
7383: PPUSH
7384: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7388: LD_INT 7
7390: PPUSH
7391: LD_INT 71
7393: PPUSH
7394: LD_INT 51
7396: PPUSH
7397: CALL_OW 293
7401: IFFALSE 7381
// DialogueOn ;
7403: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7407: LD_EXP 16
7411: PPUSH
7412: LD_STRING D1-JMM-1
7414: PPUSH
7415: CALL_OW 88
// if Joan then
7419: LD_EXP 31
7423: IFFALSE 7437
// Say ( Joan , D1-Joan-1 ) ;
7425: LD_EXP 31
7429: PPUSH
7430: LD_STRING D1-Joan-1
7432: PPUSH
7433: CALL_OW 88
// if Lisa then
7437: LD_EXP 18
7441: IFFALSE 7455
// Say ( Lisa , D1-Lisa-1 ) ;
7443: LD_EXP 18
7447: PPUSH
7448: LD_STRING D1-Lisa-1
7450: PPUSH
7451: CALL_OW 88
// if Joan or Lisa then
7455: LD_EXP 31
7459: PUSH
7460: LD_EXP 18
7464: OR
7465: IFFALSE 7479
// Say ( JMM , D1-JMM-2 ) ;
7467: LD_EXP 16
7471: PPUSH
7472: LD_STRING D1-JMM-2
7474: PPUSH
7475: CALL_OW 88
// DialogueOff ;
7479: CALL_OW 7
// InGameOff ;
7483: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7487: LD_INT 71
7489: PPUSH
7490: LD_INT 50
7492: PPUSH
7493: LD_INT 7
7495: PPUSH
7496: LD_INT 30
7498: NEG
7499: PPUSH
7500: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7504: LD_INT 71
7506: PPUSH
7507: LD_INT 50
7509: PPUSH
7510: LD_INT 7
7512: PPUSH
7513: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7517: LD_STRING M1
7519: PPUSH
7520: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7524: LD_INT 35
7526: PPUSH
7527: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7531: LD_EXP 3
7535: PUSH
7536: LD_OWVAR 1
7540: PUSH
7541: LD_INT 2100
7543: GREATER
7544: OR
7545: IFFALSE 7524
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7547: LD_INT 350
7549: PPUSH
7550: LD_INT 700
7552: PPUSH
7553: CALL_OW 12
7557: PPUSH
7558: CALL_OW 67
// PrepareGossudarov ;
7562: CALL 1881 0 0
// repeat wait ( 0 0$1 ) ;
7566: LD_INT 35
7568: PPUSH
7569: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7573: LD_INT 22
7575: PUSH
7576: LD_INT 6
7578: PUSH
7579: EMPTY
7580: LIST
7581: LIST
7582: PUSH
7583: LD_INT 3
7585: PUSH
7586: LD_INT 24
7588: PUSH
7589: LD_INT 1000
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: PUSH
7600: EMPTY
7601: LIST
7602: LIST
7603: PPUSH
7604: CALL_OW 69
7608: PUSH
7609: LD_INT 7
7611: PPUSH
7612: LD_EXP 33
7616: PPUSH
7617: CALL_OW 292
7621: OR
7622: IFFALSE 7566
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7624: LD_ADDR_VAR 0 2
7628: PUSH
7629: LD_INT 22
7631: PUSH
7632: LD_INT 6
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PPUSH
7639: CALL_OW 69
7643: ST_TO_ADDR
// for i in tmp do
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_VAR 0 2
7653: PUSH
7654: FOR_IN
7655: IFFALSE 7671
// SetSide ( i , 7 ) ;
7657: LD_VAR 0 3
7661: PPUSH
7662: LD_INT 7
7664: PPUSH
7665: CALL_OW 235
7669: GO 7654
7671: POP
7672: POP
// DialogueOn ;
7673: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7677: LD_EXP 16
7681: PUSH
7682: LD_EXP 17
7686: PUSH
7687: EMPTY
7688: LIST
7689: LIST
7690: PPUSH
7691: LD_EXP 33
7695: PPUSH
7696: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7700: LD_EXP 33
7704: PPUSH
7705: CALL_OW 87
// if not Roth then
7709: LD_EXP 17
7713: NOT
7714: IFFALSE 7806
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7716: LD_VAR 0 2
7720: PPUSH
7721: LD_INT 3
7723: PUSH
7724: LD_INT 24
7726: PUSH
7727: LD_INT 1000
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PUSH
7734: EMPTY
7735: LIST
7736: LIST
7737: PPUSH
7738: CALL_OW 72
7742: IFFALSE 7756
// Say ( JMM , D2-JMM-1 ) ;
7744: LD_EXP 16
7748: PPUSH
7749: LD_STRING D2-JMM-1
7751: PPUSH
7752: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7756: LD_EXP 16
7760: PPUSH
7761: LD_STRING D2-JMM-1b
7763: PPUSH
7764: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7768: LD_EXP 33
7772: PPUSH
7773: LD_STRING D2-Gos-1
7775: PPUSH
7776: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7780: LD_EXP 16
7784: PPUSH
7785: LD_STRING D2-JMM-2
7787: PPUSH
7788: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7792: LD_EXP 33
7796: PPUSH
7797: LD_STRING D2-Gos-2
7799: PPUSH
7800: CALL_OW 88
// end else
7804: GO 7958
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7806: LD_VAR 0 2
7810: PPUSH
7811: LD_INT 3
7813: PUSH
7814: LD_INT 24
7816: PUSH
7817: LD_INT 1000
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: PPUSH
7828: CALL_OW 72
7832: IFFALSE 7858
// begin Say ( Roth , D2-Roth-2 ) ;
7834: LD_EXP 17
7838: PPUSH
7839: LD_STRING D2-Roth-2
7841: PPUSH
7842: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7846: LD_EXP 16
7850: PPUSH
7851: LD_STRING D2-JMM-1a
7853: PPUSH
7854: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7858: LD_EXP 17
7862: PPUSH
7863: LD_STRING D2-Roth-2a
7865: PPUSH
7866: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7870: LD_EXP 17
7874: PPUSH
7875: LD_STRING D2-Roth-2b
7877: PPUSH
7878: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7882: LD_EXP 16
7886: PPUSH
7887: LD_STRING D2-JMM-3
7889: PPUSH
7890: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7894: LD_VAR 0 2
7898: PPUSH
7899: LD_INT 3
7901: PUSH
7902: LD_INT 24
7904: PUSH
7905: LD_INT 1000
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PPUSH
7916: CALL_OW 72
7920: IFFALSE 7958
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7922: LD_EXP 33
7926: PPUSH
7927: LD_STRING D2-Gos-3
7929: PPUSH
7930: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7934: LD_EXP 16
7938: PPUSH
7939: LD_STRING D2-JMM-4
7941: PPUSH
7942: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7946: LD_EXP 33
7950: PPUSH
7951: LD_STRING D2-Gos-4
7953: PPUSH
7954: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7958: LD_EXP 16
7962: PPUSH
7963: LD_STRING D2-JMM-5
7965: PPUSH
7966: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7970: LD_EXP 33
7974: PPUSH
7975: LD_STRING D2-Gos-5
7977: PPUSH
7978: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7982: LD_EXP 16
7986: PPUSH
7987: LD_STRING D2-JMM-6
7989: PPUSH
7990: CALL_OW 88
// DialogueOff ;
7994: CALL_OW 7
// wait ( 0 0$2 ) ;
7998: LD_INT 70
8000: PPUSH
8001: CALL_OW 67
// if Kirilenkova then
8005: LD_EXP 34
8009: IFFALSE 8023
// Say ( Kirilenkova , D3-Kir-1 ) ;
8011: LD_EXP 34
8015: PPUSH
8016: LD_STRING D3-Kir-1
8018: PPUSH
8019: CALL_OW 88
// gossudarov_arrive := true ;
8023: LD_ADDR_EXP 4
8027: PUSH
8028: LD_INT 1
8030: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8031: LD_INT 35
8033: PPUSH
8034: CALL_OW 67
// until ru_lab_builded ;
8038: LD_EXP 5
8042: IFFALSE 8031
// DialogueOn ;
8044: CALL_OW 6
// if Kirilenkova then
8048: LD_EXP 34
8052: IFFALSE 8068
// Say ( Kirilenkova , D3a-Kir-1 ) else
8054: LD_EXP 34
8058: PPUSH
8059: LD_STRING D3a-Kir-1
8061: PPUSH
8062: CALL_OW 88
8066: GO 8090
// begin un := SciRu ;
8068: LD_ADDR_VAR 0 4
8072: PUSH
8073: CALL 13222 0 0
8077: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8078: LD_VAR 0 4
8082: PPUSH
8083: LD_STRING D3a-Sci1-1
8085: PPUSH
8086: CALL_OW 88
// end ; if Kirilenkova or un then
8090: LD_EXP 34
8094: PUSH
8095: LD_VAR 0 4
8099: OR
8100: IFFALSE 8114
// Say ( JMM , D3a-JMM-1 ) ;
8102: LD_EXP 16
8106: PPUSH
8107: LD_STRING D3a-JMM-1
8109: PPUSH
8110: CALL_OW 88
// DialogueOff ;
8114: CALL_OW 7
// end ;
8118: LD_VAR 0 1
8122: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8123: LD_EXP 4
8127: PUSH
8128: LD_INT 22
8130: PUSH
8131: LD_INT 7
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PUSH
8138: LD_INT 2
8140: PUSH
8141: LD_INT 25
8143: PUSH
8144: LD_INT 1
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: PUSH
8151: LD_INT 25
8153: PUSH
8154: LD_INT 2
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PUSH
8161: LD_INT 25
8163: PUSH
8164: LD_INT 3
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PUSH
8171: LD_INT 25
8173: PUSH
8174: LD_INT 4
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 25
8183: PUSH
8184: LD_INT 5
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 25
8193: PUSH
8194: LD_INT 8
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: LD_INT 25
8203: PUSH
8204: LD_INT 9
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: LIST
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PUSH
8230: LD_INT 7
8232: LESS
8233: AND
8234: IFFALSE 8246
8236: GO 8238
8238: DISABLE
// YouLost ( TooMany ) ;
8239: LD_STRING TooMany
8241: PPUSH
8242: CALL_OW 104
8246: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8247: LD_EXP 33
8251: PPUSH
8252: CALL_OW 255
8256: PUSH
8257: LD_INT 7
8259: EQUAL
8260: IFFALSE 8477
8262: GO 8264
8264: DISABLE
8265: LD_INT 0
8267: PPUSH
8268: PPUSH
8269: PPUSH
// begin uc_side := 3 ;
8270: LD_ADDR_OWVAR 20
8274: PUSH
8275: LD_INT 3
8277: ST_TO_ADDR
// uc_nation := 3 ;
8278: LD_ADDR_OWVAR 21
8282: PUSH
8283: LD_INT 3
8285: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8286: LD_INT 21
8288: PPUSH
8289: LD_INT 3
8291: PPUSH
8292: LD_INT 3
8294: PPUSH
8295: LD_INT 42
8297: PPUSH
8298: LD_INT 100
8300: PPUSH
8301: CALL 19702 0 5
// un := CreateVehicle ;
8305: LD_ADDR_VAR 0 3
8309: PUSH
8310: CALL_OW 45
8314: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8315: LD_VAR 0 3
8319: PPUSH
8320: LD_INT 15
8322: PPUSH
8323: LD_INT 0
8325: PPUSH
8326: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8330: LD_VAR 0 3
8334: PPUSH
8335: LD_INT 67
8337: PPUSH
8338: LD_INT 45
8340: PPUSH
8341: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8345: LD_VAR 0 3
8349: PPUSH
8350: LD_INT 70
8352: PPUSH
8353: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8357: LD_VAR 0 3
8361: PPUSH
8362: LD_INT 69
8364: PPUSH
8365: LD_INT 18
8367: PPUSH
8368: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8372: LD_VAR 0 3
8376: PPUSH
8377: LD_INT 60
8379: PPUSH
8380: LD_INT 3
8382: PPUSH
8383: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8387: LD_INT 35
8389: PPUSH
8390: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8394: LD_VAR 0 3
8398: PPUSH
8399: CALL_OW 302
8403: NOT
8404: PUSH
8405: LD_VAR 0 3
8409: PPUSH
8410: LD_INT 17
8412: PPUSH
8413: CALL_OW 308
8417: OR
8418: PUSH
8419: LD_VAR 0 3
8423: PPUSH
8424: LD_INT 60
8426: PPUSH
8427: LD_INT 3
8429: PPUSH
8430: CALL_OW 307
8434: OR
8435: IFFALSE 8387
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8437: LD_VAR 0 3
8441: PPUSH
8442: LD_INT 17
8444: PPUSH
8445: CALL_OW 308
8449: PUSH
8450: LD_VAR 0 3
8454: PPUSH
8455: LD_INT 60
8457: PPUSH
8458: LD_INT 3
8460: PPUSH
8461: CALL_OW 307
8465: OR
8466: IFFALSE 8477
// RemoveUnit ( un ) ;
8468: LD_VAR 0 3
8472: PPUSH
8473: CALL_OW 64
// end ;
8477: PPOPN 3
8479: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8480: LD_EXP 4
8484: IFFALSE 8726
8486: GO 8488
8488: DISABLE
8489: LD_INT 0
8491: PPUSH
8492: PPUSH
8493: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8494: LD_INT 70
8496: PPUSH
8497: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8501: LD_ADDR_VAR 0 3
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 7
8511: PUSH
8512: EMPTY
8513: LIST
8514: LIST
8515: PUSH
8516: LD_INT 101
8518: PUSH
8519: LD_INT 3
8521: PUSH
8522: EMPTY
8523: LIST
8524: LIST
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PPUSH
8530: CALL_OW 69
8534: ST_TO_ADDR
// until tmp ;
8535: LD_VAR 0 3
8539: IFFALSE 8494
// un := NearestUnitToUnit ( tmp , JMM ) ;
8541: LD_ADDR_VAR 0 2
8545: PUSH
8546: LD_VAR 0 3
8550: PPUSH
8551: LD_EXP 16
8555: PPUSH
8556: CALL_OW 74
8560: ST_TO_ADDR
// player_spotted := true ;
8561: LD_ADDR_EXP 6
8565: PUSH
8566: LD_INT 1
8568: ST_TO_ADDR
// tmp := SciRu ;
8569: LD_ADDR_VAR 0 3
8573: PUSH
8574: CALL 13222 0 0
8578: ST_TO_ADDR
// if not tmp then
8579: LD_VAR 0 3
8583: NOT
8584: IFFALSE 8596
// tmp := SolRu ;
8586: LD_ADDR_VAR 0 3
8590: PUSH
8591: CALL 13369 0 0
8595: ST_TO_ADDR
// DialogueOn ;
8596: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8600: LD_VAR 0 2
8604: PPUSH
8605: CALL_OW 250
8609: PPUSH
8610: LD_VAR 0 2
8614: PPUSH
8615: CALL_OW 251
8619: PPUSH
8620: LD_INT 7
8622: PPUSH
8623: LD_INT 8
8625: NEG
8626: PPUSH
8627: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8631: LD_VAR 0 2
8635: PPUSH
8636: CALL_OW 87
// if tmp then
8640: LD_VAR 0 3
8644: IFFALSE 8658
// Say ( tmp , D4-RSci1-1 ) ;
8646: LD_VAR 0 3
8650: PPUSH
8651: LD_STRING D4-RSci1-1
8653: PPUSH
8654: CALL_OW 88
// if Gossudarov then
8658: LD_EXP 33
8662: IFFALSE 8688
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8664: LD_EXP 33
8668: PPUSH
8669: LD_STRING D4-Gos-1
8671: PPUSH
8672: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8676: LD_EXP 16
8680: PPUSH
8681: LD_STRING D4-JMM-1
8683: PPUSH
8684: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8688: LD_VAR 0 2
8692: PPUSH
8693: CALL_OW 250
8697: PPUSH
8698: LD_VAR 0 2
8702: PPUSH
8703: CALL_OW 251
8707: PPUSH
8708: LD_INT 7
8710: PPUSH
8711: CALL_OW 331
// DialogueOff ;
8715: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8719: LD_STRING M5
8721: PPUSH
8722: CALL_OW 337
// end ;
8726: PPOPN 3
8728: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8729: LD_EXP 6
8733: IFFALSE 9326
8735: GO 8737
8737: DISABLE
8738: LD_INT 0
8740: PPUSH
8741: PPUSH
8742: PPUSH
// begin PrepareBelkov ;
8743: CALL 2194 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8747: LD_EXP 48
8751: PPUSH
8752: LD_INT 118
8754: PPUSH
8755: LD_INT 106
8757: PPUSH
8758: CALL_OW 111
// AddComHold ( Belkov ) ;
8762: LD_EXP 48
8766: PPUSH
8767: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8771: LD_INT 35
8773: PPUSH
8774: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8778: LD_EXP 48
8782: PPUSH
8783: LD_INT 118
8785: PPUSH
8786: LD_INT 106
8788: PPUSH
8789: CALL_OW 307
8793: IFFALSE 8771
// ChangeSideFog ( 4 , 7 ) ;
8795: LD_INT 4
8797: PPUSH
8798: LD_INT 7
8800: PPUSH
8801: CALL_OW 343
// if IsOk ( Belkov ) then
8805: LD_EXP 48
8809: PPUSH
8810: CALL_OW 302
8814: IFFALSE 8898
// begin InGameOn ;
8816: CALL_OW 8
// DialogueOn ;
8820: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8824: LD_EXP 48
8828: PPUSH
8829: LD_STRING D5-Bel-1
8831: PPUSH
8832: CALL_OW 94
// if Gossudarov then
8836: LD_EXP 33
8840: IFFALSE 8890
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8842: LD_EXP 33
8846: PPUSH
8847: LD_STRING D5-Gos-1
8849: PPUSH
8850: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8854: LD_EXP 16
8858: PPUSH
8859: LD_STRING D5-JMM-1
8861: PPUSH
8862: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8866: LD_EXP 33
8870: PPUSH
8871: LD_STRING D5-Gos-2
8873: PPUSH
8874: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8878: LD_EXP 16
8882: PPUSH
8883: LD_STRING D5-JMM-2
8885: PPUSH
8886: CALL_OW 88
// end ; DialogueOff ;
8890: CALL_OW 7
// InGameOff ;
8894: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8898: LD_STRING QSaveBelkov
8900: PPUSH
8901: CALL_OW 97
8905: PUSH
8906: LD_INT 1
8908: DOUBLE
8909: EQUAL
8910: IFTRUE 8914
8912: GO 8964
8914: POP
// begin DialogueOn ;
8915: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8919: LD_EXP 16
8923: PPUSH
8924: LD_STRING D5a-JMM-1
8926: PPUSH
8927: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8931: LD_EXP 48
8935: PPUSH
8936: LD_STRING D5a-Bel-1
8938: PPUSH
8939: CALL_OW 94
// DialogueOff ;
8943: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8947: LD_EXP 48
8951: PPUSH
8952: LD_INT 83
8954: PPUSH
8955: LD_INT 49
8957: PPUSH
8958: CALL_OW 111
// end ; 2 :
8962: GO 8997
8964: LD_INT 2
8966: DOUBLE
8967: EQUAL
8968: IFTRUE 8972
8970: GO 8996
8972: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8973: LD_EXP 16
8977: PPUSH
8978: LD_STRING D5a-JMM-2
8980: PPUSH
8981: CALL_OW 88
// ComHold ( Belkov ) ;
8985: LD_EXP 48
8989: PPUSH
8990: CALL_OW 140
// end ; end ;
8994: GO 8997
8996: POP
// time := 0 0$00 ;
8997: LD_ADDR_VAR 0 1
9001: PUSH
9002: LD_INT 0
9004: ST_TO_ADDR
// vehSpawned := false ;
9005: LD_ADDR_VAR 0 3
9009: PUSH
9010: LD_INT 0
9012: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9013: LD_INT 35
9015: PPUSH
9016: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9020: LD_VAR 0 1
9024: PUSH
9025: LD_INT 350
9027: PUSH
9028: LD_INT 175
9030: PUSH
9031: LD_INT 105
9033: PUSH
9034: LD_INT 70
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: PUSH
9043: LD_OWVAR 67
9047: ARRAY
9048: GREATEREQUAL
9049: PUSH
9050: LD_VAR 0 3
9054: NOT
9055: AND
9056: IFFALSE 9146
// begin vehSpawned := true ;
9058: LD_ADDR_VAR 0 3
9062: PUSH
9063: LD_INT 1
9065: ST_TO_ADDR
// uc_side := 3 ;
9066: LD_ADDR_OWVAR 20
9070: PUSH
9071: LD_INT 3
9073: ST_TO_ADDR
// uc_nation := 3 ;
9074: LD_ADDR_OWVAR 21
9078: PUSH
9079: LD_INT 3
9081: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9082: LD_INT 22
9084: PPUSH
9085: LD_INT 3
9087: PPUSH
9088: LD_INT 3
9090: PPUSH
9091: LD_INT 43
9093: PPUSH
9094: LD_INT 100
9096: PPUSH
9097: CALL 19702 0 5
// veh := CreateVehicle ;
9101: LD_ADDR_VAR 0 2
9105: PUSH
9106: CALL_OW 45
9110: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9111: LD_VAR 0 2
9115: PPUSH
9116: LD_INT 130
9118: PPUSH
9119: LD_INT 131
9121: PPUSH
9122: LD_INT 0
9124: PPUSH
9125: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9129: LD_VAR 0 2
9133: PPUSH
9134: LD_INT 100
9136: PPUSH
9137: LD_INT 82
9139: PPUSH
9140: CALL_OW 114
// end else
9144: GO 9160
// time := time + 0 0$1 ;
9146: LD_ADDR_VAR 0 1
9150: PUSH
9151: LD_VAR 0 1
9155: PUSH
9156: LD_INT 35
9158: PLUS
9159: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9160: LD_EXP 48
9164: PPUSH
9165: CALL_OW 301
9169: PUSH
9170: LD_EXP 48
9174: PPUSH
9175: CALL_OW 255
9179: PUSH
9180: LD_INT 4
9182: EQUAL
9183: AND
9184: PUSH
9185: LD_INT 22
9187: PUSH
9188: LD_INT 7
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PPUSH
9200: LD_EXP 48
9204: PPUSH
9205: CALL_OW 74
9209: PPUSH
9210: LD_EXP 48
9214: PPUSH
9215: CALL_OW 296
9219: PUSH
9220: LD_INT 10
9222: LESS
9223: OR
9224: IFFALSE 9013
// if IsDead ( Belkov ) then
9226: LD_EXP 48
9230: PPUSH
9231: CALL_OW 301
9235: IFFALSE 9260
// begin CenterNowOnUnits ( Belkov ) ;
9237: LD_EXP 48
9241: PPUSH
9242: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9246: LD_EXP 16
9250: PPUSH
9251: LD_STRING D5a-JMM-2a
9253: PPUSH
9254: CALL_OW 88
// exit ;
9258: GO 9326
// end ; if See ( 7 , Belkov ) then
9260: LD_INT 7
9262: PPUSH
9263: LD_EXP 48
9267: PPUSH
9268: CALL_OW 292
9272: IFFALSE 9286
// SetSide ( Belkov , 7 ) ;
9274: LD_EXP 48
9278: PPUSH
9279: LD_INT 7
9281: PPUSH
9282: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9286: LD_INT 35
9288: PPUSH
9289: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9293: LD_EXP 48
9297: PPUSH
9298: LD_INT 66
9300: PPUSH
9301: LD_INT 45
9303: PPUSH
9304: CALL_OW 297
9308: PUSH
9309: LD_INT 30
9311: LESS
9312: IFFALSE 9286
// Say ( Belkov , D6-Bel-1 ) ;
9314: LD_EXP 48
9318: PPUSH
9319: LD_STRING D6-Bel-1
9321: PPUSH
9322: CALL_OW 88
// end ;
9326: PPOPN 3
9328: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9329: LD_EXP 48
9333: PPUSH
9334: CALL_OW 302
9338: PUSH
9339: LD_EXP 48
9343: PPUSH
9344: CALL_OW 504
9348: PUSH
9349: LD_INT 2
9351: PUSH
9352: LD_INT 34
9354: PUSH
9355: LD_INT 47
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: PUSH
9362: LD_INT 34
9364: PUSH
9365: LD_INT 45
9367: PUSH
9368: EMPTY
9369: LIST
9370: LIST
9371: PUSH
9372: EMPTY
9373: LIST
9374: LIST
9375: LIST
9376: PPUSH
9377: CALL_OW 69
9381: IN
9382: AND
9383: IFFALSE 9400
9385: GO 9387
9387: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9388: LD_EXP 48
9392: PPUSH
9393: LD_STRING D7-Bel-1
9395: PPUSH
9396: CALL_OW 88
9400: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9401: LD_INT 22
9403: PUSH
9404: LD_INT 7
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 101
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: PPUSH
9425: CALL_OW 69
9429: PUSH
9430: LD_EXP 8
9434: NOT
9435: AND
9436: PUSH
9437: LD_EXP 47
9441: PPUSH
9442: CALL_OW 305
9446: NOT
9447: AND
9448: IFFALSE 9918
9450: GO 9452
9452: DISABLE
9453: LD_INT 0
9455: PPUSH
// begin ar_base_spotted := true ;
9456: LD_ADDR_EXP 8
9460: PUSH
9461: LD_INT 1
9463: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9464: LD_ADDR_VAR 0 1
9468: PUSH
9469: LD_INT 22
9471: PUSH
9472: LD_INT 2
9474: PUSH
9475: EMPTY
9476: LIST
9477: LIST
9478: PUSH
9479: LD_INT 21
9481: PUSH
9482: LD_INT 3
9484: PUSH
9485: EMPTY
9486: LIST
9487: LIST
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PPUSH
9493: CALL_OW 69
9497: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9498: LD_ADDR_VAR 0 1
9502: PUSH
9503: LD_VAR 0 1
9507: PPUSH
9508: LD_EXP 16
9512: PPUSH
9513: CALL_OW 74
9517: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9518: LD_INT 7
9520: PPUSH
9521: LD_INT 3
9523: PPUSH
9524: CALL_OW 332
// DialogueOn ;
9528: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9532: LD_VAR 0 1
9536: PPUSH
9537: CALL_OW 250
9541: PPUSH
9542: LD_VAR 0 1
9546: PPUSH
9547: CALL_OW 251
9551: PPUSH
9552: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9556: LD_ADDR_VAR 0 1
9560: PUSH
9561: LD_INT 22
9563: PUSH
9564: LD_INT 7
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: PUSH
9571: LD_INT 23
9573: PUSH
9574: LD_INT 1
9576: PUSH
9577: EMPTY
9578: LIST
9579: LIST
9580: PUSH
9581: LD_INT 26
9583: PUSH
9584: LD_INT 1
9586: PUSH
9587: EMPTY
9588: LIST
9589: LIST
9590: PUSH
9591: EMPTY
9592: LIST
9593: LIST
9594: LIST
9595: PPUSH
9596: CALL_OW 69
9600: PUSH
9601: LD_EXP 16
9605: PUSH
9606: LD_EXP 20
9610: PUSH
9611: LD_EXP 21
9615: PUSH
9616: LD_EXP 28
9620: PUSH
9621: LD_EXP 17
9625: PUSH
9626: LD_EXP 26
9630: PUSH
9631: LD_EXP 22
9635: PUSH
9636: LD_EXP 24
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: DIFF
9651: ST_TO_ADDR
// if not tmp then
9652: LD_VAR 0 1
9656: NOT
9657: IFFALSE 9731
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9659: LD_ADDR_VAR 0 1
9663: PUSH
9664: LD_INT 22
9666: PUSH
9667: LD_INT 7
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PUSH
9674: LD_INT 23
9676: PUSH
9677: LD_INT 1
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: PUSH
9684: LD_INT 26
9686: PUSH
9687: LD_INT 2
9689: PUSH
9690: EMPTY
9691: LIST
9692: LIST
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: LIST
9698: PPUSH
9699: CALL_OW 69
9703: PUSH
9704: LD_EXP 31
9708: PUSH
9709: LD_EXP 18
9713: PUSH
9714: LD_EXP 29
9718: PUSH
9719: LD_EXP 30
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: LIST
9728: LIST
9729: DIFF
9730: ST_TO_ADDR
// if tmp then
9731: LD_VAR 0 1
9735: IFFALSE 9806
// case GetSex ( tmp [ 1 ] ) of sex_male :
9737: LD_VAR 0 1
9741: PUSH
9742: LD_INT 1
9744: ARRAY
9745: PPUSH
9746: CALL_OW 258
9750: PUSH
9751: LD_INT 1
9753: DOUBLE
9754: EQUAL
9755: IFTRUE 9759
9757: GO 9778
9759: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9760: LD_VAR 0 1
9764: PUSH
9765: LD_INT 1
9767: ARRAY
9768: PPUSH
9769: LD_STRING D9-Sol1-1
9771: PPUSH
9772: CALL_OW 88
9776: GO 9806
9778: LD_INT 2
9780: DOUBLE
9781: EQUAL
9782: IFTRUE 9786
9784: GO 9805
9786: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9787: LD_VAR 0 1
9791: PUSH
9792: LD_INT 1
9794: ARRAY
9795: PPUSH
9796: LD_STRING D9-FSol1-1
9798: PPUSH
9799: CALL_OW 88
9803: GO 9806
9805: POP
// if Frank then
9806: LD_EXP 28
9810: IFFALSE 9914
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9812: LD_EXP 57
9816: PPUSH
9817: CALL_OW 250
9821: PPUSH
9822: LD_EXP 57
9826: PPUSH
9827: CALL_OW 251
9831: PPUSH
9832: LD_INT 7
9834: PPUSH
9835: LD_INT 8
9837: PPUSH
9838: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9842: LD_EXP 57
9846: PPUSH
9847: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9851: LD_EXP 28
9855: PPUSH
9856: LD_STRING D9-Frank-1
9858: PPUSH
9859: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9863: LD_EXP 16
9867: PPUSH
9868: LD_STRING D9-JMM-1
9870: PPUSH
9871: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9875: LD_EXP 28
9879: PPUSH
9880: LD_STRING D9-Frank-2
9882: PPUSH
9883: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9887: LD_EXP 57
9891: PPUSH
9892: CALL_OW 250
9896: PPUSH
9897: LD_EXP 57
9901: PPUSH
9902: CALL_OW 251
9906: PPUSH
9907: LD_INT 7
9909: PPUSH
9910: CALL_OW 331
// end ; DialogueOff ;
9914: CALL_OW 7
// end ;
9918: PPOPN 1
9920: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9921: LD_EXP 7
9925: PUSH
9926: LD_OWVAR 1
9930: PUSH
9931: LD_INT 42000
9933: GREATEREQUAL
9934: OR
9935: IFFALSE 10962
9937: GO 9939
9939: DISABLE
9940: LD_INT 0
9942: PPUSH
9943: PPUSH
// begin selected_option := 1 ;
9944: LD_ADDR_VAR 0 2
9948: PUSH
9949: LD_INT 1
9951: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9952: LD_INT 10500
9954: PPUSH
9955: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9959: LD_INT 35
9961: PPUSH
9962: CALL_OW 67
// until not ru_attackers ;
9966: LD_EXP 53
9970: NOT
9971: IFFALSE 9959
// PrepareBurlak ;
9973: CALL 2306 0 0
// repeat wait ( 0 0$2 ) ;
9977: LD_INT 70
9979: PPUSH
9980: CALL_OW 67
// until not HasTask ( Burlak ) ;
9984: LD_EXP 47
9988: PPUSH
9989: CALL_OW 314
9993: NOT
9994: IFFALSE 9977
// InGameOn ;
9996: CALL_OW 8
// DialogueOn ;
10000: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10004: LD_EXP 50
10008: PPUSH
10009: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10013: LD_EXP 47
10017: PPUSH
10018: LD_STRING D10-Bur-1
10020: PPUSH
10021: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10025: LD_EXP 48
10029: PUSH
10030: LD_EXP 48
10034: PPUSH
10035: CALL_OW 255
10039: PUSH
10040: LD_INT 7
10042: EQUAL
10043: AND
10044: IFFALSE 10058
// Say ( Belkov , D10-Bel-1 ) ;
10046: LD_EXP 48
10050: PPUSH
10051: LD_STRING D10-Bel-1
10053: PPUSH
10054: CALL_OW 88
// if Gossudarov then
10058: LD_EXP 33
10062: IFFALSE 10076
// Say ( Gossudarov , D10-Gos-1 ) ;
10064: LD_EXP 33
10068: PPUSH
10069: LD_STRING D10-Gos-1
10071: PPUSH
10072: CALL_OW 88
// if Kirilenkova then
10076: LD_EXP 34
10080: IFFALSE 10094
// Say ( Kirilenkova , D10-Kir-1 ) ;
10082: LD_EXP 34
10086: PPUSH
10087: LD_STRING D10-Kir-1
10089: PPUSH
10090: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10094: CALL 13369 0 0
10098: PPUSH
10099: LD_STRING D10-RSol1-1
10101: PPUSH
10102: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10106: LD_EXP 47
10110: PPUSH
10111: LD_STRING D10-Bur-2
10113: PPUSH
10114: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10118: LD_EXP 16
10122: PPUSH
10123: LD_STRING D10-JMM-2
10125: PPUSH
10126: CALL_OW 88
// if Kirilenkova then
10130: LD_EXP 34
10134: IFFALSE 10150
// Say ( Kirilenkova , D10-Kir-2 ) else
10136: LD_EXP 34
10140: PPUSH
10141: LD_STRING D10-Kir-2
10143: PPUSH
10144: CALL_OW 88
10148: GO 10162
// Say ( SolRu , D10-RSol1-2 ) ;
10150: CALL 13369 0 0
10154: PPUSH
10155: LD_STRING D10-RSol1-2
10157: PPUSH
10158: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10162: LD_EXP 16
10166: PPUSH
10167: LD_STRING D10-JMM-3
10169: PPUSH
10170: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10174: LD_EXP 47
10178: PPUSH
10179: LD_STRING D10-Bur-3
10181: PPUSH
10182: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10186: LD_EXP 16
10190: PPUSH
10191: LD_STRING D10-JMM-4
10193: PPUSH
10194: CALL_OW 88
// DialogueOff ;
10198: CALL_OW 7
// InGameOff ;
10202: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10206: LD_STRING M2
10208: PPUSH
10209: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10213: LD_INT 35
10215: PPUSH
10216: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10220: LD_INT 22
10222: PUSH
10223: LD_INT 7
10225: PUSH
10226: EMPTY
10227: LIST
10228: LIST
10229: PUSH
10230: LD_INT 91
10232: PUSH
10233: LD_EXP 47
10237: PUSH
10238: LD_INT 8
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: PPUSH
10250: CALL_OW 69
10254: IFFALSE 10213
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10256: LD_ADDR_VAR 0 1
10260: PUSH
10261: LD_INT 22
10263: PUSH
10264: LD_INT 4
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PPUSH
10271: CALL_OW 69
10275: PUSH
10276: FOR_IN
10277: IFFALSE 10293
// SetSide ( i , 7 ) ;
10279: LD_VAR 0 1
10283: PPUSH
10284: LD_INT 7
10286: PPUSH
10287: CALL_OW 235
10291: GO 10276
10293: POP
10294: POP
// ChangeMissionObjectives ( M3 ) ;
10295: LD_STRING M3
10297: PPUSH
10298: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10302: LD_INT 35
10304: PPUSH
10305: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10309: LD_EXP 16
10313: PPUSH
10314: LD_EXP 47
10318: PPUSH
10319: CALL_OW 296
10323: PUSH
10324: LD_INT 8
10326: LESS
10327: IFFALSE 10302
// ComTurnUnit ( JMM , Burlak ) ;
10329: LD_EXP 16
10333: PPUSH
10334: LD_EXP 47
10338: PPUSH
10339: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10343: LD_EXP 47
10347: PPUSH
10348: LD_EXP 16
10352: PPUSH
10353: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10357: LD_INT 10
10359: PPUSH
10360: CALL_OW 67
// DialogueOn ;
10364: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10368: LD_EXP 16
10372: PPUSH
10373: LD_STRING D11-JMM-1
10375: PPUSH
10376: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10380: LD_EXP 47
10384: PPUSH
10385: LD_STRING D11-Bur-1
10387: PPUSH
10388: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10392: LD_EXP 16
10396: PPUSH
10397: LD_STRING D11-JMM-2
10399: PPUSH
10400: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10404: LD_EXP 47
10408: PPUSH
10409: LD_STRING D11-Bur-2
10411: PPUSH
10412: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10416: LD_EXP 16
10420: PPUSH
10421: LD_STRING D11-JMM-3
10423: PPUSH
10424: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10428: LD_EXP 47
10432: PPUSH
10433: LD_STRING D11-Bur-3
10435: PPUSH
10436: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10440: LD_EXP 16
10444: PPUSH
10445: LD_STRING D11-JMM-4
10447: PPUSH
10448: CALL_OW 88
// if ar_base_spotted then
10452: LD_EXP 8
10456: IFFALSE 10472
// Say ( Burlak , D12-Bur-1 ) else
10458: LD_EXP 47
10462: PPUSH
10463: LD_STRING D12-Bur-1
10465: PPUSH
10466: CALL_OW 88
10470: GO 10511
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10472: LD_INT 7
10474: PPUSH
10475: LD_INT 3
10477: PPUSH
10478: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10482: LD_INT 127
10484: PPUSH
10485: LD_INT 45
10487: PPUSH
10488: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10492: LD_EXP 47
10496: PPUSH
10497: LD_STRING D12-Bur-1a
10499: PPUSH
10500: CALL_OW 88
// dwait ( 0 0$2 ) ;
10504: LD_INT 70
10506: PPUSH
10507: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10511: LD_EXP 47
10515: PPUSH
10516: LD_STRING D12-Bur-1b
10518: PPUSH
10519: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10523: LD_EXP 16
10527: PPUSH
10528: LD_STRING D12-JMM-1
10530: PPUSH
10531: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10535: LD_EXP 47
10539: PPUSH
10540: LD_STRING D12-Bur-2
10542: PPUSH
10543: CALL_OW 88
// if Roth then
10547: LD_EXP 17
10551: IFFALSE 10567
// Say ( Roth , D12-Roth-2 ) else
10553: LD_EXP 17
10557: PPUSH
10558: LD_STRING D12-Roth-2
10560: PPUSH
10561: CALL_OW 88
10565: GO 10579
// Say ( SciRu , D12-RSci1-2 ) ;
10567: CALL 13222 0 0
10571: PPUSH
10572: LD_STRING D12-RSci1-2
10574: PPUSH
10575: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10579: LD_EXP 16
10583: PPUSH
10584: LD_STRING D12-JMM-2
10586: PPUSH
10587: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10591: LD_EXP 47
10595: PPUSH
10596: LD_STRING D12-Bur-3
10598: PPUSH
10599: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10603: LD_EXP 16
10607: PPUSH
10608: LD_STRING D12-JMM-3
10610: PPUSH
10611: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10615: LD_EXP 47
10619: PPUSH
10620: LD_STRING D12-Bur-4
10622: PPUSH
10623: CALL_OW 88
// case Query ( QBase ) of 1 :
10627: LD_STRING QBase
10629: PPUSH
10630: CALL_OW 97
10634: PUSH
10635: LD_INT 1
10637: DOUBLE
10638: EQUAL
10639: IFTRUE 10643
10641: GO 10761
10643: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10644: LD_EXP 16
10648: PPUSH
10649: LD_STRING D13a-JMM-1
10651: PPUSH
10652: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10656: LD_EXP 47
10660: PPUSH
10661: LD_STRING D13a-Bur-1
10663: PPUSH
10664: CALL_OW 88
// if Roth then
10668: LD_EXP 17
10672: IFFALSE 10688
// Say ( Roth , D13a-Roth-1 ) else
10674: LD_EXP 17
10678: PPUSH
10679: LD_STRING D13a-Roth-1
10681: PPUSH
10682: CALL_OW 88
10686: GO 10700
// Say ( SciRu , D13a-RSci1-1 ) ;
10688: CALL 13222 0 0
10692: PPUSH
10693: LD_STRING D13a-RSci1-1
10695: PPUSH
10696: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10700: LD_EXP 16
10704: PPUSH
10705: LD_STRING D13a-JMM-2
10707: PPUSH
10708: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10712: LD_STRING QBaseAgain
10714: PPUSH
10715: CALL_OW 97
10719: PUSH
10720: LD_INT 1
10722: DOUBLE
10723: EQUAL
10724: IFTRUE 10728
10726: GO 10739
10728: POP
// selected_option := 2 ; 2 :
10729: LD_ADDR_VAR 0 2
10733: PUSH
10734: LD_INT 2
10736: ST_TO_ADDR
10737: GO 10759
10739: LD_INT 2
10741: DOUBLE
10742: EQUAL
10743: IFTRUE 10747
10745: GO 10758
10747: POP
// selected_option := 3 ; end ;
10748: LD_ADDR_VAR 0 2
10752: PUSH
10753: LD_INT 3
10755: ST_TO_ADDR
10756: GO 10759
10758: POP
// end ; 2 :
10759: GO 10800
10761: LD_INT 2
10763: DOUBLE
10764: EQUAL
10765: IFTRUE 10769
10767: GO 10780
10769: POP
// selected_option := 2 ; 3 :
10770: LD_ADDR_VAR 0 2
10774: PUSH
10775: LD_INT 2
10777: ST_TO_ADDR
10778: GO 10800
10780: LD_INT 3
10782: DOUBLE
10783: EQUAL
10784: IFTRUE 10788
10786: GO 10799
10788: POP
// selected_option := 3 ; end ;
10789: LD_ADDR_VAR 0 2
10793: PUSH
10794: LD_INT 3
10796: ST_TO_ADDR
10797: GO 10800
10799: POP
// if selected_option = 2 then
10800: LD_VAR 0 2
10804: PUSH
10805: LD_INT 2
10807: EQUAL
10808: IFFALSE 10902
// begin Say ( JMM , D13b-JMM-1 ) ;
10810: LD_EXP 16
10814: PPUSH
10815: LD_STRING D13b-JMM-1
10817: PPUSH
10818: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10822: LD_EXP 47
10826: PPUSH
10827: LD_STRING D13b-Bur-1
10829: PPUSH
10830: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10834: LD_EXP 16
10838: PPUSH
10839: LD_STRING D13b-JMM-2
10841: PPUSH
10842: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10846: LD_EXP 56
10850: PPUSH
10851: LD_STRING D13b-Abd-2
10853: PPUSH
10854: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10858: LD_EXP 16
10862: PPUSH
10863: LD_STRING D13b-JMM-3
10865: PPUSH
10866: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10870: LD_EXP 56
10874: PPUSH
10875: LD_STRING D13b-Abd-3
10877: PPUSH
10878: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10882: LD_EXP 16
10886: PPUSH
10887: LD_STRING D13b-JMM-4
10889: PPUSH
10890: CALL_OW 88
// ar_active_attack := true ;
10894: LD_ADDR_EXP 9
10898: PUSH
10899: LD_INT 1
10901: ST_TO_ADDR
// end ; if selected_option = 3 then
10902: LD_VAR 0 2
10906: PUSH
10907: LD_INT 3
10909: EQUAL
10910: IFFALSE 10936
// begin Say ( JMM , D13c-JMM-1 ) ;
10912: LD_EXP 16
10916: PPUSH
10917: LD_STRING D13c-JMM-1
10919: PPUSH
10920: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10924: LD_EXP 47
10928: PPUSH
10929: LD_STRING D13c-Bur-1
10931: PPUSH
10932: CALL_OW 88
// end ; DialogueOff ;
10936: CALL_OW 7
// if not ar_active_attack then
10940: LD_EXP 9
10944: NOT
10945: IFFALSE 10962
// begin wait ( 6 6$00 ) ;
10947: LD_INT 12600
10949: PPUSH
10950: CALL_OW 67
// ar_active_attack := true ;
10954: LD_ADDR_EXP 9
10958: PUSH
10959: LD_INT 1
10961: ST_TO_ADDR
// end ; end ;
10962: PPOPN 2
10964: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10965: LD_EXP 47
10969: PPUSH
10970: CALL_OW 305
10974: PUSH
10975: LD_EXP 47
10979: PPUSH
10980: CALL_OW 255
10984: PUSH
10985: LD_INT 7
10987: EQUAL
10988: AND
10989: IFFALSE 11185
10991: GO 10993
10993: DISABLE
10994: LD_INT 0
10996: PPUSH
// begin wait ( 4 4$40 ) ;
10997: LD_INT 9800
10999: PPUSH
11000: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11004: LD_INT 35
11006: PPUSH
11007: CALL_OW 67
// until not ru_attackers ;
11011: LD_EXP 53
11015: NOT
11016: IFFALSE 11004
// PrepareGnyevko ;
11018: CALL 2250 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11022: LD_EXP 49
11026: PPUSH
11027: LD_INT 124
11029: PPUSH
11030: LD_INT 118
11032: PPUSH
11033: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11037: LD_EXP 49
11041: PPUSH
11042: CALL_OW 200
// time := 0 0$00 ;
11046: LD_ADDR_VAR 0 1
11050: PUSH
11051: LD_INT 0
11053: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11054: LD_INT 35
11056: PPUSH
11057: CALL_OW 67
// time := time + 0 0$1 ;
11061: LD_ADDR_VAR 0 1
11065: PUSH
11066: LD_VAR 0 1
11070: PUSH
11071: LD_INT 35
11073: PLUS
11074: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11075: LD_EXP 49
11079: PPUSH
11080: LD_INT 124
11082: PPUSH
11083: LD_INT 118
11085: PPUSH
11086: CALL_OW 307
11090: PUSH
11091: LD_VAR 0 1
11095: PUSH
11096: LD_INT 1050
11098: GREATEREQUAL
11099: OR
11100: IFFALSE 11054
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11102: LD_EXP 49
11106: PPUSH
11107: LD_STRING DBelkov-Gny-1
11109: PPUSH
11110: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11114: LD_EXP 47
11118: PPUSH
11119: LD_STRING DBelkov-Bur-1a
11121: PPUSH
11122: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11126: LD_INT 35
11128: PPUSH
11129: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11133: LD_EXP 49
11137: PPUSH
11138: LD_INT 22
11140: PUSH
11141: LD_INT 7
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PPUSH
11148: CALL_OW 69
11152: PPUSH
11153: LD_EXP 49
11157: PPUSH
11158: CALL_OW 74
11162: PPUSH
11163: CALL_OW 296
11167: PUSH
11168: LD_INT 8
11170: LESS
11171: IFFALSE 11126
// SetSide ( Gnyevko , 7 ) ;
11173: LD_EXP 49
11177: PPUSH
11178: LD_INT 7
11180: PPUSH
11181: CALL_OW 235
// end ;
11185: PPOPN 1
11187: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11188: LD_EXP 47
11192: PPUSH
11193: CALL_OW 255
11197: PUSH
11198: LD_INT 7
11200: EQUAL
11201: IFFALSE 11211
11203: GO 11205
11205: DISABLE
// begin enable ;
11206: ENABLE
// PrepareAmericanAttack ;
11207: CALL 6853 0 0
// end ;
11211: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11212: LD_INT 22
11214: PUSH
11215: LD_INT 1
11217: PUSH
11218: EMPTY
11219: LIST
11220: LIST
11221: PPUSH
11222: CALL_OW 69
11226: IFFALSE 11410
11228: GO 11230
11230: DISABLE
11231: LD_INT 0
11233: PPUSH
11234: PPUSH
// begin while true do
11235: LD_INT 1
11237: IFFALSE 11294
// begin wait ( 0 0$1 ) ;
11239: LD_INT 35
11241: PPUSH
11242: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11246: LD_ADDR_VAR 0 2
11250: PUSH
11251: LD_INT 22
11253: PUSH
11254: LD_INT 1
11256: PUSH
11257: EMPTY
11258: LIST
11259: LIST
11260: PPUSH
11261: CALL_OW 69
11265: PPUSH
11266: LD_EXP 16
11270: PPUSH
11271: CALL_OW 74
11275: ST_TO_ADDR
// if See ( 7 , tmp ) then
11276: LD_INT 7
11278: PPUSH
11279: LD_VAR 0 2
11283: PPUSH
11284: CALL_OW 292
11288: IFFALSE 11292
// break ;
11290: GO 11294
// end ;
11292: GO 11235
// DialogueOn ;
11294: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11298: LD_VAR 0 2
11302: PPUSH
11303: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11307: LD_VAR 0 2
11311: PPUSH
11312: CALL_OW 250
11316: PPUSH
11317: LD_VAR 0 2
11321: PPUSH
11322: CALL_OW 251
11326: PPUSH
11327: LD_INT 7
11329: PPUSH
11330: LD_INT 8
11332: PPUSH
11333: CALL_OW 330
// if Denis then
11337: LD_EXP 22
11341: IFFALSE 11355
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11343: LD_EXP 22
11347: PPUSH
11348: LD_STRING DAmerAttack-Pet-1
11350: PPUSH
11351: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11355: LD_EXP 16
11359: PPUSH
11360: LD_STRING DAmerAttack-JMM-1
11362: PPUSH
11363: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11367: LD_EXP 47
11371: PPUSH
11372: LD_STRING DStop-Bur-1
11374: PPUSH
11375: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11379: LD_VAR 0 2
11383: PPUSH
11384: CALL_OW 250
11388: PPUSH
11389: LD_VAR 0 2
11393: PPUSH
11394: CALL_OW 251
11398: PPUSH
11399: LD_INT 7
11401: PPUSH
11402: CALL_OW 331
// DialogueOff ;
11406: CALL_OW 7
// end ;
11410: PPOPN 2
11412: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11413: LD_INT 22
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: EMPTY
11420: LIST
11421: LIST
11422: PUSH
11423: LD_INT 21
11425: PUSH
11426: LD_INT 1
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PPUSH
11437: CALL_OW 69
11441: PUSH
11442: LD_INT 0
11444: EQUAL
11445: IFFALSE 11487
11447: GO 11449
11449: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11450: LD_STRING M5a
11452: PPUSH
11453: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11457: LD_EXP 16
11461: PPUSH
11462: LD_STRING D8-JMM-1
11464: PPUSH
11465: CALL_OW 88
// if Gossudarov then
11469: LD_EXP 33
11473: IFFALSE 11487
// Say ( Gossudarov , D8-Gos-1 ) ;
11475: LD_EXP 33
11479: PPUSH
11480: LD_STRING D8-Gos-1
11482: PPUSH
11483: CALL_OW 88
// end ;
11487: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11488: LD_INT 22
11490: PUSH
11491: LD_INT 2
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: PUSH
11498: LD_INT 21
11500: PUSH
11501: LD_INT 1
11503: PUSH
11504: EMPTY
11505: LIST
11506: LIST
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PPUSH
11512: CALL_OW 69
11516: PUSH
11517: LD_INT 0
11519: EQUAL
11520: IFFALSE 11570
11522: GO 11524
11524: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11525: LD_STRING M4c
11527: PPUSH
11528: CALL_OW 337
// if Roth then
11532: LD_EXP 17
11536: IFFALSE 11552
// Say ( Roth , DStop-Roth-1 ) else
11538: LD_EXP 17
11542: PPUSH
11543: LD_STRING DStop-Roth-1
11545: PPUSH
11546: CALL_OW 88
11550: GO 11570
// if Gossudarov then
11552: LD_EXP 33
11556: IFFALSE 11570
// Say ( Gossudarov , D8-Gos-1a ) ;
11558: LD_EXP 33
11562: PPUSH
11563: LD_STRING D8-Gos-1a
11565: PPUSH
11566: CALL_OW 88
// end ;
11570: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11571: LD_INT 7
11573: PPUSH
11574: LD_INT 1
11576: PPUSH
11577: LD_INT 1
11579: PPUSH
11580: CALL 14901 0 3
11584: PUSH
11585: LD_INT 0
11587: EQUAL
11588: PUSH
11589: LD_INT 7
11591: PPUSH
11592: LD_INT 3
11594: PPUSH
11595: LD_INT 1
11597: PPUSH
11598: CALL 14901 0 3
11602: PUSH
11603: LD_INT 0
11605: EQUAL
11606: AND
11607: IFFALSE 11619
11609: GO 11611
11611: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11612: LD_STRING M1a
11614: PPUSH
11615: CALL_OW 337
// end ;
11619: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11620: LD_INT 22
11622: PUSH
11623: LD_INT 2
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: PUSH
11630: LD_INT 21
11632: PUSH
11633: LD_INT 1
11635: PUSH
11636: EMPTY
11637: LIST
11638: LIST
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PPUSH
11644: CALL_OW 69
11648: PUSH
11649: LD_INT 0
11651: EQUAL
11652: PUSH
11653: LD_INT 22
11655: PUSH
11656: LD_INT 3
11658: PUSH
11659: EMPTY
11660: LIST
11661: LIST
11662: PUSH
11663: LD_INT 21
11665: PUSH
11666: LD_INT 1
11668: PUSH
11669: EMPTY
11670: LIST
11671: LIST
11672: PUSH
11673: EMPTY
11674: LIST
11675: LIST
11676: PPUSH
11677: CALL_OW 69
11681: PUSH
11682: LD_INT 0
11684: EQUAL
11685: AND
11686: PUSH
11687: LD_INT 22
11689: PUSH
11690: LD_INT 1
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PPUSH
11697: CALL_OW 69
11701: PUSH
11702: LD_INT 0
11704: EQUAL
11705: AND
11706: PUSH
11707: LD_INT 7
11709: PPUSH
11710: LD_INT 1
11712: PPUSH
11713: LD_INT 1
11715: PPUSH
11716: CALL 14901 0 3
11720: PUSH
11721: LD_INT 0
11723: EQUAL
11724: AND
11725: PUSH
11726: LD_INT 7
11728: PPUSH
11729: LD_INT 3
11731: PPUSH
11732: LD_INT 1
11734: PPUSH
11735: CALL 14901 0 3
11739: PUSH
11740: LD_INT 0
11742: EQUAL
11743: AND
11744: IFFALSE 13219
11746: GO 11748
11748: DISABLE
11749: LD_INT 0
11751: PPUSH
11752: PPUSH
11753: PPUSH
11754: PPUSH
11755: PPUSH
11756: PPUSH
// begin m1 := false ;
11757: LD_ADDR_VAR 0 4
11761: PUSH
11762: LD_INT 0
11764: ST_TO_ADDR
// m2 := false ;
11765: LD_ADDR_VAR 0 5
11769: PUSH
11770: LD_INT 0
11772: ST_TO_ADDR
// m3 := false ;
11773: LD_ADDR_VAR 0 6
11777: PUSH
11778: LD_INT 0
11780: ST_TO_ADDR
// if tick < 40 40$00 then
11781: LD_OWVAR 1
11785: PUSH
11786: LD_INT 84000
11788: LESS
11789: IFFALSE 11798
// SetAchievement ( ACH_ASPEED_17 ) ;
11791: LD_STRING ACH_ASPEED_17
11793: PPUSH
11794: CALL_OW 543
// wait ( 0 0$5 ) ;
11798: LD_INT 175
11800: PPUSH
11801: CALL_OW 67
// if not masha_killed then
11805: LD_EXP 10
11809: NOT
11810: IFFALSE 11832
// begin m1 := true ;
11812: LD_ADDR_VAR 0 4
11816: PUSH
11817: LD_INT 1
11819: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11820: LD_STRING Masha
11822: PPUSH
11823: LD_INT 1
11825: PPUSH
11826: CALL_OW 101
// end else
11830: GO 11843
// AddMedal ( Masha , - 1 ) ;
11832: LD_STRING Masha
11834: PPUSH
11835: LD_INT 1
11837: NEG
11838: PPUSH
11839: CALL_OW 101
// if abdul_escaped then
11843: LD_EXP 13
11847: IFFALSE 11862
// AddMedal ( Abdul , - 1 ) else
11849: LD_STRING Abdul
11851: PPUSH
11852: LD_INT 1
11854: NEG
11855: PPUSH
11856: CALL_OW 101
11860: GO 11880
// begin m2 := true ;
11862: LD_ADDR_VAR 0 5
11866: PUSH
11867: LD_INT 1
11869: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11870: LD_STRING Abdul
11872: PPUSH
11873: LD_INT 1
11875: PPUSH
11876: CALL_OW 101
// end ; if loss_counter = 0 then
11880: LD_EXP 14
11884: PUSH
11885: LD_INT 0
11887: EQUAL
11888: IFFALSE 11910
// begin m3 := true ;
11890: LD_ADDR_VAR 0 6
11894: PUSH
11895: LD_INT 1
11897: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11898: LD_STRING People
11900: PPUSH
11901: LD_INT 2
11903: PPUSH
11904: CALL_OW 101
// end else
11908: GO 11972
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
11910: LD_EXP 14
11914: PUSH
11915: LD_INT 3
11917: PUSH
11918: LD_INT 2
11920: PUSH
11921: LD_INT 2
11923: PUSH
11924: LD_INT 1
11926: PUSH
11927: EMPTY
11928: LIST
11929: LIST
11930: LIST
11931: LIST
11932: PUSH
11933: LD_OWVAR 67
11937: ARRAY
11938: LESSEQUAL
11939: IFFALSE 11961
// begin AddMedal ( People , 1 ) ;
11941: LD_STRING People
11943: PPUSH
11944: LD_INT 1
11946: PPUSH
11947: CALL_OW 101
// m3 := true ;
11951: LD_ADDR_VAR 0 6
11955: PUSH
11956: LD_INT 1
11958: ST_TO_ADDR
// end else
11959: GO 11972
// AddMedal ( People , - 1 ) ;
11961: LD_STRING People
11963: PPUSH
11964: LD_INT 1
11966: NEG
11967: PPUSH
11968: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
11972: LD_OWVAR 67
11976: PUSH
11977: LD_INT 3
11979: GREATEREQUAL
11980: PUSH
11981: LD_VAR 0 4
11985: AND
11986: PUSH
11987: LD_VAR 0 5
11991: AND
11992: PUSH
11993: LD_VAR 0 6
11997: AND
11998: IFFALSE 12010
// SetAchievementEX ( ACH_AMER , 17 ) ;
12000: LD_STRING ACH_AMER
12002: PPUSH
12003: LD_INT 17
12005: PPUSH
12006: CALL_OW 564
// GiveMedals ( MAIN ) ;
12010: LD_STRING MAIN
12012: PPUSH
12013: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12017: LD_ADDR_VAR 0 2
12021: PUSH
12022: LD_INT 22
12024: PUSH
12025: LD_INT 7
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PUSH
12032: LD_INT 2
12034: PUSH
12035: LD_INT 25
12037: PUSH
12038: LD_INT 1
12040: PUSH
12041: EMPTY
12042: LIST
12043: LIST
12044: PUSH
12045: LD_INT 25
12047: PUSH
12048: LD_INT 2
12050: PUSH
12051: EMPTY
12052: LIST
12053: LIST
12054: PUSH
12055: LD_INT 25
12057: PUSH
12058: LD_INT 3
12060: PUSH
12061: EMPTY
12062: LIST
12063: LIST
12064: PUSH
12065: LD_INT 25
12067: PUSH
12068: LD_INT 4
12070: PUSH
12071: EMPTY
12072: LIST
12073: LIST
12074: PUSH
12075: LD_INT 25
12077: PUSH
12078: LD_INT 5
12080: PUSH
12081: EMPTY
12082: LIST
12083: LIST
12084: PUSH
12085: LD_INT 25
12087: PUSH
12088: LD_INT 8
12090: PUSH
12091: EMPTY
12092: LIST
12093: LIST
12094: PUSH
12095: LD_INT 25
12097: PUSH
12098: LD_INT 9
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: PUSH
12105: EMPTY
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: LIST
12113: LIST
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PPUSH
12119: CALL_OW 69
12123: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12124: LD_VAR 0 2
12128: PPUSH
12129: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
12133: LD_ADDR_VAR 0 3
12137: PUSH
12138: LD_EXP 16
12142: PUSH
12143: LD_EXP 17
12147: PUSH
12148: LD_EXP 18
12152: PUSH
12153: LD_EXP 19
12157: PUSH
12158: LD_EXP 20
12162: PUSH
12163: LD_EXP 21
12167: PUSH
12168: LD_EXP 22
12172: PUSH
12173: LD_EXP 23
12177: PUSH
12178: LD_EXP 24
12182: PUSH
12183: LD_EXP 25
12187: PUSH
12188: LD_EXP 26
12192: PUSH
12193: LD_EXP 27
12197: PUSH
12198: LD_EXP 28
12202: PUSH
12203: LD_EXP 29
12207: PUSH
12208: LD_EXP 30
12212: PUSH
12213: LD_EXP 31
12217: PUSH
12218: LD_EXP 32
12222: PUSH
12223: LD_EXP 33
12227: PUSH
12228: LD_EXP 34
12232: PUSH
12233: LD_EXP 35
12237: PUSH
12238: LD_EXP 37
12242: PUSH
12243: LD_EXP 38
12247: PUSH
12248: LD_EXP 39
12252: PUSH
12253: LD_EXP 40
12257: PUSH
12258: LD_EXP 41
12262: PUSH
12263: LD_EXP 42
12267: PUSH
12268: LD_EXP 43
12272: PUSH
12273: LD_EXP 44
12277: PUSH
12278: LD_EXP 45
12282: PUSH
12283: LD_EXP 46
12287: PUSH
12288: LD_EXP 47
12292: PUSH
12293: LD_EXP 48
12297: PUSH
12298: LD_EXP 49
12302: PUSH
12303: EMPTY
12304: LIST
12305: LIST
12306: LIST
12307: LIST
12308: LIST
12309: LIST
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: LIST
12315: LIST
12316: LIST
12317: LIST
12318: LIST
12319: LIST
12320: LIST
12321: LIST
12322: LIST
12323: LIST
12324: LIST
12325: LIST
12326: LIST
12327: LIST
12328: LIST
12329: LIST
12330: LIST
12331: LIST
12332: LIST
12333: LIST
12334: LIST
12335: LIST
12336: LIST
12337: ST_TO_ADDR
// if tmp diff tmp2 then
12338: LD_VAR 0 2
12342: PUSH
12343: LD_VAR 0 3
12347: DIFF
12348: IFFALSE 12368
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12350: LD_VAR 0 2
12354: PUSH
12355: LD_VAR 0 3
12359: DIFF
12360: PPUSH
12361: LD_STRING 13a_others
12363: PPUSH
12364: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12368: LD_EXP 16
12372: PPUSH
12373: LD_STRING 13a_JMM
12375: PPUSH
12376: CALL_OW 38
// if Titov then
12380: LD_EXP 35
12384: IFFALSE 12398
// SaveCharacters ( Titov , 13a_Titov ) ;
12386: LD_EXP 35
12390: PPUSH
12391: LD_STRING 13a_Titov
12393: PPUSH
12394: CALL_OW 38
// if Dolgov then
12398: LD_EXP 37
12402: IFFALSE 12416
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12404: LD_EXP 37
12408: PPUSH
12409: LD_STRING 13a_Dolgov
12411: PPUSH
12412: CALL_OW 38
// if Petrosyan then
12416: LD_EXP 38
12420: IFFALSE 12434
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12422: LD_EXP 38
12426: PPUSH
12427: LD_STRING 13a_Petrosyan
12429: PPUSH
12430: CALL_OW 38
// if Scholtze then
12434: LD_EXP 39
12438: IFFALSE 12452
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12440: LD_EXP 39
12444: PPUSH
12445: LD_STRING 13a_Scholtze
12447: PPUSH
12448: CALL_OW 38
// if Oblukov then
12452: LD_EXP 40
12456: IFFALSE 12470
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12458: LD_EXP 40
12462: PPUSH
12463: LD_STRING 13a_Oblukov
12465: PPUSH
12466: CALL_OW 38
// if Kapitsova then
12470: LD_EXP 41
12474: IFFALSE 12488
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12476: LD_EXP 41
12480: PPUSH
12481: LD_STRING 13a_Kapitsova
12483: PPUSH
12484: CALL_OW 38
// if Lipshchin then
12488: LD_EXP 42
12492: IFFALSE 12506
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12494: LD_EXP 42
12498: PPUSH
12499: LD_STRING 13a_Lipshchin
12501: PPUSH
12502: CALL_OW 38
// if Petrovova then
12506: LD_EXP 43
12510: IFFALSE 12524
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12512: LD_EXP 43
12516: PPUSH
12517: LD_STRING 13a_Petrovova
12519: PPUSH
12520: CALL_OW 38
// if Kovalyuk then
12524: LD_EXP 44
12528: IFFALSE 12542
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12530: LD_EXP 44
12534: PPUSH
12535: LD_STRING 13a_Kovalyuk
12537: PPUSH
12538: CALL_OW 38
// if Kuzmov then
12542: LD_EXP 45
12546: IFFALSE 12560
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12548: LD_EXP 45
12552: PPUSH
12553: LD_STRING 13a_Kuzmov
12555: PPUSH
12556: CALL_OW 38
// if Karamazov then
12560: LD_EXP 46
12564: IFFALSE 12578
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12566: LD_EXP 46
12570: PPUSH
12571: LD_STRING 13a_Karamazov
12573: PPUSH
12574: CALL_OW 38
// if Burlak then
12578: LD_EXP 47
12582: IFFALSE 12596
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12584: LD_EXP 47
12588: PPUSH
12589: LD_STRING 13a_Burlak
12591: PPUSH
12592: CALL_OW 38
// if Belkov then
12596: LD_EXP 48
12600: IFFALSE 12614
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12602: LD_EXP 48
12606: PPUSH
12607: LD_STRING 13a_Belkov
12609: PPUSH
12610: CALL_OW 38
// if Gnyevko then
12614: LD_EXP 49
12618: IFFALSE 12632
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12620: LD_EXP 49
12624: PPUSH
12625: LD_STRING 13a_Gnyevko
12627: PPUSH
12628: CALL_OW 38
// if Lisa then
12632: LD_EXP 18
12636: IFFALSE 12650
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12638: LD_EXP 18
12642: PPUSH
12643: LD_STRING 13a_Lisa
12645: PPUSH
12646: CALL_OW 38
// if Donaldson then
12650: LD_EXP 19
12654: IFFALSE 12668
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12656: LD_EXP 19
12660: PPUSH
12661: LD_STRING 13a_Donaldson
12663: PPUSH
12664: CALL_OW 38
// if Bobby then
12668: LD_EXP 20
12672: IFFALSE 12686
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12674: LD_EXP 20
12678: PPUSH
12679: LD_STRING 13a_Bobby
12681: PPUSH
12682: CALL_OW 38
// if Cyrus then
12686: LD_EXP 21
12690: IFFALSE 12704
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12692: LD_EXP 21
12696: PPUSH
12697: LD_STRING 13a_Cyrus
12699: PPUSH
12700: CALL_OW 38
// if Denis then
12704: LD_EXP 22
12708: IFFALSE 12722
// SaveCharacters ( Denis , 13a_Denis ) ;
12710: LD_EXP 22
12714: PPUSH
12715: LD_STRING 13a_Denis
12717: PPUSH
12718: CALL_OW 38
// if Brown then
12722: LD_EXP 23
12726: IFFALSE 12740
// SaveCharacters ( Brown , 13a_Brown ) ;
12728: LD_EXP 23
12732: PPUSH
12733: LD_STRING 13a_Brown
12735: PPUSH
12736: CALL_OW 38
// if Gladstone then
12740: LD_EXP 24
12744: IFFALSE 12758
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12746: LD_EXP 24
12750: PPUSH
12751: LD_STRING 13a_Gladstone
12753: PPUSH
12754: CALL_OW 38
// if Houten then
12758: LD_EXP 25
12762: IFFALSE 12776
// SaveCharacters ( Houten , 13a_Houten ) ;
12764: LD_EXP 25
12768: PPUSH
12769: LD_STRING 13a_Houten
12771: PPUSH
12772: CALL_OW 38
// if Cornel then
12776: LD_EXP 26
12780: IFFALSE 12794
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12782: LD_EXP 26
12786: PPUSH
12787: LD_STRING 13a_Cornel
12789: PPUSH
12790: CALL_OW 38
// if Gary then
12794: LD_EXP 27
12798: IFFALSE 12812
// SaveCharacters ( Gary , 13a_Gary ) ;
12800: LD_EXP 27
12804: PPUSH
12805: LD_STRING 13a_Gary
12807: PPUSH
12808: CALL_OW 38
// if Frank then
12812: LD_EXP 28
12816: IFFALSE 12830
// SaveCharacters ( Frank , 13a_Frank ) ;
12818: LD_EXP 28
12822: PPUSH
12823: LD_STRING 13a_Frank
12825: PPUSH
12826: CALL_OW 38
// if Kikuchi then
12830: LD_EXP 29
12834: IFFALSE 12848
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12836: LD_EXP 29
12840: PPUSH
12841: LD_STRING 13a_Kikuchi
12843: PPUSH
12844: CALL_OW 38
// if Simms then
12848: LD_EXP 30
12852: IFFALSE 12866
// SaveCharacters ( Simms , 13a_Simms ) ;
12854: LD_EXP 30
12858: PPUSH
12859: LD_STRING 13a_Simms
12861: PPUSH
12862: CALL_OW 38
// if Joan then
12866: LD_EXP 31
12870: IFFALSE 12884
// SaveCharacters ( Joan , 13a_Joan ) ;
12872: LD_EXP 31
12876: PPUSH
12877: LD_STRING 13a_Joan
12879: PPUSH
12880: CALL_OW 38
// if DeltaDoctor then
12884: LD_EXP 32
12888: IFFALSE 12902
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12890: LD_EXP 32
12894: PPUSH
12895: LD_STRING 13a_DeltaDoctor
12897: PPUSH
12898: CALL_OW 38
// if Gossudarov then
12902: LD_EXP 33
12906: IFFALSE 12920
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12908: LD_EXP 33
12912: PPUSH
12913: LD_STRING 13a_Gossudarov
12915: PPUSH
12916: CALL_OW 38
// if Kirilenkova then
12920: LD_EXP 34
12924: IFFALSE 12938
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12926: LD_EXP 34
12930: PPUSH
12931: LD_STRING 13a_Kirilenkova
12933: PPUSH
12934: CALL_OW 38
// if Roth then
12938: LD_EXP 17
12942: IFFALSE 12956
// SaveCharacters ( Roth , 13a_Roth ) ;
12944: LD_EXP 17
12948: PPUSH
12949: LD_STRING 13a_Roth
12951: PPUSH
12952: CALL_OW 38
// if Masha then
12956: LD_EXP 50
12960: IFFALSE 13015
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12962: LD_EXP 50
12966: PPUSH
12967: CALL_OW 265
12971: PUSH
12972: LD_EXP 50
12976: PPUSH
12977: CALL_OW 262
12981: PUSH
12982: LD_EXP 50
12986: PPUSH
12987: CALL_OW 263
12991: PUSH
12992: LD_EXP 50
12996: PPUSH
12997: CALL_OW 264
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: PPUSH
13008: LD_STRING 13a_Masha
13010: PPUSH
13011: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13015: LD_ADDR_VAR 0 2
13019: PUSH
13020: LD_INT 21
13022: PUSH
13023: LD_INT 3
13025: PUSH
13026: EMPTY
13027: LIST
13028: LIST
13029: PPUSH
13030: CALL_OW 69
13034: ST_TO_ADDR
// tmp2 := [ ] ;
13035: LD_ADDR_VAR 0 3
13039: PUSH
13040: EMPTY
13041: ST_TO_ADDR
// if tmp then
13042: LD_VAR 0 2
13046: IFFALSE 13197
// for i in tmp do
13048: LD_ADDR_VAR 0 1
13052: PUSH
13053: LD_VAR 0 2
13057: PUSH
13058: FOR_IN
13059: IFFALSE 13195
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13061: LD_ADDR_VAR 0 3
13065: PUSH
13066: LD_VAR 0 3
13070: PUSH
13071: LD_VAR 0 1
13075: PPUSH
13076: CALL_OW 255
13080: PUSH
13081: LD_VAR 0 1
13085: PPUSH
13086: CALL_OW 248
13090: PUSH
13091: LD_VAR 0 1
13095: PPUSH
13096: CALL_OW 266
13100: PUSH
13101: LD_VAR 0 1
13105: PPUSH
13106: CALL_OW 250
13110: PUSH
13111: LD_VAR 0 1
13115: PPUSH
13116: CALL_OW 251
13120: PUSH
13121: LD_VAR 0 1
13125: PPUSH
13126: CALL_OW 254
13130: PUSH
13131: LD_VAR 0 1
13135: PPUSH
13136: CALL_OW 267
13140: PUSH
13141: LD_VAR 0 1
13145: PPUSH
13146: LD_INT 1
13148: PPUSH
13149: CALL_OW 268
13153: PUSH
13154: LD_VAR 0 1
13158: PPUSH
13159: LD_INT 2
13161: PPUSH
13162: CALL_OW 268
13166: PUSH
13167: LD_VAR 0 1
13171: PPUSH
13172: CALL_OW 269
13176: PUSH
13177: EMPTY
13178: LIST
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: LIST
13187: LIST
13188: PUSH
13189: EMPTY
13190: LIST
13191: ADD
13192: ST_TO_ADDR
13193: GO 13058
13195: POP
13196: POP
// if tmp2 then
13197: LD_VAR 0 3
13201: IFFALSE 13215
// SaveVariable ( tmp2 , 13a_buildings ) ;
13203: LD_VAR 0 3
13207: PPUSH
13208: LD_STRING 13a_buildings
13210: PPUSH
13211: CALL_OW 39
// YouWin ;
13215: CALL_OW 103
// end ;
13219: PPOPN 6
13221: END
// export function SciRu ; var tmp , t ; begin
13222: LD_INT 0
13224: PPUSH
13225: PPUSH
13226: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13227: LD_ADDR_VAR 0 3
13231: PUSH
13232: LD_EXP 33
13236: PUSH
13237: LD_EXP 47
13241: PUSH
13242: LD_EXP 35
13246: PUSH
13247: LD_EXP 48
13251: PUSH
13252: LD_EXP 49
13256: PUSH
13257: LD_EXP 38
13261: PUSH
13262: LD_EXP 39
13266: PUSH
13267: LD_EXP 37
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: LIST
13279: LIST
13280: LIST
13281: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13282: LD_ADDR_VAR 0 2
13286: PUSH
13287: LD_INT 22
13289: PUSH
13290: LD_INT 7
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: PUSH
13297: LD_INT 23
13299: PUSH
13300: LD_INT 3
13302: PUSH
13303: EMPTY
13304: LIST
13305: LIST
13306: PUSH
13307: LD_INT 25
13309: PUSH
13310: LD_INT 4
13312: PUSH
13313: EMPTY
13314: LIST
13315: LIST
13316: PUSH
13317: LD_INT 26
13319: PUSH
13320: LD_INT 1
13322: PUSH
13323: EMPTY
13324: LIST
13325: LIST
13326: PUSH
13327: EMPTY
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: PPUSH
13333: CALL_OW 69
13337: PUSH
13338: LD_VAR 0 3
13342: DIFF
13343: ST_TO_ADDR
// if tmp then
13344: LD_VAR 0 2
13348: IFFALSE 13364
// result := tmp [ 1 ] ;
13350: LD_ADDR_VAR 0 1
13354: PUSH
13355: LD_VAR 0 2
13359: PUSH
13360: LD_INT 1
13362: ARRAY
13363: ST_TO_ADDR
// end ;
13364: LD_VAR 0 1
13368: RET
// export function SolRu ; var tmp , t ; begin
13369: LD_INT 0
13371: PPUSH
13372: PPUSH
13373: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13374: LD_ADDR_VAR 0 3
13378: PUSH
13379: LD_EXP 33
13383: PUSH
13384: LD_EXP 47
13388: PUSH
13389: LD_EXP 35
13393: PUSH
13394: LD_EXP 48
13398: PUSH
13399: LD_EXP 49
13403: PUSH
13404: LD_EXP 38
13408: PUSH
13409: LD_EXP 39
13413: PUSH
13414: LD_EXP 37
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: LIST
13428: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13429: LD_ADDR_VAR 0 2
13433: PUSH
13434: LD_INT 22
13436: PUSH
13437: LD_INT 7
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: PUSH
13444: LD_INT 23
13446: PUSH
13447: LD_INT 3
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 25
13456: PUSH
13457: LD_INT 1
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 26
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: LIST
13478: LIST
13479: PPUSH
13480: CALL_OW 69
13484: PUSH
13485: LD_VAR 0 3
13489: DIFF
13490: ST_TO_ADDR
// if tmp then
13491: LD_VAR 0 2
13495: IFFALSE 13511
// result := tmp [ 1 ] ;
13497: LD_ADDR_VAR 0 1
13501: PUSH
13502: LD_VAR 0 2
13506: PUSH
13507: LD_INT 1
13509: ARRAY
13510: ST_TO_ADDR
// end ; end_of_file
13511: LD_VAR 0 1
13515: RET
// export function CustomEvent ( event ) ; begin
13516: LD_INT 0
13518: PPUSH
// end ;
13519: LD_VAR 0 2
13523: RET
// on UnitDestroyed ( un ) do var i , side ;
13524: LD_INT 0
13526: PPUSH
13527: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
13528: LD_VAR 0 1
13532: PPUSH
13533: CALL 100001 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13537: LD_VAR 0 1
13541: PUSH
13542: LD_INT 22
13544: PUSH
13545: LD_INT 7
13547: PUSH
13548: EMPTY
13549: LIST
13550: LIST
13551: PUSH
13552: LD_INT 2
13554: PUSH
13555: LD_INT 25
13557: PUSH
13558: LD_INT 1
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: PUSH
13565: LD_INT 25
13567: PUSH
13568: LD_INT 2
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PUSH
13575: LD_INT 25
13577: PUSH
13578: LD_INT 3
13580: PUSH
13581: EMPTY
13582: LIST
13583: LIST
13584: PUSH
13585: LD_INT 25
13587: PUSH
13588: LD_INT 4
13590: PUSH
13591: EMPTY
13592: LIST
13593: LIST
13594: PUSH
13595: LD_INT 25
13597: PUSH
13598: LD_INT 5
13600: PUSH
13601: EMPTY
13602: LIST
13603: LIST
13604: PUSH
13605: LD_INT 25
13607: PUSH
13608: LD_INT 8
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PUSH
13615: LD_INT 25
13617: PUSH
13618: LD_INT 9
13620: PUSH
13621: EMPTY
13622: LIST
13623: LIST
13624: PUSH
13625: EMPTY
13626: LIST
13627: LIST
13628: LIST
13629: LIST
13630: LIST
13631: LIST
13632: LIST
13633: LIST
13634: PUSH
13635: EMPTY
13636: LIST
13637: LIST
13638: PPUSH
13639: CALL_OW 69
13643: IN
13644: IFFALSE 13660
// loss_counter := loss_counter + 1 ;
13646: LD_ADDR_EXP 14
13650: PUSH
13651: LD_EXP 14
13655: PUSH
13656: LD_INT 1
13658: PLUS
13659: ST_TO_ADDR
// if un = Abdul then
13660: LD_VAR 0 1
13664: PUSH
13665: LD_EXP 56
13669: EQUAL
13670: IFFALSE 13680
// abdul_escaped := false ;
13672: LD_ADDR_EXP 13
13676: PUSH
13677: LD_INT 0
13679: ST_TO_ADDR
// if un in ru_attackers then
13680: LD_VAR 0 1
13684: PUSH
13685: LD_EXP 53
13689: IN
13690: IFFALSE 13708
// ru_attackers := ru_attackers diff un ;
13692: LD_ADDR_EXP 53
13696: PUSH
13697: LD_EXP 53
13701: PUSH
13702: LD_VAR 0 1
13706: DIFF
13707: ST_TO_ADDR
// if un in ar_attackers then
13708: LD_VAR 0 1
13712: PUSH
13713: LD_EXP 11
13717: IN
13718: IFFALSE 13736
// ar_attackers := ar_attackers diff un ;
13720: LD_ADDR_EXP 11
13724: PUSH
13725: LD_EXP 11
13729: PUSH
13730: LD_VAR 0 1
13734: DIFF
13735: ST_TO_ADDR
// if un = JMM then
13736: LD_VAR 0 1
13740: PUSH
13741: LD_EXP 16
13745: EQUAL
13746: IFFALSE 13757
// begin YouLost ( JMM ) ;
13748: LD_STRING JMM
13750: PPUSH
13751: CALL_OW 104
// exit ;
13755: GO 13854
// end ; if un = Burlak then
13757: LD_VAR 0 1
13761: PUSH
13762: LD_EXP 47
13766: EQUAL
13767: IFFALSE 13778
// begin YouLost ( Burlak ) ;
13769: LD_STRING Burlak
13771: PPUSH
13772: CALL_OW 104
// exit ;
13776: GO 13854
// end ; if un = freedom then
13778: LD_VAR 0 1
13782: PUSH
13783: LD_EXP 3
13787: EQUAL
13788: IFFALSE 13799
// begin YouLost ( Destroyed ) ;
13790: LD_STRING Destroyed
13792: PPUSH
13793: CALL_OW 104
// exit ;
13797: GO 13854
// end ; if un = Masha then
13799: LD_VAR 0 1
13803: PUSH
13804: LD_EXP 50
13808: EQUAL
13809: IFFALSE 13826
// begin ChangeMissionObjectives ( M4b ) ;
13811: LD_STRING M4b
13813: PPUSH
13814: CALL_OW 337
// masha_killed := true ;
13818: LD_ADDR_EXP 10
13822: PUSH
13823: LD_INT 1
13825: ST_TO_ADDR
// end ; if un = Mastodont then
13826: LD_VAR 0 1
13830: PUSH
13831: LD_EXP 57
13835: EQUAL
13836: IFFALSE 13845
// ChangeMissionObjectives ( M4a ) ;
13838: LD_STRING M4a
13840: PPUSH
13841: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13845: LD_VAR 0 1
13849: PPUSH
13850: CALL 82513 0 1
// end ;
13854: PPOPN 3
13856: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13857: LD_VAR 0 1
13861: PPUSH
13862: LD_VAR 0 2
13866: PPUSH
13867: CALL 84847 0 2
// end ;
13871: PPOPN 2
13873: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13874: LD_VAR 0 1
13878: PPUSH
13879: CALL 83915 0 1
// end ;
13883: PPOPN 1
13885: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13886: LD_VAR 0 1
13890: PUSH
13891: LD_INT 22
13893: PUSH
13894: LD_INT 7
13896: PUSH
13897: EMPTY
13898: LIST
13899: LIST
13900: PUSH
13901: LD_INT 30
13903: PUSH
13904: LD_INT 0
13906: PUSH
13907: EMPTY
13908: LIST
13909: LIST
13910: PUSH
13911: EMPTY
13912: LIST
13913: LIST
13914: PPUSH
13915: CALL_OW 69
13919: IN
13920: IFFALSE 13959
// begin SetBName ( building , freedom ) ;
13922: LD_VAR 0 1
13926: PPUSH
13927: LD_STRING freedom
13929: PPUSH
13930: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13934: LD_INT 0
13936: PPUSH
13937: LD_INT 7
13939: PPUSH
13940: LD_INT 0
13942: PPUSH
13943: CALL_OW 324
// freedom := building ;
13947: LD_ADDR_EXP 3
13951: PUSH
13952: LD_VAR 0 1
13956: ST_TO_ADDR
// exit ;
13957: GO 14025
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13959: LD_VAR 0 1
13963: PUSH
13964: LD_INT 22
13966: PUSH
13967: LD_INT 7
13969: PUSH
13970: EMPTY
13971: LIST
13972: LIST
13973: PUSH
13974: LD_INT 23
13976: PUSH
13977: LD_INT 3
13979: PUSH
13980: EMPTY
13981: LIST
13982: LIST
13983: PUSH
13984: LD_INT 30
13986: PUSH
13987: LD_INT 6
13989: PUSH
13990: EMPTY
13991: LIST
13992: LIST
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: LIST
13998: PPUSH
13999: CALL_OW 69
14003: IN
14004: IFFALSE 14016
// begin ru_lab_builded := true ;
14006: LD_ADDR_EXP 5
14010: PUSH
14011: LD_INT 1
14013: ST_TO_ADDR
// exit ;
14014: GO 14025
// end ; MCE_BuildingComplete ( building ) ;
14016: LD_VAR 0 1
14020: PPUSH
14021: CALL 84156 0 1
// end ;
14025: PPOPN 1
14027: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14028: LD_VAR 0 1
14032: PPUSH
14033: LD_VAR 0 2
14037: PPUSH
14038: CALL 82209 0 2
// end ;
14042: PPOPN 2
14044: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14045: LD_VAR 0 1
14049: PPUSH
14050: LD_VAR 0 2
14054: PPUSH
14055: LD_VAR 0 3
14059: PPUSH
14060: LD_VAR 0 4
14064: PPUSH
14065: LD_VAR 0 5
14069: PPUSH
14070: CALL 81829 0 5
// end ;
14074: PPOPN 5
14076: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
14077: LD_VAR 0 1
14081: PPUSH
14082: LD_VAR 0 2
14086: PPUSH
14087: CALL 100123 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
14091: LD_VAR 0 1
14095: PPUSH
14096: LD_VAR 0 2
14100: PPUSH
14101: CALL 81410 0 2
// end ;
14105: PPOPN 2
14107: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14108: LD_VAR 0 1
14112: PPUSH
14113: CALL_OW 263
14117: PUSH
14118: LD_INT 3
14120: EQUAL
14121: PUSH
14122: LD_VAR 0 2
14126: PPUSH
14127: CALL_OW 263
14131: PUSH
14132: LD_INT 3
14134: EQUAL
14135: OR
14136: IFFALSE 14152
// hack_counter := hack_counter + 1 ;
14138: LD_ADDR_EXP 15
14142: PUSH
14143: LD_EXP 15
14147: PUSH
14148: LD_INT 1
14150: PLUS
14151: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14152: LD_VAR 0 1
14156: PPUSH
14157: LD_VAR 0 2
14161: PPUSH
14162: LD_VAR 0 3
14166: PPUSH
14167: LD_VAR 0 4
14171: PPUSH
14172: CALL 81248 0 4
// end ;
14176: PPOPN 4
14178: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14179: LD_VAR 0 1
14183: PPUSH
14184: LD_VAR 0 2
14188: PPUSH
14189: LD_VAR 0 3
14193: PPUSH
14194: CALL 81023 0 3
// end ;
14198: PPOPN 3
14200: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14201: LD_VAR 0 1
14205: PPUSH
14206: LD_VAR 0 2
14210: PPUSH
14211: CALL 80908 0 2
// end ;
14215: PPOPN 2
14217: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14218: LD_VAR 0 1
14222: PPUSH
14223: LD_VAR 0 2
14227: PPUSH
14228: CALL 85142 0 2
// end ;
14232: PPOPN 2
14234: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14235: LD_VAR 0 1
14239: PPUSH
14240: LD_VAR 0 2
14244: PPUSH
14245: LD_VAR 0 3
14249: PPUSH
14250: LD_VAR 0 4
14254: PPUSH
14255: CALL 85358 0 4
// end ;
14259: PPOPN 4
14261: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14262: LD_VAR 0 1
14266: PPUSH
14267: LD_VAR 0 2
14271: PPUSH
14272: CALL 80717 0 2
// end ;
14276: PPOPN 2
14278: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14279: LD_VAR 0 1
14283: PPUSH
14284: CALL 100107 0 1
// end ; end_of_file
14288: PPOPN 1
14290: END
// every 0 0$30 do var cr , time ;
14291: GO 14293
14293: DISABLE
14294: LD_INT 0
14296: PPUSH
14297: PPUSH
// begin time := 0 0$20 ;
14298: LD_ADDR_VAR 0 2
14302: PUSH
14303: LD_INT 700
14305: ST_TO_ADDR
// while game do
14306: LD_EXP 2
14310: IFFALSE 14413
// begin wait ( time ) ;
14312: LD_VAR 0 2
14316: PPUSH
14317: CALL_OW 67
// if tick > 2 2$00 then
14321: LD_OWVAR 1
14325: PUSH
14326: LD_INT 4200
14328: GREATER
14329: IFFALSE 14366
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14331: LD_ADDR_VAR 0 2
14335: PUSH
14336: LD_VAR 0 2
14340: PUSH
14341: LD_INT 140
14343: PUSH
14344: LD_INT 140
14346: PUSH
14347: LD_INT 210
14349: PUSH
14350: LD_INT 280
14352: PUSH
14353: EMPTY
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: PUSH
14359: LD_OWVAR 67
14363: ARRAY
14364: PLUS
14365: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14366: LD_INT 1
14368: PPUSH
14369: LD_INT 5
14371: PPUSH
14372: CALL_OW 12
14376: PPUSH
14377: LD_INT 70
14379: PPUSH
14380: LD_INT 49
14382: PPUSH
14383: LD_INT 25
14385: PPUSH
14386: LD_INT 1
14388: PPUSH
14389: CALL_OW 56
// if time > 3 3$00 then
14393: LD_VAR 0 2
14397: PUSH
14398: LD_INT 6300
14400: GREATER
14401: IFFALSE 14411
// time := 0 0$30 ;
14403: LD_ADDR_VAR 0 2
14407: PUSH
14408: LD_INT 1050
14410: ST_TO_ADDR
// end ;
14411: GO 14306
// end ;
14413: PPOPN 2
14415: END
// every 0 0$30 do var cr , time ;
14416: GO 14418
14418: DISABLE
14419: LD_INT 0
14421: PPUSH
14422: PPUSH
// begin time := 0 0$20 ;
14423: LD_ADDR_VAR 0 2
14427: PUSH
14428: LD_INT 700
14430: ST_TO_ADDR
// while game do
14431: LD_EXP 2
14435: IFFALSE 14528
// begin wait ( time ) ;
14437: LD_VAR 0 2
14441: PPUSH
14442: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14446: LD_ADDR_VAR 0 2
14450: PUSH
14451: LD_VAR 0 2
14455: PUSH
14456: LD_INT 140
14458: PUSH
14459: LD_INT 175
14461: PUSH
14462: LD_INT 210
14464: PUSH
14465: LD_INT 280
14467: PUSH
14468: EMPTY
14469: LIST
14470: LIST
14471: LIST
14472: LIST
14473: PUSH
14474: LD_OWVAR 67
14478: ARRAY
14479: PLUS
14480: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14481: LD_INT 3
14483: PPUSH
14484: LD_INT 5
14486: PPUSH
14487: CALL_OW 12
14491: PPUSH
14492: LD_INT 26
14494: PPUSH
14495: LD_INT 9
14497: PPUSH
14498: LD_INT 30
14500: PPUSH
14501: LD_INT 1
14503: PPUSH
14504: CALL_OW 56
// if time > 3 3$00 then
14508: LD_VAR 0 2
14512: PUSH
14513: LD_INT 6300
14515: GREATER
14516: IFFALSE 14526
// time := 0 0$20 ;
14518: LD_ADDR_VAR 0 2
14522: PUSH
14523: LD_INT 700
14525: ST_TO_ADDR
// end ;
14526: GO 14431
// end ;
14528: PPOPN 2
14530: END
// every 0 0$30 do var cr , time ;
14531: GO 14533
14533: DISABLE
14534: LD_INT 0
14536: PPUSH
14537: PPUSH
// begin time := 0 0$20 ;
14538: LD_ADDR_VAR 0 2
14542: PUSH
14543: LD_INT 700
14545: ST_TO_ADDR
// while game do
14546: LD_EXP 2
14550: IFFALSE 14679
// begin wait ( time ) ;
14552: LD_VAR 0 2
14556: PPUSH
14557: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
14561: LD_ADDR_VAR 0 2
14565: PUSH
14566: LD_VAR 0 2
14570: PUSH
14571: LD_INT 175
14573: PUSH
14574: LD_INT 210
14576: PUSH
14577: LD_INT 280
14579: PUSH
14580: LD_INT 350
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: PUSH
14589: LD_OWVAR 67
14593: ARRAY
14594: PLUS
14595: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14596: LD_INT 1
14598: PPUSH
14599: LD_INT 5
14601: PPUSH
14602: CALL_OW 12
14606: PPUSH
14607: LD_INT 179
14609: PPUSH
14610: LD_INT 101
14612: PPUSH
14613: LD_INT 20
14615: PPUSH
14616: LD_INT 1
14618: PPUSH
14619: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14623: LD_INT 350
14625: PPUSH
14626: LD_INT 525
14628: PPUSH
14629: CALL_OW 12
14633: PPUSH
14634: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14638: LD_INT 1
14640: PPUSH
14641: LD_INT 5
14643: PPUSH
14644: CALL_OW 12
14648: PPUSH
14649: LD_INT 9
14651: PPUSH
14652: LD_INT 1
14654: PPUSH
14655: CALL_OW 55
// if time > 4 4$00 then
14659: LD_VAR 0 2
14663: PUSH
14664: LD_INT 8400
14666: GREATER
14667: IFFALSE 14677
// time := 0 0$30 ;
14669: LD_ADDR_VAR 0 2
14673: PUSH
14674: LD_INT 1050
14676: ST_TO_ADDR
// end ;
14677: GO 14546
// end ;
14679: PPOPN 2
14681: END
// every 0 0$30 do var cr , time ;
14682: GO 14684
14684: DISABLE
14685: LD_INT 0
14687: PPUSH
14688: PPUSH
// begin time := 0 0$10 ;
14689: LD_ADDR_VAR 0 2
14693: PUSH
14694: LD_INT 350
14696: ST_TO_ADDR
// while game do
14697: LD_EXP 2
14701: IFFALSE 14835
// begin wait ( time ) ;
14703: LD_VAR 0 2
14707: PPUSH
14708: CALL_OW 67
// time := time + 0 0$10 ;
14712: LD_ADDR_VAR 0 2
14716: PUSH
14717: LD_VAR 0 2
14721: PUSH
14722: LD_INT 350
14724: PLUS
14725: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14726: LD_INT 1
14728: PPUSH
14729: LD_INT 5
14731: PPUSH
14732: CALL_OW 12
14736: PPUSH
14737: LD_INT 11
14739: PPUSH
14740: LD_INT 1
14742: PPUSH
14743: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14747: LD_ADDR_VAR 0 1
14751: PUSH
14752: LD_INT 1
14754: PPUSH
14755: LD_INT 3
14757: PPUSH
14758: CALL_OW 12
14762: ST_TO_ADDR
// if cr = 1 then
14763: LD_VAR 0 1
14767: PUSH
14768: LD_INT 1
14770: EQUAL
14771: IFFALSE 14815
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14773: LD_INT 700
14775: PPUSH
14776: LD_INT 1575
14778: PPUSH
14779: CALL_OW 12
14783: PPUSH
14784: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14788: LD_INT 1
14790: PPUSH
14791: LD_INT 5
14793: PPUSH
14794: CALL_OW 12
14798: PPUSH
14799: LD_INT 34
14801: PPUSH
14802: LD_INT 50
14804: PPUSH
14805: LD_INT 7
14807: PPUSH
14808: LD_INT 1
14810: PPUSH
14811: CALL_OW 56
// end ; if time > 4 4$00 then
14815: LD_VAR 0 2
14819: PUSH
14820: LD_INT 8400
14822: GREATER
14823: IFFALSE 14833
// time := 0 0$40 ;
14825: LD_ADDR_VAR 0 2
14829: PUSH
14830: LD_INT 1400
14832: ST_TO_ADDR
// end ;
14833: GO 14697
// end ; end_of_file
14835: PPOPN 2
14837: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14838: LD_INT 0
14840: PPUSH
14841: PPUSH
// if exist_mode then
14842: LD_VAR 0 2
14846: IFFALSE 14871
// unit := CreateCharacter ( prefix & ident ) else
14848: LD_ADDR_VAR 0 5
14852: PUSH
14853: LD_VAR 0 3
14857: PUSH
14858: LD_VAR 0 1
14862: STR
14863: PPUSH
14864: CALL_OW 34
14868: ST_TO_ADDR
14869: GO 14886
// unit := NewCharacter ( ident ) ;
14871: LD_ADDR_VAR 0 5
14875: PUSH
14876: LD_VAR 0 1
14880: PPUSH
14881: CALL_OW 25
14885: ST_TO_ADDR
// result := unit ;
14886: LD_ADDR_VAR 0 4
14890: PUSH
14891: LD_VAR 0 5
14895: ST_TO_ADDR
// end ;
14896: LD_VAR 0 4
14900: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14901: LD_INT 0
14903: PPUSH
14904: PPUSH
// if not side or not nation then
14905: LD_VAR 0 1
14909: NOT
14910: PUSH
14911: LD_VAR 0 2
14915: NOT
14916: OR
14917: IFFALSE 14921
// exit ;
14919: GO 15689
// case nation of nation_american :
14921: LD_VAR 0 2
14925: PUSH
14926: LD_INT 1
14928: DOUBLE
14929: EQUAL
14930: IFTRUE 14934
14932: GO 15148
14934: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14935: LD_ADDR_VAR 0 4
14939: PUSH
14940: LD_INT 35
14942: PUSH
14943: LD_INT 45
14945: PUSH
14946: LD_INT 46
14948: PUSH
14949: LD_INT 47
14951: PUSH
14952: LD_INT 82
14954: PUSH
14955: LD_INT 83
14957: PUSH
14958: LD_INT 84
14960: PUSH
14961: LD_INT 85
14963: PUSH
14964: LD_INT 86
14966: PUSH
14967: LD_INT 1
14969: PUSH
14970: LD_INT 2
14972: PUSH
14973: LD_INT 6
14975: PUSH
14976: LD_INT 15
14978: PUSH
14979: LD_INT 16
14981: PUSH
14982: LD_INT 7
14984: PUSH
14985: LD_INT 12
14987: PUSH
14988: LD_INT 13
14990: PUSH
14991: LD_INT 10
14993: PUSH
14994: LD_INT 14
14996: PUSH
14997: LD_INT 20
14999: PUSH
15000: LD_INT 21
15002: PUSH
15003: LD_INT 22
15005: PUSH
15006: LD_INT 25
15008: PUSH
15009: LD_INT 32
15011: PUSH
15012: LD_INT 27
15014: PUSH
15015: LD_INT 36
15017: PUSH
15018: LD_INT 69
15020: PUSH
15021: LD_INT 39
15023: PUSH
15024: LD_INT 34
15026: PUSH
15027: LD_INT 40
15029: PUSH
15030: LD_INT 48
15032: PUSH
15033: LD_INT 49
15035: PUSH
15036: LD_INT 50
15038: PUSH
15039: LD_INT 51
15041: PUSH
15042: LD_INT 52
15044: PUSH
15045: LD_INT 53
15047: PUSH
15048: LD_INT 54
15050: PUSH
15051: LD_INT 55
15053: PUSH
15054: LD_INT 56
15056: PUSH
15057: LD_INT 57
15059: PUSH
15060: LD_INT 58
15062: PUSH
15063: LD_INT 59
15065: PUSH
15066: LD_INT 60
15068: PUSH
15069: LD_INT 61
15071: PUSH
15072: LD_INT 62
15074: PUSH
15075: LD_INT 80
15077: PUSH
15078: LD_INT 82
15080: PUSH
15081: LD_INT 83
15083: PUSH
15084: LD_INT 84
15086: PUSH
15087: LD_INT 85
15089: PUSH
15090: LD_INT 86
15092: PUSH
15093: EMPTY
15094: LIST
15095: LIST
15096: LIST
15097: LIST
15098: LIST
15099: LIST
15100: LIST
15101: LIST
15102: LIST
15103: LIST
15104: LIST
15105: LIST
15106: LIST
15107: LIST
15108: LIST
15109: LIST
15110: LIST
15111: LIST
15112: LIST
15113: LIST
15114: LIST
15115: LIST
15116: LIST
15117: LIST
15118: LIST
15119: LIST
15120: LIST
15121: LIST
15122: LIST
15123: LIST
15124: LIST
15125: LIST
15126: LIST
15127: LIST
15128: LIST
15129: LIST
15130: LIST
15131: LIST
15132: LIST
15133: LIST
15134: LIST
15135: LIST
15136: LIST
15137: LIST
15138: LIST
15139: LIST
15140: LIST
15141: LIST
15142: LIST
15143: LIST
15144: LIST
15145: ST_TO_ADDR
15146: GO 15613
15148: LD_INT 2
15150: DOUBLE
15151: EQUAL
15152: IFTRUE 15156
15154: GO 15382
15156: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15157: LD_ADDR_VAR 0 4
15161: PUSH
15162: LD_INT 35
15164: PUSH
15165: LD_INT 45
15167: PUSH
15168: LD_INT 46
15170: PUSH
15171: LD_INT 47
15173: PUSH
15174: LD_INT 82
15176: PUSH
15177: LD_INT 83
15179: PUSH
15180: LD_INT 84
15182: PUSH
15183: LD_INT 85
15185: PUSH
15186: LD_INT 87
15188: PUSH
15189: LD_INT 70
15191: PUSH
15192: LD_INT 1
15194: PUSH
15195: LD_INT 11
15197: PUSH
15198: LD_INT 3
15200: PUSH
15201: LD_INT 4
15203: PUSH
15204: LD_INT 5
15206: PUSH
15207: LD_INT 6
15209: PUSH
15210: LD_INT 15
15212: PUSH
15213: LD_INT 18
15215: PUSH
15216: LD_INT 7
15218: PUSH
15219: LD_INT 17
15221: PUSH
15222: LD_INT 8
15224: PUSH
15225: LD_INT 20
15227: PUSH
15228: LD_INT 21
15230: PUSH
15231: LD_INT 22
15233: PUSH
15234: LD_INT 72
15236: PUSH
15237: LD_INT 26
15239: PUSH
15240: LD_INT 69
15242: PUSH
15243: LD_INT 39
15245: PUSH
15246: LD_INT 40
15248: PUSH
15249: LD_INT 41
15251: PUSH
15252: LD_INT 42
15254: PUSH
15255: LD_INT 43
15257: PUSH
15258: LD_INT 48
15260: PUSH
15261: LD_INT 49
15263: PUSH
15264: LD_INT 50
15266: PUSH
15267: LD_INT 51
15269: PUSH
15270: LD_INT 52
15272: PUSH
15273: LD_INT 53
15275: PUSH
15276: LD_INT 54
15278: PUSH
15279: LD_INT 55
15281: PUSH
15282: LD_INT 56
15284: PUSH
15285: LD_INT 60
15287: PUSH
15288: LD_INT 61
15290: PUSH
15291: LD_INT 62
15293: PUSH
15294: LD_INT 66
15296: PUSH
15297: LD_INT 67
15299: PUSH
15300: LD_INT 68
15302: PUSH
15303: LD_INT 81
15305: PUSH
15306: LD_INT 82
15308: PUSH
15309: LD_INT 83
15311: PUSH
15312: LD_INT 84
15314: PUSH
15315: LD_INT 85
15317: PUSH
15318: LD_INT 87
15320: PUSH
15321: LD_INT 88
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: LIST
15328: LIST
15329: LIST
15330: LIST
15331: LIST
15332: LIST
15333: LIST
15334: LIST
15335: LIST
15336: LIST
15337: LIST
15338: LIST
15339: LIST
15340: LIST
15341: LIST
15342: LIST
15343: LIST
15344: LIST
15345: LIST
15346: LIST
15347: LIST
15348: LIST
15349: LIST
15350: LIST
15351: LIST
15352: LIST
15353: LIST
15354: LIST
15355: LIST
15356: LIST
15357: LIST
15358: LIST
15359: LIST
15360: LIST
15361: LIST
15362: LIST
15363: LIST
15364: LIST
15365: LIST
15366: LIST
15367: LIST
15368: LIST
15369: LIST
15370: LIST
15371: LIST
15372: LIST
15373: LIST
15374: LIST
15375: LIST
15376: LIST
15377: LIST
15378: LIST
15379: ST_TO_ADDR
15380: GO 15613
15382: LD_INT 3
15384: DOUBLE
15385: EQUAL
15386: IFTRUE 15390
15388: GO 15612
15390: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15391: LD_ADDR_VAR 0 4
15395: PUSH
15396: LD_INT 46
15398: PUSH
15399: LD_INT 47
15401: PUSH
15402: LD_INT 1
15404: PUSH
15405: LD_INT 2
15407: PUSH
15408: LD_INT 82
15410: PUSH
15411: LD_INT 83
15413: PUSH
15414: LD_INT 84
15416: PUSH
15417: LD_INT 85
15419: PUSH
15420: LD_INT 86
15422: PUSH
15423: LD_INT 11
15425: PUSH
15426: LD_INT 9
15428: PUSH
15429: LD_INT 20
15431: PUSH
15432: LD_INT 19
15434: PUSH
15435: LD_INT 21
15437: PUSH
15438: LD_INT 24
15440: PUSH
15441: LD_INT 22
15443: PUSH
15444: LD_INT 25
15446: PUSH
15447: LD_INT 28
15449: PUSH
15450: LD_INT 29
15452: PUSH
15453: LD_INT 30
15455: PUSH
15456: LD_INT 31
15458: PUSH
15459: LD_INT 37
15461: PUSH
15462: LD_INT 38
15464: PUSH
15465: LD_INT 32
15467: PUSH
15468: LD_INT 27
15470: PUSH
15471: LD_INT 33
15473: PUSH
15474: LD_INT 69
15476: PUSH
15477: LD_INT 39
15479: PUSH
15480: LD_INT 34
15482: PUSH
15483: LD_INT 40
15485: PUSH
15486: LD_INT 71
15488: PUSH
15489: LD_INT 23
15491: PUSH
15492: LD_INT 44
15494: PUSH
15495: LD_INT 48
15497: PUSH
15498: LD_INT 49
15500: PUSH
15501: LD_INT 50
15503: PUSH
15504: LD_INT 51
15506: PUSH
15507: LD_INT 52
15509: PUSH
15510: LD_INT 53
15512: PUSH
15513: LD_INT 54
15515: PUSH
15516: LD_INT 55
15518: PUSH
15519: LD_INT 56
15521: PUSH
15522: LD_INT 57
15524: PUSH
15525: LD_INT 58
15527: PUSH
15528: LD_INT 59
15530: PUSH
15531: LD_INT 63
15533: PUSH
15534: LD_INT 64
15536: PUSH
15537: LD_INT 65
15539: PUSH
15540: LD_INT 82
15542: PUSH
15543: LD_INT 83
15545: PUSH
15546: LD_INT 84
15548: PUSH
15549: LD_INT 85
15551: PUSH
15552: LD_INT 86
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: LIST
15559: LIST
15560: LIST
15561: LIST
15562: LIST
15563: LIST
15564: LIST
15565: LIST
15566: LIST
15567: LIST
15568: LIST
15569: LIST
15570: LIST
15571: LIST
15572: LIST
15573: LIST
15574: LIST
15575: LIST
15576: LIST
15577: LIST
15578: LIST
15579: LIST
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: LIST
15585: LIST
15586: LIST
15587: LIST
15588: LIST
15589: LIST
15590: LIST
15591: LIST
15592: LIST
15593: LIST
15594: LIST
15595: LIST
15596: LIST
15597: LIST
15598: LIST
15599: LIST
15600: LIST
15601: LIST
15602: LIST
15603: LIST
15604: LIST
15605: LIST
15606: LIST
15607: LIST
15608: LIST
15609: ST_TO_ADDR
15610: GO 15613
15612: POP
// if state > - 1 and state < 3 then
15613: LD_VAR 0 3
15617: PUSH
15618: LD_INT 1
15620: NEG
15621: GREATER
15622: PUSH
15623: LD_VAR 0 3
15627: PUSH
15628: LD_INT 3
15630: LESS
15631: AND
15632: IFFALSE 15689
// for i in result do
15634: LD_ADDR_VAR 0 5
15638: PUSH
15639: LD_VAR 0 4
15643: PUSH
15644: FOR_IN
15645: IFFALSE 15687
// if GetTech ( i , side ) <> state then
15647: LD_VAR 0 5
15651: PPUSH
15652: LD_VAR 0 1
15656: PPUSH
15657: CALL_OW 321
15661: PUSH
15662: LD_VAR 0 3
15666: NONEQUAL
15667: IFFALSE 15685
// result := result diff i ;
15669: LD_ADDR_VAR 0 4
15673: PUSH
15674: LD_VAR 0 4
15678: PUSH
15679: LD_VAR 0 5
15683: DIFF
15684: ST_TO_ADDR
15685: GO 15644
15687: POP
15688: POP
// end ;
15689: LD_VAR 0 4
15693: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15694: LD_INT 0
15696: PPUSH
15697: PPUSH
15698: PPUSH
// result := true ;
15699: LD_ADDR_VAR 0 3
15703: PUSH
15704: LD_INT 1
15706: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15707: LD_ADDR_VAR 0 5
15711: PUSH
15712: LD_VAR 0 2
15716: PPUSH
15717: CALL_OW 480
15721: ST_TO_ADDR
// if not tmp then
15722: LD_VAR 0 5
15726: NOT
15727: IFFALSE 15731
// exit ;
15729: GO 15780
// for i in tmp do
15731: LD_ADDR_VAR 0 4
15735: PUSH
15736: LD_VAR 0 5
15740: PUSH
15741: FOR_IN
15742: IFFALSE 15778
// if GetTech ( i , side ) <> state_researched then
15744: LD_VAR 0 4
15748: PPUSH
15749: LD_VAR 0 1
15753: PPUSH
15754: CALL_OW 321
15758: PUSH
15759: LD_INT 2
15761: NONEQUAL
15762: IFFALSE 15776
// begin result := false ;
15764: LD_ADDR_VAR 0 3
15768: PUSH
15769: LD_INT 0
15771: ST_TO_ADDR
// exit ;
15772: POP
15773: POP
15774: GO 15780
// end ;
15776: GO 15741
15778: POP
15779: POP
// end ;
15780: LD_VAR 0 3
15784: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15785: LD_INT 0
15787: PPUSH
15788: PPUSH
15789: PPUSH
15790: PPUSH
15791: PPUSH
15792: PPUSH
15793: PPUSH
15794: PPUSH
15795: PPUSH
15796: PPUSH
15797: PPUSH
15798: PPUSH
15799: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15800: LD_VAR 0 1
15804: NOT
15805: PUSH
15806: LD_VAR 0 1
15810: PPUSH
15811: CALL_OW 257
15815: PUSH
15816: LD_INT 9
15818: NONEQUAL
15819: OR
15820: IFFALSE 15824
// exit ;
15822: GO 16397
// side := GetSide ( unit ) ;
15824: LD_ADDR_VAR 0 9
15828: PUSH
15829: LD_VAR 0 1
15833: PPUSH
15834: CALL_OW 255
15838: ST_TO_ADDR
// tech_space := tech_spacanom ;
15839: LD_ADDR_VAR 0 12
15843: PUSH
15844: LD_INT 29
15846: ST_TO_ADDR
// tech_time := tech_taurad ;
15847: LD_ADDR_VAR 0 13
15851: PUSH
15852: LD_INT 28
15854: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15855: LD_ADDR_VAR 0 11
15859: PUSH
15860: LD_VAR 0 1
15864: PPUSH
15865: CALL_OW 310
15869: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15870: LD_VAR 0 11
15874: PPUSH
15875: CALL_OW 247
15879: PUSH
15880: LD_INT 2
15882: EQUAL
15883: IFFALSE 15887
// exit ;
15885: GO 16397
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15887: LD_ADDR_VAR 0 8
15891: PUSH
15892: LD_INT 81
15894: PUSH
15895: LD_VAR 0 9
15899: PUSH
15900: EMPTY
15901: LIST
15902: LIST
15903: PUSH
15904: LD_INT 3
15906: PUSH
15907: LD_INT 21
15909: PUSH
15910: LD_INT 3
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: PUSH
15921: EMPTY
15922: LIST
15923: LIST
15924: PPUSH
15925: CALL_OW 69
15929: ST_TO_ADDR
// if not tmp then
15930: LD_VAR 0 8
15934: NOT
15935: IFFALSE 15939
// exit ;
15937: GO 16397
// if in_unit then
15939: LD_VAR 0 11
15943: IFFALSE 15967
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15945: LD_ADDR_VAR 0 10
15949: PUSH
15950: LD_VAR 0 8
15954: PPUSH
15955: LD_VAR 0 11
15959: PPUSH
15960: CALL_OW 74
15964: ST_TO_ADDR
15965: GO 15987
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15967: LD_ADDR_VAR 0 10
15971: PUSH
15972: LD_VAR 0 8
15976: PPUSH
15977: LD_VAR 0 1
15981: PPUSH
15982: CALL_OW 74
15986: ST_TO_ADDR
// if not enemy then
15987: LD_VAR 0 10
15991: NOT
15992: IFFALSE 15996
// exit ;
15994: GO 16397
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15996: LD_VAR 0 11
16000: PUSH
16001: LD_VAR 0 11
16005: PPUSH
16006: LD_VAR 0 10
16010: PPUSH
16011: CALL_OW 296
16015: PUSH
16016: LD_INT 13
16018: GREATER
16019: AND
16020: PUSH
16021: LD_VAR 0 1
16025: PPUSH
16026: LD_VAR 0 10
16030: PPUSH
16031: CALL_OW 296
16035: PUSH
16036: LD_INT 12
16038: GREATER
16039: OR
16040: IFFALSE 16044
// exit ;
16042: GO 16397
// missile := [ 1 ] ;
16044: LD_ADDR_VAR 0 14
16048: PUSH
16049: LD_INT 1
16051: PUSH
16052: EMPTY
16053: LIST
16054: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16055: LD_VAR 0 9
16059: PPUSH
16060: LD_VAR 0 12
16064: PPUSH
16065: CALL_OW 325
16069: IFFALSE 16098
// missile := Replace ( missile , missile + 1 , 2 ) ;
16071: LD_ADDR_VAR 0 14
16075: PUSH
16076: LD_VAR 0 14
16080: PPUSH
16081: LD_VAR 0 14
16085: PUSH
16086: LD_INT 1
16088: PLUS
16089: PPUSH
16090: LD_INT 2
16092: PPUSH
16093: CALL_OW 1
16097: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16098: LD_VAR 0 9
16102: PPUSH
16103: LD_VAR 0 13
16107: PPUSH
16108: CALL_OW 325
16112: PUSH
16113: LD_VAR 0 10
16117: PPUSH
16118: CALL_OW 255
16122: PPUSH
16123: LD_VAR 0 13
16127: PPUSH
16128: CALL_OW 325
16132: NOT
16133: AND
16134: IFFALSE 16163
// missile := Replace ( missile , missile + 1 , 3 ) ;
16136: LD_ADDR_VAR 0 14
16140: PUSH
16141: LD_VAR 0 14
16145: PPUSH
16146: LD_VAR 0 14
16150: PUSH
16151: LD_INT 1
16153: PLUS
16154: PPUSH
16155: LD_INT 3
16157: PPUSH
16158: CALL_OW 1
16162: ST_TO_ADDR
// if missile < 2 then
16163: LD_VAR 0 14
16167: PUSH
16168: LD_INT 2
16170: LESS
16171: IFFALSE 16175
// exit ;
16173: GO 16397
// x := GetX ( enemy ) ;
16175: LD_ADDR_VAR 0 4
16179: PUSH
16180: LD_VAR 0 10
16184: PPUSH
16185: CALL_OW 250
16189: ST_TO_ADDR
// y := GetY ( enemy ) ;
16190: LD_ADDR_VAR 0 5
16194: PUSH
16195: LD_VAR 0 10
16199: PPUSH
16200: CALL_OW 251
16204: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16205: LD_ADDR_VAR 0 6
16209: PUSH
16210: LD_VAR 0 4
16214: PUSH
16215: LD_INT 1
16217: NEG
16218: PPUSH
16219: LD_INT 1
16221: PPUSH
16222: CALL_OW 12
16226: PLUS
16227: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16228: LD_ADDR_VAR 0 7
16232: PUSH
16233: LD_VAR 0 5
16237: PUSH
16238: LD_INT 1
16240: NEG
16241: PPUSH
16242: LD_INT 1
16244: PPUSH
16245: CALL_OW 12
16249: PLUS
16250: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16251: LD_VAR 0 6
16255: PPUSH
16256: LD_VAR 0 7
16260: PPUSH
16261: CALL_OW 488
16265: NOT
16266: IFFALSE 16288
// begin _x := x ;
16268: LD_ADDR_VAR 0 6
16272: PUSH
16273: LD_VAR 0 4
16277: ST_TO_ADDR
// _y := y ;
16278: LD_ADDR_VAR 0 7
16282: PUSH
16283: LD_VAR 0 5
16287: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16288: LD_ADDR_VAR 0 3
16292: PUSH
16293: LD_INT 1
16295: PPUSH
16296: LD_VAR 0 14
16300: PPUSH
16301: CALL_OW 12
16305: ST_TO_ADDR
// case i of 1 :
16306: LD_VAR 0 3
16310: PUSH
16311: LD_INT 1
16313: DOUBLE
16314: EQUAL
16315: IFTRUE 16319
16317: GO 16336
16319: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16320: LD_VAR 0 1
16324: PPUSH
16325: LD_VAR 0 10
16329: PPUSH
16330: CALL_OW 115
16334: GO 16397
16336: LD_INT 2
16338: DOUBLE
16339: EQUAL
16340: IFTRUE 16344
16342: GO 16366
16344: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16345: LD_VAR 0 1
16349: PPUSH
16350: LD_VAR 0 6
16354: PPUSH
16355: LD_VAR 0 7
16359: PPUSH
16360: CALL_OW 153
16364: GO 16397
16366: LD_INT 3
16368: DOUBLE
16369: EQUAL
16370: IFTRUE 16374
16372: GO 16396
16374: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16375: LD_VAR 0 1
16379: PPUSH
16380: LD_VAR 0 6
16384: PPUSH
16385: LD_VAR 0 7
16389: PPUSH
16390: CALL_OW 154
16394: GO 16397
16396: POP
// end ;
16397: LD_VAR 0 2
16401: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16402: LD_INT 0
16404: PPUSH
16405: PPUSH
16406: PPUSH
16407: PPUSH
16408: PPUSH
16409: PPUSH
// if not unit or not building then
16410: LD_VAR 0 1
16414: NOT
16415: PUSH
16416: LD_VAR 0 2
16420: NOT
16421: OR
16422: IFFALSE 16426
// exit ;
16424: GO 16584
// x := GetX ( building ) ;
16426: LD_ADDR_VAR 0 5
16430: PUSH
16431: LD_VAR 0 2
16435: PPUSH
16436: CALL_OW 250
16440: ST_TO_ADDR
// y := GetY ( building ) ;
16441: LD_ADDR_VAR 0 6
16445: PUSH
16446: LD_VAR 0 2
16450: PPUSH
16451: CALL_OW 251
16455: ST_TO_ADDR
// for i = 0 to 5 do
16456: LD_ADDR_VAR 0 4
16460: PUSH
16461: DOUBLE
16462: LD_INT 0
16464: DEC
16465: ST_TO_ADDR
16466: LD_INT 5
16468: PUSH
16469: FOR_TO
16470: IFFALSE 16582
// begin _x := ShiftX ( x , i , 3 ) ;
16472: LD_ADDR_VAR 0 7
16476: PUSH
16477: LD_VAR 0 5
16481: PPUSH
16482: LD_VAR 0 4
16486: PPUSH
16487: LD_INT 3
16489: PPUSH
16490: CALL_OW 272
16494: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16495: LD_ADDR_VAR 0 8
16499: PUSH
16500: LD_VAR 0 6
16504: PPUSH
16505: LD_VAR 0 4
16509: PPUSH
16510: LD_INT 3
16512: PPUSH
16513: CALL_OW 273
16517: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16518: LD_VAR 0 7
16522: PPUSH
16523: LD_VAR 0 8
16527: PPUSH
16528: CALL_OW 488
16532: NOT
16533: IFFALSE 16537
// continue ;
16535: GO 16469
// if HexInfo ( _x , _y ) = 0 then
16537: LD_VAR 0 7
16541: PPUSH
16542: LD_VAR 0 8
16546: PPUSH
16547: CALL_OW 428
16551: PUSH
16552: LD_INT 0
16554: EQUAL
16555: IFFALSE 16580
// begin ComMoveXY ( unit , _x , _y ) ;
16557: LD_VAR 0 1
16561: PPUSH
16562: LD_VAR 0 7
16566: PPUSH
16567: LD_VAR 0 8
16571: PPUSH
16572: CALL_OW 111
// exit ;
16576: POP
16577: POP
16578: GO 16584
// end ; end ;
16580: GO 16469
16582: POP
16583: POP
// end ;
16584: LD_VAR 0 3
16588: RET
// export function ScanBase ( side , base_area ) ; begin
16589: LD_INT 0
16591: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16592: LD_ADDR_VAR 0 3
16596: PUSH
16597: LD_VAR 0 2
16601: PPUSH
16602: LD_INT 81
16604: PUSH
16605: LD_VAR 0 1
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: PPUSH
16614: CALL_OW 70
16618: ST_TO_ADDR
// end ;
16619: LD_VAR 0 3
16623: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16624: LD_INT 0
16626: PPUSH
16627: PPUSH
16628: PPUSH
16629: PPUSH
// result := false ;
16630: LD_ADDR_VAR 0 2
16634: PUSH
16635: LD_INT 0
16637: ST_TO_ADDR
// side := GetSide ( unit ) ;
16638: LD_ADDR_VAR 0 3
16642: PUSH
16643: LD_VAR 0 1
16647: PPUSH
16648: CALL_OW 255
16652: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16653: LD_ADDR_VAR 0 4
16657: PUSH
16658: LD_VAR 0 1
16662: PPUSH
16663: CALL_OW 248
16667: ST_TO_ADDR
// case nat of 1 :
16668: LD_VAR 0 4
16672: PUSH
16673: LD_INT 1
16675: DOUBLE
16676: EQUAL
16677: IFTRUE 16681
16679: GO 16692
16681: POP
// tech := tech_lassight ; 2 :
16682: LD_ADDR_VAR 0 5
16686: PUSH
16687: LD_INT 12
16689: ST_TO_ADDR
16690: GO 16731
16692: LD_INT 2
16694: DOUBLE
16695: EQUAL
16696: IFTRUE 16700
16698: GO 16711
16700: POP
// tech := tech_mortar ; 3 :
16701: LD_ADDR_VAR 0 5
16705: PUSH
16706: LD_INT 41
16708: ST_TO_ADDR
16709: GO 16731
16711: LD_INT 3
16713: DOUBLE
16714: EQUAL
16715: IFTRUE 16719
16717: GO 16730
16719: POP
// tech := tech_bazooka ; end ;
16720: LD_ADDR_VAR 0 5
16724: PUSH
16725: LD_INT 44
16727: ST_TO_ADDR
16728: GO 16731
16730: POP
// if Researched ( side , tech ) then
16731: LD_VAR 0 3
16735: PPUSH
16736: LD_VAR 0 5
16740: PPUSH
16741: CALL_OW 325
16745: IFFALSE 16772
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16747: LD_ADDR_VAR 0 2
16751: PUSH
16752: LD_INT 5
16754: PUSH
16755: LD_INT 8
16757: PUSH
16758: LD_INT 9
16760: PUSH
16761: EMPTY
16762: LIST
16763: LIST
16764: LIST
16765: PUSH
16766: LD_VAR 0 4
16770: ARRAY
16771: ST_TO_ADDR
// end ;
16772: LD_VAR 0 2
16776: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16777: LD_INT 0
16779: PPUSH
16780: PPUSH
16781: PPUSH
// if not mines then
16782: LD_VAR 0 2
16786: NOT
16787: IFFALSE 16791
// exit ;
16789: GO 16935
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16791: LD_ADDR_VAR 0 5
16795: PUSH
16796: LD_INT 81
16798: PUSH
16799: LD_VAR 0 1
16803: PUSH
16804: EMPTY
16805: LIST
16806: LIST
16807: PUSH
16808: LD_INT 3
16810: PUSH
16811: LD_INT 21
16813: PUSH
16814: LD_INT 3
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: PUSH
16821: EMPTY
16822: LIST
16823: LIST
16824: PUSH
16825: EMPTY
16826: LIST
16827: LIST
16828: PPUSH
16829: CALL_OW 69
16833: ST_TO_ADDR
// for i in mines do
16834: LD_ADDR_VAR 0 4
16838: PUSH
16839: LD_VAR 0 2
16843: PUSH
16844: FOR_IN
16845: IFFALSE 16933
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16847: LD_VAR 0 4
16851: PUSH
16852: LD_INT 1
16854: ARRAY
16855: PPUSH
16856: LD_VAR 0 4
16860: PUSH
16861: LD_INT 2
16863: ARRAY
16864: PPUSH
16865: CALL_OW 458
16869: NOT
16870: IFFALSE 16874
// continue ;
16872: GO 16844
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16874: LD_VAR 0 4
16878: PUSH
16879: LD_INT 1
16881: ARRAY
16882: PPUSH
16883: LD_VAR 0 4
16887: PUSH
16888: LD_INT 2
16890: ARRAY
16891: PPUSH
16892: CALL_OW 428
16896: PUSH
16897: LD_VAR 0 5
16901: IN
16902: IFFALSE 16931
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16904: LD_VAR 0 4
16908: PUSH
16909: LD_INT 1
16911: ARRAY
16912: PPUSH
16913: LD_VAR 0 4
16917: PUSH
16918: LD_INT 2
16920: ARRAY
16921: PPUSH
16922: LD_VAR 0 1
16926: PPUSH
16927: CALL_OW 456
// end ;
16931: GO 16844
16933: POP
16934: POP
// end ;
16935: LD_VAR 0 3
16939: RET
// export function Count ( array ) ; var i ; begin
16940: LD_INT 0
16942: PPUSH
16943: PPUSH
// result := 0 ;
16944: LD_ADDR_VAR 0 2
16948: PUSH
16949: LD_INT 0
16951: ST_TO_ADDR
// for i in array do
16952: LD_ADDR_VAR 0 3
16956: PUSH
16957: LD_VAR 0 1
16961: PUSH
16962: FOR_IN
16963: IFFALSE 16987
// if i then
16965: LD_VAR 0 3
16969: IFFALSE 16985
// result := result + 1 ;
16971: LD_ADDR_VAR 0 2
16975: PUSH
16976: LD_VAR 0 2
16980: PUSH
16981: LD_INT 1
16983: PLUS
16984: ST_TO_ADDR
16985: GO 16962
16987: POP
16988: POP
// end ;
16989: LD_VAR 0 2
16993: RET
// export function IsEmpty ( building ) ; begin
16994: LD_INT 0
16996: PPUSH
// if not building then
16997: LD_VAR 0 1
17001: NOT
17002: IFFALSE 17006
// exit ;
17004: GO 17049
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17006: LD_ADDR_VAR 0 2
17010: PUSH
17011: LD_VAR 0 1
17015: PUSH
17016: LD_INT 22
17018: PUSH
17019: LD_VAR 0 1
17023: PPUSH
17024: CALL_OW 255
17028: PUSH
17029: EMPTY
17030: LIST
17031: LIST
17032: PUSH
17033: LD_INT 58
17035: PUSH
17036: EMPTY
17037: LIST
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: PPUSH
17043: CALL_OW 69
17047: IN
17048: ST_TO_ADDR
// end ;
17049: LD_VAR 0 2
17053: RET
// export function IsNotFull ( building ) ; begin
17054: LD_INT 0
17056: PPUSH
// if not building then
17057: LD_VAR 0 1
17061: NOT
17062: IFFALSE 17066
// exit ;
17064: GO 17085
// result := UnitsInside ( building ) < 6 ;
17066: LD_ADDR_VAR 0 2
17070: PUSH
17071: LD_VAR 0 1
17075: PPUSH
17076: CALL_OW 313
17080: PUSH
17081: LD_INT 6
17083: LESS
17084: ST_TO_ADDR
// end ;
17085: LD_VAR 0 2
17089: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17090: LD_INT 0
17092: PPUSH
17093: PPUSH
17094: PPUSH
17095: PPUSH
// tmp := [ ] ;
17096: LD_ADDR_VAR 0 3
17100: PUSH
17101: EMPTY
17102: ST_TO_ADDR
// list := [ ] ;
17103: LD_ADDR_VAR 0 5
17107: PUSH
17108: EMPTY
17109: ST_TO_ADDR
// for i = 16 to 25 do
17110: LD_ADDR_VAR 0 4
17114: PUSH
17115: DOUBLE
17116: LD_INT 16
17118: DEC
17119: ST_TO_ADDR
17120: LD_INT 25
17122: PUSH
17123: FOR_TO
17124: IFFALSE 17197
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17126: LD_ADDR_VAR 0 3
17130: PUSH
17131: LD_VAR 0 3
17135: PUSH
17136: LD_INT 22
17138: PUSH
17139: LD_VAR 0 1
17143: PPUSH
17144: CALL_OW 255
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PUSH
17153: LD_INT 91
17155: PUSH
17156: LD_VAR 0 1
17160: PUSH
17161: LD_INT 6
17163: PUSH
17164: EMPTY
17165: LIST
17166: LIST
17167: LIST
17168: PUSH
17169: LD_INT 30
17171: PUSH
17172: LD_VAR 0 4
17176: PUSH
17177: EMPTY
17178: LIST
17179: LIST
17180: PUSH
17181: EMPTY
17182: LIST
17183: LIST
17184: LIST
17185: PUSH
17186: EMPTY
17187: LIST
17188: PPUSH
17189: CALL_OW 69
17193: ADD
17194: ST_TO_ADDR
17195: GO 17123
17197: POP
17198: POP
// for i = 1 to tmp do
17199: LD_ADDR_VAR 0 4
17203: PUSH
17204: DOUBLE
17205: LD_INT 1
17207: DEC
17208: ST_TO_ADDR
17209: LD_VAR 0 3
17213: PUSH
17214: FOR_TO
17215: IFFALSE 17303
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17217: LD_ADDR_VAR 0 5
17221: PUSH
17222: LD_VAR 0 5
17226: PUSH
17227: LD_VAR 0 3
17231: PUSH
17232: LD_VAR 0 4
17236: ARRAY
17237: PPUSH
17238: CALL_OW 266
17242: PUSH
17243: LD_VAR 0 3
17247: PUSH
17248: LD_VAR 0 4
17252: ARRAY
17253: PPUSH
17254: CALL_OW 250
17258: PUSH
17259: LD_VAR 0 3
17263: PUSH
17264: LD_VAR 0 4
17268: ARRAY
17269: PPUSH
17270: CALL_OW 251
17274: PUSH
17275: LD_VAR 0 3
17279: PUSH
17280: LD_VAR 0 4
17284: ARRAY
17285: PPUSH
17286: CALL_OW 254
17290: PUSH
17291: EMPTY
17292: LIST
17293: LIST
17294: LIST
17295: LIST
17296: PUSH
17297: EMPTY
17298: LIST
17299: ADD
17300: ST_TO_ADDR
17301: GO 17214
17303: POP
17304: POP
// result := list ;
17305: LD_ADDR_VAR 0 2
17309: PUSH
17310: LD_VAR 0 5
17314: ST_TO_ADDR
// end ;
17315: LD_VAR 0 2
17319: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17320: LD_INT 0
17322: PPUSH
17323: PPUSH
17324: PPUSH
17325: PPUSH
17326: PPUSH
17327: PPUSH
17328: PPUSH
// if not factory then
17329: LD_VAR 0 1
17333: NOT
17334: IFFALSE 17338
// exit ;
17336: GO 17931
// if control = control_apeman then
17338: LD_VAR 0 4
17342: PUSH
17343: LD_INT 5
17345: EQUAL
17346: IFFALSE 17455
// begin tmp := UnitsInside ( factory ) ;
17348: LD_ADDR_VAR 0 8
17352: PUSH
17353: LD_VAR 0 1
17357: PPUSH
17358: CALL_OW 313
17362: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17363: LD_VAR 0 8
17367: PPUSH
17368: LD_INT 25
17370: PUSH
17371: LD_INT 12
17373: PUSH
17374: EMPTY
17375: LIST
17376: LIST
17377: PPUSH
17378: CALL_OW 72
17382: NOT
17383: IFFALSE 17393
// control := control_manual ;
17385: LD_ADDR_VAR 0 4
17389: PUSH
17390: LD_INT 1
17392: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17393: LD_ADDR_VAR 0 8
17397: PUSH
17398: LD_VAR 0 1
17402: PPUSH
17403: CALL 17090 0 1
17407: ST_TO_ADDR
// if tmp then
17408: LD_VAR 0 8
17412: IFFALSE 17455
// begin for i in tmp do
17414: LD_ADDR_VAR 0 7
17418: PUSH
17419: LD_VAR 0 8
17423: PUSH
17424: FOR_IN
17425: IFFALSE 17453
// if i [ 1 ] = b_ext_radio then
17427: LD_VAR 0 7
17431: PUSH
17432: LD_INT 1
17434: ARRAY
17435: PUSH
17436: LD_INT 22
17438: EQUAL
17439: IFFALSE 17451
// begin control := control_remote ;
17441: LD_ADDR_VAR 0 4
17445: PUSH
17446: LD_INT 2
17448: ST_TO_ADDR
// break ;
17449: GO 17453
// end ;
17451: GO 17424
17453: POP
17454: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17455: LD_VAR 0 1
17459: PPUSH
17460: LD_VAR 0 2
17464: PPUSH
17465: LD_VAR 0 3
17469: PPUSH
17470: LD_VAR 0 4
17474: PPUSH
17475: LD_VAR 0 5
17479: PPUSH
17480: CALL_OW 448
17484: IFFALSE 17519
// begin result := [ chassis , engine , control , weapon ] ;
17486: LD_ADDR_VAR 0 6
17490: PUSH
17491: LD_VAR 0 2
17495: PUSH
17496: LD_VAR 0 3
17500: PUSH
17501: LD_VAR 0 4
17505: PUSH
17506: LD_VAR 0 5
17510: PUSH
17511: EMPTY
17512: LIST
17513: LIST
17514: LIST
17515: LIST
17516: ST_TO_ADDR
// exit ;
17517: GO 17931
// end ; _chassis := AvailableChassisList ( factory ) ;
17519: LD_ADDR_VAR 0 9
17523: PUSH
17524: LD_VAR 0 1
17528: PPUSH
17529: CALL_OW 475
17533: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17534: LD_ADDR_VAR 0 11
17538: PUSH
17539: LD_VAR 0 1
17543: PPUSH
17544: CALL_OW 476
17548: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17549: LD_ADDR_VAR 0 12
17553: PUSH
17554: LD_VAR 0 1
17558: PPUSH
17559: CALL_OW 477
17563: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17564: LD_ADDR_VAR 0 10
17568: PUSH
17569: LD_VAR 0 1
17573: PPUSH
17574: CALL_OW 478
17578: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17579: LD_VAR 0 9
17583: NOT
17584: PUSH
17585: LD_VAR 0 11
17589: NOT
17590: OR
17591: PUSH
17592: LD_VAR 0 12
17596: NOT
17597: OR
17598: PUSH
17599: LD_VAR 0 10
17603: NOT
17604: OR
17605: IFFALSE 17640
// begin result := [ chassis , engine , control , weapon ] ;
17607: LD_ADDR_VAR 0 6
17611: PUSH
17612: LD_VAR 0 2
17616: PUSH
17617: LD_VAR 0 3
17621: PUSH
17622: LD_VAR 0 4
17626: PUSH
17627: LD_VAR 0 5
17631: PUSH
17632: EMPTY
17633: LIST
17634: LIST
17635: LIST
17636: LIST
17637: ST_TO_ADDR
// exit ;
17638: GO 17931
// end ; if not chassis in _chassis then
17640: LD_VAR 0 2
17644: PUSH
17645: LD_VAR 0 9
17649: IN
17650: NOT
17651: IFFALSE 17677
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17653: LD_ADDR_VAR 0 2
17657: PUSH
17658: LD_VAR 0 9
17662: PUSH
17663: LD_INT 1
17665: PPUSH
17666: LD_VAR 0 9
17670: PPUSH
17671: CALL_OW 12
17675: ARRAY
17676: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17677: LD_VAR 0 2
17681: PPUSH
17682: LD_VAR 0 3
17686: PPUSH
17687: CALL 17936 0 2
17691: NOT
17692: IFFALSE 17751
// repeat engine := _engine [ 1 ] ;
17694: LD_ADDR_VAR 0 3
17698: PUSH
17699: LD_VAR 0 11
17703: PUSH
17704: LD_INT 1
17706: ARRAY
17707: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17708: LD_ADDR_VAR 0 11
17712: PUSH
17713: LD_VAR 0 11
17717: PPUSH
17718: LD_INT 1
17720: PPUSH
17721: CALL_OW 3
17725: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17726: LD_VAR 0 2
17730: PPUSH
17731: LD_VAR 0 3
17735: PPUSH
17736: CALL 17936 0 2
17740: PUSH
17741: LD_VAR 0 11
17745: PUSH
17746: EMPTY
17747: EQUAL
17748: OR
17749: IFFALSE 17694
// if not control in _control then
17751: LD_VAR 0 4
17755: PUSH
17756: LD_VAR 0 12
17760: IN
17761: NOT
17762: IFFALSE 17788
// control := _control [ rand ( 1 , _control ) ] ;
17764: LD_ADDR_VAR 0 4
17768: PUSH
17769: LD_VAR 0 12
17773: PUSH
17774: LD_INT 1
17776: PPUSH
17777: LD_VAR 0 12
17781: PPUSH
17782: CALL_OW 12
17786: ARRAY
17787: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17788: LD_VAR 0 2
17792: PPUSH
17793: LD_VAR 0 5
17797: PPUSH
17798: CALL 18156 0 2
17802: NOT
17803: IFFALSE 17862
// repeat weapon := _weapon [ 1 ] ;
17805: LD_ADDR_VAR 0 5
17809: PUSH
17810: LD_VAR 0 10
17814: PUSH
17815: LD_INT 1
17817: ARRAY
17818: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17819: LD_ADDR_VAR 0 10
17823: PUSH
17824: LD_VAR 0 10
17828: PPUSH
17829: LD_INT 1
17831: PPUSH
17832: CALL_OW 3
17836: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17837: LD_VAR 0 2
17841: PPUSH
17842: LD_VAR 0 5
17846: PPUSH
17847: CALL 18156 0 2
17851: PUSH
17852: LD_VAR 0 10
17856: PUSH
17857: EMPTY
17858: EQUAL
17859: OR
17860: IFFALSE 17805
// result := [ ] ;
17862: LD_ADDR_VAR 0 6
17866: PUSH
17867: EMPTY
17868: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17869: LD_VAR 0 1
17873: PPUSH
17874: LD_VAR 0 2
17878: PPUSH
17879: LD_VAR 0 3
17883: PPUSH
17884: LD_VAR 0 4
17888: PPUSH
17889: LD_VAR 0 5
17893: PPUSH
17894: CALL_OW 448
17898: IFFALSE 17931
// result := [ chassis , engine , control , weapon ] ;
17900: LD_ADDR_VAR 0 6
17904: PUSH
17905: LD_VAR 0 2
17909: PUSH
17910: LD_VAR 0 3
17914: PUSH
17915: LD_VAR 0 4
17919: PUSH
17920: LD_VAR 0 5
17924: PUSH
17925: EMPTY
17926: LIST
17927: LIST
17928: LIST
17929: LIST
17930: ST_TO_ADDR
// end ;
17931: LD_VAR 0 6
17935: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17936: LD_INT 0
17938: PPUSH
// if not chassis or not engine then
17939: LD_VAR 0 1
17943: NOT
17944: PUSH
17945: LD_VAR 0 2
17949: NOT
17950: OR
17951: IFFALSE 17955
// exit ;
17953: GO 18151
// case engine of engine_solar :
17955: LD_VAR 0 2
17959: PUSH
17960: LD_INT 2
17962: DOUBLE
17963: EQUAL
17964: IFTRUE 17968
17966: GO 18006
17968: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17969: LD_ADDR_VAR 0 3
17973: PUSH
17974: LD_INT 11
17976: PUSH
17977: LD_INT 12
17979: PUSH
17980: LD_INT 13
17982: PUSH
17983: LD_INT 14
17985: PUSH
17986: LD_INT 1
17988: PUSH
17989: LD_INT 2
17991: PUSH
17992: LD_INT 3
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: LIST
18001: LIST
18002: LIST
18003: ST_TO_ADDR
18004: GO 18135
18006: LD_INT 1
18008: DOUBLE
18009: EQUAL
18010: IFTRUE 18014
18012: GO 18076
18014: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18015: LD_ADDR_VAR 0 3
18019: PUSH
18020: LD_INT 11
18022: PUSH
18023: LD_INT 12
18025: PUSH
18026: LD_INT 13
18028: PUSH
18029: LD_INT 14
18031: PUSH
18032: LD_INT 1
18034: PUSH
18035: LD_INT 2
18037: PUSH
18038: LD_INT 3
18040: PUSH
18041: LD_INT 4
18043: PUSH
18044: LD_INT 5
18046: PUSH
18047: LD_INT 21
18049: PUSH
18050: LD_INT 23
18052: PUSH
18053: LD_INT 22
18055: PUSH
18056: LD_INT 24
18058: PUSH
18059: EMPTY
18060: LIST
18061: LIST
18062: LIST
18063: LIST
18064: LIST
18065: LIST
18066: LIST
18067: LIST
18068: LIST
18069: LIST
18070: LIST
18071: LIST
18072: LIST
18073: ST_TO_ADDR
18074: GO 18135
18076: LD_INT 3
18078: DOUBLE
18079: EQUAL
18080: IFTRUE 18084
18082: GO 18134
18084: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18085: LD_ADDR_VAR 0 3
18089: PUSH
18090: LD_INT 13
18092: PUSH
18093: LD_INT 14
18095: PUSH
18096: LD_INT 2
18098: PUSH
18099: LD_INT 3
18101: PUSH
18102: LD_INT 4
18104: PUSH
18105: LD_INT 5
18107: PUSH
18108: LD_INT 21
18110: PUSH
18111: LD_INT 22
18113: PUSH
18114: LD_INT 23
18116: PUSH
18117: LD_INT 24
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: LIST
18126: LIST
18127: LIST
18128: LIST
18129: LIST
18130: LIST
18131: ST_TO_ADDR
18132: GO 18135
18134: POP
// result := ( chassis in result ) ;
18135: LD_ADDR_VAR 0 3
18139: PUSH
18140: LD_VAR 0 1
18144: PUSH
18145: LD_VAR 0 3
18149: IN
18150: ST_TO_ADDR
// end ;
18151: LD_VAR 0 3
18155: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18156: LD_INT 0
18158: PPUSH
// if not chassis or not weapon then
18159: LD_VAR 0 1
18163: NOT
18164: PUSH
18165: LD_VAR 0 2
18169: NOT
18170: OR
18171: IFFALSE 18175
// exit ;
18173: GO 19237
// case weapon of us_machine_gun :
18175: LD_VAR 0 2
18179: PUSH
18180: LD_INT 2
18182: DOUBLE
18183: EQUAL
18184: IFTRUE 18188
18186: GO 18218
18188: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18189: LD_ADDR_VAR 0 3
18193: PUSH
18194: LD_INT 1
18196: PUSH
18197: LD_INT 2
18199: PUSH
18200: LD_INT 3
18202: PUSH
18203: LD_INT 4
18205: PUSH
18206: LD_INT 5
18208: PUSH
18209: EMPTY
18210: LIST
18211: LIST
18212: LIST
18213: LIST
18214: LIST
18215: ST_TO_ADDR
18216: GO 19221
18218: LD_INT 3
18220: DOUBLE
18221: EQUAL
18222: IFTRUE 18226
18224: GO 18256
18226: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18227: LD_ADDR_VAR 0 3
18231: PUSH
18232: LD_INT 1
18234: PUSH
18235: LD_INT 2
18237: PUSH
18238: LD_INT 3
18240: PUSH
18241: LD_INT 4
18243: PUSH
18244: LD_INT 5
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: ST_TO_ADDR
18254: GO 19221
18256: LD_INT 11
18258: DOUBLE
18259: EQUAL
18260: IFTRUE 18264
18262: GO 18294
18264: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18265: LD_ADDR_VAR 0 3
18269: PUSH
18270: LD_INT 1
18272: PUSH
18273: LD_INT 2
18275: PUSH
18276: LD_INT 3
18278: PUSH
18279: LD_INT 4
18281: PUSH
18282: LD_INT 5
18284: PUSH
18285: EMPTY
18286: LIST
18287: LIST
18288: LIST
18289: LIST
18290: LIST
18291: ST_TO_ADDR
18292: GO 19221
18294: LD_INT 4
18296: DOUBLE
18297: EQUAL
18298: IFTRUE 18302
18300: GO 18328
18302: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18303: LD_ADDR_VAR 0 3
18307: PUSH
18308: LD_INT 2
18310: PUSH
18311: LD_INT 3
18313: PUSH
18314: LD_INT 4
18316: PUSH
18317: LD_INT 5
18319: PUSH
18320: EMPTY
18321: LIST
18322: LIST
18323: LIST
18324: LIST
18325: ST_TO_ADDR
18326: GO 19221
18328: LD_INT 5
18330: DOUBLE
18331: EQUAL
18332: IFTRUE 18336
18334: GO 18362
18336: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18337: LD_ADDR_VAR 0 3
18341: PUSH
18342: LD_INT 2
18344: PUSH
18345: LD_INT 3
18347: PUSH
18348: LD_INT 4
18350: PUSH
18351: LD_INT 5
18353: PUSH
18354: EMPTY
18355: LIST
18356: LIST
18357: LIST
18358: LIST
18359: ST_TO_ADDR
18360: GO 19221
18362: LD_INT 9
18364: DOUBLE
18365: EQUAL
18366: IFTRUE 18370
18368: GO 18396
18370: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18371: LD_ADDR_VAR 0 3
18375: PUSH
18376: LD_INT 2
18378: PUSH
18379: LD_INT 3
18381: PUSH
18382: LD_INT 4
18384: PUSH
18385: LD_INT 5
18387: PUSH
18388: EMPTY
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: ST_TO_ADDR
18394: GO 19221
18396: LD_INT 7
18398: DOUBLE
18399: EQUAL
18400: IFTRUE 18404
18402: GO 18430
18404: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18405: LD_ADDR_VAR 0 3
18409: PUSH
18410: LD_INT 2
18412: PUSH
18413: LD_INT 3
18415: PUSH
18416: LD_INT 4
18418: PUSH
18419: LD_INT 5
18421: PUSH
18422: EMPTY
18423: LIST
18424: LIST
18425: LIST
18426: LIST
18427: ST_TO_ADDR
18428: GO 19221
18430: LD_INT 12
18432: DOUBLE
18433: EQUAL
18434: IFTRUE 18438
18436: GO 18464
18438: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18439: LD_ADDR_VAR 0 3
18443: PUSH
18444: LD_INT 2
18446: PUSH
18447: LD_INT 3
18449: PUSH
18450: LD_INT 4
18452: PUSH
18453: LD_INT 5
18455: PUSH
18456: EMPTY
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: ST_TO_ADDR
18462: GO 19221
18464: LD_INT 13
18466: DOUBLE
18467: EQUAL
18468: IFTRUE 18472
18470: GO 18498
18472: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18473: LD_ADDR_VAR 0 3
18477: PUSH
18478: LD_INT 2
18480: PUSH
18481: LD_INT 3
18483: PUSH
18484: LD_INT 4
18486: PUSH
18487: LD_INT 5
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: LIST
18494: LIST
18495: ST_TO_ADDR
18496: GO 19221
18498: LD_INT 14
18500: DOUBLE
18501: EQUAL
18502: IFTRUE 18506
18504: GO 18524
18506: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18507: LD_ADDR_VAR 0 3
18511: PUSH
18512: LD_INT 4
18514: PUSH
18515: LD_INT 5
18517: PUSH
18518: EMPTY
18519: LIST
18520: LIST
18521: ST_TO_ADDR
18522: GO 19221
18524: LD_INT 6
18526: DOUBLE
18527: EQUAL
18528: IFTRUE 18532
18530: GO 18550
18532: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18533: LD_ADDR_VAR 0 3
18537: PUSH
18538: LD_INT 4
18540: PUSH
18541: LD_INT 5
18543: PUSH
18544: EMPTY
18545: LIST
18546: LIST
18547: ST_TO_ADDR
18548: GO 19221
18550: LD_INT 10
18552: DOUBLE
18553: EQUAL
18554: IFTRUE 18558
18556: GO 18576
18558: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18559: LD_ADDR_VAR 0 3
18563: PUSH
18564: LD_INT 4
18566: PUSH
18567: LD_INT 5
18569: PUSH
18570: EMPTY
18571: LIST
18572: LIST
18573: ST_TO_ADDR
18574: GO 19221
18576: LD_INT 22
18578: DOUBLE
18579: EQUAL
18580: IFTRUE 18584
18582: GO 18610
18584: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18585: LD_ADDR_VAR 0 3
18589: PUSH
18590: LD_INT 11
18592: PUSH
18593: LD_INT 12
18595: PUSH
18596: LD_INT 13
18598: PUSH
18599: LD_INT 14
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: LIST
18606: LIST
18607: ST_TO_ADDR
18608: GO 19221
18610: LD_INT 23
18612: DOUBLE
18613: EQUAL
18614: IFTRUE 18618
18616: GO 18644
18618: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18619: LD_ADDR_VAR 0 3
18623: PUSH
18624: LD_INT 11
18626: PUSH
18627: LD_INT 12
18629: PUSH
18630: LD_INT 13
18632: PUSH
18633: LD_INT 14
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: LIST
18640: LIST
18641: ST_TO_ADDR
18642: GO 19221
18644: LD_INT 24
18646: DOUBLE
18647: EQUAL
18648: IFTRUE 18652
18650: GO 18678
18652: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18653: LD_ADDR_VAR 0 3
18657: PUSH
18658: LD_INT 11
18660: PUSH
18661: LD_INT 12
18663: PUSH
18664: LD_INT 13
18666: PUSH
18667: LD_INT 14
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: LIST
18674: LIST
18675: ST_TO_ADDR
18676: GO 19221
18678: LD_INT 30
18680: DOUBLE
18681: EQUAL
18682: IFTRUE 18686
18684: GO 18712
18686: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18687: LD_ADDR_VAR 0 3
18691: PUSH
18692: LD_INT 11
18694: PUSH
18695: LD_INT 12
18697: PUSH
18698: LD_INT 13
18700: PUSH
18701: LD_INT 14
18703: PUSH
18704: EMPTY
18705: LIST
18706: LIST
18707: LIST
18708: LIST
18709: ST_TO_ADDR
18710: GO 19221
18712: LD_INT 25
18714: DOUBLE
18715: EQUAL
18716: IFTRUE 18720
18718: GO 18738
18720: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18721: LD_ADDR_VAR 0 3
18725: PUSH
18726: LD_INT 13
18728: PUSH
18729: LD_INT 14
18731: PUSH
18732: EMPTY
18733: LIST
18734: LIST
18735: ST_TO_ADDR
18736: GO 19221
18738: LD_INT 27
18740: DOUBLE
18741: EQUAL
18742: IFTRUE 18746
18744: GO 18764
18746: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
18747: LD_ADDR_VAR 0 3
18751: PUSH
18752: LD_INT 13
18754: PUSH
18755: LD_INT 14
18757: PUSH
18758: EMPTY
18759: LIST
18760: LIST
18761: ST_TO_ADDR
18762: GO 19221
18764: LD_EXP 109
18768: DOUBLE
18769: EQUAL
18770: IFTRUE 18774
18772: GO 18800
18774: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18775: LD_ADDR_VAR 0 3
18779: PUSH
18780: LD_INT 11
18782: PUSH
18783: LD_INT 12
18785: PUSH
18786: LD_INT 13
18788: PUSH
18789: LD_INT 14
18791: PUSH
18792: EMPTY
18793: LIST
18794: LIST
18795: LIST
18796: LIST
18797: ST_TO_ADDR
18798: GO 19221
18800: LD_INT 28
18802: DOUBLE
18803: EQUAL
18804: IFTRUE 18808
18806: GO 18826
18808: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18809: LD_ADDR_VAR 0 3
18813: PUSH
18814: LD_INT 13
18816: PUSH
18817: LD_INT 14
18819: PUSH
18820: EMPTY
18821: LIST
18822: LIST
18823: ST_TO_ADDR
18824: GO 19221
18826: LD_INT 29
18828: DOUBLE
18829: EQUAL
18830: IFTRUE 18834
18832: GO 18852
18834: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18835: LD_ADDR_VAR 0 3
18839: PUSH
18840: LD_INT 13
18842: PUSH
18843: LD_INT 14
18845: PUSH
18846: EMPTY
18847: LIST
18848: LIST
18849: ST_TO_ADDR
18850: GO 19221
18852: LD_INT 31
18854: DOUBLE
18855: EQUAL
18856: IFTRUE 18860
18858: GO 18878
18860: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18861: LD_ADDR_VAR 0 3
18865: PUSH
18866: LD_INT 13
18868: PUSH
18869: LD_INT 14
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: ST_TO_ADDR
18876: GO 19221
18878: LD_INT 26
18880: DOUBLE
18881: EQUAL
18882: IFTRUE 18886
18884: GO 18904
18886: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18887: LD_ADDR_VAR 0 3
18891: PUSH
18892: LD_INT 13
18894: PUSH
18895: LD_INT 14
18897: PUSH
18898: EMPTY
18899: LIST
18900: LIST
18901: ST_TO_ADDR
18902: GO 19221
18904: LD_INT 42
18906: DOUBLE
18907: EQUAL
18908: IFTRUE 18912
18910: GO 18938
18912: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18913: LD_ADDR_VAR 0 3
18917: PUSH
18918: LD_INT 21
18920: PUSH
18921: LD_INT 22
18923: PUSH
18924: LD_INT 23
18926: PUSH
18927: LD_INT 24
18929: PUSH
18930: EMPTY
18931: LIST
18932: LIST
18933: LIST
18934: LIST
18935: ST_TO_ADDR
18936: GO 19221
18938: LD_INT 43
18940: DOUBLE
18941: EQUAL
18942: IFTRUE 18946
18944: GO 18972
18946: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18947: LD_ADDR_VAR 0 3
18951: PUSH
18952: LD_INT 21
18954: PUSH
18955: LD_INT 22
18957: PUSH
18958: LD_INT 23
18960: PUSH
18961: LD_INT 24
18963: PUSH
18964: EMPTY
18965: LIST
18966: LIST
18967: LIST
18968: LIST
18969: ST_TO_ADDR
18970: GO 19221
18972: LD_INT 44
18974: DOUBLE
18975: EQUAL
18976: IFTRUE 18980
18978: GO 19006
18980: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18981: LD_ADDR_VAR 0 3
18985: PUSH
18986: LD_INT 21
18988: PUSH
18989: LD_INT 22
18991: PUSH
18992: LD_INT 23
18994: PUSH
18995: LD_INT 24
18997: PUSH
18998: EMPTY
18999: LIST
19000: LIST
19001: LIST
19002: LIST
19003: ST_TO_ADDR
19004: GO 19221
19006: LD_INT 45
19008: DOUBLE
19009: EQUAL
19010: IFTRUE 19014
19012: GO 19040
19014: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19015: LD_ADDR_VAR 0 3
19019: PUSH
19020: LD_INT 21
19022: PUSH
19023: LD_INT 22
19025: PUSH
19026: LD_INT 23
19028: PUSH
19029: LD_INT 24
19031: PUSH
19032: EMPTY
19033: LIST
19034: LIST
19035: LIST
19036: LIST
19037: ST_TO_ADDR
19038: GO 19221
19040: LD_INT 49
19042: DOUBLE
19043: EQUAL
19044: IFTRUE 19048
19046: GO 19074
19048: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19049: LD_ADDR_VAR 0 3
19053: PUSH
19054: LD_INT 21
19056: PUSH
19057: LD_INT 22
19059: PUSH
19060: LD_INT 23
19062: PUSH
19063: LD_INT 24
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: LIST
19070: LIST
19071: ST_TO_ADDR
19072: GO 19221
19074: LD_INT 51
19076: DOUBLE
19077: EQUAL
19078: IFTRUE 19082
19080: GO 19108
19082: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19083: LD_ADDR_VAR 0 3
19087: PUSH
19088: LD_INT 21
19090: PUSH
19091: LD_INT 22
19093: PUSH
19094: LD_INT 23
19096: PUSH
19097: LD_INT 24
19099: PUSH
19100: EMPTY
19101: LIST
19102: LIST
19103: LIST
19104: LIST
19105: ST_TO_ADDR
19106: GO 19221
19108: LD_INT 52
19110: DOUBLE
19111: EQUAL
19112: IFTRUE 19116
19114: GO 19142
19116: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19117: LD_ADDR_VAR 0 3
19121: PUSH
19122: LD_INT 21
19124: PUSH
19125: LD_INT 22
19127: PUSH
19128: LD_INT 23
19130: PUSH
19131: LD_INT 24
19133: PUSH
19134: EMPTY
19135: LIST
19136: LIST
19137: LIST
19138: LIST
19139: ST_TO_ADDR
19140: GO 19221
19142: LD_INT 53
19144: DOUBLE
19145: EQUAL
19146: IFTRUE 19150
19148: GO 19168
19150: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19151: LD_ADDR_VAR 0 3
19155: PUSH
19156: LD_INT 23
19158: PUSH
19159: LD_INT 24
19161: PUSH
19162: EMPTY
19163: LIST
19164: LIST
19165: ST_TO_ADDR
19166: GO 19221
19168: LD_INT 46
19170: DOUBLE
19171: EQUAL
19172: IFTRUE 19176
19174: GO 19194
19176: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19177: LD_ADDR_VAR 0 3
19181: PUSH
19182: LD_INT 23
19184: PUSH
19185: LD_INT 24
19187: PUSH
19188: EMPTY
19189: LIST
19190: LIST
19191: ST_TO_ADDR
19192: GO 19221
19194: LD_INT 47
19196: DOUBLE
19197: EQUAL
19198: IFTRUE 19202
19200: GO 19220
19202: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19203: LD_ADDR_VAR 0 3
19207: PUSH
19208: LD_INT 23
19210: PUSH
19211: LD_INT 24
19213: PUSH
19214: EMPTY
19215: LIST
19216: LIST
19217: ST_TO_ADDR
19218: GO 19221
19220: POP
// result := ( chassis in result ) ;
19221: LD_ADDR_VAR 0 3
19225: PUSH
19226: LD_VAR 0 1
19230: PUSH
19231: LD_VAR 0 3
19235: IN
19236: ST_TO_ADDR
// end ;
19237: LD_VAR 0 3
19241: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19242: LD_INT 0
19244: PPUSH
19245: PPUSH
19246: PPUSH
19247: PPUSH
19248: PPUSH
19249: PPUSH
19250: PPUSH
// result := array ;
19251: LD_ADDR_VAR 0 5
19255: PUSH
19256: LD_VAR 0 1
19260: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19261: LD_VAR 0 1
19265: NOT
19266: PUSH
19267: LD_VAR 0 2
19271: NOT
19272: OR
19273: PUSH
19274: LD_VAR 0 3
19278: NOT
19279: OR
19280: PUSH
19281: LD_VAR 0 2
19285: PUSH
19286: LD_VAR 0 1
19290: GREATER
19291: OR
19292: PUSH
19293: LD_VAR 0 3
19297: PUSH
19298: LD_VAR 0 1
19302: GREATER
19303: OR
19304: IFFALSE 19308
// exit ;
19306: GO 19604
// if direction then
19308: LD_VAR 0 4
19312: IFFALSE 19376
// begin d := 1 ;
19314: LD_ADDR_VAR 0 9
19318: PUSH
19319: LD_INT 1
19321: ST_TO_ADDR
// if i_from > i_to then
19322: LD_VAR 0 2
19326: PUSH
19327: LD_VAR 0 3
19331: GREATER
19332: IFFALSE 19358
// length := ( array - i_from ) + i_to else
19334: LD_ADDR_VAR 0 11
19338: PUSH
19339: LD_VAR 0 1
19343: PUSH
19344: LD_VAR 0 2
19348: MINUS
19349: PUSH
19350: LD_VAR 0 3
19354: PLUS
19355: ST_TO_ADDR
19356: GO 19374
// length := i_to - i_from ;
19358: LD_ADDR_VAR 0 11
19362: PUSH
19363: LD_VAR 0 3
19367: PUSH
19368: LD_VAR 0 2
19372: MINUS
19373: ST_TO_ADDR
// end else
19374: GO 19437
// begin d := - 1 ;
19376: LD_ADDR_VAR 0 9
19380: PUSH
19381: LD_INT 1
19383: NEG
19384: ST_TO_ADDR
// if i_from > i_to then
19385: LD_VAR 0 2
19389: PUSH
19390: LD_VAR 0 3
19394: GREATER
19395: IFFALSE 19415
// length := i_from - i_to else
19397: LD_ADDR_VAR 0 11
19401: PUSH
19402: LD_VAR 0 2
19406: PUSH
19407: LD_VAR 0 3
19411: MINUS
19412: ST_TO_ADDR
19413: GO 19437
// length := ( array - i_to ) + i_from ;
19415: LD_ADDR_VAR 0 11
19419: PUSH
19420: LD_VAR 0 1
19424: PUSH
19425: LD_VAR 0 3
19429: MINUS
19430: PUSH
19431: LD_VAR 0 2
19435: PLUS
19436: ST_TO_ADDR
// end ; if not length then
19437: LD_VAR 0 11
19441: NOT
19442: IFFALSE 19446
// exit ;
19444: GO 19604
// tmp := array ;
19446: LD_ADDR_VAR 0 10
19450: PUSH
19451: LD_VAR 0 1
19455: ST_TO_ADDR
// for i = 1 to length do
19456: LD_ADDR_VAR 0 6
19460: PUSH
19461: DOUBLE
19462: LD_INT 1
19464: DEC
19465: ST_TO_ADDR
19466: LD_VAR 0 11
19470: PUSH
19471: FOR_TO
19472: IFFALSE 19592
// begin for j = 1 to array do
19474: LD_ADDR_VAR 0 7
19478: PUSH
19479: DOUBLE
19480: LD_INT 1
19482: DEC
19483: ST_TO_ADDR
19484: LD_VAR 0 1
19488: PUSH
19489: FOR_TO
19490: IFFALSE 19578
// begin k := j + d ;
19492: LD_ADDR_VAR 0 8
19496: PUSH
19497: LD_VAR 0 7
19501: PUSH
19502: LD_VAR 0 9
19506: PLUS
19507: ST_TO_ADDR
// if k > array then
19508: LD_VAR 0 8
19512: PUSH
19513: LD_VAR 0 1
19517: GREATER
19518: IFFALSE 19528
// k := 1 ;
19520: LD_ADDR_VAR 0 8
19524: PUSH
19525: LD_INT 1
19527: ST_TO_ADDR
// if not k then
19528: LD_VAR 0 8
19532: NOT
19533: IFFALSE 19545
// k := array ;
19535: LD_ADDR_VAR 0 8
19539: PUSH
19540: LD_VAR 0 1
19544: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19545: LD_ADDR_VAR 0 10
19549: PUSH
19550: LD_VAR 0 10
19554: PPUSH
19555: LD_VAR 0 8
19559: PPUSH
19560: LD_VAR 0 1
19564: PUSH
19565: LD_VAR 0 7
19569: ARRAY
19570: PPUSH
19571: CALL_OW 1
19575: ST_TO_ADDR
// end ;
19576: GO 19489
19578: POP
19579: POP
// array := tmp ;
19580: LD_ADDR_VAR 0 1
19584: PUSH
19585: LD_VAR 0 10
19589: ST_TO_ADDR
// end ;
19590: GO 19471
19592: POP
19593: POP
// result := array ;
19594: LD_ADDR_VAR 0 5
19598: PUSH
19599: LD_VAR 0 1
19603: ST_TO_ADDR
// end ;
19604: LD_VAR 0 5
19608: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19609: LD_INT 0
19611: PPUSH
19612: PPUSH
// result := 0 ;
19613: LD_ADDR_VAR 0 3
19617: PUSH
19618: LD_INT 0
19620: ST_TO_ADDR
// if not array or not value in array then
19621: LD_VAR 0 1
19625: NOT
19626: PUSH
19627: LD_VAR 0 2
19631: PUSH
19632: LD_VAR 0 1
19636: IN
19637: NOT
19638: OR
19639: IFFALSE 19643
// exit ;
19641: GO 19697
// for i = 1 to array do
19643: LD_ADDR_VAR 0 4
19647: PUSH
19648: DOUBLE
19649: LD_INT 1
19651: DEC
19652: ST_TO_ADDR
19653: LD_VAR 0 1
19657: PUSH
19658: FOR_TO
19659: IFFALSE 19695
// if value = array [ i ] then
19661: LD_VAR 0 2
19665: PUSH
19666: LD_VAR 0 1
19670: PUSH
19671: LD_VAR 0 4
19675: ARRAY
19676: EQUAL
19677: IFFALSE 19693
// begin result := i ;
19679: LD_ADDR_VAR 0 3
19683: PUSH
19684: LD_VAR 0 4
19688: ST_TO_ADDR
// exit ;
19689: POP
19690: POP
19691: GO 19697
// end ;
19693: GO 19658
19695: POP
19696: POP
// end ;
19697: LD_VAR 0 3
19701: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19702: LD_INT 0
19704: PPUSH
// vc_chassis := chassis ;
19705: LD_ADDR_OWVAR 37
19709: PUSH
19710: LD_VAR 0 1
19714: ST_TO_ADDR
// vc_engine := engine ;
19715: LD_ADDR_OWVAR 39
19719: PUSH
19720: LD_VAR 0 2
19724: ST_TO_ADDR
// vc_control := control ;
19725: LD_ADDR_OWVAR 38
19729: PUSH
19730: LD_VAR 0 3
19734: ST_TO_ADDR
// vc_weapon := weapon ;
19735: LD_ADDR_OWVAR 40
19739: PUSH
19740: LD_VAR 0 4
19744: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19745: LD_ADDR_OWVAR 41
19749: PUSH
19750: LD_VAR 0 5
19754: ST_TO_ADDR
// end ;
19755: LD_VAR 0 6
19759: RET
// export function WantPlant ( unit ) ; var task ; begin
19760: LD_INT 0
19762: PPUSH
19763: PPUSH
// result := false ;
19764: LD_ADDR_VAR 0 2
19768: PUSH
19769: LD_INT 0
19771: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19772: LD_ADDR_VAR 0 3
19776: PUSH
19777: LD_VAR 0 1
19781: PPUSH
19782: CALL_OW 437
19786: ST_TO_ADDR
// if task then
19787: LD_VAR 0 3
19791: IFFALSE 19819
// if task [ 1 ] [ 1 ] = p then
19793: LD_VAR 0 3
19797: PUSH
19798: LD_INT 1
19800: ARRAY
19801: PUSH
19802: LD_INT 1
19804: ARRAY
19805: PUSH
19806: LD_STRING p
19808: EQUAL
19809: IFFALSE 19819
// result := true ;
19811: LD_ADDR_VAR 0 2
19815: PUSH
19816: LD_INT 1
19818: ST_TO_ADDR
// end ;
19819: LD_VAR 0 2
19823: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19824: LD_INT 0
19826: PPUSH
19827: PPUSH
19828: PPUSH
19829: PPUSH
// if pos < 1 then
19830: LD_VAR 0 2
19834: PUSH
19835: LD_INT 1
19837: LESS
19838: IFFALSE 19842
// exit ;
19840: GO 20145
// if pos = 1 then
19842: LD_VAR 0 2
19846: PUSH
19847: LD_INT 1
19849: EQUAL
19850: IFFALSE 19883
// result := Replace ( arr , pos [ 1 ] , value ) else
19852: LD_ADDR_VAR 0 4
19856: PUSH
19857: LD_VAR 0 1
19861: PPUSH
19862: LD_VAR 0 2
19866: PUSH
19867: LD_INT 1
19869: ARRAY
19870: PPUSH
19871: LD_VAR 0 3
19875: PPUSH
19876: CALL_OW 1
19880: ST_TO_ADDR
19881: GO 20145
// begin tmp := arr ;
19883: LD_ADDR_VAR 0 6
19887: PUSH
19888: LD_VAR 0 1
19892: ST_TO_ADDR
// s_arr := [ tmp ] ;
19893: LD_ADDR_VAR 0 7
19897: PUSH
19898: LD_VAR 0 6
19902: PUSH
19903: EMPTY
19904: LIST
19905: ST_TO_ADDR
// for i = 1 to pos - 1 do
19906: LD_ADDR_VAR 0 5
19910: PUSH
19911: DOUBLE
19912: LD_INT 1
19914: DEC
19915: ST_TO_ADDR
19916: LD_VAR 0 2
19920: PUSH
19921: LD_INT 1
19923: MINUS
19924: PUSH
19925: FOR_TO
19926: IFFALSE 19971
// begin tmp := tmp [ pos [ i ] ] ;
19928: LD_ADDR_VAR 0 6
19932: PUSH
19933: LD_VAR 0 6
19937: PUSH
19938: LD_VAR 0 2
19942: PUSH
19943: LD_VAR 0 5
19947: ARRAY
19948: ARRAY
19949: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19950: LD_ADDR_VAR 0 7
19954: PUSH
19955: LD_VAR 0 7
19959: PUSH
19960: LD_VAR 0 6
19964: PUSH
19965: EMPTY
19966: LIST
19967: ADD
19968: ST_TO_ADDR
// end ;
19969: GO 19925
19971: POP
19972: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19973: LD_ADDR_VAR 0 6
19977: PUSH
19978: LD_VAR 0 6
19982: PPUSH
19983: LD_VAR 0 2
19987: PUSH
19988: LD_VAR 0 2
19992: ARRAY
19993: PPUSH
19994: LD_VAR 0 3
19998: PPUSH
19999: CALL_OW 1
20003: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20004: LD_ADDR_VAR 0 7
20008: PUSH
20009: LD_VAR 0 7
20013: PPUSH
20014: LD_VAR 0 7
20018: PPUSH
20019: LD_VAR 0 6
20023: PPUSH
20024: CALL_OW 1
20028: ST_TO_ADDR
// for i = s_arr downto 2 do
20029: LD_ADDR_VAR 0 5
20033: PUSH
20034: DOUBLE
20035: LD_VAR 0 7
20039: INC
20040: ST_TO_ADDR
20041: LD_INT 2
20043: PUSH
20044: FOR_DOWNTO
20045: IFFALSE 20129
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20047: LD_ADDR_VAR 0 6
20051: PUSH
20052: LD_VAR 0 7
20056: PUSH
20057: LD_VAR 0 5
20061: PUSH
20062: LD_INT 1
20064: MINUS
20065: ARRAY
20066: PPUSH
20067: LD_VAR 0 2
20071: PUSH
20072: LD_VAR 0 5
20076: PUSH
20077: LD_INT 1
20079: MINUS
20080: ARRAY
20081: PPUSH
20082: LD_VAR 0 7
20086: PUSH
20087: LD_VAR 0 5
20091: ARRAY
20092: PPUSH
20093: CALL_OW 1
20097: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20098: LD_ADDR_VAR 0 7
20102: PUSH
20103: LD_VAR 0 7
20107: PPUSH
20108: LD_VAR 0 5
20112: PUSH
20113: LD_INT 1
20115: MINUS
20116: PPUSH
20117: LD_VAR 0 6
20121: PPUSH
20122: CALL_OW 1
20126: ST_TO_ADDR
// end ;
20127: GO 20044
20129: POP
20130: POP
// result := s_arr [ 1 ] ;
20131: LD_ADDR_VAR 0 4
20135: PUSH
20136: LD_VAR 0 7
20140: PUSH
20141: LD_INT 1
20143: ARRAY
20144: ST_TO_ADDR
// end ; end ;
20145: LD_VAR 0 4
20149: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20150: LD_INT 0
20152: PPUSH
20153: PPUSH
// if not list then
20154: LD_VAR 0 1
20158: NOT
20159: IFFALSE 20163
// exit ;
20161: GO 20254
// i := list [ pos1 ] ;
20163: LD_ADDR_VAR 0 5
20167: PUSH
20168: LD_VAR 0 1
20172: PUSH
20173: LD_VAR 0 2
20177: ARRAY
20178: ST_TO_ADDR
// if not i then
20179: LD_VAR 0 5
20183: NOT
20184: IFFALSE 20188
// exit ;
20186: GO 20254
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20188: LD_ADDR_VAR 0 1
20192: PUSH
20193: LD_VAR 0 1
20197: PPUSH
20198: LD_VAR 0 2
20202: PPUSH
20203: LD_VAR 0 1
20207: PUSH
20208: LD_VAR 0 3
20212: ARRAY
20213: PPUSH
20214: CALL_OW 1
20218: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20219: LD_ADDR_VAR 0 1
20223: PUSH
20224: LD_VAR 0 1
20228: PPUSH
20229: LD_VAR 0 3
20233: PPUSH
20234: LD_VAR 0 5
20238: PPUSH
20239: CALL_OW 1
20243: ST_TO_ADDR
// result := list ;
20244: LD_ADDR_VAR 0 4
20248: PUSH
20249: LD_VAR 0 1
20253: ST_TO_ADDR
// end ;
20254: LD_VAR 0 4
20258: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20259: LD_INT 0
20261: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20262: LD_ADDR_VAR 0 5
20266: PUSH
20267: LD_VAR 0 1
20271: PPUSH
20272: CALL_OW 250
20276: PPUSH
20277: LD_VAR 0 1
20281: PPUSH
20282: CALL_OW 251
20286: PPUSH
20287: LD_VAR 0 2
20291: PPUSH
20292: LD_VAR 0 3
20296: PPUSH
20297: LD_VAR 0 4
20301: PPUSH
20302: CALL 20312 0 5
20306: ST_TO_ADDR
// end ;
20307: LD_VAR 0 5
20311: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20312: LD_INT 0
20314: PPUSH
20315: PPUSH
20316: PPUSH
20317: PPUSH
// if not list then
20318: LD_VAR 0 3
20322: NOT
20323: IFFALSE 20327
// exit ;
20325: GO 20715
// result := [ ] ;
20327: LD_ADDR_VAR 0 6
20331: PUSH
20332: EMPTY
20333: ST_TO_ADDR
// for i in list do
20334: LD_ADDR_VAR 0 7
20338: PUSH
20339: LD_VAR 0 3
20343: PUSH
20344: FOR_IN
20345: IFFALSE 20547
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20347: LD_ADDR_VAR 0 9
20351: PUSH
20352: LD_VAR 0 7
20356: PPUSH
20357: LD_VAR 0 1
20361: PPUSH
20362: LD_VAR 0 2
20366: PPUSH
20367: CALL_OW 297
20371: ST_TO_ADDR
// if not result then
20372: LD_VAR 0 6
20376: NOT
20377: IFFALSE 20403
// result := [ [ i , tmp ] ] else
20379: LD_ADDR_VAR 0 6
20383: PUSH
20384: LD_VAR 0 7
20388: PUSH
20389: LD_VAR 0 9
20393: PUSH
20394: EMPTY
20395: LIST
20396: LIST
20397: PUSH
20398: EMPTY
20399: LIST
20400: ST_TO_ADDR
20401: GO 20545
// begin if result [ result ] [ 2 ] < tmp then
20403: LD_VAR 0 6
20407: PUSH
20408: LD_VAR 0 6
20412: ARRAY
20413: PUSH
20414: LD_INT 2
20416: ARRAY
20417: PUSH
20418: LD_VAR 0 9
20422: LESS
20423: IFFALSE 20465
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20425: LD_ADDR_VAR 0 6
20429: PUSH
20430: LD_VAR 0 6
20434: PPUSH
20435: LD_VAR 0 6
20439: PUSH
20440: LD_INT 1
20442: PLUS
20443: PPUSH
20444: LD_VAR 0 7
20448: PUSH
20449: LD_VAR 0 9
20453: PUSH
20454: EMPTY
20455: LIST
20456: LIST
20457: PPUSH
20458: CALL_OW 2
20462: ST_TO_ADDR
20463: GO 20545
// for j = 1 to result do
20465: LD_ADDR_VAR 0 8
20469: PUSH
20470: DOUBLE
20471: LD_INT 1
20473: DEC
20474: ST_TO_ADDR
20475: LD_VAR 0 6
20479: PUSH
20480: FOR_TO
20481: IFFALSE 20543
// begin if tmp < result [ j ] [ 2 ] then
20483: LD_VAR 0 9
20487: PUSH
20488: LD_VAR 0 6
20492: PUSH
20493: LD_VAR 0 8
20497: ARRAY
20498: PUSH
20499: LD_INT 2
20501: ARRAY
20502: LESS
20503: IFFALSE 20541
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20505: LD_ADDR_VAR 0 6
20509: PUSH
20510: LD_VAR 0 6
20514: PPUSH
20515: LD_VAR 0 8
20519: PPUSH
20520: LD_VAR 0 7
20524: PUSH
20525: LD_VAR 0 9
20529: PUSH
20530: EMPTY
20531: LIST
20532: LIST
20533: PPUSH
20534: CALL_OW 2
20538: ST_TO_ADDR
// break ;
20539: GO 20543
// end ; end ;
20541: GO 20480
20543: POP
20544: POP
// end ; end ;
20545: GO 20344
20547: POP
20548: POP
// if result and not asc then
20549: LD_VAR 0 6
20553: PUSH
20554: LD_VAR 0 4
20558: NOT
20559: AND
20560: IFFALSE 20635
// begin tmp := result ;
20562: LD_ADDR_VAR 0 9
20566: PUSH
20567: LD_VAR 0 6
20571: ST_TO_ADDR
// for i = tmp downto 1 do
20572: LD_ADDR_VAR 0 7
20576: PUSH
20577: DOUBLE
20578: LD_VAR 0 9
20582: INC
20583: ST_TO_ADDR
20584: LD_INT 1
20586: PUSH
20587: FOR_DOWNTO
20588: IFFALSE 20633
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20590: LD_ADDR_VAR 0 6
20594: PUSH
20595: LD_VAR 0 6
20599: PPUSH
20600: LD_VAR 0 9
20604: PUSH
20605: LD_VAR 0 7
20609: MINUS
20610: PUSH
20611: LD_INT 1
20613: PLUS
20614: PPUSH
20615: LD_VAR 0 9
20619: PUSH
20620: LD_VAR 0 7
20624: ARRAY
20625: PPUSH
20626: CALL_OW 1
20630: ST_TO_ADDR
20631: GO 20587
20633: POP
20634: POP
// end ; tmp := [ ] ;
20635: LD_ADDR_VAR 0 9
20639: PUSH
20640: EMPTY
20641: ST_TO_ADDR
// if mode then
20642: LD_VAR 0 5
20646: IFFALSE 20715
// begin for i = 1 to result do
20648: LD_ADDR_VAR 0 7
20652: PUSH
20653: DOUBLE
20654: LD_INT 1
20656: DEC
20657: ST_TO_ADDR
20658: LD_VAR 0 6
20662: PUSH
20663: FOR_TO
20664: IFFALSE 20703
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20666: LD_ADDR_VAR 0 9
20670: PUSH
20671: LD_VAR 0 9
20675: PPUSH
20676: LD_VAR 0 7
20680: PPUSH
20681: LD_VAR 0 6
20685: PUSH
20686: LD_VAR 0 7
20690: ARRAY
20691: PUSH
20692: LD_INT 1
20694: ARRAY
20695: PPUSH
20696: CALL_OW 1
20700: ST_TO_ADDR
20701: GO 20663
20703: POP
20704: POP
// result := tmp ;
20705: LD_ADDR_VAR 0 6
20709: PUSH
20710: LD_VAR 0 9
20714: ST_TO_ADDR
// end ; end ;
20715: LD_VAR 0 6
20719: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20720: LD_INT 0
20722: PPUSH
20723: PPUSH
20724: PPUSH
20725: PPUSH
20726: PPUSH
20727: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20728: LD_ADDR_VAR 0 5
20732: PUSH
20733: LD_INT 0
20735: PUSH
20736: LD_INT 0
20738: PUSH
20739: LD_INT 0
20741: PUSH
20742: EMPTY
20743: PUSH
20744: EMPTY
20745: LIST
20746: LIST
20747: LIST
20748: LIST
20749: ST_TO_ADDR
// if not x or not y then
20750: LD_VAR 0 2
20754: NOT
20755: PUSH
20756: LD_VAR 0 3
20760: NOT
20761: OR
20762: IFFALSE 20766
// exit ;
20764: GO 22418
// if not range then
20766: LD_VAR 0 4
20770: NOT
20771: IFFALSE 20781
// range := 10 ;
20773: LD_ADDR_VAR 0 4
20777: PUSH
20778: LD_INT 10
20780: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20781: LD_ADDR_VAR 0 8
20785: PUSH
20786: LD_INT 81
20788: PUSH
20789: LD_VAR 0 1
20793: PUSH
20794: EMPTY
20795: LIST
20796: LIST
20797: PUSH
20798: LD_INT 92
20800: PUSH
20801: LD_VAR 0 2
20805: PUSH
20806: LD_VAR 0 3
20810: PUSH
20811: LD_VAR 0 4
20815: PUSH
20816: EMPTY
20817: LIST
20818: LIST
20819: LIST
20820: LIST
20821: PUSH
20822: LD_INT 3
20824: PUSH
20825: LD_INT 21
20827: PUSH
20828: LD_INT 3
20830: PUSH
20831: EMPTY
20832: LIST
20833: LIST
20834: PUSH
20835: EMPTY
20836: LIST
20837: LIST
20838: PUSH
20839: EMPTY
20840: LIST
20841: LIST
20842: LIST
20843: PPUSH
20844: CALL_OW 69
20848: ST_TO_ADDR
// if not tmp then
20849: LD_VAR 0 8
20853: NOT
20854: IFFALSE 20858
// exit ;
20856: GO 22418
// for i in tmp do
20858: LD_ADDR_VAR 0 6
20862: PUSH
20863: LD_VAR 0 8
20867: PUSH
20868: FOR_IN
20869: IFFALSE 22393
// begin points := [ 0 , 0 , 0 ] ;
20871: LD_ADDR_VAR 0 9
20875: PUSH
20876: LD_INT 0
20878: PUSH
20879: LD_INT 0
20881: PUSH
20882: LD_INT 0
20884: PUSH
20885: EMPTY
20886: LIST
20887: LIST
20888: LIST
20889: ST_TO_ADDR
// bpoints := 1 ;
20890: LD_ADDR_VAR 0 10
20894: PUSH
20895: LD_INT 1
20897: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20898: LD_VAR 0 6
20902: PPUSH
20903: CALL_OW 247
20907: PUSH
20908: LD_INT 1
20910: DOUBLE
20911: EQUAL
20912: IFTRUE 20916
20914: GO 21494
20916: POP
// begin if GetClass ( i ) = 1 then
20917: LD_VAR 0 6
20921: PPUSH
20922: CALL_OW 257
20926: PUSH
20927: LD_INT 1
20929: EQUAL
20930: IFFALSE 20951
// points := [ 10 , 5 , 3 ] ;
20932: LD_ADDR_VAR 0 9
20936: PUSH
20937: LD_INT 10
20939: PUSH
20940: LD_INT 5
20942: PUSH
20943: LD_INT 3
20945: PUSH
20946: EMPTY
20947: LIST
20948: LIST
20949: LIST
20950: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20951: LD_VAR 0 6
20955: PPUSH
20956: CALL_OW 257
20960: PUSH
20961: LD_INT 2
20963: PUSH
20964: LD_INT 3
20966: PUSH
20967: LD_INT 4
20969: PUSH
20970: EMPTY
20971: LIST
20972: LIST
20973: LIST
20974: IN
20975: IFFALSE 20996
// points := [ 3 , 2 , 1 ] ;
20977: LD_ADDR_VAR 0 9
20981: PUSH
20982: LD_INT 3
20984: PUSH
20985: LD_INT 2
20987: PUSH
20988: LD_INT 1
20990: PUSH
20991: EMPTY
20992: LIST
20993: LIST
20994: LIST
20995: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20996: LD_VAR 0 6
21000: PPUSH
21001: CALL_OW 257
21005: PUSH
21006: LD_INT 5
21008: EQUAL
21009: IFFALSE 21030
// points := [ 130 , 5 , 2 ] ;
21011: LD_ADDR_VAR 0 9
21015: PUSH
21016: LD_INT 130
21018: PUSH
21019: LD_INT 5
21021: PUSH
21022: LD_INT 2
21024: PUSH
21025: EMPTY
21026: LIST
21027: LIST
21028: LIST
21029: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21030: LD_VAR 0 6
21034: PPUSH
21035: CALL_OW 257
21039: PUSH
21040: LD_INT 8
21042: EQUAL
21043: IFFALSE 21064
// points := [ 35 , 35 , 30 ] ;
21045: LD_ADDR_VAR 0 9
21049: PUSH
21050: LD_INT 35
21052: PUSH
21053: LD_INT 35
21055: PUSH
21056: LD_INT 30
21058: PUSH
21059: EMPTY
21060: LIST
21061: LIST
21062: LIST
21063: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21064: LD_VAR 0 6
21068: PPUSH
21069: CALL_OW 257
21073: PUSH
21074: LD_INT 9
21076: EQUAL
21077: IFFALSE 21098
// points := [ 20 , 55 , 40 ] ;
21079: LD_ADDR_VAR 0 9
21083: PUSH
21084: LD_INT 20
21086: PUSH
21087: LD_INT 55
21089: PUSH
21090: LD_INT 40
21092: PUSH
21093: EMPTY
21094: LIST
21095: LIST
21096: LIST
21097: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21098: LD_VAR 0 6
21102: PPUSH
21103: CALL_OW 257
21107: PUSH
21108: LD_INT 12
21110: PUSH
21111: LD_INT 16
21113: PUSH
21114: EMPTY
21115: LIST
21116: LIST
21117: IN
21118: IFFALSE 21139
// points := [ 5 , 3 , 2 ] ;
21120: LD_ADDR_VAR 0 9
21124: PUSH
21125: LD_INT 5
21127: PUSH
21128: LD_INT 3
21130: PUSH
21131: LD_INT 2
21133: PUSH
21134: EMPTY
21135: LIST
21136: LIST
21137: LIST
21138: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21139: LD_VAR 0 6
21143: PPUSH
21144: CALL_OW 257
21148: PUSH
21149: LD_INT 17
21151: EQUAL
21152: IFFALSE 21173
// points := [ 100 , 50 , 75 ] ;
21154: LD_ADDR_VAR 0 9
21158: PUSH
21159: LD_INT 100
21161: PUSH
21162: LD_INT 50
21164: PUSH
21165: LD_INT 75
21167: PUSH
21168: EMPTY
21169: LIST
21170: LIST
21171: LIST
21172: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21173: LD_VAR 0 6
21177: PPUSH
21178: CALL_OW 257
21182: PUSH
21183: LD_INT 15
21185: EQUAL
21186: IFFALSE 21207
// points := [ 10 , 5 , 3 ] ;
21188: LD_ADDR_VAR 0 9
21192: PUSH
21193: LD_INT 10
21195: PUSH
21196: LD_INT 5
21198: PUSH
21199: LD_INT 3
21201: PUSH
21202: EMPTY
21203: LIST
21204: LIST
21205: LIST
21206: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21207: LD_VAR 0 6
21211: PPUSH
21212: CALL_OW 257
21216: PUSH
21217: LD_INT 14
21219: EQUAL
21220: IFFALSE 21241
// points := [ 10 , 0 , 0 ] ;
21222: LD_ADDR_VAR 0 9
21226: PUSH
21227: LD_INT 10
21229: PUSH
21230: LD_INT 0
21232: PUSH
21233: LD_INT 0
21235: PUSH
21236: EMPTY
21237: LIST
21238: LIST
21239: LIST
21240: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21241: LD_VAR 0 6
21245: PPUSH
21246: CALL_OW 257
21250: PUSH
21251: LD_INT 11
21253: EQUAL
21254: IFFALSE 21275
// points := [ 30 , 10 , 5 ] ;
21256: LD_ADDR_VAR 0 9
21260: PUSH
21261: LD_INT 30
21263: PUSH
21264: LD_INT 10
21266: PUSH
21267: LD_INT 5
21269: PUSH
21270: EMPTY
21271: LIST
21272: LIST
21273: LIST
21274: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21275: LD_VAR 0 1
21279: PPUSH
21280: LD_INT 5
21282: PPUSH
21283: CALL_OW 321
21287: PUSH
21288: LD_INT 2
21290: EQUAL
21291: IFFALSE 21308
// bpoints := bpoints * 1.8 ;
21293: LD_ADDR_VAR 0 10
21297: PUSH
21298: LD_VAR 0 10
21302: PUSH
21303: LD_REAL  1.80000000000000E+0000
21306: MUL
21307: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21308: LD_VAR 0 6
21312: PPUSH
21313: CALL_OW 257
21317: PUSH
21318: LD_INT 1
21320: PUSH
21321: LD_INT 2
21323: PUSH
21324: LD_INT 3
21326: PUSH
21327: LD_INT 4
21329: PUSH
21330: EMPTY
21331: LIST
21332: LIST
21333: LIST
21334: LIST
21335: IN
21336: PUSH
21337: LD_VAR 0 1
21341: PPUSH
21342: LD_INT 51
21344: PPUSH
21345: CALL_OW 321
21349: PUSH
21350: LD_INT 2
21352: EQUAL
21353: AND
21354: IFFALSE 21371
// bpoints := bpoints * 1.2 ;
21356: LD_ADDR_VAR 0 10
21360: PUSH
21361: LD_VAR 0 10
21365: PUSH
21366: LD_REAL  1.20000000000000E+0000
21369: MUL
21370: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21371: LD_VAR 0 6
21375: PPUSH
21376: CALL_OW 257
21380: PUSH
21381: LD_INT 5
21383: PUSH
21384: LD_INT 7
21386: PUSH
21387: LD_INT 9
21389: PUSH
21390: EMPTY
21391: LIST
21392: LIST
21393: LIST
21394: IN
21395: PUSH
21396: LD_VAR 0 1
21400: PPUSH
21401: LD_INT 52
21403: PPUSH
21404: CALL_OW 321
21408: PUSH
21409: LD_INT 2
21411: EQUAL
21412: AND
21413: IFFALSE 21430
// bpoints := bpoints * 1.5 ;
21415: LD_ADDR_VAR 0 10
21419: PUSH
21420: LD_VAR 0 10
21424: PUSH
21425: LD_REAL  1.50000000000000E+0000
21428: MUL
21429: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21430: LD_VAR 0 1
21434: PPUSH
21435: LD_INT 66
21437: PPUSH
21438: CALL_OW 321
21442: PUSH
21443: LD_INT 2
21445: EQUAL
21446: IFFALSE 21463
// bpoints := bpoints * 1.1 ;
21448: LD_ADDR_VAR 0 10
21452: PUSH
21453: LD_VAR 0 10
21457: PUSH
21458: LD_REAL  1.10000000000000E+0000
21461: MUL
21462: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21463: LD_ADDR_VAR 0 10
21467: PUSH
21468: LD_VAR 0 10
21472: PUSH
21473: LD_VAR 0 6
21477: PPUSH
21478: LD_INT 1
21480: PPUSH
21481: CALL_OW 259
21485: PUSH
21486: LD_REAL  1.15000000000000E+0000
21489: MUL
21490: MUL
21491: ST_TO_ADDR
// end ; unit_vehicle :
21492: GO 22322
21494: LD_INT 2
21496: DOUBLE
21497: EQUAL
21498: IFTRUE 21502
21500: GO 22310
21502: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21503: LD_VAR 0 6
21507: PPUSH
21508: CALL_OW 264
21512: PUSH
21513: LD_INT 2
21515: PUSH
21516: LD_INT 42
21518: PUSH
21519: LD_INT 24
21521: PUSH
21522: EMPTY
21523: LIST
21524: LIST
21525: LIST
21526: IN
21527: IFFALSE 21548
// points := [ 25 , 5 , 3 ] ;
21529: LD_ADDR_VAR 0 9
21533: PUSH
21534: LD_INT 25
21536: PUSH
21537: LD_INT 5
21539: PUSH
21540: LD_INT 3
21542: PUSH
21543: EMPTY
21544: LIST
21545: LIST
21546: LIST
21547: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21548: LD_VAR 0 6
21552: PPUSH
21553: CALL_OW 264
21557: PUSH
21558: LD_INT 4
21560: PUSH
21561: LD_INT 43
21563: PUSH
21564: LD_INT 25
21566: PUSH
21567: EMPTY
21568: LIST
21569: LIST
21570: LIST
21571: IN
21572: IFFALSE 21593
// points := [ 40 , 15 , 5 ] ;
21574: LD_ADDR_VAR 0 9
21578: PUSH
21579: LD_INT 40
21581: PUSH
21582: LD_INT 15
21584: PUSH
21585: LD_INT 5
21587: PUSH
21588: EMPTY
21589: LIST
21590: LIST
21591: LIST
21592: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21593: LD_VAR 0 6
21597: PPUSH
21598: CALL_OW 264
21602: PUSH
21603: LD_INT 3
21605: PUSH
21606: LD_INT 23
21608: PUSH
21609: EMPTY
21610: LIST
21611: LIST
21612: IN
21613: IFFALSE 21634
// points := [ 7 , 25 , 8 ] ;
21615: LD_ADDR_VAR 0 9
21619: PUSH
21620: LD_INT 7
21622: PUSH
21623: LD_INT 25
21625: PUSH
21626: LD_INT 8
21628: PUSH
21629: EMPTY
21630: LIST
21631: LIST
21632: LIST
21633: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21634: LD_VAR 0 6
21638: PPUSH
21639: CALL_OW 264
21643: PUSH
21644: LD_INT 5
21646: PUSH
21647: LD_INT 27
21649: PUSH
21650: LD_INT 44
21652: PUSH
21653: EMPTY
21654: LIST
21655: LIST
21656: LIST
21657: IN
21658: IFFALSE 21679
// points := [ 14 , 50 , 16 ] ;
21660: LD_ADDR_VAR 0 9
21664: PUSH
21665: LD_INT 14
21667: PUSH
21668: LD_INT 50
21670: PUSH
21671: LD_INT 16
21673: PUSH
21674: EMPTY
21675: LIST
21676: LIST
21677: LIST
21678: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21679: LD_VAR 0 6
21683: PPUSH
21684: CALL_OW 264
21688: PUSH
21689: LD_INT 6
21691: PUSH
21692: LD_INT 46
21694: PUSH
21695: EMPTY
21696: LIST
21697: LIST
21698: IN
21699: IFFALSE 21720
// points := [ 32 , 120 , 70 ] ;
21701: LD_ADDR_VAR 0 9
21705: PUSH
21706: LD_INT 32
21708: PUSH
21709: LD_INT 120
21711: PUSH
21712: LD_INT 70
21714: PUSH
21715: EMPTY
21716: LIST
21717: LIST
21718: LIST
21719: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21720: LD_VAR 0 6
21724: PPUSH
21725: CALL_OW 264
21729: PUSH
21730: LD_INT 7
21732: PUSH
21733: LD_INT 28
21735: PUSH
21736: LD_INT 45
21738: PUSH
21739: LD_EXP 109
21743: PUSH
21744: EMPTY
21745: LIST
21746: LIST
21747: LIST
21748: LIST
21749: IN
21750: IFFALSE 21771
// points := [ 35 , 20 , 45 ] ;
21752: LD_ADDR_VAR 0 9
21756: PUSH
21757: LD_INT 35
21759: PUSH
21760: LD_INT 20
21762: PUSH
21763: LD_INT 45
21765: PUSH
21766: EMPTY
21767: LIST
21768: LIST
21769: LIST
21770: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21771: LD_VAR 0 6
21775: PPUSH
21776: CALL_OW 264
21780: PUSH
21781: LD_INT 47
21783: PUSH
21784: EMPTY
21785: LIST
21786: IN
21787: IFFALSE 21808
// points := [ 67 , 45 , 75 ] ;
21789: LD_ADDR_VAR 0 9
21793: PUSH
21794: LD_INT 67
21796: PUSH
21797: LD_INT 45
21799: PUSH
21800: LD_INT 75
21802: PUSH
21803: EMPTY
21804: LIST
21805: LIST
21806: LIST
21807: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21808: LD_VAR 0 6
21812: PPUSH
21813: CALL_OW 264
21817: PUSH
21818: LD_INT 26
21820: PUSH
21821: EMPTY
21822: LIST
21823: IN
21824: IFFALSE 21845
// points := [ 120 , 30 , 80 ] ;
21826: LD_ADDR_VAR 0 9
21830: PUSH
21831: LD_INT 120
21833: PUSH
21834: LD_INT 30
21836: PUSH
21837: LD_INT 80
21839: PUSH
21840: EMPTY
21841: LIST
21842: LIST
21843: LIST
21844: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21845: LD_VAR 0 6
21849: PPUSH
21850: CALL_OW 264
21854: PUSH
21855: LD_INT 22
21857: PUSH
21858: EMPTY
21859: LIST
21860: IN
21861: IFFALSE 21882
// points := [ 40 , 1 , 1 ] ;
21863: LD_ADDR_VAR 0 9
21867: PUSH
21868: LD_INT 40
21870: PUSH
21871: LD_INT 1
21873: PUSH
21874: LD_INT 1
21876: PUSH
21877: EMPTY
21878: LIST
21879: LIST
21880: LIST
21881: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21882: LD_VAR 0 6
21886: PPUSH
21887: CALL_OW 264
21891: PUSH
21892: LD_INT 29
21894: PUSH
21895: EMPTY
21896: LIST
21897: IN
21898: IFFALSE 21919
// points := [ 70 , 200 , 400 ] ;
21900: LD_ADDR_VAR 0 9
21904: PUSH
21905: LD_INT 70
21907: PUSH
21908: LD_INT 200
21910: PUSH
21911: LD_INT 400
21913: PUSH
21914: EMPTY
21915: LIST
21916: LIST
21917: LIST
21918: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21919: LD_VAR 0 6
21923: PPUSH
21924: CALL_OW 264
21928: PUSH
21929: LD_INT 14
21931: PUSH
21932: LD_INT 53
21934: PUSH
21935: EMPTY
21936: LIST
21937: LIST
21938: IN
21939: IFFALSE 21960
// points := [ 40 , 10 , 20 ] ;
21941: LD_ADDR_VAR 0 9
21945: PUSH
21946: LD_INT 40
21948: PUSH
21949: LD_INT 10
21951: PUSH
21952: LD_INT 20
21954: PUSH
21955: EMPTY
21956: LIST
21957: LIST
21958: LIST
21959: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21960: LD_VAR 0 6
21964: PPUSH
21965: CALL_OW 264
21969: PUSH
21970: LD_INT 9
21972: PUSH
21973: EMPTY
21974: LIST
21975: IN
21976: IFFALSE 21997
// points := [ 5 , 70 , 20 ] ;
21978: LD_ADDR_VAR 0 9
21982: PUSH
21983: LD_INT 5
21985: PUSH
21986: LD_INT 70
21988: PUSH
21989: LD_INT 20
21991: PUSH
21992: EMPTY
21993: LIST
21994: LIST
21995: LIST
21996: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21997: LD_VAR 0 6
22001: PPUSH
22002: CALL_OW 264
22006: PUSH
22007: LD_INT 10
22009: PUSH
22010: EMPTY
22011: LIST
22012: IN
22013: IFFALSE 22034
// points := [ 35 , 110 , 70 ] ;
22015: LD_ADDR_VAR 0 9
22019: PUSH
22020: LD_INT 35
22022: PUSH
22023: LD_INT 110
22025: PUSH
22026: LD_INT 70
22028: PUSH
22029: EMPTY
22030: LIST
22031: LIST
22032: LIST
22033: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22034: LD_VAR 0 6
22038: PPUSH
22039: CALL_OW 265
22043: PUSH
22044: LD_INT 25
22046: EQUAL
22047: IFFALSE 22068
// points := [ 80 , 65 , 100 ] ;
22049: LD_ADDR_VAR 0 9
22053: PUSH
22054: LD_INT 80
22056: PUSH
22057: LD_INT 65
22059: PUSH
22060: LD_INT 100
22062: PUSH
22063: EMPTY
22064: LIST
22065: LIST
22066: LIST
22067: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22068: LD_VAR 0 6
22072: PPUSH
22073: CALL_OW 263
22077: PUSH
22078: LD_INT 1
22080: EQUAL
22081: IFFALSE 22116
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22083: LD_ADDR_VAR 0 10
22087: PUSH
22088: LD_VAR 0 10
22092: PUSH
22093: LD_VAR 0 6
22097: PPUSH
22098: CALL_OW 311
22102: PPUSH
22103: LD_INT 3
22105: PPUSH
22106: CALL_OW 259
22110: PUSH
22111: LD_INT 4
22113: MUL
22114: MUL
22115: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22116: LD_VAR 0 6
22120: PPUSH
22121: CALL_OW 263
22125: PUSH
22126: LD_INT 2
22128: EQUAL
22129: IFFALSE 22180
// begin j := IsControledBy ( i ) ;
22131: LD_ADDR_VAR 0 7
22135: PUSH
22136: LD_VAR 0 6
22140: PPUSH
22141: CALL_OW 312
22145: ST_TO_ADDR
// if j then
22146: LD_VAR 0 7
22150: IFFALSE 22180
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22152: LD_ADDR_VAR 0 10
22156: PUSH
22157: LD_VAR 0 10
22161: PUSH
22162: LD_VAR 0 7
22166: PPUSH
22167: LD_INT 3
22169: PPUSH
22170: CALL_OW 259
22174: PUSH
22175: LD_INT 3
22177: MUL
22178: MUL
22179: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22180: LD_VAR 0 6
22184: PPUSH
22185: CALL_OW 264
22189: PUSH
22190: LD_INT 5
22192: PUSH
22193: LD_INT 6
22195: PUSH
22196: LD_INT 46
22198: PUSH
22199: LD_INT 44
22201: PUSH
22202: LD_INT 47
22204: PUSH
22205: LD_INT 45
22207: PUSH
22208: LD_INT 28
22210: PUSH
22211: LD_INT 7
22213: PUSH
22214: LD_INT 27
22216: PUSH
22217: LD_INT 29
22219: PUSH
22220: EMPTY
22221: LIST
22222: LIST
22223: LIST
22224: LIST
22225: LIST
22226: LIST
22227: LIST
22228: LIST
22229: LIST
22230: LIST
22231: IN
22232: PUSH
22233: LD_VAR 0 1
22237: PPUSH
22238: LD_INT 52
22240: PPUSH
22241: CALL_OW 321
22245: PUSH
22246: LD_INT 2
22248: EQUAL
22249: AND
22250: IFFALSE 22267
// bpoints := bpoints * 1.2 ;
22252: LD_ADDR_VAR 0 10
22256: PUSH
22257: LD_VAR 0 10
22261: PUSH
22262: LD_REAL  1.20000000000000E+0000
22265: MUL
22266: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22267: LD_VAR 0 6
22271: PPUSH
22272: CALL_OW 264
22276: PUSH
22277: LD_INT 6
22279: PUSH
22280: LD_INT 46
22282: PUSH
22283: LD_INT 47
22285: PUSH
22286: EMPTY
22287: LIST
22288: LIST
22289: LIST
22290: IN
22291: IFFALSE 22308
// bpoints := bpoints * 1.2 ;
22293: LD_ADDR_VAR 0 10
22297: PUSH
22298: LD_VAR 0 10
22302: PUSH
22303: LD_REAL  1.20000000000000E+0000
22306: MUL
22307: ST_TO_ADDR
// end ; unit_building :
22308: GO 22322
22310: LD_INT 3
22312: DOUBLE
22313: EQUAL
22314: IFTRUE 22318
22316: GO 22321
22318: POP
// ; end ;
22319: GO 22322
22321: POP
// for j = 1 to 3 do
22322: LD_ADDR_VAR 0 7
22326: PUSH
22327: DOUBLE
22328: LD_INT 1
22330: DEC
22331: ST_TO_ADDR
22332: LD_INT 3
22334: PUSH
22335: FOR_TO
22336: IFFALSE 22389
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22338: LD_ADDR_VAR 0 5
22342: PUSH
22343: LD_VAR 0 5
22347: PPUSH
22348: LD_VAR 0 7
22352: PPUSH
22353: LD_VAR 0 5
22357: PUSH
22358: LD_VAR 0 7
22362: ARRAY
22363: PUSH
22364: LD_VAR 0 9
22368: PUSH
22369: LD_VAR 0 7
22373: ARRAY
22374: PUSH
22375: LD_VAR 0 10
22379: MUL
22380: PLUS
22381: PPUSH
22382: CALL_OW 1
22386: ST_TO_ADDR
22387: GO 22335
22389: POP
22390: POP
// end ;
22391: GO 20868
22393: POP
22394: POP
// result := Replace ( result , 4 , tmp ) ;
22395: LD_ADDR_VAR 0 5
22399: PUSH
22400: LD_VAR 0 5
22404: PPUSH
22405: LD_INT 4
22407: PPUSH
22408: LD_VAR 0 8
22412: PPUSH
22413: CALL_OW 1
22417: ST_TO_ADDR
// end ;
22418: LD_VAR 0 5
22422: RET
// export function DangerAtRange ( unit , range ) ; begin
22423: LD_INT 0
22425: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22426: LD_ADDR_VAR 0 3
22430: PUSH
22431: LD_VAR 0 1
22435: PPUSH
22436: CALL_OW 255
22440: PPUSH
22441: LD_VAR 0 1
22445: PPUSH
22446: CALL_OW 250
22450: PPUSH
22451: LD_VAR 0 1
22455: PPUSH
22456: CALL_OW 251
22460: PPUSH
22461: LD_VAR 0 2
22465: PPUSH
22466: CALL 20720 0 4
22470: ST_TO_ADDR
// end ;
22471: LD_VAR 0 3
22475: RET
// export function DangerInArea ( side , area ) ; begin
22476: LD_INT 0
22478: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22479: LD_ADDR_VAR 0 3
22483: PUSH
22484: LD_VAR 0 2
22488: PPUSH
22489: LD_INT 81
22491: PUSH
22492: LD_VAR 0 1
22496: PUSH
22497: EMPTY
22498: LIST
22499: LIST
22500: PPUSH
22501: CALL_OW 70
22505: ST_TO_ADDR
// end ;
22506: LD_VAR 0 3
22510: RET
// export function IsExtension ( b ) ; begin
22511: LD_INT 0
22513: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22514: LD_ADDR_VAR 0 2
22518: PUSH
22519: LD_VAR 0 1
22523: PUSH
22524: LD_INT 23
22526: PUSH
22527: LD_INT 20
22529: PUSH
22530: LD_INT 22
22532: PUSH
22533: LD_INT 17
22535: PUSH
22536: LD_INT 24
22538: PUSH
22539: LD_INT 21
22541: PUSH
22542: LD_INT 19
22544: PUSH
22545: LD_INT 16
22547: PUSH
22548: LD_INT 25
22550: PUSH
22551: LD_INT 18
22553: PUSH
22554: EMPTY
22555: LIST
22556: LIST
22557: LIST
22558: LIST
22559: LIST
22560: LIST
22561: LIST
22562: LIST
22563: LIST
22564: LIST
22565: IN
22566: ST_TO_ADDR
// end ;
22567: LD_VAR 0 2
22571: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22572: LD_INT 0
22574: PPUSH
22575: PPUSH
22576: PPUSH
// result := [ ] ;
22577: LD_ADDR_VAR 0 4
22581: PUSH
22582: EMPTY
22583: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22584: LD_ADDR_VAR 0 5
22588: PUSH
22589: LD_VAR 0 2
22593: PPUSH
22594: LD_INT 21
22596: PUSH
22597: LD_INT 3
22599: PUSH
22600: EMPTY
22601: LIST
22602: LIST
22603: PPUSH
22604: CALL_OW 70
22608: ST_TO_ADDR
// if not tmp then
22609: LD_VAR 0 5
22613: NOT
22614: IFFALSE 22618
// exit ;
22616: GO 22682
// if checkLink then
22618: LD_VAR 0 3
22622: IFFALSE 22672
// begin for i in tmp do
22624: LD_ADDR_VAR 0 6
22628: PUSH
22629: LD_VAR 0 5
22633: PUSH
22634: FOR_IN
22635: IFFALSE 22670
// if GetBase ( i ) <> base then
22637: LD_VAR 0 6
22641: PPUSH
22642: CALL_OW 274
22646: PUSH
22647: LD_VAR 0 1
22651: NONEQUAL
22652: IFFALSE 22668
// ComLinkToBase ( base , i ) ;
22654: LD_VAR 0 1
22658: PPUSH
22659: LD_VAR 0 6
22663: PPUSH
22664: CALL_OW 169
22668: GO 22634
22670: POP
22671: POP
// end ; result := tmp ;
22672: LD_ADDR_VAR 0 4
22676: PUSH
22677: LD_VAR 0 5
22681: ST_TO_ADDR
// end ;
22682: LD_VAR 0 4
22686: RET
// export function ComComplete ( units , b ) ; var i ; begin
22687: LD_INT 0
22689: PPUSH
22690: PPUSH
// if not units then
22691: LD_VAR 0 1
22695: NOT
22696: IFFALSE 22700
// exit ;
22698: GO 22790
// for i in units do
22700: LD_ADDR_VAR 0 4
22704: PUSH
22705: LD_VAR 0 1
22709: PUSH
22710: FOR_IN
22711: IFFALSE 22788
// if BuildingStatus ( b ) = bs_build then
22713: LD_VAR 0 2
22717: PPUSH
22718: CALL_OW 461
22722: PUSH
22723: LD_INT 1
22725: EQUAL
22726: IFFALSE 22786
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22728: LD_VAR 0 4
22732: PPUSH
22733: LD_STRING h
22735: PUSH
22736: LD_VAR 0 2
22740: PPUSH
22741: CALL_OW 250
22745: PUSH
22746: LD_VAR 0 2
22750: PPUSH
22751: CALL_OW 251
22755: PUSH
22756: LD_VAR 0 2
22760: PUSH
22761: LD_INT 0
22763: PUSH
22764: LD_INT 0
22766: PUSH
22767: LD_INT 0
22769: PUSH
22770: EMPTY
22771: LIST
22772: LIST
22773: LIST
22774: LIST
22775: LIST
22776: LIST
22777: LIST
22778: PUSH
22779: EMPTY
22780: LIST
22781: PPUSH
22782: CALL_OW 446
22786: GO 22710
22788: POP
22789: POP
// end ;
22790: LD_VAR 0 3
22794: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22795: LD_INT 0
22797: PPUSH
22798: PPUSH
22799: PPUSH
22800: PPUSH
22801: PPUSH
22802: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
22803: LD_VAR 0 1
22807: NOT
22808: PUSH
22809: LD_VAR 0 1
22813: PPUSH
22814: CALL_OW 263
22818: PUSH
22819: LD_INT 2
22821: NONEQUAL
22822: OR
22823: IFFALSE 22827
// exit ;
22825: GO 23143
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22827: LD_ADDR_VAR 0 6
22831: PUSH
22832: LD_INT 22
22834: PUSH
22835: LD_VAR 0 1
22839: PPUSH
22840: CALL_OW 255
22844: PUSH
22845: EMPTY
22846: LIST
22847: LIST
22848: PUSH
22849: LD_INT 2
22851: PUSH
22852: LD_INT 30
22854: PUSH
22855: LD_INT 36
22857: PUSH
22858: EMPTY
22859: LIST
22860: LIST
22861: PUSH
22862: LD_INT 34
22864: PUSH
22865: LD_INT 31
22867: PUSH
22868: EMPTY
22869: LIST
22870: LIST
22871: PUSH
22872: EMPTY
22873: LIST
22874: LIST
22875: LIST
22876: PUSH
22877: EMPTY
22878: LIST
22879: LIST
22880: PPUSH
22881: CALL_OW 69
22885: ST_TO_ADDR
// if not tmp then
22886: LD_VAR 0 6
22890: NOT
22891: IFFALSE 22895
// exit ;
22893: GO 23143
// result := [ ] ;
22895: LD_ADDR_VAR 0 2
22899: PUSH
22900: EMPTY
22901: ST_TO_ADDR
// for i in tmp do
22902: LD_ADDR_VAR 0 3
22906: PUSH
22907: LD_VAR 0 6
22911: PUSH
22912: FOR_IN
22913: IFFALSE 22984
// begin t := UnitsInside ( i ) ;
22915: LD_ADDR_VAR 0 4
22919: PUSH
22920: LD_VAR 0 3
22924: PPUSH
22925: CALL_OW 313
22929: ST_TO_ADDR
// if t then
22930: LD_VAR 0 4
22934: IFFALSE 22982
// for j in t do
22936: LD_ADDR_VAR 0 7
22940: PUSH
22941: LD_VAR 0 4
22945: PUSH
22946: FOR_IN
22947: IFFALSE 22980
// result := Replace ( result , result + 1 , j ) ;
22949: LD_ADDR_VAR 0 2
22953: PUSH
22954: LD_VAR 0 2
22958: PPUSH
22959: LD_VAR 0 2
22963: PUSH
22964: LD_INT 1
22966: PLUS
22967: PPUSH
22968: LD_VAR 0 7
22972: PPUSH
22973: CALL_OW 1
22977: ST_TO_ADDR
22978: GO 22946
22980: POP
22981: POP
// end ;
22982: GO 22912
22984: POP
22985: POP
// if not result then
22986: LD_VAR 0 2
22990: NOT
22991: IFFALSE 22995
// exit ;
22993: GO 23143
// mech := result [ 1 ] ;
22995: LD_ADDR_VAR 0 5
22999: PUSH
23000: LD_VAR 0 2
23004: PUSH
23005: LD_INT 1
23007: ARRAY
23008: ST_TO_ADDR
// if result > 1 then
23009: LD_VAR 0 2
23013: PUSH
23014: LD_INT 1
23016: GREATER
23017: IFFALSE 23129
// begin for i = 2 to result do
23019: LD_ADDR_VAR 0 3
23023: PUSH
23024: DOUBLE
23025: LD_INT 2
23027: DEC
23028: ST_TO_ADDR
23029: LD_VAR 0 2
23033: PUSH
23034: FOR_TO
23035: IFFALSE 23127
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23037: LD_ADDR_VAR 0 4
23041: PUSH
23042: LD_VAR 0 2
23046: PUSH
23047: LD_VAR 0 3
23051: ARRAY
23052: PPUSH
23053: LD_INT 3
23055: PPUSH
23056: CALL_OW 259
23060: PUSH
23061: LD_VAR 0 2
23065: PUSH
23066: LD_VAR 0 3
23070: ARRAY
23071: PPUSH
23072: CALL_OW 432
23076: MINUS
23077: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23078: LD_VAR 0 4
23082: PUSH
23083: LD_VAR 0 5
23087: PPUSH
23088: LD_INT 3
23090: PPUSH
23091: CALL_OW 259
23095: PUSH
23096: LD_VAR 0 5
23100: PPUSH
23101: CALL_OW 432
23105: MINUS
23106: GREATEREQUAL
23107: IFFALSE 23125
// mech := result [ i ] ;
23109: LD_ADDR_VAR 0 5
23113: PUSH
23114: LD_VAR 0 2
23118: PUSH
23119: LD_VAR 0 3
23123: ARRAY
23124: ST_TO_ADDR
// end ;
23125: GO 23034
23127: POP
23128: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23129: LD_VAR 0 1
23133: PPUSH
23134: LD_VAR 0 5
23138: PPUSH
23139: CALL_OW 135
// end ;
23143: LD_VAR 0 2
23147: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23148: LD_INT 0
23150: PPUSH
23151: PPUSH
23152: PPUSH
23153: PPUSH
23154: PPUSH
23155: PPUSH
23156: PPUSH
23157: PPUSH
23158: PPUSH
23159: PPUSH
23160: PPUSH
23161: PPUSH
23162: PPUSH
// result := [ ] ;
23163: LD_ADDR_VAR 0 7
23167: PUSH
23168: EMPTY
23169: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23170: LD_VAR 0 1
23174: PPUSH
23175: CALL_OW 266
23179: PUSH
23180: LD_INT 0
23182: PUSH
23183: LD_INT 1
23185: PUSH
23186: EMPTY
23187: LIST
23188: LIST
23189: IN
23190: NOT
23191: IFFALSE 23195
// exit ;
23193: GO 24829
// if name then
23195: LD_VAR 0 3
23199: IFFALSE 23215
// SetBName ( base_dep , name ) ;
23201: LD_VAR 0 1
23205: PPUSH
23206: LD_VAR 0 3
23210: PPUSH
23211: CALL_OW 500
// base := GetBase ( base_dep ) ;
23215: LD_ADDR_VAR 0 15
23219: PUSH
23220: LD_VAR 0 1
23224: PPUSH
23225: CALL_OW 274
23229: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23230: LD_ADDR_VAR 0 16
23234: PUSH
23235: LD_VAR 0 1
23239: PPUSH
23240: CALL_OW 255
23244: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23245: LD_ADDR_VAR 0 17
23249: PUSH
23250: LD_VAR 0 1
23254: PPUSH
23255: CALL_OW 248
23259: ST_TO_ADDR
// if sources then
23260: LD_VAR 0 5
23264: IFFALSE 23311
// for i = 1 to 3 do
23266: LD_ADDR_VAR 0 8
23270: PUSH
23271: DOUBLE
23272: LD_INT 1
23274: DEC
23275: ST_TO_ADDR
23276: LD_INT 3
23278: PUSH
23279: FOR_TO
23280: IFFALSE 23309
// AddResourceType ( base , i , sources [ i ] ) ;
23282: LD_VAR 0 15
23286: PPUSH
23287: LD_VAR 0 8
23291: PPUSH
23292: LD_VAR 0 5
23296: PUSH
23297: LD_VAR 0 8
23301: ARRAY
23302: PPUSH
23303: CALL_OW 276
23307: GO 23279
23309: POP
23310: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23311: LD_ADDR_VAR 0 18
23315: PUSH
23316: LD_VAR 0 15
23320: PPUSH
23321: LD_VAR 0 2
23325: PPUSH
23326: LD_INT 1
23328: PPUSH
23329: CALL 22572 0 3
23333: ST_TO_ADDR
// InitHc ;
23334: CALL_OW 19
// InitUc ;
23338: CALL_OW 18
// uc_side := side ;
23342: LD_ADDR_OWVAR 20
23346: PUSH
23347: LD_VAR 0 16
23351: ST_TO_ADDR
// uc_nation := nation ;
23352: LD_ADDR_OWVAR 21
23356: PUSH
23357: LD_VAR 0 17
23361: ST_TO_ADDR
// if buildings then
23362: LD_VAR 0 18
23366: IFFALSE 24688
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23368: LD_ADDR_VAR 0 19
23372: PUSH
23373: LD_VAR 0 18
23377: PPUSH
23378: LD_INT 2
23380: PUSH
23381: LD_INT 30
23383: PUSH
23384: LD_INT 29
23386: PUSH
23387: EMPTY
23388: LIST
23389: LIST
23390: PUSH
23391: LD_INT 30
23393: PUSH
23394: LD_INT 30
23396: PUSH
23397: EMPTY
23398: LIST
23399: LIST
23400: PUSH
23401: EMPTY
23402: LIST
23403: LIST
23404: LIST
23405: PPUSH
23406: CALL_OW 72
23410: ST_TO_ADDR
// if tmp then
23411: LD_VAR 0 19
23415: IFFALSE 23463
// for i in tmp do
23417: LD_ADDR_VAR 0 8
23421: PUSH
23422: LD_VAR 0 19
23426: PUSH
23427: FOR_IN
23428: IFFALSE 23461
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23430: LD_VAR 0 8
23434: PPUSH
23435: CALL_OW 250
23439: PPUSH
23440: LD_VAR 0 8
23444: PPUSH
23445: CALL_OW 251
23449: PPUSH
23450: LD_VAR 0 16
23454: PPUSH
23455: CALL_OW 441
23459: GO 23427
23461: POP
23462: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23463: LD_VAR 0 18
23467: PPUSH
23468: LD_INT 2
23470: PUSH
23471: LD_INT 30
23473: PUSH
23474: LD_INT 32
23476: PUSH
23477: EMPTY
23478: LIST
23479: LIST
23480: PUSH
23481: LD_INT 30
23483: PUSH
23484: LD_INT 33
23486: PUSH
23487: EMPTY
23488: LIST
23489: LIST
23490: PUSH
23491: EMPTY
23492: LIST
23493: LIST
23494: LIST
23495: PPUSH
23496: CALL_OW 72
23500: IFFALSE 23588
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23502: LD_ADDR_VAR 0 8
23506: PUSH
23507: LD_VAR 0 18
23511: PPUSH
23512: LD_INT 2
23514: PUSH
23515: LD_INT 30
23517: PUSH
23518: LD_INT 32
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: PUSH
23525: LD_INT 30
23527: PUSH
23528: LD_INT 33
23530: PUSH
23531: EMPTY
23532: LIST
23533: LIST
23534: PUSH
23535: EMPTY
23536: LIST
23537: LIST
23538: LIST
23539: PPUSH
23540: CALL_OW 72
23544: PUSH
23545: FOR_IN
23546: IFFALSE 23586
// begin if not GetBWeapon ( i ) then
23548: LD_VAR 0 8
23552: PPUSH
23553: CALL_OW 269
23557: NOT
23558: IFFALSE 23584
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23560: LD_VAR 0 8
23564: PPUSH
23565: LD_VAR 0 8
23569: PPUSH
23570: LD_VAR 0 2
23574: PPUSH
23575: CALL 24834 0 2
23579: PPUSH
23580: CALL_OW 431
// end ;
23584: GO 23545
23586: POP
23587: POP
// end ; for i = 1 to personel do
23588: LD_ADDR_VAR 0 8
23592: PUSH
23593: DOUBLE
23594: LD_INT 1
23596: DEC
23597: ST_TO_ADDR
23598: LD_VAR 0 6
23602: PUSH
23603: FOR_TO
23604: IFFALSE 24668
// begin if i > 4 then
23606: LD_VAR 0 8
23610: PUSH
23611: LD_INT 4
23613: GREATER
23614: IFFALSE 23618
// break ;
23616: GO 24668
// case i of 1 :
23618: LD_VAR 0 8
23622: PUSH
23623: LD_INT 1
23625: DOUBLE
23626: EQUAL
23627: IFTRUE 23631
23629: GO 23711
23631: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23632: LD_ADDR_VAR 0 12
23636: PUSH
23637: LD_VAR 0 18
23641: PPUSH
23642: LD_INT 22
23644: PUSH
23645: LD_VAR 0 16
23649: PUSH
23650: EMPTY
23651: LIST
23652: LIST
23653: PUSH
23654: LD_INT 58
23656: PUSH
23657: EMPTY
23658: LIST
23659: PUSH
23660: LD_INT 2
23662: PUSH
23663: LD_INT 30
23665: PUSH
23666: LD_INT 32
23668: PUSH
23669: EMPTY
23670: LIST
23671: LIST
23672: PUSH
23673: LD_INT 30
23675: PUSH
23676: LD_INT 4
23678: PUSH
23679: EMPTY
23680: LIST
23681: LIST
23682: PUSH
23683: LD_INT 30
23685: PUSH
23686: LD_INT 5
23688: PUSH
23689: EMPTY
23690: LIST
23691: LIST
23692: PUSH
23693: EMPTY
23694: LIST
23695: LIST
23696: LIST
23697: LIST
23698: PUSH
23699: EMPTY
23700: LIST
23701: LIST
23702: LIST
23703: PPUSH
23704: CALL_OW 72
23708: ST_TO_ADDR
23709: GO 23933
23711: LD_INT 2
23713: DOUBLE
23714: EQUAL
23715: IFTRUE 23719
23717: GO 23781
23719: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23720: LD_ADDR_VAR 0 12
23724: PUSH
23725: LD_VAR 0 18
23729: PPUSH
23730: LD_INT 22
23732: PUSH
23733: LD_VAR 0 16
23737: PUSH
23738: EMPTY
23739: LIST
23740: LIST
23741: PUSH
23742: LD_INT 2
23744: PUSH
23745: LD_INT 30
23747: PUSH
23748: LD_INT 0
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: PUSH
23755: LD_INT 30
23757: PUSH
23758: LD_INT 1
23760: PUSH
23761: EMPTY
23762: LIST
23763: LIST
23764: PUSH
23765: EMPTY
23766: LIST
23767: LIST
23768: LIST
23769: PUSH
23770: EMPTY
23771: LIST
23772: LIST
23773: PPUSH
23774: CALL_OW 72
23778: ST_TO_ADDR
23779: GO 23933
23781: LD_INT 3
23783: DOUBLE
23784: EQUAL
23785: IFTRUE 23789
23787: GO 23851
23789: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23790: LD_ADDR_VAR 0 12
23794: PUSH
23795: LD_VAR 0 18
23799: PPUSH
23800: LD_INT 22
23802: PUSH
23803: LD_VAR 0 16
23807: PUSH
23808: EMPTY
23809: LIST
23810: LIST
23811: PUSH
23812: LD_INT 2
23814: PUSH
23815: LD_INT 30
23817: PUSH
23818: LD_INT 2
23820: PUSH
23821: EMPTY
23822: LIST
23823: LIST
23824: PUSH
23825: LD_INT 30
23827: PUSH
23828: LD_INT 3
23830: PUSH
23831: EMPTY
23832: LIST
23833: LIST
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: LIST
23839: PUSH
23840: EMPTY
23841: LIST
23842: LIST
23843: PPUSH
23844: CALL_OW 72
23848: ST_TO_ADDR
23849: GO 23933
23851: LD_INT 4
23853: DOUBLE
23854: EQUAL
23855: IFTRUE 23859
23857: GO 23932
23859: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23860: LD_ADDR_VAR 0 12
23864: PUSH
23865: LD_VAR 0 18
23869: PPUSH
23870: LD_INT 22
23872: PUSH
23873: LD_VAR 0 16
23877: PUSH
23878: EMPTY
23879: LIST
23880: LIST
23881: PUSH
23882: LD_INT 2
23884: PUSH
23885: LD_INT 30
23887: PUSH
23888: LD_INT 6
23890: PUSH
23891: EMPTY
23892: LIST
23893: LIST
23894: PUSH
23895: LD_INT 30
23897: PUSH
23898: LD_INT 7
23900: PUSH
23901: EMPTY
23902: LIST
23903: LIST
23904: PUSH
23905: LD_INT 30
23907: PUSH
23908: LD_INT 8
23910: PUSH
23911: EMPTY
23912: LIST
23913: LIST
23914: PUSH
23915: EMPTY
23916: LIST
23917: LIST
23918: LIST
23919: LIST
23920: PUSH
23921: EMPTY
23922: LIST
23923: LIST
23924: PPUSH
23925: CALL_OW 72
23929: ST_TO_ADDR
23930: GO 23933
23932: POP
// if i = 1 then
23933: LD_VAR 0 8
23937: PUSH
23938: LD_INT 1
23940: EQUAL
23941: IFFALSE 24052
// begin tmp := [ ] ;
23943: LD_ADDR_VAR 0 19
23947: PUSH
23948: EMPTY
23949: ST_TO_ADDR
// for j in f do
23950: LD_ADDR_VAR 0 9
23954: PUSH
23955: LD_VAR 0 12
23959: PUSH
23960: FOR_IN
23961: IFFALSE 24034
// if GetBType ( j ) = b_bunker then
23963: LD_VAR 0 9
23967: PPUSH
23968: CALL_OW 266
23972: PUSH
23973: LD_INT 32
23975: EQUAL
23976: IFFALSE 24003
// tmp := Insert ( tmp , 1 , j ) else
23978: LD_ADDR_VAR 0 19
23982: PUSH
23983: LD_VAR 0 19
23987: PPUSH
23988: LD_INT 1
23990: PPUSH
23991: LD_VAR 0 9
23995: PPUSH
23996: CALL_OW 2
24000: ST_TO_ADDR
24001: GO 24032
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24003: LD_ADDR_VAR 0 19
24007: PUSH
24008: LD_VAR 0 19
24012: PPUSH
24013: LD_VAR 0 19
24017: PUSH
24018: LD_INT 1
24020: PLUS
24021: PPUSH
24022: LD_VAR 0 9
24026: PPUSH
24027: CALL_OW 2
24031: ST_TO_ADDR
24032: GO 23960
24034: POP
24035: POP
// if tmp then
24036: LD_VAR 0 19
24040: IFFALSE 24052
// f := tmp ;
24042: LD_ADDR_VAR 0 12
24046: PUSH
24047: LD_VAR 0 19
24051: ST_TO_ADDR
// end ; x := personel [ i ] ;
24052: LD_ADDR_VAR 0 13
24056: PUSH
24057: LD_VAR 0 6
24061: PUSH
24062: LD_VAR 0 8
24066: ARRAY
24067: ST_TO_ADDR
// if x = - 1 then
24068: LD_VAR 0 13
24072: PUSH
24073: LD_INT 1
24075: NEG
24076: EQUAL
24077: IFFALSE 24286
// begin for j in f do
24079: LD_ADDR_VAR 0 9
24083: PUSH
24084: LD_VAR 0 12
24088: PUSH
24089: FOR_IN
24090: IFFALSE 24282
// repeat InitHc ;
24092: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24096: LD_VAR 0 9
24100: PPUSH
24101: CALL_OW 266
24105: PUSH
24106: LD_INT 5
24108: EQUAL
24109: IFFALSE 24179
// begin if UnitsInside ( j ) < 3 then
24111: LD_VAR 0 9
24115: PPUSH
24116: CALL_OW 313
24120: PUSH
24121: LD_INT 3
24123: LESS
24124: IFFALSE 24160
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24126: LD_INT 0
24128: PPUSH
24129: LD_INT 5
24131: PUSH
24132: LD_INT 8
24134: PUSH
24135: LD_INT 9
24137: PUSH
24138: EMPTY
24139: LIST
24140: LIST
24141: LIST
24142: PUSH
24143: LD_VAR 0 17
24147: ARRAY
24148: PPUSH
24149: LD_VAR 0 4
24153: PPUSH
24154: CALL_OW 380
24158: GO 24177
// PrepareHuman ( false , i , skill ) ;
24160: LD_INT 0
24162: PPUSH
24163: LD_VAR 0 8
24167: PPUSH
24168: LD_VAR 0 4
24172: PPUSH
24173: CALL_OW 380
// end else
24177: GO 24196
// PrepareHuman ( false , i , skill ) ;
24179: LD_INT 0
24181: PPUSH
24182: LD_VAR 0 8
24186: PPUSH
24187: LD_VAR 0 4
24191: PPUSH
24192: CALL_OW 380
// un := CreateHuman ;
24196: LD_ADDR_VAR 0 14
24200: PUSH
24201: CALL_OW 44
24205: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24206: LD_ADDR_VAR 0 7
24210: PUSH
24211: LD_VAR 0 7
24215: PPUSH
24216: LD_INT 1
24218: PPUSH
24219: LD_VAR 0 14
24223: PPUSH
24224: CALL_OW 2
24228: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24229: LD_VAR 0 14
24233: PPUSH
24234: LD_VAR 0 9
24238: PPUSH
24239: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24243: LD_VAR 0 9
24247: PPUSH
24248: CALL_OW 313
24252: PUSH
24253: LD_INT 6
24255: EQUAL
24256: PUSH
24257: LD_VAR 0 9
24261: PPUSH
24262: CALL_OW 266
24266: PUSH
24267: LD_INT 32
24269: PUSH
24270: LD_INT 31
24272: PUSH
24273: EMPTY
24274: LIST
24275: LIST
24276: IN
24277: OR
24278: IFFALSE 24092
24280: GO 24089
24282: POP
24283: POP
// end else
24284: GO 24666
// for j = 1 to x do
24286: LD_ADDR_VAR 0 9
24290: PUSH
24291: DOUBLE
24292: LD_INT 1
24294: DEC
24295: ST_TO_ADDR
24296: LD_VAR 0 13
24300: PUSH
24301: FOR_TO
24302: IFFALSE 24664
// begin InitHc ;
24304: CALL_OW 19
// if not f then
24308: LD_VAR 0 12
24312: NOT
24313: IFFALSE 24402
// begin PrepareHuman ( false , i , skill ) ;
24315: LD_INT 0
24317: PPUSH
24318: LD_VAR 0 8
24322: PPUSH
24323: LD_VAR 0 4
24327: PPUSH
24328: CALL_OW 380
// un := CreateHuman ;
24332: LD_ADDR_VAR 0 14
24336: PUSH
24337: CALL_OW 44
24341: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24342: LD_ADDR_VAR 0 7
24346: PUSH
24347: LD_VAR 0 7
24351: PPUSH
24352: LD_INT 1
24354: PPUSH
24355: LD_VAR 0 14
24359: PPUSH
24360: CALL_OW 2
24364: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24365: LD_VAR 0 14
24369: PPUSH
24370: LD_VAR 0 1
24374: PPUSH
24375: CALL_OW 250
24379: PPUSH
24380: LD_VAR 0 1
24384: PPUSH
24385: CALL_OW 251
24389: PPUSH
24390: LD_INT 10
24392: PPUSH
24393: LD_INT 0
24395: PPUSH
24396: CALL_OW 50
// continue ;
24400: GO 24301
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24402: LD_VAR 0 12
24406: PUSH
24407: LD_INT 1
24409: ARRAY
24410: PPUSH
24411: CALL_OW 313
24415: PUSH
24416: LD_VAR 0 12
24420: PUSH
24421: LD_INT 1
24423: ARRAY
24424: PPUSH
24425: CALL_OW 266
24429: PUSH
24430: LD_INT 32
24432: PUSH
24433: LD_INT 31
24435: PUSH
24436: EMPTY
24437: LIST
24438: LIST
24439: IN
24440: AND
24441: PUSH
24442: LD_VAR 0 12
24446: PUSH
24447: LD_INT 1
24449: ARRAY
24450: PPUSH
24451: CALL_OW 313
24455: PUSH
24456: LD_INT 6
24458: EQUAL
24459: OR
24460: IFFALSE 24480
// f := Delete ( f , 1 ) ;
24462: LD_ADDR_VAR 0 12
24466: PUSH
24467: LD_VAR 0 12
24471: PPUSH
24472: LD_INT 1
24474: PPUSH
24475: CALL_OW 3
24479: ST_TO_ADDR
// if not f then
24480: LD_VAR 0 12
24484: NOT
24485: IFFALSE 24503
// begin x := x + 2 ;
24487: LD_ADDR_VAR 0 13
24491: PUSH
24492: LD_VAR 0 13
24496: PUSH
24497: LD_INT 2
24499: PLUS
24500: ST_TO_ADDR
// continue ;
24501: GO 24301
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24503: LD_VAR 0 12
24507: PUSH
24508: LD_INT 1
24510: ARRAY
24511: PPUSH
24512: CALL_OW 266
24516: PUSH
24517: LD_INT 5
24519: EQUAL
24520: IFFALSE 24594
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24522: LD_VAR 0 12
24526: PUSH
24527: LD_INT 1
24529: ARRAY
24530: PPUSH
24531: CALL_OW 313
24535: PUSH
24536: LD_INT 3
24538: LESS
24539: IFFALSE 24575
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24541: LD_INT 0
24543: PPUSH
24544: LD_INT 5
24546: PUSH
24547: LD_INT 8
24549: PUSH
24550: LD_INT 9
24552: PUSH
24553: EMPTY
24554: LIST
24555: LIST
24556: LIST
24557: PUSH
24558: LD_VAR 0 17
24562: ARRAY
24563: PPUSH
24564: LD_VAR 0 4
24568: PPUSH
24569: CALL_OW 380
24573: GO 24592
// PrepareHuman ( false , i , skill ) ;
24575: LD_INT 0
24577: PPUSH
24578: LD_VAR 0 8
24582: PPUSH
24583: LD_VAR 0 4
24587: PPUSH
24588: CALL_OW 380
// end else
24592: GO 24611
// PrepareHuman ( false , i , skill ) ;
24594: LD_INT 0
24596: PPUSH
24597: LD_VAR 0 8
24601: PPUSH
24602: LD_VAR 0 4
24606: PPUSH
24607: CALL_OW 380
// un := CreateHuman ;
24611: LD_ADDR_VAR 0 14
24615: PUSH
24616: CALL_OW 44
24620: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24621: LD_ADDR_VAR 0 7
24625: PUSH
24626: LD_VAR 0 7
24630: PPUSH
24631: LD_INT 1
24633: PPUSH
24634: LD_VAR 0 14
24638: PPUSH
24639: CALL_OW 2
24643: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24644: LD_VAR 0 14
24648: PPUSH
24649: LD_VAR 0 12
24653: PUSH
24654: LD_INT 1
24656: ARRAY
24657: PPUSH
24658: CALL_OW 52
// end ;
24662: GO 24301
24664: POP
24665: POP
// end ;
24666: GO 23603
24668: POP
24669: POP
// result := result ^ buildings ;
24670: LD_ADDR_VAR 0 7
24674: PUSH
24675: LD_VAR 0 7
24679: PUSH
24680: LD_VAR 0 18
24684: ADD
24685: ST_TO_ADDR
// end else
24686: GO 24829
// begin for i = 1 to personel do
24688: LD_ADDR_VAR 0 8
24692: PUSH
24693: DOUBLE
24694: LD_INT 1
24696: DEC
24697: ST_TO_ADDR
24698: LD_VAR 0 6
24702: PUSH
24703: FOR_TO
24704: IFFALSE 24827
// begin if i > 4 then
24706: LD_VAR 0 8
24710: PUSH
24711: LD_INT 4
24713: GREATER
24714: IFFALSE 24718
// break ;
24716: GO 24827
// x := personel [ i ] ;
24718: LD_ADDR_VAR 0 13
24722: PUSH
24723: LD_VAR 0 6
24727: PUSH
24728: LD_VAR 0 8
24732: ARRAY
24733: ST_TO_ADDR
// if x = - 1 then
24734: LD_VAR 0 13
24738: PUSH
24739: LD_INT 1
24741: NEG
24742: EQUAL
24743: IFFALSE 24747
// continue ;
24745: GO 24703
// PrepareHuman ( false , i , skill ) ;
24747: LD_INT 0
24749: PPUSH
24750: LD_VAR 0 8
24754: PPUSH
24755: LD_VAR 0 4
24759: PPUSH
24760: CALL_OW 380
// un := CreateHuman ;
24764: LD_ADDR_VAR 0 14
24768: PUSH
24769: CALL_OW 44
24773: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24774: LD_VAR 0 14
24778: PPUSH
24779: LD_VAR 0 1
24783: PPUSH
24784: CALL_OW 250
24788: PPUSH
24789: LD_VAR 0 1
24793: PPUSH
24794: CALL_OW 251
24798: PPUSH
24799: LD_INT 10
24801: PPUSH
24802: LD_INT 0
24804: PPUSH
24805: CALL_OW 50
// result := result ^ un ;
24809: LD_ADDR_VAR 0 7
24813: PUSH
24814: LD_VAR 0 7
24818: PUSH
24819: LD_VAR 0 14
24823: ADD
24824: ST_TO_ADDR
// end ;
24825: GO 24703
24827: POP
24828: POP
// end ; end ;
24829: LD_VAR 0 7
24833: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24834: LD_INT 0
24836: PPUSH
24837: PPUSH
24838: PPUSH
24839: PPUSH
24840: PPUSH
24841: PPUSH
24842: PPUSH
24843: PPUSH
24844: PPUSH
24845: PPUSH
24846: PPUSH
24847: PPUSH
24848: PPUSH
24849: PPUSH
24850: PPUSH
24851: PPUSH
// result := false ;
24852: LD_ADDR_VAR 0 3
24856: PUSH
24857: LD_INT 0
24859: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24860: LD_VAR 0 1
24864: NOT
24865: PUSH
24866: LD_VAR 0 1
24870: PPUSH
24871: CALL_OW 266
24875: PUSH
24876: LD_INT 32
24878: PUSH
24879: LD_INT 33
24881: PUSH
24882: EMPTY
24883: LIST
24884: LIST
24885: IN
24886: NOT
24887: OR
24888: IFFALSE 24892
// exit ;
24890: GO 26001
// nat := GetNation ( tower ) ;
24892: LD_ADDR_VAR 0 12
24896: PUSH
24897: LD_VAR 0 1
24901: PPUSH
24902: CALL_OW 248
24906: ST_TO_ADDR
// side := GetSide ( tower ) ;
24907: LD_ADDR_VAR 0 16
24911: PUSH
24912: LD_VAR 0 1
24916: PPUSH
24917: CALL_OW 255
24921: ST_TO_ADDR
// x := GetX ( tower ) ;
24922: LD_ADDR_VAR 0 10
24926: PUSH
24927: LD_VAR 0 1
24931: PPUSH
24932: CALL_OW 250
24936: ST_TO_ADDR
// y := GetY ( tower ) ;
24937: LD_ADDR_VAR 0 11
24941: PUSH
24942: LD_VAR 0 1
24946: PPUSH
24947: CALL_OW 251
24951: ST_TO_ADDR
// if not x or not y then
24952: LD_VAR 0 10
24956: NOT
24957: PUSH
24958: LD_VAR 0 11
24962: NOT
24963: OR
24964: IFFALSE 24968
// exit ;
24966: GO 26001
// weapon := 0 ;
24968: LD_ADDR_VAR 0 18
24972: PUSH
24973: LD_INT 0
24975: ST_TO_ADDR
// fac_list := [ ] ;
24976: LD_ADDR_VAR 0 17
24980: PUSH
24981: EMPTY
24982: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
24983: LD_ADDR_VAR 0 6
24987: PUSH
24988: LD_VAR 0 1
24992: PPUSH
24993: CALL_OW 274
24997: PPUSH
24998: LD_VAR 0 2
25002: PPUSH
25003: LD_INT 0
25005: PPUSH
25006: CALL 22572 0 3
25010: PPUSH
25011: LD_INT 30
25013: PUSH
25014: LD_INT 3
25016: PUSH
25017: EMPTY
25018: LIST
25019: LIST
25020: PPUSH
25021: CALL_OW 72
25025: ST_TO_ADDR
// if not factories then
25026: LD_VAR 0 6
25030: NOT
25031: IFFALSE 25035
// exit ;
25033: GO 26001
// for i in factories do
25035: LD_ADDR_VAR 0 8
25039: PUSH
25040: LD_VAR 0 6
25044: PUSH
25045: FOR_IN
25046: IFFALSE 25071
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25048: LD_ADDR_VAR 0 17
25052: PUSH
25053: LD_VAR 0 17
25057: PUSH
25058: LD_VAR 0 8
25062: PPUSH
25063: CALL_OW 478
25067: UNION
25068: ST_TO_ADDR
25069: GO 25045
25071: POP
25072: POP
// if not fac_list then
25073: LD_VAR 0 17
25077: NOT
25078: IFFALSE 25082
// exit ;
25080: GO 26001
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25082: LD_ADDR_VAR 0 5
25086: PUSH
25087: LD_INT 4
25089: PUSH
25090: LD_INT 5
25092: PUSH
25093: LD_INT 9
25095: PUSH
25096: LD_INT 10
25098: PUSH
25099: LD_INT 6
25101: PUSH
25102: LD_INT 7
25104: PUSH
25105: LD_INT 11
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: LIST
25112: LIST
25113: LIST
25114: LIST
25115: LIST
25116: PUSH
25117: LD_INT 27
25119: PUSH
25120: LD_INT 28
25122: PUSH
25123: LD_INT 26
25125: PUSH
25126: LD_INT 30
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: LIST
25133: LIST
25134: PUSH
25135: LD_INT 43
25137: PUSH
25138: LD_INT 44
25140: PUSH
25141: LD_INT 46
25143: PUSH
25144: LD_INT 45
25146: PUSH
25147: LD_INT 47
25149: PUSH
25150: LD_INT 49
25152: PUSH
25153: EMPTY
25154: LIST
25155: LIST
25156: LIST
25157: LIST
25158: LIST
25159: LIST
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: LIST
25165: PUSH
25166: LD_VAR 0 12
25170: ARRAY
25171: ST_TO_ADDR
// list := list isect fac_list ;
25172: LD_ADDR_VAR 0 5
25176: PUSH
25177: LD_VAR 0 5
25181: PUSH
25182: LD_VAR 0 17
25186: ISECT
25187: ST_TO_ADDR
// if not list then
25188: LD_VAR 0 5
25192: NOT
25193: IFFALSE 25197
// exit ;
25195: GO 26001
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25197: LD_VAR 0 12
25201: PUSH
25202: LD_INT 3
25204: EQUAL
25205: PUSH
25206: LD_INT 49
25208: PUSH
25209: LD_VAR 0 5
25213: IN
25214: AND
25215: PUSH
25216: LD_INT 31
25218: PPUSH
25219: LD_VAR 0 16
25223: PPUSH
25224: CALL_OW 321
25228: PUSH
25229: LD_INT 2
25231: EQUAL
25232: AND
25233: IFFALSE 25293
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25235: LD_INT 22
25237: PUSH
25238: LD_VAR 0 16
25242: PUSH
25243: EMPTY
25244: LIST
25245: LIST
25246: PUSH
25247: LD_INT 35
25249: PUSH
25250: LD_INT 49
25252: PUSH
25253: EMPTY
25254: LIST
25255: LIST
25256: PUSH
25257: LD_INT 91
25259: PUSH
25260: LD_VAR 0 1
25264: PUSH
25265: LD_INT 10
25267: PUSH
25268: EMPTY
25269: LIST
25270: LIST
25271: LIST
25272: PUSH
25273: EMPTY
25274: LIST
25275: LIST
25276: LIST
25277: PPUSH
25278: CALL_OW 69
25282: NOT
25283: IFFALSE 25293
// weapon := ru_time_lapser ;
25285: LD_ADDR_VAR 0 18
25289: PUSH
25290: LD_INT 49
25292: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25293: LD_VAR 0 12
25297: PUSH
25298: LD_INT 1
25300: PUSH
25301: LD_INT 2
25303: PUSH
25304: EMPTY
25305: LIST
25306: LIST
25307: IN
25308: PUSH
25309: LD_INT 11
25311: PUSH
25312: LD_VAR 0 5
25316: IN
25317: PUSH
25318: LD_INT 30
25320: PUSH
25321: LD_VAR 0 5
25325: IN
25326: OR
25327: AND
25328: PUSH
25329: LD_INT 6
25331: PPUSH
25332: LD_VAR 0 16
25336: PPUSH
25337: CALL_OW 321
25341: PUSH
25342: LD_INT 2
25344: EQUAL
25345: AND
25346: IFFALSE 25511
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25348: LD_INT 22
25350: PUSH
25351: LD_VAR 0 16
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: PUSH
25360: LD_INT 2
25362: PUSH
25363: LD_INT 35
25365: PUSH
25366: LD_INT 11
25368: PUSH
25369: EMPTY
25370: LIST
25371: LIST
25372: PUSH
25373: LD_INT 35
25375: PUSH
25376: LD_INT 30
25378: PUSH
25379: EMPTY
25380: LIST
25381: LIST
25382: PUSH
25383: EMPTY
25384: LIST
25385: LIST
25386: LIST
25387: PUSH
25388: LD_INT 91
25390: PUSH
25391: LD_VAR 0 1
25395: PUSH
25396: LD_INT 18
25398: PUSH
25399: EMPTY
25400: LIST
25401: LIST
25402: LIST
25403: PUSH
25404: EMPTY
25405: LIST
25406: LIST
25407: LIST
25408: PPUSH
25409: CALL_OW 69
25413: NOT
25414: PUSH
25415: LD_INT 22
25417: PUSH
25418: LD_VAR 0 16
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: LD_INT 2
25429: PUSH
25430: LD_INT 30
25432: PUSH
25433: LD_INT 32
25435: PUSH
25436: EMPTY
25437: LIST
25438: LIST
25439: PUSH
25440: LD_INT 30
25442: PUSH
25443: LD_INT 33
25445: PUSH
25446: EMPTY
25447: LIST
25448: LIST
25449: PUSH
25450: EMPTY
25451: LIST
25452: LIST
25453: LIST
25454: PUSH
25455: LD_INT 91
25457: PUSH
25458: LD_VAR 0 1
25462: PUSH
25463: LD_INT 12
25465: PUSH
25466: EMPTY
25467: LIST
25468: LIST
25469: LIST
25470: PUSH
25471: EMPTY
25472: LIST
25473: LIST
25474: LIST
25475: PUSH
25476: EMPTY
25477: LIST
25478: PPUSH
25479: CALL_OW 69
25483: PUSH
25484: LD_INT 2
25486: GREATER
25487: AND
25488: IFFALSE 25511
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25490: LD_ADDR_VAR 0 18
25494: PUSH
25495: LD_INT 11
25497: PUSH
25498: LD_INT 30
25500: PUSH
25501: EMPTY
25502: LIST
25503: LIST
25504: PUSH
25505: LD_VAR 0 12
25509: ARRAY
25510: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25511: LD_VAR 0 18
25515: NOT
25516: PUSH
25517: LD_INT 40
25519: PPUSH
25520: LD_VAR 0 16
25524: PPUSH
25525: CALL_OW 321
25529: PUSH
25530: LD_INT 2
25532: EQUAL
25533: AND
25534: PUSH
25535: LD_INT 7
25537: PUSH
25538: LD_VAR 0 5
25542: IN
25543: PUSH
25544: LD_INT 28
25546: PUSH
25547: LD_VAR 0 5
25551: IN
25552: OR
25553: PUSH
25554: LD_INT 45
25556: PUSH
25557: LD_VAR 0 5
25561: IN
25562: OR
25563: AND
25564: IFFALSE 25818
// begin hex := GetHexInfo ( x , y ) ;
25566: LD_ADDR_VAR 0 4
25570: PUSH
25571: LD_VAR 0 10
25575: PPUSH
25576: LD_VAR 0 11
25580: PPUSH
25581: CALL_OW 546
25585: ST_TO_ADDR
// if hex [ 1 ] then
25586: LD_VAR 0 4
25590: PUSH
25591: LD_INT 1
25593: ARRAY
25594: IFFALSE 25598
// exit ;
25596: GO 26001
// height := hex [ 2 ] ;
25598: LD_ADDR_VAR 0 15
25602: PUSH
25603: LD_VAR 0 4
25607: PUSH
25608: LD_INT 2
25610: ARRAY
25611: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25612: LD_ADDR_VAR 0 14
25616: PUSH
25617: LD_INT 0
25619: PUSH
25620: LD_INT 2
25622: PUSH
25623: LD_INT 3
25625: PUSH
25626: LD_INT 5
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: LIST
25633: LIST
25634: ST_TO_ADDR
// for i in tmp do
25635: LD_ADDR_VAR 0 8
25639: PUSH
25640: LD_VAR 0 14
25644: PUSH
25645: FOR_IN
25646: IFFALSE 25816
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25648: LD_ADDR_VAR 0 9
25652: PUSH
25653: LD_VAR 0 10
25657: PPUSH
25658: LD_VAR 0 8
25662: PPUSH
25663: LD_INT 5
25665: PPUSH
25666: CALL_OW 272
25670: PUSH
25671: LD_VAR 0 11
25675: PPUSH
25676: LD_VAR 0 8
25680: PPUSH
25681: LD_INT 5
25683: PPUSH
25684: CALL_OW 273
25688: PUSH
25689: EMPTY
25690: LIST
25691: LIST
25692: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25693: LD_VAR 0 9
25697: PUSH
25698: LD_INT 1
25700: ARRAY
25701: PPUSH
25702: LD_VAR 0 9
25706: PUSH
25707: LD_INT 2
25709: ARRAY
25710: PPUSH
25711: CALL_OW 488
25715: IFFALSE 25814
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25717: LD_ADDR_VAR 0 4
25721: PUSH
25722: LD_VAR 0 9
25726: PUSH
25727: LD_INT 1
25729: ARRAY
25730: PPUSH
25731: LD_VAR 0 9
25735: PUSH
25736: LD_INT 2
25738: ARRAY
25739: PPUSH
25740: CALL_OW 546
25744: ST_TO_ADDR
// if hex [ 1 ] then
25745: LD_VAR 0 4
25749: PUSH
25750: LD_INT 1
25752: ARRAY
25753: IFFALSE 25757
// continue ;
25755: GO 25645
// h := hex [ 2 ] ;
25757: LD_ADDR_VAR 0 13
25761: PUSH
25762: LD_VAR 0 4
25766: PUSH
25767: LD_INT 2
25769: ARRAY
25770: ST_TO_ADDR
// if h + 7 < height then
25771: LD_VAR 0 13
25775: PUSH
25776: LD_INT 7
25778: PLUS
25779: PUSH
25780: LD_VAR 0 15
25784: LESS
25785: IFFALSE 25814
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25787: LD_ADDR_VAR 0 18
25791: PUSH
25792: LD_INT 7
25794: PUSH
25795: LD_INT 28
25797: PUSH
25798: LD_INT 45
25800: PUSH
25801: EMPTY
25802: LIST
25803: LIST
25804: LIST
25805: PUSH
25806: LD_VAR 0 12
25810: ARRAY
25811: ST_TO_ADDR
// break ;
25812: GO 25816
// end ; end ; end ;
25814: GO 25645
25816: POP
25817: POP
// end ; if not weapon then
25818: LD_VAR 0 18
25822: NOT
25823: IFFALSE 25883
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25825: LD_ADDR_VAR 0 5
25829: PUSH
25830: LD_VAR 0 5
25834: PUSH
25835: LD_INT 11
25837: PUSH
25838: LD_INT 30
25840: PUSH
25841: LD_INT 49
25843: PUSH
25844: EMPTY
25845: LIST
25846: LIST
25847: LIST
25848: DIFF
25849: ST_TO_ADDR
// if not list then
25850: LD_VAR 0 5
25854: NOT
25855: IFFALSE 25859
// exit ;
25857: GO 26001
// weapon := list [ rand ( 1 , list ) ] ;
25859: LD_ADDR_VAR 0 18
25863: PUSH
25864: LD_VAR 0 5
25868: PUSH
25869: LD_INT 1
25871: PPUSH
25872: LD_VAR 0 5
25876: PPUSH
25877: CALL_OW 12
25881: ARRAY
25882: ST_TO_ADDR
// end ; if weapon then
25883: LD_VAR 0 18
25887: IFFALSE 26001
// begin tmp := CostOfWeapon ( weapon ) ;
25889: LD_ADDR_VAR 0 14
25893: PUSH
25894: LD_VAR 0 18
25898: PPUSH
25899: CALL_OW 451
25903: ST_TO_ADDR
// j := GetBase ( tower ) ;
25904: LD_ADDR_VAR 0 9
25908: PUSH
25909: LD_VAR 0 1
25913: PPUSH
25914: CALL_OW 274
25918: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25919: LD_VAR 0 9
25923: PPUSH
25924: LD_INT 1
25926: PPUSH
25927: CALL_OW 275
25931: PUSH
25932: LD_VAR 0 14
25936: PUSH
25937: LD_INT 1
25939: ARRAY
25940: GREATEREQUAL
25941: PUSH
25942: LD_VAR 0 9
25946: PPUSH
25947: LD_INT 2
25949: PPUSH
25950: CALL_OW 275
25954: PUSH
25955: LD_VAR 0 14
25959: PUSH
25960: LD_INT 2
25962: ARRAY
25963: GREATEREQUAL
25964: AND
25965: PUSH
25966: LD_VAR 0 9
25970: PPUSH
25971: LD_INT 3
25973: PPUSH
25974: CALL_OW 275
25978: PUSH
25979: LD_VAR 0 14
25983: PUSH
25984: LD_INT 3
25986: ARRAY
25987: GREATEREQUAL
25988: AND
25989: IFFALSE 26001
// result := weapon ;
25991: LD_ADDR_VAR 0 3
25995: PUSH
25996: LD_VAR 0 18
26000: ST_TO_ADDR
// end ; end ;
26001: LD_VAR 0 3
26005: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26006: LD_INT 0
26008: PPUSH
26009: PPUSH
// result := true ;
26010: LD_ADDR_VAR 0 3
26014: PUSH
26015: LD_INT 1
26017: ST_TO_ADDR
// if array1 = array2 then
26018: LD_VAR 0 1
26022: PUSH
26023: LD_VAR 0 2
26027: EQUAL
26028: IFFALSE 26088
// begin for i = 1 to array1 do
26030: LD_ADDR_VAR 0 4
26034: PUSH
26035: DOUBLE
26036: LD_INT 1
26038: DEC
26039: ST_TO_ADDR
26040: LD_VAR 0 1
26044: PUSH
26045: FOR_TO
26046: IFFALSE 26084
// if array1 [ i ] <> array2 [ i ] then
26048: LD_VAR 0 1
26052: PUSH
26053: LD_VAR 0 4
26057: ARRAY
26058: PUSH
26059: LD_VAR 0 2
26063: PUSH
26064: LD_VAR 0 4
26068: ARRAY
26069: NONEQUAL
26070: IFFALSE 26082
// begin result := false ;
26072: LD_ADDR_VAR 0 3
26076: PUSH
26077: LD_INT 0
26079: ST_TO_ADDR
// break ;
26080: GO 26084
// end ;
26082: GO 26045
26084: POP
26085: POP
// end else
26086: GO 26096
// result := false ;
26088: LD_ADDR_VAR 0 3
26092: PUSH
26093: LD_INT 0
26095: ST_TO_ADDR
// end ;
26096: LD_VAR 0 3
26100: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26101: LD_INT 0
26103: PPUSH
26104: PPUSH
// if not array1 or not array2 then
26105: LD_VAR 0 1
26109: NOT
26110: PUSH
26111: LD_VAR 0 2
26115: NOT
26116: OR
26117: IFFALSE 26121
// exit ;
26119: GO 26185
// result := true ;
26121: LD_ADDR_VAR 0 3
26125: PUSH
26126: LD_INT 1
26128: ST_TO_ADDR
// for i = 1 to array1 do
26129: LD_ADDR_VAR 0 4
26133: PUSH
26134: DOUBLE
26135: LD_INT 1
26137: DEC
26138: ST_TO_ADDR
26139: LD_VAR 0 1
26143: PUSH
26144: FOR_TO
26145: IFFALSE 26183
// if array1 [ i ] <> array2 [ i ] then
26147: LD_VAR 0 1
26151: PUSH
26152: LD_VAR 0 4
26156: ARRAY
26157: PUSH
26158: LD_VAR 0 2
26162: PUSH
26163: LD_VAR 0 4
26167: ARRAY
26168: NONEQUAL
26169: IFFALSE 26181
// begin result := false ;
26171: LD_ADDR_VAR 0 3
26175: PUSH
26176: LD_INT 0
26178: ST_TO_ADDR
// break ;
26179: GO 26183
// end ;
26181: GO 26144
26183: POP
26184: POP
// end ;
26185: LD_VAR 0 3
26189: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26190: LD_INT 0
26192: PPUSH
26193: PPUSH
26194: PPUSH
// pom := GetBase ( fac ) ;
26195: LD_ADDR_VAR 0 5
26199: PUSH
26200: LD_VAR 0 1
26204: PPUSH
26205: CALL_OW 274
26209: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26210: LD_ADDR_VAR 0 4
26214: PUSH
26215: LD_VAR 0 2
26219: PUSH
26220: LD_INT 1
26222: ARRAY
26223: PPUSH
26224: LD_VAR 0 2
26228: PUSH
26229: LD_INT 2
26231: ARRAY
26232: PPUSH
26233: LD_VAR 0 2
26237: PUSH
26238: LD_INT 3
26240: ARRAY
26241: PPUSH
26242: LD_VAR 0 2
26246: PUSH
26247: LD_INT 4
26249: ARRAY
26250: PPUSH
26251: CALL_OW 449
26255: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26256: LD_ADDR_VAR 0 3
26260: PUSH
26261: LD_VAR 0 5
26265: PPUSH
26266: LD_INT 1
26268: PPUSH
26269: CALL_OW 275
26273: PUSH
26274: LD_VAR 0 4
26278: PUSH
26279: LD_INT 1
26281: ARRAY
26282: GREATEREQUAL
26283: PUSH
26284: LD_VAR 0 5
26288: PPUSH
26289: LD_INT 2
26291: PPUSH
26292: CALL_OW 275
26296: PUSH
26297: LD_VAR 0 4
26301: PUSH
26302: LD_INT 2
26304: ARRAY
26305: GREATEREQUAL
26306: AND
26307: PUSH
26308: LD_VAR 0 5
26312: PPUSH
26313: LD_INT 3
26315: PPUSH
26316: CALL_OW 275
26320: PUSH
26321: LD_VAR 0 4
26325: PUSH
26326: LD_INT 3
26328: ARRAY
26329: GREATEREQUAL
26330: AND
26331: ST_TO_ADDR
// end ;
26332: LD_VAR 0 3
26336: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26337: LD_INT 0
26339: PPUSH
26340: PPUSH
26341: PPUSH
26342: PPUSH
// pom := GetBase ( building ) ;
26343: LD_ADDR_VAR 0 3
26347: PUSH
26348: LD_VAR 0 1
26352: PPUSH
26353: CALL_OW 274
26357: ST_TO_ADDR
// if not pom then
26358: LD_VAR 0 3
26362: NOT
26363: IFFALSE 26367
// exit ;
26365: GO 26537
// btype := GetBType ( building ) ;
26367: LD_ADDR_VAR 0 5
26371: PUSH
26372: LD_VAR 0 1
26376: PPUSH
26377: CALL_OW 266
26381: ST_TO_ADDR
// if btype = b_armoury then
26382: LD_VAR 0 5
26386: PUSH
26387: LD_INT 4
26389: EQUAL
26390: IFFALSE 26400
// btype := b_barracks ;
26392: LD_ADDR_VAR 0 5
26396: PUSH
26397: LD_INT 5
26399: ST_TO_ADDR
// if btype = b_depot then
26400: LD_VAR 0 5
26404: PUSH
26405: LD_INT 0
26407: EQUAL
26408: IFFALSE 26418
// btype := b_warehouse ;
26410: LD_ADDR_VAR 0 5
26414: PUSH
26415: LD_INT 1
26417: ST_TO_ADDR
// if btype = b_workshop then
26418: LD_VAR 0 5
26422: PUSH
26423: LD_INT 2
26425: EQUAL
26426: IFFALSE 26436
// btype := b_factory ;
26428: LD_ADDR_VAR 0 5
26432: PUSH
26433: LD_INT 3
26435: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26436: LD_ADDR_VAR 0 4
26440: PUSH
26441: LD_VAR 0 5
26445: PPUSH
26446: LD_VAR 0 1
26450: PPUSH
26451: CALL_OW 248
26455: PPUSH
26456: CALL_OW 450
26460: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26461: LD_ADDR_VAR 0 2
26465: PUSH
26466: LD_VAR 0 3
26470: PPUSH
26471: LD_INT 1
26473: PPUSH
26474: CALL_OW 275
26478: PUSH
26479: LD_VAR 0 4
26483: PUSH
26484: LD_INT 1
26486: ARRAY
26487: GREATEREQUAL
26488: PUSH
26489: LD_VAR 0 3
26493: PPUSH
26494: LD_INT 2
26496: PPUSH
26497: CALL_OW 275
26501: PUSH
26502: LD_VAR 0 4
26506: PUSH
26507: LD_INT 2
26509: ARRAY
26510: GREATEREQUAL
26511: AND
26512: PUSH
26513: LD_VAR 0 3
26517: PPUSH
26518: LD_INT 3
26520: PPUSH
26521: CALL_OW 275
26525: PUSH
26526: LD_VAR 0 4
26530: PUSH
26531: LD_INT 3
26533: ARRAY
26534: GREATEREQUAL
26535: AND
26536: ST_TO_ADDR
// end ;
26537: LD_VAR 0 2
26541: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26542: LD_INT 0
26544: PPUSH
26545: PPUSH
26546: PPUSH
// pom := GetBase ( building ) ;
26547: LD_ADDR_VAR 0 4
26551: PUSH
26552: LD_VAR 0 1
26556: PPUSH
26557: CALL_OW 274
26561: ST_TO_ADDR
// if not pom then
26562: LD_VAR 0 4
26566: NOT
26567: IFFALSE 26571
// exit ;
26569: GO 26672
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26571: LD_ADDR_VAR 0 5
26575: PUSH
26576: LD_VAR 0 2
26580: PPUSH
26581: LD_VAR 0 1
26585: PPUSH
26586: CALL_OW 248
26590: PPUSH
26591: CALL_OW 450
26595: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26596: LD_ADDR_VAR 0 3
26600: PUSH
26601: LD_VAR 0 4
26605: PPUSH
26606: LD_INT 1
26608: PPUSH
26609: CALL_OW 275
26613: PUSH
26614: LD_VAR 0 5
26618: PUSH
26619: LD_INT 1
26621: ARRAY
26622: GREATEREQUAL
26623: PUSH
26624: LD_VAR 0 4
26628: PPUSH
26629: LD_INT 2
26631: PPUSH
26632: CALL_OW 275
26636: PUSH
26637: LD_VAR 0 5
26641: PUSH
26642: LD_INT 2
26644: ARRAY
26645: GREATEREQUAL
26646: AND
26647: PUSH
26648: LD_VAR 0 4
26652: PPUSH
26653: LD_INT 3
26655: PPUSH
26656: CALL_OW 275
26660: PUSH
26661: LD_VAR 0 5
26665: PUSH
26666: LD_INT 3
26668: ARRAY
26669: GREATEREQUAL
26670: AND
26671: ST_TO_ADDR
// end ;
26672: LD_VAR 0 3
26676: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26677: LD_INT 0
26679: PPUSH
26680: PPUSH
26681: PPUSH
26682: PPUSH
26683: PPUSH
26684: PPUSH
26685: PPUSH
26686: PPUSH
26687: PPUSH
26688: PPUSH
26689: PPUSH
// result := false ;
26690: LD_ADDR_VAR 0 8
26694: PUSH
26695: LD_INT 0
26697: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26698: LD_VAR 0 5
26702: NOT
26703: PUSH
26704: LD_VAR 0 1
26708: NOT
26709: OR
26710: PUSH
26711: LD_VAR 0 2
26715: NOT
26716: OR
26717: PUSH
26718: LD_VAR 0 3
26722: NOT
26723: OR
26724: IFFALSE 26728
// exit ;
26726: GO 27542
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26728: LD_ADDR_VAR 0 14
26732: PUSH
26733: LD_VAR 0 1
26737: PPUSH
26738: LD_VAR 0 2
26742: PPUSH
26743: LD_VAR 0 3
26747: PPUSH
26748: LD_VAR 0 4
26752: PPUSH
26753: LD_VAR 0 5
26757: PUSH
26758: LD_INT 1
26760: ARRAY
26761: PPUSH
26762: CALL_OW 248
26766: PPUSH
26767: LD_INT 0
26769: PPUSH
26770: CALL 28779 0 6
26774: ST_TO_ADDR
// if not hexes then
26775: LD_VAR 0 14
26779: NOT
26780: IFFALSE 26784
// exit ;
26782: GO 27542
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26784: LD_ADDR_VAR 0 17
26788: PUSH
26789: LD_VAR 0 5
26793: PPUSH
26794: LD_INT 22
26796: PUSH
26797: LD_VAR 0 13
26801: PPUSH
26802: CALL_OW 255
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: PUSH
26811: LD_INT 2
26813: PUSH
26814: LD_INT 30
26816: PUSH
26817: LD_INT 0
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: PUSH
26824: LD_INT 30
26826: PUSH
26827: LD_INT 1
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: PUSH
26834: EMPTY
26835: LIST
26836: LIST
26837: LIST
26838: PUSH
26839: EMPTY
26840: LIST
26841: LIST
26842: PPUSH
26843: CALL_OW 72
26847: ST_TO_ADDR
// for i = 1 to hexes do
26848: LD_ADDR_VAR 0 9
26852: PUSH
26853: DOUBLE
26854: LD_INT 1
26856: DEC
26857: ST_TO_ADDR
26858: LD_VAR 0 14
26862: PUSH
26863: FOR_TO
26864: IFFALSE 27540
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26866: LD_ADDR_VAR 0 13
26870: PUSH
26871: LD_VAR 0 14
26875: PUSH
26876: LD_VAR 0 9
26880: ARRAY
26881: PUSH
26882: LD_INT 1
26884: ARRAY
26885: PPUSH
26886: LD_VAR 0 14
26890: PUSH
26891: LD_VAR 0 9
26895: ARRAY
26896: PUSH
26897: LD_INT 2
26899: ARRAY
26900: PPUSH
26901: CALL_OW 428
26905: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26906: LD_VAR 0 14
26910: PUSH
26911: LD_VAR 0 9
26915: ARRAY
26916: PUSH
26917: LD_INT 1
26919: ARRAY
26920: PPUSH
26921: LD_VAR 0 14
26925: PUSH
26926: LD_VAR 0 9
26930: ARRAY
26931: PUSH
26932: LD_INT 2
26934: ARRAY
26935: PPUSH
26936: CALL_OW 351
26940: PUSH
26941: LD_VAR 0 14
26945: PUSH
26946: LD_VAR 0 9
26950: ARRAY
26951: PUSH
26952: LD_INT 1
26954: ARRAY
26955: PPUSH
26956: LD_VAR 0 14
26960: PUSH
26961: LD_VAR 0 9
26965: ARRAY
26966: PUSH
26967: LD_INT 2
26969: ARRAY
26970: PPUSH
26971: CALL_OW 488
26975: NOT
26976: OR
26977: PUSH
26978: LD_VAR 0 13
26982: PPUSH
26983: CALL_OW 247
26987: PUSH
26988: LD_INT 3
26990: EQUAL
26991: OR
26992: IFFALSE 26998
// exit ;
26994: POP
26995: POP
26996: GO 27542
// if not tmp then
26998: LD_VAR 0 13
27002: NOT
27003: IFFALSE 27007
// continue ;
27005: GO 26863
// result := true ;
27007: LD_ADDR_VAR 0 8
27011: PUSH
27012: LD_INT 1
27014: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
27015: LD_VAR 0 6
27019: PUSH
27020: LD_VAR 0 13
27024: PPUSH
27025: CALL_OW 247
27029: PUSH
27030: LD_INT 2
27032: EQUAL
27033: AND
27034: PUSH
27035: LD_VAR 0 13
27039: PPUSH
27040: CALL_OW 263
27044: PUSH
27045: LD_INT 1
27047: EQUAL
27048: AND
27049: IFFALSE 27213
// begin if IsDrivenBy ( tmp ) then
27051: LD_VAR 0 13
27055: PPUSH
27056: CALL_OW 311
27060: IFFALSE 27064
// continue ;
27062: GO 26863
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27064: LD_VAR 0 6
27068: PPUSH
27069: LD_INT 3
27071: PUSH
27072: LD_INT 60
27074: PUSH
27075: EMPTY
27076: LIST
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: PUSH
27082: LD_INT 3
27084: PUSH
27085: LD_INT 55
27087: PUSH
27088: EMPTY
27089: LIST
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: PPUSH
27099: CALL_OW 72
27103: IFFALSE 27211
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27105: LD_ADDR_VAR 0 18
27109: PUSH
27110: LD_VAR 0 6
27114: PPUSH
27115: LD_INT 3
27117: PUSH
27118: LD_INT 60
27120: PUSH
27121: EMPTY
27122: LIST
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PUSH
27128: LD_INT 3
27130: PUSH
27131: LD_INT 55
27133: PUSH
27134: EMPTY
27135: LIST
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PPUSH
27145: CALL_OW 72
27149: PUSH
27150: LD_INT 1
27152: ARRAY
27153: ST_TO_ADDR
// if IsInUnit ( driver ) then
27154: LD_VAR 0 18
27158: PPUSH
27159: CALL_OW 310
27163: IFFALSE 27174
// ComExit ( driver ) ;
27165: LD_VAR 0 18
27169: PPUSH
27170: CALL 51907 0 1
// AddComEnterUnit ( driver , tmp ) ;
27174: LD_VAR 0 18
27178: PPUSH
27179: LD_VAR 0 13
27183: PPUSH
27184: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27188: LD_VAR 0 18
27192: PPUSH
27193: LD_VAR 0 7
27197: PPUSH
27198: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27202: LD_VAR 0 18
27206: PPUSH
27207: CALL_OW 181
// end ; continue ;
27211: GO 26863
// end ; if not cleaners or not tmp in cleaners then
27213: LD_VAR 0 6
27217: NOT
27218: PUSH
27219: LD_VAR 0 13
27223: PUSH
27224: LD_VAR 0 6
27228: IN
27229: NOT
27230: OR
27231: IFFALSE 27538
// begin if dep then
27233: LD_VAR 0 17
27237: IFFALSE 27373
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27239: LD_ADDR_VAR 0 16
27243: PUSH
27244: LD_VAR 0 17
27248: PUSH
27249: LD_INT 1
27251: ARRAY
27252: PPUSH
27253: CALL_OW 250
27257: PPUSH
27258: LD_VAR 0 17
27262: PUSH
27263: LD_INT 1
27265: ARRAY
27266: PPUSH
27267: CALL_OW 254
27271: PPUSH
27272: LD_INT 5
27274: PPUSH
27275: CALL_OW 272
27279: PUSH
27280: LD_VAR 0 17
27284: PUSH
27285: LD_INT 1
27287: ARRAY
27288: PPUSH
27289: CALL_OW 251
27293: PPUSH
27294: LD_VAR 0 17
27298: PUSH
27299: LD_INT 1
27301: ARRAY
27302: PPUSH
27303: CALL_OW 254
27307: PPUSH
27308: LD_INT 5
27310: PPUSH
27311: CALL_OW 273
27315: PUSH
27316: EMPTY
27317: LIST
27318: LIST
27319: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27320: LD_VAR 0 16
27324: PUSH
27325: LD_INT 1
27327: ARRAY
27328: PPUSH
27329: LD_VAR 0 16
27333: PUSH
27334: LD_INT 2
27336: ARRAY
27337: PPUSH
27338: CALL_OW 488
27342: IFFALSE 27373
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27344: LD_VAR 0 13
27348: PPUSH
27349: LD_VAR 0 16
27353: PUSH
27354: LD_INT 1
27356: ARRAY
27357: PPUSH
27358: LD_VAR 0 16
27362: PUSH
27363: LD_INT 2
27365: ARRAY
27366: PPUSH
27367: CALL_OW 111
// continue ;
27371: GO 26863
// end ; end ; r := GetDir ( tmp ) ;
27373: LD_ADDR_VAR 0 15
27377: PUSH
27378: LD_VAR 0 13
27382: PPUSH
27383: CALL_OW 254
27387: ST_TO_ADDR
// if r = 5 then
27388: LD_VAR 0 15
27392: PUSH
27393: LD_INT 5
27395: EQUAL
27396: IFFALSE 27406
// r := 0 ;
27398: LD_ADDR_VAR 0 15
27402: PUSH
27403: LD_INT 0
27405: ST_TO_ADDR
// for j = r to 5 do
27406: LD_ADDR_VAR 0 10
27410: PUSH
27411: DOUBLE
27412: LD_VAR 0 15
27416: DEC
27417: ST_TO_ADDR
27418: LD_INT 5
27420: PUSH
27421: FOR_TO
27422: IFFALSE 27536
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27424: LD_ADDR_VAR 0 11
27428: PUSH
27429: LD_VAR 0 13
27433: PPUSH
27434: CALL_OW 250
27438: PPUSH
27439: LD_VAR 0 10
27443: PPUSH
27444: LD_INT 2
27446: PPUSH
27447: CALL_OW 272
27451: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27452: LD_ADDR_VAR 0 12
27456: PUSH
27457: LD_VAR 0 13
27461: PPUSH
27462: CALL_OW 251
27466: PPUSH
27467: LD_VAR 0 10
27471: PPUSH
27472: LD_INT 2
27474: PPUSH
27475: CALL_OW 273
27479: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27480: LD_VAR 0 11
27484: PPUSH
27485: LD_VAR 0 12
27489: PPUSH
27490: CALL_OW 488
27494: PUSH
27495: LD_VAR 0 11
27499: PPUSH
27500: LD_VAR 0 12
27504: PPUSH
27505: CALL_OW 428
27509: NOT
27510: AND
27511: IFFALSE 27534
// begin ComMoveXY ( tmp , _x , _y ) ;
27513: LD_VAR 0 13
27517: PPUSH
27518: LD_VAR 0 11
27522: PPUSH
27523: LD_VAR 0 12
27527: PPUSH
27528: CALL_OW 111
// break ;
27532: GO 27536
// end ; end ;
27534: GO 27421
27536: POP
27537: POP
// end ; end ;
27538: GO 26863
27540: POP
27541: POP
// end ;
27542: LD_VAR 0 8
27546: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27547: LD_INT 0
27549: PPUSH
// result := true ;
27550: LD_ADDR_VAR 0 3
27554: PUSH
27555: LD_INT 1
27557: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27558: LD_VAR 0 2
27562: PUSH
27563: LD_INT 24
27565: DOUBLE
27566: EQUAL
27567: IFTRUE 27577
27569: LD_INT 33
27571: DOUBLE
27572: EQUAL
27573: IFTRUE 27577
27575: GO 27602
27577: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27578: LD_ADDR_VAR 0 3
27582: PUSH
27583: LD_INT 32
27585: PPUSH
27586: LD_VAR 0 1
27590: PPUSH
27591: CALL_OW 321
27595: PUSH
27596: LD_INT 2
27598: EQUAL
27599: ST_TO_ADDR
27600: GO 27922
27602: LD_INT 20
27604: DOUBLE
27605: EQUAL
27606: IFTRUE 27610
27608: GO 27635
27610: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27611: LD_ADDR_VAR 0 3
27615: PUSH
27616: LD_INT 6
27618: PPUSH
27619: LD_VAR 0 1
27623: PPUSH
27624: CALL_OW 321
27628: PUSH
27629: LD_INT 2
27631: EQUAL
27632: ST_TO_ADDR
27633: GO 27922
27635: LD_INT 22
27637: DOUBLE
27638: EQUAL
27639: IFTRUE 27649
27641: LD_INT 36
27643: DOUBLE
27644: EQUAL
27645: IFTRUE 27649
27647: GO 27674
27649: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27650: LD_ADDR_VAR 0 3
27654: PUSH
27655: LD_INT 15
27657: PPUSH
27658: LD_VAR 0 1
27662: PPUSH
27663: CALL_OW 321
27667: PUSH
27668: LD_INT 2
27670: EQUAL
27671: ST_TO_ADDR
27672: GO 27922
27674: LD_INT 30
27676: DOUBLE
27677: EQUAL
27678: IFTRUE 27682
27680: GO 27707
27682: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27683: LD_ADDR_VAR 0 3
27687: PUSH
27688: LD_INT 20
27690: PPUSH
27691: LD_VAR 0 1
27695: PPUSH
27696: CALL_OW 321
27700: PUSH
27701: LD_INT 2
27703: EQUAL
27704: ST_TO_ADDR
27705: GO 27922
27707: LD_INT 28
27709: DOUBLE
27710: EQUAL
27711: IFTRUE 27721
27713: LD_INT 21
27715: DOUBLE
27716: EQUAL
27717: IFTRUE 27721
27719: GO 27746
27721: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27722: LD_ADDR_VAR 0 3
27726: PUSH
27727: LD_INT 21
27729: PPUSH
27730: LD_VAR 0 1
27734: PPUSH
27735: CALL_OW 321
27739: PUSH
27740: LD_INT 2
27742: EQUAL
27743: ST_TO_ADDR
27744: GO 27922
27746: LD_INT 16
27748: DOUBLE
27749: EQUAL
27750: IFTRUE 27754
27752: GO 27781
27754: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
27755: LD_ADDR_VAR 0 3
27759: PUSH
27760: LD_EXP 116
27764: PPUSH
27765: LD_VAR 0 1
27769: PPUSH
27770: CALL_OW 321
27774: PUSH
27775: LD_INT 2
27777: EQUAL
27778: ST_TO_ADDR
27779: GO 27922
27781: LD_INT 19
27783: DOUBLE
27784: EQUAL
27785: IFTRUE 27795
27787: LD_INT 23
27789: DOUBLE
27790: EQUAL
27791: IFTRUE 27795
27793: GO 27822
27795: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
27796: LD_ADDR_VAR 0 3
27800: PUSH
27801: LD_EXP 115
27805: PPUSH
27806: LD_VAR 0 1
27810: PPUSH
27811: CALL_OW 321
27815: PUSH
27816: LD_INT 2
27818: EQUAL
27819: ST_TO_ADDR
27820: GO 27922
27822: LD_INT 17
27824: DOUBLE
27825: EQUAL
27826: IFTRUE 27830
27828: GO 27855
27830: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
27831: LD_ADDR_VAR 0 3
27835: PUSH
27836: LD_INT 39
27838: PPUSH
27839: LD_VAR 0 1
27843: PPUSH
27844: CALL_OW 321
27848: PUSH
27849: LD_INT 2
27851: EQUAL
27852: ST_TO_ADDR
27853: GO 27922
27855: LD_INT 18
27857: DOUBLE
27858: EQUAL
27859: IFTRUE 27863
27861: GO 27888
27863: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
27864: LD_ADDR_VAR 0 3
27868: PUSH
27869: LD_INT 40
27871: PPUSH
27872: LD_VAR 0 1
27876: PPUSH
27877: CALL_OW 321
27881: PUSH
27882: LD_INT 2
27884: EQUAL
27885: ST_TO_ADDR
27886: GO 27922
27888: LD_INT 27
27890: DOUBLE
27891: EQUAL
27892: IFTRUE 27896
27894: GO 27921
27896: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
27897: LD_ADDR_VAR 0 3
27901: PUSH
27902: LD_INT 35
27904: PPUSH
27905: LD_VAR 0 1
27909: PPUSH
27910: CALL_OW 321
27914: PUSH
27915: LD_INT 2
27917: EQUAL
27918: ST_TO_ADDR
27919: GO 27922
27921: POP
// end ;
27922: LD_VAR 0 3
27926: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
27927: LD_INT 0
27929: PPUSH
27930: PPUSH
27931: PPUSH
27932: PPUSH
27933: PPUSH
27934: PPUSH
27935: PPUSH
27936: PPUSH
27937: PPUSH
27938: PPUSH
27939: PPUSH
// result := false ;
27940: LD_ADDR_VAR 0 6
27944: PUSH
27945: LD_INT 0
27947: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27948: LD_VAR 0 1
27952: NOT
27953: PUSH
27954: LD_VAR 0 1
27958: PPUSH
27959: CALL_OW 266
27963: PUSH
27964: LD_INT 0
27966: PUSH
27967: LD_INT 1
27969: PUSH
27970: EMPTY
27971: LIST
27972: LIST
27973: IN
27974: NOT
27975: OR
27976: PUSH
27977: LD_VAR 0 2
27981: NOT
27982: OR
27983: PUSH
27984: LD_VAR 0 5
27988: PUSH
27989: LD_INT 0
27991: PUSH
27992: LD_INT 1
27994: PUSH
27995: LD_INT 2
27997: PUSH
27998: LD_INT 3
28000: PUSH
28001: LD_INT 4
28003: PUSH
28004: LD_INT 5
28006: PUSH
28007: EMPTY
28008: LIST
28009: LIST
28010: LIST
28011: LIST
28012: LIST
28013: LIST
28014: IN
28015: NOT
28016: OR
28017: PUSH
28018: LD_VAR 0 3
28022: PPUSH
28023: LD_VAR 0 4
28027: PPUSH
28028: CALL_OW 488
28032: NOT
28033: OR
28034: IFFALSE 28038
// exit ;
28036: GO 28774
// side := GetSide ( depot ) ;
28038: LD_ADDR_VAR 0 9
28042: PUSH
28043: LD_VAR 0 1
28047: PPUSH
28048: CALL_OW 255
28052: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28053: LD_VAR 0 9
28057: PPUSH
28058: LD_VAR 0 2
28062: PPUSH
28063: CALL 27547 0 2
28067: NOT
28068: IFFALSE 28072
// exit ;
28070: GO 28774
// pom := GetBase ( depot ) ;
28072: LD_ADDR_VAR 0 10
28076: PUSH
28077: LD_VAR 0 1
28081: PPUSH
28082: CALL_OW 274
28086: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28087: LD_ADDR_VAR 0 11
28091: PUSH
28092: LD_VAR 0 2
28096: PPUSH
28097: LD_VAR 0 1
28101: PPUSH
28102: CALL_OW 248
28106: PPUSH
28107: CALL_OW 450
28111: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28112: LD_VAR 0 10
28116: PPUSH
28117: LD_INT 1
28119: PPUSH
28120: CALL_OW 275
28124: PUSH
28125: LD_VAR 0 11
28129: PUSH
28130: LD_INT 1
28132: ARRAY
28133: GREATEREQUAL
28134: PUSH
28135: LD_VAR 0 10
28139: PPUSH
28140: LD_INT 2
28142: PPUSH
28143: CALL_OW 275
28147: PUSH
28148: LD_VAR 0 11
28152: PUSH
28153: LD_INT 2
28155: ARRAY
28156: GREATEREQUAL
28157: AND
28158: PUSH
28159: LD_VAR 0 10
28163: PPUSH
28164: LD_INT 3
28166: PPUSH
28167: CALL_OW 275
28171: PUSH
28172: LD_VAR 0 11
28176: PUSH
28177: LD_INT 3
28179: ARRAY
28180: GREATEREQUAL
28181: AND
28182: NOT
28183: IFFALSE 28187
// exit ;
28185: GO 28774
// if GetBType ( depot ) = b_depot then
28187: LD_VAR 0 1
28191: PPUSH
28192: CALL_OW 266
28196: PUSH
28197: LD_INT 0
28199: EQUAL
28200: IFFALSE 28212
// dist := 28 else
28202: LD_ADDR_VAR 0 14
28206: PUSH
28207: LD_INT 28
28209: ST_TO_ADDR
28210: GO 28220
// dist := 36 ;
28212: LD_ADDR_VAR 0 14
28216: PUSH
28217: LD_INT 36
28219: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28220: LD_VAR 0 1
28224: PPUSH
28225: LD_VAR 0 3
28229: PPUSH
28230: LD_VAR 0 4
28234: PPUSH
28235: CALL_OW 297
28239: PUSH
28240: LD_VAR 0 14
28244: GREATER
28245: IFFALSE 28249
// exit ;
28247: GO 28774
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28249: LD_ADDR_VAR 0 12
28253: PUSH
28254: LD_VAR 0 2
28258: PPUSH
28259: LD_VAR 0 3
28263: PPUSH
28264: LD_VAR 0 4
28268: PPUSH
28269: LD_VAR 0 5
28273: PPUSH
28274: LD_VAR 0 1
28278: PPUSH
28279: CALL_OW 248
28283: PPUSH
28284: LD_INT 0
28286: PPUSH
28287: CALL 28779 0 6
28291: ST_TO_ADDR
// if not hexes then
28292: LD_VAR 0 12
28296: NOT
28297: IFFALSE 28301
// exit ;
28299: GO 28774
// hex := GetHexInfo ( x , y ) ;
28301: LD_ADDR_VAR 0 15
28305: PUSH
28306: LD_VAR 0 3
28310: PPUSH
28311: LD_VAR 0 4
28315: PPUSH
28316: CALL_OW 546
28320: ST_TO_ADDR
// if hex [ 1 ] then
28321: LD_VAR 0 15
28325: PUSH
28326: LD_INT 1
28328: ARRAY
28329: IFFALSE 28333
// exit ;
28331: GO 28774
// height := hex [ 2 ] ;
28333: LD_ADDR_VAR 0 13
28337: PUSH
28338: LD_VAR 0 15
28342: PUSH
28343: LD_INT 2
28345: ARRAY
28346: ST_TO_ADDR
// for i = 1 to hexes do
28347: LD_ADDR_VAR 0 7
28351: PUSH
28352: DOUBLE
28353: LD_INT 1
28355: DEC
28356: ST_TO_ADDR
28357: LD_VAR 0 12
28361: PUSH
28362: FOR_TO
28363: IFFALSE 28693
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28365: LD_VAR 0 12
28369: PUSH
28370: LD_VAR 0 7
28374: ARRAY
28375: PUSH
28376: LD_INT 1
28378: ARRAY
28379: PPUSH
28380: LD_VAR 0 12
28384: PUSH
28385: LD_VAR 0 7
28389: ARRAY
28390: PUSH
28391: LD_INT 2
28393: ARRAY
28394: PPUSH
28395: CALL_OW 488
28399: NOT
28400: PUSH
28401: LD_VAR 0 12
28405: PUSH
28406: LD_VAR 0 7
28410: ARRAY
28411: PUSH
28412: LD_INT 1
28414: ARRAY
28415: PPUSH
28416: LD_VAR 0 12
28420: PUSH
28421: LD_VAR 0 7
28425: ARRAY
28426: PUSH
28427: LD_INT 2
28429: ARRAY
28430: PPUSH
28431: CALL_OW 428
28435: PUSH
28436: LD_INT 0
28438: GREATER
28439: OR
28440: PUSH
28441: LD_VAR 0 12
28445: PUSH
28446: LD_VAR 0 7
28450: ARRAY
28451: PUSH
28452: LD_INT 1
28454: ARRAY
28455: PPUSH
28456: LD_VAR 0 12
28460: PUSH
28461: LD_VAR 0 7
28465: ARRAY
28466: PUSH
28467: LD_INT 2
28469: ARRAY
28470: PPUSH
28471: CALL_OW 351
28475: OR
28476: IFFALSE 28482
// exit ;
28478: POP
28479: POP
28480: GO 28774
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28482: LD_ADDR_VAR 0 8
28486: PUSH
28487: LD_VAR 0 12
28491: PUSH
28492: LD_VAR 0 7
28496: ARRAY
28497: PUSH
28498: LD_INT 1
28500: ARRAY
28501: PPUSH
28502: LD_VAR 0 12
28506: PUSH
28507: LD_VAR 0 7
28511: ARRAY
28512: PUSH
28513: LD_INT 2
28515: ARRAY
28516: PPUSH
28517: CALL_OW 546
28521: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28522: LD_VAR 0 8
28526: PUSH
28527: LD_INT 1
28529: ARRAY
28530: PUSH
28531: LD_VAR 0 8
28535: PUSH
28536: LD_INT 2
28538: ARRAY
28539: PUSH
28540: LD_VAR 0 13
28544: PUSH
28545: LD_INT 2
28547: PLUS
28548: GREATER
28549: OR
28550: PUSH
28551: LD_VAR 0 8
28555: PUSH
28556: LD_INT 2
28558: ARRAY
28559: PUSH
28560: LD_VAR 0 13
28564: PUSH
28565: LD_INT 2
28567: MINUS
28568: LESS
28569: OR
28570: PUSH
28571: LD_VAR 0 8
28575: PUSH
28576: LD_INT 3
28578: ARRAY
28579: PUSH
28580: LD_INT 0
28582: PUSH
28583: LD_INT 8
28585: PUSH
28586: LD_INT 9
28588: PUSH
28589: LD_INT 10
28591: PUSH
28592: LD_INT 11
28594: PUSH
28595: LD_INT 12
28597: PUSH
28598: LD_INT 13
28600: PUSH
28601: LD_INT 16
28603: PUSH
28604: LD_INT 17
28606: PUSH
28607: LD_INT 18
28609: PUSH
28610: LD_INT 19
28612: PUSH
28613: LD_INT 20
28615: PUSH
28616: LD_INT 21
28618: PUSH
28619: EMPTY
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: LIST
28627: LIST
28628: LIST
28629: LIST
28630: LIST
28631: LIST
28632: LIST
28633: IN
28634: NOT
28635: OR
28636: PUSH
28637: LD_VAR 0 8
28641: PUSH
28642: LD_INT 5
28644: ARRAY
28645: NOT
28646: OR
28647: PUSH
28648: LD_VAR 0 8
28652: PUSH
28653: LD_INT 6
28655: ARRAY
28656: PUSH
28657: LD_INT 1
28659: PUSH
28660: LD_INT 2
28662: PUSH
28663: LD_INT 7
28665: PUSH
28666: LD_INT 9
28668: PUSH
28669: LD_INT 10
28671: PUSH
28672: LD_INT 11
28674: PUSH
28675: EMPTY
28676: LIST
28677: LIST
28678: LIST
28679: LIST
28680: LIST
28681: LIST
28682: IN
28683: NOT
28684: OR
28685: IFFALSE 28691
// exit ;
28687: POP
28688: POP
28689: GO 28774
// end ;
28691: GO 28362
28693: POP
28694: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28695: LD_VAR 0 9
28699: PPUSH
28700: LD_VAR 0 3
28704: PPUSH
28705: LD_VAR 0 4
28709: PPUSH
28710: LD_INT 20
28712: PPUSH
28713: CALL 20720 0 4
28717: PUSH
28718: LD_INT 4
28720: ARRAY
28721: IFFALSE 28725
// exit ;
28723: GO 28774
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28725: LD_VAR 0 2
28729: PUSH
28730: LD_INT 29
28732: PUSH
28733: LD_INT 30
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: IN
28740: PUSH
28741: LD_VAR 0 3
28745: PPUSH
28746: LD_VAR 0 4
28750: PPUSH
28751: LD_VAR 0 9
28755: PPUSH
28756: CALL_OW 440
28760: NOT
28761: AND
28762: IFFALSE 28766
// exit ;
28764: GO 28774
// result := true ;
28766: LD_ADDR_VAR 0 6
28770: PUSH
28771: LD_INT 1
28773: ST_TO_ADDR
// end ;
28774: LD_VAR 0 6
28778: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
28779: LD_INT 0
28781: PPUSH
28782: PPUSH
28783: PPUSH
28784: PPUSH
28785: PPUSH
28786: PPUSH
28787: PPUSH
28788: PPUSH
28789: PPUSH
28790: PPUSH
28791: PPUSH
28792: PPUSH
28793: PPUSH
28794: PPUSH
28795: PPUSH
28796: PPUSH
28797: PPUSH
28798: PPUSH
28799: PPUSH
28800: PPUSH
28801: PPUSH
28802: PPUSH
28803: PPUSH
28804: PPUSH
28805: PPUSH
28806: PPUSH
28807: PPUSH
28808: PPUSH
28809: PPUSH
28810: PPUSH
28811: PPUSH
28812: PPUSH
28813: PPUSH
28814: PPUSH
28815: PPUSH
28816: PPUSH
28817: PPUSH
28818: PPUSH
28819: PPUSH
28820: PPUSH
28821: PPUSH
28822: PPUSH
28823: PPUSH
28824: PPUSH
28825: PPUSH
28826: PPUSH
28827: PPUSH
28828: PPUSH
28829: PPUSH
28830: PPUSH
28831: PPUSH
28832: PPUSH
28833: PPUSH
28834: PPUSH
28835: PPUSH
28836: PPUSH
28837: PPUSH
28838: PPUSH
// result = [ ] ;
28839: LD_ADDR_VAR 0 7
28843: PUSH
28844: EMPTY
28845: ST_TO_ADDR
// temp_list = [ ] ;
28846: LD_ADDR_VAR 0 9
28850: PUSH
28851: EMPTY
28852: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28853: LD_VAR 0 4
28857: PUSH
28858: LD_INT 0
28860: PUSH
28861: LD_INT 1
28863: PUSH
28864: LD_INT 2
28866: PUSH
28867: LD_INT 3
28869: PUSH
28870: LD_INT 4
28872: PUSH
28873: LD_INT 5
28875: PUSH
28876: EMPTY
28877: LIST
28878: LIST
28879: LIST
28880: LIST
28881: LIST
28882: LIST
28883: IN
28884: NOT
28885: PUSH
28886: LD_VAR 0 1
28890: PUSH
28891: LD_INT 0
28893: PUSH
28894: LD_INT 1
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: IN
28901: PUSH
28902: LD_VAR 0 5
28906: PUSH
28907: LD_INT 1
28909: PUSH
28910: LD_INT 2
28912: PUSH
28913: LD_INT 3
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: LIST
28920: IN
28921: NOT
28922: AND
28923: OR
28924: IFFALSE 28928
// exit ;
28926: GO 47319
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28928: LD_VAR 0 1
28932: PUSH
28933: LD_INT 6
28935: PUSH
28936: LD_INT 7
28938: PUSH
28939: LD_INT 8
28941: PUSH
28942: LD_INT 13
28944: PUSH
28945: LD_INT 12
28947: PUSH
28948: LD_INT 15
28950: PUSH
28951: LD_INT 11
28953: PUSH
28954: LD_INT 14
28956: PUSH
28957: LD_INT 10
28959: PUSH
28960: EMPTY
28961: LIST
28962: LIST
28963: LIST
28964: LIST
28965: LIST
28966: LIST
28967: LIST
28968: LIST
28969: LIST
28970: IN
28971: IFFALSE 28981
// btype = b_lab ;
28973: LD_ADDR_VAR 0 1
28977: PUSH
28978: LD_INT 6
28980: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28981: LD_VAR 0 6
28985: PUSH
28986: LD_INT 0
28988: PUSH
28989: LD_INT 1
28991: PUSH
28992: LD_INT 2
28994: PUSH
28995: EMPTY
28996: LIST
28997: LIST
28998: LIST
28999: IN
29000: NOT
29001: PUSH
29002: LD_VAR 0 1
29006: PUSH
29007: LD_INT 0
29009: PUSH
29010: LD_INT 1
29012: PUSH
29013: LD_INT 2
29015: PUSH
29016: LD_INT 3
29018: PUSH
29019: LD_INT 6
29021: PUSH
29022: LD_INT 36
29024: PUSH
29025: LD_INT 4
29027: PUSH
29028: LD_INT 5
29030: PUSH
29031: LD_INT 31
29033: PUSH
29034: LD_INT 32
29036: PUSH
29037: LD_INT 33
29039: PUSH
29040: EMPTY
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: LIST
29051: LIST
29052: IN
29053: NOT
29054: PUSH
29055: LD_VAR 0 6
29059: PUSH
29060: LD_INT 1
29062: EQUAL
29063: AND
29064: OR
29065: PUSH
29066: LD_VAR 0 1
29070: PUSH
29071: LD_INT 2
29073: PUSH
29074: LD_INT 3
29076: PUSH
29077: EMPTY
29078: LIST
29079: LIST
29080: IN
29081: NOT
29082: PUSH
29083: LD_VAR 0 6
29087: PUSH
29088: LD_INT 2
29090: EQUAL
29091: AND
29092: OR
29093: IFFALSE 29103
// mode = 0 ;
29095: LD_ADDR_VAR 0 6
29099: PUSH
29100: LD_INT 0
29102: ST_TO_ADDR
// case mode of 0 :
29103: LD_VAR 0 6
29107: PUSH
29108: LD_INT 0
29110: DOUBLE
29111: EQUAL
29112: IFTRUE 29116
29114: GO 40569
29116: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29117: LD_ADDR_VAR 0 11
29121: PUSH
29122: LD_INT 0
29124: PUSH
29125: LD_INT 0
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 0
29134: PUSH
29135: LD_INT 1
29137: NEG
29138: PUSH
29139: EMPTY
29140: LIST
29141: LIST
29142: PUSH
29143: LD_INT 1
29145: PUSH
29146: LD_INT 0
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: PUSH
29153: LD_INT 1
29155: PUSH
29156: LD_INT 1
29158: PUSH
29159: EMPTY
29160: LIST
29161: LIST
29162: PUSH
29163: LD_INT 0
29165: PUSH
29166: LD_INT 1
29168: PUSH
29169: EMPTY
29170: LIST
29171: LIST
29172: PUSH
29173: LD_INT 1
29175: NEG
29176: PUSH
29177: LD_INT 0
29179: PUSH
29180: EMPTY
29181: LIST
29182: LIST
29183: PUSH
29184: LD_INT 1
29186: NEG
29187: PUSH
29188: LD_INT 1
29190: NEG
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 1
29198: NEG
29199: PUSH
29200: LD_INT 2
29202: NEG
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: LD_INT 0
29210: PUSH
29211: LD_INT 2
29213: NEG
29214: PUSH
29215: EMPTY
29216: LIST
29217: LIST
29218: PUSH
29219: LD_INT 1
29221: PUSH
29222: LD_INT 1
29224: NEG
29225: PUSH
29226: EMPTY
29227: LIST
29228: LIST
29229: PUSH
29230: LD_INT 1
29232: PUSH
29233: LD_INT 2
29235: PUSH
29236: EMPTY
29237: LIST
29238: LIST
29239: PUSH
29240: LD_INT 0
29242: PUSH
29243: LD_INT 2
29245: PUSH
29246: EMPTY
29247: LIST
29248: LIST
29249: PUSH
29250: LD_INT 1
29252: NEG
29253: PUSH
29254: LD_INT 1
29256: PUSH
29257: EMPTY
29258: LIST
29259: LIST
29260: PUSH
29261: LD_INT 1
29263: PUSH
29264: LD_INT 3
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: PUSH
29271: LD_INT 0
29273: PUSH
29274: LD_INT 3
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: PUSH
29281: LD_INT 1
29283: NEG
29284: PUSH
29285: LD_INT 2
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: LIST
29296: LIST
29297: LIST
29298: LIST
29299: LIST
29300: LIST
29301: LIST
29302: LIST
29303: LIST
29304: LIST
29305: LIST
29306: LIST
29307: LIST
29308: LIST
29309: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29310: LD_ADDR_VAR 0 12
29314: PUSH
29315: LD_INT 0
29317: PUSH
29318: LD_INT 0
29320: PUSH
29321: EMPTY
29322: LIST
29323: LIST
29324: PUSH
29325: LD_INT 0
29327: PUSH
29328: LD_INT 1
29330: NEG
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 1
29338: PUSH
29339: LD_INT 0
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 1
29348: PUSH
29349: LD_INT 1
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 0
29358: PUSH
29359: LD_INT 1
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 1
29368: NEG
29369: PUSH
29370: LD_INT 0
29372: PUSH
29373: EMPTY
29374: LIST
29375: LIST
29376: PUSH
29377: LD_INT 1
29379: NEG
29380: PUSH
29381: LD_INT 1
29383: NEG
29384: PUSH
29385: EMPTY
29386: LIST
29387: LIST
29388: PUSH
29389: LD_INT 1
29391: PUSH
29392: LD_INT 1
29394: NEG
29395: PUSH
29396: EMPTY
29397: LIST
29398: LIST
29399: PUSH
29400: LD_INT 2
29402: PUSH
29403: LD_INT 0
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PUSH
29410: LD_INT 2
29412: PUSH
29413: LD_INT 1
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 1
29422: NEG
29423: PUSH
29424: LD_INT 1
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: LD_INT 2
29433: NEG
29434: PUSH
29435: LD_INT 0
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 2
29444: NEG
29445: PUSH
29446: LD_INT 1
29448: NEG
29449: PUSH
29450: EMPTY
29451: LIST
29452: LIST
29453: PUSH
29454: LD_INT 2
29456: NEG
29457: PUSH
29458: LD_INT 1
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PUSH
29465: LD_INT 3
29467: NEG
29468: PUSH
29469: LD_INT 0
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 3
29478: NEG
29479: PUSH
29480: LD_INT 1
29482: NEG
29483: PUSH
29484: EMPTY
29485: LIST
29486: LIST
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: LIST
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: LIST
29503: LIST
29504: LIST
29505: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29506: LD_ADDR_VAR 0 13
29510: PUSH
29511: LD_INT 0
29513: PUSH
29514: LD_INT 0
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 0
29523: PUSH
29524: LD_INT 1
29526: NEG
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 1
29534: PUSH
29535: LD_INT 0
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: LD_INT 1
29544: PUSH
29545: LD_INT 1
29547: PUSH
29548: EMPTY
29549: LIST
29550: LIST
29551: PUSH
29552: LD_INT 0
29554: PUSH
29555: LD_INT 1
29557: PUSH
29558: EMPTY
29559: LIST
29560: LIST
29561: PUSH
29562: LD_INT 1
29564: NEG
29565: PUSH
29566: LD_INT 0
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: PUSH
29573: LD_INT 1
29575: NEG
29576: PUSH
29577: LD_INT 1
29579: NEG
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: PUSH
29585: LD_INT 1
29587: NEG
29588: PUSH
29589: LD_INT 2
29591: NEG
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: PUSH
29597: LD_INT 2
29599: PUSH
29600: LD_INT 1
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PUSH
29607: LD_INT 2
29609: PUSH
29610: LD_INT 2
29612: PUSH
29613: EMPTY
29614: LIST
29615: LIST
29616: PUSH
29617: LD_INT 1
29619: PUSH
29620: LD_INT 2
29622: PUSH
29623: EMPTY
29624: LIST
29625: LIST
29626: PUSH
29627: LD_INT 2
29629: NEG
29630: PUSH
29631: LD_INT 1
29633: NEG
29634: PUSH
29635: EMPTY
29636: LIST
29637: LIST
29638: PUSH
29639: LD_INT 2
29641: NEG
29642: PUSH
29643: LD_INT 2
29645: NEG
29646: PUSH
29647: EMPTY
29648: LIST
29649: LIST
29650: PUSH
29651: LD_INT 2
29653: NEG
29654: PUSH
29655: LD_INT 3
29657: NEG
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: PUSH
29663: LD_INT 3
29665: NEG
29666: PUSH
29667: LD_INT 2
29669: NEG
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: LD_INT 3
29677: NEG
29678: PUSH
29679: LD_INT 3
29681: NEG
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: LIST
29691: LIST
29692: LIST
29693: LIST
29694: LIST
29695: LIST
29696: LIST
29697: LIST
29698: LIST
29699: LIST
29700: LIST
29701: LIST
29702: LIST
29703: LIST
29704: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29705: LD_ADDR_VAR 0 14
29709: PUSH
29710: LD_INT 0
29712: PUSH
29713: LD_INT 0
29715: PUSH
29716: EMPTY
29717: LIST
29718: LIST
29719: PUSH
29720: LD_INT 0
29722: PUSH
29723: LD_INT 1
29725: NEG
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PUSH
29731: LD_INT 1
29733: PUSH
29734: LD_INT 0
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 1
29743: PUSH
29744: LD_INT 1
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: PUSH
29751: LD_INT 0
29753: PUSH
29754: LD_INT 1
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 1
29763: NEG
29764: PUSH
29765: LD_INT 0
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: LD_INT 1
29774: NEG
29775: PUSH
29776: LD_INT 1
29778: NEG
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: PUSH
29784: LD_INT 1
29786: NEG
29787: PUSH
29788: LD_INT 2
29790: NEG
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 0
29798: PUSH
29799: LD_INT 2
29801: NEG
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PUSH
29807: LD_INT 1
29809: PUSH
29810: LD_INT 1
29812: NEG
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 1
29820: PUSH
29821: LD_INT 2
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PUSH
29828: LD_INT 0
29830: PUSH
29831: LD_INT 2
29833: PUSH
29834: EMPTY
29835: LIST
29836: LIST
29837: PUSH
29838: LD_INT 1
29840: NEG
29841: PUSH
29842: LD_INT 1
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: LD_INT 1
29851: NEG
29852: PUSH
29853: LD_INT 3
29855: NEG
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: LD_INT 3
29866: NEG
29867: PUSH
29868: EMPTY
29869: LIST
29870: LIST
29871: PUSH
29872: LD_INT 1
29874: PUSH
29875: LD_INT 2
29877: NEG
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: LIST
29887: LIST
29888: LIST
29889: LIST
29890: LIST
29891: LIST
29892: LIST
29893: LIST
29894: LIST
29895: LIST
29896: LIST
29897: LIST
29898: LIST
29899: LIST
29900: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29901: LD_ADDR_VAR 0 15
29905: PUSH
29906: LD_INT 0
29908: PUSH
29909: LD_INT 0
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 0
29918: PUSH
29919: LD_INT 1
29921: NEG
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PUSH
29927: LD_INT 1
29929: PUSH
29930: LD_INT 0
29932: PUSH
29933: EMPTY
29934: LIST
29935: LIST
29936: PUSH
29937: LD_INT 1
29939: PUSH
29940: LD_INT 1
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 0
29949: PUSH
29950: LD_INT 1
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: LD_INT 1
29959: NEG
29960: PUSH
29961: LD_INT 0
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 1
29970: NEG
29971: PUSH
29972: LD_INT 1
29974: NEG
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: PUSH
29980: LD_INT 1
29982: PUSH
29983: LD_INT 1
29985: NEG
29986: PUSH
29987: EMPTY
29988: LIST
29989: LIST
29990: PUSH
29991: LD_INT 2
29993: PUSH
29994: LD_INT 0
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: PUSH
30001: LD_INT 2
30003: PUSH
30004: LD_INT 1
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PUSH
30011: LD_INT 1
30013: NEG
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: LD_INT 2
30024: NEG
30025: PUSH
30026: LD_INT 0
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 2
30035: NEG
30036: PUSH
30037: LD_INT 1
30039: NEG
30040: PUSH
30041: EMPTY
30042: LIST
30043: LIST
30044: PUSH
30045: LD_INT 2
30047: PUSH
30048: LD_INT 1
30050: NEG
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 3
30058: PUSH
30059: LD_INT 0
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: PUSH
30066: LD_INT 3
30068: PUSH
30069: LD_INT 1
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: EMPTY
30077: LIST
30078: LIST
30079: LIST
30080: LIST
30081: LIST
30082: LIST
30083: LIST
30084: LIST
30085: LIST
30086: LIST
30087: LIST
30088: LIST
30089: LIST
30090: LIST
30091: LIST
30092: LIST
30093: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30094: LD_ADDR_VAR 0 16
30098: PUSH
30099: LD_INT 0
30101: PUSH
30102: LD_INT 0
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 0
30111: PUSH
30112: LD_INT 1
30114: NEG
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 1
30122: PUSH
30123: LD_INT 0
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: LD_INT 1
30132: PUSH
30133: LD_INT 1
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: LD_INT 0
30142: PUSH
30143: LD_INT 1
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 1
30152: NEG
30153: PUSH
30154: LD_INT 0
30156: PUSH
30157: EMPTY
30158: LIST
30159: LIST
30160: PUSH
30161: LD_INT 1
30163: NEG
30164: PUSH
30165: LD_INT 1
30167: NEG
30168: PUSH
30169: EMPTY
30170: LIST
30171: LIST
30172: PUSH
30173: LD_INT 1
30175: NEG
30176: PUSH
30177: LD_INT 2
30179: NEG
30180: PUSH
30181: EMPTY
30182: LIST
30183: LIST
30184: PUSH
30185: LD_INT 2
30187: PUSH
30188: LD_INT 1
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: LD_INT 2
30197: PUSH
30198: LD_INT 2
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 1
30207: PUSH
30208: LD_INT 2
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 2
30217: NEG
30218: PUSH
30219: LD_INT 1
30221: NEG
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 2
30229: NEG
30230: PUSH
30231: LD_INT 2
30233: NEG
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 3
30241: PUSH
30242: LD_INT 2
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: LD_INT 3
30251: PUSH
30252: LD_INT 3
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: PUSH
30259: LD_INT 2
30261: PUSH
30262: LD_INT 3
30264: PUSH
30265: EMPTY
30266: LIST
30267: LIST
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: LIST
30273: LIST
30274: LIST
30275: LIST
30276: LIST
30277: LIST
30278: LIST
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: LIST
30284: LIST
30285: LIST
30286: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30287: LD_ADDR_VAR 0 17
30291: PUSH
30292: LD_INT 0
30294: PUSH
30295: LD_INT 0
30297: PUSH
30298: EMPTY
30299: LIST
30300: LIST
30301: PUSH
30302: LD_INT 0
30304: PUSH
30305: LD_INT 1
30307: NEG
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: LD_INT 1
30315: PUSH
30316: LD_INT 0
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 1
30325: PUSH
30326: LD_INT 1
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: LD_INT 0
30335: PUSH
30336: LD_INT 1
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 1
30345: NEG
30346: PUSH
30347: LD_INT 0
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 1
30356: NEG
30357: PUSH
30358: LD_INT 1
30360: NEG
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: NEG
30369: PUSH
30370: LD_INT 2
30372: NEG
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: LD_INT 0
30380: PUSH
30381: LD_INT 2
30383: NEG
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 1
30391: PUSH
30392: LD_INT 1
30394: NEG
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: PUSH
30400: LD_INT 2
30402: PUSH
30403: LD_INT 0
30405: PUSH
30406: EMPTY
30407: LIST
30408: LIST
30409: PUSH
30410: LD_INT 2
30412: PUSH
30413: LD_INT 1
30415: PUSH
30416: EMPTY
30417: LIST
30418: LIST
30419: PUSH
30420: LD_INT 2
30422: PUSH
30423: LD_INT 2
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 1
30432: PUSH
30433: LD_INT 2
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: LD_INT 0
30442: PUSH
30443: LD_INT 2
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: PUSH
30450: LD_INT 1
30452: NEG
30453: PUSH
30454: LD_INT 1
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PUSH
30461: LD_INT 2
30463: NEG
30464: PUSH
30465: LD_INT 0
30467: PUSH
30468: EMPTY
30469: LIST
30470: LIST
30471: PUSH
30472: LD_INT 2
30474: NEG
30475: PUSH
30476: LD_INT 1
30478: NEG
30479: PUSH
30480: EMPTY
30481: LIST
30482: LIST
30483: PUSH
30484: LD_INT 2
30486: NEG
30487: PUSH
30488: LD_INT 2
30490: NEG
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: LIST
30500: LIST
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: LIST
30506: LIST
30507: LIST
30508: LIST
30509: LIST
30510: LIST
30511: LIST
30512: LIST
30513: LIST
30514: LIST
30515: LIST
30516: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30517: LD_ADDR_VAR 0 18
30521: PUSH
30522: LD_INT 0
30524: PUSH
30525: LD_INT 0
30527: PUSH
30528: EMPTY
30529: LIST
30530: LIST
30531: PUSH
30532: LD_INT 0
30534: PUSH
30535: LD_INT 1
30537: NEG
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PUSH
30543: LD_INT 1
30545: PUSH
30546: LD_INT 0
30548: PUSH
30549: EMPTY
30550: LIST
30551: LIST
30552: PUSH
30553: LD_INT 1
30555: PUSH
30556: LD_INT 1
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: LD_INT 0
30565: PUSH
30566: LD_INT 1
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 1
30575: NEG
30576: PUSH
30577: LD_INT 0
30579: PUSH
30580: EMPTY
30581: LIST
30582: LIST
30583: PUSH
30584: LD_INT 1
30586: NEG
30587: PUSH
30588: LD_INT 1
30590: NEG
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: PUSH
30596: LD_INT 1
30598: NEG
30599: PUSH
30600: LD_INT 2
30602: NEG
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: PUSH
30608: LD_INT 0
30610: PUSH
30611: LD_INT 2
30613: NEG
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 1
30621: PUSH
30622: LD_INT 1
30624: NEG
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: LD_INT 2
30632: PUSH
30633: LD_INT 0
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 2
30642: PUSH
30643: LD_INT 1
30645: PUSH
30646: EMPTY
30647: LIST
30648: LIST
30649: PUSH
30650: LD_INT 2
30652: PUSH
30653: LD_INT 2
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 1
30662: PUSH
30663: LD_INT 2
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 0
30672: PUSH
30673: LD_INT 2
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 1
30682: NEG
30683: PUSH
30684: LD_INT 1
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: PUSH
30691: LD_INT 2
30693: NEG
30694: PUSH
30695: LD_INT 0
30697: PUSH
30698: EMPTY
30699: LIST
30700: LIST
30701: PUSH
30702: LD_INT 2
30704: NEG
30705: PUSH
30706: LD_INT 1
30708: NEG
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: PUSH
30714: LD_INT 2
30716: NEG
30717: PUSH
30718: LD_INT 2
30720: NEG
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: EMPTY
30727: LIST
30728: LIST
30729: LIST
30730: LIST
30731: LIST
30732: LIST
30733: LIST
30734: LIST
30735: LIST
30736: LIST
30737: LIST
30738: LIST
30739: LIST
30740: LIST
30741: LIST
30742: LIST
30743: LIST
30744: LIST
30745: LIST
30746: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30747: LD_ADDR_VAR 0 19
30751: PUSH
30752: LD_INT 0
30754: PUSH
30755: LD_INT 0
30757: PUSH
30758: EMPTY
30759: LIST
30760: LIST
30761: PUSH
30762: LD_INT 0
30764: PUSH
30765: LD_INT 1
30767: NEG
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PUSH
30773: LD_INT 1
30775: PUSH
30776: LD_INT 0
30778: PUSH
30779: EMPTY
30780: LIST
30781: LIST
30782: PUSH
30783: LD_INT 1
30785: PUSH
30786: LD_INT 1
30788: PUSH
30789: EMPTY
30790: LIST
30791: LIST
30792: PUSH
30793: LD_INT 0
30795: PUSH
30796: LD_INT 1
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 1
30805: NEG
30806: PUSH
30807: LD_INT 0
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 1
30816: NEG
30817: PUSH
30818: LD_INT 1
30820: NEG
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 1
30828: NEG
30829: PUSH
30830: LD_INT 2
30832: NEG
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 0
30840: PUSH
30841: LD_INT 2
30843: NEG
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: PUSH
30849: LD_INT 1
30851: PUSH
30852: LD_INT 1
30854: NEG
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 2
30862: PUSH
30863: LD_INT 0
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: LD_INT 2
30872: PUSH
30873: LD_INT 1
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 2
30882: PUSH
30883: LD_INT 2
30885: PUSH
30886: EMPTY
30887: LIST
30888: LIST
30889: PUSH
30890: LD_INT 1
30892: PUSH
30893: LD_INT 2
30895: PUSH
30896: EMPTY
30897: LIST
30898: LIST
30899: PUSH
30900: LD_INT 0
30902: PUSH
30903: LD_INT 2
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PUSH
30910: LD_INT 1
30912: NEG
30913: PUSH
30914: LD_INT 1
30916: PUSH
30917: EMPTY
30918: LIST
30919: LIST
30920: PUSH
30921: LD_INT 2
30923: NEG
30924: PUSH
30925: LD_INT 0
30927: PUSH
30928: EMPTY
30929: LIST
30930: LIST
30931: PUSH
30932: LD_INT 2
30934: NEG
30935: PUSH
30936: LD_INT 1
30938: NEG
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 2
30946: NEG
30947: PUSH
30948: LD_INT 2
30950: NEG
30951: PUSH
30952: EMPTY
30953: LIST
30954: LIST
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: LIST
30960: LIST
30961: LIST
30962: LIST
30963: LIST
30964: LIST
30965: LIST
30966: LIST
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30977: LD_ADDR_VAR 0 20
30981: PUSH
30982: LD_INT 0
30984: PUSH
30985: LD_INT 0
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PUSH
30992: LD_INT 0
30994: PUSH
30995: LD_INT 1
30997: NEG
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 1
31005: PUSH
31006: LD_INT 0
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: LD_INT 1
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 0
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 1
31035: NEG
31036: PUSH
31037: LD_INT 0
31039: PUSH
31040: EMPTY
31041: LIST
31042: LIST
31043: PUSH
31044: LD_INT 1
31046: NEG
31047: PUSH
31048: LD_INT 1
31050: NEG
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PUSH
31056: LD_INT 1
31058: NEG
31059: PUSH
31060: LD_INT 2
31062: NEG
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 0
31070: PUSH
31071: LD_INT 2
31073: NEG
31074: PUSH
31075: EMPTY
31076: LIST
31077: LIST
31078: PUSH
31079: LD_INT 1
31081: PUSH
31082: LD_INT 1
31084: NEG
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 2
31092: PUSH
31093: LD_INT 0
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: LD_INT 1
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 2
31112: PUSH
31113: LD_INT 2
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 1
31122: PUSH
31123: LD_INT 2
31125: PUSH
31126: EMPTY
31127: LIST
31128: LIST
31129: PUSH
31130: LD_INT 0
31132: PUSH
31133: LD_INT 2
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 1
31142: NEG
31143: PUSH
31144: LD_INT 1
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: PUSH
31151: LD_INT 2
31153: NEG
31154: PUSH
31155: LD_INT 0
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: LD_INT 2
31164: NEG
31165: PUSH
31166: LD_INT 1
31168: NEG
31169: PUSH
31170: EMPTY
31171: LIST
31172: LIST
31173: PUSH
31174: LD_INT 2
31176: NEG
31177: PUSH
31178: LD_INT 2
31180: NEG
31181: PUSH
31182: EMPTY
31183: LIST
31184: LIST
31185: PUSH
31186: EMPTY
31187: LIST
31188: LIST
31189: LIST
31190: LIST
31191: LIST
31192: LIST
31193: LIST
31194: LIST
31195: LIST
31196: LIST
31197: LIST
31198: LIST
31199: LIST
31200: LIST
31201: LIST
31202: LIST
31203: LIST
31204: LIST
31205: LIST
31206: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31207: LD_ADDR_VAR 0 21
31211: PUSH
31212: LD_INT 0
31214: PUSH
31215: LD_INT 0
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 0
31224: PUSH
31225: LD_INT 1
31227: NEG
31228: PUSH
31229: EMPTY
31230: LIST
31231: LIST
31232: PUSH
31233: LD_INT 1
31235: PUSH
31236: LD_INT 0
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 1
31245: PUSH
31246: LD_INT 1
31248: PUSH
31249: EMPTY
31250: LIST
31251: LIST
31252: PUSH
31253: LD_INT 0
31255: PUSH
31256: LD_INT 1
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PUSH
31263: LD_INT 1
31265: NEG
31266: PUSH
31267: LD_INT 0
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: LD_INT 1
31276: NEG
31277: PUSH
31278: LD_INT 1
31280: NEG
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 1
31288: NEG
31289: PUSH
31290: LD_INT 2
31292: NEG
31293: PUSH
31294: EMPTY
31295: LIST
31296: LIST
31297: PUSH
31298: LD_INT 0
31300: PUSH
31301: LD_INT 2
31303: NEG
31304: PUSH
31305: EMPTY
31306: LIST
31307: LIST
31308: PUSH
31309: LD_INT 1
31311: PUSH
31312: LD_INT 1
31314: NEG
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 2
31322: PUSH
31323: LD_INT 0
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 2
31332: PUSH
31333: LD_INT 1
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 2
31342: PUSH
31343: LD_INT 2
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 1
31352: PUSH
31353: LD_INT 2
31355: PUSH
31356: EMPTY
31357: LIST
31358: LIST
31359: PUSH
31360: LD_INT 0
31362: PUSH
31363: LD_INT 2
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 1
31372: NEG
31373: PUSH
31374: LD_INT 1
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: PUSH
31381: LD_INT 2
31383: NEG
31384: PUSH
31385: LD_INT 0
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: PUSH
31392: LD_INT 2
31394: NEG
31395: PUSH
31396: LD_INT 1
31398: NEG
31399: PUSH
31400: EMPTY
31401: LIST
31402: LIST
31403: PUSH
31404: LD_INT 2
31406: NEG
31407: PUSH
31408: LD_INT 2
31410: NEG
31411: PUSH
31412: EMPTY
31413: LIST
31414: LIST
31415: PUSH
31416: EMPTY
31417: LIST
31418: LIST
31419: LIST
31420: LIST
31421: LIST
31422: LIST
31423: LIST
31424: LIST
31425: LIST
31426: LIST
31427: LIST
31428: LIST
31429: LIST
31430: LIST
31431: LIST
31432: LIST
31433: LIST
31434: LIST
31435: LIST
31436: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31437: LD_ADDR_VAR 0 22
31441: PUSH
31442: LD_INT 0
31444: PUSH
31445: LD_INT 0
31447: PUSH
31448: EMPTY
31449: LIST
31450: LIST
31451: PUSH
31452: LD_INT 0
31454: PUSH
31455: LD_INT 1
31457: NEG
31458: PUSH
31459: EMPTY
31460: LIST
31461: LIST
31462: PUSH
31463: LD_INT 1
31465: PUSH
31466: LD_INT 0
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: LD_INT 1
31475: PUSH
31476: LD_INT 1
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 0
31485: PUSH
31486: LD_INT 1
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 1
31495: NEG
31496: PUSH
31497: LD_INT 0
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: PUSH
31504: LD_INT 1
31506: NEG
31507: PUSH
31508: LD_INT 1
31510: NEG
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 1
31518: NEG
31519: PUSH
31520: LD_INT 2
31522: NEG
31523: PUSH
31524: EMPTY
31525: LIST
31526: LIST
31527: PUSH
31528: LD_INT 0
31530: PUSH
31531: LD_INT 2
31533: NEG
31534: PUSH
31535: EMPTY
31536: LIST
31537: LIST
31538: PUSH
31539: LD_INT 1
31541: PUSH
31542: LD_INT 1
31544: NEG
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 2
31552: PUSH
31553: LD_INT 0
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 2
31562: PUSH
31563: LD_INT 1
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 2
31572: PUSH
31573: LD_INT 2
31575: PUSH
31576: EMPTY
31577: LIST
31578: LIST
31579: PUSH
31580: LD_INT 1
31582: PUSH
31583: LD_INT 2
31585: PUSH
31586: EMPTY
31587: LIST
31588: LIST
31589: PUSH
31590: LD_INT 0
31592: PUSH
31593: LD_INT 2
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 1
31602: NEG
31603: PUSH
31604: LD_INT 1
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 2
31613: NEG
31614: PUSH
31615: LD_INT 0
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: PUSH
31622: LD_INT 2
31624: NEG
31625: PUSH
31626: LD_INT 1
31628: NEG
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 2
31636: NEG
31637: PUSH
31638: LD_INT 2
31640: NEG
31641: PUSH
31642: EMPTY
31643: LIST
31644: LIST
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31667: LD_ADDR_VAR 0 23
31671: PUSH
31672: LD_INT 0
31674: PUSH
31675: LD_INT 0
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PUSH
31682: LD_INT 0
31684: PUSH
31685: LD_INT 1
31687: NEG
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 1
31695: PUSH
31696: LD_INT 0
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 1
31705: PUSH
31706: LD_INT 1
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: PUSH
31713: LD_INT 0
31715: PUSH
31716: LD_INT 1
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 1
31725: NEG
31726: PUSH
31727: LD_INT 0
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: LD_INT 1
31736: NEG
31737: PUSH
31738: LD_INT 1
31740: NEG
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 1
31748: NEG
31749: PUSH
31750: LD_INT 2
31752: NEG
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 0
31760: PUSH
31761: LD_INT 2
31763: NEG
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 1
31771: PUSH
31772: LD_INT 1
31774: NEG
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 2
31782: PUSH
31783: LD_INT 0
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 2
31792: PUSH
31793: LD_INT 1
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 2
31802: PUSH
31803: LD_INT 2
31805: PUSH
31806: EMPTY
31807: LIST
31808: LIST
31809: PUSH
31810: LD_INT 1
31812: PUSH
31813: LD_INT 2
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 0
31822: PUSH
31823: LD_INT 2
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 1
31832: NEG
31833: PUSH
31834: LD_INT 1
31836: PUSH
31837: EMPTY
31838: LIST
31839: LIST
31840: PUSH
31841: LD_INT 2
31843: NEG
31844: PUSH
31845: LD_INT 0
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 2
31854: NEG
31855: PUSH
31856: LD_INT 1
31858: NEG
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 2
31866: NEG
31867: PUSH
31868: LD_INT 2
31870: NEG
31871: PUSH
31872: EMPTY
31873: LIST
31874: LIST
31875: PUSH
31876: LD_INT 2
31878: NEG
31879: PUSH
31880: LD_INT 3
31882: NEG
31883: PUSH
31884: EMPTY
31885: LIST
31886: LIST
31887: PUSH
31888: LD_INT 1
31890: NEG
31891: PUSH
31892: LD_INT 3
31894: NEG
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 1
31902: PUSH
31903: LD_INT 2
31905: NEG
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 2
31913: PUSH
31914: LD_INT 1
31916: NEG
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: LIST
31926: LIST
31927: LIST
31928: LIST
31929: LIST
31930: LIST
31931: LIST
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: LIST
31940: LIST
31941: LIST
31942: LIST
31943: LIST
31944: LIST
31945: LIST
31946: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31947: LD_ADDR_VAR 0 24
31951: PUSH
31952: LD_INT 0
31954: PUSH
31955: LD_INT 0
31957: PUSH
31958: EMPTY
31959: LIST
31960: LIST
31961: PUSH
31962: LD_INT 0
31964: PUSH
31965: LD_INT 1
31967: NEG
31968: PUSH
31969: EMPTY
31970: LIST
31971: LIST
31972: PUSH
31973: LD_INT 1
31975: PUSH
31976: LD_INT 0
31978: PUSH
31979: EMPTY
31980: LIST
31981: LIST
31982: PUSH
31983: LD_INT 1
31985: PUSH
31986: LD_INT 1
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PUSH
31993: LD_INT 0
31995: PUSH
31996: LD_INT 1
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 1
32005: NEG
32006: PUSH
32007: LD_INT 0
32009: PUSH
32010: EMPTY
32011: LIST
32012: LIST
32013: PUSH
32014: LD_INT 1
32016: NEG
32017: PUSH
32018: LD_INT 1
32020: NEG
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 1
32028: NEG
32029: PUSH
32030: LD_INT 2
32032: NEG
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 0
32040: PUSH
32041: LD_INT 2
32043: NEG
32044: PUSH
32045: EMPTY
32046: LIST
32047: LIST
32048: PUSH
32049: LD_INT 1
32051: PUSH
32052: LD_INT 1
32054: NEG
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PUSH
32060: LD_INT 2
32062: PUSH
32063: LD_INT 0
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 2
32072: PUSH
32073: LD_INT 1
32075: PUSH
32076: EMPTY
32077: LIST
32078: LIST
32079: PUSH
32080: LD_INT 2
32082: PUSH
32083: LD_INT 2
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: PUSH
32090: LD_INT 1
32092: PUSH
32093: LD_INT 2
32095: PUSH
32096: EMPTY
32097: LIST
32098: LIST
32099: PUSH
32100: LD_INT 0
32102: PUSH
32103: LD_INT 2
32105: PUSH
32106: EMPTY
32107: LIST
32108: LIST
32109: PUSH
32110: LD_INT 1
32112: NEG
32113: PUSH
32114: LD_INT 1
32116: PUSH
32117: EMPTY
32118: LIST
32119: LIST
32120: PUSH
32121: LD_INT 2
32123: NEG
32124: PUSH
32125: LD_INT 0
32127: PUSH
32128: EMPTY
32129: LIST
32130: LIST
32131: PUSH
32132: LD_INT 2
32134: NEG
32135: PUSH
32136: LD_INT 1
32138: NEG
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 2
32146: NEG
32147: PUSH
32148: LD_INT 2
32150: NEG
32151: PUSH
32152: EMPTY
32153: LIST
32154: LIST
32155: PUSH
32156: LD_INT 1
32158: PUSH
32159: LD_INT 2
32161: NEG
32162: PUSH
32163: EMPTY
32164: LIST
32165: LIST
32166: PUSH
32167: LD_INT 2
32169: PUSH
32170: LD_INT 1
32172: NEG
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 3
32180: PUSH
32181: LD_INT 1
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: PUSH
32188: LD_INT 3
32190: PUSH
32191: LD_INT 2
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: PUSH
32198: EMPTY
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: LIST
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: LIST
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32223: LD_ADDR_VAR 0 25
32227: PUSH
32228: LD_INT 0
32230: PUSH
32231: LD_INT 0
32233: PUSH
32234: EMPTY
32235: LIST
32236: LIST
32237: PUSH
32238: LD_INT 0
32240: PUSH
32241: LD_INT 1
32243: NEG
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: PUSH
32249: LD_INT 1
32251: PUSH
32252: LD_INT 0
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 1
32261: PUSH
32262: LD_INT 1
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PUSH
32269: LD_INT 0
32271: PUSH
32272: LD_INT 1
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 1
32281: NEG
32282: PUSH
32283: LD_INT 0
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: LD_INT 1
32292: NEG
32293: PUSH
32294: LD_INT 1
32296: NEG
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: PUSH
32306: LD_INT 2
32308: NEG
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PUSH
32314: LD_INT 0
32316: PUSH
32317: LD_INT 2
32319: NEG
32320: PUSH
32321: EMPTY
32322: LIST
32323: LIST
32324: PUSH
32325: LD_INT 1
32327: PUSH
32328: LD_INT 1
32330: NEG
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PUSH
32336: LD_INT 2
32338: PUSH
32339: LD_INT 0
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 2
32348: PUSH
32349: LD_INT 1
32351: PUSH
32352: EMPTY
32353: LIST
32354: LIST
32355: PUSH
32356: LD_INT 2
32358: PUSH
32359: LD_INT 2
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 1
32368: PUSH
32369: LD_INT 2
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 0
32378: PUSH
32379: LD_INT 2
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: LD_INT 1
32388: NEG
32389: PUSH
32390: LD_INT 1
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 2
32399: NEG
32400: PUSH
32401: LD_INT 0
32403: PUSH
32404: EMPTY
32405: LIST
32406: LIST
32407: PUSH
32408: LD_INT 2
32410: NEG
32411: PUSH
32412: LD_INT 1
32414: NEG
32415: PUSH
32416: EMPTY
32417: LIST
32418: LIST
32419: PUSH
32420: LD_INT 2
32422: NEG
32423: PUSH
32424: LD_INT 2
32426: NEG
32427: PUSH
32428: EMPTY
32429: LIST
32430: LIST
32431: PUSH
32432: LD_INT 3
32434: PUSH
32435: LD_INT 1
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: PUSH
32442: LD_INT 3
32444: PUSH
32445: LD_INT 2
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 2
32454: PUSH
32455: LD_INT 3
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: PUSH
32462: LD_INT 1
32464: PUSH
32465: LD_INT 3
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: LIST
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: LIST
32493: LIST
32494: LIST
32495: LIST
32496: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32497: LD_ADDR_VAR 0 26
32501: PUSH
32502: LD_INT 0
32504: PUSH
32505: LD_INT 0
32507: PUSH
32508: EMPTY
32509: LIST
32510: LIST
32511: PUSH
32512: LD_INT 0
32514: PUSH
32515: LD_INT 1
32517: NEG
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 1
32525: PUSH
32526: LD_INT 0
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: LD_INT 1
32535: PUSH
32536: LD_INT 1
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: LD_INT 0
32545: PUSH
32546: LD_INT 1
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 1
32555: NEG
32556: PUSH
32557: LD_INT 0
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PUSH
32564: LD_INT 1
32566: NEG
32567: PUSH
32568: LD_INT 1
32570: NEG
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 1
32578: NEG
32579: PUSH
32580: LD_INT 2
32582: NEG
32583: PUSH
32584: EMPTY
32585: LIST
32586: LIST
32587: PUSH
32588: LD_INT 0
32590: PUSH
32591: LD_INT 2
32593: NEG
32594: PUSH
32595: EMPTY
32596: LIST
32597: LIST
32598: PUSH
32599: LD_INT 1
32601: PUSH
32602: LD_INT 1
32604: NEG
32605: PUSH
32606: EMPTY
32607: LIST
32608: LIST
32609: PUSH
32610: LD_INT 2
32612: PUSH
32613: LD_INT 0
32615: PUSH
32616: EMPTY
32617: LIST
32618: LIST
32619: PUSH
32620: LD_INT 2
32622: PUSH
32623: LD_INT 1
32625: PUSH
32626: EMPTY
32627: LIST
32628: LIST
32629: PUSH
32630: LD_INT 2
32632: PUSH
32633: LD_INT 2
32635: PUSH
32636: EMPTY
32637: LIST
32638: LIST
32639: PUSH
32640: LD_INT 1
32642: PUSH
32643: LD_INT 2
32645: PUSH
32646: EMPTY
32647: LIST
32648: LIST
32649: PUSH
32650: LD_INT 0
32652: PUSH
32653: LD_INT 2
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: PUSH
32660: LD_INT 1
32662: NEG
32663: PUSH
32664: LD_INT 1
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: LD_INT 2
32673: NEG
32674: PUSH
32675: LD_INT 0
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 2
32684: NEG
32685: PUSH
32686: LD_INT 1
32688: NEG
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: PUSH
32694: LD_INT 2
32696: NEG
32697: PUSH
32698: LD_INT 2
32700: NEG
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PUSH
32706: LD_INT 2
32708: PUSH
32709: LD_INT 3
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 1
32718: PUSH
32719: LD_INT 3
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: LD_INT 1
32728: NEG
32729: PUSH
32730: LD_INT 2
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 2
32739: NEG
32740: PUSH
32741: LD_INT 1
32743: PUSH
32744: EMPTY
32745: LIST
32746: LIST
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: LIST
32752: LIST
32753: LIST
32754: LIST
32755: LIST
32756: LIST
32757: LIST
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32773: LD_ADDR_VAR 0 27
32777: PUSH
32778: LD_INT 0
32780: PUSH
32781: LD_INT 0
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 0
32790: PUSH
32791: LD_INT 1
32793: NEG
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 1
32801: PUSH
32802: LD_INT 0
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 1
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 0
32821: PUSH
32822: LD_INT 1
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 1
32831: NEG
32832: PUSH
32833: LD_INT 0
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 1
32842: NEG
32843: PUSH
32844: LD_INT 1
32846: NEG
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 1
32854: NEG
32855: PUSH
32856: LD_INT 2
32858: NEG
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 0
32866: PUSH
32867: LD_INT 2
32869: NEG
32870: PUSH
32871: EMPTY
32872: LIST
32873: LIST
32874: PUSH
32875: LD_INT 1
32877: PUSH
32878: LD_INT 1
32880: NEG
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 2
32888: PUSH
32889: LD_INT 0
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PUSH
32896: LD_INT 2
32898: PUSH
32899: LD_INT 1
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: PUSH
32906: LD_INT 2
32908: PUSH
32909: LD_INT 2
32911: PUSH
32912: EMPTY
32913: LIST
32914: LIST
32915: PUSH
32916: LD_INT 1
32918: PUSH
32919: LD_INT 2
32921: PUSH
32922: EMPTY
32923: LIST
32924: LIST
32925: PUSH
32926: LD_INT 0
32928: PUSH
32929: LD_INT 2
32931: PUSH
32932: EMPTY
32933: LIST
32934: LIST
32935: PUSH
32936: LD_INT 1
32938: NEG
32939: PUSH
32940: LD_INT 1
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 2
32949: NEG
32950: PUSH
32951: LD_INT 0
32953: PUSH
32954: EMPTY
32955: LIST
32956: LIST
32957: PUSH
32958: LD_INT 2
32960: NEG
32961: PUSH
32962: LD_INT 1
32964: NEG
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 2
32972: NEG
32973: PUSH
32974: LD_INT 2
32976: NEG
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: PUSH
32982: LD_INT 1
32984: NEG
32985: PUSH
32986: LD_INT 2
32988: PUSH
32989: EMPTY
32990: LIST
32991: LIST
32992: PUSH
32993: LD_INT 2
32995: NEG
32996: PUSH
32997: LD_INT 1
32999: PUSH
33000: EMPTY
33001: LIST
33002: LIST
33003: PUSH
33004: LD_INT 3
33006: NEG
33007: PUSH
33008: LD_INT 1
33010: NEG
33011: PUSH
33012: EMPTY
33013: LIST
33014: LIST
33015: PUSH
33016: LD_INT 3
33018: NEG
33019: PUSH
33020: LD_INT 2
33022: NEG
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: LIST
33032: LIST
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33053: LD_ADDR_VAR 0 28
33057: PUSH
33058: LD_INT 0
33060: PUSH
33061: LD_INT 0
33063: PUSH
33064: EMPTY
33065: LIST
33066: LIST
33067: PUSH
33068: LD_INT 0
33070: PUSH
33071: LD_INT 1
33073: NEG
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 1
33081: PUSH
33082: LD_INT 0
33084: PUSH
33085: EMPTY
33086: LIST
33087: LIST
33088: PUSH
33089: LD_INT 1
33091: PUSH
33092: LD_INT 1
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: PUSH
33099: LD_INT 0
33101: PUSH
33102: LD_INT 1
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 1
33111: NEG
33112: PUSH
33113: LD_INT 0
33115: PUSH
33116: EMPTY
33117: LIST
33118: LIST
33119: PUSH
33120: LD_INT 1
33122: NEG
33123: PUSH
33124: LD_INT 1
33126: NEG
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: NEG
33135: PUSH
33136: LD_INT 2
33138: NEG
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 0
33146: PUSH
33147: LD_INT 2
33149: NEG
33150: PUSH
33151: EMPTY
33152: LIST
33153: LIST
33154: PUSH
33155: LD_INT 1
33157: PUSH
33158: LD_INT 1
33160: NEG
33161: PUSH
33162: EMPTY
33163: LIST
33164: LIST
33165: PUSH
33166: LD_INT 2
33168: PUSH
33169: LD_INT 0
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 2
33178: PUSH
33179: LD_INT 1
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: LD_INT 2
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: LD_INT 1
33198: PUSH
33199: LD_INT 2
33201: PUSH
33202: EMPTY
33203: LIST
33204: LIST
33205: PUSH
33206: LD_INT 0
33208: PUSH
33209: LD_INT 2
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PUSH
33216: LD_INT 1
33218: NEG
33219: PUSH
33220: LD_INT 1
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 2
33229: NEG
33230: PUSH
33231: LD_INT 0
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 2
33240: NEG
33241: PUSH
33242: LD_INT 1
33244: NEG
33245: PUSH
33246: EMPTY
33247: LIST
33248: LIST
33249: PUSH
33250: LD_INT 2
33252: NEG
33253: PUSH
33254: LD_INT 2
33256: NEG
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: PUSH
33262: LD_INT 2
33264: NEG
33265: PUSH
33266: LD_INT 3
33268: NEG
33269: PUSH
33270: EMPTY
33271: LIST
33272: LIST
33273: PUSH
33274: LD_INT 1
33276: NEG
33277: PUSH
33278: LD_INT 3
33280: NEG
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 3
33288: NEG
33289: PUSH
33290: LD_INT 1
33292: NEG
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 3
33300: NEG
33301: PUSH
33302: LD_INT 2
33304: NEG
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: LIST
33314: LIST
33315: LIST
33316: LIST
33317: LIST
33318: LIST
33319: LIST
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33335: LD_ADDR_VAR 0 29
33339: PUSH
33340: LD_INT 0
33342: PUSH
33343: LD_INT 0
33345: PUSH
33346: EMPTY
33347: LIST
33348: LIST
33349: PUSH
33350: LD_INT 0
33352: PUSH
33353: LD_INT 1
33355: NEG
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: LD_INT 1
33363: PUSH
33364: LD_INT 0
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: PUSH
33371: LD_INT 1
33373: PUSH
33374: LD_INT 1
33376: PUSH
33377: EMPTY
33378: LIST
33379: LIST
33380: PUSH
33381: LD_INT 0
33383: PUSH
33384: LD_INT 1
33386: PUSH
33387: EMPTY
33388: LIST
33389: LIST
33390: PUSH
33391: LD_INT 1
33393: NEG
33394: PUSH
33395: LD_INT 0
33397: PUSH
33398: EMPTY
33399: LIST
33400: LIST
33401: PUSH
33402: LD_INT 1
33404: NEG
33405: PUSH
33406: LD_INT 1
33408: NEG
33409: PUSH
33410: EMPTY
33411: LIST
33412: LIST
33413: PUSH
33414: LD_INT 1
33416: NEG
33417: PUSH
33418: LD_INT 2
33420: NEG
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 0
33428: PUSH
33429: LD_INT 2
33431: NEG
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: PUSH
33437: LD_INT 1
33439: PUSH
33440: LD_INT 1
33442: NEG
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 2
33450: PUSH
33451: LD_INT 0
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: PUSH
33458: LD_INT 2
33460: PUSH
33461: LD_INT 1
33463: PUSH
33464: EMPTY
33465: LIST
33466: LIST
33467: PUSH
33468: LD_INT 1
33470: PUSH
33471: LD_INT 2
33473: PUSH
33474: EMPTY
33475: LIST
33476: LIST
33477: PUSH
33478: LD_INT 0
33480: PUSH
33481: LD_INT 2
33483: PUSH
33484: EMPTY
33485: LIST
33486: LIST
33487: PUSH
33488: LD_INT 1
33490: NEG
33491: PUSH
33492: LD_INT 1
33494: PUSH
33495: EMPTY
33496: LIST
33497: LIST
33498: PUSH
33499: LD_INT 2
33501: NEG
33502: PUSH
33503: LD_INT 1
33505: NEG
33506: PUSH
33507: EMPTY
33508: LIST
33509: LIST
33510: PUSH
33511: LD_INT 2
33513: NEG
33514: PUSH
33515: LD_INT 2
33517: NEG
33518: PUSH
33519: EMPTY
33520: LIST
33521: LIST
33522: PUSH
33523: LD_INT 2
33525: NEG
33526: PUSH
33527: LD_INT 3
33529: NEG
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 2
33537: PUSH
33538: LD_INT 1
33540: NEG
33541: PUSH
33542: EMPTY
33543: LIST
33544: LIST
33545: PUSH
33546: LD_INT 3
33548: PUSH
33549: LD_INT 1
33551: PUSH
33552: EMPTY
33553: LIST
33554: LIST
33555: PUSH
33556: LD_INT 1
33558: PUSH
33559: LD_INT 3
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: LD_INT 1
33568: NEG
33569: PUSH
33570: LD_INT 2
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: PUSH
33577: LD_INT 3
33579: NEG
33580: PUSH
33581: LD_INT 2
33583: NEG
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: LIST
33612: LIST
33613: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33614: LD_ADDR_VAR 0 30
33618: PUSH
33619: LD_INT 0
33621: PUSH
33622: LD_INT 0
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 0
33631: PUSH
33632: LD_INT 1
33634: NEG
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: LD_INT 0
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 1
33652: PUSH
33653: LD_INT 1
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 0
33662: PUSH
33663: LD_INT 1
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 1
33672: NEG
33673: PUSH
33674: LD_INT 0
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 1
33683: NEG
33684: PUSH
33685: LD_INT 1
33687: NEG
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_INT 1
33695: NEG
33696: PUSH
33697: LD_INT 2
33699: NEG
33700: PUSH
33701: EMPTY
33702: LIST
33703: LIST
33704: PUSH
33705: LD_INT 0
33707: PUSH
33708: LD_INT 2
33710: NEG
33711: PUSH
33712: EMPTY
33713: LIST
33714: LIST
33715: PUSH
33716: LD_INT 1
33718: PUSH
33719: LD_INT 1
33721: NEG
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PUSH
33727: LD_INT 2
33729: PUSH
33730: LD_INT 0
33732: PUSH
33733: EMPTY
33734: LIST
33735: LIST
33736: PUSH
33737: LD_INT 2
33739: PUSH
33740: LD_INT 1
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 2
33749: PUSH
33750: LD_INT 2
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 1
33759: PUSH
33760: LD_INT 2
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: LD_INT 1
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: LD_INT 2
33780: NEG
33781: PUSH
33782: LD_INT 0
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: LD_INT 2
33791: NEG
33792: PUSH
33793: LD_INT 1
33795: NEG
33796: PUSH
33797: EMPTY
33798: LIST
33799: LIST
33800: PUSH
33801: LD_INT 1
33803: NEG
33804: PUSH
33805: LD_INT 3
33807: NEG
33808: PUSH
33809: EMPTY
33810: LIST
33811: LIST
33812: PUSH
33813: LD_INT 1
33815: PUSH
33816: LD_INT 2
33818: NEG
33819: PUSH
33820: EMPTY
33821: LIST
33822: LIST
33823: PUSH
33824: LD_INT 3
33826: PUSH
33827: LD_INT 2
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: LD_INT 2
33836: PUSH
33837: LD_INT 3
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PUSH
33844: LD_INT 2
33846: NEG
33847: PUSH
33848: LD_INT 1
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: PUSH
33855: LD_INT 3
33857: NEG
33858: PUSH
33859: LD_INT 1
33861: NEG
33862: PUSH
33863: EMPTY
33864: LIST
33865: LIST
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33892: LD_ADDR_VAR 0 31
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 0
33909: PUSH
33910: LD_INT 1
33912: NEG
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: PUSH
33921: LD_INT 0
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 1
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 0
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 1
33950: NEG
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: LD_INT 1
33965: NEG
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 1
33973: NEG
33974: PUSH
33975: LD_INT 2
33977: NEG
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 1
33985: PUSH
33986: LD_INT 1
33988: NEG
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: PUSH
33994: LD_INT 2
33996: PUSH
33997: LD_INT 0
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 2
34006: PUSH
34007: LD_INT 1
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: LD_INT 2
34016: PUSH
34017: LD_INT 2
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: PUSH
34024: LD_INT 1
34026: PUSH
34027: LD_INT 2
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: LD_INT 0
34036: PUSH
34037: LD_INT 2
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 1
34046: NEG
34047: PUSH
34048: LD_INT 1
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: PUSH
34055: LD_INT 2
34057: NEG
34058: PUSH
34059: LD_INT 1
34061: NEG
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: PUSH
34067: LD_INT 2
34069: NEG
34070: PUSH
34071: LD_INT 2
34073: NEG
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PUSH
34079: LD_INT 2
34081: NEG
34082: PUSH
34083: LD_INT 3
34085: NEG
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 2
34093: PUSH
34094: LD_INT 1
34096: NEG
34097: PUSH
34098: EMPTY
34099: LIST
34100: LIST
34101: PUSH
34102: LD_INT 3
34104: PUSH
34105: LD_INT 1
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 1
34114: PUSH
34115: LD_INT 3
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 1
34124: NEG
34125: PUSH
34126: LD_INT 2
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 3
34135: NEG
34136: PUSH
34137: LD_INT 2
34139: NEG
34140: PUSH
34141: EMPTY
34142: LIST
34143: LIST
34144: PUSH
34145: EMPTY
34146: LIST
34147: LIST
34148: LIST
34149: LIST
34150: LIST
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: LIST
34169: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34170: LD_ADDR_VAR 0 32
34174: PUSH
34175: LD_INT 0
34177: PUSH
34178: LD_INT 0
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 0
34187: PUSH
34188: LD_INT 1
34190: NEG
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 1
34198: PUSH
34199: LD_INT 0
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 1
34208: PUSH
34209: LD_INT 1
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: LD_INT 0
34218: PUSH
34219: LD_INT 1
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PUSH
34226: LD_INT 1
34228: NEG
34229: PUSH
34230: LD_INT 0
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: LD_INT 1
34243: NEG
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 1
34251: NEG
34252: PUSH
34253: LD_INT 2
34255: NEG
34256: PUSH
34257: EMPTY
34258: LIST
34259: LIST
34260: PUSH
34261: LD_INT 0
34263: PUSH
34264: LD_INT 2
34266: NEG
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: PUSH
34272: LD_INT 1
34274: PUSH
34275: LD_INT 1
34277: NEG
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 2
34285: PUSH
34286: LD_INT 1
34288: PUSH
34289: EMPTY
34290: LIST
34291: LIST
34292: PUSH
34293: LD_INT 2
34295: PUSH
34296: LD_INT 2
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 1
34305: PUSH
34306: LD_INT 2
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 0
34315: PUSH
34316: LD_INT 2
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 1
34325: NEG
34326: PUSH
34327: LD_INT 1
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: LD_INT 2
34336: NEG
34337: PUSH
34338: LD_INT 0
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: PUSH
34345: LD_INT 2
34347: NEG
34348: PUSH
34349: LD_INT 1
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 1
34359: NEG
34360: PUSH
34361: LD_INT 3
34363: NEG
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: LD_INT 1
34371: PUSH
34372: LD_INT 2
34374: NEG
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: LD_INT 3
34382: PUSH
34383: LD_INT 2
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: PUSH
34390: LD_INT 2
34392: PUSH
34393: LD_INT 3
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 2
34402: NEG
34403: PUSH
34404: LD_INT 1
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 3
34413: NEG
34414: PUSH
34415: LD_INT 1
34417: NEG
34418: PUSH
34419: EMPTY
34420: LIST
34421: LIST
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34448: LD_ADDR_VAR 0 33
34452: PUSH
34453: LD_INT 0
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 0
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 1
34476: PUSH
34477: LD_INT 0
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 1
34486: PUSH
34487: LD_INT 1
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 0
34496: PUSH
34497: LD_INT 1
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: LD_INT 1
34506: NEG
34507: PUSH
34508: LD_INT 0
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 1
34517: NEG
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 1
34529: NEG
34530: PUSH
34531: LD_INT 2
34533: NEG
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: LD_INT 1
34541: PUSH
34542: LD_INT 1
34544: NEG
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PUSH
34550: LD_INT 2
34552: PUSH
34553: LD_INT 0
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 2
34562: PUSH
34563: LD_INT 1
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 1
34572: PUSH
34573: LD_INT 2
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 0
34582: PUSH
34583: LD_INT 2
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 1
34592: NEG
34593: PUSH
34594: LD_INT 1
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: LD_INT 0
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 2
34614: NEG
34615: PUSH
34616: LD_INT 1
34618: NEG
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 2
34626: NEG
34627: PUSH
34628: LD_INT 2
34630: NEG
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 2
34638: NEG
34639: PUSH
34640: LD_INT 3
34642: NEG
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 2
34650: PUSH
34651: LD_INT 1
34653: NEG
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 3
34661: PUSH
34662: LD_INT 1
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: LD_INT 1
34671: PUSH
34672: LD_INT 3
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: LD_INT 1
34681: NEG
34682: PUSH
34683: LD_INT 2
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 3
34692: NEG
34693: PUSH
34694: LD_INT 2
34696: NEG
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34727: LD_ADDR_VAR 0 34
34731: PUSH
34732: LD_INT 0
34734: PUSH
34735: LD_INT 0
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PUSH
34742: LD_INT 0
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: PUSH
34756: LD_INT 0
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: PUSH
34766: LD_INT 1
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 0
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 1
34785: NEG
34786: PUSH
34787: LD_INT 0
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 1
34796: NEG
34797: PUSH
34798: LD_INT 1
34800: NEG
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 1
34808: NEG
34809: PUSH
34810: LD_INT 2
34812: NEG
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 0
34820: PUSH
34821: LD_INT 2
34823: NEG
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PUSH
34829: LD_INT 1
34831: PUSH
34832: LD_INT 1
34834: NEG
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 2
34842: PUSH
34843: LD_INT 1
34845: PUSH
34846: EMPTY
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 2
34852: PUSH
34853: LD_INT 2
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 1
34862: PUSH
34863: LD_INT 2
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 1
34872: NEG
34873: PUSH
34874: LD_INT 1
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 2
34883: NEG
34884: PUSH
34885: LD_INT 0
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 2
34894: NEG
34895: PUSH
34896: LD_INT 1
34898: NEG
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 2
34906: NEG
34907: PUSH
34908: LD_INT 2
34910: NEG
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 1
34918: NEG
34919: PUSH
34920: LD_INT 3
34922: NEG
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 1
34930: PUSH
34931: LD_INT 2
34933: NEG
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: LD_INT 3
34941: PUSH
34942: LD_INT 2
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 2
34951: PUSH
34952: LD_INT 3
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: LD_INT 2
34961: NEG
34962: PUSH
34963: LD_INT 1
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 3
34972: NEG
34973: PUSH
34974: LD_INT 1
34976: NEG
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: EMPTY
34983: LIST
34984: LIST
34985: LIST
34986: LIST
34987: LIST
34988: LIST
34989: LIST
34990: LIST
34991: LIST
34992: LIST
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: LIST
35001: LIST
35002: LIST
35003: LIST
35004: LIST
35005: LIST
35006: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35007: LD_ADDR_VAR 0 35
35011: PUSH
35012: LD_INT 0
35014: PUSH
35015: LD_INT 0
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 0
35024: PUSH
35025: LD_INT 1
35027: NEG
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 1
35035: PUSH
35036: LD_INT 0
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 1
35045: PUSH
35046: LD_INT 1
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: LD_INT 0
35055: PUSH
35056: LD_INT 1
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 1
35065: NEG
35066: PUSH
35067: LD_INT 0
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 1
35076: NEG
35077: PUSH
35078: LD_INT 1
35080: NEG
35081: PUSH
35082: EMPTY
35083: LIST
35084: LIST
35085: PUSH
35086: LD_INT 2
35088: PUSH
35089: LD_INT 1
35091: PUSH
35092: EMPTY
35093: LIST
35094: LIST
35095: PUSH
35096: LD_INT 2
35098: NEG
35099: PUSH
35100: LD_INT 1
35102: NEG
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35119: LD_ADDR_VAR 0 36
35123: PUSH
35124: LD_INT 0
35126: PUSH
35127: LD_INT 0
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 0
35136: PUSH
35137: LD_INT 1
35139: NEG
35140: PUSH
35141: EMPTY
35142: LIST
35143: LIST
35144: PUSH
35145: LD_INT 1
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 1
35157: PUSH
35158: LD_INT 1
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PUSH
35165: LD_INT 0
35167: PUSH
35168: LD_INT 1
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 1
35177: NEG
35178: PUSH
35179: LD_INT 0
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 1
35188: NEG
35189: PUSH
35190: LD_INT 1
35192: NEG
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 1
35200: NEG
35201: PUSH
35202: LD_INT 2
35204: NEG
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PUSH
35210: LD_INT 1
35212: PUSH
35213: LD_INT 2
35215: PUSH
35216: EMPTY
35217: LIST
35218: LIST
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: LIST
35224: LIST
35225: LIST
35226: LIST
35227: LIST
35228: LIST
35229: LIST
35230: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35231: LD_ADDR_VAR 0 37
35235: PUSH
35236: LD_INT 0
35238: PUSH
35239: LD_INT 0
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 0
35248: PUSH
35249: LD_INT 1
35251: NEG
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 1
35259: PUSH
35260: LD_INT 0
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 1
35269: PUSH
35270: LD_INT 1
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 0
35279: PUSH
35280: LD_INT 1
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 1
35289: NEG
35290: PUSH
35291: LD_INT 0
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: LD_INT 1
35300: NEG
35301: PUSH
35302: LD_INT 1
35304: NEG
35305: PUSH
35306: EMPTY
35307: LIST
35308: LIST
35309: PUSH
35310: LD_INT 1
35312: PUSH
35313: LD_INT 1
35315: NEG
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: NEG
35324: PUSH
35325: LD_INT 1
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: LIST
35336: LIST
35337: LIST
35338: LIST
35339: LIST
35340: LIST
35341: LIST
35342: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35343: LD_ADDR_VAR 0 38
35347: PUSH
35348: LD_INT 0
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: LD_INT 0
35360: PUSH
35361: LD_INT 1
35363: NEG
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 1
35371: PUSH
35372: LD_INT 0
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 1
35381: PUSH
35382: LD_INT 1
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 0
35391: PUSH
35392: LD_INT 1
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 1
35401: NEG
35402: PUSH
35403: LD_INT 0
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: LD_INT 1
35412: NEG
35413: PUSH
35414: LD_INT 1
35416: NEG
35417: PUSH
35418: EMPTY
35419: LIST
35420: LIST
35421: PUSH
35422: LD_INT 2
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: LD_INT 2
35434: NEG
35435: PUSH
35436: LD_INT 1
35438: NEG
35439: PUSH
35440: EMPTY
35441: LIST
35442: LIST
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35455: LD_ADDR_VAR 0 39
35459: PUSH
35460: LD_INT 0
35462: PUSH
35463: LD_INT 0
35465: PUSH
35466: EMPTY
35467: LIST
35468: LIST
35469: PUSH
35470: LD_INT 0
35472: PUSH
35473: LD_INT 1
35475: NEG
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PUSH
35481: LD_INT 1
35483: PUSH
35484: LD_INT 0
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: PUSH
35491: LD_INT 1
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 0
35503: PUSH
35504: LD_INT 1
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: LD_INT 1
35513: NEG
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: LD_INT 1
35524: NEG
35525: PUSH
35526: LD_INT 1
35528: NEG
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 1
35536: NEG
35537: PUSH
35538: LD_INT 2
35540: NEG
35541: PUSH
35542: EMPTY
35543: LIST
35544: LIST
35545: PUSH
35546: LD_INT 1
35548: PUSH
35549: LD_INT 2
35551: PUSH
35552: EMPTY
35553: LIST
35554: LIST
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: LIST
35565: LIST
35566: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35567: LD_ADDR_VAR 0 40
35571: PUSH
35572: LD_INT 0
35574: PUSH
35575: LD_INT 0
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 0
35584: PUSH
35585: LD_INT 1
35587: NEG
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 1
35595: PUSH
35596: LD_INT 0
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 1
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 0
35615: PUSH
35616: LD_INT 1
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 1
35625: NEG
35626: PUSH
35627: LD_INT 0
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 1
35636: NEG
35637: PUSH
35638: LD_INT 1
35640: NEG
35641: PUSH
35642: EMPTY
35643: LIST
35644: LIST
35645: PUSH
35646: LD_INT 1
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: EMPTY
35654: LIST
35655: LIST
35656: PUSH
35657: LD_INT 1
35659: NEG
35660: PUSH
35661: LD_INT 1
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: LIST
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35679: LD_ADDR_VAR 0 41
35683: PUSH
35684: LD_INT 0
35686: PUSH
35687: LD_INT 0
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: LD_INT 1
35699: NEG
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 1
35707: PUSH
35708: LD_INT 0
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 1
35717: PUSH
35718: LD_INT 1
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 0
35727: PUSH
35728: LD_INT 1
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 1
35737: NEG
35738: PUSH
35739: LD_INT 0
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 1
35748: NEG
35749: PUSH
35750: LD_INT 1
35752: NEG
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 1
35760: NEG
35761: PUSH
35762: LD_INT 2
35764: NEG
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 1
35772: PUSH
35773: LD_INT 1
35775: NEG
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: PUSH
35781: LD_INT 2
35783: PUSH
35784: LD_INT 0
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 2
35793: PUSH
35794: LD_INT 1
35796: PUSH
35797: EMPTY
35798: LIST
35799: LIST
35800: PUSH
35801: LD_INT 2
35803: PUSH
35804: LD_INT 2
35806: PUSH
35807: EMPTY
35808: LIST
35809: LIST
35810: PUSH
35811: LD_INT 1
35813: PUSH
35814: LD_INT 2
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 1
35823: NEG
35824: PUSH
35825: LD_INT 1
35827: PUSH
35828: EMPTY
35829: LIST
35830: LIST
35831: PUSH
35832: LD_INT 2
35834: NEG
35835: PUSH
35836: LD_INT 0
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PUSH
35843: LD_INT 2
35845: NEG
35846: PUSH
35847: LD_INT 1
35849: NEG
35850: PUSH
35851: EMPTY
35852: LIST
35853: LIST
35854: PUSH
35855: LD_INT 2
35857: NEG
35858: PUSH
35859: LD_INT 2
35861: NEG
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 2
35869: NEG
35870: PUSH
35871: LD_INT 3
35873: NEG
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: PUSH
35879: LD_INT 2
35881: PUSH
35882: LD_INT 1
35884: NEG
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: PUSH
35890: LD_INT 3
35892: PUSH
35893: LD_INT 0
35895: PUSH
35896: EMPTY
35897: LIST
35898: LIST
35899: PUSH
35900: LD_INT 3
35902: PUSH
35903: LD_INT 1
35905: PUSH
35906: EMPTY
35907: LIST
35908: LIST
35909: PUSH
35910: LD_INT 3
35912: PUSH
35913: LD_INT 2
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: PUSH
35920: LD_INT 3
35922: PUSH
35923: LD_INT 3
35925: PUSH
35926: EMPTY
35927: LIST
35928: LIST
35929: PUSH
35930: LD_INT 2
35932: PUSH
35933: LD_INT 3
35935: PUSH
35936: EMPTY
35937: LIST
35938: LIST
35939: PUSH
35940: LD_INT 2
35942: NEG
35943: PUSH
35944: LD_INT 1
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: LD_INT 3
35953: NEG
35954: PUSH
35955: LD_INT 0
35957: PUSH
35958: EMPTY
35959: LIST
35960: LIST
35961: PUSH
35962: LD_INT 3
35964: NEG
35965: PUSH
35966: LD_INT 1
35968: NEG
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: LD_INT 3
35976: NEG
35977: PUSH
35978: LD_INT 2
35980: NEG
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 3
35988: NEG
35989: PUSH
35990: LD_INT 3
35992: NEG
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: EMPTY
35999: LIST
36000: LIST
36001: LIST
36002: LIST
36003: LIST
36004: LIST
36005: LIST
36006: LIST
36007: LIST
36008: LIST
36009: LIST
36010: LIST
36011: LIST
36012: LIST
36013: LIST
36014: LIST
36015: LIST
36016: LIST
36017: LIST
36018: LIST
36019: LIST
36020: LIST
36021: LIST
36022: LIST
36023: LIST
36024: LIST
36025: LIST
36026: LIST
36027: LIST
36028: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36029: LD_ADDR_VAR 0 42
36033: PUSH
36034: LD_INT 0
36036: PUSH
36037: LD_INT 0
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 0
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 1
36057: PUSH
36058: LD_INT 0
36060: PUSH
36061: EMPTY
36062: LIST
36063: LIST
36064: PUSH
36065: LD_INT 1
36067: PUSH
36068: LD_INT 1
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 0
36077: PUSH
36078: LD_INT 1
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 1
36087: NEG
36088: PUSH
36089: LD_INT 0
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 1
36098: NEG
36099: PUSH
36100: LD_INT 1
36102: NEG
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 1
36110: NEG
36111: PUSH
36112: LD_INT 2
36114: NEG
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: LD_INT 0
36122: PUSH
36123: LD_INT 2
36125: NEG
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 1
36133: PUSH
36134: LD_INT 1
36136: NEG
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: LD_INT 2
36144: PUSH
36145: LD_INT 1
36147: PUSH
36148: EMPTY
36149: LIST
36150: LIST
36151: PUSH
36152: LD_INT 2
36154: PUSH
36155: LD_INT 2
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PUSH
36162: LD_INT 1
36164: PUSH
36165: LD_INT 2
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: PUSH
36172: LD_INT 0
36174: PUSH
36175: LD_INT 2
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PUSH
36182: LD_INT 1
36184: NEG
36185: PUSH
36186: LD_INT 1
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: PUSH
36193: LD_INT 2
36195: NEG
36196: PUSH
36197: LD_INT 1
36199: NEG
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: LD_INT 2
36207: NEG
36208: PUSH
36209: LD_INT 2
36211: NEG
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: LD_INT 2
36219: NEG
36220: PUSH
36221: LD_INT 3
36223: NEG
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: PUSH
36229: LD_INT 1
36231: NEG
36232: PUSH
36233: LD_INT 3
36235: NEG
36236: PUSH
36237: EMPTY
36238: LIST
36239: LIST
36240: PUSH
36241: LD_INT 0
36243: PUSH
36244: LD_INT 3
36246: NEG
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 1
36254: PUSH
36255: LD_INT 2
36257: NEG
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 3
36265: PUSH
36266: LD_INT 2
36268: PUSH
36269: EMPTY
36270: LIST
36271: LIST
36272: PUSH
36273: LD_INT 3
36275: PUSH
36276: LD_INT 3
36278: PUSH
36279: EMPTY
36280: LIST
36281: LIST
36282: PUSH
36283: LD_INT 2
36285: PUSH
36286: LD_INT 3
36288: PUSH
36289: EMPTY
36290: LIST
36291: LIST
36292: PUSH
36293: LD_INT 1
36295: PUSH
36296: LD_INT 3
36298: PUSH
36299: EMPTY
36300: LIST
36301: LIST
36302: PUSH
36303: LD_INT 0
36305: PUSH
36306: LD_INT 3
36308: PUSH
36309: EMPTY
36310: LIST
36311: LIST
36312: PUSH
36313: LD_INT 1
36315: NEG
36316: PUSH
36317: LD_INT 2
36319: PUSH
36320: EMPTY
36321: LIST
36322: LIST
36323: PUSH
36324: LD_INT 3
36326: NEG
36327: PUSH
36328: LD_INT 2
36330: NEG
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 3
36338: NEG
36339: PUSH
36340: LD_INT 3
36342: NEG
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: LIST
36352: LIST
36353: LIST
36354: LIST
36355: LIST
36356: LIST
36357: LIST
36358: LIST
36359: LIST
36360: LIST
36361: LIST
36362: LIST
36363: LIST
36364: LIST
36365: LIST
36366: LIST
36367: LIST
36368: LIST
36369: LIST
36370: LIST
36371: LIST
36372: LIST
36373: LIST
36374: LIST
36375: LIST
36376: LIST
36377: LIST
36378: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36379: LD_ADDR_VAR 0 43
36383: PUSH
36384: LD_INT 0
36386: PUSH
36387: LD_INT 0
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: LD_INT 0
36396: PUSH
36397: LD_INT 1
36399: NEG
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 1
36407: PUSH
36408: LD_INT 0
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 1
36417: PUSH
36418: LD_INT 1
36420: PUSH
36421: EMPTY
36422: LIST
36423: LIST
36424: PUSH
36425: LD_INT 0
36427: PUSH
36428: LD_INT 1
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 1
36437: NEG
36438: PUSH
36439: LD_INT 0
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 1
36448: NEG
36449: PUSH
36450: LD_INT 1
36452: NEG
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 1
36460: NEG
36461: PUSH
36462: LD_INT 2
36464: NEG
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: LD_INT 0
36472: PUSH
36473: LD_INT 2
36475: NEG
36476: PUSH
36477: EMPTY
36478: LIST
36479: LIST
36480: PUSH
36481: LD_INT 1
36483: PUSH
36484: LD_INT 1
36486: NEG
36487: PUSH
36488: EMPTY
36489: LIST
36490: LIST
36491: PUSH
36492: LD_INT 2
36494: PUSH
36495: LD_INT 0
36497: PUSH
36498: EMPTY
36499: LIST
36500: LIST
36501: PUSH
36502: LD_INT 2
36504: PUSH
36505: LD_INT 1
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: PUSH
36512: LD_INT 1
36514: PUSH
36515: LD_INT 2
36517: PUSH
36518: EMPTY
36519: LIST
36520: LIST
36521: PUSH
36522: LD_INT 0
36524: PUSH
36525: LD_INT 2
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 1
36534: NEG
36535: PUSH
36536: LD_INT 1
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: LD_INT 2
36545: NEG
36546: PUSH
36547: LD_INT 0
36549: PUSH
36550: EMPTY
36551: LIST
36552: LIST
36553: PUSH
36554: LD_INT 2
36556: NEG
36557: PUSH
36558: LD_INT 1
36560: NEG
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 1
36568: NEG
36569: PUSH
36570: LD_INT 3
36572: NEG
36573: PUSH
36574: EMPTY
36575: LIST
36576: LIST
36577: PUSH
36578: LD_INT 0
36580: PUSH
36581: LD_INT 3
36583: NEG
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: PUSH
36589: LD_INT 1
36591: PUSH
36592: LD_INT 2
36594: NEG
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 2
36602: PUSH
36603: LD_INT 1
36605: NEG
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PUSH
36611: LD_INT 3
36613: PUSH
36614: LD_INT 0
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: PUSH
36621: LD_INT 3
36623: PUSH
36624: LD_INT 1
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 1
36633: PUSH
36634: LD_INT 3
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 0
36643: PUSH
36644: LD_INT 3
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: PUSH
36651: LD_INT 1
36653: NEG
36654: PUSH
36655: LD_INT 2
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: LD_INT 2
36664: NEG
36665: PUSH
36666: LD_INT 1
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: LD_INT 3
36675: NEG
36676: PUSH
36677: LD_INT 0
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: LD_INT 3
36686: NEG
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: LIST
36700: LIST
36701: LIST
36702: LIST
36703: LIST
36704: LIST
36705: LIST
36706: LIST
36707: LIST
36708: LIST
36709: LIST
36710: LIST
36711: LIST
36712: LIST
36713: LIST
36714: LIST
36715: LIST
36716: LIST
36717: LIST
36718: LIST
36719: LIST
36720: LIST
36721: LIST
36722: LIST
36723: LIST
36724: LIST
36725: LIST
36726: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36727: LD_ADDR_VAR 0 44
36731: PUSH
36732: LD_INT 0
36734: PUSH
36735: LD_INT 0
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 0
36744: PUSH
36745: LD_INT 1
36747: NEG
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: PUSH
36753: LD_INT 1
36755: PUSH
36756: LD_INT 0
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PUSH
36763: LD_INT 1
36765: PUSH
36766: LD_INT 1
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: LD_INT 0
36775: PUSH
36776: LD_INT 1
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 1
36785: NEG
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 1
36796: NEG
36797: PUSH
36798: LD_INT 1
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 1
36808: NEG
36809: PUSH
36810: LD_INT 2
36812: NEG
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 1
36820: PUSH
36821: LD_INT 1
36823: NEG
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 2
36831: PUSH
36832: LD_INT 0
36834: PUSH
36835: EMPTY
36836: LIST
36837: LIST
36838: PUSH
36839: LD_INT 2
36841: PUSH
36842: LD_INT 1
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PUSH
36849: LD_INT 2
36851: PUSH
36852: LD_INT 2
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PUSH
36859: LD_INT 1
36861: PUSH
36862: LD_INT 2
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 1
36871: NEG
36872: PUSH
36873: LD_INT 1
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 2
36882: NEG
36883: PUSH
36884: LD_INT 0
36886: PUSH
36887: EMPTY
36888: LIST
36889: LIST
36890: PUSH
36891: LD_INT 2
36893: NEG
36894: PUSH
36895: LD_INT 1
36897: NEG
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 2
36905: NEG
36906: PUSH
36907: LD_INT 2
36909: NEG
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 2
36917: NEG
36918: PUSH
36919: LD_INT 3
36921: NEG
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 2
36929: PUSH
36930: LD_INT 1
36932: NEG
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 3
36940: PUSH
36941: LD_INT 0
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 3
36950: PUSH
36951: LD_INT 1
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: PUSH
36958: LD_INT 3
36960: PUSH
36961: LD_INT 2
36963: PUSH
36964: EMPTY
36965: LIST
36966: LIST
36967: PUSH
36968: LD_INT 3
36970: PUSH
36971: LD_INT 3
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: LD_INT 2
36980: PUSH
36981: LD_INT 3
36983: PUSH
36984: EMPTY
36985: LIST
36986: LIST
36987: PUSH
36988: LD_INT 2
36990: NEG
36991: PUSH
36992: LD_INT 1
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: PUSH
36999: LD_INT 3
37001: NEG
37002: PUSH
37003: LD_INT 0
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PUSH
37010: LD_INT 3
37012: NEG
37013: PUSH
37014: LD_INT 1
37016: NEG
37017: PUSH
37018: EMPTY
37019: LIST
37020: LIST
37021: PUSH
37022: LD_INT 3
37024: NEG
37025: PUSH
37026: LD_INT 2
37028: NEG
37029: PUSH
37030: EMPTY
37031: LIST
37032: LIST
37033: PUSH
37034: LD_INT 3
37036: NEG
37037: PUSH
37038: LD_INT 3
37040: NEG
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: LIST
37050: LIST
37051: LIST
37052: LIST
37053: LIST
37054: LIST
37055: LIST
37056: LIST
37057: LIST
37058: LIST
37059: LIST
37060: LIST
37061: LIST
37062: LIST
37063: LIST
37064: LIST
37065: LIST
37066: LIST
37067: LIST
37068: LIST
37069: LIST
37070: LIST
37071: LIST
37072: LIST
37073: LIST
37074: LIST
37075: LIST
37076: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37077: LD_ADDR_VAR 0 45
37081: PUSH
37082: LD_INT 0
37084: PUSH
37085: LD_INT 0
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 0
37094: PUSH
37095: LD_INT 1
37097: NEG
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 1
37105: PUSH
37106: LD_INT 0
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 1
37115: PUSH
37116: LD_INT 1
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 0
37125: PUSH
37126: LD_INT 1
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 1
37135: NEG
37136: PUSH
37137: LD_INT 0
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PUSH
37144: LD_INT 1
37146: NEG
37147: PUSH
37148: LD_INT 1
37150: NEG
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 1
37158: NEG
37159: PUSH
37160: LD_INT 2
37162: NEG
37163: PUSH
37164: EMPTY
37165: LIST
37166: LIST
37167: PUSH
37168: LD_INT 0
37170: PUSH
37171: LD_INT 2
37173: NEG
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 1
37181: PUSH
37182: LD_INT 1
37184: NEG
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: PUSH
37190: LD_INT 2
37192: PUSH
37193: LD_INT 1
37195: PUSH
37196: EMPTY
37197: LIST
37198: LIST
37199: PUSH
37200: LD_INT 2
37202: PUSH
37203: LD_INT 2
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 1
37212: PUSH
37213: LD_INT 2
37215: PUSH
37216: EMPTY
37217: LIST
37218: LIST
37219: PUSH
37220: LD_INT 0
37222: PUSH
37223: LD_INT 2
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: PUSH
37230: LD_INT 1
37232: NEG
37233: PUSH
37234: LD_INT 1
37236: PUSH
37237: EMPTY
37238: LIST
37239: LIST
37240: PUSH
37241: LD_INT 2
37243: NEG
37244: PUSH
37245: LD_INT 1
37247: NEG
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: PUSH
37253: LD_INT 2
37255: NEG
37256: PUSH
37257: LD_INT 2
37259: NEG
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: LD_INT 2
37267: NEG
37268: PUSH
37269: LD_INT 3
37271: NEG
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: LD_INT 1
37279: NEG
37280: PUSH
37281: LD_INT 3
37283: NEG
37284: PUSH
37285: EMPTY
37286: LIST
37287: LIST
37288: PUSH
37289: LD_INT 0
37291: PUSH
37292: LD_INT 3
37294: NEG
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 1
37302: PUSH
37303: LD_INT 2
37305: NEG
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: LD_INT 3
37313: PUSH
37314: LD_INT 2
37316: PUSH
37317: EMPTY
37318: LIST
37319: LIST
37320: PUSH
37321: LD_INT 3
37323: PUSH
37324: LD_INT 3
37326: PUSH
37327: EMPTY
37328: LIST
37329: LIST
37330: PUSH
37331: LD_INT 2
37333: PUSH
37334: LD_INT 3
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: LD_INT 1
37343: PUSH
37344: LD_INT 3
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 0
37353: PUSH
37354: LD_INT 3
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: LD_INT 1
37363: NEG
37364: PUSH
37365: LD_INT 2
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PUSH
37372: LD_INT 3
37374: NEG
37375: PUSH
37376: LD_INT 2
37378: NEG
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: LD_INT 3
37386: NEG
37387: PUSH
37388: LD_INT 3
37390: NEG
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: LIST
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37427: LD_ADDR_VAR 0 46
37431: PUSH
37432: LD_INT 0
37434: PUSH
37435: LD_INT 0
37437: PUSH
37438: EMPTY
37439: LIST
37440: LIST
37441: PUSH
37442: LD_INT 0
37444: PUSH
37445: LD_INT 1
37447: NEG
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: LD_INT 1
37455: PUSH
37456: LD_INT 0
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 1
37465: PUSH
37466: LD_INT 1
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: LD_INT 0
37475: PUSH
37476: LD_INT 1
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 1
37485: NEG
37486: PUSH
37487: LD_INT 0
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: PUSH
37494: LD_INT 1
37496: NEG
37497: PUSH
37498: LD_INT 1
37500: NEG
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 1
37508: NEG
37509: PUSH
37510: LD_INT 2
37512: NEG
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 0
37520: PUSH
37521: LD_INT 2
37523: NEG
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 1
37531: PUSH
37532: LD_INT 1
37534: NEG
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 2
37542: PUSH
37543: LD_INT 0
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 2
37552: PUSH
37553: LD_INT 1
37555: PUSH
37556: EMPTY
37557: LIST
37558: LIST
37559: PUSH
37560: LD_INT 1
37562: PUSH
37563: LD_INT 2
37565: PUSH
37566: EMPTY
37567: LIST
37568: LIST
37569: PUSH
37570: LD_INT 0
37572: PUSH
37573: LD_INT 2
37575: PUSH
37576: EMPTY
37577: LIST
37578: LIST
37579: PUSH
37580: LD_INT 1
37582: NEG
37583: PUSH
37584: LD_INT 1
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: LD_INT 2
37593: NEG
37594: PUSH
37595: LD_INT 0
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: LD_INT 2
37604: NEG
37605: PUSH
37606: LD_INT 1
37608: NEG
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: LD_INT 1
37616: NEG
37617: PUSH
37618: LD_INT 3
37620: NEG
37621: PUSH
37622: EMPTY
37623: LIST
37624: LIST
37625: PUSH
37626: LD_INT 0
37628: PUSH
37629: LD_INT 3
37631: NEG
37632: PUSH
37633: EMPTY
37634: LIST
37635: LIST
37636: PUSH
37637: LD_INT 1
37639: PUSH
37640: LD_INT 2
37642: NEG
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 2
37650: PUSH
37651: LD_INT 1
37653: NEG
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: PUSH
37659: LD_INT 3
37661: PUSH
37662: LD_INT 0
37664: PUSH
37665: EMPTY
37666: LIST
37667: LIST
37668: PUSH
37669: LD_INT 3
37671: PUSH
37672: LD_INT 1
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 1
37681: PUSH
37682: LD_INT 3
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 0
37691: PUSH
37692: LD_INT 3
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 1
37701: NEG
37702: PUSH
37703: LD_INT 2
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 2
37712: NEG
37713: PUSH
37714: LD_INT 1
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: PUSH
37721: LD_INT 3
37723: NEG
37724: PUSH
37725: LD_INT 0
37727: PUSH
37728: EMPTY
37729: LIST
37730: LIST
37731: PUSH
37732: LD_INT 3
37734: NEG
37735: PUSH
37736: LD_INT 1
37738: NEG
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: LIST
37748: LIST
37749: LIST
37750: LIST
37751: LIST
37752: LIST
37753: LIST
37754: LIST
37755: LIST
37756: LIST
37757: LIST
37758: LIST
37759: LIST
37760: LIST
37761: LIST
37762: LIST
37763: LIST
37764: LIST
37765: LIST
37766: LIST
37767: LIST
37768: LIST
37769: LIST
37770: LIST
37771: LIST
37772: LIST
37773: LIST
37774: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37775: LD_ADDR_VAR 0 47
37779: PUSH
37780: LD_INT 0
37782: PUSH
37783: LD_INT 0
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 0
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 1
37803: PUSH
37804: LD_INT 0
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 1
37813: PUSH
37814: LD_INT 1
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 0
37823: PUSH
37824: LD_INT 1
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 1
37833: NEG
37834: PUSH
37835: LD_INT 0
37837: PUSH
37838: EMPTY
37839: LIST
37840: LIST
37841: PUSH
37842: LD_INT 1
37844: NEG
37845: PUSH
37846: LD_INT 1
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: NEG
37857: PUSH
37858: LD_INT 2
37860: NEG
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: PUSH
37866: LD_INT 0
37868: PUSH
37869: LD_INT 2
37871: NEG
37872: PUSH
37873: EMPTY
37874: LIST
37875: LIST
37876: PUSH
37877: LD_INT 1
37879: PUSH
37880: LD_INT 1
37882: NEG
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PUSH
37888: LD_INT 2
37890: NEG
37891: PUSH
37892: LD_INT 1
37894: NEG
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 2
37902: NEG
37903: PUSH
37904: LD_INT 2
37906: NEG
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: LIST
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: LIST
37924: LIST
37925: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37926: LD_ADDR_VAR 0 48
37930: PUSH
37931: LD_INT 0
37933: PUSH
37934: LD_INT 0
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: LD_INT 1
37946: NEG
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: PUSH
37955: LD_INT 0
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 1
37964: PUSH
37965: LD_INT 1
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 0
37974: PUSH
37975: LD_INT 1
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: PUSH
37982: LD_INT 1
37984: NEG
37985: PUSH
37986: LD_INT 0
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: PUSH
37993: LD_INT 1
37995: NEG
37996: PUSH
37997: LD_INT 1
37999: NEG
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 1
38007: NEG
38008: PUSH
38009: LD_INT 2
38011: NEG
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PUSH
38017: LD_INT 0
38019: PUSH
38020: LD_INT 2
38022: NEG
38023: PUSH
38024: EMPTY
38025: LIST
38026: LIST
38027: PUSH
38028: LD_INT 1
38030: PUSH
38031: LD_INT 1
38033: NEG
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 2
38041: PUSH
38042: LD_INT 0
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: LD_INT 2
38051: PUSH
38052: LD_INT 1
38054: PUSH
38055: EMPTY
38056: LIST
38057: LIST
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38073: LD_ADDR_VAR 0 49
38077: PUSH
38078: LD_INT 0
38080: PUSH
38081: LD_INT 0
38083: PUSH
38084: EMPTY
38085: LIST
38086: LIST
38087: PUSH
38088: LD_INT 0
38090: PUSH
38091: LD_INT 1
38093: NEG
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 1
38101: PUSH
38102: LD_INT 0
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: PUSH
38109: LD_INT 1
38111: PUSH
38112: LD_INT 1
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 0
38121: PUSH
38122: LD_INT 1
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: PUSH
38129: LD_INT 1
38131: NEG
38132: PUSH
38133: LD_INT 0
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 1
38142: NEG
38143: PUSH
38144: LD_INT 1
38146: NEG
38147: PUSH
38148: EMPTY
38149: LIST
38150: LIST
38151: PUSH
38152: LD_INT 1
38154: PUSH
38155: LD_INT 1
38157: NEG
38158: PUSH
38159: EMPTY
38160: LIST
38161: LIST
38162: PUSH
38163: LD_INT 2
38165: PUSH
38166: LD_INT 0
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: PUSH
38173: LD_INT 2
38175: PUSH
38176: LD_INT 1
38178: PUSH
38179: EMPTY
38180: LIST
38181: LIST
38182: PUSH
38183: LD_INT 2
38185: PUSH
38186: LD_INT 2
38188: PUSH
38189: EMPTY
38190: LIST
38191: LIST
38192: PUSH
38193: LD_INT 1
38195: PUSH
38196: LD_INT 2
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: LIST
38207: LIST
38208: LIST
38209: LIST
38210: LIST
38211: LIST
38212: LIST
38213: LIST
38214: LIST
38215: LIST
38216: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38217: LD_ADDR_VAR 0 50
38221: PUSH
38222: LD_INT 0
38224: PUSH
38225: LD_INT 0
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: LD_INT 0
38234: PUSH
38235: LD_INT 1
38237: NEG
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 1
38245: PUSH
38246: LD_INT 0
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: PUSH
38253: LD_INT 1
38255: PUSH
38256: LD_INT 1
38258: PUSH
38259: EMPTY
38260: LIST
38261: LIST
38262: PUSH
38263: LD_INT 0
38265: PUSH
38266: LD_INT 1
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: LD_INT 1
38275: NEG
38276: PUSH
38277: LD_INT 0
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 1
38286: NEG
38287: PUSH
38288: LD_INT 1
38290: NEG
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 2
38298: PUSH
38299: LD_INT 1
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 2
38308: PUSH
38309: LD_INT 2
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: PUSH
38316: LD_INT 1
38318: PUSH
38319: LD_INT 2
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: PUSH
38326: LD_INT 0
38328: PUSH
38329: LD_INT 2
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 1
38338: NEG
38339: PUSH
38340: LD_INT 1
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: LIST
38351: LIST
38352: LIST
38353: LIST
38354: LIST
38355: LIST
38356: LIST
38357: LIST
38358: LIST
38359: LIST
38360: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38361: LD_ADDR_VAR 0 51
38365: PUSH
38366: LD_INT 0
38368: PUSH
38369: LD_INT 0
38371: PUSH
38372: EMPTY
38373: LIST
38374: LIST
38375: PUSH
38376: LD_INT 0
38378: PUSH
38379: LD_INT 1
38381: NEG
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: LD_INT 0
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 1
38399: PUSH
38400: LD_INT 1
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: PUSH
38407: LD_INT 0
38409: PUSH
38410: LD_INT 1
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: PUSH
38417: LD_INT 1
38419: NEG
38420: PUSH
38421: LD_INT 0
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 1
38430: NEG
38431: PUSH
38432: LD_INT 1
38434: NEG
38435: PUSH
38436: EMPTY
38437: LIST
38438: LIST
38439: PUSH
38440: LD_INT 1
38442: PUSH
38443: LD_INT 2
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 0
38452: PUSH
38453: LD_INT 2
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 1
38462: NEG
38463: PUSH
38464: LD_INT 1
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: PUSH
38471: LD_INT 2
38473: NEG
38474: PUSH
38475: LD_INT 0
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 2
38484: NEG
38485: PUSH
38486: LD_INT 1
38488: NEG
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38508: LD_ADDR_VAR 0 52
38512: PUSH
38513: LD_INT 0
38515: PUSH
38516: LD_INT 0
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 0
38525: PUSH
38526: LD_INT 1
38528: NEG
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PUSH
38534: LD_INT 1
38536: PUSH
38537: LD_INT 0
38539: PUSH
38540: EMPTY
38541: LIST
38542: LIST
38543: PUSH
38544: LD_INT 1
38546: PUSH
38547: LD_INT 1
38549: PUSH
38550: EMPTY
38551: LIST
38552: LIST
38553: PUSH
38554: LD_INT 0
38556: PUSH
38557: LD_INT 1
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 1
38566: NEG
38567: PUSH
38568: LD_INT 0
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 1
38577: NEG
38578: PUSH
38579: LD_INT 1
38581: NEG
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: LD_INT 1
38589: NEG
38590: PUSH
38591: LD_INT 2
38593: NEG
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 1
38601: NEG
38602: PUSH
38603: LD_INT 1
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 2
38612: NEG
38613: PUSH
38614: LD_INT 0
38616: PUSH
38617: EMPTY
38618: LIST
38619: LIST
38620: PUSH
38621: LD_INT 2
38623: NEG
38624: PUSH
38625: LD_INT 1
38627: NEG
38628: PUSH
38629: EMPTY
38630: LIST
38631: LIST
38632: PUSH
38633: LD_INT 2
38635: NEG
38636: PUSH
38637: LD_INT 2
38639: NEG
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: LIST
38649: LIST
38650: LIST
38651: LIST
38652: LIST
38653: LIST
38654: LIST
38655: LIST
38656: LIST
38657: LIST
38658: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38659: LD_ADDR_VAR 0 53
38663: PUSH
38664: LD_INT 0
38666: PUSH
38667: LD_INT 0
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: LD_INT 0
38676: PUSH
38677: LD_INT 1
38679: NEG
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: LD_INT 1
38687: PUSH
38688: LD_INT 0
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: LD_INT 1
38697: PUSH
38698: LD_INT 1
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: LD_INT 0
38707: PUSH
38708: LD_INT 1
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 1
38717: NEG
38718: PUSH
38719: LD_INT 0
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 1
38728: NEG
38729: PUSH
38730: LD_INT 1
38732: NEG
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 1
38740: NEG
38741: PUSH
38742: LD_INT 2
38744: NEG
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: LD_INT 0
38752: PUSH
38753: LD_INT 2
38755: NEG
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PUSH
38761: LD_INT 1
38763: PUSH
38764: LD_INT 1
38766: NEG
38767: PUSH
38768: EMPTY
38769: LIST
38770: LIST
38771: PUSH
38772: LD_INT 2
38774: PUSH
38775: LD_INT 0
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 2
38784: PUSH
38785: LD_INT 1
38787: PUSH
38788: EMPTY
38789: LIST
38790: LIST
38791: PUSH
38792: LD_INT 2
38794: PUSH
38795: LD_INT 2
38797: PUSH
38798: EMPTY
38799: LIST
38800: LIST
38801: PUSH
38802: LD_INT 1
38804: PUSH
38805: LD_INT 2
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 0
38814: PUSH
38815: LD_INT 2
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: PUSH
38822: LD_INT 1
38824: NEG
38825: PUSH
38826: LD_INT 1
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 2
38835: NEG
38836: PUSH
38837: LD_INT 0
38839: PUSH
38840: EMPTY
38841: LIST
38842: LIST
38843: PUSH
38844: LD_INT 2
38846: NEG
38847: PUSH
38848: LD_INT 1
38850: NEG
38851: PUSH
38852: EMPTY
38853: LIST
38854: LIST
38855: PUSH
38856: LD_INT 2
38858: NEG
38859: PUSH
38860: LD_INT 2
38862: NEG
38863: PUSH
38864: EMPTY
38865: LIST
38866: LIST
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38889: LD_ADDR_VAR 0 54
38893: PUSH
38894: LD_INT 0
38896: PUSH
38897: LD_INT 0
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PUSH
38904: LD_INT 0
38906: PUSH
38907: LD_INT 1
38909: NEG
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PUSH
38915: LD_INT 1
38917: PUSH
38918: LD_INT 0
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: LD_INT 1
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: PUSH
38935: LD_INT 0
38937: PUSH
38938: LD_INT 1
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 1
38947: NEG
38948: PUSH
38949: LD_INT 0
38951: PUSH
38952: EMPTY
38953: LIST
38954: LIST
38955: PUSH
38956: LD_INT 1
38958: NEG
38959: PUSH
38960: LD_INT 1
38962: NEG
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: LD_INT 1
38970: NEG
38971: PUSH
38972: LD_INT 2
38974: NEG
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 0
38982: PUSH
38983: LD_INT 2
38985: NEG
38986: PUSH
38987: EMPTY
38988: LIST
38989: LIST
38990: PUSH
38991: LD_INT 1
38993: PUSH
38994: LD_INT 1
38996: NEG
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 2
39004: PUSH
39005: LD_INT 0
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 2
39014: PUSH
39015: LD_INT 1
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 2
39024: PUSH
39025: LD_INT 2
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PUSH
39032: LD_INT 1
39034: PUSH
39035: LD_INT 2
39037: PUSH
39038: EMPTY
39039: LIST
39040: LIST
39041: PUSH
39042: LD_INT 0
39044: PUSH
39045: LD_INT 2
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: PUSH
39052: LD_INT 1
39054: NEG
39055: PUSH
39056: LD_INT 1
39058: PUSH
39059: EMPTY
39060: LIST
39061: LIST
39062: PUSH
39063: LD_INT 2
39065: NEG
39066: PUSH
39067: LD_INT 0
39069: PUSH
39070: EMPTY
39071: LIST
39072: LIST
39073: PUSH
39074: LD_INT 2
39076: NEG
39077: PUSH
39078: LD_INT 1
39080: NEG
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: LD_INT 2
39088: NEG
39089: PUSH
39090: LD_INT 2
39092: NEG
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: LIST
39102: LIST
39103: LIST
39104: LIST
39105: LIST
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: LIST
39112: LIST
39113: LIST
39114: LIST
39115: LIST
39116: LIST
39117: LIST
39118: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39119: LD_ADDR_VAR 0 55
39123: PUSH
39124: LD_INT 0
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 0
39136: PUSH
39137: LD_INT 1
39139: NEG
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 1
39147: PUSH
39148: LD_INT 0
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 1
39157: PUSH
39158: LD_INT 1
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 0
39167: PUSH
39168: LD_INT 1
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: LD_INT 1
39177: NEG
39178: PUSH
39179: LD_INT 0
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: PUSH
39186: LD_INT 1
39188: NEG
39189: PUSH
39190: LD_INT 1
39192: NEG
39193: PUSH
39194: EMPTY
39195: LIST
39196: LIST
39197: PUSH
39198: LD_INT 1
39200: NEG
39201: PUSH
39202: LD_INT 2
39204: NEG
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 0
39212: PUSH
39213: LD_INT 2
39215: NEG
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 1
39223: PUSH
39224: LD_INT 1
39226: NEG
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: LD_INT 2
39234: PUSH
39235: LD_INT 0
39237: PUSH
39238: EMPTY
39239: LIST
39240: LIST
39241: PUSH
39242: LD_INT 2
39244: PUSH
39245: LD_INT 1
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 2
39254: PUSH
39255: LD_INT 2
39257: PUSH
39258: EMPTY
39259: LIST
39260: LIST
39261: PUSH
39262: LD_INT 1
39264: PUSH
39265: LD_INT 2
39267: PUSH
39268: EMPTY
39269: LIST
39270: LIST
39271: PUSH
39272: LD_INT 0
39274: PUSH
39275: LD_INT 2
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 1
39284: NEG
39285: PUSH
39286: LD_INT 1
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 2
39295: NEG
39296: PUSH
39297: LD_INT 0
39299: PUSH
39300: EMPTY
39301: LIST
39302: LIST
39303: PUSH
39304: LD_INT 2
39306: NEG
39307: PUSH
39308: LD_INT 1
39310: NEG
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PUSH
39316: LD_INT 2
39318: NEG
39319: PUSH
39320: LD_INT 2
39322: NEG
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: LIST
39332: LIST
39333: LIST
39334: LIST
39335: LIST
39336: LIST
39337: LIST
39338: LIST
39339: LIST
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39349: LD_ADDR_VAR 0 56
39353: PUSH
39354: LD_INT 0
39356: PUSH
39357: LD_INT 0
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: LD_INT 0
39366: PUSH
39367: LD_INT 1
39369: NEG
39370: PUSH
39371: EMPTY
39372: LIST
39373: LIST
39374: PUSH
39375: LD_INT 1
39377: PUSH
39378: LD_INT 0
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 1
39387: PUSH
39388: LD_INT 1
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PUSH
39395: LD_INT 0
39397: PUSH
39398: LD_INT 1
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: LD_INT 1
39407: NEG
39408: PUSH
39409: LD_INT 0
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PUSH
39416: LD_INT 1
39418: NEG
39419: PUSH
39420: LD_INT 1
39422: NEG
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 1
39430: NEG
39431: PUSH
39432: LD_INT 2
39434: NEG
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 0
39442: PUSH
39443: LD_INT 2
39445: NEG
39446: PUSH
39447: EMPTY
39448: LIST
39449: LIST
39450: PUSH
39451: LD_INT 1
39453: PUSH
39454: LD_INT 1
39456: NEG
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: LD_INT 2
39464: PUSH
39465: LD_INT 0
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 2
39474: PUSH
39475: LD_INT 1
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 2
39484: PUSH
39485: LD_INT 2
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 1
39494: PUSH
39495: LD_INT 2
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 0
39504: PUSH
39505: LD_INT 2
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 1
39514: NEG
39515: PUSH
39516: LD_INT 1
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 2
39525: NEG
39526: PUSH
39527: LD_INT 0
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: PUSH
39534: LD_INT 2
39536: NEG
39537: PUSH
39538: LD_INT 1
39540: NEG
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 2
39548: NEG
39549: PUSH
39550: LD_INT 2
39552: NEG
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: LIST
39562: LIST
39563: LIST
39564: LIST
39565: LIST
39566: LIST
39567: LIST
39568: LIST
39569: LIST
39570: LIST
39571: LIST
39572: LIST
39573: LIST
39574: LIST
39575: LIST
39576: LIST
39577: LIST
39578: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39579: LD_ADDR_VAR 0 57
39583: PUSH
39584: LD_INT 0
39586: PUSH
39587: LD_INT 0
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 0
39596: PUSH
39597: LD_INT 1
39599: NEG
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 1
39607: PUSH
39608: LD_INT 0
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 1
39617: PUSH
39618: LD_INT 1
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 0
39627: PUSH
39628: LD_INT 1
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 1
39637: NEG
39638: PUSH
39639: LD_INT 0
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 1
39648: NEG
39649: PUSH
39650: LD_INT 1
39652: NEG
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 1
39660: NEG
39661: PUSH
39662: LD_INT 2
39664: NEG
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: PUSH
39670: LD_INT 0
39672: PUSH
39673: LD_INT 2
39675: NEG
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 1
39683: PUSH
39684: LD_INT 1
39686: NEG
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 2
39694: PUSH
39695: LD_INT 0
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 2
39704: PUSH
39705: LD_INT 1
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 2
39714: PUSH
39715: LD_INT 2
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 1
39724: PUSH
39725: LD_INT 2
39727: PUSH
39728: EMPTY
39729: LIST
39730: LIST
39731: PUSH
39732: LD_INT 0
39734: PUSH
39735: LD_INT 2
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: PUSH
39742: LD_INT 1
39744: NEG
39745: PUSH
39746: LD_INT 1
39748: PUSH
39749: EMPTY
39750: LIST
39751: LIST
39752: PUSH
39753: LD_INT 2
39755: NEG
39756: PUSH
39757: LD_INT 0
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: LD_INT 2
39766: NEG
39767: PUSH
39768: LD_INT 1
39770: NEG
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PUSH
39776: LD_INT 2
39778: NEG
39779: PUSH
39780: LD_INT 2
39782: NEG
39783: PUSH
39784: EMPTY
39785: LIST
39786: LIST
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: LIST
39792: LIST
39793: LIST
39794: LIST
39795: LIST
39796: LIST
39797: LIST
39798: LIST
39799: LIST
39800: LIST
39801: LIST
39802: LIST
39803: LIST
39804: LIST
39805: LIST
39806: LIST
39807: LIST
39808: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39809: LD_ADDR_VAR 0 58
39813: PUSH
39814: LD_INT 0
39816: PUSH
39817: LD_INT 0
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 0
39826: PUSH
39827: LD_INT 1
39829: NEG
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: LD_INT 1
39837: PUSH
39838: LD_INT 0
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 1
39847: PUSH
39848: LD_INT 1
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 0
39857: PUSH
39858: LD_INT 1
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: LD_INT 1
39867: NEG
39868: PUSH
39869: LD_INT 0
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: LD_INT 1
39878: NEG
39879: PUSH
39880: LD_INT 1
39882: NEG
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: LD_INT 1
39890: NEG
39891: PUSH
39892: LD_INT 2
39894: NEG
39895: PUSH
39896: EMPTY
39897: LIST
39898: LIST
39899: PUSH
39900: LD_INT 0
39902: PUSH
39903: LD_INT 2
39905: NEG
39906: PUSH
39907: EMPTY
39908: LIST
39909: LIST
39910: PUSH
39911: LD_INT 1
39913: PUSH
39914: LD_INT 1
39916: NEG
39917: PUSH
39918: EMPTY
39919: LIST
39920: LIST
39921: PUSH
39922: LD_INT 2
39924: PUSH
39925: LD_INT 0
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 2
39934: PUSH
39935: LD_INT 1
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 2
39944: PUSH
39945: LD_INT 2
39947: PUSH
39948: EMPTY
39949: LIST
39950: LIST
39951: PUSH
39952: LD_INT 1
39954: PUSH
39955: LD_INT 2
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PUSH
39962: LD_INT 0
39964: PUSH
39965: LD_INT 2
39967: PUSH
39968: EMPTY
39969: LIST
39970: LIST
39971: PUSH
39972: LD_INT 1
39974: NEG
39975: PUSH
39976: LD_INT 1
39978: PUSH
39979: EMPTY
39980: LIST
39981: LIST
39982: PUSH
39983: LD_INT 2
39985: NEG
39986: PUSH
39987: LD_INT 0
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 2
39996: NEG
39997: PUSH
39998: LD_INT 1
40000: NEG
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: LD_INT 2
40008: NEG
40009: PUSH
40010: LD_INT 2
40012: NEG
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: LIST
40022: LIST
40023: LIST
40024: LIST
40025: LIST
40026: LIST
40027: LIST
40028: LIST
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: LIST
40037: LIST
40038: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40039: LD_ADDR_VAR 0 59
40043: PUSH
40044: LD_INT 0
40046: PUSH
40047: LD_INT 0
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 0
40056: PUSH
40057: LD_INT 1
40059: NEG
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: LD_INT 1
40067: PUSH
40068: LD_INT 0
40070: PUSH
40071: EMPTY
40072: LIST
40073: LIST
40074: PUSH
40075: LD_INT 1
40077: PUSH
40078: LD_INT 1
40080: PUSH
40081: EMPTY
40082: LIST
40083: LIST
40084: PUSH
40085: LD_INT 0
40087: PUSH
40088: LD_INT 1
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: LD_INT 1
40097: NEG
40098: PUSH
40099: LD_INT 0
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: PUSH
40106: LD_INT 1
40108: NEG
40109: PUSH
40110: LD_INT 1
40112: NEG
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: LIST
40122: LIST
40123: LIST
40124: LIST
40125: LIST
40126: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40127: LD_ADDR_VAR 0 60
40131: PUSH
40132: LD_INT 0
40134: PUSH
40135: LD_INT 0
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 0
40144: PUSH
40145: LD_INT 1
40147: NEG
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: LD_INT 1
40155: PUSH
40156: LD_INT 0
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: PUSH
40163: LD_INT 1
40165: PUSH
40166: LD_INT 1
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: LD_INT 0
40175: PUSH
40176: LD_INT 1
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 1
40185: NEG
40186: PUSH
40187: LD_INT 0
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: PUSH
40194: LD_INT 1
40196: NEG
40197: PUSH
40198: LD_INT 1
40200: NEG
40201: PUSH
40202: EMPTY
40203: LIST
40204: LIST
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: LIST
40210: LIST
40211: LIST
40212: LIST
40213: LIST
40214: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40215: LD_ADDR_VAR 0 61
40219: PUSH
40220: LD_INT 0
40222: PUSH
40223: LD_INT 0
40225: PUSH
40226: EMPTY
40227: LIST
40228: LIST
40229: PUSH
40230: LD_INT 0
40232: PUSH
40233: LD_INT 1
40235: NEG
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 1
40243: PUSH
40244: LD_INT 0
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 1
40253: PUSH
40254: LD_INT 1
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 0
40263: PUSH
40264: LD_INT 1
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: LD_INT 1
40273: NEG
40274: PUSH
40275: LD_INT 0
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: PUSH
40282: LD_INT 1
40284: NEG
40285: PUSH
40286: LD_INT 1
40288: NEG
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: LIST
40298: LIST
40299: LIST
40300: LIST
40301: LIST
40302: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40303: LD_ADDR_VAR 0 62
40307: PUSH
40308: LD_INT 0
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: EMPTY
40315: LIST
40316: LIST
40317: PUSH
40318: LD_INT 0
40320: PUSH
40321: LD_INT 1
40323: NEG
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: LD_INT 1
40331: PUSH
40332: LD_INT 0
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: PUSH
40339: LD_INT 1
40341: PUSH
40342: LD_INT 1
40344: PUSH
40345: EMPTY
40346: LIST
40347: LIST
40348: PUSH
40349: LD_INT 0
40351: PUSH
40352: LD_INT 1
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PUSH
40359: LD_INT 1
40361: NEG
40362: PUSH
40363: LD_INT 0
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 1
40372: NEG
40373: PUSH
40374: LD_INT 1
40376: NEG
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40391: LD_ADDR_VAR 0 63
40395: PUSH
40396: LD_INT 0
40398: PUSH
40399: LD_INT 0
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PUSH
40406: LD_INT 0
40408: PUSH
40409: LD_INT 1
40411: NEG
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: PUSH
40417: LD_INT 1
40419: PUSH
40420: LD_INT 0
40422: PUSH
40423: EMPTY
40424: LIST
40425: LIST
40426: PUSH
40427: LD_INT 1
40429: PUSH
40430: LD_INT 1
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 0
40439: PUSH
40440: LD_INT 1
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 1
40449: NEG
40450: PUSH
40451: LD_INT 0
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: LD_INT 1
40460: NEG
40461: PUSH
40462: LD_INT 1
40464: NEG
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: LIST
40474: LIST
40475: LIST
40476: LIST
40477: LIST
40478: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40479: LD_ADDR_VAR 0 64
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: LD_INT 0
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 0
40496: PUSH
40497: LD_INT 1
40499: NEG
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 1
40507: PUSH
40508: LD_INT 0
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 1
40517: PUSH
40518: LD_INT 1
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 0
40527: PUSH
40528: LD_INT 1
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: LD_INT 1
40537: NEG
40538: PUSH
40539: LD_INT 0
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 1
40548: NEG
40549: PUSH
40550: LD_INT 1
40552: NEG
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: EMPTY
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: ST_TO_ADDR
// end ; 1 :
40567: GO 46464
40569: LD_INT 1
40571: DOUBLE
40572: EQUAL
40573: IFTRUE 40577
40575: GO 43200
40577: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40578: LD_ADDR_VAR 0 11
40582: PUSH
40583: LD_INT 1
40585: NEG
40586: PUSH
40587: LD_INT 3
40589: NEG
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: LD_INT 0
40597: PUSH
40598: LD_INT 3
40600: NEG
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: PUSH
40606: LD_INT 1
40608: PUSH
40609: LD_INT 2
40611: NEG
40612: PUSH
40613: EMPTY
40614: LIST
40615: LIST
40616: PUSH
40617: EMPTY
40618: LIST
40619: LIST
40620: LIST
40621: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40622: LD_ADDR_VAR 0 12
40626: PUSH
40627: LD_INT 2
40629: PUSH
40630: LD_INT 1
40632: NEG
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 3
40640: PUSH
40641: LD_INT 0
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 3
40650: PUSH
40651: LD_INT 1
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: LIST
40662: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40663: LD_ADDR_VAR 0 13
40667: PUSH
40668: LD_INT 3
40670: PUSH
40671: LD_INT 2
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: PUSH
40678: LD_INT 3
40680: PUSH
40681: LD_INT 3
40683: PUSH
40684: EMPTY
40685: LIST
40686: LIST
40687: PUSH
40688: LD_INT 2
40690: PUSH
40691: LD_INT 3
40693: PUSH
40694: EMPTY
40695: LIST
40696: LIST
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: LIST
40702: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40703: LD_ADDR_VAR 0 14
40707: PUSH
40708: LD_INT 1
40710: PUSH
40711: LD_INT 3
40713: PUSH
40714: EMPTY
40715: LIST
40716: LIST
40717: PUSH
40718: LD_INT 0
40720: PUSH
40721: LD_INT 3
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: LD_INT 1
40730: NEG
40731: PUSH
40732: LD_INT 2
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: LIST
40743: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40744: LD_ADDR_VAR 0 15
40748: PUSH
40749: LD_INT 2
40751: NEG
40752: PUSH
40753: LD_INT 1
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: LD_INT 3
40762: NEG
40763: PUSH
40764: LD_INT 0
40766: PUSH
40767: EMPTY
40768: LIST
40769: LIST
40770: PUSH
40771: LD_INT 3
40773: NEG
40774: PUSH
40775: LD_INT 1
40777: NEG
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: PUSH
40783: EMPTY
40784: LIST
40785: LIST
40786: LIST
40787: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40788: LD_ADDR_VAR 0 16
40792: PUSH
40793: LD_INT 2
40795: NEG
40796: PUSH
40797: LD_INT 3
40799: NEG
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 3
40807: NEG
40808: PUSH
40809: LD_INT 2
40811: NEG
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 3
40819: NEG
40820: PUSH
40821: LD_INT 3
40823: NEG
40824: PUSH
40825: EMPTY
40826: LIST
40827: LIST
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: LIST
40833: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40834: LD_ADDR_VAR 0 17
40838: PUSH
40839: LD_INT 1
40841: NEG
40842: PUSH
40843: LD_INT 3
40845: NEG
40846: PUSH
40847: EMPTY
40848: LIST
40849: LIST
40850: PUSH
40851: LD_INT 0
40853: PUSH
40854: LD_INT 3
40856: NEG
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PUSH
40862: LD_INT 1
40864: PUSH
40865: LD_INT 2
40867: NEG
40868: PUSH
40869: EMPTY
40870: LIST
40871: LIST
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: LIST
40877: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40878: LD_ADDR_VAR 0 18
40882: PUSH
40883: LD_INT 2
40885: PUSH
40886: LD_INT 1
40888: NEG
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: PUSH
40894: LD_INT 3
40896: PUSH
40897: LD_INT 0
40899: PUSH
40900: EMPTY
40901: LIST
40902: LIST
40903: PUSH
40904: LD_INT 3
40906: PUSH
40907: LD_INT 1
40909: PUSH
40910: EMPTY
40911: LIST
40912: LIST
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: LIST
40918: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40919: LD_ADDR_VAR 0 19
40923: PUSH
40924: LD_INT 3
40926: PUSH
40927: LD_INT 2
40929: PUSH
40930: EMPTY
40931: LIST
40932: LIST
40933: PUSH
40934: LD_INT 3
40936: PUSH
40937: LD_INT 3
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 2
40946: PUSH
40947: LD_INT 3
40949: PUSH
40950: EMPTY
40951: LIST
40952: LIST
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: LIST
40958: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40959: LD_ADDR_VAR 0 20
40963: PUSH
40964: LD_INT 1
40966: PUSH
40967: LD_INT 3
40969: PUSH
40970: EMPTY
40971: LIST
40972: LIST
40973: PUSH
40974: LD_INT 0
40976: PUSH
40977: LD_INT 3
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PUSH
40984: LD_INT 1
40986: NEG
40987: PUSH
40988: LD_INT 2
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: LIST
40999: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41000: LD_ADDR_VAR 0 21
41004: PUSH
41005: LD_INT 2
41007: NEG
41008: PUSH
41009: LD_INT 1
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 3
41018: NEG
41019: PUSH
41020: LD_INT 0
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 3
41029: NEG
41030: PUSH
41031: LD_INT 1
41033: NEG
41034: PUSH
41035: EMPTY
41036: LIST
41037: LIST
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: LIST
41043: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41044: LD_ADDR_VAR 0 22
41048: PUSH
41049: LD_INT 2
41051: NEG
41052: PUSH
41053: LD_INT 3
41055: NEG
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PUSH
41061: LD_INT 3
41063: NEG
41064: PUSH
41065: LD_INT 2
41067: NEG
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: PUSH
41073: LD_INT 3
41075: NEG
41076: PUSH
41077: LD_INT 3
41079: NEG
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: LIST
41089: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41090: LD_ADDR_VAR 0 23
41094: PUSH
41095: LD_INT 0
41097: PUSH
41098: LD_INT 3
41100: NEG
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: LD_INT 1
41108: NEG
41109: PUSH
41110: LD_INT 4
41112: NEG
41113: PUSH
41114: EMPTY
41115: LIST
41116: LIST
41117: PUSH
41118: LD_INT 1
41120: PUSH
41121: LD_INT 3
41123: NEG
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: EMPTY
41130: LIST
41131: LIST
41132: LIST
41133: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41134: LD_ADDR_VAR 0 24
41138: PUSH
41139: LD_INT 3
41141: PUSH
41142: LD_INT 0
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: LD_INT 3
41151: PUSH
41152: LD_INT 1
41154: NEG
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: PUSH
41160: LD_INT 4
41162: PUSH
41163: LD_INT 1
41165: PUSH
41166: EMPTY
41167: LIST
41168: LIST
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: LIST
41174: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41175: LD_ADDR_VAR 0 25
41179: PUSH
41180: LD_INT 3
41182: PUSH
41183: LD_INT 3
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 4
41192: PUSH
41193: LD_INT 3
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: LD_INT 3
41202: PUSH
41203: LD_INT 4
41205: PUSH
41206: EMPTY
41207: LIST
41208: LIST
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: LIST
41214: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41215: LD_ADDR_VAR 0 26
41219: PUSH
41220: LD_INT 0
41222: PUSH
41223: LD_INT 3
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: PUSH
41230: LD_INT 1
41232: PUSH
41233: LD_INT 4
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 1
41242: NEG
41243: PUSH
41244: LD_INT 3
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: LIST
41255: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41256: LD_ADDR_VAR 0 27
41260: PUSH
41261: LD_INT 3
41263: NEG
41264: PUSH
41265: LD_INT 0
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PUSH
41272: LD_INT 3
41274: NEG
41275: PUSH
41276: LD_INT 1
41278: PUSH
41279: EMPTY
41280: LIST
41281: LIST
41282: PUSH
41283: LD_INT 4
41285: NEG
41286: PUSH
41287: LD_INT 1
41289: NEG
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: LIST
41299: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41300: LD_ADDR_VAR 0 28
41304: PUSH
41305: LD_INT 3
41307: NEG
41308: PUSH
41309: LD_INT 3
41311: NEG
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PUSH
41317: LD_INT 3
41319: NEG
41320: PUSH
41321: LD_INT 4
41323: NEG
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: PUSH
41329: LD_INT 4
41331: NEG
41332: PUSH
41333: LD_INT 3
41335: NEG
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: LIST
41345: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41346: LD_ADDR_VAR 0 29
41350: PUSH
41351: LD_INT 1
41353: NEG
41354: PUSH
41355: LD_INT 3
41357: NEG
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 0
41365: PUSH
41366: LD_INT 3
41368: NEG
41369: PUSH
41370: EMPTY
41371: LIST
41372: LIST
41373: PUSH
41374: LD_INT 1
41376: PUSH
41377: LD_INT 2
41379: NEG
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 1
41387: NEG
41388: PUSH
41389: LD_INT 4
41391: NEG
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 0
41399: PUSH
41400: LD_INT 4
41402: NEG
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 1
41410: PUSH
41411: LD_INT 3
41413: NEG
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 1
41421: NEG
41422: PUSH
41423: LD_INT 5
41425: NEG
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: LD_INT 0
41433: PUSH
41434: LD_INT 5
41436: NEG
41437: PUSH
41438: EMPTY
41439: LIST
41440: LIST
41441: PUSH
41442: LD_INT 1
41444: PUSH
41445: LD_INT 4
41447: NEG
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: LD_INT 1
41455: NEG
41456: PUSH
41457: LD_INT 6
41459: NEG
41460: PUSH
41461: EMPTY
41462: LIST
41463: LIST
41464: PUSH
41465: LD_INT 0
41467: PUSH
41468: LD_INT 6
41470: NEG
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: LD_INT 1
41478: PUSH
41479: LD_INT 5
41481: NEG
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: LIST
41491: LIST
41492: LIST
41493: LIST
41494: LIST
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: LIST
41500: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41501: LD_ADDR_VAR 0 30
41505: PUSH
41506: LD_INT 2
41508: PUSH
41509: LD_INT 1
41511: NEG
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PUSH
41517: LD_INT 3
41519: PUSH
41520: LD_INT 0
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 3
41529: PUSH
41530: LD_INT 1
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: PUSH
41537: LD_INT 3
41539: PUSH
41540: LD_INT 1
41542: NEG
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: PUSH
41548: LD_INT 4
41550: PUSH
41551: LD_INT 0
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: PUSH
41558: LD_INT 4
41560: PUSH
41561: LD_INT 1
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: LD_INT 4
41570: PUSH
41571: LD_INT 1
41573: NEG
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 5
41581: PUSH
41582: LD_INT 0
41584: PUSH
41585: EMPTY
41586: LIST
41587: LIST
41588: PUSH
41589: LD_INT 5
41591: PUSH
41592: LD_INT 1
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 5
41601: PUSH
41602: LD_INT 1
41604: NEG
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 6
41612: PUSH
41613: LD_INT 0
41615: PUSH
41616: EMPTY
41617: LIST
41618: LIST
41619: PUSH
41620: LD_INT 6
41622: PUSH
41623: LD_INT 1
41625: PUSH
41626: EMPTY
41627: LIST
41628: LIST
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: LIST
41634: LIST
41635: LIST
41636: LIST
41637: LIST
41638: LIST
41639: LIST
41640: LIST
41641: LIST
41642: LIST
41643: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41644: LD_ADDR_VAR 0 31
41648: PUSH
41649: LD_INT 3
41651: PUSH
41652: LD_INT 2
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: LD_INT 3
41661: PUSH
41662: LD_INT 3
41664: PUSH
41665: EMPTY
41666: LIST
41667: LIST
41668: PUSH
41669: LD_INT 2
41671: PUSH
41672: LD_INT 3
41674: PUSH
41675: EMPTY
41676: LIST
41677: LIST
41678: PUSH
41679: LD_INT 4
41681: PUSH
41682: LD_INT 3
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: LD_INT 4
41691: PUSH
41692: LD_INT 4
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: PUSH
41699: LD_INT 3
41701: PUSH
41702: LD_INT 4
41704: PUSH
41705: EMPTY
41706: LIST
41707: LIST
41708: PUSH
41709: LD_INT 5
41711: PUSH
41712: LD_INT 4
41714: PUSH
41715: EMPTY
41716: LIST
41717: LIST
41718: PUSH
41719: LD_INT 5
41721: PUSH
41722: LD_INT 5
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: PUSH
41729: LD_INT 4
41731: PUSH
41732: LD_INT 5
41734: PUSH
41735: EMPTY
41736: LIST
41737: LIST
41738: PUSH
41739: LD_INT 6
41741: PUSH
41742: LD_INT 5
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 6
41751: PUSH
41752: LD_INT 6
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: PUSH
41759: LD_INT 5
41761: PUSH
41762: LD_INT 6
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: LIST
41773: LIST
41774: LIST
41775: LIST
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: LIST
41781: LIST
41782: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41783: LD_ADDR_VAR 0 32
41787: PUSH
41788: LD_INT 1
41790: PUSH
41791: LD_INT 3
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 0
41800: PUSH
41801: LD_INT 3
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PUSH
41808: LD_INT 1
41810: NEG
41811: PUSH
41812: LD_INT 2
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: PUSH
41819: LD_INT 1
41821: PUSH
41822: LD_INT 4
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PUSH
41829: LD_INT 0
41831: PUSH
41832: LD_INT 4
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 1
41841: NEG
41842: PUSH
41843: LD_INT 3
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: LD_INT 1
41852: PUSH
41853: LD_INT 5
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: PUSH
41860: LD_INT 0
41862: PUSH
41863: LD_INT 5
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: LD_INT 1
41872: NEG
41873: PUSH
41874: LD_INT 4
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: PUSH
41881: LD_INT 1
41883: PUSH
41884: LD_INT 6
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: PUSH
41891: LD_INT 0
41893: PUSH
41894: LD_INT 6
41896: PUSH
41897: EMPTY
41898: LIST
41899: LIST
41900: PUSH
41901: LD_INT 1
41903: NEG
41904: PUSH
41905: LD_INT 5
41907: PUSH
41908: EMPTY
41909: LIST
41910: LIST
41911: PUSH
41912: EMPTY
41913: LIST
41914: LIST
41915: LIST
41916: LIST
41917: LIST
41918: LIST
41919: LIST
41920: LIST
41921: LIST
41922: LIST
41923: LIST
41924: LIST
41925: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41926: LD_ADDR_VAR 0 33
41930: PUSH
41931: LD_INT 2
41933: NEG
41934: PUSH
41935: LD_INT 1
41937: PUSH
41938: EMPTY
41939: LIST
41940: LIST
41941: PUSH
41942: LD_INT 3
41944: NEG
41945: PUSH
41946: LD_INT 0
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 3
41955: NEG
41956: PUSH
41957: LD_INT 1
41959: NEG
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 3
41967: NEG
41968: PUSH
41969: LD_INT 1
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PUSH
41976: LD_INT 4
41978: NEG
41979: PUSH
41980: LD_INT 0
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: PUSH
41987: LD_INT 4
41989: NEG
41990: PUSH
41991: LD_INT 1
41993: NEG
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 4
42001: NEG
42002: PUSH
42003: LD_INT 1
42005: PUSH
42006: EMPTY
42007: LIST
42008: LIST
42009: PUSH
42010: LD_INT 5
42012: NEG
42013: PUSH
42014: LD_INT 0
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: PUSH
42021: LD_INT 5
42023: NEG
42024: PUSH
42025: LD_INT 1
42027: NEG
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: LD_INT 5
42035: NEG
42036: PUSH
42037: LD_INT 1
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PUSH
42044: LD_INT 6
42046: NEG
42047: PUSH
42048: LD_INT 0
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: PUSH
42055: LD_INT 6
42057: NEG
42058: PUSH
42059: LD_INT 1
42061: NEG
42062: PUSH
42063: EMPTY
42064: LIST
42065: LIST
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: LIST
42071: LIST
42072: LIST
42073: LIST
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42081: LD_ADDR_VAR 0 34
42085: PUSH
42086: LD_INT 2
42088: NEG
42089: PUSH
42090: LD_INT 3
42092: NEG
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 3
42100: NEG
42101: PUSH
42102: LD_INT 2
42104: NEG
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 3
42112: NEG
42113: PUSH
42114: LD_INT 3
42116: NEG
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PUSH
42122: LD_INT 3
42124: NEG
42125: PUSH
42126: LD_INT 4
42128: NEG
42129: PUSH
42130: EMPTY
42131: LIST
42132: LIST
42133: PUSH
42134: LD_INT 4
42136: NEG
42137: PUSH
42138: LD_INT 3
42140: NEG
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: PUSH
42146: LD_INT 4
42148: NEG
42149: PUSH
42150: LD_INT 4
42152: NEG
42153: PUSH
42154: EMPTY
42155: LIST
42156: LIST
42157: PUSH
42158: LD_INT 4
42160: NEG
42161: PUSH
42162: LD_INT 5
42164: NEG
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: LD_INT 5
42172: NEG
42173: PUSH
42174: LD_INT 4
42176: NEG
42177: PUSH
42178: EMPTY
42179: LIST
42180: LIST
42181: PUSH
42182: LD_INT 5
42184: NEG
42185: PUSH
42186: LD_INT 5
42188: NEG
42189: PUSH
42190: EMPTY
42191: LIST
42192: LIST
42193: PUSH
42194: LD_INT 5
42196: NEG
42197: PUSH
42198: LD_INT 6
42200: NEG
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: PUSH
42206: LD_INT 6
42208: NEG
42209: PUSH
42210: LD_INT 5
42212: NEG
42213: PUSH
42214: EMPTY
42215: LIST
42216: LIST
42217: PUSH
42218: LD_INT 6
42220: NEG
42221: PUSH
42222: LD_INT 6
42224: NEG
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: LIST
42234: LIST
42235: LIST
42236: LIST
42237: LIST
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42244: LD_ADDR_VAR 0 41
42248: PUSH
42249: LD_INT 0
42251: PUSH
42252: LD_INT 2
42254: NEG
42255: PUSH
42256: EMPTY
42257: LIST
42258: LIST
42259: PUSH
42260: LD_INT 1
42262: NEG
42263: PUSH
42264: LD_INT 3
42266: NEG
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: PUSH
42272: LD_INT 1
42274: PUSH
42275: LD_INT 2
42277: NEG
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: LIST
42287: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42288: LD_ADDR_VAR 0 42
42292: PUSH
42293: LD_INT 2
42295: PUSH
42296: LD_INT 0
42298: PUSH
42299: EMPTY
42300: LIST
42301: LIST
42302: PUSH
42303: LD_INT 2
42305: PUSH
42306: LD_INT 1
42308: NEG
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 3
42316: PUSH
42317: LD_INT 1
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: LIST
42328: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42329: LD_ADDR_VAR 0 43
42333: PUSH
42334: LD_INT 2
42336: PUSH
42337: LD_INT 2
42339: PUSH
42340: EMPTY
42341: LIST
42342: LIST
42343: PUSH
42344: LD_INT 3
42346: PUSH
42347: LD_INT 2
42349: PUSH
42350: EMPTY
42351: LIST
42352: LIST
42353: PUSH
42354: LD_INT 2
42356: PUSH
42357: LD_INT 3
42359: PUSH
42360: EMPTY
42361: LIST
42362: LIST
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: LIST
42368: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42369: LD_ADDR_VAR 0 44
42373: PUSH
42374: LD_INT 0
42376: PUSH
42377: LD_INT 2
42379: PUSH
42380: EMPTY
42381: LIST
42382: LIST
42383: PUSH
42384: LD_INT 1
42386: PUSH
42387: LD_INT 3
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 1
42396: NEG
42397: PUSH
42398: LD_INT 2
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: LIST
42409: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42410: LD_ADDR_VAR 0 45
42414: PUSH
42415: LD_INT 2
42417: NEG
42418: PUSH
42419: LD_INT 0
42421: PUSH
42422: EMPTY
42423: LIST
42424: LIST
42425: PUSH
42426: LD_INT 2
42428: NEG
42429: PUSH
42430: LD_INT 1
42432: PUSH
42433: EMPTY
42434: LIST
42435: LIST
42436: PUSH
42437: LD_INT 3
42439: NEG
42440: PUSH
42441: LD_INT 1
42443: NEG
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: LIST
42453: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42454: LD_ADDR_VAR 0 46
42458: PUSH
42459: LD_INT 2
42461: NEG
42462: PUSH
42463: LD_INT 2
42465: NEG
42466: PUSH
42467: EMPTY
42468: LIST
42469: LIST
42470: PUSH
42471: LD_INT 2
42473: NEG
42474: PUSH
42475: LD_INT 3
42477: NEG
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 3
42485: NEG
42486: PUSH
42487: LD_INT 2
42489: NEG
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: LIST
42499: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42500: LD_ADDR_VAR 0 47
42504: PUSH
42505: LD_INT 2
42507: NEG
42508: PUSH
42509: LD_INT 3
42511: NEG
42512: PUSH
42513: EMPTY
42514: LIST
42515: LIST
42516: PUSH
42517: LD_INT 1
42519: NEG
42520: PUSH
42521: LD_INT 3
42523: NEG
42524: PUSH
42525: EMPTY
42526: LIST
42527: LIST
42528: PUSH
42529: EMPTY
42530: LIST
42531: LIST
42532: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42533: LD_ADDR_VAR 0 48
42537: PUSH
42538: LD_INT 1
42540: PUSH
42541: LD_INT 2
42543: NEG
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 2
42551: PUSH
42552: LD_INT 1
42554: NEG
42555: PUSH
42556: EMPTY
42557: LIST
42558: LIST
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42564: LD_ADDR_VAR 0 49
42568: PUSH
42569: LD_INT 3
42571: PUSH
42572: LD_INT 1
42574: PUSH
42575: EMPTY
42576: LIST
42577: LIST
42578: PUSH
42579: LD_INT 3
42581: PUSH
42582: LD_INT 2
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42593: LD_ADDR_VAR 0 50
42597: PUSH
42598: LD_INT 2
42600: PUSH
42601: LD_INT 3
42603: PUSH
42604: EMPTY
42605: LIST
42606: LIST
42607: PUSH
42608: LD_INT 1
42610: PUSH
42611: LD_INT 3
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42622: LD_ADDR_VAR 0 51
42626: PUSH
42627: LD_INT 1
42629: NEG
42630: PUSH
42631: LD_INT 2
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: PUSH
42638: LD_INT 2
42640: NEG
42641: PUSH
42642: LD_INT 1
42644: PUSH
42645: EMPTY
42646: LIST
42647: LIST
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42653: LD_ADDR_VAR 0 52
42657: PUSH
42658: LD_INT 3
42660: NEG
42661: PUSH
42662: LD_INT 1
42664: NEG
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: PUSH
42670: LD_INT 3
42672: NEG
42673: PUSH
42674: LD_INT 2
42676: NEG
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42686: LD_ADDR_VAR 0 53
42690: PUSH
42691: LD_INT 1
42693: NEG
42694: PUSH
42695: LD_INT 3
42697: NEG
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: PUSH
42703: LD_INT 0
42705: PUSH
42706: LD_INT 3
42708: NEG
42709: PUSH
42710: EMPTY
42711: LIST
42712: LIST
42713: PUSH
42714: LD_INT 1
42716: PUSH
42717: LD_INT 2
42719: NEG
42720: PUSH
42721: EMPTY
42722: LIST
42723: LIST
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: LIST
42729: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42730: LD_ADDR_VAR 0 54
42734: PUSH
42735: LD_INT 2
42737: PUSH
42738: LD_INT 1
42740: NEG
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: PUSH
42746: LD_INT 3
42748: PUSH
42749: LD_INT 0
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: PUSH
42756: LD_INT 3
42758: PUSH
42759: LD_INT 1
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: LIST
42770: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42771: LD_ADDR_VAR 0 55
42775: PUSH
42776: LD_INT 3
42778: PUSH
42779: LD_INT 2
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: PUSH
42786: LD_INT 3
42788: PUSH
42789: LD_INT 3
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: PUSH
42796: LD_INT 2
42798: PUSH
42799: LD_INT 3
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: PUSH
42806: EMPTY
42807: LIST
42808: LIST
42809: LIST
42810: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42811: LD_ADDR_VAR 0 56
42815: PUSH
42816: LD_INT 1
42818: PUSH
42819: LD_INT 3
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 0
42828: PUSH
42829: LD_INT 3
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 1
42838: NEG
42839: PUSH
42840: LD_INT 2
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: PUSH
42847: EMPTY
42848: LIST
42849: LIST
42850: LIST
42851: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42852: LD_ADDR_VAR 0 57
42856: PUSH
42857: LD_INT 2
42859: NEG
42860: PUSH
42861: LD_INT 1
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 3
42870: NEG
42871: PUSH
42872: LD_INT 0
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: PUSH
42879: LD_INT 3
42881: NEG
42882: PUSH
42883: LD_INT 1
42885: NEG
42886: PUSH
42887: EMPTY
42888: LIST
42889: LIST
42890: PUSH
42891: EMPTY
42892: LIST
42893: LIST
42894: LIST
42895: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42896: LD_ADDR_VAR 0 58
42900: PUSH
42901: LD_INT 2
42903: NEG
42904: PUSH
42905: LD_INT 3
42907: NEG
42908: PUSH
42909: EMPTY
42910: LIST
42911: LIST
42912: PUSH
42913: LD_INT 3
42915: NEG
42916: PUSH
42917: LD_INT 2
42919: NEG
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: PUSH
42925: LD_INT 3
42927: NEG
42928: PUSH
42929: LD_INT 3
42931: NEG
42932: PUSH
42933: EMPTY
42934: LIST
42935: LIST
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: LIST
42941: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42942: LD_ADDR_VAR 0 59
42946: PUSH
42947: LD_INT 1
42949: NEG
42950: PUSH
42951: LD_INT 2
42953: NEG
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: LD_INT 0
42961: PUSH
42962: LD_INT 2
42964: NEG
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: PUSH
42970: LD_INT 1
42972: PUSH
42973: LD_INT 1
42975: NEG
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: LIST
42985: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42986: LD_ADDR_VAR 0 60
42990: PUSH
42991: LD_INT 1
42993: PUSH
42994: LD_INT 1
42996: NEG
42997: PUSH
42998: EMPTY
42999: LIST
43000: LIST
43001: PUSH
43002: LD_INT 2
43004: PUSH
43005: LD_INT 0
43007: PUSH
43008: EMPTY
43009: LIST
43010: LIST
43011: PUSH
43012: LD_INT 2
43014: PUSH
43015: LD_INT 1
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: LIST
43026: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43027: LD_ADDR_VAR 0 61
43031: PUSH
43032: LD_INT 2
43034: PUSH
43035: LD_INT 1
43037: PUSH
43038: EMPTY
43039: LIST
43040: LIST
43041: PUSH
43042: LD_INT 2
43044: PUSH
43045: LD_INT 2
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: LD_INT 1
43054: PUSH
43055: LD_INT 2
43057: PUSH
43058: EMPTY
43059: LIST
43060: LIST
43061: PUSH
43062: EMPTY
43063: LIST
43064: LIST
43065: LIST
43066: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43067: LD_ADDR_VAR 0 62
43071: PUSH
43072: LD_INT 1
43074: PUSH
43075: LD_INT 2
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 0
43084: PUSH
43085: LD_INT 2
43087: PUSH
43088: EMPTY
43089: LIST
43090: LIST
43091: PUSH
43092: LD_INT 1
43094: NEG
43095: PUSH
43096: LD_INT 1
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: LIST
43107: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43108: LD_ADDR_VAR 0 63
43112: PUSH
43113: LD_INT 1
43115: NEG
43116: PUSH
43117: LD_INT 1
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 2
43126: NEG
43127: PUSH
43128: LD_INT 0
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: LD_INT 2
43137: NEG
43138: PUSH
43139: LD_INT 1
43141: NEG
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: EMPTY
43148: LIST
43149: LIST
43150: LIST
43151: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43152: LD_ADDR_VAR 0 64
43156: PUSH
43157: LD_INT 1
43159: NEG
43160: PUSH
43161: LD_INT 2
43163: NEG
43164: PUSH
43165: EMPTY
43166: LIST
43167: LIST
43168: PUSH
43169: LD_INT 2
43171: NEG
43172: PUSH
43173: LD_INT 1
43175: NEG
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: PUSH
43181: LD_INT 2
43183: NEG
43184: PUSH
43185: LD_INT 2
43187: NEG
43188: PUSH
43189: EMPTY
43190: LIST
43191: LIST
43192: PUSH
43193: EMPTY
43194: LIST
43195: LIST
43196: LIST
43197: ST_TO_ADDR
// end ; 2 :
43198: GO 46464
43200: LD_INT 2
43202: DOUBLE
43203: EQUAL
43204: IFTRUE 43208
43206: GO 46463
43208: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43209: LD_ADDR_VAR 0 29
43213: PUSH
43214: LD_INT 4
43216: PUSH
43217: LD_INT 0
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: PUSH
43224: LD_INT 4
43226: PUSH
43227: LD_INT 1
43229: NEG
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: PUSH
43235: LD_INT 5
43237: PUSH
43238: LD_INT 0
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: PUSH
43245: LD_INT 5
43247: PUSH
43248: LD_INT 1
43250: PUSH
43251: EMPTY
43252: LIST
43253: LIST
43254: PUSH
43255: LD_INT 4
43257: PUSH
43258: LD_INT 1
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PUSH
43265: LD_INT 3
43267: PUSH
43268: LD_INT 0
43270: PUSH
43271: EMPTY
43272: LIST
43273: LIST
43274: PUSH
43275: LD_INT 3
43277: PUSH
43278: LD_INT 1
43280: NEG
43281: PUSH
43282: EMPTY
43283: LIST
43284: LIST
43285: PUSH
43286: LD_INT 3
43288: PUSH
43289: LD_INT 2
43291: NEG
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PUSH
43297: LD_INT 5
43299: PUSH
43300: LD_INT 2
43302: PUSH
43303: EMPTY
43304: LIST
43305: LIST
43306: PUSH
43307: LD_INT 3
43309: PUSH
43310: LD_INT 3
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: PUSH
43317: LD_INT 3
43319: PUSH
43320: LD_INT 2
43322: PUSH
43323: EMPTY
43324: LIST
43325: LIST
43326: PUSH
43327: LD_INT 4
43329: PUSH
43330: LD_INT 3
43332: PUSH
43333: EMPTY
43334: LIST
43335: LIST
43336: PUSH
43337: LD_INT 4
43339: PUSH
43340: LD_INT 4
43342: PUSH
43343: EMPTY
43344: LIST
43345: LIST
43346: PUSH
43347: LD_INT 3
43349: PUSH
43350: LD_INT 4
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: PUSH
43357: LD_INT 2
43359: PUSH
43360: LD_INT 3
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: PUSH
43367: LD_INT 2
43369: PUSH
43370: LD_INT 2
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 4
43379: PUSH
43380: LD_INT 2
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: LD_INT 4
43392: PUSH
43393: EMPTY
43394: LIST
43395: LIST
43396: PUSH
43397: LD_INT 0
43399: PUSH
43400: LD_INT 4
43402: PUSH
43403: EMPTY
43404: LIST
43405: LIST
43406: PUSH
43407: LD_INT 0
43409: PUSH
43410: LD_INT 3
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: LD_INT 1
43419: PUSH
43420: LD_INT 4
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PUSH
43427: LD_INT 1
43429: PUSH
43430: LD_INT 5
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: LD_INT 0
43439: PUSH
43440: LD_INT 5
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: PUSH
43447: LD_INT 1
43449: NEG
43450: PUSH
43451: LD_INT 4
43453: PUSH
43454: EMPTY
43455: LIST
43456: LIST
43457: PUSH
43458: LD_INT 1
43460: NEG
43461: PUSH
43462: LD_INT 3
43464: PUSH
43465: EMPTY
43466: LIST
43467: LIST
43468: PUSH
43469: LD_INT 2
43471: PUSH
43472: LD_INT 5
43474: PUSH
43475: EMPTY
43476: LIST
43477: LIST
43478: PUSH
43479: LD_INT 2
43481: NEG
43482: PUSH
43483: LD_INT 3
43485: PUSH
43486: EMPTY
43487: LIST
43488: LIST
43489: PUSH
43490: LD_INT 3
43492: NEG
43493: PUSH
43494: LD_INT 0
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 3
43503: NEG
43504: PUSH
43505: LD_INT 1
43507: NEG
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: PUSH
43513: LD_INT 2
43515: NEG
43516: PUSH
43517: LD_INT 0
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: PUSH
43524: LD_INT 2
43526: NEG
43527: PUSH
43528: LD_INT 1
43530: PUSH
43531: EMPTY
43532: LIST
43533: LIST
43534: PUSH
43535: LD_INT 3
43537: NEG
43538: PUSH
43539: LD_INT 1
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PUSH
43546: LD_INT 4
43548: NEG
43549: PUSH
43550: LD_INT 0
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: PUSH
43557: LD_INT 4
43559: NEG
43560: PUSH
43561: LD_INT 1
43563: NEG
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: PUSH
43569: LD_INT 4
43571: NEG
43572: PUSH
43573: LD_INT 2
43575: NEG
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: LD_INT 2
43583: NEG
43584: PUSH
43585: LD_INT 2
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: PUSH
43592: LD_INT 4
43594: NEG
43595: PUSH
43596: LD_INT 4
43598: NEG
43599: PUSH
43600: EMPTY
43601: LIST
43602: LIST
43603: PUSH
43604: LD_INT 4
43606: NEG
43607: PUSH
43608: LD_INT 5
43610: NEG
43611: PUSH
43612: EMPTY
43613: LIST
43614: LIST
43615: PUSH
43616: LD_INT 3
43618: NEG
43619: PUSH
43620: LD_INT 4
43622: NEG
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 3
43630: NEG
43631: PUSH
43632: LD_INT 3
43634: NEG
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: PUSH
43640: LD_INT 4
43642: NEG
43643: PUSH
43644: LD_INT 3
43646: NEG
43647: PUSH
43648: EMPTY
43649: LIST
43650: LIST
43651: PUSH
43652: LD_INT 5
43654: NEG
43655: PUSH
43656: LD_INT 4
43658: NEG
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: LD_INT 5
43666: NEG
43667: PUSH
43668: LD_INT 5
43670: NEG
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: PUSH
43676: LD_INT 3
43678: NEG
43679: PUSH
43680: LD_INT 5
43682: NEG
43683: PUSH
43684: EMPTY
43685: LIST
43686: LIST
43687: PUSH
43688: LD_INT 5
43690: NEG
43691: PUSH
43692: LD_INT 3
43694: NEG
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: LIST
43706: LIST
43707: LIST
43708: LIST
43709: LIST
43710: LIST
43711: LIST
43712: LIST
43713: LIST
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: LIST
43740: LIST
43741: LIST
43742: LIST
43743: LIST
43744: LIST
43745: LIST
43746: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43747: LD_ADDR_VAR 0 30
43751: PUSH
43752: LD_INT 4
43754: PUSH
43755: LD_INT 4
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: PUSH
43762: LD_INT 4
43764: PUSH
43765: LD_INT 3
43767: PUSH
43768: EMPTY
43769: LIST
43770: LIST
43771: PUSH
43772: LD_INT 5
43774: PUSH
43775: LD_INT 4
43777: PUSH
43778: EMPTY
43779: LIST
43780: LIST
43781: PUSH
43782: LD_INT 5
43784: PUSH
43785: LD_INT 5
43787: PUSH
43788: EMPTY
43789: LIST
43790: LIST
43791: PUSH
43792: LD_INT 4
43794: PUSH
43795: LD_INT 5
43797: PUSH
43798: EMPTY
43799: LIST
43800: LIST
43801: PUSH
43802: LD_INT 3
43804: PUSH
43805: LD_INT 4
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: PUSH
43812: LD_INT 3
43814: PUSH
43815: LD_INT 3
43817: PUSH
43818: EMPTY
43819: LIST
43820: LIST
43821: PUSH
43822: LD_INT 5
43824: PUSH
43825: LD_INT 3
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 3
43834: PUSH
43835: LD_INT 5
43837: PUSH
43838: EMPTY
43839: LIST
43840: LIST
43841: PUSH
43842: LD_INT 0
43844: PUSH
43845: LD_INT 3
43847: PUSH
43848: EMPTY
43849: LIST
43850: LIST
43851: PUSH
43852: LD_INT 0
43854: PUSH
43855: LD_INT 2
43857: PUSH
43858: EMPTY
43859: LIST
43860: LIST
43861: PUSH
43862: LD_INT 1
43864: PUSH
43865: LD_INT 3
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: PUSH
43872: LD_INT 1
43874: PUSH
43875: LD_INT 4
43877: PUSH
43878: EMPTY
43879: LIST
43880: LIST
43881: PUSH
43882: LD_INT 0
43884: PUSH
43885: LD_INT 4
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: PUSH
43892: LD_INT 1
43894: NEG
43895: PUSH
43896: LD_INT 3
43898: PUSH
43899: EMPTY
43900: LIST
43901: LIST
43902: PUSH
43903: LD_INT 1
43905: NEG
43906: PUSH
43907: LD_INT 2
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: PUSH
43914: LD_INT 2
43916: PUSH
43917: LD_INT 4
43919: PUSH
43920: EMPTY
43921: LIST
43922: LIST
43923: PUSH
43924: LD_INT 2
43926: NEG
43927: PUSH
43928: LD_INT 2
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PUSH
43935: LD_INT 4
43937: NEG
43938: PUSH
43939: LD_INT 0
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: PUSH
43946: LD_INT 4
43948: NEG
43949: PUSH
43950: LD_INT 1
43952: NEG
43953: PUSH
43954: EMPTY
43955: LIST
43956: LIST
43957: PUSH
43958: LD_INT 3
43960: NEG
43961: PUSH
43962: LD_INT 0
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: PUSH
43969: LD_INT 3
43971: NEG
43972: PUSH
43973: LD_INT 1
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 4
43982: NEG
43983: PUSH
43984: LD_INT 1
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 5
43993: NEG
43994: PUSH
43995: LD_INT 0
43997: PUSH
43998: EMPTY
43999: LIST
44000: LIST
44001: PUSH
44002: LD_INT 5
44004: NEG
44005: PUSH
44006: LD_INT 1
44008: NEG
44009: PUSH
44010: EMPTY
44011: LIST
44012: LIST
44013: PUSH
44014: LD_INT 5
44016: NEG
44017: PUSH
44018: LD_INT 2
44020: NEG
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: PUSH
44026: LD_INT 3
44028: NEG
44029: PUSH
44030: LD_INT 2
44032: PUSH
44033: EMPTY
44034: LIST
44035: LIST
44036: PUSH
44037: LD_INT 3
44039: NEG
44040: PUSH
44041: LD_INT 3
44043: NEG
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 3
44051: NEG
44052: PUSH
44053: LD_INT 4
44055: NEG
44056: PUSH
44057: EMPTY
44058: LIST
44059: LIST
44060: PUSH
44061: LD_INT 2
44063: NEG
44064: PUSH
44065: LD_INT 3
44067: NEG
44068: PUSH
44069: EMPTY
44070: LIST
44071: LIST
44072: PUSH
44073: LD_INT 2
44075: NEG
44076: PUSH
44077: LD_INT 2
44079: NEG
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: PUSH
44085: LD_INT 3
44087: NEG
44088: PUSH
44089: LD_INT 2
44091: NEG
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: PUSH
44097: LD_INT 4
44099: NEG
44100: PUSH
44101: LD_INT 3
44103: NEG
44104: PUSH
44105: EMPTY
44106: LIST
44107: LIST
44108: PUSH
44109: LD_INT 4
44111: NEG
44112: PUSH
44113: LD_INT 4
44115: NEG
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: PUSH
44121: LD_INT 2
44123: NEG
44124: PUSH
44125: LD_INT 4
44127: NEG
44128: PUSH
44129: EMPTY
44130: LIST
44131: LIST
44132: PUSH
44133: LD_INT 4
44135: NEG
44136: PUSH
44137: LD_INT 2
44139: NEG
44140: PUSH
44141: EMPTY
44142: LIST
44143: LIST
44144: PUSH
44145: LD_INT 0
44147: PUSH
44148: LD_INT 4
44150: NEG
44151: PUSH
44152: EMPTY
44153: LIST
44154: LIST
44155: PUSH
44156: LD_INT 0
44158: PUSH
44159: LD_INT 5
44161: NEG
44162: PUSH
44163: EMPTY
44164: LIST
44165: LIST
44166: PUSH
44167: LD_INT 1
44169: PUSH
44170: LD_INT 4
44172: NEG
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: PUSH
44178: LD_INT 1
44180: PUSH
44181: LD_INT 3
44183: NEG
44184: PUSH
44185: EMPTY
44186: LIST
44187: LIST
44188: PUSH
44189: LD_INT 0
44191: PUSH
44192: LD_INT 3
44194: NEG
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 1
44202: NEG
44203: PUSH
44204: LD_INT 4
44206: NEG
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 1
44214: NEG
44215: PUSH
44216: LD_INT 5
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 2
44226: PUSH
44227: LD_INT 3
44229: NEG
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: LD_INT 2
44237: NEG
44238: PUSH
44239: LD_INT 5
44241: NEG
44242: PUSH
44243: EMPTY
44244: LIST
44245: LIST
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: LIST
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: LIST
44260: LIST
44261: LIST
44262: LIST
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: LIST
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: LIST
44286: LIST
44287: LIST
44288: LIST
44289: LIST
44290: LIST
44291: LIST
44292: LIST
44293: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44294: LD_ADDR_VAR 0 31
44298: PUSH
44299: LD_INT 0
44301: PUSH
44302: LD_INT 4
44304: PUSH
44305: EMPTY
44306: LIST
44307: LIST
44308: PUSH
44309: LD_INT 0
44311: PUSH
44312: LD_INT 3
44314: PUSH
44315: EMPTY
44316: LIST
44317: LIST
44318: PUSH
44319: LD_INT 1
44321: PUSH
44322: LD_INT 4
44324: PUSH
44325: EMPTY
44326: LIST
44327: LIST
44328: PUSH
44329: LD_INT 1
44331: PUSH
44332: LD_INT 5
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: PUSH
44339: LD_INT 0
44341: PUSH
44342: LD_INT 5
44344: PUSH
44345: EMPTY
44346: LIST
44347: LIST
44348: PUSH
44349: LD_INT 1
44351: NEG
44352: PUSH
44353: LD_INT 4
44355: PUSH
44356: EMPTY
44357: LIST
44358: LIST
44359: PUSH
44360: LD_INT 1
44362: NEG
44363: PUSH
44364: LD_INT 3
44366: PUSH
44367: EMPTY
44368: LIST
44369: LIST
44370: PUSH
44371: LD_INT 2
44373: PUSH
44374: LD_INT 5
44376: PUSH
44377: EMPTY
44378: LIST
44379: LIST
44380: PUSH
44381: LD_INT 2
44383: NEG
44384: PUSH
44385: LD_INT 3
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 3
44394: NEG
44395: PUSH
44396: LD_INT 0
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: PUSH
44403: LD_INT 3
44405: NEG
44406: PUSH
44407: LD_INT 1
44409: NEG
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 2
44417: NEG
44418: PUSH
44419: LD_INT 0
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: LD_INT 2
44428: NEG
44429: PUSH
44430: LD_INT 1
44432: PUSH
44433: EMPTY
44434: LIST
44435: LIST
44436: PUSH
44437: LD_INT 3
44439: NEG
44440: PUSH
44441: LD_INT 1
44443: PUSH
44444: EMPTY
44445: LIST
44446: LIST
44447: PUSH
44448: LD_INT 4
44450: NEG
44451: PUSH
44452: LD_INT 0
44454: PUSH
44455: EMPTY
44456: LIST
44457: LIST
44458: PUSH
44459: LD_INT 4
44461: NEG
44462: PUSH
44463: LD_INT 1
44465: NEG
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 4
44473: NEG
44474: PUSH
44475: LD_INT 2
44477: NEG
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: PUSH
44483: LD_INT 2
44485: NEG
44486: PUSH
44487: LD_INT 2
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: PUSH
44494: LD_INT 4
44496: NEG
44497: PUSH
44498: LD_INT 4
44500: NEG
44501: PUSH
44502: EMPTY
44503: LIST
44504: LIST
44505: PUSH
44506: LD_INT 4
44508: NEG
44509: PUSH
44510: LD_INT 5
44512: NEG
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: PUSH
44518: LD_INT 3
44520: NEG
44521: PUSH
44522: LD_INT 4
44524: NEG
44525: PUSH
44526: EMPTY
44527: LIST
44528: LIST
44529: PUSH
44530: LD_INT 3
44532: NEG
44533: PUSH
44534: LD_INT 3
44536: NEG
44537: PUSH
44538: EMPTY
44539: LIST
44540: LIST
44541: PUSH
44542: LD_INT 4
44544: NEG
44545: PUSH
44546: LD_INT 3
44548: NEG
44549: PUSH
44550: EMPTY
44551: LIST
44552: LIST
44553: PUSH
44554: LD_INT 5
44556: NEG
44557: PUSH
44558: LD_INT 4
44560: NEG
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PUSH
44566: LD_INT 5
44568: NEG
44569: PUSH
44570: LD_INT 5
44572: NEG
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 3
44580: NEG
44581: PUSH
44582: LD_INT 5
44584: NEG
44585: PUSH
44586: EMPTY
44587: LIST
44588: LIST
44589: PUSH
44590: LD_INT 5
44592: NEG
44593: PUSH
44594: LD_INT 3
44596: NEG
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PUSH
44602: LD_INT 0
44604: PUSH
44605: LD_INT 3
44607: NEG
44608: PUSH
44609: EMPTY
44610: LIST
44611: LIST
44612: PUSH
44613: LD_INT 0
44615: PUSH
44616: LD_INT 4
44618: NEG
44619: PUSH
44620: EMPTY
44621: LIST
44622: LIST
44623: PUSH
44624: LD_INT 1
44626: PUSH
44627: LD_INT 3
44629: NEG
44630: PUSH
44631: EMPTY
44632: LIST
44633: LIST
44634: PUSH
44635: LD_INT 1
44637: PUSH
44638: LD_INT 2
44640: NEG
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: LD_INT 0
44648: PUSH
44649: LD_INT 2
44651: NEG
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 1
44659: NEG
44660: PUSH
44661: LD_INT 3
44663: NEG
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PUSH
44669: LD_INT 1
44671: NEG
44672: PUSH
44673: LD_INT 4
44675: NEG
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 2
44683: PUSH
44684: LD_INT 2
44686: NEG
44687: PUSH
44688: EMPTY
44689: LIST
44690: LIST
44691: PUSH
44692: LD_INT 2
44694: NEG
44695: PUSH
44696: LD_INT 4
44698: NEG
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: PUSH
44704: LD_INT 4
44706: PUSH
44707: LD_INT 0
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: PUSH
44714: LD_INT 4
44716: PUSH
44717: LD_INT 1
44719: NEG
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 5
44727: PUSH
44728: LD_INT 0
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 5
44737: PUSH
44738: LD_INT 1
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 4
44747: PUSH
44748: LD_INT 1
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 3
44757: PUSH
44758: LD_INT 0
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: PUSH
44765: LD_INT 3
44767: PUSH
44768: LD_INT 1
44770: NEG
44771: PUSH
44772: EMPTY
44773: LIST
44774: LIST
44775: PUSH
44776: LD_INT 3
44778: PUSH
44779: LD_INT 2
44781: NEG
44782: PUSH
44783: EMPTY
44784: LIST
44785: LIST
44786: PUSH
44787: LD_INT 5
44789: PUSH
44790: LD_INT 2
44792: PUSH
44793: EMPTY
44794: LIST
44795: LIST
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: LIST
44824: LIST
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: LIST
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: LIST
44842: LIST
44843: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44844: LD_ADDR_VAR 0 32
44848: PUSH
44849: LD_INT 4
44851: NEG
44852: PUSH
44853: LD_INT 0
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 4
44862: NEG
44863: PUSH
44864: LD_INT 1
44866: NEG
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 3
44874: NEG
44875: PUSH
44876: LD_INT 0
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 3
44885: NEG
44886: PUSH
44887: LD_INT 1
44889: PUSH
44890: EMPTY
44891: LIST
44892: LIST
44893: PUSH
44894: LD_INT 4
44896: NEG
44897: PUSH
44898: LD_INT 1
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: PUSH
44905: LD_INT 5
44907: NEG
44908: PUSH
44909: LD_INT 0
44911: PUSH
44912: EMPTY
44913: LIST
44914: LIST
44915: PUSH
44916: LD_INT 5
44918: NEG
44919: PUSH
44920: LD_INT 1
44922: NEG
44923: PUSH
44924: EMPTY
44925: LIST
44926: LIST
44927: PUSH
44928: LD_INT 5
44930: NEG
44931: PUSH
44932: LD_INT 2
44934: NEG
44935: PUSH
44936: EMPTY
44937: LIST
44938: LIST
44939: PUSH
44940: LD_INT 3
44942: NEG
44943: PUSH
44944: LD_INT 2
44946: PUSH
44947: EMPTY
44948: LIST
44949: LIST
44950: PUSH
44951: LD_INT 3
44953: NEG
44954: PUSH
44955: LD_INT 3
44957: NEG
44958: PUSH
44959: EMPTY
44960: LIST
44961: LIST
44962: PUSH
44963: LD_INT 3
44965: NEG
44966: PUSH
44967: LD_INT 4
44969: NEG
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 2
44977: NEG
44978: PUSH
44979: LD_INT 3
44981: NEG
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: PUSH
44987: LD_INT 2
44989: NEG
44990: PUSH
44991: LD_INT 2
44993: NEG
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 3
45001: NEG
45002: PUSH
45003: LD_INT 2
45005: NEG
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 4
45013: NEG
45014: PUSH
45015: LD_INT 3
45017: NEG
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 4
45025: NEG
45026: PUSH
45027: LD_INT 4
45029: NEG
45030: PUSH
45031: EMPTY
45032: LIST
45033: LIST
45034: PUSH
45035: LD_INT 2
45037: NEG
45038: PUSH
45039: LD_INT 4
45041: NEG
45042: PUSH
45043: EMPTY
45044: LIST
45045: LIST
45046: PUSH
45047: LD_INT 4
45049: NEG
45050: PUSH
45051: LD_INT 2
45053: NEG
45054: PUSH
45055: EMPTY
45056: LIST
45057: LIST
45058: PUSH
45059: LD_INT 0
45061: PUSH
45062: LD_INT 4
45064: NEG
45065: PUSH
45066: EMPTY
45067: LIST
45068: LIST
45069: PUSH
45070: LD_INT 0
45072: PUSH
45073: LD_INT 5
45075: NEG
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: PUSH
45081: LD_INT 1
45083: PUSH
45084: LD_INT 4
45086: NEG
45087: PUSH
45088: EMPTY
45089: LIST
45090: LIST
45091: PUSH
45092: LD_INT 1
45094: PUSH
45095: LD_INT 3
45097: NEG
45098: PUSH
45099: EMPTY
45100: LIST
45101: LIST
45102: PUSH
45103: LD_INT 0
45105: PUSH
45106: LD_INT 3
45108: NEG
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 1
45116: NEG
45117: PUSH
45118: LD_INT 4
45120: NEG
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 1
45128: NEG
45129: PUSH
45130: LD_INT 5
45132: NEG
45133: PUSH
45134: EMPTY
45135: LIST
45136: LIST
45137: PUSH
45138: LD_INT 2
45140: PUSH
45141: LD_INT 3
45143: NEG
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: LD_INT 2
45151: NEG
45152: PUSH
45153: LD_INT 5
45155: NEG
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: PUSH
45161: LD_INT 3
45163: PUSH
45164: LD_INT 0
45166: PUSH
45167: EMPTY
45168: LIST
45169: LIST
45170: PUSH
45171: LD_INT 3
45173: PUSH
45174: LD_INT 1
45176: NEG
45177: PUSH
45178: EMPTY
45179: LIST
45180: LIST
45181: PUSH
45182: LD_INT 4
45184: PUSH
45185: LD_INT 0
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: PUSH
45192: LD_INT 4
45194: PUSH
45195: LD_INT 1
45197: PUSH
45198: EMPTY
45199: LIST
45200: LIST
45201: PUSH
45202: LD_INT 3
45204: PUSH
45205: LD_INT 1
45207: PUSH
45208: EMPTY
45209: LIST
45210: LIST
45211: PUSH
45212: LD_INT 2
45214: PUSH
45215: LD_INT 0
45217: PUSH
45218: EMPTY
45219: LIST
45220: LIST
45221: PUSH
45222: LD_INT 2
45224: PUSH
45225: LD_INT 1
45227: NEG
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: PUSH
45233: LD_INT 2
45235: PUSH
45236: LD_INT 2
45238: NEG
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: PUSH
45244: LD_INT 4
45246: PUSH
45247: LD_INT 2
45249: PUSH
45250: EMPTY
45251: LIST
45252: LIST
45253: PUSH
45254: LD_INT 4
45256: PUSH
45257: LD_INT 4
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 4
45266: PUSH
45267: LD_INT 3
45269: PUSH
45270: EMPTY
45271: LIST
45272: LIST
45273: PUSH
45274: LD_INT 5
45276: PUSH
45277: LD_INT 4
45279: PUSH
45280: EMPTY
45281: LIST
45282: LIST
45283: PUSH
45284: LD_INT 5
45286: PUSH
45287: LD_INT 5
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: PUSH
45294: LD_INT 4
45296: PUSH
45297: LD_INT 5
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: PUSH
45304: LD_INT 3
45306: PUSH
45307: LD_INT 4
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PUSH
45314: LD_INT 3
45316: PUSH
45317: LD_INT 3
45319: PUSH
45320: EMPTY
45321: LIST
45322: LIST
45323: PUSH
45324: LD_INT 5
45326: PUSH
45327: LD_INT 3
45329: PUSH
45330: EMPTY
45331: LIST
45332: LIST
45333: PUSH
45334: LD_INT 3
45336: PUSH
45337: LD_INT 5
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: LIST
45378: LIST
45379: LIST
45380: LIST
45381: LIST
45382: LIST
45383: LIST
45384: LIST
45385: LIST
45386: LIST
45387: LIST
45388: LIST
45389: LIST
45390: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45391: LD_ADDR_VAR 0 33
45395: PUSH
45396: LD_INT 4
45398: NEG
45399: PUSH
45400: LD_INT 4
45402: NEG
45403: PUSH
45404: EMPTY
45405: LIST
45406: LIST
45407: PUSH
45408: LD_INT 4
45410: NEG
45411: PUSH
45412: LD_INT 5
45414: NEG
45415: PUSH
45416: EMPTY
45417: LIST
45418: LIST
45419: PUSH
45420: LD_INT 3
45422: NEG
45423: PUSH
45424: LD_INT 4
45426: NEG
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 3
45434: NEG
45435: PUSH
45436: LD_INT 3
45438: NEG
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: PUSH
45444: LD_INT 4
45446: NEG
45447: PUSH
45448: LD_INT 3
45450: NEG
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: LD_INT 5
45458: NEG
45459: PUSH
45460: LD_INT 4
45462: NEG
45463: PUSH
45464: EMPTY
45465: LIST
45466: LIST
45467: PUSH
45468: LD_INT 5
45470: NEG
45471: PUSH
45472: LD_INT 5
45474: NEG
45475: PUSH
45476: EMPTY
45477: LIST
45478: LIST
45479: PUSH
45480: LD_INT 3
45482: NEG
45483: PUSH
45484: LD_INT 5
45486: NEG
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: PUSH
45492: LD_INT 5
45494: NEG
45495: PUSH
45496: LD_INT 3
45498: NEG
45499: PUSH
45500: EMPTY
45501: LIST
45502: LIST
45503: PUSH
45504: LD_INT 0
45506: PUSH
45507: LD_INT 3
45509: NEG
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: LD_INT 0
45517: PUSH
45518: LD_INT 4
45520: NEG
45521: PUSH
45522: EMPTY
45523: LIST
45524: LIST
45525: PUSH
45526: LD_INT 1
45528: PUSH
45529: LD_INT 3
45531: NEG
45532: PUSH
45533: EMPTY
45534: LIST
45535: LIST
45536: PUSH
45537: LD_INT 1
45539: PUSH
45540: LD_INT 2
45542: NEG
45543: PUSH
45544: EMPTY
45545: LIST
45546: LIST
45547: PUSH
45548: LD_INT 0
45550: PUSH
45551: LD_INT 2
45553: NEG
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 1
45561: NEG
45562: PUSH
45563: LD_INT 3
45565: NEG
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 1
45573: NEG
45574: PUSH
45575: LD_INT 4
45577: NEG
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: PUSH
45583: LD_INT 2
45585: PUSH
45586: LD_INT 2
45588: NEG
45589: PUSH
45590: EMPTY
45591: LIST
45592: LIST
45593: PUSH
45594: LD_INT 2
45596: NEG
45597: PUSH
45598: LD_INT 4
45600: NEG
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: PUSH
45606: LD_INT 4
45608: PUSH
45609: LD_INT 0
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: LD_INT 4
45618: PUSH
45619: LD_INT 1
45621: NEG
45622: PUSH
45623: EMPTY
45624: LIST
45625: LIST
45626: PUSH
45627: LD_INT 5
45629: PUSH
45630: LD_INT 0
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: LD_INT 5
45639: PUSH
45640: LD_INT 1
45642: PUSH
45643: EMPTY
45644: LIST
45645: LIST
45646: PUSH
45647: LD_INT 4
45649: PUSH
45650: LD_INT 1
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: PUSH
45657: LD_INT 3
45659: PUSH
45660: LD_INT 0
45662: PUSH
45663: EMPTY
45664: LIST
45665: LIST
45666: PUSH
45667: LD_INT 3
45669: PUSH
45670: LD_INT 1
45672: NEG
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: PUSH
45678: LD_INT 3
45680: PUSH
45681: LD_INT 2
45683: NEG
45684: PUSH
45685: EMPTY
45686: LIST
45687: LIST
45688: PUSH
45689: LD_INT 5
45691: PUSH
45692: LD_INT 2
45694: PUSH
45695: EMPTY
45696: LIST
45697: LIST
45698: PUSH
45699: LD_INT 3
45701: PUSH
45702: LD_INT 3
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 3
45711: PUSH
45712: LD_INT 2
45714: PUSH
45715: EMPTY
45716: LIST
45717: LIST
45718: PUSH
45719: LD_INT 4
45721: PUSH
45722: LD_INT 3
45724: PUSH
45725: EMPTY
45726: LIST
45727: LIST
45728: PUSH
45729: LD_INT 4
45731: PUSH
45732: LD_INT 4
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: PUSH
45739: LD_INT 3
45741: PUSH
45742: LD_INT 4
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: LD_INT 2
45751: PUSH
45752: LD_INT 3
45754: PUSH
45755: EMPTY
45756: LIST
45757: LIST
45758: PUSH
45759: LD_INT 2
45761: PUSH
45762: LD_INT 2
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 4
45771: PUSH
45772: LD_INT 2
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: PUSH
45779: LD_INT 2
45781: PUSH
45782: LD_INT 4
45784: PUSH
45785: EMPTY
45786: LIST
45787: LIST
45788: PUSH
45789: LD_INT 0
45791: PUSH
45792: LD_INT 4
45794: PUSH
45795: EMPTY
45796: LIST
45797: LIST
45798: PUSH
45799: LD_INT 0
45801: PUSH
45802: LD_INT 3
45804: PUSH
45805: EMPTY
45806: LIST
45807: LIST
45808: PUSH
45809: LD_INT 1
45811: PUSH
45812: LD_INT 4
45814: PUSH
45815: EMPTY
45816: LIST
45817: LIST
45818: PUSH
45819: LD_INT 1
45821: PUSH
45822: LD_INT 5
45824: PUSH
45825: EMPTY
45826: LIST
45827: LIST
45828: PUSH
45829: LD_INT 0
45831: PUSH
45832: LD_INT 5
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 1
45841: NEG
45842: PUSH
45843: LD_INT 4
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: PUSH
45850: LD_INT 1
45852: NEG
45853: PUSH
45854: LD_INT 3
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: PUSH
45861: LD_INT 2
45863: PUSH
45864: LD_INT 5
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: PUSH
45871: LD_INT 2
45873: NEG
45874: PUSH
45875: LD_INT 3
45877: PUSH
45878: EMPTY
45879: LIST
45880: LIST
45881: PUSH
45882: EMPTY
45883: LIST
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: LIST
45901: LIST
45902: LIST
45903: LIST
45904: LIST
45905: LIST
45906: LIST
45907: LIST
45908: LIST
45909: LIST
45910: LIST
45911: LIST
45912: LIST
45913: LIST
45914: LIST
45915: LIST
45916: LIST
45917: LIST
45918: LIST
45919: LIST
45920: LIST
45921: LIST
45922: LIST
45923: LIST
45924: LIST
45925: LIST
45926: LIST
45927: LIST
45928: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45929: LD_ADDR_VAR 0 34
45933: PUSH
45934: LD_INT 0
45936: PUSH
45937: LD_INT 4
45939: NEG
45940: PUSH
45941: EMPTY
45942: LIST
45943: LIST
45944: PUSH
45945: LD_INT 0
45947: PUSH
45948: LD_INT 5
45950: NEG
45951: PUSH
45952: EMPTY
45953: LIST
45954: LIST
45955: PUSH
45956: LD_INT 1
45958: PUSH
45959: LD_INT 4
45961: NEG
45962: PUSH
45963: EMPTY
45964: LIST
45965: LIST
45966: PUSH
45967: LD_INT 1
45969: PUSH
45970: LD_INT 3
45972: NEG
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 0
45980: PUSH
45981: LD_INT 3
45983: NEG
45984: PUSH
45985: EMPTY
45986: LIST
45987: LIST
45988: PUSH
45989: LD_INT 1
45991: NEG
45992: PUSH
45993: LD_INT 4
45995: NEG
45996: PUSH
45997: EMPTY
45998: LIST
45999: LIST
46000: PUSH
46001: LD_INT 1
46003: NEG
46004: PUSH
46005: LD_INT 5
46007: NEG
46008: PUSH
46009: EMPTY
46010: LIST
46011: LIST
46012: PUSH
46013: LD_INT 2
46015: PUSH
46016: LD_INT 3
46018: NEG
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: PUSH
46024: LD_INT 2
46026: NEG
46027: PUSH
46028: LD_INT 5
46030: NEG
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: PUSH
46036: LD_INT 3
46038: PUSH
46039: LD_INT 0
46041: PUSH
46042: EMPTY
46043: LIST
46044: LIST
46045: PUSH
46046: LD_INT 3
46048: PUSH
46049: LD_INT 1
46051: NEG
46052: PUSH
46053: EMPTY
46054: LIST
46055: LIST
46056: PUSH
46057: LD_INT 4
46059: PUSH
46060: LD_INT 0
46062: PUSH
46063: EMPTY
46064: LIST
46065: LIST
46066: PUSH
46067: LD_INT 4
46069: PUSH
46070: LD_INT 1
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: PUSH
46077: LD_INT 3
46079: PUSH
46080: LD_INT 1
46082: PUSH
46083: EMPTY
46084: LIST
46085: LIST
46086: PUSH
46087: LD_INT 2
46089: PUSH
46090: LD_INT 0
46092: PUSH
46093: EMPTY
46094: LIST
46095: LIST
46096: PUSH
46097: LD_INT 2
46099: PUSH
46100: LD_INT 1
46102: NEG
46103: PUSH
46104: EMPTY
46105: LIST
46106: LIST
46107: PUSH
46108: LD_INT 2
46110: PUSH
46111: LD_INT 2
46113: NEG
46114: PUSH
46115: EMPTY
46116: LIST
46117: LIST
46118: PUSH
46119: LD_INT 4
46121: PUSH
46122: LD_INT 2
46124: PUSH
46125: EMPTY
46126: LIST
46127: LIST
46128: PUSH
46129: LD_INT 4
46131: PUSH
46132: LD_INT 4
46134: PUSH
46135: EMPTY
46136: LIST
46137: LIST
46138: PUSH
46139: LD_INT 4
46141: PUSH
46142: LD_INT 3
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: PUSH
46149: LD_INT 5
46151: PUSH
46152: LD_INT 4
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: PUSH
46159: LD_INT 5
46161: PUSH
46162: LD_INT 5
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PUSH
46169: LD_INT 4
46171: PUSH
46172: LD_INT 5
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 3
46181: PUSH
46182: LD_INT 4
46184: PUSH
46185: EMPTY
46186: LIST
46187: LIST
46188: PUSH
46189: LD_INT 3
46191: PUSH
46192: LD_INT 3
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: PUSH
46199: LD_INT 5
46201: PUSH
46202: LD_INT 3
46204: PUSH
46205: EMPTY
46206: LIST
46207: LIST
46208: PUSH
46209: LD_INT 3
46211: PUSH
46212: LD_INT 5
46214: PUSH
46215: EMPTY
46216: LIST
46217: LIST
46218: PUSH
46219: LD_INT 0
46221: PUSH
46222: LD_INT 3
46224: PUSH
46225: EMPTY
46226: LIST
46227: LIST
46228: PUSH
46229: LD_INT 0
46231: PUSH
46232: LD_INT 2
46234: PUSH
46235: EMPTY
46236: LIST
46237: LIST
46238: PUSH
46239: LD_INT 1
46241: PUSH
46242: LD_INT 3
46244: PUSH
46245: EMPTY
46246: LIST
46247: LIST
46248: PUSH
46249: LD_INT 1
46251: PUSH
46252: LD_INT 4
46254: PUSH
46255: EMPTY
46256: LIST
46257: LIST
46258: PUSH
46259: LD_INT 0
46261: PUSH
46262: LD_INT 4
46264: PUSH
46265: EMPTY
46266: LIST
46267: LIST
46268: PUSH
46269: LD_INT 1
46271: NEG
46272: PUSH
46273: LD_INT 3
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: PUSH
46280: LD_INT 1
46282: NEG
46283: PUSH
46284: LD_INT 2
46286: PUSH
46287: EMPTY
46288: LIST
46289: LIST
46290: PUSH
46291: LD_INT 2
46293: PUSH
46294: LD_INT 4
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: PUSH
46301: LD_INT 2
46303: NEG
46304: PUSH
46305: LD_INT 2
46307: PUSH
46308: EMPTY
46309: LIST
46310: LIST
46311: PUSH
46312: LD_INT 4
46314: NEG
46315: PUSH
46316: LD_INT 0
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: PUSH
46323: LD_INT 4
46325: NEG
46326: PUSH
46327: LD_INT 1
46329: NEG
46330: PUSH
46331: EMPTY
46332: LIST
46333: LIST
46334: PUSH
46335: LD_INT 3
46337: NEG
46338: PUSH
46339: LD_INT 0
46341: PUSH
46342: EMPTY
46343: LIST
46344: LIST
46345: PUSH
46346: LD_INT 3
46348: NEG
46349: PUSH
46350: LD_INT 1
46352: PUSH
46353: EMPTY
46354: LIST
46355: LIST
46356: PUSH
46357: LD_INT 4
46359: NEG
46360: PUSH
46361: LD_INT 1
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 5
46370: NEG
46371: PUSH
46372: LD_INT 0
46374: PUSH
46375: EMPTY
46376: LIST
46377: LIST
46378: PUSH
46379: LD_INT 5
46381: NEG
46382: PUSH
46383: LD_INT 1
46385: NEG
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 5
46393: NEG
46394: PUSH
46395: LD_INT 2
46397: NEG
46398: PUSH
46399: EMPTY
46400: LIST
46401: LIST
46402: PUSH
46403: LD_INT 3
46405: NEG
46406: PUSH
46407: LD_INT 2
46409: PUSH
46410: EMPTY
46411: LIST
46412: LIST
46413: PUSH
46414: EMPTY
46415: LIST
46416: LIST
46417: LIST
46418: LIST
46419: LIST
46420: LIST
46421: LIST
46422: LIST
46423: LIST
46424: LIST
46425: LIST
46426: LIST
46427: LIST
46428: LIST
46429: LIST
46430: LIST
46431: LIST
46432: LIST
46433: LIST
46434: LIST
46435: LIST
46436: LIST
46437: LIST
46438: LIST
46439: LIST
46440: LIST
46441: LIST
46442: LIST
46443: LIST
46444: LIST
46445: LIST
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: LIST
46454: LIST
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: ST_TO_ADDR
// end ; end ;
46461: GO 46464
46463: POP
// case btype of b_depot , b_warehouse :
46464: LD_VAR 0 1
46468: PUSH
46469: LD_INT 0
46471: DOUBLE
46472: EQUAL
46473: IFTRUE 46483
46475: LD_INT 1
46477: DOUBLE
46478: EQUAL
46479: IFTRUE 46483
46481: GO 46684
46483: POP
// case nation of nation_american :
46484: LD_VAR 0 5
46488: PUSH
46489: LD_INT 1
46491: DOUBLE
46492: EQUAL
46493: IFTRUE 46497
46495: GO 46553
46497: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46498: LD_ADDR_VAR 0 9
46502: PUSH
46503: LD_VAR 0 11
46507: PUSH
46508: LD_VAR 0 12
46512: PUSH
46513: LD_VAR 0 13
46517: PUSH
46518: LD_VAR 0 14
46522: PUSH
46523: LD_VAR 0 15
46527: PUSH
46528: LD_VAR 0 16
46532: PUSH
46533: EMPTY
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: PUSH
46541: LD_VAR 0 4
46545: PUSH
46546: LD_INT 1
46548: PLUS
46549: ARRAY
46550: ST_TO_ADDR
46551: GO 46682
46553: LD_INT 2
46555: DOUBLE
46556: EQUAL
46557: IFTRUE 46561
46559: GO 46617
46561: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46562: LD_ADDR_VAR 0 9
46566: PUSH
46567: LD_VAR 0 17
46571: PUSH
46572: LD_VAR 0 18
46576: PUSH
46577: LD_VAR 0 19
46581: PUSH
46582: LD_VAR 0 20
46586: PUSH
46587: LD_VAR 0 21
46591: PUSH
46592: LD_VAR 0 22
46596: PUSH
46597: EMPTY
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: PUSH
46605: LD_VAR 0 4
46609: PUSH
46610: LD_INT 1
46612: PLUS
46613: ARRAY
46614: ST_TO_ADDR
46615: GO 46682
46617: LD_INT 3
46619: DOUBLE
46620: EQUAL
46621: IFTRUE 46625
46623: GO 46681
46625: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46626: LD_ADDR_VAR 0 9
46630: PUSH
46631: LD_VAR 0 23
46635: PUSH
46636: LD_VAR 0 24
46640: PUSH
46641: LD_VAR 0 25
46645: PUSH
46646: LD_VAR 0 26
46650: PUSH
46651: LD_VAR 0 27
46655: PUSH
46656: LD_VAR 0 28
46660: PUSH
46661: EMPTY
46662: LIST
46663: LIST
46664: LIST
46665: LIST
46666: LIST
46667: LIST
46668: PUSH
46669: LD_VAR 0 4
46673: PUSH
46674: LD_INT 1
46676: PLUS
46677: ARRAY
46678: ST_TO_ADDR
46679: GO 46682
46681: POP
46682: GO 47237
46684: LD_INT 2
46686: DOUBLE
46687: EQUAL
46688: IFTRUE 46698
46690: LD_INT 3
46692: DOUBLE
46693: EQUAL
46694: IFTRUE 46698
46696: GO 46754
46698: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46699: LD_ADDR_VAR 0 9
46703: PUSH
46704: LD_VAR 0 29
46708: PUSH
46709: LD_VAR 0 30
46713: PUSH
46714: LD_VAR 0 31
46718: PUSH
46719: LD_VAR 0 32
46723: PUSH
46724: LD_VAR 0 33
46728: PUSH
46729: LD_VAR 0 34
46733: PUSH
46734: EMPTY
46735: LIST
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: PUSH
46742: LD_VAR 0 4
46746: PUSH
46747: LD_INT 1
46749: PLUS
46750: ARRAY
46751: ST_TO_ADDR
46752: GO 47237
46754: LD_INT 16
46756: DOUBLE
46757: EQUAL
46758: IFTRUE 46816
46760: LD_INT 17
46762: DOUBLE
46763: EQUAL
46764: IFTRUE 46816
46766: LD_INT 18
46768: DOUBLE
46769: EQUAL
46770: IFTRUE 46816
46772: LD_INT 19
46774: DOUBLE
46775: EQUAL
46776: IFTRUE 46816
46778: LD_INT 22
46780: DOUBLE
46781: EQUAL
46782: IFTRUE 46816
46784: LD_INT 20
46786: DOUBLE
46787: EQUAL
46788: IFTRUE 46816
46790: LD_INT 21
46792: DOUBLE
46793: EQUAL
46794: IFTRUE 46816
46796: LD_INT 23
46798: DOUBLE
46799: EQUAL
46800: IFTRUE 46816
46802: LD_INT 24
46804: DOUBLE
46805: EQUAL
46806: IFTRUE 46816
46808: LD_INT 25
46810: DOUBLE
46811: EQUAL
46812: IFTRUE 46816
46814: GO 46872
46816: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46817: LD_ADDR_VAR 0 9
46821: PUSH
46822: LD_VAR 0 35
46826: PUSH
46827: LD_VAR 0 36
46831: PUSH
46832: LD_VAR 0 37
46836: PUSH
46837: LD_VAR 0 38
46841: PUSH
46842: LD_VAR 0 39
46846: PUSH
46847: LD_VAR 0 40
46851: PUSH
46852: EMPTY
46853: LIST
46854: LIST
46855: LIST
46856: LIST
46857: LIST
46858: LIST
46859: PUSH
46860: LD_VAR 0 4
46864: PUSH
46865: LD_INT 1
46867: PLUS
46868: ARRAY
46869: ST_TO_ADDR
46870: GO 47237
46872: LD_INT 6
46874: DOUBLE
46875: EQUAL
46876: IFTRUE 46928
46878: LD_INT 7
46880: DOUBLE
46881: EQUAL
46882: IFTRUE 46928
46884: LD_INT 8
46886: DOUBLE
46887: EQUAL
46888: IFTRUE 46928
46890: LD_INT 13
46892: DOUBLE
46893: EQUAL
46894: IFTRUE 46928
46896: LD_INT 12
46898: DOUBLE
46899: EQUAL
46900: IFTRUE 46928
46902: LD_INT 15
46904: DOUBLE
46905: EQUAL
46906: IFTRUE 46928
46908: LD_INT 11
46910: DOUBLE
46911: EQUAL
46912: IFTRUE 46928
46914: LD_INT 14
46916: DOUBLE
46917: EQUAL
46918: IFTRUE 46928
46920: LD_INT 10
46922: DOUBLE
46923: EQUAL
46924: IFTRUE 46928
46926: GO 46984
46928: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
46929: LD_ADDR_VAR 0 9
46933: PUSH
46934: LD_VAR 0 41
46938: PUSH
46939: LD_VAR 0 42
46943: PUSH
46944: LD_VAR 0 43
46948: PUSH
46949: LD_VAR 0 44
46953: PUSH
46954: LD_VAR 0 45
46958: PUSH
46959: LD_VAR 0 46
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: PUSH
46972: LD_VAR 0 4
46976: PUSH
46977: LD_INT 1
46979: PLUS
46980: ARRAY
46981: ST_TO_ADDR
46982: GO 47237
46984: LD_INT 36
46986: DOUBLE
46987: EQUAL
46988: IFTRUE 46992
46990: GO 47048
46992: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46993: LD_ADDR_VAR 0 9
46997: PUSH
46998: LD_VAR 0 47
47002: PUSH
47003: LD_VAR 0 48
47007: PUSH
47008: LD_VAR 0 49
47012: PUSH
47013: LD_VAR 0 50
47017: PUSH
47018: LD_VAR 0 51
47022: PUSH
47023: LD_VAR 0 52
47027: PUSH
47028: EMPTY
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: PUSH
47036: LD_VAR 0 4
47040: PUSH
47041: LD_INT 1
47043: PLUS
47044: ARRAY
47045: ST_TO_ADDR
47046: GO 47237
47048: LD_INT 4
47050: DOUBLE
47051: EQUAL
47052: IFTRUE 47074
47054: LD_INT 5
47056: DOUBLE
47057: EQUAL
47058: IFTRUE 47074
47060: LD_INT 34
47062: DOUBLE
47063: EQUAL
47064: IFTRUE 47074
47066: LD_INT 37
47068: DOUBLE
47069: EQUAL
47070: IFTRUE 47074
47072: GO 47130
47074: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47075: LD_ADDR_VAR 0 9
47079: PUSH
47080: LD_VAR 0 53
47084: PUSH
47085: LD_VAR 0 54
47089: PUSH
47090: LD_VAR 0 55
47094: PUSH
47095: LD_VAR 0 56
47099: PUSH
47100: LD_VAR 0 57
47104: PUSH
47105: LD_VAR 0 58
47109: PUSH
47110: EMPTY
47111: LIST
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: LIST
47117: PUSH
47118: LD_VAR 0 4
47122: PUSH
47123: LD_INT 1
47125: PLUS
47126: ARRAY
47127: ST_TO_ADDR
47128: GO 47237
47130: LD_INT 31
47132: DOUBLE
47133: EQUAL
47134: IFTRUE 47180
47136: LD_INT 32
47138: DOUBLE
47139: EQUAL
47140: IFTRUE 47180
47142: LD_INT 33
47144: DOUBLE
47145: EQUAL
47146: IFTRUE 47180
47148: LD_INT 27
47150: DOUBLE
47151: EQUAL
47152: IFTRUE 47180
47154: LD_INT 26
47156: DOUBLE
47157: EQUAL
47158: IFTRUE 47180
47160: LD_INT 28
47162: DOUBLE
47163: EQUAL
47164: IFTRUE 47180
47166: LD_INT 29
47168: DOUBLE
47169: EQUAL
47170: IFTRUE 47180
47172: LD_INT 30
47174: DOUBLE
47175: EQUAL
47176: IFTRUE 47180
47178: GO 47236
47180: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47181: LD_ADDR_VAR 0 9
47185: PUSH
47186: LD_VAR 0 59
47190: PUSH
47191: LD_VAR 0 60
47195: PUSH
47196: LD_VAR 0 61
47200: PUSH
47201: LD_VAR 0 62
47205: PUSH
47206: LD_VAR 0 63
47210: PUSH
47211: LD_VAR 0 64
47215: PUSH
47216: EMPTY
47217: LIST
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: PUSH
47224: LD_VAR 0 4
47228: PUSH
47229: LD_INT 1
47231: PLUS
47232: ARRAY
47233: ST_TO_ADDR
47234: GO 47237
47236: POP
// temp_list2 = [ ] ;
47237: LD_ADDR_VAR 0 10
47241: PUSH
47242: EMPTY
47243: ST_TO_ADDR
// for i in temp_list do
47244: LD_ADDR_VAR 0 8
47248: PUSH
47249: LD_VAR 0 9
47253: PUSH
47254: FOR_IN
47255: IFFALSE 47307
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47257: LD_ADDR_VAR 0 10
47261: PUSH
47262: LD_VAR 0 10
47266: PUSH
47267: LD_VAR 0 8
47271: PUSH
47272: LD_INT 1
47274: ARRAY
47275: PUSH
47276: LD_VAR 0 2
47280: PLUS
47281: PUSH
47282: LD_VAR 0 8
47286: PUSH
47287: LD_INT 2
47289: ARRAY
47290: PUSH
47291: LD_VAR 0 3
47295: PLUS
47296: PUSH
47297: EMPTY
47298: LIST
47299: LIST
47300: PUSH
47301: EMPTY
47302: LIST
47303: ADD
47304: ST_TO_ADDR
47305: GO 47254
47307: POP
47308: POP
// result = temp_list2 ;
47309: LD_ADDR_VAR 0 7
47313: PUSH
47314: LD_VAR 0 10
47318: ST_TO_ADDR
// end ;
47319: LD_VAR 0 7
47323: RET
// export function EnemyInRange ( unit , dist ) ; begin
47324: LD_INT 0
47326: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47327: LD_ADDR_VAR 0 3
47331: PUSH
47332: LD_VAR 0 1
47336: PPUSH
47337: CALL_OW 255
47341: PPUSH
47342: LD_VAR 0 1
47346: PPUSH
47347: CALL_OW 250
47351: PPUSH
47352: LD_VAR 0 1
47356: PPUSH
47357: CALL_OW 251
47361: PPUSH
47362: LD_VAR 0 2
47366: PPUSH
47367: CALL 20720 0 4
47371: PUSH
47372: LD_INT 4
47374: ARRAY
47375: ST_TO_ADDR
// end ;
47376: LD_VAR 0 3
47380: RET
// export function PlayerSeeMe ( unit ) ; begin
47381: LD_INT 0
47383: PPUSH
// result := See ( your_side , unit ) ;
47384: LD_ADDR_VAR 0 2
47388: PUSH
47389: LD_OWVAR 2
47393: PPUSH
47394: LD_VAR 0 1
47398: PPUSH
47399: CALL_OW 292
47403: ST_TO_ADDR
// end ;
47404: LD_VAR 0 2
47408: RET
// export function ReverseDir ( unit ) ; begin
47409: LD_INT 0
47411: PPUSH
// if not unit then
47412: LD_VAR 0 1
47416: NOT
47417: IFFALSE 47421
// exit ;
47419: GO 47444
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47421: LD_ADDR_VAR 0 2
47425: PUSH
47426: LD_VAR 0 1
47430: PPUSH
47431: CALL_OW 254
47435: PUSH
47436: LD_INT 3
47438: PLUS
47439: PUSH
47440: LD_INT 6
47442: MOD
47443: ST_TO_ADDR
// end ;
47444: LD_VAR 0 2
47448: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47449: LD_INT 0
47451: PPUSH
47452: PPUSH
47453: PPUSH
47454: PPUSH
47455: PPUSH
// if not hexes then
47456: LD_VAR 0 2
47460: NOT
47461: IFFALSE 47465
// exit ;
47463: GO 47613
// dist := 9999 ;
47465: LD_ADDR_VAR 0 5
47469: PUSH
47470: LD_INT 9999
47472: ST_TO_ADDR
// for i = 1 to hexes do
47473: LD_ADDR_VAR 0 4
47477: PUSH
47478: DOUBLE
47479: LD_INT 1
47481: DEC
47482: ST_TO_ADDR
47483: LD_VAR 0 2
47487: PUSH
47488: FOR_TO
47489: IFFALSE 47601
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47491: LD_VAR 0 1
47495: PPUSH
47496: LD_VAR 0 2
47500: PUSH
47501: LD_VAR 0 4
47505: ARRAY
47506: PUSH
47507: LD_INT 1
47509: ARRAY
47510: PPUSH
47511: LD_VAR 0 2
47515: PUSH
47516: LD_VAR 0 4
47520: ARRAY
47521: PUSH
47522: LD_INT 2
47524: ARRAY
47525: PPUSH
47526: CALL_OW 297
47530: PUSH
47531: LD_VAR 0 5
47535: LESS
47536: IFFALSE 47599
// begin hex := hexes [ i ] ;
47538: LD_ADDR_VAR 0 7
47542: PUSH
47543: LD_VAR 0 2
47547: PUSH
47548: LD_VAR 0 4
47552: ARRAY
47553: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47554: LD_ADDR_VAR 0 5
47558: PUSH
47559: LD_VAR 0 1
47563: PPUSH
47564: LD_VAR 0 2
47568: PUSH
47569: LD_VAR 0 4
47573: ARRAY
47574: PUSH
47575: LD_INT 1
47577: ARRAY
47578: PPUSH
47579: LD_VAR 0 2
47583: PUSH
47584: LD_VAR 0 4
47588: ARRAY
47589: PUSH
47590: LD_INT 2
47592: ARRAY
47593: PPUSH
47594: CALL_OW 297
47598: ST_TO_ADDR
// end ; end ;
47599: GO 47488
47601: POP
47602: POP
// result := hex ;
47603: LD_ADDR_VAR 0 3
47607: PUSH
47608: LD_VAR 0 7
47612: ST_TO_ADDR
// end ;
47613: LD_VAR 0 3
47617: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47618: LD_INT 0
47620: PPUSH
47621: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47622: LD_VAR 0 1
47626: NOT
47627: PUSH
47628: LD_VAR 0 1
47632: PUSH
47633: LD_INT 21
47635: PUSH
47636: LD_INT 2
47638: PUSH
47639: EMPTY
47640: LIST
47641: LIST
47642: PUSH
47643: LD_INT 23
47645: PUSH
47646: LD_INT 2
47648: PUSH
47649: EMPTY
47650: LIST
47651: LIST
47652: PUSH
47653: EMPTY
47654: LIST
47655: LIST
47656: PPUSH
47657: CALL_OW 69
47661: IN
47662: NOT
47663: OR
47664: IFFALSE 47668
// exit ;
47666: GO 47715
// for i = 1 to 3 do
47668: LD_ADDR_VAR 0 3
47672: PUSH
47673: DOUBLE
47674: LD_INT 1
47676: DEC
47677: ST_TO_ADDR
47678: LD_INT 3
47680: PUSH
47681: FOR_TO
47682: IFFALSE 47713
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47684: LD_VAR 0 1
47688: PPUSH
47689: CALL_OW 250
47693: PPUSH
47694: LD_VAR 0 1
47698: PPUSH
47699: CALL_OW 251
47703: PPUSH
47704: LD_INT 1
47706: PPUSH
47707: CALL_OW 453
47711: GO 47681
47713: POP
47714: POP
// end ;
47715: LD_VAR 0 2
47719: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47720: LD_INT 0
47722: PPUSH
47723: PPUSH
47724: PPUSH
47725: PPUSH
47726: PPUSH
47727: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47728: LD_VAR 0 1
47732: NOT
47733: PUSH
47734: LD_VAR 0 2
47738: NOT
47739: OR
47740: PUSH
47741: LD_VAR 0 1
47745: PPUSH
47746: CALL_OW 314
47750: OR
47751: IFFALSE 47755
// exit ;
47753: GO 48196
// x := GetX ( enemy_unit ) ;
47755: LD_ADDR_VAR 0 7
47759: PUSH
47760: LD_VAR 0 2
47764: PPUSH
47765: CALL_OW 250
47769: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47770: LD_ADDR_VAR 0 8
47774: PUSH
47775: LD_VAR 0 2
47779: PPUSH
47780: CALL_OW 251
47784: ST_TO_ADDR
// if not x or not y then
47785: LD_VAR 0 7
47789: NOT
47790: PUSH
47791: LD_VAR 0 8
47795: NOT
47796: OR
47797: IFFALSE 47801
// exit ;
47799: GO 48196
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47801: LD_ADDR_VAR 0 6
47805: PUSH
47806: LD_VAR 0 7
47810: PPUSH
47811: LD_INT 0
47813: PPUSH
47814: LD_INT 4
47816: PPUSH
47817: CALL_OW 272
47821: PUSH
47822: LD_VAR 0 8
47826: PPUSH
47827: LD_INT 0
47829: PPUSH
47830: LD_INT 4
47832: PPUSH
47833: CALL_OW 273
47837: PUSH
47838: EMPTY
47839: LIST
47840: LIST
47841: PUSH
47842: LD_VAR 0 7
47846: PPUSH
47847: LD_INT 1
47849: PPUSH
47850: LD_INT 4
47852: PPUSH
47853: CALL_OW 272
47857: PUSH
47858: LD_VAR 0 8
47862: PPUSH
47863: LD_INT 1
47865: PPUSH
47866: LD_INT 4
47868: PPUSH
47869: CALL_OW 273
47873: PUSH
47874: EMPTY
47875: LIST
47876: LIST
47877: PUSH
47878: LD_VAR 0 7
47882: PPUSH
47883: LD_INT 2
47885: PPUSH
47886: LD_INT 4
47888: PPUSH
47889: CALL_OW 272
47893: PUSH
47894: LD_VAR 0 8
47898: PPUSH
47899: LD_INT 2
47901: PPUSH
47902: LD_INT 4
47904: PPUSH
47905: CALL_OW 273
47909: PUSH
47910: EMPTY
47911: LIST
47912: LIST
47913: PUSH
47914: LD_VAR 0 7
47918: PPUSH
47919: LD_INT 3
47921: PPUSH
47922: LD_INT 4
47924: PPUSH
47925: CALL_OW 272
47929: PUSH
47930: LD_VAR 0 8
47934: PPUSH
47935: LD_INT 3
47937: PPUSH
47938: LD_INT 4
47940: PPUSH
47941: CALL_OW 273
47945: PUSH
47946: EMPTY
47947: LIST
47948: LIST
47949: PUSH
47950: LD_VAR 0 7
47954: PPUSH
47955: LD_INT 4
47957: PPUSH
47958: LD_INT 4
47960: PPUSH
47961: CALL_OW 272
47965: PUSH
47966: LD_VAR 0 8
47970: PPUSH
47971: LD_INT 4
47973: PPUSH
47974: LD_INT 4
47976: PPUSH
47977: CALL_OW 273
47981: PUSH
47982: EMPTY
47983: LIST
47984: LIST
47985: PUSH
47986: LD_VAR 0 7
47990: PPUSH
47991: LD_INT 5
47993: PPUSH
47994: LD_INT 4
47996: PPUSH
47997: CALL_OW 272
48001: PUSH
48002: LD_VAR 0 8
48006: PPUSH
48007: LD_INT 5
48009: PPUSH
48010: LD_INT 4
48012: PPUSH
48013: CALL_OW 273
48017: PUSH
48018: EMPTY
48019: LIST
48020: LIST
48021: PUSH
48022: EMPTY
48023: LIST
48024: LIST
48025: LIST
48026: LIST
48027: LIST
48028: LIST
48029: ST_TO_ADDR
// for i = tmp downto 1 do
48030: LD_ADDR_VAR 0 4
48034: PUSH
48035: DOUBLE
48036: LD_VAR 0 6
48040: INC
48041: ST_TO_ADDR
48042: LD_INT 1
48044: PUSH
48045: FOR_DOWNTO
48046: IFFALSE 48147
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48048: LD_VAR 0 6
48052: PUSH
48053: LD_VAR 0 4
48057: ARRAY
48058: PUSH
48059: LD_INT 1
48061: ARRAY
48062: PPUSH
48063: LD_VAR 0 6
48067: PUSH
48068: LD_VAR 0 4
48072: ARRAY
48073: PUSH
48074: LD_INT 2
48076: ARRAY
48077: PPUSH
48078: CALL_OW 488
48082: NOT
48083: PUSH
48084: LD_VAR 0 6
48088: PUSH
48089: LD_VAR 0 4
48093: ARRAY
48094: PUSH
48095: LD_INT 1
48097: ARRAY
48098: PPUSH
48099: LD_VAR 0 6
48103: PUSH
48104: LD_VAR 0 4
48108: ARRAY
48109: PUSH
48110: LD_INT 2
48112: ARRAY
48113: PPUSH
48114: CALL_OW 428
48118: PUSH
48119: LD_INT 0
48121: NONEQUAL
48122: OR
48123: IFFALSE 48145
// tmp := Delete ( tmp , i ) ;
48125: LD_ADDR_VAR 0 6
48129: PUSH
48130: LD_VAR 0 6
48134: PPUSH
48135: LD_VAR 0 4
48139: PPUSH
48140: CALL_OW 3
48144: ST_TO_ADDR
48145: GO 48045
48147: POP
48148: POP
// j := GetClosestHex ( unit , tmp ) ;
48149: LD_ADDR_VAR 0 5
48153: PUSH
48154: LD_VAR 0 1
48158: PPUSH
48159: LD_VAR 0 6
48163: PPUSH
48164: CALL 47449 0 2
48168: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48169: LD_VAR 0 1
48173: PPUSH
48174: LD_VAR 0 5
48178: PUSH
48179: LD_INT 1
48181: ARRAY
48182: PPUSH
48183: LD_VAR 0 5
48187: PUSH
48188: LD_INT 2
48190: ARRAY
48191: PPUSH
48192: CALL_OW 111
// end ;
48196: LD_VAR 0 3
48200: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48201: LD_INT 0
48203: PPUSH
48204: PPUSH
48205: PPUSH
// uc_side = 0 ;
48206: LD_ADDR_OWVAR 20
48210: PUSH
48211: LD_INT 0
48213: ST_TO_ADDR
// uc_nation = 0 ;
48214: LD_ADDR_OWVAR 21
48218: PUSH
48219: LD_INT 0
48221: ST_TO_ADDR
// InitHc_All ( ) ;
48222: CALL_OW 584
// InitVc ;
48226: CALL_OW 20
// if mastodonts then
48230: LD_VAR 0 6
48234: IFFALSE 48301
// for i = 1 to mastodonts do
48236: LD_ADDR_VAR 0 11
48240: PUSH
48241: DOUBLE
48242: LD_INT 1
48244: DEC
48245: ST_TO_ADDR
48246: LD_VAR 0 6
48250: PUSH
48251: FOR_TO
48252: IFFALSE 48299
// begin vc_chassis := 31 ;
48254: LD_ADDR_OWVAR 37
48258: PUSH
48259: LD_INT 31
48261: ST_TO_ADDR
// vc_control := control_rider ;
48262: LD_ADDR_OWVAR 38
48266: PUSH
48267: LD_INT 4
48269: ST_TO_ADDR
// animal := CreateVehicle ;
48270: LD_ADDR_VAR 0 12
48274: PUSH
48275: CALL_OW 45
48279: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48280: LD_VAR 0 12
48284: PPUSH
48285: LD_VAR 0 8
48289: PPUSH
48290: LD_INT 0
48292: PPUSH
48293: CALL 50436 0 3
// end ;
48297: GO 48251
48299: POP
48300: POP
// if horses then
48301: LD_VAR 0 5
48305: IFFALSE 48372
// for i = 1 to horses do
48307: LD_ADDR_VAR 0 11
48311: PUSH
48312: DOUBLE
48313: LD_INT 1
48315: DEC
48316: ST_TO_ADDR
48317: LD_VAR 0 5
48321: PUSH
48322: FOR_TO
48323: IFFALSE 48370
// begin hc_class := 21 ;
48325: LD_ADDR_OWVAR 28
48329: PUSH
48330: LD_INT 21
48332: ST_TO_ADDR
// hc_gallery :=  ;
48333: LD_ADDR_OWVAR 33
48337: PUSH
48338: LD_STRING 
48340: ST_TO_ADDR
// animal := CreateHuman ;
48341: LD_ADDR_VAR 0 12
48345: PUSH
48346: CALL_OW 44
48350: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48351: LD_VAR 0 12
48355: PPUSH
48356: LD_VAR 0 8
48360: PPUSH
48361: LD_INT 0
48363: PPUSH
48364: CALL 50436 0 3
// end ;
48368: GO 48322
48370: POP
48371: POP
// if birds then
48372: LD_VAR 0 1
48376: IFFALSE 48443
// for i = 1 to birds do
48378: LD_ADDR_VAR 0 11
48382: PUSH
48383: DOUBLE
48384: LD_INT 1
48386: DEC
48387: ST_TO_ADDR
48388: LD_VAR 0 1
48392: PUSH
48393: FOR_TO
48394: IFFALSE 48441
// begin hc_class = 18 ;
48396: LD_ADDR_OWVAR 28
48400: PUSH
48401: LD_INT 18
48403: ST_TO_ADDR
// hc_gallery =  ;
48404: LD_ADDR_OWVAR 33
48408: PUSH
48409: LD_STRING 
48411: ST_TO_ADDR
// animal := CreateHuman ;
48412: LD_ADDR_VAR 0 12
48416: PUSH
48417: CALL_OW 44
48421: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48422: LD_VAR 0 12
48426: PPUSH
48427: LD_VAR 0 8
48431: PPUSH
48432: LD_INT 0
48434: PPUSH
48435: CALL 50436 0 3
// end ;
48439: GO 48393
48441: POP
48442: POP
// if tigers then
48443: LD_VAR 0 2
48447: IFFALSE 48531
// for i = 1 to tigers do
48449: LD_ADDR_VAR 0 11
48453: PUSH
48454: DOUBLE
48455: LD_INT 1
48457: DEC
48458: ST_TO_ADDR
48459: LD_VAR 0 2
48463: PUSH
48464: FOR_TO
48465: IFFALSE 48529
// begin hc_class = class_tiger ;
48467: LD_ADDR_OWVAR 28
48471: PUSH
48472: LD_INT 14
48474: ST_TO_ADDR
// hc_gallery =  ;
48475: LD_ADDR_OWVAR 33
48479: PUSH
48480: LD_STRING 
48482: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48483: LD_ADDR_OWVAR 35
48487: PUSH
48488: LD_INT 7
48490: NEG
48491: PPUSH
48492: LD_INT 7
48494: PPUSH
48495: CALL_OW 12
48499: ST_TO_ADDR
// animal := CreateHuman ;
48500: LD_ADDR_VAR 0 12
48504: PUSH
48505: CALL_OW 44
48509: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48510: LD_VAR 0 12
48514: PPUSH
48515: LD_VAR 0 8
48519: PPUSH
48520: LD_INT 0
48522: PPUSH
48523: CALL 50436 0 3
// end ;
48527: GO 48464
48529: POP
48530: POP
// if apemans then
48531: LD_VAR 0 3
48535: IFFALSE 48658
// for i = 1 to apemans do
48537: LD_ADDR_VAR 0 11
48541: PUSH
48542: DOUBLE
48543: LD_INT 1
48545: DEC
48546: ST_TO_ADDR
48547: LD_VAR 0 3
48551: PUSH
48552: FOR_TO
48553: IFFALSE 48656
// begin hc_class = class_apeman ;
48555: LD_ADDR_OWVAR 28
48559: PUSH
48560: LD_INT 12
48562: ST_TO_ADDR
// hc_gallery =  ;
48563: LD_ADDR_OWVAR 33
48567: PUSH
48568: LD_STRING 
48570: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
48571: LD_ADDR_OWVAR 35
48575: PUSH
48576: LD_INT 2
48578: NEG
48579: PPUSH
48580: LD_INT 2
48582: PPUSH
48583: CALL_OW 12
48587: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48588: LD_ADDR_OWVAR 31
48592: PUSH
48593: LD_INT 1
48595: PPUSH
48596: LD_INT 3
48598: PPUSH
48599: CALL_OW 12
48603: PUSH
48604: LD_INT 1
48606: PPUSH
48607: LD_INT 3
48609: PPUSH
48610: CALL_OW 12
48614: PUSH
48615: LD_INT 0
48617: PUSH
48618: LD_INT 0
48620: PUSH
48621: EMPTY
48622: LIST
48623: LIST
48624: LIST
48625: LIST
48626: ST_TO_ADDR
// animal := CreateHuman ;
48627: LD_ADDR_VAR 0 12
48631: PUSH
48632: CALL_OW 44
48636: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48637: LD_VAR 0 12
48641: PPUSH
48642: LD_VAR 0 8
48646: PPUSH
48647: LD_INT 0
48649: PPUSH
48650: CALL 50436 0 3
// end ;
48654: GO 48552
48656: POP
48657: POP
// if enchidnas then
48658: LD_VAR 0 4
48662: IFFALSE 48729
// for i = 1 to enchidnas do
48664: LD_ADDR_VAR 0 11
48668: PUSH
48669: DOUBLE
48670: LD_INT 1
48672: DEC
48673: ST_TO_ADDR
48674: LD_VAR 0 4
48678: PUSH
48679: FOR_TO
48680: IFFALSE 48727
// begin hc_class = 13 ;
48682: LD_ADDR_OWVAR 28
48686: PUSH
48687: LD_INT 13
48689: ST_TO_ADDR
// hc_gallery =  ;
48690: LD_ADDR_OWVAR 33
48694: PUSH
48695: LD_STRING 
48697: ST_TO_ADDR
// animal := CreateHuman ;
48698: LD_ADDR_VAR 0 12
48702: PUSH
48703: CALL_OW 44
48707: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48708: LD_VAR 0 12
48712: PPUSH
48713: LD_VAR 0 8
48717: PPUSH
48718: LD_INT 0
48720: PPUSH
48721: CALL 50436 0 3
// end ;
48725: GO 48679
48727: POP
48728: POP
// if fishes then
48729: LD_VAR 0 7
48733: IFFALSE 48800
// for i = 1 to fishes do
48735: LD_ADDR_VAR 0 11
48739: PUSH
48740: DOUBLE
48741: LD_INT 1
48743: DEC
48744: ST_TO_ADDR
48745: LD_VAR 0 7
48749: PUSH
48750: FOR_TO
48751: IFFALSE 48798
// begin hc_class = 20 ;
48753: LD_ADDR_OWVAR 28
48757: PUSH
48758: LD_INT 20
48760: ST_TO_ADDR
// hc_gallery =  ;
48761: LD_ADDR_OWVAR 33
48765: PUSH
48766: LD_STRING 
48768: ST_TO_ADDR
// animal := CreateHuman ;
48769: LD_ADDR_VAR 0 12
48773: PUSH
48774: CALL_OW 44
48778: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48779: LD_VAR 0 12
48783: PPUSH
48784: LD_VAR 0 9
48788: PPUSH
48789: LD_INT 0
48791: PPUSH
48792: CALL 50436 0 3
// end ;
48796: GO 48750
48798: POP
48799: POP
// end ;
48800: LD_VAR 0 10
48804: RET
// export function WantHeal ( sci , unit ) ; begin
48805: LD_INT 0
48807: PPUSH
// if GetTaskList ( sci ) > 0 then
48808: LD_VAR 0 1
48812: PPUSH
48813: CALL_OW 437
48817: PUSH
48818: LD_INT 0
48820: GREATER
48821: IFFALSE 48891
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48823: LD_VAR 0 1
48827: PPUSH
48828: CALL_OW 437
48832: PUSH
48833: LD_INT 1
48835: ARRAY
48836: PUSH
48837: LD_INT 1
48839: ARRAY
48840: PUSH
48841: LD_STRING l
48843: EQUAL
48844: PUSH
48845: LD_VAR 0 1
48849: PPUSH
48850: CALL_OW 437
48854: PUSH
48855: LD_INT 1
48857: ARRAY
48858: PUSH
48859: LD_INT 4
48861: ARRAY
48862: PUSH
48863: LD_VAR 0 2
48867: EQUAL
48868: AND
48869: IFFALSE 48881
// result := true else
48871: LD_ADDR_VAR 0 3
48875: PUSH
48876: LD_INT 1
48878: ST_TO_ADDR
48879: GO 48889
// result := false ;
48881: LD_ADDR_VAR 0 3
48885: PUSH
48886: LD_INT 0
48888: ST_TO_ADDR
// end else
48889: GO 48899
// result := false ;
48891: LD_ADDR_VAR 0 3
48895: PUSH
48896: LD_INT 0
48898: ST_TO_ADDR
// end ;
48899: LD_VAR 0 3
48903: RET
// export function HealTarget ( sci ) ; begin
48904: LD_INT 0
48906: PPUSH
// if not sci then
48907: LD_VAR 0 1
48911: NOT
48912: IFFALSE 48916
// exit ;
48914: GO 48981
// result := 0 ;
48916: LD_ADDR_VAR 0 2
48920: PUSH
48921: LD_INT 0
48923: ST_TO_ADDR
// if GetTaskList ( sci ) then
48924: LD_VAR 0 1
48928: PPUSH
48929: CALL_OW 437
48933: IFFALSE 48981
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48935: LD_VAR 0 1
48939: PPUSH
48940: CALL_OW 437
48944: PUSH
48945: LD_INT 1
48947: ARRAY
48948: PUSH
48949: LD_INT 1
48951: ARRAY
48952: PUSH
48953: LD_STRING l
48955: EQUAL
48956: IFFALSE 48981
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48958: LD_ADDR_VAR 0 2
48962: PUSH
48963: LD_VAR 0 1
48967: PPUSH
48968: CALL_OW 437
48972: PUSH
48973: LD_INT 1
48975: ARRAY
48976: PUSH
48977: LD_INT 4
48979: ARRAY
48980: ST_TO_ADDR
// end ;
48981: LD_VAR 0 2
48985: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48986: LD_INT 0
48988: PPUSH
48989: PPUSH
48990: PPUSH
48991: PPUSH
// if not base_units then
48992: LD_VAR 0 1
48996: NOT
48997: IFFALSE 49001
// exit ;
48999: GO 49088
// result := false ;
49001: LD_ADDR_VAR 0 2
49005: PUSH
49006: LD_INT 0
49008: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
49009: LD_ADDR_VAR 0 5
49013: PUSH
49014: LD_VAR 0 1
49018: PPUSH
49019: LD_INT 21
49021: PUSH
49022: LD_INT 3
49024: PUSH
49025: EMPTY
49026: LIST
49027: LIST
49028: PPUSH
49029: CALL_OW 72
49033: ST_TO_ADDR
// if not tmp then
49034: LD_VAR 0 5
49038: NOT
49039: IFFALSE 49043
// exit ;
49041: GO 49088
// for i in tmp do
49043: LD_ADDR_VAR 0 3
49047: PUSH
49048: LD_VAR 0 5
49052: PUSH
49053: FOR_IN
49054: IFFALSE 49086
// begin result := EnemyInRange ( i , 22 ) ;
49056: LD_ADDR_VAR 0 2
49060: PUSH
49061: LD_VAR 0 3
49065: PPUSH
49066: LD_INT 22
49068: PPUSH
49069: CALL 47324 0 2
49073: ST_TO_ADDR
// if result then
49074: LD_VAR 0 2
49078: IFFALSE 49084
// exit ;
49080: POP
49081: POP
49082: GO 49088
// end ;
49084: GO 49053
49086: POP
49087: POP
// end ;
49088: LD_VAR 0 2
49092: RET
// export function FilterByTag ( units , tag ) ; begin
49093: LD_INT 0
49095: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
49096: LD_ADDR_VAR 0 3
49100: PUSH
49101: LD_VAR 0 1
49105: PPUSH
49106: LD_INT 120
49108: PUSH
49109: LD_VAR 0 2
49113: PUSH
49114: EMPTY
49115: LIST
49116: LIST
49117: PPUSH
49118: CALL_OW 72
49122: ST_TO_ADDR
// end ;
49123: LD_VAR 0 3
49127: RET
// export function IsDriver ( un ) ; begin
49128: LD_INT 0
49130: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
49131: LD_ADDR_VAR 0 2
49135: PUSH
49136: LD_VAR 0 1
49140: PUSH
49141: LD_INT 55
49143: PUSH
49144: EMPTY
49145: LIST
49146: PPUSH
49147: CALL_OW 69
49151: IN
49152: ST_TO_ADDR
// end ;
49153: LD_VAR 0 2
49157: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
49158: LD_INT 0
49160: PPUSH
49161: PPUSH
// list := [ ] ;
49162: LD_ADDR_VAR 0 5
49166: PUSH
49167: EMPTY
49168: ST_TO_ADDR
// case d of 0 :
49169: LD_VAR 0 3
49173: PUSH
49174: LD_INT 0
49176: DOUBLE
49177: EQUAL
49178: IFTRUE 49182
49180: GO 49315
49182: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
49183: LD_ADDR_VAR 0 5
49187: PUSH
49188: LD_VAR 0 1
49192: PUSH
49193: LD_INT 4
49195: MINUS
49196: PUSH
49197: LD_VAR 0 2
49201: PUSH
49202: LD_INT 4
49204: MINUS
49205: PUSH
49206: LD_INT 2
49208: PUSH
49209: EMPTY
49210: LIST
49211: LIST
49212: LIST
49213: PUSH
49214: LD_VAR 0 1
49218: PUSH
49219: LD_INT 3
49221: MINUS
49222: PUSH
49223: LD_VAR 0 2
49227: PUSH
49228: LD_INT 1
49230: PUSH
49231: EMPTY
49232: LIST
49233: LIST
49234: LIST
49235: PUSH
49236: LD_VAR 0 1
49240: PUSH
49241: LD_INT 4
49243: PLUS
49244: PUSH
49245: LD_VAR 0 2
49249: PUSH
49250: LD_INT 4
49252: PUSH
49253: EMPTY
49254: LIST
49255: LIST
49256: LIST
49257: PUSH
49258: LD_VAR 0 1
49262: PUSH
49263: LD_INT 3
49265: PLUS
49266: PUSH
49267: LD_VAR 0 2
49271: PUSH
49272: LD_INT 3
49274: PLUS
49275: PUSH
49276: LD_INT 5
49278: PUSH
49279: EMPTY
49280: LIST
49281: LIST
49282: LIST
49283: PUSH
49284: LD_VAR 0 1
49288: PUSH
49289: LD_VAR 0 2
49293: PUSH
49294: LD_INT 4
49296: PLUS
49297: PUSH
49298: LD_INT 0
49300: PUSH
49301: EMPTY
49302: LIST
49303: LIST
49304: LIST
49305: PUSH
49306: EMPTY
49307: LIST
49308: LIST
49309: LIST
49310: LIST
49311: LIST
49312: ST_TO_ADDR
// end ; 1 :
49313: GO 50013
49315: LD_INT 1
49317: DOUBLE
49318: EQUAL
49319: IFTRUE 49323
49321: GO 49456
49323: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
49324: LD_ADDR_VAR 0 5
49328: PUSH
49329: LD_VAR 0 1
49333: PUSH
49334: LD_VAR 0 2
49338: PUSH
49339: LD_INT 4
49341: MINUS
49342: PUSH
49343: LD_INT 3
49345: PUSH
49346: EMPTY
49347: LIST
49348: LIST
49349: LIST
49350: PUSH
49351: LD_VAR 0 1
49355: PUSH
49356: LD_INT 3
49358: MINUS
49359: PUSH
49360: LD_VAR 0 2
49364: PUSH
49365: LD_INT 3
49367: MINUS
49368: PUSH
49369: LD_INT 2
49371: PUSH
49372: EMPTY
49373: LIST
49374: LIST
49375: LIST
49376: PUSH
49377: LD_VAR 0 1
49381: PUSH
49382: LD_INT 4
49384: MINUS
49385: PUSH
49386: LD_VAR 0 2
49390: PUSH
49391: LD_INT 1
49393: PUSH
49394: EMPTY
49395: LIST
49396: LIST
49397: LIST
49398: PUSH
49399: LD_VAR 0 1
49403: PUSH
49404: LD_VAR 0 2
49408: PUSH
49409: LD_INT 3
49411: PLUS
49412: PUSH
49413: LD_INT 0
49415: PUSH
49416: EMPTY
49417: LIST
49418: LIST
49419: LIST
49420: PUSH
49421: LD_VAR 0 1
49425: PUSH
49426: LD_INT 4
49428: PLUS
49429: PUSH
49430: LD_VAR 0 2
49434: PUSH
49435: LD_INT 4
49437: PLUS
49438: PUSH
49439: LD_INT 5
49441: PUSH
49442: EMPTY
49443: LIST
49444: LIST
49445: LIST
49446: PUSH
49447: EMPTY
49448: LIST
49449: LIST
49450: LIST
49451: LIST
49452: LIST
49453: ST_TO_ADDR
// end ; 2 :
49454: GO 50013
49456: LD_INT 2
49458: DOUBLE
49459: EQUAL
49460: IFTRUE 49464
49462: GO 49593
49464: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
49465: LD_ADDR_VAR 0 5
49469: PUSH
49470: LD_VAR 0 1
49474: PUSH
49475: LD_VAR 0 2
49479: PUSH
49480: LD_INT 3
49482: MINUS
49483: PUSH
49484: LD_INT 3
49486: PUSH
49487: EMPTY
49488: LIST
49489: LIST
49490: LIST
49491: PUSH
49492: LD_VAR 0 1
49496: PUSH
49497: LD_INT 4
49499: PLUS
49500: PUSH
49501: LD_VAR 0 2
49505: PUSH
49506: LD_INT 4
49508: PUSH
49509: EMPTY
49510: LIST
49511: LIST
49512: LIST
49513: PUSH
49514: LD_VAR 0 1
49518: PUSH
49519: LD_VAR 0 2
49523: PUSH
49524: LD_INT 4
49526: PLUS
49527: PUSH
49528: LD_INT 0
49530: PUSH
49531: EMPTY
49532: LIST
49533: LIST
49534: LIST
49535: PUSH
49536: LD_VAR 0 1
49540: PUSH
49541: LD_INT 3
49543: MINUS
49544: PUSH
49545: LD_VAR 0 2
49549: PUSH
49550: LD_INT 1
49552: PUSH
49553: EMPTY
49554: LIST
49555: LIST
49556: LIST
49557: PUSH
49558: LD_VAR 0 1
49562: PUSH
49563: LD_INT 4
49565: MINUS
49566: PUSH
49567: LD_VAR 0 2
49571: PUSH
49572: LD_INT 4
49574: MINUS
49575: PUSH
49576: LD_INT 2
49578: PUSH
49579: EMPTY
49580: LIST
49581: LIST
49582: LIST
49583: PUSH
49584: EMPTY
49585: LIST
49586: LIST
49587: LIST
49588: LIST
49589: LIST
49590: ST_TO_ADDR
// end ; 3 :
49591: GO 50013
49593: LD_INT 3
49595: DOUBLE
49596: EQUAL
49597: IFTRUE 49601
49599: GO 49734
49601: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49602: LD_ADDR_VAR 0 5
49606: PUSH
49607: LD_VAR 0 1
49611: PUSH
49612: LD_INT 3
49614: PLUS
49615: PUSH
49616: LD_VAR 0 2
49620: PUSH
49621: LD_INT 4
49623: PUSH
49624: EMPTY
49625: LIST
49626: LIST
49627: LIST
49628: PUSH
49629: LD_VAR 0 1
49633: PUSH
49634: LD_INT 4
49636: PLUS
49637: PUSH
49638: LD_VAR 0 2
49642: PUSH
49643: LD_INT 4
49645: PLUS
49646: PUSH
49647: LD_INT 5
49649: PUSH
49650: EMPTY
49651: LIST
49652: LIST
49653: LIST
49654: PUSH
49655: LD_VAR 0 1
49659: PUSH
49660: LD_INT 4
49662: MINUS
49663: PUSH
49664: LD_VAR 0 2
49668: PUSH
49669: LD_INT 1
49671: PUSH
49672: EMPTY
49673: LIST
49674: LIST
49675: LIST
49676: PUSH
49677: LD_VAR 0 1
49681: PUSH
49682: LD_VAR 0 2
49686: PUSH
49687: LD_INT 4
49689: MINUS
49690: PUSH
49691: LD_INT 3
49693: PUSH
49694: EMPTY
49695: LIST
49696: LIST
49697: LIST
49698: PUSH
49699: LD_VAR 0 1
49703: PUSH
49704: LD_INT 3
49706: MINUS
49707: PUSH
49708: LD_VAR 0 2
49712: PUSH
49713: LD_INT 3
49715: MINUS
49716: PUSH
49717: LD_INT 2
49719: PUSH
49720: EMPTY
49721: LIST
49722: LIST
49723: LIST
49724: PUSH
49725: EMPTY
49726: LIST
49727: LIST
49728: LIST
49729: LIST
49730: LIST
49731: ST_TO_ADDR
// end ; 4 :
49732: GO 50013
49734: LD_INT 4
49736: DOUBLE
49737: EQUAL
49738: IFTRUE 49742
49740: GO 49875
49742: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49743: LD_ADDR_VAR 0 5
49747: PUSH
49748: LD_VAR 0 1
49752: PUSH
49753: LD_VAR 0 2
49757: PUSH
49758: LD_INT 4
49760: PLUS
49761: PUSH
49762: LD_INT 0
49764: PUSH
49765: EMPTY
49766: LIST
49767: LIST
49768: LIST
49769: PUSH
49770: LD_VAR 0 1
49774: PUSH
49775: LD_INT 3
49777: PLUS
49778: PUSH
49779: LD_VAR 0 2
49783: PUSH
49784: LD_INT 3
49786: PLUS
49787: PUSH
49788: LD_INT 5
49790: PUSH
49791: EMPTY
49792: LIST
49793: LIST
49794: LIST
49795: PUSH
49796: LD_VAR 0 1
49800: PUSH
49801: LD_INT 4
49803: PLUS
49804: PUSH
49805: LD_VAR 0 2
49809: PUSH
49810: LD_INT 4
49812: PUSH
49813: EMPTY
49814: LIST
49815: LIST
49816: LIST
49817: PUSH
49818: LD_VAR 0 1
49822: PUSH
49823: LD_VAR 0 2
49827: PUSH
49828: LD_INT 3
49830: MINUS
49831: PUSH
49832: LD_INT 3
49834: PUSH
49835: EMPTY
49836: LIST
49837: LIST
49838: LIST
49839: PUSH
49840: LD_VAR 0 1
49844: PUSH
49845: LD_INT 4
49847: MINUS
49848: PUSH
49849: LD_VAR 0 2
49853: PUSH
49854: LD_INT 4
49856: MINUS
49857: PUSH
49858: LD_INT 2
49860: PUSH
49861: EMPTY
49862: LIST
49863: LIST
49864: LIST
49865: PUSH
49866: EMPTY
49867: LIST
49868: LIST
49869: LIST
49870: LIST
49871: LIST
49872: ST_TO_ADDR
// end ; 5 :
49873: GO 50013
49875: LD_INT 5
49877: DOUBLE
49878: EQUAL
49879: IFTRUE 49883
49881: GO 50012
49883: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49884: LD_ADDR_VAR 0 5
49888: PUSH
49889: LD_VAR 0 1
49893: PUSH
49894: LD_INT 4
49896: MINUS
49897: PUSH
49898: LD_VAR 0 2
49902: PUSH
49903: LD_INT 1
49905: PUSH
49906: EMPTY
49907: LIST
49908: LIST
49909: LIST
49910: PUSH
49911: LD_VAR 0 1
49915: PUSH
49916: LD_VAR 0 2
49920: PUSH
49921: LD_INT 4
49923: MINUS
49924: PUSH
49925: LD_INT 3
49927: PUSH
49928: EMPTY
49929: LIST
49930: LIST
49931: LIST
49932: PUSH
49933: LD_VAR 0 1
49937: PUSH
49938: LD_INT 4
49940: PLUS
49941: PUSH
49942: LD_VAR 0 2
49946: PUSH
49947: LD_INT 4
49949: PLUS
49950: PUSH
49951: LD_INT 5
49953: PUSH
49954: EMPTY
49955: LIST
49956: LIST
49957: LIST
49958: PUSH
49959: LD_VAR 0 1
49963: PUSH
49964: LD_INT 3
49966: PLUS
49967: PUSH
49968: LD_VAR 0 2
49972: PUSH
49973: LD_INT 4
49975: PUSH
49976: EMPTY
49977: LIST
49978: LIST
49979: LIST
49980: PUSH
49981: LD_VAR 0 1
49985: PUSH
49986: LD_VAR 0 2
49990: PUSH
49991: LD_INT 3
49993: PLUS
49994: PUSH
49995: LD_INT 0
49997: PUSH
49998: EMPTY
49999: LIST
50000: LIST
50001: LIST
50002: PUSH
50003: EMPTY
50004: LIST
50005: LIST
50006: LIST
50007: LIST
50008: LIST
50009: ST_TO_ADDR
// end ; end ;
50010: GO 50013
50012: POP
// result := list ;
50013: LD_ADDR_VAR 0 4
50017: PUSH
50018: LD_VAR 0 5
50022: ST_TO_ADDR
// end ;
50023: LD_VAR 0 4
50027: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
50028: LD_INT 0
50030: PPUSH
50031: PPUSH
50032: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
50033: LD_VAR 0 1
50037: NOT
50038: PUSH
50039: LD_VAR 0 2
50043: PUSH
50044: LD_INT 1
50046: PUSH
50047: LD_INT 2
50049: PUSH
50050: LD_INT 3
50052: PUSH
50053: LD_INT 4
50055: PUSH
50056: EMPTY
50057: LIST
50058: LIST
50059: LIST
50060: LIST
50061: IN
50062: NOT
50063: OR
50064: IFFALSE 50068
// exit ;
50066: GO 50160
// tmp := [ ] ;
50068: LD_ADDR_VAR 0 5
50072: PUSH
50073: EMPTY
50074: ST_TO_ADDR
// for i in units do
50075: LD_ADDR_VAR 0 4
50079: PUSH
50080: LD_VAR 0 1
50084: PUSH
50085: FOR_IN
50086: IFFALSE 50129
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
50088: LD_ADDR_VAR 0 5
50092: PUSH
50093: LD_VAR 0 5
50097: PPUSH
50098: LD_VAR 0 5
50102: PUSH
50103: LD_INT 1
50105: PLUS
50106: PPUSH
50107: LD_VAR 0 4
50111: PPUSH
50112: LD_VAR 0 2
50116: PPUSH
50117: CALL_OW 259
50121: PPUSH
50122: CALL_OW 2
50126: ST_TO_ADDR
50127: GO 50085
50129: POP
50130: POP
// if not tmp then
50131: LD_VAR 0 5
50135: NOT
50136: IFFALSE 50140
// exit ;
50138: GO 50160
// result := SortListByListDesc ( units , tmp ) ;
50140: LD_ADDR_VAR 0 3
50144: PUSH
50145: LD_VAR 0 1
50149: PPUSH
50150: LD_VAR 0 5
50154: PPUSH
50155: CALL_OW 77
50159: ST_TO_ADDR
// end ;
50160: LD_VAR 0 3
50164: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
50165: LD_INT 0
50167: PPUSH
50168: PPUSH
50169: PPUSH
// result := false ;
50170: LD_ADDR_VAR 0 3
50174: PUSH
50175: LD_INT 0
50177: ST_TO_ADDR
// x := GetX ( building ) ;
50178: LD_ADDR_VAR 0 4
50182: PUSH
50183: LD_VAR 0 2
50187: PPUSH
50188: CALL_OW 250
50192: ST_TO_ADDR
// y := GetY ( building ) ;
50193: LD_ADDR_VAR 0 5
50197: PUSH
50198: LD_VAR 0 2
50202: PPUSH
50203: CALL_OW 251
50207: ST_TO_ADDR
// if not building or not x or not y then
50208: LD_VAR 0 2
50212: NOT
50213: PUSH
50214: LD_VAR 0 4
50218: NOT
50219: OR
50220: PUSH
50221: LD_VAR 0 5
50225: NOT
50226: OR
50227: IFFALSE 50231
// exit ;
50229: GO 50323
// if GetTaskList ( unit ) then
50231: LD_VAR 0 1
50235: PPUSH
50236: CALL_OW 437
50240: IFFALSE 50323
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50242: LD_STRING e
50244: PUSH
50245: LD_VAR 0 1
50249: PPUSH
50250: CALL_OW 437
50254: PUSH
50255: LD_INT 1
50257: ARRAY
50258: PUSH
50259: LD_INT 1
50261: ARRAY
50262: EQUAL
50263: PUSH
50264: LD_VAR 0 4
50268: PUSH
50269: LD_VAR 0 1
50273: PPUSH
50274: CALL_OW 437
50278: PUSH
50279: LD_INT 1
50281: ARRAY
50282: PUSH
50283: LD_INT 2
50285: ARRAY
50286: EQUAL
50287: AND
50288: PUSH
50289: LD_VAR 0 5
50293: PUSH
50294: LD_VAR 0 1
50298: PPUSH
50299: CALL_OW 437
50303: PUSH
50304: LD_INT 1
50306: ARRAY
50307: PUSH
50308: LD_INT 3
50310: ARRAY
50311: EQUAL
50312: AND
50313: IFFALSE 50323
// result := true end ;
50315: LD_ADDR_VAR 0 3
50319: PUSH
50320: LD_INT 1
50322: ST_TO_ADDR
// end ;
50323: LD_VAR 0 3
50327: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
50328: LD_INT 0
50330: PPUSH
// result := false ;
50331: LD_ADDR_VAR 0 4
50335: PUSH
50336: LD_INT 0
50338: ST_TO_ADDR
// if GetTaskList ( unit ) then
50339: LD_VAR 0 1
50343: PPUSH
50344: CALL_OW 437
50348: IFFALSE 50431
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50350: LD_STRING M
50352: PUSH
50353: LD_VAR 0 1
50357: PPUSH
50358: CALL_OW 437
50362: PUSH
50363: LD_INT 1
50365: ARRAY
50366: PUSH
50367: LD_INT 1
50369: ARRAY
50370: EQUAL
50371: PUSH
50372: LD_VAR 0 2
50376: PUSH
50377: LD_VAR 0 1
50381: PPUSH
50382: CALL_OW 437
50386: PUSH
50387: LD_INT 1
50389: ARRAY
50390: PUSH
50391: LD_INT 2
50393: ARRAY
50394: EQUAL
50395: AND
50396: PUSH
50397: LD_VAR 0 3
50401: PUSH
50402: LD_VAR 0 1
50406: PPUSH
50407: CALL_OW 437
50411: PUSH
50412: LD_INT 1
50414: ARRAY
50415: PUSH
50416: LD_INT 3
50418: ARRAY
50419: EQUAL
50420: AND
50421: IFFALSE 50431
// result := true ;
50423: LD_ADDR_VAR 0 4
50427: PUSH
50428: LD_INT 1
50430: ST_TO_ADDR
// end ; end ;
50431: LD_VAR 0 4
50435: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
50436: LD_INT 0
50438: PPUSH
50439: PPUSH
50440: PPUSH
50441: PPUSH
// if not unit or not area then
50442: LD_VAR 0 1
50446: NOT
50447: PUSH
50448: LD_VAR 0 2
50452: NOT
50453: OR
50454: IFFALSE 50458
// exit ;
50456: GO 50622
// tmp := AreaToList ( area , i ) ;
50458: LD_ADDR_VAR 0 6
50462: PUSH
50463: LD_VAR 0 2
50467: PPUSH
50468: LD_VAR 0 5
50472: PPUSH
50473: CALL_OW 517
50477: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
50478: LD_ADDR_VAR 0 5
50482: PUSH
50483: DOUBLE
50484: LD_INT 1
50486: DEC
50487: ST_TO_ADDR
50488: LD_VAR 0 6
50492: PUSH
50493: LD_INT 1
50495: ARRAY
50496: PUSH
50497: FOR_TO
50498: IFFALSE 50620
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
50500: LD_ADDR_VAR 0 7
50504: PUSH
50505: LD_VAR 0 6
50509: PUSH
50510: LD_INT 1
50512: ARRAY
50513: PUSH
50514: LD_VAR 0 5
50518: ARRAY
50519: PUSH
50520: LD_VAR 0 6
50524: PUSH
50525: LD_INT 2
50527: ARRAY
50528: PUSH
50529: LD_VAR 0 5
50533: ARRAY
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
50539: LD_VAR 0 7
50543: PUSH
50544: LD_INT 1
50546: ARRAY
50547: PPUSH
50548: LD_VAR 0 7
50552: PUSH
50553: LD_INT 2
50555: ARRAY
50556: PPUSH
50557: CALL_OW 428
50561: PUSH
50562: LD_INT 0
50564: EQUAL
50565: IFFALSE 50618
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
50567: LD_VAR 0 1
50571: PPUSH
50572: LD_VAR 0 7
50576: PUSH
50577: LD_INT 1
50579: ARRAY
50580: PPUSH
50581: LD_VAR 0 7
50585: PUSH
50586: LD_INT 2
50588: ARRAY
50589: PPUSH
50590: LD_VAR 0 3
50594: PPUSH
50595: CALL_OW 48
// result := IsPlaced ( unit ) ;
50599: LD_ADDR_VAR 0 4
50603: PUSH
50604: LD_VAR 0 1
50608: PPUSH
50609: CALL_OW 305
50613: ST_TO_ADDR
// exit ;
50614: POP
50615: POP
50616: GO 50622
// end ; end ;
50618: GO 50497
50620: POP
50621: POP
// end ;
50622: LD_VAR 0 4
50626: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50627: LD_INT 0
50629: PPUSH
50630: PPUSH
50631: PPUSH
// if not side or side > 8 then
50632: LD_VAR 0 1
50636: NOT
50637: PUSH
50638: LD_VAR 0 1
50642: PUSH
50643: LD_INT 8
50645: GREATER
50646: OR
50647: IFFALSE 50651
// exit ;
50649: GO 50838
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50651: LD_ADDR_VAR 0 4
50655: PUSH
50656: LD_INT 22
50658: PUSH
50659: LD_VAR 0 1
50663: PUSH
50664: EMPTY
50665: LIST
50666: LIST
50667: PUSH
50668: LD_INT 21
50670: PUSH
50671: LD_INT 3
50673: PUSH
50674: EMPTY
50675: LIST
50676: LIST
50677: PUSH
50678: EMPTY
50679: LIST
50680: LIST
50681: PPUSH
50682: CALL_OW 69
50686: ST_TO_ADDR
// if not tmp then
50687: LD_VAR 0 4
50691: NOT
50692: IFFALSE 50696
// exit ;
50694: GO 50838
// enable_addtolog := true ;
50696: LD_ADDR_OWVAR 81
50700: PUSH
50701: LD_INT 1
50703: ST_TO_ADDR
// AddToLog ( [ ) ;
50704: LD_STRING [
50706: PPUSH
50707: CALL_OW 561
// for i in tmp do
50711: LD_ADDR_VAR 0 3
50715: PUSH
50716: LD_VAR 0 4
50720: PUSH
50721: FOR_IN
50722: IFFALSE 50829
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50724: LD_STRING [
50726: PUSH
50727: LD_VAR 0 3
50731: PPUSH
50732: CALL_OW 266
50736: STR
50737: PUSH
50738: LD_STRING , 
50740: STR
50741: PUSH
50742: LD_VAR 0 3
50746: PPUSH
50747: CALL_OW 250
50751: STR
50752: PUSH
50753: LD_STRING , 
50755: STR
50756: PUSH
50757: LD_VAR 0 3
50761: PPUSH
50762: CALL_OW 251
50766: STR
50767: PUSH
50768: LD_STRING , 
50770: STR
50771: PUSH
50772: LD_VAR 0 3
50776: PPUSH
50777: CALL_OW 254
50781: STR
50782: PUSH
50783: LD_STRING , 
50785: STR
50786: PUSH
50787: LD_VAR 0 3
50791: PPUSH
50792: LD_INT 1
50794: PPUSH
50795: CALL_OW 268
50799: STR
50800: PUSH
50801: LD_STRING , 
50803: STR
50804: PUSH
50805: LD_VAR 0 3
50809: PPUSH
50810: LD_INT 2
50812: PPUSH
50813: CALL_OW 268
50817: STR
50818: PUSH
50819: LD_STRING ],
50821: STR
50822: PPUSH
50823: CALL_OW 561
// end ;
50827: GO 50721
50829: POP
50830: POP
// AddToLog ( ]; ) ;
50831: LD_STRING ];
50833: PPUSH
50834: CALL_OW 561
// end ;
50838: LD_VAR 0 2
50842: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50843: LD_INT 0
50845: PPUSH
50846: PPUSH
50847: PPUSH
50848: PPUSH
50849: PPUSH
// if not area or not rate or not max then
50850: LD_VAR 0 1
50854: NOT
50855: PUSH
50856: LD_VAR 0 2
50860: NOT
50861: OR
50862: PUSH
50863: LD_VAR 0 4
50867: NOT
50868: OR
50869: IFFALSE 50873
// exit ;
50871: GO 51062
// while 1 do
50873: LD_INT 1
50875: IFFALSE 51062
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50877: LD_ADDR_VAR 0 9
50881: PUSH
50882: LD_VAR 0 1
50886: PPUSH
50887: LD_INT 1
50889: PPUSH
50890: CALL_OW 287
50894: PUSH
50895: LD_INT 10
50897: MUL
50898: ST_TO_ADDR
// r := rate / 10 ;
50899: LD_ADDR_VAR 0 7
50903: PUSH
50904: LD_VAR 0 2
50908: PUSH
50909: LD_INT 10
50911: DIVREAL
50912: ST_TO_ADDR
// time := 1 1$00 ;
50913: LD_ADDR_VAR 0 8
50917: PUSH
50918: LD_INT 2100
50920: ST_TO_ADDR
// if amount < min then
50921: LD_VAR 0 9
50925: PUSH
50926: LD_VAR 0 3
50930: LESS
50931: IFFALSE 50949
// r := r * 2 else
50933: LD_ADDR_VAR 0 7
50937: PUSH
50938: LD_VAR 0 7
50942: PUSH
50943: LD_INT 2
50945: MUL
50946: ST_TO_ADDR
50947: GO 50975
// if amount > max then
50949: LD_VAR 0 9
50953: PUSH
50954: LD_VAR 0 4
50958: GREATER
50959: IFFALSE 50975
// r := r / 2 ;
50961: LD_ADDR_VAR 0 7
50965: PUSH
50966: LD_VAR 0 7
50970: PUSH
50971: LD_INT 2
50973: DIVREAL
50974: ST_TO_ADDR
// time := time / r ;
50975: LD_ADDR_VAR 0 8
50979: PUSH
50980: LD_VAR 0 8
50984: PUSH
50985: LD_VAR 0 7
50989: DIVREAL
50990: ST_TO_ADDR
// if time < 0 then
50991: LD_VAR 0 8
50995: PUSH
50996: LD_INT 0
50998: LESS
50999: IFFALSE 51016
// time := time * - 1 ;
51001: LD_ADDR_VAR 0 8
51005: PUSH
51006: LD_VAR 0 8
51010: PUSH
51011: LD_INT 1
51013: NEG
51014: MUL
51015: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
51016: LD_VAR 0 8
51020: PUSH
51021: LD_INT 35
51023: PPUSH
51024: LD_INT 875
51026: PPUSH
51027: CALL_OW 12
51031: PLUS
51032: PPUSH
51033: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
51037: LD_INT 1
51039: PPUSH
51040: LD_INT 5
51042: PPUSH
51043: CALL_OW 12
51047: PPUSH
51048: LD_VAR 0 1
51052: PPUSH
51053: LD_INT 1
51055: PPUSH
51056: CALL_OW 55
// end ;
51060: GO 50873
// end ;
51062: LD_VAR 0 5
51066: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51067: LD_INT 0
51069: PPUSH
51070: PPUSH
51071: PPUSH
51072: PPUSH
51073: PPUSH
51074: PPUSH
51075: PPUSH
51076: PPUSH
// if not turrets or not factories then
51077: LD_VAR 0 1
51081: NOT
51082: PUSH
51083: LD_VAR 0 2
51087: NOT
51088: OR
51089: IFFALSE 51093
// exit ;
51091: GO 51400
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51093: LD_ADDR_VAR 0 10
51097: PUSH
51098: LD_INT 5
51100: PUSH
51101: LD_INT 6
51103: PUSH
51104: EMPTY
51105: LIST
51106: LIST
51107: PUSH
51108: LD_INT 2
51110: PUSH
51111: LD_INT 4
51113: PUSH
51114: EMPTY
51115: LIST
51116: LIST
51117: PUSH
51118: LD_INT 3
51120: PUSH
51121: LD_INT 5
51123: PUSH
51124: EMPTY
51125: LIST
51126: LIST
51127: PUSH
51128: EMPTY
51129: LIST
51130: LIST
51131: LIST
51132: PUSH
51133: LD_INT 24
51135: PUSH
51136: LD_INT 25
51138: PUSH
51139: EMPTY
51140: LIST
51141: LIST
51142: PUSH
51143: LD_INT 23
51145: PUSH
51146: LD_INT 27
51148: PUSH
51149: EMPTY
51150: LIST
51151: LIST
51152: PUSH
51153: EMPTY
51154: LIST
51155: LIST
51156: PUSH
51157: LD_INT 42
51159: PUSH
51160: LD_INT 43
51162: PUSH
51163: EMPTY
51164: LIST
51165: LIST
51166: PUSH
51167: LD_INT 44
51169: PUSH
51170: LD_INT 46
51172: PUSH
51173: EMPTY
51174: LIST
51175: LIST
51176: PUSH
51177: LD_INT 45
51179: PUSH
51180: LD_INT 47
51182: PUSH
51183: EMPTY
51184: LIST
51185: LIST
51186: PUSH
51187: EMPTY
51188: LIST
51189: LIST
51190: LIST
51191: PUSH
51192: EMPTY
51193: LIST
51194: LIST
51195: LIST
51196: ST_TO_ADDR
// result := [ ] ;
51197: LD_ADDR_VAR 0 3
51201: PUSH
51202: EMPTY
51203: ST_TO_ADDR
// for i in turrets do
51204: LD_ADDR_VAR 0 4
51208: PUSH
51209: LD_VAR 0 1
51213: PUSH
51214: FOR_IN
51215: IFFALSE 51398
// begin nat := GetNation ( i ) ;
51217: LD_ADDR_VAR 0 7
51221: PUSH
51222: LD_VAR 0 4
51226: PPUSH
51227: CALL_OW 248
51231: ST_TO_ADDR
// weapon := 0 ;
51232: LD_ADDR_VAR 0 8
51236: PUSH
51237: LD_INT 0
51239: ST_TO_ADDR
// if not nat then
51240: LD_VAR 0 7
51244: NOT
51245: IFFALSE 51249
// continue ;
51247: GO 51214
// for j in list [ nat ] do
51249: LD_ADDR_VAR 0 5
51253: PUSH
51254: LD_VAR 0 10
51258: PUSH
51259: LD_VAR 0 7
51263: ARRAY
51264: PUSH
51265: FOR_IN
51266: IFFALSE 51307
// if GetBWeapon ( i ) = j [ 1 ] then
51268: LD_VAR 0 4
51272: PPUSH
51273: CALL_OW 269
51277: PUSH
51278: LD_VAR 0 5
51282: PUSH
51283: LD_INT 1
51285: ARRAY
51286: EQUAL
51287: IFFALSE 51305
// begin weapon := j [ 2 ] ;
51289: LD_ADDR_VAR 0 8
51293: PUSH
51294: LD_VAR 0 5
51298: PUSH
51299: LD_INT 2
51301: ARRAY
51302: ST_TO_ADDR
// break ;
51303: GO 51307
// end ;
51305: GO 51265
51307: POP
51308: POP
// if not weapon then
51309: LD_VAR 0 8
51313: NOT
51314: IFFALSE 51318
// continue ;
51316: GO 51214
// for k in factories do
51318: LD_ADDR_VAR 0 6
51322: PUSH
51323: LD_VAR 0 2
51327: PUSH
51328: FOR_IN
51329: IFFALSE 51394
// begin weapons := AvailableWeaponList ( k ) ;
51331: LD_ADDR_VAR 0 9
51335: PUSH
51336: LD_VAR 0 6
51340: PPUSH
51341: CALL_OW 478
51345: ST_TO_ADDR
// if not weapons then
51346: LD_VAR 0 9
51350: NOT
51351: IFFALSE 51355
// continue ;
51353: GO 51328
// if weapon in weapons then
51355: LD_VAR 0 8
51359: PUSH
51360: LD_VAR 0 9
51364: IN
51365: IFFALSE 51392
// begin result := [ i , weapon ] ;
51367: LD_ADDR_VAR 0 3
51371: PUSH
51372: LD_VAR 0 4
51376: PUSH
51377: LD_VAR 0 8
51381: PUSH
51382: EMPTY
51383: LIST
51384: LIST
51385: ST_TO_ADDR
// exit ;
51386: POP
51387: POP
51388: POP
51389: POP
51390: GO 51400
// end ; end ;
51392: GO 51328
51394: POP
51395: POP
// end ;
51396: GO 51214
51398: POP
51399: POP
// end ;
51400: LD_VAR 0 3
51404: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
51405: LD_INT 0
51407: PPUSH
// if not side or side > 8 then
51408: LD_VAR 0 3
51412: NOT
51413: PUSH
51414: LD_VAR 0 3
51418: PUSH
51419: LD_INT 8
51421: GREATER
51422: OR
51423: IFFALSE 51427
// exit ;
51425: GO 51486
// if not range then
51427: LD_VAR 0 4
51431: NOT
51432: IFFALSE 51443
// range := - 12 ;
51434: LD_ADDR_VAR 0 4
51438: PUSH
51439: LD_INT 12
51441: NEG
51442: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
51443: LD_VAR 0 1
51447: PPUSH
51448: LD_VAR 0 2
51452: PPUSH
51453: LD_VAR 0 3
51457: PPUSH
51458: LD_VAR 0 4
51462: PPUSH
51463: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
51467: LD_VAR 0 1
51471: PPUSH
51472: LD_VAR 0 2
51476: PPUSH
51477: LD_VAR 0 3
51481: PPUSH
51482: CALL_OW 331
// end ;
51486: LD_VAR 0 5
51490: RET
// export function Video ( mode ) ; begin
51491: LD_INT 0
51493: PPUSH
// ingame_video = mode ;
51494: LD_ADDR_OWVAR 52
51498: PUSH
51499: LD_VAR 0 1
51503: ST_TO_ADDR
// interface_hidden = mode ;
51504: LD_ADDR_OWVAR 54
51508: PUSH
51509: LD_VAR 0 1
51513: ST_TO_ADDR
// end ;
51514: LD_VAR 0 2
51518: RET
// export function Join ( array , element ) ; begin
51519: LD_INT 0
51521: PPUSH
// result := Replace ( array , array + 1 , element ) ;
51522: LD_ADDR_VAR 0 3
51526: PUSH
51527: LD_VAR 0 1
51531: PPUSH
51532: LD_VAR 0 1
51536: PUSH
51537: LD_INT 1
51539: PLUS
51540: PPUSH
51541: LD_VAR 0 2
51545: PPUSH
51546: CALL_OW 1
51550: ST_TO_ADDR
// end ;
51551: LD_VAR 0 3
51555: RET
// export function JoinUnion ( array , element ) ; begin
51556: LD_INT 0
51558: PPUSH
// result := array union element ;
51559: LD_ADDR_VAR 0 3
51563: PUSH
51564: LD_VAR 0 1
51568: PUSH
51569: LD_VAR 0 2
51573: UNION
51574: ST_TO_ADDR
// end ;
51575: LD_VAR 0 3
51579: RET
// export function GetBehemoths ( side ) ; begin
51580: LD_INT 0
51582: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
51583: LD_ADDR_VAR 0 2
51587: PUSH
51588: LD_INT 22
51590: PUSH
51591: LD_VAR 0 1
51595: PUSH
51596: EMPTY
51597: LIST
51598: LIST
51599: PUSH
51600: LD_INT 31
51602: PUSH
51603: LD_INT 25
51605: PUSH
51606: EMPTY
51607: LIST
51608: LIST
51609: PUSH
51610: EMPTY
51611: LIST
51612: LIST
51613: PPUSH
51614: CALL_OW 69
51618: ST_TO_ADDR
// end ;
51619: LD_VAR 0 2
51623: RET
// export function Shuffle ( array ) ; var i , index ; begin
51624: LD_INT 0
51626: PPUSH
51627: PPUSH
51628: PPUSH
// result := [ ] ;
51629: LD_ADDR_VAR 0 2
51633: PUSH
51634: EMPTY
51635: ST_TO_ADDR
// if not array then
51636: LD_VAR 0 1
51640: NOT
51641: IFFALSE 51645
// exit ;
51643: GO 51744
// Randomize ;
51645: CALL_OW 10
// for i = array downto 1 do
51649: LD_ADDR_VAR 0 3
51653: PUSH
51654: DOUBLE
51655: LD_VAR 0 1
51659: INC
51660: ST_TO_ADDR
51661: LD_INT 1
51663: PUSH
51664: FOR_DOWNTO
51665: IFFALSE 51742
// begin index := rand ( 1 , array ) ;
51667: LD_ADDR_VAR 0 4
51671: PUSH
51672: LD_INT 1
51674: PPUSH
51675: LD_VAR 0 1
51679: PPUSH
51680: CALL_OW 12
51684: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51685: LD_ADDR_VAR 0 2
51689: PUSH
51690: LD_VAR 0 2
51694: PPUSH
51695: LD_VAR 0 2
51699: PUSH
51700: LD_INT 1
51702: PLUS
51703: PPUSH
51704: LD_VAR 0 1
51708: PUSH
51709: LD_VAR 0 4
51713: ARRAY
51714: PPUSH
51715: CALL_OW 2
51719: ST_TO_ADDR
// array := Delete ( array , index ) ;
51720: LD_ADDR_VAR 0 1
51724: PUSH
51725: LD_VAR 0 1
51729: PPUSH
51730: LD_VAR 0 4
51734: PPUSH
51735: CALL_OW 3
51739: ST_TO_ADDR
// end ;
51740: GO 51664
51742: POP
51743: POP
// end ;
51744: LD_VAR 0 2
51748: RET
// export function GetBaseMaterials ( base ) ; begin
51749: LD_INT 0
51751: PPUSH
// result := [ 0 , 0 , 0 ] ;
51752: LD_ADDR_VAR 0 2
51756: PUSH
51757: LD_INT 0
51759: PUSH
51760: LD_INT 0
51762: PUSH
51763: LD_INT 0
51765: PUSH
51766: EMPTY
51767: LIST
51768: LIST
51769: LIST
51770: ST_TO_ADDR
// if not base then
51771: LD_VAR 0 1
51775: NOT
51776: IFFALSE 51780
// exit ;
51778: GO 51829
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51780: LD_ADDR_VAR 0 2
51784: PUSH
51785: LD_VAR 0 1
51789: PPUSH
51790: LD_INT 1
51792: PPUSH
51793: CALL_OW 275
51797: PUSH
51798: LD_VAR 0 1
51802: PPUSH
51803: LD_INT 2
51805: PPUSH
51806: CALL_OW 275
51810: PUSH
51811: LD_VAR 0 1
51815: PPUSH
51816: LD_INT 3
51818: PPUSH
51819: CALL_OW 275
51823: PUSH
51824: EMPTY
51825: LIST
51826: LIST
51827: LIST
51828: ST_TO_ADDR
// end ;
51829: LD_VAR 0 2
51833: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
51834: LD_INT 0
51836: PPUSH
51837: PPUSH
// result := array ;
51838: LD_ADDR_VAR 0 3
51842: PUSH
51843: LD_VAR 0 1
51847: ST_TO_ADDR
// if size > 0 then
51848: LD_VAR 0 2
51852: PUSH
51853: LD_INT 0
51855: GREATER
51856: IFFALSE 51902
// for i := array downto size do
51858: LD_ADDR_VAR 0 4
51862: PUSH
51863: DOUBLE
51864: LD_VAR 0 1
51868: INC
51869: ST_TO_ADDR
51870: LD_VAR 0 2
51874: PUSH
51875: FOR_DOWNTO
51876: IFFALSE 51900
// result := Delete ( result , result ) ;
51878: LD_ADDR_VAR 0 3
51882: PUSH
51883: LD_VAR 0 3
51887: PPUSH
51888: LD_VAR 0 3
51892: PPUSH
51893: CALL_OW 3
51897: ST_TO_ADDR
51898: GO 51875
51900: POP
51901: POP
// end ;
51902: LD_VAR 0 3
51906: RET
// export function ComExit ( unit ) ; var tmp ; begin
51907: LD_INT 0
51909: PPUSH
51910: PPUSH
// if not IsInUnit ( unit ) then
51911: LD_VAR 0 1
51915: PPUSH
51916: CALL_OW 310
51920: NOT
51921: IFFALSE 51925
// exit ;
51923: GO 51985
// tmp := IsInUnit ( unit ) ;
51925: LD_ADDR_VAR 0 3
51929: PUSH
51930: LD_VAR 0 1
51934: PPUSH
51935: CALL_OW 310
51939: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51940: LD_VAR 0 3
51944: PPUSH
51945: CALL_OW 247
51949: PUSH
51950: LD_INT 2
51952: EQUAL
51953: IFFALSE 51966
// ComExitVehicle ( unit ) else
51955: LD_VAR 0 1
51959: PPUSH
51960: CALL_OW 121
51964: GO 51975
// ComExitBuilding ( unit ) ;
51966: LD_VAR 0 1
51970: PPUSH
51971: CALL_OW 122
// result := tmp ;
51975: LD_ADDR_VAR 0 2
51979: PUSH
51980: LD_VAR 0 3
51984: ST_TO_ADDR
// end ;
51985: LD_VAR 0 2
51989: RET
// export function ComExitAll ( units ) ; var i ; begin
51990: LD_INT 0
51992: PPUSH
51993: PPUSH
// if not units then
51994: LD_VAR 0 1
51998: NOT
51999: IFFALSE 52003
// exit ;
52001: GO 52029
// for i in units do
52003: LD_ADDR_VAR 0 3
52007: PUSH
52008: LD_VAR 0 1
52012: PUSH
52013: FOR_IN
52014: IFFALSE 52027
// ComExit ( i ) ;
52016: LD_VAR 0 3
52020: PPUSH
52021: CALL 51907 0 1
52025: GO 52013
52027: POP
52028: POP
// end ;
52029: LD_VAR 0 2
52033: RET
// export function ResetHc ; begin
52034: LD_INT 0
52036: PPUSH
// InitHc ;
52037: CALL_OW 19
// hc_importance := 0 ;
52041: LD_ADDR_OWVAR 32
52045: PUSH
52046: LD_INT 0
52048: ST_TO_ADDR
// end ;
52049: LD_VAR 0 1
52053: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52054: LD_INT 0
52056: PPUSH
52057: PPUSH
52058: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52059: LD_ADDR_VAR 0 6
52063: PUSH
52064: LD_VAR 0 1
52068: PUSH
52069: LD_VAR 0 3
52073: PLUS
52074: PUSH
52075: LD_INT 2
52077: DIV
52078: ST_TO_ADDR
// if _x < 0 then
52079: LD_VAR 0 6
52083: PUSH
52084: LD_INT 0
52086: LESS
52087: IFFALSE 52104
// _x := _x * - 1 ;
52089: LD_ADDR_VAR 0 6
52093: PUSH
52094: LD_VAR 0 6
52098: PUSH
52099: LD_INT 1
52101: NEG
52102: MUL
52103: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
52104: LD_ADDR_VAR 0 7
52108: PUSH
52109: LD_VAR 0 2
52113: PUSH
52114: LD_VAR 0 4
52118: PLUS
52119: PUSH
52120: LD_INT 2
52122: DIV
52123: ST_TO_ADDR
// if _y < 0 then
52124: LD_VAR 0 7
52128: PUSH
52129: LD_INT 0
52131: LESS
52132: IFFALSE 52149
// _y := _y * - 1 ;
52134: LD_ADDR_VAR 0 7
52138: PUSH
52139: LD_VAR 0 7
52143: PUSH
52144: LD_INT 1
52146: NEG
52147: MUL
52148: ST_TO_ADDR
// result := [ _x , _y ] ;
52149: LD_ADDR_VAR 0 5
52153: PUSH
52154: LD_VAR 0 6
52158: PUSH
52159: LD_VAR 0 7
52163: PUSH
52164: EMPTY
52165: LIST
52166: LIST
52167: ST_TO_ADDR
// end ;
52168: LD_VAR 0 5
52172: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
52173: LD_INT 0
52175: PPUSH
52176: PPUSH
52177: PPUSH
52178: PPUSH
// task := GetTaskList ( unit ) ;
52179: LD_ADDR_VAR 0 7
52183: PUSH
52184: LD_VAR 0 1
52188: PPUSH
52189: CALL_OW 437
52193: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
52194: LD_VAR 0 7
52198: NOT
52199: PUSH
52200: LD_VAR 0 1
52204: PPUSH
52205: LD_VAR 0 2
52209: PPUSH
52210: CALL_OW 308
52214: NOT
52215: AND
52216: IFFALSE 52220
// exit ;
52218: GO 52338
// if IsInArea ( unit , area ) then
52220: LD_VAR 0 1
52224: PPUSH
52225: LD_VAR 0 2
52229: PPUSH
52230: CALL_OW 308
52234: IFFALSE 52252
// begin ComMoveToArea ( unit , goAway ) ;
52236: LD_VAR 0 1
52240: PPUSH
52241: LD_VAR 0 3
52245: PPUSH
52246: CALL_OW 113
// exit ;
52250: GO 52338
// end ; if task [ 1 ] [ 1 ] <> M then
52252: LD_VAR 0 7
52256: PUSH
52257: LD_INT 1
52259: ARRAY
52260: PUSH
52261: LD_INT 1
52263: ARRAY
52264: PUSH
52265: LD_STRING M
52267: NONEQUAL
52268: IFFALSE 52272
// exit ;
52270: GO 52338
// x := task [ 1 ] [ 2 ] ;
52272: LD_ADDR_VAR 0 5
52276: PUSH
52277: LD_VAR 0 7
52281: PUSH
52282: LD_INT 1
52284: ARRAY
52285: PUSH
52286: LD_INT 2
52288: ARRAY
52289: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
52290: LD_ADDR_VAR 0 6
52294: PUSH
52295: LD_VAR 0 7
52299: PUSH
52300: LD_INT 1
52302: ARRAY
52303: PUSH
52304: LD_INT 3
52306: ARRAY
52307: ST_TO_ADDR
// if InArea ( x , y , area ) then
52308: LD_VAR 0 5
52312: PPUSH
52313: LD_VAR 0 6
52317: PPUSH
52318: LD_VAR 0 2
52322: PPUSH
52323: CALL_OW 309
52327: IFFALSE 52338
// ComStop ( unit ) ;
52329: LD_VAR 0 1
52333: PPUSH
52334: CALL_OW 141
// end ;
52338: LD_VAR 0 4
52342: RET
// export function Abs ( value ) ; begin
52343: LD_INT 0
52345: PPUSH
// result := value ;
52346: LD_ADDR_VAR 0 2
52350: PUSH
52351: LD_VAR 0 1
52355: ST_TO_ADDR
// if value < 0 then
52356: LD_VAR 0 1
52360: PUSH
52361: LD_INT 0
52363: LESS
52364: IFFALSE 52381
// result := value * - 1 ;
52366: LD_ADDR_VAR 0 2
52370: PUSH
52371: LD_VAR 0 1
52375: PUSH
52376: LD_INT 1
52378: NEG
52379: MUL
52380: ST_TO_ADDR
// end ;
52381: LD_VAR 0 2
52385: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
52386: LD_INT 0
52388: PPUSH
52389: PPUSH
52390: PPUSH
52391: PPUSH
52392: PPUSH
52393: PPUSH
52394: PPUSH
52395: PPUSH
// if not unit or not building then
52396: LD_VAR 0 1
52400: NOT
52401: PUSH
52402: LD_VAR 0 2
52406: NOT
52407: OR
52408: IFFALSE 52412
// exit ;
52410: GO 52638
// x := GetX ( building ) ;
52412: LD_ADDR_VAR 0 4
52416: PUSH
52417: LD_VAR 0 2
52421: PPUSH
52422: CALL_OW 250
52426: ST_TO_ADDR
// y := GetY ( building ) ;
52427: LD_ADDR_VAR 0 6
52431: PUSH
52432: LD_VAR 0 2
52436: PPUSH
52437: CALL_OW 251
52441: ST_TO_ADDR
// d := GetDir ( building ) ;
52442: LD_ADDR_VAR 0 8
52446: PUSH
52447: LD_VAR 0 2
52451: PPUSH
52452: CALL_OW 254
52456: ST_TO_ADDR
// r := 4 ;
52457: LD_ADDR_VAR 0 9
52461: PUSH
52462: LD_INT 4
52464: ST_TO_ADDR
// for i := 1 to 5 do
52465: LD_ADDR_VAR 0 10
52469: PUSH
52470: DOUBLE
52471: LD_INT 1
52473: DEC
52474: ST_TO_ADDR
52475: LD_INT 5
52477: PUSH
52478: FOR_TO
52479: IFFALSE 52636
// begin _x := ShiftX ( x , d , r + i ) ;
52481: LD_ADDR_VAR 0 5
52485: PUSH
52486: LD_VAR 0 4
52490: PPUSH
52491: LD_VAR 0 8
52495: PPUSH
52496: LD_VAR 0 9
52500: PUSH
52501: LD_VAR 0 10
52505: PLUS
52506: PPUSH
52507: CALL_OW 272
52511: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
52512: LD_ADDR_VAR 0 7
52516: PUSH
52517: LD_VAR 0 6
52521: PPUSH
52522: LD_VAR 0 8
52526: PPUSH
52527: LD_VAR 0 9
52531: PUSH
52532: LD_VAR 0 10
52536: PLUS
52537: PPUSH
52538: CALL_OW 273
52542: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
52543: LD_VAR 0 5
52547: PPUSH
52548: LD_VAR 0 7
52552: PPUSH
52553: CALL_OW 488
52557: PUSH
52558: LD_VAR 0 5
52562: PPUSH
52563: LD_VAR 0 7
52567: PPUSH
52568: CALL_OW 428
52572: PPUSH
52573: CALL_OW 247
52577: PUSH
52578: LD_INT 3
52580: PUSH
52581: LD_INT 2
52583: PUSH
52584: EMPTY
52585: LIST
52586: LIST
52587: IN
52588: NOT
52589: AND
52590: IFFALSE 52634
// begin ComMoveXY ( unit , _x , _y ) ;
52592: LD_VAR 0 1
52596: PPUSH
52597: LD_VAR 0 5
52601: PPUSH
52602: LD_VAR 0 7
52606: PPUSH
52607: CALL_OW 111
// result := [ _x , _y ] ;
52611: LD_ADDR_VAR 0 3
52615: PUSH
52616: LD_VAR 0 5
52620: PUSH
52621: LD_VAR 0 7
52625: PUSH
52626: EMPTY
52627: LIST
52628: LIST
52629: ST_TO_ADDR
// exit ;
52630: POP
52631: POP
52632: GO 52638
// end ; end ;
52634: GO 52478
52636: POP
52637: POP
// end ;
52638: LD_VAR 0 3
52642: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52643: LD_INT 0
52645: PPUSH
52646: PPUSH
52647: PPUSH
// result := 0 ;
52648: LD_ADDR_VAR 0 3
52652: PUSH
52653: LD_INT 0
52655: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52656: LD_VAR 0 1
52660: PUSH
52661: LD_INT 0
52663: LESS
52664: PUSH
52665: LD_VAR 0 1
52669: PUSH
52670: LD_INT 8
52672: GREATER
52673: OR
52674: PUSH
52675: LD_VAR 0 2
52679: PUSH
52680: LD_INT 0
52682: LESS
52683: OR
52684: PUSH
52685: LD_VAR 0 2
52689: PUSH
52690: LD_INT 8
52692: GREATER
52693: OR
52694: IFFALSE 52698
// exit ;
52696: GO 52773
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52698: LD_ADDR_VAR 0 4
52702: PUSH
52703: LD_INT 22
52705: PUSH
52706: LD_VAR 0 2
52710: PUSH
52711: EMPTY
52712: LIST
52713: LIST
52714: PPUSH
52715: CALL_OW 69
52719: PUSH
52720: FOR_IN
52721: IFFALSE 52771
// begin un := UnitShoot ( i ) ;
52723: LD_ADDR_VAR 0 5
52727: PUSH
52728: LD_VAR 0 4
52732: PPUSH
52733: CALL_OW 504
52737: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52738: LD_VAR 0 5
52742: PPUSH
52743: CALL_OW 255
52747: PUSH
52748: LD_VAR 0 1
52752: EQUAL
52753: IFFALSE 52769
// begin result := un ;
52755: LD_ADDR_VAR 0 3
52759: PUSH
52760: LD_VAR 0 5
52764: ST_TO_ADDR
// exit ;
52765: POP
52766: POP
52767: GO 52773
// end ; end ;
52769: GO 52720
52771: POP
52772: POP
// end ;
52773: LD_VAR 0 3
52777: RET
// export function GetCargoBay ( units ) ; begin
52778: LD_INT 0
52780: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52781: LD_ADDR_VAR 0 2
52785: PUSH
52786: LD_VAR 0 1
52790: PPUSH
52791: LD_INT 2
52793: PUSH
52794: LD_INT 34
52796: PUSH
52797: LD_INT 12
52799: PUSH
52800: EMPTY
52801: LIST
52802: LIST
52803: PUSH
52804: LD_INT 34
52806: PUSH
52807: LD_INT 51
52809: PUSH
52810: EMPTY
52811: LIST
52812: LIST
52813: PUSH
52814: LD_INT 34
52816: PUSH
52817: LD_INT 32
52819: PUSH
52820: EMPTY
52821: LIST
52822: LIST
52823: PUSH
52824: LD_INT 34
52826: PUSH
52827: LD_EXP 105
52831: PUSH
52832: EMPTY
52833: LIST
52834: LIST
52835: PUSH
52836: EMPTY
52837: LIST
52838: LIST
52839: LIST
52840: LIST
52841: LIST
52842: PPUSH
52843: CALL_OW 72
52847: ST_TO_ADDR
// end ;
52848: LD_VAR 0 2
52852: RET
// export function Negate ( value ) ; begin
52853: LD_INT 0
52855: PPUSH
// result := not value ;
52856: LD_ADDR_VAR 0 2
52860: PUSH
52861: LD_VAR 0 1
52865: NOT
52866: ST_TO_ADDR
// end ;
52867: LD_VAR 0 2
52871: RET
// export function Inc ( value ) ; begin
52872: LD_INT 0
52874: PPUSH
// result := value + 1 ;
52875: LD_ADDR_VAR 0 2
52879: PUSH
52880: LD_VAR 0 1
52884: PUSH
52885: LD_INT 1
52887: PLUS
52888: ST_TO_ADDR
// end ;
52889: LD_VAR 0 2
52893: RET
// export function Dec ( value ) ; begin
52894: LD_INT 0
52896: PPUSH
// result := value - 1 ;
52897: LD_ADDR_VAR 0 2
52901: PUSH
52902: LD_VAR 0 1
52906: PUSH
52907: LD_INT 1
52909: MINUS
52910: ST_TO_ADDR
// end ;
52911: LD_VAR 0 2
52915: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
52916: LD_INT 0
52918: PPUSH
52919: PPUSH
52920: PPUSH
52921: PPUSH
52922: PPUSH
52923: PPUSH
52924: PPUSH
52925: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
52926: LD_VAR 0 1
52930: PPUSH
52931: LD_VAR 0 2
52935: PPUSH
52936: CALL_OW 488
52940: NOT
52941: PUSH
52942: LD_VAR 0 3
52946: PPUSH
52947: LD_VAR 0 4
52951: PPUSH
52952: CALL_OW 488
52956: NOT
52957: OR
52958: IFFALSE 52971
// begin result := - 1 ;
52960: LD_ADDR_VAR 0 5
52964: PUSH
52965: LD_INT 1
52967: NEG
52968: ST_TO_ADDR
// exit ;
52969: GO 53206
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
52971: LD_ADDR_VAR 0 12
52975: PUSH
52976: LD_VAR 0 1
52980: PPUSH
52981: LD_VAR 0 2
52985: PPUSH
52986: LD_VAR 0 3
52990: PPUSH
52991: LD_VAR 0 4
52995: PPUSH
52996: CALL 52054 0 4
53000: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
53001: LD_ADDR_VAR 0 11
53005: PUSH
53006: LD_VAR 0 1
53010: PPUSH
53011: LD_VAR 0 2
53015: PPUSH
53016: LD_VAR 0 12
53020: PUSH
53021: LD_INT 1
53023: ARRAY
53024: PPUSH
53025: LD_VAR 0 12
53029: PUSH
53030: LD_INT 2
53032: ARRAY
53033: PPUSH
53034: CALL_OW 298
53038: ST_TO_ADDR
// distance := 9999 ;
53039: LD_ADDR_VAR 0 10
53043: PUSH
53044: LD_INT 9999
53046: ST_TO_ADDR
// for i := 0 to 5 do
53047: LD_ADDR_VAR 0 6
53051: PUSH
53052: DOUBLE
53053: LD_INT 0
53055: DEC
53056: ST_TO_ADDR
53057: LD_INT 5
53059: PUSH
53060: FOR_TO
53061: IFFALSE 53204
// begin _x := ShiftX ( x1 , i , centerDist ) ;
53063: LD_ADDR_VAR 0 7
53067: PUSH
53068: LD_VAR 0 1
53072: PPUSH
53073: LD_VAR 0 6
53077: PPUSH
53078: LD_VAR 0 11
53082: PPUSH
53083: CALL_OW 272
53087: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
53088: LD_ADDR_VAR 0 8
53092: PUSH
53093: LD_VAR 0 2
53097: PPUSH
53098: LD_VAR 0 6
53102: PPUSH
53103: LD_VAR 0 11
53107: PPUSH
53108: CALL_OW 273
53112: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53113: LD_VAR 0 7
53117: PPUSH
53118: LD_VAR 0 8
53122: PPUSH
53123: CALL_OW 488
53127: NOT
53128: IFFALSE 53132
// continue ;
53130: GO 53060
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
53132: LD_ADDR_VAR 0 9
53136: PUSH
53137: LD_VAR 0 12
53141: PUSH
53142: LD_INT 1
53144: ARRAY
53145: PPUSH
53146: LD_VAR 0 12
53150: PUSH
53151: LD_INT 2
53153: ARRAY
53154: PPUSH
53155: LD_VAR 0 7
53159: PPUSH
53160: LD_VAR 0 8
53164: PPUSH
53165: CALL_OW 298
53169: ST_TO_ADDR
// if tmp < distance then
53170: LD_VAR 0 9
53174: PUSH
53175: LD_VAR 0 10
53179: LESS
53180: IFFALSE 53202
// begin result := i ;
53182: LD_ADDR_VAR 0 5
53186: PUSH
53187: LD_VAR 0 6
53191: ST_TO_ADDR
// distance := tmp ;
53192: LD_ADDR_VAR 0 10
53196: PUSH
53197: LD_VAR 0 9
53201: ST_TO_ADDR
// end ; end ;
53202: GO 53060
53204: POP
53205: POP
// end ;
53206: LD_VAR 0 5
53210: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53211: LD_INT 0
53213: PPUSH
53214: PPUSH
// if not driver or not IsInUnit ( driver ) then
53215: LD_VAR 0 1
53219: NOT
53220: PUSH
53221: LD_VAR 0 1
53225: PPUSH
53226: CALL_OW 310
53230: NOT
53231: OR
53232: IFFALSE 53236
// exit ;
53234: GO 53326
// vehicle := IsInUnit ( driver ) ;
53236: LD_ADDR_VAR 0 3
53240: PUSH
53241: LD_VAR 0 1
53245: PPUSH
53246: CALL_OW 310
53250: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53251: LD_VAR 0 1
53255: PPUSH
53256: LD_STRING \
53258: PUSH
53259: LD_INT 0
53261: PUSH
53262: LD_INT 0
53264: PUSH
53265: LD_INT 0
53267: PUSH
53268: LD_INT 0
53270: PUSH
53271: LD_INT 0
53273: PUSH
53274: LD_INT 0
53276: PUSH
53277: EMPTY
53278: LIST
53279: LIST
53280: LIST
53281: LIST
53282: LIST
53283: LIST
53284: LIST
53285: PUSH
53286: LD_STRING E
53288: PUSH
53289: LD_INT 0
53291: PUSH
53292: LD_INT 0
53294: PUSH
53295: LD_VAR 0 3
53299: PUSH
53300: LD_INT 0
53302: PUSH
53303: LD_INT 0
53305: PUSH
53306: LD_INT 0
53308: PUSH
53309: EMPTY
53310: LIST
53311: LIST
53312: LIST
53313: LIST
53314: LIST
53315: LIST
53316: LIST
53317: PUSH
53318: EMPTY
53319: LIST
53320: LIST
53321: PPUSH
53322: CALL_OW 446
// end ;
53326: LD_VAR 0 2
53330: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53331: LD_INT 0
53333: PPUSH
53334: PPUSH
// if not driver or not IsInUnit ( driver ) then
53335: LD_VAR 0 1
53339: NOT
53340: PUSH
53341: LD_VAR 0 1
53345: PPUSH
53346: CALL_OW 310
53350: NOT
53351: OR
53352: IFFALSE 53356
// exit ;
53354: GO 53446
// vehicle := IsInUnit ( driver ) ;
53356: LD_ADDR_VAR 0 3
53360: PUSH
53361: LD_VAR 0 1
53365: PPUSH
53366: CALL_OW 310
53370: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53371: LD_VAR 0 1
53375: PPUSH
53376: LD_STRING \
53378: PUSH
53379: LD_INT 0
53381: PUSH
53382: LD_INT 0
53384: PUSH
53385: LD_INT 0
53387: PUSH
53388: LD_INT 0
53390: PUSH
53391: LD_INT 0
53393: PUSH
53394: LD_INT 0
53396: PUSH
53397: EMPTY
53398: LIST
53399: LIST
53400: LIST
53401: LIST
53402: LIST
53403: LIST
53404: LIST
53405: PUSH
53406: LD_STRING E
53408: PUSH
53409: LD_INT 0
53411: PUSH
53412: LD_INT 0
53414: PUSH
53415: LD_VAR 0 3
53419: PUSH
53420: LD_INT 0
53422: PUSH
53423: LD_INT 0
53425: PUSH
53426: LD_INT 0
53428: PUSH
53429: EMPTY
53430: LIST
53431: LIST
53432: LIST
53433: LIST
53434: LIST
53435: LIST
53436: LIST
53437: PUSH
53438: EMPTY
53439: LIST
53440: LIST
53441: PPUSH
53442: CALL_OW 447
// end ;
53446: LD_VAR 0 2
53450: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
53451: LD_INT 0
53453: PPUSH
53454: PPUSH
53455: PPUSH
// tmp := [ ] ;
53456: LD_ADDR_VAR 0 5
53460: PUSH
53461: EMPTY
53462: ST_TO_ADDR
// for i in units do
53463: LD_ADDR_VAR 0 4
53467: PUSH
53468: LD_VAR 0 1
53472: PUSH
53473: FOR_IN
53474: IFFALSE 53512
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
53476: LD_ADDR_VAR 0 5
53480: PUSH
53481: LD_VAR 0 5
53485: PPUSH
53486: LD_VAR 0 5
53490: PUSH
53491: LD_INT 1
53493: PLUS
53494: PPUSH
53495: LD_VAR 0 4
53499: PPUSH
53500: CALL_OW 256
53504: PPUSH
53505: CALL_OW 2
53509: ST_TO_ADDR
53510: GO 53473
53512: POP
53513: POP
// if not tmp then
53514: LD_VAR 0 5
53518: NOT
53519: IFFALSE 53523
// exit ;
53521: GO 53571
// if asc then
53523: LD_VAR 0 2
53527: IFFALSE 53551
// result := SortListByListAsc ( units , tmp ) else
53529: LD_ADDR_VAR 0 3
53533: PUSH
53534: LD_VAR 0 1
53538: PPUSH
53539: LD_VAR 0 5
53543: PPUSH
53544: CALL_OW 76
53548: ST_TO_ADDR
53549: GO 53571
// result := SortListByListDesc ( units , tmp ) ;
53551: LD_ADDR_VAR 0 3
53555: PUSH
53556: LD_VAR 0 1
53560: PPUSH
53561: LD_VAR 0 5
53565: PPUSH
53566: CALL_OW 77
53570: ST_TO_ADDR
// end ;
53571: LD_VAR 0 3
53575: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
53576: LD_INT 0
53578: PPUSH
53579: PPUSH
// task := GetTaskList ( mech ) ;
53580: LD_ADDR_VAR 0 4
53584: PUSH
53585: LD_VAR 0 1
53589: PPUSH
53590: CALL_OW 437
53594: ST_TO_ADDR
// if not task then
53595: LD_VAR 0 4
53599: NOT
53600: IFFALSE 53604
// exit ;
53602: GO 53646
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
53604: LD_ADDR_VAR 0 3
53608: PUSH
53609: LD_VAR 0 4
53613: PUSH
53614: LD_INT 1
53616: ARRAY
53617: PUSH
53618: LD_INT 1
53620: ARRAY
53621: PUSH
53622: LD_STRING r
53624: EQUAL
53625: PUSH
53626: LD_VAR 0 4
53630: PUSH
53631: LD_INT 1
53633: ARRAY
53634: PUSH
53635: LD_INT 4
53637: ARRAY
53638: PUSH
53639: LD_VAR 0 2
53643: EQUAL
53644: AND
53645: ST_TO_ADDR
// end ;
53646: LD_VAR 0 3
53650: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
53651: LD_INT 0
53653: PPUSH
// SetDir ( unit , d ) ;
53654: LD_VAR 0 1
53658: PPUSH
53659: LD_VAR 0 4
53663: PPUSH
53664: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
53668: LD_VAR 0 1
53672: PPUSH
53673: LD_VAR 0 2
53677: PPUSH
53678: LD_VAR 0 3
53682: PPUSH
53683: LD_VAR 0 5
53687: PPUSH
53688: CALL_OW 48
// end ;
53692: LD_VAR 0 6
53696: RET
// export function ToNaturalNumber ( number ) ; begin
53697: LD_INT 0
53699: PPUSH
// result := number div 1 ;
53700: LD_ADDR_VAR 0 2
53704: PUSH
53705: LD_VAR 0 1
53709: PUSH
53710: LD_INT 1
53712: DIV
53713: ST_TO_ADDR
// if number < 0 then
53714: LD_VAR 0 1
53718: PUSH
53719: LD_INT 0
53721: LESS
53722: IFFALSE 53732
// result := 0 ;
53724: LD_ADDR_VAR 0 2
53728: PUSH
53729: LD_INT 0
53731: ST_TO_ADDR
// end ;
53732: LD_VAR 0 2
53736: RET
// export function SortByClass ( units , class ) ; var un ; begin
53737: LD_INT 0
53739: PPUSH
53740: PPUSH
// if not units or not class then
53741: LD_VAR 0 1
53745: NOT
53746: PUSH
53747: LD_VAR 0 2
53751: NOT
53752: OR
53753: IFFALSE 53757
// exit ;
53755: GO 53852
// result := [ ] ;
53757: LD_ADDR_VAR 0 3
53761: PUSH
53762: EMPTY
53763: ST_TO_ADDR
// for un in units do
53764: LD_ADDR_VAR 0 4
53768: PUSH
53769: LD_VAR 0 1
53773: PUSH
53774: FOR_IN
53775: IFFALSE 53850
// if GetClass ( un ) = class then
53777: LD_VAR 0 4
53781: PPUSH
53782: CALL_OW 257
53786: PUSH
53787: LD_VAR 0 2
53791: EQUAL
53792: IFFALSE 53819
// result := Insert ( result , 1 , un ) else
53794: LD_ADDR_VAR 0 3
53798: PUSH
53799: LD_VAR 0 3
53803: PPUSH
53804: LD_INT 1
53806: PPUSH
53807: LD_VAR 0 4
53811: PPUSH
53812: CALL_OW 2
53816: ST_TO_ADDR
53817: GO 53848
// result := Replace ( result , result + 1 , un ) ;
53819: LD_ADDR_VAR 0 3
53823: PUSH
53824: LD_VAR 0 3
53828: PPUSH
53829: LD_VAR 0 3
53833: PUSH
53834: LD_INT 1
53836: PLUS
53837: PPUSH
53838: LD_VAR 0 4
53842: PPUSH
53843: CALL_OW 1
53847: ST_TO_ADDR
53848: GO 53774
53850: POP
53851: POP
// end ;
53852: LD_VAR 0 3
53856: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
53857: LD_INT 0
53859: PPUSH
53860: PPUSH
53861: PPUSH
53862: PPUSH
53863: PPUSH
53864: PPUSH
53865: PPUSH
// result := [ ] ;
53866: LD_ADDR_VAR 0 4
53870: PUSH
53871: EMPTY
53872: ST_TO_ADDR
// if x - r < 0 then
53873: LD_VAR 0 1
53877: PUSH
53878: LD_VAR 0 3
53882: MINUS
53883: PUSH
53884: LD_INT 0
53886: LESS
53887: IFFALSE 53899
// min_x := 0 else
53889: LD_ADDR_VAR 0 8
53893: PUSH
53894: LD_INT 0
53896: ST_TO_ADDR
53897: GO 53915
// min_x := x - r ;
53899: LD_ADDR_VAR 0 8
53903: PUSH
53904: LD_VAR 0 1
53908: PUSH
53909: LD_VAR 0 3
53913: MINUS
53914: ST_TO_ADDR
// if y - r < 0 then
53915: LD_VAR 0 2
53919: PUSH
53920: LD_VAR 0 3
53924: MINUS
53925: PUSH
53926: LD_INT 0
53928: LESS
53929: IFFALSE 53941
// min_y := 0 else
53931: LD_ADDR_VAR 0 7
53935: PUSH
53936: LD_INT 0
53938: ST_TO_ADDR
53939: GO 53957
// min_y := y - r ;
53941: LD_ADDR_VAR 0 7
53945: PUSH
53946: LD_VAR 0 2
53950: PUSH
53951: LD_VAR 0 3
53955: MINUS
53956: ST_TO_ADDR
// max_x := x + r ;
53957: LD_ADDR_VAR 0 9
53961: PUSH
53962: LD_VAR 0 1
53966: PUSH
53967: LD_VAR 0 3
53971: PLUS
53972: ST_TO_ADDR
// max_y := y + r ;
53973: LD_ADDR_VAR 0 10
53977: PUSH
53978: LD_VAR 0 2
53982: PUSH
53983: LD_VAR 0 3
53987: PLUS
53988: ST_TO_ADDR
// for _x = min_x to max_x do
53989: LD_ADDR_VAR 0 5
53993: PUSH
53994: DOUBLE
53995: LD_VAR 0 8
53999: DEC
54000: ST_TO_ADDR
54001: LD_VAR 0 9
54005: PUSH
54006: FOR_TO
54007: IFFALSE 54108
// for _y = min_y to max_y do
54009: LD_ADDR_VAR 0 6
54013: PUSH
54014: DOUBLE
54015: LD_VAR 0 7
54019: DEC
54020: ST_TO_ADDR
54021: LD_VAR 0 10
54025: PUSH
54026: FOR_TO
54027: IFFALSE 54104
// begin if not ValidHex ( _x , _y ) then
54029: LD_VAR 0 5
54033: PPUSH
54034: LD_VAR 0 6
54038: PPUSH
54039: CALL_OW 488
54043: NOT
54044: IFFALSE 54048
// continue ;
54046: GO 54026
// if GetResourceTypeXY ( _x , _y ) then
54048: LD_VAR 0 5
54052: PPUSH
54053: LD_VAR 0 6
54057: PPUSH
54058: CALL_OW 283
54062: IFFALSE 54102
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
54064: LD_ADDR_VAR 0 4
54068: PUSH
54069: LD_VAR 0 4
54073: PPUSH
54074: LD_VAR 0 4
54078: PUSH
54079: LD_INT 1
54081: PLUS
54082: PPUSH
54083: LD_VAR 0 5
54087: PUSH
54088: LD_VAR 0 6
54092: PUSH
54093: EMPTY
54094: LIST
54095: LIST
54096: PPUSH
54097: CALL_OW 1
54101: ST_TO_ADDR
// end ;
54102: GO 54026
54104: POP
54105: POP
54106: GO 54006
54108: POP
54109: POP
// end ;
54110: LD_VAR 0 4
54114: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
54115: LD_INT 0
54117: PPUSH
54118: PPUSH
54119: PPUSH
54120: PPUSH
54121: PPUSH
54122: PPUSH
54123: PPUSH
54124: PPUSH
// if not units then
54125: LD_VAR 0 1
54129: NOT
54130: IFFALSE 54134
// exit ;
54132: GO 54559
// result := UnitFilter ( units , [ f_ok ] ) ;
54134: LD_ADDR_VAR 0 3
54138: PUSH
54139: LD_VAR 0 1
54143: PPUSH
54144: LD_INT 50
54146: PUSH
54147: EMPTY
54148: LIST
54149: PPUSH
54150: CALL_OW 72
54154: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
54155: LD_ADDR_VAR 0 8
54159: PUSH
54160: LD_VAR 0 1
54164: PUSH
54165: LD_INT 1
54167: ARRAY
54168: PPUSH
54169: CALL_OW 255
54173: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
54174: LD_ADDR_VAR 0 10
54178: PUSH
54179: LD_INT 29
54181: PUSH
54182: LD_EXP 108
54186: PUSH
54187: EMPTY
54188: LIST
54189: LIST
54190: ST_TO_ADDR
// if not result then
54191: LD_VAR 0 3
54195: NOT
54196: IFFALSE 54200
// exit ;
54198: GO 54559
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
54200: LD_ADDR_VAR 0 5
54204: PUSH
54205: LD_INT 81
54207: PUSH
54208: LD_VAR 0 8
54212: PUSH
54213: EMPTY
54214: LIST
54215: LIST
54216: PPUSH
54217: CALL_OW 69
54221: ST_TO_ADDR
// for i in result do
54222: LD_ADDR_VAR 0 4
54226: PUSH
54227: LD_VAR 0 3
54231: PUSH
54232: FOR_IN
54233: IFFALSE 54557
// begin tag := GetTag ( i ) + 1 ;
54235: LD_ADDR_VAR 0 9
54239: PUSH
54240: LD_VAR 0 4
54244: PPUSH
54245: CALL_OW 110
54249: PUSH
54250: LD_INT 1
54252: PLUS
54253: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
54254: LD_ADDR_VAR 0 7
54258: PUSH
54259: LD_VAR 0 4
54263: PPUSH
54264: CALL_OW 250
54268: PPUSH
54269: LD_VAR 0 4
54273: PPUSH
54274: CALL_OW 251
54278: PPUSH
54279: LD_INT 6
54281: PPUSH
54282: CALL 53857 0 3
54286: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
54287: LD_VAR 0 7
54291: PUSH
54292: LD_VAR 0 4
54296: PPUSH
54297: CALL_OW 264
54301: PUSH
54302: LD_VAR 0 10
54306: IN
54307: NOT
54308: AND
54309: IFFALSE 54348
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
54311: LD_VAR 0 4
54315: PPUSH
54316: LD_VAR 0 7
54320: PUSH
54321: LD_INT 1
54323: ARRAY
54324: PUSH
54325: LD_INT 1
54327: ARRAY
54328: PPUSH
54329: LD_VAR 0 7
54333: PUSH
54334: LD_INT 1
54336: ARRAY
54337: PUSH
54338: LD_INT 2
54340: ARRAY
54341: PPUSH
54342: CALL_OW 116
54346: GO 54555
// if path > tag then
54348: LD_VAR 0 2
54352: PUSH
54353: LD_VAR 0 9
54357: GREATER
54358: IFFALSE 54525
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
54360: LD_ADDR_VAR 0 6
54364: PUSH
54365: LD_VAR 0 5
54369: PPUSH
54370: LD_INT 91
54372: PUSH
54373: LD_VAR 0 4
54377: PUSH
54378: LD_INT 12
54380: PUSH
54381: EMPTY
54382: LIST
54383: LIST
54384: LIST
54385: PPUSH
54386: CALL_OW 72
54390: ST_TO_ADDR
// if nearEnemy then
54391: LD_VAR 0 6
54395: IFFALSE 54423
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
54397: LD_VAR 0 4
54401: PPUSH
54402: LD_VAR 0 6
54406: PPUSH
54407: LD_VAR 0 4
54411: PPUSH
54412: CALL_OW 74
54416: PPUSH
54417: CALL_OW 115
54421: GO 54523
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
54423: LD_VAR 0 4
54427: PPUSH
54428: LD_VAR 0 2
54432: PUSH
54433: LD_VAR 0 9
54437: ARRAY
54438: PUSH
54439: LD_INT 1
54441: ARRAY
54442: PPUSH
54443: LD_VAR 0 2
54447: PUSH
54448: LD_VAR 0 9
54452: ARRAY
54453: PUSH
54454: LD_INT 2
54456: ARRAY
54457: PPUSH
54458: CALL_OW 297
54462: PUSH
54463: LD_INT 6
54465: GREATER
54466: IFFALSE 54509
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
54468: LD_VAR 0 4
54472: PPUSH
54473: LD_VAR 0 2
54477: PUSH
54478: LD_VAR 0 9
54482: ARRAY
54483: PUSH
54484: LD_INT 1
54486: ARRAY
54487: PPUSH
54488: LD_VAR 0 2
54492: PUSH
54493: LD_VAR 0 9
54497: ARRAY
54498: PUSH
54499: LD_INT 2
54501: ARRAY
54502: PPUSH
54503: CALL_OW 114
54507: GO 54523
// SetTag ( i , tag ) ;
54509: LD_VAR 0 4
54513: PPUSH
54514: LD_VAR 0 9
54518: PPUSH
54519: CALL_OW 109
// end else
54523: GO 54555
// if enemy then
54525: LD_VAR 0 5
54529: IFFALSE 54555
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
54531: LD_VAR 0 4
54535: PPUSH
54536: LD_VAR 0 5
54540: PPUSH
54541: LD_VAR 0 4
54545: PPUSH
54546: CALL_OW 74
54550: PPUSH
54551: CALL_OW 115
// end ;
54555: GO 54232
54557: POP
54558: POP
// end ;
54559: LD_VAR 0 3
54563: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
54564: LD_INT 0
54566: PPUSH
54567: PPUSH
54568: PPUSH
// if not unit or IsInUnit ( unit ) then
54569: LD_VAR 0 1
54573: NOT
54574: PUSH
54575: LD_VAR 0 1
54579: PPUSH
54580: CALL_OW 310
54584: OR
54585: IFFALSE 54589
// exit ;
54587: GO 54680
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
54589: LD_ADDR_VAR 0 4
54593: PUSH
54594: LD_VAR 0 1
54598: PPUSH
54599: CALL_OW 250
54603: PPUSH
54604: LD_VAR 0 2
54608: PPUSH
54609: LD_INT 1
54611: PPUSH
54612: CALL_OW 272
54616: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
54617: LD_ADDR_VAR 0 5
54621: PUSH
54622: LD_VAR 0 1
54626: PPUSH
54627: CALL_OW 251
54631: PPUSH
54632: LD_VAR 0 2
54636: PPUSH
54637: LD_INT 1
54639: PPUSH
54640: CALL_OW 273
54644: ST_TO_ADDR
// if ValidHex ( x , y ) then
54645: LD_VAR 0 4
54649: PPUSH
54650: LD_VAR 0 5
54654: PPUSH
54655: CALL_OW 488
54659: IFFALSE 54680
// ComTurnXY ( unit , x , y ) ;
54661: LD_VAR 0 1
54665: PPUSH
54666: LD_VAR 0 4
54670: PPUSH
54671: LD_VAR 0 5
54675: PPUSH
54676: CALL_OW 118
// end ;
54680: LD_VAR 0 3
54684: RET
// export function SeeUnits ( side , units ) ; var i ; begin
54685: LD_INT 0
54687: PPUSH
54688: PPUSH
// result := false ;
54689: LD_ADDR_VAR 0 3
54693: PUSH
54694: LD_INT 0
54696: ST_TO_ADDR
// if not units then
54697: LD_VAR 0 2
54701: NOT
54702: IFFALSE 54706
// exit ;
54704: GO 54751
// for i in units do
54706: LD_ADDR_VAR 0 4
54710: PUSH
54711: LD_VAR 0 2
54715: PUSH
54716: FOR_IN
54717: IFFALSE 54749
// if See ( side , i ) then
54719: LD_VAR 0 1
54723: PPUSH
54724: LD_VAR 0 4
54728: PPUSH
54729: CALL_OW 292
54733: IFFALSE 54747
// begin result := true ;
54735: LD_ADDR_VAR 0 3
54739: PUSH
54740: LD_INT 1
54742: ST_TO_ADDR
// exit ;
54743: POP
54744: POP
54745: GO 54751
// end ;
54747: GO 54716
54749: POP
54750: POP
// end ;
54751: LD_VAR 0 3
54755: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
54756: LD_INT 0
54758: PPUSH
54759: PPUSH
54760: PPUSH
54761: PPUSH
// if not unit or not points then
54762: LD_VAR 0 1
54766: NOT
54767: PUSH
54768: LD_VAR 0 2
54772: NOT
54773: OR
54774: IFFALSE 54778
// exit ;
54776: GO 54868
// dist := 99999 ;
54778: LD_ADDR_VAR 0 5
54782: PUSH
54783: LD_INT 99999
54785: ST_TO_ADDR
// for i in points do
54786: LD_ADDR_VAR 0 4
54790: PUSH
54791: LD_VAR 0 2
54795: PUSH
54796: FOR_IN
54797: IFFALSE 54866
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54799: LD_ADDR_VAR 0 6
54803: PUSH
54804: LD_VAR 0 1
54808: PPUSH
54809: LD_VAR 0 4
54813: PUSH
54814: LD_INT 1
54816: ARRAY
54817: PPUSH
54818: LD_VAR 0 4
54822: PUSH
54823: LD_INT 2
54825: ARRAY
54826: PPUSH
54827: CALL_OW 297
54831: ST_TO_ADDR
// if tmpDist < dist then
54832: LD_VAR 0 6
54836: PUSH
54837: LD_VAR 0 5
54841: LESS
54842: IFFALSE 54864
// begin result := i ;
54844: LD_ADDR_VAR 0 3
54848: PUSH
54849: LD_VAR 0 4
54853: ST_TO_ADDR
// dist := tmpDist ;
54854: LD_ADDR_VAR 0 5
54858: PUSH
54859: LD_VAR 0 6
54863: ST_TO_ADDR
// end ; end ;
54864: GO 54796
54866: POP
54867: POP
// end ; end_of_file
54868: LD_VAR 0 3
54872: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
54873: LD_INT 0
54875: PPUSH
54876: PPUSH
// skirmish := false ;
54877: LD_ADDR_EXP 58
54881: PUSH
54882: LD_INT 0
54884: ST_TO_ADDR
// debug_mc := false ;
54885: LD_ADDR_EXP 59
54889: PUSH
54890: LD_INT 0
54892: ST_TO_ADDR
// mc_bases := [ ] ;
54893: LD_ADDR_EXP 60
54897: PUSH
54898: EMPTY
54899: ST_TO_ADDR
// mc_sides := [ ] ;
54900: LD_ADDR_EXP 86
54904: PUSH
54905: EMPTY
54906: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
54907: LD_ADDR_EXP 61
54911: PUSH
54912: EMPTY
54913: ST_TO_ADDR
// mc_building_repairs := [ ] ;
54914: LD_ADDR_EXP 62
54918: PUSH
54919: EMPTY
54920: ST_TO_ADDR
// mc_need_heal := [ ] ;
54921: LD_ADDR_EXP 63
54925: PUSH
54926: EMPTY
54927: ST_TO_ADDR
// mc_healers := [ ] ;
54928: LD_ADDR_EXP 64
54932: PUSH
54933: EMPTY
54934: ST_TO_ADDR
// mc_build_list := [ ] ;
54935: LD_ADDR_EXP 65
54939: PUSH
54940: EMPTY
54941: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
54942: LD_ADDR_EXP 92
54946: PUSH
54947: EMPTY
54948: ST_TO_ADDR
// mc_builders := [ ] ;
54949: LD_ADDR_EXP 66
54953: PUSH
54954: EMPTY
54955: ST_TO_ADDR
// mc_construct_list := [ ] ;
54956: LD_ADDR_EXP 67
54960: PUSH
54961: EMPTY
54962: ST_TO_ADDR
// mc_turret_list := [ ] ;
54963: LD_ADDR_EXP 68
54967: PUSH
54968: EMPTY
54969: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
54970: LD_ADDR_EXP 69
54974: PUSH
54975: EMPTY
54976: ST_TO_ADDR
// mc_miners := [ ] ;
54977: LD_ADDR_EXP 74
54981: PUSH
54982: EMPTY
54983: ST_TO_ADDR
// mc_mines := [ ] ;
54984: LD_ADDR_EXP 73
54988: PUSH
54989: EMPTY
54990: ST_TO_ADDR
// mc_minefields := [ ] ;
54991: LD_ADDR_EXP 75
54995: PUSH
54996: EMPTY
54997: ST_TO_ADDR
// mc_crates := [ ] ;
54998: LD_ADDR_EXP 76
55002: PUSH
55003: EMPTY
55004: ST_TO_ADDR
// mc_crates_collector := [ ] ;
55005: LD_ADDR_EXP 77
55009: PUSH
55010: EMPTY
55011: ST_TO_ADDR
// mc_crates_area := [ ] ;
55012: LD_ADDR_EXP 78
55016: PUSH
55017: EMPTY
55018: ST_TO_ADDR
// mc_vehicles := [ ] ;
55019: LD_ADDR_EXP 79
55023: PUSH
55024: EMPTY
55025: ST_TO_ADDR
// mc_attack := [ ] ;
55026: LD_ADDR_EXP 80
55030: PUSH
55031: EMPTY
55032: ST_TO_ADDR
// mc_produce := [ ] ;
55033: LD_ADDR_EXP 81
55037: PUSH
55038: EMPTY
55039: ST_TO_ADDR
// mc_defender := [ ] ;
55040: LD_ADDR_EXP 82
55044: PUSH
55045: EMPTY
55046: ST_TO_ADDR
// mc_parking := [ ] ;
55047: LD_ADDR_EXP 84
55051: PUSH
55052: EMPTY
55053: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
55054: LD_ADDR_EXP 70
55058: PUSH
55059: EMPTY
55060: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
55061: LD_ADDR_EXP 72
55065: PUSH
55066: EMPTY
55067: ST_TO_ADDR
// mc_scan := [ ] ;
55068: LD_ADDR_EXP 83
55072: PUSH
55073: EMPTY
55074: ST_TO_ADDR
// mc_scan_area := [ ] ;
55075: LD_ADDR_EXP 85
55079: PUSH
55080: EMPTY
55081: ST_TO_ADDR
// mc_tech := [ ] ;
55082: LD_ADDR_EXP 87
55086: PUSH
55087: EMPTY
55088: ST_TO_ADDR
// mc_class := [ ] ;
55089: LD_ADDR_EXP 101
55093: PUSH
55094: EMPTY
55095: ST_TO_ADDR
// mc_class_case_use := [ ] ;
55096: LD_ADDR_EXP 102
55100: PUSH
55101: EMPTY
55102: ST_TO_ADDR
// mc_is_defending := [ ] ;
55103: LD_ADDR_EXP 103
55107: PUSH
55108: EMPTY
55109: ST_TO_ADDR
// end ;
55110: LD_VAR 0 1
55114: RET
// export function MC_Kill ( base ) ; begin
55115: LD_INT 0
55117: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
55118: LD_ADDR_EXP 60
55122: PUSH
55123: LD_EXP 60
55127: PPUSH
55128: LD_VAR 0 1
55132: PPUSH
55133: EMPTY
55134: PPUSH
55135: CALL_OW 1
55139: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55140: LD_ADDR_EXP 61
55144: PUSH
55145: LD_EXP 61
55149: PPUSH
55150: LD_VAR 0 1
55154: PPUSH
55155: EMPTY
55156: PPUSH
55157: CALL_OW 1
55161: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55162: LD_ADDR_EXP 62
55166: PUSH
55167: LD_EXP 62
55171: PPUSH
55172: LD_VAR 0 1
55176: PPUSH
55177: EMPTY
55178: PPUSH
55179: CALL_OW 1
55183: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55184: LD_ADDR_EXP 63
55188: PUSH
55189: LD_EXP 63
55193: PPUSH
55194: LD_VAR 0 1
55198: PPUSH
55199: EMPTY
55200: PPUSH
55201: CALL_OW 1
55205: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55206: LD_ADDR_EXP 64
55210: PUSH
55211: LD_EXP 64
55215: PPUSH
55216: LD_VAR 0 1
55220: PPUSH
55221: EMPTY
55222: PPUSH
55223: CALL_OW 1
55227: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55228: LD_ADDR_EXP 65
55232: PUSH
55233: LD_EXP 65
55237: PPUSH
55238: LD_VAR 0 1
55242: PPUSH
55243: EMPTY
55244: PPUSH
55245: CALL_OW 1
55249: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55250: LD_ADDR_EXP 66
55254: PUSH
55255: LD_EXP 66
55259: PPUSH
55260: LD_VAR 0 1
55264: PPUSH
55265: EMPTY
55266: PPUSH
55267: CALL_OW 1
55271: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55272: LD_ADDR_EXP 67
55276: PUSH
55277: LD_EXP 67
55281: PPUSH
55282: LD_VAR 0 1
55286: PPUSH
55287: EMPTY
55288: PPUSH
55289: CALL_OW 1
55293: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55294: LD_ADDR_EXP 68
55298: PUSH
55299: LD_EXP 68
55303: PPUSH
55304: LD_VAR 0 1
55308: PPUSH
55309: EMPTY
55310: PPUSH
55311: CALL_OW 1
55315: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55316: LD_ADDR_EXP 69
55320: PUSH
55321: LD_EXP 69
55325: PPUSH
55326: LD_VAR 0 1
55330: PPUSH
55331: EMPTY
55332: PPUSH
55333: CALL_OW 1
55337: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55338: LD_ADDR_EXP 70
55342: PUSH
55343: LD_EXP 70
55347: PPUSH
55348: LD_VAR 0 1
55352: PPUSH
55353: EMPTY
55354: PPUSH
55355: CALL_OW 1
55359: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55360: LD_ADDR_EXP 71
55364: PUSH
55365: LD_EXP 71
55369: PPUSH
55370: LD_VAR 0 1
55374: PPUSH
55375: LD_INT 0
55377: PPUSH
55378: CALL_OW 1
55382: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55383: LD_ADDR_EXP 72
55387: PUSH
55388: LD_EXP 72
55392: PPUSH
55393: LD_VAR 0 1
55397: PPUSH
55398: EMPTY
55399: PPUSH
55400: CALL_OW 1
55404: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55405: LD_ADDR_EXP 73
55409: PUSH
55410: LD_EXP 73
55414: PPUSH
55415: LD_VAR 0 1
55419: PPUSH
55420: EMPTY
55421: PPUSH
55422: CALL_OW 1
55426: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55427: LD_ADDR_EXP 74
55431: PUSH
55432: LD_EXP 74
55436: PPUSH
55437: LD_VAR 0 1
55441: PPUSH
55442: EMPTY
55443: PPUSH
55444: CALL_OW 1
55448: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55449: LD_ADDR_EXP 75
55453: PUSH
55454: LD_EXP 75
55458: PPUSH
55459: LD_VAR 0 1
55463: PPUSH
55464: EMPTY
55465: PPUSH
55466: CALL_OW 1
55470: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55471: LD_ADDR_EXP 76
55475: PUSH
55476: LD_EXP 76
55480: PPUSH
55481: LD_VAR 0 1
55485: PPUSH
55486: EMPTY
55487: PPUSH
55488: CALL_OW 1
55492: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55493: LD_ADDR_EXP 77
55497: PUSH
55498: LD_EXP 77
55502: PPUSH
55503: LD_VAR 0 1
55507: PPUSH
55508: EMPTY
55509: PPUSH
55510: CALL_OW 1
55514: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55515: LD_ADDR_EXP 78
55519: PUSH
55520: LD_EXP 78
55524: PPUSH
55525: LD_VAR 0 1
55529: PPUSH
55530: EMPTY
55531: PPUSH
55532: CALL_OW 1
55536: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55537: LD_ADDR_EXP 79
55541: PUSH
55542: LD_EXP 79
55546: PPUSH
55547: LD_VAR 0 1
55551: PPUSH
55552: EMPTY
55553: PPUSH
55554: CALL_OW 1
55558: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55559: LD_ADDR_EXP 80
55563: PUSH
55564: LD_EXP 80
55568: PPUSH
55569: LD_VAR 0 1
55573: PPUSH
55574: EMPTY
55575: PPUSH
55576: CALL_OW 1
55580: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55581: LD_ADDR_EXP 81
55585: PUSH
55586: LD_EXP 81
55590: PPUSH
55591: LD_VAR 0 1
55595: PPUSH
55596: EMPTY
55597: PPUSH
55598: CALL_OW 1
55602: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55603: LD_ADDR_EXP 82
55607: PUSH
55608: LD_EXP 82
55612: PPUSH
55613: LD_VAR 0 1
55617: PPUSH
55618: EMPTY
55619: PPUSH
55620: CALL_OW 1
55624: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55625: LD_ADDR_EXP 83
55629: PUSH
55630: LD_EXP 83
55634: PPUSH
55635: LD_VAR 0 1
55639: PPUSH
55640: EMPTY
55641: PPUSH
55642: CALL_OW 1
55646: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55647: LD_ADDR_EXP 84
55651: PUSH
55652: LD_EXP 84
55656: PPUSH
55657: LD_VAR 0 1
55661: PPUSH
55662: EMPTY
55663: PPUSH
55664: CALL_OW 1
55668: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55669: LD_ADDR_EXP 85
55673: PUSH
55674: LD_EXP 85
55678: PPUSH
55679: LD_VAR 0 1
55683: PPUSH
55684: EMPTY
55685: PPUSH
55686: CALL_OW 1
55690: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55691: LD_ADDR_EXP 87
55695: PUSH
55696: LD_EXP 87
55700: PPUSH
55701: LD_VAR 0 1
55705: PPUSH
55706: EMPTY
55707: PPUSH
55708: CALL_OW 1
55712: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55713: LD_ADDR_EXP 89
55717: PUSH
55718: LD_EXP 89
55722: PPUSH
55723: LD_VAR 0 1
55727: PPUSH
55728: EMPTY
55729: PPUSH
55730: CALL_OW 1
55734: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55735: LD_ADDR_EXP 90
55739: PUSH
55740: LD_EXP 90
55744: PPUSH
55745: LD_VAR 0 1
55749: PPUSH
55750: EMPTY
55751: PPUSH
55752: CALL_OW 1
55756: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55757: LD_ADDR_EXP 91
55761: PUSH
55762: LD_EXP 91
55766: PPUSH
55767: LD_VAR 0 1
55771: PPUSH
55772: EMPTY
55773: PPUSH
55774: CALL_OW 1
55778: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55779: LD_ADDR_EXP 92
55783: PUSH
55784: LD_EXP 92
55788: PPUSH
55789: LD_VAR 0 1
55793: PPUSH
55794: EMPTY
55795: PPUSH
55796: CALL_OW 1
55800: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55801: LD_ADDR_EXP 93
55805: PUSH
55806: LD_EXP 93
55810: PPUSH
55811: LD_VAR 0 1
55815: PPUSH
55816: EMPTY
55817: PPUSH
55818: CALL_OW 1
55822: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55823: LD_ADDR_EXP 94
55827: PUSH
55828: LD_EXP 94
55832: PPUSH
55833: LD_VAR 0 1
55837: PPUSH
55838: EMPTY
55839: PPUSH
55840: CALL_OW 1
55844: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55845: LD_ADDR_EXP 95
55849: PUSH
55850: LD_EXP 95
55854: PPUSH
55855: LD_VAR 0 1
55859: PPUSH
55860: EMPTY
55861: PPUSH
55862: CALL_OW 1
55866: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55867: LD_ADDR_EXP 96
55871: PUSH
55872: LD_EXP 96
55876: PPUSH
55877: LD_VAR 0 1
55881: PPUSH
55882: EMPTY
55883: PPUSH
55884: CALL_OW 1
55888: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55889: LD_ADDR_EXP 97
55893: PUSH
55894: LD_EXP 97
55898: PPUSH
55899: LD_VAR 0 1
55903: PPUSH
55904: EMPTY
55905: PPUSH
55906: CALL_OW 1
55910: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55911: LD_ADDR_EXP 98
55915: PUSH
55916: LD_EXP 98
55920: PPUSH
55921: LD_VAR 0 1
55925: PPUSH
55926: EMPTY
55927: PPUSH
55928: CALL_OW 1
55932: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55933: LD_ADDR_EXP 99
55937: PUSH
55938: LD_EXP 99
55942: PPUSH
55943: LD_VAR 0 1
55947: PPUSH
55948: EMPTY
55949: PPUSH
55950: CALL_OW 1
55954: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55955: LD_ADDR_EXP 100
55959: PUSH
55960: LD_EXP 100
55964: PPUSH
55965: LD_VAR 0 1
55969: PPUSH
55970: EMPTY
55971: PPUSH
55972: CALL_OW 1
55976: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55977: LD_ADDR_EXP 101
55981: PUSH
55982: LD_EXP 101
55986: PPUSH
55987: LD_VAR 0 1
55991: PPUSH
55992: EMPTY
55993: PPUSH
55994: CALL_OW 1
55998: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55999: LD_ADDR_EXP 102
56003: PUSH
56004: LD_EXP 102
56008: PPUSH
56009: LD_VAR 0 1
56013: PPUSH
56014: LD_INT 0
56016: PPUSH
56017: CALL_OW 1
56021: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56022: LD_ADDR_EXP 103
56026: PUSH
56027: LD_EXP 103
56031: PPUSH
56032: LD_VAR 0 1
56036: PPUSH
56037: LD_INT 0
56039: PPUSH
56040: CALL_OW 1
56044: ST_TO_ADDR
// end ;
56045: LD_VAR 0 2
56049: RET
// export function MC_Add ( side , units ) ; var base ; begin
56050: LD_INT 0
56052: PPUSH
56053: PPUSH
// base := mc_bases + 1 ;
56054: LD_ADDR_VAR 0 4
56058: PUSH
56059: LD_EXP 60
56063: PUSH
56064: LD_INT 1
56066: PLUS
56067: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
56068: LD_ADDR_EXP 86
56072: PUSH
56073: LD_EXP 86
56077: PPUSH
56078: LD_VAR 0 4
56082: PPUSH
56083: LD_VAR 0 1
56087: PPUSH
56088: CALL_OW 1
56092: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
56093: LD_ADDR_EXP 60
56097: PUSH
56098: LD_EXP 60
56102: PPUSH
56103: LD_VAR 0 4
56107: PPUSH
56108: LD_VAR 0 2
56112: PPUSH
56113: CALL_OW 1
56117: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56118: LD_ADDR_EXP 61
56122: PUSH
56123: LD_EXP 61
56127: PPUSH
56128: LD_VAR 0 4
56132: PPUSH
56133: EMPTY
56134: PPUSH
56135: CALL_OW 1
56139: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56140: LD_ADDR_EXP 62
56144: PUSH
56145: LD_EXP 62
56149: PPUSH
56150: LD_VAR 0 4
56154: PPUSH
56155: EMPTY
56156: PPUSH
56157: CALL_OW 1
56161: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56162: LD_ADDR_EXP 63
56166: PUSH
56167: LD_EXP 63
56171: PPUSH
56172: LD_VAR 0 4
56176: PPUSH
56177: EMPTY
56178: PPUSH
56179: CALL_OW 1
56183: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56184: LD_ADDR_EXP 64
56188: PUSH
56189: LD_EXP 64
56193: PPUSH
56194: LD_VAR 0 4
56198: PPUSH
56199: EMPTY
56200: PPUSH
56201: CALL_OW 1
56205: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56206: LD_ADDR_EXP 65
56210: PUSH
56211: LD_EXP 65
56215: PPUSH
56216: LD_VAR 0 4
56220: PPUSH
56221: EMPTY
56222: PPUSH
56223: CALL_OW 1
56227: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56228: LD_ADDR_EXP 66
56232: PUSH
56233: LD_EXP 66
56237: PPUSH
56238: LD_VAR 0 4
56242: PPUSH
56243: EMPTY
56244: PPUSH
56245: CALL_OW 1
56249: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56250: LD_ADDR_EXP 67
56254: PUSH
56255: LD_EXP 67
56259: PPUSH
56260: LD_VAR 0 4
56264: PPUSH
56265: EMPTY
56266: PPUSH
56267: CALL_OW 1
56271: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56272: LD_ADDR_EXP 68
56276: PUSH
56277: LD_EXP 68
56281: PPUSH
56282: LD_VAR 0 4
56286: PPUSH
56287: EMPTY
56288: PPUSH
56289: CALL_OW 1
56293: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56294: LD_ADDR_EXP 69
56298: PUSH
56299: LD_EXP 69
56303: PPUSH
56304: LD_VAR 0 4
56308: PPUSH
56309: EMPTY
56310: PPUSH
56311: CALL_OW 1
56315: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56316: LD_ADDR_EXP 70
56320: PUSH
56321: LD_EXP 70
56325: PPUSH
56326: LD_VAR 0 4
56330: PPUSH
56331: EMPTY
56332: PPUSH
56333: CALL_OW 1
56337: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56338: LD_ADDR_EXP 71
56342: PUSH
56343: LD_EXP 71
56347: PPUSH
56348: LD_VAR 0 4
56352: PPUSH
56353: LD_INT 0
56355: PPUSH
56356: CALL_OW 1
56360: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56361: LD_ADDR_EXP 72
56365: PUSH
56366: LD_EXP 72
56370: PPUSH
56371: LD_VAR 0 4
56375: PPUSH
56376: EMPTY
56377: PPUSH
56378: CALL_OW 1
56382: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56383: LD_ADDR_EXP 73
56387: PUSH
56388: LD_EXP 73
56392: PPUSH
56393: LD_VAR 0 4
56397: PPUSH
56398: EMPTY
56399: PPUSH
56400: CALL_OW 1
56404: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56405: LD_ADDR_EXP 74
56409: PUSH
56410: LD_EXP 74
56414: PPUSH
56415: LD_VAR 0 4
56419: PPUSH
56420: EMPTY
56421: PPUSH
56422: CALL_OW 1
56426: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56427: LD_ADDR_EXP 75
56431: PUSH
56432: LD_EXP 75
56436: PPUSH
56437: LD_VAR 0 4
56441: PPUSH
56442: EMPTY
56443: PPUSH
56444: CALL_OW 1
56448: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56449: LD_ADDR_EXP 76
56453: PUSH
56454: LD_EXP 76
56458: PPUSH
56459: LD_VAR 0 4
56463: PPUSH
56464: EMPTY
56465: PPUSH
56466: CALL_OW 1
56470: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56471: LD_ADDR_EXP 77
56475: PUSH
56476: LD_EXP 77
56480: PPUSH
56481: LD_VAR 0 4
56485: PPUSH
56486: EMPTY
56487: PPUSH
56488: CALL_OW 1
56492: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56493: LD_ADDR_EXP 78
56497: PUSH
56498: LD_EXP 78
56502: PPUSH
56503: LD_VAR 0 4
56507: PPUSH
56508: EMPTY
56509: PPUSH
56510: CALL_OW 1
56514: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56515: LD_ADDR_EXP 79
56519: PUSH
56520: LD_EXP 79
56524: PPUSH
56525: LD_VAR 0 4
56529: PPUSH
56530: EMPTY
56531: PPUSH
56532: CALL_OW 1
56536: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56537: LD_ADDR_EXP 80
56541: PUSH
56542: LD_EXP 80
56546: PPUSH
56547: LD_VAR 0 4
56551: PPUSH
56552: EMPTY
56553: PPUSH
56554: CALL_OW 1
56558: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56559: LD_ADDR_EXP 81
56563: PUSH
56564: LD_EXP 81
56568: PPUSH
56569: LD_VAR 0 4
56573: PPUSH
56574: EMPTY
56575: PPUSH
56576: CALL_OW 1
56580: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56581: LD_ADDR_EXP 82
56585: PUSH
56586: LD_EXP 82
56590: PPUSH
56591: LD_VAR 0 4
56595: PPUSH
56596: EMPTY
56597: PPUSH
56598: CALL_OW 1
56602: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56603: LD_ADDR_EXP 83
56607: PUSH
56608: LD_EXP 83
56612: PPUSH
56613: LD_VAR 0 4
56617: PPUSH
56618: EMPTY
56619: PPUSH
56620: CALL_OW 1
56624: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56625: LD_ADDR_EXP 84
56629: PUSH
56630: LD_EXP 84
56634: PPUSH
56635: LD_VAR 0 4
56639: PPUSH
56640: EMPTY
56641: PPUSH
56642: CALL_OW 1
56646: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56647: LD_ADDR_EXP 85
56651: PUSH
56652: LD_EXP 85
56656: PPUSH
56657: LD_VAR 0 4
56661: PPUSH
56662: EMPTY
56663: PPUSH
56664: CALL_OW 1
56668: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56669: LD_ADDR_EXP 87
56673: PUSH
56674: LD_EXP 87
56678: PPUSH
56679: LD_VAR 0 4
56683: PPUSH
56684: EMPTY
56685: PPUSH
56686: CALL_OW 1
56690: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56691: LD_ADDR_EXP 89
56695: PUSH
56696: LD_EXP 89
56700: PPUSH
56701: LD_VAR 0 4
56705: PPUSH
56706: EMPTY
56707: PPUSH
56708: CALL_OW 1
56712: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56713: LD_ADDR_EXP 90
56717: PUSH
56718: LD_EXP 90
56722: PPUSH
56723: LD_VAR 0 4
56727: PPUSH
56728: EMPTY
56729: PPUSH
56730: CALL_OW 1
56734: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56735: LD_ADDR_EXP 91
56739: PUSH
56740: LD_EXP 91
56744: PPUSH
56745: LD_VAR 0 4
56749: PPUSH
56750: EMPTY
56751: PPUSH
56752: CALL_OW 1
56756: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56757: LD_ADDR_EXP 92
56761: PUSH
56762: LD_EXP 92
56766: PPUSH
56767: LD_VAR 0 4
56771: PPUSH
56772: EMPTY
56773: PPUSH
56774: CALL_OW 1
56778: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56779: LD_ADDR_EXP 93
56783: PUSH
56784: LD_EXP 93
56788: PPUSH
56789: LD_VAR 0 4
56793: PPUSH
56794: EMPTY
56795: PPUSH
56796: CALL_OW 1
56800: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56801: LD_ADDR_EXP 94
56805: PUSH
56806: LD_EXP 94
56810: PPUSH
56811: LD_VAR 0 4
56815: PPUSH
56816: EMPTY
56817: PPUSH
56818: CALL_OW 1
56822: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56823: LD_ADDR_EXP 95
56827: PUSH
56828: LD_EXP 95
56832: PPUSH
56833: LD_VAR 0 4
56837: PPUSH
56838: EMPTY
56839: PPUSH
56840: CALL_OW 1
56844: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56845: LD_ADDR_EXP 96
56849: PUSH
56850: LD_EXP 96
56854: PPUSH
56855: LD_VAR 0 4
56859: PPUSH
56860: EMPTY
56861: PPUSH
56862: CALL_OW 1
56866: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56867: LD_ADDR_EXP 97
56871: PUSH
56872: LD_EXP 97
56876: PPUSH
56877: LD_VAR 0 4
56881: PPUSH
56882: EMPTY
56883: PPUSH
56884: CALL_OW 1
56888: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56889: LD_ADDR_EXP 98
56893: PUSH
56894: LD_EXP 98
56898: PPUSH
56899: LD_VAR 0 4
56903: PPUSH
56904: EMPTY
56905: PPUSH
56906: CALL_OW 1
56910: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56911: LD_ADDR_EXP 99
56915: PUSH
56916: LD_EXP 99
56920: PPUSH
56921: LD_VAR 0 4
56925: PPUSH
56926: EMPTY
56927: PPUSH
56928: CALL_OW 1
56932: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56933: LD_ADDR_EXP 100
56937: PUSH
56938: LD_EXP 100
56942: PPUSH
56943: LD_VAR 0 4
56947: PPUSH
56948: EMPTY
56949: PPUSH
56950: CALL_OW 1
56954: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56955: LD_ADDR_EXP 101
56959: PUSH
56960: LD_EXP 101
56964: PPUSH
56965: LD_VAR 0 4
56969: PPUSH
56970: EMPTY
56971: PPUSH
56972: CALL_OW 1
56976: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56977: LD_ADDR_EXP 102
56981: PUSH
56982: LD_EXP 102
56986: PPUSH
56987: LD_VAR 0 4
56991: PPUSH
56992: LD_INT 0
56994: PPUSH
56995: CALL_OW 1
56999: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57000: LD_ADDR_EXP 103
57004: PUSH
57005: LD_EXP 103
57009: PPUSH
57010: LD_VAR 0 4
57014: PPUSH
57015: LD_INT 0
57017: PPUSH
57018: CALL_OW 1
57022: ST_TO_ADDR
// result := base ;
57023: LD_ADDR_VAR 0 3
57027: PUSH
57028: LD_VAR 0 4
57032: ST_TO_ADDR
// end ;
57033: LD_VAR 0 3
57037: RET
// export function MC_Start ( ) ; var i ; begin
57038: LD_INT 0
57040: PPUSH
57041: PPUSH
// for i = 1 to mc_bases do
57042: LD_ADDR_VAR 0 2
57046: PUSH
57047: DOUBLE
57048: LD_INT 1
57050: DEC
57051: ST_TO_ADDR
57052: LD_EXP 60
57056: PUSH
57057: FOR_TO
57058: IFFALSE 58158
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57060: LD_ADDR_EXP 60
57064: PUSH
57065: LD_EXP 60
57069: PPUSH
57070: LD_VAR 0 2
57074: PPUSH
57075: LD_EXP 60
57079: PUSH
57080: LD_VAR 0 2
57084: ARRAY
57085: PUSH
57086: LD_INT 0
57088: DIFF
57089: PPUSH
57090: CALL_OW 1
57094: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57095: LD_ADDR_EXP 61
57099: PUSH
57100: LD_EXP 61
57104: PPUSH
57105: LD_VAR 0 2
57109: PPUSH
57110: EMPTY
57111: PPUSH
57112: CALL_OW 1
57116: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57117: LD_ADDR_EXP 62
57121: PUSH
57122: LD_EXP 62
57126: PPUSH
57127: LD_VAR 0 2
57131: PPUSH
57132: EMPTY
57133: PPUSH
57134: CALL_OW 1
57138: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57139: LD_ADDR_EXP 63
57143: PUSH
57144: LD_EXP 63
57148: PPUSH
57149: LD_VAR 0 2
57153: PPUSH
57154: EMPTY
57155: PPUSH
57156: CALL_OW 1
57160: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57161: LD_ADDR_EXP 64
57165: PUSH
57166: LD_EXP 64
57170: PPUSH
57171: LD_VAR 0 2
57175: PPUSH
57176: EMPTY
57177: PUSH
57178: EMPTY
57179: PUSH
57180: EMPTY
57181: LIST
57182: LIST
57183: PPUSH
57184: CALL_OW 1
57188: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57189: LD_ADDR_EXP 65
57193: PUSH
57194: LD_EXP 65
57198: PPUSH
57199: LD_VAR 0 2
57203: PPUSH
57204: EMPTY
57205: PPUSH
57206: CALL_OW 1
57210: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57211: LD_ADDR_EXP 92
57215: PUSH
57216: LD_EXP 92
57220: PPUSH
57221: LD_VAR 0 2
57225: PPUSH
57226: EMPTY
57227: PPUSH
57228: CALL_OW 1
57232: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57233: LD_ADDR_EXP 66
57237: PUSH
57238: LD_EXP 66
57242: PPUSH
57243: LD_VAR 0 2
57247: PPUSH
57248: EMPTY
57249: PPUSH
57250: CALL_OW 1
57254: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57255: LD_ADDR_EXP 67
57259: PUSH
57260: LD_EXP 67
57264: PPUSH
57265: LD_VAR 0 2
57269: PPUSH
57270: EMPTY
57271: PPUSH
57272: CALL_OW 1
57276: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57277: LD_ADDR_EXP 68
57281: PUSH
57282: LD_EXP 68
57286: PPUSH
57287: LD_VAR 0 2
57291: PPUSH
57292: LD_EXP 60
57296: PUSH
57297: LD_VAR 0 2
57301: ARRAY
57302: PPUSH
57303: LD_INT 2
57305: PUSH
57306: LD_INT 30
57308: PUSH
57309: LD_INT 32
57311: PUSH
57312: EMPTY
57313: LIST
57314: LIST
57315: PUSH
57316: LD_INT 30
57318: PUSH
57319: LD_INT 33
57321: PUSH
57322: EMPTY
57323: LIST
57324: LIST
57325: PUSH
57326: EMPTY
57327: LIST
57328: LIST
57329: LIST
57330: PPUSH
57331: CALL_OW 72
57335: PPUSH
57336: CALL_OW 1
57340: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57341: LD_ADDR_EXP 69
57345: PUSH
57346: LD_EXP 69
57350: PPUSH
57351: LD_VAR 0 2
57355: PPUSH
57356: LD_EXP 60
57360: PUSH
57361: LD_VAR 0 2
57365: ARRAY
57366: PPUSH
57367: LD_INT 2
57369: PUSH
57370: LD_INT 30
57372: PUSH
57373: LD_INT 32
57375: PUSH
57376: EMPTY
57377: LIST
57378: LIST
57379: PUSH
57380: LD_INT 30
57382: PUSH
57383: LD_INT 31
57385: PUSH
57386: EMPTY
57387: LIST
57388: LIST
57389: PUSH
57390: EMPTY
57391: LIST
57392: LIST
57393: LIST
57394: PUSH
57395: LD_INT 58
57397: PUSH
57398: EMPTY
57399: LIST
57400: PUSH
57401: EMPTY
57402: LIST
57403: LIST
57404: PPUSH
57405: CALL_OW 72
57409: PPUSH
57410: CALL_OW 1
57414: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57415: LD_ADDR_EXP 70
57419: PUSH
57420: LD_EXP 70
57424: PPUSH
57425: LD_VAR 0 2
57429: PPUSH
57430: EMPTY
57431: PPUSH
57432: CALL_OW 1
57436: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57437: LD_ADDR_EXP 74
57441: PUSH
57442: LD_EXP 74
57446: PPUSH
57447: LD_VAR 0 2
57451: PPUSH
57452: EMPTY
57453: PPUSH
57454: CALL_OW 1
57458: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57459: LD_ADDR_EXP 73
57463: PUSH
57464: LD_EXP 73
57468: PPUSH
57469: LD_VAR 0 2
57473: PPUSH
57474: EMPTY
57475: PPUSH
57476: CALL_OW 1
57480: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57481: LD_ADDR_EXP 75
57485: PUSH
57486: LD_EXP 75
57490: PPUSH
57491: LD_VAR 0 2
57495: PPUSH
57496: EMPTY
57497: PPUSH
57498: CALL_OW 1
57502: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57503: LD_ADDR_EXP 76
57507: PUSH
57508: LD_EXP 76
57512: PPUSH
57513: LD_VAR 0 2
57517: PPUSH
57518: EMPTY
57519: PPUSH
57520: CALL_OW 1
57524: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57525: LD_ADDR_EXP 77
57529: PUSH
57530: LD_EXP 77
57534: PPUSH
57535: LD_VAR 0 2
57539: PPUSH
57540: EMPTY
57541: PPUSH
57542: CALL_OW 1
57546: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57547: LD_ADDR_EXP 78
57551: PUSH
57552: LD_EXP 78
57556: PPUSH
57557: LD_VAR 0 2
57561: PPUSH
57562: EMPTY
57563: PPUSH
57564: CALL_OW 1
57568: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57569: LD_ADDR_EXP 79
57573: PUSH
57574: LD_EXP 79
57578: PPUSH
57579: LD_VAR 0 2
57583: PPUSH
57584: EMPTY
57585: PPUSH
57586: CALL_OW 1
57590: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57591: LD_ADDR_EXP 80
57595: PUSH
57596: LD_EXP 80
57600: PPUSH
57601: LD_VAR 0 2
57605: PPUSH
57606: EMPTY
57607: PPUSH
57608: CALL_OW 1
57612: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57613: LD_ADDR_EXP 81
57617: PUSH
57618: LD_EXP 81
57622: PPUSH
57623: LD_VAR 0 2
57627: PPUSH
57628: EMPTY
57629: PPUSH
57630: CALL_OW 1
57634: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57635: LD_ADDR_EXP 82
57639: PUSH
57640: LD_EXP 82
57644: PPUSH
57645: LD_VAR 0 2
57649: PPUSH
57650: EMPTY
57651: PPUSH
57652: CALL_OW 1
57656: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57657: LD_ADDR_EXP 71
57661: PUSH
57662: LD_EXP 71
57666: PPUSH
57667: LD_VAR 0 2
57671: PPUSH
57672: LD_INT 0
57674: PPUSH
57675: CALL_OW 1
57679: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57680: LD_ADDR_EXP 84
57684: PUSH
57685: LD_EXP 84
57689: PPUSH
57690: LD_VAR 0 2
57694: PPUSH
57695: LD_INT 0
57697: PPUSH
57698: CALL_OW 1
57702: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57703: LD_ADDR_EXP 72
57707: PUSH
57708: LD_EXP 72
57712: PPUSH
57713: LD_VAR 0 2
57717: PPUSH
57718: EMPTY
57719: PPUSH
57720: CALL_OW 1
57724: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57725: LD_ADDR_EXP 83
57729: PUSH
57730: LD_EXP 83
57734: PPUSH
57735: LD_VAR 0 2
57739: PPUSH
57740: LD_INT 0
57742: PPUSH
57743: CALL_OW 1
57747: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57748: LD_ADDR_EXP 85
57752: PUSH
57753: LD_EXP 85
57757: PPUSH
57758: LD_VAR 0 2
57762: PPUSH
57763: EMPTY
57764: PPUSH
57765: CALL_OW 1
57769: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57770: LD_ADDR_EXP 88
57774: PUSH
57775: LD_EXP 88
57779: PPUSH
57780: LD_VAR 0 2
57784: PPUSH
57785: LD_INT 0
57787: PPUSH
57788: CALL_OW 1
57792: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57793: LD_ADDR_EXP 89
57797: PUSH
57798: LD_EXP 89
57802: PPUSH
57803: LD_VAR 0 2
57807: PPUSH
57808: EMPTY
57809: PPUSH
57810: CALL_OW 1
57814: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57815: LD_ADDR_EXP 90
57819: PUSH
57820: LD_EXP 90
57824: PPUSH
57825: LD_VAR 0 2
57829: PPUSH
57830: EMPTY
57831: PPUSH
57832: CALL_OW 1
57836: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57837: LD_ADDR_EXP 91
57841: PUSH
57842: LD_EXP 91
57846: PPUSH
57847: LD_VAR 0 2
57851: PPUSH
57852: EMPTY
57853: PPUSH
57854: CALL_OW 1
57858: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57859: LD_ADDR_EXP 93
57863: PUSH
57864: LD_EXP 93
57868: PPUSH
57869: LD_VAR 0 2
57873: PPUSH
57874: LD_EXP 60
57878: PUSH
57879: LD_VAR 0 2
57883: ARRAY
57884: PPUSH
57885: LD_INT 2
57887: PUSH
57888: LD_INT 30
57890: PUSH
57891: LD_INT 6
57893: PUSH
57894: EMPTY
57895: LIST
57896: LIST
57897: PUSH
57898: LD_INT 30
57900: PUSH
57901: LD_INT 7
57903: PUSH
57904: EMPTY
57905: LIST
57906: LIST
57907: PUSH
57908: LD_INT 30
57910: PUSH
57911: LD_INT 8
57913: PUSH
57914: EMPTY
57915: LIST
57916: LIST
57917: PUSH
57918: EMPTY
57919: LIST
57920: LIST
57921: LIST
57922: LIST
57923: PPUSH
57924: CALL_OW 72
57928: PPUSH
57929: CALL_OW 1
57933: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
57934: LD_ADDR_EXP 94
57938: PUSH
57939: LD_EXP 94
57943: PPUSH
57944: LD_VAR 0 2
57948: PPUSH
57949: EMPTY
57950: PPUSH
57951: CALL_OW 1
57955: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57956: LD_ADDR_EXP 95
57960: PUSH
57961: LD_EXP 95
57965: PPUSH
57966: LD_VAR 0 2
57970: PPUSH
57971: EMPTY
57972: PPUSH
57973: CALL_OW 1
57977: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
57978: LD_ADDR_EXP 96
57982: PUSH
57983: LD_EXP 96
57987: PPUSH
57988: LD_VAR 0 2
57992: PPUSH
57993: EMPTY
57994: PPUSH
57995: CALL_OW 1
57999: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58000: LD_ADDR_EXP 97
58004: PUSH
58005: LD_EXP 97
58009: PPUSH
58010: LD_VAR 0 2
58014: PPUSH
58015: EMPTY
58016: PPUSH
58017: CALL_OW 1
58021: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58022: LD_ADDR_EXP 98
58026: PUSH
58027: LD_EXP 98
58031: PPUSH
58032: LD_VAR 0 2
58036: PPUSH
58037: EMPTY
58038: PPUSH
58039: CALL_OW 1
58043: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58044: LD_ADDR_EXP 99
58048: PUSH
58049: LD_EXP 99
58053: PPUSH
58054: LD_VAR 0 2
58058: PPUSH
58059: EMPTY
58060: PPUSH
58061: CALL_OW 1
58065: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58066: LD_ADDR_EXP 100
58070: PUSH
58071: LD_EXP 100
58075: PPUSH
58076: LD_VAR 0 2
58080: PPUSH
58081: EMPTY
58082: PPUSH
58083: CALL_OW 1
58087: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58088: LD_ADDR_EXP 101
58092: PUSH
58093: LD_EXP 101
58097: PPUSH
58098: LD_VAR 0 2
58102: PPUSH
58103: EMPTY
58104: PPUSH
58105: CALL_OW 1
58109: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58110: LD_ADDR_EXP 102
58114: PUSH
58115: LD_EXP 102
58119: PPUSH
58120: LD_VAR 0 2
58124: PPUSH
58125: LD_INT 0
58127: PPUSH
58128: CALL_OW 1
58132: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
58133: LD_ADDR_EXP 103
58137: PUSH
58138: LD_EXP 103
58142: PPUSH
58143: LD_VAR 0 2
58147: PPUSH
58148: LD_INT 0
58150: PPUSH
58151: CALL_OW 1
58155: ST_TO_ADDR
// end ;
58156: GO 57057
58158: POP
58159: POP
// MC_InitSides ( ) ;
58160: CALL 58446 0 0
// MC_InitResearch ( ) ;
58164: CALL 58185 0 0
// CustomInitMacro ( ) ;
58168: CALL 206 0 0
// skirmish := true ;
58172: LD_ADDR_EXP 58
58176: PUSH
58177: LD_INT 1
58179: ST_TO_ADDR
// end ;
58180: LD_VAR 0 1
58184: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58185: LD_INT 0
58187: PPUSH
58188: PPUSH
58189: PPUSH
58190: PPUSH
58191: PPUSH
58192: PPUSH
// if not mc_bases then
58193: LD_EXP 60
58197: NOT
58198: IFFALSE 58202
// exit ;
58200: GO 58441
// for i = 1 to 8 do
58202: LD_ADDR_VAR 0 2
58206: PUSH
58207: DOUBLE
58208: LD_INT 1
58210: DEC
58211: ST_TO_ADDR
58212: LD_INT 8
58214: PUSH
58215: FOR_TO
58216: IFFALSE 58242
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58218: LD_ADDR_EXP 87
58222: PUSH
58223: LD_EXP 87
58227: PPUSH
58228: LD_VAR 0 2
58232: PPUSH
58233: EMPTY
58234: PPUSH
58235: CALL_OW 1
58239: ST_TO_ADDR
58240: GO 58215
58242: POP
58243: POP
// tmp := [ ] ;
58244: LD_ADDR_VAR 0 5
58248: PUSH
58249: EMPTY
58250: ST_TO_ADDR
// for i = 1 to mc_sides do
58251: LD_ADDR_VAR 0 2
58255: PUSH
58256: DOUBLE
58257: LD_INT 1
58259: DEC
58260: ST_TO_ADDR
58261: LD_EXP 86
58265: PUSH
58266: FOR_TO
58267: IFFALSE 58325
// if not mc_sides [ i ] in tmp then
58269: LD_EXP 86
58273: PUSH
58274: LD_VAR 0 2
58278: ARRAY
58279: PUSH
58280: LD_VAR 0 5
58284: IN
58285: NOT
58286: IFFALSE 58323
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58288: LD_ADDR_VAR 0 5
58292: PUSH
58293: LD_VAR 0 5
58297: PPUSH
58298: LD_VAR 0 5
58302: PUSH
58303: LD_INT 1
58305: PLUS
58306: PPUSH
58307: LD_EXP 86
58311: PUSH
58312: LD_VAR 0 2
58316: ARRAY
58317: PPUSH
58318: CALL_OW 2
58322: ST_TO_ADDR
58323: GO 58266
58325: POP
58326: POP
// if not tmp then
58327: LD_VAR 0 5
58331: NOT
58332: IFFALSE 58336
// exit ;
58334: GO 58441
// for j in tmp do
58336: LD_ADDR_VAR 0 3
58340: PUSH
58341: LD_VAR 0 5
58345: PUSH
58346: FOR_IN
58347: IFFALSE 58439
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58349: LD_ADDR_VAR 0 6
58353: PUSH
58354: LD_INT 22
58356: PUSH
58357: LD_VAR 0 3
58361: PUSH
58362: EMPTY
58363: LIST
58364: LIST
58365: PPUSH
58366: CALL_OW 69
58370: ST_TO_ADDR
// if not un then
58371: LD_VAR 0 6
58375: NOT
58376: IFFALSE 58380
// continue ;
58378: GO 58346
// nation := GetNation ( un [ 1 ] ) ;
58380: LD_ADDR_VAR 0 4
58384: PUSH
58385: LD_VAR 0 6
58389: PUSH
58390: LD_INT 1
58392: ARRAY
58393: PPUSH
58394: CALL_OW 248
58398: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58399: LD_ADDR_EXP 87
58403: PUSH
58404: LD_EXP 87
58408: PPUSH
58409: LD_VAR 0 3
58413: PPUSH
58414: LD_VAR 0 3
58418: PPUSH
58419: LD_VAR 0 4
58423: PPUSH
58424: LD_INT 1
58426: PPUSH
58427: CALL 14901 0 3
58431: PPUSH
58432: CALL_OW 1
58436: ST_TO_ADDR
// end ;
58437: GO 58346
58439: POP
58440: POP
// end ;
58441: LD_VAR 0 1
58445: RET
// export function MC_InitSides ( ) ; var i ; begin
58446: LD_INT 0
58448: PPUSH
58449: PPUSH
// if not mc_bases then
58450: LD_EXP 60
58454: NOT
58455: IFFALSE 58459
// exit ;
58457: GO 58533
// for i = 1 to mc_bases do
58459: LD_ADDR_VAR 0 2
58463: PUSH
58464: DOUBLE
58465: LD_INT 1
58467: DEC
58468: ST_TO_ADDR
58469: LD_EXP 60
58473: PUSH
58474: FOR_TO
58475: IFFALSE 58531
// if mc_bases [ i ] then
58477: LD_EXP 60
58481: PUSH
58482: LD_VAR 0 2
58486: ARRAY
58487: IFFALSE 58529
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58489: LD_ADDR_EXP 86
58493: PUSH
58494: LD_EXP 86
58498: PPUSH
58499: LD_VAR 0 2
58503: PPUSH
58504: LD_EXP 60
58508: PUSH
58509: LD_VAR 0 2
58513: ARRAY
58514: PUSH
58515: LD_INT 1
58517: ARRAY
58518: PPUSH
58519: CALL_OW 255
58523: PPUSH
58524: CALL_OW 1
58528: ST_TO_ADDR
58529: GO 58474
58531: POP
58532: POP
// end ;
58533: LD_VAR 0 1
58537: RET
// every 0 0$03 trigger skirmish do
58538: LD_EXP 58
58542: IFFALSE 58696
58544: GO 58546
58546: DISABLE
// begin enable ;
58547: ENABLE
// MC_CheckBuildings ( ) ;
58548: CALL 63194 0 0
// MC_CheckPeopleLife ( ) ;
58552: CALL 63355 0 0
// RaiseSailEvent ( 100 ) ;
58556: LD_INT 100
58558: PPUSH
58559: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58563: LD_INT 103
58565: PPUSH
58566: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58570: LD_INT 104
58572: PPUSH
58573: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58577: LD_INT 105
58579: PPUSH
58580: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58584: LD_INT 106
58586: PPUSH
58587: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58591: LD_INT 107
58593: PPUSH
58594: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58598: LD_INT 108
58600: PPUSH
58601: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58605: LD_INT 109
58607: PPUSH
58608: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58612: LD_INT 110
58614: PPUSH
58615: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58619: LD_INT 111
58621: PPUSH
58622: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58626: LD_INT 112
58628: PPUSH
58629: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58633: LD_INT 113
58635: PPUSH
58636: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58640: LD_INT 120
58642: PPUSH
58643: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58647: LD_INT 121
58649: PPUSH
58650: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58654: LD_INT 122
58656: PPUSH
58657: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58661: LD_INT 123
58663: PPUSH
58664: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58668: LD_INT 124
58670: PPUSH
58671: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58675: LD_INT 125
58677: PPUSH
58678: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58682: LD_INT 126
58684: PPUSH
58685: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58689: LD_INT 200
58691: PPUSH
58692: CALL_OW 427
// end ;
58696: END
// on SailEvent ( event ) do begin if event < 100 then
58697: LD_VAR 0 1
58701: PUSH
58702: LD_INT 100
58704: LESS
58705: IFFALSE 58716
// CustomEvent ( event ) ;
58707: LD_VAR 0 1
58711: PPUSH
58712: CALL 13516 0 1
// if event = 100 then
58716: LD_VAR 0 1
58720: PUSH
58721: LD_INT 100
58723: EQUAL
58724: IFFALSE 58730
// MC_ClassManager ( ) ;
58726: CALL 59122 0 0
// if event = 101 then
58730: LD_VAR 0 1
58734: PUSH
58735: LD_INT 101
58737: EQUAL
58738: IFFALSE 58744
// MC_RepairBuildings ( ) ;
58740: CALL 63940 0 0
// if event = 102 then
58744: LD_VAR 0 1
58748: PUSH
58749: LD_INT 102
58751: EQUAL
58752: IFFALSE 58758
// MC_Heal ( ) ;
58754: CALL 64847 0 0
// if event = 103 then
58758: LD_VAR 0 1
58762: PUSH
58763: LD_INT 103
58765: EQUAL
58766: IFFALSE 58772
// MC_Build ( ) ;
58768: CALL 65269 0 0
// if event = 104 then
58772: LD_VAR 0 1
58776: PUSH
58777: LD_INT 104
58779: EQUAL
58780: IFFALSE 58786
// MC_TurretWeapon ( ) ;
58782: CALL 66910 0 0
// if event = 105 then
58786: LD_VAR 0 1
58790: PUSH
58791: LD_INT 105
58793: EQUAL
58794: IFFALSE 58800
// MC_BuildUpgrade ( ) ;
58796: CALL 66461 0 0
// if event = 106 then
58800: LD_VAR 0 1
58804: PUSH
58805: LD_INT 106
58807: EQUAL
58808: IFFALSE 58814
// MC_PlantMines ( ) ;
58810: CALL 67340 0 0
// if event = 107 then
58814: LD_VAR 0 1
58818: PUSH
58819: LD_INT 107
58821: EQUAL
58822: IFFALSE 58828
// MC_CollectCrates ( ) ;
58824: CALL 68131 0 0
// if event = 108 then
58828: LD_VAR 0 1
58832: PUSH
58833: LD_INT 108
58835: EQUAL
58836: IFFALSE 58842
// MC_LinkRemoteControl ( ) ;
58838: CALL 69981 0 0
// if event = 109 then
58842: LD_VAR 0 1
58846: PUSH
58847: LD_INT 109
58849: EQUAL
58850: IFFALSE 58856
// MC_ProduceVehicle ( ) ;
58852: CALL 70162 0 0
// if event = 110 then
58856: LD_VAR 0 1
58860: PUSH
58861: LD_INT 110
58863: EQUAL
58864: IFFALSE 58870
// MC_SendAttack ( ) ;
58866: CALL 70628 0 0
// if event = 111 then
58870: LD_VAR 0 1
58874: PUSH
58875: LD_INT 111
58877: EQUAL
58878: IFFALSE 58884
// MC_Defend ( ) ;
58880: CALL 70736 0 0
// if event = 112 then
58884: LD_VAR 0 1
58888: PUSH
58889: LD_INT 112
58891: EQUAL
58892: IFFALSE 58898
// MC_Research ( ) ;
58894: CALL 71616 0 0
// if event = 113 then
58898: LD_VAR 0 1
58902: PUSH
58903: LD_INT 113
58905: EQUAL
58906: IFFALSE 58912
// MC_MinesTrigger ( ) ;
58908: CALL 72730 0 0
// if event = 120 then
58912: LD_VAR 0 1
58916: PUSH
58917: LD_INT 120
58919: EQUAL
58920: IFFALSE 58926
// MC_RepairVehicle ( ) ;
58922: CALL 72829 0 0
// if event = 121 then
58926: LD_VAR 0 1
58930: PUSH
58931: LD_INT 121
58933: EQUAL
58934: IFFALSE 58940
// MC_TameApe ( ) ;
58936: CALL 73570 0 0
// if event = 122 then
58940: LD_VAR 0 1
58944: PUSH
58945: LD_INT 122
58947: EQUAL
58948: IFFALSE 58954
// MC_ChangeApeClass ( ) ;
58950: CALL 74399 0 0
// if event = 123 then
58954: LD_VAR 0 1
58958: PUSH
58959: LD_INT 123
58961: EQUAL
58962: IFFALSE 58968
// MC_Bazooka ( ) ;
58964: CALL 75049 0 0
// if event = 124 then
58968: LD_VAR 0 1
58972: PUSH
58973: LD_INT 124
58975: EQUAL
58976: IFFALSE 58982
// MC_TeleportExit ( ) ;
58978: CALL 75247 0 0
// if event = 125 then
58982: LD_VAR 0 1
58986: PUSH
58987: LD_INT 125
58989: EQUAL
58990: IFFALSE 58996
// MC_Deposits ( ) ;
58992: CALL 75894 0 0
// if event = 126 then
58996: LD_VAR 0 1
59000: PUSH
59001: LD_INT 126
59003: EQUAL
59004: IFFALSE 59010
// MC_RemoteDriver ( ) ;
59006: CALL 76519 0 0
// if event = 200 then
59010: LD_VAR 0 1
59014: PUSH
59015: LD_INT 200
59017: EQUAL
59018: IFFALSE 59024
// MC_Idle ( ) ;
59020: CALL 78468 0 0
// end ;
59024: PPOPN 1
59026: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59027: LD_INT 0
59029: PPUSH
59030: PPUSH
// if not mc_bases [ base ] or not tag then
59031: LD_EXP 60
59035: PUSH
59036: LD_VAR 0 1
59040: ARRAY
59041: NOT
59042: PUSH
59043: LD_VAR 0 2
59047: NOT
59048: OR
59049: IFFALSE 59053
// exit ;
59051: GO 59117
// for i in mc_bases [ base ] union mc_ape [ base ] do
59053: LD_ADDR_VAR 0 4
59057: PUSH
59058: LD_EXP 60
59062: PUSH
59063: LD_VAR 0 1
59067: ARRAY
59068: PUSH
59069: LD_EXP 89
59073: PUSH
59074: LD_VAR 0 1
59078: ARRAY
59079: UNION
59080: PUSH
59081: FOR_IN
59082: IFFALSE 59115
// if GetTag ( i ) = tag then
59084: LD_VAR 0 4
59088: PPUSH
59089: CALL_OW 110
59093: PUSH
59094: LD_VAR 0 2
59098: EQUAL
59099: IFFALSE 59113
// SetTag ( i , 0 ) ;
59101: LD_VAR 0 4
59105: PPUSH
59106: LD_INT 0
59108: PPUSH
59109: CALL_OW 109
59113: GO 59081
59115: POP
59116: POP
// end ;
59117: LD_VAR 0 3
59121: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59122: LD_INT 0
59124: PPUSH
59125: PPUSH
59126: PPUSH
59127: PPUSH
59128: PPUSH
59129: PPUSH
59130: PPUSH
59131: PPUSH
// if not mc_bases then
59132: LD_EXP 60
59136: NOT
59137: IFFALSE 59141
// exit ;
59139: GO 59599
// for i = 1 to mc_bases do
59141: LD_ADDR_VAR 0 2
59145: PUSH
59146: DOUBLE
59147: LD_INT 1
59149: DEC
59150: ST_TO_ADDR
59151: LD_EXP 60
59155: PUSH
59156: FOR_TO
59157: IFFALSE 59597
// begin tmp := MC_ClassCheckReq ( i ) ;
59159: LD_ADDR_VAR 0 4
59163: PUSH
59164: LD_VAR 0 2
59168: PPUSH
59169: CALL 59604 0 1
59173: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59174: LD_ADDR_EXP 101
59178: PUSH
59179: LD_EXP 101
59183: PPUSH
59184: LD_VAR 0 2
59188: PPUSH
59189: LD_VAR 0 4
59193: PPUSH
59194: CALL_OW 1
59198: ST_TO_ADDR
// if not tmp then
59199: LD_VAR 0 4
59203: NOT
59204: IFFALSE 59208
// continue ;
59206: GO 59156
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59208: LD_ADDR_VAR 0 6
59212: PUSH
59213: LD_EXP 60
59217: PUSH
59218: LD_VAR 0 2
59222: ARRAY
59223: PPUSH
59224: LD_INT 2
59226: PUSH
59227: LD_INT 30
59229: PUSH
59230: LD_INT 4
59232: PUSH
59233: EMPTY
59234: LIST
59235: LIST
59236: PUSH
59237: LD_INT 30
59239: PUSH
59240: LD_INT 5
59242: PUSH
59243: EMPTY
59244: LIST
59245: LIST
59246: PUSH
59247: EMPTY
59248: LIST
59249: LIST
59250: LIST
59251: PPUSH
59252: CALL_OW 72
59256: PUSH
59257: LD_EXP 60
59261: PUSH
59262: LD_VAR 0 2
59266: ARRAY
59267: PPUSH
59268: LD_INT 2
59270: PUSH
59271: LD_INT 30
59273: PUSH
59274: LD_INT 0
59276: PUSH
59277: EMPTY
59278: LIST
59279: LIST
59280: PUSH
59281: LD_INT 30
59283: PUSH
59284: LD_INT 1
59286: PUSH
59287: EMPTY
59288: LIST
59289: LIST
59290: PUSH
59291: EMPTY
59292: LIST
59293: LIST
59294: LIST
59295: PPUSH
59296: CALL_OW 72
59300: PUSH
59301: LD_EXP 60
59305: PUSH
59306: LD_VAR 0 2
59310: ARRAY
59311: PPUSH
59312: LD_INT 30
59314: PUSH
59315: LD_INT 3
59317: PUSH
59318: EMPTY
59319: LIST
59320: LIST
59321: PPUSH
59322: CALL_OW 72
59326: PUSH
59327: LD_EXP 60
59331: PUSH
59332: LD_VAR 0 2
59336: ARRAY
59337: PPUSH
59338: LD_INT 2
59340: PUSH
59341: LD_INT 30
59343: PUSH
59344: LD_INT 6
59346: PUSH
59347: EMPTY
59348: LIST
59349: LIST
59350: PUSH
59351: LD_INT 30
59353: PUSH
59354: LD_INT 7
59356: PUSH
59357: EMPTY
59358: LIST
59359: LIST
59360: PUSH
59361: LD_INT 30
59363: PUSH
59364: LD_INT 8
59366: PUSH
59367: EMPTY
59368: LIST
59369: LIST
59370: PUSH
59371: EMPTY
59372: LIST
59373: LIST
59374: LIST
59375: LIST
59376: PPUSH
59377: CALL_OW 72
59381: PUSH
59382: EMPTY
59383: LIST
59384: LIST
59385: LIST
59386: LIST
59387: ST_TO_ADDR
// for j = 1 to 4 do
59388: LD_ADDR_VAR 0 3
59392: PUSH
59393: DOUBLE
59394: LD_INT 1
59396: DEC
59397: ST_TO_ADDR
59398: LD_INT 4
59400: PUSH
59401: FOR_TO
59402: IFFALSE 59593
// begin if not tmp [ j ] then
59404: LD_VAR 0 4
59408: PUSH
59409: LD_VAR 0 3
59413: ARRAY
59414: NOT
59415: IFFALSE 59419
// continue ;
59417: GO 59401
// for p in tmp [ j ] do
59419: LD_ADDR_VAR 0 5
59423: PUSH
59424: LD_VAR 0 4
59428: PUSH
59429: LD_VAR 0 3
59433: ARRAY
59434: PUSH
59435: FOR_IN
59436: IFFALSE 59589
// begin if not b [ j ] then
59438: LD_VAR 0 6
59442: PUSH
59443: LD_VAR 0 3
59447: ARRAY
59448: NOT
59449: IFFALSE 59453
// break ;
59451: GO 59589
// e := 0 ;
59453: LD_ADDR_VAR 0 7
59457: PUSH
59458: LD_INT 0
59460: ST_TO_ADDR
// for k in b [ j ] do
59461: LD_ADDR_VAR 0 8
59465: PUSH
59466: LD_VAR 0 6
59470: PUSH
59471: LD_VAR 0 3
59475: ARRAY
59476: PUSH
59477: FOR_IN
59478: IFFALSE 59505
// if IsNotFull ( k ) then
59480: LD_VAR 0 8
59484: PPUSH
59485: CALL 17054 0 1
59489: IFFALSE 59503
// begin e := k ;
59491: LD_ADDR_VAR 0 7
59495: PUSH
59496: LD_VAR 0 8
59500: ST_TO_ADDR
// break ;
59501: GO 59505
// end ;
59503: GO 59477
59505: POP
59506: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59507: LD_VAR 0 7
59511: PUSH
59512: LD_VAR 0 5
59516: PPUSH
59517: LD_VAR 0 7
59521: PPUSH
59522: CALL 50165 0 2
59526: NOT
59527: AND
59528: IFFALSE 59587
// begin if IsInUnit ( p ) then
59530: LD_VAR 0 5
59534: PPUSH
59535: CALL_OW 310
59539: IFFALSE 59550
// ComExitBuilding ( p ) ;
59541: LD_VAR 0 5
59545: PPUSH
59546: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59550: LD_VAR 0 5
59554: PPUSH
59555: LD_VAR 0 7
59559: PPUSH
59560: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59564: LD_VAR 0 5
59568: PPUSH
59569: LD_VAR 0 3
59573: PPUSH
59574: CALL_OW 183
// AddComExitBuilding ( p ) ;
59578: LD_VAR 0 5
59582: PPUSH
59583: CALL_OW 182
// end ; end ;
59587: GO 59435
59589: POP
59590: POP
// end ;
59591: GO 59401
59593: POP
59594: POP
// end ;
59595: GO 59156
59597: POP
59598: POP
// end ;
59599: LD_VAR 0 1
59603: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59604: LD_INT 0
59606: PPUSH
59607: PPUSH
59608: PPUSH
59609: PPUSH
59610: PPUSH
59611: PPUSH
59612: PPUSH
59613: PPUSH
59614: PPUSH
59615: PPUSH
59616: PPUSH
59617: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59618: LD_VAR 0 1
59622: NOT
59623: PUSH
59624: LD_EXP 60
59628: PUSH
59629: LD_VAR 0 1
59633: ARRAY
59634: NOT
59635: OR
59636: PUSH
59637: LD_EXP 60
59641: PUSH
59642: LD_VAR 0 1
59646: ARRAY
59647: PPUSH
59648: LD_INT 2
59650: PUSH
59651: LD_INT 30
59653: PUSH
59654: LD_INT 0
59656: PUSH
59657: EMPTY
59658: LIST
59659: LIST
59660: PUSH
59661: LD_INT 30
59663: PUSH
59664: LD_INT 1
59666: PUSH
59667: EMPTY
59668: LIST
59669: LIST
59670: PUSH
59671: EMPTY
59672: LIST
59673: LIST
59674: LIST
59675: PPUSH
59676: CALL_OW 72
59680: NOT
59681: OR
59682: IFFALSE 59686
// exit ;
59684: GO 63189
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59686: LD_ADDR_VAR 0 4
59690: PUSH
59691: LD_EXP 60
59695: PUSH
59696: LD_VAR 0 1
59700: ARRAY
59701: PPUSH
59702: LD_INT 2
59704: PUSH
59705: LD_INT 25
59707: PUSH
59708: LD_INT 1
59710: PUSH
59711: EMPTY
59712: LIST
59713: LIST
59714: PUSH
59715: LD_INT 25
59717: PUSH
59718: LD_INT 2
59720: PUSH
59721: EMPTY
59722: LIST
59723: LIST
59724: PUSH
59725: LD_INT 25
59727: PUSH
59728: LD_INT 3
59730: PUSH
59731: EMPTY
59732: LIST
59733: LIST
59734: PUSH
59735: LD_INT 25
59737: PUSH
59738: LD_INT 4
59740: PUSH
59741: EMPTY
59742: LIST
59743: LIST
59744: PUSH
59745: LD_INT 25
59747: PUSH
59748: LD_INT 5
59750: PUSH
59751: EMPTY
59752: LIST
59753: LIST
59754: PUSH
59755: LD_INT 25
59757: PUSH
59758: LD_INT 8
59760: PUSH
59761: EMPTY
59762: LIST
59763: LIST
59764: PUSH
59765: LD_INT 25
59767: PUSH
59768: LD_INT 9
59770: PUSH
59771: EMPTY
59772: LIST
59773: LIST
59774: PUSH
59775: EMPTY
59776: LIST
59777: LIST
59778: LIST
59779: LIST
59780: LIST
59781: LIST
59782: LIST
59783: LIST
59784: PPUSH
59785: CALL_OW 72
59789: ST_TO_ADDR
// if not tmp then
59790: LD_VAR 0 4
59794: NOT
59795: IFFALSE 59799
// exit ;
59797: GO 63189
// for i in tmp do
59799: LD_ADDR_VAR 0 3
59803: PUSH
59804: LD_VAR 0 4
59808: PUSH
59809: FOR_IN
59810: IFFALSE 59841
// if GetTag ( i ) then
59812: LD_VAR 0 3
59816: PPUSH
59817: CALL_OW 110
59821: IFFALSE 59839
// tmp := tmp diff i ;
59823: LD_ADDR_VAR 0 4
59827: PUSH
59828: LD_VAR 0 4
59832: PUSH
59833: LD_VAR 0 3
59837: DIFF
59838: ST_TO_ADDR
59839: GO 59809
59841: POP
59842: POP
// if not tmp then
59843: LD_VAR 0 4
59847: NOT
59848: IFFALSE 59852
// exit ;
59850: GO 63189
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59852: LD_ADDR_VAR 0 5
59856: PUSH
59857: LD_EXP 60
59861: PUSH
59862: LD_VAR 0 1
59866: ARRAY
59867: PPUSH
59868: LD_INT 2
59870: PUSH
59871: LD_INT 25
59873: PUSH
59874: LD_INT 1
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: PUSH
59881: LD_INT 25
59883: PUSH
59884: LD_INT 5
59886: PUSH
59887: EMPTY
59888: LIST
59889: LIST
59890: PUSH
59891: LD_INT 25
59893: PUSH
59894: LD_INT 8
59896: PUSH
59897: EMPTY
59898: LIST
59899: LIST
59900: PUSH
59901: LD_INT 25
59903: PUSH
59904: LD_INT 9
59906: PUSH
59907: EMPTY
59908: LIST
59909: LIST
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: LIST
59915: LIST
59916: LIST
59917: PPUSH
59918: CALL_OW 72
59922: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
59923: LD_ADDR_VAR 0 6
59927: PUSH
59928: LD_EXP 60
59932: PUSH
59933: LD_VAR 0 1
59937: ARRAY
59938: PPUSH
59939: LD_INT 25
59941: PUSH
59942: LD_INT 2
59944: PUSH
59945: EMPTY
59946: LIST
59947: LIST
59948: PPUSH
59949: CALL_OW 72
59953: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59954: LD_ADDR_VAR 0 7
59958: PUSH
59959: LD_EXP 60
59963: PUSH
59964: LD_VAR 0 1
59968: ARRAY
59969: PPUSH
59970: LD_INT 25
59972: PUSH
59973: LD_INT 3
59975: PUSH
59976: EMPTY
59977: LIST
59978: LIST
59979: PPUSH
59980: CALL_OW 72
59984: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
59985: LD_ADDR_VAR 0 8
59989: PUSH
59990: LD_EXP 60
59994: PUSH
59995: LD_VAR 0 1
59999: ARRAY
60000: PPUSH
60001: LD_INT 25
60003: PUSH
60004: LD_INT 4
60006: PUSH
60007: EMPTY
60008: LIST
60009: LIST
60010: PUSH
60011: LD_INT 24
60013: PUSH
60014: LD_INT 251
60016: PUSH
60017: EMPTY
60018: LIST
60019: LIST
60020: PUSH
60021: EMPTY
60022: LIST
60023: LIST
60024: PPUSH
60025: CALL_OW 72
60029: ST_TO_ADDR
// if mc_is_defending [ base ] then
60030: LD_EXP 103
60034: PUSH
60035: LD_VAR 0 1
60039: ARRAY
60040: IFFALSE 60501
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60042: LD_ADDR_EXP 102
60046: PUSH
60047: LD_EXP 102
60051: PPUSH
60052: LD_VAR 0 1
60056: PPUSH
60057: LD_INT 4
60059: PPUSH
60060: CALL_OW 1
60064: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60065: LD_ADDR_VAR 0 12
60069: PUSH
60070: LD_EXP 60
60074: PUSH
60075: LD_VAR 0 1
60079: ARRAY
60080: PPUSH
60081: LD_INT 2
60083: PUSH
60084: LD_INT 30
60086: PUSH
60087: LD_INT 4
60089: PUSH
60090: EMPTY
60091: LIST
60092: LIST
60093: PUSH
60094: LD_INT 30
60096: PUSH
60097: LD_INT 5
60099: PUSH
60100: EMPTY
60101: LIST
60102: LIST
60103: PUSH
60104: EMPTY
60105: LIST
60106: LIST
60107: LIST
60108: PPUSH
60109: CALL_OW 72
60113: ST_TO_ADDR
// if not b then
60114: LD_VAR 0 12
60118: NOT
60119: IFFALSE 60123
// exit ;
60121: GO 63189
// p := [ ] ;
60123: LD_ADDR_VAR 0 11
60127: PUSH
60128: EMPTY
60129: ST_TO_ADDR
// if sci >= 2 then
60130: LD_VAR 0 8
60134: PUSH
60135: LD_INT 2
60137: GREATEREQUAL
60138: IFFALSE 60169
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60140: LD_ADDR_VAR 0 8
60144: PUSH
60145: LD_VAR 0 8
60149: PUSH
60150: LD_INT 1
60152: ARRAY
60153: PUSH
60154: LD_VAR 0 8
60158: PUSH
60159: LD_INT 2
60161: ARRAY
60162: PUSH
60163: EMPTY
60164: LIST
60165: LIST
60166: ST_TO_ADDR
60167: GO 60230
// if sci = 1 then
60169: LD_VAR 0 8
60173: PUSH
60174: LD_INT 1
60176: EQUAL
60177: IFFALSE 60198
// sci := [ sci [ 1 ] ] else
60179: LD_ADDR_VAR 0 8
60183: PUSH
60184: LD_VAR 0 8
60188: PUSH
60189: LD_INT 1
60191: ARRAY
60192: PUSH
60193: EMPTY
60194: LIST
60195: ST_TO_ADDR
60196: GO 60230
// if sci = 0 then
60198: LD_VAR 0 8
60202: PUSH
60203: LD_INT 0
60205: EQUAL
60206: IFFALSE 60230
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60208: LD_ADDR_VAR 0 11
60212: PUSH
60213: LD_VAR 0 4
60217: PPUSH
60218: LD_INT 4
60220: PPUSH
60221: CALL 50028 0 2
60225: PUSH
60226: LD_INT 1
60228: ARRAY
60229: ST_TO_ADDR
// if eng > 4 then
60230: LD_VAR 0 6
60234: PUSH
60235: LD_INT 4
60237: GREATER
60238: IFFALSE 60284
// for i = eng downto 4 do
60240: LD_ADDR_VAR 0 3
60244: PUSH
60245: DOUBLE
60246: LD_VAR 0 6
60250: INC
60251: ST_TO_ADDR
60252: LD_INT 4
60254: PUSH
60255: FOR_DOWNTO
60256: IFFALSE 60282
// eng := eng diff eng [ i ] ;
60258: LD_ADDR_VAR 0 6
60262: PUSH
60263: LD_VAR 0 6
60267: PUSH
60268: LD_VAR 0 6
60272: PUSH
60273: LD_VAR 0 3
60277: ARRAY
60278: DIFF
60279: ST_TO_ADDR
60280: GO 60255
60282: POP
60283: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60284: LD_ADDR_VAR 0 4
60288: PUSH
60289: LD_VAR 0 4
60293: PUSH
60294: LD_VAR 0 5
60298: PUSH
60299: LD_VAR 0 6
60303: UNION
60304: PUSH
60305: LD_VAR 0 7
60309: UNION
60310: PUSH
60311: LD_VAR 0 8
60315: UNION
60316: DIFF
60317: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60318: LD_ADDR_VAR 0 13
60322: PUSH
60323: LD_EXP 60
60327: PUSH
60328: LD_VAR 0 1
60332: ARRAY
60333: PPUSH
60334: LD_INT 2
60336: PUSH
60337: LD_INT 30
60339: PUSH
60340: LD_INT 32
60342: PUSH
60343: EMPTY
60344: LIST
60345: LIST
60346: PUSH
60347: LD_INT 30
60349: PUSH
60350: LD_INT 31
60352: PUSH
60353: EMPTY
60354: LIST
60355: LIST
60356: PUSH
60357: EMPTY
60358: LIST
60359: LIST
60360: LIST
60361: PPUSH
60362: CALL_OW 72
60366: PUSH
60367: LD_EXP 60
60371: PUSH
60372: LD_VAR 0 1
60376: ARRAY
60377: PPUSH
60378: LD_INT 2
60380: PUSH
60381: LD_INT 30
60383: PUSH
60384: LD_INT 4
60386: PUSH
60387: EMPTY
60388: LIST
60389: LIST
60390: PUSH
60391: LD_INT 30
60393: PUSH
60394: LD_INT 5
60396: PUSH
60397: EMPTY
60398: LIST
60399: LIST
60400: PUSH
60401: EMPTY
60402: LIST
60403: LIST
60404: LIST
60405: PPUSH
60406: CALL_OW 72
60410: PUSH
60411: LD_INT 6
60413: MUL
60414: PLUS
60415: ST_TO_ADDR
// if bcount < tmp then
60416: LD_VAR 0 13
60420: PUSH
60421: LD_VAR 0 4
60425: LESS
60426: IFFALSE 60472
// for i = tmp downto bcount do
60428: LD_ADDR_VAR 0 3
60432: PUSH
60433: DOUBLE
60434: LD_VAR 0 4
60438: INC
60439: ST_TO_ADDR
60440: LD_VAR 0 13
60444: PUSH
60445: FOR_DOWNTO
60446: IFFALSE 60470
// tmp := Delete ( tmp , tmp ) ;
60448: LD_ADDR_VAR 0 4
60452: PUSH
60453: LD_VAR 0 4
60457: PPUSH
60458: LD_VAR 0 4
60462: PPUSH
60463: CALL_OW 3
60467: ST_TO_ADDR
60468: GO 60445
60470: POP
60471: POP
// result := [ tmp , 0 , 0 , p ] ;
60472: LD_ADDR_VAR 0 2
60476: PUSH
60477: LD_VAR 0 4
60481: PUSH
60482: LD_INT 0
60484: PUSH
60485: LD_INT 0
60487: PUSH
60488: LD_VAR 0 11
60492: PUSH
60493: EMPTY
60494: LIST
60495: LIST
60496: LIST
60497: LIST
60498: ST_TO_ADDR
// exit ;
60499: GO 63189
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60501: LD_EXP 60
60505: PUSH
60506: LD_VAR 0 1
60510: ARRAY
60511: PPUSH
60512: LD_INT 2
60514: PUSH
60515: LD_INT 30
60517: PUSH
60518: LD_INT 6
60520: PUSH
60521: EMPTY
60522: LIST
60523: LIST
60524: PUSH
60525: LD_INT 30
60527: PUSH
60528: LD_INT 7
60530: PUSH
60531: EMPTY
60532: LIST
60533: LIST
60534: PUSH
60535: LD_INT 30
60537: PUSH
60538: LD_INT 8
60540: PUSH
60541: EMPTY
60542: LIST
60543: LIST
60544: PUSH
60545: EMPTY
60546: LIST
60547: LIST
60548: LIST
60549: LIST
60550: PPUSH
60551: CALL_OW 72
60555: NOT
60556: PUSH
60557: LD_EXP 60
60561: PUSH
60562: LD_VAR 0 1
60566: ARRAY
60567: PPUSH
60568: LD_INT 30
60570: PUSH
60571: LD_INT 3
60573: PUSH
60574: EMPTY
60575: LIST
60576: LIST
60577: PPUSH
60578: CALL_OW 72
60582: NOT
60583: AND
60584: IFFALSE 60656
// begin if eng = tmp then
60586: LD_VAR 0 6
60590: PUSH
60591: LD_VAR 0 4
60595: EQUAL
60596: IFFALSE 60600
// exit ;
60598: GO 63189
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60600: LD_ADDR_EXP 102
60604: PUSH
60605: LD_EXP 102
60609: PPUSH
60610: LD_VAR 0 1
60614: PPUSH
60615: LD_INT 1
60617: PPUSH
60618: CALL_OW 1
60622: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60623: LD_ADDR_VAR 0 2
60627: PUSH
60628: LD_INT 0
60630: PUSH
60631: LD_VAR 0 4
60635: PUSH
60636: LD_VAR 0 6
60640: DIFF
60641: PUSH
60642: LD_INT 0
60644: PUSH
60645: LD_INT 0
60647: PUSH
60648: EMPTY
60649: LIST
60650: LIST
60651: LIST
60652: LIST
60653: ST_TO_ADDR
// exit ;
60654: GO 63189
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60656: LD_EXP 87
60660: PUSH
60661: LD_EXP 86
60665: PUSH
60666: LD_VAR 0 1
60670: ARRAY
60671: ARRAY
60672: PUSH
60673: LD_EXP 60
60677: PUSH
60678: LD_VAR 0 1
60682: ARRAY
60683: PPUSH
60684: LD_INT 2
60686: PUSH
60687: LD_INT 30
60689: PUSH
60690: LD_INT 6
60692: PUSH
60693: EMPTY
60694: LIST
60695: LIST
60696: PUSH
60697: LD_INT 30
60699: PUSH
60700: LD_INT 7
60702: PUSH
60703: EMPTY
60704: LIST
60705: LIST
60706: PUSH
60707: LD_INT 30
60709: PUSH
60710: LD_INT 8
60712: PUSH
60713: EMPTY
60714: LIST
60715: LIST
60716: PUSH
60717: EMPTY
60718: LIST
60719: LIST
60720: LIST
60721: LIST
60722: PPUSH
60723: CALL_OW 72
60727: AND
60728: PUSH
60729: LD_EXP 60
60733: PUSH
60734: LD_VAR 0 1
60738: ARRAY
60739: PPUSH
60740: LD_INT 30
60742: PUSH
60743: LD_INT 3
60745: PUSH
60746: EMPTY
60747: LIST
60748: LIST
60749: PPUSH
60750: CALL_OW 72
60754: NOT
60755: AND
60756: IFFALSE 60970
// begin if sci >= 6 then
60758: LD_VAR 0 8
60762: PUSH
60763: LD_INT 6
60765: GREATEREQUAL
60766: IFFALSE 60770
// exit ;
60768: GO 63189
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60770: LD_ADDR_EXP 102
60774: PUSH
60775: LD_EXP 102
60779: PPUSH
60780: LD_VAR 0 1
60784: PPUSH
60785: LD_INT 2
60787: PPUSH
60788: CALL_OW 1
60792: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60793: LD_ADDR_VAR 0 9
60797: PUSH
60798: LD_VAR 0 4
60802: PUSH
60803: LD_VAR 0 8
60807: DIFF
60808: PPUSH
60809: LD_INT 4
60811: PPUSH
60812: CALL 50028 0 2
60816: ST_TO_ADDR
// p := [ ] ;
60817: LD_ADDR_VAR 0 11
60821: PUSH
60822: EMPTY
60823: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60824: LD_VAR 0 8
60828: PUSH
60829: LD_INT 6
60831: LESS
60832: PUSH
60833: LD_VAR 0 9
60837: PUSH
60838: LD_INT 6
60840: GREATER
60841: AND
60842: IFFALSE 60923
// begin for i = 1 to 6 - sci do
60844: LD_ADDR_VAR 0 3
60848: PUSH
60849: DOUBLE
60850: LD_INT 1
60852: DEC
60853: ST_TO_ADDR
60854: LD_INT 6
60856: PUSH
60857: LD_VAR 0 8
60861: MINUS
60862: PUSH
60863: FOR_TO
60864: IFFALSE 60919
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60866: LD_ADDR_VAR 0 11
60870: PUSH
60871: LD_VAR 0 11
60875: PPUSH
60876: LD_VAR 0 11
60880: PUSH
60881: LD_INT 1
60883: PLUS
60884: PPUSH
60885: LD_VAR 0 9
60889: PUSH
60890: LD_INT 1
60892: ARRAY
60893: PPUSH
60894: CALL_OW 2
60898: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60899: LD_ADDR_VAR 0 9
60903: PUSH
60904: LD_VAR 0 9
60908: PPUSH
60909: LD_INT 1
60911: PPUSH
60912: CALL_OW 3
60916: ST_TO_ADDR
// end ;
60917: GO 60863
60919: POP
60920: POP
// end else
60921: GO 60943
// if sort then
60923: LD_VAR 0 9
60927: IFFALSE 60943
// p := sort [ 1 ] ;
60929: LD_ADDR_VAR 0 11
60933: PUSH
60934: LD_VAR 0 9
60938: PUSH
60939: LD_INT 1
60941: ARRAY
60942: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
60943: LD_ADDR_VAR 0 2
60947: PUSH
60948: LD_INT 0
60950: PUSH
60951: LD_INT 0
60953: PUSH
60954: LD_INT 0
60956: PUSH
60957: LD_VAR 0 11
60961: PUSH
60962: EMPTY
60963: LIST
60964: LIST
60965: LIST
60966: LIST
60967: ST_TO_ADDR
// exit ;
60968: GO 63189
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60970: LD_EXP 87
60974: PUSH
60975: LD_EXP 86
60979: PUSH
60980: LD_VAR 0 1
60984: ARRAY
60985: ARRAY
60986: PUSH
60987: LD_EXP 60
60991: PUSH
60992: LD_VAR 0 1
60996: ARRAY
60997: PPUSH
60998: LD_INT 2
61000: PUSH
61001: LD_INT 30
61003: PUSH
61004: LD_INT 6
61006: PUSH
61007: EMPTY
61008: LIST
61009: LIST
61010: PUSH
61011: LD_INT 30
61013: PUSH
61014: LD_INT 7
61016: PUSH
61017: EMPTY
61018: LIST
61019: LIST
61020: PUSH
61021: LD_INT 30
61023: PUSH
61024: LD_INT 8
61026: PUSH
61027: EMPTY
61028: LIST
61029: LIST
61030: PUSH
61031: EMPTY
61032: LIST
61033: LIST
61034: LIST
61035: LIST
61036: PPUSH
61037: CALL_OW 72
61041: AND
61042: PUSH
61043: LD_EXP 60
61047: PUSH
61048: LD_VAR 0 1
61052: ARRAY
61053: PPUSH
61054: LD_INT 30
61056: PUSH
61057: LD_INT 3
61059: PUSH
61060: EMPTY
61061: LIST
61062: LIST
61063: PPUSH
61064: CALL_OW 72
61068: AND
61069: IFFALSE 61803
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61071: LD_ADDR_EXP 102
61075: PUSH
61076: LD_EXP 102
61080: PPUSH
61081: LD_VAR 0 1
61085: PPUSH
61086: LD_INT 3
61088: PPUSH
61089: CALL_OW 1
61093: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61094: LD_ADDR_VAR 0 2
61098: PUSH
61099: LD_INT 0
61101: PUSH
61102: LD_INT 0
61104: PUSH
61105: LD_INT 0
61107: PUSH
61108: LD_INT 0
61110: PUSH
61111: EMPTY
61112: LIST
61113: LIST
61114: LIST
61115: LIST
61116: ST_TO_ADDR
// if not eng then
61117: LD_VAR 0 6
61121: NOT
61122: IFFALSE 61185
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61124: LD_ADDR_VAR 0 11
61128: PUSH
61129: LD_VAR 0 4
61133: PPUSH
61134: LD_INT 2
61136: PPUSH
61137: CALL 50028 0 2
61141: PUSH
61142: LD_INT 1
61144: ARRAY
61145: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61146: LD_ADDR_VAR 0 2
61150: PUSH
61151: LD_VAR 0 2
61155: PPUSH
61156: LD_INT 2
61158: PPUSH
61159: LD_VAR 0 11
61163: PPUSH
61164: CALL_OW 1
61168: ST_TO_ADDR
// tmp := tmp diff p ;
61169: LD_ADDR_VAR 0 4
61173: PUSH
61174: LD_VAR 0 4
61178: PUSH
61179: LD_VAR 0 11
61183: DIFF
61184: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61185: LD_VAR 0 4
61189: PUSH
61190: LD_VAR 0 8
61194: PUSH
61195: LD_INT 6
61197: LESS
61198: AND
61199: IFFALSE 61387
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61201: LD_ADDR_VAR 0 9
61205: PUSH
61206: LD_VAR 0 4
61210: PUSH
61211: LD_VAR 0 8
61215: PUSH
61216: LD_VAR 0 7
61220: UNION
61221: DIFF
61222: PPUSH
61223: LD_INT 4
61225: PPUSH
61226: CALL 50028 0 2
61230: ST_TO_ADDR
// p := [ ] ;
61231: LD_ADDR_VAR 0 11
61235: PUSH
61236: EMPTY
61237: ST_TO_ADDR
// if sort then
61238: LD_VAR 0 9
61242: IFFALSE 61358
// for i = 1 to 6 - sci do
61244: LD_ADDR_VAR 0 3
61248: PUSH
61249: DOUBLE
61250: LD_INT 1
61252: DEC
61253: ST_TO_ADDR
61254: LD_INT 6
61256: PUSH
61257: LD_VAR 0 8
61261: MINUS
61262: PUSH
61263: FOR_TO
61264: IFFALSE 61356
// begin if i = sort then
61266: LD_VAR 0 3
61270: PUSH
61271: LD_VAR 0 9
61275: EQUAL
61276: IFFALSE 61280
// break ;
61278: GO 61356
// if GetClass ( i ) = 4 then
61280: LD_VAR 0 3
61284: PPUSH
61285: CALL_OW 257
61289: PUSH
61290: LD_INT 4
61292: EQUAL
61293: IFFALSE 61297
// continue ;
61295: GO 61263
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61297: LD_ADDR_VAR 0 11
61301: PUSH
61302: LD_VAR 0 11
61306: PPUSH
61307: LD_VAR 0 11
61311: PUSH
61312: LD_INT 1
61314: PLUS
61315: PPUSH
61316: LD_VAR 0 9
61320: PUSH
61321: LD_VAR 0 3
61325: ARRAY
61326: PPUSH
61327: CALL_OW 2
61331: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61332: LD_ADDR_VAR 0 4
61336: PUSH
61337: LD_VAR 0 4
61341: PUSH
61342: LD_VAR 0 9
61346: PUSH
61347: LD_VAR 0 3
61351: ARRAY
61352: DIFF
61353: ST_TO_ADDR
// end ;
61354: GO 61263
61356: POP
61357: POP
// if p then
61358: LD_VAR 0 11
61362: IFFALSE 61387
// result := Replace ( result , 4 , p ) ;
61364: LD_ADDR_VAR 0 2
61368: PUSH
61369: LD_VAR 0 2
61373: PPUSH
61374: LD_INT 4
61376: PPUSH
61377: LD_VAR 0 11
61381: PPUSH
61382: CALL_OW 1
61386: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61387: LD_VAR 0 4
61391: PUSH
61392: LD_VAR 0 7
61396: PUSH
61397: LD_INT 6
61399: LESS
61400: AND
61401: IFFALSE 61589
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61403: LD_ADDR_VAR 0 9
61407: PUSH
61408: LD_VAR 0 4
61412: PUSH
61413: LD_VAR 0 8
61417: PUSH
61418: LD_VAR 0 7
61422: UNION
61423: DIFF
61424: PPUSH
61425: LD_INT 3
61427: PPUSH
61428: CALL 50028 0 2
61432: ST_TO_ADDR
// p := [ ] ;
61433: LD_ADDR_VAR 0 11
61437: PUSH
61438: EMPTY
61439: ST_TO_ADDR
// if sort then
61440: LD_VAR 0 9
61444: IFFALSE 61560
// for i = 1 to 6 - mech do
61446: LD_ADDR_VAR 0 3
61450: PUSH
61451: DOUBLE
61452: LD_INT 1
61454: DEC
61455: ST_TO_ADDR
61456: LD_INT 6
61458: PUSH
61459: LD_VAR 0 7
61463: MINUS
61464: PUSH
61465: FOR_TO
61466: IFFALSE 61558
// begin if i = sort then
61468: LD_VAR 0 3
61472: PUSH
61473: LD_VAR 0 9
61477: EQUAL
61478: IFFALSE 61482
// break ;
61480: GO 61558
// if GetClass ( i ) = 3 then
61482: LD_VAR 0 3
61486: PPUSH
61487: CALL_OW 257
61491: PUSH
61492: LD_INT 3
61494: EQUAL
61495: IFFALSE 61499
// continue ;
61497: GO 61465
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61499: LD_ADDR_VAR 0 11
61503: PUSH
61504: LD_VAR 0 11
61508: PPUSH
61509: LD_VAR 0 11
61513: PUSH
61514: LD_INT 1
61516: PLUS
61517: PPUSH
61518: LD_VAR 0 9
61522: PUSH
61523: LD_VAR 0 3
61527: ARRAY
61528: PPUSH
61529: CALL_OW 2
61533: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61534: LD_ADDR_VAR 0 4
61538: PUSH
61539: LD_VAR 0 4
61543: PUSH
61544: LD_VAR 0 9
61548: PUSH
61549: LD_VAR 0 3
61553: ARRAY
61554: DIFF
61555: ST_TO_ADDR
// end ;
61556: GO 61465
61558: POP
61559: POP
// if p then
61560: LD_VAR 0 11
61564: IFFALSE 61589
// result := Replace ( result , 3 , p ) ;
61566: LD_ADDR_VAR 0 2
61570: PUSH
61571: LD_VAR 0 2
61575: PPUSH
61576: LD_INT 3
61578: PPUSH
61579: LD_VAR 0 11
61583: PPUSH
61584: CALL_OW 1
61588: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61589: LD_VAR 0 4
61593: PUSH
61594: LD_INT 6
61596: GREATER
61597: PUSH
61598: LD_VAR 0 6
61602: PUSH
61603: LD_INT 6
61605: LESS
61606: AND
61607: IFFALSE 61801
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61609: LD_ADDR_VAR 0 9
61613: PUSH
61614: LD_VAR 0 4
61618: PUSH
61619: LD_VAR 0 8
61623: PUSH
61624: LD_VAR 0 7
61628: UNION
61629: PUSH
61630: LD_VAR 0 6
61634: UNION
61635: DIFF
61636: PPUSH
61637: LD_INT 2
61639: PPUSH
61640: CALL 50028 0 2
61644: ST_TO_ADDR
// p := [ ] ;
61645: LD_ADDR_VAR 0 11
61649: PUSH
61650: EMPTY
61651: ST_TO_ADDR
// if sort then
61652: LD_VAR 0 9
61656: IFFALSE 61772
// for i = 1 to 6 - eng do
61658: LD_ADDR_VAR 0 3
61662: PUSH
61663: DOUBLE
61664: LD_INT 1
61666: DEC
61667: ST_TO_ADDR
61668: LD_INT 6
61670: PUSH
61671: LD_VAR 0 6
61675: MINUS
61676: PUSH
61677: FOR_TO
61678: IFFALSE 61770
// begin if i = sort then
61680: LD_VAR 0 3
61684: PUSH
61685: LD_VAR 0 9
61689: EQUAL
61690: IFFALSE 61694
// break ;
61692: GO 61770
// if GetClass ( i ) = 2 then
61694: LD_VAR 0 3
61698: PPUSH
61699: CALL_OW 257
61703: PUSH
61704: LD_INT 2
61706: EQUAL
61707: IFFALSE 61711
// continue ;
61709: GO 61677
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61711: LD_ADDR_VAR 0 11
61715: PUSH
61716: LD_VAR 0 11
61720: PPUSH
61721: LD_VAR 0 11
61725: PUSH
61726: LD_INT 1
61728: PLUS
61729: PPUSH
61730: LD_VAR 0 9
61734: PUSH
61735: LD_VAR 0 3
61739: ARRAY
61740: PPUSH
61741: CALL_OW 2
61745: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61746: LD_ADDR_VAR 0 4
61750: PUSH
61751: LD_VAR 0 4
61755: PUSH
61756: LD_VAR 0 9
61760: PUSH
61761: LD_VAR 0 3
61765: ARRAY
61766: DIFF
61767: ST_TO_ADDR
// end ;
61768: GO 61677
61770: POP
61771: POP
// if p then
61772: LD_VAR 0 11
61776: IFFALSE 61801
// result := Replace ( result , 2 , p ) ;
61778: LD_ADDR_VAR 0 2
61782: PUSH
61783: LD_VAR 0 2
61787: PPUSH
61788: LD_INT 2
61790: PPUSH
61791: LD_VAR 0 11
61795: PPUSH
61796: CALL_OW 1
61800: ST_TO_ADDR
// end ; exit ;
61801: GO 63189
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61803: LD_EXP 87
61807: PUSH
61808: LD_EXP 86
61812: PUSH
61813: LD_VAR 0 1
61817: ARRAY
61818: ARRAY
61819: NOT
61820: PUSH
61821: LD_EXP 60
61825: PUSH
61826: LD_VAR 0 1
61830: ARRAY
61831: PPUSH
61832: LD_INT 30
61834: PUSH
61835: LD_INT 3
61837: PUSH
61838: EMPTY
61839: LIST
61840: LIST
61841: PPUSH
61842: CALL_OW 72
61846: AND
61847: PUSH
61848: LD_EXP 65
61852: PUSH
61853: LD_VAR 0 1
61857: ARRAY
61858: AND
61859: IFFALSE 62467
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61861: LD_ADDR_EXP 102
61865: PUSH
61866: LD_EXP 102
61870: PPUSH
61871: LD_VAR 0 1
61875: PPUSH
61876: LD_INT 5
61878: PPUSH
61879: CALL_OW 1
61883: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61884: LD_ADDR_VAR 0 2
61888: PUSH
61889: LD_INT 0
61891: PUSH
61892: LD_INT 0
61894: PUSH
61895: LD_INT 0
61897: PUSH
61898: LD_INT 0
61900: PUSH
61901: EMPTY
61902: LIST
61903: LIST
61904: LIST
61905: LIST
61906: ST_TO_ADDR
// if sci > 1 then
61907: LD_VAR 0 8
61911: PUSH
61912: LD_INT 1
61914: GREATER
61915: IFFALSE 61943
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61917: LD_ADDR_VAR 0 4
61921: PUSH
61922: LD_VAR 0 4
61926: PUSH
61927: LD_VAR 0 8
61931: PUSH
61932: LD_VAR 0 8
61936: PUSH
61937: LD_INT 1
61939: ARRAY
61940: DIFF
61941: DIFF
61942: ST_TO_ADDR
// if tmp and not sci then
61943: LD_VAR 0 4
61947: PUSH
61948: LD_VAR 0 8
61952: NOT
61953: AND
61954: IFFALSE 62023
// begin sort := SortBySkill ( tmp , 4 ) ;
61956: LD_ADDR_VAR 0 9
61960: PUSH
61961: LD_VAR 0 4
61965: PPUSH
61966: LD_INT 4
61968: PPUSH
61969: CALL 50028 0 2
61973: ST_TO_ADDR
// if sort then
61974: LD_VAR 0 9
61978: IFFALSE 61994
// p := sort [ 1 ] ;
61980: LD_ADDR_VAR 0 11
61984: PUSH
61985: LD_VAR 0 9
61989: PUSH
61990: LD_INT 1
61992: ARRAY
61993: ST_TO_ADDR
// if p then
61994: LD_VAR 0 11
61998: IFFALSE 62023
// result := Replace ( result , 4 , p ) ;
62000: LD_ADDR_VAR 0 2
62004: PUSH
62005: LD_VAR 0 2
62009: PPUSH
62010: LD_INT 4
62012: PPUSH
62013: LD_VAR 0 11
62017: PPUSH
62018: CALL_OW 1
62022: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62023: LD_ADDR_VAR 0 4
62027: PUSH
62028: LD_VAR 0 4
62032: PUSH
62033: LD_VAR 0 7
62037: DIFF
62038: ST_TO_ADDR
// if tmp and mech < 6 then
62039: LD_VAR 0 4
62043: PUSH
62044: LD_VAR 0 7
62048: PUSH
62049: LD_INT 6
62051: LESS
62052: AND
62053: IFFALSE 62241
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62055: LD_ADDR_VAR 0 9
62059: PUSH
62060: LD_VAR 0 4
62064: PUSH
62065: LD_VAR 0 8
62069: PUSH
62070: LD_VAR 0 7
62074: UNION
62075: DIFF
62076: PPUSH
62077: LD_INT 3
62079: PPUSH
62080: CALL 50028 0 2
62084: ST_TO_ADDR
// p := [ ] ;
62085: LD_ADDR_VAR 0 11
62089: PUSH
62090: EMPTY
62091: ST_TO_ADDR
// if sort then
62092: LD_VAR 0 9
62096: IFFALSE 62212
// for i = 1 to 6 - mech do
62098: LD_ADDR_VAR 0 3
62102: PUSH
62103: DOUBLE
62104: LD_INT 1
62106: DEC
62107: ST_TO_ADDR
62108: LD_INT 6
62110: PUSH
62111: LD_VAR 0 7
62115: MINUS
62116: PUSH
62117: FOR_TO
62118: IFFALSE 62210
// begin if i = sort then
62120: LD_VAR 0 3
62124: PUSH
62125: LD_VAR 0 9
62129: EQUAL
62130: IFFALSE 62134
// break ;
62132: GO 62210
// if GetClass ( i ) = 3 then
62134: LD_VAR 0 3
62138: PPUSH
62139: CALL_OW 257
62143: PUSH
62144: LD_INT 3
62146: EQUAL
62147: IFFALSE 62151
// continue ;
62149: GO 62117
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62151: LD_ADDR_VAR 0 11
62155: PUSH
62156: LD_VAR 0 11
62160: PPUSH
62161: LD_VAR 0 11
62165: PUSH
62166: LD_INT 1
62168: PLUS
62169: PPUSH
62170: LD_VAR 0 9
62174: PUSH
62175: LD_VAR 0 3
62179: ARRAY
62180: PPUSH
62181: CALL_OW 2
62185: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62186: LD_ADDR_VAR 0 4
62190: PUSH
62191: LD_VAR 0 4
62195: PUSH
62196: LD_VAR 0 9
62200: PUSH
62201: LD_VAR 0 3
62205: ARRAY
62206: DIFF
62207: ST_TO_ADDR
// end ;
62208: GO 62117
62210: POP
62211: POP
// if p then
62212: LD_VAR 0 11
62216: IFFALSE 62241
// result := Replace ( result , 3 , p ) ;
62218: LD_ADDR_VAR 0 2
62222: PUSH
62223: LD_VAR 0 2
62227: PPUSH
62228: LD_INT 3
62230: PPUSH
62231: LD_VAR 0 11
62235: PPUSH
62236: CALL_OW 1
62240: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62241: LD_ADDR_VAR 0 4
62245: PUSH
62246: LD_VAR 0 4
62250: PUSH
62251: LD_VAR 0 6
62255: DIFF
62256: ST_TO_ADDR
// if tmp and eng < 6 then
62257: LD_VAR 0 4
62261: PUSH
62262: LD_VAR 0 6
62266: PUSH
62267: LD_INT 6
62269: LESS
62270: AND
62271: IFFALSE 62465
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62273: LD_ADDR_VAR 0 9
62277: PUSH
62278: LD_VAR 0 4
62282: PUSH
62283: LD_VAR 0 8
62287: PUSH
62288: LD_VAR 0 7
62292: UNION
62293: PUSH
62294: LD_VAR 0 6
62298: UNION
62299: DIFF
62300: PPUSH
62301: LD_INT 2
62303: PPUSH
62304: CALL 50028 0 2
62308: ST_TO_ADDR
// p := [ ] ;
62309: LD_ADDR_VAR 0 11
62313: PUSH
62314: EMPTY
62315: ST_TO_ADDR
// if sort then
62316: LD_VAR 0 9
62320: IFFALSE 62436
// for i = 1 to 6 - eng do
62322: LD_ADDR_VAR 0 3
62326: PUSH
62327: DOUBLE
62328: LD_INT 1
62330: DEC
62331: ST_TO_ADDR
62332: LD_INT 6
62334: PUSH
62335: LD_VAR 0 6
62339: MINUS
62340: PUSH
62341: FOR_TO
62342: IFFALSE 62434
// begin if i = sort then
62344: LD_VAR 0 3
62348: PUSH
62349: LD_VAR 0 9
62353: EQUAL
62354: IFFALSE 62358
// break ;
62356: GO 62434
// if GetClass ( i ) = 2 then
62358: LD_VAR 0 3
62362: PPUSH
62363: CALL_OW 257
62367: PUSH
62368: LD_INT 2
62370: EQUAL
62371: IFFALSE 62375
// continue ;
62373: GO 62341
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62375: LD_ADDR_VAR 0 11
62379: PUSH
62380: LD_VAR 0 11
62384: PPUSH
62385: LD_VAR 0 11
62389: PUSH
62390: LD_INT 1
62392: PLUS
62393: PPUSH
62394: LD_VAR 0 9
62398: PUSH
62399: LD_VAR 0 3
62403: ARRAY
62404: PPUSH
62405: CALL_OW 2
62409: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62410: LD_ADDR_VAR 0 4
62414: PUSH
62415: LD_VAR 0 4
62419: PUSH
62420: LD_VAR 0 9
62424: PUSH
62425: LD_VAR 0 3
62429: ARRAY
62430: DIFF
62431: ST_TO_ADDR
// end ;
62432: GO 62341
62434: POP
62435: POP
// if p then
62436: LD_VAR 0 11
62440: IFFALSE 62465
// result := Replace ( result , 2 , p ) ;
62442: LD_ADDR_VAR 0 2
62446: PUSH
62447: LD_VAR 0 2
62451: PPUSH
62452: LD_INT 2
62454: PPUSH
62455: LD_VAR 0 11
62459: PPUSH
62460: CALL_OW 1
62464: ST_TO_ADDR
// end ; exit ;
62465: GO 63189
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62467: LD_EXP 87
62471: PUSH
62472: LD_EXP 86
62476: PUSH
62477: LD_VAR 0 1
62481: ARRAY
62482: ARRAY
62483: NOT
62484: PUSH
62485: LD_EXP 60
62489: PUSH
62490: LD_VAR 0 1
62494: ARRAY
62495: PPUSH
62496: LD_INT 30
62498: PUSH
62499: LD_INT 3
62501: PUSH
62502: EMPTY
62503: LIST
62504: LIST
62505: PPUSH
62506: CALL_OW 72
62510: AND
62511: PUSH
62512: LD_EXP 65
62516: PUSH
62517: LD_VAR 0 1
62521: ARRAY
62522: NOT
62523: AND
62524: IFFALSE 63189
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62526: LD_ADDR_EXP 102
62530: PUSH
62531: LD_EXP 102
62535: PPUSH
62536: LD_VAR 0 1
62540: PPUSH
62541: LD_INT 6
62543: PPUSH
62544: CALL_OW 1
62548: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62549: LD_ADDR_VAR 0 2
62553: PUSH
62554: LD_INT 0
62556: PUSH
62557: LD_INT 0
62559: PUSH
62560: LD_INT 0
62562: PUSH
62563: LD_INT 0
62565: PUSH
62566: EMPTY
62567: LIST
62568: LIST
62569: LIST
62570: LIST
62571: ST_TO_ADDR
// if sci >= 1 then
62572: LD_VAR 0 8
62576: PUSH
62577: LD_INT 1
62579: GREATEREQUAL
62580: IFFALSE 62602
// tmp := tmp diff sci [ 1 ] ;
62582: LD_ADDR_VAR 0 4
62586: PUSH
62587: LD_VAR 0 4
62591: PUSH
62592: LD_VAR 0 8
62596: PUSH
62597: LD_INT 1
62599: ARRAY
62600: DIFF
62601: ST_TO_ADDR
// if tmp and not sci then
62602: LD_VAR 0 4
62606: PUSH
62607: LD_VAR 0 8
62611: NOT
62612: AND
62613: IFFALSE 62682
// begin sort := SortBySkill ( tmp , 4 ) ;
62615: LD_ADDR_VAR 0 9
62619: PUSH
62620: LD_VAR 0 4
62624: PPUSH
62625: LD_INT 4
62627: PPUSH
62628: CALL 50028 0 2
62632: ST_TO_ADDR
// if sort then
62633: LD_VAR 0 9
62637: IFFALSE 62653
// p := sort [ 1 ] ;
62639: LD_ADDR_VAR 0 11
62643: PUSH
62644: LD_VAR 0 9
62648: PUSH
62649: LD_INT 1
62651: ARRAY
62652: ST_TO_ADDR
// if p then
62653: LD_VAR 0 11
62657: IFFALSE 62682
// result := Replace ( result , 4 , p ) ;
62659: LD_ADDR_VAR 0 2
62663: PUSH
62664: LD_VAR 0 2
62668: PPUSH
62669: LD_INT 4
62671: PPUSH
62672: LD_VAR 0 11
62676: PPUSH
62677: CALL_OW 1
62681: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62682: LD_ADDR_VAR 0 4
62686: PUSH
62687: LD_VAR 0 4
62691: PUSH
62692: LD_VAR 0 7
62696: DIFF
62697: ST_TO_ADDR
// if tmp and mech < 6 then
62698: LD_VAR 0 4
62702: PUSH
62703: LD_VAR 0 7
62707: PUSH
62708: LD_INT 6
62710: LESS
62711: AND
62712: IFFALSE 62894
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
62714: LD_ADDR_VAR 0 9
62718: PUSH
62719: LD_VAR 0 4
62723: PUSH
62724: LD_VAR 0 7
62728: DIFF
62729: PPUSH
62730: LD_INT 3
62732: PPUSH
62733: CALL 50028 0 2
62737: ST_TO_ADDR
// p := [ ] ;
62738: LD_ADDR_VAR 0 11
62742: PUSH
62743: EMPTY
62744: ST_TO_ADDR
// if sort then
62745: LD_VAR 0 9
62749: IFFALSE 62865
// for i = 1 to 6 - mech do
62751: LD_ADDR_VAR 0 3
62755: PUSH
62756: DOUBLE
62757: LD_INT 1
62759: DEC
62760: ST_TO_ADDR
62761: LD_INT 6
62763: PUSH
62764: LD_VAR 0 7
62768: MINUS
62769: PUSH
62770: FOR_TO
62771: IFFALSE 62863
// begin if i = sort then
62773: LD_VAR 0 3
62777: PUSH
62778: LD_VAR 0 9
62782: EQUAL
62783: IFFALSE 62787
// break ;
62785: GO 62863
// if GetClass ( i ) = 3 then
62787: LD_VAR 0 3
62791: PPUSH
62792: CALL_OW 257
62796: PUSH
62797: LD_INT 3
62799: EQUAL
62800: IFFALSE 62804
// continue ;
62802: GO 62770
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62804: LD_ADDR_VAR 0 11
62808: PUSH
62809: LD_VAR 0 11
62813: PPUSH
62814: LD_VAR 0 11
62818: PUSH
62819: LD_INT 1
62821: PLUS
62822: PPUSH
62823: LD_VAR 0 9
62827: PUSH
62828: LD_VAR 0 3
62832: ARRAY
62833: PPUSH
62834: CALL_OW 2
62838: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62839: LD_ADDR_VAR 0 4
62843: PUSH
62844: LD_VAR 0 4
62848: PUSH
62849: LD_VAR 0 9
62853: PUSH
62854: LD_VAR 0 3
62858: ARRAY
62859: DIFF
62860: ST_TO_ADDR
// end ;
62861: GO 62770
62863: POP
62864: POP
// if p then
62865: LD_VAR 0 11
62869: IFFALSE 62894
// result := Replace ( result , 3 , p ) ;
62871: LD_ADDR_VAR 0 2
62875: PUSH
62876: LD_VAR 0 2
62880: PPUSH
62881: LD_INT 3
62883: PPUSH
62884: LD_VAR 0 11
62888: PPUSH
62889: CALL_OW 1
62893: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62894: LD_ADDR_VAR 0 4
62898: PUSH
62899: LD_VAR 0 4
62903: PUSH
62904: LD_VAR 0 6
62908: DIFF
62909: ST_TO_ADDR
// if tmp and eng < 4 then
62910: LD_VAR 0 4
62914: PUSH
62915: LD_VAR 0 6
62919: PUSH
62920: LD_INT 4
62922: LESS
62923: AND
62924: IFFALSE 63114
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
62926: LD_ADDR_VAR 0 9
62930: PUSH
62931: LD_VAR 0 4
62935: PUSH
62936: LD_VAR 0 7
62940: PUSH
62941: LD_VAR 0 6
62945: UNION
62946: DIFF
62947: PPUSH
62948: LD_INT 2
62950: PPUSH
62951: CALL 50028 0 2
62955: ST_TO_ADDR
// p := [ ] ;
62956: LD_ADDR_VAR 0 11
62960: PUSH
62961: EMPTY
62962: ST_TO_ADDR
// if sort then
62963: LD_VAR 0 9
62967: IFFALSE 63083
// for i = 1 to 4 - eng do
62969: LD_ADDR_VAR 0 3
62973: PUSH
62974: DOUBLE
62975: LD_INT 1
62977: DEC
62978: ST_TO_ADDR
62979: LD_INT 4
62981: PUSH
62982: LD_VAR 0 6
62986: MINUS
62987: PUSH
62988: FOR_TO
62989: IFFALSE 63081
// begin if i = sort then
62991: LD_VAR 0 3
62995: PUSH
62996: LD_VAR 0 9
63000: EQUAL
63001: IFFALSE 63005
// break ;
63003: GO 63081
// if GetClass ( i ) = 2 then
63005: LD_VAR 0 3
63009: PPUSH
63010: CALL_OW 257
63014: PUSH
63015: LD_INT 2
63017: EQUAL
63018: IFFALSE 63022
// continue ;
63020: GO 62988
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63022: LD_ADDR_VAR 0 11
63026: PUSH
63027: LD_VAR 0 11
63031: PPUSH
63032: LD_VAR 0 11
63036: PUSH
63037: LD_INT 1
63039: PLUS
63040: PPUSH
63041: LD_VAR 0 9
63045: PUSH
63046: LD_VAR 0 3
63050: ARRAY
63051: PPUSH
63052: CALL_OW 2
63056: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63057: LD_ADDR_VAR 0 4
63061: PUSH
63062: LD_VAR 0 4
63066: PUSH
63067: LD_VAR 0 9
63071: PUSH
63072: LD_VAR 0 3
63076: ARRAY
63077: DIFF
63078: ST_TO_ADDR
// end ;
63079: GO 62988
63081: POP
63082: POP
// if p then
63083: LD_VAR 0 11
63087: IFFALSE 63112
// result := Replace ( result , 2 , p ) ;
63089: LD_ADDR_VAR 0 2
63093: PUSH
63094: LD_VAR 0 2
63098: PPUSH
63099: LD_INT 2
63101: PPUSH
63102: LD_VAR 0 11
63106: PPUSH
63107: CALL_OW 1
63111: ST_TO_ADDR
// end else
63112: GO 63158
// for i = eng downto 5 do
63114: LD_ADDR_VAR 0 3
63118: PUSH
63119: DOUBLE
63120: LD_VAR 0 6
63124: INC
63125: ST_TO_ADDR
63126: LD_INT 5
63128: PUSH
63129: FOR_DOWNTO
63130: IFFALSE 63156
// tmp := tmp union eng [ i ] ;
63132: LD_ADDR_VAR 0 4
63136: PUSH
63137: LD_VAR 0 4
63141: PUSH
63142: LD_VAR 0 6
63146: PUSH
63147: LD_VAR 0 3
63151: ARRAY
63152: UNION
63153: ST_TO_ADDR
63154: GO 63129
63156: POP
63157: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63158: LD_ADDR_VAR 0 2
63162: PUSH
63163: LD_VAR 0 2
63167: PPUSH
63168: LD_INT 1
63170: PPUSH
63171: LD_VAR 0 4
63175: PUSH
63176: LD_VAR 0 5
63180: DIFF
63181: PPUSH
63182: CALL_OW 1
63186: ST_TO_ADDR
// exit ;
63187: GO 63189
// end ; end ;
63189: LD_VAR 0 2
63193: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63194: LD_INT 0
63196: PPUSH
63197: PPUSH
63198: PPUSH
// if not mc_bases then
63199: LD_EXP 60
63203: NOT
63204: IFFALSE 63208
// exit ;
63206: GO 63350
// for i = 1 to mc_bases do
63208: LD_ADDR_VAR 0 2
63212: PUSH
63213: DOUBLE
63214: LD_INT 1
63216: DEC
63217: ST_TO_ADDR
63218: LD_EXP 60
63222: PUSH
63223: FOR_TO
63224: IFFALSE 63341
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63226: LD_ADDR_VAR 0 3
63230: PUSH
63231: LD_EXP 60
63235: PUSH
63236: LD_VAR 0 2
63240: ARRAY
63241: PPUSH
63242: LD_INT 21
63244: PUSH
63245: LD_INT 3
63247: PUSH
63248: EMPTY
63249: LIST
63250: LIST
63251: PUSH
63252: LD_INT 3
63254: PUSH
63255: LD_INT 2
63257: PUSH
63258: LD_INT 30
63260: PUSH
63261: LD_INT 29
63263: PUSH
63264: EMPTY
63265: LIST
63266: LIST
63267: PUSH
63268: LD_INT 30
63270: PUSH
63271: LD_INT 30
63273: PUSH
63274: EMPTY
63275: LIST
63276: LIST
63277: PUSH
63278: EMPTY
63279: LIST
63280: LIST
63281: LIST
63282: PUSH
63283: EMPTY
63284: LIST
63285: LIST
63286: PUSH
63287: LD_INT 3
63289: PUSH
63290: LD_INT 24
63292: PUSH
63293: LD_INT 1000
63295: PUSH
63296: EMPTY
63297: LIST
63298: LIST
63299: PUSH
63300: EMPTY
63301: LIST
63302: LIST
63303: PUSH
63304: EMPTY
63305: LIST
63306: LIST
63307: LIST
63308: PPUSH
63309: CALL_OW 72
63313: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63314: LD_ADDR_EXP 61
63318: PUSH
63319: LD_EXP 61
63323: PPUSH
63324: LD_VAR 0 2
63328: PPUSH
63329: LD_VAR 0 3
63333: PPUSH
63334: CALL_OW 1
63338: ST_TO_ADDR
// end ;
63339: GO 63223
63341: POP
63342: POP
// RaiseSailEvent ( 101 ) ;
63343: LD_INT 101
63345: PPUSH
63346: CALL_OW 427
// end ;
63350: LD_VAR 0 1
63354: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63355: LD_INT 0
63357: PPUSH
63358: PPUSH
63359: PPUSH
63360: PPUSH
63361: PPUSH
63362: PPUSH
63363: PPUSH
// if not mc_bases then
63364: LD_EXP 60
63368: NOT
63369: IFFALSE 63373
// exit ;
63371: GO 63935
// for i = 1 to mc_bases do
63373: LD_ADDR_VAR 0 2
63377: PUSH
63378: DOUBLE
63379: LD_INT 1
63381: DEC
63382: ST_TO_ADDR
63383: LD_EXP 60
63387: PUSH
63388: FOR_TO
63389: IFFALSE 63926
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
63391: LD_ADDR_VAR 0 5
63395: PUSH
63396: LD_EXP 60
63400: PUSH
63401: LD_VAR 0 2
63405: ARRAY
63406: PUSH
63407: LD_EXP 89
63411: PUSH
63412: LD_VAR 0 2
63416: ARRAY
63417: UNION
63418: PPUSH
63419: LD_INT 21
63421: PUSH
63422: LD_INT 1
63424: PUSH
63425: EMPTY
63426: LIST
63427: LIST
63428: PUSH
63429: LD_INT 1
63431: PUSH
63432: LD_INT 3
63434: PUSH
63435: LD_INT 54
63437: PUSH
63438: EMPTY
63439: LIST
63440: PUSH
63441: EMPTY
63442: LIST
63443: LIST
63444: PUSH
63445: LD_INT 3
63447: PUSH
63448: LD_INT 24
63450: PUSH
63451: LD_INT 1000
63453: PUSH
63454: EMPTY
63455: LIST
63456: LIST
63457: PUSH
63458: EMPTY
63459: LIST
63460: LIST
63461: PUSH
63462: EMPTY
63463: LIST
63464: LIST
63465: LIST
63466: PUSH
63467: EMPTY
63468: LIST
63469: LIST
63470: PPUSH
63471: CALL_OW 72
63475: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63476: LD_ADDR_VAR 0 6
63480: PUSH
63481: LD_EXP 60
63485: PUSH
63486: LD_VAR 0 2
63490: ARRAY
63491: PPUSH
63492: LD_INT 21
63494: PUSH
63495: LD_INT 1
63497: PUSH
63498: EMPTY
63499: LIST
63500: LIST
63501: PUSH
63502: LD_INT 1
63504: PUSH
63505: LD_INT 3
63507: PUSH
63508: LD_INT 54
63510: PUSH
63511: EMPTY
63512: LIST
63513: PUSH
63514: EMPTY
63515: LIST
63516: LIST
63517: PUSH
63518: LD_INT 3
63520: PUSH
63521: LD_INT 24
63523: PUSH
63524: LD_INT 250
63526: PUSH
63527: EMPTY
63528: LIST
63529: LIST
63530: PUSH
63531: EMPTY
63532: LIST
63533: LIST
63534: PUSH
63535: EMPTY
63536: LIST
63537: LIST
63538: LIST
63539: PUSH
63540: EMPTY
63541: LIST
63542: LIST
63543: PPUSH
63544: CALL_OW 72
63548: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63549: LD_ADDR_VAR 0 7
63553: PUSH
63554: LD_VAR 0 5
63558: PUSH
63559: LD_VAR 0 6
63563: DIFF
63564: ST_TO_ADDR
// if not need_heal_1 then
63565: LD_VAR 0 6
63569: NOT
63570: IFFALSE 63603
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63572: LD_ADDR_EXP 63
63576: PUSH
63577: LD_EXP 63
63581: PPUSH
63582: LD_VAR 0 2
63586: PUSH
63587: LD_INT 1
63589: PUSH
63590: EMPTY
63591: LIST
63592: LIST
63593: PPUSH
63594: EMPTY
63595: PPUSH
63596: CALL 19824 0 3
63600: ST_TO_ADDR
63601: GO 63673
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63603: LD_ADDR_EXP 63
63607: PUSH
63608: LD_EXP 63
63612: PPUSH
63613: LD_VAR 0 2
63617: PUSH
63618: LD_INT 1
63620: PUSH
63621: EMPTY
63622: LIST
63623: LIST
63624: PPUSH
63625: LD_EXP 63
63629: PUSH
63630: LD_VAR 0 2
63634: ARRAY
63635: PUSH
63636: LD_INT 1
63638: ARRAY
63639: PPUSH
63640: LD_INT 3
63642: PUSH
63643: LD_INT 24
63645: PUSH
63646: LD_INT 1000
63648: PUSH
63649: EMPTY
63650: LIST
63651: LIST
63652: PUSH
63653: EMPTY
63654: LIST
63655: LIST
63656: PPUSH
63657: CALL_OW 72
63661: PUSH
63662: LD_VAR 0 6
63666: UNION
63667: PPUSH
63668: CALL 19824 0 3
63672: ST_TO_ADDR
// if not need_heal_2 then
63673: LD_VAR 0 7
63677: NOT
63678: IFFALSE 63711
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63680: LD_ADDR_EXP 63
63684: PUSH
63685: LD_EXP 63
63689: PPUSH
63690: LD_VAR 0 2
63694: PUSH
63695: LD_INT 2
63697: PUSH
63698: EMPTY
63699: LIST
63700: LIST
63701: PPUSH
63702: EMPTY
63703: PPUSH
63704: CALL 19824 0 3
63708: ST_TO_ADDR
63709: GO 63743
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63711: LD_ADDR_EXP 63
63715: PUSH
63716: LD_EXP 63
63720: PPUSH
63721: LD_VAR 0 2
63725: PUSH
63726: LD_INT 2
63728: PUSH
63729: EMPTY
63730: LIST
63731: LIST
63732: PPUSH
63733: LD_VAR 0 7
63737: PPUSH
63738: CALL 19824 0 3
63742: ST_TO_ADDR
// if need_heal_2 then
63743: LD_VAR 0 7
63747: IFFALSE 63908
// for j in need_heal_2 do
63749: LD_ADDR_VAR 0 3
63753: PUSH
63754: LD_VAR 0 7
63758: PUSH
63759: FOR_IN
63760: IFFALSE 63906
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63762: LD_ADDR_VAR 0 5
63766: PUSH
63767: LD_EXP 60
63771: PUSH
63772: LD_VAR 0 2
63776: ARRAY
63777: PPUSH
63778: LD_INT 2
63780: PUSH
63781: LD_INT 30
63783: PUSH
63784: LD_INT 6
63786: PUSH
63787: EMPTY
63788: LIST
63789: LIST
63790: PUSH
63791: LD_INT 30
63793: PUSH
63794: LD_INT 7
63796: PUSH
63797: EMPTY
63798: LIST
63799: LIST
63800: PUSH
63801: LD_INT 30
63803: PUSH
63804: LD_INT 8
63806: PUSH
63807: EMPTY
63808: LIST
63809: LIST
63810: PUSH
63811: LD_INT 30
63813: PUSH
63814: LD_INT 0
63816: PUSH
63817: EMPTY
63818: LIST
63819: LIST
63820: PUSH
63821: LD_INT 30
63823: PUSH
63824: LD_INT 1
63826: PUSH
63827: EMPTY
63828: LIST
63829: LIST
63830: PUSH
63831: EMPTY
63832: LIST
63833: LIST
63834: LIST
63835: LIST
63836: LIST
63837: LIST
63838: PPUSH
63839: CALL_OW 72
63843: ST_TO_ADDR
// if tmp then
63844: LD_VAR 0 5
63848: IFFALSE 63904
// begin k := NearestUnitToUnit ( tmp , j ) ;
63850: LD_ADDR_VAR 0 4
63854: PUSH
63855: LD_VAR 0 5
63859: PPUSH
63860: LD_VAR 0 3
63864: PPUSH
63865: CALL_OW 74
63869: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
63870: LD_VAR 0 3
63874: PPUSH
63875: LD_VAR 0 4
63879: PPUSH
63880: CALL_OW 296
63884: PUSH
63885: LD_INT 5
63887: GREATER
63888: IFFALSE 63904
// ComMoveToNearbyEntrance ( j , k ) ;
63890: LD_VAR 0 3
63894: PPUSH
63895: LD_VAR 0 4
63899: PPUSH
63900: CALL 52386 0 2
// end ; end ;
63904: GO 63759
63906: POP
63907: POP
// if not need_heal_1 and not need_heal_2 then
63908: LD_VAR 0 6
63912: NOT
63913: PUSH
63914: LD_VAR 0 7
63918: NOT
63919: AND
63920: IFFALSE 63924
// continue ;
63922: GO 63388
// end ;
63924: GO 63388
63926: POP
63927: POP
// RaiseSailEvent ( 102 ) ;
63928: LD_INT 102
63930: PPUSH
63931: CALL_OW 427
// end ;
63935: LD_VAR 0 1
63939: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
63940: LD_INT 0
63942: PPUSH
63943: PPUSH
63944: PPUSH
63945: PPUSH
63946: PPUSH
63947: PPUSH
63948: PPUSH
63949: PPUSH
// if not mc_bases then
63950: LD_EXP 60
63954: NOT
63955: IFFALSE 63959
// exit ;
63957: GO 64842
// for i = 1 to mc_bases do
63959: LD_ADDR_VAR 0 2
63963: PUSH
63964: DOUBLE
63965: LD_INT 1
63967: DEC
63968: ST_TO_ADDR
63969: LD_EXP 60
63973: PUSH
63974: FOR_TO
63975: IFFALSE 64840
// begin if not mc_building_need_repair [ i ] then
63977: LD_EXP 61
63981: PUSH
63982: LD_VAR 0 2
63986: ARRAY
63987: NOT
63988: IFFALSE 64175
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
63990: LD_ADDR_VAR 0 6
63994: PUSH
63995: LD_EXP 79
63999: PUSH
64000: LD_VAR 0 2
64004: ARRAY
64005: PPUSH
64006: LD_INT 3
64008: PUSH
64009: LD_INT 24
64011: PUSH
64012: LD_INT 1000
64014: PUSH
64015: EMPTY
64016: LIST
64017: LIST
64018: PUSH
64019: EMPTY
64020: LIST
64021: LIST
64022: PUSH
64023: LD_INT 2
64025: PUSH
64026: LD_INT 34
64028: PUSH
64029: LD_INT 13
64031: PUSH
64032: EMPTY
64033: LIST
64034: LIST
64035: PUSH
64036: LD_INT 34
64038: PUSH
64039: LD_INT 52
64041: PUSH
64042: EMPTY
64043: LIST
64044: LIST
64045: PUSH
64046: LD_INT 34
64048: PUSH
64049: LD_EXP 110
64053: PUSH
64054: EMPTY
64055: LIST
64056: LIST
64057: PUSH
64058: EMPTY
64059: LIST
64060: LIST
64061: LIST
64062: LIST
64063: PUSH
64064: EMPTY
64065: LIST
64066: LIST
64067: PPUSH
64068: CALL_OW 72
64072: ST_TO_ADDR
// if cranes then
64073: LD_VAR 0 6
64077: IFFALSE 64139
// for j in cranes do
64079: LD_ADDR_VAR 0 3
64083: PUSH
64084: LD_VAR 0 6
64088: PUSH
64089: FOR_IN
64090: IFFALSE 64137
// if not IsInArea ( j , mc_parking [ i ] ) then
64092: LD_VAR 0 3
64096: PPUSH
64097: LD_EXP 84
64101: PUSH
64102: LD_VAR 0 2
64106: ARRAY
64107: PPUSH
64108: CALL_OW 308
64112: NOT
64113: IFFALSE 64135
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64115: LD_VAR 0 3
64119: PPUSH
64120: LD_EXP 84
64124: PUSH
64125: LD_VAR 0 2
64129: ARRAY
64130: PPUSH
64131: CALL_OW 113
64135: GO 64089
64137: POP
64138: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64139: LD_ADDR_EXP 62
64143: PUSH
64144: LD_EXP 62
64148: PPUSH
64149: LD_VAR 0 2
64153: PPUSH
64154: EMPTY
64155: PPUSH
64156: CALL_OW 1
64160: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64161: LD_VAR 0 2
64165: PPUSH
64166: LD_INT 101
64168: PPUSH
64169: CALL 59027 0 2
// continue ;
64173: GO 63974
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64175: LD_ADDR_EXP 66
64179: PUSH
64180: LD_EXP 66
64184: PPUSH
64185: LD_VAR 0 2
64189: PPUSH
64190: EMPTY
64191: PPUSH
64192: CALL_OW 1
64196: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64197: LD_VAR 0 2
64201: PPUSH
64202: LD_INT 103
64204: PPUSH
64205: CALL 59027 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64209: LD_ADDR_VAR 0 5
64213: PUSH
64214: LD_EXP 60
64218: PUSH
64219: LD_VAR 0 2
64223: ARRAY
64224: PUSH
64225: LD_EXP 89
64229: PUSH
64230: LD_VAR 0 2
64234: ARRAY
64235: UNION
64236: PPUSH
64237: LD_INT 2
64239: PUSH
64240: LD_INT 25
64242: PUSH
64243: LD_INT 2
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: PUSH
64250: LD_INT 25
64252: PUSH
64253: LD_INT 16
64255: PUSH
64256: EMPTY
64257: LIST
64258: LIST
64259: PUSH
64260: EMPTY
64261: LIST
64262: LIST
64263: LIST
64264: PUSH
64265: EMPTY
64266: LIST
64267: PPUSH
64268: CALL_OW 72
64272: ST_TO_ADDR
// if mc_need_heal [ i ] then
64273: LD_EXP 63
64277: PUSH
64278: LD_VAR 0 2
64282: ARRAY
64283: IFFALSE 64327
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
64285: LD_ADDR_VAR 0 5
64289: PUSH
64290: LD_VAR 0 5
64294: PUSH
64295: LD_EXP 63
64299: PUSH
64300: LD_VAR 0 2
64304: ARRAY
64305: PUSH
64306: LD_INT 1
64308: ARRAY
64309: PUSH
64310: LD_EXP 63
64314: PUSH
64315: LD_VAR 0 2
64319: ARRAY
64320: PUSH
64321: LD_INT 2
64323: ARRAY
64324: UNION
64325: DIFF
64326: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
64327: LD_ADDR_VAR 0 6
64331: PUSH
64332: LD_EXP 79
64336: PUSH
64337: LD_VAR 0 2
64341: ARRAY
64342: PPUSH
64343: LD_INT 2
64345: PUSH
64346: LD_INT 34
64348: PUSH
64349: LD_INT 13
64351: PUSH
64352: EMPTY
64353: LIST
64354: LIST
64355: PUSH
64356: LD_INT 34
64358: PUSH
64359: LD_INT 52
64361: PUSH
64362: EMPTY
64363: LIST
64364: LIST
64365: PUSH
64366: LD_INT 34
64368: PUSH
64369: LD_EXP 110
64373: PUSH
64374: EMPTY
64375: LIST
64376: LIST
64377: PUSH
64378: EMPTY
64379: LIST
64380: LIST
64381: LIST
64382: LIST
64383: PPUSH
64384: CALL_OW 72
64388: ST_TO_ADDR
// if cranes then
64389: LD_VAR 0 6
64393: IFFALSE 64529
// begin for j in cranes do
64395: LD_ADDR_VAR 0 3
64399: PUSH
64400: LD_VAR 0 6
64404: PUSH
64405: FOR_IN
64406: IFFALSE 64527
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
64408: LD_VAR 0 3
64412: PPUSH
64413: CALL_OW 256
64417: PUSH
64418: LD_INT 1000
64420: EQUAL
64421: PUSH
64422: LD_VAR 0 3
64426: PPUSH
64427: CALL_OW 314
64431: NOT
64432: AND
64433: IFFALSE 64467
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
64435: LD_VAR 0 3
64439: PPUSH
64440: LD_EXP 61
64444: PUSH
64445: LD_VAR 0 2
64449: ARRAY
64450: PPUSH
64451: LD_VAR 0 3
64455: PPUSH
64456: CALL_OW 74
64460: PPUSH
64461: CALL_OW 130
64465: GO 64525
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
64467: LD_VAR 0 3
64471: PPUSH
64472: CALL_OW 256
64476: PUSH
64477: LD_INT 500
64479: LESS
64480: PUSH
64481: LD_VAR 0 3
64485: PPUSH
64486: LD_EXP 84
64490: PUSH
64491: LD_VAR 0 2
64495: ARRAY
64496: PPUSH
64497: CALL_OW 308
64501: NOT
64502: AND
64503: IFFALSE 64525
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64505: LD_VAR 0 3
64509: PPUSH
64510: LD_EXP 84
64514: PUSH
64515: LD_VAR 0 2
64519: ARRAY
64520: PPUSH
64521: CALL_OW 113
// end ;
64525: GO 64405
64527: POP
64528: POP
// end ; if tmp > 3 then
64529: LD_VAR 0 5
64533: PUSH
64534: LD_INT 3
64536: GREATER
64537: IFFALSE 64557
// tmp := ShrinkArray ( tmp , 4 ) ;
64539: LD_ADDR_VAR 0 5
64543: PUSH
64544: LD_VAR 0 5
64548: PPUSH
64549: LD_INT 4
64551: PPUSH
64552: CALL 51834 0 2
64556: ST_TO_ADDR
// if not tmp then
64557: LD_VAR 0 5
64561: NOT
64562: IFFALSE 64566
// continue ;
64564: GO 63974
// for j in tmp do
64566: LD_ADDR_VAR 0 3
64570: PUSH
64571: LD_VAR 0 5
64575: PUSH
64576: FOR_IN
64577: IFFALSE 64836
// begin if IsInUnit ( j ) then
64579: LD_VAR 0 3
64583: PPUSH
64584: CALL_OW 310
64588: IFFALSE 64599
// ComExitBuilding ( j ) ;
64590: LD_VAR 0 3
64594: PPUSH
64595: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64599: LD_VAR 0 3
64603: PUSH
64604: LD_EXP 62
64608: PUSH
64609: LD_VAR 0 2
64613: ARRAY
64614: IN
64615: NOT
64616: IFFALSE 64674
// begin SetTag ( j , 101 ) ;
64618: LD_VAR 0 3
64622: PPUSH
64623: LD_INT 101
64625: PPUSH
64626: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64630: LD_ADDR_EXP 62
64634: PUSH
64635: LD_EXP 62
64639: PPUSH
64640: LD_VAR 0 2
64644: PUSH
64645: LD_EXP 62
64649: PUSH
64650: LD_VAR 0 2
64654: ARRAY
64655: PUSH
64656: LD_INT 1
64658: PLUS
64659: PUSH
64660: EMPTY
64661: LIST
64662: LIST
64663: PPUSH
64664: LD_VAR 0 3
64668: PPUSH
64669: CALL 19824 0 3
64673: ST_TO_ADDR
// end ; wait ( 1 ) ;
64674: LD_INT 1
64676: PPUSH
64677: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
64681: LD_ADDR_VAR 0 7
64685: PUSH
64686: LD_EXP 61
64690: PUSH
64691: LD_VAR 0 2
64695: ARRAY
64696: ST_TO_ADDR
// if mc_scan [ i ] then
64697: LD_EXP 83
64701: PUSH
64702: LD_VAR 0 2
64706: ARRAY
64707: IFFALSE 64769
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
64709: LD_ADDR_VAR 0 7
64713: PUSH
64714: LD_EXP 61
64718: PUSH
64719: LD_VAR 0 2
64723: ARRAY
64724: PPUSH
64725: LD_INT 3
64727: PUSH
64728: LD_INT 30
64730: PUSH
64731: LD_INT 32
64733: PUSH
64734: EMPTY
64735: LIST
64736: LIST
64737: PUSH
64738: LD_INT 30
64740: PUSH
64741: LD_INT 33
64743: PUSH
64744: EMPTY
64745: LIST
64746: LIST
64747: PUSH
64748: LD_INT 30
64750: PUSH
64751: LD_INT 31
64753: PUSH
64754: EMPTY
64755: LIST
64756: LIST
64757: PUSH
64758: EMPTY
64759: LIST
64760: LIST
64761: LIST
64762: LIST
64763: PPUSH
64764: CALL_OW 72
64768: ST_TO_ADDR
// if not to_repair_tmp then
64769: LD_VAR 0 7
64773: NOT
64774: IFFALSE 64778
// continue ;
64776: GO 64576
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
64778: LD_ADDR_VAR 0 8
64782: PUSH
64783: LD_VAR 0 7
64787: PPUSH
64788: LD_VAR 0 3
64792: PPUSH
64793: CALL_OW 74
64797: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
64798: LD_VAR 0 8
64802: PPUSH
64803: LD_INT 16
64805: PPUSH
64806: CALL 22423 0 2
64810: PUSH
64811: LD_INT 4
64813: ARRAY
64814: PUSH
64815: LD_INT 10
64817: LESS
64818: IFFALSE 64834
// ComRepairBuilding ( j , to_repair ) ;
64820: LD_VAR 0 3
64824: PPUSH
64825: LD_VAR 0 8
64829: PPUSH
64830: CALL_OW 130
// end ;
64834: GO 64576
64836: POP
64837: POP
// end ;
64838: GO 63974
64840: POP
64841: POP
// end ;
64842: LD_VAR 0 1
64846: RET
// export function MC_Heal ; var i , j , tmp ; begin
64847: LD_INT 0
64849: PPUSH
64850: PPUSH
64851: PPUSH
64852: PPUSH
// if not mc_bases then
64853: LD_EXP 60
64857: NOT
64858: IFFALSE 64862
// exit ;
64860: GO 65264
// for i = 1 to mc_bases do
64862: LD_ADDR_VAR 0 2
64866: PUSH
64867: DOUBLE
64868: LD_INT 1
64870: DEC
64871: ST_TO_ADDR
64872: LD_EXP 60
64876: PUSH
64877: FOR_TO
64878: IFFALSE 65262
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64880: LD_EXP 63
64884: PUSH
64885: LD_VAR 0 2
64889: ARRAY
64890: PUSH
64891: LD_INT 1
64893: ARRAY
64894: NOT
64895: PUSH
64896: LD_EXP 63
64900: PUSH
64901: LD_VAR 0 2
64905: ARRAY
64906: PUSH
64907: LD_INT 2
64909: ARRAY
64910: NOT
64911: AND
64912: IFFALSE 64950
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64914: LD_ADDR_EXP 64
64918: PUSH
64919: LD_EXP 64
64923: PPUSH
64924: LD_VAR 0 2
64928: PPUSH
64929: EMPTY
64930: PPUSH
64931: CALL_OW 1
64935: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64936: LD_VAR 0 2
64940: PPUSH
64941: LD_INT 102
64943: PPUSH
64944: CALL 59027 0 2
// continue ;
64948: GO 64877
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64950: LD_ADDR_VAR 0 4
64954: PUSH
64955: LD_EXP 60
64959: PUSH
64960: LD_VAR 0 2
64964: ARRAY
64965: PPUSH
64966: LD_INT 25
64968: PUSH
64969: LD_INT 4
64971: PUSH
64972: EMPTY
64973: LIST
64974: LIST
64975: PPUSH
64976: CALL_OW 72
64980: ST_TO_ADDR
// if not tmp then
64981: LD_VAR 0 4
64985: NOT
64986: IFFALSE 64990
// continue ;
64988: GO 64877
// if mc_taming [ i ] then
64990: LD_EXP 91
64994: PUSH
64995: LD_VAR 0 2
64999: ARRAY
65000: IFFALSE 65024
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65002: LD_ADDR_EXP 91
65006: PUSH
65007: LD_EXP 91
65011: PPUSH
65012: LD_VAR 0 2
65016: PPUSH
65017: EMPTY
65018: PPUSH
65019: CALL_OW 1
65023: ST_TO_ADDR
// for j in tmp do
65024: LD_ADDR_VAR 0 3
65028: PUSH
65029: LD_VAR 0 4
65033: PUSH
65034: FOR_IN
65035: IFFALSE 65258
// begin if IsInUnit ( j ) then
65037: LD_VAR 0 3
65041: PPUSH
65042: CALL_OW 310
65046: IFFALSE 65057
// ComExitBuilding ( j ) ;
65048: LD_VAR 0 3
65052: PPUSH
65053: CALL_OW 122
// if not j in mc_healers [ i ] then
65057: LD_VAR 0 3
65061: PUSH
65062: LD_EXP 64
65066: PUSH
65067: LD_VAR 0 2
65071: ARRAY
65072: IN
65073: NOT
65074: IFFALSE 65120
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
65076: LD_ADDR_EXP 64
65080: PUSH
65081: LD_EXP 64
65085: PPUSH
65086: LD_VAR 0 2
65090: PUSH
65091: LD_EXP 64
65095: PUSH
65096: LD_VAR 0 2
65100: ARRAY
65101: PUSH
65102: LD_INT 1
65104: PLUS
65105: PUSH
65106: EMPTY
65107: LIST
65108: LIST
65109: PPUSH
65110: LD_VAR 0 3
65114: PPUSH
65115: CALL 19824 0 3
65119: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
65120: LD_VAR 0 3
65124: PPUSH
65125: CALL_OW 110
65129: PUSH
65130: LD_INT 102
65132: NONEQUAL
65133: IFFALSE 65147
// SetTag ( j , 102 ) ;
65135: LD_VAR 0 3
65139: PPUSH
65140: LD_INT 102
65142: PPUSH
65143: CALL_OW 109
// Wait ( 3 ) ;
65147: LD_INT 3
65149: PPUSH
65150: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
65154: LD_EXP 63
65158: PUSH
65159: LD_VAR 0 2
65163: ARRAY
65164: PUSH
65165: LD_INT 1
65167: ARRAY
65168: IFFALSE 65200
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
65170: LD_VAR 0 3
65174: PPUSH
65175: LD_EXP 63
65179: PUSH
65180: LD_VAR 0 2
65184: ARRAY
65185: PUSH
65186: LD_INT 1
65188: ARRAY
65189: PUSH
65190: LD_INT 1
65192: ARRAY
65193: PPUSH
65194: CALL_OW 128
65198: GO 65256
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65200: LD_VAR 0 3
65204: PPUSH
65205: CALL_OW 314
65209: NOT
65210: PUSH
65211: LD_EXP 63
65215: PUSH
65216: LD_VAR 0 2
65220: ARRAY
65221: PUSH
65222: LD_INT 2
65224: ARRAY
65225: AND
65226: IFFALSE 65256
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65228: LD_VAR 0 3
65232: PPUSH
65233: LD_EXP 63
65237: PUSH
65238: LD_VAR 0 2
65242: ARRAY
65243: PUSH
65244: LD_INT 2
65246: ARRAY
65247: PUSH
65248: LD_INT 1
65250: ARRAY
65251: PPUSH
65252: CALL_OW 128
// end ;
65256: GO 65034
65258: POP
65259: POP
// end ;
65260: GO 64877
65262: POP
65263: POP
// end ;
65264: LD_VAR 0 1
65268: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
65269: LD_INT 0
65271: PPUSH
65272: PPUSH
65273: PPUSH
65274: PPUSH
65275: PPUSH
// if not mc_bases then
65276: LD_EXP 60
65280: NOT
65281: IFFALSE 65285
// exit ;
65283: GO 66456
// for i = 1 to mc_bases do
65285: LD_ADDR_VAR 0 2
65289: PUSH
65290: DOUBLE
65291: LD_INT 1
65293: DEC
65294: ST_TO_ADDR
65295: LD_EXP 60
65299: PUSH
65300: FOR_TO
65301: IFFALSE 66454
// begin if mc_scan [ i ] then
65303: LD_EXP 83
65307: PUSH
65308: LD_VAR 0 2
65312: ARRAY
65313: IFFALSE 65317
// continue ;
65315: GO 65300
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65317: LD_EXP 65
65321: PUSH
65322: LD_VAR 0 2
65326: ARRAY
65327: NOT
65328: PUSH
65329: LD_EXP 67
65333: PUSH
65334: LD_VAR 0 2
65338: ARRAY
65339: NOT
65340: AND
65341: PUSH
65342: LD_EXP 66
65346: PUSH
65347: LD_VAR 0 2
65351: ARRAY
65352: AND
65353: IFFALSE 65391
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65355: LD_ADDR_EXP 66
65359: PUSH
65360: LD_EXP 66
65364: PPUSH
65365: LD_VAR 0 2
65369: PPUSH
65370: EMPTY
65371: PPUSH
65372: CALL_OW 1
65376: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65377: LD_VAR 0 2
65381: PPUSH
65382: LD_INT 103
65384: PPUSH
65385: CALL 59027 0 2
// continue ;
65389: GO 65300
// end ; if mc_construct_list [ i ] then
65391: LD_EXP 67
65395: PUSH
65396: LD_VAR 0 2
65400: ARRAY
65401: IFFALSE 65621
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65403: LD_ADDR_VAR 0 4
65407: PUSH
65408: LD_EXP 60
65412: PUSH
65413: LD_VAR 0 2
65417: ARRAY
65418: PPUSH
65419: LD_INT 25
65421: PUSH
65422: LD_INT 2
65424: PUSH
65425: EMPTY
65426: LIST
65427: LIST
65428: PPUSH
65429: CALL_OW 72
65433: PUSH
65434: LD_EXP 62
65438: PUSH
65439: LD_VAR 0 2
65443: ARRAY
65444: DIFF
65445: ST_TO_ADDR
// if not tmp then
65446: LD_VAR 0 4
65450: NOT
65451: IFFALSE 65455
// continue ;
65453: GO 65300
// for j in tmp do
65455: LD_ADDR_VAR 0 3
65459: PUSH
65460: LD_VAR 0 4
65464: PUSH
65465: FOR_IN
65466: IFFALSE 65617
// begin if not mc_builders [ i ] then
65468: LD_EXP 66
65472: PUSH
65473: LD_VAR 0 2
65477: ARRAY
65478: NOT
65479: IFFALSE 65537
// begin SetTag ( j , 103 ) ;
65481: LD_VAR 0 3
65485: PPUSH
65486: LD_INT 103
65488: PPUSH
65489: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65493: LD_ADDR_EXP 66
65497: PUSH
65498: LD_EXP 66
65502: PPUSH
65503: LD_VAR 0 2
65507: PUSH
65508: LD_EXP 66
65512: PUSH
65513: LD_VAR 0 2
65517: ARRAY
65518: PUSH
65519: LD_INT 1
65521: PLUS
65522: PUSH
65523: EMPTY
65524: LIST
65525: LIST
65526: PPUSH
65527: LD_VAR 0 3
65531: PPUSH
65532: CALL 19824 0 3
65536: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65537: LD_VAR 0 3
65541: PPUSH
65542: CALL_OW 310
65546: IFFALSE 65557
// ComExitBuilding ( j ) ;
65548: LD_VAR 0 3
65552: PPUSH
65553: CALL_OW 122
// wait ( 3 ) ;
65557: LD_INT 3
65559: PPUSH
65560: CALL_OW 67
// if not mc_construct_list [ i ] then
65564: LD_EXP 67
65568: PUSH
65569: LD_VAR 0 2
65573: ARRAY
65574: NOT
65575: IFFALSE 65579
// break ;
65577: GO 65617
// if not HasTask ( j ) then
65579: LD_VAR 0 3
65583: PPUSH
65584: CALL_OW 314
65588: NOT
65589: IFFALSE 65615
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65591: LD_VAR 0 3
65595: PPUSH
65596: LD_EXP 67
65600: PUSH
65601: LD_VAR 0 2
65605: ARRAY
65606: PUSH
65607: LD_INT 1
65609: ARRAY
65610: PPUSH
65611: CALL 22687 0 2
// end ;
65615: GO 65465
65617: POP
65618: POP
// end else
65619: GO 66452
// if mc_build_list [ i ] then
65621: LD_EXP 65
65625: PUSH
65626: LD_VAR 0 2
65630: ARRAY
65631: IFFALSE 66452
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65633: LD_ADDR_VAR 0 5
65637: PUSH
65638: LD_EXP 60
65642: PUSH
65643: LD_VAR 0 2
65647: ARRAY
65648: PPUSH
65649: LD_INT 2
65651: PUSH
65652: LD_INT 30
65654: PUSH
65655: LD_INT 0
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: LD_INT 30
65664: PUSH
65665: LD_INT 1
65667: PUSH
65668: EMPTY
65669: LIST
65670: LIST
65671: PUSH
65672: EMPTY
65673: LIST
65674: LIST
65675: LIST
65676: PPUSH
65677: CALL_OW 72
65681: ST_TO_ADDR
// if depot then
65682: LD_VAR 0 5
65686: IFFALSE 65704
// depot := depot [ 1 ] else
65688: LD_ADDR_VAR 0 5
65692: PUSH
65693: LD_VAR 0 5
65697: PUSH
65698: LD_INT 1
65700: ARRAY
65701: ST_TO_ADDR
65702: GO 65712
// depot := 0 ;
65704: LD_ADDR_VAR 0 5
65708: PUSH
65709: LD_INT 0
65711: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65712: LD_EXP 65
65716: PUSH
65717: LD_VAR 0 2
65721: ARRAY
65722: PUSH
65723: LD_INT 1
65725: ARRAY
65726: PUSH
65727: LD_INT 1
65729: ARRAY
65730: PPUSH
65731: CALL 22511 0 1
65735: PUSH
65736: LD_EXP 60
65740: PUSH
65741: LD_VAR 0 2
65745: ARRAY
65746: PPUSH
65747: LD_INT 2
65749: PUSH
65750: LD_INT 30
65752: PUSH
65753: LD_INT 2
65755: PUSH
65756: EMPTY
65757: LIST
65758: LIST
65759: PUSH
65760: LD_INT 30
65762: PUSH
65763: LD_INT 3
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: EMPTY
65771: LIST
65772: LIST
65773: LIST
65774: PPUSH
65775: CALL_OW 72
65779: NOT
65780: AND
65781: IFFALSE 65886
// begin for j = 1 to mc_build_list [ i ] do
65783: LD_ADDR_VAR 0 3
65787: PUSH
65788: DOUBLE
65789: LD_INT 1
65791: DEC
65792: ST_TO_ADDR
65793: LD_EXP 65
65797: PUSH
65798: LD_VAR 0 2
65802: ARRAY
65803: PUSH
65804: FOR_TO
65805: IFFALSE 65884
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65807: LD_EXP 65
65811: PUSH
65812: LD_VAR 0 2
65816: ARRAY
65817: PUSH
65818: LD_VAR 0 3
65822: ARRAY
65823: PUSH
65824: LD_INT 1
65826: ARRAY
65827: PUSH
65828: LD_INT 2
65830: EQUAL
65831: IFFALSE 65882
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65833: LD_ADDR_EXP 65
65837: PUSH
65838: LD_EXP 65
65842: PPUSH
65843: LD_VAR 0 2
65847: PPUSH
65848: LD_EXP 65
65852: PUSH
65853: LD_VAR 0 2
65857: ARRAY
65858: PPUSH
65859: LD_VAR 0 3
65863: PPUSH
65864: LD_INT 1
65866: PPUSH
65867: LD_INT 0
65869: PPUSH
65870: CALL 19242 0 4
65874: PPUSH
65875: CALL_OW 1
65879: ST_TO_ADDR
// break ;
65880: GO 65884
// end ;
65882: GO 65804
65884: POP
65885: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
65886: LD_EXP 65
65890: PUSH
65891: LD_VAR 0 2
65895: ARRAY
65896: PUSH
65897: LD_INT 1
65899: ARRAY
65900: PUSH
65901: LD_INT 1
65903: ARRAY
65904: PUSH
65905: LD_INT 0
65907: EQUAL
65908: PUSH
65909: LD_VAR 0 5
65913: PUSH
65914: LD_VAR 0 5
65918: PPUSH
65919: LD_EXP 65
65923: PUSH
65924: LD_VAR 0 2
65928: ARRAY
65929: PUSH
65930: LD_INT 1
65932: ARRAY
65933: PUSH
65934: LD_INT 1
65936: ARRAY
65937: PPUSH
65938: LD_EXP 65
65942: PUSH
65943: LD_VAR 0 2
65947: ARRAY
65948: PUSH
65949: LD_INT 1
65951: ARRAY
65952: PUSH
65953: LD_INT 2
65955: ARRAY
65956: PPUSH
65957: LD_EXP 65
65961: PUSH
65962: LD_VAR 0 2
65966: ARRAY
65967: PUSH
65968: LD_INT 1
65970: ARRAY
65971: PUSH
65972: LD_INT 3
65974: ARRAY
65975: PPUSH
65976: LD_EXP 65
65980: PUSH
65981: LD_VAR 0 2
65985: ARRAY
65986: PUSH
65987: LD_INT 1
65989: ARRAY
65990: PUSH
65991: LD_INT 4
65993: ARRAY
65994: PPUSH
65995: CALL 27927 0 5
65999: AND
66000: OR
66001: IFFALSE 66282
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66003: LD_ADDR_VAR 0 4
66007: PUSH
66008: LD_EXP 60
66012: PUSH
66013: LD_VAR 0 2
66017: ARRAY
66018: PPUSH
66019: LD_INT 25
66021: PUSH
66022: LD_INT 2
66024: PUSH
66025: EMPTY
66026: LIST
66027: LIST
66028: PPUSH
66029: CALL_OW 72
66033: PUSH
66034: LD_EXP 62
66038: PUSH
66039: LD_VAR 0 2
66043: ARRAY
66044: DIFF
66045: ST_TO_ADDR
// if not tmp then
66046: LD_VAR 0 4
66050: NOT
66051: IFFALSE 66055
// continue ;
66053: GO 65300
// for j in tmp do
66055: LD_ADDR_VAR 0 3
66059: PUSH
66060: LD_VAR 0 4
66064: PUSH
66065: FOR_IN
66066: IFFALSE 66278
// begin if not mc_builders [ i ] then
66068: LD_EXP 66
66072: PUSH
66073: LD_VAR 0 2
66077: ARRAY
66078: NOT
66079: IFFALSE 66137
// begin SetTag ( j , 103 ) ;
66081: LD_VAR 0 3
66085: PPUSH
66086: LD_INT 103
66088: PPUSH
66089: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66093: LD_ADDR_EXP 66
66097: PUSH
66098: LD_EXP 66
66102: PPUSH
66103: LD_VAR 0 2
66107: PUSH
66108: LD_EXP 66
66112: PUSH
66113: LD_VAR 0 2
66117: ARRAY
66118: PUSH
66119: LD_INT 1
66121: PLUS
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PPUSH
66127: LD_VAR 0 3
66131: PPUSH
66132: CALL 19824 0 3
66136: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66137: LD_VAR 0 3
66141: PPUSH
66142: CALL_OW 310
66146: IFFALSE 66157
// ComExitBuilding ( j ) ;
66148: LD_VAR 0 3
66152: PPUSH
66153: CALL_OW 122
// wait ( 3 ) ;
66157: LD_INT 3
66159: PPUSH
66160: CALL_OW 67
// if not mc_build_list [ i ] then
66164: LD_EXP 65
66168: PUSH
66169: LD_VAR 0 2
66173: ARRAY
66174: NOT
66175: IFFALSE 66179
// break ;
66177: GO 66278
// if not HasTask ( j ) then
66179: LD_VAR 0 3
66183: PPUSH
66184: CALL_OW 314
66188: NOT
66189: IFFALSE 66276
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66191: LD_VAR 0 3
66195: PPUSH
66196: LD_EXP 65
66200: PUSH
66201: LD_VAR 0 2
66205: ARRAY
66206: PUSH
66207: LD_INT 1
66209: ARRAY
66210: PUSH
66211: LD_INT 1
66213: ARRAY
66214: PPUSH
66215: LD_EXP 65
66219: PUSH
66220: LD_VAR 0 2
66224: ARRAY
66225: PUSH
66226: LD_INT 1
66228: ARRAY
66229: PUSH
66230: LD_INT 2
66232: ARRAY
66233: PPUSH
66234: LD_EXP 65
66238: PUSH
66239: LD_VAR 0 2
66243: ARRAY
66244: PUSH
66245: LD_INT 1
66247: ARRAY
66248: PUSH
66249: LD_INT 3
66251: ARRAY
66252: PPUSH
66253: LD_EXP 65
66257: PUSH
66258: LD_VAR 0 2
66262: ARRAY
66263: PUSH
66264: LD_INT 1
66266: ARRAY
66267: PUSH
66268: LD_INT 4
66270: ARRAY
66271: PPUSH
66272: CALL_OW 145
// end ;
66276: GO 66065
66278: POP
66279: POP
// end else
66280: GO 66452
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
66282: LD_EXP 60
66286: PUSH
66287: LD_VAR 0 2
66291: ARRAY
66292: PPUSH
66293: LD_EXP 65
66297: PUSH
66298: LD_VAR 0 2
66302: ARRAY
66303: PUSH
66304: LD_INT 1
66306: ARRAY
66307: PUSH
66308: LD_INT 1
66310: ARRAY
66311: PPUSH
66312: LD_EXP 65
66316: PUSH
66317: LD_VAR 0 2
66321: ARRAY
66322: PUSH
66323: LD_INT 1
66325: ARRAY
66326: PUSH
66327: LD_INT 2
66329: ARRAY
66330: PPUSH
66331: LD_EXP 65
66335: PUSH
66336: LD_VAR 0 2
66340: ARRAY
66341: PUSH
66342: LD_INT 1
66344: ARRAY
66345: PUSH
66346: LD_INT 3
66348: ARRAY
66349: PPUSH
66350: LD_EXP 65
66354: PUSH
66355: LD_VAR 0 2
66359: ARRAY
66360: PUSH
66361: LD_INT 1
66363: ARRAY
66364: PUSH
66365: LD_INT 4
66367: ARRAY
66368: PPUSH
66369: LD_EXP 60
66373: PUSH
66374: LD_VAR 0 2
66378: ARRAY
66379: PPUSH
66380: LD_INT 21
66382: PUSH
66383: LD_INT 3
66385: PUSH
66386: EMPTY
66387: LIST
66388: LIST
66389: PPUSH
66390: CALL_OW 72
66394: PPUSH
66395: EMPTY
66396: PPUSH
66397: CALL 26677 0 7
66401: NOT
66402: IFFALSE 66452
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66404: LD_ADDR_EXP 65
66408: PUSH
66409: LD_EXP 65
66413: PPUSH
66414: LD_VAR 0 2
66418: PPUSH
66419: LD_EXP 65
66423: PUSH
66424: LD_VAR 0 2
66428: ARRAY
66429: PPUSH
66430: LD_INT 1
66432: PPUSH
66433: LD_INT 1
66435: NEG
66436: PPUSH
66437: LD_INT 0
66439: PPUSH
66440: CALL 19242 0 4
66444: PPUSH
66445: CALL_OW 1
66449: ST_TO_ADDR
// continue ;
66450: GO 65300
// end ; end ; end ;
66452: GO 65300
66454: POP
66455: POP
// end ;
66456: LD_VAR 0 1
66460: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
66461: LD_INT 0
66463: PPUSH
66464: PPUSH
66465: PPUSH
66466: PPUSH
66467: PPUSH
66468: PPUSH
// if not mc_bases then
66469: LD_EXP 60
66473: NOT
66474: IFFALSE 66478
// exit ;
66476: GO 66905
// for i = 1 to mc_bases do
66478: LD_ADDR_VAR 0 2
66482: PUSH
66483: DOUBLE
66484: LD_INT 1
66486: DEC
66487: ST_TO_ADDR
66488: LD_EXP 60
66492: PUSH
66493: FOR_TO
66494: IFFALSE 66903
// begin tmp := mc_build_upgrade [ i ] ;
66496: LD_ADDR_VAR 0 4
66500: PUSH
66501: LD_EXP 92
66505: PUSH
66506: LD_VAR 0 2
66510: ARRAY
66511: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66512: LD_ADDR_VAR 0 6
66516: PUSH
66517: LD_EXP 93
66521: PUSH
66522: LD_VAR 0 2
66526: ARRAY
66527: PPUSH
66528: LD_INT 2
66530: PUSH
66531: LD_INT 30
66533: PUSH
66534: LD_INT 6
66536: PUSH
66537: EMPTY
66538: LIST
66539: LIST
66540: PUSH
66541: LD_INT 30
66543: PUSH
66544: LD_INT 7
66546: PUSH
66547: EMPTY
66548: LIST
66549: LIST
66550: PUSH
66551: EMPTY
66552: LIST
66553: LIST
66554: LIST
66555: PPUSH
66556: CALL_OW 72
66560: ST_TO_ADDR
// if not tmp and not lab then
66561: LD_VAR 0 4
66565: NOT
66566: PUSH
66567: LD_VAR 0 6
66571: NOT
66572: AND
66573: IFFALSE 66577
// continue ;
66575: GO 66493
// if tmp then
66577: LD_VAR 0 4
66581: IFFALSE 66701
// for j in tmp do
66583: LD_ADDR_VAR 0 3
66587: PUSH
66588: LD_VAR 0 4
66592: PUSH
66593: FOR_IN
66594: IFFALSE 66699
// begin if UpgradeCost ( j ) then
66596: LD_VAR 0 3
66600: PPUSH
66601: CALL 26337 0 1
66605: IFFALSE 66697
// begin ComUpgrade ( j ) ;
66607: LD_VAR 0 3
66611: PPUSH
66612: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66616: LD_ADDR_EXP 92
66620: PUSH
66621: LD_EXP 92
66625: PPUSH
66626: LD_VAR 0 2
66630: PPUSH
66631: LD_EXP 92
66635: PUSH
66636: LD_VAR 0 2
66640: ARRAY
66641: PUSH
66642: LD_VAR 0 3
66646: DIFF
66647: PPUSH
66648: CALL_OW 1
66652: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66653: LD_ADDR_EXP 67
66657: PUSH
66658: LD_EXP 67
66662: PPUSH
66663: LD_VAR 0 2
66667: PUSH
66668: LD_EXP 67
66672: PUSH
66673: LD_VAR 0 2
66677: ARRAY
66678: PUSH
66679: LD_INT 1
66681: PLUS
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PPUSH
66687: LD_VAR 0 3
66691: PPUSH
66692: CALL 19824 0 3
66696: ST_TO_ADDR
// end ; end ;
66697: GO 66593
66699: POP
66700: POP
// if not lab or not mc_lab_upgrade [ i ] then
66701: LD_VAR 0 6
66705: NOT
66706: PUSH
66707: LD_EXP 94
66711: PUSH
66712: LD_VAR 0 2
66716: ARRAY
66717: NOT
66718: OR
66719: IFFALSE 66723
// continue ;
66721: GO 66493
// for j in lab do
66723: LD_ADDR_VAR 0 3
66727: PUSH
66728: LD_VAR 0 6
66732: PUSH
66733: FOR_IN
66734: IFFALSE 66899
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66736: LD_VAR 0 3
66740: PPUSH
66741: CALL_OW 266
66745: PUSH
66746: LD_INT 6
66748: PUSH
66749: LD_INT 7
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: IN
66756: PUSH
66757: LD_VAR 0 3
66761: PPUSH
66762: CALL_OW 461
66766: PUSH
66767: LD_INT 1
66769: NONEQUAL
66770: AND
66771: IFFALSE 66897
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66773: LD_VAR 0 3
66777: PPUSH
66778: LD_EXP 94
66782: PUSH
66783: LD_VAR 0 2
66787: ARRAY
66788: PUSH
66789: LD_INT 1
66791: ARRAY
66792: PPUSH
66793: CALL 26542 0 2
66797: IFFALSE 66897
// begin ComCancel ( j ) ;
66799: LD_VAR 0 3
66803: PPUSH
66804: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66808: LD_VAR 0 3
66812: PPUSH
66813: LD_EXP 94
66817: PUSH
66818: LD_VAR 0 2
66822: ARRAY
66823: PUSH
66824: LD_INT 1
66826: ARRAY
66827: PPUSH
66828: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66832: LD_VAR 0 3
66836: PUSH
66837: LD_EXP 67
66841: PUSH
66842: LD_VAR 0 2
66846: ARRAY
66847: IN
66848: NOT
66849: IFFALSE 66895
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66851: LD_ADDR_EXP 67
66855: PUSH
66856: LD_EXP 67
66860: PPUSH
66861: LD_VAR 0 2
66865: PUSH
66866: LD_EXP 67
66870: PUSH
66871: LD_VAR 0 2
66875: ARRAY
66876: PUSH
66877: LD_INT 1
66879: PLUS
66880: PUSH
66881: EMPTY
66882: LIST
66883: LIST
66884: PPUSH
66885: LD_VAR 0 3
66889: PPUSH
66890: CALL 19824 0 3
66894: ST_TO_ADDR
// break ;
66895: GO 66899
// end ; end ; end ;
66897: GO 66733
66899: POP
66900: POP
// end ;
66901: GO 66493
66903: POP
66904: POP
// end ;
66905: LD_VAR 0 1
66909: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66910: LD_INT 0
66912: PPUSH
66913: PPUSH
66914: PPUSH
66915: PPUSH
66916: PPUSH
66917: PPUSH
66918: PPUSH
66919: PPUSH
66920: PPUSH
// if not mc_bases then
66921: LD_EXP 60
66925: NOT
66926: IFFALSE 66930
// exit ;
66928: GO 67335
// for i = 1 to mc_bases do
66930: LD_ADDR_VAR 0 2
66934: PUSH
66935: DOUBLE
66936: LD_INT 1
66938: DEC
66939: ST_TO_ADDR
66940: LD_EXP 60
66944: PUSH
66945: FOR_TO
66946: IFFALSE 67333
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66948: LD_EXP 68
66952: PUSH
66953: LD_VAR 0 2
66957: ARRAY
66958: NOT
66959: PUSH
66960: LD_EXP 60
66964: PUSH
66965: LD_VAR 0 2
66969: ARRAY
66970: PPUSH
66971: LD_INT 30
66973: PUSH
66974: LD_INT 3
66976: PUSH
66977: EMPTY
66978: LIST
66979: LIST
66980: PPUSH
66981: CALL_OW 72
66985: NOT
66986: OR
66987: IFFALSE 66991
// continue ;
66989: GO 66945
// busy := false ;
66991: LD_ADDR_VAR 0 8
66995: PUSH
66996: LD_INT 0
66998: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66999: LD_ADDR_VAR 0 4
67003: PUSH
67004: LD_EXP 60
67008: PUSH
67009: LD_VAR 0 2
67013: ARRAY
67014: PPUSH
67015: LD_INT 30
67017: PUSH
67018: LD_INT 3
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: PPUSH
67025: CALL_OW 72
67029: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
67030: LD_ADDR_VAR 0 6
67034: PUSH
67035: LD_EXP 68
67039: PUSH
67040: LD_VAR 0 2
67044: ARRAY
67045: PPUSH
67046: LD_INT 2
67048: PUSH
67049: LD_INT 30
67051: PUSH
67052: LD_INT 32
67054: PUSH
67055: EMPTY
67056: LIST
67057: LIST
67058: PUSH
67059: LD_INT 30
67061: PUSH
67062: LD_INT 33
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: PUSH
67069: EMPTY
67070: LIST
67071: LIST
67072: LIST
67073: PPUSH
67074: CALL_OW 72
67078: ST_TO_ADDR
// if not t then
67079: LD_VAR 0 6
67083: NOT
67084: IFFALSE 67088
// continue ;
67086: GO 66945
// for j in tmp do
67088: LD_ADDR_VAR 0 3
67092: PUSH
67093: LD_VAR 0 4
67097: PUSH
67098: FOR_IN
67099: IFFALSE 67129
// if not BuildingStatus ( j ) = bs_idle then
67101: LD_VAR 0 3
67105: PPUSH
67106: CALL_OW 461
67110: PUSH
67111: LD_INT 2
67113: EQUAL
67114: NOT
67115: IFFALSE 67127
// begin busy := true ;
67117: LD_ADDR_VAR 0 8
67121: PUSH
67122: LD_INT 1
67124: ST_TO_ADDR
// break ;
67125: GO 67129
// end ;
67127: GO 67098
67129: POP
67130: POP
// if busy then
67131: LD_VAR 0 8
67135: IFFALSE 67139
// continue ;
67137: GO 66945
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
67139: LD_ADDR_VAR 0 7
67143: PUSH
67144: LD_VAR 0 6
67148: PPUSH
67149: LD_INT 35
67151: PUSH
67152: LD_INT 0
67154: PUSH
67155: EMPTY
67156: LIST
67157: LIST
67158: PPUSH
67159: CALL_OW 72
67163: ST_TO_ADDR
// if tw then
67164: LD_VAR 0 7
67168: IFFALSE 67245
// begin tw := tw [ 1 ] ;
67170: LD_ADDR_VAR 0 7
67174: PUSH
67175: LD_VAR 0 7
67179: PUSH
67180: LD_INT 1
67182: ARRAY
67183: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
67184: LD_ADDR_VAR 0 9
67188: PUSH
67189: LD_VAR 0 7
67193: PPUSH
67194: LD_EXP 85
67198: PUSH
67199: LD_VAR 0 2
67203: ARRAY
67204: PPUSH
67205: CALL 24834 0 2
67209: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67210: LD_EXP 99
67214: PUSH
67215: LD_VAR 0 2
67219: ARRAY
67220: IFFALSE 67243
// if not weapon in mc_allowed_tower_weapons [ i ] then
67222: LD_VAR 0 9
67226: PUSH
67227: LD_EXP 99
67231: PUSH
67232: LD_VAR 0 2
67236: ARRAY
67237: IN
67238: NOT
67239: IFFALSE 67243
// continue ;
67241: GO 66945
// end else
67243: GO 67308
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67245: LD_ADDR_VAR 0 5
67249: PUSH
67250: LD_EXP 68
67254: PUSH
67255: LD_VAR 0 2
67259: ARRAY
67260: PPUSH
67261: LD_VAR 0 4
67265: PPUSH
67266: CALL 51067 0 2
67270: ST_TO_ADDR
// if not tmp2 then
67271: LD_VAR 0 5
67275: NOT
67276: IFFALSE 67280
// continue ;
67278: GO 66945
// tw := tmp2 [ 1 ] ;
67280: LD_ADDR_VAR 0 7
67284: PUSH
67285: LD_VAR 0 5
67289: PUSH
67290: LD_INT 1
67292: ARRAY
67293: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67294: LD_ADDR_VAR 0 9
67298: PUSH
67299: LD_VAR 0 5
67303: PUSH
67304: LD_INT 2
67306: ARRAY
67307: ST_TO_ADDR
// end ; if not weapon then
67308: LD_VAR 0 9
67312: NOT
67313: IFFALSE 67317
// continue ;
67315: GO 66945
// ComPlaceWeapon ( tw , weapon ) ;
67317: LD_VAR 0 7
67321: PPUSH
67322: LD_VAR 0 9
67326: PPUSH
67327: CALL_OW 148
// end ;
67331: GO 66945
67333: POP
67334: POP
// end ;
67335: LD_VAR 0 1
67339: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
67340: LD_INT 0
67342: PPUSH
67343: PPUSH
67344: PPUSH
67345: PPUSH
67346: PPUSH
67347: PPUSH
67348: PPUSH
// if not mc_bases then
67349: LD_EXP 60
67353: NOT
67354: IFFALSE 67358
// exit ;
67356: GO 68126
// for i = 1 to mc_bases do
67358: LD_ADDR_VAR 0 2
67362: PUSH
67363: DOUBLE
67364: LD_INT 1
67366: DEC
67367: ST_TO_ADDR
67368: LD_EXP 60
67372: PUSH
67373: FOR_TO
67374: IFFALSE 68124
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
67376: LD_EXP 73
67380: PUSH
67381: LD_VAR 0 2
67385: ARRAY
67386: NOT
67387: PUSH
67388: LD_EXP 73
67392: PUSH
67393: LD_VAR 0 2
67397: ARRAY
67398: PUSH
67399: LD_EXP 74
67403: PUSH
67404: LD_VAR 0 2
67408: ARRAY
67409: EQUAL
67410: OR
67411: PUSH
67412: LD_EXP 83
67416: PUSH
67417: LD_VAR 0 2
67421: ARRAY
67422: OR
67423: IFFALSE 67427
// continue ;
67425: GO 67373
// if mc_miners [ i ] then
67427: LD_EXP 74
67431: PUSH
67432: LD_VAR 0 2
67436: ARRAY
67437: IFFALSE 67811
// begin for j = mc_miners [ i ] downto 1 do
67439: LD_ADDR_VAR 0 3
67443: PUSH
67444: DOUBLE
67445: LD_EXP 74
67449: PUSH
67450: LD_VAR 0 2
67454: ARRAY
67455: INC
67456: ST_TO_ADDR
67457: LD_INT 1
67459: PUSH
67460: FOR_DOWNTO
67461: IFFALSE 67809
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
67463: LD_EXP 74
67467: PUSH
67468: LD_VAR 0 2
67472: ARRAY
67473: PUSH
67474: LD_VAR 0 3
67478: ARRAY
67479: PPUSH
67480: CALL_OW 301
67484: PUSH
67485: LD_EXP 74
67489: PUSH
67490: LD_VAR 0 2
67494: ARRAY
67495: PUSH
67496: LD_VAR 0 3
67500: ARRAY
67501: PPUSH
67502: CALL_OW 257
67506: PUSH
67507: LD_INT 1
67509: NONEQUAL
67510: OR
67511: IFFALSE 67574
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67513: LD_ADDR_VAR 0 5
67517: PUSH
67518: LD_EXP 74
67522: PUSH
67523: LD_VAR 0 2
67527: ARRAY
67528: PUSH
67529: LD_EXP 74
67533: PUSH
67534: LD_VAR 0 2
67538: ARRAY
67539: PUSH
67540: LD_VAR 0 3
67544: ARRAY
67545: DIFF
67546: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67547: LD_ADDR_EXP 74
67551: PUSH
67552: LD_EXP 74
67556: PPUSH
67557: LD_VAR 0 2
67561: PPUSH
67562: LD_VAR 0 5
67566: PPUSH
67567: CALL_OW 1
67571: ST_TO_ADDR
// continue ;
67572: GO 67460
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
67574: LD_EXP 74
67578: PUSH
67579: LD_VAR 0 2
67583: ARRAY
67584: PUSH
67585: LD_VAR 0 3
67589: ARRAY
67590: PPUSH
67591: CALL_OW 257
67595: PUSH
67596: LD_INT 1
67598: EQUAL
67599: PUSH
67600: LD_EXP 74
67604: PUSH
67605: LD_VAR 0 2
67609: ARRAY
67610: PUSH
67611: LD_VAR 0 3
67615: ARRAY
67616: PPUSH
67617: CALL_OW 459
67621: NOT
67622: AND
67623: PUSH
67624: LD_EXP 74
67628: PUSH
67629: LD_VAR 0 2
67633: ARRAY
67634: PUSH
67635: LD_VAR 0 3
67639: ARRAY
67640: PPUSH
67641: CALL_OW 314
67645: NOT
67646: AND
67647: IFFALSE 67807
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67649: LD_EXP 74
67653: PUSH
67654: LD_VAR 0 2
67658: ARRAY
67659: PUSH
67660: LD_VAR 0 3
67664: ARRAY
67665: PPUSH
67666: CALL_OW 310
67670: IFFALSE 67693
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67672: LD_EXP 74
67676: PUSH
67677: LD_VAR 0 2
67681: ARRAY
67682: PUSH
67683: LD_VAR 0 3
67687: ARRAY
67688: PPUSH
67689: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67693: LD_EXP 74
67697: PUSH
67698: LD_VAR 0 2
67702: ARRAY
67703: PUSH
67704: LD_VAR 0 3
67708: ARRAY
67709: PPUSH
67710: CALL_OW 314
67714: NOT
67715: IFFALSE 67807
// begin r := rand ( 1 , mc_mines [ i ] ) ;
67717: LD_ADDR_VAR 0 7
67721: PUSH
67722: LD_INT 1
67724: PPUSH
67725: LD_EXP 73
67729: PUSH
67730: LD_VAR 0 2
67734: ARRAY
67735: PPUSH
67736: CALL_OW 12
67740: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
67741: LD_EXP 74
67745: PUSH
67746: LD_VAR 0 2
67750: ARRAY
67751: PUSH
67752: LD_VAR 0 3
67756: ARRAY
67757: PPUSH
67758: LD_EXP 73
67762: PUSH
67763: LD_VAR 0 2
67767: ARRAY
67768: PUSH
67769: LD_VAR 0 7
67773: ARRAY
67774: PUSH
67775: LD_INT 1
67777: ARRAY
67778: PPUSH
67779: LD_EXP 73
67783: PUSH
67784: LD_VAR 0 2
67788: ARRAY
67789: PUSH
67790: LD_VAR 0 7
67794: ARRAY
67795: PUSH
67796: LD_INT 2
67798: ARRAY
67799: PPUSH
67800: LD_INT 0
67802: PPUSH
67803: CALL_OW 193
// end ; end ; end ;
67807: GO 67460
67809: POP
67810: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67811: LD_ADDR_VAR 0 5
67815: PUSH
67816: LD_EXP 60
67820: PUSH
67821: LD_VAR 0 2
67825: ARRAY
67826: PPUSH
67827: LD_INT 2
67829: PUSH
67830: LD_INT 30
67832: PUSH
67833: LD_INT 4
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: PUSH
67840: LD_INT 30
67842: PUSH
67843: LD_INT 5
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: PUSH
67850: LD_INT 30
67852: PUSH
67853: LD_INT 32
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: LIST
67864: LIST
67865: PPUSH
67866: CALL_OW 72
67870: ST_TO_ADDR
// if not tmp then
67871: LD_VAR 0 5
67875: NOT
67876: IFFALSE 67880
// continue ;
67878: GO 67373
// list := [ ] ;
67880: LD_ADDR_VAR 0 6
67884: PUSH
67885: EMPTY
67886: ST_TO_ADDR
// for j in tmp do
67887: LD_ADDR_VAR 0 3
67891: PUSH
67892: LD_VAR 0 5
67896: PUSH
67897: FOR_IN
67898: IFFALSE 67967
// begin for k in UnitsInside ( j ) do
67900: LD_ADDR_VAR 0 4
67904: PUSH
67905: LD_VAR 0 3
67909: PPUSH
67910: CALL_OW 313
67914: PUSH
67915: FOR_IN
67916: IFFALSE 67963
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
67918: LD_VAR 0 4
67922: PPUSH
67923: CALL_OW 257
67927: PUSH
67928: LD_INT 1
67930: EQUAL
67931: PUSH
67932: LD_VAR 0 4
67936: PPUSH
67937: CALL_OW 459
67941: NOT
67942: AND
67943: IFFALSE 67961
// list := list ^ k ;
67945: LD_ADDR_VAR 0 6
67949: PUSH
67950: LD_VAR 0 6
67954: PUSH
67955: LD_VAR 0 4
67959: ADD
67960: ST_TO_ADDR
67961: GO 67915
67963: POP
67964: POP
// end ;
67965: GO 67897
67967: POP
67968: POP
// list := list diff mc_miners [ i ] ;
67969: LD_ADDR_VAR 0 6
67973: PUSH
67974: LD_VAR 0 6
67978: PUSH
67979: LD_EXP 74
67983: PUSH
67984: LD_VAR 0 2
67988: ARRAY
67989: DIFF
67990: ST_TO_ADDR
// if not list then
67991: LD_VAR 0 6
67995: NOT
67996: IFFALSE 68000
// continue ;
67998: GO 67373
// k := mc_mines [ i ] - mc_miners [ i ] ;
68000: LD_ADDR_VAR 0 4
68004: PUSH
68005: LD_EXP 73
68009: PUSH
68010: LD_VAR 0 2
68014: ARRAY
68015: PUSH
68016: LD_EXP 74
68020: PUSH
68021: LD_VAR 0 2
68025: ARRAY
68026: MINUS
68027: ST_TO_ADDR
// if k > list then
68028: LD_VAR 0 4
68032: PUSH
68033: LD_VAR 0 6
68037: GREATER
68038: IFFALSE 68050
// k := list ;
68040: LD_ADDR_VAR 0 4
68044: PUSH
68045: LD_VAR 0 6
68049: ST_TO_ADDR
// for j = 1 to k do
68050: LD_ADDR_VAR 0 3
68054: PUSH
68055: DOUBLE
68056: LD_INT 1
68058: DEC
68059: ST_TO_ADDR
68060: LD_VAR 0 4
68064: PUSH
68065: FOR_TO
68066: IFFALSE 68120
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
68068: LD_ADDR_EXP 74
68072: PUSH
68073: LD_EXP 74
68077: PPUSH
68078: LD_VAR 0 2
68082: PUSH
68083: LD_EXP 74
68087: PUSH
68088: LD_VAR 0 2
68092: ARRAY
68093: PUSH
68094: LD_INT 1
68096: PLUS
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PPUSH
68102: LD_VAR 0 6
68106: PUSH
68107: LD_VAR 0 3
68111: ARRAY
68112: PPUSH
68113: CALL 19824 0 3
68117: ST_TO_ADDR
68118: GO 68065
68120: POP
68121: POP
// end ;
68122: GO 67373
68124: POP
68125: POP
// end ;
68126: LD_VAR 0 1
68130: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
68131: LD_INT 0
68133: PPUSH
68134: PPUSH
68135: PPUSH
68136: PPUSH
68137: PPUSH
68138: PPUSH
68139: PPUSH
68140: PPUSH
68141: PPUSH
68142: PPUSH
68143: PPUSH
// if not mc_bases then
68144: LD_EXP 60
68148: NOT
68149: IFFALSE 68153
// exit ;
68151: GO 69976
// for i = 1 to mc_bases do
68153: LD_ADDR_VAR 0 2
68157: PUSH
68158: DOUBLE
68159: LD_INT 1
68161: DEC
68162: ST_TO_ADDR
68163: LD_EXP 60
68167: PUSH
68168: FOR_TO
68169: IFFALSE 69974
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68171: LD_EXP 60
68175: PUSH
68176: LD_VAR 0 2
68180: ARRAY
68181: NOT
68182: PUSH
68183: LD_EXP 67
68187: PUSH
68188: LD_VAR 0 2
68192: ARRAY
68193: OR
68194: IFFALSE 68198
// continue ;
68196: GO 68168
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68198: LD_EXP 76
68202: PUSH
68203: LD_VAR 0 2
68207: ARRAY
68208: NOT
68209: PUSH
68210: LD_EXP 77
68214: PUSH
68215: LD_VAR 0 2
68219: ARRAY
68220: AND
68221: IFFALSE 68259
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68223: LD_ADDR_EXP 77
68227: PUSH
68228: LD_EXP 77
68232: PPUSH
68233: LD_VAR 0 2
68237: PPUSH
68238: EMPTY
68239: PPUSH
68240: CALL_OW 1
68244: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68245: LD_VAR 0 2
68249: PPUSH
68250: LD_INT 107
68252: PPUSH
68253: CALL 59027 0 2
// continue ;
68257: GO 68168
// end ; target := [ ] ;
68259: LD_ADDR_VAR 0 7
68263: PUSH
68264: EMPTY
68265: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68266: LD_ADDR_VAR 0 6
68270: PUSH
68271: LD_EXP 60
68275: PUSH
68276: LD_VAR 0 2
68280: ARRAY
68281: PUSH
68282: LD_INT 1
68284: ARRAY
68285: PPUSH
68286: CALL_OW 255
68290: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68291: LD_ADDR_VAR 0 9
68295: PUSH
68296: LD_EXP 60
68300: PUSH
68301: LD_VAR 0 2
68305: ARRAY
68306: PPUSH
68307: LD_INT 2
68309: PUSH
68310: LD_INT 30
68312: PUSH
68313: LD_INT 0
68315: PUSH
68316: EMPTY
68317: LIST
68318: LIST
68319: PUSH
68320: LD_INT 30
68322: PUSH
68323: LD_INT 1
68325: PUSH
68326: EMPTY
68327: LIST
68328: LIST
68329: PUSH
68330: EMPTY
68331: LIST
68332: LIST
68333: LIST
68334: PPUSH
68335: CALL_OW 72
68339: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68340: LD_ADDR_VAR 0 3
68344: PUSH
68345: DOUBLE
68346: LD_EXP 76
68350: PUSH
68351: LD_VAR 0 2
68355: ARRAY
68356: INC
68357: ST_TO_ADDR
68358: LD_INT 1
68360: PUSH
68361: FOR_DOWNTO
68362: IFFALSE 68607
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68364: LD_EXP 76
68368: PUSH
68369: LD_VAR 0 2
68373: ARRAY
68374: PUSH
68375: LD_VAR 0 3
68379: ARRAY
68380: PUSH
68381: LD_INT 2
68383: ARRAY
68384: PPUSH
68385: LD_EXP 76
68389: PUSH
68390: LD_VAR 0 2
68394: ARRAY
68395: PUSH
68396: LD_VAR 0 3
68400: ARRAY
68401: PUSH
68402: LD_INT 3
68404: ARRAY
68405: PPUSH
68406: CALL_OW 488
68410: PUSH
68411: LD_EXP 76
68415: PUSH
68416: LD_VAR 0 2
68420: ARRAY
68421: PUSH
68422: LD_VAR 0 3
68426: ARRAY
68427: PUSH
68428: LD_INT 2
68430: ARRAY
68431: PPUSH
68432: LD_EXP 76
68436: PUSH
68437: LD_VAR 0 2
68441: ARRAY
68442: PUSH
68443: LD_VAR 0 3
68447: ARRAY
68448: PUSH
68449: LD_INT 3
68451: ARRAY
68452: PPUSH
68453: CALL_OW 284
68457: PUSH
68458: LD_INT 0
68460: EQUAL
68461: AND
68462: IFFALSE 68517
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
68464: LD_ADDR_VAR 0 5
68468: PUSH
68469: LD_EXP 76
68473: PUSH
68474: LD_VAR 0 2
68478: ARRAY
68479: PPUSH
68480: LD_VAR 0 3
68484: PPUSH
68485: CALL_OW 3
68489: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
68490: LD_ADDR_EXP 76
68494: PUSH
68495: LD_EXP 76
68499: PPUSH
68500: LD_VAR 0 2
68504: PPUSH
68505: LD_VAR 0 5
68509: PPUSH
68510: CALL_OW 1
68514: ST_TO_ADDR
// continue ;
68515: GO 68361
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68517: LD_VAR 0 6
68521: PPUSH
68522: LD_EXP 76
68526: PUSH
68527: LD_VAR 0 2
68531: ARRAY
68532: PUSH
68533: LD_VAR 0 3
68537: ARRAY
68538: PUSH
68539: LD_INT 2
68541: ARRAY
68542: PPUSH
68543: LD_EXP 76
68547: PUSH
68548: LD_VAR 0 2
68552: ARRAY
68553: PUSH
68554: LD_VAR 0 3
68558: ARRAY
68559: PUSH
68560: LD_INT 3
68562: ARRAY
68563: PPUSH
68564: LD_INT 30
68566: PPUSH
68567: CALL 20720 0 4
68571: PUSH
68572: LD_INT 4
68574: ARRAY
68575: PUSH
68576: LD_INT 0
68578: EQUAL
68579: IFFALSE 68605
// begin target := mc_crates [ i ] [ j ] ;
68581: LD_ADDR_VAR 0 7
68585: PUSH
68586: LD_EXP 76
68590: PUSH
68591: LD_VAR 0 2
68595: ARRAY
68596: PUSH
68597: LD_VAR 0 3
68601: ARRAY
68602: ST_TO_ADDR
// break ;
68603: GO 68607
// end ; end ;
68605: GO 68361
68607: POP
68608: POP
// if not target then
68609: LD_VAR 0 7
68613: NOT
68614: IFFALSE 68618
// continue ;
68616: GO 68168
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68618: LD_ADDR_VAR 0 8
68622: PUSH
68623: LD_EXP 79
68627: PUSH
68628: LD_VAR 0 2
68632: ARRAY
68633: PPUSH
68634: LD_INT 2
68636: PUSH
68637: LD_INT 3
68639: PUSH
68640: LD_INT 58
68642: PUSH
68643: EMPTY
68644: LIST
68645: PUSH
68646: EMPTY
68647: LIST
68648: LIST
68649: PUSH
68650: LD_INT 61
68652: PUSH
68653: EMPTY
68654: LIST
68655: PUSH
68656: LD_INT 33
68658: PUSH
68659: LD_INT 5
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 33
68668: PUSH
68669: LD_INT 3
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: PUSH
68676: EMPTY
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: PUSH
68683: LD_INT 2
68685: PUSH
68686: LD_INT 34
68688: PUSH
68689: LD_INT 32
68691: PUSH
68692: EMPTY
68693: LIST
68694: LIST
68695: PUSH
68696: LD_INT 34
68698: PUSH
68699: LD_INT 51
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: PUSH
68706: LD_INT 34
68708: PUSH
68709: LD_INT 12
68711: PUSH
68712: EMPTY
68713: LIST
68714: LIST
68715: PUSH
68716: EMPTY
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: PUSH
68722: EMPTY
68723: LIST
68724: LIST
68725: PPUSH
68726: CALL_OW 72
68730: ST_TO_ADDR
// if not cargo then
68731: LD_VAR 0 8
68735: NOT
68736: IFFALSE 69442
// begin if mc_crates_collector [ i ] < 5 then
68738: LD_EXP 77
68742: PUSH
68743: LD_VAR 0 2
68747: ARRAY
68748: PUSH
68749: LD_INT 5
68751: LESS
68752: IFFALSE 69118
// begin if mc_ape [ i ] then
68754: LD_EXP 89
68758: PUSH
68759: LD_VAR 0 2
68763: ARRAY
68764: IFFALSE 68811
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68766: LD_ADDR_VAR 0 5
68770: PUSH
68771: LD_EXP 89
68775: PUSH
68776: LD_VAR 0 2
68780: ARRAY
68781: PPUSH
68782: LD_INT 25
68784: PUSH
68785: LD_INT 16
68787: PUSH
68788: EMPTY
68789: LIST
68790: LIST
68791: PUSH
68792: LD_INT 24
68794: PUSH
68795: LD_INT 750
68797: PUSH
68798: EMPTY
68799: LIST
68800: LIST
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PPUSH
68806: CALL_OW 72
68810: ST_TO_ADDR
// if not tmp then
68811: LD_VAR 0 5
68815: NOT
68816: IFFALSE 68863
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68818: LD_ADDR_VAR 0 5
68822: PUSH
68823: LD_EXP 60
68827: PUSH
68828: LD_VAR 0 2
68832: ARRAY
68833: PPUSH
68834: LD_INT 25
68836: PUSH
68837: LD_INT 2
68839: PUSH
68840: EMPTY
68841: LIST
68842: LIST
68843: PUSH
68844: LD_INT 24
68846: PUSH
68847: LD_INT 750
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: PUSH
68854: EMPTY
68855: LIST
68856: LIST
68857: PPUSH
68858: CALL_OW 72
68862: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68863: LD_EXP 89
68867: PUSH
68868: LD_VAR 0 2
68872: ARRAY
68873: PUSH
68874: LD_EXP 60
68878: PUSH
68879: LD_VAR 0 2
68883: ARRAY
68884: PPUSH
68885: LD_INT 25
68887: PUSH
68888: LD_INT 2
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: PUSH
68895: LD_INT 24
68897: PUSH
68898: LD_INT 750
68900: PUSH
68901: EMPTY
68902: LIST
68903: LIST
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PPUSH
68909: CALL_OW 72
68913: AND
68914: PUSH
68915: LD_VAR 0 5
68919: PUSH
68920: LD_INT 5
68922: LESS
68923: AND
68924: IFFALSE 69006
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68926: LD_ADDR_VAR 0 3
68930: PUSH
68931: LD_EXP 60
68935: PUSH
68936: LD_VAR 0 2
68940: ARRAY
68941: PPUSH
68942: LD_INT 25
68944: PUSH
68945: LD_INT 2
68947: PUSH
68948: EMPTY
68949: LIST
68950: LIST
68951: PUSH
68952: LD_INT 24
68954: PUSH
68955: LD_INT 750
68957: PUSH
68958: EMPTY
68959: LIST
68960: LIST
68961: PUSH
68962: EMPTY
68963: LIST
68964: LIST
68965: PPUSH
68966: CALL_OW 72
68970: PUSH
68971: FOR_IN
68972: IFFALSE 69004
// begin tmp := tmp union j ;
68974: LD_ADDR_VAR 0 5
68978: PUSH
68979: LD_VAR 0 5
68983: PUSH
68984: LD_VAR 0 3
68988: UNION
68989: ST_TO_ADDR
// if tmp >= 5 then
68990: LD_VAR 0 5
68994: PUSH
68995: LD_INT 5
68997: GREATEREQUAL
68998: IFFALSE 69002
// break ;
69000: GO 69004
// end ;
69002: GO 68971
69004: POP
69005: POP
// end ; if not tmp then
69006: LD_VAR 0 5
69010: NOT
69011: IFFALSE 69015
// continue ;
69013: GO 68168
// for j in tmp do
69015: LD_ADDR_VAR 0 3
69019: PUSH
69020: LD_VAR 0 5
69024: PUSH
69025: FOR_IN
69026: IFFALSE 69116
// if not GetTag ( j ) then
69028: LD_VAR 0 3
69032: PPUSH
69033: CALL_OW 110
69037: NOT
69038: IFFALSE 69114
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
69040: LD_ADDR_EXP 77
69044: PUSH
69045: LD_EXP 77
69049: PPUSH
69050: LD_VAR 0 2
69054: PUSH
69055: LD_EXP 77
69059: PUSH
69060: LD_VAR 0 2
69064: ARRAY
69065: PUSH
69066: LD_INT 1
69068: PLUS
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: PPUSH
69074: LD_VAR 0 3
69078: PPUSH
69079: CALL 19824 0 3
69083: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69084: LD_VAR 0 3
69088: PPUSH
69089: LD_INT 107
69091: PPUSH
69092: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69096: LD_EXP 77
69100: PUSH
69101: LD_VAR 0 2
69105: ARRAY
69106: PUSH
69107: LD_INT 5
69109: GREATEREQUAL
69110: IFFALSE 69114
// break ;
69112: GO 69116
// end ;
69114: GO 69025
69116: POP
69117: POP
// end ; if mc_crates_collector [ i ] and target then
69118: LD_EXP 77
69122: PUSH
69123: LD_VAR 0 2
69127: ARRAY
69128: PUSH
69129: LD_VAR 0 7
69133: AND
69134: IFFALSE 69440
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69136: LD_EXP 77
69140: PUSH
69141: LD_VAR 0 2
69145: ARRAY
69146: PUSH
69147: LD_VAR 0 7
69151: PUSH
69152: LD_INT 1
69154: ARRAY
69155: LESS
69156: IFFALSE 69176
// tmp := mc_crates_collector [ i ] else
69158: LD_ADDR_VAR 0 5
69162: PUSH
69163: LD_EXP 77
69167: PUSH
69168: LD_VAR 0 2
69172: ARRAY
69173: ST_TO_ADDR
69174: GO 69190
// tmp := target [ 1 ] ;
69176: LD_ADDR_VAR 0 5
69180: PUSH
69181: LD_VAR 0 7
69185: PUSH
69186: LD_INT 1
69188: ARRAY
69189: ST_TO_ADDR
// k := 0 ;
69190: LD_ADDR_VAR 0 4
69194: PUSH
69195: LD_INT 0
69197: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69198: LD_ADDR_VAR 0 3
69202: PUSH
69203: LD_EXP 77
69207: PUSH
69208: LD_VAR 0 2
69212: ARRAY
69213: PUSH
69214: FOR_IN
69215: IFFALSE 69438
// begin k := k + 1 ;
69217: LD_ADDR_VAR 0 4
69221: PUSH
69222: LD_VAR 0 4
69226: PUSH
69227: LD_INT 1
69229: PLUS
69230: ST_TO_ADDR
// if k > tmp then
69231: LD_VAR 0 4
69235: PUSH
69236: LD_VAR 0 5
69240: GREATER
69241: IFFALSE 69245
// break ;
69243: GO 69438
// if not GetClass ( j ) in [ 2 , 16 ] then
69245: LD_VAR 0 3
69249: PPUSH
69250: CALL_OW 257
69254: PUSH
69255: LD_INT 2
69257: PUSH
69258: LD_INT 16
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: IN
69265: NOT
69266: IFFALSE 69319
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69268: LD_ADDR_EXP 77
69272: PUSH
69273: LD_EXP 77
69277: PPUSH
69278: LD_VAR 0 2
69282: PPUSH
69283: LD_EXP 77
69287: PUSH
69288: LD_VAR 0 2
69292: ARRAY
69293: PUSH
69294: LD_VAR 0 3
69298: DIFF
69299: PPUSH
69300: CALL_OW 1
69304: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69305: LD_VAR 0 3
69309: PPUSH
69310: LD_INT 0
69312: PPUSH
69313: CALL_OW 109
// continue ;
69317: GO 69214
// end ; if IsInUnit ( j ) then
69319: LD_VAR 0 3
69323: PPUSH
69324: CALL_OW 310
69328: IFFALSE 69339
// ComExitBuilding ( j ) ;
69330: LD_VAR 0 3
69334: PPUSH
69335: CALL_OW 122
// wait ( 3 ) ;
69339: LD_INT 3
69341: PPUSH
69342: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
69346: LD_VAR 0 3
69350: PPUSH
69351: CALL_OW 314
69355: PUSH
69356: LD_VAR 0 6
69360: PPUSH
69361: LD_VAR 0 7
69365: PUSH
69366: LD_INT 2
69368: ARRAY
69369: PPUSH
69370: LD_VAR 0 7
69374: PUSH
69375: LD_INT 3
69377: ARRAY
69378: PPUSH
69379: LD_INT 30
69381: PPUSH
69382: CALL 20720 0 4
69386: PUSH
69387: LD_INT 4
69389: ARRAY
69390: AND
69391: IFFALSE 69409
// ComStandNearbyBuilding ( j , depot ) else
69393: LD_VAR 0 3
69397: PPUSH
69398: LD_VAR 0 9
69402: PPUSH
69403: CALL 16402 0 2
69407: GO 69436
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69409: LD_VAR 0 3
69413: PPUSH
69414: LD_VAR 0 7
69418: PUSH
69419: LD_INT 2
69421: ARRAY
69422: PPUSH
69423: LD_VAR 0 7
69427: PUSH
69428: LD_INT 3
69430: ARRAY
69431: PPUSH
69432: CALL_OW 117
// end ;
69436: GO 69214
69438: POP
69439: POP
// end ; end else
69440: GO 69972
// begin for j in cargo do
69442: LD_ADDR_VAR 0 3
69446: PUSH
69447: LD_VAR 0 8
69451: PUSH
69452: FOR_IN
69453: IFFALSE 69970
// begin if GetTag ( j ) <> 0 then
69455: LD_VAR 0 3
69459: PPUSH
69460: CALL_OW 110
69464: PUSH
69465: LD_INT 0
69467: NONEQUAL
69468: IFFALSE 69472
// continue ;
69470: GO 69452
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
69472: LD_VAR 0 3
69476: PPUSH
69477: CALL_OW 256
69481: PUSH
69482: LD_INT 1000
69484: LESS
69485: PUSH
69486: LD_VAR 0 3
69490: PPUSH
69491: LD_EXP 84
69495: PUSH
69496: LD_VAR 0 2
69500: ARRAY
69501: PPUSH
69502: CALL_OW 308
69506: NOT
69507: AND
69508: IFFALSE 69530
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69510: LD_VAR 0 3
69514: PPUSH
69515: LD_EXP 84
69519: PUSH
69520: LD_VAR 0 2
69524: ARRAY
69525: PPUSH
69526: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69530: LD_VAR 0 3
69534: PPUSH
69535: CALL_OW 256
69539: PUSH
69540: LD_INT 1000
69542: LESS
69543: PUSH
69544: LD_VAR 0 3
69548: PPUSH
69549: LD_EXP 84
69553: PUSH
69554: LD_VAR 0 2
69558: ARRAY
69559: PPUSH
69560: CALL_OW 308
69564: AND
69565: IFFALSE 69569
// continue ;
69567: GO 69452
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69569: LD_VAR 0 3
69573: PPUSH
69574: CALL_OW 262
69578: PUSH
69579: LD_INT 2
69581: EQUAL
69582: PUSH
69583: LD_VAR 0 3
69587: PPUSH
69588: CALL_OW 261
69592: PUSH
69593: LD_INT 15
69595: LESS
69596: AND
69597: IFFALSE 69601
// continue ;
69599: GO 69452
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69601: LD_VAR 0 3
69605: PPUSH
69606: CALL_OW 262
69610: PUSH
69611: LD_INT 1
69613: EQUAL
69614: PUSH
69615: LD_VAR 0 3
69619: PPUSH
69620: CALL_OW 261
69624: PUSH
69625: LD_INT 10
69627: LESS
69628: AND
69629: IFFALSE 69909
// begin if not depot then
69631: LD_VAR 0 9
69635: NOT
69636: IFFALSE 69640
// continue ;
69638: GO 69452
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69640: LD_VAR 0 3
69644: PPUSH
69645: LD_VAR 0 9
69649: PPUSH
69650: LD_VAR 0 3
69654: PPUSH
69655: CALL_OW 74
69659: PPUSH
69660: CALL_OW 296
69664: PUSH
69665: LD_INT 6
69667: LESS
69668: IFFALSE 69684
// SetFuel ( j , 100 ) else
69670: LD_VAR 0 3
69674: PPUSH
69675: LD_INT 100
69677: PPUSH
69678: CALL_OW 240
69682: GO 69909
// if GetFuel ( j ) = 0 then
69684: LD_VAR 0 3
69688: PPUSH
69689: CALL_OW 261
69693: PUSH
69694: LD_INT 0
69696: EQUAL
69697: IFFALSE 69909
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69699: LD_ADDR_EXP 79
69703: PUSH
69704: LD_EXP 79
69708: PPUSH
69709: LD_VAR 0 2
69713: PPUSH
69714: LD_EXP 79
69718: PUSH
69719: LD_VAR 0 2
69723: ARRAY
69724: PUSH
69725: LD_VAR 0 3
69729: DIFF
69730: PPUSH
69731: CALL_OW 1
69735: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69736: LD_VAR 0 3
69740: PPUSH
69741: CALL_OW 263
69745: PUSH
69746: LD_INT 1
69748: EQUAL
69749: IFFALSE 69765
// ComExitVehicle ( IsInUnit ( j ) ) ;
69751: LD_VAR 0 3
69755: PPUSH
69756: CALL_OW 310
69760: PPUSH
69761: CALL_OW 121
// if GetControl ( j ) = control_remote then
69765: LD_VAR 0 3
69769: PPUSH
69770: CALL_OW 263
69774: PUSH
69775: LD_INT 2
69777: EQUAL
69778: IFFALSE 69789
// ComUnlink ( j ) ;
69780: LD_VAR 0 3
69784: PPUSH
69785: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
69789: LD_ADDR_VAR 0 10
69793: PUSH
69794: LD_VAR 0 2
69798: PPUSH
69799: LD_INT 3
69801: PPUSH
69802: CALL 79548 0 2
69806: ST_TO_ADDR
// if fac then
69807: LD_VAR 0 10
69811: IFFALSE 69907
// begin for k in fac do
69813: LD_ADDR_VAR 0 4
69817: PUSH
69818: LD_VAR 0 10
69822: PUSH
69823: FOR_IN
69824: IFFALSE 69905
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69826: LD_ADDR_VAR 0 11
69830: PUSH
69831: LD_VAR 0 10
69835: PPUSH
69836: LD_VAR 0 3
69840: PPUSH
69841: CALL_OW 265
69845: PPUSH
69846: LD_VAR 0 3
69850: PPUSH
69851: CALL_OW 262
69855: PPUSH
69856: LD_VAR 0 3
69860: PPUSH
69861: CALL_OW 263
69865: PPUSH
69866: LD_VAR 0 3
69870: PPUSH
69871: CALL_OW 264
69875: PPUSH
69876: CALL 17320 0 5
69880: ST_TO_ADDR
// if components then
69881: LD_VAR 0 11
69885: IFFALSE 69903
// begin MC_InsertProduceList ( i , components ) ;
69887: LD_VAR 0 2
69891: PPUSH
69892: LD_VAR 0 11
69896: PPUSH
69897: CALL 79093 0 2
// break ;
69901: GO 69905
// end ; end ;
69903: GO 69823
69905: POP
69906: POP
// end ; continue ;
69907: GO 69452
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69909: LD_VAR 0 3
69913: PPUSH
69914: LD_INT 1
69916: PPUSH
69917: CALL_OW 289
69921: PUSH
69922: LD_INT 100
69924: LESS
69925: PUSH
69926: LD_VAR 0 3
69930: PPUSH
69931: CALL_OW 314
69935: NOT
69936: AND
69937: IFFALSE 69966
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69939: LD_VAR 0 3
69943: PPUSH
69944: LD_VAR 0 7
69948: PUSH
69949: LD_INT 2
69951: ARRAY
69952: PPUSH
69953: LD_VAR 0 7
69957: PUSH
69958: LD_INT 3
69960: ARRAY
69961: PPUSH
69962: CALL_OW 117
// break ;
69966: GO 69970
// end ;
69968: GO 69452
69970: POP
69971: POP
// end ; end ;
69972: GO 68168
69974: POP
69975: POP
// end ;
69976: LD_VAR 0 1
69980: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69981: LD_INT 0
69983: PPUSH
69984: PPUSH
69985: PPUSH
69986: PPUSH
// if not mc_bases then
69987: LD_EXP 60
69991: NOT
69992: IFFALSE 69996
// exit ;
69994: GO 70157
// for i = 1 to mc_bases do
69996: LD_ADDR_VAR 0 2
70000: PUSH
70001: DOUBLE
70002: LD_INT 1
70004: DEC
70005: ST_TO_ADDR
70006: LD_EXP 60
70010: PUSH
70011: FOR_TO
70012: IFFALSE 70155
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
70014: LD_ADDR_VAR 0 4
70018: PUSH
70019: LD_EXP 79
70023: PUSH
70024: LD_VAR 0 2
70028: ARRAY
70029: PUSH
70030: LD_EXP 82
70034: PUSH
70035: LD_VAR 0 2
70039: ARRAY
70040: UNION
70041: PPUSH
70042: LD_INT 33
70044: PUSH
70045: LD_INT 2
70047: PUSH
70048: EMPTY
70049: LIST
70050: LIST
70051: PPUSH
70052: CALL_OW 72
70056: ST_TO_ADDR
// if tmp then
70057: LD_VAR 0 4
70061: IFFALSE 70153
// for j in tmp do
70063: LD_ADDR_VAR 0 3
70067: PUSH
70068: LD_VAR 0 4
70072: PUSH
70073: FOR_IN
70074: IFFALSE 70151
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70076: LD_VAR 0 3
70080: PPUSH
70081: CALL_OW 312
70085: NOT
70086: PUSH
70087: LD_VAR 0 3
70091: PPUSH
70092: CALL_OW 256
70096: PUSH
70097: LD_INT 250
70099: GREATEREQUAL
70100: AND
70101: IFFALSE 70114
// Connect ( j ) else
70103: LD_VAR 0 3
70107: PPUSH
70108: CALL 22795 0 1
70112: GO 70149
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70114: LD_VAR 0 3
70118: PPUSH
70119: CALL_OW 256
70123: PUSH
70124: LD_INT 250
70126: LESS
70127: PUSH
70128: LD_VAR 0 3
70132: PPUSH
70133: CALL_OW 312
70137: AND
70138: IFFALSE 70149
// ComUnlink ( j ) ;
70140: LD_VAR 0 3
70144: PPUSH
70145: CALL_OW 136
70149: GO 70073
70151: POP
70152: POP
// end ;
70153: GO 70011
70155: POP
70156: POP
// end ;
70157: LD_VAR 0 1
70161: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70162: LD_INT 0
70164: PPUSH
70165: PPUSH
70166: PPUSH
70167: PPUSH
70168: PPUSH
// if not mc_bases then
70169: LD_EXP 60
70173: NOT
70174: IFFALSE 70178
// exit ;
70176: GO 70623
// for i = 1 to mc_bases do
70178: LD_ADDR_VAR 0 2
70182: PUSH
70183: DOUBLE
70184: LD_INT 1
70186: DEC
70187: ST_TO_ADDR
70188: LD_EXP 60
70192: PUSH
70193: FOR_TO
70194: IFFALSE 70621
// begin if not mc_produce [ i ] then
70196: LD_EXP 81
70200: PUSH
70201: LD_VAR 0 2
70205: ARRAY
70206: NOT
70207: IFFALSE 70211
// continue ;
70209: GO 70193
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70211: LD_ADDR_VAR 0 5
70215: PUSH
70216: LD_EXP 60
70220: PUSH
70221: LD_VAR 0 2
70225: ARRAY
70226: PPUSH
70227: LD_INT 30
70229: PUSH
70230: LD_INT 3
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: PPUSH
70237: CALL_OW 72
70241: ST_TO_ADDR
// if not fac then
70242: LD_VAR 0 5
70246: NOT
70247: IFFALSE 70251
// continue ;
70249: GO 70193
// for j in fac do
70251: LD_ADDR_VAR 0 3
70255: PUSH
70256: LD_VAR 0 5
70260: PUSH
70261: FOR_IN
70262: IFFALSE 70617
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
70264: LD_VAR 0 3
70268: PPUSH
70269: CALL_OW 461
70273: PUSH
70274: LD_INT 2
70276: NONEQUAL
70277: PUSH
70278: LD_VAR 0 3
70282: PPUSH
70283: LD_INT 15
70285: PPUSH
70286: CALL 22423 0 2
70290: PUSH
70291: LD_INT 4
70293: ARRAY
70294: OR
70295: IFFALSE 70299
// continue ;
70297: GO 70261
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70299: LD_VAR 0 3
70303: PPUSH
70304: LD_EXP 81
70308: PUSH
70309: LD_VAR 0 2
70313: ARRAY
70314: PUSH
70315: LD_INT 1
70317: ARRAY
70318: PUSH
70319: LD_INT 1
70321: ARRAY
70322: PPUSH
70323: LD_EXP 81
70327: PUSH
70328: LD_VAR 0 2
70332: ARRAY
70333: PUSH
70334: LD_INT 1
70336: ARRAY
70337: PUSH
70338: LD_INT 2
70340: ARRAY
70341: PPUSH
70342: LD_EXP 81
70346: PUSH
70347: LD_VAR 0 2
70351: ARRAY
70352: PUSH
70353: LD_INT 1
70355: ARRAY
70356: PUSH
70357: LD_INT 3
70359: ARRAY
70360: PPUSH
70361: LD_EXP 81
70365: PUSH
70366: LD_VAR 0 2
70370: ARRAY
70371: PUSH
70372: LD_INT 1
70374: ARRAY
70375: PUSH
70376: LD_INT 4
70378: ARRAY
70379: PPUSH
70380: CALL_OW 448
70384: PUSH
70385: LD_VAR 0 3
70389: PPUSH
70390: LD_EXP 81
70394: PUSH
70395: LD_VAR 0 2
70399: ARRAY
70400: PUSH
70401: LD_INT 1
70403: ARRAY
70404: PUSH
70405: LD_INT 1
70407: ARRAY
70408: PUSH
70409: LD_EXP 81
70413: PUSH
70414: LD_VAR 0 2
70418: ARRAY
70419: PUSH
70420: LD_INT 1
70422: ARRAY
70423: PUSH
70424: LD_INT 2
70426: ARRAY
70427: PUSH
70428: LD_EXP 81
70432: PUSH
70433: LD_VAR 0 2
70437: ARRAY
70438: PUSH
70439: LD_INT 1
70441: ARRAY
70442: PUSH
70443: LD_INT 3
70445: ARRAY
70446: PUSH
70447: LD_EXP 81
70451: PUSH
70452: LD_VAR 0 2
70456: ARRAY
70457: PUSH
70458: LD_INT 1
70460: ARRAY
70461: PUSH
70462: LD_INT 4
70464: ARRAY
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: PPUSH
70472: CALL 26190 0 2
70476: AND
70477: IFFALSE 70615
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
70479: LD_VAR 0 3
70483: PPUSH
70484: LD_EXP 81
70488: PUSH
70489: LD_VAR 0 2
70493: ARRAY
70494: PUSH
70495: LD_INT 1
70497: ARRAY
70498: PUSH
70499: LD_INT 1
70501: ARRAY
70502: PPUSH
70503: LD_EXP 81
70507: PUSH
70508: LD_VAR 0 2
70512: ARRAY
70513: PUSH
70514: LD_INT 1
70516: ARRAY
70517: PUSH
70518: LD_INT 2
70520: ARRAY
70521: PPUSH
70522: LD_EXP 81
70526: PUSH
70527: LD_VAR 0 2
70531: ARRAY
70532: PUSH
70533: LD_INT 1
70535: ARRAY
70536: PUSH
70537: LD_INT 3
70539: ARRAY
70540: PPUSH
70541: LD_EXP 81
70545: PUSH
70546: LD_VAR 0 2
70550: ARRAY
70551: PUSH
70552: LD_INT 1
70554: ARRAY
70555: PUSH
70556: LD_INT 4
70558: ARRAY
70559: PPUSH
70560: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70564: LD_ADDR_VAR 0 4
70568: PUSH
70569: LD_EXP 81
70573: PUSH
70574: LD_VAR 0 2
70578: ARRAY
70579: PPUSH
70580: LD_INT 1
70582: PPUSH
70583: CALL_OW 3
70587: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70588: LD_ADDR_EXP 81
70592: PUSH
70593: LD_EXP 81
70597: PPUSH
70598: LD_VAR 0 2
70602: PPUSH
70603: LD_VAR 0 4
70607: PPUSH
70608: CALL_OW 1
70612: ST_TO_ADDR
// break ;
70613: GO 70617
// end ; end ;
70615: GO 70261
70617: POP
70618: POP
// end ;
70619: GO 70193
70621: POP
70622: POP
// end ;
70623: LD_VAR 0 1
70627: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70628: LD_INT 0
70630: PPUSH
70631: PPUSH
70632: PPUSH
// if not mc_bases then
70633: LD_EXP 60
70637: NOT
70638: IFFALSE 70642
// exit ;
70640: GO 70731
// for i = 1 to mc_bases do
70642: LD_ADDR_VAR 0 2
70646: PUSH
70647: DOUBLE
70648: LD_INT 1
70650: DEC
70651: ST_TO_ADDR
70652: LD_EXP 60
70656: PUSH
70657: FOR_TO
70658: IFFALSE 70729
// begin if mc_attack [ i ] then
70660: LD_EXP 80
70664: PUSH
70665: LD_VAR 0 2
70669: ARRAY
70670: IFFALSE 70727
// begin tmp := mc_attack [ i ] [ 1 ] ;
70672: LD_ADDR_VAR 0 3
70676: PUSH
70677: LD_EXP 80
70681: PUSH
70682: LD_VAR 0 2
70686: ARRAY
70687: PUSH
70688: LD_INT 1
70690: ARRAY
70691: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70692: LD_ADDR_EXP 80
70696: PUSH
70697: LD_EXP 80
70701: PPUSH
70702: LD_VAR 0 2
70706: PPUSH
70707: EMPTY
70708: PPUSH
70709: CALL_OW 1
70713: ST_TO_ADDR
// Attack ( tmp ) ;
70714: LD_VAR 0 3
70718: PPUSH
70719: CALL 104641 0 1
// exit ;
70723: POP
70724: POP
70725: GO 70731
// end ; end ;
70727: GO 70657
70729: POP
70730: POP
// end ;
70731: LD_VAR 0 1
70735: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70736: LD_INT 0
70738: PPUSH
70739: PPUSH
70740: PPUSH
70741: PPUSH
70742: PPUSH
70743: PPUSH
70744: PPUSH
// if not mc_bases then
70745: LD_EXP 60
70749: NOT
70750: IFFALSE 70754
// exit ;
70752: GO 71611
// for i = 1 to mc_bases do
70754: LD_ADDR_VAR 0 2
70758: PUSH
70759: DOUBLE
70760: LD_INT 1
70762: DEC
70763: ST_TO_ADDR
70764: LD_EXP 60
70768: PUSH
70769: FOR_TO
70770: IFFALSE 71609
// begin if not mc_bases [ i ] then
70772: LD_EXP 60
70776: PUSH
70777: LD_VAR 0 2
70781: ARRAY
70782: NOT
70783: IFFALSE 70787
// continue ;
70785: GO 70769
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70787: LD_ADDR_VAR 0 7
70791: PUSH
70792: LD_EXP 60
70796: PUSH
70797: LD_VAR 0 2
70801: ARRAY
70802: PUSH
70803: LD_INT 1
70805: ARRAY
70806: PPUSH
70807: CALL 16624 0 1
70811: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70812: LD_ADDR_EXP 83
70816: PUSH
70817: LD_EXP 83
70821: PPUSH
70822: LD_VAR 0 2
70826: PPUSH
70827: LD_EXP 60
70831: PUSH
70832: LD_VAR 0 2
70836: ARRAY
70837: PUSH
70838: LD_INT 1
70840: ARRAY
70841: PPUSH
70842: CALL_OW 255
70846: PPUSH
70847: LD_EXP 85
70851: PUSH
70852: LD_VAR 0 2
70856: ARRAY
70857: PPUSH
70858: CALL 16589 0 2
70862: PPUSH
70863: CALL_OW 1
70867: ST_TO_ADDR
// if not mc_scan [ i ] then
70868: LD_EXP 83
70872: PUSH
70873: LD_VAR 0 2
70877: ARRAY
70878: NOT
70879: IFFALSE 71057
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
70881: LD_ADDR_EXP 103
70885: PUSH
70886: LD_EXP 103
70890: PPUSH
70891: LD_VAR 0 2
70895: PPUSH
70896: LD_INT 0
70898: PPUSH
70899: CALL_OW 1
70903: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70904: LD_ADDR_VAR 0 4
70908: PUSH
70909: LD_EXP 60
70913: PUSH
70914: LD_VAR 0 2
70918: ARRAY
70919: PPUSH
70920: LD_INT 2
70922: PUSH
70923: LD_INT 25
70925: PUSH
70926: LD_INT 5
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: PUSH
70933: LD_INT 25
70935: PUSH
70936: LD_INT 8
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: PUSH
70943: LD_INT 25
70945: PUSH
70946: LD_INT 9
70948: PUSH
70949: EMPTY
70950: LIST
70951: LIST
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: LIST
70957: LIST
70958: PPUSH
70959: CALL_OW 72
70963: ST_TO_ADDR
// if not tmp then
70964: LD_VAR 0 4
70968: NOT
70969: IFFALSE 70973
// continue ;
70971: GO 70769
// for j in tmp do
70973: LD_ADDR_VAR 0 3
70977: PUSH
70978: LD_VAR 0 4
70982: PUSH
70983: FOR_IN
70984: IFFALSE 71055
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70986: LD_VAR 0 3
70990: PPUSH
70991: CALL_OW 310
70995: PPUSH
70996: CALL_OW 266
71000: PUSH
71001: LD_INT 5
71003: EQUAL
71004: PUSH
71005: LD_VAR 0 3
71009: PPUSH
71010: CALL_OW 257
71014: PUSH
71015: LD_INT 1
71017: EQUAL
71018: AND
71019: PUSH
71020: LD_VAR 0 3
71024: PPUSH
71025: CALL_OW 459
71029: NOT
71030: AND
71031: PUSH
71032: LD_VAR 0 7
71036: AND
71037: IFFALSE 71053
// ComChangeProfession ( j , class ) ;
71039: LD_VAR 0 3
71043: PPUSH
71044: LD_VAR 0 7
71048: PPUSH
71049: CALL_OW 123
71053: GO 70983
71055: POP
71056: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
71057: LD_EXP 83
71061: PUSH
71062: LD_VAR 0 2
71066: ARRAY
71067: PUSH
71068: LD_EXP 103
71072: PUSH
71073: LD_VAR 0 2
71077: ARRAY
71078: NOT
71079: AND
71080: PUSH
71081: LD_EXP 82
71085: PUSH
71086: LD_VAR 0 2
71090: ARRAY
71091: NOT
71092: AND
71093: PUSH
71094: LD_EXP 60
71098: PUSH
71099: LD_VAR 0 2
71103: ARRAY
71104: PPUSH
71105: LD_INT 50
71107: PUSH
71108: EMPTY
71109: LIST
71110: PUSH
71111: LD_INT 2
71113: PUSH
71114: LD_INT 30
71116: PUSH
71117: LD_INT 32
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PUSH
71124: LD_INT 30
71126: PUSH
71127: LD_INT 33
71129: PUSH
71130: EMPTY
71131: LIST
71132: LIST
71133: PUSH
71134: LD_INT 30
71136: PUSH
71137: LD_INT 4
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: PUSH
71144: LD_INT 30
71146: PUSH
71147: LD_INT 5
71149: PUSH
71150: EMPTY
71151: LIST
71152: LIST
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PPUSH
71165: CALL_OW 72
71169: PUSH
71170: LD_INT 4
71172: LESS
71173: PUSH
71174: LD_EXP 60
71178: PUSH
71179: LD_VAR 0 2
71183: ARRAY
71184: PPUSH
71185: LD_INT 3
71187: PUSH
71188: LD_INT 24
71190: PUSH
71191: LD_INT 1000
71193: PUSH
71194: EMPTY
71195: LIST
71196: LIST
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: LD_INT 2
71204: PUSH
71205: LD_INT 30
71207: PUSH
71208: LD_INT 0
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: PUSH
71215: LD_INT 30
71217: PUSH
71218: LD_INT 1
71220: PUSH
71221: EMPTY
71222: LIST
71223: LIST
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: LIST
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PPUSH
71234: CALL_OW 72
71238: OR
71239: AND
71240: IFFALSE 71491
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71242: LD_ADDR_EXP 103
71246: PUSH
71247: LD_EXP 103
71251: PPUSH
71252: LD_VAR 0 2
71256: PPUSH
71257: LD_INT 1
71259: PPUSH
71260: CALL_OW 1
71264: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71265: LD_ADDR_VAR 0 4
71269: PUSH
71270: LD_EXP 60
71274: PUSH
71275: LD_VAR 0 2
71279: ARRAY
71280: PPUSH
71281: LD_INT 2
71283: PUSH
71284: LD_INT 25
71286: PUSH
71287: LD_INT 1
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: PUSH
71294: LD_INT 25
71296: PUSH
71297: LD_INT 5
71299: PUSH
71300: EMPTY
71301: LIST
71302: LIST
71303: PUSH
71304: LD_INT 25
71306: PUSH
71307: LD_INT 8
71309: PUSH
71310: EMPTY
71311: LIST
71312: LIST
71313: PUSH
71314: LD_INT 25
71316: PUSH
71317: LD_INT 9
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: PPUSH
71331: CALL_OW 72
71335: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71336: LD_ADDR_VAR 0 4
71340: PUSH
71341: LD_VAR 0 4
71345: PUSH
71346: LD_VAR 0 4
71350: PPUSH
71351: LD_INT 18
71353: PPUSH
71354: CALL 49093 0 2
71358: DIFF
71359: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
71360: LD_VAR 0 4
71364: NOT
71365: PUSH
71366: LD_EXP 60
71370: PUSH
71371: LD_VAR 0 2
71375: ARRAY
71376: PPUSH
71377: LD_INT 2
71379: PUSH
71380: LD_INT 30
71382: PUSH
71383: LD_INT 4
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PUSH
71390: LD_INT 30
71392: PUSH
71393: LD_INT 5
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: LIST
71404: PPUSH
71405: CALL_OW 72
71409: NOT
71410: AND
71411: IFFALSE 71473
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
71413: LD_ADDR_VAR 0 4
71417: PUSH
71418: LD_EXP 60
71422: PUSH
71423: LD_VAR 0 2
71427: ARRAY
71428: PPUSH
71429: LD_INT 2
71431: PUSH
71432: LD_INT 25
71434: PUSH
71435: LD_INT 2
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 25
71444: PUSH
71445: LD_INT 3
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 25
71454: PUSH
71455: LD_INT 4
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: LIST
71466: LIST
71467: PPUSH
71468: CALL_OW 72
71472: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
71473: LD_VAR 0 2
71477: PPUSH
71478: LD_VAR 0 4
71482: PPUSH
71483: CALL 109350 0 2
// exit ;
71487: POP
71488: POP
71489: GO 71611
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
71491: LD_EXP 83
71495: PUSH
71496: LD_VAR 0 2
71500: ARRAY
71501: PUSH
71502: LD_EXP 103
71506: PUSH
71507: LD_VAR 0 2
71511: ARRAY
71512: NOT
71513: AND
71514: PUSH
71515: LD_EXP 82
71519: PUSH
71520: LD_VAR 0 2
71524: ARRAY
71525: AND
71526: IFFALSE 71607
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71528: LD_ADDR_EXP 103
71532: PUSH
71533: LD_EXP 103
71537: PPUSH
71538: LD_VAR 0 2
71542: PPUSH
71543: LD_INT 1
71545: PPUSH
71546: CALL_OW 1
71550: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
71551: LD_ADDR_VAR 0 4
71555: PUSH
71556: LD_EXP 82
71560: PUSH
71561: LD_VAR 0 2
71565: ARRAY
71566: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71567: LD_ADDR_EXP 82
71571: PUSH
71572: LD_EXP 82
71576: PPUSH
71577: LD_VAR 0 2
71581: PPUSH
71582: EMPTY
71583: PPUSH
71584: CALL_OW 1
71588: ST_TO_ADDR
// Defend ( i , tmp ) ;
71589: LD_VAR 0 2
71593: PPUSH
71594: LD_VAR 0 4
71598: PPUSH
71599: CALL 109946 0 2
// exit ;
71603: POP
71604: POP
71605: GO 71611
// end ; end ;
71607: GO 70769
71609: POP
71610: POP
// end ;
71611: LD_VAR 0 1
71615: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71616: LD_INT 0
71618: PPUSH
71619: PPUSH
71620: PPUSH
71621: PPUSH
71622: PPUSH
71623: PPUSH
71624: PPUSH
71625: PPUSH
71626: PPUSH
71627: PPUSH
71628: PPUSH
// if not mc_bases then
71629: LD_EXP 60
71633: NOT
71634: IFFALSE 71638
// exit ;
71636: GO 72725
// for i = 1 to mc_bases do
71638: LD_ADDR_VAR 0 2
71642: PUSH
71643: DOUBLE
71644: LD_INT 1
71646: DEC
71647: ST_TO_ADDR
71648: LD_EXP 60
71652: PUSH
71653: FOR_TO
71654: IFFALSE 72723
// begin tmp := mc_lab [ i ] ;
71656: LD_ADDR_VAR 0 6
71660: PUSH
71661: LD_EXP 93
71665: PUSH
71666: LD_VAR 0 2
71670: ARRAY
71671: ST_TO_ADDR
// if not tmp then
71672: LD_VAR 0 6
71676: NOT
71677: IFFALSE 71681
// continue ;
71679: GO 71653
// idle_lab := 0 ;
71681: LD_ADDR_VAR 0 11
71685: PUSH
71686: LD_INT 0
71688: ST_TO_ADDR
// for j in tmp do
71689: LD_ADDR_VAR 0 3
71693: PUSH
71694: LD_VAR 0 6
71698: PUSH
71699: FOR_IN
71700: IFFALSE 72719
// begin researching := false ;
71702: LD_ADDR_VAR 0 10
71706: PUSH
71707: LD_INT 0
71709: ST_TO_ADDR
// side := GetSide ( j ) ;
71710: LD_ADDR_VAR 0 4
71714: PUSH
71715: LD_VAR 0 3
71719: PPUSH
71720: CALL_OW 255
71724: ST_TO_ADDR
// if not mc_tech [ side ] then
71725: LD_EXP 87
71729: PUSH
71730: LD_VAR 0 4
71734: ARRAY
71735: NOT
71736: IFFALSE 71740
// continue ;
71738: GO 71699
// if BuildingStatus ( j ) = bs_idle then
71740: LD_VAR 0 3
71744: PPUSH
71745: CALL_OW 461
71749: PUSH
71750: LD_INT 2
71752: EQUAL
71753: IFFALSE 71941
// begin if idle_lab and UnitsInside ( j ) < 6 then
71755: LD_VAR 0 11
71759: PUSH
71760: LD_VAR 0 3
71764: PPUSH
71765: CALL_OW 313
71769: PUSH
71770: LD_INT 6
71772: LESS
71773: AND
71774: IFFALSE 71845
// begin tmp2 := UnitsInside ( idle_lab ) ;
71776: LD_ADDR_VAR 0 9
71780: PUSH
71781: LD_VAR 0 11
71785: PPUSH
71786: CALL_OW 313
71790: ST_TO_ADDR
// if tmp2 then
71791: LD_VAR 0 9
71795: IFFALSE 71837
// for x in tmp2 do
71797: LD_ADDR_VAR 0 7
71801: PUSH
71802: LD_VAR 0 9
71806: PUSH
71807: FOR_IN
71808: IFFALSE 71835
// begin ComExitBuilding ( x ) ;
71810: LD_VAR 0 7
71814: PPUSH
71815: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71819: LD_VAR 0 7
71823: PPUSH
71824: LD_VAR 0 3
71828: PPUSH
71829: CALL_OW 180
// end ;
71833: GO 71807
71835: POP
71836: POP
// idle_lab := 0 ;
71837: LD_ADDR_VAR 0 11
71841: PUSH
71842: LD_INT 0
71844: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71845: LD_ADDR_VAR 0 5
71849: PUSH
71850: LD_EXP 87
71854: PUSH
71855: LD_VAR 0 4
71859: ARRAY
71860: PUSH
71861: FOR_IN
71862: IFFALSE 71922
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71864: LD_VAR 0 3
71868: PPUSH
71869: LD_VAR 0 5
71873: PPUSH
71874: CALL_OW 430
71878: PUSH
71879: LD_VAR 0 4
71883: PPUSH
71884: LD_VAR 0 5
71888: PPUSH
71889: CALL 15694 0 2
71893: AND
71894: IFFALSE 71920
// begin researching := true ;
71896: LD_ADDR_VAR 0 10
71900: PUSH
71901: LD_INT 1
71903: ST_TO_ADDR
// ComResearch ( j , t ) ;
71904: LD_VAR 0 3
71908: PPUSH
71909: LD_VAR 0 5
71913: PPUSH
71914: CALL_OW 124
// break ;
71918: GO 71922
// end ;
71920: GO 71861
71922: POP
71923: POP
// if not researching then
71924: LD_VAR 0 10
71928: NOT
71929: IFFALSE 71941
// idle_lab := j ;
71931: LD_ADDR_VAR 0 11
71935: PUSH
71936: LD_VAR 0 3
71940: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
71941: LD_VAR 0 3
71945: PPUSH
71946: CALL_OW 461
71950: PUSH
71951: LD_INT 10
71953: EQUAL
71954: IFFALSE 72542
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71956: LD_EXP 89
71960: PUSH
71961: LD_VAR 0 2
71965: ARRAY
71966: NOT
71967: PUSH
71968: LD_EXP 90
71972: PUSH
71973: LD_VAR 0 2
71977: ARRAY
71978: NOT
71979: AND
71980: PUSH
71981: LD_EXP 87
71985: PUSH
71986: LD_VAR 0 4
71990: ARRAY
71991: PUSH
71992: LD_INT 1
71994: GREATER
71995: AND
71996: IFFALSE 72127
// begin ComCancel ( j ) ;
71998: LD_VAR 0 3
72002: PPUSH
72003: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
72007: LD_ADDR_EXP 87
72011: PUSH
72012: LD_EXP 87
72016: PPUSH
72017: LD_VAR 0 4
72021: PPUSH
72022: LD_EXP 87
72026: PUSH
72027: LD_VAR 0 4
72031: ARRAY
72032: PPUSH
72033: LD_EXP 87
72037: PUSH
72038: LD_VAR 0 4
72042: ARRAY
72043: PUSH
72044: LD_INT 1
72046: MINUS
72047: PPUSH
72048: LD_EXP 87
72052: PUSH
72053: LD_VAR 0 4
72057: ARRAY
72058: PPUSH
72059: LD_INT 0
72061: PPUSH
72062: CALL 19242 0 4
72066: PPUSH
72067: CALL_OW 1
72071: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72072: LD_ADDR_EXP 87
72076: PUSH
72077: LD_EXP 87
72081: PPUSH
72082: LD_VAR 0 4
72086: PPUSH
72087: LD_EXP 87
72091: PUSH
72092: LD_VAR 0 4
72096: ARRAY
72097: PPUSH
72098: LD_EXP 87
72102: PUSH
72103: LD_VAR 0 4
72107: ARRAY
72108: PPUSH
72109: LD_INT 1
72111: PPUSH
72112: LD_INT 0
72114: PPUSH
72115: CALL 19242 0 4
72119: PPUSH
72120: CALL_OW 1
72124: ST_TO_ADDR
// continue ;
72125: GO 71699
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72127: LD_EXP 89
72131: PUSH
72132: LD_VAR 0 2
72136: ARRAY
72137: PUSH
72138: LD_EXP 90
72142: PUSH
72143: LD_VAR 0 2
72147: ARRAY
72148: NOT
72149: AND
72150: IFFALSE 72277
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
72152: LD_ADDR_EXP 90
72156: PUSH
72157: LD_EXP 90
72161: PPUSH
72162: LD_VAR 0 2
72166: PUSH
72167: LD_EXP 90
72171: PUSH
72172: LD_VAR 0 2
72176: ARRAY
72177: PUSH
72178: LD_INT 1
72180: PLUS
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PPUSH
72186: LD_EXP 89
72190: PUSH
72191: LD_VAR 0 2
72195: ARRAY
72196: PUSH
72197: LD_INT 1
72199: ARRAY
72200: PPUSH
72201: CALL 19824 0 3
72205: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
72206: LD_EXP 89
72210: PUSH
72211: LD_VAR 0 2
72215: ARRAY
72216: PUSH
72217: LD_INT 1
72219: ARRAY
72220: PPUSH
72221: LD_INT 112
72223: PPUSH
72224: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
72228: LD_ADDR_VAR 0 9
72232: PUSH
72233: LD_EXP 89
72237: PUSH
72238: LD_VAR 0 2
72242: ARRAY
72243: PPUSH
72244: LD_INT 1
72246: PPUSH
72247: CALL_OW 3
72251: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
72252: LD_ADDR_EXP 89
72256: PUSH
72257: LD_EXP 89
72261: PPUSH
72262: LD_VAR 0 2
72266: PPUSH
72267: LD_VAR 0 9
72271: PPUSH
72272: CALL_OW 1
72276: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
72277: LD_EXP 89
72281: PUSH
72282: LD_VAR 0 2
72286: ARRAY
72287: PUSH
72288: LD_EXP 90
72292: PUSH
72293: LD_VAR 0 2
72297: ARRAY
72298: AND
72299: PUSH
72300: LD_EXP 90
72304: PUSH
72305: LD_VAR 0 2
72309: ARRAY
72310: PUSH
72311: LD_INT 1
72313: ARRAY
72314: PPUSH
72315: CALL_OW 310
72319: NOT
72320: AND
72321: PUSH
72322: LD_VAR 0 3
72326: PPUSH
72327: CALL_OW 313
72331: PUSH
72332: LD_INT 6
72334: EQUAL
72335: AND
72336: IFFALSE 72392
// begin tmp2 := UnitsInside ( j ) ;
72338: LD_ADDR_VAR 0 9
72342: PUSH
72343: LD_VAR 0 3
72347: PPUSH
72348: CALL_OW 313
72352: ST_TO_ADDR
// if tmp2 = 6 then
72353: LD_VAR 0 9
72357: PUSH
72358: LD_INT 6
72360: EQUAL
72361: IFFALSE 72392
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72363: LD_VAR 0 9
72367: PUSH
72368: LD_INT 1
72370: ARRAY
72371: PPUSH
72372: LD_INT 112
72374: PPUSH
72375: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72379: LD_VAR 0 9
72383: PUSH
72384: LD_INT 1
72386: ARRAY
72387: PPUSH
72388: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72392: LD_EXP 90
72396: PUSH
72397: LD_VAR 0 2
72401: ARRAY
72402: PUSH
72403: LD_EXP 90
72407: PUSH
72408: LD_VAR 0 2
72412: ARRAY
72413: PUSH
72414: LD_INT 1
72416: ARRAY
72417: PPUSH
72418: CALL_OW 314
72422: NOT
72423: AND
72424: PUSH
72425: LD_EXP 90
72429: PUSH
72430: LD_VAR 0 2
72434: ARRAY
72435: PUSH
72436: LD_INT 1
72438: ARRAY
72439: PPUSH
72440: CALL_OW 310
72444: NOT
72445: AND
72446: IFFALSE 72472
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
72448: LD_EXP 90
72452: PUSH
72453: LD_VAR 0 2
72457: ARRAY
72458: PUSH
72459: LD_INT 1
72461: ARRAY
72462: PPUSH
72463: LD_VAR 0 3
72467: PPUSH
72468: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
72472: LD_EXP 90
72476: PUSH
72477: LD_VAR 0 2
72481: ARRAY
72482: PUSH
72483: LD_INT 1
72485: ARRAY
72486: PPUSH
72487: CALL_OW 310
72491: PUSH
72492: LD_EXP 90
72496: PUSH
72497: LD_VAR 0 2
72501: ARRAY
72502: PUSH
72503: LD_INT 1
72505: ARRAY
72506: PPUSH
72507: CALL_OW 310
72511: PPUSH
72512: CALL_OW 461
72516: PUSH
72517: LD_INT 3
72519: NONEQUAL
72520: AND
72521: IFFALSE 72542
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72523: LD_EXP 90
72527: PUSH
72528: LD_VAR 0 2
72532: ARRAY
72533: PUSH
72534: LD_INT 1
72536: ARRAY
72537: PPUSH
72538: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72542: LD_VAR 0 3
72546: PPUSH
72547: CALL_OW 461
72551: PUSH
72552: LD_INT 6
72554: EQUAL
72555: PUSH
72556: LD_VAR 0 6
72560: PUSH
72561: LD_INT 1
72563: GREATER
72564: AND
72565: IFFALSE 72717
// begin sci := [ ] ;
72567: LD_ADDR_VAR 0 8
72571: PUSH
72572: EMPTY
72573: ST_TO_ADDR
// for x in ( tmp diff j ) do
72574: LD_ADDR_VAR 0 7
72578: PUSH
72579: LD_VAR 0 6
72583: PUSH
72584: LD_VAR 0 3
72588: DIFF
72589: PUSH
72590: FOR_IN
72591: IFFALSE 72643
// begin if sci = 6 then
72593: LD_VAR 0 8
72597: PUSH
72598: LD_INT 6
72600: EQUAL
72601: IFFALSE 72605
// break ;
72603: GO 72643
// if BuildingStatus ( x ) = bs_idle then
72605: LD_VAR 0 7
72609: PPUSH
72610: CALL_OW 461
72614: PUSH
72615: LD_INT 2
72617: EQUAL
72618: IFFALSE 72641
// sci := sci ^ UnitsInside ( x ) ;
72620: LD_ADDR_VAR 0 8
72624: PUSH
72625: LD_VAR 0 8
72629: PUSH
72630: LD_VAR 0 7
72634: PPUSH
72635: CALL_OW 313
72639: ADD
72640: ST_TO_ADDR
// end ;
72641: GO 72590
72643: POP
72644: POP
// if not sci then
72645: LD_VAR 0 8
72649: NOT
72650: IFFALSE 72654
// continue ;
72652: GO 71699
// for x in sci do
72654: LD_ADDR_VAR 0 7
72658: PUSH
72659: LD_VAR 0 8
72663: PUSH
72664: FOR_IN
72665: IFFALSE 72715
// if IsInUnit ( x ) and not HasTask ( x ) then
72667: LD_VAR 0 7
72671: PPUSH
72672: CALL_OW 310
72676: PUSH
72677: LD_VAR 0 7
72681: PPUSH
72682: CALL_OW 314
72686: NOT
72687: AND
72688: IFFALSE 72713
// begin ComExitBuilding ( x ) ;
72690: LD_VAR 0 7
72694: PPUSH
72695: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72699: LD_VAR 0 7
72703: PPUSH
72704: LD_VAR 0 3
72708: PPUSH
72709: CALL_OW 180
// end ;
72713: GO 72664
72715: POP
72716: POP
// end ; end ;
72717: GO 71699
72719: POP
72720: POP
// end ;
72721: GO 71653
72723: POP
72724: POP
// end ;
72725: LD_VAR 0 1
72729: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72730: LD_INT 0
72732: PPUSH
72733: PPUSH
// if not mc_bases then
72734: LD_EXP 60
72738: NOT
72739: IFFALSE 72743
// exit ;
72741: GO 72824
// for i = 1 to mc_bases do
72743: LD_ADDR_VAR 0 2
72747: PUSH
72748: DOUBLE
72749: LD_INT 1
72751: DEC
72752: ST_TO_ADDR
72753: LD_EXP 60
72757: PUSH
72758: FOR_TO
72759: IFFALSE 72822
// if mc_mines [ i ] and mc_miners [ i ] then
72761: LD_EXP 73
72765: PUSH
72766: LD_VAR 0 2
72770: ARRAY
72771: PUSH
72772: LD_EXP 74
72776: PUSH
72777: LD_VAR 0 2
72781: ARRAY
72782: AND
72783: IFFALSE 72820
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72785: LD_EXP 74
72789: PUSH
72790: LD_VAR 0 2
72794: ARRAY
72795: PUSH
72796: LD_INT 1
72798: ARRAY
72799: PPUSH
72800: CALL_OW 255
72804: PPUSH
72805: LD_EXP 73
72809: PUSH
72810: LD_VAR 0 2
72814: ARRAY
72815: PPUSH
72816: CALL 16777 0 2
72820: GO 72758
72822: POP
72823: POP
// end ;
72824: LD_VAR 0 1
72828: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
72829: LD_INT 0
72831: PPUSH
72832: PPUSH
72833: PPUSH
72834: PPUSH
72835: PPUSH
72836: PPUSH
72837: PPUSH
72838: PPUSH
// if not mc_bases or not mc_parking then
72839: LD_EXP 60
72843: NOT
72844: PUSH
72845: LD_EXP 84
72849: NOT
72850: OR
72851: IFFALSE 72855
// exit ;
72853: GO 73565
// for i = 1 to mc_bases do
72855: LD_ADDR_VAR 0 2
72859: PUSH
72860: DOUBLE
72861: LD_INT 1
72863: DEC
72864: ST_TO_ADDR
72865: LD_EXP 60
72869: PUSH
72870: FOR_TO
72871: IFFALSE 73563
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72873: LD_EXP 60
72877: PUSH
72878: LD_VAR 0 2
72882: ARRAY
72883: NOT
72884: PUSH
72885: LD_EXP 84
72889: PUSH
72890: LD_VAR 0 2
72894: ARRAY
72895: NOT
72896: OR
72897: IFFALSE 72901
// continue ;
72899: GO 72870
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72901: LD_ADDR_VAR 0 5
72905: PUSH
72906: LD_EXP 60
72910: PUSH
72911: LD_VAR 0 2
72915: ARRAY
72916: PUSH
72917: LD_INT 1
72919: ARRAY
72920: PPUSH
72921: CALL_OW 255
72925: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72926: LD_ADDR_VAR 0 6
72930: PUSH
72931: LD_EXP 60
72935: PUSH
72936: LD_VAR 0 2
72940: ARRAY
72941: PPUSH
72942: LD_INT 30
72944: PUSH
72945: LD_INT 3
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: PPUSH
72952: CALL_OW 72
72956: ST_TO_ADDR
// if not fac then
72957: LD_VAR 0 6
72961: NOT
72962: IFFALSE 73013
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72964: LD_ADDR_VAR 0 6
72968: PUSH
72969: LD_EXP 60
72973: PUSH
72974: LD_VAR 0 2
72978: ARRAY
72979: PPUSH
72980: LD_INT 2
72982: PUSH
72983: LD_INT 30
72985: PUSH
72986: LD_INT 0
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: LD_INT 30
72995: PUSH
72996: LD_INT 1
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: EMPTY
73004: LIST
73005: LIST
73006: LIST
73007: PPUSH
73008: CALL_OW 72
73012: ST_TO_ADDR
// if not fac then
73013: LD_VAR 0 6
73017: NOT
73018: IFFALSE 73022
// continue ;
73020: GO 72870
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73022: LD_ADDR_VAR 0 7
73026: PUSH
73027: LD_EXP 84
73031: PUSH
73032: LD_VAR 0 2
73036: ARRAY
73037: PPUSH
73038: LD_INT 22
73040: PUSH
73041: LD_VAR 0 5
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PUSH
73050: LD_INT 21
73052: PUSH
73053: LD_INT 2
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PUSH
73060: LD_INT 3
73062: PUSH
73063: LD_INT 24
73065: PUSH
73066: LD_INT 1000
73068: PUSH
73069: EMPTY
73070: LIST
73071: LIST
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: LIST
73081: PPUSH
73082: CALL_OW 70
73086: ST_TO_ADDR
// for j in fac do
73087: LD_ADDR_VAR 0 3
73091: PUSH
73092: LD_VAR 0 6
73096: PUSH
73097: FOR_IN
73098: IFFALSE 73179
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73100: LD_ADDR_VAR 0 7
73104: PUSH
73105: LD_VAR 0 7
73109: PUSH
73110: LD_INT 22
73112: PUSH
73113: LD_VAR 0 5
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: LD_INT 91
73124: PUSH
73125: LD_VAR 0 3
73129: PUSH
73130: LD_INT 15
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: LIST
73137: PUSH
73138: LD_INT 21
73140: PUSH
73141: LD_INT 2
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 3
73150: PUSH
73151: LD_INT 24
73153: PUSH
73154: LD_INT 1000
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: LIST
73169: LIST
73170: PPUSH
73171: CALL_OW 69
73175: UNION
73176: ST_TO_ADDR
73177: GO 73097
73179: POP
73180: POP
// if not vehs then
73181: LD_VAR 0 7
73185: NOT
73186: IFFALSE 73212
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73188: LD_ADDR_EXP 72
73192: PUSH
73193: LD_EXP 72
73197: PPUSH
73198: LD_VAR 0 2
73202: PPUSH
73203: EMPTY
73204: PPUSH
73205: CALL_OW 1
73209: ST_TO_ADDR
// continue ;
73210: GO 72870
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73212: LD_ADDR_VAR 0 8
73216: PUSH
73217: LD_EXP 60
73221: PUSH
73222: LD_VAR 0 2
73226: ARRAY
73227: PPUSH
73228: LD_INT 30
73230: PUSH
73231: LD_INT 3
73233: PUSH
73234: EMPTY
73235: LIST
73236: LIST
73237: PPUSH
73238: CALL_OW 72
73242: ST_TO_ADDR
// if tmp then
73243: LD_VAR 0 8
73247: IFFALSE 73350
// begin for j in tmp do
73249: LD_ADDR_VAR 0 3
73253: PUSH
73254: LD_VAR 0 8
73258: PUSH
73259: FOR_IN
73260: IFFALSE 73348
// for k in UnitsInside ( j ) do
73262: LD_ADDR_VAR 0 4
73266: PUSH
73267: LD_VAR 0 3
73271: PPUSH
73272: CALL_OW 313
73276: PUSH
73277: FOR_IN
73278: IFFALSE 73344
// if k then
73280: LD_VAR 0 4
73284: IFFALSE 73342
// if not k in mc_repair_vehicle [ i ] then
73286: LD_VAR 0 4
73290: PUSH
73291: LD_EXP 72
73295: PUSH
73296: LD_VAR 0 2
73300: ARRAY
73301: IN
73302: NOT
73303: IFFALSE 73342
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73305: LD_ADDR_EXP 72
73309: PUSH
73310: LD_EXP 72
73314: PPUSH
73315: LD_VAR 0 2
73319: PPUSH
73320: LD_EXP 72
73324: PUSH
73325: LD_VAR 0 2
73329: ARRAY
73330: PUSH
73331: LD_VAR 0 4
73335: UNION
73336: PPUSH
73337: CALL_OW 1
73341: ST_TO_ADDR
73342: GO 73277
73344: POP
73345: POP
73346: GO 73259
73348: POP
73349: POP
// end ; if not mc_repair_vehicle [ i ] then
73350: LD_EXP 72
73354: PUSH
73355: LD_VAR 0 2
73359: ARRAY
73360: NOT
73361: IFFALSE 73365
// continue ;
73363: GO 72870
// for j in mc_repair_vehicle [ i ] do
73365: LD_ADDR_VAR 0 3
73369: PUSH
73370: LD_EXP 72
73374: PUSH
73375: LD_VAR 0 2
73379: ARRAY
73380: PUSH
73381: FOR_IN
73382: IFFALSE 73559
// begin if GetClass ( j ) <> 3 then
73384: LD_VAR 0 3
73388: PPUSH
73389: CALL_OW 257
73393: PUSH
73394: LD_INT 3
73396: NONEQUAL
73397: IFFALSE 73438
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73399: LD_ADDR_EXP 72
73403: PUSH
73404: LD_EXP 72
73408: PPUSH
73409: LD_VAR 0 2
73413: PPUSH
73414: LD_EXP 72
73418: PUSH
73419: LD_VAR 0 2
73423: ARRAY
73424: PUSH
73425: LD_VAR 0 3
73429: DIFF
73430: PPUSH
73431: CALL_OW 1
73435: ST_TO_ADDR
// continue ;
73436: GO 73381
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73438: LD_VAR 0 3
73442: PPUSH
73443: CALL_OW 311
73447: NOT
73448: PUSH
73449: LD_VAR 0 3
73453: PUSH
73454: LD_EXP 63
73458: PUSH
73459: LD_VAR 0 2
73463: ARRAY
73464: PUSH
73465: LD_INT 1
73467: ARRAY
73468: IN
73469: NOT
73470: AND
73471: PUSH
73472: LD_VAR 0 3
73476: PUSH
73477: LD_EXP 63
73481: PUSH
73482: LD_VAR 0 2
73486: ARRAY
73487: PUSH
73488: LD_INT 2
73490: ARRAY
73491: IN
73492: NOT
73493: AND
73494: IFFALSE 73557
// begin if IsInUnit ( j ) then
73496: LD_VAR 0 3
73500: PPUSH
73501: CALL_OW 310
73505: IFFALSE 73518
// ComExitBuilding ( j ) else
73507: LD_VAR 0 3
73511: PPUSH
73512: CALL_OW 122
73516: GO 73557
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
73518: LD_VAR 0 3
73522: PPUSH
73523: LD_VAR 0 7
73527: PUSH
73528: LD_INT 1
73530: ARRAY
73531: PPUSH
73532: CALL 53576 0 2
73536: NOT
73537: IFFALSE 73557
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
73539: LD_VAR 0 3
73543: PPUSH
73544: LD_VAR 0 7
73548: PUSH
73549: LD_INT 1
73551: ARRAY
73552: PPUSH
73553: CALL_OW 129
// end ; end ;
73557: GO 73381
73559: POP
73560: POP
// end ;
73561: GO 72870
73563: POP
73564: POP
// end ;
73565: LD_VAR 0 1
73569: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73570: LD_INT 0
73572: PPUSH
73573: PPUSH
73574: PPUSH
73575: PPUSH
73576: PPUSH
73577: PPUSH
73578: PPUSH
73579: PPUSH
73580: PPUSH
73581: PPUSH
73582: PPUSH
// if not mc_bases then
73583: LD_EXP 60
73587: NOT
73588: IFFALSE 73592
// exit ;
73590: GO 74394
// for i = 1 to mc_bases do
73592: LD_ADDR_VAR 0 2
73596: PUSH
73597: DOUBLE
73598: LD_INT 1
73600: DEC
73601: ST_TO_ADDR
73602: LD_EXP 60
73606: PUSH
73607: FOR_TO
73608: IFFALSE 74392
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73610: LD_EXP 88
73614: PUSH
73615: LD_VAR 0 2
73619: ARRAY
73620: NOT
73621: PUSH
73622: LD_EXP 63
73626: PUSH
73627: LD_VAR 0 2
73631: ARRAY
73632: PUSH
73633: LD_INT 1
73635: ARRAY
73636: OR
73637: PUSH
73638: LD_EXP 63
73642: PUSH
73643: LD_VAR 0 2
73647: ARRAY
73648: PUSH
73649: LD_INT 2
73651: ARRAY
73652: OR
73653: PUSH
73654: LD_EXP 86
73658: PUSH
73659: LD_VAR 0 2
73663: ARRAY
73664: PPUSH
73665: LD_INT 1
73667: PPUSH
73668: CALL_OW 325
73672: NOT
73673: OR
73674: PUSH
73675: LD_EXP 83
73679: PUSH
73680: LD_VAR 0 2
73684: ARRAY
73685: OR
73686: IFFALSE 73690
// continue ;
73688: GO 73607
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73690: LD_ADDR_VAR 0 8
73694: PUSH
73695: LD_EXP 60
73699: PUSH
73700: LD_VAR 0 2
73704: ARRAY
73705: PPUSH
73706: LD_INT 25
73708: PUSH
73709: LD_INT 4
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: PUSH
73716: LD_INT 50
73718: PUSH
73719: EMPTY
73720: LIST
73721: PUSH
73722: LD_INT 3
73724: PUSH
73725: LD_INT 60
73727: PUSH
73728: EMPTY
73729: LIST
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: LIST
73739: PPUSH
73740: CALL_OW 72
73744: PUSH
73745: LD_EXP 64
73749: PUSH
73750: LD_VAR 0 2
73754: ARRAY
73755: DIFF
73756: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73757: LD_ADDR_VAR 0 9
73761: PUSH
73762: LD_EXP 60
73766: PUSH
73767: LD_VAR 0 2
73771: ARRAY
73772: PPUSH
73773: LD_INT 2
73775: PUSH
73776: LD_INT 30
73778: PUSH
73779: LD_INT 0
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: PUSH
73786: LD_INT 30
73788: PUSH
73789: LD_INT 1
73791: PUSH
73792: EMPTY
73793: LIST
73794: LIST
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: LIST
73800: PPUSH
73801: CALL_OW 72
73805: ST_TO_ADDR
// if not tmp or not dep then
73806: LD_VAR 0 8
73810: NOT
73811: PUSH
73812: LD_VAR 0 9
73816: NOT
73817: OR
73818: IFFALSE 73822
// continue ;
73820: GO 73607
// side := GetSide ( tmp [ 1 ] ) ;
73822: LD_ADDR_VAR 0 11
73826: PUSH
73827: LD_VAR 0 8
73831: PUSH
73832: LD_INT 1
73834: ARRAY
73835: PPUSH
73836: CALL_OW 255
73840: ST_TO_ADDR
// dep := dep [ 1 ] ;
73841: LD_ADDR_VAR 0 9
73845: PUSH
73846: LD_VAR 0 9
73850: PUSH
73851: LD_INT 1
73853: ARRAY
73854: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73855: LD_ADDR_VAR 0 7
73859: PUSH
73860: LD_EXP 88
73864: PUSH
73865: LD_VAR 0 2
73869: ARRAY
73870: PPUSH
73871: LD_INT 22
73873: PUSH
73874: LD_INT 0
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 25
73883: PUSH
73884: LD_INT 12
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: EMPTY
73892: LIST
73893: LIST
73894: PPUSH
73895: CALL_OW 70
73899: PUSH
73900: LD_INT 22
73902: PUSH
73903: LD_INT 0
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 25
73912: PUSH
73913: LD_INT 12
73915: PUSH
73916: EMPTY
73917: LIST
73918: LIST
73919: PUSH
73920: LD_INT 91
73922: PUSH
73923: LD_VAR 0 9
73927: PUSH
73928: LD_INT 20
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: LIST
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: LIST
73940: PPUSH
73941: CALL_OW 69
73945: UNION
73946: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
73947: LD_ADDR_VAR 0 10
73951: PUSH
73952: LD_EXP 88
73956: PUSH
73957: LD_VAR 0 2
73961: ARRAY
73962: PPUSH
73963: LD_INT 81
73965: PUSH
73966: LD_VAR 0 11
73970: PUSH
73971: EMPTY
73972: LIST
73973: LIST
73974: PPUSH
73975: CALL_OW 70
73979: ST_TO_ADDR
// if not apes or danger_at_area then
73980: LD_VAR 0 7
73984: NOT
73985: PUSH
73986: LD_VAR 0 10
73990: OR
73991: IFFALSE 74041
// begin if mc_taming [ i ] then
73993: LD_EXP 91
73997: PUSH
73998: LD_VAR 0 2
74002: ARRAY
74003: IFFALSE 74039
// begin MC_Reset ( i , 121 ) ;
74005: LD_VAR 0 2
74009: PPUSH
74010: LD_INT 121
74012: PPUSH
74013: CALL 59027 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74017: LD_ADDR_EXP 91
74021: PUSH
74022: LD_EXP 91
74026: PPUSH
74027: LD_VAR 0 2
74031: PPUSH
74032: EMPTY
74033: PPUSH
74034: CALL_OW 1
74038: ST_TO_ADDR
// end ; continue ;
74039: GO 73607
// end ; for j in tmp do
74041: LD_ADDR_VAR 0 3
74045: PUSH
74046: LD_VAR 0 8
74050: PUSH
74051: FOR_IN
74052: IFFALSE 74388
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74054: LD_VAR 0 3
74058: PUSH
74059: LD_EXP 91
74063: PUSH
74064: LD_VAR 0 2
74068: ARRAY
74069: IN
74070: NOT
74071: PUSH
74072: LD_EXP 91
74076: PUSH
74077: LD_VAR 0 2
74081: ARRAY
74082: PUSH
74083: LD_INT 3
74085: LESS
74086: AND
74087: IFFALSE 74145
// begin SetTag ( j , 121 ) ;
74089: LD_VAR 0 3
74093: PPUSH
74094: LD_INT 121
74096: PPUSH
74097: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74101: LD_ADDR_EXP 91
74105: PUSH
74106: LD_EXP 91
74110: PPUSH
74111: LD_VAR 0 2
74115: PUSH
74116: LD_EXP 91
74120: PUSH
74121: LD_VAR 0 2
74125: ARRAY
74126: PUSH
74127: LD_INT 1
74129: PLUS
74130: PUSH
74131: EMPTY
74132: LIST
74133: LIST
74134: PPUSH
74135: LD_VAR 0 3
74139: PPUSH
74140: CALL 19824 0 3
74144: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74145: LD_VAR 0 3
74149: PUSH
74150: LD_EXP 91
74154: PUSH
74155: LD_VAR 0 2
74159: ARRAY
74160: IN
74161: IFFALSE 74386
// begin if GetClass ( j ) <> 4 then
74163: LD_VAR 0 3
74167: PPUSH
74168: CALL_OW 257
74172: PUSH
74173: LD_INT 4
74175: NONEQUAL
74176: IFFALSE 74229
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
74178: LD_ADDR_EXP 91
74182: PUSH
74183: LD_EXP 91
74187: PPUSH
74188: LD_VAR 0 2
74192: PPUSH
74193: LD_EXP 91
74197: PUSH
74198: LD_VAR 0 2
74202: ARRAY
74203: PUSH
74204: LD_VAR 0 3
74208: DIFF
74209: PPUSH
74210: CALL_OW 1
74214: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74215: LD_VAR 0 3
74219: PPUSH
74220: LD_INT 0
74222: PPUSH
74223: CALL_OW 109
// continue ;
74227: GO 74051
// end ; if IsInUnit ( j ) then
74229: LD_VAR 0 3
74233: PPUSH
74234: CALL_OW 310
74238: IFFALSE 74249
// ComExitBuilding ( j ) ;
74240: LD_VAR 0 3
74244: PPUSH
74245: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
74249: LD_ADDR_VAR 0 6
74253: PUSH
74254: LD_VAR 0 7
74258: PPUSH
74259: LD_VAR 0 3
74263: PPUSH
74264: CALL_OW 74
74268: ST_TO_ADDR
// if not ape then
74269: LD_VAR 0 6
74273: NOT
74274: IFFALSE 74278
// break ;
74276: GO 74388
// x := GetX ( ape ) ;
74278: LD_ADDR_VAR 0 4
74282: PUSH
74283: LD_VAR 0 6
74287: PPUSH
74288: CALL_OW 250
74292: ST_TO_ADDR
// y := GetY ( ape ) ;
74293: LD_ADDR_VAR 0 5
74297: PUSH
74298: LD_VAR 0 6
74302: PPUSH
74303: CALL_OW 251
74307: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74308: LD_VAR 0 4
74312: PPUSH
74313: LD_VAR 0 5
74317: PPUSH
74318: CALL_OW 488
74322: NOT
74323: PUSH
74324: LD_VAR 0 11
74328: PPUSH
74329: LD_VAR 0 4
74333: PPUSH
74334: LD_VAR 0 5
74338: PPUSH
74339: LD_INT 20
74341: PPUSH
74342: CALL 20720 0 4
74346: PUSH
74347: LD_INT 4
74349: ARRAY
74350: OR
74351: IFFALSE 74355
// break ;
74353: GO 74388
// if not HasTask ( j ) then
74355: LD_VAR 0 3
74359: PPUSH
74360: CALL_OW 314
74364: NOT
74365: IFFALSE 74386
// ComTameXY ( j , x , y ) ;
74367: LD_VAR 0 3
74371: PPUSH
74372: LD_VAR 0 4
74376: PPUSH
74377: LD_VAR 0 5
74381: PPUSH
74382: CALL_OW 131
// end ; end ;
74386: GO 74051
74388: POP
74389: POP
// end ;
74390: GO 73607
74392: POP
74393: POP
// end ;
74394: LD_VAR 0 1
74398: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74399: LD_INT 0
74401: PPUSH
74402: PPUSH
74403: PPUSH
74404: PPUSH
74405: PPUSH
74406: PPUSH
74407: PPUSH
74408: PPUSH
// if not mc_bases then
74409: LD_EXP 60
74413: NOT
74414: IFFALSE 74418
// exit ;
74416: GO 75044
// for i = 1 to mc_bases do
74418: LD_ADDR_VAR 0 2
74422: PUSH
74423: DOUBLE
74424: LD_INT 1
74426: DEC
74427: ST_TO_ADDR
74428: LD_EXP 60
74432: PUSH
74433: FOR_TO
74434: IFFALSE 75042
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
74436: LD_EXP 89
74440: PUSH
74441: LD_VAR 0 2
74445: ARRAY
74446: NOT
74447: PUSH
74448: LD_EXP 89
74452: PUSH
74453: LD_VAR 0 2
74457: ARRAY
74458: PPUSH
74459: LD_INT 25
74461: PUSH
74462: LD_INT 12
74464: PUSH
74465: EMPTY
74466: LIST
74467: LIST
74468: PPUSH
74469: CALL_OW 72
74473: NOT
74474: OR
74475: IFFALSE 74479
// continue ;
74477: GO 74433
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
74479: LD_ADDR_VAR 0 5
74483: PUSH
74484: LD_EXP 89
74488: PUSH
74489: LD_VAR 0 2
74493: ARRAY
74494: PUSH
74495: LD_INT 1
74497: ARRAY
74498: PPUSH
74499: CALL_OW 255
74503: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74504: LD_VAR 0 5
74508: PPUSH
74509: LD_INT 2
74511: PPUSH
74512: CALL_OW 325
74516: IFFALSE 74769
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74518: LD_ADDR_VAR 0 4
74522: PUSH
74523: LD_EXP 89
74527: PUSH
74528: LD_VAR 0 2
74532: ARRAY
74533: PPUSH
74534: LD_INT 25
74536: PUSH
74537: LD_INT 16
74539: PUSH
74540: EMPTY
74541: LIST
74542: LIST
74543: PPUSH
74544: CALL_OW 72
74548: ST_TO_ADDR
// if tmp < 6 then
74549: LD_VAR 0 4
74553: PUSH
74554: LD_INT 6
74556: LESS
74557: IFFALSE 74769
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74559: LD_ADDR_VAR 0 6
74563: PUSH
74564: LD_EXP 60
74568: PUSH
74569: LD_VAR 0 2
74573: ARRAY
74574: PPUSH
74575: LD_INT 2
74577: PUSH
74578: LD_INT 30
74580: PUSH
74581: LD_INT 0
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: PUSH
74588: LD_INT 30
74590: PUSH
74591: LD_INT 1
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: LIST
74602: PPUSH
74603: CALL_OW 72
74607: ST_TO_ADDR
// if depot then
74608: LD_VAR 0 6
74612: IFFALSE 74769
// begin selected := 0 ;
74614: LD_ADDR_VAR 0 7
74618: PUSH
74619: LD_INT 0
74621: ST_TO_ADDR
// for j in depot do
74622: LD_ADDR_VAR 0 3
74626: PUSH
74627: LD_VAR 0 6
74631: PUSH
74632: FOR_IN
74633: IFFALSE 74664
// begin if UnitsInside ( j ) < 6 then
74635: LD_VAR 0 3
74639: PPUSH
74640: CALL_OW 313
74644: PUSH
74645: LD_INT 6
74647: LESS
74648: IFFALSE 74662
// begin selected := j ;
74650: LD_ADDR_VAR 0 7
74654: PUSH
74655: LD_VAR 0 3
74659: ST_TO_ADDR
// break ;
74660: GO 74664
// end ; end ;
74662: GO 74632
74664: POP
74665: POP
// if selected then
74666: LD_VAR 0 7
74670: IFFALSE 74769
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74672: LD_ADDR_VAR 0 3
74676: PUSH
74677: LD_EXP 89
74681: PUSH
74682: LD_VAR 0 2
74686: ARRAY
74687: PPUSH
74688: LD_INT 25
74690: PUSH
74691: LD_INT 12
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: PPUSH
74698: CALL_OW 72
74702: PUSH
74703: FOR_IN
74704: IFFALSE 74767
// if not HasTask ( j ) then
74706: LD_VAR 0 3
74710: PPUSH
74711: CALL_OW 314
74715: NOT
74716: IFFALSE 74765
// begin if not IsInUnit ( j ) then
74718: LD_VAR 0 3
74722: PPUSH
74723: CALL_OW 310
74727: NOT
74728: IFFALSE 74744
// ComEnterUnit ( j , selected ) ;
74730: LD_VAR 0 3
74734: PPUSH
74735: LD_VAR 0 7
74739: PPUSH
74740: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74744: LD_VAR 0 3
74748: PPUSH
74749: LD_INT 16
74751: PPUSH
74752: CALL_OW 183
// AddComExitBuilding ( j ) ;
74756: LD_VAR 0 3
74760: PPUSH
74761: CALL_OW 182
// end ;
74765: GO 74703
74767: POP
74768: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74769: LD_VAR 0 5
74773: PPUSH
74774: LD_INT 11
74776: PPUSH
74777: CALL_OW 325
74781: IFFALSE 75040
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74783: LD_ADDR_VAR 0 4
74787: PUSH
74788: LD_EXP 89
74792: PUSH
74793: LD_VAR 0 2
74797: ARRAY
74798: PPUSH
74799: LD_INT 25
74801: PUSH
74802: LD_INT 16
74804: PUSH
74805: EMPTY
74806: LIST
74807: LIST
74808: PPUSH
74809: CALL_OW 72
74813: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
74814: LD_VAR 0 4
74818: PUSH
74819: LD_INT 6
74821: GREATEREQUAL
74822: PUSH
74823: LD_VAR 0 5
74827: PPUSH
74828: LD_INT 2
74830: PPUSH
74831: CALL_OW 325
74835: NOT
74836: OR
74837: IFFALSE 75040
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74839: LD_ADDR_VAR 0 8
74843: PUSH
74844: LD_EXP 60
74848: PUSH
74849: LD_VAR 0 2
74853: ARRAY
74854: PPUSH
74855: LD_INT 2
74857: PUSH
74858: LD_INT 30
74860: PUSH
74861: LD_INT 4
74863: PUSH
74864: EMPTY
74865: LIST
74866: LIST
74867: PUSH
74868: LD_INT 30
74870: PUSH
74871: LD_INT 5
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: LIST
74882: PPUSH
74883: CALL_OW 72
74887: ST_TO_ADDR
// if barracks then
74888: LD_VAR 0 8
74892: IFFALSE 75040
// begin selected := 0 ;
74894: LD_ADDR_VAR 0 7
74898: PUSH
74899: LD_INT 0
74901: ST_TO_ADDR
// for j in barracks do
74902: LD_ADDR_VAR 0 3
74906: PUSH
74907: LD_VAR 0 8
74911: PUSH
74912: FOR_IN
74913: IFFALSE 74944
// begin if UnitsInside ( j ) < 6 then
74915: LD_VAR 0 3
74919: PPUSH
74920: CALL_OW 313
74924: PUSH
74925: LD_INT 6
74927: LESS
74928: IFFALSE 74942
// begin selected := j ;
74930: LD_ADDR_VAR 0 7
74934: PUSH
74935: LD_VAR 0 3
74939: ST_TO_ADDR
// break ;
74940: GO 74944
// end ; end ;
74942: GO 74912
74944: POP
74945: POP
// if selected then
74946: LD_VAR 0 7
74950: IFFALSE 75040
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74952: LD_ADDR_VAR 0 3
74956: PUSH
74957: LD_EXP 89
74961: PUSH
74962: LD_VAR 0 2
74966: ARRAY
74967: PPUSH
74968: LD_INT 25
74970: PUSH
74971: LD_INT 12
74973: PUSH
74974: EMPTY
74975: LIST
74976: LIST
74977: PPUSH
74978: CALL_OW 72
74982: PUSH
74983: FOR_IN
74984: IFFALSE 75038
// if not IsInUnit ( j ) and not HasTask ( j ) then
74986: LD_VAR 0 3
74990: PPUSH
74991: CALL_OW 310
74995: NOT
74996: PUSH
74997: LD_VAR 0 3
75001: PPUSH
75002: CALL_OW 314
75006: NOT
75007: AND
75008: IFFALSE 75036
// begin ComEnterUnit ( j , selected ) ;
75010: LD_VAR 0 3
75014: PPUSH
75015: LD_VAR 0 7
75019: PPUSH
75020: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75024: LD_VAR 0 3
75028: PPUSH
75029: LD_INT 15
75031: PPUSH
75032: CALL_OW 183
// end ;
75036: GO 74983
75038: POP
75039: POP
// end ; end ; end ; end ; end ;
75040: GO 74433
75042: POP
75043: POP
// end ;
75044: LD_VAR 0 1
75048: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75049: LD_INT 0
75051: PPUSH
75052: PPUSH
75053: PPUSH
75054: PPUSH
// if not mc_bases then
75055: LD_EXP 60
75059: NOT
75060: IFFALSE 75064
// exit ;
75062: GO 75242
// for i = 1 to mc_bases do
75064: LD_ADDR_VAR 0 2
75068: PUSH
75069: DOUBLE
75070: LD_INT 1
75072: DEC
75073: ST_TO_ADDR
75074: LD_EXP 60
75078: PUSH
75079: FOR_TO
75080: IFFALSE 75240
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75082: LD_ADDR_VAR 0 4
75086: PUSH
75087: LD_EXP 60
75091: PUSH
75092: LD_VAR 0 2
75096: ARRAY
75097: PPUSH
75098: LD_INT 25
75100: PUSH
75101: LD_INT 9
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PPUSH
75108: CALL_OW 72
75112: ST_TO_ADDR
// if not tmp then
75113: LD_VAR 0 4
75117: NOT
75118: IFFALSE 75122
// continue ;
75120: GO 75079
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75122: LD_EXP 86
75126: PUSH
75127: LD_VAR 0 2
75131: ARRAY
75132: PPUSH
75133: LD_INT 29
75135: PPUSH
75136: CALL_OW 325
75140: NOT
75141: PUSH
75142: LD_EXP 86
75146: PUSH
75147: LD_VAR 0 2
75151: ARRAY
75152: PPUSH
75153: LD_INT 28
75155: PPUSH
75156: CALL_OW 325
75160: NOT
75161: AND
75162: IFFALSE 75166
// continue ;
75164: GO 75079
// for j in tmp do
75166: LD_ADDR_VAR 0 3
75170: PUSH
75171: LD_VAR 0 4
75175: PUSH
75176: FOR_IN
75177: IFFALSE 75236
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75179: LD_VAR 0 3
75183: PUSH
75184: LD_EXP 63
75188: PUSH
75189: LD_VAR 0 2
75193: ARRAY
75194: PUSH
75195: LD_INT 1
75197: ARRAY
75198: IN
75199: NOT
75200: PUSH
75201: LD_VAR 0 3
75205: PUSH
75206: LD_EXP 63
75210: PUSH
75211: LD_VAR 0 2
75215: ARRAY
75216: PUSH
75217: LD_INT 2
75219: ARRAY
75220: IN
75221: NOT
75222: AND
75223: IFFALSE 75234
// ComSpaceTimeShoot ( j ) ;
75225: LD_VAR 0 3
75229: PPUSH
75230: CALL 15785 0 1
75234: GO 75176
75236: POP
75237: POP
// end ;
75238: GO 75079
75240: POP
75241: POP
// end ;
75242: LD_VAR 0 1
75246: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
75247: LD_INT 0
75249: PPUSH
75250: PPUSH
75251: PPUSH
75252: PPUSH
75253: PPUSH
75254: PPUSH
75255: PPUSH
75256: PPUSH
75257: PPUSH
// if not mc_bases then
75258: LD_EXP 60
75262: NOT
75263: IFFALSE 75267
// exit ;
75265: GO 75889
// for i = 1 to mc_bases do
75267: LD_ADDR_VAR 0 2
75271: PUSH
75272: DOUBLE
75273: LD_INT 1
75275: DEC
75276: ST_TO_ADDR
75277: LD_EXP 60
75281: PUSH
75282: FOR_TO
75283: IFFALSE 75887
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
75285: LD_EXP 95
75289: PUSH
75290: LD_VAR 0 2
75294: ARRAY
75295: NOT
75296: PUSH
75297: LD_INT 38
75299: PPUSH
75300: LD_EXP 86
75304: PUSH
75305: LD_VAR 0 2
75309: ARRAY
75310: PPUSH
75311: CALL_OW 321
75315: PUSH
75316: LD_INT 2
75318: NONEQUAL
75319: OR
75320: IFFALSE 75324
// continue ;
75322: GO 75282
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75324: LD_ADDR_VAR 0 8
75328: PUSH
75329: LD_EXP 60
75333: PUSH
75334: LD_VAR 0 2
75338: ARRAY
75339: PPUSH
75340: LD_INT 30
75342: PUSH
75343: LD_INT 34
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: PPUSH
75350: CALL_OW 72
75354: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75355: LD_ADDR_VAR 0 9
75359: PUSH
75360: LD_EXP 60
75364: PUSH
75365: LD_VAR 0 2
75369: ARRAY
75370: PPUSH
75371: LD_INT 25
75373: PUSH
75374: LD_INT 4
75376: PUSH
75377: EMPTY
75378: LIST
75379: LIST
75380: PPUSH
75381: CALL_OW 72
75385: PPUSH
75386: LD_INT 0
75388: PPUSH
75389: CALL 49093 0 2
75393: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75394: LD_VAR 0 9
75398: NOT
75399: PUSH
75400: LD_VAR 0 8
75404: NOT
75405: OR
75406: PUSH
75407: LD_EXP 60
75411: PUSH
75412: LD_VAR 0 2
75416: ARRAY
75417: PPUSH
75418: LD_INT 124
75420: PPUSH
75421: CALL 49093 0 2
75425: OR
75426: IFFALSE 75430
// continue ;
75428: GO 75282
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
75430: LD_EXP 96
75434: PUSH
75435: LD_VAR 0 2
75439: ARRAY
75440: PUSH
75441: LD_EXP 95
75445: PUSH
75446: LD_VAR 0 2
75450: ARRAY
75451: LESS
75452: PUSH
75453: LD_EXP 96
75457: PUSH
75458: LD_VAR 0 2
75462: ARRAY
75463: PUSH
75464: LD_VAR 0 8
75468: LESS
75469: AND
75470: IFFALSE 75885
// begin tmp := sci [ 1 ] ;
75472: LD_ADDR_VAR 0 7
75476: PUSH
75477: LD_VAR 0 9
75481: PUSH
75482: LD_INT 1
75484: ARRAY
75485: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
75486: LD_VAR 0 7
75490: PPUSH
75491: LD_INT 124
75493: PPUSH
75494: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
75498: LD_ADDR_VAR 0 3
75502: PUSH
75503: DOUBLE
75504: LD_EXP 95
75508: PUSH
75509: LD_VAR 0 2
75513: ARRAY
75514: INC
75515: ST_TO_ADDR
75516: LD_EXP 95
75520: PUSH
75521: LD_VAR 0 2
75525: ARRAY
75526: PUSH
75527: FOR_DOWNTO
75528: IFFALSE 75871
// begin if IsInUnit ( tmp ) then
75530: LD_VAR 0 7
75534: PPUSH
75535: CALL_OW 310
75539: IFFALSE 75550
// ComExitBuilding ( tmp ) ;
75541: LD_VAR 0 7
75545: PPUSH
75546: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75550: LD_INT 35
75552: PPUSH
75553: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75557: LD_VAR 0 7
75561: PPUSH
75562: CALL_OW 310
75566: NOT
75567: PUSH
75568: LD_VAR 0 7
75572: PPUSH
75573: CALL_OW 314
75577: NOT
75578: AND
75579: IFFALSE 75550
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75581: LD_ADDR_VAR 0 6
75585: PUSH
75586: LD_VAR 0 7
75590: PPUSH
75591: CALL_OW 250
75595: PUSH
75596: LD_VAR 0 7
75600: PPUSH
75601: CALL_OW 251
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75610: LD_INT 35
75612: PPUSH
75613: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75617: LD_ADDR_VAR 0 4
75621: PUSH
75622: LD_EXP 95
75626: PUSH
75627: LD_VAR 0 2
75631: ARRAY
75632: PUSH
75633: LD_VAR 0 3
75637: ARRAY
75638: PUSH
75639: LD_INT 1
75641: ARRAY
75642: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
75643: LD_ADDR_VAR 0 5
75647: PUSH
75648: LD_EXP 95
75652: PUSH
75653: LD_VAR 0 2
75657: ARRAY
75658: PUSH
75659: LD_VAR 0 3
75663: ARRAY
75664: PUSH
75665: LD_INT 2
75667: ARRAY
75668: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75669: LD_VAR 0 7
75673: PPUSH
75674: LD_INT 10
75676: PPUSH
75677: CALL 22423 0 2
75681: PUSH
75682: LD_INT 4
75684: ARRAY
75685: IFFALSE 75723
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75687: LD_VAR 0 7
75691: PPUSH
75692: LD_VAR 0 6
75696: PUSH
75697: LD_INT 1
75699: ARRAY
75700: PPUSH
75701: LD_VAR 0 6
75705: PUSH
75706: LD_INT 2
75708: ARRAY
75709: PPUSH
75710: CALL_OW 111
// wait ( 0 0$10 ) ;
75714: LD_INT 350
75716: PPUSH
75717: CALL_OW 67
// end else
75721: GO 75749
// begin ComMoveXY ( tmp , x , y ) ;
75723: LD_VAR 0 7
75727: PPUSH
75728: LD_VAR 0 4
75732: PPUSH
75733: LD_VAR 0 5
75737: PPUSH
75738: CALL_OW 111
// wait ( 0 0$3 ) ;
75742: LD_INT 105
75744: PPUSH
75745: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75749: LD_VAR 0 7
75753: PPUSH
75754: LD_VAR 0 4
75758: PPUSH
75759: LD_VAR 0 5
75763: PPUSH
75764: CALL_OW 307
75768: IFFALSE 75610
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75770: LD_VAR 0 7
75774: PPUSH
75775: LD_VAR 0 4
75779: PPUSH
75780: LD_VAR 0 5
75784: PPUSH
75785: LD_VAR 0 8
75789: PUSH
75790: LD_VAR 0 3
75794: ARRAY
75795: PPUSH
75796: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
75800: LD_INT 35
75802: PPUSH
75803: CALL_OW 67
// until not HasTask ( tmp ) ;
75807: LD_VAR 0 7
75811: PPUSH
75812: CALL_OW 314
75816: NOT
75817: IFFALSE 75800
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
75819: LD_ADDR_EXP 96
75823: PUSH
75824: LD_EXP 96
75828: PPUSH
75829: LD_VAR 0 2
75833: PUSH
75834: LD_EXP 96
75838: PUSH
75839: LD_VAR 0 2
75843: ARRAY
75844: PUSH
75845: LD_INT 1
75847: PLUS
75848: PUSH
75849: EMPTY
75850: LIST
75851: LIST
75852: PPUSH
75853: LD_VAR 0 8
75857: PUSH
75858: LD_VAR 0 3
75862: ARRAY
75863: PPUSH
75864: CALL 19824 0 3
75868: ST_TO_ADDR
// end ;
75869: GO 75527
75871: POP
75872: POP
// MC_Reset ( i , 124 ) ;
75873: LD_VAR 0 2
75877: PPUSH
75878: LD_INT 124
75880: PPUSH
75881: CALL 59027 0 2
// end ; end ;
75885: GO 75282
75887: POP
75888: POP
// end ;
75889: LD_VAR 0 1
75893: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
75894: LD_INT 0
75896: PPUSH
75897: PPUSH
75898: PPUSH
// if not mc_bases then
75899: LD_EXP 60
75903: NOT
75904: IFFALSE 75908
// exit ;
75906: GO 76514
// for i = 1 to mc_bases do
75908: LD_ADDR_VAR 0 2
75912: PUSH
75913: DOUBLE
75914: LD_INT 1
75916: DEC
75917: ST_TO_ADDR
75918: LD_EXP 60
75922: PUSH
75923: FOR_TO
75924: IFFALSE 76512
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
75926: LD_ADDR_VAR 0 3
75930: PUSH
75931: LD_EXP 60
75935: PUSH
75936: LD_VAR 0 2
75940: ARRAY
75941: PPUSH
75942: LD_INT 25
75944: PUSH
75945: LD_INT 4
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PPUSH
75952: CALL_OW 72
75956: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75957: LD_VAR 0 3
75961: NOT
75962: PUSH
75963: LD_EXP 97
75967: PUSH
75968: LD_VAR 0 2
75972: ARRAY
75973: NOT
75974: OR
75975: PUSH
75976: LD_EXP 60
75980: PUSH
75981: LD_VAR 0 2
75985: ARRAY
75986: PPUSH
75987: LD_INT 2
75989: PUSH
75990: LD_INT 30
75992: PUSH
75993: LD_INT 0
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: LD_INT 30
76002: PUSH
76003: LD_INT 1
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: LIST
76014: PPUSH
76015: CALL_OW 72
76019: NOT
76020: OR
76021: IFFALSE 76071
// begin if mc_deposits_finder [ i ] then
76023: LD_EXP 98
76027: PUSH
76028: LD_VAR 0 2
76032: ARRAY
76033: IFFALSE 76069
// begin MC_Reset ( i , 125 ) ;
76035: LD_VAR 0 2
76039: PPUSH
76040: LD_INT 125
76042: PPUSH
76043: CALL 59027 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76047: LD_ADDR_EXP 98
76051: PUSH
76052: LD_EXP 98
76056: PPUSH
76057: LD_VAR 0 2
76061: PPUSH
76062: EMPTY
76063: PPUSH
76064: CALL_OW 1
76068: ST_TO_ADDR
// end ; continue ;
76069: GO 75923
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76071: LD_EXP 97
76075: PUSH
76076: LD_VAR 0 2
76080: ARRAY
76081: PUSH
76082: LD_INT 1
76084: ARRAY
76085: PUSH
76086: LD_INT 3
76088: ARRAY
76089: PUSH
76090: LD_INT 1
76092: EQUAL
76093: PUSH
76094: LD_INT 20
76096: PPUSH
76097: LD_EXP 86
76101: PUSH
76102: LD_VAR 0 2
76106: ARRAY
76107: PPUSH
76108: CALL_OW 321
76112: PUSH
76113: LD_INT 2
76115: NONEQUAL
76116: AND
76117: IFFALSE 76167
// begin if mc_deposits_finder [ i ] then
76119: LD_EXP 98
76123: PUSH
76124: LD_VAR 0 2
76128: ARRAY
76129: IFFALSE 76165
// begin MC_Reset ( i , 125 ) ;
76131: LD_VAR 0 2
76135: PPUSH
76136: LD_INT 125
76138: PPUSH
76139: CALL 59027 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76143: LD_ADDR_EXP 98
76147: PUSH
76148: LD_EXP 98
76152: PPUSH
76153: LD_VAR 0 2
76157: PPUSH
76158: EMPTY
76159: PPUSH
76160: CALL_OW 1
76164: ST_TO_ADDR
// end ; continue ;
76165: GO 75923
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
76167: LD_EXP 97
76171: PUSH
76172: LD_VAR 0 2
76176: ARRAY
76177: PUSH
76178: LD_INT 1
76180: ARRAY
76181: PUSH
76182: LD_INT 1
76184: ARRAY
76185: PPUSH
76186: LD_EXP 97
76190: PUSH
76191: LD_VAR 0 2
76195: ARRAY
76196: PUSH
76197: LD_INT 1
76199: ARRAY
76200: PUSH
76201: LD_INT 2
76203: ARRAY
76204: PPUSH
76205: LD_EXP 86
76209: PUSH
76210: LD_VAR 0 2
76214: ARRAY
76215: PPUSH
76216: CALL_OW 440
76220: IFFALSE 76263
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
76222: LD_ADDR_EXP 97
76226: PUSH
76227: LD_EXP 97
76231: PPUSH
76232: LD_VAR 0 2
76236: PPUSH
76237: LD_EXP 97
76241: PUSH
76242: LD_VAR 0 2
76246: ARRAY
76247: PPUSH
76248: LD_INT 1
76250: PPUSH
76251: CALL_OW 3
76255: PPUSH
76256: CALL_OW 1
76260: ST_TO_ADDR
76261: GO 76510
// begin if not mc_deposits_finder [ i ] then
76263: LD_EXP 98
76267: PUSH
76268: LD_VAR 0 2
76272: ARRAY
76273: NOT
76274: IFFALSE 76326
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
76276: LD_ADDR_EXP 98
76280: PUSH
76281: LD_EXP 98
76285: PPUSH
76286: LD_VAR 0 2
76290: PPUSH
76291: LD_VAR 0 3
76295: PUSH
76296: LD_INT 1
76298: ARRAY
76299: PUSH
76300: EMPTY
76301: LIST
76302: PPUSH
76303: CALL_OW 1
76307: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76308: LD_VAR 0 3
76312: PUSH
76313: LD_INT 1
76315: ARRAY
76316: PPUSH
76317: LD_INT 125
76319: PPUSH
76320: CALL_OW 109
// end else
76324: GO 76510
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76326: LD_EXP 98
76330: PUSH
76331: LD_VAR 0 2
76335: ARRAY
76336: PUSH
76337: LD_INT 1
76339: ARRAY
76340: PPUSH
76341: CALL_OW 310
76345: IFFALSE 76368
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76347: LD_EXP 98
76351: PUSH
76352: LD_VAR 0 2
76356: ARRAY
76357: PUSH
76358: LD_INT 1
76360: ARRAY
76361: PPUSH
76362: CALL_OW 122
76366: GO 76510
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76368: LD_EXP 98
76372: PUSH
76373: LD_VAR 0 2
76377: ARRAY
76378: PUSH
76379: LD_INT 1
76381: ARRAY
76382: PPUSH
76383: CALL_OW 314
76387: NOT
76388: PUSH
76389: LD_EXP 98
76393: PUSH
76394: LD_VAR 0 2
76398: ARRAY
76399: PUSH
76400: LD_INT 1
76402: ARRAY
76403: PPUSH
76404: LD_EXP 97
76408: PUSH
76409: LD_VAR 0 2
76413: ARRAY
76414: PUSH
76415: LD_INT 1
76417: ARRAY
76418: PUSH
76419: LD_INT 1
76421: ARRAY
76422: PPUSH
76423: LD_EXP 97
76427: PUSH
76428: LD_VAR 0 2
76432: ARRAY
76433: PUSH
76434: LD_INT 1
76436: ARRAY
76437: PUSH
76438: LD_INT 2
76440: ARRAY
76441: PPUSH
76442: CALL_OW 297
76446: PUSH
76447: LD_INT 6
76449: GREATER
76450: AND
76451: IFFALSE 76510
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
76453: LD_EXP 98
76457: PUSH
76458: LD_VAR 0 2
76462: ARRAY
76463: PUSH
76464: LD_INT 1
76466: ARRAY
76467: PPUSH
76468: LD_EXP 97
76472: PUSH
76473: LD_VAR 0 2
76477: ARRAY
76478: PUSH
76479: LD_INT 1
76481: ARRAY
76482: PUSH
76483: LD_INT 1
76485: ARRAY
76486: PPUSH
76487: LD_EXP 97
76491: PUSH
76492: LD_VAR 0 2
76496: ARRAY
76497: PUSH
76498: LD_INT 1
76500: ARRAY
76501: PUSH
76502: LD_INT 2
76504: ARRAY
76505: PPUSH
76506: CALL_OW 111
// end ; end ; end ;
76510: GO 75923
76512: POP
76513: POP
// end ;
76514: LD_VAR 0 1
76518: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76519: LD_INT 0
76521: PPUSH
76522: PPUSH
76523: PPUSH
76524: PPUSH
76525: PPUSH
76526: PPUSH
76527: PPUSH
76528: PPUSH
76529: PPUSH
76530: PPUSH
76531: PPUSH
// if not mc_bases then
76532: LD_EXP 60
76536: NOT
76537: IFFALSE 76541
// exit ;
76539: GO 77481
// for i = 1 to mc_bases do
76541: LD_ADDR_VAR 0 2
76545: PUSH
76546: DOUBLE
76547: LD_INT 1
76549: DEC
76550: ST_TO_ADDR
76551: LD_EXP 60
76555: PUSH
76556: FOR_TO
76557: IFFALSE 77479
// begin if not mc_bases [ i ] or mc_scan [ i ] then
76559: LD_EXP 60
76563: PUSH
76564: LD_VAR 0 2
76568: ARRAY
76569: NOT
76570: PUSH
76571: LD_EXP 83
76575: PUSH
76576: LD_VAR 0 2
76580: ARRAY
76581: OR
76582: IFFALSE 76586
// continue ;
76584: GO 76556
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76586: LD_ADDR_VAR 0 7
76590: PUSH
76591: LD_EXP 60
76595: PUSH
76596: LD_VAR 0 2
76600: ARRAY
76601: PUSH
76602: LD_INT 1
76604: ARRAY
76605: PPUSH
76606: CALL_OW 248
76610: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76611: LD_VAR 0 7
76615: PUSH
76616: LD_INT 3
76618: EQUAL
76619: PUSH
76620: LD_EXP 79
76624: PUSH
76625: LD_VAR 0 2
76629: ARRAY
76630: PUSH
76631: LD_EXP 82
76635: PUSH
76636: LD_VAR 0 2
76640: ARRAY
76641: UNION
76642: PPUSH
76643: LD_INT 33
76645: PUSH
76646: LD_INT 2
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: PPUSH
76653: CALL_OW 72
76657: NOT
76658: OR
76659: IFFALSE 76663
// continue ;
76661: GO 76556
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76663: LD_ADDR_VAR 0 9
76667: PUSH
76668: LD_EXP 60
76672: PUSH
76673: LD_VAR 0 2
76677: ARRAY
76678: PPUSH
76679: LD_INT 30
76681: PUSH
76682: LD_INT 36
76684: PUSH
76685: EMPTY
76686: LIST
76687: LIST
76688: PPUSH
76689: CALL_OW 72
76693: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76694: LD_ADDR_VAR 0 10
76698: PUSH
76699: LD_EXP 79
76703: PUSH
76704: LD_VAR 0 2
76708: ARRAY
76709: PPUSH
76710: LD_INT 34
76712: PUSH
76713: LD_INT 31
76715: PUSH
76716: EMPTY
76717: LIST
76718: LIST
76719: PPUSH
76720: CALL_OW 72
76724: ST_TO_ADDR
// if not cts and not mcts then
76725: LD_VAR 0 9
76729: NOT
76730: PUSH
76731: LD_VAR 0 10
76735: NOT
76736: AND
76737: IFFALSE 76741
// continue ;
76739: GO 76556
// x := cts ;
76741: LD_ADDR_VAR 0 11
76745: PUSH
76746: LD_VAR 0 9
76750: ST_TO_ADDR
// if not x then
76751: LD_VAR 0 11
76755: NOT
76756: IFFALSE 76768
// x := mcts ;
76758: LD_ADDR_VAR 0 11
76762: PUSH
76763: LD_VAR 0 10
76767: ST_TO_ADDR
// if not x then
76768: LD_VAR 0 11
76772: NOT
76773: IFFALSE 76777
// continue ;
76775: GO 76556
// if mc_remote_driver [ i ] then
76777: LD_EXP 100
76781: PUSH
76782: LD_VAR 0 2
76786: ARRAY
76787: IFFALSE 77174
// for j in mc_remote_driver [ i ] do
76789: LD_ADDR_VAR 0 3
76793: PUSH
76794: LD_EXP 100
76798: PUSH
76799: LD_VAR 0 2
76803: ARRAY
76804: PUSH
76805: FOR_IN
76806: IFFALSE 77172
// begin if GetClass ( j ) <> 3 then
76808: LD_VAR 0 3
76812: PPUSH
76813: CALL_OW 257
76817: PUSH
76818: LD_INT 3
76820: NONEQUAL
76821: IFFALSE 76874
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
76823: LD_ADDR_EXP 100
76827: PUSH
76828: LD_EXP 100
76832: PPUSH
76833: LD_VAR 0 2
76837: PPUSH
76838: LD_EXP 100
76842: PUSH
76843: LD_VAR 0 2
76847: ARRAY
76848: PUSH
76849: LD_VAR 0 3
76853: DIFF
76854: PPUSH
76855: CALL_OW 1
76859: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76860: LD_VAR 0 3
76864: PPUSH
76865: LD_INT 0
76867: PPUSH
76868: CALL_OW 109
// continue ;
76872: GO 76805
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
76874: LD_EXP 79
76878: PUSH
76879: LD_VAR 0 2
76883: ARRAY
76884: PPUSH
76885: LD_INT 34
76887: PUSH
76888: LD_INT 31
76890: PUSH
76891: EMPTY
76892: LIST
76893: LIST
76894: PUSH
76895: LD_INT 58
76897: PUSH
76898: EMPTY
76899: LIST
76900: PUSH
76901: EMPTY
76902: LIST
76903: LIST
76904: PPUSH
76905: CALL_OW 72
76909: PUSH
76910: LD_VAR 0 3
76914: PPUSH
76915: CALL 49128 0 1
76919: NOT
76920: AND
76921: IFFALSE 76992
// begin if IsInUnit ( j ) then
76923: LD_VAR 0 3
76927: PPUSH
76928: CALL_OW 310
76932: IFFALSE 76943
// ComExitBuilding ( j ) ;
76934: LD_VAR 0 3
76938: PPUSH
76939: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
76943: LD_VAR 0 3
76947: PPUSH
76948: LD_EXP 79
76952: PUSH
76953: LD_VAR 0 2
76957: ARRAY
76958: PPUSH
76959: LD_INT 34
76961: PUSH
76962: LD_INT 31
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 58
76971: PUSH
76972: EMPTY
76973: LIST
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PPUSH
76979: CALL_OW 72
76983: PUSH
76984: LD_INT 1
76986: ARRAY
76987: PPUSH
76988: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
76992: LD_VAR 0 3
76996: PPUSH
76997: CALL_OW 310
77001: NOT
77002: PUSH
77003: LD_VAR 0 3
77007: PPUSH
77008: CALL_OW 310
77012: PPUSH
77013: CALL_OW 266
77017: PUSH
77018: LD_INT 36
77020: NONEQUAL
77021: PUSH
77022: LD_VAR 0 3
77026: PPUSH
77027: CALL 49128 0 1
77031: NOT
77032: AND
77033: OR
77034: IFFALSE 77170
// begin if IsInUnit ( j ) then
77036: LD_VAR 0 3
77040: PPUSH
77041: CALL_OW 310
77045: IFFALSE 77056
// ComExitBuilding ( j ) ;
77047: LD_VAR 0 3
77051: PPUSH
77052: CALL_OW 122
// ct := 0 ;
77056: LD_ADDR_VAR 0 8
77060: PUSH
77061: LD_INT 0
77063: ST_TO_ADDR
// for k in x do
77064: LD_ADDR_VAR 0 4
77068: PUSH
77069: LD_VAR 0 11
77073: PUSH
77074: FOR_IN
77075: IFFALSE 77148
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77077: LD_VAR 0 4
77081: PPUSH
77082: CALL_OW 264
77086: PUSH
77087: LD_INT 31
77089: EQUAL
77090: PUSH
77091: LD_VAR 0 4
77095: PPUSH
77096: CALL_OW 311
77100: NOT
77101: AND
77102: PUSH
77103: LD_VAR 0 4
77107: PPUSH
77108: CALL_OW 266
77112: PUSH
77113: LD_INT 36
77115: EQUAL
77116: PUSH
77117: LD_VAR 0 4
77121: PPUSH
77122: CALL_OW 313
77126: PUSH
77127: LD_INT 3
77129: LESS
77130: AND
77131: OR
77132: IFFALSE 77146
// begin ct := k ;
77134: LD_ADDR_VAR 0 8
77138: PUSH
77139: LD_VAR 0 4
77143: ST_TO_ADDR
// break ;
77144: GO 77148
// end ;
77146: GO 77074
77148: POP
77149: POP
// if ct then
77150: LD_VAR 0 8
77154: IFFALSE 77170
// ComEnterUnit ( j , ct ) ;
77156: LD_VAR 0 3
77160: PPUSH
77161: LD_VAR 0 8
77165: PPUSH
77166: CALL_OW 120
// end ; end ;
77170: GO 76805
77172: POP
77173: POP
// places := 0 ;
77174: LD_ADDR_VAR 0 5
77178: PUSH
77179: LD_INT 0
77181: ST_TO_ADDR
// for j = 1 to x do
77182: LD_ADDR_VAR 0 3
77186: PUSH
77187: DOUBLE
77188: LD_INT 1
77190: DEC
77191: ST_TO_ADDR
77192: LD_VAR 0 11
77196: PUSH
77197: FOR_TO
77198: IFFALSE 77274
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77200: LD_VAR 0 11
77204: PUSH
77205: LD_VAR 0 3
77209: ARRAY
77210: PPUSH
77211: CALL_OW 264
77215: PUSH
77216: LD_INT 31
77218: EQUAL
77219: IFFALSE 77237
// places := places + 1 else
77221: LD_ADDR_VAR 0 5
77225: PUSH
77226: LD_VAR 0 5
77230: PUSH
77231: LD_INT 1
77233: PLUS
77234: ST_TO_ADDR
77235: GO 77272
// if GetBType ( x [ j ] ) = b_control_tower then
77237: LD_VAR 0 11
77241: PUSH
77242: LD_VAR 0 3
77246: ARRAY
77247: PPUSH
77248: CALL_OW 266
77252: PUSH
77253: LD_INT 36
77255: EQUAL
77256: IFFALSE 77272
// places := places + 3 ;
77258: LD_ADDR_VAR 0 5
77262: PUSH
77263: LD_VAR 0 5
77267: PUSH
77268: LD_INT 3
77270: PLUS
77271: ST_TO_ADDR
77272: GO 77197
77274: POP
77275: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
77276: LD_VAR 0 5
77280: PUSH
77281: LD_INT 0
77283: EQUAL
77284: PUSH
77285: LD_VAR 0 5
77289: PUSH
77290: LD_EXP 100
77294: PUSH
77295: LD_VAR 0 2
77299: ARRAY
77300: LESSEQUAL
77301: OR
77302: IFFALSE 77306
// continue ;
77304: GO 76556
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
77306: LD_ADDR_VAR 0 6
77310: PUSH
77311: LD_EXP 60
77315: PUSH
77316: LD_VAR 0 2
77320: ARRAY
77321: PPUSH
77322: LD_INT 25
77324: PUSH
77325: LD_INT 3
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PPUSH
77332: CALL_OW 72
77336: PUSH
77337: LD_EXP 100
77341: PUSH
77342: LD_VAR 0 2
77346: ARRAY
77347: DIFF
77348: PPUSH
77349: LD_INT 3
77351: PPUSH
77352: CALL 50028 0 2
77356: ST_TO_ADDR
// for j in tmp do
77357: LD_ADDR_VAR 0 3
77361: PUSH
77362: LD_VAR 0 6
77366: PUSH
77367: FOR_IN
77368: IFFALSE 77403
// if GetTag ( j ) > 0 then
77370: LD_VAR 0 3
77374: PPUSH
77375: CALL_OW 110
77379: PUSH
77380: LD_INT 0
77382: GREATER
77383: IFFALSE 77401
// tmp := tmp diff j ;
77385: LD_ADDR_VAR 0 6
77389: PUSH
77390: LD_VAR 0 6
77394: PUSH
77395: LD_VAR 0 3
77399: DIFF
77400: ST_TO_ADDR
77401: GO 77367
77403: POP
77404: POP
// if not tmp then
77405: LD_VAR 0 6
77409: NOT
77410: IFFALSE 77414
// continue ;
77412: GO 76556
// if places then
77414: LD_VAR 0 5
77418: IFFALSE 77477
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
77420: LD_ADDR_EXP 100
77424: PUSH
77425: LD_EXP 100
77429: PPUSH
77430: LD_VAR 0 2
77434: PPUSH
77435: LD_EXP 100
77439: PUSH
77440: LD_VAR 0 2
77444: ARRAY
77445: PUSH
77446: LD_VAR 0 6
77450: PUSH
77451: LD_INT 1
77453: ARRAY
77454: UNION
77455: PPUSH
77456: CALL_OW 1
77460: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
77461: LD_VAR 0 6
77465: PUSH
77466: LD_INT 1
77468: ARRAY
77469: PPUSH
77470: LD_INT 126
77472: PPUSH
77473: CALL_OW 109
// end ; end ;
77477: GO 76556
77479: POP
77480: POP
// end ;
77481: LD_VAR 0 1
77485: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
77486: LD_INT 0
77488: PPUSH
77489: PPUSH
77490: PPUSH
77491: PPUSH
77492: PPUSH
77493: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
77494: LD_VAR 0 1
77498: NOT
77499: PUSH
77500: LD_VAR 0 2
77504: NOT
77505: OR
77506: PUSH
77507: LD_VAR 0 3
77511: NOT
77512: OR
77513: PUSH
77514: LD_VAR 0 4
77518: PUSH
77519: LD_INT 1
77521: PUSH
77522: LD_INT 2
77524: PUSH
77525: LD_INT 3
77527: PUSH
77528: LD_INT 4
77530: PUSH
77531: LD_INT 5
77533: PUSH
77534: LD_INT 8
77536: PUSH
77537: LD_INT 9
77539: PUSH
77540: LD_INT 15
77542: PUSH
77543: LD_INT 16
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: LIST
77550: LIST
77551: LIST
77552: LIST
77553: LIST
77554: LIST
77555: LIST
77556: IN
77557: NOT
77558: OR
77559: IFFALSE 77563
// exit ;
77561: GO 78463
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77563: LD_ADDR_VAR 0 2
77567: PUSH
77568: LD_VAR 0 2
77572: PPUSH
77573: LD_INT 21
77575: PUSH
77576: LD_INT 3
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: PUSH
77583: LD_INT 24
77585: PUSH
77586: LD_INT 250
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: PPUSH
77597: CALL_OW 72
77601: ST_TO_ADDR
// case class of 1 , 15 :
77602: LD_VAR 0 4
77606: PUSH
77607: LD_INT 1
77609: DOUBLE
77610: EQUAL
77611: IFTRUE 77621
77613: LD_INT 15
77615: DOUBLE
77616: EQUAL
77617: IFTRUE 77621
77619: GO 77706
77621: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77622: LD_ADDR_VAR 0 8
77626: PUSH
77627: LD_VAR 0 2
77631: PPUSH
77632: LD_INT 2
77634: PUSH
77635: LD_INT 30
77637: PUSH
77638: LD_INT 32
77640: PUSH
77641: EMPTY
77642: LIST
77643: LIST
77644: PUSH
77645: LD_INT 30
77647: PUSH
77648: LD_INT 31
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: PUSH
77655: EMPTY
77656: LIST
77657: LIST
77658: LIST
77659: PPUSH
77660: CALL_OW 72
77664: PUSH
77665: LD_VAR 0 2
77669: PPUSH
77670: LD_INT 2
77672: PUSH
77673: LD_INT 30
77675: PUSH
77676: LD_INT 4
77678: PUSH
77679: EMPTY
77680: LIST
77681: LIST
77682: PUSH
77683: LD_INT 30
77685: PUSH
77686: LD_INT 5
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: LIST
77697: PPUSH
77698: CALL_OW 72
77702: ADD
77703: ST_TO_ADDR
77704: GO 77952
77706: LD_INT 2
77708: DOUBLE
77709: EQUAL
77710: IFTRUE 77720
77712: LD_INT 16
77714: DOUBLE
77715: EQUAL
77716: IFTRUE 77720
77718: GO 77766
77720: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77721: LD_ADDR_VAR 0 8
77725: PUSH
77726: LD_VAR 0 2
77730: PPUSH
77731: LD_INT 2
77733: PUSH
77734: LD_INT 30
77736: PUSH
77737: LD_INT 0
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: PUSH
77744: LD_INT 30
77746: PUSH
77747: LD_INT 1
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: LIST
77758: PPUSH
77759: CALL_OW 72
77763: ST_TO_ADDR
77764: GO 77952
77766: LD_INT 3
77768: DOUBLE
77769: EQUAL
77770: IFTRUE 77774
77772: GO 77820
77774: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77775: LD_ADDR_VAR 0 8
77779: PUSH
77780: LD_VAR 0 2
77784: PPUSH
77785: LD_INT 2
77787: PUSH
77788: LD_INT 30
77790: PUSH
77791: LD_INT 2
77793: PUSH
77794: EMPTY
77795: LIST
77796: LIST
77797: PUSH
77798: LD_INT 30
77800: PUSH
77801: LD_INT 3
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: LIST
77812: PPUSH
77813: CALL_OW 72
77817: ST_TO_ADDR
77818: GO 77952
77820: LD_INT 4
77822: DOUBLE
77823: EQUAL
77824: IFTRUE 77828
77826: GO 77885
77828: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
77829: LD_ADDR_VAR 0 8
77833: PUSH
77834: LD_VAR 0 2
77838: PPUSH
77839: LD_INT 2
77841: PUSH
77842: LD_INT 30
77844: PUSH
77845: LD_INT 6
77847: PUSH
77848: EMPTY
77849: LIST
77850: LIST
77851: PUSH
77852: LD_INT 30
77854: PUSH
77855: LD_INT 7
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: LD_INT 30
77864: PUSH
77865: LD_INT 8
77867: PUSH
77868: EMPTY
77869: LIST
77870: LIST
77871: PUSH
77872: EMPTY
77873: LIST
77874: LIST
77875: LIST
77876: LIST
77877: PPUSH
77878: CALL_OW 72
77882: ST_TO_ADDR
77883: GO 77952
77885: LD_INT 5
77887: DOUBLE
77888: EQUAL
77889: IFTRUE 77905
77891: LD_INT 8
77893: DOUBLE
77894: EQUAL
77895: IFTRUE 77905
77897: LD_INT 9
77899: DOUBLE
77900: EQUAL
77901: IFTRUE 77905
77903: GO 77951
77905: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
77906: LD_ADDR_VAR 0 8
77910: PUSH
77911: LD_VAR 0 2
77915: PPUSH
77916: LD_INT 2
77918: PUSH
77919: LD_INT 30
77921: PUSH
77922: LD_INT 4
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 30
77931: PUSH
77932: LD_INT 5
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: EMPTY
77940: LIST
77941: LIST
77942: LIST
77943: PPUSH
77944: CALL_OW 72
77948: ST_TO_ADDR
77949: GO 77952
77951: POP
// if not tmp then
77952: LD_VAR 0 8
77956: NOT
77957: IFFALSE 77961
// exit ;
77959: GO 78463
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
77961: LD_VAR 0 4
77965: PUSH
77966: LD_INT 1
77968: PUSH
77969: LD_INT 15
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: IN
77976: PUSH
77977: LD_EXP 69
77981: PUSH
77982: LD_VAR 0 1
77986: ARRAY
77987: AND
77988: IFFALSE 78144
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
77990: LD_ADDR_VAR 0 9
77994: PUSH
77995: LD_EXP 69
77999: PUSH
78000: LD_VAR 0 1
78004: ARRAY
78005: PUSH
78006: LD_INT 1
78008: ARRAY
78009: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78010: LD_VAR 0 9
78014: PUSH
78015: LD_EXP 70
78019: PUSH
78020: LD_VAR 0 1
78024: ARRAY
78025: IN
78026: NOT
78027: IFFALSE 78142
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78029: LD_ADDR_EXP 70
78033: PUSH
78034: LD_EXP 70
78038: PPUSH
78039: LD_VAR 0 1
78043: PUSH
78044: LD_EXP 70
78048: PUSH
78049: LD_VAR 0 1
78053: ARRAY
78054: PUSH
78055: LD_INT 1
78057: PLUS
78058: PUSH
78059: EMPTY
78060: LIST
78061: LIST
78062: PPUSH
78063: LD_VAR 0 9
78067: PPUSH
78068: CALL 19824 0 3
78072: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78073: LD_ADDR_EXP 69
78077: PUSH
78078: LD_EXP 69
78082: PPUSH
78083: LD_VAR 0 1
78087: PPUSH
78088: LD_EXP 69
78092: PUSH
78093: LD_VAR 0 1
78097: ARRAY
78098: PUSH
78099: LD_VAR 0 9
78103: DIFF
78104: PPUSH
78105: CALL_OW 1
78109: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78110: LD_VAR 0 3
78114: PPUSH
78115: LD_EXP 70
78119: PUSH
78120: LD_VAR 0 1
78124: ARRAY
78125: PUSH
78126: LD_EXP 70
78130: PUSH
78131: LD_VAR 0 1
78135: ARRAY
78136: ARRAY
78137: PPUSH
78138: CALL_OW 120
// end ; exit ;
78142: GO 78463
// end ; if tmp > 1 then
78144: LD_VAR 0 8
78148: PUSH
78149: LD_INT 1
78151: GREATER
78152: IFFALSE 78256
// for i = 2 to tmp do
78154: LD_ADDR_VAR 0 6
78158: PUSH
78159: DOUBLE
78160: LD_INT 2
78162: DEC
78163: ST_TO_ADDR
78164: LD_VAR 0 8
78168: PUSH
78169: FOR_TO
78170: IFFALSE 78254
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78172: LD_VAR 0 8
78176: PUSH
78177: LD_VAR 0 6
78181: ARRAY
78182: PPUSH
78183: CALL_OW 461
78187: PUSH
78188: LD_INT 6
78190: EQUAL
78191: IFFALSE 78252
// begin x := tmp [ i ] ;
78193: LD_ADDR_VAR 0 9
78197: PUSH
78198: LD_VAR 0 8
78202: PUSH
78203: LD_VAR 0 6
78207: ARRAY
78208: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78209: LD_ADDR_VAR 0 8
78213: PUSH
78214: LD_VAR 0 8
78218: PPUSH
78219: LD_VAR 0 6
78223: PPUSH
78224: CALL_OW 3
78228: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78229: LD_ADDR_VAR 0 8
78233: PUSH
78234: LD_VAR 0 8
78238: PPUSH
78239: LD_INT 1
78241: PPUSH
78242: LD_VAR 0 9
78246: PPUSH
78247: CALL_OW 2
78251: ST_TO_ADDR
// end ;
78252: GO 78169
78254: POP
78255: POP
// for i in tmp do
78256: LD_ADDR_VAR 0 6
78260: PUSH
78261: LD_VAR 0 8
78265: PUSH
78266: FOR_IN
78267: IFFALSE 78336
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
78269: LD_VAR 0 6
78273: PPUSH
78274: CALL_OW 313
78278: PUSH
78279: LD_INT 6
78281: LESS
78282: PUSH
78283: LD_VAR 0 6
78287: PPUSH
78288: CALL_OW 266
78292: PUSH
78293: LD_INT 31
78295: PUSH
78296: LD_INT 32
78298: PUSH
78299: EMPTY
78300: LIST
78301: LIST
78302: IN
78303: NOT
78304: AND
78305: PUSH
78306: LD_VAR 0 6
78310: PPUSH
78311: CALL_OW 313
78315: PUSH
78316: LD_INT 0
78318: EQUAL
78319: OR
78320: IFFALSE 78334
// begin j := i ;
78322: LD_ADDR_VAR 0 7
78326: PUSH
78327: LD_VAR 0 6
78331: ST_TO_ADDR
// break ;
78332: GO 78336
// end ; end ;
78334: GO 78266
78336: POP
78337: POP
// if j then
78338: LD_VAR 0 7
78342: IFFALSE 78360
// ComEnterUnit ( unit , j ) else
78344: LD_VAR 0 3
78348: PPUSH
78349: LD_VAR 0 7
78353: PPUSH
78354: CALL_OW 120
78358: GO 78463
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78360: LD_ADDR_VAR 0 10
78364: PUSH
78365: LD_VAR 0 2
78369: PPUSH
78370: LD_INT 2
78372: PUSH
78373: LD_INT 30
78375: PUSH
78376: LD_INT 0
78378: PUSH
78379: EMPTY
78380: LIST
78381: LIST
78382: PUSH
78383: LD_INT 30
78385: PUSH
78386: LD_INT 1
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: LIST
78397: PPUSH
78398: CALL_OW 72
78402: ST_TO_ADDR
// if depot then
78403: LD_VAR 0 10
78407: IFFALSE 78463
// begin depot := NearestUnitToUnit ( depot , unit ) ;
78409: LD_ADDR_VAR 0 10
78413: PUSH
78414: LD_VAR 0 10
78418: PPUSH
78419: LD_VAR 0 3
78423: PPUSH
78424: CALL_OW 74
78428: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
78429: LD_VAR 0 3
78433: PPUSH
78434: LD_VAR 0 10
78438: PPUSH
78439: CALL_OW 296
78443: PUSH
78444: LD_INT 10
78446: GREATER
78447: IFFALSE 78463
// ComStandNearbyBuilding ( unit , depot ) ;
78449: LD_VAR 0 3
78453: PPUSH
78454: LD_VAR 0 10
78458: PPUSH
78459: CALL 16402 0 2
// end ; end ; end ;
78463: LD_VAR 0 5
78467: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
78468: LD_INT 0
78470: PPUSH
78471: PPUSH
78472: PPUSH
78473: PPUSH
// if not mc_bases then
78474: LD_EXP 60
78478: NOT
78479: IFFALSE 78483
// exit ;
78481: GO 78722
// for i = 1 to mc_bases do
78483: LD_ADDR_VAR 0 2
78487: PUSH
78488: DOUBLE
78489: LD_INT 1
78491: DEC
78492: ST_TO_ADDR
78493: LD_EXP 60
78497: PUSH
78498: FOR_TO
78499: IFFALSE 78720
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
78501: LD_ADDR_VAR 0 4
78505: PUSH
78506: LD_EXP 60
78510: PUSH
78511: LD_VAR 0 2
78515: ARRAY
78516: PPUSH
78517: LD_INT 21
78519: PUSH
78520: LD_INT 1
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PPUSH
78527: CALL_OW 72
78531: PUSH
78532: LD_EXP 89
78536: PUSH
78537: LD_VAR 0 2
78541: ARRAY
78542: UNION
78543: ST_TO_ADDR
// if not tmp then
78544: LD_VAR 0 4
78548: NOT
78549: IFFALSE 78553
// continue ;
78551: GO 78498
// for j in tmp do
78553: LD_ADDR_VAR 0 3
78557: PUSH
78558: LD_VAR 0 4
78562: PUSH
78563: FOR_IN
78564: IFFALSE 78716
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78566: LD_VAR 0 3
78570: PPUSH
78571: CALL_OW 110
78575: NOT
78576: PUSH
78577: LD_VAR 0 3
78581: PPUSH
78582: CALL_OW 314
78586: NOT
78587: AND
78588: PUSH
78589: LD_VAR 0 3
78593: PPUSH
78594: CALL_OW 311
78598: NOT
78599: AND
78600: PUSH
78601: LD_VAR 0 3
78605: PPUSH
78606: CALL_OW 310
78610: NOT
78611: AND
78612: PUSH
78613: LD_VAR 0 3
78617: PUSH
78618: LD_EXP 63
78622: PUSH
78623: LD_VAR 0 2
78627: ARRAY
78628: PUSH
78629: LD_INT 1
78631: ARRAY
78632: IN
78633: NOT
78634: AND
78635: PUSH
78636: LD_VAR 0 3
78640: PUSH
78641: LD_EXP 63
78645: PUSH
78646: LD_VAR 0 2
78650: ARRAY
78651: PUSH
78652: LD_INT 2
78654: ARRAY
78655: IN
78656: NOT
78657: AND
78658: PUSH
78659: LD_VAR 0 3
78663: PUSH
78664: LD_EXP 72
78668: PUSH
78669: LD_VAR 0 2
78673: ARRAY
78674: IN
78675: NOT
78676: AND
78677: IFFALSE 78714
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78679: LD_VAR 0 2
78683: PPUSH
78684: LD_EXP 60
78688: PUSH
78689: LD_VAR 0 2
78693: ARRAY
78694: PPUSH
78695: LD_VAR 0 3
78699: PPUSH
78700: LD_VAR 0 3
78704: PPUSH
78705: CALL_OW 257
78709: PPUSH
78710: CALL 77486 0 4
// end ;
78714: GO 78563
78716: POP
78717: POP
// end ;
78718: GO 78498
78720: POP
78721: POP
// end ;
78722: LD_VAR 0 1
78726: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
78727: LD_INT 0
78729: PPUSH
78730: PPUSH
78731: PPUSH
78732: PPUSH
78733: PPUSH
78734: PPUSH
// if not mc_bases [ base ] then
78735: LD_EXP 60
78739: PUSH
78740: LD_VAR 0 1
78744: ARRAY
78745: NOT
78746: IFFALSE 78750
// exit ;
78748: GO 78932
// tmp := [ ] ;
78750: LD_ADDR_VAR 0 6
78754: PUSH
78755: EMPTY
78756: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78757: LD_ADDR_VAR 0 7
78761: PUSH
78762: LD_VAR 0 3
78766: PPUSH
78767: LD_INT 0
78769: PPUSH
78770: CALL_OW 517
78774: ST_TO_ADDR
// if not list then
78775: LD_VAR 0 7
78779: NOT
78780: IFFALSE 78784
// exit ;
78782: GO 78932
// for i = 1 to amount do
78784: LD_ADDR_VAR 0 5
78788: PUSH
78789: DOUBLE
78790: LD_INT 1
78792: DEC
78793: ST_TO_ADDR
78794: LD_VAR 0 2
78798: PUSH
78799: FOR_TO
78800: IFFALSE 78880
// begin x := rand ( 1 , list [ 1 ] ) ;
78802: LD_ADDR_VAR 0 8
78806: PUSH
78807: LD_INT 1
78809: PPUSH
78810: LD_VAR 0 7
78814: PUSH
78815: LD_INT 1
78817: ARRAY
78818: PPUSH
78819: CALL_OW 12
78823: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
78824: LD_ADDR_VAR 0 6
78828: PUSH
78829: LD_VAR 0 6
78833: PPUSH
78834: LD_VAR 0 5
78838: PPUSH
78839: LD_VAR 0 7
78843: PUSH
78844: LD_INT 1
78846: ARRAY
78847: PUSH
78848: LD_VAR 0 8
78852: ARRAY
78853: PUSH
78854: LD_VAR 0 7
78858: PUSH
78859: LD_INT 2
78861: ARRAY
78862: PUSH
78863: LD_VAR 0 8
78867: ARRAY
78868: PUSH
78869: EMPTY
78870: LIST
78871: LIST
78872: PPUSH
78873: CALL_OW 1
78877: ST_TO_ADDR
// end ;
78878: GO 78799
78880: POP
78881: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
78882: LD_ADDR_EXP 73
78886: PUSH
78887: LD_EXP 73
78891: PPUSH
78892: LD_VAR 0 1
78896: PPUSH
78897: LD_VAR 0 6
78901: PPUSH
78902: CALL_OW 1
78906: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
78907: LD_ADDR_EXP 75
78911: PUSH
78912: LD_EXP 75
78916: PPUSH
78917: LD_VAR 0 1
78921: PPUSH
78922: LD_VAR 0 3
78926: PPUSH
78927: CALL_OW 1
78931: ST_TO_ADDR
// end ;
78932: LD_VAR 0 4
78936: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
78937: LD_INT 0
78939: PPUSH
// if not mc_bases [ base ] then
78940: LD_EXP 60
78944: PUSH
78945: LD_VAR 0 1
78949: ARRAY
78950: NOT
78951: IFFALSE 78955
// exit ;
78953: GO 78980
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
78955: LD_ADDR_EXP 65
78959: PUSH
78960: LD_EXP 65
78964: PPUSH
78965: LD_VAR 0 1
78969: PPUSH
78970: LD_VAR 0 2
78974: PPUSH
78975: CALL_OW 1
78979: ST_TO_ADDR
// end ;
78980: LD_VAR 0 3
78984: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
78985: LD_INT 0
78987: PPUSH
// if not mc_bases [ base ] then
78988: LD_EXP 60
78992: PUSH
78993: LD_VAR 0 1
78997: ARRAY
78998: NOT
78999: IFFALSE 79003
// exit ;
79001: GO 79040
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79003: LD_ADDR_EXP 65
79007: PUSH
79008: LD_EXP 65
79012: PPUSH
79013: LD_VAR 0 1
79017: PPUSH
79018: LD_EXP 65
79022: PUSH
79023: LD_VAR 0 1
79027: ARRAY
79028: PUSH
79029: LD_VAR 0 2
79033: UNION
79034: PPUSH
79035: CALL_OW 1
79039: ST_TO_ADDR
// end ;
79040: LD_VAR 0 3
79044: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79045: LD_INT 0
79047: PPUSH
// if not mc_bases [ base ] then
79048: LD_EXP 60
79052: PUSH
79053: LD_VAR 0 1
79057: ARRAY
79058: NOT
79059: IFFALSE 79063
// exit ;
79061: GO 79088
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79063: LD_ADDR_EXP 81
79067: PUSH
79068: LD_EXP 81
79072: PPUSH
79073: LD_VAR 0 1
79077: PPUSH
79078: LD_VAR 0 2
79082: PPUSH
79083: CALL_OW 1
79087: ST_TO_ADDR
// end ;
79088: LD_VAR 0 3
79092: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79093: LD_INT 0
79095: PPUSH
// if not mc_bases [ base ] then
79096: LD_EXP 60
79100: PUSH
79101: LD_VAR 0 1
79105: ARRAY
79106: NOT
79107: IFFALSE 79111
// exit ;
79109: GO 79148
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79111: LD_ADDR_EXP 81
79115: PUSH
79116: LD_EXP 81
79120: PPUSH
79121: LD_VAR 0 1
79125: PPUSH
79126: LD_EXP 81
79130: PUSH
79131: LD_VAR 0 1
79135: ARRAY
79136: PUSH
79137: LD_VAR 0 2
79141: ADD
79142: PPUSH
79143: CALL_OW 1
79147: ST_TO_ADDR
// end ;
79148: LD_VAR 0 3
79152: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79153: LD_INT 0
79155: PPUSH
// if not mc_bases [ base ] then
79156: LD_EXP 60
79160: PUSH
79161: LD_VAR 0 1
79165: ARRAY
79166: NOT
79167: IFFALSE 79171
// exit ;
79169: GO 79225
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79171: LD_ADDR_EXP 82
79175: PUSH
79176: LD_EXP 82
79180: PPUSH
79181: LD_VAR 0 1
79185: PPUSH
79186: LD_VAR 0 2
79190: PPUSH
79191: CALL_OW 1
79195: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79196: LD_ADDR_EXP 71
79200: PUSH
79201: LD_EXP 71
79205: PPUSH
79206: LD_VAR 0 1
79210: PPUSH
79211: LD_VAR 0 2
79215: PUSH
79216: LD_INT 0
79218: PLUS
79219: PPUSH
79220: CALL_OW 1
79224: ST_TO_ADDR
// end ;
79225: LD_VAR 0 3
79229: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79230: LD_INT 0
79232: PPUSH
// if not mc_bases [ base ] then
79233: LD_EXP 60
79237: PUSH
79238: LD_VAR 0 1
79242: ARRAY
79243: NOT
79244: IFFALSE 79248
// exit ;
79246: GO 79273
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79248: LD_ADDR_EXP 71
79252: PUSH
79253: LD_EXP 71
79257: PPUSH
79258: LD_VAR 0 1
79262: PPUSH
79263: LD_VAR 0 2
79267: PPUSH
79268: CALL_OW 1
79272: ST_TO_ADDR
// end ;
79273: LD_VAR 0 3
79277: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79278: LD_INT 0
79280: PPUSH
79281: PPUSH
79282: PPUSH
79283: PPUSH
// if not mc_bases [ base ] then
79284: LD_EXP 60
79288: PUSH
79289: LD_VAR 0 1
79293: ARRAY
79294: NOT
79295: IFFALSE 79299
// exit ;
79297: GO 79364
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79299: LD_ADDR_EXP 80
79303: PUSH
79304: LD_EXP 80
79308: PPUSH
79309: LD_VAR 0 1
79313: PUSH
79314: LD_EXP 80
79318: PUSH
79319: LD_VAR 0 1
79323: ARRAY
79324: PUSH
79325: LD_INT 1
79327: PLUS
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PPUSH
79333: LD_VAR 0 1
79337: PUSH
79338: LD_VAR 0 2
79342: PUSH
79343: LD_VAR 0 3
79347: PUSH
79348: LD_VAR 0 4
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: LIST
79357: LIST
79358: PPUSH
79359: CALL 19824 0 3
79363: ST_TO_ADDR
// end ;
79364: LD_VAR 0 5
79368: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79369: LD_INT 0
79371: PPUSH
// if not mc_bases [ base ] then
79372: LD_EXP 60
79376: PUSH
79377: LD_VAR 0 1
79381: ARRAY
79382: NOT
79383: IFFALSE 79387
// exit ;
79385: GO 79412
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
79387: LD_ADDR_EXP 97
79391: PUSH
79392: LD_EXP 97
79396: PPUSH
79397: LD_VAR 0 1
79401: PPUSH
79402: LD_VAR 0 2
79406: PPUSH
79407: CALL_OW 1
79411: ST_TO_ADDR
// end ;
79412: LD_VAR 0 3
79416: RET
// export function MC_GetMinesField ( base ) ; begin
79417: LD_INT 0
79419: PPUSH
// result := mc_mines [ base ] ;
79420: LD_ADDR_VAR 0 2
79424: PUSH
79425: LD_EXP 73
79429: PUSH
79430: LD_VAR 0 1
79434: ARRAY
79435: ST_TO_ADDR
// end ;
79436: LD_VAR 0 2
79440: RET
// export function MC_GetProduceList ( base ) ; begin
79441: LD_INT 0
79443: PPUSH
// result := mc_produce [ base ] ;
79444: LD_ADDR_VAR 0 2
79448: PUSH
79449: LD_EXP 81
79453: PUSH
79454: LD_VAR 0 1
79458: ARRAY
79459: ST_TO_ADDR
// end ;
79460: LD_VAR 0 2
79464: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
79465: LD_INT 0
79467: PPUSH
79468: PPUSH
// if not mc_bases then
79469: LD_EXP 60
79473: NOT
79474: IFFALSE 79478
// exit ;
79476: GO 79543
// if mc_bases [ base ] then
79478: LD_EXP 60
79482: PUSH
79483: LD_VAR 0 1
79487: ARRAY
79488: IFFALSE 79543
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79490: LD_ADDR_VAR 0 3
79494: PUSH
79495: LD_EXP 60
79499: PUSH
79500: LD_VAR 0 1
79504: ARRAY
79505: PPUSH
79506: LD_INT 30
79508: PUSH
79509: LD_VAR 0 2
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PPUSH
79518: CALL_OW 72
79522: ST_TO_ADDR
// if result then
79523: LD_VAR 0 3
79527: IFFALSE 79543
// result := result [ 1 ] ;
79529: LD_ADDR_VAR 0 3
79533: PUSH
79534: LD_VAR 0 3
79538: PUSH
79539: LD_INT 1
79541: ARRAY
79542: ST_TO_ADDR
// end ; end ;
79543: LD_VAR 0 3
79547: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
79548: LD_INT 0
79550: PPUSH
79551: PPUSH
// if not mc_bases then
79552: LD_EXP 60
79556: NOT
79557: IFFALSE 79561
// exit ;
79559: GO 79606
// if mc_bases [ base ] then
79561: LD_EXP 60
79565: PUSH
79566: LD_VAR 0 1
79570: ARRAY
79571: IFFALSE 79606
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79573: LD_ADDR_VAR 0 3
79577: PUSH
79578: LD_EXP 60
79582: PUSH
79583: LD_VAR 0 1
79587: ARRAY
79588: PPUSH
79589: LD_INT 30
79591: PUSH
79592: LD_VAR 0 2
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: PPUSH
79601: CALL_OW 72
79605: ST_TO_ADDR
// end ;
79606: LD_VAR 0 3
79610: RET
// export function MC_SetTame ( base , area ) ; begin
79611: LD_INT 0
79613: PPUSH
// if not mc_bases or not base then
79614: LD_EXP 60
79618: NOT
79619: PUSH
79620: LD_VAR 0 1
79624: NOT
79625: OR
79626: IFFALSE 79630
// exit ;
79628: GO 79655
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79630: LD_ADDR_EXP 88
79634: PUSH
79635: LD_EXP 88
79639: PPUSH
79640: LD_VAR 0 1
79644: PPUSH
79645: LD_VAR 0 2
79649: PPUSH
79650: CALL_OW 1
79654: ST_TO_ADDR
// end ;
79655: LD_VAR 0 3
79659: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
79660: LD_INT 0
79662: PPUSH
79663: PPUSH
// if not mc_bases or not base then
79664: LD_EXP 60
79668: NOT
79669: PUSH
79670: LD_VAR 0 1
79674: NOT
79675: OR
79676: IFFALSE 79680
// exit ;
79678: GO 79782
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79680: LD_ADDR_VAR 0 4
79684: PUSH
79685: LD_EXP 60
79689: PUSH
79690: LD_VAR 0 1
79694: ARRAY
79695: PPUSH
79696: LD_INT 30
79698: PUSH
79699: LD_VAR 0 2
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PPUSH
79708: CALL_OW 72
79712: ST_TO_ADDR
// if not tmp then
79713: LD_VAR 0 4
79717: NOT
79718: IFFALSE 79722
// exit ;
79720: GO 79782
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79722: LD_ADDR_EXP 92
79726: PUSH
79727: LD_EXP 92
79731: PPUSH
79732: LD_VAR 0 1
79736: PPUSH
79737: LD_EXP 92
79741: PUSH
79742: LD_VAR 0 1
79746: ARRAY
79747: PPUSH
79748: LD_EXP 92
79752: PUSH
79753: LD_VAR 0 1
79757: ARRAY
79758: PUSH
79759: LD_INT 1
79761: PLUS
79762: PPUSH
79763: LD_VAR 0 4
79767: PUSH
79768: LD_INT 1
79770: ARRAY
79771: PPUSH
79772: CALL_OW 2
79776: PPUSH
79777: CALL_OW 1
79781: ST_TO_ADDR
// end ;
79782: LD_VAR 0 3
79786: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
79787: LD_INT 0
79789: PPUSH
79790: PPUSH
// if not mc_bases or not base or not kinds then
79791: LD_EXP 60
79795: NOT
79796: PUSH
79797: LD_VAR 0 1
79801: NOT
79802: OR
79803: PUSH
79804: LD_VAR 0 2
79808: NOT
79809: OR
79810: IFFALSE 79814
// exit ;
79812: GO 79875
// for i in kinds do
79814: LD_ADDR_VAR 0 4
79818: PUSH
79819: LD_VAR 0 2
79823: PUSH
79824: FOR_IN
79825: IFFALSE 79873
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
79827: LD_ADDR_EXP 94
79831: PUSH
79832: LD_EXP 94
79836: PPUSH
79837: LD_VAR 0 1
79841: PUSH
79842: LD_EXP 94
79846: PUSH
79847: LD_VAR 0 1
79851: ARRAY
79852: PUSH
79853: LD_INT 1
79855: PLUS
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PPUSH
79861: LD_VAR 0 4
79865: PPUSH
79866: CALL 19824 0 3
79870: ST_TO_ADDR
79871: GO 79824
79873: POP
79874: POP
// end ;
79875: LD_VAR 0 3
79879: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
79880: LD_INT 0
79882: PPUSH
// if not mc_bases or not base or not areas then
79883: LD_EXP 60
79887: NOT
79888: PUSH
79889: LD_VAR 0 1
79893: NOT
79894: OR
79895: PUSH
79896: LD_VAR 0 2
79900: NOT
79901: OR
79902: IFFALSE 79906
// exit ;
79904: GO 79931
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
79906: LD_ADDR_EXP 78
79910: PUSH
79911: LD_EXP 78
79915: PPUSH
79916: LD_VAR 0 1
79920: PPUSH
79921: LD_VAR 0 2
79925: PPUSH
79926: CALL_OW 1
79930: ST_TO_ADDR
// end ;
79931: LD_VAR 0 3
79935: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
79936: LD_INT 0
79938: PPUSH
// if not mc_bases or not base or not teleports_exit then
79939: LD_EXP 60
79943: NOT
79944: PUSH
79945: LD_VAR 0 1
79949: NOT
79950: OR
79951: PUSH
79952: LD_VAR 0 2
79956: NOT
79957: OR
79958: IFFALSE 79962
// exit ;
79960: GO 79987
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
79962: LD_ADDR_EXP 95
79966: PUSH
79967: LD_EXP 95
79971: PPUSH
79972: LD_VAR 0 1
79976: PPUSH
79977: LD_VAR 0 2
79981: PPUSH
79982: CALL_OW 1
79986: ST_TO_ADDR
// end ;
79987: LD_VAR 0 3
79991: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
79992: LD_INT 0
79994: PPUSH
79995: PPUSH
79996: PPUSH
// if not mc_bases or not base or not ext_list then
79997: LD_EXP 60
80001: NOT
80002: PUSH
80003: LD_VAR 0 1
80007: NOT
80008: OR
80009: PUSH
80010: LD_VAR 0 5
80014: NOT
80015: OR
80016: IFFALSE 80020
// exit ;
80018: GO 80193
// tmp := GetFacExtXYD ( x , y , d ) ;
80020: LD_ADDR_VAR 0 8
80024: PUSH
80025: LD_VAR 0 2
80029: PPUSH
80030: LD_VAR 0 3
80034: PPUSH
80035: LD_VAR 0 4
80039: PPUSH
80040: CALL 49158 0 3
80044: ST_TO_ADDR
// if not tmp then
80045: LD_VAR 0 8
80049: NOT
80050: IFFALSE 80054
// exit ;
80052: GO 80193
// for i in tmp do
80054: LD_ADDR_VAR 0 7
80058: PUSH
80059: LD_VAR 0 8
80063: PUSH
80064: FOR_IN
80065: IFFALSE 80191
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80067: LD_ADDR_EXP 65
80071: PUSH
80072: LD_EXP 65
80076: PPUSH
80077: LD_VAR 0 1
80081: PPUSH
80082: LD_EXP 65
80086: PUSH
80087: LD_VAR 0 1
80091: ARRAY
80092: PPUSH
80093: LD_EXP 65
80097: PUSH
80098: LD_VAR 0 1
80102: ARRAY
80103: PUSH
80104: LD_INT 1
80106: PLUS
80107: PPUSH
80108: LD_VAR 0 5
80112: PUSH
80113: LD_INT 1
80115: ARRAY
80116: PUSH
80117: LD_VAR 0 7
80121: PUSH
80122: LD_INT 1
80124: ARRAY
80125: PUSH
80126: LD_VAR 0 7
80130: PUSH
80131: LD_INT 2
80133: ARRAY
80134: PUSH
80135: LD_VAR 0 7
80139: PUSH
80140: LD_INT 3
80142: ARRAY
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: LIST
80148: LIST
80149: PPUSH
80150: CALL_OW 2
80154: PPUSH
80155: CALL_OW 1
80159: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80160: LD_ADDR_VAR 0 5
80164: PUSH
80165: LD_VAR 0 5
80169: PPUSH
80170: LD_INT 1
80172: PPUSH
80173: CALL_OW 3
80177: ST_TO_ADDR
// if not ext_list then
80178: LD_VAR 0 5
80182: NOT
80183: IFFALSE 80189
// exit ;
80185: POP
80186: POP
80187: GO 80193
// end ;
80189: GO 80064
80191: POP
80192: POP
// end ;
80193: LD_VAR 0 6
80197: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80198: LD_INT 0
80200: PPUSH
// if not mc_bases or not base or not weapon_list then
80201: LD_EXP 60
80205: NOT
80206: PUSH
80207: LD_VAR 0 1
80211: NOT
80212: OR
80213: PUSH
80214: LD_VAR 0 2
80218: NOT
80219: OR
80220: IFFALSE 80224
// exit ;
80222: GO 80249
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80224: LD_ADDR_EXP 99
80228: PUSH
80229: LD_EXP 99
80233: PPUSH
80234: LD_VAR 0 1
80238: PPUSH
80239: LD_VAR 0 2
80243: PPUSH
80244: CALL_OW 1
80248: ST_TO_ADDR
// end ;
80249: LD_VAR 0 3
80253: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80254: LD_INT 0
80256: PPUSH
// if not mc_bases or not base or not tech_list then
80257: LD_EXP 60
80261: NOT
80262: PUSH
80263: LD_VAR 0 1
80267: NOT
80268: OR
80269: PUSH
80270: LD_VAR 0 2
80274: NOT
80275: OR
80276: IFFALSE 80280
// exit ;
80278: GO 80305
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80280: LD_ADDR_EXP 87
80284: PUSH
80285: LD_EXP 87
80289: PPUSH
80290: LD_VAR 0 1
80294: PPUSH
80295: LD_VAR 0 2
80299: PPUSH
80300: CALL_OW 1
80304: ST_TO_ADDR
// end ;
80305: LD_VAR 0 3
80309: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80310: LD_INT 0
80312: PPUSH
// if not mc_bases or not parking_area or not base then
80313: LD_EXP 60
80317: NOT
80318: PUSH
80319: LD_VAR 0 2
80323: NOT
80324: OR
80325: PUSH
80326: LD_VAR 0 1
80330: NOT
80331: OR
80332: IFFALSE 80336
// exit ;
80334: GO 80361
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80336: LD_ADDR_EXP 84
80340: PUSH
80341: LD_EXP 84
80345: PPUSH
80346: LD_VAR 0 1
80350: PPUSH
80351: LD_VAR 0 2
80355: PPUSH
80356: CALL_OW 1
80360: ST_TO_ADDR
// end ;
80361: LD_VAR 0 3
80365: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80366: LD_INT 0
80368: PPUSH
// if not mc_bases or not base or not scan_area then
80369: LD_EXP 60
80373: NOT
80374: PUSH
80375: LD_VAR 0 1
80379: NOT
80380: OR
80381: PUSH
80382: LD_VAR 0 2
80386: NOT
80387: OR
80388: IFFALSE 80392
// exit ;
80390: GO 80417
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
80392: LD_ADDR_EXP 85
80396: PUSH
80397: LD_EXP 85
80401: PPUSH
80402: LD_VAR 0 1
80406: PPUSH
80407: LD_VAR 0 2
80411: PPUSH
80412: CALL_OW 1
80416: ST_TO_ADDR
// end ;
80417: LD_VAR 0 3
80421: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
80422: LD_INT 0
80424: PPUSH
80425: PPUSH
// if not mc_bases or not base then
80426: LD_EXP 60
80430: NOT
80431: PUSH
80432: LD_VAR 0 1
80436: NOT
80437: OR
80438: IFFALSE 80442
// exit ;
80440: GO 80506
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
80442: LD_ADDR_VAR 0 3
80446: PUSH
80447: LD_INT 1
80449: PUSH
80450: LD_INT 2
80452: PUSH
80453: LD_INT 3
80455: PUSH
80456: LD_INT 4
80458: PUSH
80459: LD_INT 11
80461: PUSH
80462: EMPTY
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
80469: LD_ADDR_EXP 87
80473: PUSH
80474: LD_EXP 87
80478: PPUSH
80479: LD_VAR 0 1
80483: PPUSH
80484: LD_EXP 87
80488: PUSH
80489: LD_VAR 0 1
80493: ARRAY
80494: PUSH
80495: LD_VAR 0 3
80499: DIFF
80500: PPUSH
80501: CALL_OW 1
80505: ST_TO_ADDR
// end ;
80506: LD_VAR 0 2
80510: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
80511: LD_INT 0
80513: PPUSH
// result := mc_vehicles [ base ] ;
80514: LD_ADDR_VAR 0 3
80518: PUSH
80519: LD_EXP 79
80523: PUSH
80524: LD_VAR 0 1
80528: ARRAY
80529: ST_TO_ADDR
// if onlyCombat then
80530: LD_VAR 0 2
80534: IFFALSE 80712
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
80536: LD_ADDR_VAR 0 3
80540: PUSH
80541: LD_VAR 0 3
80545: PUSH
80546: LD_VAR 0 3
80550: PPUSH
80551: LD_INT 2
80553: PUSH
80554: LD_INT 34
80556: PUSH
80557: LD_INT 12
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 34
80566: PUSH
80567: LD_INT 51
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: LD_INT 34
80576: PUSH
80577: LD_EXP 105
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: PUSH
80586: LD_INT 34
80588: PUSH
80589: LD_INT 32
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 34
80598: PUSH
80599: LD_INT 13
80601: PUSH
80602: EMPTY
80603: LIST
80604: LIST
80605: PUSH
80606: LD_INT 34
80608: PUSH
80609: LD_INT 52
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: PUSH
80616: LD_INT 34
80618: PUSH
80619: LD_EXP 110
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 34
80630: PUSH
80631: LD_INT 14
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 34
80640: PUSH
80641: LD_INT 53
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 34
80650: PUSH
80651: LD_EXP 104
80655: PUSH
80656: EMPTY
80657: LIST
80658: LIST
80659: PUSH
80660: LD_INT 34
80662: PUSH
80663: LD_INT 31
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: PUSH
80670: LD_INT 34
80672: PUSH
80673: LD_INT 48
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 34
80682: PUSH
80683: LD_INT 8
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: LIST
80694: LIST
80695: LIST
80696: LIST
80697: LIST
80698: LIST
80699: LIST
80700: LIST
80701: LIST
80702: LIST
80703: LIST
80704: LIST
80705: PPUSH
80706: CALL_OW 72
80710: DIFF
80711: ST_TO_ADDR
// end ; end_of_file
80712: LD_VAR 0 3
80716: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80717: LD_INT 0
80719: PPUSH
80720: PPUSH
80721: PPUSH
// if not mc_bases or not skirmish then
80722: LD_EXP 60
80726: NOT
80727: PUSH
80728: LD_EXP 58
80732: NOT
80733: OR
80734: IFFALSE 80738
// exit ;
80736: GO 80903
// for i = 1 to mc_bases do
80738: LD_ADDR_VAR 0 4
80742: PUSH
80743: DOUBLE
80744: LD_INT 1
80746: DEC
80747: ST_TO_ADDR
80748: LD_EXP 60
80752: PUSH
80753: FOR_TO
80754: IFFALSE 80901
// begin if sci in mc_bases [ i ] then
80756: LD_VAR 0 2
80760: PUSH
80761: LD_EXP 60
80765: PUSH
80766: LD_VAR 0 4
80770: ARRAY
80771: IN
80772: IFFALSE 80899
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80774: LD_ADDR_EXP 89
80778: PUSH
80779: LD_EXP 89
80783: PPUSH
80784: LD_VAR 0 4
80788: PUSH
80789: LD_EXP 89
80793: PUSH
80794: LD_VAR 0 4
80798: ARRAY
80799: PUSH
80800: LD_INT 1
80802: PLUS
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PPUSH
80808: LD_VAR 0 1
80812: PPUSH
80813: CALL 19824 0 3
80817: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
80818: LD_ADDR_VAR 0 5
80822: PUSH
80823: LD_EXP 60
80827: PUSH
80828: LD_VAR 0 4
80832: ARRAY
80833: PPUSH
80834: LD_INT 2
80836: PUSH
80837: LD_INT 30
80839: PUSH
80840: LD_INT 0
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 30
80849: PUSH
80850: LD_INT 1
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: EMPTY
80858: LIST
80859: LIST
80860: LIST
80861: PPUSH
80862: CALL_OW 72
80866: PPUSH
80867: LD_VAR 0 1
80871: PPUSH
80872: CALL_OW 74
80876: ST_TO_ADDR
// if tmp then
80877: LD_VAR 0 5
80881: IFFALSE 80897
// ComStandNearbyBuilding ( ape , tmp ) ;
80883: LD_VAR 0 1
80887: PPUSH
80888: LD_VAR 0 5
80892: PPUSH
80893: CALL 16402 0 2
// break ;
80897: GO 80901
// end ; end ;
80899: GO 80753
80901: POP
80902: POP
// end ;
80903: LD_VAR 0 3
80907: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
80908: LD_INT 0
80910: PPUSH
80911: PPUSH
80912: PPUSH
// if not mc_bases or not skirmish then
80913: LD_EXP 60
80917: NOT
80918: PUSH
80919: LD_EXP 58
80923: NOT
80924: OR
80925: IFFALSE 80929
// exit ;
80927: GO 81018
// for i = 1 to mc_bases do
80929: LD_ADDR_VAR 0 4
80933: PUSH
80934: DOUBLE
80935: LD_INT 1
80937: DEC
80938: ST_TO_ADDR
80939: LD_EXP 60
80943: PUSH
80944: FOR_TO
80945: IFFALSE 81016
// begin if building in mc_busy_turret_list [ i ] then
80947: LD_VAR 0 1
80951: PUSH
80952: LD_EXP 70
80956: PUSH
80957: LD_VAR 0 4
80961: ARRAY
80962: IN
80963: IFFALSE 81014
// begin tmp := mc_busy_turret_list [ i ] diff building ;
80965: LD_ADDR_VAR 0 5
80969: PUSH
80970: LD_EXP 70
80974: PUSH
80975: LD_VAR 0 4
80979: ARRAY
80980: PUSH
80981: LD_VAR 0 1
80985: DIFF
80986: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
80987: LD_ADDR_EXP 70
80991: PUSH
80992: LD_EXP 70
80996: PPUSH
80997: LD_VAR 0 4
81001: PPUSH
81002: LD_VAR 0 5
81006: PPUSH
81007: CALL_OW 1
81011: ST_TO_ADDR
// break ;
81012: GO 81016
// end ; end ;
81014: GO 80944
81016: POP
81017: POP
// end ;
81018: LD_VAR 0 3
81022: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81023: LD_INT 0
81025: PPUSH
81026: PPUSH
81027: PPUSH
// if not mc_bases or not skirmish then
81028: LD_EXP 60
81032: NOT
81033: PUSH
81034: LD_EXP 58
81038: NOT
81039: OR
81040: IFFALSE 81044
// exit ;
81042: GO 81243
// for i = 1 to mc_bases do
81044: LD_ADDR_VAR 0 5
81048: PUSH
81049: DOUBLE
81050: LD_INT 1
81052: DEC
81053: ST_TO_ADDR
81054: LD_EXP 60
81058: PUSH
81059: FOR_TO
81060: IFFALSE 81241
// if building in mc_bases [ i ] then
81062: LD_VAR 0 1
81066: PUSH
81067: LD_EXP 60
81071: PUSH
81072: LD_VAR 0 5
81076: ARRAY
81077: IN
81078: IFFALSE 81239
// begin tmp := mc_bases [ i ] diff building ;
81080: LD_ADDR_VAR 0 6
81084: PUSH
81085: LD_EXP 60
81089: PUSH
81090: LD_VAR 0 5
81094: ARRAY
81095: PUSH
81096: LD_VAR 0 1
81100: DIFF
81101: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81102: LD_ADDR_EXP 60
81106: PUSH
81107: LD_EXP 60
81111: PPUSH
81112: LD_VAR 0 5
81116: PPUSH
81117: LD_VAR 0 6
81121: PPUSH
81122: CALL_OW 1
81126: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81127: LD_VAR 0 1
81131: PUSH
81132: LD_EXP 68
81136: PUSH
81137: LD_VAR 0 5
81141: ARRAY
81142: IN
81143: IFFALSE 81182
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81145: LD_ADDR_EXP 68
81149: PUSH
81150: LD_EXP 68
81154: PPUSH
81155: LD_VAR 0 5
81159: PPUSH
81160: LD_EXP 68
81164: PUSH
81165: LD_VAR 0 5
81169: ARRAY
81170: PUSH
81171: LD_VAR 0 1
81175: DIFF
81176: PPUSH
81177: CALL_OW 1
81181: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81182: LD_VAR 0 1
81186: PUSH
81187: LD_EXP 69
81191: PUSH
81192: LD_VAR 0 5
81196: ARRAY
81197: IN
81198: IFFALSE 81237
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81200: LD_ADDR_EXP 69
81204: PUSH
81205: LD_EXP 69
81209: PPUSH
81210: LD_VAR 0 5
81214: PPUSH
81215: LD_EXP 69
81219: PUSH
81220: LD_VAR 0 5
81224: ARRAY
81225: PUSH
81226: LD_VAR 0 1
81230: DIFF
81231: PPUSH
81232: CALL_OW 1
81236: ST_TO_ADDR
// break ;
81237: GO 81241
// end ;
81239: GO 81059
81241: POP
81242: POP
// end ;
81243: LD_VAR 0 4
81247: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81248: LD_INT 0
81250: PPUSH
81251: PPUSH
81252: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81253: LD_EXP 60
81257: NOT
81258: PUSH
81259: LD_EXP 58
81263: NOT
81264: OR
81265: PUSH
81266: LD_VAR 0 3
81270: PUSH
81271: LD_EXP 86
81275: IN
81276: NOT
81277: OR
81278: IFFALSE 81282
// exit ;
81280: GO 81405
// for i = 1 to mc_vehicles do
81282: LD_ADDR_VAR 0 6
81286: PUSH
81287: DOUBLE
81288: LD_INT 1
81290: DEC
81291: ST_TO_ADDR
81292: LD_EXP 79
81296: PUSH
81297: FOR_TO
81298: IFFALSE 81403
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81300: LD_VAR 0 2
81304: PUSH
81305: LD_EXP 79
81309: PUSH
81310: LD_VAR 0 6
81314: ARRAY
81315: IN
81316: PUSH
81317: LD_VAR 0 1
81321: PUSH
81322: LD_EXP 79
81326: PUSH
81327: LD_VAR 0 6
81331: ARRAY
81332: IN
81333: OR
81334: IFFALSE 81401
// begin tmp := mc_vehicles [ i ] diff old ;
81336: LD_ADDR_VAR 0 7
81340: PUSH
81341: LD_EXP 79
81345: PUSH
81346: LD_VAR 0 6
81350: ARRAY
81351: PUSH
81352: LD_VAR 0 2
81356: DIFF
81357: ST_TO_ADDR
// tmp := tmp diff new ;
81358: LD_ADDR_VAR 0 7
81362: PUSH
81363: LD_VAR 0 7
81367: PUSH
81368: LD_VAR 0 1
81372: DIFF
81373: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81374: LD_ADDR_EXP 79
81378: PUSH
81379: LD_EXP 79
81383: PPUSH
81384: LD_VAR 0 6
81388: PPUSH
81389: LD_VAR 0 7
81393: PPUSH
81394: CALL_OW 1
81398: ST_TO_ADDR
// break ;
81399: GO 81403
// end ;
81401: GO 81297
81403: POP
81404: POP
// end ;
81405: LD_VAR 0 5
81409: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
81410: LD_INT 0
81412: PPUSH
81413: PPUSH
81414: PPUSH
81415: PPUSH
// if not mc_bases or not skirmish then
81416: LD_EXP 60
81420: NOT
81421: PUSH
81422: LD_EXP 58
81426: NOT
81427: OR
81428: IFFALSE 81432
// exit ;
81430: GO 81824
// side := GetSide ( vehicle ) ;
81432: LD_ADDR_VAR 0 5
81436: PUSH
81437: LD_VAR 0 1
81441: PPUSH
81442: CALL_OW 255
81446: ST_TO_ADDR
// for i = 1 to mc_bases do
81447: LD_ADDR_VAR 0 4
81451: PUSH
81452: DOUBLE
81453: LD_INT 1
81455: DEC
81456: ST_TO_ADDR
81457: LD_EXP 60
81461: PUSH
81462: FOR_TO
81463: IFFALSE 81822
// begin if factory in mc_bases [ i ] then
81465: LD_VAR 0 2
81469: PUSH
81470: LD_EXP 60
81474: PUSH
81475: LD_VAR 0 4
81479: ARRAY
81480: IN
81481: IFFALSE 81820
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
81483: LD_EXP 82
81487: PUSH
81488: LD_VAR 0 4
81492: ARRAY
81493: PUSH
81494: LD_EXP 71
81498: PUSH
81499: LD_VAR 0 4
81503: ARRAY
81504: LESS
81505: PUSH
81506: LD_VAR 0 1
81510: PPUSH
81511: CALL_OW 264
81515: PUSH
81516: LD_INT 31
81518: PUSH
81519: LD_INT 32
81521: PUSH
81522: LD_INT 51
81524: PUSH
81525: LD_EXP 105
81529: PUSH
81530: LD_INT 12
81532: PUSH
81533: LD_INT 30
81535: PUSH
81536: LD_EXP 104
81540: PUSH
81541: LD_INT 11
81543: PUSH
81544: LD_INT 53
81546: PUSH
81547: LD_INT 14
81549: PUSH
81550: LD_EXP 108
81554: PUSH
81555: LD_INT 29
81557: PUSH
81558: LD_EXP 106
81562: PUSH
81563: LD_INT 13
81565: PUSH
81566: LD_INT 52
81568: PUSH
81569: LD_EXP 110
81573: PUSH
81574: LD_INT 48
81576: PUSH
81577: LD_INT 8
81579: PUSH
81580: EMPTY
81581: LIST
81582: LIST
81583: LIST
81584: LIST
81585: LIST
81586: LIST
81587: LIST
81588: LIST
81589: LIST
81590: LIST
81591: LIST
81592: LIST
81593: LIST
81594: LIST
81595: LIST
81596: LIST
81597: LIST
81598: LIST
81599: IN
81600: NOT
81601: AND
81602: IFFALSE 81650
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
81604: LD_ADDR_EXP 82
81608: PUSH
81609: LD_EXP 82
81613: PPUSH
81614: LD_VAR 0 4
81618: PUSH
81619: LD_EXP 82
81623: PUSH
81624: LD_VAR 0 4
81628: ARRAY
81629: PUSH
81630: LD_INT 1
81632: PLUS
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: PPUSH
81638: LD_VAR 0 1
81642: PPUSH
81643: CALL 19824 0 3
81647: ST_TO_ADDR
81648: GO 81694
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81650: LD_ADDR_EXP 79
81654: PUSH
81655: LD_EXP 79
81659: PPUSH
81660: LD_VAR 0 4
81664: PUSH
81665: LD_EXP 79
81669: PUSH
81670: LD_VAR 0 4
81674: ARRAY
81675: PUSH
81676: LD_INT 1
81678: PLUS
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: PPUSH
81684: LD_VAR 0 1
81688: PPUSH
81689: CALL 19824 0 3
81693: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
81694: LD_VAR 0 1
81698: PPUSH
81699: CALL_OW 263
81703: PUSH
81704: LD_INT 2
81706: EQUAL
81707: IFFALSE 81736
// begin repeat wait ( 0 0$3 ) ;
81709: LD_INT 105
81711: PPUSH
81712: CALL_OW 67
// Connect ( vehicle ) ;
81716: LD_VAR 0 1
81720: PPUSH
81721: CALL 22795 0 1
// until IsControledBy ( vehicle ) ;
81725: LD_VAR 0 1
81729: PPUSH
81730: CALL_OW 312
81734: IFFALSE 81709
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81736: LD_VAR 0 1
81740: PPUSH
81741: LD_EXP 84
81745: PUSH
81746: LD_VAR 0 4
81750: ARRAY
81751: PPUSH
81752: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81756: LD_VAR 0 1
81760: PPUSH
81761: CALL_OW 263
81765: PUSH
81766: LD_INT 1
81768: NONEQUAL
81769: IFFALSE 81773
// break ;
81771: GO 81822
// repeat wait ( 0 0$1 ) ;
81773: LD_INT 35
81775: PPUSH
81776: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81780: LD_VAR 0 1
81784: PPUSH
81785: LD_EXP 84
81789: PUSH
81790: LD_VAR 0 4
81794: ARRAY
81795: PPUSH
81796: CALL_OW 308
81800: IFFALSE 81773
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
81802: LD_VAR 0 1
81806: PPUSH
81807: CALL_OW 311
81811: PPUSH
81812: CALL_OW 121
// exit ;
81816: POP
81817: POP
81818: GO 81824
// end ; end ;
81820: GO 81462
81822: POP
81823: POP
// end ;
81824: LD_VAR 0 3
81828: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
81829: LD_INT 0
81831: PPUSH
81832: PPUSH
81833: PPUSH
81834: PPUSH
// if not mc_bases or not skirmish then
81835: LD_EXP 60
81839: NOT
81840: PUSH
81841: LD_EXP 58
81845: NOT
81846: OR
81847: IFFALSE 81851
// exit ;
81849: GO 82204
// repeat wait ( 0 0$1 ) ;
81851: LD_INT 35
81853: PPUSH
81854: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
81858: LD_VAR 0 2
81862: PPUSH
81863: LD_VAR 0 3
81867: PPUSH
81868: CALL_OW 284
81872: IFFALSE 81851
// if GetResourceTypeXY ( x , y ) = mat_artefact then
81874: LD_VAR 0 2
81878: PPUSH
81879: LD_VAR 0 3
81883: PPUSH
81884: CALL_OW 283
81888: PUSH
81889: LD_INT 4
81891: EQUAL
81892: IFFALSE 81896
// exit ;
81894: GO 82204
// for i = 1 to mc_bases do
81896: LD_ADDR_VAR 0 7
81900: PUSH
81901: DOUBLE
81902: LD_INT 1
81904: DEC
81905: ST_TO_ADDR
81906: LD_EXP 60
81910: PUSH
81911: FOR_TO
81912: IFFALSE 82202
// begin if mc_crates_area [ i ] then
81914: LD_EXP 78
81918: PUSH
81919: LD_VAR 0 7
81923: ARRAY
81924: IFFALSE 82035
// for j in mc_crates_area [ i ] do
81926: LD_ADDR_VAR 0 8
81930: PUSH
81931: LD_EXP 78
81935: PUSH
81936: LD_VAR 0 7
81940: ARRAY
81941: PUSH
81942: FOR_IN
81943: IFFALSE 82033
// if InArea ( x , y , j ) then
81945: LD_VAR 0 2
81949: PPUSH
81950: LD_VAR 0 3
81954: PPUSH
81955: LD_VAR 0 8
81959: PPUSH
81960: CALL_OW 309
81964: IFFALSE 82031
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81966: LD_ADDR_EXP 76
81970: PUSH
81971: LD_EXP 76
81975: PPUSH
81976: LD_VAR 0 7
81980: PUSH
81981: LD_EXP 76
81985: PUSH
81986: LD_VAR 0 7
81990: ARRAY
81991: PUSH
81992: LD_INT 1
81994: PLUS
81995: PUSH
81996: EMPTY
81997: LIST
81998: LIST
81999: PPUSH
82000: LD_VAR 0 4
82004: PUSH
82005: LD_VAR 0 2
82009: PUSH
82010: LD_VAR 0 3
82014: PUSH
82015: EMPTY
82016: LIST
82017: LIST
82018: LIST
82019: PPUSH
82020: CALL 19824 0 3
82024: ST_TO_ADDR
// exit ;
82025: POP
82026: POP
82027: POP
82028: POP
82029: GO 82204
// end ;
82031: GO 81942
82033: POP
82034: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82035: LD_ADDR_VAR 0 9
82039: PUSH
82040: LD_EXP 60
82044: PUSH
82045: LD_VAR 0 7
82049: ARRAY
82050: PPUSH
82051: LD_INT 2
82053: PUSH
82054: LD_INT 30
82056: PUSH
82057: LD_INT 0
82059: PUSH
82060: EMPTY
82061: LIST
82062: LIST
82063: PUSH
82064: LD_INT 30
82066: PUSH
82067: LD_INT 1
82069: PUSH
82070: EMPTY
82071: LIST
82072: LIST
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: LIST
82078: PPUSH
82079: CALL_OW 72
82083: ST_TO_ADDR
// if not depot then
82084: LD_VAR 0 9
82088: NOT
82089: IFFALSE 82093
// continue ;
82091: GO 81911
// for j in depot do
82093: LD_ADDR_VAR 0 8
82097: PUSH
82098: LD_VAR 0 9
82102: PUSH
82103: FOR_IN
82104: IFFALSE 82198
// if GetDistUnitXY ( j , x , y ) < 30 then
82106: LD_VAR 0 8
82110: PPUSH
82111: LD_VAR 0 2
82115: PPUSH
82116: LD_VAR 0 3
82120: PPUSH
82121: CALL_OW 297
82125: PUSH
82126: LD_INT 30
82128: LESS
82129: IFFALSE 82196
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82131: LD_ADDR_EXP 76
82135: PUSH
82136: LD_EXP 76
82140: PPUSH
82141: LD_VAR 0 7
82145: PUSH
82146: LD_EXP 76
82150: PUSH
82151: LD_VAR 0 7
82155: ARRAY
82156: PUSH
82157: LD_INT 1
82159: PLUS
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PPUSH
82165: LD_VAR 0 4
82169: PUSH
82170: LD_VAR 0 2
82174: PUSH
82175: LD_VAR 0 3
82179: PUSH
82180: EMPTY
82181: LIST
82182: LIST
82183: LIST
82184: PPUSH
82185: CALL 19824 0 3
82189: ST_TO_ADDR
// exit ;
82190: POP
82191: POP
82192: POP
82193: POP
82194: GO 82204
// end ;
82196: GO 82103
82198: POP
82199: POP
// end ;
82200: GO 81911
82202: POP
82203: POP
// end ;
82204: LD_VAR 0 6
82208: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82209: LD_INT 0
82211: PPUSH
82212: PPUSH
82213: PPUSH
82214: PPUSH
// if not mc_bases or not skirmish then
82215: LD_EXP 60
82219: NOT
82220: PUSH
82221: LD_EXP 58
82225: NOT
82226: OR
82227: IFFALSE 82231
// exit ;
82229: GO 82508
// side := GetSide ( lab ) ;
82231: LD_ADDR_VAR 0 4
82235: PUSH
82236: LD_VAR 0 2
82240: PPUSH
82241: CALL_OW 255
82245: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82246: LD_VAR 0 4
82250: PUSH
82251: LD_EXP 86
82255: IN
82256: NOT
82257: PUSH
82258: LD_EXP 87
82262: NOT
82263: OR
82264: PUSH
82265: LD_EXP 60
82269: NOT
82270: OR
82271: IFFALSE 82275
// exit ;
82273: GO 82508
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82275: LD_ADDR_EXP 87
82279: PUSH
82280: LD_EXP 87
82284: PPUSH
82285: LD_VAR 0 4
82289: PPUSH
82290: LD_EXP 87
82294: PUSH
82295: LD_VAR 0 4
82299: ARRAY
82300: PUSH
82301: LD_VAR 0 1
82305: DIFF
82306: PPUSH
82307: CALL_OW 1
82311: ST_TO_ADDR
// for i = 1 to mc_bases do
82312: LD_ADDR_VAR 0 5
82316: PUSH
82317: DOUBLE
82318: LD_INT 1
82320: DEC
82321: ST_TO_ADDR
82322: LD_EXP 60
82326: PUSH
82327: FOR_TO
82328: IFFALSE 82506
// begin if lab in mc_bases [ i ] then
82330: LD_VAR 0 2
82334: PUSH
82335: LD_EXP 60
82339: PUSH
82340: LD_VAR 0 5
82344: ARRAY
82345: IN
82346: IFFALSE 82504
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82348: LD_VAR 0 1
82352: PUSH
82353: LD_INT 11
82355: PUSH
82356: LD_INT 4
82358: PUSH
82359: LD_INT 3
82361: PUSH
82362: LD_INT 2
82364: PUSH
82365: EMPTY
82366: LIST
82367: LIST
82368: LIST
82369: LIST
82370: IN
82371: PUSH
82372: LD_EXP 90
82376: PUSH
82377: LD_VAR 0 5
82381: ARRAY
82382: AND
82383: IFFALSE 82504
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82385: LD_ADDR_VAR 0 6
82389: PUSH
82390: LD_EXP 90
82394: PUSH
82395: LD_VAR 0 5
82399: ARRAY
82400: PUSH
82401: LD_INT 1
82403: ARRAY
82404: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82405: LD_ADDR_EXP 90
82409: PUSH
82410: LD_EXP 90
82414: PPUSH
82415: LD_VAR 0 5
82419: PPUSH
82420: EMPTY
82421: PPUSH
82422: CALL_OW 1
82426: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
82427: LD_VAR 0 6
82431: PPUSH
82432: LD_INT 0
82434: PPUSH
82435: CALL_OW 109
// ComExitBuilding ( tmp ) ;
82439: LD_VAR 0 6
82443: PPUSH
82444: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
82448: LD_ADDR_EXP 89
82452: PUSH
82453: LD_EXP 89
82457: PPUSH
82458: LD_VAR 0 5
82462: PPUSH
82463: LD_EXP 89
82467: PUSH
82468: LD_VAR 0 5
82472: ARRAY
82473: PPUSH
82474: LD_INT 1
82476: PPUSH
82477: LD_VAR 0 6
82481: PPUSH
82482: CALL_OW 2
82486: PPUSH
82487: CALL_OW 1
82491: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
82492: LD_VAR 0 5
82496: PPUSH
82497: LD_INT 112
82499: PPUSH
82500: CALL 59027 0 2
// end ; end ; end ;
82504: GO 82327
82506: POP
82507: POP
// end ;
82508: LD_VAR 0 3
82512: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
82513: LD_INT 0
82515: PPUSH
82516: PPUSH
82517: PPUSH
82518: PPUSH
82519: PPUSH
82520: PPUSH
82521: PPUSH
82522: PPUSH
// if not mc_bases or not skirmish then
82523: LD_EXP 60
82527: NOT
82528: PUSH
82529: LD_EXP 58
82533: NOT
82534: OR
82535: IFFALSE 82539
// exit ;
82537: GO 83910
// for i = 1 to mc_bases do
82539: LD_ADDR_VAR 0 3
82543: PUSH
82544: DOUBLE
82545: LD_INT 1
82547: DEC
82548: ST_TO_ADDR
82549: LD_EXP 60
82553: PUSH
82554: FOR_TO
82555: IFFALSE 83908
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
82557: LD_VAR 0 1
82561: PUSH
82562: LD_EXP 60
82566: PUSH
82567: LD_VAR 0 3
82571: ARRAY
82572: IN
82573: PUSH
82574: LD_VAR 0 1
82578: PUSH
82579: LD_EXP 67
82583: PUSH
82584: LD_VAR 0 3
82588: ARRAY
82589: IN
82590: OR
82591: PUSH
82592: LD_VAR 0 1
82596: PUSH
82597: LD_EXP 82
82601: PUSH
82602: LD_VAR 0 3
82606: ARRAY
82607: IN
82608: OR
82609: PUSH
82610: LD_VAR 0 1
82614: PUSH
82615: LD_EXP 79
82619: PUSH
82620: LD_VAR 0 3
82624: ARRAY
82625: IN
82626: OR
82627: PUSH
82628: LD_VAR 0 1
82632: PUSH
82633: LD_EXP 89
82637: PUSH
82638: LD_VAR 0 3
82642: ARRAY
82643: IN
82644: OR
82645: PUSH
82646: LD_VAR 0 1
82650: PUSH
82651: LD_EXP 90
82655: PUSH
82656: LD_VAR 0 3
82660: ARRAY
82661: IN
82662: OR
82663: IFFALSE 83906
// begin if un in mc_ape [ i ] then
82665: LD_VAR 0 1
82669: PUSH
82670: LD_EXP 89
82674: PUSH
82675: LD_VAR 0 3
82679: ARRAY
82680: IN
82681: IFFALSE 82720
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82683: LD_ADDR_EXP 89
82687: PUSH
82688: LD_EXP 89
82692: PPUSH
82693: LD_VAR 0 3
82697: PPUSH
82698: LD_EXP 89
82702: PUSH
82703: LD_VAR 0 3
82707: ARRAY
82708: PUSH
82709: LD_VAR 0 1
82713: DIFF
82714: PPUSH
82715: CALL_OW 1
82719: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82720: LD_VAR 0 1
82724: PUSH
82725: LD_EXP 90
82729: PUSH
82730: LD_VAR 0 3
82734: ARRAY
82735: IN
82736: IFFALSE 82760
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82738: LD_ADDR_EXP 90
82742: PUSH
82743: LD_EXP 90
82747: PPUSH
82748: LD_VAR 0 3
82752: PPUSH
82753: EMPTY
82754: PPUSH
82755: CALL_OW 1
82759: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
82760: LD_VAR 0 1
82764: PPUSH
82765: CALL_OW 247
82769: PUSH
82770: LD_INT 2
82772: EQUAL
82773: PUSH
82774: LD_VAR 0 1
82778: PPUSH
82779: CALL_OW 110
82783: PUSH
82784: LD_INT 20
82786: EQUAL
82787: PUSH
82788: LD_VAR 0 1
82792: PUSH
82793: LD_EXP 82
82797: PUSH
82798: LD_VAR 0 3
82802: ARRAY
82803: IN
82804: OR
82805: PUSH
82806: LD_VAR 0 1
82810: PPUSH
82811: CALL_OW 264
82815: PUSH
82816: LD_INT 12
82818: PUSH
82819: LD_INT 51
82821: PUSH
82822: LD_EXP 105
82826: PUSH
82827: LD_INT 32
82829: PUSH
82830: LD_INT 13
82832: PUSH
82833: LD_INT 52
82835: PUSH
82836: LD_INT 31
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: IN
82848: OR
82849: AND
82850: IFFALSE 83158
// begin if un in mc_defender [ i ] then
82852: LD_VAR 0 1
82856: PUSH
82857: LD_EXP 82
82861: PUSH
82862: LD_VAR 0 3
82866: ARRAY
82867: IN
82868: IFFALSE 82907
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82870: LD_ADDR_EXP 82
82874: PUSH
82875: LD_EXP 82
82879: PPUSH
82880: LD_VAR 0 3
82884: PPUSH
82885: LD_EXP 82
82889: PUSH
82890: LD_VAR 0 3
82894: ARRAY
82895: PUSH
82896: LD_VAR 0 1
82900: DIFF
82901: PPUSH
82902: CALL_OW 1
82906: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
82907: LD_ADDR_VAR 0 8
82911: PUSH
82912: LD_VAR 0 3
82916: PPUSH
82917: LD_INT 3
82919: PPUSH
82920: CALL 79548 0 2
82924: ST_TO_ADDR
// if fac then
82925: LD_VAR 0 8
82929: IFFALSE 83158
// begin for j in fac do
82931: LD_ADDR_VAR 0 4
82935: PUSH
82936: LD_VAR 0 8
82940: PUSH
82941: FOR_IN
82942: IFFALSE 83156
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
82944: LD_ADDR_VAR 0 9
82948: PUSH
82949: LD_VAR 0 8
82953: PPUSH
82954: LD_VAR 0 1
82958: PPUSH
82959: CALL_OW 265
82963: PPUSH
82964: LD_VAR 0 1
82968: PPUSH
82969: CALL_OW 262
82973: PPUSH
82974: LD_VAR 0 1
82978: PPUSH
82979: CALL_OW 263
82983: PPUSH
82984: LD_VAR 0 1
82988: PPUSH
82989: CALL_OW 264
82993: PPUSH
82994: CALL 17320 0 5
82998: ST_TO_ADDR
// if components then
82999: LD_VAR 0 9
83003: IFFALSE 83154
// begin if GetWeapon ( un ) = ar_control_tower then
83005: LD_VAR 0 1
83009: PPUSH
83010: CALL_OW 264
83014: PUSH
83015: LD_INT 31
83017: EQUAL
83018: IFFALSE 83135
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
83020: LD_VAR 0 1
83024: PPUSH
83025: CALL_OW 311
83029: PPUSH
83030: LD_INT 0
83032: PPUSH
83033: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
83037: LD_ADDR_EXP 100
83041: PUSH
83042: LD_EXP 100
83046: PPUSH
83047: LD_VAR 0 3
83051: PPUSH
83052: LD_EXP 100
83056: PUSH
83057: LD_VAR 0 3
83061: ARRAY
83062: PUSH
83063: LD_VAR 0 1
83067: PPUSH
83068: CALL_OW 311
83072: DIFF
83073: PPUSH
83074: CALL_OW 1
83078: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
83079: LD_ADDR_VAR 0 7
83083: PUSH
83084: LD_EXP 81
83088: PUSH
83089: LD_VAR 0 3
83093: ARRAY
83094: PPUSH
83095: LD_INT 1
83097: PPUSH
83098: LD_VAR 0 9
83102: PPUSH
83103: CALL_OW 2
83107: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
83108: LD_ADDR_EXP 81
83112: PUSH
83113: LD_EXP 81
83117: PPUSH
83118: LD_VAR 0 3
83122: PPUSH
83123: LD_VAR 0 7
83127: PPUSH
83128: CALL_OW 1
83132: ST_TO_ADDR
// end else
83133: GO 83152
// MC_InsertProduceList ( i , [ components ] ) ;
83135: LD_VAR 0 3
83139: PPUSH
83140: LD_VAR 0 9
83144: PUSH
83145: EMPTY
83146: LIST
83147: PPUSH
83148: CALL 79093 0 2
// break ;
83152: GO 83156
// end ; end ;
83154: GO 82941
83156: POP
83157: POP
// end ; end ; if GetType ( un ) = unit_building then
83158: LD_VAR 0 1
83162: PPUSH
83163: CALL_OW 247
83167: PUSH
83168: LD_INT 3
83170: EQUAL
83171: IFFALSE 83574
// begin btype := GetBType ( un ) ;
83173: LD_ADDR_VAR 0 5
83177: PUSH
83178: LD_VAR 0 1
83182: PPUSH
83183: CALL_OW 266
83187: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
83188: LD_VAR 0 5
83192: PUSH
83193: LD_INT 29
83195: PUSH
83196: LD_INT 30
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: IN
83203: IFFALSE 83276
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
83205: LD_VAR 0 1
83209: PPUSH
83210: CALL_OW 250
83214: PPUSH
83215: LD_VAR 0 1
83219: PPUSH
83220: CALL_OW 251
83224: PPUSH
83225: LD_VAR 0 1
83229: PPUSH
83230: CALL_OW 255
83234: PPUSH
83235: CALL_OW 440
83239: NOT
83240: IFFALSE 83276
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
83242: LD_VAR 0 1
83246: PPUSH
83247: CALL_OW 250
83251: PPUSH
83252: LD_VAR 0 1
83256: PPUSH
83257: CALL_OW 251
83261: PPUSH
83262: LD_VAR 0 1
83266: PPUSH
83267: CALL_OW 255
83271: PPUSH
83272: CALL_OW 441
// end ; if btype = b_warehouse then
83276: LD_VAR 0 5
83280: PUSH
83281: LD_INT 1
83283: EQUAL
83284: IFFALSE 83302
// begin btype := b_depot ;
83286: LD_ADDR_VAR 0 5
83290: PUSH
83291: LD_INT 0
83293: ST_TO_ADDR
// pos := 1 ;
83294: LD_ADDR_VAR 0 6
83298: PUSH
83299: LD_INT 1
83301: ST_TO_ADDR
// end ; if btype = b_factory then
83302: LD_VAR 0 5
83306: PUSH
83307: LD_INT 3
83309: EQUAL
83310: IFFALSE 83328
// begin btype := b_workshop ;
83312: LD_ADDR_VAR 0 5
83316: PUSH
83317: LD_INT 2
83319: ST_TO_ADDR
// pos := 1 ;
83320: LD_ADDR_VAR 0 6
83324: PUSH
83325: LD_INT 1
83327: ST_TO_ADDR
// end ; if btype = b_barracks then
83328: LD_VAR 0 5
83332: PUSH
83333: LD_INT 5
83335: EQUAL
83336: IFFALSE 83346
// btype := b_armoury ;
83338: LD_ADDR_VAR 0 5
83342: PUSH
83343: LD_INT 4
83345: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83346: LD_VAR 0 5
83350: PUSH
83351: LD_INT 7
83353: PUSH
83354: LD_INT 8
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: IN
83361: IFFALSE 83371
// btype := b_lab ;
83363: LD_ADDR_VAR 0 5
83367: PUSH
83368: LD_INT 6
83370: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83371: LD_ADDR_EXP 65
83375: PUSH
83376: LD_EXP 65
83380: PPUSH
83381: LD_VAR 0 3
83385: PUSH
83386: LD_EXP 65
83390: PUSH
83391: LD_VAR 0 3
83395: ARRAY
83396: PUSH
83397: LD_INT 1
83399: PLUS
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PPUSH
83405: LD_VAR 0 5
83409: PUSH
83410: LD_VAR 0 1
83414: PPUSH
83415: CALL_OW 250
83419: PUSH
83420: LD_VAR 0 1
83424: PPUSH
83425: CALL_OW 251
83429: PUSH
83430: LD_VAR 0 1
83434: PPUSH
83435: CALL_OW 254
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: LIST
83444: LIST
83445: PPUSH
83446: CALL 19824 0 3
83450: ST_TO_ADDR
// if pos = 1 then
83451: LD_VAR 0 6
83455: PUSH
83456: LD_INT 1
83458: EQUAL
83459: IFFALSE 83574
// begin tmp := mc_build_list [ i ] ;
83461: LD_ADDR_VAR 0 7
83465: PUSH
83466: LD_EXP 65
83470: PUSH
83471: LD_VAR 0 3
83475: ARRAY
83476: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83477: LD_VAR 0 7
83481: PPUSH
83482: LD_INT 2
83484: PUSH
83485: LD_INT 30
83487: PUSH
83488: LD_INT 0
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 30
83497: PUSH
83498: LD_INT 1
83500: PUSH
83501: EMPTY
83502: LIST
83503: LIST
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: LIST
83509: PPUSH
83510: CALL_OW 72
83514: IFFALSE 83524
// pos := 2 ;
83516: LD_ADDR_VAR 0 6
83520: PUSH
83521: LD_INT 2
83523: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83524: LD_ADDR_VAR 0 7
83528: PUSH
83529: LD_VAR 0 7
83533: PPUSH
83534: LD_VAR 0 6
83538: PPUSH
83539: LD_VAR 0 7
83543: PPUSH
83544: CALL 20150 0 3
83548: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83549: LD_ADDR_EXP 65
83553: PUSH
83554: LD_EXP 65
83558: PPUSH
83559: LD_VAR 0 3
83563: PPUSH
83564: LD_VAR 0 7
83568: PPUSH
83569: CALL_OW 1
83573: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83574: LD_VAR 0 1
83578: PUSH
83579: LD_EXP 60
83583: PUSH
83584: LD_VAR 0 3
83588: ARRAY
83589: IN
83590: IFFALSE 83629
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83592: LD_ADDR_EXP 60
83596: PUSH
83597: LD_EXP 60
83601: PPUSH
83602: LD_VAR 0 3
83606: PPUSH
83607: LD_EXP 60
83611: PUSH
83612: LD_VAR 0 3
83616: ARRAY
83617: PUSH
83618: LD_VAR 0 1
83622: DIFF
83623: PPUSH
83624: CALL_OW 1
83628: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83629: LD_VAR 0 1
83633: PUSH
83634: LD_EXP 67
83638: PUSH
83639: LD_VAR 0 3
83643: ARRAY
83644: IN
83645: IFFALSE 83684
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
83647: LD_ADDR_EXP 67
83651: PUSH
83652: LD_EXP 67
83656: PPUSH
83657: LD_VAR 0 3
83661: PPUSH
83662: LD_EXP 67
83666: PUSH
83667: LD_VAR 0 3
83671: ARRAY
83672: PUSH
83673: LD_VAR 0 1
83677: DIFF
83678: PPUSH
83679: CALL_OW 1
83683: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83684: LD_VAR 0 1
83688: PUSH
83689: LD_EXP 79
83693: PUSH
83694: LD_VAR 0 3
83698: ARRAY
83699: IN
83700: IFFALSE 83739
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83702: LD_ADDR_EXP 79
83706: PUSH
83707: LD_EXP 79
83711: PPUSH
83712: LD_VAR 0 3
83716: PPUSH
83717: LD_EXP 79
83721: PUSH
83722: LD_VAR 0 3
83726: ARRAY
83727: PUSH
83728: LD_VAR 0 1
83732: DIFF
83733: PPUSH
83734: CALL_OW 1
83738: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83739: LD_VAR 0 1
83743: PUSH
83744: LD_EXP 82
83748: PUSH
83749: LD_VAR 0 3
83753: ARRAY
83754: IN
83755: IFFALSE 83794
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83757: LD_ADDR_EXP 82
83761: PUSH
83762: LD_EXP 82
83766: PPUSH
83767: LD_VAR 0 3
83771: PPUSH
83772: LD_EXP 82
83776: PUSH
83777: LD_VAR 0 3
83781: ARRAY
83782: PUSH
83783: LD_VAR 0 1
83787: DIFF
83788: PPUSH
83789: CALL_OW 1
83793: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
83794: LD_VAR 0 1
83798: PUSH
83799: LD_EXP 69
83803: PUSH
83804: LD_VAR 0 3
83808: ARRAY
83809: IN
83810: IFFALSE 83849
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
83812: LD_ADDR_EXP 69
83816: PUSH
83817: LD_EXP 69
83821: PPUSH
83822: LD_VAR 0 3
83826: PPUSH
83827: LD_EXP 69
83831: PUSH
83832: LD_VAR 0 3
83836: ARRAY
83837: PUSH
83838: LD_VAR 0 1
83842: DIFF
83843: PPUSH
83844: CALL_OW 1
83848: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
83849: LD_VAR 0 1
83853: PUSH
83854: LD_EXP 68
83858: PUSH
83859: LD_VAR 0 3
83863: ARRAY
83864: IN
83865: IFFALSE 83904
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
83867: LD_ADDR_EXP 68
83871: PUSH
83872: LD_EXP 68
83876: PPUSH
83877: LD_VAR 0 3
83881: PPUSH
83882: LD_EXP 68
83886: PUSH
83887: LD_VAR 0 3
83891: ARRAY
83892: PUSH
83893: LD_VAR 0 1
83897: DIFF
83898: PPUSH
83899: CALL_OW 1
83903: ST_TO_ADDR
// end ; break ;
83904: GO 83908
// end ;
83906: GO 82554
83908: POP
83909: POP
// end ;
83910: LD_VAR 0 2
83914: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
83915: LD_INT 0
83917: PPUSH
83918: PPUSH
83919: PPUSH
// if not mc_bases or not skirmish then
83920: LD_EXP 60
83924: NOT
83925: PUSH
83926: LD_EXP 58
83930: NOT
83931: OR
83932: IFFALSE 83936
// exit ;
83934: GO 84151
// for i = 1 to mc_bases do
83936: LD_ADDR_VAR 0 3
83940: PUSH
83941: DOUBLE
83942: LD_INT 1
83944: DEC
83945: ST_TO_ADDR
83946: LD_EXP 60
83950: PUSH
83951: FOR_TO
83952: IFFALSE 84149
// begin if building in mc_construct_list [ i ] then
83954: LD_VAR 0 1
83958: PUSH
83959: LD_EXP 67
83963: PUSH
83964: LD_VAR 0 3
83968: ARRAY
83969: IN
83970: IFFALSE 84147
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83972: LD_ADDR_EXP 67
83976: PUSH
83977: LD_EXP 67
83981: PPUSH
83982: LD_VAR 0 3
83986: PPUSH
83987: LD_EXP 67
83991: PUSH
83992: LD_VAR 0 3
83996: ARRAY
83997: PUSH
83998: LD_VAR 0 1
84002: DIFF
84003: PPUSH
84004: CALL_OW 1
84008: ST_TO_ADDR
// if building in mc_lab [ i ] then
84009: LD_VAR 0 1
84013: PUSH
84014: LD_EXP 93
84018: PUSH
84019: LD_VAR 0 3
84023: ARRAY
84024: IN
84025: IFFALSE 84080
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84027: LD_ADDR_EXP 94
84031: PUSH
84032: LD_EXP 94
84036: PPUSH
84037: LD_VAR 0 3
84041: PPUSH
84042: LD_EXP 94
84046: PUSH
84047: LD_VAR 0 3
84051: ARRAY
84052: PPUSH
84053: LD_INT 1
84055: PPUSH
84056: LD_EXP 94
84060: PUSH
84061: LD_VAR 0 3
84065: ARRAY
84066: PPUSH
84067: LD_INT 0
84069: PPUSH
84070: CALL 19242 0 4
84074: PPUSH
84075: CALL_OW 1
84079: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84080: LD_VAR 0 1
84084: PUSH
84085: LD_EXP 60
84089: PUSH
84090: LD_VAR 0 3
84094: ARRAY
84095: IN
84096: NOT
84097: IFFALSE 84143
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84099: LD_ADDR_EXP 60
84103: PUSH
84104: LD_EXP 60
84108: PPUSH
84109: LD_VAR 0 3
84113: PUSH
84114: LD_EXP 60
84118: PUSH
84119: LD_VAR 0 3
84123: ARRAY
84124: PUSH
84125: LD_INT 1
84127: PLUS
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PPUSH
84133: LD_VAR 0 1
84137: PPUSH
84138: CALL 19824 0 3
84142: ST_TO_ADDR
// exit ;
84143: POP
84144: POP
84145: GO 84151
// end ; end ;
84147: GO 83951
84149: POP
84150: POP
// end ;
84151: LD_VAR 0 2
84155: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84156: LD_INT 0
84158: PPUSH
84159: PPUSH
84160: PPUSH
84161: PPUSH
84162: PPUSH
84163: PPUSH
84164: PPUSH
// if not mc_bases or not skirmish then
84165: LD_EXP 60
84169: NOT
84170: PUSH
84171: LD_EXP 58
84175: NOT
84176: OR
84177: IFFALSE 84181
// exit ;
84179: GO 84842
// for i = 1 to mc_bases do
84181: LD_ADDR_VAR 0 3
84185: PUSH
84186: DOUBLE
84187: LD_INT 1
84189: DEC
84190: ST_TO_ADDR
84191: LD_EXP 60
84195: PUSH
84196: FOR_TO
84197: IFFALSE 84840
// begin if building in mc_construct_list [ i ] then
84199: LD_VAR 0 1
84203: PUSH
84204: LD_EXP 67
84208: PUSH
84209: LD_VAR 0 3
84213: ARRAY
84214: IN
84215: IFFALSE 84838
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84217: LD_ADDR_EXP 67
84221: PUSH
84222: LD_EXP 67
84226: PPUSH
84227: LD_VAR 0 3
84231: PPUSH
84232: LD_EXP 67
84236: PUSH
84237: LD_VAR 0 3
84241: ARRAY
84242: PUSH
84243: LD_VAR 0 1
84247: DIFF
84248: PPUSH
84249: CALL_OW 1
84253: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84254: LD_ADDR_EXP 60
84258: PUSH
84259: LD_EXP 60
84263: PPUSH
84264: LD_VAR 0 3
84268: PUSH
84269: LD_EXP 60
84273: PUSH
84274: LD_VAR 0 3
84278: ARRAY
84279: PUSH
84280: LD_INT 1
84282: PLUS
84283: PUSH
84284: EMPTY
84285: LIST
84286: LIST
84287: PPUSH
84288: LD_VAR 0 1
84292: PPUSH
84293: CALL 19824 0 3
84297: ST_TO_ADDR
// btype := GetBType ( building ) ;
84298: LD_ADDR_VAR 0 5
84302: PUSH
84303: LD_VAR 0 1
84307: PPUSH
84308: CALL_OW 266
84312: ST_TO_ADDR
// side := GetSide ( building ) ;
84313: LD_ADDR_VAR 0 8
84317: PUSH
84318: LD_VAR 0 1
84322: PPUSH
84323: CALL_OW 255
84327: ST_TO_ADDR
// if btype = b_lab then
84328: LD_VAR 0 5
84332: PUSH
84333: LD_INT 6
84335: EQUAL
84336: IFFALSE 84386
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84338: LD_ADDR_EXP 93
84342: PUSH
84343: LD_EXP 93
84347: PPUSH
84348: LD_VAR 0 3
84352: PUSH
84353: LD_EXP 93
84357: PUSH
84358: LD_VAR 0 3
84362: ARRAY
84363: PUSH
84364: LD_INT 1
84366: PLUS
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: PPUSH
84372: LD_VAR 0 1
84376: PPUSH
84377: CALL 19824 0 3
84381: ST_TO_ADDR
// exit ;
84382: POP
84383: POP
84384: GO 84842
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84386: LD_VAR 0 5
84390: PUSH
84391: LD_INT 0
84393: PUSH
84394: LD_INT 2
84396: PUSH
84397: LD_INT 4
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: LIST
84404: IN
84405: IFFALSE 84529
// begin if btype = b_armoury then
84407: LD_VAR 0 5
84411: PUSH
84412: LD_INT 4
84414: EQUAL
84415: IFFALSE 84425
// btype := b_barracks ;
84417: LD_ADDR_VAR 0 5
84421: PUSH
84422: LD_INT 5
84424: ST_TO_ADDR
// if btype = b_depot then
84425: LD_VAR 0 5
84429: PUSH
84430: LD_INT 0
84432: EQUAL
84433: IFFALSE 84443
// btype := b_warehouse ;
84435: LD_ADDR_VAR 0 5
84439: PUSH
84440: LD_INT 1
84442: ST_TO_ADDR
// if btype = b_workshop then
84443: LD_VAR 0 5
84447: PUSH
84448: LD_INT 2
84450: EQUAL
84451: IFFALSE 84461
// btype := b_factory ;
84453: LD_ADDR_VAR 0 5
84457: PUSH
84458: LD_INT 3
84460: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
84461: LD_VAR 0 5
84465: PPUSH
84466: LD_VAR 0 8
84470: PPUSH
84471: CALL_OW 323
84475: PUSH
84476: LD_INT 1
84478: EQUAL
84479: IFFALSE 84525
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
84481: LD_ADDR_EXP 92
84485: PUSH
84486: LD_EXP 92
84490: PPUSH
84491: LD_VAR 0 3
84495: PUSH
84496: LD_EXP 92
84500: PUSH
84501: LD_VAR 0 3
84505: ARRAY
84506: PUSH
84507: LD_INT 1
84509: PLUS
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PPUSH
84515: LD_VAR 0 1
84519: PPUSH
84520: CALL 19824 0 3
84524: ST_TO_ADDR
// exit ;
84525: POP
84526: POP
84527: GO 84842
// end ; if btype in [ b_bunker , b_turret ] then
84529: LD_VAR 0 5
84533: PUSH
84534: LD_INT 32
84536: PUSH
84537: LD_INT 33
84539: PUSH
84540: EMPTY
84541: LIST
84542: LIST
84543: IN
84544: IFFALSE 84834
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84546: LD_ADDR_EXP 68
84550: PUSH
84551: LD_EXP 68
84555: PPUSH
84556: LD_VAR 0 3
84560: PUSH
84561: LD_EXP 68
84565: PUSH
84566: LD_VAR 0 3
84570: ARRAY
84571: PUSH
84572: LD_INT 1
84574: PLUS
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: PPUSH
84580: LD_VAR 0 1
84584: PPUSH
84585: CALL 19824 0 3
84589: ST_TO_ADDR
// if btype = b_bunker then
84590: LD_VAR 0 5
84594: PUSH
84595: LD_INT 32
84597: EQUAL
84598: IFFALSE 84834
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84600: LD_ADDR_EXP 69
84604: PUSH
84605: LD_EXP 69
84609: PPUSH
84610: LD_VAR 0 3
84614: PUSH
84615: LD_EXP 69
84619: PUSH
84620: LD_VAR 0 3
84624: ARRAY
84625: PUSH
84626: LD_INT 1
84628: PLUS
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PPUSH
84634: LD_VAR 0 1
84638: PPUSH
84639: CALL 19824 0 3
84643: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
84644: LD_ADDR_VAR 0 6
84648: PUSH
84649: LD_EXP 60
84653: PUSH
84654: LD_VAR 0 3
84658: ARRAY
84659: PPUSH
84660: LD_INT 25
84662: PUSH
84663: LD_INT 1
84665: PUSH
84666: EMPTY
84667: LIST
84668: LIST
84669: PUSH
84670: LD_INT 3
84672: PUSH
84673: LD_INT 54
84675: PUSH
84676: EMPTY
84677: LIST
84678: PUSH
84679: EMPTY
84680: LIST
84681: LIST
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PPUSH
84687: CALL_OW 72
84691: ST_TO_ADDR
// if tmp then
84692: LD_VAR 0 6
84696: IFFALSE 84702
// exit ;
84698: POP
84699: POP
84700: GO 84842
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84702: LD_ADDR_VAR 0 6
84706: PUSH
84707: LD_EXP 60
84711: PUSH
84712: LD_VAR 0 3
84716: ARRAY
84717: PPUSH
84718: LD_INT 2
84720: PUSH
84721: LD_INT 30
84723: PUSH
84724: LD_INT 4
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_INT 30
84733: PUSH
84734: LD_INT 5
84736: PUSH
84737: EMPTY
84738: LIST
84739: LIST
84740: PUSH
84741: EMPTY
84742: LIST
84743: LIST
84744: LIST
84745: PPUSH
84746: CALL_OW 72
84750: ST_TO_ADDR
// if not tmp then
84751: LD_VAR 0 6
84755: NOT
84756: IFFALSE 84762
// exit ;
84758: POP
84759: POP
84760: GO 84842
// for j in tmp do
84762: LD_ADDR_VAR 0 4
84766: PUSH
84767: LD_VAR 0 6
84771: PUSH
84772: FOR_IN
84773: IFFALSE 84832
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
84775: LD_ADDR_VAR 0 7
84779: PUSH
84780: LD_VAR 0 4
84784: PPUSH
84785: CALL_OW 313
84789: PPUSH
84790: LD_INT 25
84792: PUSH
84793: LD_INT 1
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: PPUSH
84800: CALL_OW 72
84804: ST_TO_ADDR
// if units then
84805: LD_VAR 0 7
84809: IFFALSE 84830
// begin ComExitBuilding ( units [ 1 ] ) ;
84811: LD_VAR 0 7
84815: PUSH
84816: LD_INT 1
84818: ARRAY
84819: PPUSH
84820: CALL_OW 122
// exit ;
84824: POP
84825: POP
84826: POP
84827: POP
84828: GO 84842
// end ; end ;
84830: GO 84772
84832: POP
84833: POP
// end ; end ; exit ;
84834: POP
84835: POP
84836: GO 84842
// end ; end ;
84838: GO 84196
84840: POP
84841: POP
// end ;
84842: LD_VAR 0 2
84846: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
84847: LD_INT 0
84849: PPUSH
84850: PPUSH
84851: PPUSH
84852: PPUSH
84853: PPUSH
84854: PPUSH
84855: PPUSH
// if not mc_bases or not skirmish then
84856: LD_EXP 60
84860: NOT
84861: PUSH
84862: LD_EXP 58
84866: NOT
84867: OR
84868: IFFALSE 84872
// exit ;
84870: GO 85137
// btype := GetBType ( building ) ;
84872: LD_ADDR_VAR 0 6
84876: PUSH
84877: LD_VAR 0 1
84881: PPUSH
84882: CALL_OW 266
84886: ST_TO_ADDR
// x := GetX ( building ) ;
84887: LD_ADDR_VAR 0 7
84891: PUSH
84892: LD_VAR 0 1
84896: PPUSH
84897: CALL_OW 250
84901: ST_TO_ADDR
// y := GetY ( building ) ;
84902: LD_ADDR_VAR 0 8
84906: PUSH
84907: LD_VAR 0 1
84911: PPUSH
84912: CALL_OW 251
84916: ST_TO_ADDR
// d := GetDir ( building ) ;
84917: LD_ADDR_VAR 0 9
84921: PUSH
84922: LD_VAR 0 1
84926: PPUSH
84927: CALL_OW 254
84931: ST_TO_ADDR
// for i = 1 to mc_bases do
84932: LD_ADDR_VAR 0 4
84936: PUSH
84937: DOUBLE
84938: LD_INT 1
84940: DEC
84941: ST_TO_ADDR
84942: LD_EXP 60
84946: PUSH
84947: FOR_TO
84948: IFFALSE 85135
// begin if not mc_build_list [ i ] then
84950: LD_EXP 65
84954: PUSH
84955: LD_VAR 0 4
84959: ARRAY
84960: NOT
84961: IFFALSE 84965
// continue ;
84963: GO 84947
// for j := 1 to mc_build_list [ i ] do
84965: LD_ADDR_VAR 0 5
84969: PUSH
84970: DOUBLE
84971: LD_INT 1
84973: DEC
84974: ST_TO_ADDR
84975: LD_EXP 65
84979: PUSH
84980: LD_VAR 0 4
84984: ARRAY
84985: PUSH
84986: FOR_TO
84987: IFFALSE 85131
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
84989: LD_VAR 0 6
84993: PUSH
84994: LD_VAR 0 7
84998: PUSH
84999: LD_VAR 0 8
85003: PUSH
85004: LD_VAR 0 9
85008: PUSH
85009: EMPTY
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: PPUSH
85015: LD_EXP 65
85019: PUSH
85020: LD_VAR 0 4
85024: ARRAY
85025: PUSH
85026: LD_VAR 0 5
85030: ARRAY
85031: PPUSH
85032: CALL 26006 0 2
85036: IFFALSE 85129
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
85038: LD_ADDR_EXP 65
85042: PUSH
85043: LD_EXP 65
85047: PPUSH
85048: LD_VAR 0 4
85052: PPUSH
85053: LD_EXP 65
85057: PUSH
85058: LD_VAR 0 4
85062: ARRAY
85063: PPUSH
85064: LD_VAR 0 5
85068: PPUSH
85069: CALL_OW 3
85073: PPUSH
85074: CALL_OW 1
85078: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85079: LD_ADDR_EXP 67
85083: PUSH
85084: LD_EXP 67
85088: PPUSH
85089: LD_VAR 0 4
85093: PUSH
85094: LD_EXP 67
85098: PUSH
85099: LD_VAR 0 4
85103: ARRAY
85104: PUSH
85105: LD_INT 1
85107: PLUS
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PPUSH
85113: LD_VAR 0 1
85117: PPUSH
85118: CALL 19824 0 3
85122: ST_TO_ADDR
// exit ;
85123: POP
85124: POP
85125: POP
85126: POP
85127: GO 85137
// end ;
85129: GO 84986
85131: POP
85132: POP
// end ;
85133: GO 84947
85135: POP
85136: POP
// end ;
85137: LD_VAR 0 3
85141: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85142: LD_INT 0
85144: PPUSH
85145: PPUSH
85146: PPUSH
// if not mc_bases or not skirmish then
85147: LD_EXP 60
85151: NOT
85152: PUSH
85153: LD_EXP 58
85157: NOT
85158: OR
85159: IFFALSE 85163
// exit ;
85161: GO 85353
// for i = 1 to mc_bases do
85163: LD_ADDR_VAR 0 4
85167: PUSH
85168: DOUBLE
85169: LD_INT 1
85171: DEC
85172: ST_TO_ADDR
85173: LD_EXP 60
85177: PUSH
85178: FOR_TO
85179: IFFALSE 85266
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85181: LD_VAR 0 1
85185: PUSH
85186: LD_EXP 68
85190: PUSH
85191: LD_VAR 0 4
85195: ARRAY
85196: IN
85197: PUSH
85198: LD_VAR 0 1
85202: PUSH
85203: LD_EXP 69
85207: PUSH
85208: LD_VAR 0 4
85212: ARRAY
85213: IN
85214: NOT
85215: AND
85216: IFFALSE 85264
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85218: LD_ADDR_EXP 69
85222: PUSH
85223: LD_EXP 69
85227: PPUSH
85228: LD_VAR 0 4
85232: PUSH
85233: LD_EXP 69
85237: PUSH
85238: LD_VAR 0 4
85242: ARRAY
85243: PUSH
85244: LD_INT 1
85246: PLUS
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PPUSH
85252: LD_VAR 0 1
85256: PPUSH
85257: CALL 19824 0 3
85261: ST_TO_ADDR
// break ;
85262: GO 85266
// end ; end ;
85264: GO 85178
85266: POP
85267: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85268: LD_VAR 0 1
85272: PPUSH
85273: CALL_OW 257
85277: PUSH
85278: LD_EXP 86
85282: IN
85283: PUSH
85284: LD_VAR 0 1
85288: PPUSH
85289: CALL_OW 266
85293: PUSH
85294: LD_INT 5
85296: EQUAL
85297: AND
85298: PUSH
85299: LD_VAR 0 2
85303: PPUSH
85304: CALL_OW 110
85308: PUSH
85309: LD_INT 18
85311: NONEQUAL
85312: AND
85313: IFFALSE 85353
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85315: LD_VAR 0 2
85319: PPUSH
85320: CALL_OW 257
85324: PUSH
85325: LD_INT 5
85327: PUSH
85328: LD_INT 8
85330: PUSH
85331: LD_INT 9
85333: PUSH
85334: EMPTY
85335: LIST
85336: LIST
85337: LIST
85338: IN
85339: IFFALSE 85353
// SetClass ( unit , 1 ) ;
85341: LD_VAR 0 2
85345: PPUSH
85346: LD_INT 1
85348: PPUSH
85349: CALL_OW 336
// end ;
85353: LD_VAR 0 3
85357: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85358: LD_INT 0
85360: PPUSH
85361: PPUSH
// if not mc_bases or not skirmish then
85362: LD_EXP 60
85366: NOT
85367: PUSH
85368: LD_EXP 58
85372: NOT
85373: OR
85374: IFFALSE 85378
// exit ;
85376: GO 85494
// if GetLives ( abandoned_vehicle ) > 250 then
85378: LD_VAR 0 2
85382: PPUSH
85383: CALL_OW 256
85387: PUSH
85388: LD_INT 250
85390: GREATER
85391: IFFALSE 85395
// exit ;
85393: GO 85494
// for i = 1 to mc_bases do
85395: LD_ADDR_VAR 0 6
85399: PUSH
85400: DOUBLE
85401: LD_INT 1
85403: DEC
85404: ST_TO_ADDR
85405: LD_EXP 60
85409: PUSH
85410: FOR_TO
85411: IFFALSE 85492
// begin if driver in mc_bases [ i ] then
85413: LD_VAR 0 1
85417: PUSH
85418: LD_EXP 60
85422: PUSH
85423: LD_VAR 0 6
85427: ARRAY
85428: IN
85429: IFFALSE 85490
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
85431: LD_VAR 0 1
85435: PPUSH
85436: LD_EXP 60
85440: PUSH
85441: LD_VAR 0 6
85445: ARRAY
85446: PPUSH
85447: LD_INT 2
85449: PUSH
85450: LD_INT 30
85452: PUSH
85453: LD_INT 0
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 30
85462: PUSH
85463: LD_INT 1
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: LIST
85474: PPUSH
85475: CALL_OW 72
85479: PUSH
85480: LD_INT 1
85482: ARRAY
85483: PPUSH
85484: CALL 52386 0 2
// break ;
85488: GO 85492
// end ; end ;
85490: GO 85410
85492: POP
85493: POP
// end ; end_of_file
85494: LD_VAR 0 5
85498: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
85499: LD_INT 0
85501: PPUSH
// ar_miner := 81 ;
85502: LD_ADDR_EXP 111
85506: PUSH
85507: LD_INT 81
85509: ST_TO_ADDR
// ar_crane := 88 ;
85510: LD_ADDR_EXP 110
85514: PUSH
85515: LD_INT 88
85517: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
85518: LD_ADDR_EXP 105
85522: PUSH
85523: LD_INT 89
85525: ST_TO_ADDR
// us_hack := 99 ;
85526: LD_ADDR_EXP 106
85530: PUSH
85531: LD_INT 99
85533: ST_TO_ADDR
// us_artillery := 97 ;
85534: LD_ADDR_EXP 107
85538: PUSH
85539: LD_INT 97
85541: ST_TO_ADDR
// ar_bio_bomb := 91 ;
85542: LD_ADDR_EXP 108
85546: PUSH
85547: LD_INT 91
85549: ST_TO_ADDR
// ar_mortar := 92 ;
85550: LD_ADDR_EXP 109
85554: PUSH
85555: LD_INT 92
85557: ST_TO_ADDR
// ru_radar := 98 ;
85558: LD_ADDR_EXP 104
85562: PUSH
85563: LD_INT 98
85565: ST_TO_ADDR
// tech_Artillery := 80 ;
85566: LD_ADDR_EXP 112
85570: PUSH
85571: LD_INT 80
85573: ST_TO_ADDR
// tech_RadMat := 81 ;
85574: LD_ADDR_EXP 113
85578: PUSH
85579: LD_INT 81
85581: ST_TO_ADDR
// tech_BasicTools := 82 ;
85582: LD_ADDR_EXP 114
85586: PUSH
85587: LD_INT 82
85589: ST_TO_ADDR
// tech_Cargo := 83 ;
85590: LD_ADDR_EXP 115
85594: PUSH
85595: LD_INT 83
85597: ST_TO_ADDR
// tech_Track := 84 ;
85598: LD_ADDR_EXP 116
85602: PUSH
85603: LD_INT 84
85605: ST_TO_ADDR
// tech_Crane := 85 ;
85606: LD_ADDR_EXP 117
85610: PUSH
85611: LD_INT 85
85613: ST_TO_ADDR
// tech_Bulldozer := 86 ;
85614: LD_ADDR_EXP 118
85618: PUSH
85619: LD_INT 86
85621: ST_TO_ADDR
// tech_Hovercraft := 87 ;
85622: LD_ADDR_EXP 119
85626: PUSH
85627: LD_INT 87
85629: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
85630: LD_ADDR_EXP 120
85634: PUSH
85635: LD_INT 88
85637: ST_TO_ADDR
// class_mastodont := 31 ;
85638: LD_ADDR_EXP 121
85642: PUSH
85643: LD_INT 31
85645: ST_TO_ADDR
// class_horse := 21 ;
85646: LD_ADDR_EXP 122
85650: PUSH
85651: LD_INT 21
85653: ST_TO_ADDR
// end ;
85654: LD_VAR 0 1
85658: RET
// every 1 do
85659: GO 85661
85661: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
85662: CALL 85499 0 0
85666: END
// every 0 0$1 do
85667: GO 85669
85669: DISABLE
// begin enable ;
85670: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
85671: LD_STRING updateTimer(
85673: PUSH
85674: LD_OWVAR 1
85678: STR
85679: PUSH
85680: LD_STRING );
85682: STR
85683: PPUSH
85684: CALL_OW 559
// end ;
85688: END
// export function SOS_MapStart ( ) ; begin
85689: LD_INT 0
85691: PPUSH
// if streamModeActive then
85692: LD_EXP 123
85696: IFFALSE 85705
// DefineStreamItems ( true ) ;
85698: LD_INT 1
85700: PPUSH
85701: CALL 87355 0 1
// UpdateFactoryWaypoints ( ) ;
85705: CALL 100939 0 0
// end ;
85709: LD_VAR 0 1
85713: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
85714: LD_INT 0
85716: PPUSH
// if p2 = 100 then
85717: LD_VAR 0 2
85721: PUSH
85722: LD_INT 100
85724: EQUAL
85725: IFFALSE 86728
// begin if not StreamModeActive then
85727: LD_EXP 123
85731: NOT
85732: IFFALSE 85742
// StreamModeActive := true ;
85734: LD_ADDR_EXP 123
85738: PUSH
85739: LD_INT 1
85741: ST_TO_ADDR
// if p3 = 0 then
85742: LD_VAR 0 3
85746: PUSH
85747: LD_INT 0
85749: EQUAL
85750: IFFALSE 85756
// InitStreamMode ;
85752: CALL 86891 0 0
// if p3 = 1 then
85756: LD_VAR 0 3
85760: PUSH
85761: LD_INT 1
85763: EQUAL
85764: IFFALSE 85774
// sRocket := true ;
85766: LD_ADDR_EXP 128
85770: PUSH
85771: LD_INT 1
85773: ST_TO_ADDR
// if p3 = 2 then
85774: LD_VAR 0 3
85778: PUSH
85779: LD_INT 2
85781: EQUAL
85782: IFFALSE 85792
// sSpeed := true ;
85784: LD_ADDR_EXP 127
85788: PUSH
85789: LD_INT 1
85791: ST_TO_ADDR
// if p3 = 3 then
85792: LD_VAR 0 3
85796: PUSH
85797: LD_INT 3
85799: EQUAL
85800: IFFALSE 85810
// sEngine := true ;
85802: LD_ADDR_EXP 129
85806: PUSH
85807: LD_INT 1
85809: ST_TO_ADDR
// if p3 = 4 then
85810: LD_VAR 0 3
85814: PUSH
85815: LD_INT 4
85817: EQUAL
85818: IFFALSE 85828
// sSpec := true ;
85820: LD_ADDR_EXP 126
85824: PUSH
85825: LD_INT 1
85827: ST_TO_ADDR
// if p3 = 5 then
85828: LD_VAR 0 3
85832: PUSH
85833: LD_INT 5
85835: EQUAL
85836: IFFALSE 85846
// sLevel := true ;
85838: LD_ADDR_EXP 130
85842: PUSH
85843: LD_INT 1
85845: ST_TO_ADDR
// if p3 = 6 then
85846: LD_VAR 0 3
85850: PUSH
85851: LD_INT 6
85853: EQUAL
85854: IFFALSE 85864
// sArmoury := true ;
85856: LD_ADDR_EXP 131
85860: PUSH
85861: LD_INT 1
85863: ST_TO_ADDR
// if p3 = 7 then
85864: LD_VAR 0 3
85868: PUSH
85869: LD_INT 7
85871: EQUAL
85872: IFFALSE 85882
// sRadar := true ;
85874: LD_ADDR_EXP 132
85878: PUSH
85879: LD_INT 1
85881: ST_TO_ADDR
// if p3 = 8 then
85882: LD_VAR 0 3
85886: PUSH
85887: LD_INT 8
85889: EQUAL
85890: IFFALSE 85900
// sBunker := true ;
85892: LD_ADDR_EXP 133
85896: PUSH
85897: LD_INT 1
85899: ST_TO_ADDR
// if p3 = 9 then
85900: LD_VAR 0 3
85904: PUSH
85905: LD_INT 9
85907: EQUAL
85908: IFFALSE 85918
// sHack := true ;
85910: LD_ADDR_EXP 134
85914: PUSH
85915: LD_INT 1
85917: ST_TO_ADDR
// if p3 = 10 then
85918: LD_VAR 0 3
85922: PUSH
85923: LD_INT 10
85925: EQUAL
85926: IFFALSE 85936
// sFire := true ;
85928: LD_ADDR_EXP 135
85932: PUSH
85933: LD_INT 1
85935: ST_TO_ADDR
// if p3 = 11 then
85936: LD_VAR 0 3
85940: PUSH
85941: LD_INT 11
85943: EQUAL
85944: IFFALSE 85954
// sRefresh := true ;
85946: LD_ADDR_EXP 136
85950: PUSH
85951: LD_INT 1
85953: ST_TO_ADDR
// if p3 = 12 then
85954: LD_VAR 0 3
85958: PUSH
85959: LD_INT 12
85961: EQUAL
85962: IFFALSE 85972
// sExp := true ;
85964: LD_ADDR_EXP 137
85968: PUSH
85969: LD_INT 1
85971: ST_TO_ADDR
// if p3 = 13 then
85972: LD_VAR 0 3
85976: PUSH
85977: LD_INT 13
85979: EQUAL
85980: IFFALSE 85990
// sDepot := true ;
85982: LD_ADDR_EXP 138
85986: PUSH
85987: LD_INT 1
85989: ST_TO_ADDR
// if p3 = 14 then
85990: LD_VAR 0 3
85994: PUSH
85995: LD_INT 14
85997: EQUAL
85998: IFFALSE 86008
// sFlag := true ;
86000: LD_ADDR_EXP 139
86004: PUSH
86005: LD_INT 1
86007: ST_TO_ADDR
// if p3 = 15 then
86008: LD_VAR 0 3
86012: PUSH
86013: LD_INT 15
86015: EQUAL
86016: IFFALSE 86026
// sKamikadze := true ;
86018: LD_ADDR_EXP 147
86022: PUSH
86023: LD_INT 1
86025: ST_TO_ADDR
// if p3 = 16 then
86026: LD_VAR 0 3
86030: PUSH
86031: LD_INT 16
86033: EQUAL
86034: IFFALSE 86044
// sTroll := true ;
86036: LD_ADDR_EXP 148
86040: PUSH
86041: LD_INT 1
86043: ST_TO_ADDR
// if p3 = 17 then
86044: LD_VAR 0 3
86048: PUSH
86049: LD_INT 17
86051: EQUAL
86052: IFFALSE 86062
// sSlow := true ;
86054: LD_ADDR_EXP 149
86058: PUSH
86059: LD_INT 1
86061: ST_TO_ADDR
// if p3 = 18 then
86062: LD_VAR 0 3
86066: PUSH
86067: LD_INT 18
86069: EQUAL
86070: IFFALSE 86080
// sLack := true ;
86072: LD_ADDR_EXP 150
86076: PUSH
86077: LD_INT 1
86079: ST_TO_ADDR
// if p3 = 19 then
86080: LD_VAR 0 3
86084: PUSH
86085: LD_INT 19
86087: EQUAL
86088: IFFALSE 86098
// sTank := true ;
86090: LD_ADDR_EXP 152
86094: PUSH
86095: LD_INT 1
86097: ST_TO_ADDR
// if p3 = 20 then
86098: LD_VAR 0 3
86102: PUSH
86103: LD_INT 20
86105: EQUAL
86106: IFFALSE 86116
// sRemote := true ;
86108: LD_ADDR_EXP 153
86112: PUSH
86113: LD_INT 1
86115: ST_TO_ADDR
// if p3 = 21 then
86116: LD_VAR 0 3
86120: PUSH
86121: LD_INT 21
86123: EQUAL
86124: IFFALSE 86134
// sPowell := true ;
86126: LD_ADDR_EXP 154
86130: PUSH
86131: LD_INT 1
86133: ST_TO_ADDR
// if p3 = 22 then
86134: LD_VAR 0 3
86138: PUSH
86139: LD_INT 22
86141: EQUAL
86142: IFFALSE 86152
// sTeleport := true ;
86144: LD_ADDR_EXP 157
86148: PUSH
86149: LD_INT 1
86151: ST_TO_ADDR
// if p3 = 23 then
86152: LD_VAR 0 3
86156: PUSH
86157: LD_INT 23
86159: EQUAL
86160: IFFALSE 86170
// sOilTower := true ;
86162: LD_ADDR_EXP 159
86166: PUSH
86167: LD_INT 1
86169: ST_TO_ADDR
// if p3 = 24 then
86170: LD_VAR 0 3
86174: PUSH
86175: LD_INT 24
86177: EQUAL
86178: IFFALSE 86188
// sShovel := true ;
86180: LD_ADDR_EXP 160
86184: PUSH
86185: LD_INT 1
86187: ST_TO_ADDR
// if p3 = 25 then
86188: LD_VAR 0 3
86192: PUSH
86193: LD_INT 25
86195: EQUAL
86196: IFFALSE 86206
// sSheik := true ;
86198: LD_ADDR_EXP 161
86202: PUSH
86203: LD_INT 1
86205: ST_TO_ADDR
// if p3 = 26 then
86206: LD_VAR 0 3
86210: PUSH
86211: LD_INT 26
86213: EQUAL
86214: IFFALSE 86224
// sEarthquake := true ;
86216: LD_ADDR_EXP 163
86220: PUSH
86221: LD_INT 1
86223: ST_TO_ADDR
// if p3 = 27 then
86224: LD_VAR 0 3
86228: PUSH
86229: LD_INT 27
86231: EQUAL
86232: IFFALSE 86242
// sAI := true ;
86234: LD_ADDR_EXP 164
86238: PUSH
86239: LD_INT 1
86241: ST_TO_ADDR
// if p3 = 28 then
86242: LD_VAR 0 3
86246: PUSH
86247: LD_INT 28
86249: EQUAL
86250: IFFALSE 86260
// sCargo := true ;
86252: LD_ADDR_EXP 167
86256: PUSH
86257: LD_INT 1
86259: ST_TO_ADDR
// if p3 = 29 then
86260: LD_VAR 0 3
86264: PUSH
86265: LD_INT 29
86267: EQUAL
86268: IFFALSE 86278
// sDLaser := true ;
86270: LD_ADDR_EXP 168
86274: PUSH
86275: LD_INT 1
86277: ST_TO_ADDR
// if p3 = 30 then
86278: LD_VAR 0 3
86282: PUSH
86283: LD_INT 30
86285: EQUAL
86286: IFFALSE 86296
// sExchange := true ;
86288: LD_ADDR_EXP 169
86292: PUSH
86293: LD_INT 1
86295: ST_TO_ADDR
// if p3 = 31 then
86296: LD_VAR 0 3
86300: PUSH
86301: LD_INT 31
86303: EQUAL
86304: IFFALSE 86314
// sFac := true ;
86306: LD_ADDR_EXP 170
86310: PUSH
86311: LD_INT 1
86313: ST_TO_ADDR
// if p3 = 32 then
86314: LD_VAR 0 3
86318: PUSH
86319: LD_INT 32
86321: EQUAL
86322: IFFALSE 86332
// sPower := true ;
86324: LD_ADDR_EXP 171
86328: PUSH
86329: LD_INT 1
86331: ST_TO_ADDR
// if p3 = 33 then
86332: LD_VAR 0 3
86336: PUSH
86337: LD_INT 33
86339: EQUAL
86340: IFFALSE 86350
// sRandom := true ;
86342: LD_ADDR_EXP 172
86346: PUSH
86347: LD_INT 1
86349: ST_TO_ADDR
// if p3 = 34 then
86350: LD_VAR 0 3
86354: PUSH
86355: LD_INT 34
86357: EQUAL
86358: IFFALSE 86368
// sShield := true ;
86360: LD_ADDR_EXP 173
86364: PUSH
86365: LD_INT 1
86367: ST_TO_ADDR
// if p3 = 35 then
86368: LD_VAR 0 3
86372: PUSH
86373: LD_INT 35
86375: EQUAL
86376: IFFALSE 86386
// sTime := true ;
86378: LD_ADDR_EXP 174
86382: PUSH
86383: LD_INT 1
86385: ST_TO_ADDR
// if p3 = 36 then
86386: LD_VAR 0 3
86390: PUSH
86391: LD_INT 36
86393: EQUAL
86394: IFFALSE 86404
// sTools := true ;
86396: LD_ADDR_EXP 175
86400: PUSH
86401: LD_INT 1
86403: ST_TO_ADDR
// if p3 = 101 then
86404: LD_VAR 0 3
86408: PUSH
86409: LD_INT 101
86411: EQUAL
86412: IFFALSE 86422
// sSold := true ;
86414: LD_ADDR_EXP 140
86418: PUSH
86419: LD_INT 1
86421: ST_TO_ADDR
// if p3 = 102 then
86422: LD_VAR 0 3
86426: PUSH
86427: LD_INT 102
86429: EQUAL
86430: IFFALSE 86440
// sDiff := true ;
86432: LD_ADDR_EXP 141
86436: PUSH
86437: LD_INT 1
86439: ST_TO_ADDR
// if p3 = 103 then
86440: LD_VAR 0 3
86444: PUSH
86445: LD_INT 103
86447: EQUAL
86448: IFFALSE 86458
// sFog := true ;
86450: LD_ADDR_EXP 144
86454: PUSH
86455: LD_INT 1
86457: ST_TO_ADDR
// if p3 = 104 then
86458: LD_VAR 0 3
86462: PUSH
86463: LD_INT 104
86465: EQUAL
86466: IFFALSE 86476
// sReset := true ;
86468: LD_ADDR_EXP 145
86472: PUSH
86473: LD_INT 1
86475: ST_TO_ADDR
// if p3 = 105 then
86476: LD_VAR 0 3
86480: PUSH
86481: LD_INT 105
86483: EQUAL
86484: IFFALSE 86494
// sSun := true ;
86486: LD_ADDR_EXP 146
86490: PUSH
86491: LD_INT 1
86493: ST_TO_ADDR
// if p3 = 106 then
86494: LD_VAR 0 3
86498: PUSH
86499: LD_INT 106
86501: EQUAL
86502: IFFALSE 86512
// sTiger := true ;
86504: LD_ADDR_EXP 142
86508: PUSH
86509: LD_INT 1
86511: ST_TO_ADDR
// if p3 = 107 then
86512: LD_VAR 0 3
86516: PUSH
86517: LD_INT 107
86519: EQUAL
86520: IFFALSE 86530
// sBomb := true ;
86522: LD_ADDR_EXP 143
86526: PUSH
86527: LD_INT 1
86529: ST_TO_ADDR
// if p3 = 108 then
86530: LD_VAR 0 3
86534: PUSH
86535: LD_INT 108
86537: EQUAL
86538: IFFALSE 86548
// sWound := true ;
86540: LD_ADDR_EXP 151
86544: PUSH
86545: LD_INT 1
86547: ST_TO_ADDR
// if p3 = 109 then
86548: LD_VAR 0 3
86552: PUSH
86553: LD_INT 109
86555: EQUAL
86556: IFFALSE 86566
// sBetray := true ;
86558: LD_ADDR_EXP 155
86562: PUSH
86563: LD_INT 1
86565: ST_TO_ADDR
// if p3 = 110 then
86566: LD_VAR 0 3
86570: PUSH
86571: LD_INT 110
86573: EQUAL
86574: IFFALSE 86584
// sContamin := true ;
86576: LD_ADDR_EXP 156
86580: PUSH
86581: LD_INT 1
86583: ST_TO_ADDR
// if p3 = 111 then
86584: LD_VAR 0 3
86588: PUSH
86589: LD_INT 111
86591: EQUAL
86592: IFFALSE 86602
// sOil := true ;
86594: LD_ADDR_EXP 158
86598: PUSH
86599: LD_INT 1
86601: ST_TO_ADDR
// if p3 = 112 then
86602: LD_VAR 0 3
86606: PUSH
86607: LD_INT 112
86609: EQUAL
86610: IFFALSE 86620
// sStu := true ;
86612: LD_ADDR_EXP 162
86616: PUSH
86617: LD_INT 1
86619: ST_TO_ADDR
// if p3 = 113 then
86620: LD_VAR 0 3
86624: PUSH
86625: LD_INT 113
86627: EQUAL
86628: IFFALSE 86638
// sBazooka := true ;
86630: LD_ADDR_EXP 165
86634: PUSH
86635: LD_INT 1
86637: ST_TO_ADDR
// if p3 = 114 then
86638: LD_VAR 0 3
86642: PUSH
86643: LD_INT 114
86645: EQUAL
86646: IFFALSE 86656
// sMortar := true ;
86648: LD_ADDR_EXP 166
86652: PUSH
86653: LD_INT 1
86655: ST_TO_ADDR
// if p3 = 115 then
86656: LD_VAR 0 3
86660: PUSH
86661: LD_INT 115
86663: EQUAL
86664: IFFALSE 86674
// sRanger := true ;
86666: LD_ADDR_EXP 176
86670: PUSH
86671: LD_INT 1
86673: ST_TO_ADDR
// if p3 = 116 then
86674: LD_VAR 0 3
86678: PUSH
86679: LD_INT 116
86681: EQUAL
86682: IFFALSE 86692
// sComputer := true ;
86684: LD_ADDR_EXP 177
86688: PUSH
86689: LD_INT 1
86691: ST_TO_ADDR
// if p3 = 117 then
86692: LD_VAR 0 3
86696: PUSH
86697: LD_INT 117
86699: EQUAL
86700: IFFALSE 86710
// s30 := true ;
86702: LD_ADDR_EXP 178
86706: PUSH
86707: LD_INT 1
86709: ST_TO_ADDR
// if p3 = 118 then
86710: LD_VAR 0 3
86714: PUSH
86715: LD_INT 118
86717: EQUAL
86718: IFFALSE 86728
// s60 := true ;
86720: LD_ADDR_EXP 179
86724: PUSH
86725: LD_INT 1
86727: ST_TO_ADDR
// end ; if p2 = 101 then
86728: LD_VAR 0 2
86732: PUSH
86733: LD_INT 101
86735: EQUAL
86736: IFFALSE 86864
// begin case p3 of 1 :
86738: LD_VAR 0 3
86742: PUSH
86743: LD_INT 1
86745: DOUBLE
86746: EQUAL
86747: IFTRUE 86751
86749: GO 86758
86751: POP
// hHackUnlimitedResources ; 2 :
86752: CALL 98962 0 0
86756: GO 86864
86758: LD_INT 2
86760: DOUBLE
86761: EQUAL
86762: IFTRUE 86766
86764: GO 86773
86766: POP
// hHackSetLevel10 ; 3 :
86767: CALL 99095 0 0
86771: GO 86864
86773: LD_INT 3
86775: DOUBLE
86776: EQUAL
86777: IFTRUE 86781
86779: GO 86788
86781: POP
// hHackSetLevel10YourUnits ; 4 :
86782: CALL 99180 0 0
86786: GO 86864
86788: LD_INT 4
86790: DOUBLE
86791: EQUAL
86792: IFTRUE 86796
86794: GO 86803
86796: POP
// hHackInvincible ; 5 :
86797: CALL 99628 0 0
86801: GO 86864
86803: LD_INT 5
86805: DOUBLE
86806: EQUAL
86807: IFTRUE 86811
86809: GO 86818
86811: POP
// hHackInvisible ; 6 :
86812: CALL 99739 0 0
86816: GO 86864
86818: LD_INT 6
86820: DOUBLE
86821: EQUAL
86822: IFTRUE 86826
86824: GO 86833
86826: POP
// hHackChangeYourSide ; 7 :
86827: CALL 99796 0 0
86831: GO 86864
86833: LD_INT 7
86835: DOUBLE
86836: EQUAL
86837: IFTRUE 86841
86839: GO 86848
86841: POP
// hHackChangeUnitSide ; 8 :
86842: CALL 99838 0 0
86846: GO 86864
86848: LD_INT 8
86850: DOUBLE
86851: EQUAL
86852: IFTRUE 86856
86854: GO 86863
86856: POP
// hHackFog ; end ;
86857: CALL 99939 0 0
86861: GO 86864
86863: POP
// end ; end ;
86864: LD_VAR 0 7
86868: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
86869: GO 86871
86871: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
86872: LD_STRING initStreamRollete();
86874: PPUSH
86875: CALL_OW 559
// InitStreamMode ;
86879: CALL 86891 0 0
// DefineStreamItems ( false ) ;
86883: LD_INT 0
86885: PPUSH
86886: CALL 87355 0 1
// end ;
86890: END
// function InitStreamMode ; begin
86891: LD_INT 0
86893: PPUSH
// streamModeActive := false ;
86894: LD_ADDR_EXP 123
86898: PUSH
86899: LD_INT 0
86901: ST_TO_ADDR
// normalCounter := 36 ;
86902: LD_ADDR_EXP 124
86906: PUSH
86907: LD_INT 36
86909: ST_TO_ADDR
// hardcoreCounter := 18 ;
86910: LD_ADDR_EXP 125
86914: PUSH
86915: LD_INT 18
86917: ST_TO_ADDR
// sRocket := false ;
86918: LD_ADDR_EXP 128
86922: PUSH
86923: LD_INT 0
86925: ST_TO_ADDR
// sSpeed := false ;
86926: LD_ADDR_EXP 127
86930: PUSH
86931: LD_INT 0
86933: ST_TO_ADDR
// sEngine := false ;
86934: LD_ADDR_EXP 129
86938: PUSH
86939: LD_INT 0
86941: ST_TO_ADDR
// sSpec := false ;
86942: LD_ADDR_EXP 126
86946: PUSH
86947: LD_INT 0
86949: ST_TO_ADDR
// sLevel := false ;
86950: LD_ADDR_EXP 130
86954: PUSH
86955: LD_INT 0
86957: ST_TO_ADDR
// sArmoury := false ;
86958: LD_ADDR_EXP 131
86962: PUSH
86963: LD_INT 0
86965: ST_TO_ADDR
// sRadar := false ;
86966: LD_ADDR_EXP 132
86970: PUSH
86971: LD_INT 0
86973: ST_TO_ADDR
// sBunker := false ;
86974: LD_ADDR_EXP 133
86978: PUSH
86979: LD_INT 0
86981: ST_TO_ADDR
// sHack := false ;
86982: LD_ADDR_EXP 134
86986: PUSH
86987: LD_INT 0
86989: ST_TO_ADDR
// sFire := false ;
86990: LD_ADDR_EXP 135
86994: PUSH
86995: LD_INT 0
86997: ST_TO_ADDR
// sRefresh := false ;
86998: LD_ADDR_EXP 136
87002: PUSH
87003: LD_INT 0
87005: ST_TO_ADDR
// sExp := false ;
87006: LD_ADDR_EXP 137
87010: PUSH
87011: LD_INT 0
87013: ST_TO_ADDR
// sDepot := false ;
87014: LD_ADDR_EXP 138
87018: PUSH
87019: LD_INT 0
87021: ST_TO_ADDR
// sFlag := false ;
87022: LD_ADDR_EXP 139
87026: PUSH
87027: LD_INT 0
87029: ST_TO_ADDR
// sKamikadze := false ;
87030: LD_ADDR_EXP 147
87034: PUSH
87035: LD_INT 0
87037: ST_TO_ADDR
// sTroll := false ;
87038: LD_ADDR_EXP 148
87042: PUSH
87043: LD_INT 0
87045: ST_TO_ADDR
// sSlow := false ;
87046: LD_ADDR_EXP 149
87050: PUSH
87051: LD_INT 0
87053: ST_TO_ADDR
// sLack := false ;
87054: LD_ADDR_EXP 150
87058: PUSH
87059: LD_INT 0
87061: ST_TO_ADDR
// sTank := false ;
87062: LD_ADDR_EXP 152
87066: PUSH
87067: LD_INT 0
87069: ST_TO_ADDR
// sRemote := false ;
87070: LD_ADDR_EXP 153
87074: PUSH
87075: LD_INT 0
87077: ST_TO_ADDR
// sPowell := false ;
87078: LD_ADDR_EXP 154
87082: PUSH
87083: LD_INT 0
87085: ST_TO_ADDR
// sTeleport := false ;
87086: LD_ADDR_EXP 157
87090: PUSH
87091: LD_INT 0
87093: ST_TO_ADDR
// sOilTower := false ;
87094: LD_ADDR_EXP 159
87098: PUSH
87099: LD_INT 0
87101: ST_TO_ADDR
// sShovel := false ;
87102: LD_ADDR_EXP 160
87106: PUSH
87107: LD_INT 0
87109: ST_TO_ADDR
// sSheik := false ;
87110: LD_ADDR_EXP 161
87114: PUSH
87115: LD_INT 0
87117: ST_TO_ADDR
// sEarthquake := false ;
87118: LD_ADDR_EXP 163
87122: PUSH
87123: LD_INT 0
87125: ST_TO_ADDR
// sAI := false ;
87126: LD_ADDR_EXP 164
87130: PUSH
87131: LD_INT 0
87133: ST_TO_ADDR
// sCargo := false ;
87134: LD_ADDR_EXP 167
87138: PUSH
87139: LD_INT 0
87141: ST_TO_ADDR
// sDLaser := false ;
87142: LD_ADDR_EXP 168
87146: PUSH
87147: LD_INT 0
87149: ST_TO_ADDR
// sExchange := false ;
87150: LD_ADDR_EXP 169
87154: PUSH
87155: LD_INT 0
87157: ST_TO_ADDR
// sFac := false ;
87158: LD_ADDR_EXP 170
87162: PUSH
87163: LD_INT 0
87165: ST_TO_ADDR
// sPower := false ;
87166: LD_ADDR_EXP 171
87170: PUSH
87171: LD_INT 0
87173: ST_TO_ADDR
// sRandom := false ;
87174: LD_ADDR_EXP 172
87178: PUSH
87179: LD_INT 0
87181: ST_TO_ADDR
// sShield := false ;
87182: LD_ADDR_EXP 173
87186: PUSH
87187: LD_INT 0
87189: ST_TO_ADDR
// sTime := false ;
87190: LD_ADDR_EXP 174
87194: PUSH
87195: LD_INT 0
87197: ST_TO_ADDR
// sTools := false ;
87198: LD_ADDR_EXP 175
87202: PUSH
87203: LD_INT 0
87205: ST_TO_ADDR
// sSold := false ;
87206: LD_ADDR_EXP 140
87210: PUSH
87211: LD_INT 0
87213: ST_TO_ADDR
// sDiff := false ;
87214: LD_ADDR_EXP 141
87218: PUSH
87219: LD_INT 0
87221: ST_TO_ADDR
// sFog := false ;
87222: LD_ADDR_EXP 144
87226: PUSH
87227: LD_INT 0
87229: ST_TO_ADDR
// sReset := false ;
87230: LD_ADDR_EXP 145
87234: PUSH
87235: LD_INT 0
87237: ST_TO_ADDR
// sSun := false ;
87238: LD_ADDR_EXP 146
87242: PUSH
87243: LD_INT 0
87245: ST_TO_ADDR
// sTiger := false ;
87246: LD_ADDR_EXP 142
87250: PUSH
87251: LD_INT 0
87253: ST_TO_ADDR
// sBomb := false ;
87254: LD_ADDR_EXP 143
87258: PUSH
87259: LD_INT 0
87261: ST_TO_ADDR
// sWound := false ;
87262: LD_ADDR_EXP 151
87266: PUSH
87267: LD_INT 0
87269: ST_TO_ADDR
// sBetray := false ;
87270: LD_ADDR_EXP 155
87274: PUSH
87275: LD_INT 0
87277: ST_TO_ADDR
// sContamin := false ;
87278: LD_ADDR_EXP 156
87282: PUSH
87283: LD_INT 0
87285: ST_TO_ADDR
// sOil := false ;
87286: LD_ADDR_EXP 158
87290: PUSH
87291: LD_INT 0
87293: ST_TO_ADDR
// sStu := false ;
87294: LD_ADDR_EXP 162
87298: PUSH
87299: LD_INT 0
87301: ST_TO_ADDR
// sBazooka := false ;
87302: LD_ADDR_EXP 165
87306: PUSH
87307: LD_INT 0
87309: ST_TO_ADDR
// sMortar := false ;
87310: LD_ADDR_EXP 166
87314: PUSH
87315: LD_INT 0
87317: ST_TO_ADDR
// sRanger := false ;
87318: LD_ADDR_EXP 176
87322: PUSH
87323: LD_INT 0
87325: ST_TO_ADDR
// sComputer := false ;
87326: LD_ADDR_EXP 177
87330: PUSH
87331: LD_INT 0
87333: ST_TO_ADDR
// s30 := false ;
87334: LD_ADDR_EXP 178
87338: PUSH
87339: LD_INT 0
87341: ST_TO_ADDR
// s60 := false ;
87342: LD_ADDR_EXP 179
87346: PUSH
87347: LD_INT 0
87349: ST_TO_ADDR
// end ;
87350: LD_VAR 0 1
87354: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
87355: LD_INT 0
87357: PPUSH
87358: PPUSH
87359: PPUSH
87360: PPUSH
87361: PPUSH
87362: PPUSH
87363: PPUSH
// result := [ ] ;
87364: LD_ADDR_VAR 0 2
87368: PUSH
87369: EMPTY
87370: ST_TO_ADDR
// if campaign_id = 1 then
87371: LD_OWVAR 69
87375: PUSH
87376: LD_INT 1
87378: EQUAL
87379: IFFALSE 90545
// begin case mission_number of 1 :
87381: LD_OWVAR 70
87385: PUSH
87386: LD_INT 1
87388: DOUBLE
87389: EQUAL
87390: IFTRUE 87394
87392: GO 87470
87394: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
87395: LD_ADDR_VAR 0 2
87399: PUSH
87400: LD_INT 2
87402: PUSH
87403: LD_INT 4
87405: PUSH
87406: LD_INT 11
87408: PUSH
87409: LD_INT 12
87411: PUSH
87412: LD_INT 15
87414: PUSH
87415: LD_INT 16
87417: PUSH
87418: LD_INT 22
87420: PUSH
87421: LD_INT 23
87423: PUSH
87424: LD_INT 26
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: LIST
87431: LIST
87432: LIST
87433: LIST
87434: LIST
87435: LIST
87436: LIST
87437: PUSH
87438: LD_INT 101
87440: PUSH
87441: LD_INT 102
87443: PUSH
87444: LD_INT 106
87446: PUSH
87447: LD_INT 116
87449: PUSH
87450: LD_INT 117
87452: PUSH
87453: LD_INT 118
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: PUSH
87464: EMPTY
87465: LIST
87466: LIST
87467: ST_TO_ADDR
87468: GO 90543
87470: LD_INT 2
87472: DOUBLE
87473: EQUAL
87474: IFTRUE 87478
87476: GO 87562
87478: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
87479: LD_ADDR_VAR 0 2
87483: PUSH
87484: LD_INT 2
87486: PUSH
87487: LD_INT 4
87489: PUSH
87490: LD_INT 11
87492: PUSH
87493: LD_INT 12
87495: PUSH
87496: LD_INT 15
87498: PUSH
87499: LD_INT 16
87501: PUSH
87502: LD_INT 22
87504: PUSH
87505: LD_INT 23
87507: PUSH
87508: LD_INT 26
87510: PUSH
87511: EMPTY
87512: LIST
87513: LIST
87514: LIST
87515: LIST
87516: LIST
87517: LIST
87518: LIST
87519: LIST
87520: LIST
87521: PUSH
87522: LD_INT 101
87524: PUSH
87525: LD_INT 102
87527: PUSH
87528: LD_INT 105
87530: PUSH
87531: LD_INT 106
87533: PUSH
87534: LD_INT 108
87536: PUSH
87537: LD_INT 116
87539: PUSH
87540: LD_INT 117
87542: PUSH
87543: LD_INT 118
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: LIST
87550: LIST
87551: LIST
87552: LIST
87553: LIST
87554: LIST
87555: PUSH
87556: EMPTY
87557: LIST
87558: LIST
87559: ST_TO_ADDR
87560: GO 90543
87562: LD_INT 3
87564: DOUBLE
87565: EQUAL
87566: IFTRUE 87570
87568: GO 87658
87570: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
87571: LD_ADDR_VAR 0 2
87575: PUSH
87576: LD_INT 2
87578: PUSH
87579: LD_INT 4
87581: PUSH
87582: LD_INT 5
87584: PUSH
87585: LD_INT 11
87587: PUSH
87588: LD_INT 12
87590: PUSH
87591: LD_INT 15
87593: PUSH
87594: LD_INT 16
87596: PUSH
87597: LD_INT 22
87599: PUSH
87600: LD_INT 26
87602: PUSH
87603: LD_INT 36
87605: PUSH
87606: EMPTY
87607: LIST
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: LIST
87617: PUSH
87618: LD_INT 101
87620: PUSH
87621: LD_INT 102
87623: PUSH
87624: LD_INT 105
87626: PUSH
87627: LD_INT 106
87629: PUSH
87630: LD_INT 108
87632: PUSH
87633: LD_INT 116
87635: PUSH
87636: LD_INT 117
87638: PUSH
87639: LD_INT 118
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: LIST
87646: LIST
87647: LIST
87648: LIST
87649: LIST
87650: LIST
87651: PUSH
87652: EMPTY
87653: LIST
87654: LIST
87655: ST_TO_ADDR
87656: GO 90543
87658: LD_INT 4
87660: DOUBLE
87661: EQUAL
87662: IFTRUE 87666
87664: GO 87762
87666: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
87667: LD_ADDR_VAR 0 2
87671: PUSH
87672: LD_INT 2
87674: PUSH
87675: LD_INT 4
87677: PUSH
87678: LD_INT 5
87680: PUSH
87681: LD_INT 8
87683: PUSH
87684: LD_INT 11
87686: PUSH
87687: LD_INT 12
87689: PUSH
87690: LD_INT 15
87692: PUSH
87693: LD_INT 16
87695: PUSH
87696: LD_INT 22
87698: PUSH
87699: LD_INT 23
87701: PUSH
87702: LD_INT 26
87704: PUSH
87705: LD_INT 36
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: LIST
87712: LIST
87713: LIST
87714: LIST
87715: LIST
87716: LIST
87717: LIST
87718: LIST
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 101
87724: PUSH
87725: LD_INT 102
87727: PUSH
87728: LD_INT 105
87730: PUSH
87731: LD_INT 106
87733: PUSH
87734: LD_INT 108
87736: PUSH
87737: LD_INT 116
87739: PUSH
87740: LD_INT 117
87742: PUSH
87743: LD_INT 118
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: PUSH
87756: EMPTY
87757: LIST
87758: LIST
87759: ST_TO_ADDR
87760: GO 90543
87762: LD_INT 5
87764: DOUBLE
87765: EQUAL
87766: IFTRUE 87770
87768: GO 87882
87770: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
87771: LD_ADDR_VAR 0 2
87775: PUSH
87776: LD_INT 2
87778: PUSH
87779: LD_INT 4
87781: PUSH
87782: LD_INT 5
87784: PUSH
87785: LD_INT 6
87787: PUSH
87788: LD_INT 8
87790: PUSH
87791: LD_INT 11
87793: PUSH
87794: LD_INT 12
87796: PUSH
87797: LD_INT 15
87799: PUSH
87800: LD_INT 16
87802: PUSH
87803: LD_INT 22
87805: PUSH
87806: LD_INT 23
87808: PUSH
87809: LD_INT 25
87811: PUSH
87812: LD_INT 26
87814: PUSH
87815: LD_INT 36
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: PUSH
87834: LD_INT 101
87836: PUSH
87837: LD_INT 102
87839: PUSH
87840: LD_INT 105
87842: PUSH
87843: LD_INT 106
87845: PUSH
87846: LD_INT 108
87848: PUSH
87849: LD_INT 109
87851: PUSH
87852: LD_INT 112
87854: PUSH
87855: LD_INT 116
87857: PUSH
87858: LD_INT 117
87860: PUSH
87861: LD_INT 118
87863: PUSH
87864: EMPTY
87865: LIST
87866: LIST
87867: LIST
87868: LIST
87869: LIST
87870: LIST
87871: LIST
87872: LIST
87873: LIST
87874: LIST
87875: PUSH
87876: EMPTY
87877: LIST
87878: LIST
87879: ST_TO_ADDR
87880: GO 90543
87882: LD_INT 6
87884: DOUBLE
87885: EQUAL
87886: IFTRUE 87890
87888: GO 88022
87890: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
87891: LD_ADDR_VAR 0 2
87895: PUSH
87896: LD_INT 2
87898: PUSH
87899: LD_INT 4
87901: PUSH
87902: LD_INT 5
87904: PUSH
87905: LD_INT 6
87907: PUSH
87908: LD_INT 8
87910: PUSH
87911: LD_INT 11
87913: PUSH
87914: LD_INT 12
87916: PUSH
87917: LD_INT 15
87919: PUSH
87920: LD_INT 16
87922: PUSH
87923: LD_INT 20
87925: PUSH
87926: LD_INT 21
87928: PUSH
87929: LD_INT 22
87931: PUSH
87932: LD_INT 23
87934: PUSH
87935: LD_INT 25
87937: PUSH
87938: LD_INT 26
87940: PUSH
87941: LD_INT 30
87943: PUSH
87944: LD_INT 31
87946: PUSH
87947: LD_INT 32
87949: PUSH
87950: LD_INT 36
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: LIST
87962: LIST
87963: LIST
87964: LIST
87965: LIST
87966: LIST
87967: LIST
87968: LIST
87969: LIST
87970: LIST
87971: LIST
87972: LIST
87973: PUSH
87974: LD_INT 101
87976: PUSH
87977: LD_INT 102
87979: PUSH
87980: LD_INT 105
87982: PUSH
87983: LD_INT 106
87985: PUSH
87986: LD_INT 108
87988: PUSH
87989: LD_INT 109
87991: PUSH
87992: LD_INT 112
87994: PUSH
87995: LD_INT 116
87997: PUSH
87998: LD_INT 117
88000: PUSH
88001: LD_INT 118
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: ST_TO_ADDR
88020: GO 90543
88022: LD_INT 7
88024: DOUBLE
88025: EQUAL
88026: IFTRUE 88030
88028: GO 88142
88030: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
88031: LD_ADDR_VAR 0 2
88035: PUSH
88036: LD_INT 2
88038: PUSH
88039: LD_INT 4
88041: PUSH
88042: LD_INT 5
88044: PUSH
88045: LD_INT 7
88047: PUSH
88048: LD_INT 11
88050: PUSH
88051: LD_INT 12
88053: PUSH
88054: LD_INT 15
88056: PUSH
88057: LD_INT 16
88059: PUSH
88060: LD_INT 20
88062: PUSH
88063: LD_INT 21
88065: PUSH
88066: LD_INT 22
88068: PUSH
88069: LD_INT 23
88071: PUSH
88072: LD_INT 25
88074: PUSH
88075: LD_INT 26
88077: PUSH
88078: EMPTY
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: PUSH
88094: LD_INT 101
88096: PUSH
88097: LD_INT 102
88099: PUSH
88100: LD_INT 103
88102: PUSH
88103: LD_INT 105
88105: PUSH
88106: LD_INT 106
88108: PUSH
88109: LD_INT 108
88111: PUSH
88112: LD_INT 112
88114: PUSH
88115: LD_INT 116
88117: PUSH
88118: LD_INT 117
88120: PUSH
88121: LD_INT 118
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: ST_TO_ADDR
88140: GO 90543
88142: LD_INT 8
88144: DOUBLE
88145: EQUAL
88146: IFTRUE 88150
88148: GO 88290
88150: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
88151: LD_ADDR_VAR 0 2
88155: PUSH
88156: LD_INT 2
88158: PUSH
88159: LD_INT 4
88161: PUSH
88162: LD_INT 5
88164: PUSH
88165: LD_INT 6
88167: PUSH
88168: LD_INT 7
88170: PUSH
88171: LD_INT 8
88173: PUSH
88174: LD_INT 11
88176: PUSH
88177: LD_INT 12
88179: PUSH
88180: LD_INT 15
88182: PUSH
88183: LD_INT 16
88185: PUSH
88186: LD_INT 20
88188: PUSH
88189: LD_INT 21
88191: PUSH
88192: LD_INT 22
88194: PUSH
88195: LD_INT 23
88197: PUSH
88198: LD_INT 25
88200: PUSH
88201: LD_INT 26
88203: PUSH
88204: LD_INT 30
88206: PUSH
88207: LD_INT 31
88209: PUSH
88210: LD_INT 32
88212: PUSH
88213: LD_INT 36
88215: PUSH
88216: EMPTY
88217: LIST
88218: LIST
88219: LIST
88220: LIST
88221: LIST
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: LIST
88233: LIST
88234: LIST
88235: LIST
88236: LIST
88237: PUSH
88238: LD_INT 101
88240: PUSH
88241: LD_INT 102
88243: PUSH
88244: LD_INT 103
88246: PUSH
88247: LD_INT 105
88249: PUSH
88250: LD_INT 106
88252: PUSH
88253: LD_INT 108
88255: PUSH
88256: LD_INT 109
88258: PUSH
88259: LD_INT 112
88261: PUSH
88262: LD_INT 116
88264: PUSH
88265: LD_INT 117
88267: PUSH
88268: LD_INT 118
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: PUSH
88284: EMPTY
88285: LIST
88286: LIST
88287: ST_TO_ADDR
88288: GO 90543
88290: LD_INT 9
88292: DOUBLE
88293: EQUAL
88294: IFTRUE 88298
88296: GO 88446
88298: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
88299: LD_ADDR_VAR 0 2
88303: PUSH
88304: LD_INT 2
88306: PUSH
88307: LD_INT 4
88309: PUSH
88310: LD_INT 5
88312: PUSH
88313: LD_INT 6
88315: PUSH
88316: LD_INT 7
88318: PUSH
88319: LD_INT 8
88321: PUSH
88322: LD_INT 11
88324: PUSH
88325: LD_INT 12
88327: PUSH
88328: LD_INT 15
88330: PUSH
88331: LD_INT 16
88333: PUSH
88334: LD_INT 20
88336: PUSH
88337: LD_INT 21
88339: PUSH
88340: LD_INT 22
88342: PUSH
88343: LD_INT 23
88345: PUSH
88346: LD_INT 25
88348: PUSH
88349: LD_INT 26
88351: PUSH
88352: LD_INT 28
88354: PUSH
88355: LD_INT 30
88357: PUSH
88358: LD_INT 31
88360: PUSH
88361: LD_INT 32
88363: PUSH
88364: LD_INT 36
88366: PUSH
88367: EMPTY
88368: LIST
88369: LIST
88370: LIST
88371: LIST
88372: LIST
88373: LIST
88374: LIST
88375: LIST
88376: LIST
88377: LIST
88378: LIST
88379: LIST
88380: LIST
88381: LIST
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: PUSH
88390: LD_INT 101
88392: PUSH
88393: LD_INT 102
88395: PUSH
88396: LD_INT 103
88398: PUSH
88399: LD_INT 105
88401: PUSH
88402: LD_INT 106
88404: PUSH
88405: LD_INT 108
88407: PUSH
88408: LD_INT 109
88410: PUSH
88411: LD_INT 112
88413: PUSH
88414: LD_INT 114
88416: PUSH
88417: LD_INT 116
88419: PUSH
88420: LD_INT 117
88422: PUSH
88423: LD_INT 118
88425: PUSH
88426: EMPTY
88427: LIST
88428: LIST
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: LIST
88434: LIST
88435: LIST
88436: LIST
88437: LIST
88438: LIST
88439: PUSH
88440: EMPTY
88441: LIST
88442: LIST
88443: ST_TO_ADDR
88444: GO 90543
88446: LD_INT 10
88448: DOUBLE
88449: EQUAL
88450: IFTRUE 88454
88452: GO 88650
88454: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
88455: LD_ADDR_VAR 0 2
88459: PUSH
88460: LD_INT 2
88462: PUSH
88463: LD_INT 4
88465: PUSH
88466: LD_INT 5
88468: PUSH
88469: LD_INT 6
88471: PUSH
88472: LD_INT 7
88474: PUSH
88475: LD_INT 8
88477: PUSH
88478: LD_INT 9
88480: PUSH
88481: LD_INT 10
88483: PUSH
88484: LD_INT 11
88486: PUSH
88487: LD_INT 12
88489: PUSH
88490: LD_INT 13
88492: PUSH
88493: LD_INT 14
88495: PUSH
88496: LD_INT 15
88498: PUSH
88499: LD_INT 16
88501: PUSH
88502: LD_INT 17
88504: PUSH
88505: LD_INT 18
88507: PUSH
88508: LD_INT 19
88510: PUSH
88511: LD_INT 20
88513: PUSH
88514: LD_INT 21
88516: PUSH
88517: LD_INT 22
88519: PUSH
88520: LD_INT 23
88522: PUSH
88523: LD_INT 24
88525: PUSH
88526: LD_INT 25
88528: PUSH
88529: LD_INT 26
88531: PUSH
88532: LD_INT 28
88534: PUSH
88535: LD_INT 30
88537: PUSH
88538: LD_INT 31
88540: PUSH
88541: LD_INT 32
88543: PUSH
88544: LD_INT 36
88546: PUSH
88547: EMPTY
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: PUSH
88578: LD_INT 101
88580: PUSH
88581: LD_INT 102
88583: PUSH
88584: LD_INT 103
88586: PUSH
88587: LD_INT 104
88589: PUSH
88590: LD_INT 105
88592: PUSH
88593: LD_INT 106
88595: PUSH
88596: LD_INT 107
88598: PUSH
88599: LD_INT 108
88601: PUSH
88602: LD_INT 109
88604: PUSH
88605: LD_INT 110
88607: PUSH
88608: LD_INT 111
88610: PUSH
88611: LD_INT 112
88613: PUSH
88614: LD_INT 114
88616: PUSH
88617: LD_INT 116
88619: PUSH
88620: LD_INT 117
88622: PUSH
88623: LD_INT 118
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: LIST
88630: LIST
88631: LIST
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: PUSH
88644: EMPTY
88645: LIST
88646: LIST
88647: ST_TO_ADDR
88648: GO 90543
88650: LD_INT 11
88652: DOUBLE
88653: EQUAL
88654: IFTRUE 88658
88656: GO 88862
88658: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
88659: LD_ADDR_VAR 0 2
88663: PUSH
88664: LD_INT 2
88666: PUSH
88667: LD_INT 3
88669: PUSH
88670: LD_INT 4
88672: PUSH
88673: LD_INT 5
88675: PUSH
88676: LD_INT 6
88678: PUSH
88679: LD_INT 7
88681: PUSH
88682: LD_INT 8
88684: PUSH
88685: LD_INT 9
88687: PUSH
88688: LD_INT 10
88690: PUSH
88691: LD_INT 11
88693: PUSH
88694: LD_INT 12
88696: PUSH
88697: LD_INT 13
88699: PUSH
88700: LD_INT 14
88702: PUSH
88703: LD_INT 15
88705: PUSH
88706: LD_INT 16
88708: PUSH
88709: LD_INT 17
88711: PUSH
88712: LD_INT 18
88714: PUSH
88715: LD_INT 19
88717: PUSH
88718: LD_INT 20
88720: PUSH
88721: LD_INT 21
88723: PUSH
88724: LD_INT 22
88726: PUSH
88727: LD_INT 23
88729: PUSH
88730: LD_INT 24
88732: PUSH
88733: LD_INT 25
88735: PUSH
88736: LD_INT 26
88738: PUSH
88739: LD_INT 28
88741: PUSH
88742: LD_INT 30
88744: PUSH
88745: LD_INT 31
88747: PUSH
88748: LD_INT 32
88750: PUSH
88751: LD_INT 34
88753: PUSH
88754: LD_INT 36
88756: PUSH
88757: EMPTY
88758: LIST
88759: LIST
88760: LIST
88761: LIST
88762: LIST
88763: LIST
88764: LIST
88765: LIST
88766: LIST
88767: LIST
88768: LIST
88769: LIST
88770: LIST
88771: LIST
88772: LIST
88773: LIST
88774: LIST
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: PUSH
88790: LD_INT 101
88792: PUSH
88793: LD_INT 102
88795: PUSH
88796: LD_INT 103
88798: PUSH
88799: LD_INT 104
88801: PUSH
88802: LD_INT 105
88804: PUSH
88805: LD_INT 106
88807: PUSH
88808: LD_INT 107
88810: PUSH
88811: LD_INT 108
88813: PUSH
88814: LD_INT 109
88816: PUSH
88817: LD_INT 110
88819: PUSH
88820: LD_INT 111
88822: PUSH
88823: LD_INT 112
88825: PUSH
88826: LD_INT 114
88828: PUSH
88829: LD_INT 116
88831: PUSH
88832: LD_INT 117
88834: PUSH
88835: LD_INT 118
88837: PUSH
88838: EMPTY
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: ST_TO_ADDR
88860: GO 90543
88862: LD_INT 12
88864: DOUBLE
88865: EQUAL
88866: IFTRUE 88870
88868: GO 89090
88870: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
88871: LD_ADDR_VAR 0 2
88875: PUSH
88876: LD_INT 1
88878: PUSH
88879: LD_INT 2
88881: PUSH
88882: LD_INT 3
88884: PUSH
88885: LD_INT 4
88887: PUSH
88888: LD_INT 5
88890: PUSH
88891: LD_INT 6
88893: PUSH
88894: LD_INT 7
88896: PUSH
88897: LD_INT 8
88899: PUSH
88900: LD_INT 9
88902: PUSH
88903: LD_INT 10
88905: PUSH
88906: LD_INT 11
88908: PUSH
88909: LD_INT 12
88911: PUSH
88912: LD_INT 13
88914: PUSH
88915: LD_INT 14
88917: PUSH
88918: LD_INT 15
88920: PUSH
88921: LD_INT 16
88923: PUSH
88924: LD_INT 17
88926: PUSH
88927: LD_INT 18
88929: PUSH
88930: LD_INT 19
88932: PUSH
88933: LD_INT 20
88935: PUSH
88936: LD_INT 21
88938: PUSH
88939: LD_INT 22
88941: PUSH
88942: LD_INT 23
88944: PUSH
88945: LD_INT 24
88947: PUSH
88948: LD_INT 25
88950: PUSH
88951: LD_INT 26
88953: PUSH
88954: LD_INT 27
88956: PUSH
88957: LD_INT 28
88959: PUSH
88960: LD_INT 30
88962: PUSH
88963: LD_INT 31
88965: PUSH
88966: LD_INT 32
88968: PUSH
88969: LD_INT 33
88971: PUSH
88972: LD_INT 34
88974: PUSH
88975: LD_INT 36
88977: PUSH
88978: EMPTY
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: LIST
89009: LIST
89010: LIST
89011: LIST
89012: LIST
89013: PUSH
89014: LD_INT 101
89016: PUSH
89017: LD_INT 102
89019: PUSH
89020: LD_INT 103
89022: PUSH
89023: LD_INT 104
89025: PUSH
89026: LD_INT 105
89028: PUSH
89029: LD_INT 106
89031: PUSH
89032: LD_INT 107
89034: PUSH
89035: LD_INT 108
89037: PUSH
89038: LD_INT 109
89040: PUSH
89041: LD_INT 110
89043: PUSH
89044: LD_INT 111
89046: PUSH
89047: LD_INT 112
89049: PUSH
89050: LD_INT 113
89052: PUSH
89053: LD_INT 114
89055: PUSH
89056: LD_INT 116
89058: PUSH
89059: LD_INT 117
89061: PUSH
89062: LD_INT 118
89064: PUSH
89065: EMPTY
89066: LIST
89067: LIST
89068: LIST
89069: LIST
89070: LIST
89071: LIST
89072: LIST
89073: LIST
89074: LIST
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: ST_TO_ADDR
89088: GO 90543
89090: LD_INT 13
89092: DOUBLE
89093: EQUAL
89094: IFTRUE 89098
89096: GO 89306
89098: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
89099: LD_ADDR_VAR 0 2
89103: PUSH
89104: LD_INT 1
89106: PUSH
89107: LD_INT 2
89109: PUSH
89110: LD_INT 3
89112: PUSH
89113: LD_INT 4
89115: PUSH
89116: LD_INT 5
89118: PUSH
89119: LD_INT 8
89121: PUSH
89122: LD_INT 9
89124: PUSH
89125: LD_INT 10
89127: PUSH
89128: LD_INT 11
89130: PUSH
89131: LD_INT 12
89133: PUSH
89134: LD_INT 14
89136: PUSH
89137: LD_INT 15
89139: PUSH
89140: LD_INT 16
89142: PUSH
89143: LD_INT 17
89145: PUSH
89146: LD_INT 18
89148: PUSH
89149: LD_INT 19
89151: PUSH
89152: LD_INT 20
89154: PUSH
89155: LD_INT 21
89157: PUSH
89158: LD_INT 22
89160: PUSH
89161: LD_INT 23
89163: PUSH
89164: LD_INT 24
89166: PUSH
89167: LD_INT 25
89169: PUSH
89170: LD_INT 26
89172: PUSH
89173: LD_INT 27
89175: PUSH
89176: LD_INT 28
89178: PUSH
89179: LD_INT 30
89181: PUSH
89182: LD_INT 31
89184: PUSH
89185: LD_INT 32
89187: PUSH
89188: LD_INT 33
89190: PUSH
89191: LD_INT 34
89193: PUSH
89194: LD_INT 36
89196: PUSH
89197: EMPTY
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 101
89232: PUSH
89233: LD_INT 102
89235: PUSH
89236: LD_INT 103
89238: PUSH
89239: LD_INT 104
89241: PUSH
89242: LD_INT 105
89244: PUSH
89245: LD_INT 106
89247: PUSH
89248: LD_INT 107
89250: PUSH
89251: LD_INT 108
89253: PUSH
89254: LD_INT 109
89256: PUSH
89257: LD_INT 110
89259: PUSH
89260: LD_INT 111
89262: PUSH
89263: LD_INT 112
89265: PUSH
89266: LD_INT 113
89268: PUSH
89269: LD_INT 114
89271: PUSH
89272: LD_INT 116
89274: PUSH
89275: LD_INT 117
89277: PUSH
89278: LD_INT 118
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: PUSH
89300: EMPTY
89301: LIST
89302: LIST
89303: ST_TO_ADDR
89304: GO 90543
89306: LD_INT 14
89308: DOUBLE
89309: EQUAL
89310: IFTRUE 89314
89312: GO 89538
89314: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
89315: LD_ADDR_VAR 0 2
89319: PUSH
89320: LD_INT 1
89322: PUSH
89323: LD_INT 2
89325: PUSH
89326: LD_INT 3
89328: PUSH
89329: LD_INT 4
89331: PUSH
89332: LD_INT 5
89334: PUSH
89335: LD_INT 6
89337: PUSH
89338: LD_INT 7
89340: PUSH
89341: LD_INT 8
89343: PUSH
89344: LD_INT 9
89346: PUSH
89347: LD_INT 10
89349: PUSH
89350: LD_INT 11
89352: PUSH
89353: LD_INT 12
89355: PUSH
89356: LD_INT 13
89358: PUSH
89359: LD_INT 14
89361: PUSH
89362: LD_INT 15
89364: PUSH
89365: LD_INT 16
89367: PUSH
89368: LD_INT 17
89370: PUSH
89371: LD_INT 18
89373: PUSH
89374: LD_INT 19
89376: PUSH
89377: LD_INT 20
89379: PUSH
89380: LD_INT 21
89382: PUSH
89383: LD_INT 22
89385: PUSH
89386: LD_INT 23
89388: PUSH
89389: LD_INT 24
89391: PUSH
89392: LD_INT 25
89394: PUSH
89395: LD_INT 26
89397: PUSH
89398: LD_INT 27
89400: PUSH
89401: LD_INT 28
89403: PUSH
89404: LD_INT 29
89406: PUSH
89407: LD_INT 30
89409: PUSH
89410: LD_INT 31
89412: PUSH
89413: LD_INT 32
89415: PUSH
89416: LD_INT 33
89418: PUSH
89419: LD_INT 34
89421: PUSH
89422: LD_INT 36
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: LIST
89433: LIST
89434: LIST
89435: LIST
89436: LIST
89437: LIST
89438: LIST
89439: LIST
89440: LIST
89441: LIST
89442: LIST
89443: LIST
89444: LIST
89445: LIST
89446: LIST
89447: LIST
89448: LIST
89449: LIST
89450: LIST
89451: LIST
89452: LIST
89453: LIST
89454: LIST
89455: LIST
89456: LIST
89457: LIST
89458: LIST
89459: LIST
89460: LIST
89461: PUSH
89462: LD_INT 101
89464: PUSH
89465: LD_INT 102
89467: PUSH
89468: LD_INT 103
89470: PUSH
89471: LD_INT 104
89473: PUSH
89474: LD_INT 105
89476: PUSH
89477: LD_INT 106
89479: PUSH
89480: LD_INT 107
89482: PUSH
89483: LD_INT 108
89485: PUSH
89486: LD_INT 109
89488: PUSH
89489: LD_INT 110
89491: PUSH
89492: LD_INT 111
89494: PUSH
89495: LD_INT 112
89497: PUSH
89498: LD_INT 113
89500: PUSH
89501: LD_INT 114
89503: PUSH
89504: LD_INT 116
89506: PUSH
89507: LD_INT 117
89509: PUSH
89510: LD_INT 118
89512: PUSH
89513: EMPTY
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: PUSH
89532: EMPTY
89533: LIST
89534: LIST
89535: ST_TO_ADDR
89536: GO 90543
89538: LD_INT 15
89540: DOUBLE
89541: EQUAL
89542: IFTRUE 89546
89544: GO 89770
89546: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
89547: LD_ADDR_VAR 0 2
89551: PUSH
89552: LD_INT 1
89554: PUSH
89555: LD_INT 2
89557: PUSH
89558: LD_INT 3
89560: PUSH
89561: LD_INT 4
89563: PUSH
89564: LD_INT 5
89566: PUSH
89567: LD_INT 6
89569: PUSH
89570: LD_INT 7
89572: PUSH
89573: LD_INT 8
89575: PUSH
89576: LD_INT 9
89578: PUSH
89579: LD_INT 10
89581: PUSH
89582: LD_INT 11
89584: PUSH
89585: LD_INT 12
89587: PUSH
89588: LD_INT 13
89590: PUSH
89591: LD_INT 14
89593: PUSH
89594: LD_INT 15
89596: PUSH
89597: LD_INT 16
89599: PUSH
89600: LD_INT 17
89602: PUSH
89603: LD_INT 18
89605: PUSH
89606: LD_INT 19
89608: PUSH
89609: LD_INT 20
89611: PUSH
89612: LD_INT 21
89614: PUSH
89615: LD_INT 22
89617: PUSH
89618: LD_INT 23
89620: PUSH
89621: LD_INT 24
89623: PUSH
89624: LD_INT 25
89626: PUSH
89627: LD_INT 26
89629: PUSH
89630: LD_INT 27
89632: PUSH
89633: LD_INT 28
89635: PUSH
89636: LD_INT 29
89638: PUSH
89639: LD_INT 30
89641: PUSH
89642: LD_INT 31
89644: PUSH
89645: LD_INT 32
89647: PUSH
89648: LD_INT 33
89650: PUSH
89651: LD_INT 34
89653: PUSH
89654: LD_INT 36
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: LIST
89671: LIST
89672: LIST
89673: LIST
89674: LIST
89675: LIST
89676: LIST
89677: LIST
89678: LIST
89679: LIST
89680: LIST
89681: LIST
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: PUSH
89694: LD_INT 101
89696: PUSH
89697: LD_INT 102
89699: PUSH
89700: LD_INT 103
89702: PUSH
89703: LD_INT 104
89705: PUSH
89706: LD_INT 105
89708: PUSH
89709: LD_INT 106
89711: PUSH
89712: LD_INT 107
89714: PUSH
89715: LD_INT 108
89717: PUSH
89718: LD_INT 109
89720: PUSH
89721: LD_INT 110
89723: PUSH
89724: LD_INT 111
89726: PUSH
89727: LD_INT 112
89729: PUSH
89730: LD_INT 113
89732: PUSH
89733: LD_INT 114
89735: PUSH
89736: LD_INT 116
89738: PUSH
89739: LD_INT 117
89741: PUSH
89742: LD_INT 118
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: LIST
89749: LIST
89750: LIST
89751: LIST
89752: LIST
89753: LIST
89754: LIST
89755: LIST
89756: LIST
89757: LIST
89758: LIST
89759: LIST
89760: LIST
89761: LIST
89762: LIST
89763: PUSH
89764: EMPTY
89765: LIST
89766: LIST
89767: ST_TO_ADDR
89768: GO 90543
89770: LD_INT 16
89772: DOUBLE
89773: EQUAL
89774: IFTRUE 89778
89776: GO 89914
89778: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
89779: LD_ADDR_VAR 0 2
89783: PUSH
89784: LD_INT 2
89786: PUSH
89787: LD_INT 4
89789: PUSH
89790: LD_INT 5
89792: PUSH
89793: LD_INT 7
89795: PUSH
89796: LD_INT 11
89798: PUSH
89799: LD_INT 12
89801: PUSH
89802: LD_INT 15
89804: PUSH
89805: LD_INT 16
89807: PUSH
89808: LD_INT 20
89810: PUSH
89811: LD_INT 21
89813: PUSH
89814: LD_INT 22
89816: PUSH
89817: LD_INT 23
89819: PUSH
89820: LD_INT 25
89822: PUSH
89823: LD_INT 26
89825: PUSH
89826: LD_INT 30
89828: PUSH
89829: LD_INT 31
89831: PUSH
89832: LD_INT 32
89834: PUSH
89835: LD_INT 33
89837: PUSH
89838: LD_INT 34
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: LIST
89847: LIST
89848: LIST
89849: LIST
89850: LIST
89851: LIST
89852: LIST
89853: LIST
89854: LIST
89855: LIST
89856: LIST
89857: LIST
89858: LIST
89859: LIST
89860: LIST
89861: PUSH
89862: LD_INT 101
89864: PUSH
89865: LD_INT 102
89867: PUSH
89868: LD_INT 103
89870: PUSH
89871: LD_INT 106
89873: PUSH
89874: LD_INT 108
89876: PUSH
89877: LD_INT 112
89879: PUSH
89880: LD_INT 113
89882: PUSH
89883: LD_INT 114
89885: PUSH
89886: LD_INT 116
89888: PUSH
89889: LD_INT 117
89891: PUSH
89892: LD_INT 118
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: LIST
89899: LIST
89900: LIST
89901: LIST
89902: LIST
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: ST_TO_ADDR
89912: GO 90543
89914: LD_INT 17
89916: DOUBLE
89917: EQUAL
89918: IFTRUE 89922
89920: GO 90146
89922: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
89923: LD_ADDR_VAR 0 2
89927: PUSH
89928: LD_INT 1
89930: PUSH
89931: LD_INT 2
89933: PUSH
89934: LD_INT 3
89936: PUSH
89937: LD_INT 4
89939: PUSH
89940: LD_INT 5
89942: PUSH
89943: LD_INT 6
89945: PUSH
89946: LD_INT 7
89948: PUSH
89949: LD_INT 8
89951: PUSH
89952: LD_INT 9
89954: PUSH
89955: LD_INT 10
89957: PUSH
89958: LD_INT 11
89960: PUSH
89961: LD_INT 12
89963: PUSH
89964: LD_INT 13
89966: PUSH
89967: LD_INT 14
89969: PUSH
89970: LD_INT 15
89972: PUSH
89973: LD_INT 16
89975: PUSH
89976: LD_INT 17
89978: PUSH
89979: LD_INT 18
89981: PUSH
89982: LD_INT 19
89984: PUSH
89985: LD_INT 20
89987: PUSH
89988: LD_INT 21
89990: PUSH
89991: LD_INT 22
89993: PUSH
89994: LD_INT 23
89996: PUSH
89997: LD_INT 24
89999: PUSH
90000: LD_INT 25
90002: PUSH
90003: LD_INT 26
90005: PUSH
90006: LD_INT 27
90008: PUSH
90009: LD_INT 28
90011: PUSH
90012: LD_INT 29
90014: PUSH
90015: LD_INT 30
90017: PUSH
90018: LD_INT 31
90020: PUSH
90021: LD_INT 32
90023: PUSH
90024: LD_INT 33
90026: PUSH
90027: LD_INT 34
90029: PUSH
90030: LD_INT 36
90032: PUSH
90033: EMPTY
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: PUSH
90070: LD_INT 101
90072: PUSH
90073: LD_INT 102
90075: PUSH
90076: LD_INT 103
90078: PUSH
90079: LD_INT 104
90081: PUSH
90082: LD_INT 105
90084: PUSH
90085: LD_INT 106
90087: PUSH
90088: LD_INT 107
90090: PUSH
90091: LD_INT 108
90093: PUSH
90094: LD_INT 109
90096: PUSH
90097: LD_INT 110
90099: PUSH
90100: LD_INT 111
90102: PUSH
90103: LD_INT 112
90105: PUSH
90106: LD_INT 113
90108: PUSH
90109: LD_INT 114
90111: PUSH
90112: LD_INT 116
90114: PUSH
90115: LD_INT 117
90117: PUSH
90118: LD_INT 118
90120: PUSH
90121: EMPTY
90122: LIST
90123: LIST
90124: LIST
90125: LIST
90126: LIST
90127: LIST
90128: LIST
90129: LIST
90130: LIST
90131: LIST
90132: LIST
90133: LIST
90134: LIST
90135: LIST
90136: LIST
90137: LIST
90138: LIST
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: ST_TO_ADDR
90144: GO 90543
90146: LD_INT 18
90148: DOUBLE
90149: EQUAL
90150: IFTRUE 90154
90152: GO 90302
90154: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
90155: LD_ADDR_VAR 0 2
90159: PUSH
90160: LD_INT 2
90162: PUSH
90163: LD_INT 4
90165: PUSH
90166: LD_INT 5
90168: PUSH
90169: LD_INT 7
90171: PUSH
90172: LD_INT 11
90174: PUSH
90175: LD_INT 12
90177: PUSH
90178: LD_INT 15
90180: PUSH
90181: LD_INT 16
90183: PUSH
90184: LD_INT 20
90186: PUSH
90187: LD_INT 21
90189: PUSH
90190: LD_INT 22
90192: PUSH
90193: LD_INT 23
90195: PUSH
90196: LD_INT 25
90198: PUSH
90199: LD_INT 26
90201: PUSH
90202: LD_INT 30
90204: PUSH
90205: LD_INT 31
90207: PUSH
90208: LD_INT 32
90210: PUSH
90211: LD_INT 33
90213: PUSH
90214: LD_INT 34
90216: PUSH
90217: LD_INT 35
90219: PUSH
90220: LD_INT 36
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: LIST
90227: LIST
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: LIST
90235: LIST
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: PUSH
90246: LD_INT 101
90248: PUSH
90249: LD_INT 102
90251: PUSH
90252: LD_INT 103
90254: PUSH
90255: LD_INT 106
90257: PUSH
90258: LD_INT 108
90260: PUSH
90261: LD_INT 112
90263: PUSH
90264: LD_INT 113
90266: PUSH
90267: LD_INT 114
90269: PUSH
90270: LD_INT 115
90272: PUSH
90273: LD_INT 116
90275: PUSH
90276: LD_INT 117
90278: PUSH
90279: LD_INT 118
90281: PUSH
90282: EMPTY
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: PUSH
90296: EMPTY
90297: LIST
90298: LIST
90299: ST_TO_ADDR
90300: GO 90543
90302: LD_INT 19
90304: DOUBLE
90305: EQUAL
90306: IFTRUE 90310
90308: GO 90542
90310: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
90311: LD_ADDR_VAR 0 2
90315: PUSH
90316: LD_INT 1
90318: PUSH
90319: LD_INT 2
90321: PUSH
90322: LD_INT 3
90324: PUSH
90325: LD_INT 4
90327: PUSH
90328: LD_INT 5
90330: PUSH
90331: LD_INT 6
90333: PUSH
90334: LD_INT 7
90336: PUSH
90337: LD_INT 8
90339: PUSH
90340: LD_INT 9
90342: PUSH
90343: LD_INT 10
90345: PUSH
90346: LD_INT 11
90348: PUSH
90349: LD_INT 12
90351: PUSH
90352: LD_INT 13
90354: PUSH
90355: LD_INT 14
90357: PUSH
90358: LD_INT 15
90360: PUSH
90361: LD_INT 16
90363: PUSH
90364: LD_INT 17
90366: PUSH
90367: LD_INT 18
90369: PUSH
90370: LD_INT 19
90372: PUSH
90373: LD_INT 20
90375: PUSH
90376: LD_INT 21
90378: PUSH
90379: LD_INT 22
90381: PUSH
90382: LD_INT 23
90384: PUSH
90385: LD_INT 24
90387: PUSH
90388: LD_INT 25
90390: PUSH
90391: LD_INT 26
90393: PUSH
90394: LD_INT 27
90396: PUSH
90397: LD_INT 28
90399: PUSH
90400: LD_INT 29
90402: PUSH
90403: LD_INT 30
90405: PUSH
90406: LD_INT 31
90408: PUSH
90409: LD_INT 32
90411: PUSH
90412: LD_INT 33
90414: PUSH
90415: LD_INT 34
90417: PUSH
90418: LD_INT 35
90420: PUSH
90421: LD_INT 36
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: LIST
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: LIST
90445: LIST
90446: LIST
90447: LIST
90448: LIST
90449: LIST
90450: LIST
90451: LIST
90452: LIST
90453: LIST
90454: LIST
90455: LIST
90456: LIST
90457: LIST
90458: LIST
90459: LIST
90460: LIST
90461: PUSH
90462: LD_INT 101
90464: PUSH
90465: LD_INT 102
90467: PUSH
90468: LD_INT 103
90470: PUSH
90471: LD_INT 104
90473: PUSH
90474: LD_INT 105
90476: PUSH
90477: LD_INT 106
90479: PUSH
90480: LD_INT 107
90482: PUSH
90483: LD_INT 108
90485: PUSH
90486: LD_INT 109
90488: PUSH
90489: LD_INT 110
90491: PUSH
90492: LD_INT 111
90494: PUSH
90495: LD_INT 112
90497: PUSH
90498: LD_INT 113
90500: PUSH
90501: LD_INT 114
90503: PUSH
90504: LD_INT 115
90506: PUSH
90507: LD_INT 116
90509: PUSH
90510: LD_INT 117
90512: PUSH
90513: LD_INT 118
90515: PUSH
90516: EMPTY
90517: LIST
90518: LIST
90519: LIST
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: LIST
90528: LIST
90529: LIST
90530: LIST
90531: LIST
90532: LIST
90533: LIST
90534: LIST
90535: PUSH
90536: EMPTY
90537: LIST
90538: LIST
90539: ST_TO_ADDR
90540: GO 90543
90542: POP
// end else
90543: GO 90774
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
90545: LD_ADDR_VAR 0 2
90549: PUSH
90550: LD_INT 1
90552: PUSH
90553: LD_INT 2
90555: PUSH
90556: LD_INT 3
90558: PUSH
90559: LD_INT 4
90561: PUSH
90562: LD_INT 5
90564: PUSH
90565: LD_INT 6
90567: PUSH
90568: LD_INT 7
90570: PUSH
90571: LD_INT 8
90573: PUSH
90574: LD_INT 9
90576: PUSH
90577: LD_INT 10
90579: PUSH
90580: LD_INT 11
90582: PUSH
90583: LD_INT 12
90585: PUSH
90586: LD_INT 13
90588: PUSH
90589: LD_INT 14
90591: PUSH
90592: LD_INT 15
90594: PUSH
90595: LD_INT 16
90597: PUSH
90598: LD_INT 17
90600: PUSH
90601: LD_INT 18
90603: PUSH
90604: LD_INT 19
90606: PUSH
90607: LD_INT 20
90609: PUSH
90610: LD_INT 21
90612: PUSH
90613: LD_INT 22
90615: PUSH
90616: LD_INT 23
90618: PUSH
90619: LD_INT 24
90621: PUSH
90622: LD_INT 25
90624: PUSH
90625: LD_INT 26
90627: PUSH
90628: LD_INT 27
90630: PUSH
90631: LD_INT 28
90633: PUSH
90634: LD_INT 29
90636: PUSH
90637: LD_INT 30
90639: PUSH
90640: LD_INT 31
90642: PUSH
90643: LD_INT 32
90645: PUSH
90646: LD_INT 33
90648: PUSH
90649: LD_INT 34
90651: PUSH
90652: LD_INT 35
90654: PUSH
90655: LD_INT 36
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: LIST
90670: LIST
90671: LIST
90672: LIST
90673: LIST
90674: LIST
90675: LIST
90676: LIST
90677: LIST
90678: LIST
90679: LIST
90680: LIST
90681: LIST
90682: LIST
90683: LIST
90684: LIST
90685: LIST
90686: LIST
90687: LIST
90688: LIST
90689: LIST
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: LIST
90695: PUSH
90696: LD_INT 101
90698: PUSH
90699: LD_INT 102
90701: PUSH
90702: LD_INT 103
90704: PUSH
90705: LD_INT 104
90707: PUSH
90708: LD_INT 105
90710: PUSH
90711: LD_INT 106
90713: PUSH
90714: LD_INT 107
90716: PUSH
90717: LD_INT 108
90719: PUSH
90720: LD_INT 109
90722: PUSH
90723: LD_INT 110
90725: PUSH
90726: LD_INT 111
90728: PUSH
90729: LD_INT 112
90731: PUSH
90732: LD_INT 113
90734: PUSH
90735: LD_INT 114
90737: PUSH
90738: LD_INT 115
90740: PUSH
90741: LD_INT 116
90743: PUSH
90744: LD_INT 117
90746: PUSH
90747: LD_INT 118
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: LIST
90754: LIST
90755: LIST
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: LIST
90769: PUSH
90770: EMPTY
90771: LIST
90772: LIST
90773: ST_TO_ADDR
// if result then
90774: LD_VAR 0 2
90778: IFFALSE 91564
// begin normal :=  ;
90780: LD_ADDR_VAR 0 5
90784: PUSH
90785: LD_STRING 
90787: ST_TO_ADDR
// hardcore :=  ;
90788: LD_ADDR_VAR 0 6
90792: PUSH
90793: LD_STRING 
90795: ST_TO_ADDR
// active :=  ;
90796: LD_ADDR_VAR 0 7
90800: PUSH
90801: LD_STRING 
90803: ST_TO_ADDR
// for i = 1 to normalCounter do
90804: LD_ADDR_VAR 0 8
90808: PUSH
90809: DOUBLE
90810: LD_INT 1
90812: DEC
90813: ST_TO_ADDR
90814: LD_EXP 124
90818: PUSH
90819: FOR_TO
90820: IFFALSE 90921
// begin tmp := 0 ;
90822: LD_ADDR_VAR 0 3
90826: PUSH
90827: LD_STRING 0
90829: ST_TO_ADDR
// if result [ 1 ] then
90830: LD_VAR 0 2
90834: PUSH
90835: LD_INT 1
90837: ARRAY
90838: IFFALSE 90903
// if result [ 1 ] [ 1 ] = i then
90840: LD_VAR 0 2
90844: PUSH
90845: LD_INT 1
90847: ARRAY
90848: PUSH
90849: LD_INT 1
90851: ARRAY
90852: PUSH
90853: LD_VAR 0 8
90857: EQUAL
90858: IFFALSE 90903
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
90860: LD_ADDR_VAR 0 2
90864: PUSH
90865: LD_VAR 0 2
90869: PPUSH
90870: LD_INT 1
90872: PPUSH
90873: LD_VAR 0 2
90877: PUSH
90878: LD_INT 1
90880: ARRAY
90881: PPUSH
90882: LD_INT 1
90884: PPUSH
90885: CALL_OW 3
90889: PPUSH
90890: CALL_OW 1
90894: ST_TO_ADDR
// tmp := 1 ;
90895: LD_ADDR_VAR 0 3
90899: PUSH
90900: LD_STRING 1
90902: ST_TO_ADDR
// end ; normal := normal & tmp ;
90903: LD_ADDR_VAR 0 5
90907: PUSH
90908: LD_VAR 0 5
90912: PUSH
90913: LD_VAR 0 3
90917: STR
90918: ST_TO_ADDR
// end ;
90919: GO 90819
90921: POP
90922: POP
// for i = 1 to hardcoreCounter do
90923: LD_ADDR_VAR 0 8
90927: PUSH
90928: DOUBLE
90929: LD_INT 1
90931: DEC
90932: ST_TO_ADDR
90933: LD_EXP 125
90937: PUSH
90938: FOR_TO
90939: IFFALSE 91044
// begin tmp := 0 ;
90941: LD_ADDR_VAR 0 3
90945: PUSH
90946: LD_STRING 0
90948: ST_TO_ADDR
// if result [ 2 ] then
90949: LD_VAR 0 2
90953: PUSH
90954: LD_INT 2
90956: ARRAY
90957: IFFALSE 91026
// if result [ 2 ] [ 1 ] = 100 + i then
90959: LD_VAR 0 2
90963: PUSH
90964: LD_INT 2
90966: ARRAY
90967: PUSH
90968: LD_INT 1
90970: ARRAY
90971: PUSH
90972: LD_INT 100
90974: PUSH
90975: LD_VAR 0 8
90979: PLUS
90980: EQUAL
90981: IFFALSE 91026
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
90983: LD_ADDR_VAR 0 2
90987: PUSH
90988: LD_VAR 0 2
90992: PPUSH
90993: LD_INT 2
90995: PPUSH
90996: LD_VAR 0 2
91000: PUSH
91001: LD_INT 2
91003: ARRAY
91004: PPUSH
91005: LD_INT 1
91007: PPUSH
91008: CALL_OW 3
91012: PPUSH
91013: CALL_OW 1
91017: ST_TO_ADDR
// tmp := 1 ;
91018: LD_ADDR_VAR 0 3
91022: PUSH
91023: LD_STRING 1
91025: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
91026: LD_ADDR_VAR 0 6
91030: PUSH
91031: LD_VAR 0 6
91035: PUSH
91036: LD_VAR 0 3
91040: STR
91041: ST_TO_ADDR
// end ;
91042: GO 90938
91044: POP
91045: POP
// if isGameLoad then
91046: LD_VAR 0 1
91050: IFFALSE 91525
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
91052: LD_ADDR_VAR 0 4
91056: PUSH
91057: LD_EXP 128
91061: PUSH
91062: LD_EXP 127
91066: PUSH
91067: LD_EXP 129
91071: PUSH
91072: LD_EXP 126
91076: PUSH
91077: LD_EXP 130
91081: PUSH
91082: LD_EXP 131
91086: PUSH
91087: LD_EXP 132
91091: PUSH
91092: LD_EXP 133
91096: PUSH
91097: LD_EXP 134
91101: PUSH
91102: LD_EXP 135
91106: PUSH
91107: LD_EXP 136
91111: PUSH
91112: LD_EXP 137
91116: PUSH
91117: LD_EXP 138
91121: PUSH
91122: LD_EXP 139
91126: PUSH
91127: LD_EXP 147
91131: PUSH
91132: LD_EXP 148
91136: PUSH
91137: LD_EXP 149
91141: PUSH
91142: LD_EXP 150
91146: PUSH
91147: LD_EXP 152
91151: PUSH
91152: LD_EXP 153
91156: PUSH
91157: LD_EXP 154
91161: PUSH
91162: LD_EXP 157
91166: PUSH
91167: LD_EXP 159
91171: PUSH
91172: LD_EXP 160
91176: PUSH
91177: LD_EXP 161
91181: PUSH
91182: LD_EXP 163
91186: PUSH
91187: LD_EXP 164
91191: PUSH
91192: LD_EXP 167
91196: PUSH
91197: LD_EXP 168
91201: PUSH
91202: LD_EXP 169
91206: PUSH
91207: LD_EXP 170
91211: PUSH
91212: LD_EXP 171
91216: PUSH
91217: LD_EXP 172
91221: PUSH
91222: LD_EXP 173
91226: PUSH
91227: LD_EXP 174
91231: PUSH
91232: LD_EXP 175
91236: PUSH
91237: LD_EXP 140
91241: PUSH
91242: LD_EXP 141
91246: PUSH
91247: LD_EXP 144
91251: PUSH
91252: LD_EXP 145
91256: PUSH
91257: LD_EXP 146
91261: PUSH
91262: LD_EXP 142
91266: PUSH
91267: LD_EXP 143
91271: PUSH
91272: LD_EXP 151
91276: PUSH
91277: LD_EXP 155
91281: PUSH
91282: LD_EXP 156
91286: PUSH
91287: LD_EXP 158
91291: PUSH
91292: LD_EXP 162
91296: PUSH
91297: LD_EXP 165
91301: PUSH
91302: LD_EXP 166
91306: PUSH
91307: LD_EXP 176
91311: PUSH
91312: LD_EXP 177
91316: PUSH
91317: LD_EXP 178
91321: PUSH
91322: LD_EXP 179
91326: PUSH
91327: EMPTY
91328: LIST
91329: LIST
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: LIST
91350: LIST
91351: LIST
91352: LIST
91353: LIST
91354: LIST
91355: LIST
91356: LIST
91357: LIST
91358: LIST
91359: LIST
91360: LIST
91361: LIST
91362: LIST
91363: LIST
91364: LIST
91365: LIST
91366: LIST
91367: LIST
91368: LIST
91369: LIST
91370: LIST
91371: LIST
91372: LIST
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: LIST
91380: LIST
91381: LIST
91382: ST_TO_ADDR
// tmp :=  ;
91383: LD_ADDR_VAR 0 3
91387: PUSH
91388: LD_STRING 
91390: ST_TO_ADDR
// for i = 1 to normalCounter do
91391: LD_ADDR_VAR 0 8
91395: PUSH
91396: DOUBLE
91397: LD_INT 1
91399: DEC
91400: ST_TO_ADDR
91401: LD_EXP 124
91405: PUSH
91406: FOR_TO
91407: IFFALSE 91443
// begin if flags [ i ] then
91409: LD_VAR 0 4
91413: PUSH
91414: LD_VAR 0 8
91418: ARRAY
91419: IFFALSE 91441
// tmp := tmp & i & ; ;
91421: LD_ADDR_VAR 0 3
91425: PUSH
91426: LD_VAR 0 3
91430: PUSH
91431: LD_VAR 0 8
91435: STR
91436: PUSH
91437: LD_STRING ;
91439: STR
91440: ST_TO_ADDR
// end ;
91441: GO 91406
91443: POP
91444: POP
// for i = 1 to hardcoreCounter do
91445: LD_ADDR_VAR 0 8
91449: PUSH
91450: DOUBLE
91451: LD_INT 1
91453: DEC
91454: ST_TO_ADDR
91455: LD_EXP 125
91459: PUSH
91460: FOR_TO
91461: IFFALSE 91507
// begin if flags [ normalCounter + i ] then
91463: LD_VAR 0 4
91467: PUSH
91468: LD_EXP 124
91472: PUSH
91473: LD_VAR 0 8
91477: PLUS
91478: ARRAY
91479: IFFALSE 91505
// tmp := tmp & ( 100 + i ) & ; ;
91481: LD_ADDR_VAR 0 3
91485: PUSH
91486: LD_VAR 0 3
91490: PUSH
91491: LD_INT 100
91493: PUSH
91494: LD_VAR 0 8
91498: PLUS
91499: STR
91500: PUSH
91501: LD_STRING ;
91503: STR
91504: ST_TO_ADDR
// end ;
91505: GO 91460
91507: POP
91508: POP
// if tmp then
91509: LD_VAR 0 3
91513: IFFALSE 91525
// active := tmp ;
91515: LD_ADDR_VAR 0 7
91519: PUSH
91520: LD_VAR 0 3
91524: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
91525: LD_STRING getStreamItemsFromMission("
91527: PUSH
91528: LD_VAR 0 5
91532: STR
91533: PUSH
91534: LD_STRING ","
91536: STR
91537: PUSH
91538: LD_VAR 0 6
91542: STR
91543: PUSH
91544: LD_STRING ","
91546: STR
91547: PUSH
91548: LD_VAR 0 7
91552: STR
91553: PUSH
91554: LD_STRING ")
91556: STR
91557: PPUSH
91558: CALL_OW 559
// end else
91562: GO 91571
// ToLua ( getStreamItemsFromMission("","","") ) ;
91564: LD_STRING getStreamItemsFromMission("","","")
91566: PPUSH
91567: CALL_OW 559
// end ;
91571: LD_VAR 0 2
91575: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
91576: LD_EXP 123
91580: PUSH
91581: LD_EXP 128
91585: AND
91586: IFFALSE 91710
91588: GO 91590
91590: DISABLE
91591: LD_INT 0
91593: PPUSH
91594: PPUSH
// begin enable ;
91595: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
91596: LD_ADDR_VAR 0 2
91600: PUSH
91601: LD_INT 22
91603: PUSH
91604: LD_OWVAR 2
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: PUSH
91613: LD_INT 2
91615: PUSH
91616: LD_INT 34
91618: PUSH
91619: LD_INT 7
91621: PUSH
91622: EMPTY
91623: LIST
91624: LIST
91625: PUSH
91626: LD_INT 34
91628: PUSH
91629: LD_INT 45
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: PUSH
91636: LD_INT 34
91638: PUSH
91639: LD_INT 28
91641: PUSH
91642: EMPTY
91643: LIST
91644: LIST
91645: PUSH
91646: LD_INT 34
91648: PUSH
91649: LD_INT 47
91651: PUSH
91652: EMPTY
91653: LIST
91654: LIST
91655: PUSH
91656: EMPTY
91657: LIST
91658: LIST
91659: LIST
91660: LIST
91661: LIST
91662: PUSH
91663: EMPTY
91664: LIST
91665: LIST
91666: PPUSH
91667: CALL_OW 69
91671: ST_TO_ADDR
// if not tmp then
91672: LD_VAR 0 2
91676: NOT
91677: IFFALSE 91681
// exit ;
91679: GO 91710
// for i in tmp do
91681: LD_ADDR_VAR 0 1
91685: PUSH
91686: LD_VAR 0 2
91690: PUSH
91691: FOR_IN
91692: IFFALSE 91708
// begin SetLives ( i , 0 ) ;
91694: LD_VAR 0 1
91698: PPUSH
91699: LD_INT 0
91701: PPUSH
91702: CALL_OW 234
// end ;
91706: GO 91691
91708: POP
91709: POP
// end ;
91710: PPOPN 2
91712: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
91713: LD_EXP 123
91717: PUSH
91718: LD_EXP 129
91722: AND
91723: IFFALSE 91807
91725: GO 91727
91727: DISABLE
91728: LD_INT 0
91730: PPUSH
91731: PPUSH
// begin enable ;
91732: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
91733: LD_ADDR_VAR 0 2
91737: PUSH
91738: LD_INT 22
91740: PUSH
91741: LD_OWVAR 2
91745: PUSH
91746: EMPTY
91747: LIST
91748: LIST
91749: PUSH
91750: LD_INT 32
91752: PUSH
91753: LD_INT 3
91755: PUSH
91756: EMPTY
91757: LIST
91758: LIST
91759: PUSH
91760: EMPTY
91761: LIST
91762: LIST
91763: PPUSH
91764: CALL_OW 69
91768: ST_TO_ADDR
// if not tmp then
91769: LD_VAR 0 2
91773: NOT
91774: IFFALSE 91778
// exit ;
91776: GO 91807
// for i in tmp do
91778: LD_ADDR_VAR 0 1
91782: PUSH
91783: LD_VAR 0 2
91787: PUSH
91788: FOR_IN
91789: IFFALSE 91805
// begin SetLives ( i , 0 ) ;
91791: LD_VAR 0 1
91795: PPUSH
91796: LD_INT 0
91798: PPUSH
91799: CALL_OW 234
// end ;
91803: GO 91788
91805: POP
91806: POP
// end ;
91807: PPOPN 2
91809: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
91810: LD_EXP 123
91814: PUSH
91815: LD_EXP 126
91819: AND
91820: IFFALSE 91913
91822: GO 91824
91824: DISABLE
91825: LD_INT 0
91827: PPUSH
// begin enable ;
91828: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
91829: LD_ADDR_VAR 0 1
91833: PUSH
91834: LD_INT 22
91836: PUSH
91837: LD_OWVAR 2
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: PUSH
91846: LD_INT 2
91848: PUSH
91849: LD_INT 25
91851: PUSH
91852: LD_INT 5
91854: PUSH
91855: EMPTY
91856: LIST
91857: LIST
91858: PUSH
91859: LD_INT 25
91861: PUSH
91862: LD_INT 9
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: PUSH
91869: LD_INT 25
91871: PUSH
91872: LD_INT 8
91874: PUSH
91875: EMPTY
91876: LIST
91877: LIST
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: LIST
91883: LIST
91884: PUSH
91885: EMPTY
91886: LIST
91887: LIST
91888: PPUSH
91889: CALL_OW 69
91893: PUSH
91894: FOR_IN
91895: IFFALSE 91911
// begin SetClass ( i , 1 ) ;
91897: LD_VAR 0 1
91901: PPUSH
91902: LD_INT 1
91904: PPUSH
91905: CALL_OW 336
// end ;
91909: GO 91894
91911: POP
91912: POP
// end ;
91913: PPOPN 1
91915: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
91916: LD_EXP 123
91920: PUSH
91921: LD_EXP 127
91925: AND
91926: PUSH
91927: LD_OWVAR 65
91931: PUSH
91932: LD_INT 7
91934: LESS
91935: AND
91936: IFFALSE 91950
91938: GO 91940
91940: DISABLE
// begin enable ;
91941: ENABLE
// game_speed := 7 ;
91942: LD_ADDR_OWVAR 65
91946: PUSH
91947: LD_INT 7
91949: ST_TO_ADDR
// end ;
91950: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
91951: LD_EXP 123
91955: PUSH
91956: LD_EXP 130
91960: AND
91961: IFFALSE 92163
91963: GO 91965
91965: DISABLE
91966: LD_INT 0
91968: PPUSH
91969: PPUSH
91970: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
91971: LD_ADDR_VAR 0 3
91975: PUSH
91976: LD_INT 81
91978: PUSH
91979: LD_OWVAR 2
91983: PUSH
91984: EMPTY
91985: LIST
91986: LIST
91987: PUSH
91988: LD_INT 21
91990: PUSH
91991: LD_INT 1
91993: PUSH
91994: EMPTY
91995: LIST
91996: LIST
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: PPUSH
92002: CALL_OW 69
92006: ST_TO_ADDR
// if not tmp then
92007: LD_VAR 0 3
92011: NOT
92012: IFFALSE 92016
// exit ;
92014: GO 92163
// if tmp > 5 then
92016: LD_VAR 0 3
92020: PUSH
92021: LD_INT 5
92023: GREATER
92024: IFFALSE 92036
// k := 5 else
92026: LD_ADDR_VAR 0 2
92030: PUSH
92031: LD_INT 5
92033: ST_TO_ADDR
92034: GO 92046
// k := tmp ;
92036: LD_ADDR_VAR 0 2
92040: PUSH
92041: LD_VAR 0 3
92045: ST_TO_ADDR
// for i := 1 to k do
92046: LD_ADDR_VAR 0 1
92050: PUSH
92051: DOUBLE
92052: LD_INT 1
92054: DEC
92055: ST_TO_ADDR
92056: LD_VAR 0 2
92060: PUSH
92061: FOR_TO
92062: IFFALSE 92161
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92064: LD_VAR 0 3
92068: PUSH
92069: LD_VAR 0 1
92073: ARRAY
92074: PPUSH
92075: LD_VAR 0 1
92079: PUSH
92080: LD_INT 4
92082: MOD
92083: PUSH
92084: LD_INT 1
92086: PLUS
92087: PPUSH
92088: CALL_OW 259
92092: PUSH
92093: LD_INT 10
92095: LESS
92096: IFFALSE 92159
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92098: LD_VAR 0 3
92102: PUSH
92103: LD_VAR 0 1
92107: ARRAY
92108: PPUSH
92109: LD_VAR 0 1
92113: PUSH
92114: LD_INT 4
92116: MOD
92117: PUSH
92118: LD_INT 1
92120: PLUS
92121: PPUSH
92122: LD_VAR 0 3
92126: PUSH
92127: LD_VAR 0 1
92131: ARRAY
92132: PPUSH
92133: LD_VAR 0 1
92137: PUSH
92138: LD_INT 4
92140: MOD
92141: PUSH
92142: LD_INT 1
92144: PLUS
92145: PPUSH
92146: CALL_OW 259
92150: PUSH
92151: LD_INT 1
92153: PLUS
92154: PPUSH
92155: CALL_OW 237
92159: GO 92061
92161: POP
92162: POP
// end ;
92163: PPOPN 3
92165: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92166: LD_EXP 123
92170: PUSH
92171: LD_EXP 131
92175: AND
92176: IFFALSE 92196
92178: GO 92180
92180: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92181: LD_INT 4
92183: PPUSH
92184: LD_OWVAR 2
92188: PPUSH
92189: LD_INT 0
92191: PPUSH
92192: CALL_OW 324
92196: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92197: LD_EXP 123
92201: PUSH
92202: LD_EXP 160
92206: AND
92207: IFFALSE 92227
92209: GO 92211
92211: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92212: LD_INT 19
92214: PPUSH
92215: LD_OWVAR 2
92219: PPUSH
92220: LD_INT 0
92222: PPUSH
92223: CALL_OW 324
92227: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92228: LD_EXP 123
92232: PUSH
92233: LD_EXP 132
92237: AND
92238: IFFALSE 92340
92240: GO 92242
92242: DISABLE
92243: LD_INT 0
92245: PPUSH
92246: PPUSH
// begin enable ;
92247: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92248: LD_ADDR_VAR 0 2
92252: PUSH
92253: LD_INT 22
92255: PUSH
92256: LD_OWVAR 2
92260: PUSH
92261: EMPTY
92262: LIST
92263: LIST
92264: PUSH
92265: LD_INT 2
92267: PUSH
92268: LD_INT 34
92270: PUSH
92271: LD_INT 11
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: PUSH
92278: LD_INT 34
92280: PUSH
92281: LD_INT 30
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: EMPTY
92289: LIST
92290: LIST
92291: LIST
92292: PUSH
92293: EMPTY
92294: LIST
92295: LIST
92296: PPUSH
92297: CALL_OW 69
92301: ST_TO_ADDR
// if not tmp then
92302: LD_VAR 0 2
92306: NOT
92307: IFFALSE 92311
// exit ;
92309: GO 92340
// for i in tmp do
92311: LD_ADDR_VAR 0 1
92315: PUSH
92316: LD_VAR 0 2
92320: PUSH
92321: FOR_IN
92322: IFFALSE 92338
// begin SetLives ( i , 0 ) ;
92324: LD_VAR 0 1
92328: PPUSH
92329: LD_INT 0
92331: PPUSH
92332: CALL_OW 234
// end ;
92336: GO 92321
92338: POP
92339: POP
// end ;
92340: PPOPN 2
92342: END
// every 0 0$1 trigger StreamModeActive and sBunker do
92343: LD_EXP 123
92347: PUSH
92348: LD_EXP 133
92352: AND
92353: IFFALSE 92373
92355: GO 92357
92357: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
92358: LD_INT 32
92360: PPUSH
92361: LD_OWVAR 2
92365: PPUSH
92366: LD_INT 0
92368: PPUSH
92369: CALL_OW 324
92373: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
92374: LD_EXP 123
92378: PUSH
92379: LD_EXP 134
92383: AND
92384: IFFALSE 92565
92386: GO 92388
92388: DISABLE
92389: LD_INT 0
92391: PPUSH
92392: PPUSH
92393: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
92394: LD_ADDR_VAR 0 2
92398: PUSH
92399: LD_INT 22
92401: PUSH
92402: LD_OWVAR 2
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: PUSH
92411: LD_INT 33
92413: PUSH
92414: LD_INT 3
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: PPUSH
92425: CALL_OW 69
92429: ST_TO_ADDR
// if not tmp then
92430: LD_VAR 0 2
92434: NOT
92435: IFFALSE 92439
// exit ;
92437: GO 92565
// side := 0 ;
92439: LD_ADDR_VAR 0 3
92443: PUSH
92444: LD_INT 0
92446: ST_TO_ADDR
// for i := 1 to 8 do
92447: LD_ADDR_VAR 0 1
92451: PUSH
92452: DOUBLE
92453: LD_INT 1
92455: DEC
92456: ST_TO_ADDR
92457: LD_INT 8
92459: PUSH
92460: FOR_TO
92461: IFFALSE 92509
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
92463: LD_OWVAR 2
92467: PUSH
92468: LD_VAR 0 1
92472: NONEQUAL
92473: PUSH
92474: LD_OWVAR 2
92478: PPUSH
92479: LD_VAR 0 1
92483: PPUSH
92484: CALL_OW 81
92488: PUSH
92489: LD_INT 2
92491: EQUAL
92492: AND
92493: IFFALSE 92507
// begin side := i ;
92495: LD_ADDR_VAR 0 3
92499: PUSH
92500: LD_VAR 0 1
92504: ST_TO_ADDR
// break ;
92505: GO 92509
// end ;
92507: GO 92460
92509: POP
92510: POP
// if not side then
92511: LD_VAR 0 3
92515: NOT
92516: IFFALSE 92520
// exit ;
92518: GO 92565
// for i := 1 to tmp do
92520: LD_ADDR_VAR 0 1
92524: PUSH
92525: DOUBLE
92526: LD_INT 1
92528: DEC
92529: ST_TO_ADDR
92530: LD_VAR 0 2
92534: PUSH
92535: FOR_TO
92536: IFFALSE 92563
// if Prob ( 60 ) then
92538: LD_INT 60
92540: PPUSH
92541: CALL_OW 13
92545: IFFALSE 92561
// SetSide ( i , side ) ;
92547: LD_VAR 0 1
92551: PPUSH
92552: LD_VAR 0 3
92556: PPUSH
92557: CALL_OW 235
92561: GO 92535
92563: POP
92564: POP
// end ;
92565: PPOPN 3
92567: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
92568: LD_EXP 123
92572: PUSH
92573: LD_EXP 136
92577: AND
92578: IFFALSE 92697
92580: GO 92582
92582: DISABLE
92583: LD_INT 0
92585: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
92586: LD_ADDR_VAR 0 1
92590: PUSH
92591: LD_INT 22
92593: PUSH
92594: LD_OWVAR 2
92598: PUSH
92599: EMPTY
92600: LIST
92601: LIST
92602: PUSH
92603: LD_INT 21
92605: PUSH
92606: LD_INT 1
92608: PUSH
92609: EMPTY
92610: LIST
92611: LIST
92612: PUSH
92613: LD_INT 3
92615: PUSH
92616: LD_INT 23
92618: PUSH
92619: LD_INT 0
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: PUSH
92630: EMPTY
92631: LIST
92632: LIST
92633: LIST
92634: PPUSH
92635: CALL_OW 69
92639: PUSH
92640: FOR_IN
92641: IFFALSE 92695
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
92643: LD_VAR 0 1
92647: PPUSH
92648: CALL_OW 257
92652: PUSH
92653: LD_INT 1
92655: PUSH
92656: LD_INT 2
92658: PUSH
92659: LD_INT 3
92661: PUSH
92662: LD_INT 4
92664: PUSH
92665: EMPTY
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: IN
92671: IFFALSE 92693
// SetClass ( un , rand ( 1 , 4 ) ) ;
92673: LD_VAR 0 1
92677: PPUSH
92678: LD_INT 1
92680: PPUSH
92681: LD_INT 4
92683: PPUSH
92684: CALL_OW 12
92688: PPUSH
92689: CALL_OW 336
92693: GO 92640
92695: POP
92696: POP
// end ;
92697: PPOPN 1
92699: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
92700: LD_EXP 123
92704: PUSH
92705: LD_EXP 135
92709: AND
92710: IFFALSE 92789
92712: GO 92714
92714: DISABLE
92715: LD_INT 0
92717: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92718: LD_ADDR_VAR 0 1
92722: PUSH
92723: LD_INT 22
92725: PUSH
92726: LD_OWVAR 2
92730: PUSH
92731: EMPTY
92732: LIST
92733: LIST
92734: PUSH
92735: LD_INT 21
92737: PUSH
92738: LD_INT 3
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PPUSH
92749: CALL_OW 69
92753: ST_TO_ADDR
// if not tmp then
92754: LD_VAR 0 1
92758: NOT
92759: IFFALSE 92763
// exit ;
92761: GO 92789
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
92763: LD_VAR 0 1
92767: PUSH
92768: LD_INT 1
92770: PPUSH
92771: LD_VAR 0 1
92775: PPUSH
92776: CALL_OW 12
92780: ARRAY
92781: PPUSH
92782: LD_INT 100
92784: PPUSH
92785: CALL_OW 234
// end ;
92789: PPOPN 1
92791: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
92792: LD_EXP 123
92796: PUSH
92797: LD_EXP 137
92801: AND
92802: IFFALSE 92900
92804: GO 92806
92806: DISABLE
92807: LD_INT 0
92809: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92810: LD_ADDR_VAR 0 1
92814: PUSH
92815: LD_INT 22
92817: PUSH
92818: LD_OWVAR 2
92822: PUSH
92823: EMPTY
92824: LIST
92825: LIST
92826: PUSH
92827: LD_INT 21
92829: PUSH
92830: LD_INT 1
92832: PUSH
92833: EMPTY
92834: LIST
92835: LIST
92836: PUSH
92837: EMPTY
92838: LIST
92839: LIST
92840: PPUSH
92841: CALL_OW 69
92845: ST_TO_ADDR
// if not tmp then
92846: LD_VAR 0 1
92850: NOT
92851: IFFALSE 92855
// exit ;
92853: GO 92900
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
92855: LD_VAR 0 1
92859: PUSH
92860: LD_INT 1
92862: PPUSH
92863: LD_VAR 0 1
92867: PPUSH
92868: CALL_OW 12
92872: ARRAY
92873: PPUSH
92874: LD_INT 1
92876: PPUSH
92877: LD_INT 4
92879: PPUSH
92880: CALL_OW 12
92884: PPUSH
92885: LD_INT 3000
92887: PPUSH
92888: LD_INT 9000
92890: PPUSH
92891: CALL_OW 12
92895: PPUSH
92896: CALL_OW 492
// end ;
92900: PPOPN 1
92902: END
// every 0 0$1 trigger StreamModeActive and sDepot do
92903: LD_EXP 123
92907: PUSH
92908: LD_EXP 138
92912: AND
92913: IFFALSE 92933
92915: GO 92917
92917: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
92918: LD_INT 1
92920: PPUSH
92921: LD_OWVAR 2
92925: PPUSH
92926: LD_INT 0
92928: PPUSH
92929: CALL_OW 324
92933: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
92934: LD_EXP 123
92938: PUSH
92939: LD_EXP 139
92943: AND
92944: IFFALSE 93027
92946: GO 92948
92948: DISABLE
92949: LD_INT 0
92951: PPUSH
92952: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92953: LD_ADDR_VAR 0 2
92957: PUSH
92958: LD_INT 22
92960: PUSH
92961: LD_OWVAR 2
92965: PUSH
92966: EMPTY
92967: LIST
92968: LIST
92969: PUSH
92970: LD_INT 21
92972: PUSH
92973: LD_INT 3
92975: PUSH
92976: EMPTY
92977: LIST
92978: LIST
92979: PUSH
92980: EMPTY
92981: LIST
92982: LIST
92983: PPUSH
92984: CALL_OW 69
92988: ST_TO_ADDR
// if not tmp then
92989: LD_VAR 0 2
92993: NOT
92994: IFFALSE 92998
// exit ;
92996: GO 93027
// for i in tmp do
92998: LD_ADDR_VAR 0 1
93002: PUSH
93003: LD_VAR 0 2
93007: PUSH
93008: FOR_IN
93009: IFFALSE 93025
// SetBLevel ( i , 10 ) ;
93011: LD_VAR 0 1
93015: PPUSH
93016: LD_INT 10
93018: PPUSH
93019: CALL_OW 241
93023: GO 93008
93025: POP
93026: POP
// end ;
93027: PPOPN 2
93029: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93030: LD_EXP 123
93034: PUSH
93035: LD_EXP 140
93039: AND
93040: IFFALSE 93151
93042: GO 93044
93044: DISABLE
93045: LD_INT 0
93047: PPUSH
93048: PPUSH
93049: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93050: LD_ADDR_VAR 0 3
93054: PUSH
93055: LD_INT 22
93057: PUSH
93058: LD_OWVAR 2
93062: PUSH
93063: EMPTY
93064: LIST
93065: LIST
93066: PUSH
93067: LD_INT 25
93069: PUSH
93070: LD_INT 1
93072: PUSH
93073: EMPTY
93074: LIST
93075: LIST
93076: PUSH
93077: EMPTY
93078: LIST
93079: LIST
93080: PPUSH
93081: CALL_OW 69
93085: ST_TO_ADDR
// if not tmp then
93086: LD_VAR 0 3
93090: NOT
93091: IFFALSE 93095
// exit ;
93093: GO 93151
// un := tmp [ rand ( 1 , tmp ) ] ;
93095: LD_ADDR_VAR 0 2
93099: PUSH
93100: LD_VAR 0 3
93104: PUSH
93105: LD_INT 1
93107: PPUSH
93108: LD_VAR 0 3
93112: PPUSH
93113: CALL_OW 12
93117: ARRAY
93118: ST_TO_ADDR
// if Crawls ( un ) then
93119: LD_VAR 0 2
93123: PPUSH
93124: CALL_OW 318
93128: IFFALSE 93139
// ComWalk ( un ) ;
93130: LD_VAR 0 2
93134: PPUSH
93135: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93139: LD_VAR 0 2
93143: PPUSH
93144: LD_INT 5
93146: PPUSH
93147: CALL_OW 336
// end ;
93151: PPOPN 3
93153: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
93154: LD_EXP 123
93158: PUSH
93159: LD_EXP 141
93163: AND
93164: PUSH
93165: LD_OWVAR 67
93169: PUSH
93170: LD_INT 4
93172: LESS
93173: AND
93174: IFFALSE 93193
93176: GO 93178
93178: DISABLE
// begin Difficulty := Difficulty + 1 ;
93179: LD_ADDR_OWVAR 67
93183: PUSH
93184: LD_OWVAR 67
93188: PUSH
93189: LD_INT 1
93191: PLUS
93192: ST_TO_ADDR
// end ;
93193: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93194: LD_EXP 123
93198: PUSH
93199: LD_EXP 142
93203: AND
93204: IFFALSE 93307
93206: GO 93208
93208: DISABLE
93209: LD_INT 0
93211: PPUSH
// begin for i := 1 to 5 do
93212: LD_ADDR_VAR 0 1
93216: PUSH
93217: DOUBLE
93218: LD_INT 1
93220: DEC
93221: ST_TO_ADDR
93222: LD_INT 5
93224: PUSH
93225: FOR_TO
93226: IFFALSE 93305
// begin uc_nation := nation_nature ;
93228: LD_ADDR_OWVAR 21
93232: PUSH
93233: LD_INT 0
93235: ST_TO_ADDR
// uc_side := 0 ;
93236: LD_ADDR_OWVAR 20
93240: PUSH
93241: LD_INT 0
93243: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93244: LD_ADDR_OWVAR 29
93248: PUSH
93249: LD_INT 12
93251: PUSH
93252: LD_INT 12
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: ST_TO_ADDR
// hc_agressivity := 20 ;
93259: LD_ADDR_OWVAR 35
93263: PUSH
93264: LD_INT 20
93266: ST_TO_ADDR
// hc_class := class_tiger ;
93267: LD_ADDR_OWVAR 28
93271: PUSH
93272: LD_INT 14
93274: ST_TO_ADDR
// hc_gallery :=  ;
93275: LD_ADDR_OWVAR 33
93279: PUSH
93280: LD_STRING 
93282: ST_TO_ADDR
// hc_name :=  ;
93283: LD_ADDR_OWVAR 26
93287: PUSH
93288: LD_STRING 
93290: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93291: CALL_OW 44
93295: PPUSH
93296: LD_INT 0
93298: PPUSH
93299: CALL_OW 51
// end ;
93303: GO 93225
93305: POP
93306: POP
// end ;
93307: PPOPN 1
93309: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93310: LD_EXP 123
93314: PUSH
93315: LD_EXP 143
93319: AND
93320: IFFALSE 93329
93322: GO 93324
93324: DISABLE
// StreamSibBomb ;
93325: CALL 93330 0 0
93329: END
// export function StreamSibBomb ; var i , x , y ; begin
93330: LD_INT 0
93332: PPUSH
93333: PPUSH
93334: PPUSH
93335: PPUSH
// result := false ;
93336: LD_ADDR_VAR 0 1
93340: PUSH
93341: LD_INT 0
93343: ST_TO_ADDR
// for i := 1 to 16 do
93344: LD_ADDR_VAR 0 2
93348: PUSH
93349: DOUBLE
93350: LD_INT 1
93352: DEC
93353: ST_TO_ADDR
93354: LD_INT 16
93356: PUSH
93357: FOR_TO
93358: IFFALSE 93557
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93360: LD_ADDR_VAR 0 3
93364: PUSH
93365: LD_INT 10
93367: PUSH
93368: LD_INT 20
93370: PUSH
93371: LD_INT 30
93373: PUSH
93374: LD_INT 40
93376: PUSH
93377: LD_INT 50
93379: PUSH
93380: LD_INT 60
93382: PUSH
93383: LD_INT 70
93385: PUSH
93386: LD_INT 80
93388: PUSH
93389: LD_INT 90
93391: PUSH
93392: LD_INT 100
93394: PUSH
93395: LD_INT 110
93397: PUSH
93398: LD_INT 120
93400: PUSH
93401: LD_INT 130
93403: PUSH
93404: LD_INT 140
93406: PUSH
93407: LD_INT 150
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: LIST
93414: LIST
93415: LIST
93416: LIST
93417: LIST
93418: LIST
93419: LIST
93420: LIST
93421: LIST
93422: LIST
93423: LIST
93424: LIST
93425: LIST
93426: PUSH
93427: LD_INT 1
93429: PPUSH
93430: LD_INT 15
93432: PPUSH
93433: CALL_OW 12
93437: ARRAY
93438: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93439: LD_ADDR_VAR 0 4
93443: PUSH
93444: LD_INT 10
93446: PUSH
93447: LD_INT 20
93449: PUSH
93450: LD_INT 30
93452: PUSH
93453: LD_INT 40
93455: PUSH
93456: LD_INT 50
93458: PUSH
93459: LD_INT 60
93461: PUSH
93462: LD_INT 70
93464: PUSH
93465: LD_INT 80
93467: PUSH
93468: LD_INT 90
93470: PUSH
93471: LD_INT 100
93473: PUSH
93474: LD_INT 110
93476: PUSH
93477: LD_INT 120
93479: PUSH
93480: LD_INT 130
93482: PUSH
93483: LD_INT 140
93485: PUSH
93486: LD_INT 150
93488: PUSH
93489: EMPTY
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: PUSH
93506: LD_INT 1
93508: PPUSH
93509: LD_INT 15
93511: PPUSH
93512: CALL_OW 12
93516: ARRAY
93517: ST_TO_ADDR
// if ValidHex ( x , y ) then
93518: LD_VAR 0 3
93522: PPUSH
93523: LD_VAR 0 4
93527: PPUSH
93528: CALL_OW 488
93532: IFFALSE 93555
// begin result := [ x , y ] ;
93534: LD_ADDR_VAR 0 1
93538: PUSH
93539: LD_VAR 0 3
93543: PUSH
93544: LD_VAR 0 4
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: ST_TO_ADDR
// break ;
93553: GO 93557
// end ; end ;
93555: GO 93357
93557: POP
93558: POP
// if result then
93559: LD_VAR 0 1
93563: IFFALSE 93623
// begin ToLua ( playSibBomb() ) ;
93565: LD_STRING playSibBomb()
93567: PPUSH
93568: CALL_OW 559
// wait ( 0 0$14 ) ;
93572: LD_INT 490
93574: PPUSH
93575: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
93579: LD_VAR 0 1
93583: PUSH
93584: LD_INT 1
93586: ARRAY
93587: PPUSH
93588: LD_VAR 0 1
93592: PUSH
93593: LD_INT 2
93595: ARRAY
93596: PPUSH
93597: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
93601: LD_VAR 0 1
93605: PUSH
93606: LD_INT 1
93608: ARRAY
93609: PPUSH
93610: LD_VAR 0 1
93614: PUSH
93615: LD_INT 2
93617: ARRAY
93618: PPUSH
93619: CALL_OW 429
// end ; end ;
93623: LD_VAR 0 1
93627: RET
// every 0 0$1 trigger StreamModeActive and sReset do
93628: LD_EXP 123
93632: PUSH
93633: LD_EXP 145
93637: AND
93638: IFFALSE 93650
93640: GO 93642
93642: DISABLE
// YouLost (  ) ;
93643: LD_STRING 
93645: PPUSH
93646: CALL_OW 104
93650: END
// every 0 0$1 trigger StreamModeActive and sFog do
93651: LD_EXP 123
93655: PUSH
93656: LD_EXP 144
93660: AND
93661: IFFALSE 93675
93663: GO 93665
93665: DISABLE
// FogOff ( your_side ) ;
93666: LD_OWVAR 2
93670: PPUSH
93671: CALL_OW 344
93675: END
// every 0 0$1 trigger StreamModeActive and sSun do
93676: LD_EXP 123
93680: PUSH
93681: LD_EXP 146
93685: AND
93686: IFFALSE 93714
93688: GO 93690
93690: DISABLE
// begin solar_recharge_percent := 0 ;
93691: LD_ADDR_OWVAR 79
93695: PUSH
93696: LD_INT 0
93698: ST_TO_ADDR
// wait ( 5 5$00 ) ;
93699: LD_INT 10500
93701: PPUSH
93702: CALL_OW 67
// solar_recharge_percent := 100 ;
93706: LD_ADDR_OWVAR 79
93710: PUSH
93711: LD_INT 100
93713: ST_TO_ADDR
// end ;
93714: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
93715: LD_EXP 123
93719: PUSH
93720: LD_EXP 147
93724: AND
93725: IFFALSE 93964
93727: GO 93729
93729: DISABLE
93730: LD_INT 0
93732: PPUSH
93733: PPUSH
93734: PPUSH
// begin tmp := [ ] ;
93735: LD_ADDR_VAR 0 3
93739: PUSH
93740: EMPTY
93741: ST_TO_ADDR
// for i := 1 to 6 do
93742: LD_ADDR_VAR 0 1
93746: PUSH
93747: DOUBLE
93748: LD_INT 1
93750: DEC
93751: ST_TO_ADDR
93752: LD_INT 6
93754: PUSH
93755: FOR_TO
93756: IFFALSE 93861
// begin uc_nation := nation_nature ;
93758: LD_ADDR_OWVAR 21
93762: PUSH
93763: LD_INT 0
93765: ST_TO_ADDR
// uc_side := 0 ;
93766: LD_ADDR_OWVAR 20
93770: PUSH
93771: LD_INT 0
93773: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93774: LD_ADDR_OWVAR 29
93778: PUSH
93779: LD_INT 12
93781: PUSH
93782: LD_INT 12
93784: PUSH
93785: EMPTY
93786: LIST
93787: LIST
93788: ST_TO_ADDR
// hc_agressivity := 20 ;
93789: LD_ADDR_OWVAR 35
93793: PUSH
93794: LD_INT 20
93796: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
93797: LD_ADDR_OWVAR 28
93801: PUSH
93802: LD_INT 17
93804: ST_TO_ADDR
// hc_gallery :=  ;
93805: LD_ADDR_OWVAR 33
93809: PUSH
93810: LD_STRING 
93812: ST_TO_ADDR
// hc_name :=  ;
93813: LD_ADDR_OWVAR 26
93817: PUSH
93818: LD_STRING 
93820: ST_TO_ADDR
// un := CreateHuman ;
93821: LD_ADDR_VAR 0 2
93825: PUSH
93826: CALL_OW 44
93830: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
93831: LD_VAR 0 2
93835: PPUSH
93836: LD_INT 1
93838: PPUSH
93839: CALL_OW 51
// tmp := tmp ^ un ;
93843: LD_ADDR_VAR 0 3
93847: PUSH
93848: LD_VAR 0 3
93852: PUSH
93853: LD_VAR 0 2
93857: ADD
93858: ST_TO_ADDR
// end ;
93859: GO 93755
93861: POP
93862: POP
// repeat wait ( 0 0$1 ) ;
93863: LD_INT 35
93865: PPUSH
93866: CALL_OW 67
// for un in tmp do
93870: LD_ADDR_VAR 0 2
93874: PUSH
93875: LD_VAR 0 3
93879: PUSH
93880: FOR_IN
93881: IFFALSE 93955
// begin if IsDead ( un ) then
93883: LD_VAR 0 2
93887: PPUSH
93888: CALL_OW 301
93892: IFFALSE 93912
// begin tmp := tmp diff un ;
93894: LD_ADDR_VAR 0 3
93898: PUSH
93899: LD_VAR 0 3
93903: PUSH
93904: LD_VAR 0 2
93908: DIFF
93909: ST_TO_ADDR
// continue ;
93910: GO 93880
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
93912: LD_VAR 0 2
93916: PPUSH
93917: LD_INT 3
93919: PUSH
93920: LD_INT 22
93922: PUSH
93923: LD_INT 0
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: PUSH
93930: EMPTY
93931: LIST
93932: LIST
93933: PPUSH
93934: CALL_OW 69
93938: PPUSH
93939: LD_VAR 0 2
93943: PPUSH
93944: CALL_OW 74
93948: PPUSH
93949: CALL_OW 115
// end ;
93953: GO 93880
93955: POP
93956: POP
// until not tmp ;
93957: LD_VAR 0 3
93961: NOT
93962: IFFALSE 93863
// end ;
93964: PPOPN 3
93966: END
// every 0 0$1 trigger StreamModeActive and sTroll do
93967: LD_EXP 123
93971: PUSH
93972: LD_EXP 148
93976: AND
93977: IFFALSE 94031
93979: GO 93981
93981: DISABLE
// begin ToLua ( displayTroll(); ) ;
93982: LD_STRING displayTroll();
93984: PPUSH
93985: CALL_OW 559
// wait ( 3 3$00 ) ;
93989: LD_INT 6300
93991: PPUSH
93992: CALL_OW 67
// ToLua ( hideTroll(); ) ;
93996: LD_STRING hideTroll();
93998: PPUSH
93999: CALL_OW 559
// wait ( 1 1$00 ) ;
94003: LD_INT 2100
94005: PPUSH
94006: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94010: LD_STRING displayTroll();
94012: PPUSH
94013: CALL_OW 559
// wait ( 1 1$00 ) ;
94017: LD_INT 2100
94019: PPUSH
94020: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94024: LD_STRING hideTroll();
94026: PPUSH
94027: CALL_OW 559
// end ;
94031: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94032: LD_EXP 123
94036: PUSH
94037: LD_EXP 149
94041: AND
94042: IFFALSE 94105
94044: GO 94046
94046: DISABLE
94047: LD_INT 0
94049: PPUSH
// begin p := 0 ;
94050: LD_ADDR_VAR 0 1
94054: PUSH
94055: LD_INT 0
94057: ST_TO_ADDR
// repeat game_speed := 1 ;
94058: LD_ADDR_OWVAR 65
94062: PUSH
94063: LD_INT 1
94065: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94066: LD_INT 35
94068: PPUSH
94069: CALL_OW 67
// p := p + 1 ;
94073: LD_ADDR_VAR 0 1
94077: PUSH
94078: LD_VAR 0 1
94082: PUSH
94083: LD_INT 1
94085: PLUS
94086: ST_TO_ADDR
// until p >= 60 ;
94087: LD_VAR 0 1
94091: PUSH
94092: LD_INT 60
94094: GREATEREQUAL
94095: IFFALSE 94058
// game_speed := 4 ;
94097: LD_ADDR_OWVAR 65
94101: PUSH
94102: LD_INT 4
94104: ST_TO_ADDR
// end ;
94105: PPOPN 1
94107: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94108: LD_EXP 123
94112: PUSH
94113: LD_EXP 150
94117: AND
94118: IFFALSE 94264
94120: GO 94122
94122: DISABLE
94123: LD_INT 0
94125: PPUSH
94126: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94127: LD_ADDR_VAR 0 1
94131: PUSH
94132: LD_INT 22
94134: PUSH
94135: LD_OWVAR 2
94139: PUSH
94140: EMPTY
94141: LIST
94142: LIST
94143: PUSH
94144: LD_INT 2
94146: PUSH
94147: LD_INT 30
94149: PUSH
94150: LD_INT 0
94152: PUSH
94153: EMPTY
94154: LIST
94155: LIST
94156: PUSH
94157: LD_INT 30
94159: PUSH
94160: LD_INT 1
94162: PUSH
94163: EMPTY
94164: LIST
94165: LIST
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: LIST
94171: PUSH
94172: EMPTY
94173: LIST
94174: LIST
94175: PPUSH
94176: CALL_OW 69
94180: ST_TO_ADDR
// if not depot then
94181: LD_VAR 0 1
94185: NOT
94186: IFFALSE 94190
// exit ;
94188: GO 94264
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94190: LD_ADDR_VAR 0 2
94194: PUSH
94195: LD_VAR 0 1
94199: PUSH
94200: LD_INT 1
94202: PPUSH
94203: LD_VAR 0 1
94207: PPUSH
94208: CALL_OW 12
94212: ARRAY
94213: PPUSH
94214: CALL_OW 274
94218: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94219: LD_VAR 0 2
94223: PPUSH
94224: LD_INT 1
94226: PPUSH
94227: LD_INT 0
94229: PPUSH
94230: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94234: LD_VAR 0 2
94238: PPUSH
94239: LD_INT 2
94241: PPUSH
94242: LD_INT 0
94244: PPUSH
94245: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94249: LD_VAR 0 2
94253: PPUSH
94254: LD_INT 3
94256: PPUSH
94257: LD_INT 0
94259: PPUSH
94260: CALL_OW 277
// end ;
94264: PPOPN 2
94266: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94267: LD_EXP 123
94271: PUSH
94272: LD_EXP 151
94276: AND
94277: IFFALSE 94374
94279: GO 94281
94281: DISABLE
94282: LD_INT 0
94284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94285: LD_ADDR_VAR 0 1
94289: PUSH
94290: LD_INT 22
94292: PUSH
94293: LD_OWVAR 2
94297: PUSH
94298: EMPTY
94299: LIST
94300: LIST
94301: PUSH
94302: LD_INT 21
94304: PUSH
94305: LD_INT 1
94307: PUSH
94308: EMPTY
94309: LIST
94310: LIST
94311: PUSH
94312: LD_INT 3
94314: PUSH
94315: LD_INT 23
94317: PUSH
94318: LD_INT 0
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: PUSH
94329: EMPTY
94330: LIST
94331: LIST
94332: LIST
94333: PPUSH
94334: CALL_OW 69
94338: ST_TO_ADDR
// if not tmp then
94339: LD_VAR 0 1
94343: NOT
94344: IFFALSE 94348
// exit ;
94346: GO 94374
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
94348: LD_VAR 0 1
94352: PUSH
94353: LD_INT 1
94355: PPUSH
94356: LD_VAR 0 1
94360: PPUSH
94361: CALL_OW 12
94365: ARRAY
94366: PPUSH
94367: LD_INT 200
94369: PPUSH
94370: CALL_OW 234
// end ;
94374: PPOPN 1
94376: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
94377: LD_EXP 123
94381: PUSH
94382: LD_EXP 152
94386: AND
94387: IFFALSE 94466
94389: GO 94391
94391: DISABLE
94392: LD_INT 0
94394: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
94395: LD_ADDR_VAR 0 1
94399: PUSH
94400: LD_INT 22
94402: PUSH
94403: LD_OWVAR 2
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: PUSH
94412: LD_INT 21
94414: PUSH
94415: LD_INT 2
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: EMPTY
94423: LIST
94424: LIST
94425: PPUSH
94426: CALL_OW 69
94430: ST_TO_ADDR
// if not tmp then
94431: LD_VAR 0 1
94435: NOT
94436: IFFALSE 94440
// exit ;
94438: GO 94466
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
94440: LD_VAR 0 1
94444: PUSH
94445: LD_INT 1
94447: PPUSH
94448: LD_VAR 0 1
94452: PPUSH
94453: CALL_OW 12
94457: ARRAY
94458: PPUSH
94459: LD_INT 60
94461: PPUSH
94462: CALL_OW 234
// end ;
94466: PPOPN 1
94468: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
94469: LD_EXP 123
94473: PUSH
94474: LD_EXP 153
94478: AND
94479: IFFALSE 94578
94481: GO 94483
94483: DISABLE
94484: LD_INT 0
94486: PPUSH
94487: PPUSH
// begin enable ;
94488: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
94489: LD_ADDR_VAR 0 1
94493: PUSH
94494: LD_INT 22
94496: PUSH
94497: LD_OWVAR 2
94501: PUSH
94502: EMPTY
94503: LIST
94504: LIST
94505: PUSH
94506: LD_INT 61
94508: PUSH
94509: EMPTY
94510: LIST
94511: PUSH
94512: LD_INT 33
94514: PUSH
94515: LD_INT 2
94517: PUSH
94518: EMPTY
94519: LIST
94520: LIST
94521: PUSH
94522: EMPTY
94523: LIST
94524: LIST
94525: LIST
94526: PPUSH
94527: CALL_OW 69
94531: ST_TO_ADDR
// if not tmp then
94532: LD_VAR 0 1
94536: NOT
94537: IFFALSE 94541
// exit ;
94539: GO 94578
// for i in tmp do
94541: LD_ADDR_VAR 0 2
94545: PUSH
94546: LD_VAR 0 1
94550: PUSH
94551: FOR_IN
94552: IFFALSE 94576
// if IsControledBy ( i ) then
94554: LD_VAR 0 2
94558: PPUSH
94559: CALL_OW 312
94563: IFFALSE 94574
// ComUnlink ( i ) ;
94565: LD_VAR 0 2
94569: PPUSH
94570: CALL_OW 136
94574: GO 94551
94576: POP
94577: POP
// end ;
94578: PPOPN 2
94580: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
94581: LD_EXP 123
94585: PUSH
94586: LD_EXP 154
94590: AND
94591: IFFALSE 94731
94593: GO 94595
94595: DISABLE
94596: LD_INT 0
94598: PPUSH
94599: PPUSH
// begin ToLua ( displayPowell(); ) ;
94600: LD_STRING displayPowell();
94602: PPUSH
94603: CALL_OW 559
// uc_side := 0 ;
94607: LD_ADDR_OWVAR 20
94611: PUSH
94612: LD_INT 0
94614: ST_TO_ADDR
// uc_nation := 2 ;
94615: LD_ADDR_OWVAR 21
94619: PUSH
94620: LD_INT 2
94622: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
94623: LD_ADDR_OWVAR 37
94627: PUSH
94628: LD_INT 14
94630: ST_TO_ADDR
// vc_engine := engine_siberite ;
94631: LD_ADDR_OWVAR 39
94635: PUSH
94636: LD_INT 3
94638: ST_TO_ADDR
// vc_control := control_apeman ;
94639: LD_ADDR_OWVAR 38
94643: PUSH
94644: LD_INT 5
94646: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
94647: LD_ADDR_OWVAR 40
94651: PUSH
94652: LD_INT 29
94654: ST_TO_ADDR
// un := CreateVehicle ;
94655: LD_ADDR_VAR 0 2
94659: PUSH
94660: CALL_OW 45
94664: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94665: LD_VAR 0 2
94669: PPUSH
94670: LD_INT 1
94672: PPUSH
94673: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94677: LD_INT 35
94679: PPUSH
94680: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94684: LD_VAR 0 2
94688: PPUSH
94689: LD_INT 22
94691: PUSH
94692: LD_OWVAR 2
94696: PUSH
94697: EMPTY
94698: LIST
94699: LIST
94700: PPUSH
94701: CALL_OW 69
94705: PPUSH
94706: LD_VAR 0 2
94710: PPUSH
94711: CALL_OW 74
94715: PPUSH
94716: CALL_OW 115
// until IsDead ( un ) ;
94720: LD_VAR 0 2
94724: PPUSH
94725: CALL_OW 301
94729: IFFALSE 94677
// end ;
94731: PPOPN 2
94733: END
// every 0 0$1 trigger StreamModeActive and sStu do
94734: LD_EXP 123
94738: PUSH
94739: LD_EXP 162
94743: AND
94744: IFFALSE 94760
94746: GO 94748
94748: DISABLE
// begin ToLua ( displayStucuk(); ) ;
94749: LD_STRING displayStucuk();
94751: PPUSH
94752: CALL_OW 559
// ResetFog ;
94756: CALL_OW 335
// end ;
94760: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
94761: LD_EXP 123
94765: PUSH
94766: LD_EXP 155
94770: AND
94771: IFFALSE 94912
94773: GO 94775
94775: DISABLE
94776: LD_INT 0
94778: PPUSH
94779: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94780: LD_ADDR_VAR 0 2
94784: PUSH
94785: LD_INT 22
94787: PUSH
94788: LD_OWVAR 2
94792: PUSH
94793: EMPTY
94794: LIST
94795: LIST
94796: PUSH
94797: LD_INT 21
94799: PUSH
94800: LD_INT 1
94802: PUSH
94803: EMPTY
94804: LIST
94805: LIST
94806: PUSH
94807: EMPTY
94808: LIST
94809: LIST
94810: PPUSH
94811: CALL_OW 69
94815: ST_TO_ADDR
// if not tmp then
94816: LD_VAR 0 2
94820: NOT
94821: IFFALSE 94825
// exit ;
94823: GO 94912
// un := tmp [ rand ( 1 , tmp ) ] ;
94825: LD_ADDR_VAR 0 1
94829: PUSH
94830: LD_VAR 0 2
94834: PUSH
94835: LD_INT 1
94837: PPUSH
94838: LD_VAR 0 2
94842: PPUSH
94843: CALL_OW 12
94847: ARRAY
94848: ST_TO_ADDR
// SetSide ( un , 0 ) ;
94849: LD_VAR 0 1
94853: PPUSH
94854: LD_INT 0
94856: PPUSH
94857: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
94861: LD_VAR 0 1
94865: PPUSH
94866: LD_OWVAR 3
94870: PUSH
94871: LD_VAR 0 1
94875: DIFF
94876: PPUSH
94877: LD_VAR 0 1
94881: PPUSH
94882: CALL_OW 74
94886: PPUSH
94887: CALL_OW 115
// wait ( 0 0$20 ) ;
94891: LD_INT 700
94893: PPUSH
94894: CALL_OW 67
// SetSide ( un , your_side ) ;
94898: LD_VAR 0 1
94902: PPUSH
94903: LD_OWVAR 2
94907: PPUSH
94908: CALL_OW 235
// end ;
94912: PPOPN 2
94914: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
94915: LD_EXP 123
94919: PUSH
94920: LD_EXP 156
94924: AND
94925: IFFALSE 95031
94927: GO 94929
94929: DISABLE
94930: LD_INT 0
94932: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94933: LD_ADDR_VAR 0 1
94937: PUSH
94938: LD_INT 22
94940: PUSH
94941: LD_OWVAR 2
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: LD_INT 2
94952: PUSH
94953: LD_INT 30
94955: PUSH
94956: LD_INT 0
94958: PUSH
94959: EMPTY
94960: LIST
94961: LIST
94962: PUSH
94963: LD_INT 30
94965: PUSH
94966: LD_INT 1
94968: PUSH
94969: EMPTY
94970: LIST
94971: LIST
94972: PUSH
94973: EMPTY
94974: LIST
94975: LIST
94976: LIST
94977: PUSH
94978: EMPTY
94979: LIST
94980: LIST
94981: PPUSH
94982: CALL_OW 69
94986: ST_TO_ADDR
// if not depot then
94987: LD_VAR 0 1
94991: NOT
94992: IFFALSE 94996
// exit ;
94994: GO 95031
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
94996: LD_VAR 0 1
95000: PUSH
95001: LD_INT 1
95003: ARRAY
95004: PPUSH
95005: CALL_OW 250
95009: PPUSH
95010: LD_VAR 0 1
95014: PUSH
95015: LD_INT 1
95017: ARRAY
95018: PPUSH
95019: CALL_OW 251
95023: PPUSH
95024: LD_INT 70
95026: PPUSH
95027: CALL_OW 495
// end ;
95031: PPOPN 1
95033: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95034: LD_EXP 123
95038: PUSH
95039: LD_EXP 157
95043: AND
95044: IFFALSE 95255
95046: GO 95048
95048: DISABLE
95049: LD_INT 0
95051: PPUSH
95052: PPUSH
95053: PPUSH
95054: PPUSH
95055: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95056: LD_ADDR_VAR 0 5
95060: PUSH
95061: LD_INT 22
95063: PUSH
95064: LD_OWVAR 2
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: LD_INT 21
95075: PUSH
95076: LD_INT 1
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PUSH
95083: EMPTY
95084: LIST
95085: LIST
95086: PPUSH
95087: CALL_OW 69
95091: ST_TO_ADDR
// if not tmp then
95092: LD_VAR 0 5
95096: NOT
95097: IFFALSE 95101
// exit ;
95099: GO 95255
// for i in tmp do
95101: LD_ADDR_VAR 0 1
95105: PUSH
95106: LD_VAR 0 5
95110: PUSH
95111: FOR_IN
95112: IFFALSE 95253
// begin d := rand ( 0 , 5 ) ;
95114: LD_ADDR_VAR 0 4
95118: PUSH
95119: LD_INT 0
95121: PPUSH
95122: LD_INT 5
95124: PPUSH
95125: CALL_OW 12
95129: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95130: LD_ADDR_VAR 0 2
95134: PUSH
95135: LD_VAR 0 1
95139: PPUSH
95140: CALL_OW 250
95144: PPUSH
95145: LD_VAR 0 4
95149: PPUSH
95150: LD_INT 3
95152: PPUSH
95153: LD_INT 12
95155: PPUSH
95156: CALL_OW 12
95160: PPUSH
95161: CALL_OW 272
95165: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95166: LD_ADDR_VAR 0 3
95170: PUSH
95171: LD_VAR 0 1
95175: PPUSH
95176: CALL_OW 251
95180: PPUSH
95181: LD_VAR 0 4
95185: PPUSH
95186: LD_INT 3
95188: PPUSH
95189: LD_INT 12
95191: PPUSH
95192: CALL_OW 12
95196: PPUSH
95197: CALL_OW 273
95201: ST_TO_ADDR
// if ValidHex ( x , y ) then
95202: LD_VAR 0 2
95206: PPUSH
95207: LD_VAR 0 3
95211: PPUSH
95212: CALL_OW 488
95216: IFFALSE 95251
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95218: LD_VAR 0 1
95222: PPUSH
95223: LD_VAR 0 2
95227: PPUSH
95228: LD_VAR 0 3
95232: PPUSH
95233: LD_INT 3
95235: PPUSH
95236: LD_INT 6
95238: PPUSH
95239: CALL_OW 12
95243: PPUSH
95244: LD_INT 1
95246: PPUSH
95247: CALL_OW 483
// end ;
95251: GO 95111
95253: POP
95254: POP
// end ;
95255: PPOPN 5
95257: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95258: LD_EXP 123
95262: PUSH
95263: LD_EXP 158
95267: AND
95268: IFFALSE 95362
95270: GO 95272
95272: DISABLE
95273: LD_INT 0
95275: PPUSH
95276: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95277: LD_ADDR_VAR 0 2
95281: PUSH
95282: LD_INT 22
95284: PUSH
95285: LD_OWVAR 2
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: LD_INT 32
95296: PUSH
95297: LD_INT 1
95299: PUSH
95300: EMPTY
95301: LIST
95302: LIST
95303: PUSH
95304: LD_INT 21
95306: PUSH
95307: LD_INT 2
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: PUSH
95314: EMPTY
95315: LIST
95316: LIST
95317: LIST
95318: PPUSH
95319: CALL_OW 69
95323: ST_TO_ADDR
// if not tmp then
95324: LD_VAR 0 2
95328: NOT
95329: IFFALSE 95333
// exit ;
95331: GO 95362
// for i in tmp do
95333: LD_ADDR_VAR 0 1
95337: PUSH
95338: LD_VAR 0 2
95342: PUSH
95343: FOR_IN
95344: IFFALSE 95360
// SetFuel ( i , 0 ) ;
95346: LD_VAR 0 1
95350: PPUSH
95351: LD_INT 0
95353: PPUSH
95354: CALL_OW 240
95358: GO 95343
95360: POP
95361: POP
// end ;
95362: PPOPN 2
95364: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
95365: LD_EXP 123
95369: PUSH
95370: LD_EXP 159
95374: AND
95375: IFFALSE 95441
95377: GO 95379
95379: DISABLE
95380: LD_INT 0
95382: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95383: LD_ADDR_VAR 0 1
95387: PUSH
95388: LD_INT 22
95390: PUSH
95391: LD_OWVAR 2
95395: PUSH
95396: EMPTY
95397: LIST
95398: LIST
95399: PUSH
95400: LD_INT 30
95402: PUSH
95403: LD_INT 29
95405: PUSH
95406: EMPTY
95407: LIST
95408: LIST
95409: PUSH
95410: EMPTY
95411: LIST
95412: LIST
95413: PPUSH
95414: CALL_OW 69
95418: ST_TO_ADDR
// if not tmp then
95419: LD_VAR 0 1
95423: NOT
95424: IFFALSE 95428
// exit ;
95426: GO 95441
// DestroyUnit ( tmp [ 1 ] ) ;
95428: LD_VAR 0 1
95432: PUSH
95433: LD_INT 1
95435: ARRAY
95436: PPUSH
95437: CALL_OW 65
// end ;
95441: PPOPN 1
95443: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
95444: LD_EXP 123
95448: PUSH
95449: LD_EXP 161
95453: AND
95454: IFFALSE 95583
95456: GO 95458
95458: DISABLE
95459: LD_INT 0
95461: PPUSH
// begin uc_side := 0 ;
95462: LD_ADDR_OWVAR 20
95466: PUSH
95467: LD_INT 0
95469: ST_TO_ADDR
// uc_nation := nation_arabian ;
95470: LD_ADDR_OWVAR 21
95474: PUSH
95475: LD_INT 2
95477: ST_TO_ADDR
// hc_gallery :=  ;
95478: LD_ADDR_OWVAR 33
95482: PUSH
95483: LD_STRING 
95485: ST_TO_ADDR
// hc_name :=  ;
95486: LD_ADDR_OWVAR 26
95490: PUSH
95491: LD_STRING 
95493: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
95494: LD_INT 1
95496: PPUSH
95497: LD_INT 11
95499: PPUSH
95500: LD_INT 10
95502: PPUSH
95503: CALL_OW 380
// un := CreateHuman ;
95507: LD_ADDR_VAR 0 1
95511: PUSH
95512: CALL_OW 44
95516: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95517: LD_VAR 0 1
95521: PPUSH
95522: LD_INT 1
95524: PPUSH
95525: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95529: LD_INT 35
95531: PPUSH
95532: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95536: LD_VAR 0 1
95540: PPUSH
95541: LD_INT 22
95543: PUSH
95544: LD_OWVAR 2
95548: PUSH
95549: EMPTY
95550: LIST
95551: LIST
95552: PPUSH
95553: CALL_OW 69
95557: PPUSH
95558: LD_VAR 0 1
95562: PPUSH
95563: CALL_OW 74
95567: PPUSH
95568: CALL_OW 115
// until IsDead ( un ) ;
95572: LD_VAR 0 1
95576: PPUSH
95577: CALL_OW 301
95581: IFFALSE 95529
// end ;
95583: PPOPN 1
95585: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
95586: LD_EXP 123
95590: PUSH
95591: LD_EXP 163
95595: AND
95596: IFFALSE 95608
95598: GO 95600
95600: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
95601: LD_STRING earthquake(getX(game), 0, 32)
95603: PPUSH
95604: CALL_OW 559
95608: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
95609: LD_EXP 123
95613: PUSH
95614: LD_EXP 164
95618: AND
95619: IFFALSE 95710
95621: GO 95623
95623: DISABLE
95624: LD_INT 0
95626: PPUSH
// begin enable ;
95627: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
95628: LD_ADDR_VAR 0 1
95632: PUSH
95633: LD_INT 22
95635: PUSH
95636: LD_OWVAR 2
95640: PUSH
95641: EMPTY
95642: LIST
95643: LIST
95644: PUSH
95645: LD_INT 21
95647: PUSH
95648: LD_INT 2
95650: PUSH
95651: EMPTY
95652: LIST
95653: LIST
95654: PUSH
95655: LD_INT 33
95657: PUSH
95658: LD_INT 3
95660: PUSH
95661: EMPTY
95662: LIST
95663: LIST
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: LIST
95669: PPUSH
95670: CALL_OW 69
95674: ST_TO_ADDR
// if not tmp then
95675: LD_VAR 0 1
95679: NOT
95680: IFFALSE 95684
// exit ;
95682: GO 95710
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95684: LD_VAR 0 1
95688: PUSH
95689: LD_INT 1
95691: PPUSH
95692: LD_VAR 0 1
95696: PPUSH
95697: CALL_OW 12
95701: ARRAY
95702: PPUSH
95703: LD_INT 1
95705: PPUSH
95706: CALL_OW 234
// end ;
95710: PPOPN 1
95712: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
95713: LD_EXP 123
95717: PUSH
95718: LD_EXP 165
95722: AND
95723: IFFALSE 95864
95725: GO 95727
95727: DISABLE
95728: LD_INT 0
95730: PPUSH
95731: PPUSH
95732: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95733: LD_ADDR_VAR 0 3
95737: PUSH
95738: LD_INT 22
95740: PUSH
95741: LD_OWVAR 2
95745: PUSH
95746: EMPTY
95747: LIST
95748: LIST
95749: PUSH
95750: LD_INT 25
95752: PUSH
95753: LD_INT 1
95755: PUSH
95756: EMPTY
95757: LIST
95758: LIST
95759: PUSH
95760: EMPTY
95761: LIST
95762: LIST
95763: PPUSH
95764: CALL_OW 69
95768: ST_TO_ADDR
// if not tmp then
95769: LD_VAR 0 3
95773: NOT
95774: IFFALSE 95778
// exit ;
95776: GO 95864
// un := tmp [ rand ( 1 , tmp ) ] ;
95778: LD_ADDR_VAR 0 2
95782: PUSH
95783: LD_VAR 0 3
95787: PUSH
95788: LD_INT 1
95790: PPUSH
95791: LD_VAR 0 3
95795: PPUSH
95796: CALL_OW 12
95800: ARRAY
95801: ST_TO_ADDR
// if Crawls ( un ) then
95802: LD_VAR 0 2
95806: PPUSH
95807: CALL_OW 318
95811: IFFALSE 95822
// ComWalk ( un ) ;
95813: LD_VAR 0 2
95817: PPUSH
95818: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
95822: LD_VAR 0 2
95826: PPUSH
95827: LD_INT 9
95829: PPUSH
95830: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
95834: LD_INT 28
95836: PPUSH
95837: LD_OWVAR 2
95841: PPUSH
95842: LD_INT 2
95844: PPUSH
95845: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
95849: LD_INT 29
95851: PPUSH
95852: LD_OWVAR 2
95856: PPUSH
95857: LD_INT 2
95859: PPUSH
95860: CALL_OW 322
// end ;
95864: PPOPN 3
95866: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
95867: LD_EXP 123
95871: PUSH
95872: LD_EXP 166
95876: AND
95877: IFFALSE 95988
95879: GO 95881
95881: DISABLE
95882: LD_INT 0
95884: PPUSH
95885: PPUSH
95886: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95887: LD_ADDR_VAR 0 3
95891: PUSH
95892: LD_INT 22
95894: PUSH
95895: LD_OWVAR 2
95899: PUSH
95900: EMPTY
95901: LIST
95902: LIST
95903: PUSH
95904: LD_INT 25
95906: PUSH
95907: LD_INT 1
95909: PUSH
95910: EMPTY
95911: LIST
95912: LIST
95913: PUSH
95914: EMPTY
95915: LIST
95916: LIST
95917: PPUSH
95918: CALL_OW 69
95922: ST_TO_ADDR
// if not tmp then
95923: LD_VAR 0 3
95927: NOT
95928: IFFALSE 95932
// exit ;
95930: GO 95988
// un := tmp [ rand ( 1 , tmp ) ] ;
95932: LD_ADDR_VAR 0 2
95936: PUSH
95937: LD_VAR 0 3
95941: PUSH
95942: LD_INT 1
95944: PPUSH
95945: LD_VAR 0 3
95949: PPUSH
95950: CALL_OW 12
95954: ARRAY
95955: ST_TO_ADDR
// if Crawls ( un ) then
95956: LD_VAR 0 2
95960: PPUSH
95961: CALL_OW 318
95965: IFFALSE 95976
// ComWalk ( un ) ;
95967: LD_VAR 0 2
95971: PPUSH
95972: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95976: LD_VAR 0 2
95980: PPUSH
95981: LD_INT 8
95983: PPUSH
95984: CALL_OW 336
// end ;
95988: PPOPN 3
95990: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
95991: LD_EXP 123
95995: PUSH
95996: LD_EXP 167
96000: AND
96001: IFFALSE 96145
96003: GO 96005
96005: DISABLE
96006: LD_INT 0
96008: PPUSH
96009: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96010: LD_ADDR_VAR 0 2
96014: PUSH
96015: LD_INT 22
96017: PUSH
96018: LD_OWVAR 2
96022: PUSH
96023: EMPTY
96024: LIST
96025: LIST
96026: PUSH
96027: LD_INT 21
96029: PUSH
96030: LD_INT 2
96032: PUSH
96033: EMPTY
96034: LIST
96035: LIST
96036: PUSH
96037: LD_INT 2
96039: PUSH
96040: LD_INT 34
96042: PUSH
96043: LD_INT 12
96045: PUSH
96046: EMPTY
96047: LIST
96048: LIST
96049: PUSH
96050: LD_INT 34
96052: PUSH
96053: LD_INT 51
96055: PUSH
96056: EMPTY
96057: LIST
96058: LIST
96059: PUSH
96060: LD_INT 34
96062: PUSH
96063: LD_INT 32
96065: PUSH
96066: EMPTY
96067: LIST
96068: LIST
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: PUSH
96076: EMPTY
96077: LIST
96078: LIST
96079: LIST
96080: PPUSH
96081: CALL_OW 69
96085: ST_TO_ADDR
// if not tmp then
96086: LD_VAR 0 2
96090: NOT
96091: IFFALSE 96095
// exit ;
96093: GO 96145
// for i in tmp do
96095: LD_ADDR_VAR 0 1
96099: PUSH
96100: LD_VAR 0 2
96104: PUSH
96105: FOR_IN
96106: IFFALSE 96143
// if GetCargo ( i , mat_artifact ) = 0 then
96108: LD_VAR 0 1
96112: PPUSH
96113: LD_INT 4
96115: PPUSH
96116: CALL_OW 289
96120: PUSH
96121: LD_INT 0
96123: EQUAL
96124: IFFALSE 96141
// SetCargo ( i , mat_siberit , 100 ) ;
96126: LD_VAR 0 1
96130: PPUSH
96131: LD_INT 3
96133: PPUSH
96134: LD_INT 100
96136: PPUSH
96137: CALL_OW 290
96141: GO 96105
96143: POP
96144: POP
// end ;
96145: PPOPN 2
96147: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96148: LD_EXP 123
96152: PUSH
96153: LD_EXP 168
96157: AND
96158: IFFALSE 96341
96160: GO 96162
96162: DISABLE
96163: LD_INT 0
96165: PPUSH
96166: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96167: LD_ADDR_VAR 0 2
96171: PUSH
96172: LD_INT 22
96174: PUSH
96175: LD_OWVAR 2
96179: PUSH
96180: EMPTY
96181: LIST
96182: LIST
96183: PPUSH
96184: CALL_OW 69
96188: ST_TO_ADDR
// if not tmp then
96189: LD_VAR 0 2
96193: NOT
96194: IFFALSE 96198
// exit ;
96196: GO 96341
// for i := 1 to 2 do
96198: LD_ADDR_VAR 0 1
96202: PUSH
96203: DOUBLE
96204: LD_INT 1
96206: DEC
96207: ST_TO_ADDR
96208: LD_INT 2
96210: PUSH
96211: FOR_TO
96212: IFFALSE 96339
// begin uc_side := your_side ;
96214: LD_ADDR_OWVAR 20
96218: PUSH
96219: LD_OWVAR 2
96223: ST_TO_ADDR
// uc_nation := nation_american ;
96224: LD_ADDR_OWVAR 21
96228: PUSH
96229: LD_INT 1
96231: ST_TO_ADDR
// vc_chassis := us_morphling ;
96232: LD_ADDR_OWVAR 37
96236: PUSH
96237: LD_INT 5
96239: ST_TO_ADDR
// vc_engine := engine_siberite ;
96240: LD_ADDR_OWVAR 39
96244: PUSH
96245: LD_INT 3
96247: ST_TO_ADDR
// vc_control := control_computer ;
96248: LD_ADDR_OWVAR 38
96252: PUSH
96253: LD_INT 3
96255: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96256: LD_ADDR_OWVAR 40
96260: PUSH
96261: LD_INT 10
96263: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
96264: LD_VAR 0 2
96268: PUSH
96269: LD_INT 1
96271: ARRAY
96272: PPUSH
96273: CALL_OW 310
96277: NOT
96278: IFFALSE 96325
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
96280: CALL_OW 45
96284: PPUSH
96285: LD_VAR 0 2
96289: PUSH
96290: LD_INT 1
96292: ARRAY
96293: PPUSH
96294: CALL_OW 250
96298: PPUSH
96299: LD_VAR 0 2
96303: PUSH
96304: LD_INT 1
96306: ARRAY
96307: PPUSH
96308: CALL_OW 251
96312: PPUSH
96313: LD_INT 12
96315: PPUSH
96316: LD_INT 1
96318: PPUSH
96319: CALL_OW 50
96323: GO 96337
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
96325: CALL_OW 45
96329: PPUSH
96330: LD_INT 1
96332: PPUSH
96333: CALL_OW 51
// end ;
96337: GO 96211
96339: POP
96340: POP
// end ;
96341: PPOPN 2
96343: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
96344: LD_EXP 123
96348: PUSH
96349: LD_EXP 169
96353: AND
96354: IFFALSE 96576
96356: GO 96358
96358: DISABLE
96359: LD_INT 0
96361: PPUSH
96362: PPUSH
96363: PPUSH
96364: PPUSH
96365: PPUSH
96366: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96367: LD_ADDR_VAR 0 6
96371: PUSH
96372: LD_INT 22
96374: PUSH
96375: LD_OWVAR 2
96379: PUSH
96380: EMPTY
96381: LIST
96382: LIST
96383: PUSH
96384: LD_INT 21
96386: PUSH
96387: LD_INT 1
96389: PUSH
96390: EMPTY
96391: LIST
96392: LIST
96393: PUSH
96394: LD_INT 3
96396: PUSH
96397: LD_INT 23
96399: PUSH
96400: LD_INT 0
96402: PUSH
96403: EMPTY
96404: LIST
96405: LIST
96406: PUSH
96407: EMPTY
96408: LIST
96409: LIST
96410: PUSH
96411: EMPTY
96412: LIST
96413: LIST
96414: LIST
96415: PPUSH
96416: CALL_OW 69
96420: ST_TO_ADDR
// if not tmp then
96421: LD_VAR 0 6
96425: NOT
96426: IFFALSE 96430
// exit ;
96428: GO 96576
// s1 := rand ( 1 , 4 ) ;
96430: LD_ADDR_VAR 0 2
96434: PUSH
96435: LD_INT 1
96437: PPUSH
96438: LD_INT 4
96440: PPUSH
96441: CALL_OW 12
96445: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
96446: LD_ADDR_VAR 0 4
96450: PUSH
96451: LD_VAR 0 6
96455: PUSH
96456: LD_INT 1
96458: ARRAY
96459: PPUSH
96460: LD_VAR 0 2
96464: PPUSH
96465: CALL_OW 259
96469: ST_TO_ADDR
// if s1 = 1 then
96470: LD_VAR 0 2
96474: PUSH
96475: LD_INT 1
96477: EQUAL
96478: IFFALSE 96498
// s2 := rand ( 2 , 4 ) else
96480: LD_ADDR_VAR 0 3
96484: PUSH
96485: LD_INT 2
96487: PPUSH
96488: LD_INT 4
96490: PPUSH
96491: CALL_OW 12
96495: ST_TO_ADDR
96496: GO 96506
// s2 := 1 ;
96498: LD_ADDR_VAR 0 3
96502: PUSH
96503: LD_INT 1
96505: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
96506: LD_ADDR_VAR 0 5
96510: PUSH
96511: LD_VAR 0 6
96515: PUSH
96516: LD_INT 1
96518: ARRAY
96519: PPUSH
96520: LD_VAR 0 3
96524: PPUSH
96525: CALL_OW 259
96529: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
96530: LD_VAR 0 6
96534: PUSH
96535: LD_INT 1
96537: ARRAY
96538: PPUSH
96539: LD_VAR 0 2
96543: PPUSH
96544: LD_VAR 0 5
96548: PPUSH
96549: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
96553: LD_VAR 0 6
96557: PUSH
96558: LD_INT 1
96560: ARRAY
96561: PPUSH
96562: LD_VAR 0 3
96566: PPUSH
96567: LD_VAR 0 4
96571: PPUSH
96572: CALL_OW 237
// end ;
96576: PPOPN 6
96578: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
96579: LD_EXP 123
96583: PUSH
96584: LD_EXP 170
96588: AND
96589: IFFALSE 96668
96591: GO 96593
96593: DISABLE
96594: LD_INT 0
96596: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
96597: LD_ADDR_VAR 0 1
96601: PUSH
96602: LD_INT 22
96604: PUSH
96605: LD_OWVAR 2
96609: PUSH
96610: EMPTY
96611: LIST
96612: LIST
96613: PUSH
96614: LD_INT 30
96616: PUSH
96617: LD_INT 3
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: PUSH
96624: EMPTY
96625: LIST
96626: LIST
96627: PPUSH
96628: CALL_OW 69
96632: ST_TO_ADDR
// if not tmp then
96633: LD_VAR 0 1
96637: NOT
96638: IFFALSE 96642
// exit ;
96640: GO 96668
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96642: LD_VAR 0 1
96646: PUSH
96647: LD_INT 1
96649: PPUSH
96650: LD_VAR 0 1
96654: PPUSH
96655: CALL_OW 12
96659: ARRAY
96660: PPUSH
96661: LD_INT 1
96663: PPUSH
96664: CALL_OW 234
// end ;
96668: PPOPN 1
96670: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
96671: LD_EXP 123
96675: PUSH
96676: LD_EXP 171
96680: AND
96681: IFFALSE 96793
96683: GO 96685
96685: DISABLE
96686: LD_INT 0
96688: PPUSH
96689: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
96690: LD_ADDR_VAR 0 2
96694: PUSH
96695: LD_INT 22
96697: PUSH
96698: LD_OWVAR 2
96702: PUSH
96703: EMPTY
96704: LIST
96705: LIST
96706: PUSH
96707: LD_INT 2
96709: PUSH
96710: LD_INT 30
96712: PUSH
96713: LD_INT 27
96715: PUSH
96716: EMPTY
96717: LIST
96718: LIST
96719: PUSH
96720: LD_INT 30
96722: PUSH
96723: LD_INT 26
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: PUSH
96730: LD_INT 30
96732: PUSH
96733: LD_INT 28
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: EMPTY
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: PUSH
96746: EMPTY
96747: LIST
96748: LIST
96749: PPUSH
96750: CALL_OW 69
96754: ST_TO_ADDR
// if not tmp then
96755: LD_VAR 0 2
96759: NOT
96760: IFFALSE 96764
// exit ;
96762: GO 96793
// for i in tmp do
96764: LD_ADDR_VAR 0 1
96768: PUSH
96769: LD_VAR 0 2
96773: PUSH
96774: FOR_IN
96775: IFFALSE 96791
// SetLives ( i , 1 ) ;
96777: LD_VAR 0 1
96781: PPUSH
96782: LD_INT 1
96784: PPUSH
96785: CALL_OW 234
96789: GO 96774
96791: POP
96792: POP
// end ;
96793: PPOPN 2
96795: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
96796: LD_EXP 123
96800: PUSH
96801: LD_EXP 172
96805: AND
96806: IFFALSE 97093
96808: GO 96810
96810: DISABLE
96811: LD_INT 0
96813: PPUSH
96814: PPUSH
96815: PPUSH
// begin i := rand ( 1 , 7 ) ;
96816: LD_ADDR_VAR 0 1
96820: PUSH
96821: LD_INT 1
96823: PPUSH
96824: LD_INT 7
96826: PPUSH
96827: CALL_OW 12
96831: ST_TO_ADDR
// case i of 1 :
96832: LD_VAR 0 1
96836: PUSH
96837: LD_INT 1
96839: DOUBLE
96840: EQUAL
96841: IFTRUE 96845
96843: GO 96855
96845: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
96846: LD_STRING earthquake(getX(game), 0, 32)
96848: PPUSH
96849: CALL_OW 559
96853: GO 97093
96855: LD_INT 2
96857: DOUBLE
96858: EQUAL
96859: IFTRUE 96863
96861: GO 96877
96863: POP
// begin ToLua ( displayStucuk(); ) ;
96864: LD_STRING displayStucuk();
96866: PPUSH
96867: CALL_OW 559
// ResetFog ;
96871: CALL_OW 335
// end ; 3 :
96875: GO 97093
96877: LD_INT 3
96879: DOUBLE
96880: EQUAL
96881: IFTRUE 96885
96883: GO 96989
96885: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96886: LD_ADDR_VAR 0 2
96890: PUSH
96891: LD_INT 22
96893: PUSH
96894: LD_OWVAR 2
96898: PUSH
96899: EMPTY
96900: LIST
96901: LIST
96902: PUSH
96903: LD_INT 25
96905: PUSH
96906: LD_INT 1
96908: PUSH
96909: EMPTY
96910: LIST
96911: LIST
96912: PUSH
96913: EMPTY
96914: LIST
96915: LIST
96916: PPUSH
96917: CALL_OW 69
96921: ST_TO_ADDR
// if not tmp then
96922: LD_VAR 0 2
96926: NOT
96927: IFFALSE 96931
// exit ;
96929: GO 97093
// un := tmp [ rand ( 1 , tmp ) ] ;
96931: LD_ADDR_VAR 0 3
96935: PUSH
96936: LD_VAR 0 2
96940: PUSH
96941: LD_INT 1
96943: PPUSH
96944: LD_VAR 0 2
96948: PPUSH
96949: CALL_OW 12
96953: ARRAY
96954: ST_TO_ADDR
// if Crawls ( un ) then
96955: LD_VAR 0 3
96959: PPUSH
96960: CALL_OW 318
96964: IFFALSE 96975
// ComWalk ( un ) ;
96966: LD_VAR 0 3
96970: PPUSH
96971: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96975: LD_VAR 0 3
96979: PPUSH
96980: LD_INT 8
96982: PPUSH
96983: CALL_OW 336
// end ; 4 :
96987: GO 97093
96989: LD_INT 4
96991: DOUBLE
96992: EQUAL
96993: IFTRUE 96997
96995: GO 97071
96997: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96998: LD_ADDR_VAR 0 2
97002: PUSH
97003: LD_INT 22
97005: PUSH
97006: LD_OWVAR 2
97010: PUSH
97011: EMPTY
97012: LIST
97013: LIST
97014: PUSH
97015: LD_INT 30
97017: PUSH
97018: LD_INT 29
97020: PUSH
97021: EMPTY
97022: LIST
97023: LIST
97024: PUSH
97025: EMPTY
97026: LIST
97027: LIST
97028: PPUSH
97029: CALL_OW 69
97033: ST_TO_ADDR
// if not tmp then
97034: LD_VAR 0 2
97038: NOT
97039: IFFALSE 97043
// exit ;
97041: GO 97093
// CenterNowOnUnits ( tmp [ 1 ] ) ;
97043: LD_VAR 0 2
97047: PUSH
97048: LD_INT 1
97050: ARRAY
97051: PPUSH
97052: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
97056: LD_VAR 0 2
97060: PUSH
97061: LD_INT 1
97063: ARRAY
97064: PPUSH
97065: CALL_OW 65
// end ; 5 .. 7 :
97069: GO 97093
97071: LD_INT 5
97073: DOUBLE
97074: GREATEREQUAL
97075: IFFALSE 97083
97077: LD_INT 7
97079: DOUBLE
97080: LESSEQUAL
97081: IFTRUE 97085
97083: GO 97092
97085: POP
// StreamSibBomb ; end ;
97086: CALL 93330 0 0
97090: GO 97093
97092: POP
// end ;
97093: PPOPN 3
97095: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97096: LD_EXP 123
97100: PUSH
97101: LD_EXP 173
97105: AND
97106: IFFALSE 97262
97108: GO 97110
97110: DISABLE
97111: LD_INT 0
97113: PPUSH
97114: PPUSH
97115: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97116: LD_ADDR_VAR 0 2
97120: PUSH
97121: LD_INT 81
97123: PUSH
97124: LD_OWVAR 2
97128: PUSH
97129: EMPTY
97130: LIST
97131: LIST
97132: PUSH
97133: LD_INT 2
97135: PUSH
97136: LD_INT 21
97138: PUSH
97139: LD_INT 1
97141: PUSH
97142: EMPTY
97143: LIST
97144: LIST
97145: PUSH
97146: LD_INT 21
97148: PUSH
97149: LD_INT 2
97151: PUSH
97152: EMPTY
97153: LIST
97154: LIST
97155: PUSH
97156: EMPTY
97157: LIST
97158: LIST
97159: LIST
97160: PUSH
97161: EMPTY
97162: LIST
97163: LIST
97164: PPUSH
97165: CALL_OW 69
97169: ST_TO_ADDR
// if not tmp then
97170: LD_VAR 0 2
97174: NOT
97175: IFFALSE 97179
// exit ;
97177: GO 97262
// p := 0 ;
97179: LD_ADDR_VAR 0 3
97183: PUSH
97184: LD_INT 0
97186: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97187: LD_INT 35
97189: PPUSH
97190: CALL_OW 67
// p := p + 1 ;
97194: LD_ADDR_VAR 0 3
97198: PUSH
97199: LD_VAR 0 3
97203: PUSH
97204: LD_INT 1
97206: PLUS
97207: ST_TO_ADDR
// for i in tmp do
97208: LD_ADDR_VAR 0 1
97212: PUSH
97213: LD_VAR 0 2
97217: PUSH
97218: FOR_IN
97219: IFFALSE 97250
// if GetLives ( i ) < 1000 then
97221: LD_VAR 0 1
97225: PPUSH
97226: CALL_OW 256
97230: PUSH
97231: LD_INT 1000
97233: LESS
97234: IFFALSE 97248
// SetLives ( i , 1000 ) ;
97236: LD_VAR 0 1
97240: PPUSH
97241: LD_INT 1000
97243: PPUSH
97244: CALL_OW 234
97248: GO 97218
97250: POP
97251: POP
// until p > 20 ;
97252: LD_VAR 0 3
97256: PUSH
97257: LD_INT 20
97259: GREATER
97260: IFFALSE 97187
// end ;
97262: PPOPN 3
97264: END
// every 0 0$1 trigger StreamModeActive and sTime do
97265: LD_EXP 123
97269: PUSH
97270: LD_EXP 174
97274: AND
97275: IFFALSE 97310
97277: GO 97279
97279: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97280: LD_INT 28
97282: PPUSH
97283: LD_OWVAR 2
97287: PPUSH
97288: LD_INT 2
97290: PPUSH
97291: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97295: LD_INT 30
97297: PPUSH
97298: LD_OWVAR 2
97302: PPUSH
97303: LD_INT 2
97305: PPUSH
97306: CALL_OW 322
// end ;
97310: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97311: LD_EXP 123
97315: PUSH
97316: LD_EXP 175
97320: AND
97321: IFFALSE 97442
97323: GO 97325
97325: DISABLE
97326: LD_INT 0
97328: PPUSH
97329: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97330: LD_ADDR_VAR 0 2
97334: PUSH
97335: LD_INT 22
97337: PUSH
97338: LD_OWVAR 2
97342: PUSH
97343: EMPTY
97344: LIST
97345: LIST
97346: PUSH
97347: LD_INT 21
97349: PUSH
97350: LD_INT 1
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: PUSH
97357: LD_INT 3
97359: PUSH
97360: LD_INT 23
97362: PUSH
97363: LD_INT 0
97365: PUSH
97366: EMPTY
97367: LIST
97368: LIST
97369: PUSH
97370: EMPTY
97371: LIST
97372: LIST
97373: PUSH
97374: EMPTY
97375: LIST
97376: LIST
97377: LIST
97378: PPUSH
97379: CALL_OW 69
97383: ST_TO_ADDR
// if not tmp then
97384: LD_VAR 0 2
97388: NOT
97389: IFFALSE 97393
// exit ;
97391: GO 97442
// for i in tmp do
97393: LD_ADDR_VAR 0 1
97397: PUSH
97398: LD_VAR 0 2
97402: PUSH
97403: FOR_IN
97404: IFFALSE 97440
// begin if Crawls ( i ) then
97406: LD_VAR 0 1
97410: PPUSH
97411: CALL_OW 318
97415: IFFALSE 97426
// ComWalk ( i ) ;
97417: LD_VAR 0 1
97421: PPUSH
97422: CALL_OW 138
// SetClass ( i , 2 ) ;
97426: LD_VAR 0 1
97430: PPUSH
97431: LD_INT 2
97433: PPUSH
97434: CALL_OW 336
// end ;
97438: GO 97403
97440: POP
97441: POP
// end ;
97442: PPOPN 2
97444: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
97445: LD_EXP 123
97449: PUSH
97450: LD_EXP 176
97454: AND
97455: IFFALSE 97743
97457: GO 97459
97459: DISABLE
97460: LD_INT 0
97462: PPUSH
97463: PPUSH
97464: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
97465: LD_OWVAR 2
97469: PPUSH
97470: LD_INT 9
97472: PPUSH
97473: LD_INT 1
97475: PPUSH
97476: LD_INT 1
97478: PPUSH
97479: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
97483: LD_INT 9
97485: PPUSH
97486: LD_OWVAR 2
97490: PPUSH
97491: CALL_OW 343
// uc_side := 9 ;
97495: LD_ADDR_OWVAR 20
97499: PUSH
97500: LD_INT 9
97502: ST_TO_ADDR
// uc_nation := 2 ;
97503: LD_ADDR_OWVAR 21
97507: PUSH
97508: LD_INT 2
97510: ST_TO_ADDR
// hc_name := Dark Warrior ;
97511: LD_ADDR_OWVAR 26
97515: PUSH
97516: LD_STRING Dark Warrior
97518: ST_TO_ADDR
// hc_gallery :=  ;
97519: LD_ADDR_OWVAR 33
97523: PUSH
97524: LD_STRING 
97526: ST_TO_ADDR
// hc_noskilllimit := true ;
97527: LD_ADDR_OWVAR 76
97531: PUSH
97532: LD_INT 1
97534: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
97535: LD_ADDR_OWVAR 31
97539: PUSH
97540: LD_INT 30
97542: PUSH
97543: LD_INT 30
97545: PUSH
97546: LD_INT 30
97548: PUSH
97549: LD_INT 30
97551: PUSH
97552: EMPTY
97553: LIST
97554: LIST
97555: LIST
97556: LIST
97557: ST_TO_ADDR
// un := CreateHuman ;
97558: LD_ADDR_VAR 0 3
97562: PUSH
97563: CALL_OW 44
97567: ST_TO_ADDR
// hc_noskilllimit := false ;
97568: LD_ADDR_OWVAR 76
97572: PUSH
97573: LD_INT 0
97575: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97576: LD_VAR 0 3
97580: PPUSH
97581: LD_INT 1
97583: PPUSH
97584: CALL_OW 51
// ToLua ( playRanger() ) ;
97588: LD_STRING playRanger()
97590: PPUSH
97591: CALL_OW 559
// p := 0 ;
97595: LD_ADDR_VAR 0 2
97599: PUSH
97600: LD_INT 0
97602: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97603: LD_INT 35
97605: PPUSH
97606: CALL_OW 67
// p := p + 1 ;
97610: LD_ADDR_VAR 0 2
97614: PUSH
97615: LD_VAR 0 2
97619: PUSH
97620: LD_INT 1
97622: PLUS
97623: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
97624: LD_VAR 0 3
97628: PPUSH
97629: CALL_OW 256
97633: PUSH
97634: LD_INT 1000
97636: LESS
97637: IFFALSE 97651
// SetLives ( un , 1000 ) ;
97639: LD_VAR 0 3
97643: PPUSH
97644: LD_INT 1000
97646: PPUSH
97647: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
97651: LD_VAR 0 3
97655: PPUSH
97656: LD_INT 81
97658: PUSH
97659: LD_OWVAR 2
97663: PUSH
97664: EMPTY
97665: LIST
97666: LIST
97667: PUSH
97668: LD_INT 91
97670: PUSH
97671: LD_VAR 0 3
97675: PUSH
97676: LD_INT 30
97678: PUSH
97679: EMPTY
97680: LIST
97681: LIST
97682: LIST
97683: PUSH
97684: EMPTY
97685: LIST
97686: LIST
97687: PPUSH
97688: CALL_OW 69
97692: PPUSH
97693: LD_VAR 0 3
97697: PPUSH
97698: CALL_OW 74
97702: PPUSH
97703: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
97707: LD_VAR 0 2
97711: PUSH
97712: LD_INT 80
97714: GREATER
97715: PUSH
97716: LD_VAR 0 3
97720: PPUSH
97721: CALL_OW 301
97725: OR
97726: IFFALSE 97603
// if un then
97728: LD_VAR 0 3
97732: IFFALSE 97743
// RemoveUnit ( un ) ;
97734: LD_VAR 0 3
97738: PPUSH
97739: CALL_OW 64
// end ;
97743: PPOPN 3
97745: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
97746: LD_EXP 177
97750: IFFALSE 97866
97752: GO 97754
97754: DISABLE
97755: LD_INT 0
97757: PPUSH
97758: PPUSH
97759: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97760: LD_ADDR_VAR 0 2
97764: PUSH
97765: LD_INT 81
97767: PUSH
97768: LD_OWVAR 2
97772: PUSH
97773: EMPTY
97774: LIST
97775: LIST
97776: PUSH
97777: LD_INT 21
97779: PUSH
97780: LD_INT 1
97782: PUSH
97783: EMPTY
97784: LIST
97785: LIST
97786: PUSH
97787: EMPTY
97788: LIST
97789: LIST
97790: PPUSH
97791: CALL_OW 69
97795: ST_TO_ADDR
// ToLua ( playComputer() ) ;
97796: LD_STRING playComputer()
97798: PPUSH
97799: CALL_OW 559
// if not tmp then
97803: LD_VAR 0 2
97807: NOT
97808: IFFALSE 97812
// exit ;
97810: GO 97866
// for i in tmp do
97812: LD_ADDR_VAR 0 1
97816: PUSH
97817: LD_VAR 0 2
97821: PUSH
97822: FOR_IN
97823: IFFALSE 97864
// for j := 1 to 4 do
97825: LD_ADDR_VAR 0 3
97829: PUSH
97830: DOUBLE
97831: LD_INT 1
97833: DEC
97834: ST_TO_ADDR
97835: LD_INT 4
97837: PUSH
97838: FOR_TO
97839: IFFALSE 97860
// SetSkill ( i , j , 10 ) ;
97841: LD_VAR 0 1
97845: PPUSH
97846: LD_VAR 0 3
97850: PPUSH
97851: LD_INT 10
97853: PPUSH
97854: CALL_OW 237
97858: GO 97838
97860: POP
97861: POP
97862: GO 97822
97864: POP
97865: POP
// end ;
97866: PPOPN 3
97868: END
// every 0 0$1 trigger s30 do var i , tmp ;
97869: LD_EXP 178
97873: IFFALSE 97942
97875: GO 97877
97877: DISABLE
97878: LD_INT 0
97880: PPUSH
97881: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97882: LD_ADDR_VAR 0 2
97886: PUSH
97887: LD_INT 22
97889: PUSH
97890: LD_OWVAR 2
97894: PUSH
97895: EMPTY
97896: LIST
97897: LIST
97898: PPUSH
97899: CALL_OW 69
97903: ST_TO_ADDR
// if not tmp then
97904: LD_VAR 0 2
97908: NOT
97909: IFFALSE 97913
// exit ;
97911: GO 97942
// for i in tmp do
97913: LD_ADDR_VAR 0 1
97917: PUSH
97918: LD_VAR 0 2
97922: PUSH
97923: FOR_IN
97924: IFFALSE 97940
// SetLives ( i , 300 ) ;
97926: LD_VAR 0 1
97930: PPUSH
97931: LD_INT 300
97933: PPUSH
97934: CALL_OW 234
97938: GO 97923
97940: POP
97941: POP
// end ;
97942: PPOPN 2
97944: END
// every 0 0$1 trigger s60 do var i , tmp ;
97945: LD_EXP 179
97949: IFFALSE 98018
97951: GO 97953
97953: DISABLE
97954: LD_INT 0
97956: PPUSH
97957: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97958: LD_ADDR_VAR 0 2
97962: PUSH
97963: LD_INT 22
97965: PUSH
97966: LD_OWVAR 2
97970: PUSH
97971: EMPTY
97972: LIST
97973: LIST
97974: PPUSH
97975: CALL_OW 69
97979: ST_TO_ADDR
// if not tmp then
97980: LD_VAR 0 2
97984: NOT
97985: IFFALSE 97989
// exit ;
97987: GO 98018
// for i in tmp do
97989: LD_ADDR_VAR 0 1
97993: PUSH
97994: LD_VAR 0 2
97998: PUSH
97999: FOR_IN
98000: IFFALSE 98016
// SetLives ( i , 600 ) ;
98002: LD_VAR 0 1
98006: PPUSH
98007: LD_INT 600
98009: PPUSH
98010: CALL_OW 234
98014: GO 97999
98016: POP
98017: POP
// end ;
98018: PPOPN 2
98020: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
98021: LD_INT 0
98023: PPUSH
// case cmd of 301 :
98024: LD_VAR 0 1
98028: PUSH
98029: LD_INT 301
98031: DOUBLE
98032: EQUAL
98033: IFTRUE 98037
98035: GO 98069
98037: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
98038: LD_VAR 0 6
98042: PPUSH
98043: LD_VAR 0 7
98047: PPUSH
98048: LD_VAR 0 8
98052: PPUSH
98053: LD_VAR 0 4
98057: PPUSH
98058: LD_VAR 0 5
98062: PPUSH
98063: CALL 99270 0 5
98067: GO 98190
98069: LD_INT 302
98071: DOUBLE
98072: EQUAL
98073: IFTRUE 98077
98075: GO 98114
98077: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
98078: LD_VAR 0 6
98082: PPUSH
98083: LD_VAR 0 7
98087: PPUSH
98088: LD_VAR 0 8
98092: PPUSH
98093: LD_VAR 0 9
98097: PPUSH
98098: LD_VAR 0 4
98102: PPUSH
98103: LD_VAR 0 5
98107: PPUSH
98108: CALL 99361 0 6
98112: GO 98190
98114: LD_INT 303
98116: DOUBLE
98117: EQUAL
98118: IFTRUE 98122
98120: GO 98159
98122: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
98123: LD_VAR 0 6
98127: PPUSH
98128: LD_VAR 0 7
98132: PPUSH
98133: LD_VAR 0 8
98137: PPUSH
98138: LD_VAR 0 9
98142: PPUSH
98143: LD_VAR 0 4
98147: PPUSH
98148: LD_VAR 0 5
98152: PPUSH
98153: CALL 98195 0 6
98157: GO 98190
98159: LD_INT 304
98161: DOUBLE
98162: EQUAL
98163: IFTRUE 98167
98165: GO 98189
98167: POP
// hHackTeleport ( unit , x , y ) ; end ;
98168: LD_VAR 0 2
98172: PPUSH
98173: LD_VAR 0 4
98177: PPUSH
98178: LD_VAR 0 5
98182: PPUSH
98183: CALL 99954 0 3
98187: GO 98190
98189: POP
// end ;
98190: LD_VAR 0 12
98194: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
98195: LD_INT 0
98197: PPUSH
98198: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
98199: LD_VAR 0 1
98203: PUSH
98204: LD_INT 1
98206: LESS
98207: PUSH
98208: LD_VAR 0 1
98212: PUSH
98213: LD_INT 3
98215: GREATER
98216: OR
98217: PUSH
98218: LD_VAR 0 5
98222: PPUSH
98223: LD_VAR 0 6
98227: PPUSH
98228: CALL_OW 428
98232: OR
98233: IFFALSE 98237
// exit ;
98235: GO 98957
// uc_side := your_side ;
98237: LD_ADDR_OWVAR 20
98241: PUSH
98242: LD_OWVAR 2
98246: ST_TO_ADDR
// uc_nation := nation ;
98247: LD_ADDR_OWVAR 21
98251: PUSH
98252: LD_VAR 0 1
98256: ST_TO_ADDR
// bc_level = 1 ;
98257: LD_ADDR_OWVAR 43
98261: PUSH
98262: LD_INT 1
98264: ST_TO_ADDR
// case btype of 1 :
98265: LD_VAR 0 2
98269: PUSH
98270: LD_INT 1
98272: DOUBLE
98273: EQUAL
98274: IFTRUE 98278
98276: GO 98289
98278: POP
// bc_type := b_depot ; 2 :
98279: LD_ADDR_OWVAR 42
98283: PUSH
98284: LD_INT 0
98286: ST_TO_ADDR
98287: GO 98901
98289: LD_INT 2
98291: DOUBLE
98292: EQUAL
98293: IFTRUE 98297
98295: GO 98308
98297: POP
// bc_type := b_warehouse ; 3 :
98298: LD_ADDR_OWVAR 42
98302: PUSH
98303: LD_INT 1
98305: ST_TO_ADDR
98306: GO 98901
98308: LD_INT 3
98310: DOUBLE
98311: EQUAL
98312: IFTRUE 98316
98314: GO 98327
98316: POP
// bc_type := b_lab ; 4 .. 9 :
98317: LD_ADDR_OWVAR 42
98321: PUSH
98322: LD_INT 6
98324: ST_TO_ADDR
98325: GO 98901
98327: LD_INT 4
98329: DOUBLE
98330: GREATEREQUAL
98331: IFFALSE 98339
98333: LD_INT 9
98335: DOUBLE
98336: LESSEQUAL
98337: IFTRUE 98341
98339: GO 98393
98341: POP
// begin bc_type := b_lab_half ;
98342: LD_ADDR_OWVAR 42
98346: PUSH
98347: LD_INT 7
98349: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
98350: LD_ADDR_OWVAR 44
98354: PUSH
98355: LD_INT 10
98357: PUSH
98358: LD_INT 11
98360: PUSH
98361: LD_INT 12
98363: PUSH
98364: LD_INT 15
98366: PUSH
98367: LD_INT 14
98369: PUSH
98370: LD_INT 13
98372: PUSH
98373: EMPTY
98374: LIST
98375: LIST
98376: LIST
98377: LIST
98378: LIST
98379: LIST
98380: PUSH
98381: LD_VAR 0 2
98385: PUSH
98386: LD_INT 3
98388: MINUS
98389: ARRAY
98390: ST_TO_ADDR
// end ; 10 .. 13 :
98391: GO 98901
98393: LD_INT 10
98395: DOUBLE
98396: GREATEREQUAL
98397: IFFALSE 98405
98399: LD_INT 13
98401: DOUBLE
98402: LESSEQUAL
98403: IFTRUE 98407
98405: GO 98484
98407: POP
// begin bc_type := b_lab_full ;
98408: LD_ADDR_OWVAR 42
98412: PUSH
98413: LD_INT 8
98415: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
98416: LD_ADDR_OWVAR 44
98420: PUSH
98421: LD_INT 10
98423: PUSH
98424: LD_INT 12
98426: PUSH
98427: LD_INT 14
98429: PUSH
98430: LD_INT 13
98432: PUSH
98433: EMPTY
98434: LIST
98435: LIST
98436: LIST
98437: LIST
98438: PUSH
98439: LD_VAR 0 2
98443: PUSH
98444: LD_INT 9
98446: MINUS
98447: ARRAY
98448: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
98449: LD_ADDR_OWVAR 45
98453: PUSH
98454: LD_INT 11
98456: PUSH
98457: LD_INT 15
98459: PUSH
98460: LD_INT 12
98462: PUSH
98463: LD_INT 15
98465: PUSH
98466: EMPTY
98467: LIST
98468: LIST
98469: LIST
98470: LIST
98471: PUSH
98472: LD_VAR 0 2
98476: PUSH
98477: LD_INT 9
98479: MINUS
98480: ARRAY
98481: ST_TO_ADDR
// end ; 14 :
98482: GO 98901
98484: LD_INT 14
98486: DOUBLE
98487: EQUAL
98488: IFTRUE 98492
98490: GO 98503
98492: POP
// bc_type := b_workshop ; 15 :
98493: LD_ADDR_OWVAR 42
98497: PUSH
98498: LD_INT 2
98500: ST_TO_ADDR
98501: GO 98901
98503: LD_INT 15
98505: DOUBLE
98506: EQUAL
98507: IFTRUE 98511
98509: GO 98522
98511: POP
// bc_type := b_factory ; 16 :
98512: LD_ADDR_OWVAR 42
98516: PUSH
98517: LD_INT 3
98519: ST_TO_ADDR
98520: GO 98901
98522: LD_INT 16
98524: DOUBLE
98525: EQUAL
98526: IFTRUE 98530
98528: GO 98541
98530: POP
// bc_type := b_ext_gun ; 17 :
98531: LD_ADDR_OWVAR 42
98535: PUSH
98536: LD_INT 17
98538: ST_TO_ADDR
98539: GO 98901
98541: LD_INT 17
98543: DOUBLE
98544: EQUAL
98545: IFTRUE 98549
98547: GO 98577
98549: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
98550: LD_ADDR_OWVAR 42
98554: PUSH
98555: LD_INT 19
98557: PUSH
98558: LD_INT 23
98560: PUSH
98561: LD_INT 19
98563: PUSH
98564: EMPTY
98565: LIST
98566: LIST
98567: LIST
98568: PUSH
98569: LD_VAR 0 1
98573: ARRAY
98574: ST_TO_ADDR
98575: GO 98901
98577: LD_INT 18
98579: DOUBLE
98580: EQUAL
98581: IFTRUE 98585
98583: GO 98596
98585: POP
// bc_type := b_ext_radar ; 19 :
98586: LD_ADDR_OWVAR 42
98590: PUSH
98591: LD_INT 20
98593: ST_TO_ADDR
98594: GO 98901
98596: LD_INT 19
98598: DOUBLE
98599: EQUAL
98600: IFTRUE 98604
98602: GO 98615
98604: POP
// bc_type := b_ext_radio ; 20 :
98605: LD_ADDR_OWVAR 42
98609: PUSH
98610: LD_INT 22
98612: ST_TO_ADDR
98613: GO 98901
98615: LD_INT 20
98617: DOUBLE
98618: EQUAL
98619: IFTRUE 98623
98621: GO 98634
98623: POP
// bc_type := b_ext_siberium ; 21 :
98624: LD_ADDR_OWVAR 42
98628: PUSH
98629: LD_INT 21
98631: ST_TO_ADDR
98632: GO 98901
98634: LD_INT 21
98636: DOUBLE
98637: EQUAL
98638: IFTRUE 98642
98640: GO 98653
98642: POP
// bc_type := b_ext_computer ; 22 :
98643: LD_ADDR_OWVAR 42
98647: PUSH
98648: LD_INT 24
98650: ST_TO_ADDR
98651: GO 98901
98653: LD_INT 22
98655: DOUBLE
98656: EQUAL
98657: IFTRUE 98661
98659: GO 98672
98661: POP
// bc_type := b_ext_track ; 23 :
98662: LD_ADDR_OWVAR 42
98666: PUSH
98667: LD_INT 16
98669: ST_TO_ADDR
98670: GO 98901
98672: LD_INT 23
98674: DOUBLE
98675: EQUAL
98676: IFTRUE 98680
98678: GO 98691
98680: POP
// bc_type := b_ext_laser ; 24 :
98681: LD_ADDR_OWVAR 42
98685: PUSH
98686: LD_INT 25
98688: ST_TO_ADDR
98689: GO 98901
98691: LD_INT 24
98693: DOUBLE
98694: EQUAL
98695: IFTRUE 98699
98697: GO 98710
98699: POP
// bc_type := b_control_tower ; 25 :
98700: LD_ADDR_OWVAR 42
98704: PUSH
98705: LD_INT 36
98707: ST_TO_ADDR
98708: GO 98901
98710: LD_INT 25
98712: DOUBLE
98713: EQUAL
98714: IFTRUE 98718
98716: GO 98729
98718: POP
// bc_type := b_breastwork ; 26 :
98719: LD_ADDR_OWVAR 42
98723: PUSH
98724: LD_INT 31
98726: ST_TO_ADDR
98727: GO 98901
98729: LD_INT 26
98731: DOUBLE
98732: EQUAL
98733: IFTRUE 98737
98735: GO 98748
98737: POP
// bc_type := b_bunker ; 27 :
98738: LD_ADDR_OWVAR 42
98742: PUSH
98743: LD_INT 32
98745: ST_TO_ADDR
98746: GO 98901
98748: LD_INT 27
98750: DOUBLE
98751: EQUAL
98752: IFTRUE 98756
98754: GO 98767
98756: POP
// bc_type := b_turret ; 28 :
98757: LD_ADDR_OWVAR 42
98761: PUSH
98762: LD_INT 33
98764: ST_TO_ADDR
98765: GO 98901
98767: LD_INT 28
98769: DOUBLE
98770: EQUAL
98771: IFTRUE 98775
98773: GO 98786
98775: POP
// bc_type := b_armoury ; 29 :
98776: LD_ADDR_OWVAR 42
98780: PUSH
98781: LD_INT 4
98783: ST_TO_ADDR
98784: GO 98901
98786: LD_INT 29
98788: DOUBLE
98789: EQUAL
98790: IFTRUE 98794
98792: GO 98805
98794: POP
// bc_type := b_barracks ; 30 :
98795: LD_ADDR_OWVAR 42
98799: PUSH
98800: LD_INT 5
98802: ST_TO_ADDR
98803: GO 98901
98805: LD_INT 30
98807: DOUBLE
98808: EQUAL
98809: IFTRUE 98813
98811: GO 98824
98813: POP
// bc_type := b_solar_power ; 31 :
98814: LD_ADDR_OWVAR 42
98818: PUSH
98819: LD_INT 27
98821: ST_TO_ADDR
98822: GO 98901
98824: LD_INT 31
98826: DOUBLE
98827: EQUAL
98828: IFTRUE 98832
98830: GO 98843
98832: POP
// bc_type := b_oil_power ; 32 :
98833: LD_ADDR_OWVAR 42
98837: PUSH
98838: LD_INT 26
98840: ST_TO_ADDR
98841: GO 98901
98843: LD_INT 32
98845: DOUBLE
98846: EQUAL
98847: IFTRUE 98851
98849: GO 98862
98851: POP
// bc_type := b_siberite_power ; 33 :
98852: LD_ADDR_OWVAR 42
98856: PUSH
98857: LD_INT 28
98859: ST_TO_ADDR
98860: GO 98901
98862: LD_INT 33
98864: DOUBLE
98865: EQUAL
98866: IFTRUE 98870
98868: GO 98881
98870: POP
// bc_type := b_oil_mine ; 34 :
98871: LD_ADDR_OWVAR 42
98875: PUSH
98876: LD_INT 29
98878: ST_TO_ADDR
98879: GO 98901
98881: LD_INT 34
98883: DOUBLE
98884: EQUAL
98885: IFTRUE 98889
98887: GO 98900
98889: POP
// bc_type := b_siberite_mine ; end ;
98890: LD_ADDR_OWVAR 42
98894: PUSH
98895: LD_INT 30
98897: ST_TO_ADDR
98898: GO 98901
98900: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
98901: LD_ADDR_VAR 0 8
98905: PUSH
98906: LD_VAR 0 5
98910: PPUSH
98911: LD_VAR 0 6
98915: PPUSH
98916: LD_VAR 0 3
98920: PPUSH
98921: CALL_OW 47
98925: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
98926: LD_OWVAR 42
98930: PUSH
98931: LD_INT 32
98933: PUSH
98934: LD_INT 33
98936: PUSH
98937: EMPTY
98938: LIST
98939: LIST
98940: IN
98941: IFFALSE 98957
// PlaceWeaponTurret ( b , weapon ) ;
98943: LD_VAR 0 8
98947: PPUSH
98948: LD_VAR 0 4
98952: PPUSH
98953: CALL_OW 431
// end ;
98957: LD_VAR 0 7
98961: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
98962: LD_INT 0
98964: PPUSH
98965: PPUSH
98966: PPUSH
98967: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98968: LD_ADDR_VAR 0 4
98972: PUSH
98973: LD_INT 22
98975: PUSH
98976: LD_OWVAR 2
98980: PUSH
98981: EMPTY
98982: LIST
98983: LIST
98984: PUSH
98985: LD_INT 2
98987: PUSH
98988: LD_INT 30
98990: PUSH
98991: LD_INT 0
98993: PUSH
98994: EMPTY
98995: LIST
98996: LIST
98997: PUSH
98998: LD_INT 30
99000: PUSH
99001: LD_INT 1
99003: PUSH
99004: EMPTY
99005: LIST
99006: LIST
99007: PUSH
99008: EMPTY
99009: LIST
99010: LIST
99011: LIST
99012: PUSH
99013: EMPTY
99014: LIST
99015: LIST
99016: PPUSH
99017: CALL_OW 69
99021: ST_TO_ADDR
// if not tmp then
99022: LD_VAR 0 4
99026: NOT
99027: IFFALSE 99031
// exit ;
99029: GO 99090
// for i in tmp do
99031: LD_ADDR_VAR 0 2
99035: PUSH
99036: LD_VAR 0 4
99040: PUSH
99041: FOR_IN
99042: IFFALSE 99088
// for j = 1 to 3 do
99044: LD_ADDR_VAR 0 3
99048: PUSH
99049: DOUBLE
99050: LD_INT 1
99052: DEC
99053: ST_TO_ADDR
99054: LD_INT 3
99056: PUSH
99057: FOR_TO
99058: IFFALSE 99084
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
99060: LD_VAR 0 2
99064: PPUSH
99065: CALL_OW 274
99069: PPUSH
99070: LD_VAR 0 3
99074: PPUSH
99075: LD_INT 99999
99077: PPUSH
99078: CALL_OW 277
99082: GO 99057
99084: POP
99085: POP
99086: GO 99041
99088: POP
99089: POP
// end ;
99090: LD_VAR 0 1
99094: RET
// export function hHackSetLevel10 ; var i , j ; begin
99095: LD_INT 0
99097: PPUSH
99098: PPUSH
99099: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99100: LD_ADDR_VAR 0 2
99104: PUSH
99105: LD_INT 21
99107: PUSH
99108: LD_INT 1
99110: PUSH
99111: EMPTY
99112: LIST
99113: LIST
99114: PPUSH
99115: CALL_OW 69
99119: PUSH
99120: FOR_IN
99121: IFFALSE 99173
// if IsSelected ( i ) then
99123: LD_VAR 0 2
99127: PPUSH
99128: CALL_OW 306
99132: IFFALSE 99171
// begin for j := 1 to 4 do
99134: LD_ADDR_VAR 0 3
99138: PUSH
99139: DOUBLE
99140: LD_INT 1
99142: DEC
99143: ST_TO_ADDR
99144: LD_INT 4
99146: PUSH
99147: FOR_TO
99148: IFFALSE 99169
// SetSkill ( i , j , 10 ) ;
99150: LD_VAR 0 2
99154: PPUSH
99155: LD_VAR 0 3
99159: PPUSH
99160: LD_INT 10
99162: PPUSH
99163: CALL_OW 237
99167: GO 99147
99169: POP
99170: POP
// end ;
99171: GO 99120
99173: POP
99174: POP
// end ;
99175: LD_VAR 0 1
99179: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
99180: LD_INT 0
99182: PPUSH
99183: PPUSH
99184: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
99185: LD_ADDR_VAR 0 2
99189: PUSH
99190: LD_INT 22
99192: PUSH
99193: LD_OWVAR 2
99197: PUSH
99198: EMPTY
99199: LIST
99200: LIST
99201: PUSH
99202: LD_INT 21
99204: PUSH
99205: LD_INT 1
99207: PUSH
99208: EMPTY
99209: LIST
99210: LIST
99211: PUSH
99212: EMPTY
99213: LIST
99214: LIST
99215: PPUSH
99216: CALL_OW 69
99220: PUSH
99221: FOR_IN
99222: IFFALSE 99263
// begin for j := 1 to 4 do
99224: LD_ADDR_VAR 0 3
99228: PUSH
99229: DOUBLE
99230: LD_INT 1
99232: DEC
99233: ST_TO_ADDR
99234: LD_INT 4
99236: PUSH
99237: FOR_TO
99238: IFFALSE 99259
// SetSkill ( i , j , 10 ) ;
99240: LD_VAR 0 2
99244: PPUSH
99245: LD_VAR 0 3
99249: PPUSH
99250: LD_INT 10
99252: PPUSH
99253: CALL_OW 237
99257: GO 99237
99259: POP
99260: POP
// end ;
99261: GO 99221
99263: POP
99264: POP
// end ;
99265: LD_VAR 0 1
99269: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
99270: LD_INT 0
99272: PPUSH
// uc_side := your_side ;
99273: LD_ADDR_OWVAR 20
99277: PUSH
99278: LD_OWVAR 2
99282: ST_TO_ADDR
// uc_nation := nation ;
99283: LD_ADDR_OWVAR 21
99287: PUSH
99288: LD_VAR 0 1
99292: ST_TO_ADDR
// InitHc ;
99293: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
99297: LD_INT 0
99299: PPUSH
99300: LD_VAR 0 2
99304: PPUSH
99305: LD_VAR 0 3
99309: PPUSH
99310: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
99314: LD_VAR 0 4
99318: PPUSH
99319: LD_VAR 0 5
99323: PPUSH
99324: CALL_OW 428
99328: PUSH
99329: LD_INT 0
99331: EQUAL
99332: IFFALSE 99356
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
99334: CALL_OW 44
99338: PPUSH
99339: LD_VAR 0 4
99343: PPUSH
99344: LD_VAR 0 5
99348: PPUSH
99349: LD_INT 1
99351: PPUSH
99352: CALL_OW 48
// end ;
99356: LD_VAR 0 6
99360: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
99361: LD_INT 0
99363: PPUSH
99364: PPUSH
// uc_side := your_side ;
99365: LD_ADDR_OWVAR 20
99369: PUSH
99370: LD_OWVAR 2
99374: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
99375: LD_VAR 0 1
99379: PUSH
99380: LD_INT 1
99382: PUSH
99383: LD_INT 2
99385: PUSH
99386: LD_INT 3
99388: PUSH
99389: LD_INT 4
99391: PUSH
99392: LD_INT 5
99394: PUSH
99395: EMPTY
99396: LIST
99397: LIST
99398: LIST
99399: LIST
99400: LIST
99401: IN
99402: IFFALSE 99414
// uc_nation := nation_american else
99404: LD_ADDR_OWVAR 21
99408: PUSH
99409: LD_INT 1
99411: ST_TO_ADDR
99412: GO 99457
// if chassis in [ 11 , 12 , 13 , 14 ] then
99414: LD_VAR 0 1
99418: PUSH
99419: LD_INT 11
99421: PUSH
99422: LD_INT 12
99424: PUSH
99425: LD_INT 13
99427: PUSH
99428: LD_INT 14
99430: PUSH
99431: EMPTY
99432: LIST
99433: LIST
99434: LIST
99435: LIST
99436: IN
99437: IFFALSE 99449
// uc_nation := nation_arabian else
99439: LD_ADDR_OWVAR 21
99443: PUSH
99444: LD_INT 2
99446: ST_TO_ADDR
99447: GO 99457
// uc_nation := nation_russian ;
99449: LD_ADDR_OWVAR 21
99453: PUSH
99454: LD_INT 3
99456: ST_TO_ADDR
// vc_chassis := chassis ;
99457: LD_ADDR_OWVAR 37
99461: PUSH
99462: LD_VAR 0 1
99466: ST_TO_ADDR
// vc_engine := engine ;
99467: LD_ADDR_OWVAR 39
99471: PUSH
99472: LD_VAR 0 2
99476: ST_TO_ADDR
// vc_control := control ;
99477: LD_ADDR_OWVAR 38
99481: PUSH
99482: LD_VAR 0 3
99486: ST_TO_ADDR
// vc_weapon := weapon ;
99487: LD_ADDR_OWVAR 40
99491: PUSH
99492: LD_VAR 0 4
99496: ST_TO_ADDR
// un := CreateVehicle ;
99497: LD_ADDR_VAR 0 8
99501: PUSH
99502: CALL_OW 45
99506: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
99507: LD_VAR 0 8
99511: PPUSH
99512: LD_INT 0
99514: PPUSH
99515: LD_INT 5
99517: PPUSH
99518: CALL_OW 12
99522: PPUSH
99523: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
99527: LD_VAR 0 8
99531: PPUSH
99532: LD_VAR 0 5
99536: PPUSH
99537: LD_VAR 0 6
99541: PPUSH
99542: LD_INT 1
99544: PPUSH
99545: CALL_OW 48
// end ;
99549: LD_VAR 0 7
99553: RET
// export hInvincible ; every 1 do
99554: GO 99556
99556: DISABLE
// hInvincible := [ ] ;
99557: LD_ADDR_EXP 180
99561: PUSH
99562: EMPTY
99563: ST_TO_ADDR
99564: END
// every 10 do var i ;
99565: GO 99567
99567: DISABLE
99568: LD_INT 0
99570: PPUSH
// begin enable ;
99571: ENABLE
// if not hInvincible then
99572: LD_EXP 180
99576: NOT
99577: IFFALSE 99581
// exit ;
99579: GO 99625
// for i in hInvincible do
99581: LD_ADDR_VAR 0 1
99585: PUSH
99586: LD_EXP 180
99590: PUSH
99591: FOR_IN
99592: IFFALSE 99623
// if GetLives ( i ) < 1000 then
99594: LD_VAR 0 1
99598: PPUSH
99599: CALL_OW 256
99603: PUSH
99604: LD_INT 1000
99606: LESS
99607: IFFALSE 99621
// SetLives ( i , 1000 ) ;
99609: LD_VAR 0 1
99613: PPUSH
99614: LD_INT 1000
99616: PPUSH
99617: CALL_OW 234
99621: GO 99591
99623: POP
99624: POP
// end ;
99625: PPOPN 1
99627: END
// export function hHackInvincible ; var i ; begin
99628: LD_INT 0
99630: PPUSH
99631: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
99632: LD_ADDR_VAR 0 2
99636: PUSH
99637: LD_INT 2
99639: PUSH
99640: LD_INT 21
99642: PUSH
99643: LD_INT 1
99645: PUSH
99646: EMPTY
99647: LIST
99648: LIST
99649: PUSH
99650: LD_INT 21
99652: PUSH
99653: LD_INT 2
99655: PUSH
99656: EMPTY
99657: LIST
99658: LIST
99659: PUSH
99660: EMPTY
99661: LIST
99662: LIST
99663: LIST
99664: PPUSH
99665: CALL_OW 69
99669: PUSH
99670: FOR_IN
99671: IFFALSE 99732
// if IsSelected ( i ) then
99673: LD_VAR 0 2
99677: PPUSH
99678: CALL_OW 306
99682: IFFALSE 99730
// begin if i in hInvincible then
99684: LD_VAR 0 2
99688: PUSH
99689: LD_EXP 180
99693: IN
99694: IFFALSE 99714
// hInvincible := hInvincible diff i else
99696: LD_ADDR_EXP 180
99700: PUSH
99701: LD_EXP 180
99705: PUSH
99706: LD_VAR 0 2
99710: DIFF
99711: ST_TO_ADDR
99712: GO 99730
// hInvincible := hInvincible union i ;
99714: LD_ADDR_EXP 180
99718: PUSH
99719: LD_EXP 180
99723: PUSH
99724: LD_VAR 0 2
99728: UNION
99729: ST_TO_ADDR
// end ;
99730: GO 99670
99732: POP
99733: POP
// end ;
99734: LD_VAR 0 1
99738: RET
// export function hHackInvisible ; var i , j ; begin
99739: LD_INT 0
99741: PPUSH
99742: PPUSH
99743: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99744: LD_ADDR_VAR 0 2
99748: PUSH
99749: LD_INT 21
99751: PUSH
99752: LD_INT 1
99754: PUSH
99755: EMPTY
99756: LIST
99757: LIST
99758: PPUSH
99759: CALL_OW 69
99763: PUSH
99764: FOR_IN
99765: IFFALSE 99789
// if IsSelected ( i ) then
99767: LD_VAR 0 2
99771: PPUSH
99772: CALL_OW 306
99776: IFFALSE 99787
// ComForceInvisible ( i ) ;
99778: LD_VAR 0 2
99782: PPUSH
99783: CALL_OW 496
99787: GO 99764
99789: POP
99790: POP
// end ;
99791: LD_VAR 0 1
99795: RET
// export function hHackChangeYourSide ; begin
99796: LD_INT 0
99798: PPUSH
// if your_side = 8 then
99799: LD_OWVAR 2
99803: PUSH
99804: LD_INT 8
99806: EQUAL
99807: IFFALSE 99819
// your_side := 0 else
99809: LD_ADDR_OWVAR 2
99813: PUSH
99814: LD_INT 0
99816: ST_TO_ADDR
99817: GO 99833
// your_side := your_side + 1 ;
99819: LD_ADDR_OWVAR 2
99823: PUSH
99824: LD_OWVAR 2
99828: PUSH
99829: LD_INT 1
99831: PLUS
99832: ST_TO_ADDR
// end ;
99833: LD_VAR 0 1
99837: RET
// export function hHackChangeUnitSide ; var i , j ; begin
99838: LD_INT 0
99840: PPUSH
99841: PPUSH
99842: PPUSH
// for i in all_units do
99843: LD_ADDR_VAR 0 2
99847: PUSH
99848: LD_OWVAR 3
99852: PUSH
99853: FOR_IN
99854: IFFALSE 99932
// if IsSelected ( i ) then
99856: LD_VAR 0 2
99860: PPUSH
99861: CALL_OW 306
99865: IFFALSE 99930
// begin j := GetSide ( i ) ;
99867: LD_ADDR_VAR 0 3
99871: PUSH
99872: LD_VAR 0 2
99876: PPUSH
99877: CALL_OW 255
99881: ST_TO_ADDR
// if j = 8 then
99882: LD_VAR 0 3
99886: PUSH
99887: LD_INT 8
99889: EQUAL
99890: IFFALSE 99902
// j := 0 else
99892: LD_ADDR_VAR 0 3
99896: PUSH
99897: LD_INT 0
99899: ST_TO_ADDR
99900: GO 99916
// j := j + 1 ;
99902: LD_ADDR_VAR 0 3
99906: PUSH
99907: LD_VAR 0 3
99911: PUSH
99912: LD_INT 1
99914: PLUS
99915: ST_TO_ADDR
// SetSide ( i , j ) ;
99916: LD_VAR 0 2
99920: PPUSH
99921: LD_VAR 0 3
99925: PPUSH
99926: CALL_OW 235
// end ;
99930: GO 99853
99932: POP
99933: POP
// end ;
99934: LD_VAR 0 1
99938: RET
// export function hHackFog ; begin
99939: LD_INT 0
99941: PPUSH
// FogOff ( true ) ;
99942: LD_INT 1
99944: PPUSH
99945: CALL_OW 344
// end ;
99949: LD_VAR 0 1
99953: RET
// export function hHackTeleport ( unit , x , y ) ; begin
99954: LD_INT 0
99956: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
99957: LD_VAR 0 1
99961: PPUSH
99962: LD_VAR 0 2
99966: PPUSH
99967: LD_VAR 0 3
99971: PPUSH
99972: LD_INT 1
99974: PPUSH
99975: LD_INT 1
99977: PPUSH
99978: CALL_OW 483
// CenterOnXY ( x , y ) ;
99982: LD_VAR 0 2
99986: PPUSH
99987: LD_VAR 0 3
99991: PPUSH
99992: CALL_OW 84
// end ; end_of_file
99996: LD_VAR 0 4
100000: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
100001: LD_INT 0
100003: PPUSH
100004: PPUSH
100005: PPUSH
100006: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
100007: LD_VAR 0 1
100011: PPUSH
100012: CALL_OW 264
100016: PUSH
100017: LD_EXP 108
100021: EQUAL
100022: IFFALSE 100094
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
100024: LD_INT 68
100026: PPUSH
100027: LD_VAR 0 1
100031: PPUSH
100032: CALL_OW 255
100036: PPUSH
100037: CALL_OW 321
100041: PUSH
100042: LD_INT 2
100044: EQUAL
100045: IFFALSE 100057
// eff := 70 else
100047: LD_ADDR_VAR 0 4
100051: PUSH
100052: LD_INT 70
100054: ST_TO_ADDR
100055: GO 100065
// eff := 30 ;
100057: LD_ADDR_VAR 0 4
100061: PUSH
100062: LD_INT 30
100064: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
100065: LD_VAR 0 1
100069: PPUSH
100070: CALL_OW 250
100074: PPUSH
100075: LD_VAR 0 1
100079: PPUSH
100080: CALL_OW 251
100084: PPUSH
100085: LD_VAR 0 4
100089: PPUSH
100090: CALL_OW 495
// end ; end ;
100094: LD_VAR 0 2
100098: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
100099: LD_INT 0
100101: PPUSH
// end ;
100102: LD_VAR 0 4
100106: RET
// export function SOS_Command ( cmd ) ; begin
100107: LD_INT 0
100109: PPUSH
// end ;
100110: LD_VAR 0 2
100114: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
100115: LD_INT 0
100117: PPUSH
// end ;
100118: LD_VAR 0 6
100122: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
100123: LD_INT 0
100125: PPUSH
100126: PPUSH
// if not vehicle or not factory then
100127: LD_VAR 0 1
100131: NOT
100132: PUSH
100133: LD_VAR 0 2
100137: NOT
100138: OR
100139: IFFALSE 100143
// exit ;
100141: GO 100374
// if factoryWaypoints >= factory then
100143: LD_EXP 181
100147: PUSH
100148: LD_VAR 0 2
100152: GREATEREQUAL
100153: IFFALSE 100374
// if factoryWaypoints [ factory ] then
100155: LD_EXP 181
100159: PUSH
100160: LD_VAR 0 2
100164: ARRAY
100165: IFFALSE 100374
// begin if GetControl ( vehicle ) = control_manual then
100167: LD_VAR 0 1
100171: PPUSH
100172: CALL_OW 263
100176: PUSH
100177: LD_INT 1
100179: EQUAL
100180: IFFALSE 100261
// begin driver := IsDrivenBy ( vehicle ) ;
100182: LD_ADDR_VAR 0 4
100186: PUSH
100187: LD_VAR 0 1
100191: PPUSH
100192: CALL_OW 311
100196: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
100197: LD_VAR 0 4
100201: PPUSH
100202: LD_EXP 181
100206: PUSH
100207: LD_VAR 0 2
100211: ARRAY
100212: PUSH
100213: LD_INT 3
100215: ARRAY
100216: PPUSH
100217: LD_EXP 181
100221: PUSH
100222: LD_VAR 0 2
100226: ARRAY
100227: PUSH
100228: LD_INT 4
100230: ARRAY
100231: PPUSH
100232: CALL_OW 171
// AddComExitVehicle ( driver ) ;
100236: LD_VAR 0 4
100240: PPUSH
100241: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
100245: LD_VAR 0 4
100249: PPUSH
100250: LD_VAR 0 2
100254: PPUSH
100255: CALL_OW 180
// end else
100259: GO 100374
// if GetControl ( vehicle ) = control_remote then
100261: LD_VAR 0 1
100265: PPUSH
100266: CALL_OW 263
100270: PUSH
100271: LD_INT 2
100273: EQUAL
100274: IFFALSE 100335
// begin wait ( 0 0$2 ) ;
100276: LD_INT 70
100278: PPUSH
100279: CALL_OW 67
// if Connect ( vehicle ) then
100283: LD_VAR 0 1
100287: PPUSH
100288: CALL 22795 0 1
100292: IFFALSE 100333
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
100294: LD_VAR 0 1
100298: PPUSH
100299: LD_EXP 181
100303: PUSH
100304: LD_VAR 0 2
100308: ARRAY
100309: PUSH
100310: LD_INT 3
100312: ARRAY
100313: PPUSH
100314: LD_EXP 181
100318: PUSH
100319: LD_VAR 0 2
100323: ARRAY
100324: PUSH
100325: LD_INT 4
100327: ARRAY
100328: PPUSH
100329: CALL_OW 171
// end else
100333: GO 100374
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
100335: LD_VAR 0 1
100339: PPUSH
100340: LD_EXP 181
100344: PUSH
100345: LD_VAR 0 2
100349: ARRAY
100350: PUSH
100351: LD_INT 3
100353: ARRAY
100354: PPUSH
100355: LD_EXP 181
100359: PUSH
100360: LD_VAR 0 2
100364: ARRAY
100365: PUSH
100366: LD_INT 4
100368: ARRAY
100369: PPUSH
100370: CALL_OW 171
// end ; end ;
100374: LD_VAR 0 3
100378: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
100379: LD_INT 0
100381: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
100382: LD_VAR 0 1
100386: PUSH
100387: LD_INT 250
100389: EQUAL
100390: PUSH
100391: LD_VAR 0 2
100395: PPUSH
100396: CALL_OW 264
100400: PUSH
100401: LD_EXP 111
100405: EQUAL
100406: AND
100407: IFFALSE 100428
// MinerPlaceMine ( unit , x , y ) ;
100409: LD_VAR 0 2
100413: PPUSH
100414: LD_VAR 0 4
100418: PPUSH
100419: LD_VAR 0 5
100423: PPUSH
100424: CALL 103156 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
100428: LD_VAR 0 1
100432: PUSH
100433: LD_INT 251
100435: EQUAL
100436: PUSH
100437: LD_VAR 0 2
100441: PPUSH
100442: CALL_OW 264
100446: PUSH
100447: LD_EXP 111
100451: EQUAL
100452: AND
100453: IFFALSE 100474
// MinerDetonateMine ( unit , x , y ) ;
100455: LD_VAR 0 2
100459: PPUSH
100460: LD_VAR 0 4
100464: PPUSH
100465: LD_VAR 0 5
100469: PPUSH
100470: CALL 103433 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
100474: LD_VAR 0 1
100478: PUSH
100479: LD_INT 252
100481: EQUAL
100482: PUSH
100483: LD_VAR 0 2
100487: PPUSH
100488: CALL_OW 264
100492: PUSH
100493: LD_EXP 111
100497: EQUAL
100498: AND
100499: IFFALSE 100520
// MinerCreateMinefield ( unit , x , y ) ;
100501: LD_VAR 0 2
100505: PPUSH
100506: LD_VAR 0 4
100510: PPUSH
100511: LD_VAR 0 5
100515: PPUSH
100516: CALL 103850 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
100520: LD_VAR 0 1
100524: PUSH
100525: LD_INT 253
100527: EQUAL
100528: PUSH
100529: LD_VAR 0 2
100533: PPUSH
100534: CALL_OW 257
100538: PUSH
100539: LD_INT 5
100541: EQUAL
100542: AND
100543: IFFALSE 100564
// ComBinocular ( unit , x , y ) ;
100545: LD_VAR 0 2
100549: PPUSH
100550: LD_VAR 0 4
100554: PPUSH
100555: LD_VAR 0 5
100559: PPUSH
100560: CALL 104221 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
100564: LD_VAR 0 1
100568: PUSH
100569: LD_INT 254
100571: EQUAL
100572: PUSH
100573: LD_VAR 0 2
100577: PPUSH
100578: CALL_OW 264
100582: PUSH
100583: LD_EXP 106
100587: EQUAL
100588: AND
100589: PUSH
100590: LD_VAR 0 3
100594: PPUSH
100595: CALL_OW 263
100599: PUSH
100600: LD_INT 3
100602: EQUAL
100603: AND
100604: IFFALSE 100620
// HackDestroyVehicle ( unit , selectedUnit ) ;
100606: LD_VAR 0 2
100610: PPUSH
100611: LD_VAR 0 3
100615: PPUSH
100616: CALL 102516 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
100620: LD_VAR 0 1
100624: PUSH
100625: LD_INT 255
100627: EQUAL
100628: PUSH
100629: LD_VAR 0 2
100633: PPUSH
100634: CALL_OW 264
100638: PUSH
100639: LD_INT 14
100641: PUSH
100642: LD_INT 53
100644: PUSH
100645: EMPTY
100646: LIST
100647: LIST
100648: IN
100649: AND
100650: PUSH
100651: LD_VAR 0 4
100655: PPUSH
100656: LD_VAR 0 5
100660: PPUSH
100661: CALL_OW 488
100665: AND
100666: IFFALSE 100690
// CutTreeXYR ( unit , x , y , 12 ) ;
100668: LD_VAR 0 2
100672: PPUSH
100673: LD_VAR 0 4
100677: PPUSH
100678: LD_VAR 0 5
100682: PPUSH
100683: LD_INT 12
100685: PPUSH
100686: CALL 101082 0 4
// if cmd = 256 then
100690: LD_VAR 0 1
100694: PUSH
100695: LD_INT 256
100697: EQUAL
100698: IFFALSE 100719
// SetFactoryWaypoint ( unit , x , y ) ;
100700: LD_VAR 0 2
100704: PPUSH
100705: LD_VAR 0 4
100709: PPUSH
100710: LD_VAR 0 5
100714: PPUSH
100715: CALL 100724 0 3
// end ;
100719: LD_VAR 0 6
100723: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
100724: LD_INT 0
100726: PPUSH
100727: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
100728: LD_VAR 0 1
100732: NOT
100733: PUSH
100734: LD_VAR 0 2
100738: PPUSH
100739: LD_VAR 0 3
100743: PPUSH
100744: CALL_OW 488
100748: NOT
100749: OR
100750: PUSH
100751: LD_VAR 0 1
100755: PPUSH
100756: CALL_OW 266
100760: PUSH
100761: LD_INT 3
100763: NONEQUAL
100764: PUSH
100765: LD_VAR 0 1
100769: PPUSH
100770: CALL_OW 247
100774: PUSH
100775: LD_INT 1
100777: EQUAL
100778: NOT
100779: AND
100780: OR
100781: IFFALSE 100785
// exit ;
100783: GO 100934
// if GetType ( factory ) = unit_human then
100785: LD_VAR 0 1
100789: PPUSH
100790: CALL_OW 247
100794: PUSH
100795: LD_INT 1
100797: EQUAL
100798: IFFALSE 100815
// factory := IsInUnit ( factory ) ;
100800: LD_ADDR_VAR 0 1
100804: PUSH
100805: LD_VAR 0 1
100809: PPUSH
100810: CALL_OW 310
100814: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
100815: LD_VAR 0 1
100819: PPUSH
100820: CALL_OW 266
100824: PUSH
100825: LD_INT 3
100827: NONEQUAL
100828: IFFALSE 100832
// exit ;
100830: GO 100934
// if HexInfo ( x , y ) = factory then
100832: LD_VAR 0 2
100836: PPUSH
100837: LD_VAR 0 3
100841: PPUSH
100842: CALL_OW 428
100846: PUSH
100847: LD_VAR 0 1
100851: EQUAL
100852: IFFALSE 100879
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
100854: LD_ADDR_EXP 181
100858: PUSH
100859: LD_EXP 181
100863: PPUSH
100864: LD_VAR 0 1
100868: PPUSH
100869: LD_INT 0
100871: PPUSH
100872: CALL_OW 1
100876: ST_TO_ADDR
100877: GO 100930
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
100879: LD_ADDR_EXP 181
100883: PUSH
100884: LD_EXP 181
100888: PPUSH
100889: LD_VAR 0 1
100893: PPUSH
100894: LD_VAR 0 1
100898: PPUSH
100899: CALL_OW 255
100903: PUSH
100904: LD_VAR 0 1
100908: PUSH
100909: LD_VAR 0 2
100913: PUSH
100914: LD_VAR 0 3
100918: PUSH
100919: EMPTY
100920: LIST
100921: LIST
100922: LIST
100923: LIST
100924: PPUSH
100925: CALL_OW 1
100929: ST_TO_ADDR
// UpdateFactoryWaypoints ;
100930: CALL 100939 0 0
// end ;
100934: LD_VAR 0 4
100938: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
100939: LD_INT 0
100941: PPUSH
100942: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
100943: LD_STRING resetFactoryWaypoint();
100945: PPUSH
100946: CALL_OW 559
// if factoryWaypoints then
100950: LD_EXP 181
100954: IFFALSE 101077
// begin for i := 1 to factoryWaypoints do
100956: LD_ADDR_VAR 0 2
100960: PUSH
100961: DOUBLE
100962: LD_INT 1
100964: DEC
100965: ST_TO_ADDR
100966: LD_EXP 181
100970: PUSH
100971: FOR_TO
100972: IFFALSE 101075
// if factoryWaypoints [ i ] then
100974: LD_EXP 181
100978: PUSH
100979: LD_VAR 0 2
100983: ARRAY
100984: IFFALSE 101073
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
100986: LD_STRING setFactoryWaypointXY(
100988: PUSH
100989: LD_EXP 181
100993: PUSH
100994: LD_VAR 0 2
100998: ARRAY
100999: PUSH
101000: LD_INT 1
101002: ARRAY
101003: STR
101004: PUSH
101005: LD_STRING ,
101007: STR
101008: PUSH
101009: LD_EXP 181
101013: PUSH
101014: LD_VAR 0 2
101018: ARRAY
101019: PUSH
101020: LD_INT 2
101022: ARRAY
101023: STR
101024: PUSH
101025: LD_STRING ,
101027: STR
101028: PUSH
101029: LD_EXP 181
101033: PUSH
101034: LD_VAR 0 2
101038: ARRAY
101039: PUSH
101040: LD_INT 3
101042: ARRAY
101043: STR
101044: PUSH
101045: LD_STRING ,
101047: STR
101048: PUSH
101049: LD_EXP 181
101053: PUSH
101054: LD_VAR 0 2
101058: ARRAY
101059: PUSH
101060: LD_INT 4
101062: ARRAY
101063: STR
101064: PUSH
101065: LD_STRING )
101067: STR
101068: PPUSH
101069: CALL_OW 559
101073: GO 100971
101075: POP
101076: POP
// end ; end ;
101077: LD_VAR 0 1
101081: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
101082: LD_INT 0
101084: PPUSH
101085: PPUSH
101086: PPUSH
101087: PPUSH
101088: PPUSH
101089: PPUSH
101090: PPUSH
101091: PPUSH
101092: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
101093: LD_VAR 0 1
101097: NOT
101098: PUSH
101099: LD_VAR 0 2
101103: PPUSH
101104: LD_VAR 0 3
101108: PPUSH
101109: CALL_OW 488
101113: NOT
101114: OR
101115: PUSH
101116: LD_VAR 0 4
101120: NOT
101121: OR
101122: IFFALSE 101126
// exit ;
101124: GO 101466
// list := [ ] ;
101126: LD_ADDR_VAR 0 13
101130: PUSH
101131: EMPTY
101132: ST_TO_ADDR
// if x - r < 0 then
101133: LD_VAR 0 2
101137: PUSH
101138: LD_VAR 0 4
101142: MINUS
101143: PUSH
101144: LD_INT 0
101146: LESS
101147: IFFALSE 101159
// min_x := 0 else
101149: LD_ADDR_VAR 0 7
101153: PUSH
101154: LD_INT 0
101156: ST_TO_ADDR
101157: GO 101175
// min_x := x - r ;
101159: LD_ADDR_VAR 0 7
101163: PUSH
101164: LD_VAR 0 2
101168: PUSH
101169: LD_VAR 0 4
101173: MINUS
101174: ST_TO_ADDR
// if y - r < 0 then
101175: LD_VAR 0 3
101179: PUSH
101180: LD_VAR 0 4
101184: MINUS
101185: PUSH
101186: LD_INT 0
101188: LESS
101189: IFFALSE 101201
// min_y := 0 else
101191: LD_ADDR_VAR 0 8
101195: PUSH
101196: LD_INT 0
101198: ST_TO_ADDR
101199: GO 101217
// min_y := y - r ;
101201: LD_ADDR_VAR 0 8
101205: PUSH
101206: LD_VAR 0 3
101210: PUSH
101211: LD_VAR 0 4
101215: MINUS
101216: ST_TO_ADDR
// max_x := x + r ;
101217: LD_ADDR_VAR 0 9
101221: PUSH
101222: LD_VAR 0 2
101226: PUSH
101227: LD_VAR 0 4
101231: PLUS
101232: ST_TO_ADDR
// max_y := y + r ;
101233: LD_ADDR_VAR 0 10
101237: PUSH
101238: LD_VAR 0 3
101242: PUSH
101243: LD_VAR 0 4
101247: PLUS
101248: ST_TO_ADDR
// for _x = min_x to max_x do
101249: LD_ADDR_VAR 0 11
101253: PUSH
101254: DOUBLE
101255: LD_VAR 0 7
101259: DEC
101260: ST_TO_ADDR
101261: LD_VAR 0 9
101265: PUSH
101266: FOR_TO
101267: IFFALSE 101384
// for _y = min_y to max_y do
101269: LD_ADDR_VAR 0 12
101273: PUSH
101274: DOUBLE
101275: LD_VAR 0 8
101279: DEC
101280: ST_TO_ADDR
101281: LD_VAR 0 10
101285: PUSH
101286: FOR_TO
101287: IFFALSE 101380
// begin if not ValidHex ( _x , _y ) then
101289: LD_VAR 0 11
101293: PPUSH
101294: LD_VAR 0 12
101298: PPUSH
101299: CALL_OW 488
101303: NOT
101304: IFFALSE 101308
// continue ;
101306: GO 101286
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
101308: LD_VAR 0 11
101312: PPUSH
101313: LD_VAR 0 12
101317: PPUSH
101318: CALL_OW 351
101322: PUSH
101323: LD_VAR 0 11
101327: PPUSH
101328: LD_VAR 0 12
101332: PPUSH
101333: CALL_OW 554
101337: AND
101338: IFFALSE 101378
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
101340: LD_ADDR_VAR 0 13
101344: PUSH
101345: LD_VAR 0 13
101349: PPUSH
101350: LD_VAR 0 13
101354: PUSH
101355: LD_INT 1
101357: PLUS
101358: PPUSH
101359: LD_VAR 0 11
101363: PUSH
101364: LD_VAR 0 12
101368: PUSH
101369: EMPTY
101370: LIST
101371: LIST
101372: PPUSH
101373: CALL_OW 2
101377: ST_TO_ADDR
// end ;
101378: GO 101286
101380: POP
101381: POP
101382: GO 101266
101384: POP
101385: POP
// if not list then
101386: LD_VAR 0 13
101390: NOT
101391: IFFALSE 101395
// exit ;
101393: GO 101466
// for i in list do
101395: LD_ADDR_VAR 0 6
101399: PUSH
101400: LD_VAR 0 13
101404: PUSH
101405: FOR_IN
101406: IFFALSE 101464
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
101408: LD_VAR 0 1
101412: PPUSH
101413: LD_STRING M
101415: PUSH
101416: LD_VAR 0 6
101420: PUSH
101421: LD_INT 1
101423: ARRAY
101424: PUSH
101425: LD_VAR 0 6
101429: PUSH
101430: LD_INT 2
101432: ARRAY
101433: PUSH
101434: LD_INT 0
101436: PUSH
101437: LD_INT 0
101439: PUSH
101440: LD_INT 0
101442: PUSH
101443: LD_INT 0
101445: PUSH
101446: EMPTY
101447: LIST
101448: LIST
101449: LIST
101450: LIST
101451: LIST
101452: LIST
101453: LIST
101454: PUSH
101455: EMPTY
101456: LIST
101457: PPUSH
101458: CALL_OW 447
101462: GO 101405
101464: POP
101465: POP
// end ;
101466: LD_VAR 0 5
101470: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
101471: LD_EXP 182
101475: NOT
101476: IFFALSE 101526
101478: GO 101480
101480: DISABLE
// begin initHack := true ;
101481: LD_ADDR_EXP 182
101485: PUSH
101486: LD_INT 1
101488: ST_TO_ADDR
// hackTanks := [ ] ;
101489: LD_ADDR_EXP 183
101493: PUSH
101494: EMPTY
101495: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
101496: LD_ADDR_EXP 184
101500: PUSH
101501: EMPTY
101502: ST_TO_ADDR
// hackLimit := 3 ;
101503: LD_ADDR_EXP 185
101507: PUSH
101508: LD_INT 3
101510: ST_TO_ADDR
// hackDist := 12 ;
101511: LD_ADDR_EXP 186
101515: PUSH
101516: LD_INT 12
101518: ST_TO_ADDR
// hackCounter := [ ] ;
101519: LD_ADDR_EXP 187
101523: PUSH
101524: EMPTY
101525: ST_TO_ADDR
// end ;
101526: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
101527: LD_EXP 182
101531: PUSH
101532: LD_INT 34
101534: PUSH
101535: LD_EXP 106
101539: PUSH
101540: EMPTY
101541: LIST
101542: LIST
101543: PPUSH
101544: CALL_OW 69
101548: AND
101549: IFFALSE 101804
101551: GO 101553
101553: DISABLE
101554: LD_INT 0
101556: PPUSH
101557: PPUSH
// begin enable ;
101558: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
101559: LD_ADDR_VAR 0 1
101563: PUSH
101564: LD_INT 34
101566: PUSH
101567: LD_EXP 106
101571: PUSH
101572: EMPTY
101573: LIST
101574: LIST
101575: PPUSH
101576: CALL_OW 69
101580: PUSH
101581: FOR_IN
101582: IFFALSE 101802
// begin if not i in hackTanks then
101584: LD_VAR 0 1
101588: PUSH
101589: LD_EXP 183
101593: IN
101594: NOT
101595: IFFALSE 101678
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
101597: LD_ADDR_EXP 183
101601: PUSH
101602: LD_EXP 183
101606: PPUSH
101607: LD_EXP 183
101611: PUSH
101612: LD_INT 1
101614: PLUS
101615: PPUSH
101616: LD_VAR 0 1
101620: PPUSH
101621: CALL_OW 1
101625: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
101626: LD_ADDR_EXP 184
101630: PUSH
101631: LD_EXP 184
101635: PPUSH
101636: LD_EXP 184
101640: PUSH
101641: LD_INT 1
101643: PLUS
101644: PPUSH
101645: EMPTY
101646: PPUSH
101647: CALL_OW 1
101651: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
101652: LD_ADDR_EXP 187
101656: PUSH
101657: LD_EXP 187
101661: PPUSH
101662: LD_EXP 187
101666: PUSH
101667: LD_INT 1
101669: PLUS
101670: PPUSH
101671: EMPTY
101672: PPUSH
101673: CALL_OW 1
101677: ST_TO_ADDR
// end ; if not IsOk ( i ) then
101678: LD_VAR 0 1
101682: PPUSH
101683: CALL_OW 302
101687: NOT
101688: IFFALSE 101701
// begin HackUnlinkAll ( i ) ;
101690: LD_VAR 0 1
101694: PPUSH
101695: CALL 101807 0 1
// continue ;
101699: GO 101581
// end ; HackCheckCapturedStatus ( i ) ;
101701: LD_VAR 0 1
101705: PPUSH
101706: CALL 102250 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
101710: LD_ADDR_VAR 0 2
101714: PUSH
101715: LD_INT 81
101717: PUSH
101718: LD_VAR 0 1
101722: PPUSH
101723: CALL_OW 255
101727: PUSH
101728: EMPTY
101729: LIST
101730: LIST
101731: PUSH
101732: LD_INT 33
101734: PUSH
101735: LD_INT 3
101737: PUSH
101738: EMPTY
101739: LIST
101740: LIST
101741: PUSH
101742: LD_INT 91
101744: PUSH
101745: LD_VAR 0 1
101749: PUSH
101750: LD_EXP 186
101754: PUSH
101755: EMPTY
101756: LIST
101757: LIST
101758: LIST
101759: PUSH
101760: LD_INT 50
101762: PUSH
101763: EMPTY
101764: LIST
101765: PUSH
101766: EMPTY
101767: LIST
101768: LIST
101769: LIST
101770: LIST
101771: PPUSH
101772: CALL_OW 69
101776: ST_TO_ADDR
// if not tmp then
101777: LD_VAR 0 2
101781: NOT
101782: IFFALSE 101786
// continue ;
101784: GO 101581
// HackLink ( i , tmp ) ;
101786: LD_VAR 0 1
101790: PPUSH
101791: LD_VAR 0 2
101795: PPUSH
101796: CALL 101943 0 2
// end ;
101800: GO 101581
101802: POP
101803: POP
// end ;
101804: PPOPN 2
101806: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
101807: LD_INT 0
101809: PPUSH
101810: PPUSH
101811: PPUSH
// if not hack in hackTanks then
101812: LD_VAR 0 1
101816: PUSH
101817: LD_EXP 183
101821: IN
101822: NOT
101823: IFFALSE 101827
// exit ;
101825: GO 101938
// index := GetElementIndex ( hackTanks , hack ) ;
101827: LD_ADDR_VAR 0 4
101831: PUSH
101832: LD_EXP 183
101836: PPUSH
101837: LD_VAR 0 1
101841: PPUSH
101842: CALL 19609 0 2
101846: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
101847: LD_EXP 184
101851: PUSH
101852: LD_VAR 0 4
101856: ARRAY
101857: IFFALSE 101938
// begin for i in hackTanksCaptured [ index ] do
101859: LD_ADDR_VAR 0 3
101863: PUSH
101864: LD_EXP 184
101868: PUSH
101869: LD_VAR 0 4
101873: ARRAY
101874: PUSH
101875: FOR_IN
101876: IFFALSE 101902
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
101878: LD_VAR 0 3
101882: PUSH
101883: LD_INT 1
101885: ARRAY
101886: PPUSH
101887: LD_VAR 0 3
101891: PUSH
101892: LD_INT 2
101894: ARRAY
101895: PPUSH
101896: CALL_OW 235
101900: GO 101875
101902: POP
101903: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
101904: LD_ADDR_EXP 184
101908: PUSH
101909: LD_EXP 184
101913: PPUSH
101914: LD_VAR 0 4
101918: PPUSH
101919: EMPTY
101920: PPUSH
101921: CALL_OW 1
101925: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
101926: LD_VAR 0 1
101930: PPUSH
101931: LD_INT 0
101933: PPUSH
101934: CALL_OW 505
// end ; end ;
101938: LD_VAR 0 2
101942: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
101943: LD_INT 0
101945: PPUSH
101946: PPUSH
101947: PPUSH
// if not hack in hackTanks or not vehicles then
101948: LD_VAR 0 1
101952: PUSH
101953: LD_EXP 183
101957: IN
101958: NOT
101959: PUSH
101960: LD_VAR 0 2
101964: NOT
101965: OR
101966: IFFALSE 101970
// exit ;
101968: GO 102245
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
101970: LD_ADDR_VAR 0 2
101974: PUSH
101975: LD_VAR 0 1
101979: PPUSH
101980: LD_VAR 0 2
101984: PPUSH
101985: LD_INT 1
101987: PPUSH
101988: LD_INT 1
101990: PPUSH
101991: CALL 20259 0 4
101995: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
101996: LD_ADDR_VAR 0 5
102000: PUSH
102001: LD_EXP 183
102005: PPUSH
102006: LD_VAR 0 1
102010: PPUSH
102011: CALL 19609 0 2
102015: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
102016: LD_EXP 184
102020: PUSH
102021: LD_VAR 0 5
102025: ARRAY
102026: PUSH
102027: LD_EXP 185
102031: LESS
102032: IFFALSE 102221
// begin for i := 1 to vehicles do
102034: LD_ADDR_VAR 0 4
102038: PUSH
102039: DOUBLE
102040: LD_INT 1
102042: DEC
102043: ST_TO_ADDR
102044: LD_VAR 0 2
102048: PUSH
102049: FOR_TO
102050: IFFALSE 102219
// begin if hackTanksCaptured [ index ] = hackLimit then
102052: LD_EXP 184
102056: PUSH
102057: LD_VAR 0 5
102061: ARRAY
102062: PUSH
102063: LD_EXP 185
102067: EQUAL
102068: IFFALSE 102072
// break ;
102070: GO 102219
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
102072: LD_ADDR_EXP 187
102076: PUSH
102077: LD_EXP 187
102081: PPUSH
102082: LD_VAR 0 5
102086: PPUSH
102087: LD_EXP 187
102091: PUSH
102092: LD_VAR 0 5
102096: ARRAY
102097: PUSH
102098: LD_INT 1
102100: PLUS
102101: PPUSH
102102: CALL_OW 1
102106: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
102107: LD_ADDR_EXP 184
102111: PUSH
102112: LD_EXP 184
102116: PPUSH
102117: LD_VAR 0 5
102121: PUSH
102122: LD_EXP 184
102126: PUSH
102127: LD_VAR 0 5
102131: ARRAY
102132: PUSH
102133: LD_INT 1
102135: PLUS
102136: PUSH
102137: EMPTY
102138: LIST
102139: LIST
102140: PPUSH
102141: LD_VAR 0 2
102145: PUSH
102146: LD_VAR 0 4
102150: ARRAY
102151: PUSH
102152: LD_VAR 0 2
102156: PUSH
102157: LD_VAR 0 4
102161: ARRAY
102162: PPUSH
102163: CALL_OW 255
102167: PUSH
102168: EMPTY
102169: LIST
102170: LIST
102171: PPUSH
102172: CALL 19824 0 3
102176: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
102177: LD_VAR 0 2
102181: PUSH
102182: LD_VAR 0 4
102186: ARRAY
102187: PPUSH
102188: LD_VAR 0 1
102192: PPUSH
102193: CALL_OW 255
102197: PPUSH
102198: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
102202: LD_VAR 0 2
102206: PUSH
102207: LD_VAR 0 4
102211: ARRAY
102212: PPUSH
102213: CALL_OW 141
// end ;
102217: GO 102049
102219: POP
102220: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102221: LD_VAR 0 1
102225: PPUSH
102226: LD_EXP 184
102230: PUSH
102231: LD_VAR 0 5
102235: ARRAY
102236: PUSH
102237: LD_INT 0
102239: PLUS
102240: PPUSH
102241: CALL_OW 505
// end ;
102245: LD_VAR 0 3
102249: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
102250: LD_INT 0
102252: PPUSH
102253: PPUSH
102254: PPUSH
102255: PPUSH
// if not hack in hackTanks then
102256: LD_VAR 0 1
102260: PUSH
102261: LD_EXP 183
102265: IN
102266: NOT
102267: IFFALSE 102271
// exit ;
102269: GO 102511
// index := GetElementIndex ( hackTanks , hack ) ;
102271: LD_ADDR_VAR 0 4
102275: PUSH
102276: LD_EXP 183
102280: PPUSH
102281: LD_VAR 0 1
102285: PPUSH
102286: CALL 19609 0 2
102290: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
102291: LD_ADDR_VAR 0 3
102295: PUSH
102296: DOUBLE
102297: LD_EXP 184
102301: PUSH
102302: LD_VAR 0 4
102306: ARRAY
102307: INC
102308: ST_TO_ADDR
102309: LD_INT 1
102311: PUSH
102312: FOR_DOWNTO
102313: IFFALSE 102485
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
102315: LD_ADDR_VAR 0 5
102319: PUSH
102320: LD_EXP 184
102324: PUSH
102325: LD_VAR 0 4
102329: ARRAY
102330: PUSH
102331: LD_VAR 0 3
102335: ARRAY
102336: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
102337: LD_VAR 0 5
102341: PUSH
102342: LD_INT 1
102344: ARRAY
102345: PPUSH
102346: CALL_OW 302
102350: NOT
102351: PUSH
102352: LD_VAR 0 5
102356: PUSH
102357: LD_INT 1
102359: ARRAY
102360: PPUSH
102361: CALL_OW 255
102365: PUSH
102366: LD_VAR 0 1
102370: PPUSH
102371: CALL_OW 255
102375: NONEQUAL
102376: OR
102377: IFFALSE 102483
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
102379: LD_VAR 0 5
102383: PUSH
102384: LD_INT 1
102386: ARRAY
102387: PPUSH
102388: CALL_OW 305
102392: PUSH
102393: LD_VAR 0 5
102397: PUSH
102398: LD_INT 1
102400: ARRAY
102401: PPUSH
102402: CALL_OW 255
102406: PUSH
102407: LD_VAR 0 1
102411: PPUSH
102412: CALL_OW 255
102416: EQUAL
102417: AND
102418: IFFALSE 102442
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
102420: LD_VAR 0 5
102424: PUSH
102425: LD_INT 1
102427: ARRAY
102428: PPUSH
102429: LD_VAR 0 5
102433: PUSH
102434: LD_INT 2
102436: ARRAY
102437: PPUSH
102438: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
102442: LD_ADDR_EXP 184
102446: PUSH
102447: LD_EXP 184
102451: PPUSH
102452: LD_VAR 0 4
102456: PPUSH
102457: LD_EXP 184
102461: PUSH
102462: LD_VAR 0 4
102466: ARRAY
102467: PPUSH
102468: LD_VAR 0 3
102472: PPUSH
102473: CALL_OW 3
102477: PPUSH
102478: CALL_OW 1
102482: ST_TO_ADDR
// end ; end ;
102483: GO 102312
102485: POP
102486: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102487: LD_VAR 0 1
102491: PPUSH
102492: LD_EXP 184
102496: PUSH
102497: LD_VAR 0 4
102501: ARRAY
102502: PUSH
102503: LD_INT 0
102505: PLUS
102506: PPUSH
102507: CALL_OW 505
// end ;
102511: LD_VAR 0 2
102515: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
102516: LD_INT 0
102518: PPUSH
102519: PPUSH
102520: PPUSH
102521: PPUSH
// if not hack in hackTanks then
102522: LD_VAR 0 1
102526: PUSH
102527: LD_EXP 183
102531: IN
102532: NOT
102533: IFFALSE 102537
// exit ;
102535: GO 102622
// index := GetElementIndex ( hackTanks , hack ) ;
102537: LD_ADDR_VAR 0 5
102541: PUSH
102542: LD_EXP 183
102546: PPUSH
102547: LD_VAR 0 1
102551: PPUSH
102552: CALL 19609 0 2
102556: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
102557: LD_ADDR_VAR 0 4
102561: PUSH
102562: DOUBLE
102563: LD_INT 1
102565: DEC
102566: ST_TO_ADDR
102567: LD_EXP 184
102571: PUSH
102572: LD_VAR 0 5
102576: ARRAY
102577: PUSH
102578: FOR_TO
102579: IFFALSE 102620
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
102581: LD_EXP 184
102585: PUSH
102586: LD_VAR 0 5
102590: ARRAY
102591: PUSH
102592: LD_VAR 0 4
102596: ARRAY
102597: PUSH
102598: LD_INT 1
102600: ARRAY
102601: PUSH
102602: LD_VAR 0 2
102606: EQUAL
102607: IFFALSE 102618
// KillUnit ( vehicle ) ;
102609: LD_VAR 0 2
102613: PPUSH
102614: CALL_OW 66
102618: GO 102578
102620: POP
102621: POP
// end ;
102622: LD_VAR 0 3
102626: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
102627: LD_EXP 188
102631: NOT
102632: IFFALSE 102667
102634: GO 102636
102636: DISABLE
// begin initMiner := true ;
102637: LD_ADDR_EXP 188
102641: PUSH
102642: LD_INT 1
102644: ST_TO_ADDR
// minersList := [ ] ;
102645: LD_ADDR_EXP 189
102649: PUSH
102650: EMPTY
102651: ST_TO_ADDR
// minerMinesList := [ ] ;
102652: LD_ADDR_EXP 190
102656: PUSH
102657: EMPTY
102658: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
102659: LD_ADDR_EXP 191
102663: PUSH
102664: LD_INT 5
102666: ST_TO_ADDR
// end ;
102667: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
102668: LD_EXP 188
102672: PUSH
102673: LD_INT 34
102675: PUSH
102676: LD_EXP 111
102680: PUSH
102681: EMPTY
102682: LIST
102683: LIST
102684: PPUSH
102685: CALL_OW 69
102689: AND
102690: IFFALSE 103153
102692: GO 102694
102694: DISABLE
102695: LD_INT 0
102697: PPUSH
102698: PPUSH
102699: PPUSH
102700: PPUSH
// begin enable ;
102701: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
102702: LD_ADDR_VAR 0 1
102706: PUSH
102707: LD_INT 34
102709: PUSH
102710: LD_EXP 111
102714: PUSH
102715: EMPTY
102716: LIST
102717: LIST
102718: PPUSH
102719: CALL_OW 69
102723: PUSH
102724: FOR_IN
102725: IFFALSE 102797
// begin if not i in minersList then
102727: LD_VAR 0 1
102731: PUSH
102732: LD_EXP 189
102736: IN
102737: NOT
102738: IFFALSE 102795
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
102740: LD_ADDR_EXP 189
102744: PUSH
102745: LD_EXP 189
102749: PPUSH
102750: LD_EXP 189
102754: PUSH
102755: LD_INT 1
102757: PLUS
102758: PPUSH
102759: LD_VAR 0 1
102763: PPUSH
102764: CALL_OW 1
102768: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
102769: LD_ADDR_EXP 190
102773: PUSH
102774: LD_EXP 190
102778: PPUSH
102779: LD_EXP 190
102783: PUSH
102784: LD_INT 1
102786: PLUS
102787: PPUSH
102788: EMPTY
102789: PPUSH
102790: CALL_OW 1
102794: ST_TO_ADDR
// end end ;
102795: GO 102724
102797: POP
102798: POP
// for i := minerMinesList downto 1 do
102799: LD_ADDR_VAR 0 1
102803: PUSH
102804: DOUBLE
102805: LD_EXP 190
102809: INC
102810: ST_TO_ADDR
102811: LD_INT 1
102813: PUSH
102814: FOR_DOWNTO
102815: IFFALSE 103151
// begin if IsLive ( minersList [ i ] ) then
102817: LD_EXP 189
102821: PUSH
102822: LD_VAR 0 1
102826: ARRAY
102827: PPUSH
102828: CALL_OW 300
102832: IFFALSE 102860
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
102834: LD_EXP 189
102838: PUSH
102839: LD_VAR 0 1
102843: ARRAY
102844: PPUSH
102845: LD_EXP 190
102849: PUSH
102850: LD_VAR 0 1
102854: ARRAY
102855: PPUSH
102856: CALL_OW 505
// if not minerMinesList [ i ] then
102860: LD_EXP 190
102864: PUSH
102865: LD_VAR 0 1
102869: ARRAY
102870: NOT
102871: IFFALSE 102875
// continue ;
102873: GO 102814
// for j := minerMinesList [ i ] downto 1 do
102875: LD_ADDR_VAR 0 2
102879: PUSH
102880: DOUBLE
102881: LD_EXP 190
102885: PUSH
102886: LD_VAR 0 1
102890: ARRAY
102891: INC
102892: ST_TO_ADDR
102893: LD_INT 1
102895: PUSH
102896: FOR_DOWNTO
102897: IFFALSE 103147
// begin side := GetSide ( minersList [ i ] ) ;
102899: LD_ADDR_VAR 0 3
102903: PUSH
102904: LD_EXP 189
102908: PUSH
102909: LD_VAR 0 1
102913: ARRAY
102914: PPUSH
102915: CALL_OW 255
102919: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
102920: LD_ADDR_VAR 0 4
102924: PUSH
102925: LD_EXP 190
102929: PUSH
102930: LD_VAR 0 1
102934: ARRAY
102935: PUSH
102936: LD_VAR 0 2
102940: ARRAY
102941: PUSH
102942: LD_INT 1
102944: ARRAY
102945: PPUSH
102946: LD_EXP 190
102950: PUSH
102951: LD_VAR 0 1
102955: ARRAY
102956: PUSH
102957: LD_VAR 0 2
102961: ARRAY
102962: PUSH
102963: LD_INT 2
102965: ARRAY
102966: PPUSH
102967: CALL_OW 428
102971: ST_TO_ADDR
// if not tmp then
102972: LD_VAR 0 4
102976: NOT
102977: IFFALSE 102981
// continue ;
102979: GO 102896
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
102981: LD_VAR 0 4
102985: PUSH
102986: LD_INT 81
102988: PUSH
102989: LD_VAR 0 3
102993: PUSH
102994: EMPTY
102995: LIST
102996: LIST
102997: PPUSH
102998: CALL_OW 69
103002: IN
103003: PUSH
103004: LD_EXP 190
103008: PUSH
103009: LD_VAR 0 1
103013: ARRAY
103014: PUSH
103015: LD_VAR 0 2
103019: ARRAY
103020: PUSH
103021: LD_INT 1
103023: ARRAY
103024: PPUSH
103025: LD_EXP 190
103029: PUSH
103030: LD_VAR 0 1
103034: ARRAY
103035: PUSH
103036: LD_VAR 0 2
103040: ARRAY
103041: PUSH
103042: LD_INT 2
103044: ARRAY
103045: PPUSH
103046: CALL_OW 458
103050: AND
103051: IFFALSE 103145
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
103053: LD_EXP 190
103057: PUSH
103058: LD_VAR 0 1
103062: ARRAY
103063: PUSH
103064: LD_VAR 0 2
103068: ARRAY
103069: PUSH
103070: LD_INT 1
103072: ARRAY
103073: PPUSH
103074: LD_EXP 190
103078: PUSH
103079: LD_VAR 0 1
103083: ARRAY
103084: PUSH
103085: LD_VAR 0 2
103089: ARRAY
103090: PUSH
103091: LD_INT 2
103093: ARRAY
103094: PPUSH
103095: LD_VAR 0 3
103099: PPUSH
103100: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
103104: LD_ADDR_EXP 190
103108: PUSH
103109: LD_EXP 190
103113: PPUSH
103114: LD_VAR 0 1
103118: PPUSH
103119: LD_EXP 190
103123: PUSH
103124: LD_VAR 0 1
103128: ARRAY
103129: PPUSH
103130: LD_VAR 0 2
103134: PPUSH
103135: CALL_OW 3
103139: PPUSH
103140: CALL_OW 1
103144: ST_TO_ADDR
// end ; end ;
103145: GO 102896
103147: POP
103148: POP
// end ;
103149: GO 102814
103151: POP
103152: POP
// end ;
103153: PPOPN 4
103155: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
103156: LD_INT 0
103158: PPUSH
103159: PPUSH
// result := false ;
103160: LD_ADDR_VAR 0 4
103164: PUSH
103165: LD_INT 0
103167: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
103168: LD_VAR 0 1
103172: PPUSH
103173: CALL_OW 264
103177: PUSH
103178: LD_EXP 111
103182: EQUAL
103183: NOT
103184: IFFALSE 103188
// exit ;
103186: GO 103428
// index := GetElementIndex ( minersList , unit ) ;
103188: LD_ADDR_VAR 0 5
103192: PUSH
103193: LD_EXP 189
103197: PPUSH
103198: LD_VAR 0 1
103202: PPUSH
103203: CALL 19609 0 2
103207: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
103208: LD_EXP 190
103212: PUSH
103213: LD_VAR 0 5
103217: ARRAY
103218: PUSH
103219: LD_EXP 191
103223: GREATEREQUAL
103224: IFFALSE 103228
// exit ;
103226: GO 103428
// ComMoveXY ( unit , x , y ) ;
103228: LD_VAR 0 1
103232: PPUSH
103233: LD_VAR 0 2
103237: PPUSH
103238: LD_VAR 0 3
103242: PPUSH
103243: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
103247: LD_INT 35
103249: PPUSH
103250: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
103254: LD_VAR 0 1
103258: PPUSH
103259: LD_VAR 0 2
103263: PPUSH
103264: LD_VAR 0 3
103268: PPUSH
103269: CALL 50328 0 3
103273: NOT
103274: PUSH
103275: LD_VAR 0 1
103279: PPUSH
103280: CALL_OW 314
103284: AND
103285: IFFALSE 103289
// exit ;
103287: GO 103428
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
103289: LD_VAR 0 2
103293: PPUSH
103294: LD_VAR 0 3
103298: PPUSH
103299: CALL_OW 428
103303: PUSH
103304: LD_VAR 0 1
103308: EQUAL
103309: PUSH
103310: LD_VAR 0 1
103314: PPUSH
103315: CALL_OW 314
103319: NOT
103320: AND
103321: IFFALSE 103247
// PlaySoundXY ( x , y , PlantMine ) ;
103323: LD_VAR 0 2
103327: PPUSH
103328: LD_VAR 0 3
103332: PPUSH
103333: LD_STRING PlantMine
103335: PPUSH
103336: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
103340: LD_VAR 0 2
103344: PPUSH
103345: LD_VAR 0 3
103349: PPUSH
103350: LD_VAR 0 1
103354: PPUSH
103355: CALL_OW 255
103359: PPUSH
103360: LD_INT 0
103362: PPUSH
103363: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
103367: LD_ADDR_EXP 190
103371: PUSH
103372: LD_EXP 190
103376: PPUSH
103377: LD_VAR 0 5
103381: PUSH
103382: LD_EXP 190
103386: PUSH
103387: LD_VAR 0 5
103391: ARRAY
103392: PUSH
103393: LD_INT 1
103395: PLUS
103396: PUSH
103397: EMPTY
103398: LIST
103399: LIST
103400: PPUSH
103401: LD_VAR 0 2
103405: PUSH
103406: LD_VAR 0 3
103410: PUSH
103411: EMPTY
103412: LIST
103413: LIST
103414: PPUSH
103415: CALL 19824 0 3
103419: ST_TO_ADDR
// result := true ;
103420: LD_ADDR_VAR 0 4
103424: PUSH
103425: LD_INT 1
103427: ST_TO_ADDR
// end ;
103428: LD_VAR 0 4
103432: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
103433: LD_INT 0
103435: PPUSH
103436: PPUSH
103437: PPUSH
// if not unit in minersList then
103438: LD_VAR 0 1
103442: PUSH
103443: LD_EXP 189
103447: IN
103448: NOT
103449: IFFALSE 103453
// exit ;
103451: GO 103845
// index := GetElementIndex ( minersList , unit ) ;
103453: LD_ADDR_VAR 0 6
103457: PUSH
103458: LD_EXP 189
103462: PPUSH
103463: LD_VAR 0 1
103467: PPUSH
103468: CALL 19609 0 2
103472: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
103473: LD_ADDR_VAR 0 5
103477: PUSH
103478: DOUBLE
103479: LD_EXP 190
103483: PUSH
103484: LD_VAR 0 6
103488: ARRAY
103489: INC
103490: ST_TO_ADDR
103491: LD_INT 1
103493: PUSH
103494: FOR_DOWNTO
103495: IFFALSE 103656
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
103497: LD_EXP 190
103501: PUSH
103502: LD_VAR 0 6
103506: ARRAY
103507: PUSH
103508: LD_VAR 0 5
103512: ARRAY
103513: PUSH
103514: LD_INT 1
103516: ARRAY
103517: PUSH
103518: LD_VAR 0 2
103522: EQUAL
103523: PUSH
103524: LD_EXP 190
103528: PUSH
103529: LD_VAR 0 6
103533: ARRAY
103534: PUSH
103535: LD_VAR 0 5
103539: ARRAY
103540: PUSH
103541: LD_INT 2
103543: ARRAY
103544: PUSH
103545: LD_VAR 0 3
103549: EQUAL
103550: AND
103551: IFFALSE 103654
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
103553: LD_EXP 190
103557: PUSH
103558: LD_VAR 0 6
103562: ARRAY
103563: PUSH
103564: LD_VAR 0 5
103568: ARRAY
103569: PUSH
103570: LD_INT 1
103572: ARRAY
103573: PPUSH
103574: LD_EXP 190
103578: PUSH
103579: LD_VAR 0 6
103583: ARRAY
103584: PUSH
103585: LD_VAR 0 5
103589: ARRAY
103590: PUSH
103591: LD_INT 2
103593: ARRAY
103594: PPUSH
103595: LD_VAR 0 1
103599: PPUSH
103600: CALL_OW 255
103604: PPUSH
103605: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
103609: LD_ADDR_EXP 190
103613: PUSH
103614: LD_EXP 190
103618: PPUSH
103619: LD_VAR 0 6
103623: PPUSH
103624: LD_EXP 190
103628: PUSH
103629: LD_VAR 0 6
103633: ARRAY
103634: PPUSH
103635: LD_VAR 0 5
103639: PPUSH
103640: CALL_OW 3
103644: PPUSH
103645: CALL_OW 1
103649: ST_TO_ADDR
// exit ;
103650: POP
103651: POP
103652: GO 103845
// end ; end ;
103654: GO 103494
103656: POP
103657: POP
// for i := minerMinesList [ index ] downto 1 do
103658: LD_ADDR_VAR 0 5
103662: PUSH
103663: DOUBLE
103664: LD_EXP 190
103668: PUSH
103669: LD_VAR 0 6
103673: ARRAY
103674: INC
103675: ST_TO_ADDR
103676: LD_INT 1
103678: PUSH
103679: FOR_DOWNTO
103680: IFFALSE 103843
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
103682: LD_EXP 190
103686: PUSH
103687: LD_VAR 0 6
103691: ARRAY
103692: PUSH
103693: LD_VAR 0 5
103697: ARRAY
103698: PUSH
103699: LD_INT 1
103701: ARRAY
103702: PPUSH
103703: LD_EXP 190
103707: PUSH
103708: LD_VAR 0 6
103712: ARRAY
103713: PUSH
103714: LD_VAR 0 5
103718: ARRAY
103719: PUSH
103720: LD_INT 2
103722: ARRAY
103723: PPUSH
103724: LD_VAR 0 2
103728: PPUSH
103729: LD_VAR 0 3
103733: PPUSH
103734: CALL_OW 298
103738: PUSH
103739: LD_INT 6
103741: LESS
103742: IFFALSE 103841
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
103744: LD_EXP 190
103748: PUSH
103749: LD_VAR 0 6
103753: ARRAY
103754: PUSH
103755: LD_VAR 0 5
103759: ARRAY
103760: PUSH
103761: LD_INT 1
103763: ARRAY
103764: PPUSH
103765: LD_EXP 190
103769: PUSH
103770: LD_VAR 0 6
103774: ARRAY
103775: PUSH
103776: LD_VAR 0 5
103780: ARRAY
103781: PUSH
103782: LD_INT 2
103784: ARRAY
103785: PPUSH
103786: LD_VAR 0 1
103790: PPUSH
103791: CALL_OW 255
103795: PPUSH
103796: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
103800: LD_ADDR_EXP 190
103804: PUSH
103805: LD_EXP 190
103809: PPUSH
103810: LD_VAR 0 6
103814: PPUSH
103815: LD_EXP 190
103819: PUSH
103820: LD_VAR 0 6
103824: ARRAY
103825: PPUSH
103826: LD_VAR 0 5
103830: PPUSH
103831: CALL_OW 3
103835: PPUSH
103836: CALL_OW 1
103840: ST_TO_ADDR
// end ; end ;
103841: GO 103679
103843: POP
103844: POP
// end ;
103845: LD_VAR 0 4
103849: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
103850: LD_INT 0
103852: PPUSH
103853: PPUSH
103854: PPUSH
103855: PPUSH
103856: PPUSH
103857: PPUSH
103858: PPUSH
103859: PPUSH
103860: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
103861: LD_VAR 0 1
103865: PPUSH
103866: CALL_OW 264
103870: PUSH
103871: LD_EXP 111
103875: EQUAL
103876: NOT
103877: PUSH
103878: LD_VAR 0 1
103882: PUSH
103883: LD_EXP 189
103887: IN
103888: NOT
103889: OR
103890: IFFALSE 103894
// exit ;
103892: GO 104216
// index := GetElementIndex ( minersList , unit ) ;
103894: LD_ADDR_VAR 0 6
103898: PUSH
103899: LD_EXP 189
103903: PPUSH
103904: LD_VAR 0 1
103908: PPUSH
103909: CALL 19609 0 2
103913: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
103914: LD_ADDR_VAR 0 8
103918: PUSH
103919: LD_EXP 191
103923: PUSH
103924: LD_EXP 190
103928: PUSH
103929: LD_VAR 0 6
103933: ARRAY
103934: MINUS
103935: ST_TO_ADDR
// if not minesFreeAmount then
103936: LD_VAR 0 8
103940: NOT
103941: IFFALSE 103945
// exit ;
103943: GO 104216
// tmp := [ ] ;
103945: LD_ADDR_VAR 0 7
103949: PUSH
103950: EMPTY
103951: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
103952: LD_ADDR_VAR 0 5
103956: PUSH
103957: DOUBLE
103958: LD_INT 1
103960: DEC
103961: ST_TO_ADDR
103962: LD_VAR 0 8
103966: PUSH
103967: FOR_TO
103968: IFFALSE 104163
// begin _d := rand ( 0 , 5 ) ;
103970: LD_ADDR_VAR 0 11
103974: PUSH
103975: LD_INT 0
103977: PPUSH
103978: LD_INT 5
103980: PPUSH
103981: CALL_OW 12
103985: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
103986: LD_ADDR_VAR 0 12
103990: PUSH
103991: LD_INT 2
103993: PPUSH
103994: LD_INT 6
103996: PPUSH
103997: CALL_OW 12
104001: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
104002: LD_ADDR_VAR 0 9
104006: PUSH
104007: LD_VAR 0 2
104011: PPUSH
104012: LD_VAR 0 11
104016: PPUSH
104017: LD_VAR 0 12
104021: PPUSH
104022: CALL_OW 272
104026: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
104027: LD_ADDR_VAR 0 10
104031: PUSH
104032: LD_VAR 0 3
104036: PPUSH
104037: LD_VAR 0 11
104041: PPUSH
104042: LD_VAR 0 12
104046: PPUSH
104047: CALL_OW 273
104051: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
104052: LD_VAR 0 9
104056: PPUSH
104057: LD_VAR 0 10
104061: PPUSH
104062: CALL_OW 488
104066: PUSH
104067: LD_VAR 0 9
104071: PUSH
104072: LD_VAR 0 10
104076: PUSH
104077: EMPTY
104078: LIST
104079: LIST
104080: PUSH
104081: LD_VAR 0 7
104085: IN
104086: NOT
104087: AND
104088: PUSH
104089: LD_VAR 0 9
104093: PPUSH
104094: LD_VAR 0 10
104098: PPUSH
104099: CALL_OW 458
104103: NOT
104104: AND
104105: IFFALSE 104147
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
104107: LD_ADDR_VAR 0 7
104111: PUSH
104112: LD_VAR 0 7
104116: PPUSH
104117: LD_VAR 0 7
104121: PUSH
104122: LD_INT 1
104124: PLUS
104125: PPUSH
104126: LD_VAR 0 9
104130: PUSH
104131: LD_VAR 0 10
104135: PUSH
104136: EMPTY
104137: LIST
104138: LIST
104139: PPUSH
104140: CALL_OW 1
104144: ST_TO_ADDR
104145: GO 104161
// i := i - 1 ;
104147: LD_ADDR_VAR 0 5
104151: PUSH
104152: LD_VAR 0 5
104156: PUSH
104157: LD_INT 1
104159: MINUS
104160: ST_TO_ADDR
// end ;
104161: GO 103967
104163: POP
104164: POP
// for i in tmp do
104165: LD_ADDR_VAR 0 5
104169: PUSH
104170: LD_VAR 0 7
104174: PUSH
104175: FOR_IN
104176: IFFALSE 104214
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
104178: LD_VAR 0 1
104182: PPUSH
104183: LD_VAR 0 5
104187: PUSH
104188: LD_INT 1
104190: ARRAY
104191: PPUSH
104192: LD_VAR 0 5
104196: PUSH
104197: LD_INT 2
104199: ARRAY
104200: PPUSH
104201: CALL 103156 0 3
104205: NOT
104206: IFFALSE 104212
// exit ;
104208: POP
104209: POP
104210: GO 104216
104212: GO 104175
104214: POP
104215: POP
// end ;
104216: LD_VAR 0 4
104220: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
104221: LD_INT 0
104223: PPUSH
104224: PPUSH
104225: PPUSH
104226: PPUSH
104227: PPUSH
104228: PPUSH
104229: PPUSH
// if not GetClass ( unit ) = class_sniper then
104230: LD_VAR 0 1
104234: PPUSH
104235: CALL_OW 257
104239: PUSH
104240: LD_INT 5
104242: EQUAL
104243: NOT
104244: IFFALSE 104248
// exit ;
104246: GO 104636
// dist := 8 ;
104248: LD_ADDR_VAR 0 5
104252: PUSH
104253: LD_INT 8
104255: ST_TO_ADDR
// viewRange := 12 ;
104256: LD_ADDR_VAR 0 7
104260: PUSH
104261: LD_INT 12
104263: ST_TO_ADDR
// side := GetSide ( unit ) ;
104264: LD_ADDR_VAR 0 6
104268: PUSH
104269: LD_VAR 0 1
104273: PPUSH
104274: CALL_OW 255
104278: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
104279: LD_INT 61
104281: PPUSH
104282: LD_VAR 0 6
104286: PPUSH
104287: CALL_OW 321
104291: PUSH
104292: LD_INT 2
104294: EQUAL
104295: IFFALSE 104305
// viewRange := 16 ;
104297: LD_ADDR_VAR 0 7
104301: PUSH
104302: LD_INT 16
104304: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
104305: LD_VAR 0 1
104309: PPUSH
104310: LD_VAR 0 2
104314: PPUSH
104315: LD_VAR 0 3
104319: PPUSH
104320: CALL_OW 297
104324: PUSH
104325: LD_VAR 0 5
104329: GREATER
104330: IFFALSE 104409
// begin ComMoveXY ( unit , x , y ) ;
104332: LD_VAR 0 1
104336: PPUSH
104337: LD_VAR 0 2
104341: PPUSH
104342: LD_VAR 0 3
104346: PPUSH
104347: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104351: LD_INT 35
104353: PPUSH
104354: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
104358: LD_VAR 0 1
104362: PPUSH
104363: LD_VAR 0 2
104367: PPUSH
104368: LD_VAR 0 3
104372: PPUSH
104373: CALL 50328 0 3
104377: NOT
104378: IFFALSE 104382
// exit ;
104380: GO 104636
// until GetDistUnitXY ( unit , x , y ) < dist ;
104382: LD_VAR 0 1
104386: PPUSH
104387: LD_VAR 0 2
104391: PPUSH
104392: LD_VAR 0 3
104396: PPUSH
104397: CALL_OW 297
104401: PUSH
104402: LD_VAR 0 5
104406: LESS
104407: IFFALSE 104351
// end ; ComTurnXY ( unit , x , y ) ;
104409: LD_VAR 0 1
104413: PPUSH
104414: LD_VAR 0 2
104418: PPUSH
104419: LD_VAR 0 3
104423: PPUSH
104424: CALL_OW 118
// wait ( 5 ) ;
104428: LD_INT 5
104430: PPUSH
104431: CALL_OW 67
// _d := GetDir ( unit ) ;
104435: LD_ADDR_VAR 0 10
104439: PUSH
104440: LD_VAR 0 1
104444: PPUSH
104445: CALL_OW 254
104449: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
104450: LD_ADDR_VAR 0 8
104454: PUSH
104455: LD_VAR 0 1
104459: PPUSH
104460: CALL_OW 250
104464: PPUSH
104465: LD_VAR 0 10
104469: PPUSH
104470: LD_VAR 0 5
104474: PPUSH
104475: CALL_OW 272
104479: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
104480: LD_ADDR_VAR 0 9
104484: PUSH
104485: LD_VAR 0 1
104489: PPUSH
104490: CALL_OW 251
104494: PPUSH
104495: LD_VAR 0 10
104499: PPUSH
104500: LD_VAR 0 5
104504: PPUSH
104505: CALL_OW 273
104509: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
104510: LD_VAR 0 8
104514: PPUSH
104515: LD_VAR 0 9
104519: PPUSH
104520: CALL_OW 488
104524: NOT
104525: IFFALSE 104529
// exit ;
104527: GO 104636
// ComAnimCustom ( unit , 1 ) ;
104529: LD_VAR 0 1
104533: PPUSH
104534: LD_INT 1
104536: PPUSH
104537: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
104541: LD_VAR 0 8
104545: PPUSH
104546: LD_VAR 0 9
104550: PPUSH
104551: LD_VAR 0 6
104555: PPUSH
104556: LD_VAR 0 7
104560: PPUSH
104561: CALL_OW 330
// repeat wait ( 1 ) ;
104565: LD_INT 1
104567: PPUSH
104568: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
104572: LD_VAR 0 1
104576: PPUSH
104577: CALL_OW 316
104581: PUSH
104582: LD_VAR 0 1
104586: PPUSH
104587: CALL_OW 314
104591: OR
104592: PUSH
104593: LD_VAR 0 1
104597: PPUSH
104598: CALL_OW 302
104602: NOT
104603: OR
104604: PUSH
104605: LD_VAR 0 1
104609: PPUSH
104610: CALL_OW 301
104614: OR
104615: IFFALSE 104565
// RemoveSeeing ( _x , _y , side ) ;
104617: LD_VAR 0 8
104621: PPUSH
104622: LD_VAR 0 9
104626: PPUSH
104627: LD_VAR 0 6
104631: PPUSH
104632: CALL_OW 331
// end ; end_of_file
104636: LD_VAR 0 4
104640: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
104641: LD_INT 0
104643: PPUSH
104644: PPUSH
104645: PPUSH
104646: PPUSH
104647: PPUSH
104648: PPUSH
104649: PPUSH
104650: PPUSH
104651: PPUSH
104652: PPUSH
104653: PPUSH
104654: PPUSH
104655: PPUSH
104656: PPUSH
104657: PPUSH
104658: PPUSH
104659: PPUSH
104660: PPUSH
104661: PPUSH
104662: PPUSH
104663: PPUSH
104664: PPUSH
104665: PPUSH
104666: PPUSH
104667: PPUSH
104668: PPUSH
104669: PPUSH
104670: PPUSH
104671: PPUSH
104672: PPUSH
104673: PPUSH
104674: PPUSH
104675: PPUSH
104676: PPUSH
// if not list then
104677: LD_VAR 0 1
104681: NOT
104682: IFFALSE 104686
// exit ;
104684: GO 109345
// base := list [ 1 ] ;
104686: LD_ADDR_VAR 0 3
104690: PUSH
104691: LD_VAR 0 1
104695: PUSH
104696: LD_INT 1
104698: ARRAY
104699: ST_TO_ADDR
// group := list [ 2 ] ;
104700: LD_ADDR_VAR 0 4
104704: PUSH
104705: LD_VAR 0 1
104709: PUSH
104710: LD_INT 2
104712: ARRAY
104713: ST_TO_ADDR
// path := list [ 3 ] ;
104714: LD_ADDR_VAR 0 5
104718: PUSH
104719: LD_VAR 0 1
104723: PUSH
104724: LD_INT 3
104726: ARRAY
104727: ST_TO_ADDR
// flags := list [ 4 ] ;
104728: LD_ADDR_VAR 0 6
104732: PUSH
104733: LD_VAR 0 1
104737: PUSH
104738: LD_INT 4
104740: ARRAY
104741: ST_TO_ADDR
// mined := [ ] ;
104742: LD_ADDR_VAR 0 27
104746: PUSH
104747: EMPTY
104748: ST_TO_ADDR
// bombed := [ ] ;
104749: LD_ADDR_VAR 0 28
104753: PUSH
104754: EMPTY
104755: ST_TO_ADDR
// healers := [ ] ;
104756: LD_ADDR_VAR 0 31
104760: PUSH
104761: EMPTY
104762: ST_TO_ADDR
// to_heal := [ ] ;
104763: LD_ADDR_VAR 0 30
104767: PUSH
104768: EMPTY
104769: ST_TO_ADDR
// repairs := [ ] ;
104770: LD_ADDR_VAR 0 33
104774: PUSH
104775: EMPTY
104776: ST_TO_ADDR
// to_repair := [ ] ;
104777: LD_ADDR_VAR 0 32
104781: PUSH
104782: EMPTY
104783: ST_TO_ADDR
// if not group or not path then
104784: LD_VAR 0 4
104788: NOT
104789: PUSH
104790: LD_VAR 0 5
104794: NOT
104795: OR
104796: IFFALSE 104800
// exit ;
104798: GO 109345
// side := GetSide ( group [ 1 ] ) ;
104800: LD_ADDR_VAR 0 35
104804: PUSH
104805: LD_VAR 0 4
104809: PUSH
104810: LD_INT 1
104812: ARRAY
104813: PPUSH
104814: CALL_OW 255
104818: ST_TO_ADDR
// if flags then
104819: LD_VAR 0 6
104823: IFFALSE 104967
// begin f_ignore_area := flags [ 1 ] ;
104825: LD_ADDR_VAR 0 17
104829: PUSH
104830: LD_VAR 0 6
104834: PUSH
104835: LD_INT 1
104837: ARRAY
104838: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
104839: LD_ADDR_VAR 0 18
104843: PUSH
104844: LD_VAR 0 6
104848: PUSH
104849: LD_INT 2
104851: ARRAY
104852: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
104853: LD_ADDR_VAR 0 19
104857: PUSH
104858: LD_VAR 0 6
104862: PUSH
104863: LD_INT 3
104865: ARRAY
104866: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
104867: LD_ADDR_VAR 0 20
104871: PUSH
104872: LD_VAR 0 6
104876: PUSH
104877: LD_INT 4
104879: ARRAY
104880: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
104881: LD_ADDR_VAR 0 21
104885: PUSH
104886: LD_VAR 0 6
104890: PUSH
104891: LD_INT 5
104893: ARRAY
104894: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
104895: LD_ADDR_VAR 0 22
104899: PUSH
104900: LD_VAR 0 6
104904: PUSH
104905: LD_INT 6
104907: ARRAY
104908: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
104909: LD_ADDR_VAR 0 23
104913: PUSH
104914: LD_VAR 0 6
104918: PUSH
104919: LD_INT 7
104921: ARRAY
104922: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
104923: LD_ADDR_VAR 0 24
104927: PUSH
104928: LD_VAR 0 6
104932: PUSH
104933: LD_INT 8
104935: ARRAY
104936: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
104937: LD_ADDR_VAR 0 25
104941: PUSH
104942: LD_VAR 0 6
104946: PUSH
104947: LD_INT 9
104949: ARRAY
104950: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
104951: LD_ADDR_VAR 0 26
104955: PUSH
104956: LD_VAR 0 6
104960: PUSH
104961: LD_INT 10
104963: ARRAY
104964: ST_TO_ADDR
// end else
104965: GO 105047
// begin f_ignore_area := false ;
104967: LD_ADDR_VAR 0 17
104971: PUSH
104972: LD_INT 0
104974: ST_TO_ADDR
// f_capture := false ;
104975: LD_ADDR_VAR 0 18
104979: PUSH
104980: LD_INT 0
104982: ST_TO_ADDR
// f_ignore_civ := false ;
104983: LD_ADDR_VAR 0 19
104987: PUSH
104988: LD_INT 0
104990: ST_TO_ADDR
// f_murder := false ;
104991: LD_ADDR_VAR 0 20
104995: PUSH
104996: LD_INT 0
104998: ST_TO_ADDR
// f_mines := false ;
104999: LD_ADDR_VAR 0 21
105003: PUSH
105004: LD_INT 0
105006: ST_TO_ADDR
// f_repair := false ;
105007: LD_ADDR_VAR 0 22
105011: PUSH
105012: LD_INT 0
105014: ST_TO_ADDR
// f_heal := false ;
105015: LD_ADDR_VAR 0 23
105019: PUSH
105020: LD_INT 0
105022: ST_TO_ADDR
// f_spacetime := false ;
105023: LD_ADDR_VAR 0 24
105027: PUSH
105028: LD_INT 0
105030: ST_TO_ADDR
// f_attack_depot := false ;
105031: LD_ADDR_VAR 0 25
105035: PUSH
105036: LD_INT 0
105038: ST_TO_ADDR
// f_crawl := false ;
105039: LD_ADDR_VAR 0 26
105043: PUSH
105044: LD_INT 0
105046: ST_TO_ADDR
// end ; if f_heal then
105047: LD_VAR 0 23
105051: IFFALSE 105078
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
105053: LD_ADDR_VAR 0 31
105057: PUSH
105058: LD_VAR 0 4
105062: PPUSH
105063: LD_INT 25
105065: PUSH
105066: LD_INT 4
105068: PUSH
105069: EMPTY
105070: LIST
105071: LIST
105072: PPUSH
105073: CALL_OW 72
105077: ST_TO_ADDR
// if f_repair then
105078: LD_VAR 0 22
105082: IFFALSE 105109
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
105084: LD_ADDR_VAR 0 33
105088: PUSH
105089: LD_VAR 0 4
105093: PPUSH
105094: LD_INT 25
105096: PUSH
105097: LD_INT 3
105099: PUSH
105100: EMPTY
105101: LIST
105102: LIST
105103: PPUSH
105104: CALL_OW 72
105108: ST_TO_ADDR
// units_path := [ ] ;
105109: LD_ADDR_VAR 0 16
105113: PUSH
105114: EMPTY
105115: ST_TO_ADDR
// for i = 1 to group do
105116: LD_ADDR_VAR 0 7
105120: PUSH
105121: DOUBLE
105122: LD_INT 1
105124: DEC
105125: ST_TO_ADDR
105126: LD_VAR 0 4
105130: PUSH
105131: FOR_TO
105132: IFFALSE 105161
// units_path := Replace ( units_path , i , path ) ;
105134: LD_ADDR_VAR 0 16
105138: PUSH
105139: LD_VAR 0 16
105143: PPUSH
105144: LD_VAR 0 7
105148: PPUSH
105149: LD_VAR 0 5
105153: PPUSH
105154: CALL_OW 1
105158: ST_TO_ADDR
105159: GO 105131
105161: POP
105162: POP
// repeat for i = group downto 1 do
105163: LD_ADDR_VAR 0 7
105167: PUSH
105168: DOUBLE
105169: LD_VAR 0 4
105173: INC
105174: ST_TO_ADDR
105175: LD_INT 1
105177: PUSH
105178: FOR_DOWNTO
105179: IFFALSE 109301
// begin wait ( 5 ) ;
105181: LD_INT 5
105183: PPUSH
105184: CALL_OW 67
// tmp := [ ] ;
105188: LD_ADDR_VAR 0 14
105192: PUSH
105193: EMPTY
105194: ST_TO_ADDR
// attacking := false ;
105195: LD_ADDR_VAR 0 29
105199: PUSH
105200: LD_INT 0
105202: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
105203: LD_VAR 0 4
105207: PUSH
105208: LD_VAR 0 7
105212: ARRAY
105213: PPUSH
105214: CALL_OW 301
105218: PUSH
105219: LD_VAR 0 4
105223: PUSH
105224: LD_VAR 0 7
105228: ARRAY
105229: NOT
105230: OR
105231: IFFALSE 105340
// begin if GetType ( group [ i ] ) = unit_human then
105233: LD_VAR 0 4
105237: PUSH
105238: LD_VAR 0 7
105242: ARRAY
105243: PPUSH
105244: CALL_OW 247
105248: PUSH
105249: LD_INT 1
105251: EQUAL
105252: IFFALSE 105298
// begin to_heal := to_heal diff group [ i ] ;
105254: LD_ADDR_VAR 0 30
105258: PUSH
105259: LD_VAR 0 30
105263: PUSH
105264: LD_VAR 0 4
105268: PUSH
105269: LD_VAR 0 7
105273: ARRAY
105274: DIFF
105275: ST_TO_ADDR
// healers := healers diff group [ i ] ;
105276: LD_ADDR_VAR 0 31
105280: PUSH
105281: LD_VAR 0 31
105285: PUSH
105286: LD_VAR 0 4
105290: PUSH
105291: LD_VAR 0 7
105295: ARRAY
105296: DIFF
105297: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
105298: LD_ADDR_VAR 0 4
105302: PUSH
105303: LD_VAR 0 4
105307: PPUSH
105308: LD_VAR 0 7
105312: PPUSH
105313: CALL_OW 3
105317: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
105318: LD_ADDR_VAR 0 16
105322: PUSH
105323: LD_VAR 0 16
105327: PPUSH
105328: LD_VAR 0 7
105332: PPUSH
105333: CALL_OW 3
105337: ST_TO_ADDR
// continue ;
105338: GO 105178
// end ; if f_repair then
105340: LD_VAR 0 22
105344: IFFALSE 105833
// begin if GetType ( group [ i ] ) = unit_vehicle then
105346: LD_VAR 0 4
105350: PUSH
105351: LD_VAR 0 7
105355: ARRAY
105356: PPUSH
105357: CALL_OW 247
105361: PUSH
105362: LD_INT 2
105364: EQUAL
105365: IFFALSE 105555
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
105367: LD_VAR 0 4
105371: PUSH
105372: LD_VAR 0 7
105376: ARRAY
105377: PPUSH
105378: CALL_OW 256
105382: PUSH
105383: LD_INT 700
105385: LESS
105386: PUSH
105387: LD_VAR 0 4
105391: PUSH
105392: LD_VAR 0 7
105396: ARRAY
105397: PUSH
105398: LD_VAR 0 32
105402: IN
105403: NOT
105404: AND
105405: IFFALSE 105429
// to_repair := to_repair union group [ i ] ;
105407: LD_ADDR_VAR 0 32
105411: PUSH
105412: LD_VAR 0 32
105416: PUSH
105417: LD_VAR 0 4
105421: PUSH
105422: LD_VAR 0 7
105426: ARRAY
105427: UNION
105428: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
105429: LD_VAR 0 4
105433: PUSH
105434: LD_VAR 0 7
105438: ARRAY
105439: PPUSH
105440: CALL_OW 256
105444: PUSH
105445: LD_INT 1000
105447: EQUAL
105448: PUSH
105449: LD_VAR 0 4
105453: PUSH
105454: LD_VAR 0 7
105458: ARRAY
105459: PUSH
105460: LD_VAR 0 32
105464: IN
105465: AND
105466: IFFALSE 105490
// to_repair := to_repair diff group [ i ] ;
105468: LD_ADDR_VAR 0 32
105472: PUSH
105473: LD_VAR 0 32
105477: PUSH
105478: LD_VAR 0 4
105482: PUSH
105483: LD_VAR 0 7
105487: ARRAY
105488: DIFF
105489: ST_TO_ADDR
// if group [ i ] in to_repair then
105490: LD_VAR 0 4
105494: PUSH
105495: LD_VAR 0 7
105499: ARRAY
105500: PUSH
105501: LD_VAR 0 32
105505: IN
105506: IFFALSE 105553
// begin if not IsInArea ( group [ i ] , f_repair ) then
105508: LD_VAR 0 4
105512: PUSH
105513: LD_VAR 0 7
105517: ARRAY
105518: PPUSH
105519: LD_VAR 0 22
105523: PPUSH
105524: CALL_OW 308
105528: NOT
105529: IFFALSE 105551
// ComMoveToArea ( group [ i ] , f_repair ) ;
105531: LD_VAR 0 4
105535: PUSH
105536: LD_VAR 0 7
105540: ARRAY
105541: PPUSH
105542: LD_VAR 0 22
105546: PPUSH
105547: CALL_OW 113
// continue ;
105551: GO 105178
// end ; end else
105553: GO 105833
// if group [ i ] in repairs then
105555: LD_VAR 0 4
105559: PUSH
105560: LD_VAR 0 7
105564: ARRAY
105565: PUSH
105566: LD_VAR 0 33
105570: IN
105571: IFFALSE 105833
// begin if IsInUnit ( group [ i ] ) then
105573: LD_VAR 0 4
105577: PUSH
105578: LD_VAR 0 7
105582: ARRAY
105583: PPUSH
105584: CALL_OW 310
105588: IFFALSE 105656
// begin z := IsInUnit ( group [ i ] ) ;
105590: LD_ADDR_VAR 0 13
105594: PUSH
105595: LD_VAR 0 4
105599: PUSH
105600: LD_VAR 0 7
105604: ARRAY
105605: PPUSH
105606: CALL_OW 310
105610: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
105611: LD_VAR 0 13
105615: PUSH
105616: LD_VAR 0 32
105620: IN
105621: PUSH
105622: LD_VAR 0 13
105626: PPUSH
105627: LD_VAR 0 22
105631: PPUSH
105632: CALL_OW 308
105636: AND
105637: IFFALSE 105654
// ComExitVehicle ( group [ i ] ) ;
105639: LD_VAR 0 4
105643: PUSH
105644: LD_VAR 0 7
105648: ARRAY
105649: PPUSH
105650: CALL_OW 121
// end else
105654: GO 105833
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
105656: LD_ADDR_VAR 0 13
105660: PUSH
105661: LD_VAR 0 4
105665: PPUSH
105666: LD_INT 95
105668: PUSH
105669: LD_VAR 0 22
105673: PUSH
105674: EMPTY
105675: LIST
105676: LIST
105677: PUSH
105678: LD_INT 58
105680: PUSH
105681: EMPTY
105682: LIST
105683: PUSH
105684: EMPTY
105685: LIST
105686: LIST
105687: PPUSH
105688: CALL_OW 72
105692: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
105693: LD_VAR 0 4
105697: PUSH
105698: LD_VAR 0 7
105702: ARRAY
105703: PPUSH
105704: CALL_OW 314
105708: NOT
105709: IFFALSE 105831
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
105711: LD_ADDR_VAR 0 10
105715: PUSH
105716: LD_VAR 0 13
105720: PPUSH
105721: LD_VAR 0 4
105725: PUSH
105726: LD_VAR 0 7
105730: ARRAY
105731: PPUSH
105732: CALL_OW 74
105736: ST_TO_ADDR
// if not x then
105737: LD_VAR 0 10
105741: NOT
105742: IFFALSE 105746
// continue ;
105744: GO 105178
// if GetLives ( x ) < 1000 then
105746: LD_VAR 0 10
105750: PPUSH
105751: CALL_OW 256
105755: PUSH
105756: LD_INT 1000
105758: LESS
105759: IFFALSE 105783
// ComRepairVehicle ( group [ i ] , x ) else
105761: LD_VAR 0 4
105765: PUSH
105766: LD_VAR 0 7
105770: ARRAY
105771: PPUSH
105772: LD_VAR 0 10
105776: PPUSH
105777: CALL_OW 129
105781: GO 105831
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
105783: LD_VAR 0 23
105787: PUSH
105788: LD_VAR 0 4
105792: PUSH
105793: LD_VAR 0 7
105797: ARRAY
105798: PPUSH
105799: CALL_OW 256
105803: PUSH
105804: LD_INT 1000
105806: LESS
105807: AND
105808: NOT
105809: IFFALSE 105831
// ComEnterUnit ( group [ i ] , x ) ;
105811: LD_VAR 0 4
105815: PUSH
105816: LD_VAR 0 7
105820: ARRAY
105821: PPUSH
105822: LD_VAR 0 10
105826: PPUSH
105827: CALL_OW 120
// end ; continue ;
105831: GO 105178
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
105833: LD_VAR 0 23
105837: PUSH
105838: LD_VAR 0 4
105842: PUSH
105843: LD_VAR 0 7
105847: ARRAY
105848: PPUSH
105849: CALL_OW 247
105853: PUSH
105854: LD_INT 1
105856: EQUAL
105857: AND
105858: IFFALSE 106336
// begin if group [ i ] in healers then
105860: LD_VAR 0 4
105864: PUSH
105865: LD_VAR 0 7
105869: ARRAY
105870: PUSH
105871: LD_VAR 0 31
105875: IN
105876: IFFALSE 106149
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
105878: LD_VAR 0 4
105882: PUSH
105883: LD_VAR 0 7
105887: ARRAY
105888: PPUSH
105889: LD_VAR 0 23
105893: PPUSH
105894: CALL_OW 308
105898: NOT
105899: PUSH
105900: LD_VAR 0 4
105904: PUSH
105905: LD_VAR 0 7
105909: ARRAY
105910: PPUSH
105911: CALL_OW 314
105915: NOT
105916: AND
105917: IFFALSE 105941
// ComMoveToArea ( group [ i ] , f_heal ) else
105919: LD_VAR 0 4
105923: PUSH
105924: LD_VAR 0 7
105928: ARRAY
105929: PPUSH
105930: LD_VAR 0 23
105934: PPUSH
105935: CALL_OW 113
105939: GO 106147
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
105941: LD_VAR 0 4
105945: PUSH
105946: LD_VAR 0 7
105950: ARRAY
105951: PPUSH
105952: CALL 48904 0 1
105956: PPUSH
105957: CALL_OW 256
105961: PUSH
105962: LD_INT 1000
105964: EQUAL
105965: IFFALSE 105984
// ComStop ( group [ i ] ) else
105967: LD_VAR 0 4
105971: PUSH
105972: LD_VAR 0 7
105976: ARRAY
105977: PPUSH
105978: CALL_OW 141
105982: GO 106147
// if not HasTask ( group [ i ] ) and to_heal then
105984: LD_VAR 0 4
105988: PUSH
105989: LD_VAR 0 7
105993: ARRAY
105994: PPUSH
105995: CALL_OW 314
105999: NOT
106000: PUSH
106001: LD_VAR 0 30
106005: AND
106006: IFFALSE 106147
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
106008: LD_ADDR_VAR 0 13
106012: PUSH
106013: LD_VAR 0 30
106017: PPUSH
106018: LD_INT 3
106020: PUSH
106021: LD_INT 54
106023: PUSH
106024: EMPTY
106025: LIST
106026: PUSH
106027: EMPTY
106028: LIST
106029: LIST
106030: PPUSH
106031: CALL_OW 72
106035: PPUSH
106036: LD_VAR 0 4
106040: PUSH
106041: LD_VAR 0 7
106045: ARRAY
106046: PPUSH
106047: CALL_OW 74
106051: ST_TO_ADDR
// if z then
106052: LD_VAR 0 13
106056: IFFALSE 106147
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
106058: LD_INT 91
106060: PUSH
106061: LD_VAR 0 13
106065: PUSH
106066: LD_INT 10
106068: PUSH
106069: EMPTY
106070: LIST
106071: LIST
106072: LIST
106073: PUSH
106074: LD_INT 81
106076: PUSH
106077: LD_VAR 0 13
106081: PPUSH
106082: CALL_OW 255
106086: PUSH
106087: EMPTY
106088: LIST
106089: LIST
106090: PUSH
106091: EMPTY
106092: LIST
106093: LIST
106094: PPUSH
106095: CALL_OW 69
106099: PUSH
106100: LD_INT 0
106102: EQUAL
106103: IFFALSE 106127
// ComHeal ( group [ i ] , z ) else
106105: LD_VAR 0 4
106109: PUSH
106110: LD_VAR 0 7
106114: ARRAY
106115: PPUSH
106116: LD_VAR 0 13
106120: PPUSH
106121: CALL_OW 128
106125: GO 106147
// ComMoveToArea ( group [ i ] , f_heal ) ;
106127: LD_VAR 0 4
106131: PUSH
106132: LD_VAR 0 7
106136: ARRAY
106137: PPUSH
106138: LD_VAR 0 23
106142: PPUSH
106143: CALL_OW 113
// end ; continue ;
106147: GO 105178
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
106149: LD_VAR 0 4
106153: PUSH
106154: LD_VAR 0 7
106158: ARRAY
106159: PPUSH
106160: CALL_OW 256
106164: PUSH
106165: LD_INT 700
106167: LESS
106168: PUSH
106169: LD_VAR 0 4
106173: PUSH
106174: LD_VAR 0 7
106178: ARRAY
106179: PUSH
106180: LD_VAR 0 30
106184: IN
106185: NOT
106186: AND
106187: IFFALSE 106211
// to_heal := to_heal union group [ i ] ;
106189: LD_ADDR_VAR 0 30
106193: PUSH
106194: LD_VAR 0 30
106198: PUSH
106199: LD_VAR 0 4
106203: PUSH
106204: LD_VAR 0 7
106208: ARRAY
106209: UNION
106210: ST_TO_ADDR
// if group [ i ] in to_heal then
106211: LD_VAR 0 4
106215: PUSH
106216: LD_VAR 0 7
106220: ARRAY
106221: PUSH
106222: LD_VAR 0 30
106226: IN
106227: IFFALSE 106336
// begin if GetLives ( group [ i ] ) = 1000 then
106229: LD_VAR 0 4
106233: PUSH
106234: LD_VAR 0 7
106238: ARRAY
106239: PPUSH
106240: CALL_OW 256
106244: PUSH
106245: LD_INT 1000
106247: EQUAL
106248: IFFALSE 106274
// to_heal := to_heal diff group [ i ] else
106250: LD_ADDR_VAR 0 30
106254: PUSH
106255: LD_VAR 0 30
106259: PUSH
106260: LD_VAR 0 4
106264: PUSH
106265: LD_VAR 0 7
106269: ARRAY
106270: DIFF
106271: ST_TO_ADDR
106272: GO 106336
// begin if not IsInArea ( group [ i ] , to_heal ) then
106274: LD_VAR 0 4
106278: PUSH
106279: LD_VAR 0 7
106283: ARRAY
106284: PPUSH
106285: LD_VAR 0 30
106289: PPUSH
106290: CALL_OW 308
106294: NOT
106295: IFFALSE 106319
// ComMoveToArea ( group [ i ] , f_heal ) else
106297: LD_VAR 0 4
106301: PUSH
106302: LD_VAR 0 7
106306: ARRAY
106307: PPUSH
106308: LD_VAR 0 23
106312: PPUSH
106313: CALL_OW 113
106317: GO 106334
// ComHold ( group [ i ] ) ;
106319: LD_VAR 0 4
106323: PUSH
106324: LD_VAR 0 7
106328: ARRAY
106329: PPUSH
106330: CALL_OW 140
// continue ;
106334: GO 105178
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
106336: LD_VAR 0 4
106340: PUSH
106341: LD_VAR 0 7
106345: ARRAY
106346: PPUSH
106347: LD_INT 10
106349: PPUSH
106350: CALL 47324 0 2
106354: NOT
106355: PUSH
106356: LD_VAR 0 16
106360: PUSH
106361: LD_VAR 0 7
106365: ARRAY
106366: PUSH
106367: EMPTY
106368: EQUAL
106369: NOT
106370: AND
106371: IFFALSE 106637
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
106373: LD_VAR 0 4
106377: PUSH
106378: LD_VAR 0 7
106382: ARRAY
106383: PPUSH
106384: CALL_OW 262
106388: PUSH
106389: LD_INT 1
106391: PUSH
106392: LD_INT 2
106394: PUSH
106395: EMPTY
106396: LIST
106397: LIST
106398: IN
106399: IFFALSE 106440
// if GetFuel ( group [ i ] ) < 10 then
106401: LD_VAR 0 4
106405: PUSH
106406: LD_VAR 0 7
106410: ARRAY
106411: PPUSH
106412: CALL_OW 261
106416: PUSH
106417: LD_INT 10
106419: LESS
106420: IFFALSE 106440
// SetFuel ( group [ i ] , 12 ) ;
106422: LD_VAR 0 4
106426: PUSH
106427: LD_VAR 0 7
106431: ARRAY
106432: PPUSH
106433: LD_INT 12
106435: PPUSH
106436: CALL_OW 240
// if units_path [ i ] then
106440: LD_VAR 0 16
106444: PUSH
106445: LD_VAR 0 7
106449: ARRAY
106450: IFFALSE 106635
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
106452: LD_VAR 0 4
106456: PUSH
106457: LD_VAR 0 7
106461: ARRAY
106462: PPUSH
106463: LD_VAR 0 16
106467: PUSH
106468: LD_VAR 0 7
106472: ARRAY
106473: PUSH
106474: LD_INT 1
106476: ARRAY
106477: PUSH
106478: LD_INT 1
106480: ARRAY
106481: PPUSH
106482: LD_VAR 0 16
106486: PUSH
106487: LD_VAR 0 7
106491: ARRAY
106492: PUSH
106493: LD_INT 1
106495: ARRAY
106496: PUSH
106497: LD_INT 2
106499: ARRAY
106500: PPUSH
106501: CALL_OW 297
106505: PUSH
106506: LD_INT 6
106508: GREATER
106509: IFFALSE 106584
// begin if not HasTask ( group [ i ] ) then
106511: LD_VAR 0 4
106515: PUSH
106516: LD_VAR 0 7
106520: ARRAY
106521: PPUSH
106522: CALL_OW 314
106526: NOT
106527: IFFALSE 106582
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
106529: LD_VAR 0 4
106533: PUSH
106534: LD_VAR 0 7
106538: ARRAY
106539: PPUSH
106540: LD_VAR 0 16
106544: PUSH
106545: LD_VAR 0 7
106549: ARRAY
106550: PUSH
106551: LD_INT 1
106553: ARRAY
106554: PUSH
106555: LD_INT 1
106557: ARRAY
106558: PPUSH
106559: LD_VAR 0 16
106563: PUSH
106564: LD_VAR 0 7
106568: ARRAY
106569: PUSH
106570: LD_INT 1
106572: ARRAY
106573: PUSH
106574: LD_INT 2
106576: ARRAY
106577: PPUSH
106578: CALL_OW 114
// end else
106582: GO 106635
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
106584: LD_ADDR_VAR 0 15
106588: PUSH
106589: LD_VAR 0 16
106593: PUSH
106594: LD_VAR 0 7
106598: ARRAY
106599: PPUSH
106600: LD_INT 1
106602: PPUSH
106603: CALL_OW 3
106607: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
106608: LD_ADDR_VAR 0 16
106612: PUSH
106613: LD_VAR 0 16
106617: PPUSH
106618: LD_VAR 0 7
106622: PPUSH
106623: LD_VAR 0 15
106627: PPUSH
106628: CALL_OW 1
106632: ST_TO_ADDR
// continue ;
106633: GO 105178
// end ; end ; end else
106635: GO 109299
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
106637: LD_ADDR_VAR 0 14
106641: PUSH
106642: LD_INT 81
106644: PUSH
106645: LD_VAR 0 4
106649: PUSH
106650: LD_VAR 0 7
106654: ARRAY
106655: PPUSH
106656: CALL_OW 255
106660: PUSH
106661: EMPTY
106662: LIST
106663: LIST
106664: PPUSH
106665: CALL_OW 69
106669: ST_TO_ADDR
// if not tmp then
106670: LD_VAR 0 14
106674: NOT
106675: IFFALSE 106679
// continue ;
106677: GO 105178
// if f_ignore_area then
106679: LD_VAR 0 17
106683: IFFALSE 106771
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
106685: LD_ADDR_VAR 0 15
106689: PUSH
106690: LD_VAR 0 14
106694: PPUSH
106695: LD_INT 3
106697: PUSH
106698: LD_INT 92
106700: PUSH
106701: LD_VAR 0 17
106705: PUSH
106706: LD_INT 1
106708: ARRAY
106709: PUSH
106710: LD_VAR 0 17
106714: PUSH
106715: LD_INT 2
106717: ARRAY
106718: PUSH
106719: LD_VAR 0 17
106723: PUSH
106724: LD_INT 3
106726: ARRAY
106727: PUSH
106728: EMPTY
106729: LIST
106730: LIST
106731: LIST
106732: LIST
106733: PUSH
106734: EMPTY
106735: LIST
106736: LIST
106737: PPUSH
106738: CALL_OW 72
106742: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
106743: LD_VAR 0 14
106747: PUSH
106748: LD_VAR 0 15
106752: DIFF
106753: IFFALSE 106771
// tmp := tmp diff tmp2 ;
106755: LD_ADDR_VAR 0 14
106759: PUSH
106760: LD_VAR 0 14
106764: PUSH
106765: LD_VAR 0 15
106769: DIFF
106770: ST_TO_ADDR
// end ; if not f_murder then
106771: LD_VAR 0 20
106775: NOT
106776: IFFALSE 106834
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
106778: LD_ADDR_VAR 0 15
106782: PUSH
106783: LD_VAR 0 14
106787: PPUSH
106788: LD_INT 3
106790: PUSH
106791: LD_INT 50
106793: PUSH
106794: EMPTY
106795: LIST
106796: PUSH
106797: EMPTY
106798: LIST
106799: LIST
106800: PPUSH
106801: CALL_OW 72
106805: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
106806: LD_VAR 0 14
106810: PUSH
106811: LD_VAR 0 15
106815: DIFF
106816: IFFALSE 106834
// tmp := tmp diff tmp2 ;
106818: LD_ADDR_VAR 0 14
106822: PUSH
106823: LD_VAR 0 14
106827: PUSH
106828: LD_VAR 0 15
106832: DIFF
106833: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
106834: LD_ADDR_VAR 0 14
106838: PUSH
106839: LD_VAR 0 4
106843: PUSH
106844: LD_VAR 0 7
106848: ARRAY
106849: PPUSH
106850: LD_VAR 0 14
106854: PPUSH
106855: LD_INT 1
106857: PPUSH
106858: LD_INT 1
106860: PPUSH
106861: CALL 20259 0 4
106865: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
106866: LD_VAR 0 4
106870: PUSH
106871: LD_VAR 0 7
106875: ARRAY
106876: PPUSH
106877: CALL_OW 257
106881: PUSH
106882: LD_INT 1
106884: EQUAL
106885: IFFALSE 107333
// begin if WantPlant ( group [ i ] ) then
106887: LD_VAR 0 4
106891: PUSH
106892: LD_VAR 0 7
106896: ARRAY
106897: PPUSH
106898: CALL 19760 0 1
106902: IFFALSE 106906
// continue ;
106904: GO 105178
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
106906: LD_VAR 0 18
106910: PUSH
106911: LD_VAR 0 4
106915: PUSH
106916: LD_VAR 0 7
106920: ARRAY
106921: PPUSH
106922: CALL_OW 310
106926: NOT
106927: AND
106928: PUSH
106929: LD_VAR 0 14
106933: PUSH
106934: LD_INT 1
106936: ARRAY
106937: PUSH
106938: LD_VAR 0 14
106942: PPUSH
106943: LD_INT 21
106945: PUSH
106946: LD_INT 2
106948: PUSH
106949: EMPTY
106950: LIST
106951: LIST
106952: PUSH
106953: LD_INT 58
106955: PUSH
106956: EMPTY
106957: LIST
106958: PUSH
106959: EMPTY
106960: LIST
106961: LIST
106962: PPUSH
106963: CALL_OW 72
106967: IN
106968: AND
106969: IFFALSE 107005
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
106971: LD_VAR 0 4
106975: PUSH
106976: LD_VAR 0 7
106980: ARRAY
106981: PPUSH
106982: LD_VAR 0 14
106986: PUSH
106987: LD_INT 1
106989: ARRAY
106990: PPUSH
106991: CALL_OW 120
// attacking := true ;
106995: LD_ADDR_VAR 0 29
106999: PUSH
107000: LD_INT 1
107002: ST_TO_ADDR
// continue ;
107003: GO 105178
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
107005: LD_VAR 0 26
107009: PUSH
107010: LD_VAR 0 4
107014: PUSH
107015: LD_VAR 0 7
107019: ARRAY
107020: PPUSH
107021: CALL_OW 257
107025: PUSH
107026: LD_INT 1
107028: EQUAL
107029: AND
107030: PUSH
107031: LD_VAR 0 4
107035: PUSH
107036: LD_VAR 0 7
107040: ARRAY
107041: PPUSH
107042: CALL_OW 256
107046: PUSH
107047: LD_INT 800
107049: LESS
107050: AND
107051: PUSH
107052: LD_VAR 0 4
107056: PUSH
107057: LD_VAR 0 7
107061: ARRAY
107062: PPUSH
107063: CALL_OW 318
107067: NOT
107068: AND
107069: IFFALSE 107086
// ComCrawl ( group [ i ] ) ;
107071: LD_VAR 0 4
107075: PUSH
107076: LD_VAR 0 7
107080: ARRAY
107081: PPUSH
107082: CALL_OW 137
// if f_mines then
107086: LD_VAR 0 21
107090: IFFALSE 107333
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
107092: LD_VAR 0 14
107096: PUSH
107097: LD_INT 1
107099: ARRAY
107100: PPUSH
107101: CALL_OW 247
107105: PUSH
107106: LD_INT 3
107108: EQUAL
107109: PUSH
107110: LD_VAR 0 14
107114: PUSH
107115: LD_INT 1
107117: ARRAY
107118: PUSH
107119: LD_VAR 0 27
107123: IN
107124: NOT
107125: AND
107126: IFFALSE 107333
// begin x := GetX ( tmp [ 1 ] ) ;
107128: LD_ADDR_VAR 0 10
107132: PUSH
107133: LD_VAR 0 14
107137: PUSH
107138: LD_INT 1
107140: ARRAY
107141: PPUSH
107142: CALL_OW 250
107146: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
107147: LD_ADDR_VAR 0 11
107151: PUSH
107152: LD_VAR 0 14
107156: PUSH
107157: LD_INT 1
107159: ARRAY
107160: PPUSH
107161: CALL_OW 251
107165: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
107166: LD_ADDR_VAR 0 12
107170: PUSH
107171: LD_VAR 0 4
107175: PUSH
107176: LD_VAR 0 7
107180: ARRAY
107181: PPUSH
107182: CALL 47409 0 1
107186: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
107187: LD_VAR 0 4
107191: PUSH
107192: LD_VAR 0 7
107196: ARRAY
107197: PPUSH
107198: LD_VAR 0 10
107202: PPUSH
107203: LD_VAR 0 11
107207: PPUSH
107208: LD_VAR 0 14
107212: PUSH
107213: LD_INT 1
107215: ARRAY
107216: PPUSH
107217: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
107221: LD_VAR 0 4
107225: PUSH
107226: LD_VAR 0 7
107230: ARRAY
107231: PPUSH
107232: LD_VAR 0 10
107236: PPUSH
107237: LD_VAR 0 12
107241: PPUSH
107242: LD_INT 7
107244: PPUSH
107245: CALL_OW 272
107249: PPUSH
107250: LD_VAR 0 11
107254: PPUSH
107255: LD_VAR 0 12
107259: PPUSH
107260: LD_INT 7
107262: PPUSH
107263: CALL_OW 273
107267: PPUSH
107268: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
107272: LD_VAR 0 4
107276: PUSH
107277: LD_VAR 0 7
107281: ARRAY
107282: PPUSH
107283: LD_INT 71
107285: PPUSH
107286: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
107290: LD_ADDR_VAR 0 27
107294: PUSH
107295: LD_VAR 0 27
107299: PPUSH
107300: LD_VAR 0 27
107304: PUSH
107305: LD_INT 1
107307: PLUS
107308: PPUSH
107309: LD_VAR 0 14
107313: PUSH
107314: LD_INT 1
107316: ARRAY
107317: PPUSH
107318: CALL_OW 1
107322: ST_TO_ADDR
// attacking := true ;
107323: LD_ADDR_VAR 0 29
107327: PUSH
107328: LD_INT 1
107330: ST_TO_ADDR
// continue ;
107331: GO 105178
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
107333: LD_VAR 0 4
107337: PUSH
107338: LD_VAR 0 7
107342: ARRAY
107343: PPUSH
107344: CALL_OW 257
107348: PUSH
107349: LD_INT 17
107351: EQUAL
107352: PUSH
107353: LD_VAR 0 4
107357: PUSH
107358: LD_VAR 0 7
107362: ARRAY
107363: PPUSH
107364: CALL_OW 110
107368: PUSH
107369: LD_INT 71
107371: EQUAL
107372: NOT
107373: AND
107374: IFFALSE 107520
// begin attacking := false ;
107376: LD_ADDR_VAR 0 29
107380: PUSH
107381: LD_INT 0
107383: ST_TO_ADDR
// k := 5 ;
107384: LD_ADDR_VAR 0 9
107388: PUSH
107389: LD_INT 5
107391: ST_TO_ADDR
// if tmp < k then
107392: LD_VAR 0 14
107396: PUSH
107397: LD_VAR 0 9
107401: LESS
107402: IFFALSE 107414
// k := tmp ;
107404: LD_ADDR_VAR 0 9
107408: PUSH
107409: LD_VAR 0 14
107413: ST_TO_ADDR
// for j = 1 to k do
107414: LD_ADDR_VAR 0 8
107418: PUSH
107419: DOUBLE
107420: LD_INT 1
107422: DEC
107423: ST_TO_ADDR
107424: LD_VAR 0 9
107428: PUSH
107429: FOR_TO
107430: IFFALSE 107518
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
107432: LD_VAR 0 14
107436: PUSH
107437: LD_VAR 0 8
107441: ARRAY
107442: PUSH
107443: LD_VAR 0 14
107447: PPUSH
107448: LD_INT 58
107450: PUSH
107451: EMPTY
107452: LIST
107453: PPUSH
107454: CALL_OW 72
107458: IN
107459: NOT
107460: IFFALSE 107516
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107462: LD_VAR 0 4
107466: PUSH
107467: LD_VAR 0 7
107471: ARRAY
107472: PPUSH
107473: LD_VAR 0 14
107477: PUSH
107478: LD_VAR 0 8
107482: ARRAY
107483: PPUSH
107484: CALL_OW 115
// attacking := true ;
107488: LD_ADDR_VAR 0 29
107492: PUSH
107493: LD_INT 1
107495: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
107496: LD_VAR 0 4
107500: PUSH
107501: LD_VAR 0 7
107505: ARRAY
107506: PPUSH
107507: LD_INT 71
107509: PPUSH
107510: CALL_OW 109
// continue ;
107514: GO 107429
// end ; end ;
107516: GO 107429
107518: POP
107519: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
107520: LD_VAR 0 4
107524: PUSH
107525: LD_VAR 0 7
107529: ARRAY
107530: PPUSH
107531: CALL_OW 257
107535: PUSH
107536: LD_INT 8
107538: EQUAL
107539: PUSH
107540: LD_VAR 0 4
107544: PUSH
107545: LD_VAR 0 7
107549: ARRAY
107550: PPUSH
107551: CALL_OW 264
107555: PUSH
107556: LD_INT 28
107558: PUSH
107559: LD_INT 45
107561: PUSH
107562: LD_INT 7
107564: PUSH
107565: LD_INT 47
107567: PUSH
107568: EMPTY
107569: LIST
107570: LIST
107571: LIST
107572: LIST
107573: IN
107574: OR
107575: IFFALSE 107831
// begin attacking := false ;
107577: LD_ADDR_VAR 0 29
107581: PUSH
107582: LD_INT 0
107584: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
107585: LD_VAR 0 14
107589: PUSH
107590: LD_INT 1
107592: ARRAY
107593: PPUSH
107594: CALL_OW 266
107598: PUSH
107599: LD_INT 32
107601: PUSH
107602: LD_INT 31
107604: PUSH
107605: LD_INT 33
107607: PUSH
107608: LD_INT 4
107610: PUSH
107611: LD_INT 5
107613: PUSH
107614: EMPTY
107615: LIST
107616: LIST
107617: LIST
107618: LIST
107619: LIST
107620: IN
107621: IFFALSE 107807
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
107623: LD_ADDR_VAR 0 9
107627: PUSH
107628: LD_VAR 0 14
107632: PUSH
107633: LD_INT 1
107635: ARRAY
107636: PPUSH
107637: CALL_OW 266
107641: PPUSH
107642: LD_VAR 0 14
107646: PUSH
107647: LD_INT 1
107649: ARRAY
107650: PPUSH
107651: CALL_OW 250
107655: PPUSH
107656: LD_VAR 0 14
107660: PUSH
107661: LD_INT 1
107663: ARRAY
107664: PPUSH
107665: CALL_OW 251
107669: PPUSH
107670: LD_VAR 0 14
107674: PUSH
107675: LD_INT 1
107677: ARRAY
107678: PPUSH
107679: CALL_OW 254
107683: PPUSH
107684: LD_VAR 0 14
107688: PUSH
107689: LD_INT 1
107691: ARRAY
107692: PPUSH
107693: CALL_OW 248
107697: PPUSH
107698: LD_INT 0
107700: PPUSH
107701: CALL 28779 0 6
107705: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
107706: LD_ADDR_VAR 0 8
107710: PUSH
107711: LD_VAR 0 4
107715: PUSH
107716: LD_VAR 0 7
107720: ARRAY
107721: PPUSH
107722: LD_VAR 0 9
107726: PPUSH
107727: CALL 47449 0 2
107731: ST_TO_ADDR
// if j then
107732: LD_VAR 0 8
107736: IFFALSE 107805
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
107738: LD_VAR 0 8
107742: PUSH
107743: LD_INT 1
107745: ARRAY
107746: PPUSH
107747: LD_VAR 0 8
107751: PUSH
107752: LD_INT 2
107754: ARRAY
107755: PPUSH
107756: CALL_OW 488
107760: IFFALSE 107805
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
107762: LD_VAR 0 4
107766: PUSH
107767: LD_VAR 0 7
107771: ARRAY
107772: PPUSH
107773: LD_VAR 0 8
107777: PUSH
107778: LD_INT 1
107780: ARRAY
107781: PPUSH
107782: LD_VAR 0 8
107786: PUSH
107787: LD_INT 2
107789: ARRAY
107790: PPUSH
107791: CALL_OW 116
// attacking := true ;
107795: LD_ADDR_VAR 0 29
107799: PUSH
107800: LD_INT 1
107802: ST_TO_ADDR
// continue ;
107803: GO 105178
// end ; end else
107805: GO 107831
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
107807: LD_VAR 0 4
107811: PUSH
107812: LD_VAR 0 7
107816: ARRAY
107817: PPUSH
107818: LD_VAR 0 14
107822: PUSH
107823: LD_INT 1
107825: ARRAY
107826: PPUSH
107827: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
107831: LD_VAR 0 4
107835: PUSH
107836: LD_VAR 0 7
107840: ARRAY
107841: PPUSH
107842: CALL_OW 265
107846: PUSH
107847: LD_INT 11
107849: EQUAL
107850: IFFALSE 108128
// begin k := 10 ;
107852: LD_ADDR_VAR 0 9
107856: PUSH
107857: LD_INT 10
107859: ST_TO_ADDR
// x := 0 ;
107860: LD_ADDR_VAR 0 10
107864: PUSH
107865: LD_INT 0
107867: ST_TO_ADDR
// if tmp < k then
107868: LD_VAR 0 14
107872: PUSH
107873: LD_VAR 0 9
107877: LESS
107878: IFFALSE 107890
// k := tmp ;
107880: LD_ADDR_VAR 0 9
107884: PUSH
107885: LD_VAR 0 14
107889: ST_TO_ADDR
// for j = k downto 1 do
107890: LD_ADDR_VAR 0 8
107894: PUSH
107895: DOUBLE
107896: LD_VAR 0 9
107900: INC
107901: ST_TO_ADDR
107902: LD_INT 1
107904: PUSH
107905: FOR_DOWNTO
107906: IFFALSE 107981
// begin if GetType ( tmp [ j ] ) = unit_human then
107908: LD_VAR 0 14
107912: PUSH
107913: LD_VAR 0 8
107917: ARRAY
107918: PPUSH
107919: CALL_OW 247
107923: PUSH
107924: LD_INT 1
107926: EQUAL
107927: IFFALSE 107979
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
107929: LD_VAR 0 4
107933: PUSH
107934: LD_VAR 0 7
107938: ARRAY
107939: PPUSH
107940: LD_VAR 0 14
107944: PUSH
107945: LD_VAR 0 8
107949: ARRAY
107950: PPUSH
107951: CALL 47720 0 2
// x := tmp [ j ] ;
107955: LD_ADDR_VAR 0 10
107959: PUSH
107960: LD_VAR 0 14
107964: PUSH
107965: LD_VAR 0 8
107969: ARRAY
107970: ST_TO_ADDR
// attacking := true ;
107971: LD_ADDR_VAR 0 29
107975: PUSH
107976: LD_INT 1
107978: ST_TO_ADDR
// end ; end ;
107979: GO 107905
107981: POP
107982: POP
// if not x then
107983: LD_VAR 0 10
107987: NOT
107988: IFFALSE 108128
// begin attacking := true ;
107990: LD_ADDR_VAR 0 29
107994: PUSH
107995: LD_INT 1
107997: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
107998: LD_VAR 0 4
108002: PUSH
108003: LD_VAR 0 7
108007: ARRAY
108008: PPUSH
108009: CALL_OW 250
108013: PPUSH
108014: LD_VAR 0 4
108018: PUSH
108019: LD_VAR 0 7
108023: ARRAY
108024: PPUSH
108025: CALL_OW 251
108029: PPUSH
108030: CALL_OW 546
108034: PUSH
108035: LD_INT 2
108037: ARRAY
108038: PUSH
108039: LD_VAR 0 14
108043: PUSH
108044: LD_INT 1
108046: ARRAY
108047: PPUSH
108048: CALL_OW 250
108052: PPUSH
108053: LD_VAR 0 14
108057: PUSH
108058: LD_INT 1
108060: ARRAY
108061: PPUSH
108062: CALL_OW 251
108066: PPUSH
108067: CALL_OW 546
108071: PUSH
108072: LD_INT 2
108074: ARRAY
108075: EQUAL
108076: IFFALSE 108104
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
108078: LD_VAR 0 4
108082: PUSH
108083: LD_VAR 0 7
108087: ARRAY
108088: PPUSH
108089: LD_VAR 0 14
108093: PUSH
108094: LD_INT 1
108096: ARRAY
108097: PPUSH
108098: CALL 47720 0 2
108102: GO 108128
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108104: LD_VAR 0 4
108108: PUSH
108109: LD_VAR 0 7
108113: ARRAY
108114: PPUSH
108115: LD_VAR 0 14
108119: PUSH
108120: LD_INT 1
108122: ARRAY
108123: PPUSH
108124: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
108128: LD_VAR 0 4
108132: PUSH
108133: LD_VAR 0 7
108137: ARRAY
108138: PPUSH
108139: CALL_OW 264
108143: PUSH
108144: LD_INT 29
108146: EQUAL
108147: IFFALSE 108513
// begin if WantsToAttack ( group [ i ] ) in bombed then
108149: LD_VAR 0 4
108153: PUSH
108154: LD_VAR 0 7
108158: ARRAY
108159: PPUSH
108160: CALL_OW 319
108164: PUSH
108165: LD_VAR 0 28
108169: IN
108170: IFFALSE 108174
// continue ;
108172: GO 105178
// k := 8 ;
108174: LD_ADDR_VAR 0 9
108178: PUSH
108179: LD_INT 8
108181: ST_TO_ADDR
// x := 0 ;
108182: LD_ADDR_VAR 0 10
108186: PUSH
108187: LD_INT 0
108189: ST_TO_ADDR
// if tmp < k then
108190: LD_VAR 0 14
108194: PUSH
108195: LD_VAR 0 9
108199: LESS
108200: IFFALSE 108212
// k := tmp ;
108202: LD_ADDR_VAR 0 9
108206: PUSH
108207: LD_VAR 0 14
108211: ST_TO_ADDR
// for j = 1 to k do
108212: LD_ADDR_VAR 0 8
108216: PUSH
108217: DOUBLE
108218: LD_INT 1
108220: DEC
108221: ST_TO_ADDR
108222: LD_VAR 0 9
108226: PUSH
108227: FOR_TO
108228: IFFALSE 108360
// begin if GetType ( tmp [ j ] ) = unit_building then
108230: LD_VAR 0 14
108234: PUSH
108235: LD_VAR 0 8
108239: ARRAY
108240: PPUSH
108241: CALL_OW 247
108245: PUSH
108246: LD_INT 3
108248: EQUAL
108249: IFFALSE 108358
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
108251: LD_VAR 0 14
108255: PUSH
108256: LD_VAR 0 8
108260: ARRAY
108261: PUSH
108262: LD_VAR 0 28
108266: IN
108267: NOT
108268: PUSH
108269: LD_VAR 0 14
108273: PUSH
108274: LD_VAR 0 8
108278: ARRAY
108279: PPUSH
108280: CALL_OW 313
108284: AND
108285: IFFALSE 108358
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108287: LD_VAR 0 4
108291: PUSH
108292: LD_VAR 0 7
108296: ARRAY
108297: PPUSH
108298: LD_VAR 0 14
108302: PUSH
108303: LD_VAR 0 8
108307: ARRAY
108308: PPUSH
108309: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
108313: LD_ADDR_VAR 0 28
108317: PUSH
108318: LD_VAR 0 28
108322: PPUSH
108323: LD_VAR 0 28
108327: PUSH
108328: LD_INT 1
108330: PLUS
108331: PPUSH
108332: LD_VAR 0 14
108336: PUSH
108337: LD_VAR 0 8
108341: ARRAY
108342: PPUSH
108343: CALL_OW 1
108347: ST_TO_ADDR
// attacking := true ;
108348: LD_ADDR_VAR 0 29
108352: PUSH
108353: LD_INT 1
108355: ST_TO_ADDR
// break ;
108356: GO 108360
// end ; end ;
108358: GO 108227
108360: POP
108361: POP
// if not attacking and f_attack_depot then
108362: LD_VAR 0 29
108366: NOT
108367: PUSH
108368: LD_VAR 0 25
108372: AND
108373: IFFALSE 108468
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108375: LD_ADDR_VAR 0 13
108379: PUSH
108380: LD_VAR 0 14
108384: PPUSH
108385: LD_INT 2
108387: PUSH
108388: LD_INT 30
108390: PUSH
108391: LD_INT 0
108393: PUSH
108394: EMPTY
108395: LIST
108396: LIST
108397: PUSH
108398: LD_INT 30
108400: PUSH
108401: LD_INT 1
108403: PUSH
108404: EMPTY
108405: LIST
108406: LIST
108407: PUSH
108408: EMPTY
108409: LIST
108410: LIST
108411: LIST
108412: PPUSH
108413: CALL_OW 72
108417: ST_TO_ADDR
// if z then
108418: LD_VAR 0 13
108422: IFFALSE 108468
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
108424: LD_VAR 0 4
108428: PUSH
108429: LD_VAR 0 7
108433: ARRAY
108434: PPUSH
108435: LD_VAR 0 13
108439: PPUSH
108440: LD_VAR 0 4
108444: PUSH
108445: LD_VAR 0 7
108449: ARRAY
108450: PPUSH
108451: CALL_OW 74
108455: PPUSH
108456: CALL_OW 115
// attacking := true ;
108460: LD_ADDR_VAR 0 29
108464: PUSH
108465: LD_INT 1
108467: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
108468: LD_VAR 0 4
108472: PUSH
108473: LD_VAR 0 7
108477: ARRAY
108478: PPUSH
108479: CALL_OW 256
108483: PUSH
108484: LD_INT 500
108486: LESS
108487: IFFALSE 108513
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108489: LD_VAR 0 4
108493: PUSH
108494: LD_VAR 0 7
108498: ARRAY
108499: PPUSH
108500: LD_VAR 0 14
108504: PUSH
108505: LD_INT 1
108507: ARRAY
108508: PPUSH
108509: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
108513: LD_VAR 0 4
108517: PUSH
108518: LD_VAR 0 7
108522: ARRAY
108523: PPUSH
108524: CALL_OW 264
108528: PUSH
108529: LD_INT 49
108531: EQUAL
108532: IFFALSE 108653
// begin if not HasTask ( group [ i ] ) then
108534: LD_VAR 0 4
108538: PUSH
108539: LD_VAR 0 7
108543: ARRAY
108544: PPUSH
108545: CALL_OW 314
108549: NOT
108550: IFFALSE 108653
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
108552: LD_ADDR_VAR 0 9
108556: PUSH
108557: LD_INT 81
108559: PUSH
108560: LD_VAR 0 4
108564: PUSH
108565: LD_VAR 0 7
108569: ARRAY
108570: PPUSH
108571: CALL_OW 255
108575: PUSH
108576: EMPTY
108577: LIST
108578: LIST
108579: PPUSH
108580: CALL_OW 69
108584: PPUSH
108585: LD_VAR 0 4
108589: PUSH
108590: LD_VAR 0 7
108594: ARRAY
108595: PPUSH
108596: CALL_OW 74
108600: ST_TO_ADDR
// if k then
108601: LD_VAR 0 9
108605: IFFALSE 108653
// if GetDistUnits ( group [ i ] , k ) > 10 then
108607: LD_VAR 0 4
108611: PUSH
108612: LD_VAR 0 7
108616: ARRAY
108617: PPUSH
108618: LD_VAR 0 9
108622: PPUSH
108623: CALL_OW 296
108627: PUSH
108628: LD_INT 10
108630: GREATER
108631: IFFALSE 108653
// ComMoveUnit ( group [ i ] , k ) ;
108633: LD_VAR 0 4
108637: PUSH
108638: LD_VAR 0 7
108642: ARRAY
108643: PPUSH
108644: LD_VAR 0 9
108648: PPUSH
108649: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
108653: LD_VAR 0 4
108657: PUSH
108658: LD_VAR 0 7
108662: ARRAY
108663: PPUSH
108664: CALL_OW 256
108668: PUSH
108669: LD_INT 250
108671: LESS
108672: PUSH
108673: LD_VAR 0 4
108677: PUSH
108678: LD_VAR 0 7
108682: ARRAY
108683: PUSH
108684: LD_INT 21
108686: PUSH
108687: LD_INT 2
108689: PUSH
108690: EMPTY
108691: LIST
108692: LIST
108693: PUSH
108694: LD_INT 23
108696: PUSH
108697: LD_INT 2
108699: PUSH
108700: EMPTY
108701: LIST
108702: LIST
108703: PUSH
108704: EMPTY
108705: LIST
108706: LIST
108707: PPUSH
108708: CALL_OW 69
108712: IN
108713: AND
108714: IFFALSE 108839
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
108716: LD_ADDR_VAR 0 9
108720: PUSH
108721: LD_OWVAR 3
108725: PUSH
108726: LD_VAR 0 4
108730: PUSH
108731: LD_VAR 0 7
108735: ARRAY
108736: DIFF
108737: PPUSH
108738: LD_VAR 0 4
108742: PUSH
108743: LD_VAR 0 7
108747: ARRAY
108748: PPUSH
108749: CALL_OW 74
108753: ST_TO_ADDR
// if not k then
108754: LD_VAR 0 9
108758: NOT
108759: IFFALSE 108763
// continue ;
108761: GO 105178
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
108763: LD_VAR 0 9
108767: PUSH
108768: LD_INT 81
108770: PUSH
108771: LD_VAR 0 4
108775: PUSH
108776: LD_VAR 0 7
108780: ARRAY
108781: PPUSH
108782: CALL_OW 255
108786: PUSH
108787: EMPTY
108788: LIST
108789: LIST
108790: PPUSH
108791: CALL_OW 69
108795: IN
108796: PUSH
108797: LD_VAR 0 9
108801: PPUSH
108802: LD_VAR 0 4
108806: PUSH
108807: LD_VAR 0 7
108811: ARRAY
108812: PPUSH
108813: CALL_OW 296
108817: PUSH
108818: LD_INT 5
108820: LESS
108821: AND
108822: IFFALSE 108839
// ComAutodestruct ( group [ i ] ) ;
108824: LD_VAR 0 4
108828: PUSH
108829: LD_VAR 0 7
108833: ARRAY
108834: PPUSH
108835: CALL 47618 0 1
// end ; if f_attack_depot then
108839: LD_VAR 0 25
108843: IFFALSE 108955
// begin k := 6 ;
108845: LD_ADDR_VAR 0 9
108849: PUSH
108850: LD_INT 6
108852: ST_TO_ADDR
// if tmp < k then
108853: LD_VAR 0 14
108857: PUSH
108858: LD_VAR 0 9
108862: LESS
108863: IFFALSE 108875
// k := tmp ;
108865: LD_ADDR_VAR 0 9
108869: PUSH
108870: LD_VAR 0 14
108874: ST_TO_ADDR
// for j = 1 to k do
108875: LD_ADDR_VAR 0 8
108879: PUSH
108880: DOUBLE
108881: LD_INT 1
108883: DEC
108884: ST_TO_ADDR
108885: LD_VAR 0 9
108889: PUSH
108890: FOR_TO
108891: IFFALSE 108953
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
108893: LD_VAR 0 8
108897: PPUSH
108898: CALL_OW 266
108902: PUSH
108903: LD_INT 0
108905: PUSH
108906: LD_INT 1
108908: PUSH
108909: EMPTY
108910: LIST
108911: LIST
108912: IN
108913: IFFALSE 108951
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108915: LD_VAR 0 4
108919: PUSH
108920: LD_VAR 0 7
108924: ARRAY
108925: PPUSH
108926: LD_VAR 0 14
108930: PUSH
108931: LD_VAR 0 8
108935: ARRAY
108936: PPUSH
108937: CALL_OW 115
// attacking := true ;
108941: LD_ADDR_VAR 0 29
108945: PUSH
108946: LD_INT 1
108948: ST_TO_ADDR
// break ;
108949: GO 108953
// end ;
108951: GO 108890
108953: POP
108954: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
108955: LD_VAR 0 4
108959: PUSH
108960: LD_VAR 0 7
108964: ARRAY
108965: PPUSH
108966: CALL_OW 302
108970: PUSH
108971: LD_VAR 0 29
108975: NOT
108976: AND
108977: IFFALSE 109299
// begin if GetTag ( group [ i ] ) = 71 then
108979: LD_VAR 0 4
108983: PUSH
108984: LD_VAR 0 7
108988: ARRAY
108989: PPUSH
108990: CALL_OW 110
108994: PUSH
108995: LD_INT 71
108997: EQUAL
108998: IFFALSE 109039
// begin if HasTask ( group [ i ] ) then
109000: LD_VAR 0 4
109004: PUSH
109005: LD_VAR 0 7
109009: ARRAY
109010: PPUSH
109011: CALL_OW 314
109015: IFFALSE 109021
// continue else
109017: GO 105178
109019: GO 109039
// SetTag ( group [ i ] , 0 ) ;
109021: LD_VAR 0 4
109025: PUSH
109026: LD_VAR 0 7
109030: ARRAY
109031: PPUSH
109032: LD_INT 0
109034: PPUSH
109035: CALL_OW 109
// end ; k := 8 ;
109039: LD_ADDR_VAR 0 9
109043: PUSH
109044: LD_INT 8
109046: ST_TO_ADDR
// x := 0 ;
109047: LD_ADDR_VAR 0 10
109051: PUSH
109052: LD_INT 0
109054: ST_TO_ADDR
// if tmp < k then
109055: LD_VAR 0 14
109059: PUSH
109060: LD_VAR 0 9
109064: LESS
109065: IFFALSE 109077
// k := tmp ;
109067: LD_ADDR_VAR 0 9
109071: PUSH
109072: LD_VAR 0 14
109076: ST_TO_ADDR
// for j = 1 to k do
109077: LD_ADDR_VAR 0 8
109081: PUSH
109082: DOUBLE
109083: LD_INT 1
109085: DEC
109086: ST_TO_ADDR
109087: LD_VAR 0 9
109091: PUSH
109092: FOR_TO
109093: IFFALSE 109191
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
109095: LD_VAR 0 14
109099: PUSH
109100: LD_VAR 0 8
109104: ARRAY
109105: PPUSH
109106: CALL_OW 247
109110: PUSH
109111: LD_INT 1
109113: EQUAL
109114: PUSH
109115: LD_VAR 0 14
109119: PUSH
109120: LD_VAR 0 8
109124: ARRAY
109125: PPUSH
109126: CALL_OW 256
109130: PUSH
109131: LD_INT 250
109133: LESS
109134: PUSH
109135: LD_VAR 0 20
109139: AND
109140: PUSH
109141: LD_VAR 0 20
109145: NOT
109146: PUSH
109147: LD_VAR 0 14
109151: PUSH
109152: LD_VAR 0 8
109156: ARRAY
109157: PPUSH
109158: CALL_OW 256
109162: PUSH
109163: LD_INT 250
109165: GREATEREQUAL
109166: AND
109167: OR
109168: AND
109169: IFFALSE 109189
// begin x := tmp [ j ] ;
109171: LD_ADDR_VAR 0 10
109175: PUSH
109176: LD_VAR 0 14
109180: PUSH
109181: LD_VAR 0 8
109185: ARRAY
109186: ST_TO_ADDR
// break ;
109187: GO 109191
// end ;
109189: GO 109092
109191: POP
109192: POP
// if x then
109193: LD_VAR 0 10
109197: IFFALSE 109221
// ComAttackUnit ( group [ i ] , x ) else
109199: LD_VAR 0 4
109203: PUSH
109204: LD_VAR 0 7
109208: ARRAY
109209: PPUSH
109210: LD_VAR 0 10
109214: PPUSH
109215: CALL_OW 115
109219: GO 109245
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109221: LD_VAR 0 4
109225: PUSH
109226: LD_VAR 0 7
109230: ARRAY
109231: PPUSH
109232: LD_VAR 0 14
109236: PUSH
109237: LD_INT 1
109239: ARRAY
109240: PPUSH
109241: CALL_OW 115
// if not HasTask ( group [ i ] ) then
109245: LD_VAR 0 4
109249: PUSH
109250: LD_VAR 0 7
109254: ARRAY
109255: PPUSH
109256: CALL_OW 314
109260: NOT
109261: IFFALSE 109299
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
109263: LD_VAR 0 4
109267: PUSH
109268: LD_VAR 0 7
109272: ARRAY
109273: PPUSH
109274: LD_VAR 0 14
109278: PPUSH
109279: LD_VAR 0 4
109283: PUSH
109284: LD_VAR 0 7
109288: ARRAY
109289: PPUSH
109290: CALL_OW 74
109294: PPUSH
109295: CALL_OW 115
// end ; end ; end ;
109299: GO 105178
109301: POP
109302: POP
// wait ( 0 0$2 ) ;
109303: LD_INT 70
109305: PPUSH
109306: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
109310: LD_VAR 0 4
109314: NOT
109315: PUSH
109316: LD_VAR 0 4
109320: PUSH
109321: EMPTY
109322: EQUAL
109323: OR
109324: PUSH
109325: LD_INT 81
109327: PUSH
109328: LD_VAR 0 35
109332: PUSH
109333: EMPTY
109334: LIST
109335: LIST
109336: PPUSH
109337: CALL_OW 69
109341: NOT
109342: OR
109343: IFFALSE 105163
// end ;
109345: LD_VAR 0 2
109349: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
109350: LD_INT 0
109352: PPUSH
109353: PPUSH
109354: PPUSH
109355: PPUSH
109356: PPUSH
109357: PPUSH
// if not base or not mc_bases [ base ] or not solds then
109358: LD_VAR 0 1
109362: NOT
109363: PUSH
109364: LD_EXP 60
109368: PUSH
109369: LD_VAR 0 1
109373: ARRAY
109374: NOT
109375: OR
109376: PUSH
109377: LD_VAR 0 2
109381: NOT
109382: OR
109383: IFFALSE 109387
// exit ;
109385: GO 109941
// side := mc_sides [ base ] ;
109387: LD_ADDR_VAR 0 6
109391: PUSH
109392: LD_EXP 86
109396: PUSH
109397: LD_VAR 0 1
109401: ARRAY
109402: ST_TO_ADDR
// if not side then
109403: LD_VAR 0 6
109407: NOT
109408: IFFALSE 109412
// exit ;
109410: GO 109941
// for i in solds do
109412: LD_ADDR_VAR 0 7
109416: PUSH
109417: LD_VAR 0 2
109421: PUSH
109422: FOR_IN
109423: IFFALSE 109484
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
109425: LD_VAR 0 7
109429: PPUSH
109430: CALL_OW 310
109434: PPUSH
109435: CALL_OW 266
109439: PUSH
109440: LD_INT 32
109442: PUSH
109443: LD_INT 31
109445: PUSH
109446: EMPTY
109447: LIST
109448: LIST
109449: IN
109450: IFFALSE 109470
// solds := solds diff i else
109452: LD_ADDR_VAR 0 2
109456: PUSH
109457: LD_VAR 0 2
109461: PUSH
109462: LD_VAR 0 7
109466: DIFF
109467: ST_TO_ADDR
109468: GO 109482
// SetTag ( i , 18 ) ;
109470: LD_VAR 0 7
109474: PPUSH
109475: LD_INT 18
109477: PPUSH
109478: CALL_OW 109
109482: GO 109422
109484: POP
109485: POP
// if not solds then
109486: LD_VAR 0 2
109490: NOT
109491: IFFALSE 109495
// exit ;
109493: GO 109941
// repeat wait ( 0 0$2 ) ;
109495: LD_INT 70
109497: PPUSH
109498: CALL_OW 67
// enemy := mc_scan [ base ] ;
109502: LD_ADDR_VAR 0 4
109506: PUSH
109507: LD_EXP 83
109511: PUSH
109512: LD_VAR 0 1
109516: ARRAY
109517: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109518: LD_EXP 60
109522: PUSH
109523: LD_VAR 0 1
109527: ARRAY
109528: NOT
109529: PUSH
109530: LD_EXP 60
109534: PUSH
109535: LD_VAR 0 1
109539: ARRAY
109540: PUSH
109541: EMPTY
109542: EQUAL
109543: OR
109544: IFFALSE 109581
// begin for i in solds do
109546: LD_ADDR_VAR 0 7
109550: PUSH
109551: LD_VAR 0 2
109555: PUSH
109556: FOR_IN
109557: IFFALSE 109570
// ComStop ( i ) ;
109559: LD_VAR 0 7
109563: PPUSH
109564: CALL_OW 141
109568: GO 109556
109570: POP
109571: POP
// solds := [ ] ;
109572: LD_ADDR_VAR 0 2
109576: PUSH
109577: EMPTY
109578: ST_TO_ADDR
// exit ;
109579: GO 109941
// end ; for i in solds do
109581: LD_ADDR_VAR 0 7
109585: PUSH
109586: LD_VAR 0 2
109590: PUSH
109591: FOR_IN
109592: IFFALSE 109913
// begin if IsInUnit ( i ) then
109594: LD_VAR 0 7
109598: PPUSH
109599: CALL_OW 310
109603: IFFALSE 109614
// ComExitBuilding ( i ) ;
109605: LD_VAR 0 7
109609: PPUSH
109610: CALL_OW 122
// if GetLives ( i ) > 500 then
109614: LD_VAR 0 7
109618: PPUSH
109619: CALL_OW 256
109623: PUSH
109624: LD_INT 500
109626: GREATER
109627: IFFALSE 109680
// begin e := NearestUnitToUnit ( enemy , i ) ;
109629: LD_ADDR_VAR 0 5
109633: PUSH
109634: LD_VAR 0 4
109638: PPUSH
109639: LD_VAR 0 7
109643: PPUSH
109644: CALL_OW 74
109648: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
109649: LD_VAR 0 7
109653: PPUSH
109654: LD_VAR 0 5
109658: PPUSH
109659: CALL_OW 250
109663: PPUSH
109664: LD_VAR 0 5
109668: PPUSH
109669: CALL_OW 251
109673: PPUSH
109674: CALL_OW 114
// end else
109678: GO 109911
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
109680: LD_VAR 0 7
109684: PPUSH
109685: LD_EXP 60
109689: PUSH
109690: LD_VAR 0 1
109694: ARRAY
109695: PPUSH
109696: LD_INT 2
109698: PUSH
109699: LD_INT 30
109701: PUSH
109702: LD_INT 0
109704: PUSH
109705: EMPTY
109706: LIST
109707: LIST
109708: PUSH
109709: LD_INT 30
109711: PUSH
109712: LD_INT 1
109714: PUSH
109715: EMPTY
109716: LIST
109717: LIST
109718: PUSH
109719: LD_INT 30
109721: PUSH
109722: LD_INT 6
109724: PUSH
109725: EMPTY
109726: LIST
109727: LIST
109728: PUSH
109729: EMPTY
109730: LIST
109731: LIST
109732: LIST
109733: LIST
109734: PPUSH
109735: CALL_OW 72
109739: PPUSH
109740: LD_VAR 0 7
109744: PPUSH
109745: CALL_OW 74
109749: PPUSH
109750: CALL_OW 296
109754: PUSH
109755: LD_INT 10
109757: GREATER
109758: IFFALSE 109911
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
109760: LD_ADDR_VAR 0 8
109764: PUSH
109765: LD_EXP 60
109769: PUSH
109770: LD_VAR 0 1
109774: ARRAY
109775: PPUSH
109776: LD_INT 2
109778: PUSH
109779: LD_INT 30
109781: PUSH
109782: LD_INT 0
109784: PUSH
109785: EMPTY
109786: LIST
109787: LIST
109788: PUSH
109789: LD_INT 30
109791: PUSH
109792: LD_INT 1
109794: PUSH
109795: EMPTY
109796: LIST
109797: LIST
109798: PUSH
109799: LD_INT 30
109801: PUSH
109802: LD_INT 6
109804: PUSH
109805: EMPTY
109806: LIST
109807: LIST
109808: PUSH
109809: EMPTY
109810: LIST
109811: LIST
109812: LIST
109813: LIST
109814: PPUSH
109815: CALL_OW 72
109819: PPUSH
109820: LD_VAR 0 7
109824: PPUSH
109825: CALL_OW 74
109829: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
109830: LD_VAR 0 7
109834: PPUSH
109835: LD_VAR 0 8
109839: PPUSH
109840: CALL_OW 250
109844: PPUSH
109845: LD_INT 3
109847: PPUSH
109848: LD_INT 5
109850: PPUSH
109851: CALL_OW 272
109855: PPUSH
109856: LD_VAR 0 8
109860: PPUSH
109861: CALL_OW 251
109865: PPUSH
109866: LD_INT 3
109868: PPUSH
109869: LD_INT 5
109871: PPUSH
109872: CALL_OW 273
109876: PPUSH
109877: CALL_OW 111
// SetTag ( i , 0 ) ;
109881: LD_VAR 0 7
109885: PPUSH
109886: LD_INT 0
109888: PPUSH
109889: CALL_OW 109
// solds := solds diff i ;
109893: LD_ADDR_VAR 0 2
109897: PUSH
109898: LD_VAR 0 2
109902: PUSH
109903: LD_VAR 0 7
109907: DIFF
109908: ST_TO_ADDR
// continue ;
109909: GO 109591
// end ; end ;
109911: GO 109591
109913: POP
109914: POP
// until not solds or not enemy ;
109915: LD_VAR 0 2
109919: NOT
109920: PUSH
109921: LD_VAR 0 4
109925: NOT
109926: OR
109927: IFFALSE 109495
// MC_Reset ( base , 18 ) ;
109929: LD_VAR 0 1
109933: PPUSH
109934: LD_INT 18
109936: PPUSH
109937: CALL 59027 0 2
// end ;
109941: LD_VAR 0 3
109945: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
109946: LD_INT 0
109948: PPUSH
109949: PPUSH
109950: PPUSH
109951: PPUSH
109952: PPUSH
109953: PPUSH
109954: PPUSH
109955: PPUSH
109956: PPUSH
109957: PPUSH
109958: PPUSH
109959: PPUSH
109960: PPUSH
109961: PPUSH
109962: PPUSH
109963: PPUSH
109964: PPUSH
109965: PPUSH
109966: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
109967: LD_ADDR_VAR 0 12
109971: PUSH
109972: LD_EXP 60
109976: PUSH
109977: LD_VAR 0 1
109981: ARRAY
109982: PPUSH
109983: LD_INT 25
109985: PUSH
109986: LD_INT 3
109988: PUSH
109989: EMPTY
109990: LIST
109991: LIST
109992: PPUSH
109993: CALL_OW 72
109997: ST_TO_ADDR
// if mc_remote_driver [ base ] then
109998: LD_EXP 100
110002: PUSH
110003: LD_VAR 0 1
110007: ARRAY
110008: IFFALSE 110032
// mechs := mechs diff mc_remote_driver [ base ] ;
110010: LD_ADDR_VAR 0 12
110014: PUSH
110015: LD_VAR 0 12
110019: PUSH
110020: LD_EXP 100
110024: PUSH
110025: LD_VAR 0 1
110029: ARRAY
110030: DIFF
110031: ST_TO_ADDR
// for i in mechs do
110032: LD_ADDR_VAR 0 4
110036: PUSH
110037: LD_VAR 0 12
110041: PUSH
110042: FOR_IN
110043: IFFALSE 110078
// if GetTag ( i ) > 0 then
110045: LD_VAR 0 4
110049: PPUSH
110050: CALL_OW 110
110054: PUSH
110055: LD_INT 0
110057: GREATER
110058: IFFALSE 110076
// mechs := mechs diff i ;
110060: LD_ADDR_VAR 0 12
110064: PUSH
110065: LD_VAR 0 12
110069: PUSH
110070: LD_VAR 0 4
110074: DIFF
110075: ST_TO_ADDR
110076: GO 110042
110078: POP
110079: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
110080: LD_ADDR_VAR 0 8
110084: PUSH
110085: LD_EXP 60
110089: PUSH
110090: LD_VAR 0 1
110094: ARRAY
110095: PPUSH
110096: LD_INT 2
110098: PUSH
110099: LD_INT 25
110101: PUSH
110102: LD_INT 1
110104: PUSH
110105: EMPTY
110106: LIST
110107: LIST
110108: PUSH
110109: LD_INT 25
110111: PUSH
110112: LD_INT 5
110114: PUSH
110115: EMPTY
110116: LIST
110117: LIST
110118: PUSH
110119: LD_INT 25
110121: PUSH
110122: LD_INT 8
110124: PUSH
110125: EMPTY
110126: LIST
110127: LIST
110128: PUSH
110129: LD_INT 25
110131: PUSH
110132: LD_INT 9
110134: PUSH
110135: EMPTY
110136: LIST
110137: LIST
110138: PUSH
110139: EMPTY
110140: LIST
110141: LIST
110142: LIST
110143: LIST
110144: LIST
110145: PPUSH
110146: CALL_OW 72
110150: ST_TO_ADDR
// if not defenders and not solds then
110151: LD_VAR 0 2
110155: NOT
110156: PUSH
110157: LD_VAR 0 8
110161: NOT
110162: AND
110163: IFFALSE 110167
// exit ;
110165: GO 111937
// depot_under_attack := false ;
110167: LD_ADDR_VAR 0 16
110171: PUSH
110172: LD_INT 0
110174: ST_TO_ADDR
// sold_defenders := [ ] ;
110175: LD_ADDR_VAR 0 17
110179: PUSH
110180: EMPTY
110181: ST_TO_ADDR
// if mechs then
110182: LD_VAR 0 12
110186: IFFALSE 110339
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
110188: LD_ADDR_VAR 0 4
110192: PUSH
110193: LD_VAR 0 2
110197: PPUSH
110198: LD_INT 21
110200: PUSH
110201: LD_INT 2
110203: PUSH
110204: EMPTY
110205: LIST
110206: LIST
110207: PPUSH
110208: CALL_OW 72
110212: PUSH
110213: FOR_IN
110214: IFFALSE 110337
// begin if GetTag ( i ) <> 20 then
110216: LD_VAR 0 4
110220: PPUSH
110221: CALL_OW 110
110225: PUSH
110226: LD_INT 20
110228: NONEQUAL
110229: IFFALSE 110243
// SetTag ( i , 20 ) ;
110231: LD_VAR 0 4
110235: PPUSH
110236: LD_INT 20
110238: PPUSH
110239: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
110243: LD_VAR 0 4
110247: PPUSH
110248: CALL_OW 263
110252: PUSH
110253: LD_INT 1
110255: EQUAL
110256: PUSH
110257: LD_VAR 0 4
110261: PPUSH
110262: CALL_OW 311
110266: NOT
110267: AND
110268: IFFALSE 110335
// begin un := mechs [ 1 ] ;
110270: LD_ADDR_VAR 0 10
110274: PUSH
110275: LD_VAR 0 12
110279: PUSH
110280: LD_INT 1
110282: ARRAY
110283: ST_TO_ADDR
// ComExit ( un ) ;
110284: LD_VAR 0 10
110288: PPUSH
110289: CALL 51907 0 1
// AddComEnterUnit ( un , i ) ;
110293: LD_VAR 0 10
110297: PPUSH
110298: LD_VAR 0 4
110302: PPUSH
110303: CALL_OW 180
// SetTag ( un , 19 ) ;
110307: LD_VAR 0 10
110311: PPUSH
110312: LD_INT 19
110314: PPUSH
110315: CALL_OW 109
// mechs := mechs diff un ;
110319: LD_ADDR_VAR 0 12
110323: PUSH
110324: LD_VAR 0 12
110328: PUSH
110329: LD_VAR 0 10
110333: DIFF
110334: ST_TO_ADDR
// end ; end ;
110335: GO 110213
110337: POP
110338: POP
// if solds then
110339: LD_VAR 0 8
110343: IFFALSE 110402
// for i in solds do
110345: LD_ADDR_VAR 0 4
110349: PUSH
110350: LD_VAR 0 8
110354: PUSH
110355: FOR_IN
110356: IFFALSE 110400
// if not GetTag ( i ) then
110358: LD_VAR 0 4
110362: PPUSH
110363: CALL_OW 110
110367: NOT
110368: IFFALSE 110398
// begin defenders := defenders union i ;
110370: LD_ADDR_VAR 0 2
110374: PUSH
110375: LD_VAR 0 2
110379: PUSH
110380: LD_VAR 0 4
110384: UNION
110385: ST_TO_ADDR
// SetTag ( i , 18 ) ;
110386: LD_VAR 0 4
110390: PPUSH
110391: LD_INT 18
110393: PPUSH
110394: CALL_OW 109
// end ;
110398: GO 110355
110400: POP
110401: POP
// repeat wait ( 0 0$2 ) ;
110402: LD_INT 70
110404: PPUSH
110405: CALL_OW 67
// enemy := mc_scan [ base ] ;
110409: LD_ADDR_VAR 0 21
110413: PUSH
110414: LD_EXP 83
110418: PUSH
110419: LD_VAR 0 1
110423: ARRAY
110424: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110425: LD_EXP 60
110429: PUSH
110430: LD_VAR 0 1
110434: ARRAY
110435: NOT
110436: PUSH
110437: LD_EXP 60
110441: PUSH
110442: LD_VAR 0 1
110446: ARRAY
110447: PUSH
110448: EMPTY
110449: EQUAL
110450: OR
110451: IFFALSE 110488
// begin for i in defenders do
110453: LD_ADDR_VAR 0 4
110457: PUSH
110458: LD_VAR 0 2
110462: PUSH
110463: FOR_IN
110464: IFFALSE 110477
// ComStop ( i ) ;
110466: LD_VAR 0 4
110470: PPUSH
110471: CALL_OW 141
110475: GO 110463
110477: POP
110478: POP
// defenders := [ ] ;
110479: LD_ADDR_VAR 0 2
110483: PUSH
110484: EMPTY
110485: ST_TO_ADDR
// exit ;
110486: GO 111937
// end ; for i in defenders do
110488: LD_ADDR_VAR 0 4
110492: PUSH
110493: LD_VAR 0 2
110497: PUSH
110498: FOR_IN
110499: IFFALSE 111397
// begin e := NearestUnitToUnit ( enemy , i ) ;
110501: LD_ADDR_VAR 0 13
110505: PUSH
110506: LD_VAR 0 21
110510: PPUSH
110511: LD_VAR 0 4
110515: PPUSH
110516: CALL_OW 74
110520: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110521: LD_ADDR_VAR 0 7
110525: PUSH
110526: LD_EXP 60
110530: PUSH
110531: LD_VAR 0 1
110535: ARRAY
110536: PPUSH
110537: LD_INT 2
110539: PUSH
110540: LD_INT 30
110542: PUSH
110543: LD_INT 0
110545: PUSH
110546: EMPTY
110547: LIST
110548: LIST
110549: PUSH
110550: LD_INT 30
110552: PUSH
110553: LD_INT 1
110555: PUSH
110556: EMPTY
110557: LIST
110558: LIST
110559: PUSH
110560: EMPTY
110561: LIST
110562: LIST
110563: LIST
110564: PPUSH
110565: CALL_OW 72
110569: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
110570: LD_ADDR_VAR 0 16
110574: PUSH
110575: LD_VAR 0 7
110579: NOT
110580: PUSH
110581: LD_VAR 0 7
110585: PPUSH
110586: LD_INT 3
110588: PUSH
110589: LD_INT 24
110591: PUSH
110592: LD_INT 600
110594: PUSH
110595: EMPTY
110596: LIST
110597: LIST
110598: PUSH
110599: EMPTY
110600: LIST
110601: LIST
110602: PPUSH
110603: CALL_OW 72
110607: OR
110608: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
110609: LD_VAR 0 4
110613: PPUSH
110614: CALL_OW 247
110618: PUSH
110619: LD_INT 2
110621: DOUBLE
110622: EQUAL
110623: IFTRUE 110627
110625: GO 111023
110627: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
110628: LD_VAR 0 4
110632: PPUSH
110633: CALL_OW 256
110637: PUSH
110638: LD_INT 1000
110640: EQUAL
110641: PUSH
110642: LD_VAR 0 4
110646: PPUSH
110647: LD_VAR 0 13
110651: PPUSH
110652: CALL_OW 296
110656: PUSH
110657: LD_INT 40
110659: LESS
110660: PUSH
110661: LD_VAR 0 13
110665: PPUSH
110666: LD_EXP 85
110670: PUSH
110671: LD_VAR 0 1
110675: ARRAY
110676: PPUSH
110677: CALL_OW 308
110681: OR
110682: AND
110683: IFFALSE 110805
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
110685: LD_VAR 0 4
110689: PPUSH
110690: CALL_OW 262
110694: PUSH
110695: LD_INT 1
110697: EQUAL
110698: PUSH
110699: LD_VAR 0 4
110703: PPUSH
110704: CALL_OW 261
110708: PUSH
110709: LD_INT 30
110711: LESS
110712: AND
110713: PUSH
110714: LD_VAR 0 7
110718: AND
110719: IFFALSE 110789
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
110721: LD_VAR 0 4
110725: PPUSH
110726: LD_VAR 0 7
110730: PPUSH
110731: LD_VAR 0 4
110735: PPUSH
110736: CALL_OW 74
110740: PPUSH
110741: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
110745: LD_VAR 0 4
110749: PPUSH
110750: LD_VAR 0 7
110754: PPUSH
110755: LD_VAR 0 4
110759: PPUSH
110760: CALL_OW 74
110764: PPUSH
110765: CALL_OW 296
110769: PUSH
110770: LD_INT 6
110772: LESS
110773: IFFALSE 110787
// SetFuel ( i , 100 ) ;
110775: LD_VAR 0 4
110779: PPUSH
110780: LD_INT 100
110782: PPUSH
110783: CALL_OW 240
// end else
110787: GO 110803
// ComAttackUnit ( i , e ) ;
110789: LD_VAR 0 4
110793: PPUSH
110794: LD_VAR 0 13
110798: PPUSH
110799: CALL_OW 115
// end else
110803: GO 110906
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
110805: LD_VAR 0 13
110809: PPUSH
110810: LD_EXP 85
110814: PUSH
110815: LD_VAR 0 1
110819: ARRAY
110820: PPUSH
110821: CALL_OW 308
110825: NOT
110826: PUSH
110827: LD_VAR 0 4
110831: PPUSH
110832: LD_VAR 0 13
110836: PPUSH
110837: CALL_OW 296
110841: PUSH
110842: LD_INT 40
110844: GREATEREQUAL
110845: AND
110846: PUSH
110847: LD_VAR 0 4
110851: PPUSH
110852: CALL_OW 256
110856: PUSH
110857: LD_INT 650
110859: LESSEQUAL
110860: OR
110861: PUSH
110862: LD_VAR 0 4
110866: PPUSH
110867: LD_EXP 84
110871: PUSH
110872: LD_VAR 0 1
110876: ARRAY
110877: PPUSH
110878: CALL_OW 308
110882: NOT
110883: AND
110884: IFFALSE 110906
// ComMoveToArea ( i , mc_parking [ base ] ) ;
110886: LD_VAR 0 4
110890: PPUSH
110891: LD_EXP 84
110895: PUSH
110896: LD_VAR 0 1
110900: ARRAY
110901: PPUSH
110902: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
110906: LD_VAR 0 4
110910: PPUSH
110911: CALL_OW 256
110915: PUSH
110916: LD_INT 1000
110918: LESS
110919: PUSH
110920: LD_VAR 0 4
110924: PPUSH
110925: CALL_OW 263
110929: PUSH
110930: LD_INT 1
110932: EQUAL
110933: AND
110934: PUSH
110935: LD_VAR 0 4
110939: PPUSH
110940: CALL_OW 311
110944: AND
110945: PUSH
110946: LD_VAR 0 4
110950: PPUSH
110951: LD_EXP 84
110955: PUSH
110956: LD_VAR 0 1
110960: ARRAY
110961: PPUSH
110962: CALL_OW 308
110966: AND
110967: IFFALSE 111021
// begin mech := IsDrivenBy ( i ) ;
110969: LD_ADDR_VAR 0 9
110973: PUSH
110974: LD_VAR 0 4
110978: PPUSH
110979: CALL_OW 311
110983: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
110984: LD_VAR 0 9
110988: PPUSH
110989: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
110993: LD_VAR 0 9
110997: PPUSH
110998: LD_VAR 0 4
111002: PPUSH
111003: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
111007: LD_VAR 0 9
111011: PPUSH
111012: LD_VAR 0 4
111016: PPUSH
111017: CALL_OW 180
// end ; end ; unit_human :
111021: GO 111368
111023: LD_INT 1
111025: DOUBLE
111026: EQUAL
111027: IFTRUE 111031
111029: GO 111367
111031: POP
// begin b := IsInUnit ( i ) ;
111032: LD_ADDR_VAR 0 18
111036: PUSH
111037: LD_VAR 0 4
111041: PPUSH
111042: CALL_OW 310
111046: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
111047: LD_ADDR_VAR 0 19
111051: PUSH
111052: LD_VAR 0 18
111056: NOT
111057: PUSH
111058: LD_VAR 0 18
111062: PPUSH
111063: CALL_OW 266
111067: PUSH
111068: LD_INT 32
111070: PUSH
111071: LD_INT 31
111073: PUSH
111074: EMPTY
111075: LIST
111076: LIST
111077: IN
111078: OR
111079: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
111080: LD_VAR 0 18
111084: PPUSH
111085: CALL_OW 266
111089: PUSH
111090: LD_INT 5
111092: EQUAL
111093: PUSH
111094: LD_VAR 0 4
111098: PPUSH
111099: CALL_OW 257
111103: PUSH
111104: LD_INT 1
111106: PUSH
111107: LD_INT 2
111109: PUSH
111110: LD_INT 3
111112: PUSH
111113: LD_INT 4
111115: PUSH
111116: EMPTY
111117: LIST
111118: LIST
111119: LIST
111120: LIST
111121: IN
111122: AND
111123: IFFALSE 111160
// begin class := AllowSpecClass ( i ) ;
111125: LD_ADDR_VAR 0 20
111129: PUSH
111130: LD_VAR 0 4
111134: PPUSH
111135: CALL 16624 0 1
111139: ST_TO_ADDR
// if class then
111140: LD_VAR 0 20
111144: IFFALSE 111160
// ComChangeProfession ( i , class ) ;
111146: LD_VAR 0 4
111150: PPUSH
111151: LD_VAR 0 20
111155: PPUSH
111156: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
111160: LD_VAR 0 16
111164: PUSH
111165: LD_VAR 0 2
111169: PPUSH
111170: LD_INT 21
111172: PUSH
111173: LD_INT 2
111175: PUSH
111176: EMPTY
111177: LIST
111178: LIST
111179: PPUSH
111180: CALL_OW 72
111184: PUSH
111185: LD_INT 1
111187: LESSEQUAL
111188: OR
111189: PUSH
111190: LD_VAR 0 19
111194: AND
111195: PUSH
111196: LD_VAR 0 4
111200: PUSH
111201: LD_VAR 0 17
111205: IN
111206: NOT
111207: AND
111208: IFFALSE 111301
// begin if b then
111210: LD_VAR 0 18
111214: IFFALSE 111263
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
111216: LD_VAR 0 18
111220: PPUSH
111221: LD_VAR 0 21
111225: PPUSH
111226: LD_VAR 0 18
111230: PPUSH
111231: CALL_OW 74
111235: PPUSH
111236: CALL_OW 296
111240: PUSH
111241: LD_INT 10
111243: LESS
111244: PUSH
111245: LD_VAR 0 18
111249: PPUSH
111250: CALL_OW 461
111254: PUSH
111255: LD_INT 7
111257: NONEQUAL
111258: AND
111259: IFFALSE 111263
// continue ;
111261: GO 110498
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
111263: LD_ADDR_VAR 0 17
111267: PUSH
111268: LD_VAR 0 17
111272: PPUSH
111273: LD_VAR 0 17
111277: PUSH
111278: LD_INT 1
111280: PLUS
111281: PPUSH
111282: LD_VAR 0 4
111286: PPUSH
111287: CALL_OW 1
111291: ST_TO_ADDR
// ComExitBuilding ( i ) ;
111292: LD_VAR 0 4
111296: PPUSH
111297: CALL_OW 122
// end ; if sold_defenders then
111301: LD_VAR 0 17
111305: IFFALSE 111365
// if i in sold_defenders then
111307: LD_VAR 0 4
111311: PUSH
111312: LD_VAR 0 17
111316: IN
111317: IFFALSE 111365
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
111319: LD_VAR 0 4
111323: PPUSH
111324: CALL_OW 314
111328: NOT
111329: PUSH
111330: LD_VAR 0 4
111334: PPUSH
111335: LD_VAR 0 13
111339: PPUSH
111340: CALL_OW 296
111344: PUSH
111345: LD_INT 30
111347: LESS
111348: AND
111349: IFFALSE 111365
// ComAttackUnit ( i , e ) ;
111351: LD_VAR 0 4
111355: PPUSH
111356: LD_VAR 0 13
111360: PPUSH
111361: CALL_OW 115
// end ; end ; end ;
111365: GO 111368
111367: POP
// if IsDead ( i ) then
111368: LD_VAR 0 4
111372: PPUSH
111373: CALL_OW 301
111377: IFFALSE 111395
// defenders := defenders diff i ;
111379: LD_ADDR_VAR 0 2
111383: PUSH
111384: LD_VAR 0 2
111388: PUSH
111389: LD_VAR 0 4
111393: DIFF
111394: ST_TO_ADDR
// end ;
111395: GO 110498
111397: POP
111398: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
111399: LD_VAR 0 21
111403: NOT
111404: PUSH
111405: LD_VAR 0 2
111409: NOT
111410: OR
111411: PUSH
111412: LD_EXP 60
111416: PUSH
111417: LD_VAR 0 1
111421: ARRAY
111422: NOT
111423: OR
111424: IFFALSE 110402
// MC_Reset ( base , 18 ) ;
111426: LD_VAR 0 1
111430: PPUSH
111431: LD_INT 18
111433: PPUSH
111434: CALL 59027 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
111438: LD_ADDR_VAR 0 2
111442: PUSH
111443: LD_VAR 0 2
111447: PUSH
111448: LD_VAR 0 2
111452: PPUSH
111453: LD_INT 2
111455: PUSH
111456: LD_INT 25
111458: PUSH
111459: LD_INT 1
111461: PUSH
111462: EMPTY
111463: LIST
111464: LIST
111465: PUSH
111466: LD_INT 25
111468: PUSH
111469: LD_INT 5
111471: PUSH
111472: EMPTY
111473: LIST
111474: LIST
111475: PUSH
111476: LD_INT 25
111478: PUSH
111479: LD_INT 8
111481: PUSH
111482: EMPTY
111483: LIST
111484: LIST
111485: PUSH
111486: LD_INT 25
111488: PUSH
111489: LD_INT 9
111491: PUSH
111492: EMPTY
111493: LIST
111494: LIST
111495: PUSH
111496: EMPTY
111497: LIST
111498: LIST
111499: LIST
111500: LIST
111501: LIST
111502: PPUSH
111503: CALL_OW 72
111507: DIFF
111508: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
111509: LD_VAR 0 21
111513: NOT
111514: PUSH
111515: LD_VAR 0 2
111519: PPUSH
111520: LD_INT 21
111522: PUSH
111523: LD_INT 2
111525: PUSH
111526: EMPTY
111527: LIST
111528: LIST
111529: PPUSH
111530: CALL_OW 72
111534: AND
111535: IFFALSE 111873
// begin tmp := FilterByTag ( defenders , 19 ) ;
111537: LD_ADDR_VAR 0 11
111541: PUSH
111542: LD_VAR 0 2
111546: PPUSH
111547: LD_INT 19
111549: PPUSH
111550: CALL 49093 0 2
111554: ST_TO_ADDR
// if tmp then
111555: LD_VAR 0 11
111559: IFFALSE 111629
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
111561: LD_ADDR_VAR 0 11
111565: PUSH
111566: LD_VAR 0 11
111570: PPUSH
111571: LD_INT 25
111573: PUSH
111574: LD_INT 3
111576: PUSH
111577: EMPTY
111578: LIST
111579: LIST
111580: PPUSH
111581: CALL_OW 72
111585: ST_TO_ADDR
// if tmp then
111586: LD_VAR 0 11
111590: IFFALSE 111629
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
111592: LD_ADDR_EXP 72
111596: PUSH
111597: LD_EXP 72
111601: PPUSH
111602: LD_VAR 0 1
111606: PPUSH
111607: LD_EXP 72
111611: PUSH
111612: LD_VAR 0 1
111616: ARRAY
111617: PUSH
111618: LD_VAR 0 11
111622: UNION
111623: PPUSH
111624: CALL_OW 1
111628: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
111629: LD_VAR 0 1
111633: PPUSH
111634: LD_INT 19
111636: PPUSH
111637: CALL 59027 0 2
// repeat wait ( 0 0$1 ) ;
111641: LD_INT 35
111643: PPUSH
111644: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111648: LD_EXP 60
111652: PUSH
111653: LD_VAR 0 1
111657: ARRAY
111658: NOT
111659: PUSH
111660: LD_EXP 60
111664: PUSH
111665: LD_VAR 0 1
111669: ARRAY
111670: PUSH
111671: EMPTY
111672: EQUAL
111673: OR
111674: IFFALSE 111711
// begin for i in defenders do
111676: LD_ADDR_VAR 0 4
111680: PUSH
111681: LD_VAR 0 2
111685: PUSH
111686: FOR_IN
111687: IFFALSE 111700
// ComStop ( i ) ;
111689: LD_VAR 0 4
111693: PPUSH
111694: CALL_OW 141
111698: GO 111686
111700: POP
111701: POP
// defenders := [ ] ;
111702: LD_ADDR_VAR 0 2
111706: PUSH
111707: EMPTY
111708: ST_TO_ADDR
// exit ;
111709: GO 111937
// end ; for i in defenders do
111711: LD_ADDR_VAR 0 4
111715: PUSH
111716: LD_VAR 0 2
111720: PUSH
111721: FOR_IN
111722: IFFALSE 111811
// begin if not IsInArea ( i , mc_parking [ base ] ) then
111724: LD_VAR 0 4
111728: PPUSH
111729: LD_EXP 84
111733: PUSH
111734: LD_VAR 0 1
111738: ARRAY
111739: PPUSH
111740: CALL_OW 308
111744: NOT
111745: IFFALSE 111769
// ComMoveToArea ( i , mc_parking [ base ] ) else
111747: LD_VAR 0 4
111751: PPUSH
111752: LD_EXP 84
111756: PUSH
111757: LD_VAR 0 1
111761: ARRAY
111762: PPUSH
111763: CALL_OW 113
111767: GO 111809
// if GetControl ( i ) = control_manual then
111769: LD_VAR 0 4
111773: PPUSH
111774: CALL_OW 263
111778: PUSH
111779: LD_INT 1
111781: EQUAL
111782: IFFALSE 111809
// if IsDrivenBy ( i ) then
111784: LD_VAR 0 4
111788: PPUSH
111789: CALL_OW 311
111793: IFFALSE 111809
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
111795: LD_VAR 0 4
111799: PPUSH
111800: CALL_OW 311
111804: PPUSH
111805: CALL_OW 121
// end ;
111809: GO 111721
111811: POP
111812: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
111813: LD_VAR 0 2
111817: PPUSH
111818: LD_INT 95
111820: PUSH
111821: LD_EXP 84
111825: PUSH
111826: LD_VAR 0 1
111830: ARRAY
111831: PUSH
111832: EMPTY
111833: LIST
111834: LIST
111835: PPUSH
111836: CALL_OW 72
111840: PUSH
111841: LD_VAR 0 2
111845: EQUAL
111846: PUSH
111847: LD_EXP 83
111851: PUSH
111852: LD_VAR 0 1
111856: ARRAY
111857: OR
111858: PUSH
111859: LD_EXP 60
111863: PUSH
111864: LD_VAR 0 1
111868: ARRAY
111869: NOT
111870: OR
111871: IFFALSE 111641
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
111873: LD_ADDR_EXP 82
111877: PUSH
111878: LD_EXP 82
111882: PPUSH
111883: LD_VAR 0 1
111887: PPUSH
111888: LD_VAR 0 2
111892: PPUSH
111893: LD_INT 21
111895: PUSH
111896: LD_INT 2
111898: PUSH
111899: EMPTY
111900: LIST
111901: LIST
111902: PPUSH
111903: CALL_OW 72
111907: PPUSH
111908: CALL_OW 1
111912: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
111913: LD_VAR 0 1
111917: PPUSH
111918: LD_INT 19
111920: PPUSH
111921: CALL 59027 0 2
// MC_Reset ( base , 20 ) ;
111925: LD_VAR 0 1
111929: PPUSH
111930: LD_INT 20
111932: PPUSH
111933: CALL 59027 0 2
// end ; end_of_file
111937: LD_VAR 0 3
111941: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
111942: LD_VAR 0 1
111946: PUSH
111947: LD_INT 200
111949: DOUBLE
111950: GREATEREQUAL
111951: IFFALSE 111959
111953: LD_INT 299
111955: DOUBLE
111956: LESSEQUAL
111957: IFTRUE 111961
111959: GO 111993
111961: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
111962: LD_VAR 0 1
111966: PPUSH
111967: LD_VAR 0 2
111971: PPUSH
111972: LD_VAR 0 3
111976: PPUSH
111977: LD_VAR 0 4
111981: PPUSH
111982: LD_VAR 0 5
111986: PPUSH
111987: CALL 100379 0 5
111991: GO 112070
111993: LD_INT 300
111995: DOUBLE
111996: GREATEREQUAL
111997: IFFALSE 112005
111999: LD_INT 399
112001: DOUBLE
112002: LESSEQUAL
112003: IFTRUE 112007
112005: GO 112069
112007: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
112008: LD_VAR 0 1
112012: PPUSH
112013: LD_VAR 0 2
112017: PPUSH
112018: LD_VAR 0 3
112022: PPUSH
112023: LD_VAR 0 4
112027: PPUSH
112028: LD_VAR 0 5
112032: PPUSH
112033: LD_VAR 0 6
112037: PPUSH
112038: LD_VAR 0 7
112042: PPUSH
112043: LD_VAR 0 8
112047: PPUSH
112048: LD_VAR 0 9
112052: PPUSH
112053: LD_VAR 0 10
112057: PPUSH
112058: LD_VAR 0 11
112062: PPUSH
112063: CALL 98021 0 11
112067: GO 112070
112069: POP
// end ;
112070: PPOPN 11
112072: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
112073: LD_VAR 0 1
112077: PPUSH
112078: LD_VAR 0 2
112082: PPUSH
112083: LD_VAR 0 3
112087: PPUSH
112088: LD_VAR 0 4
112092: PPUSH
112093: LD_VAR 0 5
112097: PPUSH
112098: CALL 100115 0 5
// end ; end_of_file
112102: PPOPN 5
112104: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
112105: LD_VAR 0 1
112109: PPUSH
112110: LD_VAR 0 2
112114: PPUSH
112115: LD_VAR 0 3
112119: PPUSH
112120: LD_VAR 0 4
112124: PPUSH
112125: LD_VAR 0 5
112129: PPUSH
112130: LD_VAR 0 6
112134: PPUSH
112135: CALL 85714 0 6
// end ;
112139: PPOPN 6
112141: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
112142: CALL 85689 0 0
// end ;
112146: PPOPN 1
112148: END
