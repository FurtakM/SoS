// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 57076 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 48843 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 48843 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 48843 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 48843 0 9
// PrepareArabian ;
 147: CALL 3529 0 0
// PrepareRussian ;
 151: CALL 2664 0 0
// PrepareAlliance ;
 155: CALL 729 0 0
// MC_Start ( ) ;
 159: CALL 59188 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6692 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 82
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 83
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 80293 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 53
 252: PPUSH
 253: CALL 80719 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 81177 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 81446 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 80659 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 81353 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 50
 340: PPUSH
 341: CALL 80719 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 81177 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 81446 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 80503 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 80659 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := false ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 51
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// end ; end_of_file
 724: LD_VAR 0 1
 728: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 729: LD_INT 0
 731: PPUSH
 732: PPUSH
 733: PPUSH
 734: PPUSH
// uc_side := 7 ;
 735: LD_ADDR_OWVAR 20
 739: PUSH
 740: LD_INT 7
 742: ST_TO_ADDR
// uc_nation := 1 ;
 743: LD_ADDR_OWVAR 21
 747: PUSH
 748: LD_INT 1
 750: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 751: LD_ADDR_EXP 14
 755: PUSH
 756: LD_STRING JMM
 758: PPUSH
 759: LD_EXP 1
 763: NOT
 764: PPUSH
 765: LD_STRING 12a_
 767: PPUSH
 768: CALL 14063 0 3
 772: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 773: LD_EXP 14
 777: PPUSH
 778: LD_INT 71
 780: PPUSH
 781: LD_INT 23
 783: PPUSH
 784: LD_INT 0
 786: PPUSH
 787: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 791: LD_EXP 14
 795: PPUSH
 796: LD_INT 2
 798: PPUSH
 799: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 803: LD_ADDR_EXP 15
 807: PUSH
 808: LD_STRING Roth
 810: PPUSH
 811: LD_EXP 1
 815: NOT
 816: PPUSH
 817: LD_STRING 12a_
 819: PPUSH
 820: CALL 14063 0 3
 824: ST_TO_ADDR
// if Roth then
 825: LD_EXP 15
 829: IFFALSE 849
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 831: LD_EXP 15
 835: PPUSH
 836: LD_INT 71
 838: PPUSH
 839: LD_INT 21
 841: PPUSH
 842: LD_INT 0
 844: PPUSH
 845: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 849: LD_ADDR_EXP 16
 853: PUSH
 854: LD_STRING Lisa
 856: PPUSH
 857: LD_EXP 1
 861: NOT
 862: PPUSH
 863: LD_STRING 12a_
 865: PPUSH
 866: CALL 14063 0 3
 870: ST_TO_ADDR
// if Lisa then
 871: LD_EXP 16
 875: IFFALSE 892
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 877: LD_EXP 16
 881: PPUSH
 882: LD_INT 13
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 892: LD_ADDR_EXP 17
 896: PUSH
 897: LD_STRING Donaldson
 899: PPUSH
 900: LD_EXP 1
 904: NOT
 905: PPUSH
 906: LD_STRING 12a_
 908: PPUSH
 909: CALL 14063 0 3
 913: ST_TO_ADDR
// if Donaldson then
 914: LD_EXP 17
 918: IFFALSE 935
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 920: LD_EXP 17
 924: PPUSH
 925: LD_INT 13
 927: PPUSH
 928: LD_INT 0
 930: PPUSH
 931: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 935: LD_ADDR_EXP 18
 939: PUSH
 940: LD_STRING Bobby
 942: PPUSH
 943: LD_EXP 1
 947: NOT
 948: PPUSH
 949: LD_STRING 12a_
 951: PPUSH
 952: CALL 14063 0 3
 956: ST_TO_ADDR
// if Bobby then
 957: LD_EXP 18
 961: IFFALSE 978
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 963: LD_EXP 18
 967: PPUSH
 968: LD_INT 13
 970: PPUSH
 971: LD_INT 0
 973: PPUSH
 974: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 978: LD_ADDR_EXP 19
 982: PUSH
 983: LD_STRING Cyrus
 985: PPUSH
 986: LD_EXP 1
 990: NOT
 991: PPUSH
 992: LD_STRING 12a_
 994: PPUSH
 995: CALL 14063 0 3
 999: ST_TO_ADDR
// if Cyrus then
1000: LD_EXP 19
1004: IFFALSE 1021
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1006: LD_EXP 19
1010: PPUSH
1011: LD_INT 13
1013: PPUSH
1014: LD_INT 0
1016: PPUSH
1017: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1021: LD_ADDR_EXP 20
1025: PUSH
1026: LD_STRING Denis
1028: PPUSH
1029: LD_EXP 1
1033: NOT
1034: PPUSH
1035: LD_STRING 12a_
1037: PPUSH
1038: CALL 14063 0 3
1042: ST_TO_ADDR
// if Denis then
1043: LD_EXP 20
1047: IFFALSE 1064
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1049: LD_EXP 20
1053: PPUSH
1054: LD_INT 13
1056: PPUSH
1057: LD_INT 0
1059: PPUSH
1060: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1064: LD_ADDR_EXP 21
1068: PUSH
1069: LD_STRING Brown
1071: PPUSH
1072: LD_EXP 1
1076: NOT
1077: PPUSH
1078: LD_STRING 12a_
1080: PPUSH
1081: CALL 14063 0 3
1085: ST_TO_ADDR
// if Brown then
1086: LD_EXP 21
1090: IFFALSE 1107
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1092: LD_EXP 21
1096: PPUSH
1097: LD_INT 13
1099: PPUSH
1100: LD_INT 0
1102: PPUSH
1103: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1107: LD_ADDR_EXP 22
1111: PUSH
1112: LD_STRING Gladstone
1114: PPUSH
1115: LD_EXP 1
1119: NOT
1120: PPUSH
1121: LD_STRING 12a_
1123: PPUSH
1124: CALL 14063 0 3
1128: ST_TO_ADDR
// if Gladstone then
1129: LD_EXP 22
1133: IFFALSE 1150
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1135: LD_EXP 22
1139: PPUSH
1140: LD_INT 13
1142: PPUSH
1143: LD_INT 0
1145: PPUSH
1146: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1150: LD_ADDR_EXP 23
1154: PUSH
1155: LD_STRING Houten
1157: PPUSH
1158: LD_EXP 1
1162: NOT
1163: PPUSH
1164: LD_STRING 12a_
1166: PPUSH
1167: CALL 14063 0 3
1171: ST_TO_ADDR
// if Houten then
1172: LD_EXP 23
1176: IFFALSE 1193
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1178: LD_EXP 23
1182: PPUSH
1183: LD_INT 13
1185: PPUSH
1186: LD_INT 0
1188: PPUSH
1189: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1193: LD_ADDR_EXP 24
1197: PUSH
1198: LD_STRING Cornell
1200: PPUSH
1201: LD_EXP 1
1205: NOT
1206: PPUSH
1207: LD_STRING 12a_
1209: PPUSH
1210: CALL 14063 0 3
1214: ST_TO_ADDR
// if Cornel then
1215: LD_EXP 24
1219: IFFALSE 1236
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1221: LD_EXP 24
1225: PPUSH
1226: LD_INT 13
1228: PPUSH
1229: LD_INT 0
1231: PPUSH
1232: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1236: LD_ADDR_EXP 25
1240: PUSH
1241: LD_STRING Gary
1243: PPUSH
1244: LD_EXP 1
1248: NOT
1249: PPUSH
1250: LD_STRING 12a_
1252: PPUSH
1253: CALL 14063 0 3
1257: ST_TO_ADDR
// if Gary then
1258: LD_EXP 25
1262: IFFALSE 1279
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1264: LD_EXP 25
1268: PPUSH
1269: LD_INT 13
1271: PPUSH
1272: LD_INT 0
1274: PPUSH
1275: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1279: LD_ADDR_EXP 26
1283: PUSH
1284: LD_STRING Frank
1286: PPUSH
1287: LD_EXP 1
1291: NOT
1292: PPUSH
1293: LD_STRING 12a_
1295: PPUSH
1296: CALL 14063 0 3
1300: ST_TO_ADDR
// if Frank then
1301: LD_EXP 26
1305: IFFALSE 1322
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1307: LD_EXP 26
1311: PPUSH
1312: LD_INT 13
1314: PPUSH
1315: LD_INT 0
1317: PPUSH
1318: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1322: LD_ADDR_EXP 27
1326: PUSH
1327: LD_STRING Kikuchi
1329: PPUSH
1330: LD_EXP 1
1334: NOT
1335: PPUSH
1336: LD_STRING 12a_
1338: PPUSH
1339: CALL 14063 0 3
1343: ST_TO_ADDR
// if Kikuchi then
1344: LD_EXP 27
1348: IFFALSE 1365
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1350: LD_EXP 27
1354: PPUSH
1355: LD_INT 13
1357: PPUSH
1358: LD_INT 0
1360: PPUSH
1361: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1365: LD_ADDR_EXP 28
1369: PUSH
1370: LD_STRING Simms
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_STRING 12a_
1381: PPUSH
1382: CALL 14063 0 3
1386: ST_TO_ADDR
// if Simms then
1387: LD_EXP 28
1391: IFFALSE 1408
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1393: LD_EXP 28
1397: PPUSH
1398: LD_INT 13
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1408: LD_ADDR_EXP 29
1412: PUSH
1413: LD_STRING Joan
1415: PPUSH
1416: LD_EXP 1
1420: NOT
1421: PPUSH
1422: LD_STRING 12a_
1424: PPUSH
1425: CALL 14063 0 3
1429: ST_TO_ADDR
// if Joan then
1430: LD_EXP 29
1434: IFFALSE 1451
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1436: LD_EXP 29
1440: PPUSH
1441: LD_INT 13
1443: PPUSH
1444: LD_INT 0
1446: PPUSH
1447: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1451: LD_ADDR_EXP 30
1455: PUSH
1456: LD_STRING DeltaDoctor
1458: PPUSH
1459: LD_EXP 1
1463: NOT
1464: PPUSH
1465: LD_STRING 12a_
1467: PPUSH
1468: CALL 14063 0 3
1472: ST_TO_ADDR
// if DeltaDoctor then
1473: LD_EXP 30
1477: IFFALSE 1494
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1479: LD_EXP 30
1483: PPUSH
1484: LD_INT 13
1486: PPUSH
1487: LD_INT 0
1489: PPUSH
1490: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_STRING 12a_others
1501: PPUSH
1502: CALL_OW 31
1506: ST_TO_ADDR
// if tmp then
1507: LD_VAR 0 4
1511: IFFALSE 1545
// for i in tmp do
1513: LD_ADDR_VAR 0 3
1517: PUSH
1518: LD_VAR 0 4
1522: PUSH
1523: FOR_IN
1524: IFFALSE 1543
// PlaceUnitArea ( i , alliance_start , false ) ;
1526: LD_VAR 0 3
1530: PPUSH
1531: LD_INT 13
1533: PPUSH
1534: LD_INT 0
1536: PPUSH
1537: CALL_OW 49
1541: GO 1523
1543: POP
1544: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1545: LD_INT 3
1547: PPUSH
1548: LD_INT 3
1550: PPUSH
1551: LD_INT 3
1553: PPUSH
1554: LD_INT 12
1556: PPUSH
1557: LD_INT 100
1559: PPUSH
1560: CALL 21029 0 5
// veh := CreateVehicle ;
1564: LD_ADDR_VAR 0 2
1568: PUSH
1569: CALL_OW 45
1573: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1574: LD_VAR 0 2
1578: PPUSH
1579: LD_INT 2
1581: PPUSH
1582: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1586: LD_VAR 0 2
1590: PPUSH
1591: LD_INT 60
1593: PPUSH
1594: LD_INT 6
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1604: LD_VAR 0 2
1608: PPUSH
1609: LD_INT 4
1611: PPUSH
1612: LD_INT 30
1614: PPUSH
1615: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1619: LD_STRING 11_artifact_captured
1621: PPUSH
1622: LD_INT 0
1624: PPUSH
1625: CALL_OW 30
1629: IFFALSE 1705
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1631: LD_INT 3
1633: PPUSH
1634: LD_INT 3
1636: PPUSH
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 12
1642: PPUSH
1643: LD_INT 100
1645: PPUSH
1646: CALL 21029 0 5
// veh := CreateVehicle ;
1650: LD_ADDR_VAR 0 2
1654: PUSH
1655: CALL_OW 45
1659: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1660: LD_VAR 0 2
1664: PPUSH
1665: LD_INT 3
1667: PPUSH
1668: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1672: LD_VAR 0 2
1676: PPUSH
1677: LD_INT 75
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: LD_INT 0
1685: PPUSH
1686: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1690: LD_VAR 0 2
1694: PPUSH
1695: LD_INT 4
1697: PPUSH
1698: LD_INT 50
1700: PPUSH
1701: CALL_OW 290
// end ; end ;
1705: LD_VAR 0 1
1709: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1710: LD_INT 0
1712: PPUSH
1713: PPUSH
1714: PPUSH
1715: PPUSH
// uc_side := 6 ;
1716: LD_ADDR_OWVAR 20
1720: PUSH
1721: LD_INT 6
1723: ST_TO_ADDR
// uc_nation := 3 ;
1724: LD_ADDR_OWVAR 21
1728: PUSH
1729: LD_INT 3
1731: ST_TO_ADDR
// InitHc ;
1732: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1736: LD_ADDR_EXP 31
1740: PUSH
1741: LD_STRING Gossudarov
1743: PPUSH
1744: CALL_OW 25
1748: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1749: LD_ADDR_EXP 32
1753: PUSH
1754: LD_STRING Kirilenkova
1756: PPUSH
1757: CALL_OW 25
1761: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1762: LD_ADDR_EXP 33
1766: PUSH
1767: LD_STRING Titov
1769: PPUSH
1770: CALL_OW 25
1774: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1775: LD_ADDR_EXP 38
1779: PUSH
1780: LD_STRING Oblukov
1782: PPUSH
1783: CALL_OW 25
1787: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1788: LD_ADDR_EXP 35
1792: PUSH
1793: LD_STRING Dolgov
1795: PPUSH
1796: CALL_OW 25
1800: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1801: LD_ADDR_EXP 36
1805: PUSH
1806: LD_STRING Petrosyan
1808: PPUSH
1809: CALL_OW 25
1813: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1814: LD_ADDR_EXP 37
1818: PUSH
1819: LD_STRING Scholtze
1821: PPUSH
1822: CALL_OW 25
1826: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1827: LD_ADDR_EXP 39
1831: PUSH
1832: LD_STRING Kapitsova
1834: PPUSH
1835: CALL_OW 25
1839: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1840: LD_ADDR_VAR 0 2
1844: PUSH
1845: LD_EXP 31
1849: PUSH
1850: LD_EXP 32
1854: PUSH
1855: LD_EXP 33
1859: PUSH
1860: LD_EXP 38
1864: PUSH
1865: LD_EXP 35
1869: PUSH
1870: LD_EXP 36
1874: PUSH
1875: LD_EXP 37
1879: PUSH
1880: LD_EXP 39
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1895: LD_INT 1
1897: PPUSH
1898: LD_INT 4
1900: PPUSH
1901: LD_INT 8
1903: PPUSH
1904: CALL_OW 380
// un := CreateHuman ;
1908: LD_ADDR_VAR 0 4
1912: PUSH
1913: CALL_OW 44
1917: ST_TO_ADDR
// tmp := tmp ^ un ;
1918: LD_ADDR_VAR 0 2
1922: PUSH
1923: LD_VAR 0 2
1927: PUSH
1928: LD_VAR 0 4
1932: ADD
1933: ST_TO_ADDR
// for i in tmp do
1934: LD_ADDR_VAR 0 3
1938: PUSH
1939: LD_VAR 0 2
1943: PUSH
1944: FOR_IN
1945: IFFALSE 1964
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1947: LD_VAR 0 3
1951: PPUSH
1952: LD_INT 14
1954: PPUSH
1955: LD_INT 0
1957: PPUSH
1958: CALL_OW 49
1962: GO 1944
1964: POP
1965: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1966: LD_VAR 0 2
1970: PPUSH
1971: LD_EXP 3
1975: PPUSH
1976: CALL_OW 250
1980: PPUSH
1981: LD_EXP 3
1985: PPUSH
1986: CALL_OW 251
1990: PPUSH
1991: CALL_OW 111
// end ;
1995: LD_VAR 0 1
1999: RET
// export function PrepareBelkov ; begin
2000: LD_INT 0
2002: PPUSH
// uc_side := 4 ;
2003: LD_ADDR_OWVAR 20
2007: PUSH
2008: LD_INT 4
2010: ST_TO_ADDR
// uc_nation := 3 ;
2011: LD_ADDR_OWVAR 21
2015: PUSH
2016: LD_INT 3
2018: ST_TO_ADDR
// InitHc ;
2019: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2023: LD_ADDR_EXP 46
2027: PUSH
2028: LD_STRING Belkov
2030: PPUSH
2031: CALL_OW 25
2035: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2036: LD_EXP 46
2040: PPUSH
2041: LD_INT 14
2043: PPUSH
2044: LD_INT 0
2046: PPUSH
2047: CALL_OW 49
// end ;
2051: LD_VAR 0 1
2055: RET
// export function PrepareGnyevko ; begin
2056: LD_INT 0
2058: PPUSH
// uc_side := 4 ;
2059: LD_ADDR_OWVAR 20
2063: PUSH
2064: LD_INT 4
2066: ST_TO_ADDR
// uc_nation := 3 ;
2067: LD_ADDR_OWVAR 21
2071: PUSH
2072: LD_INT 3
2074: ST_TO_ADDR
// InitHc ;
2075: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2079: LD_ADDR_EXP 47
2083: PUSH
2084: LD_STRING Gnyevko
2086: PPUSH
2087: CALL_OW 25
2091: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2092: LD_EXP 47
2096: PPUSH
2097: LD_INT 14
2099: PPUSH
2100: LD_INT 0
2102: PPUSH
2103: CALL_OW 49
// end ;
2107: LD_VAR 0 1
2111: RET
// export function PrepareBurlak ; var i , tmp ; begin
2112: LD_INT 0
2114: PPUSH
2115: PPUSH
2116: PPUSH
// uc_side := 4 ;
2117: LD_ADDR_OWVAR 20
2121: PUSH
2122: LD_INT 4
2124: ST_TO_ADDR
// uc_nation := 3 ;
2125: LD_ADDR_OWVAR 21
2129: PUSH
2130: LD_INT 3
2132: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2133: LD_INT 35
2135: PPUSH
2136: CALL_OW 67
// until not FilterAllUnits ( [ f_distxy , 123 , 3 , 3 ] ) ;
2140: LD_INT 92
2142: PUSH
2143: LD_INT 123
2145: PUSH
2146: LD_INT 3
2148: PUSH
2149: LD_INT 3
2151: PUSH
2152: EMPTY
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: PPUSH
2158: CALL_OW 69
2162: NOT
2163: IFFALSE 2133
// InitHc ;
2165: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2169: LD_ADDR_EXP 45
2173: PUSH
2174: LD_STRING Burlak
2176: PPUSH
2177: CALL_OW 25
2181: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2182: LD_INT 24
2184: PUSH
2185: LD_INT 23
2187: PUSH
2188: LD_INT 22
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_OWVAR 67
2200: ARRAY
2201: PPUSH
2202: LD_INT 1
2204: PPUSH
2205: LD_INT 1
2207: PPUSH
2208: LD_INT 45
2210: PUSH
2211: LD_INT 44
2213: PUSH
2214: LD_INT 43
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: LIST
2221: PUSH
2222: LD_OWVAR 67
2226: ARRAY
2227: PPUSH
2228: LD_INT 0
2230: PPUSH
2231: CALL 21029 0 5
// Masha := CreateVehicle ;
2235: LD_ADDR_EXP 48
2239: PUSH
2240: CALL_OW 45
2244: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2245: LD_EXP 48
2249: PUSH
2250: LD_EXP 45
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PPUSH
2259: LD_INT 499
2261: PPUSH
2262: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2266: LD_EXP 48
2270: PPUSH
2271: LD_INT 3
2273: PPUSH
2274: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2278: LD_EXP 48
2282: PPUSH
2283: LD_INT 1
2285: PPUSH
2286: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2290: LD_EXP 48
2294: PPUSH
2295: LD_INT 18
2297: PPUSH
2298: LD_INT 0
2300: PPUSH
2301: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2305: LD_EXP 45
2309: PPUSH
2310: LD_INT 125
2312: PPUSH
2313: LD_INT 1
2315: PPUSH
2316: LD_INT 0
2318: PPUSH
2319: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2323: LD_EXP 45
2327: PPUSH
2328: LD_EXP 48
2332: PPUSH
2333: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2337: LD_INT 10
2339: PPUSH
2340: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2344: LD_EXP 48
2348: PPUSH
2349: LD_INT 110
2351: PPUSH
2352: LD_INT 10
2354: PPUSH
2355: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2359: LD_ADDR_EXP 41
2363: PUSH
2364: LD_STRING Petrovova
2366: PPUSH
2367: CALL_OW 25
2371: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2372: LD_ADDR_EXP 43
2376: PUSH
2377: LD_STRING Kuzmov
2379: PPUSH
2380: CALL_OW 25
2384: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2385: LD_ADDR_EXP 42
2389: PUSH
2390: LD_STRING Kovalyuk
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2398: LD_ADDR_EXP 40
2402: PUSH
2403: LD_STRING Lipshchin
2405: PPUSH
2406: CALL_OW 25
2410: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2411: LD_ADDR_EXP 44
2415: PUSH
2416: LD_STRING Karamazov
2418: PPUSH
2419: CALL_OW 25
2423: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2424: LD_ADDR_VAR 0 3
2428: PUSH
2429: LD_EXP 41
2433: PUSH
2434: LD_EXP 43
2438: PUSH
2439: LD_EXP 42
2443: PUSH
2444: LD_EXP 40
2448: PUSH
2449: LD_EXP 44
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: ST_TO_ADDR
// for i in tmp do
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 3
2470: PUSH
2471: FOR_IN
2472: IFFALSE 2511
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2474: LD_VAR 0 2
2478: PPUSH
2479: LD_INT 399
2481: PPUSH
2482: LD_INT 799
2484: PPUSH
2485: CALL_OW 12
2489: PPUSH
2490: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2494: LD_VAR 0 2
2498: PPUSH
2499: LD_INT 19
2501: PPUSH
2502: LD_INT 0
2504: PPUSH
2505: CALL_OW 49
// end ;
2509: GO 2471
2511: POP
2512: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2513: LD_VAR 0 3
2517: PPUSH
2518: LD_INT 116
2520: PPUSH
2521: LD_INT 8
2523: PPUSH
2524: CALL_OW 111
// AddComHold ( tmp ) ;
2528: LD_VAR 0 3
2532: PPUSH
2533: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2537: LD_ADDR_VAR 0 2
2541: PUSH
2542: LD_VAR 0 3
2546: PPUSH
2547: LD_INT 25
2549: PUSH
2550: LD_INT 1
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 72
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2603
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 20
2572: PPUSH
2573: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2577: LD_VAR 0 2
2581: PPUSH
2582: LD_INT 147
2584: PPUSH
2585: LD_INT 45
2587: PPUSH
2588: CALL_OW 178
// AddComCrawl ( i ) ;
2592: LD_VAR 0 2
2596: PPUSH
2597: CALL_OW 197
// end ;
2601: GO 2562
2603: POP
2604: POP
// repeat wait ( 0 0$1 ) ;
2605: LD_INT 35
2607: PPUSH
2608: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2612: LD_EXP 48
2616: PPUSH
2617: LD_INT 110
2619: PPUSH
2620: LD_INT 10
2622: PPUSH
2623: CALL_OW 307
2627: PUSH
2628: LD_EXP 48
2632: PPUSH
2633: CALL_OW 305
2637: NOT
2638: OR
2639: IFFALSE 2605
// ComStop ( Burlak ) ;
2641: LD_EXP 45
2645: PPUSH
2646: CALL_OW 141
// AddComHold ( Burlak ) ;
2650: LD_EXP 45
2654: PPUSH
2655: CALL_OW 200
// end ; end_of_file
2659: LD_VAR 0 1
2663: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2664: LD_INT 0
2666: PPUSH
2667: PPUSH
2668: PPUSH
2669: PPUSH
// uc_side := 3 ;
2670: LD_ADDR_OWVAR 20
2674: PUSH
2675: LD_INT 3
2677: ST_TO_ADDR
// uc_nation := 3 ;
2678: LD_ADDR_OWVAR 21
2682: PUSH
2683: LD_INT 3
2685: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2686: LD_ADDR_EXP 49
2690: PUSH
2691: LD_INT 47
2693: PPUSH
2694: LD_INT 4
2696: PPUSH
2697: LD_STRING 
2699: PPUSH
2700: LD_INT 7
2702: PUSH
2703: LD_INT 8
2705: PUSH
2706: LD_INT 9
2708: PUSH
2709: EMPTY
2710: LIST
2711: LIST
2712: LIST
2713: PUSH
2714: LD_OWVAR 67
2718: ARRAY
2719: PPUSH
2720: LD_INT 10000
2722: PUSH
2723: LD_INT 3000
2725: PUSH
2726: LD_INT 300
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: LIST
2733: PPUSH
2734: LD_INT 9
2736: PUSH
2737: LD_INT 5
2739: PUSH
2740: LD_INT 6
2742: PUSH
2743: LD_INT 6
2745: PUSH
2746: EMPTY
2747: LIST
2748: LIST
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL 24438 0 6
2756: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2757: LD_ADDR_EXP 58
2761: PUSH
2762: LD_EXP 58
2766: PPUSH
2767: LD_INT 2
2769: PPUSH
2770: LD_EXP 49
2774: PPUSH
2775: CALL_OW 1
2779: ST_TO_ADDR
// tmp := [ ] ;
2780: LD_ADDR_VAR 0 4
2784: PUSH
2785: EMPTY
2786: ST_TO_ADDR
// for i = 1 to 4 do
2787: LD_ADDR_VAR 0 2
2791: PUSH
2792: DOUBLE
2793: LD_INT 1
2795: DEC
2796: ST_TO_ADDR
2797: LD_INT 4
2799: PUSH
2800: FOR_TO
2801: IFFALSE 2894
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2803: LD_INT 22
2805: PPUSH
2806: LD_INT 3
2808: PPUSH
2809: LD_INT 3
2811: PPUSH
2812: LD_INT 43
2814: PUSH
2815: LD_INT 45
2817: PUSH
2818: LD_INT 45
2820: PUSH
2821: LD_INT 44
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: LIST
2828: LIST
2829: PUSH
2830: LD_VAR 0 2
2834: PUSH
2835: LD_INT 4
2837: MOD
2838: PUSH
2839: LD_INT 1
2841: PLUS
2842: ARRAY
2843: PPUSH
2844: LD_INT 100
2846: PPUSH
2847: CALL 21029 0 5
// veh := CreateVehicle ;
2851: LD_ADDR_VAR 0 3
2855: PUSH
2856: CALL_OW 45
2860: ST_TO_ADDR
// tmp := tmp ^ veh ;
2861: LD_ADDR_VAR 0 4
2865: PUSH
2866: LD_VAR 0 4
2870: PUSH
2871: LD_VAR 0 3
2875: ADD
2876: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2877: LD_VAR 0 3
2881: PPUSH
2882: LD_INT 2
2884: PPUSH
2885: LD_INT 0
2887: PPUSH
2888: CALL_OW 49
// end ;
2892: GO 2800
2894: POP
2895: POP
// russian_guard := tmp ;
2896: LD_ADDR_EXP 50
2900: PUSH
2901: LD_VAR 0 4
2905: ST_TO_ADDR
// end ;
2906: LD_VAR 0 1
2910: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2911: LD_INT 47
2913: PPUSH
2914: CALL_OW 302
2918: PUSH
2919: LD_EXP 6
2923: AND
2924: IFFALSE 3526
2926: GO 2928
2928: DISABLE
2929: LD_INT 0
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
2935: PPUSH
2936: PPUSH
// begin enable ;
2937: ENABLE
// base := 2 ;
2938: LD_ADDR_VAR 0 2
2942: PUSH
2943: LD_INT 2
2945: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2946: LD_ADDR_VAR 0 4
2950: PUSH
2951: LD_INT 0
2953: PUSH
2954: LD_INT 0
2956: PUSH
2957: LD_INT 0
2959: PUSH
2960: LD_INT 0
2962: PUSH
2963: LD_INT 0
2965: PUSH
2966: LD_INT 0
2968: PUSH
2969: LD_INT 0
2971: PUSH
2972: LD_INT 0
2974: PUSH
2975: LD_INT 1
2977: PUSH
2978: LD_INT 0
2980: PUSH
2981: EMPTY
2982: LIST
2983: LIST
2984: LIST
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2993: LD_ADDR_VAR 0 3
2997: PUSH
2998: LD_INT 22
3000: PUSH
3001: LD_INT 1
3003: PUSH
3004: LD_INT 3
3006: PUSH
3007: LD_INT 45
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_INT 21
3018: PUSH
3019: LD_INT 1
3021: PUSH
3022: LD_INT 3
3024: PUSH
3025: LD_INT 45
3027: PUSH
3028: EMPTY
3029: LIST
3030: LIST
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 22
3036: PUSH
3037: LD_INT 1
3039: PUSH
3040: LD_INT 3
3042: PUSH
3043: LD_INT 45
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: LD_INT 23
3054: PUSH
3055: LD_INT 1
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 46
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3076: LD_ADDR_VAR 0 1
3080: PUSH
3081: DOUBLE
3082: LD_INT 1
3084: DEC
3085: ST_TO_ADDR
3086: LD_OWVAR 67
3090: PUSH
3091: LD_OWVAR 1
3095: PUSH
3096: LD_INT 21000
3098: DIV
3099: PLUS
3100: PUSH
3101: FOR_TO
3102: IFFALSE 3190
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3104: LD_ADDR_VAR 0 3
3108: PUSH
3109: LD_VAR 0 3
3113: PPUSH
3114: LD_VAR 0 3
3118: PUSH
3119: LD_INT 1
3121: PLUS
3122: PPUSH
3123: LD_INT 23
3125: PUSH
3126: LD_INT 24
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PUSH
3133: LD_INT 1
3135: PPUSH
3136: LD_INT 2
3138: PPUSH
3139: CALL_OW 12
3143: ARRAY
3144: PUSH
3145: LD_INT 1
3147: PUSH
3148: LD_INT 3
3150: PUSH
3151: LD_INT 46
3153: PUSH
3154: LD_INT 47
3156: PUSH
3157: LD_INT 45
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: PUSH
3165: LD_INT 1
3167: PPUSH
3168: LD_INT 3
3170: PPUSH
3171: CALL_OW 12
3175: ARRAY
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 2
3187: ST_TO_ADDR
3188: GO 3101
3190: POP
3191: POP
// MC_InsertProduceList ( base , tmp ) ;
3192: LD_VAR 0 2
3196: PPUSH
3197: LD_VAR 0 3
3201: PPUSH
3202: CALL 80659 0 2
// repeat wait ( 0 0$1 ) ;
3206: LD_INT 35
3208: PPUSH
3209: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3213: LD_EXP 77
3217: PUSH
3218: LD_VAR 0 2
3222: ARRAY
3223: PUSH
3224: LD_INT 6
3226: GREATER
3227: IFFALSE 3206
// wait ( 0 0$20 ) ;
3229: LD_INT 700
3231: PPUSH
3232: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3236: LD_ADDR_VAR 0 5
3240: PUSH
3241: LD_INT 71
3243: PUSH
3244: LD_INT 19
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PUSH
3251: LD_INT 91
3253: PUSH
3254: LD_INT 67
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 52
3263: PUSH
3264: LD_INT 44
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PUSH
3271: LD_INT 68
3273: PUSH
3274: LD_INT 48
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3287: LD_ADDR_VAR 0 6
3291: PUSH
3292: LD_EXP 77
3296: PUSH
3297: LD_VAR 0 2
3301: ARRAY
3302: PUSH
3303: LD_EXP 77
3307: PUSH
3308: LD_VAR 0 2
3312: ARRAY
3313: PPUSH
3314: LD_INT 2
3316: PUSH
3317: LD_INT 34
3319: PUSH
3320: LD_INT 51
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: PUSH
3327: LD_INT 34
3329: PUSH
3330: LD_INT 52
3332: PUSH
3333: EMPTY
3334: LIST
3335: LIST
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: PPUSH
3342: CALL_OW 72
3346: DIFF
3347: ST_TO_ADDR
// if not attackers then
3348: LD_VAR 0 6
3352: NOT
3353: IFFALSE 3357
// exit ;
3355: GO 3526
// ru_attackers := attackers ;
3357: LD_ADDR_EXP 51
3361: PUSH
3362: LD_VAR 0 6
3366: ST_TO_ADDR
// for i = 1 to attackers do
3367: LD_ADDR_VAR 0 1
3371: PUSH
3372: DOUBLE
3373: LD_INT 1
3375: DEC
3376: ST_TO_ADDR
3377: LD_VAR 0 6
3381: PUSH
3382: FOR_TO
3383: IFFALSE 3460
// begin case i mod 3 of 0 :
3385: LD_VAR 0 1
3389: PUSH
3390: LD_INT 3
3392: MOD
3393: PUSH
3394: LD_INT 0
3396: DOUBLE
3397: EQUAL
3398: IFTRUE 3402
3400: GO 3405
3402: POP
// ; 1 :
3403: GO 3458
3405: LD_INT 1
3407: DOUBLE
3408: EQUAL
3409: IFTRUE 3413
3411: GO 3431
3413: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3414: LD_VAR 0 1
3418: PPUSH
3419: LD_INT 32
3421: PPUSH
3422: LD_INT 49
3424: PPUSH
3425: CALL_OW 114
3429: GO 3458
3431: LD_INT 2
3433: DOUBLE
3434: EQUAL
3435: IFTRUE 3439
3437: GO 3457
3439: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3440: LD_VAR 0 1
3444: PPUSH
3445: LD_INT 117
3447: PPUSH
3448: LD_INT 107
3450: PPUSH
3451: CALL_OW 114
3455: GO 3458
3457: POP
// end ;
3458: GO 3382
3460: POP
3461: POP
// repeat wait ( 0 0$1 ) ;
3462: LD_INT 35
3464: PPUSH
3465: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3469: LD_VAR 0 6
3473: PPUSH
3474: LD_INT 60
3476: PUSH
3477: EMPTY
3478: LIST
3479: PPUSH
3480: CALL_OW 72
3484: NOT
3485: IFFALSE 3462
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3487: LD_VAR 0 2
3491: PPUSH
3492: LD_VAR 0 6
3496: PPUSH
3497: LD_VAR 0 5
3501: PPUSH
3502: LD_VAR 0 4
3506: PPUSH
3507: CALL 80844 0 4
// if not first_attack then
3511: LD_EXP 7
3515: NOT
3516: IFFALSE 3526
// first_attack := true ;
3518: LD_ADDR_EXP 7
3522: PUSH
3523: LD_INT 1
3525: ST_TO_ADDR
// end ; end_of_file
3526: PPOPN 6
3528: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3529: LD_INT 0
3531: PPUSH
3532: PPUSH
3533: PPUSH
3534: PPUSH
3535: PPUSH
3536: PPUSH
3537: PPUSH
// uc_side := 2 ;
3538: LD_ADDR_OWVAR 20
3542: PUSH
3543: LD_INT 2
3545: ST_TO_ADDR
// uc_nation := 2 ;
3546: LD_ADDR_OWVAR 21
3550: PUSH
3551: LD_INT 2
3553: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3554: LD_ADDR_EXP 54
3558: PUSH
3559: LD_STRING Abdul
3561: PPUSH
3562: CALL_OW 25
3566: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3567: LD_EXP 54
3571: PPUSH
3572: LD_INT 11
3574: PPUSH
3575: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3579: LD_EXP 54
3583: PPUSH
3584: LD_INT 1
3586: PPUSH
3587: CALL_OW 52
// vc_chassis := 31 ;
3591: LD_ADDR_OWVAR 37
3595: PUSH
3596: LD_INT 31
3598: ST_TO_ADDR
// vc_control := control_rider ;
3599: LD_ADDR_OWVAR 38
3603: PUSH
3604: LD_INT 4
3606: ST_TO_ADDR
// mastodont := CreateVehicle ;
3607: LD_ADDR_EXP 55
3611: PUSH
3612: CALL_OW 45
3616: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3617: LD_EXP 55
3621: PPUSH
3622: LD_INT 153
3624: PPUSH
3625: LD_INT 71
3627: PPUSH
3628: LD_INT 0
3630: PPUSH
3631: CALL_OW 48
// InitVc ;
3635: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3639: LD_ADDR_EXP 52
3643: PUSH
3644: LD_INT 1
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_STRING 
3652: PPUSH
3653: LD_INT 7
3655: PUSH
3656: LD_INT 8
3658: PUSH
3659: LD_INT 9
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: LIST
3666: PUSH
3667: LD_OWVAR 67
3671: ARRAY
3672: PPUSH
3673: LD_INT 5000
3675: PUSH
3676: LD_INT 1000
3678: PUSH
3679: LD_INT 300
3681: PUSH
3682: EMPTY
3683: LIST
3684: LIST
3685: LIST
3686: PPUSH
3687: LD_INT 22
3689: PUSH
3690: LD_INT 5
3692: PUSH
3693: LD_INT 6
3695: PUSH
3696: LD_INT 9
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: LIST
3703: LIST
3704: PPUSH
3705: CALL 24438 0 6
3709: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3710: LD_ADDR_EXP 58
3714: PUSH
3715: LD_EXP 58
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_EXP 52
3727: PPUSH
3728: CALL_OW 1
3732: ST_TO_ADDR
// tmp := [ ] ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: EMPTY
3739: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3740: LD_ADDR_OWVAR 37
3744: PUSH
3745: LD_INT 14
3747: ST_TO_ADDR
// vc_engine := engine_siberite ;
3748: LD_ADDR_OWVAR 39
3752: PUSH
3753: LD_INT 3
3755: ST_TO_ADDR
// vc_control := control_manual ;
3756: LD_ADDR_OWVAR 38
3760: PUSH
3761: LD_INT 1
3763: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3764: LD_ADDR_OWVAR 40
3768: PUSH
3769: LD_INT 31
3771: ST_TO_ADDR
// for i = 1 to 3 do
3772: LD_ADDR_VAR 0 2
3776: PUSH
3777: DOUBLE
3778: LD_INT 1
3780: DEC
3781: ST_TO_ADDR
3782: LD_INT 3
3784: PUSH
3785: FOR_TO
3786: IFFALSE 4030
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3788: LD_ADDR_VAR 0 5
3792: PUSH
3793: LD_INT 153
3795: PUSH
3796: LD_INT 71
3798: PUSH
3799: EMPTY
3800: LIST
3801: LIST
3802: PUSH
3803: LD_INT 155
3805: PUSH
3806: LD_INT 81
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: PUSH
3817: LD_VAR 0 2
3821: PUSH
3822: LD_INT 2
3824: MOD
3825: PUSH
3826: LD_INT 1
3828: PLUS
3829: ARRAY
3830: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3831: LD_INT 0
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: LD_INT 7
3839: PUSH
3840: LD_INT 8
3842: PUSH
3843: LD_INT 9
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_OWVAR 67
3855: ARRAY
3856: PPUSH
3857: CALL_OW 380
// un := CreateVehicle ;
3861: LD_ADDR_VAR 0 6
3865: PUSH
3866: CALL_OW 45
3870: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3871: LD_VAR 0 6
3875: PPUSH
3876: LD_INT 0
3878: PPUSH
3879: LD_INT 5
3881: PPUSH
3882: CALL_OW 12
3886: PPUSH
3887: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3891: LD_VAR 0 6
3895: PPUSH
3896: LD_VAR 0 5
3900: PUSH
3901: LD_INT 1
3903: ARRAY
3904: PPUSH
3905: LD_VAR 0 5
3909: PUSH
3910: LD_INT 2
3912: ARRAY
3913: PPUSH
3914: LD_INT 6
3916: PPUSH
3917: LD_INT 0
3919: PPUSH
3920: CALL_OW 50
// un2 := CreateHuman ;
3924: LD_ADDR_VAR 0 7
3928: PUSH
3929: CALL_OW 44
3933: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3934: LD_VAR 0 7
3938: PPUSH
3939: LD_VAR 0 6
3943: PPUSH
3944: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3948: LD_ADDR_EXP 58
3952: PUSH
3953: LD_EXP 58
3957: PPUSH
3958: LD_INT 1
3960: PUSH
3961: LD_EXP 58
3965: PUSH
3966: LD_INT 1
3968: ARRAY
3969: PUSH
3970: LD_INT 1
3972: PLUS
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PPUSH
3978: LD_VAR 0 6
3982: PPUSH
3983: CALL 21151 0 3
3987: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3988: LD_ADDR_EXP 58
3992: PUSH
3993: LD_EXP 58
3997: PPUSH
3998: LD_INT 1
4000: PUSH
4001: LD_EXP 58
4005: PUSH
4006: LD_INT 1
4008: ARRAY
4009: PUSH
4010: LD_INT 1
4012: PLUS
4013: PUSH
4014: EMPTY
4015: LIST
4016: LIST
4017: PPUSH
4018: LD_VAR 0 7
4022: PPUSH
4023: CALL 21151 0 3
4027: ST_TO_ADDR
// end ;
4028: GO 3785
4030: POP
4031: POP
// for i = 1 to 5 do
4032: LD_ADDR_VAR 0 2
4036: PUSH
4037: DOUBLE
4038: LD_INT 1
4040: DEC
4041: ST_TO_ADDR
4042: LD_INT 5
4044: PUSH
4045: FOR_TO
4046: IFFALSE 4139
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4048: LD_INT 14
4050: PPUSH
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 1
4056: PPUSH
4057: LD_INT 25
4059: PUSH
4060: LD_INT 28
4062: PUSH
4063: LD_INT 28
4065: PUSH
4066: LD_INT 26
4068: PUSH
4069: EMPTY
4070: LIST
4071: LIST
4072: LIST
4073: LIST
4074: PUSH
4075: LD_VAR 0 2
4079: PUSH
4080: LD_INT 4
4082: MOD
4083: PUSH
4084: LD_INT 1
4086: PLUS
4087: ARRAY
4088: PPUSH
4089: LD_INT 100
4091: PPUSH
4092: CALL 21029 0 5
// veh := CreateVehicle ;
4096: LD_ADDR_VAR 0 3
4100: PUSH
4101: CALL_OW 45
4105: ST_TO_ADDR
// tmp := tmp ^ veh ;
4106: LD_ADDR_VAR 0 4
4110: PUSH
4111: LD_VAR 0 4
4115: PUSH
4116: LD_VAR 0 3
4120: ADD
4121: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4122: LD_VAR 0 3
4126: PPUSH
4127: LD_INT 1
4129: PPUSH
4130: LD_INT 0
4132: PPUSH
4133: CALL_OW 49
// end ;
4137: GO 4045
4139: POP
4140: POP
// arabian_guard := tmp ;
4141: LD_ADDR_EXP 53
4145: PUSH
4146: LD_VAR 0 4
4150: ST_TO_ADDR
// end ;
4151: LD_VAR 0 1
4155: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4156: LD_INT 22
4158: PUSH
4159: LD_INT 7
4161: PUSH
4162: EMPTY
4163: LIST
4164: LIST
4165: PUSH
4166: LD_INT 91
4168: PUSH
4169: LD_INT 1
4171: PUSH
4172: LD_INT 12
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: PUSH
4180: EMPTY
4181: LIST
4182: LIST
4183: PPUSH
4184: CALL_OW 69
4188: PUSH
4189: LD_EXP 55
4193: PPUSH
4194: CALL_OW 256
4198: PUSH
4199: LD_INT 990
4201: LESS
4202: OR
4203: PUSH
4204: LD_EXP 54
4208: PPUSH
4209: CALL_OW 256
4213: PUSH
4214: LD_INT 990
4216: LESS
4217: OR
4218: IFFALSE 4361
4220: GO 4222
4222: DISABLE
// begin if IsInUnit ( Abdul ) then
4223: LD_EXP 54
4227: PPUSH
4228: CALL_OW 310
4232: IFFALSE 4243
// ComExitBuilding ( Abdul ) ;
4234: LD_EXP 54
4238: PPUSH
4239: CALL_OW 122
// if Mastodont then
4243: LD_EXP 55
4247: IFFALSE 4264
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4249: LD_EXP 55
4253: PPUSH
4254: LD_INT 205
4256: PPUSH
4257: LD_INT 132
4259: PPUSH
4260: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4264: LD_EXP 54
4268: PPUSH
4269: LD_INT 205
4271: PPUSH
4272: LD_INT 132
4274: PPUSH
4275: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4279: LD_INT 35
4281: PPUSH
4282: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4286: LD_EXP 54
4290: PPUSH
4291: LD_INT 21
4293: PPUSH
4294: CALL_OW 308
4298: IFFALSE 4279
// RemoveUnit ( Abdul ) ;
4300: LD_EXP 54
4304: PPUSH
4305: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4309: LD_INT 35
4311: PPUSH
4312: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4316: LD_EXP 55
4320: PPUSH
4321: LD_INT 21
4323: PPUSH
4324: CALL_OW 308
4328: PUSH
4329: LD_EXP 55
4333: PPUSH
4334: CALL_OW 301
4338: OR
4339: IFFALSE 4309
// if IsOk ( Mastodont ) then
4341: LD_EXP 55
4345: PPUSH
4346: CALL_OW 302
4350: IFFALSE 4361
// RemoveUnit ( Mastodont ) ;
4352: LD_EXP 55
4356: PPUSH
4357: CALL_OW 64
// end ;
4361: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4362: LD_EXP 54
4366: PPUSH
4367: CALL_OW 301
4371: PUSH
4372: LD_INT 22
4374: PUSH
4375: LD_INT 2
4377: PUSH
4378: EMPTY
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 2
4384: PUSH
4385: LD_INT 25
4387: PUSH
4388: LD_INT 1
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 25
4397: PUSH
4398: LD_INT 2
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 25
4407: PUSH
4408: LD_INT 3
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: LD_INT 25
4417: PUSH
4418: LD_INT 4
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: PUSH
4425: LD_INT 25
4427: PUSH
4428: LD_INT 8
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: LIST
4442: PUSH
4443: EMPTY
4444: LIST
4445: LIST
4446: PPUSH
4447: CALL_OW 69
4451: PUSH
4452: LD_INT 16
4454: PUSH
4455: LD_INT 19
4457: PUSH
4458: LD_INT 22
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: LIST
4465: PUSH
4466: LD_OWVAR 67
4470: ARRAY
4471: LESS
4472: OR
4473: IFFALSE 5146
4475: GO 4477
4477: DISABLE
4478: LD_INT 0
4480: PPUSH
4481: PPUSH
4482: PPUSH
4483: PPUSH
4484: PPUSH
4485: PPUSH
// begin MC_Kill ( 1 ) ;
4486: LD_INT 1
4488: PPUSH
4489: CALL 57311 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4493: LD_ADDR_VAR 0 2
4497: PUSH
4498: LD_INT 22
4500: PUSH
4501: LD_INT 2
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 2
4510: PUSH
4511: LD_INT 25
4513: PUSH
4514: LD_INT 1
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: LD_INT 25
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: LD_INT 25
4533: PUSH
4534: LD_INT 3
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PUSH
4541: LD_INT 25
4543: PUSH
4544: LD_INT 4
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PUSH
4551: LD_INT 25
4553: PUSH
4554: LD_INT 8
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: PUSH
4561: EMPTY
4562: LIST
4563: LIST
4564: LIST
4565: LIST
4566: LIST
4567: LIST
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: PPUSH
4573: CALL_OW 69
4577: ST_TO_ADDR
// for i in tmp do
4578: LD_ADDR_VAR 0 5
4582: PUSH
4583: LD_VAR 0 2
4587: PUSH
4588: FOR_IN
4589: IFFALSE 4605
// SetTag ( i , 10 ) ;
4591: LD_VAR 0 5
4595: PPUSH
4596: LD_INT 10
4598: PPUSH
4599: CALL_OW 109
4603: GO 4588
4605: POP
4606: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4607: LD_ADDR_VAR 0 3
4611: PUSH
4612: LD_INT 22
4614: PUSH
4615: LD_INT 2
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: PUSH
4622: LD_INT 21
4624: PUSH
4625: LD_INT 1
4627: PUSH
4628: EMPTY
4629: LIST
4630: LIST
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PPUSH
4636: CALL_OW 69
4640: PUSH
4641: LD_VAR 0 2
4645: DIFF
4646: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4647: LD_ADDR_VAR 0 1
4651: PUSH
4652: LD_INT 22
4654: PUSH
4655: LD_INT 2
4657: PUSH
4658: EMPTY
4659: LIST
4660: LIST
4661: PUSH
4662: LD_INT 21
4664: PUSH
4665: LD_INT 2
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 24
4674: PUSH
4675: LD_INT 300
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: LIST
4686: PPUSH
4687: CALL_OW 69
4691: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4692: LD_ADDR_VAR 0 4
4696: PUSH
4697: LD_VAR 0 1
4701: PPUSH
4702: LD_INT 33
4704: PUSH
4705: LD_INT 1
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 58
4714: PUSH
4715: EMPTY
4716: LIST
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 72
4726: ST_TO_ADDR
// for i in tmp do
4727: LD_ADDR_VAR 0 5
4731: PUSH
4732: LD_VAR 0 2
4736: PUSH
4737: FOR_IN
4738: IFFALSE 4922
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4740: LD_VAR 0 5
4744: PUSH
4745: LD_INT 55
4747: PUSH
4748: EMPTY
4749: LIST
4750: PPUSH
4751: CALL_OW 69
4755: IN
4756: IFFALSE 4775
// begin AddComMoveXY ( i , 209 , 132 ) ;
4758: LD_VAR 0 5
4762: PPUSH
4763: LD_INT 209
4765: PPUSH
4766: LD_INT 132
4768: PPUSH
4769: CALL_OW 171
// continue ;
4773: GO 4737
// end ; if IsInUnit ( i ) then
4775: LD_VAR 0 5
4779: PPUSH
4780: CALL_OW 310
4784: IFFALSE 4802
// begin ComExitBuilding ( i ) ;
4786: LD_VAR 0 5
4790: PPUSH
4791: CALL_OW 122
// wait ( 3 ) ;
4795: LD_INT 3
4797: PPUSH
4798: CALL_OW 67
// end ; if tmp_empty then
4802: LD_VAR 0 4
4806: IFFALSE 4905
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4808: LD_VAR 0 5
4812: PPUSH
4813: LD_VAR 0 4
4817: PPUSH
4818: LD_VAR 0 5
4822: PPUSH
4823: CALL_OW 74
4827: PPUSH
4828: CALL_OW 296
4832: PUSH
4833: LD_INT 25
4835: LESS
4836: IFFALSE 4905
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4838: LD_ADDR_VAR 0 6
4842: PUSH
4843: LD_VAR 0 4
4847: PPUSH
4848: LD_VAR 0 5
4852: PPUSH
4853: CALL_OW 74
4857: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4858: LD_VAR 0 5
4862: PPUSH
4863: LD_VAR 0 6
4867: PPUSH
4868: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4872: LD_VAR 0 5
4876: PPUSH
4877: LD_INT 209
4879: PPUSH
4880: LD_INT 132
4882: PPUSH
4883: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4887: LD_ADDR_VAR 0 4
4891: PUSH
4892: LD_VAR 0 4
4896: PUSH
4897: LD_VAR 0 6
4901: DIFF
4902: ST_TO_ADDR
// continue ;
4903: GO 4737
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4905: LD_VAR 0 5
4909: PPUSH
4910: LD_INT 201
4912: PPUSH
4913: LD_INT 132
4915: PPUSH
4916: CALL_OW 171
// end ;
4920: GO 4737
4922: POP
4923: POP
// for i in tmp_ape do
4924: LD_ADDR_VAR 0 5
4928: PUSH
4929: LD_VAR 0 3
4933: PUSH
4934: FOR_IN
4935: IFFALSE 4974
// begin if IsInUnit ( i ) then
4937: LD_VAR 0 5
4941: PPUSH
4942: CALL_OW 310
4946: IFFALSE 4957
// ComExitBuilding ( i ) ;
4948: LD_VAR 0 5
4952: PPUSH
4953: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4957: LD_VAR 0 5
4961: PPUSH
4962: LD_INT 201
4964: PPUSH
4965: LD_INT 132
4967: PPUSH
4968: CALL_OW 171
// end ;
4972: GO 4934
4974: POP
4975: POP
// repeat wait ( 0 0$1 ) ;
4976: LD_INT 35
4978: PPUSH
4979: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4983: LD_ADDR_VAR 0 5
4987: PUSH
4988: LD_VAR 0 2
4992: PUSH
4993: LD_VAR 0 3
4997: UNION
4998: PUSH
4999: LD_VAR 0 1
5003: UNION
5004: PUSH
5005: FOR_IN
5006: IFFALSE 5037
// if not HasTask ( i ) then
5008: LD_VAR 0 5
5012: PPUSH
5013: CALL_OW 314
5017: NOT
5018: IFFALSE 5035
// ComMoveXY ( i , 201 , 132 ) ;
5020: LD_VAR 0 5
5024: PPUSH
5025: LD_INT 201
5027: PPUSH
5028: LD_INT 132
5030: PPUSH
5031: CALL_OW 111
5035: GO 5005
5037: POP
5038: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5039: LD_INT 21
5041: PPUSH
5042: LD_INT 22
5044: PUSH
5045: LD_INT 2
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PPUSH
5052: CALL_OW 70
5056: IFFALSE 5097
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5058: LD_ADDR_VAR 0 5
5062: PUSH
5063: LD_INT 21
5065: PPUSH
5066: LD_INT 22
5068: PUSH
5069: LD_INT 2
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 70
5080: PUSH
5081: FOR_IN
5082: IFFALSE 5095
// RemoveUnit ( i ) ;
5084: LD_VAR 0 5
5088: PPUSH
5089: CALL_OW 64
5093: GO 5081
5095: POP
5096: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5097: LD_INT 22
5099: PUSH
5100: LD_INT 2
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 2
5109: PUSH
5110: LD_INT 21
5112: PUSH
5113: LD_INT 1
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PUSH
5120: LD_INT 21
5122: PUSH
5123: LD_INT 2
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: LIST
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PPUSH
5139: CALL_OW 69
5143: NOT
5144: IFFALSE 4976
// end ;
5146: PPOPN 6
5148: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5149: LD_EXP 9
5153: PUSH
5154: LD_INT 92
5156: PPUSH
5157: LD_INT 40
5159: PPUSH
5160: CALL_OW 428
5164: PPUSH
5165: CALL_OW 266
5169: PUSH
5170: LD_INT 30
5172: EQUAL
5173: AND
5174: IFFALSE 5370
5176: GO 5178
5178: DISABLE
5179: LD_INT 0
5181: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5182: LD_ADDR_VAR 0 1
5186: PUSH
5187: LD_EXP 58
5191: PUSH
5192: LD_INT 1
5194: ARRAY
5195: PPUSH
5196: LD_INT 25
5198: PUSH
5199: LD_INT 4
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: PPUSH
5206: CALL_OW 72
5210: ST_TO_ADDR
// if not sci then
5211: LD_VAR 0 1
5215: NOT
5216: IFFALSE 5220
// exit ;
5218: GO 5370
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5220: LD_ADDR_EXP 58
5224: PUSH
5225: LD_EXP 58
5229: PPUSH
5230: LD_INT 1
5232: PPUSH
5233: LD_EXP 58
5237: PUSH
5238: LD_INT 1
5240: ARRAY
5241: PUSH
5242: LD_VAR 0 1
5246: PUSH
5247: LD_INT 1
5249: ARRAY
5250: DIFF
5251: PPUSH
5252: CALL_OW 1
5256: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5257: LD_VAR 0 1
5261: PUSH
5262: LD_INT 1
5264: ARRAY
5265: PPUSH
5266: CALL_OW 310
5270: IFFALSE 5285
// ComExitBuilding ( sci [ 1 ] ) ;
5272: LD_VAR 0 1
5276: PUSH
5277: LD_INT 1
5279: ARRAY
5280: PPUSH
5281: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5285: LD_INT 2
5287: PPUSH
5288: LD_INT 105
5290: PPUSH
5291: LD_INT 14
5293: PPUSH
5294: LD_INT 20
5296: PPUSH
5297: CALL 22047 0 4
5301: PUSH
5302: LD_INT 4
5304: ARRAY
5305: PUSH
5306: LD_INT 10
5308: LESS
5309: IFFALSE 5332
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5311: LD_VAR 0 1
5315: PUSH
5316: LD_INT 1
5318: ARRAY
5319: PPUSH
5320: LD_INT 105
5322: PPUSH
5323: LD_INT 14
5325: PPUSH
5326: CALL_OW 171
5330: GO 5351
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5332: LD_VAR 0 1
5336: PUSH
5337: LD_INT 1
5339: ARRAY
5340: PPUSH
5341: LD_INT 118
5343: PPUSH
5344: LD_INT 77
5346: PPUSH
5347: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5351: LD_VAR 0 1
5355: PUSH
5356: LD_INT 1
5358: ARRAY
5359: PPUSH
5360: LD_INT 92
5362: PPUSH
5363: LD_INT 40
5365: PPUSH
5366: CALL_OW 218
// end ;
5370: PPOPN 1
5372: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5373: LD_INT 1
5375: PPUSH
5376: CALL_OW 302
5380: PUSH
5381: LD_EXP 9
5385: AND
5386: IFFALSE 5845
5388: GO 5390
5390: DISABLE
5391: LD_INT 0
5393: PPUSH
5394: PPUSH
5395: PPUSH
5396: PPUSH
5397: PPUSH
5398: PPUSH
// begin enable ;
5399: ENABLE
// base := 1 ;
5400: LD_ADDR_VAR 0 2
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5408: LD_ADDR_VAR 0 4
5412: PUSH
5413: LD_INT 0
5415: PUSH
5416: LD_INT 0
5418: PUSH
5419: LD_INT 0
5421: PUSH
5422: LD_INT 0
5424: PUSH
5425: LD_INT 0
5427: PUSH
5428: LD_INT 0
5430: PUSH
5431: LD_INT 0
5433: PUSH
5434: LD_INT 0
5436: PUSH
5437: LD_INT 1
5439: PUSH
5440: LD_INT 0
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: LIST
5447: LIST
5448: LIST
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: LIST
5454: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5455: LD_ADDR_VAR 0 3
5459: PUSH
5460: LD_INT 14
5462: PUSH
5463: LD_INT 1
5465: PUSH
5466: LD_INT 2
5468: PUSH
5469: LD_INT 26
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: LIST
5476: LIST
5477: PUSH
5478: LD_INT 14
5480: PUSH
5481: LD_INT 1
5483: PUSH
5484: LD_INT 2
5486: PUSH
5487: LD_INT 28
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_INT 13
5498: PUSH
5499: LD_INT 1
5501: PUSH
5502: LD_INT 2
5504: PUSH
5505: LD_INT 29
5507: PUSH
5508: EMPTY
5509: LIST
5510: LIST
5511: LIST
5512: LIST
5513: PUSH
5514: EMPTY
5515: LIST
5516: LIST
5517: LIST
5518: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5519: LD_ADDR_VAR 0 1
5523: PUSH
5524: DOUBLE
5525: LD_INT 1
5527: DEC
5528: ST_TO_ADDR
5529: LD_OWVAR 67
5533: PUSH
5534: LD_OWVAR 1
5538: PUSH
5539: LD_INT 21000
5541: DIV
5542: PLUS
5543: PUSH
5544: FOR_TO
5545: IFFALSE 5637
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5547: LD_ADDR_VAR 0 3
5551: PUSH
5552: LD_VAR 0 3
5556: PPUSH
5557: LD_VAR 0 3
5561: PUSH
5562: LD_INT 1
5564: PLUS
5565: PPUSH
5566: LD_INT 13
5568: PUSH
5569: LD_INT 14
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: PUSH
5576: LD_INT 1
5578: PPUSH
5579: LD_INT 2
5581: PPUSH
5582: CALL_OW 12
5586: ARRAY
5587: PUSH
5588: LD_INT 1
5590: PUSH
5591: LD_INT 2
5593: PUSH
5594: LD_INT 28
5596: PUSH
5597: LD_INT 29
5599: PUSH
5600: LD_INT 25
5602: PUSH
5603: LD_INT 26
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: PUSH
5612: LD_INT 1
5614: PPUSH
5615: LD_INT 4
5617: PPUSH
5618: CALL_OW 12
5622: ARRAY
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: LIST
5628: LIST
5629: PPUSH
5630: CALL_OW 2
5634: ST_TO_ADDR
5635: GO 5544
5637: POP
5638: POP
// MC_InsertProduceList ( base , tmp ) ;
5639: LD_VAR 0 2
5643: PPUSH
5644: LD_VAR 0 3
5648: PPUSH
5649: CALL 80659 0 2
// repeat wait ( 0 0$1 ) ;
5653: LD_INT 35
5655: PPUSH
5656: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5660: LD_EXP 77
5664: PUSH
5665: LD_VAR 0 2
5669: ARRAY
5670: PUSH
5671: LD_INT 6
5673: GREATER
5674: IFFALSE 5653
// wait ( 0 0$20 ) ;
5676: LD_INT 700
5678: PPUSH
5679: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5683: LD_ADDR_VAR 0 5
5687: PUSH
5688: LD_INT 124
5690: PUSH
5691: LD_INT 85
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: LD_INT 90
5700: PUSH
5701: LD_INT 61
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 69
5710: PUSH
5711: LD_INT 48
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 68
5720: PUSH
5721: LD_INT 48
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5734: LD_ADDR_VAR 0 6
5738: PUSH
5739: LD_EXP 77
5743: PUSH
5744: LD_VAR 0 2
5748: ARRAY
5749: PUSH
5750: LD_EXP 77
5754: PUSH
5755: LD_VAR 0 2
5759: ARRAY
5760: PPUSH
5761: LD_INT 34
5763: PUSH
5764: LD_INT 32
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PPUSH
5771: CALL_OW 72
5775: DIFF
5776: ST_TO_ADDR
// if not attackers then
5777: LD_VAR 0 6
5781: NOT
5782: IFFALSE 5786
// exit ;
5784: GO 5845
// ar_attackers := attackers ;
5786: LD_ADDR_EXP 10
5790: PUSH
5791: LD_VAR 0 6
5795: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5796: LD_INT 35
5798: PPUSH
5799: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5803: LD_VAR 0 6
5807: PPUSH
5808: LD_INT 60
5810: PUSH
5811: EMPTY
5812: LIST
5813: PPUSH
5814: CALL_OW 72
5818: NOT
5819: IFFALSE 5796
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5821: LD_VAR 0 2
5825: PPUSH
5826: LD_VAR 0 6
5830: PPUSH
5831: LD_VAR 0 5
5835: PPUSH
5836: LD_VAR 0 4
5840: PPUSH
5841: CALL 80844 0 4
// end ;
5845: PPOPN 6
5847: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5848: LD_INT 1
5850: PPUSH
5851: CALL_OW 302
5855: PUSH
5856: LD_EXP 9
5860: AND
5861: PUSH
5862: LD_EXP 48
5866: PPUSH
5867: LD_INT 22
5869: PPUSH
5870: CALL_OW 308
5874: AND
5875: PUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 81007 0 1
5883: PUSH
5884: LD_INT 0
5886: EQUAL
5887: AND
5888: PUSH
5889: LD_EXP 10
5893: NOT
5894: AND
5895: IFFALSE 6359
5897: GO 5899
5899: DISABLE
5900: LD_INT 0
5902: PPUSH
5903: PPUSH
5904: PPUSH
5905: PPUSH
5906: PPUSH
5907: PPUSH
5908: PPUSH
// begin base := 1 ;
5909: LD_ADDR_VAR 0 2
5913: PUSH
5914: LD_INT 1
5916: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5917: LD_ADDR_VAR 0 4
5921: PUSH
5922: LD_INT 0
5924: PUSH
5925: LD_INT 0
5927: PUSH
5928: LD_INT 0
5930: PUSH
5931: LD_INT 0
5933: PUSH
5934: LD_INT 0
5936: PUSH
5937: LD_INT 0
5939: PUSH
5940: LD_INT 0
5942: PUSH
5943: LD_INT 0
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 0
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: LIST
5961: LIST
5962: LIST
5963: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5964: LD_ADDR_VAR 0 3
5968: PUSH
5969: LD_INT 13
5971: PUSH
5972: LD_INT 1
5974: PUSH
5975: LD_INT 2
5977: PUSH
5978: LD_INT 28
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: PUSH
5987: LD_INT 13
5989: PUSH
5990: LD_INT 1
5992: PUSH
5993: LD_INT 2
5995: PUSH
5996: LD_INT 27
5998: PUSH
5999: EMPTY
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: PUSH
6005: LD_INT 13
6007: PUSH
6008: LD_INT 1
6010: PUSH
6011: LD_INT 2
6013: PUSH
6014: LD_INT 25
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 11
6025: PUSH
6026: LD_INT 2
6028: PUSH
6029: LD_INT 2
6031: PUSH
6032: LD_INT 24
6034: PUSH
6035: EMPTY
6036: LIST
6037: LIST
6038: LIST
6039: LIST
6040: PUSH
6041: LD_INT 11
6043: PUSH
6044: LD_INT 2
6046: PUSH
6047: LD_INT 2
6049: PUSH
6050: LD_INT 24
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6066: LD_VAR 0 2
6070: PPUSH
6071: LD_VAR 0 3
6075: PPUSH
6076: CALL 80659 0 2
// repeat wait ( 0 0$1 ) ;
6080: LD_INT 35
6082: PPUSH
6083: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6087: LD_EXP 77
6091: PUSH
6092: LD_VAR 0 2
6096: ARRAY
6097: PUSH
6098: LD_INT 6
6100: GREATEREQUAL
6101: IFFALSE 6080
// wait ( 0 0$20 ) ;
6103: LD_INT 700
6105: PPUSH
6106: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6110: LD_ADDR_VAR 0 5
6114: PUSH
6115: LD_INT 119
6117: PUSH
6118: LD_INT 9
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: PUSH
6125: EMPTY
6126: LIST
6127: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6128: LD_ADDR_VAR 0 6
6132: PUSH
6133: LD_EXP 77
6137: PUSH
6138: LD_VAR 0 2
6142: ARRAY
6143: PUSH
6144: LD_EXP 77
6148: PUSH
6149: LD_VAR 0 2
6153: ARRAY
6154: PPUSH
6155: LD_INT 34
6157: PUSH
6158: LD_INT 32
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PPUSH
6165: CALL_OW 72
6169: DIFF
6170: ST_TO_ADDR
// if not attackers then
6171: LD_VAR 0 6
6175: NOT
6176: IFFALSE 6180
// exit ;
6178: GO 6359
// uc_side := 2 ;
6180: LD_ADDR_OWVAR 20
6184: PUSH
6185: LD_INT 2
6187: ST_TO_ADDR
// uc_nation := 2 ;
6188: LD_ADDR_OWVAR 21
6192: PUSH
6193: LD_INT 2
6195: ST_TO_ADDR
// InitHc ;
6196: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6200: LD_ADDR_VAR 0 1
6204: PUSH
6205: DOUBLE
6206: LD_INT 1
6208: DEC
6209: ST_TO_ADDR
6210: LD_INT 4
6212: PUSH
6213: LD_INT 5
6215: PUSH
6216: LD_INT 6
6218: PUSH
6219: EMPTY
6220: LIST
6221: LIST
6222: LIST
6223: PUSH
6224: LD_OWVAR 67
6228: ARRAY
6229: PUSH
6230: FOR_TO
6231: IFFALSE 6308
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6233: LD_INT 0
6235: PPUSH
6236: LD_INT 15
6238: PUSH
6239: LD_INT 17
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 1
6248: PPUSH
6249: LD_INT 2
6251: PPUSH
6252: CALL_OW 12
6256: ARRAY
6257: PPUSH
6258: LD_INT 8
6260: PPUSH
6261: CALL_OW 380
// un := CreateHuman ;
6265: LD_ADDR_VAR 0 7
6269: PUSH
6270: CALL_OW 44
6274: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6275: LD_VAR 0 7
6279: PPUSH
6280: LD_INT 23
6282: PPUSH
6283: LD_INT 0
6285: PPUSH
6286: CALL_OW 49
// attackers := attackers union un ;
6290: LD_ADDR_VAR 0 6
6294: PUSH
6295: LD_VAR 0 6
6299: PUSH
6300: LD_VAR 0 7
6304: UNION
6305: ST_TO_ADDR
// end ;
6306: GO 6230
6308: POP
6309: POP
// repeat wait ( 0 0$1 ) ;
6310: LD_INT 35
6312: PPUSH
6313: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6317: LD_VAR 0 6
6321: PPUSH
6322: LD_INT 60
6324: PUSH
6325: EMPTY
6326: LIST
6327: PPUSH
6328: CALL_OW 72
6332: NOT
6333: IFFALSE 6310
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6335: LD_VAR 0 2
6339: PPUSH
6340: LD_VAR 0 6
6344: PPUSH
6345: LD_VAR 0 5
6349: PPUSH
6350: LD_VAR 0 4
6354: PPUSH
6355: CALL 80844 0 4
// end ; end_of_file
6359: PPOPN 7
6361: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6362: LD_INT 0
6364: PPUSH
6365: PPUSH
6366: PPUSH
6367: PPUSH
// uc_side := 1 ;
6368: LD_ADDR_OWVAR 20
6372: PUSH
6373: LD_INT 1
6375: ST_TO_ADDR
// uc_nation := 1 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 1
6383: ST_TO_ADDR
// InitHc ;
6384: CALL_OW 19
// InitVc ;
6388: CALL_OW 20
// tmp := [ ] ;
6392: LD_ADDR_VAR 0 3
6396: PUSH
6397: EMPTY
6398: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6399: LD_ADDR_VAR 0 2
6403: PUSH
6404: DOUBLE
6405: LD_INT 1
6407: DEC
6408: ST_TO_ADDR
6409: LD_INT 5
6411: PUSH
6412: LD_INT 6
6414: PUSH
6415: LD_INT 6
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: LIST
6422: PUSH
6423: LD_OWVAR 67
6427: ARRAY
6428: PUSH
6429: FOR_TO
6430: IFFALSE 6567
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6432: LD_INT 2
6434: PUSH
6435: LD_INT 4
6437: PUSH
6438: LD_INT 5
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 1
6448: PPUSH
6449: LD_INT 3
6451: PPUSH
6452: CALL_OW 12
6456: ARRAY
6457: PPUSH
6458: LD_INT 1
6460: PUSH
6461: LD_INT 3
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PUSH
6468: LD_INT 1
6470: PPUSH
6471: LD_INT 2
6473: PPUSH
6474: CALL_OW 12
6478: ARRAY
6479: PPUSH
6480: LD_INT 3
6482: PPUSH
6483: LD_INT 9
6485: PUSH
6486: LD_INT 7
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: PUSH
6493: LD_INT 1
6495: PPUSH
6496: LD_INT 2
6498: PPUSH
6499: CALL_OW 12
6503: ARRAY
6504: PPUSH
6505: LD_INT 78
6507: PPUSH
6508: CALL 21029 0 5
// veh := CreateVehicle ;
6512: LD_ADDR_VAR 0 4
6516: PUSH
6517: CALL_OW 45
6521: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6522: LD_VAR 0 4
6526: PPUSH
6527: LD_INT 2
6529: PPUSH
6530: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6534: LD_VAR 0 4
6538: PPUSH
6539: LD_INT 17
6541: PPUSH
6542: LD_INT 0
6544: PPUSH
6545: CALL_OW 49
// tmp := tmp ^ veh ;
6549: LD_ADDR_VAR 0 3
6553: PUSH
6554: LD_VAR 0 3
6558: PUSH
6559: LD_VAR 0 4
6563: ADD
6564: ST_TO_ADDR
// end ;
6565: GO 6429
6567: POP
6568: POP
// if not tmp then
6569: LD_VAR 0 3
6573: NOT
6574: IFFALSE 6578
// exit ;
6576: GO 6687
// if not first_powell_attack then
6578: LD_EXP 11
6582: NOT
6583: IFFALSE 6593
// first_powell_attack := true ;
6585: LD_ADDR_EXP 11
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6593: LD_INT 70
6595: PPUSH
6596: CALL_OW 67
// for i in tmp do
6600: LD_ADDR_VAR 0 2
6604: PUSH
6605: LD_VAR 0 3
6609: PUSH
6610: FOR_IN
6611: IFFALSE 6678
// if IsOk ( i ) then
6613: LD_VAR 0 2
6617: PPUSH
6618: CALL_OW 302
6622: IFFALSE 6660
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6624: LD_VAR 0 2
6628: PPUSH
6629: LD_INT 81
6631: PUSH
6632: LD_INT 1
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PPUSH
6639: CALL_OW 69
6643: PPUSH
6644: LD_VAR 0 2
6648: PPUSH
6649: CALL_OW 74
6653: PPUSH
6654: CALL_OW 115
6658: GO 6676
// tmp := tmp diff i ;
6660: LD_ADDR_VAR 0 3
6664: PUSH
6665: LD_VAR 0 3
6669: PUSH
6670: LD_VAR 0 2
6674: DIFF
6675: ST_TO_ADDR
6676: GO 6610
6678: POP
6679: POP
// until not tmp ;
6680: LD_VAR 0 3
6684: NOT
6685: IFFALSE 6593
// end ; end_of_file
6687: LD_VAR 0 1
6691: RET
// export function Action ; var tmp , i , un ; begin
6692: LD_INT 0
6694: PPUSH
6695: PPUSH
6696: PPUSH
6697: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6698: LD_INT 68
6700: PPUSH
6701: LD_INT 39
6703: PPUSH
6704: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6708: LD_ADDR_VAR 0 2
6712: PUSH
6713: LD_INT 22
6715: PUSH
6716: LD_INT 7
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PPUSH
6723: CALL_OW 69
6727: ST_TO_ADDR
// InGameOn ;
6728: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6732: LD_VAR 0 2
6736: PPUSH
6737: LD_INT 71
6739: PPUSH
6740: LD_INT 49
6742: PPUSH
6743: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6747: LD_INT 35
6749: PPUSH
6750: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6754: LD_INT 7
6756: PPUSH
6757: LD_INT 71
6759: PPUSH
6760: LD_INT 51
6762: PPUSH
6763: CALL_OW 293
6767: IFFALSE 6747
// DialogueOn ;
6769: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6773: LD_EXP 14
6777: PPUSH
6778: LD_STRING D1-JMM-1
6780: PPUSH
6781: CALL_OW 88
// if Joan then
6785: LD_EXP 29
6789: IFFALSE 6803
// Say ( Joan , D1-Joan-1 ) ;
6791: LD_EXP 29
6795: PPUSH
6796: LD_STRING D1-Joan-1
6798: PPUSH
6799: CALL_OW 88
// if Lisa then
6803: LD_EXP 16
6807: IFFALSE 6821
// Say ( Lisa , D1-Lisa-1 ) ;
6809: LD_EXP 16
6813: PPUSH
6814: LD_STRING D1-Lisa-1
6816: PPUSH
6817: CALL_OW 88
// if Joan or Lisa then
6821: LD_EXP 29
6825: PUSH
6826: LD_EXP 16
6830: OR
6831: IFFALSE 6845
// Say ( JMM , D1-JMM-2 ) ;
6833: LD_EXP 14
6837: PPUSH
6838: LD_STRING D1-JMM-2
6840: PPUSH
6841: CALL_OW 88
// DialogueOff ;
6845: CALL_OW 7
// InGameOff ;
6849: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6853: LD_INT 71
6855: PPUSH
6856: LD_INT 50
6858: PPUSH
6859: LD_INT 7
6861: PPUSH
6862: LD_INT 30
6864: NEG
6865: PPUSH
6866: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6870: LD_INT 71
6872: PPUSH
6873: LD_INT 50
6875: PPUSH
6876: LD_INT 7
6878: PPUSH
6879: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6883: LD_STRING M1
6885: PPUSH
6886: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6890: LD_INT 35
6892: PPUSH
6893: CALL_OW 67
// until freedom ;
6897: LD_EXP 3
6901: IFFALSE 6890
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6903: LD_INT 350
6905: PPUSH
6906: LD_INT 700
6908: PPUSH
6909: CALL_OW 12
6913: PPUSH
6914: CALL_OW 67
// PrepareGossudarov ;
6918: CALL 1710 0 0
// repeat wait ( 0 0$1 ) ;
6922: LD_INT 35
6924: PPUSH
6925: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6929: LD_INT 22
6931: PUSH
6932: LD_INT 6
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: PUSH
6939: LD_INT 3
6941: PUSH
6942: LD_INT 24
6944: PUSH
6945: LD_INT 1000
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PPUSH
6960: CALL_OW 69
6964: PUSH
6965: LD_INT 7
6967: PPUSH
6968: LD_EXP 31
6972: PPUSH
6973: CALL_OW 292
6977: OR
6978: IFFALSE 6922
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6980: LD_ADDR_VAR 0 2
6984: PUSH
6985: LD_INT 22
6987: PUSH
6988: LD_INT 6
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PPUSH
6995: CALL_OW 69
6999: ST_TO_ADDR
// for i in tmp do
7000: LD_ADDR_VAR 0 3
7004: PUSH
7005: LD_VAR 0 2
7009: PUSH
7010: FOR_IN
7011: IFFALSE 7027
// SetSide ( i , 7 ) ;
7013: LD_VAR 0 3
7017: PPUSH
7018: LD_INT 7
7020: PPUSH
7021: CALL_OW 235
7025: GO 7010
7027: POP
7028: POP
// DialogueOn ;
7029: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7033: LD_EXP 14
7037: PUSH
7038: LD_EXP 15
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PPUSH
7047: LD_EXP 31
7051: PPUSH
7052: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7056: LD_EXP 31
7060: PPUSH
7061: CALL_OW 87
// if not Roth then
7065: LD_EXP 15
7069: NOT
7070: IFFALSE 7162
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7072: LD_VAR 0 2
7076: PPUSH
7077: LD_INT 3
7079: PUSH
7080: LD_INT 24
7082: PUSH
7083: LD_INT 1000
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL_OW 72
7098: IFFALSE 7112
// Say ( JMM , D2-JMM-1 ) ;
7100: LD_EXP 14
7104: PPUSH
7105: LD_STRING D2-JMM-1
7107: PPUSH
7108: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7112: LD_EXP 14
7116: PPUSH
7117: LD_STRING D2-JMM-1b
7119: PPUSH
7120: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7124: LD_EXP 31
7128: PPUSH
7129: LD_STRING D2-Gos-1
7131: PPUSH
7132: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7136: LD_EXP 14
7140: PPUSH
7141: LD_STRING D2-JMM-2
7143: PPUSH
7144: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7148: LD_EXP 31
7152: PPUSH
7153: LD_STRING D2-Gos-2
7155: PPUSH
7156: CALL_OW 88
// end else
7160: GO 7314
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7162: LD_VAR 0 2
7166: PPUSH
7167: LD_INT 3
7169: PUSH
7170: LD_INT 24
7172: PUSH
7173: LD_INT 1000
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: PPUSH
7184: CALL_OW 72
7188: IFFALSE 7214
// begin Say ( Roth , D2-Roth-2 ) ;
7190: LD_EXP 15
7194: PPUSH
7195: LD_STRING D2-Roth-2
7197: PPUSH
7198: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7202: LD_EXP 14
7206: PPUSH
7207: LD_STRING D2-JMM-1a
7209: PPUSH
7210: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7214: LD_EXP 15
7218: PPUSH
7219: LD_STRING D2-Roth-2a
7221: PPUSH
7222: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7226: LD_EXP 15
7230: PPUSH
7231: LD_STRING D2-Roth-2b
7233: PPUSH
7234: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7238: LD_EXP 14
7242: PPUSH
7243: LD_STRING D2-JMM-3
7245: PPUSH
7246: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7250: LD_VAR 0 2
7254: PPUSH
7255: LD_INT 3
7257: PUSH
7258: LD_INT 24
7260: PUSH
7261: LD_INT 1000
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: PPUSH
7272: CALL_OW 72
7276: IFFALSE 7314
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7278: LD_EXP 31
7282: PPUSH
7283: LD_STRING D2-Gos-3
7285: PPUSH
7286: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7290: LD_EXP 14
7294: PPUSH
7295: LD_STRING D2-JMM-4
7297: PPUSH
7298: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7302: LD_EXP 31
7306: PPUSH
7307: LD_STRING D2-Gos-4
7309: PPUSH
7310: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7314: LD_EXP 14
7318: PPUSH
7319: LD_STRING D2-JMM-5
7321: PPUSH
7322: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7326: LD_EXP 31
7330: PPUSH
7331: LD_STRING D2-Gos-5
7333: PPUSH
7334: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7338: LD_EXP 14
7342: PPUSH
7343: LD_STRING D2-JMM-6
7345: PPUSH
7346: CALL_OW 88
// DialogueOff ;
7350: CALL_OW 7
// wait ( 0 0$2 ) ;
7354: LD_INT 70
7356: PPUSH
7357: CALL_OW 67
// if Kirilenkova then
7361: LD_EXP 32
7365: IFFALSE 7379
// Say ( Kirilenkova , D3-Kir-1 ) ;
7367: LD_EXP 32
7371: PPUSH
7372: LD_STRING D3-Kir-1
7374: PPUSH
7375: CALL_OW 88
// gossudarov_arrive := true ;
7379: LD_ADDR_EXP 4
7383: PUSH
7384: LD_INT 1
7386: ST_TO_ADDR
// Hint ( CombinedForces ) ;
7387: LD_STRING CombinedForces
7389: PPUSH
7390: CALL_OW 339
// repeat wait ( 0 0$1 ) ;
7394: LD_INT 35
7396: PPUSH
7397: CALL_OW 67
// until ru_lab_builded ;
7401: LD_EXP 5
7405: IFFALSE 7394
// if Kirilenkova then
7407: LD_EXP 32
7411: IFFALSE 7427
// Say ( Kirilenkova , D3a-Kir-1 ) else
7413: LD_EXP 32
7417: PPUSH
7418: LD_STRING D3a-Kir-1
7420: PPUSH
7421: CALL_OW 88
7425: GO 7449
// begin un := SciRu ;
7427: LD_ADDR_VAR 0 4
7431: PUSH
7432: CALL 12534 0 0
7436: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7437: LD_VAR 0 4
7441: PPUSH
7442: LD_STRING D3a-Sci1-1
7444: PPUSH
7445: CALL_OW 88
// end ; if Kirilenkova or un then
7449: LD_EXP 32
7453: PUSH
7454: LD_VAR 0 4
7458: OR
7459: IFFALSE 7473
// Say ( JMM , D3a-JMM-1 ) ;
7461: LD_EXP 14
7465: PPUSH
7466: LD_STRING D3a-JMM-1
7468: PPUSH
7469: CALL_OW 88
// end ;
7473: LD_VAR 0 1
7477: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7478: LD_EXP 4
7482: PUSH
7483: LD_INT 22
7485: PUSH
7486: LD_INT 7
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: PUSH
7493: LD_INT 2
7495: PUSH
7496: LD_INT 25
7498: PUSH
7499: LD_INT 1
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PUSH
7506: LD_INT 25
7508: PUSH
7509: LD_INT 2
7511: PUSH
7512: EMPTY
7513: LIST
7514: LIST
7515: PUSH
7516: LD_INT 25
7518: PUSH
7519: LD_INT 3
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: LD_INT 25
7528: PUSH
7529: LD_INT 4
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: LD_INT 25
7538: PUSH
7539: LD_INT 5
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PUSH
7546: LD_INT 25
7548: PUSH
7549: LD_INT 8
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: LD_INT 25
7558: PUSH
7559: LD_INT 9
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: LIST
7570: LIST
7571: LIST
7572: LIST
7573: LIST
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PPUSH
7580: CALL_OW 69
7584: PUSH
7585: LD_INT 7
7587: LESS
7588: AND
7589: IFFALSE 7601
7591: GO 7593
7593: DISABLE
// YouLost ( TooMany ) ;
7594: LD_STRING TooMany
7596: PPUSH
7597: CALL_OW 104
7601: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7602: LD_EXP 31
7606: PPUSH
7607: CALL_OW 255
7611: PUSH
7612: LD_INT 7
7614: EQUAL
7615: IFFALSE 7815
7617: GO 7619
7619: DISABLE
7620: LD_INT 0
7622: PPUSH
7623: PPUSH
7624: PPUSH
// begin uc_side := 3 ;
7625: LD_ADDR_OWVAR 20
7629: PUSH
7630: LD_INT 3
7632: ST_TO_ADDR
// uc_nation := 3 ;
7633: LD_ADDR_OWVAR 21
7637: PUSH
7638: LD_INT 3
7640: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7641: LD_INT 21
7643: PPUSH
7644: LD_INT 3
7646: PPUSH
7647: LD_INT 3
7649: PPUSH
7650: LD_INT 42
7652: PPUSH
7653: LD_INT 100
7655: PPUSH
7656: CALL 21029 0 5
// un := CreateVehicle ;
7660: LD_ADDR_VAR 0 3
7664: PUSH
7665: CALL_OW 45
7669: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7670: LD_VAR 0 3
7674: PPUSH
7675: LD_INT 15
7677: PPUSH
7678: LD_INT 0
7680: PPUSH
7681: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7685: LD_VAR 0 3
7689: PPUSH
7690: LD_INT 67
7692: PPUSH
7693: LD_INT 45
7695: PPUSH
7696: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7700: LD_VAR 0 3
7704: PPUSH
7705: LD_INT 70
7707: PPUSH
7708: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7712: LD_VAR 0 3
7716: PPUSH
7717: LD_INT 69
7719: PPUSH
7720: LD_INT 18
7722: PPUSH
7723: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7727: LD_VAR 0 3
7731: PPUSH
7732: LD_INT 60
7734: PPUSH
7735: LD_INT 2
7737: PPUSH
7738: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7742: LD_INT 35
7744: PPUSH
7745: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7749: LD_VAR 0 3
7753: PPUSH
7754: CALL_OW 302
7758: NOT
7759: PUSH
7760: LD_VAR 0 3
7764: PPUSH
7765: LD_INT 17
7767: PPUSH
7768: CALL_OW 308
7772: OR
7773: IFFALSE 7742
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7775: LD_VAR 0 3
7779: PPUSH
7780: LD_INT 17
7782: PPUSH
7783: CALL_OW 308
7787: PUSH
7788: LD_VAR 0 3
7792: PPUSH
7793: LD_INT 60
7795: PPUSH
7796: LD_INT 2
7798: PPUSH
7799: CALL_OW 307
7803: OR
7804: IFFALSE 7815
// RemoveUnit ( un ) ;
7806: LD_VAR 0 3
7810: PPUSH
7811: CALL_OW 64
// end ;
7815: PPOPN 3
7817: END
// every 0 0$2 do var i , un , tmp ;
7818: GO 7820
7820: DISABLE
7821: LD_INT 0
7823: PPUSH
7824: PPUSH
7825: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7826: LD_INT 70
7828: PPUSH
7829: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7833: LD_ADDR_VAR 0 3
7837: PUSH
7838: LD_INT 22
7840: PUSH
7841: LD_INT 7
7843: PUSH
7844: EMPTY
7845: LIST
7846: LIST
7847: PUSH
7848: LD_INT 101
7850: PUSH
7851: LD_INT 3
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PPUSH
7862: CALL_OW 69
7866: ST_TO_ADDR
// until tmp ;
7867: LD_VAR 0 3
7871: IFFALSE 7826
// un := NearestUnitToUnit ( tmp , JMM ) ;
7873: LD_ADDR_VAR 0 2
7877: PUSH
7878: LD_VAR 0 3
7882: PPUSH
7883: LD_EXP 14
7887: PPUSH
7888: CALL_OW 74
7892: ST_TO_ADDR
// player_spotted := true ;
7893: LD_ADDR_EXP 6
7897: PUSH
7898: LD_INT 1
7900: ST_TO_ADDR
// tmp := SciRu ;
7901: LD_ADDR_VAR 0 3
7905: PUSH
7906: CALL 12534 0 0
7910: ST_TO_ADDR
// if not tmp then
7911: LD_VAR 0 3
7915: NOT
7916: IFFALSE 7928
// tmp := SolRu ;
7918: LD_ADDR_VAR 0 3
7922: PUSH
7923: CALL 12681 0 0
7927: ST_TO_ADDR
// DialogueOn ;
7928: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7932: LD_VAR 0 2
7936: PPUSH
7937: CALL_OW 250
7941: PPUSH
7942: LD_VAR 0 2
7946: PPUSH
7947: CALL_OW 251
7951: PPUSH
7952: LD_INT 7
7954: PPUSH
7955: LD_INT 8
7957: NEG
7958: PPUSH
7959: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7963: LD_VAR 0 2
7967: PPUSH
7968: CALL_OW 87
// if tmp then
7972: LD_VAR 0 3
7976: IFFALSE 7990
// Say ( tmp , D4-RSci1-1 ) ;
7978: LD_VAR 0 3
7982: PPUSH
7983: LD_STRING D4-RSci1-1
7985: PPUSH
7986: CALL_OW 88
// if Gossudarov then
7990: LD_EXP 31
7994: IFFALSE 8020
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7996: LD_EXP 31
8000: PPUSH
8001: LD_STRING D4-Gos-1
8003: PPUSH
8004: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8008: LD_EXP 14
8012: PPUSH
8013: LD_STRING D4-JMM-1
8015: PPUSH
8016: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8020: LD_VAR 0 2
8024: PPUSH
8025: CALL_OW 250
8029: PPUSH
8030: LD_VAR 0 2
8034: PPUSH
8035: CALL_OW 251
8039: PPUSH
8040: LD_INT 7
8042: PPUSH
8043: CALL_OW 331
// DialogueOff ;
8047: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8051: LD_STRING M5
8053: PPUSH
8054: CALL_OW 337
// end ;
8058: PPOPN 3
8060: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8061: LD_EXP 6
8065: IFFALSE 8654
8067: GO 8069
8069: DISABLE
8070: LD_INT 0
8072: PPUSH
8073: PPUSH
8074: PPUSH
// begin PrepareBelkov ;
8075: CALL 2000 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8079: LD_EXP 46
8083: PPUSH
8084: LD_INT 118
8086: PPUSH
8087: LD_INT 106
8089: PPUSH
8090: CALL_OW 111
// AddComHold ( Belkov ) ;
8094: LD_EXP 46
8098: PPUSH
8099: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8103: LD_INT 35
8105: PPUSH
8106: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8110: LD_EXP 46
8114: PPUSH
8115: LD_INT 118
8117: PPUSH
8118: LD_INT 106
8120: PPUSH
8121: CALL_OW 307
8125: IFFALSE 8103
// ChangeSideFog ( 4 , 7 ) ;
8127: LD_INT 4
8129: PPUSH
8130: LD_INT 7
8132: PPUSH
8133: CALL_OW 343
// if IsOk ( Belkov ) then
8137: LD_EXP 46
8141: PPUSH
8142: CALL_OW 302
8146: IFFALSE 8230
// begin InGameOn ;
8148: CALL_OW 8
// DialogueOn ;
8152: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8156: LD_EXP 46
8160: PPUSH
8161: LD_STRING D5-Bel-1
8163: PPUSH
8164: CALL_OW 94
// if Gossudarov then
8168: LD_EXP 31
8172: IFFALSE 8222
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8174: LD_EXP 31
8178: PPUSH
8179: LD_STRING D5-Gos-1
8181: PPUSH
8182: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8186: LD_EXP 14
8190: PPUSH
8191: LD_STRING D5-JMM-1
8193: PPUSH
8194: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8198: LD_EXP 31
8202: PPUSH
8203: LD_STRING D5-Gos-2
8205: PPUSH
8206: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8210: LD_EXP 14
8214: PPUSH
8215: LD_STRING D5-JMM-2
8217: PPUSH
8218: CALL_OW 88
// end ; DialogueOff ;
8222: CALL_OW 7
// InGameOff ;
8226: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8230: LD_STRING QSaveBelkov
8232: PPUSH
8233: CALL_OW 97
8237: PUSH
8238: LD_INT 1
8240: DOUBLE
8241: EQUAL
8242: IFTRUE 8246
8244: GO 8296
8246: POP
// begin DialogueOn ;
8247: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8251: LD_EXP 14
8255: PPUSH
8256: LD_STRING D5a-JMM-1
8258: PPUSH
8259: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8263: LD_EXP 46
8267: PPUSH
8268: LD_STRING D5a-Bel-1
8270: PPUSH
8271: CALL_OW 94
// DialogueOff ;
8275: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8279: LD_EXP 46
8283: PPUSH
8284: LD_INT 83
8286: PPUSH
8287: LD_INT 49
8289: PPUSH
8290: CALL_OW 111
// end ; 2 :
8294: GO 8329
8296: LD_INT 2
8298: DOUBLE
8299: EQUAL
8300: IFTRUE 8304
8302: GO 8328
8304: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8305: LD_EXP 14
8309: PPUSH
8310: LD_STRING D5a-JMM-2
8312: PPUSH
8313: CALL_OW 88
// ComHold ( Belkov ) ;
8317: LD_EXP 46
8321: PPUSH
8322: CALL_OW 140
// end ; end ;
8326: GO 8329
8328: POP
// time := 0 0$00 ;
8329: LD_ADDR_VAR 0 1
8333: PUSH
8334: LD_INT 0
8336: ST_TO_ADDR
// vehSpawned := false ;
8337: LD_ADDR_VAR 0 3
8341: PUSH
8342: LD_INT 0
8344: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8345: LD_INT 35
8347: PPUSH
8348: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8352: LD_VAR 0 1
8356: PUSH
8357: LD_INT 350
8359: PUSH
8360: LD_INT 175
8362: PUSH
8363: LD_INT 70
8365: PUSH
8366: EMPTY
8367: LIST
8368: LIST
8369: LIST
8370: PUSH
8371: LD_OWVAR 67
8375: ARRAY
8376: GREATEREQUAL
8377: PUSH
8378: LD_VAR 0 3
8382: NOT
8383: AND
8384: IFFALSE 8474
// begin vehSpawned := true ;
8386: LD_ADDR_VAR 0 3
8390: PUSH
8391: LD_INT 1
8393: ST_TO_ADDR
// uc_side := 3 ;
8394: LD_ADDR_OWVAR 20
8398: PUSH
8399: LD_INT 3
8401: ST_TO_ADDR
// uc_nation := 3 ;
8402: LD_ADDR_OWVAR 21
8406: PUSH
8407: LD_INT 3
8409: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8410: LD_INT 22
8412: PPUSH
8413: LD_INT 3
8415: PPUSH
8416: LD_INT 3
8418: PPUSH
8419: LD_INT 43
8421: PPUSH
8422: LD_INT 100
8424: PPUSH
8425: CALL 21029 0 5
// veh := CreateVehicle ;
8429: LD_ADDR_VAR 0 2
8433: PUSH
8434: CALL_OW 45
8438: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8439: LD_VAR 0 2
8443: PPUSH
8444: LD_INT 130
8446: PPUSH
8447: LD_INT 131
8449: PPUSH
8450: LD_INT 0
8452: PPUSH
8453: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8457: LD_VAR 0 2
8461: PPUSH
8462: LD_INT 100
8464: PPUSH
8465: LD_INT 82
8467: PPUSH
8468: CALL_OW 114
// end else
8472: GO 8488
// time := time + 0 0$1 ;
8474: LD_ADDR_VAR 0 1
8478: PUSH
8479: LD_VAR 0 1
8483: PUSH
8484: LD_INT 35
8486: PLUS
8487: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8488: LD_EXP 46
8492: PPUSH
8493: CALL_OW 301
8497: PUSH
8498: LD_EXP 46
8502: PPUSH
8503: CALL_OW 255
8507: PUSH
8508: LD_INT 4
8510: EQUAL
8511: AND
8512: PUSH
8513: LD_INT 22
8515: PUSH
8516: LD_INT 7
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: PPUSH
8523: CALL_OW 69
8527: PPUSH
8528: LD_EXP 46
8532: PPUSH
8533: CALL_OW 74
8537: PPUSH
8538: LD_EXP 46
8542: PPUSH
8543: CALL_OW 296
8547: PUSH
8548: LD_INT 10
8550: LESS
8551: OR
8552: IFFALSE 8345
// if IsDead ( Belkov ) then
8554: LD_EXP 46
8558: PPUSH
8559: CALL_OW 301
8563: IFFALSE 8588
// begin CenterNowOnUnits ( Belkov ) ;
8565: LD_EXP 46
8569: PPUSH
8570: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8574: LD_EXP 14
8578: PPUSH
8579: LD_STRING D5a-JMM-2a
8581: PPUSH
8582: CALL_OW 88
// exit ;
8586: GO 8654
// end ; if See ( 7 , Belkov ) then
8588: LD_INT 7
8590: PPUSH
8591: LD_EXP 46
8595: PPUSH
8596: CALL_OW 292
8600: IFFALSE 8614
// SetSide ( Belkov , 7 ) ;
8602: LD_EXP 46
8606: PPUSH
8607: LD_INT 7
8609: PPUSH
8610: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8614: LD_INT 35
8616: PPUSH
8617: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8621: LD_EXP 46
8625: PPUSH
8626: LD_INT 66
8628: PPUSH
8629: LD_INT 45
8631: PPUSH
8632: CALL_OW 297
8636: PUSH
8637: LD_INT 30
8639: LESS
8640: IFFALSE 8614
// Say ( Belkov , D6-Bel-1 ) ;
8642: LD_EXP 46
8646: PPUSH
8647: LD_STRING D6-Bel-1
8649: PPUSH
8650: CALL_OW 88
// end ;
8654: PPOPN 3
8656: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8657: LD_EXP 46
8661: PPUSH
8662: CALL_OW 302
8666: PUSH
8667: LD_EXP 46
8671: PPUSH
8672: CALL_OW 504
8676: PUSH
8677: LD_INT 2
8679: PUSH
8680: LD_INT 34
8682: PUSH
8683: LD_INT 47
8685: PUSH
8686: EMPTY
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 34
8692: PUSH
8693: LD_INT 45
8695: PUSH
8696: EMPTY
8697: LIST
8698: LIST
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: LIST
8704: PPUSH
8705: CALL_OW 69
8709: IN
8710: AND
8711: IFFALSE 8728
8713: GO 8715
8715: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8716: LD_EXP 46
8720: PPUSH
8721: LD_STRING D7-Bel-1
8723: PPUSH
8724: CALL_OW 88
8728: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8729: LD_INT 22
8731: PUSH
8732: LD_INT 7
8734: PUSH
8735: EMPTY
8736: LIST
8737: LIST
8738: PUSH
8739: LD_INT 101
8741: PUSH
8742: LD_INT 2
8744: PUSH
8745: EMPTY
8746: LIST
8747: LIST
8748: PUSH
8749: EMPTY
8750: LIST
8751: LIST
8752: PPUSH
8753: CALL_OW 69
8757: PUSH
8758: LD_EXP 8
8762: NOT
8763: AND
8764: PUSH
8765: LD_EXP 45
8769: PPUSH
8770: CALL_OW 305
8774: NOT
8775: AND
8776: IFFALSE 9246
8778: GO 8780
8780: DISABLE
8781: LD_INT 0
8783: PPUSH
// begin ar_base_spotted := true ;
8784: LD_ADDR_EXP 8
8788: PUSH
8789: LD_INT 1
8791: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8792: LD_ADDR_VAR 0 1
8796: PUSH
8797: LD_INT 22
8799: PUSH
8800: LD_INT 2
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 3
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PPUSH
8821: CALL_OW 69
8825: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8826: LD_ADDR_VAR 0 1
8830: PUSH
8831: LD_VAR 0 1
8835: PPUSH
8836: LD_EXP 14
8840: PPUSH
8841: CALL_OW 74
8845: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8846: LD_INT 7
8848: PPUSH
8849: LD_INT 3
8851: PPUSH
8852: CALL_OW 332
// DialogueOn ;
8856: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8860: LD_VAR 0 1
8864: PPUSH
8865: CALL_OW 250
8869: PPUSH
8870: LD_VAR 0 1
8874: PPUSH
8875: CALL_OW 251
8879: PPUSH
8880: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8884: LD_ADDR_VAR 0 1
8888: PUSH
8889: LD_INT 22
8891: PUSH
8892: LD_INT 7
8894: PUSH
8895: EMPTY
8896: LIST
8897: LIST
8898: PUSH
8899: LD_INT 23
8901: PUSH
8902: LD_INT 1
8904: PUSH
8905: EMPTY
8906: LIST
8907: LIST
8908: PUSH
8909: LD_INT 26
8911: PUSH
8912: LD_INT 1
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: PPUSH
8924: CALL_OW 69
8928: PUSH
8929: LD_EXP 14
8933: PUSH
8934: LD_EXP 18
8938: PUSH
8939: LD_EXP 19
8943: PUSH
8944: LD_EXP 26
8948: PUSH
8949: LD_EXP 15
8953: PUSH
8954: LD_EXP 24
8958: PUSH
8959: LD_EXP 20
8963: PUSH
8964: LD_EXP 22
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: LIST
8973: LIST
8974: LIST
8975: LIST
8976: LIST
8977: LIST
8978: DIFF
8979: ST_TO_ADDR
// if not tmp then
8980: LD_VAR 0 1
8984: NOT
8985: IFFALSE 9059
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8987: LD_ADDR_VAR 0 1
8991: PUSH
8992: LD_INT 22
8994: PUSH
8995: LD_INT 7
8997: PUSH
8998: EMPTY
8999: LIST
9000: LIST
9001: PUSH
9002: LD_INT 23
9004: PUSH
9005: LD_INT 1
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: PUSH
9012: LD_INT 26
9014: PUSH
9015: LD_INT 2
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: LIST
9026: PPUSH
9027: CALL_OW 69
9031: PUSH
9032: LD_EXP 29
9036: PUSH
9037: LD_EXP 16
9041: PUSH
9042: LD_EXP 27
9046: PUSH
9047: LD_EXP 28
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: DIFF
9058: ST_TO_ADDR
// if tmp then
9059: LD_VAR 0 1
9063: IFFALSE 9134
// case GetSex ( tmp [ 1 ] ) of sex_male :
9065: LD_VAR 0 1
9069: PUSH
9070: LD_INT 1
9072: ARRAY
9073: PPUSH
9074: CALL_OW 258
9078: PUSH
9079: LD_INT 1
9081: DOUBLE
9082: EQUAL
9083: IFTRUE 9087
9085: GO 9106
9087: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9088: LD_VAR 0 1
9092: PUSH
9093: LD_INT 1
9095: ARRAY
9096: PPUSH
9097: LD_STRING D9-Sol1-1
9099: PPUSH
9100: CALL_OW 88
9104: GO 9134
9106: LD_INT 2
9108: DOUBLE
9109: EQUAL
9110: IFTRUE 9114
9112: GO 9133
9114: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9115: LD_VAR 0 1
9119: PUSH
9120: LD_INT 1
9122: ARRAY
9123: PPUSH
9124: LD_STRING D9-FSol1-1
9126: PPUSH
9127: CALL_OW 88
9131: GO 9134
9133: POP
// if Frank then
9134: LD_EXP 26
9138: IFFALSE 9242
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9140: LD_EXP 55
9144: PPUSH
9145: CALL_OW 250
9149: PPUSH
9150: LD_EXP 55
9154: PPUSH
9155: CALL_OW 251
9159: PPUSH
9160: LD_INT 7
9162: PPUSH
9163: LD_INT 8
9165: PPUSH
9166: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9170: LD_EXP 55
9174: PPUSH
9175: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9179: LD_EXP 26
9183: PPUSH
9184: LD_STRING D9-Frank-1
9186: PPUSH
9187: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9191: LD_EXP 14
9195: PPUSH
9196: LD_STRING D9-JMM-1
9198: PPUSH
9199: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9203: LD_EXP 26
9207: PPUSH
9208: LD_STRING D9-Frank-2
9210: PPUSH
9211: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9215: LD_EXP 55
9219: PPUSH
9220: CALL_OW 250
9224: PPUSH
9225: LD_EXP 55
9229: PPUSH
9230: CALL_OW 251
9234: PPUSH
9235: LD_INT 7
9237: PPUSH
9238: CALL_OW 331
// end ; DialogueOff ;
9242: CALL_OW 7
// end ;
9246: PPOPN 1
9248: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9249: LD_EXP 7
9253: PUSH
9254: LD_OWVAR 1
9258: PUSH
9259: LD_INT 42000
9261: GREATEREQUAL
9262: OR
9263: IFFALSE 10290
9265: GO 9267
9267: DISABLE
9268: LD_INT 0
9270: PPUSH
9271: PPUSH
// begin selected_option := 1 ;
9272: LD_ADDR_VAR 0 2
9276: PUSH
9277: LD_INT 1
9279: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9280: LD_INT 10500
9282: PPUSH
9283: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9287: LD_INT 35
9289: PPUSH
9290: CALL_OW 67
// until not ru_attackers ;
9294: LD_EXP 51
9298: NOT
9299: IFFALSE 9287
// PrepareBurlak ;
9301: CALL 2112 0 0
// repeat wait ( 0 0$2 ) ;
9305: LD_INT 70
9307: PPUSH
9308: CALL_OW 67
// until not HasTask ( Burlak ) ;
9312: LD_EXP 45
9316: PPUSH
9317: CALL_OW 314
9321: NOT
9322: IFFALSE 9305
// InGameOn ;
9324: CALL_OW 8
// DialogueOn ;
9328: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9332: LD_EXP 48
9336: PPUSH
9337: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9341: LD_EXP 45
9345: PPUSH
9346: LD_STRING D10-Bur-1
9348: PPUSH
9349: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9353: LD_EXP 46
9357: PUSH
9358: LD_EXP 46
9362: PPUSH
9363: CALL_OW 255
9367: PUSH
9368: LD_INT 7
9370: EQUAL
9371: AND
9372: IFFALSE 9386
// Say ( Belkov , D10-Bel-1 ) ;
9374: LD_EXP 46
9378: PPUSH
9379: LD_STRING D10-Bel-1
9381: PPUSH
9382: CALL_OW 88
// if Gossudarov then
9386: LD_EXP 31
9390: IFFALSE 9404
// Say ( Gossudarov , D10-Gos-1 ) ;
9392: LD_EXP 31
9396: PPUSH
9397: LD_STRING D10-Gos-1
9399: PPUSH
9400: CALL_OW 88
// if Kirilenkova then
9404: LD_EXP 32
9408: IFFALSE 9422
// Say ( Kirilenkova , D10-Kir-1 ) ;
9410: LD_EXP 32
9414: PPUSH
9415: LD_STRING D10-Kir-1
9417: PPUSH
9418: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9422: CALL 12681 0 0
9426: PPUSH
9427: LD_STRING D10-RSol1-1
9429: PPUSH
9430: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9434: LD_EXP 45
9438: PPUSH
9439: LD_STRING D10-Bur-2
9441: PPUSH
9442: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9446: LD_EXP 14
9450: PPUSH
9451: LD_STRING D10-JMM-2
9453: PPUSH
9454: CALL_OW 88
// if Kirilenkova then
9458: LD_EXP 32
9462: IFFALSE 9478
// Say ( Kirilenkova , D10-Kir-2 ) else
9464: LD_EXP 32
9468: PPUSH
9469: LD_STRING D10-Kir-2
9471: PPUSH
9472: CALL_OW 88
9476: GO 9490
// Say ( SolRu , D10-RSol1-2 ) ;
9478: CALL 12681 0 0
9482: PPUSH
9483: LD_STRING D10-RSol1-2
9485: PPUSH
9486: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9490: LD_EXP 14
9494: PPUSH
9495: LD_STRING D10-JMM-3
9497: PPUSH
9498: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9502: LD_EXP 45
9506: PPUSH
9507: LD_STRING D10-Bur-3
9509: PPUSH
9510: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9514: LD_EXP 14
9518: PPUSH
9519: LD_STRING D10-JMM-4
9521: PPUSH
9522: CALL_OW 88
// DialogueOff ;
9526: CALL_OW 7
// InGameOff ;
9530: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9534: LD_STRING M2
9536: PPUSH
9537: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9541: LD_INT 35
9543: PPUSH
9544: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9548: LD_INT 22
9550: PUSH
9551: LD_INT 7
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 91
9560: PUSH
9561: LD_EXP 45
9565: PUSH
9566: LD_INT 8
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: LIST
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: PPUSH
9578: CALL_OW 69
9582: IFFALSE 9541
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9584: LD_ADDR_VAR 0 1
9588: PUSH
9589: LD_INT 22
9591: PUSH
9592: LD_INT 4
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: PPUSH
9599: CALL_OW 69
9603: PUSH
9604: FOR_IN
9605: IFFALSE 9621
// SetSide ( i , 7 ) ;
9607: LD_VAR 0 1
9611: PPUSH
9612: LD_INT 7
9614: PPUSH
9615: CALL_OW 235
9619: GO 9604
9621: POP
9622: POP
// ChangeMissionObjectives ( M3 ) ;
9623: LD_STRING M3
9625: PPUSH
9626: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9630: LD_INT 35
9632: PPUSH
9633: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9637: LD_EXP 14
9641: PPUSH
9642: LD_EXP 45
9646: PPUSH
9647: CALL_OW 296
9651: PUSH
9652: LD_INT 8
9654: LESS
9655: IFFALSE 9630
// ComTurnUnit ( JMM , Burlak ) ;
9657: LD_EXP 14
9661: PPUSH
9662: LD_EXP 45
9666: PPUSH
9667: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9671: LD_EXP 45
9675: PPUSH
9676: LD_EXP 14
9680: PPUSH
9681: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9685: LD_INT 10
9687: PPUSH
9688: CALL_OW 67
// DialogueOn ;
9692: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9696: LD_EXP 14
9700: PPUSH
9701: LD_STRING D11-JMM-1
9703: PPUSH
9704: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9708: LD_EXP 45
9712: PPUSH
9713: LD_STRING D11-Bur-1
9715: PPUSH
9716: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9720: LD_EXP 14
9724: PPUSH
9725: LD_STRING D11-JMM-2
9727: PPUSH
9728: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9732: LD_EXP 45
9736: PPUSH
9737: LD_STRING D11-Bur-2
9739: PPUSH
9740: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9744: LD_EXP 14
9748: PPUSH
9749: LD_STRING D11-JMM-3
9751: PPUSH
9752: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9756: LD_EXP 45
9760: PPUSH
9761: LD_STRING D11-Bur-3
9763: PPUSH
9764: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9768: LD_EXP 14
9772: PPUSH
9773: LD_STRING D11-JMM-4
9775: PPUSH
9776: CALL_OW 88
// if ar_base_spotted then
9780: LD_EXP 8
9784: IFFALSE 9800
// Say ( Burlak , D12-Bur-1 ) else
9786: LD_EXP 45
9790: PPUSH
9791: LD_STRING D12-Bur-1
9793: PPUSH
9794: CALL_OW 88
9798: GO 9839
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9800: LD_INT 7
9802: PPUSH
9803: LD_INT 3
9805: PPUSH
9806: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9810: LD_INT 127
9812: PPUSH
9813: LD_INT 45
9815: PPUSH
9816: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9820: LD_EXP 45
9824: PPUSH
9825: LD_STRING D12-Bur-1a
9827: PPUSH
9828: CALL_OW 88
// dwait ( 0 0$2 ) ;
9832: LD_INT 70
9834: PPUSH
9835: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9839: LD_EXP 45
9843: PPUSH
9844: LD_STRING D12-Bur-1b
9846: PPUSH
9847: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9851: LD_EXP 14
9855: PPUSH
9856: LD_STRING D12-JMM-1
9858: PPUSH
9859: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9863: LD_EXP 45
9867: PPUSH
9868: LD_STRING D12-Bur-2
9870: PPUSH
9871: CALL_OW 88
// if Roth then
9875: LD_EXP 15
9879: IFFALSE 9895
// Say ( Roth , D12-Roth-2 ) else
9881: LD_EXP 15
9885: PPUSH
9886: LD_STRING D12-Roth-2
9888: PPUSH
9889: CALL_OW 88
9893: GO 9907
// Say ( SciRu , D12-RSci1-2 ) ;
9895: CALL 12534 0 0
9899: PPUSH
9900: LD_STRING D12-RSci1-2
9902: PPUSH
9903: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9907: LD_EXP 14
9911: PPUSH
9912: LD_STRING D12-JMM-2
9914: PPUSH
9915: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9919: LD_EXP 45
9923: PPUSH
9924: LD_STRING D12-Bur-3
9926: PPUSH
9927: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9931: LD_EXP 14
9935: PPUSH
9936: LD_STRING D12-JMM-3
9938: PPUSH
9939: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9943: LD_EXP 45
9947: PPUSH
9948: LD_STRING D12-Bur-4
9950: PPUSH
9951: CALL_OW 88
// case Query ( QBase ) of 1 :
9955: LD_STRING QBase
9957: PPUSH
9958: CALL_OW 97
9962: PUSH
9963: LD_INT 1
9965: DOUBLE
9966: EQUAL
9967: IFTRUE 9971
9969: GO 10089
9971: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9972: LD_EXP 14
9976: PPUSH
9977: LD_STRING D13a-JMM-1
9979: PPUSH
9980: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9984: LD_EXP 45
9988: PPUSH
9989: LD_STRING D13a-Bur-1
9991: PPUSH
9992: CALL_OW 88
// if Roth then
9996: LD_EXP 15
10000: IFFALSE 10016
// Say ( Roth , D13a-Roth-1 ) else
10002: LD_EXP 15
10006: PPUSH
10007: LD_STRING D13a-Roth-1
10009: PPUSH
10010: CALL_OW 88
10014: GO 10028
// Say ( SciRu , D13a-RSci1-1 ) ;
10016: CALL 12534 0 0
10020: PPUSH
10021: LD_STRING D13a-RSci1-1
10023: PPUSH
10024: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10028: LD_EXP 14
10032: PPUSH
10033: LD_STRING D13a-JMM-2
10035: PPUSH
10036: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10040: LD_STRING QBaseAgain
10042: PPUSH
10043: CALL_OW 97
10047: PUSH
10048: LD_INT 1
10050: DOUBLE
10051: EQUAL
10052: IFTRUE 10056
10054: GO 10067
10056: POP
// selected_option := 2 ; 2 :
10057: LD_ADDR_VAR 0 2
10061: PUSH
10062: LD_INT 2
10064: ST_TO_ADDR
10065: GO 10087
10067: LD_INT 2
10069: DOUBLE
10070: EQUAL
10071: IFTRUE 10075
10073: GO 10086
10075: POP
// selected_option := 3 ; end ;
10076: LD_ADDR_VAR 0 2
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
10084: GO 10087
10086: POP
// end ; 2 :
10087: GO 10128
10089: LD_INT 2
10091: DOUBLE
10092: EQUAL
10093: IFTRUE 10097
10095: GO 10108
10097: POP
// selected_option := 2 ; 3 :
10098: LD_ADDR_VAR 0 2
10102: PUSH
10103: LD_INT 2
10105: ST_TO_ADDR
10106: GO 10128
10108: LD_INT 3
10110: DOUBLE
10111: EQUAL
10112: IFTRUE 10116
10114: GO 10127
10116: POP
// selected_option := 3 ; end ;
10117: LD_ADDR_VAR 0 2
10121: PUSH
10122: LD_INT 3
10124: ST_TO_ADDR
10125: GO 10128
10127: POP
// if selected_option = 2 then
10128: LD_VAR 0 2
10132: PUSH
10133: LD_INT 2
10135: EQUAL
10136: IFFALSE 10230
// begin Say ( JMM , D13b-JMM-1 ) ;
10138: LD_EXP 14
10142: PPUSH
10143: LD_STRING D13b-JMM-1
10145: PPUSH
10146: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10150: LD_EXP 45
10154: PPUSH
10155: LD_STRING D13b-Bur-1
10157: PPUSH
10158: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10162: LD_EXP 14
10166: PPUSH
10167: LD_STRING D13b-JMM-2
10169: PPUSH
10170: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10174: LD_EXP 54
10178: PPUSH
10179: LD_STRING D13b-Abd-2
10181: PPUSH
10182: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10186: LD_EXP 14
10190: PPUSH
10191: LD_STRING D13b-JMM-3
10193: PPUSH
10194: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10198: LD_EXP 54
10202: PPUSH
10203: LD_STRING D13b-Abd-3
10205: PPUSH
10206: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10210: LD_EXP 14
10214: PPUSH
10215: LD_STRING D13b-JMM-4
10217: PPUSH
10218: CALL_OW 88
// ar_active_attack := true ;
10222: LD_ADDR_EXP 9
10226: PUSH
10227: LD_INT 1
10229: ST_TO_ADDR
// end ; if selected_option = 3 then
10230: LD_VAR 0 2
10234: PUSH
10235: LD_INT 3
10237: EQUAL
10238: IFFALSE 10264
// begin Say ( JMM , D13c-JMM-1 ) ;
10240: LD_EXP 14
10244: PPUSH
10245: LD_STRING D13c-JMM-1
10247: PPUSH
10248: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10252: LD_EXP 45
10256: PPUSH
10257: LD_STRING D13c-Bur-1
10259: PPUSH
10260: CALL_OW 88
// end ; DialogueOff ;
10264: CALL_OW 7
// if not ar_active_attack then
10268: LD_EXP 9
10272: NOT
10273: IFFALSE 10290
// begin wait ( 6 6$00 ) ;
10275: LD_INT 12600
10277: PPUSH
10278: CALL_OW 67
// ar_active_attack := true ;
10282: LD_ADDR_EXP 9
10286: PUSH
10287: LD_INT 1
10289: ST_TO_ADDR
// end ; end ;
10290: PPOPN 2
10292: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10293: LD_EXP 45
10297: PPUSH
10298: CALL_OW 305
10302: PUSH
10303: LD_EXP 45
10307: PPUSH
10308: CALL_OW 255
10312: PUSH
10313: LD_INT 7
10315: EQUAL
10316: AND
10317: IFFALSE 10513
10319: GO 10321
10321: DISABLE
10322: LD_INT 0
10324: PPUSH
// begin wait ( 4 4$40 ) ;
10325: LD_INT 9800
10327: PPUSH
10328: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10332: LD_INT 35
10334: PPUSH
10335: CALL_OW 67
// until not ru_attackers ;
10339: LD_EXP 51
10343: NOT
10344: IFFALSE 10332
// PrepareGnyevko ;
10346: CALL 2056 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10350: LD_EXP 47
10354: PPUSH
10355: LD_INT 124
10357: PPUSH
10358: LD_INT 118
10360: PPUSH
10361: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10365: LD_EXP 47
10369: PPUSH
10370: CALL_OW 200
// time := 0 0$00 ;
10374: LD_ADDR_VAR 0 1
10378: PUSH
10379: LD_INT 0
10381: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10382: LD_INT 35
10384: PPUSH
10385: CALL_OW 67
// time := time + 0 0$1 ;
10389: LD_ADDR_VAR 0 1
10393: PUSH
10394: LD_VAR 0 1
10398: PUSH
10399: LD_INT 35
10401: PLUS
10402: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10403: LD_EXP 47
10407: PPUSH
10408: LD_INT 124
10410: PPUSH
10411: LD_INT 118
10413: PPUSH
10414: CALL_OW 307
10418: PUSH
10419: LD_VAR 0 1
10423: PUSH
10424: LD_INT 1050
10426: GREATEREQUAL
10427: OR
10428: IFFALSE 10382
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10430: LD_EXP 47
10434: PPUSH
10435: LD_STRING DBelkov-Gny-1
10437: PPUSH
10438: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10442: LD_EXP 45
10446: PPUSH
10447: LD_STRING DBelkov-Bur-1a
10449: PPUSH
10450: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10454: LD_INT 35
10456: PPUSH
10457: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10461: LD_EXP 47
10465: PPUSH
10466: LD_INT 22
10468: PUSH
10469: LD_INT 7
10471: PUSH
10472: EMPTY
10473: LIST
10474: LIST
10475: PPUSH
10476: CALL_OW 69
10480: PPUSH
10481: LD_EXP 47
10485: PPUSH
10486: CALL_OW 74
10490: PPUSH
10491: CALL_OW 296
10495: PUSH
10496: LD_INT 8
10498: LESS
10499: IFFALSE 10454
// SetSide ( Gnyevko , 7 ) ;
10501: LD_EXP 47
10505: PPUSH
10506: LD_INT 7
10508: PPUSH
10509: CALL_OW 235
// end ;
10513: PPOPN 1
10515: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10516: LD_EXP 45
10520: PPUSH
10521: CALL_OW 255
10525: PUSH
10526: LD_INT 7
10528: EQUAL
10529: IFFALSE 10539
10531: GO 10533
10533: DISABLE
// begin enable ;
10534: ENABLE
// PrepareAmericanAttack ;
10535: CALL 6362 0 0
// end ;
10539: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10540: LD_INT 22
10542: PUSH
10543: LD_INT 1
10545: PUSH
10546: EMPTY
10547: LIST
10548: LIST
10549: PPUSH
10550: CALL_OW 69
10554: IFFALSE 10738
10556: GO 10558
10558: DISABLE
10559: LD_INT 0
10561: PPUSH
10562: PPUSH
// begin while true do
10563: LD_INT 1
10565: IFFALSE 10622
// begin wait ( 0 0$1 ) ;
10567: LD_INT 35
10569: PPUSH
10570: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10574: LD_ADDR_VAR 0 2
10578: PUSH
10579: LD_INT 22
10581: PUSH
10582: LD_INT 1
10584: PUSH
10585: EMPTY
10586: LIST
10587: LIST
10588: PPUSH
10589: CALL_OW 69
10593: PPUSH
10594: LD_EXP 14
10598: PPUSH
10599: CALL_OW 74
10603: ST_TO_ADDR
// if See ( 7 , tmp ) then
10604: LD_INT 7
10606: PPUSH
10607: LD_VAR 0 2
10611: PPUSH
10612: CALL_OW 292
10616: IFFALSE 10620
// break ;
10618: GO 10622
// end ;
10620: GO 10563
// DialogueOn ;
10622: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10626: LD_VAR 0 2
10630: PPUSH
10631: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10635: LD_VAR 0 2
10639: PPUSH
10640: CALL_OW 250
10644: PPUSH
10645: LD_VAR 0 2
10649: PPUSH
10650: CALL_OW 251
10654: PPUSH
10655: LD_INT 7
10657: PPUSH
10658: LD_INT 8
10660: PPUSH
10661: CALL_OW 330
// if Denis then
10665: LD_EXP 20
10669: IFFALSE 10683
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10671: LD_EXP 20
10675: PPUSH
10676: LD_STRING DAmerAttack-Pet-1
10678: PPUSH
10679: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10683: LD_EXP 14
10687: PPUSH
10688: LD_STRING DAmerAttack-JMM-1
10690: PPUSH
10691: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10695: LD_EXP 45
10699: PPUSH
10700: LD_STRING DStop-Bur-1
10702: PPUSH
10703: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10707: LD_VAR 0 2
10711: PPUSH
10712: CALL_OW 250
10716: PPUSH
10717: LD_VAR 0 2
10721: PPUSH
10722: CALL_OW 251
10726: PPUSH
10727: LD_INT 7
10729: PPUSH
10730: CALL_OW 331
// DialogueOff ;
10734: CALL_OW 7
// end ;
10738: PPOPN 2
10740: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10741: LD_INT 22
10743: PUSH
10744: LD_INT 3
10746: PUSH
10747: EMPTY
10748: LIST
10749: LIST
10750: PUSH
10751: LD_INT 21
10753: PUSH
10754: LD_INT 1
10756: PUSH
10757: EMPTY
10758: LIST
10759: LIST
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PPUSH
10765: CALL_OW 69
10769: PUSH
10770: LD_INT 0
10772: EQUAL
10773: IFFALSE 10815
10775: GO 10777
10777: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10778: LD_STRING M5a
10780: PPUSH
10781: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10785: LD_EXP 14
10789: PPUSH
10790: LD_STRING D8-JMM-1
10792: PPUSH
10793: CALL_OW 88
// if Gossudarov then
10797: LD_EXP 31
10801: IFFALSE 10815
// Say ( Gossudarov , D8-Gos-1 ) ;
10803: LD_EXP 31
10807: PPUSH
10808: LD_STRING D8-Gos-1
10810: PPUSH
10811: CALL_OW 88
// end ;
10815: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10816: LD_INT 22
10818: PUSH
10819: LD_INT 2
10821: PUSH
10822: EMPTY
10823: LIST
10824: LIST
10825: PUSH
10826: LD_INT 21
10828: PUSH
10829: LD_INT 1
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: PPUSH
10840: CALL_OW 69
10844: PUSH
10845: LD_INT 0
10847: EQUAL
10848: IFFALSE 10898
10850: GO 10852
10852: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10853: LD_STRING M4c
10855: PPUSH
10856: CALL_OW 337
// if Roth then
10860: LD_EXP 15
10864: IFFALSE 10880
// Say ( Roth , DStop-Roth-1 ) else
10866: LD_EXP 15
10870: PPUSH
10871: LD_STRING DStop-Roth-1
10873: PPUSH
10874: CALL_OW 88
10878: GO 10898
// if Gossudarov then
10880: LD_EXP 31
10884: IFFALSE 10898
// Say ( Gossudarov , D8-Gos-1a ) ;
10886: LD_EXP 31
10890: PPUSH
10891: LD_STRING D8-Gos-1a
10893: PPUSH
10894: CALL_OW 88
// end ;
10898: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10899: LD_INT 7
10901: PPUSH
10902: LD_INT 1
10904: PPUSH
10905: LD_INT 1
10907: PPUSH
10908: CALL 14126 0 3
10912: PUSH
10913: LD_INT 0
10915: EQUAL
10916: PUSH
10917: LD_INT 7
10919: PPUSH
10920: LD_INT 3
10922: PPUSH
10923: LD_INT 1
10925: PPUSH
10926: CALL 14126 0 3
10930: PUSH
10931: LD_INT 0
10933: EQUAL
10934: AND
10935: IFFALSE 10947
10937: GO 10939
10939: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10940: LD_STRING M1a
10942: PPUSH
10943: CALL_OW 337
// end ;
10947: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
10948: LD_INT 22
10950: PUSH
10951: LD_INT 2
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PUSH
10958: LD_INT 21
10960: PUSH
10961: LD_INT 1
10963: PUSH
10964: EMPTY
10965: LIST
10966: LIST
10967: PUSH
10968: EMPTY
10969: LIST
10970: LIST
10971: PPUSH
10972: CALL_OW 69
10976: PUSH
10977: LD_INT 0
10979: EQUAL
10980: PUSH
10981: LD_INT 22
10983: PUSH
10984: LD_INT 3
10986: PUSH
10987: EMPTY
10988: LIST
10989: LIST
10990: PUSH
10991: LD_INT 21
10993: PUSH
10994: LD_INT 1
10996: PUSH
10997: EMPTY
10998: LIST
10999: LIST
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: PPUSH
11005: CALL_OW 69
11009: PUSH
11010: LD_INT 0
11012: EQUAL
11013: AND
11014: PUSH
11015: LD_INT 22
11017: PUSH
11018: LD_INT 1
11020: PUSH
11021: EMPTY
11022: LIST
11023: LIST
11024: PPUSH
11025: CALL_OW 69
11029: PUSH
11030: LD_INT 0
11032: EQUAL
11033: AND
11034: PUSH
11035: LD_INT 7
11037: PPUSH
11038: LD_INT 1
11040: PPUSH
11041: LD_INT 1
11043: PPUSH
11044: CALL 14126 0 3
11048: PUSH
11049: LD_INT 0
11051: EQUAL
11052: AND
11053: PUSH
11054: LD_INT 7
11056: PPUSH
11057: LD_INT 3
11059: PPUSH
11060: LD_INT 1
11062: PPUSH
11063: CALL 14126 0 3
11067: PUSH
11068: LD_INT 0
11070: EQUAL
11071: AND
11072: IFFALSE 12531
11074: GO 11076
11076: DISABLE
11077: LD_INT 0
11079: PPUSH
11080: PPUSH
11081: PPUSH
11082: PPUSH
11083: PPUSH
11084: PPUSH
// begin m1 := false ;
11085: LD_ADDR_VAR 0 4
11089: PUSH
11090: LD_INT 0
11092: ST_TO_ADDR
// m2 := false ;
11093: LD_ADDR_VAR 0 5
11097: PUSH
11098: LD_INT 0
11100: ST_TO_ADDR
// m3 := false ;
11101: LD_ADDR_VAR 0 6
11105: PUSH
11106: LD_INT 0
11108: ST_TO_ADDR
// wait ( 0 0$3 ) ;
11109: LD_INT 105
11111: PPUSH
11112: CALL_OW 67
// if not IsDead ( Masha ) then
11116: LD_EXP 48
11120: PPUSH
11121: CALL_OW 301
11125: NOT
11126: IFFALSE 11148
// begin m1 := true ;
11128: LD_ADDR_VAR 0 4
11132: PUSH
11133: LD_INT 1
11135: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11136: LD_STRING Masha
11138: PPUSH
11139: LD_INT 1
11141: PPUSH
11142: CALL_OW 101
// end else
11146: GO 11159
// AddMedal ( Masha , - 1 ) ;
11148: LD_STRING Masha
11150: PPUSH
11151: LD_INT 1
11153: NEG
11154: PPUSH
11155: CALL_OW 101
// if abdul_escaped then
11159: LD_EXP 12
11163: IFFALSE 11178
// AddMedal ( Abdul , - 1 ) else
11165: LD_STRING Abdul
11167: PPUSH
11168: LD_INT 1
11170: NEG
11171: PPUSH
11172: CALL_OW 101
11176: GO 11196
// begin m2 := true ;
11178: LD_ADDR_VAR 0 5
11182: PUSH
11183: LD_INT 1
11185: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11186: LD_STRING Abdul
11188: PPUSH
11189: LD_INT 1
11191: PPUSH
11192: CALL_OW 101
// end ; if loss_counter = 0 then
11196: LD_EXP 13
11200: PUSH
11201: LD_INT 0
11203: EQUAL
11204: IFFALSE 11226
// begin m3 := true ;
11206: LD_ADDR_VAR 0 6
11210: PUSH
11211: LD_INT 1
11213: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11214: LD_STRING People
11216: PPUSH
11217: LD_INT 2
11219: PPUSH
11220: CALL_OW 101
// end else
11224: GO 11284
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11226: LD_EXP 13
11230: PUSH
11231: LD_INT 3
11233: PUSH
11234: LD_INT 2
11236: PUSH
11237: LD_INT 2
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: LIST
11244: PUSH
11245: LD_OWVAR 67
11249: ARRAY
11250: LESSEQUAL
11251: IFFALSE 11273
// begin AddMedal ( People , 1 ) ;
11253: LD_STRING People
11255: PPUSH
11256: LD_INT 1
11258: PPUSH
11259: CALL_OW 101
// m3 := true ;
11263: LD_ADDR_VAR 0 6
11267: PUSH
11268: LD_INT 1
11270: ST_TO_ADDR
// end else
11271: GO 11284
// AddMedal ( People , - 1 ) ;
11273: LD_STRING People
11275: PPUSH
11276: LD_INT 1
11278: NEG
11279: PPUSH
11280: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11284: LD_OWVAR 67
11288: PUSH
11289: LD_INT 3
11291: EQUAL
11292: PUSH
11293: LD_VAR 0 4
11297: AND
11298: PUSH
11299: LD_VAR 0 5
11303: AND
11304: PUSH
11305: LD_VAR 0 6
11309: AND
11310: IFFALSE 11322
// SetAchievementEX ( ACH_AMER , 17 ) ;
11312: LD_STRING ACH_AMER
11314: PPUSH
11315: LD_INT 17
11317: PPUSH
11318: CALL_OW 564
// GiveMedals ( MAIN ) ;
11322: LD_STRING MAIN
11324: PPUSH
11325: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11329: LD_ADDR_VAR 0 2
11333: PUSH
11334: LD_INT 22
11336: PUSH
11337: LD_INT 7
11339: PUSH
11340: EMPTY
11341: LIST
11342: LIST
11343: PUSH
11344: LD_INT 2
11346: PUSH
11347: LD_INT 25
11349: PUSH
11350: LD_INT 1
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: PUSH
11357: LD_INT 25
11359: PUSH
11360: LD_INT 2
11362: PUSH
11363: EMPTY
11364: LIST
11365: LIST
11366: PUSH
11367: LD_INT 25
11369: PUSH
11370: LD_INT 3
11372: PUSH
11373: EMPTY
11374: LIST
11375: LIST
11376: PUSH
11377: LD_INT 25
11379: PUSH
11380: LD_INT 4
11382: PUSH
11383: EMPTY
11384: LIST
11385: LIST
11386: PUSH
11387: LD_INT 25
11389: PUSH
11390: LD_INT 5
11392: PUSH
11393: EMPTY
11394: LIST
11395: LIST
11396: PUSH
11397: LD_INT 25
11399: PUSH
11400: LD_INT 8
11402: PUSH
11403: EMPTY
11404: LIST
11405: LIST
11406: PUSH
11407: LD_INT 25
11409: PUSH
11410: LD_INT 9
11412: PUSH
11413: EMPTY
11414: LIST
11415: LIST
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: PUSH
11427: EMPTY
11428: LIST
11429: LIST
11430: PPUSH
11431: CALL_OW 69
11435: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11436: LD_VAR 0 2
11440: PPUSH
11441: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11445: LD_ADDR_VAR 0 3
11449: PUSH
11450: LD_EXP 14
11454: PUSH
11455: LD_EXP 15
11459: PUSH
11460: LD_EXP 16
11464: PUSH
11465: LD_EXP 17
11469: PUSH
11470: LD_EXP 18
11474: PUSH
11475: LD_EXP 19
11479: PUSH
11480: LD_EXP 20
11484: PUSH
11485: LD_EXP 21
11489: PUSH
11490: LD_EXP 22
11494: PUSH
11495: LD_EXP 23
11499: PUSH
11500: LD_EXP 24
11504: PUSH
11505: LD_EXP 25
11509: PUSH
11510: LD_EXP 26
11514: PUSH
11515: LD_EXP 27
11519: PUSH
11520: LD_EXP 28
11524: PUSH
11525: LD_EXP 29
11529: PUSH
11530: LD_EXP 30
11534: PUSH
11535: LD_EXP 31
11539: PUSH
11540: LD_EXP 32
11544: PUSH
11545: LD_EXP 33
11549: PUSH
11550: LD_EXP 35
11554: PUSH
11555: LD_EXP 36
11559: PUSH
11560: LD_EXP 37
11564: PUSH
11565: LD_EXP 38
11569: PUSH
11570: LD_EXP 39
11574: PUSH
11575: LD_EXP 40
11579: PUSH
11580: LD_EXP 41
11584: PUSH
11585: LD_EXP 42
11589: PUSH
11590: LD_EXP 43
11594: PUSH
11595: LD_EXP 44
11599: PUSH
11600: LD_EXP 45
11604: PUSH
11605: LD_EXP 46
11609: PUSH
11610: LD_EXP 47
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: LIST
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: LIST
11637: LIST
11638: LIST
11639: LIST
11640: LIST
11641: LIST
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: ST_TO_ADDR
// if tmp diff tmp2 then
11650: LD_VAR 0 2
11654: PUSH
11655: LD_VAR 0 3
11659: DIFF
11660: IFFALSE 11680
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11662: LD_VAR 0 2
11666: PUSH
11667: LD_VAR 0 3
11671: DIFF
11672: PPUSH
11673: LD_STRING 13a_others
11675: PPUSH
11676: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11680: LD_EXP 14
11684: PPUSH
11685: LD_STRING 13a_JMM
11687: PPUSH
11688: CALL_OW 38
// if Titov then
11692: LD_EXP 33
11696: IFFALSE 11710
// SaveCharacters ( Titov , 13a_Titov ) ;
11698: LD_EXP 33
11702: PPUSH
11703: LD_STRING 13a_Titov
11705: PPUSH
11706: CALL_OW 38
// if Dolgov then
11710: LD_EXP 35
11714: IFFALSE 11728
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11716: LD_EXP 35
11720: PPUSH
11721: LD_STRING 13a_Dolgov
11723: PPUSH
11724: CALL_OW 38
// if Petrosyan then
11728: LD_EXP 36
11732: IFFALSE 11746
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11734: LD_EXP 36
11738: PPUSH
11739: LD_STRING 13a_Petrosyan
11741: PPUSH
11742: CALL_OW 38
// if Scholtze then
11746: LD_EXP 37
11750: IFFALSE 11764
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11752: LD_EXP 37
11756: PPUSH
11757: LD_STRING 13a_Scholtze
11759: PPUSH
11760: CALL_OW 38
// if Oblukov then
11764: LD_EXP 38
11768: IFFALSE 11782
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11770: LD_EXP 38
11774: PPUSH
11775: LD_STRING 13a_Oblukov
11777: PPUSH
11778: CALL_OW 38
// if Kapitsova then
11782: LD_EXP 39
11786: IFFALSE 11800
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11788: LD_EXP 39
11792: PPUSH
11793: LD_STRING 13a_Kapitsova
11795: PPUSH
11796: CALL_OW 38
// if Lipshchin then
11800: LD_EXP 40
11804: IFFALSE 11818
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11806: LD_EXP 40
11810: PPUSH
11811: LD_STRING 13a_Lipshchin
11813: PPUSH
11814: CALL_OW 38
// if Petrovova then
11818: LD_EXP 41
11822: IFFALSE 11836
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11824: LD_EXP 41
11828: PPUSH
11829: LD_STRING 13a_Petrovova
11831: PPUSH
11832: CALL_OW 38
// if Kovalyuk then
11836: LD_EXP 42
11840: IFFALSE 11854
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11842: LD_EXP 42
11846: PPUSH
11847: LD_STRING 13a_Kovalyuk
11849: PPUSH
11850: CALL_OW 38
// if Kuzmov then
11854: LD_EXP 43
11858: IFFALSE 11872
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11860: LD_EXP 43
11864: PPUSH
11865: LD_STRING 13a_Kuzmov
11867: PPUSH
11868: CALL_OW 38
// if Karamazov then
11872: LD_EXP 44
11876: IFFALSE 11890
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11878: LD_EXP 44
11882: PPUSH
11883: LD_STRING 13a_Karamazov
11885: PPUSH
11886: CALL_OW 38
// if Burlak then
11890: LD_EXP 45
11894: IFFALSE 11908
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11896: LD_EXP 45
11900: PPUSH
11901: LD_STRING 13a_Burlak
11903: PPUSH
11904: CALL_OW 38
// if Belkov then
11908: LD_EXP 46
11912: IFFALSE 11926
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11914: LD_EXP 46
11918: PPUSH
11919: LD_STRING 13a_Belkov
11921: PPUSH
11922: CALL_OW 38
// if Gnyevko then
11926: LD_EXP 47
11930: IFFALSE 11944
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11932: LD_EXP 47
11936: PPUSH
11937: LD_STRING 13a_Gnyevko
11939: PPUSH
11940: CALL_OW 38
// if Lisa then
11944: LD_EXP 16
11948: IFFALSE 11962
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11950: LD_EXP 16
11954: PPUSH
11955: LD_STRING 13a_Lisa
11957: PPUSH
11958: CALL_OW 38
// if Donaldson then
11962: LD_EXP 17
11966: IFFALSE 11980
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11968: LD_EXP 17
11972: PPUSH
11973: LD_STRING 13a_Donaldson
11975: PPUSH
11976: CALL_OW 38
// if Bobby then
11980: LD_EXP 18
11984: IFFALSE 11998
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11986: LD_EXP 18
11990: PPUSH
11991: LD_STRING 13a_Bobby
11993: PPUSH
11994: CALL_OW 38
// if Cyrus then
11998: LD_EXP 19
12002: IFFALSE 12016
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12004: LD_EXP 19
12008: PPUSH
12009: LD_STRING 13a_Cyrus
12011: PPUSH
12012: CALL_OW 38
// if Denis then
12016: LD_EXP 20
12020: IFFALSE 12034
// SaveCharacters ( Denis , 13a_Denis ) ;
12022: LD_EXP 20
12026: PPUSH
12027: LD_STRING 13a_Denis
12029: PPUSH
12030: CALL_OW 38
// if Brown then
12034: LD_EXP 21
12038: IFFALSE 12052
// SaveCharacters ( Brown , 13a_Brown ) ;
12040: LD_EXP 21
12044: PPUSH
12045: LD_STRING 13a_Brown
12047: PPUSH
12048: CALL_OW 38
// if Gladstone then
12052: LD_EXP 22
12056: IFFALSE 12070
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12058: LD_EXP 22
12062: PPUSH
12063: LD_STRING 13a_Gladstone
12065: PPUSH
12066: CALL_OW 38
// if Houten then
12070: LD_EXP 23
12074: IFFALSE 12088
// SaveCharacters ( Houten , 13a_Houten ) ;
12076: LD_EXP 23
12080: PPUSH
12081: LD_STRING 13a_Houten
12083: PPUSH
12084: CALL_OW 38
// if Cornel then
12088: LD_EXP 24
12092: IFFALSE 12106
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12094: LD_EXP 24
12098: PPUSH
12099: LD_STRING 13a_Cornel
12101: PPUSH
12102: CALL_OW 38
// if Gary then
12106: LD_EXP 25
12110: IFFALSE 12124
// SaveCharacters ( Gary , 13a_Gary ) ;
12112: LD_EXP 25
12116: PPUSH
12117: LD_STRING 13a_Gary
12119: PPUSH
12120: CALL_OW 38
// if Frank then
12124: LD_EXP 26
12128: IFFALSE 12142
// SaveCharacters ( Frank , 13a_Frank ) ;
12130: LD_EXP 26
12134: PPUSH
12135: LD_STRING 13a_Frank
12137: PPUSH
12138: CALL_OW 38
// if Kikuchi then
12142: LD_EXP 27
12146: IFFALSE 12160
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12148: LD_EXP 27
12152: PPUSH
12153: LD_STRING 13a_Kikuchi
12155: PPUSH
12156: CALL_OW 38
// if Simms then
12160: LD_EXP 28
12164: IFFALSE 12178
// SaveCharacters ( Simms , 13a_Simms ) ;
12166: LD_EXP 28
12170: PPUSH
12171: LD_STRING 13a_Simms
12173: PPUSH
12174: CALL_OW 38
// if Joan then
12178: LD_EXP 29
12182: IFFALSE 12196
// SaveCharacters ( Joan , 13a_Joan ) ;
12184: LD_EXP 29
12188: PPUSH
12189: LD_STRING 13a_Joan
12191: PPUSH
12192: CALL_OW 38
// if DeltaDoctor then
12196: LD_EXP 30
12200: IFFALSE 12214
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12202: LD_EXP 30
12206: PPUSH
12207: LD_STRING 13a_DeltaDoctor
12209: PPUSH
12210: CALL_OW 38
// if Gossudarov then
12214: LD_EXP 31
12218: IFFALSE 12232
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12220: LD_EXP 31
12224: PPUSH
12225: LD_STRING 13a_Gossudarov
12227: PPUSH
12228: CALL_OW 38
// if Kirilenkova then
12232: LD_EXP 32
12236: IFFALSE 12250
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12238: LD_EXP 32
12242: PPUSH
12243: LD_STRING 13a_Kirilenkova
12245: PPUSH
12246: CALL_OW 38
// if Roth then
12250: LD_EXP 15
12254: IFFALSE 12268
// SaveCharacters ( Roth , 13a_Roth ) ;
12256: LD_EXP 15
12260: PPUSH
12261: LD_STRING 13a_Roth
12263: PPUSH
12264: CALL_OW 38
// if Masha then
12268: LD_EXP 48
12272: IFFALSE 12327
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12274: LD_EXP 48
12278: PPUSH
12279: CALL_OW 265
12283: PUSH
12284: LD_EXP 48
12288: PPUSH
12289: CALL_OW 262
12293: PUSH
12294: LD_EXP 48
12298: PPUSH
12299: CALL_OW 263
12303: PUSH
12304: LD_EXP 48
12308: PPUSH
12309: CALL_OW 264
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: LIST
12318: LIST
12319: PPUSH
12320: LD_STRING 13a_Masha
12322: PPUSH
12323: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12327: LD_ADDR_VAR 0 2
12331: PUSH
12332: LD_INT 21
12334: PUSH
12335: LD_INT 3
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: PPUSH
12342: CALL_OW 69
12346: ST_TO_ADDR
// tmp2 := [ ] ;
12347: LD_ADDR_VAR 0 3
12351: PUSH
12352: EMPTY
12353: ST_TO_ADDR
// if tmp then
12354: LD_VAR 0 2
12358: IFFALSE 12509
// for i in tmp do
12360: LD_ADDR_VAR 0 1
12364: PUSH
12365: LD_VAR 0 2
12369: PUSH
12370: FOR_IN
12371: IFFALSE 12507
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12373: LD_ADDR_VAR 0 3
12377: PUSH
12378: LD_VAR 0 3
12382: PUSH
12383: LD_VAR 0 1
12387: PPUSH
12388: CALL_OW 255
12392: PUSH
12393: LD_VAR 0 1
12397: PPUSH
12398: CALL_OW 248
12402: PUSH
12403: LD_VAR 0 1
12407: PPUSH
12408: CALL_OW 266
12412: PUSH
12413: LD_VAR 0 1
12417: PPUSH
12418: CALL_OW 250
12422: PUSH
12423: LD_VAR 0 1
12427: PPUSH
12428: CALL_OW 251
12432: PUSH
12433: LD_VAR 0 1
12437: PPUSH
12438: CALL_OW 254
12442: PUSH
12443: LD_VAR 0 1
12447: PPUSH
12448: CALL_OW 267
12452: PUSH
12453: LD_VAR 0 1
12457: PPUSH
12458: LD_INT 1
12460: PPUSH
12461: CALL_OW 268
12465: PUSH
12466: LD_VAR 0 1
12470: PPUSH
12471: LD_INT 2
12473: PPUSH
12474: CALL_OW 268
12478: PUSH
12479: LD_VAR 0 1
12483: PPUSH
12484: CALL_OW 269
12488: PUSH
12489: EMPTY
12490: LIST
12491: LIST
12492: LIST
12493: LIST
12494: LIST
12495: LIST
12496: LIST
12497: LIST
12498: LIST
12499: LIST
12500: PUSH
12501: EMPTY
12502: LIST
12503: ADD
12504: ST_TO_ADDR
12505: GO 12370
12507: POP
12508: POP
// if tmp2 then
12509: LD_VAR 0 3
12513: IFFALSE 12527
// SaveVariable ( tmp2 , 13a_buildings ) ;
12515: LD_VAR 0 3
12519: PPUSH
12520: LD_STRING 13a_buildings
12522: PPUSH
12523: CALL_OW 39
// YouWin ;
12527: CALL_OW 103
// end ;
12531: PPOPN 6
12533: END
// export function SciRu ; var tmp , t ; begin
12534: LD_INT 0
12536: PPUSH
12537: PPUSH
12538: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12539: LD_ADDR_VAR 0 3
12543: PUSH
12544: LD_EXP 31
12548: PUSH
12549: LD_EXP 45
12553: PUSH
12554: LD_EXP 33
12558: PUSH
12559: LD_EXP 46
12563: PUSH
12564: LD_EXP 47
12568: PUSH
12569: LD_EXP 36
12573: PUSH
12574: LD_EXP 37
12578: PUSH
12579: LD_EXP 35
12583: PUSH
12584: EMPTY
12585: LIST
12586: LIST
12587: LIST
12588: LIST
12589: LIST
12590: LIST
12591: LIST
12592: LIST
12593: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12594: LD_ADDR_VAR 0 2
12598: PUSH
12599: LD_INT 22
12601: PUSH
12602: LD_INT 7
12604: PUSH
12605: EMPTY
12606: LIST
12607: LIST
12608: PUSH
12609: LD_INT 23
12611: PUSH
12612: LD_INT 3
12614: PUSH
12615: EMPTY
12616: LIST
12617: LIST
12618: PUSH
12619: LD_INT 25
12621: PUSH
12622: LD_INT 4
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: PUSH
12629: LD_INT 26
12631: PUSH
12632: LD_INT 1
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PUSH
12639: EMPTY
12640: LIST
12641: LIST
12642: LIST
12643: LIST
12644: PPUSH
12645: CALL_OW 69
12649: PUSH
12650: LD_VAR 0 3
12654: DIFF
12655: ST_TO_ADDR
// if tmp then
12656: LD_VAR 0 2
12660: IFFALSE 12676
// result := tmp [ 1 ] ;
12662: LD_ADDR_VAR 0 1
12666: PUSH
12667: LD_VAR 0 2
12671: PUSH
12672: LD_INT 1
12674: ARRAY
12675: ST_TO_ADDR
// end ;
12676: LD_VAR 0 1
12680: RET
// export function SolRu ; var tmp , t ; begin
12681: LD_INT 0
12683: PPUSH
12684: PPUSH
12685: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12686: LD_ADDR_VAR 0 3
12690: PUSH
12691: LD_EXP 31
12695: PUSH
12696: LD_EXP 45
12700: PUSH
12701: LD_EXP 33
12705: PUSH
12706: LD_EXP 46
12710: PUSH
12711: LD_EXP 47
12715: PUSH
12716: LD_EXP 36
12720: PUSH
12721: LD_EXP 37
12725: PUSH
12726: LD_EXP 35
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: LIST
12735: LIST
12736: LIST
12737: LIST
12738: LIST
12739: LIST
12740: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12741: LD_ADDR_VAR 0 2
12745: PUSH
12746: LD_INT 22
12748: PUSH
12749: LD_INT 7
12751: PUSH
12752: EMPTY
12753: LIST
12754: LIST
12755: PUSH
12756: LD_INT 23
12758: PUSH
12759: LD_INT 3
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: PUSH
12766: LD_INT 25
12768: PUSH
12769: LD_INT 1
12771: PUSH
12772: EMPTY
12773: LIST
12774: LIST
12775: PUSH
12776: LD_INT 26
12778: PUSH
12779: LD_INT 1
12781: PUSH
12782: EMPTY
12783: LIST
12784: LIST
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: LIST
12790: LIST
12791: PPUSH
12792: CALL_OW 69
12796: PUSH
12797: LD_VAR 0 3
12801: DIFF
12802: ST_TO_ADDR
// if tmp then
12803: LD_VAR 0 2
12807: IFFALSE 12823
// result := tmp [ 1 ] ;
12809: LD_ADDR_VAR 0 1
12813: PUSH
12814: LD_VAR 0 2
12818: PUSH
12819: LD_INT 1
12821: ARRAY
12822: ST_TO_ADDR
// end ; end_of_file
12823: LD_VAR 0 1
12827: RET
// export function CustomEvent ( event ) ; begin
12828: LD_INT 0
12830: PPUSH
// end ;
12831: LD_VAR 0 2
12835: RET
// on UnitDestroyed ( un ) do var i , side ;
12836: LD_INT 0
12838: PPUSH
12839: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12840: LD_VAR 0 1
12844: PUSH
12845: LD_INT 22
12847: PUSH
12848: LD_INT 7
12850: PUSH
12851: EMPTY
12852: LIST
12853: LIST
12854: PUSH
12855: LD_INT 2
12857: PUSH
12858: LD_INT 25
12860: PUSH
12861: LD_INT 1
12863: PUSH
12864: EMPTY
12865: LIST
12866: LIST
12867: PUSH
12868: LD_INT 25
12870: PUSH
12871: LD_INT 2
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: PUSH
12878: LD_INT 25
12880: PUSH
12881: LD_INT 3
12883: PUSH
12884: EMPTY
12885: LIST
12886: LIST
12887: PUSH
12888: LD_INT 25
12890: PUSH
12891: LD_INT 4
12893: PUSH
12894: EMPTY
12895: LIST
12896: LIST
12897: PUSH
12898: LD_INT 25
12900: PUSH
12901: LD_INT 5
12903: PUSH
12904: EMPTY
12905: LIST
12906: LIST
12907: PUSH
12908: LD_INT 25
12910: PUSH
12911: LD_INT 8
12913: PUSH
12914: EMPTY
12915: LIST
12916: LIST
12917: PUSH
12918: LD_INT 25
12920: PUSH
12921: LD_INT 9
12923: PUSH
12924: EMPTY
12925: LIST
12926: LIST
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: LIST
12932: LIST
12933: LIST
12934: LIST
12935: LIST
12936: LIST
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: PPUSH
12942: CALL_OW 69
12946: IN
12947: IFFALSE 12963
// loss_counter := loss_counter + 1 ;
12949: LD_ADDR_EXP 13
12953: PUSH
12954: LD_EXP 13
12958: PUSH
12959: LD_INT 1
12961: PLUS
12962: ST_TO_ADDR
// if un = Abdul then
12963: LD_VAR 0 1
12967: PUSH
12968: LD_EXP 54
12972: EQUAL
12973: IFFALSE 12983
// abdul_escaped := false ;
12975: LD_ADDR_EXP 12
12979: PUSH
12980: LD_INT 0
12982: ST_TO_ADDR
// if un in ru_attackers then
12983: LD_VAR 0 1
12987: PUSH
12988: LD_EXP 51
12992: IN
12993: IFFALSE 13011
// ru_attackers := ru_attackers diff un ;
12995: LD_ADDR_EXP 51
12999: PUSH
13000: LD_EXP 51
13004: PUSH
13005: LD_VAR 0 1
13009: DIFF
13010: ST_TO_ADDR
// if un in ar_attackers then
13011: LD_VAR 0 1
13015: PUSH
13016: LD_EXP 10
13020: IN
13021: IFFALSE 13039
// ar_attackers := ar_attackers diff un ;
13023: LD_ADDR_EXP 10
13027: PUSH
13028: LD_EXP 10
13032: PUSH
13033: LD_VAR 0 1
13037: DIFF
13038: ST_TO_ADDR
// if un = JMM then
13039: LD_VAR 0 1
13043: PUSH
13044: LD_EXP 14
13048: EQUAL
13049: IFFALSE 13060
// begin YouLost ( JMM ) ;
13051: LD_STRING JMM
13053: PPUSH
13054: CALL_OW 104
// exit ;
13058: GO 13149
// end ; if un = Burlak then
13060: LD_VAR 0 1
13064: PUSH
13065: LD_EXP 45
13069: EQUAL
13070: IFFALSE 13081
// begin YouLost ( Burlak ) ;
13072: LD_STRING Burlak
13074: PPUSH
13075: CALL_OW 104
// exit ;
13079: GO 13149
// end ; if un = freedom then
13081: LD_VAR 0 1
13085: PUSH
13086: LD_EXP 3
13090: EQUAL
13091: IFFALSE 13102
// begin YouLost ( Destroyed ) ;
13093: LD_STRING Destroyed
13095: PPUSH
13096: CALL_OW 104
// exit ;
13100: GO 13149
// end ; if un = Masha then
13102: LD_VAR 0 1
13106: PUSH
13107: LD_EXP 48
13111: EQUAL
13112: IFFALSE 13121
// ChangeMissionObjectives ( M4b ) ;
13114: LD_STRING M4b
13116: PPUSH
13117: CALL_OW 337
// if un = Mastodont then
13121: LD_VAR 0 1
13125: PUSH
13126: LD_EXP 55
13130: EQUAL
13131: IFFALSE 13140
// ChangeMissionObjectives ( M4a ) ;
13133: LD_STRING M4a
13135: PPUSH
13136: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13140: LD_VAR 0 1
13144: PPUSH
13145: CALL 84051 0 1
// end ;
13149: PPOPN 3
13151: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13152: LD_VAR 0 1
13156: PPUSH
13157: LD_VAR 0 2
13161: PPUSH
13162: CALL 86251 0 2
// end ;
13166: PPOPN 2
13168: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13169: LD_VAR 0 1
13173: PPUSH
13174: CALL 85319 0 1
// end ;
13178: PPOPN 1
13180: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13181: LD_VAR 0 1
13185: PUSH
13186: LD_INT 22
13188: PUSH
13189: LD_INT 7
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: PUSH
13196: LD_INT 30
13198: PUSH
13199: LD_INT 0
13201: PUSH
13202: EMPTY
13203: LIST
13204: LIST
13205: PUSH
13206: EMPTY
13207: LIST
13208: LIST
13209: PPUSH
13210: CALL_OW 69
13214: IN
13215: IFFALSE 13254
// begin SetBName ( building , freedom ) ;
13217: LD_VAR 0 1
13221: PPUSH
13222: LD_STRING freedom
13224: PPUSH
13225: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13229: LD_INT 0
13231: PPUSH
13232: LD_INT 7
13234: PPUSH
13235: LD_INT 0
13237: PPUSH
13238: CALL_OW 324
// freedom := building ;
13242: LD_ADDR_EXP 3
13246: PUSH
13247: LD_VAR 0 1
13251: ST_TO_ADDR
// exit ;
13252: GO 13320
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13254: LD_VAR 0 1
13258: PUSH
13259: LD_INT 22
13261: PUSH
13262: LD_INT 7
13264: PUSH
13265: EMPTY
13266: LIST
13267: LIST
13268: PUSH
13269: LD_INT 23
13271: PUSH
13272: LD_INT 3
13274: PUSH
13275: EMPTY
13276: LIST
13277: LIST
13278: PUSH
13279: LD_INT 30
13281: PUSH
13282: LD_INT 6
13284: PUSH
13285: EMPTY
13286: LIST
13287: LIST
13288: PUSH
13289: EMPTY
13290: LIST
13291: LIST
13292: LIST
13293: PPUSH
13294: CALL_OW 69
13298: IN
13299: IFFALSE 13311
// begin ru_lab_builded := true ;
13301: LD_ADDR_EXP 5
13305: PUSH
13306: LD_INT 1
13308: ST_TO_ADDR
// exit ;
13309: GO 13320
// end ; MCE_BuildingComplete ( building ) ;
13311: LD_VAR 0 1
13315: PPUSH
13316: CALL 85560 0 1
// end ;
13320: PPOPN 1
13322: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13323: LD_VAR 0 1
13327: PPUSH
13328: LD_VAR 0 2
13332: PPUSH
13333: CALL 83747 0 2
// end ;
13337: PPOPN 2
13339: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13340: LD_VAR 0 1
13344: PPUSH
13345: LD_VAR 0 2
13349: PPUSH
13350: LD_VAR 0 3
13354: PPUSH
13355: LD_VAR 0 4
13359: PPUSH
13360: LD_VAR 0 5
13364: PPUSH
13365: CALL 83367 0 5
// end ;
13369: PPOPN 5
13371: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13372: LD_VAR 0 1
13376: PPUSH
13377: LD_VAR 0 2
13381: PPUSH
13382: CALL 82963 0 2
// end ;
13386: PPOPN 2
13388: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13389: LD_VAR 0 1
13393: PPUSH
13394: LD_VAR 0 2
13398: PPUSH
13399: LD_VAR 0 3
13403: PPUSH
13404: LD_VAR 0 4
13408: PPUSH
13409: CALL 82801 0 4
// end ;
13413: PPOPN 4
13415: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13416: LD_VAR 0 1
13420: PPUSH
13421: LD_VAR 0 2
13425: PPUSH
13426: LD_VAR 0 3
13430: PPUSH
13431: CALL 82576 0 3
// end ;
13435: PPOPN 3
13437: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_VAR 0 2
13447: PPUSH
13448: CALL 82461 0 2
// end ;
13452: PPOPN 2
13454: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13455: LD_VAR 0 1
13459: PPUSH
13460: LD_VAR 0 2
13464: PPUSH
13465: CALL 86512 0 2
// end ;
13469: PPOPN 2
13471: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13472: LD_VAR 0 1
13476: PPUSH
13477: LD_VAR 0 2
13481: PPUSH
13482: LD_VAR 0 3
13486: PPUSH
13487: LD_VAR 0 4
13491: PPUSH
13492: CALL 86728 0 4
// end ;
13496: PPOPN 4
13498: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13499: LD_VAR 0 1
13503: PPUSH
13504: LD_VAR 0 2
13508: PPUSH
13509: CALL 82270 0 2
// end ;
13513: PPOPN 2
13515: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13516: LD_VAR 0 1
13520: PPUSH
13521: CALL 87011 0 1
// end ; end_of_file
13525: PPOPN 1
13527: END
// every 0 0$30 do var cr , time ;
13528: GO 13530
13530: DISABLE
13531: LD_INT 0
13533: PPUSH
13534: PPUSH
// begin time := 0 0$30 ;
13535: LD_ADDR_VAR 0 2
13539: PUSH
13540: LD_INT 1050
13542: ST_TO_ADDR
// while game do
13543: LD_EXP 2
13547: IFFALSE 13646
// begin wait ( time ) ;
13549: LD_VAR 0 2
13553: PPUSH
13554: CALL_OW 67
// if tick > 2 2$00 then
13558: LD_OWVAR 1
13562: PUSH
13563: LD_INT 4200
13565: GREATER
13566: IFFALSE 13599
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13568: LD_ADDR_VAR 0 2
13572: PUSH
13573: LD_VAR 0 2
13577: PUSH
13578: LD_INT 280
13580: PUSH
13581: LD_INT 420
13583: PUSH
13584: LD_INT 630
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: LIST
13591: PUSH
13592: LD_OWVAR 67
13596: ARRAY
13597: PLUS
13598: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13599: LD_INT 1
13601: PPUSH
13602: LD_INT 5
13604: PPUSH
13605: CALL_OW 12
13609: PPUSH
13610: LD_INT 70
13612: PPUSH
13613: LD_INT 49
13615: PPUSH
13616: LD_INT 25
13618: PPUSH
13619: LD_INT 1
13621: PPUSH
13622: CALL_OW 56
// if time > 5 5$00 then
13626: LD_VAR 0 2
13630: PUSH
13631: LD_INT 10500
13633: GREATER
13634: IFFALSE 13644
// time := 0 0$30 ;
13636: LD_ADDR_VAR 0 2
13640: PUSH
13641: LD_INT 1050
13643: ST_TO_ADDR
// end ;
13644: GO 13543
// end ;
13646: PPOPN 2
13648: END
// every 0 0$30 do var cr , time ;
13649: GO 13651
13651: DISABLE
13652: LD_INT 0
13654: PPUSH
13655: PPUSH
// begin time := 0 0$20 ;
13656: LD_ADDR_VAR 0 2
13660: PUSH
13661: LD_INT 700
13663: ST_TO_ADDR
// while game do
13664: LD_EXP 2
13668: IFFALSE 13757
// begin wait ( time ) ;
13670: LD_VAR 0 2
13674: PPUSH
13675: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13679: LD_ADDR_VAR 0 2
13683: PUSH
13684: LD_VAR 0 2
13688: PUSH
13689: LD_INT 490
13691: PUSH
13692: LD_INT 525
13694: PUSH
13695: LD_INT 560
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: LIST
13702: PUSH
13703: LD_OWVAR 67
13707: ARRAY
13708: PLUS
13709: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13710: LD_INT 3
13712: PPUSH
13713: LD_INT 5
13715: PPUSH
13716: CALL_OW 12
13720: PPUSH
13721: LD_INT 26
13723: PPUSH
13724: LD_INT 9
13726: PPUSH
13727: LD_INT 30
13729: PPUSH
13730: LD_INT 1
13732: PPUSH
13733: CALL_OW 56
// if time > 3 3$00 then
13737: LD_VAR 0 2
13741: PUSH
13742: LD_INT 6300
13744: GREATER
13745: IFFALSE 13755
// time := 0 0$20 ;
13747: LD_ADDR_VAR 0 2
13751: PUSH
13752: LD_INT 700
13754: ST_TO_ADDR
// end ;
13755: GO 13664
// end ;
13757: PPOPN 2
13759: END
// every 0 0$30 do var cr , time ;
13760: GO 13762
13762: DISABLE
13763: LD_INT 0
13765: PPUSH
13766: PPUSH
// begin time := 0 0$20 ;
13767: LD_ADDR_VAR 0 2
13771: PUSH
13772: LD_INT 700
13774: ST_TO_ADDR
// while game do
13775: LD_EXP 2
13779: IFFALSE 13904
// begin wait ( time ) ;
13781: LD_VAR 0 2
13785: PPUSH
13786: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13790: LD_ADDR_VAR 0 2
13794: PUSH
13795: LD_VAR 0 2
13799: PUSH
13800: LD_INT 175
13802: PUSH
13803: LD_INT 210
13805: PUSH
13806: LD_INT 280
13808: PUSH
13809: EMPTY
13810: LIST
13811: LIST
13812: LIST
13813: PUSH
13814: LD_OWVAR 67
13818: ARRAY
13819: PLUS
13820: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13821: LD_INT 1
13823: PPUSH
13824: LD_INT 5
13826: PPUSH
13827: CALL_OW 12
13831: PPUSH
13832: LD_INT 179
13834: PPUSH
13835: LD_INT 101
13837: PPUSH
13838: LD_INT 20
13840: PPUSH
13841: LD_INT 1
13843: PPUSH
13844: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13848: LD_INT 350
13850: PPUSH
13851: LD_INT 525
13853: PPUSH
13854: CALL_OW 12
13858: PPUSH
13859: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13863: LD_INT 1
13865: PPUSH
13866: LD_INT 5
13868: PPUSH
13869: CALL_OW 12
13873: PPUSH
13874: LD_INT 9
13876: PPUSH
13877: LD_INT 1
13879: PPUSH
13880: CALL_OW 55
// if time > 4 4$00 then
13884: LD_VAR 0 2
13888: PUSH
13889: LD_INT 8400
13891: GREATER
13892: IFFALSE 13902
// time := 0 0$30 ;
13894: LD_ADDR_VAR 0 2
13898: PUSH
13899: LD_INT 1050
13901: ST_TO_ADDR
// end ;
13902: GO 13775
// end ;
13904: PPOPN 2
13906: END
// every 0 0$30 do var cr , time ;
13907: GO 13909
13909: DISABLE
13910: LD_INT 0
13912: PPUSH
13913: PPUSH
// begin time := 0 0$10 ;
13914: LD_ADDR_VAR 0 2
13918: PUSH
13919: LD_INT 350
13921: ST_TO_ADDR
// while game do
13922: LD_EXP 2
13926: IFFALSE 14060
// begin wait ( time ) ;
13928: LD_VAR 0 2
13932: PPUSH
13933: CALL_OW 67
// time := time + 0 0$10 ;
13937: LD_ADDR_VAR 0 2
13941: PUSH
13942: LD_VAR 0 2
13946: PUSH
13947: LD_INT 350
13949: PLUS
13950: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13951: LD_INT 1
13953: PPUSH
13954: LD_INT 5
13956: PPUSH
13957: CALL_OW 12
13961: PPUSH
13962: LD_INT 11
13964: PPUSH
13965: LD_INT 1
13967: PPUSH
13968: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13972: LD_ADDR_VAR 0 1
13976: PUSH
13977: LD_INT 1
13979: PPUSH
13980: LD_INT 3
13982: PPUSH
13983: CALL_OW 12
13987: ST_TO_ADDR
// if cr = 1 then
13988: LD_VAR 0 1
13992: PUSH
13993: LD_INT 1
13995: EQUAL
13996: IFFALSE 14040
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13998: LD_INT 700
14000: PPUSH
14001: LD_INT 1575
14003: PPUSH
14004: CALL_OW 12
14008: PPUSH
14009: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14013: LD_INT 1
14015: PPUSH
14016: LD_INT 5
14018: PPUSH
14019: CALL_OW 12
14023: PPUSH
14024: LD_INT 34
14026: PPUSH
14027: LD_INT 50
14029: PPUSH
14030: LD_INT 7
14032: PPUSH
14033: LD_INT 1
14035: PPUSH
14036: CALL_OW 56
// end ; if time > 8 8$00 then
14040: LD_VAR 0 2
14044: PUSH
14045: LD_INT 16800
14047: GREATER
14048: IFFALSE 14058
// time := 0 0$40 ;
14050: LD_ADDR_VAR 0 2
14054: PUSH
14055: LD_INT 1400
14057: ST_TO_ADDR
// end ;
14058: GO 13922
// end ; end_of_file
14060: PPOPN 2
14062: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14063: LD_INT 0
14065: PPUSH
14066: PPUSH
// if exist_mode then
14067: LD_VAR 0 2
14071: IFFALSE 14096
// unit := CreateCharacter ( prefix & ident ) else
14073: LD_ADDR_VAR 0 5
14077: PUSH
14078: LD_VAR 0 3
14082: PUSH
14083: LD_VAR 0 1
14087: STR
14088: PPUSH
14089: CALL_OW 34
14093: ST_TO_ADDR
14094: GO 14111
// unit := NewCharacter ( ident ) ;
14096: LD_ADDR_VAR 0 5
14100: PUSH
14101: LD_VAR 0 1
14105: PPUSH
14106: CALL_OW 25
14110: ST_TO_ADDR
// result := unit ;
14111: LD_ADDR_VAR 0 4
14115: PUSH
14116: LD_VAR 0 5
14120: ST_TO_ADDR
// end ;
14121: LD_VAR 0 4
14125: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14126: LD_INT 0
14128: PPUSH
14129: PPUSH
// if not side or not nation then
14130: LD_VAR 0 1
14134: NOT
14135: PUSH
14136: LD_VAR 0 2
14140: NOT
14141: OR
14142: IFFALSE 14146
// exit ;
14144: GO 14790
// case nation of nation_american :
14146: LD_VAR 0 2
14150: PUSH
14151: LD_INT 1
14153: DOUBLE
14154: EQUAL
14155: IFTRUE 14159
14157: GO 14333
14159: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14160: LD_ADDR_VAR 0 4
14164: PUSH
14165: LD_INT 35
14167: PUSH
14168: LD_INT 45
14170: PUSH
14171: LD_INT 46
14173: PUSH
14174: LD_INT 47
14176: PUSH
14177: LD_INT 1
14179: PUSH
14180: LD_INT 2
14182: PUSH
14183: LD_INT 6
14185: PUSH
14186: LD_INT 15
14188: PUSH
14189: LD_INT 16
14191: PUSH
14192: LD_INT 7
14194: PUSH
14195: LD_INT 12
14197: PUSH
14198: LD_INT 13
14200: PUSH
14201: LD_INT 10
14203: PUSH
14204: LD_INT 14
14206: PUSH
14207: LD_INT 20
14209: PUSH
14210: LD_INT 21
14212: PUSH
14213: LD_INT 22
14215: PUSH
14216: LD_INT 25
14218: PUSH
14219: LD_INT 32
14221: PUSH
14222: LD_INT 27
14224: PUSH
14225: LD_INT 36
14227: PUSH
14228: LD_INT 69
14230: PUSH
14231: LD_INT 39
14233: PUSH
14234: LD_INT 34
14236: PUSH
14237: LD_INT 40
14239: PUSH
14240: LD_INT 48
14242: PUSH
14243: LD_INT 49
14245: PUSH
14246: LD_INT 50
14248: PUSH
14249: LD_INT 51
14251: PUSH
14252: LD_INT 52
14254: PUSH
14255: LD_INT 53
14257: PUSH
14258: LD_INT 54
14260: PUSH
14261: LD_INT 55
14263: PUSH
14264: LD_INT 56
14266: PUSH
14267: LD_INT 57
14269: PUSH
14270: LD_INT 58
14272: PUSH
14273: LD_INT 59
14275: PUSH
14276: LD_INT 60
14278: PUSH
14279: LD_INT 61
14281: PUSH
14282: LD_INT 62
14284: PUSH
14285: LD_INT 80
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: LIST
14298: LIST
14299: LIST
14300: LIST
14301: LIST
14302: LIST
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: LIST
14308: LIST
14309: LIST
14310: LIST
14311: LIST
14312: LIST
14313: LIST
14314: LIST
14315: LIST
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: ST_TO_ADDR
14331: GO 14714
14333: LD_INT 2
14335: DOUBLE
14336: EQUAL
14337: IFTRUE 14341
14339: GO 14523
14341: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14342: LD_ADDR_VAR 0 4
14346: PUSH
14347: LD_INT 35
14349: PUSH
14350: LD_INT 45
14352: PUSH
14353: LD_INT 46
14355: PUSH
14356: LD_INT 47
14358: PUSH
14359: LD_INT 70
14361: PUSH
14362: LD_INT 1
14364: PUSH
14365: LD_INT 11
14367: PUSH
14368: LD_INT 3
14370: PUSH
14371: LD_INT 4
14373: PUSH
14374: LD_INT 5
14376: PUSH
14377: LD_INT 6
14379: PUSH
14380: LD_INT 15
14382: PUSH
14383: LD_INT 18
14385: PUSH
14386: LD_INT 7
14388: PUSH
14389: LD_INT 17
14391: PUSH
14392: LD_INT 8
14394: PUSH
14395: LD_INT 20
14397: PUSH
14398: LD_INT 21
14400: PUSH
14401: LD_INT 22
14403: PUSH
14404: LD_INT 72
14406: PUSH
14407: LD_INT 26
14409: PUSH
14410: LD_INT 69
14412: PUSH
14413: LD_INT 39
14415: PUSH
14416: LD_INT 40
14418: PUSH
14419: LD_INT 41
14421: PUSH
14422: LD_INT 42
14424: PUSH
14425: LD_INT 43
14427: PUSH
14428: LD_INT 48
14430: PUSH
14431: LD_INT 49
14433: PUSH
14434: LD_INT 50
14436: PUSH
14437: LD_INT 51
14439: PUSH
14440: LD_INT 52
14442: PUSH
14443: LD_INT 53
14445: PUSH
14446: LD_INT 54
14448: PUSH
14449: LD_INT 55
14451: PUSH
14452: LD_INT 56
14454: PUSH
14455: LD_INT 60
14457: PUSH
14458: LD_INT 61
14460: PUSH
14461: LD_INT 62
14463: PUSH
14464: LD_INT 66
14466: PUSH
14467: LD_INT 67
14469: PUSH
14470: LD_INT 68
14472: PUSH
14473: LD_INT 81
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: LIST
14480: LIST
14481: LIST
14482: LIST
14483: LIST
14484: LIST
14485: LIST
14486: LIST
14487: LIST
14488: LIST
14489: LIST
14490: LIST
14491: LIST
14492: LIST
14493: LIST
14494: LIST
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: LIST
14501: LIST
14502: LIST
14503: LIST
14504: LIST
14505: LIST
14506: LIST
14507: LIST
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: ST_TO_ADDR
14521: GO 14714
14523: LD_INT 3
14525: DOUBLE
14526: EQUAL
14527: IFTRUE 14531
14529: GO 14713
14531: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14532: LD_ADDR_VAR 0 4
14536: PUSH
14537: LD_INT 46
14539: PUSH
14540: LD_INT 47
14542: PUSH
14543: LD_INT 1
14545: PUSH
14546: LD_INT 2
14548: PUSH
14549: LD_INT 11
14551: PUSH
14552: LD_INT 9
14554: PUSH
14555: LD_INT 20
14557: PUSH
14558: LD_INT 19
14560: PUSH
14561: LD_INT 21
14563: PUSH
14564: LD_INT 24
14566: PUSH
14567: LD_INT 22
14569: PUSH
14570: LD_INT 25
14572: PUSH
14573: LD_INT 28
14575: PUSH
14576: LD_INT 29
14578: PUSH
14579: LD_INT 30
14581: PUSH
14582: LD_INT 31
14584: PUSH
14585: LD_INT 37
14587: PUSH
14588: LD_INT 38
14590: PUSH
14591: LD_INT 32
14593: PUSH
14594: LD_INT 27
14596: PUSH
14597: LD_INT 33
14599: PUSH
14600: LD_INT 69
14602: PUSH
14603: LD_INT 39
14605: PUSH
14606: LD_INT 34
14608: PUSH
14609: LD_INT 40
14611: PUSH
14612: LD_INT 71
14614: PUSH
14615: LD_INT 23
14617: PUSH
14618: LD_INT 44
14620: PUSH
14621: LD_INT 48
14623: PUSH
14624: LD_INT 49
14626: PUSH
14627: LD_INT 50
14629: PUSH
14630: LD_INT 51
14632: PUSH
14633: LD_INT 52
14635: PUSH
14636: LD_INT 53
14638: PUSH
14639: LD_INT 54
14641: PUSH
14642: LD_INT 55
14644: PUSH
14645: LD_INT 56
14647: PUSH
14648: LD_INT 57
14650: PUSH
14651: LD_INT 58
14653: PUSH
14654: LD_INT 59
14656: PUSH
14657: LD_INT 63
14659: PUSH
14660: LD_INT 64
14662: PUSH
14663: LD_INT 65
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: LIST
14670: LIST
14671: LIST
14672: LIST
14673: LIST
14674: LIST
14675: LIST
14676: LIST
14677: LIST
14678: LIST
14679: LIST
14680: LIST
14681: LIST
14682: LIST
14683: LIST
14684: LIST
14685: LIST
14686: LIST
14687: LIST
14688: LIST
14689: LIST
14690: LIST
14691: LIST
14692: LIST
14693: LIST
14694: LIST
14695: LIST
14696: LIST
14697: LIST
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: LIST
14707: LIST
14708: LIST
14709: LIST
14710: ST_TO_ADDR
14711: GO 14714
14713: POP
// if state > - 1 and state < 3 then
14714: LD_VAR 0 3
14718: PUSH
14719: LD_INT 1
14721: NEG
14722: GREATER
14723: PUSH
14724: LD_VAR 0 3
14728: PUSH
14729: LD_INT 3
14731: LESS
14732: AND
14733: IFFALSE 14790
// for i in result do
14735: LD_ADDR_VAR 0 5
14739: PUSH
14740: LD_VAR 0 4
14744: PUSH
14745: FOR_IN
14746: IFFALSE 14788
// if GetTech ( i , side ) <> state then
14748: LD_VAR 0 5
14752: PPUSH
14753: LD_VAR 0 1
14757: PPUSH
14758: CALL_OW 321
14762: PUSH
14763: LD_VAR 0 3
14767: NONEQUAL
14768: IFFALSE 14786
// result := result diff i ;
14770: LD_ADDR_VAR 0 4
14774: PUSH
14775: LD_VAR 0 4
14779: PUSH
14780: LD_VAR 0 5
14784: DIFF
14785: ST_TO_ADDR
14786: GO 14745
14788: POP
14789: POP
// end ;
14790: LD_VAR 0 4
14794: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14795: LD_INT 0
14797: PPUSH
14798: PPUSH
14799: PPUSH
// result := true ;
14800: LD_ADDR_VAR 0 3
14804: PUSH
14805: LD_INT 1
14807: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14808: LD_ADDR_VAR 0 5
14812: PUSH
14813: LD_VAR 0 2
14817: PPUSH
14818: CALL_OW 480
14822: ST_TO_ADDR
// if not tmp then
14823: LD_VAR 0 5
14827: NOT
14828: IFFALSE 14832
// exit ;
14830: GO 14881
// for i in tmp do
14832: LD_ADDR_VAR 0 4
14836: PUSH
14837: LD_VAR 0 5
14841: PUSH
14842: FOR_IN
14843: IFFALSE 14879
// if GetTech ( i , side ) <> state_researched then
14845: LD_VAR 0 4
14849: PPUSH
14850: LD_VAR 0 1
14854: PPUSH
14855: CALL_OW 321
14859: PUSH
14860: LD_INT 2
14862: NONEQUAL
14863: IFFALSE 14877
// begin result := false ;
14865: LD_ADDR_VAR 0 3
14869: PUSH
14870: LD_INT 0
14872: ST_TO_ADDR
// exit ;
14873: POP
14874: POP
14875: GO 14881
// end ;
14877: GO 14842
14879: POP
14880: POP
// end ;
14881: LD_VAR 0 3
14885: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14886: LD_INT 0
14888: PPUSH
14889: PPUSH
14890: PPUSH
14891: PPUSH
14892: PPUSH
14893: PPUSH
14894: PPUSH
14895: PPUSH
14896: PPUSH
14897: PPUSH
14898: PPUSH
14899: PPUSH
14900: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14901: LD_VAR 0 1
14905: NOT
14906: PUSH
14907: LD_VAR 0 1
14911: PPUSH
14912: CALL_OW 257
14916: PUSH
14917: LD_INT 9
14919: NONEQUAL
14920: OR
14921: IFFALSE 14925
// exit ;
14923: GO 15498
// side := GetSide ( unit ) ;
14925: LD_ADDR_VAR 0 9
14929: PUSH
14930: LD_VAR 0 1
14934: PPUSH
14935: CALL_OW 255
14939: ST_TO_ADDR
// tech_space := tech_spacanom ;
14940: LD_ADDR_VAR 0 12
14944: PUSH
14945: LD_INT 29
14947: ST_TO_ADDR
// tech_time := tech_taurad ;
14948: LD_ADDR_VAR 0 13
14952: PUSH
14953: LD_INT 28
14955: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14956: LD_ADDR_VAR 0 11
14960: PUSH
14961: LD_VAR 0 1
14965: PPUSH
14966: CALL_OW 310
14970: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14971: LD_VAR 0 11
14975: PPUSH
14976: CALL_OW 247
14980: PUSH
14981: LD_INT 2
14983: EQUAL
14984: IFFALSE 14988
// exit ;
14986: GO 15498
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14988: LD_ADDR_VAR 0 8
14992: PUSH
14993: LD_INT 81
14995: PUSH
14996: LD_VAR 0 9
15000: PUSH
15001: EMPTY
15002: LIST
15003: LIST
15004: PUSH
15005: LD_INT 3
15007: PUSH
15008: LD_INT 21
15010: PUSH
15011: LD_INT 3
15013: PUSH
15014: EMPTY
15015: LIST
15016: LIST
15017: PUSH
15018: EMPTY
15019: LIST
15020: LIST
15021: PUSH
15022: EMPTY
15023: LIST
15024: LIST
15025: PPUSH
15026: CALL_OW 69
15030: ST_TO_ADDR
// if not tmp then
15031: LD_VAR 0 8
15035: NOT
15036: IFFALSE 15040
// exit ;
15038: GO 15498
// if in_unit then
15040: LD_VAR 0 11
15044: IFFALSE 15068
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15046: LD_ADDR_VAR 0 10
15050: PUSH
15051: LD_VAR 0 8
15055: PPUSH
15056: LD_VAR 0 11
15060: PPUSH
15061: CALL_OW 74
15065: ST_TO_ADDR
15066: GO 15088
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15068: LD_ADDR_VAR 0 10
15072: PUSH
15073: LD_VAR 0 8
15077: PPUSH
15078: LD_VAR 0 1
15082: PPUSH
15083: CALL_OW 74
15087: ST_TO_ADDR
// if not enemy then
15088: LD_VAR 0 10
15092: NOT
15093: IFFALSE 15097
// exit ;
15095: GO 15498
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15097: LD_VAR 0 11
15101: PUSH
15102: LD_VAR 0 11
15106: PPUSH
15107: LD_VAR 0 10
15111: PPUSH
15112: CALL_OW 296
15116: PUSH
15117: LD_INT 13
15119: GREATER
15120: AND
15121: PUSH
15122: LD_VAR 0 1
15126: PPUSH
15127: LD_VAR 0 10
15131: PPUSH
15132: CALL_OW 296
15136: PUSH
15137: LD_INT 12
15139: GREATER
15140: OR
15141: IFFALSE 15145
// exit ;
15143: GO 15498
// missile := [ 1 ] ;
15145: LD_ADDR_VAR 0 14
15149: PUSH
15150: LD_INT 1
15152: PUSH
15153: EMPTY
15154: LIST
15155: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15156: LD_VAR 0 9
15160: PPUSH
15161: LD_VAR 0 12
15165: PPUSH
15166: CALL_OW 325
15170: IFFALSE 15199
// missile := Insert ( missile , missile + 1 , 2 ) ;
15172: LD_ADDR_VAR 0 14
15176: PUSH
15177: LD_VAR 0 14
15181: PPUSH
15182: LD_VAR 0 14
15186: PUSH
15187: LD_INT 1
15189: PLUS
15190: PPUSH
15191: LD_INT 2
15193: PPUSH
15194: CALL_OW 2
15198: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15199: LD_VAR 0 9
15203: PPUSH
15204: LD_VAR 0 13
15208: PPUSH
15209: CALL_OW 325
15213: PUSH
15214: LD_VAR 0 10
15218: PPUSH
15219: CALL_OW 255
15223: PPUSH
15224: LD_VAR 0 13
15228: PPUSH
15229: CALL_OW 325
15233: NOT
15234: AND
15235: IFFALSE 15264
// missile := Insert ( missile , missile + 1 , 3 ) ;
15237: LD_ADDR_VAR 0 14
15241: PUSH
15242: LD_VAR 0 14
15246: PPUSH
15247: LD_VAR 0 14
15251: PUSH
15252: LD_INT 1
15254: PLUS
15255: PPUSH
15256: LD_INT 3
15258: PPUSH
15259: CALL_OW 2
15263: ST_TO_ADDR
// if missile < 2 then
15264: LD_VAR 0 14
15268: PUSH
15269: LD_INT 2
15271: LESS
15272: IFFALSE 15276
// exit ;
15274: GO 15498
// x := GetX ( enemy ) ;
15276: LD_ADDR_VAR 0 4
15280: PUSH
15281: LD_VAR 0 10
15285: PPUSH
15286: CALL_OW 250
15290: ST_TO_ADDR
// y := GetY ( enemy ) ;
15291: LD_ADDR_VAR 0 5
15295: PUSH
15296: LD_VAR 0 10
15300: PPUSH
15301: CALL_OW 251
15305: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15306: LD_ADDR_VAR 0 6
15310: PUSH
15311: LD_VAR 0 4
15315: PUSH
15316: LD_INT 1
15318: NEG
15319: PPUSH
15320: LD_INT 1
15322: PPUSH
15323: CALL_OW 12
15327: PLUS
15328: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15329: LD_ADDR_VAR 0 7
15333: PUSH
15334: LD_VAR 0 5
15338: PUSH
15339: LD_INT 1
15341: NEG
15342: PPUSH
15343: LD_INT 1
15345: PPUSH
15346: CALL_OW 12
15350: PLUS
15351: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15352: LD_VAR 0 6
15356: PPUSH
15357: LD_VAR 0 7
15361: PPUSH
15362: CALL_OW 488
15366: NOT
15367: IFFALSE 15389
// begin _x := x ;
15369: LD_ADDR_VAR 0 6
15373: PUSH
15374: LD_VAR 0 4
15378: ST_TO_ADDR
// _y := y ;
15379: LD_ADDR_VAR 0 7
15383: PUSH
15384: LD_VAR 0 5
15388: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15389: LD_ADDR_VAR 0 3
15393: PUSH
15394: LD_INT 1
15396: PPUSH
15397: LD_VAR 0 14
15401: PPUSH
15402: CALL_OW 12
15406: ST_TO_ADDR
// case i of 1 :
15407: LD_VAR 0 3
15411: PUSH
15412: LD_INT 1
15414: DOUBLE
15415: EQUAL
15416: IFTRUE 15420
15418: GO 15437
15420: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15421: LD_VAR 0 1
15425: PPUSH
15426: LD_VAR 0 10
15430: PPUSH
15431: CALL_OW 115
15435: GO 15498
15437: LD_INT 2
15439: DOUBLE
15440: EQUAL
15441: IFTRUE 15445
15443: GO 15467
15445: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15446: LD_VAR 0 1
15450: PPUSH
15451: LD_VAR 0 6
15455: PPUSH
15456: LD_VAR 0 7
15460: PPUSH
15461: CALL_OW 153
15465: GO 15498
15467: LD_INT 3
15469: DOUBLE
15470: EQUAL
15471: IFTRUE 15475
15473: GO 15497
15475: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15476: LD_VAR 0 1
15480: PPUSH
15481: LD_VAR 0 6
15485: PPUSH
15486: LD_VAR 0 7
15490: PPUSH
15491: CALL_OW 154
15495: GO 15498
15497: POP
// end ;
15498: LD_VAR 0 2
15502: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15503: LD_INT 0
15505: PPUSH
15506: PPUSH
15507: PPUSH
15508: PPUSH
15509: PPUSH
15510: PPUSH
// if not unit or not building then
15511: LD_VAR 0 1
15515: NOT
15516: PUSH
15517: LD_VAR 0 2
15521: NOT
15522: OR
15523: IFFALSE 15527
// exit ;
15525: GO 15685
// x := GetX ( building ) ;
15527: LD_ADDR_VAR 0 5
15531: PUSH
15532: LD_VAR 0 2
15536: PPUSH
15537: CALL_OW 250
15541: ST_TO_ADDR
// y := GetY ( building ) ;
15542: LD_ADDR_VAR 0 6
15546: PUSH
15547: LD_VAR 0 2
15551: PPUSH
15552: CALL_OW 251
15556: ST_TO_ADDR
// for i = 0 to 5 do
15557: LD_ADDR_VAR 0 4
15561: PUSH
15562: DOUBLE
15563: LD_INT 0
15565: DEC
15566: ST_TO_ADDR
15567: LD_INT 5
15569: PUSH
15570: FOR_TO
15571: IFFALSE 15683
// begin _x := ShiftX ( x , i , 3 ) ;
15573: LD_ADDR_VAR 0 7
15577: PUSH
15578: LD_VAR 0 5
15582: PPUSH
15583: LD_VAR 0 4
15587: PPUSH
15588: LD_INT 3
15590: PPUSH
15591: CALL_OW 272
15595: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15596: LD_ADDR_VAR 0 8
15600: PUSH
15601: LD_VAR 0 6
15605: PPUSH
15606: LD_VAR 0 4
15610: PPUSH
15611: LD_INT 3
15613: PPUSH
15614: CALL_OW 273
15618: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15619: LD_VAR 0 7
15623: PPUSH
15624: LD_VAR 0 8
15628: PPUSH
15629: CALL_OW 488
15633: NOT
15634: IFFALSE 15638
// continue ;
15636: GO 15570
// if HexInfo ( _x , _y ) = 0 then
15638: LD_VAR 0 7
15642: PPUSH
15643: LD_VAR 0 8
15647: PPUSH
15648: CALL_OW 428
15652: PUSH
15653: LD_INT 0
15655: EQUAL
15656: IFFALSE 15681
// begin ComMoveXY ( unit , _x , _y ) ;
15658: LD_VAR 0 1
15662: PPUSH
15663: LD_VAR 0 7
15667: PPUSH
15668: LD_VAR 0 8
15672: PPUSH
15673: CALL_OW 111
// exit ;
15677: POP
15678: POP
15679: GO 15685
// end ; end ;
15681: GO 15570
15683: POP
15684: POP
// end ;
15685: LD_VAR 0 3
15689: RET
// export function ScanBase ( side , base_area ) ; begin
15690: LD_INT 0
15692: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15693: LD_ADDR_VAR 0 3
15697: PUSH
15698: LD_VAR 0 2
15702: PPUSH
15703: LD_INT 81
15705: PUSH
15706: LD_VAR 0 1
15710: PUSH
15711: EMPTY
15712: LIST
15713: LIST
15714: PPUSH
15715: CALL_OW 70
15719: ST_TO_ADDR
// end ;
15720: LD_VAR 0 3
15724: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15725: LD_INT 0
15727: PPUSH
15728: PPUSH
15729: PPUSH
15730: PPUSH
15731: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15732: LD_VAR 0 1
15736: NOT
15737: PUSH
15738: LD_EXP 58
15742: PUSH
15743: LD_VAR 0 1
15747: ARRAY
15748: NOT
15749: OR
15750: PUSH
15751: LD_VAR 0 2
15755: NOT
15756: OR
15757: PUSH
15758: LD_VAR 0 3
15762: NOT
15763: OR
15764: IFFALSE 15768
// exit ;
15766: GO 16281
// side := mc_sides [ base ] ;
15768: LD_ADDR_VAR 0 6
15772: PUSH
15773: LD_EXP 84
15777: PUSH
15778: LD_VAR 0 1
15782: ARRAY
15783: ST_TO_ADDR
// if not side then
15784: LD_VAR 0 6
15788: NOT
15789: IFFALSE 15793
// exit ;
15791: GO 16281
// for i in solds do
15793: LD_ADDR_VAR 0 7
15797: PUSH
15798: LD_VAR 0 2
15802: PUSH
15803: FOR_IN
15804: IFFALSE 15865
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15806: LD_VAR 0 7
15810: PPUSH
15811: CALL_OW 310
15815: PPUSH
15816: CALL_OW 266
15820: PUSH
15821: LD_INT 32
15823: PUSH
15824: LD_INT 31
15826: PUSH
15827: EMPTY
15828: LIST
15829: LIST
15830: IN
15831: IFFALSE 15851
// solds := solds diff i else
15833: LD_ADDR_VAR 0 2
15837: PUSH
15838: LD_VAR 0 2
15842: PUSH
15843: LD_VAR 0 7
15847: DIFF
15848: ST_TO_ADDR
15849: GO 15863
// SetTag ( i , 18 ) ;
15851: LD_VAR 0 7
15855: PPUSH
15856: LD_INT 18
15858: PPUSH
15859: CALL_OW 109
15863: GO 15803
15865: POP
15866: POP
// if not solds then
15867: LD_VAR 0 2
15871: NOT
15872: IFFALSE 15876
// exit ;
15874: GO 16281
// repeat wait ( 0 0$1 ) ;
15876: LD_INT 35
15878: PPUSH
15879: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15883: LD_ADDR_VAR 0 5
15887: PUSH
15888: LD_VAR 0 6
15892: PPUSH
15893: LD_VAR 0 3
15897: PPUSH
15898: CALL 15690 0 2
15902: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
15903: LD_EXP 58
15907: PUSH
15908: LD_VAR 0 1
15912: ARRAY
15913: NOT
15914: PUSH
15915: LD_EXP 58
15919: PUSH
15920: LD_VAR 0 1
15924: ARRAY
15925: PUSH
15926: EMPTY
15927: EQUAL
15928: OR
15929: IFFALSE 15966
// begin for i in solds do
15931: LD_ADDR_VAR 0 7
15935: PUSH
15936: LD_VAR 0 2
15940: PUSH
15941: FOR_IN
15942: IFFALSE 15955
// ComStop ( i ) ;
15944: LD_VAR 0 7
15948: PPUSH
15949: CALL_OW 141
15953: GO 15941
15955: POP
15956: POP
// solds := [ ] ;
15957: LD_ADDR_VAR 0 2
15961: PUSH
15962: EMPTY
15963: ST_TO_ADDR
// exit ;
15964: GO 16281
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
15966: LD_VAR 0 5
15970: NOT
15971: PUSH
15972: LD_VAR 0 5
15976: PUSH
15977: LD_INT 3
15979: GREATER
15980: OR
15981: PUSH
15982: LD_EXP 80
15986: PUSH
15987: LD_VAR 0 1
15991: ARRAY
15992: OR
15993: IFFALSE 16034
// begin for i in solds do
15995: LD_ADDR_VAR 0 7
15999: PUSH
16000: LD_VAR 0 2
16004: PUSH
16005: FOR_IN
16006: IFFALSE 16030
// if HasTask ( i ) then
16008: LD_VAR 0 7
16012: PPUSH
16013: CALL_OW 314
16017: IFFALSE 16028
// ComStop ( i ) ;
16019: LD_VAR 0 7
16023: PPUSH
16024: CALL_OW 141
16028: GO 16005
16030: POP
16031: POP
// break ;
16032: GO 16269
// end ; for i in solds do
16034: LD_ADDR_VAR 0 7
16038: PUSH
16039: LD_VAR 0 2
16043: PUSH
16044: FOR_IN
16045: IFFALSE 16261
// begin if IsInUnit ( i ) then
16047: LD_VAR 0 7
16051: PPUSH
16052: CALL_OW 310
16056: IFFALSE 16067
// ComExitBuilding ( i ) ;
16058: LD_VAR 0 7
16062: PPUSH
16063: CALL_OW 122
// if GetLives ( i ) > 333 then
16067: LD_VAR 0 7
16071: PPUSH
16072: CALL_OW 256
16076: PUSH
16077: LD_INT 333
16079: GREATER
16080: IFFALSE 16108
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16082: LD_VAR 0 7
16086: PPUSH
16087: LD_VAR 0 5
16091: PPUSH
16092: LD_VAR 0 7
16096: PPUSH
16097: CALL_OW 74
16101: PPUSH
16102: CALL_OW 115
16106: GO 16259
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
16108: LD_ADDR_VAR 0 8
16112: PUSH
16113: LD_EXP 58
16117: PUSH
16118: LD_VAR 0 1
16122: ARRAY
16123: PPUSH
16124: LD_INT 2
16126: PUSH
16127: LD_INT 30
16129: PUSH
16130: LD_INT 0
16132: PUSH
16133: EMPTY
16134: LIST
16135: LIST
16136: PUSH
16137: LD_INT 30
16139: PUSH
16140: LD_INT 1
16142: PUSH
16143: EMPTY
16144: LIST
16145: LIST
16146: PUSH
16147: LD_INT 30
16149: PUSH
16150: LD_INT 6
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: PUSH
16157: EMPTY
16158: LIST
16159: LIST
16160: LIST
16161: LIST
16162: PPUSH
16163: CALL_OW 72
16167: PPUSH
16168: LD_VAR 0 7
16172: PPUSH
16173: CALL_OW 74
16177: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16178: LD_VAR 0 7
16182: PPUSH
16183: LD_VAR 0 8
16187: PPUSH
16188: CALL_OW 250
16192: PPUSH
16193: LD_INT 3
16195: PPUSH
16196: LD_INT 5
16198: PPUSH
16199: CALL_OW 272
16203: PPUSH
16204: LD_VAR 0 8
16208: PPUSH
16209: CALL_OW 251
16213: PPUSH
16214: LD_INT 3
16216: PPUSH
16217: LD_INT 5
16219: PPUSH
16220: CALL_OW 273
16224: PPUSH
16225: CALL_OW 111
// SetTag ( i , 0 ) ;
16229: LD_VAR 0 7
16233: PPUSH
16234: LD_INT 0
16236: PPUSH
16237: CALL_OW 109
// solds := solds diff i ;
16241: LD_ADDR_VAR 0 2
16245: PUSH
16246: LD_VAR 0 2
16250: PUSH
16251: LD_VAR 0 7
16255: DIFF
16256: ST_TO_ADDR
// continue ;
16257: GO 16044
// end ; end ;
16259: GO 16044
16261: POP
16262: POP
// until solds ;
16263: LD_VAR 0 2
16267: IFFALSE 15876
// MC_Reset ( base , 18 ) ;
16269: LD_VAR 0 1
16273: PPUSH
16274: LD_INT 18
16276: PPUSH
16277: CALL 61154 0 2
// end ;
16281: LD_VAR 0 4
16285: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16286: LD_INT 0
16288: PPUSH
16289: PPUSH
16290: PPUSH
16291: PPUSH
16292: PPUSH
16293: PPUSH
16294: PPUSH
16295: PPUSH
16296: PPUSH
16297: PPUSH
16298: PPUSH
16299: PPUSH
16300: PPUSH
16301: PPUSH
16302: PPUSH
16303: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16304: LD_ADDR_VAR 0 12
16308: PUSH
16309: LD_EXP 58
16313: PUSH
16314: LD_VAR 0 1
16318: ARRAY
16319: PPUSH
16320: LD_INT 25
16322: PUSH
16323: LD_INT 3
16325: PUSH
16326: EMPTY
16327: LIST
16328: LIST
16329: PPUSH
16330: CALL_OW 72
16334: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16335: LD_EXP 98
16339: PUSH
16340: LD_VAR 0 1
16344: ARRAY
16345: IFFALSE 16369
// mechs := mechs diff mc_remote_driver [ base ] ;
16347: LD_ADDR_VAR 0 12
16351: PUSH
16352: LD_VAR 0 12
16356: PUSH
16357: LD_EXP 98
16361: PUSH
16362: LD_VAR 0 1
16366: ARRAY
16367: DIFF
16368: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16369: LD_ADDR_VAR 0 8
16373: PUSH
16374: LD_EXP 58
16378: PUSH
16379: LD_VAR 0 1
16383: ARRAY
16384: PPUSH
16385: LD_INT 2
16387: PUSH
16388: LD_INT 25
16390: PUSH
16391: LD_INT 1
16393: PUSH
16394: EMPTY
16395: LIST
16396: LIST
16397: PUSH
16398: LD_INT 25
16400: PUSH
16401: LD_INT 5
16403: PUSH
16404: EMPTY
16405: LIST
16406: LIST
16407: PUSH
16408: LD_INT 25
16410: PUSH
16411: LD_INT 8
16413: PUSH
16414: EMPTY
16415: LIST
16416: LIST
16417: PUSH
16418: LD_INT 25
16420: PUSH
16421: LD_INT 9
16423: PUSH
16424: EMPTY
16425: LIST
16426: LIST
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: LIST
16432: LIST
16433: LIST
16434: PPUSH
16435: CALL_OW 72
16439: ST_TO_ADDR
// if not defenders and not solds then
16440: LD_VAR 0 2
16444: NOT
16445: PUSH
16446: LD_VAR 0 8
16450: NOT
16451: AND
16452: IFFALSE 16456
// exit ;
16454: GO 17982
// depot_under_attack := false ;
16456: LD_ADDR_VAR 0 16
16460: PUSH
16461: LD_INT 0
16463: ST_TO_ADDR
// sold_defenders := [ ] ;
16464: LD_ADDR_VAR 0 17
16468: PUSH
16469: EMPTY
16470: ST_TO_ADDR
// if mechs then
16471: LD_VAR 0 12
16475: IFFALSE 16604
// for i in defenders do
16477: LD_ADDR_VAR 0 5
16481: PUSH
16482: LD_VAR 0 2
16486: PUSH
16487: FOR_IN
16488: IFFALSE 16602
// begin SetTag ( i , 20 ) ;
16490: LD_VAR 0 5
16494: PPUSH
16495: LD_INT 20
16497: PPUSH
16498: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16502: LD_VAR 0 5
16506: PPUSH
16507: CALL_OW 263
16511: PUSH
16512: LD_INT 1
16514: EQUAL
16515: PUSH
16516: LD_VAR 0 5
16520: PPUSH
16521: CALL_OW 311
16525: NOT
16526: AND
16527: PUSH
16528: LD_VAR 0 12
16532: AND
16533: IFFALSE 16600
// begin un := mechs [ 1 ] ;
16535: LD_ADDR_VAR 0 10
16539: PUSH
16540: LD_VAR 0 12
16544: PUSH
16545: LD_INT 1
16547: ARRAY
16548: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16549: LD_VAR 0 10
16553: PPUSH
16554: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16558: LD_VAR 0 10
16562: PPUSH
16563: LD_VAR 0 5
16567: PPUSH
16568: CALL_OW 180
// SetTag ( un , 19 ) ;
16572: LD_VAR 0 10
16576: PPUSH
16577: LD_INT 19
16579: PPUSH
16580: CALL_OW 109
// mechs := mechs diff un ;
16584: LD_ADDR_VAR 0 12
16588: PUSH
16589: LD_VAR 0 12
16593: PUSH
16594: LD_VAR 0 10
16598: DIFF
16599: ST_TO_ADDR
// end ; end ;
16600: GO 16487
16602: POP
16603: POP
// if solds then
16604: LD_VAR 0 8
16608: IFFALSE 16667
// for i in solds do
16610: LD_ADDR_VAR 0 5
16614: PUSH
16615: LD_VAR 0 8
16619: PUSH
16620: FOR_IN
16621: IFFALSE 16665
// if not GetTag ( i ) then
16623: LD_VAR 0 5
16627: PPUSH
16628: CALL_OW 110
16632: NOT
16633: IFFALSE 16663
// begin defenders := defenders union i ;
16635: LD_ADDR_VAR 0 2
16639: PUSH
16640: LD_VAR 0 2
16644: PUSH
16645: LD_VAR 0 5
16649: UNION
16650: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16651: LD_VAR 0 5
16655: PPUSH
16656: LD_INT 18
16658: PPUSH
16659: CALL_OW 109
// end ;
16663: GO 16620
16665: POP
16666: POP
// repeat wait ( 0 0$1 ) ;
16667: LD_INT 35
16669: PPUSH
16670: CALL_OW 67
// enemy := mc_scan [ base ] ;
16674: LD_ADDR_VAR 0 3
16678: PUSH
16679: LD_EXP 81
16683: PUSH
16684: LD_VAR 0 1
16688: ARRAY
16689: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16690: LD_EXP 58
16694: PUSH
16695: LD_VAR 0 1
16699: ARRAY
16700: NOT
16701: PUSH
16702: LD_EXP 58
16706: PUSH
16707: LD_VAR 0 1
16711: ARRAY
16712: PUSH
16713: EMPTY
16714: EQUAL
16715: OR
16716: IFFALSE 16753
// begin for i in defenders do
16718: LD_ADDR_VAR 0 5
16722: PUSH
16723: LD_VAR 0 2
16727: PUSH
16728: FOR_IN
16729: IFFALSE 16742
// ComStop ( i ) ;
16731: LD_VAR 0 5
16735: PPUSH
16736: CALL_OW 141
16740: GO 16728
16742: POP
16743: POP
// defenders := [ ] ;
16744: LD_ADDR_VAR 0 2
16748: PUSH
16749: EMPTY
16750: ST_TO_ADDR
// exit ;
16751: GO 17982
// end ; for i in defenders do
16753: LD_ADDR_VAR 0 5
16757: PUSH
16758: LD_VAR 0 2
16762: PUSH
16763: FOR_IN
16764: IFFALSE 17494
// begin e := NearestUnitToUnit ( enemy , i ) ;
16766: LD_ADDR_VAR 0 13
16770: PUSH
16771: LD_VAR 0 3
16775: PPUSH
16776: LD_VAR 0 5
16780: PPUSH
16781: CALL_OW 74
16785: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16786: LD_ADDR_VAR 0 16
16790: PUSH
16791: LD_EXP 58
16795: PUSH
16796: LD_VAR 0 1
16800: ARRAY
16801: PPUSH
16802: LD_INT 2
16804: PUSH
16805: LD_INT 30
16807: PUSH
16808: LD_INT 0
16810: PUSH
16811: EMPTY
16812: LIST
16813: LIST
16814: PUSH
16815: LD_INT 30
16817: PUSH
16818: LD_INT 1
16820: PUSH
16821: EMPTY
16822: LIST
16823: LIST
16824: PUSH
16825: EMPTY
16826: LIST
16827: LIST
16828: LIST
16829: PPUSH
16830: CALL_OW 72
16834: NOT
16835: PUSH
16836: LD_EXP 58
16840: PUSH
16841: LD_VAR 0 1
16845: ARRAY
16846: PPUSH
16847: LD_INT 2
16849: PUSH
16850: LD_INT 30
16852: PUSH
16853: LD_INT 0
16855: PUSH
16856: EMPTY
16857: LIST
16858: LIST
16859: PUSH
16860: LD_INT 30
16862: PUSH
16863: LD_INT 1
16865: PUSH
16866: EMPTY
16867: LIST
16868: LIST
16869: PUSH
16870: EMPTY
16871: LIST
16872: LIST
16873: LIST
16874: PPUSH
16875: CALL_OW 72
16879: PPUSH
16880: CALL_OW 256
16884: PUSH
16885: LD_INT 600
16887: LESS
16888: OR
16889: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16890: LD_VAR 0 5
16894: PPUSH
16895: CALL_OW 247
16899: PUSH
16900: LD_INT 2
16902: DOUBLE
16903: EQUAL
16904: IFTRUE 16908
16906: GO 17200
16908: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
16909: LD_VAR 0 5
16913: PPUSH
16914: CALL_OW 256
16918: PUSH
16919: LD_INT 650
16921: GREATER
16922: PUSH
16923: LD_VAR 0 5
16927: PPUSH
16928: LD_VAR 0 13
16932: PPUSH
16933: CALL_OW 296
16937: PUSH
16938: LD_INT 40
16940: LESS
16941: PUSH
16942: LD_VAR 0 13
16946: PPUSH
16947: LD_EXP 83
16951: PUSH
16952: LD_VAR 0 1
16956: ARRAY
16957: PPUSH
16958: CALL_OW 308
16962: OR
16963: AND
16964: IFFALSE 16982
// ComAttackUnit ( i , e ) else
16966: LD_VAR 0 5
16970: PPUSH
16971: LD_VAR 0 13
16975: PPUSH
16976: CALL_OW 115
16980: GO 17083
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16982: LD_VAR 0 13
16986: PPUSH
16987: LD_EXP 83
16991: PUSH
16992: LD_VAR 0 1
16996: ARRAY
16997: PPUSH
16998: CALL_OW 308
17002: NOT
17003: PUSH
17004: LD_VAR 0 5
17008: PPUSH
17009: LD_VAR 0 13
17013: PPUSH
17014: CALL_OW 296
17018: PUSH
17019: LD_INT 40
17021: GREATEREQUAL
17022: AND
17023: PUSH
17024: LD_VAR 0 5
17028: PPUSH
17029: CALL_OW 256
17033: PUSH
17034: LD_INT 650
17036: LESSEQUAL
17037: OR
17038: PUSH
17039: LD_VAR 0 5
17043: PPUSH
17044: LD_EXP 82
17048: PUSH
17049: LD_VAR 0 1
17053: ARRAY
17054: PPUSH
17055: CALL_OW 308
17059: NOT
17060: AND
17061: IFFALSE 17083
// ComMoveToArea ( i , mc_parking [ base ] ) ;
17063: LD_VAR 0 5
17067: PPUSH
17068: LD_EXP 82
17072: PUSH
17073: LD_VAR 0 1
17077: ARRAY
17078: PPUSH
17079: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
17083: LD_VAR 0 5
17087: PPUSH
17088: CALL_OW 256
17092: PUSH
17093: LD_INT 998
17095: LESS
17096: PUSH
17097: LD_VAR 0 5
17101: PPUSH
17102: CALL_OW 263
17106: PUSH
17107: LD_INT 1
17109: EQUAL
17110: AND
17111: PUSH
17112: LD_VAR 0 5
17116: PPUSH
17117: CALL_OW 311
17121: AND
17122: PUSH
17123: LD_VAR 0 5
17127: PPUSH
17128: LD_EXP 82
17132: PUSH
17133: LD_VAR 0 1
17137: ARRAY
17138: PPUSH
17139: CALL_OW 308
17143: AND
17144: IFFALSE 17198
// begin mech := IsDrivenBy ( i ) ;
17146: LD_ADDR_VAR 0 9
17150: PUSH
17151: LD_VAR 0 5
17155: PPUSH
17156: CALL_OW 311
17160: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
17161: LD_VAR 0 9
17165: PPUSH
17166: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
17170: LD_VAR 0 9
17174: PPUSH
17175: LD_VAR 0 5
17179: PPUSH
17180: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
17184: LD_VAR 0 9
17188: PPUSH
17189: LD_VAR 0 5
17193: PPUSH
17194: CALL_OW 180
// end ; end ; unit_human :
17198: GO 17465
17200: LD_INT 1
17202: DOUBLE
17203: EQUAL
17204: IFTRUE 17208
17206: GO 17464
17208: POP
// begin b := IsInUnit ( i ) ;
17209: LD_ADDR_VAR 0 18
17213: PUSH
17214: LD_VAR 0 5
17218: PPUSH
17219: CALL_OW 310
17223: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17224: LD_ADDR_VAR 0 19
17228: PUSH
17229: LD_VAR 0 18
17233: NOT
17234: PUSH
17235: LD_VAR 0 18
17239: PPUSH
17240: CALL_OW 266
17244: PUSH
17245: LD_INT 32
17247: PUSH
17248: LD_INT 31
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: IN
17255: OR
17256: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17257: LD_VAR 0 16
17261: PUSH
17262: LD_VAR 0 2
17266: PPUSH
17267: LD_INT 21
17269: PUSH
17270: LD_INT 2
17272: PUSH
17273: EMPTY
17274: LIST
17275: LIST
17276: PPUSH
17277: CALL_OW 72
17281: PUSH
17282: LD_INT 1
17284: LESSEQUAL
17285: OR
17286: PUSH
17287: LD_VAR 0 19
17291: AND
17292: PUSH
17293: LD_VAR 0 5
17297: PUSH
17298: LD_VAR 0 17
17302: IN
17303: NOT
17304: AND
17305: IFFALSE 17398
// begin if b then
17307: LD_VAR 0 18
17311: IFFALSE 17360
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17313: LD_VAR 0 18
17317: PPUSH
17318: LD_VAR 0 3
17322: PPUSH
17323: LD_VAR 0 18
17327: PPUSH
17328: CALL_OW 74
17332: PPUSH
17333: CALL_OW 296
17337: PUSH
17338: LD_INT 10
17340: LESS
17341: PUSH
17342: LD_VAR 0 18
17346: PPUSH
17347: CALL_OW 461
17351: PUSH
17352: LD_INT 7
17354: NONEQUAL
17355: AND
17356: IFFALSE 17360
// continue ;
17358: GO 16763
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17360: LD_ADDR_VAR 0 17
17364: PUSH
17365: LD_VAR 0 17
17369: PPUSH
17370: LD_VAR 0 17
17374: PUSH
17375: LD_INT 1
17377: PLUS
17378: PPUSH
17379: LD_VAR 0 5
17383: PPUSH
17384: CALL_OW 1
17388: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17389: LD_VAR 0 5
17393: PPUSH
17394: CALL_OW 122
// end ; if sold_defenders then
17398: LD_VAR 0 17
17402: IFFALSE 17462
// if i in sold_defenders then
17404: LD_VAR 0 5
17408: PUSH
17409: LD_VAR 0 17
17413: IN
17414: IFFALSE 17462
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17416: LD_VAR 0 5
17420: PPUSH
17421: CALL_OW 314
17425: NOT
17426: PUSH
17427: LD_VAR 0 5
17431: PPUSH
17432: LD_VAR 0 13
17436: PPUSH
17437: CALL_OW 296
17441: PUSH
17442: LD_INT 30
17444: LESS
17445: AND
17446: IFFALSE 17462
// ComAttackUnit ( i , e ) ;
17448: LD_VAR 0 5
17452: PPUSH
17453: LD_VAR 0 13
17457: PPUSH
17458: CALL_OW 115
// end ; end ; end ;
17462: GO 17465
17464: POP
// if IsDead ( i ) then
17465: LD_VAR 0 5
17469: PPUSH
17470: CALL_OW 301
17474: IFFALSE 17492
// defenders := defenders diff i ;
17476: LD_ADDR_VAR 0 2
17480: PUSH
17481: LD_VAR 0 2
17485: PUSH
17486: LD_VAR 0 5
17490: DIFF
17491: ST_TO_ADDR
// end ;
17492: GO 16763
17494: POP
17495: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
17496: LD_VAR 0 3
17500: NOT
17501: PUSH
17502: LD_VAR 0 2
17506: NOT
17507: OR
17508: PUSH
17509: LD_EXP 58
17513: PUSH
17514: LD_VAR 0 1
17518: ARRAY
17519: NOT
17520: OR
17521: IFFALSE 16667
// MC_Reset ( base , 18 ) ;
17523: LD_VAR 0 1
17527: PPUSH
17528: LD_INT 18
17530: PPUSH
17531: CALL 61154 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17535: LD_ADDR_VAR 0 2
17539: PUSH
17540: LD_VAR 0 2
17544: PUSH
17545: LD_VAR 0 2
17549: PPUSH
17550: LD_INT 2
17552: PUSH
17553: LD_INT 25
17555: PUSH
17556: LD_INT 1
17558: PUSH
17559: EMPTY
17560: LIST
17561: LIST
17562: PUSH
17563: LD_INT 25
17565: PUSH
17566: LD_INT 5
17568: PUSH
17569: EMPTY
17570: LIST
17571: LIST
17572: PUSH
17573: LD_INT 25
17575: PUSH
17576: LD_INT 8
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: PUSH
17583: LD_INT 25
17585: PUSH
17586: LD_INT 9
17588: PUSH
17589: EMPTY
17590: LIST
17591: LIST
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: LIST
17599: PPUSH
17600: CALL_OW 72
17604: DIFF
17605: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17606: LD_VAR 0 3
17610: NOT
17611: PUSH
17612: LD_VAR 0 2
17616: PPUSH
17617: LD_INT 21
17619: PUSH
17620: LD_INT 2
17622: PUSH
17623: EMPTY
17624: LIST
17625: LIST
17626: PPUSH
17627: CALL_OW 72
17631: AND
17632: IFFALSE 17970
// begin tmp := FilterByTag ( defenders , 19 ) ;
17634: LD_ADDR_VAR 0 11
17638: PUSH
17639: LD_VAR 0 2
17643: PPUSH
17644: LD_INT 19
17646: PPUSH
17647: CALL 54411 0 2
17651: ST_TO_ADDR
// if tmp then
17652: LD_VAR 0 11
17656: IFFALSE 17726
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17658: LD_ADDR_VAR 0 11
17662: PUSH
17663: LD_VAR 0 11
17667: PPUSH
17668: LD_INT 25
17670: PUSH
17671: LD_INT 3
17673: PUSH
17674: EMPTY
17675: LIST
17676: LIST
17677: PPUSH
17678: CALL_OW 72
17682: ST_TO_ADDR
// if tmp then
17683: LD_VAR 0 11
17687: IFFALSE 17726
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17689: LD_ADDR_EXP 70
17693: PUSH
17694: LD_EXP 70
17698: PPUSH
17699: LD_VAR 0 1
17703: PPUSH
17704: LD_EXP 70
17708: PUSH
17709: LD_VAR 0 1
17713: ARRAY
17714: PUSH
17715: LD_VAR 0 11
17719: UNION
17720: PPUSH
17721: CALL_OW 1
17725: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17726: LD_VAR 0 1
17730: PPUSH
17731: LD_INT 19
17733: PPUSH
17734: CALL 61154 0 2
// repeat wait ( 0 0$1 ) ;
17738: LD_INT 35
17740: PPUSH
17741: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
17745: LD_EXP 58
17749: PUSH
17750: LD_VAR 0 1
17754: ARRAY
17755: NOT
17756: PUSH
17757: LD_EXP 58
17761: PUSH
17762: LD_VAR 0 1
17766: ARRAY
17767: PUSH
17768: EMPTY
17769: EQUAL
17770: OR
17771: IFFALSE 17808
// begin for i in defenders do
17773: LD_ADDR_VAR 0 5
17777: PUSH
17778: LD_VAR 0 2
17782: PUSH
17783: FOR_IN
17784: IFFALSE 17797
// ComStop ( i ) ;
17786: LD_VAR 0 5
17790: PPUSH
17791: CALL_OW 141
17795: GO 17783
17797: POP
17798: POP
// defenders := [ ] ;
17799: LD_ADDR_VAR 0 2
17803: PUSH
17804: EMPTY
17805: ST_TO_ADDR
// exit ;
17806: GO 17982
// end ; for i in defenders do
17808: LD_ADDR_VAR 0 5
17812: PUSH
17813: LD_VAR 0 2
17817: PUSH
17818: FOR_IN
17819: IFFALSE 17908
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17821: LD_VAR 0 5
17825: PPUSH
17826: LD_EXP 82
17830: PUSH
17831: LD_VAR 0 1
17835: ARRAY
17836: PPUSH
17837: CALL_OW 308
17841: NOT
17842: IFFALSE 17866
// ComMoveToArea ( i , mc_parking [ base ] ) else
17844: LD_VAR 0 5
17848: PPUSH
17849: LD_EXP 82
17853: PUSH
17854: LD_VAR 0 1
17858: ARRAY
17859: PPUSH
17860: CALL_OW 113
17864: GO 17906
// if GetControl ( i ) = control_manual then
17866: LD_VAR 0 5
17870: PPUSH
17871: CALL_OW 263
17875: PUSH
17876: LD_INT 1
17878: EQUAL
17879: IFFALSE 17906
// if IsDrivenBy ( i ) then
17881: LD_VAR 0 5
17885: PPUSH
17886: CALL_OW 311
17890: IFFALSE 17906
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17892: LD_VAR 0 5
17896: PPUSH
17897: CALL_OW 311
17901: PPUSH
17902: CALL_OW 121
// end ;
17906: GO 17818
17908: POP
17909: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
17910: LD_VAR 0 2
17914: PPUSH
17915: LD_INT 95
17917: PUSH
17918: LD_EXP 82
17922: PUSH
17923: LD_VAR 0 1
17927: ARRAY
17928: PUSH
17929: EMPTY
17930: LIST
17931: LIST
17932: PPUSH
17933: CALL_OW 72
17937: PUSH
17938: LD_VAR 0 2
17942: EQUAL
17943: PUSH
17944: LD_EXP 81
17948: PUSH
17949: LD_VAR 0 1
17953: ARRAY
17954: OR
17955: PUSH
17956: LD_EXP 58
17960: PUSH
17961: LD_VAR 0 1
17965: ARRAY
17966: NOT
17967: OR
17968: IFFALSE 17738
// end ; MC_Reset ( base , 20 ) ;
17970: LD_VAR 0 1
17974: PPUSH
17975: LD_INT 20
17977: PPUSH
17978: CALL 61154 0 2
// end ;
17982: LD_VAR 0 4
17986: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17987: LD_INT 0
17989: PPUSH
17990: PPUSH
17991: PPUSH
17992: PPUSH
// result := false ;
17993: LD_ADDR_VAR 0 2
17997: PUSH
17998: LD_INT 0
18000: ST_TO_ADDR
// side := GetSide ( unit ) ;
18001: LD_ADDR_VAR 0 3
18005: PUSH
18006: LD_VAR 0 1
18010: PPUSH
18011: CALL_OW 255
18015: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18016: LD_ADDR_VAR 0 4
18020: PUSH
18021: LD_VAR 0 1
18025: PPUSH
18026: CALL_OW 248
18030: ST_TO_ADDR
// case nat of 1 :
18031: LD_VAR 0 4
18035: PUSH
18036: LD_INT 1
18038: DOUBLE
18039: EQUAL
18040: IFTRUE 18044
18042: GO 18055
18044: POP
// tech := tech_lassight ; 2 :
18045: LD_ADDR_VAR 0 5
18049: PUSH
18050: LD_INT 12
18052: ST_TO_ADDR
18053: GO 18094
18055: LD_INT 2
18057: DOUBLE
18058: EQUAL
18059: IFTRUE 18063
18061: GO 18074
18063: POP
// tech := tech_mortar ; 3 :
18064: LD_ADDR_VAR 0 5
18068: PUSH
18069: LD_INT 41
18071: ST_TO_ADDR
18072: GO 18094
18074: LD_INT 3
18076: DOUBLE
18077: EQUAL
18078: IFTRUE 18082
18080: GO 18093
18082: POP
// tech := tech_bazooka ; end ;
18083: LD_ADDR_VAR 0 5
18087: PUSH
18088: LD_INT 44
18090: ST_TO_ADDR
18091: GO 18094
18093: POP
// if Researched ( side , tech ) then
18094: LD_VAR 0 3
18098: PPUSH
18099: LD_VAR 0 5
18103: PPUSH
18104: CALL_OW 325
18108: IFFALSE 18135
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18110: LD_ADDR_VAR 0 2
18114: PUSH
18115: LD_INT 5
18117: PUSH
18118: LD_INT 8
18120: PUSH
18121: LD_INT 9
18123: PUSH
18124: EMPTY
18125: LIST
18126: LIST
18127: LIST
18128: PUSH
18129: LD_VAR 0 4
18133: ARRAY
18134: ST_TO_ADDR
// end ;
18135: LD_VAR 0 2
18139: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18140: LD_INT 0
18142: PPUSH
18143: PPUSH
18144: PPUSH
// if not mines then
18145: LD_VAR 0 2
18149: NOT
18150: IFFALSE 18154
// exit ;
18152: GO 18298
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18154: LD_ADDR_VAR 0 5
18158: PUSH
18159: LD_INT 81
18161: PUSH
18162: LD_VAR 0 1
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 3
18173: PUSH
18174: LD_INT 21
18176: PUSH
18177: LD_INT 3
18179: PUSH
18180: EMPTY
18181: LIST
18182: LIST
18183: PUSH
18184: EMPTY
18185: LIST
18186: LIST
18187: PUSH
18188: EMPTY
18189: LIST
18190: LIST
18191: PPUSH
18192: CALL_OW 69
18196: ST_TO_ADDR
// for i in mines do
18197: LD_ADDR_VAR 0 4
18201: PUSH
18202: LD_VAR 0 2
18206: PUSH
18207: FOR_IN
18208: IFFALSE 18296
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18210: LD_VAR 0 4
18214: PUSH
18215: LD_INT 1
18217: ARRAY
18218: PPUSH
18219: LD_VAR 0 4
18223: PUSH
18224: LD_INT 2
18226: ARRAY
18227: PPUSH
18228: CALL_OW 458
18232: NOT
18233: IFFALSE 18237
// continue ;
18235: GO 18207
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18237: LD_VAR 0 4
18241: PUSH
18242: LD_INT 1
18244: ARRAY
18245: PPUSH
18246: LD_VAR 0 4
18250: PUSH
18251: LD_INT 2
18253: ARRAY
18254: PPUSH
18255: CALL_OW 428
18259: PUSH
18260: LD_VAR 0 5
18264: IN
18265: IFFALSE 18294
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18267: LD_VAR 0 4
18271: PUSH
18272: LD_INT 1
18274: ARRAY
18275: PPUSH
18276: LD_VAR 0 4
18280: PUSH
18281: LD_INT 2
18283: ARRAY
18284: PPUSH
18285: LD_VAR 0 1
18289: PPUSH
18290: CALL_OW 456
// end ;
18294: GO 18207
18296: POP
18297: POP
// end ;
18298: LD_VAR 0 3
18302: RET
// export function Count ( array ) ; var i ; begin
18303: LD_INT 0
18305: PPUSH
18306: PPUSH
// result := 0 ;
18307: LD_ADDR_VAR 0 2
18311: PUSH
18312: LD_INT 0
18314: ST_TO_ADDR
// for i in array do
18315: LD_ADDR_VAR 0 3
18319: PUSH
18320: LD_VAR 0 1
18324: PUSH
18325: FOR_IN
18326: IFFALSE 18350
// if i then
18328: LD_VAR 0 3
18332: IFFALSE 18348
// result := result + 1 ;
18334: LD_ADDR_VAR 0 2
18338: PUSH
18339: LD_VAR 0 2
18343: PUSH
18344: LD_INT 1
18346: PLUS
18347: ST_TO_ADDR
18348: GO 18325
18350: POP
18351: POP
// end ;
18352: LD_VAR 0 2
18356: RET
// export function IsEmpty ( building ) ; begin
18357: LD_INT 0
18359: PPUSH
// if not building then
18360: LD_VAR 0 1
18364: NOT
18365: IFFALSE 18369
// exit ;
18367: GO 18412
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18369: LD_ADDR_VAR 0 2
18373: PUSH
18374: LD_VAR 0 1
18378: PUSH
18379: LD_INT 22
18381: PUSH
18382: LD_VAR 0 1
18386: PPUSH
18387: CALL_OW 255
18391: PUSH
18392: EMPTY
18393: LIST
18394: LIST
18395: PUSH
18396: LD_INT 58
18398: PUSH
18399: EMPTY
18400: LIST
18401: PUSH
18402: EMPTY
18403: LIST
18404: LIST
18405: PPUSH
18406: CALL_OW 69
18410: IN
18411: ST_TO_ADDR
// end ;
18412: LD_VAR 0 2
18416: RET
// export function IsNotFull ( building ) ; begin
18417: LD_INT 0
18419: PPUSH
// if not building then
18420: LD_VAR 0 1
18424: NOT
18425: IFFALSE 18429
// exit ;
18427: GO 18448
// result := UnitsInside ( building ) < 6 ;
18429: LD_ADDR_VAR 0 2
18433: PUSH
18434: LD_VAR 0 1
18438: PPUSH
18439: CALL_OW 313
18443: PUSH
18444: LD_INT 6
18446: LESS
18447: ST_TO_ADDR
// end ;
18448: LD_VAR 0 2
18452: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18453: LD_INT 0
18455: PPUSH
18456: PPUSH
18457: PPUSH
18458: PPUSH
// tmp := [ ] ;
18459: LD_ADDR_VAR 0 3
18463: PUSH
18464: EMPTY
18465: ST_TO_ADDR
// list := [ ] ;
18466: LD_ADDR_VAR 0 5
18470: PUSH
18471: EMPTY
18472: ST_TO_ADDR
// for i = 16 to 25 do
18473: LD_ADDR_VAR 0 4
18477: PUSH
18478: DOUBLE
18479: LD_INT 16
18481: DEC
18482: ST_TO_ADDR
18483: LD_INT 25
18485: PUSH
18486: FOR_TO
18487: IFFALSE 18560
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18489: LD_ADDR_VAR 0 3
18493: PUSH
18494: LD_VAR 0 3
18498: PUSH
18499: LD_INT 22
18501: PUSH
18502: LD_VAR 0 1
18506: PPUSH
18507: CALL_OW 255
18511: PUSH
18512: EMPTY
18513: LIST
18514: LIST
18515: PUSH
18516: LD_INT 91
18518: PUSH
18519: LD_VAR 0 1
18523: PUSH
18524: LD_INT 6
18526: PUSH
18527: EMPTY
18528: LIST
18529: LIST
18530: LIST
18531: PUSH
18532: LD_INT 30
18534: PUSH
18535: LD_VAR 0 4
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: PUSH
18544: EMPTY
18545: LIST
18546: LIST
18547: LIST
18548: PUSH
18549: EMPTY
18550: LIST
18551: PPUSH
18552: CALL_OW 69
18556: ADD
18557: ST_TO_ADDR
18558: GO 18486
18560: POP
18561: POP
// for i = 1 to tmp do
18562: LD_ADDR_VAR 0 4
18566: PUSH
18567: DOUBLE
18568: LD_INT 1
18570: DEC
18571: ST_TO_ADDR
18572: LD_VAR 0 3
18576: PUSH
18577: FOR_TO
18578: IFFALSE 18666
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18580: LD_ADDR_VAR 0 5
18584: PUSH
18585: LD_VAR 0 5
18589: PUSH
18590: LD_VAR 0 3
18594: PUSH
18595: LD_VAR 0 4
18599: ARRAY
18600: PPUSH
18601: CALL_OW 266
18605: PUSH
18606: LD_VAR 0 3
18610: PUSH
18611: LD_VAR 0 4
18615: ARRAY
18616: PPUSH
18617: CALL_OW 250
18621: PUSH
18622: LD_VAR 0 3
18626: PUSH
18627: LD_VAR 0 4
18631: ARRAY
18632: PPUSH
18633: CALL_OW 251
18637: PUSH
18638: LD_VAR 0 3
18642: PUSH
18643: LD_VAR 0 4
18647: ARRAY
18648: PPUSH
18649: CALL_OW 254
18653: PUSH
18654: EMPTY
18655: LIST
18656: LIST
18657: LIST
18658: LIST
18659: PUSH
18660: EMPTY
18661: LIST
18662: ADD
18663: ST_TO_ADDR
18664: GO 18577
18666: POP
18667: POP
// result := list ;
18668: LD_ADDR_VAR 0 2
18672: PUSH
18673: LD_VAR 0 5
18677: ST_TO_ADDR
// end ;
18678: LD_VAR 0 2
18682: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18683: LD_INT 0
18685: PPUSH
18686: PPUSH
18687: PPUSH
18688: PPUSH
18689: PPUSH
18690: PPUSH
18691: PPUSH
// if not factory then
18692: LD_VAR 0 1
18696: NOT
18697: IFFALSE 18701
// exit ;
18699: GO 19294
// if control = control_apeman then
18701: LD_VAR 0 4
18705: PUSH
18706: LD_INT 5
18708: EQUAL
18709: IFFALSE 18818
// begin tmp := UnitsInside ( factory ) ;
18711: LD_ADDR_VAR 0 8
18715: PUSH
18716: LD_VAR 0 1
18720: PPUSH
18721: CALL_OW 313
18725: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18726: LD_VAR 0 8
18730: PPUSH
18731: LD_INT 25
18733: PUSH
18734: LD_INT 12
18736: PUSH
18737: EMPTY
18738: LIST
18739: LIST
18740: PPUSH
18741: CALL_OW 72
18745: NOT
18746: IFFALSE 18756
// control := control_manual ;
18748: LD_ADDR_VAR 0 4
18752: PUSH
18753: LD_INT 1
18755: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18756: LD_ADDR_VAR 0 8
18760: PUSH
18761: LD_VAR 0 1
18765: PPUSH
18766: CALL 18453 0 1
18770: ST_TO_ADDR
// if tmp then
18771: LD_VAR 0 8
18775: IFFALSE 18818
// begin for i in tmp do
18777: LD_ADDR_VAR 0 7
18781: PUSH
18782: LD_VAR 0 8
18786: PUSH
18787: FOR_IN
18788: IFFALSE 18816
// if i [ 1 ] = b_ext_radio then
18790: LD_VAR 0 7
18794: PUSH
18795: LD_INT 1
18797: ARRAY
18798: PUSH
18799: LD_INT 22
18801: EQUAL
18802: IFFALSE 18814
// begin control := control_remote ;
18804: LD_ADDR_VAR 0 4
18808: PUSH
18809: LD_INT 2
18811: ST_TO_ADDR
// break ;
18812: GO 18816
// end ;
18814: GO 18787
18816: POP
18817: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18818: LD_VAR 0 1
18822: PPUSH
18823: LD_VAR 0 2
18827: PPUSH
18828: LD_VAR 0 3
18832: PPUSH
18833: LD_VAR 0 4
18837: PPUSH
18838: LD_VAR 0 5
18842: PPUSH
18843: CALL_OW 448
18847: IFFALSE 18882
// begin result := [ chassis , engine , control , weapon ] ;
18849: LD_ADDR_VAR 0 6
18853: PUSH
18854: LD_VAR 0 2
18858: PUSH
18859: LD_VAR 0 3
18863: PUSH
18864: LD_VAR 0 4
18868: PUSH
18869: LD_VAR 0 5
18873: PUSH
18874: EMPTY
18875: LIST
18876: LIST
18877: LIST
18878: LIST
18879: ST_TO_ADDR
// exit ;
18880: GO 19294
// end ; _chassis := AvailableChassisList ( factory ) ;
18882: LD_ADDR_VAR 0 9
18886: PUSH
18887: LD_VAR 0 1
18891: PPUSH
18892: CALL_OW 475
18896: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18897: LD_ADDR_VAR 0 11
18901: PUSH
18902: LD_VAR 0 1
18906: PPUSH
18907: CALL_OW 476
18911: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18912: LD_ADDR_VAR 0 12
18916: PUSH
18917: LD_VAR 0 1
18921: PPUSH
18922: CALL_OW 477
18926: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18927: LD_ADDR_VAR 0 10
18931: PUSH
18932: LD_VAR 0 1
18936: PPUSH
18937: CALL_OW 478
18941: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
18942: LD_VAR 0 9
18946: NOT
18947: PUSH
18948: LD_VAR 0 11
18952: NOT
18953: OR
18954: PUSH
18955: LD_VAR 0 12
18959: NOT
18960: OR
18961: PUSH
18962: LD_VAR 0 10
18966: NOT
18967: OR
18968: IFFALSE 19003
// begin result := [ chassis , engine , control , weapon ] ;
18970: LD_ADDR_VAR 0 6
18974: PUSH
18975: LD_VAR 0 2
18979: PUSH
18980: LD_VAR 0 3
18984: PUSH
18985: LD_VAR 0 4
18989: PUSH
18990: LD_VAR 0 5
18994: PUSH
18995: EMPTY
18996: LIST
18997: LIST
18998: LIST
18999: LIST
19000: ST_TO_ADDR
// exit ;
19001: GO 19294
// end ; if not chassis in _chassis then
19003: LD_VAR 0 2
19007: PUSH
19008: LD_VAR 0 9
19012: IN
19013: NOT
19014: IFFALSE 19040
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19016: LD_ADDR_VAR 0 2
19020: PUSH
19021: LD_VAR 0 9
19025: PUSH
19026: LD_INT 1
19028: PPUSH
19029: LD_VAR 0 9
19033: PPUSH
19034: CALL_OW 12
19038: ARRAY
19039: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19040: LD_VAR 0 2
19044: PPUSH
19045: LD_VAR 0 3
19049: PPUSH
19050: CALL 19299 0 2
19054: NOT
19055: IFFALSE 19114
// repeat engine := _engine [ 1 ] ;
19057: LD_ADDR_VAR 0 3
19061: PUSH
19062: LD_VAR 0 11
19066: PUSH
19067: LD_INT 1
19069: ARRAY
19070: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19071: LD_ADDR_VAR 0 11
19075: PUSH
19076: LD_VAR 0 11
19080: PPUSH
19081: LD_INT 1
19083: PPUSH
19084: CALL_OW 3
19088: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19089: LD_VAR 0 2
19093: PPUSH
19094: LD_VAR 0 3
19098: PPUSH
19099: CALL 19299 0 2
19103: PUSH
19104: LD_VAR 0 11
19108: PUSH
19109: EMPTY
19110: EQUAL
19111: OR
19112: IFFALSE 19057
// if not control in _control then
19114: LD_VAR 0 4
19118: PUSH
19119: LD_VAR 0 12
19123: IN
19124: NOT
19125: IFFALSE 19151
// control := _control [ rand ( 1 , _control ) ] ;
19127: LD_ADDR_VAR 0 4
19131: PUSH
19132: LD_VAR 0 12
19136: PUSH
19137: LD_INT 1
19139: PPUSH
19140: LD_VAR 0 12
19144: PPUSH
19145: CALL_OW 12
19149: ARRAY
19150: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19151: LD_VAR 0 2
19155: PPUSH
19156: LD_VAR 0 5
19160: PPUSH
19161: CALL 19519 0 2
19165: NOT
19166: IFFALSE 19225
// repeat weapon := _weapon [ 1 ] ;
19168: LD_ADDR_VAR 0 5
19172: PUSH
19173: LD_VAR 0 10
19177: PUSH
19178: LD_INT 1
19180: ARRAY
19181: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19182: LD_ADDR_VAR 0 10
19186: PUSH
19187: LD_VAR 0 10
19191: PPUSH
19192: LD_INT 1
19194: PPUSH
19195: CALL_OW 3
19199: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19200: LD_VAR 0 2
19204: PPUSH
19205: LD_VAR 0 5
19209: PPUSH
19210: CALL 19519 0 2
19214: PUSH
19215: LD_VAR 0 10
19219: PUSH
19220: EMPTY
19221: EQUAL
19222: OR
19223: IFFALSE 19168
// result := [ ] ;
19225: LD_ADDR_VAR 0 6
19229: PUSH
19230: EMPTY
19231: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19232: LD_VAR 0 1
19236: PPUSH
19237: LD_VAR 0 2
19241: PPUSH
19242: LD_VAR 0 3
19246: PPUSH
19247: LD_VAR 0 4
19251: PPUSH
19252: LD_VAR 0 5
19256: PPUSH
19257: CALL_OW 448
19261: IFFALSE 19294
// result := [ chassis , engine , control , weapon ] ;
19263: LD_ADDR_VAR 0 6
19267: PUSH
19268: LD_VAR 0 2
19272: PUSH
19273: LD_VAR 0 3
19277: PUSH
19278: LD_VAR 0 4
19282: PUSH
19283: LD_VAR 0 5
19287: PUSH
19288: EMPTY
19289: LIST
19290: LIST
19291: LIST
19292: LIST
19293: ST_TO_ADDR
// end ;
19294: LD_VAR 0 6
19298: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19299: LD_INT 0
19301: PPUSH
// if not chassis or not engine then
19302: LD_VAR 0 1
19306: NOT
19307: PUSH
19308: LD_VAR 0 2
19312: NOT
19313: OR
19314: IFFALSE 19318
// exit ;
19316: GO 19514
// case engine of engine_solar :
19318: LD_VAR 0 2
19322: PUSH
19323: LD_INT 2
19325: DOUBLE
19326: EQUAL
19327: IFTRUE 19331
19329: GO 19369
19331: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19332: LD_ADDR_VAR 0 3
19336: PUSH
19337: LD_INT 11
19339: PUSH
19340: LD_INT 12
19342: PUSH
19343: LD_INT 13
19345: PUSH
19346: LD_INT 14
19348: PUSH
19349: LD_INT 1
19351: PUSH
19352: LD_INT 2
19354: PUSH
19355: LD_INT 3
19357: PUSH
19358: EMPTY
19359: LIST
19360: LIST
19361: LIST
19362: LIST
19363: LIST
19364: LIST
19365: LIST
19366: ST_TO_ADDR
19367: GO 19498
19369: LD_INT 1
19371: DOUBLE
19372: EQUAL
19373: IFTRUE 19377
19375: GO 19439
19377: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19378: LD_ADDR_VAR 0 3
19382: PUSH
19383: LD_INT 11
19385: PUSH
19386: LD_INT 12
19388: PUSH
19389: LD_INT 13
19391: PUSH
19392: LD_INT 14
19394: PUSH
19395: LD_INT 1
19397: PUSH
19398: LD_INT 2
19400: PUSH
19401: LD_INT 3
19403: PUSH
19404: LD_INT 4
19406: PUSH
19407: LD_INT 5
19409: PUSH
19410: LD_INT 21
19412: PUSH
19413: LD_INT 23
19415: PUSH
19416: LD_INT 22
19418: PUSH
19419: LD_INT 24
19421: PUSH
19422: EMPTY
19423: LIST
19424: LIST
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: LIST
19431: LIST
19432: LIST
19433: LIST
19434: LIST
19435: LIST
19436: ST_TO_ADDR
19437: GO 19498
19439: LD_INT 3
19441: DOUBLE
19442: EQUAL
19443: IFTRUE 19447
19445: GO 19497
19447: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19448: LD_ADDR_VAR 0 3
19452: PUSH
19453: LD_INT 13
19455: PUSH
19456: LD_INT 14
19458: PUSH
19459: LD_INT 2
19461: PUSH
19462: LD_INT 3
19464: PUSH
19465: LD_INT 4
19467: PUSH
19468: LD_INT 5
19470: PUSH
19471: LD_INT 21
19473: PUSH
19474: LD_INT 22
19476: PUSH
19477: LD_INT 23
19479: PUSH
19480: LD_INT 24
19482: PUSH
19483: EMPTY
19484: LIST
19485: LIST
19486: LIST
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: LIST
19492: LIST
19493: LIST
19494: ST_TO_ADDR
19495: GO 19498
19497: POP
// result := ( chassis in result ) ;
19498: LD_ADDR_VAR 0 3
19502: PUSH
19503: LD_VAR 0 1
19507: PUSH
19508: LD_VAR 0 3
19512: IN
19513: ST_TO_ADDR
// end ;
19514: LD_VAR 0 3
19518: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19519: LD_INT 0
19521: PPUSH
// if not chassis or not weapon then
19522: LD_VAR 0 1
19526: NOT
19527: PUSH
19528: LD_VAR 0 2
19532: NOT
19533: OR
19534: IFFALSE 19538
// exit ;
19536: GO 20564
// case weapon of us_machine_gun :
19538: LD_VAR 0 2
19542: PUSH
19543: LD_INT 2
19545: DOUBLE
19546: EQUAL
19547: IFTRUE 19551
19549: GO 19581
19551: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19552: LD_ADDR_VAR 0 3
19556: PUSH
19557: LD_INT 1
19559: PUSH
19560: LD_INT 2
19562: PUSH
19563: LD_INT 3
19565: PUSH
19566: LD_INT 4
19568: PUSH
19569: LD_INT 5
19571: PUSH
19572: EMPTY
19573: LIST
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: ST_TO_ADDR
19579: GO 20548
19581: LD_INT 3
19583: DOUBLE
19584: EQUAL
19585: IFTRUE 19589
19587: GO 19619
19589: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19590: LD_ADDR_VAR 0 3
19594: PUSH
19595: LD_INT 1
19597: PUSH
19598: LD_INT 2
19600: PUSH
19601: LD_INT 3
19603: PUSH
19604: LD_INT 4
19606: PUSH
19607: LD_INT 5
19609: PUSH
19610: EMPTY
19611: LIST
19612: LIST
19613: LIST
19614: LIST
19615: LIST
19616: ST_TO_ADDR
19617: GO 20548
19619: LD_INT 11
19621: DOUBLE
19622: EQUAL
19623: IFTRUE 19627
19625: GO 19657
19627: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19628: LD_ADDR_VAR 0 3
19632: PUSH
19633: LD_INT 1
19635: PUSH
19636: LD_INT 2
19638: PUSH
19639: LD_INT 3
19641: PUSH
19642: LD_INT 4
19644: PUSH
19645: LD_INT 5
19647: PUSH
19648: EMPTY
19649: LIST
19650: LIST
19651: LIST
19652: LIST
19653: LIST
19654: ST_TO_ADDR
19655: GO 20548
19657: LD_INT 4
19659: DOUBLE
19660: EQUAL
19661: IFTRUE 19665
19663: GO 19691
19665: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19666: LD_ADDR_VAR 0 3
19670: PUSH
19671: LD_INT 2
19673: PUSH
19674: LD_INT 3
19676: PUSH
19677: LD_INT 4
19679: PUSH
19680: LD_INT 5
19682: PUSH
19683: EMPTY
19684: LIST
19685: LIST
19686: LIST
19687: LIST
19688: ST_TO_ADDR
19689: GO 20548
19691: LD_INT 5
19693: DOUBLE
19694: EQUAL
19695: IFTRUE 19699
19697: GO 19725
19699: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19700: LD_ADDR_VAR 0 3
19704: PUSH
19705: LD_INT 2
19707: PUSH
19708: LD_INT 3
19710: PUSH
19711: LD_INT 4
19713: PUSH
19714: LD_INT 5
19716: PUSH
19717: EMPTY
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: ST_TO_ADDR
19723: GO 20548
19725: LD_INT 9
19727: DOUBLE
19728: EQUAL
19729: IFTRUE 19733
19731: GO 19759
19733: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19734: LD_ADDR_VAR 0 3
19738: PUSH
19739: LD_INT 2
19741: PUSH
19742: LD_INT 3
19744: PUSH
19745: LD_INT 4
19747: PUSH
19748: LD_INT 5
19750: PUSH
19751: EMPTY
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: ST_TO_ADDR
19757: GO 20548
19759: LD_INT 7
19761: DOUBLE
19762: EQUAL
19763: IFTRUE 19767
19765: GO 19793
19767: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19768: LD_ADDR_VAR 0 3
19772: PUSH
19773: LD_INT 2
19775: PUSH
19776: LD_INT 3
19778: PUSH
19779: LD_INT 4
19781: PUSH
19782: LD_INT 5
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: LIST
19789: LIST
19790: ST_TO_ADDR
19791: GO 20548
19793: LD_INT 12
19795: DOUBLE
19796: EQUAL
19797: IFTRUE 19801
19799: GO 19827
19801: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19802: LD_ADDR_VAR 0 3
19806: PUSH
19807: LD_INT 2
19809: PUSH
19810: LD_INT 3
19812: PUSH
19813: LD_INT 4
19815: PUSH
19816: LD_INT 5
19818: PUSH
19819: EMPTY
19820: LIST
19821: LIST
19822: LIST
19823: LIST
19824: ST_TO_ADDR
19825: GO 20548
19827: LD_INT 13
19829: DOUBLE
19830: EQUAL
19831: IFTRUE 19835
19833: GO 19861
19835: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19836: LD_ADDR_VAR 0 3
19840: PUSH
19841: LD_INT 2
19843: PUSH
19844: LD_INT 3
19846: PUSH
19847: LD_INT 4
19849: PUSH
19850: LD_INT 5
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: LIST
19857: LIST
19858: ST_TO_ADDR
19859: GO 20548
19861: LD_INT 14
19863: DOUBLE
19864: EQUAL
19865: IFTRUE 19869
19867: GO 19887
19869: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19870: LD_ADDR_VAR 0 3
19874: PUSH
19875: LD_INT 4
19877: PUSH
19878: LD_INT 5
19880: PUSH
19881: EMPTY
19882: LIST
19883: LIST
19884: ST_TO_ADDR
19885: GO 20548
19887: LD_INT 6
19889: DOUBLE
19890: EQUAL
19891: IFTRUE 19895
19893: GO 19913
19895: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19896: LD_ADDR_VAR 0 3
19900: PUSH
19901: LD_INT 4
19903: PUSH
19904: LD_INT 5
19906: PUSH
19907: EMPTY
19908: LIST
19909: LIST
19910: ST_TO_ADDR
19911: GO 20548
19913: LD_INT 10
19915: DOUBLE
19916: EQUAL
19917: IFTRUE 19921
19919: GO 19939
19921: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19922: LD_ADDR_VAR 0 3
19926: PUSH
19927: LD_INT 4
19929: PUSH
19930: LD_INT 5
19932: PUSH
19933: EMPTY
19934: LIST
19935: LIST
19936: ST_TO_ADDR
19937: GO 20548
19939: LD_INT 22
19941: DOUBLE
19942: EQUAL
19943: IFTRUE 19947
19945: GO 19973
19947: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19948: LD_ADDR_VAR 0 3
19952: PUSH
19953: LD_INT 11
19955: PUSH
19956: LD_INT 12
19958: PUSH
19959: LD_INT 13
19961: PUSH
19962: LD_INT 14
19964: PUSH
19965: EMPTY
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: ST_TO_ADDR
19971: GO 20548
19973: LD_INT 23
19975: DOUBLE
19976: EQUAL
19977: IFTRUE 19981
19979: GO 20007
19981: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19982: LD_ADDR_VAR 0 3
19986: PUSH
19987: LD_INT 11
19989: PUSH
19990: LD_INT 12
19992: PUSH
19993: LD_INT 13
19995: PUSH
19996: LD_INT 14
19998: PUSH
19999: EMPTY
20000: LIST
20001: LIST
20002: LIST
20003: LIST
20004: ST_TO_ADDR
20005: GO 20548
20007: LD_INT 24
20009: DOUBLE
20010: EQUAL
20011: IFTRUE 20015
20013: GO 20041
20015: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20016: LD_ADDR_VAR 0 3
20020: PUSH
20021: LD_INT 11
20023: PUSH
20024: LD_INT 12
20026: PUSH
20027: LD_INT 13
20029: PUSH
20030: LD_INT 14
20032: PUSH
20033: EMPTY
20034: LIST
20035: LIST
20036: LIST
20037: LIST
20038: ST_TO_ADDR
20039: GO 20548
20041: LD_INT 30
20043: DOUBLE
20044: EQUAL
20045: IFTRUE 20049
20047: GO 20075
20049: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20050: LD_ADDR_VAR 0 3
20054: PUSH
20055: LD_INT 11
20057: PUSH
20058: LD_INT 12
20060: PUSH
20061: LD_INT 13
20063: PUSH
20064: LD_INT 14
20066: PUSH
20067: EMPTY
20068: LIST
20069: LIST
20070: LIST
20071: LIST
20072: ST_TO_ADDR
20073: GO 20548
20075: LD_INT 25
20077: DOUBLE
20078: EQUAL
20079: IFTRUE 20083
20081: GO 20101
20083: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20084: LD_ADDR_VAR 0 3
20088: PUSH
20089: LD_INT 13
20091: PUSH
20092: LD_INT 14
20094: PUSH
20095: EMPTY
20096: LIST
20097: LIST
20098: ST_TO_ADDR
20099: GO 20548
20101: LD_INT 27
20103: DOUBLE
20104: EQUAL
20105: IFTRUE 20109
20107: GO 20127
20109: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20110: LD_ADDR_VAR 0 3
20114: PUSH
20115: LD_INT 13
20117: PUSH
20118: LD_INT 14
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: ST_TO_ADDR
20125: GO 20548
20127: LD_INT 28
20129: DOUBLE
20130: EQUAL
20131: IFTRUE 20135
20133: GO 20153
20135: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20136: LD_ADDR_VAR 0 3
20140: PUSH
20141: LD_INT 13
20143: PUSH
20144: LD_INT 14
20146: PUSH
20147: EMPTY
20148: LIST
20149: LIST
20150: ST_TO_ADDR
20151: GO 20548
20153: LD_INT 29
20155: DOUBLE
20156: EQUAL
20157: IFTRUE 20161
20159: GO 20179
20161: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20162: LD_ADDR_VAR 0 3
20166: PUSH
20167: LD_INT 13
20169: PUSH
20170: LD_INT 14
20172: PUSH
20173: EMPTY
20174: LIST
20175: LIST
20176: ST_TO_ADDR
20177: GO 20548
20179: LD_INT 31
20181: DOUBLE
20182: EQUAL
20183: IFTRUE 20187
20185: GO 20205
20187: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20188: LD_ADDR_VAR 0 3
20192: PUSH
20193: LD_INT 13
20195: PUSH
20196: LD_INT 14
20198: PUSH
20199: EMPTY
20200: LIST
20201: LIST
20202: ST_TO_ADDR
20203: GO 20548
20205: LD_INT 26
20207: DOUBLE
20208: EQUAL
20209: IFTRUE 20213
20211: GO 20231
20213: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20214: LD_ADDR_VAR 0 3
20218: PUSH
20219: LD_INT 13
20221: PUSH
20222: LD_INT 14
20224: PUSH
20225: EMPTY
20226: LIST
20227: LIST
20228: ST_TO_ADDR
20229: GO 20548
20231: LD_INT 42
20233: DOUBLE
20234: EQUAL
20235: IFTRUE 20239
20237: GO 20265
20239: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20240: LD_ADDR_VAR 0 3
20244: PUSH
20245: LD_INT 21
20247: PUSH
20248: LD_INT 22
20250: PUSH
20251: LD_INT 23
20253: PUSH
20254: LD_INT 24
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: LIST
20261: LIST
20262: ST_TO_ADDR
20263: GO 20548
20265: LD_INT 43
20267: DOUBLE
20268: EQUAL
20269: IFTRUE 20273
20271: GO 20299
20273: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20274: LD_ADDR_VAR 0 3
20278: PUSH
20279: LD_INT 21
20281: PUSH
20282: LD_INT 22
20284: PUSH
20285: LD_INT 23
20287: PUSH
20288: LD_INT 24
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: LIST
20295: LIST
20296: ST_TO_ADDR
20297: GO 20548
20299: LD_INT 44
20301: DOUBLE
20302: EQUAL
20303: IFTRUE 20307
20305: GO 20333
20307: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20308: LD_ADDR_VAR 0 3
20312: PUSH
20313: LD_INT 21
20315: PUSH
20316: LD_INT 22
20318: PUSH
20319: LD_INT 23
20321: PUSH
20322: LD_INT 24
20324: PUSH
20325: EMPTY
20326: LIST
20327: LIST
20328: LIST
20329: LIST
20330: ST_TO_ADDR
20331: GO 20548
20333: LD_INT 45
20335: DOUBLE
20336: EQUAL
20337: IFTRUE 20341
20339: GO 20367
20341: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20342: LD_ADDR_VAR 0 3
20346: PUSH
20347: LD_INT 21
20349: PUSH
20350: LD_INT 22
20352: PUSH
20353: LD_INT 23
20355: PUSH
20356: LD_INT 24
20358: PUSH
20359: EMPTY
20360: LIST
20361: LIST
20362: LIST
20363: LIST
20364: ST_TO_ADDR
20365: GO 20548
20367: LD_INT 49
20369: DOUBLE
20370: EQUAL
20371: IFTRUE 20375
20373: GO 20401
20375: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20376: LD_ADDR_VAR 0 3
20380: PUSH
20381: LD_INT 21
20383: PUSH
20384: LD_INT 22
20386: PUSH
20387: LD_INT 23
20389: PUSH
20390: LD_INT 24
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: LIST
20397: LIST
20398: ST_TO_ADDR
20399: GO 20548
20401: LD_INT 51
20403: DOUBLE
20404: EQUAL
20405: IFTRUE 20409
20407: GO 20435
20409: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20410: LD_ADDR_VAR 0 3
20414: PUSH
20415: LD_INT 21
20417: PUSH
20418: LD_INT 22
20420: PUSH
20421: LD_INT 23
20423: PUSH
20424: LD_INT 24
20426: PUSH
20427: EMPTY
20428: LIST
20429: LIST
20430: LIST
20431: LIST
20432: ST_TO_ADDR
20433: GO 20548
20435: LD_INT 52
20437: DOUBLE
20438: EQUAL
20439: IFTRUE 20443
20441: GO 20469
20443: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20444: LD_ADDR_VAR 0 3
20448: PUSH
20449: LD_INT 21
20451: PUSH
20452: LD_INT 22
20454: PUSH
20455: LD_INT 23
20457: PUSH
20458: LD_INT 24
20460: PUSH
20461: EMPTY
20462: LIST
20463: LIST
20464: LIST
20465: LIST
20466: ST_TO_ADDR
20467: GO 20548
20469: LD_INT 53
20471: DOUBLE
20472: EQUAL
20473: IFTRUE 20477
20475: GO 20495
20477: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20478: LD_ADDR_VAR 0 3
20482: PUSH
20483: LD_INT 23
20485: PUSH
20486: LD_INT 24
20488: PUSH
20489: EMPTY
20490: LIST
20491: LIST
20492: ST_TO_ADDR
20493: GO 20548
20495: LD_INT 46
20497: DOUBLE
20498: EQUAL
20499: IFTRUE 20503
20501: GO 20521
20503: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20504: LD_ADDR_VAR 0 3
20508: PUSH
20509: LD_INT 23
20511: PUSH
20512: LD_INT 24
20514: PUSH
20515: EMPTY
20516: LIST
20517: LIST
20518: ST_TO_ADDR
20519: GO 20548
20521: LD_INT 47
20523: DOUBLE
20524: EQUAL
20525: IFTRUE 20529
20527: GO 20547
20529: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20530: LD_ADDR_VAR 0 3
20534: PUSH
20535: LD_INT 23
20537: PUSH
20538: LD_INT 24
20540: PUSH
20541: EMPTY
20542: LIST
20543: LIST
20544: ST_TO_ADDR
20545: GO 20548
20547: POP
// result := ( chassis in result ) ;
20548: LD_ADDR_VAR 0 3
20552: PUSH
20553: LD_VAR 0 1
20557: PUSH
20558: LD_VAR 0 3
20562: IN
20563: ST_TO_ADDR
// end ;
20564: LD_VAR 0 3
20568: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20569: LD_INT 0
20571: PPUSH
20572: PPUSH
20573: PPUSH
20574: PPUSH
20575: PPUSH
20576: PPUSH
20577: PPUSH
// result := array ;
20578: LD_ADDR_VAR 0 5
20582: PUSH
20583: LD_VAR 0 1
20587: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20588: LD_VAR 0 1
20592: NOT
20593: PUSH
20594: LD_VAR 0 2
20598: NOT
20599: OR
20600: PUSH
20601: LD_VAR 0 3
20605: NOT
20606: OR
20607: PUSH
20608: LD_VAR 0 2
20612: PUSH
20613: LD_VAR 0 1
20617: GREATER
20618: OR
20619: PUSH
20620: LD_VAR 0 3
20624: PUSH
20625: LD_VAR 0 1
20629: GREATER
20630: OR
20631: IFFALSE 20635
// exit ;
20633: GO 20931
// if direction then
20635: LD_VAR 0 4
20639: IFFALSE 20703
// begin d := 1 ;
20641: LD_ADDR_VAR 0 9
20645: PUSH
20646: LD_INT 1
20648: ST_TO_ADDR
// if i_from > i_to then
20649: LD_VAR 0 2
20653: PUSH
20654: LD_VAR 0 3
20658: GREATER
20659: IFFALSE 20685
// length := ( array - i_from ) + i_to else
20661: LD_ADDR_VAR 0 11
20665: PUSH
20666: LD_VAR 0 1
20670: PUSH
20671: LD_VAR 0 2
20675: MINUS
20676: PUSH
20677: LD_VAR 0 3
20681: PLUS
20682: ST_TO_ADDR
20683: GO 20701
// length := i_to - i_from ;
20685: LD_ADDR_VAR 0 11
20689: PUSH
20690: LD_VAR 0 3
20694: PUSH
20695: LD_VAR 0 2
20699: MINUS
20700: ST_TO_ADDR
// end else
20701: GO 20764
// begin d := - 1 ;
20703: LD_ADDR_VAR 0 9
20707: PUSH
20708: LD_INT 1
20710: NEG
20711: ST_TO_ADDR
// if i_from > i_to then
20712: LD_VAR 0 2
20716: PUSH
20717: LD_VAR 0 3
20721: GREATER
20722: IFFALSE 20742
// length := i_from - i_to else
20724: LD_ADDR_VAR 0 11
20728: PUSH
20729: LD_VAR 0 2
20733: PUSH
20734: LD_VAR 0 3
20738: MINUS
20739: ST_TO_ADDR
20740: GO 20764
// length := ( array - i_to ) + i_from ;
20742: LD_ADDR_VAR 0 11
20746: PUSH
20747: LD_VAR 0 1
20751: PUSH
20752: LD_VAR 0 3
20756: MINUS
20757: PUSH
20758: LD_VAR 0 2
20762: PLUS
20763: ST_TO_ADDR
// end ; if not length then
20764: LD_VAR 0 11
20768: NOT
20769: IFFALSE 20773
// exit ;
20771: GO 20931
// tmp := array ;
20773: LD_ADDR_VAR 0 10
20777: PUSH
20778: LD_VAR 0 1
20782: ST_TO_ADDR
// for i = 1 to length do
20783: LD_ADDR_VAR 0 6
20787: PUSH
20788: DOUBLE
20789: LD_INT 1
20791: DEC
20792: ST_TO_ADDR
20793: LD_VAR 0 11
20797: PUSH
20798: FOR_TO
20799: IFFALSE 20919
// begin for j = 1 to array do
20801: LD_ADDR_VAR 0 7
20805: PUSH
20806: DOUBLE
20807: LD_INT 1
20809: DEC
20810: ST_TO_ADDR
20811: LD_VAR 0 1
20815: PUSH
20816: FOR_TO
20817: IFFALSE 20905
// begin k := j + d ;
20819: LD_ADDR_VAR 0 8
20823: PUSH
20824: LD_VAR 0 7
20828: PUSH
20829: LD_VAR 0 9
20833: PLUS
20834: ST_TO_ADDR
// if k > array then
20835: LD_VAR 0 8
20839: PUSH
20840: LD_VAR 0 1
20844: GREATER
20845: IFFALSE 20855
// k := 1 ;
20847: LD_ADDR_VAR 0 8
20851: PUSH
20852: LD_INT 1
20854: ST_TO_ADDR
// if not k then
20855: LD_VAR 0 8
20859: NOT
20860: IFFALSE 20872
// k := array ;
20862: LD_ADDR_VAR 0 8
20866: PUSH
20867: LD_VAR 0 1
20871: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20872: LD_ADDR_VAR 0 10
20876: PUSH
20877: LD_VAR 0 10
20881: PPUSH
20882: LD_VAR 0 8
20886: PPUSH
20887: LD_VAR 0 1
20891: PUSH
20892: LD_VAR 0 7
20896: ARRAY
20897: PPUSH
20898: CALL_OW 1
20902: ST_TO_ADDR
// end ;
20903: GO 20816
20905: POP
20906: POP
// array := tmp ;
20907: LD_ADDR_VAR 0 1
20911: PUSH
20912: LD_VAR 0 10
20916: ST_TO_ADDR
// end ;
20917: GO 20798
20919: POP
20920: POP
// result := array ;
20921: LD_ADDR_VAR 0 5
20925: PUSH
20926: LD_VAR 0 1
20930: ST_TO_ADDR
// end ;
20931: LD_VAR 0 5
20935: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20936: LD_INT 0
20938: PPUSH
20939: PPUSH
// result := 0 ;
20940: LD_ADDR_VAR 0 3
20944: PUSH
20945: LD_INT 0
20947: ST_TO_ADDR
// if not array or not value in array then
20948: LD_VAR 0 1
20952: NOT
20953: PUSH
20954: LD_VAR 0 2
20958: PUSH
20959: LD_VAR 0 1
20963: IN
20964: NOT
20965: OR
20966: IFFALSE 20970
// exit ;
20968: GO 21024
// for i = 1 to array do
20970: LD_ADDR_VAR 0 4
20974: PUSH
20975: DOUBLE
20976: LD_INT 1
20978: DEC
20979: ST_TO_ADDR
20980: LD_VAR 0 1
20984: PUSH
20985: FOR_TO
20986: IFFALSE 21022
// if value = array [ i ] then
20988: LD_VAR 0 2
20992: PUSH
20993: LD_VAR 0 1
20997: PUSH
20998: LD_VAR 0 4
21002: ARRAY
21003: EQUAL
21004: IFFALSE 21020
// begin result := i ;
21006: LD_ADDR_VAR 0 3
21010: PUSH
21011: LD_VAR 0 4
21015: ST_TO_ADDR
// exit ;
21016: POP
21017: POP
21018: GO 21024
// end ;
21020: GO 20985
21022: POP
21023: POP
// end ;
21024: LD_VAR 0 3
21028: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21029: LD_INT 0
21031: PPUSH
// vc_chassis := chassis ;
21032: LD_ADDR_OWVAR 37
21036: PUSH
21037: LD_VAR 0 1
21041: ST_TO_ADDR
// vc_engine := engine ;
21042: LD_ADDR_OWVAR 39
21046: PUSH
21047: LD_VAR 0 2
21051: ST_TO_ADDR
// vc_control := control ;
21052: LD_ADDR_OWVAR 38
21056: PUSH
21057: LD_VAR 0 3
21061: ST_TO_ADDR
// vc_weapon := weapon ;
21062: LD_ADDR_OWVAR 40
21066: PUSH
21067: LD_VAR 0 4
21071: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21072: LD_ADDR_OWVAR 41
21076: PUSH
21077: LD_VAR 0 5
21081: ST_TO_ADDR
// end ;
21082: LD_VAR 0 6
21086: RET
// export function WantPlant ( unit ) ; var task ; begin
21087: LD_INT 0
21089: PPUSH
21090: PPUSH
// result := false ;
21091: LD_ADDR_VAR 0 2
21095: PUSH
21096: LD_INT 0
21098: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21099: LD_ADDR_VAR 0 3
21103: PUSH
21104: LD_VAR 0 1
21108: PPUSH
21109: CALL_OW 437
21113: ST_TO_ADDR
// if task then
21114: LD_VAR 0 3
21118: IFFALSE 21146
// if task [ 1 ] [ 1 ] = p then
21120: LD_VAR 0 3
21124: PUSH
21125: LD_INT 1
21127: ARRAY
21128: PUSH
21129: LD_INT 1
21131: ARRAY
21132: PUSH
21133: LD_STRING p
21135: EQUAL
21136: IFFALSE 21146
// result := true ;
21138: LD_ADDR_VAR 0 2
21142: PUSH
21143: LD_INT 1
21145: ST_TO_ADDR
// end ;
21146: LD_VAR 0 2
21150: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21151: LD_INT 0
21153: PPUSH
21154: PPUSH
21155: PPUSH
21156: PPUSH
// if pos < 1 then
21157: LD_VAR 0 2
21161: PUSH
21162: LD_INT 1
21164: LESS
21165: IFFALSE 21169
// exit ;
21167: GO 21472
// if pos = 1 then
21169: LD_VAR 0 2
21173: PUSH
21174: LD_INT 1
21176: EQUAL
21177: IFFALSE 21210
// result := Replace ( arr , pos [ 1 ] , value ) else
21179: LD_ADDR_VAR 0 4
21183: PUSH
21184: LD_VAR 0 1
21188: PPUSH
21189: LD_VAR 0 2
21193: PUSH
21194: LD_INT 1
21196: ARRAY
21197: PPUSH
21198: LD_VAR 0 3
21202: PPUSH
21203: CALL_OW 1
21207: ST_TO_ADDR
21208: GO 21472
// begin tmp := arr ;
21210: LD_ADDR_VAR 0 6
21214: PUSH
21215: LD_VAR 0 1
21219: ST_TO_ADDR
// s_arr := [ tmp ] ;
21220: LD_ADDR_VAR 0 7
21224: PUSH
21225: LD_VAR 0 6
21229: PUSH
21230: EMPTY
21231: LIST
21232: ST_TO_ADDR
// for i = 1 to pos - 1 do
21233: LD_ADDR_VAR 0 5
21237: PUSH
21238: DOUBLE
21239: LD_INT 1
21241: DEC
21242: ST_TO_ADDR
21243: LD_VAR 0 2
21247: PUSH
21248: LD_INT 1
21250: MINUS
21251: PUSH
21252: FOR_TO
21253: IFFALSE 21298
// begin tmp := tmp [ pos [ i ] ] ;
21255: LD_ADDR_VAR 0 6
21259: PUSH
21260: LD_VAR 0 6
21264: PUSH
21265: LD_VAR 0 2
21269: PUSH
21270: LD_VAR 0 5
21274: ARRAY
21275: ARRAY
21276: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21277: LD_ADDR_VAR 0 7
21281: PUSH
21282: LD_VAR 0 7
21286: PUSH
21287: LD_VAR 0 6
21291: PUSH
21292: EMPTY
21293: LIST
21294: ADD
21295: ST_TO_ADDR
// end ;
21296: GO 21252
21298: POP
21299: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21300: LD_ADDR_VAR 0 6
21304: PUSH
21305: LD_VAR 0 6
21309: PPUSH
21310: LD_VAR 0 2
21314: PUSH
21315: LD_VAR 0 2
21319: ARRAY
21320: PPUSH
21321: LD_VAR 0 3
21325: PPUSH
21326: CALL_OW 1
21330: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21331: LD_ADDR_VAR 0 7
21335: PUSH
21336: LD_VAR 0 7
21340: PPUSH
21341: LD_VAR 0 7
21345: PPUSH
21346: LD_VAR 0 6
21350: PPUSH
21351: CALL_OW 1
21355: ST_TO_ADDR
// for i = s_arr downto 2 do
21356: LD_ADDR_VAR 0 5
21360: PUSH
21361: DOUBLE
21362: LD_VAR 0 7
21366: INC
21367: ST_TO_ADDR
21368: LD_INT 2
21370: PUSH
21371: FOR_DOWNTO
21372: IFFALSE 21456
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21374: LD_ADDR_VAR 0 6
21378: PUSH
21379: LD_VAR 0 7
21383: PUSH
21384: LD_VAR 0 5
21388: PUSH
21389: LD_INT 1
21391: MINUS
21392: ARRAY
21393: PPUSH
21394: LD_VAR 0 2
21398: PUSH
21399: LD_VAR 0 5
21403: PUSH
21404: LD_INT 1
21406: MINUS
21407: ARRAY
21408: PPUSH
21409: LD_VAR 0 7
21413: PUSH
21414: LD_VAR 0 5
21418: ARRAY
21419: PPUSH
21420: CALL_OW 1
21424: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21425: LD_ADDR_VAR 0 7
21429: PUSH
21430: LD_VAR 0 7
21434: PPUSH
21435: LD_VAR 0 5
21439: PUSH
21440: LD_INT 1
21442: MINUS
21443: PPUSH
21444: LD_VAR 0 6
21448: PPUSH
21449: CALL_OW 1
21453: ST_TO_ADDR
// end ;
21454: GO 21371
21456: POP
21457: POP
// result := s_arr [ 1 ] ;
21458: LD_ADDR_VAR 0 4
21462: PUSH
21463: LD_VAR 0 7
21467: PUSH
21468: LD_INT 1
21470: ARRAY
21471: ST_TO_ADDR
// end ; end ;
21472: LD_VAR 0 4
21476: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21477: LD_INT 0
21479: PPUSH
21480: PPUSH
// if not list then
21481: LD_VAR 0 1
21485: NOT
21486: IFFALSE 21490
// exit ;
21488: GO 21581
// i := list [ pos1 ] ;
21490: LD_ADDR_VAR 0 5
21494: PUSH
21495: LD_VAR 0 1
21499: PUSH
21500: LD_VAR 0 2
21504: ARRAY
21505: ST_TO_ADDR
// if not i then
21506: LD_VAR 0 5
21510: NOT
21511: IFFALSE 21515
// exit ;
21513: GO 21581
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21515: LD_ADDR_VAR 0 1
21519: PUSH
21520: LD_VAR 0 1
21524: PPUSH
21525: LD_VAR 0 2
21529: PPUSH
21530: LD_VAR 0 1
21534: PUSH
21535: LD_VAR 0 3
21539: ARRAY
21540: PPUSH
21541: CALL_OW 1
21545: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21546: LD_ADDR_VAR 0 1
21550: PUSH
21551: LD_VAR 0 1
21555: PPUSH
21556: LD_VAR 0 3
21560: PPUSH
21561: LD_VAR 0 5
21565: PPUSH
21566: CALL_OW 1
21570: ST_TO_ADDR
// result := list ;
21571: LD_ADDR_VAR 0 4
21575: PUSH
21576: LD_VAR 0 1
21580: ST_TO_ADDR
// end ;
21581: LD_VAR 0 4
21585: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21586: LD_INT 0
21588: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21589: LD_ADDR_VAR 0 5
21593: PUSH
21594: LD_VAR 0 1
21598: PPUSH
21599: CALL_OW 250
21603: PPUSH
21604: LD_VAR 0 1
21608: PPUSH
21609: CALL_OW 251
21613: PPUSH
21614: LD_VAR 0 2
21618: PPUSH
21619: LD_VAR 0 3
21623: PPUSH
21624: LD_VAR 0 4
21628: PPUSH
21629: CALL 21639 0 5
21633: ST_TO_ADDR
// end ;
21634: LD_VAR 0 5
21638: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21639: LD_INT 0
21641: PPUSH
21642: PPUSH
21643: PPUSH
21644: PPUSH
// if not list then
21645: LD_VAR 0 3
21649: NOT
21650: IFFALSE 21654
// exit ;
21652: GO 22042
// result := [ ] ;
21654: LD_ADDR_VAR 0 6
21658: PUSH
21659: EMPTY
21660: ST_TO_ADDR
// for i in list do
21661: LD_ADDR_VAR 0 7
21665: PUSH
21666: LD_VAR 0 3
21670: PUSH
21671: FOR_IN
21672: IFFALSE 21874
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21674: LD_ADDR_VAR 0 9
21678: PUSH
21679: LD_VAR 0 7
21683: PPUSH
21684: LD_VAR 0 1
21688: PPUSH
21689: LD_VAR 0 2
21693: PPUSH
21694: CALL_OW 297
21698: ST_TO_ADDR
// if not result then
21699: LD_VAR 0 6
21703: NOT
21704: IFFALSE 21730
// result := [ [ i , tmp ] ] else
21706: LD_ADDR_VAR 0 6
21710: PUSH
21711: LD_VAR 0 7
21715: PUSH
21716: LD_VAR 0 9
21720: PUSH
21721: EMPTY
21722: LIST
21723: LIST
21724: PUSH
21725: EMPTY
21726: LIST
21727: ST_TO_ADDR
21728: GO 21872
// begin if result [ result ] [ 2 ] < tmp then
21730: LD_VAR 0 6
21734: PUSH
21735: LD_VAR 0 6
21739: ARRAY
21740: PUSH
21741: LD_INT 2
21743: ARRAY
21744: PUSH
21745: LD_VAR 0 9
21749: LESS
21750: IFFALSE 21792
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21752: LD_ADDR_VAR 0 6
21756: PUSH
21757: LD_VAR 0 6
21761: PPUSH
21762: LD_VAR 0 6
21766: PUSH
21767: LD_INT 1
21769: PLUS
21770: PPUSH
21771: LD_VAR 0 7
21775: PUSH
21776: LD_VAR 0 9
21780: PUSH
21781: EMPTY
21782: LIST
21783: LIST
21784: PPUSH
21785: CALL_OW 2
21789: ST_TO_ADDR
21790: GO 21872
// for j = 1 to result do
21792: LD_ADDR_VAR 0 8
21796: PUSH
21797: DOUBLE
21798: LD_INT 1
21800: DEC
21801: ST_TO_ADDR
21802: LD_VAR 0 6
21806: PUSH
21807: FOR_TO
21808: IFFALSE 21870
// begin if tmp < result [ j ] [ 2 ] then
21810: LD_VAR 0 9
21814: PUSH
21815: LD_VAR 0 6
21819: PUSH
21820: LD_VAR 0 8
21824: ARRAY
21825: PUSH
21826: LD_INT 2
21828: ARRAY
21829: LESS
21830: IFFALSE 21868
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21832: LD_ADDR_VAR 0 6
21836: PUSH
21837: LD_VAR 0 6
21841: PPUSH
21842: LD_VAR 0 8
21846: PPUSH
21847: LD_VAR 0 7
21851: PUSH
21852: LD_VAR 0 9
21856: PUSH
21857: EMPTY
21858: LIST
21859: LIST
21860: PPUSH
21861: CALL_OW 2
21865: ST_TO_ADDR
// break ;
21866: GO 21870
// end ; end ;
21868: GO 21807
21870: POP
21871: POP
// end ; end ;
21872: GO 21671
21874: POP
21875: POP
// if result and not asc then
21876: LD_VAR 0 6
21880: PUSH
21881: LD_VAR 0 4
21885: NOT
21886: AND
21887: IFFALSE 21962
// begin tmp := result ;
21889: LD_ADDR_VAR 0 9
21893: PUSH
21894: LD_VAR 0 6
21898: ST_TO_ADDR
// for i = tmp downto 1 do
21899: LD_ADDR_VAR 0 7
21903: PUSH
21904: DOUBLE
21905: LD_VAR 0 9
21909: INC
21910: ST_TO_ADDR
21911: LD_INT 1
21913: PUSH
21914: FOR_DOWNTO
21915: IFFALSE 21960
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21917: LD_ADDR_VAR 0 6
21921: PUSH
21922: LD_VAR 0 6
21926: PPUSH
21927: LD_VAR 0 9
21931: PUSH
21932: LD_VAR 0 7
21936: MINUS
21937: PUSH
21938: LD_INT 1
21940: PLUS
21941: PPUSH
21942: LD_VAR 0 9
21946: PUSH
21947: LD_VAR 0 7
21951: ARRAY
21952: PPUSH
21953: CALL_OW 1
21957: ST_TO_ADDR
21958: GO 21914
21960: POP
21961: POP
// end ; tmp := [ ] ;
21962: LD_ADDR_VAR 0 9
21966: PUSH
21967: EMPTY
21968: ST_TO_ADDR
// if mode then
21969: LD_VAR 0 5
21973: IFFALSE 22042
// begin for i = 1 to result do
21975: LD_ADDR_VAR 0 7
21979: PUSH
21980: DOUBLE
21981: LD_INT 1
21983: DEC
21984: ST_TO_ADDR
21985: LD_VAR 0 6
21989: PUSH
21990: FOR_TO
21991: IFFALSE 22030
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21993: LD_ADDR_VAR 0 9
21997: PUSH
21998: LD_VAR 0 9
22002: PPUSH
22003: LD_VAR 0 7
22007: PPUSH
22008: LD_VAR 0 6
22012: PUSH
22013: LD_VAR 0 7
22017: ARRAY
22018: PUSH
22019: LD_INT 1
22021: ARRAY
22022: PPUSH
22023: CALL_OW 1
22027: ST_TO_ADDR
22028: GO 21990
22030: POP
22031: POP
// result := tmp ;
22032: LD_ADDR_VAR 0 6
22036: PUSH
22037: LD_VAR 0 9
22041: ST_TO_ADDR
// end ; end ;
22042: LD_VAR 0 6
22046: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22047: LD_INT 0
22049: PPUSH
22050: PPUSH
22051: PPUSH
22052: PPUSH
22053: PPUSH
22054: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22055: LD_ADDR_VAR 0 5
22059: PUSH
22060: LD_INT 0
22062: PUSH
22063: LD_INT 0
22065: PUSH
22066: LD_INT 0
22068: PUSH
22069: EMPTY
22070: PUSH
22071: EMPTY
22072: LIST
22073: LIST
22074: LIST
22075: LIST
22076: ST_TO_ADDR
// if not x or not y then
22077: LD_VAR 0 2
22081: NOT
22082: PUSH
22083: LD_VAR 0 3
22087: NOT
22088: OR
22089: IFFALSE 22093
// exit ;
22091: GO 23739
// if not range then
22093: LD_VAR 0 4
22097: NOT
22098: IFFALSE 22108
// range := 10 ;
22100: LD_ADDR_VAR 0 4
22104: PUSH
22105: LD_INT 10
22107: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22108: LD_ADDR_VAR 0 8
22112: PUSH
22113: LD_INT 81
22115: PUSH
22116: LD_VAR 0 1
22120: PUSH
22121: EMPTY
22122: LIST
22123: LIST
22124: PUSH
22125: LD_INT 92
22127: PUSH
22128: LD_VAR 0 2
22132: PUSH
22133: LD_VAR 0 3
22137: PUSH
22138: LD_VAR 0 4
22142: PUSH
22143: EMPTY
22144: LIST
22145: LIST
22146: LIST
22147: LIST
22148: PUSH
22149: LD_INT 3
22151: PUSH
22152: LD_INT 21
22154: PUSH
22155: LD_INT 3
22157: PUSH
22158: EMPTY
22159: LIST
22160: LIST
22161: PUSH
22162: EMPTY
22163: LIST
22164: LIST
22165: PUSH
22166: EMPTY
22167: LIST
22168: LIST
22169: LIST
22170: PPUSH
22171: CALL_OW 69
22175: ST_TO_ADDR
// if not tmp then
22176: LD_VAR 0 8
22180: NOT
22181: IFFALSE 22185
// exit ;
22183: GO 23739
// for i in tmp do
22185: LD_ADDR_VAR 0 6
22189: PUSH
22190: LD_VAR 0 8
22194: PUSH
22195: FOR_IN
22196: IFFALSE 23714
// begin points := [ 0 , 0 , 0 ] ;
22198: LD_ADDR_VAR 0 9
22202: PUSH
22203: LD_INT 0
22205: PUSH
22206: LD_INT 0
22208: PUSH
22209: LD_INT 0
22211: PUSH
22212: EMPTY
22213: LIST
22214: LIST
22215: LIST
22216: ST_TO_ADDR
// bpoints := 1 ;
22217: LD_ADDR_VAR 0 10
22221: PUSH
22222: LD_INT 1
22224: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22225: LD_VAR 0 6
22229: PPUSH
22230: CALL_OW 247
22234: PUSH
22235: LD_INT 1
22237: DOUBLE
22238: EQUAL
22239: IFTRUE 22243
22241: GO 22821
22243: POP
// begin if GetClass ( i ) = 1 then
22244: LD_VAR 0 6
22248: PPUSH
22249: CALL_OW 257
22253: PUSH
22254: LD_INT 1
22256: EQUAL
22257: IFFALSE 22278
// points := [ 10 , 5 , 3 ] ;
22259: LD_ADDR_VAR 0 9
22263: PUSH
22264: LD_INT 10
22266: PUSH
22267: LD_INT 5
22269: PUSH
22270: LD_INT 3
22272: PUSH
22273: EMPTY
22274: LIST
22275: LIST
22276: LIST
22277: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22278: LD_VAR 0 6
22282: PPUSH
22283: CALL_OW 257
22287: PUSH
22288: LD_INT 2
22290: PUSH
22291: LD_INT 3
22293: PUSH
22294: LD_INT 4
22296: PUSH
22297: EMPTY
22298: LIST
22299: LIST
22300: LIST
22301: IN
22302: IFFALSE 22323
// points := [ 3 , 2 , 1 ] ;
22304: LD_ADDR_VAR 0 9
22308: PUSH
22309: LD_INT 3
22311: PUSH
22312: LD_INT 2
22314: PUSH
22315: LD_INT 1
22317: PUSH
22318: EMPTY
22319: LIST
22320: LIST
22321: LIST
22322: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22323: LD_VAR 0 6
22327: PPUSH
22328: CALL_OW 257
22332: PUSH
22333: LD_INT 5
22335: EQUAL
22336: IFFALSE 22357
// points := [ 130 , 5 , 2 ] ;
22338: LD_ADDR_VAR 0 9
22342: PUSH
22343: LD_INT 130
22345: PUSH
22346: LD_INT 5
22348: PUSH
22349: LD_INT 2
22351: PUSH
22352: EMPTY
22353: LIST
22354: LIST
22355: LIST
22356: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22357: LD_VAR 0 6
22361: PPUSH
22362: CALL_OW 257
22366: PUSH
22367: LD_INT 8
22369: EQUAL
22370: IFFALSE 22391
// points := [ 35 , 35 , 30 ] ;
22372: LD_ADDR_VAR 0 9
22376: PUSH
22377: LD_INT 35
22379: PUSH
22380: LD_INT 35
22382: PUSH
22383: LD_INT 30
22385: PUSH
22386: EMPTY
22387: LIST
22388: LIST
22389: LIST
22390: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22391: LD_VAR 0 6
22395: PPUSH
22396: CALL_OW 257
22400: PUSH
22401: LD_INT 9
22403: EQUAL
22404: IFFALSE 22425
// points := [ 20 , 55 , 40 ] ;
22406: LD_ADDR_VAR 0 9
22410: PUSH
22411: LD_INT 20
22413: PUSH
22414: LD_INT 55
22416: PUSH
22417: LD_INT 40
22419: PUSH
22420: EMPTY
22421: LIST
22422: LIST
22423: LIST
22424: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22425: LD_VAR 0 6
22429: PPUSH
22430: CALL_OW 257
22434: PUSH
22435: LD_INT 12
22437: PUSH
22438: LD_INT 16
22440: PUSH
22441: EMPTY
22442: LIST
22443: LIST
22444: IN
22445: IFFALSE 22466
// points := [ 5 , 3 , 2 ] ;
22447: LD_ADDR_VAR 0 9
22451: PUSH
22452: LD_INT 5
22454: PUSH
22455: LD_INT 3
22457: PUSH
22458: LD_INT 2
22460: PUSH
22461: EMPTY
22462: LIST
22463: LIST
22464: LIST
22465: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22466: LD_VAR 0 6
22470: PPUSH
22471: CALL_OW 257
22475: PUSH
22476: LD_INT 17
22478: EQUAL
22479: IFFALSE 22500
// points := [ 100 , 50 , 75 ] ;
22481: LD_ADDR_VAR 0 9
22485: PUSH
22486: LD_INT 100
22488: PUSH
22489: LD_INT 50
22491: PUSH
22492: LD_INT 75
22494: PUSH
22495: EMPTY
22496: LIST
22497: LIST
22498: LIST
22499: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22500: LD_VAR 0 6
22504: PPUSH
22505: CALL_OW 257
22509: PUSH
22510: LD_INT 15
22512: EQUAL
22513: IFFALSE 22534
// points := [ 10 , 5 , 3 ] ;
22515: LD_ADDR_VAR 0 9
22519: PUSH
22520: LD_INT 10
22522: PUSH
22523: LD_INT 5
22525: PUSH
22526: LD_INT 3
22528: PUSH
22529: EMPTY
22530: LIST
22531: LIST
22532: LIST
22533: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22534: LD_VAR 0 6
22538: PPUSH
22539: CALL_OW 257
22543: PUSH
22544: LD_INT 14
22546: EQUAL
22547: IFFALSE 22568
// points := [ 10 , 0 , 0 ] ;
22549: LD_ADDR_VAR 0 9
22553: PUSH
22554: LD_INT 10
22556: PUSH
22557: LD_INT 0
22559: PUSH
22560: LD_INT 0
22562: PUSH
22563: EMPTY
22564: LIST
22565: LIST
22566: LIST
22567: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22568: LD_VAR 0 6
22572: PPUSH
22573: CALL_OW 257
22577: PUSH
22578: LD_INT 11
22580: EQUAL
22581: IFFALSE 22602
// points := [ 30 , 10 , 5 ] ;
22583: LD_ADDR_VAR 0 9
22587: PUSH
22588: LD_INT 30
22590: PUSH
22591: LD_INT 10
22593: PUSH
22594: LD_INT 5
22596: PUSH
22597: EMPTY
22598: LIST
22599: LIST
22600: LIST
22601: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22602: LD_VAR 0 1
22606: PPUSH
22607: LD_INT 5
22609: PPUSH
22610: CALL_OW 321
22614: PUSH
22615: LD_INT 2
22617: EQUAL
22618: IFFALSE 22635
// bpoints := bpoints * 1.8 ;
22620: LD_ADDR_VAR 0 10
22624: PUSH
22625: LD_VAR 0 10
22629: PUSH
22630: LD_REAL  1.80000000000000E+0000
22633: MUL
22634: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22635: LD_VAR 0 6
22639: PPUSH
22640: CALL_OW 257
22644: PUSH
22645: LD_INT 1
22647: PUSH
22648: LD_INT 2
22650: PUSH
22651: LD_INT 3
22653: PUSH
22654: LD_INT 4
22656: PUSH
22657: EMPTY
22658: LIST
22659: LIST
22660: LIST
22661: LIST
22662: IN
22663: PUSH
22664: LD_VAR 0 1
22668: PPUSH
22669: LD_INT 51
22671: PPUSH
22672: CALL_OW 321
22676: PUSH
22677: LD_INT 2
22679: EQUAL
22680: AND
22681: IFFALSE 22698
// bpoints := bpoints * 1.2 ;
22683: LD_ADDR_VAR 0 10
22687: PUSH
22688: LD_VAR 0 10
22692: PUSH
22693: LD_REAL  1.20000000000000E+0000
22696: MUL
22697: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22698: LD_VAR 0 6
22702: PPUSH
22703: CALL_OW 257
22707: PUSH
22708: LD_INT 5
22710: PUSH
22711: LD_INT 7
22713: PUSH
22714: LD_INT 9
22716: PUSH
22717: EMPTY
22718: LIST
22719: LIST
22720: LIST
22721: IN
22722: PUSH
22723: LD_VAR 0 1
22727: PPUSH
22728: LD_INT 52
22730: PPUSH
22731: CALL_OW 321
22735: PUSH
22736: LD_INT 2
22738: EQUAL
22739: AND
22740: IFFALSE 22757
// bpoints := bpoints * 1.5 ;
22742: LD_ADDR_VAR 0 10
22746: PUSH
22747: LD_VAR 0 10
22751: PUSH
22752: LD_REAL  1.50000000000000E+0000
22755: MUL
22756: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22757: LD_VAR 0 1
22761: PPUSH
22762: LD_INT 66
22764: PPUSH
22765: CALL_OW 321
22769: PUSH
22770: LD_INT 2
22772: EQUAL
22773: IFFALSE 22790
// bpoints := bpoints * 1.1 ;
22775: LD_ADDR_VAR 0 10
22779: PUSH
22780: LD_VAR 0 10
22784: PUSH
22785: LD_REAL  1.10000000000000E+0000
22788: MUL
22789: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22790: LD_ADDR_VAR 0 10
22794: PUSH
22795: LD_VAR 0 10
22799: PUSH
22800: LD_VAR 0 6
22804: PPUSH
22805: LD_INT 1
22807: PPUSH
22808: CALL_OW 259
22812: PUSH
22813: LD_REAL  1.15000000000000E+0000
22816: MUL
22817: MUL
22818: ST_TO_ADDR
// end ; unit_vehicle :
22819: GO 23643
22821: LD_INT 2
22823: DOUBLE
22824: EQUAL
22825: IFTRUE 22829
22827: GO 23631
22829: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22830: LD_VAR 0 6
22834: PPUSH
22835: CALL_OW 264
22839: PUSH
22840: LD_INT 2
22842: PUSH
22843: LD_INT 42
22845: PUSH
22846: LD_INT 24
22848: PUSH
22849: EMPTY
22850: LIST
22851: LIST
22852: LIST
22853: IN
22854: IFFALSE 22875
// points := [ 25 , 5 , 3 ] ;
22856: LD_ADDR_VAR 0 9
22860: PUSH
22861: LD_INT 25
22863: PUSH
22864: LD_INT 5
22866: PUSH
22867: LD_INT 3
22869: PUSH
22870: EMPTY
22871: LIST
22872: LIST
22873: LIST
22874: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22875: LD_VAR 0 6
22879: PPUSH
22880: CALL_OW 264
22884: PUSH
22885: LD_INT 4
22887: PUSH
22888: LD_INT 43
22890: PUSH
22891: LD_INT 25
22893: PUSH
22894: EMPTY
22895: LIST
22896: LIST
22897: LIST
22898: IN
22899: IFFALSE 22920
// points := [ 40 , 15 , 5 ] ;
22901: LD_ADDR_VAR 0 9
22905: PUSH
22906: LD_INT 40
22908: PUSH
22909: LD_INT 15
22911: PUSH
22912: LD_INT 5
22914: PUSH
22915: EMPTY
22916: LIST
22917: LIST
22918: LIST
22919: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22920: LD_VAR 0 6
22924: PPUSH
22925: CALL_OW 264
22929: PUSH
22930: LD_INT 3
22932: PUSH
22933: LD_INT 23
22935: PUSH
22936: EMPTY
22937: LIST
22938: LIST
22939: IN
22940: IFFALSE 22961
// points := [ 7 , 25 , 8 ] ;
22942: LD_ADDR_VAR 0 9
22946: PUSH
22947: LD_INT 7
22949: PUSH
22950: LD_INT 25
22952: PUSH
22953: LD_INT 8
22955: PUSH
22956: EMPTY
22957: LIST
22958: LIST
22959: LIST
22960: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22961: LD_VAR 0 6
22965: PPUSH
22966: CALL_OW 264
22970: PUSH
22971: LD_INT 5
22973: PUSH
22974: LD_INT 27
22976: PUSH
22977: LD_INT 44
22979: PUSH
22980: EMPTY
22981: LIST
22982: LIST
22983: LIST
22984: IN
22985: IFFALSE 23006
// points := [ 14 , 50 , 16 ] ;
22987: LD_ADDR_VAR 0 9
22991: PUSH
22992: LD_INT 14
22994: PUSH
22995: LD_INT 50
22997: PUSH
22998: LD_INT 16
23000: PUSH
23001: EMPTY
23002: LIST
23003: LIST
23004: LIST
23005: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23006: LD_VAR 0 6
23010: PPUSH
23011: CALL_OW 264
23015: PUSH
23016: LD_INT 6
23018: PUSH
23019: LD_INT 46
23021: PUSH
23022: EMPTY
23023: LIST
23024: LIST
23025: IN
23026: IFFALSE 23047
// points := [ 32 , 120 , 70 ] ;
23028: LD_ADDR_VAR 0 9
23032: PUSH
23033: LD_INT 32
23035: PUSH
23036: LD_INT 120
23038: PUSH
23039: LD_INT 70
23041: PUSH
23042: EMPTY
23043: LIST
23044: LIST
23045: LIST
23046: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
23047: LD_VAR 0 6
23051: PPUSH
23052: CALL_OW 264
23056: PUSH
23057: LD_INT 7
23059: PUSH
23060: LD_INT 28
23062: PUSH
23063: LD_INT 45
23065: PUSH
23066: EMPTY
23067: LIST
23068: LIST
23069: LIST
23070: IN
23071: IFFALSE 23092
// points := [ 35 , 20 , 45 ] ;
23073: LD_ADDR_VAR 0 9
23077: PUSH
23078: LD_INT 35
23080: PUSH
23081: LD_INT 20
23083: PUSH
23084: LD_INT 45
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: LIST
23091: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23092: LD_VAR 0 6
23096: PPUSH
23097: CALL_OW 264
23101: PUSH
23102: LD_INT 47
23104: PUSH
23105: EMPTY
23106: LIST
23107: IN
23108: IFFALSE 23129
// points := [ 67 , 45 , 75 ] ;
23110: LD_ADDR_VAR 0 9
23114: PUSH
23115: LD_INT 67
23117: PUSH
23118: LD_INT 45
23120: PUSH
23121: LD_INT 75
23123: PUSH
23124: EMPTY
23125: LIST
23126: LIST
23127: LIST
23128: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23129: LD_VAR 0 6
23133: PPUSH
23134: CALL_OW 264
23138: PUSH
23139: LD_INT 26
23141: PUSH
23142: EMPTY
23143: LIST
23144: IN
23145: IFFALSE 23166
// points := [ 120 , 30 , 80 ] ;
23147: LD_ADDR_VAR 0 9
23151: PUSH
23152: LD_INT 120
23154: PUSH
23155: LD_INT 30
23157: PUSH
23158: LD_INT 80
23160: PUSH
23161: EMPTY
23162: LIST
23163: LIST
23164: LIST
23165: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23166: LD_VAR 0 6
23170: PPUSH
23171: CALL_OW 264
23175: PUSH
23176: LD_INT 22
23178: PUSH
23179: EMPTY
23180: LIST
23181: IN
23182: IFFALSE 23203
// points := [ 40 , 1 , 1 ] ;
23184: LD_ADDR_VAR 0 9
23188: PUSH
23189: LD_INT 40
23191: PUSH
23192: LD_INT 1
23194: PUSH
23195: LD_INT 1
23197: PUSH
23198: EMPTY
23199: LIST
23200: LIST
23201: LIST
23202: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23203: LD_VAR 0 6
23207: PPUSH
23208: CALL_OW 264
23212: PUSH
23213: LD_INT 29
23215: PUSH
23216: EMPTY
23217: LIST
23218: IN
23219: IFFALSE 23240
// points := [ 70 , 200 , 400 ] ;
23221: LD_ADDR_VAR 0 9
23225: PUSH
23226: LD_INT 70
23228: PUSH
23229: LD_INT 200
23231: PUSH
23232: LD_INT 400
23234: PUSH
23235: EMPTY
23236: LIST
23237: LIST
23238: LIST
23239: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23240: LD_VAR 0 6
23244: PPUSH
23245: CALL_OW 264
23249: PUSH
23250: LD_INT 14
23252: PUSH
23253: LD_INT 53
23255: PUSH
23256: EMPTY
23257: LIST
23258: LIST
23259: IN
23260: IFFALSE 23281
// points := [ 40 , 10 , 20 ] ;
23262: LD_ADDR_VAR 0 9
23266: PUSH
23267: LD_INT 40
23269: PUSH
23270: LD_INT 10
23272: PUSH
23273: LD_INT 20
23275: PUSH
23276: EMPTY
23277: LIST
23278: LIST
23279: LIST
23280: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23281: LD_VAR 0 6
23285: PPUSH
23286: CALL_OW 264
23290: PUSH
23291: LD_INT 9
23293: PUSH
23294: EMPTY
23295: LIST
23296: IN
23297: IFFALSE 23318
// points := [ 5 , 70 , 20 ] ;
23299: LD_ADDR_VAR 0 9
23303: PUSH
23304: LD_INT 5
23306: PUSH
23307: LD_INT 70
23309: PUSH
23310: LD_INT 20
23312: PUSH
23313: EMPTY
23314: LIST
23315: LIST
23316: LIST
23317: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23318: LD_VAR 0 6
23322: PPUSH
23323: CALL_OW 264
23327: PUSH
23328: LD_INT 10
23330: PUSH
23331: EMPTY
23332: LIST
23333: IN
23334: IFFALSE 23355
// points := [ 35 , 110 , 70 ] ;
23336: LD_ADDR_VAR 0 9
23340: PUSH
23341: LD_INT 35
23343: PUSH
23344: LD_INT 110
23346: PUSH
23347: LD_INT 70
23349: PUSH
23350: EMPTY
23351: LIST
23352: LIST
23353: LIST
23354: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23355: LD_VAR 0 6
23359: PPUSH
23360: CALL_OW 265
23364: PUSH
23365: LD_INT 25
23367: EQUAL
23368: IFFALSE 23389
// points := [ 80 , 65 , 100 ] ;
23370: LD_ADDR_VAR 0 9
23374: PUSH
23375: LD_INT 80
23377: PUSH
23378: LD_INT 65
23380: PUSH
23381: LD_INT 100
23383: PUSH
23384: EMPTY
23385: LIST
23386: LIST
23387: LIST
23388: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23389: LD_VAR 0 6
23393: PPUSH
23394: CALL_OW 263
23398: PUSH
23399: LD_INT 1
23401: EQUAL
23402: IFFALSE 23437
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23404: LD_ADDR_VAR 0 10
23408: PUSH
23409: LD_VAR 0 10
23413: PUSH
23414: LD_VAR 0 6
23418: PPUSH
23419: CALL_OW 311
23423: PPUSH
23424: LD_INT 3
23426: PPUSH
23427: CALL_OW 259
23431: PUSH
23432: LD_INT 4
23434: MUL
23435: MUL
23436: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23437: LD_VAR 0 6
23441: PPUSH
23442: CALL_OW 263
23446: PUSH
23447: LD_INT 2
23449: EQUAL
23450: IFFALSE 23501
// begin j := IsControledBy ( i ) ;
23452: LD_ADDR_VAR 0 7
23456: PUSH
23457: LD_VAR 0 6
23461: PPUSH
23462: CALL_OW 312
23466: ST_TO_ADDR
// if j then
23467: LD_VAR 0 7
23471: IFFALSE 23501
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23473: LD_ADDR_VAR 0 10
23477: PUSH
23478: LD_VAR 0 10
23482: PUSH
23483: LD_VAR 0 7
23487: PPUSH
23488: LD_INT 3
23490: PPUSH
23491: CALL_OW 259
23495: PUSH
23496: LD_INT 3
23498: MUL
23499: MUL
23500: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23501: LD_VAR 0 6
23505: PPUSH
23506: CALL_OW 264
23510: PUSH
23511: LD_INT 5
23513: PUSH
23514: LD_INT 6
23516: PUSH
23517: LD_INT 46
23519: PUSH
23520: LD_INT 44
23522: PUSH
23523: LD_INT 47
23525: PUSH
23526: LD_INT 45
23528: PUSH
23529: LD_INT 28
23531: PUSH
23532: LD_INT 7
23534: PUSH
23535: LD_INT 27
23537: PUSH
23538: LD_INT 29
23540: PUSH
23541: EMPTY
23542: LIST
23543: LIST
23544: LIST
23545: LIST
23546: LIST
23547: LIST
23548: LIST
23549: LIST
23550: LIST
23551: LIST
23552: IN
23553: PUSH
23554: LD_VAR 0 1
23558: PPUSH
23559: LD_INT 52
23561: PPUSH
23562: CALL_OW 321
23566: PUSH
23567: LD_INT 2
23569: EQUAL
23570: AND
23571: IFFALSE 23588
// bpoints := bpoints * 1.2 ;
23573: LD_ADDR_VAR 0 10
23577: PUSH
23578: LD_VAR 0 10
23582: PUSH
23583: LD_REAL  1.20000000000000E+0000
23586: MUL
23587: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23588: LD_VAR 0 6
23592: PPUSH
23593: CALL_OW 264
23597: PUSH
23598: LD_INT 6
23600: PUSH
23601: LD_INT 46
23603: PUSH
23604: LD_INT 47
23606: PUSH
23607: EMPTY
23608: LIST
23609: LIST
23610: LIST
23611: IN
23612: IFFALSE 23629
// bpoints := bpoints * 1.2 ;
23614: LD_ADDR_VAR 0 10
23618: PUSH
23619: LD_VAR 0 10
23623: PUSH
23624: LD_REAL  1.20000000000000E+0000
23627: MUL
23628: ST_TO_ADDR
// end ; unit_building :
23629: GO 23643
23631: LD_INT 3
23633: DOUBLE
23634: EQUAL
23635: IFTRUE 23639
23637: GO 23642
23639: POP
// ; end ;
23640: GO 23643
23642: POP
// for j = 1 to 3 do
23643: LD_ADDR_VAR 0 7
23647: PUSH
23648: DOUBLE
23649: LD_INT 1
23651: DEC
23652: ST_TO_ADDR
23653: LD_INT 3
23655: PUSH
23656: FOR_TO
23657: IFFALSE 23710
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23659: LD_ADDR_VAR 0 5
23663: PUSH
23664: LD_VAR 0 5
23668: PPUSH
23669: LD_VAR 0 7
23673: PPUSH
23674: LD_VAR 0 5
23678: PUSH
23679: LD_VAR 0 7
23683: ARRAY
23684: PUSH
23685: LD_VAR 0 9
23689: PUSH
23690: LD_VAR 0 7
23694: ARRAY
23695: PUSH
23696: LD_VAR 0 10
23700: MUL
23701: PLUS
23702: PPUSH
23703: CALL_OW 1
23707: ST_TO_ADDR
23708: GO 23656
23710: POP
23711: POP
// end ;
23712: GO 22195
23714: POP
23715: POP
// result := Replace ( result , 4 , tmp ) ;
23716: LD_ADDR_VAR 0 5
23720: PUSH
23721: LD_VAR 0 5
23725: PPUSH
23726: LD_INT 4
23728: PPUSH
23729: LD_VAR 0 8
23733: PPUSH
23734: CALL_OW 1
23738: ST_TO_ADDR
// end ;
23739: LD_VAR 0 5
23743: RET
// export function DangerAtRange ( unit , range ) ; begin
23744: LD_INT 0
23746: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23747: LD_ADDR_VAR 0 3
23751: PUSH
23752: LD_VAR 0 1
23756: PPUSH
23757: CALL_OW 255
23761: PPUSH
23762: LD_VAR 0 1
23766: PPUSH
23767: CALL_OW 250
23771: PPUSH
23772: LD_VAR 0 1
23776: PPUSH
23777: CALL_OW 251
23781: PPUSH
23782: LD_VAR 0 2
23786: PPUSH
23787: CALL 22047 0 4
23791: ST_TO_ADDR
// end ;
23792: LD_VAR 0 3
23796: RET
// export function DangerInArea ( side , area ) ; begin
23797: LD_INT 0
23799: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23800: LD_ADDR_VAR 0 3
23804: PUSH
23805: LD_VAR 0 2
23809: PPUSH
23810: LD_INT 81
23812: PUSH
23813: LD_VAR 0 1
23817: PUSH
23818: EMPTY
23819: LIST
23820: LIST
23821: PPUSH
23822: CALL_OW 70
23826: ST_TO_ADDR
// end ;
23827: LD_VAR 0 3
23831: RET
// export function IsExtension ( b ) ; begin
23832: LD_INT 0
23834: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23835: LD_ADDR_VAR 0 2
23839: PUSH
23840: LD_VAR 0 1
23844: PUSH
23845: LD_INT 23
23847: PUSH
23848: LD_INT 20
23850: PUSH
23851: LD_INT 22
23853: PUSH
23854: LD_INT 17
23856: PUSH
23857: LD_INT 24
23859: PUSH
23860: LD_INT 21
23862: PUSH
23863: LD_INT 19
23865: PUSH
23866: LD_INT 16
23868: PUSH
23869: LD_INT 25
23871: PUSH
23872: LD_INT 18
23874: PUSH
23875: EMPTY
23876: LIST
23877: LIST
23878: LIST
23879: LIST
23880: LIST
23881: LIST
23882: LIST
23883: LIST
23884: LIST
23885: LIST
23886: IN
23887: ST_TO_ADDR
// end ;
23888: LD_VAR 0 2
23892: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23893: LD_INT 0
23895: PPUSH
23896: PPUSH
23897: PPUSH
// result := [ ] ;
23898: LD_ADDR_VAR 0 3
23902: PUSH
23903: EMPTY
23904: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23905: LD_ADDR_VAR 0 4
23909: PUSH
23910: LD_VAR 0 2
23914: PPUSH
23915: LD_INT 21
23917: PUSH
23918: LD_INT 3
23920: PUSH
23921: EMPTY
23922: LIST
23923: LIST
23924: PPUSH
23925: CALL_OW 70
23929: ST_TO_ADDR
// if not tmp then
23930: LD_VAR 0 4
23934: NOT
23935: IFFALSE 23939
// exit ;
23937: GO 23997
// for i in tmp do
23939: LD_ADDR_VAR 0 5
23943: PUSH
23944: LD_VAR 0 4
23948: PUSH
23949: FOR_IN
23950: IFFALSE 23985
// if GetBase ( i ) <> base then
23952: LD_VAR 0 5
23956: PPUSH
23957: CALL_OW 274
23961: PUSH
23962: LD_VAR 0 1
23966: NONEQUAL
23967: IFFALSE 23983
// ComLinkToBase ( base , i ) ;
23969: LD_VAR 0 1
23973: PPUSH
23974: LD_VAR 0 5
23978: PPUSH
23979: CALL_OW 169
23983: GO 23949
23985: POP
23986: POP
// result := tmp ;
23987: LD_ADDR_VAR 0 3
23991: PUSH
23992: LD_VAR 0 4
23996: ST_TO_ADDR
// end ;
23997: LD_VAR 0 3
24001: RET
// export function ComComplete ( unit , b ) ; var i ; begin
24002: LD_INT 0
24004: PPUSH
24005: PPUSH
// if BuildingStatus ( b ) = bs_build then
24006: LD_VAR 0 2
24010: PPUSH
24011: CALL_OW 461
24015: PUSH
24016: LD_INT 1
24018: EQUAL
24019: IFFALSE 24079
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24021: LD_VAR 0 1
24025: PPUSH
24026: LD_STRING h
24028: PUSH
24029: LD_VAR 0 2
24033: PPUSH
24034: CALL_OW 250
24038: PUSH
24039: LD_VAR 0 2
24043: PPUSH
24044: CALL_OW 251
24048: PUSH
24049: LD_VAR 0 2
24053: PUSH
24054: LD_INT 0
24056: PUSH
24057: LD_INT 0
24059: PUSH
24060: LD_INT 0
24062: PUSH
24063: EMPTY
24064: LIST
24065: LIST
24066: LIST
24067: LIST
24068: LIST
24069: LIST
24070: LIST
24071: PUSH
24072: EMPTY
24073: LIST
24074: PPUSH
24075: CALL_OW 446
// end ;
24079: LD_VAR 0 3
24083: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24084: LD_INT 0
24086: PPUSH
24087: PPUSH
24088: PPUSH
24089: PPUSH
24090: PPUSH
24091: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
24092: LD_VAR 0 1
24096: NOT
24097: PUSH
24098: LD_VAR 0 1
24102: PPUSH
24103: CALL_OW 263
24107: PUSH
24108: LD_INT 2
24110: EQUAL
24111: NOT
24112: OR
24113: IFFALSE 24117
// exit ;
24115: GO 24433
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24117: LD_ADDR_VAR 0 6
24121: PUSH
24122: LD_INT 22
24124: PUSH
24125: LD_VAR 0 1
24129: PPUSH
24130: CALL_OW 255
24134: PUSH
24135: EMPTY
24136: LIST
24137: LIST
24138: PUSH
24139: LD_INT 2
24141: PUSH
24142: LD_INT 30
24144: PUSH
24145: LD_INT 36
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: PUSH
24152: LD_INT 34
24154: PUSH
24155: LD_INT 31
24157: PUSH
24158: EMPTY
24159: LIST
24160: LIST
24161: PUSH
24162: EMPTY
24163: LIST
24164: LIST
24165: LIST
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: PPUSH
24171: CALL_OW 69
24175: ST_TO_ADDR
// if not tmp then
24176: LD_VAR 0 6
24180: NOT
24181: IFFALSE 24185
// exit ;
24183: GO 24433
// result := [ ] ;
24185: LD_ADDR_VAR 0 2
24189: PUSH
24190: EMPTY
24191: ST_TO_ADDR
// for i in tmp do
24192: LD_ADDR_VAR 0 3
24196: PUSH
24197: LD_VAR 0 6
24201: PUSH
24202: FOR_IN
24203: IFFALSE 24274
// begin t := UnitsInside ( i ) ;
24205: LD_ADDR_VAR 0 4
24209: PUSH
24210: LD_VAR 0 3
24214: PPUSH
24215: CALL_OW 313
24219: ST_TO_ADDR
// if t then
24220: LD_VAR 0 4
24224: IFFALSE 24272
// for j in t do
24226: LD_ADDR_VAR 0 7
24230: PUSH
24231: LD_VAR 0 4
24235: PUSH
24236: FOR_IN
24237: IFFALSE 24270
// result := Insert ( result , result + 1 , j ) ;
24239: LD_ADDR_VAR 0 2
24243: PUSH
24244: LD_VAR 0 2
24248: PPUSH
24249: LD_VAR 0 2
24253: PUSH
24254: LD_INT 1
24256: PLUS
24257: PPUSH
24258: LD_VAR 0 7
24262: PPUSH
24263: CALL_OW 2
24267: ST_TO_ADDR
24268: GO 24236
24270: POP
24271: POP
// end ;
24272: GO 24202
24274: POP
24275: POP
// if not result then
24276: LD_VAR 0 2
24280: NOT
24281: IFFALSE 24285
// exit ;
24283: GO 24433
// mech := result [ 1 ] ;
24285: LD_ADDR_VAR 0 5
24289: PUSH
24290: LD_VAR 0 2
24294: PUSH
24295: LD_INT 1
24297: ARRAY
24298: ST_TO_ADDR
// if result > 1 then
24299: LD_VAR 0 2
24303: PUSH
24304: LD_INT 1
24306: GREATER
24307: IFFALSE 24419
// for i = 2 to result do
24309: LD_ADDR_VAR 0 3
24313: PUSH
24314: DOUBLE
24315: LD_INT 2
24317: DEC
24318: ST_TO_ADDR
24319: LD_VAR 0 2
24323: PUSH
24324: FOR_TO
24325: IFFALSE 24417
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24327: LD_ADDR_VAR 0 4
24331: PUSH
24332: LD_VAR 0 2
24336: PUSH
24337: LD_VAR 0 3
24341: ARRAY
24342: PPUSH
24343: LD_INT 3
24345: PPUSH
24346: CALL_OW 259
24350: PUSH
24351: LD_VAR 0 2
24355: PUSH
24356: LD_VAR 0 3
24360: ARRAY
24361: PPUSH
24362: CALL_OW 432
24366: MINUS
24367: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24368: LD_VAR 0 4
24372: PUSH
24373: LD_VAR 0 5
24377: PPUSH
24378: LD_INT 3
24380: PPUSH
24381: CALL_OW 259
24385: PUSH
24386: LD_VAR 0 5
24390: PPUSH
24391: CALL_OW 432
24395: MINUS
24396: GREATEREQUAL
24397: IFFALSE 24415
// mech := result [ i ] ;
24399: LD_ADDR_VAR 0 5
24403: PUSH
24404: LD_VAR 0 2
24408: PUSH
24409: LD_VAR 0 3
24413: ARRAY
24414: ST_TO_ADDR
// end ;
24415: GO 24324
24417: POP
24418: POP
// ComLinkTo ( vehicle , mech ) ;
24419: LD_VAR 0 1
24423: PPUSH
24424: LD_VAR 0 5
24428: PPUSH
24429: CALL_OW 135
// end ;
24433: LD_VAR 0 2
24437: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24438: LD_INT 0
24440: PPUSH
24441: PPUSH
24442: PPUSH
24443: PPUSH
24444: PPUSH
24445: PPUSH
24446: PPUSH
24447: PPUSH
24448: PPUSH
24449: PPUSH
24450: PPUSH
24451: PPUSH
24452: PPUSH
// result := [ ] ;
24453: LD_ADDR_VAR 0 7
24457: PUSH
24458: EMPTY
24459: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24460: LD_VAR 0 1
24464: PPUSH
24465: CALL_OW 266
24469: PUSH
24470: LD_INT 0
24472: PUSH
24473: LD_INT 1
24475: PUSH
24476: EMPTY
24477: LIST
24478: LIST
24479: IN
24480: NOT
24481: IFFALSE 24485
// exit ;
24483: GO 26116
// if name then
24485: LD_VAR 0 3
24489: IFFALSE 24505
// SetBName ( base_dep , name ) ;
24491: LD_VAR 0 1
24495: PPUSH
24496: LD_VAR 0 3
24500: PPUSH
24501: CALL_OW 500
// base := GetBase ( base_dep ) ;
24505: LD_ADDR_VAR 0 15
24509: PUSH
24510: LD_VAR 0 1
24514: PPUSH
24515: CALL_OW 274
24519: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24520: LD_ADDR_VAR 0 16
24524: PUSH
24525: LD_VAR 0 1
24529: PPUSH
24530: CALL_OW 255
24534: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24535: LD_ADDR_VAR 0 17
24539: PUSH
24540: LD_VAR 0 1
24544: PPUSH
24545: CALL_OW 248
24549: ST_TO_ADDR
// if sources then
24550: LD_VAR 0 5
24554: IFFALSE 24601
// for i = 1 to 3 do
24556: LD_ADDR_VAR 0 8
24560: PUSH
24561: DOUBLE
24562: LD_INT 1
24564: DEC
24565: ST_TO_ADDR
24566: LD_INT 3
24568: PUSH
24569: FOR_TO
24570: IFFALSE 24599
// AddResourceType ( base , i , sources [ i ] ) ;
24572: LD_VAR 0 15
24576: PPUSH
24577: LD_VAR 0 8
24581: PPUSH
24582: LD_VAR 0 5
24586: PUSH
24587: LD_VAR 0 8
24591: ARRAY
24592: PPUSH
24593: CALL_OW 276
24597: GO 24569
24599: POP
24600: POP
// buildings := GetBaseBuildings ( base , area ) ;
24601: LD_ADDR_VAR 0 18
24605: PUSH
24606: LD_VAR 0 15
24610: PPUSH
24611: LD_VAR 0 2
24615: PPUSH
24616: CALL 23893 0 2
24620: ST_TO_ADDR
// InitHc ;
24621: CALL_OW 19
// InitUc ;
24625: CALL_OW 18
// uc_side := side ;
24629: LD_ADDR_OWVAR 20
24633: PUSH
24634: LD_VAR 0 16
24638: ST_TO_ADDR
// uc_nation := nation ;
24639: LD_ADDR_OWVAR 21
24643: PUSH
24644: LD_VAR 0 17
24648: ST_TO_ADDR
// if buildings then
24649: LD_VAR 0 18
24653: IFFALSE 25975
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24655: LD_ADDR_VAR 0 19
24659: PUSH
24660: LD_VAR 0 18
24664: PPUSH
24665: LD_INT 2
24667: PUSH
24668: LD_INT 30
24670: PUSH
24671: LD_INT 29
24673: PUSH
24674: EMPTY
24675: LIST
24676: LIST
24677: PUSH
24678: LD_INT 30
24680: PUSH
24681: LD_INT 30
24683: PUSH
24684: EMPTY
24685: LIST
24686: LIST
24687: PUSH
24688: EMPTY
24689: LIST
24690: LIST
24691: LIST
24692: PPUSH
24693: CALL_OW 72
24697: ST_TO_ADDR
// if tmp then
24698: LD_VAR 0 19
24702: IFFALSE 24750
// for i in tmp do
24704: LD_ADDR_VAR 0 8
24708: PUSH
24709: LD_VAR 0 19
24713: PUSH
24714: FOR_IN
24715: IFFALSE 24748
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24717: LD_VAR 0 8
24721: PPUSH
24722: CALL_OW 250
24726: PPUSH
24727: LD_VAR 0 8
24731: PPUSH
24732: CALL_OW 251
24736: PPUSH
24737: LD_VAR 0 16
24741: PPUSH
24742: CALL_OW 441
24746: GO 24714
24748: POP
24749: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24750: LD_VAR 0 18
24754: PPUSH
24755: LD_INT 2
24757: PUSH
24758: LD_INT 30
24760: PUSH
24761: LD_INT 32
24763: PUSH
24764: EMPTY
24765: LIST
24766: LIST
24767: PUSH
24768: LD_INT 30
24770: PUSH
24771: LD_INT 33
24773: PUSH
24774: EMPTY
24775: LIST
24776: LIST
24777: PUSH
24778: EMPTY
24779: LIST
24780: LIST
24781: LIST
24782: PPUSH
24783: CALL_OW 72
24787: IFFALSE 24875
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24789: LD_ADDR_VAR 0 8
24793: PUSH
24794: LD_VAR 0 18
24798: PPUSH
24799: LD_INT 2
24801: PUSH
24802: LD_INT 30
24804: PUSH
24805: LD_INT 32
24807: PUSH
24808: EMPTY
24809: LIST
24810: LIST
24811: PUSH
24812: LD_INT 30
24814: PUSH
24815: LD_INT 33
24817: PUSH
24818: EMPTY
24819: LIST
24820: LIST
24821: PUSH
24822: EMPTY
24823: LIST
24824: LIST
24825: LIST
24826: PPUSH
24827: CALL_OW 72
24831: PUSH
24832: FOR_IN
24833: IFFALSE 24873
// begin if not GetBWeapon ( i ) then
24835: LD_VAR 0 8
24839: PPUSH
24840: CALL_OW 269
24844: NOT
24845: IFFALSE 24871
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24847: LD_VAR 0 8
24851: PPUSH
24852: LD_VAR 0 8
24856: PPUSH
24857: LD_VAR 0 2
24861: PPUSH
24862: CALL 26121 0 2
24866: PPUSH
24867: CALL_OW 431
// end ;
24871: GO 24832
24873: POP
24874: POP
// end ; for i = 1 to personel do
24875: LD_ADDR_VAR 0 8
24879: PUSH
24880: DOUBLE
24881: LD_INT 1
24883: DEC
24884: ST_TO_ADDR
24885: LD_VAR 0 6
24889: PUSH
24890: FOR_TO
24891: IFFALSE 25955
// begin if i > 4 then
24893: LD_VAR 0 8
24897: PUSH
24898: LD_INT 4
24900: GREATER
24901: IFFALSE 24905
// break ;
24903: GO 25955
// case i of 1 :
24905: LD_VAR 0 8
24909: PUSH
24910: LD_INT 1
24912: DOUBLE
24913: EQUAL
24914: IFTRUE 24918
24916: GO 24998
24918: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24919: LD_ADDR_VAR 0 12
24923: PUSH
24924: LD_VAR 0 18
24928: PPUSH
24929: LD_INT 22
24931: PUSH
24932: LD_VAR 0 16
24936: PUSH
24937: EMPTY
24938: LIST
24939: LIST
24940: PUSH
24941: LD_INT 58
24943: PUSH
24944: EMPTY
24945: LIST
24946: PUSH
24947: LD_INT 2
24949: PUSH
24950: LD_INT 30
24952: PUSH
24953: LD_INT 32
24955: PUSH
24956: EMPTY
24957: LIST
24958: LIST
24959: PUSH
24960: LD_INT 30
24962: PUSH
24963: LD_INT 4
24965: PUSH
24966: EMPTY
24967: LIST
24968: LIST
24969: PUSH
24970: LD_INT 30
24972: PUSH
24973: LD_INT 5
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: PUSH
24980: EMPTY
24981: LIST
24982: LIST
24983: LIST
24984: LIST
24985: PUSH
24986: EMPTY
24987: LIST
24988: LIST
24989: LIST
24990: PPUSH
24991: CALL_OW 72
24995: ST_TO_ADDR
24996: GO 25220
24998: LD_INT 2
25000: DOUBLE
25001: EQUAL
25002: IFTRUE 25006
25004: GO 25068
25006: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25007: LD_ADDR_VAR 0 12
25011: PUSH
25012: LD_VAR 0 18
25016: PPUSH
25017: LD_INT 22
25019: PUSH
25020: LD_VAR 0 16
25024: PUSH
25025: EMPTY
25026: LIST
25027: LIST
25028: PUSH
25029: LD_INT 2
25031: PUSH
25032: LD_INT 30
25034: PUSH
25035: LD_INT 0
25037: PUSH
25038: EMPTY
25039: LIST
25040: LIST
25041: PUSH
25042: LD_INT 30
25044: PUSH
25045: LD_INT 1
25047: PUSH
25048: EMPTY
25049: LIST
25050: LIST
25051: PUSH
25052: EMPTY
25053: LIST
25054: LIST
25055: LIST
25056: PUSH
25057: EMPTY
25058: LIST
25059: LIST
25060: PPUSH
25061: CALL_OW 72
25065: ST_TO_ADDR
25066: GO 25220
25068: LD_INT 3
25070: DOUBLE
25071: EQUAL
25072: IFTRUE 25076
25074: GO 25138
25076: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25077: LD_ADDR_VAR 0 12
25081: PUSH
25082: LD_VAR 0 18
25086: PPUSH
25087: LD_INT 22
25089: PUSH
25090: LD_VAR 0 16
25094: PUSH
25095: EMPTY
25096: LIST
25097: LIST
25098: PUSH
25099: LD_INT 2
25101: PUSH
25102: LD_INT 30
25104: PUSH
25105: LD_INT 2
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: PUSH
25112: LD_INT 30
25114: PUSH
25115: LD_INT 3
25117: PUSH
25118: EMPTY
25119: LIST
25120: LIST
25121: PUSH
25122: EMPTY
25123: LIST
25124: LIST
25125: LIST
25126: PUSH
25127: EMPTY
25128: LIST
25129: LIST
25130: PPUSH
25131: CALL_OW 72
25135: ST_TO_ADDR
25136: GO 25220
25138: LD_INT 4
25140: DOUBLE
25141: EQUAL
25142: IFTRUE 25146
25144: GO 25219
25146: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25147: LD_ADDR_VAR 0 12
25151: PUSH
25152: LD_VAR 0 18
25156: PPUSH
25157: LD_INT 22
25159: PUSH
25160: LD_VAR 0 16
25164: PUSH
25165: EMPTY
25166: LIST
25167: LIST
25168: PUSH
25169: LD_INT 2
25171: PUSH
25172: LD_INT 30
25174: PUSH
25175: LD_INT 6
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PUSH
25182: LD_INT 30
25184: PUSH
25185: LD_INT 7
25187: PUSH
25188: EMPTY
25189: LIST
25190: LIST
25191: PUSH
25192: LD_INT 30
25194: PUSH
25195: LD_INT 8
25197: PUSH
25198: EMPTY
25199: LIST
25200: LIST
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: LIST
25206: LIST
25207: PUSH
25208: EMPTY
25209: LIST
25210: LIST
25211: PPUSH
25212: CALL_OW 72
25216: ST_TO_ADDR
25217: GO 25220
25219: POP
// if i = 1 then
25220: LD_VAR 0 8
25224: PUSH
25225: LD_INT 1
25227: EQUAL
25228: IFFALSE 25339
// begin tmp := [ ] ;
25230: LD_ADDR_VAR 0 19
25234: PUSH
25235: EMPTY
25236: ST_TO_ADDR
// for j in f do
25237: LD_ADDR_VAR 0 9
25241: PUSH
25242: LD_VAR 0 12
25246: PUSH
25247: FOR_IN
25248: IFFALSE 25321
// if GetBType ( j ) = b_bunker then
25250: LD_VAR 0 9
25254: PPUSH
25255: CALL_OW 266
25259: PUSH
25260: LD_INT 32
25262: EQUAL
25263: IFFALSE 25290
// tmp := Insert ( tmp , 1 , j ) else
25265: LD_ADDR_VAR 0 19
25269: PUSH
25270: LD_VAR 0 19
25274: PPUSH
25275: LD_INT 1
25277: PPUSH
25278: LD_VAR 0 9
25282: PPUSH
25283: CALL_OW 2
25287: ST_TO_ADDR
25288: GO 25319
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25290: LD_ADDR_VAR 0 19
25294: PUSH
25295: LD_VAR 0 19
25299: PPUSH
25300: LD_VAR 0 19
25304: PUSH
25305: LD_INT 1
25307: PLUS
25308: PPUSH
25309: LD_VAR 0 9
25313: PPUSH
25314: CALL_OW 2
25318: ST_TO_ADDR
25319: GO 25247
25321: POP
25322: POP
// if tmp then
25323: LD_VAR 0 19
25327: IFFALSE 25339
// f := tmp ;
25329: LD_ADDR_VAR 0 12
25333: PUSH
25334: LD_VAR 0 19
25338: ST_TO_ADDR
// end ; x := personel [ i ] ;
25339: LD_ADDR_VAR 0 13
25343: PUSH
25344: LD_VAR 0 6
25348: PUSH
25349: LD_VAR 0 8
25353: ARRAY
25354: ST_TO_ADDR
// if x = - 1 then
25355: LD_VAR 0 13
25359: PUSH
25360: LD_INT 1
25362: NEG
25363: EQUAL
25364: IFFALSE 25573
// begin for j in f do
25366: LD_ADDR_VAR 0 9
25370: PUSH
25371: LD_VAR 0 12
25375: PUSH
25376: FOR_IN
25377: IFFALSE 25569
// repeat InitHc ;
25379: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25383: LD_VAR 0 9
25387: PPUSH
25388: CALL_OW 266
25392: PUSH
25393: LD_INT 5
25395: EQUAL
25396: IFFALSE 25466
// begin if UnitsInside ( j ) < 3 then
25398: LD_VAR 0 9
25402: PPUSH
25403: CALL_OW 313
25407: PUSH
25408: LD_INT 3
25410: LESS
25411: IFFALSE 25447
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25413: LD_INT 0
25415: PPUSH
25416: LD_INT 5
25418: PUSH
25419: LD_INT 8
25421: PUSH
25422: LD_INT 9
25424: PUSH
25425: EMPTY
25426: LIST
25427: LIST
25428: LIST
25429: PUSH
25430: LD_VAR 0 17
25434: ARRAY
25435: PPUSH
25436: LD_VAR 0 4
25440: PPUSH
25441: CALL_OW 380
25445: GO 25464
// PrepareHuman ( false , i , skill ) ;
25447: LD_INT 0
25449: PPUSH
25450: LD_VAR 0 8
25454: PPUSH
25455: LD_VAR 0 4
25459: PPUSH
25460: CALL_OW 380
// end else
25464: GO 25483
// PrepareHuman ( false , i , skill ) ;
25466: LD_INT 0
25468: PPUSH
25469: LD_VAR 0 8
25473: PPUSH
25474: LD_VAR 0 4
25478: PPUSH
25479: CALL_OW 380
// un := CreateHuman ;
25483: LD_ADDR_VAR 0 14
25487: PUSH
25488: CALL_OW 44
25492: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25493: LD_ADDR_VAR 0 7
25497: PUSH
25498: LD_VAR 0 7
25502: PPUSH
25503: LD_INT 1
25505: PPUSH
25506: LD_VAR 0 14
25510: PPUSH
25511: CALL_OW 2
25515: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25516: LD_VAR 0 14
25520: PPUSH
25521: LD_VAR 0 9
25525: PPUSH
25526: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25530: LD_VAR 0 9
25534: PPUSH
25535: CALL_OW 313
25539: PUSH
25540: LD_INT 6
25542: EQUAL
25543: PUSH
25544: LD_VAR 0 9
25548: PPUSH
25549: CALL_OW 266
25553: PUSH
25554: LD_INT 32
25556: PUSH
25557: LD_INT 31
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: IN
25564: OR
25565: IFFALSE 25379
25567: GO 25376
25569: POP
25570: POP
// end else
25571: GO 25953
// for j = 1 to x do
25573: LD_ADDR_VAR 0 9
25577: PUSH
25578: DOUBLE
25579: LD_INT 1
25581: DEC
25582: ST_TO_ADDR
25583: LD_VAR 0 13
25587: PUSH
25588: FOR_TO
25589: IFFALSE 25951
// begin InitHc ;
25591: CALL_OW 19
// if not f then
25595: LD_VAR 0 12
25599: NOT
25600: IFFALSE 25689
// begin PrepareHuman ( false , i , skill ) ;
25602: LD_INT 0
25604: PPUSH
25605: LD_VAR 0 8
25609: PPUSH
25610: LD_VAR 0 4
25614: PPUSH
25615: CALL_OW 380
// un := CreateHuman ;
25619: LD_ADDR_VAR 0 14
25623: PUSH
25624: CALL_OW 44
25628: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25629: LD_ADDR_VAR 0 7
25633: PUSH
25634: LD_VAR 0 7
25638: PPUSH
25639: LD_INT 1
25641: PPUSH
25642: LD_VAR 0 14
25646: PPUSH
25647: CALL_OW 2
25651: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25652: LD_VAR 0 14
25656: PPUSH
25657: LD_VAR 0 1
25661: PPUSH
25662: CALL_OW 250
25666: PPUSH
25667: LD_VAR 0 1
25671: PPUSH
25672: CALL_OW 251
25676: PPUSH
25677: LD_INT 10
25679: PPUSH
25680: LD_INT 0
25682: PPUSH
25683: CALL_OW 50
// continue ;
25687: GO 25588
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25689: LD_VAR 0 12
25693: PUSH
25694: LD_INT 1
25696: ARRAY
25697: PPUSH
25698: CALL_OW 313
25702: PUSH
25703: LD_VAR 0 12
25707: PUSH
25708: LD_INT 1
25710: ARRAY
25711: PPUSH
25712: CALL_OW 266
25716: PUSH
25717: LD_INT 32
25719: PUSH
25720: LD_INT 31
25722: PUSH
25723: EMPTY
25724: LIST
25725: LIST
25726: IN
25727: AND
25728: PUSH
25729: LD_VAR 0 12
25733: PUSH
25734: LD_INT 1
25736: ARRAY
25737: PPUSH
25738: CALL_OW 313
25742: PUSH
25743: LD_INT 6
25745: EQUAL
25746: OR
25747: IFFALSE 25767
// f := Delete ( f , 1 ) ;
25749: LD_ADDR_VAR 0 12
25753: PUSH
25754: LD_VAR 0 12
25758: PPUSH
25759: LD_INT 1
25761: PPUSH
25762: CALL_OW 3
25766: ST_TO_ADDR
// if not f then
25767: LD_VAR 0 12
25771: NOT
25772: IFFALSE 25790
// begin x := x + 2 ;
25774: LD_ADDR_VAR 0 13
25778: PUSH
25779: LD_VAR 0 13
25783: PUSH
25784: LD_INT 2
25786: PLUS
25787: ST_TO_ADDR
// continue ;
25788: GO 25588
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25790: LD_VAR 0 12
25794: PUSH
25795: LD_INT 1
25797: ARRAY
25798: PPUSH
25799: CALL_OW 266
25803: PUSH
25804: LD_INT 5
25806: EQUAL
25807: IFFALSE 25881
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25809: LD_VAR 0 12
25813: PUSH
25814: LD_INT 1
25816: ARRAY
25817: PPUSH
25818: CALL_OW 313
25822: PUSH
25823: LD_INT 3
25825: LESS
25826: IFFALSE 25862
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25828: LD_INT 0
25830: PPUSH
25831: LD_INT 5
25833: PUSH
25834: LD_INT 8
25836: PUSH
25837: LD_INT 9
25839: PUSH
25840: EMPTY
25841: LIST
25842: LIST
25843: LIST
25844: PUSH
25845: LD_VAR 0 17
25849: ARRAY
25850: PPUSH
25851: LD_VAR 0 4
25855: PPUSH
25856: CALL_OW 380
25860: GO 25879
// PrepareHuman ( false , i , skill ) ;
25862: LD_INT 0
25864: PPUSH
25865: LD_VAR 0 8
25869: PPUSH
25870: LD_VAR 0 4
25874: PPUSH
25875: CALL_OW 380
// end else
25879: GO 25898
// PrepareHuman ( false , i , skill ) ;
25881: LD_INT 0
25883: PPUSH
25884: LD_VAR 0 8
25888: PPUSH
25889: LD_VAR 0 4
25893: PPUSH
25894: CALL_OW 380
// un := CreateHuman ;
25898: LD_ADDR_VAR 0 14
25902: PUSH
25903: CALL_OW 44
25907: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25908: LD_ADDR_VAR 0 7
25912: PUSH
25913: LD_VAR 0 7
25917: PPUSH
25918: LD_INT 1
25920: PPUSH
25921: LD_VAR 0 14
25925: PPUSH
25926: CALL_OW 2
25930: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25931: LD_VAR 0 14
25935: PPUSH
25936: LD_VAR 0 12
25940: PUSH
25941: LD_INT 1
25943: ARRAY
25944: PPUSH
25945: CALL_OW 52
// end ;
25949: GO 25588
25951: POP
25952: POP
// end ;
25953: GO 24890
25955: POP
25956: POP
// result := result ^ buildings ;
25957: LD_ADDR_VAR 0 7
25961: PUSH
25962: LD_VAR 0 7
25966: PUSH
25967: LD_VAR 0 18
25971: ADD
25972: ST_TO_ADDR
// end else
25973: GO 26116
// begin for i = 1 to personel do
25975: LD_ADDR_VAR 0 8
25979: PUSH
25980: DOUBLE
25981: LD_INT 1
25983: DEC
25984: ST_TO_ADDR
25985: LD_VAR 0 6
25989: PUSH
25990: FOR_TO
25991: IFFALSE 26114
// begin if i > 4 then
25993: LD_VAR 0 8
25997: PUSH
25998: LD_INT 4
26000: GREATER
26001: IFFALSE 26005
// break ;
26003: GO 26114
// x := personel [ i ] ;
26005: LD_ADDR_VAR 0 13
26009: PUSH
26010: LD_VAR 0 6
26014: PUSH
26015: LD_VAR 0 8
26019: ARRAY
26020: ST_TO_ADDR
// if x = - 1 then
26021: LD_VAR 0 13
26025: PUSH
26026: LD_INT 1
26028: NEG
26029: EQUAL
26030: IFFALSE 26034
// continue ;
26032: GO 25990
// PrepareHuman ( false , i , skill ) ;
26034: LD_INT 0
26036: PPUSH
26037: LD_VAR 0 8
26041: PPUSH
26042: LD_VAR 0 4
26046: PPUSH
26047: CALL_OW 380
// un := CreateHuman ;
26051: LD_ADDR_VAR 0 14
26055: PUSH
26056: CALL_OW 44
26060: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26061: LD_VAR 0 14
26065: PPUSH
26066: LD_VAR 0 1
26070: PPUSH
26071: CALL_OW 250
26075: PPUSH
26076: LD_VAR 0 1
26080: PPUSH
26081: CALL_OW 251
26085: PPUSH
26086: LD_INT 10
26088: PPUSH
26089: LD_INT 0
26091: PPUSH
26092: CALL_OW 50
// result := result ^ un ;
26096: LD_ADDR_VAR 0 7
26100: PUSH
26101: LD_VAR 0 7
26105: PUSH
26106: LD_VAR 0 14
26110: ADD
26111: ST_TO_ADDR
// end ;
26112: GO 25990
26114: POP
26115: POP
// end ; end ;
26116: LD_VAR 0 7
26120: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26121: LD_INT 0
26123: PPUSH
26124: PPUSH
26125: PPUSH
26126: PPUSH
26127: PPUSH
26128: PPUSH
26129: PPUSH
26130: PPUSH
26131: PPUSH
26132: PPUSH
26133: PPUSH
26134: PPUSH
26135: PPUSH
26136: PPUSH
26137: PPUSH
26138: PPUSH
// result := false ;
26139: LD_ADDR_VAR 0 3
26143: PUSH
26144: LD_INT 0
26146: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26147: LD_VAR 0 1
26151: NOT
26152: PUSH
26153: LD_VAR 0 1
26157: PPUSH
26158: CALL_OW 266
26162: PUSH
26163: LD_INT 32
26165: PUSH
26166: LD_INT 33
26168: PUSH
26169: EMPTY
26170: LIST
26171: LIST
26172: IN
26173: NOT
26174: OR
26175: IFFALSE 26179
// exit ;
26177: GO 27315
// nat := GetNation ( tower ) ;
26179: LD_ADDR_VAR 0 12
26183: PUSH
26184: LD_VAR 0 1
26188: PPUSH
26189: CALL_OW 248
26193: ST_TO_ADDR
// side := GetSide ( tower ) ;
26194: LD_ADDR_VAR 0 16
26198: PUSH
26199: LD_VAR 0 1
26203: PPUSH
26204: CALL_OW 255
26208: ST_TO_ADDR
// x := GetX ( tower ) ;
26209: LD_ADDR_VAR 0 10
26213: PUSH
26214: LD_VAR 0 1
26218: PPUSH
26219: CALL_OW 250
26223: ST_TO_ADDR
// y := GetY ( tower ) ;
26224: LD_ADDR_VAR 0 11
26228: PUSH
26229: LD_VAR 0 1
26233: PPUSH
26234: CALL_OW 251
26238: ST_TO_ADDR
// if not x or not y then
26239: LD_VAR 0 10
26243: NOT
26244: PUSH
26245: LD_VAR 0 11
26249: NOT
26250: OR
26251: IFFALSE 26255
// exit ;
26253: GO 27315
// weapon := 0 ;
26255: LD_ADDR_VAR 0 18
26259: PUSH
26260: LD_INT 0
26262: ST_TO_ADDR
// fac_list := [ ] ;
26263: LD_ADDR_VAR 0 17
26267: PUSH
26268: EMPTY
26269: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
26270: LD_ADDR_VAR 0 6
26274: PUSH
26275: LD_VAR 0 1
26279: PPUSH
26280: CALL_OW 274
26284: PPUSH
26285: LD_VAR 0 2
26289: PPUSH
26290: CALL 23893 0 2
26294: PPUSH
26295: LD_INT 30
26297: PUSH
26298: LD_INT 3
26300: PUSH
26301: EMPTY
26302: LIST
26303: LIST
26304: PPUSH
26305: CALL_OW 72
26309: ST_TO_ADDR
// if not factories then
26310: LD_VAR 0 6
26314: NOT
26315: IFFALSE 26319
// exit ;
26317: GO 27315
// for i in factories do
26319: LD_ADDR_VAR 0 8
26323: PUSH
26324: LD_VAR 0 6
26328: PUSH
26329: FOR_IN
26330: IFFALSE 26355
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26332: LD_ADDR_VAR 0 17
26336: PUSH
26337: LD_VAR 0 17
26341: PUSH
26342: LD_VAR 0 8
26346: PPUSH
26347: CALL_OW 478
26351: UNION
26352: ST_TO_ADDR
26353: GO 26329
26355: POP
26356: POP
// if not fac_list then
26357: LD_VAR 0 17
26361: NOT
26362: IFFALSE 26366
// exit ;
26364: GO 27315
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26366: LD_ADDR_VAR 0 5
26370: PUSH
26371: LD_INT 4
26373: PUSH
26374: LD_INT 5
26376: PUSH
26377: LD_INT 9
26379: PUSH
26380: LD_INT 10
26382: PUSH
26383: LD_INT 6
26385: PUSH
26386: LD_INT 7
26388: PUSH
26389: LD_INT 11
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: LIST
26396: LIST
26397: LIST
26398: LIST
26399: LIST
26400: PUSH
26401: LD_INT 27
26403: PUSH
26404: LD_INT 28
26406: PUSH
26407: LD_INT 26
26409: PUSH
26410: LD_INT 30
26412: PUSH
26413: EMPTY
26414: LIST
26415: LIST
26416: LIST
26417: LIST
26418: PUSH
26419: LD_INT 43
26421: PUSH
26422: LD_INT 44
26424: PUSH
26425: LD_INT 46
26427: PUSH
26428: LD_INT 45
26430: PUSH
26431: LD_INT 47
26433: PUSH
26434: LD_INT 49
26436: PUSH
26437: EMPTY
26438: LIST
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: LIST
26449: PUSH
26450: LD_VAR 0 12
26454: ARRAY
26455: ST_TO_ADDR
// for i in list do
26456: LD_ADDR_VAR 0 8
26460: PUSH
26461: LD_VAR 0 5
26465: PUSH
26466: FOR_IN
26467: IFFALSE 26500
// if not i in fac_list then
26469: LD_VAR 0 8
26473: PUSH
26474: LD_VAR 0 17
26478: IN
26479: NOT
26480: IFFALSE 26498
// list := list diff i ;
26482: LD_ADDR_VAR 0 5
26486: PUSH
26487: LD_VAR 0 5
26491: PUSH
26492: LD_VAR 0 8
26496: DIFF
26497: ST_TO_ADDR
26498: GO 26466
26500: POP
26501: POP
// if not list then
26502: LD_VAR 0 5
26506: NOT
26507: IFFALSE 26511
// exit ;
26509: GO 27315
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26511: LD_VAR 0 12
26515: PUSH
26516: LD_INT 3
26518: EQUAL
26519: PUSH
26520: LD_INT 49
26522: PUSH
26523: LD_VAR 0 5
26527: IN
26528: AND
26529: PUSH
26530: LD_INT 31
26532: PPUSH
26533: LD_VAR 0 16
26537: PPUSH
26538: CALL_OW 321
26542: PUSH
26543: LD_INT 2
26545: EQUAL
26546: AND
26547: IFFALSE 26607
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26549: LD_INT 22
26551: PUSH
26552: LD_VAR 0 16
26556: PUSH
26557: EMPTY
26558: LIST
26559: LIST
26560: PUSH
26561: LD_INT 35
26563: PUSH
26564: LD_INT 49
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: LD_INT 91
26573: PUSH
26574: LD_VAR 0 1
26578: PUSH
26579: LD_INT 10
26581: PUSH
26582: EMPTY
26583: LIST
26584: LIST
26585: LIST
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: LIST
26591: PPUSH
26592: CALL_OW 69
26596: NOT
26597: IFFALSE 26607
// weapon := ru_time_lapser ;
26599: LD_ADDR_VAR 0 18
26603: PUSH
26604: LD_INT 49
26606: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26607: LD_VAR 0 12
26611: PUSH
26612: LD_INT 1
26614: PUSH
26615: LD_INT 2
26617: PUSH
26618: EMPTY
26619: LIST
26620: LIST
26621: IN
26622: PUSH
26623: LD_INT 11
26625: PUSH
26626: LD_VAR 0 5
26630: IN
26631: PUSH
26632: LD_INT 30
26634: PUSH
26635: LD_VAR 0 5
26639: IN
26640: OR
26641: AND
26642: PUSH
26643: LD_INT 6
26645: PPUSH
26646: LD_VAR 0 16
26650: PPUSH
26651: CALL_OW 321
26655: PUSH
26656: LD_INT 2
26658: EQUAL
26659: AND
26660: IFFALSE 26825
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26662: LD_INT 22
26664: PUSH
26665: LD_VAR 0 16
26669: PUSH
26670: EMPTY
26671: LIST
26672: LIST
26673: PUSH
26674: LD_INT 2
26676: PUSH
26677: LD_INT 35
26679: PUSH
26680: LD_INT 11
26682: PUSH
26683: EMPTY
26684: LIST
26685: LIST
26686: PUSH
26687: LD_INT 35
26689: PUSH
26690: LD_INT 30
26692: PUSH
26693: EMPTY
26694: LIST
26695: LIST
26696: PUSH
26697: EMPTY
26698: LIST
26699: LIST
26700: LIST
26701: PUSH
26702: LD_INT 91
26704: PUSH
26705: LD_VAR 0 1
26709: PUSH
26710: LD_INT 18
26712: PUSH
26713: EMPTY
26714: LIST
26715: LIST
26716: LIST
26717: PUSH
26718: EMPTY
26719: LIST
26720: LIST
26721: LIST
26722: PPUSH
26723: CALL_OW 69
26727: NOT
26728: PUSH
26729: LD_INT 22
26731: PUSH
26732: LD_VAR 0 16
26736: PUSH
26737: EMPTY
26738: LIST
26739: LIST
26740: PUSH
26741: LD_INT 2
26743: PUSH
26744: LD_INT 30
26746: PUSH
26747: LD_INT 32
26749: PUSH
26750: EMPTY
26751: LIST
26752: LIST
26753: PUSH
26754: LD_INT 30
26756: PUSH
26757: LD_INT 33
26759: PUSH
26760: EMPTY
26761: LIST
26762: LIST
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: LIST
26768: PUSH
26769: LD_INT 91
26771: PUSH
26772: LD_VAR 0 1
26776: PUSH
26777: LD_INT 12
26779: PUSH
26780: EMPTY
26781: LIST
26782: LIST
26783: LIST
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: LIST
26789: PUSH
26790: EMPTY
26791: LIST
26792: PPUSH
26793: CALL_OW 69
26797: PUSH
26798: LD_INT 2
26800: GREATER
26801: AND
26802: IFFALSE 26825
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26804: LD_ADDR_VAR 0 18
26808: PUSH
26809: LD_INT 11
26811: PUSH
26812: LD_INT 30
26814: PUSH
26815: EMPTY
26816: LIST
26817: LIST
26818: PUSH
26819: LD_VAR 0 12
26823: ARRAY
26824: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26825: LD_VAR 0 18
26829: NOT
26830: PUSH
26831: LD_INT 40
26833: PPUSH
26834: LD_VAR 0 16
26838: PPUSH
26839: CALL_OW 321
26843: PUSH
26844: LD_INT 2
26846: EQUAL
26847: AND
26848: PUSH
26849: LD_INT 7
26851: PUSH
26852: LD_VAR 0 5
26856: IN
26857: PUSH
26858: LD_INT 28
26860: PUSH
26861: LD_VAR 0 5
26865: IN
26866: OR
26867: PUSH
26868: LD_INT 45
26870: PUSH
26871: LD_VAR 0 5
26875: IN
26876: OR
26877: AND
26878: IFFALSE 27132
// begin hex := GetHexInfo ( x , y ) ;
26880: LD_ADDR_VAR 0 4
26884: PUSH
26885: LD_VAR 0 10
26889: PPUSH
26890: LD_VAR 0 11
26894: PPUSH
26895: CALL_OW 546
26899: ST_TO_ADDR
// if hex [ 1 ] then
26900: LD_VAR 0 4
26904: PUSH
26905: LD_INT 1
26907: ARRAY
26908: IFFALSE 26912
// exit ;
26910: GO 27315
// height := hex [ 2 ] ;
26912: LD_ADDR_VAR 0 15
26916: PUSH
26917: LD_VAR 0 4
26921: PUSH
26922: LD_INT 2
26924: ARRAY
26925: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26926: LD_ADDR_VAR 0 14
26930: PUSH
26931: LD_INT 0
26933: PUSH
26934: LD_INT 2
26936: PUSH
26937: LD_INT 3
26939: PUSH
26940: LD_INT 5
26942: PUSH
26943: EMPTY
26944: LIST
26945: LIST
26946: LIST
26947: LIST
26948: ST_TO_ADDR
// for i in tmp do
26949: LD_ADDR_VAR 0 8
26953: PUSH
26954: LD_VAR 0 14
26958: PUSH
26959: FOR_IN
26960: IFFALSE 27130
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26962: LD_ADDR_VAR 0 9
26966: PUSH
26967: LD_VAR 0 10
26971: PPUSH
26972: LD_VAR 0 8
26976: PPUSH
26977: LD_INT 5
26979: PPUSH
26980: CALL_OW 272
26984: PUSH
26985: LD_VAR 0 11
26989: PPUSH
26990: LD_VAR 0 8
26994: PPUSH
26995: LD_INT 5
26997: PPUSH
26998: CALL_OW 273
27002: PUSH
27003: EMPTY
27004: LIST
27005: LIST
27006: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27007: LD_VAR 0 9
27011: PUSH
27012: LD_INT 1
27014: ARRAY
27015: PPUSH
27016: LD_VAR 0 9
27020: PUSH
27021: LD_INT 2
27023: ARRAY
27024: PPUSH
27025: CALL_OW 488
27029: IFFALSE 27128
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27031: LD_ADDR_VAR 0 4
27035: PUSH
27036: LD_VAR 0 9
27040: PUSH
27041: LD_INT 1
27043: ARRAY
27044: PPUSH
27045: LD_VAR 0 9
27049: PUSH
27050: LD_INT 2
27052: ARRAY
27053: PPUSH
27054: CALL_OW 546
27058: ST_TO_ADDR
// if hex [ 1 ] then
27059: LD_VAR 0 4
27063: PUSH
27064: LD_INT 1
27066: ARRAY
27067: IFFALSE 27071
// continue ;
27069: GO 26959
// h := hex [ 2 ] ;
27071: LD_ADDR_VAR 0 13
27075: PUSH
27076: LD_VAR 0 4
27080: PUSH
27081: LD_INT 2
27083: ARRAY
27084: ST_TO_ADDR
// if h + 7 < height then
27085: LD_VAR 0 13
27089: PUSH
27090: LD_INT 7
27092: PLUS
27093: PUSH
27094: LD_VAR 0 15
27098: LESS
27099: IFFALSE 27128
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27101: LD_ADDR_VAR 0 18
27105: PUSH
27106: LD_INT 7
27108: PUSH
27109: LD_INT 28
27111: PUSH
27112: LD_INT 45
27114: PUSH
27115: EMPTY
27116: LIST
27117: LIST
27118: LIST
27119: PUSH
27120: LD_VAR 0 12
27124: ARRAY
27125: ST_TO_ADDR
// break ;
27126: GO 27130
// end ; end ; end ;
27128: GO 26959
27130: POP
27131: POP
// end ; if not weapon then
27132: LD_VAR 0 18
27136: NOT
27137: IFFALSE 27197
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27139: LD_ADDR_VAR 0 5
27143: PUSH
27144: LD_VAR 0 5
27148: PUSH
27149: LD_INT 11
27151: PUSH
27152: LD_INT 30
27154: PUSH
27155: LD_INT 49
27157: PUSH
27158: EMPTY
27159: LIST
27160: LIST
27161: LIST
27162: DIFF
27163: ST_TO_ADDR
// if not list then
27164: LD_VAR 0 5
27168: NOT
27169: IFFALSE 27173
// exit ;
27171: GO 27315
// weapon := list [ rand ( 1 , list ) ] ;
27173: LD_ADDR_VAR 0 18
27177: PUSH
27178: LD_VAR 0 5
27182: PUSH
27183: LD_INT 1
27185: PPUSH
27186: LD_VAR 0 5
27190: PPUSH
27191: CALL_OW 12
27195: ARRAY
27196: ST_TO_ADDR
// end ; if weapon then
27197: LD_VAR 0 18
27201: IFFALSE 27315
// begin tmp := CostOfWeapon ( weapon ) ;
27203: LD_ADDR_VAR 0 14
27207: PUSH
27208: LD_VAR 0 18
27212: PPUSH
27213: CALL_OW 451
27217: ST_TO_ADDR
// j := GetBase ( tower ) ;
27218: LD_ADDR_VAR 0 9
27222: PUSH
27223: LD_VAR 0 1
27227: PPUSH
27228: CALL_OW 274
27232: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27233: LD_VAR 0 9
27237: PPUSH
27238: LD_INT 1
27240: PPUSH
27241: CALL_OW 275
27245: PUSH
27246: LD_VAR 0 14
27250: PUSH
27251: LD_INT 1
27253: ARRAY
27254: GREATEREQUAL
27255: PUSH
27256: LD_VAR 0 9
27260: PPUSH
27261: LD_INT 2
27263: PPUSH
27264: CALL_OW 275
27268: PUSH
27269: LD_VAR 0 14
27273: PUSH
27274: LD_INT 2
27276: ARRAY
27277: GREATEREQUAL
27278: AND
27279: PUSH
27280: LD_VAR 0 9
27284: PPUSH
27285: LD_INT 3
27287: PPUSH
27288: CALL_OW 275
27292: PUSH
27293: LD_VAR 0 14
27297: PUSH
27298: LD_INT 3
27300: ARRAY
27301: GREATEREQUAL
27302: AND
27303: IFFALSE 27315
// result := weapon ;
27305: LD_ADDR_VAR 0 3
27309: PUSH
27310: LD_VAR 0 18
27314: ST_TO_ADDR
// end ; end ;
27315: LD_VAR 0 3
27319: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27320: LD_INT 0
27322: PPUSH
27323: PPUSH
// result := true ;
27324: LD_ADDR_VAR 0 3
27328: PUSH
27329: LD_INT 1
27331: ST_TO_ADDR
// if array1 = array2 then
27332: LD_VAR 0 1
27336: PUSH
27337: LD_VAR 0 2
27341: EQUAL
27342: IFFALSE 27402
// begin for i = 1 to array1 do
27344: LD_ADDR_VAR 0 4
27348: PUSH
27349: DOUBLE
27350: LD_INT 1
27352: DEC
27353: ST_TO_ADDR
27354: LD_VAR 0 1
27358: PUSH
27359: FOR_TO
27360: IFFALSE 27398
// if array1 [ i ] <> array2 [ i ] then
27362: LD_VAR 0 1
27366: PUSH
27367: LD_VAR 0 4
27371: ARRAY
27372: PUSH
27373: LD_VAR 0 2
27377: PUSH
27378: LD_VAR 0 4
27382: ARRAY
27383: NONEQUAL
27384: IFFALSE 27396
// begin result := false ;
27386: LD_ADDR_VAR 0 3
27390: PUSH
27391: LD_INT 0
27393: ST_TO_ADDR
// break ;
27394: GO 27398
// end ;
27396: GO 27359
27398: POP
27399: POP
// end else
27400: GO 27410
// result := false ;
27402: LD_ADDR_VAR 0 3
27406: PUSH
27407: LD_INT 0
27409: ST_TO_ADDR
// end ;
27410: LD_VAR 0 3
27414: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27415: LD_INT 0
27417: PPUSH
27418: PPUSH
27419: PPUSH
// pom := GetBase ( fac ) ;
27420: LD_ADDR_VAR 0 5
27424: PUSH
27425: LD_VAR 0 1
27429: PPUSH
27430: CALL_OW 274
27434: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27435: LD_ADDR_VAR 0 4
27439: PUSH
27440: LD_VAR 0 2
27444: PUSH
27445: LD_INT 1
27447: ARRAY
27448: PPUSH
27449: LD_VAR 0 2
27453: PUSH
27454: LD_INT 2
27456: ARRAY
27457: PPUSH
27458: LD_VAR 0 2
27462: PUSH
27463: LD_INT 3
27465: ARRAY
27466: PPUSH
27467: LD_VAR 0 2
27471: PUSH
27472: LD_INT 4
27474: ARRAY
27475: PPUSH
27476: CALL_OW 449
27480: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27481: LD_ADDR_VAR 0 3
27485: PUSH
27486: LD_VAR 0 5
27490: PPUSH
27491: LD_INT 1
27493: PPUSH
27494: CALL_OW 275
27498: PUSH
27499: LD_VAR 0 4
27503: PUSH
27504: LD_INT 1
27506: ARRAY
27507: GREATEREQUAL
27508: PUSH
27509: LD_VAR 0 5
27513: PPUSH
27514: LD_INT 2
27516: PPUSH
27517: CALL_OW 275
27521: PUSH
27522: LD_VAR 0 4
27526: PUSH
27527: LD_INT 2
27529: ARRAY
27530: GREATEREQUAL
27531: AND
27532: PUSH
27533: LD_VAR 0 5
27537: PPUSH
27538: LD_INT 3
27540: PPUSH
27541: CALL_OW 275
27545: PUSH
27546: LD_VAR 0 4
27550: PUSH
27551: LD_INT 3
27553: ARRAY
27554: GREATEREQUAL
27555: AND
27556: ST_TO_ADDR
// end ;
27557: LD_VAR 0 3
27561: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27562: LD_INT 0
27564: PPUSH
27565: PPUSH
27566: PPUSH
27567: PPUSH
// pom := GetBase ( building ) ;
27568: LD_ADDR_VAR 0 3
27572: PUSH
27573: LD_VAR 0 1
27577: PPUSH
27578: CALL_OW 274
27582: ST_TO_ADDR
// if not pom then
27583: LD_VAR 0 3
27587: NOT
27588: IFFALSE 27592
// exit ;
27590: GO 27762
// btype := GetBType ( building ) ;
27592: LD_ADDR_VAR 0 5
27596: PUSH
27597: LD_VAR 0 1
27601: PPUSH
27602: CALL_OW 266
27606: ST_TO_ADDR
// if btype = b_armoury then
27607: LD_VAR 0 5
27611: PUSH
27612: LD_INT 4
27614: EQUAL
27615: IFFALSE 27625
// btype := b_barracks ;
27617: LD_ADDR_VAR 0 5
27621: PUSH
27622: LD_INT 5
27624: ST_TO_ADDR
// if btype = b_depot then
27625: LD_VAR 0 5
27629: PUSH
27630: LD_INT 0
27632: EQUAL
27633: IFFALSE 27643
// btype := b_warehouse ;
27635: LD_ADDR_VAR 0 5
27639: PUSH
27640: LD_INT 1
27642: ST_TO_ADDR
// if btype = b_workshop then
27643: LD_VAR 0 5
27647: PUSH
27648: LD_INT 2
27650: EQUAL
27651: IFFALSE 27661
// btype := b_factory ;
27653: LD_ADDR_VAR 0 5
27657: PUSH
27658: LD_INT 3
27660: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27661: LD_ADDR_VAR 0 4
27665: PUSH
27666: LD_VAR 0 5
27670: PPUSH
27671: LD_VAR 0 1
27675: PPUSH
27676: CALL_OW 248
27680: PPUSH
27681: CALL_OW 450
27685: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27686: LD_ADDR_VAR 0 2
27690: PUSH
27691: LD_VAR 0 3
27695: PPUSH
27696: LD_INT 1
27698: PPUSH
27699: CALL_OW 275
27703: PUSH
27704: LD_VAR 0 4
27708: PUSH
27709: LD_INT 1
27711: ARRAY
27712: GREATEREQUAL
27713: PUSH
27714: LD_VAR 0 3
27718: PPUSH
27719: LD_INT 2
27721: PPUSH
27722: CALL_OW 275
27726: PUSH
27727: LD_VAR 0 4
27731: PUSH
27732: LD_INT 2
27734: ARRAY
27735: GREATEREQUAL
27736: AND
27737: PUSH
27738: LD_VAR 0 3
27742: PPUSH
27743: LD_INT 3
27745: PPUSH
27746: CALL_OW 275
27750: PUSH
27751: LD_VAR 0 4
27755: PUSH
27756: LD_INT 3
27758: ARRAY
27759: GREATEREQUAL
27760: AND
27761: ST_TO_ADDR
// end ;
27762: LD_VAR 0 2
27766: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27767: LD_INT 0
27769: PPUSH
27770: PPUSH
27771: PPUSH
// pom := GetBase ( building ) ;
27772: LD_ADDR_VAR 0 4
27776: PUSH
27777: LD_VAR 0 1
27781: PPUSH
27782: CALL_OW 274
27786: ST_TO_ADDR
// if not pom then
27787: LD_VAR 0 4
27791: NOT
27792: IFFALSE 27796
// exit ;
27794: GO 27897
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27796: LD_ADDR_VAR 0 5
27800: PUSH
27801: LD_VAR 0 2
27805: PPUSH
27806: LD_VAR 0 1
27810: PPUSH
27811: CALL_OW 248
27815: PPUSH
27816: CALL_OW 450
27820: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27821: LD_ADDR_VAR 0 3
27825: PUSH
27826: LD_VAR 0 4
27830: PPUSH
27831: LD_INT 1
27833: PPUSH
27834: CALL_OW 275
27838: PUSH
27839: LD_VAR 0 5
27843: PUSH
27844: LD_INT 1
27846: ARRAY
27847: GREATEREQUAL
27848: PUSH
27849: LD_VAR 0 4
27853: PPUSH
27854: LD_INT 2
27856: PPUSH
27857: CALL_OW 275
27861: PUSH
27862: LD_VAR 0 5
27866: PUSH
27867: LD_INT 2
27869: ARRAY
27870: GREATEREQUAL
27871: AND
27872: PUSH
27873: LD_VAR 0 4
27877: PPUSH
27878: LD_INT 3
27880: PPUSH
27881: CALL_OW 275
27885: PUSH
27886: LD_VAR 0 5
27890: PUSH
27891: LD_INT 3
27893: ARRAY
27894: GREATEREQUAL
27895: AND
27896: ST_TO_ADDR
// end ;
27897: LD_VAR 0 3
27901: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27902: LD_INT 0
27904: PPUSH
27905: PPUSH
27906: PPUSH
27907: PPUSH
27908: PPUSH
27909: PPUSH
27910: PPUSH
27911: PPUSH
27912: PPUSH
27913: PPUSH
// result := false ;
27914: LD_ADDR_VAR 0 6
27918: PUSH
27919: LD_INT 0
27921: ST_TO_ADDR
// if not base or not btype or not x or not y then
27922: LD_VAR 0 1
27926: NOT
27927: PUSH
27928: LD_VAR 0 2
27932: NOT
27933: OR
27934: PUSH
27935: LD_VAR 0 3
27939: NOT
27940: OR
27941: PUSH
27942: LD_VAR 0 4
27946: NOT
27947: OR
27948: IFFALSE 27952
// exit ;
27950: GO 28561
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27952: LD_ADDR_VAR 0 12
27956: PUSH
27957: LD_VAR 0 2
27961: PPUSH
27962: LD_VAR 0 3
27966: PPUSH
27967: LD_VAR 0 4
27971: PPUSH
27972: LD_VAR 0 5
27976: PPUSH
27977: LD_VAR 0 1
27981: PUSH
27982: LD_INT 1
27984: ARRAY
27985: PPUSH
27986: CALL_OW 248
27990: PPUSH
27991: LD_INT 0
27993: PPUSH
27994: CALL 29398 0 6
27998: ST_TO_ADDR
// if not hexes then
27999: LD_VAR 0 12
28003: NOT
28004: IFFALSE 28008
// exit ;
28006: GO 28561
// for i = 1 to hexes do
28008: LD_ADDR_VAR 0 7
28012: PUSH
28013: DOUBLE
28014: LD_INT 1
28016: DEC
28017: ST_TO_ADDR
28018: LD_VAR 0 12
28022: PUSH
28023: FOR_TO
28024: IFFALSE 28559
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28026: LD_ADDR_VAR 0 11
28030: PUSH
28031: LD_VAR 0 12
28035: PUSH
28036: LD_VAR 0 7
28040: ARRAY
28041: PUSH
28042: LD_INT 1
28044: ARRAY
28045: PPUSH
28046: LD_VAR 0 12
28050: PUSH
28051: LD_VAR 0 7
28055: ARRAY
28056: PUSH
28057: LD_INT 2
28059: ARRAY
28060: PPUSH
28061: CALL_OW 428
28065: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28066: LD_VAR 0 12
28070: PUSH
28071: LD_VAR 0 7
28075: ARRAY
28076: PUSH
28077: LD_INT 1
28079: ARRAY
28080: PPUSH
28081: LD_VAR 0 12
28085: PUSH
28086: LD_VAR 0 7
28090: ARRAY
28091: PUSH
28092: LD_INT 2
28094: ARRAY
28095: PPUSH
28096: CALL_OW 351
28100: PUSH
28101: LD_VAR 0 12
28105: PUSH
28106: LD_VAR 0 7
28110: ARRAY
28111: PUSH
28112: LD_INT 1
28114: ARRAY
28115: PPUSH
28116: LD_VAR 0 12
28120: PUSH
28121: LD_VAR 0 7
28125: ARRAY
28126: PUSH
28127: LD_INT 2
28129: ARRAY
28130: PPUSH
28131: CALL_OW 488
28135: NOT
28136: OR
28137: PUSH
28138: LD_VAR 0 11
28142: PPUSH
28143: CALL_OW 247
28147: PUSH
28148: LD_INT 3
28150: EQUAL
28151: OR
28152: IFFALSE 28158
// exit ;
28154: POP
28155: POP
28156: GO 28561
// if not tmp or not tmp in base then
28158: LD_VAR 0 11
28162: NOT
28163: PUSH
28164: LD_VAR 0 11
28168: PUSH
28169: LD_VAR 0 1
28173: IN
28174: NOT
28175: OR
28176: IFFALSE 28180
// continue ;
28178: GO 28023
// result := true ;
28180: LD_ADDR_VAR 0 6
28184: PUSH
28185: LD_INT 1
28187: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28188: LD_ADDR_VAR 0 15
28192: PUSH
28193: LD_VAR 0 1
28197: PPUSH
28198: LD_INT 22
28200: PUSH
28201: LD_VAR 0 11
28205: PPUSH
28206: CALL_OW 255
28210: PUSH
28211: EMPTY
28212: LIST
28213: LIST
28214: PUSH
28215: LD_INT 2
28217: PUSH
28218: LD_INT 30
28220: PUSH
28221: LD_INT 0
28223: PUSH
28224: EMPTY
28225: LIST
28226: LIST
28227: PUSH
28228: LD_INT 30
28230: PUSH
28231: LD_INT 1
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: LIST
28242: PUSH
28243: EMPTY
28244: LIST
28245: LIST
28246: PPUSH
28247: CALL_OW 72
28251: ST_TO_ADDR
// if dep then
28252: LD_VAR 0 15
28256: IFFALSE 28392
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28258: LD_ADDR_VAR 0 14
28262: PUSH
28263: LD_VAR 0 15
28267: PUSH
28268: LD_INT 1
28270: ARRAY
28271: PPUSH
28272: CALL_OW 250
28276: PPUSH
28277: LD_VAR 0 15
28281: PUSH
28282: LD_INT 1
28284: ARRAY
28285: PPUSH
28286: CALL_OW 254
28290: PPUSH
28291: LD_INT 5
28293: PPUSH
28294: CALL_OW 272
28298: PUSH
28299: LD_VAR 0 15
28303: PUSH
28304: LD_INT 1
28306: ARRAY
28307: PPUSH
28308: CALL_OW 251
28312: PPUSH
28313: LD_VAR 0 15
28317: PUSH
28318: LD_INT 1
28320: ARRAY
28321: PPUSH
28322: CALL_OW 254
28326: PPUSH
28327: LD_INT 5
28329: PPUSH
28330: CALL_OW 273
28334: PUSH
28335: EMPTY
28336: LIST
28337: LIST
28338: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28339: LD_VAR 0 14
28343: PUSH
28344: LD_INT 1
28346: ARRAY
28347: PPUSH
28348: LD_VAR 0 14
28352: PUSH
28353: LD_INT 2
28355: ARRAY
28356: PPUSH
28357: CALL_OW 488
28361: IFFALSE 28392
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28363: LD_VAR 0 11
28367: PPUSH
28368: LD_VAR 0 14
28372: PUSH
28373: LD_INT 1
28375: ARRAY
28376: PPUSH
28377: LD_VAR 0 14
28381: PUSH
28382: LD_INT 2
28384: ARRAY
28385: PPUSH
28386: CALL_OW 111
// continue ;
28390: GO 28023
// end ; end ; r := GetDir ( tmp ) ;
28392: LD_ADDR_VAR 0 13
28396: PUSH
28397: LD_VAR 0 11
28401: PPUSH
28402: CALL_OW 254
28406: ST_TO_ADDR
// if r = 5 then
28407: LD_VAR 0 13
28411: PUSH
28412: LD_INT 5
28414: EQUAL
28415: IFFALSE 28425
// r := 0 ;
28417: LD_ADDR_VAR 0 13
28421: PUSH
28422: LD_INT 0
28424: ST_TO_ADDR
// for j = r to 5 do
28425: LD_ADDR_VAR 0 8
28429: PUSH
28430: DOUBLE
28431: LD_VAR 0 13
28435: DEC
28436: ST_TO_ADDR
28437: LD_INT 5
28439: PUSH
28440: FOR_TO
28441: IFFALSE 28555
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28443: LD_ADDR_VAR 0 9
28447: PUSH
28448: LD_VAR 0 11
28452: PPUSH
28453: CALL_OW 250
28457: PPUSH
28458: LD_VAR 0 8
28462: PPUSH
28463: LD_INT 2
28465: PPUSH
28466: CALL_OW 272
28470: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28471: LD_ADDR_VAR 0 10
28475: PUSH
28476: LD_VAR 0 11
28480: PPUSH
28481: CALL_OW 251
28485: PPUSH
28486: LD_VAR 0 8
28490: PPUSH
28491: LD_INT 2
28493: PPUSH
28494: CALL_OW 273
28498: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28499: LD_VAR 0 9
28503: PPUSH
28504: LD_VAR 0 10
28508: PPUSH
28509: CALL_OW 488
28513: PUSH
28514: LD_VAR 0 9
28518: PPUSH
28519: LD_VAR 0 10
28523: PPUSH
28524: CALL_OW 428
28528: NOT
28529: AND
28530: IFFALSE 28553
// begin ComMoveXY ( tmp , _x , _y ) ;
28532: LD_VAR 0 11
28536: PPUSH
28537: LD_VAR 0 9
28541: PPUSH
28542: LD_VAR 0 10
28546: PPUSH
28547: CALL_OW 111
// break ;
28551: GO 28555
// end ; end ;
28553: GO 28440
28555: POP
28556: POP
// end ;
28557: GO 28023
28559: POP
28560: POP
// end ;
28561: LD_VAR 0 6
28565: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28566: LD_INT 0
28568: PPUSH
28569: PPUSH
28570: PPUSH
28571: PPUSH
28572: PPUSH
28573: PPUSH
28574: PPUSH
28575: PPUSH
28576: PPUSH
28577: PPUSH
// result := false ;
28578: LD_ADDR_VAR 0 6
28582: PUSH
28583: LD_INT 0
28585: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28586: LD_VAR 0 1
28590: NOT
28591: PUSH
28592: LD_VAR 0 1
28596: PPUSH
28597: CALL_OW 266
28601: PUSH
28602: LD_INT 0
28604: PUSH
28605: LD_INT 1
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: IN
28612: NOT
28613: OR
28614: PUSH
28615: LD_VAR 0 2
28619: NOT
28620: OR
28621: PUSH
28622: LD_VAR 0 5
28626: PUSH
28627: LD_INT 0
28629: PUSH
28630: LD_INT 1
28632: PUSH
28633: LD_INT 2
28635: PUSH
28636: LD_INT 3
28638: PUSH
28639: LD_INT 4
28641: PUSH
28642: LD_INT 5
28644: PUSH
28645: EMPTY
28646: LIST
28647: LIST
28648: LIST
28649: LIST
28650: LIST
28651: LIST
28652: IN
28653: NOT
28654: OR
28655: PUSH
28656: LD_VAR 0 3
28660: PPUSH
28661: LD_VAR 0 4
28665: PPUSH
28666: CALL_OW 488
28670: NOT
28671: OR
28672: IFFALSE 28676
// exit ;
28674: GO 29393
// pom := GetBase ( depot ) ;
28676: LD_ADDR_VAR 0 10
28680: PUSH
28681: LD_VAR 0 1
28685: PPUSH
28686: CALL_OW 274
28690: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28691: LD_ADDR_VAR 0 11
28695: PUSH
28696: LD_VAR 0 2
28700: PPUSH
28701: LD_VAR 0 1
28705: PPUSH
28706: CALL_OW 248
28710: PPUSH
28711: CALL_OW 450
28715: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28716: LD_VAR 0 10
28720: PPUSH
28721: LD_INT 1
28723: PPUSH
28724: CALL_OW 275
28728: PUSH
28729: LD_VAR 0 11
28733: PUSH
28734: LD_INT 1
28736: ARRAY
28737: GREATEREQUAL
28738: PUSH
28739: LD_VAR 0 10
28743: PPUSH
28744: LD_INT 2
28746: PPUSH
28747: CALL_OW 275
28751: PUSH
28752: LD_VAR 0 11
28756: PUSH
28757: LD_INT 2
28759: ARRAY
28760: GREATEREQUAL
28761: AND
28762: PUSH
28763: LD_VAR 0 10
28767: PPUSH
28768: LD_INT 3
28770: PPUSH
28771: CALL_OW 275
28775: PUSH
28776: LD_VAR 0 11
28780: PUSH
28781: LD_INT 3
28783: ARRAY
28784: GREATEREQUAL
28785: AND
28786: NOT
28787: IFFALSE 28791
// exit ;
28789: GO 29393
// if GetBType ( depot ) = b_depot then
28791: LD_VAR 0 1
28795: PPUSH
28796: CALL_OW 266
28800: PUSH
28801: LD_INT 0
28803: EQUAL
28804: IFFALSE 28816
// dist := 28 else
28806: LD_ADDR_VAR 0 14
28810: PUSH
28811: LD_INT 28
28813: ST_TO_ADDR
28814: GO 28824
// dist := 36 ;
28816: LD_ADDR_VAR 0 14
28820: PUSH
28821: LD_INT 36
28823: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28824: LD_VAR 0 1
28828: PPUSH
28829: LD_VAR 0 3
28833: PPUSH
28834: LD_VAR 0 4
28838: PPUSH
28839: CALL_OW 297
28843: PUSH
28844: LD_VAR 0 14
28848: GREATER
28849: IFFALSE 28853
// exit ;
28851: GO 29393
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28853: LD_ADDR_VAR 0 12
28857: PUSH
28858: LD_VAR 0 2
28862: PPUSH
28863: LD_VAR 0 3
28867: PPUSH
28868: LD_VAR 0 4
28872: PPUSH
28873: LD_VAR 0 5
28877: PPUSH
28878: LD_VAR 0 1
28882: PPUSH
28883: CALL_OW 248
28887: PPUSH
28888: LD_INT 0
28890: PPUSH
28891: CALL 29398 0 6
28895: ST_TO_ADDR
// if not hexes then
28896: LD_VAR 0 12
28900: NOT
28901: IFFALSE 28905
// exit ;
28903: GO 29393
// hex := GetHexInfo ( x , y ) ;
28905: LD_ADDR_VAR 0 15
28909: PUSH
28910: LD_VAR 0 3
28914: PPUSH
28915: LD_VAR 0 4
28919: PPUSH
28920: CALL_OW 546
28924: ST_TO_ADDR
// if hex [ 1 ] then
28925: LD_VAR 0 15
28929: PUSH
28930: LD_INT 1
28932: ARRAY
28933: IFFALSE 28937
// exit ;
28935: GO 29393
// height := hex [ 2 ] ;
28937: LD_ADDR_VAR 0 13
28941: PUSH
28942: LD_VAR 0 15
28946: PUSH
28947: LD_INT 2
28949: ARRAY
28950: ST_TO_ADDR
// for i = 1 to hexes do
28951: LD_ADDR_VAR 0 7
28955: PUSH
28956: DOUBLE
28957: LD_INT 1
28959: DEC
28960: ST_TO_ADDR
28961: LD_VAR 0 12
28965: PUSH
28966: FOR_TO
28967: IFFALSE 29297
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28969: LD_VAR 0 12
28973: PUSH
28974: LD_VAR 0 7
28978: ARRAY
28979: PUSH
28980: LD_INT 1
28982: ARRAY
28983: PPUSH
28984: LD_VAR 0 12
28988: PUSH
28989: LD_VAR 0 7
28993: ARRAY
28994: PUSH
28995: LD_INT 2
28997: ARRAY
28998: PPUSH
28999: CALL_OW 488
29003: NOT
29004: PUSH
29005: LD_VAR 0 12
29009: PUSH
29010: LD_VAR 0 7
29014: ARRAY
29015: PUSH
29016: LD_INT 1
29018: ARRAY
29019: PPUSH
29020: LD_VAR 0 12
29024: PUSH
29025: LD_VAR 0 7
29029: ARRAY
29030: PUSH
29031: LD_INT 2
29033: ARRAY
29034: PPUSH
29035: CALL_OW 428
29039: PUSH
29040: LD_INT 0
29042: GREATER
29043: OR
29044: PUSH
29045: LD_VAR 0 12
29049: PUSH
29050: LD_VAR 0 7
29054: ARRAY
29055: PUSH
29056: LD_INT 1
29058: ARRAY
29059: PPUSH
29060: LD_VAR 0 12
29064: PUSH
29065: LD_VAR 0 7
29069: ARRAY
29070: PUSH
29071: LD_INT 2
29073: ARRAY
29074: PPUSH
29075: CALL_OW 351
29079: OR
29080: IFFALSE 29086
// exit ;
29082: POP
29083: POP
29084: GO 29393
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29086: LD_ADDR_VAR 0 8
29090: PUSH
29091: LD_VAR 0 12
29095: PUSH
29096: LD_VAR 0 7
29100: ARRAY
29101: PUSH
29102: LD_INT 1
29104: ARRAY
29105: PPUSH
29106: LD_VAR 0 12
29110: PUSH
29111: LD_VAR 0 7
29115: ARRAY
29116: PUSH
29117: LD_INT 2
29119: ARRAY
29120: PPUSH
29121: CALL_OW 546
29125: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29126: LD_VAR 0 8
29130: PUSH
29131: LD_INT 1
29133: ARRAY
29134: PUSH
29135: LD_VAR 0 8
29139: PUSH
29140: LD_INT 2
29142: ARRAY
29143: PUSH
29144: LD_VAR 0 13
29148: PUSH
29149: LD_INT 2
29151: PLUS
29152: GREATER
29153: OR
29154: PUSH
29155: LD_VAR 0 8
29159: PUSH
29160: LD_INT 2
29162: ARRAY
29163: PUSH
29164: LD_VAR 0 13
29168: PUSH
29169: LD_INT 2
29171: MINUS
29172: LESS
29173: OR
29174: PUSH
29175: LD_VAR 0 8
29179: PUSH
29180: LD_INT 3
29182: ARRAY
29183: PUSH
29184: LD_INT 0
29186: PUSH
29187: LD_INT 8
29189: PUSH
29190: LD_INT 9
29192: PUSH
29193: LD_INT 10
29195: PUSH
29196: LD_INT 11
29198: PUSH
29199: LD_INT 12
29201: PUSH
29202: LD_INT 13
29204: PUSH
29205: LD_INT 16
29207: PUSH
29208: LD_INT 17
29210: PUSH
29211: LD_INT 18
29213: PUSH
29214: LD_INT 19
29216: PUSH
29217: LD_INT 20
29219: PUSH
29220: LD_INT 21
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: LIST
29227: LIST
29228: LIST
29229: LIST
29230: LIST
29231: LIST
29232: LIST
29233: LIST
29234: LIST
29235: LIST
29236: LIST
29237: IN
29238: NOT
29239: OR
29240: PUSH
29241: LD_VAR 0 8
29245: PUSH
29246: LD_INT 5
29248: ARRAY
29249: NOT
29250: OR
29251: PUSH
29252: LD_VAR 0 8
29256: PUSH
29257: LD_INT 6
29259: ARRAY
29260: PUSH
29261: LD_INT 1
29263: PUSH
29264: LD_INT 2
29266: PUSH
29267: LD_INT 7
29269: PUSH
29270: LD_INT 9
29272: PUSH
29273: LD_INT 10
29275: PUSH
29276: LD_INT 11
29278: PUSH
29279: EMPTY
29280: LIST
29281: LIST
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: IN
29287: NOT
29288: OR
29289: IFFALSE 29295
// exit ;
29291: POP
29292: POP
29293: GO 29393
// end ;
29295: GO 28966
29297: POP
29298: POP
// side := GetSide ( depot ) ;
29299: LD_ADDR_VAR 0 9
29303: PUSH
29304: LD_VAR 0 1
29308: PPUSH
29309: CALL_OW 255
29313: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29314: LD_VAR 0 9
29318: PPUSH
29319: LD_VAR 0 3
29323: PPUSH
29324: LD_VAR 0 4
29328: PPUSH
29329: LD_INT 20
29331: PPUSH
29332: CALL 22047 0 4
29336: PUSH
29337: LD_INT 4
29339: ARRAY
29340: IFFALSE 29344
// exit ;
29342: GO 29393
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29344: LD_VAR 0 2
29348: PUSH
29349: LD_INT 29
29351: PUSH
29352: LD_INT 30
29354: PUSH
29355: EMPTY
29356: LIST
29357: LIST
29358: IN
29359: PUSH
29360: LD_VAR 0 3
29364: PPUSH
29365: LD_VAR 0 4
29369: PPUSH
29370: LD_VAR 0 9
29374: PPUSH
29375: CALL_OW 440
29379: NOT
29380: AND
29381: IFFALSE 29385
// exit ;
29383: GO 29393
// result := true ;
29385: LD_ADDR_VAR 0 6
29389: PUSH
29390: LD_INT 1
29392: ST_TO_ADDR
// end ;
29393: LD_VAR 0 6
29397: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29398: LD_INT 0
29400: PPUSH
29401: PPUSH
29402: PPUSH
29403: PPUSH
29404: PPUSH
29405: PPUSH
29406: PPUSH
29407: PPUSH
29408: PPUSH
29409: PPUSH
29410: PPUSH
29411: PPUSH
29412: PPUSH
29413: PPUSH
29414: PPUSH
29415: PPUSH
29416: PPUSH
29417: PPUSH
29418: PPUSH
29419: PPUSH
29420: PPUSH
29421: PPUSH
29422: PPUSH
29423: PPUSH
29424: PPUSH
29425: PPUSH
29426: PPUSH
29427: PPUSH
29428: PPUSH
29429: PPUSH
29430: PPUSH
29431: PPUSH
29432: PPUSH
29433: PPUSH
29434: PPUSH
29435: PPUSH
29436: PPUSH
29437: PPUSH
29438: PPUSH
29439: PPUSH
29440: PPUSH
29441: PPUSH
29442: PPUSH
29443: PPUSH
29444: PPUSH
29445: PPUSH
29446: PPUSH
29447: PPUSH
29448: PPUSH
29449: PPUSH
29450: PPUSH
29451: PPUSH
29452: PPUSH
29453: PPUSH
29454: PPUSH
29455: PPUSH
29456: PPUSH
29457: PPUSH
// result = [ ] ;
29458: LD_ADDR_VAR 0 7
29462: PUSH
29463: EMPTY
29464: ST_TO_ADDR
// temp_list = [ ] ;
29465: LD_ADDR_VAR 0 9
29469: PUSH
29470: EMPTY
29471: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29472: LD_VAR 0 4
29476: PUSH
29477: LD_INT 0
29479: PUSH
29480: LD_INT 1
29482: PUSH
29483: LD_INT 2
29485: PUSH
29486: LD_INT 3
29488: PUSH
29489: LD_INT 4
29491: PUSH
29492: LD_INT 5
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: IN
29503: NOT
29504: PUSH
29505: LD_VAR 0 1
29509: PUSH
29510: LD_INT 0
29512: PUSH
29513: LD_INT 1
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: IN
29520: PUSH
29521: LD_VAR 0 5
29525: PUSH
29526: LD_INT 1
29528: PUSH
29529: LD_INT 2
29531: PUSH
29532: LD_INT 3
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: LIST
29539: IN
29540: NOT
29541: AND
29542: OR
29543: IFFALSE 29547
// exit ;
29545: GO 47938
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29547: LD_VAR 0 1
29551: PUSH
29552: LD_INT 6
29554: PUSH
29555: LD_INT 7
29557: PUSH
29558: LD_INT 8
29560: PUSH
29561: LD_INT 13
29563: PUSH
29564: LD_INT 12
29566: PUSH
29567: LD_INT 15
29569: PUSH
29570: LD_INT 11
29572: PUSH
29573: LD_INT 14
29575: PUSH
29576: LD_INT 10
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: LIST
29583: LIST
29584: LIST
29585: LIST
29586: LIST
29587: LIST
29588: LIST
29589: IN
29590: IFFALSE 29600
// btype = b_lab ;
29592: LD_ADDR_VAR 0 1
29596: PUSH
29597: LD_INT 6
29599: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29600: LD_VAR 0 6
29604: PUSH
29605: LD_INT 0
29607: PUSH
29608: LD_INT 1
29610: PUSH
29611: LD_INT 2
29613: PUSH
29614: EMPTY
29615: LIST
29616: LIST
29617: LIST
29618: IN
29619: NOT
29620: PUSH
29621: LD_VAR 0 1
29625: PUSH
29626: LD_INT 0
29628: PUSH
29629: LD_INT 1
29631: PUSH
29632: LD_INT 2
29634: PUSH
29635: LD_INT 3
29637: PUSH
29638: LD_INT 6
29640: PUSH
29641: LD_INT 36
29643: PUSH
29644: LD_INT 4
29646: PUSH
29647: LD_INT 5
29649: PUSH
29650: LD_INT 31
29652: PUSH
29653: LD_INT 32
29655: PUSH
29656: LD_INT 33
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: LIST
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: IN
29672: NOT
29673: PUSH
29674: LD_VAR 0 6
29678: PUSH
29679: LD_INT 1
29681: EQUAL
29682: AND
29683: OR
29684: PUSH
29685: LD_VAR 0 1
29689: PUSH
29690: LD_INT 2
29692: PUSH
29693: LD_INT 3
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: IN
29700: NOT
29701: PUSH
29702: LD_VAR 0 6
29706: PUSH
29707: LD_INT 2
29709: EQUAL
29710: AND
29711: OR
29712: IFFALSE 29722
// mode = 0 ;
29714: LD_ADDR_VAR 0 6
29718: PUSH
29719: LD_INT 0
29721: ST_TO_ADDR
// case mode of 0 :
29722: LD_VAR 0 6
29726: PUSH
29727: LD_INT 0
29729: DOUBLE
29730: EQUAL
29731: IFTRUE 29735
29733: GO 41188
29735: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29736: LD_ADDR_VAR 0 11
29740: PUSH
29741: LD_INT 0
29743: PUSH
29744: LD_INT 0
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: PUSH
29751: LD_INT 0
29753: PUSH
29754: LD_INT 1
29756: NEG
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 1
29764: PUSH
29765: LD_INT 0
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: LD_INT 1
29774: PUSH
29775: LD_INT 1
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 0
29784: PUSH
29785: LD_INT 1
29787: PUSH
29788: EMPTY
29789: LIST
29790: LIST
29791: PUSH
29792: LD_INT 1
29794: NEG
29795: PUSH
29796: LD_INT 0
29798: PUSH
29799: EMPTY
29800: LIST
29801: LIST
29802: PUSH
29803: LD_INT 1
29805: NEG
29806: PUSH
29807: LD_INT 1
29809: NEG
29810: PUSH
29811: EMPTY
29812: LIST
29813: LIST
29814: PUSH
29815: LD_INT 1
29817: NEG
29818: PUSH
29819: LD_INT 2
29821: NEG
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: PUSH
29827: LD_INT 0
29829: PUSH
29830: LD_INT 2
29832: NEG
29833: PUSH
29834: EMPTY
29835: LIST
29836: LIST
29837: PUSH
29838: LD_INT 1
29840: PUSH
29841: LD_INT 1
29843: NEG
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: LD_INT 1
29851: PUSH
29852: LD_INT 2
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: LD_INT 0
29861: PUSH
29862: LD_INT 2
29864: PUSH
29865: EMPTY
29866: LIST
29867: LIST
29868: PUSH
29869: LD_INT 1
29871: NEG
29872: PUSH
29873: LD_INT 1
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 1
29882: PUSH
29883: LD_INT 3
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: PUSH
29890: LD_INT 0
29892: PUSH
29893: LD_INT 3
29895: PUSH
29896: EMPTY
29897: LIST
29898: LIST
29899: PUSH
29900: LD_INT 1
29902: NEG
29903: PUSH
29904: LD_INT 2
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: LIST
29915: LIST
29916: LIST
29917: LIST
29918: LIST
29919: LIST
29920: LIST
29921: LIST
29922: LIST
29923: LIST
29924: LIST
29925: LIST
29926: LIST
29927: LIST
29928: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29929: LD_ADDR_VAR 0 12
29933: PUSH
29934: LD_INT 0
29936: PUSH
29937: LD_INT 0
29939: PUSH
29940: EMPTY
29941: LIST
29942: LIST
29943: PUSH
29944: LD_INT 0
29946: PUSH
29947: LD_INT 1
29949: NEG
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 1
29957: PUSH
29958: LD_INT 0
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: LD_INT 1
29967: PUSH
29968: LD_INT 1
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: LD_INT 0
29977: PUSH
29978: LD_INT 1
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PUSH
29985: LD_INT 1
29987: NEG
29988: PUSH
29989: LD_INT 0
29991: PUSH
29992: EMPTY
29993: LIST
29994: LIST
29995: PUSH
29996: LD_INT 1
29998: NEG
29999: PUSH
30000: LD_INT 1
30002: NEG
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 1
30010: PUSH
30011: LD_INT 1
30013: NEG
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: LD_INT 2
30021: PUSH
30022: LD_INT 0
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 2
30031: PUSH
30032: LD_INT 1
30034: PUSH
30035: EMPTY
30036: LIST
30037: LIST
30038: PUSH
30039: LD_INT 1
30041: NEG
30042: PUSH
30043: LD_INT 1
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: LD_INT 2
30052: NEG
30053: PUSH
30054: LD_INT 0
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: PUSH
30061: LD_INT 2
30063: NEG
30064: PUSH
30065: LD_INT 1
30067: NEG
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 2
30075: NEG
30076: PUSH
30077: LD_INT 1
30079: PUSH
30080: EMPTY
30081: LIST
30082: LIST
30083: PUSH
30084: LD_INT 3
30086: NEG
30087: PUSH
30088: LD_INT 0
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 3
30097: NEG
30098: PUSH
30099: LD_INT 1
30101: NEG
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: EMPTY
30108: LIST
30109: LIST
30110: LIST
30111: LIST
30112: LIST
30113: LIST
30114: LIST
30115: LIST
30116: LIST
30117: LIST
30118: LIST
30119: LIST
30120: LIST
30121: LIST
30122: LIST
30123: LIST
30124: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30125: LD_ADDR_VAR 0 13
30129: PUSH
30130: LD_INT 0
30132: PUSH
30133: LD_INT 0
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: LD_INT 0
30142: PUSH
30143: LD_INT 1
30145: NEG
30146: PUSH
30147: EMPTY
30148: LIST
30149: LIST
30150: PUSH
30151: LD_INT 1
30153: PUSH
30154: LD_INT 0
30156: PUSH
30157: EMPTY
30158: LIST
30159: LIST
30160: PUSH
30161: LD_INT 1
30163: PUSH
30164: LD_INT 1
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: PUSH
30171: LD_INT 0
30173: PUSH
30174: LD_INT 1
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 1
30183: NEG
30184: PUSH
30185: LD_INT 0
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: PUSH
30192: LD_INT 1
30194: NEG
30195: PUSH
30196: LD_INT 1
30198: NEG
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 1
30206: NEG
30207: PUSH
30208: LD_INT 2
30210: NEG
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 2
30218: PUSH
30219: LD_INT 1
30221: PUSH
30222: EMPTY
30223: LIST
30224: LIST
30225: PUSH
30226: LD_INT 2
30228: PUSH
30229: LD_INT 2
30231: PUSH
30232: EMPTY
30233: LIST
30234: LIST
30235: PUSH
30236: LD_INT 1
30238: PUSH
30239: LD_INT 2
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: LD_INT 2
30248: NEG
30249: PUSH
30250: LD_INT 1
30252: NEG
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 2
30260: NEG
30261: PUSH
30262: LD_INT 2
30264: NEG
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 2
30272: NEG
30273: PUSH
30274: LD_INT 3
30276: NEG
30277: PUSH
30278: EMPTY
30279: LIST
30280: LIST
30281: PUSH
30282: LD_INT 3
30284: NEG
30285: PUSH
30286: LD_INT 2
30288: NEG
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 3
30296: NEG
30297: PUSH
30298: LD_INT 3
30300: NEG
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: LIST
30310: LIST
30311: LIST
30312: LIST
30313: LIST
30314: LIST
30315: LIST
30316: LIST
30317: LIST
30318: LIST
30319: LIST
30320: LIST
30321: LIST
30322: LIST
30323: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30324: LD_ADDR_VAR 0 14
30328: PUSH
30329: LD_INT 0
30331: PUSH
30332: LD_INT 0
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PUSH
30339: LD_INT 0
30341: PUSH
30342: LD_INT 1
30344: NEG
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 1
30352: PUSH
30353: LD_INT 0
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 1
30362: PUSH
30363: LD_INT 1
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 0
30372: PUSH
30373: LD_INT 1
30375: PUSH
30376: EMPTY
30377: LIST
30378: LIST
30379: PUSH
30380: LD_INT 1
30382: NEG
30383: PUSH
30384: LD_INT 0
30386: PUSH
30387: EMPTY
30388: LIST
30389: LIST
30390: PUSH
30391: LD_INT 1
30393: NEG
30394: PUSH
30395: LD_INT 1
30397: NEG
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: LD_INT 1
30405: NEG
30406: PUSH
30407: LD_INT 2
30409: NEG
30410: PUSH
30411: EMPTY
30412: LIST
30413: LIST
30414: PUSH
30415: LD_INT 0
30417: PUSH
30418: LD_INT 2
30420: NEG
30421: PUSH
30422: EMPTY
30423: LIST
30424: LIST
30425: PUSH
30426: LD_INT 1
30428: PUSH
30429: LD_INT 1
30431: NEG
30432: PUSH
30433: EMPTY
30434: LIST
30435: LIST
30436: PUSH
30437: LD_INT 1
30439: PUSH
30440: LD_INT 2
30442: PUSH
30443: EMPTY
30444: LIST
30445: LIST
30446: PUSH
30447: LD_INT 0
30449: PUSH
30450: LD_INT 2
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: LD_INT 1
30459: NEG
30460: PUSH
30461: LD_INT 1
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: LD_INT 3
30474: NEG
30475: PUSH
30476: EMPTY
30477: LIST
30478: LIST
30479: PUSH
30480: LD_INT 0
30482: PUSH
30483: LD_INT 3
30485: NEG
30486: PUSH
30487: EMPTY
30488: LIST
30489: LIST
30490: PUSH
30491: LD_INT 1
30493: PUSH
30494: LD_INT 2
30496: NEG
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: LIST
30506: LIST
30507: LIST
30508: LIST
30509: LIST
30510: LIST
30511: LIST
30512: LIST
30513: LIST
30514: LIST
30515: LIST
30516: LIST
30517: LIST
30518: LIST
30519: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30520: LD_ADDR_VAR 0 15
30524: PUSH
30525: LD_INT 0
30527: PUSH
30528: LD_INT 0
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 0
30537: PUSH
30538: LD_INT 1
30540: NEG
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: LD_INT 1
30548: PUSH
30549: LD_INT 0
30551: PUSH
30552: EMPTY
30553: LIST
30554: LIST
30555: PUSH
30556: LD_INT 1
30558: PUSH
30559: LD_INT 1
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PUSH
30566: LD_INT 0
30568: PUSH
30569: LD_INT 1
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: PUSH
30576: LD_INT 1
30578: NEG
30579: PUSH
30580: LD_INT 0
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: PUSH
30587: LD_INT 1
30589: NEG
30590: PUSH
30591: LD_INT 1
30593: NEG
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 1
30601: PUSH
30602: LD_INT 1
30604: NEG
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: LD_INT 2
30612: PUSH
30613: LD_INT 0
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PUSH
30620: LD_INT 2
30622: PUSH
30623: LD_INT 1
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: LD_INT 1
30632: NEG
30633: PUSH
30634: LD_INT 1
30636: PUSH
30637: EMPTY
30638: LIST
30639: LIST
30640: PUSH
30641: LD_INT 2
30643: NEG
30644: PUSH
30645: LD_INT 0
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 2
30654: NEG
30655: PUSH
30656: LD_INT 1
30658: NEG
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 2
30666: PUSH
30667: LD_INT 1
30669: NEG
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: LD_INT 3
30677: PUSH
30678: LD_INT 0
30680: PUSH
30681: EMPTY
30682: LIST
30683: LIST
30684: PUSH
30685: LD_INT 3
30687: PUSH
30688: LD_INT 1
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: LIST
30699: LIST
30700: LIST
30701: LIST
30702: LIST
30703: LIST
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: LIST
30711: LIST
30712: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30713: LD_ADDR_VAR 0 16
30717: PUSH
30718: LD_INT 0
30720: PUSH
30721: LD_INT 0
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: LD_INT 0
30730: PUSH
30731: LD_INT 1
30733: NEG
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: PUSH
30739: LD_INT 1
30741: PUSH
30742: LD_INT 0
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: PUSH
30749: LD_INT 1
30751: PUSH
30752: LD_INT 1
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: PUSH
30759: LD_INT 0
30761: PUSH
30762: LD_INT 1
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 1
30771: NEG
30772: PUSH
30773: LD_INT 0
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 1
30782: NEG
30783: PUSH
30784: LD_INT 1
30786: NEG
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 1
30794: NEG
30795: PUSH
30796: LD_INT 2
30798: NEG
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 2
30806: PUSH
30807: LD_INT 1
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 2
30816: PUSH
30817: LD_INT 2
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 1
30826: PUSH
30827: LD_INT 2
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: LD_INT 2
30836: NEG
30837: PUSH
30838: LD_INT 1
30840: NEG
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: PUSH
30846: LD_INT 2
30848: NEG
30849: PUSH
30850: LD_INT 2
30852: NEG
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: LD_INT 3
30860: PUSH
30861: LD_INT 2
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 3
30870: PUSH
30871: LD_INT 3
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PUSH
30878: LD_INT 2
30880: PUSH
30881: LD_INT 3
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: LIST
30892: LIST
30893: LIST
30894: LIST
30895: LIST
30896: LIST
30897: LIST
30898: LIST
30899: LIST
30900: LIST
30901: LIST
30902: LIST
30903: LIST
30904: LIST
30905: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30906: LD_ADDR_VAR 0 17
30910: PUSH
30911: LD_INT 0
30913: PUSH
30914: LD_INT 0
30916: PUSH
30917: EMPTY
30918: LIST
30919: LIST
30920: PUSH
30921: LD_INT 0
30923: PUSH
30924: LD_INT 1
30926: NEG
30927: PUSH
30928: EMPTY
30929: LIST
30930: LIST
30931: PUSH
30932: LD_INT 1
30934: PUSH
30935: LD_INT 0
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 1
30944: PUSH
30945: LD_INT 1
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 0
30954: PUSH
30955: LD_INT 1
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: LD_INT 1
30964: NEG
30965: PUSH
30966: LD_INT 0
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: PUSH
30973: LD_INT 1
30975: NEG
30976: PUSH
30977: LD_INT 1
30979: NEG
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 1
30987: NEG
30988: PUSH
30989: LD_INT 2
30991: NEG
30992: PUSH
30993: EMPTY
30994: LIST
30995: LIST
30996: PUSH
30997: LD_INT 0
30999: PUSH
31000: LD_INT 2
31002: NEG
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: LD_INT 1
31010: PUSH
31011: LD_INT 1
31013: NEG
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: PUSH
31019: LD_INT 2
31021: PUSH
31022: LD_INT 0
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PUSH
31029: LD_INT 2
31031: PUSH
31032: LD_INT 1
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PUSH
31039: LD_INT 2
31041: PUSH
31042: LD_INT 2
31044: PUSH
31045: EMPTY
31046: LIST
31047: LIST
31048: PUSH
31049: LD_INT 1
31051: PUSH
31052: LD_INT 2
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 0
31061: PUSH
31062: LD_INT 2
31064: PUSH
31065: EMPTY
31066: LIST
31067: LIST
31068: PUSH
31069: LD_INT 1
31071: NEG
31072: PUSH
31073: LD_INT 1
31075: PUSH
31076: EMPTY
31077: LIST
31078: LIST
31079: PUSH
31080: LD_INT 2
31082: NEG
31083: PUSH
31084: LD_INT 0
31086: PUSH
31087: EMPTY
31088: LIST
31089: LIST
31090: PUSH
31091: LD_INT 2
31093: NEG
31094: PUSH
31095: LD_INT 1
31097: NEG
31098: PUSH
31099: EMPTY
31100: LIST
31101: LIST
31102: PUSH
31103: LD_INT 2
31105: NEG
31106: PUSH
31107: LD_INT 2
31109: NEG
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: EMPTY
31116: LIST
31117: LIST
31118: LIST
31119: LIST
31120: LIST
31121: LIST
31122: LIST
31123: LIST
31124: LIST
31125: LIST
31126: LIST
31127: LIST
31128: LIST
31129: LIST
31130: LIST
31131: LIST
31132: LIST
31133: LIST
31134: LIST
31135: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31136: LD_ADDR_VAR 0 18
31140: PUSH
31141: LD_INT 0
31143: PUSH
31144: LD_INT 0
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: PUSH
31151: LD_INT 0
31153: PUSH
31154: LD_INT 1
31156: NEG
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: LD_INT 1
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 1
31174: PUSH
31175: LD_INT 1
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 0
31184: PUSH
31185: LD_INT 1
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 1
31194: NEG
31195: PUSH
31196: LD_INT 0
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PUSH
31203: LD_INT 1
31205: NEG
31206: PUSH
31207: LD_INT 1
31209: NEG
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 1
31217: NEG
31218: PUSH
31219: LD_INT 2
31221: NEG
31222: PUSH
31223: EMPTY
31224: LIST
31225: LIST
31226: PUSH
31227: LD_INT 0
31229: PUSH
31230: LD_INT 2
31232: NEG
31233: PUSH
31234: EMPTY
31235: LIST
31236: LIST
31237: PUSH
31238: LD_INT 1
31240: PUSH
31241: LD_INT 1
31243: NEG
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 2
31251: PUSH
31252: LD_INT 0
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 2
31261: PUSH
31262: LD_INT 1
31264: PUSH
31265: EMPTY
31266: LIST
31267: LIST
31268: PUSH
31269: LD_INT 2
31271: PUSH
31272: LD_INT 2
31274: PUSH
31275: EMPTY
31276: LIST
31277: LIST
31278: PUSH
31279: LD_INT 1
31281: PUSH
31282: LD_INT 2
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 0
31291: PUSH
31292: LD_INT 2
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: PUSH
31299: LD_INT 1
31301: NEG
31302: PUSH
31303: LD_INT 1
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 2
31312: NEG
31313: PUSH
31314: LD_INT 0
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: LD_INT 2
31323: NEG
31324: PUSH
31325: LD_INT 1
31327: NEG
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 2
31335: NEG
31336: PUSH
31337: LD_INT 2
31339: NEG
31340: PUSH
31341: EMPTY
31342: LIST
31343: LIST
31344: PUSH
31345: EMPTY
31346: LIST
31347: LIST
31348: LIST
31349: LIST
31350: LIST
31351: LIST
31352: LIST
31353: LIST
31354: LIST
31355: LIST
31356: LIST
31357: LIST
31358: LIST
31359: LIST
31360: LIST
31361: LIST
31362: LIST
31363: LIST
31364: LIST
31365: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31366: LD_ADDR_VAR 0 19
31370: PUSH
31371: LD_INT 0
31373: PUSH
31374: LD_INT 0
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: PUSH
31381: LD_INT 0
31383: PUSH
31384: LD_INT 1
31386: NEG
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: PUSH
31392: LD_INT 1
31394: PUSH
31395: LD_INT 0
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 1
31404: PUSH
31405: LD_INT 1
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 0
31414: PUSH
31415: LD_INT 1
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 1
31424: NEG
31425: PUSH
31426: LD_INT 0
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 1
31435: NEG
31436: PUSH
31437: LD_INT 1
31439: NEG
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: PUSH
31445: LD_INT 1
31447: NEG
31448: PUSH
31449: LD_INT 2
31451: NEG
31452: PUSH
31453: EMPTY
31454: LIST
31455: LIST
31456: PUSH
31457: LD_INT 0
31459: PUSH
31460: LD_INT 2
31462: NEG
31463: PUSH
31464: EMPTY
31465: LIST
31466: LIST
31467: PUSH
31468: LD_INT 1
31470: PUSH
31471: LD_INT 1
31473: NEG
31474: PUSH
31475: EMPTY
31476: LIST
31477: LIST
31478: PUSH
31479: LD_INT 2
31481: PUSH
31482: LD_INT 0
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: PUSH
31489: LD_INT 2
31491: PUSH
31492: LD_INT 1
31494: PUSH
31495: EMPTY
31496: LIST
31497: LIST
31498: PUSH
31499: LD_INT 2
31501: PUSH
31502: LD_INT 2
31504: PUSH
31505: EMPTY
31506: LIST
31507: LIST
31508: PUSH
31509: LD_INT 1
31511: PUSH
31512: LD_INT 2
31514: PUSH
31515: EMPTY
31516: LIST
31517: LIST
31518: PUSH
31519: LD_INT 0
31521: PUSH
31522: LD_INT 2
31524: PUSH
31525: EMPTY
31526: LIST
31527: LIST
31528: PUSH
31529: LD_INT 1
31531: NEG
31532: PUSH
31533: LD_INT 1
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 2
31542: NEG
31543: PUSH
31544: LD_INT 0
31546: PUSH
31547: EMPTY
31548: LIST
31549: LIST
31550: PUSH
31551: LD_INT 2
31553: NEG
31554: PUSH
31555: LD_INT 1
31557: NEG
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 2
31565: NEG
31566: PUSH
31567: LD_INT 2
31569: NEG
31570: PUSH
31571: EMPTY
31572: LIST
31573: LIST
31574: PUSH
31575: EMPTY
31576: LIST
31577: LIST
31578: LIST
31579: LIST
31580: LIST
31581: LIST
31582: LIST
31583: LIST
31584: LIST
31585: LIST
31586: LIST
31587: LIST
31588: LIST
31589: LIST
31590: LIST
31591: LIST
31592: LIST
31593: LIST
31594: LIST
31595: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31596: LD_ADDR_VAR 0 20
31600: PUSH
31601: LD_INT 0
31603: PUSH
31604: LD_INT 0
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 0
31613: PUSH
31614: LD_INT 1
31616: NEG
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: PUSH
31622: LD_INT 1
31624: PUSH
31625: LD_INT 0
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 1
31634: PUSH
31635: LD_INT 1
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 0
31644: PUSH
31645: LD_INT 1
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 1
31654: NEG
31655: PUSH
31656: LD_INT 0
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PUSH
31663: LD_INT 1
31665: NEG
31666: PUSH
31667: LD_INT 1
31669: NEG
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: LD_INT 1
31677: NEG
31678: PUSH
31679: LD_INT 2
31681: NEG
31682: PUSH
31683: EMPTY
31684: LIST
31685: LIST
31686: PUSH
31687: LD_INT 0
31689: PUSH
31690: LD_INT 2
31692: NEG
31693: PUSH
31694: EMPTY
31695: LIST
31696: LIST
31697: PUSH
31698: LD_INT 1
31700: PUSH
31701: LD_INT 1
31703: NEG
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 2
31711: PUSH
31712: LD_INT 0
31714: PUSH
31715: EMPTY
31716: LIST
31717: LIST
31718: PUSH
31719: LD_INT 2
31721: PUSH
31722: LD_INT 1
31724: PUSH
31725: EMPTY
31726: LIST
31727: LIST
31728: PUSH
31729: LD_INT 2
31731: PUSH
31732: LD_INT 2
31734: PUSH
31735: EMPTY
31736: LIST
31737: LIST
31738: PUSH
31739: LD_INT 1
31741: PUSH
31742: LD_INT 2
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 0
31751: PUSH
31752: LD_INT 2
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 1
31761: NEG
31762: PUSH
31763: LD_INT 1
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: PUSH
31770: LD_INT 2
31772: NEG
31773: PUSH
31774: LD_INT 0
31776: PUSH
31777: EMPTY
31778: LIST
31779: LIST
31780: PUSH
31781: LD_INT 2
31783: NEG
31784: PUSH
31785: LD_INT 1
31787: NEG
31788: PUSH
31789: EMPTY
31790: LIST
31791: LIST
31792: PUSH
31793: LD_INT 2
31795: NEG
31796: PUSH
31797: LD_INT 2
31799: NEG
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: EMPTY
31806: LIST
31807: LIST
31808: LIST
31809: LIST
31810: LIST
31811: LIST
31812: LIST
31813: LIST
31814: LIST
31815: LIST
31816: LIST
31817: LIST
31818: LIST
31819: LIST
31820: LIST
31821: LIST
31822: LIST
31823: LIST
31824: LIST
31825: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31826: LD_ADDR_VAR 0 21
31830: PUSH
31831: LD_INT 0
31833: PUSH
31834: LD_INT 0
31836: PUSH
31837: EMPTY
31838: LIST
31839: LIST
31840: PUSH
31841: LD_INT 0
31843: PUSH
31844: LD_INT 1
31846: NEG
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 1
31854: PUSH
31855: LD_INT 0
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 1
31864: PUSH
31865: LD_INT 1
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 0
31874: PUSH
31875: LD_INT 1
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 1
31884: NEG
31885: PUSH
31886: LD_INT 0
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PUSH
31893: LD_INT 1
31895: NEG
31896: PUSH
31897: LD_INT 1
31899: NEG
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 1
31907: NEG
31908: PUSH
31909: LD_INT 2
31911: NEG
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: LD_INT 0
31919: PUSH
31920: LD_INT 2
31922: NEG
31923: PUSH
31924: EMPTY
31925: LIST
31926: LIST
31927: PUSH
31928: LD_INT 1
31930: PUSH
31931: LD_INT 1
31933: NEG
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 2
31941: PUSH
31942: LD_INT 0
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PUSH
31949: LD_INT 2
31951: PUSH
31952: LD_INT 1
31954: PUSH
31955: EMPTY
31956: LIST
31957: LIST
31958: PUSH
31959: LD_INT 2
31961: PUSH
31962: LD_INT 2
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 1
31971: PUSH
31972: LD_INT 2
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 0
31981: PUSH
31982: LD_INT 2
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 1
31991: NEG
31992: PUSH
31993: LD_INT 1
31995: PUSH
31996: EMPTY
31997: LIST
31998: LIST
31999: PUSH
32000: LD_INT 2
32002: NEG
32003: PUSH
32004: LD_INT 0
32006: PUSH
32007: EMPTY
32008: LIST
32009: LIST
32010: PUSH
32011: LD_INT 2
32013: NEG
32014: PUSH
32015: LD_INT 1
32017: NEG
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: PUSH
32023: LD_INT 2
32025: NEG
32026: PUSH
32027: LD_INT 2
32029: NEG
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: EMPTY
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32056: LD_ADDR_VAR 0 22
32060: PUSH
32061: LD_INT 0
32063: PUSH
32064: LD_INT 0
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 0
32073: PUSH
32074: LD_INT 1
32076: NEG
32077: PUSH
32078: EMPTY
32079: LIST
32080: LIST
32081: PUSH
32082: LD_INT 1
32084: PUSH
32085: LD_INT 0
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 1
32094: PUSH
32095: LD_INT 1
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: PUSH
32102: LD_INT 0
32104: PUSH
32105: LD_INT 1
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 1
32114: NEG
32115: PUSH
32116: LD_INT 0
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: PUSH
32123: LD_INT 1
32125: NEG
32126: PUSH
32127: LD_INT 1
32129: NEG
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 1
32137: NEG
32138: PUSH
32139: LD_INT 2
32141: NEG
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: PUSH
32147: LD_INT 0
32149: PUSH
32150: LD_INT 2
32152: NEG
32153: PUSH
32154: EMPTY
32155: LIST
32156: LIST
32157: PUSH
32158: LD_INT 1
32160: PUSH
32161: LD_INT 1
32163: NEG
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: PUSH
32169: LD_INT 2
32171: PUSH
32172: LD_INT 0
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: LD_INT 2
32181: PUSH
32182: LD_INT 1
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 2
32191: PUSH
32192: LD_INT 2
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: PUSH
32199: LD_INT 1
32201: PUSH
32202: LD_INT 2
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: PUSH
32209: LD_INT 0
32211: PUSH
32212: LD_INT 2
32214: PUSH
32215: EMPTY
32216: LIST
32217: LIST
32218: PUSH
32219: LD_INT 1
32221: NEG
32222: PUSH
32223: LD_INT 1
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PUSH
32230: LD_INT 2
32232: NEG
32233: PUSH
32234: LD_INT 0
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: LD_INT 2
32243: NEG
32244: PUSH
32245: LD_INT 1
32247: NEG
32248: PUSH
32249: EMPTY
32250: LIST
32251: LIST
32252: PUSH
32253: LD_INT 2
32255: NEG
32256: PUSH
32257: LD_INT 2
32259: NEG
32260: PUSH
32261: EMPTY
32262: LIST
32263: LIST
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: LIST
32269: LIST
32270: LIST
32271: LIST
32272: LIST
32273: LIST
32274: LIST
32275: LIST
32276: LIST
32277: LIST
32278: LIST
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: LIST
32284: LIST
32285: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32286: LD_ADDR_VAR 0 23
32290: PUSH
32291: LD_INT 0
32293: PUSH
32294: LD_INT 0
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: PUSH
32301: LD_INT 0
32303: PUSH
32304: LD_INT 1
32306: NEG
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PUSH
32312: LD_INT 1
32314: PUSH
32315: LD_INT 0
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: LD_INT 1
32324: PUSH
32325: LD_INT 1
32327: PUSH
32328: EMPTY
32329: LIST
32330: LIST
32331: PUSH
32332: LD_INT 0
32334: PUSH
32335: LD_INT 1
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: LD_INT 1
32344: NEG
32345: PUSH
32346: LD_INT 0
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 1
32355: NEG
32356: PUSH
32357: LD_INT 1
32359: NEG
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 1
32367: NEG
32368: PUSH
32369: LD_INT 2
32371: NEG
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: LD_INT 0
32379: PUSH
32380: LD_INT 2
32382: NEG
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: LD_INT 1
32390: PUSH
32391: LD_INT 1
32393: NEG
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 2
32401: PUSH
32402: LD_INT 0
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: LD_INT 2
32411: PUSH
32412: LD_INT 1
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: PUSH
32419: LD_INT 2
32421: PUSH
32422: LD_INT 2
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 1
32431: PUSH
32432: LD_INT 2
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 0
32441: PUSH
32442: LD_INT 2
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 1
32451: NEG
32452: PUSH
32453: LD_INT 1
32455: PUSH
32456: EMPTY
32457: LIST
32458: LIST
32459: PUSH
32460: LD_INT 2
32462: NEG
32463: PUSH
32464: LD_INT 0
32466: PUSH
32467: EMPTY
32468: LIST
32469: LIST
32470: PUSH
32471: LD_INT 2
32473: NEG
32474: PUSH
32475: LD_INT 1
32477: NEG
32478: PUSH
32479: EMPTY
32480: LIST
32481: LIST
32482: PUSH
32483: LD_INT 2
32485: NEG
32486: PUSH
32487: LD_INT 2
32489: NEG
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 2
32497: NEG
32498: PUSH
32499: LD_INT 3
32501: NEG
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: NEG
32510: PUSH
32511: LD_INT 3
32513: NEG
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: PUSH
32522: LD_INT 2
32524: NEG
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 2
32532: PUSH
32533: LD_INT 1
32535: NEG
32536: PUSH
32537: EMPTY
32538: LIST
32539: LIST
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: LIST
32545: LIST
32546: LIST
32547: LIST
32548: LIST
32549: LIST
32550: LIST
32551: LIST
32552: LIST
32553: LIST
32554: LIST
32555: LIST
32556: LIST
32557: LIST
32558: LIST
32559: LIST
32560: LIST
32561: LIST
32562: LIST
32563: LIST
32564: LIST
32565: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32566: LD_ADDR_VAR 0 24
32570: PUSH
32571: LD_INT 0
32573: PUSH
32574: LD_INT 0
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PUSH
32581: LD_INT 0
32583: PUSH
32584: LD_INT 1
32586: NEG
32587: PUSH
32588: EMPTY
32589: LIST
32590: LIST
32591: PUSH
32592: LD_INT 1
32594: PUSH
32595: LD_INT 0
32597: PUSH
32598: EMPTY
32599: LIST
32600: LIST
32601: PUSH
32602: LD_INT 1
32604: PUSH
32605: LD_INT 1
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: LD_INT 0
32614: PUSH
32615: LD_INT 1
32617: PUSH
32618: EMPTY
32619: LIST
32620: LIST
32621: PUSH
32622: LD_INT 1
32624: NEG
32625: PUSH
32626: LD_INT 0
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 1
32635: NEG
32636: PUSH
32637: LD_INT 1
32639: NEG
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: PUSH
32645: LD_INT 1
32647: NEG
32648: PUSH
32649: LD_INT 2
32651: NEG
32652: PUSH
32653: EMPTY
32654: LIST
32655: LIST
32656: PUSH
32657: LD_INT 0
32659: PUSH
32660: LD_INT 2
32662: NEG
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 1
32670: PUSH
32671: LD_INT 1
32673: NEG
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 2
32681: PUSH
32682: LD_INT 0
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 2
32691: PUSH
32692: LD_INT 1
32694: PUSH
32695: EMPTY
32696: LIST
32697: LIST
32698: PUSH
32699: LD_INT 2
32701: PUSH
32702: LD_INT 2
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 1
32711: PUSH
32712: LD_INT 2
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 0
32721: PUSH
32722: LD_INT 2
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 1
32731: NEG
32732: PUSH
32733: LD_INT 1
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PUSH
32740: LD_INT 2
32742: NEG
32743: PUSH
32744: LD_INT 0
32746: PUSH
32747: EMPTY
32748: LIST
32749: LIST
32750: PUSH
32751: LD_INT 2
32753: NEG
32754: PUSH
32755: LD_INT 1
32757: NEG
32758: PUSH
32759: EMPTY
32760: LIST
32761: LIST
32762: PUSH
32763: LD_INT 2
32765: NEG
32766: PUSH
32767: LD_INT 2
32769: NEG
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 1
32777: PUSH
32778: LD_INT 2
32780: NEG
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 2
32788: PUSH
32789: LD_INT 1
32791: NEG
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 3
32799: PUSH
32800: LD_INT 1
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: LD_INT 3
32809: PUSH
32810: LD_INT 2
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: LIST
32821: LIST
32822: LIST
32823: LIST
32824: LIST
32825: LIST
32826: LIST
32827: LIST
32828: LIST
32829: LIST
32830: LIST
32831: LIST
32832: LIST
32833: LIST
32834: LIST
32835: LIST
32836: LIST
32837: LIST
32838: LIST
32839: LIST
32840: LIST
32841: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32842: LD_ADDR_VAR 0 25
32846: PUSH
32847: LD_INT 0
32849: PUSH
32850: LD_INT 0
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 0
32859: PUSH
32860: LD_INT 1
32862: NEG
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PUSH
32868: LD_INT 1
32870: PUSH
32871: LD_INT 0
32873: PUSH
32874: EMPTY
32875: LIST
32876: LIST
32877: PUSH
32878: LD_INT 1
32880: PUSH
32881: LD_INT 1
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 0
32890: PUSH
32891: LD_INT 1
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 1
32900: NEG
32901: PUSH
32902: LD_INT 0
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 1
32911: NEG
32912: PUSH
32913: LD_INT 1
32915: NEG
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 1
32923: NEG
32924: PUSH
32925: LD_INT 2
32927: NEG
32928: PUSH
32929: EMPTY
32930: LIST
32931: LIST
32932: PUSH
32933: LD_INT 0
32935: PUSH
32936: LD_INT 2
32938: NEG
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 1
32946: PUSH
32947: LD_INT 1
32949: NEG
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 2
32957: PUSH
32958: LD_INT 0
32960: PUSH
32961: EMPTY
32962: LIST
32963: LIST
32964: PUSH
32965: LD_INT 2
32967: PUSH
32968: LD_INT 1
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: LD_INT 2
32977: PUSH
32978: LD_INT 2
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 1
32987: PUSH
32988: LD_INT 2
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 0
32997: PUSH
32998: LD_INT 2
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: LD_INT 1
33007: NEG
33008: PUSH
33009: LD_INT 1
33011: PUSH
33012: EMPTY
33013: LIST
33014: LIST
33015: PUSH
33016: LD_INT 2
33018: NEG
33019: PUSH
33020: LD_INT 0
33022: PUSH
33023: EMPTY
33024: LIST
33025: LIST
33026: PUSH
33027: LD_INT 2
33029: NEG
33030: PUSH
33031: LD_INT 1
33033: NEG
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PUSH
33039: LD_INT 2
33041: NEG
33042: PUSH
33043: LD_INT 2
33045: NEG
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 3
33053: PUSH
33054: LD_INT 1
33056: PUSH
33057: EMPTY
33058: LIST
33059: LIST
33060: PUSH
33061: LD_INT 3
33063: PUSH
33064: LD_INT 2
33066: PUSH
33067: EMPTY
33068: LIST
33069: LIST
33070: PUSH
33071: LD_INT 2
33073: PUSH
33074: LD_INT 3
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 1
33083: PUSH
33084: LD_INT 3
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: LIST
33095: LIST
33096: LIST
33097: LIST
33098: LIST
33099: LIST
33100: LIST
33101: LIST
33102: LIST
33103: LIST
33104: LIST
33105: LIST
33106: LIST
33107: LIST
33108: LIST
33109: LIST
33110: LIST
33111: LIST
33112: LIST
33113: LIST
33114: LIST
33115: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33116: LD_ADDR_VAR 0 26
33120: PUSH
33121: LD_INT 0
33123: PUSH
33124: LD_INT 0
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 0
33133: PUSH
33134: LD_INT 1
33136: NEG
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 1
33144: PUSH
33145: LD_INT 0
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 1
33154: PUSH
33155: LD_INT 1
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 0
33164: PUSH
33165: LD_INT 1
33167: PUSH
33168: EMPTY
33169: LIST
33170: LIST
33171: PUSH
33172: LD_INT 1
33174: NEG
33175: PUSH
33176: LD_INT 0
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 1
33185: NEG
33186: PUSH
33187: LD_INT 1
33189: NEG
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 1
33197: NEG
33198: PUSH
33199: LD_INT 2
33201: NEG
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 0
33209: PUSH
33210: LD_INT 2
33212: NEG
33213: PUSH
33214: EMPTY
33215: LIST
33216: LIST
33217: PUSH
33218: LD_INT 1
33220: PUSH
33221: LD_INT 1
33223: NEG
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: PUSH
33229: LD_INT 2
33231: PUSH
33232: LD_INT 0
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: PUSH
33239: LD_INT 2
33241: PUSH
33242: LD_INT 1
33244: PUSH
33245: EMPTY
33246: LIST
33247: LIST
33248: PUSH
33249: LD_INT 2
33251: PUSH
33252: LD_INT 2
33254: PUSH
33255: EMPTY
33256: LIST
33257: LIST
33258: PUSH
33259: LD_INT 1
33261: PUSH
33262: LD_INT 2
33264: PUSH
33265: EMPTY
33266: LIST
33267: LIST
33268: PUSH
33269: LD_INT 0
33271: PUSH
33272: LD_INT 2
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 1
33281: NEG
33282: PUSH
33283: LD_INT 1
33285: PUSH
33286: EMPTY
33287: LIST
33288: LIST
33289: PUSH
33290: LD_INT 2
33292: NEG
33293: PUSH
33294: LD_INT 0
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: LD_INT 2
33303: NEG
33304: PUSH
33305: LD_INT 1
33307: NEG
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: PUSH
33313: LD_INT 2
33315: NEG
33316: PUSH
33317: LD_INT 2
33319: NEG
33320: PUSH
33321: EMPTY
33322: LIST
33323: LIST
33324: PUSH
33325: LD_INT 2
33327: PUSH
33328: LD_INT 3
33330: PUSH
33331: EMPTY
33332: LIST
33333: LIST
33334: PUSH
33335: LD_INT 1
33337: PUSH
33338: LD_INT 3
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 1
33347: NEG
33348: PUSH
33349: LD_INT 2
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 2
33358: NEG
33359: PUSH
33360: LD_INT 1
33362: PUSH
33363: EMPTY
33364: LIST
33365: LIST
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: LIST
33375: LIST
33376: LIST
33377: LIST
33378: LIST
33379: LIST
33380: LIST
33381: LIST
33382: LIST
33383: LIST
33384: LIST
33385: LIST
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: LIST
33391: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33392: LD_ADDR_VAR 0 27
33396: PUSH
33397: LD_INT 0
33399: PUSH
33400: LD_INT 0
33402: PUSH
33403: EMPTY
33404: LIST
33405: LIST
33406: PUSH
33407: LD_INT 0
33409: PUSH
33410: LD_INT 1
33412: NEG
33413: PUSH
33414: EMPTY
33415: LIST
33416: LIST
33417: PUSH
33418: LD_INT 1
33420: PUSH
33421: LD_INT 0
33423: PUSH
33424: EMPTY
33425: LIST
33426: LIST
33427: PUSH
33428: LD_INT 1
33430: PUSH
33431: LD_INT 1
33433: PUSH
33434: EMPTY
33435: LIST
33436: LIST
33437: PUSH
33438: LD_INT 0
33440: PUSH
33441: LD_INT 1
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 1
33450: NEG
33451: PUSH
33452: LD_INT 0
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: NEG
33462: PUSH
33463: LD_INT 1
33465: NEG
33466: PUSH
33467: EMPTY
33468: LIST
33469: LIST
33470: PUSH
33471: LD_INT 1
33473: NEG
33474: PUSH
33475: LD_INT 2
33477: NEG
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PUSH
33483: LD_INT 0
33485: PUSH
33486: LD_INT 2
33488: NEG
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 1
33496: PUSH
33497: LD_INT 1
33499: NEG
33500: PUSH
33501: EMPTY
33502: LIST
33503: LIST
33504: PUSH
33505: LD_INT 2
33507: PUSH
33508: LD_INT 0
33510: PUSH
33511: EMPTY
33512: LIST
33513: LIST
33514: PUSH
33515: LD_INT 2
33517: PUSH
33518: LD_INT 1
33520: PUSH
33521: EMPTY
33522: LIST
33523: LIST
33524: PUSH
33525: LD_INT 2
33527: PUSH
33528: LD_INT 2
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 1
33537: PUSH
33538: LD_INT 2
33540: PUSH
33541: EMPTY
33542: LIST
33543: LIST
33544: PUSH
33545: LD_INT 0
33547: PUSH
33548: LD_INT 2
33550: PUSH
33551: EMPTY
33552: LIST
33553: LIST
33554: PUSH
33555: LD_INT 1
33557: NEG
33558: PUSH
33559: LD_INT 1
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: LD_INT 2
33568: NEG
33569: PUSH
33570: LD_INT 0
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: PUSH
33577: LD_INT 2
33579: NEG
33580: PUSH
33581: LD_INT 1
33583: NEG
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: LD_INT 2
33591: NEG
33592: PUSH
33593: LD_INT 2
33595: NEG
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 1
33603: NEG
33604: PUSH
33605: LD_INT 2
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 2
33614: NEG
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: EMPTY
33620: LIST
33621: LIST
33622: PUSH
33623: LD_INT 3
33625: NEG
33626: PUSH
33627: LD_INT 1
33629: NEG
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PUSH
33635: LD_INT 3
33637: NEG
33638: PUSH
33639: LD_INT 2
33641: NEG
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: EMPTY
33648: LIST
33649: LIST
33650: LIST
33651: LIST
33652: LIST
33653: LIST
33654: LIST
33655: LIST
33656: LIST
33657: LIST
33658: LIST
33659: LIST
33660: LIST
33661: LIST
33662: LIST
33663: LIST
33664: LIST
33665: LIST
33666: LIST
33667: LIST
33668: LIST
33669: LIST
33670: LIST
33671: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33672: LD_ADDR_VAR 0 28
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: LD_INT 0
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 0
33689: PUSH
33690: LD_INT 1
33692: NEG
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 1
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 1
33710: PUSH
33711: LD_INT 1
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: LD_INT 1
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 1
33730: NEG
33731: PUSH
33732: LD_INT 0
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 1
33741: NEG
33742: PUSH
33743: LD_INT 1
33745: NEG
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 1
33753: NEG
33754: PUSH
33755: LD_INT 2
33757: NEG
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 0
33765: PUSH
33766: LD_INT 2
33768: NEG
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: LD_INT 1
33779: NEG
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 2
33787: PUSH
33788: LD_INT 0
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 2
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 2
33807: PUSH
33808: LD_INT 2
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 1
33817: PUSH
33818: LD_INT 2
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 0
33827: PUSH
33828: LD_INT 2
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 1
33837: NEG
33838: PUSH
33839: LD_INT 1
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: PUSH
33846: LD_INT 2
33848: NEG
33849: PUSH
33850: LD_INT 0
33852: PUSH
33853: EMPTY
33854: LIST
33855: LIST
33856: PUSH
33857: LD_INT 2
33859: NEG
33860: PUSH
33861: LD_INT 1
33863: NEG
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 2
33871: NEG
33872: PUSH
33873: LD_INT 2
33875: NEG
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 2
33883: NEG
33884: PUSH
33885: LD_INT 3
33887: NEG
33888: PUSH
33889: EMPTY
33890: LIST
33891: LIST
33892: PUSH
33893: LD_INT 1
33895: NEG
33896: PUSH
33897: LD_INT 3
33899: NEG
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 3
33907: NEG
33908: PUSH
33909: LD_INT 1
33911: NEG
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 3
33919: NEG
33920: PUSH
33921: LD_INT 2
33923: NEG
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: LIST
33937: LIST
33938: LIST
33939: LIST
33940: LIST
33941: LIST
33942: LIST
33943: LIST
33944: LIST
33945: LIST
33946: LIST
33947: LIST
33948: LIST
33949: LIST
33950: LIST
33951: LIST
33952: LIST
33953: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33954: LD_ADDR_VAR 0 29
33958: PUSH
33959: LD_INT 0
33961: PUSH
33962: LD_INT 0
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 0
33971: PUSH
33972: LD_INT 1
33974: NEG
33975: PUSH
33976: EMPTY
33977: LIST
33978: LIST
33979: PUSH
33980: LD_INT 1
33982: PUSH
33983: LD_INT 0
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 1
33992: PUSH
33993: LD_INT 1
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 0
34002: PUSH
34003: LD_INT 1
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 1
34012: NEG
34013: PUSH
34014: LD_INT 0
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: NEG
34024: PUSH
34025: LD_INT 1
34027: NEG
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 1
34035: NEG
34036: PUSH
34037: LD_INT 2
34039: NEG
34040: PUSH
34041: EMPTY
34042: LIST
34043: LIST
34044: PUSH
34045: LD_INT 0
34047: PUSH
34048: LD_INT 2
34050: NEG
34051: PUSH
34052: EMPTY
34053: LIST
34054: LIST
34055: PUSH
34056: LD_INT 1
34058: PUSH
34059: LD_INT 1
34061: NEG
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: PUSH
34067: LD_INT 2
34069: PUSH
34070: LD_INT 0
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: PUSH
34077: LD_INT 2
34079: PUSH
34080: LD_INT 1
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: PUSH
34087: LD_INT 1
34089: PUSH
34090: LD_INT 2
34092: PUSH
34093: EMPTY
34094: LIST
34095: LIST
34096: PUSH
34097: LD_INT 0
34099: PUSH
34100: LD_INT 2
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 1
34109: NEG
34110: PUSH
34111: LD_INT 1
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 2
34120: NEG
34121: PUSH
34122: LD_INT 1
34124: NEG
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 2
34132: NEG
34133: PUSH
34134: LD_INT 2
34136: NEG
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: PUSH
34142: LD_INT 2
34144: NEG
34145: PUSH
34146: LD_INT 3
34148: NEG
34149: PUSH
34150: EMPTY
34151: LIST
34152: LIST
34153: PUSH
34154: LD_INT 2
34156: PUSH
34157: LD_INT 1
34159: NEG
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PUSH
34165: LD_INT 3
34167: PUSH
34168: LD_INT 1
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: LD_INT 1
34177: PUSH
34178: LD_INT 3
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 1
34187: NEG
34188: PUSH
34189: LD_INT 2
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 3
34198: NEG
34199: PUSH
34200: LD_INT 2
34202: NEG
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: LIST
34212: LIST
34213: LIST
34214: LIST
34215: LIST
34216: LIST
34217: LIST
34218: LIST
34219: LIST
34220: LIST
34221: LIST
34222: LIST
34223: LIST
34224: LIST
34225: LIST
34226: LIST
34227: LIST
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34233: LD_ADDR_VAR 0 30
34237: PUSH
34238: LD_INT 0
34240: PUSH
34241: LD_INT 0
34243: PUSH
34244: EMPTY
34245: LIST
34246: LIST
34247: PUSH
34248: LD_INT 0
34250: PUSH
34251: LD_INT 1
34253: NEG
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 1
34261: PUSH
34262: LD_INT 0
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: PUSH
34269: LD_INT 1
34271: PUSH
34272: LD_INT 1
34274: PUSH
34275: EMPTY
34276: LIST
34277: LIST
34278: PUSH
34279: LD_INT 0
34281: PUSH
34282: LD_INT 1
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 1
34291: NEG
34292: PUSH
34293: LD_INT 0
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 1
34302: NEG
34303: PUSH
34304: LD_INT 1
34306: NEG
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PUSH
34312: LD_INT 1
34314: NEG
34315: PUSH
34316: LD_INT 2
34318: NEG
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PUSH
34324: LD_INT 0
34326: PUSH
34327: LD_INT 2
34329: NEG
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: LD_INT 1
34337: PUSH
34338: LD_INT 1
34340: NEG
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 2
34348: PUSH
34349: LD_INT 0
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 2
34358: PUSH
34359: LD_INT 1
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: LD_INT 2
34368: PUSH
34369: LD_INT 2
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 1
34378: PUSH
34379: LD_INT 2
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: LD_INT 1
34388: NEG
34389: PUSH
34390: LD_INT 1
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PUSH
34397: LD_INT 2
34399: NEG
34400: PUSH
34401: LD_INT 0
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 2
34410: NEG
34411: PUSH
34412: LD_INT 1
34414: NEG
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: LD_INT 1
34422: NEG
34423: PUSH
34424: LD_INT 3
34426: NEG
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: LD_INT 1
34434: PUSH
34435: LD_INT 2
34437: NEG
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: PUSH
34443: LD_INT 3
34445: PUSH
34446: LD_INT 2
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 2
34455: PUSH
34456: LD_INT 3
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 2
34465: NEG
34466: PUSH
34467: LD_INT 1
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 3
34476: NEG
34477: PUSH
34478: LD_INT 1
34480: NEG
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: EMPTY
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: LIST
34494: LIST
34495: LIST
34496: LIST
34497: LIST
34498: LIST
34499: LIST
34500: LIST
34501: LIST
34502: LIST
34503: LIST
34504: LIST
34505: LIST
34506: LIST
34507: LIST
34508: LIST
34509: LIST
34510: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34511: LD_ADDR_VAR 0 31
34515: PUSH
34516: LD_INT 0
34518: PUSH
34519: LD_INT 0
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 0
34528: PUSH
34529: LD_INT 1
34531: NEG
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 1
34539: PUSH
34540: LD_INT 0
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 1
34549: PUSH
34550: LD_INT 1
34552: PUSH
34553: EMPTY
34554: LIST
34555: LIST
34556: PUSH
34557: LD_INT 0
34559: PUSH
34560: LD_INT 1
34562: PUSH
34563: EMPTY
34564: LIST
34565: LIST
34566: PUSH
34567: LD_INT 1
34569: NEG
34570: PUSH
34571: LD_INT 0
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 1
34580: NEG
34581: PUSH
34582: LD_INT 1
34584: NEG
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 1
34592: NEG
34593: PUSH
34594: LD_INT 2
34596: NEG
34597: PUSH
34598: EMPTY
34599: LIST
34600: LIST
34601: PUSH
34602: LD_INT 1
34604: PUSH
34605: LD_INT 1
34607: NEG
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 2
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 2
34625: PUSH
34626: LD_INT 1
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 2
34635: PUSH
34636: LD_INT 2
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 1
34645: PUSH
34646: LD_INT 2
34648: PUSH
34649: EMPTY
34650: LIST
34651: LIST
34652: PUSH
34653: LD_INT 0
34655: PUSH
34656: LD_INT 2
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 1
34665: NEG
34666: PUSH
34667: LD_INT 1
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PUSH
34674: LD_INT 2
34676: NEG
34677: PUSH
34678: LD_INT 1
34680: NEG
34681: PUSH
34682: EMPTY
34683: LIST
34684: LIST
34685: PUSH
34686: LD_INT 2
34688: NEG
34689: PUSH
34690: LD_INT 2
34692: NEG
34693: PUSH
34694: EMPTY
34695: LIST
34696: LIST
34697: PUSH
34698: LD_INT 2
34700: NEG
34701: PUSH
34702: LD_INT 3
34704: NEG
34705: PUSH
34706: EMPTY
34707: LIST
34708: LIST
34709: PUSH
34710: LD_INT 2
34712: PUSH
34713: LD_INT 1
34715: NEG
34716: PUSH
34717: EMPTY
34718: LIST
34719: LIST
34720: PUSH
34721: LD_INT 3
34723: PUSH
34724: LD_INT 1
34726: PUSH
34727: EMPTY
34728: LIST
34729: LIST
34730: PUSH
34731: LD_INT 1
34733: PUSH
34734: LD_INT 3
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 1
34743: NEG
34744: PUSH
34745: LD_INT 2
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 3
34754: NEG
34755: PUSH
34756: LD_INT 2
34758: NEG
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: EMPTY
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: LIST
34770: LIST
34771: LIST
34772: LIST
34773: LIST
34774: LIST
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: LIST
34787: LIST
34788: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34789: LD_ADDR_VAR 0 32
34793: PUSH
34794: LD_INT 0
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: LD_INT 0
34806: PUSH
34807: LD_INT 1
34809: NEG
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PUSH
34815: LD_INT 1
34817: PUSH
34818: LD_INT 0
34820: PUSH
34821: EMPTY
34822: LIST
34823: LIST
34824: PUSH
34825: LD_INT 1
34827: PUSH
34828: LD_INT 1
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: LD_INT 0
34837: PUSH
34838: LD_INT 1
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: LD_INT 1
34847: NEG
34848: PUSH
34849: LD_INT 0
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: LD_INT 1
34858: NEG
34859: PUSH
34860: LD_INT 1
34862: NEG
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 1
34870: NEG
34871: PUSH
34872: LD_INT 2
34874: NEG
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 0
34882: PUSH
34883: LD_INT 2
34885: NEG
34886: PUSH
34887: EMPTY
34888: LIST
34889: LIST
34890: PUSH
34891: LD_INT 1
34893: PUSH
34894: LD_INT 1
34896: NEG
34897: PUSH
34898: EMPTY
34899: LIST
34900: LIST
34901: PUSH
34902: LD_INT 2
34904: PUSH
34905: LD_INT 1
34907: PUSH
34908: EMPTY
34909: LIST
34910: LIST
34911: PUSH
34912: LD_INT 2
34914: PUSH
34915: LD_INT 2
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 1
34924: PUSH
34925: LD_INT 2
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 0
34934: PUSH
34935: LD_INT 2
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 1
34944: NEG
34945: PUSH
34946: LD_INT 1
34948: PUSH
34949: EMPTY
34950: LIST
34951: LIST
34952: PUSH
34953: LD_INT 2
34955: NEG
34956: PUSH
34957: LD_INT 0
34959: PUSH
34960: EMPTY
34961: LIST
34962: LIST
34963: PUSH
34964: LD_INT 2
34966: NEG
34967: PUSH
34968: LD_INT 1
34970: NEG
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PUSH
34976: LD_INT 1
34978: NEG
34979: PUSH
34980: LD_INT 3
34982: NEG
34983: PUSH
34984: EMPTY
34985: LIST
34986: LIST
34987: PUSH
34988: LD_INT 1
34990: PUSH
34991: LD_INT 2
34993: NEG
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 3
35001: PUSH
35002: LD_INT 2
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 2
35011: PUSH
35012: LD_INT 3
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: LD_INT 1
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 3
35032: NEG
35033: PUSH
35034: LD_INT 1
35036: NEG
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: LIST
35055: LIST
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: LIST
35063: LIST
35064: LIST
35065: LIST
35066: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35067: LD_ADDR_VAR 0 33
35071: PUSH
35072: LD_INT 0
35074: PUSH
35075: LD_INT 0
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 0
35084: PUSH
35085: LD_INT 1
35087: NEG
35088: PUSH
35089: EMPTY
35090: LIST
35091: LIST
35092: PUSH
35093: LD_INT 1
35095: PUSH
35096: LD_INT 0
35098: PUSH
35099: EMPTY
35100: LIST
35101: LIST
35102: PUSH
35103: LD_INT 1
35105: PUSH
35106: LD_INT 1
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PUSH
35113: LD_INT 0
35115: PUSH
35116: LD_INT 1
35118: PUSH
35119: EMPTY
35120: LIST
35121: LIST
35122: PUSH
35123: LD_INT 1
35125: NEG
35126: PUSH
35127: LD_INT 0
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 1
35136: NEG
35137: PUSH
35138: LD_INT 1
35140: NEG
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 1
35148: NEG
35149: PUSH
35150: LD_INT 2
35152: NEG
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 1
35160: PUSH
35161: LD_INT 1
35163: NEG
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 2
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 2
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: PUSH
35192: LD_INT 2
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 0
35201: PUSH
35202: LD_INT 2
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: PUSH
35209: LD_INT 1
35211: NEG
35212: PUSH
35213: LD_INT 1
35215: PUSH
35216: EMPTY
35217: LIST
35218: LIST
35219: PUSH
35220: LD_INT 2
35222: NEG
35223: PUSH
35224: LD_INT 0
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 2
35233: NEG
35234: PUSH
35235: LD_INT 1
35237: NEG
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 2
35245: NEG
35246: PUSH
35247: LD_INT 2
35249: NEG
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: LD_INT 2
35257: NEG
35258: PUSH
35259: LD_INT 3
35261: NEG
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 2
35269: PUSH
35270: LD_INT 1
35272: NEG
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: PUSH
35278: LD_INT 3
35280: PUSH
35281: LD_INT 1
35283: PUSH
35284: EMPTY
35285: LIST
35286: LIST
35287: PUSH
35288: LD_INT 1
35290: PUSH
35291: LD_INT 3
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: LD_INT 1
35300: NEG
35301: PUSH
35302: LD_INT 2
35304: PUSH
35305: EMPTY
35306: LIST
35307: LIST
35308: PUSH
35309: LD_INT 3
35311: NEG
35312: PUSH
35313: LD_INT 2
35315: NEG
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: LIST
35325: LIST
35326: LIST
35327: LIST
35328: LIST
35329: LIST
35330: LIST
35331: LIST
35332: LIST
35333: LIST
35334: LIST
35335: LIST
35336: LIST
35337: LIST
35338: LIST
35339: LIST
35340: LIST
35341: LIST
35342: LIST
35343: LIST
35344: LIST
35345: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35346: LD_ADDR_VAR 0 34
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: LD_INT 0
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 0
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: LD_INT 0
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 1
35384: PUSH
35385: LD_INT 1
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: PUSH
35392: LD_INT 0
35394: PUSH
35395: LD_INT 1
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: LD_INT 1
35404: NEG
35405: PUSH
35406: LD_INT 0
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: NEG
35428: PUSH
35429: LD_INT 2
35431: NEG
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 0
35439: PUSH
35440: LD_INT 2
35442: NEG
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: PUSH
35451: LD_INT 1
35453: NEG
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: LD_INT 2
35461: PUSH
35462: LD_INT 1
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 2
35471: PUSH
35472: LD_INT 2
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 1
35481: PUSH
35482: LD_INT 2
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 1
35491: NEG
35492: PUSH
35493: LD_INT 1
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 2
35502: NEG
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: LD_INT 2
35513: NEG
35514: PUSH
35515: LD_INT 1
35517: NEG
35518: PUSH
35519: EMPTY
35520: LIST
35521: LIST
35522: PUSH
35523: LD_INT 2
35525: NEG
35526: PUSH
35527: LD_INT 2
35529: NEG
35530: PUSH
35531: EMPTY
35532: LIST
35533: LIST
35534: PUSH
35535: LD_INT 1
35537: NEG
35538: PUSH
35539: LD_INT 3
35541: NEG
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 1
35549: PUSH
35550: LD_INT 2
35552: NEG
35553: PUSH
35554: EMPTY
35555: LIST
35556: LIST
35557: PUSH
35558: LD_INT 3
35560: PUSH
35561: LD_INT 2
35563: PUSH
35564: EMPTY
35565: LIST
35566: LIST
35567: PUSH
35568: LD_INT 2
35570: PUSH
35571: LD_INT 3
35573: PUSH
35574: EMPTY
35575: LIST
35576: LIST
35577: PUSH
35578: LD_INT 2
35580: NEG
35581: PUSH
35582: LD_INT 1
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: LD_INT 3
35591: NEG
35592: PUSH
35593: LD_INT 1
35595: NEG
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: EMPTY
35602: LIST
35603: LIST
35604: LIST
35605: LIST
35606: LIST
35607: LIST
35608: LIST
35609: LIST
35610: LIST
35611: LIST
35612: LIST
35613: LIST
35614: LIST
35615: LIST
35616: LIST
35617: LIST
35618: LIST
35619: LIST
35620: LIST
35621: LIST
35622: LIST
35623: LIST
35624: LIST
35625: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35626: LD_ADDR_VAR 0 35
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: LD_INT 0
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 0
35643: PUSH
35644: LD_INT 1
35646: NEG
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 1
35654: PUSH
35655: LD_INT 0
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 1
35664: PUSH
35665: LD_INT 1
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 0
35674: PUSH
35675: LD_INT 1
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 1
35684: NEG
35685: PUSH
35686: LD_INT 0
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: LD_INT 1
35695: NEG
35696: PUSH
35697: LD_INT 1
35699: NEG
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 2
35707: PUSH
35708: LD_INT 1
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 2
35717: NEG
35718: PUSH
35719: LD_INT 1
35721: NEG
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35738: LD_ADDR_VAR 0 36
35742: PUSH
35743: LD_INT 0
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: LD_INT 1
35758: NEG
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 1
35766: PUSH
35767: LD_INT 0
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 1
35776: PUSH
35777: LD_INT 1
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: PUSH
35784: LD_INT 0
35786: PUSH
35787: LD_INT 1
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: PUSH
35794: LD_INT 1
35796: NEG
35797: PUSH
35798: LD_INT 0
35800: PUSH
35801: EMPTY
35802: LIST
35803: LIST
35804: PUSH
35805: LD_INT 1
35807: NEG
35808: PUSH
35809: LD_INT 1
35811: NEG
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 1
35819: NEG
35820: PUSH
35821: LD_INT 2
35823: NEG
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 1
35831: PUSH
35832: LD_INT 2
35834: PUSH
35835: EMPTY
35836: LIST
35837: LIST
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: LIST
35849: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35850: LD_ADDR_VAR 0 37
35854: PUSH
35855: LD_INT 0
35857: PUSH
35858: LD_INT 0
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: LD_INT 0
35867: PUSH
35868: LD_INT 1
35870: NEG
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 1
35878: PUSH
35879: LD_INT 0
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 1
35888: PUSH
35889: LD_INT 1
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 0
35898: PUSH
35899: LD_INT 1
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 1
35908: NEG
35909: PUSH
35910: LD_INT 0
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 1
35919: NEG
35920: PUSH
35921: LD_INT 1
35923: NEG
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: PUSH
35929: LD_INT 1
35931: PUSH
35932: LD_INT 1
35934: NEG
35935: PUSH
35936: EMPTY
35937: LIST
35938: LIST
35939: PUSH
35940: LD_INT 1
35942: NEG
35943: PUSH
35944: LD_INT 1
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: EMPTY
35952: LIST
35953: LIST
35954: LIST
35955: LIST
35956: LIST
35957: LIST
35958: LIST
35959: LIST
35960: LIST
35961: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35962: LD_ADDR_VAR 0 38
35966: PUSH
35967: LD_INT 0
35969: PUSH
35970: LD_INT 0
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 0
35979: PUSH
35980: LD_INT 1
35982: NEG
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 1
35990: PUSH
35991: LD_INT 0
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 1
36000: PUSH
36001: LD_INT 1
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: LD_INT 1
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 1
36020: NEG
36021: PUSH
36022: LD_INT 0
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 1
36031: NEG
36032: PUSH
36033: LD_INT 1
36035: NEG
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 2
36043: PUSH
36044: LD_INT 1
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 2
36053: NEG
36054: PUSH
36055: LD_INT 1
36057: NEG
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: LIST
36067: LIST
36068: LIST
36069: LIST
36070: LIST
36071: LIST
36072: LIST
36073: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36074: LD_ADDR_VAR 0 39
36078: PUSH
36079: LD_INT 0
36081: PUSH
36082: LD_INT 0
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 0
36091: PUSH
36092: LD_INT 1
36094: NEG
36095: PUSH
36096: EMPTY
36097: LIST
36098: LIST
36099: PUSH
36100: LD_INT 1
36102: PUSH
36103: LD_INT 0
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: PUSH
36110: LD_INT 1
36112: PUSH
36113: LD_INT 1
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: LD_INT 0
36122: PUSH
36123: LD_INT 1
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 1
36132: NEG
36133: PUSH
36134: LD_INT 0
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 1
36143: NEG
36144: PUSH
36145: LD_INT 1
36147: NEG
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 1
36155: NEG
36156: PUSH
36157: LD_INT 2
36159: NEG
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 1
36167: PUSH
36168: LD_INT 2
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36186: LD_ADDR_VAR 0 40
36190: PUSH
36191: LD_INT 0
36193: PUSH
36194: LD_INT 0
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: PUSH
36201: LD_INT 0
36203: PUSH
36204: LD_INT 1
36206: NEG
36207: PUSH
36208: EMPTY
36209: LIST
36210: LIST
36211: PUSH
36212: LD_INT 1
36214: PUSH
36215: LD_INT 0
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: PUSH
36222: LD_INT 1
36224: PUSH
36225: LD_INT 1
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: LD_INT 0
36234: PUSH
36235: LD_INT 1
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 1
36244: NEG
36245: PUSH
36246: LD_INT 0
36248: PUSH
36249: EMPTY
36250: LIST
36251: LIST
36252: PUSH
36253: LD_INT 1
36255: NEG
36256: PUSH
36257: LD_INT 1
36259: NEG
36260: PUSH
36261: EMPTY
36262: LIST
36263: LIST
36264: PUSH
36265: LD_INT 1
36267: PUSH
36268: LD_INT 1
36270: NEG
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 1
36278: NEG
36279: PUSH
36280: LD_INT 1
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: LIST
36291: LIST
36292: LIST
36293: LIST
36294: LIST
36295: LIST
36296: LIST
36297: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36298: LD_ADDR_VAR 0 41
36302: PUSH
36303: LD_INT 0
36305: PUSH
36306: LD_INT 0
36308: PUSH
36309: EMPTY
36310: LIST
36311: LIST
36312: PUSH
36313: LD_INT 0
36315: PUSH
36316: LD_INT 1
36318: NEG
36319: PUSH
36320: EMPTY
36321: LIST
36322: LIST
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: LD_INT 0
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: PUSH
36334: LD_INT 1
36336: PUSH
36337: LD_INT 1
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 0
36346: PUSH
36347: LD_INT 1
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 1
36356: NEG
36357: PUSH
36358: LD_INT 0
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 1
36367: NEG
36368: PUSH
36369: LD_INT 1
36371: NEG
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 1
36379: NEG
36380: PUSH
36381: LD_INT 2
36383: NEG
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: PUSH
36389: LD_INT 1
36391: PUSH
36392: LD_INT 1
36394: NEG
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 2
36402: PUSH
36403: LD_INT 0
36405: PUSH
36406: EMPTY
36407: LIST
36408: LIST
36409: PUSH
36410: LD_INT 2
36412: PUSH
36413: LD_INT 1
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 2
36422: PUSH
36423: LD_INT 2
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: LD_INT 1
36432: PUSH
36433: LD_INT 2
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: LD_INT 1
36442: NEG
36443: PUSH
36444: LD_INT 1
36446: PUSH
36447: EMPTY
36448: LIST
36449: LIST
36450: PUSH
36451: LD_INT 2
36453: NEG
36454: PUSH
36455: LD_INT 0
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: PUSH
36462: LD_INT 2
36464: NEG
36465: PUSH
36466: LD_INT 1
36468: NEG
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 2
36476: NEG
36477: PUSH
36478: LD_INT 2
36480: NEG
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 2
36488: NEG
36489: PUSH
36490: LD_INT 3
36492: NEG
36493: PUSH
36494: EMPTY
36495: LIST
36496: LIST
36497: PUSH
36498: LD_INT 2
36500: PUSH
36501: LD_INT 1
36503: NEG
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 3
36511: PUSH
36512: LD_INT 0
36514: PUSH
36515: EMPTY
36516: LIST
36517: LIST
36518: PUSH
36519: LD_INT 3
36521: PUSH
36522: LD_INT 1
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: PUSH
36529: LD_INT 3
36531: PUSH
36532: LD_INT 2
36534: PUSH
36535: EMPTY
36536: LIST
36537: LIST
36538: PUSH
36539: LD_INT 3
36541: PUSH
36542: LD_INT 3
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: LD_INT 2
36551: PUSH
36552: LD_INT 3
36554: PUSH
36555: EMPTY
36556: LIST
36557: LIST
36558: PUSH
36559: LD_INT 2
36561: NEG
36562: PUSH
36563: LD_INT 1
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PUSH
36570: LD_INT 3
36572: NEG
36573: PUSH
36574: LD_INT 0
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 3
36583: NEG
36584: PUSH
36585: LD_INT 1
36587: NEG
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 3
36595: NEG
36596: PUSH
36597: LD_INT 2
36599: NEG
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: PUSH
36605: LD_INT 3
36607: NEG
36608: PUSH
36609: LD_INT 3
36611: NEG
36612: PUSH
36613: EMPTY
36614: LIST
36615: LIST
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: LIST
36630: LIST
36631: LIST
36632: LIST
36633: LIST
36634: LIST
36635: LIST
36636: LIST
36637: LIST
36638: LIST
36639: LIST
36640: LIST
36641: LIST
36642: LIST
36643: LIST
36644: LIST
36645: LIST
36646: LIST
36647: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36648: LD_ADDR_VAR 0 42
36652: PUSH
36653: LD_INT 0
36655: PUSH
36656: LD_INT 0
36658: PUSH
36659: EMPTY
36660: LIST
36661: LIST
36662: PUSH
36663: LD_INT 0
36665: PUSH
36666: LD_INT 1
36668: NEG
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: PUSH
36674: LD_INT 1
36676: PUSH
36677: LD_INT 0
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: LD_INT 1
36686: PUSH
36687: LD_INT 1
36689: PUSH
36690: EMPTY
36691: LIST
36692: LIST
36693: PUSH
36694: LD_INT 0
36696: PUSH
36697: LD_INT 1
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: LD_INT 1
36706: NEG
36707: PUSH
36708: LD_INT 0
36710: PUSH
36711: EMPTY
36712: LIST
36713: LIST
36714: PUSH
36715: LD_INT 1
36717: NEG
36718: PUSH
36719: LD_INT 1
36721: NEG
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: NEG
36730: PUSH
36731: LD_INT 2
36733: NEG
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 0
36741: PUSH
36742: LD_INT 2
36744: NEG
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: PUSH
36750: LD_INT 1
36752: PUSH
36753: LD_INT 1
36755: NEG
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 2
36763: PUSH
36764: LD_INT 1
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 2
36773: PUSH
36774: LD_INT 2
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 1
36783: PUSH
36784: LD_INT 2
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 0
36793: PUSH
36794: LD_INT 2
36796: PUSH
36797: EMPTY
36798: LIST
36799: LIST
36800: PUSH
36801: LD_INT 1
36803: NEG
36804: PUSH
36805: LD_INT 1
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 2
36814: NEG
36815: PUSH
36816: LD_INT 1
36818: NEG
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 2
36826: NEG
36827: PUSH
36828: LD_INT 2
36830: NEG
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: PUSH
36836: LD_INT 2
36838: NEG
36839: PUSH
36840: LD_INT 3
36842: NEG
36843: PUSH
36844: EMPTY
36845: LIST
36846: LIST
36847: PUSH
36848: LD_INT 1
36850: NEG
36851: PUSH
36852: LD_INT 3
36854: NEG
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PUSH
36860: LD_INT 0
36862: PUSH
36863: LD_INT 3
36865: NEG
36866: PUSH
36867: EMPTY
36868: LIST
36869: LIST
36870: PUSH
36871: LD_INT 1
36873: PUSH
36874: LD_INT 2
36876: NEG
36877: PUSH
36878: EMPTY
36879: LIST
36880: LIST
36881: PUSH
36882: LD_INT 3
36884: PUSH
36885: LD_INT 2
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: PUSH
36892: LD_INT 3
36894: PUSH
36895: LD_INT 3
36897: PUSH
36898: EMPTY
36899: LIST
36900: LIST
36901: PUSH
36902: LD_INT 2
36904: PUSH
36905: LD_INT 3
36907: PUSH
36908: EMPTY
36909: LIST
36910: LIST
36911: PUSH
36912: LD_INT 1
36914: PUSH
36915: LD_INT 3
36917: PUSH
36918: EMPTY
36919: LIST
36920: LIST
36921: PUSH
36922: LD_INT 0
36924: PUSH
36925: LD_INT 3
36927: PUSH
36928: EMPTY
36929: LIST
36930: LIST
36931: PUSH
36932: LD_INT 1
36934: NEG
36935: PUSH
36936: LD_INT 2
36938: PUSH
36939: EMPTY
36940: LIST
36941: LIST
36942: PUSH
36943: LD_INT 3
36945: NEG
36946: PUSH
36947: LD_INT 2
36949: NEG
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PUSH
36955: LD_INT 3
36957: NEG
36958: PUSH
36959: LD_INT 3
36961: NEG
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: LIST
36981: LIST
36982: LIST
36983: LIST
36984: LIST
36985: LIST
36986: LIST
36987: LIST
36988: LIST
36989: LIST
36990: LIST
36991: LIST
36992: LIST
36993: LIST
36994: LIST
36995: LIST
36996: LIST
36997: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36998: LD_ADDR_VAR 0 43
37002: PUSH
37003: LD_INT 0
37005: PUSH
37006: LD_INT 0
37008: PUSH
37009: EMPTY
37010: LIST
37011: LIST
37012: PUSH
37013: LD_INT 0
37015: PUSH
37016: LD_INT 1
37018: NEG
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: PUSH
37024: LD_INT 1
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: EMPTY
37031: LIST
37032: LIST
37033: PUSH
37034: LD_INT 1
37036: PUSH
37037: LD_INT 1
37039: PUSH
37040: EMPTY
37041: LIST
37042: LIST
37043: PUSH
37044: LD_INT 0
37046: PUSH
37047: LD_INT 1
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 1
37056: NEG
37057: PUSH
37058: LD_INT 0
37060: PUSH
37061: EMPTY
37062: LIST
37063: LIST
37064: PUSH
37065: LD_INT 1
37067: NEG
37068: PUSH
37069: LD_INT 1
37071: NEG
37072: PUSH
37073: EMPTY
37074: LIST
37075: LIST
37076: PUSH
37077: LD_INT 1
37079: NEG
37080: PUSH
37081: LD_INT 2
37083: NEG
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 0
37091: PUSH
37092: LD_INT 2
37094: NEG
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 1
37102: PUSH
37103: LD_INT 1
37105: NEG
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: LD_INT 2
37113: PUSH
37114: LD_INT 0
37116: PUSH
37117: EMPTY
37118: LIST
37119: LIST
37120: PUSH
37121: LD_INT 2
37123: PUSH
37124: LD_INT 1
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 1
37133: PUSH
37134: LD_INT 2
37136: PUSH
37137: EMPTY
37138: LIST
37139: LIST
37140: PUSH
37141: LD_INT 0
37143: PUSH
37144: LD_INT 2
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 1
37153: NEG
37154: PUSH
37155: LD_INT 1
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: PUSH
37162: LD_INT 2
37164: NEG
37165: PUSH
37166: LD_INT 0
37168: PUSH
37169: EMPTY
37170: LIST
37171: LIST
37172: PUSH
37173: LD_INT 2
37175: NEG
37176: PUSH
37177: LD_INT 1
37179: NEG
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 1
37187: NEG
37188: PUSH
37189: LD_INT 3
37191: NEG
37192: PUSH
37193: EMPTY
37194: LIST
37195: LIST
37196: PUSH
37197: LD_INT 0
37199: PUSH
37200: LD_INT 3
37202: NEG
37203: PUSH
37204: EMPTY
37205: LIST
37206: LIST
37207: PUSH
37208: LD_INT 1
37210: PUSH
37211: LD_INT 2
37213: NEG
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: PUSH
37219: LD_INT 2
37221: PUSH
37222: LD_INT 1
37224: NEG
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: PUSH
37230: LD_INT 3
37232: PUSH
37233: LD_INT 0
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 3
37242: PUSH
37243: LD_INT 1
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 1
37252: PUSH
37253: LD_INT 3
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 0
37262: PUSH
37263: LD_INT 3
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 1
37272: NEG
37273: PUSH
37274: LD_INT 2
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 2
37283: NEG
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 3
37294: NEG
37295: PUSH
37296: LD_INT 0
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: LD_INT 3
37305: NEG
37306: PUSH
37307: LD_INT 1
37309: NEG
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: LIST
37319: LIST
37320: LIST
37321: LIST
37322: LIST
37323: LIST
37324: LIST
37325: LIST
37326: LIST
37327: LIST
37328: LIST
37329: LIST
37330: LIST
37331: LIST
37332: LIST
37333: LIST
37334: LIST
37335: LIST
37336: LIST
37337: LIST
37338: LIST
37339: LIST
37340: LIST
37341: LIST
37342: LIST
37343: LIST
37344: LIST
37345: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37346: LD_ADDR_VAR 0 44
37350: PUSH
37351: LD_INT 0
37353: PUSH
37354: LD_INT 0
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: LD_INT 0
37363: PUSH
37364: LD_INT 1
37366: NEG
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PUSH
37372: LD_INT 1
37374: PUSH
37375: LD_INT 0
37377: PUSH
37378: EMPTY
37379: LIST
37380: LIST
37381: PUSH
37382: LD_INT 1
37384: PUSH
37385: LD_INT 1
37387: PUSH
37388: EMPTY
37389: LIST
37390: LIST
37391: PUSH
37392: LD_INT 0
37394: PUSH
37395: LD_INT 1
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 1
37404: NEG
37405: PUSH
37406: LD_INT 0
37408: PUSH
37409: EMPTY
37410: LIST
37411: LIST
37412: PUSH
37413: LD_INT 1
37415: NEG
37416: PUSH
37417: LD_INT 1
37419: NEG
37420: PUSH
37421: EMPTY
37422: LIST
37423: LIST
37424: PUSH
37425: LD_INT 1
37427: NEG
37428: PUSH
37429: LD_INT 2
37431: NEG
37432: PUSH
37433: EMPTY
37434: LIST
37435: LIST
37436: PUSH
37437: LD_INT 1
37439: PUSH
37440: LD_INT 1
37442: NEG
37443: PUSH
37444: EMPTY
37445: LIST
37446: LIST
37447: PUSH
37448: LD_INT 2
37450: PUSH
37451: LD_INT 0
37453: PUSH
37454: EMPTY
37455: LIST
37456: LIST
37457: PUSH
37458: LD_INT 2
37460: PUSH
37461: LD_INT 1
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: LD_INT 2
37470: PUSH
37471: LD_INT 2
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 1
37480: PUSH
37481: LD_INT 2
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 1
37490: NEG
37491: PUSH
37492: LD_INT 1
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 2
37501: NEG
37502: PUSH
37503: LD_INT 0
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 2
37512: NEG
37513: PUSH
37514: LD_INT 1
37516: NEG
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 2
37524: NEG
37525: PUSH
37526: LD_INT 2
37528: NEG
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: PUSH
37534: LD_INT 2
37536: NEG
37537: PUSH
37538: LD_INT 3
37540: NEG
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 2
37548: PUSH
37549: LD_INT 1
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 3
37559: PUSH
37560: LD_INT 0
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 3
37569: PUSH
37570: LD_INT 1
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 3
37579: PUSH
37580: LD_INT 2
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: LD_INT 3
37589: PUSH
37590: LD_INT 3
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 2
37599: PUSH
37600: LD_INT 3
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PUSH
37607: LD_INT 2
37609: NEG
37610: PUSH
37611: LD_INT 1
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 3
37620: NEG
37621: PUSH
37622: LD_INT 0
37624: PUSH
37625: EMPTY
37626: LIST
37627: LIST
37628: PUSH
37629: LD_INT 3
37631: NEG
37632: PUSH
37633: LD_INT 1
37635: NEG
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 3
37643: NEG
37644: PUSH
37645: LD_INT 2
37647: NEG
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: LD_INT 3
37655: NEG
37656: PUSH
37657: LD_INT 3
37659: NEG
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: EMPTY
37666: LIST
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: LIST
37672: LIST
37673: LIST
37674: LIST
37675: LIST
37676: LIST
37677: LIST
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: LIST
37688: LIST
37689: LIST
37690: LIST
37691: LIST
37692: LIST
37693: LIST
37694: LIST
37695: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37696: LD_ADDR_VAR 0 45
37700: PUSH
37701: LD_INT 0
37703: PUSH
37704: LD_INT 0
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: LD_INT 1
37716: NEG
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 1
37724: PUSH
37725: LD_INT 0
37727: PUSH
37728: EMPTY
37729: LIST
37730: LIST
37731: PUSH
37732: LD_INT 1
37734: PUSH
37735: LD_INT 1
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 0
37744: PUSH
37745: LD_INT 1
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 1
37754: NEG
37755: PUSH
37756: LD_INT 0
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 1
37765: NEG
37766: PUSH
37767: LD_INT 1
37769: NEG
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 1
37777: NEG
37778: PUSH
37779: LD_INT 2
37781: NEG
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: LD_INT 0
37789: PUSH
37790: LD_INT 2
37792: NEG
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PUSH
37798: LD_INT 1
37800: PUSH
37801: LD_INT 1
37803: NEG
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: LD_INT 2
37811: PUSH
37812: LD_INT 1
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 2
37821: PUSH
37822: LD_INT 2
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 1
37831: PUSH
37832: LD_INT 2
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: LD_INT 0
37841: PUSH
37842: LD_INT 2
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 1
37851: NEG
37852: PUSH
37853: LD_INT 1
37855: PUSH
37856: EMPTY
37857: LIST
37858: LIST
37859: PUSH
37860: LD_INT 2
37862: NEG
37863: PUSH
37864: LD_INT 1
37866: NEG
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 2
37874: NEG
37875: PUSH
37876: LD_INT 2
37878: NEG
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 2
37886: NEG
37887: PUSH
37888: LD_INT 3
37890: NEG
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: LD_INT 3
37902: NEG
37903: PUSH
37904: EMPTY
37905: LIST
37906: LIST
37907: PUSH
37908: LD_INT 0
37910: PUSH
37911: LD_INT 3
37913: NEG
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 1
37921: PUSH
37922: LD_INT 2
37924: NEG
37925: PUSH
37926: EMPTY
37927: LIST
37928: LIST
37929: PUSH
37930: LD_INT 3
37932: PUSH
37933: LD_INT 2
37935: PUSH
37936: EMPTY
37937: LIST
37938: LIST
37939: PUSH
37940: LD_INT 3
37942: PUSH
37943: LD_INT 3
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: LD_INT 2
37952: PUSH
37953: LD_INT 3
37955: PUSH
37956: EMPTY
37957: LIST
37958: LIST
37959: PUSH
37960: LD_INT 1
37962: PUSH
37963: LD_INT 3
37965: PUSH
37966: EMPTY
37967: LIST
37968: LIST
37969: PUSH
37970: LD_INT 0
37972: PUSH
37973: LD_INT 3
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: PUSH
37980: LD_INT 1
37982: NEG
37983: PUSH
37984: LD_INT 2
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: PUSH
37991: LD_INT 3
37993: NEG
37994: PUSH
37995: LD_INT 2
37997: NEG
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 3
38005: NEG
38006: PUSH
38007: LD_INT 3
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: LIST
38019: LIST
38020: LIST
38021: LIST
38022: LIST
38023: LIST
38024: LIST
38025: LIST
38026: LIST
38027: LIST
38028: LIST
38029: LIST
38030: LIST
38031: LIST
38032: LIST
38033: LIST
38034: LIST
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38046: LD_ADDR_VAR 0 46
38050: PUSH
38051: LD_INT 0
38053: PUSH
38054: LD_INT 0
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 0
38063: PUSH
38064: LD_INT 1
38066: NEG
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 1
38074: PUSH
38075: LD_INT 0
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PUSH
38082: LD_INT 1
38084: PUSH
38085: LD_INT 1
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PUSH
38092: LD_INT 0
38094: PUSH
38095: LD_INT 1
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 1
38104: NEG
38105: PUSH
38106: LD_INT 0
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 1
38115: NEG
38116: PUSH
38117: LD_INT 1
38119: NEG
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: LD_INT 1
38127: NEG
38128: PUSH
38129: LD_INT 2
38131: NEG
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 0
38139: PUSH
38140: LD_INT 2
38142: NEG
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 1
38150: PUSH
38151: LD_INT 1
38153: NEG
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 2
38161: PUSH
38162: LD_INT 0
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 2
38171: PUSH
38172: LD_INT 1
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 1
38181: PUSH
38182: LD_INT 2
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 0
38191: PUSH
38192: LD_INT 2
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 1
38201: NEG
38202: PUSH
38203: LD_INT 1
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 2
38212: NEG
38213: PUSH
38214: LD_INT 0
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: LD_INT 2
38223: NEG
38224: PUSH
38225: LD_INT 1
38227: NEG
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 1
38235: NEG
38236: PUSH
38237: LD_INT 3
38239: NEG
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: PUSH
38245: LD_INT 0
38247: PUSH
38248: LD_INT 3
38250: NEG
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: LD_INT 1
38258: PUSH
38259: LD_INT 2
38261: NEG
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 2
38269: PUSH
38270: LD_INT 1
38272: NEG
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 3
38280: PUSH
38281: LD_INT 0
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 3
38290: PUSH
38291: LD_INT 1
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 1
38300: PUSH
38301: LD_INT 3
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: LD_INT 0
38310: PUSH
38311: LD_INT 3
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: LD_INT 1
38320: NEG
38321: PUSH
38322: LD_INT 2
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: LD_INT 2
38331: NEG
38332: PUSH
38333: LD_INT 1
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 3
38342: NEG
38343: PUSH
38344: LD_INT 0
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: PUSH
38351: LD_INT 3
38353: NEG
38354: PUSH
38355: LD_INT 1
38357: NEG
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: LIST
38367: LIST
38368: LIST
38369: LIST
38370: LIST
38371: LIST
38372: LIST
38373: LIST
38374: LIST
38375: LIST
38376: LIST
38377: LIST
38378: LIST
38379: LIST
38380: LIST
38381: LIST
38382: LIST
38383: LIST
38384: LIST
38385: LIST
38386: LIST
38387: LIST
38388: LIST
38389: LIST
38390: LIST
38391: LIST
38392: LIST
38393: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38394: LD_ADDR_VAR 0 47
38398: PUSH
38399: LD_INT 0
38401: PUSH
38402: LD_INT 0
38404: PUSH
38405: EMPTY
38406: LIST
38407: LIST
38408: PUSH
38409: LD_INT 0
38411: PUSH
38412: LD_INT 1
38414: NEG
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 1
38422: PUSH
38423: LD_INT 0
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: PUSH
38433: LD_INT 1
38435: PUSH
38436: EMPTY
38437: LIST
38438: LIST
38439: PUSH
38440: LD_INT 0
38442: PUSH
38443: LD_INT 1
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 1
38452: NEG
38453: PUSH
38454: LD_INT 0
38456: PUSH
38457: EMPTY
38458: LIST
38459: LIST
38460: PUSH
38461: LD_INT 1
38463: NEG
38464: PUSH
38465: LD_INT 1
38467: NEG
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: PUSH
38473: LD_INT 1
38475: NEG
38476: PUSH
38477: LD_INT 2
38479: NEG
38480: PUSH
38481: EMPTY
38482: LIST
38483: LIST
38484: PUSH
38485: LD_INT 0
38487: PUSH
38488: LD_INT 2
38490: NEG
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 1
38498: PUSH
38499: LD_INT 1
38501: NEG
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 2
38509: NEG
38510: PUSH
38511: LD_INT 1
38513: NEG
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: LD_INT 2
38521: NEG
38522: PUSH
38523: LD_INT 2
38525: NEG
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: LIST
38540: LIST
38541: LIST
38542: LIST
38543: LIST
38544: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38545: LD_ADDR_VAR 0 48
38549: PUSH
38550: LD_INT 0
38552: PUSH
38553: LD_INT 0
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PUSH
38560: LD_INT 0
38562: PUSH
38563: LD_INT 1
38565: NEG
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 1
38573: PUSH
38574: LD_INT 0
38576: PUSH
38577: EMPTY
38578: LIST
38579: LIST
38580: PUSH
38581: LD_INT 1
38583: PUSH
38584: LD_INT 1
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: PUSH
38591: LD_INT 0
38593: PUSH
38594: LD_INT 1
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PUSH
38601: LD_INT 1
38603: NEG
38604: PUSH
38605: LD_INT 0
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: PUSH
38612: LD_INT 1
38614: NEG
38615: PUSH
38616: LD_INT 1
38618: NEG
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 1
38626: NEG
38627: PUSH
38628: LD_INT 2
38630: NEG
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PUSH
38636: LD_INT 0
38638: PUSH
38639: LD_INT 2
38641: NEG
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 1
38649: PUSH
38650: LD_INT 1
38652: NEG
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 2
38660: PUSH
38661: LD_INT 0
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 2
38670: PUSH
38671: LD_INT 1
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: LIST
38686: LIST
38687: LIST
38688: LIST
38689: LIST
38690: LIST
38691: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38692: LD_ADDR_VAR 0 49
38696: PUSH
38697: LD_INT 0
38699: PUSH
38700: LD_INT 0
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PUSH
38707: LD_INT 0
38709: PUSH
38710: LD_INT 1
38712: NEG
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: PUSH
38718: LD_INT 1
38720: PUSH
38721: LD_INT 0
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: PUSH
38728: LD_INT 1
38730: PUSH
38731: LD_INT 1
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 0
38740: PUSH
38741: LD_INT 1
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 1
38750: NEG
38751: PUSH
38752: LD_INT 0
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 1
38761: NEG
38762: PUSH
38763: LD_INT 1
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 1
38773: PUSH
38774: LD_INT 1
38776: NEG
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 2
38784: PUSH
38785: LD_INT 0
38787: PUSH
38788: EMPTY
38789: LIST
38790: LIST
38791: PUSH
38792: LD_INT 2
38794: PUSH
38795: LD_INT 1
38797: PUSH
38798: EMPTY
38799: LIST
38800: LIST
38801: PUSH
38802: LD_INT 2
38804: PUSH
38805: LD_INT 2
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 1
38814: PUSH
38815: LD_INT 2
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: LIST
38834: LIST
38835: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38836: LD_ADDR_VAR 0 50
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: LD_INT 0
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 0
38853: PUSH
38854: LD_INT 1
38856: NEG
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 1
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 1
38874: PUSH
38875: LD_INT 1
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: LD_INT 0
38884: PUSH
38885: LD_INT 1
38887: PUSH
38888: EMPTY
38889: LIST
38890: LIST
38891: PUSH
38892: LD_INT 1
38894: NEG
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: EMPTY
38900: LIST
38901: LIST
38902: PUSH
38903: LD_INT 1
38905: NEG
38906: PUSH
38907: LD_INT 1
38909: NEG
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PUSH
38915: LD_INT 2
38917: PUSH
38918: LD_INT 1
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 2
38927: PUSH
38928: LD_INT 2
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: PUSH
38935: LD_INT 1
38937: PUSH
38938: LD_INT 2
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 0
38947: PUSH
38948: LD_INT 2
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: LD_INT 1
38957: NEG
38958: PUSH
38959: LD_INT 1
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: LIST
38970: LIST
38971: LIST
38972: LIST
38973: LIST
38974: LIST
38975: LIST
38976: LIST
38977: LIST
38978: LIST
38979: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38980: LD_ADDR_VAR 0 51
38984: PUSH
38985: LD_INT 0
38987: PUSH
38988: LD_INT 0
38990: PUSH
38991: EMPTY
38992: LIST
38993: LIST
38994: PUSH
38995: LD_INT 0
38997: PUSH
38998: LD_INT 1
39000: NEG
39001: PUSH
39002: EMPTY
39003: LIST
39004: LIST
39005: PUSH
39006: LD_INT 1
39008: PUSH
39009: LD_INT 0
39011: PUSH
39012: EMPTY
39013: LIST
39014: LIST
39015: PUSH
39016: LD_INT 1
39018: PUSH
39019: LD_INT 1
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: PUSH
39026: LD_INT 0
39028: PUSH
39029: LD_INT 1
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 1
39038: NEG
39039: PUSH
39040: LD_INT 0
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: LD_INT 1
39049: NEG
39050: PUSH
39051: LD_INT 1
39053: NEG
39054: PUSH
39055: EMPTY
39056: LIST
39057: LIST
39058: PUSH
39059: LD_INT 1
39061: PUSH
39062: LD_INT 2
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: LD_INT 0
39071: PUSH
39072: LD_INT 2
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 1
39081: NEG
39082: PUSH
39083: LD_INT 1
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 2
39092: NEG
39093: PUSH
39094: LD_INT 0
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 2
39103: NEG
39104: PUSH
39105: LD_INT 1
39107: NEG
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: EMPTY
39114: LIST
39115: LIST
39116: LIST
39117: LIST
39118: LIST
39119: LIST
39120: LIST
39121: LIST
39122: LIST
39123: LIST
39124: LIST
39125: LIST
39126: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39127: LD_ADDR_VAR 0 52
39131: PUSH
39132: LD_INT 0
39134: PUSH
39135: LD_INT 0
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: PUSH
39142: LD_INT 0
39144: PUSH
39145: LD_INT 1
39147: NEG
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: LD_INT 1
39155: PUSH
39156: LD_INT 0
39158: PUSH
39159: EMPTY
39160: LIST
39161: LIST
39162: PUSH
39163: LD_INT 1
39165: PUSH
39166: LD_INT 1
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: LD_INT 0
39175: PUSH
39176: LD_INT 1
39178: PUSH
39179: EMPTY
39180: LIST
39181: LIST
39182: PUSH
39183: LD_INT 1
39185: NEG
39186: PUSH
39187: LD_INT 0
39189: PUSH
39190: EMPTY
39191: LIST
39192: LIST
39193: PUSH
39194: LD_INT 1
39196: NEG
39197: PUSH
39198: LD_INT 1
39200: NEG
39201: PUSH
39202: EMPTY
39203: LIST
39204: LIST
39205: PUSH
39206: LD_INT 1
39208: NEG
39209: PUSH
39210: LD_INT 2
39212: NEG
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PUSH
39218: LD_INT 1
39220: NEG
39221: PUSH
39222: LD_INT 1
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 2
39231: NEG
39232: PUSH
39233: LD_INT 0
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 2
39242: NEG
39243: PUSH
39244: LD_INT 1
39246: NEG
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 2
39254: NEG
39255: PUSH
39256: LD_INT 2
39258: NEG
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: LIST
39270: LIST
39271: LIST
39272: LIST
39273: LIST
39274: LIST
39275: LIST
39276: LIST
39277: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39278: LD_ADDR_VAR 0 53
39282: PUSH
39283: LD_INT 0
39285: PUSH
39286: LD_INT 0
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 0
39295: PUSH
39296: LD_INT 1
39298: NEG
39299: PUSH
39300: EMPTY
39301: LIST
39302: LIST
39303: PUSH
39304: LD_INT 1
39306: PUSH
39307: LD_INT 0
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 1
39316: PUSH
39317: LD_INT 1
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 0
39326: PUSH
39327: LD_INT 1
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: PUSH
39334: LD_INT 1
39336: NEG
39337: PUSH
39338: LD_INT 0
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 1
39347: NEG
39348: PUSH
39349: LD_INT 1
39351: NEG
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 1
39359: NEG
39360: PUSH
39361: LD_INT 2
39363: NEG
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: LD_INT 2
39374: NEG
39375: PUSH
39376: EMPTY
39377: LIST
39378: LIST
39379: PUSH
39380: LD_INT 1
39382: PUSH
39383: LD_INT 1
39385: NEG
39386: PUSH
39387: EMPTY
39388: LIST
39389: LIST
39390: PUSH
39391: LD_INT 2
39393: PUSH
39394: LD_INT 0
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 2
39403: PUSH
39404: LD_INT 1
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: LD_INT 2
39413: PUSH
39414: LD_INT 2
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 1
39423: PUSH
39424: LD_INT 2
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 0
39433: PUSH
39434: LD_INT 2
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PUSH
39441: LD_INT 1
39443: NEG
39444: PUSH
39445: LD_INT 1
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 2
39454: NEG
39455: PUSH
39456: LD_INT 0
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 2
39465: NEG
39466: PUSH
39467: LD_INT 1
39469: NEG
39470: PUSH
39471: EMPTY
39472: LIST
39473: LIST
39474: PUSH
39475: LD_INT 2
39477: NEG
39478: PUSH
39479: LD_INT 2
39481: NEG
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: LIST
39491: LIST
39492: LIST
39493: LIST
39494: LIST
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: LIST
39500: LIST
39501: LIST
39502: LIST
39503: LIST
39504: LIST
39505: LIST
39506: LIST
39507: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39508: LD_ADDR_VAR 0 54
39512: PUSH
39513: LD_INT 0
39515: PUSH
39516: LD_INT 0
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 0
39525: PUSH
39526: LD_INT 1
39528: NEG
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: PUSH
39534: LD_INT 1
39536: PUSH
39537: LD_INT 0
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 1
39546: PUSH
39547: LD_INT 1
39549: PUSH
39550: EMPTY
39551: LIST
39552: LIST
39553: PUSH
39554: LD_INT 0
39556: PUSH
39557: LD_INT 1
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 1
39566: NEG
39567: PUSH
39568: LD_INT 0
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PUSH
39575: LD_INT 1
39577: NEG
39578: PUSH
39579: LD_INT 1
39581: NEG
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 1
39589: NEG
39590: PUSH
39591: LD_INT 2
39593: NEG
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 0
39601: PUSH
39602: LD_INT 2
39604: NEG
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: LD_INT 1
39612: PUSH
39613: LD_INT 1
39615: NEG
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: LD_INT 2
39623: PUSH
39624: LD_INT 0
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 2
39633: PUSH
39634: LD_INT 1
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 2
39643: PUSH
39644: LD_INT 2
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: LD_INT 1
39653: PUSH
39654: LD_INT 2
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 0
39663: PUSH
39664: LD_INT 2
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 1
39673: NEG
39674: PUSH
39675: LD_INT 1
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 2
39684: NEG
39685: PUSH
39686: LD_INT 0
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: PUSH
39693: LD_INT 2
39695: NEG
39696: PUSH
39697: LD_INT 1
39699: NEG
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 2
39707: NEG
39708: PUSH
39709: LD_INT 2
39711: NEG
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: EMPTY
39718: LIST
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: LIST
39729: LIST
39730: LIST
39731: LIST
39732: LIST
39733: LIST
39734: LIST
39735: LIST
39736: LIST
39737: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39738: LD_ADDR_VAR 0 55
39742: PUSH
39743: LD_INT 0
39745: PUSH
39746: LD_INT 0
39748: PUSH
39749: EMPTY
39750: LIST
39751: LIST
39752: PUSH
39753: LD_INT 0
39755: PUSH
39756: LD_INT 1
39758: NEG
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: LD_INT 1
39766: PUSH
39767: LD_INT 0
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 1
39776: PUSH
39777: LD_INT 1
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: PUSH
39784: LD_INT 0
39786: PUSH
39787: LD_INT 1
39789: PUSH
39790: EMPTY
39791: LIST
39792: LIST
39793: PUSH
39794: LD_INT 1
39796: NEG
39797: PUSH
39798: LD_INT 0
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 1
39807: NEG
39808: PUSH
39809: LD_INT 1
39811: NEG
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 1
39819: NEG
39820: PUSH
39821: LD_INT 2
39823: NEG
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 0
39831: PUSH
39832: LD_INT 2
39834: NEG
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PUSH
39840: LD_INT 1
39842: PUSH
39843: LD_INT 1
39845: NEG
39846: PUSH
39847: EMPTY
39848: LIST
39849: LIST
39850: PUSH
39851: LD_INT 2
39853: PUSH
39854: LD_INT 0
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: PUSH
39861: LD_INT 2
39863: PUSH
39864: LD_INT 1
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: PUSH
39871: LD_INT 2
39873: PUSH
39874: LD_INT 2
39876: PUSH
39877: EMPTY
39878: LIST
39879: LIST
39880: PUSH
39881: LD_INT 1
39883: PUSH
39884: LD_INT 2
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 0
39893: PUSH
39894: LD_INT 2
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: LD_INT 1
39903: NEG
39904: PUSH
39905: LD_INT 1
39907: PUSH
39908: EMPTY
39909: LIST
39910: LIST
39911: PUSH
39912: LD_INT 2
39914: NEG
39915: PUSH
39916: LD_INT 0
39918: PUSH
39919: EMPTY
39920: LIST
39921: LIST
39922: PUSH
39923: LD_INT 2
39925: NEG
39926: PUSH
39927: LD_INT 1
39929: NEG
39930: PUSH
39931: EMPTY
39932: LIST
39933: LIST
39934: PUSH
39935: LD_INT 2
39937: NEG
39938: PUSH
39939: LD_INT 2
39941: NEG
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: LIST
39956: LIST
39957: LIST
39958: LIST
39959: LIST
39960: LIST
39961: LIST
39962: LIST
39963: LIST
39964: LIST
39965: LIST
39966: LIST
39967: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39968: LD_ADDR_VAR 0 56
39972: PUSH
39973: LD_INT 0
39975: PUSH
39976: LD_INT 0
39978: PUSH
39979: EMPTY
39980: LIST
39981: LIST
39982: PUSH
39983: LD_INT 0
39985: PUSH
39986: LD_INT 1
39988: NEG
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 1
39996: PUSH
39997: LD_INT 0
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: LD_INT 1
40006: PUSH
40007: LD_INT 1
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: LD_INT 0
40016: PUSH
40017: LD_INT 1
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 1
40026: NEG
40027: PUSH
40028: LD_INT 0
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 1
40037: NEG
40038: PUSH
40039: LD_INT 1
40041: NEG
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 1
40049: NEG
40050: PUSH
40051: LD_INT 2
40053: NEG
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: LD_INT 0
40061: PUSH
40062: LD_INT 2
40064: NEG
40065: PUSH
40066: EMPTY
40067: LIST
40068: LIST
40069: PUSH
40070: LD_INT 1
40072: PUSH
40073: LD_INT 1
40075: NEG
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PUSH
40081: LD_INT 2
40083: PUSH
40084: LD_INT 0
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 2
40093: PUSH
40094: LD_INT 1
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 2
40103: PUSH
40104: LD_INT 2
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 1
40113: PUSH
40114: LD_INT 2
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 0
40123: PUSH
40124: LD_INT 2
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 1
40133: NEG
40134: PUSH
40135: LD_INT 1
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 2
40144: NEG
40145: PUSH
40146: LD_INT 0
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: LD_INT 2
40155: NEG
40156: PUSH
40157: LD_INT 1
40159: NEG
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: PUSH
40165: LD_INT 2
40167: NEG
40168: PUSH
40169: LD_INT 2
40171: NEG
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40198: LD_ADDR_VAR 0 57
40202: PUSH
40203: LD_INT 0
40205: PUSH
40206: LD_INT 0
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 0
40215: PUSH
40216: LD_INT 1
40218: NEG
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: PUSH
40224: LD_INT 1
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 1
40236: PUSH
40237: LD_INT 1
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 0
40246: PUSH
40247: LD_INT 1
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 1
40256: NEG
40257: PUSH
40258: LD_INT 0
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 1
40267: NEG
40268: PUSH
40269: LD_INT 1
40271: NEG
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 1
40279: NEG
40280: PUSH
40281: LD_INT 2
40283: NEG
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 0
40291: PUSH
40292: LD_INT 2
40294: NEG
40295: PUSH
40296: EMPTY
40297: LIST
40298: LIST
40299: PUSH
40300: LD_INT 1
40302: PUSH
40303: LD_INT 1
40305: NEG
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 2
40313: PUSH
40314: LD_INT 0
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 2
40323: PUSH
40324: LD_INT 1
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PUSH
40331: LD_INT 2
40333: PUSH
40334: LD_INT 2
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: LD_INT 1
40343: PUSH
40344: LD_INT 2
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 0
40353: PUSH
40354: LD_INT 2
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 1
40363: NEG
40364: PUSH
40365: LD_INT 1
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 2
40374: NEG
40375: PUSH
40376: LD_INT 0
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 2
40385: NEG
40386: PUSH
40387: LD_INT 1
40389: NEG
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 2
40397: NEG
40398: PUSH
40399: LD_INT 2
40401: NEG
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: LIST
40427: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40428: LD_ADDR_VAR 0 58
40432: PUSH
40433: LD_INT 0
40435: PUSH
40436: LD_INT 0
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 0
40445: PUSH
40446: LD_INT 1
40448: NEG
40449: PUSH
40450: EMPTY
40451: LIST
40452: LIST
40453: PUSH
40454: LD_INT 1
40456: PUSH
40457: LD_INT 0
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: PUSH
40464: LD_INT 1
40466: PUSH
40467: LD_INT 1
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 0
40476: PUSH
40477: LD_INT 1
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 1
40486: NEG
40487: PUSH
40488: LD_INT 0
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 1
40497: NEG
40498: PUSH
40499: LD_INT 1
40501: NEG
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: PUSH
40507: LD_INT 1
40509: NEG
40510: PUSH
40511: LD_INT 2
40513: NEG
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: LD_INT 0
40521: PUSH
40522: LD_INT 2
40524: NEG
40525: PUSH
40526: EMPTY
40527: LIST
40528: LIST
40529: PUSH
40530: LD_INT 1
40532: PUSH
40533: LD_INT 1
40535: NEG
40536: PUSH
40537: EMPTY
40538: LIST
40539: LIST
40540: PUSH
40541: LD_INT 2
40543: PUSH
40544: LD_INT 0
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: PUSH
40551: LD_INT 2
40553: PUSH
40554: LD_INT 1
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: LD_INT 2
40563: PUSH
40564: LD_INT 2
40566: PUSH
40567: EMPTY
40568: LIST
40569: LIST
40570: PUSH
40571: LD_INT 1
40573: PUSH
40574: LD_INT 2
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 0
40583: PUSH
40584: LD_INT 2
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 1
40593: NEG
40594: PUSH
40595: LD_INT 1
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: LD_INT 2
40604: NEG
40605: PUSH
40606: LD_INT 0
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: PUSH
40613: LD_INT 2
40615: NEG
40616: PUSH
40617: LD_INT 1
40619: NEG
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 2
40627: NEG
40628: PUSH
40629: LD_INT 2
40631: NEG
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: EMPTY
40638: LIST
40639: LIST
40640: LIST
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: LIST
40646: LIST
40647: LIST
40648: LIST
40649: LIST
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: LIST
40656: LIST
40657: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40658: LD_ADDR_VAR 0 59
40662: PUSH
40663: LD_INT 0
40665: PUSH
40666: LD_INT 0
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 0
40675: PUSH
40676: LD_INT 1
40678: NEG
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 1
40686: PUSH
40687: LD_INT 0
40689: PUSH
40690: EMPTY
40691: LIST
40692: LIST
40693: PUSH
40694: LD_INT 1
40696: PUSH
40697: LD_INT 1
40699: PUSH
40700: EMPTY
40701: LIST
40702: LIST
40703: PUSH
40704: LD_INT 0
40706: PUSH
40707: LD_INT 1
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 1
40716: NEG
40717: PUSH
40718: LD_INT 0
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: NEG
40728: PUSH
40729: LD_INT 1
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: LIST
40741: LIST
40742: LIST
40743: LIST
40744: LIST
40745: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40746: LD_ADDR_VAR 0 60
40750: PUSH
40751: LD_INT 0
40753: PUSH
40754: LD_INT 0
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 0
40763: PUSH
40764: LD_INT 1
40766: NEG
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 1
40774: PUSH
40775: LD_INT 0
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 1
40784: PUSH
40785: LD_INT 1
40787: PUSH
40788: EMPTY
40789: LIST
40790: LIST
40791: PUSH
40792: LD_INT 0
40794: PUSH
40795: LD_INT 1
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: PUSH
40802: LD_INT 1
40804: NEG
40805: PUSH
40806: LD_INT 0
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: LD_INT 1
40815: NEG
40816: PUSH
40817: LD_INT 1
40819: NEG
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: EMPTY
40826: LIST
40827: LIST
40828: LIST
40829: LIST
40830: LIST
40831: LIST
40832: LIST
40833: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40834: LD_ADDR_VAR 0 61
40838: PUSH
40839: LD_INT 0
40841: PUSH
40842: LD_INT 0
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: PUSH
40849: LD_INT 0
40851: PUSH
40852: LD_INT 1
40854: NEG
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: PUSH
40860: LD_INT 1
40862: PUSH
40863: LD_INT 0
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 1
40872: PUSH
40873: LD_INT 1
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: PUSH
40880: LD_INT 0
40882: PUSH
40883: LD_INT 1
40885: PUSH
40886: EMPTY
40887: LIST
40888: LIST
40889: PUSH
40890: LD_INT 1
40892: NEG
40893: PUSH
40894: LD_INT 0
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: PUSH
40901: LD_INT 1
40903: NEG
40904: PUSH
40905: LD_INT 1
40907: NEG
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: EMPTY
40914: LIST
40915: LIST
40916: LIST
40917: LIST
40918: LIST
40919: LIST
40920: LIST
40921: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40922: LD_ADDR_VAR 0 62
40926: PUSH
40927: LD_INT 0
40929: PUSH
40930: LD_INT 0
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 0
40939: PUSH
40940: LD_INT 1
40942: NEG
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: PUSH
40948: LD_INT 1
40950: PUSH
40951: LD_INT 0
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 1
40960: PUSH
40961: LD_INT 1
40963: PUSH
40964: EMPTY
40965: LIST
40966: LIST
40967: PUSH
40968: LD_INT 0
40970: PUSH
40971: LD_INT 1
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 1
40980: NEG
40981: PUSH
40982: LD_INT 0
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: LD_INT 1
40991: NEG
40992: PUSH
40993: LD_INT 1
40995: NEG
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41010: LD_ADDR_VAR 0 63
41014: PUSH
41015: LD_INT 0
41017: PUSH
41018: LD_INT 0
41020: PUSH
41021: EMPTY
41022: LIST
41023: LIST
41024: PUSH
41025: LD_INT 0
41027: PUSH
41028: LD_INT 1
41030: NEG
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 1
41038: PUSH
41039: LD_INT 0
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: LD_INT 1
41048: PUSH
41049: LD_INT 1
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: LD_INT 0
41058: PUSH
41059: LD_INT 1
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: PUSH
41066: LD_INT 1
41068: NEG
41069: PUSH
41070: LD_INT 0
41072: PUSH
41073: EMPTY
41074: LIST
41075: LIST
41076: PUSH
41077: LD_INT 1
41079: NEG
41080: PUSH
41081: LD_INT 1
41083: NEG
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: LIST
41097: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41098: LD_ADDR_VAR 0 64
41102: PUSH
41103: LD_INT 0
41105: PUSH
41106: LD_INT 0
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: PUSH
41113: LD_INT 0
41115: PUSH
41116: LD_INT 1
41118: NEG
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: PUSH
41124: LD_INT 1
41126: PUSH
41127: LD_INT 0
41129: PUSH
41130: EMPTY
41131: LIST
41132: LIST
41133: PUSH
41134: LD_INT 1
41136: PUSH
41137: LD_INT 1
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: LD_INT 0
41146: PUSH
41147: LD_INT 1
41149: PUSH
41150: EMPTY
41151: LIST
41152: LIST
41153: PUSH
41154: LD_INT 1
41156: NEG
41157: PUSH
41158: LD_INT 0
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 1
41167: NEG
41168: PUSH
41169: LD_INT 1
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: EMPTY
41178: LIST
41179: LIST
41180: LIST
41181: LIST
41182: LIST
41183: LIST
41184: LIST
41185: ST_TO_ADDR
// end ; 1 :
41186: GO 47083
41188: LD_INT 1
41190: DOUBLE
41191: EQUAL
41192: IFTRUE 41196
41194: GO 43819
41196: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41197: LD_ADDR_VAR 0 11
41201: PUSH
41202: LD_INT 1
41204: NEG
41205: PUSH
41206: LD_INT 3
41208: NEG
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PUSH
41214: LD_INT 0
41216: PUSH
41217: LD_INT 3
41219: NEG
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 1
41227: PUSH
41228: LD_INT 2
41230: NEG
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: LIST
41240: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41241: LD_ADDR_VAR 0 12
41245: PUSH
41246: LD_INT 2
41248: PUSH
41249: LD_INT 1
41251: NEG
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 3
41259: PUSH
41260: LD_INT 0
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PUSH
41267: LD_INT 3
41269: PUSH
41270: LD_INT 1
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: LIST
41281: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41282: LD_ADDR_VAR 0 13
41286: PUSH
41287: LD_INT 3
41289: PUSH
41290: LD_INT 2
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 3
41299: PUSH
41300: LD_INT 3
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: PUSH
41307: LD_INT 2
41309: PUSH
41310: LD_INT 3
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: LIST
41321: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41322: LD_ADDR_VAR 0 14
41326: PUSH
41327: LD_INT 1
41329: PUSH
41330: LD_INT 3
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 0
41339: PUSH
41340: LD_INT 3
41342: PUSH
41343: EMPTY
41344: LIST
41345: LIST
41346: PUSH
41347: LD_INT 1
41349: NEG
41350: PUSH
41351: LD_INT 2
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: EMPTY
41359: LIST
41360: LIST
41361: LIST
41362: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41363: LD_ADDR_VAR 0 15
41367: PUSH
41368: LD_INT 2
41370: NEG
41371: PUSH
41372: LD_INT 1
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 3
41381: NEG
41382: PUSH
41383: LD_INT 0
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: PUSH
41390: LD_INT 3
41392: NEG
41393: PUSH
41394: LD_INT 1
41396: NEG
41397: PUSH
41398: EMPTY
41399: LIST
41400: LIST
41401: PUSH
41402: EMPTY
41403: LIST
41404: LIST
41405: LIST
41406: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41407: LD_ADDR_VAR 0 16
41411: PUSH
41412: LD_INT 2
41414: NEG
41415: PUSH
41416: LD_INT 3
41418: NEG
41419: PUSH
41420: EMPTY
41421: LIST
41422: LIST
41423: PUSH
41424: LD_INT 3
41426: NEG
41427: PUSH
41428: LD_INT 2
41430: NEG
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 3
41438: NEG
41439: PUSH
41440: LD_INT 3
41442: NEG
41443: PUSH
41444: EMPTY
41445: LIST
41446: LIST
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: LIST
41452: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41453: LD_ADDR_VAR 0 17
41457: PUSH
41458: LD_INT 1
41460: NEG
41461: PUSH
41462: LD_INT 3
41464: NEG
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 0
41472: PUSH
41473: LD_INT 3
41475: NEG
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: PUSH
41481: LD_INT 1
41483: PUSH
41484: LD_INT 2
41486: NEG
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: LIST
41496: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41497: LD_ADDR_VAR 0 18
41501: PUSH
41502: LD_INT 2
41504: PUSH
41505: LD_INT 1
41507: NEG
41508: PUSH
41509: EMPTY
41510: LIST
41511: LIST
41512: PUSH
41513: LD_INT 3
41515: PUSH
41516: LD_INT 0
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 3
41525: PUSH
41526: LD_INT 1
41528: PUSH
41529: EMPTY
41530: LIST
41531: LIST
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: LIST
41537: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41538: LD_ADDR_VAR 0 19
41542: PUSH
41543: LD_INT 3
41545: PUSH
41546: LD_INT 2
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: LD_INT 3
41555: PUSH
41556: LD_INT 3
41558: PUSH
41559: EMPTY
41560: LIST
41561: LIST
41562: PUSH
41563: LD_INT 2
41565: PUSH
41566: LD_INT 3
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: EMPTY
41574: LIST
41575: LIST
41576: LIST
41577: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41578: LD_ADDR_VAR 0 20
41582: PUSH
41583: LD_INT 1
41585: PUSH
41586: LD_INT 3
41588: PUSH
41589: EMPTY
41590: LIST
41591: LIST
41592: PUSH
41593: LD_INT 0
41595: PUSH
41596: LD_INT 3
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: PUSH
41603: LD_INT 1
41605: NEG
41606: PUSH
41607: LD_INT 2
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PUSH
41614: EMPTY
41615: LIST
41616: LIST
41617: LIST
41618: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41619: LD_ADDR_VAR 0 21
41623: PUSH
41624: LD_INT 2
41626: NEG
41627: PUSH
41628: LD_INT 1
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: PUSH
41635: LD_INT 3
41637: NEG
41638: PUSH
41639: LD_INT 0
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 3
41648: NEG
41649: PUSH
41650: LD_INT 1
41652: NEG
41653: PUSH
41654: EMPTY
41655: LIST
41656: LIST
41657: PUSH
41658: EMPTY
41659: LIST
41660: LIST
41661: LIST
41662: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41663: LD_ADDR_VAR 0 22
41667: PUSH
41668: LD_INT 2
41670: NEG
41671: PUSH
41672: LD_INT 3
41674: NEG
41675: PUSH
41676: EMPTY
41677: LIST
41678: LIST
41679: PUSH
41680: LD_INT 3
41682: NEG
41683: PUSH
41684: LD_INT 2
41686: NEG
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 3
41694: NEG
41695: PUSH
41696: LD_INT 3
41698: NEG
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: LIST
41708: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41709: LD_ADDR_VAR 0 23
41713: PUSH
41714: LD_INT 0
41716: PUSH
41717: LD_INT 3
41719: NEG
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 1
41727: NEG
41728: PUSH
41729: LD_INT 4
41731: NEG
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 1
41739: PUSH
41740: LD_INT 3
41742: NEG
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: LIST
41752: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41753: LD_ADDR_VAR 0 24
41757: PUSH
41758: LD_INT 3
41760: PUSH
41761: LD_INT 0
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: LD_INT 3
41770: PUSH
41771: LD_INT 1
41773: NEG
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: PUSH
41779: LD_INT 4
41781: PUSH
41782: LD_INT 1
41784: PUSH
41785: EMPTY
41786: LIST
41787: LIST
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: LIST
41793: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41794: LD_ADDR_VAR 0 25
41798: PUSH
41799: LD_INT 3
41801: PUSH
41802: LD_INT 3
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: LD_INT 4
41811: PUSH
41812: LD_INT 3
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: PUSH
41819: LD_INT 3
41821: PUSH
41822: LD_INT 4
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PUSH
41829: EMPTY
41830: LIST
41831: LIST
41832: LIST
41833: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41834: LD_ADDR_VAR 0 26
41838: PUSH
41839: LD_INT 0
41841: PUSH
41842: LD_INT 3
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: PUSH
41849: LD_INT 1
41851: PUSH
41852: LD_INT 4
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 1
41861: NEG
41862: PUSH
41863: LD_INT 3
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: LIST
41874: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41875: LD_ADDR_VAR 0 27
41879: PUSH
41880: LD_INT 3
41882: NEG
41883: PUSH
41884: LD_INT 0
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: PUSH
41891: LD_INT 3
41893: NEG
41894: PUSH
41895: LD_INT 1
41897: PUSH
41898: EMPTY
41899: LIST
41900: LIST
41901: PUSH
41902: LD_INT 4
41904: NEG
41905: PUSH
41906: LD_INT 1
41908: NEG
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: LIST
41918: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41919: LD_ADDR_VAR 0 28
41923: PUSH
41924: LD_INT 3
41926: NEG
41927: PUSH
41928: LD_INT 3
41930: NEG
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 3
41938: NEG
41939: PUSH
41940: LD_INT 4
41942: NEG
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: LD_INT 4
41950: NEG
41951: PUSH
41952: LD_INT 3
41954: NEG
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: LIST
41964: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41965: LD_ADDR_VAR 0 29
41969: PUSH
41970: LD_INT 1
41972: NEG
41973: PUSH
41974: LD_INT 3
41976: NEG
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: PUSH
41982: LD_INT 0
41984: PUSH
41985: LD_INT 3
41987: NEG
41988: PUSH
41989: EMPTY
41990: LIST
41991: LIST
41992: PUSH
41993: LD_INT 1
41995: PUSH
41996: LD_INT 2
41998: NEG
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: LD_INT 1
42006: NEG
42007: PUSH
42008: LD_INT 4
42010: NEG
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 0
42018: PUSH
42019: LD_INT 4
42021: NEG
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: LD_INT 1
42029: PUSH
42030: LD_INT 3
42032: NEG
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: LD_INT 1
42040: NEG
42041: PUSH
42042: LD_INT 5
42044: NEG
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 0
42052: PUSH
42053: LD_INT 5
42055: NEG
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 1
42063: PUSH
42064: LD_INT 4
42066: NEG
42067: PUSH
42068: EMPTY
42069: LIST
42070: LIST
42071: PUSH
42072: LD_INT 1
42074: NEG
42075: PUSH
42076: LD_INT 6
42078: NEG
42079: PUSH
42080: EMPTY
42081: LIST
42082: LIST
42083: PUSH
42084: LD_INT 0
42086: PUSH
42087: LD_INT 6
42089: NEG
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: PUSH
42095: LD_INT 1
42097: PUSH
42098: LD_INT 5
42100: NEG
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: LIST
42110: LIST
42111: LIST
42112: LIST
42113: LIST
42114: LIST
42115: LIST
42116: LIST
42117: LIST
42118: LIST
42119: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42120: LD_ADDR_VAR 0 30
42124: PUSH
42125: LD_INT 2
42127: PUSH
42128: LD_INT 1
42130: NEG
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: LD_INT 3
42138: PUSH
42139: LD_INT 0
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: PUSH
42146: LD_INT 3
42148: PUSH
42149: LD_INT 1
42151: PUSH
42152: EMPTY
42153: LIST
42154: LIST
42155: PUSH
42156: LD_INT 3
42158: PUSH
42159: LD_INT 1
42161: NEG
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: LD_INT 4
42169: PUSH
42170: LD_INT 0
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: PUSH
42177: LD_INT 4
42179: PUSH
42180: LD_INT 1
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 4
42189: PUSH
42190: LD_INT 1
42192: NEG
42193: PUSH
42194: EMPTY
42195: LIST
42196: LIST
42197: PUSH
42198: LD_INT 5
42200: PUSH
42201: LD_INT 0
42203: PUSH
42204: EMPTY
42205: LIST
42206: LIST
42207: PUSH
42208: LD_INT 5
42210: PUSH
42211: LD_INT 1
42213: PUSH
42214: EMPTY
42215: LIST
42216: LIST
42217: PUSH
42218: LD_INT 5
42220: PUSH
42221: LD_INT 1
42223: NEG
42224: PUSH
42225: EMPTY
42226: LIST
42227: LIST
42228: PUSH
42229: LD_INT 6
42231: PUSH
42232: LD_INT 0
42234: PUSH
42235: EMPTY
42236: LIST
42237: LIST
42238: PUSH
42239: LD_INT 6
42241: PUSH
42242: LD_INT 1
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: LIST
42259: LIST
42260: LIST
42261: LIST
42262: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42263: LD_ADDR_VAR 0 31
42267: PUSH
42268: LD_INT 3
42270: PUSH
42271: LD_INT 2
42273: PUSH
42274: EMPTY
42275: LIST
42276: LIST
42277: PUSH
42278: LD_INT 3
42280: PUSH
42281: LD_INT 3
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: LD_INT 2
42290: PUSH
42291: LD_INT 3
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: LD_INT 4
42300: PUSH
42301: LD_INT 3
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: PUSH
42308: LD_INT 4
42310: PUSH
42311: LD_INT 4
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PUSH
42318: LD_INT 3
42320: PUSH
42321: LD_INT 4
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 5
42330: PUSH
42331: LD_INT 4
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: LD_INT 5
42340: PUSH
42341: LD_INT 5
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: PUSH
42348: LD_INT 4
42350: PUSH
42351: LD_INT 5
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 6
42360: PUSH
42361: LD_INT 5
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 6
42370: PUSH
42371: LD_INT 6
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: PUSH
42378: LD_INT 5
42380: PUSH
42381: LD_INT 6
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: EMPTY
42389: LIST
42390: LIST
42391: LIST
42392: LIST
42393: LIST
42394: LIST
42395: LIST
42396: LIST
42397: LIST
42398: LIST
42399: LIST
42400: LIST
42401: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42402: LD_ADDR_VAR 0 32
42406: PUSH
42407: LD_INT 1
42409: PUSH
42410: LD_INT 3
42412: PUSH
42413: EMPTY
42414: LIST
42415: LIST
42416: PUSH
42417: LD_INT 0
42419: PUSH
42420: LD_INT 3
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PUSH
42427: LD_INT 1
42429: NEG
42430: PUSH
42431: LD_INT 2
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: PUSH
42438: LD_INT 1
42440: PUSH
42441: LD_INT 4
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: PUSH
42448: LD_INT 0
42450: PUSH
42451: LD_INT 4
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 1
42460: NEG
42461: PUSH
42462: LD_INT 3
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 1
42471: PUSH
42472: LD_INT 5
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: LD_INT 0
42481: PUSH
42482: LD_INT 5
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 1
42491: NEG
42492: PUSH
42493: LD_INT 4
42495: PUSH
42496: EMPTY
42497: LIST
42498: LIST
42499: PUSH
42500: LD_INT 1
42502: PUSH
42503: LD_INT 6
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: PUSH
42510: LD_INT 0
42512: PUSH
42513: LD_INT 6
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PUSH
42520: LD_INT 1
42522: NEG
42523: PUSH
42524: LD_INT 5
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PUSH
42531: EMPTY
42532: LIST
42533: LIST
42534: LIST
42535: LIST
42536: LIST
42537: LIST
42538: LIST
42539: LIST
42540: LIST
42541: LIST
42542: LIST
42543: LIST
42544: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42545: LD_ADDR_VAR 0 33
42549: PUSH
42550: LD_INT 2
42552: NEG
42553: PUSH
42554: LD_INT 1
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: PUSH
42561: LD_INT 3
42563: NEG
42564: PUSH
42565: LD_INT 0
42567: PUSH
42568: EMPTY
42569: LIST
42570: LIST
42571: PUSH
42572: LD_INT 3
42574: NEG
42575: PUSH
42576: LD_INT 1
42578: NEG
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 3
42586: NEG
42587: PUSH
42588: LD_INT 1
42590: PUSH
42591: EMPTY
42592: LIST
42593: LIST
42594: PUSH
42595: LD_INT 4
42597: NEG
42598: PUSH
42599: LD_INT 0
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: PUSH
42606: LD_INT 4
42608: NEG
42609: PUSH
42610: LD_INT 1
42612: NEG
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 4
42620: NEG
42621: PUSH
42622: LD_INT 1
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 5
42631: NEG
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: EMPTY
42637: LIST
42638: LIST
42639: PUSH
42640: LD_INT 5
42642: NEG
42643: PUSH
42644: LD_INT 1
42646: NEG
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 5
42654: NEG
42655: PUSH
42656: LD_INT 1
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: PUSH
42663: LD_INT 6
42665: NEG
42666: PUSH
42667: LD_INT 0
42669: PUSH
42670: EMPTY
42671: LIST
42672: LIST
42673: PUSH
42674: LD_INT 6
42676: NEG
42677: PUSH
42678: LD_INT 1
42680: NEG
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: LIST
42690: LIST
42691: LIST
42692: LIST
42693: LIST
42694: LIST
42695: LIST
42696: LIST
42697: LIST
42698: LIST
42699: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42700: LD_ADDR_VAR 0 34
42704: PUSH
42705: LD_INT 2
42707: NEG
42708: PUSH
42709: LD_INT 3
42711: NEG
42712: PUSH
42713: EMPTY
42714: LIST
42715: LIST
42716: PUSH
42717: LD_INT 3
42719: NEG
42720: PUSH
42721: LD_INT 2
42723: NEG
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: PUSH
42729: LD_INT 3
42731: NEG
42732: PUSH
42733: LD_INT 3
42735: NEG
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 3
42743: NEG
42744: PUSH
42745: LD_INT 4
42747: NEG
42748: PUSH
42749: EMPTY
42750: LIST
42751: LIST
42752: PUSH
42753: LD_INT 4
42755: NEG
42756: PUSH
42757: LD_INT 3
42759: NEG
42760: PUSH
42761: EMPTY
42762: LIST
42763: LIST
42764: PUSH
42765: LD_INT 4
42767: NEG
42768: PUSH
42769: LD_INT 4
42771: NEG
42772: PUSH
42773: EMPTY
42774: LIST
42775: LIST
42776: PUSH
42777: LD_INT 4
42779: NEG
42780: PUSH
42781: LD_INT 5
42783: NEG
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PUSH
42789: LD_INT 5
42791: NEG
42792: PUSH
42793: LD_INT 4
42795: NEG
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: PUSH
42801: LD_INT 5
42803: NEG
42804: PUSH
42805: LD_INT 5
42807: NEG
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 5
42815: NEG
42816: PUSH
42817: LD_INT 6
42819: NEG
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 6
42827: NEG
42828: PUSH
42829: LD_INT 5
42831: NEG
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: LD_INT 6
42839: NEG
42840: PUSH
42841: LD_INT 6
42843: NEG
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: EMPTY
42850: LIST
42851: LIST
42852: LIST
42853: LIST
42854: LIST
42855: LIST
42856: LIST
42857: LIST
42858: LIST
42859: LIST
42860: LIST
42861: LIST
42862: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42863: LD_ADDR_VAR 0 41
42867: PUSH
42868: LD_INT 0
42870: PUSH
42871: LD_INT 2
42873: NEG
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: PUSH
42879: LD_INT 1
42881: NEG
42882: PUSH
42883: LD_INT 3
42885: NEG
42886: PUSH
42887: EMPTY
42888: LIST
42889: LIST
42890: PUSH
42891: LD_INT 1
42893: PUSH
42894: LD_INT 2
42896: NEG
42897: PUSH
42898: EMPTY
42899: LIST
42900: LIST
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: LIST
42906: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42907: LD_ADDR_VAR 0 42
42911: PUSH
42912: LD_INT 2
42914: PUSH
42915: LD_INT 0
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: PUSH
42922: LD_INT 2
42924: PUSH
42925: LD_INT 1
42927: NEG
42928: PUSH
42929: EMPTY
42930: LIST
42931: LIST
42932: PUSH
42933: LD_INT 3
42935: PUSH
42936: LD_INT 1
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: PUSH
42943: EMPTY
42944: LIST
42945: LIST
42946: LIST
42947: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42948: LD_ADDR_VAR 0 43
42952: PUSH
42953: LD_INT 2
42955: PUSH
42956: LD_INT 2
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: PUSH
42963: LD_INT 3
42965: PUSH
42966: LD_INT 2
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 2
42975: PUSH
42976: LD_INT 3
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: LIST
42987: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42988: LD_ADDR_VAR 0 44
42992: PUSH
42993: LD_INT 0
42995: PUSH
42996: LD_INT 2
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: LD_INT 1
43005: PUSH
43006: LD_INT 3
43008: PUSH
43009: EMPTY
43010: LIST
43011: LIST
43012: PUSH
43013: LD_INT 1
43015: NEG
43016: PUSH
43017: LD_INT 2
43019: PUSH
43020: EMPTY
43021: LIST
43022: LIST
43023: PUSH
43024: EMPTY
43025: LIST
43026: LIST
43027: LIST
43028: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43029: LD_ADDR_VAR 0 45
43033: PUSH
43034: LD_INT 2
43036: NEG
43037: PUSH
43038: LD_INT 0
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 2
43047: NEG
43048: PUSH
43049: LD_INT 1
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: PUSH
43056: LD_INT 3
43058: NEG
43059: PUSH
43060: LD_INT 1
43062: NEG
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: PUSH
43068: EMPTY
43069: LIST
43070: LIST
43071: LIST
43072: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43073: LD_ADDR_VAR 0 46
43077: PUSH
43078: LD_INT 2
43080: NEG
43081: PUSH
43082: LD_INT 2
43084: NEG
43085: PUSH
43086: EMPTY
43087: LIST
43088: LIST
43089: PUSH
43090: LD_INT 2
43092: NEG
43093: PUSH
43094: LD_INT 3
43096: NEG
43097: PUSH
43098: EMPTY
43099: LIST
43100: LIST
43101: PUSH
43102: LD_INT 3
43104: NEG
43105: PUSH
43106: LD_INT 2
43108: NEG
43109: PUSH
43110: EMPTY
43111: LIST
43112: LIST
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: LIST
43118: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43119: LD_ADDR_VAR 0 47
43123: PUSH
43124: LD_INT 2
43126: NEG
43127: PUSH
43128: LD_INT 3
43130: NEG
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: PUSH
43136: LD_INT 1
43138: NEG
43139: PUSH
43140: LD_INT 3
43142: NEG
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: PUSH
43148: EMPTY
43149: LIST
43150: LIST
43151: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43152: LD_ADDR_VAR 0 48
43156: PUSH
43157: LD_INT 1
43159: PUSH
43160: LD_INT 2
43162: NEG
43163: PUSH
43164: EMPTY
43165: LIST
43166: LIST
43167: PUSH
43168: LD_INT 2
43170: PUSH
43171: LD_INT 1
43173: NEG
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: EMPTY
43180: LIST
43181: LIST
43182: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43183: LD_ADDR_VAR 0 49
43187: PUSH
43188: LD_INT 3
43190: PUSH
43191: LD_INT 1
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: PUSH
43198: LD_INT 3
43200: PUSH
43201: LD_INT 2
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43212: LD_ADDR_VAR 0 50
43216: PUSH
43217: LD_INT 2
43219: PUSH
43220: LD_INT 3
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: LD_INT 1
43229: PUSH
43230: LD_INT 3
43232: PUSH
43233: EMPTY
43234: LIST
43235: LIST
43236: PUSH
43237: EMPTY
43238: LIST
43239: LIST
43240: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43241: LD_ADDR_VAR 0 51
43245: PUSH
43246: LD_INT 1
43248: NEG
43249: PUSH
43250: LD_INT 2
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: LD_INT 2
43259: NEG
43260: PUSH
43261: LD_INT 1
43263: PUSH
43264: EMPTY
43265: LIST
43266: LIST
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43272: LD_ADDR_VAR 0 52
43276: PUSH
43277: LD_INT 3
43279: NEG
43280: PUSH
43281: LD_INT 1
43283: NEG
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 3
43291: NEG
43292: PUSH
43293: LD_INT 2
43295: NEG
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: EMPTY
43302: LIST
43303: LIST
43304: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43305: LD_ADDR_VAR 0 53
43309: PUSH
43310: LD_INT 1
43312: NEG
43313: PUSH
43314: LD_INT 3
43316: NEG
43317: PUSH
43318: EMPTY
43319: LIST
43320: LIST
43321: PUSH
43322: LD_INT 0
43324: PUSH
43325: LD_INT 3
43327: NEG
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: PUSH
43333: LD_INT 1
43335: PUSH
43336: LD_INT 2
43338: NEG
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: LIST
43348: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43349: LD_ADDR_VAR 0 54
43353: PUSH
43354: LD_INT 2
43356: PUSH
43357: LD_INT 1
43359: NEG
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: PUSH
43365: LD_INT 3
43367: PUSH
43368: LD_INT 0
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 3
43377: PUSH
43378: LD_INT 1
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PUSH
43385: EMPTY
43386: LIST
43387: LIST
43388: LIST
43389: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43390: LD_ADDR_VAR 0 55
43394: PUSH
43395: LD_INT 3
43397: PUSH
43398: LD_INT 2
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: PUSH
43405: LD_INT 3
43407: PUSH
43408: LD_INT 3
43410: PUSH
43411: EMPTY
43412: LIST
43413: LIST
43414: PUSH
43415: LD_INT 2
43417: PUSH
43418: LD_INT 3
43420: PUSH
43421: EMPTY
43422: LIST
43423: LIST
43424: PUSH
43425: EMPTY
43426: LIST
43427: LIST
43428: LIST
43429: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43430: LD_ADDR_VAR 0 56
43434: PUSH
43435: LD_INT 1
43437: PUSH
43438: LD_INT 3
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PUSH
43445: LD_INT 0
43447: PUSH
43448: LD_INT 3
43450: PUSH
43451: EMPTY
43452: LIST
43453: LIST
43454: PUSH
43455: LD_INT 1
43457: NEG
43458: PUSH
43459: LD_INT 2
43461: PUSH
43462: EMPTY
43463: LIST
43464: LIST
43465: PUSH
43466: EMPTY
43467: LIST
43468: LIST
43469: LIST
43470: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43471: LD_ADDR_VAR 0 57
43475: PUSH
43476: LD_INT 2
43478: NEG
43479: PUSH
43480: LD_INT 1
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 3
43489: NEG
43490: PUSH
43491: LD_INT 0
43493: PUSH
43494: EMPTY
43495: LIST
43496: LIST
43497: PUSH
43498: LD_INT 3
43500: NEG
43501: PUSH
43502: LD_INT 1
43504: NEG
43505: PUSH
43506: EMPTY
43507: LIST
43508: LIST
43509: PUSH
43510: EMPTY
43511: LIST
43512: LIST
43513: LIST
43514: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43515: LD_ADDR_VAR 0 58
43519: PUSH
43520: LD_INT 2
43522: NEG
43523: PUSH
43524: LD_INT 3
43526: NEG
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 3
43534: NEG
43535: PUSH
43536: LD_INT 2
43538: NEG
43539: PUSH
43540: EMPTY
43541: LIST
43542: LIST
43543: PUSH
43544: LD_INT 3
43546: NEG
43547: PUSH
43548: LD_INT 3
43550: NEG
43551: PUSH
43552: EMPTY
43553: LIST
43554: LIST
43555: PUSH
43556: EMPTY
43557: LIST
43558: LIST
43559: LIST
43560: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43561: LD_ADDR_VAR 0 59
43565: PUSH
43566: LD_INT 1
43568: NEG
43569: PUSH
43570: LD_INT 2
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 0
43580: PUSH
43581: LD_INT 2
43583: NEG
43584: PUSH
43585: EMPTY
43586: LIST
43587: LIST
43588: PUSH
43589: LD_INT 1
43591: PUSH
43592: LD_INT 1
43594: NEG
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PUSH
43600: EMPTY
43601: LIST
43602: LIST
43603: LIST
43604: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43605: LD_ADDR_VAR 0 60
43609: PUSH
43610: LD_INT 1
43612: PUSH
43613: LD_INT 1
43615: NEG
43616: PUSH
43617: EMPTY
43618: LIST
43619: LIST
43620: PUSH
43621: LD_INT 2
43623: PUSH
43624: LD_INT 0
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 2
43633: PUSH
43634: LD_INT 1
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PUSH
43641: EMPTY
43642: LIST
43643: LIST
43644: LIST
43645: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43646: LD_ADDR_VAR 0 61
43650: PUSH
43651: LD_INT 2
43653: PUSH
43654: LD_INT 1
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: LD_INT 2
43663: PUSH
43664: LD_INT 2
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: LD_INT 1
43673: PUSH
43674: LD_INT 2
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: LIST
43685: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43686: LD_ADDR_VAR 0 62
43690: PUSH
43691: LD_INT 1
43693: PUSH
43694: LD_INT 2
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: PUSH
43701: LD_INT 0
43703: PUSH
43704: LD_INT 2
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: LD_INT 1
43713: NEG
43714: PUSH
43715: LD_INT 1
43717: PUSH
43718: EMPTY
43719: LIST
43720: LIST
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: LIST
43726: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43727: LD_ADDR_VAR 0 63
43731: PUSH
43732: LD_INT 1
43734: NEG
43735: PUSH
43736: LD_INT 1
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: PUSH
43743: LD_INT 2
43745: NEG
43746: PUSH
43747: LD_INT 0
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PUSH
43754: LD_INT 2
43756: NEG
43757: PUSH
43758: LD_INT 1
43760: NEG
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: LIST
43770: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43771: LD_ADDR_VAR 0 64
43775: PUSH
43776: LD_INT 1
43778: NEG
43779: PUSH
43780: LD_INT 2
43782: NEG
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PUSH
43788: LD_INT 2
43790: NEG
43791: PUSH
43792: LD_INT 1
43794: NEG
43795: PUSH
43796: EMPTY
43797: LIST
43798: LIST
43799: PUSH
43800: LD_INT 2
43802: NEG
43803: PUSH
43804: LD_INT 2
43806: NEG
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: PUSH
43812: EMPTY
43813: LIST
43814: LIST
43815: LIST
43816: ST_TO_ADDR
// end ; 2 :
43817: GO 47083
43819: LD_INT 2
43821: DOUBLE
43822: EQUAL
43823: IFTRUE 43827
43825: GO 47082
43827: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43828: LD_ADDR_VAR 0 29
43832: PUSH
43833: LD_INT 4
43835: PUSH
43836: LD_INT 0
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 4
43845: PUSH
43846: LD_INT 1
43848: NEG
43849: PUSH
43850: EMPTY
43851: LIST
43852: LIST
43853: PUSH
43854: LD_INT 5
43856: PUSH
43857: LD_INT 0
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: PUSH
43864: LD_INT 5
43866: PUSH
43867: LD_INT 1
43869: PUSH
43870: EMPTY
43871: LIST
43872: LIST
43873: PUSH
43874: LD_INT 4
43876: PUSH
43877: LD_INT 1
43879: PUSH
43880: EMPTY
43881: LIST
43882: LIST
43883: PUSH
43884: LD_INT 3
43886: PUSH
43887: LD_INT 0
43889: PUSH
43890: EMPTY
43891: LIST
43892: LIST
43893: PUSH
43894: LD_INT 3
43896: PUSH
43897: LD_INT 1
43899: NEG
43900: PUSH
43901: EMPTY
43902: LIST
43903: LIST
43904: PUSH
43905: LD_INT 3
43907: PUSH
43908: LD_INT 2
43910: NEG
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: PUSH
43916: LD_INT 5
43918: PUSH
43919: LD_INT 2
43921: PUSH
43922: EMPTY
43923: LIST
43924: LIST
43925: PUSH
43926: LD_INT 3
43928: PUSH
43929: LD_INT 3
43931: PUSH
43932: EMPTY
43933: LIST
43934: LIST
43935: PUSH
43936: LD_INT 3
43938: PUSH
43939: LD_INT 2
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: PUSH
43946: LD_INT 4
43948: PUSH
43949: LD_INT 3
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: PUSH
43956: LD_INT 4
43958: PUSH
43959: LD_INT 4
43961: PUSH
43962: EMPTY
43963: LIST
43964: LIST
43965: PUSH
43966: LD_INT 3
43968: PUSH
43969: LD_INT 4
43971: PUSH
43972: EMPTY
43973: LIST
43974: LIST
43975: PUSH
43976: LD_INT 2
43978: PUSH
43979: LD_INT 3
43981: PUSH
43982: EMPTY
43983: LIST
43984: LIST
43985: PUSH
43986: LD_INT 2
43988: PUSH
43989: LD_INT 2
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: LD_INT 4
43998: PUSH
43999: LD_INT 2
44001: PUSH
44002: EMPTY
44003: LIST
44004: LIST
44005: PUSH
44006: LD_INT 2
44008: PUSH
44009: LD_INT 4
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: LD_INT 0
44018: PUSH
44019: LD_INT 4
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: PUSH
44026: LD_INT 0
44028: PUSH
44029: LD_INT 3
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 1
44038: PUSH
44039: LD_INT 4
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PUSH
44046: LD_INT 1
44048: PUSH
44049: LD_INT 5
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 0
44058: PUSH
44059: LD_INT 5
44061: PUSH
44062: EMPTY
44063: LIST
44064: LIST
44065: PUSH
44066: LD_INT 1
44068: NEG
44069: PUSH
44070: LD_INT 4
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: PUSH
44077: LD_INT 1
44079: NEG
44080: PUSH
44081: LD_INT 3
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 2
44090: PUSH
44091: LD_INT 5
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 2
44100: NEG
44101: PUSH
44102: LD_INT 3
44104: PUSH
44105: EMPTY
44106: LIST
44107: LIST
44108: PUSH
44109: LD_INT 3
44111: NEG
44112: PUSH
44113: LD_INT 0
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PUSH
44120: LD_INT 3
44122: NEG
44123: PUSH
44124: LD_INT 1
44126: NEG
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: PUSH
44132: LD_INT 2
44134: NEG
44135: PUSH
44136: LD_INT 0
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PUSH
44143: LD_INT 2
44145: NEG
44146: PUSH
44147: LD_INT 1
44149: PUSH
44150: EMPTY
44151: LIST
44152: LIST
44153: PUSH
44154: LD_INT 3
44156: NEG
44157: PUSH
44158: LD_INT 1
44160: PUSH
44161: EMPTY
44162: LIST
44163: LIST
44164: PUSH
44165: LD_INT 4
44167: NEG
44168: PUSH
44169: LD_INT 0
44171: PUSH
44172: EMPTY
44173: LIST
44174: LIST
44175: PUSH
44176: LD_INT 4
44178: NEG
44179: PUSH
44180: LD_INT 1
44182: NEG
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: LD_INT 4
44190: NEG
44191: PUSH
44192: LD_INT 2
44194: NEG
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 2
44202: NEG
44203: PUSH
44204: LD_INT 2
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 4
44213: NEG
44214: PUSH
44215: LD_INT 4
44217: NEG
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 4
44225: NEG
44226: PUSH
44227: LD_INT 5
44229: NEG
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: LD_INT 3
44237: NEG
44238: PUSH
44239: LD_INT 4
44241: NEG
44242: PUSH
44243: EMPTY
44244: LIST
44245: LIST
44246: PUSH
44247: LD_INT 3
44249: NEG
44250: PUSH
44251: LD_INT 3
44253: NEG
44254: PUSH
44255: EMPTY
44256: LIST
44257: LIST
44258: PUSH
44259: LD_INT 4
44261: NEG
44262: PUSH
44263: LD_INT 3
44265: NEG
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 5
44273: NEG
44274: PUSH
44275: LD_INT 4
44277: NEG
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 5
44285: NEG
44286: PUSH
44287: LD_INT 5
44289: NEG
44290: PUSH
44291: EMPTY
44292: LIST
44293: LIST
44294: PUSH
44295: LD_INT 3
44297: NEG
44298: PUSH
44299: LD_INT 5
44301: NEG
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: PUSH
44307: LD_INT 5
44309: NEG
44310: PUSH
44311: LD_INT 3
44313: NEG
44314: PUSH
44315: EMPTY
44316: LIST
44317: LIST
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: LIST
44323: LIST
44324: LIST
44325: LIST
44326: LIST
44327: LIST
44328: LIST
44329: LIST
44330: LIST
44331: LIST
44332: LIST
44333: LIST
44334: LIST
44335: LIST
44336: LIST
44337: LIST
44338: LIST
44339: LIST
44340: LIST
44341: LIST
44342: LIST
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: LIST
44348: LIST
44349: LIST
44350: LIST
44351: LIST
44352: LIST
44353: LIST
44354: LIST
44355: LIST
44356: LIST
44357: LIST
44358: LIST
44359: LIST
44360: LIST
44361: LIST
44362: LIST
44363: LIST
44364: LIST
44365: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44366: LD_ADDR_VAR 0 30
44370: PUSH
44371: LD_INT 4
44373: PUSH
44374: LD_INT 4
44376: PUSH
44377: EMPTY
44378: LIST
44379: LIST
44380: PUSH
44381: LD_INT 4
44383: PUSH
44384: LD_INT 3
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 5
44393: PUSH
44394: LD_INT 4
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 5
44403: PUSH
44404: LD_INT 5
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: PUSH
44411: LD_INT 4
44413: PUSH
44414: LD_INT 5
44416: PUSH
44417: EMPTY
44418: LIST
44419: LIST
44420: PUSH
44421: LD_INT 3
44423: PUSH
44424: LD_INT 4
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: LD_INT 3
44433: PUSH
44434: LD_INT 3
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: PUSH
44441: LD_INT 5
44443: PUSH
44444: LD_INT 3
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 3
44453: PUSH
44454: LD_INT 5
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 0
44463: PUSH
44464: LD_INT 3
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 0
44473: PUSH
44474: LD_INT 2
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 1
44483: PUSH
44484: LD_INT 3
44486: PUSH
44487: EMPTY
44488: LIST
44489: LIST
44490: PUSH
44491: LD_INT 1
44493: PUSH
44494: LD_INT 4
44496: PUSH
44497: EMPTY
44498: LIST
44499: LIST
44500: PUSH
44501: LD_INT 0
44503: PUSH
44504: LD_INT 4
44506: PUSH
44507: EMPTY
44508: LIST
44509: LIST
44510: PUSH
44511: LD_INT 1
44513: NEG
44514: PUSH
44515: LD_INT 3
44517: PUSH
44518: EMPTY
44519: LIST
44520: LIST
44521: PUSH
44522: LD_INT 1
44524: NEG
44525: PUSH
44526: LD_INT 2
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: PUSH
44533: LD_INT 2
44535: PUSH
44536: LD_INT 4
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 2
44545: NEG
44546: PUSH
44547: LD_INT 2
44549: PUSH
44550: EMPTY
44551: LIST
44552: LIST
44553: PUSH
44554: LD_INT 4
44556: NEG
44557: PUSH
44558: LD_INT 0
44560: PUSH
44561: EMPTY
44562: LIST
44563: LIST
44564: PUSH
44565: LD_INT 4
44567: NEG
44568: PUSH
44569: LD_INT 1
44571: NEG
44572: PUSH
44573: EMPTY
44574: LIST
44575: LIST
44576: PUSH
44577: LD_INT 3
44579: NEG
44580: PUSH
44581: LD_INT 0
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: LD_INT 3
44590: NEG
44591: PUSH
44592: LD_INT 1
44594: PUSH
44595: EMPTY
44596: LIST
44597: LIST
44598: PUSH
44599: LD_INT 4
44601: NEG
44602: PUSH
44603: LD_INT 1
44605: PUSH
44606: EMPTY
44607: LIST
44608: LIST
44609: PUSH
44610: LD_INT 5
44612: NEG
44613: PUSH
44614: LD_INT 0
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 5
44623: NEG
44624: PUSH
44625: LD_INT 1
44627: NEG
44628: PUSH
44629: EMPTY
44630: LIST
44631: LIST
44632: PUSH
44633: LD_INT 5
44635: NEG
44636: PUSH
44637: LD_INT 2
44639: NEG
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 3
44647: NEG
44648: PUSH
44649: LD_INT 2
44651: PUSH
44652: EMPTY
44653: LIST
44654: LIST
44655: PUSH
44656: LD_INT 3
44658: NEG
44659: PUSH
44660: LD_INT 3
44662: NEG
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: LD_INT 3
44670: NEG
44671: PUSH
44672: LD_INT 4
44674: NEG
44675: PUSH
44676: EMPTY
44677: LIST
44678: LIST
44679: PUSH
44680: LD_INT 2
44682: NEG
44683: PUSH
44684: LD_INT 3
44686: NEG
44687: PUSH
44688: EMPTY
44689: LIST
44690: LIST
44691: PUSH
44692: LD_INT 2
44694: NEG
44695: PUSH
44696: LD_INT 2
44698: NEG
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: PUSH
44704: LD_INT 3
44706: NEG
44707: PUSH
44708: LD_INT 2
44710: NEG
44711: PUSH
44712: EMPTY
44713: LIST
44714: LIST
44715: PUSH
44716: LD_INT 4
44718: NEG
44719: PUSH
44720: LD_INT 3
44722: NEG
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 4
44730: NEG
44731: PUSH
44732: LD_INT 4
44734: NEG
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: LD_INT 2
44742: NEG
44743: PUSH
44744: LD_INT 4
44746: NEG
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: PUSH
44752: LD_INT 4
44754: NEG
44755: PUSH
44756: LD_INT 2
44758: NEG
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: PUSH
44764: LD_INT 0
44766: PUSH
44767: LD_INT 4
44769: NEG
44770: PUSH
44771: EMPTY
44772: LIST
44773: LIST
44774: PUSH
44775: LD_INT 0
44777: PUSH
44778: LD_INT 5
44780: NEG
44781: PUSH
44782: EMPTY
44783: LIST
44784: LIST
44785: PUSH
44786: LD_INT 1
44788: PUSH
44789: LD_INT 4
44791: NEG
44792: PUSH
44793: EMPTY
44794: LIST
44795: LIST
44796: PUSH
44797: LD_INT 1
44799: PUSH
44800: LD_INT 3
44802: NEG
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: PUSH
44808: LD_INT 0
44810: PUSH
44811: LD_INT 3
44813: NEG
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PUSH
44819: LD_INT 1
44821: NEG
44822: PUSH
44823: LD_INT 4
44825: NEG
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 1
44833: NEG
44834: PUSH
44835: LD_INT 5
44837: NEG
44838: PUSH
44839: EMPTY
44840: LIST
44841: LIST
44842: PUSH
44843: LD_INT 2
44845: PUSH
44846: LD_INT 3
44848: NEG
44849: PUSH
44850: EMPTY
44851: LIST
44852: LIST
44853: PUSH
44854: LD_INT 2
44856: NEG
44857: PUSH
44858: LD_INT 5
44860: NEG
44861: PUSH
44862: EMPTY
44863: LIST
44864: LIST
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: LIST
44870: LIST
44871: LIST
44872: LIST
44873: LIST
44874: LIST
44875: LIST
44876: LIST
44877: LIST
44878: LIST
44879: LIST
44880: LIST
44881: LIST
44882: LIST
44883: LIST
44884: LIST
44885: LIST
44886: LIST
44887: LIST
44888: LIST
44889: LIST
44890: LIST
44891: LIST
44892: LIST
44893: LIST
44894: LIST
44895: LIST
44896: LIST
44897: LIST
44898: LIST
44899: LIST
44900: LIST
44901: LIST
44902: LIST
44903: LIST
44904: LIST
44905: LIST
44906: LIST
44907: LIST
44908: LIST
44909: LIST
44910: LIST
44911: LIST
44912: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44913: LD_ADDR_VAR 0 31
44917: PUSH
44918: LD_INT 0
44920: PUSH
44921: LD_INT 4
44923: PUSH
44924: EMPTY
44925: LIST
44926: LIST
44927: PUSH
44928: LD_INT 0
44930: PUSH
44931: LD_INT 3
44933: PUSH
44934: EMPTY
44935: LIST
44936: LIST
44937: PUSH
44938: LD_INT 1
44940: PUSH
44941: LD_INT 4
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: PUSH
44948: LD_INT 1
44950: PUSH
44951: LD_INT 5
44953: PUSH
44954: EMPTY
44955: LIST
44956: LIST
44957: PUSH
44958: LD_INT 0
44960: PUSH
44961: LD_INT 5
44963: PUSH
44964: EMPTY
44965: LIST
44966: LIST
44967: PUSH
44968: LD_INT 1
44970: NEG
44971: PUSH
44972: LD_INT 4
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: PUSH
44979: LD_INT 1
44981: NEG
44982: PUSH
44983: LD_INT 3
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PUSH
44990: LD_INT 2
44992: PUSH
44993: LD_INT 5
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: PUSH
45000: LD_INT 2
45002: NEG
45003: PUSH
45004: LD_INT 3
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 3
45013: NEG
45014: PUSH
45015: LD_INT 0
45017: PUSH
45018: EMPTY
45019: LIST
45020: LIST
45021: PUSH
45022: LD_INT 3
45024: NEG
45025: PUSH
45026: LD_INT 1
45028: NEG
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 2
45036: NEG
45037: PUSH
45038: LD_INT 0
45040: PUSH
45041: EMPTY
45042: LIST
45043: LIST
45044: PUSH
45045: LD_INT 2
45047: NEG
45048: PUSH
45049: LD_INT 1
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 3
45058: NEG
45059: PUSH
45060: LD_INT 1
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: LD_INT 4
45069: NEG
45070: PUSH
45071: LD_INT 0
45073: PUSH
45074: EMPTY
45075: LIST
45076: LIST
45077: PUSH
45078: LD_INT 4
45080: NEG
45081: PUSH
45082: LD_INT 1
45084: NEG
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: PUSH
45090: LD_INT 4
45092: NEG
45093: PUSH
45094: LD_INT 2
45096: NEG
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: PUSH
45102: LD_INT 2
45104: NEG
45105: PUSH
45106: LD_INT 2
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: PUSH
45113: LD_INT 4
45115: NEG
45116: PUSH
45117: LD_INT 4
45119: NEG
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: PUSH
45125: LD_INT 4
45127: NEG
45128: PUSH
45129: LD_INT 5
45131: NEG
45132: PUSH
45133: EMPTY
45134: LIST
45135: LIST
45136: PUSH
45137: LD_INT 3
45139: NEG
45140: PUSH
45141: LD_INT 4
45143: NEG
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: LD_INT 3
45151: NEG
45152: PUSH
45153: LD_INT 3
45155: NEG
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: PUSH
45161: LD_INT 4
45163: NEG
45164: PUSH
45165: LD_INT 3
45167: NEG
45168: PUSH
45169: EMPTY
45170: LIST
45171: LIST
45172: PUSH
45173: LD_INT 5
45175: NEG
45176: PUSH
45177: LD_INT 4
45179: NEG
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 5
45187: NEG
45188: PUSH
45189: LD_INT 5
45191: NEG
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: LD_INT 3
45199: NEG
45200: PUSH
45201: LD_INT 5
45203: NEG
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 5
45211: NEG
45212: PUSH
45213: LD_INT 3
45215: NEG
45216: PUSH
45217: EMPTY
45218: LIST
45219: LIST
45220: PUSH
45221: LD_INT 0
45223: PUSH
45224: LD_INT 3
45226: NEG
45227: PUSH
45228: EMPTY
45229: LIST
45230: LIST
45231: PUSH
45232: LD_INT 0
45234: PUSH
45235: LD_INT 4
45237: NEG
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: PUSH
45243: LD_INT 1
45245: PUSH
45246: LD_INT 3
45248: NEG
45249: PUSH
45250: EMPTY
45251: LIST
45252: LIST
45253: PUSH
45254: LD_INT 1
45256: PUSH
45257: LD_INT 2
45259: NEG
45260: PUSH
45261: EMPTY
45262: LIST
45263: LIST
45264: PUSH
45265: LD_INT 0
45267: PUSH
45268: LD_INT 2
45270: NEG
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 1
45278: NEG
45279: PUSH
45280: LD_INT 3
45282: NEG
45283: PUSH
45284: EMPTY
45285: LIST
45286: LIST
45287: PUSH
45288: LD_INT 1
45290: NEG
45291: PUSH
45292: LD_INT 4
45294: NEG
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: PUSH
45300: LD_INT 2
45302: PUSH
45303: LD_INT 2
45305: NEG
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: PUSH
45311: LD_INT 2
45313: NEG
45314: PUSH
45315: LD_INT 4
45317: NEG
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: PUSH
45323: LD_INT 4
45325: PUSH
45326: LD_INT 0
45328: PUSH
45329: EMPTY
45330: LIST
45331: LIST
45332: PUSH
45333: LD_INT 4
45335: PUSH
45336: LD_INT 1
45338: NEG
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PUSH
45344: LD_INT 5
45346: PUSH
45347: LD_INT 0
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PUSH
45354: LD_INT 5
45356: PUSH
45357: LD_INT 1
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 4
45366: PUSH
45367: LD_INT 1
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: PUSH
45374: LD_INT 3
45376: PUSH
45377: LD_INT 0
45379: PUSH
45380: EMPTY
45381: LIST
45382: LIST
45383: PUSH
45384: LD_INT 3
45386: PUSH
45387: LD_INT 1
45389: NEG
45390: PUSH
45391: EMPTY
45392: LIST
45393: LIST
45394: PUSH
45395: LD_INT 3
45397: PUSH
45398: LD_INT 2
45400: NEG
45401: PUSH
45402: EMPTY
45403: LIST
45404: LIST
45405: PUSH
45406: LD_INT 5
45408: PUSH
45409: LD_INT 2
45411: PUSH
45412: EMPTY
45413: LIST
45414: LIST
45415: PUSH
45416: EMPTY
45417: LIST
45418: LIST
45419: LIST
45420: LIST
45421: LIST
45422: LIST
45423: LIST
45424: LIST
45425: LIST
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: LIST
45433: LIST
45434: LIST
45435: LIST
45436: LIST
45437: LIST
45438: LIST
45439: LIST
45440: LIST
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: LIST
45451: LIST
45452: LIST
45453: LIST
45454: LIST
45455: LIST
45456: LIST
45457: LIST
45458: LIST
45459: LIST
45460: LIST
45461: LIST
45462: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45463: LD_ADDR_VAR 0 32
45467: PUSH
45468: LD_INT 4
45470: NEG
45471: PUSH
45472: LD_INT 0
45474: PUSH
45475: EMPTY
45476: LIST
45477: LIST
45478: PUSH
45479: LD_INT 4
45481: NEG
45482: PUSH
45483: LD_INT 1
45485: NEG
45486: PUSH
45487: EMPTY
45488: LIST
45489: LIST
45490: PUSH
45491: LD_INT 3
45493: NEG
45494: PUSH
45495: LD_INT 0
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: PUSH
45502: LD_INT 3
45504: NEG
45505: PUSH
45506: LD_INT 1
45508: PUSH
45509: EMPTY
45510: LIST
45511: LIST
45512: PUSH
45513: LD_INT 4
45515: NEG
45516: PUSH
45517: LD_INT 1
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: PUSH
45524: LD_INT 5
45526: NEG
45527: PUSH
45528: LD_INT 0
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: PUSH
45535: LD_INT 5
45537: NEG
45538: PUSH
45539: LD_INT 1
45541: NEG
45542: PUSH
45543: EMPTY
45544: LIST
45545: LIST
45546: PUSH
45547: LD_INT 5
45549: NEG
45550: PUSH
45551: LD_INT 2
45553: NEG
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 3
45561: NEG
45562: PUSH
45563: LD_INT 2
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: PUSH
45570: LD_INT 3
45572: NEG
45573: PUSH
45574: LD_INT 3
45576: NEG
45577: PUSH
45578: EMPTY
45579: LIST
45580: LIST
45581: PUSH
45582: LD_INT 3
45584: NEG
45585: PUSH
45586: LD_INT 4
45588: NEG
45589: PUSH
45590: EMPTY
45591: LIST
45592: LIST
45593: PUSH
45594: LD_INT 2
45596: NEG
45597: PUSH
45598: LD_INT 3
45600: NEG
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: PUSH
45606: LD_INT 2
45608: NEG
45609: PUSH
45610: LD_INT 2
45612: NEG
45613: PUSH
45614: EMPTY
45615: LIST
45616: LIST
45617: PUSH
45618: LD_INT 3
45620: NEG
45621: PUSH
45622: LD_INT 2
45624: NEG
45625: PUSH
45626: EMPTY
45627: LIST
45628: LIST
45629: PUSH
45630: LD_INT 4
45632: NEG
45633: PUSH
45634: LD_INT 3
45636: NEG
45637: PUSH
45638: EMPTY
45639: LIST
45640: LIST
45641: PUSH
45642: LD_INT 4
45644: NEG
45645: PUSH
45646: LD_INT 4
45648: NEG
45649: PUSH
45650: EMPTY
45651: LIST
45652: LIST
45653: PUSH
45654: LD_INT 2
45656: NEG
45657: PUSH
45658: LD_INT 4
45660: NEG
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PUSH
45666: LD_INT 4
45668: NEG
45669: PUSH
45670: LD_INT 2
45672: NEG
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: PUSH
45678: LD_INT 0
45680: PUSH
45681: LD_INT 4
45683: NEG
45684: PUSH
45685: EMPTY
45686: LIST
45687: LIST
45688: PUSH
45689: LD_INT 0
45691: PUSH
45692: LD_INT 5
45694: NEG
45695: PUSH
45696: EMPTY
45697: LIST
45698: LIST
45699: PUSH
45700: LD_INT 1
45702: PUSH
45703: LD_INT 4
45705: NEG
45706: PUSH
45707: EMPTY
45708: LIST
45709: LIST
45710: PUSH
45711: LD_INT 1
45713: PUSH
45714: LD_INT 3
45716: NEG
45717: PUSH
45718: EMPTY
45719: LIST
45720: LIST
45721: PUSH
45722: LD_INT 0
45724: PUSH
45725: LD_INT 3
45727: NEG
45728: PUSH
45729: EMPTY
45730: LIST
45731: LIST
45732: PUSH
45733: LD_INT 1
45735: NEG
45736: PUSH
45737: LD_INT 4
45739: NEG
45740: PUSH
45741: EMPTY
45742: LIST
45743: LIST
45744: PUSH
45745: LD_INT 1
45747: NEG
45748: PUSH
45749: LD_INT 5
45751: NEG
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PUSH
45757: LD_INT 2
45759: PUSH
45760: LD_INT 3
45762: NEG
45763: PUSH
45764: EMPTY
45765: LIST
45766: LIST
45767: PUSH
45768: LD_INT 2
45770: NEG
45771: PUSH
45772: LD_INT 5
45774: NEG
45775: PUSH
45776: EMPTY
45777: LIST
45778: LIST
45779: PUSH
45780: LD_INT 3
45782: PUSH
45783: LD_INT 0
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: PUSH
45790: LD_INT 3
45792: PUSH
45793: LD_INT 1
45795: NEG
45796: PUSH
45797: EMPTY
45798: LIST
45799: LIST
45800: PUSH
45801: LD_INT 4
45803: PUSH
45804: LD_INT 0
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 4
45813: PUSH
45814: LD_INT 1
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 3
45823: PUSH
45824: LD_INT 1
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 2
45833: PUSH
45834: LD_INT 0
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: LD_INT 2
45843: PUSH
45844: LD_INT 1
45846: NEG
45847: PUSH
45848: EMPTY
45849: LIST
45850: LIST
45851: PUSH
45852: LD_INT 2
45854: PUSH
45855: LD_INT 2
45857: NEG
45858: PUSH
45859: EMPTY
45860: LIST
45861: LIST
45862: PUSH
45863: LD_INT 4
45865: PUSH
45866: LD_INT 2
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: PUSH
45873: LD_INT 4
45875: PUSH
45876: LD_INT 4
45878: PUSH
45879: EMPTY
45880: LIST
45881: LIST
45882: PUSH
45883: LD_INT 4
45885: PUSH
45886: LD_INT 3
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: PUSH
45893: LD_INT 5
45895: PUSH
45896: LD_INT 4
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: PUSH
45903: LD_INT 5
45905: PUSH
45906: LD_INT 5
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 4
45915: PUSH
45916: LD_INT 5
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: PUSH
45923: LD_INT 3
45925: PUSH
45926: LD_INT 4
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 3
45935: PUSH
45936: LD_INT 3
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: PUSH
45943: LD_INT 5
45945: PUSH
45946: LD_INT 3
45948: PUSH
45949: EMPTY
45950: LIST
45951: LIST
45952: PUSH
45953: LD_INT 3
45955: PUSH
45956: LD_INT 5
45958: PUSH
45959: EMPTY
45960: LIST
45961: LIST
45962: PUSH
45963: EMPTY
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46010: LD_ADDR_VAR 0 33
46014: PUSH
46015: LD_INT 4
46017: NEG
46018: PUSH
46019: LD_INT 4
46021: NEG
46022: PUSH
46023: EMPTY
46024: LIST
46025: LIST
46026: PUSH
46027: LD_INT 4
46029: NEG
46030: PUSH
46031: LD_INT 5
46033: NEG
46034: PUSH
46035: EMPTY
46036: LIST
46037: LIST
46038: PUSH
46039: LD_INT 3
46041: NEG
46042: PUSH
46043: LD_INT 4
46045: NEG
46046: PUSH
46047: EMPTY
46048: LIST
46049: LIST
46050: PUSH
46051: LD_INT 3
46053: NEG
46054: PUSH
46055: LD_INT 3
46057: NEG
46058: PUSH
46059: EMPTY
46060: LIST
46061: LIST
46062: PUSH
46063: LD_INT 4
46065: NEG
46066: PUSH
46067: LD_INT 3
46069: NEG
46070: PUSH
46071: EMPTY
46072: LIST
46073: LIST
46074: PUSH
46075: LD_INT 5
46077: NEG
46078: PUSH
46079: LD_INT 4
46081: NEG
46082: PUSH
46083: EMPTY
46084: LIST
46085: LIST
46086: PUSH
46087: LD_INT 5
46089: NEG
46090: PUSH
46091: LD_INT 5
46093: NEG
46094: PUSH
46095: EMPTY
46096: LIST
46097: LIST
46098: PUSH
46099: LD_INT 3
46101: NEG
46102: PUSH
46103: LD_INT 5
46105: NEG
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 5
46113: NEG
46114: PUSH
46115: LD_INT 3
46117: NEG
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 0
46125: PUSH
46126: LD_INT 3
46128: NEG
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: LD_INT 0
46136: PUSH
46137: LD_INT 4
46139: NEG
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: LD_INT 1
46147: PUSH
46148: LD_INT 3
46150: NEG
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PUSH
46156: LD_INT 1
46158: PUSH
46159: LD_INT 2
46161: NEG
46162: PUSH
46163: EMPTY
46164: LIST
46165: LIST
46166: PUSH
46167: LD_INT 0
46169: PUSH
46170: LD_INT 2
46172: NEG
46173: PUSH
46174: EMPTY
46175: LIST
46176: LIST
46177: PUSH
46178: LD_INT 1
46180: NEG
46181: PUSH
46182: LD_INT 3
46184: NEG
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: PUSH
46190: LD_INT 1
46192: NEG
46193: PUSH
46194: LD_INT 4
46196: NEG
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: PUSH
46202: LD_INT 2
46204: PUSH
46205: LD_INT 2
46207: NEG
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: LD_INT 2
46215: NEG
46216: PUSH
46217: LD_INT 4
46219: NEG
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 4
46227: PUSH
46228: LD_INT 0
46230: PUSH
46231: EMPTY
46232: LIST
46233: LIST
46234: PUSH
46235: LD_INT 4
46237: PUSH
46238: LD_INT 1
46240: NEG
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 5
46248: PUSH
46249: LD_INT 0
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 5
46258: PUSH
46259: LD_INT 1
46261: PUSH
46262: EMPTY
46263: LIST
46264: LIST
46265: PUSH
46266: LD_INT 4
46268: PUSH
46269: LD_INT 1
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: LD_INT 3
46278: PUSH
46279: LD_INT 0
46281: PUSH
46282: EMPTY
46283: LIST
46284: LIST
46285: PUSH
46286: LD_INT 3
46288: PUSH
46289: LD_INT 1
46291: NEG
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: PUSH
46297: LD_INT 3
46299: PUSH
46300: LD_INT 2
46302: NEG
46303: PUSH
46304: EMPTY
46305: LIST
46306: LIST
46307: PUSH
46308: LD_INT 5
46310: PUSH
46311: LD_INT 2
46313: PUSH
46314: EMPTY
46315: LIST
46316: LIST
46317: PUSH
46318: LD_INT 3
46320: PUSH
46321: LD_INT 3
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: PUSH
46328: LD_INT 3
46330: PUSH
46331: LD_INT 2
46333: PUSH
46334: EMPTY
46335: LIST
46336: LIST
46337: PUSH
46338: LD_INT 4
46340: PUSH
46341: LD_INT 3
46343: PUSH
46344: EMPTY
46345: LIST
46346: LIST
46347: PUSH
46348: LD_INT 4
46350: PUSH
46351: LD_INT 4
46353: PUSH
46354: EMPTY
46355: LIST
46356: LIST
46357: PUSH
46358: LD_INT 3
46360: PUSH
46361: LD_INT 4
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 2
46370: PUSH
46371: LD_INT 3
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PUSH
46378: LD_INT 2
46380: PUSH
46381: LD_INT 2
46383: PUSH
46384: EMPTY
46385: LIST
46386: LIST
46387: PUSH
46388: LD_INT 4
46390: PUSH
46391: LD_INT 2
46393: PUSH
46394: EMPTY
46395: LIST
46396: LIST
46397: PUSH
46398: LD_INT 2
46400: PUSH
46401: LD_INT 4
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: PUSH
46408: LD_INT 0
46410: PUSH
46411: LD_INT 4
46413: PUSH
46414: EMPTY
46415: LIST
46416: LIST
46417: PUSH
46418: LD_INT 0
46420: PUSH
46421: LD_INT 3
46423: PUSH
46424: EMPTY
46425: LIST
46426: LIST
46427: PUSH
46428: LD_INT 1
46430: PUSH
46431: LD_INT 4
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: LD_INT 1
46440: PUSH
46441: LD_INT 5
46443: PUSH
46444: EMPTY
46445: LIST
46446: LIST
46447: PUSH
46448: LD_INT 0
46450: PUSH
46451: LD_INT 5
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: PUSH
46458: LD_INT 1
46460: NEG
46461: PUSH
46462: LD_INT 4
46464: PUSH
46465: EMPTY
46466: LIST
46467: LIST
46468: PUSH
46469: LD_INT 1
46471: NEG
46472: PUSH
46473: LD_INT 3
46475: PUSH
46476: EMPTY
46477: LIST
46478: LIST
46479: PUSH
46480: LD_INT 2
46482: PUSH
46483: LD_INT 5
46485: PUSH
46486: EMPTY
46487: LIST
46488: LIST
46489: PUSH
46490: LD_INT 2
46492: NEG
46493: PUSH
46494: LD_INT 3
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: PUSH
46501: EMPTY
46502: LIST
46503: LIST
46504: LIST
46505: LIST
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: LIST
46519: LIST
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46548: LD_ADDR_VAR 0 34
46552: PUSH
46553: LD_INT 0
46555: PUSH
46556: LD_INT 4
46558: NEG
46559: PUSH
46560: EMPTY
46561: LIST
46562: LIST
46563: PUSH
46564: LD_INT 0
46566: PUSH
46567: LD_INT 5
46569: NEG
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: PUSH
46575: LD_INT 1
46577: PUSH
46578: LD_INT 4
46580: NEG
46581: PUSH
46582: EMPTY
46583: LIST
46584: LIST
46585: PUSH
46586: LD_INT 1
46588: PUSH
46589: LD_INT 3
46591: NEG
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: PUSH
46597: LD_INT 0
46599: PUSH
46600: LD_INT 3
46602: NEG
46603: PUSH
46604: EMPTY
46605: LIST
46606: LIST
46607: PUSH
46608: LD_INT 1
46610: NEG
46611: PUSH
46612: LD_INT 4
46614: NEG
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: PUSH
46620: LD_INT 1
46622: NEG
46623: PUSH
46624: LD_INT 5
46626: NEG
46627: PUSH
46628: EMPTY
46629: LIST
46630: LIST
46631: PUSH
46632: LD_INT 2
46634: PUSH
46635: LD_INT 3
46637: NEG
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: PUSH
46643: LD_INT 2
46645: NEG
46646: PUSH
46647: LD_INT 5
46649: NEG
46650: PUSH
46651: EMPTY
46652: LIST
46653: LIST
46654: PUSH
46655: LD_INT 3
46657: PUSH
46658: LD_INT 0
46660: PUSH
46661: EMPTY
46662: LIST
46663: LIST
46664: PUSH
46665: LD_INT 3
46667: PUSH
46668: LD_INT 1
46670: NEG
46671: PUSH
46672: EMPTY
46673: LIST
46674: LIST
46675: PUSH
46676: LD_INT 4
46678: PUSH
46679: LD_INT 0
46681: PUSH
46682: EMPTY
46683: LIST
46684: LIST
46685: PUSH
46686: LD_INT 4
46688: PUSH
46689: LD_INT 1
46691: PUSH
46692: EMPTY
46693: LIST
46694: LIST
46695: PUSH
46696: LD_INT 3
46698: PUSH
46699: LD_INT 1
46701: PUSH
46702: EMPTY
46703: LIST
46704: LIST
46705: PUSH
46706: LD_INT 2
46708: PUSH
46709: LD_INT 0
46711: PUSH
46712: EMPTY
46713: LIST
46714: LIST
46715: PUSH
46716: LD_INT 2
46718: PUSH
46719: LD_INT 1
46721: NEG
46722: PUSH
46723: EMPTY
46724: LIST
46725: LIST
46726: PUSH
46727: LD_INT 2
46729: PUSH
46730: LD_INT 2
46732: NEG
46733: PUSH
46734: EMPTY
46735: LIST
46736: LIST
46737: PUSH
46738: LD_INT 4
46740: PUSH
46741: LD_INT 2
46743: PUSH
46744: EMPTY
46745: LIST
46746: LIST
46747: PUSH
46748: LD_INT 4
46750: PUSH
46751: LD_INT 4
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: PUSH
46758: LD_INT 4
46760: PUSH
46761: LD_INT 3
46763: PUSH
46764: EMPTY
46765: LIST
46766: LIST
46767: PUSH
46768: LD_INT 5
46770: PUSH
46771: LD_INT 4
46773: PUSH
46774: EMPTY
46775: LIST
46776: LIST
46777: PUSH
46778: LD_INT 5
46780: PUSH
46781: LD_INT 5
46783: PUSH
46784: EMPTY
46785: LIST
46786: LIST
46787: PUSH
46788: LD_INT 4
46790: PUSH
46791: LD_INT 5
46793: PUSH
46794: EMPTY
46795: LIST
46796: LIST
46797: PUSH
46798: LD_INT 3
46800: PUSH
46801: LD_INT 4
46803: PUSH
46804: EMPTY
46805: LIST
46806: LIST
46807: PUSH
46808: LD_INT 3
46810: PUSH
46811: LD_INT 3
46813: PUSH
46814: EMPTY
46815: LIST
46816: LIST
46817: PUSH
46818: LD_INT 5
46820: PUSH
46821: LD_INT 3
46823: PUSH
46824: EMPTY
46825: LIST
46826: LIST
46827: PUSH
46828: LD_INT 3
46830: PUSH
46831: LD_INT 5
46833: PUSH
46834: EMPTY
46835: LIST
46836: LIST
46837: PUSH
46838: LD_INT 0
46840: PUSH
46841: LD_INT 3
46843: PUSH
46844: EMPTY
46845: LIST
46846: LIST
46847: PUSH
46848: LD_INT 0
46850: PUSH
46851: LD_INT 2
46853: PUSH
46854: EMPTY
46855: LIST
46856: LIST
46857: PUSH
46858: LD_INT 1
46860: PUSH
46861: LD_INT 3
46863: PUSH
46864: EMPTY
46865: LIST
46866: LIST
46867: PUSH
46868: LD_INT 1
46870: PUSH
46871: LD_INT 4
46873: PUSH
46874: EMPTY
46875: LIST
46876: LIST
46877: PUSH
46878: LD_INT 0
46880: PUSH
46881: LD_INT 4
46883: PUSH
46884: EMPTY
46885: LIST
46886: LIST
46887: PUSH
46888: LD_INT 1
46890: NEG
46891: PUSH
46892: LD_INT 3
46894: PUSH
46895: EMPTY
46896: LIST
46897: LIST
46898: PUSH
46899: LD_INT 1
46901: NEG
46902: PUSH
46903: LD_INT 2
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: PUSH
46910: LD_INT 2
46912: PUSH
46913: LD_INT 4
46915: PUSH
46916: EMPTY
46917: LIST
46918: LIST
46919: PUSH
46920: LD_INT 2
46922: NEG
46923: PUSH
46924: LD_INT 2
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: PUSH
46931: LD_INT 4
46933: NEG
46934: PUSH
46935: LD_INT 0
46937: PUSH
46938: EMPTY
46939: LIST
46940: LIST
46941: PUSH
46942: LD_INT 4
46944: NEG
46945: PUSH
46946: LD_INT 1
46948: NEG
46949: PUSH
46950: EMPTY
46951: LIST
46952: LIST
46953: PUSH
46954: LD_INT 3
46956: NEG
46957: PUSH
46958: LD_INT 0
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: PUSH
46965: LD_INT 3
46967: NEG
46968: PUSH
46969: LD_INT 1
46971: PUSH
46972: EMPTY
46973: LIST
46974: LIST
46975: PUSH
46976: LD_INT 4
46978: NEG
46979: PUSH
46980: LD_INT 1
46982: PUSH
46983: EMPTY
46984: LIST
46985: LIST
46986: PUSH
46987: LD_INT 5
46989: NEG
46990: PUSH
46991: LD_INT 0
46993: PUSH
46994: EMPTY
46995: LIST
46996: LIST
46997: PUSH
46998: LD_INT 5
47000: NEG
47001: PUSH
47002: LD_INT 1
47004: NEG
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 5
47012: NEG
47013: PUSH
47014: LD_INT 2
47016: NEG
47017: PUSH
47018: EMPTY
47019: LIST
47020: LIST
47021: PUSH
47022: LD_INT 3
47024: NEG
47025: PUSH
47026: LD_INT 2
47028: PUSH
47029: EMPTY
47030: LIST
47031: LIST
47032: PUSH
47033: EMPTY
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: LIST
47067: LIST
47068: LIST
47069: LIST
47070: LIST
47071: LIST
47072: LIST
47073: LIST
47074: LIST
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: ST_TO_ADDR
// end ; end ;
47080: GO 47083
47082: POP
// case btype of b_depot , b_warehouse :
47083: LD_VAR 0 1
47087: PUSH
47088: LD_INT 0
47090: DOUBLE
47091: EQUAL
47092: IFTRUE 47102
47094: LD_INT 1
47096: DOUBLE
47097: EQUAL
47098: IFTRUE 47102
47100: GO 47303
47102: POP
// case nation of nation_american :
47103: LD_VAR 0 5
47107: PUSH
47108: LD_INT 1
47110: DOUBLE
47111: EQUAL
47112: IFTRUE 47116
47114: GO 47172
47116: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
47117: LD_ADDR_VAR 0 9
47121: PUSH
47122: LD_VAR 0 11
47126: PUSH
47127: LD_VAR 0 12
47131: PUSH
47132: LD_VAR 0 13
47136: PUSH
47137: LD_VAR 0 14
47141: PUSH
47142: LD_VAR 0 15
47146: PUSH
47147: LD_VAR 0 16
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: LIST
47156: LIST
47157: LIST
47158: LIST
47159: PUSH
47160: LD_VAR 0 4
47164: PUSH
47165: LD_INT 1
47167: PLUS
47168: ARRAY
47169: ST_TO_ADDR
47170: GO 47301
47172: LD_INT 2
47174: DOUBLE
47175: EQUAL
47176: IFTRUE 47180
47178: GO 47236
47180: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
47181: LD_ADDR_VAR 0 9
47185: PUSH
47186: LD_VAR 0 17
47190: PUSH
47191: LD_VAR 0 18
47195: PUSH
47196: LD_VAR 0 19
47200: PUSH
47201: LD_VAR 0 20
47205: PUSH
47206: LD_VAR 0 21
47210: PUSH
47211: LD_VAR 0 22
47215: PUSH
47216: EMPTY
47217: LIST
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: PUSH
47224: LD_VAR 0 4
47228: PUSH
47229: LD_INT 1
47231: PLUS
47232: ARRAY
47233: ST_TO_ADDR
47234: GO 47301
47236: LD_INT 3
47238: DOUBLE
47239: EQUAL
47240: IFTRUE 47244
47242: GO 47300
47244: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47245: LD_ADDR_VAR 0 9
47249: PUSH
47250: LD_VAR 0 23
47254: PUSH
47255: LD_VAR 0 24
47259: PUSH
47260: LD_VAR 0 25
47264: PUSH
47265: LD_VAR 0 26
47269: PUSH
47270: LD_VAR 0 27
47274: PUSH
47275: LD_VAR 0 28
47279: PUSH
47280: EMPTY
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: LIST
47286: LIST
47287: PUSH
47288: LD_VAR 0 4
47292: PUSH
47293: LD_INT 1
47295: PLUS
47296: ARRAY
47297: ST_TO_ADDR
47298: GO 47301
47300: POP
47301: GO 47856
47303: LD_INT 2
47305: DOUBLE
47306: EQUAL
47307: IFTRUE 47317
47309: LD_INT 3
47311: DOUBLE
47312: EQUAL
47313: IFTRUE 47317
47315: GO 47373
47317: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47318: LD_ADDR_VAR 0 9
47322: PUSH
47323: LD_VAR 0 29
47327: PUSH
47328: LD_VAR 0 30
47332: PUSH
47333: LD_VAR 0 31
47337: PUSH
47338: LD_VAR 0 32
47342: PUSH
47343: LD_VAR 0 33
47347: PUSH
47348: LD_VAR 0 34
47352: PUSH
47353: EMPTY
47354: LIST
47355: LIST
47356: LIST
47357: LIST
47358: LIST
47359: LIST
47360: PUSH
47361: LD_VAR 0 4
47365: PUSH
47366: LD_INT 1
47368: PLUS
47369: ARRAY
47370: ST_TO_ADDR
47371: GO 47856
47373: LD_INT 16
47375: DOUBLE
47376: EQUAL
47377: IFTRUE 47435
47379: LD_INT 17
47381: DOUBLE
47382: EQUAL
47383: IFTRUE 47435
47385: LD_INT 18
47387: DOUBLE
47388: EQUAL
47389: IFTRUE 47435
47391: LD_INT 19
47393: DOUBLE
47394: EQUAL
47395: IFTRUE 47435
47397: LD_INT 22
47399: DOUBLE
47400: EQUAL
47401: IFTRUE 47435
47403: LD_INT 20
47405: DOUBLE
47406: EQUAL
47407: IFTRUE 47435
47409: LD_INT 21
47411: DOUBLE
47412: EQUAL
47413: IFTRUE 47435
47415: LD_INT 23
47417: DOUBLE
47418: EQUAL
47419: IFTRUE 47435
47421: LD_INT 24
47423: DOUBLE
47424: EQUAL
47425: IFTRUE 47435
47427: LD_INT 25
47429: DOUBLE
47430: EQUAL
47431: IFTRUE 47435
47433: GO 47491
47435: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47436: LD_ADDR_VAR 0 9
47440: PUSH
47441: LD_VAR 0 35
47445: PUSH
47446: LD_VAR 0 36
47450: PUSH
47451: LD_VAR 0 37
47455: PUSH
47456: LD_VAR 0 38
47460: PUSH
47461: LD_VAR 0 39
47465: PUSH
47466: LD_VAR 0 40
47470: PUSH
47471: EMPTY
47472: LIST
47473: LIST
47474: LIST
47475: LIST
47476: LIST
47477: LIST
47478: PUSH
47479: LD_VAR 0 4
47483: PUSH
47484: LD_INT 1
47486: PLUS
47487: ARRAY
47488: ST_TO_ADDR
47489: GO 47856
47491: LD_INT 6
47493: DOUBLE
47494: EQUAL
47495: IFTRUE 47547
47497: LD_INT 7
47499: DOUBLE
47500: EQUAL
47501: IFTRUE 47547
47503: LD_INT 8
47505: DOUBLE
47506: EQUAL
47507: IFTRUE 47547
47509: LD_INT 13
47511: DOUBLE
47512: EQUAL
47513: IFTRUE 47547
47515: LD_INT 12
47517: DOUBLE
47518: EQUAL
47519: IFTRUE 47547
47521: LD_INT 15
47523: DOUBLE
47524: EQUAL
47525: IFTRUE 47547
47527: LD_INT 11
47529: DOUBLE
47530: EQUAL
47531: IFTRUE 47547
47533: LD_INT 14
47535: DOUBLE
47536: EQUAL
47537: IFTRUE 47547
47539: LD_INT 10
47541: DOUBLE
47542: EQUAL
47543: IFTRUE 47547
47545: GO 47603
47547: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47548: LD_ADDR_VAR 0 9
47552: PUSH
47553: LD_VAR 0 41
47557: PUSH
47558: LD_VAR 0 42
47562: PUSH
47563: LD_VAR 0 43
47567: PUSH
47568: LD_VAR 0 44
47572: PUSH
47573: LD_VAR 0 45
47577: PUSH
47578: LD_VAR 0 46
47582: PUSH
47583: EMPTY
47584: LIST
47585: LIST
47586: LIST
47587: LIST
47588: LIST
47589: LIST
47590: PUSH
47591: LD_VAR 0 4
47595: PUSH
47596: LD_INT 1
47598: PLUS
47599: ARRAY
47600: ST_TO_ADDR
47601: GO 47856
47603: LD_INT 36
47605: DOUBLE
47606: EQUAL
47607: IFTRUE 47611
47609: GO 47667
47611: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47612: LD_ADDR_VAR 0 9
47616: PUSH
47617: LD_VAR 0 47
47621: PUSH
47622: LD_VAR 0 48
47626: PUSH
47627: LD_VAR 0 49
47631: PUSH
47632: LD_VAR 0 50
47636: PUSH
47637: LD_VAR 0 51
47641: PUSH
47642: LD_VAR 0 52
47646: PUSH
47647: EMPTY
47648: LIST
47649: LIST
47650: LIST
47651: LIST
47652: LIST
47653: LIST
47654: PUSH
47655: LD_VAR 0 4
47659: PUSH
47660: LD_INT 1
47662: PLUS
47663: ARRAY
47664: ST_TO_ADDR
47665: GO 47856
47667: LD_INT 4
47669: DOUBLE
47670: EQUAL
47671: IFTRUE 47693
47673: LD_INT 5
47675: DOUBLE
47676: EQUAL
47677: IFTRUE 47693
47679: LD_INT 34
47681: DOUBLE
47682: EQUAL
47683: IFTRUE 47693
47685: LD_INT 37
47687: DOUBLE
47688: EQUAL
47689: IFTRUE 47693
47691: GO 47749
47693: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47694: LD_ADDR_VAR 0 9
47698: PUSH
47699: LD_VAR 0 53
47703: PUSH
47704: LD_VAR 0 54
47708: PUSH
47709: LD_VAR 0 55
47713: PUSH
47714: LD_VAR 0 56
47718: PUSH
47719: LD_VAR 0 57
47723: PUSH
47724: LD_VAR 0 58
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: LIST
47733: LIST
47734: LIST
47735: LIST
47736: PUSH
47737: LD_VAR 0 4
47741: PUSH
47742: LD_INT 1
47744: PLUS
47745: ARRAY
47746: ST_TO_ADDR
47747: GO 47856
47749: LD_INT 31
47751: DOUBLE
47752: EQUAL
47753: IFTRUE 47799
47755: LD_INT 32
47757: DOUBLE
47758: EQUAL
47759: IFTRUE 47799
47761: LD_INT 33
47763: DOUBLE
47764: EQUAL
47765: IFTRUE 47799
47767: LD_INT 27
47769: DOUBLE
47770: EQUAL
47771: IFTRUE 47799
47773: LD_INT 26
47775: DOUBLE
47776: EQUAL
47777: IFTRUE 47799
47779: LD_INT 28
47781: DOUBLE
47782: EQUAL
47783: IFTRUE 47799
47785: LD_INT 29
47787: DOUBLE
47788: EQUAL
47789: IFTRUE 47799
47791: LD_INT 30
47793: DOUBLE
47794: EQUAL
47795: IFTRUE 47799
47797: GO 47855
47799: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47800: LD_ADDR_VAR 0 9
47804: PUSH
47805: LD_VAR 0 59
47809: PUSH
47810: LD_VAR 0 60
47814: PUSH
47815: LD_VAR 0 61
47819: PUSH
47820: LD_VAR 0 62
47824: PUSH
47825: LD_VAR 0 63
47829: PUSH
47830: LD_VAR 0 64
47834: PUSH
47835: EMPTY
47836: LIST
47837: LIST
47838: LIST
47839: LIST
47840: LIST
47841: LIST
47842: PUSH
47843: LD_VAR 0 4
47847: PUSH
47848: LD_INT 1
47850: PLUS
47851: ARRAY
47852: ST_TO_ADDR
47853: GO 47856
47855: POP
// temp_list2 = [ ] ;
47856: LD_ADDR_VAR 0 10
47860: PUSH
47861: EMPTY
47862: ST_TO_ADDR
// for i in temp_list do
47863: LD_ADDR_VAR 0 8
47867: PUSH
47868: LD_VAR 0 9
47872: PUSH
47873: FOR_IN
47874: IFFALSE 47926
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47876: LD_ADDR_VAR 0 10
47880: PUSH
47881: LD_VAR 0 10
47885: PUSH
47886: LD_VAR 0 8
47890: PUSH
47891: LD_INT 1
47893: ARRAY
47894: PUSH
47895: LD_VAR 0 2
47899: PLUS
47900: PUSH
47901: LD_VAR 0 8
47905: PUSH
47906: LD_INT 2
47908: ARRAY
47909: PUSH
47910: LD_VAR 0 3
47914: PLUS
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: PUSH
47920: EMPTY
47921: LIST
47922: ADD
47923: ST_TO_ADDR
47924: GO 47873
47926: POP
47927: POP
// result = temp_list2 ;
47928: LD_ADDR_VAR 0 7
47932: PUSH
47933: LD_VAR 0 10
47937: ST_TO_ADDR
// end ;
47938: LD_VAR 0 7
47942: RET
// export function EnemyInRange ( unit , dist ) ; begin
47943: LD_INT 0
47945: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47946: LD_ADDR_VAR 0 3
47950: PUSH
47951: LD_VAR 0 1
47955: PPUSH
47956: CALL_OW 255
47960: PPUSH
47961: LD_VAR 0 1
47965: PPUSH
47966: CALL_OW 250
47970: PPUSH
47971: LD_VAR 0 1
47975: PPUSH
47976: CALL_OW 251
47980: PPUSH
47981: LD_VAR 0 2
47985: PPUSH
47986: CALL 22047 0 4
47990: PUSH
47991: LD_INT 4
47993: ARRAY
47994: ST_TO_ADDR
// end ;
47995: LD_VAR 0 3
47999: RET
// export function PlayerSeeMe ( unit ) ; begin
48000: LD_INT 0
48002: PPUSH
// result := See ( your_side , unit ) ;
48003: LD_ADDR_VAR 0 2
48007: PUSH
48008: LD_OWVAR 2
48012: PPUSH
48013: LD_VAR 0 1
48017: PPUSH
48018: CALL_OW 292
48022: ST_TO_ADDR
// end ;
48023: LD_VAR 0 2
48027: RET
// export function ReverseDir ( unit ) ; begin
48028: LD_INT 0
48030: PPUSH
// if not unit then
48031: LD_VAR 0 1
48035: NOT
48036: IFFALSE 48040
// exit ;
48038: GO 48086
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
48040: LD_ADDR_VAR 0 2
48044: PUSH
48045: LD_INT 3
48047: PUSH
48048: LD_INT 4
48050: PUSH
48051: LD_INT 5
48053: PUSH
48054: LD_INT 0
48056: PUSH
48057: LD_INT 1
48059: PUSH
48060: LD_INT 2
48062: PUSH
48063: EMPTY
48064: LIST
48065: LIST
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: PUSH
48071: LD_VAR 0 1
48075: PPUSH
48076: CALL_OW 254
48080: PUSH
48081: LD_INT 1
48083: PLUS
48084: ARRAY
48085: ST_TO_ADDR
// end ;
48086: LD_VAR 0 2
48090: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
48091: LD_INT 0
48093: PPUSH
48094: PPUSH
48095: PPUSH
48096: PPUSH
48097: PPUSH
// if not hexes then
48098: LD_VAR 0 2
48102: NOT
48103: IFFALSE 48107
// exit ;
48105: GO 48255
// dist := 9999 ;
48107: LD_ADDR_VAR 0 5
48111: PUSH
48112: LD_INT 9999
48114: ST_TO_ADDR
// for i = 1 to hexes do
48115: LD_ADDR_VAR 0 4
48119: PUSH
48120: DOUBLE
48121: LD_INT 1
48123: DEC
48124: ST_TO_ADDR
48125: LD_VAR 0 2
48129: PUSH
48130: FOR_TO
48131: IFFALSE 48243
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
48133: LD_VAR 0 1
48137: PPUSH
48138: LD_VAR 0 2
48142: PUSH
48143: LD_VAR 0 4
48147: ARRAY
48148: PUSH
48149: LD_INT 1
48151: ARRAY
48152: PPUSH
48153: LD_VAR 0 2
48157: PUSH
48158: LD_VAR 0 4
48162: ARRAY
48163: PUSH
48164: LD_INT 2
48166: ARRAY
48167: PPUSH
48168: CALL_OW 297
48172: PUSH
48173: LD_VAR 0 5
48177: LESS
48178: IFFALSE 48241
// begin hex := hexes [ i ] ;
48180: LD_ADDR_VAR 0 7
48184: PUSH
48185: LD_VAR 0 2
48189: PUSH
48190: LD_VAR 0 4
48194: ARRAY
48195: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48196: LD_ADDR_VAR 0 5
48200: PUSH
48201: LD_VAR 0 1
48205: PPUSH
48206: LD_VAR 0 2
48210: PUSH
48211: LD_VAR 0 4
48215: ARRAY
48216: PUSH
48217: LD_INT 1
48219: ARRAY
48220: PPUSH
48221: LD_VAR 0 2
48225: PUSH
48226: LD_VAR 0 4
48230: ARRAY
48231: PUSH
48232: LD_INT 2
48234: ARRAY
48235: PPUSH
48236: CALL_OW 297
48240: ST_TO_ADDR
// end ; end ;
48241: GO 48130
48243: POP
48244: POP
// result := hex ;
48245: LD_ADDR_VAR 0 3
48249: PUSH
48250: LD_VAR 0 7
48254: ST_TO_ADDR
// end ;
48255: LD_VAR 0 3
48259: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48260: LD_INT 0
48262: PPUSH
48263: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48264: LD_VAR 0 1
48268: NOT
48269: PUSH
48270: LD_VAR 0 1
48274: PUSH
48275: LD_INT 21
48277: PUSH
48278: LD_INT 2
48280: PUSH
48281: EMPTY
48282: LIST
48283: LIST
48284: PUSH
48285: LD_INT 23
48287: PUSH
48288: LD_INT 2
48290: PUSH
48291: EMPTY
48292: LIST
48293: LIST
48294: PUSH
48295: EMPTY
48296: LIST
48297: LIST
48298: PPUSH
48299: CALL_OW 69
48303: IN
48304: NOT
48305: OR
48306: IFFALSE 48310
// exit ;
48308: GO 48357
// for i = 1 to 3 do
48310: LD_ADDR_VAR 0 3
48314: PUSH
48315: DOUBLE
48316: LD_INT 1
48318: DEC
48319: ST_TO_ADDR
48320: LD_INT 3
48322: PUSH
48323: FOR_TO
48324: IFFALSE 48355
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48326: LD_VAR 0 1
48330: PPUSH
48331: CALL_OW 250
48335: PPUSH
48336: LD_VAR 0 1
48340: PPUSH
48341: CALL_OW 251
48345: PPUSH
48346: LD_INT 1
48348: PPUSH
48349: CALL_OW 453
48353: GO 48323
48355: POP
48356: POP
// end ;
48357: LD_VAR 0 2
48361: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48362: LD_INT 0
48364: PPUSH
48365: PPUSH
48366: PPUSH
48367: PPUSH
48368: PPUSH
48369: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48370: LD_VAR 0 1
48374: NOT
48375: PUSH
48376: LD_VAR 0 2
48380: NOT
48381: OR
48382: PUSH
48383: LD_VAR 0 1
48387: PPUSH
48388: CALL_OW 314
48392: OR
48393: IFFALSE 48397
// exit ;
48395: GO 48838
// x := GetX ( enemy_unit ) ;
48397: LD_ADDR_VAR 0 7
48401: PUSH
48402: LD_VAR 0 2
48406: PPUSH
48407: CALL_OW 250
48411: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48412: LD_ADDR_VAR 0 8
48416: PUSH
48417: LD_VAR 0 2
48421: PPUSH
48422: CALL_OW 251
48426: ST_TO_ADDR
// if not x or not y then
48427: LD_VAR 0 7
48431: NOT
48432: PUSH
48433: LD_VAR 0 8
48437: NOT
48438: OR
48439: IFFALSE 48443
// exit ;
48441: GO 48838
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48443: LD_ADDR_VAR 0 6
48447: PUSH
48448: LD_VAR 0 7
48452: PPUSH
48453: LD_INT 0
48455: PPUSH
48456: LD_INT 4
48458: PPUSH
48459: CALL_OW 272
48463: PUSH
48464: LD_VAR 0 8
48468: PPUSH
48469: LD_INT 0
48471: PPUSH
48472: LD_INT 4
48474: PPUSH
48475: CALL_OW 273
48479: PUSH
48480: EMPTY
48481: LIST
48482: LIST
48483: PUSH
48484: LD_VAR 0 7
48488: PPUSH
48489: LD_INT 1
48491: PPUSH
48492: LD_INT 4
48494: PPUSH
48495: CALL_OW 272
48499: PUSH
48500: LD_VAR 0 8
48504: PPUSH
48505: LD_INT 1
48507: PPUSH
48508: LD_INT 4
48510: PPUSH
48511: CALL_OW 273
48515: PUSH
48516: EMPTY
48517: LIST
48518: LIST
48519: PUSH
48520: LD_VAR 0 7
48524: PPUSH
48525: LD_INT 2
48527: PPUSH
48528: LD_INT 4
48530: PPUSH
48531: CALL_OW 272
48535: PUSH
48536: LD_VAR 0 8
48540: PPUSH
48541: LD_INT 2
48543: PPUSH
48544: LD_INT 4
48546: PPUSH
48547: CALL_OW 273
48551: PUSH
48552: EMPTY
48553: LIST
48554: LIST
48555: PUSH
48556: LD_VAR 0 7
48560: PPUSH
48561: LD_INT 3
48563: PPUSH
48564: LD_INT 4
48566: PPUSH
48567: CALL_OW 272
48571: PUSH
48572: LD_VAR 0 8
48576: PPUSH
48577: LD_INT 3
48579: PPUSH
48580: LD_INT 4
48582: PPUSH
48583: CALL_OW 273
48587: PUSH
48588: EMPTY
48589: LIST
48590: LIST
48591: PUSH
48592: LD_VAR 0 7
48596: PPUSH
48597: LD_INT 4
48599: PPUSH
48600: LD_INT 4
48602: PPUSH
48603: CALL_OW 272
48607: PUSH
48608: LD_VAR 0 8
48612: PPUSH
48613: LD_INT 4
48615: PPUSH
48616: LD_INT 4
48618: PPUSH
48619: CALL_OW 273
48623: PUSH
48624: EMPTY
48625: LIST
48626: LIST
48627: PUSH
48628: LD_VAR 0 7
48632: PPUSH
48633: LD_INT 5
48635: PPUSH
48636: LD_INT 4
48638: PPUSH
48639: CALL_OW 272
48643: PUSH
48644: LD_VAR 0 8
48648: PPUSH
48649: LD_INT 5
48651: PPUSH
48652: LD_INT 4
48654: PPUSH
48655: CALL_OW 273
48659: PUSH
48660: EMPTY
48661: LIST
48662: LIST
48663: PUSH
48664: EMPTY
48665: LIST
48666: LIST
48667: LIST
48668: LIST
48669: LIST
48670: LIST
48671: ST_TO_ADDR
// for i = tmp downto 1 do
48672: LD_ADDR_VAR 0 4
48676: PUSH
48677: DOUBLE
48678: LD_VAR 0 6
48682: INC
48683: ST_TO_ADDR
48684: LD_INT 1
48686: PUSH
48687: FOR_DOWNTO
48688: IFFALSE 48789
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48690: LD_VAR 0 6
48694: PUSH
48695: LD_VAR 0 4
48699: ARRAY
48700: PUSH
48701: LD_INT 1
48703: ARRAY
48704: PPUSH
48705: LD_VAR 0 6
48709: PUSH
48710: LD_VAR 0 4
48714: ARRAY
48715: PUSH
48716: LD_INT 2
48718: ARRAY
48719: PPUSH
48720: CALL_OW 488
48724: NOT
48725: PUSH
48726: LD_VAR 0 6
48730: PUSH
48731: LD_VAR 0 4
48735: ARRAY
48736: PUSH
48737: LD_INT 1
48739: ARRAY
48740: PPUSH
48741: LD_VAR 0 6
48745: PUSH
48746: LD_VAR 0 4
48750: ARRAY
48751: PUSH
48752: LD_INT 2
48754: ARRAY
48755: PPUSH
48756: CALL_OW 428
48760: PUSH
48761: LD_INT 0
48763: NONEQUAL
48764: OR
48765: IFFALSE 48787
// tmp := Delete ( tmp , i ) ;
48767: LD_ADDR_VAR 0 6
48771: PUSH
48772: LD_VAR 0 6
48776: PPUSH
48777: LD_VAR 0 4
48781: PPUSH
48782: CALL_OW 3
48786: ST_TO_ADDR
48787: GO 48687
48789: POP
48790: POP
// j := GetClosestHex ( unit , tmp ) ;
48791: LD_ADDR_VAR 0 5
48795: PUSH
48796: LD_VAR 0 1
48800: PPUSH
48801: LD_VAR 0 6
48805: PPUSH
48806: CALL 48091 0 2
48810: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48811: LD_VAR 0 1
48815: PPUSH
48816: LD_VAR 0 5
48820: PUSH
48821: LD_INT 1
48823: ARRAY
48824: PPUSH
48825: LD_VAR 0 5
48829: PUSH
48830: LD_INT 2
48832: ARRAY
48833: PPUSH
48834: CALL_OW 111
// end ;
48838: LD_VAR 0 3
48842: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48843: LD_INT 0
48845: PPUSH
48846: PPUSH
48847: PPUSH
// uc_side = 0 ;
48848: LD_ADDR_OWVAR 20
48852: PUSH
48853: LD_INT 0
48855: ST_TO_ADDR
// uc_nation = 0 ;
48856: LD_ADDR_OWVAR 21
48860: PUSH
48861: LD_INT 0
48863: ST_TO_ADDR
// InitHc ;
48864: CALL_OW 19
// InitVc ;
48868: CALL_OW 20
// if mastodonts then
48872: LD_VAR 0 6
48876: IFFALSE 48943
// for i = 1 to mastodonts do
48878: LD_ADDR_VAR 0 11
48882: PUSH
48883: DOUBLE
48884: LD_INT 1
48886: DEC
48887: ST_TO_ADDR
48888: LD_VAR 0 6
48892: PUSH
48893: FOR_TO
48894: IFFALSE 48941
// begin vc_chassis := 31 ;
48896: LD_ADDR_OWVAR 37
48900: PUSH
48901: LD_INT 31
48903: ST_TO_ADDR
// vc_control := control_rider ;
48904: LD_ADDR_OWVAR 38
48908: PUSH
48909: LD_INT 4
48911: ST_TO_ADDR
// animal := CreateVehicle ;
48912: LD_ADDR_VAR 0 12
48916: PUSH
48917: CALL_OW 45
48921: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48922: LD_VAR 0 12
48926: PPUSH
48927: LD_VAR 0 8
48931: PPUSH
48932: LD_INT 0
48934: PPUSH
48935: CALL 55688 0 3
// end ;
48939: GO 48893
48941: POP
48942: POP
// if horses then
48943: LD_VAR 0 5
48947: IFFALSE 49014
// for i = 1 to horses do
48949: LD_ADDR_VAR 0 11
48953: PUSH
48954: DOUBLE
48955: LD_INT 1
48957: DEC
48958: ST_TO_ADDR
48959: LD_VAR 0 5
48963: PUSH
48964: FOR_TO
48965: IFFALSE 49012
// begin hc_class := 21 ;
48967: LD_ADDR_OWVAR 28
48971: PUSH
48972: LD_INT 21
48974: ST_TO_ADDR
// hc_gallery :=  ;
48975: LD_ADDR_OWVAR 33
48979: PUSH
48980: LD_STRING 
48982: ST_TO_ADDR
// animal := CreateHuman ;
48983: LD_ADDR_VAR 0 12
48987: PUSH
48988: CALL_OW 44
48992: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48993: LD_VAR 0 12
48997: PPUSH
48998: LD_VAR 0 8
49002: PPUSH
49003: LD_INT 0
49005: PPUSH
49006: CALL 55688 0 3
// end ;
49010: GO 48964
49012: POP
49013: POP
// if birds then
49014: LD_VAR 0 1
49018: IFFALSE 49085
// for i = 1 to birds do
49020: LD_ADDR_VAR 0 11
49024: PUSH
49025: DOUBLE
49026: LD_INT 1
49028: DEC
49029: ST_TO_ADDR
49030: LD_VAR 0 1
49034: PUSH
49035: FOR_TO
49036: IFFALSE 49083
// begin hc_class = 18 ;
49038: LD_ADDR_OWVAR 28
49042: PUSH
49043: LD_INT 18
49045: ST_TO_ADDR
// hc_gallery =  ;
49046: LD_ADDR_OWVAR 33
49050: PUSH
49051: LD_STRING 
49053: ST_TO_ADDR
// animal := CreateHuman ;
49054: LD_ADDR_VAR 0 12
49058: PUSH
49059: CALL_OW 44
49063: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49064: LD_VAR 0 12
49068: PPUSH
49069: LD_VAR 0 8
49073: PPUSH
49074: LD_INT 0
49076: PPUSH
49077: CALL 55688 0 3
// end ;
49081: GO 49035
49083: POP
49084: POP
// if tigers then
49085: LD_VAR 0 2
49089: IFFALSE 49173
// for i = 1 to tigers do
49091: LD_ADDR_VAR 0 11
49095: PUSH
49096: DOUBLE
49097: LD_INT 1
49099: DEC
49100: ST_TO_ADDR
49101: LD_VAR 0 2
49105: PUSH
49106: FOR_TO
49107: IFFALSE 49171
// begin hc_class = class_tiger ;
49109: LD_ADDR_OWVAR 28
49113: PUSH
49114: LD_INT 14
49116: ST_TO_ADDR
// hc_gallery =  ;
49117: LD_ADDR_OWVAR 33
49121: PUSH
49122: LD_STRING 
49124: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49125: LD_ADDR_OWVAR 35
49129: PUSH
49130: LD_INT 7
49132: NEG
49133: PPUSH
49134: LD_INT 7
49136: PPUSH
49137: CALL_OW 12
49141: ST_TO_ADDR
// animal := CreateHuman ;
49142: LD_ADDR_VAR 0 12
49146: PUSH
49147: CALL_OW 44
49151: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49152: LD_VAR 0 12
49156: PPUSH
49157: LD_VAR 0 8
49161: PPUSH
49162: LD_INT 0
49164: PPUSH
49165: CALL 55688 0 3
// end ;
49169: GO 49106
49171: POP
49172: POP
// if apemans then
49173: LD_VAR 0 3
49177: IFFALSE 49300
// for i = 1 to apemans do
49179: LD_ADDR_VAR 0 11
49183: PUSH
49184: DOUBLE
49185: LD_INT 1
49187: DEC
49188: ST_TO_ADDR
49189: LD_VAR 0 3
49193: PUSH
49194: FOR_TO
49195: IFFALSE 49298
// begin hc_class = class_apeman ;
49197: LD_ADDR_OWVAR 28
49201: PUSH
49202: LD_INT 12
49204: ST_TO_ADDR
// hc_gallery =  ;
49205: LD_ADDR_OWVAR 33
49209: PUSH
49210: LD_STRING 
49212: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
49213: LD_ADDR_OWVAR 35
49217: PUSH
49218: LD_INT 5
49220: NEG
49221: PPUSH
49222: LD_INT 5
49224: PPUSH
49225: CALL_OW 12
49229: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49230: LD_ADDR_OWVAR 31
49234: PUSH
49235: LD_INT 1
49237: PPUSH
49238: LD_INT 3
49240: PPUSH
49241: CALL_OW 12
49245: PUSH
49246: LD_INT 1
49248: PPUSH
49249: LD_INT 3
49251: PPUSH
49252: CALL_OW 12
49256: PUSH
49257: LD_INT 0
49259: PUSH
49260: LD_INT 0
49262: PUSH
49263: EMPTY
49264: LIST
49265: LIST
49266: LIST
49267: LIST
49268: ST_TO_ADDR
// animal := CreateHuman ;
49269: LD_ADDR_VAR 0 12
49273: PUSH
49274: CALL_OW 44
49278: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49279: LD_VAR 0 12
49283: PPUSH
49284: LD_VAR 0 8
49288: PPUSH
49289: LD_INT 0
49291: PPUSH
49292: CALL 55688 0 3
// end ;
49296: GO 49194
49298: POP
49299: POP
// if enchidnas then
49300: LD_VAR 0 4
49304: IFFALSE 49371
// for i = 1 to enchidnas do
49306: LD_ADDR_VAR 0 11
49310: PUSH
49311: DOUBLE
49312: LD_INT 1
49314: DEC
49315: ST_TO_ADDR
49316: LD_VAR 0 4
49320: PUSH
49321: FOR_TO
49322: IFFALSE 49369
// begin hc_class = 13 ;
49324: LD_ADDR_OWVAR 28
49328: PUSH
49329: LD_INT 13
49331: ST_TO_ADDR
// hc_gallery =  ;
49332: LD_ADDR_OWVAR 33
49336: PUSH
49337: LD_STRING 
49339: ST_TO_ADDR
// animal := CreateHuman ;
49340: LD_ADDR_VAR 0 12
49344: PUSH
49345: CALL_OW 44
49349: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49350: LD_VAR 0 12
49354: PPUSH
49355: LD_VAR 0 8
49359: PPUSH
49360: LD_INT 0
49362: PPUSH
49363: CALL 55688 0 3
// end ;
49367: GO 49321
49369: POP
49370: POP
// if fishes then
49371: LD_VAR 0 7
49375: IFFALSE 49442
// for i = 1 to fishes do
49377: LD_ADDR_VAR 0 11
49381: PUSH
49382: DOUBLE
49383: LD_INT 1
49385: DEC
49386: ST_TO_ADDR
49387: LD_VAR 0 7
49391: PUSH
49392: FOR_TO
49393: IFFALSE 49440
// begin hc_class = 20 ;
49395: LD_ADDR_OWVAR 28
49399: PUSH
49400: LD_INT 20
49402: ST_TO_ADDR
// hc_gallery =  ;
49403: LD_ADDR_OWVAR 33
49407: PUSH
49408: LD_STRING 
49410: ST_TO_ADDR
// animal := CreateHuman ;
49411: LD_ADDR_VAR 0 12
49415: PUSH
49416: CALL_OW 44
49420: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49421: LD_VAR 0 12
49425: PPUSH
49426: LD_VAR 0 9
49430: PPUSH
49431: LD_INT 0
49433: PPUSH
49434: CALL 55688 0 3
// end ;
49438: GO 49392
49440: POP
49441: POP
// end ;
49442: LD_VAR 0 10
49446: RET
// export function WantHeal ( sci , unit ) ; begin
49447: LD_INT 0
49449: PPUSH
// if GetTaskList ( sci ) > 0 then
49450: LD_VAR 0 1
49454: PPUSH
49455: CALL_OW 437
49459: PUSH
49460: LD_INT 0
49462: GREATER
49463: IFFALSE 49533
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49465: LD_VAR 0 1
49469: PPUSH
49470: CALL_OW 437
49474: PUSH
49475: LD_INT 1
49477: ARRAY
49478: PUSH
49479: LD_INT 1
49481: ARRAY
49482: PUSH
49483: LD_STRING l
49485: EQUAL
49486: PUSH
49487: LD_VAR 0 1
49491: PPUSH
49492: CALL_OW 437
49496: PUSH
49497: LD_INT 1
49499: ARRAY
49500: PUSH
49501: LD_INT 4
49503: ARRAY
49504: PUSH
49505: LD_VAR 0 2
49509: EQUAL
49510: AND
49511: IFFALSE 49523
// result := true else
49513: LD_ADDR_VAR 0 3
49517: PUSH
49518: LD_INT 1
49520: ST_TO_ADDR
49521: GO 49531
// result := false ;
49523: LD_ADDR_VAR 0 3
49527: PUSH
49528: LD_INT 0
49530: ST_TO_ADDR
// end else
49531: GO 49541
// result := false ;
49533: LD_ADDR_VAR 0 3
49537: PUSH
49538: LD_INT 0
49540: ST_TO_ADDR
// end ;
49541: LD_VAR 0 3
49545: RET
// export function HealTarget ( sci ) ; begin
49546: LD_INT 0
49548: PPUSH
// if not sci then
49549: LD_VAR 0 1
49553: NOT
49554: IFFALSE 49558
// exit ;
49556: GO 49623
// result := 0 ;
49558: LD_ADDR_VAR 0 2
49562: PUSH
49563: LD_INT 0
49565: ST_TO_ADDR
// if GetTaskList ( sci ) then
49566: LD_VAR 0 1
49570: PPUSH
49571: CALL_OW 437
49575: IFFALSE 49623
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49577: LD_VAR 0 1
49581: PPUSH
49582: CALL_OW 437
49586: PUSH
49587: LD_INT 1
49589: ARRAY
49590: PUSH
49591: LD_INT 1
49593: ARRAY
49594: PUSH
49595: LD_STRING l
49597: EQUAL
49598: IFFALSE 49623
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49600: LD_ADDR_VAR 0 2
49604: PUSH
49605: LD_VAR 0 1
49609: PPUSH
49610: CALL_OW 437
49614: PUSH
49615: LD_INT 1
49617: ARRAY
49618: PUSH
49619: LD_INT 4
49621: ARRAY
49622: ST_TO_ADDR
// end ;
49623: LD_VAR 0 2
49627: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49628: LD_INT 0
49630: PPUSH
49631: PPUSH
49632: PPUSH
49633: PPUSH
49634: PPUSH
49635: PPUSH
49636: PPUSH
49637: PPUSH
49638: PPUSH
49639: PPUSH
49640: PPUSH
49641: PPUSH
49642: PPUSH
49643: PPUSH
49644: PPUSH
49645: PPUSH
49646: PPUSH
49647: PPUSH
49648: PPUSH
49649: PPUSH
49650: PPUSH
49651: PPUSH
49652: PPUSH
49653: PPUSH
49654: PPUSH
49655: PPUSH
49656: PPUSH
49657: PPUSH
49658: PPUSH
49659: PPUSH
49660: PPUSH
49661: PPUSH
49662: PPUSH
49663: PPUSH
// if not list then
49664: LD_VAR 0 1
49668: NOT
49669: IFFALSE 49673
// exit ;
49671: GO 54299
// base := list [ 1 ] ;
49673: LD_ADDR_VAR 0 3
49677: PUSH
49678: LD_VAR 0 1
49682: PUSH
49683: LD_INT 1
49685: ARRAY
49686: ST_TO_ADDR
// group := list [ 2 ] ;
49687: LD_ADDR_VAR 0 4
49691: PUSH
49692: LD_VAR 0 1
49696: PUSH
49697: LD_INT 2
49699: ARRAY
49700: ST_TO_ADDR
// path := list [ 3 ] ;
49701: LD_ADDR_VAR 0 5
49705: PUSH
49706: LD_VAR 0 1
49710: PUSH
49711: LD_INT 3
49713: ARRAY
49714: ST_TO_ADDR
// flags := list [ 4 ] ;
49715: LD_ADDR_VAR 0 6
49719: PUSH
49720: LD_VAR 0 1
49724: PUSH
49725: LD_INT 4
49727: ARRAY
49728: ST_TO_ADDR
// mined := [ ] ;
49729: LD_ADDR_VAR 0 27
49733: PUSH
49734: EMPTY
49735: ST_TO_ADDR
// bombed := [ ] ;
49736: LD_ADDR_VAR 0 28
49740: PUSH
49741: EMPTY
49742: ST_TO_ADDR
// healers := [ ] ;
49743: LD_ADDR_VAR 0 31
49747: PUSH
49748: EMPTY
49749: ST_TO_ADDR
// to_heal := [ ] ;
49750: LD_ADDR_VAR 0 30
49754: PUSH
49755: EMPTY
49756: ST_TO_ADDR
// repairs := [ ] ;
49757: LD_ADDR_VAR 0 33
49761: PUSH
49762: EMPTY
49763: ST_TO_ADDR
// to_repair := [ ] ;
49764: LD_ADDR_VAR 0 32
49768: PUSH
49769: EMPTY
49770: ST_TO_ADDR
// if not group or not path then
49771: LD_VAR 0 4
49775: NOT
49776: PUSH
49777: LD_VAR 0 5
49781: NOT
49782: OR
49783: IFFALSE 49787
// exit ;
49785: GO 54299
// side := GetSide ( group [ 1 ] ) ;
49787: LD_ADDR_VAR 0 35
49791: PUSH
49792: LD_VAR 0 4
49796: PUSH
49797: LD_INT 1
49799: ARRAY
49800: PPUSH
49801: CALL_OW 255
49805: ST_TO_ADDR
// if flags then
49806: LD_VAR 0 6
49810: IFFALSE 49954
// begin f_ignore_area := flags [ 1 ] ;
49812: LD_ADDR_VAR 0 17
49816: PUSH
49817: LD_VAR 0 6
49821: PUSH
49822: LD_INT 1
49824: ARRAY
49825: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49826: LD_ADDR_VAR 0 18
49830: PUSH
49831: LD_VAR 0 6
49835: PUSH
49836: LD_INT 2
49838: ARRAY
49839: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49840: LD_ADDR_VAR 0 19
49844: PUSH
49845: LD_VAR 0 6
49849: PUSH
49850: LD_INT 3
49852: ARRAY
49853: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49854: LD_ADDR_VAR 0 20
49858: PUSH
49859: LD_VAR 0 6
49863: PUSH
49864: LD_INT 4
49866: ARRAY
49867: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49868: LD_ADDR_VAR 0 21
49872: PUSH
49873: LD_VAR 0 6
49877: PUSH
49878: LD_INT 5
49880: ARRAY
49881: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49882: LD_ADDR_VAR 0 22
49886: PUSH
49887: LD_VAR 0 6
49891: PUSH
49892: LD_INT 6
49894: ARRAY
49895: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49896: LD_ADDR_VAR 0 23
49900: PUSH
49901: LD_VAR 0 6
49905: PUSH
49906: LD_INT 7
49908: ARRAY
49909: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49910: LD_ADDR_VAR 0 24
49914: PUSH
49915: LD_VAR 0 6
49919: PUSH
49920: LD_INT 8
49922: ARRAY
49923: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49924: LD_ADDR_VAR 0 25
49928: PUSH
49929: LD_VAR 0 6
49933: PUSH
49934: LD_INT 9
49936: ARRAY
49937: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49938: LD_ADDR_VAR 0 26
49942: PUSH
49943: LD_VAR 0 6
49947: PUSH
49948: LD_INT 10
49950: ARRAY
49951: ST_TO_ADDR
// end else
49952: GO 50034
// begin f_ignore_area := false ;
49954: LD_ADDR_VAR 0 17
49958: PUSH
49959: LD_INT 0
49961: ST_TO_ADDR
// f_capture := false ;
49962: LD_ADDR_VAR 0 18
49966: PUSH
49967: LD_INT 0
49969: ST_TO_ADDR
// f_ignore_civ := false ;
49970: LD_ADDR_VAR 0 19
49974: PUSH
49975: LD_INT 0
49977: ST_TO_ADDR
// f_murder := false ;
49978: LD_ADDR_VAR 0 20
49982: PUSH
49983: LD_INT 0
49985: ST_TO_ADDR
// f_mines := false ;
49986: LD_ADDR_VAR 0 21
49990: PUSH
49991: LD_INT 0
49993: ST_TO_ADDR
// f_repair := false ;
49994: LD_ADDR_VAR 0 22
49998: PUSH
49999: LD_INT 0
50001: ST_TO_ADDR
// f_heal := false ;
50002: LD_ADDR_VAR 0 23
50006: PUSH
50007: LD_INT 0
50009: ST_TO_ADDR
// f_spacetime := false ;
50010: LD_ADDR_VAR 0 24
50014: PUSH
50015: LD_INT 0
50017: ST_TO_ADDR
// f_attack_depot := false ;
50018: LD_ADDR_VAR 0 25
50022: PUSH
50023: LD_INT 0
50025: ST_TO_ADDR
// f_crawl := false ;
50026: LD_ADDR_VAR 0 26
50030: PUSH
50031: LD_INT 0
50033: ST_TO_ADDR
// end ; if f_heal then
50034: LD_VAR 0 23
50038: IFFALSE 50065
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
50040: LD_ADDR_VAR 0 31
50044: PUSH
50045: LD_VAR 0 4
50049: PPUSH
50050: LD_INT 25
50052: PUSH
50053: LD_INT 4
50055: PUSH
50056: EMPTY
50057: LIST
50058: LIST
50059: PPUSH
50060: CALL_OW 72
50064: ST_TO_ADDR
// if f_repair then
50065: LD_VAR 0 22
50069: IFFALSE 50096
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
50071: LD_ADDR_VAR 0 33
50075: PUSH
50076: LD_VAR 0 4
50080: PPUSH
50081: LD_INT 25
50083: PUSH
50084: LD_INT 3
50086: PUSH
50087: EMPTY
50088: LIST
50089: LIST
50090: PPUSH
50091: CALL_OW 72
50095: ST_TO_ADDR
// units_path := [ ] ;
50096: LD_ADDR_VAR 0 16
50100: PUSH
50101: EMPTY
50102: ST_TO_ADDR
// for i = 1 to group do
50103: LD_ADDR_VAR 0 7
50107: PUSH
50108: DOUBLE
50109: LD_INT 1
50111: DEC
50112: ST_TO_ADDR
50113: LD_VAR 0 4
50117: PUSH
50118: FOR_TO
50119: IFFALSE 50148
// units_path := Replace ( units_path , i , path ) ;
50121: LD_ADDR_VAR 0 16
50125: PUSH
50126: LD_VAR 0 16
50130: PPUSH
50131: LD_VAR 0 7
50135: PPUSH
50136: LD_VAR 0 5
50140: PPUSH
50141: CALL_OW 1
50145: ST_TO_ADDR
50146: GO 50118
50148: POP
50149: POP
// repeat for i = group downto 1 do
50150: LD_ADDR_VAR 0 7
50154: PUSH
50155: DOUBLE
50156: LD_VAR 0 4
50160: INC
50161: ST_TO_ADDR
50162: LD_INT 1
50164: PUSH
50165: FOR_DOWNTO
50166: IFFALSE 54262
// begin wait ( 5 ) ;
50168: LD_INT 5
50170: PPUSH
50171: CALL_OW 67
// tmp := [ ] ;
50175: LD_ADDR_VAR 0 14
50179: PUSH
50180: EMPTY
50181: ST_TO_ADDR
// attacking := false ;
50182: LD_ADDR_VAR 0 29
50186: PUSH
50187: LD_INT 0
50189: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
50190: LD_VAR 0 4
50194: PUSH
50195: LD_VAR 0 7
50199: ARRAY
50200: PPUSH
50201: CALL_OW 301
50205: PUSH
50206: LD_VAR 0 4
50210: PUSH
50211: LD_VAR 0 7
50215: ARRAY
50216: NOT
50217: OR
50218: IFFALSE 50327
// begin if GetType ( group [ i ] ) = unit_human then
50220: LD_VAR 0 4
50224: PUSH
50225: LD_VAR 0 7
50229: ARRAY
50230: PPUSH
50231: CALL_OW 247
50235: PUSH
50236: LD_INT 1
50238: EQUAL
50239: IFFALSE 50285
// begin to_heal := to_heal diff group [ i ] ;
50241: LD_ADDR_VAR 0 30
50245: PUSH
50246: LD_VAR 0 30
50250: PUSH
50251: LD_VAR 0 4
50255: PUSH
50256: LD_VAR 0 7
50260: ARRAY
50261: DIFF
50262: ST_TO_ADDR
// healers := healers diff group [ i ] ;
50263: LD_ADDR_VAR 0 31
50267: PUSH
50268: LD_VAR 0 31
50272: PUSH
50273: LD_VAR 0 4
50277: PUSH
50278: LD_VAR 0 7
50282: ARRAY
50283: DIFF
50284: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
50285: LD_ADDR_VAR 0 4
50289: PUSH
50290: LD_VAR 0 4
50294: PPUSH
50295: LD_VAR 0 7
50299: PPUSH
50300: CALL_OW 3
50304: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
50305: LD_ADDR_VAR 0 16
50309: PUSH
50310: LD_VAR 0 16
50314: PPUSH
50315: LD_VAR 0 7
50319: PPUSH
50320: CALL_OW 3
50324: ST_TO_ADDR
// continue ;
50325: GO 50165
// end ; if f_repair then
50327: LD_VAR 0 22
50331: IFFALSE 50820
// begin if GetType ( group [ i ] ) = unit_vehicle then
50333: LD_VAR 0 4
50337: PUSH
50338: LD_VAR 0 7
50342: ARRAY
50343: PPUSH
50344: CALL_OW 247
50348: PUSH
50349: LD_INT 2
50351: EQUAL
50352: IFFALSE 50542
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50354: LD_VAR 0 4
50358: PUSH
50359: LD_VAR 0 7
50363: ARRAY
50364: PPUSH
50365: CALL_OW 256
50369: PUSH
50370: LD_INT 700
50372: LESS
50373: PUSH
50374: LD_VAR 0 4
50378: PUSH
50379: LD_VAR 0 7
50383: ARRAY
50384: PUSH
50385: LD_VAR 0 32
50389: IN
50390: NOT
50391: AND
50392: IFFALSE 50416
// to_repair := to_repair union group [ i ] ;
50394: LD_ADDR_VAR 0 32
50398: PUSH
50399: LD_VAR 0 32
50403: PUSH
50404: LD_VAR 0 4
50408: PUSH
50409: LD_VAR 0 7
50413: ARRAY
50414: UNION
50415: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50416: LD_VAR 0 4
50420: PUSH
50421: LD_VAR 0 7
50425: ARRAY
50426: PPUSH
50427: CALL_OW 256
50431: PUSH
50432: LD_INT 1000
50434: EQUAL
50435: PUSH
50436: LD_VAR 0 4
50440: PUSH
50441: LD_VAR 0 7
50445: ARRAY
50446: PUSH
50447: LD_VAR 0 32
50451: IN
50452: AND
50453: IFFALSE 50477
// to_repair := to_repair diff group [ i ] ;
50455: LD_ADDR_VAR 0 32
50459: PUSH
50460: LD_VAR 0 32
50464: PUSH
50465: LD_VAR 0 4
50469: PUSH
50470: LD_VAR 0 7
50474: ARRAY
50475: DIFF
50476: ST_TO_ADDR
// if group [ i ] in to_repair then
50477: LD_VAR 0 4
50481: PUSH
50482: LD_VAR 0 7
50486: ARRAY
50487: PUSH
50488: LD_VAR 0 32
50492: IN
50493: IFFALSE 50540
// begin if not IsInArea ( group [ i ] , f_repair ) then
50495: LD_VAR 0 4
50499: PUSH
50500: LD_VAR 0 7
50504: ARRAY
50505: PPUSH
50506: LD_VAR 0 22
50510: PPUSH
50511: CALL_OW 308
50515: NOT
50516: IFFALSE 50538
// ComMoveToArea ( group [ i ] , f_repair ) ;
50518: LD_VAR 0 4
50522: PUSH
50523: LD_VAR 0 7
50527: ARRAY
50528: PPUSH
50529: LD_VAR 0 22
50533: PPUSH
50534: CALL_OW 113
// continue ;
50538: GO 50165
// end ; end else
50540: GO 50820
// if group [ i ] in repairs then
50542: LD_VAR 0 4
50546: PUSH
50547: LD_VAR 0 7
50551: ARRAY
50552: PUSH
50553: LD_VAR 0 33
50557: IN
50558: IFFALSE 50820
// begin if IsInUnit ( group [ i ] ) then
50560: LD_VAR 0 4
50564: PUSH
50565: LD_VAR 0 7
50569: ARRAY
50570: PPUSH
50571: CALL_OW 310
50575: IFFALSE 50643
// begin z := IsInUnit ( group [ i ] ) ;
50577: LD_ADDR_VAR 0 13
50581: PUSH
50582: LD_VAR 0 4
50586: PUSH
50587: LD_VAR 0 7
50591: ARRAY
50592: PPUSH
50593: CALL_OW 310
50597: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50598: LD_VAR 0 13
50602: PUSH
50603: LD_VAR 0 32
50607: IN
50608: PUSH
50609: LD_VAR 0 13
50613: PPUSH
50614: LD_VAR 0 22
50618: PPUSH
50619: CALL_OW 308
50623: AND
50624: IFFALSE 50641
// ComExitVehicle ( group [ i ] ) ;
50626: LD_VAR 0 4
50630: PUSH
50631: LD_VAR 0 7
50635: ARRAY
50636: PPUSH
50637: CALL_OW 121
// end else
50641: GO 50820
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50643: LD_ADDR_VAR 0 13
50647: PUSH
50648: LD_VAR 0 4
50652: PPUSH
50653: LD_INT 95
50655: PUSH
50656: LD_VAR 0 22
50660: PUSH
50661: EMPTY
50662: LIST
50663: LIST
50664: PUSH
50665: LD_INT 58
50667: PUSH
50668: EMPTY
50669: LIST
50670: PUSH
50671: EMPTY
50672: LIST
50673: LIST
50674: PPUSH
50675: CALL_OW 72
50679: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50680: LD_VAR 0 4
50684: PUSH
50685: LD_VAR 0 7
50689: ARRAY
50690: PPUSH
50691: CALL_OW 314
50695: NOT
50696: IFFALSE 50818
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50698: LD_ADDR_VAR 0 10
50702: PUSH
50703: LD_VAR 0 13
50707: PPUSH
50708: LD_VAR 0 4
50712: PUSH
50713: LD_VAR 0 7
50717: ARRAY
50718: PPUSH
50719: CALL_OW 74
50723: ST_TO_ADDR
// if not x then
50724: LD_VAR 0 10
50728: NOT
50729: IFFALSE 50733
// continue ;
50731: GO 50165
// if GetLives ( x ) < 1000 then
50733: LD_VAR 0 10
50737: PPUSH
50738: CALL_OW 256
50742: PUSH
50743: LD_INT 1000
50745: LESS
50746: IFFALSE 50770
// ComRepairVehicle ( group [ i ] , x ) else
50748: LD_VAR 0 4
50752: PUSH
50753: LD_VAR 0 7
50757: ARRAY
50758: PPUSH
50759: LD_VAR 0 10
50763: PPUSH
50764: CALL_OW 129
50768: GO 50818
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50770: LD_VAR 0 23
50774: PUSH
50775: LD_VAR 0 4
50779: PUSH
50780: LD_VAR 0 7
50784: ARRAY
50785: PPUSH
50786: CALL_OW 256
50790: PUSH
50791: LD_INT 1000
50793: LESS
50794: AND
50795: NOT
50796: IFFALSE 50818
// ComEnterUnit ( group [ i ] , x ) ;
50798: LD_VAR 0 4
50802: PUSH
50803: LD_VAR 0 7
50807: ARRAY
50808: PPUSH
50809: LD_VAR 0 10
50813: PPUSH
50814: CALL_OW 120
// end ; continue ;
50818: GO 50165
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50820: LD_VAR 0 23
50824: PUSH
50825: LD_VAR 0 4
50829: PUSH
50830: LD_VAR 0 7
50834: ARRAY
50835: PPUSH
50836: CALL_OW 247
50840: PUSH
50841: LD_INT 1
50843: EQUAL
50844: AND
50845: IFFALSE 51323
// begin if group [ i ] in healers then
50847: LD_VAR 0 4
50851: PUSH
50852: LD_VAR 0 7
50856: ARRAY
50857: PUSH
50858: LD_VAR 0 31
50862: IN
50863: IFFALSE 51136
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50865: LD_VAR 0 4
50869: PUSH
50870: LD_VAR 0 7
50874: ARRAY
50875: PPUSH
50876: LD_VAR 0 23
50880: PPUSH
50881: CALL_OW 308
50885: NOT
50886: PUSH
50887: LD_VAR 0 4
50891: PUSH
50892: LD_VAR 0 7
50896: ARRAY
50897: PPUSH
50898: CALL_OW 314
50902: NOT
50903: AND
50904: IFFALSE 50928
// ComMoveToArea ( group [ i ] , f_heal ) else
50906: LD_VAR 0 4
50910: PUSH
50911: LD_VAR 0 7
50915: ARRAY
50916: PPUSH
50917: LD_VAR 0 23
50921: PPUSH
50922: CALL_OW 113
50926: GO 51134
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50928: LD_VAR 0 4
50932: PUSH
50933: LD_VAR 0 7
50937: ARRAY
50938: PPUSH
50939: CALL 49546 0 1
50943: PPUSH
50944: CALL_OW 256
50948: PUSH
50949: LD_INT 1000
50951: EQUAL
50952: IFFALSE 50971
// ComStop ( group [ i ] ) else
50954: LD_VAR 0 4
50958: PUSH
50959: LD_VAR 0 7
50963: ARRAY
50964: PPUSH
50965: CALL_OW 141
50969: GO 51134
// if not HasTask ( group [ i ] ) and to_heal then
50971: LD_VAR 0 4
50975: PUSH
50976: LD_VAR 0 7
50980: ARRAY
50981: PPUSH
50982: CALL_OW 314
50986: NOT
50987: PUSH
50988: LD_VAR 0 30
50992: AND
50993: IFFALSE 51134
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50995: LD_ADDR_VAR 0 13
50999: PUSH
51000: LD_VAR 0 30
51004: PPUSH
51005: LD_INT 3
51007: PUSH
51008: LD_INT 54
51010: PUSH
51011: EMPTY
51012: LIST
51013: PUSH
51014: EMPTY
51015: LIST
51016: LIST
51017: PPUSH
51018: CALL_OW 72
51022: PPUSH
51023: LD_VAR 0 4
51027: PUSH
51028: LD_VAR 0 7
51032: ARRAY
51033: PPUSH
51034: CALL_OW 74
51038: ST_TO_ADDR
// if z then
51039: LD_VAR 0 13
51043: IFFALSE 51134
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
51045: LD_INT 91
51047: PUSH
51048: LD_VAR 0 13
51052: PUSH
51053: LD_INT 10
51055: PUSH
51056: EMPTY
51057: LIST
51058: LIST
51059: LIST
51060: PUSH
51061: LD_INT 81
51063: PUSH
51064: LD_VAR 0 13
51068: PPUSH
51069: CALL_OW 255
51073: PUSH
51074: EMPTY
51075: LIST
51076: LIST
51077: PUSH
51078: EMPTY
51079: LIST
51080: LIST
51081: PPUSH
51082: CALL_OW 69
51086: PUSH
51087: LD_INT 0
51089: EQUAL
51090: IFFALSE 51114
// ComHeal ( group [ i ] , z ) else
51092: LD_VAR 0 4
51096: PUSH
51097: LD_VAR 0 7
51101: ARRAY
51102: PPUSH
51103: LD_VAR 0 13
51107: PPUSH
51108: CALL_OW 128
51112: GO 51134
// ComMoveToArea ( group [ i ] , f_heal ) ;
51114: LD_VAR 0 4
51118: PUSH
51119: LD_VAR 0 7
51123: ARRAY
51124: PPUSH
51125: LD_VAR 0 23
51129: PPUSH
51130: CALL_OW 113
// end ; continue ;
51134: GO 50165
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
51136: LD_VAR 0 4
51140: PUSH
51141: LD_VAR 0 7
51145: ARRAY
51146: PPUSH
51147: CALL_OW 256
51151: PUSH
51152: LD_INT 700
51154: LESS
51155: PUSH
51156: LD_VAR 0 4
51160: PUSH
51161: LD_VAR 0 7
51165: ARRAY
51166: PUSH
51167: LD_VAR 0 30
51171: IN
51172: NOT
51173: AND
51174: IFFALSE 51198
// to_heal := to_heal union group [ i ] ;
51176: LD_ADDR_VAR 0 30
51180: PUSH
51181: LD_VAR 0 30
51185: PUSH
51186: LD_VAR 0 4
51190: PUSH
51191: LD_VAR 0 7
51195: ARRAY
51196: UNION
51197: ST_TO_ADDR
// if group [ i ] in to_heal then
51198: LD_VAR 0 4
51202: PUSH
51203: LD_VAR 0 7
51207: ARRAY
51208: PUSH
51209: LD_VAR 0 30
51213: IN
51214: IFFALSE 51323
// begin if GetLives ( group [ i ] ) = 1000 then
51216: LD_VAR 0 4
51220: PUSH
51221: LD_VAR 0 7
51225: ARRAY
51226: PPUSH
51227: CALL_OW 256
51231: PUSH
51232: LD_INT 1000
51234: EQUAL
51235: IFFALSE 51261
// to_heal := to_heal diff group [ i ] else
51237: LD_ADDR_VAR 0 30
51241: PUSH
51242: LD_VAR 0 30
51246: PUSH
51247: LD_VAR 0 4
51251: PUSH
51252: LD_VAR 0 7
51256: ARRAY
51257: DIFF
51258: ST_TO_ADDR
51259: GO 51323
// begin if not IsInArea ( group [ i ] , to_heal ) then
51261: LD_VAR 0 4
51265: PUSH
51266: LD_VAR 0 7
51270: ARRAY
51271: PPUSH
51272: LD_VAR 0 30
51276: PPUSH
51277: CALL_OW 308
51281: NOT
51282: IFFALSE 51306
// ComMoveToArea ( group [ i ] , f_heal ) else
51284: LD_VAR 0 4
51288: PUSH
51289: LD_VAR 0 7
51293: ARRAY
51294: PPUSH
51295: LD_VAR 0 23
51299: PPUSH
51300: CALL_OW 113
51304: GO 51321
// ComHold ( group [ i ] ) ;
51306: LD_VAR 0 4
51310: PUSH
51311: LD_VAR 0 7
51315: ARRAY
51316: PPUSH
51317: CALL_OW 140
// continue ;
51321: GO 50165
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51323: LD_VAR 0 4
51327: PUSH
51328: LD_VAR 0 7
51332: ARRAY
51333: PPUSH
51334: LD_INT 10
51336: PPUSH
51337: CALL 47943 0 2
51341: NOT
51342: PUSH
51343: LD_VAR 0 16
51347: PUSH
51348: LD_VAR 0 7
51352: ARRAY
51353: PUSH
51354: EMPTY
51355: EQUAL
51356: NOT
51357: AND
51358: IFFALSE 51624
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51360: LD_VAR 0 4
51364: PUSH
51365: LD_VAR 0 7
51369: ARRAY
51370: PPUSH
51371: CALL_OW 262
51375: PUSH
51376: LD_INT 1
51378: PUSH
51379: LD_INT 2
51381: PUSH
51382: EMPTY
51383: LIST
51384: LIST
51385: IN
51386: IFFALSE 51427
// if GetFuel ( group [ i ] ) < 10 then
51388: LD_VAR 0 4
51392: PUSH
51393: LD_VAR 0 7
51397: ARRAY
51398: PPUSH
51399: CALL_OW 261
51403: PUSH
51404: LD_INT 10
51406: LESS
51407: IFFALSE 51427
// SetFuel ( group [ i ] , 12 ) ;
51409: LD_VAR 0 4
51413: PUSH
51414: LD_VAR 0 7
51418: ARRAY
51419: PPUSH
51420: LD_INT 12
51422: PPUSH
51423: CALL_OW 240
// if units_path [ i ] then
51427: LD_VAR 0 16
51431: PUSH
51432: LD_VAR 0 7
51436: ARRAY
51437: IFFALSE 51622
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51439: LD_VAR 0 4
51443: PUSH
51444: LD_VAR 0 7
51448: ARRAY
51449: PPUSH
51450: LD_VAR 0 16
51454: PUSH
51455: LD_VAR 0 7
51459: ARRAY
51460: PUSH
51461: LD_INT 1
51463: ARRAY
51464: PUSH
51465: LD_INT 1
51467: ARRAY
51468: PPUSH
51469: LD_VAR 0 16
51473: PUSH
51474: LD_VAR 0 7
51478: ARRAY
51479: PUSH
51480: LD_INT 1
51482: ARRAY
51483: PUSH
51484: LD_INT 2
51486: ARRAY
51487: PPUSH
51488: CALL_OW 297
51492: PUSH
51493: LD_INT 6
51495: GREATER
51496: IFFALSE 51571
// begin if not HasTask ( group [ i ] ) then
51498: LD_VAR 0 4
51502: PUSH
51503: LD_VAR 0 7
51507: ARRAY
51508: PPUSH
51509: CALL_OW 314
51513: NOT
51514: IFFALSE 51569
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51516: LD_VAR 0 4
51520: PUSH
51521: LD_VAR 0 7
51525: ARRAY
51526: PPUSH
51527: LD_VAR 0 16
51531: PUSH
51532: LD_VAR 0 7
51536: ARRAY
51537: PUSH
51538: LD_INT 1
51540: ARRAY
51541: PUSH
51542: LD_INT 1
51544: ARRAY
51545: PPUSH
51546: LD_VAR 0 16
51550: PUSH
51551: LD_VAR 0 7
51555: ARRAY
51556: PUSH
51557: LD_INT 1
51559: ARRAY
51560: PUSH
51561: LD_INT 2
51563: ARRAY
51564: PPUSH
51565: CALL_OW 114
// end else
51569: GO 51622
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51571: LD_ADDR_VAR 0 15
51575: PUSH
51576: LD_VAR 0 16
51580: PUSH
51581: LD_VAR 0 7
51585: ARRAY
51586: PPUSH
51587: LD_INT 1
51589: PPUSH
51590: CALL_OW 3
51594: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51595: LD_ADDR_VAR 0 16
51599: PUSH
51600: LD_VAR 0 16
51604: PPUSH
51605: LD_VAR 0 7
51609: PPUSH
51610: LD_VAR 0 15
51614: PPUSH
51615: CALL_OW 1
51619: ST_TO_ADDR
// continue ;
51620: GO 50165
// end ; end ; end else
51622: GO 54260
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51624: LD_ADDR_VAR 0 14
51628: PUSH
51629: LD_INT 81
51631: PUSH
51632: LD_VAR 0 4
51636: PUSH
51637: LD_VAR 0 7
51641: ARRAY
51642: PPUSH
51643: CALL_OW 255
51647: PUSH
51648: EMPTY
51649: LIST
51650: LIST
51651: PPUSH
51652: CALL_OW 69
51656: ST_TO_ADDR
// if not tmp then
51657: LD_VAR 0 14
51661: NOT
51662: IFFALSE 51666
// continue ;
51664: GO 50165
// if f_ignore_area then
51666: LD_VAR 0 17
51670: IFFALSE 51758
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51672: LD_ADDR_VAR 0 15
51676: PUSH
51677: LD_VAR 0 14
51681: PPUSH
51682: LD_INT 3
51684: PUSH
51685: LD_INT 92
51687: PUSH
51688: LD_VAR 0 17
51692: PUSH
51693: LD_INT 1
51695: ARRAY
51696: PUSH
51697: LD_VAR 0 17
51701: PUSH
51702: LD_INT 2
51704: ARRAY
51705: PUSH
51706: LD_VAR 0 17
51710: PUSH
51711: LD_INT 3
51713: ARRAY
51714: PUSH
51715: EMPTY
51716: LIST
51717: LIST
51718: LIST
51719: LIST
51720: PUSH
51721: EMPTY
51722: LIST
51723: LIST
51724: PPUSH
51725: CALL_OW 72
51729: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51730: LD_VAR 0 14
51734: PUSH
51735: LD_VAR 0 15
51739: DIFF
51740: IFFALSE 51758
// tmp := tmp diff tmp2 ;
51742: LD_ADDR_VAR 0 14
51746: PUSH
51747: LD_VAR 0 14
51751: PUSH
51752: LD_VAR 0 15
51756: DIFF
51757: ST_TO_ADDR
// end ; if not f_murder then
51758: LD_VAR 0 20
51762: NOT
51763: IFFALSE 51821
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51765: LD_ADDR_VAR 0 15
51769: PUSH
51770: LD_VAR 0 14
51774: PPUSH
51775: LD_INT 3
51777: PUSH
51778: LD_INT 50
51780: PUSH
51781: EMPTY
51782: LIST
51783: PUSH
51784: EMPTY
51785: LIST
51786: LIST
51787: PPUSH
51788: CALL_OW 72
51792: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51793: LD_VAR 0 14
51797: PUSH
51798: LD_VAR 0 15
51802: DIFF
51803: IFFALSE 51821
// tmp := tmp diff tmp2 ;
51805: LD_ADDR_VAR 0 14
51809: PUSH
51810: LD_VAR 0 14
51814: PUSH
51815: LD_VAR 0 15
51819: DIFF
51820: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51821: LD_ADDR_VAR 0 14
51825: PUSH
51826: LD_VAR 0 4
51830: PUSH
51831: LD_VAR 0 7
51835: ARRAY
51836: PPUSH
51837: LD_VAR 0 14
51841: PPUSH
51842: LD_INT 1
51844: PPUSH
51845: LD_INT 1
51847: PPUSH
51848: CALL 21586 0 4
51852: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51853: LD_VAR 0 4
51857: PUSH
51858: LD_VAR 0 7
51862: ARRAY
51863: PPUSH
51864: CALL_OW 257
51868: PUSH
51869: LD_INT 1
51871: EQUAL
51872: IFFALSE 52320
// begin if WantPlant ( group [ i ] ) then
51874: LD_VAR 0 4
51878: PUSH
51879: LD_VAR 0 7
51883: ARRAY
51884: PPUSH
51885: CALL 21087 0 1
51889: IFFALSE 51893
// continue ;
51891: GO 50165
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51893: LD_VAR 0 18
51897: PUSH
51898: LD_VAR 0 4
51902: PUSH
51903: LD_VAR 0 7
51907: ARRAY
51908: PPUSH
51909: CALL_OW 310
51913: NOT
51914: AND
51915: PUSH
51916: LD_VAR 0 14
51920: PUSH
51921: LD_INT 1
51923: ARRAY
51924: PUSH
51925: LD_VAR 0 14
51929: PPUSH
51930: LD_INT 21
51932: PUSH
51933: LD_INT 2
51935: PUSH
51936: EMPTY
51937: LIST
51938: LIST
51939: PUSH
51940: LD_INT 58
51942: PUSH
51943: EMPTY
51944: LIST
51945: PUSH
51946: EMPTY
51947: LIST
51948: LIST
51949: PPUSH
51950: CALL_OW 72
51954: IN
51955: AND
51956: IFFALSE 51992
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51958: LD_VAR 0 4
51962: PUSH
51963: LD_VAR 0 7
51967: ARRAY
51968: PPUSH
51969: LD_VAR 0 14
51973: PUSH
51974: LD_INT 1
51976: ARRAY
51977: PPUSH
51978: CALL_OW 120
// attacking := true ;
51982: LD_ADDR_VAR 0 29
51986: PUSH
51987: LD_INT 1
51989: ST_TO_ADDR
// continue ;
51990: GO 50165
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51992: LD_VAR 0 26
51996: PUSH
51997: LD_VAR 0 4
52001: PUSH
52002: LD_VAR 0 7
52006: ARRAY
52007: PPUSH
52008: CALL_OW 257
52012: PUSH
52013: LD_INT 1
52015: EQUAL
52016: AND
52017: PUSH
52018: LD_VAR 0 4
52022: PUSH
52023: LD_VAR 0 7
52027: ARRAY
52028: PPUSH
52029: CALL_OW 256
52033: PUSH
52034: LD_INT 800
52036: LESS
52037: AND
52038: PUSH
52039: LD_VAR 0 4
52043: PUSH
52044: LD_VAR 0 7
52048: ARRAY
52049: PPUSH
52050: CALL_OW 318
52054: NOT
52055: AND
52056: IFFALSE 52073
// ComCrawl ( group [ i ] ) ;
52058: LD_VAR 0 4
52062: PUSH
52063: LD_VAR 0 7
52067: ARRAY
52068: PPUSH
52069: CALL_OW 137
// if f_mines then
52073: LD_VAR 0 21
52077: IFFALSE 52320
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
52079: LD_VAR 0 14
52083: PUSH
52084: LD_INT 1
52086: ARRAY
52087: PPUSH
52088: CALL_OW 247
52092: PUSH
52093: LD_INT 3
52095: EQUAL
52096: PUSH
52097: LD_VAR 0 14
52101: PUSH
52102: LD_INT 1
52104: ARRAY
52105: PUSH
52106: LD_VAR 0 27
52110: IN
52111: NOT
52112: AND
52113: IFFALSE 52320
// begin x := GetX ( tmp [ 1 ] ) ;
52115: LD_ADDR_VAR 0 10
52119: PUSH
52120: LD_VAR 0 14
52124: PUSH
52125: LD_INT 1
52127: ARRAY
52128: PPUSH
52129: CALL_OW 250
52133: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
52134: LD_ADDR_VAR 0 11
52138: PUSH
52139: LD_VAR 0 14
52143: PUSH
52144: LD_INT 1
52146: ARRAY
52147: PPUSH
52148: CALL_OW 251
52152: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
52153: LD_ADDR_VAR 0 12
52157: PUSH
52158: LD_VAR 0 4
52162: PUSH
52163: LD_VAR 0 7
52167: ARRAY
52168: PPUSH
52169: CALL 48028 0 1
52173: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
52174: LD_VAR 0 4
52178: PUSH
52179: LD_VAR 0 7
52183: ARRAY
52184: PPUSH
52185: LD_VAR 0 10
52189: PPUSH
52190: LD_VAR 0 11
52194: PPUSH
52195: LD_VAR 0 14
52199: PUSH
52200: LD_INT 1
52202: ARRAY
52203: PPUSH
52204: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
52208: LD_VAR 0 4
52212: PUSH
52213: LD_VAR 0 7
52217: ARRAY
52218: PPUSH
52219: LD_VAR 0 10
52223: PPUSH
52224: LD_VAR 0 12
52228: PPUSH
52229: LD_INT 7
52231: PPUSH
52232: CALL_OW 272
52236: PPUSH
52237: LD_VAR 0 11
52241: PPUSH
52242: LD_VAR 0 12
52246: PPUSH
52247: LD_INT 7
52249: PPUSH
52250: CALL_OW 273
52254: PPUSH
52255: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
52259: LD_VAR 0 4
52263: PUSH
52264: LD_VAR 0 7
52268: ARRAY
52269: PPUSH
52270: LD_INT 71
52272: PPUSH
52273: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
52277: LD_ADDR_VAR 0 27
52281: PUSH
52282: LD_VAR 0 27
52286: PPUSH
52287: LD_VAR 0 27
52291: PUSH
52292: LD_INT 1
52294: PLUS
52295: PPUSH
52296: LD_VAR 0 14
52300: PUSH
52301: LD_INT 1
52303: ARRAY
52304: PPUSH
52305: CALL_OW 1
52309: ST_TO_ADDR
// attacking := true ;
52310: LD_ADDR_VAR 0 29
52314: PUSH
52315: LD_INT 1
52317: ST_TO_ADDR
// continue ;
52318: GO 50165
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52320: LD_VAR 0 4
52324: PUSH
52325: LD_VAR 0 7
52329: ARRAY
52330: PPUSH
52331: CALL_OW 257
52335: PUSH
52336: LD_INT 17
52338: EQUAL
52339: PUSH
52340: LD_VAR 0 4
52344: PUSH
52345: LD_VAR 0 7
52349: ARRAY
52350: PPUSH
52351: CALL_OW 110
52355: PUSH
52356: LD_INT 71
52358: EQUAL
52359: NOT
52360: AND
52361: IFFALSE 52507
// begin attacking := false ;
52363: LD_ADDR_VAR 0 29
52367: PUSH
52368: LD_INT 0
52370: ST_TO_ADDR
// k := 5 ;
52371: LD_ADDR_VAR 0 9
52375: PUSH
52376: LD_INT 5
52378: ST_TO_ADDR
// if tmp < k then
52379: LD_VAR 0 14
52383: PUSH
52384: LD_VAR 0 9
52388: LESS
52389: IFFALSE 52401
// k := tmp ;
52391: LD_ADDR_VAR 0 9
52395: PUSH
52396: LD_VAR 0 14
52400: ST_TO_ADDR
// for j = 1 to k do
52401: LD_ADDR_VAR 0 8
52405: PUSH
52406: DOUBLE
52407: LD_INT 1
52409: DEC
52410: ST_TO_ADDR
52411: LD_VAR 0 9
52415: PUSH
52416: FOR_TO
52417: IFFALSE 52505
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52419: LD_VAR 0 14
52423: PUSH
52424: LD_VAR 0 8
52428: ARRAY
52429: PUSH
52430: LD_VAR 0 14
52434: PPUSH
52435: LD_INT 58
52437: PUSH
52438: EMPTY
52439: LIST
52440: PPUSH
52441: CALL_OW 72
52445: IN
52446: NOT
52447: IFFALSE 52503
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52449: LD_VAR 0 4
52453: PUSH
52454: LD_VAR 0 7
52458: ARRAY
52459: PPUSH
52460: LD_VAR 0 14
52464: PUSH
52465: LD_VAR 0 8
52469: ARRAY
52470: PPUSH
52471: CALL_OW 115
// attacking := true ;
52475: LD_ADDR_VAR 0 29
52479: PUSH
52480: LD_INT 1
52482: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52483: LD_VAR 0 4
52487: PUSH
52488: LD_VAR 0 7
52492: ARRAY
52493: PPUSH
52494: LD_INT 71
52496: PPUSH
52497: CALL_OW 109
// continue ;
52501: GO 52416
// end ; end ;
52503: GO 52416
52505: POP
52506: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52507: LD_VAR 0 4
52511: PUSH
52512: LD_VAR 0 7
52516: ARRAY
52517: PPUSH
52518: CALL_OW 257
52522: PUSH
52523: LD_INT 8
52525: EQUAL
52526: PUSH
52527: LD_VAR 0 4
52531: PUSH
52532: LD_VAR 0 7
52536: ARRAY
52537: PPUSH
52538: CALL_OW 264
52542: PUSH
52543: LD_INT 28
52545: PUSH
52546: LD_INT 45
52548: PUSH
52549: LD_INT 7
52551: PUSH
52552: LD_INT 47
52554: PUSH
52555: EMPTY
52556: LIST
52557: LIST
52558: LIST
52559: LIST
52560: IN
52561: OR
52562: IFFALSE 52792
// begin attacking := false ;
52564: LD_ADDR_VAR 0 29
52568: PUSH
52569: LD_INT 0
52571: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52572: LD_VAR 0 14
52576: PUSH
52577: LD_INT 1
52579: ARRAY
52580: PPUSH
52581: CALL_OW 266
52585: PUSH
52586: LD_INT 32
52588: PUSH
52589: LD_INT 31
52591: PUSH
52592: LD_INT 33
52594: PUSH
52595: LD_INT 4
52597: PUSH
52598: LD_INT 5
52600: PUSH
52601: EMPTY
52602: LIST
52603: LIST
52604: LIST
52605: LIST
52606: LIST
52607: IN
52608: IFFALSE 52792
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52610: LD_ADDR_VAR 0 9
52614: PUSH
52615: LD_VAR 0 14
52619: PUSH
52620: LD_INT 1
52622: ARRAY
52623: PPUSH
52624: CALL_OW 266
52628: PPUSH
52629: LD_VAR 0 14
52633: PUSH
52634: LD_INT 1
52636: ARRAY
52637: PPUSH
52638: CALL_OW 250
52642: PPUSH
52643: LD_VAR 0 14
52647: PUSH
52648: LD_INT 1
52650: ARRAY
52651: PPUSH
52652: CALL_OW 251
52656: PPUSH
52657: LD_VAR 0 14
52661: PUSH
52662: LD_INT 1
52664: ARRAY
52665: PPUSH
52666: CALL_OW 254
52670: PPUSH
52671: LD_VAR 0 14
52675: PUSH
52676: LD_INT 1
52678: ARRAY
52679: PPUSH
52680: CALL_OW 248
52684: PPUSH
52685: LD_INT 0
52687: PPUSH
52688: CALL 29398 0 6
52692: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52693: LD_ADDR_VAR 0 8
52697: PUSH
52698: LD_VAR 0 4
52702: PUSH
52703: LD_VAR 0 7
52707: ARRAY
52708: PPUSH
52709: LD_VAR 0 9
52713: PPUSH
52714: CALL 48091 0 2
52718: ST_TO_ADDR
// if j then
52719: LD_VAR 0 8
52723: IFFALSE 52792
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52725: LD_VAR 0 8
52729: PUSH
52730: LD_INT 1
52732: ARRAY
52733: PPUSH
52734: LD_VAR 0 8
52738: PUSH
52739: LD_INT 2
52741: ARRAY
52742: PPUSH
52743: CALL_OW 488
52747: IFFALSE 52792
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52749: LD_VAR 0 4
52753: PUSH
52754: LD_VAR 0 7
52758: ARRAY
52759: PPUSH
52760: LD_VAR 0 8
52764: PUSH
52765: LD_INT 1
52767: ARRAY
52768: PPUSH
52769: LD_VAR 0 8
52773: PUSH
52774: LD_INT 2
52776: ARRAY
52777: PPUSH
52778: CALL_OW 116
// attacking := true ;
52782: LD_ADDR_VAR 0 29
52786: PUSH
52787: LD_INT 1
52789: ST_TO_ADDR
// continue ;
52790: GO 50165
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52792: LD_VAR 0 4
52796: PUSH
52797: LD_VAR 0 7
52801: ARRAY
52802: PPUSH
52803: CALL_OW 265
52807: PUSH
52808: LD_INT 11
52810: EQUAL
52811: IFFALSE 53089
// begin k := 10 ;
52813: LD_ADDR_VAR 0 9
52817: PUSH
52818: LD_INT 10
52820: ST_TO_ADDR
// x := 0 ;
52821: LD_ADDR_VAR 0 10
52825: PUSH
52826: LD_INT 0
52828: ST_TO_ADDR
// if tmp < k then
52829: LD_VAR 0 14
52833: PUSH
52834: LD_VAR 0 9
52838: LESS
52839: IFFALSE 52851
// k := tmp ;
52841: LD_ADDR_VAR 0 9
52845: PUSH
52846: LD_VAR 0 14
52850: ST_TO_ADDR
// for j = k downto 1 do
52851: LD_ADDR_VAR 0 8
52855: PUSH
52856: DOUBLE
52857: LD_VAR 0 9
52861: INC
52862: ST_TO_ADDR
52863: LD_INT 1
52865: PUSH
52866: FOR_DOWNTO
52867: IFFALSE 52942
// begin if GetType ( tmp [ j ] ) = unit_human then
52869: LD_VAR 0 14
52873: PUSH
52874: LD_VAR 0 8
52878: ARRAY
52879: PPUSH
52880: CALL_OW 247
52884: PUSH
52885: LD_INT 1
52887: EQUAL
52888: IFFALSE 52940
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52890: LD_VAR 0 4
52894: PUSH
52895: LD_VAR 0 7
52899: ARRAY
52900: PPUSH
52901: LD_VAR 0 14
52905: PUSH
52906: LD_VAR 0 8
52910: ARRAY
52911: PPUSH
52912: CALL 48362 0 2
// x := tmp [ j ] ;
52916: LD_ADDR_VAR 0 10
52920: PUSH
52921: LD_VAR 0 14
52925: PUSH
52926: LD_VAR 0 8
52930: ARRAY
52931: ST_TO_ADDR
// attacking := true ;
52932: LD_ADDR_VAR 0 29
52936: PUSH
52937: LD_INT 1
52939: ST_TO_ADDR
// end ; end ;
52940: GO 52866
52942: POP
52943: POP
// if not x then
52944: LD_VAR 0 10
52948: NOT
52949: IFFALSE 53089
// begin attacking := true ;
52951: LD_ADDR_VAR 0 29
52955: PUSH
52956: LD_INT 1
52958: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52959: LD_VAR 0 4
52963: PUSH
52964: LD_VAR 0 7
52968: ARRAY
52969: PPUSH
52970: CALL_OW 250
52974: PPUSH
52975: LD_VAR 0 4
52979: PUSH
52980: LD_VAR 0 7
52984: ARRAY
52985: PPUSH
52986: CALL_OW 251
52990: PPUSH
52991: CALL_OW 546
52995: PUSH
52996: LD_INT 2
52998: ARRAY
52999: PUSH
53000: LD_VAR 0 14
53004: PUSH
53005: LD_INT 1
53007: ARRAY
53008: PPUSH
53009: CALL_OW 250
53013: PPUSH
53014: LD_VAR 0 14
53018: PUSH
53019: LD_INT 1
53021: ARRAY
53022: PPUSH
53023: CALL_OW 251
53027: PPUSH
53028: CALL_OW 546
53032: PUSH
53033: LD_INT 2
53035: ARRAY
53036: EQUAL
53037: IFFALSE 53065
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
53039: LD_VAR 0 4
53043: PUSH
53044: LD_VAR 0 7
53048: ARRAY
53049: PPUSH
53050: LD_VAR 0 14
53054: PUSH
53055: LD_INT 1
53057: ARRAY
53058: PPUSH
53059: CALL 48362 0 2
53063: GO 53089
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53065: LD_VAR 0 4
53069: PUSH
53070: LD_VAR 0 7
53074: ARRAY
53075: PPUSH
53076: LD_VAR 0 14
53080: PUSH
53081: LD_INT 1
53083: ARRAY
53084: PPUSH
53085: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
53089: LD_VAR 0 4
53093: PUSH
53094: LD_VAR 0 7
53098: ARRAY
53099: PPUSH
53100: CALL_OW 264
53104: PUSH
53105: LD_INT 29
53107: EQUAL
53108: IFFALSE 53474
// begin if WantsToAttack ( group [ i ] ) in bombed then
53110: LD_VAR 0 4
53114: PUSH
53115: LD_VAR 0 7
53119: ARRAY
53120: PPUSH
53121: CALL_OW 319
53125: PUSH
53126: LD_VAR 0 28
53130: IN
53131: IFFALSE 53135
// continue ;
53133: GO 50165
// k := 8 ;
53135: LD_ADDR_VAR 0 9
53139: PUSH
53140: LD_INT 8
53142: ST_TO_ADDR
// x := 0 ;
53143: LD_ADDR_VAR 0 10
53147: PUSH
53148: LD_INT 0
53150: ST_TO_ADDR
// if tmp < k then
53151: LD_VAR 0 14
53155: PUSH
53156: LD_VAR 0 9
53160: LESS
53161: IFFALSE 53173
// k := tmp ;
53163: LD_ADDR_VAR 0 9
53167: PUSH
53168: LD_VAR 0 14
53172: ST_TO_ADDR
// for j = 1 to k do
53173: LD_ADDR_VAR 0 8
53177: PUSH
53178: DOUBLE
53179: LD_INT 1
53181: DEC
53182: ST_TO_ADDR
53183: LD_VAR 0 9
53187: PUSH
53188: FOR_TO
53189: IFFALSE 53321
// begin if GetType ( tmp [ j ] ) = unit_building then
53191: LD_VAR 0 14
53195: PUSH
53196: LD_VAR 0 8
53200: ARRAY
53201: PPUSH
53202: CALL_OW 247
53206: PUSH
53207: LD_INT 3
53209: EQUAL
53210: IFFALSE 53319
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
53212: LD_VAR 0 14
53216: PUSH
53217: LD_VAR 0 8
53221: ARRAY
53222: PUSH
53223: LD_VAR 0 28
53227: IN
53228: NOT
53229: PUSH
53230: LD_VAR 0 14
53234: PUSH
53235: LD_VAR 0 8
53239: ARRAY
53240: PPUSH
53241: CALL_OW 313
53245: AND
53246: IFFALSE 53319
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53248: LD_VAR 0 4
53252: PUSH
53253: LD_VAR 0 7
53257: ARRAY
53258: PPUSH
53259: LD_VAR 0 14
53263: PUSH
53264: LD_VAR 0 8
53268: ARRAY
53269: PPUSH
53270: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
53274: LD_ADDR_VAR 0 28
53278: PUSH
53279: LD_VAR 0 28
53283: PPUSH
53284: LD_VAR 0 28
53288: PUSH
53289: LD_INT 1
53291: PLUS
53292: PPUSH
53293: LD_VAR 0 14
53297: PUSH
53298: LD_VAR 0 8
53302: ARRAY
53303: PPUSH
53304: CALL_OW 1
53308: ST_TO_ADDR
// attacking := true ;
53309: LD_ADDR_VAR 0 29
53313: PUSH
53314: LD_INT 1
53316: ST_TO_ADDR
// break ;
53317: GO 53321
// end ; end ;
53319: GO 53188
53321: POP
53322: POP
// if not attacking and f_attack_depot then
53323: LD_VAR 0 29
53327: NOT
53328: PUSH
53329: LD_VAR 0 25
53333: AND
53334: IFFALSE 53429
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53336: LD_ADDR_VAR 0 13
53340: PUSH
53341: LD_VAR 0 14
53345: PPUSH
53346: LD_INT 2
53348: PUSH
53349: LD_INT 30
53351: PUSH
53352: LD_INT 0
53354: PUSH
53355: EMPTY
53356: LIST
53357: LIST
53358: PUSH
53359: LD_INT 30
53361: PUSH
53362: LD_INT 1
53364: PUSH
53365: EMPTY
53366: LIST
53367: LIST
53368: PUSH
53369: EMPTY
53370: LIST
53371: LIST
53372: LIST
53373: PPUSH
53374: CALL_OW 72
53378: ST_TO_ADDR
// if z then
53379: LD_VAR 0 13
53383: IFFALSE 53429
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53385: LD_VAR 0 4
53389: PUSH
53390: LD_VAR 0 7
53394: ARRAY
53395: PPUSH
53396: LD_VAR 0 13
53400: PPUSH
53401: LD_VAR 0 4
53405: PUSH
53406: LD_VAR 0 7
53410: ARRAY
53411: PPUSH
53412: CALL_OW 74
53416: PPUSH
53417: CALL_OW 115
// attacking := true ;
53421: LD_ADDR_VAR 0 29
53425: PUSH
53426: LD_INT 1
53428: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53429: LD_VAR 0 4
53433: PUSH
53434: LD_VAR 0 7
53438: ARRAY
53439: PPUSH
53440: CALL_OW 256
53444: PUSH
53445: LD_INT 500
53447: LESS
53448: IFFALSE 53474
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53450: LD_VAR 0 4
53454: PUSH
53455: LD_VAR 0 7
53459: ARRAY
53460: PPUSH
53461: LD_VAR 0 14
53465: PUSH
53466: LD_INT 1
53468: ARRAY
53469: PPUSH
53470: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53474: LD_VAR 0 4
53478: PUSH
53479: LD_VAR 0 7
53483: ARRAY
53484: PPUSH
53485: CALL_OW 264
53489: PUSH
53490: LD_INT 49
53492: EQUAL
53493: IFFALSE 53614
// begin if not HasTask ( group [ i ] ) then
53495: LD_VAR 0 4
53499: PUSH
53500: LD_VAR 0 7
53504: ARRAY
53505: PPUSH
53506: CALL_OW 314
53510: NOT
53511: IFFALSE 53614
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53513: LD_ADDR_VAR 0 9
53517: PUSH
53518: LD_INT 81
53520: PUSH
53521: LD_VAR 0 4
53525: PUSH
53526: LD_VAR 0 7
53530: ARRAY
53531: PPUSH
53532: CALL_OW 255
53536: PUSH
53537: EMPTY
53538: LIST
53539: LIST
53540: PPUSH
53541: CALL_OW 69
53545: PPUSH
53546: LD_VAR 0 4
53550: PUSH
53551: LD_VAR 0 7
53555: ARRAY
53556: PPUSH
53557: CALL_OW 74
53561: ST_TO_ADDR
// if k then
53562: LD_VAR 0 9
53566: IFFALSE 53614
// if GetDistUnits ( group [ i ] , k ) > 10 then
53568: LD_VAR 0 4
53572: PUSH
53573: LD_VAR 0 7
53577: ARRAY
53578: PPUSH
53579: LD_VAR 0 9
53583: PPUSH
53584: CALL_OW 296
53588: PUSH
53589: LD_INT 10
53591: GREATER
53592: IFFALSE 53614
// ComMoveUnit ( group [ i ] , k ) ;
53594: LD_VAR 0 4
53598: PUSH
53599: LD_VAR 0 7
53603: ARRAY
53604: PPUSH
53605: LD_VAR 0 9
53609: PPUSH
53610: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53614: LD_VAR 0 4
53618: PUSH
53619: LD_VAR 0 7
53623: ARRAY
53624: PPUSH
53625: CALL_OW 256
53629: PUSH
53630: LD_INT 250
53632: LESS
53633: PUSH
53634: LD_VAR 0 4
53638: PUSH
53639: LD_VAR 0 7
53643: ARRAY
53644: PUSH
53645: LD_INT 21
53647: PUSH
53648: LD_INT 2
53650: PUSH
53651: EMPTY
53652: LIST
53653: LIST
53654: PUSH
53655: LD_INT 23
53657: PUSH
53658: LD_INT 2
53660: PUSH
53661: EMPTY
53662: LIST
53663: LIST
53664: PUSH
53665: EMPTY
53666: LIST
53667: LIST
53668: PPUSH
53669: CALL_OW 69
53673: IN
53674: AND
53675: IFFALSE 53800
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53677: LD_ADDR_VAR 0 9
53681: PUSH
53682: LD_OWVAR 3
53686: PUSH
53687: LD_VAR 0 4
53691: PUSH
53692: LD_VAR 0 7
53696: ARRAY
53697: DIFF
53698: PPUSH
53699: LD_VAR 0 4
53703: PUSH
53704: LD_VAR 0 7
53708: ARRAY
53709: PPUSH
53710: CALL_OW 74
53714: ST_TO_ADDR
// if not k then
53715: LD_VAR 0 9
53719: NOT
53720: IFFALSE 53724
// continue ;
53722: GO 50165
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53724: LD_VAR 0 9
53728: PUSH
53729: LD_INT 81
53731: PUSH
53732: LD_VAR 0 4
53736: PUSH
53737: LD_VAR 0 7
53741: ARRAY
53742: PPUSH
53743: CALL_OW 255
53747: PUSH
53748: EMPTY
53749: LIST
53750: LIST
53751: PPUSH
53752: CALL_OW 69
53756: IN
53757: PUSH
53758: LD_VAR 0 9
53762: PPUSH
53763: LD_VAR 0 4
53767: PUSH
53768: LD_VAR 0 7
53772: ARRAY
53773: PPUSH
53774: CALL_OW 296
53778: PUSH
53779: LD_INT 5
53781: LESS
53782: AND
53783: IFFALSE 53800
// ComAutodestruct ( group [ i ] ) ;
53785: LD_VAR 0 4
53789: PUSH
53790: LD_VAR 0 7
53794: ARRAY
53795: PPUSH
53796: CALL 48260 0 1
// end ; if f_attack_depot then
53800: LD_VAR 0 25
53804: IFFALSE 53916
// begin k := 6 ;
53806: LD_ADDR_VAR 0 9
53810: PUSH
53811: LD_INT 6
53813: ST_TO_ADDR
// if tmp < k then
53814: LD_VAR 0 14
53818: PUSH
53819: LD_VAR 0 9
53823: LESS
53824: IFFALSE 53836
// k := tmp ;
53826: LD_ADDR_VAR 0 9
53830: PUSH
53831: LD_VAR 0 14
53835: ST_TO_ADDR
// for j = 1 to k do
53836: LD_ADDR_VAR 0 8
53840: PUSH
53841: DOUBLE
53842: LD_INT 1
53844: DEC
53845: ST_TO_ADDR
53846: LD_VAR 0 9
53850: PUSH
53851: FOR_TO
53852: IFFALSE 53914
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53854: LD_VAR 0 8
53858: PPUSH
53859: CALL_OW 266
53863: PUSH
53864: LD_INT 0
53866: PUSH
53867: LD_INT 1
53869: PUSH
53870: EMPTY
53871: LIST
53872: LIST
53873: IN
53874: IFFALSE 53912
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53876: LD_VAR 0 4
53880: PUSH
53881: LD_VAR 0 7
53885: ARRAY
53886: PPUSH
53887: LD_VAR 0 14
53891: PUSH
53892: LD_VAR 0 8
53896: ARRAY
53897: PPUSH
53898: CALL_OW 115
// attacking := true ;
53902: LD_ADDR_VAR 0 29
53906: PUSH
53907: LD_INT 1
53909: ST_TO_ADDR
// break ;
53910: GO 53914
// end ;
53912: GO 53851
53914: POP
53915: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53916: LD_VAR 0 4
53920: PUSH
53921: LD_VAR 0 7
53925: ARRAY
53926: PPUSH
53927: CALL_OW 302
53931: PUSH
53932: LD_VAR 0 29
53936: NOT
53937: AND
53938: IFFALSE 54260
// begin if GetTag ( group [ i ] ) = 71 then
53940: LD_VAR 0 4
53944: PUSH
53945: LD_VAR 0 7
53949: ARRAY
53950: PPUSH
53951: CALL_OW 110
53955: PUSH
53956: LD_INT 71
53958: EQUAL
53959: IFFALSE 54000
// begin if HasTask ( group [ i ] ) then
53961: LD_VAR 0 4
53965: PUSH
53966: LD_VAR 0 7
53970: ARRAY
53971: PPUSH
53972: CALL_OW 314
53976: IFFALSE 53982
// continue else
53978: GO 50165
53980: GO 54000
// SetTag ( group [ i ] , 0 ) ;
53982: LD_VAR 0 4
53986: PUSH
53987: LD_VAR 0 7
53991: ARRAY
53992: PPUSH
53993: LD_INT 0
53995: PPUSH
53996: CALL_OW 109
// end ; k := 8 ;
54000: LD_ADDR_VAR 0 9
54004: PUSH
54005: LD_INT 8
54007: ST_TO_ADDR
// x := 0 ;
54008: LD_ADDR_VAR 0 10
54012: PUSH
54013: LD_INT 0
54015: ST_TO_ADDR
// if tmp < k then
54016: LD_VAR 0 14
54020: PUSH
54021: LD_VAR 0 9
54025: LESS
54026: IFFALSE 54038
// k := tmp ;
54028: LD_ADDR_VAR 0 9
54032: PUSH
54033: LD_VAR 0 14
54037: ST_TO_ADDR
// for j = 1 to k do
54038: LD_ADDR_VAR 0 8
54042: PUSH
54043: DOUBLE
54044: LD_INT 1
54046: DEC
54047: ST_TO_ADDR
54048: LD_VAR 0 9
54052: PUSH
54053: FOR_TO
54054: IFFALSE 54152
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
54056: LD_VAR 0 14
54060: PUSH
54061: LD_VAR 0 8
54065: ARRAY
54066: PPUSH
54067: CALL_OW 247
54071: PUSH
54072: LD_INT 1
54074: EQUAL
54075: PUSH
54076: LD_VAR 0 14
54080: PUSH
54081: LD_VAR 0 8
54085: ARRAY
54086: PPUSH
54087: CALL_OW 256
54091: PUSH
54092: LD_INT 250
54094: LESS
54095: PUSH
54096: LD_VAR 0 20
54100: AND
54101: PUSH
54102: LD_VAR 0 20
54106: NOT
54107: PUSH
54108: LD_VAR 0 14
54112: PUSH
54113: LD_VAR 0 8
54117: ARRAY
54118: PPUSH
54119: CALL_OW 256
54123: PUSH
54124: LD_INT 250
54126: GREATEREQUAL
54127: AND
54128: OR
54129: AND
54130: IFFALSE 54150
// begin x := tmp [ j ] ;
54132: LD_ADDR_VAR 0 10
54136: PUSH
54137: LD_VAR 0 14
54141: PUSH
54142: LD_VAR 0 8
54146: ARRAY
54147: ST_TO_ADDR
// break ;
54148: GO 54152
// end ;
54150: GO 54053
54152: POP
54153: POP
// if x then
54154: LD_VAR 0 10
54158: IFFALSE 54182
// ComAttackUnit ( group [ i ] , x ) else
54160: LD_VAR 0 4
54164: PUSH
54165: LD_VAR 0 7
54169: ARRAY
54170: PPUSH
54171: LD_VAR 0 10
54175: PPUSH
54176: CALL_OW 115
54180: GO 54206
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
54182: LD_VAR 0 4
54186: PUSH
54187: LD_VAR 0 7
54191: ARRAY
54192: PPUSH
54193: LD_VAR 0 14
54197: PUSH
54198: LD_INT 1
54200: ARRAY
54201: PPUSH
54202: CALL_OW 115
// if not HasTask ( group [ i ] ) then
54206: LD_VAR 0 4
54210: PUSH
54211: LD_VAR 0 7
54215: ARRAY
54216: PPUSH
54217: CALL_OW 314
54221: NOT
54222: IFFALSE 54260
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
54224: LD_VAR 0 4
54228: PUSH
54229: LD_VAR 0 7
54233: ARRAY
54234: PPUSH
54235: LD_VAR 0 14
54239: PPUSH
54240: LD_VAR 0 4
54244: PUSH
54245: LD_VAR 0 7
54249: ARRAY
54250: PPUSH
54251: CALL_OW 74
54255: PPUSH
54256: CALL_OW 115
// end ; end ; end ;
54260: GO 50165
54262: POP
54263: POP
// wait ( 0 0$1 ) ;
54264: LD_INT 35
54266: PPUSH
54267: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
54271: LD_VAR 0 4
54275: PUSH
54276: EMPTY
54277: EQUAL
54278: PUSH
54279: LD_INT 81
54281: PUSH
54282: LD_VAR 0 35
54286: PUSH
54287: EMPTY
54288: LIST
54289: LIST
54290: PPUSH
54291: CALL_OW 69
54295: NOT
54296: OR
54297: IFFALSE 50150
// end ;
54299: LD_VAR 0 2
54303: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54304: LD_INT 0
54306: PPUSH
54307: PPUSH
54308: PPUSH
54309: PPUSH
// if not base_units then
54310: LD_VAR 0 1
54314: NOT
54315: IFFALSE 54319
// exit ;
54317: GO 54406
// result := false ;
54319: LD_ADDR_VAR 0 2
54323: PUSH
54324: LD_INT 0
54326: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54327: LD_ADDR_VAR 0 5
54331: PUSH
54332: LD_VAR 0 1
54336: PPUSH
54337: LD_INT 21
54339: PUSH
54340: LD_INT 3
54342: PUSH
54343: EMPTY
54344: LIST
54345: LIST
54346: PPUSH
54347: CALL_OW 72
54351: ST_TO_ADDR
// if not tmp then
54352: LD_VAR 0 5
54356: NOT
54357: IFFALSE 54361
// exit ;
54359: GO 54406
// for i in tmp do
54361: LD_ADDR_VAR 0 3
54365: PUSH
54366: LD_VAR 0 5
54370: PUSH
54371: FOR_IN
54372: IFFALSE 54404
// begin result := EnemyInRange ( i , 22 ) ;
54374: LD_ADDR_VAR 0 2
54378: PUSH
54379: LD_VAR 0 3
54383: PPUSH
54384: LD_INT 22
54386: PPUSH
54387: CALL 47943 0 2
54391: ST_TO_ADDR
// if result then
54392: LD_VAR 0 2
54396: IFFALSE 54402
// exit ;
54398: POP
54399: POP
54400: GO 54406
// end ;
54402: GO 54371
54404: POP
54405: POP
// end ;
54406: LD_VAR 0 2
54410: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54411: LD_INT 0
54413: PPUSH
54414: PPUSH
// if not units then
54415: LD_VAR 0 1
54419: NOT
54420: IFFALSE 54424
// exit ;
54422: GO 54494
// result := [ ] ;
54424: LD_ADDR_VAR 0 3
54428: PUSH
54429: EMPTY
54430: ST_TO_ADDR
// for i in units do
54431: LD_ADDR_VAR 0 4
54435: PUSH
54436: LD_VAR 0 1
54440: PUSH
54441: FOR_IN
54442: IFFALSE 54492
// if GetTag ( i ) = tag then
54444: LD_VAR 0 4
54448: PPUSH
54449: CALL_OW 110
54453: PUSH
54454: LD_VAR 0 2
54458: EQUAL
54459: IFFALSE 54490
// result := Insert ( result , result + 1 , i ) ;
54461: LD_ADDR_VAR 0 3
54465: PUSH
54466: LD_VAR 0 3
54470: PPUSH
54471: LD_VAR 0 3
54475: PUSH
54476: LD_INT 1
54478: PLUS
54479: PPUSH
54480: LD_VAR 0 4
54484: PPUSH
54485: CALL_OW 2
54489: ST_TO_ADDR
54490: GO 54441
54492: POP
54493: POP
// end ;
54494: LD_VAR 0 3
54498: RET
// export function IsDriver ( un ) ; begin
54499: LD_INT 0
54501: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54502: LD_ADDR_VAR 0 2
54506: PUSH
54507: LD_VAR 0 1
54511: PUSH
54512: LD_INT 55
54514: PUSH
54515: EMPTY
54516: LIST
54517: PPUSH
54518: CALL_OW 69
54522: IN
54523: ST_TO_ADDR
// end ;
54524: LD_VAR 0 2
54528: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54529: LD_INT 0
54531: PPUSH
54532: PPUSH
// list := [ ] ;
54533: LD_ADDR_VAR 0 5
54537: PUSH
54538: EMPTY
54539: ST_TO_ADDR
// case d of 0 :
54540: LD_VAR 0 3
54544: PUSH
54545: LD_INT 0
54547: DOUBLE
54548: EQUAL
54549: IFTRUE 54553
54551: GO 54686
54553: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54554: LD_ADDR_VAR 0 5
54558: PUSH
54559: LD_VAR 0 1
54563: PUSH
54564: LD_INT 4
54566: MINUS
54567: PUSH
54568: LD_VAR 0 2
54572: PUSH
54573: LD_INT 4
54575: MINUS
54576: PUSH
54577: LD_INT 2
54579: PUSH
54580: EMPTY
54581: LIST
54582: LIST
54583: LIST
54584: PUSH
54585: LD_VAR 0 1
54589: PUSH
54590: LD_INT 3
54592: MINUS
54593: PUSH
54594: LD_VAR 0 2
54598: PUSH
54599: LD_INT 1
54601: PUSH
54602: EMPTY
54603: LIST
54604: LIST
54605: LIST
54606: PUSH
54607: LD_VAR 0 1
54611: PUSH
54612: LD_INT 4
54614: PLUS
54615: PUSH
54616: LD_VAR 0 2
54620: PUSH
54621: LD_INT 4
54623: PUSH
54624: EMPTY
54625: LIST
54626: LIST
54627: LIST
54628: PUSH
54629: LD_VAR 0 1
54633: PUSH
54634: LD_INT 3
54636: PLUS
54637: PUSH
54638: LD_VAR 0 2
54642: PUSH
54643: LD_INT 3
54645: PLUS
54646: PUSH
54647: LD_INT 5
54649: PUSH
54650: EMPTY
54651: LIST
54652: LIST
54653: LIST
54654: PUSH
54655: LD_VAR 0 1
54659: PUSH
54660: LD_VAR 0 2
54664: PUSH
54665: LD_INT 4
54667: PLUS
54668: PUSH
54669: LD_INT 0
54671: PUSH
54672: EMPTY
54673: LIST
54674: LIST
54675: LIST
54676: PUSH
54677: EMPTY
54678: LIST
54679: LIST
54680: LIST
54681: LIST
54682: LIST
54683: ST_TO_ADDR
// end ; 1 :
54684: GO 55384
54686: LD_INT 1
54688: DOUBLE
54689: EQUAL
54690: IFTRUE 54694
54692: GO 54827
54694: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54695: LD_ADDR_VAR 0 5
54699: PUSH
54700: LD_VAR 0 1
54704: PUSH
54705: LD_VAR 0 2
54709: PUSH
54710: LD_INT 4
54712: MINUS
54713: PUSH
54714: LD_INT 3
54716: PUSH
54717: EMPTY
54718: LIST
54719: LIST
54720: LIST
54721: PUSH
54722: LD_VAR 0 1
54726: PUSH
54727: LD_INT 3
54729: MINUS
54730: PUSH
54731: LD_VAR 0 2
54735: PUSH
54736: LD_INT 3
54738: MINUS
54739: PUSH
54740: LD_INT 2
54742: PUSH
54743: EMPTY
54744: LIST
54745: LIST
54746: LIST
54747: PUSH
54748: LD_VAR 0 1
54752: PUSH
54753: LD_INT 4
54755: MINUS
54756: PUSH
54757: LD_VAR 0 2
54761: PUSH
54762: LD_INT 1
54764: PUSH
54765: EMPTY
54766: LIST
54767: LIST
54768: LIST
54769: PUSH
54770: LD_VAR 0 1
54774: PUSH
54775: LD_VAR 0 2
54779: PUSH
54780: LD_INT 3
54782: PLUS
54783: PUSH
54784: LD_INT 0
54786: PUSH
54787: EMPTY
54788: LIST
54789: LIST
54790: LIST
54791: PUSH
54792: LD_VAR 0 1
54796: PUSH
54797: LD_INT 4
54799: PLUS
54800: PUSH
54801: LD_VAR 0 2
54805: PUSH
54806: LD_INT 4
54808: PLUS
54809: PUSH
54810: LD_INT 5
54812: PUSH
54813: EMPTY
54814: LIST
54815: LIST
54816: LIST
54817: PUSH
54818: EMPTY
54819: LIST
54820: LIST
54821: LIST
54822: LIST
54823: LIST
54824: ST_TO_ADDR
// end ; 2 :
54825: GO 55384
54827: LD_INT 2
54829: DOUBLE
54830: EQUAL
54831: IFTRUE 54835
54833: GO 54964
54835: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54836: LD_ADDR_VAR 0 5
54840: PUSH
54841: LD_VAR 0 1
54845: PUSH
54846: LD_VAR 0 2
54850: PUSH
54851: LD_INT 3
54853: MINUS
54854: PUSH
54855: LD_INT 3
54857: PUSH
54858: EMPTY
54859: LIST
54860: LIST
54861: LIST
54862: PUSH
54863: LD_VAR 0 1
54867: PUSH
54868: LD_INT 4
54870: PLUS
54871: PUSH
54872: LD_VAR 0 2
54876: PUSH
54877: LD_INT 4
54879: PUSH
54880: EMPTY
54881: LIST
54882: LIST
54883: LIST
54884: PUSH
54885: LD_VAR 0 1
54889: PUSH
54890: LD_VAR 0 2
54894: PUSH
54895: LD_INT 4
54897: PLUS
54898: PUSH
54899: LD_INT 0
54901: PUSH
54902: EMPTY
54903: LIST
54904: LIST
54905: LIST
54906: PUSH
54907: LD_VAR 0 1
54911: PUSH
54912: LD_INT 3
54914: MINUS
54915: PUSH
54916: LD_VAR 0 2
54920: PUSH
54921: LD_INT 1
54923: PUSH
54924: EMPTY
54925: LIST
54926: LIST
54927: LIST
54928: PUSH
54929: LD_VAR 0 1
54933: PUSH
54934: LD_INT 4
54936: MINUS
54937: PUSH
54938: LD_VAR 0 2
54942: PUSH
54943: LD_INT 4
54945: MINUS
54946: PUSH
54947: LD_INT 2
54949: PUSH
54950: EMPTY
54951: LIST
54952: LIST
54953: LIST
54954: PUSH
54955: EMPTY
54956: LIST
54957: LIST
54958: LIST
54959: LIST
54960: LIST
54961: ST_TO_ADDR
// end ; 3 :
54962: GO 55384
54964: LD_INT 3
54966: DOUBLE
54967: EQUAL
54968: IFTRUE 54972
54970: GO 55105
54972: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54973: LD_ADDR_VAR 0 5
54977: PUSH
54978: LD_VAR 0 1
54982: PUSH
54983: LD_INT 3
54985: PLUS
54986: PUSH
54987: LD_VAR 0 2
54991: PUSH
54992: LD_INT 4
54994: PUSH
54995: EMPTY
54996: LIST
54997: LIST
54998: LIST
54999: PUSH
55000: LD_VAR 0 1
55004: PUSH
55005: LD_INT 4
55007: PLUS
55008: PUSH
55009: LD_VAR 0 2
55013: PUSH
55014: LD_INT 4
55016: PLUS
55017: PUSH
55018: LD_INT 5
55020: PUSH
55021: EMPTY
55022: LIST
55023: LIST
55024: LIST
55025: PUSH
55026: LD_VAR 0 1
55030: PUSH
55031: LD_INT 4
55033: MINUS
55034: PUSH
55035: LD_VAR 0 2
55039: PUSH
55040: LD_INT 1
55042: PUSH
55043: EMPTY
55044: LIST
55045: LIST
55046: LIST
55047: PUSH
55048: LD_VAR 0 1
55052: PUSH
55053: LD_VAR 0 2
55057: PUSH
55058: LD_INT 4
55060: MINUS
55061: PUSH
55062: LD_INT 3
55064: PUSH
55065: EMPTY
55066: LIST
55067: LIST
55068: LIST
55069: PUSH
55070: LD_VAR 0 1
55074: PUSH
55075: LD_INT 3
55077: MINUS
55078: PUSH
55079: LD_VAR 0 2
55083: PUSH
55084: LD_INT 3
55086: MINUS
55087: PUSH
55088: LD_INT 2
55090: PUSH
55091: EMPTY
55092: LIST
55093: LIST
55094: LIST
55095: PUSH
55096: EMPTY
55097: LIST
55098: LIST
55099: LIST
55100: LIST
55101: LIST
55102: ST_TO_ADDR
// end ; 4 :
55103: GO 55384
55105: LD_INT 4
55107: DOUBLE
55108: EQUAL
55109: IFTRUE 55113
55111: GO 55246
55113: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55114: LD_ADDR_VAR 0 5
55118: PUSH
55119: LD_VAR 0 1
55123: PUSH
55124: LD_VAR 0 2
55128: PUSH
55129: LD_INT 4
55131: PLUS
55132: PUSH
55133: LD_INT 0
55135: PUSH
55136: EMPTY
55137: LIST
55138: LIST
55139: LIST
55140: PUSH
55141: LD_VAR 0 1
55145: PUSH
55146: LD_INT 3
55148: PLUS
55149: PUSH
55150: LD_VAR 0 2
55154: PUSH
55155: LD_INT 3
55157: PLUS
55158: PUSH
55159: LD_INT 5
55161: PUSH
55162: EMPTY
55163: LIST
55164: LIST
55165: LIST
55166: PUSH
55167: LD_VAR 0 1
55171: PUSH
55172: LD_INT 4
55174: PLUS
55175: PUSH
55176: LD_VAR 0 2
55180: PUSH
55181: LD_INT 4
55183: PUSH
55184: EMPTY
55185: LIST
55186: LIST
55187: LIST
55188: PUSH
55189: LD_VAR 0 1
55193: PUSH
55194: LD_VAR 0 2
55198: PUSH
55199: LD_INT 3
55201: MINUS
55202: PUSH
55203: LD_INT 3
55205: PUSH
55206: EMPTY
55207: LIST
55208: LIST
55209: LIST
55210: PUSH
55211: LD_VAR 0 1
55215: PUSH
55216: LD_INT 4
55218: MINUS
55219: PUSH
55220: LD_VAR 0 2
55224: PUSH
55225: LD_INT 4
55227: MINUS
55228: PUSH
55229: LD_INT 2
55231: PUSH
55232: EMPTY
55233: LIST
55234: LIST
55235: LIST
55236: PUSH
55237: EMPTY
55238: LIST
55239: LIST
55240: LIST
55241: LIST
55242: LIST
55243: ST_TO_ADDR
// end ; 5 :
55244: GO 55384
55246: LD_INT 5
55248: DOUBLE
55249: EQUAL
55250: IFTRUE 55254
55252: GO 55383
55254: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55255: LD_ADDR_VAR 0 5
55259: PUSH
55260: LD_VAR 0 1
55264: PUSH
55265: LD_INT 4
55267: MINUS
55268: PUSH
55269: LD_VAR 0 2
55273: PUSH
55274: LD_INT 1
55276: PUSH
55277: EMPTY
55278: LIST
55279: LIST
55280: LIST
55281: PUSH
55282: LD_VAR 0 1
55286: PUSH
55287: LD_VAR 0 2
55291: PUSH
55292: LD_INT 4
55294: MINUS
55295: PUSH
55296: LD_INT 3
55298: PUSH
55299: EMPTY
55300: LIST
55301: LIST
55302: LIST
55303: PUSH
55304: LD_VAR 0 1
55308: PUSH
55309: LD_INT 4
55311: PLUS
55312: PUSH
55313: LD_VAR 0 2
55317: PUSH
55318: LD_INT 4
55320: PLUS
55321: PUSH
55322: LD_INT 5
55324: PUSH
55325: EMPTY
55326: LIST
55327: LIST
55328: LIST
55329: PUSH
55330: LD_VAR 0 1
55334: PUSH
55335: LD_INT 3
55337: PLUS
55338: PUSH
55339: LD_VAR 0 2
55343: PUSH
55344: LD_INT 4
55346: PUSH
55347: EMPTY
55348: LIST
55349: LIST
55350: LIST
55351: PUSH
55352: LD_VAR 0 1
55356: PUSH
55357: LD_VAR 0 2
55361: PUSH
55362: LD_INT 3
55364: PLUS
55365: PUSH
55366: LD_INT 0
55368: PUSH
55369: EMPTY
55370: LIST
55371: LIST
55372: LIST
55373: PUSH
55374: EMPTY
55375: LIST
55376: LIST
55377: LIST
55378: LIST
55379: LIST
55380: ST_TO_ADDR
// end ; end ;
55381: GO 55384
55383: POP
// result := list ;
55384: LD_ADDR_VAR 0 4
55388: PUSH
55389: LD_VAR 0 5
55393: ST_TO_ADDR
// end ;
55394: LD_VAR 0 4
55398: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55399: LD_INT 0
55401: PPUSH
55402: PPUSH
55403: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55404: LD_VAR 0 1
55408: NOT
55409: PUSH
55410: LD_VAR 0 2
55414: PUSH
55415: LD_INT 1
55417: PUSH
55418: LD_INT 2
55420: PUSH
55421: LD_INT 3
55423: PUSH
55424: LD_INT 4
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: LIST
55431: LIST
55432: IN
55433: NOT
55434: OR
55435: IFFALSE 55439
// exit ;
55437: GO 55531
// tmp := [ ] ;
55439: LD_ADDR_VAR 0 5
55443: PUSH
55444: EMPTY
55445: ST_TO_ADDR
// for i in units do
55446: LD_ADDR_VAR 0 4
55450: PUSH
55451: LD_VAR 0 1
55455: PUSH
55456: FOR_IN
55457: IFFALSE 55500
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55459: LD_ADDR_VAR 0 5
55463: PUSH
55464: LD_VAR 0 5
55468: PPUSH
55469: LD_VAR 0 5
55473: PUSH
55474: LD_INT 1
55476: PLUS
55477: PPUSH
55478: LD_VAR 0 4
55482: PPUSH
55483: LD_VAR 0 2
55487: PPUSH
55488: CALL_OW 259
55492: PPUSH
55493: CALL_OW 2
55497: ST_TO_ADDR
55498: GO 55456
55500: POP
55501: POP
// if not tmp then
55502: LD_VAR 0 5
55506: NOT
55507: IFFALSE 55511
// exit ;
55509: GO 55531
// result := SortListByListDesc ( units , tmp ) ;
55511: LD_ADDR_VAR 0 3
55515: PUSH
55516: LD_VAR 0 1
55520: PPUSH
55521: LD_VAR 0 5
55525: PPUSH
55526: CALL_OW 77
55530: ST_TO_ADDR
// end ;
55531: LD_VAR 0 3
55535: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55536: LD_INT 0
55538: PPUSH
55539: PPUSH
55540: PPUSH
// x := GetX ( building ) ;
55541: LD_ADDR_VAR 0 4
55545: PUSH
55546: LD_VAR 0 2
55550: PPUSH
55551: CALL_OW 250
55555: ST_TO_ADDR
// y := GetY ( building ) ;
55556: LD_ADDR_VAR 0 5
55560: PUSH
55561: LD_VAR 0 2
55565: PPUSH
55566: CALL_OW 251
55570: ST_TO_ADDR
// if GetTaskList ( unit ) then
55571: LD_VAR 0 1
55575: PPUSH
55576: CALL_OW 437
55580: IFFALSE 55675
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55582: LD_STRING e
55584: PUSH
55585: LD_VAR 0 1
55589: PPUSH
55590: CALL_OW 437
55594: PUSH
55595: LD_INT 1
55597: ARRAY
55598: PUSH
55599: LD_INT 1
55601: ARRAY
55602: EQUAL
55603: PUSH
55604: LD_VAR 0 4
55608: PUSH
55609: LD_VAR 0 1
55613: PPUSH
55614: CALL_OW 437
55618: PUSH
55619: LD_INT 1
55621: ARRAY
55622: PUSH
55623: LD_INT 2
55625: ARRAY
55626: EQUAL
55627: AND
55628: PUSH
55629: LD_VAR 0 5
55633: PUSH
55634: LD_VAR 0 1
55638: PPUSH
55639: CALL_OW 437
55643: PUSH
55644: LD_INT 1
55646: ARRAY
55647: PUSH
55648: LD_INT 3
55650: ARRAY
55651: EQUAL
55652: AND
55653: IFFALSE 55665
// result := true else
55655: LD_ADDR_VAR 0 3
55659: PUSH
55660: LD_INT 1
55662: ST_TO_ADDR
55663: GO 55673
// result := false ;
55665: LD_ADDR_VAR 0 3
55669: PUSH
55670: LD_INT 0
55672: ST_TO_ADDR
// end else
55673: GO 55683
// result := false ;
55675: LD_ADDR_VAR 0 3
55679: PUSH
55680: LD_INT 0
55682: ST_TO_ADDR
// end ;
55683: LD_VAR 0 3
55687: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55688: LD_INT 0
55690: PPUSH
55691: PPUSH
55692: PPUSH
55693: PPUSH
// if not unit or not area then
55694: LD_VAR 0 1
55698: NOT
55699: PUSH
55700: LD_VAR 0 2
55704: NOT
55705: OR
55706: IFFALSE 55710
// exit ;
55708: GO 55874
// tmp := AreaToList ( area , i ) ;
55710: LD_ADDR_VAR 0 6
55714: PUSH
55715: LD_VAR 0 2
55719: PPUSH
55720: LD_VAR 0 5
55724: PPUSH
55725: CALL_OW 517
55729: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55730: LD_ADDR_VAR 0 5
55734: PUSH
55735: DOUBLE
55736: LD_INT 1
55738: DEC
55739: ST_TO_ADDR
55740: LD_VAR 0 6
55744: PUSH
55745: LD_INT 1
55747: ARRAY
55748: PUSH
55749: FOR_TO
55750: IFFALSE 55872
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55752: LD_ADDR_VAR 0 7
55756: PUSH
55757: LD_VAR 0 6
55761: PUSH
55762: LD_INT 1
55764: ARRAY
55765: PUSH
55766: LD_VAR 0 5
55770: ARRAY
55771: PUSH
55772: LD_VAR 0 6
55776: PUSH
55777: LD_INT 2
55779: ARRAY
55780: PUSH
55781: LD_VAR 0 5
55785: ARRAY
55786: PUSH
55787: EMPTY
55788: LIST
55789: LIST
55790: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55791: LD_VAR 0 7
55795: PUSH
55796: LD_INT 1
55798: ARRAY
55799: PPUSH
55800: LD_VAR 0 7
55804: PUSH
55805: LD_INT 2
55807: ARRAY
55808: PPUSH
55809: CALL_OW 428
55813: PUSH
55814: LD_INT 0
55816: EQUAL
55817: IFFALSE 55870
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55819: LD_VAR 0 1
55823: PPUSH
55824: LD_VAR 0 7
55828: PUSH
55829: LD_INT 1
55831: ARRAY
55832: PPUSH
55833: LD_VAR 0 7
55837: PUSH
55838: LD_INT 2
55840: ARRAY
55841: PPUSH
55842: LD_VAR 0 3
55846: PPUSH
55847: CALL_OW 48
// result := IsPlaced ( unit ) ;
55851: LD_ADDR_VAR 0 4
55855: PUSH
55856: LD_VAR 0 1
55860: PPUSH
55861: CALL_OW 305
55865: ST_TO_ADDR
// exit ;
55866: POP
55867: POP
55868: GO 55874
// end ; end ;
55870: GO 55749
55872: POP
55873: POP
// end ;
55874: LD_VAR 0 4
55878: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55879: LD_INT 0
55881: PPUSH
55882: PPUSH
55883: PPUSH
// if not side or side > 8 then
55884: LD_VAR 0 1
55888: NOT
55889: PUSH
55890: LD_VAR 0 1
55894: PUSH
55895: LD_INT 8
55897: GREATER
55898: OR
55899: IFFALSE 55903
// exit ;
55901: GO 56090
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55903: LD_ADDR_VAR 0 4
55907: PUSH
55908: LD_INT 22
55910: PUSH
55911: LD_VAR 0 1
55915: PUSH
55916: EMPTY
55917: LIST
55918: LIST
55919: PUSH
55920: LD_INT 21
55922: PUSH
55923: LD_INT 3
55925: PUSH
55926: EMPTY
55927: LIST
55928: LIST
55929: PUSH
55930: EMPTY
55931: LIST
55932: LIST
55933: PPUSH
55934: CALL_OW 69
55938: ST_TO_ADDR
// if not tmp then
55939: LD_VAR 0 4
55943: NOT
55944: IFFALSE 55948
// exit ;
55946: GO 56090
// enable_addtolog := true ;
55948: LD_ADDR_OWVAR 81
55952: PUSH
55953: LD_INT 1
55955: ST_TO_ADDR
// AddToLog ( [ ) ;
55956: LD_STRING [
55958: PPUSH
55959: CALL_OW 561
// for i in tmp do
55963: LD_ADDR_VAR 0 3
55967: PUSH
55968: LD_VAR 0 4
55972: PUSH
55973: FOR_IN
55974: IFFALSE 56081
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55976: LD_STRING [
55978: PUSH
55979: LD_VAR 0 3
55983: PPUSH
55984: CALL_OW 266
55988: STR
55989: PUSH
55990: LD_STRING , 
55992: STR
55993: PUSH
55994: LD_VAR 0 3
55998: PPUSH
55999: CALL_OW 250
56003: STR
56004: PUSH
56005: LD_STRING , 
56007: STR
56008: PUSH
56009: LD_VAR 0 3
56013: PPUSH
56014: CALL_OW 251
56018: STR
56019: PUSH
56020: LD_STRING , 
56022: STR
56023: PUSH
56024: LD_VAR 0 3
56028: PPUSH
56029: CALL_OW 254
56033: STR
56034: PUSH
56035: LD_STRING , 
56037: STR
56038: PUSH
56039: LD_VAR 0 3
56043: PPUSH
56044: LD_INT 1
56046: PPUSH
56047: CALL_OW 268
56051: STR
56052: PUSH
56053: LD_STRING , 
56055: STR
56056: PUSH
56057: LD_VAR 0 3
56061: PPUSH
56062: LD_INT 2
56064: PPUSH
56065: CALL_OW 268
56069: STR
56070: PUSH
56071: LD_STRING ],
56073: STR
56074: PPUSH
56075: CALL_OW 561
// end ;
56079: GO 55973
56081: POP
56082: POP
// AddToLog ( ]; ) ;
56083: LD_STRING ];
56085: PPUSH
56086: CALL_OW 561
// end ;
56090: LD_VAR 0 2
56094: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56095: LD_INT 0
56097: PPUSH
56098: PPUSH
56099: PPUSH
56100: PPUSH
56101: PPUSH
// if not area or not rate or not max then
56102: LD_VAR 0 1
56106: NOT
56107: PUSH
56108: LD_VAR 0 2
56112: NOT
56113: OR
56114: PUSH
56115: LD_VAR 0 4
56119: NOT
56120: OR
56121: IFFALSE 56125
// exit ;
56123: GO 56317
// while 1 do
56125: LD_INT 1
56127: IFFALSE 56317
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56129: LD_ADDR_VAR 0 9
56133: PUSH
56134: LD_VAR 0 1
56138: PPUSH
56139: LD_INT 1
56141: PPUSH
56142: CALL_OW 287
56146: PUSH
56147: LD_INT 10
56149: MUL
56150: ST_TO_ADDR
// r := rate / 10 ;
56151: LD_ADDR_VAR 0 7
56155: PUSH
56156: LD_VAR 0 2
56160: PUSH
56161: LD_INT 10
56163: DIVREAL
56164: ST_TO_ADDR
// time := 1 1$00 ;
56165: LD_ADDR_VAR 0 8
56169: PUSH
56170: LD_INT 2100
56172: ST_TO_ADDR
// if amount < min then
56173: LD_VAR 0 9
56177: PUSH
56178: LD_VAR 0 3
56182: LESS
56183: IFFALSE 56201
// r := r * 2 else
56185: LD_ADDR_VAR 0 7
56189: PUSH
56190: LD_VAR 0 7
56194: PUSH
56195: LD_INT 2
56197: MUL
56198: ST_TO_ADDR
56199: GO 56227
// if amount > max then
56201: LD_VAR 0 9
56205: PUSH
56206: LD_VAR 0 4
56210: GREATER
56211: IFFALSE 56227
// r := r / 2 ;
56213: LD_ADDR_VAR 0 7
56217: PUSH
56218: LD_VAR 0 7
56222: PUSH
56223: LD_INT 2
56225: DIVREAL
56226: ST_TO_ADDR
// time := time / r ;
56227: LD_ADDR_VAR 0 8
56231: PUSH
56232: LD_VAR 0 8
56236: PUSH
56237: LD_VAR 0 7
56241: DIVREAL
56242: ST_TO_ADDR
// if time < 0 then
56243: LD_VAR 0 8
56247: PUSH
56248: LD_INT 0
56250: LESS
56251: IFFALSE 56268
// time := time * - 1 ;
56253: LD_ADDR_VAR 0 8
56257: PUSH
56258: LD_VAR 0 8
56262: PUSH
56263: LD_INT 1
56265: NEG
56266: MUL
56267: ST_TO_ADDR
// wait ( time ) ;
56268: LD_VAR 0 8
56272: PPUSH
56273: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56277: LD_INT 35
56279: PPUSH
56280: LD_INT 875
56282: PPUSH
56283: CALL_OW 12
56287: PPUSH
56288: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56292: LD_INT 1
56294: PPUSH
56295: LD_INT 5
56297: PPUSH
56298: CALL_OW 12
56302: PPUSH
56303: LD_VAR 0 1
56307: PPUSH
56308: LD_INT 1
56310: PPUSH
56311: CALL_OW 55
// end ;
56315: GO 56125
// end ;
56317: LD_VAR 0 5
56321: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56322: LD_INT 0
56324: PPUSH
56325: PPUSH
56326: PPUSH
56327: PPUSH
56328: PPUSH
56329: PPUSH
56330: PPUSH
56331: PPUSH
// if not turrets or not factories then
56332: LD_VAR 0 1
56336: NOT
56337: PUSH
56338: LD_VAR 0 2
56342: NOT
56343: OR
56344: IFFALSE 56348
// exit ;
56346: GO 56655
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56348: LD_ADDR_VAR 0 10
56352: PUSH
56353: LD_INT 5
56355: PUSH
56356: LD_INT 6
56358: PUSH
56359: EMPTY
56360: LIST
56361: LIST
56362: PUSH
56363: LD_INT 2
56365: PUSH
56366: LD_INT 4
56368: PUSH
56369: EMPTY
56370: LIST
56371: LIST
56372: PUSH
56373: LD_INT 3
56375: PUSH
56376: LD_INT 5
56378: PUSH
56379: EMPTY
56380: LIST
56381: LIST
56382: PUSH
56383: EMPTY
56384: LIST
56385: LIST
56386: LIST
56387: PUSH
56388: LD_INT 24
56390: PUSH
56391: LD_INT 25
56393: PUSH
56394: EMPTY
56395: LIST
56396: LIST
56397: PUSH
56398: LD_INT 23
56400: PUSH
56401: LD_INT 27
56403: PUSH
56404: EMPTY
56405: LIST
56406: LIST
56407: PUSH
56408: EMPTY
56409: LIST
56410: LIST
56411: PUSH
56412: LD_INT 42
56414: PUSH
56415: LD_INT 43
56417: PUSH
56418: EMPTY
56419: LIST
56420: LIST
56421: PUSH
56422: LD_INT 44
56424: PUSH
56425: LD_INT 46
56427: PUSH
56428: EMPTY
56429: LIST
56430: LIST
56431: PUSH
56432: LD_INT 45
56434: PUSH
56435: LD_INT 47
56437: PUSH
56438: EMPTY
56439: LIST
56440: LIST
56441: PUSH
56442: EMPTY
56443: LIST
56444: LIST
56445: LIST
56446: PUSH
56447: EMPTY
56448: LIST
56449: LIST
56450: LIST
56451: ST_TO_ADDR
// result := [ ] ;
56452: LD_ADDR_VAR 0 3
56456: PUSH
56457: EMPTY
56458: ST_TO_ADDR
// for i in turrets do
56459: LD_ADDR_VAR 0 4
56463: PUSH
56464: LD_VAR 0 1
56468: PUSH
56469: FOR_IN
56470: IFFALSE 56653
// begin nat := GetNation ( i ) ;
56472: LD_ADDR_VAR 0 7
56476: PUSH
56477: LD_VAR 0 4
56481: PPUSH
56482: CALL_OW 248
56486: ST_TO_ADDR
// weapon := 0 ;
56487: LD_ADDR_VAR 0 8
56491: PUSH
56492: LD_INT 0
56494: ST_TO_ADDR
// if not nat then
56495: LD_VAR 0 7
56499: NOT
56500: IFFALSE 56504
// continue ;
56502: GO 56469
// for j in list [ nat ] do
56504: LD_ADDR_VAR 0 5
56508: PUSH
56509: LD_VAR 0 10
56513: PUSH
56514: LD_VAR 0 7
56518: ARRAY
56519: PUSH
56520: FOR_IN
56521: IFFALSE 56562
// if GetBWeapon ( i ) = j [ 1 ] then
56523: LD_VAR 0 4
56527: PPUSH
56528: CALL_OW 269
56532: PUSH
56533: LD_VAR 0 5
56537: PUSH
56538: LD_INT 1
56540: ARRAY
56541: EQUAL
56542: IFFALSE 56560
// begin weapon := j [ 2 ] ;
56544: LD_ADDR_VAR 0 8
56548: PUSH
56549: LD_VAR 0 5
56553: PUSH
56554: LD_INT 2
56556: ARRAY
56557: ST_TO_ADDR
// break ;
56558: GO 56562
// end ;
56560: GO 56520
56562: POP
56563: POP
// if not weapon then
56564: LD_VAR 0 8
56568: NOT
56569: IFFALSE 56573
// continue ;
56571: GO 56469
// for k in factories do
56573: LD_ADDR_VAR 0 6
56577: PUSH
56578: LD_VAR 0 2
56582: PUSH
56583: FOR_IN
56584: IFFALSE 56649
// begin weapons := AvailableWeaponList ( k ) ;
56586: LD_ADDR_VAR 0 9
56590: PUSH
56591: LD_VAR 0 6
56595: PPUSH
56596: CALL_OW 478
56600: ST_TO_ADDR
// if not weapons then
56601: LD_VAR 0 9
56605: NOT
56606: IFFALSE 56610
// continue ;
56608: GO 56583
// if weapon in weapons then
56610: LD_VAR 0 8
56614: PUSH
56615: LD_VAR 0 9
56619: IN
56620: IFFALSE 56647
// begin result := [ i , weapon ] ;
56622: LD_ADDR_VAR 0 3
56626: PUSH
56627: LD_VAR 0 4
56631: PUSH
56632: LD_VAR 0 8
56636: PUSH
56637: EMPTY
56638: LIST
56639: LIST
56640: ST_TO_ADDR
// exit ;
56641: POP
56642: POP
56643: POP
56644: POP
56645: GO 56655
// end ; end ;
56647: GO 56583
56649: POP
56650: POP
// end ;
56651: GO 56469
56653: POP
56654: POP
// end ;
56655: LD_VAR 0 3
56659: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56660: LD_INT 0
56662: PPUSH
// if not side or side > 8 then
56663: LD_VAR 0 3
56667: NOT
56668: PUSH
56669: LD_VAR 0 3
56673: PUSH
56674: LD_INT 8
56676: GREATER
56677: OR
56678: IFFALSE 56682
// exit ;
56680: GO 56741
// if not range then
56682: LD_VAR 0 4
56686: NOT
56687: IFFALSE 56698
// range := - 12 ;
56689: LD_ADDR_VAR 0 4
56693: PUSH
56694: LD_INT 12
56696: NEG
56697: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56698: LD_VAR 0 1
56702: PPUSH
56703: LD_VAR 0 2
56707: PPUSH
56708: LD_VAR 0 3
56712: PPUSH
56713: LD_VAR 0 4
56717: PPUSH
56718: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56722: LD_VAR 0 1
56726: PPUSH
56727: LD_VAR 0 2
56731: PPUSH
56732: LD_VAR 0 3
56736: PPUSH
56737: CALL_OW 331
// end ;
56741: LD_VAR 0 5
56745: RET
// export function Video ( mode ) ; begin
56746: LD_INT 0
56748: PPUSH
// ingame_video = mode ;
56749: LD_ADDR_OWVAR 52
56753: PUSH
56754: LD_VAR 0 1
56758: ST_TO_ADDR
// interface_hidden = mode ;
56759: LD_ADDR_OWVAR 54
56763: PUSH
56764: LD_VAR 0 1
56768: ST_TO_ADDR
// end ;
56769: LD_VAR 0 2
56773: RET
// export function Join ( array , element ) ; begin
56774: LD_INT 0
56776: PPUSH
// result := array ^ element ;
56777: LD_ADDR_VAR 0 3
56781: PUSH
56782: LD_VAR 0 1
56786: PUSH
56787: LD_VAR 0 2
56791: ADD
56792: ST_TO_ADDR
// end ;
56793: LD_VAR 0 3
56797: RET
// export function JoinUnion ( array , element ) ; begin
56798: LD_INT 0
56800: PPUSH
// result := array union element ;
56801: LD_ADDR_VAR 0 3
56805: PUSH
56806: LD_VAR 0 1
56810: PUSH
56811: LD_VAR 0 2
56815: UNION
56816: ST_TO_ADDR
// end ;
56817: LD_VAR 0 3
56821: RET
// export function GetBehemoths ( side ) ; begin
56822: LD_INT 0
56824: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56825: LD_ADDR_VAR 0 2
56829: PUSH
56830: LD_INT 22
56832: PUSH
56833: LD_VAR 0 1
56837: PUSH
56838: EMPTY
56839: LIST
56840: LIST
56841: PUSH
56842: LD_INT 31
56844: PUSH
56845: LD_INT 25
56847: PUSH
56848: EMPTY
56849: LIST
56850: LIST
56851: PUSH
56852: EMPTY
56853: LIST
56854: LIST
56855: PPUSH
56856: CALL_OW 69
56860: ST_TO_ADDR
// end ;
56861: LD_VAR 0 2
56865: RET
// export function Shuffle ( array ) ; var i , index ; begin
56866: LD_INT 0
56868: PPUSH
56869: PPUSH
56870: PPUSH
// result := [ ] ;
56871: LD_ADDR_VAR 0 2
56875: PUSH
56876: EMPTY
56877: ST_TO_ADDR
// if not array then
56878: LD_VAR 0 1
56882: NOT
56883: IFFALSE 56887
// exit ;
56885: GO 56986
// Randomize ;
56887: CALL_OW 10
// for i = array downto 1 do
56891: LD_ADDR_VAR 0 3
56895: PUSH
56896: DOUBLE
56897: LD_VAR 0 1
56901: INC
56902: ST_TO_ADDR
56903: LD_INT 1
56905: PUSH
56906: FOR_DOWNTO
56907: IFFALSE 56984
// begin index := rand ( 1 , array ) ;
56909: LD_ADDR_VAR 0 4
56913: PUSH
56914: LD_INT 1
56916: PPUSH
56917: LD_VAR 0 1
56921: PPUSH
56922: CALL_OW 12
56926: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56927: LD_ADDR_VAR 0 2
56931: PUSH
56932: LD_VAR 0 2
56936: PPUSH
56937: LD_VAR 0 2
56941: PUSH
56942: LD_INT 1
56944: PLUS
56945: PPUSH
56946: LD_VAR 0 1
56950: PUSH
56951: LD_VAR 0 4
56955: ARRAY
56956: PPUSH
56957: CALL_OW 2
56961: ST_TO_ADDR
// array := Delete ( array , index ) ;
56962: LD_ADDR_VAR 0 1
56966: PUSH
56967: LD_VAR 0 1
56971: PPUSH
56972: LD_VAR 0 4
56976: PPUSH
56977: CALL_OW 3
56981: ST_TO_ADDR
// end ;
56982: GO 56906
56984: POP
56985: POP
// end ;
56986: LD_VAR 0 2
56990: RET
// export function GetBaseMaterials ( base ) ; begin
56991: LD_INT 0
56993: PPUSH
// result := [ 0 , 0 , 0 ] ;
56994: LD_ADDR_VAR 0 2
56998: PUSH
56999: LD_INT 0
57001: PUSH
57002: LD_INT 0
57004: PUSH
57005: LD_INT 0
57007: PUSH
57008: EMPTY
57009: LIST
57010: LIST
57011: LIST
57012: ST_TO_ADDR
// if not base then
57013: LD_VAR 0 1
57017: NOT
57018: IFFALSE 57022
// exit ;
57020: GO 57071
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57022: LD_ADDR_VAR 0 2
57026: PUSH
57027: LD_VAR 0 1
57031: PPUSH
57032: LD_INT 1
57034: PPUSH
57035: CALL_OW 275
57039: PUSH
57040: LD_VAR 0 1
57044: PPUSH
57045: LD_INT 2
57047: PPUSH
57048: CALL_OW 275
57052: PUSH
57053: LD_VAR 0 1
57057: PPUSH
57058: LD_INT 3
57060: PPUSH
57061: CALL_OW 275
57065: PUSH
57066: EMPTY
57067: LIST
57068: LIST
57069: LIST
57070: ST_TO_ADDR
// end ; end_of_file
57071: LD_VAR 0 2
57075: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
57076: LD_INT 0
57078: PPUSH
57079: PPUSH
// skirmish := false ;
57080: LD_ADDR_EXP 56
57084: PUSH
57085: LD_INT 0
57087: ST_TO_ADDR
// debug_mc := false ;
57088: LD_ADDR_EXP 57
57092: PUSH
57093: LD_INT 0
57095: ST_TO_ADDR
// mc_bases := [ ] ;
57096: LD_ADDR_EXP 58
57100: PUSH
57101: EMPTY
57102: ST_TO_ADDR
// mc_sides := [ ] ;
57103: LD_ADDR_EXP 84
57107: PUSH
57108: EMPTY
57109: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57110: LD_ADDR_EXP 59
57114: PUSH
57115: EMPTY
57116: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57117: LD_ADDR_EXP 60
57121: PUSH
57122: EMPTY
57123: ST_TO_ADDR
// mc_need_heal := [ ] ;
57124: LD_ADDR_EXP 61
57128: PUSH
57129: EMPTY
57130: ST_TO_ADDR
// mc_healers := [ ] ;
57131: LD_ADDR_EXP 62
57135: PUSH
57136: EMPTY
57137: ST_TO_ADDR
// mc_build_list := [ ] ;
57138: LD_ADDR_EXP 63
57142: PUSH
57143: EMPTY
57144: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57145: LD_ADDR_EXP 90
57149: PUSH
57150: EMPTY
57151: ST_TO_ADDR
// mc_builders := [ ] ;
57152: LD_ADDR_EXP 64
57156: PUSH
57157: EMPTY
57158: ST_TO_ADDR
// mc_construct_list := [ ] ;
57159: LD_ADDR_EXP 65
57163: PUSH
57164: EMPTY
57165: ST_TO_ADDR
// mc_turret_list := [ ] ;
57166: LD_ADDR_EXP 66
57170: PUSH
57171: EMPTY
57172: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57173: LD_ADDR_EXP 67
57177: PUSH
57178: EMPTY
57179: ST_TO_ADDR
// mc_miners := [ ] ;
57180: LD_ADDR_EXP 72
57184: PUSH
57185: EMPTY
57186: ST_TO_ADDR
// mc_mines := [ ] ;
57187: LD_ADDR_EXP 71
57191: PUSH
57192: EMPTY
57193: ST_TO_ADDR
// mc_minefields := [ ] ;
57194: LD_ADDR_EXP 73
57198: PUSH
57199: EMPTY
57200: ST_TO_ADDR
// mc_crates := [ ] ;
57201: LD_ADDR_EXP 74
57205: PUSH
57206: EMPTY
57207: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57208: LD_ADDR_EXP 75
57212: PUSH
57213: EMPTY
57214: ST_TO_ADDR
// mc_crates_area := [ ] ;
57215: LD_ADDR_EXP 76
57219: PUSH
57220: EMPTY
57221: ST_TO_ADDR
// mc_vehicles := [ ] ;
57222: LD_ADDR_EXP 77
57226: PUSH
57227: EMPTY
57228: ST_TO_ADDR
// mc_attack := [ ] ;
57229: LD_ADDR_EXP 78
57233: PUSH
57234: EMPTY
57235: ST_TO_ADDR
// mc_produce := [ ] ;
57236: LD_ADDR_EXP 79
57240: PUSH
57241: EMPTY
57242: ST_TO_ADDR
// mc_defender := [ ] ;
57243: LD_ADDR_EXP 80
57247: PUSH
57248: EMPTY
57249: ST_TO_ADDR
// mc_parking := [ ] ;
57250: LD_ADDR_EXP 82
57254: PUSH
57255: EMPTY
57256: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57257: LD_ADDR_EXP 68
57261: PUSH
57262: EMPTY
57263: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57264: LD_ADDR_EXP 70
57268: PUSH
57269: EMPTY
57270: ST_TO_ADDR
// mc_scan := [ ] ;
57271: LD_ADDR_EXP 81
57275: PUSH
57276: EMPTY
57277: ST_TO_ADDR
// mc_scan_area := [ ] ;
57278: LD_ADDR_EXP 83
57282: PUSH
57283: EMPTY
57284: ST_TO_ADDR
// mc_tech := [ ] ;
57285: LD_ADDR_EXP 85
57289: PUSH
57290: EMPTY
57291: ST_TO_ADDR
// mc_class := [ ] ;
57292: LD_ADDR_EXP 99
57296: PUSH
57297: EMPTY
57298: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57299: LD_ADDR_EXP 100
57303: PUSH
57304: EMPTY
57305: ST_TO_ADDR
// end ;
57306: LD_VAR 0 1
57310: RET
// export function MC_Kill ( base ) ; begin
57311: LD_INT 0
57313: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57314: LD_ADDR_EXP 58
57318: PUSH
57319: LD_EXP 58
57323: PPUSH
57324: LD_VAR 0 1
57328: PPUSH
57329: EMPTY
57330: PPUSH
57331: CALL_OW 1
57335: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57336: LD_ADDR_EXP 59
57340: PUSH
57341: LD_EXP 59
57345: PPUSH
57346: LD_VAR 0 1
57350: PPUSH
57351: EMPTY
57352: PPUSH
57353: CALL_OW 1
57357: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57358: LD_ADDR_EXP 60
57362: PUSH
57363: LD_EXP 60
57367: PPUSH
57368: LD_VAR 0 1
57372: PPUSH
57373: EMPTY
57374: PPUSH
57375: CALL_OW 1
57379: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57380: LD_ADDR_EXP 61
57384: PUSH
57385: LD_EXP 61
57389: PPUSH
57390: LD_VAR 0 1
57394: PPUSH
57395: EMPTY
57396: PPUSH
57397: CALL_OW 1
57401: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57402: LD_ADDR_EXP 62
57406: PUSH
57407: LD_EXP 62
57411: PPUSH
57412: LD_VAR 0 1
57416: PPUSH
57417: EMPTY
57418: PPUSH
57419: CALL_OW 1
57423: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57424: LD_ADDR_EXP 63
57428: PUSH
57429: LD_EXP 63
57433: PPUSH
57434: LD_VAR 0 1
57438: PPUSH
57439: EMPTY
57440: PPUSH
57441: CALL_OW 1
57445: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57446: LD_ADDR_EXP 64
57450: PUSH
57451: LD_EXP 64
57455: PPUSH
57456: LD_VAR 0 1
57460: PPUSH
57461: EMPTY
57462: PPUSH
57463: CALL_OW 1
57467: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57468: LD_ADDR_EXP 65
57472: PUSH
57473: LD_EXP 65
57477: PPUSH
57478: LD_VAR 0 1
57482: PPUSH
57483: EMPTY
57484: PPUSH
57485: CALL_OW 1
57489: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57490: LD_ADDR_EXP 66
57494: PUSH
57495: LD_EXP 66
57499: PPUSH
57500: LD_VAR 0 1
57504: PPUSH
57505: EMPTY
57506: PPUSH
57507: CALL_OW 1
57511: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57512: LD_ADDR_EXP 67
57516: PUSH
57517: LD_EXP 67
57521: PPUSH
57522: LD_VAR 0 1
57526: PPUSH
57527: EMPTY
57528: PPUSH
57529: CALL_OW 1
57533: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57534: LD_ADDR_EXP 68
57538: PUSH
57539: LD_EXP 68
57543: PPUSH
57544: LD_VAR 0 1
57548: PPUSH
57549: EMPTY
57550: PPUSH
57551: CALL_OW 1
57555: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57556: LD_ADDR_EXP 69
57560: PUSH
57561: LD_EXP 69
57565: PPUSH
57566: LD_VAR 0 1
57570: PPUSH
57571: LD_INT 0
57573: PPUSH
57574: CALL_OW 1
57578: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57579: LD_ADDR_EXP 70
57583: PUSH
57584: LD_EXP 70
57588: PPUSH
57589: LD_VAR 0 1
57593: PPUSH
57594: EMPTY
57595: PPUSH
57596: CALL_OW 1
57600: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57601: LD_ADDR_EXP 71
57605: PUSH
57606: LD_EXP 71
57610: PPUSH
57611: LD_VAR 0 1
57615: PPUSH
57616: EMPTY
57617: PPUSH
57618: CALL_OW 1
57622: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57623: LD_ADDR_EXP 72
57627: PUSH
57628: LD_EXP 72
57632: PPUSH
57633: LD_VAR 0 1
57637: PPUSH
57638: EMPTY
57639: PPUSH
57640: CALL_OW 1
57644: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57645: LD_ADDR_EXP 73
57649: PUSH
57650: LD_EXP 73
57654: PPUSH
57655: LD_VAR 0 1
57659: PPUSH
57660: EMPTY
57661: PPUSH
57662: CALL_OW 1
57666: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57667: LD_ADDR_EXP 74
57671: PUSH
57672: LD_EXP 74
57676: PPUSH
57677: LD_VAR 0 1
57681: PPUSH
57682: EMPTY
57683: PPUSH
57684: CALL_OW 1
57688: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57689: LD_ADDR_EXP 75
57693: PUSH
57694: LD_EXP 75
57698: PPUSH
57699: LD_VAR 0 1
57703: PPUSH
57704: EMPTY
57705: PPUSH
57706: CALL_OW 1
57710: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57711: LD_ADDR_EXP 76
57715: PUSH
57716: LD_EXP 76
57720: PPUSH
57721: LD_VAR 0 1
57725: PPUSH
57726: EMPTY
57727: PPUSH
57728: CALL_OW 1
57732: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57733: LD_ADDR_EXP 77
57737: PUSH
57738: LD_EXP 77
57742: PPUSH
57743: LD_VAR 0 1
57747: PPUSH
57748: EMPTY
57749: PPUSH
57750: CALL_OW 1
57754: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57755: LD_ADDR_EXP 78
57759: PUSH
57760: LD_EXP 78
57764: PPUSH
57765: LD_VAR 0 1
57769: PPUSH
57770: EMPTY
57771: PPUSH
57772: CALL_OW 1
57776: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57777: LD_ADDR_EXP 79
57781: PUSH
57782: LD_EXP 79
57786: PPUSH
57787: LD_VAR 0 1
57791: PPUSH
57792: EMPTY
57793: PPUSH
57794: CALL_OW 1
57798: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57799: LD_ADDR_EXP 80
57803: PUSH
57804: LD_EXP 80
57808: PPUSH
57809: LD_VAR 0 1
57813: PPUSH
57814: EMPTY
57815: PPUSH
57816: CALL_OW 1
57820: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57821: LD_ADDR_EXP 81
57825: PUSH
57826: LD_EXP 81
57830: PPUSH
57831: LD_VAR 0 1
57835: PPUSH
57836: EMPTY
57837: PPUSH
57838: CALL_OW 1
57842: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57843: LD_ADDR_EXP 82
57847: PUSH
57848: LD_EXP 82
57852: PPUSH
57853: LD_VAR 0 1
57857: PPUSH
57858: EMPTY
57859: PPUSH
57860: CALL_OW 1
57864: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57865: LD_ADDR_EXP 83
57869: PUSH
57870: LD_EXP 83
57874: PPUSH
57875: LD_VAR 0 1
57879: PPUSH
57880: EMPTY
57881: PPUSH
57882: CALL_OW 1
57886: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57887: LD_ADDR_EXP 85
57891: PUSH
57892: LD_EXP 85
57896: PPUSH
57897: LD_VAR 0 1
57901: PPUSH
57902: EMPTY
57903: PPUSH
57904: CALL_OW 1
57908: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57909: LD_ADDR_EXP 87
57913: PUSH
57914: LD_EXP 87
57918: PPUSH
57919: LD_VAR 0 1
57923: PPUSH
57924: EMPTY
57925: PPUSH
57926: CALL_OW 1
57930: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57931: LD_ADDR_EXP 88
57935: PUSH
57936: LD_EXP 88
57940: PPUSH
57941: LD_VAR 0 1
57945: PPUSH
57946: EMPTY
57947: PPUSH
57948: CALL_OW 1
57952: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57953: LD_ADDR_EXP 89
57957: PUSH
57958: LD_EXP 89
57962: PPUSH
57963: LD_VAR 0 1
57967: PPUSH
57968: EMPTY
57969: PPUSH
57970: CALL_OW 1
57974: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57975: LD_ADDR_EXP 90
57979: PUSH
57980: LD_EXP 90
57984: PPUSH
57985: LD_VAR 0 1
57989: PPUSH
57990: EMPTY
57991: PPUSH
57992: CALL_OW 1
57996: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57997: LD_ADDR_EXP 91
58001: PUSH
58002: LD_EXP 91
58006: PPUSH
58007: LD_VAR 0 1
58011: PPUSH
58012: EMPTY
58013: PPUSH
58014: CALL_OW 1
58018: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58019: LD_ADDR_EXP 92
58023: PUSH
58024: LD_EXP 92
58028: PPUSH
58029: LD_VAR 0 1
58033: PPUSH
58034: EMPTY
58035: PPUSH
58036: CALL_OW 1
58040: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58041: LD_ADDR_EXP 93
58045: PUSH
58046: LD_EXP 93
58050: PPUSH
58051: LD_VAR 0 1
58055: PPUSH
58056: EMPTY
58057: PPUSH
58058: CALL_OW 1
58062: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58063: LD_ADDR_EXP 94
58067: PUSH
58068: LD_EXP 94
58072: PPUSH
58073: LD_VAR 0 1
58077: PPUSH
58078: EMPTY
58079: PPUSH
58080: CALL_OW 1
58084: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58085: LD_ADDR_EXP 95
58089: PUSH
58090: LD_EXP 95
58094: PPUSH
58095: LD_VAR 0 1
58099: PPUSH
58100: EMPTY
58101: PPUSH
58102: CALL_OW 1
58106: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58107: LD_ADDR_EXP 96
58111: PUSH
58112: LD_EXP 96
58116: PPUSH
58117: LD_VAR 0 1
58121: PPUSH
58122: EMPTY
58123: PPUSH
58124: CALL_OW 1
58128: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58129: LD_ADDR_EXP 97
58133: PUSH
58134: LD_EXP 97
58138: PPUSH
58139: LD_VAR 0 1
58143: PPUSH
58144: EMPTY
58145: PPUSH
58146: CALL_OW 1
58150: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58151: LD_ADDR_EXP 98
58155: PUSH
58156: LD_EXP 98
58160: PPUSH
58161: LD_VAR 0 1
58165: PPUSH
58166: EMPTY
58167: PPUSH
58168: CALL_OW 1
58172: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58173: LD_ADDR_EXP 99
58177: PUSH
58178: LD_EXP 99
58182: PPUSH
58183: LD_VAR 0 1
58187: PPUSH
58188: EMPTY
58189: PPUSH
58190: CALL_OW 1
58194: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58195: LD_ADDR_EXP 100
58199: PUSH
58200: LD_EXP 100
58204: PPUSH
58205: LD_VAR 0 1
58209: PPUSH
58210: LD_INT 0
58212: PPUSH
58213: CALL_OW 1
58217: ST_TO_ADDR
// end ;
58218: LD_VAR 0 2
58222: RET
// export function MC_Add ( side , units ) ; var base ; begin
58223: LD_INT 0
58225: PPUSH
58226: PPUSH
// base := mc_bases + 1 ;
58227: LD_ADDR_VAR 0 4
58231: PUSH
58232: LD_EXP 58
58236: PUSH
58237: LD_INT 1
58239: PLUS
58240: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58241: LD_ADDR_EXP 84
58245: PUSH
58246: LD_EXP 84
58250: PPUSH
58251: LD_VAR 0 4
58255: PPUSH
58256: LD_VAR 0 1
58260: PPUSH
58261: CALL_OW 1
58265: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58266: LD_ADDR_EXP 58
58270: PUSH
58271: LD_EXP 58
58275: PPUSH
58276: LD_VAR 0 4
58280: PPUSH
58281: LD_VAR 0 2
58285: PPUSH
58286: CALL_OW 1
58290: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58291: LD_ADDR_EXP 59
58295: PUSH
58296: LD_EXP 59
58300: PPUSH
58301: LD_VAR 0 4
58305: PPUSH
58306: EMPTY
58307: PPUSH
58308: CALL_OW 1
58312: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58313: LD_ADDR_EXP 60
58317: PUSH
58318: LD_EXP 60
58322: PPUSH
58323: LD_VAR 0 4
58327: PPUSH
58328: EMPTY
58329: PPUSH
58330: CALL_OW 1
58334: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58335: LD_ADDR_EXP 61
58339: PUSH
58340: LD_EXP 61
58344: PPUSH
58345: LD_VAR 0 4
58349: PPUSH
58350: EMPTY
58351: PPUSH
58352: CALL_OW 1
58356: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58357: LD_ADDR_EXP 62
58361: PUSH
58362: LD_EXP 62
58366: PPUSH
58367: LD_VAR 0 4
58371: PPUSH
58372: EMPTY
58373: PPUSH
58374: CALL_OW 1
58378: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58379: LD_ADDR_EXP 63
58383: PUSH
58384: LD_EXP 63
58388: PPUSH
58389: LD_VAR 0 4
58393: PPUSH
58394: EMPTY
58395: PPUSH
58396: CALL_OW 1
58400: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58401: LD_ADDR_EXP 64
58405: PUSH
58406: LD_EXP 64
58410: PPUSH
58411: LD_VAR 0 4
58415: PPUSH
58416: EMPTY
58417: PPUSH
58418: CALL_OW 1
58422: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58423: LD_ADDR_EXP 65
58427: PUSH
58428: LD_EXP 65
58432: PPUSH
58433: LD_VAR 0 4
58437: PPUSH
58438: EMPTY
58439: PPUSH
58440: CALL_OW 1
58444: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58445: LD_ADDR_EXP 66
58449: PUSH
58450: LD_EXP 66
58454: PPUSH
58455: LD_VAR 0 4
58459: PPUSH
58460: EMPTY
58461: PPUSH
58462: CALL_OW 1
58466: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58467: LD_ADDR_EXP 67
58471: PUSH
58472: LD_EXP 67
58476: PPUSH
58477: LD_VAR 0 4
58481: PPUSH
58482: EMPTY
58483: PPUSH
58484: CALL_OW 1
58488: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58489: LD_ADDR_EXP 68
58493: PUSH
58494: LD_EXP 68
58498: PPUSH
58499: LD_VAR 0 4
58503: PPUSH
58504: EMPTY
58505: PPUSH
58506: CALL_OW 1
58510: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58511: LD_ADDR_EXP 69
58515: PUSH
58516: LD_EXP 69
58520: PPUSH
58521: LD_VAR 0 4
58525: PPUSH
58526: LD_INT 0
58528: PPUSH
58529: CALL_OW 1
58533: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58534: LD_ADDR_EXP 70
58538: PUSH
58539: LD_EXP 70
58543: PPUSH
58544: LD_VAR 0 4
58548: PPUSH
58549: EMPTY
58550: PPUSH
58551: CALL_OW 1
58555: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58556: LD_ADDR_EXP 71
58560: PUSH
58561: LD_EXP 71
58565: PPUSH
58566: LD_VAR 0 4
58570: PPUSH
58571: EMPTY
58572: PPUSH
58573: CALL_OW 1
58577: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58578: LD_ADDR_EXP 72
58582: PUSH
58583: LD_EXP 72
58587: PPUSH
58588: LD_VAR 0 4
58592: PPUSH
58593: EMPTY
58594: PPUSH
58595: CALL_OW 1
58599: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58600: LD_ADDR_EXP 73
58604: PUSH
58605: LD_EXP 73
58609: PPUSH
58610: LD_VAR 0 4
58614: PPUSH
58615: EMPTY
58616: PPUSH
58617: CALL_OW 1
58621: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58622: LD_ADDR_EXP 74
58626: PUSH
58627: LD_EXP 74
58631: PPUSH
58632: LD_VAR 0 4
58636: PPUSH
58637: EMPTY
58638: PPUSH
58639: CALL_OW 1
58643: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58644: LD_ADDR_EXP 75
58648: PUSH
58649: LD_EXP 75
58653: PPUSH
58654: LD_VAR 0 4
58658: PPUSH
58659: EMPTY
58660: PPUSH
58661: CALL_OW 1
58665: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58666: LD_ADDR_EXP 76
58670: PUSH
58671: LD_EXP 76
58675: PPUSH
58676: LD_VAR 0 4
58680: PPUSH
58681: EMPTY
58682: PPUSH
58683: CALL_OW 1
58687: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58688: LD_ADDR_EXP 77
58692: PUSH
58693: LD_EXP 77
58697: PPUSH
58698: LD_VAR 0 4
58702: PPUSH
58703: EMPTY
58704: PPUSH
58705: CALL_OW 1
58709: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58710: LD_ADDR_EXP 78
58714: PUSH
58715: LD_EXP 78
58719: PPUSH
58720: LD_VAR 0 4
58724: PPUSH
58725: EMPTY
58726: PPUSH
58727: CALL_OW 1
58731: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58732: LD_ADDR_EXP 79
58736: PUSH
58737: LD_EXP 79
58741: PPUSH
58742: LD_VAR 0 4
58746: PPUSH
58747: EMPTY
58748: PPUSH
58749: CALL_OW 1
58753: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58754: LD_ADDR_EXP 80
58758: PUSH
58759: LD_EXP 80
58763: PPUSH
58764: LD_VAR 0 4
58768: PPUSH
58769: EMPTY
58770: PPUSH
58771: CALL_OW 1
58775: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58776: LD_ADDR_EXP 81
58780: PUSH
58781: LD_EXP 81
58785: PPUSH
58786: LD_VAR 0 4
58790: PPUSH
58791: EMPTY
58792: PPUSH
58793: CALL_OW 1
58797: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58798: LD_ADDR_EXP 82
58802: PUSH
58803: LD_EXP 82
58807: PPUSH
58808: LD_VAR 0 4
58812: PPUSH
58813: EMPTY
58814: PPUSH
58815: CALL_OW 1
58819: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58820: LD_ADDR_EXP 83
58824: PUSH
58825: LD_EXP 83
58829: PPUSH
58830: LD_VAR 0 4
58834: PPUSH
58835: EMPTY
58836: PPUSH
58837: CALL_OW 1
58841: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58842: LD_ADDR_EXP 85
58846: PUSH
58847: LD_EXP 85
58851: PPUSH
58852: LD_VAR 0 4
58856: PPUSH
58857: EMPTY
58858: PPUSH
58859: CALL_OW 1
58863: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58864: LD_ADDR_EXP 87
58868: PUSH
58869: LD_EXP 87
58873: PPUSH
58874: LD_VAR 0 4
58878: PPUSH
58879: EMPTY
58880: PPUSH
58881: CALL_OW 1
58885: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58886: LD_ADDR_EXP 88
58890: PUSH
58891: LD_EXP 88
58895: PPUSH
58896: LD_VAR 0 4
58900: PPUSH
58901: EMPTY
58902: PPUSH
58903: CALL_OW 1
58907: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58908: LD_ADDR_EXP 89
58912: PUSH
58913: LD_EXP 89
58917: PPUSH
58918: LD_VAR 0 4
58922: PPUSH
58923: EMPTY
58924: PPUSH
58925: CALL_OW 1
58929: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58930: LD_ADDR_EXP 90
58934: PUSH
58935: LD_EXP 90
58939: PPUSH
58940: LD_VAR 0 4
58944: PPUSH
58945: EMPTY
58946: PPUSH
58947: CALL_OW 1
58951: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58952: LD_ADDR_EXP 91
58956: PUSH
58957: LD_EXP 91
58961: PPUSH
58962: LD_VAR 0 4
58966: PPUSH
58967: EMPTY
58968: PPUSH
58969: CALL_OW 1
58973: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58974: LD_ADDR_EXP 92
58978: PUSH
58979: LD_EXP 92
58983: PPUSH
58984: LD_VAR 0 4
58988: PPUSH
58989: EMPTY
58990: PPUSH
58991: CALL_OW 1
58995: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58996: LD_ADDR_EXP 93
59000: PUSH
59001: LD_EXP 93
59005: PPUSH
59006: LD_VAR 0 4
59010: PPUSH
59011: EMPTY
59012: PPUSH
59013: CALL_OW 1
59017: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59018: LD_ADDR_EXP 94
59022: PUSH
59023: LD_EXP 94
59027: PPUSH
59028: LD_VAR 0 4
59032: PPUSH
59033: EMPTY
59034: PPUSH
59035: CALL_OW 1
59039: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59040: LD_ADDR_EXP 95
59044: PUSH
59045: LD_EXP 95
59049: PPUSH
59050: LD_VAR 0 4
59054: PPUSH
59055: EMPTY
59056: PPUSH
59057: CALL_OW 1
59061: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59062: LD_ADDR_EXP 96
59066: PUSH
59067: LD_EXP 96
59071: PPUSH
59072: LD_VAR 0 4
59076: PPUSH
59077: EMPTY
59078: PPUSH
59079: CALL_OW 1
59083: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59084: LD_ADDR_EXP 97
59088: PUSH
59089: LD_EXP 97
59093: PPUSH
59094: LD_VAR 0 4
59098: PPUSH
59099: EMPTY
59100: PPUSH
59101: CALL_OW 1
59105: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59106: LD_ADDR_EXP 98
59110: PUSH
59111: LD_EXP 98
59115: PPUSH
59116: LD_VAR 0 4
59120: PPUSH
59121: EMPTY
59122: PPUSH
59123: CALL_OW 1
59127: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59128: LD_ADDR_EXP 99
59132: PUSH
59133: LD_EXP 99
59137: PPUSH
59138: LD_VAR 0 4
59142: PPUSH
59143: EMPTY
59144: PPUSH
59145: CALL_OW 1
59149: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59150: LD_ADDR_EXP 100
59154: PUSH
59155: LD_EXP 100
59159: PPUSH
59160: LD_VAR 0 4
59164: PPUSH
59165: LD_INT 0
59167: PPUSH
59168: CALL_OW 1
59172: ST_TO_ADDR
// result := base ;
59173: LD_ADDR_VAR 0 3
59177: PUSH
59178: LD_VAR 0 4
59182: ST_TO_ADDR
// end ;
59183: LD_VAR 0 3
59187: RET
// export function MC_Start ( ) ; var i ; begin
59188: LD_INT 0
59190: PPUSH
59191: PPUSH
// for i = 1 to mc_bases do
59192: LD_ADDR_VAR 0 2
59196: PUSH
59197: DOUBLE
59198: LD_INT 1
59200: DEC
59201: ST_TO_ADDR
59202: LD_EXP 58
59206: PUSH
59207: FOR_TO
59208: IFFALSE 60285
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59210: LD_ADDR_EXP 58
59214: PUSH
59215: LD_EXP 58
59219: PPUSH
59220: LD_VAR 0 2
59224: PPUSH
59225: LD_EXP 58
59229: PUSH
59230: LD_VAR 0 2
59234: ARRAY
59235: PUSH
59236: LD_INT 0
59238: DIFF
59239: PPUSH
59240: CALL_OW 1
59244: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59245: LD_ADDR_EXP 59
59249: PUSH
59250: LD_EXP 59
59254: PPUSH
59255: LD_VAR 0 2
59259: PPUSH
59260: EMPTY
59261: PPUSH
59262: CALL_OW 1
59266: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59267: LD_ADDR_EXP 60
59271: PUSH
59272: LD_EXP 60
59276: PPUSH
59277: LD_VAR 0 2
59281: PPUSH
59282: EMPTY
59283: PPUSH
59284: CALL_OW 1
59288: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59289: LD_ADDR_EXP 61
59293: PUSH
59294: LD_EXP 61
59298: PPUSH
59299: LD_VAR 0 2
59303: PPUSH
59304: EMPTY
59305: PPUSH
59306: CALL_OW 1
59310: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59311: LD_ADDR_EXP 62
59315: PUSH
59316: LD_EXP 62
59320: PPUSH
59321: LD_VAR 0 2
59325: PPUSH
59326: EMPTY
59327: PUSH
59328: EMPTY
59329: PUSH
59330: EMPTY
59331: LIST
59332: LIST
59333: PPUSH
59334: CALL_OW 1
59338: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59339: LD_ADDR_EXP 63
59343: PUSH
59344: LD_EXP 63
59348: PPUSH
59349: LD_VAR 0 2
59353: PPUSH
59354: EMPTY
59355: PPUSH
59356: CALL_OW 1
59360: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59361: LD_ADDR_EXP 90
59365: PUSH
59366: LD_EXP 90
59370: PPUSH
59371: LD_VAR 0 2
59375: PPUSH
59376: EMPTY
59377: PPUSH
59378: CALL_OW 1
59382: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59383: LD_ADDR_EXP 64
59387: PUSH
59388: LD_EXP 64
59392: PPUSH
59393: LD_VAR 0 2
59397: PPUSH
59398: EMPTY
59399: PPUSH
59400: CALL_OW 1
59404: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59405: LD_ADDR_EXP 65
59409: PUSH
59410: LD_EXP 65
59414: PPUSH
59415: LD_VAR 0 2
59419: PPUSH
59420: EMPTY
59421: PPUSH
59422: CALL_OW 1
59426: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59427: LD_ADDR_EXP 66
59431: PUSH
59432: LD_EXP 66
59436: PPUSH
59437: LD_VAR 0 2
59441: PPUSH
59442: LD_EXP 58
59446: PUSH
59447: LD_VAR 0 2
59451: ARRAY
59452: PPUSH
59453: LD_INT 2
59455: PUSH
59456: LD_INT 30
59458: PUSH
59459: LD_INT 32
59461: PUSH
59462: EMPTY
59463: LIST
59464: LIST
59465: PUSH
59466: LD_INT 30
59468: PUSH
59469: LD_INT 33
59471: PUSH
59472: EMPTY
59473: LIST
59474: LIST
59475: PUSH
59476: EMPTY
59477: LIST
59478: LIST
59479: LIST
59480: PPUSH
59481: CALL_OW 72
59485: PPUSH
59486: CALL_OW 1
59490: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59491: LD_ADDR_EXP 67
59495: PUSH
59496: LD_EXP 67
59500: PPUSH
59501: LD_VAR 0 2
59505: PPUSH
59506: LD_EXP 58
59510: PUSH
59511: LD_VAR 0 2
59515: ARRAY
59516: PPUSH
59517: LD_INT 2
59519: PUSH
59520: LD_INT 30
59522: PUSH
59523: LD_INT 32
59525: PUSH
59526: EMPTY
59527: LIST
59528: LIST
59529: PUSH
59530: LD_INT 30
59532: PUSH
59533: LD_INT 31
59535: PUSH
59536: EMPTY
59537: LIST
59538: LIST
59539: PUSH
59540: EMPTY
59541: LIST
59542: LIST
59543: LIST
59544: PUSH
59545: LD_INT 58
59547: PUSH
59548: EMPTY
59549: LIST
59550: PUSH
59551: EMPTY
59552: LIST
59553: LIST
59554: PPUSH
59555: CALL_OW 72
59559: PPUSH
59560: CALL_OW 1
59564: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59565: LD_ADDR_EXP 68
59569: PUSH
59570: LD_EXP 68
59574: PPUSH
59575: LD_VAR 0 2
59579: PPUSH
59580: EMPTY
59581: PPUSH
59582: CALL_OW 1
59586: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59587: LD_ADDR_EXP 72
59591: PUSH
59592: LD_EXP 72
59596: PPUSH
59597: LD_VAR 0 2
59601: PPUSH
59602: EMPTY
59603: PPUSH
59604: CALL_OW 1
59608: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59609: LD_ADDR_EXP 71
59613: PUSH
59614: LD_EXP 71
59618: PPUSH
59619: LD_VAR 0 2
59623: PPUSH
59624: EMPTY
59625: PPUSH
59626: CALL_OW 1
59630: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59631: LD_ADDR_EXP 73
59635: PUSH
59636: LD_EXP 73
59640: PPUSH
59641: LD_VAR 0 2
59645: PPUSH
59646: EMPTY
59647: PPUSH
59648: CALL_OW 1
59652: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59653: LD_ADDR_EXP 74
59657: PUSH
59658: LD_EXP 74
59662: PPUSH
59663: LD_VAR 0 2
59667: PPUSH
59668: EMPTY
59669: PPUSH
59670: CALL_OW 1
59674: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59675: LD_ADDR_EXP 75
59679: PUSH
59680: LD_EXP 75
59684: PPUSH
59685: LD_VAR 0 2
59689: PPUSH
59690: EMPTY
59691: PPUSH
59692: CALL_OW 1
59696: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59697: LD_ADDR_EXP 76
59701: PUSH
59702: LD_EXP 76
59706: PPUSH
59707: LD_VAR 0 2
59711: PPUSH
59712: EMPTY
59713: PPUSH
59714: CALL_OW 1
59718: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59719: LD_ADDR_EXP 77
59723: PUSH
59724: LD_EXP 77
59728: PPUSH
59729: LD_VAR 0 2
59733: PPUSH
59734: EMPTY
59735: PPUSH
59736: CALL_OW 1
59740: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59741: LD_ADDR_EXP 78
59745: PUSH
59746: LD_EXP 78
59750: PPUSH
59751: LD_VAR 0 2
59755: PPUSH
59756: EMPTY
59757: PPUSH
59758: CALL_OW 1
59762: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59763: LD_ADDR_EXP 79
59767: PUSH
59768: LD_EXP 79
59772: PPUSH
59773: LD_VAR 0 2
59777: PPUSH
59778: EMPTY
59779: PPUSH
59780: CALL_OW 1
59784: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59785: LD_ADDR_EXP 80
59789: PUSH
59790: LD_EXP 80
59794: PPUSH
59795: LD_VAR 0 2
59799: PPUSH
59800: EMPTY
59801: PPUSH
59802: CALL_OW 1
59806: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59807: LD_ADDR_EXP 69
59811: PUSH
59812: LD_EXP 69
59816: PPUSH
59817: LD_VAR 0 2
59821: PPUSH
59822: LD_INT 0
59824: PPUSH
59825: CALL_OW 1
59829: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59830: LD_ADDR_EXP 82
59834: PUSH
59835: LD_EXP 82
59839: PPUSH
59840: LD_VAR 0 2
59844: PPUSH
59845: LD_INT 0
59847: PPUSH
59848: CALL_OW 1
59852: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59853: LD_ADDR_EXP 70
59857: PUSH
59858: LD_EXP 70
59862: PPUSH
59863: LD_VAR 0 2
59867: PPUSH
59868: EMPTY
59869: PPUSH
59870: CALL_OW 1
59874: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59875: LD_ADDR_EXP 81
59879: PUSH
59880: LD_EXP 81
59884: PPUSH
59885: LD_VAR 0 2
59889: PPUSH
59890: LD_INT 0
59892: PPUSH
59893: CALL_OW 1
59897: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59898: LD_ADDR_EXP 83
59902: PUSH
59903: LD_EXP 83
59907: PPUSH
59908: LD_VAR 0 2
59912: PPUSH
59913: EMPTY
59914: PPUSH
59915: CALL_OW 1
59919: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59920: LD_ADDR_EXP 86
59924: PUSH
59925: LD_EXP 86
59929: PPUSH
59930: LD_VAR 0 2
59934: PPUSH
59935: LD_INT 0
59937: PPUSH
59938: CALL_OW 1
59942: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59943: LD_ADDR_EXP 87
59947: PUSH
59948: LD_EXP 87
59952: PPUSH
59953: LD_VAR 0 2
59957: PPUSH
59958: EMPTY
59959: PPUSH
59960: CALL_OW 1
59964: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59965: LD_ADDR_EXP 88
59969: PUSH
59970: LD_EXP 88
59974: PPUSH
59975: LD_VAR 0 2
59979: PPUSH
59980: EMPTY
59981: PPUSH
59982: CALL_OW 1
59986: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59987: LD_ADDR_EXP 89
59991: PUSH
59992: LD_EXP 89
59996: PPUSH
59997: LD_VAR 0 2
60001: PPUSH
60002: EMPTY
60003: PPUSH
60004: CALL_OW 1
60008: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60009: LD_ADDR_EXP 91
60013: PUSH
60014: LD_EXP 91
60018: PPUSH
60019: LD_VAR 0 2
60023: PPUSH
60024: LD_EXP 58
60028: PUSH
60029: LD_VAR 0 2
60033: ARRAY
60034: PPUSH
60035: LD_INT 2
60037: PUSH
60038: LD_INT 30
60040: PUSH
60041: LD_INT 6
60043: PUSH
60044: EMPTY
60045: LIST
60046: LIST
60047: PUSH
60048: LD_INT 30
60050: PUSH
60051: LD_INT 7
60053: PUSH
60054: EMPTY
60055: LIST
60056: LIST
60057: PUSH
60058: LD_INT 30
60060: PUSH
60061: LD_INT 8
60063: PUSH
60064: EMPTY
60065: LIST
60066: LIST
60067: PUSH
60068: EMPTY
60069: LIST
60070: LIST
60071: LIST
60072: LIST
60073: PPUSH
60074: CALL_OW 72
60078: PPUSH
60079: CALL_OW 1
60083: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60084: LD_ADDR_EXP 92
60088: PUSH
60089: LD_EXP 92
60093: PPUSH
60094: LD_VAR 0 2
60098: PPUSH
60099: EMPTY
60100: PPUSH
60101: CALL_OW 1
60105: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60106: LD_ADDR_EXP 93
60110: PUSH
60111: LD_EXP 93
60115: PPUSH
60116: LD_VAR 0 2
60120: PPUSH
60121: EMPTY
60122: PPUSH
60123: CALL_OW 1
60127: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60128: LD_ADDR_EXP 94
60132: PUSH
60133: LD_EXP 94
60137: PPUSH
60138: LD_VAR 0 2
60142: PPUSH
60143: EMPTY
60144: PPUSH
60145: CALL_OW 1
60149: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60150: LD_ADDR_EXP 95
60154: PUSH
60155: LD_EXP 95
60159: PPUSH
60160: LD_VAR 0 2
60164: PPUSH
60165: EMPTY
60166: PPUSH
60167: CALL_OW 1
60171: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60172: LD_ADDR_EXP 96
60176: PUSH
60177: LD_EXP 96
60181: PPUSH
60182: LD_VAR 0 2
60186: PPUSH
60187: EMPTY
60188: PPUSH
60189: CALL_OW 1
60193: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60194: LD_ADDR_EXP 97
60198: PUSH
60199: LD_EXP 97
60203: PPUSH
60204: LD_VAR 0 2
60208: PPUSH
60209: EMPTY
60210: PPUSH
60211: CALL_OW 1
60215: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60216: LD_ADDR_EXP 98
60220: PUSH
60221: LD_EXP 98
60225: PPUSH
60226: LD_VAR 0 2
60230: PPUSH
60231: EMPTY
60232: PPUSH
60233: CALL_OW 1
60237: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60238: LD_ADDR_EXP 99
60242: PUSH
60243: LD_EXP 99
60247: PPUSH
60248: LD_VAR 0 2
60252: PPUSH
60253: EMPTY
60254: PPUSH
60255: CALL_OW 1
60259: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60260: LD_ADDR_EXP 100
60264: PUSH
60265: LD_EXP 100
60269: PPUSH
60270: LD_VAR 0 2
60274: PPUSH
60275: LD_INT 0
60277: PPUSH
60278: CALL_OW 1
60282: ST_TO_ADDR
// end ;
60283: GO 59207
60285: POP
60286: POP
// MC_InitSides ( ) ;
60287: CALL 60573 0 0
// MC_InitResearch ( ) ;
60291: CALL 60312 0 0
// CustomInitMacro ( ) ;
60295: CALL 181 0 0
// skirmish := true ;
60299: LD_ADDR_EXP 56
60303: PUSH
60304: LD_INT 1
60306: ST_TO_ADDR
// end ;
60307: LD_VAR 0 1
60311: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60312: LD_INT 0
60314: PPUSH
60315: PPUSH
60316: PPUSH
60317: PPUSH
60318: PPUSH
60319: PPUSH
// if not mc_bases then
60320: LD_EXP 58
60324: NOT
60325: IFFALSE 60329
// exit ;
60327: GO 60568
// for i = 1 to 8 do
60329: LD_ADDR_VAR 0 2
60333: PUSH
60334: DOUBLE
60335: LD_INT 1
60337: DEC
60338: ST_TO_ADDR
60339: LD_INT 8
60341: PUSH
60342: FOR_TO
60343: IFFALSE 60369
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60345: LD_ADDR_EXP 85
60349: PUSH
60350: LD_EXP 85
60354: PPUSH
60355: LD_VAR 0 2
60359: PPUSH
60360: EMPTY
60361: PPUSH
60362: CALL_OW 1
60366: ST_TO_ADDR
60367: GO 60342
60369: POP
60370: POP
// tmp := [ ] ;
60371: LD_ADDR_VAR 0 5
60375: PUSH
60376: EMPTY
60377: ST_TO_ADDR
// for i = 1 to mc_sides do
60378: LD_ADDR_VAR 0 2
60382: PUSH
60383: DOUBLE
60384: LD_INT 1
60386: DEC
60387: ST_TO_ADDR
60388: LD_EXP 84
60392: PUSH
60393: FOR_TO
60394: IFFALSE 60452
// if not mc_sides [ i ] in tmp then
60396: LD_EXP 84
60400: PUSH
60401: LD_VAR 0 2
60405: ARRAY
60406: PUSH
60407: LD_VAR 0 5
60411: IN
60412: NOT
60413: IFFALSE 60450
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60415: LD_ADDR_VAR 0 5
60419: PUSH
60420: LD_VAR 0 5
60424: PPUSH
60425: LD_VAR 0 5
60429: PUSH
60430: LD_INT 1
60432: PLUS
60433: PPUSH
60434: LD_EXP 84
60438: PUSH
60439: LD_VAR 0 2
60443: ARRAY
60444: PPUSH
60445: CALL_OW 2
60449: ST_TO_ADDR
60450: GO 60393
60452: POP
60453: POP
// if not tmp then
60454: LD_VAR 0 5
60458: NOT
60459: IFFALSE 60463
// exit ;
60461: GO 60568
// for j in tmp do
60463: LD_ADDR_VAR 0 3
60467: PUSH
60468: LD_VAR 0 5
60472: PUSH
60473: FOR_IN
60474: IFFALSE 60566
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60476: LD_ADDR_VAR 0 6
60480: PUSH
60481: LD_INT 22
60483: PUSH
60484: LD_VAR 0 3
60488: PUSH
60489: EMPTY
60490: LIST
60491: LIST
60492: PPUSH
60493: CALL_OW 69
60497: ST_TO_ADDR
// if not un then
60498: LD_VAR 0 6
60502: NOT
60503: IFFALSE 60507
// continue ;
60505: GO 60473
// nation := GetNation ( un [ 1 ] ) ;
60507: LD_ADDR_VAR 0 4
60511: PUSH
60512: LD_VAR 0 6
60516: PUSH
60517: LD_INT 1
60519: ARRAY
60520: PPUSH
60521: CALL_OW 248
60525: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60526: LD_ADDR_EXP 85
60530: PUSH
60531: LD_EXP 85
60535: PPUSH
60536: LD_VAR 0 3
60540: PPUSH
60541: LD_VAR 0 3
60545: PPUSH
60546: LD_VAR 0 4
60550: PPUSH
60551: LD_INT 1
60553: PPUSH
60554: CALL 14126 0 3
60558: PPUSH
60559: CALL_OW 1
60563: ST_TO_ADDR
// end ;
60564: GO 60473
60566: POP
60567: POP
// end ;
60568: LD_VAR 0 1
60572: RET
// export function MC_InitSides ( ) ; var i ; begin
60573: LD_INT 0
60575: PPUSH
60576: PPUSH
// if not mc_bases then
60577: LD_EXP 58
60581: NOT
60582: IFFALSE 60586
// exit ;
60584: GO 60660
// for i = 1 to mc_bases do
60586: LD_ADDR_VAR 0 2
60590: PUSH
60591: DOUBLE
60592: LD_INT 1
60594: DEC
60595: ST_TO_ADDR
60596: LD_EXP 58
60600: PUSH
60601: FOR_TO
60602: IFFALSE 60658
// if mc_bases [ i ] then
60604: LD_EXP 58
60608: PUSH
60609: LD_VAR 0 2
60613: ARRAY
60614: IFFALSE 60656
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60616: LD_ADDR_EXP 84
60620: PUSH
60621: LD_EXP 84
60625: PPUSH
60626: LD_VAR 0 2
60630: PPUSH
60631: LD_EXP 58
60635: PUSH
60636: LD_VAR 0 2
60640: ARRAY
60641: PUSH
60642: LD_INT 1
60644: ARRAY
60645: PPUSH
60646: CALL_OW 255
60650: PPUSH
60651: CALL_OW 1
60655: ST_TO_ADDR
60656: GO 60601
60658: POP
60659: POP
// end ;
60660: LD_VAR 0 1
60664: RET
// every 0 0$01 trigger skirmish do
60665: LD_EXP 56
60669: IFFALSE 60823
60671: GO 60673
60673: DISABLE
// begin enable ;
60674: ENABLE
// MC_CheckBuildings ( ) ;
60675: CALL 65321 0 0
// MC_CheckPeopleLife ( ) ;
60679: CALL 65446 0 0
// RaiseSailEvent ( 100 ) ;
60683: LD_INT 100
60685: PPUSH
60686: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60690: LD_INT 103
60692: PPUSH
60693: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60697: LD_INT 104
60699: PPUSH
60700: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60704: LD_INT 105
60706: PPUSH
60707: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60711: LD_INT 106
60713: PPUSH
60714: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60718: LD_INT 107
60720: PPUSH
60721: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60725: LD_INT 108
60727: PPUSH
60728: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60732: LD_INT 109
60734: PPUSH
60735: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60739: LD_INT 110
60741: PPUSH
60742: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60746: LD_INT 111
60748: PPUSH
60749: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60753: LD_INT 112
60755: PPUSH
60756: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60760: LD_INT 113
60762: PPUSH
60763: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60767: LD_INT 120
60769: PPUSH
60770: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60774: LD_INT 121
60776: PPUSH
60777: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60781: LD_INT 122
60783: PPUSH
60784: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60788: LD_INT 123
60790: PPUSH
60791: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60795: LD_INT 124
60797: PPUSH
60798: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60802: LD_INT 125
60804: PPUSH
60805: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60809: LD_INT 126
60811: PPUSH
60812: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60816: LD_INT 200
60818: PPUSH
60819: CALL_OW 427
// end ;
60823: END
// on SailEvent ( event ) do begin if event < 100 then
60824: LD_VAR 0 1
60828: PUSH
60829: LD_INT 100
60831: LESS
60832: IFFALSE 60843
// CustomEvent ( event ) ;
60834: LD_VAR 0 1
60838: PPUSH
60839: CALL 12828 0 1
// if event = 100 then
60843: LD_VAR 0 1
60847: PUSH
60848: LD_INT 100
60850: EQUAL
60851: IFFALSE 60857
// MC_ClassManager ( ) ;
60853: CALL 61249 0 0
// if event = 101 then
60857: LD_VAR 0 1
60861: PUSH
60862: LD_INT 101
60864: EQUAL
60865: IFFALSE 60871
// MC_RepairBuildings ( ) ;
60867: CALL 66042 0 0
// if event = 102 then
60871: LD_VAR 0 1
60875: PUSH
60876: LD_INT 102
60878: EQUAL
60879: IFFALSE 60885
// MC_Heal ( ) ;
60881: CALL 66774 0 0
// if event = 103 then
60885: LD_VAR 0 1
60889: PUSH
60890: LD_INT 103
60892: EQUAL
60893: IFFALSE 60899
// MC_Build ( ) ;
60895: CALL 67196 0 0
// if event = 104 then
60899: LD_VAR 0 1
60903: PUSH
60904: LD_INT 104
60906: EQUAL
60907: IFFALSE 60913
// MC_TurretWeapon ( ) ;
60909: CALL 68809 0 0
// if event = 105 then
60913: LD_VAR 0 1
60917: PUSH
60918: LD_INT 105
60920: EQUAL
60921: IFFALSE 60927
// MC_BuildUpgrade ( ) ;
60923: CALL 68360 0 0
// if event = 106 then
60927: LD_VAR 0 1
60931: PUSH
60932: LD_INT 106
60934: EQUAL
60935: IFFALSE 60941
// MC_PlantMines ( ) ;
60937: CALL 69239 0 0
// if event = 107 then
60941: LD_VAR 0 1
60945: PUSH
60946: LD_INT 107
60948: EQUAL
60949: IFFALSE 60955
// MC_CollectCrates ( ) ;
60951: CALL 70273 0 0
// if event = 108 then
60955: LD_VAR 0 1
60959: PUSH
60960: LD_INT 108
60962: EQUAL
60963: IFFALSE 60969
// MC_LinkRemoteControl ( ) ;
60965: CALL 72049 0 0
// if event = 109 then
60969: LD_VAR 0 1
60973: PUSH
60974: LD_INT 109
60976: EQUAL
60977: IFFALSE 60983
// MC_ProduceVehicle ( ) ;
60979: CALL 72230 0 0
// if event = 110 then
60983: LD_VAR 0 1
60987: PUSH
60988: LD_INT 110
60990: EQUAL
60991: IFFALSE 60997
// MC_SendAttack ( ) ;
60993: CALL 72696 0 0
// if event = 111 then
60997: LD_VAR 0 1
61001: PUSH
61002: LD_INT 111
61004: EQUAL
61005: IFFALSE 61011
// MC_Defend ( ) ;
61007: CALL 72804 0 0
// if event = 112 then
61011: LD_VAR 0 1
61015: PUSH
61016: LD_INT 112
61018: EQUAL
61019: IFFALSE 61025
// MC_Research ( ) ;
61021: CALL 73409 0 0
// if event = 113 then
61025: LD_VAR 0 1
61029: PUSH
61030: LD_INT 113
61032: EQUAL
61033: IFFALSE 61039
// MC_MinesTrigger ( ) ;
61035: CALL 74523 0 0
// if event = 120 then
61039: LD_VAR 0 1
61043: PUSH
61044: LD_INT 120
61046: EQUAL
61047: IFFALSE 61053
// MC_RepairVehicle ( ) ;
61049: CALL 74622 0 0
// if event = 121 then
61053: LD_VAR 0 1
61057: PUSH
61058: LD_INT 121
61060: EQUAL
61061: IFFALSE 61067
// MC_TameApe ( ) ;
61063: CALL 75352 0 0
// if event = 122 then
61067: LD_VAR 0 1
61071: PUSH
61072: LD_INT 122
61074: EQUAL
61075: IFFALSE 61081
// MC_ChangeApeClass ( ) ;
61077: CALL 76181 0 0
// if event = 123 then
61081: LD_VAR 0 1
61085: PUSH
61086: LD_INT 123
61088: EQUAL
61089: IFFALSE 61095
// MC_Bazooka ( ) ;
61091: CALL 76831 0 0
// if event = 124 then
61095: LD_VAR 0 1
61099: PUSH
61100: LD_INT 124
61102: EQUAL
61103: IFFALSE 61109
// MC_TeleportExit ( ) ;
61105: CALL 77029 0 0
// if event = 125 then
61109: LD_VAR 0 1
61113: PUSH
61114: LD_INT 125
61116: EQUAL
61117: IFFALSE 61123
// MC_Deposits ( ) ;
61119: CALL 77676 0 0
// if event = 126 then
61123: LD_VAR 0 1
61127: PUSH
61128: LD_INT 126
61130: EQUAL
61131: IFFALSE 61137
// MC_RemoteDriver ( ) ;
61133: CALL 78301 0 0
// if event = 200 then
61137: LD_VAR 0 1
61141: PUSH
61142: LD_INT 200
61144: EQUAL
61145: IFFALSE 61151
// MC_Idle ( ) ;
61147: CALL 80034 0 0
// end ;
61151: PPOPN 1
61153: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61154: LD_INT 0
61156: PPUSH
61157: PPUSH
// if not mc_bases [ base ] or not tag then
61158: LD_EXP 58
61162: PUSH
61163: LD_VAR 0 1
61167: ARRAY
61168: NOT
61169: PUSH
61170: LD_VAR 0 2
61174: NOT
61175: OR
61176: IFFALSE 61180
// exit ;
61178: GO 61244
// for i in mc_bases [ base ] union mc_ape [ base ] do
61180: LD_ADDR_VAR 0 4
61184: PUSH
61185: LD_EXP 58
61189: PUSH
61190: LD_VAR 0 1
61194: ARRAY
61195: PUSH
61196: LD_EXP 87
61200: PUSH
61201: LD_VAR 0 1
61205: ARRAY
61206: UNION
61207: PUSH
61208: FOR_IN
61209: IFFALSE 61242
// if GetTag ( i ) = tag then
61211: LD_VAR 0 4
61215: PPUSH
61216: CALL_OW 110
61220: PUSH
61221: LD_VAR 0 2
61225: EQUAL
61226: IFFALSE 61240
// SetTag ( i , 0 ) ;
61228: LD_VAR 0 4
61232: PPUSH
61233: LD_INT 0
61235: PPUSH
61236: CALL_OW 109
61240: GO 61208
61242: POP
61243: POP
// end ;
61244: LD_VAR 0 3
61248: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61249: LD_INT 0
61251: PPUSH
61252: PPUSH
61253: PPUSH
61254: PPUSH
61255: PPUSH
61256: PPUSH
61257: PPUSH
61258: PPUSH
// if not mc_bases then
61259: LD_EXP 58
61263: NOT
61264: IFFALSE 61268
// exit ;
61266: GO 61726
// for i = 1 to mc_bases do
61268: LD_ADDR_VAR 0 2
61272: PUSH
61273: DOUBLE
61274: LD_INT 1
61276: DEC
61277: ST_TO_ADDR
61278: LD_EXP 58
61282: PUSH
61283: FOR_TO
61284: IFFALSE 61724
// begin tmp := MC_ClassCheckReq ( i ) ;
61286: LD_ADDR_VAR 0 4
61290: PUSH
61291: LD_VAR 0 2
61295: PPUSH
61296: CALL 61731 0 1
61300: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61301: LD_ADDR_EXP 99
61305: PUSH
61306: LD_EXP 99
61310: PPUSH
61311: LD_VAR 0 2
61315: PPUSH
61316: LD_VAR 0 4
61320: PPUSH
61321: CALL_OW 1
61325: ST_TO_ADDR
// if not tmp then
61326: LD_VAR 0 4
61330: NOT
61331: IFFALSE 61335
// continue ;
61333: GO 61283
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61335: LD_ADDR_VAR 0 6
61339: PUSH
61340: LD_EXP 58
61344: PUSH
61345: LD_VAR 0 2
61349: ARRAY
61350: PPUSH
61351: LD_INT 2
61353: PUSH
61354: LD_INT 30
61356: PUSH
61357: LD_INT 4
61359: PUSH
61360: EMPTY
61361: LIST
61362: LIST
61363: PUSH
61364: LD_INT 30
61366: PUSH
61367: LD_INT 5
61369: PUSH
61370: EMPTY
61371: LIST
61372: LIST
61373: PUSH
61374: EMPTY
61375: LIST
61376: LIST
61377: LIST
61378: PPUSH
61379: CALL_OW 72
61383: PUSH
61384: LD_EXP 58
61388: PUSH
61389: LD_VAR 0 2
61393: ARRAY
61394: PPUSH
61395: LD_INT 2
61397: PUSH
61398: LD_INT 30
61400: PUSH
61401: LD_INT 0
61403: PUSH
61404: EMPTY
61405: LIST
61406: LIST
61407: PUSH
61408: LD_INT 30
61410: PUSH
61411: LD_INT 1
61413: PUSH
61414: EMPTY
61415: LIST
61416: LIST
61417: PUSH
61418: EMPTY
61419: LIST
61420: LIST
61421: LIST
61422: PPUSH
61423: CALL_OW 72
61427: PUSH
61428: LD_EXP 58
61432: PUSH
61433: LD_VAR 0 2
61437: ARRAY
61438: PPUSH
61439: LD_INT 30
61441: PUSH
61442: LD_INT 3
61444: PUSH
61445: EMPTY
61446: LIST
61447: LIST
61448: PPUSH
61449: CALL_OW 72
61453: PUSH
61454: LD_EXP 58
61458: PUSH
61459: LD_VAR 0 2
61463: ARRAY
61464: PPUSH
61465: LD_INT 2
61467: PUSH
61468: LD_INT 30
61470: PUSH
61471: LD_INT 6
61473: PUSH
61474: EMPTY
61475: LIST
61476: LIST
61477: PUSH
61478: LD_INT 30
61480: PUSH
61481: LD_INT 7
61483: PUSH
61484: EMPTY
61485: LIST
61486: LIST
61487: PUSH
61488: LD_INT 30
61490: PUSH
61491: LD_INT 8
61493: PUSH
61494: EMPTY
61495: LIST
61496: LIST
61497: PUSH
61498: EMPTY
61499: LIST
61500: LIST
61501: LIST
61502: LIST
61503: PPUSH
61504: CALL_OW 72
61508: PUSH
61509: EMPTY
61510: LIST
61511: LIST
61512: LIST
61513: LIST
61514: ST_TO_ADDR
// for j = 1 to 4 do
61515: LD_ADDR_VAR 0 3
61519: PUSH
61520: DOUBLE
61521: LD_INT 1
61523: DEC
61524: ST_TO_ADDR
61525: LD_INT 4
61527: PUSH
61528: FOR_TO
61529: IFFALSE 61720
// begin if not tmp [ j ] then
61531: LD_VAR 0 4
61535: PUSH
61536: LD_VAR 0 3
61540: ARRAY
61541: NOT
61542: IFFALSE 61546
// continue ;
61544: GO 61528
// for p in tmp [ j ] do
61546: LD_ADDR_VAR 0 5
61550: PUSH
61551: LD_VAR 0 4
61555: PUSH
61556: LD_VAR 0 3
61560: ARRAY
61561: PUSH
61562: FOR_IN
61563: IFFALSE 61716
// begin if not b [ j ] then
61565: LD_VAR 0 6
61569: PUSH
61570: LD_VAR 0 3
61574: ARRAY
61575: NOT
61576: IFFALSE 61580
// break ;
61578: GO 61716
// e := 0 ;
61580: LD_ADDR_VAR 0 7
61584: PUSH
61585: LD_INT 0
61587: ST_TO_ADDR
// for k in b [ j ] do
61588: LD_ADDR_VAR 0 8
61592: PUSH
61593: LD_VAR 0 6
61597: PUSH
61598: LD_VAR 0 3
61602: ARRAY
61603: PUSH
61604: FOR_IN
61605: IFFALSE 61632
// if IsNotFull ( k ) then
61607: LD_VAR 0 8
61611: PPUSH
61612: CALL 18417 0 1
61616: IFFALSE 61630
// begin e := k ;
61618: LD_ADDR_VAR 0 7
61622: PUSH
61623: LD_VAR 0 8
61627: ST_TO_ADDR
// break ;
61628: GO 61632
// end ;
61630: GO 61604
61632: POP
61633: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61634: LD_VAR 0 7
61638: PUSH
61639: LD_VAR 0 5
61643: PPUSH
61644: LD_VAR 0 7
61648: PPUSH
61649: CALL 55536 0 2
61653: NOT
61654: AND
61655: IFFALSE 61714
// begin if IsInUnit ( p ) then
61657: LD_VAR 0 5
61661: PPUSH
61662: CALL_OW 310
61666: IFFALSE 61677
// ComExitBuilding ( p ) ;
61668: LD_VAR 0 5
61672: PPUSH
61673: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61677: LD_VAR 0 5
61681: PPUSH
61682: LD_VAR 0 7
61686: PPUSH
61687: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61691: LD_VAR 0 5
61695: PPUSH
61696: LD_VAR 0 3
61700: PPUSH
61701: CALL_OW 183
// AddComExitBuilding ( p ) ;
61705: LD_VAR 0 5
61709: PPUSH
61710: CALL_OW 182
// end ; end ;
61714: GO 61562
61716: POP
61717: POP
// end ;
61718: GO 61528
61720: POP
61721: POP
// end ;
61722: GO 61283
61724: POP
61725: POP
// end ;
61726: LD_VAR 0 1
61730: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61731: LD_INT 0
61733: PPUSH
61734: PPUSH
61735: PPUSH
61736: PPUSH
61737: PPUSH
61738: PPUSH
61739: PPUSH
61740: PPUSH
61741: PPUSH
61742: PPUSH
61743: PPUSH
61744: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61745: LD_VAR 0 1
61749: NOT
61750: PUSH
61751: LD_EXP 58
61755: PUSH
61756: LD_VAR 0 1
61760: ARRAY
61761: NOT
61762: OR
61763: PUSH
61764: LD_EXP 58
61768: PUSH
61769: LD_VAR 0 1
61773: ARRAY
61774: PPUSH
61775: LD_INT 2
61777: PUSH
61778: LD_INT 30
61780: PUSH
61781: LD_INT 0
61783: PUSH
61784: EMPTY
61785: LIST
61786: LIST
61787: PUSH
61788: LD_INT 30
61790: PUSH
61791: LD_INT 1
61793: PUSH
61794: EMPTY
61795: LIST
61796: LIST
61797: PUSH
61798: EMPTY
61799: LIST
61800: LIST
61801: LIST
61802: PPUSH
61803: CALL_OW 72
61807: NOT
61808: OR
61809: IFFALSE 61813
// exit ;
61811: GO 65316
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61813: LD_ADDR_VAR 0 4
61817: PUSH
61818: LD_EXP 58
61822: PUSH
61823: LD_VAR 0 1
61827: ARRAY
61828: PPUSH
61829: LD_INT 2
61831: PUSH
61832: LD_INT 25
61834: PUSH
61835: LD_INT 1
61837: PUSH
61838: EMPTY
61839: LIST
61840: LIST
61841: PUSH
61842: LD_INT 25
61844: PUSH
61845: LD_INT 2
61847: PUSH
61848: EMPTY
61849: LIST
61850: LIST
61851: PUSH
61852: LD_INT 25
61854: PUSH
61855: LD_INT 3
61857: PUSH
61858: EMPTY
61859: LIST
61860: LIST
61861: PUSH
61862: LD_INT 25
61864: PUSH
61865: LD_INT 4
61867: PUSH
61868: EMPTY
61869: LIST
61870: LIST
61871: PUSH
61872: LD_INT 25
61874: PUSH
61875: LD_INT 5
61877: PUSH
61878: EMPTY
61879: LIST
61880: LIST
61881: PUSH
61882: LD_INT 25
61884: PUSH
61885: LD_INT 8
61887: PUSH
61888: EMPTY
61889: LIST
61890: LIST
61891: PUSH
61892: LD_INT 25
61894: PUSH
61895: LD_INT 9
61897: PUSH
61898: EMPTY
61899: LIST
61900: LIST
61901: PUSH
61902: EMPTY
61903: LIST
61904: LIST
61905: LIST
61906: LIST
61907: LIST
61908: LIST
61909: LIST
61910: LIST
61911: PPUSH
61912: CALL_OW 72
61916: ST_TO_ADDR
// if not tmp then
61917: LD_VAR 0 4
61921: NOT
61922: IFFALSE 61926
// exit ;
61924: GO 65316
// for i in tmp do
61926: LD_ADDR_VAR 0 3
61930: PUSH
61931: LD_VAR 0 4
61935: PUSH
61936: FOR_IN
61937: IFFALSE 61968
// if GetTag ( i ) then
61939: LD_VAR 0 3
61943: PPUSH
61944: CALL_OW 110
61948: IFFALSE 61966
// tmp := tmp diff i ;
61950: LD_ADDR_VAR 0 4
61954: PUSH
61955: LD_VAR 0 4
61959: PUSH
61960: LD_VAR 0 3
61964: DIFF
61965: ST_TO_ADDR
61966: GO 61936
61968: POP
61969: POP
// if not tmp then
61970: LD_VAR 0 4
61974: NOT
61975: IFFALSE 61979
// exit ;
61977: GO 65316
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61979: LD_ADDR_VAR 0 5
61983: PUSH
61984: LD_EXP 58
61988: PUSH
61989: LD_VAR 0 1
61993: ARRAY
61994: PPUSH
61995: LD_INT 2
61997: PUSH
61998: LD_INT 25
62000: PUSH
62001: LD_INT 1
62003: PUSH
62004: EMPTY
62005: LIST
62006: LIST
62007: PUSH
62008: LD_INT 25
62010: PUSH
62011: LD_INT 5
62013: PUSH
62014: EMPTY
62015: LIST
62016: LIST
62017: PUSH
62018: LD_INT 25
62020: PUSH
62021: LD_INT 8
62023: PUSH
62024: EMPTY
62025: LIST
62026: LIST
62027: PUSH
62028: LD_INT 25
62030: PUSH
62031: LD_INT 9
62033: PUSH
62034: EMPTY
62035: LIST
62036: LIST
62037: PUSH
62038: EMPTY
62039: LIST
62040: LIST
62041: LIST
62042: LIST
62043: LIST
62044: PPUSH
62045: CALL_OW 72
62049: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62050: LD_ADDR_VAR 0 6
62054: PUSH
62055: LD_EXP 58
62059: PUSH
62060: LD_VAR 0 1
62064: ARRAY
62065: PPUSH
62066: LD_INT 25
62068: PUSH
62069: LD_INT 2
62071: PUSH
62072: EMPTY
62073: LIST
62074: LIST
62075: PPUSH
62076: CALL_OW 72
62080: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62081: LD_ADDR_VAR 0 7
62085: PUSH
62086: LD_EXP 58
62090: PUSH
62091: LD_VAR 0 1
62095: ARRAY
62096: PPUSH
62097: LD_INT 25
62099: PUSH
62100: LD_INT 3
62102: PUSH
62103: EMPTY
62104: LIST
62105: LIST
62106: PPUSH
62107: CALL_OW 72
62111: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62112: LD_ADDR_VAR 0 8
62116: PUSH
62117: LD_EXP 58
62121: PUSH
62122: LD_VAR 0 1
62126: ARRAY
62127: PPUSH
62128: LD_INT 25
62130: PUSH
62131: LD_INT 4
62133: PUSH
62134: EMPTY
62135: LIST
62136: LIST
62137: PUSH
62138: LD_INT 24
62140: PUSH
62141: LD_INT 251
62143: PUSH
62144: EMPTY
62145: LIST
62146: LIST
62147: PUSH
62148: EMPTY
62149: LIST
62150: LIST
62151: PPUSH
62152: CALL_OW 72
62156: ST_TO_ADDR
// if mc_scan [ base ] then
62157: LD_EXP 81
62161: PUSH
62162: LD_VAR 0 1
62166: ARRAY
62167: IFFALSE 62628
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62169: LD_ADDR_EXP 100
62173: PUSH
62174: LD_EXP 100
62178: PPUSH
62179: LD_VAR 0 1
62183: PPUSH
62184: LD_INT 4
62186: PPUSH
62187: CALL_OW 1
62191: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62192: LD_ADDR_VAR 0 12
62196: PUSH
62197: LD_EXP 58
62201: PUSH
62202: LD_VAR 0 1
62206: ARRAY
62207: PPUSH
62208: LD_INT 2
62210: PUSH
62211: LD_INT 30
62213: PUSH
62214: LD_INT 4
62216: PUSH
62217: EMPTY
62218: LIST
62219: LIST
62220: PUSH
62221: LD_INT 30
62223: PUSH
62224: LD_INT 5
62226: PUSH
62227: EMPTY
62228: LIST
62229: LIST
62230: PUSH
62231: EMPTY
62232: LIST
62233: LIST
62234: LIST
62235: PPUSH
62236: CALL_OW 72
62240: ST_TO_ADDR
// if not b then
62241: LD_VAR 0 12
62245: NOT
62246: IFFALSE 62250
// exit ;
62248: GO 65316
// p := [ ] ;
62250: LD_ADDR_VAR 0 11
62254: PUSH
62255: EMPTY
62256: ST_TO_ADDR
// if sci >= 2 then
62257: LD_VAR 0 8
62261: PUSH
62262: LD_INT 2
62264: GREATEREQUAL
62265: IFFALSE 62296
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62267: LD_ADDR_VAR 0 8
62271: PUSH
62272: LD_VAR 0 8
62276: PUSH
62277: LD_INT 1
62279: ARRAY
62280: PUSH
62281: LD_VAR 0 8
62285: PUSH
62286: LD_INT 2
62288: ARRAY
62289: PUSH
62290: EMPTY
62291: LIST
62292: LIST
62293: ST_TO_ADDR
62294: GO 62357
// if sci = 1 then
62296: LD_VAR 0 8
62300: PUSH
62301: LD_INT 1
62303: EQUAL
62304: IFFALSE 62325
// sci := [ sci [ 1 ] ] else
62306: LD_ADDR_VAR 0 8
62310: PUSH
62311: LD_VAR 0 8
62315: PUSH
62316: LD_INT 1
62318: ARRAY
62319: PUSH
62320: EMPTY
62321: LIST
62322: ST_TO_ADDR
62323: GO 62357
// if sci = 0 then
62325: LD_VAR 0 8
62329: PUSH
62330: LD_INT 0
62332: EQUAL
62333: IFFALSE 62357
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62335: LD_ADDR_VAR 0 11
62339: PUSH
62340: LD_VAR 0 4
62344: PPUSH
62345: LD_INT 4
62347: PPUSH
62348: CALL 55399 0 2
62352: PUSH
62353: LD_INT 1
62355: ARRAY
62356: ST_TO_ADDR
// if eng > 4 then
62357: LD_VAR 0 6
62361: PUSH
62362: LD_INT 4
62364: GREATER
62365: IFFALSE 62411
// for i = eng downto 4 do
62367: LD_ADDR_VAR 0 3
62371: PUSH
62372: DOUBLE
62373: LD_VAR 0 6
62377: INC
62378: ST_TO_ADDR
62379: LD_INT 4
62381: PUSH
62382: FOR_DOWNTO
62383: IFFALSE 62409
// eng := eng diff eng [ i ] ;
62385: LD_ADDR_VAR 0 6
62389: PUSH
62390: LD_VAR 0 6
62394: PUSH
62395: LD_VAR 0 6
62399: PUSH
62400: LD_VAR 0 3
62404: ARRAY
62405: DIFF
62406: ST_TO_ADDR
62407: GO 62382
62409: POP
62410: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62411: LD_ADDR_VAR 0 4
62415: PUSH
62416: LD_VAR 0 4
62420: PUSH
62421: LD_VAR 0 5
62425: PUSH
62426: LD_VAR 0 6
62430: UNION
62431: PUSH
62432: LD_VAR 0 7
62436: UNION
62437: PUSH
62438: LD_VAR 0 8
62442: UNION
62443: DIFF
62444: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62445: LD_ADDR_VAR 0 13
62449: PUSH
62450: LD_EXP 58
62454: PUSH
62455: LD_VAR 0 1
62459: ARRAY
62460: PPUSH
62461: LD_INT 2
62463: PUSH
62464: LD_INT 30
62466: PUSH
62467: LD_INT 32
62469: PUSH
62470: EMPTY
62471: LIST
62472: LIST
62473: PUSH
62474: LD_INT 30
62476: PUSH
62477: LD_INT 31
62479: PUSH
62480: EMPTY
62481: LIST
62482: LIST
62483: PUSH
62484: EMPTY
62485: LIST
62486: LIST
62487: LIST
62488: PPUSH
62489: CALL_OW 72
62493: PUSH
62494: LD_EXP 58
62498: PUSH
62499: LD_VAR 0 1
62503: ARRAY
62504: PPUSH
62505: LD_INT 2
62507: PUSH
62508: LD_INT 30
62510: PUSH
62511: LD_INT 4
62513: PUSH
62514: EMPTY
62515: LIST
62516: LIST
62517: PUSH
62518: LD_INT 30
62520: PUSH
62521: LD_INT 5
62523: PUSH
62524: EMPTY
62525: LIST
62526: LIST
62527: PUSH
62528: EMPTY
62529: LIST
62530: LIST
62531: LIST
62532: PPUSH
62533: CALL_OW 72
62537: PUSH
62538: LD_INT 6
62540: MUL
62541: PLUS
62542: ST_TO_ADDR
// if bcount < tmp then
62543: LD_VAR 0 13
62547: PUSH
62548: LD_VAR 0 4
62552: LESS
62553: IFFALSE 62599
// for i = tmp downto bcount do
62555: LD_ADDR_VAR 0 3
62559: PUSH
62560: DOUBLE
62561: LD_VAR 0 4
62565: INC
62566: ST_TO_ADDR
62567: LD_VAR 0 13
62571: PUSH
62572: FOR_DOWNTO
62573: IFFALSE 62597
// tmp := Delete ( tmp , tmp ) ;
62575: LD_ADDR_VAR 0 4
62579: PUSH
62580: LD_VAR 0 4
62584: PPUSH
62585: LD_VAR 0 4
62589: PPUSH
62590: CALL_OW 3
62594: ST_TO_ADDR
62595: GO 62572
62597: POP
62598: POP
// result := [ tmp , 0 , 0 , p ] ;
62599: LD_ADDR_VAR 0 2
62603: PUSH
62604: LD_VAR 0 4
62608: PUSH
62609: LD_INT 0
62611: PUSH
62612: LD_INT 0
62614: PUSH
62615: LD_VAR 0 11
62619: PUSH
62620: EMPTY
62621: LIST
62622: LIST
62623: LIST
62624: LIST
62625: ST_TO_ADDR
// exit ;
62626: GO 65316
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62628: LD_EXP 58
62632: PUSH
62633: LD_VAR 0 1
62637: ARRAY
62638: PPUSH
62639: LD_INT 2
62641: PUSH
62642: LD_INT 30
62644: PUSH
62645: LD_INT 6
62647: PUSH
62648: EMPTY
62649: LIST
62650: LIST
62651: PUSH
62652: LD_INT 30
62654: PUSH
62655: LD_INT 7
62657: PUSH
62658: EMPTY
62659: LIST
62660: LIST
62661: PUSH
62662: LD_INT 30
62664: PUSH
62665: LD_INT 8
62667: PUSH
62668: EMPTY
62669: LIST
62670: LIST
62671: PUSH
62672: EMPTY
62673: LIST
62674: LIST
62675: LIST
62676: LIST
62677: PPUSH
62678: CALL_OW 72
62682: NOT
62683: PUSH
62684: LD_EXP 58
62688: PUSH
62689: LD_VAR 0 1
62693: ARRAY
62694: PPUSH
62695: LD_INT 30
62697: PUSH
62698: LD_INT 3
62700: PUSH
62701: EMPTY
62702: LIST
62703: LIST
62704: PPUSH
62705: CALL_OW 72
62709: NOT
62710: AND
62711: IFFALSE 62783
// begin if eng = tmp then
62713: LD_VAR 0 6
62717: PUSH
62718: LD_VAR 0 4
62722: EQUAL
62723: IFFALSE 62727
// exit ;
62725: GO 65316
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62727: LD_ADDR_EXP 100
62731: PUSH
62732: LD_EXP 100
62736: PPUSH
62737: LD_VAR 0 1
62741: PPUSH
62742: LD_INT 1
62744: PPUSH
62745: CALL_OW 1
62749: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62750: LD_ADDR_VAR 0 2
62754: PUSH
62755: LD_INT 0
62757: PUSH
62758: LD_VAR 0 4
62762: PUSH
62763: LD_VAR 0 6
62767: DIFF
62768: PUSH
62769: LD_INT 0
62771: PUSH
62772: LD_INT 0
62774: PUSH
62775: EMPTY
62776: LIST
62777: LIST
62778: LIST
62779: LIST
62780: ST_TO_ADDR
// exit ;
62781: GO 65316
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62783: LD_EXP 85
62787: PUSH
62788: LD_EXP 84
62792: PUSH
62793: LD_VAR 0 1
62797: ARRAY
62798: ARRAY
62799: PUSH
62800: LD_EXP 58
62804: PUSH
62805: LD_VAR 0 1
62809: ARRAY
62810: PPUSH
62811: LD_INT 2
62813: PUSH
62814: LD_INT 30
62816: PUSH
62817: LD_INT 6
62819: PUSH
62820: EMPTY
62821: LIST
62822: LIST
62823: PUSH
62824: LD_INT 30
62826: PUSH
62827: LD_INT 7
62829: PUSH
62830: EMPTY
62831: LIST
62832: LIST
62833: PUSH
62834: LD_INT 30
62836: PUSH
62837: LD_INT 8
62839: PUSH
62840: EMPTY
62841: LIST
62842: LIST
62843: PUSH
62844: EMPTY
62845: LIST
62846: LIST
62847: LIST
62848: LIST
62849: PPUSH
62850: CALL_OW 72
62854: AND
62855: PUSH
62856: LD_EXP 58
62860: PUSH
62861: LD_VAR 0 1
62865: ARRAY
62866: PPUSH
62867: LD_INT 30
62869: PUSH
62870: LD_INT 3
62872: PUSH
62873: EMPTY
62874: LIST
62875: LIST
62876: PPUSH
62877: CALL_OW 72
62881: NOT
62882: AND
62883: IFFALSE 63097
// begin if sci >= 6 then
62885: LD_VAR 0 8
62889: PUSH
62890: LD_INT 6
62892: GREATEREQUAL
62893: IFFALSE 62897
// exit ;
62895: GO 65316
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62897: LD_ADDR_EXP 100
62901: PUSH
62902: LD_EXP 100
62906: PPUSH
62907: LD_VAR 0 1
62911: PPUSH
62912: LD_INT 2
62914: PPUSH
62915: CALL_OW 1
62919: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62920: LD_ADDR_VAR 0 9
62924: PUSH
62925: LD_VAR 0 4
62929: PUSH
62930: LD_VAR 0 8
62934: DIFF
62935: PPUSH
62936: LD_INT 4
62938: PPUSH
62939: CALL 55399 0 2
62943: ST_TO_ADDR
// p := [ ] ;
62944: LD_ADDR_VAR 0 11
62948: PUSH
62949: EMPTY
62950: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62951: LD_VAR 0 8
62955: PUSH
62956: LD_INT 6
62958: LESS
62959: PUSH
62960: LD_VAR 0 9
62964: PUSH
62965: LD_INT 6
62967: GREATER
62968: AND
62969: IFFALSE 63050
// begin for i = 1 to 6 - sci do
62971: LD_ADDR_VAR 0 3
62975: PUSH
62976: DOUBLE
62977: LD_INT 1
62979: DEC
62980: ST_TO_ADDR
62981: LD_INT 6
62983: PUSH
62984: LD_VAR 0 8
62988: MINUS
62989: PUSH
62990: FOR_TO
62991: IFFALSE 63046
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62993: LD_ADDR_VAR 0 11
62997: PUSH
62998: LD_VAR 0 11
63002: PPUSH
63003: LD_VAR 0 11
63007: PUSH
63008: LD_INT 1
63010: PLUS
63011: PPUSH
63012: LD_VAR 0 9
63016: PUSH
63017: LD_INT 1
63019: ARRAY
63020: PPUSH
63021: CALL_OW 2
63025: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63026: LD_ADDR_VAR 0 9
63030: PUSH
63031: LD_VAR 0 9
63035: PPUSH
63036: LD_INT 1
63038: PPUSH
63039: CALL_OW 3
63043: ST_TO_ADDR
// end ;
63044: GO 62990
63046: POP
63047: POP
// end else
63048: GO 63070
// if sort then
63050: LD_VAR 0 9
63054: IFFALSE 63070
// p := sort [ 1 ] ;
63056: LD_ADDR_VAR 0 11
63060: PUSH
63061: LD_VAR 0 9
63065: PUSH
63066: LD_INT 1
63068: ARRAY
63069: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63070: LD_ADDR_VAR 0 2
63074: PUSH
63075: LD_INT 0
63077: PUSH
63078: LD_INT 0
63080: PUSH
63081: LD_INT 0
63083: PUSH
63084: LD_VAR 0 11
63088: PUSH
63089: EMPTY
63090: LIST
63091: LIST
63092: LIST
63093: LIST
63094: ST_TO_ADDR
// exit ;
63095: GO 65316
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63097: LD_EXP 85
63101: PUSH
63102: LD_EXP 84
63106: PUSH
63107: LD_VAR 0 1
63111: ARRAY
63112: ARRAY
63113: PUSH
63114: LD_EXP 58
63118: PUSH
63119: LD_VAR 0 1
63123: ARRAY
63124: PPUSH
63125: LD_INT 2
63127: PUSH
63128: LD_INT 30
63130: PUSH
63131: LD_INT 6
63133: PUSH
63134: EMPTY
63135: LIST
63136: LIST
63137: PUSH
63138: LD_INT 30
63140: PUSH
63141: LD_INT 7
63143: PUSH
63144: EMPTY
63145: LIST
63146: LIST
63147: PUSH
63148: LD_INT 30
63150: PUSH
63151: LD_INT 8
63153: PUSH
63154: EMPTY
63155: LIST
63156: LIST
63157: PUSH
63158: EMPTY
63159: LIST
63160: LIST
63161: LIST
63162: LIST
63163: PPUSH
63164: CALL_OW 72
63168: AND
63169: PUSH
63170: LD_EXP 58
63174: PUSH
63175: LD_VAR 0 1
63179: ARRAY
63180: PPUSH
63181: LD_INT 30
63183: PUSH
63184: LD_INT 3
63186: PUSH
63187: EMPTY
63188: LIST
63189: LIST
63190: PPUSH
63191: CALL_OW 72
63195: AND
63196: IFFALSE 63930
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63198: LD_ADDR_EXP 100
63202: PUSH
63203: LD_EXP 100
63207: PPUSH
63208: LD_VAR 0 1
63212: PPUSH
63213: LD_INT 3
63215: PPUSH
63216: CALL_OW 1
63220: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63221: LD_ADDR_VAR 0 2
63225: PUSH
63226: LD_INT 0
63228: PUSH
63229: LD_INT 0
63231: PUSH
63232: LD_INT 0
63234: PUSH
63235: LD_INT 0
63237: PUSH
63238: EMPTY
63239: LIST
63240: LIST
63241: LIST
63242: LIST
63243: ST_TO_ADDR
// if not eng then
63244: LD_VAR 0 6
63248: NOT
63249: IFFALSE 63312
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63251: LD_ADDR_VAR 0 11
63255: PUSH
63256: LD_VAR 0 4
63260: PPUSH
63261: LD_INT 2
63263: PPUSH
63264: CALL 55399 0 2
63268: PUSH
63269: LD_INT 1
63271: ARRAY
63272: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63273: LD_ADDR_VAR 0 2
63277: PUSH
63278: LD_VAR 0 2
63282: PPUSH
63283: LD_INT 2
63285: PPUSH
63286: LD_VAR 0 11
63290: PPUSH
63291: CALL_OW 1
63295: ST_TO_ADDR
// tmp := tmp diff p ;
63296: LD_ADDR_VAR 0 4
63300: PUSH
63301: LD_VAR 0 4
63305: PUSH
63306: LD_VAR 0 11
63310: DIFF
63311: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63312: LD_VAR 0 4
63316: PUSH
63317: LD_VAR 0 8
63321: PUSH
63322: LD_INT 6
63324: LESS
63325: AND
63326: IFFALSE 63514
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63328: LD_ADDR_VAR 0 9
63332: PUSH
63333: LD_VAR 0 4
63337: PUSH
63338: LD_VAR 0 8
63342: PUSH
63343: LD_VAR 0 7
63347: UNION
63348: DIFF
63349: PPUSH
63350: LD_INT 4
63352: PPUSH
63353: CALL 55399 0 2
63357: ST_TO_ADDR
// p := [ ] ;
63358: LD_ADDR_VAR 0 11
63362: PUSH
63363: EMPTY
63364: ST_TO_ADDR
// if sort then
63365: LD_VAR 0 9
63369: IFFALSE 63485
// for i = 1 to 6 - sci do
63371: LD_ADDR_VAR 0 3
63375: PUSH
63376: DOUBLE
63377: LD_INT 1
63379: DEC
63380: ST_TO_ADDR
63381: LD_INT 6
63383: PUSH
63384: LD_VAR 0 8
63388: MINUS
63389: PUSH
63390: FOR_TO
63391: IFFALSE 63483
// begin if i = sort then
63393: LD_VAR 0 3
63397: PUSH
63398: LD_VAR 0 9
63402: EQUAL
63403: IFFALSE 63407
// break ;
63405: GO 63483
// if GetClass ( i ) = 4 then
63407: LD_VAR 0 3
63411: PPUSH
63412: CALL_OW 257
63416: PUSH
63417: LD_INT 4
63419: EQUAL
63420: IFFALSE 63424
// continue ;
63422: GO 63390
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63424: LD_ADDR_VAR 0 11
63428: PUSH
63429: LD_VAR 0 11
63433: PPUSH
63434: LD_VAR 0 11
63438: PUSH
63439: LD_INT 1
63441: PLUS
63442: PPUSH
63443: LD_VAR 0 9
63447: PUSH
63448: LD_VAR 0 3
63452: ARRAY
63453: PPUSH
63454: CALL_OW 2
63458: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63459: LD_ADDR_VAR 0 4
63463: PUSH
63464: LD_VAR 0 4
63468: PUSH
63469: LD_VAR 0 9
63473: PUSH
63474: LD_VAR 0 3
63478: ARRAY
63479: DIFF
63480: ST_TO_ADDR
// end ;
63481: GO 63390
63483: POP
63484: POP
// if p then
63485: LD_VAR 0 11
63489: IFFALSE 63514
// result := Replace ( result , 4 , p ) ;
63491: LD_ADDR_VAR 0 2
63495: PUSH
63496: LD_VAR 0 2
63500: PPUSH
63501: LD_INT 4
63503: PPUSH
63504: LD_VAR 0 11
63508: PPUSH
63509: CALL_OW 1
63513: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63514: LD_VAR 0 4
63518: PUSH
63519: LD_VAR 0 7
63523: PUSH
63524: LD_INT 6
63526: LESS
63527: AND
63528: IFFALSE 63716
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63530: LD_ADDR_VAR 0 9
63534: PUSH
63535: LD_VAR 0 4
63539: PUSH
63540: LD_VAR 0 8
63544: PUSH
63545: LD_VAR 0 7
63549: UNION
63550: DIFF
63551: PPUSH
63552: LD_INT 3
63554: PPUSH
63555: CALL 55399 0 2
63559: ST_TO_ADDR
// p := [ ] ;
63560: LD_ADDR_VAR 0 11
63564: PUSH
63565: EMPTY
63566: ST_TO_ADDR
// if sort then
63567: LD_VAR 0 9
63571: IFFALSE 63687
// for i = 1 to 6 - mech do
63573: LD_ADDR_VAR 0 3
63577: PUSH
63578: DOUBLE
63579: LD_INT 1
63581: DEC
63582: ST_TO_ADDR
63583: LD_INT 6
63585: PUSH
63586: LD_VAR 0 7
63590: MINUS
63591: PUSH
63592: FOR_TO
63593: IFFALSE 63685
// begin if i = sort then
63595: LD_VAR 0 3
63599: PUSH
63600: LD_VAR 0 9
63604: EQUAL
63605: IFFALSE 63609
// break ;
63607: GO 63685
// if GetClass ( i ) = 3 then
63609: LD_VAR 0 3
63613: PPUSH
63614: CALL_OW 257
63618: PUSH
63619: LD_INT 3
63621: EQUAL
63622: IFFALSE 63626
// continue ;
63624: GO 63592
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63626: LD_ADDR_VAR 0 11
63630: PUSH
63631: LD_VAR 0 11
63635: PPUSH
63636: LD_VAR 0 11
63640: PUSH
63641: LD_INT 1
63643: PLUS
63644: PPUSH
63645: LD_VAR 0 9
63649: PUSH
63650: LD_VAR 0 3
63654: ARRAY
63655: PPUSH
63656: CALL_OW 2
63660: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63661: LD_ADDR_VAR 0 4
63665: PUSH
63666: LD_VAR 0 4
63670: PUSH
63671: LD_VAR 0 9
63675: PUSH
63676: LD_VAR 0 3
63680: ARRAY
63681: DIFF
63682: ST_TO_ADDR
// end ;
63683: GO 63592
63685: POP
63686: POP
// if p then
63687: LD_VAR 0 11
63691: IFFALSE 63716
// result := Replace ( result , 3 , p ) ;
63693: LD_ADDR_VAR 0 2
63697: PUSH
63698: LD_VAR 0 2
63702: PPUSH
63703: LD_INT 3
63705: PPUSH
63706: LD_VAR 0 11
63710: PPUSH
63711: CALL_OW 1
63715: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63716: LD_VAR 0 4
63720: PUSH
63721: LD_INT 6
63723: GREATER
63724: PUSH
63725: LD_VAR 0 6
63729: PUSH
63730: LD_INT 6
63732: LESS
63733: AND
63734: IFFALSE 63928
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63736: LD_ADDR_VAR 0 9
63740: PUSH
63741: LD_VAR 0 4
63745: PUSH
63746: LD_VAR 0 8
63750: PUSH
63751: LD_VAR 0 7
63755: UNION
63756: PUSH
63757: LD_VAR 0 6
63761: UNION
63762: DIFF
63763: PPUSH
63764: LD_INT 2
63766: PPUSH
63767: CALL 55399 0 2
63771: ST_TO_ADDR
// p := [ ] ;
63772: LD_ADDR_VAR 0 11
63776: PUSH
63777: EMPTY
63778: ST_TO_ADDR
// if sort then
63779: LD_VAR 0 9
63783: IFFALSE 63899
// for i = 1 to 6 - eng do
63785: LD_ADDR_VAR 0 3
63789: PUSH
63790: DOUBLE
63791: LD_INT 1
63793: DEC
63794: ST_TO_ADDR
63795: LD_INT 6
63797: PUSH
63798: LD_VAR 0 6
63802: MINUS
63803: PUSH
63804: FOR_TO
63805: IFFALSE 63897
// begin if i = sort then
63807: LD_VAR 0 3
63811: PUSH
63812: LD_VAR 0 9
63816: EQUAL
63817: IFFALSE 63821
// break ;
63819: GO 63897
// if GetClass ( i ) = 2 then
63821: LD_VAR 0 3
63825: PPUSH
63826: CALL_OW 257
63830: PUSH
63831: LD_INT 2
63833: EQUAL
63834: IFFALSE 63838
// continue ;
63836: GO 63804
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63838: LD_ADDR_VAR 0 11
63842: PUSH
63843: LD_VAR 0 11
63847: PPUSH
63848: LD_VAR 0 11
63852: PUSH
63853: LD_INT 1
63855: PLUS
63856: PPUSH
63857: LD_VAR 0 9
63861: PUSH
63862: LD_VAR 0 3
63866: ARRAY
63867: PPUSH
63868: CALL_OW 2
63872: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63873: LD_ADDR_VAR 0 4
63877: PUSH
63878: LD_VAR 0 4
63882: PUSH
63883: LD_VAR 0 9
63887: PUSH
63888: LD_VAR 0 3
63892: ARRAY
63893: DIFF
63894: ST_TO_ADDR
// end ;
63895: GO 63804
63897: POP
63898: POP
// if p then
63899: LD_VAR 0 11
63903: IFFALSE 63928
// result := Replace ( result , 2 , p ) ;
63905: LD_ADDR_VAR 0 2
63909: PUSH
63910: LD_VAR 0 2
63914: PPUSH
63915: LD_INT 2
63917: PPUSH
63918: LD_VAR 0 11
63922: PPUSH
63923: CALL_OW 1
63927: ST_TO_ADDR
// end ; exit ;
63928: GO 65316
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63930: LD_EXP 85
63934: PUSH
63935: LD_EXP 84
63939: PUSH
63940: LD_VAR 0 1
63944: ARRAY
63945: ARRAY
63946: NOT
63947: PUSH
63948: LD_EXP 58
63952: PUSH
63953: LD_VAR 0 1
63957: ARRAY
63958: PPUSH
63959: LD_INT 30
63961: PUSH
63962: LD_INT 3
63964: PUSH
63965: EMPTY
63966: LIST
63967: LIST
63968: PPUSH
63969: CALL_OW 72
63973: AND
63974: PUSH
63975: LD_EXP 63
63979: PUSH
63980: LD_VAR 0 1
63984: ARRAY
63985: AND
63986: IFFALSE 64594
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63988: LD_ADDR_EXP 100
63992: PUSH
63993: LD_EXP 100
63997: PPUSH
63998: LD_VAR 0 1
64002: PPUSH
64003: LD_INT 5
64005: PPUSH
64006: CALL_OW 1
64010: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64011: LD_ADDR_VAR 0 2
64015: PUSH
64016: LD_INT 0
64018: PUSH
64019: LD_INT 0
64021: PUSH
64022: LD_INT 0
64024: PUSH
64025: LD_INT 0
64027: PUSH
64028: EMPTY
64029: LIST
64030: LIST
64031: LIST
64032: LIST
64033: ST_TO_ADDR
// if sci > 1 then
64034: LD_VAR 0 8
64038: PUSH
64039: LD_INT 1
64041: GREATER
64042: IFFALSE 64070
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64044: LD_ADDR_VAR 0 4
64048: PUSH
64049: LD_VAR 0 4
64053: PUSH
64054: LD_VAR 0 8
64058: PUSH
64059: LD_VAR 0 8
64063: PUSH
64064: LD_INT 1
64066: ARRAY
64067: DIFF
64068: DIFF
64069: ST_TO_ADDR
// if tmp and not sci then
64070: LD_VAR 0 4
64074: PUSH
64075: LD_VAR 0 8
64079: NOT
64080: AND
64081: IFFALSE 64150
// begin sort := SortBySkill ( tmp , 4 ) ;
64083: LD_ADDR_VAR 0 9
64087: PUSH
64088: LD_VAR 0 4
64092: PPUSH
64093: LD_INT 4
64095: PPUSH
64096: CALL 55399 0 2
64100: ST_TO_ADDR
// if sort then
64101: LD_VAR 0 9
64105: IFFALSE 64121
// p := sort [ 1 ] ;
64107: LD_ADDR_VAR 0 11
64111: PUSH
64112: LD_VAR 0 9
64116: PUSH
64117: LD_INT 1
64119: ARRAY
64120: ST_TO_ADDR
// if p then
64121: LD_VAR 0 11
64125: IFFALSE 64150
// result := Replace ( result , 4 , p ) ;
64127: LD_ADDR_VAR 0 2
64131: PUSH
64132: LD_VAR 0 2
64136: PPUSH
64137: LD_INT 4
64139: PPUSH
64140: LD_VAR 0 11
64144: PPUSH
64145: CALL_OW 1
64149: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64150: LD_ADDR_VAR 0 4
64154: PUSH
64155: LD_VAR 0 4
64159: PUSH
64160: LD_VAR 0 7
64164: DIFF
64165: ST_TO_ADDR
// if tmp and mech < 6 then
64166: LD_VAR 0 4
64170: PUSH
64171: LD_VAR 0 7
64175: PUSH
64176: LD_INT 6
64178: LESS
64179: AND
64180: IFFALSE 64368
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64182: LD_ADDR_VAR 0 9
64186: PUSH
64187: LD_VAR 0 4
64191: PUSH
64192: LD_VAR 0 8
64196: PUSH
64197: LD_VAR 0 7
64201: UNION
64202: DIFF
64203: PPUSH
64204: LD_INT 3
64206: PPUSH
64207: CALL 55399 0 2
64211: ST_TO_ADDR
// p := [ ] ;
64212: LD_ADDR_VAR 0 11
64216: PUSH
64217: EMPTY
64218: ST_TO_ADDR
// if sort then
64219: LD_VAR 0 9
64223: IFFALSE 64339
// for i = 1 to 6 - mech do
64225: LD_ADDR_VAR 0 3
64229: PUSH
64230: DOUBLE
64231: LD_INT 1
64233: DEC
64234: ST_TO_ADDR
64235: LD_INT 6
64237: PUSH
64238: LD_VAR 0 7
64242: MINUS
64243: PUSH
64244: FOR_TO
64245: IFFALSE 64337
// begin if i = sort then
64247: LD_VAR 0 3
64251: PUSH
64252: LD_VAR 0 9
64256: EQUAL
64257: IFFALSE 64261
// break ;
64259: GO 64337
// if GetClass ( i ) = 3 then
64261: LD_VAR 0 3
64265: PPUSH
64266: CALL_OW 257
64270: PUSH
64271: LD_INT 3
64273: EQUAL
64274: IFFALSE 64278
// continue ;
64276: GO 64244
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64278: LD_ADDR_VAR 0 11
64282: PUSH
64283: LD_VAR 0 11
64287: PPUSH
64288: LD_VAR 0 11
64292: PUSH
64293: LD_INT 1
64295: PLUS
64296: PPUSH
64297: LD_VAR 0 9
64301: PUSH
64302: LD_VAR 0 3
64306: ARRAY
64307: PPUSH
64308: CALL_OW 2
64312: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64313: LD_ADDR_VAR 0 4
64317: PUSH
64318: LD_VAR 0 4
64322: PUSH
64323: LD_VAR 0 9
64327: PUSH
64328: LD_VAR 0 3
64332: ARRAY
64333: DIFF
64334: ST_TO_ADDR
// end ;
64335: GO 64244
64337: POP
64338: POP
// if p then
64339: LD_VAR 0 11
64343: IFFALSE 64368
// result := Replace ( result , 3 , p ) ;
64345: LD_ADDR_VAR 0 2
64349: PUSH
64350: LD_VAR 0 2
64354: PPUSH
64355: LD_INT 3
64357: PPUSH
64358: LD_VAR 0 11
64362: PPUSH
64363: CALL_OW 1
64367: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64368: LD_ADDR_VAR 0 4
64372: PUSH
64373: LD_VAR 0 4
64377: PUSH
64378: LD_VAR 0 6
64382: DIFF
64383: ST_TO_ADDR
// if tmp and eng < 6 then
64384: LD_VAR 0 4
64388: PUSH
64389: LD_VAR 0 6
64393: PUSH
64394: LD_INT 6
64396: LESS
64397: AND
64398: IFFALSE 64592
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64400: LD_ADDR_VAR 0 9
64404: PUSH
64405: LD_VAR 0 4
64409: PUSH
64410: LD_VAR 0 8
64414: PUSH
64415: LD_VAR 0 7
64419: UNION
64420: PUSH
64421: LD_VAR 0 6
64425: UNION
64426: DIFF
64427: PPUSH
64428: LD_INT 2
64430: PPUSH
64431: CALL 55399 0 2
64435: ST_TO_ADDR
// p := [ ] ;
64436: LD_ADDR_VAR 0 11
64440: PUSH
64441: EMPTY
64442: ST_TO_ADDR
// if sort then
64443: LD_VAR 0 9
64447: IFFALSE 64563
// for i = 1 to 6 - eng do
64449: LD_ADDR_VAR 0 3
64453: PUSH
64454: DOUBLE
64455: LD_INT 1
64457: DEC
64458: ST_TO_ADDR
64459: LD_INT 6
64461: PUSH
64462: LD_VAR 0 6
64466: MINUS
64467: PUSH
64468: FOR_TO
64469: IFFALSE 64561
// begin if i = sort then
64471: LD_VAR 0 3
64475: PUSH
64476: LD_VAR 0 9
64480: EQUAL
64481: IFFALSE 64485
// break ;
64483: GO 64561
// if GetClass ( i ) = 2 then
64485: LD_VAR 0 3
64489: PPUSH
64490: CALL_OW 257
64494: PUSH
64495: LD_INT 2
64497: EQUAL
64498: IFFALSE 64502
// continue ;
64500: GO 64468
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64502: LD_ADDR_VAR 0 11
64506: PUSH
64507: LD_VAR 0 11
64511: PPUSH
64512: LD_VAR 0 11
64516: PUSH
64517: LD_INT 1
64519: PLUS
64520: PPUSH
64521: LD_VAR 0 9
64525: PUSH
64526: LD_VAR 0 3
64530: ARRAY
64531: PPUSH
64532: CALL_OW 2
64536: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64537: LD_ADDR_VAR 0 4
64541: PUSH
64542: LD_VAR 0 4
64546: PUSH
64547: LD_VAR 0 9
64551: PUSH
64552: LD_VAR 0 3
64556: ARRAY
64557: DIFF
64558: ST_TO_ADDR
// end ;
64559: GO 64468
64561: POP
64562: POP
// if p then
64563: LD_VAR 0 11
64567: IFFALSE 64592
// result := Replace ( result , 2 , p ) ;
64569: LD_ADDR_VAR 0 2
64573: PUSH
64574: LD_VAR 0 2
64578: PPUSH
64579: LD_INT 2
64581: PPUSH
64582: LD_VAR 0 11
64586: PPUSH
64587: CALL_OW 1
64591: ST_TO_ADDR
// end ; exit ;
64592: GO 65316
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64594: LD_EXP 85
64598: PUSH
64599: LD_EXP 84
64603: PUSH
64604: LD_VAR 0 1
64608: ARRAY
64609: ARRAY
64610: NOT
64611: PUSH
64612: LD_EXP 58
64616: PUSH
64617: LD_VAR 0 1
64621: ARRAY
64622: PPUSH
64623: LD_INT 30
64625: PUSH
64626: LD_INT 3
64628: PUSH
64629: EMPTY
64630: LIST
64631: LIST
64632: PPUSH
64633: CALL_OW 72
64637: AND
64638: PUSH
64639: LD_EXP 63
64643: PUSH
64644: LD_VAR 0 1
64648: ARRAY
64649: NOT
64650: AND
64651: IFFALSE 65316
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64653: LD_ADDR_EXP 100
64657: PUSH
64658: LD_EXP 100
64662: PPUSH
64663: LD_VAR 0 1
64667: PPUSH
64668: LD_INT 6
64670: PPUSH
64671: CALL_OW 1
64675: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64676: LD_ADDR_VAR 0 2
64680: PUSH
64681: LD_INT 0
64683: PUSH
64684: LD_INT 0
64686: PUSH
64687: LD_INT 0
64689: PUSH
64690: LD_INT 0
64692: PUSH
64693: EMPTY
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: ST_TO_ADDR
// if sci >= 1 then
64699: LD_VAR 0 8
64703: PUSH
64704: LD_INT 1
64706: GREATEREQUAL
64707: IFFALSE 64729
// tmp := tmp diff sci [ 1 ] ;
64709: LD_ADDR_VAR 0 4
64713: PUSH
64714: LD_VAR 0 4
64718: PUSH
64719: LD_VAR 0 8
64723: PUSH
64724: LD_INT 1
64726: ARRAY
64727: DIFF
64728: ST_TO_ADDR
// if tmp and not sci then
64729: LD_VAR 0 4
64733: PUSH
64734: LD_VAR 0 8
64738: NOT
64739: AND
64740: IFFALSE 64809
// begin sort := SortBySkill ( tmp , 4 ) ;
64742: LD_ADDR_VAR 0 9
64746: PUSH
64747: LD_VAR 0 4
64751: PPUSH
64752: LD_INT 4
64754: PPUSH
64755: CALL 55399 0 2
64759: ST_TO_ADDR
// if sort then
64760: LD_VAR 0 9
64764: IFFALSE 64780
// p := sort [ 1 ] ;
64766: LD_ADDR_VAR 0 11
64770: PUSH
64771: LD_VAR 0 9
64775: PUSH
64776: LD_INT 1
64778: ARRAY
64779: ST_TO_ADDR
// if p then
64780: LD_VAR 0 11
64784: IFFALSE 64809
// result := Replace ( result , 4 , p ) ;
64786: LD_ADDR_VAR 0 2
64790: PUSH
64791: LD_VAR 0 2
64795: PPUSH
64796: LD_INT 4
64798: PPUSH
64799: LD_VAR 0 11
64803: PPUSH
64804: CALL_OW 1
64808: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64809: LD_ADDR_VAR 0 4
64813: PUSH
64814: LD_VAR 0 4
64818: PUSH
64819: LD_VAR 0 7
64823: DIFF
64824: ST_TO_ADDR
// if tmp and mech < 6 then
64825: LD_VAR 0 4
64829: PUSH
64830: LD_VAR 0 7
64834: PUSH
64835: LD_INT 6
64837: LESS
64838: AND
64839: IFFALSE 65021
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64841: LD_ADDR_VAR 0 9
64845: PUSH
64846: LD_VAR 0 4
64850: PUSH
64851: LD_VAR 0 7
64855: DIFF
64856: PPUSH
64857: LD_INT 3
64859: PPUSH
64860: CALL 55399 0 2
64864: ST_TO_ADDR
// p := [ ] ;
64865: LD_ADDR_VAR 0 11
64869: PUSH
64870: EMPTY
64871: ST_TO_ADDR
// if sort then
64872: LD_VAR 0 9
64876: IFFALSE 64992
// for i = 1 to 6 - mech do
64878: LD_ADDR_VAR 0 3
64882: PUSH
64883: DOUBLE
64884: LD_INT 1
64886: DEC
64887: ST_TO_ADDR
64888: LD_INT 6
64890: PUSH
64891: LD_VAR 0 7
64895: MINUS
64896: PUSH
64897: FOR_TO
64898: IFFALSE 64990
// begin if i = sort then
64900: LD_VAR 0 3
64904: PUSH
64905: LD_VAR 0 9
64909: EQUAL
64910: IFFALSE 64914
// break ;
64912: GO 64990
// if GetClass ( i ) = 3 then
64914: LD_VAR 0 3
64918: PPUSH
64919: CALL_OW 257
64923: PUSH
64924: LD_INT 3
64926: EQUAL
64927: IFFALSE 64931
// continue ;
64929: GO 64897
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64931: LD_ADDR_VAR 0 11
64935: PUSH
64936: LD_VAR 0 11
64940: PPUSH
64941: LD_VAR 0 11
64945: PUSH
64946: LD_INT 1
64948: PLUS
64949: PPUSH
64950: LD_VAR 0 9
64954: PUSH
64955: LD_VAR 0 3
64959: ARRAY
64960: PPUSH
64961: CALL_OW 2
64965: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64966: LD_ADDR_VAR 0 4
64970: PUSH
64971: LD_VAR 0 4
64975: PUSH
64976: LD_VAR 0 9
64980: PUSH
64981: LD_VAR 0 3
64985: ARRAY
64986: DIFF
64987: ST_TO_ADDR
// end ;
64988: GO 64897
64990: POP
64991: POP
// if p then
64992: LD_VAR 0 11
64996: IFFALSE 65021
// result := Replace ( result , 3 , p ) ;
64998: LD_ADDR_VAR 0 2
65002: PUSH
65003: LD_VAR 0 2
65007: PPUSH
65008: LD_INT 3
65010: PPUSH
65011: LD_VAR 0 11
65015: PPUSH
65016: CALL_OW 1
65020: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65021: LD_ADDR_VAR 0 4
65025: PUSH
65026: LD_VAR 0 4
65030: PUSH
65031: LD_VAR 0 6
65035: DIFF
65036: ST_TO_ADDR
// if tmp and eng < 4 then
65037: LD_VAR 0 4
65041: PUSH
65042: LD_VAR 0 6
65046: PUSH
65047: LD_INT 4
65049: LESS
65050: AND
65051: IFFALSE 65241
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65053: LD_ADDR_VAR 0 9
65057: PUSH
65058: LD_VAR 0 4
65062: PUSH
65063: LD_VAR 0 7
65067: PUSH
65068: LD_VAR 0 6
65072: UNION
65073: DIFF
65074: PPUSH
65075: LD_INT 2
65077: PPUSH
65078: CALL 55399 0 2
65082: ST_TO_ADDR
// p := [ ] ;
65083: LD_ADDR_VAR 0 11
65087: PUSH
65088: EMPTY
65089: ST_TO_ADDR
// if sort then
65090: LD_VAR 0 9
65094: IFFALSE 65210
// for i = 1 to 4 - eng do
65096: LD_ADDR_VAR 0 3
65100: PUSH
65101: DOUBLE
65102: LD_INT 1
65104: DEC
65105: ST_TO_ADDR
65106: LD_INT 4
65108: PUSH
65109: LD_VAR 0 6
65113: MINUS
65114: PUSH
65115: FOR_TO
65116: IFFALSE 65208
// begin if i = sort then
65118: LD_VAR 0 3
65122: PUSH
65123: LD_VAR 0 9
65127: EQUAL
65128: IFFALSE 65132
// break ;
65130: GO 65208
// if GetClass ( i ) = 2 then
65132: LD_VAR 0 3
65136: PPUSH
65137: CALL_OW 257
65141: PUSH
65142: LD_INT 2
65144: EQUAL
65145: IFFALSE 65149
// continue ;
65147: GO 65115
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65149: LD_ADDR_VAR 0 11
65153: PUSH
65154: LD_VAR 0 11
65158: PPUSH
65159: LD_VAR 0 11
65163: PUSH
65164: LD_INT 1
65166: PLUS
65167: PPUSH
65168: LD_VAR 0 9
65172: PUSH
65173: LD_VAR 0 3
65177: ARRAY
65178: PPUSH
65179: CALL_OW 2
65183: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65184: LD_ADDR_VAR 0 4
65188: PUSH
65189: LD_VAR 0 4
65193: PUSH
65194: LD_VAR 0 9
65198: PUSH
65199: LD_VAR 0 3
65203: ARRAY
65204: DIFF
65205: ST_TO_ADDR
// end ;
65206: GO 65115
65208: POP
65209: POP
// if p then
65210: LD_VAR 0 11
65214: IFFALSE 65239
// result := Replace ( result , 2 , p ) ;
65216: LD_ADDR_VAR 0 2
65220: PUSH
65221: LD_VAR 0 2
65225: PPUSH
65226: LD_INT 2
65228: PPUSH
65229: LD_VAR 0 11
65233: PPUSH
65234: CALL_OW 1
65238: ST_TO_ADDR
// end else
65239: GO 65285
// for i = eng downto 5 do
65241: LD_ADDR_VAR 0 3
65245: PUSH
65246: DOUBLE
65247: LD_VAR 0 6
65251: INC
65252: ST_TO_ADDR
65253: LD_INT 5
65255: PUSH
65256: FOR_DOWNTO
65257: IFFALSE 65283
// tmp := tmp union eng [ i ] ;
65259: LD_ADDR_VAR 0 4
65263: PUSH
65264: LD_VAR 0 4
65268: PUSH
65269: LD_VAR 0 6
65273: PUSH
65274: LD_VAR 0 3
65278: ARRAY
65279: UNION
65280: ST_TO_ADDR
65281: GO 65256
65283: POP
65284: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65285: LD_ADDR_VAR 0 2
65289: PUSH
65290: LD_VAR 0 2
65294: PPUSH
65295: LD_INT 1
65297: PPUSH
65298: LD_VAR 0 4
65302: PUSH
65303: LD_VAR 0 5
65307: DIFF
65308: PPUSH
65309: CALL_OW 1
65313: ST_TO_ADDR
// exit ;
65314: GO 65316
// end ; end ;
65316: LD_VAR 0 2
65320: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65321: LD_INT 0
65323: PPUSH
65324: PPUSH
65325: PPUSH
// if not mc_bases then
65326: LD_EXP 58
65330: NOT
65331: IFFALSE 65335
// exit ;
65333: GO 65441
// for i = 1 to mc_bases do
65335: LD_ADDR_VAR 0 2
65339: PUSH
65340: DOUBLE
65341: LD_INT 1
65343: DEC
65344: ST_TO_ADDR
65345: LD_EXP 58
65349: PUSH
65350: FOR_TO
65351: IFFALSE 65432
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65353: LD_ADDR_VAR 0 3
65357: PUSH
65358: LD_EXP 58
65362: PUSH
65363: LD_VAR 0 2
65367: ARRAY
65368: PPUSH
65369: LD_INT 21
65371: PUSH
65372: LD_INT 3
65374: PUSH
65375: EMPTY
65376: LIST
65377: LIST
65378: PUSH
65379: LD_INT 3
65381: PUSH
65382: LD_INT 24
65384: PUSH
65385: LD_INT 1000
65387: PUSH
65388: EMPTY
65389: LIST
65390: LIST
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: PUSH
65396: EMPTY
65397: LIST
65398: LIST
65399: PPUSH
65400: CALL_OW 72
65404: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65405: LD_ADDR_EXP 59
65409: PUSH
65410: LD_EXP 59
65414: PPUSH
65415: LD_VAR 0 2
65419: PPUSH
65420: LD_VAR 0 3
65424: PPUSH
65425: CALL_OW 1
65429: ST_TO_ADDR
// end ;
65430: GO 65350
65432: POP
65433: POP
// RaiseSailEvent ( 101 ) ;
65434: LD_INT 101
65436: PPUSH
65437: CALL_OW 427
// end ;
65441: LD_VAR 0 1
65445: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65446: LD_INT 0
65448: PPUSH
65449: PPUSH
65450: PPUSH
65451: PPUSH
65452: PPUSH
65453: PPUSH
65454: PPUSH
// if not mc_bases then
65455: LD_EXP 58
65459: NOT
65460: IFFALSE 65464
// exit ;
65462: GO 66037
// for i = 1 to mc_bases do
65464: LD_ADDR_VAR 0 2
65468: PUSH
65469: DOUBLE
65470: LD_INT 1
65472: DEC
65473: ST_TO_ADDR
65474: LD_EXP 58
65478: PUSH
65479: FOR_TO
65480: IFFALSE 66028
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65482: LD_ADDR_VAR 0 5
65486: PUSH
65487: LD_EXP 58
65491: PUSH
65492: LD_VAR 0 2
65496: ARRAY
65497: PUSH
65498: LD_EXP 87
65502: PUSH
65503: LD_VAR 0 2
65507: ARRAY
65508: UNION
65509: PPUSH
65510: LD_INT 21
65512: PUSH
65513: LD_INT 1
65515: PUSH
65516: EMPTY
65517: LIST
65518: LIST
65519: PUSH
65520: LD_INT 1
65522: PUSH
65523: LD_INT 3
65525: PUSH
65526: LD_INT 54
65528: PUSH
65529: EMPTY
65530: LIST
65531: PUSH
65532: EMPTY
65533: LIST
65534: LIST
65535: PUSH
65536: LD_INT 3
65538: PUSH
65539: LD_INT 24
65541: PUSH
65542: LD_INT 800
65544: PUSH
65545: EMPTY
65546: LIST
65547: LIST
65548: PUSH
65549: EMPTY
65550: LIST
65551: LIST
65552: PUSH
65553: EMPTY
65554: LIST
65555: LIST
65556: LIST
65557: PUSH
65558: EMPTY
65559: LIST
65560: LIST
65561: PPUSH
65562: CALL_OW 72
65566: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65567: LD_ADDR_VAR 0 6
65571: PUSH
65572: LD_EXP 58
65576: PUSH
65577: LD_VAR 0 2
65581: ARRAY
65582: PPUSH
65583: LD_INT 21
65585: PUSH
65586: LD_INT 1
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 1
65595: PUSH
65596: LD_INT 3
65598: PUSH
65599: LD_INT 54
65601: PUSH
65602: EMPTY
65603: LIST
65604: PUSH
65605: EMPTY
65606: LIST
65607: LIST
65608: PUSH
65609: LD_INT 3
65611: PUSH
65612: LD_INT 24
65614: PUSH
65615: LD_INT 250
65617: PUSH
65618: EMPTY
65619: LIST
65620: LIST
65621: PUSH
65622: EMPTY
65623: LIST
65624: LIST
65625: PUSH
65626: EMPTY
65627: LIST
65628: LIST
65629: LIST
65630: PUSH
65631: EMPTY
65632: LIST
65633: LIST
65634: PPUSH
65635: CALL_OW 72
65639: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65640: LD_ADDR_VAR 0 7
65644: PUSH
65645: LD_VAR 0 5
65649: PUSH
65650: LD_VAR 0 6
65654: DIFF
65655: ST_TO_ADDR
// if not need_heal_1 then
65656: LD_VAR 0 6
65660: NOT
65661: IFFALSE 65694
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65663: LD_ADDR_EXP 61
65667: PUSH
65668: LD_EXP 61
65672: PPUSH
65673: LD_VAR 0 2
65677: PUSH
65678: LD_INT 1
65680: PUSH
65681: EMPTY
65682: LIST
65683: LIST
65684: PPUSH
65685: EMPTY
65686: PPUSH
65687: CALL 21151 0 3
65691: ST_TO_ADDR
65692: GO 65764
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65694: LD_ADDR_EXP 61
65698: PUSH
65699: LD_EXP 61
65703: PPUSH
65704: LD_VAR 0 2
65708: PUSH
65709: LD_INT 1
65711: PUSH
65712: EMPTY
65713: LIST
65714: LIST
65715: PPUSH
65716: LD_EXP 61
65720: PUSH
65721: LD_VAR 0 2
65725: ARRAY
65726: PUSH
65727: LD_INT 1
65729: ARRAY
65730: PPUSH
65731: LD_INT 3
65733: PUSH
65734: LD_INT 24
65736: PUSH
65737: LD_INT 1000
65739: PUSH
65740: EMPTY
65741: LIST
65742: LIST
65743: PUSH
65744: EMPTY
65745: LIST
65746: LIST
65747: PPUSH
65748: CALL_OW 72
65752: PUSH
65753: LD_VAR 0 6
65757: UNION
65758: PPUSH
65759: CALL 21151 0 3
65763: ST_TO_ADDR
// if not need_heal_2 then
65764: LD_VAR 0 7
65768: NOT
65769: IFFALSE 65802
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65771: LD_ADDR_EXP 61
65775: PUSH
65776: LD_EXP 61
65780: PPUSH
65781: LD_VAR 0 2
65785: PUSH
65786: LD_INT 2
65788: PUSH
65789: EMPTY
65790: LIST
65791: LIST
65792: PPUSH
65793: EMPTY
65794: PPUSH
65795: CALL 21151 0 3
65799: ST_TO_ADDR
65800: GO 65834
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65802: LD_ADDR_EXP 61
65806: PUSH
65807: LD_EXP 61
65811: PPUSH
65812: LD_VAR 0 2
65816: PUSH
65817: LD_INT 2
65819: PUSH
65820: EMPTY
65821: LIST
65822: LIST
65823: PPUSH
65824: LD_VAR 0 7
65828: PPUSH
65829: CALL 21151 0 3
65833: ST_TO_ADDR
// if need_heal_2 then
65834: LD_VAR 0 7
65838: IFFALSE 66010
// for j in need_heal_2 do
65840: LD_ADDR_VAR 0 3
65844: PUSH
65845: LD_VAR 0 7
65849: PUSH
65850: FOR_IN
65851: IFFALSE 66008
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
65853: LD_ADDR_VAR 0 5
65857: PUSH
65858: LD_EXP 58
65862: PUSH
65863: LD_VAR 0 2
65867: ARRAY
65868: PPUSH
65869: LD_INT 2
65871: PUSH
65872: LD_INT 30
65874: PUSH
65875: LD_INT 6
65877: PUSH
65878: EMPTY
65879: LIST
65880: LIST
65881: PUSH
65882: LD_INT 30
65884: PUSH
65885: LD_INT 7
65887: PUSH
65888: EMPTY
65889: LIST
65890: LIST
65891: PUSH
65892: LD_INT 30
65894: PUSH
65895: LD_INT 8
65897: PUSH
65898: EMPTY
65899: LIST
65900: LIST
65901: PUSH
65902: LD_INT 30
65904: PUSH
65905: LD_INT 0
65907: PUSH
65908: EMPTY
65909: LIST
65910: LIST
65911: PUSH
65912: LD_INT 30
65914: PUSH
65915: LD_INT 1
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: PUSH
65922: LD_INT 25
65924: PUSH
65925: LD_INT 4
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: EMPTY
65933: LIST
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: LIST
65940: PPUSH
65941: CALL_OW 72
65945: ST_TO_ADDR
// if tmp then
65946: LD_VAR 0 5
65950: IFFALSE 66006
// begin k := NearestUnitToUnit ( tmp , j ) ;
65952: LD_ADDR_VAR 0 4
65956: PUSH
65957: LD_VAR 0 5
65961: PPUSH
65962: LD_VAR 0 3
65966: PPUSH
65967: CALL_OW 74
65971: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
65972: LD_VAR 0 3
65976: PPUSH
65977: LD_VAR 0 4
65981: PPUSH
65982: CALL_OW 296
65986: PUSH
65987: LD_INT 7
65989: GREATER
65990: IFFALSE 66006
// ComMoveUnit ( j , k ) ;
65992: LD_VAR 0 3
65996: PPUSH
65997: LD_VAR 0 4
66001: PPUSH
66002: CALL_OW 112
// end ; end ;
66006: GO 65850
66008: POP
66009: POP
// if not need_heal_1 and not need_heal_2 then
66010: LD_VAR 0 6
66014: NOT
66015: PUSH
66016: LD_VAR 0 7
66020: NOT
66021: AND
66022: IFFALSE 66026
// continue ;
66024: GO 65479
// end ;
66026: GO 65479
66028: POP
66029: POP
// RaiseSailEvent ( 102 ) ;
66030: LD_INT 102
66032: PPUSH
66033: CALL_OW 427
// end ;
66037: LD_VAR 0 1
66041: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
66042: LD_INT 0
66044: PPUSH
66045: PPUSH
66046: PPUSH
66047: PPUSH
66048: PPUSH
66049: PPUSH
// if not mc_bases then
66050: LD_EXP 58
66054: NOT
66055: IFFALSE 66059
// exit ;
66057: GO 66769
// for i = 1 to mc_bases do
66059: LD_ADDR_VAR 0 2
66063: PUSH
66064: DOUBLE
66065: LD_INT 1
66067: DEC
66068: ST_TO_ADDR
66069: LD_EXP 58
66073: PUSH
66074: FOR_TO
66075: IFFALSE 66767
// begin if not mc_building_need_repair [ i ] then
66077: LD_EXP 59
66081: PUSH
66082: LD_VAR 0 2
66086: ARRAY
66087: NOT
66088: IFFALSE 66262
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
66090: LD_ADDR_VAR 0 6
66094: PUSH
66095: LD_EXP 77
66099: PUSH
66100: LD_VAR 0 2
66104: ARRAY
66105: PPUSH
66106: LD_INT 3
66108: PUSH
66109: LD_INT 24
66111: PUSH
66112: LD_INT 1000
66114: PUSH
66115: EMPTY
66116: LIST
66117: LIST
66118: PUSH
66119: EMPTY
66120: LIST
66121: LIST
66122: PUSH
66123: LD_INT 2
66125: PUSH
66126: LD_INT 34
66128: PUSH
66129: LD_INT 13
66131: PUSH
66132: EMPTY
66133: LIST
66134: LIST
66135: PUSH
66136: LD_INT 34
66138: PUSH
66139: LD_INT 52
66141: PUSH
66142: EMPTY
66143: LIST
66144: LIST
66145: PUSH
66146: EMPTY
66147: LIST
66148: LIST
66149: LIST
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: PPUSH
66155: CALL_OW 72
66159: ST_TO_ADDR
// if cranes then
66160: LD_VAR 0 6
66164: IFFALSE 66226
// for j in cranes do
66166: LD_ADDR_VAR 0 3
66170: PUSH
66171: LD_VAR 0 6
66175: PUSH
66176: FOR_IN
66177: IFFALSE 66224
// if not IsInArea ( j , mc_parking [ i ] ) then
66179: LD_VAR 0 3
66183: PPUSH
66184: LD_EXP 82
66188: PUSH
66189: LD_VAR 0 2
66193: ARRAY
66194: PPUSH
66195: CALL_OW 308
66199: NOT
66200: IFFALSE 66222
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66202: LD_VAR 0 3
66206: PPUSH
66207: LD_EXP 82
66211: PUSH
66212: LD_VAR 0 2
66216: ARRAY
66217: PPUSH
66218: CALL_OW 113
66222: GO 66176
66224: POP
66225: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66226: LD_ADDR_EXP 60
66230: PUSH
66231: LD_EXP 60
66235: PPUSH
66236: LD_VAR 0 2
66240: PPUSH
66241: EMPTY
66242: PPUSH
66243: CALL_OW 1
66247: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66248: LD_VAR 0 2
66252: PPUSH
66253: LD_INT 101
66255: PPUSH
66256: CALL 61154 0 2
// continue ;
66260: GO 66074
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66262: LD_ADDR_EXP 64
66266: PUSH
66267: LD_EXP 64
66271: PPUSH
66272: LD_VAR 0 2
66276: PPUSH
66277: EMPTY
66278: PPUSH
66279: CALL_OW 1
66283: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66284: LD_VAR 0 2
66288: PPUSH
66289: LD_INT 103
66291: PPUSH
66292: CALL 61154 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66296: LD_ADDR_VAR 0 5
66300: PUSH
66301: LD_EXP 58
66305: PUSH
66306: LD_VAR 0 2
66310: ARRAY
66311: PUSH
66312: LD_EXP 87
66316: PUSH
66317: LD_VAR 0 2
66321: ARRAY
66322: UNION
66323: PPUSH
66324: LD_INT 2
66326: PUSH
66327: LD_INT 25
66329: PUSH
66330: LD_INT 2
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 25
66339: PUSH
66340: LD_INT 16
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: LIST
66351: PUSH
66352: EMPTY
66353: LIST
66354: PPUSH
66355: CALL_OW 72
66359: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66360: LD_ADDR_VAR 0 6
66364: PUSH
66365: LD_EXP 77
66369: PUSH
66370: LD_VAR 0 2
66374: ARRAY
66375: PPUSH
66376: LD_INT 2
66378: PUSH
66379: LD_INT 34
66381: PUSH
66382: LD_INT 13
66384: PUSH
66385: EMPTY
66386: LIST
66387: LIST
66388: PUSH
66389: LD_INT 34
66391: PUSH
66392: LD_INT 52
66394: PUSH
66395: EMPTY
66396: LIST
66397: LIST
66398: PUSH
66399: EMPTY
66400: LIST
66401: LIST
66402: LIST
66403: PPUSH
66404: CALL_OW 72
66408: ST_TO_ADDR
// if cranes then
66409: LD_VAR 0 6
66413: IFFALSE 66549
// begin for j in cranes do
66415: LD_ADDR_VAR 0 3
66419: PUSH
66420: LD_VAR 0 6
66424: PUSH
66425: FOR_IN
66426: IFFALSE 66547
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66428: LD_VAR 0 3
66432: PPUSH
66433: CALL_OW 256
66437: PUSH
66438: LD_INT 500
66440: GREATEREQUAL
66441: PUSH
66442: LD_VAR 0 3
66446: PPUSH
66447: CALL_OW 314
66451: NOT
66452: AND
66453: IFFALSE 66487
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66455: LD_VAR 0 3
66459: PPUSH
66460: LD_EXP 59
66464: PUSH
66465: LD_VAR 0 2
66469: ARRAY
66470: PPUSH
66471: LD_VAR 0 3
66475: PPUSH
66476: CALL_OW 74
66480: PPUSH
66481: CALL_OW 130
66485: GO 66545
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66487: LD_VAR 0 3
66491: PPUSH
66492: CALL_OW 256
66496: PUSH
66497: LD_INT 500
66499: LESS
66500: PUSH
66501: LD_VAR 0 3
66505: PPUSH
66506: LD_EXP 82
66510: PUSH
66511: LD_VAR 0 2
66515: ARRAY
66516: PPUSH
66517: CALL_OW 308
66521: NOT
66522: AND
66523: IFFALSE 66545
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66525: LD_VAR 0 3
66529: PPUSH
66530: LD_EXP 82
66534: PUSH
66535: LD_VAR 0 2
66539: ARRAY
66540: PPUSH
66541: CALL_OW 113
66545: GO 66425
66547: POP
66548: POP
// end ; if not tmp then
66549: LD_VAR 0 5
66553: NOT
66554: IFFALSE 66558
// continue ;
66556: GO 66074
// for j in tmp do
66558: LD_ADDR_VAR 0 3
66562: PUSH
66563: LD_VAR 0 5
66567: PUSH
66568: FOR_IN
66569: IFFALSE 66763
// begin if mc_need_heal [ i ] then
66571: LD_EXP 61
66575: PUSH
66576: LD_VAR 0 2
66580: ARRAY
66581: IFFALSE 66629
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
66583: LD_VAR 0 3
66587: PUSH
66588: LD_EXP 61
66592: PUSH
66593: LD_VAR 0 2
66597: ARRAY
66598: PUSH
66599: LD_INT 1
66601: ARRAY
66602: IN
66603: PUSH
66604: LD_VAR 0 3
66608: PUSH
66609: LD_EXP 61
66613: PUSH
66614: LD_VAR 0 2
66618: ARRAY
66619: PUSH
66620: LD_INT 2
66622: ARRAY
66623: IN
66624: OR
66625: IFFALSE 66629
// continue ;
66627: GO 66568
// if IsInUnit ( j ) then
66629: LD_VAR 0 3
66633: PPUSH
66634: CALL_OW 310
66638: IFFALSE 66649
// ComExitBuilding ( j ) ;
66640: LD_VAR 0 3
66644: PPUSH
66645: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66649: LD_VAR 0 3
66653: PUSH
66654: LD_EXP 60
66658: PUSH
66659: LD_VAR 0 2
66663: ARRAY
66664: IN
66665: NOT
66666: IFFALSE 66724
// begin SetTag ( j , 101 ) ;
66668: LD_VAR 0 3
66672: PPUSH
66673: LD_INT 101
66675: PPUSH
66676: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66680: LD_ADDR_EXP 60
66684: PUSH
66685: LD_EXP 60
66689: PPUSH
66690: LD_VAR 0 2
66694: PUSH
66695: LD_EXP 60
66699: PUSH
66700: LD_VAR 0 2
66704: ARRAY
66705: PUSH
66706: LD_INT 1
66708: PLUS
66709: PUSH
66710: EMPTY
66711: LIST
66712: LIST
66713: PPUSH
66714: LD_VAR 0 3
66718: PPUSH
66719: CALL 21151 0 3
66723: ST_TO_ADDR
// end ; wait ( 1 ) ;
66724: LD_INT 1
66726: PPUSH
66727: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
66731: LD_VAR 0 3
66735: PPUSH
66736: LD_EXP 59
66740: PUSH
66741: LD_VAR 0 2
66745: ARRAY
66746: PPUSH
66747: LD_VAR 0 3
66751: PPUSH
66752: CALL_OW 74
66756: PPUSH
66757: CALL_OW 130
// end ;
66761: GO 66568
66763: POP
66764: POP
// end ;
66765: GO 66074
66767: POP
66768: POP
// end ;
66769: LD_VAR 0 1
66773: RET
// export function MC_Heal ; var i , j , tmp ; begin
66774: LD_INT 0
66776: PPUSH
66777: PPUSH
66778: PPUSH
66779: PPUSH
// if not mc_bases then
66780: LD_EXP 58
66784: NOT
66785: IFFALSE 66789
// exit ;
66787: GO 67191
// for i = 1 to mc_bases do
66789: LD_ADDR_VAR 0 2
66793: PUSH
66794: DOUBLE
66795: LD_INT 1
66797: DEC
66798: ST_TO_ADDR
66799: LD_EXP 58
66803: PUSH
66804: FOR_TO
66805: IFFALSE 67189
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66807: LD_EXP 61
66811: PUSH
66812: LD_VAR 0 2
66816: ARRAY
66817: PUSH
66818: LD_INT 1
66820: ARRAY
66821: NOT
66822: PUSH
66823: LD_EXP 61
66827: PUSH
66828: LD_VAR 0 2
66832: ARRAY
66833: PUSH
66834: LD_INT 2
66836: ARRAY
66837: NOT
66838: AND
66839: IFFALSE 66877
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66841: LD_ADDR_EXP 62
66845: PUSH
66846: LD_EXP 62
66850: PPUSH
66851: LD_VAR 0 2
66855: PPUSH
66856: EMPTY
66857: PPUSH
66858: CALL_OW 1
66862: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66863: LD_VAR 0 2
66867: PPUSH
66868: LD_INT 102
66870: PPUSH
66871: CALL 61154 0 2
// continue ;
66875: GO 66804
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
66877: LD_ADDR_VAR 0 4
66881: PUSH
66882: LD_EXP 58
66886: PUSH
66887: LD_VAR 0 2
66891: ARRAY
66892: PPUSH
66893: LD_INT 25
66895: PUSH
66896: LD_INT 4
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PPUSH
66903: CALL_OW 72
66907: ST_TO_ADDR
// if not tmp then
66908: LD_VAR 0 4
66912: NOT
66913: IFFALSE 66917
// continue ;
66915: GO 66804
// if mc_taming [ i ] then
66917: LD_EXP 89
66921: PUSH
66922: LD_VAR 0 2
66926: ARRAY
66927: IFFALSE 66951
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66929: LD_ADDR_EXP 89
66933: PUSH
66934: LD_EXP 89
66938: PPUSH
66939: LD_VAR 0 2
66943: PPUSH
66944: EMPTY
66945: PPUSH
66946: CALL_OW 1
66950: ST_TO_ADDR
// for j in tmp do
66951: LD_ADDR_VAR 0 3
66955: PUSH
66956: LD_VAR 0 4
66960: PUSH
66961: FOR_IN
66962: IFFALSE 67185
// begin if IsInUnit ( j ) then
66964: LD_VAR 0 3
66968: PPUSH
66969: CALL_OW 310
66973: IFFALSE 66984
// ComExitBuilding ( j ) ;
66975: LD_VAR 0 3
66979: PPUSH
66980: CALL_OW 122
// if not j in mc_healers [ i ] then
66984: LD_VAR 0 3
66988: PUSH
66989: LD_EXP 62
66993: PUSH
66994: LD_VAR 0 2
66998: ARRAY
66999: IN
67000: NOT
67001: IFFALSE 67047
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67003: LD_ADDR_EXP 62
67007: PUSH
67008: LD_EXP 62
67012: PPUSH
67013: LD_VAR 0 2
67017: PUSH
67018: LD_EXP 62
67022: PUSH
67023: LD_VAR 0 2
67027: ARRAY
67028: PUSH
67029: LD_INT 1
67031: PLUS
67032: PUSH
67033: EMPTY
67034: LIST
67035: LIST
67036: PPUSH
67037: LD_VAR 0 3
67041: PPUSH
67042: CALL 21151 0 3
67046: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67047: LD_VAR 0 3
67051: PPUSH
67052: CALL_OW 110
67056: PUSH
67057: LD_INT 102
67059: NONEQUAL
67060: IFFALSE 67074
// SetTag ( j , 102 ) ;
67062: LD_VAR 0 3
67066: PPUSH
67067: LD_INT 102
67069: PPUSH
67070: CALL_OW 109
// Wait ( 3 ) ;
67074: LD_INT 3
67076: PPUSH
67077: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67081: LD_EXP 61
67085: PUSH
67086: LD_VAR 0 2
67090: ARRAY
67091: PUSH
67092: LD_INT 1
67094: ARRAY
67095: IFFALSE 67127
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67097: LD_VAR 0 3
67101: PPUSH
67102: LD_EXP 61
67106: PUSH
67107: LD_VAR 0 2
67111: ARRAY
67112: PUSH
67113: LD_INT 1
67115: ARRAY
67116: PUSH
67117: LD_INT 1
67119: ARRAY
67120: PPUSH
67121: CALL_OW 128
67125: GO 67183
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67127: LD_VAR 0 3
67131: PPUSH
67132: CALL_OW 314
67136: NOT
67137: PUSH
67138: LD_EXP 61
67142: PUSH
67143: LD_VAR 0 2
67147: ARRAY
67148: PUSH
67149: LD_INT 2
67151: ARRAY
67152: AND
67153: IFFALSE 67183
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67155: LD_VAR 0 3
67159: PPUSH
67160: LD_EXP 61
67164: PUSH
67165: LD_VAR 0 2
67169: ARRAY
67170: PUSH
67171: LD_INT 2
67173: ARRAY
67174: PUSH
67175: LD_INT 1
67177: ARRAY
67178: PPUSH
67179: CALL_OW 128
// end ;
67183: GO 66961
67185: POP
67186: POP
// end ;
67187: GO 66804
67189: POP
67190: POP
// end ;
67191: LD_VAR 0 1
67195: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
67196: LD_INT 0
67198: PPUSH
67199: PPUSH
67200: PPUSH
67201: PPUSH
67202: PPUSH
// if not mc_bases then
67203: LD_EXP 58
67207: NOT
67208: IFFALSE 67212
// exit ;
67210: GO 68355
// for i = 1 to mc_bases do
67212: LD_ADDR_VAR 0 2
67216: PUSH
67217: DOUBLE
67218: LD_INT 1
67220: DEC
67221: ST_TO_ADDR
67222: LD_EXP 58
67226: PUSH
67227: FOR_TO
67228: IFFALSE 68353
// begin if mc_scan [ i ] then
67230: LD_EXP 81
67234: PUSH
67235: LD_VAR 0 2
67239: ARRAY
67240: IFFALSE 67244
// continue ;
67242: GO 67227
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67244: LD_EXP 63
67248: PUSH
67249: LD_VAR 0 2
67253: ARRAY
67254: NOT
67255: PUSH
67256: LD_EXP 65
67260: PUSH
67261: LD_VAR 0 2
67265: ARRAY
67266: NOT
67267: AND
67268: PUSH
67269: LD_EXP 64
67273: PUSH
67274: LD_VAR 0 2
67278: ARRAY
67279: AND
67280: IFFALSE 67318
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67282: LD_ADDR_EXP 64
67286: PUSH
67287: LD_EXP 64
67291: PPUSH
67292: LD_VAR 0 2
67296: PPUSH
67297: EMPTY
67298: PPUSH
67299: CALL_OW 1
67303: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67304: LD_VAR 0 2
67308: PPUSH
67309: LD_INT 103
67311: PPUSH
67312: CALL 61154 0 2
// continue ;
67316: GO 67227
// end ; if mc_construct_list [ i ] then
67318: LD_EXP 65
67322: PUSH
67323: LD_VAR 0 2
67327: ARRAY
67328: IFFALSE 67548
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67330: LD_ADDR_VAR 0 4
67334: PUSH
67335: LD_EXP 58
67339: PUSH
67340: LD_VAR 0 2
67344: ARRAY
67345: PPUSH
67346: LD_INT 25
67348: PUSH
67349: LD_INT 2
67351: PUSH
67352: EMPTY
67353: LIST
67354: LIST
67355: PPUSH
67356: CALL_OW 72
67360: PUSH
67361: LD_EXP 60
67365: PUSH
67366: LD_VAR 0 2
67370: ARRAY
67371: DIFF
67372: ST_TO_ADDR
// if not tmp then
67373: LD_VAR 0 4
67377: NOT
67378: IFFALSE 67382
// continue ;
67380: GO 67227
// for j in tmp do
67382: LD_ADDR_VAR 0 3
67386: PUSH
67387: LD_VAR 0 4
67391: PUSH
67392: FOR_IN
67393: IFFALSE 67544
// begin if not mc_builders [ i ] then
67395: LD_EXP 64
67399: PUSH
67400: LD_VAR 0 2
67404: ARRAY
67405: NOT
67406: IFFALSE 67464
// begin SetTag ( j , 103 ) ;
67408: LD_VAR 0 3
67412: PPUSH
67413: LD_INT 103
67415: PPUSH
67416: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67420: LD_ADDR_EXP 64
67424: PUSH
67425: LD_EXP 64
67429: PPUSH
67430: LD_VAR 0 2
67434: PUSH
67435: LD_EXP 64
67439: PUSH
67440: LD_VAR 0 2
67444: ARRAY
67445: PUSH
67446: LD_INT 1
67448: PLUS
67449: PUSH
67450: EMPTY
67451: LIST
67452: LIST
67453: PPUSH
67454: LD_VAR 0 3
67458: PPUSH
67459: CALL 21151 0 3
67463: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67464: LD_VAR 0 3
67468: PPUSH
67469: CALL_OW 310
67473: IFFALSE 67484
// ComExitBuilding ( j ) ;
67475: LD_VAR 0 3
67479: PPUSH
67480: CALL_OW 122
// wait ( 3 ) ;
67484: LD_INT 3
67486: PPUSH
67487: CALL_OW 67
// if not mc_construct_list [ i ] then
67491: LD_EXP 65
67495: PUSH
67496: LD_VAR 0 2
67500: ARRAY
67501: NOT
67502: IFFALSE 67506
// break ;
67504: GO 67544
// if not HasTask ( j ) then
67506: LD_VAR 0 3
67510: PPUSH
67511: CALL_OW 314
67515: NOT
67516: IFFALSE 67542
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67518: LD_VAR 0 3
67522: PPUSH
67523: LD_EXP 65
67527: PUSH
67528: LD_VAR 0 2
67532: ARRAY
67533: PUSH
67534: LD_INT 1
67536: ARRAY
67537: PPUSH
67538: CALL 24002 0 2
// end ;
67542: GO 67392
67544: POP
67545: POP
// end else
67546: GO 68351
// if mc_build_list [ i ] then
67548: LD_EXP 63
67552: PUSH
67553: LD_VAR 0 2
67557: ARRAY
67558: IFFALSE 68351
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67560: LD_ADDR_VAR 0 5
67564: PUSH
67565: LD_EXP 58
67569: PUSH
67570: LD_VAR 0 2
67574: ARRAY
67575: PPUSH
67576: LD_INT 2
67578: PUSH
67579: LD_INT 30
67581: PUSH
67582: LD_INT 0
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: LD_INT 30
67591: PUSH
67592: LD_INT 1
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: PUSH
67599: EMPTY
67600: LIST
67601: LIST
67602: LIST
67603: PPUSH
67604: CALL_OW 72
67608: ST_TO_ADDR
// if depot then
67609: LD_VAR 0 5
67613: IFFALSE 67631
// depot := depot [ 1 ] else
67615: LD_ADDR_VAR 0 5
67619: PUSH
67620: LD_VAR 0 5
67624: PUSH
67625: LD_INT 1
67627: ARRAY
67628: ST_TO_ADDR
67629: GO 67639
// depot := 0 ;
67631: LD_ADDR_VAR 0 5
67635: PUSH
67636: LD_INT 0
67638: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67639: LD_EXP 63
67643: PUSH
67644: LD_VAR 0 2
67648: ARRAY
67649: PUSH
67650: LD_INT 1
67652: ARRAY
67653: PUSH
67654: LD_INT 1
67656: ARRAY
67657: PPUSH
67658: CALL 23832 0 1
67662: PUSH
67663: LD_EXP 58
67667: PUSH
67668: LD_VAR 0 2
67672: ARRAY
67673: PPUSH
67674: LD_INT 2
67676: PUSH
67677: LD_INT 30
67679: PUSH
67680: LD_INT 2
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: PUSH
67687: LD_INT 30
67689: PUSH
67690: LD_INT 3
67692: PUSH
67693: EMPTY
67694: LIST
67695: LIST
67696: PUSH
67697: EMPTY
67698: LIST
67699: LIST
67700: LIST
67701: PPUSH
67702: CALL_OW 72
67706: NOT
67707: AND
67708: IFFALSE 67813
// begin for j = 1 to mc_build_list [ i ] do
67710: LD_ADDR_VAR 0 3
67714: PUSH
67715: DOUBLE
67716: LD_INT 1
67718: DEC
67719: ST_TO_ADDR
67720: LD_EXP 63
67724: PUSH
67725: LD_VAR 0 2
67729: ARRAY
67730: PUSH
67731: FOR_TO
67732: IFFALSE 67811
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67734: LD_EXP 63
67738: PUSH
67739: LD_VAR 0 2
67743: ARRAY
67744: PUSH
67745: LD_VAR 0 3
67749: ARRAY
67750: PUSH
67751: LD_INT 1
67753: ARRAY
67754: PUSH
67755: LD_INT 2
67757: EQUAL
67758: IFFALSE 67809
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67760: LD_ADDR_EXP 63
67764: PUSH
67765: LD_EXP 63
67769: PPUSH
67770: LD_VAR 0 2
67774: PPUSH
67775: LD_EXP 63
67779: PUSH
67780: LD_VAR 0 2
67784: ARRAY
67785: PPUSH
67786: LD_VAR 0 3
67790: PPUSH
67791: LD_INT 1
67793: PPUSH
67794: LD_INT 0
67796: PPUSH
67797: CALL 20569 0 4
67801: PPUSH
67802: CALL_OW 1
67806: ST_TO_ADDR
// break ;
67807: GO 67811
// end ;
67809: GO 67731
67811: POP
67812: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
67813: LD_EXP 63
67817: PUSH
67818: LD_VAR 0 2
67822: ARRAY
67823: PUSH
67824: LD_INT 1
67826: ARRAY
67827: PUSH
67828: LD_INT 1
67830: ARRAY
67831: PUSH
67832: LD_INT 0
67834: EQUAL
67835: PUSH
67836: LD_VAR 0 5
67840: PUSH
67841: LD_VAR 0 5
67845: PPUSH
67846: LD_EXP 63
67850: PUSH
67851: LD_VAR 0 2
67855: ARRAY
67856: PUSH
67857: LD_INT 1
67859: ARRAY
67860: PUSH
67861: LD_INT 1
67863: ARRAY
67864: PPUSH
67865: LD_EXP 63
67869: PUSH
67870: LD_VAR 0 2
67874: ARRAY
67875: PUSH
67876: LD_INT 1
67878: ARRAY
67879: PUSH
67880: LD_INT 2
67882: ARRAY
67883: PPUSH
67884: LD_EXP 63
67888: PUSH
67889: LD_VAR 0 2
67893: ARRAY
67894: PUSH
67895: LD_INT 1
67897: ARRAY
67898: PUSH
67899: LD_INT 3
67901: ARRAY
67902: PPUSH
67903: LD_EXP 63
67907: PUSH
67908: LD_VAR 0 2
67912: ARRAY
67913: PUSH
67914: LD_INT 1
67916: ARRAY
67917: PUSH
67918: LD_INT 4
67920: ARRAY
67921: PPUSH
67922: CALL 28566 0 5
67926: AND
67927: OR
67928: IFFALSE 68209
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67930: LD_ADDR_VAR 0 4
67934: PUSH
67935: LD_EXP 58
67939: PUSH
67940: LD_VAR 0 2
67944: ARRAY
67945: PPUSH
67946: LD_INT 25
67948: PUSH
67949: LD_INT 2
67951: PUSH
67952: EMPTY
67953: LIST
67954: LIST
67955: PPUSH
67956: CALL_OW 72
67960: PUSH
67961: LD_EXP 60
67965: PUSH
67966: LD_VAR 0 2
67970: ARRAY
67971: DIFF
67972: ST_TO_ADDR
// if not tmp then
67973: LD_VAR 0 4
67977: NOT
67978: IFFALSE 67982
// continue ;
67980: GO 67227
// for j in tmp do
67982: LD_ADDR_VAR 0 3
67986: PUSH
67987: LD_VAR 0 4
67991: PUSH
67992: FOR_IN
67993: IFFALSE 68205
// begin if not mc_builders [ i ] then
67995: LD_EXP 64
67999: PUSH
68000: LD_VAR 0 2
68004: ARRAY
68005: NOT
68006: IFFALSE 68064
// begin SetTag ( j , 103 ) ;
68008: LD_VAR 0 3
68012: PPUSH
68013: LD_INT 103
68015: PPUSH
68016: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68020: LD_ADDR_EXP 64
68024: PUSH
68025: LD_EXP 64
68029: PPUSH
68030: LD_VAR 0 2
68034: PUSH
68035: LD_EXP 64
68039: PUSH
68040: LD_VAR 0 2
68044: ARRAY
68045: PUSH
68046: LD_INT 1
68048: PLUS
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PPUSH
68054: LD_VAR 0 3
68058: PPUSH
68059: CALL 21151 0 3
68063: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68064: LD_VAR 0 3
68068: PPUSH
68069: CALL_OW 310
68073: IFFALSE 68084
// ComExitBuilding ( j ) ;
68075: LD_VAR 0 3
68079: PPUSH
68080: CALL_OW 122
// wait ( 3 ) ;
68084: LD_INT 3
68086: PPUSH
68087: CALL_OW 67
// if not mc_build_list [ i ] then
68091: LD_EXP 63
68095: PUSH
68096: LD_VAR 0 2
68100: ARRAY
68101: NOT
68102: IFFALSE 68106
// break ;
68104: GO 68205
// if not HasTask ( j ) then
68106: LD_VAR 0 3
68110: PPUSH
68111: CALL_OW 314
68115: NOT
68116: IFFALSE 68203
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68118: LD_VAR 0 3
68122: PPUSH
68123: LD_EXP 63
68127: PUSH
68128: LD_VAR 0 2
68132: ARRAY
68133: PUSH
68134: LD_INT 1
68136: ARRAY
68137: PUSH
68138: LD_INT 1
68140: ARRAY
68141: PPUSH
68142: LD_EXP 63
68146: PUSH
68147: LD_VAR 0 2
68151: ARRAY
68152: PUSH
68153: LD_INT 1
68155: ARRAY
68156: PUSH
68157: LD_INT 2
68159: ARRAY
68160: PPUSH
68161: LD_EXP 63
68165: PUSH
68166: LD_VAR 0 2
68170: ARRAY
68171: PUSH
68172: LD_INT 1
68174: ARRAY
68175: PUSH
68176: LD_INT 3
68178: ARRAY
68179: PPUSH
68180: LD_EXP 63
68184: PUSH
68185: LD_VAR 0 2
68189: ARRAY
68190: PUSH
68191: LD_INT 1
68193: ARRAY
68194: PUSH
68195: LD_INT 4
68197: ARRAY
68198: PPUSH
68199: CALL_OW 145
// end ;
68203: GO 67992
68205: POP
68206: POP
// end else
68207: GO 68351
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68209: LD_EXP 58
68213: PUSH
68214: LD_VAR 0 2
68218: ARRAY
68219: PPUSH
68220: LD_EXP 63
68224: PUSH
68225: LD_VAR 0 2
68229: ARRAY
68230: PUSH
68231: LD_INT 1
68233: ARRAY
68234: PUSH
68235: LD_INT 1
68237: ARRAY
68238: PPUSH
68239: LD_EXP 63
68243: PUSH
68244: LD_VAR 0 2
68248: ARRAY
68249: PUSH
68250: LD_INT 1
68252: ARRAY
68253: PUSH
68254: LD_INT 2
68256: ARRAY
68257: PPUSH
68258: LD_EXP 63
68262: PUSH
68263: LD_VAR 0 2
68267: ARRAY
68268: PUSH
68269: LD_INT 1
68271: ARRAY
68272: PUSH
68273: LD_INT 3
68275: ARRAY
68276: PPUSH
68277: LD_EXP 63
68281: PUSH
68282: LD_VAR 0 2
68286: ARRAY
68287: PUSH
68288: LD_INT 1
68290: ARRAY
68291: PUSH
68292: LD_INT 4
68294: ARRAY
68295: PPUSH
68296: CALL 27902 0 5
68300: NOT
68301: IFFALSE 68351
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68303: LD_ADDR_EXP 63
68307: PUSH
68308: LD_EXP 63
68312: PPUSH
68313: LD_VAR 0 2
68317: PPUSH
68318: LD_EXP 63
68322: PUSH
68323: LD_VAR 0 2
68327: ARRAY
68328: PPUSH
68329: LD_INT 1
68331: PPUSH
68332: LD_INT 1
68334: NEG
68335: PPUSH
68336: LD_INT 0
68338: PPUSH
68339: CALL 20569 0 4
68343: PPUSH
68344: CALL_OW 1
68348: ST_TO_ADDR
// continue ;
68349: GO 67227
// end ; end ; end ;
68351: GO 67227
68353: POP
68354: POP
// end ;
68355: LD_VAR 0 1
68359: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68360: LD_INT 0
68362: PPUSH
68363: PPUSH
68364: PPUSH
68365: PPUSH
68366: PPUSH
68367: PPUSH
// if not mc_bases then
68368: LD_EXP 58
68372: NOT
68373: IFFALSE 68377
// exit ;
68375: GO 68804
// for i = 1 to mc_bases do
68377: LD_ADDR_VAR 0 2
68381: PUSH
68382: DOUBLE
68383: LD_INT 1
68385: DEC
68386: ST_TO_ADDR
68387: LD_EXP 58
68391: PUSH
68392: FOR_TO
68393: IFFALSE 68802
// begin tmp := mc_build_upgrade [ i ] ;
68395: LD_ADDR_VAR 0 4
68399: PUSH
68400: LD_EXP 90
68404: PUSH
68405: LD_VAR 0 2
68409: ARRAY
68410: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68411: LD_ADDR_VAR 0 6
68415: PUSH
68416: LD_EXP 91
68420: PUSH
68421: LD_VAR 0 2
68425: ARRAY
68426: PPUSH
68427: LD_INT 2
68429: PUSH
68430: LD_INT 30
68432: PUSH
68433: LD_INT 6
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PUSH
68440: LD_INT 30
68442: PUSH
68443: LD_INT 7
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: LIST
68454: PPUSH
68455: CALL_OW 72
68459: ST_TO_ADDR
// if not tmp and not lab then
68460: LD_VAR 0 4
68464: NOT
68465: PUSH
68466: LD_VAR 0 6
68470: NOT
68471: AND
68472: IFFALSE 68476
// continue ;
68474: GO 68392
// if tmp then
68476: LD_VAR 0 4
68480: IFFALSE 68600
// for j in tmp do
68482: LD_ADDR_VAR 0 3
68486: PUSH
68487: LD_VAR 0 4
68491: PUSH
68492: FOR_IN
68493: IFFALSE 68598
// begin if UpgradeCost ( j ) then
68495: LD_VAR 0 3
68499: PPUSH
68500: CALL 27562 0 1
68504: IFFALSE 68596
// begin ComUpgrade ( j ) ;
68506: LD_VAR 0 3
68510: PPUSH
68511: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68515: LD_ADDR_EXP 90
68519: PUSH
68520: LD_EXP 90
68524: PPUSH
68525: LD_VAR 0 2
68529: PPUSH
68530: LD_EXP 90
68534: PUSH
68535: LD_VAR 0 2
68539: ARRAY
68540: PUSH
68541: LD_VAR 0 3
68545: DIFF
68546: PPUSH
68547: CALL_OW 1
68551: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68552: LD_ADDR_EXP 65
68556: PUSH
68557: LD_EXP 65
68561: PPUSH
68562: LD_VAR 0 2
68566: PUSH
68567: LD_EXP 65
68571: PUSH
68572: LD_VAR 0 2
68576: ARRAY
68577: PUSH
68578: LD_INT 1
68580: PLUS
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PPUSH
68586: LD_VAR 0 3
68590: PPUSH
68591: CALL 21151 0 3
68595: ST_TO_ADDR
// end ; end ;
68596: GO 68492
68598: POP
68599: POP
// if not lab or not mc_lab_upgrade [ i ] then
68600: LD_VAR 0 6
68604: NOT
68605: PUSH
68606: LD_EXP 92
68610: PUSH
68611: LD_VAR 0 2
68615: ARRAY
68616: NOT
68617: OR
68618: IFFALSE 68622
// continue ;
68620: GO 68392
// for j in lab do
68622: LD_ADDR_VAR 0 3
68626: PUSH
68627: LD_VAR 0 6
68631: PUSH
68632: FOR_IN
68633: IFFALSE 68798
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68635: LD_VAR 0 3
68639: PPUSH
68640: CALL_OW 266
68644: PUSH
68645: LD_INT 6
68647: PUSH
68648: LD_INT 7
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: IN
68655: PUSH
68656: LD_VAR 0 3
68660: PPUSH
68661: CALL_OW 461
68665: PUSH
68666: LD_INT 1
68668: NONEQUAL
68669: AND
68670: IFFALSE 68796
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68672: LD_VAR 0 3
68676: PPUSH
68677: LD_EXP 92
68681: PUSH
68682: LD_VAR 0 2
68686: ARRAY
68687: PUSH
68688: LD_INT 1
68690: ARRAY
68691: PPUSH
68692: CALL 27767 0 2
68696: IFFALSE 68796
// begin ComCancel ( j ) ;
68698: LD_VAR 0 3
68702: PPUSH
68703: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68707: LD_VAR 0 3
68711: PPUSH
68712: LD_EXP 92
68716: PUSH
68717: LD_VAR 0 2
68721: ARRAY
68722: PUSH
68723: LD_INT 1
68725: ARRAY
68726: PPUSH
68727: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68731: LD_VAR 0 3
68735: PUSH
68736: LD_EXP 65
68740: PUSH
68741: LD_VAR 0 2
68745: ARRAY
68746: IN
68747: NOT
68748: IFFALSE 68794
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68750: LD_ADDR_EXP 65
68754: PUSH
68755: LD_EXP 65
68759: PPUSH
68760: LD_VAR 0 2
68764: PUSH
68765: LD_EXP 65
68769: PUSH
68770: LD_VAR 0 2
68774: ARRAY
68775: PUSH
68776: LD_INT 1
68778: PLUS
68779: PUSH
68780: EMPTY
68781: LIST
68782: LIST
68783: PPUSH
68784: LD_VAR 0 3
68788: PPUSH
68789: CALL 21151 0 3
68793: ST_TO_ADDR
// break ;
68794: GO 68798
// end ; end ; end ;
68796: GO 68632
68798: POP
68799: POP
// end ;
68800: GO 68392
68802: POP
68803: POP
// end ;
68804: LD_VAR 0 1
68808: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68809: LD_INT 0
68811: PPUSH
68812: PPUSH
68813: PPUSH
68814: PPUSH
68815: PPUSH
68816: PPUSH
68817: PPUSH
68818: PPUSH
68819: PPUSH
// if not mc_bases then
68820: LD_EXP 58
68824: NOT
68825: IFFALSE 68829
// exit ;
68827: GO 69234
// for i = 1 to mc_bases do
68829: LD_ADDR_VAR 0 2
68833: PUSH
68834: DOUBLE
68835: LD_INT 1
68837: DEC
68838: ST_TO_ADDR
68839: LD_EXP 58
68843: PUSH
68844: FOR_TO
68845: IFFALSE 69232
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68847: LD_EXP 66
68851: PUSH
68852: LD_VAR 0 2
68856: ARRAY
68857: NOT
68858: PUSH
68859: LD_EXP 58
68863: PUSH
68864: LD_VAR 0 2
68868: ARRAY
68869: PPUSH
68870: LD_INT 30
68872: PUSH
68873: LD_INT 3
68875: PUSH
68876: EMPTY
68877: LIST
68878: LIST
68879: PPUSH
68880: CALL_OW 72
68884: NOT
68885: OR
68886: IFFALSE 68890
// continue ;
68888: GO 68844
// busy := false ;
68890: LD_ADDR_VAR 0 8
68894: PUSH
68895: LD_INT 0
68897: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68898: LD_ADDR_VAR 0 4
68902: PUSH
68903: LD_EXP 58
68907: PUSH
68908: LD_VAR 0 2
68912: ARRAY
68913: PPUSH
68914: LD_INT 30
68916: PUSH
68917: LD_INT 3
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PPUSH
68924: CALL_OW 72
68928: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68929: LD_ADDR_VAR 0 6
68933: PUSH
68934: LD_EXP 66
68938: PUSH
68939: LD_VAR 0 2
68943: ARRAY
68944: PPUSH
68945: LD_INT 2
68947: PUSH
68948: LD_INT 30
68950: PUSH
68951: LD_INT 32
68953: PUSH
68954: EMPTY
68955: LIST
68956: LIST
68957: PUSH
68958: LD_INT 30
68960: PUSH
68961: LD_INT 33
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: LIST
68972: PPUSH
68973: CALL_OW 72
68977: ST_TO_ADDR
// if not t then
68978: LD_VAR 0 6
68982: NOT
68983: IFFALSE 68987
// continue ;
68985: GO 68844
// for j in tmp do
68987: LD_ADDR_VAR 0 3
68991: PUSH
68992: LD_VAR 0 4
68996: PUSH
68997: FOR_IN
68998: IFFALSE 69028
// if not BuildingStatus ( j ) = bs_idle then
69000: LD_VAR 0 3
69004: PPUSH
69005: CALL_OW 461
69009: PUSH
69010: LD_INT 2
69012: EQUAL
69013: NOT
69014: IFFALSE 69026
// begin busy := true ;
69016: LD_ADDR_VAR 0 8
69020: PUSH
69021: LD_INT 1
69023: ST_TO_ADDR
// break ;
69024: GO 69028
// end ;
69026: GO 68997
69028: POP
69029: POP
// if busy then
69030: LD_VAR 0 8
69034: IFFALSE 69038
// continue ;
69036: GO 68844
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69038: LD_ADDR_VAR 0 7
69042: PUSH
69043: LD_VAR 0 6
69047: PPUSH
69048: LD_INT 35
69050: PUSH
69051: LD_INT 0
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PPUSH
69058: CALL_OW 72
69062: ST_TO_ADDR
// if tw then
69063: LD_VAR 0 7
69067: IFFALSE 69144
// begin tw := tw [ 1 ] ;
69069: LD_ADDR_VAR 0 7
69073: PUSH
69074: LD_VAR 0 7
69078: PUSH
69079: LD_INT 1
69081: ARRAY
69082: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69083: LD_ADDR_VAR 0 9
69087: PUSH
69088: LD_VAR 0 7
69092: PPUSH
69093: LD_EXP 83
69097: PUSH
69098: LD_VAR 0 2
69102: ARRAY
69103: PPUSH
69104: CALL 26121 0 2
69108: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69109: LD_EXP 97
69113: PUSH
69114: LD_VAR 0 2
69118: ARRAY
69119: IFFALSE 69142
// if not weapon in mc_allowed_tower_weapons [ i ] then
69121: LD_VAR 0 9
69125: PUSH
69126: LD_EXP 97
69130: PUSH
69131: LD_VAR 0 2
69135: ARRAY
69136: IN
69137: NOT
69138: IFFALSE 69142
// continue ;
69140: GO 68844
// end else
69142: GO 69207
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69144: LD_ADDR_VAR 0 5
69148: PUSH
69149: LD_EXP 66
69153: PUSH
69154: LD_VAR 0 2
69158: ARRAY
69159: PPUSH
69160: LD_VAR 0 4
69164: PPUSH
69165: CALL 56322 0 2
69169: ST_TO_ADDR
// if not tmp2 then
69170: LD_VAR 0 5
69174: NOT
69175: IFFALSE 69179
// continue ;
69177: GO 68844
// tw := tmp2 [ 1 ] ;
69179: LD_ADDR_VAR 0 7
69183: PUSH
69184: LD_VAR 0 5
69188: PUSH
69189: LD_INT 1
69191: ARRAY
69192: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69193: LD_ADDR_VAR 0 9
69197: PUSH
69198: LD_VAR 0 5
69202: PUSH
69203: LD_INT 2
69205: ARRAY
69206: ST_TO_ADDR
// end ; if not weapon then
69207: LD_VAR 0 9
69211: NOT
69212: IFFALSE 69216
// continue ;
69214: GO 68844
// ComPlaceWeapon ( tw , weapon ) ;
69216: LD_VAR 0 7
69220: PPUSH
69221: LD_VAR 0 9
69225: PPUSH
69226: CALL_OW 148
// end ;
69230: GO 68844
69232: POP
69233: POP
// end ;
69234: LD_VAR 0 1
69238: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
69239: LD_INT 0
69241: PPUSH
69242: PPUSH
69243: PPUSH
69244: PPUSH
69245: PPUSH
69246: PPUSH
// if not mc_bases then
69247: LD_EXP 58
69251: NOT
69252: IFFALSE 69256
// exit ;
69254: GO 70268
// for i = 1 to mc_bases do
69256: LD_ADDR_VAR 0 2
69260: PUSH
69261: DOUBLE
69262: LD_INT 1
69264: DEC
69265: ST_TO_ADDR
69266: LD_EXP 58
69270: PUSH
69271: FOR_TO
69272: IFFALSE 70266
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
69274: LD_EXP 71
69278: PUSH
69279: LD_VAR 0 2
69283: ARRAY
69284: NOT
69285: PUSH
69286: LD_EXP 71
69290: PUSH
69291: LD_VAR 0 2
69295: ARRAY
69296: PUSH
69297: LD_EXP 72
69301: PUSH
69302: LD_VAR 0 2
69306: ARRAY
69307: EQUAL
69308: OR
69309: IFFALSE 69313
// continue ;
69311: GO 69271
// if mc_miners [ i ] then
69313: LD_EXP 72
69317: PUSH
69318: LD_VAR 0 2
69322: ARRAY
69323: IFFALSE 69953
// begin k := 1 ;
69325: LD_ADDR_VAR 0 4
69329: PUSH
69330: LD_INT 1
69332: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
69333: LD_ADDR_VAR 0 3
69337: PUSH
69338: DOUBLE
69339: LD_EXP 72
69343: PUSH
69344: LD_VAR 0 2
69348: ARRAY
69349: INC
69350: ST_TO_ADDR
69351: LD_INT 1
69353: PUSH
69354: FOR_DOWNTO
69355: IFFALSE 69951
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69357: LD_EXP 72
69361: PUSH
69362: LD_VAR 0 2
69366: ARRAY
69367: PUSH
69368: LD_VAR 0 3
69372: ARRAY
69373: PPUSH
69374: CALL_OW 301
69378: PUSH
69379: LD_EXP 72
69383: PUSH
69384: LD_VAR 0 2
69388: ARRAY
69389: PUSH
69390: LD_VAR 0 3
69394: ARRAY
69395: PPUSH
69396: CALL_OW 257
69400: PUSH
69401: LD_INT 1
69403: NONEQUAL
69404: OR
69405: IFFALSE 69468
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69407: LD_ADDR_VAR 0 5
69411: PUSH
69412: LD_EXP 72
69416: PUSH
69417: LD_VAR 0 2
69421: ARRAY
69422: PUSH
69423: LD_EXP 72
69427: PUSH
69428: LD_VAR 0 2
69432: ARRAY
69433: PUSH
69434: LD_VAR 0 3
69438: ARRAY
69439: DIFF
69440: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69441: LD_ADDR_EXP 72
69445: PUSH
69446: LD_EXP 72
69450: PPUSH
69451: LD_VAR 0 2
69455: PPUSH
69456: LD_VAR 0 5
69460: PPUSH
69461: CALL_OW 1
69465: ST_TO_ADDR
// continue ;
69466: GO 69354
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
69468: LD_EXP 72
69472: PUSH
69473: LD_VAR 0 2
69477: ARRAY
69478: PUSH
69479: LD_VAR 0 3
69483: ARRAY
69484: PPUSH
69485: CALL 21087 0 1
69489: PUSH
69490: LD_EXP 72
69494: PUSH
69495: LD_VAR 0 2
69499: ARRAY
69500: PUSH
69501: LD_VAR 0 3
69505: ARRAY
69506: PPUSH
69507: CALL_OW 255
69511: PPUSH
69512: LD_EXP 71
69516: PUSH
69517: LD_VAR 0 2
69521: ARRAY
69522: PUSH
69523: LD_VAR 0 4
69527: ARRAY
69528: PUSH
69529: LD_INT 1
69531: ARRAY
69532: PPUSH
69533: LD_EXP 71
69537: PUSH
69538: LD_VAR 0 2
69542: ARRAY
69543: PUSH
69544: LD_VAR 0 4
69548: ARRAY
69549: PUSH
69550: LD_INT 2
69552: ARRAY
69553: PPUSH
69554: LD_INT 15
69556: PPUSH
69557: CALL 22047 0 4
69561: PUSH
69562: LD_INT 4
69564: ARRAY
69565: PUSH
69566: LD_EXP 72
69570: PUSH
69571: LD_VAR 0 2
69575: ARRAY
69576: PUSH
69577: LD_VAR 0 3
69581: ARRAY
69582: PPUSH
69583: LD_INT 10
69585: PPUSH
69586: CALL 23744 0 2
69590: PUSH
69591: LD_INT 4
69593: ARRAY
69594: OR
69595: AND
69596: IFFALSE 69619
// ComStop ( mc_miners [ i ] [ j ] ) ;
69598: LD_EXP 72
69602: PUSH
69603: LD_VAR 0 2
69607: ARRAY
69608: PUSH
69609: LD_VAR 0 3
69613: ARRAY
69614: PPUSH
69615: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
69619: LD_EXP 72
69623: PUSH
69624: LD_VAR 0 2
69628: ARRAY
69629: PUSH
69630: LD_VAR 0 3
69634: ARRAY
69635: PPUSH
69636: CALL_OW 257
69640: PUSH
69641: LD_INT 1
69643: EQUAL
69644: PUSH
69645: LD_EXP 72
69649: PUSH
69650: LD_VAR 0 2
69654: ARRAY
69655: PUSH
69656: LD_VAR 0 3
69660: ARRAY
69661: PPUSH
69662: CALL_OW 459
69666: NOT
69667: AND
69668: PUSH
69669: LD_EXP 72
69673: PUSH
69674: LD_VAR 0 2
69678: ARRAY
69679: PUSH
69680: LD_VAR 0 3
69684: ARRAY
69685: PPUSH
69686: CALL_OW 255
69690: PPUSH
69691: LD_EXP 71
69695: PUSH
69696: LD_VAR 0 2
69700: ARRAY
69701: PUSH
69702: LD_VAR 0 4
69706: ARRAY
69707: PUSH
69708: LD_INT 1
69710: ARRAY
69711: PPUSH
69712: LD_EXP 71
69716: PUSH
69717: LD_VAR 0 2
69721: ARRAY
69722: PUSH
69723: LD_VAR 0 4
69727: ARRAY
69728: PUSH
69729: LD_INT 2
69731: ARRAY
69732: PPUSH
69733: LD_INT 15
69735: PPUSH
69736: CALL 22047 0 4
69740: PUSH
69741: LD_INT 4
69743: ARRAY
69744: PUSH
69745: LD_INT 0
69747: EQUAL
69748: AND
69749: PUSH
69750: LD_EXP 72
69754: PUSH
69755: LD_VAR 0 2
69759: ARRAY
69760: PUSH
69761: LD_VAR 0 3
69765: ARRAY
69766: PPUSH
69767: CALL_OW 314
69771: NOT
69772: AND
69773: IFFALSE 69949
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69775: LD_EXP 72
69779: PUSH
69780: LD_VAR 0 2
69784: ARRAY
69785: PUSH
69786: LD_VAR 0 3
69790: ARRAY
69791: PPUSH
69792: CALL_OW 310
69796: IFFALSE 69819
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69798: LD_EXP 72
69802: PUSH
69803: LD_VAR 0 2
69807: ARRAY
69808: PUSH
69809: LD_VAR 0 3
69813: ARRAY
69814: PPUSH
69815: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69819: LD_EXP 72
69823: PUSH
69824: LD_VAR 0 2
69828: ARRAY
69829: PUSH
69830: LD_VAR 0 3
69834: ARRAY
69835: PPUSH
69836: CALL_OW 314
69840: NOT
69841: IFFALSE 69909
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
69843: LD_EXP 72
69847: PUSH
69848: LD_VAR 0 2
69852: ARRAY
69853: PUSH
69854: LD_VAR 0 3
69858: ARRAY
69859: PPUSH
69860: LD_EXP 71
69864: PUSH
69865: LD_VAR 0 2
69869: ARRAY
69870: PUSH
69871: LD_VAR 0 4
69875: ARRAY
69876: PUSH
69877: LD_INT 1
69879: ARRAY
69880: PPUSH
69881: LD_EXP 71
69885: PUSH
69886: LD_VAR 0 2
69890: ARRAY
69891: PUSH
69892: LD_VAR 0 4
69896: ARRAY
69897: PUSH
69898: LD_INT 2
69900: ARRAY
69901: PPUSH
69902: LD_INT 0
69904: PPUSH
69905: CALL_OW 193
// k := k + 1 ;
69909: LD_ADDR_VAR 0 4
69913: PUSH
69914: LD_VAR 0 4
69918: PUSH
69919: LD_INT 1
69921: PLUS
69922: ST_TO_ADDR
// if k > mc_mines [ i ] then
69923: LD_VAR 0 4
69927: PUSH
69928: LD_EXP 71
69932: PUSH
69933: LD_VAR 0 2
69937: ARRAY
69938: GREATER
69939: IFFALSE 69949
// k := 1 ;
69941: LD_ADDR_VAR 0 4
69945: PUSH
69946: LD_INT 1
69948: ST_TO_ADDR
// end ; end ;
69949: GO 69354
69951: POP
69952: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69953: LD_ADDR_VAR 0 5
69957: PUSH
69958: LD_EXP 58
69962: PUSH
69963: LD_VAR 0 2
69967: ARRAY
69968: PPUSH
69969: LD_INT 2
69971: PUSH
69972: LD_INT 30
69974: PUSH
69975: LD_INT 4
69977: PUSH
69978: EMPTY
69979: LIST
69980: LIST
69981: PUSH
69982: LD_INT 30
69984: PUSH
69985: LD_INT 5
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: LD_INT 30
69994: PUSH
69995: LD_INT 32
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: LIST
70006: LIST
70007: PPUSH
70008: CALL_OW 72
70012: ST_TO_ADDR
// if not tmp then
70013: LD_VAR 0 5
70017: NOT
70018: IFFALSE 70022
// continue ;
70020: GO 69271
// list := [ ] ;
70022: LD_ADDR_VAR 0 6
70026: PUSH
70027: EMPTY
70028: ST_TO_ADDR
// for j in tmp do
70029: LD_ADDR_VAR 0 3
70033: PUSH
70034: LD_VAR 0 5
70038: PUSH
70039: FOR_IN
70040: IFFALSE 70109
// begin for k in UnitsInside ( j ) do
70042: LD_ADDR_VAR 0 4
70046: PUSH
70047: LD_VAR 0 3
70051: PPUSH
70052: CALL_OW 313
70056: PUSH
70057: FOR_IN
70058: IFFALSE 70105
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70060: LD_VAR 0 4
70064: PPUSH
70065: CALL_OW 257
70069: PUSH
70070: LD_INT 1
70072: EQUAL
70073: PUSH
70074: LD_VAR 0 4
70078: PPUSH
70079: CALL_OW 459
70083: NOT
70084: AND
70085: IFFALSE 70103
// list := list ^ k ;
70087: LD_ADDR_VAR 0 6
70091: PUSH
70092: LD_VAR 0 6
70096: PUSH
70097: LD_VAR 0 4
70101: ADD
70102: ST_TO_ADDR
70103: GO 70057
70105: POP
70106: POP
// end ;
70107: GO 70039
70109: POP
70110: POP
// list := list diff mc_miners [ i ] ;
70111: LD_ADDR_VAR 0 6
70115: PUSH
70116: LD_VAR 0 6
70120: PUSH
70121: LD_EXP 72
70125: PUSH
70126: LD_VAR 0 2
70130: ARRAY
70131: DIFF
70132: ST_TO_ADDR
// if not list then
70133: LD_VAR 0 6
70137: NOT
70138: IFFALSE 70142
// continue ;
70140: GO 69271
// k := mc_mines [ i ] - mc_miners [ i ] ;
70142: LD_ADDR_VAR 0 4
70146: PUSH
70147: LD_EXP 71
70151: PUSH
70152: LD_VAR 0 2
70156: ARRAY
70157: PUSH
70158: LD_EXP 72
70162: PUSH
70163: LD_VAR 0 2
70167: ARRAY
70168: MINUS
70169: ST_TO_ADDR
// if k > list then
70170: LD_VAR 0 4
70174: PUSH
70175: LD_VAR 0 6
70179: GREATER
70180: IFFALSE 70192
// k := list ;
70182: LD_ADDR_VAR 0 4
70186: PUSH
70187: LD_VAR 0 6
70191: ST_TO_ADDR
// for j = 1 to k do
70192: LD_ADDR_VAR 0 3
70196: PUSH
70197: DOUBLE
70198: LD_INT 1
70200: DEC
70201: ST_TO_ADDR
70202: LD_VAR 0 4
70206: PUSH
70207: FOR_TO
70208: IFFALSE 70262
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70210: LD_ADDR_EXP 72
70214: PUSH
70215: LD_EXP 72
70219: PPUSH
70220: LD_VAR 0 2
70224: PUSH
70225: LD_EXP 72
70229: PUSH
70230: LD_VAR 0 2
70234: ARRAY
70235: PUSH
70236: LD_INT 1
70238: PLUS
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: PPUSH
70244: LD_VAR 0 6
70248: PUSH
70249: LD_VAR 0 3
70253: ARRAY
70254: PPUSH
70255: CALL 21151 0 3
70259: ST_TO_ADDR
70260: GO 70207
70262: POP
70263: POP
// end ;
70264: GO 69271
70266: POP
70267: POP
// end ;
70268: LD_VAR 0 1
70272: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
70273: LD_INT 0
70275: PPUSH
70276: PPUSH
70277: PPUSH
70278: PPUSH
70279: PPUSH
70280: PPUSH
70281: PPUSH
70282: PPUSH
70283: PPUSH
70284: PPUSH
// if not mc_bases then
70285: LD_EXP 58
70289: NOT
70290: IFFALSE 70294
// exit ;
70292: GO 72044
// for i = 1 to mc_bases do
70294: LD_ADDR_VAR 0 2
70298: PUSH
70299: DOUBLE
70300: LD_INT 1
70302: DEC
70303: ST_TO_ADDR
70304: LD_EXP 58
70308: PUSH
70309: FOR_TO
70310: IFFALSE 72042
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70312: LD_EXP 58
70316: PUSH
70317: LD_VAR 0 2
70321: ARRAY
70322: NOT
70323: PUSH
70324: LD_EXP 65
70328: PUSH
70329: LD_VAR 0 2
70333: ARRAY
70334: OR
70335: IFFALSE 70339
// continue ;
70337: GO 70309
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70339: LD_EXP 74
70343: PUSH
70344: LD_VAR 0 2
70348: ARRAY
70349: NOT
70350: PUSH
70351: LD_EXP 75
70355: PUSH
70356: LD_VAR 0 2
70360: ARRAY
70361: AND
70362: IFFALSE 70400
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70364: LD_ADDR_EXP 75
70368: PUSH
70369: LD_EXP 75
70373: PPUSH
70374: LD_VAR 0 2
70378: PPUSH
70379: EMPTY
70380: PPUSH
70381: CALL_OW 1
70385: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70386: LD_VAR 0 2
70390: PPUSH
70391: LD_INT 107
70393: PPUSH
70394: CALL 61154 0 2
// continue ;
70398: GO 70309
// end ; target := [ ] ;
70400: LD_ADDR_VAR 0 6
70404: PUSH
70405: EMPTY
70406: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70407: LD_ADDR_VAR 0 3
70411: PUSH
70412: DOUBLE
70413: LD_EXP 74
70417: PUSH
70418: LD_VAR 0 2
70422: ARRAY
70423: INC
70424: ST_TO_ADDR
70425: LD_INT 1
70427: PUSH
70428: FOR_DOWNTO
70429: IFFALSE 70689
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70431: LD_EXP 74
70435: PUSH
70436: LD_VAR 0 2
70440: ARRAY
70441: PUSH
70442: LD_VAR 0 3
70446: ARRAY
70447: PUSH
70448: LD_INT 2
70450: ARRAY
70451: PPUSH
70452: LD_EXP 74
70456: PUSH
70457: LD_VAR 0 2
70461: ARRAY
70462: PUSH
70463: LD_VAR 0 3
70467: ARRAY
70468: PUSH
70469: LD_INT 3
70471: ARRAY
70472: PPUSH
70473: CALL_OW 488
70477: PUSH
70478: LD_EXP 74
70482: PUSH
70483: LD_VAR 0 2
70487: ARRAY
70488: PUSH
70489: LD_VAR 0 3
70493: ARRAY
70494: PUSH
70495: LD_INT 2
70497: ARRAY
70498: PPUSH
70499: LD_EXP 74
70503: PUSH
70504: LD_VAR 0 2
70508: ARRAY
70509: PUSH
70510: LD_VAR 0 3
70514: ARRAY
70515: PUSH
70516: LD_INT 3
70518: ARRAY
70519: PPUSH
70520: CALL_OW 284
70524: PUSH
70525: LD_INT 0
70527: EQUAL
70528: AND
70529: IFFALSE 70584
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70531: LD_ADDR_VAR 0 5
70535: PUSH
70536: LD_EXP 74
70540: PUSH
70541: LD_VAR 0 2
70545: ARRAY
70546: PPUSH
70547: LD_VAR 0 3
70551: PPUSH
70552: CALL_OW 3
70556: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70557: LD_ADDR_EXP 74
70561: PUSH
70562: LD_EXP 74
70566: PPUSH
70567: LD_VAR 0 2
70571: PPUSH
70572: LD_VAR 0 5
70576: PPUSH
70577: CALL_OW 1
70581: ST_TO_ADDR
// continue ;
70582: GO 70428
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70584: LD_EXP 58
70588: PUSH
70589: LD_VAR 0 2
70593: ARRAY
70594: PUSH
70595: LD_INT 1
70597: ARRAY
70598: PPUSH
70599: CALL_OW 255
70603: PPUSH
70604: LD_EXP 74
70608: PUSH
70609: LD_VAR 0 2
70613: ARRAY
70614: PUSH
70615: LD_VAR 0 3
70619: ARRAY
70620: PUSH
70621: LD_INT 2
70623: ARRAY
70624: PPUSH
70625: LD_EXP 74
70629: PUSH
70630: LD_VAR 0 2
70634: ARRAY
70635: PUSH
70636: LD_VAR 0 3
70640: ARRAY
70641: PUSH
70642: LD_INT 3
70644: ARRAY
70645: PPUSH
70646: LD_INT 30
70648: PPUSH
70649: CALL 22047 0 4
70653: PUSH
70654: LD_INT 4
70656: ARRAY
70657: PUSH
70658: LD_INT 0
70660: EQUAL
70661: IFFALSE 70687
// begin target := mc_crates [ i ] [ j ] ;
70663: LD_ADDR_VAR 0 6
70667: PUSH
70668: LD_EXP 74
70672: PUSH
70673: LD_VAR 0 2
70677: ARRAY
70678: PUSH
70679: LD_VAR 0 3
70683: ARRAY
70684: ST_TO_ADDR
// break ;
70685: GO 70689
// end ; end ;
70687: GO 70428
70689: POP
70690: POP
// if not target then
70691: LD_VAR 0 6
70695: NOT
70696: IFFALSE 70700
// continue ;
70698: GO 70309
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70700: LD_ADDR_VAR 0 7
70704: PUSH
70705: LD_EXP 77
70709: PUSH
70710: LD_VAR 0 2
70714: ARRAY
70715: PPUSH
70716: LD_INT 2
70718: PUSH
70719: LD_INT 3
70721: PUSH
70722: LD_INT 58
70724: PUSH
70725: EMPTY
70726: LIST
70727: PUSH
70728: EMPTY
70729: LIST
70730: LIST
70731: PUSH
70732: LD_INT 61
70734: PUSH
70735: EMPTY
70736: LIST
70737: PUSH
70738: LD_INT 33
70740: PUSH
70741: LD_INT 5
70743: PUSH
70744: EMPTY
70745: LIST
70746: LIST
70747: PUSH
70748: LD_INT 33
70750: PUSH
70751: LD_INT 3
70753: PUSH
70754: EMPTY
70755: LIST
70756: LIST
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 2
70767: PUSH
70768: LD_INT 34
70770: PUSH
70771: LD_INT 32
70773: PUSH
70774: EMPTY
70775: LIST
70776: LIST
70777: PUSH
70778: LD_INT 34
70780: PUSH
70781: LD_INT 51
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 34
70790: PUSH
70791: LD_INT 12
70793: PUSH
70794: EMPTY
70795: LIST
70796: LIST
70797: PUSH
70798: EMPTY
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: PPUSH
70808: CALL_OW 72
70812: ST_TO_ADDR
// if not cargo then
70813: LD_VAR 0 7
70817: NOT
70818: IFFALSE 71461
// begin if mc_crates_collector [ i ] < 5 then
70820: LD_EXP 75
70824: PUSH
70825: LD_VAR 0 2
70829: ARRAY
70830: PUSH
70831: LD_INT 5
70833: LESS
70834: IFFALSE 71200
// begin if mc_ape [ i ] then
70836: LD_EXP 87
70840: PUSH
70841: LD_VAR 0 2
70845: ARRAY
70846: IFFALSE 70893
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70848: LD_ADDR_VAR 0 5
70852: PUSH
70853: LD_EXP 87
70857: PUSH
70858: LD_VAR 0 2
70862: ARRAY
70863: PPUSH
70864: LD_INT 25
70866: PUSH
70867: LD_INT 16
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 24
70876: PUSH
70877: LD_INT 750
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: PPUSH
70888: CALL_OW 72
70892: ST_TO_ADDR
// if not tmp then
70893: LD_VAR 0 5
70897: NOT
70898: IFFALSE 70945
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
70900: LD_ADDR_VAR 0 5
70904: PUSH
70905: LD_EXP 58
70909: PUSH
70910: LD_VAR 0 2
70914: ARRAY
70915: PPUSH
70916: LD_INT 25
70918: PUSH
70919: LD_INT 2
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: PUSH
70926: LD_INT 24
70928: PUSH
70929: LD_INT 750
70931: PUSH
70932: EMPTY
70933: LIST
70934: LIST
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PPUSH
70940: CALL_OW 72
70944: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70945: LD_EXP 87
70949: PUSH
70950: LD_VAR 0 2
70954: ARRAY
70955: PUSH
70956: LD_EXP 58
70960: PUSH
70961: LD_VAR 0 2
70965: ARRAY
70966: PPUSH
70967: LD_INT 25
70969: PUSH
70970: LD_INT 2
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PUSH
70977: LD_INT 24
70979: PUSH
70980: LD_INT 750
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PUSH
70987: EMPTY
70988: LIST
70989: LIST
70990: PPUSH
70991: CALL_OW 72
70995: AND
70996: PUSH
70997: LD_VAR 0 5
71001: PUSH
71002: LD_INT 5
71004: LESS
71005: AND
71006: IFFALSE 71088
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71008: LD_ADDR_VAR 0 3
71012: PUSH
71013: LD_EXP 58
71017: PUSH
71018: LD_VAR 0 2
71022: ARRAY
71023: PPUSH
71024: LD_INT 25
71026: PUSH
71027: LD_INT 2
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: PUSH
71034: LD_INT 24
71036: PUSH
71037: LD_INT 750
71039: PUSH
71040: EMPTY
71041: LIST
71042: LIST
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: PPUSH
71048: CALL_OW 72
71052: PUSH
71053: FOR_IN
71054: IFFALSE 71086
// begin tmp := tmp union j ;
71056: LD_ADDR_VAR 0 5
71060: PUSH
71061: LD_VAR 0 5
71065: PUSH
71066: LD_VAR 0 3
71070: UNION
71071: ST_TO_ADDR
// if tmp >= 5 then
71072: LD_VAR 0 5
71076: PUSH
71077: LD_INT 5
71079: GREATEREQUAL
71080: IFFALSE 71084
// break ;
71082: GO 71086
// end ;
71084: GO 71053
71086: POP
71087: POP
// end ; if not tmp then
71088: LD_VAR 0 5
71092: NOT
71093: IFFALSE 71097
// continue ;
71095: GO 70309
// for j in tmp do
71097: LD_ADDR_VAR 0 3
71101: PUSH
71102: LD_VAR 0 5
71106: PUSH
71107: FOR_IN
71108: IFFALSE 71198
// if not GetTag ( j ) then
71110: LD_VAR 0 3
71114: PPUSH
71115: CALL_OW 110
71119: NOT
71120: IFFALSE 71196
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71122: LD_ADDR_EXP 75
71126: PUSH
71127: LD_EXP 75
71131: PPUSH
71132: LD_VAR 0 2
71136: PUSH
71137: LD_EXP 75
71141: PUSH
71142: LD_VAR 0 2
71146: ARRAY
71147: PUSH
71148: LD_INT 1
71150: PLUS
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: PPUSH
71156: LD_VAR 0 3
71160: PPUSH
71161: CALL 21151 0 3
71165: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71166: LD_VAR 0 3
71170: PPUSH
71171: LD_INT 107
71173: PPUSH
71174: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71178: LD_EXP 75
71182: PUSH
71183: LD_VAR 0 2
71187: ARRAY
71188: PUSH
71189: LD_INT 5
71191: GREATEREQUAL
71192: IFFALSE 71196
// break ;
71194: GO 71198
// end ;
71196: GO 71107
71198: POP
71199: POP
// end ; if mc_crates_collector [ i ] and target then
71200: LD_EXP 75
71204: PUSH
71205: LD_VAR 0 2
71209: ARRAY
71210: PUSH
71211: LD_VAR 0 6
71215: AND
71216: IFFALSE 71459
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71218: LD_EXP 75
71222: PUSH
71223: LD_VAR 0 2
71227: ARRAY
71228: PUSH
71229: LD_VAR 0 6
71233: PUSH
71234: LD_INT 1
71236: ARRAY
71237: LESS
71238: IFFALSE 71258
// tmp := mc_crates_collector [ i ] else
71240: LD_ADDR_VAR 0 5
71244: PUSH
71245: LD_EXP 75
71249: PUSH
71250: LD_VAR 0 2
71254: ARRAY
71255: ST_TO_ADDR
71256: GO 71272
// tmp := target [ 1 ] ;
71258: LD_ADDR_VAR 0 5
71262: PUSH
71263: LD_VAR 0 6
71267: PUSH
71268: LD_INT 1
71270: ARRAY
71271: ST_TO_ADDR
// k := 0 ;
71272: LD_ADDR_VAR 0 4
71276: PUSH
71277: LD_INT 0
71279: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71280: LD_ADDR_VAR 0 3
71284: PUSH
71285: LD_EXP 75
71289: PUSH
71290: LD_VAR 0 2
71294: ARRAY
71295: PUSH
71296: FOR_IN
71297: IFFALSE 71457
// begin k := k + 1 ;
71299: LD_ADDR_VAR 0 4
71303: PUSH
71304: LD_VAR 0 4
71308: PUSH
71309: LD_INT 1
71311: PLUS
71312: ST_TO_ADDR
// if k > tmp then
71313: LD_VAR 0 4
71317: PUSH
71318: LD_VAR 0 5
71322: GREATER
71323: IFFALSE 71327
// break ;
71325: GO 71457
// if not GetClass ( j ) in [ 2 , 16 ] then
71327: LD_VAR 0 3
71331: PPUSH
71332: CALL_OW 257
71336: PUSH
71337: LD_INT 2
71339: PUSH
71340: LD_INT 16
71342: PUSH
71343: EMPTY
71344: LIST
71345: LIST
71346: IN
71347: NOT
71348: IFFALSE 71401
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71350: LD_ADDR_EXP 75
71354: PUSH
71355: LD_EXP 75
71359: PPUSH
71360: LD_VAR 0 2
71364: PPUSH
71365: LD_EXP 75
71369: PUSH
71370: LD_VAR 0 2
71374: ARRAY
71375: PUSH
71376: LD_VAR 0 3
71380: DIFF
71381: PPUSH
71382: CALL_OW 1
71386: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71387: LD_VAR 0 3
71391: PPUSH
71392: LD_INT 0
71394: PPUSH
71395: CALL_OW 109
// continue ;
71399: GO 71296
// end ; if IsInUnit ( j ) then
71401: LD_VAR 0 3
71405: PPUSH
71406: CALL_OW 310
71410: IFFALSE 71421
// ComExitBuilding ( j ) ;
71412: LD_VAR 0 3
71416: PPUSH
71417: CALL_OW 122
// wait ( 3 ) ;
71421: LD_INT 3
71423: PPUSH
71424: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71428: LD_VAR 0 3
71432: PPUSH
71433: LD_VAR 0 6
71437: PUSH
71438: LD_INT 2
71440: ARRAY
71441: PPUSH
71442: LD_VAR 0 6
71446: PUSH
71447: LD_INT 3
71449: ARRAY
71450: PPUSH
71451: CALL_OW 117
// end ;
71455: GO 71296
71457: POP
71458: POP
// end ; end else
71459: GO 72040
// begin for j in cargo do
71461: LD_ADDR_VAR 0 3
71465: PUSH
71466: LD_VAR 0 7
71470: PUSH
71471: FOR_IN
71472: IFFALSE 72038
// begin if GetTag ( j ) <> 0 then
71474: LD_VAR 0 3
71478: PPUSH
71479: CALL_OW 110
71483: PUSH
71484: LD_INT 0
71486: NONEQUAL
71487: IFFALSE 71491
// continue ;
71489: GO 71471
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71491: LD_VAR 0 3
71495: PPUSH
71496: CALL_OW 256
71500: PUSH
71501: LD_INT 1000
71503: LESS
71504: PUSH
71505: LD_VAR 0 3
71509: PPUSH
71510: LD_EXP 82
71514: PUSH
71515: LD_VAR 0 2
71519: ARRAY
71520: PPUSH
71521: CALL_OW 308
71525: NOT
71526: AND
71527: IFFALSE 71549
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71529: LD_VAR 0 3
71533: PPUSH
71534: LD_EXP 82
71538: PUSH
71539: LD_VAR 0 2
71543: ARRAY
71544: PPUSH
71545: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71549: LD_VAR 0 3
71553: PPUSH
71554: CALL_OW 256
71558: PUSH
71559: LD_INT 1000
71561: LESS
71562: PUSH
71563: LD_VAR 0 3
71567: PPUSH
71568: LD_EXP 82
71572: PUSH
71573: LD_VAR 0 2
71577: ARRAY
71578: PPUSH
71579: CALL_OW 308
71583: AND
71584: IFFALSE 71588
// continue ;
71586: GO 71471
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71588: LD_VAR 0 3
71592: PPUSH
71593: CALL_OW 262
71597: PUSH
71598: LD_INT 2
71600: EQUAL
71601: PUSH
71602: LD_VAR 0 3
71606: PPUSH
71607: CALL_OW 261
71611: PUSH
71612: LD_INT 15
71614: LESS
71615: AND
71616: IFFALSE 71620
// continue ;
71618: GO 71471
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71620: LD_VAR 0 3
71624: PPUSH
71625: CALL_OW 262
71629: PUSH
71630: LD_INT 1
71632: EQUAL
71633: PUSH
71634: LD_VAR 0 3
71638: PPUSH
71639: CALL_OW 261
71643: PUSH
71644: LD_INT 10
71646: LESS
71647: AND
71648: IFFALSE 71977
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71650: LD_ADDR_VAR 0 8
71654: PUSH
71655: LD_EXP 58
71659: PUSH
71660: LD_VAR 0 2
71664: ARRAY
71665: PPUSH
71666: LD_INT 2
71668: PUSH
71669: LD_INT 30
71671: PUSH
71672: LD_INT 0
71674: PUSH
71675: EMPTY
71676: LIST
71677: LIST
71678: PUSH
71679: LD_INT 30
71681: PUSH
71682: LD_INT 1
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: LIST
71693: PPUSH
71694: CALL_OW 72
71698: ST_TO_ADDR
// if not depot then
71699: LD_VAR 0 8
71703: NOT
71704: IFFALSE 71708
// continue ;
71706: GO 71471
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71708: LD_VAR 0 3
71712: PPUSH
71713: LD_VAR 0 8
71717: PPUSH
71718: LD_VAR 0 3
71722: PPUSH
71723: CALL_OW 74
71727: PPUSH
71728: CALL_OW 296
71732: PUSH
71733: LD_INT 6
71735: LESS
71736: IFFALSE 71752
// SetFuel ( j , 100 ) else
71738: LD_VAR 0 3
71742: PPUSH
71743: LD_INT 100
71745: PPUSH
71746: CALL_OW 240
71750: GO 71977
// if GetFuel ( j ) = 0 then
71752: LD_VAR 0 3
71756: PPUSH
71757: CALL_OW 261
71761: PUSH
71762: LD_INT 0
71764: EQUAL
71765: IFFALSE 71977
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71767: LD_ADDR_EXP 77
71771: PUSH
71772: LD_EXP 77
71776: PPUSH
71777: LD_VAR 0 2
71781: PPUSH
71782: LD_EXP 77
71786: PUSH
71787: LD_VAR 0 2
71791: ARRAY
71792: PUSH
71793: LD_VAR 0 3
71797: DIFF
71798: PPUSH
71799: CALL_OW 1
71803: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71804: LD_VAR 0 3
71808: PPUSH
71809: CALL_OW 263
71813: PUSH
71814: LD_INT 1
71816: EQUAL
71817: IFFALSE 71833
// ComExitVehicle ( IsInUnit ( j ) ) ;
71819: LD_VAR 0 3
71823: PPUSH
71824: CALL_OW 310
71828: PPUSH
71829: CALL_OW 121
// if GetControl ( j ) = control_remote then
71833: LD_VAR 0 3
71837: PPUSH
71838: CALL_OW 263
71842: PUSH
71843: LD_INT 2
71845: EQUAL
71846: IFFALSE 71857
// ComUnlink ( j ) ;
71848: LD_VAR 0 3
71852: PPUSH
71853: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
71857: LD_ADDR_VAR 0 9
71861: PUSH
71862: LD_VAR 0 2
71866: PPUSH
71867: LD_INT 3
71869: PPUSH
71870: CALL 81114 0 2
71874: ST_TO_ADDR
// if fac then
71875: LD_VAR 0 9
71879: IFFALSE 71975
// begin for k in fac do
71881: LD_ADDR_VAR 0 4
71885: PUSH
71886: LD_VAR 0 9
71890: PUSH
71891: FOR_IN
71892: IFFALSE 71973
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
71894: LD_ADDR_VAR 0 10
71898: PUSH
71899: LD_VAR 0 9
71903: PPUSH
71904: LD_VAR 0 3
71908: PPUSH
71909: CALL_OW 265
71913: PPUSH
71914: LD_VAR 0 3
71918: PPUSH
71919: CALL_OW 262
71923: PPUSH
71924: LD_VAR 0 3
71928: PPUSH
71929: CALL_OW 263
71933: PPUSH
71934: LD_VAR 0 3
71938: PPUSH
71939: CALL_OW 264
71943: PPUSH
71944: CALL 18683 0 5
71948: ST_TO_ADDR
// if components then
71949: LD_VAR 0 10
71953: IFFALSE 71971
// begin MC_InsertProduceList ( i , components ) ;
71955: LD_VAR 0 2
71959: PPUSH
71960: LD_VAR 0 10
71964: PPUSH
71965: CALL 80659 0 2
// break ;
71969: GO 71973
// end ; end ;
71971: GO 71891
71973: POP
71974: POP
// end ; continue ;
71975: GO 71471
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71977: LD_VAR 0 3
71981: PPUSH
71982: LD_INT 1
71984: PPUSH
71985: CALL_OW 289
71989: PUSH
71990: LD_INT 100
71992: LESS
71993: PUSH
71994: LD_VAR 0 3
71998: PPUSH
71999: CALL_OW 314
72003: NOT
72004: AND
72005: IFFALSE 72034
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72007: LD_VAR 0 3
72011: PPUSH
72012: LD_VAR 0 6
72016: PUSH
72017: LD_INT 2
72019: ARRAY
72020: PPUSH
72021: LD_VAR 0 6
72025: PUSH
72026: LD_INT 3
72028: ARRAY
72029: PPUSH
72030: CALL_OW 117
// break ;
72034: GO 72038
// end ;
72036: GO 71471
72038: POP
72039: POP
// end ; end ;
72040: GO 70309
72042: POP
72043: POP
// end ;
72044: LD_VAR 0 1
72048: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72049: LD_INT 0
72051: PPUSH
72052: PPUSH
72053: PPUSH
72054: PPUSH
// if not mc_bases then
72055: LD_EXP 58
72059: NOT
72060: IFFALSE 72064
// exit ;
72062: GO 72225
// for i = 1 to mc_bases do
72064: LD_ADDR_VAR 0 2
72068: PUSH
72069: DOUBLE
72070: LD_INT 1
72072: DEC
72073: ST_TO_ADDR
72074: LD_EXP 58
72078: PUSH
72079: FOR_TO
72080: IFFALSE 72223
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72082: LD_ADDR_VAR 0 4
72086: PUSH
72087: LD_EXP 77
72091: PUSH
72092: LD_VAR 0 2
72096: ARRAY
72097: PUSH
72098: LD_EXP 80
72102: PUSH
72103: LD_VAR 0 2
72107: ARRAY
72108: UNION
72109: PPUSH
72110: LD_INT 33
72112: PUSH
72113: LD_INT 2
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PPUSH
72120: CALL_OW 72
72124: ST_TO_ADDR
// if tmp then
72125: LD_VAR 0 4
72129: IFFALSE 72221
// for j in tmp do
72131: LD_ADDR_VAR 0 3
72135: PUSH
72136: LD_VAR 0 4
72140: PUSH
72141: FOR_IN
72142: IFFALSE 72219
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72144: LD_VAR 0 3
72148: PPUSH
72149: CALL_OW 312
72153: NOT
72154: PUSH
72155: LD_VAR 0 3
72159: PPUSH
72160: CALL_OW 256
72164: PUSH
72165: LD_INT 250
72167: GREATEREQUAL
72168: AND
72169: IFFALSE 72182
// Connect ( j ) else
72171: LD_VAR 0 3
72175: PPUSH
72176: CALL 24084 0 1
72180: GO 72217
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72182: LD_VAR 0 3
72186: PPUSH
72187: CALL_OW 256
72191: PUSH
72192: LD_INT 250
72194: LESS
72195: PUSH
72196: LD_VAR 0 3
72200: PPUSH
72201: CALL_OW 312
72205: AND
72206: IFFALSE 72217
// ComUnlink ( j ) ;
72208: LD_VAR 0 3
72212: PPUSH
72213: CALL_OW 136
72217: GO 72141
72219: POP
72220: POP
// end ;
72221: GO 72079
72223: POP
72224: POP
// end ;
72225: LD_VAR 0 1
72229: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72230: LD_INT 0
72232: PPUSH
72233: PPUSH
72234: PPUSH
72235: PPUSH
72236: PPUSH
// if not mc_bases then
72237: LD_EXP 58
72241: NOT
72242: IFFALSE 72246
// exit ;
72244: GO 72691
// for i = 1 to mc_bases do
72246: LD_ADDR_VAR 0 2
72250: PUSH
72251: DOUBLE
72252: LD_INT 1
72254: DEC
72255: ST_TO_ADDR
72256: LD_EXP 58
72260: PUSH
72261: FOR_TO
72262: IFFALSE 72689
// begin if not mc_produce [ i ] then
72264: LD_EXP 79
72268: PUSH
72269: LD_VAR 0 2
72273: ARRAY
72274: NOT
72275: IFFALSE 72279
// continue ;
72277: GO 72261
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72279: LD_ADDR_VAR 0 5
72283: PUSH
72284: LD_EXP 58
72288: PUSH
72289: LD_VAR 0 2
72293: ARRAY
72294: PPUSH
72295: LD_INT 30
72297: PUSH
72298: LD_INT 3
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PPUSH
72305: CALL_OW 72
72309: ST_TO_ADDR
// if not fac then
72310: LD_VAR 0 5
72314: NOT
72315: IFFALSE 72319
// continue ;
72317: GO 72261
// for j in fac do
72319: LD_ADDR_VAR 0 3
72323: PUSH
72324: LD_VAR 0 5
72328: PUSH
72329: FOR_IN
72330: IFFALSE 72685
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72332: LD_VAR 0 3
72336: PPUSH
72337: CALL_OW 461
72341: PUSH
72342: LD_INT 2
72344: NONEQUAL
72345: PUSH
72346: LD_VAR 0 3
72350: PPUSH
72351: LD_INT 15
72353: PPUSH
72354: CALL 23744 0 2
72358: PUSH
72359: LD_INT 4
72361: ARRAY
72362: OR
72363: IFFALSE 72367
// continue ;
72365: GO 72329
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72367: LD_VAR 0 3
72371: PPUSH
72372: LD_EXP 79
72376: PUSH
72377: LD_VAR 0 2
72381: ARRAY
72382: PUSH
72383: LD_INT 1
72385: ARRAY
72386: PUSH
72387: LD_INT 1
72389: ARRAY
72390: PPUSH
72391: LD_EXP 79
72395: PUSH
72396: LD_VAR 0 2
72400: ARRAY
72401: PUSH
72402: LD_INT 1
72404: ARRAY
72405: PUSH
72406: LD_INT 2
72408: ARRAY
72409: PPUSH
72410: LD_EXP 79
72414: PUSH
72415: LD_VAR 0 2
72419: ARRAY
72420: PUSH
72421: LD_INT 1
72423: ARRAY
72424: PUSH
72425: LD_INT 3
72427: ARRAY
72428: PPUSH
72429: LD_EXP 79
72433: PUSH
72434: LD_VAR 0 2
72438: ARRAY
72439: PUSH
72440: LD_INT 1
72442: ARRAY
72443: PUSH
72444: LD_INT 4
72446: ARRAY
72447: PPUSH
72448: CALL_OW 448
72452: PUSH
72453: LD_VAR 0 3
72457: PPUSH
72458: LD_EXP 79
72462: PUSH
72463: LD_VAR 0 2
72467: ARRAY
72468: PUSH
72469: LD_INT 1
72471: ARRAY
72472: PUSH
72473: LD_INT 1
72475: ARRAY
72476: PUSH
72477: LD_EXP 79
72481: PUSH
72482: LD_VAR 0 2
72486: ARRAY
72487: PUSH
72488: LD_INT 1
72490: ARRAY
72491: PUSH
72492: LD_INT 2
72494: ARRAY
72495: PUSH
72496: LD_EXP 79
72500: PUSH
72501: LD_VAR 0 2
72505: ARRAY
72506: PUSH
72507: LD_INT 1
72509: ARRAY
72510: PUSH
72511: LD_INT 3
72513: ARRAY
72514: PUSH
72515: LD_EXP 79
72519: PUSH
72520: LD_VAR 0 2
72524: ARRAY
72525: PUSH
72526: LD_INT 1
72528: ARRAY
72529: PUSH
72530: LD_INT 4
72532: ARRAY
72533: PUSH
72534: EMPTY
72535: LIST
72536: LIST
72537: LIST
72538: LIST
72539: PPUSH
72540: CALL 27415 0 2
72544: AND
72545: IFFALSE 72683
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72547: LD_VAR 0 3
72551: PPUSH
72552: LD_EXP 79
72556: PUSH
72557: LD_VAR 0 2
72561: ARRAY
72562: PUSH
72563: LD_INT 1
72565: ARRAY
72566: PUSH
72567: LD_INT 1
72569: ARRAY
72570: PPUSH
72571: LD_EXP 79
72575: PUSH
72576: LD_VAR 0 2
72580: ARRAY
72581: PUSH
72582: LD_INT 1
72584: ARRAY
72585: PUSH
72586: LD_INT 2
72588: ARRAY
72589: PPUSH
72590: LD_EXP 79
72594: PUSH
72595: LD_VAR 0 2
72599: ARRAY
72600: PUSH
72601: LD_INT 1
72603: ARRAY
72604: PUSH
72605: LD_INT 3
72607: ARRAY
72608: PPUSH
72609: LD_EXP 79
72613: PUSH
72614: LD_VAR 0 2
72618: ARRAY
72619: PUSH
72620: LD_INT 1
72622: ARRAY
72623: PUSH
72624: LD_INT 4
72626: ARRAY
72627: PPUSH
72628: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72632: LD_ADDR_VAR 0 4
72636: PUSH
72637: LD_EXP 79
72641: PUSH
72642: LD_VAR 0 2
72646: ARRAY
72647: PPUSH
72648: LD_INT 1
72650: PPUSH
72651: CALL_OW 3
72655: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72656: LD_ADDR_EXP 79
72660: PUSH
72661: LD_EXP 79
72665: PPUSH
72666: LD_VAR 0 2
72670: PPUSH
72671: LD_VAR 0 4
72675: PPUSH
72676: CALL_OW 1
72680: ST_TO_ADDR
// break ;
72681: GO 72685
// end ; end ;
72683: GO 72329
72685: POP
72686: POP
// end ;
72687: GO 72261
72689: POP
72690: POP
// end ;
72691: LD_VAR 0 1
72695: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72696: LD_INT 0
72698: PPUSH
72699: PPUSH
72700: PPUSH
// if not mc_bases then
72701: LD_EXP 58
72705: NOT
72706: IFFALSE 72710
// exit ;
72708: GO 72799
// for i = 1 to mc_bases do
72710: LD_ADDR_VAR 0 2
72714: PUSH
72715: DOUBLE
72716: LD_INT 1
72718: DEC
72719: ST_TO_ADDR
72720: LD_EXP 58
72724: PUSH
72725: FOR_TO
72726: IFFALSE 72797
// begin if mc_attack [ i ] then
72728: LD_EXP 78
72732: PUSH
72733: LD_VAR 0 2
72737: ARRAY
72738: IFFALSE 72795
// begin tmp := mc_attack [ i ] [ 1 ] ;
72740: LD_ADDR_VAR 0 3
72744: PUSH
72745: LD_EXP 78
72749: PUSH
72750: LD_VAR 0 2
72754: ARRAY
72755: PUSH
72756: LD_INT 1
72758: ARRAY
72759: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72760: LD_ADDR_EXP 78
72764: PUSH
72765: LD_EXP 78
72769: PPUSH
72770: LD_VAR 0 2
72774: PPUSH
72775: EMPTY
72776: PPUSH
72777: CALL_OW 1
72781: ST_TO_ADDR
// Attack ( tmp ) ;
72782: LD_VAR 0 3
72786: PPUSH
72787: CALL 49628 0 1
// exit ;
72791: POP
72792: POP
72793: GO 72799
// end ; end ;
72795: GO 72725
72797: POP
72798: POP
// end ;
72799: LD_VAR 0 1
72803: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72804: LD_INT 0
72806: PPUSH
72807: PPUSH
72808: PPUSH
72809: PPUSH
72810: PPUSH
72811: PPUSH
72812: PPUSH
// if not mc_bases then
72813: LD_EXP 58
72817: NOT
72818: IFFALSE 72822
// exit ;
72820: GO 73404
// for i = 1 to mc_bases do
72822: LD_ADDR_VAR 0 2
72826: PUSH
72827: DOUBLE
72828: LD_INT 1
72830: DEC
72831: ST_TO_ADDR
72832: LD_EXP 58
72836: PUSH
72837: FOR_TO
72838: IFFALSE 73402
// begin if not mc_bases [ i ] then
72840: LD_EXP 58
72844: PUSH
72845: LD_VAR 0 2
72849: ARRAY
72850: NOT
72851: IFFALSE 72855
// continue ;
72853: GO 72837
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
72855: LD_ADDR_VAR 0 7
72859: PUSH
72860: LD_EXP 58
72864: PUSH
72865: LD_VAR 0 2
72869: ARRAY
72870: PUSH
72871: LD_INT 1
72873: ARRAY
72874: PPUSH
72875: CALL 17987 0 1
72879: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
72880: LD_ADDR_EXP 81
72884: PUSH
72885: LD_EXP 81
72889: PPUSH
72890: LD_VAR 0 2
72894: PPUSH
72895: LD_EXP 58
72899: PUSH
72900: LD_VAR 0 2
72904: ARRAY
72905: PUSH
72906: LD_INT 1
72908: ARRAY
72909: PPUSH
72910: CALL_OW 255
72914: PPUSH
72915: LD_EXP 83
72919: PUSH
72920: LD_VAR 0 2
72924: ARRAY
72925: PPUSH
72926: CALL 15690 0 2
72930: PPUSH
72931: CALL_OW 1
72935: ST_TO_ADDR
// if not mc_scan [ i ] then
72936: LD_EXP 81
72940: PUSH
72941: LD_VAR 0 2
72945: ARRAY
72946: NOT
72947: IFFALSE 73102
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72949: LD_ADDR_VAR 0 4
72953: PUSH
72954: LD_EXP 58
72958: PUSH
72959: LD_VAR 0 2
72963: ARRAY
72964: PPUSH
72965: LD_INT 2
72967: PUSH
72968: LD_INT 25
72970: PUSH
72971: LD_INT 5
72973: PUSH
72974: EMPTY
72975: LIST
72976: LIST
72977: PUSH
72978: LD_INT 25
72980: PUSH
72981: LD_INT 8
72983: PUSH
72984: EMPTY
72985: LIST
72986: LIST
72987: PUSH
72988: LD_INT 25
72990: PUSH
72991: LD_INT 9
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: PPUSH
73004: CALL_OW 72
73008: ST_TO_ADDR
// if not tmp then
73009: LD_VAR 0 4
73013: NOT
73014: IFFALSE 73018
// continue ;
73016: GO 72837
// for j in tmp do
73018: LD_ADDR_VAR 0 3
73022: PUSH
73023: LD_VAR 0 4
73027: PUSH
73028: FOR_IN
73029: IFFALSE 73100
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73031: LD_VAR 0 3
73035: PPUSH
73036: CALL_OW 310
73040: PPUSH
73041: CALL_OW 266
73045: PUSH
73046: LD_INT 5
73048: EQUAL
73049: PUSH
73050: LD_VAR 0 3
73054: PPUSH
73055: CALL_OW 257
73059: PUSH
73060: LD_INT 1
73062: EQUAL
73063: AND
73064: PUSH
73065: LD_VAR 0 3
73069: PPUSH
73070: CALL_OW 459
73074: NOT
73075: AND
73076: PUSH
73077: LD_VAR 0 7
73081: AND
73082: IFFALSE 73098
// ComChangeProfession ( j , class ) ;
73084: LD_VAR 0 3
73088: PPUSH
73089: LD_VAR 0 7
73093: PPUSH
73094: CALL_OW 123
73098: GO 73028
73100: POP
73101: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73102: LD_EXP 81
73106: PUSH
73107: LD_VAR 0 2
73111: ARRAY
73112: PUSH
73113: LD_EXP 80
73117: PUSH
73118: LD_VAR 0 2
73122: ARRAY
73123: NOT
73124: AND
73125: PUSH
73126: LD_EXP 58
73130: PUSH
73131: LD_VAR 0 2
73135: ARRAY
73136: PPUSH
73137: LD_INT 30
73139: PUSH
73140: LD_INT 32
73142: PUSH
73143: EMPTY
73144: LIST
73145: LIST
73146: PPUSH
73147: CALL_OW 72
73151: NOT
73152: AND
73153: PUSH
73154: LD_EXP 58
73158: PUSH
73159: LD_VAR 0 2
73163: ARRAY
73164: PPUSH
73165: LD_INT 2
73167: PUSH
73168: LD_INT 30
73170: PUSH
73171: LD_INT 4
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: LD_INT 30
73180: PUSH
73181: LD_INT 5
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: LIST
73192: PPUSH
73193: CALL_OW 72
73197: NOT
73198: AND
73199: IFFALSE 73331
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73201: LD_ADDR_VAR 0 4
73205: PUSH
73206: LD_EXP 58
73210: PUSH
73211: LD_VAR 0 2
73215: ARRAY
73216: PPUSH
73217: LD_INT 2
73219: PUSH
73220: LD_INT 25
73222: PUSH
73223: LD_INT 1
73225: PUSH
73226: EMPTY
73227: LIST
73228: LIST
73229: PUSH
73230: LD_INT 25
73232: PUSH
73233: LD_INT 5
73235: PUSH
73236: EMPTY
73237: LIST
73238: LIST
73239: PUSH
73240: LD_INT 25
73242: PUSH
73243: LD_INT 8
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: PUSH
73250: LD_INT 25
73252: PUSH
73253: LD_INT 9
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: LIST
73264: LIST
73265: LIST
73266: PPUSH
73267: CALL_OW 72
73271: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73272: LD_ADDR_VAR 0 4
73276: PUSH
73277: LD_VAR 0 4
73281: PUSH
73282: LD_VAR 0 4
73286: PPUSH
73287: LD_INT 18
73289: PPUSH
73290: CALL 54411 0 2
73294: DIFF
73295: ST_TO_ADDR
// if tmp then
73296: LD_VAR 0 4
73300: IFFALSE 73331
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
73302: LD_VAR 0 2
73306: PPUSH
73307: LD_VAR 0 4
73311: PPUSH
73312: LD_EXP 83
73316: PUSH
73317: LD_VAR 0 2
73321: ARRAY
73322: PPUSH
73323: CALL 15725 0 3
// exit ;
73327: POP
73328: POP
73329: GO 73404
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73331: LD_EXP 81
73335: PUSH
73336: LD_VAR 0 2
73340: ARRAY
73341: PUSH
73342: LD_EXP 80
73346: PUSH
73347: LD_VAR 0 2
73351: ARRAY
73352: AND
73353: IFFALSE 73400
// begin tmp := mc_defender [ i ] ;
73355: LD_ADDR_VAR 0 4
73359: PUSH
73360: LD_EXP 80
73364: PUSH
73365: LD_VAR 0 2
73369: ARRAY
73370: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73371: LD_VAR 0 2
73375: PPUSH
73376: LD_VAR 0 4
73380: PPUSH
73381: LD_EXP 81
73385: PUSH
73386: LD_VAR 0 2
73390: ARRAY
73391: PPUSH
73392: CALL 16286 0 3
// exit ;
73396: POP
73397: POP
73398: GO 73404
// end ; end ;
73400: GO 72837
73402: POP
73403: POP
// end ;
73404: LD_VAR 0 1
73408: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73409: LD_INT 0
73411: PPUSH
73412: PPUSH
73413: PPUSH
73414: PPUSH
73415: PPUSH
73416: PPUSH
73417: PPUSH
73418: PPUSH
73419: PPUSH
73420: PPUSH
73421: PPUSH
// if not mc_bases then
73422: LD_EXP 58
73426: NOT
73427: IFFALSE 73431
// exit ;
73429: GO 74518
// for i = 1 to mc_bases do
73431: LD_ADDR_VAR 0 2
73435: PUSH
73436: DOUBLE
73437: LD_INT 1
73439: DEC
73440: ST_TO_ADDR
73441: LD_EXP 58
73445: PUSH
73446: FOR_TO
73447: IFFALSE 74516
// begin tmp := mc_lab [ i ] ;
73449: LD_ADDR_VAR 0 6
73453: PUSH
73454: LD_EXP 91
73458: PUSH
73459: LD_VAR 0 2
73463: ARRAY
73464: ST_TO_ADDR
// if not tmp then
73465: LD_VAR 0 6
73469: NOT
73470: IFFALSE 73474
// continue ;
73472: GO 73446
// idle_lab := 0 ;
73474: LD_ADDR_VAR 0 11
73478: PUSH
73479: LD_INT 0
73481: ST_TO_ADDR
// for j in tmp do
73482: LD_ADDR_VAR 0 3
73486: PUSH
73487: LD_VAR 0 6
73491: PUSH
73492: FOR_IN
73493: IFFALSE 74512
// begin researching := false ;
73495: LD_ADDR_VAR 0 10
73499: PUSH
73500: LD_INT 0
73502: ST_TO_ADDR
// side := GetSide ( j ) ;
73503: LD_ADDR_VAR 0 4
73507: PUSH
73508: LD_VAR 0 3
73512: PPUSH
73513: CALL_OW 255
73517: ST_TO_ADDR
// if not mc_tech [ side ] then
73518: LD_EXP 85
73522: PUSH
73523: LD_VAR 0 4
73527: ARRAY
73528: NOT
73529: IFFALSE 73533
// continue ;
73531: GO 73492
// if BuildingStatus ( j ) = bs_idle then
73533: LD_VAR 0 3
73537: PPUSH
73538: CALL_OW 461
73542: PUSH
73543: LD_INT 2
73545: EQUAL
73546: IFFALSE 73734
// begin if idle_lab and UnitsInside ( j ) < 6 then
73548: LD_VAR 0 11
73552: PUSH
73553: LD_VAR 0 3
73557: PPUSH
73558: CALL_OW 313
73562: PUSH
73563: LD_INT 6
73565: LESS
73566: AND
73567: IFFALSE 73638
// begin tmp2 := UnitsInside ( idle_lab ) ;
73569: LD_ADDR_VAR 0 9
73573: PUSH
73574: LD_VAR 0 11
73578: PPUSH
73579: CALL_OW 313
73583: ST_TO_ADDR
// if tmp2 then
73584: LD_VAR 0 9
73588: IFFALSE 73630
// for x in tmp2 do
73590: LD_ADDR_VAR 0 7
73594: PUSH
73595: LD_VAR 0 9
73599: PUSH
73600: FOR_IN
73601: IFFALSE 73628
// begin ComExitBuilding ( x ) ;
73603: LD_VAR 0 7
73607: PPUSH
73608: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73612: LD_VAR 0 7
73616: PPUSH
73617: LD_VAR 0 3
73621: PPUSH
73622: CALL_OW 180
// end ;
73626: GO 73600
73628: POP
73629: POP
// idle_lab := 0 ;
73630: LD_ADDR_VAR 0 11
73634: PUSH
73635: LD_INT 0
73637: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73638: LD_ADDR_VAR 0 5
73642: PUSH
73643: LD_EXP 85
73647: PUSH
73648: LD_VAR 0 4
73652: ARRAY
73653: PUSH
73654: FOR_IN
73655: IFFALSE 73715
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73657: LD_VAR 0 3
73661: PPUSH
73662: LD_VAR 0 5
73666: PPUSH
73667: CALL_OW 430
73671: PUSH
73672: LD_VAR 0 4
73676: PPUSH
73677: LD_VAR 0 5
73681: PPUSH
73682: CALL 14795 0 2
73686: AND
73687: IFFALSE 73713
// begin researching := true ;
73689: LD_ADDR_VAR 0 10
73693: PUSH
73694: LD_INT 1
73696: ST_TO_ADDR
// ComResearch ( j , t ) ;
73697: LD_VAR 0 3
73701: PPUSH
73702: LD_VAR 0 5
73706: PPUSH
73707: CALL_OW 124
// break ;
73711: GO 73715
// end ;
73713: GO 73654
73715: POP
73716: POP
// if not researching then
73717: LD_VAR 0 10
73721: NOT
73722: IFFALSE 73734
// idle_lab := j ;
73724: LD_ADDR_VAR 0 11
73728: PUSH
73729: LD_VAR 0 3
73733: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73734: LD_VAR 0 3
73738: PPUSH
73739: CALL_OW 461
73743: PUSH
73744: LD_INT 10
73746: EQUAL
73747: IFFALSE 74335
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73749: LD_EXP 87
73753: PUSH
73754: LD_VAR 0 2
73758: ARRAY
73759: NOT
73760: PUSH
73761: LD_EXP 88
73765: PUSH
73766: LD_VAR 0 2
73770: ARRAY
73771: NOT
73772: AND
73773: PUSH
73774: LD_EXP 85
73778: PUSH
73779: LD_VAR 0 4
73783: ARRAY
73784: PUSH
73785: LD_INT 1
73787: GREATER
73788: AND
73789: IFFALSE 73920
// begin ComCancel ( j ) ;
73791: LD_VAR 0 3
73795: PPUSH
73796: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
73800: LD_ADDR_EXP 85
73804: PUSH
73805: LD_EXP 85
73809: PPUSH
73810: LD_VAR 0 4
73814: PPUSH
73815: LD_EXP 85
73819: PUSH
73820: LD_VAR 0 4
73824: ARRAY
73825: PPUSH
73826: LD_EXP 85
73830: PUSH
73831: LD_VAR 0 4
73835: ARRAY
73836: PUSH
73837: LD_INT 1
73839: MINUS
73840: PPUSH
73841: LD_EXP 85
73845: PUSH
73846: LD_VAR 0 4
73850: ARRAY
73851: PPUSH
73852: LD_INT 0
73854: PPUSH
73855: CALL 20569 0 4
73859: PPUSH
73860: CALL_OW 1
73864: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
73865: LD_ADDR_EXP 85
73869: PUSH
73870: LD_EXP 85
73874: PPUSH
73875: LD_VAR 0 4
73879: PPUSH
73880: LD_EXP 85
73884: PUSH
73885: LD_VAR 0 4
73889: ARRAY
73890: PPUSH
73891: LD_EXP 85
73895: PUSH
73896: LD_VAR 0 4
73900: ARRAY
73901: PPUSH
73902: LD_INT 1
73904: PPUSH
73905: LD_INT 0
73907: PPUSH
73908: CALL 20569 0 4
73912: PPUSH
73913: CALL_OW 1
73917: ST_TO_ADDR
// continue ;
73918: GO 73492
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73920: LD_EXP 87
73924: PUSH
73925: LD_VAR 0 2
73929: ARRAY
73930: PUSH
73931: LD_EXP 88
73935: PUSH
73936: LD_VAR 0 2
73940: ARRAY
73941: NOT
73942: AND
73943: IFFALSE 74070
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73945: LD_ADDR_EXP 88
73949: PUSH
73950: LD_EXP 88
73954: PPUSH
73955: LD_VAR 0 2
73959: PUSH
73960: LD_EXP 88
73964: PUSH
73965: LD_VAR 0 2
73969: ARRAY
73970: PUSH
73971: LD_INT 1
73973: PLUS
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: PPUSH
73979: LD_EXP 87
73983: PUSH
73984: LD_VAR 0 2
73988: ARRAY
73989: PUSH
73990: LD_INT 1
73992: ARRAY
73993: PPUSH
73994: CALL 21151 0 3
73998: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73999: LD_EXP 87
74003: PUSH
74004: LD_VAR 0 2
74008: ARRAY
74009: PUSH
74010: LD_INT 1
74012: ARRAY
74013: PPUSH
74014: LD_INT 112
74016: PPUSH
74017: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74021: LD_ADDR_VAR 0 9
74025: PUSH
74026: LD_EXP 87
74030: PUSH
74031: LD_VAR 0 2
74035: ARRAY
74036: PPUSH
74037: LD_INT 1
74039: PPUSH
74040: CALL_OW 3
74044: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74045: LD_ADDR_EXP 87
74049: PUSH
74050: LD_EXP 87
74054: PPUSH
74055: LD_VAR 0 2
74059: PPUSH
74060: LD_VAR 0 9
74064: PPUSH
74065: CALL_OW 1
74069: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74070: LD_EXP 87
74074: PUSH
74075: LD_VAR 0 2
74079: ARRAY
74080: PUSH
74081: LD_EXP 88
74085: PUSH
74086: LD_VAR 0 2
74090: ARRAY
74091: AND
74092: PUSH
74093: LD_EXP 88
74097: PUSH
74098: LD_VAR 0 2
74102: ARRAY
74103: PUSH
74104: LD_INT 1
74106: ARRAY
74107: PPUSH
74108: CALL_OW 310
74112: NOT
74113: AND
74114: PUSH
74115: LD_VAR 0 3
74119: PPUSH
74120: CALL_OW 313
74124: PUSH
74125: LD_INT 6
74127: EQUAL
74128: AND
74129: IFFALSE 74185
// begin tmp2 := UnitsInside ( j ) ;
74131: LD_ADDR_VAR 0 9
74135: PUSH
74136: LD_VAR 0 3
74140: PPUSH
74141: CALL_OW 313
74145: ST_TO_ADDR
// if tmp2 = 6 then
74146: LD_VAR 0 9
74150: PUSH
74151: LD_INT 6
74153: EQUAL
74154: IFFALSE 74185
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74156: LD_VAR 0 9
74160: PUSH
74161: LD_INT 1
74163: ARRAY
74164: PPUSH
74165: LD_INT 112
74167: PPUSH
74168: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74172: LD_VAR 0 9
74176: PUSH
74177: LD_INT 1
74179: ARRAY
74180: PPUSH
74181: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74185: LD_EXP 88
74189: PUSH
74190: LD_VAR 0 2
74194: ARRAY
74195: PUSH
74196: LD_EXP 88
74200: PUSH
74201: LD_VAR 0 2
74205: ARRAY
74206: PUSH
74207: LD_INT 1
74209: ARRAY
74210: PPUSH
74211: CALL_OW 314
74215: NOT
74216: AND
74217: PUSH
74218: LD_EXP 88
74222: PUSH
74223: LD_VAR 0 2
74227: ARRAY
74228: PUSH
74229: LD_INT 1
74231: ARRAY
74232: PPUSH
74233: CALL_OW 310
74237: NOT
74238: AND
74239: IFFALSE 74265
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74241: LD_EXP 88
74245: PUSH
74246: LD_VAR 0 2
74250: ARRAY
74251: PUSH
74252: LD_INT 1
74254: ARRAY
74255: PPUSH
74256: LD_VAR 0 3
74260: PPUSH
74261: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74265: LD_EXP 88
74269: PUSH
74270: LD_VAR 0 2
74274: ARRAY
74275: PUSH
74276: LD_INT 1
74278: ARRAY
74279: PPUSH
74280: CALL_OW 310
74284: PUSH
74285: LD_EXP 88
74289: PUSH
74290: LD_VAR 0 2
74294: ARRAY
74295: PUSH
74296: LD_INT 1
74298: ARRAY
74299: PPUSH
74300: CALL_OW 310
74304: PPUSH
74305: CALL_OW 461
74309: PUSH
74310: LD_INT 3
74312: NONEQUAL
74313: AND
74314: IFFALSE 74335
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74316: LD_EXP 88
74320: PUSH
74321: LD_VAR 0 2
74325: ARRAY
74326: PUSH
74327: LD_INT 1
74329: ARRAY
74330: PPUSH
74331: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74335: LD_VAR 0 3
74339: PPUSH
74340: CALL_OW 461
74344: PUSH
74345: LD_INT 6
74347: EQUAL
74348: PUSH
74349: LD_VAR 0 6
74353: PUSH
74354: LD_INT 1
74356: GREATER
74357: AND
74358: IFFALSE 74510
// begin sci := [ ] ;
74360: LD_ADDR_VAR 0 8
74364: PUSH
74365: EMPTY
74366: ST_TO_ADDR
// for x in ( tmp diff j ) do
74367: LD_ADDR_VAR 0 7
74371: PUSH
74372: LD_VAR 0 6
74376: PUSH
74377: LD_VAR 0 3
74381: DIFF
74382: PUSH
74383: FOR_IN
74384: IFFALSE 74436
// begin if sci = 6 then
74386: LD_VAR 0 8
74390: PUSH
74391: LD_INT 6
74393: EQUAL
74394: IFFALSE 74398
// break ;
74396: GO 74436
// if BuildingStatus ( x ) = bs_idle then
74398: LD_VAR 0 7
74402: PPUSH
74403: CALL_OW 461
74407: PUSH
74408: LD_INT 2
74410: EQUAL
74411: IFFALSE 74434
// sci := sci ^ UnitsInside ( x ) ;
74413: LD_ADDR_VAR 0 8
74417: PUSH
74418: LD_VAR 0 8
74422: PUSH
74423: LD_VAR 0 7
74427: PPUSH
74428: CALL_OW 313
74432: ADD
74433: ST_TO_ADDR
// end ;
74434: GO 74383
74436: POP
74437: POP
// if not sci then
74438: LD_VAR 0 8
74442: NOT
74443: IFFALSE 74447
// continue ;
74445: GO 73492
// for x in sci do
74447: LD_ADDR_VAR 0 7
74451: PUSH
74452: LD_VAR 0 8
74456: PUSH
74457: FOR_IN
74458: IFFALSE 74508
// if IsInUnit ( x ) and not HasTask ( x ) then
74460: LD_VAR 0 7
74464: PPUSH
74465: CALL_OW 310
74469: PUSH
74470: LD_VAR 0 7
74474: PPUSH
74475: CALL_OW 314
74479: NOT
74480: AND
74481: IFFALSE 74506
// begin ComExitBuilding ( x ) ;
74483: LD_VAR 0 7
74487: PPUSH
74488: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74492: LD_VAR 0 7
74496: PPUSH
74497: LD_VAR 0 3
74501: PPUSH
74502: CALL_OW 180
// end ;
74506: GO 74457
74508: POP
74509: POP
// end ; end ;
74510: GO 73492
74512: POP
74513: POP
// end ;
74514: GO 73446
74516: POP
74517: POP
// end ;
74518: LD_VAR 0 1
74522: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74523: LD_INT 0
74525: PPUSH
74526: PPUSH
// if not mc_bases then
74527: LD_EXP 58
74531: NOT
74532: IFFALSE 74536
// exit ;
74534: GO 74617
// for i = 1 to mc_bases do
74536: LD_ADDR_VAR 0 2
74540: PUSH
74541: DOUBLE
74542: LD_INT 1
74544: DEC
74545: ST_TO_ADDR
74546: LD_EXP 58
74550: PUSH
74551: FOR_TO
74552: IFFALSE 74615
// if mc_mines [ i ] and mc_miners [ i ] then
74554: LD_EXP 71
74558: PUSH
74559: LD_VAR 0 2
74563: ARRAY
74564: PUSH
74565: LD_EXP 72
74569: PUSH
74570: LD_VAR 0 2
74574: ARRAY
74575: AND
74576: IFFALSE 74613
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74578: LD_EXP 72
74582: PUSH
74583: LD_VAR 0 2
74587: ARRAY
74588: PUSH
74589: LD_INT 1
74591: ARRAY
74592: PPUSH
74593: CALL_OW 255
74597: PPUSH
74598: LD_EXP 71
74602: PUSH
74603: LD_VAR 0 2
74607: ARRAY
74608: PPUSH
74609: CALL 18140 0 2
74613: GO 74551
74615: POP
74616: POP
// end ;
74617: LD_VAR 0 1
74621: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74622: LD_INT 0
74624: PPUSH
74625: PPUSH
74626: PPUSH
74627: PPUSH
74628: PPUSH
74629: PPUSH
74630: PPUSH
74631: PPUSH
// if not mc_bases or not mc_parking then
74632: LD_EXP 58
74636: NOT
74637: PUSH
74638: LD_EXP 82
74642: NOT
74643: OR
74644: IFFALSE 74648
// exit ;
74646: GO 75347
// for i = 1 to mc_bases do
74648: LD_ADDR_VAR 0 2
74652: PUSH
74653: DOUBLE
74654: LD_INT 1
74656: DEC
74657: ST_TO_ADDR
74658: LD_EXP 58
74662: PUSH
74663: FOR_TO
74664: IFFALSE 75345
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74666: LD_EXP 58
74670: PUSH
74671: LD_VAR 0 2
74675: ARRAY
74676: NOT
74677: PUSH
74678: LD_EXP 82
74682: PUSH
74683: LD_VAR 0 2
74687: ARRAY
74688: NOT
74689: OR
74690: IFFALSE 74694
// continue ;
74692: GO 74663
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74694: LD_ADDR_VAR 0 5
74698: PUSH
74699: LD_EXP 58
74703: PUSH
74704: LD_VAR 0 2
74708: ARRAY
74709: PUSH
74710: LD_INT 1
74712: ARRAY
74713: PPUSH
74714: CALL_OW 255
74718: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74719: LD_ADDR_VAR 0 6
74723: PUSH
74724: LD_EXP 58
74728: PUSH
74729: LD_VAR 0 2
74733: ARRAY
74734: PPUSH
74735: LD_INT 30
74737: PUSH
74738: LD_INT 3
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PPUSH
74745: CALL_OW 72
74749: ST_TO_ADDR
// if not fac then
74750: LD_VAR 0 6
74754: NOT
74755: IFFALSE 74806
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74757: LD_ADDR_VAR 0 6
74761: PUSH
74762: LD_EXP 58
74766: PUSH
74767: LD_VAR 0 2
74771: ARRAY
74772: PPUSH
74773: LD_INT 2
74775: PUSH
74776: LD_INT 30
74778: PUSH
74779: LD_INT 0
74781: PUSH
74782: EMPTY
74783: LIST
74784: LIST
74785: PUSH
74786: LD_INT 30
74788: PUSH
74789: LD_INT 1
74791: PUSH
74792: EMPTY
74793: LIST
74794: LIST
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: LIST
74800: PPUSH
74801: CALL_OW 72
74805: ST_TO_ADDR
// if not fac then
74806: LD_VAR 0 6
74810: NOT
74811: IFFALSE 74815
// continue ;
74813: GO 74663
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74815: LD_ADDR_VAR 0 7
74819: PUSH
74820: LD_EXP 82
74824: PUSH
74825: LD_VAR 0 2
74829: ARRAY
74830: PPUSH
74831: LD_INT 22
74833: PUSH
74834: LD_VAR 0 5
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: PUSH
74843: LD_INT 21
74845: PUSH
74846: LD_INT 2
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 3
74855: PUSH
74856: LD_INT 24
74858: PUSH
74859: LD_INT 1000
74861: PUSH
74862: EMPTY
74863: LIST
74864: LIST
74865: PUSH
74866: EMPTY
74867: LIST
74868: LIST
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: LIST
74874: PPUSH
74875: CALL_OW 70
74879: ST_TO_ADDR
// for j in fac do
74880: LD_ADDR_VAR 0 3
74884: PUSH
74885: LD_VAR 0 6
74889: PUSH
74890: FOR_IN
74891: IFFALSE 74972
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74893: LD_ADDR_VAR 0 7
74897: PUSH
74898: LD_VAR 0 7
74902: PUSH
74903: LD_INT 22
74905: PUSH
74906: LD_VAR 0 5
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: PUSH
74915: LD_INT 91
74917: PUSH
74918: LD_VAR 0 3
74922: PUSH
74923: LD_INT 15
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: LIST
74930: PUSH
74931: LD_INT 21
74933: PUSH
74934: LD_INT 2
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: PUSH
74941: LD_INT 3
74943: PUSH
74944: LD_INT 24
74946: PUSH
74947: LD_INT 1000
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: LIST
74962: LIST
74963: PPUSH
74964: CALL_OW 69
74968: UNION
74969: ST_TO_ADDR
74970: GO 74890
74972: POP
74973: POP
// if not vehs then
74974: LD_VAR 0 7
74978: NOT
74979: IFFALSE 75005
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74981: LD_ADDR_EXP 70
74985: PUSH
74986: LD_EXP 70
74990: PPUSH
74991: LD_VAR 0 2
74995: PPUSH
74996: EMPTY
74997: PPUSH
74998: CALL_OW 1
75002: ST_TO_ADDR
// continue ;
75003: GO 74663
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75005: LD_ADDR_VAR 0 8
75009: PUSH
75010: LD_EXP 58
75014: PUSH
75015: LD_VAR 0 2
75019: ARRAY
75020: PPUSH
75021: LD_INT 30
75023: PUSH
75024: LD_INT 3
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: PPUSH
75031: CALL_OW 72
75035: ST_TO_ADDR
// if tmp then
75036: LD_VAR 0 8
75040: IFFALSE 75143
// begin for j in tmp do
75042: LD_ADDR_VAR 0 3
75046: PUSH
75047: LD_VAR 0 8
75051: PUSH
75052: FOR_IN
75053: IFFALSE 75141
// for k in UnitsInside ( j ) do
75055: LD_ADDR_VAR 0 4
75059: PUSH
75060: LD_VAR 0 3
75064: PPUSH
75065: CALL_OW 313
75069: PUSH
75070: FOR_IN
75071: IFFALSE 75137
// if k then
75073: LD_VAR 0 4
75077: IFFALSE 75135
// if not k in mc_repair_vehicle [ i ] then
75079: LD_VAR 0 4
75083: PUSH
75084: LD_EXP 70
75088: PUSH
75089: LD_VAR 0 2
75093: ARRAY
75094: IN
75095: NOT
75096: IFFALSE 75135
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75098: LD_ADDR_EXP 70
75102: PUSH
75103: LD_EXP 70
75107: PPUSH
75108: LD_VAR 0 2
75112: PPUSH
75113: LD_EXP 70
75117: PUSH
75118: LD_VAR 0 2
75122: ARRAY
75123: PUSH
75124: LD_VAR 0 4
75128: UNION
75129: PPUSH
75130: CALL_OW 1
75134: ST_TO_ADDR
75135: GO 75070
75137: POP
75138: POP
75139: GO 75052
75141: POP
75142: POP
// end ; if not mc_repair_vehicle [ i ] then
75143: LD_EXP 70
75147: PUSH
75148: LD_VAR 0 2
75152: ARRAY
75153: NOT
75154: IFFALSE 75158
// continue ;
75156: GO 74663
// for j in mc_repair_vehicle [ i ] do
75158: LD_ADDR_VAR 0 3
75162: PUSH
75163: LD_EXP 70
75167: PUSH
75168: LD_VAR 0 2
75172: ARRAY
75173: PUSH
75174: FOR_IN
75175: IFFALSE 75341
// begin if GetClass ( j ) <> 3 then
75177: LD_VAR 0 3
75181: PPUSH
75182: CALL_OW 257
75186: PUSH
75187: LD_INT 3
75189: NONEQUAL
75190: IFFALSE 75231
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75192: LD_ADDR_EXP 70
75196: PUSH
75197: LD_EXP 70
75201: PPUSH
75202: LD_VAR 0 2
75206: PPUSH
75207: LD_EXP 70
75211: PUSH
75212: LD_VAR 0 2
75216: ARRAY
75217: PUSH
75218: LD_VAR 0 3
75222: DIFF
75223: PPUSH
75224: CALL_OW 1
75228: ST_TO_ADDR
// continue ;
75229: GO 75174
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75231: LD_VAR 0 3
75235: PPUSH
75236: CALL_OW 311
75240: NOT
75241: PUSH
75242: LD_VAR 0 3
75246: PUSH
75247: LD_EXP 61
75251: PUSH
75252: LD_VAR 0 2
75256: ARRAY
75257: PUSH
75258: LD_INT 1
75260: ARRAY
75261: IN
75262: NOT
75263: AND
75264: PUSH
75265: LD_VAR 0 3
75269: PUSH
75270: LD_EXP 61
75274: PUSH
75275: LD_VAR 0 2
75279: ARRAY
75280: PUSH
75281: LD_INT 2
75283: ARRAY
75284: IN
75285: NOT
75286: AND
75287: IFFALSE 75339
// begin if IsInUnit ( j ) then
75289: LD_VAR 0 3
75293: PPUSH
75294: CALL_OW 310
75298: IFFALSE 75309
// ComExitBuilding ( j ) ;
75300: LD_VAR 0 3
75304: PPUSH
75305: CALL_OW 122
// if not HasTask ( j ) then
75309: LD_VAR 0 3
75313: PPUSH
75314: CALL_OW 314
75318: NOT
75319: IFFALSE 75339
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75321: LD_VAR 0 3
75325: PPUSH
75326: LD_VAR 0 7
75330: PUSH
75331: LD_INT 1
75333: ARRAY
75334: PPUSH
75335: CALL_OW 189
// end ; end ;
75339: GO 75174
75341: POP
75342: POP
// end ;
75343: GO 74663
75345: POP
75346: POP
// end ;
75347: LD_VAR 0 1
75351: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75352: LD_INT 0
75354: PPUSH
75355: PPUSH
75356: PPUSH
75357: PPUSH
75358: PPUSH
75359: PPUSH
75360: PPUSH
75361: PPUSH
75362: PPUSH
75363: PPUSH
75364: PPUSH
// if not mc_bases then
75365: LD_EXP 58
75369: NOT
75370: IFFALSE 75374
// exit ;
75372: GO 76176
// for i = 1 to mc_bases do
75374: LD_ADDR_VAR 0 2
75378: PUSH
75379: DOUBLE
75380: LD_INT 1
75382: DEC
75383: ST_TO_ADDR
75384: LD_EXP 58
75388: PUSH
75389: FOR_TO
75390: IFFALSE 76174
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75392: LD_EXP 86
75396: PUSH
75397: LD_VAR 0 2
75401: ARRAY
75402: NOT
75403: PUSH
75404: LD_EXP 61
75408: PUSH
75409: LD_VAR 0 2
75413: ARRAY
75414: PUSH
75415: LD_INT 1
75417: ARRAY
75418: OR
75419: PUSH
75420: LD_EXP 61
75424: PUSH
75425: LD_VAR 0 2
75429: ARRAY
75430: PUSH
75431: LD_INT 2
75433: ARRAY
75434: OR
75435: PUSH
75436: LD_EXP 84
75440: PUSH
75441: LD_VAR 0 2
75445: ARRAY
75446: PPUSH
75447: LD_INT 1
75449: PPUSH
75450: CALL_OW 325
75454: NOT
75455: OR
75456: PUSH
75457: LD_EXP 81
75461: PUSH
75462: LD_VAR 0 2
75466: ARRAY
75467: OR
75468: IFFALSE 75472
// continue ;
75470: GO 75389
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75472: LD_ADDR_VAR 0 8
75476: PUSH
75477: LD_EXP 58
75481: PUSH
75482: LD_VAR 0 2
75486: ARRAY
75487: PPUSH
75488: LD_INT 25
75490: PUSH
75491: LD_INT 4
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: PUSH
75498: LD_INT 50
75500: PUSH
75501: EMPTY
75502: LIST
75503: PUSH
75504: LD_INT 3
75506: PUSH
75507: LD_INT 60
75509: PUSH
75510: EMPTY
75511: LIST
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: LIST
75521: PPUSH
75522: CALL_OW 72
75526: PUSH
75527: LD_EXP 62
75531: PUSH
75532: LD_VAR 0 2
75536: ARRAY
75537: DIFF
75538: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75539: LD_ADDR_VAR 0 9
75543: PUSH
75544: LD_EXP 58
75548: PUSH
75549: LD_VAR 0 2
75553: ARRAY
75554: PPUSH
75555: LD_INT 2
75557: PUSH
75558: LD_INT 30
75560: PUSH
75561: LD_INT 0
75563: PUSH
75564: EMPTY
75565: LIST
75566: LIST
75567: PUSH
75568: LD_INT 30
75570: PUSH
75571: LD_INT 1
75573: PUSH
75574: EMPTY
75575: LIST
75576: LIST
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: LIST
75582: PPUSH
75583: CALL_OW 72
75587: ST_TO_ADDR
// if not tmp or not dep then
75588: LD_VAR 0 8
75592: NOT
75593: PUSH
75594: LD_VAR 0 9
75598: NOT
75599: OR
75600: IFFALSE 75604
// continue ;
75602: GO 75389
// side := GetSide ( tmp [ 1 ] ) ;
75604: LD_ADDR_VAR 0 11
75608: PUSH
75609: LD_VAR 0 8
75613: PUSH
75614: LD_INT 1
75616: ARRAY
75617: PPUSH
75618: CALL_OW 255
75622: ST_TO_ADDR
// dep := dep [ 1 ] ;
75623: LD_ADDR_VAR 0 9
75627: PUSH
75628: LD_VAR 0 9
75632: PUSH
75633: LD_INT 1
75635: ARRAY
75636: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75637: LD_ADDR_VAR 0 7
75641: PUSH
75642: LD_EXP 86
75646: PUSH
75647: LD_VAR 0 2
75651: ARRAY
75652: PPUSH
75653: LD_INT 22
75655: PUSH
75656: LD_INT 0
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PUSH
75663: LD_INT 25
75665: PUSH
75666: LD_INT 12
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: PPUSH
75677: CALL_OW 70
75681: PUSH
75682: LD_INT 22
75684: PUSH
75685: LD_INT 0
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PUSH
75692: LD_INT 25
75694: PUSH
75695: LD_INT 12
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 91
75704: PUSH
75705: LD_VAR 0 9
75709: PUSH
75710: LD_INT 20
75712: PUSH
75713: EMPTY
75714: LIST
75715: LIST
75716: LIST
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: LIST
75722: PPUSH
75723: CALL_OW 69
75727: UNION
75728: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75729: LD_ADDR_VAR 0 10
75733: PUSH
75734: LD_EXP 86
75738: PUSH
75739: LD_VAR 0 2
75743: ARRAY
75744: PPUSH
75745: LD_INT 81
75747: PUSH
75748: LD_VAR 0 11
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PPUSH
75757: CALL_OW 70
75761: ST_TO_ADDR
// if not apes or danger_at_area then
75762: LD_VAR 0 7
75766: NOT
75767: PUSH
75768: LD_VAR 0 10
75772: OR
75773: IFFALSE 75823
// begin if mc_taming [ i ] then
75775: LD_EXP 89
75779: PUSH
75780: LD_VAR 0 2
75784: ARRAY
75785: IFFALSE 75821
// begin MC_Reset ( i , 121 ) ;
75787: LD_VAR 0 2
75791: PPUSH
75792: LD_INT 121
75794: PPUSH
75795: CALL 61154 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
75799: LD_ADDR_EXP 89
75803: PUSH
75804: LD_EXP 89
75808: PPUSH
75809: LD_VAR 0 2
75813: PPUSH
75814: EMPTY
75815: PPUSH
75816: CALL_OW 1
75820: ST_TO_ADDR
// end ; continue ;
75821: GO 75389
// end ; for j in tmp do
75823: LD_ADDR_VAR 0 3
75827: PUSH
75828: LD_VAR 0 8
75832: PUSH
75833: FOR_IN
75834: IFFALSE 76170
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
75836: LD_VAR 0 3
75840: PUSH
75841: LD_EXP 89
75845: PUSH
75846: LD_VAR 0 2
75850: ARRAY
75851: IN
75852: NOT
75853: PUSH
75854: LD_EXP 89
75858: PUSH
75859: LD_VAR 0 2
75863: ARRAY
75864: PUSH
75865: LD_INT 3
75867: LESS
75868: AND
75869: IFFALSE 75927
// begin SetTag ( j , 121 ) ;
75871: LD_VAR 0 3
75875: PPUSH
75876: LD_INT 121
75878: PPUSH
75879: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
75883: LD_ADDR_EXP 89
75887: PUSH
75888: LD_EXP 89
75892: PPUSH
75893: LD_VAR 0 2
75897: PUSH
75898: LD_EXP 89
75902: PUSH
75903: LD_VAR 0 2
75907: ARRAY
75908: PUSH
75909: LD_INT 1
75911: PLUS
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: PPUSH
75917: LD_VAR 0 3
75921: PPUSH
75922: CALL 21151 0 3
75926: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75927: LD_VAR 0 3
75931: PUSH
75932: LD_EXP 89
75936: PUSH
75937: LD_VAR 0 2
75941: ARRAY
75942: IN
75943: IFFALSE 76168
// begin if GetClass ( j ) <> 4 then
75945: LD_VAR 0 3
75949: PPUSH
75950: CALL_OW 257
75954: PUSH
75955: LD_INT 4
75957: NONEQUAL
75958: IFFALSE 76011
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75960: LD_ADDR_EXP 89
75964: PUSH
75965: LD_EXP 89
75969: PPUSH
75970: LD_VAR 0 2
75974: PPUSH
75975: LD_EXP 89
75979: PUSH
75980: LD_VAR 0 2
75984: ARRAY
75985: PUSH
75986: LD_VAR 0 3
75990: DIFF
75991: PPUSH
75992: CALL_OW 1
75996: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75997: LD_VAR 0 3
76001: PPUSH
76002: LD_INT 0
76004: PPUSH
76005: CALL_OW 109
// continue ;
76009: GO 75833
// end ; if IsInUnit ( j ) then
76011: LD_VAR 0 3
76015: PPUSH
76016: CALL_OW 310
76020: IFFALSE 76031
// ComExitBuilding ( j ) ;
76022: LD_VAR 0 3
76026: PPUSH
76027: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76031: LD_ADDR_VAR 0 6
76035: PUSH
76036: LD_VAR 0 7
76040: PPUSH
76041: LD_VAR 0 3
76045: PPUSH
76046: CALL_OW 74
76050: ST_TO_ADDR
// if not ape then
76051: LD_VAR 0 6
76055: NOT
76056: IFFALSE 76060
// break ;
76058: GO 76170
// x := GetX ( ape ) ;
76060: LD_ADDR_VAR 0 4
76064: PUSH
76065: LD_VAR 0 6
76069: PPUSH
76070: CALL_OW 250
76074: ST_TO_ADDR
// y := GetY ( ape ) ;
76075: LD_ADDR_VAR 0 5
76079: PUSH
76080: LD_VAR 0 6
76084: PPUSH
76085: CALL_OW 251
76089: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76090: LD_VAR 0 4
76094: PPUSH
76095: LD_VAR 0 5
76099: PPUSH
76100: CALL_OW 488
76104: NOT
76105: PUSH
76106: LD_VAR 0 11
76110: PPUSH
76111: LD_VAR 0 4
76115: PPUSH
76116: LD_VAR 0 5
76120: PPUSH
76121: LD_INT 20
76123: PPUSH
76124: CALL 22047 0 4
76128: PUSH
76129: LD_INT 4
76131: ARRAY
76132: OR
76133: IFFALSE 76137
// break ;
76135: GO 76170
// if not HasTask ( j ) then
76137: LD_VAR 0 3
76141: PPUSH
76142: CALL_OW 314
76146: NOT
76147: IFFALSE 76168
// ComTameXY ( j , x , y ) ;
76149: LD_VAR 0 3
76153: PPUSH
76154: LD_VAR 0 4
76158: PPUSH
76159: LD_VAR 0 5
76163: PPUSH
76164: CALL_OW 131
// end ; end ;
76168: GO 75833
76170: POP
76171: POP
// end ;
76172: GO 75389
76174: POP
76175: POP
// end ;
76176: LD_VAR 0 1
76180: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76181: LD_INT 0
76183: PPUSH
76184: PPUSH
76185: PPUSH
76186: PPUSH
76187: PPUSH
76188: PPUSH
76189: PPUSH
76190: PPUSH
// if not mc_bases then
76191: LD_EXP 58
76195: NOT
76196: IFFALSE 76200
// exit ;
76198: GO 76826
// for i = 1 to mc_bases do
76200: LD_ADDR_VAR 0 2
76204: PUSH
76205: DOUBLE
76206: LD_INT 1
76208: DEC
76209: ST_TO_ADDR
76210: LD_EXP 58
76214: PUSH
76215: FOR_TO
76216: IFFALSE 76824
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76218: LD_EXP 87
76222: PUSH
76223: LD_VAR 0 2
76227: ARRAY
76228: NOT
76229: PUSH
76230: LD_EXP 87
76234: PUSH
76235: LD_VAR 0 2
76239: ARRAY
76240: PPUSH
76241: LD_INT 25
76243: PUSH
76244: LD_INT 12
76246: PUSH
76247: EMPTY
76248: LIST
76249: LIST
76250: PPUSH
76251: CALL_OW 72
76255: NOT
76256: OR
76257: IFFALSE 76261
// continue ;
76259: GO 76215
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76261: LD_ADDR_VAR 0 5
76265: PUSH
76266: LD_EXP 87
76270: PUSH
76271: LD_VAR 0 2
76275: ARRAY
76276: PUSH
76277: LD_INT 1
76279: ARRAY
76280: PPUSH
76281: CALL_OW 255
76285: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76286: LD_VAR 0 5
76290: PPUSH
76291: LD_INT 2
76293: PPUSH
76294: CALL_OW 325
76298: IFFALSE 76551
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76300: LD_ADDR_VAR 0 4
76304: PUSH
76305: LD_EXP 87
76309: PUSH
76310: LD_VAR 0 2
76314: ARRAY
76315: PPUSH
76316: LD_INT 25
76318: PUSH
76319: LD_INT 16
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PPUSH
76326: CALL_OW 72
76330: ST_TO_ADDR
// if tmp < 6 then
76331: LD_VAR 0 4
76335: PUSH
76336: LD_INT 6
76338: LESS
76339: IFFALSE 76551
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76341: LD_ADDR_VAR 0 6
76345: PUSH
76346: LD_EXP 58
76350: PUSH
76351: LD_VAR 0 2
76355: ARRAY
76356: PPUSH
76357: LD_INT 2
76359: PUSH
76360: LD_INT 30
76362: PUSH
76363: LD_INT 0
76365: PUSH
76366: EMPTY
76367: LIST
76368: LIST
76369: PUSH
76370: LD_INT 30
76372: PUSH
76373: LD_INT 1
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: LIST
76384: PPUSH
76385: CALL_OW 72
76389: ST_TO_ADDR
// if depot then
76390: LD_VAR 0 6
76394: IFFALSE 76551
// begin selected := 0 ;
76396: LD_ADDR_VAR 0 7
76400: PUSH
76401: LD_INT 0
76403: ST_TO_ADDR
// for j in depot do
76404: LD_ADDR_VAR 0 3
76408: PUSH
76409: LD_VAR 0 6
76413: PUSH
76414: FOR_IN
76415: IFFALSE 76446
// begin if UnitsInside ( j ) < 6 then
76417: LD_VAR 0 3
76421: PPUSH
76422: CALL_OW 313
76426: PUSH
76427: LD_INT 6
76429: LESS
76430: IFFALSE 76444
// begin selected := j ;
76432: LD_ADDR_VAR 0 7
76436: PUSH
76437: LD_VAR 0 3
76441: ST_TO_ADDR
// break ;
76442: GO 76446
// end ; end ;
76444: GO 76414
76446: POP
76447: POP
// if selected then
76448: LD_VAR 0 7
76452: IFFALSE 76551
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76454: LD_ADDR_VAR 0 3
76458: PUSH
76459: LD_EXP 87
76463: PUSH
76464: LD_VAR 0 2
76468: ARRAY
76469: PPUSH
76470: LD_INT 25
76472: PUSH
76473: LD_INT 12
76475: PUSH
76476: EMPTY
76477: LIST
76478: LIST
76479: PPUSH
76480: CALL_OW 72
76484: PUSH
76485: FOR_IN
76486: IFFALSE 76549
// if not HasTask ( j ) then
76488: LD_VAR 0 3
76492: PPUSH
76493: CALL_OW 314
76497: NOT
76498: IFFALSE 76547
// begin if not IsInUnit ( j ) then
76500: LD_VAR 0 3
76504: PPUSH
76505: CALL_OW 310
76509: NOT
76510: IFFALSE 76526
// ComEnterUnit ( j , selected ) ;
76512: LD_VAR 0 3
76516: PPUSH
76517: LD_VAR 0 7
76521: PPUSH
76522: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76526: LD_VAR 0 3
76530: PPUSH
76531: LD_INT 16
76533: PPUSH
76534: CALL_OW 183
// AddComExitBuilding ( j ) ;
76538: LD_VAR 0 3
76542: PPUSH
76543: CALL_OW 182
// end ;
76547: GO 76485
76549: POP
76550: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76551: LD_VAR 0 5
76555: PPUSH
76556: LD_INT 11
76558: PPUSH
76559: CALL_OW 325
76563: IFFALSE 76822
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76565: LD_ADDR_VAR 0 4
76569: PUSH
76570: LD_EXP 87
76574: PUSH
76575: LD_VAR 0 2
76579: ARRAY
76580: PPUSH
76581: LD_INT 25
76583: PUSH
76584: LD_INT 16
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: PPUSH
76591: CALL_OW 72
76595: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76596: LD_VAR 0 4
76600: PUSH
76601: LD_INT 6
76603: GREATEREQUAL
76604: PUSH
76605: LD_VAR 0 5
76609: PPUSH
76610: LD_INT 2
76612: PPUSH
76613: CALL_OW 325
76617: NOT
76618: OR
76619: IFFALSE 76822
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76621: LD_ADDR_VAR 0 8
76625: PUSH
76626: LD_EXP 58
76630: PUSH
76631: LD_VAR 0 2
76635: ARRAY
76636: PPUSH
76637: LD_INT 2
76639: PUSH
76640: LD_INT 30
76642: PUSH
76643: LD_INT 4
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: LD_INT 30
76652: PUSH
76653: LD_INT 5
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: LIST
76664: PPUSH
76665: CALL_OW 72
76669: ST_TO_ADDR
// if barracks then
76670: LD_VAR 0 8
76674: IFFALSE 76822
// begin selected := 0 ;
76676: LD_ADDR_VAR 0 7
76680: PUSH
76681: LD_INT 0
76683: ST_TO_ADDR
// for j in barracks do
76684: LD_ADDR_VAR 0 3
76688: PUSH
76689: LD_VAR 0 8
76693: PUSH
76694: FOR_IN
76695: IFFALSE 76726
// begin if UnitsInside ( j ) < 6 then
76697: LD_VAR 0 3
76701: PPUSH
76702: CALL_OW 313
76706: PUSH
76707: LD_INT 6
76709: LESS
76710: IFFALSE 76724
// begin selected := j ;
76712: LD_ADDR_VAR 0 7
76716: PUSH
76717: LD_VAR 0 3
76721: ST_TO_ADDR
// break ;
76722: GO 76726
// end ; end ;
76724: GO 76694
76726: POP
76727: POP
// if selected then
76728: LD_VAR 0 7
76732: IFFALSE 76822
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76734: LD_ADDR_VAR 0 3
76738: PUSH
76739: LD_EXP 87
76743: PUSH
76744: LD_VAR 0 2
76748: ARRAY
76749: PPUSH
76750: LD_INT 25
76752: PUSH
76753: LD_INT 12
76755: PUSH
76756: EMPTY
76757: LIST
76758: LIST
76759: PPUSH
76760: CALL_OW 72
76764: PUSH
76765: FOR_IN
76766: IFFALSE 76820
// if not IsInUnit ( j ) and not HasTask ( j ) then
76768: LD_VAR 0 3
76772: PPUSH
76773: CALL_OW 310
76777: NOT
76778: PUSH
76779: LD_VAR 0 3
76783: PPUSH
76784: CALL_OW 314
76788: NOT
76789: AND
76790: IFFALSE 76818
// begin ComEnterUnit ( j , selected ) ;
76792: LD_VAR 0 3
76796: PPUSH
76797: LD_VAR 0 7
76801: PPUSH
76802: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
76806: LD_VAR 0 3
76810: PPUSH
76811: LD_INT 15
76813: PPUSH
76814: CALL_OW 183
// end ;
76818: GO 76765
76820: POP
76821: POP
// end ; end ; end ; end ; end ;
76822: GO 76215
76824: POP
76825: POP
// end ;
76826: LD_VAR 0 1
76830: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
76831: LD_INT 0
76833: PPUSH
76834: PPUSH
76835: PPUSH
76836: PPUSH
// if not mc_bases then
76837: LD_EXP 58
76841: NOT
76842: IFFALSE 76846
// exit ;
76844: GO 77024
// for i = 1 to mc_bases do
76846: LD_ADDR_VAR 0 2
76850: PUSH
76851: DOUBLE
76852: LD_INT 1
76854: DEC
76855: ST_TO_ADDR
76856: LD_EXP 58
76860: PUSH
76861: FOR_TO
76862: IFFALSE 77022
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
76864: LD_ADDR_VAR 0 4
76868: PUSH
76869: LD_EXP 58
76873: PUSH
76874: LD_VAR 0 2
76878: ARRAY
76879: PPUSH
76880: LD_INT 25
76882: PUSH
76883: LD_INT 9
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PPUSH
76890: CALL_OW 72
76894: ST_TO_ADDR
// if not tmp then
76895: LD_VAR 0 4
76899: NOT
76900: IFFALSE 76904
// continue ;
76902: GO 76861
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76904: LD_EXP 84
76908: PUSH
76909: LD_VAR 0 2
76913: ARRAY
76914: PPUSH
76915: LD_INT 29
76917: PPUSH
76918: CALL_OW 325
76922: NOT
76923: PUSH
76924: LD_EXP 84
76928: PUSH
76929: LD_VAR 0 2
76933: ARRAY
76934: PPUSH
76935: LD_INT 28
76937: PPUSH
76938: CALL_OW 325
76942: NOT
76943: AND
76944: IFFALSE 76948
// continue ;
76946: GO 76861
// for j in tmp do
76948: LD_ADDR_VAR 0 3
76952: PUSH
76953: LD_VAR 0 4
76957: PUSH
76958: FOR_IN
76959: IFFALSE 77018
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76961: LD_VAR 0 3
76965: PUSH
76966: LD_EXP 61
76970: PUSH
76971: LD_VAR 0 2
76975: ARRAY
76976: PUSH
76977: LD_INT 1
76979: ARRAY
76980: IN
76981: NOT
76982: PUSH
76983: LD_VAR 0 3
76987: PUSH
76988: LD_EXP 61
76992: PUSH
76993: LD_VAR 0 2
76997: ARRAY
76998: PUSH
76999: LD_INT 2
77001: ARRAY
77002: IN
77003: NOT
77004: AND
77005: IFFALSE 77016
// ComSpaceTimeShoot ( j ) ;
77007: LD_VAR 0 3
77011: PPUSH
77012: CALL 14886 0 1
77016: GO 76958
77018: POP
77019: POP
// end ;
77020: GO 76861
77022: POP
77023: POP
// end ;
77024: LD_VAR 0 1
77028: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77029: LD_INT 0
77031: PPUSH
77032: PPUSH
77033: PPUSH
77034: PPUSH
77035: PPUSH
77036: PPUSH
77037: PPUSH
77038: PPUSH
77039: PPUSH
// if not mc_bases then
77040: LD_EXP 58
77044: NOT
77045: IFFALSE 77049
// exit ;
77047: GO 77671
// for i = 1 to mc_bases do
77049: LD_ADDR_VAR 0 2
77053: PUSH
77054: DOUBLE
77055: LD_INT 1
77057: DEC
77058: ST_TO_ADDR
77059: LD_EXP 58
77063: PUSH
77064: FOR_TO
77065: IFFALSE 77669
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77067: LD_EXP 93
77071: PUSH
77072: LD_VAR 0 2
77076: ARRAY
77077: NOT
77078: PUSH
77079: LD_INT 38
77081: PPUSH
77082: LD_EXP 84
77086: PUSH
77087: LD_VAR 0 2
77091: ARRAY
77092: PPUSH
77093: CALL_OW 321
77097: PUSH
77098: LD_INT 2
77100: NONEQUAL
77101: OR
77102: IFFALSE 77106
// continue ;
77104: GO 77064
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77106: LD_ADDR_VAR 0 8
77110: PUSH
77111: LD_EXP 58
77115: PUSH
77116: LD_VAR 0 2
77120: ARRAY
77121: PPUSH
77122: LD_INT 30
77124: PUSH
77125: LD_INT 34
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: PPUSH
77132: CALL_OW 72
77136: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77137: LD_ADDR_VAR 0 9
77141: PUSH
77142: LD_EXP 58
77146: PUSH
77147: LD_VAR 0 2
77151: ARRAY
77152: PPUSH
77153: LD_INT 25
77155: PUSH
77156: LD_INT 4
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PPUSH
77163: CALL_OW 72
77167: PPUSH
77168: LD_INT 0
77170: PPUSH
77171: CALL 54411 0 2
77175: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77176: LD_VAR 0 9
77180: NOT
77181: PUSH
77182: LD_VAR 0 8
77186: NOT
77187: OR
77188: PUSH
77189: LD_EXP 58
77193: PUSH
77194: LD_VAR 0 2
77198: ARRAY
77199: PPUSH
77200: LD_INT 124
77202: PPUSH
77203: CALL 54411 0 2
77207: OR
77208: IFFALSE 77212
// continue ;
77210: GO 77064
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77212: LD_EXP 94
77216: PUSH
77217: LD_VAR 0 2
77221: ARRAY
77222: PUSH
77223: LD_EXP 93
77227: PUSH
77228: LD_VAR 0 2
77232: ARRAY
77233: LESS
77234: PUSH
77235: LD_EXP 94
77239: PUSH
77240: LD_VAR 0 2
77244: ARRAY
77245: PUSH
77246: LD_VAR 0 8
77250: LESS
77251: AND
77252: IFFALSE 77667
// begin tmp := sci [ 1 ] ;
77254: LD_ADDR_VAR 0 7
77258: PUSH
77259: LD_VAR 0 9
77263: PUSH
77264: LD_INT 1
77266: ARRAY
77267: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77268: LD_VAR 0 7
77272: PPUSH
77273: LD_INT 124
77275: PPUSH
77276: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77280: LD_ADDR_VAR 0 3
77284: PUSH
77285: DOUBLE
77286: LD_EXP 93
77290: PUSH
77291: LD_VAR 0 2
77295: ARRAY
77296: INC
77297: ST_TO_ADDR
77298: LD_EXP 93
77302: PUSH
77303: LD_VAR 0 2
77307: ARRAY
77308: PUSH
77309: FOR_DOWNTO
77310: IFFALSE 77653
// begin if IsInUnit ( tmp ) then
77312: LD_VAR 0 7
77316: PPUSH
77317: CALL_OW 310
77321: IFFALSE 77332
// ComExitBuilding ( tmp ) ;
77323: LD_VAR 0 7
77327: PPUSH
77328: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77332: LD_INT 35
77334: PPUSH
77335: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77339: LD_VAR 0 7
77343: PPUSH
77344: CALL_OW 310
77348: NOT
77349: PUSH
77350: LD_VAR 0 7
77354: PPUSH
77355: CALL_OW 314
77359: NOT
77360: AND
77361: IFFALSE 77332
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77363: LD_ADDR_VAR 0 6
77367: PUSH
77368: LD_VAR 0 7
77372: PPUSH
77373: CALL_OW 250
77377: PUSH
77378: LD_VAR 0 7
77382: PPUSH
77383: CALL_OW 251
77387: PUSH
77388: EMPTY
77389: LIST
77390: LIST
77391: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77392: LD_INT 35
77394: PPUSH
77395: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77399: LD_ADDR_VAR 0 4
77403: PUSH
77404: LD_EXP 93
77408: PUSH
77409: LD_VAR 0 2
77413: ARRAY
77414: PUSH
77415: LD_VAR 0 3
77419: ARRAY
77420: PUSH
77421: LD_INT 1
77423: ARRAY
77424: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77425: LD_ADDR_VAR 0 5
77429: PUSH
77430: LD_EXP 93
77434: PUSH
77435: LD_VAR 0 2
77439: ARRAY
77440: PUSH
77441: LD_VAR 0 3
77445: ARRAY
77446: PUSH
77447: LD_INT 2
77449: ARRAY
77450: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77451: LD_VAR 0 7
77455: PPUSH
77456: LD_INT 10
77458: PPUSH
77459: CALL 23744 0 2
77463: PUSH
77464: LD_INT 4
77466: ARRAY
77467: IFFALSE 77505
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77469: LD_VAR 0 7
77473: PPUSH
77474: LD_VAR 0 6
77478: PUSH
77479: LD_INT 1
77481: ARRAY
77482: PPUSH
77483: LD_VAR 0 6
77487: PUSH
77488: LD_INT 2
77490: ARRAY
77491: PPUSH
77492: CALL_OW 111
// wait ( 0 0$10 ) ;
77496: LD_INT 350
77498: PPUSH
77499: CALL_OW 67
// end else
77503: GO 77531
// begin ComMoveXY ( tmp , x , y ) ;
77505: LD_VAR 0 7
77509: PPUSH
77510: LD_VAR 0 4
77514: PPUSH
77515: LD_VAR 0 5
77519: PPUSH
77520: CALL_OW 111
// wait ( 0 0$3 ) ;
77524: LD_INT 105
77526: PPUSH
77527: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77531: LD_VAR 0 7
77535: PPUSH
77536: LD_VAR 0 4
77540: PPUSH
77541: LD_VAR 0 5
77545: PPUSH
77546: CALL_OW 307
77550: IFFALSE 77392
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77552: LD_VAR 0 7
77556: PPUSH
77557: LD_VAR 0 4
77561: PPUSH
77562: LD_VAR 0 5
77566: PPUSH
77567: LD_VAR 0 8
77571: PUSH
77572: LD_VAR 0 3
77576: ARRAY
77577: PPUSH
77578: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77582: LD_INT 35
77584: PPUSH
77585: CALL_OW 67
// until not HasTask ( tmp ) ;
77589: LD_VAR 0 7
77593: PPUSH
77594: CALL_OW 314
77598: NOT
77599: IFFALSE 77582
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77601: LD_ADDR_EXP 94
77605: PUSH
77606: LD_EXP 94
77610: PPUSH
77611: LD_VAR 0 2
77615: PUSH
77616: LD_EXP 94
77620: PUSH
77621: LD_VAR 0 2
77625: ARRAY
77626: PUSH
77627: LD_INT 1
77629: PLUS
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PPUSH
77635: LD_VAR 0 8
77639: PUSH
77640: LD_VAR 0 3
77644: ARRAY
77645: PPUSH
77646: CALL 21151 0 3
77650: ST_TO_ADDR
// end ;
77651: GO 77309
77653: POP
77654: POP
// MC_Reset ( i , 124 ) ;
77655: LD_VAR 0 2
77659: PPUSH
77660: LD_INT 124
77662: PPUSH
77663: CALL 61154 0 2
// end ; end ;
77667: GO 77064
77669: POP
77670: POP
// end ;
77671: LD_VAR 0 1
77675: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77676: LD_INT 0
77678: PPUSH
77679: PPUSH
77680: PPUSH
// if not mc_bases then
77681: LD_EXP 58
77685: NOT
77686: IFFALSE 77690
// exit ;
77688: GO 78296
// for i = 1 to mc_bases do
77690: LD_ADDR_VAR 0 2
77694: PUSH
77695: DOUBLE
77696: LD_INT 1
77698: DEC
77699: ST_TO_ADDR
77700: LD_EXP 58
77704: PUSH
77705: FOR_TO
77706: IFFALSE 78294
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77708: LD_ADDR_VAR 0 3
77712: PUSH
77713: LD_EXP 58
77717: PUSH
77718: LD_VAR 0 2
77722: ARRAY
77723: PPUSH
77724: LD_INT 25
77726: PUSH
77727: LD_INT 4
77729: PUSH
77730: EMPTY
77731: LIST
77732: LIST
77733: PPUSH
77734: CALL_OW 72
77738: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77739: LD_VAR 0 3
77743: NOT
77744: PUSH
77745: LD_EXP 95
77749: PUSH
77750: LD_VAR 0 2
77754: ARRAY
77755: NOT
77756: OR
77757: PUSH
77758: LD_EXP 58
77762: PUSH
77763: LD_VAR 0 2
77767: ARRAY
77768: PPUSH
77769: LD_INT 2
77771: PUSH
77772: LD_INT 30
77774: PUSH
77775: LD_INT 0
77777: PUSH
77778: EMPTY
77779: LIST
77780: LIST
77781: PUSH
77782: LD_INT 30
77784: PUSH
77785: LD_INT 1
77787: PUSH
77788: EMPTY
77789: LIST
77790: LIST
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: LIST
77796: PPUSH
77797: CALL_OW 72
77801: NOT
77802: OR
77803: IFFALSE 77853
// begin if mc_deposits_finder [ i ] then
77805: LD_EXP 96
77809: PUSH
77810: LD_VAR 0 2
77814: ARRAY
77815: IFFALSE 77851
// begin MC_Reset ( i , 125 ) ;
77817: LD_VAR 0 2
77821: PPUSH
77822: LD_INT 125
77824: PPUSH
77825: CALL 61154 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77829: LD_ADDR_EXP 96
77833: PUSH
77834: LD_EXP 96
77838: PPUSH
77839: LD_VAR 0 2
77843: PPUSH
77844: EMPTY
77845: PPUSH
77846: CALL_OW 1
77850: ST_TO_ADDR
// end ; continue ;
77851: GO 77705
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
77853: LD_EXP 95
77857: PUSH
77858: LD_VAR 0 2
77862: ARRAY
77863: PUSH
77864: LD_INT 1
77866: ARRAY
77867: PUSH
77868: LD_INT 3
77870: ARRAY
77871: PUSH
77872: LD_INT 1
77874: EQUAL
77875: PUSH
77876: LD_INT 20
77878: PPUSH
77879: LD_EXP 84
77883: PUSH
77884: LD_VAR 0 2
77888: ARRAY
77889: PPUSH
77890: CALL_OW 321
77894: PUSH
77895: LD_INT 2
77897: NONEQUAL
77898: AND
77899: IFFALSE 77949
// begin if mc_deposits_finder [ i ] then
77901: LD_EXP 96
77905: PUSH
77906: LD_VAR 0 2
77910: ARRAY
77911: IFFALSE 77947
// begin MC_Reset ( i , 125 ) ;
77913: LD_VAR 0 2
77917: PPUSH
77918: LD_INT 125
77920: PPUSH
77921: CALL 61154 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77925: LD_ADDR_EXP 96
77929: PUSH
77930: LD_EXP 96
77934: PPUSH
77935: LD_VAR 0 2
77939: PPUSH
77940: EMPTY
77941: PPUSH
77942: CALL_OW 1
77946: ST_TO_ADDR
// end ; continue ;
77947: GO 77705
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77949: LD_EXP 95
77953: PUSH
77954: LD_VAR 0 2
77958: ARRAY
77959: PUSH
77960: LD_INT 1
77962: ARRAY
77963: PUSH
77964: LD_INT 1
77966: ARRAY
77967: PPUSH
77968: LD_EXP 95
77972: PUSH
77973: LD_VAR 0 2
77977: ARRAY
77978: PUSH
77979: LD_INT 1
77981: ARRAY
77982: PUSH
77983: LD_INT 2
77985: ARRAY
77986: PPUSH
77987: LD_EXP 84
77991: PUSH
77992: LD_VAR 0 2
77996: ARRAY
77997: PPUSH
77998: CALL_OW 440
78002: IFFALSE 78045
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78004: LD_ADDR_EXP 95
78008: PUSH
78009: LD_EXP 95
78013: PPUSH
78014: LD_VAR 0 2
78018: PPUSH
78019: LD_EXP 95
78023: PUSH
78024: LD_VAR 0 2
78028: ARRAY
78029: PPUSH
78030: LD_INT 1
78032: PPUSH
78033: CALL_OW 3
78037: PPUSH
78038: CALL_OW 1
78042: ST_TO_ADDR
78043: GO 78292
// begin if not mc_deposits_finder [ i ] then
78045: LD_EXP 96
78049: PUSH
78050: LD_VAR 0 2
78054: ARRAY
78055: NOT
78056: IFFALSE 78108
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78058: LD_ADDR_EXP 96
78062: PUSH
78063: LD_EXP 96
78067: PPUSH
78068: LD_VAR 0 2
78072: PPUSH
78073: LD_VAR 0 3
78077: PUSH
78078: LD_INT 1
78080: ARRAY
78081: PUSH
78082: EMPTY
78083: LIST
78084: PPUSH
78085: CALL_OW 1
78089: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78090: LD_VAR 0 3
78094: PUSH
78095: LD_INT 1
78097: ARRAY
78098: PPUSH
78099: LD_INT 125
78101: PPUSH
78102: CALL_OW 109
// end else
78106: GO 78292
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78108: LD_EXP 96
78112: PUSH
78113: LD_VAR 0 2
78117: ARRAY
78118: PUSH
78119: LD_INT 1
78121: ARRAY
78122: PPUSH
78123: CALL_OW 310
78127: IFFALSE 78150
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78129: LD_EXP 96
78133: PUSH
78134: LD_VAR 0 2
78138: ARRAY
78139: PUSH
78140: LD_INT 1
78142: ARRAY
78143: PPUSH
78144: CALL_OW 122
78148: GO 78292
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78150: LD_EXP 96
78154: PUSH
78155: LD_VAR 0 2
78159: ARRAY
78160: PUSH
78161: LD_INT 1
78163: ARRAY
78164: PPUSH
78165: CALL_OW 314
78169: NOT
78170: PUSH
78171: LD_EXP 96
78175: PUSH
78176: LD_VAR 0 2
78180: ARRAY
78181: PUSH
78182: LD_INT 1
78184: ARRAY
78185: PPUSH
78186: LD_EXP 95
78190: PUSH
78191: LD_VAR 0 2
78195: ARRAY
78196: PUSH
78197: LD_INT 1
78199: ARRAY
78200: PUSH
78201: LD_INT 1
78203: ARRAY
78204: PPUSH
78205: LD_EXP 95
78209: PUSH
78210: LD_VAR 0 2
78214: ARRAY
78215: PUSH
78216: LD_INT 1
78218: ARRAY
78219: PUSH
78220: LD_INT 2
78222: ARRAY
78223: PPUSH
78224: CALL_OW 297
78228: PUSH
78229: LD_INT 6
78231: GREATER
78232: AND
78233: IFFALSE 78292
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78235: LD_EXP 96
78239: PUSH
78240: LD_VAR 0 2
78244: ARRAY
78245: PUSH
78246: LD_INT 1
78248: ARRAY
78249: PPUSH
78250: LD_EXP 95
78254: PUSH
78255: LD_VAR 0 2
78259: ARRAY
78260: PUSH
78261: LD_INT 1
78263: ARRAY
78264: PUSH
78265: LD_INT 1
78267: ARRAY
78268: PPUSH
78269: LD_EXP 95
78273: PUSH
78274: LD_VAR 0 2
78278: ARRAY
78279: PUSH
78280: LD_INT 1
78282: ARRAY
78283: PUSH
78284: LD_INT 2
78286: ARRAY
78287: PPUSH
78288: CALL_OW 111
// end ; end ; end ;
78292: GO 77705
78294: POP
78295: POP
// end ;
78296: LD_VAR 0 1
78300: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78301: LD_INT 0
78303: PPUSH
78304: PPUSH
78305: PPUSH
78306: PPUSH
78307: PPUSH
78308: PPUSH
78309: PPUSH
78310: PPUSH
78311: PPUSH
78312: PPUSH
78313: PPUSH
// if not mc_bases then
78314: LD_EXP 58
78318: NOT
78319: IFFALSE 78323
// exit ;
78321: GO 79047
// for i = 1 to mc_bases do
78323: LD_ADDR_VAR 0 2
78327: PUSH
78328: DOUBLE
78329: LD_INT 1
78331: DEC
78332: ST_TO_ADDR
78333: LD_EXP 58
78337: PUSH
78338: FOR_TO
78339: IFFALSE 79045
// begin if not mc_bases [ i ] then
78341: LD_EXP 58
78345: PUSH
78346: LD_VAR 0 2
78350: ARRAY
78351: NOT
78352: IFFALSE 78356
// continue ;
78354: GO 78338
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78356: LD_ADDR_VAR 0 7
78360: PUSH
78361: LD_EXP 58
78365: PUSH
78366: LD_VAR 0 2
78370: ARRAY
78371: PUSH
78372: LD_INT 1
78374: ARRAY
78375: PPUSH
78376: CALL_OW 248
78380: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78381: LD_VAR 0 7
78385: PUSH
78386: LD_INT 3
78388: EQUAL
78389: PUSH
78390: LD_EXP 77
78394: PUSH
78395: LD_VAR 0 2
78399: ARRAY
78400: PUSH
78401: LD_EXP 80
78405: PUSH
78406: LD_VAR 0 2
78410: ARRAY
78411: UNION
78412: PPUSH
78413: LD_INT 33
78415: PUSH
78416: LD_INT 2
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: PPUSH
78423: CALL_OW 72
78427: NOT
78428: OR
78429: IFFALSE 78433
// continue ;
78431: GO 78338
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78433: LD_ADDR_VAR 0 9
78437: PUSH
78438: LD_EXP 58
78442: PUSH
78443: LD_VAR 0 2
78447: ARRAY
78448: PPUSH
78449: LD_INT 30
78451: PUSH
78452: LD_INT 36
78454: PUSH
78455: EMPTY
78456: LIST
78457: LIST
78458: PPUSH
78459: CALL_OW 72
78463: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78464: LD_ADDR_VAR 0 10
78468: PUSH
78469: LD_EXP 77
78473: PUSH
78474: LD_VAR 0 2
78478: ARRAY
78479: PPUSH
78480: LD_INT 34
78482: PUSH
78483: LD_INT 31
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PPUSH
78490: CALL_OW 72
78494: ST_TO_ADDR
// if not cts and not mcts then
78495: LD_VAR 0 9
78499: NOT
78500: PUSH
78501: LD_VAR 0 10
78505: NOT
78506: AND
78507: IFFALSE 78511
// continue ;
78509: GO 78338
// x := cts ;
78511: LD_ADDR_VAR 0 11
78515: PUSH
78516: LD_VAR 0 9
78520: ST_TO_ADDR
// if not x then
78521: LD_VAR 0 11
78525: NOT
78526: IFFALSE 78538
// x := mcts ;
78528: LD_ADDR_VAR 0 11
78532: PUSH
78533: LD_VAR 0 10
78537: ST_TO_ADDR
// if mc_remote_driver [ i ] then
78538: LD_EXP 98
78542: PUSH
78543: LD_VAR 0 2
78547: ARRAY
78548: IFFALSE 78817
// for j in mc_remote_driver [ i ] do
78550: LD_ADDR_VAR 0 3
78554: PUSH
78555: LD_EXP 98
78559: PUSH
78560: LD_VAR 0 2
78564: ARRAY
78565: PUSH
78566: FOR_IN
78567: IFFALSE 78815
// begin if GetClass ( j ) <> 3 then
78569: LD_VAR 0 3
78573: PPUSH
78574: CALL_OW 257
78578: PUSH
78579: LD_INT 3
78581: NONEQUAL
78582: IFFALSE 78635
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78584: LD_ADDR_EXP 98
78588: PUSH
78589: LD_EXP 98
78593: PPUSH
78594: LD_VAR 0 2
78598: PPUSH
78599: LD_EXP 98
78603: PUSH
78604: LD_VAR 0 2
78608: ARRAY
78609: PUSH
78610: LD_VAR 0 3
78614: DIFF
78615: PPUSH
78616: CALL_OW 1
78620: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78621: LD_VAR 0 3
78625: PPUSH
78626: LD_INT 0
78628: PPUSH
78629: CALL_OW 109
// continue ;
78633: GO 78566
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78635: LD_VAR 0 3
78639: PPUSH
78640: CALL_OW 310
78644: NOT
78645: PUSH
78646: LD_VAR 0 3
78650: PPUSH
78651: CALL_OW 310
78655: PPUSH
78656: CALL_OW 266
78660: PUSH
78661: LD_INT 36
78663: NONEQUAL
78664: PUSH
78665: LD_VAR 0 3
78669: PPUSH
78670: CALL 54499 0 1
78674: NOT
78675: AND
78676: OR
78677: IFFALSE 78813
// begin if IsInUnit ( j ) then
78679: LD_VAR 0 3
78683: PPUSH
78684: CALL_OW 310
78688: IFFALSE 78699
// ComExitBuilding ( j ) ;
78690: LD_VAR 0 3
78694: PPUSH
78695: CALL_OW 122
// ct := 0 ;
78699: LD_ADDR_VAR 0 8
78703: PUSH
78704: LD_INT 0
78706: ST_TO_ADDR
// for k in x do
78707: LD_ADDR_VAR 0 4
78711: PUSH
78712: LD_VAR 0 11
78716: PUSH
78717: FOR_IN
78718: IFFALSE 78791
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
78720: LD_VAR 0 4
78724: PPUSH
78725: CALL_OW 264
78729: PUSH
78730: LD_INT 31
78732: EQUAL
78733: PUSH
78734: LD_VAR 0 4
78738: PPUSH
78739: CALL_OW 311
78743: NOT
78744: AND
78745: PUSH
78746: LD_VAR 0 4
78750: PPUSH
78751: CALL_OW 266
78755: PUSH
78756: LD_INT 36
78758: EQUAL
78759: PUSH
78760: LD_VAR 0 4
78764: PPUSH
78765: CALL_OW 313
78769: PUSH
78770: LD_INT 3
78772: LESS
78773: AND
78774: OR
78775: IFFALSE 78789
// begin ct := k ;
78777: LD_ADDR_VAR 0 8
78781: PUSH
78782: LD_VAR 0 4
78786: ST_TO_ADDR
// break ;
78787: GO 78791
// end ;
78789: GO 78717
78791: POP
78792: POP
// if ct then
78793: LD_VAR 0 8
78797: IFFALSE 78813
// ComEnterUnit ( j , ct ) ;
78799: LD_VAR 0 3
78803: PPUSH
78804: LD_VAR 0 8
78808: PPUSH
78809: CALL_OW 120
// end ; end ;
78813: GO 78566
78815: POP
78816: POP
// places := 0 ;
78817: LD_ADDR_VAR 0 5
78821: PUSH
78822: LD_INT 0
78824: ST_TO_ADDR
// for j = 1 to x do
78825: LD_ADDR_VAR 0 3
78829: PUSH
78830: DOUBLE
78831: LD_INT 1
78833: DEC
78834: ST_TO_ADDR
78835: LD_VAR 0 11
78839: PUSH
78840: FOR_TO
78841: IFFALSE 78896
// if GetWeapon ( x [ j ] ) = ar_control_tower then
78843: LD_VAR 0 11
78847: PUSH
78848: LD_VAR 0 3
78852: ARRAY
78853: PPUSH
78854: CALL_OW 264
78858: PUSH
78859: LD_INT 31
78861: EQUAL
78862: IFFALSE 78880
// places := places + 1 else
78864: LD_ADDR_VAR 0 5
78868: PUSH
78869: LD_VAR 0 5
78873: PUSH
78874: LD_INT 1
78876: PLUS
78877: ST_TO_ADDR
78878: GO 78894
// places := places + 3 ;
78880: LD_ADDR_VAR 0 5
78884: PUSH
78885: LD_VAR 0 5
78889: PUSH
78890: LD_INT 3
78892: PLUS
78893: ST_TO_ADDR
78894: GO 78840
78896: POP
78897: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
78898: LD_ADDR_VAR 0 6
78902: PUSH
78903: LD_EXP 58
78907: PUSH
78908: LD_VAR 0 2
78912: ARRAY
78913: PPUSH
78914: LD_INT 25
78916: PUSH
78917: LD_INT 3
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PPUSH
78924: CALL_OW 72
78928: PUSH
78929: LD_EXP 98
78933: PUSH
78934: LD_VAR 0 2
78938: ARRAY
78939: DIFF
78940: PPUSH
78941: LD_INT 3
78943: PPUSH
78944: CALL 55399 0 2
78948: ST_TO_ADDR
// if not tmp then
78949: LD_VAR 0 6
78953: NOT
78954: IFFALSE 78958
// continue ;
78956: GO 78338
// places := places - mc_remote_driver [ i ] ;
78958: LD_ADDR_VAR 0 5
78962: PUSH
78963: LD_VAR 0 5
78967: PUSH
78968: LD_EXP 98
78972: PUSH
78973: LD_VAR 0 2
78977: ARRAY
78978: MINUS
78979: ST_TO_ADDR
// if places then
78980: LD_VAR 0 5
78984: IFFALSE 79043
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78986: LD_ADDR_EXP 98
78990: PUSH
78991: LD_EXP 98
78995: PPUSH
78996: LD_VAR 0 2
79000: PPUSH
79001: LD_EXP 98
79005: PUSH
79006: LD_VAR 0 2
79010: ARRAY
79011: PUSH
79012: LD_VAR 0 6
79016: PUSH
79017: LD_INT 1
79019: ARRAY
79020: UNION
79021: PPUSH
79022: CALL_OW 1
79026: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79027: LD_VAR 0 6
79031: PUSH
79032: LD_INT 1
79034: ARRAY
79035: PPUSH
79036: LD_INT 126
79038: PPUSH
79039: CALL_OW 109
// end ; end ;
79043: GO 78338
79045: POP
79046: POP
// end ;
79047: LD_VAR 0 1
79051: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79052: LD_INT 0
79054: PPUSH
79055: PPUSH
79056: PPUSH
79057: PPUSH
79058: PPUSH
79059: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79060: LD_VAR 0 1
79064: NOT
79065: PUSH
79066: LD_VAR 0 2
79070: NOT
79071: OR
79072: PUSH
79073: LD_VAR 0 3
79077: NOT
79078: OR
79079: PUSH
79080: LD_VAR 0 4
79084: PUSH
79085: LD_INT 1
79087: PUSH
79088: LD_INT 2
79090: PUSH
79091: LD_INT 3
79093: PUSH
79094: LD_INT 4
79096: PUSH
79097: LD_INT 5
79099: PUSH
79100: LD_INT 8
79102: PUSH
79103: LD_INT 9
79105: PUSH
79106: LD_INT 15
79108: PUSH
79109: LD_INT 16
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: LIST
79119: LIST
79120: LIST
79121: LIST
79122: IN
79123: NOT
79124: OR
79125: IFFALSE 79129
// exit ;
79127: GO 80029
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79129: LD_ADDR_VAR 0 2
79133: PUSH
79134: LD_VAR 0 2
79138: PPUSH
79139: LD_INT 21
79141: PUSH
79142: LD_INT 3
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 24
79151: PUSH
79152: LD_INT 250
79154: PUSH
79155: EMPTY
79156: LIST
79157: LIST
79158: PUSH
79159: EMPTY
79160: LIST
79161: LIST
79162: PPUSH
79163: CALL_OW 72
79167: ST_TO_ADDR
// case class of 1 , 15 :
79168: LD_VAR 0 4
79172: PUSH
79173: LD_INT 1
79175: DOUBLE
79176: EQUAL
79177: IFTRUE 79187
79179: LD_INT 15
79181: DOUBLE
79182: EQUAL
79183: IFTRUE 79187
79185: GO 79272
79187: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79188: LD_ADDR_VAR 0 8
79192: PUSH
79193: LD_VAR 0 2
79197: PPUSH
79198: LD_INT 2
79200: PUSH
79201: LD_INT 30
79203: PUSH
79204: LD_INT 32
79206: PUSH
79207: EMPTY
79208: LIST
79209: LIST
79210: PUSH
79211: LD_INT 30
79213: PUSH
79214: LD_INT 31
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: LIST
79225: PPUSH
79226: CALL_OW 72
79230: PUSH
79231: LD_VAR 0 2
79235: PPUSH
79236: LD_INT 2
79238: PUSH
79239: LD_INT 30
79241: PUSH
79242: LD_INT 4
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PUSH
79249: LD_INT 30
79251: PUSH
79252: LD_INT 5
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: LIST
79263: PPUSH
79264: CALL_OW 72
79268: ADD
79269: ST_TO_ADDR
79270: GO 79518
79272: LD_INT 2
79274: DOUBLE
79275: EQUAL
79276: IFTRUE 79286
79278: LD_INT 16
79280: DOUBLE
79281: EQUAL
79282: IFTRUE 79286
79284: GO 79332
79286: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79287: LD_ADDR_VAR 0 8
79291: PUSH
79292: LD_VAR 0 2
79296: PPUSH
79297: LD_INT 2
79299: PUSH
79300: LD_INT 30
79302: PUSH
79303: LD_INT 0
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 30
79312: PUSH
79313: LD_INT 1
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: LIST
79324: PPUSH
79325: CALL_OW 72
79329: ST_TO_ADDR
79330: GO 79518
79332: LD_INT 3
79334: DOUBLE
79335: EQUAL
79336: IFTRUE 79340
79338: GO 79386
79340: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79341: LD_ADDR_VAR 0 8
79345: PUSH
79346: LD_VAR 0 2
79350: PPUSH
79351: LD_INT 2
79353: PUSH
79354: LD_INT 30
79356: PUSH
79357: LD_INT 2
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 30
79366: PUSH
79367: LD_INT 3
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: LIST
79378: PPUSH
79379: CALL_OW 72
79383: ST_TO_ADDR
79384: GO 79518
79386: LD_INT 4
79388: DOUBLE
79389: EQUAL
79390: IFTRUE 79394
79392: GO 79451
79394: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79395: LD_ADDR_VAR 0 8
79399: PUSH
79400: LD_VAR 0 2
79404: PPUSH
79405: LD_INT 2
79407: PUSH
79408: LD_INT 30
79410: PUSH
79411: LD_INT 6
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 30
79420: PUSH
79421: LD_INT 7
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: LD_INT 30
79430: PUSH
79431: LD_INT 8
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: PPUSH
79444: CALL_OW 72
79448: ST_TO_ADDR
79449: GO 79518
79451: LD_INT 5
79453: DOUBLE
79454: EQUAL
79455: IFTRUE 79471
79457: LD_INT 8
79459: DOUBLE
79460: EQUAL
79461: IFTRUE 79471
79463: LD_INT 9
79465: DOUBLE
79466: EQUAL
79467: IFTRUE 79471
79469: GO 79517
79471: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79472: LD_ADDR_VAR 0 8
79476: PUSH
79477: LD_VAR 0 2
79481: PPUSH
79482: LD_INT 2
79484: PUSH
79485: LD_INT 30
79487: PUSH
79488: LD_INT 4
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: PUSH
79495: LD_INT 30
79497: PUSH
79498: LD_INT 5
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: LIST
79509: PPUSH
79510: CALL_OW 72
79514: ST_TO_ADDR
79515: GO 79518
79517: POP
// if not tmp then
79518: LD_VAR 0 8
79522: NOT
79523: IFFALSE 79527
// exit ;
79525: GO 80029
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79527: LD_VAR 0 4
79531: PUSH
79532: LD_INT 1
79534: PUSH
79535: LD_INT 15
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: IN
79542: PUSH
79543: LD_EXP 67
79547: PUSH
79548: LD_VAR 0 1
79552: ARRAY
79553: AND
79554: IFFALSE 79710
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79556: LD_ADDR_VAR 0 9
79560: PUSH
79561: LD_EXP 67
79565: PUSH
79566: LD_VAR 0 1
79570: ARRAY
79571: PUSH
79572: LD_INT 1
79574: ARRAY
79575: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
79576: LD_VAR 0 9
79580: PUSH
79581: LD_EXP 68
79585: PUSH
79586: LD_VAR 0 1
79590: ARRAY
79591: IN
79592: NOT
79593: IFFALSE 79708
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
79595: LD_ADDR_EXP 68
79599: PUSH
79600: LD_EXP 68
79604: PPUSH
79605: LD_VAR 0 1
79609: PUSH
79610: LD_EXP 68
79614: PUSH
79615: LD_VAR 0 1
79619: ARRAY
79620: PUSH
79621: LD_INT 1
79623: PLUS
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PPUSH
79629: LD_VAR 0 9
79633: PPUSH
79634: CALL 21151 0 3
79638: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
79639: LD_ADDR_EXP 67
79643: PUSH
79644: LD_EXP 67
79648: PPUSH
79649: LD_VAR 0 1
79653: PPUSH
79654: LD_EXP 67
79658: PUSH
79659: LD_VAR 0 1
79663: ARRAY
79664: PUSH
79665: LD_VAR 0 9
79669: DIFF
79670: PPUSH
79671: CALL_OW 1
79675: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
79676: LD_VAR 0 3
79680: PPUSH
79681: LD_EXP 68
79685: PUSH
79686: LD_VAR 0 1
79690: ARRAY
79691: PUSH
79692: LD_EXP 68
79696: PUSH
79697: LD_VAR 0 1
79701: ARRAY
79702: ARRAY
79703: PPUSH
79704: CALL_OW 120
// end ; exit ;
79708: GO 80029
// end ; if tmp > 1 then
79710: LD_VAR 0 8
79714: PUSH
79715: LD_INT 1
79717: GREATER
79718: IFFALSE 79822
// for i = 2 to tmp do
79720: LD_ADDR_VAR 0 6
79724: PUSH
79725: DOUBLE
79726: LD_INT 2
79728: DEC
79729: ST_TO_ADDR
79730: LD_VAR 0 8
79734: PUSH
79735: FOR_TO
79736: IFFALSE 79820
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
79738: LD_VAR 0 8
79742: PUSH
79743: LD_VAR 0 6
79747: ARRAY
79748: PPUSH
79749: CALL_OW 461
79753: PUSH
79754: LD_INT 6
79756: EQUAL
79757: IFFALSE 79818
// begin x := tmp [ i ] ;
79759: LD_ADDR_VAR 0 9
79763: PUSH
79764: LD_VAR 0 8
79768: PUSH
79769: LD_VAR 0 6
79773: ARRAY
79774: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
79775: LD_ADDR_VAR 0 8
79779: PUSH
79780: LD_VAR 0 8
79784: PPUSH
79785: LD_VAR 0 6
79789: PPUSH
79790: CALL_OW 3
79794: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
79795: LD_ADDR_VAR 0 8
79799: PUSH
79800: LD_VAR 0 8
79804: PPUSH
79805: LD_INT 1
79807: PPUSH
79808: LD_VAR 0 9
79812: PPUSH
79813: CALL_OW 2
79817: ST_TO_ADDR
// end ;
79818: GO 79735
79820: POP
79821: POP
// for i in tmp do
79822: LD_ADDR_VAR 0 6
79826: PUSH
79827: LD_VAR 0 8
79831: PUSH
79832: FOR_IN
79833: IFFALSE 79902
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
79835: LD_VAR 0 6
79839: PPUSH
79840: CALL_OW 313
79844: PUSH
79845: LD_INT 6
79847: LESS
79848: PUSH
79849: LD_VAR 0 6
79853: PPUSH
79854: CALL_OW 266
79858: PUSH
79859: LD_INT 31
79861: PUSH
79862: LD_INT 32
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: IN
79869: NOT
79870: AND
79871: PUSH
79872: LD_VAR 0 6
79876: PPUSH
79877: CALL_OW 313
79881: PUSH
79882: LD_INT 0
79884: EQUAL
79885: OR
79886: IFFALSE 79900
// begin j := i ;
79888: LD_ADDR_VAR 0 7
79892: PUSH
79893: LD_VAR 0 6
79897: ST_TO_ADDR
// break ;
79898: GO 79902
// end ; end ;
79900: GO 79832
79902: POP
79903: POP
// if j then
79904: LD_VAR 0 7
79908: IFFALSE 79926
// ComEnterUnit ( unit , j ) else
79910: LD_VAR 0 3
79914: PPUSH
79915: LD_VAR 0 7
79919: PPUSH
79920: CALL_OW 120
79924: GO 80029
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79926: LD_ADDR_VAR 0 10
79930: PUSH
79931: LD_VAR 0 2
79935: PPUSH
79936: LD_INT 2
79938: PUSH
79939: LD_INT 30
79941: PUSH
79942: LD_INT 0
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 30
79951: PUSH
79952: LD_INT 1
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: LIST
79963: PPUSH
79964: CALL_OW 72
79968: ST_TO_ADDR
// if depot then
79969: LD_VAR 0 10
79973: IFFALSE 80029
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79975: LD_ADDR_VAR 0 10
79979: PUSH
79980: LD_VAR 0 10
79984: PPUSH
79985: LD_VAR 0 3
79989: PPUSH
79990: CALL_OW 74
79994: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79995: LD_VAR 0 3
79999: PPUSH
80000: LD_VAR 0 10
80004: PPUSH
80005: CALL_OW 296
80009: PUSH
80010: LD_INT 10
80012: GREATER
80013: IFFALSE 80029
// ComStandNearbyBuilding ( unit , depot ) ;
80015: LD_VAR 0 3
80019: PPUSH
80020: LD_VAR 0 10
80024: PPUSH
80025: CALL 15503 0 2
// end ; end ; end ;
80029: LD_VAR 0 5
80033: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80034: LD_INT 0
80036: PPUSH
80037: PPUSH
80038: PPUSH
80039: PPUSH
// if not mc_bases then
80040: LD_EXP 58
80044: NOT
80045: IFFALSE 80049
// exit ;
80047: GO 80288
// for i = 1 to mc_bases do
80049: LD_ADDR_VAR 0 2
80053: PUSH
80054: DOUBLE
80055: LD_INT 1
80057: DEC
80058: ST_TO_ADDR
80059: LD_EXP 58
80063: PUSH
80064: FOR_TO
80065: IFFALSE 80286
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80067: LD_ADDR_VAR 0 4
80071: PUSH
80072: LD_EXP 58
80076: PUSH
80077: LD_VAR 0 2
80081: ARRAY
80082: PPUSH
80083: LD_INT 21
80085: PUSH
80086: LD_INT 1
80088: PUSH
80089: EMPTY
80090: LIST
80091: LIST
80092: PPUSH
80093: CALL_OW 72
80097: PUSH
80098: LD_EXP 87
80102: PUSH
80103: LD_VAR 0 2
80107: ARRAY
80108: UNION
80109: ST_TO_ADDR
// if not tmp then
80110: LD_VAR 0 4
80114: NOT
80115: IFFALSE 80119
// continue ;
80117: GO 80064
// for j in tmp do
80119: LD_ADDR_VAR 0 3
80123: PUSH
80124: LD_VAR 0 4
80128: PUSH
80129: FOR_IN
80130: IFFALSE 80282
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80132: LD_VAR 0 3
80136: PPUSH
80137: CALL_OW 110
80141: NOT
80142: PUSH
80143: LD_VAR 0 3
80147: PPUSH
80148: CALL_OW 314
80152: NOT
80153: AND
80154: PUSH
80155: LD_VAR 0 3
80159: PPUSH
80160: CALL_OW 311
80164: NOT
80165: AND
80166: PUSH
80167: LD_VAR 0 3
80171: PPUSH
80172: CALL_OW 310
80176: NOT
80177: AND
80178: PUSH
80179: LD_VAR 0 3
80183: PUSH
80184: LD_EXP 61
80188: PUSH
80189: LD_VAR 0 2
80193: ARRAY
80194: PUSH
80195: LD_INT 1
80197: ARRAY
80198: IN
80199: NOT
80200: AND
80201: PUSH
80202: LD_VAR 0 3
80206: PUSH
80207: LD_EXP 61
80211: PUSH
80212: LD_VAR 0 2
80216: ARRAY
80217: PUSH
80218: LD_INT 2
80220: ARRAY
80221: IN
80222: NOT
80223: AND
80224: PUSH
80225: LD_VAR 0 3
80229: PUSH
80230: LD_EXP 70
80234: PUSH
80235: LD_VAR 0 2
80239: ARRAY
80240: IN
80241: NOT
80242: AND
80243: IFFALSE 80280
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80245: LD_VAR 0 2
80249: PPUSH
80250: LD_EXP 58
80254: PUSH
80255: LD_VAR 0 2
80259: ARRAY
80260: PPUSH
80261: LD_VAR 0 3
80265: PPUSH
80266: LD_VAR 0 3
80270: PPUSH
80271: CALL_OW 257
80275: PPUSH
80276: CALL 79052 0 4
// end ;
80280: GO 80129
80282: POP
80283: POP
// end ;
80284: GO 80064
80286: POP
80287: POP
// end ;
80288: LD_VAR 0 1
80292: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80293: LD_INT 0
80295: PPUSH
80296: PPUSH
80297: PPUSH
80298: PPUSH
80299: PPUSH
80300: PPUSH
// if not mc_bases [ base ] then
80301: LD_EXP 58
80305: PUSH
80306: LD_VAR 0 1
80310: ARRAY
80311: NOT
80312: IFFALSE 80316
// exit ;
80314: GO 80498
// tmp := [ ] ;
80316: LD_ADDR_VAR 0 6
80320: PUSH
80321: EMPTY
80322: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80323: LD_ADDR_VAR 0 7
80327: PUSH
80328: LD_VAR 0 3
80332: PPUSH
80333: LD_INT 0
80335: PPUSH
80336: CALL_OW 517
80340: ST_TO_ADDR
// if not list then
80341: LD_VAR 0 7
80345: NOT
80346: IFFALSE 80350
// exit ;
80348: GO 80498
// for i = 1 to amount do
80350: LD_ADDR_VAR 0 5
80354: PUSH
80355: DOUBLE
80356: LD_INT 1
80358: DEC
80359: ST_TO_ADDR
80360: LD_VAR 0 2
80364: PUSH
80365: FOR_TO
80366: IFFALSE 80446
// begin x := rand ( 1 , list [ 1 ] ) ;
80368: LD_ADDR_VAR 0 8
80372: PUSH
80373: LD_INT 1
80375: PPUSH
80376: LD_VAR 0 7
80380: PUSH
80381: LD_INT 1
80383: ARRAY
80384: PPUSH
80385: CALL_OW 12
80389: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80390: LD_ADDR_VAR 0 6
80394: PUSH
80395: LD_VAR 0 6
80399: PPUSH
80400: LD_VAR 0 5
80404: PPUSH
80405: LD_VAR 0 7
80409: PUSH
80410: LD_INT 1
80412: ARRAY
80413: PUSH
80414: LD_VAR 0 8
80418: ARRAY
80419: PUSH
80420: LD_VAR 0 7
80424: PUSH
80425: LD_INT 2
80427: ARRAY
80428: PUSH
80429: LD_VAR 0 8
80433: ARRAY
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PPUSH
80439: CALL_OW 1
80443: ST_TO_ADDR
// end ;
80444: GO 80365
80446: POP
80447: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80448: LD_ADDR_EXP 71
80452: PUSH
80453: LD_EXP 71
80457: PPUSH
80458: LD_VAR 0 1
80462: PPUSH
80463: LD_VAR 0 6
80467: PPUSH
80468: CALL_OW 1
80472: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80473: LD_ADDR_EXP 73
80477: PUSH
80478: LD_EXP 73
80482: PPUSH
80483: LD_VAR 0 1
80487: PPUSH
80488: LD_VAR 0 3
80492: PPUSH
80493: CALL_OW 1
80497: ST_TO_ADDR
// end ;
80498: LD_VAR 0 4
80502: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80503: LD_INT 0
80505: PPUSH
// if not mc_bases [ base ] then
80506: LD_EXP 58
80510: PUSH
80511: LD_VAR 0 1
80515: ARRAY
80516: NOT
80517: IFFALSE 80521
// exit ;
80519: GO 80546
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80521: LD_ADDR_EXP 63
80525: PUSH
80526: LD_EXP 63
80530: PPUSH
80531: LD_VAR 0 1
80535: PPUSH
80536: LD_VAR 0 2
80540: PPUSH
80541: CALL_OW 1
80545: ST_TO_ADDR
// end ;
80546: LD_VAR 0 3
80550: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80551: LD_INT 0
80553: PPUSH
// if not mc_bases [ base ] then
80554: LD_EXP 58
80558: PUSH
80559: LD_VAR 0 1
80563: ARRAY
80564: NOT
80565: IFFALSE 80569
// exit ;
80567: GO 80606
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
80569: LD_ADDR_EXP 63
80573: PUSH
80574: LD_EXP 63
80578: PPUSH
80579: LD_VAR 0 1
80583: PPUSH
80584: LD_EXP 63
80588: PUSH
80589: LD_VAR 0 1
80593: ARRAY
80594: PUSH
80595: LD_VAR 0 2
80599: UNION
80600: PPUSH
80601: CALL_OW 1
80605: ST_TO_ADDR
// end ;
80606: LD_VAR 0 3
80610: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
80611: LD_INT 0
80613: PPUSH
// if not mc_bases [ base ] then
80614: LD_EXP 58
80618: PUSH
80619: LD_VAR 0 1
80623: ARRAY
80624: NOT
80625: IFFALSE 80629
// exit ;
80627: GO 80654
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
80629: LD_ADDR_EXP 79
80633: PUSH
80634: LD_EXP 79
80638: PPUSH
80639: LD_VAR 0 1
80643: PPUSH
80644: LD_VAR 0 2
80648: PPUSH
80649: CALL_OW 1
80653: ST_TO_ADDR
// end ;
80654: LD_VAR 0 3
80658: RET
// export function MC_InsertProduceList ( base , components ) ; begin
80659: LD_INT 0
80661: PPUSH
// if not mc_bases [ base ] then
80662: LD_EXP 58
80666: PUSH
80667: LD_VAR 0 1
80671: ARRAY
80672: NOT
80673: IFFALSE 80677
// exit ;
80675: GO 80714
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
80677: LD_ADDR_EXP 79
80681: PUSH
80682: LD_EXP 79
80686: PPUSH
80687: LD_VAR 0 1
80691: PPUSH
80692: LD_EXP 79
80696: PUSH
80697: LD_VAR 0 1
80701: ARRAY
80702: PUSH
80703: LD_VAR 0 2
80707: ADD
80708: PPUSH
80709: CALL_OW 1
80713: ST_TO_ADDR
// end ;
80714: LD_VAR 0 3
80718: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
80719: LD_INT 0
80721: PPUSH
// if not mc_bases [ base ] then
80722: LD_EXP 58
80726: PUSH
80727: LD_VAR 0 1
80731: ARRAY
80732: NOT
80733: IFFALSE 80737
// exit ;
80735: GO 80791
// mc_defender := Replace ( mc_defender , base , deflist ) ;
80737: LD_ADDR_EXP 80
80741: PUSH
80742: LD_EXP 80
80746: PPUSH
80747: LD_VAR 0 1
80751: PPUSH
80752: LD_VAR 0 2
80756: PPUSH
80757: CALL_OW 1
80761: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
80762: LD_ADDR_EXP 69
80766: PUSH
80767: LD_EXP 69
80771: PPUSH
80772: LD_VAR 0 1
80776: PPUSH
80777: LD_VAR 0 2
80781: PUSH
80782: LD_INT 0
80784: PLUS
80785: PPUSH
80786: CALL_OW 1
80790: ST_TO_ADDR
// end ;
80791: LD_VAR 0 3
80795: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
80796: LD_INT 0
80798: PPUSH
// if not mc_bases [ base ] then
80799: LD_EXP 58
80803: PUSH
80804: LD_VAR 0 1
80808: ARRAY
80809: NOT
80810: IFFALSE 80814
// exit ;
80812: GO 80839
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
80814: LD_ADDR_EXP 69
80818: PUSH
80819: LD_EXP 69
80823: PPUSH
80824: LD_VAR 0 1
80828: PPUSH
80829: LD_VAR 0 2
80833: PPUSH
80834: CALL_OW 1
80838: ST_TO_ADDR
// end ;
80839: LD_VAR 0 3
80843: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
80844: LD_INT 0
80846: PPUSH
80847: PPUSH
80848: PPUSH
80849: PPUSH
// if not mc_bases [ base ] then
80850: LD_EXP 58
80854: PUSH
80855: LD_VAR 0 1
80859: ARRAY
80860: NOT
80861: IFFALSE 80865
// exit ;
80863: GO 80930
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
80865: LD_ADDR_EXP 78
80869: PUSH
80870: LD_EXP 78
80874: PPUSH
80875: LD_VAR 0 1
80879: PUSH
80880: LD_EXP 78
80884: PUSH
80885: LD_VAR 0 1
80889: ARRAY
80890: PUSH
80891: LD_INT 1
80893: PLUS
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PPUSH
80899: LD_VAR 0 1
80903: PUSH
80904: LD_VAR 0 2
80908: PUSH
80909: LD_VAR 0 3
80913: PUSH
80914: LD_VAR 0 4
80918: PUSH
80919: EMPTY
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: PPUSH
80925: CALL 21151 0 3
80929: ST_TO_ADDR
// end ;
80930: LD_VAR 0 5
80934: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
80935: LD_INT 0
80937: PPUSH
// if not mc_bases [ base ] then
80938: LD_EXP 58
80942: PUSH
80943: LD_VAR 0 1
80947: ARRAY
80948: NOT
80949: IFFALSE 80953
// exit ;
80951: GO 80978
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80953: LD_ADDR_EXP 95
80957: PUSH
80958: LD_EXP 95
80962: PPUSH
80963: LD_VAR 0 1
80967: PPUSH
80968: LD_VAR 0 2
80972: PPUSH
80973: CALL_OW 1
80977: ST_TO_ADDR
// end ;
80978: LD_VAR 0 3
80982: RET
// export function MC_GetMinesField ( base ) ; begin
80983: LD_INT 0
80985: PPUSH
// result := mc_mines [ base ] ;
80986: LD_ADDR_VAR 0 2
80990: PUSH
80991: LD_EXP 71
80995: PUSH
80996: LD_VAR 0 1
81000: ARRAY
81001: ST_TO_ADDR
// end ;
81002: LD_VAR 0 2
81006: RET
// export function MC_GetProduceList ( base ) ; begin
81007: LD_INT 0
81009: PPUSH
// result := mc_produce [ base ] ;
81010: LD_ADDR_VAR 0 2
81014: PUSH
81015: LD_EXP 79
81019: PUSH
81020: LD_VAR 0 1
81024: ARRAY
81025: ST_TO_ADDR
// end ;
81026: LD_VAR 0 2
81030: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81031: LD_INT 0
81033: PPUSH
81034: PPUSH
// if not mc_bases then
81035: LD_EXP 58
81039: NOT
81040: IFFALSE 81044
// exit ;
81042: GO 81109
// if mc_bases [ base ] then
81044: LD_EXP 58
81048: PUSH
81049: LD_VAR 0 1
81053: ARRAY
81054: IFFALSE 81109
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81056: LD_ADDR_VAR 0 3
81060: PUSH
81061: LD_EXP 58
81065: PUSH
81066: LD_VAR 0 1
81070: ARRAY
81071: PPUSH
81072: LD_INT 30
81074: PUSH
81075: LD_VAR 0 2
81079: PUSH
81080: EMPTY
81081: LIST
81082: LIST
81083: PPUSH
81084: CALL_OW 72
81088: ST_TO_ADDR
// if result then
81089: LD_VAR 0 3
81093: IFFALSE 81109
// result := result [ 1 ] ;
81095: LD_ADDR_VAR 0 3
81099: PUSH
81100: LD_VAR 0 3
81104: PUSH
81105: LD_INT 1
81107: ARRAY
81108: ST_TO_ADDR
// end ; end ;
81109: LD_VAR 0 3
81113: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81114: LD_INT 0
81116: PPUSH
81117: PPUSH
// if not mc_bases then
81118: LD_EXP 58
81122: NOT
81123: IFFALSE 81127
// exit ;
81125: GO 81172
// if mc_bases [ base ] then
81127: LD_EXP 58
81131: PUSH
81132: LD_VAR 0 1
81136: ARRAY
81137: IFFALSE 81172
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81139: LD_ADDR_VAR 0 3
81143: PUSH
81144: LD_EXP 58
81148: PUSH
81149: LD_VAR 0 1
81153: ARRAY
81154: PPUSH
81155: LD_INT 30
81157: PUSH
81158: LD_VAR 0 2
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: PPUSH
81167: CALL_OW 72
81171: ST_TO_ADDR
// end ;
81172: LD_VAR 0 3
81176: RET
// export function MC_SetTame ( base , area ) ; begin
81177: LD_INT 0
81179: PPUSH
// if not mc_bases or not base then
81180: LD_EXP 58
81184: NOT
81185: PUSH
81186: LD_VAR 0 1
81190: NOT
81191: OR
81192: IFFALSE 81196
// exit ;
81194: GO 81221
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81196: LD_ADDR_EXP 86
81200: PUSH
81201: LD_EXP 86
81205: PPUSH
81206: LD_VAR 0 1
81210: PPUSH
81211: LD_VAR 0 2
81215: PPUSH
81216: CALL_OW 1
81220: ST_TO_ADDR
// end ;
81221: LD_VAR 0 3
81225: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81226: LD_INT 0
81228: PPUSH
81229: PPUSH
// if not mc_bases or not base then
81230: LD_EXP 58
81234: NOT
81235: PUSH
81236: LD_VAR 0 1
81240: NOT
81241: OR
81242: IFFALSE 81246
// exit ;
81244: GO 81348
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81246: LD_ADDR_VAR 0 4
81250: PUSH
81251: LD_EXP 58
81255: PUSH
81256: LD_VAR 0 1
81260: ARRAY
81261: PPUSH
81262: LD_INT 30
81264: PUSH
81265: LD_VAR 0 2
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PPUSH
81274: CALL_OW 72
81278: ST_TO_ADDR
// if not tmp then
81279: LD_VAR 0 4
81283: NOT
81284: IFFALSE 81288
// exit ;
81286: GO 81348
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81288: LD_ADDR_EXP 90
81292: PUSH
81293: LD_EXP 90
81297: PPUSH
81298: LD_VAR 0 1
81302: PPUSH
81303: LD_EXP 90
81307: PUSH
81308: LD_VAR 0 1
81312: ARRAY
81313: PPUSH
81314: LD_EXP 90
81318: PUSH
81319: LD_VAR 0 1
81323: ARRAY
81324: PUSH
81325: LD_INT 1
81327: PLUS
81328: PPUSH
81329: LD_VAR 0 4
81333: PUSH
81334: LD_INT 1
81336: ARRAY
81337: PPUSH
81338: CALL_OW 2
81342: PPUSH
81343: CALL_OW 1
81347: ST_TO_ADDR
// end ;
81348: LD_VAR 0 3
81352: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81353: LD_INT 0
81355: PPUSH
81356: PPUSH
// if not mc_bases or not base or not kinds then
81357: LD_EXP 58
81361: NOT
81362: PUSH
81363: LD_VAR 0 1
81367: NOT
81368: OR
81369: PUSH
81370: LD_VAR 0 2
81374: NOT
81375: OR
81376: IFFALSE 81380
// exit ;
81378: GO 81441
// for i in kinds do
81380: LD_ADDR_VAR 0 4
81384: PUSH
81385: LD_VAR 0 2
81389: PUSH
81390: FOR_IN
81391: IFFALSE 81439
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81393: LD_ADDR_EXP 92
81397: PUSH
81398: LD_EXP 92
81402: PPUSH
81403: LD_VAR 0 1
81407: PUSH
81408: LD_EXP 92
81412: PUSH
81413: LD_VAR 0 1
81417: ARRAY
81418: PUSH
81419: LD_INT 1
81421: PLUS
81422: PUSH
81423: EMPTY
81424: LIST
81425: LIST
81426: PPUSH
81427: LD_VAR 0 4
81431: PPUSH
81432: CALL 21151 0 3
81436: ST_TO_ADDR
81437: GO 81390
81439: POP
81440: POP
// end ;
81441: LD_VAR 0 3
81445: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81446: LD_INT 0
81448: PPUSH
// if not mc_bases or not base or not areas then
81449: LD_EXP 58
81453: NOT
81454: PUSH
81455: LD_VAR 0 1
81459: NOT
81460: OR
81461: PUSH
81462: LD_VAR 0 2
81466: NOT
81467: OR
81468: IFFALSE 81472
// exit ;
81470: GO 81497
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81472: LD_ADDR_EXP 76
81476: PUSH
81477: LD_EXP 76
81481: PPUSH
81482: LD_VAR 0 1
81486: PPUSH
81487: LD_VAR 0 2
81491: PPUSH
81492: CALL_OW 1
81496: ST_TO_ADDR
// end ;
81497: LD_VAR 0 3
81501: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81502: LD_INT 0
81504: PPUSH
// if not mc_bases or not base or not teleports_exit then
81505: LD_EXP 58
81509: NOT
81510: PUSH
81511: LD_VAR 0 1
81515: NOT
81516: OR
81517: PUSH
81518: LD_VAR 0 2
81522: NOT
81523: OR
81524: IFFALSE 81528
// exit ;
81526: GO 81553
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81528: LD_ADDR_EXP 93
81532: PUSH
81533: LD_EXP 93
81537: PPUSH
81538: LD_VAR 0 1
81542: PPUSH
81543: LD_VAR 0 2
81547: PPUSH
81548: CALL_OW 1
81552: ST_TO_ADDR
// end ;
81553: LD_VAR 0 3
81557: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81558: LD_INT 0
81560: PPUSH
81561: PPUSH
81562: PPUSH
// if not mc_bases or not base or not ext_list then
81563: LD_EXP 58
81567: NOT
81568: PUSH
81569: LD_VAR 0 1
81573: NOT
81574: OR
81575: PUSH
81576: LD_VAR 0 5
81580: NOT
81581: OR
81582: IFFALSE 81586
// exit ;
81584: GO 81759
// tmp := GetFacExtXYD ( x , y , d ) ;
81586: LD_ADDR_VAR 0 8
81590: PUSH
81591: LD_VAR 0 2
81595: PPUSH
81596: LD_VAR 0 3
81600: PPUSH
81601: LD_VAR 0 4
81605: PPUSH
81606: CALL 54529 0 3
81610: ST_TO_ADDR
// if not tmp then
81611: LD_VAR 0 8
81615: NOT
81616: IFFALSE 81620
// exit ;
81618: GO 81759
// for i in tmp do
81620: LD_ADDR_VAR 0 7
81624: PUSH
81625: LD_VAR 0 8
81629: PUSH
81630: FOR_IN
81631: IFFALSE 81757
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
81633: LD_ADDR_EXP 63
81637: PUSH
81638: LD_EXP 63
81642: PPUSH
81643: LD_VAR 0 1
81647: PPUSH
81648: LD_EXP 63
81652: PUSH
81653: LD_VAR 0 1
81657: ARRAY
81658: PPUSH
81659: LD_EXP 63
81663: PUSH
81664: LD_VAR 0 1
81668: ARRAY
81669: PUSH
81670: LD_INT 1
81672: PLUS
81673: PPUSH
81674: LD_VAR 0 5
81678: PUSH
81679: LD_INT 1
81681: ARRAY
81682: PUSH
81683: LD_VAR 0 7
81687: PUSH
81688: LD_INT 1
81690: ARRAY
81691: PUSH
81692: LD_VAR 0 7
81696: PUSH
81697: LD_INT 2
81699: ARRAY
81700: PUSH
81701: LD_VAR 0 7
81705: PUSH
81706: LD_INT 3
81708: ARRAY
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: LIST
81714: LIST
81715: PPUSH
81716: CALL_OW 2
81720: PPUSH
81721: CALL_OW 1
81725: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
81726: LD_ADDR_VAR 0 5
81730: PUSH
81731: LD_VAR 0 5
81735: PPUSH
81736: LD_INT 1
81738: PPUSH
81739: CALL_OW 3
81743: ST_TO_ADDR
// if not ext_list then
81744: LD_VAR 0 5
81748: NOT
81749: IFFALSE 81755
// exit ;
81751: POP
81752: POP
81753: GO 81759
// end ;
81755: GO 81630
81757: POP
81758: POP
// end ;
81759: LD_VAR 0 6
81763: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
81764: LD_INT 0
81766: PPUSH
// if not mc_bases or not base or not weapon_list then
81767: LD_EXP 58
81771: NOT
81772: PUSH
81773: LD_VAR 0 1
81777: NOT
81778: OR
81779: PUSH
81780: LD_VAR 0 2
81784: NOT
81785: OR
81786: IFFALSE 81790
// exit ;
81788: GO 81815
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
81790: LD_ADDR_EXP 97
81794: PUSH
81795: LD_EXP 97
81799: PPUSH
81800: LD_VAR 0 1
81804: PPUSH
81805: LD_VAR 0 2
81809: PPUSH
81810: CALL_OW 1
81814: ST_TO_ADDR
// end ;
81815: LD_VAR 0 3
81819: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
81820: LD_INT 0
81822: PPUSH
// if not mc_bases or not base or not tech_list then
81823: LD_EXP 58
81827: NOT
81828: PUSH
81829: LD_VAR 0 1
81833: NOT
81834: OR
81835: PUSH
81836: LD_VAR 0 2
81840: NOT
81841: OR
81842: IFFALSE 81846
// exit ;
81844: GO 81871
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
81846: LD_ADDR_EXP 85
81850: PUSH
81851: LD_EXP 85
81855: PPUSH
81856: LD_VAR 0 1
81860: PPUSH
81861: LD_VAR 0 2
81865: PPUSH
81866: CALL_OW 1
81870: ST_TO_ADDR
// end ;
81871: LD_VAR 0 3
81875: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
81876: LD_INT 0
81878: PPUSH
// if not mc_bases or not parking_area or not base then
81879: LD_EXP 58
81883: NOT
81884: PUSH
81885: LD_VAR 0 2
81889: NOT
81890: OR
81891: PUSH
81892: LD_VAR 0 1
81896: NOT
81897: OR
81898: IFFALSE 81902
// exit ;
81900: GO 81927
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
81902: LD_ADDR_EXP 82
81906: PUSH
81907: LD_EXP 82
81911: PPUSH
81912: LD_VAR 0 1
81916: PPUSH
81917: LD_VAR 0 2
81921: PPUSH
81922: CALL_OW 1
81926: ST_TO_ADDR
// end ;
81927: LD_VAR 0 3
81931: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
81932: LD_INT 0
81934: PPUSH
// if not mc_bases or not base or not scan_area then
81935: LD_EXP 58
81939: NOT
81940: PUSH
81941: LD_VAR 0 1
81945: NOT
81946: OR
81947: PUSH
81948: LD_VAR 0 2
81952: NOT
81953: OR
81954: IFFALSE 81958
// exit ;
81956: GO 81983
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
81958: LD_ADDR_EXP 83
81962: PUSH
81963: LD_EXP 83
81967: PPUSH
81968: LD_VAR 0 1
81972: PPUSH
81973: LD_VAR 0 2
81977: PPUSH
81978: CALL_OW 1
81982: ST_TO_ADDR
// end ;
81983: LD_VAR 0 3
81987: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81988: LD_INT 0
81990: PPUSH
81991: PPUSH
// if not mc_bases or not base then
81992: LD_EXP 58
81996: NOT
81997: PUSH
81998: LD_VAR 0 1
82002: NOT
82003: OR
82004: IFFALSE 82008
// exit ;
82006: GO 82072
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82008: LD_ADDR_VAR 0 3
82012: PUSH
82013: LD_INT 1
82015: PUSH
82016: LD_INT 2
82018: PUSH
82019: LD_INT 3
82021: PUSH
82022: LD_INT 4
82024: PUSH
82025: LD_INT 11
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82035: LD_ADDR_EXP 85
82039: PUSH
82040: LD_EXP 85
82044: PPUSH
82045: LD_VAR 0 1
82049: PPUSH
82050: LD_EXP 85
82054: PUSH
82055: LD_VAR 0 1
82059: ARRAY
82060: PUSH
82061: LD_VAR 0 3
82065: DIFF
82066: PPUSH
82067: CALL_OW 1
82071: ST_TO_ADDR
// end ;
82072: LD_VAR 0 2
82076: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82077: LD_INT 0
82079: PPUSH
// result := mc_vehicles [ base ] ;
82080: LD_ADDR_VAR 0 3
82084: PUSH
82085: LD_EXP 77
82089: PUSH
82090: LD_VAR 0 1
82094: ARRAY
82095: ST_TO_ADDR
// if onlyCombat then
82096: LD_VAR 0 2
82100: IFFALSE 82265
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82102: LD_ADDR_VAR 0 3
82106: PUSH
82107: LD_VAR 0 3
82111: PUSH
82112: LD_VAR 0 3
82116: PPUSH
82117: LD_INT 2
82119: PUSH
82120: LD_INT 34
82122: PUSH
82123: LD_INT 12
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 34
82132: PUSH
82133: LD_INT 51
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: PUSH
82140: LD_INT 34
82142: PUSH
82143: LD_EXP 102
82147: PUSH
82148: EMPTY
82149: LIST
82150: LIST
82151: PUSH
82152: LD_INT 34
82154: PUSH
82155: LD_INT 32
82157: PUSH
82158: EMPTY
82159: LIST
82160: LIST
82161: PUSH
82162: LD_INT 34
82164: PUSH
82165: LD_INT 13
82167: PUSH
82168: EMPTY
82169: LIST
82170: LIST
82171: PUSH
82172: LD_INT 34
82174: PUSH
82175: LD_INT 52
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: LD_INT 34
82184: PUSH
82185: LD_INT 14
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: LD_INT 34
82194: PUSH
82195: LD_INT 53
82197: PUSH
82198: EMPTY
82199: LIST
82200: LIST
82201: PUSH
82202: LD_INT 34
82204: PUSH
82205: LD_EXP 101
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 34
82216: PUSH
82217: LD_INT 31
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 34
82226: PUSH
82227: LD_INT 48
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 34
82236: PUSH
82237: LD_INT 8
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: LIST
82256: LIST
82257: LIST
82258: PPUSH
82259: CALL_OW 72
82263: DIFF
82264: ST_TO_ADDR
// end ; end_of_file
82265: LD_VAR 0 3
82269: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82270: LD_INT 0
82272: PPUSH
82273: PPUSH
82274: PPUSH
// if not mc_bases or not skirmish then
82275: LD_EXP 58
82279: NOT
82280: PUSH
82281: LD_EXP 56
82285: NOT
82286: OR
82287: IFFALSE 82291
// exit ;
82289: GO 82456
// for i = 1 to mc_bases do
82291: LD_ADDR_VAR 0 4
82295: PUSH
82296: DOUBLE
82297: LD_INT 1
82299: DEC
82300: ST_TO_ADDR
82301: LD_EXP 58
82305: PUSH
82306: FOR_TO
82307: IFFALSE 82454
// begin if sci in mc_bases [ i ] then
82309: LD_VAR 0 2
82313: PUSH
82314: LD_EXP 58
82318: PUSH
82319: LD_VAR 0 4
82323: ARRAY
82324: IN
82325: IFFALSE 82452
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82327: LD_ADDR_EXP 87
82331: PUSH
82332: LD_EXP 87
82336: PPUSH
82337: LD_VAR 0 4
82341: PUSH
82342: LD_EXP 87
82346: PUSH
82347: LD_VAR 0 4
82351: ARRAY
82352: PUSH
82353: LD_INT 1
82355: PLUS
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: PPUSH
82361: LD_VAR 0 1
82365: PPUSH
82366: CALL 21151 0 3
82370: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82371: LD_ADDR_VAR 0 5
82375: PUSH
82376: LD_EXP 58
82380: PUSH
82381: LD_VAR 0 4
82385: ARRAY
82386: PPUSH
82387: LD_INT 2
82389: PUSH
82390: LD_INT 30
82392: PUSH
82393: LD_INT 0
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PUSH
82400: LD_INT 30
82402: PUSH
82403: LD_INT 1
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: LIST
82414: PPUSH
82415: CALL_OW 72
82419: PPUSH
82420: LD_VAR 0 1
82424: PPUSH
82425: CALL_OW 74
82429: ST_TO_ADDR
// if tmp then
82430: LD_VAR 0 5
82434: IFFALSE 82450
// ComStandNearbyBuilding ( ape , tmp ) ;
82436: LD_VAR 0 1
82440: PPUSH
82441: LD_VAR 0 5
82445: PPUSH
82446: CALL 15503 0 2
// break ;
82450: GO 82454
// end ; end ;
82452: GO 82306
82454: POP
82455: POP
// end ;
82456: LD_VAR 0 3
82460: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82461: LD_INT 0
82463: PPUSH
82464: PPUSH
82465: PPUSH
// if not mc_bases or not skirmish then
82466: LD_EXP 58
82470: NOT
82471: PUSH
82472: LD_EXP 56
82476: NOT
82477: OR
82478: IFFALSE 82482
// exit ;
82480: GO 82571
// for i = 1 to mc_bases do
82482: LD_ADDR_VAR 0 4
82486: PUSH
82487: DOUBLE
82488: LD_INT 1
82490: DEC
82491: ST_TO_ADDR
82492: LD_EXP 58
82496: PUSH
82497: FOR_TO
82498: IFFALSE 82569
// begin if building in mc_busy_turret_list [ i ] then
82500: LD_VAR 0 1
82504: PUSH
82505: LD_EXP 68
82509: PUSH
82510: LD_VAR 0 4
82514: ARRAY
82515: IN
82516: IFFALSE 82567
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82518: LD_ADDR_VAR 0 5
82522: PUSH
82523: LD_EXP 68
82527: PUSH
82528: LD_VAR 0 4
82532: ARRAY
82533: PUSH
82534: LD_VAR 0 1
82538: DIFF
82539: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82540: LD_ADDR_EXP 68
82544: PUSH
82545: LD_EXP 68
82549: PPUSH
82550: LD_VAR 0 4
82554: PPUSH
82555: LD_VAR 0 5
82559: PPUSH
82560: CALL_OW 1
82564: ST_TO_ADDR
// break ;
82565: GO 82569
// end ; end ;
82567: GO 82497
82569: POP
82570: POP
// end ;
82571: LD_VAR 0 3
82575: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
82576: LD_INT 0
82578: PPUSH
82579: PPUSH
82580: PPUSH
// if not mc_bases or not skirmish then
82581: LD_EXP 58
82585: NOT
82586: PUSH
82587: LD_EXP 56
82591: NOT
82592: OR
82593: IFFALSE 82597
// exit ;
82595: GO 82796
// for i = 1 to mc_bases do
82597: LD_ADDR_VAR 0 5
82601: PUSH
82602: DOUBLE
82603: LD_INT 1
82605: DEC
82606: ST_TO_ADDR
82607: LD_EXP 58
82611: PUSH
82612: FOR_TO
82613: IFFALSE 82794
// if building in mc_bases [ i ] then
82615: LD_VAR 0 1
82619: PUSH
82620: LD_EXP 58
82624: PUSH
82625: LD_VAR 0 5
82629: ARRAY
82630: IN
82631: IFFALSE 82792
// begin tmp := mc_bases [ i ] diff building ;
82633: LD_ADDR_VAR 0 6
82637: PUSH
82638: LD_EXP 58
82642: PUSH
82643: LD_VAR 0 5
82647: ARRAY
82648: PUSH
82649: LD_VAR 0 1
82653: DIFF
82654: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
82655: LD_ADDR_EXP 58
82659: PUSH
82660: LD_EXP 58
82664: PPUSH
82665: LD_VAR 0 5
82669: PPUSH
82670: LD_VAR 0 6
82674: PPUSH
82675: CALL_OW 1
82679: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
82680: LD_VAR 0 1
82684: PUSH
82685: LD_EXP 66
82689: PUSH
82690: LD_VAR 0 5
82694: ARRAY
82695: IN
82696: IFFALSE 82735
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
82698: LD_ADDR_EXP 66
82702: PUSH
82703: LD_EXP 66
82707: PPUSH
82708: LD_VAR 0 5
82712: PPUSH
82713: LD_EXP 66
82717: PUSH
82718: LD_VAR 0 5
82722: ARRAY
82723: PUSH
82724: LD_VAR 0 1
82728: DIFF
82729: PPUSH
82730: CALL_OW 1
82734: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
82735: LD_VAR 0 1
82739: PUSH
82740: LD_EXP 67
82744: PUSH
82745: LD_VAR 0 5
82749: ARRAY
82750: IN
82751: IFFALSE 82790
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
82753: LD_ADDR_EXP 67
82757: PUSH
82758: LD_EXP 67
82762: PPUSH
82763: LD_VAR 0 5
82767: PPUSH
82768: LD_EXP 67
82772: PUSH
82773: LD_VAR 0 5
82777: ARRAY
82778: PUSH
82779: LD_VAR 0 1
82783: DIFF
82784: PPUSH
82785: CALL_OW 1
82789: ST_TO_ADDR
// break ;
82790: GO 82794
// end ;
82792: GO 82612
82794: POP
82795: POP
// end ;
82796: LD_VAR 0 4
82800: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
82801: LD_INT 0
82803: PPUSH
82804: PPUSH
82805: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
82806: LD_EXP 58
82810: NOT
82811: PUSH
82812: LD_EXP 56
82816: NOT
82817: OR
82818: PUSH
82819: LD_VAR 0 3
82823: PUSH
82824: LD_EXP 84
82828: IN
82829: NOT
82830: OR
82831: IFFALSE 82835
// exit ;
82833: GO 82958
// for i = 1 to mc_vehicles do
82835: LD_ADDR_VAR 0 6
82839: PUSH
82840: DOUBLE
82841: LD_INT 1
82843: DEC
82844: ST_TO_ADDR
82845: LD_EXP 77
82849: PUSH
82850: FOR_TO
82851: IFFALSE 82956
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
82853: LD_VAR 0 2
82857: PUSH
82858: LD_EXP 77
82862: PUSH
82863: LD_VAR 0 6
82867: ARRAY
82868: IN
82869: PUSH
82870: LD_VAR 0 1
82874: PUSH
82875: LD_EXP 77
82879: PUSH
82880: LD_VAR 0 6
82884: ARRAY
82885: IN
82886: OR
82887: IFFALSE 82954
// begin tmp := mc_vehicles [ i ] diff old ;
82889: LD_ADDR_VAR 0 7
82893: PUSH
82894: LD_EXP 77
82898: PUSH
82899: LD_VAR 0 6
82903: ARRAY
82904: PUSH
82905: LD_VAR 0 2
82909: DIFF
82910: ST_TO_ADDR
// tmp := tmp diff new ;
82911: LD_ADDR_VAR 0 7
82915: PUSH
82916: LD_VAR 0 7
82920: PUSH
82921: LD_VAR 0 1
82925: DIFF
82926: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
82927: LD_ADDR_EXP 77
82931: PUSH
82932: LD_EXP 77
82936: PPUSH
82937: LD_VAR 0 6
82941: PPUSH
82942: LD_VAR 0 7
82946: PPUSH
82947: CALL_OW 1
82951: ST_TO_ADDR
// break ;
82952: GO 82956
// end ;
82954: GO 82850
82956: POP
82957: POP
// end ;
82958: LD_VAR 0 5
82962: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
82963: LD_INT 0
82965: PPUSH
82966: PPUSH
82967: PPUSH
82968: PPUSH
// if not mc_bases or not skirmish then
82969: LD_EXP 58
82973: NOT
82974: PUSH
82975: LD_EXP 56
82979: NOT
82980: OR
82981: IFFALSE 82985
// exit ;
82983: GO 83362
// side := GetSide ( vehicle ) ;
82985: LD_ADDR_VAR 0 5
82989: PUSH
82990: LD_VAR 0 1
82994: PPUSH
82995: CALL_OW 255
82999: ST_TO_ADDR
// for i = 1 to mc_bases do
83000: LD_ADDR_VAR 0 4
83004: PUSH
83005: DOUBLE
83006: LD_INT 1
83008: DEC
83009: ST_TO_ADDR
83010: LD_EXP 58
83014: PUSH
83015: FOR_TO
83016: IFFALSE 83360
// begin if factory in mc_bases [ i ] then
83018: LD_VAR 0 2
83022: PUSH
83023: LD_EXP 58
83027: PUSH
83028: LD_VAR 0 4
83032: ARRAY
83033: IN
83034: IFFALSE 83358
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
83036: LD_EXP 80
83040: PUSH
83041: LD_VAR 0 4
83045: ARRAY
83046: PUSH
83047: LD_EXP 69
83051: PUSH
83052: LD_VAR 0 4
83056: ARRAY
83057: LESS
83058: PUSH
83059: LD_VAR 0 1
83063: PPUSH
83064: CALL_OW 264
83068: PUSH
83069: LD_INT 31
83071: PUSH
83072: LD_INT 32
83074: PUSH
83075: LD_INT 51
83077: PUSH
83078: LD_EXP 102
83082: PUSH
83083: LD_INT 12
83085: PUSH
83086: LD_INT 30
83088: PUSH
83089: LD_EXP 101
83093: PUSH
83094: LD_INT 11
83096: PUSH
83097: LD_INT 53
83099: PUSH
83100: LD_INT 14
83102: PUSH
83103: LD_EXP 105
83107: PUSH
83108: LD_INT 29
83110: PUSH
83111: LD_EXP 103
83115: PUSH
83116: LD_INT 13
83118: PUSH
83119: LD_INT 52
83121: PUSH
83122: LD_INT 48
83124: PUSH
83125: LD_INT 8
83127: PUSH
83128: EMPTY
83129: LIST
83130: LIST
83131: LIST
83132: LIST
83133: LIST
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: LIST
83139: LIST
83140: LIST
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: IN
83147: NOT
83148: AND
83149: IFFALSE 83197
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83151: LD_ADDR_EXP 80
83155: PUSH
83156: LD_EXP 80
83160: PPUSH
83161: LD_VAR 0 4
83165: PUSH
83166: LD_EXP 80
83170: PUSH
83171: LD_VAR 0 4
83175: ARRAY
83176: PUSH
83177: LD_INT 1
83179: PLUS
83180: PUSH
83181: EMPTY
83182: LIST
83183: LIST
83184: PPUSH
83185: LD_VAR 0 1
83189: PPUSH
83190: CALL 21151 0 3
83194: ST_TO_ADDR
83195: GO 83241
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83197: LD_ADDR_EXP 77
83201: PUSH
83202: LD_EXP 77
83206: PPUSH
83207: LD_VAR 0 4
83211: PUSH
83212: LD_EXP 77
83216: PUSH
83217: LD_VAR 0 4
83221: ARRAY
83222: PUSH
83223: LD_INT 1
83225: PLUS
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PPUSH
83231: LD_VAR 0 1
83235: PPUSH
83236: CALL 21151 0 3
83240: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83241: LD_VAR 0 1
83245: PPUSH
83246: CALL_OW 263
83250: PUSH
83251: LD_INT 2
83253: EQUAL
83254: IFFALSE 83274
// begin repeat wait ( 0 0$1 ) ;
83256: LD_INT 35
83258: PPUSH
83259: CALL_OW 67
// until IsControledBy ( vehicle ) ;
83263: LD_VAR 0 1
83267: PPUSH
83268: CALL_OW 312
83272: IFFALSE 83256
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83274: LD_VAR 0 1
83278: PPUSH
83279: LD_EXP 82
83283: PUSH
83284: LD_VAR 0 4
83288: ARRAY
83289: PPUSH
83290: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83294: LD_VAR 0 1
83298: PPUSH
83299: CALL_OW 263
83303: PUSH
83304: LD_INT 1
83306: NONEQUAL
83307: IFFALSE 83311
// break ;
83309: GO 83360
// repeat wait ( 0 0$1 ) ;
83311: LD_INT 35
83313: PPUSH
83314: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83318: LD_VAR 0 1
83322: PPUSH
83323: LD_EXP 82
83327: PUSH
83328: LD_VAR 0 4
83332: ARRAY
83333: PPUSH
83334: CALL_OW 308
83338: IFFALSE 83311
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83340: LD_VAR 0 1
83344: PPUSH
83345: CALL_OW 311
83349: PPUSH
83350: CALL_OW 121
// exit ;
83354: POP
83355: POP
83356: GO 83362
// end ; end ;
83358: GO 83015
83360: POP
83361: POP
// end ;
83362: LD_VAR 0 3
83366: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83367: LD_INT 0
83369: PPUSH
83370: PPUSH
83371: PPUSH
83372: PPUSH
// if not mc_bases or not skirmish then
83373: LD_EXP 58
83377: NOT
83378: PUSH
83379: LD_EXP 56
83383: NOT
83384: OR
83385: IFFALSE 83389
// exit ;
83387: GO 83742
// repeat wait ( 0 0$1 ) ;
83389: LD_INT 35
83391: PPUSH
83392: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83396: LD_VAR 0 2
83400: PPUSH
83401: LD_VAR 0 3
83405: PPUSH
83406: CALL_OW 284
83410: IFFALSE 83389
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83412: LD_VAR 0 2
83416: PPUSH
83417: LD_VAR 0 3
83421: PPUSH
83422: CALL_OW 283
83426: PUSH
83427: LD_INT 4
83429: EQUAL
83430: IFFALSE 83434
// exit ;
83432: GO 83742
// for i = 1 to mc_bases do
83434: LD_ADDR_VAR 0 7
83438: PUSH
83439: DOUBLE
83440: LD_INT 1
83442: DEC
83443: ST_TO_ADDR
83444: LD_EXP 58
83448: PUSH
83449: FOR_TO
83450: IFFALSE 83740
// begin if mc_crates_area [ i ] then
83452: LD_EXP 76
83456: PUSH
83457: LD_VAR 0 7
83461: ARRAY
83462: IFFALSE 83573
// for j in mc_crates_area [ i ] do
83464: LD_ADDR_VAR 0 8
83468: PUSH
83469: LD_EXP 76
83473: PUSH
83474: LD_VAR 0 7
83478: ARRAY
83479: PUSH
83480: FOR_IN
83481: IFFALSE 83571
// if InArea ( x , y , j ) then
83483: LD_VAR 0 2
83487: PPUSH
83488: LD_VAR 0 3
83492: PPUSH
83493: LD_VAR 0 8
83497: PPUSH
83498: CALL_OW 309
83502: IFFALSE 83569
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83504: LD_ADDR_EXP 74
83508: PUSH
83509: LD_EXP 74
83513: PPUSH
83514: LD_VAR 0 7
83518: PUSH
83519: LD_EXP 74
83523: PUSH
83524: LD_VAR 0 7
83528: ARRAY
83529: PUSH
83530: LD_INT 1
83532: PLUS
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PPUSH
83538: LD_VAR 0 4
83542: PUSH
83543: LD_VAR 0 2
83547: PUSH
83548: LD_VAR 0 3
83552: PUSH
83553: EMPTY
83554: LIST
83555: LIST
83556: LIST
83557: PPUSH
83558: CALL 21151 0 3
83562: ST_TO_ADDR
// exit ;
83563: POP
83564: POP
83565: POP
83566: POP
83567: GO 83742
// end ;
83569: GO 83480
83571: POP
83572: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83573: LD_ADDR_VAR 0 9
83577: PUSH
83578: LD_EXP 58
83582: PUSH
83583: LD_VAR 0 7
83587: ARRAY
83588: PPUSH
83589: LD_INT 2
83591: PUSH
83592: LD_INT 30
83594: PUSH
83595: LD_INT 0
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 30
83604: PUSH
83605: LD_INT 1
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: LIST
83616: PPUSH
83617: CALL_OW 72
83621: ST_TO_ADDR
// if not depot then
83622: LD_VAR 0 9
83626: NOT
83627: IFFALSE 83631
// continue ;
83629: GO 83449
// for j in depot do
83631: LD_ADDR_VAR 0 8
83635: PUSH
83636: LD_VAR 0 9
83640: PUSH
83641: FOR_IN
83642: IFFALSE 83736
// if GetDistUnitXY ( j , x , y ) < 30 then
83644: LD_VAR 0 8
83648: PPUSH
83649: LD_VAR 0 2
83653: PPUSH
83654: LD_VAR 0 3
83658: PPUSH
83659: CALL_OW 297
83663: PUSH
83664: LD_INT 30
83666: LESS
83667: IFFALSE 83734
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83669: LD_ADDR_EXP 74
83673: PUSH
83674: LD_EXP 74
83678: PPUSH
83679: LD_VAR 0 7
83683: PUSH
83684: LD_EXP 74
83688: PUSH
83689: LD_VAR 0 7
83693: ARRAY
83694: PUSH
83695: LD_INT 1
83697: PLUS
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PPUSH
83703: LD_VAR 0 4
83707: PUSH
83708: LD_VAR 0 2
83712: PUSH
83713: LD_VAR 0 3
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: LIST
83722: PPUSH
83723: CALL 21151 0 3
83727: ST_TO_ADDR
// exit ;
83728: POP
83729: POP
83730: POP
83731: POP
83732: GO 83742
// end ;
83734: GO 83641
83736: POP
83737: POP
// end ;
83738: GO 83449
83740: POP
83741: POP
// end ;
83742: LD_VAR 0 6
83746: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
83747: LD_INT 0
83749: PPUSH
83750: PPUSH
83751: PPUSH
83752: PPUSH
// if not mc_bases or not skirmish then
83753: LD_EXP 58
83757: NOT
83758: PUSH
83759: LD_EXP 56
83763: NOT
83764: OR
83765: IFFALSE 83769
// exit ;
83767: GO 84046
// side := GetSide ( lab ) ;
83769: LD_ADDR_VAR 0 4
83773: PUSH
83774: LD_VAR 0 2
83778: PPUSH
83779: CALL_OW 255
83783: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
83784: LD_VAR 0 4
83788: PUSH
83789: LD_EXP 84
83793: IN
83794: NOT
83795: PUSH
83796: LD_EXP 85
83800: NOT
83801: OR
83802: PUSH
83803: LD_EXP 58
83807: NOT
83808: OR
83809: IFFALSE 83813
// exit ;
83811: GO 84046
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
83813: LD_ADDR_EXP 85
83817: PUSH
83818: LD_EXP 85
83822: PPUSH
83823: LD_VAR 0 4
83827: PPUSH
83828: LD_EXP 85
83832: PUSH
83833: LD_VAR 0 4
83837: ARRAY
83838: PUSH
83839: LD_VAR 0 1
83843: DIFF
83844: PPUSH
83845: CALL_OW 1
83849: ST_TO_ADDR
// for i = 1 to mc_bases do
83850: LD_ADDR_VAR 0 5
83854: PUSH
83855: DOUBLE
83856: LD_INT 1
83858: DEC
83859: ST_TO_ADDR
83860: LD_EXP 58
83864: PUSH
83865: FOR_TO
83866: IFFALSE 84044
// begin if lab in mc_bases [ i ] then
83868: LD_VAR 0 2
83872: PUSH
83873: LD_EXP 58
83877: PUSH
83878: LD_VAR 0 5
83882: ARRAY
83883: IN
83884: IFFALSE 84042
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
83886: LD_VAR 0 1
83890: PUSH
83891: LD_INT 11
83893: PUSH
83894: LD_INT 4
83896: PUSH
83897: LD_INT 3
83899: PUSH
83900: LD_INT 2
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: LIST
83907: LIST
83908: IN
83909: PUSH
83910: LD_EXP 88
83914: PUSH
83915: LD_VAR 0 5
83919: ARRAY
83920: AND
83921: IFFALSE 84042
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
83923: LD_ADDR_VAR 0 6
83927: PUSH
83928: LD_EXP 88
83932: PUSH
83933: LD_VAR 0 5
83937: ARRAY
83938: PUSH
83939: LD_INT 1
83941: ARRAY
83942: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83943: LD_ADDR_EXP 88
83947: PUSH
83948: LD_EXP 88
83952: PPUSH
83953: LD_VAR 0 5
83957: PPUSH
83958: EMPTY
83959: PPUSH
83960: CALL_OW 1
83964: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
83965: LD_VAR 0 6
83969: PPUSH
83970: LD_INT 0
83972: PPUSH
83973: CALL_OW 109
// ComExitBuilding ( tmp ) ;
83977: LD_VAR 0 6
83981: PPUSH
83982: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
83986: LD_ADDR_EXP 87
83990: PUSH
83991: LD_EXP 87
83995: PPUSH
83996: LD_VAR 0 5
84000: PPUSH
84001: LD_EXP 87
84005: PUSH
84006: LD_VAR 0 5
84010: ARRAY
84011: PPUSH
84012: LD_INT 1
84014: PPUSH
84015: LD_VAR 0 6
84019: PPUSH
84020: CALL_OW 2
84024: PPUSH
84025: CALL_OW 1
84029: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84030: LD_VAR 0 5
84034: PPUSH
84035: LD_INT 112
84037: PPUSH
84038: CALL 61154 0 2
// end ; end ; end ;
84042: GO 83865
84044: POP
84045: POP
// end ;
84046: LD_VAR 0 3
84050: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84051: LD_INT 0
84053: PPUSH
84054: PPUSH
84055: PPUSH
84056: PPUSH
84057: PPUSH
84058: PPUSH
84059: PPUSH
84060: PPUSH
// if not mc_bases or not skirmish then
84061: LD_EXP 58
84065: NOT
84066: PUSH
84067: LD_EXP 56
84071: NOT
84072: OR
84073: IFFALSE 84077
// exit ;
84075: GO 85314
// for i = 1 to mc_bases do
84077: LD_ADDR_VAR 0 3
84081: PUSH
84082: DOUBLE
84083: LD_INT 1
84085: DEC
84086: ST_TO_ADDR
84087: LD_EXP 58
84091: PUSH
84092: FOR_TO
84093: IFFALSE 85312
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84095: LD_VAR 0 1
84099: PUSH
84100: LD_EXP 58
84104: PUSH
84105: LD_VAR 0 3
84109: ARRAY
84110: IN
84111: PUSH
84112: LD_VAR 0 1
84116: PUSH
84117: LD_EXP 65
84121: PUSH
84122: LD_VAR 0 3
84126: ARRAY
84127: IN
84128: OR
84129: PUSH
84130: LD_VAR 0 1
84134: PUSH
84135: LD_EXP 80
84139: PUSH
84140: LD_VAR 0 3
84144: ARRAY
84145: IN
84146: OR
84147: PUSH
84148: LD_VAR 0 1
84152: PUSH
84153: LD_EXP 77
84157: PUSH
84158: LD_VAR 0 3
84162: ARRAY
84163: IN
84164: OR
84165: PUSH
84166: LD_VAR 0 1
84170: PUSH
84171: LD_EXP 87
84175: PUSH
84176: LD_VAR 0 3
84180: ARRAY
84181: IN
84182: OR
84183: PUSH
84184: LD_VAR 0 1
84188: PUSH
84189: LD_EXP 88
84193: PUSH
84194: LD_VAR 0 3
84198: ARRAY
84199: IN
84200: OR
84201: IFFALSE 85310
// begin if un in mc_ape [ i ] then
84203: LD_VAR 0 1
84207: PUSH
84208: LD_EXP 87
84212: PUSH
84213: LD_VAR 0 3
84217: ARRAY
84218: IN
84219: IFFALSE 84258
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84221: LD_ADDR_EXP 87
84225: PUSH
84226: LD_EXP 87
84230: PPUSH
84231: LD_VAR 0 3
84235: PPUSH
84236: LD_EXP 87
84240: PUSH
84241: LD_VAR 0 3
84245: ARRAY
84246: PUSH
84247: LD_VAR 0 1
84251: DIFF
84252: PPUSH
84253: CALL_OW 1
84257: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84258: LD_VAR 0 1
84262: PUSH
84263: LD_EXP 88
84267: PUSH
84268: LD_VAR 0 3
84272: ARRAY
84273: IN
84274: IFFALSE 84298
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84276: LD_ADDR_EXP 88
84280: PUSH
84281: LD_EXP 88
84285: PPUSH
84286: LD_VAR 0 3
84290: PPUSH
84291: EMPTY
84292: PPUSH
84293: CALL_OW 1
84297: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
84298: LD_VAR 0 1
84302: PPUSH
84303: CALL_OW 247
84307: PUSH
84308: LD_INT 2
84310: EQUAL
84311: PUSH
84312: LD_VAR 0 1
84316: PPUSH
84317: CALL_OW 110
84321: PUSH
84322: LD_INT 20
84324: EQUAL
84325: PUSH
84326: LD_VAR 0 1
84330: PUSH
84331: LD_EXP 80
84335: PUSH
84336: LD_VAR 0 3
84340: ARRAY
84341: IN
84342: OR
84343: PUSH
84344: LD_VAR 0 1
84348: PPUSH
84349: CALL_OW 264
84353: PUSH
84354: LD_INT 12
84356: PUSH
84357: LD_INT 51
84359: PUSH
84360: LD_EXP 102
84364: PUSH
84365: LD_INT 32
84367: PUSH
84368: LD_INT 13
84370: PUSH
84371: LD_INT 52
84373: PUSH
84374: EMPTY
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: IN
84382: OR
84383: AND
84384: IFFALSE 84562
// begin if un in mc_defender [ i ] then
84386: LD_VAR 0 1
84390: PUSH
84391: LD_EXP 80
84395: PUSH
84396: LD_VAR 0 3
84400: ARRAY
84401: IN
84402: IFFALSE 84441
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84404: LD_ADDR_EXP 80
84408: PUSH
84409: LD_EXP 80
84413: PPUSH
84414: LD_VAR 0 3
84418: PPUSH
84419: LD_EXP 80
84423: PUSH
84424: LD_VAR 0 3
84428: ARRAY
84429: PUSH
84430: LD_VAR 0 1
84434: DIFF
84435: PPUSH
84436: CALL_OW 1
84440: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84441: LD_ADDR_VAR 0 8
84445: PUSH
84446: LD_VAR 0 3
84450: PPUSH
84451: LD_INT 3
84453: PPUSH
84454: CALL 81114 0 2
84458: ST_TO_ADDR
// if fac then
84459: LD_VAR 0 8
84463: IFFALSE 84562
// begin for j in fac do
84465: LD_ADDR_VAR 0 4
84469: PUSH
84470: LD_VAR 0 8
84474: PUSH
84475: FOR_IN
84476: IFFALSE 84560
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84478: LD_ADDR_VAR 0 9
84482: PUSH
84483: LD_VAR 0 8
84487: PPUSH
84488: LD_VAR 0 1
84492: PPUSH
84493: CALL_OW 265
84497: PPUSH
84498: LD_VAR 0 1
84502: PPUSH
84503: CALL_OW 262
84507: PPUSH
84508: LD_VAR 0 1
84512: PPUSH
84513: CALL_OW 263
84517: PPUSH
84518: LD_VAR 0 1
84522: PPUSH
84523: CALL_OW 264
84527: PPUSH
84528: CALL 18683 0 5
84532: ST_TO_ADDR
// if components then
84533: LD_VAR 0 9
84537: IFFALSE 84558
// begin MC_InsertProduceList ( i , [ components ] ) ;
84539: LD_VAR 0 3
84543: PPUSH
84544: LD_VAR 0 9
84548: PUSH
84549: EMPTY
84550: LIST
84551: PPUSH
84552: CALL 80659 0 2
// break ;
84556: GO 84560
// end ; end ;
84558: GO 84475
84560: POP
84561: POP
// end ; end ; if GetType ( un ) = unit_building then
84562: LD_VAR 0 1
84566: PPUSH
84567: CALL_OW 247
84571: PUSH
84572: LD_INT 3
84574: EQUAL
84575: IFFALSE 84978
// begin btype := GetBType ( un ) ;
84577: LD_ADDR_VAR 0 5
84581: PUSH
84582: LD_VAR 0 1
84586: PPUSH
84587: CALL_OW 266
84591: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
84592: LD_VAR 0 5
84596: PUSH
84597: LD_INT 29
84599: PUSH
84600: LD_INT 30
84602: PUSH
84603: EMPTY
84604: LIST
84605: LIST
84606: IN
84607: IFFALSE 84680
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
84609: LD_VAR 0 1
84613: PPUSH
84614: CALL_OW 250
84618: PPUSH
84619: LD_VAR 0 1
84623: PPUSH
84624: CALL_OW 251
84628: PPUSH
84629: LD_VAR 0 1
84633: PPUSH
84634: CALL_OW 255
84638: PPUSH
84639: CALL_OW 440
84643: NOT
84644: IFFALSE 84680
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
84646: LD_VAR 0 1
84650: PPUSH
84651: CALL_OW 250
84655: PPUSH
84656: LD_VAR 0 1
84660: PPUSH
84661: CALL_OW 251
84665: PPUSH
84666: LD_VAR 0 1
84670: PPUSH
84671: CALL_OW 255
84675: PPUSH
84676: CALL_OW 441
// end ; if btype = b_warehouse then
84680: LD_VAR 0 5
84684: PUSH
84685: LD_INT 1
84687: EQUAL
84688: IFFALSE 84706
// begin btype := b_depot ;
84690: LD_ADDR_VAR 0 5
84694: PUSH
84695: LD_INT 0
84697: ST_TO_ADDR
// pos := 1 ;
84698: LD_ADDR_VAR 0 6
84702: PUSH
84703: LD_INT 1
84705: ST_TO_ADDR
// end ; if btype = b_factory then
84706: LD_VAR 0 5
84710: PUSH
84711: LD_INT 3
84713: EQUAL
84714: IFFALSE 84732
// begin btype := b_workshop ;
84716: LD_ADDR_VAR 0 5
84720: PUSH
84721: LD_INT 2
84723: ST_TO_ADDR
// pos := 1 ;
84724: LD_ADDR_VAR 0 6
84728: PUSH
84729: LD_INT 1
84731: ST_TO_ADDR
// end ; if btype = b_barracks then
84732: LD_VAR 0 5
84736: PUSH
84737: LD_INT 5
84739: EQUAL
84740: IFFALSE 84750
// btype := b_armoury ;
84742: LD_ADDR_VAR 0 5
84746: PUSH
84747: LD_INT 4
84749: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
84750: LD_VAR 0 5
84754: PUSH
84755: LD_INT 7
84757: PUSH
84758: LD_INT 8
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: IN
84765: IFFALSE 84775
// btype := b_lab ;
84767: LD_ADDR_VAR 0 5
84771: PUSH
84772: LD_INT 6
84774: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
84775: LD_ADDR_EXP 63
84779: PUSH
84780: LD_EXP 63
84784: PPUSH
84785: LD_VAR 0 3
84789: PUSH
84790: LD_EXP 63
84794: PUSH
84795: LD_VAR 0 3
84799: ARRAY
84800: PUSH
84801: LD_INT 1
84803: PLUS
84804: PUSH
84805: EMPTY
84806: LIST
84807: LIST
84808: PPUSH
84809: LD_VAR 0 5
84813: PUSH
84814: LD_VAR 0 1
84818: PPUSH
84819: CALL_OW 250
84823: PUSH
84824: LD_VAR 0 1
84828: PPUSH
84829: CALL_OW 251
84833: PUSH
84834: LD_VAR 0 1
84838: PPUSH
84839: CALL_OW 254
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: LIST
84848: LIST
84849: PPUSH
84850: CALL 21151 0 3
84854: ST_TO_ADDR
// if pos = 1 then
84855: LD_VAR 0 6
84859: PUSH
84860: LD_INT 1
84862: EQUAL
84863: IFFALSE 84978
// begin tmp := mc_build_list [ i ] ;
84865: LD_ADDR_VAR 0 7
84869: PUSH
84870: LD_EXP 63
84874: PUSH
84875: LD_VAR 0 3
84879: ARRAY
84880: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
84881: LD_VAR 0 7
84885: PPUSH
84886: LD_INT 2
84888: PUSH
84889: LD_INT 30
84891: PUSH
84892: LD_INT 0
84894: PUSH
84895: EMPTY
84896: LIST
84897: LIST
84898: PUSH
84899: LD_INT 30
84901: PUSH
84902: LD_INT 1
84904: PUSH
84905: EMPTY
84906: LIST
84907: LIST
84908: PUSH
84909: EMPTY
84910: LIST
84911: LIST
84912: LIST
84913: PPUSH
84914: CALL_OW 72
84918: IFFALSE 84928
// pos := 2 ;
84920: LD_ADDR_VAR 0 6
84924: PUSH
84925: LD_INT 2
84927: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
84928: LD_ADDR_VAR 0 7
84932: PUSH
84933: LD_VAR 0 7
84937: PPUSH
84938: LD_VAR 0 6
84942: PPUSH
84943: LD_VAR 0 7
84947: PPUSH
84948: CALL 21477 0 3
84952: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
84953: LD_ADDR_EXP 63
84957: PUSH
84958: LD_EXP 63
84962: PPUSH
84963: LD_VAR 0 3
84967: PPUSH
84968: LD_VAR 0 7
84972: PPUSH
84973: CALL_OW 1
84977: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
84978: LD_VAR 0 1
84982: PUSH
84983: LD_EXP 58
84987: PUSH
84988: LD_VAR 0 3
84992: ARRAY
84993: IN
84994: IFFALSE 85033
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
84996: LD_ADDR_EXP 58
85000: PUSH
85001: LD_EXP 58
85005: PPUSH
85006: LD_VAR 0 3
85010: PPUSH
85011: LD_EXP 58
85015: PUSH
85016: LD_VAR 0 3
85020: ARRAY
85021: PUSH
85022: LD_VAR 0 1
85026: DIFF
85027: PPUSH
85028: CALL_OW 1
85032: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85033: LD_VAR 0 1
85037: PUSH
85038: LD_EXP 65
85042: PUSH
85043: LD_VAR 0 3
85047: ARRAY
85048: IN
85049: IFFALSE 85088
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85051: LD_ADDR_EXP 65
85055: PUSH
85056: LD_EXP 65
85060: PPUSH
85061: LD_VAR 0 3
85065: PPUSH
85066: LD_EXP 65
85070: PUSH
85071: LD_VAR 0 3
85075: ARRAY
85076: PUSH
85077: LD_VAR 0 1
85081: DIFF
85082: PPUSH
85083: CALL_OW 1
85087: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85088: LD_VAR 0 1
85092: PUSH
85093: LD_EXP 77
85097: PUSH
85098: LD_VAR 0 3
85102: ARRAY
85103: IN
85104: IFFALSE 85143
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85106: LD_ADDR_EXP 77
85110: PUSH
85111: LD_EXP 77
85115: PPUSH
85116: LD_VAR 0 3
85120: PPUSH
85121: LD_EXP 77
85125: PUSH
85126: LD_VAR 0 3
85130: ARRAY
85131: PUSH
85132: LD_VAR 0 1
85136: DIFF
85137: PPUSH
85138: CALL_OW 1
85142: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85143: LD_VAR 0 1
85147: PUSH
85148: LD_EXP 80
85152: PUSH
85153: LD_VAR 0 3
85157: ARRAY
85158: IN
85159: IFFALSE 85198
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85161: LD_ADDR_EXP 80
85165: PUSH
85166: LD_EXP 80
85170: PPUSH
85171: LD_VAR 0 3
85175: PPUSH
85176: LD_EXP 80
85180: PUSH
85181: LD_VAR 0 3
85185: ARRAY
85186: PUSH
85187: LD_VAR 0 1
85191: DIFF
85192: PPUSH
85193: CALL_OW 1
85197: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85198: LD_VAR 0 1
85202: PUSH
85203: LD_EXP 67
85207: PUSH
85208: LD_VAR 0 3
85212: ARRAY
85213: IN
85214: IFFALSE 85253
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85216: LD_ADDR_EXP 67
85220: PUSH
85221: LD_EXP 67
85225: PPUSH
85226: LD_VAR 0 3
85230: PPUSH
85231: LD_EXP 67
85235: PUSH
85236: LD_VAR 0 3
85240: ARRAY
85241: PUSH
85242: LD_VAR 0 1
85246: DIFF
85247: PPUSH
85248: CALL_OW 1
85252: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85253: LD_VAR 0 1
85257: PUSH
85258: LD_EXP 66
85262: PUSH
85263: LD_VAR 0 3
85267: ARRAY
85268: IN
85269: IFFALSE 85308
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85271: LD_ADDR_EXP 66
85275: PUSH
85276: LD_EXP 66
85280: PPUSH
85281: LD_VAR 0 3
85285: PPUSH
85286: LD_EXP 66
85290: PUSH
85291: LD_VAR 0 3
85295: ARRAY
85296: PUSH
85297: LD_VAR 0 1
85301: DIFF
85302: PPUSH
85303: CALL_OW 1
85307: ST_TO_ADDR
// end ; break ;
85308: GO 85312
// end ;
85310: GO 84092
85312: POP
85313: POP
// end ;
85314: LD_VAR 0 2
85318: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85319: LD_INT 0
85321: PPUSH
85322: PPUSH
85323: PPUSH
// if not mc_bases or not skirmish then
85324: LD_EXP 58
85328: NOT
85329: PUSH
85330: LD_EXP 56
85334: NOT
85335: OR
85336: IFFALSE 85340
// exit ;
85338: GO 85555
// for i = 1 to mc_bases do
85340: LD_ADDR_VAR 0 3
85344: PUSH
85345: DOUBLE
85346: LD_INT 1
85348: DEC
85349: ST_TO_ADDR
85350: LD_EXP 58
85354: PUSH
85355: FOR_TO
85356: IFFALSE 85553
// begin if building in mc_construct_list [ i ] then
85358: LD_VAR 0 1
85362: PUSH
85363: LD_EXP 65
85367: PUSH
85368: LD_VAR 0 3
85372: ARRAY
85373: IN
85374: IFFALSE 85551
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85376: LD_ADDR_EXP 65
85380: PUSH
85381: LD_EXP 65
85385: PPUSH
85386: LD_VAR 0 3
85390: PPUSH
85391: LD_EXP 65
85395: PUSH
85396: LD_VAR 0 3
85400: ARRAY
85401: PUSH
85402: LD_VAR 0 1
85406: DIFF
85407: PPUSH
85408: CALL_OW 1
85412: ST_TO_ADDR
// if building in mc_lab [ i ] then
85413: LD_VAR 0 1
85417: PUSH
85418: LD_EXP 91
85422: PUSH
85423: LD_VAR 0 3
85427: ARRAY
85428: IN
85429: IFFALSE 85484
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
85431: LD_ADDR_EXP 92
85435: PUSH
85436: LD_EXP 92
85440: PPUSH
85441: LD_VAR 0 3
85445: PPUSH
85446: LD_EXP 92
85450: PUSH
85451: LD_VAR 0 3
85455: ARRAY
85456: PPUSH
85457: LD_INT 1
85459: PPUSH
85460: LD_EXP 92
85464: PUSH
85465: LD_VAR 0 3
85469: ARRAY
85470: PPUSH
85471: LD_INT 0
85473: PPUSH
85474: CALL 20569 0 4
85478: PPUSH
85479: CALL_OW 1
85483: ST_TO_ADDR
// if not building in mc_bases [ i ] then
85484: LD_VAR 0 1
85488: PUSH
85489: LD_EXP 58
85493: PUSH
85494: LD_VAR 0 3
85498: ARRAY
85499: IN
85500: NOT
85501: IFFALSE 85547
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85503: LD_ADDR_EXP 58
85507: PUSH
85508: LD_EXP 58
85512: PPUSH
85513: LD_VAR 0 3
85517: PUSH
85518: LD_EXP 58
85522: PUSH
85523: LD_VAR 0 3
85527: ARRAY
85528: PUSH
85529: LD_INT 1
85531: PLUS
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PPUSH
85537: LD_VAR 0 1
85541: PPUSH
85542: CALL 21151 0 3
85546: ST_TO_ADDR
// exit ;
85547: POP
85548: POP
85549: GO 85555
// end ; end ;
85551: GO 85355
85553: POP
85554: POP
// end ;
85555: LD_VAR 0 2
85559: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
85560: LD_INT 0
85562: PPUSH
85563: PPUSH
85564: PPUSH
85565: PPUSH
85566: PPUSH
85567: PPUSH
85568: PPUSH
// if not mc_bases or not skirmish then
85569: LD_EXP 58
85573: NOT
85574: PUSH
85575: LD_EXP 56
85579: NOT
85580: OR
85581: IFFALSE 85585
// exit ;
85583: GO 86246
// for i = 1 to mc_bases do
85585: LD_ADDR_VAR 0 3
85589: PUSH
85590: DOUBLE
85591: LD_INT 1
85593: DEC
85594: ST_TO_ADDR
85595: LD_EXP 58
85599: PUSH
85600: FOR_TO
85601: IFFALSE 86244
// begin if building in mc_construct_list [ i ] then
85603: LD_VAR 0 1
85607: PUSH
85608: LD_EXP 65
85612: PUSH
85613: LD_VAR 0 3
85617: ARRAY
85618: IN
85619: IFFALSE 86242
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85621: LD_ADDR_EXP 65
85625: PUSH
85626: LD_EXP 65
85630: PPUSH
85631: LD_VAR 0 3
85635: PPUSH
85636: LD_EXP 65
85640: PUSH
85641: LD_VAR 0 3
85645: ARRAY
85646: PUSH
85647: LD_VAR 0 1
85651: DIFF
85652: PPUSH
85653: CALL_OW 1
85657: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85658: LD_ADDR_EXP 58
85662: PUSH
85663: LD_EXP 58
85667: PPUSH
85668: LD_VAR 0 3
85672: PUSH
85673: LD_EXP 58
85677: PUSH
85678: LD_VAR 0 3
85682: ARRAY
85683: PUSH
85684: LD_INT 1
85686: PLUS
85687: PUSH
85688: EMPTY
85689: LIST
85690: LIST
85691: PPUSH
85692: LD_VAR 0 1
85696: PPUSH
85697: CALL 21151 0 3
85701: ST_TO_ADDR
// btype := GetBType ( building ) ;
85702: LD_ADDR_VAR 0 5
85706: PUSH
85707: LD_VAR 0 1
85711: PPUSH
85712: CALL_OW 266
85716: ST_TO_ADDR
// side := GetSide ( building ) ;
85717: LD_ADDR_VAR 0 8
85721: PUSH
85722: LD_VAR 0 1
85726: PPUSH
85727: CALL_OW 255
85731: ST_TO_ADDR
// if btype = b_lab then
85732: LD_VAR 0 5
85736: PUSH
85737: LD_INT 6
85739: EQUAL
85740: IFFALSE 85790
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
85742: LD_ADDR_EXP 91
85746: PUSH
85747: LD_EXP 91
85751: PPUSH
85752: LD_VAR 0 3
85756: PUSH
85757: LD_EXP 91
85761: PUSH
85762: LD_VAR 0 3
85766: ARRAY
85767: PUSH
85768: LD_INT 1
85770: PLUS
85771: PUSH
85772: EMPTY
85773: LIST
85774: LIST
85775: PPUSH
85776: LD_VAR 0 1
85780: PPUSH
85781: CALL 21151 0 3
85785: ST_TO_ADDR
// exit ;
85786: POP
85787: POP
85788: GO 86246
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
85790: LD_VAR 0 5
85794: PUSH
85795: LD_INT 0
85797: PUSH
85798: LD_INT 2
85800: PUSH
85801: LD_INT 4
85803: PUSH
85804: EMPTY
85805: LIST
85806: LIST
85807: LIST
85808: IN
85809: IFFALSE 85933
// begin if btype = b_armoury then
85811: LD_VAR 0 5
85815: PUSH
85816: LD_INT 4
85818: EQUAL
85819: IFFALSE 85829
// btype := b_barracks ;
85821: LD_ADDR_VAR 0 5
85825: PUSH
85826: LD_INT 5
85828: ST_TO_ADDR
// if btype = b_depot then
85829: LD_VAR 0 5
85833: PUSH
85834: LD_INT 0
85836: EQUAL
85837: IFFALSE 85847
// btype := b_warehouse ;
85839: LD_ADDR_VAR 0 5
85843: PUSH
85844: LD_INT 1
85846: ST_TO_ADDR
// if btype = b_workshop then
85847: LD_VAR 0 5
85851: PUSH
85852: LD_INT 2
85854: EQUAL
85855: IFFALSE 85865
// btype := b_factory ;
85857: LD_ADDR_VAR 0 5
85861: PUSH
85862: LD_INT 3
85864: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
85865: LD_VAR 0 5
85869: PPUSH
85870: LD_VAR 0 8
85874: PPUSH
85875: CALL_OW 323
85879: PUSH
85880: LD_INT 1
85882: EQUAL
85883: IFFALSE 85929
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
85885: LD_ADDR_EXP 90
85889: PUSH
85890: LD_EXP 90
85894: PPUSH
85895: LD_VAR 0 3
85899: PUSH
85900: LD_EXP 90
85904: PUSH
85905: LD_VAR 0 3
85909: ARRAY
85910: PUSH
85911: LD_INT 1
85913: PLUS
85914: PUSH
85915: EMPTY
85916: LIST
85917: LIST
85918: PPUSH
85919: LD_VAR 0 1
85923: PPUSH
85924: CALL 21151 0 3
85928: ST_TO_ADDR
// exit ;
85929: POP
85930: POP
85931: GO 86246
// end ; if btype in [ b_bunker , b_turret ] then
85933: LD_VAR 0 5
85937: PUSH
85938: LD_INT 32
85940: PUSH
85941: LD_INT 33
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: IN
85948: IFFALSE 86238
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
85950: LD_ADDR_EXP 66
85954: PUSH
85955: LD_EXP 66
85959: PPUSH
85960: LD_VAR 0 3
85964: PUSH
85965: LD_EXP 66
85969: PUSH
85970: LD_VAR 0 3
85974: ARRAY
85975: PUSH
85976: LD_INT 1
85978: PLUS
85979: PUSH
85980: EMPTY
85981: LIST
85982: LIST
85983: PPUSH
85984: LD_VAR 0 1
85988: PPUSH
85989: CALL 21151 0 3
85993: ST_TO_ADDR
// if btype = b_bunker then
85994: LD_VAR 0 5
85998: PUSH
85999: LD_INT 32
86001: EQUAL
86002: IFFALSE 86238
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86004: LD_ADDR_EXP 67
86008: PUSH
86009: LD_EXP 67
86013: PPUSH
86014: LD_VAR 0 3
86018: PUSH
86019: LD_EXP 67
86023: PUSH
86024: LD_VAR 0 3
86028: ARRAY
86029: PUSH
86030: LD_INT 1
86032: PLUS
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: PPUSH
86038: LD_VAR 0 1
86042: PPUSH
86043: CALL 21151 0 3
86047: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86048: LD_ADDR_VAR 0 6
86052: PUSH
86053: LD_EXP 58
86057: PUSH
86058: LD_VAR 0 3
86062: ARRAY
86063: PPUSH
86064: LD_INT 25
86066: PUSH
86067: LD_INT 1
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: PUSH
86074: LD_INT 3
86076: PUSH
86077: LD_INT 54
86079: PUSH
86080: EMPTY
86081: LIST
86082: PUSH
86083: EMPTY
86084: LIST
86085: LIST
86086: PUSH
86087: EMPTY
86088: LIST
86089: LIST
86090: PPUSH
86091: CALL_OW 72
86095: ST_TO_ADDR
// if tmp then
86096: LD_VAR 0 6
86100: IFFALSE 86106
// exit ;
86102: POP
86103: POP
86104: GO 86246
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86106: LD_ADDR_VAR 0 6
86110: PUSH
86111: LD_EXP 58
86115: PUSH
86116: LD_VAR 0 3
86120: ARRAY
86121: PPUSH
86122: LD_INT 2
86124: PUSH
86125: LD_INT 30
86127: PUSH
86128: LD_INT 4
86130: PUSH
86131: EMPTY
86132: LIST
86133: LIST
86134: PUSH
86135: LD_INT 30
86137: PUSH
86138: LD_INT 5
86140: PUSH
86141: EMPTY
86142: LIST
86143: LIST
86144: PUSH
86145: EMPTY
86146: LIST
86147: LIST
86148: LIST
86149: PPUSH
86150: CALL_OW 72
86154: ST_TO_ADDR
// if not tmp then
86155: LD_VAR 0 6
86159: NOT
86160: IFFALSE 86166
// exit ;
86162: POP
86163: POP
86164: GO 86246
// for j in tmp do
86166: LD_ADDR_VAR 0 4
86170: PUSH
86171: LD_VAR 0 6
86175: PUSH
86176: FOR_IN
86177: IFFALSE 86236
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86179: LD_ADDR_VAR 0 7
86183: PUSH
86184: LD_VAR 0 4
86188: PPUSH
86189: CALL_OW 313
86193: PPUSH
86194: LD_INT 25
86196: PUSH
86197: LD_INT 1
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PPUSH
86204: CALL_OW 72
86208: ST_TO_ADDR
// if units then
86209: LD_VAR 0 7
86213: IFFALSE 86234
// begin ComExitBuilding ( units [ 1 ] ) ;
86215: LD_VAR 0 7
86219: PUSH
86220: LD_INT 1
86222: ARRAY
86223: PPUSH
86224: CALL_OW 122
// exit ;
86228: POP
86229: POP
86230: POP
86231: POP
86232: GO 86246
// end ; end ;
86234: GO 86176
86236: POP
86237: POP
// end ; end ; exit ;
86238: POP
86239: POP
86240: GO 86246
// end ; end ;
86242: GO 85600
86244: POP
86245: POP
// end ;
86246: LD_VAR 0 2
86250: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86251: LD_INT 0
86253: PPUSH
86254: PPUSH
86255: PPUSH
86256: PPUSH
86257: PPUSH
86258: PPUSH
86259: PPUSH
// if not mc_bases or not skirmish then
86260: LD_EXP 58
86264: NOT
86265: PUSH
86266: LD_EXP 56
86270: NOT
86271: OR
86272: IFFALSE 86276
// exit ;
86274: GO 86507
// btype := GetBType ( building ) ;
86276: LD_ADDR_VAR 0 6
86280: PUSH
86281: LD_VAR 0 1
86285: PPUSH
86286: CALL_OW 266
86290: ST_TO_ADDR
// x := GetX ( building ) ;
86291: LD_ADDR_VAR 0 7
86295: PUSH
86296: LD_VAR 0 1
86300: PPUSH
86301: CALL_OW 250
86305: ST_TO_ADDR
// y := GetY ( building ) ;
86306: LD_ADDR_VAR 0 8
86310: PUSH
86311: LD_VAR 0 1
86315: PPUSH
86316: CALL_OW 251
86320: ST_TO_ADDR
// d := GetDir ( building ) ;
86321: LD_ADDR_VAR 0 9
86325: PUSH
86326: LD_VAR 0 1
86330: PPUSH
86331: CALL_OW 254
86335: ST_TO_ADDR
// for i = 1 to mc_bases do
86336: LD_ADDR_VAR 0 4
86340: PUSH
86341: DOUBLE
86342: LD_INT 1
86344: DEC
86345: ST_TO_ADDR
86346: LD_EXP 58
86350: PUSH
86351: FOR_TO
86352: IFFALSE 86505
// begin if not mc_build_list [ i ] then
86354: LD_EXP 63
86358: PUSH
86359: LD_VAR 0 4
86363: ARRAY
86364: NOT
86365: IFFALSE 86369
// continue ;
86367: GO 86351
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
86369: LD_VAR 0 6
86373: PUSH
86374: LD_VAR 0 7
86378: PUSH
86379: LD_VAR 0 8
86383: PUSH
86384: LD_VAR 0 9
86388: PUSH
86389: EMPTY
86390: LIST
86391: LIST
86392: LIST
86393: LIST
86394: PPUSH
86395: LD_EXP 63
86399: PUSH
86400: LD_VAR 0 4
86404: ARRAY
86405: PUSH
86406: LD_INT 1
86408: ARRAY
86409: PPUSH
86410: CALL 27320 0 2
86414: IFFALSE 86503
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
86416: LD_ADDR_EXP 63
86420: PUSH
86421: LD_EXP 63
86425: PPUSH
86426: LD_VAR 0 4
86430: PPUSH
86431: LD_EXP 63
86435: PUSH
86436: LD_VAR 0 4
86440: ARRAY
86441: PPUSH
86442: LD_INT 1
86444: PPUSH
86445: CALL_OW 3
86449: PPUSH
86450: CALL_OW 1
86454: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
86455: LD_ADDR_EXP 65
86459: PUSH
86460: LD_EXP 65
86464: PPUSH
86465: LD_VAR 0 4
86469: PUSH
86470: LD_EXP 65
86474: PUSH
86475: LD_VAR 0 4
86479: ARRAY
86480: PUSH
86481: LD_INT 1
86483: PLUS
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PPUSH
86489: LD_VAR 0 1
86493: PPUSH
86494: CALL 21151 0 3
86498: ST_TO_ADDR
// exit ;
86499: POP
86500: POP
86501: GO 86507
// end ; end ;
86503: GO 86351
86505: POP
86506: POP
// end ;
86507: LD_VAR 0 3
86511: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
86512: LD_INT 0
86514: PPUSH
86515: PPUSH
86516: PPUSH
// if not mc_bases or not skirmish then
86517: LD_EXP 58
86521: NOT
86522: PUSH
86523: LD_EXP 56
86527: NOT
86528: OR
86529: IFFALSE 86533
// exit ;
86531: GO 86723
// for i = 1 to mc_bases do
86533: LD_ADDR_VAR 0 4
86537: PUSH
86538: DOUBLE
86539: LD_INT 1
86541: DEC
86542: ST_TO_ADDR
86543: LD_EXP 58
86547: PUSH
86548: FOR_TO
86549: IFFALSE 86636
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
86551: LD_VAR 0 1
86555: PUSH
86556: LD_EXP 66
86560: PUSH
86561: LD_VAR 0 4
86565: ARRAY
86566: IN
86567: PUSH
86568: LD_VAR 0 1
86572: PUSH
86573: LD_EXP 67
86577: PUSH
86578: LD_VAR 0 4
86582: ARRAY
86583: IN
86584: NOT
86585: AND
86586: IFFALSE 86634
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86588: LD_ADDR_EXP 67
86592: PUSH
86593: LD_EXP 67
86597: PPUSH
86598: LD_VAR 0 4
86602: PUSH
86603: LD_EXP 67
86607: PUSH
86608: LD_VAR 0 4
86612: ARRAY
86613: PUSH
86614: LD_INT 1
86616: PLUS
86617: PUSH
86618: EMPTY
86619: LIST
86620: LIST
86621: PPUSH
86622: LD_VAR 0 1
86626: PPUSH
86627: CALL 21151 0 3
86631: ST_TO_ADDR
// break ;
86632: GO 86636
// end ; end ;
86634: GO 86548
86636: POP
86637: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
86638: LD_VAR 0 1
86642: PPUSH
86643: CALL_OW 257
86647: PUSH
86648: LD_EXP 84
86652: IN
86653: PUSH
86654: LD_VAR 0 1
86658: PPUSH
86659: CALL_OW 266
86663: PUSH
86664: LD_INT 5
86666: EQUAL
86667: AND
86668: PUSH
86669: LD_VAR 0 2
86673: PPUSH
86674: CALL_OW 110
86678: PUSH
86679: LD_INT 18
86681: NONEQUAL
86682: AND
86683: IFFALSE 86723
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
86685: LD_VAR 0 2
86689: PPUSH
86690: CALL_OW 257
86694: PUSH
86695: LD_INT 5
86697: PUSH
86698: LD_INT 8
86700: PUSH
86701: LD_INT 9
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: LIST
86708: IN
86709: IFFALSE 86723
// SetClass ( unit , 1 ) ;
86711: LD_VAR 0 2
86715: PPUSH
86716: LD_INT 1
86718: PPUSH
86719: CALL_OW 336
// end ;
86723: LD_VAR 0 3
86727: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
86728: LD_INT 0
86730: PPUSH
86731: PPUSH
// if not mc_bases or not skirmish then
86732: LD_EXP 58
86736: NOT
86737: PUSH
86738: LD_EXP 56
86742: NOT
86743: OR
86744: IFFALSE 86748
// exit ;
86746: GO 86864
// if GetLives ( abandoned_vehicle ) > 250 then
86748: LD_VAR 0 2
86752: PPUSH
86753: CALL_OW 256
86757: PUSH
86758: LD_INT 250
86760: GREATER
86761: IFFALSE 86765
// exit ;
86763: GO 86864
// for i = 1 to mc_bases do
86765: LD_ADDR_VAR 0 6
86769: PUSH
86770: DOUBLE
86771: LD_INT 1
86773: DEC
86774: ST_TO_ADDR
86775: LD_EXP 58
86779: PUSH
86780: FOR_TO
86781: IFFALSE 86862
// begin if driver in mc_bases [ i ] then
86783: LD_VAR 0 1
86787: PUSH
86788: LD_EXP 58
86792: PUSH
86793: LD_VAR 0 6
86797: ARRAY
86798: IN
86799: IFFALSE 86860
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
86801: LD_VAR 0 1
86805: PPUSH
86806: LD_EXP 58
86810: PUSH
86811: LD_VAR 0 6
86815: ARRAY
86816: PPUSH
86817: LD_INT 2
86819: PUSH
86820: LD_INT 30
86822: PUSH
86823: LD_INT 0
86825: PUSH
86826: EMPTY
86827: LIST
86828: LIST
86829: PUSH
86830: LD_INT 30
86832: PUSH
86833: LD_INT 1
86835: PUSH
86836: EMPTY
86837: LIST
86838: LIST
86839: PUSH
86840: EMPTY
86841: LIST
86842: LIST
86843: LIST
86844: PPUSH
86845: CALL_OW 72
86849: PUSH
86850: LD_INT 1
86852: ARRAY
86853: PPUSH
86854: CALL_OW 112
// break ;
86858: GO 86862
// end ; end ;
86860: GO 86780
86862: POP
86863: POP
// end ; end_of_file
86864: LD_VAR 0 5
86868: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
86869: GO 86871
86871: DISABLE
// begin ru_radar := 98 ;
86872: LD_ADDR_EXP 101
86876: PUSH
86877: LD_INT 98
86879: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
86880: LD_ADDR_EXP 102
86884: PUSH
86885: LD_INT 89
86887: ST_TO_ADDR
// us_hack := 99 ;
86888: LD_ADDR_EXP 103
86892: PUSH
86893: LD_INT 99
86895: ST_TO_ADDR
// us_artillery := 97 ;
86896: LD_ADDR_EXP 104
86900: PUSH
86901: LD_INT 97
86903: ST_TO_ADDR
// ar_bio_bomb := 91 ;
86904: LD_ADDR_EXP 105
86908: PUSH
86909: LD_INT 91
86911: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
86912: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
86913: LD_INT 0
86915: PPUSH
86916: PPUSH
86917: PPUSH
86918: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
86919: LD_VAR 0 1
86923: PPUSH
86924: CALL_OW 264
86928: PUSH
86929: LD_EXP 105
86933: EQUAL
86934: IFFALSE 87006
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
86936: LD_INT 68
86938: PPUSH
86939: LD_VAR 0 1
86943: PPUSH
86944: CALL_OW 255
86948: PPUSH
86949: CALL_OW 321
86953: PUSH
86954: LD_INT 2
86956: EQUAL
86957: IFFALSE 86969
// eff := 70 else
86959: LD_ADDR_VAR 0 6
86963: PUSH
86964: LD_INT 70
86966: ST_TO_ADDR
86967: GO 86977
// eff := 30 ;
86969: LD_ADDR_VAR 0 6
86973: PUSH
86974: LD_INT 30
86976: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
86977: LD_VAR 0 1
86981: PPUSH
86982: CALL_OW 250
86986: PPUSH
86987: LD_VAR 0 1
86991: PPUSH
86992: CALL_OW 251
86996: PPUSH
86997: LD_VAR 0 6
87001: PPUSH
87002: CALL_OW 495
// end ; end ;
87006: LD_VAR 0 4
87010: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
87011: LD_INT 0
87013: PPUSH
87014: PPUSH
87015: PPUSH
87016: PPUSH
87017: PPUSH
87018: PPUSH
// if cmd = 124 then
87019: LD_VAR 0 1
87023: PUSH
87024: LD_INT 124
87026: EQUAL
87027: IFFALSE 87233
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
87029: LD_ADDR_VAR 0 5
87033: PUSH
87034: LD_INT 2
87036: PUSH
87037: LD_INT 34
87039: PUSH
87040: LD_INT 53
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PUSH
87047: LD_INT 34
87049: PUSH
87050: LD_INT 14
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: EMPTY
87058: LIST
87059: LIST
87060: LIST
87061: PPUSH
87062: CALL_OW 69
87066: ST_TO_ADDR
// if not tmp then
87067: LD_VAR 0 5
87071: NOT
87072: IFFALSE 87076
// exit ;
87074: GO 87233
// for i in tmp do
87076: LD_ADDR_VAR 0 3
87080: PUSH
87081: LD_VAR 0 5
87085: PUSH
87086: FOR_IN
87087: IFFALSE 87231
// begin taskList := GetTaskList ( i ) ;
87089: LD_ADDR_VAR 0 6
87093: PUSH
87094: LD_VAR 0 3
87098: PPUSH
87099: CALL_OW 437
87103: ST_TO_ADDR
// if not taskList then
87104: LD_VAR 0 6
87108: NOT
87109: IFFALSE 87113
// continue ;
87111: GO 87086
// for j = 1 to taskList do
87113: LD_ADDR_VAR 0 4
87117: PUSH
87118: DOUBLE
87119: LD_INT 1
87121: DEC
87122: ST_TO_ADDR
87123: LD_VAR 0 6
87127: PUSH
87128: FOR_TO
87129: IFFALSE 87227
// if taskList [ j ] [ 1 ] = | then
87131: LD_VAR 0 6
87135: PUSH
87136: LD_VAR 0 4
87140: ARRAY
87141: PUSH
87142: LD_INT 1
87144: ARRAY
87145: PUSH
87146: LD_STRING |
87148: EQUAL
87149: IFFALSE 87225
// begin _taskList := Delete ( taskList , 1 ) ;
87151: LD_ADDR_VAR 0 7
87155: PUSH
87156: LD_VAR 0 6
87160: PPUSH
87161: LD_INT 1
87163: PPUSH
87164: CALL_OW 3
87168: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
87169: LD_VAR 0 3
87173: PPUSH
87174: LD_VAR 0 7
87178: PPUSH
87179: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
87183: LD_VAR 0 3
87187: PPUSH
87188: LD_VAR 0 6
87192: PUSH
87193: LD_VAR 0 4
87197: ARRAY
87198: PUSH
87199: LD_INT 2
87201: ARRAY
87202: PPUSH
87203: LD_VAR 0 6
87207: PUSH
87208: LD_VAR 0 4
87212: ARRAY
87213: PUSH
87214: LD_INT 3
87216: ARRAY
87217: PPUSH
87218: LD_INT 8
87220: PPUSH
87221: CALL 87238 0 4
// end ;
87225: GO 87128
87227: POP
87228: POP
// end ;
87229: GO 87086
87231: POP
87232: POP
// end ; end ;
87233: LD_VAR 0 2
87237: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87238: LD_INT 0
87240: PPUSH
87241: PPUSH
87242: PPUSH
87243: PPUSH
87244: PPUSH
87245: PPUSH
87246: PPUSH
87247: PPUSH
87248: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87249: LD_VAR 0 1
87253: NOT
87254: PUSH
87255: LD_VAR 0 2
87259: PPUSH
87260: LD_VAR 0 3
87264: PPUSH
87265: CALL_OW 488
87269: NOT
87270: OR
87271: PUSH
87272: LD_VAR 0 4
87276: NOT
87277: OR
87278: IFFALSE 87282
// exit ;
87280: GO 87622
// list := [ ] ;
87282: LD_ADDR_VAR 0 13
87286: PUSH
87287: EMPTY
87288: ST_TO_ADDR
// if x - r < 0 then
87289: LD_VAR 0 2
87293: PUSH
87294: LD_VAR 0 4
87298: MINUS
87299: PUSH
87300: LD_INT 0
87302: LESS
87303: IFFALSE 87315
// min_x := 0 else
87305: LD_ADDR_VAR 0 7
87309: PUSH
87310: LD_INT 0
87312: ST_TO_ADDR
87313: GO 87331
// min_x := x - r ;
87315: LD_ADDR_VAR 0 7
87319: PUSH
87320: LD_VAR 0 2
87324: PUSH
87325: LD_VAR 0 4
87329: MINUS
87330: ST_TO_ADDR
// if y - r < 0 then
87331: LD_VAR 0 3
87335: PUSH
87336: LD_VAR 0 4
87340: MINUS
87341: PUSH
87342: LD_INT 0
87344: LESS
87345: IFFALSE 87357
// min_y := 0 else
87347: LD_ADDR_VAR 0 8
87351: PUSH
87352: LD_INT 0
87354: ST_TO_ADDR
87355: GO 87373
// min_y := y - r ;
87357: LD_ADDR_VAR 0 8
87361: PUSH
87362: LD_VAR 0 3
87366: PUSH
87367: LD_VAR 0 4
87371: MINUS
87372: ST_TO_ADDR
// max_x := x + r ;
87373: LD_ADDR_VAR 0 9
87377: PUSH
87378: LD_VAR 0 2
87382: PUSH
87383: LD_VAR 0 4
87387: PLUS
87388: ST_TO_ADDR
// max_y := y + r ;
87389: LD_ADDR_VAR 0 10
87393: PUSH
87394: LD_VAR 0 3
87398: PUSH
87399: LD_VAR 0 4
87403: PLUS
87404: ST_TO_ADDR
// for _x = min_x to max_x do
87405: LD_ADDR_VAR 0 11
87409: PUSH
87410: DOUBLE
87411: LD_VAR 0 7
87415: DEC
87416: ST_TO_ADDR
87417: LD_VAR 0 9
87421: PUSH
87422: FOR_TO
87423: IFFALSE 87540
// for _y = min_y to max_y do
87425: LD_ADDR_VAR 0 12
87429: PUSH
87430: DOUBLE
87431: LD_VAR 0 8
87435: DEC
87436: ST_TO_ADDR
87437: LD_VAR 0 10
87441: PUSH
87442: FOR_TO
87443: IFFALSE 87536
// begin if not ValidHex ( _x , _y ) then
87445: LD_VAR 0 11
87449: PPUSH
87450: LD_VAR 0 12
87454: PPUSH
87455: CALL_OW 488
87459: NOT
87460: IFFALSE 87464
// continue ;
87462: GO 87442
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
87464: LD_VAR 0 11
87468: PPUSH
87469: LD_VAR 0 12
87473: PPUSH
87474: CALL_OW 351
87478: PUSH
87479: LD_VAR 0 11
87483: PPUSH
87484: LD_VAR 0 12
87488: PPUSH
87489: CALL_OW 554
87493: AND
87494: IFFALSE 87534
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
87496: LD_ADDR_VAR 0 13
87500: PUSH
87501: LD_VAR 0 13
87505: PPUSH
87506: LD_VAR 0 13
87510: PUSH
87511: LD_INT 1
87513: PLUS
87514: PPUSH
87515: LD_VAR 0 11
87519: PUSH
87520: LD_VAR 0 12
87524: PUSH
87525: EMPTY
87526: LIST
87527: LIST
87528: PPUSH
87529: CALL_OW 2
87533: ST_TO_ADDR
// end ;
87534: GO 87442
87536: POP
87537: POP
87538: GO 87422
87540: POP
87541: POP
// if not list then
87542: LD_VAR 0 13
87546: NOT
87547: IFFALSE 87551
// exit ;
87549: GO 87622
// for i in list do
87551: LD_ADDR_VAR 0 6
87555: PUSH
87556: LD_VAR 0 13
87560: PUSH
87561: FOR_IN
87562: IFFALSE 87620
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
87564: LD_VAR 0 1
87568: PPUSH
87569: LD_STRING M
87571: PUSH
87572: LD_VAR 0 6
87576: PUSH
87577: LD_INT 1
87579: ARRAY
87580: PUSH
87581: LD_VAR 0 6
87585: PUSH
87586: LD_INT 2
87588: ARRAY
87589: PUSH
87590: LD_INT 0
87592: PUSH
87593: LD_INT 0
87595: PUSH
87596: LD_INT 0
87598: PUSH
87599: LD_INT 0
87601: PUSH
87602: EMPTY
87603: LIST
87604: LIST
87605: LIST
87606: LIST
87607: LIST
87608: LIST
87609: LIST
87610: PUSH
87611: EMPTY
87612: LIST
87613: PPUSH
87614: CALL_OW 447
87618: GO 87561
87620: POP
87621: POP
// end ;
87622: LD_VAR 0 5
87626: RET
