// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 57425 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49880 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49880 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49880 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 49880 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4085 0 0
// PrepareRussian ;
 189: CALL 2989 0 0
// PrepareAlliance ;
 193: CALL 911 0 0
// MC_Start ( ) ;
 197: CALL 59605 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 7736 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 85
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 86
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 81322 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 56
 294: PPUSH
 295: CALL 81767 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 82225 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 82494 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 81707 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 82401 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 53
 401: PPUSH
 402: CALL 81767 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 82225 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 82494 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 81551 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 82812 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 81707 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 6
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 7
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 54
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 8
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ar_attackers := [ ] ;
 775: LD_ADDR_EXP 11
 779: PUSH
 780: EMPTY
 781: ST_TO_ADDR
// first_powell_attack := false ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_INT 0
 789: ST_TO_ADDR
// masha_killed := false ;
 790: LD_ADDR_EXP 10
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// abdul_escaped := true ;
 798: LD_ADDR_EXP 13
 802: PUSH
 803: LD_INT 1
 805: ST_TO_ADDR
// loss_counter := 0 ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 0
 813: ST_TO_ADDR
// hack_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// end ;
 822: LD_VAR 0 1
 826: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 827: LD_EXP 50
 831: PPUSH
 832: CALL_OW 255
 836: PUSH
 837: LD_INT 7
 839: EQUAL
 840: PUSH
 841: LD_EXP 49
 845: PPUSH
 846: CALL_OW 255
 850: PUSH
 851: LD_INT 7
 853: EQUAL
 854: AND
 855: PUSH
 856: LD_EXP 50
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: PUSH
 867: LD_EXP 49
 871: PPUSH
 872: CALL_OW 302
 876: AND
 877: IFFALSE 889
 879: GO 881
 881: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 882: LD_STRING ACH_COMRADE
 884: PPUSH
 885: CALL_OW 543
 889: END
// every 0 0$1 trigger hack_counter >= 10 do
 890: LD_EXP 15
 894: PUSH
 895: LD_INT 10
 897: GREATEREQUAL
 898: IFFALSE 910
 900: GO 902
 902: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 903: LD_STRING ACH_HACK
 905: PPUSH
 906: CALL_OW 543
 910: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
 915: PPUSH
 916: PPUSH
// uc_side := 7 ;
 917: LD_ADDR_OWVAR 20
 921: PUSH
 922: LD_INT 7
 924: ST_TO_ADDR
// uc_nation := 1 ;
 925: LD_ADDR_OWVAR 21
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 933: LD_ADDR_EXP 16
 937: PUSH
 938: LD_STRING JMM
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_STRING 12a_
 949: PPUSH
 950: CALL 15501 0 3
 954: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 955: LD_EXP 16
 959: PPUSH
 960: LD_INT 71
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 0
 968: PPUSH
 969: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 2
 980: PPUSH
 981: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 985: LD_ADDR_EXP 17
 989: PUSH
 990: LD_STRING Roth
 992: PPUSH
 993: LD_EXP 1
 997: NOT
 998: PPUSH
 999: LD_STRING 12a_
1001: PPUSH
1002: CALL 15501 0 3
1006: ST_TO_ADDR
// if Roth then
1007: LD_EXP 17
1011: IFFALSE 1031
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1013: LD_EXP 17
1017: PPUSH
1018: LD_INT 71
1020: PPUSH
1021: LD_INT 21
1023: PPUSH
1024: LD_INT 0
1026: PPUSH
1027: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1031: LD_ADDR_EXP 33
1035: PUSH
1036: LD_STRING Mike
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_STRING 12a_
1047: PPUSH
1048: CALL 15501 0 3
1052: ST_TO_ADDR
// if Mike then
1053: LD_EXP 33
1057: IFFALSE 1074
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 13
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1074: LD_ADDR_EXP 18
1078: PUSH
1079: LD_STRING Lisa
1081: PPUSH
1082: LD_EXP 1
1086: NOT
1087: PPUSH
1088: LD_STRING 12a_
1090: PPUSH
1091: CALL 15501 0 3
1095: ST_TO_ADDR
// if Lisa then
1096: LD_EXP 18
1100: IFFALSE 1117
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1102: LD_EXP 18
1106: PPUSH
1107: LD_INT 13
1109: PPUSH
1110: LD_INT 0
1112: PPUSH
1113: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1117: LD_ADDR_EXP 19
1121: PUSH
1122: LD_STRING Donaldson
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_STRING 12a_
1133: PPUSH
1134: CALL 15501 0 3
1138: ST_TO_ADDR
// if Donaldson then
1139: LD_EXP 19
1143: IFFALSE 1160
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1145: LD_EXP 19
1149: PPUSH
1150: LD_INT 13
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1160: LD_ADDR_EXP 20
1164: PUSH
1165: LD_STRING Bobby
1167: PPUSH
1168: LD_EXP 1
1172: NOT
1173: PPUSH
1174: LD_STRING 12a_
1176: PPUSH
1177: CALL 15501 0 3
1181: ST_TO_ADDR
// if Bobby then
1182: LD_EXP 20
1186: IFFALSE 1203
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1188: LD_EXP 20
1192: PPUSH
1193: LD_INT 13
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1203: LD_ADDR_EXP 21
1207: PUSH
1208: LD_STRING Cyrus
1210: PPUSH
1211: LD_EXP 1
1215: NOT
1216: PPUSH
1217: LD_STRING 12a_
1219: PPUSH
1220: CALL 15501 0 3
1224: ST_TO_ADDR
// if Cyrus then
1225: LD_EXP 21
1229: IFFALSE 1246
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1231: LD_EXP 21
1235: PPUSH
1236: LD_INT 13
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1246: LD_ADDR_EXP 22
1250: PUSH
1251: LD_STRING Denis
1253: PPUSH
1254: LD_EXP 1
1258: NOT
1259: PPUSH
1260: LD_STRING 12a_
1262: PPUSH
1263: CALL 15501 0 3
1267: ST_TO_ADDR
// if Denis then
1268: LD_EXP 22
1272: IFFALSE 1289
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1274: LD_EXP 22
1278: PPUSH
1279: LD_INT 13
1281: PPUSH
1282: LD_INT 0
1284: PPUSH
1285: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1289: LD_ADDR_EXP 23
1293: PUSH
1294: LD_STRING Brown
1296: PPUSH
1297: LD_EXP 1
1301: NOT
1302: PPUSH
1303: LD_STRING 12a_
1305: PPUSH
1306: CALL 15501 0 3
1310: ST_TO_ADDR
// if Brown then
1311: LD_EXP 23
1315: IFFALSE 1332
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1317: LD_EXP 23
1321: PPUSH
1322: LD_INT 13
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1332: LD_ADDR_EXP 24
1336: PUSH
1337: LD_STRING Gladstone
1339: PPUSH
1340: LD_EXP 1
1344: NOT
1345: PPUSH
1346: LD_STRING 12a_
1348: PPUSH
1349: CALL 15501 0 3
1353: ST_TO_ADDR
// if Gladstone then
1354: LD_EXP 24
1358: IFFALSE 1375
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1360: LD_EXP 24
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: LD_INT 0
1370: PPUSH
1371: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1375: LD_ADDR_EXP 25
1379: PUSH
1380: LD_STRING Houten
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 12a_
1391: PPUSH
1392: CALL 15501 0 3
1396: ST_TO_ADDR
// if Houten then
1397: LD_EXP 25
1401: IFFALSE 1418
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1403: LD_EXP 25
1407: PPUSH
1408: LD_INT 13
1410: PPUSH
1411: LD_INT 0
1413: PPUSH
1414: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1418: LD_ADDR_EXP 26
1422: PUSH
1423: LD_STRING Cornell
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: LD_STRING 12a_
1434: PPUSH
1435: CALL 15501 0 3
1439: ST_TO_ADDR
// if Cornel then
1440: LD_EXP 26
1444: IFFALSE 1461
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1446: LD_EXP 26
1450: PPUSH
1451: LD_INT 13
1453: PPUSH
1454: LD_INT 0
1456: PPUSH
1457: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1461: LD_ADDR_EXP 27
1465: PUSH
1466: LD_STRING Gary
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 12a_
1477: PPUSH
1478: CALL 15501 0 3
1482: ST_TO_ADDR
// if Gary then
1483: LD_EXP 27
1487: IFFALSE 1504
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1489: LD_EXP 27
1493: PPUSH
1494: LD_INT 13
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1504: LD_ADDR_EXP 28
1508: PUSH
1509: LD_STRING Frank
1511: PPUSH
1512: LD_EXP 1
1516: NOT
1517: PPUSH
1518: LD_STRING 12a_
1520: PPUSH
1521: CALL 15501 0 3
1525: ST_TO_ADDR
// if Frank then
1526: LD_EXP 28
1530: IFFALSE 1547
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1532: LD_EXP 28
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1547: LD_ADDR_EXP 29
1551: PUSH
1552: LD_STRING Kikuchi
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 12a_
1563: PPUSH
1564: CALL 15501 0 3
1568: ST_TO_ADDR
// if Kikuchi then
1569: LD_EXP 29
1573: IFFALSE 1590
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1575: LD_EXP 29
1579: PPUSH
1580: LD_INT 13
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1590: LD_ADDR_EXP 30
1594: PUSH
1595: LD_STRING Simms
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 12a_
1606: PPUSH
1607: CALL 15501 0 3
1611: ST_TO_ADDR
// if Simms then
1612: LD_EXP 30
1616: IFFALSE 1633
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1618: LD_EXP 30
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1633: LD_ADDR_EXP 31
1637: PUSH
1638: LD_STRING Joan
1640: PPUSH
1641: LD_EXP 1
1645: NOT
1646: PPUSH
1647: LD_STRING 12a_
1649: PPUSH
1650: CALL 15501 0 3
1654: ST_TO_ADDR
// if Joan then
1655: LD_EXP 31
1659: IFFALSE 1676
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1661: LD_EXP 31
1665: PPUSH
1666: LD_INT 13
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1676: LD_ADDR_EXP 32
1680: PUSH
1681: LD_STRING DeltaDoctor
1683: PPUSH
1684: LD_EXP 1
1688: NOT
1689: PPUSH
1690: LD_STRING 12a_
1692: PPUSH
1693: CALL 15501 0 3
1697: ST_TO_ADDR
// if DeltaDoctor then
1698: LD_EXP 32
1702: IFFALSE 1719
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1704: LD_EXP 32
1708: PPUSH
1709: LD_INT 13
1711: PPUSH
1712: LD_INT 0
1714: PPUSH
1715: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_STRING 12a_others
1726: PPUSH
1727: CALL_OW 31
1731: ST_TO_ADDR
// if tmp then
1732: LD_VAR 0 4
1736: IFFALSE 1770
// for i in tmp do
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_VAR 0 4
1747: PUSH
1748: FOR_IN
1749: IFFALSE 1768
// PlaceUnitArea ( i , alliance_start , false ) ;
1751: LD_VAR 0 3
1755: PPUSH
1756: LD_INT 13
1758: PPUSH
1759: LD_INT 0
1761: PPUSH
1762: CALL_OW 49
1766: GO 1748
1768: POP
1769: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 3
1778: PPUSH
1779: LD_INT 12
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 20341 0 5
// veh := CreateVehicle ;
1789: LD_ADDR_VAR 0 2
1793: PUSH
1794: CALL_OW 45
1798: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_INT 2
1806: PPUSH
1807: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1811: LD_VAR 0 2
1815: PPUSH
1816: LD_INT 60
1818: PPUSH
1819: LD_INT 6
1821: PPUSH
1822: LD_INT 0
1824: PPUSH
1825: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1829: LD_VAR 0 2
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_INT 30
1839: PPUSH
1840: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1844: LD_STRING 11_artifact_captured
1846: PPUSH
1847: LD_INT 0
1849: PPUSH
1850: CALL_OW 30
1854: IFFALSE 1930
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1856: LD_INT 3
1858: PPUSH
1859: LD_INT 3
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: LD_INT 12
1867: PPUSH
1868: LD_INT 100
1870: PPUSH
1871: CALL 20341 0 5
// veh := CreateVehicle ;
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: CALL_OW 45
1884: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1885: LD_VAR 0 2
1889: PPUSH
1890: LD_INT 3
1892: PPUSH
1893: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1897: LD_VAR 0 2
1901: PPUSH
1902: LD_INT 75
1904: PPUSH
1905: LD_INT 6
1907: PPUSH
1908: LD_INT 0
1910: PPUSH
1911: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1915: LD_VAR 0 2
1919: PPUSH
1920: LD_INT 4
1922: PPUSH
1923: LD_INT 50
1925: PPUSH
1926: CALL_OW 290
// end ; end ;
1930: LD_VAR 0 1
1934: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1935: LD_INT 0
1937: PPUSH
1938: PPUSH
1939: PPUSH
1940: PPUSH
// uc_side := 6 ;
1941: LD_ADDR_OWVAR 20
1945: PUSH
1946: LD_INT 6
1948: ST_TO_ADDR
// uc_nation := 3 ;
1949: LD_ADDR_OWVAR 21
1953: PUSH
1954: LD_INT 3
1956: ST_TO_ADDR
// InitHc ;
1957: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1961: LD_ADDR_EXP 34
1965: PUSH
1966: LD_STRING Gossudarov
1968: PPUSH
1969: CALL_OW 25
1973: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1974: LD_ADDR_EXP 35
1978: PUSH
1979: LD_STRING Kirilenkova
1981: PPUSH
1982: CALL_OW 25
1986: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1987: LD_ADDR_EXP 36
1991: PUSH
1992: LD_STRING Titov
1994: PPUSH
1995: CALL_OW 25
1999: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2000: LD_ADDR_EXP 41
2004: PUSH
2005: LD_STRING Oblukov
2007: PPUSH
2008: CALL_OW 25
2012: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2013: LD_ADDR_EXP 38
2017: PUSH
2018: LD_STRING Dolgov
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2026: LD_ADDR_EXP 39
2030: PUSH
2031: LD_STRING Petrosyan
2033: PPUSH
2034: CALL_OW 25
2038: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2039: LD_ADDR_EXP 40
2043: PUSH
2044: LD_STRING Scholtze
2046: PPUSH
2047: CALL_OW 25
2051: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2052: LD_ADDR_EXP 42
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: CALL_OW 25
2064: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2065: LD_ADDR_VAR 0 2
2069: PUSH
2070: LD_EXP 34
2074: PUSH
2075: LD_EXP 35
2079: PUSH
2080: LD_EXP 36
2084: PUSH
2085: LD_EXP 41
2089: PUSH
2090: LD_EXP 38
2094: PUSH
2095: LD_EXP 39
2099: PUSH
2100: LD_EXP 40
2104: PUSH
2105: LD_EXP 42
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: LIST
2119: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2120: LD_INT 1
2122: PPUSH
2123: LD_INT 4
2125: PPUSH
2126: LD_INT 8
2128: PPUSH
2129: CALL_OW 380
// un := CreateHuman ;
2133: LD_ADDR_VAR 0 4
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ un ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_VAR 0 4
2157: ADD
2158: ST_TO_ADDR
// for i in tmp do
2159: LD_ADDR_VAR 0 3
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: FOR_IN
2170: IFFALSE 2189
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2172: LD_VAR 0 3
2176: PPUSH
2177: LD_INT 14
2179: PPUSH
2180: LD_INT 0
2182: PPUSH
2183: CALL_OW 49
2187: GO 2169
2189: POP
2190: POP
// if freedom then
2191: LD_EXP 3
2195: IFFALSE 2228
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2197: LD_VAR 0 2
2201: PPUSH
2202: LD_EXP 3
2206: PPUSH
2207: CALL_OW 250
2211: PPUSH
2212: LD_EXP 3
2216: PPUSH
2217: CALL_OW 251
2221: PPUSH
2222: CALL_OW 111
2226: GO 2243
// ComMoveXY ( tmp , 70 , 48 ) ;
2228: LD_VAR 0 2
2232: PPUSH
2233: LD_INT 70
2235: PPUSH
2236: LD_INT 48
2238: PPUSH
2239: CALL_OW 111
// end ;
2243: LD_VAR 0 1
2247: RET
// export function PrepareBelkov ; begin
2248: LD_INT 0
2250: PPUSH
// uc_side := 4 ;
2251: LD_ADDR_OWVAR 20
2255: PUSH
2256: LD_INT 4
2258: ST_TO_ADDR
// uc_nation := 3 ;
2259: LD_ADDR_OWVAR 21
2263: PUSH
2264: LD_INT 3
2266: ST_TO_ADDR
// InitHc ;
2267: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2271: LD_ADDR_EXP 49
2275: PUSH
2276: LD_STRING Belkov
2278: PPUSH
2279: CALL_OW 25
2283: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2284: LD_EXP 49
2288: PPUSH
2289: LD_INT 14
2291: PPUSH
2292: LD_INT 0
2294: PPUSH
2295: CALL_OW 49
// end ;
2299: LD_VAR 0 1
2303: RET
// export function PrepareGnyevko ; begin
2304: LD_INT 0
2306: PPUSH
// uc_side := 4 ;
2307: LD_ADDR_OWVAR 20
2311: PUSH
2312: LD_INT 4
2314: ST_TO_ADDR
// uc_nation := 3 ;
2315: LD_ADDR_OWVAR 21
2319: PUSH
2320: LD_INT 3
2322: ST_TO_ADDR
// InitHc ;
2323: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2327: LD_ADDR_EXP 50
2331: PUSH
2332: LD_STRING Gnyevko
2334: PPUSH
2335: CALL_OW 25
2339: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2340: LD_EXP 50
2344: PPUSH
2345: LD_INT 14
2347: PPUSH
2348: LD_INT 0
2350: PPUSH
2351: CALL_OW 49
// end ;
2355: LD_VAR 0 1
2359: RET
// export function PrepareBurlak ; var i , tmp ; begin
2360: LD_INT 0
2362: PPUSH
2363: PPUSH
2364: PPUSH
// uc_side := 4 ;
2365: LD_ADDR_OWVAR 20
2369: PUSH
2370: LD_INT 4
2372: ST_TO_ADDR
// uc_nation := 3 ;
2373: LD_ADDR_OWVAR 21
2377: PUSH
2378: LD_INT 3
2380: ST_TO_ADDR
// InitHc ;
2381: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2385: LD_ADDR_EXP 48
2389: PUSH
2390: LD_STRING Burlak
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2398: LD_INT 24
2400: PUSH
2401: LD_INT 23
2403: PUSH
2404: LD_INT 22
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_OWVAR 67
2420: ARRAY
2421: PPUSH
2422: LD_INT 1
2424: PPUSH
2425: LD_INT 1
2427: PPUSH
2428: LD_INT 45
2430: PUSH
2431: LD_INT 44
2433: PUSH
2434: LD_INT 43
2436: PUSH
2437: LD_INT 42
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: LIST
2444: LIST
2445: PUSH
2446: LD_OWVAR 67
2450: ARRAY
2451: PPUSH
2452: LD_INT 0
2454: PPUSH
2455: CALL 20341 0 5
// Masha := CreateVehicle ;
2459: LD_ADDR_EXP 51
2463: PUSH
2464: CALL_OW 45
2468: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2469: LD_EXP 51
2473: PUSH
2474: LD_EXP 48
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: LD_INT 499
2485: PPUSH
2486: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2490: LD_EXP 51
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2502: LD_EXP 51
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 18
2519: PPUSH
2520: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2524: LD_INT 35
2526: PPUSH
2527: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2531: LD_ADDR_VAR 0 3
2535: PUSH
2536: LD_INT 18
2538: PPUSH
2539: EMPTY
2540: PPUSH
2541: CALL_OW 70
2545: ST_TO_ADDR
// if tmp then
2546: LD_VAR 0 3
2550: IFFALSE 2584
// for i in tmp do
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 3
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2582
// ComMoveXY ( i , 114 , 9 ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 114
2572: PPUSH
2573: LD_INT 9
2575: PPUSH
2576: CALL_OW 111
2580: GO 2562
2582: POP
2583: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2584: LD_INT 18
2586: PPUSH
2587: EMPTY
2588: PPUSH
2589: CALL_OW 70
2593: NOT
2594: PUSH
2595: LD_INT 123
2597: PPUSH
2598: LD_INT 3
2600: PPUSH
2601: CALL_OW 428
2605: PUSH
2606: LD_INT 0
2608: EQUAL
2609: AND
2610: IFFALSE 2524
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2612: LD_EXP 51
2616: PPUSH
2617: LD_INT 123
2619: PPUSH
2620: LD_INT 3
2622: PPUSH
2623: LD_INT 0
2625: PPUSH
2626: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2630: LD_EXP 48
2634: PPUSH
2635: LD_INT 125
2637: PPUSH
2638: LD_INT 1
2640: PPUSH
2641: LD_INT 0
2643: PPUSH
2644: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2648: LD_EXP 48
2652: PPUSH
2653: LD_EXP 51
2657: PPUSH
2658: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2662: LD_INT 10
2664: PPUSH
2665: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2669: LD_EXP 51
2673: PPUSH
2674: LD_INT 110
2676: PPUSH
2677: LD_INT 10
2679: PPUSH
2680: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2684: LD_ADDR_EXP 44
2688: PUSH
2689: LD_STRING Petrovova
2691: PPUSH
2692: CALL_OW 25
2696: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2697: LD_ADDR_EXP 46
2701: PUSH
2702: LD_STRING Kuzmov
2704: PPUSH
2705: CALL_OW 25
2709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2710: LD_ADDR_EXP 45
2714: PUSH
2715: LD_STRING Kovalyuk
2717: PPUSH
2718: CALL_OW 25
2722: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2723: LD_ADDR_EXP 43
2727: PUSH
2728: LD_STRING Lipshchin
2730: PPUSH
2731: CALL_OW 25
2735: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2736: LD_ADDR_EXP 47
2740: PUSH
2741: LD_STRING Karamazov
2743: PPUSH
2744: CALL_OW 25
2748: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 44
2758: PUSH
2759: LD_EXP 46
2763: PUSH
2764: LD_EXP 45
2768: PUSH
2769: LD_EXP 43
2773: PUSH
2774: LD_EXP 47
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: ST_TO_ADDR
// for i in tmp do
2786: LD_ADDR_VAR 0 2
2790: PUSH
2791: LD_VAR 0 3
2795: PUSH
2796: FOR_IN
2797: IFFALSE 2836
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2799: LD_VAR 0 2
2803: PPUSH
2804: LD_INT 399
2806: PPUSH
2807: LD_INT 799
2809: PPUSH
2810: CALL_OW 12
2814: PPUSH
2815: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 19
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
// end ;
2834: GO 2796
2836: POP
2837: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2838: LD_VAR 0 3
2842: PPUSH
2843: LD_INT 112
2845: PPUSH
2846: LD_INT 5
2848: PPUSH
2849: CALL_OW 111
// AddComHold ( tmp ) ;
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2862: LD_ADDR_VAR 0 2
2866: PUSH
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 25
2874: PUSH
2875: LD_INT 1
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 72
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2928
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2890: LD_VAR 0 2
2894: PPUSH
2895: LD_INT 20
2897: PPUSH
2898: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2902: LD_VAR 0 2
2906: PPUSH
2907: LD_INT 147
2909: PPUSH
2910: LD_INT 45
2912: PPUSH
2913: CALL_OW 178
// AddComCrawl ( i ) ;
2917: LD_VAR 0 2
2921: PPUSH
2922: CALL_OW 197
// end ;
2926: GO 2887
2928: POP
2929: POP
// repeat wait ( 0 0$1 ) ;
2930: LD_INT 35
2932: PPUSH
2933: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2937: LD_EXP 51
2941: PPUSH
2942: LD_INT 110
2944: PPUSH
2945: LD_INT 10
2947: PPUSH
2948: CALL_OW 307
2952: PUSH
2953: LD_EXP 51
2957: PPUSH
2958: CALL_OW 305
2962: NOT
2963: OR
2964: IFFALSE 2930
// ComStop ( Burlak ) ;
2966: LD_EXP 48
2970: PPUSH
2971: CALL_OW 141
// AddComHold ( Burlak ) ;
2975: LD_EXP 48
2979: PPUSH
2980: CALL_OW 200
// end ; end_of_file
2984: LD_VAR 0 1
2988: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2989: LD_INT 0
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
2995: PPUSH
// uc_side := 3 ;
2996: LD_ADDR_OWVAR 20
3000: PUSH
3001: LD_INT 3
3003: ST_TO_ADDR
// uc_nation := 3 ;
3004: LD_ADDR_OWVAR 21
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3012: LD_ADDR_EXP 52
3016: PUSH
3017: LD_INT 47
3019: PPUSH
3020: LD_INT 4
3022: PPUSH
3023: LD_STRING 
3025: PPUSH
3026: LD_INT 7
3028: PUSH
3029: LD_INT 8
3031: PUSH
3032: LD_INT 9
3034: PUSH
3035: LD_INT 10
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: LD_OWVAR 67
3048: ARRAY
3049: PPUSH
3050: LD_INT 10000
3052: PUSH
3053: LD_INT 3000
3055: PUSH
3056: LD_INT 300
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: PPUSH
3064: LD_INT 9
3066: PUSH
3067: LD_INT 5
3069: PUSH
3070: LD_INT 6
3072: PUSH
3073: LD_INT 6
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: CALL 24162 0 6
3086: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3087: LD_ADDR_EXP 61
3091: PUSH
3092: LD_EXP 61
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: LD_EXP 52
3104: PPUSH
3105: CALL_OW 1
3109: ST_TO_ADDR
// tmp := [ ] ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: EMPTY
3116: ST_TO_ADDR
// for i = 1 to 4 do
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: DOUBLE
3123: LD_INT 1
3125: DEC
3126: ST_TO_ADDR
3127: LD_INT 4
3129: PUSH
3130: FOR_TO
3131: IFFALSE 3224
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3133: LD_INT 22
3135: PPUSH
3136: LD_INT 3
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: LD_INT 43
3144: PUSH
3145: LD_INT 45
3147: PUSH
3148: LD_INT 45
3150: PUSH
3151: LD_INT 44
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: PUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 4
3167: MOD
3168: PUSH
3169: LD_INT 1
3171: PLUS
3172: ARRAY
3173: PPUSH
3174: LD_INT 100
3176: PPUSH
3177: CALL 20341 0 5
// veh := CreateVehicle ;
3181: LD_ADDR_VAR 0 3
3185: PUSH
3186: CALL_OW 45
3190: ST_TO_ADDR
// tmp := tmp ^ veh ;
3191: LD_ADDR_VAR 0 4
3195: PUSH
3196: LD_VAR 0 4
3200: PUSH
3201: LD_VAR 0 3
3205: ADD
3206: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3207: LD_VAR 0 3
3211: PPUSH
3212: LD_INT 2
3214: PPUSH
3215: LD_INT 0
3217: PPUSH
3218: CALL_OW 49
// end ;
3222: GO 3130
3224: POP
3225: POP
// russian_guard := tmp ;
3226: LD_ADDR_EXP 53
3230: PUSH
3231: LD_VAR 0 4
3235: ST_TO_ADDR
// if Difficulty >= 3 then
3236: LD_OWVAR 67
3240: PUSH
3241: LD_INT 3
3243: GREATEREQUAL
3244: IFFALSE 3308
// begin bc_type := b_breastwork ;
3246: LD_ADDR_OWVAR 42
3250: PUSH
3251: LD_INT 31
3253: ST_TO_ADDR
// bc_level := 10 ;
3254: LD_ADDR_OWVAR 43
3258: PUSH
3259: LD_INT 10
3261: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3262: LD_ADDR_VAR 0 5
3266: PUSH
3267: LD_INT 96
3269: PPUSH
3270: LD_INT 105
3272: PPUSH
3273: LD_INT 3
3275: PPUSH
3276: CALL_OW 47
3280: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 9
3286: PPUSH
3287: LD_INT 10
3289: PPUSH
3290: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3294: CALL_OW 44
3298: PPUSH
3299: LD_VAR 0 5
3303: PPUSH
3304: CALL_OW 52
// end ; end ;
3308: LD_VAR 0 1
3312: RET
// every 7 7$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , flags , _target , attackers , amount ;
3313: LD_INT 47
3315: PPUSH
3316: CALL_OW 302
3320: PUSH
3321: LD_EXP 6
3325: AND
3326: IFFALSE 4082
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
3340: PPUSH
// begin enable ;
3341: ENABLE
// base := 2 ;
3342: LD_ADDR_VAR 0 3
3346: PUSH
3347: LD_INT 2
3349: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3350: LD_ADDR_VAR 0 5
3354: PUSH
3355: LD_INT 0
3357: PUSH
3358: LD_INT 0
3360: PUSH
3361: LD_INT 0
3363: PUSH
3364: LD_INT 0
3366: PUSH
3367: LD_INT 0
3369: PUSH
3370: LD_INT 0
3372: PUSH
3373: LD_INT 0
3375: PUSH
3376: LD_INT 0
3378: PUSH
3379: LD_INT 1
3381: PUSH
3382: LD_INT 0
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3397: LD_ADDR_VAR 0 4
3401: PUSH
3402: LD_INT 22
3404: PUSH
3405: LD_INT 1
3407: PUSH
3408: LD_INT 3
3410: PUSH
3411: LD_INT 45
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PUSH
3420: LD_INT 21
3422: PUSH
3423: LD_INT 1
3425: PUSH
3426: LD_INT 3
3428: PUSH
3429: LD_INT 45
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: PUSH
3438: LD_INT 22
3440: PUSH
3441: LD_INT 1
3443: PUSH
3444: LD_INT 3
3446: PUSH
3447: LD_INT 45
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: LIST
3454: LIST
3455: PUSH
3456: LD_INT 23
3458: PUSH
3459: LD_INT 1
3461: PUSH
3462: LD_INT 3
3464: PUSH
3465: LD_INT 46
3467: PUSH
3468: EMPTY
3469: LIST
3470: LIST
3471: LIST
3472: LIST
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: LIST
3478: LIST
3479: ST_TO_ADDR
// amount := Difficulty ;
3480: LD_ADDR_VAR 0 8
3484: PUSH
3485: LD_OWVAR 67
3489: ST_TO_ADDR
// if tick > 30 30$00 then
3490: LD_OWVAR 1
3494: PUSH
3495: LD_INT 63000
3497: GREATER
3498: IFFALSE 3535
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3500: LD_ADDR_VAR 0 8
3504: PUSH
3505: LD_VAR 0 8
3509: PUSH
3510: LD_INT 2
3512: PUSH
3513: LD_INT 3
3515: PUSH
3516: LD_INT 4
3518: PUSH
3519: LD_INT 4
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: LIST
3527: PUSH
3528: LD_OWVAR 67
3532: ARRAY
3533: PLUS
3534: ST_TO_ADDR
// for i = 1 to amount do
3535: LD_ADDR_VAR 0 1
3539: PUSH
3540: DOUBLE
3541: LD_INT 1
3543: DEC
3544: ST_TO_ADDR
3545: LD_VAR 0 8
3549: PUSH
3550: FOR_TO
3551: IFFALSE 3639
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3553: LD_ADDR_VAR 0 4
3557: PUSH
3558: LD_VAR 0 4
3562: PPUSH
3563: LD_VAR 0 4
3567: PUSH
3568: LD_INT 1
3570: PLUS
3571: PPUSH
3572: LD_INT 23
3574: PUSH
3575: LD_INT 24
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: PUSH
3582: LD_INT 1
3584: PPUSH
3585: LD_INT 2
3587: PPUSH
3588: CALL_OW 12
3592: ARRAY
3593: PUSH
3594: LD_INT 1
3596: PUSH
3597: LD_INT 3
3599: PUSH
3600: LD_INT 46
3602: PUSH
3603: LD_INT 47
3605: PUSH
3606: LD_INT 45
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 1
3616: PPUSH
3617: LD_INT 3
3619: PPUSH
3620: CALL_OW 12
3624: ARRAY
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: LIST
3630: LIST
3631: PPUSH
3632: CALL_OW 2
3636: ST_TO_ADDR
3637: GO 3550
3639: POP
3640: POP
// p := 1 ;
3641: LD_ADDR_VAR 0 2
3645: PUSH
3646: LD_INT 1
3648: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3649: LD_VAR 0 3
3653: PPUSH
3654: LD_VAR 0 4
3658: PPUSH
3659: CALL 81707 0 2
// repeat wait ( 0 0$1 ) ;
3663: LD_INT 35
3665: PPUSH
3666: CALL_OW 67
// p := Inc ( p ) ;
3670: LD_ADDR_VAR 0 2
3674: PUSH
3675: LD_VAR 0 2
3679: PPUSH
3680: CALL 54564 0 1
3684: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 100 ;
3685: LD_VAR 0 3
3689: PPUSH
3690: LD_INT 1
3692: PPUSH
3693: CALL 83125 0 2
3697: PUSH
3698: LD_VAR 0 8
3702: GREATEREQUAL
3703: PUSH
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 100
3711: GREATEREQUAL
3712: OR
3713: IFFALSE 3663
// wait ( 0 0$30 ) ;
3715: LD_INT 1050
3717: PPUSH
3718: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3722: LD_ADDR_VAR 0 6
3726: PUSH
3727: LD_INT 71
3729: PUSH
3730: LD_INT 19
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: PUSH
3737: LD_INT 91
3739: PUSH
3740: LD_INT 67
3742: PUSH
3743: EMPTY
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 52
3749: PUSH
3750: LD_INT 44
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 68
3759: PUSH
3760: LD_INT 48
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_EXP 80
3782: PUSH
3783: LD_VAR 0 3
3787: ARRAY
3788: PUSH
3789: LD_EXP 80
3793: PUSH
3794: LD_VAR 0 3
3798: ARRAY
3799: PPUSH
3800: LD_INT 2
3802: PUSH
3803: LD_INT 34
3805: PUSH
3806: LD_INT 51
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: LD_INT 34
3815: PUSH
3816: LD_INT 52
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PPUSH
3828: CALL_OW 72
3832: DIFF
3833: ST_TO_ADDR
// if not attackers then
3834: LD_VAR 0 7
3838: NOT
3839: IFFALSE 3843
// exit ;
3841: GO 4082
// ru_attackers := attackers ;
3843: LD_ADDR_EXP 54
3847: PUSH
3848: LD_VAR 0 7
3852: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3853: LD_ADDR_EXP 80
3857: PUSH
3858: LD_EXP 80
3862: PPUSH
3863: LD_VAR 0 3
3867: PPUSH
3868: LD_EXP 80
3872: PUSH
3873: LD_VAR 0 3
3877: ARRAY
3878: PUSH
3879: LD_VAR 0 7
3883: DIFF
3884: PPUSH
3885: CALL_OW 1
3889: ST_TO_ADDR
// for i = 1 to attackers do
3890: LD_ADDR_VAR 0 1
3894: PUSH
3895: DOUBLE
3896: LD_INT 1
3898: DEC
3899: ST_TO_ADDR
3900: LD_VAR 0 7
3904: PUSH
3905: FOR_TO
3906: IFFALSE 3983
// begin case i mod 3 of 0 :
3908: LD_VAR 0 1
3912: PUSH
3913: LD_INT 3
3915: MOD
3916: PUSH
3917: LD_INT 0
3919: DOUBLE
3920: EQUAL
3921: IFTRUE 3925
3923: GO 3928
3925: POP
// ; 1 :
3926: GO 3981
3928: LD_INT 1
3930: DOUBLE
3931: EQUAL
3932: IFTRUE 3936
3934: GO 3954
3936: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3937: LD_VAR 0 1
3941: PPUSH
3942: LD_INT 32
3944: PPUSH
3945: LD_INT 49
3947: PPUSH
3948: CALL_OW 114
3952: GO 3981
3954: LD_INT 2
3956: DOUBLE
3957: EQUAL
3958: IFTRUE 3962
3960: GO 3980
3962: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3963: LD_VAR 0 1
3967: PPUSH
3968: LD_INT 117
3970: PPUSH
3971: LD_INT 107
3973: PPUSH
3974: CALL_OW 114
3978: GO 3981
3980: POP
// end ;
3981: GO 3905
3983: POP
3984: POP
// p := 0 ;
3985: LD_ADDR_VAR 0 2
3989: PUSH
3990: LD_INT 0
3992: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3993: LD_INT 35
3995: PPUSH
3996: CALL_OW 67
// p := Inc ( p ) ;
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: LD_VAR 0 2
4009: PPUSH
4010: CALL 54564 0 1
4014: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
4015: LD_VAR 0 7
4019: PPUSH
4020: LD_INT 60
4022: PUSH
4023: EMPTY
4024: LIST
4025: PPUSH
4026: CALL_OW 72
4030: NOT
4031: PUSH
4032: LD_VAR 0 2
4036: PUSH
4037: LD_INT 30
4039: GREATER
4040: OR
4041: IFFALSE 3993
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
4043: LD_VAR 0 3
4047: PPUSH
4048: LD_VAR 0 7
4052: PPUSH
4053: LD_VAR 0 6
4057: PPUSH
4058: LD_VAR 0 5
4062: PPUSH
4063: CALL 81892 0 4
// if not first_attack then
4067: LD_EXP 7
4071: NOT
4072: IFFALSE 4082
// first_attack := true ;
4074: LD_ADDR_EXP 7
4078: PUSH
4079: LD_INT 1
4081: ST_TO_ADDR
// end ; end_of_file
4082: PPOPN 8
4084: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4085: LD_INT 0
4087: PPUSH
4088: PPUSH
4089: PPUSH
4090: PPUSH
4091: PPUSH
4092: PPUSH
4093: PPUSH
// uc_side := 2 ;
4094: LD_ADDR_OWVAR 20
4098: PUSH
4099: LD_INT 2
4101: ST_TO_ADDR
// uc_nation := 2 ;
4102: LD_ADDR_OWVAR 21
4106: PUSH
4107: LD_INT 2
4109: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4110: LD_ADDR_EXP 57
4114: PUSH
4115: LD_STRING Abdul
4117: PPUSH
4118: CALL_OW 25
4122: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4123: LD_EXP 57
4127: PPUSH
4128: LD_INT 11
4130: PPUSH
4131: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4135: LD_EXP 57
4139: PPUSH
4140: LD_INT 1
4142: PPUSH
4143: CALL_OW 52
// vc_chassis := 31 ;
4147: LD_ADDR_OWVAR 37
4151: PUSH
4152: LD_INT 31
4154: ST_TO_ADDR
// vc_control := control_rider ;
4155: LD_ADDR_OWVAR 38
4159: PUSH
4160: LD_INT 4
4162: ST_TO_ADDR
// mastodont := CreateVehicle ;
4163: LD_ADDR_EXP 58
4167: PUSH
4168: CALL_OW 45
4172: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4173: LD_EXP 58
4177: PPUSH
4178: LD_INT 153
4180: PPUSH
4181: LD_INT 71
4183: PPUSH
4184: LD_INT 0
4186: PPUSH
4187: CALL_OW 48
// InitVc ;
4191: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4195: LD_ADDR_EXP 55
4199: PUSH
4200: LD_INT 1
4202: PPUSH
4203: LD_INT 3
4205: PPUSH
4206: LD_STRING kaba
4208: PPUSH
4209: LD_INT 7
4211: PUSH
4212: LD_INT 8
4214: PUSH
4215: LD_INT 9
4217: PUSH
4218: LD_INT 10
4220: PUSH
4221: EMPTY
4222: LIST
4223: LIST
4224: LIST
4225: LIST
4226: PUSH
4227: LD_OWVAR 67
4231: ARRAY
4232: PPUSH
4233: LD_INT 5000
4235: PUSH
4236: LD_INT 1000
4238: PUSH
4239: LD_INT 300
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: LIST
4246: PPUSH
4247: LD_INT 18
4249: PUSH
4250: LD_INT 5
4252: PUSH
4253: LD_INT 6
4255: PUSH
4256: LD_INT 9
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: PPUSH
4265: CALL 24162 0 6
4269: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4270: LD_ADDR_EXP 61
4274: PUSH
4275: LD_EXP 61
4279: PPUSH
4280: LD_INT 1
4282: PPUSH
4283: LD_EXP 55
4287: PPUSH
4288: CALL_OW 1
4292: ST_TO_ADDR
// tmp := [ ] ;
4293: LD_ADDR_VAR 0 4
4297: PUSH
4298: EMPTY
4299: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
4300: LD_ADDR_OWVAR 37
4304: PUSH
4305: LD_INT 13
4307: ST_TO_ADDR
// vc_engine := engine_siberite ;
4308: LD_ADDR_OWVAR 39
4312: PUSH
4313: LD_INT 3
4315: ST_TO_ADDR
// vc_control := control_manual ;
4316: LD_ADDR_OWVAR 38
4320: PUSH
4321: LD_INT 1
4323: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4324: LD_ADDR_OWVAR 40
4328: PUSH
4329: LD_INT 31
4331: ST_TO_ADDR
// for i = 1 to 3 do
4332: LD_ADDR_VAR 0 2
4336: PUSH
4337: DOUBLE
4338: LD_INT 1
4340: DEC
4341: ST_TO_ADDR
4342: LD_INT 3
4344: PUSH
4345: FOR_TO
4346: IFFALSE 4594
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4348: LD_ADDR_VAR 0 5
4352: PUSH
4353: LD_INT 153
4355: PUSH
4356: LD_INT 71
4358: PUSH
4359: EMPTY
4360: LIST
4361: LIST
4362: PUSH
4363: LD_INT 155
4365: PUSH
4366: LD_INT 81
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PUSH
4377: LD_VAR 0 2
4381: PUSH
4382: LD_INT 2
4384: MOD
4385: PUSH
4386: LD_INT 1
4388: PLUS
4389: ARRAY
4390: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4391: LD_INT 0
4393: PPUSH
4394: LD_INT 3
4396: PPUSH
4397: LD_INT 7
4399: PUSH
4400: LD_INT 8
4402: PUSH
4403: LD_INT 10
4405: PUSH
4406: LD_INT 10
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: LIST
4413: LIST
4414: PUSH
4415: LD_OWVAR 67
4419: ARRAY
4420: PPUSH
4421: CALL_OW 380
// un := CreateVehicle ;
4425: LD_ADDR_VAR 0 6
4429: PUSH
4430: CALL_OW 45
4434: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4435: LD_VAR 0 6
4439: PPUSH
4440: LD_INT 0
4442: PPUSH
4443: LD_INT 5
4445: PPUSH
4446: CALL_OW 12
4450: PPUSH
4451: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4455: LD_VAR 0 6
4459: PPUSH
4460: LD_VAR 0 5
4464: PUSH
4465: LD_INT 1
4467: ARRAY
4468: PPUSH
4469: LD_VAR 0 5
4473: PUSH
4474: LD_INT 2
4476: ARRAY
4477: PPUSH
4478: LD_INT 6
4480: PPUSH
4481: LD_INT 0
4483: PPUSH
4484: CALL_OW 50
// un2 := CreateHuman ;
4488: LD_ADDR_VAR 0 7
4492: PUSH
4493: CALL_OW 44
4497: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4498: LD_VAR 0 7
4502: PPUSH
4503: LD_VAR 0 6
4507: PPUSH
4508: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4512: LD_ADDR_EXP 61
4516: PUSH
4517: LD_EXP 61
4521: PPUSH
4522: LD_INT 1
4524: PUSH
4525: LD_EXP 61
4529: PUSH
4530: LD_INT 1
4532: ARRAY
4533: PUSH
4534: LD_INT 1
4536: PLUS
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PPUSH
4542: LD_VAR 0 6
4546: PPUSH
4547: CALL 20463 0 3
4551: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4552: LD_ADDR_EXP 61
4556: PUSH
4557: LD_EXP 61
4561: PPUSH
4562: LD_INT 1
4564: PUSH
4565: LD_EXP 61
4569: PUSH
4570: LD_INT 1
4572: ARRAY
4573: PUSH
4574: LD_INT 1
4576: PLUS
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: PPUSH
4582: LD_VAR 0 7
4586: PPUSH
4587: CALL 20463 0 3
4591: ST_TO_ADDR
// end ;
4592: GO 4345
4594: POP
4595: POP
// for i = 1 to 5 do
4596: LD_ADDR_VAR 0 2
4600: PUSH
4601: DOUBLE
4602: LD_INT 1
4604: DEC
4605: ST_TO_ADDR
4606: LD_INT 5
4608: PUSH
4609: FOR_TO
4610: IFFALSE 4703
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4612: LD_INT 13
4614: PPUSH
4615: LD_INT 3
4617: PPUSH
4618: LD_INT 1
4620: PPUSH
4621: LD_INT 25
4623: PUSH
4624: LD_INT 28
4626: PUSH
4627: LD_INT 28
4629: PUSH
4630: LD_INT 26
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: LIST
4637: LIST
4638: PUSH
4639: LD_VAR 0 2
4643: PUSH
4644: LD_INT 4
4646: MOD
4647: PUSH
4648: LD_INT 1
4650: PLUS
4651: ARRAY
4652: PPUSH
4653: LD_INT 100
4655: PPUSH
4656: CALL 20341 0 5
// veh := CreateVehicle ;
4660: LD_ADDR_VAR 0 3
4664: PUSH
4665: CALL_OW 45
4669: ST_TO_ADDR
// tmp := tmp ^ veh ;
4670: LD_ADDR_VAR 0 4
4674: PUSH
4675: LD_VAR 0 4
4679: PUSH
4680: LD_VAR 0 3
4684: ADD
4685: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4686: LD_VAR 0 3
4690: PPUSH
4691: LD_INT 1
4693: PPUSH
4694: LD_INT 0
4696: PPUSH
4697: CALL_OW 49
// end ;
4701: GO 4609
4703: POP
4704: POP
// arabian_guard := tmp ;
4705: LD_ADDR_EXP 56
4709: PUSH
4710: LD_VAR 0 4
4714: ST_TO_ADDR
// end ;
4715: LD_VAR 0 1
4719: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4720: LD_INT 22
4722: PUSH
4723: LD_INT 7
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 91
4732: PUSH
4733: LD_INT 1
4735: PUSH
4736: LD_INT 12
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: LIST
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: PPUSH
4748: CALL_OW 69
4752: PUSH
4753: LD_EXP 58
4757: PPUSH
4758: CALL_OW 256
4762: PUSH
4763: LD_INT 990
4765: LESS
4766: OR
4767: PUSH
4768: LD_EXP 57
4772: PPUSH
4773: CALL_OW 256
4777: PUSH
4778: LD_INT 990
4780: LESS
4781: OR
4782: IFFALSE 4925
4784: GO 4786
4786: DISABLE
// begin if IsInUnit ( Abdul ) then
4787: LD_EXP 57
4791: PPUSH
4792: CALL_OW 310
4796: IFFALSE 4807
// ComExitBuilding ( Abdul ) ;
4798: LD_EXP 57
4802: PPUSH
4803: CALL_OW 122
// if Mastodont then
4807: LD_EXP 58
4811: IFFALSE 4828
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 205
4820: PPUSH
4821: LD_INT 132
4823: PPUSH
4824: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4828: LD_EXP 57
4832: PPUSH
4833: LD_INT 205
4835: PPUSH
4836: LD_INT 132
4838: PPUSH
4839: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4843: LD_INT 35
4845: PPUSH
4846: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4850: LD_EXP 57
4854: PPUSH
4855: LD_INT 21
4857: PPUSH
4858: CALL_OW 308
4862: IFFALSE 4843
// RemoveUnit ( Abdul ) ;
4864: LD_EXP 57
4868: PPUSH
4869: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4873: LD_INT 35
4875: PPUSH
4876: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4880: LD_EXP 58
4884: PPUSH
4885: LD_INT 21
4887: PPUSH
4888: CALL_OW 308
4892: PUSH
4893: LD_EXP 58
4897: PPUSH
4898: CALL_OW 301
4902: OR
4903: IFFALSE 4873
// if IsOk ( Mastodont ) then
4905: LD_EXP 58
4909: PPUSH
4910: CALL_OW 302
4914: IFFALSE 4925
// RemoveUnit ( Mastodont ) ;
4916: LD_EXP 58
4920: PPUSH
4921: CALL_OW 64
// end ;
4925: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4926: LD_EXP 57
4930: PPUSH
4931: CALL_OW 301
4935: PUSH
4936: LD_INT 22
4938: PUSH
4939: LD_INT 2
4941: PUSH
4942: EMPTY
4943: LIST
4944: LIST
4945: PUSH
4946: LD_INT 2
4948: PUSH
4949: LD_INT 25
4951: PUSH
4952: LD_INT 1
4954: PUSH
4955: EMPTY
4956: LIST
4957: LIST
4958: PUSH
4959: LD_INT 25
4961: PUSH
4962: LD_INT 2
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: PUSH
4969: LD_INT 25
4971: PUSH
4972: LD_INT 3
4974: PUSH
4975: EMPTY
4976: LIST
4977: LIST
4978: PUSH
4979: LD_INT 25
4981: PUSH
4982: LD_INT 4
4984: PUSH
4985: EMPTY
4986: LIST
4987: LIST
4988: PUSH
4989: LD_INT 25
4991: PUSH
4992: LD_INT 8
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PPUSH
5011: CALL_OW 69
5015: PUSH
5016: LD_INT 16
5018: PUSH
5019: LD_INT 19
5021: PUSH
5022: LD_INT 22
5024: PUSH
5025: LD_INT 22
5027: PUSH
5028: EMPTY
5029: LIST
5030: LIST
5031: LIST
5032: LIST
5033: PUSH
5034: LD_OWVAR 67
5038: ARRAY
5039: LESS
5040: OR
5041: IFFALSE 5714
5043: GO 5045
5045: DISABLE
5046: LD_INT 0
5048: PPUSH
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
// begin MC_Kill ( 1 ) ;
5054: LD_INT 1
5056: PPUSH
5057: CALL 57682 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5061: LD_ADDR_VAR 0 2
5065: PUSH
5066: LD_INT 22
5068: PUSH
5069: LD_INT 2
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PUSH
5076: LD_INT 2
5078: PUSH
5079: LD_INT 25
5081: PUSH
5082: LD_INT 1
5084: PUSH
5085: EMPTY
5086: LIST
5087: LIST
5088: PUSH
5089: LD_INT 25
5091: PUSH
5092: LD_INT 2
5094: PUSH
5095: EMPTY
5096: LIST
5097: LIST
5098: PUSH
5099: LD_INT 25
5101: PUSH
5102: LD_INT 3
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PUSH
5109: LD_INT 25
5111: PUSH
5112: LD_INT 4
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 25
5121: PUSH
5122: LD_INT 8
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: LIST
5133: LIST
5134: LIST
5135: LIST
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: PPUSH
5141: CALL_OW 69
5145: ST_TO_ADDR
// for i in tmp do
5146: LD_ADDR_VAR 0 5
5150: PUSH
5151: LD_VAR 0 2
5155: PUSH
5156: FOR_IN
5157: IFFALSE 5173
// SetTag ( i , 10 ) ;
5159: LD_VAR 0 5
5163: PPUSH
5164: LD_INT 10
5166: PPUSH
5167: CALL_OW 109
5171: GO 5156
5173: POP
5174: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5175: LD_ADDR_VAR 0 3
5179: PUSH
5180: LD_INT 22
5182: PUSH
5183: LD_INT 2
5185: PUSH
5186: EMPTY
5187: LIST
5188: LIST
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: LD_INT 1
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: PUSH
5200: EMPTY
5201: LIST
5202: LIST
5203: PPUSH
5204: CALL_OW 69
5208: PUSH
5209: LD_VAR 0 2
5213: DIFF
5214: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5215: LD_ADDR_VAR 0 1
5219: PUSH
5220: LD_INT 22
5222: PUSH
5223: LD_INT 2
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 21
5232: PUSH
5233: LD_INT 2
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 24
5242: PUSH
5243: LD_INT 300
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: LIST
5254: PPUSH
5255: CALL_OW 69
5259: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5260: LD_ADDR_VAR 0 4
5264: PUSH
5265: LD_VAR 0 1
5269: PPUSH
5270: LD_INT 33
5272: PUSH
5273: LD_INT 1
5275: PUSH
5276: EMPTY
5277: LIST
5278: LIST
5279: PUSH
5280: LD_INT 58
5282: PUSH
5283: EMPTY
5284: LIST
5285: PUSH
5286: EMPTY
5287: LIST
5288: LIST
5289: PPUSH
5290: CALL_OW 72
5294: ST_TO_ADDR
// for i in tmp do
5295: LD_ADDR_VAR 0 5
5299: PUSH
5300: LD_VAR 0 2
5304: PUSH
5305: FOR_IN
5306: IFFALSE 5490
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5308: LD_VAR 0 5
5312: PUSH
5313: LD_INT 55
5315: PUSH
5316: EMPTY
5317: LIST
5318: PPUSH
5319: CALL_OW 69
5323: IN
5324: IFFALSE 5343
// begin AddComMoveXY ( i , 209 , 132 ) ;
5326: LD_VAR 0 5
5330: PPUSH
5331: LD_INT 209
5333: PPUSH
5334: LD_INT 132
5336: PPUSH
5337: CALL_OW 171
// continue ;
5341: GO 5305
// end ; if IsInUnit ( i ) then
5343: LD_VAR 0 5
5347: PPUSH
5348: CALL_OW 310
5352: IFFALSE 5370
// begin ComExitBuilding ( i ) ;
5354: LD_VAR 0 5
5358: PPUSH
5359: CALL_OW 122
// wait ( 3 ) ;
5363: LD_INT 3
5365: PPUSH
5366: CALL_OW 67
// end ; if tmp_empty then
5370: LD_VAR 0 4
5374: IFFALSE 5473
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5376: LD_VAR 0 5
5380: PPUSH
5381: LD_VAR 0 4
5385: PPUSH
5386: LD_VAR 0 5
5390: PPUSH
5391: CALL_OW 74
5395: PPUSH
5396: CALL_OW 296
5400: PUSH
5401: LD_INT 25
5403: LESS
5404: IFFALSE 5473
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5406: LD_ADDR_VAR 0 6
5410: PUSH
5411: LD_VAR 0 4
5415: PPUSH
5416: LD_VAR 0 5
5420: PPUSH
5421: CALL_OW 74
5425: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5426: LD_VAR 0 5
5430: PPUSH
5431: LD_VAR 0 6
5435: PPUSH
5436: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5440: LD_VAR 0 5
5444: PPUSH
5445: LD_INT 209
5447: PPUSH
5448: LD_INT 132
5450: PPUSH
5451: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5455: LD_ADDR_VAR 0 4
5459: PUSH
5460: LD_VAR 0 4
5464: PUSH
5465: LD_VAR 0 6
5469: DIFF
5470: ST_TO_ADDR
// continue ;
5471: GO 5305
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5473: LD_VAR 0 5
5477: PPUSH
5478: LD_INT 201
5480: PPUSH
5481: LD_INT 132
5483: PPUSH
5484: CALL_OW 171
// end ;
5488: GO 5305
5490: POP
5491: POP
// for i in tmp_ape do
5492: LD_ADDR_VAR 0 5
5496: PUSH
5497: LD_VAR 0 3
5501: PUSH
5502: FOR_IN
5503: IFFALSE 5542
// begin if IsInUnit ( i ) then
5505: LD_VAR 0 5
5509: PPUSH
5510: CALL_OW 310
5514: IFFALSE 5525
// ComExitBuilding ( i ) ;
5516: LD_VAR 0 5
5520: PPUSH
5521: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5525: LD_VAR 0 5
5529: PPUSH
5530: LD_INT 201
5532: PPUSH
5533: LD_INT 132
5535: PPUSH
5536: CALL_OW 171
// end ;
5540: GO 5502
5542: POP
5543: POP
// repeat wait ( 0 0$1 ) ;
5544: LD_INT 35
5546: PPUSH
5547: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5551: LD_ADDR_VAR 0 5
5555: PUSH
5556: LD_VAR 0 2
5560: PUSH
5561: LD_VAR 0 3
5565: UNION
5566: PUSH
5567: LD_VAR 0 1
5571: UNION
5572: PUSH
5573: FOR_IN
5574: IFFALSE 5605
// if not HasTask ( i ) then
5576: LD_VAR 0 5
5580: PPUSH
5581: CALL_OW 314
5585: NOT
5586: IFFALSE 5603
// ComMoveXY ( i , 201 , 132 ) ;
5588: LD_VAR 0 5
5592: PPUSH
5593: LD_INT 201
5595: PPUSH
5596: LD_INT 132
5598: PPUSH
5599: CALL_OW 111
5603: GO 5573
5605: POP
5606: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5607: LD_INT 21
5609: PPUSH
5610: LD_INT 22
5612: PUSH
5613: LD_INT 2
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 70
5624: IFFALSE 5665
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5626: LD_ADDR_VAR 0 5
5630: PUSH
5631: LD_INT 21
5633: PPUSH
5634: LD_INT 22
5636: PUSH
5637: LD_INT 2
5639: PUSH
5640: EMPTY
5641: LIST
5642: LIST
5643: PPUSH
5644: CALL_OW 70
5648: PUSH
5649: FOR_IN
5650: IFFALSE 5663
// RemoveUnit ( i ) ;
5652: LD_VAR 0 5
5656: PPUSH
5657: CALL_OW 64
5661: GO 5649
5663: POP
5664: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5665: LD_INT 22
5667: PUSH
5668: LD_INT 2
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 2
5677: PUSH
5678: LD_INT 21
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: PUSH
5688: LD_INT 21
5690: PUSH
5691: LD_INT 2
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: PPUSH
5707: CALL_OW 69
5711: NOT
5712: IFFALSE 5544
// end ;
5714: PPOPN 6
5716: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5717: LD_EXP 9
5721: PUSH
5722: LD_INT 92
5724: PPUSH
5725: LD_INT 40
5727: PPUSH
5728: CALL_OW 428
5732: PPUSH
5733: CALL_OW 266
5737: PUSH
5738: LD_INT 30
5740: EQUAL
5741: AND
5742: IFFALSE 5938
5744: GO 5746
5746: DISABLE
5747: LD_INT 0
5749: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5750: LD_ADDR_VAR 0 1
5754: PUSH
5755: LD_EXP 61
5759: PUSH
5760: LD_INT 1
5762: ARRAY
5763: PPUSH
5764: LD_INT 25
5766: PUSH
5767: LD_INT 4
5769: PUSH
5770: EMPTY
5771: LIST
5772: LIST
5773: PPUSH
5774: CALL_OW 72
5778: ST_TO_ADDR
// if not sci then
5779: LD_VAR 0 1
5783: NOT
5784: IFFALSE 5788
// exit ;
5786: GO 5938
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5788: LD_ADDR_EXP 61
5792: PUSH
5793: LD_EXP 61
5797: PPUSH
5798: LD_INT 1
5800: PPUSH
5801: LD_EXP 61
5805: PUSH
5806: LD_INT 1
5808: ARRAY
5809: PUSH
5810: LD_VAR 0 1
5814: PUSH
5815: LD_INT 1
5817: ARRAY
5818: DIFF
5819: PPUSH
5820: CALL_OW 1
5824: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5825: LD_VAR 0 1
5829: PUSH
5830: LD_INT 1
5832: ARRAY
5833: PPUSH
5834: CALL_OW 310
5838: IFFALSE 5853
// ComExitBuilding ( sci [ 1 ] ) ;
5840: LD_VAR 0 1
5844: PUSH
5845: LD_INT 1
5847: ARRAY
5848: PPUSH
5849: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5853: LD_INT 2
5855: PPUSH
5856: LD_INT 105
5858: PPUSH
5859: LD_INT 14
5861: PPUSH
5862: LD_INT 20
5864: PPUSH
5865: CALL 21727 0 4
5869: PUSH
5870: LD_INT 4
5872: ARRAY
5873: PUSH
5874: LD_INT 10
5876: LESS
5877: IFFALSE 5900
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5879: LD_VAR 0 1
5883: PUSH
5884: LD_INT 1
5886: ARRAY
5887: PPUSH
5888: LD_INT 105
5890: PPUSH
5891: LD_INT 14
5893: PPUSH
5894: CALL_OW 171
5898: GO 5919
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5900: LD_VAR 0 1
5904: PUSH
5905: LD_INT 1
5907: ARRAY
5908: PPUSH
5909: LD_INT 118
5911: PPUSH
5912: LD_INT 77
5914: PPUSH
5915: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5919: LD_VAR 0 1
5923: PUSH
5924: LD_INT 1
5926: ARRAY
5927: PPUSH
5928: LD_INT 92
5930: PPUSH
5931: LD_INT 40
5933: PPUSH
5934: CALL_OW 218
// end ;
5938: PPOPN 1
5940: END
// every 9 9$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
5941: LD_INT 1
5943: PPUSH
5944: CALL_OW 302
5948: PUSH
5949: LD_EXP 9
5953: AND
5954: IFFALSE 6742
5956: GO 5958
5958: DISABLE
5959: LD_INT 0
5961: PPUSH
5962: PPUSH
5963: PPUSH
5964: PPUSH
5965: PPUSH
5966: PPUSH
5967: PPUSH
5968: PPUSH
// begin enable ;
5969: ENABLE
// base := 1 ;
5970: LD_ADDR_VAR 0 3
5974: PUSH
5975: LD_INT 1
5977: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5978: LD_ADDR_VAR 0 5
5982: PUSH
5983: LD_INT 0
5985: PUSH
5986: LD_INT 0
5988: PUSH
5989: LD_INT 0
5991: PUSH
5992: LD_INT 0
5994: PUSH
5995: LD_INT 0
5997: PUSH
5998: LD_INT 0
6000: PUSH
6001: LD_INT 0
6003: PUSH
6004: LD_INT 0
6006: PUSH
6007: LD_INT 1
6009: PUSH
6010: LD_INT 0
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6025: LD_ADDR_VAR 0 4
6029: PUSH
6030: LD_INT 13
6032: PUSH
6033: LD_INT 1
6035: PUSH
6036: LD_INT 2
6038: PUSH
6039: LD_INT 26
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 13
6050: PUSH
6051: LD_INT 1
6053: PUSH
6054: LD_INT 2
6056: PUSH
6057: LD_INT 28
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 13
6068: PUSH
6069: LD_INT 1
6071: PUSH
6072: LD_INT 2
6074: PUSH
6075: LD_INT 29
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: LIST
6088: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6089: LD_ADDR_VAR 0 1
6093: PUSH
6094: DOUBLE
6095: LD_INT 1
6097: DEC
6098: ST_TO_ADDR
6099: LD_OWVAR 67
6103: PUSH
6104: LD_OWVAR 1
6108: PUSH
6109: LD_INT 21000
6111: DIV
6112: PLUS
6113: PUSH
6114: FOR_TO
6115: IFFALSE 6188
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6117: LD_ADDR_VAR 0 4
6121: PUSH
6122: LD_VAR 0 4
6126: PPUSH
6127: LD_VAR 0 4
6131: PUSH
6132: LD_INT 1
6134: PLUS
6135: PPUSH
6136: LD_INT 13
6138: PUSH
6139: LD_INT 1
6141: PUSH
6142: LD_INT 2
6144: PUSH
6145: LD_INT 28
6147: PUSH
6148: LD_INT 29
6150: PUSH
6151: LD_INT 25
6153: PUSH
6154: LD_INT 26
6156: PUSH
6157: EMPTY
6158: LIST
6159: LIST
6160: LIST
6161: LIST
6162: PUSH
6163: LD_INT 1
6165: PPUSH
6166: LD_INT 4
6168: PPUSH
6169: CALL_OW 12
6173: ARRAY
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: PPUSH
6181: CALL_OW 2
6185: ST_TO_ADDR
6186: GO 6114
6188: POP
6189: POP
// MC_InsertProduceList ( base , tmp ) ;
6190: LD_VAR 0 3
6194: PPUSH
6195: LD_VAR 0 4
6199: PPUSH
6200: CALL 81707 0 2
// wait ( 4 4$20 ) ;
6204: LD_INT 9100
6206: PPUSH
6207: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6211: LD_ADDR_VAR 0 6
6215: PUSH
6216: LD_INT 124
6218: PUSH
6219: LD_INT 85
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: PUSH
6226: LD_INT 90
6228: PUSH
6229: LD_INT 61
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: PUSH
6236: LD_INT 69
6238: PUSH
6239: LD_INT 48
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 68
6248: PUSH
6249: LD_INT 48
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6262: LD_ADDR_VAR 0 7
6266: PUSH
6267: LD_EXP 80
6271: PUSH
6272: LD_VAR 0 3
6276: ARRAY
6277: PUSH
6278: LD_EXP 80
6282: PUSH
6283: LD_VAR 0 3
6287: ARRAY
6288: PPUSH
6289: LD_INT 2
6291: PUSH
6292: LD_INT 34
6294: PUSH
6295: LD_INT 32
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: PUSH
6302: LD_INT 34
6304: PUSH
6305: LD_INT 88
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: LIST
6316: PPUSH
6317: CALL_OW 72
6321: DIFF
6322: ST_TO_ADDR
// if rand ( 0 , 1 ) then
6323: LD_INT 0
6325: PPUSH
6326: LD_INT 1
6328: PPUSH
6329: CALL_OW 12
6333: IFFALSE 6483
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
6335: LD_ADDR_VAR 0 1
6339: PUSH
6340: DOUBLE
6341: LD_INT 1
6343: DEC
6344: ST_TO_ADDR
6345: LD_INT 3
6347: PUSH
6348: LD_INT 4
6350: PUSH
6351: LD_INT 5
6353: PUSH
6354: LD_INT 6
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PUSH
6363: LD_OWVAR 67
6367: ARRAY
6368: PUSH
6369: FOR_TO
6370: IFFALSE 6479
// begin uc_side := 2 ;
6372: LD_ADDR_OWVAR 20
6376: PUSH
6377: LD_INT 2
6379: ST_TO_ADDR
// uc_nation := 2 ;
6380: LD_ADDR_OWVAR 21
6384: PUSH
6385: LD_INT 2
6387: ST_TO_ADDR
// InitHc ;
6388: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6392: LD_INT 0
6394: PPUSH
6395: LD_INT 15
6397: PUSH
6398: LD_INT 17
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: PUSH
6405: LD_INT 1
6407: PPUSH
6408: LD_INT 2
6410: PPUSH
6411: CALL_OW 12
6415: ARRAY
6416: PPUSH
6417: LD_INT 8
6419: PPUSH
6420: CALL_OW 380
// un := CreateHuman ;
6424: LD_ADDR_VAR 0 2
6428: PUSH
6429: CALL_OW 44
6433: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6434: LD_VAR 0 2
6438: PPUSH
6439: LD_INT 4
6441: PPUSH
6442: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6446: LD_VAR 0 2
6450: PPUSH
6451: LD_INT 23
6453: PPUSH
6454: LD_INT 0
6456: PPUSH
6457: CALL_OW 49
// attackers := attackers union un ;
6461: LD_ADDR_VAR 0 7
6465: PUSH
6466: LD_VAR 0 7
6470: PUSH
6471: LD_VAR 0 2
6475: UNION
6476: ST_TO_ADDR
// end ;
6477: GO 6369
6479: POP
6480: POP
// end else
6481: GO 6641
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6483: LD_ADDR_VAR 0 1
6487: PUSH
6488: DOUBLE
6489: LD_INT 1
6491: DEC
6492: ST_TO_ADDR
6493: LD_INT 2
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 4
6501: PUSH
6502: LD_INT 5
6504: PUSH
6505: EMPTY
6506: LIST
6507: LIST
6508: LIST
6509: LIST
6510: PUSH
6511: LD_OWVAR 67
6515: ARRAY
6516: PUSH
6517: FOR_TO
6518: IFFALSE 6639
// begin uc_side := 2 ;
6520: LD_ADDR_OWVAR 20
6524: PUSH
6525: LD_INT 2
6527: ST_TO_ADDR
// uc_nation := 2 ;
6528: LD_ADDR_OWVAR 21
6532: PUSH
6533: LD_INT 2
6535: ST_TO_ADDR
// InitHc ;
6536: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
6540: LD_INT 14
6542: PPUSH
6543: LD_INT 3
6545: PPUSH
6546: LD_INT 5
6548: PPUSH
6549: LD_INT 29
6551: PUSH
6552: LD_INT 29
6554: PUSH
6555: LD_INT 26
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: LIST
6562: PUSH
6563: LD_VAR 0 1
6567: PUSH
6568: LD_INT 3
6570: MOD
6571: PUSH
6572: LD_INT 1
6574: PLUS
6575: ARRAY
6576: PPUSH
6577: LD_INT 100
6579: PPUSH
6580: CALL 20341 0 5
// un := CreateVehicle ;
6584: LD_ADDR_VAR 0 2
6588: PUSH
6589: CALL_OW 45
6593: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6594: LD_VAR 0 2
6598: PPUSH
6599: LD_INT 4
6601: PPUSH
6602: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 23
6613: PPUSH
6614: LD_INT 0
6616: PPUSH
6617: CALL_OW 49
// attackers := attackers union un ;
6621: LD_ADDR_VAR 0 7
6625: PUSH
6626: LD_VAR 0 7
6630: PUSH
6631: LD_VAR 0 2
6635: UNION
6636: ST_TO_ADDR
// end ;
6637: GO 6517
6639: POP
6640: POP
// end ; if not attackers then
6641: LD_VAR 0 7
6645: NOT
6646: IFFALSE 6650
// exit ;
6648: GO 6742
// ar_attackers := attackers ;
6650: LD_ADDR_EXP 11
6654: PUSH
6655: LD_VAR 0 7
6659: ST_TO_ADDR
// p := 0 ;
6660: LD_ADDR_VAR 0 8
6664: PUSH
6665: LD_INT 0
6667: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6668: LD_INT 35
6670: PPUSH
6671: CALL_OW 67
// p := Inc ( p ) ;
6675: LD_ADDR_VAR 0 8
6679: PUSH
6680: LD_VAR 0 8
6684: PPUSH
6685: CALL 54564 0 1
6689: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
6690: LD_VAR 0 7
6694: PPUSH
6695: LD_INT 60
6697: PUSH
6698: EMPTY
6699: LIST
6700: PPUSH
6701: CALL_OW 72
6705: NOT
6706: PUSH
6707: LD_VAR 0 8
6711: PUSH
6712: LD_INT 30
6714: GREATER
6715: OR
6716: IFFALSE 6668
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6718: LD_VAR 0 3
6722: PPUSH
6723: LD_VAR 0 7
6727: PPUSH
6728: LD_VAR 0 6
6732: PPUSH
6733: LD_VAR 0 5
6737: PPUSH
6738: CALL 81892 0 4
// end ;
6742: PPOPN 8
6744: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
6745: LD_INT 1
6747: PPUSH
6748: CALL_OW 302
6752: PUSH
6753: LD_EXP 9
6757: AND
6758: PUSH
6759: LD_EXP 51
6763: PPUSH
6764: LD_INT 22
6766: PPUSH
6767: CALL_OW 308
6771: AND
6772: IFFALSE 7260
6774: GO 6776
6776: DISABLE
6777: LD_INT 0
6779: PPUSH
6780: PPUSH
6781: PPUSH
6782: PPUSH
6783: PPUSH
6784: PPUSH
6785: PPUSH
6786: PPUSH
// begin base := 1 ;
6787: LD_ADDR_VAR 0 2
6791: PUSH
6792: LD_INT 1
6794: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6795: LD_ADDR_VAR 0 4
6799: PUSH
6800: LD_INT 0
6802: PUSH
6803: LD_INT 0
6805: PUSH
6806: LD_INT 0
6808: PUSH
6809: LD_INT 0
6811: PUSH
6812: LD_INT 0
6814: PUSH
6815: LD_INT 0
6817: PUSH
6818: LD_INT 0
6820: PUSH
6821: LD_INT 0
6823: PUSH
6824: LD_INT 1
6826: PUSH
6827: LD_INT 0
6829: PUSH
6830: EMPTY
6831: LIST
6832: LIST
6833: LIST
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: LIST
6840: LIST
6841: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6842: LD_ADDR_VAR 0 3
6846: PUSH
6847: LD_INT 13
6849: PUSH
6850: LD_INT 1
6852: PUSH
6853: LD_INT 2
6855: PUSH
6856: LD_INT 28
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: LIST
6863: LIST
6864: PUSH
6865: LD_INT 13
6867: PUSH
6868: LD_INT 1
6870: PUSH
6871: LD_INT 2
6873: PUSH
6874: LD_INT 27
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: LIST
6881: LIST
6882: PUSH
6883: LD_INT 13
6885: PUSH
6886: LD_INT 1
6888: PUSH
6889: LD_INT 2
6891: PUSH
6892: LD_INT 25
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 11
6903: PUSH
6904: LD_INT 2
6906: PUSH
6907: LD_INT 2
6909: PUSH
6910: LD_INT 24
6912: PUSH
6913: EMPTY
6914: LIST
6915: LIST
6916: LIST
6917: LIST
6918: PUSH
6919: LD_INT 11
6921: PUSH
6922: LD_INT 2
6924: PUSH
6925: LD_INT 2
6927: PUSH
6928: LD_INT 24
6930: PUSH
6931: EMPTY
6932: LIST
6933: LIST
6934: LIST
6935: LIST
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: LIST
6941: LIST
6942: LIST
6943: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6944: LD_VAR 0 2
6948: PPUSH
6949: LD_VAR 0 3
6953: PPUSH
6954: CALL 81707 0 2
// wait ( 4 4$20 ) ;
6958: LD_INT 9100
6960: PPUSH
6961: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6965: LD_ADDR_VAR 0 5
6969: PUSH
6970: LD_INT 119
6972: PUSH
6973: LD_INT 9
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6983: LD_ADDR_VAR 0 6
6987: PUSH
6988: LD_EXP 80
6992: PUSH
6993: LD_VAR 0 2
6997: ARRAY
6998: PUSH
6999: LD_EXP 80
7003: PUSH
7004: LD_VAR 0 2
7008: ARRAY
7009: PPUSH
7010: LD_INT 2
7012: PUSH
7013: LD_INT 34
7015: PUSH
7016: LD_INT 32
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: PUSH
7023: LD_INT 34
7025: PUSH
7026: LD_INT 88
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: LIST
7037: PPUSH
7038: CALL_OW 72
7042: DIFF
7043: ST_TO_ADDR
// uc_side := 2 ;
7044: LD_ADDR_OWVAR 20
7048: PUSH
7049: LD_INT 2
7051: ST_TO_ADDR
// uc_nation := 2 ;
7052: LD_ADDR_OWVAR 21
7056: PUSH
7057: LD_INT 2
7059: ST_TO_ADDR
// InitHc ;
7060: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7064: LD_ADDR_VAR 0 1
7068: PUSH
7069: DOUBLE
7070: LD_INT 1
7072: DEC
7073: ST_TO_ADDR
7074: LD_INT 4
7076: PUSH
7077: LD_INT 5
7079: PUSH
7080: LD_INT 6
7082: PUSH
7083: LD_INT 6
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: LD_OWVAR 67
7096: ARRAY
7097: PUSH
7098: FOR_TO
7099: IFFALSE 7176
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7101: LD_INT 0
7103: PPUSH
7104: LD_INT 15
7106: PUSH
7107: LD_INT 17
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: PUSH
7114: LD_INT 1
7116: PPUSH
7117: LD_INT 2
7119: PPUSH
7120: CALL_OW 12
7124: ARRAY
7125: PPUSH
7126: LD_INT 8
7128: PPUSH
7129: CALL_OW 380
// un := CreateHuman ;
7133: LD_ADDR_VAR 0 7
7137: PUSH
7138: CALL_OW 44
7142: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7143: LD_VAR 0 7
7147: PPUSH
7148: LD_INT 23
7150: PPUSH
7151: LD_INT 0
7153: PPUSH
7154: CALL_OW 49
// attackers := attackers union un ;
7158: LD_ADDR_VAR 0 6
7162: PUSH
7163: LD_VAR 0 6
7167: PUSH
7168: LD_VAR 0 7
7172: UNION
7173: ST_TO_ADDR
// end ;
7174: GO 7098
7176: POP
7177: POP
// p := 0 ;
7178: LD_ADDR_VAR 0 8
7182: PUSH
7183: LD_INT 0
7185: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7186: LD_INT 35
7188: PPUSH
7189: CALL_OW 67
// p := Inc ( p ) ;
7193: LD_ADDR_VAR 0 8
7197: PUSH
7198: LD_VAR 0 8
7202: PPUSH
7203: CALL 54564 0 1
7207: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7208: LD_VAR 0 6
7212: PPUSH
7213: LD_INT 60
7215: PUSH
7216: EMPTY
7217: LIST
7218: PPUSH
7219: CALL_OW 72
7223: NOT
7224: PUSH
7225: LD_VAR 0 8
7229: PUSH
7230: LD_INT 30
7232: GREATER
7233: OR
7234: IFFALSE 7186
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7236: LD_VAR 0 2
7240: PPUSH
7241: LD_VAR 0 6
7245: PPUSH
7246: LD_VAR 0 5
7250: PPUSH
7251: LD_VAR 0 4
7255: PPUSH
7256: CALL 81892 0 4
// end ; end_of_file
7260: PPOPN 8
7262: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
7263: LD_INT 0
7265: PPUSH
7266: PPUSH
7267: PPUSH
7268: PPUSH
7269: PPUSH
7270: PPUSH
// uc_side := 1 ;
7271: LD_ADDR_OWVAR 20
7275: PUSH
7276: LD_INT 1
7278: ST_TO_ADDR
// uc_nation := 1 ;
7279: LD_ADDR_OWVAR 21
7283: PUSH
7284: LD_INT 1
7286: ST_TO_ADDR
// InitHc ;
7287: CALL_OW 19
// InitVc ;
7291: CALL_OW 20
// tmp := [ ] ;
7295: LD_ADDR_VAR 0 3
7299: PUSH
7300: EMPTY
7301: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
7302: LD_ADDR_VAR 0 2
7306: PUSH
7307: DOUBLE
7308: LD_INT 1
7310: DEC
7311: ST_TO_ADDR
7312: LD_INT 6
7314: PUSH
7315: LD_INT 8
7317: PUSH
7318: LD_INT 10
7320: PUSH
7321: LD_INT 10
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: LIST
7328: LIST
7329: PUSH
7330: LD_OWVAR 67
7334: ARRAY
7335: PUSH
7336: FOR_TO
7337: IFFALSE 7611
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
7339: LD_ADDR_VAR 0 5
7343: PUSH
7344: LD_INT 2
7346: PUSH
7347: LD_INT 4
7349: PUSH
7350: LD_INT 5
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 3
7363: PPUSH
7364: CALL_OW 12
7368: ARRAY
7369: ST_TO_ADDR
// case chassis of us_medium_wheeled :
7370: LD_VAR 0 5
7374: PUSH
7375: LD_INT 2
7377: DOUBLE
7378: EQUAL
7379: IFTRUE 7383
7381: GO 7417
7383: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7384: LD_ADDR_VAR 0 6
7388: PUSH
7389: LD_INT 9
7391: PUSH
7392: LD_INT 5
7394: PUSH
7395: LD_INT 7
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: LIST
7402: PUSH
7403: LD_INT 1
7405: PPUSH
7406: LD_INT 3
7408: PPUSH
7409: CALL_OW 12
7413: ARRAY
7414: ST_TO_ADDR
7415: GO 7506
7417: LD_INT 4
7419: DOUBLE
7420: EQUAL
7421: IFTRUE 7425
7423: GO 7463
7425: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: LD_INT 9
7433: PUSH
7434: LD_INT 6
7436: PUSH
7437: LD_INT 6
7439: PUSH
7440: LD_INT 7
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: LIST
7447: LIST
7448: PUSH
7449: LD_INT 1
7451: PPUSH
7452: LD_INT 4
7454: PPUSH
7455: CALL_OW 12
7459: ARRAY
7460: ST_TO_ADDR
7461: GO 7506
7463: LD_INT 5
7465: DOUBLE
7466: EQUAL
7467: IFTRUE 7471
7469: GO 7505
7471: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7472: LD_ADDR_VAR 0 6
7476: PUSH
7477: LD_INT 9
7479: PUSH
7480: LD_INT 6
7482: PUSH
7483: LD_INT 7
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 1
7493: PPUSH
7494: LD_INT 3
7496: PPUSH
7497: CALL_OW 12
7501: ARRAY
7502: ST_TO_ADDR
7503: GO 7506
7505: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7506: LD_VAR 0 5
7510: PPUSH
7511: LD_INT 1
7513: PUSH
7514: LD_INT 3
7516: PUSH
7517: EMPTY
7518: LIST
7519: LIST
7520: PUSH
7521: LD_INT 1
7523: PPUSH
7524: LD_INT 2
7526: PPUSH
7527: CALL_OW 12
7531: ARRAY
7532: PPUSH
7533: LD_INT 3
7535: PPUSH
7536: LD_VAR 0 6
7540: PPUSH
7541: LD_INT 70
7543: PPUSH
7544: LD_INT 90
7546: PPUSH
7547: CALL_OW 12
7551: PPUSH
7552: CALL 20341 0 5
// veh := CreateVehicle ;
7556: LD_ADDR_VAR 0 4
7560: PUSH
7561: CALL_OW 45
7565: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7566: LD_VAR 0 4
7570: PPUSH
7571: LD_INT 2
7573: PPUSH
7574: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7578: LD_VAR 0 4
7582: PPUSH
7583: LD_INT 17
7585: PPUSH
7586: LD_INT 0
7588: PPUSH
7589: CALL_OW 49
// tmp := tmp ^ veh ;
7593: LD_ADDR_VAR 0 3
7597: PUSH
7598: LD_VAR 0 3
7602: PUSH
7603: LD_VAR 0 4
7607: ADD
7608: ST_TO_ADDR
// end ;
7609: GO 7336
7611: POP
7612: POP
// if not tmp then
7613: LD_VAR 0 3
7617: NOT
7618: IFFALSE 7622
// exit ;
7620: GO 7731
// if not first_powell_attack then
7622: LD_EXP 12
7626: NOT
7627: IFFALSE 7637
// first_powell_attack := true ;
7629: LD_ADDR_EXP 12
7633: PUSH
7634: LD_INT 1
7636: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7637: LD_INT 70
7639: PPUSH
7640: CALL_OW 67
// for i in tmp do
7644: LD_ADDR_VAR 0 2
7648: PUSH
7649: LD_VAR 0 3
7653: PUSH
7654: FOR_IN
7655: IFFALSE 7722
// if IsOk ( i ) then
7657: LD_VAR 0 2
7661: PPUSH
7662: CALL_OW 302
7666: IFFALSE 7704
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7668: LD_VAR 0 2
7672: PPUSH
7673: LD_INT 81
7675: PUSH
7676: LD_INT 1
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: PPUSH
7683: CALL_OW 69
7687: PPUSH
7688: LD_VAR 0 2
7692: PPUSH
7693: CALL_OW 74
7697: PPUSH
7698: CALL_OW 115
7702: GO 7720
// tmp := tmp diff i ;
7704: LD_ADDR_VAR 0 3
7708: PUSH
7709: LD_VAR 0 3
7713: PUSH
7714: LD_VAR 0 2
7718: DIFF
7719: ST_TO_ADDR
7720: GO 7654
7722: POP
7723: POP
// until not tmp ;
7724: LD_VAR 0 3
7728: NOT
7729: IFFALSE 7637
// end ; end_of_file
7731: LD_VAR 0 1
7735: RET
// export function Action ; var tmp , i , un ; begin
7736: LD_INT 0
7738: PPUSH
7739: PPUSH
7740: PPUSH
7741: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7742: LD_INT 68
7744: PPUSH
7745: LD_INT 39
7747: PPUSH
7748: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7752: LD_ADDR_VAR 0 2
7756: PUSH
7757: LD_INT 22
7759: PUSH
7760: LD_INT 7
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: PPUSH
7767: CALL_OW 69
7771: ST_TO_ADDR
// InGameOn ;
7772: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_INT 71
7783: PPUSH
7784: LD_INT 49
7786: PPUSH
7787: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7791: LD_INT 35
7793: PPUSH
7794: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7798: LD_INT 7
7800: PPUSH
7801: LD_INT 71
7803: PPUSH
7804: LD_INT 51
7806: PPUSH
7807: CALL_OW 293
7811: IFFALSE 7791
// DialogueOn ;
7813: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7817: LD_EXP 16
7821: PPUSH
7822: LD_STRING D1-JMM-1
7824: PPUSH
7825: CALL_OW 88
// if Joan then
7829: LD_EXP 31
7833: IFFALSE 7847
// Say ( Joan , D1-Joan-1 ) ;
7835: LD_EXP 31
7839: PPUSH
7840: LD_STRING D1-Joan-1
7842: PPUSH
7843: CALL_OW 88
// if Lisa then
7847: LD_EXP 18
7851: IFFALSE 7865
// Say ( Lisa , D1-Lisa-1 ) ;
7853: LD_EXP 18
7857: PPUSH
7858: LD_STRING D1-Lisa-1
7860: PPUSH
7861: CALL_OW 88
// if Joan or Lisa then
7865: LD_EXP 31
7869: PUSH
7870: LD_EXP 18
7874: OR
7875: IFFALSE 7889
// Say ( JMM , D1-JMM-2 ) ;
7877: LD_EXP 16
7881: PPUSH
7882: LD_STRING D1-JMM-2
7884: PPUSH
7885: CALL_OW 88
// DialogueOff ;
7889: CALL_OW 7
// InGameOff ;
7893: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7897: LD_INT 71
7899: PPUSH
7900: LD_INT 50
7902: PPUSH
7903: LD_INT 7
7905: PPUSH
7906: LD_INT 30
7908: NEG
7909: PPUSH
7910: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7914: LD_INT 71
7916: PPUSH
7917: LD_INT 50
7919: PPUSH
7920: LD_INT 7
7922: PPUSH
7923: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7927: LD_STRING M1
7929: PPUSH
7930: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7934: LD_INT 35
7936: PPUSH
7937: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7941: LD_EXP 3
7945: PUSH
7946: LD_OWVAR 1
7950: PUSH
7951: LD_INT 2100
7953: GREATER
7954: OR
7955: IFFALSE 7934
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7957: LD_INT 350
7959: PPUSH
7960: LD_INT 700
7962: PPUSH
7963: CALL_OW 12
7967: PPUSH
7968: CALL_OW 67
// PrepareGossudarov ;
7972: CALL 1935 0 0
// repeat wait ( 0 0$1 ) ;
7976: LD_INT 35
7978: PPUSH
7979: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7983: LD_INT 22
7985: PUSH
7986: LD_INT 6
7988: PUSH
7989: EMPTY
7990: LIST
7991: LIST
7992: PUSH
7993: LD_INT 3
7995: PUSH
7996: LD_INT 24
7998: PUSH
7999: LD_INT 1000
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: PUSH
8010: EMPTY
8011: LIST
8012: LIST
8013: PPUSH
8014: CALL_OW 69
8018: PUSH
8019: LD_INT 7
8021: PPUSH
8022: LD_EXP 34
8026: PPUSH
8027: CALL_OW 292
8031: OR
8032: IFFALSE 7976
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
8034: LD_ADDR_VAR 0 2
8038: PUSH
8039: LD_INT 22
8041: PUSH
8042: LD_INT 6
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PPUSH
8049: CALL_OW 69
8053: ST_TO_ADDR
// for i in tmp do
8054: LD_ADDR_VAR 0 3
8058: PUSH
8059: LD_VAR 0 2
8063: PUSH
8064: FOR_IN
8065: IFFALSE 8081
// SetSide ( i , 7 ) ;
8067: LD_VAR 0 3
8071: PPUSH
8072: LD_INT 7
8074: PPUSH
8075: CALL_OW 235
8079: GO 8064
8081: POP
8082: POP
// DialogueOn ;
8083: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
8087: LD_EXP 16
8091: PUSH
8092: LD_EXP 17
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: LD_EXP 34
8105: PPUSH
8106: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
8110: LD_EXP 34
8114: PPUSH
8115: CALL_OW 87
// if not Roth then
8119: LD_EXP 17
8123: NOT
8124: IFFALSE 8216
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8126: LD_VAR 0 2
8130: PPUSH
8131: LD_INT 3
8133: PUSH
8134: LD_INT 24
8136: PUSH
8137: LD_INT 1000
8139: PUSH
8140: EMPTY
8141: LIST
8142: LIST
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PPUSH
8148: CALL_OW 72
8152: IFFALSE 8166
// Say ( JMM , D2-JMM-1 ) ;
8154: LD_EXP 16
8158: PPUSH
8159: LD_STRING D2-JMM-1
8161: PPUSH
8162: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
8166: LD_EXP 16
8170: PPUSH
8171: LD_STRING D2-JMM-1b
8173: PPUSH
8174: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
8178: LD_EXP 34
8182: PPUSH
8183: LD_STRING D2-Gos-1
8185: PPUSH
8186: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
8190: LD_EXP 16
8194: PPUSH
8195: LD_STRING D2-JMM-2
8197: PPUSH
8198: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
8202: LD_EXP 34
8206: PPUSH
8207: LD_STRING D2-Gos-2
8209: PPUSH
8210: CALL_OW 88
// end else
8214: GO 8368
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8216: LD_VAR 0 2
8220: PPUSH
8221: LD_INT 3
8223: PUSH
8224: LD_INT 24
8226: PUSH
8227: LD_INT 1000
8229: PUSH
8230: EMPTY
8231: LIST
8232: LIST
8233: PUSH
8234: EMPTY
8235: LIST
8236: LIST
8237: PPUSH
8238: CALL_OW 72
8242: IFFALSE 8268
// begin Say ( Roth , D2-Roth-2 ) ;
8244: LD_EXP 17
8248: PPUSH
8249: LD_STRING D2-Roth-2
8251: PPUSH
8252: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
8256: LD_EXP 16
8260: PPUSH
8261: LD_STRING D2-JMM-1a
8263: PPUSH
8264: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
8268: LD_EXP 17
8272: PPUSH
8273: LD_STRING D2-Roth-2a
8275: PPUSH
8276: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
8280: LD_EXP 17
8284: PPUSH
8285: LD_STRING D2-Roth-2b
8287: PPUSH
8288: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
8292: LD_EXP 16
8296: PPUSH
8297: LD_STRING D2-JMM-3
8299: PPUSH
8300: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8304: LD_VAR 0 2
8308: PPUSH
8309: LD_INT 3
8311: PUSH
8312: LD_INT 24
8314: PUSH
8315: LD_INT 1000
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PUSH
8322: EMPTY
8323: LIST
8324: LIST
8325: PPUSH
8326: CALL_OW 72
8330: IFFALSE 8368
// begin Say ( Gossudarov , D2-Gos-3 ) ;
8332: LD_EXP 34
8336: PPUSH
8337: LD_STRING D2-Gos-3
8339: PPUSH
8340: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
8344: LD_EXP 16
8348: PPUSH
8349: LD_STRING D2-JMM-4
8351: PPUSH
8352: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
8356: LD_EXP 34
8360: PPUSH
8361: LD_STRING D2-Gos-4
8363: PPUSH
8364: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
8368: LD_EXP 16
8372: PPUSH
8373: LD_STRING D2-JMM-5
8375: PPUSH
8376: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
8380: LD_EXP 34
8384: PPUSH
8385: LD_STRING D2-Gos-5
8387: PPUSH
8388: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
8392: LD_EXP 16
8396: PPUSH
8397: LD_STRING D2-JMM-6
8399: PPUSH
8400: CALL_OW 88
// DialogueOff ;
8404: CALL_OW 7
// wait ( 0 0$2 ) ;
8408: LD_INT 70
8410: PPUSH
8411: CALL_OW 67
// if Kirilenkova then
8415: LD_EXP 35
8419: IFFALSE 8433
// Say ( Kirilenkova , D3-Kir-1 ) ;
8421: LD_EXP 35
8425: PPUSH
8426: LD_STRING D3-Kir-1
8428: PPUSH
8429: CALL_OW 88
// gossudarov_arrive := true ;
8433: LD_ADDR_EXP 4
8437: PUSH
8438: LD_INT 1
8440: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8441: LD_INT 35
8443: PPUSH
8444: CALL_OW 67
// until ru_lab_builded ;
8448: LD_EXP 5
8452: IFFALSE 8441
// DialogueOn ;
8454: CALL_OW 6
// if Kirilenkova then
8458: LD_EXP 35
8462: IFFALSE 8478
// Say ( Kirilenkova , D3a-Kir-1 ) else
8464: LD_EXP 35
8468: PPUSH
8469: LD_STRING D3a-Kir-1
8471: PPUSH
8472: CALL_OW 88
8476: GO 8500
// begin un := SciRu ;
8478: LD_ADDR_VAR 0 4
8482: PUSH
8483: CALL 13885 0 0
8487: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8488: LD_VAR 0 4
8492: PPUSH
8493: LD_STRING D3a-Sci1-1
8495: PPUSH
8496: CALL_OW 88
// end ; if Kirilenkova or un then
8500: LD_EXP 35
8504: PUSH
8505: LD_VAR 0 4
8509: OR
8510: IFFALSE 8524
// Say ( JMM , D3a-JMM-1 ) ;
8512: LD_EXP 16
8516: PPUSH
8517: LD_STRING D3a-JMM-1
8519: PPUSH
8520: CALL_OW 88
// DialogueOff ;
8524: CALL_OW 7
// end ;
8528: LD_VAR 0 1
8532: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8533: LD_EXP 4
8537: PUSH
8538: LD_INT 22
8540: PUSH
8541: LD_INT 7
8543: PUSH
8544: EMPTY
8545: LIST
8546: LIST
8547: PUSH
8548: LD_INT 2
8550: PUSH
8551: LD_INT 25
8553: PUSH
8554: LD_INT 1
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: PUSH
8561: LD_INT 25
8563: PUSH
8564: LD_INT 2
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: PUSH
8571: LD_INT 25
8573: PUSH
8574: LD_INT 3
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: PUSH
8581: LD_INT 25
8583: PUSH
8584: LD_INT 4
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: PUSH
8591: LD_INT 25
8593: PUSH
8594: LD_INT 5
8596: PUSH
8597: EMPTY
8598: LIST
8599: LIST
8600: PUSH
8601: LD_INT 25
8603: PUSH
8604: LD_INT 8
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PUSH
8611: LD_INT 25
8613: PUSH
8614: LD_INT 9
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: LIST
8625: LIST
8626: LIST
8627: LIST
8628: LIST
8629: LIST
8630: PUSH
8631: EMPTY
8632: LIST
8633: LIST
8634: PPUSH
8635: CALL_OW 69
8639: PUSH
8640: LD_INT 7
8642: LESS
8643: AND
8644: IFFALSE 8656
8646: GO 8648
8648: DISABLE
// YouLost ( TooMany ) ;
8649: LD_STRING TooMany
8651: PPUSH
8652: CALL_OW 104
8656: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8657: LD_EXP 34
8661: PPUSH
8662: CALL_OW 255
8666: PUSH
8667: LD_INT 7
8669: EQUAL
8670: IFFALSE 8887
8672: GO 8674
8674: DISABLE
8675: LD_INT 0
8677: PPUSH
8678: PPUSH
8679: PPUSH
// begin uc_side := 3 ;
8680: LD_ADDR_OWVAR 20
8684: PUSH
8685: LD_INT 3
8687: ST_TO_ADDR
// uc_nation := 3 ;
8688: LD_ADDR_OWVAR 21
8692: PUSH
8693: LD_INT 3
8695: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8696: LD_INT 21
8698: PPUSH
8699: LD_INT 3
8701: PPUSH
8702: LD_INT 3
8704: PPUSH
8705: LD_INT 42
8707: PPUSH
8708: LD_INT 100
8710: PPUSH
8711: CALL 20341 0 5
// un := CreateVehicle ;
8715: LD_ADDR_VAR 0 3
8719: PUSH
8720: CALL_OW 45
8724: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8725: LD_VAR 0 3
8729: PPUSH
8730: LD_INT 15
8732: PPUSH
8733: LD_INT 0
8735: PPUSH
8736: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8740: LD_VAR 0 3
8744: PPUSH
8745: LD_INT 67
8747: PPUSH
8748: LD_INT 45
8750: PPUSH
8751: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8755: LD_VAR 0 3
8759: PPUSH
8760: LD_INT 70
8762: PPUSH
8763: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8767: LD_VAR 0 3
8771: PPUSH
8772: LD_INT 69
8774: PPUSH
8775: LD_INT 18
8777: PPUSH
8778: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8782: LD_VAR 0 3
8786: PPUSH
8787: LD_INT 60
8789: PPUSH
8790: LD_INT 3
8792: PPUSH
8793: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8797: LD_INT 35
8799: PPUSH
8800: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8804: LD_VAR 0 3
8808: PPUSH
8809: CALL_OW 302
8813: NOT
8814: PUSH
8815: LD_VAR 0 3
8819: PPUSH
8820: LD_INT 17
8822: PPUSH
8823: CALL_OW 308
8827: OR
8828: PUSH
8829: LD_VAR 0 3
8833: PPUSH
8834: LD_INT 60
8836: PPUSH
8837: LD_INT 3
8839: PPUSH
8840: CALL_OW 307
8844: OR
8845: IFFALSE 8797
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8847: LD_VAR 0 3
8851: PPUSH
8852: LD_INT 17
8854: PPUSH
8855: CALL_OW 308
8859: PUSH
8860: LD_VAR 0 3
8864: PPUSH
8865: LD_INT 60
8867: PPUSH
8868: LD_INT 3
8870: PPUSH
8871: CALL_OW 307
8875: OR
8876: IFFALSE 8887
// RemoveUnit ( un ) ;
8878: LD_VAR 0 3
8882: PPUSH
8883: CALL_OW 64
// end ;
8887: PPOPN 3
8889: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8890: LD_EXP 4
8894: IFFALSE 9136
8896: GO 8898
8898: DISABLE
8899: LD_INT 0
8901: PPUSH
8902: PPUSH
8903: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8904: LD_INT 70
8906: PPUSH
8907: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8911: LD_ADDR_VAR 0 3
8915: PUSH
8916: LD_INT 22
8918: PUSH
8919: LD_INT 7
8921: PUSH
8922: EMPTY
8923: LIST
8924: LIST
8925: PUSH
8926: LD_INT 101
8928: PUSH
8929: LD_INT 3
8931: PUSH
8932: EMPTY
8933: LIST
8934: LIST
8935: PUSH
8936: EMPTY
8937: LIST
8938: LIST
8939: PPUSH
8940: CALL_OW 69
8944: ST_TO_ADDR
// until tmp ;
8945: LD_VAR 0 3
8949: IFFALSE 8904
// un := NearestUnitToUnit ( tmp , JMM ) ;
8951: LD_ADDR_VAR 0 2
8955: PUSH
8956: LD_VAR 0 3
8960: PPUSH
8961: LD_EXP 16
8965: PPUSH
8966: CALL_OW 74
8970: ST_TO_ADDR
// player_spotted := true ;
8971: LD_ADDR_EXP 6
8975: PUSH
8976: LD_INT 1
8978: ST_TO_ADDR
// tmp := SciRu ;
8979: LD_ADDR_VAR 0 3
8983: PUSH
8984: CALL 13885 0 0
8988: ST_TO_ADDR
// if not tmp then
8989: LD_VAR 0 3
8993: NOT
8994: IFFALSE 9006
// tmp := SolRu ;
8996: LD_ADDR_VAR 0 3
9000: PUSH
9001: CALL 14032 0 0
9005: ST_TO_ADDR
// DialogueOn ;
9006: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
9010: LD_VAR 0 2
9014: PPUSH
9015: CALL_OW 250
9019: PPUSH
9020: LD_VAR 0 2
9024: PPUSH
9025: CALL_OW 251
9029: PPUSH
9030: LD_INT 7
9032: PPUSH
9033: LD_INT 8
9035: NEG
9036: PPUSH
9037: CALL_OW 330
// CenterNowOnUnits ( un ) ;
9041: LD_VAR 0 2
9045: PPUSH
9046: CALL_OW 87
// if tmp then
9050: LD_VAR 0 3
9054: IFFALSE 9068
// Say ( tmp , D4-RSci1-1 ) ;
9056: LD_VAR 0 3
9060: PPUSH
9061: LD_STRING D4-RSci1-1
9063: PPUSH
9064: CALL_OW 88
// if Gossudarov then
9068: LD_EXP 34
9072: IFFALSE 9098
// begin Say ( Gossudarov , D4-Gos-1 ) ;
9074: LD_EXP 34
9078: PPUSH
9079: LD_STRING D4-Gos-1
9081: PPUSH
9082: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
9086: LD_EXP 16
9090: PPUSH
9091: LD_STRING D4-JMM-1
9093: PPUSH
9094: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
9098: LD_VAR 0 2
9102: PPUSH
9103: CALL_OW 250
9107: PPUSH
9108: LD_VAR 0 2
9112: PPUSH
9113: CALL_OW 251
9117: PPUSH
9118: LD_INT 7
9120: PPUSH
9121: CALL_OW 331
// DialogueOff ;
9125: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
9129: LD_STRING M5
9131: PPUSH
9132: CALL_OW 337
// end ;
9136: PPOPN 3
9138: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
9139: LD_EXP 6
9143: IFFALSE 9736
9145: GO 9147
9147: DISABLE
9148: LD_INT 0
9150: PPUSH
9151: PPUSH
9152: PPUSH
// begin PrepareBelkov ;
9153: CALL 2248 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
9157: LD_EXP 49
9161: PPUSH
9162: LD_INT 118
9164: PPUSH
9165: LD_INT 106
9167: PPUSH
9168: CALL_OW 111
// AddComHold ( Belkov ) ;
9172: LD_EXP 49
9176: PPUSH
9177: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
9181: LD_INT 35
9183: PPUSH
9184: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
9188: LD_EXP 49
9192: PPUSH
9193: LD_INT 118
9195: PPUSH
9196: LD_INT 106
9198: PPUSH
9199: CALL_OW 307
9203: IFFALSE 9181
// ChangeSideFog ( 4 , 7 ) ;
9205: LD_INT 4
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: CALL_OW 343
// if IsOk ( Belkov ) then
9215: LD_EXP 49
9219: PPUSH
9220: CALL_OW 302
9224: IFFALSE 9308
// begin InGameOn ;
9226: CALL_OW 8
// DialogueOn ;
9230: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
9234: LD_EXP 49
9238: PPUSH
9239: LD_STRING D5-Bel-1
9241: PPUSH
9242: CALL_OW 94
// if Gossudarov then
9246: LD_EXP 34
9250: IFFALSE 9300
// begin Say ( Gossudarov , D5-Gos-1 ) ;
9252: LD_EXP 34
9256: PPUSH
9257: LD_STRING D5-Gos-1
9259: PPUSH
9260: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
9264: LD_EXP 16
9268: PPUSH
9269: LD_STRING D5-JMM-1
9271: PPUSH
9272: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
9276: LD_EXP 34
9280: PPUSH
9281: LD_STRING D5-Gos-2
9283: PPUSH
9284: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
9288: LD_EXP 16
9292: PPUSH
9293: LD_STRING D5-JMM-2
9295: PPUSH
9296: CALL_OW 88
// end ; DialogueOff ;
9300: CALL_OW 7
// InGameOff ;
9304: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
9308: LD_STRING QSaveBelkov
9310: PPUSH
9311: CALL_OW 97
9315: PUSH
9316: LD_INT 1
9318: DOUBLE
9319: EQUAL
9320: IFTRUE 9324
9322: GO 9374
9324: POP
// begin DialogueOn ;
9325: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
9329: LD_EXP 16
9333: PPUSH
9334: LD_STRING D5a-JMM-1
9336: PPUSH
9337: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
9341: LD_EXP 49
9345: PPUSH
9346: LD_STRING D5a-Bel-1
9348: PPUSH
9349: CALL_OW 94
// DialogueOff ;
9353: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
9357: LD_EXP 49
9361: PPUSH
9362: LD_INT 83
9364: PPUSH
9365: LD_INT 49
9367: PPUSH
9368: CALL_OW 111
// end ; 2 :
9372: GO 9407
9374: LD_INT 2
9376: DOUBLE
9377: EQUAL
9378: IFTRUE 9382
9380: GO 9406
9382: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
9383: LD_EXP 16
9387: PPUSH
9388: LD_STRING D5a-JMM-2
9390: PPUSH
9391: CALL_OW 88
// ComHold ( Belkov ) ;
9395: LD_EXP 49
9399: PPUSH
9400: CALL_OW 140
// end ; end ;
9404: GO 9407
9406: POP
// time := 0 0$00 ;
9407: LD_ADDR_VAR 0 1
9411: PUSH
9412: LD_INT 0
9414: ST_TO_ADDR
// vehSpawned := false ;
9415: LD_ADDR_VAR 0 3
9419: PUSH
9420: LD_INT 0
9422: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9423: LD_INT 35
9425: PPUSH
9426: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9430: LD_VAR 0 1
9434: PUSH
9435: LD_INT 350
9437: PUSH
9438: LD_INT 175
9440: PUSH
9441: LD_INT 105
9443: PUSH
9444: LD_INT 70
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: PUSH
9453: LD_OWVAR 67
9457: ARRAY
9458: GREATEREQUAL
9459: PUSH
9460: LD_VAR 0 3
9464: NOT
9465: AND
9466: IFFALSE 9556
// begin vehSpawned := true ;
9468: LD_ADDR_VAR 0 3
9472: PUSH
9473: LD_INT 1
9475: ST_TO_ADDR
// uc_side := 3 ;
9476: LD_ADDR_OWVAR 20
9480: PUSH
9481: LD_INT 3
9483: ST_TO_ADDR
// uc_nation := 3 ;
9484: LD_ADDR_OWVAR 21
9488: PUSH
9489: LD_INT 3
9491: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9492: LD_INT 22
9494: PPUSH
9495: LD_INT 3
9497: PPUSH
9498: LD_INT 3
9500: PPUSH
9501: LD_INT 43
9503: PPUSH
9504: LD_INT 100
9506: PPUSH
9507: CALL 20341 0 5
// veh := CreateVehicle ;
9511: LD_ADDR_VAR 0 2
9515: PUSH
9516: CALL_OW 45
9520: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9521: LD_VAR 0 2
9525: PPUSH
9526: LD_INT 130
9528: PPUSH
9529: LD_INT 131
9531: PPUSH
9532: LD_INT 0
9534: PPUSH
9535: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9539: LD_VAR 0 2
9543: PPUSH
9544: LD_INT 100
9546: PPUSH
9547: LD_INT 82
9549: PPUSH
9550: CALL_OW 114
// end else
9554: GO 9570
// time := time + 0 0$1 ;
9556: LD_ADDR_VAR 0 1
9560: PUSH
9561: LD_VAR 0 1
9565: PUSH
9566: LD_INT 35
9568: PLUS
9569: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9570: LD_EXP 49
9574: PPUSH
9575: CALL_OW 301
9579: PUSH
9580: LD_EXP 49
9584: PPUSH
9585: CALL_OW 255
9589: PUSH
9590: LD_INT 4
9592: EQUAL
9593: AND
9594: PUSH
9595: LD_INT 22
9597: PUSH
9598: LD_INT 7
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: PPUSH
9605: CALL_OW 69
9609: PPUSH
9610: LD_EXP 49
9614: PPUSH
9615: CALL_OW 74
9619: PPUSH
9620: LD_EXP 49
9624: PPUSH
9625: CALL_OW 296
9629: PUSH
9630: LD_INT 10
9632: LESS
9633: OR
9634: IFFALSE 9423
// if IsDead ( Belkov ) then
9636: LD_EXP 49
9640: PPUSH
9641: CALL_OW 301
9645: IFFALSE 9670
// begin CenterNowOnUnits ( Belkov ) ;
9647: LD_EXP 49
9651: PPUSH
9652: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9656: LD_EXP 16
9660: PPUSH
9661: LD_STRING D5a-JMM-2a
9663: PPUSH
9664: CALL_OW 88
// exit ;
9668: GO 9736
// end ; if See ( 7 , Belkov ) then
9670: LD_INT 7
9672: PPUSH
9673: LD_EXP 49
9677: PPUSH
9678: CALL_OW 292
9682: IFFALSE 9696
// SetSide ( Belkov , 7 ) ;
9684: LD_EXP 49
9688: PPUSH
9689: LD_INT 7
9691: PPUSH
9692: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9696: LD_INT 35
9698: PPUSH
9699: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9703: LD_EXP 49
9707: PPUSH
9708: LD_INT 66
9710: PPUSH
9711: LD_INT 45
9713: PPUSH
9714: CALL_OW 297
9718: PUSH
9719: LD_INT 30
9721: LESS
9722: IFFALSE 9696
// Say ( Belkov , D6-Bel-1 ) ;
9724: LD_EXP 49
9728: PPUSH
9729: LD_STRING D6-Bel-1
9731: PPUSH
9732: CALL_OW 88
// end ;
9736: PPOPN 3
9738: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9739: LD_EXP 49
9743: PPUSH
9744: CALL_OW 302
9748: PUSH
9749: LD_EXP 49
9753: PPUSH
9754: CALL_OW 504
9758: PUSH
9759: LD_INT 2
9761: PUSH
9762: LD_INT 34
9764: PUSH
9765: LD_INT 47
9767: PUSH
9768: EMPTY
9769: LIST
9770: LIST
9771: PUSH
9772: LD_INT 34
9774: PUSH
9775: LD_INT 45
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: LIST
9786: PPUSH
9787: CALL_OW 69
9791: IN
9792: AND
9793: IFFALSE 9810
9795: GO 9797
9797: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9798: LD_EXP 49
9802: PPUSH
9803: LD_STRING D7-Bel-1
9805: PPUSH
9806: CALL_OW 88
9810: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9811: LD_INT 22
9813: PUSH
9814: LD_INT 7
9816: PUSH
9817: EMPTY
9818: LIST
9819: LIST
9820: PUSH
9821: LD_INT 101
9823: PUSH
9824: LD_INT 2
9826: PUSH
9827: EMPTY
9828: LIST
9829: LIST
9830: PUSH
9831: EMPTY
9832: LIST
9833: LIST
9834: PPUSH
9835: CALL_OW 69
9839: PUSH
9840: LD_EXP 8
9844: NOT
9845: AND
9846: PUSH
9847: LD_EXP 48
9851: PPUSH
9852: CALL_OW 305
9856: NOT
9857: AND
9858: IFFALSE 10328
9860: GO 9862
9862: DISABLE
9863: LD_INT 0
9865: PPUSH
// begin ar_base_spotted := true ;
9866: LD_ADDR_EXP 8
9870: PUSH
9871: LD_INT 1
9873: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9874: LD_ADDR_VAR 0 1
9878: PUSH
9879: LD_INT 22
9881: PUSH
9882: LD_INT 2
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PUSH
9889: LD_INT 21
9891: PUSH
9892: LD_INT 3
9894: PUSH
9895: EMPTY
9896: LIST
9897: LIST
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: PPUSH
9903: CALL_OW 69
9907: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9908: LD_ADDR_VAR 0 1
9912: PUSH
9913: LD_VAR 0 1
9917: PPUSH
9918: LD_EXP 16
9922: PPUSH
9923: CALL_OW 74
9927: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9928: LD_INT 7
9930: PPUSH
9931: LD_INT 3
9933: PPUSH
9934: CALL_OW 332
// DialogueOn ;
9938: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9942: LD_VAR 0 1
9946: PPUSH
9947: CALL_OW 250
9951: PPUSH
9952: LD_VAR 0 1
9956: PPUSH
9957: CALL_OW 251
9961: PPUSH
9962: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9966: LD_ADDR_VAR 0 1
9970: PUSH
9971: LD_INT 22
9973: PUSH
9974: LD_INT 7
9976: PUSH
9977: EMPTY
9978: LIST
9979: LIST
9980: PUSH
9981: LD_INT 23
9983: PUSH
9984: LD_INT 1
9986: PUSH
9987: EMPTY
9988: LIST
9989: LIST
9990: PUSH
9991: LD_INT 26
9993: PUSH
9994: LD_INT 1
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: EMPTY
10002: LIST
10003: LIST
10004: LIST
10005: PPUSH
10006: CALL_OW 69
10010: PUSH
10011: LD_EXP 16
10015: PUSH
10016: LD_EXP 20
10020: PUSH
10021: LD_EXP 21
10025: PUSH
10026: LD_EXP 28
10030: PUSH
10031: LD_EXP 17
10035: PUSH
10036: LD_EXP 26
10040: PUSH
10041: LD_EXP 22
10045: PUSH
10046: LD_EXP 24
10050: PUSH
10051: EMPTY
10052: LIST
10053: LIST
10054: LIST
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: LIST
10060: DIFF
10061: ST_TO_ADDR
// if not tmp then
10062: LD_VAR 0 1
10066: NOT
10067: IFFALSE 10141
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
10069: LD_ADDR_VAR 0 1
10073: PUSH
10074: LD_INT 22
10076: PUSH
10077: LD_INT 7
10079: PUSH
10080: EMPTY
10081: LIST
10082: LIST
10083: PUSH
10084: LD_INT 23
10086: PUSH
10087: LD_INT 1
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PUSH
10094: LD_INT 26
10096: PUSH
10097: LD_INT 2
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: PPUSH
10109: CALL_OW 69
10113: PUSH
10114: LD_EXP 31
10118: PUSH
10119: LD_EXP 18
10123: PUSH
10124: LD_EXP 29
10128: PUSH
10129: LD_EXP 30
10133: PUSH
10134: EMPTY
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: DIFF
10140: ST_TO_ADDR
// if tmp then
10141: LD_VAR 0 1
10145: IFFALSE 10216
// case GetSex ( tmp [ 1 ] ) of sex_male :
10147: LD_VAR 0 1
10151: PUSH
10152: LD_INT 1
10154: ARRAY
10155: PPUSH
10156: CALL_OW 258
10160: PUSH
10161: LD_INT 1
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10188
10169: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
10170: LD_VAR 0 1
10174: PUSH
10175: LD_INT 1
10177: ARRAY
10178: PPUSH
10179: LD_STRING D9-Sol1-1
10181: PPUSH
10182: CALL_OW 88
10186: GO 10216
10188: LD_INT 2
10190: DOUBLE
10191: EQUAL
10192: IFTRUE 10196
10194: GO 10215
10196: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
10197: LD_VAR 0 1
10201: PUSH
10202: LD_INT 1
10204: ARRAY
10205: PPUSH
10206: LD_STRING D9-FSol1-1
10208: PPUSH
10209: CALL_OW 88
10213: GO 10216
10215: POP
// if Frank then
10216: LD_EXP 28
10220: IFFALSE 10324
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
10222: LD_EXP 58
10226: PPUSH
10227: CALL_OW 250
10231: PPUSH
10232: LD_EXP 58
10236: PPUSH
10237: CALL_OW 251
10241: PPUSH
10242: LD_INT 7
10244: PPUSH
10245: LD_INT 8
10247: PPUSH
10248: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
10252: LD_EXP 58
10256: PPUSH
10257: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
10261: LD_EXP 28
10265: PPUSH
10266: LD_STRING D9-Frank-1
10268: PPUSH
10269: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
10273: LD_EXP 16
10277: PPUSH
10278: LD_STRING D9-JMM-1
10280: PPUSH
10281: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
10285: LD_EXP 28
10289: PPUSH
10290: LD_STRING D9-Frank-2
10292: PPUSH
10293: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
10297: LD_EXP 58
10301: PPUSH
10302: CALL_OW 250
10306: PPUSH
10307: LD_EXP 58
10311: PPUSH
10312: CALL_OW 251
10316: PPUSH
10317: LD_INT 7
10319: PPUSH
10320: CALL_OW 331
// end ; DialogueOff ;
10324: CALL_OW 7
// end ;
10328: PPOPN 1
10330: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
10331: LD_EXP 7
10335: PUSH
10336: LD_OWVAR 1
10340: PUSH
10341: LD_INT 42000
10343: GREATEREQUAL
10344: OR
10345: IFFALSE 11379
10347: GO 10349
10349: DISABLE
10350: LD_INT 0
10352: PPUSH
10353: PPUSH
// begin selected_option := 1 ;
10354: LD_ADDR_VAR 0 2
10358: PUSH
10359: LD_INT 1
10361: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10362: LD_INT 10500
10364: PPUSH
10365: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10369: LD_INT 35
10371: PPUSH
10372: CALL_OW 67
// until not ru_attackers ;
10376: LD_EXP 54
10380: NOT
10381: IFFALSE 10369
// PrepareBurlak ;
10383: CALL 2360 0 0
// repeat wait ( 0 0$2 ) ;
10387: LD_INT 70
10389: PPUSH
10390: CALL_OW 67
// until not HasTask ( Burlak ) ;
10394: LD_EXP 48
10398: PPUSH
10399: CALL_OW 314
10403: NOT
10404: IFFALSE 10387
// InGameOn ;
10406: CALL_OW 8
// DialogueOn ;
10410: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10414: LD_EXP 51
10418: PPUSH
10419: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10423: LD_EXP 48
10427: PPUSH
10428: LD_STRING D10-Bur-1
10430: PPUSH
10431: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10435: LD_EXP 49
10439: PUSH
10440: LD_EXP 49
10444: PPUSH
10445: CALL_OW 255
10449: PUSH
10450: LD_INT 7
10452: EQUAL
10453: AND
10454: IFFALSE 10468
// Say ( Belkov , D10-Bel-1 ) ;
10456: LD_EXP 49
10460: PPUSH
10461: LD_STRING D10-Bel-1
10463: PPUSH
10464: CALL_OW 88
// if Gossudarov then
10468: LD_EXP 34
10472: IFFALSE 10486
// Say ( Gossudarov , D10-Gos-1 ) ;
10474: LD_EXP 34
10478: PPUSH
10479: LD_STRING D10-Gos-1
10481: PPUSH
10482: CALL_OW 88
// if Kirilenkova then
10486: LD_EXP 35
10490: IFFALSE 10504
// Say ( Kirilenkova , D10-Kir-1 ) ;
10492: LD_EXP 35
10496: PPUSH
10497: LD_STRING D10-Kir-1
10499: PPUSH
10500: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10504: CALL 14032 0 0
10508: PPUSH
10509: LD_STRING D10-RSol1-1
10511: PPUSH
10512: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10516: LD_EXP 48
10520: PPUSH
10521: LD_STRING D10-Bur-2
10523: PPUSH
10524: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10528: LD_EXP 16
10532: PPUSH
10533: LD_STRING D10-JMM-2
10535: PPUSH
10536: CALL_OW 88
// if Kirilenkova then
10540: LD_EXP 35
10544: IFFALSE 10560
// Say ( Kirilenkova , D10-Kir-2 ) else
10546: LD_EXP 35
10550: PPUSH
10551: LD_STRING D10-Kir-2
10553: PPUSH
10554: CALL_OW 88
10558: GO 10572
// Say ( SolRu , D10-RSol1-2 ) ;
10560: CALL 14032 0 0
10564: PPUSH
10565: LD_STRING D10-RSol1-2
10567: PPUSH
10568: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10572: LD_EXP 16
10576: PPUSH
10577: LD_STRING D10-JMM-3
10579: PPUSH
10580: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10584: LD_EXP 48
10588: PPUSH
10589: LD_STRING D10-Bur-3
10591: PPUSH
10592: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10596: LD_EXP 16
10600: PPUSH
10601: LD_STRING D10-JMM-4
10603: PPUSH
10604: CALL_OW 88
// DialogueOff ;
10608: CALL_OW 7
// InGameOff ;
10612: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10616: LD_STRING M2
10618: PPUSH
10619: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10623: LD_INT 35
10625: PPUSH
10626: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10630: LD_INT 22
10632: PUSH
10633: LD_INT 7
10635: PUSH
10636: EMPTY
10637: LIST
10638: LIST
10639: PUSH
10640: LD_INT 91
10642: PUSH
10643: LD_EXP 48
10647: PUSH
10648: LD_INT 8
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: LIST
10655: PUSH
10656: EMPTY
10657: LIST
10658: LIST
10659: PPUSH
10660: CALL_OW 69
10664: IFFALSE 10623
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10666: LD_ADDR_VAR 0 1
10670: PUSH
10671: LD_INT 22
10673: PUSH
10674: LD_INT 4
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: PPUSH
10681: CALL_OW 69
10685: PUSH
10686: FOR_IN
10687: IFFALSE 10703
// SetSide ( i , 7 ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 7
10696: PPUSH
10697: CALL_OW 235
10701: GO 10686
10703: POP
10704: POP
// ChangeMissionObjectives ( M3 ) ;
10705: LD_STRING M3
10707: PPUSH
10708: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10712: LD_INT 35
10714: PPUSH
10715: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10719: LD_EXP 16
10723: PPUSH
10724: LD_EXP 48
10728: PPUSH
10729: CALL_OW 296
10733: PUSH
10734: LD_INT 8
10736: LESS
10737: IFFALSE 10712
// ComTurnUnit ( JMM , Burlak ) ;
10739: LD_EXP 16
10743: PPUSH
10744: LD_EXP 48
10748: PPUSH
10749: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10753: LD_EXP 48
10757: PPUSH
10758: LD_EXP 16
10762: PPUSH
10763: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10767: LD_INT 10
10769: PPUSH
10770: CALL_OW 67
// DialogueOn ;
10774: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10778: LD_EXP 16
10782: PPUSH
10783: LD_STRING D11-JMM-1
10785: PPUSH
10786: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10790: LD_EXP 48
10794: PPUSH
10795: LD_STRING D11-Bur-1
10797: PPUSH
10798: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10802: LD_EXP 16
10806: PPUSH
10807: LD_STRING D11-JMM-2
10809: PPUSH
10810: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10814: LD_EXP 48
10818: PPUSH
10819: LD_STRING D11-Bur-2
10821: PPUSH
10822: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10826: LD_EXP 16
10830: PPUSH
10831: LD_STRING D11-JMM-3
10833: PPUSH
10834: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10838: LD_EXP 48
10842: PPUSH
10843: LD_STRING D11-Bur-3
10845: PPUSH
10846: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10850: LD_EXP 16
10854: PPUSH
10855: LD_STRING D11-JMM-4
10857: PPUSH
10858: CALL_OW 88
// if ar_base_spotted then
10862: LD_EXP 8
10866: IFFALSE 10882
// Say ( Burlak , D12-Bur-1 ) else
10868: LD_EXP 48
10872: PPUSH
10873: LD_STRING D12-Bur-1
10875: PPUSH
10876: CALL_OW 88
10880: GO 10921
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10882: LD_INT 7
10884: PPUSH
10885: LD_INT 3
10887: PPUSH
10888: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10892: LD_INT 127
10894: PPUSH
10895: LD_INT 45
10897: PPUSH
10898: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10902: LD_EXP 48
10906: PPUSH
10907: LD_STRING D12-Bur-1a
10909: PPUSH
10910: CALL_OW 88
// dwait ( 0 0$2 ) ;
10914: LD_INT 70
10916: PPUSH
10917: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10921: LD_EXP 48
10925: PPUSH
10926: LD_STRING D12-Bur-1b
10928: PPUSH
10929: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10933: LD_EXP 16
10937: PPUSH
10938: LD_STRING D12-JMM-1
10940: PPUSH
10941: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10945: LD_EXP 48
10949: PPUSH
10950: LD_STRING D12-Bur-2
10952: PPUSH
10953: CALL_OW 88
// if Roth then
10957: LD_EXP 17
10961: IFFALSE 10977
// Say ( Roth , D12-Roth-2 ) else
10963: LD_EXP 17
10967: PPUSH
10968: LD_STRING D12-Roth-2
10970: PPUSH
10971: CALL_OW 88
10975: GO 10989
// Say ( SciRu , D12-RSci1-2 ) ;
10977: CALL 13885 0 0
10981: PPUSH
10982: LD_STRING D12-RSci1-2
10984: PPUSH
10985: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10989: LD_EXP 16
10993: PPUSH
10994: LD_STRING D12-JMM-2
10996: PPUSH
10997: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
11001: LD_EXP 48
11005: PPUSH
11006: LD_STRING D12-Bur-3
11008: PPUSH
11009: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
11013: LD_EXP 16
11017: PPUSH
11018: LD_STRING D12-JMM-3
11020: PPUSH
11021: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
11025: LD_EXP 48
11029: PPUSH
11030: LD_STRING D12-Bur-4
11032: PPUSH
11033: CALL_OW 88
// case Query ( QBase ) of 1 :
11037: LD_STRING QBase
11039: PPUSH
11040: CALL_OW 97
11044: PUSH
11045: LD_INT 1
11047: DOUBLE
11048: EQUAL
11049: IFTRUE 11053
11051: GO 11171
11053: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
11054: LD_EXP 16
11058: PPUSH
11059: LD_STRING D13a-JMM-1
11061: PPUSH
11062: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
11066: LD_EXP 48
11070: PPUSH
11071: LD_STRING D13a-Bur-1
11073: PPUSH
11074: CALL_OW 88
// if Roth then
11078: LD_EXP 17
11082: IFFALSE 11098
// Say ( Roth , D13a-Roth-1 ) else
11084: LD_EXP 17
11088: PPUSH
11089: LD_STRING D13a-Roth-1
11091: PPUSH
11092: CALL_OW 88
11096: GO 11110
// Say ( SciRu , D13a-RSci1-1 ) ;
11098: CALL 13885 0 0
11102: PPUSH
11103: LD_STRING D13a-RSci1-1
11105: PPUSH
11106: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
11110: LD_EXP 16
11114: PPUSH
11115: LD_STRING D13a-JMM-2
11117: PPUSH
11118: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
11122: LD_STRING QBaseAgain
11124: PPUSH
11125: CALL_OW 97
11129: PUSH
11130: LD_INT 1
11132: DOUBLE
11133: EQUAL
11134: IFTRUE 11138
11136: GO 11149
11138: POP
// selected_option := 2 ; 2 :
11139: LD_ADDR_VAR 0 2
11143: PUSH
11144: LD_INT 2
11146: ST_TO_ADDR
11147: GO 11169
11149: LD_INT 2
11151: DOUBLE
11152: EQUAL
11153: IFTRUE 11157
11155: GO 11168
11157: POP
// selected_option := 3 ; end ;
11158: LD_ADDR_VAR 0 2
11162: PUSH
11163: LD_INT 3
11165: ST_TO_ADDR
11166: GO 11169
11168: POP
// end ; 2 :
11169: GO 11210
11171: LD_INT 2
11173: DOUBLE
11174: EQUAL
11175: IFTRUE 11179
11177: GO 11190
11179: POP
// selected_option := 2 ; 3 :
11180: LD_ADDR_VAR 0 2
11184: PUSH
11185: LD_INT 2
11187: ST_TO_ADDR
11188: GO 11210
11190: LD_INT 3
11192: DOUBLE
11193: EQUAL
11194: IFTRUE 11198
11196: GO 11209
11198: POP
// selected_option := 3 ; end ;
11199: LD_ADDR_VAR 0 2
11203: PUSH
11204: LD_INT 3
11206: ST_TO_ADDR
11207: GO 11210
11209: POP
// if selected_option = 2 then
11210: LD_VAR 0 2
11214: PUSH
11215: LD_INT 2
11217: EQUAL
11218: IFFALSE 11312
// begin Say ( JMM , D13b-JMM-1 ) ;
11220: LD_EXP 16
11224: PPUSH
11225: LD_STRING D13b-JMM-1
11227: PPUSH
11228: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
11232: LD_EXP 48
11236: PPUSH
11237: LD_STRING D13b-Bur-1
11239: PPUSH
11240: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
11244: LD_EXP 16
11248: PPUSH
11249: LD_STRING D13b-JMM-2
11251: PPUSH
11252: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
11256: LD_EXP 57
11260: PPUSH
11261: LD_STRING D13b-Abd-2
11263: PPUSH
11264: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
11268: LD_EXP 16
11272: PPUSH
11273: LD_STRING D13b-JMM-3
11275: PPUSH
11276: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
11280: LD_EXP 57
11284: PPUSH
11285: LD_STRING D13b-Abd-3
11287: PPUSH
11288: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
11292: LD_EXP 16
11296: PPUSH
11297: LD_STRING D13b-JMM-4
11299: PPUSH
11300: CALL_OW 88
// ar_active_attack := true ;
11304: LD_ADDR_EXP 9
11308: PUSH
11309: LD_INT 1
11311: ST_TO_ADDR
// end ; if selected_option = 3 then
11312: LD_VAR 0 2
11316: PUSH
11317: LD_INT 3
11319: EQUAL
11320: IFFALSE 11346
// begin Say ( JMM , D13c-JMM-1 ) ;
11322: LD_EXP 16
11326: PPUSH
11327: LD_STRING D13c-JMM-1
11329: PPUSH
11330: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
11334: LD_EXP 48
11338: PPUSH
11339: LD_STRING D13c-Bur-1
11341: PPUSH
11342: CALL_OW 88
// end ; DialogueOff ;
11346: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
11350: LD_STRING M4
11352: PPUSH
11353: CALL_OW 337
// if not ar_active_attack then
11357: LD_EXP 9
11361: NOT
11362: IFFALSE 11379
// begin wait ( 6 6$00 ) ;
11364: LD_INT 12600
11366: PPUSH
11367: CALL_OW 67
// ar_active_attack := true ;
11371: LD_ADDR_EXP 9
11375: PUSH
11376: LD_INT 1
11378: ST_TO_ADDR
// end ; end ;
11379: PPOPN 2
11381: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
11382: LD_EXP 48
11386: PPUSH
11387: CALL_OW 305
11391: PUSH
11392: LD_EXP 48
11396: PPUSH
11397: CALL_OW 255
11401: PUSH
11402: LD_INT 7
11404: EQUAL
11405: AND
11406: IFFALSE 11602
11408: GO 11410
11410: DISABLE
11411: LD_INT 0
11413: PPUSH
// begin wait ( 4 4$40 ) ;
11414: LD_INT 9800
11416: PPUSH
11417: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11421: LD_INT 35
11423: PPUSH
11424: CALL_OW 67
// until not ru_attackers ;
11428: LD_EXP 54
11432: NOT
11433: IFFALSE 11421
// PrepareGnyevko ;
11435: CALL 2304 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11439: LD_EXP 50
11443: PPUSH
11444: LD_INT 124
11446: PPUSH
11447: LD_INT 118
11449: PPUSH
11450: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11454: LD_EXP 50
11458: PPUSH
11459: CALL_OW 200
// time := 0 0$00 ;
11463: LD_ADDR_VAR 0 1
11467: PUSH
11468: LD_INT 0
11470: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11471: LD_INT 35
11473: PPUSH
11474: CALL_OW 67
// time := time + 0 0$1 ;
11478: LD_ADDR_VAR 0 1
11482: PUSH
11483: LD_VAR 0 1
11487: PUSH
11488: LD_INT 35
11490: PLUS
11491: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11492: LD_EXP 50
11496: PPUSH
11497: LD_INT 124
11499: PPUSH
11500: LD_INT 118
11502: PPUSH
11503: CALL_OW 307
11507: PUSH
11508: LD_VAR 0 1
11512: PUSH
11513: LD_INT 1050
11515: GREATEREQUAL
11516: OR
11517: IFFALSE 11471
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11519: LD_EXP 50
11523: PPUSH
11524: LD_STRING DBelkov-Gny-1
11526: PPUSH
11527: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11531: LD_EXP 48
11535: PPUSH
11536: LD_STRING DBelkov-Bur-1a
11538: PPUSH
11539: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11543: LD_INT 35
11545: PPUSH
11546: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11550: LD_EXP 50
11554: PPUSH
11555: LD_INT 22
11557: PUSH
11558: LD_INT 7
11560: PUSH
11561: EMPTY
11562: LIST
11563: LIST
11564: PPUSH
11565: CALL_OW 69
11569: PPUSH
11570: LD_EXP 50
11574: PPUSH
11575: CALL_OW 74
11579: PPUSH
11580: CALL_OW 296
11584: PUSH
11585: LD_INT 8
11587: LESS
11588: IFFALSE 11543
// SetSide ( Gnyevko , 7 ) ;
11590: LD_EXP 50
11594: PPUSH
11595: LD_INT 7
11597: PPUSH
11598: CALL_OW 235
// end ;
11602: PPOPN 1
11604: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11605: LD_EXP 48
11609: PPUSH
11610: CALL_OW 255
11614: PUSH
11615: LD_INT 7
11617: EQUAL
11618: IFFALSE 11628
11620: GO 11622
11622: DISABLE
// begin enable ;
11623: ENABLE
// PrepareAmericanAttack ;
11624: CALL 7263 0 0
// end ;
11628: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11629: LD_INT 22
11631: PUSH
11632: LD_INT 1
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: PPUSH
11639: CALL_OW 69
11643: IFFALSE 11827
11645: GO 11647
11647: DISABLE
11648: LD_INT 0
11650: PPUSH
11651: PPUSH
// begin while true do
11652: LD_INT 1
11654: IFFALSE 11711
// begin wait ( 0 0$1 ) ;
11656: LD_INT 35
11658: PPUSH
11659: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11663: LD_ADDR_VAR 0 2
11667: PUSH
11668: LD_INT 22
11670: PUSH
11671: LD_INT 1
11673: PUSH
11674: EMPTY
11675: LIST
11676: LIST
11677: PPUSH
11678: CALL_OW 69
11682: PPUSH
11683: LD_EXP 16
11687: PPUSH
11688: CALL_OW 74
11692: ST_TO_ADDR
// if See ( 7 , tmp ) then
11693: LD_INT 7
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: CALL_OW 292
11705: IFFALSE 11709
// break ;
11707: GO 11711
// end ;
11709: GO 11652
// DialogueOn ;
11711: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11715: LD_VAR 0 2
11719: PPUSH
11720: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 250
11733: PPUSH
11734: LD_VAR 0 2
11738: PPUSH
11739: CALL_OW 251
11743: PPUSH
11744: LD_INT 7
11746: PPUSH
11747: LD_INT 8
11749: PPUSH
11750: CALL_OW 330
// if Denis then
11754: LD_EXP 22
11758: IFFALSE 11772
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11760: LD_EXP 22
11764: PPUSH
11765: LD_STRING DAmerAttack-Pet-1
11767: PPUSH
11768: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11772: LD_EXP 16
11776: PPUSH
11777: LD_STRING DAmerAttack-JMM-1
11779: PPUSH
11780: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11784: LD_EXP 48
11788: PPUSH
11789: LD_STRING DStop-Bur-1
11791: PPUSH
11792: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11796: LD_VAR 0 2
11800: PPUSH
11801: CALL_OW 250
11805: PPUSH
11806: LD_VAR 0 2
11810: PPUSH
11811: CALL_OW 251
11815: PPUSH
11816: LD_INT 7
11818: PPUSH
11819: CALL_OW 331
// DialogueOff ;
11823: CALL_OW 7
// end ;
11827: PPOPN 2
11829: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11830: LD_INT 22
11832: PUSH
11833: LD_INT 3
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: LD_INT 21
11842: PUSH
11843: LD_INT 1
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PPUSH
11854: CALL_OW 69
11858: PUSH
11859: LD_INT 0
11861: EQUAL
11862: IFFALSE 11904
11864: GO 11866
11866: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11867: LD_STRING M5a
11869: PPUSH
11870: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11874: LD_EXP 16
11878: PPUSH
11879: LD_STRING D8-JMM-1
11881: PPUSH
11882: CALL_OW 88
// if Gossudarov then
11886: LD_EXP 34
11890: IFFALSE 11904
// Say ( Gossudarov , D8-Gos-1 ) ;
11892: LD_EXP 34
11896: PPUSH
11897: LD_STRING D8-Gos-1
11899: PPUSH
11900: CALL_OW 88
// end ;
11904: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11905: LD_INT 22
11907: PUSH
11908: LD_INT 2
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: PUSH
11915: LD_INT 21
11917: PUSH
11918: LD_INT 1
11920: PUSH
11921: EMPTY
11922: LIST
11923: LIST
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PPUSH
11929: CALL_OW 69
11933: PUSH
11934: LD_INT 0
11936: EQUAL
11937: IFFALSE 11987
11939: GO 11941
11941: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11942: LD_STRING M4c
11944: PPUSH
11945: CALL_OW 337
// if Roth then
11949: LD_EXP 17
11953: IFFALSE 11969
// Say ( Roth , DStop-Roth-1 ) else
11955: LD_EXP 17
11959: PPUSH
11960: LD_STRING DStop-Roth-1
11962: PPUSH
11963: CALL_OW 88
11967: GO 11987
// if Gossudarov then
11969: LD_EXP 34
11973: IFFALSE 11987
// Say ( Gossudarov , D8-Gos-1a ) ;
11975: LD_EXP 34
11979: PPUSH
11980: LD_STRING D8-Gos-1a
11982: PPUSH
11983: CALL_OW 88
// end ;
11987: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11988: LD_INT 7
11990: PPUSH
11991: LD_INT 1
11993: PPUSH
11994: LD_INT 1
11996: PPUSH
11997: CALL 15564 0 3
12001: PUSH
12002: LD_INT 0
12004: EQUAL
12005: PUSH
12006: LD_INT 7
12008: PPUSH
12009: LD_INT 3
12011: PPUSH
12012: LD_INT 1
12014: PPUSH
12015: CALL 15564 0 3
12019: PUSH
12020: LD_INT 0
12022: EQUAL
12023: AND
12024: IFFALSE 12036
12026: GO 12028
12028: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
12029: LD_STRING M1a
12031: PPUSH
12032: CALL_OW 337
// end ;
12036: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
12037: LD_INT 22
12039: PUSH
12040: LD_INT 2
12042: PUSH
12043: EMPTY
12044: LIST
12045: LIST
12046: PUSH
12047: LD_INT 23
12049: PUSH
12050: LD_INT 2
12052: PUSH
12053: EMPTY
12054: LIST
12055: LIST
12056: PUSH
12057: LD_INT 21
12059: PUSH
12060: LD_INT 1
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: PUSH
12067: EMPTY
12068: LIST
12069: LIST
12070: LIST
12071: PPUSH
12072: CALL_OW 69
12076: PUSH
12077: LD_INT 0
12079: EQUAL
12080: PUSH
12081: LD_INT 22
12083: PUSH
12084: LD_INT 3
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PUSH
12091: LD_INT 23
12093: PUSH
12094: LD_INT 3
12096: PUSH
12097: EMPTY
12098: LIST
12099: LIST
12100: PUSH
12101: LD_INT 21
12103: PUSH
12104: LD_INT 1
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: LIST
12115: PPUSH
12116: CALL_OW 69
12120: PUSH
12121: LD_INT 0
12123: EQUAL
12124: AND
12125: PUSH
12126: LD_INT 22
12128: PUSH
12129: LD_INT 1
12131: PUSH
12132: EMPTY
12133: LIST
12134: LIST
12135: PPUSH
12136: CALL_OW 69
12140: PUSH
12141: LD_INT 0
12143: EQUAL
12144: AND
12145: PUSH
12146: LD_INT 7
12148: PPUSH
12149: LD_INT 1
12151: PPUSH
12152: LD_INT 1
12154: PPUSH
12155: CALL 15564 0 3
12159: PUSH
12160: LD_INT 0
12162: EQUAL
12163: AND
12164: PUSH
12165: LD_INT 7
12167: PPUSH
12168: LD_INT 3
12170: PPUSH
12171: LD_INT 1
12173: PPUSH
12174: CALL 15564 0 3
12178: PUSH
12179: LD_INT 0
12181: EQUAL
12182: AND
12183: PUSH
12184: LD_EXP 48
12188: PPUSH
12189: CALL_OW 255
12193: PUSH
12194: LD_INT 7
12196: EQUAL
12197: AND
12198: PUSH
12199: LD_EXP 48
12203: PPUSH
12204: CALL_OW 302
12208: AND
12209: IFFALSE 13882
12211: GO 12213
12213: DISABLE
12214: LD_INT 0
12216: PPUSH
12217: PPUSH
12218: PPUSH
12219: PPUSH
12220: PPUSH
12221: PPUSH
// begin m1 := false ;
12222: LD_ADDR_VAR 0 4
12226: PUSH
12227: LD_INT 0
12229: ST_TO_ADDR
// m2 := false ;
12230: LD_ADDR_VAR 0 5
12234: PUSH
12235: LD_INT 0
12237: ST_TO_ADDR
// m3 := false ;
12238: LD_ADDR_VAR 0 6
12242: PUSH
12243: LD_INT 0
12245: ST_TO_ADDR
// if tick < 40 40$00 then
12246: LD_OWVAR 1
12250: PUSH
12251: LD_INT 84000
12253: LESS
12254: IFFALSE 12263
// SetAchievement ( ACH_ASPEED_17 ) ;
12256: LD_STRING ACH_ASPEED_17
12258: PPUSH
12259: CALL_OW 543
// wait ( 0 0$5 ) ;
12263: LD_INT 175
12265: PPUSH
12266: CALL_OW 67
// if not masha_killed then
12270: LD_EXP 10
12274: NOT
12275: IFFALSE 12297
// begin m1 := true ;
12277: LD_ADDR_VAR 0 4
12281: PUSH
12282: LD_INT 1
12284: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
12285: LD_STRING Masha
12287: PPUSH
12288: LD_INT 1
12290: PPUSH
12291: CALL_OW 101
// end else
12295: GO 12308
// AddMedal ( Masha , - 1 ) ;
12297: LD_STRING Masha
12299: PPUSH
12300: LD_INT 1
12302: NEG
12303: PPUSH
12304: CALL_OW 101
// if abdul_escaped then
12308: LD_EXP 13
12312: IFFALSE 12327
// AddMedal ( Abdul , - 1 ) else
12314: LD_STRING Abdul
12316: PPUSH
12317: LD_INT 1
12319: NEG
12320: PPUSH
12321: CALL_OW 101
12325: GO 12345
// begin m2 := true ;
12327: LD_ADDR_VAR 0 5
12331: PUSH
12332: LD_INT 1
12334: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
12335: LD_STRING Abdul
12337: PPUSH
12338: LD_INT 1
12340: PPUSH
12341: CALL_OW 101
// end ; if loss_counter = 0 then
12345: LD_EXP 14
12349: PUSH
12350: LD_INT 0
12352: EQUAL
12353: IFFALSE 12375
// begin m3 := true ;
12355: LD_ADDR_VAR 0 6
12359: PUSH
12360: LD_INT 1
12362: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
12363: LD_STRING People
12365: PPUSH
12366: LD_INT 2
12368: PPUSH
12369: CALL_OW 101
// end else
12373: GO 12437
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
12375: LD_EXP 14
12379: PUSH
12380: LD_INT 3
12382: PUSH
12383: LD_INT 2
12385: PUSH
12386: LD_INT 2
12388: PUSH
12389: LD_INT 1
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: PUSH
12398: LD_OWVAR 67
12402: ARRAY
12403: LESSEQUAL
12404: IFFALSE 12426
// begin AddMedal ( People , 1 ) ;
12406: LD_STRING People
12408: PPUSH
12409: LD_INT 1
12411: PPUSH
12412: CALL_OW 101
// m3 := true ;
12416: LD_ADDR_VAR 0 6
12420: PUSH
12421: LD_INT 1
12423: ST_TO_ADDR
// end else
12424: GO 12437
// AddMedal ( People , - 1 ) ;
12426: LD_STRING People
12428: PPUSH
12429: LD_INT 1
12431: NEG
12432: PPUSH
12433: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
12437: LD_OWVAR 67
12441: PUSH
12442: LD_INT 3
12444: GREATEREQUAL
12445: PUSH
12446: LD_VAR 0 4
12450: AND
12451: PUSH
12452: LD_VAR 0 5
12456: AND
12457: PUSH
12458: LD_VAR 0 6
12462: AND
12463: IFFALSE 12475
// SetAchievementEX ( ACH_AMER , 17 ) ;
12465: LD_STRING ACH_AMER
12467: PPUSH
12468: LD_INT 17
12470: PPUSH
12471: CALL_OW 564
// GiveMedals ( MAIN ) ;
12475: LD_STRING MAIN
12477: PPUSH
12478: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12482: LD_ADDR_VAR 0 2
12486: PUSH
12487: LD_INT 22
12489: PUSH
12490: LD_INT 7
12492: PUSH
12493: EMPTY
12494: LIST
12495: LIST
12496: PUSH
12497: LD_INT 50
12499: PUSH
12500: EMPTY
12501: LIST
12502: PUSH
12503: LD_INT 2
12505: PUSH
12506: LD_INT 25
12508: PUSH
12509: LD_INT 1
12511: PUSH
12512: EMPTY
12513: LIST
12514: LIST
12515: PUSH
12516: LD_INT 25
12518: PUSH
12519: LD_INT 2
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: PUSH
12526: LD_INT 25
12528: PUSH
12529: LD_INT 3
12531: PUSH
12532: EMPTY
12533: LIST
12534: LIST
12535: PUSH
12536: LD_INT 25
12538: PUSH
12539: LD_INT 4
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: PUSH
12546: LD_INT 25
12548: PUSH
12549: LD_INT 5
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: PUSH
12556: LD_INT 25
12558: PUSH
12559: LD_INT 8
12561: PUSH
12562: EMPTY
12563: LIST
12564: LIST
12565: PUSH
12566: LD_INT 25
12568: PUSH
12569: LD_INT 9
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: LIST
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: LIST
12590: PPUSH
12591: CALL_OW 69
12595: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12596: LD_VAR 0 2
12600: PPUSH
12601: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
12605: LD_ADDR_VAR 0 3
12609: PUSH
12610: LD_EXP 16
12614: PUSH
12615: LD_EXP 17
12619: PUSH
12620: LD_EXP 18
12624: PUSH
12625: LD_EXP 19
12629: PUSH
12630: LD_EXP 20
12634: PUSH
12635: LD_EXP 21
12639: PUSH
12640: LD_EXP 22
12644: PUSH
12645: LD_EXP 23
12649: PUSH
12650: LD_EXP 24
12654: PUSH
12655: LD_EXP 25
12659: PUSH
12660: LD_EXP 26
12664: PUSH
12665: LD_EXP 27
12669: PUSH
12670: LD_EXP 28
12674: PUSH
12675: LD_EXP 29
12679: PUSH
12680: LD_EXP 30
12684: PUSH
12685: LD_EXP 31
12689: PUSH
12690: LD_EXP 32
12694: PUSH
12695: LD_EXP 34
12699: PUSH
12700: LD_EXP 35
12704: PUSH
12705: LD_EXP 36
12709: PUSH
12710: LD_EXP 38
12714: PUSH
12715: LD_EXP 39
12719: PUSH
12720: LD_EXP 40
12724: PUSH
12725: LD_EXP 41
12729: PUSH
12730: LD_EXP 42
12734: PUSH
12735: LD_EXP 43
12739: PUSH
12740: LD_EXP 44
12744: PUSH
12745: LD_EXP 45
12749: PUSH
12750: LD_EXP 46
12754: PUSH
12755: LD_EXP 47
12759: PUSH
12760: LD_EXP 48
12764: PUSH
12765: LD_EXP 49
12769: PUSH
12770: LD_EXP 50
12774: PUSH
12775: LD_EXP 33
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: LIST
12789: LIST
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: ST_TO_ADDR
// if tmp diff tmp2 then
12816: LD_VAR 0 2
12820: PUSH
12821: LD_VAR 0 3
12825: DIFF
12826: IFFALSE 12846
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12828: LD_VAR 0 2
12832: PUSH
12833: LD_VAR 0 3
12837: DIFF
12838: PPUSH
12839: LD_STRING 13a_others
12841: PPUSH
12842: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12846: LD_EXP 16
12850: PPUSH
12851: LD_STRING 13a_JMM
12853: PPUSH
12854: CALL_OW 38
// if IsOk ( Mike ) then
12858: LD_EXP 33
12862: PPUSH
12863: CALL_OW 302
12867: IFFALSE 12881
// SaveCharacters ( Mike , 13a_Mike ) ;
12869: LD_EXP 33
12873: PPUSH
12874: LD_STRING 13a_Mike
12876: PPUSH
12877: CALL_OW 38
// if IsOk ( Titov ) then
12881: LD_EXP 36
12885: PPUSH
12886: CALL_OW 302
12890: IFFALSE 12904
// SaveCharacters ( Titov , 13a_Titov ) ;
12892: LD_EXP 36
12896: PPUSH
12897: LD_STRING 13a_Titov
12899: PPUSH
12900: CALL_OW 38
// if IsOk ( Dolgov ) then
12904: LD_EXP 38
12908: PPUSH
12909: CALL_OW 302
12913: IFFALSE 12927
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12915: LD_EXP 38
12919: PPUSH
12920: LD_STRING 13a_Dolgov
12922: PPUSH
12923: CALL_OW 38
// if IsOk ( Petrosyan ) then
12927: LD_EXP 39
12931: PPUSH
12932: CALL_OW 302
12936: IFFALSE 12950
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12938: LD_EXP 39
12942: PPUSH
12943: LD_STRING 13a_Petrosyan
12945: PPUSH
12946: CALL_OW 38
// if IsOk ( Scholtze ) then
12950: LD_EXP 40
12954: PPUSH
12955: CALL_OW 302
12959: IFFALSE 12973
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12961: LD_EXP 40
12965: PPUSH
12966: LD_STRING 13a_Scholtze
12968: PPUSH
12969: CALL_OW 38
// if IsOk ( Oblukov ) then
12973: LD_EXP 41
12977: PPUSH
12978: CALL_OW 302
12982: IFFALSE 12996
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12984: LD_EXP 41
12988: PPUSH
12989: LD_STRING 13a_Oblukov
12991: PPUSH
12992: CALL_OW 38
// if IsOk ( Kapitsova ) then
12996: LD_EXP 42
13000: PPUSH
13001: CALL_OW 302
13005: IFFALSE 13019
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
13007: LD_EXP 42
13011: PPUSH
13012: LD_STRING 13a_Kapitsova
13014: PPUSH
13015: CALL_OW 38
// if IsOk ( Lipshchin ) then
13019: LD_EXP 43
13023: PPUSH
13024: CALL_OW 302
13028: IFFALSE 13042
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
13030: LD_EXP 43
13034: PPUSH
13035: LD_STRING 13a_Lipshchin
13037: PPUSH
13038: CALL_OW 38
// if IsOk ( Petrovova ) then
13042: LD_EXP 44
13046: PPUSH
13047: CALL_OW 302
13051: IFFALSE 13065
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
13053: LD_EXP 44
13057: PPUSH
13058: LD_STRING 13a_Petrovova
13060: PPUSH
13061: CALL_OW 38
// if IsOk ( Kovalyuk ) then
13065: LD_EXP 45
13069: PPUSH
13070: CALL_OW 302
13074: IFFALSE 13088
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
13076: LD_EXP 45
13080: PPUSH
13081: LD_STRING 13a_Kovalyuk
13083: PPUSH
13084: CALL_OW 38
// if IsOk ( Kuzmov ) then
13088: LD_EXP 46
13092: PPUSH
13093: CALL_OW 302
13097: IFFALSE 13111
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
13099: LD_EXP 46
13103: PPUSH
13104: LD_STRING 13a_Kuzmov
13106: PPUSH
13107: CALL_OW 38
// if IsOk ( Karamazov ) then
13111: LD_EXP 47
13115: PPUSH
13116: CALL_OW 302
13120: IFFALSE 13134
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
13122: LD_EXP 47
13126: PPUSH
13127: LD_STRING 13a_Karamazov
13129: PPUSH
13130: CALL_OW 38
// if Burlak then
13134: LD_EXP 48
13138: IFFALSE 13159
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
13140: LD_STRING enableBioCharacter(BIO_GORKI)
13142: PPUSH
13143: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
13147: LD_EXP 48
13151: PPUSH
13152: LD_STRING 13a_Burlak
13154: PPUSH
13155: CALL_OW 38
// end ; if IsOk ( Belkov ) then
13159: LD_EXP 49
13163: PPUSH
13164: CALL_OW 302
13168: IFFALSE 13182
// SaveCharacters ( Belkov , 13a_Belkov ) ;
13170: LD_EXP 49
13174: PPUSH
13175: LD_STRING 13a_Belkov
13177: PPUSH
13178: CALL_OW 38
// if IsOk ( Gnyevko ) then
13182: LD_EXP 50
13186: PPUSH
13187: CALL_OW 302
13191: IFFALSE 13205
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
13193: LD_EXP 50
13197: PPUSH
13198: LD_STRING 13a_Gnyevko
13200: PPUSH
13201: CALL_OW 38
// if IsOk ( Lisa ) then
13205: LD_EXP 18
13209: PPUSH
13210: CALL_OW 302
13214: IFFALSE 13228
// SaveCharacters ( Lisa , 13a_Lisa ) ;
13216: LD_EXP 18
13220: PPUSH
13221: LD_STRING 13a_Lisa
13223: PPUSH
13224: CALL_OW 38
// if IsOk ( Donaldson ) then
13228: LD_EXP 19
13232: PPUSH
13233: CALL_OW 302
13237: IFFALSE 13251
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
13239: LD_EXP 19
13243: PPUSH
13244: LD_STRING 13a_Donaldson
13246: PPUSH
13247: CALL_OW 38
// if IsOk ( Bobby ) then
13251: LD_EXP 20
13255: PPUSH
13256: CALL_OW 302
13260: IFFALSE 13274
// SaveCharacters ( Bobby , 13a_Bobby ) ;
13262: LD_EXP 20
13266: PPUSH
13267: LD_STRING 13a_Bobby
13269: PPUSH
13270: CALL_OW 38
// if IsOk ( Cyrus ) then
13274: LD_EXP 21
13278: PPUSH
13279: CALL_OW 302
13283: IFFALSE 13297
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
13285: LD_EXP 21
13289: PPUSH
13290: LD_STRING 13a_Cyrus
13292: PPUSH
13293: CALL_OW 38
// if IsOk ( Denis ) then
13297: LD_EXP 22
13301: PPUSH
13302: CALL_OW 302
13306: IFFALSE 13320
// SaveCharacters ( Denis , 13a_Denis ) ;
13308: LD_EXP 22
13312: PPUSH
13313: LD_STRING 13a_Denis
13315: PPUSH
13316: CALL_OW 38
// if IsOk ( Brown ) then
13320: LD_EXP 23
13324: PPUSH
13325: CALL_OW 302
13329: IFFALSE 13343
// SaveCharacters ( Brown , 13a_Brown ) ;
13331: LD_EXP 23
13335: PPUSH
13336: LD_STRING 13a_Brown
13338: PPUSH
13339: CALL_OW 38
// if IsOk ( Gladstone ) then
13343: LD_EXP 24
13347: PPUSH
13348: CALL_OW 302
13352: IFFALSE 13366
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
13354: LD_EXP 24
13358: PPUSH
13359: LD_STRING 13a_Gladstone
13361: PPUSH
13362: CALL_OW 38
// if IsOk ( Houten ) then
13366: LD_EXP 25
13370: PPUSH
13371: CALL_OW 302
13375: IFFALSE 13389
// SaveCharacters ( Houten , 13a_Houten ) ;
13377: LD_EXP 25
13381: PPUSH
13382: LD_STRING 13a_Houten
13384: PPUSH
13385: CALL_OW 38
// if IsOk ( Cornel ) then
13389: LD_EXP 26
13393: PPUSH
13394: CALL_OW 302
13398: IFFALSE 13412
// SaveCharacters ( Cornel , 13a_Cornel ) ;
13400: LD_EXP 26
13404: PPUSH
13405: LD_STRING 13a_Cornel
13407: PPUSH
13408: CALL_OW 38
// if IsOk ( Gary ) then
13412: LD_EXP 27
13416: PPUSH
13417: CALL_OW 302
13421: IFFALSE 13435
// SaveCharacters ( Gary , 13a_Gary ) ;
13423: LD_EXP 27
13427: PPUSH
13428: LD_STRING 13a_Gary
13430: PPUSH
13431: CALL_OW 38
// if IsOk ( Frank ) then
13435: LD_EXP 28
13439: PPUSH
13440: CALL_OW 302
13444: IFFALSE 13458
// SaveCharacters ( Frank , 13a_Frank ) ;
13446: LD_EXP 28
13450: PPUSH
13451: LD_STRING 13a_Frank
13453: PPUSH
13454: CALL_OW 38
// if IsOk ( Kikuchi ) then
13458: LD_EXP 29
13462: PPUSH
13463: CALL_OW 302
13467: IFFALSE 13481
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
13469: LD_EXP 29
13473: PPUSH
13474: LD_STRING 13a_Kikuchi
13476: PPUSH
13477: CALL_OW 38
// if IsOk ( Simms ) then
13481: LD_EXP 30
13485: PPUSH
13486: CALL_OW 302
13490: IFFALSE 13504
// SaveCharacters ( Simms , 13a_Simms ) ;
13492: LD_EXP 30
13496: PPUSH
13497: LD_STRING 13a_Simms
13499: PPUSH
13500: CALL_OW 38
// if IsOk ( Joan ) then
13504: LD_EXP 31
13508: PPUSH
13509: CALL_OW 302
13513: IFFALSE 13527
// SaveCharacters ( Joan , 13a_Joan ) ;
13515: LD_EXP 31
13519: PPUSH
13520: LD_STRING 13a_Joan
13522: PPUSH
13523: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
13527: LD_EXP 32
13531: PPUSH
13532: CALL_OW 302
13536: IFFALSE 13550
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
13538: LD_EXP 32
13542: PPUSH
13543: LD_STRING 13a_DeltaDoctor
13545: PPUSH
13546: CALL_OW 38
// if IsOk ( Gossudarov ) then
13550: LD_EXP 34
13554: PPUSH
13555: CALL_OW 302
13559: IFFALSE 13573
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
13561: LD_EXP 34
13565: PPUSH
13566: LD_STRING 13a_Gossudarov
13568: PPUSH
13569: CALL_OW 38
// if IsOk ( Kirilenkova ) then
13573: LD_EXP 35
13577: PPUSH
13578: CALL_OW 302
13582: IFFALSE 13596
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
13584: LD_EXP 35
13588: PPUSH
13589: LD_STRING 13a_Kirilenkova
13591: PPUSH
13592: CALL_OW 38
// if IsOk ( Roth ) then
13596: LD_EXP 17
13600: PPUSH
13601: CALL_OW 302
13605: IFFALSE 13619
// SaveCharacters ( Roth , 13a_Roth ) ;
13607: LD_EXP 17
13611: PPUSH
13612: LD_STRING 13a_Roth
13614: PPUSH
13615: CALL_OW 38
// if Masha then
13619: LD_EXP 51
13623: IFFALSE 13678
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
13625: LD_EXP 51
13629: PPUSH
13630: CALL_OW 265
13634: PUSH
13635: LD_EXP 51
13639: PPUSH
13640: CALL_OW 262
13644: PUSH
13645: LD_EXP 51
13649: PPUSH
13650: CALL_OW 263
13654: PUSH
13655: LD_EXP 51
13659: PPUSH
13660: CALL_OW 264
13664: PUSH
13665: EMPTY
13666: LIST
13667: LIST
13668: LIST
13669: LIST
13670: PPUSH
13671: LD_STRING 13a_Masha
13673: PPUSH
13674: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13678: LD_ADDR_VAR 0 2
13682: PUSH
13683: LD_INT 21
13685: PUSH
13686: LD_INT 3
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: PPUSH
13693: CALL_OW 69
13697: ST_TO_ADDR
// tmp2 := [ ] ;
13698: LD_ADDR_VAR 0 3
13702: PUSH
13703: EMPTY
13704: ST_TO_ADDR
// if tmp then
13705: LD_VAR 0 2
13709: IFFALSE 13860
// for i in tmp do
13711: LD_ADDR_VAR 0 1
13715: PUSH
13716: LD_VAR 0 2
13720: PUSH
13721: FOR_IN
13722: IFFALSE 13858
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13724: LD_ADDR_VAR 0 3
13728: PUSH
13729: LD_VAR 0 3
13733: PUSH
13734: LD_VAR 0 1
13738: PPUSH
13739: CALL_OW 255
13743: PUSH
13744: LD_VAR 0 1
13748: PPUSH
13749: CALL_OW 248
13753: PUSH
13754: LD_VAR 0 1
13758: PPUSH
13759: CALL_OW 266
13763: PUSH
13764: LD_VAR 0 1
13768: PPUSH
13769: CALL_OW 250
13773: PUSH
13774: LD_VAR 0 1
13778: PPUSH
13779: CALL_OW 251
13783: PUSH
13784: LD_VAR 0 1
13788: PPUSH
13789: CALL_OW 254
13793: PUSH
13794: LD_VAR 0 1
13798: PPUSH
13799: CALL_OW 267
13803: PUSH
13804: LD_VAR 0 1
13808: PPUSH
13809: LD_INT 1
13811: PPUSH
13812: CALL_OW 268
13816: PUSH
13817: LD_VAR 0 1
13821: PPUSH
13822: LD_INT 2
13824: PPUSH
13825: CALL_OW 268
13829: PUSH
13830: LD_VAR 0 1
13834: PPUSH
13835: CALL_OW 269
13839: PUSH
13840: EMPTY
13841: LIST
13842: LIST
13843: LIST
13844: LIST
13845: LIST
13846: LIST
13847: LIST
13848: LIST
13849: LIST
13850: LIST
13851: PUSH
13852: EMPTY
13853: LIST
13854: ADD
13855: ST_TO_ADDR
13856: GO 13721
13858: POP
13859: POP
// if tmp2 then
13860: LD_VAR 0 3
13864: IFFALSE 13878
// SaveVariable ( tmp2 , 13a_buildings ) ;
13866: LD_VAR 0 3
13870: PPUSH
13871: LD_STRING 13a_buildings
13873: PPUSH
13874: CALL_OW 39
// YouWin ;
13878: CALL_OW 103
// end ;
13882: PPOPN 6
13884: END
// export function SciRu ; var tmp , t ; begin
13885: LD_INT 0
13887: PPUSH
13888: PPUSH
13889: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13890: LD_ADDR_VAR 0 3
13894: PUSH
13895: LD_EXP 34
13899: PUSH
13900: LD_EXP 48
13904: PUSH
13905: LD_EXP 36
13909: PUSH
13910: LD_EXP 49
13914: PUSH
13915: LD_EXP 50
13919: PUSH
13920: LD_EXP 39
13924: PUSH
13925: LD_EXP 40
13929: PUSH
13930: LD_EXP 38
13934: PUSH
13935: EMPTY
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13945: LD_ADDR_VAR 0 2
13949: PUSH
13950: LD_INT 22
13952: PUSH
13953: LD_INT 7
13955: PUSH
13956: EMPTY
13957: LIST
13958: LIST
13959: PUSH
13960: LD_INT 23
13962: PUSH
13963: LD_INT 3
13965: PUSH
13966: EMPTY
13967: LIST
13968: LIST
13969: PUSH
13970: LD_INT 25
13972: PUSH
13973: LD_INT 4
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: PUSH
13980: LD_INT 26
13982: PUSH
13983: LD_INT 1
13985: PUSH
13986: EMPTY
13987: LIST
13988: LIST
13989: PUSH
13990: EMPTY
13991: LIST
13992: LIST
13993: LIST
13994: LIST
13995: PPUSH
13996: CALL_OW 69
14000: PUSH
14001: LD_VAR 0 3
14005: DIFF
14006: ST_TO_ADDR
// if tmp then
14007: LD_VAR 0 2
14011: IFFALSE 14027
// result := tmp [ 1 ] ;
14013: LD_ADDR_VAR 0 1
14017: PUSH
14018: LD_VAR 0 2
14022: PUSH
14023: LD_INT 1
14025: ARRAY
14026: ST_TO_ADDR
// end ;
14027: LD_VAR 0 1
14031: RET
// export function SolRu ; var tmp , t ; begin
14032: LD_INT 0
14034: PPUSH
14035: PPUSH
14036: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14037: LD_ADDR_VAR 0 3
14041: PUSH
14042: LD_EXP 34
14046: PUSH
14047: LD_EXP 48
14051: PUSH
14052: LD_EXP 36
14056: PUSH
14057: LD_EXP 49
14061: PUSH
14062: LD_EXP 50
14066: PUSH
14067: LD_EXP 39
14071: PUSH
14072: LD_EXP 40
14076: PUSH
14077: LD_EXP 38
14081: PUSH
14082: EMPTY
14083: LIST
14084: LIST
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: LIST
14090: LIST
14091: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
14092: LD_ADDR_VAR 0 2
14096: PUSH
14097: LD_INT 22
14099: PUSH
14100: LD_INT 7
14102: PUSH
14103: EMPTY
14104: LIST
14105: LIST
14106: PUSH
14107: LD_INT 23
14109: PUSH
14110: LD_INT 3
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: PUSH
14117: LD_INT 25
14119: PUSH
14120: LD_INT 1
14122: PUSH
14123: EMPTY
14124: LIST
14125: LIST
14126: PUSH
14127: LD_INT 26
14129: PUSH
14130: LD_INT 1
14132: PUSH
14133: EMPTY
14134: LIST
14135: LIST
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: PPUSH
14143: CALL_OW 69
14147: PUSH
14148: LD_VAR 0 3
14152: DIFF
14153: ST_TO_ADDR
// if tmp then
14154: LD_VAR 0 2
14158: IFFALSE 14174
// result := tmp [ 1 ] ;
14160: LD_ADDR_VAR 0 1
14164: PUSH
14165: LD_VAR 0 2
14169: PUSH
14170: LD_INT 1
14172: ARRAY
14173: ST_TO_ADDR
// end ; end_of_file
14174: LD_VAR 0 1
14178: RET
// export function CustomEvent ( event ) ; begin
14179: LD_INT 0
14181: PPUSH
// end ;
14182: LD_VAR 0 2
14186: RET
// on UnitDestroyed ( un ) do var i , side ;
14187: LD_INT 0
14189: PPUSH
14190: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
14191: LD_VAR 0 1
14195: PPUSH
14196: CALL 103935 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
14200: LD_VAR 0 1
14204: PUSH
14205: LD_INT 22
14207: PUSH
14208: LD_INT 7
14210: PUSH
14211: EMPTY
14212: LIST
14213: LIST
14214: PUSH
14215: LD_INT 2
14217: PUSH
14218: LD_INT 25
14220: PUSH
14221: LD_INT 1
14223: PUSH
14224: EMPTY
14225: LIST
14226: LIST
14227: PUSH
14228: LD_INT 25
14230: PUSH
14231: LD_INT 2
14233: PUSH
14234: EMPTY
14235: LIST
14236: LIST
14237: PUSH
14238: LD_INT 25
14240: PUSH
14241: LD_INT 3
14243: PUSH
14244: EMPTY
14245: LIST
14246: LIST
14247: PUSH
14248: LD_INT 25
14250: PUSH
14251: LD_INT 4
14253: PUSH
14254: EMPTY
14255: LIST
14256: LIST
14257: PUSH
14258: LD_INT 25
14260: PUSH
14261: LD_INT 5
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: PUSH
14268: LD_INT 25
14270: PUSH
14271: LD_INT 8
14273: PUSH
14274: EMPTY
14275: LIST
14276: LIST
14277: PUSH
14278: LD_INT 25
14280: PUSH
14281: LD_INT 9
14283: PUSH
14284: EMPTY
14285: LIST
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: PUSH
14298: EMPTY
14299: LIST
14300: LIST
14301: PPUSH
14302: CALL_OW 69
14306: IN
14307: IFFALSE 14323
// loss_counter := loss_counter + 1 ;
14309: LD_ADDR_EXP 14
14313: PUSH
14314: LD_EXP 14
14318: PUSH
14319: LD_INT 1
14321: PLUS
14322: ST_TO_ADDR
// if un = Abdul then
14323: LD_VAR 0 1
14327: PUSH
14328: LD_EXP 57
14332: EQUAL
14333: IFFALSE 14343
// abdul_escaped := false ;
14335: LD_ADDR_EXP 13
14339: PUSH
14340: LD_INT 0
14342: ST_TO_ADDR
// if un in ru_attackers then
14343: LD_VAR 0 1
14347: PUSH
14348: LD_EXP 54
14352: IN
14353: IFFALSE 14371
// ru_attackers := ru_attackers diff un ;
14355: LD_ADDR_EXP 54
14359: PUSH
14360: LD_EXP 54
14364: PUSH
14365: LD_VAR 0 1
14369: DIFF
14370: ST_TO_ADDR
// if un in ar_attackers then
14371: LD_VAR 0 1
14375: PUSH
14376: LD_EXP 11
14380: IN
14381: IFFALSE 14399
// ar_attackers := ar_attackers diff un ;
14383: LD_ADDR_EXP 11
14387: PUSH
14388: LD_EXP 11
14392: PUSH
14393: LD_VAR 0 1
14397: DIFF
14398: ST_TO_ADDR
// if un = JMM then
14399: LD_VAR 0 1
14403: PUSH
14404: LD_EXP 16
14408: EQUAL
14409: IFFALSE 14420
// begin YouLost ( JMM ) ;
14411: LD_STRING JMM
14413: PPUSH
14414: CALL_OW 104
// exit ;
14418: GO 14517
// end ; if un = Burlak then
14420: LD_VAR 0 1
14424: PUSH
14425: LD_EXP 48
14429: EQUAL
14430: IFFALSE 14441
// begin YouLost ( Burlak ) ;
14432: LD_STRING Burlak
14434: PPUSH
14435: CALL_OW 104
// exit ;
14439: GO 14517
// end ; if un = freedom then
14441: LD_VAR 0 1
14445: PUSH
14446: LD_EXP 3
14450: EQUAL
14451: IFFALSE 14462
// begin YouLost ( Destroyed ) ;
14453: LD_STRING Destroyed
14455: PPUSH
14456: CALL_OW 104
// exit ;
14460: GO 14517
// end ; if un = Masha then
14462: LD_VAR 0 1
14466: PUSH
14467: LD_EXP 51
14471: EQUAL
14472: IFFALSE 14489
// begin ChangeMissionObjectives ( M4b ) ;
14474: LD_STRING M4b
14476: PPUSH
14477: CALL_OW 337
// masha_killed := true ;
14481: LD_ADDR_EXP 10
14485: PUSH
14486: LD_INT 1
14488: ST_TO_ADDR
// end ; if un = Mastodont then
14489: LD_VAR 0 1
14493: PUSH
14494: LD_EXP 58
14498: EQUAL
14499: IFFALSE 14508
// ChangeMissionObjectives ( M4a ) ;
14501: LD_STRING M4a
14503: PPUSH
14504: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
14508: LD_VAR 0 1
14512: PPUSH
14513: CALL 85149 0 1
// end ;
14517: PPOPN 3
14519: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
14520: LD_VAR 0 1
14524: PPUSH
14525: LD_VAR 0 2
14529: PPUSH
14530: CALL 87481 0 2
// end ;
14534: PPOPN 2
14536: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
14537: LD_VAR 0 1
14541: PPUSH
14542: CALL 86549 0 1
// end ;
14546: PPOPN 1
14548: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
14549: LD_VAR 0 1
14553: PUSH
14554: LD_INT 22
14556: PUSH
14557: LD_INT 7
14559: PUSH
14560: EMPTY
14561: LIST
14562: LIST
14563: PUSH
14564: LD_INT 30
14566: PUSH
14567: LD_INT 0
14569: PUSH
14570: EMPTY
14571: LIST
14572: LIST
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: PPUSH
14578: CALL_OW 69
14582: IN
14583: IFFALSE 14622
// begin SetBName ( building , freedom ) ;
14585: LD_VAR 0 1
14589: PPUSH
14590: LD_STRING freedom
14592: PPUSH
14593: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
14597: LD_INT 0
14599: PPUSH
14600: LD_INT 7
14602: PPUSH
14603: LD_INT 0
14605: PPUSH
14606: CALL_OW 324
// freedom := building ;
14610: LD_ADDR_EXP 3
14614: PUSH
14615: LD_VAR 0 1
14619: ST_TO_ADDR
// exit ;
14620: GO 14688
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
14622: LD_VAR 0 1
14626: PUSH
14627: LD_INT 22
14629: PUSH
14630: LD_INT 7
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: LD_INT 23
14639: PUSH
14640: LD_INT 3
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 30
14649: PUSH
14650: LD_INT 6
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PPUSH
14662: CALL_OW 69
14666: IN
14667: IFFALSE 14679
// begin ru_lab_builded := true ;
14669: LD_ADDR_EXP 5
14673: PUSH
14674: LD_INT 1
14676: ST_TO_ADDR
// exit ;
14677: GO 14688
// end ; MCE_BuildingComplete ( building ) ;
14679: LD_VAR 0 1
14683: PPUSH
14684: CALL 86790 0 1
// end ;
14688: PPOPN 1
14690: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14691: LD_VAR 0 1
14695: PPUSH
14696: LD_VAR 0 2
14700: PPUSH
14701: CALL 84845 0 2
// end ;
14705: PPOPN 2
14707: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14708: LD_VAR 0 1
14712: PPUSH
14713: LD_VAR 0 2
14717: PPUSH
14718: LD_VAR 0 3
14722: PPUSH
14723: LD_VAR 0 4
14727: PPUSH
14728: LD_VAR 0 5
14732: PPUSH
14733: CALL 84465 0 5
// end ;
14737: PPOPN 5
14739: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
14740: LD_VAR 0 1
14744: PPUSH
14745: LD_VAR 0 2
14749: PPUSH
14750: CALL 104055 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
14754: LD_VAR 0 1
14758: PPUSH
14759: LD_VAR 0 2
14763: PPUSH
14764: CALL 84018 0 2
// end ;
14768: PPOPN 2
14770: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14771: LD_VAR 0 1
14775: PPUSH
14776: CALL_OW 263
14780: PUSH
14781: LD_INT 3
14783: EQUAL
14784: PUSH
14785: LD_VAR 0 2
14789: PPUSH
14790: CALL_OW 263
14794: PUSH
14795: LD_INT 3
14797: EQUAL
14798: OR
14799: IFFALSE 14815
// hack_counter := hack_counter + 1 ;
14801: LD_ADDR_EXP 15
14805: PUSH
14806: LD_EXP 15
14810: PUSH
14811: LD_INT 1
14813: PLUS
14814: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14815: LD_VAR 0 1
14819: PPUSH
14820: LD_VAR 0 2
14824: PPUSH
14825: LD_VAR 0 3
14829: PPUSH
14830: LD_VAR 0 4
14834: PPUSH
14835: CALL 83856 0 4
// end ;
14839: PPOPN 4
14841: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14842: LD_VAR 0 1
14846: PPUSH
14847: LD_VAR 0 2
14851: PPUSH
14852: LD_VAR 0 3
14856: PPUSH
14857: CALL 83631 0 3
// end ;
14861: PPOPN 3
14863: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14864: LD_VAR 0 1
14868: PPUSH
14869: LD_VAR 0 2
14873: PPUSH
14874: CALL 83516 0 2
// end ;
14878: PPOPN 2
14880: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14881: LD_VAR 0 1
14885: PPUSH
14886: LD_VAR 0 2
14890: PPUSH
14891: CALL 87776 0 2
// end ;
14895: PPOPN 2
14897: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14898: LD_VAR 0 1
14902: PPUSH
14903: LD_VAR 0 2
14907: PPUSH
14908: LD_VAR 0 3
14912: PPUSH
14913: LD_VAR 0 4
14917: PPUSH
14918: CALL 87992 0 4
// end ;
14922: PPOPN 4
14924: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14925: LD_VAR 0 1
14929: PPUSH
14930: LD_VAR 0 2
14934: PPUSH
14935: CALL 83325 0 2
// end ;
14939: PPOPN 2
14941: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14942: LD_VAR 0 1
14946: PPUSH
14947: CALL 104039 0 1
// end ; end_of_file
14951: PPOPN 1
14953: END
// every 0 0$30 do var cr , time ;
14954: GO 14956
14956: DISABLE
14957: LD_INT 0
14959: PPUSH
14960: PPUSH
// begin time := 0 0$20 ;
14961: LD_ADDR_VAR 0 2
14965: PUSH
14966: LD_INT 700
14968: ST_TO_ADDR
// while game do
14969: LD_EXP 2
14973: IFFALSE 15076
// begin wait ( time ) ;
14975: LD_VAR 0 2
14979: PPUSH
14980: CALL_OW 67
// if tick > 2 2$00 then
14984: LD_OWVAR 1
14988: PUSH
14989: LD_INT 4200
14991: GREATER
14992: IFFALSE 15029
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14994: LD_ADDR_VAR 0 2
14998: PUSH
14999: LD_VAR 0 2
15003: PUSH
15004: LD_INT 140
15006: PUSH
15007: LD_INT 140
15009: PUSH
15010: LD_INT 210
15012: PUSH
15013: LD_INT 280
15015: PUSH
15016: EMPTY
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: PUSH
15022: LD_OWVAR 67
15026: ARRAY
15027: PLUS
15028: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
15029: LD_INT 1
15031: PPUSH
15032: LD_INT 5
15034: PPUSH
15035: CALL_OW 12
15039: PPUSH
15040: LD_INT 70
15042: PPUSH
15043: LD_INT 49
15045: PPUSH
15046: LD_INT 25
15048: PPUSH
15049: LD_INT 1
15051: PPUSH
15052: CALL_OW 56
// if time > 3 3$00 then
15056: LD_VAR 0 2
15060: PUSH
15061: LD_INT 6300
15063: GREATER
15064: IFFALSE 15074
// time := 0 0$30 ;
15066: LD_ADDR_VAR 0 2
15070: PUSH
15071: LD_INT 1050
15073: ST_TO_ADDR
// end ;
15074: GO 14969
// end ;
15076: PPOPN 2
15078: END
// every 0 0$30 do var cr , time ;
15079: GO 15081
15081: DISABLE
15082: LD_INT 0
15084: PPUSH
15085: PPUSH
// begin time := 0 0$20 ;
15086: LD_ADDR_VAR 0 2
15090: PUSH
15091: LD_INT 700
15093: ST_TO_ADDR
// while game do
15094: LD_EXP 2
15098: IFFALSE 15191
// begin wait ( time ) ;
15100: LD_VAR 0 2
15104: PPUSH
15105: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
15109: LD_ADDR_VAR 0 2
15113: PUSH
15114: LD_VAR 0 2
15118: PUSH
15119: LD_INT 140
15121: PUSH
15122: LD_INT 175
15124: PUSH
15125: LD_INT 210
15127: PUSH
15128: LD_INT 280
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: LIST
15135: LIST
15136: PUSH
15137: LD_OWVAR 67
15141: ARRAY
15142: PLUS
15143: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
15144: LD_INT 3
15146: PPUSH
15147: LD_INT 5
15149: PPUSH
15150: CALL_OW 12
15154: PPUSH
15155: LD_INT 26
15157: PPUSH
15158: LD_INT 9
15160: PPUSH
15161: LD_INT 30
15163: PPUSH
15164: LD_INT 1
15166: PPUSH
15167: CALL_OW 56
// if time > 3 3$00 then
15171: LD_VAR 0 2
15175: PUSH
15176: LD_INT 6300
15178: GREATER
15179: IFFALSE 15189
// time := 0 0$20 ;
15181: LD_ADDR_VAR 0 2
15185: PUSH
15186: LD_INT 700
15188: ST_TO_ADDR
// end ;
15189: GO 15094
// end ;
15191: PPOPN 2
15193: END
// every 0 0$30 do var cr , time ;
15194: GO 15196
15196: DISABLE
15197: LD_INT 0
15199: PPUSH
15200: PPUSH
// begin time := 0 0$20 ;
15201: LD_ADDR_VAR 0 2
15205: PUSH
15206: LD_INT 700
15208: ST_TO_ADDR
// while game do
15209: LD_EXP 2
15213: IFFALSE 15342
// begin wait ( time ) ;
15215: LD_VAR 0 2
15219: PPUSH
15220: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
15224: LD_ADDR_VAR 0 2
15228: PUSH
15229: LD_VAR 0 2
15233: PUSH
15234: LD_INT 175
15236: PUSH
15237: LD_INT 210
15239: PUSH
15240: LD_INT 280
15242: PUSH
15243: LD_INT 350
15245: PUSH
15246: EMPTY
15247: LIST
15248: LIST
15249: LIST
15250: LIST
15251: PUSH
15252: LD_OWVAR 67
15256: ARRAY
15257: PLUS
15258: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
15259: LD_INT 1
15261: PPUSH
15262: LD_INT 5
15264: PPUSH
15265: CALL_OW 12
15269: PPUSH
15270: LD_INT 179
15272: PPUSH
15273: LD_INT 101
15275: PPUSH
15276: LD_INT 20
15278: PPUSH
15279: LD_INT 1
15281: PPUSH
15282: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
15286: LD_INT 350
15288: PPUSH
15289: LD_INT 525
15291: PPUSH
15292: CALL_OW 12
15296: PPUSH
15297: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
15301: LD_INT 1
15303: PPUSH
15304: LD_INT 5
15306: PPUSH
15307: CALL_OW 12
15311: PPUSH
15312: LD_INT 9
15314: PPUSH
15315: LD_INT 1
15317: PPUSH
15318: CALL_OW 55
// if time > 4 4$00 then
15322: LD_VAR 0 2
15326: PUSH
15327: LD_INT 8400
15329: GREATER
15330: IFFALSE 15340
// time := 0 0$30 ;
15332: LD_ADDR_VAR 0 2
15336: PUSH
15337: LD_INT 1050
15339: ST_TO_ADDR
// end ;
15340: GO 15209
// end ;
15342: PPOPN 2
15344: END
// every 0 0$30 do var cr , time ;
15345: GO 15347
15347: DISABLE
15348: LD_INT 0
15350: PPUSH
15351: PPUSH
// begin time := 0 0$10 ;
15352: LD_ADDR_VAR 0 2
15356: PUSH
15357: LD_INT 350
15359: ST_TO_ADDR
// while game do
15360: LD_EXP 2
15364: IFFALSE 15498
// begin wait ( time ) ;
15366: LD_VAR 0 2
15370: PPUSH
15371: CALL_OW 67
// time := time + 0 0$10 ;
15375: LD_ADDR_VAR 0 2
15379: PUSH
15380: LD_VAR 0 2
15384: PUSH
15385: LD_INT 350
15387: PLUS
15388: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
15389: LD_INT 1
15391: PPUSH
15392: LD_INT 5
15394: PPUSH
15395: CALL_OW 12
15399: PPUSH
15400: LD_INT 11
15402: PPUSH
15403: LD_INT 1
15405: PPUSH
15406: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
15410: LD_ADDR_VAR 0 1
15414: PUSH
15415: LD_INT 1
15417: PPUSH
15418: LD_INT 3
15420: PPUSH
15421: CALL_OW 12
15425: ST_TO_ADDR
// if cr = 1 then
15426: LD_VAR 0 1
15430: PUSH
15431: LD_INT 1
15433: EQUAL
15434: IFFALSE 15478
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
15436: LD_INT 700
15438: PPUSH
15439: LD_INT 1575
15441: PPUSH
15442: CALL_OW 12
15446: PPUSH
15447: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
15451: LD_INT 1
15453: PPUSH
15454: LD_INT 5
15456: PPUSH
15457: CALL_OW 12
15461: PPUSH
15462: LD_INT 34
15464: PPUSH
15465: LD_INT 50
15467: PPUSH
15468: LD_INT 7
15470: PPUSH
15471: LD_INT 1
15473: PPUSH
15474: CALL_OW 56
// end ; if time > 4 4$00 then
15478: LD_VAR 0 2
15482: PUSH
15483: LD_INT 8400
15485: GREATER
15486: IFFALSE 15496
// time := 0 0$40 ;
15488: LD_ADDR_VAR 0 2
15492: PUSH
15493: LD_INT 1400
15495: ST_TO_ADDR
// end ;
15496: GO 15360
// end ; end_of_file
15498: PPOPN 2
15500: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
15501: LD_INT 0
15503: PPUSH
15504: PPUSH
// if exist_mode then
15505: LD_VAR 0 2
15509: IFFALSE 15534
// unit := CreateCharacter ( prefix & ident ) else
15511: LD_ADDR_VAR 0 5
15515: PUSH
15516: LD_VAR 0 3
15520: PUSH
15521: LD_VAR 0 1
15525: STR
15526: PPUSH
15527: CALL_OW 34
15531: ST_TO_ADDR
15532: GO 15549
// unit := NewCharacter ( ident ) ;
15534: LD_ADDR_VAR 0 5
15538: PUSH
15539: LD_VAR 0 1
15543: PPUSH
15544: CALL_OW 25
15548: ST_TO_ADDR
// result := unit ;
15549: LD_ADDR_VAR 0 4
15553: PUSH
15554: LD_VAR 0 5
15558: ST_TO_ADDR
// end ;
15559: LD_VAR 0 4
15563: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
15564: LD_INT 0
15566: PPUSH
15567: PPUSH
// if not side or not nation then
15568: LD_VAR 0 1
15572: NOT
15573: PUSH
15574: LD_VAR 0 2
15578: NOT
15579: OR
15580: IFFALSE 15584
// exit ;
15582: GO 16352
// case nation of nation_american :
15584: LD_VAR 0 2
15588: PUSH
15589: LD_INT 1
15591: DOUBLE
15592: EQUAL
15593: IFTRUE 15597
15595: GO 15811
15597: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
15598: LD_ADDR_VAR 0 4
15602: PUSH
15603: LD_INT 35
15605: PUSH
15606: LD_INT 45
15608: PUSH
15609: LD_INT 46
15611: PUSH
15612: LD_INT 47
15614: PUSH
15615: LD_INT 82
15617: PUSH
15618: LD_INT 83
15620: PUSH
15621: LD_INT 84
15623: PUSH
15624: LD_INT 85
15626: PUSH
15627: LD_INT 86
15629: PUSH
15630: LD_INT 1
15632: PUSH
15633: LD_INT 2
15635: PUSH
15636: LD_INT 6
15638: PUSH
15639: LD_INT 15
15641: PUSH
15642: LD_INT 16
15644: PUSH
15645: LD_INT 7
15647: PUSH
15648: LD_INT 12
15650: PUSH
15651: LD_INT 13
15653: PUSH
15654: LD_INT 10
15656: PUSH
15657: LD_INT 14
15659: PUSH
15660: LD_INT 20
15662: PUSH
15663: LD_INT 21
15665: PUSH
15666: LD_INT 22
15668: PUSH
15669: LD_INT 25
15671: PUSH
15672: LD_INT 32
15674: PUSH
15675: LD_INT 27
15677: PUSH
15678: LD_INT 36
15680: PUSH
15681: LD_INT 69
15683: PUSH
15684: LD_INT 39
15686: PUSH
15687: LD_INT 34
15689: PUSH
15690: LD_INT 40
15692: PUSH
15693: LD_INT 48
15695: PUSH
15696: LD_INT 49
15698: PUSH
15699: LD_INT 50
15701: PUSH
15702: LD_INT 51
15704: PUSH
15705: LD_INT 52
15707: PUSH
15708: LD_INT 53
15710: PUSH
15711: LD_INT 54
15713: PUSH
15714: LD_INT 55
15716: PUSH
15717: LD_INT 56
15719: PUSH
15720: LD_INT 57
15722: PUSH
15723: LD_INT 58
15725: PUSH
15726: LD_INT 59
15728: PUSH
15729: LD_INT 60
15731: PUSH
15732: LD_INT 61
15734: PUSH
15735: LD_INT 62
15737: PUSH
15738: LD_INT 80
15740: PUSH
15741: LD_INT 82
15743: PUSH
15744: LD_INT 83
15746: PUSH
15747: LD_INT 84
15749: PUSH
15750: LD_INT 85
15752: PUSH
15753: LD_INT 86
15755: PUSH
15756: EMPTY
15757: LIST
15758: LIST
15759: LIST
15760: LIST
15761: LIST
15762: LIST
15763: LIST
15764: LIST
15765: LIST
15766: LIST
15767: LIST
15768: LIST
15769: LIST
15770: LIST
15771: LIST
15772: LIST
15773: LIST
15774: LIST
15775: LIST
15776: LIST
15777: LIST
15778: LIST
15779: LIST
15780: LIST
15781: LIST
15782: LIST
15783: LIST
15784: LIST
15785: LIST
15786: LIST
15787: LIST
15788: LIST
15789: LIST
15790: LIST
15791: LIST
15792: LIST
15793: LIST
15794: LIST
15795: LIST
15796: LIST
15797: LIST
15798: LIST
15799: LIST
15800: LIST
15801: LIST
15802: LIST
15803: LIST
15804: LIST
15805: LIST
15806: LIST
15807: LIST
15808: ST_TO_ADDR
15809: GO 16276
15811: LD_INT 2
15813: DOUBLE
15814: EQUAL
15815: IFTRUE 15819
15817: GO 16045
15819: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15820: LD_ADDR_VAR 0 4
15824: PUSH
15825: LD_INT 35
15827: PUSH
15828: LD_INT 45
15830: PUSH
15831: LD_INT 46
15833: PUSH
15834: LD_INT 47
15836: PUSH
15837: LD_INT 82
15839: PUSH
15840: LD_INT 83
15842: PUSH
15843: LD_INT 84
15845: PUSH
15846: LD_INT 85
15848: PUSH
15849: LD_INT 87
15851: PUSH
15852: LD_INT 70
15854: PUSH
15855: LD_INT 1
15857: PUSH
15858: LD_INT 11
15860: PUSH
15861: LD_INT 3
15863: PUSH
15864: LD_INT 4
15866: PUSH
15867: LD_INT 5
15869: PUSH
15870: LD_INT 6
15872: PUSH
15873: LD_INT 15
15875: PUSH
15876: LD_INT 18
15878: PUSH
15879: LD_INT 7
15881: PUSH
15882: LD_INT 17
15884: PUSH
15885: LD_INT 8
15887: PUSH
15888: LD_INT 20
15890: PUSH
15891: LD_INT 21
15893: PUSH
15894: LD_INT 22
15896: PUSH
15897: LD_INT 72
15899: PUSH
15900: LD_INT 26
15902: PUSH
15903: LD_INT 69
15905: PUSH
15906: LD_INT 39
15908: PUSH
15909: LD_INT 40
15911: PUSH
15912: LD_INT 41
15914: PUSH
15915: LD_INT 42
15917: PUSH
15918: LD_INT 43
15920: PUSH
15921: LD_INT 48
15923: PUSH
15924: LD_INT 49
15926: PUSH
15927: LD_INT 50
15929: PUSH
15930: LD_INT 51
15932: PUSH
15933: LD_INT 52
15935: PUSH
15936: LD_INT 53
15938: PUSH
15939: LD_INT 54
15941: PUSH
15942: LD_INT 55
15944: PUSH
15945: LD_INT 56
15947: PUSH
15948: LD_INT 60
15950: PUSH
15951: LD_INT 61
15953: PUSH
15954: LD_INT 62
15956: PUSH
15957: LD_INT 66
15959: PUSH
15960: LD_INT 67
15962: PUSH
15963: LD_INT 68
15965: PUSH
15966: LD_INT 81
15968: PUSH
15969: LD_INT 82
15971: PUSH
15972: LD_INT 83
15974: PUSH
15975: LD_INT 84
15977: PUSH
15978: LD_INT 85
15980: PUSH
15981: LD_INT 87
15983: PUSH
15984: LD_INT 88
15986: PUSH
15987: EMPTY
15988: LIST
15989: LIST
15990: LIST
15991: LIST
15992: LIST
15993: LIST
15994: LIST
15995: LIST
15996: LIST
15997: LIST
15998: LIST
15999: LIST
16000: LIST
16001: LIST
16002: LIST
16003: LIST
16004: LIST
16005: LIST
16006: LIST
16007: LIST
16008: LIST
16009: LIST
16010: LIST
16011: LIST
16012: LIST
16013: LIST
16014: LIST
16015: LIST
16016: LIST
16017: LIST
16018: LIST
16019: LIST
16020: LIST
16021: LIST
16022: LIST
16023: LIST
16024: LIST
16025: LIST
16026: LIST
16027: LIST
16028: LIST
16029: LIST
16030: LIST
16031: LIST
16032: LIST
16033: LIST
16034: LIST
16035: LIST
16036: LIST
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: ST_TO_ADDR
16043: GO 16276
16045: LD_INT 3
16047: DOUBLE
16048: EQUAL
16049: IFTRUE 16053
16051: GO 16275
16053: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
16054: LD_ADDR_VAR 0 4
16058: PUSH
16059: LD_INT 46
16061: PUSH
16062: LD_INT 47
16064: PUSH
16065: LD_INT 1
16067: PUSH
16068: LD_INT 2
16070: PUSH
16071: LD_INT 82
16073: PUSH
16074: LD_INT 83
16076: PUSH
16077: LD_INT 84
16079: PUSH
16080: LD_INT 85
16082: PUSH
16083: LD_INT 86
16085: PUSH
16086: LD_INT 11
16088: PUSH
16089: LD_INT 9
16091: PUSH
16092: LD_INT 20
16094: PUSH
16095: LD_INT 19
16097: PUSH
16098: LD_INT 21
16100: PUSH
16101: LD_INT 24
16103: PUSH
16104: LD_INT 22
16106: PUSH
16107: LD_INT 25
16109: PUSH
16110: LD_INT 28
16112: PUSH
16113: LD_INT 29
16115: PUSH
16116: LD_INT 30
16118: PUSH
16119: LD_INT 31
16121: PUSH
16122: LD_INT 37
16124: PUSH
16125: LD_INT 38
16127: PUSH
16128: LD_INT 32
16130: PUSH
16131: LD_INT 27
16133: PUSH
16134: LD_INT 33
16136: PUSH
16137: LD_INT 69
16139: PUSH
16140: LD_INT 39
16142: PUSH
16143: LD_INT 34
16145: PUSH
16146: LD_INT 40
16148: PUSH
16149: LD_INT 71
16151: PUSH
16152: LD_INT 23
16154: PUSH
16155: LD_INT 44
16157: PUSH
16158: LD_INT 48
16160: PUSH
16161: LD_INT 49
16163: PUSH
16164: LD_INT 50
16166: PUSH
16167: LD_INT 51
16169: PUSH
16170: LD_INT 52
16172: PUSH
16173: LD_INT 53
16175: PUSH
16176: LD_INT 54
16178: PUSH
16179: LD_INT 55
16181: PUSH
16182: LD_INT 56
16184: PUSH
16185: LD_INT 57
16187: PUSH
16188: LD_INT 58
16190: PUSH
16191: LD_INT 59
16193: PUSH
16194: LD_INT 63
16196: PUSH
16197: LD_INT 64
16199: PUSH
16200: LD_INT 65
16202: PUSH
16203: LD_INT 82
16205: PUSH
16206: LD_INT 83
16208: PUSH
16209: LD_INT 84
16211: PUSH
16212: LD_INT 85
16214: PUSH
16215: LD_INT 86
16217: PUSH
16218: EMPTY
16219: LIST
16220: LIST
16221: LIST
16222: LIST
16223: LIST
16224: LIST
16225: LIST
16226: LIST
16227: LIST
16228: LIST
16229: LIST
16230: LIST
16231: LIST
16232: LIST
16233: LIST
16234: LIST
16235: LIST
16236: LIST
16237: LIST
16238: LIST
16239: LIST
16240: LIST
16241: LIST
16242: LIST
16243: LIST
16244: LIST
16245: LIST
16246: LIST
16247: LIST
16248: LIST
16249: LIST
16250: LIST
16251: LIST
16252: LIST
16253: LIST
16254: LIST
16255: LIST
16256: LIST
16257: LIST
16258: LIST
16259: LIST
16260: LIST
16261: LIST
16262: LIST
16263: LIST
16264: LIST
16265: LIST
16266: LIST
16267: LIST
16268: LIST
16269: LIST
16270: LIST
16271: LIST
16272: ST_TO_ADDR
16273: GO 16276
16275: POP
// if state > - 1 and state < 3 then
16276: LD_VAR 0 3
16280: PUSH
16281: LD_INT 1
16283: NEG
16284: GREATER
16285: PUSH
16286: LD_VAR 0 3
16290: PUSH
16291: LD_INT 3
16293: LESS
16294: AND
16295: IFFALSE 16352
// for i in result do
16297: LD_ADDR_VAR 0 5
16301: PUSH
16302: LD_VAR 0 4
16306: PUSH
16307: FOR_IN
16308: IFFALSE 16350
// if GetTech ( i , side ) <> state then
16310: LD_VAR 0 5
16314: PPUSH
16315: LD_VAR 0 1
16319: PPUSH
16320: CALL_OW 321
16324: PUSH
16325: LD_VAR 0 3
16329: NONEQUAL
16330: IFFALSE 16348
// result := result diff i ;
16332: LD_ADDR_VAR 0 4
16336: PUSH
16337: LD_VAR 0 4
16341: PUSH
16342: LD_VAR 0 5
16346: DIFF
16347: ST_TO_ADDR
16348: GO 16307
16350: POP
16351: POP
// end ;
16352: LD_VAR 0 4
16356: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
16357: LD_INT 0
16359: PPUSH
16360: PPUSH
16361: PPUSH
// result := true ;
16362: LD_ADDR_VAR 0 3
16366: PUSH
16367: LD_INT 1
16369: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
16370: LD_ADDR_VAR 0 5
16374: PUSH
16375: LD_VAR 0 2
16379: PPUSH
16380: CALL_OW 480
16384: ST_TO_ADDR
// if not tmp then
16385: LD_VAR 0 5
16389: NOT
16390: IFFALSE 16394
// exit ;
16392: GO 16443
// for i in tmp do
16394: LD_ADDR_VAR 0 4
16398: PUSH
16399: LD_VAR 0 5
16403: PUSH
16404: FOR_IN
16405: IFFALSE 16441
// if GetTech ( i , side ) <> state_researched then
16407: LD_VAR 0 4
16411: PPUSH
16412: LD_VAR 0 1
16416: PPUSH
16417: CALL_OW 321
16421: PUSH
16422: LD_INT 2
16424: NONEQUAL
16425: IFFALSE 16439
// begin result := false ;
16427: LD_ADDR_VAR 0 3
16431: PUSH
16432: LD_INT 0
16434: ST_TO_ADDR
// exit ;
16435: POP
16436: POP
16437: GO 16443
// end ;
16439: GO 16404
16441: POP
16442: POP
// end ;
16443: LD_VAR 0 3
16447: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
16448: LD_INT 0
16450: PPUSH
16451: PPUSH
16452: PPUSH
16453: PPUSH
16454: PPUSH
16455: PPUSH
16456: PPUSH
16457: PPUSH
16458: PPUSH
16459: PPUSH
16460: PPUSH
16461: PPUSH
16462: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
16463: LD_VAR 0 1
16467: NOT
16468: PUSH
16469: LD_VAR 0 1
16473: PPUSH
16474: CALL_OW 257
16478: PUSH
16479: LD_INT 9
16481: NONEQUAL
16482: OR
16483: IFFALSE 16487
// exit ;
16485: GO 17060
// side := GetSide ( unit ) ;
16487: LD_ADDR_VAR 0 9
16491: PUSH
16492: LD_VAR 0 1
16496: PPUSH
16497: CALL_OW 255
16501: ST_TO_ADDR
// tech_space := tech_spacanom ;
16502: LD_ADDR_VAR 0 12
16506: PUSH
16507: LD_INT 29
16509: ST_TO_ADDR
// tech_time := tech_taurad ;
16510: LD_ADDR_VAR 0 13
16514: PUSH
16515: LD_INT 28
16517: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
16518: LD_ADDR_VAR 0 11
16522: PUSH
16523: LD_VAR 0 1
16527: PPUSH
16528: CALL_OW 310
16532: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
16533: LD_VAR 0 11
16537: PPUSH
16538: CALL_OW 247
16542: PUSH
16543: LD_INT 2
16545: EQUAL
16546: IFFALSE 16550
// exit ;
16548: GO 17060
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16550: LD_ADDR_VAR 0 8
16554: PUSH
16555: LD_INT 81
16557: PUSH
16558: LD_VAR 0 9
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: PUSH
16567: LD_INT 3
16569: PUSH
16570: LD_INT 21
16572: PUSH
16573: LD_INT 3
16575: PUSH
16576: EMPTY
16577: LIST
16578: LIST
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: EMPTY
16585: LIST
16586: LIST
16587: PPUSH
16588: CALL_OW 69
16592: ST_TO_ADDR
// if not tmp then
16593: LD_VAR 0 8
16597: NOT
16598: IFFALSE 16602
// exit ;
16600: GO 17060
// if in_unit then
16602: LD_VAR 0 11
16606: IFFALSE 16630
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
16608: LD_ADDR_VAR 0 10
16612: PUSH
16613: LD_VAR 0 8
16617: PPUSH
16618: LD_VAR 0 11
16622: PPUSH
16623: CALL_OW 74
16627: ST_TO_ADDR
16628: GO 16650
// enemy := NearestUnitToUnit ( tmp , unit ) ;
16630: LD_ADDR_VAR 0 10
16634: PUSH
16635: LD_VAR 0 8
16639: PPUSH
16640: LD_VAR 0 1
16644: PPUSH
16645: CALL_OW 74
16649: ST_TO_ADDR
// if not enemy then
16650: LD_VAR 0 10
16654: NOT
16655: IFFALSE 16659
// exit ;
16657: GO 17060
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
16659: LD_VAR 0 11
16663: PUSH
16664: LD_VAR 0 11
16668: PPUSH
16669: LD_VAR 0 10
16673: PPUSH
16674: CALL_OW 296
16678: PUSH
16679: LD_INT 13
16681: GREATER
16682: AND
16683: PUSH
16684: LD_VAR 0 1
16688: PPUSH
16689: LD_VAR 0 10
16693: PPUSH
16694: CALL_OW 296
16698: PUSH
16699: LD_INT 12
16701: GREATER
16702: OR
16703: IFFALSE 16707
// exit ;
16705: GO 17060
// missile := [ 1 ] ;
16707: LD_ADDR_VAR 0 14
16711: PUSH
16712: LD_INT 1
16714: PUSH
16715: EMPTY
16716: LIST
16717: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16718: LD_VAR 0 9
16722: PPUSH
16723: LD_VAR 0 12
16727: PPUSH
16728: CALL_OW 325
16732: IFFALSE 16761
// missile := Replace ( missile , missile + 1 , 2 ) ;
16734: LD_ADDR_VAR 0 14
16738: PUSH
16739: LD_VAR 0 14
16743: PPUSH
16744: LD_VAR 0 14
16748: PUSH
16749: LD_INT 1
16751: PLUS
16752: PPUSH
16753: LD_INT 2
16755: PPUSH
16756: CALL_OW 1
16760: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16761: LD_VAR 0 9
16765: PPUSH
16766: LD_VAR 0 13
16770: PPUSH
16771: CALL_OW 325
16775: PUSH
16776: LD_VAR 0 10
16780: PPUSH
16781: CALL_OW 255
16785: PPUSH
16786: LD_VAR 0 13
16790: PPUSH
16791: CALL_OW 325
16795: NOT
16796: AND
16797: IFFALSE 16826
// missile := Replace ( missile , missile + 1 , 3 ) ;
16799: LD_ADDR_VAR 0 14
16803: PUSH
16804: LD_VAR 0 14
16808: PPUSH
16809: LD_VAR 0 14
16813: PUSH
16814: LD_INT 1
16816: PLUS
16817: PPUSH
16818: LD_INT 3
16820: PPUSH
16821: CALL_OW 1
16825: ST_TO_ADDR
// if missile < 2 then
16826: LD_VAR 0 14
16830: PUSH
16831: LD_INT 2
16833: LESS
16834: IFFALSE 16838
// exit ;
16836: GO 17060
// x := GetX ( enemy ) ;
16838: LD_ADDR_VAR 0 4
16842: PUSH
16843: LD_VAR 0 10
16847: PPUSH
16848: CALL_OW 250
16852: ST_TO_ADDR
// y := GetY ( enemy ) ;
16853: LD_ADDR_VAR 0 5
16857: PUSH
16858: LD_VAR 0 10
16862: PPUSH
16863: CALL_OW 251
16867: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16868: LD_ADDR_VAR 0 6
16872: PUSH
16873: LD_VAR 0 4
16877: PUSH
16878: LD_INT 1
16880: NEG
16881: PPUSH
16882: LD_INT 1
16884: PPUSH
16885: CALL_OW 12
16889: PLUS
16890: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16891: LD_ADDR_VAR 0 7
16895: PUSH
16896: LD_VAR 0 5
16900: PUSH
16901: LD_INT 1
16903: NEG
16904: PPUSH
16905: LD_INT 1
16907: PPUSH
16908: CALL_OW 12
16912: PLUS
16913: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16914: LD_VAR 0 6
16918: PPUSH
16919: LD_VAR 0 7
16923: PPUSH
16924: CALL_OW 488
16928: NOT
16929: IFFALSE 16951
// begin _x := x ;
16931: LD_ADDR_VAR 0 6
16935: PUSH
16936: LD_VAR 0 4
16940: ST_TO_ADDR
// _y := y ;
16941: LD_ADDR_VAR 0 7
16945: PUSH
16946: LD_VAR 0 5
16950: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16951: LD_ADDR_VAR 0 3
16955: PUSH
16956: LD_INT 1
16958: PPUSH
16959: LD_VAR 0 14
16963: PPUSH
16964: CALL_OW 12
16968: ST_TO_ADDR
// case i of 1 :
16969: LD_VAR 0 3
16973: PUSH
16974: LD_INT 1
16976: DOUBLE
16977: EQUAL
16978: IFTRUE 16982
16980: GO 16999
16982: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16983: LD_VAR 0 1
16987: PPUSH
16988: LD_VAR 0 10
16992: PPUSH
16993: CALL_OW 115
16997: GO 17060
16999: LD_INT 2
17001: DOUBLE
17002: EQUAL
17003: IFTRUE 17007
17005: GO 17029
17007: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
17008: LD_VAR 0 1
17012: PPUSH
17013: LD_VAR 0 6
17017: PPUSH
17018: LD_VAR 0 7
17022: PPUSH
17023: CALL_OW 153
17027: GO 17060
17029: LD_INT 3
17031: DOUBLE
17032: EQUAL
17033: IFTRUE 17037
17035: GO 17059
17037: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
17038: LD_VAR 0 1
17042: PPUSH
17043: LD_VAR 0 6
17047: PPUSH
17048: LD_VAR 0 7
17052: PPUSH
17053: CALL_OW 154
17057: GO 17060
17059: POP
// end ;
17060: LD_VAR 0 2
17064: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
17065: LD_INT 0
17067: PPUSH
17068: PPUSH
17069: PPUSH
17070: PPUSH
17071: PPUSH
17072: PPUSH
// if not unit or not building then
17073: LD_VAR 0 1
17077: NOT
17078: PUSH
17079: LD_VAR 0 2
17083: NOT
17084: OR
17085: IFFALSE 17089
// exit ;
17087: GO 17247
// x := GetX ( building ) ;
17089: LD_ADDR_VAR 0 5
17093: PUSH
17094: LD_VAR 0 2
17098: PPUSH
17099: CALL_OW 250
17103: ST_TO_ADDR
// y := GetY ( building ) ;
17104: LD_ADDR_VAR 0 6
17108: PUSH
17109: LD_VAR 0 2
17113: PPUSH
17114: CALL_OW 251
17118: ST_TO_ADDR
// for i = 0 to 5 do
17119: LD_ADDR_VAR 0 4
17123: PUSH
17124: DOUBLE
17125: LD_INT 0
17127: DEC
17128: ST_TO_ADDR
17129: LD_INT 5
17131: PUSH
17132: FOR_TO
17133: IFFALSE 17245
// begin _x := ShiftX ( x , i , 3 ) ;
17135: LD_ADDR_VAR 0 7
17139: PUSH
17140: LD_VAR 0 5
17144: PPUSH
17145: LD_VAR 0 4
17149: PPUSH
17150: LD_INT 3
17152: PPUSH
17153: CALL_OW 272
17157: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
17158: LD_ADDR_VAR 0 8
17162: PUSH
17163: LD_VAR 0 6
17167: PPUSH
17168: LD_VAR 0 4
17172: PPUSH
17173: LD_INT 3
17175: PPUSH
17176: CALL_OW 273
17180: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17181: LD_VAR 0 7
17185: PPUSH
17186: LD_VAR 0 8
17190: PPUSH
17191: CALL_OW 488
17195: NOT
17196: IFFALSE 17200
// continue ;
17198: GO 17132
// if HexInfo ( _x , _y ) = 0 then
17200: LD_VAR 0 7
17204: PPUSH
17205: LD_VAR 0 8
17209: PPUSH
17210: CALL_OW 428
17214: PUSH
17215: LD_INT 0
17217: EQUAL
17218: IFFALSE 17243
// begin ComMoveXY ( unit , _x , _y ) ;
17220: LD_VAR 0 1
17224: PPUSH
17225: LD_VAR 0 7
17229: PPUSH
17230: LD_VAR 0 8
17234: PPUSH
17235: CALL_OW 111
// exit ;
17239: POP
17240: POP
17241: GO 17247
// end ; end ;
17243: GO 17132
17245: POP
17246: POP
// end ;
17247: LD_VAR 0 3
17251: RET
// export function ScanBase ( side , base_area ) ; begin
17252: LD_INT 0
17254: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
17255: LD_ADDR_VAR 0 3
17259: PUSH
17260: LD_VAR 0 2
17264: PPUSH
17265: LD_INT 81
17267: PUSH
17268: LD_VAR 0 1
17272: PUSH
17273: EMPTY
17274: LIST
17275: LIST
17276: PPUSH
17277: CALL_OW 70
17281: ST_TO_ADDR
// end ;
17282: LD_VAR 0 3
17286: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17287: LD_INT 0
17289: PPUSH
17290: PPUSH
17291: PPUSH
17292: PPUSH
// result := false ;
17293: LD_ADDR_VAR 0 2
17297: PUSH
17298: LD_INT 0
17300: ST_TO_ADDR
// side := GetSide ( unit ) ;
17301: LD_ADDR_VAR 0 3
17305: PUSH
17306: LD_VAR 0 1
17310: PPUSH
17311: CALL_OW 255
17315: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17316: LD_ADDR_VAR 0 4
17320: PUSH
17321: LD_VAR 0 1
17325: PPUSH
17326: CALL_OW 248
17330: ST_TO_ADDR
// case nat of 1 :
17331: LD_VAR 0 4
17335: PUSH
17336: LD_INT 1
17338: DOUBLE
17339: EQUAL
17340: IFTRUE 17344
17342: GO 17355
17344: POP
// tech := tech_lassight ; 2 :
17345: LD_ADDR_VAR 0 5
17349: PUSH
17350: LD_INT 12
17352: ST_TO_ADDR
17353: GO 17394
17355: LD_INT 2
17357: DOUBLE
17358: EQUAL
17359: IFTRUE 17363
17361: GO 17374
17363: POP
// tech := tech_mortar ; 3 :
17364: LD_ADDR_VAR 0 5
17368: PUSH
17369: LD_INT 41
17371: ST_TO_ADDR
17372: GO 17394
17374: LD_INT 3
17376: DOUBLE
17377: EQUAL
17378: IFTRUE 17382
17380: GO 17393
17382: POP
// tech := tech_bazooka ; end ;
17383: LD_ADDR_VAR 0 5
17387: PUSH
17388: LD_INT 44
17390: ST_TO_ADDR
17391: GO 17394
17393: POP
// if Researched ( side , tech ) then
17394: LD_VAR 0 3
17398: PPUSH
17399: LD_VAR 0 5
17403: PPUSH
17404: CALL_OW 325
17408: IFFALSE 17435
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17410: LD_ADDR_VAR 0 2
17414: PUSH
17415: LD_INT 5
17417: PUSH
17418: LD_INT 8
17420: PUSH
17421: LD_INT 9
17423: PUSH
17424: EMPTY
17425: LIST
17426: LIST
17427: LIST
17428: PUSH
17429: LD_VAR 0 4
17433: ARRAY
17434: ST_TO_ADDR
// end ;
17435: LD_VAR 0 2
17439: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17440: LD_INT 0
17442: PPUSH
17443: PPUSH
17444: PPUSH
// if not mines then
17445: LD_VAR 0 2
17449: NOT
17450: IFFALSE 17454
// exit ;
17452: GO 17598
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17454: LD_ADDR_VAR 0 5
17458: PUSH
17459: LD_INT 81
17461: PUSH
17462: LD_VAR 0 1
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: PUSH
17471: LD_INT 3
17473: PUSH
17474: LD_INT 21
17476: PUSH
17477: LD_INT 3
17479: PUSH
17480: EMPTY
17481: LIST
17482: LIST
17483: PUSH
17484: EMPTY
17485: LIST
17486: LIST
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PPUSH
17492: CALL_OW 69
17496: ST_TO_ADDR
// for i in mines do
17497: LD_ADDR_VAR 0 4
17501: PUSH
17502: LD_VAR 0 2
17506: PUSH
17507: FOR_IN
17508: IFFALSE 17596
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17510: LD_VAR 0 4
17514: PUSH
17515: LD_INT 1
17517: ARRAY
17518: PPUSH
17519: LD_VAR 0 4
17523: PUSH
17524: LD_INT 2
17526: ARRAY
17527: PPUSH
17528: CALL_OW 458
17532: NOT
17533: IFFALSE 17537
// continue ;
17535: GO 17507
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17537: LD_VAR 0 4
17541: PUSH
17542: LD_INT 1
17544: ARRAY
17545: PPUSH
17546: LD_VAR 0 4
17550: PUSH
17551: LD_INT 2
17553: ARRAY
17554: PPUSH
17555: CALL_OW 428
17559: PUSH
17560: LD_VAR 0 5
17564: IN
17565: IFFALSE 17594
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17567: LD_VAR 0 4
17571: PUSH
17572: LD_INT 1
17574: ARRAY
17575: PPUSH
17576: LD_VAR 0 4
17580: PUSH
17581: LD_INT 2
17583: ARRAY
17584: PPUSH
17585: LD_VAR 0 1
17589: PPUSH
17590: CALL_OW 456
// end ;
17594: GO 17507
17596: POP
17597: POP
// end ;
17598: LD_VAR 0 3
17602: RET
// export function Count ( array ) ; begin
17603: LD_INT 0
17605: PPUSH
// result := array + 0 ;
17606: LD_ADDR_VAR 0 2
17610: PUSH
17611: LD_VAR 0 1
17615: PUSH
17616: LD_INT 0
17618: PLUS
17619: ST_TO_ADDR
// end ;
17620: LD_VAR 0 2
17624: RET
// export function IsEmpty ( building ) ; begin
17625: LD_INT 0
17627: PPUSH
// if not building then
17628: LD_VAR 0 1
17632: NOT
17633: IFFALSE 17637
// exit ;
17635: GO 17680
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17637: LD_ADDR_VAR 0 2
17641: PUSH
17642: LD_VAR 0 1
17646: PUSH
17647: LD_INT 22
17649: PUSH
17650: LD_VAR 0 1
17654: PPUSH
17655: CALL_OW 255
17659: PUSH
17660: EMPTY
17661: LIST
17662: LIST
17663: PUSH
17664: LD_INT 58
17666: PUSH
17667: EMPTY
17668: LIST
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: PPUSH
17674: CALL_OW 69
17678: IN
17679: ST_TO_ADDR
// end ;
17680: LD_VAR 0 2
17684: RET
// export function IsNotFull ( building ) ; var places ; begin
17685: LD_INT 0
17687: PPUSH
17688: PPUSH
// if not building then
17689: LD_VAR 0 1
17693: NOT
17694: IFFALSE 17698
// exit ;
17696: GO 17726
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
17698: LD_ADDR_VAR 0 2
17702: PUSH
17703: LD_VAR 0 1
17707: PPUSH
17708: LD_INT 3
17710: PUSH
17711: LD_INT 62
17713: PUSH
17714: EMPTY
17715: LIST
17716: PUSH
17717: EMPTY
17718: LIST
17719: LIST
17720: PPUSH
17721: CALL_OW 72
17725: ST_TO_ADDR
// end ;
17726: LD_VAR 0 2
17730: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17731: LD_INT 0
17733: PPUSH
17734: PPUSH
17735: PPUSH
17736: PPUSH
// tmp := [ ] ;
17737: LD_ADDR_VAR 0 3
17741: PUSH
17742: EMPTY
17743: ST_TO_ADDR
// list := [ ] ;
17744: LD_ADDR_VAR 0 5
17748: PUSH
17749: EMPTY
17750: ST_TO_ADDR
// for i = 16 to 25 do
17751: LD_ADDR_VAR 0 4
17755: PUSH
17756: DOUBLE
17757: LD_INT 16
17759: DEC
17760: ST_TO_ADDR
17761: LD_INT 25
17763: PUSH
17764: FOR_TO
17765: IFFALSE 17838
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17767: LD_ADDR_VAR 0 3
17771: PUSH
17772: LD_VAR 0 3
17776: PUSH
17777: LD_INT 22
17779: PUSH
17780: LD_VAR 0 1
17784: PPUSH
17785: CALL_OW 255
17789: PUSH
17790: EMPTY
17791: LIST
17792: LIST
17793: PUSH
17794: LD_INT 91
17796: PUSH
17797: LD_VAR 0 1
17801: PUSH
17802: LD_INT 6
17804: PUSH
17805: EMPTY
17806: LIST
17807: LIST
17808: LIST
17809: PUSH
17810: LD_INT 30
17812: PUSH
17813: LD_VAR 0 4
17817: PUSH
17818: EMPTY
17819: LIST
17820: LIST
17821: PUSH
17822: EMPTY
17823: LIST
17824: LIST
17825: LIST
17826: PUSH
17827: EMPTY
17828: LIST
17829: PPUSH
17830: CALL_OW 69
17834: ADD
17835: ST_TO_ADDR
17836: GO 17764
17838: POP
17839: POP
// for i = 1 to tmp do
17840: LD_ADDR_VAR 0 4
17844: PUSH
17845: DOUBLE
17846: LD_INT 1
17848: DEC
17849: ST_TO_ADDR
17850: LD_VAR 0 3
17854: PUSH
17855: FOR_TO
17856: IFFALSE 17944
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17858: LD_ADDR_VAR 0 5
17862: PUSH
17863: LD_VAR 0 5
17867: PUSH
17868: LD_VAR 0 3
17872: PUSH
17873: LD_VAR 0 4
17877: ARRAY
17878: PPUSH
17879: CALL_OW 266
17883: PUSH
17884: LD_VAR 0 3
17888: PUSH
17889: LD_VAR 0 4
17893: ARRAY
17894: PPUSH
17895: CALL_OW 250
17899: PUSH
17900: LD_VAR 0 3
17904: PUSH
17905: LD_VAR 0 4
17909: ARRAY
17910: PPUSH
17911: CALL_OW 251
17915: PUSH
17916: LD_VAR 0 3
17920: PUSH
17921: LD_VAR 0 4
17925: ARRAY
17926: PPUSH
17927: CALL_OW 254
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: LIST
17936: LIST
17937: PUSH
17938: EMPTY
17939: LIST
17940: ADD
17941: ST_TO_ADDR
17942: GO 17855
17944: POP
17945: POP
// result := list ;
17946: LD_ADDR_VAR 0 2
17950: PUSH
17951: LD_VAR 0 5
17955: ST_TO_ADDR
// end ;
17956: LD_VAR 0 2
17960: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17961: LD_INT 0
17963: PPUSH
17964: PPUSH
17965: PPUSH
17966: PPUSH
17967: PPUSH
17968: PPUSH
17969: PPUSH
// if not factory then
17970: LD_VAR 0 1
17974: NOT
17975: IFFALSE 17979
// exit ;
17977: GO 18572
// if control = control_apeman then
17979: LD_VAR 0 4
17983: PUSH
17984: LD_INT 5
17986: EQUAL
17987: IFFALSE 18096
// begin tmp := UnitsInside ( factory ) ;
17989: LD_ADDR_VAR 0 8
17993: PUSH
17994: LD_VAR 0 1
17998: PPUSH
17999: CALL_OW 313
18003: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18004: LD_VAR 0 8
18008: PPUSH
18009: LD_INT 25
18011: PUSH
18012: LD_INT 12
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: PPUSH
18019: CALL_OW 72
18023: NOT
18024: IFFALSE 18034
// control := control_manual ;
18026: LD_ADDR_VAR 0 4
18030: PUSH
18031: LD_INT 1
18033: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18034: LD_ADDR_VAR 0 8
18038: PUSH
18039: LD_VAR 0 1
18043: PPUSH
18044: CALL 17731 0 1
18048: ST_TO_ADDR
// if tmp then
18049: LD_VAR 0 8
18053: IFFALSE 18096
// begin for i in tmp do
18055: LD_ADDR_VAR 0 7
18059: PUSH
18060: LD_VAR 0 8
18064: PUSH
18065: FOR_IN
18066: IFFALSE 18094
// if i [ 1 ] = b_ext_radio then
18068: LD_VAR 0 7
18072: PUSH
18073: LD_INT 1
18075: ARRAY
18076: PUSH
18077: LD_INT 22
18079: EQUAL
18080: IFFALSE 18092
// begin control := control_remote ;
18082: LD_ADDR_VAR 0 4
18086: PUSH
18087: LD_INT 2
18089: ST_TO_ADDR
// break ;
18090: GO 18094
// end ;
18092: GO 18065
18094: POP
18095: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18096: LD_VAR 0 1
18100: PPUSH
18101: LD_VAR 0 2
18105: PPUSH
18106: LD_VAR 0 3
18110: PPUSH
18111: LD_VAR 0 4
18115: PPUSH
18116: LD_VAR 0 5
18120: PPUSH
18121: CALL_OW 448
18125: IFFALSE 18160
// begin result := [ chassis , engine , control , weapon ] ;
18127: LD_ADDR_VAR 0 6
18131: PUSH
18132: LD_VAR 0 2
18136: PUSH
18137: LD_VAR 0 3
18141: PUSH
18142: LD_VAR 0 4
18146: PUSH
18147: LD_VAR 0 5
18151: PUSH
18152: EMPTY
18153: LIST
18154: LIST
18155: LIST
18156: LIST
18157: ST_TO_ADDR
// exit ;
18158: GO 18572
// end ; _chassis := AvailableChassisList ( factory ) ;
18160: LD_ADDR_VAR 0 9
18164: PUSH
18165: LD_VAR 0 1
18169: PPUSH
18170: CALL_OW 475
18174: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18175: LD_ADDR_VAR 0 11
18179: PUSH
18180: LD_VAR 0 1
18184: PPUSH
18185: CALL_OW 476
18189: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18190: LD_ADDR_VAR 0 12
18194: PUSH
18195: LD_VAR 0 1
18199: PPUSH
18200: CALL_OW 477
18204: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18205: LD_ADDR_VAR 0 10
18209: PUSH
18210: LD_VAR 0 1
18214: PPUSH
18215: CALL_OW 478
18219: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
18220: LD_VAR 0 9
18224: NOT
18225: PUSH
18226: LD_VAR 0 11
18230: NOT
18231: OR
18232: PUSH
18233: LD_VAR 0 12
18237: NOT
18238: OR
18239: PUSH
18240: LD_VAR 0 10
18244: NOT
18245: OR
18246: IFFALSE 18281
// begin result := [ chassis , engine , control , weapon ] ;
18248: LD_ADDR_VAR 0 6
18252: PUSH
18253: LD_VAR 0 2
18257: PUSH
18258: LD_VAR 0 3
18262: PUSH
18263: LD_VAR 0 4
18267: PUSH
18268: LD_VAR 0 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: ST_TO_ADDR
// exit ;
18279: GO 18572
// end ; if not chassis in _chassis then
18281: LD_VAR 0 2
18285: PUSH
18286: LD_VAR 0 9
18290: IN
18291: NOT
18292: IFFALSE 18318
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18294: LD_ADDR_VAR 0 2
18298: PUSH
18299: LD_VAR 0 9
18303: PUSH
18304: LD_INT 1
18306: PPUSH
18307: LD_VAR 0 9
18311: PPUSH
18312: CALL_OW 12
18316: ARRAY
18317: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18318: LD_VAR 0 2
18322: PPUSH
18323: LD_VAR 0 3
18327: PPUSH
18328: CALL 18577 0 2
18332: NOT
18333: IFFALSE 18392
// repeat engine := _engine [ 1 ] ;
18335: LD_ADDR_VAR 0 3
18339: PUSH
18340: LD_VAR 0 11
18344: PUSH
18345: LD_INT 1
18347: ARRAY
18348: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18349: LD_ADDR_VAR 0 11
18353: PUSH
18354: LD_VAR 0 11
18358: PPUSH
18359: LD_INT 1
18361: PPUSH
18362: CALL_OW 3
18366: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18367: LD_VAR 0 2
18371: PPUSH
18372: LD_VAR 0 3
18376: PPUSH
18377: CALL 18577 0 2
18381: PUSH
18382: LD_VAR 0 11
18386: PUSH
18387: EMPTY
18388: EQUAL
18389: OR
18390: IFFALSE 18335
// if not control in _control then
18392: LD_VAR 0 4
18396: PUSH
18397: LD_VAR 0 12
18401: IN
18402: NOT
18403: IFFALSE 18429
// control := _control [ rand ( 1 , _control ) ] ;
18405: LD_ADDR_VAR 0 4
18409: PUSH
18410: LD_VAR 0 12
18414: PUSH
18415: LD_INT 1
18417: PPUSH
18418: LD_VAR 0 12
18422: PPUSH
18423: CALL_OW 12
18427: ARRAY
18428: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18429: LD_VAR 0 2
18433: PPUSH
18434: LD_VAR 0 5
18438: PPUSH
18439: CALL 18797 0 2
18443: NOT
18444: IFFALSE 18503
// repeat weapon := _weapon [ 1 ] ;
18446: LD_ADDR_VAR 0 5
18450: PUSH
18451: LD_VAR 0 10
18455: PUSH
18456: LD_INT 1
18458: ARRAY
18459: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18460: LD_ADDR_VAR 0 10
18464: PUSH
18465: LD_VAR 0 10
18469: PPUSH
18470: LD_INT 1
18472: PPUSH
18473: CALL_OW 3
18477: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18478: LD_VAR 0 2
18482: PPUSH
18483: LD_VAR 0 5
18487: PPUSH
18488: CALL 18797 0 2
18492: PUSH
18493: LD_VAR 0 10
18497: PUSH
18498: EMPTY
18499: EQUAL
18500: OR
18501: IFFALSE 18446
// result := [ ] ;
18503: LD_ADDR_VAR 0 6
18507: PUSH
18508: EMPTY
18509: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18510: LD_VAR 0 1
18514: PPUSH
18515: LD_VAR 0 2
18519: PPUSH
18520: LD_VAR 0 3
18524: PPUSH
18525: LD_VAR 0 4
18529: PPUSH
18530: LD_VAR 0 5
18534: PPUSH
18535: CALL_OW 448
18539: IFFALSE 18572
// result := [ chassis , engine , control , weapon ] ;
18541: LD_ADDR_VAR 0 6
18545: PUSH
18546: LD_VAR 0 2
18550: PUSH
18551: LD_VAR 0 3
18555: PUSH
18556: LD_VAR 0 4
18560: PUSH
18561: LD_VAR 0 5
18565: PUSH
18566: EMPTY
18567: LIST
18568: LIST
18569: LIST
18570: LIST
18571: ST_TO_ADDR
// end ;
18572: LD_VAR 0 6
18576: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18577: LD_INT 0
18579: PPUSH
// if not chassis or not engine then
18580: LD_VAR 0 1
18584: NOT
18585: PUSH
18586: LD_VAR 0 2
18590: NOT
18591: OR
18592: IFFALSE 18596
// exit ;
18594: GO 18792
// case engine of engine_solar :
18596: LD_VAR 0 2
18600: PUSH
18601: LD_INT 2
18603: DOUBLE
18604: EQUAL
18605: IFTRUE 18609
18607: GO 18647
18609: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18610: LD_ADDR_VAR 0 3
18614: PUSH
18615: LD_INT 11
18617: PUSH
18618: LD_INT 12
18620: PUSH
18621: LD_INT 13
18623: PUSH
18624: LD_INT 14
18626: PUSH
18627: LD_INT 1
18629: PUSH
18630: LD_INT 2
18632: PUSH
18633: LD_INT 3
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: LIST
18640: LIST
18641: LIST
18642: LIST
18643: LIST
18644: ST_TO_ADDR
18645: GO 18776
18647: LD_INT 1
18649: DOUBLE
18650: EQUAL
18651: IFTRUE 18655
18653: GO 18717
18655: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18656: LD_ADDR_VAR 0 3
18660: PUSH
18661: LD_INT 11
18663: PUSH
18664: LD_INT 12
18666: PUSH
18667: LD_INT 13
18669: PUSH
18670: LD_INT 14
18672: PUSH
18673: LD_INT 1
18675: PUSH
18676: LD_INT 2
18678: PUSH
18679: LD_INT 3
18681: PUSH
18682: LD_INT 4
18684: PUSH
18685: LD_INT 5
18687: PUSH
18688: LD_INT 21
18690: PUSH
18691: LD_INT 23
18693: PUSH
18694: LD_INT 22
18696: PUSH
18697: LD_INT 24
18699: PUSH
18700: EMPTY
18701: LIST
18702: LIST
18703: LIST
18704: LIST
18705: LIST
18706: LIST
18707: LIST
18708: LIST
18709: LIST
18710: LIST
18711: LIST
18712: LIST
18713: LIST
18714: ST_TO_ADDR
18715: GO 18776
18717: LD_INT 3
18719: DOUBLE
18720: EQUAL
18721: IFTRUE 18725
18723: GO 18775
18725: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18726: LD_ADDR_VAR 0 3
18730: PUSH
18731: LD_INT 13
18733: PUSH
18734: LD_INT 14
18736: PUSH
18737: LD_INT 2
18739: PUSH
18740: LD_INT 3
18742: PUSH
18743: LD_INT 4
18745: PUSH
18746: LD_INT 5
18748: PUSH
18749: LD_INT 21
18751: PUSH
18752: LD_INT 22
18754: PUSH
18755: LD_INT 23
18757: PUSH
18758: LD_INT 24
18760: PUSH
18761: EMPTY
18762: LIST
18763: LIST
18764: LIST
18765: LIST
18766: LIST
18767: LIST
18768: LIST
18769: LIST
18770: LIST
18771: LIST
18772: ST_TO_ADDR
18773: GO 18776
18775: POP
// result := ( chassis in result ) ;
18776: LD_ADDR_VAR 0 3
18780: PUSH
18781: LD_VAR 0 1
18785: PUSH
18786: LD_VAR 0 3
18790: IN
18791: ST_TO_ADDR
// end ;
18792: LD_VAR 0 3
18796: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18797: LD_INT 0
18799: PPUSH
// if not chassis or not weapon then
18800: LD_VAR 0 1
18804: NOT
18805: PUSH
18806: LD_VAR 0 2
18810: NOT
18811: OR
18812: IFFALSE 18816
// exit ;
18814: GO 19876
// case weapon of us_machine_gun :
18816: LD_VAR 0 2
18820: PUSH
18821: LD_INT 2
18823: DOUBLE
18824: EQUAL
18825: IFTRUE 18829
18827: GO 18859
18829: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18830: LD_ADDR_VAR 0 3
18834: PUSH
18835: LD_INT 1
18837: PUSH
18838: LD_INT 2
18840: PUSH
18841: LD_INT 3
18843: PUSH
18844: LD_INT 4
18846: PUSH
18847: LD_INT 5
18849: PUSH
18850: EMPTY
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: LIST
18856: ST_TO_ADDR
18857: GO 19860
18859: LD_INT 3
18861: DOUBLE
18862: EQUAL
18863: IFTRUE 18867
18865: GO 18897
18867: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18868: LD_ADDR_VAR 0 3
18872: PUSH
18873: LD_INT 1
18875: PUSH
18876: LD_INT 2
18878: PUSH
18879: LD_INT 3
18881: PUSH
18882: LD_INT 4
18884: PUSH
18885: LD_INT 5
18887: PUSH
18888: EMPTY
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: LIST
18894: ST_TO_ADDR
18895: GO 19860
18897: LD_INT 11
18899: DOUBLE
18900: EQUAL
18901: IFTRUE 18905
18903: GO 18935
18905: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18906: LD_ADDR_VAR 0 3
18910: PUSH
18911: LD_INT 1
18913: PUSH
18914: LD_INT 2
18916: PUSH
18917: LD_INT 3
18919: PUSH
18920: LD_INT 4
18922: PUSH
18923: LD_INT 5
18925: PUSH
18926: EMPTY
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: LIST
18932: ST_TO_ADDR
18933: GO 19860
18935: LD_INT 4
18937: DOUBLE
18938: EQUAL
18939: IFTRUE 18943
18941: GO 18969
18943: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18944: LD_ADDR_VAR 0 3
18948: PUSH
18949: LD_INT 2
18951: PUSH
18952: LD_INT 3
18954: PUSH
18955: LD_INT 4
18957: PUSH
18958: LD_INT 5
18960: PUSH
18961: EMPTY
18962: LIST
18963: LIST
18964: LIST
18965: LIST
18966: ST_TO_ADDR
18967: GO 19860
18969: LD_INT 5
18971: DOUBLE
18972: EQUAL
18973: IFTRUE 18977
18975: GO 19003
18977: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18978: LD_ADDR_VAR 0 3
18982: PUSH
18983: LD_INT 2
18985: PUSH
18986: LD_INT 3
18988: PUSH
18989: LD_INT 4
18991: PUSH
18992: LD_INT 5
18994: PUSH
18995: EMPTY
18996: LIST
18997: LIST
18998: LIST
18999: LIST
19000: ST_TO_ADDR
19001: GO 19860
19003: LD_INT 9
19005: DOUBLE
19006: EQUAL
19007: IFTRUE 19011
19009: GO 19037
19011: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19012: LD_ADDR_VAR 0 3
19016: PUSH
19017: LD_INT 2
19019: PUSH
19020: LD_INT 3
19022: PUSH
19023: LD_INT 4
19025: PUSH
19026: LD_INT 5
19028: PUSH
19029: EMPTY
19030: LIST
19031: LIST
19032: LIST
19033: LIST
19034: ST_TO_ADDR
19035: GO 19860
19037: LD_INT 7
19039: DOUBLE
19040: EQUAL
19041: IFTRUE 19045
19043: GO 19071
19045: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19046: LD_ADDR_VAR 0 3
19050: PUSH
19051: LD_INT 2
19053: PUSH
19054: LD_INT 3
19056: PUSH
19057: LD_INT 4
19059: PUSH
19060: LD_INT 5
19062: PUSH
19063: EMPTY
19064: LIST
19065: LIST
19066: LIST
19067: LIST
19068: ST_TO_ADDR
19069: GO 19860
19071: LD_INT 12
19073: DOUBLE
19074: EQUAL
19075: IFTRUE 19079
19077: GO 19105
19079: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19080: LD_ADDR_VAR 0 3
19084: PUSH
19085: LD_INT 2
19087: PUSH
19088: LD_INT 3
19090: PUSH
19091: LD_INT 4
19093: PUSH
19094: LD_INT 5
19096: PUSH
19097: EMPTY
19098: LIST
19099: LIST
19100: LIST
19101: LIST
19102: ST_TO_ADDR
19103: GO 19860
19105: LD_INT 13
19107: DOUBLE
19108: EQUAL
19109: IFTRUE 19113
19111: GO 19139
19113: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19114: LD_ADDR_VAR 0 3
19118: PUSH
19119: LD_INT 2
19121: PUSH
19122: LD_INT 3
19124: PUSH
19125: LD_INT 4
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: LIST
19135: LIST
19136: ST_TO_ADDR
19137: GO 19860
19139: LD_INT 14
19141: DOUBLE
19142: EQUAL
19143: IFTRUE 19147
19145: GO 19165
19147: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19148: LD_ADDR_VAR 0 3
19152: PUSH
19153: LD_INT 4
19155: PUSH
19156: LD_INT 5
19158: PUSH
19159: EMPTY
19160: LIST
19161: LIST
19162: ST_TO_ADDR
19163: GO 19860
19165: LD_INT 6
19167: DOUBLE
19168: EQUAL
19169: IFTRUE 19173
19171: GO 19191
19173: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19174: LD_ADDR_VAR 0 3
19178: PUSH
19179: LD_INT 4
19181: PUSH
19182: LD_INT 5
19184: PUSH
19185: EMPTY
19186: LIST
19187: LIST
19188: ST_TO_ADDR
19189: GO 19860
19191: LD_INT 10
19193: DOUBLE
19194: EQUAL
19195: IFTRUE 19199
19197: GO 19217
19199: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19200: LD_ADDR_VAR 0 3
19204: PUSH
19205: LD_INT 4
19207: PUSH
19208: LD_INT 5
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: ST_TO_ADDR
19215: GO 19860
19217: LD_INT 22
19219: DOUBLE
19220: EQUAL
19221: IFTRUE 19225
19223: GO 19251
19225: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19226: LD_ADDR_VAR 0 3
19230: PUSH
19231: LD_INT 11
19233: PUSH
19234: LD_INT 12
19236: PUSH
19237: LD_INT 13
19239: PUSH
19240: LD_INT 14
19242: PUSH
19243: EMPTY
19244: LIST
19245: LIST
19246: LIST
19247: LIST
19248: ST_TO_ADDR
19249: GO 19860
19251: LD_INT 23
19253: DOUBLE
19254: EQUAL
19255: IFTRUE 19259
19257: GO 19285
19259: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19260: LD_ADDR_VAR 0 3
19264: PUSH
19265: LD_INT 11
19267: PUSH
19268: LD_INT 12
19270: PUSH
19271: LD_INT 13
19273: PUSH
19274: LD_INT 14
19276: PUSH
19277: EMPTY
19278: LIST
19279: LIST
19280: LIST
19281: LIST
19282: ST_TO_ADDR
19283: GO 19860
19285: LD_INT 24
19287: DOUBLE
19288: EQUAL
19289: IFTRUE 19293
19291: GO 19319
19293: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19294: LD_ADDR_VAR 0 3
19298: PUSH
19299: LD_INT 11
19301: PUSH
19302: LD_INT 12
19304: PUSH
19305: LD_INT 13
19307: PUSH
19308: LD_INT 14
19310: PUSH
19311: EMPTY
19312: LIST
19313: LIST
19314: LIST
19315: LIST
19316: ST_TO_ADDR
19317: GO 19860
19319: LD_INT 30
19321: DOUBLE
19322: EQUAL
19323: IFTRUE 19327
19325: GO 19353
19327: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19328: LD_ADDR_VAR 0 3
19332: PUSH
19333: LD_INT 11
19335: PUSH
19336: LD_INT 12
19338: PUSH
19339: LD_INT 13
19341: PUSH
19342: LD_INT 14
19344: PUSH
19345: EMPTY
19346: LIST
19347: LIST
19348: LIST
19349: LIST
19350: ST_TO_ADDR
19351: GO 19860
19353: LD_INT 25
19355: DOUBLE
19356: EQUAL
19357: IFTRUE 19361
19359: GO 19379
19361: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19362: LD_ADDR_VAR 0 3
19366: PUSH
19367: LD_INT 13
19369: PUSH
19370: LD_INT 14
19372: PUSH
19373: EMPTY
19374: LIST
19375: LIST
19376: ST_TO_ADDR
19377: GO 19860
19379: LD_INT 27
19381: DOUBLE
19382: EQUAL
19383: IFTRUE 19387
19385: GO 19405
19387: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
19388: LD_ADDR_VAR 0 3
19392: PUSH
19393: LD_INT 13
19395: PUSH
19396: LD_INT 14
19398: PUSH
19399: EMPTY
19400: LIST
19401: LIST
19402: ST_TO_ADDR
19403: GO 19860
19405: LD_INT 92
19407: DOUBLE
19408: EQUAL
19409: IFTRUE 19413
19411: GO 19439
19413: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19414: LD_ADDR_VAR 0 3
19418: PUSH
19419: LD_INT 11
19421: PUSH
19422: LD_INT 12
19424: PUSH
19425: LD_INT 13
19427: PUSH
19428: LD_INT 14
19430: PUSH
19431: EMPTY
19432: LIST
19433: LIST
19434: LIST
19435: LIST
19436: ST_TO_ADDR
19437: GO 19860
19439: LD_INT 28
19441: DOUBLE
19442: EQUAL
19443: IFTRUE 19447
19445: GO 19465
19447: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19448: LD_ADDR_VAR 0 3
19452: PUSH
19453: LD_INT 13
19455: PUSH
19456: LD_INT 14
19458: PUSH
19459: EMPTY
19460: LIST
19461: LIST
19462: ST_TO_ADDR
19463: GO 19860
19465: LD_INT 29
19467: DOUBLE
19468: EQUAL
19469: IFTRUE 19473
19471: GO 19491
19473: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19474: LD_ADDR_VAR 0 3
19478: PUSH
19479: LD_INT 13
19481: PUSH
19482: LD_INT 14
19484: PUSH
19485: EMPTY
19486: LIST
19487: LIST
19488: ST_TO_ADDR
19489: GO 19860
19491: LD_INT 31
19493: DOUBLE
19494: EQUAL
19495: IFTRUE 19499
19497: GO 19517
19499: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19500: LD_ADDR_VAR 0 3
19504: PUSH
19505: LD_INT 13
19507: PUSH
19508: LD_INT 14
19510: PUSH
19511: EMPTY
19512: LIST
19513: LIST
19514: ST_TO_ADDR
19515: GO 19860
19517: LD_INT 26
19519: DOUBLE
19520: EQUAL
19521: IFTRUE 19525
19523: GO 19543
19525: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19526: LD_ADDR_VAR 0 3
19530: PUSH
19531: LD_INT 13
19533: PUSH
19534: LD_INT 14
19536: PUSH
19537: EMPTY
19538: LIST
19539: LIST
19540: ST_TO_ADDR
19541: GO 19860
19543: LD_INT 42
19545: DOUBLE
19546: EQUAL
19547: IFTRUE 19551
19549: GO 19577
19551: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19552: LD_ADDR_VAR 0 3
19556: PUSH
19557: LD_INT 21
19559: PUSH
19560: LD_INT 22
19562: PUSH
19563: LD_INT 23
19565: PUSH
19566: LD_INT 24
19568: PUSH
19569: EMPTY
19570: LIST
19571: LIST
19572: LIST
19573: LIST
19574: ST_TO_ADDR
19575: GO 19860
19577: LD_INT 43
19579: DOUBLE
19580: EQUAL
19581: IFTRUE 19585
19583: GO 19611
19585: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19586: LD_ADDR_VAR 0 3
19590: PUSH
19591: LD_INT 21
19593: PUSH
19594: LD_INT 22
19596: PUSH
19597: LD_INT 23
19599: PUSH
19600: LD_INT 24
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: LIST
19607: LIST
19608: ST_TO_ADDR
19609: GO 19860
19611: LD_INT 44
19613: DOUBLE
19614: EQUAL
19615: IFTRUE 19619
19617: GO 19645
19619: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19620: LD_ADDR_VAR 0 3
19624: PUSH
19625: LD_INT 21
19627: PUSH
19628: LD_INT 22
19630: PUSH
19631: LD_INT 23
19633: PUSH
19634: LD_INT 24
19636: PUSH
19637: EMPTY
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: ST_TO_ADDR
19643: GO 19860
19645: LD_INT 45
19647: DOUBLE
19648: EQUAL
19649: IFTRUE 19653
19651: GO 19679
19653: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19654: LD_ADDR_VAR 0 3
19658: PUSH
19659: LD_INT 21
19661: PUSH
19662: LD_INT 22
19664: PUSH
19665: LD_INT 23
19667: PUSH
19668: LD_INT 24
19670: PUSH
19671: EMPTY
19672: LIST
19673: LIST
19674: LIST
19675: LIST
19676: ST_TO_ADDR
19677: GO 19860
19679: LD_INT 49
19681: DOUBLE
19682: EQUAL
19683: IFTRUE 19687
19685: GO 19713
19687: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19688: LD_ADDR_VAR 0 3
19692: PUSH
19693: LD_INT 21
19695: PUSH
19696: LD_INT 22
19698: PUSH
19699: LD_INT 23
19701: PUSH
19702: LD_INT 24
19704: PUSH
19705: EMPTY
19706: LIST
19707: LIST
19708: LIST
19709: LIST
19710: ST_TO_ADDR
19711: GO 19860
19713: LD_INT 51
19715: DOUBLE
19716: EQUAL
19717: IFTRUE 19721
19719: GO 19747
19721: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19722: LD_ADDR_VAR 0 3
19726: PUSH
19727: LD_INT 21
19729: PUSH
19730: LD_INT 22
19732: PUSH
19733: LD_INT 23
19735: PUSH
19736: LD_INT 24
19738: PUSH
19739: EMPTY
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: ST_TO_ADDR
19745: GO 19860
19747: LD_INT 52
19749: DOUBLE
19750: EQUAL
19751: IFTRUE 19755
19753: GO 19781
19755: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19756: LD_ADDR_VAR 0 3
19760: PUSH
19761: LD_INT 21
19763: PUSH
19764: LD_INT 22
19766: PUSH
19767: LD_INT 23
19769: PUSH
19770: LD_INT 24
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: LIST
19777: LIST
19778: ST_TO_ADDR
19779: GO 19860
19781: LD_INT 53
19783: DOUBLE
19784: EQUAL
19785: IFTRUE 19789
19787: GO 19807
19789: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19790: LD_ADDR_VAR 0 3
19794: PUSH
19795: LD_INT 23
19797: PUSH
19798: LD_INT 24
19800: PUSH
19801: EMPTY
19802: LIST
19803: LIST
19804: ST_TO_ADDR
19805: GO 19860
19807: LD_INT 46
19809: DOUBLE
19810: EQUAL
19811: IFTRUE 19815
19813: GO 19833
19815: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19816: LD_ADDR_VAR 0 3
19820: PUSH
19821: LD_INT 23
19823: PUSH
19824: LD_INT 24
19826: PUSH
19827: EMPTY
19828: LIST
19829: LIST
19830: ST_TO_ADDR
19831: GO 19860
19833: LD_INT 47
19835: DOUBLE
19836: EQUAL
19837: IFTRUE 19841
19839: GO 19859
19841: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19842: LD_ADDR_VAR 0 3
19846: PUSH
19847: LD_INT 23
19849: PUSH
19850: LD_INT 24
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: ST_TO_ADDR
19857: GO 19860
19859: POP
// result := ( chassis in result ) ;
19860: LD_ADDR_VAR 0 3
19864: PUSH
19865: LD_VAR 0 1
19869: PUSH
19870: LD_VAR 0 3
19874: IN
19875: ST_TO_ADDR
// end ;
19876: LD_VAR 0 3
19880: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19881: LD_INT 0
19883: PPUSH
19884: PPUSH
19885: PPUSH
19886: PPUSH
19887: PPUSH
19888: PPUSH
19889: PPUSH
// result := array ;
19890: LD_ADDR_VAR 0 5
19894: PUSH
19895: LD_VAR 0 1
19899: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19900: LD_VAR 0 1
19904: NOT
19905: PUSH
19906: LD_VAR 0 2
19910: NOT
19911: OR
19912: PUSH
19913: LD_VAR 0 3
19917: NOT
19918: OR
19919: PUSH
19920: LD_VAR 0 2
19924: PUSH
19925: LD_VAR 0 1
19929: GREATER
19930: OR
19931: PUSH
19932: LD_VAR 0 3
19936: PUSH
19937: LD_VAR 0 1
19941: GREATER
19942: OR
19943: IFFALSE 19947
// exit ;
19945: GO 20243
// if direction then
19947: LD_VAR 0 4
19951: IFFALSE 20015
// begin d := 1 ;
19953: LD_ADDR_VAR 0 9
19957: PUSH
19958: LD_INT 1
19960: ST_TO_ADDR
// if i_from > i_to then
19961: LD_VAR 0 2
19965: PUSH
19966: LD_VAR 0 3
19970: GREATER
19971: IFFALSE 19997
// length := ( array - i_from ) + i_to else
19973: LD_ADDR_VAR 0 11
19977: PUSH
19978: LD_VAR 0 1
19982: PUSH
19983: LD_VAR 0 2
19987: MINUS
19988: PUSH
19989: LD_VAR 0 3
19993: PLUS
19994: ST_TO_ADDR
19995: GO 20013
// length := i_to - i_from ;
19997: LD_ADDR_VAR 0 11
20001: PUSH
20002: LD_VAR 0 3
20006: PUSH
20007: LD_VAR 0 2
20011: MINUS
20012: ST_TO_ADDR
// end else
20013: GO 20076
// begin d := - 1 ;
20015: LD_ADDR_VAR 0 9
20019: PUSH
20020: LD_INT 1
20022: NEG
20023: ST_TO_ADDR
// if i_from > i_to then
20024: LD_VAR 0 2
20028: PUSH
20029: LD_VAR 0 3
20033: GREATER
20034: IFFALSE 20054
// length := i_from - i_to else
20036: LD_ADDR_VAR 0 11
20040: PUSH
20041: LD_VAR 0 2
20045: PUSH
20046: LD_VAR 0 3
20050: MINUS
20051: ST_TO_ADDR
20052: GO 20076
// length := ( array - i_to ) + i_from ;
20054: LD_ADDR_VAR 0 11
20058: PUSH
20059: LD_VAR 0 1
20063: PUSH
20064: LD_VAR 0 3
20068: MINUS
20069: PUSH
20070: LD_VAR 0 2
20074: PLUS
20075: ST_TO_ADDR
// end ; if not length then
20076: LD_VAR 0 11
20080: NOT
20081: IFFALSE 20085
// exit ;
20083: GO 20243
// tmp := array ;
20085: LD_ADDR_VAR 0 10
20089: PUSH
20090: LD_VAR 0 1
20094: ST_TO_ADDR
// for i = 1 to length do
20095: LD_ADDR_VAR 0 6
20099: PUSH
20100: DOUBLE
20101: LD_INT 1
20103: DEC
20104: ST_TO_ADDR
20105: LD_VAR 0 11
20109: PUSH
20110: FOR_TO
20111: IFFALSE 20231
// begin for j = 1 to array do
20113: LD_ADDR_VAR 0 7
20117: PUSH
20118: DOUBLE
20119: LD_INT 1
20121: DEC
20122: ST_TO_ADDR
20123: LD_VAR 0 1
20127: PUSH
20128: FOR_TO
20129: IFFALSE 20217
// begin k := j + d ;
20131: LD_ADDR_VAR 0 8
20135: PUSH
20136: LD_VAR 0 7
20140: PUSH
20141: LD_VAR 0 9
20145: PLUS
20146: ST_TO_ADDR
// if k > array then
20147: LD_VAR 0 8
20151: PUSH
20152: LD_VAR 0 1
20156: GREATER
20157: IFFALSE 20167
// k := 1 ;
20159: LD_ADDR_VAR 0 8
20163: PUSH
20164: LD_INT 1
20166: ST_TO_ADDR
// if not k then
20167: LD_VAR 0 8
20171: NOT
20172: IFFALSE 20184
// k := array ;
20174: LD_ADDR_VAR 0 8
20178: PUSH
20179: LD_VAR 0 1
20183: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20184: LD_ADDR_VAR 0 10
20188: PUSH
20189: LD_VAR 0 10
20193: PPUSH
20194: LD_VAR 0 8
20198: PPUSH
20199: LD_VAR 0 1
20203: PUSH
20204: LD_VAR 0 7
20208: ARRAY
20209: PPUSH
20210: CALL_OW 1
20214: ST_TO_ADDR
// end ;
20215: GO 20128
20217: POP
20218: POP
// array := tmp ;
20219: LD_ADDR_VAR 0 1
20223: PUSH
20224: LD_VAR 0 10
20228: ST_TO_ADDR
// end ;
20229: GO 20110
20231: POP
20232: POP
// result := array ;
20233: LD_ADDR_VAR 0 5
20237: PUSH
20238: LD_VAR 0 1
20242: ST_TO_ADDR
// end ;
20243: LD_VAR 0 5
20247: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20248: LD_INT 0
20250: PPUSH
20251: PPUSH
// result := 0 ;
20252: LD_ADDR_VAR 0 3
20256: PUSH
20257: LD_INT 0
20259: ST_TO_ADDR
// if not array or not value in array then
20260: LD_VAR 0 1
20264: NOT
20265: PUSH
20266: LD_VAR 0 2
20270: PUSH
20271: LD_VAR 0 1
20275: IN
20276: NOT
20277: OR
20278: IFFALSE 20282
// exit ;
20280: GO 20336
// for i = 1 to array do
20282: LD_ADDR_VAR 0 4
20286: PUSH
20287: DOUBLE
20288: LD_INT 1
20290: DEC
20291: ST_TO_ADDR
20292: LD_VAR 0 1
20296: PUSH
20297: FOR_TO
20298: IFFALSE 20334
// if value = array [ i ] then
20300: LD_VAR 0 2
20304: PUSH
20305: LD_VAR 0 1
20309: PUSH
20310: LD_VAR 0 4
20314: ARRAY
20315: EQUAL
20316: IFFALSE 20332
// begin result := i ;
20318: LD_ADDR_VAR 0 3
20322: PUSH
20323: LD_VAR 0 4
20327: ST_TO_ADDR
// exit ;
20328: POP
20329: POP
20330: GO 20336
// end ;
20332: GO 20297
20334: POP
20335: POP
// end ;
20336: LD_VAR 0 3
20340: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20341: LD_INT 0
20343: PPUSH
// vc_chassis := chassis ;
20344: LD_ADDR_OWVAR 37
20348: PUSH
20349: LD_VAR 0 1
20353: ST_TO_ADDR
// vc_engine := engine ;
20354: LD_ADDR_OWVAR 39
20358: PUSH
20359: LD_VAR 0 2
20363: ST_TO_ADDR
// vc_control := control ;
20364: LD_ADDR_OWVAR 38
20368: PUSH
20369: LD_VAR 0 3
20373: ST_TO_ADDR
// vc_weapon := weapon ;
20374: LD_ADDR_OWVAR 40
20378: PUSH
20379: LD_VAR 0 4
20383: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20384: LD_ADDR_OWVAR 41
20388: PUSH
20389: LD_VAR 0 5
20393: ST_TO_ADDR
// end ;
20394: LD_VAR 0 6
20398: RET
// export function WantPlant ( unit ) ; var task ; begin
20399: LD_INT 0
20401: PPUSH
20402: PPUSH
// result := false ;
20403: LD_ADDR_VAR 0 2
20407: PUSH
20408: LD_INT 0
20410: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20411: LD_ADDR_VAR 0 3
20415: PUSH
20416: LD_VAR 0 1
20420: PPUSH
20421: CALL_OW 437
20425: ST_TO_ADDR
// if task then
20426: LD_VAR 0 3
20430: IFFALSE 20458
// if task [ 1 ] [ 1 ] = p then
20432: LD_VAR 0 3
20436: PUSH
20437: LD_INT 1
20439: ARRAY
20440: PUSH
20441: LD_INT 1
20443: ARRAY
20444: PUSH
20445: LD_STRING p
20447: EQUAL
20448: IFFALSE 20458
// result := true ;
20450: LD_ADDR_VAR 0 2
20454: PUSH
20455: LD_INT 1
20457: ST_TO_ADDR
// end ;
20458: LD_VAR 0 2
20462: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20463: LD_INT 0
20465: PPUSH
20466: PPUSH
20467: PPUSH
20468: PPUSH
// if pos < 1 then
20469: LD_VAR 0 2
20473: PUSH
20474: LD_INT 1
20476: LESS
20477: IFFALSE 20481
// exit ;
20479: GO 20784
// if pos = 1 then
20481: LD_VAR 0 2
20485: PUSH
20486: LD_INT 1
20488: EQUAL
20489: IFFALSE 20522
// result := Replace ( arr , pos [ 1 ] , value ) else
20491: LD_ADDR_VAR 0 4
20495: PUSH
20496: LD_VAR 0 1
20500: PPUSH
20501: LD_VAR 0 2
20505: PUSH
20506: LD_INT 1
20508: ARRAY
20509: PPUSH
20510: LD_VAR 0 3
20514: PPUSH
20515: CALL_OW 1
20519: ST_TO_ADDR
20520: GO 20784
// begin tmp := arr ;
20522: LD_ADDR_VAR 0 6
20526: PUSH
20527: LD_VAR 0 1
20531: ST_TO_ADDR
// s_arr := [ tmp ] ;
20532: LD_ADDR_VAR 0 7
20536: PUSH
20537: LD_VAR 0 6
20541: PUSH
20542: EMPTY
20543: LIST
20544: ST_TO_ADDR
// for i = 1 to pos - 1 do
20545: LD_ADDR_VAR 0 5
20549: PUSH
20550: DOUBLE
20551: LD_INT 1
20553: DEC
20554: ST_TO_ADDR
20555: LD_VAR 0 2
20559: PUSH
20560: LD_INT 1
20562: MINUS
20563: PUSH
20564: FOR_TO
20565: IFFALSE 20610
// begin tmp := tmp [ pos [ i ] ] ;
20567: LD_ADDR_VAR 0 6
20571: PUSH
20572: LD_VAR 0 6
20576: PUSH
20577: LD_VAR 0 2
20581: PUSH
20582: LD_VAR 0 5
20586: ARRAY
20587: ARRAY
20588: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20589: LD_ADDR_VAR 0 7
20593: PUSH
20594: LD_VAR 0 7
20598: PUSH
20599: LD_VAR 0 6
20603: PUSH
20604: EMPTY
20605: LIST
20606: ADD
20607: ST_TO_ADDR
// end ;
20608: GO 20564
20610: POP
20611: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20612: LD_ADDR_VAR 0 6
20616: PUSH
20617: LD_VAR 0 6
20621: PPUSH
20622: LD_VAR 0 2
20626: PUSH
20627: LD_VAR 0 2
20631: ARRAY
20632: PPUSH
20633: LD_VAR 0 3
20637: PPUSH
20638: CALL_OW 1
20642: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20643: LD_ADDR_VAR 0 7
20647: PUSH
20648: LD_VAR 0 7
20652: PPUSH
20653: LD_VAR 0 7
20657: PPUSH
20658: LD_VAR 0 6
20662: PPUSH
20663: CALL_OW 1
20667: ST_TO_ADDR
// for i = s_arr downto 2 do
20668: LD_ADDR_VAR 0 5
20672: PUSH
20673: DOUBLE
20674: LD_VAR 0 7
20678: INC
20679: ST_TO_ADDR
20680: LD_INT 2
20682: PUSH
20683: FOR_DOWNTO
20684: IFFALSE 20768
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20686: LD_ADDR_VAR 0 6
20690: PUSH
20691: LD_VAR 0 7
20695: PUSH
20696: LD_VAR 0 5
20700: PUSH
20701: LD_INT 1
20703: MINUS
20704: ARRAY
20705: PPUSH
20706: LD_VAR 0 2
20710: PUSH
20711: LD_VAR 0 5
20715: PUSH
20716: LD_INT 1
20718: MINUS
20719: ARRAY
20720: PPUSH
20721: LD_VAR 0 7
20725: PUSH
20726: LD_VAR 0 5
20730: ARRAY
20731: PPUSH
20732: CALL_OW 1
20736: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20737: LD_ADDR_VAR 0 7
20741: PUSH
20742: LD_VAR 0 7
20746: PPUSH
20747: LD_VAR 0 5
20751: PUSH
20752: LD_INT 1
20754: MINUS
20755: PPUSH
20756: LD_VAR 0 6
20760: PPUSH
20761: CALL_OW 1
20765: ST_TO_ADDR
// end ;
20766: GO 20683
20768: POP
20769: POP
// result := s_arr [ 1 ] ;
20770: LD_ADDR_VAR 0 4
20774: PUSH
20775: LD_VAR 0 7
20779: PUSH
20780: LD_INT 1
20782: ARRAY
20783: ST_TO_ADDR
// end ; end ;
20784: LD_VAR 0 4
20788: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20789: LD_INT 0
20791: PPUSH
20792: PPUSH
// if not list then
20793: LD_VAR 0 1
20797: NOT
20798: IFFALSE 20802
// exit ;
20800: GO 20893
// i := list [ pos1 ] ;
20802: LD_ADDR_VAR 0 5
20806: PUSH
20807: LD_VAR 0 1
20811: PUSH
20812: LD_VAR 0 2
20816: ARRAY
20817: ST_TO_ADDR
// if not i then
20818: LD_VAR 0 5
20822: NOT
20823: IFFALSE 20827
// exit ;
20825: GO 20893
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20827: LD_ADDR_VAR 0 1
20831: PUSH
20832: LD_VAR 0 1
20836: PPUSH
20837: LD_VAR 0 2
20841: PPUSH
20842: LD_VAR 0 1
20846: PUSH
20847: LD_VAR 0 3
20851: ARRAY
20852: PPUSH
20853: CALL_OW 1
20857: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20858: LD_ADDR_VAR 0 1
20862: PUSH
20863: LD_VAR 0 1
20867: PPUSH
20868: LD_VAR 0 3
20872: PPUSH
20873: LD_VAR 0 5
20877: PPUSH
20878: CALL_OW 1
20882: ST_TO_ADDR
// result := list ;
20883: LD_ADDR_VAR 0 4
20887: PUSH
20888: LD_VAR 0 1
20892: ST_TO_ADDR
// end ;
20893: LD_VAR 0 4
20897: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20898: LD_INT 0
20900: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20901: LD_ADDR_VAR 0 5
20905: PUSH
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 250
20915: PPUSH
20916: LD_VAR 0 1
20920: PPUSH
20921: CALL_OW 251
20925: PPUSH
20926: LD_VAR 0 2
20930: PPUSH
20931: LD_VAR 0 3
20935: PPUSH
20936: LD_VAR 0 4
20940: PPUSH
20941: CALL 21319 0 5
20945: ST_TO_ADDR
// end ;
20946: LD_VAR 0 5
20950: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
20951: LD_INT 0
20953: PPUSH
20954: PPUSH
20955: PPUSH
20956: PPUSH
// if not list or not unit then
20957: LD_VAR 0 2
20961: NOT
20962: PUSH
20963: LD_VAR 0 1
20967: NOT
20968: OR
20969: IFFALSE 20973
// exit ;
20971: GO 21314
// result := [ ] ;
20973: LD_ADDR_VAR 0 5
20977: PUSH
20978: EMPTY
20979: ST_TO_ADDR
// for i in list do
20980: LD_ADDR_VAR 0 6
20984: PUSH
20985: LD_VAR 0 2
20989: PUSH
20990: FOR_IN
20991: IFFALSE 21209
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
20993: LD_ADDR_VAR 0 8
20997: PUSH
20998: LD_VAR 0 1
21002: PPUSH
21003: LD_VAR 0 6
21007: PUSH
21008: LD_INT 1
21010: ARRAY
21011: PPUSH
21012: LD_VAR 0 6
21016: PUSH
21017: LD_INT 2
21019: ARRAY
21020: PPUSH
21021: CALL_OW 297
21025: ST_TO_ADDR
// if not Count ( result ) then
21026: LD_VAR 0 5
21030: PPUSH
21031: CALL 17603 0 1
21035: NOT
21036: IFFALSE 21069
// begin result := Join ( result , [ i , tmp ] ) ;
21038: LD_ADDR_VAR 0 5
21042: PUSH
21043: LD_VAR 0 5
21047: PPUSH
21048: LD_VAR 0 6
21052: PUSH
21053: LD_VAR 0 8
21057: PUSH
21058: EMPTY
21059: LIST
21060: LIST
21061: PPUSH
21062: CALL 53203 0 2
21066: ST_TO_ADDR
// continue ;
21067: GO 20990
// end ; if result [ result ] [ 2 ] <= tmp then
21069: LD_VAR 0 5
21073: PUSH
21074: LD_VAR 0 5
21078: ARRAY
21079: PUSH
21080: LD_INT 2
21082: ARRAY
21083: PUSH
21084: LD_VAR 0 8
21088: LESSEQUAL
21089: IFFALSE 21122
// result := Join ( result , [ i , tmp ] ) else
21091: LD_ADDR_VAR 0 5
21095: PUSH
21096: LD_VAR 0 5
21100: PPUSH
21101: LD_VAR 0 6
21105: PUSH
21106: LD_VAR 0 8
21110: PUSH
21111: EMPTY
21112: LIST
21113: LIST
21114: PPUSH
21115: CALL 53203 0 2
21119: ST_TO_ADDR
21120: GO 21207
// begin for j := 1 to Count ( result ) do
21122: LD_ADDR_VAR 0 7
21126: PUSH
21127: DOUBLE
21128: LD_INT 1
21130: DEC
21131: ST_TO_ADDR
21132: LD_VAR 0 5
21136: PPUSH
21137: CALL 17603 0 1
21141: PUSH
21142: FOR_TO
21143: IFFALSE 21205
// begin if tmp < result [ j ] [ 2 ] then
21145: LD_VAR 0 8
21149: PUSH
21150: LD_VAR 0 5
21154: PUSH
21155: LD_VAR 0 7
21159: ARRAY
21160: PUSH
21161: LD_INT 2
21163: ARRAY
21164: LESS
21165: IFFALSE 21203
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21167: LD_ADDR_VAR 0 5
21171: PUSH
21172: LD_VAR 0 5
21176: PPUSH
21177: LD_VAR 0 7
21181: PPUSH
21182: LD_VAR 0 6
21186: PUSH
21187: LD_VAR 0 8
21191: PUSH
21192: EMPTY
21193: LIST
21194: LIST
21195: PPUSH
21196: CALL_OW 2
21200: ST_TO_ADDR
// break ;
21201: GO 21205
// end ; end ;
21203: GO 21142
21205: POP
21206: POP
// end ; end ;
21207: GO 20990
21209: POP
21210: POP
// if result and not asc then
21211: LD_VAR 0 5
21215: PUSH
21216: LD_VAR 0 3
21220: NOT
21221: AND
21222: IFFALSE 21239
// result := ReverseArray ( result ) ;
21224: LD_ADDR_VAR 0 5
21228: PUSH
21229: LD_VAR 0 5
21233: PPUSH
21234: CALL 48479 0 1
21238: ST_TO_ADDR
// tmp := [ ] ;
21239: LD_ADDR_VAR 0 8
21243: PUSH
21244: EMPTY
21245: ST_TO_ADDR
// if mode then
21246: LD_VAR 0 4
21250: IFFALSE 21314
// begin for i := 1 to result do
21252: LD_ADDR_VAR 0 6
21256: PUSH
21257: DOUBLE
21258: LD_INT 1
21260: DEC
21261: ST_TO_ADDR
21262: LD_VAR 0 5
21266: PUSH
21267: FOR_TO
21268: IFFALSE 21302
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
21270: LD_ADDR_VAR 0 8
21274: PUSH
21275: LD_VAR 0 8
21279: PPUSH
21280: LD_VAR 0 5
21284: PUSH
21285: LD_VAR 0 6
21289: ARRAY
21290: PUSH
21291: LD_INT 1
21293: ARRAY
21294: PPUSH
21295: CALL 53203 0 2
21299: ST_TO_ADDR
21300: GO 21267
21302: POP
21303: POP
// result := tmp ;
21304: LD_ADDR_VAR 0 5
21308: PUSH
21309: LD_VAR 0 8
21313: ST_TO_ADDR
// end ; end ;
21314: LD_VAR 0 5
21318: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21319: LD_INT 0
21321: PPUSH
21322: PPUSH
21323: PPUSH
21324: PPUSH
// if not list then
21325: LD_VAR 0 3
21329: NOT
21330: IFFALSE 21334
// exit ;
21332: GO 21722
// result := [ ] ;
21334: LD_ADDR_VAR 0 6
21338: PUSH
21339: EMPTY
21340: ST_TO_ADDR
// for i in list do
21341: LD_ADDR_VAR 0 7
21345: PUSH
21346: LD_VAR 0 3
21350: PUSH
21351: FOR_IN
21352: IFFALSE 21554
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21354: LD_ADDR_VAR 0 9
21358: PUSH
21359: LD_VAR 0 7
21363: PPUSH
21364: LD_VAR 0 1
21368: PPUSH
21369: LD_VAR 0 2
21373: PPUSH
21374: CALL_OW 297
21378: ST_TO_ADDR
// if not result then
21379: LD_VAR 0 6
21383: NOT
21384: IFFALSE 21410
// result := [ [ i , tmp ] ] else
21386: LD_ADDR_VAR 0 6
21390: PUSH
21391: LD_VAR 0 7
21395: PUSH
21396: LD_VAR 0 9
21400: PUSH
21401: EMPTY
21402: LIST
21403: LIST
21404: PUSH
21405: EMPTY
21406: LIST
21407: ST_TO_ADDR
21408: GO 21552
// begin if result [ result ] [ 2 ] < tmp then
21410: LD_VAR 0 6
21414: PUSH
21415: LD_VAR 0 6
21419: ARRAY
21420: PUSH
21421: LD_INT 2
21423: ARRAY
21424: PUSH
21425: LD_VAR 0 9
21429: LESS
21430: IFFALSE 21472
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21432: LD_ADDR_VAR 0 6
21436: PUSH
21437: LD_VAR 0 6
21441: PPUSH
21442: LD_VAR 0 6
21446: PUSH
21447: LD_INT 1
21449: PLUS
21450: PPUSH
21451: LD_VAR 0 7
21455: PUSH
21456: LD_VAR 0 9
21460: PUSH
21461: EMPTY
21462: LIST
21463: LIST
21464: PPUSH
21465: CALL_OW 2
21469: ST_TO_ADDR
21470: GO 21552
// for j = 1 to result do
21472: LD_ADDR_VAR 0 8
21476: PUSH
21477: DOUBLE
21478: LD_INT 1
21480: DEC
21481: ST_TO_ADDR
21482: LD_VAR 0 6
21486: PUSH
21487: FOR_TO
21488: IFFALSE 21550
// begin if tmp < result [ j ] [ 2 ] then
21490: LD_VAR 0 9
21494: PUSH
21495: LD_VAR 0 6
21499: PUSH
21500: LD_VAR 0 8
21504: ARRAY
21505: PUSH
21506: LD_INT 2
21508: ARRAY
21509: LESS
21510: IFFALSE 21548
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21512: LD_ADDR_VAR 0 6
21516: PUSH
21517: LD_VAR 0 6
21521: PPUSH
21522: LD_VAR 0 8
21526: PPUSH
21527: LD_VAR 0 7
21531: PUSH
21532: LD_VAR 0 9
21536: PUSH
21537: EMPTY
21538: LIST
21539: LIST
21540: PPUSH
21541: CALL_OW 2
21545: ST_TO_ADDR
// break ;
21546: GO 21550
// end ; end ;
21548: GO 21487
21550: POP
21551: POP
// end ; end ;
21552: GO 21351
21554: POP
21555: POP
// if result and not asc then
21556: LD_VAR 0 6
21560: PUSH
21561: LD_VAR 0 4
21565: NOT
21566: AND
21567: IFFALSE 21642
// begin tmp := result ;
21569: LD_ADDR_VAR 0 9
21573: PUSH
21574: LD_VAR 0 6
21578: ST_TO_ADDR
// for i = tmp downto 1 do
21579: LD_ADDR_VAR 0 7
21583: PUSH
21584: DOUBLE
21585: LD_VAR 0 9
21589: INC
21590: ST_TO_ADDR
21591: LD_INT 1
21593: PUSH
21594: FOR_DOWNTO
21595: IFFALSE 21640
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21597: LD_ADDR_VAR 0 6
21601: PUSH
21602: LD_VAR 0 6
21606: PPUSH
21607: LD_VAR 0 9
21611: PUSH
21612: LD_VAR 0 7
21616: MINUS
21617: PUSH
21618: LD_INT 1
21620: PLUS
21621: PPUSH
21622: LD_VAR 0 9
21626: PUSH
21627: LD_VAR 0 7
21631: ARRAY
21632: PPUSH
21633: CALL_OW 1
21637: ST_TO_ADDR
21638: GO 21594
21640: POP
21641: POP
// end ; tmp := [ ] ;
21642: LD_ADDR_VAR 0 9
21646: PUSH
21647: EMPTY
21648: ST_TO_ADDR
// if mode then
21649: LD_VAR 0 5
21653: IFFALSE 21722
// begin for i = 1 to result do
21655: LD_ADDR_VAR 0 7
21659: PUSH
21660: DOUBLE
21661: LD_INT 1
21663: DEC
21664: ST_TO_ADDR
21665: LD_VAR 0 6
21669: PUSH
21670: FOR_TO
21671: IFFALSE 21710
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21673: LD_ADDR_VAR 0 9
21677: PUSH
21678: LD_VAR 0 9
21682: PPUSH
21683: LD_VAR 0 7
21687: PPUSH
21688: LD_VAR 0 6
21692: PUSH
21693: LD_VAR 0 7
21697: ARRAY
21698: PUSH
21699: LD_INT 1
21701: ARRAY
21702: PPUSH
21703: CALL_OW 1
21707: ST_TO_ADDR
21708: GO 21670
21710: POP
21711: POP
// result := tmp ;
21712: LD_ADDR_VAR 0 6
21716: PUSH
21717: LD_VAR 0 9
21721: ST_TO_ADDR
// end ; end ;
21722: LD_VAR 0 6
21726: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21727: LD_INT 0
21729: PPUSH
21730: PPUSH
21731: PPUSH
21732: PPUSH
21733: PPUSH
21734: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21735: LD_ADDR_VAR 0 5
21739: PUSH
21740: LD_INT 0
21742: PUSH
21743: LD_INT 0
21745: PUSH
21746: LD_INT 0
21748: PUSH
21749: EMPTY
21750: PUSH
21751: EMPTY
21752: LIST
21753: LIST
21754: LIST
21755: LIST
21756: ST_TO_ADDR
// if not x or not y then
21757: LD_VAR 0 2
21761: NOT
21762: PUSH
21763: LD_VAR 0 3
21767: NOT
21768: OR
21769: IFFALSE 21773
// exit ;
21771: GO 23423
// if not range then
21773: LD_VAR 0 4
21777: NOT
21778: IFFALSE 21788
// range := 10 ;
21780: LD_ADDR_VAR 0 4
21784: PUSH
21785: LD_INT 10
21787: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21788: LD_ADDR_VAR 0 8
21792: PUSH
21793: LD_INT 81
21795: PUSH
21796: LD_VAR 0 1
21800: PUSH
21801: EMPTY
21802: LIST
21803: LIST
21804: PUSH
21805: LD_INT 92
21807: PUSH
21808: LD_VAR 0 2
21812: PUSH
21813: LD_VAR 0 3
21817: PUSH
21818: LD_VAR 0 4
21822: PUSH
21823: EMPTY
21824: LIST
21825: LIST
21826: LIST
21827: LIST
21828: PUSH
21829: LD_INT 3
21831: PUSH
21832: LD_INT 21
21834: PUSH
21835: LD_INT 3
21837: PUSH
21838: EMPTY
21839: LIST
21840: LIST
21841: PUSH
21842: EMPTY
21843: LIST
21844: LIST
21845: PUSH
21846: EMPTY
21847: LIST
21848: LIST
21849: LIST
21850: PPUSH
21851: CALL_OW 69
21855: ST_TO_ADDR
// if not tmp then
21856: LD_VAR 0 8
21860: NOT
21861: IFFALSE 21865
// exit ;
21863: GO 23423
// for i in tmp do
21865: LD_ADDR_VAR 0 6
21869: PUSH
21870: LD_VAR 0 8
21874: PUSH
21875: FOR_IN
21876: IFFALSE 23398
// begin points := [ 0 , 0 , 0 ] ;
21878: LD_ADDR_VAR 0 9
21882: PUSH
21883: LD_INT 0
21885: PUSH
21886: LD_INT 0
21888: PUSH
21889: LD_INT 0
21891: PUSH
21892: EMPTY
21893: LIST
21894: LIST
21895: LIST
21896: ST_TO_ADDR
// bpoints := 1 ;
21897: LD_ADDR_VAR 0 10
21901: PUSH
21902: LD_INT 1
21904: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21905: LD_VAR 0 6
21909: PPUSH
21910: CALL_OW 247
21914: PUSH
21915: LD_INT 1
21917: DOUBLE
21918: EQUAL
21919: IFTRUE 21923
21921: GO 22501
21923: POP
// begin if GetClass ( i ) = 1 then
21924: LD_VAR 0 6
21928: PPUSH
21929: CALL_OW 257
21933: PUSH
21934: LD_INT 1
21936: EQUAL
21937: IFFALSE 21958
// points := [ 10 , 5 , 3 ] ;
21939: LD_ADDR_VAR 0 9
21943: PUSH
21944: LD_INT 10
21946: PUSH
21947: LD_INT 5
21949: PUSH
21950: LD_INT 3
21952: PUSH
21953: EMPTY
21954: LIST
21955: LIST
21956: LIST
21957: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21958: LD_VAR 0 6
21962: PPUSH
21963: CALL_OW 257
21967: PUSH
21968: LD_INT 2
21970: PUSH
21971: LD_INT 3
21973: PUSH
21974: LD_INT 4
21976: PUSH
21977: EMPTY
21978: LIST
21979: LIST
21980: LIST
21981: IN
21982: IFFALSE 22003
// points := [ 3 , 2 , 1 ] ;
21984: LD_ADDR_VAR 0 9
21988: PUSH
21989: LD_INT 3
21991: PUSH
21992: LD_INT 2
21994: PUSH
21995: LD_INT 1
21997: PUSH
21998: EMPTY
21999: LIST
22000: LIST
22001: LIST
22002: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22003: LD_VAR 0 6
22007: PPUSH
22008: CALL_OW 257
22012: PUSH
22013: LD_INT 5
22015: EQUAL
22016: IFFALSE 22037
// points := [ 130 , 5 , 2 ] ;
22018: LD_ADDR_VAR 0 9
22022: PUSH
22023: LD_INT 130
22025: PUSH
22026: LD_INT 5
22028: PUSH
22029: LD_INT 2
22031: PUSH
22032: EMPTY
22033: LIST
22034: LIST
22035: LIST
22036: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22037: LD_VAR 0 6
22041: PPUSH
22042: CALL_OW 257
22046: PUSH
22047: LD_INT 8
22049: EQUAL
22050: IFFALSE 22071
// points := [ 35 , 35 , 30 ] ;
22052: LD_ADDR_VAR 0 9
22056: PUSH
22057: LD_INT 35
22059: PUSH
22060: LD_INT 35
22062: PUSH
22063: LD_INT 30
22065: PUSH
22066: EMPTY
22067: LIST
22068: LIST
22069: LIST
22070: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22071: LD_VAR 0 6
22075: PPUSH
22076: CALL_OW 257
22080: PUSH
22081: LD_INT 9
22083: EQUAL
22084: IFFALSE 22105
// points := [ 20 , 55 , 40 ] ;
22086: LD_ADDR_VAR 0 9
22090: PUSH
22091: LD_INT 20
22093: PUSH
22094: LD_INT 55
22096: PUSH
22097: LD_INT 40
22099: PUSH
22100: EMPTY
22101: LIST
22102: LIST
22103: LIST
22104: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22105: LD_VAR 0 6
22109: PPUSH
22110: CALL_OW 257
22114: PUSH
22115: LD_INT 12
22117: PUSH
22118: LD_INT 16
22120: PUSH
22121: EMPTY
22122: LIST
22123: LIST
22124: IN
22125: IFFALSE 22146
// points := [ 5 , 3 , 2 ] ;
22127: LD_ADDR_VAR 0 9
22131: PUSH
22132: LD_INT 5
22134: PUSH
22135: LD_INT 3
22137: PUSH
22138: LD_INT 2
22140: PUSH
22141: EMPTY
22142: LIST
22143: LIST
22144: LIST
22145: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22146: LD_VAR 0 6
22150: PPUSH
22151: CALL_OW 257
22155: PUSH
22156: LD_INT 17
22158: EQUAL
22159: IFFALSE 22180
// points := [ 100 , 50 , 75 ] ;
22161: LD_ADDR_VAR 0 9
22165: PUSH
22166: LD_INT 100
22168: PUSH
22169: LD_INT 50
22171: PUSH
22172: LD_INT 75
22174: PUSH
22175: EMPTY
22176: LIST
22177: LIST
22178: LIST
22179: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22180: LD_VAR 0 6
22184: PPUSH
22185: CALL_OW 257
22189: PUSH
22190: LD_INT 15
22192: EQUAL
22193: IFFALSE 22214
// points := [ 10 , 5 , 3 ] ;
22195: LD_ADDR_VAR 0 9
22199: PUSH
22200: LD_INT 10
22202: PUSH
22203: LD_INT 5
22205: PUSH
22206: LD_INT 3
22208: PUSH
22209: EMPTY
22210: LIST
22211: LIST
22212: LIST
22213: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22214: LD_VAR 0 6
22218: PPUSH
22219: CALL_OW 257
22223: PUSH
22224: LD_INT 14
22226: EQUAL
22227: IFFALSE 22248
// points := [ 10 , 0 , 0 ] ;
22229: LD_ADDR_VAR 0 9
22233: PUSH
22234: LD_INT 10
22236: PUSH
22237: LD_INT 0
22239: PUSH
22240: LD_INT 0
22242: PUSH
22243: EMPTY
22244: LIST
22245: LIST
22246: LIST
22247: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22248: LD_VAR 0 6
22252: PPUSH
22253: CALL_OW 257
22257: PUSH
22258: LD_INT 11
22260: EQUAL
22261: IFFALSE 22282
// points := [ 30 , 10 , 5 ] ;
22263: LD_ADDR_VAR 0 9
22267: PUSH
22268: LD_INT 30
22270: PUSH
22271: LD_INT 10
22273: PUSH
22274: LD_INT 5
22276: PUSH
22277: EMPTY
22278: LIST
22279: LIST
22280: LIST
22281: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22282: LD_VAR 0 1
22286: PPUSH
22287: LD_INT 5
22289: PPUSH
22290: CALL_OW 321
22294: PUSH
22295: LD_INT 2
22297: EQUAL
22298: IFFALSE 22315
// bpoints := bpoints * 1.8 ;
22300: LD_ADDR_VAR 0 10
22304: PUSH
22305: LD_VAR 0 10
22309: PUSH
22310: LD_REAL  1.80000000000000E+0000
22313: MUL
22314: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22315: LD_VAR 0 6
22319: PPUSH
22320: CALL_OW 257
22324: PUSH
22325: LD_INT 1
22327: PUSH
22328: LD_INT 2
22330: PUSH
22331: LD_INT 3
22333: PUSH
22334: LD_INT 4
22336: PUSH
22337: EMPTY
22338: LIST
22339: LIST
22340: LIST
22341: LIST
22342: IN
22343: PUSH
22344: LD_VAR 0 1
22348: PPUSH
22349: LD_INT 51
22351: PPUSH
22352: CALL_OW 321
22356: PUSH
22357: LD_INT 2
22359: EQUAL
22360: AND
22361: IFFALSE 22378
// bpoints := bpoints * 1.2 ;
22363: LD_ADDR_VAR 0 10
22367: PUSH
22368: LD_VAR 0 10
22372: PUSH
22373: LD_REAL  1.20000000000000E+0000
22376: MUL
22377: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22378: LD_VAR 0 6
22382: PPUSH
22383: CALL_OW 257
22387: PUSH
22388: LD_INT 5
22390: PUSH
22391: LD_INT 7
22393: PUSH
22394: LD_INT 9
22396: PUSH
22397: EMPTY
22398: LIST
22399: LIST
22400: LIST
22401: IN
22402: PUSH
22403: LD_VAR 0 1
22407: PPUSH
22408: LD_INT 52
22410: PPUSH
22411: CALL_OW 321
22415: PUSH
22416: LD_INT 2
22418: EQUAL
22419: AND
22420: IFFALSE 22437
// bpoints := bpoints * 1.5 ;
22422: LD_ADDR_VAR 0 10
22426: PUSH
22427: LD_VAR 0 10
22431: PUSH
22432: LD_REAL  1.50000000000000E+0000
22435: MUL
22436: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22437: LD_VAR 0 1
22441: PPUSH
22442: LD_INT 66
22444: PPUSH
22445: CALL_OW 321
22449: PUSH
22450: LD_INT 2
22452: EQUAL
22453: IFFALSE 22470
// bpoints := bpoints * 1.1 ;
22455: LD_ADDR_VAR 0 10
22459: PUSH
22460: LD_VAR 0 10
22464: PUSH
22465: LD_REAL  1.10000000000000E+0000
22468: MUL
22469: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22470: LD_ADDR_VAR 0 10
22474: PUSH
22475: LD_VAR 0 10
22479: PUSH
22480: LD_VAR 0 6
22484: PPUSH
22485: LD_INT 1
22487: PPUSH
22488: CALL_OW 259
22492: PUSH
22493: LD_REAL  1.15000000000000E+0000
22496: MUL
22497: MUL
22498: ST_TO_ADDR
// end ; unit_vehicle :
22499: GO 23327
22501: LD_INT 2
22503: DOUBLE
22504: EQUAL
22505: IFTRUE 22509
22507: GO 23315
22509: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22510: LD_VAR 0 6
22514: PPUSH
22515: CALL_OW 264
22519: PUSH
22520: LD_INT 2
22522: PUSH
22523: LD_INT 42
22525: PUSH
22526: LD_INT 24
22528: PUSH
22529: EMPTY
22530: LIST
22531: LIST
22532: LIST
22533: IN
22534: IFFALSE 22555
// points := [ 25 , 5 , 3 ] ;
22536: LD_ADDR_VAR 0 9
22540: PUSH
22541: LD_INT 25
22543: PUSH
22544: LD_INT 5
22546: PUSH
22547: LD_INT 3
22549: PUSH
22550: EMPTY
22551: LIST
22552: LIST
22553: LIST
22554: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22555: LD_VAR 0 6
22559: PPUSH
22560: CALL_OW 264
22564: PUSH
22565: LD_INT 4
22567: PUSH
22568: LD_INT 43
22570: PUSH
22571: LD_INT 25
22573: PUSH
22574: EMPTY
22575: LIST
22576: LIST
22577: LIST
22578: IN
22579: IFFALSE 22600
// points := [ 40 , 15 , 5 ] ;
22581: LD_ADDR_VAR 0 9
22585: PUSH
22586: LD_INT 40
22588: PUSH
22589: LD_INT 15
22591: PUSH
22592: LD_INT 5
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: LIST
22599: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22600: LD_VAR 0 6
22604: PPUSH
22605: CALL_OW 264
22609: PUSH
22610: LD_INT 3
22612: PUSH
22613: LD_INT 23
22615: PUSH
22616: EMPTY
22617: LIST
22618: LIST
22619: IN
22620: IFFALSE 22641
// points := [ 7 , 25 , 8 ] ;
22622: LD_ADDR_VAR 0 9
22626: PUSH
22627: LD_INT 7
22629: PUSH
22630: LD_INT 25
22632: PUSH
22633: LD_INT 8
22635: PUSH
22636: EMPTY
22637: LIST
22638: LIST
22639: LIST
22640: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22641: LD_VAR 0 6
22645: PPUSH
22646: CALL_OW 264
22650: PUSH
22651: LD_INT 5
22653: PUSH
22654: LD_INT 27
22656: PUSH
22657: LD_INT 44
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: LIST
22664: IN
22665: IFFALSE 22686
// points := [ 14 , 50 , 16 ] ;
22667: LD_ADDR_VAR 0 9
22671: PUSH
22672: LD_INT 14
22674: PUSH
22675: LD_INT 50
22677: PUSH
22678: LD_INT 16
22680: PUSH
22681: EMPTY
22682: LIST
22683: LIST
22684: LIST
22685: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22686: LD_VAR 0 6
22690: PPUSH
22691: CALL_OW 264
22695: PUSH
22696: LD_INT 6
22698: PUSH
22699: LD_INT 46
22701: PUSH
22702: EMPTY
22703: LIST
22704: LIST
22705: IN
22706: IFFALSE 22727
// points := [ 32 , 120 , 70 ] ;
22708: LD_ADDR_VAR 0 9
22712: PUSH
22713: LD_INT 32
22715: PUSH
22716: LD_INT 120
22718: PUSH
22719: LD_INT 70
22721: PUSH
22722: EMPTY
22723: LIST
22724: LIST
22725: LIST
22726: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
22727: LD_VAR 0 6
22731: PPUSH
22732: CALL_OW 264
22736: PUSH
22737: LD_INT 7
22739: PUSH
22740: LD_INT 28
22742: PUSH
22743: LD_INT 45
22745: PUSH
22746: LD_INT 92
22748: PUSH
22749: EMPTY
22750: LIST
22751: LIST
22752: LIST
22753: LIST
22754: IN
22755: IFFALSE 22776
// points := [ 35 , 20 , 45 ] ;
22757: LD_ADDR_VAR 0 9
22761: PUSH
22762: LD_INT 35
22764: PUSH
22765: LD_INT 20
22767: PUSH
22768: LD_INT 45
22770: PUSH
22771: EMPTY
22772: LIST
22773: LIST
22774: LIST
22775: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22776: LD_VAR 0 6
22780: PPUSH
22781: CALL_OW 264
22785: PUSH
22786: LD_INT 47
22788: PUSH
22789: EMPTY
22790: LIST
22791: IN
22792: IFFALSE 22813
// points := [ 67 , 45 , 75 ] ;
22794: LD_ADDR_VAR 0 9
22798: PUSH
22799: LD_INT 67
22801: PUSH
22802: LD_INT 45
22804: PUSH
22805: LD_INT 75
22807: PUSH
22808: EMPTY
22809: LIST
22810: LIST
22811: LIST
22812: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22813: LD_VAR 0 6
22817: PPUSH
22818: CALL_OW 264
22822: PUSH
22823: LD_INT 26
22825: PUSH
22826: EMPTY
22827: LIST
22828: IN
22829: IFFALSE 22850
// points := [ 120 , 30 , 80 ] ;
22831: LD_ADDR_VAR 0 9
22835: PUSH
22836: LD_INT 120
22838: PUSH
22839: LD_INT 30
22841: PUSH
22842: LD_INT 80
22844: PUSH
22845: EMPTY
22846: LIST
22847: LIST
22848: LIST
22849: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22850: LD_VAR 0 6
22854: PPUSH
22855: CALL_OW 264
22859: PUSH
22860: LD_INT 22
22862: PUSH
22863: EMPTY
22864: LIST
22865: IN
22866: IFFALSE 22887
// points := [ 40 , 1 , 1 ] ;
22868: LD_ADDR_VAR 0 9
22872: PUSH
22873: LD_INT 40
22875: PUSH
22876: LD_INT 1
22878: PUSH
22879: LD_INT 1
22881: PUSH
22882: EMPTY
22883: LIST
22884: LIST
22885: LIST
22886: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22887: LD_VAR 0 6
22891: PPUSH
22892: CALL_OW 264
22896: PUSH
22897: LD_INT 29
22899: PUSH
22900: EMPTY
22901: LIST
22902: IN
22903: IFFALSE 22924
// points := [ 70 , 200 , 400 ] ;
22905: LD_ADDR_VAR 0 9
22909: PUSH
22910: LD_INT 70
22912: PUSH
22913: LD_INT 200
22915: PUSH
22916: LD_INT 400
22918: PUSH
22919: EMPTY
22920: LIST
22921: LIST
22922: LIST
22923: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22924: LD_VAR 0 6
22928: PPUSH
22929: CALL_OW 264
22933: PUSH
22934: LD_INT 14
22936: PUSH
22937: LD_INT 53
22939: PUSH
22940: EMPTY
22941: LIST
22942: LIST
22943: IN
22944: IFFALSE 22965
// points := [ 40 , 10 , 20 ] ;
22946: LD_ADDR_VAR 0 9
22950: PUSH
22951: LD_INT 40
22953: PUSH
22954: LD_INT 10
22956: PUSH
22957: LD_INT 20
22959: PUSH
22960: EMPTY
22961: LIST
22962: LIST
22963: LIST
22964: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22965: LD_VAR 0 6
22969: PPUSH
22970: CALL_OW 264
22974: PUSH
22975: LD_INT 9
22977: PUSH
22978: EMPTY
22979: LIST
22980: IN
22981: IFFALSE 23002
// points := [ 5 , 70 , 20 ] ;
22983: LD_ADDR_VAR 0 9
22987: PUSH
22988: LD_INT 5
22990: PUSH
22991: LD_INT 70
22993: PUSH
22994: LD_INT 20
22996: PUSH
22997: EMPTY
22998: LIST
22999: LIST
23000: LIST
23001: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23002: LD_VAR 0 6
23006: PPUSH
23007: CALL_OW 264
23011: PUSH
23012: LD_INT 10
23014: PUSH
23015: EMPTY
23016: LIST
23017: IN
23018: IFFALSE 23039
// points := [ 35 , 110 , 70 ] ;
23020: LD_ADDR_VAR 0 9
23024: PUSH
23025: LD_INT 35
23027: PUSH
23028: LD_INT 110
23030: PUSH
23031: LD_INT 70
23033: PUSH
23034: EMPTY
23035: LIST
23036: LIST
23037: LIST
23038: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23039: LD_VAR 0 6
23043: PPUSH
23044: CALL_OW 265
23048: PUSH
23049: LD_INT 25
23051: EQUAL
23052: IFFALSE 23073
// points := [ 80 , 65 , 100 ] ;
23054: LD_ADDR_VAR 0 9
23058: PUSH
23059: LD_INT 80
23061: PUSH
23062: LD_INT 65
23064: PUSH
23065: LD_INT 100
23067: PUSH
23068: EMPTY
23069: LIST
23070: LIST
23071: LIST
23072: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23073: LD_VAR 0 6
23077: PPUSH
23078: CALL_OW 263
23082: PUSH
23083: LD_INT 1
23085: EQUAL
23086: IFFALSE 23121
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23088: LD_ADDR_VAR 0 10
23092: PUSH
23093: LD_VAR 0 10
23097: PUSH
23098: LD_VAR 0 6
23102: PPUSH
23103: CALL_OW 311
23107: PPUSH
23108: LD_INT 3
23110: PPUSH
23111: CALL_OW 259
23115: PUSH
23116: LD_INT 4
23118: MUL
23119: MUL
23120: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23121: LD_VAR 0 6
23125: PPUSH
23126: CALL_OW 263
23130: PUSH
23131: LD_INT 2
23133: EQUAL
23134: IFFALSE 23185
// begin j := IsControledBy ( i ) ;
23136: LD_ADDR_VAR 0 7
23140: PUSH
23141: LD_VAR 0 6
23145: PPUSH
23146: CALL_OW 312
23150: ST_TO_ADDR
// if j then
23151: LD_VAR 0 7
23155: IFFALSE 23185
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23157: LD_ADDR_VAR 0 10
23161: PUSH
23162: LD_VAR 0 10
23166: PUSH
23167: LD_VAR 0 7
23171: PPUSH
23172: LD_INT 3
23174: PPUSH
23175: CALL_OW 259
23179: PUSH
23180: LD_INT 3
23182: MUL
23183: MUL
23184: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23185: LD_VAR 0 6
23189: PPUSH
23190: CALL_OW 264
23194: PUSH
23195: LD_INT 5
23197: PUSH
23198: LD_INT 6
23200: PUSH
23201: LD_INT 46
23203: PUSH
23204: LD_INT 44
23206: PUSH
23207: LD_INT 47
23209: PUSH
23210: LD_INT 45
23212: PUSH
23213: LD_INT 28
23215: PUSH
23216: LD_INT 7
23218: PUSH
23219: LD_INT 27
23221: PUSH
23222: LD_INT 29
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: LIST
23232: LIST
23233: LIST
23234: LIST
23235: LIST
23236: IN
23237: PUSH
23238: LD_VAR 0 1
23242: PPUSH
23243: LD_INT 52
23245: PPUSH
23246: CALL_OW 321
23250: PUSH
23251: LD_INT 2
23253: EQUAL
23254: AND
23255: IFFALSE 23272
// bpoints := bpoints * 1.2 ;
23257: LD_ADDR_VAR 0 10
23261: PUSH
23262: LD_VAR 0 10
23266: PUSH
23267: LD_REAL  1.20000000000000E+0000
23270: MUL
23271: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23272: LD_VAR 0 6
23276: PPUSH
23277: CALL_OW 264
23281: PUSH
23282: LD_INT 6
23284: PUSH
23285: LD_INT 46
23287: PUSH
23288: LD_INT 47
23290: PUSH
23291: EMPTY
23292: LIST
23293: LIST
23294: LIST
23295: IN
23296: IFFALSE 23313
// bpoints := bpoints * 1.2 ;
23298: LD_ADDR_VAR 0 10
23302: PUSH
23303: LD_VAR 0 10
23307: PUSH
23308: LD_REAL  1.20000000000000E+0000
23311: MUL
23312: ST_TO_ADDR
// end ; unit_building :
23313: GO 23327
23315: LD_INT 3
23317: DOUBLE
23318: EQUAL
23319: IFTRUE 23323
23321: GO 23326
23323: POP
// ; end ;
23324: GO 23327
23326: POP
// for j = 1 to 3 do
23327: LD_ADDR_VAR 0 7
23331: PUSH
23332: DOUBLE
23333: LD_INT 1
23335: DEC
23336: ST_TO_ADDR
23337: LD_INT 3
23339: PUSH
23340: FOR_TO
23341: IFFALSE 23394
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23343: LD_ADDR_VAR 0 5
23347: PUSH
23348: LD_VAR 0 5
23352: PPUSH
23353: LD_VAR 0 7
23357: PPUSH
23358: LD_VAR 0 5
23362: PUSH
23363: LD_VAR 0 7
23367: ARRAY
23368: PUSH
23369: LD_VAR 0 9
23373: PUSH
23374: LD_VAR 0 7
23378: ARRAY
23379: PUSH
23380: LD_VAR 0 10
23384: MUL
23385: PLUS
23386: PPUSH
23387: CALL_OW 1
23391: ST_TO_ADDR
23392: GO 23340
23394: POP
23395: POP
// end ;
23396: GO 21875
23398: POP
23399: POP
// result := Replace ( result , 4 , tmp ) ;
23400: LD_ADDR_VAR 0 5
23404: PUSH
23405: LD_VAR 0 5
23409: PPUSH
23410: LD_INT 4
23412: PPUSH
23413: LD_VAR 0 8
23417: PPUSH
23418: CALL_OW 1
23422: ST_TO_ADDR
// end ;
23423: LD_VAR 0 5
23427: RET
// export function DangerAtRange ( unit , range ) ; begin
23428: LD_INT 0
23430: PPUSH
// if not unit then
23431: LD_VAR 0 1
23435: NOT
23436: IFFALSE 23440
// exit ;
23438: GO 23485
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23440: LD_ADDR_VAR 0 3
23444: PUSH
23445: LD_VAR 0 1
23449: PPUSH
23450: CALL_OW 255
23454: PPUSH
23455: LD_VAR 0 1
23459: PPUSH
23460: CALL_OW 250
23464: PPUSH
23465: LD_VAR 0 1
23469: PPUSH
23470: CALL_OW 251
23474: PPUSH
23475: LD_VAR 0 2
23479: PPUSH
23480: CALL 21727 0 4
23484: ST_TO_ADDR
// end ;
23485: LD_VAR 0 3
23489: RET
// export function DangerInArea ( side , area ) ; begin
23490: LD_INT 0
23492: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23493: LD_ADDR_VAR 0 3
23497: PUSH
23498: LD_VAR 0 2
23502: PPUSH
23503: LD_INT 81
23505: PUSH
23506: LD_VAR 0 1
23510: PUSH
23511: EMPTY
23512: LIST
23513: LIST
23514: PPUSH
23515: CALL_OW 70
23519: ST_TO_ADDR
// end ;
23520: LD_VAR 0 3
23524: RET
// export function IsExtension ( b ) ; begin
23525: LD_INT 0
23527: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23528: LD_ADDR_VAR 0 2
23532: PUSH
23533: LD_VAR 0 1
23537: PUSH
23538: LD_INT 23
23540: PUSH
23541: LD_INT 20
23543: PUSH
23544: LD_INT 22
23546: PUSH
23547: LD_INT 17
23549: PUSH
23550: LD_INT 24
23552: PUSH
23553: LD_INT 21
23555: PUSH
23556: LD_INT 19
23558: PUSH
23559: LD_INT 16
23561: PUSH
23562: LD_INT 25
23564: PUSH
23565: LD_INT 18
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: LIST
23572: LIST
23573: LIST
23574: LIST
23575: LIST
23576: LIST
23577: LIST
23578: LIST
23579: IN
23580: ST_TO_ADDR
// end ;
23581: LD_VAR 0 2
23585: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
23586: LD_INT 0
23588: PPUSH
23589: PPUSH
23590: PPUSH
// result := [ ] ;
23591: LD_ADDR_VAR 0 4
23595: PUSH
23596: EMPTY
23597: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23598: LD_ADDR_VAR 0 5
23602: PUSH
23603: LD_VAR 0 2
23607: PPUSH
23608: LD_INT 21
23610: PUSH
23611: LD_INT 3
23613: PUSH
23614: EMPTY
23615: LIST
23616: LIST
23617: PPUSH
23618: CALL_OW 70
23622: ST_TO_ADDR
// if not tmp then
23623: LD_VAR 0 5
23627: NOT
23628: IFFALSE 23632
// exit ;
23630: GO 23696
// if checkLink then
23632: LD_VAR 0 3
23636: IFFALSE 23686
// begin for i in tmp do
23638: LD_ADDR_VAR 0 6
23642: PUSH
23643: LD_VAR 0 5
23647: PUSH
23648: FOR_IN
23649: IFFALSE 23684
// if GetBase ( i ) <> base then
23651: LD_VAR 0 6
23655: PPUSH
23656: CALL_OW 274
23660: PUSH
23661: LD_VAR 0 1
23665: NONEQUAL
23666: IFFALSE 23682
// ComLinkToBase ( base , i ) ;
23668: LD_VAR 0 1
23672: PPUSH
23673: LD_VAR 0 6
23677: PPUSH
23678: CALL_OW 169
23682: GO 23648
23684: POP
23685: POP
// end ; result := tmp ;
23686: LD_ADDR_VAR 0 4
23690: PUSH
23691: LD_VAR 0 5
23695: ST_TO_ADDR
// end ;
23696: LD_VAR 0 4
23700: RET
// export function ComComplete ( units , b ) ; var i ; begin
23701: LD_INT 0
23703: PPUSH
23704: PPUSH
// if not units then
23705: LD_VAR 0 1
23709: NOT
23710: IFFALSE 23714
// exit ;
23712: GO 23804
// for i in units do
23714: LD_ADDR_VAR 0 4
23718: PUSH
23719: LD_VAR 0 1
23723: PUSH
23724: FOR_IN
23725: IFFALSE 23802
// if BuildingStatus ( b ) = bs_build then
23727: LD_VAR 0 2
23731: PPUSH
23732: CALL_OW 461
23736: PUSH
23737: LD_INT 1
23739: EQUAL
23740: IFFALSE 23800
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23742: LD_VAR 0 4
23746: PPUSH
23747: LD_STRING h
23749: PUSH
23750: LD_VAR 0 2
23754: PPUSH
23755: CALL_OW 250
23759: PUSH
23760: LD_VAR 0 2
23764: PPUSH
23765: CALL_OW 251
23769: PUSH
23770: LD_VAR 0 2
23774: PUSH
23775: LD_INT 0
23777: PUSH
23778: LD_INT 0
23780: PUSH
23781: LD_INT 0
23783: PUSH
23784: EMPTY
23785: LIST
23786: LIST
23787: LIST
23788: LIST
23789: LIST
23790: LIST
23791: LIST
23792: PUSH
23793: EMPTY
23794: LIST
23795: PPUSH
23796: CALL_OW 446
23800: GO 23724
23802: POP
23803: POP
// end ;
23804: LD_VAR 0 3
23808: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23809: LD_INT 0
23811: PPUSH
23812: PPUSH
23813: PPUSH
23814: PPUSH
23815: PPUSH
23816: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
23817: LD_VAR 0 1
23821: NOT
23822: PUSH
23823: LD_VAR 0 1
23827: PPUSH
23828: CALL_OW 263
23832: PUSH
23833: LD_INT 2
23835: NONEQUAL
23836: OR
23837: IFFALSE 23841
// exit ;
23839: GO 24157
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23841: LD_ADDR_VAR 0 6
23845: PUSH
23846: LD_INT 22
23848: PUSH
23849: LD_VAR 0 1
23853: PPUSH
23854: CALL_OW 255
23858: PUSH
23859: EMPTY
23860: LIST
23861: LIST
23862: PUSH
23863: LD_INT 2
23865: PUSH
23866: LD_INT 30
23868: PUSH
23869: LD_INT 36
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: PUSH
23876: LD_INT 34
23878: PUSH
23879: LD_INT 31
23881: PUSH
23882: EMPTY
23883: LIST
23884: LIST
23885: PUSH
23886: EMPTY
23887: LIST
23888: LIST
23889: LIST
23890: PUSH
23891: EMPTY
23892: LIST
23893: LIST
23894: PPUSH
23895: CALL_OW 69
23899: ST_TO_ADDR
// if not tmp then
23900: LD_VAR 0 6
23904: NOT
23905: IFFALSE 23909
// exit ;
23907: GO 24157
// result := [ ] ;
23909: LD_ADDR_VAR 0 2
23913: PUSH
23914: EMPTY
23915: ST_TO_ADDR
// for i in tmp do
23916: LD_ADDR_VAR 0 3
23920: PUSH
23921: LD_VAR 0 6
23925: PUSH
23926: FOR_IN
23927: IFFALSE 23998
// begin t := UnitsInside ( i ) ;
23929: LD_ADDR_VAR 0 4
23933: PUSH
23934: LD_VAR 0 3
23938: PPUSH
23939: CALL_OW 313
23943: ST_TO_ADDR
// if t then
23944: LD_VAR 0 4
23948: IFFALSE 23996
// for j in t do
23950: LD_ADDR_VAR 0 7
23954: PUSH
23955: LD_VAR 0 4
23959: PUSH
23960: FOR_IN
23961: IFFALSE 23994
// result := Replace ( result , result + 1 , j ) ;
23963: LD_ADDR_VAR 0 2
23967: PUSH
23968: LD_VAR 0 2
23972: PPUSH
23973: LD_VAR 0 2
23977: PUSH
23978: LD_INT 1
23980: PLUS
23981: PPUSH
23982: LD_VAR 0 7
23986: PPUSH
23987: CALL_OW 1
23991: ST_TO_ADDR
23992: GO 23960
23994: POP
23995: POP
// end ;
23996: GO 23926
23998: POP
23999: POP
// if not result then
24000: LD_VAR 0 2
24004: NOT
24005: IFFALSE 24009
// exit ;
24007: GO 24157
// mech := result [ 1 ] ;
24009: LD_ADDR_VAR 0 5
24013: PUSH
24014: LD_VAR 0 2
24018: PUSH
24019: LD_INT 1
24021: ARRAY
24022: ST_TO_ADDR
// if result > 1 then
24023: LD_VAR 0 2
24027: PUSH
24028: LD_INT 1
24030: GREATER
24031: IFFALSE 24143
// begin for i = 2 to result do
24033: LD_ADDR_VAR 0 3
24037: PUSH
24038: DOUBLE
24039: LD_INT 2
24041: DEC
24042: ST_TO_ADDR
24043: LD_VAR 0 2
24047: PUSH
24048: FOR_TO
24049: IFFALSE 24141
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24051: LD_ADDR_VAR 0 4
24055: PUSH
24056: LD_VAR 0 2
24060: PUSH
24061: LD_VAR 0 3
24065: ARRAY
24066: PPUSH
24067: LD_INT 3
24069: PPUSH
24070: CALL_OW 259
24074: PUSH
24075: LD_VAR 0 2
24079: PUSH
24080: LD_VAR 0 3
24084: ARRAY
24085: PPUSH
24086: CALL_OW 432
24090: MINUS
24091: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24092: LD_VAR 0 4
24096: PUSH
24097: LD_VAR 0 5
24101: PPUSH
24102: LD_INT 3
24104: PPUSH
24105: CALL_OW 259
24109: PUSH
24110: LD_VAR 0 5
24114: PPUSH
24115: CALL_OW 432
24119: MINUS
24120: GREATEREQUAL
24121: IFFALSE 24139
// mech := result [ i ] ;
24123: LD_ADDR_VAR 0 5
24127: PUSH
24128: LD_VAR 0 2
24132: PUSH
24133: LD_VAR 0 3
24137: ARRAY
24138: ST_TO_ADDR
// end ;
24139: GO 24048
24141: POP
24142: POP
// end ; ComLinkTo ( vehicle , mech ) ;
24143: LD_VAR 0 1
24147: PPUSH
24148: LD_VAR 0 5
24152: PPUSH
24153: CALL_OW 135
// end ;
24157: LD_VAR 0 2
24161: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24162: LD_INT 0
24164: PPUSH
24165: PPUSH
24166: PPUSH
24167: PPUSH
24168: PPUSH
24169: PPUSH
24170: PPUSH
24171: PPUSH
24172: PPUSH
24173: PPUSH
24174: PPUSH
24175: PPUSH
24176: PPUSH
// result := [ ] ;
24177: LD_ADDR_VAR 0 7
24181: PUSH
24182: EMPTY
24183: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24184: LD_VAR 0 1
24188: PPUSH
24189: CALL_OW 266
24193: PUSH
24194: LD_INT 0
24196: PUSH
24197: LD_INT 1
24199: PUSH
24200: EMPTY
24201: LIST
24202: LIST
24203: IN
24204: NOT
24205: IFFALSE 24209
// exit ;
24207: GO 25843
// if name then
24209: LD_VAR 0 3
24213: IFFALSE 24229
// SetBName ( base_dep , name ) ;
24215: LD_VAR 0 1
24219: PPUSH
24220: LD_VAR 0 3
24224: PPUSH
24225: CALL_OW 500
// base := GetBase ( base_dep ) ;
24229: LD_ADDR_VAR 0 15
24233: PUSH
24234: LD_VAR 0 1
24238: PPUSH
24239: CALL_OW 274
24243: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24244: LD_ADDR_VAR 0 16
24248: PUSH
24249: LD_VAR 0 1
24253: PPUSH
24254: CALL_OW 255
24258: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24259: LD_ADDR_VAR 0 17
24263: PUSH
24264: LD_VAR 0 1
24268: PPUSH
24269: CALL_OW 248
24273: ST_TO_ADDR
// if sources then
24274: LD_VAR 0 5
24278: IFFALSE 24325
// for i = 1 to 3 do
24280: LD_ADDR_VAR 0 8
24284: PUSH
24285: DOUBLE
24286: LD_INT 1
24288: DEC
24289: ST_TO_ADDR
24290: LD_INT 3
24292: PUSH
24293: FOR_TO
24294: IFFALSE 24323
// AddResourceType ( base , i , sources [ i ] ) ;
24296: LD_VAR 0 15
24300: PPUSH
24301: LD_VAR 0 8
24305: PPUSH
24306: LD_VAR 0 5
24310: PUSH
24311: LD_VAR 0 8
24315: ARRAY
24316: PPUSH
24317: CALL_OW 276
24321: GO 24293
24323: POP
24324: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
24325: LD_ADDR_VAR 0 18
24329: PUSH
24330: LD_VAR 0 15
24334: PPUSH
24335: LD_VAR 0 2
24339: PPUSH
24340: LD_INT 1
24342: PPUSH
24343: CALL 23586 0 3
24347: ST_TO_ADDR
// InitHc ;
24348: CALL_OW 19
// InitUc ;
24352: CALL_OW 18
// uc_side := side ;
24356: LD_ADDR_OWVAR 20
24360: PUSH
24361: LD_VAR 0 16
24365: ST_TO_ADDR
// uc_nation := nation ;
24366: LD_ADDR_OWVAR 21
24370: PUSH
24371: LD_VAR 0 17
24375: ST_TO_ADDR
// if buildings then
24376: LD_VAR 0 18
24380: IFFALSE 25702
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24382: LD_ADDR_VAR 0 19
24386: PUSH
24387: LD_VAR 0 18
24391: PPUSH
24392: LD_INT 2
24394: PUSH
24395: LD_INT 30
24397: PUSH
24398: LD_INT 29
24400: PUSH
24401: EMPTY
24402: LIST
24403: LIST
24404: PUSH
24405: LD_INT 30
24407: PUSH
24408: LD_INT 30
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: PUSH
24415: EMPTY
24416: LIST
24417: LIST
24418: LIST
24419: PPUSH
24420: CALL_OW 72
24424: ST_TO_ADDR
// if tmp then
24425: LD_VAR 0 19
24429: IFFALSE 24477
// for i in tmp do
24431: LD_ADDR_VAR 0 8
24435: PUSH
24436: LD_VAR 0 19
24440: PUSH
24441: FOR_IN
24442: IFFALSE 24475
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24444: LD_VAR 0 8
24448: PPUSH
24449: CALL_OW 250
24453: PPUSH
24454: LD_VAR 0 8
24458: PPUSH
24459: CALL_OW 251
24463: PPUSH
24464: LD_VAR 0 16
24468: PPUSH
24469: CALL_OW 441
24473: GO 24441
24475: POP
24476: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24477: LD_VAR 0 18
24481: PPUSH
24482: LD_INT 2
24484: PUSH
24485: LD_INT 30
24487: PUSH
24488: LD_INT 32
24490: PUSH
24491: EMPTY
24492: LIST
24493: LIST
24494: PUSH
24495: LD_INT 30
24497: PUSH
24498: LD_INT 33
24500: PUSH
24501: EMPTY
24502: LIST
24503: LIST
24504: PUSH
24505: EMPTY
24506: LIST
24507: LIST
24508: LIST
24509: PPUSH
24510: CALL_OW 72
24514: IFFALSE 24602
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24516: LD_ADDR_VAR 0 8
24520: PUSH
24521: LD_VAR 0 18
24525: PPUSH
24526: LD_INT 2
24528: PUSH
24529: LD_INT 30
24531: PUSH
24532: LD_INT 32
24534: PUSH
24535: EMPTY
24536: LIST
24537: LIST
24538: PUSH
24539: LD_INT 30
24541: PUSH
24542: LD_INT 33
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: PUSH
24549: EMPTY
24550: LIST
24551: LIST
24552: LIST
24553: PPUSH
24554: CALL_OW 72
24558: PUSH
24559: FOR_IN
24560: IFFALSE 24600
// begin if not GetBWeapon ( i ) then
24562: LD_VAR 0 8
24566: PPUSH
24567: CALL_OW 269
24571: NOT
24572: IFFALSE 24598
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24574: LD_VAR 0 8
24578: PPUSH
24579: LD_VAR 0 8
24583: PPUSH
24584: LD_VAR 0 2
24588: PPUSH
24589: CALL 25848 0 2
24593: PPUSH
24594: CALL_OW 431
// end ;
24598: GO 24559
24600: POP
24601: POP
// end ; for i = 1 to personel do
24602: LD_ADDR_VAR 0 8
24606: PUSH
24607: DOUBLE
24608: LD_INT 1
24610: DEC
24611: ST_TO_ADDR
24612: LD_VAR 0 6
24616: PUSH
24617: FOR_TO
24618: IFFALSE 25682
// begin if i > 4 then
24620: LD_VAR 0 8
24624: PUSH
24625: LD_INT 4
24627: GREATER
24628: IFFALSE 24632
// break ;
24630: GO 25682
// case i of 1 :
24632: LD_VAR 0 8
24636: PUSH
24637: LD_INT 1
24639: DOUBLE
24640: EQUAL
24641: IFTRUE 24645
24643: GO 24725
24645: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24646: LD_ADDR_VAR 0 12
24650: PUSH
24651: LD_VAR 0 18
24655: PPUSH
24656: LD_INT 22
24658: PUSH
24659: LD_VAR 0 16
24663: PUSH
24664: EMPTY
24665: LIST
24666: LIST
24667: PUSH
24668: LD_INT 58
24670: PUSH
24671: EMPTY
24672: LIST
24673: PUSH
24674: LD_INT 2
24676: PUSH
24677: LD_INT 30
24679: PUSH
24680: LD_INT 32
24682: PUSH
24683: EMPTY
24684: LIST
24685: LIST
24686: PUSH
24687: LD_INT 30
24689: PUSH
24690: LD_INT 4
24692: PUSH
24693: EMPTY
24694: LIST
24695: LIST
24696: PUSH
24697: LD_INT 30
24699: PUSH
24700: LD_INT 5
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: LIST
24711: LIST
24712: PUSH
24713: EMPTY
24714: LIST
24715: LIST
24716: LIST
24717: PPUSH
24718: CALL_OW 72
24722: ST_TO_ADDR
24723: GO 24947
24725: LD_INT 2
24727: DOUBLE
24728: EQUAL
24729: IFTRUE 24733
24731: GO 24795
24733: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24734: LD_ADDR_VAR 0 12
24738: PUSH
24739: LD_VAR 0 18
24743: PPUSH
24744: LD_INT 22
24746: PUSH
24747: LD_VAR 0 16
24751: PUSH
24752: EMPTY
24753: LIST
24754: LIST
24755: PUSH
24756: LD_INT 2
24758: PUSH
24759: LD_INT 30
24761: PUSH
24762: LD_INT 0
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: PUSH
24769: LD_INT 30
24771: PUSH
24772: LD_INT 1
24774: PUSH
24775: EMPTY
24776: LIST
24777: LIST
24778: PUSH
24779: EMPTY
24780: LIST
24781: LIST
24782: LIST
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: PPUSH
24788: CALL_OW 72
24792: ST_TO_ADDR
24793: GO 24947
24795: LD_INT 3
24797: DOUBLE
24798: EQUAL
24799: IFTRUE 24803
24801: GO 24865
24803: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24804: LD_ADDR_VAR 0 12
24808: PUSH
24809: LD_VAR 0 18
24813: PPUSH
24814: LD_INT 22
24816: PUSH
24817: LD_VAR 0 16
24821: PUSH
24822: EMPTY
24823: LIST
24824: LIST
24825: PUSH
24826: LD_INT 2
24828: PUSH
24829: LD_INT 30
24831: PUSH
24832: LD_INT 2
24834: PUSH
24835: EMPTY
24836: LIST
24837: LIST
24838: PUSH
24839: LD_INT 30
24841: PUSH
24842: LD_INT 3
24844: PUSH
24845: EMPTY
24846: LIST
24847: LIST
24848: PUSH
24849: EMPTY
24850: LIST
24851: LIST
24852: LIST
24853: PUSH
24854: EMPTY
24855: LIST
24856: LIST
24857: PPUSH
24858: CALL_OW 72
24862: ST_TO_ADDR
24863: GO 24947
24865: LD_INT 4
24867: DOUBLE
24868: EQUAL
24869: IFTRUE 24873
24871: GO 24946
24873: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24874: LD_ADDR_VAR 0 12
24878: PUSH
24879: LD_VAR 0 18
24883: PPUSH
24884: LD_INT 22
24886: PUSH
24887: LD_VAR 0 16
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PUSH
24896: LD_INT 2
24898: PUSH
24899: LD_INT 30
24901: PUSH
24902: LD_INT 6
24904: PUSH
24905: EMPTY
24906: LIST
24907: LIST
24908: PUSH
24909: LD_INT 30
24911: PUSH
24912: LD_INT 7
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: PUSH
24919: LD_INT 30
24921: PUSH
24922: LD_INT 8
24924: PUSH
24925: EMPTY
24926: LIST
24927: LIST
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: LIST
24933: LIST
24934: PUSH
24935: EMPTY
24936: LIST
24937: LIST
24938: PPUSH
24939: CALL_OW 72
24943: ST_TO_ADDR
24944: GO 24947
24946: POP
// if i = 1 then
24947: LD_VAR 0 8
24951: PUSH
24952: LD_INT 1
24954: EQUAL
24955: IFFALSE 25066
// begin tmp := [ ] ;
24957: LD_ADDR_VAR 0 19
24961: PUSH
24962: EMPTY
24963: ST_TO_ADDR
// for j in f do
24964: LD_ADDR_VAR 0 9
24968: PUSH
24969: LD_VAR 0 12
24973: PUSH
24974: FOR_IN
24975: IFFALSE 25048
// if GetBType ( j ) = b_bunker then
24977: LD_VAR 0 9
24981: PPUSH
24982: CALL_OW 266
24986: PUSH
24987: LD_INT 32
24989: EQUAL
24990: IFFALSE 25017
// tmp := Insert ( tmp , 1 , j ) else
24992: LD_ADDR_VAR 0 19
24996: PUSH
24997: LD_VAR 0 19
25001: PPUSH
25002: LD_INT 1
25004: PPUSH
25005: LD_VAR 0 9
25009: PPUSH
25010: CALL_OW 2
25014: ST_TO_ADDR
25015: GO 25046
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25017: LD_ADDR_VAR 0 19
25021: PUSH
25022: LD_VAR 0 19
25026: PPUSH
25027: LD_VAR 0 19
25031: PUSH
25032: LD_INT 1
25034: PLUS
25035: PPUSH
25036: LD_VAR 0 9
25040: PPUSH
25041: CALL_OW 2
25045: ST_TO_ADDR
25046: GO 24974
25048: POP
25049: POP
// if tmp then
25050: LD_VAR 0 19
25054: IFFALSE 25066
// f := tmp ;
25056: LD_ADDR_VAR 0 12
25060: PUSH
25061: LD_VAR 0 19
25065: ST_TO_ADDR
// end ; x := personel [ i ] ;
25066: LD_ADDR_VAR 0 13
25070: PUSH
25071: LD_VAR 0 6
25075: PUSH
25076: LD_VAR 0 8
25080: ARRAY
25081: ST_TO_ADDR
// if x = - 1 then
25082: LD_VAR 0 13
25086: PUSH
25087: LD_INT 1
25089: NEG
25090: EQUAL
25091: IFFALSE 25300
// begin for j in f do
25093: LD_ADDR_VAR 0 9
25097: PUSH
25098: LD_VAR 0 12
25102: PUSH
25103: FOR_IN
25104: IFFALSE 25296
// repeat InitHc ;
25106: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25110: LD_VAR 0 9
25114: PPUSH
25115: CALL_OW 266
25119: PUSH
25120: LD_INT 5
25122: EQUAL
25123: IFFALSE 25193
// begin if UnitsInside ( j ) < 3 then
25125: LD_VAR 0 9
25129: PPUSH
25130: CALL_OW 313
25134: PUSH
25135: LD_INT 3
25137: LESS
25138: IFFALSE 25174
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25140: LD_INT 0
25142: PPUSH
25143: LD_INT 5
25145: PUSH
25146: LD_INT 8
25148: PUSH
25149: LD_INT 9
25151: PUSH
25152: EMPTY
25153: LIST
25154: LIST
25155: LIST
25156: PUSH
25157: LD_VAR 0 17
25161: ARRAY
25162: PPUSH
25163: LD_VAR 0 4
25167: PPUSH
25168: CALL_OW 380
25172: GO 25191
// PrepareHuman ( false , i , skill ) ;
25174: LD_INT 0
25176: PPUSH
25177: LD_VAR 0 8
25181: PPUSH
25182: LD_VAR 0 4
25186: PPUSH
25187: CALL_OW 380
// end else
25191: GO 25210
// PrepareHuman ( false , i , skill ) ;
25193: LD_INT 0
25195: PPUSH
25196: LD_VAR 0 8
25200: PPUSH
25201: LD_VAR 0 4
25205: PPUSH
25206: CALL_OW 380
// un := CreateHuman ;
25210: LD_ADDR_VAR 0 14
25214: PUSH
25215: CALL_OW 44
25219: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25220: LD_ADDR_VAR 0 7
25224: PUSH
25225: LD_VAR 0 7
25229: PPUSH
25230: LD_INT 1
25232: PPUSH
25233: LD_VAR 0 14
25237: PPUSH
25238: CALL_OW 2
25242: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25243: LD_VAR 0 14
25247: PPUSH
25248: LD_VAR 0 9
25252: PPUSH
25253: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25257: LD_VAR 0 9
25261: PPUSH
25262: CALL_OW 313
25266: PUSH
25267: LD_INT 6
25269: EQUAL
25270: PUSH
25271: LD_VAR 0 9
25275: PPUSH
25276: CALL_OW 266
25280: PUSH
25281: LD_INT 32
25283: PUSH
25284: LD_INT 31
25286: PUSH
25287: EMPTY
25288: LIST
25289: LIST
25290: IN
25291: OR
25292: IFFALSE 25106
25294: GO 25103
25296: POP
25297: POP
// end else
25298: GO 25680
// for j = 1 to x do
25300: LD_ADDR_VAR 0 9
25304: PUSH
25305: DOUBLE
25306: LD_INT 1
25308: DEC
25309: ST_TO_ADDR
25310: LD_VAR 0 13
25314: PUSH
25315: FOR_TO
25316: IFFALSE 25678
// begin InitHc ;
25318: CALL_OW 19
// if not f then
25322: LD_VAR 0 12
25326: NOT
25327: IFFALSE 25416
// begin PrepareHuman ( false , i , skill ) ;
25329: LD_INT 0
25331: PPUSH
25332: LD_VAR 0 8
25336: PPUSH
25337: LD_VAR 0 4
25341: PPUSH
25342: CALL_OW 380
// un := CreateHuman ;
25346: LD_ADDR_VAR 0 14
25350: PUSH
25351: CALL_OW 44
25355: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25356: LD_ADDR_VAR 0 7
25360: PUSH
25361: LD_VAR 0 7
25365: PPUSH
25366: LD_INT 1
25368: PPUSH
25369: LD_VAR 0 14
25373: PPUSH
25374: CALL_OW 2
25378: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25379: LD_VAR 0 14
25383: PPUSH
25384: LD_VAR 0 1
25388: PPUSH
25389: CALL_OW 250
25393: PPUSH
25394: LD_VAR 0 1
25398: PPUSH
25399: CALL_OW 251
25403: PPUSH
25404: LD_INT 10
25406: PPUSH
25407: LD_INT 0
25409: PPUSH
25410: CALL_OW 50
// continue ;
25414: GO 25315
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25416: LD_VAR 0 12
25420: PUSH
25421: LD_INT 1
25423: ARRAY
25424: PPUSH
25425: CALL_OW 313
25429: PUSH
25430: LD_VAR 0 12
25434: PUSH
25435: LD_INT 1
25437: ARRAY
25438: PPUSH
25439: CALL_OW 266
25443: PUSH
25444: LD_INT 32
25446: PUSH
25447: LD_INT 31
25449: PUSH
25450: EMPTY
25451: LIST
25452: LIST
25453: IN
25454: AND
25455: PUSH
25456: LD_VAR 0 12
25460: PUSH
25461: LD_INT 1
25463: ARRAY
25464: PPUSH
25465: CALL_OW 313
25469: PUSH
25470: LD_INT 6
25472: EQUAL
25473: OR
25474: IFFALSE 25494
// f := Delete ( f , 1 ) ;
25476: LD_ADDR_VAR 0 12
25480: PUSH
25481: LD_VAR 0 12
25485: PPUSH
25486: LD_INT 1
25488: PPUSH
25489: CALL_OW 3
25493: ST_TO_ADDR
// if not f then
25494: LD_VAR 0 12
25498: NOT
25499: IFFALSE 25517
// begin x := x + 2 ;
25501: LD_ADDR_VAR 0 13
25505: PUSH
25506: LD_VAR 0 13
25510: PUSH
25511: LD_INT 2
25513: PLUS
25514: ST_TO_ADDR
// continue ;
25515: GO 25315
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25517: LD_VAR 0 12
25521: PUSH
25522: LD_INT 1
25524: ARRAY
25525: PPUSH
25526: CALL_OW 266
25530: PUSH
25531: LD_INT 5
25533: EQUAL
25534: IFFALSE 25608
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25536: LD_VAR 0 12
25540: PUSH
25541: LD_INT 1
25543: ARRAY
25544: PPUSH
25545: CALL_OW 313
25549: PUSH
25550: LD_INT 3
25552: LESS
25553: IFFALSE 25589
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25555: LD_INT 0
25557: PPUSH
25558: LD_INT 5
25560: PUSH
25561: LD_INT 8
25563: PUSH
25564: LD_INT 9
25566: PUSH
25567: EMPTY
25568: LIST
25569: LIST
25570: LIST
25571: PUSH
25572: LD_VAR 0 17
25576: ARRAY
25577: PPUSH
25578: LD_VAR 0 4
25582: PPUSH
25583: CALL_OW 380
25587: GO 25606
// PrepareHuman ( false , i , skill ) ;
25589: LD_INT 0
25591: PPUSH
25592: LD_VAR 0 8
25596: PPUSH
25597: LD_VAR 0 4
25601: PPUSH
25602: CALL_OW 380
// end else
25606: GO 25625
// PrepareHuman ( false , i , skill ) ;
25608: LD_INT 0
25610: PPUSH
25611: LD_VAR 0 8
25615: PPUSH
25616: LD_VAR 0 4
25620: PPUSH
25621: CALL_OW 380
// un := CreateHuman ;
25625: LD_ADDR_VAR 0 14
25629: PUSH
25630: CALL_OW 44
25634: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25635: LD_ADDR_VAR 0 7
25639: PUSH
25640: LD_VAR 0 7
25644: PPUSH
25645: LD_INT 1
25647: PPUSH
25648: LD_VAR 0 14
25652: PPUSH
25653: CALL_OW 2
25657: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25658: LD_VAR 0 14
25662: PPUSH
25663: LD_VAR 0 12
25667: PUSH
25668: LD_INT 1
25670: ARRAY
25671: PPUSH
25672: CALL_OW 52
// end ;
25676: GO 25315
25678: POP
25679: POP
// end ;
25680: GO 24617
25682: POP
25683: POP
// result := result ^ buildings ;
25684: LD_ADDR_VAR 0 7
25688: PUSH
25689: LD_VAR 0 7
25693: PUSH
25694: LD_VAR 0 18
25698: ADD
25699: ST_TO_ADDR
// end else
25700: GO 25843
// begin for i = 1 to personel do
25702: LD_ADDR_VAR 0 8
25706: PUSH
25707: DOUBLE
25708: LD_INT 1
25710: DEC
25711: ST_TO_ADDR
25712: LD_VAR 0 6
25716: PUSH
25717: FOR_TO
25718: IFFALSE 25841
// begin if i > 4 then
25720: LD_VAR 0 8
25724: PUSH
25725: LD_INT 4
25727: GREATER
25728: IFFALSE 25732
// break ;
25730: GO 25841
// x := personel [ i ] ;
25732: LD_ADDR_VAR 0 13
25736: PUSH
25737: LD_VAR 0 6
25741: PUSH
25742: LD_VAR 0 8
25746: ARRAY
25747: ST_TO_ADDR
// if x = - 1 then
25748: LD_VAR 0 13
25752: PUSH
25753: LD_INT 1
25755: NEG
25756: EQUAL
25757: IFFALSE 25761
// continue ;
25759: GO 25717
// PrepareHuman ( false , i , skill ) ;
25761: LD_INT 0
25763: PPUSH
25764: LD_VAR 0 8
25768: PPUSH
25769: LD_VAR 0 4
25773: PPUSH
25774: CALL_OW 380
// un := CreateHuman ;
25778: LD_ADDR_VAR 0 14
25782: PUSH
25783: CALL_OW 44
25787: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25788: LD_VAR 0 14
25792: PPUSH
25793: LD_VAR 0 1
25797: PPUSH
25798: CALL_OW 250
25802: PPUSH
25803: LD_VAR 0 1
25807: PPUSH
25808: CALL_OW 251
25812: PPUSH
25813: LD_INT 10
25815: PPUSH
25816: LD_INT 0
25818: PPUSH
25819: CALL_OW 50
// result := result ^ un ;
25823: LD_ADDR_VAR 0 7
25827: PUSH
25828: LD_VAR 0 7
25832: PUSH
25833: LD_VAR 0 14
25837: ADD
25838: ST_TO_ADDR
// end ;
25839: GO 25717
25841: POP
25842: POP
// end ; end ;
25843: LD_VAR 0 7
25847: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25848: LD_INT 0
25850: PPUSH
25851: PPUSH
25852: PPUSH
25853: PPUSH
25854: PPUSH
25855: PPUSH
25856: PPUSH
25857: PPUSH
25858: PPUSH
25859: PPUSH
25860: PPUSH
25861: PPUSH
25862: PPUSH
25863: PPUSH
25864: PPUSH
25865: PPUSH
// result := false ;
25866: LD_ADDR_VAR 0 3
25870: PUSH
25871: LD_INT 0
25873: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25874: LD_VAR 0 1
25878: NOT
25879: PUSH
25880: LD_VAR 0 1
25884: PPUSH
25885: CALL_OW 266
25889: PUSH
25890: LD_INT 32
25892: PUSH
25893: LD_INT 33
25895: PUSH
25896: EMPTY
25897: LIST
25898: LIST
25899: IN
25900: NOT
25901: OR
25902: IFFALSE 25906
// exit ;
25904: GO 27015
// nat := GetNation ( tower ) ;
25906: LD_ADDR_VAR 0 12
25910: PUSH
25911: LD_VAR 0 1
25915: PPUSH
25916: CALL_OW 248
25920: ST_TO_ADDR
// side := GetSide ( tower ) ;
25921: LD_ADDR_VAR 0 16
25925: PUSH
25926: LD_VAR 0 1
25930: PPUSH
25931: CALL_OW 255
25935: ST_TO_ADDR
// x := GetX ( tower ) ;
25936: LD_ADDR_VAR 0 10
25940: PUSH
25941: LD_VAR 0 1
25945: PPUSH
25946: CALL_OW 250
25950: ST_TO_ADDR
// y := GetY ( tower ) ;
25951: LD_ADDR_VAR 0 11
25955: PUSH
25956: LD_VAR 0 1
25960: PPUSH
25961: CALL_OW 251
25965: ST_TO_ADDR
// if not x or not y then
25966: LD_VAR 0 10
25970: NOT
25971: PUSH
25972: LD_VAR 0 11
25976: NOT
25977: OR
25978: IFFALSE 25982
// exit ;
25980: GO 27015
// weapon := 0 ;
25982: LD_ADDR_VAR 0 18
25986: PUSH
25987: LD_INT 0
25989: ST_TO_ADDR
// fac_list := [ ] ;
25990: LD_ADDR_VAR 0 17
25994: PUSH
25995: EMPTY
25996: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
25997: LD_ADDR_VAR 0 6
26001: PUSH
26002: LD_VAR 0 1
26006: PPUSH
26007: CALL_OW 274
26011: PPUSH
26012: LD_VAR 0 2
26016: PPUSH
26017: LD_INT 0
26019: PPUSH
26020: CALL 23586 0 3
26024: PPUSH
26025: LD_INT 30
26027: PUSH
26028: LD_INT 3
26030: PUSH
26031: EMPTY
26032: LIST
26033: LIST
26034: PPUSH
26035: CALL_OW 72
26039: ST_TO_ADDR
// if not factories then
26040: LD_VAR 0 6
26044: NOT
26045: IFFALSE 26049
// exit ;
26047: GO 27015
// for i in factories do
26049: LD_ADDR_VAR 0 8
26053: PUSH
26054: LD_VAR 0 6
26058: PUSH
26059: FOR_IN
26060: IFFALSE 26085
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26062: LD_ADDR_VAR 0 17
26066: PUSH
26067: LD_VAR 0 17
26071: PUSH
26072: LD_VAR 0 8
26076: PPUSH
26077: CALL_OW 478
26081: UNION
26082: ST_TO_ADDR
26083: GO 26059
26085: POP
26086: POP
// if not fac_list then
26087: LD_VAR 0 17
26091: NOT
26092: IFFALSE 26096
// exit ;
26094: GO 27015
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26096: LD_ADDR_VAR 0 5
26100: PUSH
26101: LD_INT 4
26103: PUSH
26104: LD_INT 5
26106: PUSH
26107: LD_INT 9
26109: PUSH
26110: LD_INT 10
26112: PUSH
26113: LD_INT 6
26115: PUSH
26116: LD_INT 7
26118: PUSH
26119: LD_INT 11
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: LIST
26126: LIST
26127: LIST
26128: LIST
26129: LIST
26130: PUSH
26131: LD_INT 27
26133: PUSH
26134: LD_INT 28
26136: PUSH
26137: LD_INT 26
26139: PUSH
26140: LD_INT 30
26142: PUSH
26143: EMPTY
26144: LIST
26145: LIST
26146: LIST
26147: LIST
26148: PUSH
26149: LD_INT 43
26151: PUSH
26152: LD_INT 44
26154: PUSH
26155: LD_INT 46
26157: PUSH
26158: LD_INT 45
26160: PUSH
26161: LD_INT 47
26163: PUSH
26164: LD_INT 49
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: LIST
26171: LIST
26172: LIST
26173: LIST
26174: PUSH
26175: EMPTY
26176: LIST
26177: LIST
26178: LIST
26179: PUSH
26180: LD_VAR 0 12
26184: ARRAY
26185: ST_TO_ADDR
// list := list isect fac_list ;
26186: LD_ADDR_VAR 0 5
26190: PUSH
26191: LD_VAR 0 5
26195: PUSH
26196: LD_VAR 0 17
26200: ISECT
26201: ST_TO_ADDR
// if not list then
26202: LD_VAR 0 5
26206: NOT
26207: IFFALSE 26211
// exit ;
26209: GO 27015
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26211: LD_VAR 0 12
26215: PUSH
26216: LD_INT 3
26218: EQUAL
26219: PUSH
26220: LD_INT 49
26222: PUSH
26223: LD_VAR 0 5
26227: IN
26228: AND
26229: PUSH
26230: LD_INT 31
26232: PPUSH
26233: LD_VAR 0 16
26237: PPUSH
26238: CALL_OW 321
26242: PUSH
26243: LD_INT 2
26245: EQUAL
26246: AND
26247: IFFALSE 26307
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26249: LD_INT 22
26251: PUSH
26252: LD_VAR 0 16
26256: PUSH
26257: EMPTY
26258: LIST
26259: LIST
26260: PUSH
26261: LD_INT 35
26263: PUSH
26264: LD_INT 49
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: PUSH
26271: LD_INT 91
26273: PUSH
26274: LD_VAR 0 1
26278: PUSH
26279: LD_INT 10
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: LIST
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: LIST
26291: PPUSH
26292: CALL_OW 69
26296: NOT
26297: IFFALSE 26307
// weapon := ru_time_lapser ;
26299: LD_ADDR_VAR 0 18
26303: PUSH
26304: LD_INT 49
26306: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26307: LD_VAR 0 12
26311: PUSH
26312: LD_INT 1
26314: PUSH
26315: LD_INT 2
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: IN
26322: PUSH
26323: LD_INT 11
26325: PUSH
26326: LD_VAR 0 5
26330: IN
26331: PUSH
26332: LD_INT 30
26334: PUSH
26335: LD_VAR 0 5
26339: IN
26340: OR
26341: AND
26342: PUSH
26343: LD_INT 6
26345: PPUSH
26346: LD_VAR 0 16
26350: PPUSH
26351: CALL_OW 321
26355: PUSH
26356: LD_INT 2
26358: EQUAL
26359: AND
26360: IFFALSE 26525
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26362: LD_INT 22
26364: PUSH
26365: LD_VAR 0 16
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: PUSH
26374: LD_INT 2
26376: PUSH
26377: LD_INT 35
26379: PUSH
26380: LD_INT 11
26382: PUSH
26383: EMPTY
26384: LIST
26385: LIST
26386: PUSH
26387: LD_INT 35
26389: PUSH
26390: LD_INT 30
26392: PUSH
26393: EMPTY
26394: LIST
26395: LIST
26396: PUSH
26397: EMPTY
26398: LIST
26399: LIST
26400: LIST
26401: PUSH
26402: LD_INT 91
26404: PUSH
26405: LD_VAR 0 1
26409: PUSH
26410: LD_INT 18
26412: PUSH
26413: EMPTY
26414: LIST
26415: LIST
26416: LIST
26417: PUSH
26418: EMPTY
26419: LIST
26420: LIST
26421: LIST
26422: PPUSH
26423: CALL_OW 69
26427: NOT
26428: PUSH
26429: LD_INT 22
26431: PUSH
26432: LD_VAR 0 16
26436: PUSH
26437: EMPTY
26438: LIST
26439: LIST
26440: PUSH
26441: LD_INT 2
26443: PUSH
26444: LD_INT 30
26446: PUSH
26447: LD_INT 32
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: PUSH
26454: LD_INT 30
26456: PUSH
26457: LD_INT 33
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: LIST
26468: PUSH
26469: LD_INT 91
26471: PUSH
26472: LD_VAR 0 1
26476: PUSH
26477: LD_INT 12
26479: PUSH
26480: EMPTY
26481: LIST
26482: LIST
26483: LIST
26484: PUSH
26485: EMPTY
26486: LIST
26487: LIST
26488: LIST
26489: PUSH
26490: EMPTY
26491: LIST
26492: PPUSH
26493: CALL_OW 69
26497: PUSH
26498: LD_INT 2
26500: GREATER
26501: AND
26502: IFFALSE 26525
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26504: LD_ADDR_VAR 0 18
26508: PUSH
26509: LD_INT 11
26511: PUSH
26512: LD_INT 30
26514: PUSH
26515: EMPTY
26516: LIST
26517: LIST
26518: PUSH
26519: LD_VAR 0 12
26523: ARRAY
26524: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26525: LD_VAR 0 18
26529: NOT
26530: PUSH
26531: LD_INT 40
26533: PPUSH
26534: LD_VAR 0 16
26538: PPUSH
26539: CALL_OW 321
26543: PUSH
26544: LD_INT 2
26546: EQUAL
26547: AND
26548: PUSH
26549: LD_INT 7
26551: PUSH
26552: LD_VAR 0 5
26556: IN
26557: PUSH
26558: LD_INT 28
26560: PUSH
26561: LD_VAR 0 5
26565: IN
26566: OR
26567: PUSH
26568: LD_INT 45
26570: PUSH
26571: LD_VAR 0 5
26575: IN
26576: OR
26577: AND
26578: IFFALSE 26832
// begin hex := GetHexInfo ( x , y ) ;
26580: LD_ADDR_VAR 0 4
26584: PUSH
26585: LD_VAR 0 10
26589: PPUSH
26590: LD_VAR 0 11
26594: PPUSH
26595: CALL_OW 546
26599: ST_TO_ADDR
// if hex [ 1 ] then
26600: LD_VAR 0 4
26604: PUSH
26605: LD_INT 1
26607: ARRAY
26608: IFFALSE 26612
// exit ;
26610: GO 27015
// height := hex [ 2 ] ;
26612: LD_ADDR_VAR 0 15
26616: PUSH
26617: LD_VAR 0 4
26621: PUSH
26622: LD_INT 2
26624: ARRAY
26625: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26626: LD_ADDR_VAR 0 14
26630: PUSH
26631: LD_INT 0
26633: PUSH
26634: LD_INT 2
26636: PUSH
26637: LD_INT 3
26639: PUSH
26640: LD_INT 5
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: LIST
26647: LIST
26648: ST_TO_ADDR
// for i in tmp do
26649: LD_ADDR_VAR 0 8
26653: PUSH
26654: LD_VAR 0 14
26658: PUSH
26659: FOR_IN
26660: IFFALSE 26830
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26662: LD_ADDR_VAR 0 9
26666: PUSH
26667: LD_VAR 0 10
26671: PPUSH
26672: LD_VAR 0 8
26676: PPUSH
26677: LD_INT 5
26679: PPUSH
26680: CALL_OW 272
26684: PUSH
26685: LD_VAR 0 11
26689: PPUSH
26690: LD_VAR 0 8
26694: PPUSH
26695: LD_INT 5
26697: PPUSH
26698: CALL_OW 273
26702: PUSH
26703: EMPTY
26704: LIST
26705: LIST
26706: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26707: LD_VAR 0 9
26711: PUSH
26712: LD_INT 1
26714: ARRAY
26715: PPUSH
26716: LD_VAR 0 9
26720: PUSH
26721: LD_INT 2
26723: ARRAY
26724: PPUSH
26725: CALL_OW 488
26729: IFFALSE 26828
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26731: LD_ADDR_VAR 0 4
26735: PUSH
26736: LD_VAR 0 9
26740: PUSH
26741: LD_INT 1
26743: ARRAY
26744: PPUSH
26745: LD_VAR 0 9
26749: PUSH
26750: LD_INT 2
26752: ARRAY
26753: PPUSH
26754: CALL_OW 546
26758: ST_TO_ADDR
// if hex [ 1 ] then
26759: LD_VAR 0 4
26763: PUSH
26764: LD_INT 1
26766: ARRAY
26767: IFFALSE 26771
// continue ;
26769: GO 26659
// h := hex [ 2 ] ;
26771: LD_ADDR_VAR 0 13
26775: PUSH
26776: LD_VAR 0 4
26780: PUSH
26781: LD_INT 2
26783: ARRAY
26784: ST_TO_ADDR
// if h + 7 < height then
26785: LD_VAR 0 13
26789: PUSH
26790: LD_INT 7
26792: PLUS
26793: PUSH
26794: LD_VAR 0 15
26798: LESS
26799: IFFALSE 26828
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26801: LD_ADDR_VAR 0 18
26805: PUSH
26806: LD_INT 7
26808: PUSH
26809: LD_INT 28
26811: PUSH
26812: LD_INT 45
26814: PUSH
26815: EMPTY
26816: LIST
26817: LIST
26818: LIST
26819: PUSH
26820: LD_VAR 0 12
26824: ARRAY
26825: ST_TO_ADDR
// break ;
26826: GO 26830
// end ; end ; end ;
26828: GO 26659
26830: POP
26831: POP
// end ; if not weapon then
26832: LD_VAR 0 18
26836: NOT
26837: IFFALSE 26897
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26839: LD_ADDR_VAR 0 5
26843: PUSH
26844: LD_VAR 0 5
26848: PUSH
26849: LD_INT 11
26851: PUSH
26852: LD_INT 30
26854: PUSH
26855: LD_INT 49
26857: PUSH
26858: EMPTY
26859: LIST
26860: LIST
26861: LIST
26862: DIFF
26863: ST_TO_ADDR
// if not list then
26864: LD_VAR 0 5
26868: NOT
26869: IFFALSE 26873
// exit ;
26871: GO 27015
// weapon := list [ rand ( 1 , list ) ] ;
26873: LD_ADDR_VAR 0 18
26877: PUSH
26878: LD_VAR 0 5
26882: PUSH
26883: LD_INT 1
26885: PPUSH
26886: LD_VAR 0 5
26890: PPUSH
26891: CALL_OW 12
26895: ARRAY
26896: ST_TO_ADDR
// end ; if weapon then
26897: LD_VAR 0 18
26901: IFFALSE 27015
// begin tmp := CostOfWeapon ( weapon ) ;
26903: LD_ADDR_VAR 0 14
26907: PUSH
26908: LD_VAR 0 18
26912: PPUSH
26913: CALL_OW 451
26917: ST_TO_ADDR
// j := GetBase ( tower ) ;
26918: LD_ADDR_VAR 0 9
26922: PUSH
26923: LD_VAR 0 1
26927: PPUSH
26928: CALL_OW 274
26932: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26933: LD_VAR 0 9
26937: PPUSH
26938: LD_INT 1
26940: PPUSH
26941: CALL_OW 275
26945: PUSH
26946: LD_VAR 0 14
26950: PUSH
26951: LD_INT 1
26953: ARRAY
26954: GREATEREQUAL
26955: PUSH
26956: LD_VAR 0 9
26960: PPUSH
26961: LD_INT 2
26963: PPUSH
26964: CALL_OW 275
26968: PUSH
26969: LD_VAR 0 14
26973: PUSH
26974: LD_INT 2
26976: ARRAY
26977: GREATEREQUAL
26978: AND
26979: PUSH
26980: LD_VAR 0 9
26984: PPUSH
26985: LD_INT 3
26987: PPUSH
26988: CALL_OW 275
26992: PUSH
26993: LD_VAR 0 14
26997: PUSH
26998: LD_INT 3
27000: ARRAY
27001: GREATEREQUAL
27002: AND
27003: IFFALSE 27015
// result := weapon ;
27005: LD_ADDR_VAR 0 3
27009: PUSH
27010: LD_VAR 0 18
27014: ST_TO_ADDR
// end ; end ;
27015: LD_VAR 0 3
27019: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27020: LD_INT 0
27022: PPUSH
27023: PPUSH
// result := true ;
27024: LD_ADDR_VAR 0 3
27028: PUSH
27029: LD_INT 1
27031: ST_TO_ADDR
// if array1 = array2 then
27032: LD_VAR 0 1
27036: PUSH
27037: LD_VAR 0 2
27041: EQUAL
27042: IFFALSE 27102
// begin for i = 1 to array1 do
27044: LD_ADDR_VAR 0 4
27048: PUSH
27049: DOUBLE
27050: LD_INT 1
27052: DEC
27053: ST_TO_ADDR
27054: LD_VAR 0 1
27058: PUSH
27059: FOR_TO
27060: IFFALSE 27098
// if array1 [ i ] <> array2 [ i ] then
27062: LD_VAR 0 1
27066: PUSH
27067: LD_VAR 0 4
27071: ARRAY
27072: PUSH
27073: LD_VAR 0 2
27077: PUSH
27078: LD_VAR 0 4
27082: ARRAY
27083: NONEQUAL
27084: IFFALSE 27096
// begin result := false ;
27086: LD_ADDR_VAR 0 3
27090: PUSH
27091: LD_INT 0
27093: ST_TO_ADDR
// break ;
27094: GO 27098
// end ;
27096: GO 27059
27098: POP
27099: POP
// end else
27100: GO 27110
// result := false ;
27102: LD_ADDR_VAR 0 3
27106: PUSH
27107: LD_INT 0
27109: ST_TO_ADDR
// end ;
27110: LD_VAR 0 3
27114: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
27115: LD_INT 0
27117: PPUSH
27118: PPUSH
// if not array1 or not array2 then
27119: LD_VAR 0 1
27123: NOT
27124: PUSH
27125: LD_VAR 0 2
27129: NOT
27130: OR
27131: IFFALSE 27135
// exit ;
27133: GO 27199
// result := true ;
27135: LD_ADDR_VAR 0 3
27139: PUSH
27140: LD_INT 1
27142: ST_TO_ADDR
// for i = 1 to array1 do
27143: LD_ADDR_VAR 0 4
27147: PUSH
27148: DOUBLE
27149: LD_INT 1
27151: DEC
27152: ST_TO_ADDR
27153: LD_VAR 0 1
27157: PUSH
27158: FOR_TO
27159: IFFALSE 27197
// if array1 [ i ] <> array2 [ i ] then
27161: LD_VAR 0 1
27165: PUSH
27166: LD_VAR 0 4
27170: ARRAY
27171: PUSH
27172: LD_VAR 0 2
27176: PUSH
27177: LD_VAR 0 4
27181: ARRAY
27182: NONEQUAL
27183: IFFALSE 27195
// begin result := false ;
27185: LD_ADDR_VAR 0 3
27189: PUSH
27190: LD_INT 0
27192: ST_TO_ADDR
// break ;
27193: GO 27197
// end ;
27195: GO 27158
27197: POP
27198: POP
// end ;
27199: LD_VAR 0 3
27203: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27204: LD_INT 0
27206: PPUSH
27207: PPUSH
27208: PPUSH
// pom := GetBase ( fac ) ;
27209: LD_ADDR_VAR 0 5
27213: PUSH
27214: LD_VAR 0 1
27218: PPUSH
27219: CALL_OW 274
27223: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27224: LD_ADDR_VAR 0 4
27228: PUSH
27229: LD_VAR 0 2
27233: PUSH
27234: LD_INT 1
27236: ARRAY
27237: PPUSH
27238: LD_VAR 0 2
27242: PUSH
27243: LD_INT 2
27245: ARRAY
27246: PPUSH
27247: LD_VAR 0 2
27251: PUSH
27252: LD_INT 3
27254: ARRAY
27255: PPUSH
27256: LD_VAR 0 2
27260: PUSH
27261: LD_INT 4
27263: ARRAY
27264: PPUSH
27265: CALL_OW 449
27269: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27270: LD_ADDR_VAR 0 3
27274: PUSH
27275: LD_VAR 0 5
27279: PPUSH
27280: LD_INT 1
27282: PPUSH
27283: CALL_OW 275
27287: PUSH
27288: LD_VAR 0 4
27292: PUSH
27293: LD_INT 1
27295: ARRAY
27296: GREATEREQUAL
27297: PUSH
27298: LD_VAR 0 5
27302: PPUSH
27303: LD_INT 2
27305: PPUSH
27306: CALL_OW 275
27310: PUSH
27311: LD_VAR 0 4
27315: PUSH
27316: LD_INT 2
27318: ARRAY
27319: GREATEREQUAL
27320: AND
27321: PUSH
27322: LD_VAR 0 5
27326: PPUSH
27327: LD_INT 3
27329: PPUSH
27330: CALL_OW 275
27334: PUSH
27335: LD_VAR 0 4
27339: PUSH
27340: LD_INT 3
27342: ARRAY
27343: GREATEREQUAL
27344: AND
27345: ST_TO_ADDR
// end ;
27346: LD_VAR 0 3
27350: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27351: LD_INT 0
27353: PPUSH
27354: PPUSH
27355: PPUSH
27356: PPUSH
// pom := GetBase ( building ) ;
27357: LD_ADDR_VAR 0 3
27361: PUSH
27362: LD_VAR 0 1
27366: PPUSH
27367: CALL_OW 274
27371: ST_TO_ADDR
// if not pom then
27372: LD_VAR 0 3
27376: NOT
27377: IFFALSE 27381
// exit ;
27379: GO 27551
// btype := GetBType ( building ) ;
27381: LD_ADDR_VAR 0 5
27385: PUSH
27386: LD_VAR 0 1
27390: PPUSH
27391: CALL_OW 266
27395: ST_TO_ADDR
// if btype = b_armoury then
27396: LD_VAR 0 5
27400: PUSH
27401: LD_INT 4
27403: EQUAL
27404: IFFALSE 27414
// btype := b_barracks ;
27406: LD_ADDR_VAR 0 5
27410: PUSH
27411: LD_INT 5
27413: ST_TO_ADDR
// if btype = b_depot then
27414: LD_VAR 0 5
27418: PUSH
27419: LD_INT 0
27421: EQUAL
27422: IFFALSE 27432
// btype := b_warehouse ;
27424: LD_ADDR_VAR 0 5
27428: PUSH
27429: LD_INT 1
27431: ST_TO_ADDR
// if btype = b_workshop then
27432: LD_VAR 0 5
27436: PUSH
27437: LD_INT 2
27439: EQUAL
27440: IFFALSE 27450
// btype := b_factory ;
27442: LD_ADDR_VAR 0 5
27446: PUSH
27447: LD_INT 3
27449: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27450: LD_ADDR_VAR 0 4
27454: PUSH
27455: LD_VAR 0 5
27459: PPUSH
27460: LD_VAR 0 1
27464: PPUSH
27465: CALL_OW 248
27469: PPUSH
27470: CALL_OW 450
27474: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27475: LD_ADDR_VAR 0 2
27479: PUSH
27480: LD_VAR 0 3
27484: PPUSH
27485: LD_INT 1
27487: PPUSH
27488: CALL_OW 275
27492: PUSH
27493: LD_VAR 0 4
27497: PUSH
27498: LD_INT 1
27500: ARRAY
27501: GREATEREQUAL
27502: PUSH
27503: LD_VAR 0 3
27507: PPUSH
27508: LD_INT 2
27510: PPUSH
27511: CALL_OW 275
27515: PUSH
27516: LD_VAR 0 4
27520: PUSH
27521: LD_INT 2
27523: ARRAY
27524: GREATEREQUAL
27525: AND
27526: PUSH
27527: LD_VAR 0 3
27531: PPUSH
27532: LD_INT 3
27534: PPUSH
27535: CALL_OW 275
27539: PUSH
27540: LD_VAR 0 4
27544: PUSH
27545: LD_INT 3
27547: ARRAY
27548: GREATEREQUAL
27549: AND
27550: ST_TO_ADDR
// end ;
27551: LD_VAR 0 2
27555: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27556: LD_INT 0
27558: PPUSH
27559: PPUSH
27560: PPUSH
// pom := GetBase ( building ) ;
27561: LD_ADDR_VAR 0 4
27565: PUSH
27566: LD_VAR 0 1
27570: PPUSH
27571: CALL_OW 274
27575: ST_TO_ADDR
// if not pom then
27576: LD_VAR 0 4
27580: NOT
27581: IFFALSE 27585
// exit ;
27583: GO 27686
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27585: LD_ADDR_VAR 0 5
27589: PUSH
27590: LD_VAR 0 2
27594: PPUSH
27595: LD_VAR 0 1
27599: PPUSH
27600: CALL_OW 248
27604: PPUSH
27605: CALL_OW 450
27609: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27610: LD_ADDR_VAR 0 3
27614: PUSH
27615: LD_VAR 0 4
27619: PPUSH
27620: LD_INT 1
27622: PPUSH
27623: CALL_OW 275
27627: PUSH
27628: LD_VAR 0 5
27632: PUSH
27633: LD_INT 1
27635: ARRAY
27636: GREATEREQUAL
27637: PUSH
27638: LD_VAR 0 4
27642: PPUSH
27643: LD_INT 2
27645: PPUSH
27646: CALL_OW 275
27650: PUSH
27651: LD_VAR 0 5
27655: PUSH
27656: LD_INT 2
27658: ARRAY
27659: GREATEREQUAL
27660: AND
27661: PUSH
27662: LD_VAR 0 4
27666: PPUSH
27667: LD_INT 3
27669: PPUSH
27670: CALL_OW 275
27674: PUSH
27675: LD_VAR 0 5
27679: PUSH
27680: LD_INT 3
27682: ARRAY
27683: GREATEREQUAL
27684: AND
27685: ST_TO_ADDR
// end ;
27686: LD_VAR 0 3
27690: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
27691: LD_INT 0
27693: PPUSH
27694: PPUSH
27695: PPUSH
27696: PPUSH
27697: PPUSH
27698: PPUSH
27699: PPUSH
27700: PPUSH
27701: PPUSH
27702: PPUSH
27703: PPUSH
// result := false ;
27704: LD_ADDR_VAR 0 8
27708: PUSH
27709: LD_INT 0
27711: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
27712: LD_VAR 0 5
27716: NOT
27717: PUSH
27718: LD_VAR 0 1
27722: NOT
27723: OR
27724: PUSH
27725: LD_VAR 0 2
27729: NOT
27730: OR
27731: PUSH
27732: LD_VAR 0 3
27736: NOT
27737: OR
27738: IFFALSE 27742
// exit ;
27740: GO 28556
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
27742: LD_ADDR_VAR 0 14
27746: PUSH
27747: LD_VAR 0 1
27751: PPUSH
27752: LD_VAR 0 2
27756: PPUSH
27757: LD_VAR 0 3
27761: PPUSH
27762: LD_VAR 0 4
27766: PPUSH
27767: LD_VAR 0 5
27771: PUSH
27772: LD_INT 1
27774: ARRAY
27775: PPUSH
27776: CALL_OW 248
27780: PPUSH
27781: LD_INT 0
27783: PPUSH
27784: CALL 29809 0 6
27788: ST_TO_ADDR
// if not hexes then
27789: LD_VAR 0 14
27793: NOT
27794: IFFALSE 27798
// exit ;
27796: GO 28556
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27798: LD_ADDR_VAR 0 17
27802: PUSH
27803: LD_VAR 0 5
27807: PPUSH
27808: LD_INT 22
27810: PUSH
27811: LD_VAR 0 13
27815: PPUSH
27816: CALL_OW 255
27820: PUSH
27821: EMPTY
27822: LIST
27823: LIST
27824: PUSH
27825: LD_INT 2
27827: PUSH
27828: LD_INT 30
27830: PUSH
27831: LD_INT 0
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 30
27840: PUSH
27841: LD_INT 1
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: EMPTY
27849: LIST
27850: LIST
27851: LIST
27852: PUSH
27853: EMPTY
27854: LIST
27855: LIST
27856: PPUSH
27857: CALL_OW 72
27861: ST_TO_ADDR
// for i = 1 to hexes do
27862: LD_ADDR_VAR 0 9
27866: PUSH
27867: DOUBLE
27868: LD_INT 1
27870: DEC
27871: ST_TO_ADDR
27872: LD_VAR 0 14
27876: PUSH
27877: FOR_TO
27878: IFFALSE 28554
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27880: LD_ADDR_VAR 0 13
27884: PUSH
27885: LD_VAR 0 14
27889: PUSH
27890: LD_VAR 0 9
27894: ARRAY
27895: PUSH
27896: LD_INT 1
27898: ARRAY
27899: PPUSH
27900: LD_VAR 0 14
27904: PUSH
27905: LD_VAR 0 9
27909: ARRAY
27910: PUSH
27911: LD_INT 2
27913: ARRAY
27914: PPUSH
27915: CALL_OW 428
27919: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27920: LD_VAR 0 14
27924: PUSH
27925: LD_VAR 0 9
27929: ARRAY
27930: PUSH
27931: LD_INT 1
27933: ARRAY
27934: PPUSH
27935: LD_VAR 0 14
27939: PUSH
27940: LD_VAR 0 9
27944: ARRAY
27945: PUSH
27946: LD_INT 2
27948: ARRAY
27949: PPUSH
27950: CALL_OW 351
27954: PUSH
27955: LD_VAR 0 14
27959: PUSH
27960: LD_VAR 0 9
27964: ARRAY
27965: PUSH
27966: LD_INT 1
27968: ARRAY
27969: PPUSH
27970: LD_VAR 0 14
27974: PUSH
27975: LD_VAR 0 9
27979: ARRAY
27980: PUSH
27981: LD_INT 2
27983: ARRAY
27984: PPUSH
27985: CALL_OW 488
27989: NOT
27990: OR
27991: PUSH
27992: LD_VAR 0 13
27996: PPUSH
27997: CALL_OW 247
28001: PUSH
28002: LD_INT 3
28004: EQUAL
28005: OR
28006: IFFALSE 28012
// exit ;
28008: POP
28009: POP
28010: GO 28556
// if not tmp then
28012: LD_VAR 0 13
28016: NOT
28017: IFFALSE 28021
// continue ;
28019: GO 27877
// result := true ;
28021: LD_ADDR_VAR 0 8
28025: PUSH
28026: LD_INT 1
28028: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
28029: LD_VAR 0 6
28033: PUSH
28034: LD_VAR 0 13
28038: PPUSH
28039: CALL_OW 247
28043: PUSH
28044: LD_INT 2
28046: EQUAL
28047: AND
28048: PUSH
28049: LD_VAR 0 13
28053: PPUSH
28054: CALL_OW 263
28058: PUSH
28059: LD_INT 1
28061: EQUAL
28062: AND
28063: IFFALSE 28227
// begin if IsDrivenBy ( tmp ) then
28065: LD_VAR 0 13
28069: PPUSH
28070: CALL_OW 311
28074: IFFALSE 28078
// continue ;
28076: GO 27877
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
28078: LD_VAR 0 6
28082: PPUSH
28083: LD_INT 3
28085: PUSH
28086: LD_INT 60
28088: PUSH
28089: EMPTY
28090: LIST
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: LD_INT 3
28098: PUSH
28099: LD_INT 55
28101: PUSH
28102: EMPTY
28103: LIST
28104: PUSH
28105: EMPTY
28106: LIST
28107: LIST
28108: PUSH
28109: EMPTY
28110: LIST
28111: LIST
28112: PPUSH
28113: CALL_OW 72
28117: IFFALSE 28225
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
28119: LD_ADDR_VAR 0 18
28123: PUSH
28124: LD_VAR 0 6
28128: PPUSH
28129: LD_INT 3
28131: PUSH
28132: LD_INT 60
28134: PUSH
28135: EMPTY
28136: LIST
28137: PUSH
28138: EMPTY
28139: LIST
28140: LIST
28141: PUSH
28142: LD_INT 3
28144: PUSH
28145: LD_INT 55
28147: PUSH
28148: EMPTY
28149: LIST
28150: PUSH
28151: EMPTY
28152: LIST
28153: LIST
28154: PUSH
28155: EMPTY
28156: LIST
28157: LIST
28158: PPUSH
28159: CALL_OW 72
28163: PUSH
28164: LD_INT 1
28166: ARRAY
28167: ST_TO_ADDR
// if IsInUnit ( driver ) then
28168: LD_VAR 0 18
28172: PPUSH
28173: CALL_OW 310
28177: IFFALSE 28188
// ComExit ( driver ) ;
28179: LD_VAR 0 18
28183: PPUSH
28184: CALL 53601 0 1
// AddComEnterUnit ( driver , tmp ) ;
28188: LD_VAR 0 18
28192: PPUSH
28193: LD_VAR 0 13
28197: PPUSH
28198: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
28202: LD_VAR 0 18
28206: PPUSH
28207: LD_VAR 0 7
28211: PPUSH
28212: CALL_OW 173
// AddComExitVehicle ( driver ) ;
28216: LD_VAR 0 18
28220: PPUSH
28221: CALL_OW 181
// end ; continue ;
28225: GO 27877
// end ; if not cleaners or not tmp in cleaners then
28227: LD_VAR 0 6
28231: NOT
28232: PUSH
28233: LD_VAR 0 13
28237: PUSH
28238: LD_VAR 0 6
28242: IN
28243: NOT
28244: OR
28245: IFFALSE 28552
// begin if dep then
28247: LD_VAR 0 17
28251: IFFALSE 28387
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28253: LD_ADDR_VAR 0 16
28257: PUSH
28258: LD_VAR 0 17
28262: PUSH
28263: LD_INT 1
28265: ARRAY
28266: PPUSH
28267: CALL_OW 250
28271: PPUSH
28272: LD_VAR 0 17
28276: PUSH
28277: LD_INT 1
28279: ARRAY
28280: PPUSH
28281: CALL_OW 254
28285: PPUSH
28286: LD_INT 5
28288: PPUSH
28289: CALL_OW 272
28293: PUSH
28294: LD_VAR 0 17
28298: PUSH
28299: LD_INT 1
28301: ARRAY
28302: PPUSH
28303: CALL_OW 251
28307: PPUSH
28308: LD_VAR 0 17
28312: PUSH
28313: LD_INT 1
28315: ARRAY
28316: PPUSH
28317: CALL_OW 254
28321: PPUSH
28322: LD_INT 5
28324: PPUSH
28325: CALL_OW 273
28329: PUSH
28330: EMPTY
28331: LIST
28332: LIST
28333: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28334: LD_VAR 0 16
28338: PUSH
28339: LD_INT 1
28341: ARRAY
28342: PPUSH
28343: LD_VAR 0 16
28347: PUSH
28348: LD_INT 2
28350: ARRAY
28351: PPUSH
28352: CALL_OW 488
28356: IFFALSE 28387
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28358: LD_VAR 0 13
28362: PPUSH
28363: LD_VAR 0 16
28367: PUSH
28368: LD_INT 1
28370: ARRAY
28371: PPUSH
28372: LD_VAR 0 16
28376: PUSH
28377: LD_INT 2
28379: ARRAY
28380: PPUSH
28381: CALL_OW 111
// continue ;
28385: GO 27877
// end ; end ; r := GetDir ( tmp ) ;
28387: LD_ADDR_VAR 0 15
28391: PUSH
28392: LD_VAR 0 13
28396: PPUSH
28397: CALL_OW 254
28401: ST_TO_ADDR
// if r = 5 then
28402: LD_VAR 0 15
28406: PUSH
28407: LD_INT 5
28409: EQUAL
28410: IFFALSE 28420
// r := 0 ;
28412: LD_ADDR_VAR 0 15
28416: PUSH
28417: LD_INT 0
28419: ST_TO_ADDR
// for j = r to 5 do
28420: LD_ADDR_VAR 0 10
28424: PUSH
28425: DOUBLE
28426: LD_VAR 0 15
28430: DEC
28431: ST_TO_ADDR
28432: LD_INT 5
28434: PUSH
28435: FOR_TO
28436: IFFALSE 28550
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28438: LD_ADDR_VAR 0 11
28442: PUSH
28443: LD_VAR 0 13
28447: PPUSH
28448: CALL_OW 250
28452: PPUSH
28453: LD_VAR 0 10
28457: PPUSH
28458: LD_INT 2
28460: PPUSH
28461: CALL_OW 272
28465: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28466: LD_ADDR_VAR 0 12
28470: PUSH
28471: LD_VAR 0 13
28475: PPUSH
28476: CALL_OW 251
28480: PPUSH
28481: LD_VAR 0 10
28485: PPUSH
28486: LD_INT 2
28488: PPUSH
28489: CALL_OW 273
28493: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28494: LD_VAR 0 11
28498: PPUSH
28499: LD_VAR 0 12
28503: PPUSH
28504: CALL_OW 488
28508: PUSH
28509: LD_VAR 0 11
28513: PPUSH
28514: LD_VAR 0 12
28518: PPUSH
28519: CALL_OW 428
28523: NOT
28524: AND
28525: IFFALSE 28548
// begin ComMoveXY ( tmp , _x , _y ) ;
28527: LD_VAR 0 13
28531: PPUSH
28532: LD_VAR 0 11
28536: PPUSH
28537: LD_VAR 0 12
28541: PPUSH
28542: CALL_OW 111
// break ;
28546: GO 28550
// end ; end ;
28548: GO 28435
28550: POP
28551: POP
// end ; end ;
28552: GO 27877
28554: POP
28555: POP
// end ;
28556: LD_VAR 0 8
28560: RET
// export function BuildingTechInvented ( side , btype ) ; begin
28561: LD_INT 0
28563: PPUSH
// result := true ;
28564: LD_ADDR_VAR 0 3
28568: PUSH
28569: LD_INT 1
28571: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
28572: LD_VAR 0 2
28576: PUSH
28577: LD_INT 24
28579: DOUBLE
28580: EQUAL
28581: IFTRUE 28591
28583: LD_INT 33
28585: DOUBLE
28586: EQUAL
28587: IFTRUE 28591
28589: GO 28616
28591: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
28592: LD_ADDR_VAR 0 3
28596: PUSH
28597: LD_INT 32
28599: PPUSH
28600: LD_VAR 0 1
28604: PPUSH
28605: CALL_OW 321
28609: PUSH
28610: LD_INT 2
28612: EQUAL
28613: ST_TO_ADDR
28614: GO 28932
28616: LD_INT 20
28618: DOUBLE
28619: EQUAL
28620: IFTRUE 28624
28622: GO 28649
28624: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
28625: LD_ADDR_VAR 0 3
28629: PUSH
28630: LD_INT 6
28632: PPUSH
28633: LD_VAR 0 1
28637: PPUSH
28638: CALL_OW 321
28642: PUSH
28643: LD_INT 2
28645: EQUAL
28646: ST_TO_ADDR
28647: GO 28932
28649: LD_INT 22
28651: DOUBLE
28652: EQUAL
28653: IFTRUE 28663
28655: LD_INT 36
28657: DOUBLE
28658: EQUAL
28659: IFTRUE 28663
28661: GO 28688
28663: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
28664: LD_ADDR_VAR 0 3
28668: PUSH
28669: LD_INT 15
28671: PPUSH
28672: LD_VAR 0 1
28676: PPUSH
28677: CALL_OW 321
28681: PUSH
28682: LD_INT 2
28684: EQUAL
28685: ST_TO_ADDR
28686: GO 28932
28688: LD_INT 30
28690: DOUBLE
28691: EQUAL
28692: IFTRUE 28696
28694: GO 28721
28696: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
28697: LD_ADDR_VAR 0 3
28701: PUSH
28702: LD_INT 20
28704: PPUSH
28705: LD_VAR 0 1
28709: PPUSH
28710: CALL_OW 321
28714: PUSH
28715: LD_INT 2
28717: EQUAL
28718: ST_TO_ADDR
28719: GO 28932
28721: LD_INT 28
28723: DOUBLE
28724: EQUAL
28725: IFTRUE 28735
28727: LD_INT 21
28729: DOUBLE
28730: EQUAL
28731: IFTRUE 28735
28733: GO 28760
28735: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
28736: LD_ADDR_VAR 0 3
28740: PUSH
28741: LD_INT 21
28743: PPUSH
28744: LD_VAR 0 1
28748: PPUSH
28749: CALL_OW 321
28753: PUSH
28754: LD_INT 2
28756: EQUAL
28757: ST_TO_ADDR
28758: GO 28932
28760: LD_INT 16
28762: DOUBLE
28763: EQUAL
28764: IFTRUE 28768
28766: GO 28793
28768: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
28769: LD_ADDR_VAR 0 3
28773: PUSH
28774: LD_INT 84
28776: PPUSH
28777: LD_VAR 0 1
28781: PPUSH
28782: CALL_OW 321
28786: PUSH
28787: LD_INT 2
28789: EQUAL
28790: ST_TO_ADDR
28791: GO 28932
28793: LD_INT 19
28795: DOUBLE
28796: EQUAL
28797: IFTRUE 28807
28799: LD_INT 23
28801: DOUBLE
28802: EQUAL
28803: IFTRUE 28807
28805: GO 28832
28807: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
28808: LD_ADDR_VAR 0 3
28812: PUSH
28813: LD_INT 83
28815: PPUSH
28816: LD_VAR 0 1
28820: PPUSH
28821: CALL_OW 321
28825: PUSH
28826: LD_INT 2
28828: EQUAL
28829: ST_TO_ADDR
28830: GO 28932
28832: LD_INT 17
28834: DOUBLE
28835: EQUAL
28836: IFTRUE 28840
28838: GO 28865
28840: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
28841: LD_ADDR_VAR 0 3
28845: PUSH
28846: LD_INT 39
28848: PPUSH
28849: LD_VAR 0 1
28853: PPUSH
28854: CALL_OW 321
28858: PUSH
28859: LD_INT 2
28861: EQUAL
28862: ST_TO_ADDR
28863: GO 28932
28865: LD_INT 18
28867: DOUBLE
28868: EQUAL
28869: IFTRUE 28873
28871: GO 28898
28873: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
28874: LD_ADDR_VAR 0 3
28878: PUSH
28879: LD_INT 40
28881: PPUSH
28882: LD_VAR 0 1
28886: PPUSH
28887: CALL_OW 321
28891: PUSH
28892: LD_INT 2
28894: EQUAL
28895: ST_TO_ADDR
28896: GO 28932
28898: LD_INT 27
28900: DOUBLE
28901: EQUAL
28902: IFTRUE 28906
28904: GO 28931
28906: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
28907: LD_ADDR_VAR 0 3
28911: PUSH
28912: LD_INT 35
28914: PPUSH
28915: LD_VAR 0 1
28919: PPUSH
28920: CALL_OW 321
28924: PUSH
28925: LD_INT 2
28927: EQUAL
28928: ST_TO_ADDR
28929: GO 28932
28931: POP
// end ;
28932: LD_VAR 0 3
28936: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
28937: LD_INT 0
28939: PPUSH
28940: PPUSH
28941: PPUSH
28942: PPUSH
28943: PPUSH
28944: PPUSH
28945: PPUSH
28946: PPUSH
28947: PPUSH
28948: PPUSH
28949: PPUSH
// result := false ;
28950: LD_ADDR_VAR 0 6
28954: PUSH
28955: LD_INT 0
28957: ST_TO_ADDR
// if btype = b_depot then
28958: LD_VAR 0 2
28962: PUSH
28963: LD_INT 0
28965: EQUAL
28966: IFFALSE 28978
// begin result := true ;
28968: LD_ADDR_VAR 0 6
28972: PUSH
28973: LD_INT 1
28975: ST_TO_ADDR
// exit ;
28976: GO 29804
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28978: LD_VAR 0 1
28982: NOT
28983: PUSH
28984: LD_VAR 0 1
28988: PPUSH
28989: CALL_OW 266
28993: PUSH
28994: LD_INT 0
28996: PUSH
28997: LD_INT 1
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: IN
29004: NOT
29005: OR
29006: PUSH
29007: LD_VAR 0 2
29011: NOT
29012: OR
29013: PUSH
29014: LD_VAR 0 5
29018: PUSH
29019: LD_INT 0
29021: PUSH
29022: LD_INT 1
29024: PUSH
29025: LD_INT 2
29027: PUSH
29028: LD_INT 3
29030: PUSH
29031: LD_INT 4
29033: PUSH
29034: LD_INT 5
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: IN
29045: NOT
29046: OR
29047: PUSH
29048: LD_VAR 0 3
29052: PPUSH
29053: LD_VAR 0 4
29057: PPUSH
29058: CALL_OW 488
29062: NOT
29063: OR
29064: IFFALSE 29068
// exit ;
29066: GO 29804
// side := GetSide ( depot ) ;
29068: LD_ADDR_VAR 0 9
29072: PUSH
29073: LD_VAR 0 1
29077: PPUSH
29078: CALL_OW 255
29082: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
29083: LD_VAR 0 9
29087: PPUSH
29088: LD_VAR 0 2
29092: PPUSH
29093: CALL 28561 0 2
29097: NOT
29098: IFFALSE 29102
// exit ;
29100: GO 29804
// pom := GetBase ( depot ) ;
29102: LD_ADDR_VAR 0 10
29106: PUSH
29107: LD_VAR 0 1
29111: PPUSH
29112: CALL_OW 274
29116: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
29117: LD_ADDR_VAR 0 11
29121: PUSH
29122: LD_VAR 0 2
29126: PPUSH
29127: LD_VAR 0 1
29131: PPUSH
29132: CALL_OW 248
29136: PPUSH
29137: CALL_OW 450
29141: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
29142: LD_VAR 0 10
29146: PPUSH
29147: LD_INT 1
29149: PPUSH
29150: CALL_OW 275
29154: PUSH
29155: LD_VAR 0 11
29159: PUSH
29160: LD_INT 1
29162: ARRAY
29163: GREATEREQUAL
29164: PUSH
29165: LD_VAR 0 10
29169: PPUSH
29170: LD_INT 2
29172: PPUSH
29173: CALL_OW 275
29177: PUSH
29178: LD_VAR 0 11
29182: PUSH
29183: LD_INT 2
29185: ARRAY
29186: GREATEREQUAL
29187: AND
29188: PUSH
29189: LD_VAR 0 10
29193: PPUSH
29194: LD_INT 3
29196: PPUSH
29197: CALL_OW 275
29201: PUSH
29202: LD_VAR 0 11
29206: PUSH
29207: LD_INT 3
29209: ARRAY
29210: GREATEREQUAL
29211: AND
29212: NOT
29213: IFFALSE 29217
// exit ;
29215: GO 29804
// if GetBType ( depot ) = b_depot then
29217: LD_VAR 0 1
29221: PPUSH
29222: CALL_OW 266
29226: PUSH
29227: LD_INT 0
29229: EQUAL
29230: IFFALSE 29242
// dist := 28 else
29232: LD_ADDR_VAR 0 14
29236: PUSH
29237: LD_INT 28
29239: ST_TO_ADDR
29240: GO 29250
// dist := 36 ;
29242: LD_ADDR_VAR 0 14
29246: PUSH
29247: LD_INT 36
29249: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
29250: LD_VAR 0 1
29254: PPUSH
29255: LD_VAR 0 3
29259: PPUSH
29260: LD_VAR 0 4
29264: PPUSH
29265: CALL_OW 297
29269: PUSH
29270: LD_VAR 0 14
29274: GREATER
29275: IFFALSE 29279
// exit ;
29277: GO 29804
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
29279: LD_ADDR_VAR 0 12
29283: PUSH
29284: LD_VAR 0 2
29288: PPUSH
29289: LD_VAR 0 3
29293: PPUSH
29294: LD_VAR 0 4
29298: PPUSH
29299: LD_VAR 0 5
29303: PPUSH
29304: LD_VAR 0 1
29308: PPUSH
29309: CALL_OW 248
29313: PPUSH
29314: LD_INT 0
29316: PPUSH
29317: CALL 29809 0 6
29321: ST_TO_ADDR
// if not hexes then
29322: LD_VAR 0 12
29326: NOT
29327: IFFALSE 29331
// exit ;
29329: GO 29804
// hex := GetHexInfo ( x , y ) ;
29331: LD_ADDR_VAR 0 15
29335: PUSH
29336: LD_VAR 0 3
29340: PPUSH
29341: LD_VAR 0 4
29345: PPUSH
29346: CALL_OW 546
29350: ST_TO_ADDR
// if hex [ 1 ] then
29351: LD_VAR 0 15
29355: PUSH
29356: LD_INT 1
29358: ARRAY
29359: IFFALSE 29363
// exit ;
29361: GO 29804
// height := hex [ 2 ] ;
29363: LD_ADDR_VAR 0 13
29367: PUSH
29368: LD_VAR 0 15
29372: PUSH
29373: LD_INT 2
29375: ARRAY
29376: ST_TO_ADDR
// for i = 1 to hexes do
29377: LD_ADDR_VAR 0 7
29381: PUSH
29382: DOUBLE
29383: LD_INT 1
29385: DEC
29386: ST_TO_ADDR
29387: LD_VAR 0 12
29391: PUSH
29392: FOR_TO
29393: IFFALSE 29723
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29395: LD_VAR 0 12
29399: PUSH
29400: LD_VAR 0 7
29404: ARRAY
29405: PUSH
29406: LD_INT 1
29408: ARRAY
29409: PPUSH
29410: LD_VAR 0 12
29414: PUSH
29415: LD_VAR 0 7
29419: ARRAY
29420: PUSH
29421: LD_INT 2
29423: ARRAY
29424: PPUSH
29425: CALL_OW 488
29429: NOT
29430: PUSH
29431: LD_VAR 0 12
29435: PUSH
29436: LD_VAR 0 7
29440: ARRAY
29441: PUSH
29442: LD_INT 1
29444: ARRAY
29445: PPUSH
29446: LD_VAR 0 12
29450: PUSH
29451: LD_VAR 0 7
29455: ARRAY
29456: PUSH
29457: LD_INT 2
29459: ARRAY
29460: PPUSH
29461: CALL_OW 428
29465: PUSH
29466: LD_INT 0
29468: GREATER
29469: OR
29470: PUSH
29471: LD_VAR 0 12
29475: PUSH
29476: LD_VAR 0 7
29480: ARRAY
29481: PUSH
29482: LD_INT 1
29484: ARRAY
29485: PPUSH
29486: LD_VAR 0 12
29490: PUSH
29491: LD_VAR 0 7
29495: ARRAY
29496: PUSH
29497: LD_INT 2
29499: ARRAY
29500: PPUSH
29501: CALL_OW 351
29505: OR
29506: IFFALSE 29512
// exit ;
29508: POP
29509: POP
29510: GO 29804
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29512: LD_ADDR_VAR 0 8
29516: PUSH
29517: LD_VAR 0 12
29521: PUSH
29522: LD_VAR 0 7
29526: ARRAY
29527: PUSH
29528: LD_INT 1
29530: ARRAY
29531: PPUSH
29532: LD_VAR 0 12
29536: PUSH
29537: LD_VAR 0 7
29541: ARRAY
29542: PUSH
29543: LD_INT 2
29545: ARRAY
29546: PPUSH
29547: CALL_OW 546
29551: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29552: LD_VAR 0 8
29556: PUSH
29557: LD_INT 1
29559: ARRAY
29560: PUSH
29561: LD_VAR 0 8
29565: PUSH
29566: LD_INT 2
29568: ARRAY
29569: PUSH
29570: LD_VAR 0 13
29574: PUSH
29575: LD_INT 2
29577: PLUS
29578: GREATER
29579: OR
29580: PUSH
29581: LD_VAR 0 8
29585: PUSH
29586: LD_INT 2
29588: ARRAY
29589: PUSH
29590: LD_VAR 0 13
29594: PUSH
29595: LD_INT 2
29597: MINUS
29598: LESS
29599: OR
29600: PUSH
29601: LD_VAR 0 8
29605: PUSH
29606: LD_INT 3
29608: ARRAY
29609: PUSH
29610: LD_INT 0
29612: PUSH
29613: LD_INT 8
29615: PUSH
29616: LD_INT 9
29618: PUSH
29619: LD_INT 10
29621: PUSH
29622: LD_INT 11
29624: PUSH
29625: LD_INT 12
29627: PUSH
29628: LD_INT 13
29630: PUSH
29631: LD_INT 16
29633: PUSH
29634: LD_INT 17
29636: PUSH
29637: LD_INT 18
29639: PUSH
29640: LD_INT 19
29642: PUSH
29643: LD_INT 20
29645: PUSH
29646: LD_INT 21
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: LIST
29653: LIST
29654: LIST
29655: LIST
29656: LIST
29657: LIST
29658: LIST
29659: LIST
29660: LIST
29661: LIST
29662: LIST
29663: IN
29664: NOT
29665: OR
29666: PUSH
29667: LD_VAR 0 8
29671: PUSH
29672: LD_INT 5
29674: ARRAY
29675: NOT
29676: OR
29677: PUSH
29678: LD_VAR 0 8
29682: PUSH
29683: LD_INT 6
29685: ARRAY
29686: PUSH
29687: LD_INT 1
29689: PUSH
29690: LD_INT 2
29692: PUSH
29693: LD_INT 7
29695: PUSH
29696: LD_INT 9
29698: PUSH
29699: LD_INT 10
29701: PUSH
29702: LD_INT 11
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: LIST
29709: LIST
29710: LIST
29711: LIST
29712: IN
29713: NOT
29714: OR
29715: IFFALSE 29721
// exit ;
29717: POP
29718: POP
29719: GO 29804
// end ;
29721: GO 29392
29723: POP
29724: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29725: LD_VAR 0 9
29729: PPUSH
29730: LD_VAR 0 3
29734: PPUSH
29735: LD_VAR 0 4
29739: PPUSH
29740: LD_INT 20
29742: PPUSH
29743: CALL 21727 0 4
29747: PUSH
29748: LD_INT 4
29750: ARRAY
29751: IFFALSE 29755
// exit ;
29753: GO 29804
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29755: LD_VAR 0 2
29759: PUSH
29760: LD_INT 29
29762: PUSH
29763: LD_INT 30
29765: PUSH
29766: EMPTY
29767: LIST
29768: LIST
29769: IN
29770: PUSH
29771: LD_VAR 0 3
29775: PPUSH
29776: LD_VAR 0 4
29780: PPUSH
29781: LD_VAR 0 9
29785: PPUSH
29786: CALL_OW 440
29790: NOT
29791: AND
29792: IFFALSE 29796
// exit ;
29794: GO 29804
// result := true ;
29796: LD_ADDR_VAR 0 6
29800: PUSH
29801: LD_INT 1
29803: ST_TO_ADDR
// end ;
29804: LD_VAR 0 6
29808: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
29809: LD_INT 0
29811: PPUSH
29812: PPUSH
29813: PPUSH
29814: PPUSH
29815: PPUSH
29816: PPUSH
29817: PPUSH
29818: PPUSH
29819: PPUSH
29820: PPUSH
29821: PPUSH
29822: PPUSH
29823: PPUSH
29824: PPUSH
29825: PPUSH
29826: PPUSH
29827: PPUSH
29828: PPUSH
29829: PPUSH
29830: PPUSH
29831: PPUSH
29832: PPUSH
29833: PPUSH
29834: PPUSH
29835: PPUSH
29836: PPUSH
29837: PPUSH
29838: PPUSH
29839: PPUSH
29840: PPUSH
29841: PPUSH
29842: PPUSH
29843: PPUSH
29844: PPUSH
29845: PPUSH
29846: PPUSH
29847: PPUSH
29848: PPUSH
29849: PPUSH
29850: PPUSH
29851: PPUSH
29852: PPUSH
29853: PPUSH
29854: PPUSH
29855: PPUSH
29856: PPUSH
29857: PPUSH
29858: PPUSH
29859: PPUSH
29860: PPUSH
29861: PPUSH
29862: PPUSH
29863: PPUSH
29864: PPUSH
29865: PPUSH
29866: PPUSH
29867: PPUSH
29868: PPUSH
// result = [ ] ;
29869: LD_ADDR_VAR 0 7
29873: PUSH
29874: EMPTY
29875: ST_TO_ADDR
// temp_list = [ ] ;
29876: LD_ADDR_VAR 0 9
29880: PUSH
29881: EMPTY
29882: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29883: LD_VAR 0 4
29887: PUSH
29888: LD_INT 0
29890: PUSH
29891: LD_INT 1
29893: PUSH
29894: LD_INT 2
29896: PUSH
29897: LD_INT 3
29899: PUSH
29900: LD_INT 4
29902: PUSH
29903: LD_INT 5
29905: PUSH
29906: EMPTY
29907: LIST
29908: LIST
29909: LIST
29910: LIST
29911: LIST
29912: LIST
29913: IN
29914: NOT
29915: PUSH
29916: LD_VAR 0 1
29920: PUSH
29921: LD_INT 0
29923: PUSH
29924: LD_INT 1
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: IN
29931: PUSH
29932: LD_VAR 0 5
29936: PUSH
29937: LD_INT 1
29939: PUSH
29940: LD_INT 2
29942: PUSH
29943: LD_INT 3
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: LIST
29950: IN
29951: NOT
29952: AND
29953: OR
29954: IFFALSE 29958
// exit ;
29956: GO 48349
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29958: LD_VAR 0 1
29962: PUSH
29963: LD_INT 6
29965: PUSH
29966: LD_INT 7
29968: PUSH
29969: LD_INT 8
29971: PUSH
29972: LD_INT 13
29974: PUSH
29975: LD_INT 12
29977: PUSH
29978: LD_INT 15
29980: PUSH
29981: LD_INT 11
29983: PUSH
29984: LD_INT 14
29986: PUSH
29987: LD_INT 10
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: LIST
29994: LIST
29995: LIST
29996: LIST
29997: LIST
29998: LIST
29999: LIST
30000: IN
30001: IFFALSE 30011
// btype = b_lab ;
30003: LD_ADDR_VAR 0 1
30007: PUSH
30008: LD_INT 6
30010: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
30011: LD_VAR 0 6
30015: PUSH
30016: LD_INT 0
30018: PUSH
30019: LD_INT 1
30021: PUSH
30022: LD_INT 2
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: LIST
30029: IN
30030: NOT
30031: PUSH
30032: LD_VAR 0 1
30036: PUSH
30037: LD_INT 0
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: LD_INT 2
30045: PUSH
30046: LD_INT 3
30048: PUSH
30049: LD_INT 6
30051: PUSH
30052: LD_INT 36
30054: PUSH
30055: LD_INT 4
30057: PUSH
30058: LD_INT 5
30060: PUSH
30061: LD_INT 31
30063: PUSH
30064: LD_INT 32
30066: PUSH
30067: LD_INT 33
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: LIST
30074: LIST
30075: LIST
30076: LIST
30077: LIST
30078: LIST
30079: LIST
30080: LIST
30081: LIST
30082: IN
30083: NOT
30084: PUSH
30085: LD_VAR 0 6
30089: PUSH
30090: LD_INT 1
30092: EQUAL
30093: AND
30094: OR
30095: PUSH
30096: LD_VAR 0 1
30100: PUSH
30101: LD_INT 2
30103: PUSH
30104: LD_INT 3
30106: PUSH
30107: EMPTY
30108: LIST
30109: LIST
30110: IN
30111: NOT
30112: PUSH
30113: LD_VAR 0 6
30117: PUSH
30118: LD_INT 2
30120: EQUAL
30121: AND
30122: OR
30123: IFFALSE 30133
// mode = 0 ;
30125: LD_ADDR_VAR 0 6
30129: PUSH
30130: LD_INT 0
30132: ST_TO_ADDR
// case mode of 0 :
30133: LD_VAR 0 6
30137: PUSH
30138: LD_INT 0
30140: DOUBLE
30141: EQUAL
30142: IFTRUE 30146
30144: GO 41599
30146: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
30147: LD_ADDR_VAR 0 11
30151: PUSH
30152: LD_INT 0
30154: PUSH
30155: LD_INT 0
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 0
30164: PUSH
30165: LD_INT 1
30167: NEG
30168: PUSH
30169: EMPTY
30170: LIST
30171: LIST
30172: PUSH
30173: LD_INT 1
30175: PUSH
30176: LD_INT 0
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 1
30185: PUSH
30186: LD_INT 1
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: LD_INT 0
30195: PUSH
30196: LD_INT 1
30198: PUSH
30199: EMPTY
30200: LIST
30201: LIST
30202: PUSH
30203: LD_INT 1
30205: NEG
30206: PUSH
30207: LD_INT 0
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PUSH
30214: LD_INT 1
30216: NEG
30217: PUSH
30218: LD_INT 1
30220: NEG
30221: PUSH
30222: EMPTY
30223: LIST
30224: LIST
30225: PUSH
30226: LD_INT 1
30228: NEG
30229: PUSH
30230: LD_INT 2
30232: NEG
30233: PUSH
30234: EMPTY
30235: LIST
30236: LIST
30237: PUSH
30238: LD_INT 0
30240: PUSH
30241: LD_INT 2
30243: NEG
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: LD_INT 1
30251: PUSH
30252: LD_INT 1
30254: NEG
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 1
30262: PUSH
30263: LD_INT 2
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 0
30272: PUSH
30273: LD_INT 2
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 1
30282: NEG
30283: PUSH
30284: LD_INT 1
30286: PUSH
30287: EMPTY
30288: LIST
30289: LIST
30290: PUSH
30291: LD_INT 1
30293: PUSH
30294: LD_INT 3
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 0
30303: PUSH
30304: LD_INT 3
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 1
30313: NEG
30314: PUSH
30315: LD_INT 2
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: EMPTY
30323: LIST
30324: LIST
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30340: LD_ADDR_VAR 0 12
30344: PUSH
30345: LD_INT 0
30347: PUSH
30348: LD_INT 0
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 0
30357: PUSH
30358: LD_INT 1
30360: NEG
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: PUSH
30369: LD_INT 0
30371: PUSH
30372: EMPTY
30373: LIST
30374: LIST
30375: PUSH
30376: LD_INT 1
30378: PUSH
30379: LD_INT 1
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 0
30388: PUSH
30389: LD_INT 1
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: LD_INT 1
30398: NEG
30399: PUSH
30400: LD_INT 0
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 1
30409: NEG
30410: PUSH
30411: LD_INT 1
30413: NEG
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 1
30421: PUSH
30422: LD_INT 1
30424: NEG
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 2
30432: PUSH
30433: LD_INT 0
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: LD_INT 2
30442: PUSH
30443: LD_INT 1
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: PUSH
30450: LD_INT 1
30452: NEG
30453: PUSH
30454: LD_INT 1
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PUSH
30461: LD_INT 2
30463: NEG
30464: PUSH
30465: LD_INT 0
30467: PUSH
30468: EMPTY
30469: LIST
30470: LIST
30471: PUSH
30472: LD_INT 2
30474: NEG
30475: PUSH
30476: LD_INT 1
30478: NEG
30479: PUSH
30480: EMPTY
30481: LIST
30482: LIST
30483: PUSH
30484: LD_INT 2
30486: NEG
30487: PUSH
30488: LD_INT 1
30490: PUSH
30491: EMPTY
30492: LIST
30493: LIST
30494: PUSH
30495: LD_INT 3
30497: NEG
30498: PUSH
30499: LD_INT 0
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 3
30508: NEG
30509: PUSH
30510: LD_INT 1
30512: NEG
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: LIST
30525: LIST
30526: LIST
30527: LIST
30528: LIST
30529: LIST
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: LIST
30535: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30536: LD_ADDR_VAR 0 13
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: LD_INT 0
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: PUSH
30551: LD_INT 0
30553: PUSH
30554: LD_INT 1
30556: NEG
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 1
30564: PUSH
30565: LD_INT 0
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: LD_INT 1
30574: PUSH
30575: LD_INT 1
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 0
30584: PUSH
30585: LD_INT 1
30587: PUSH
30588: EMPTY
30589: LIST
30590: LIST
30591: PUSH
30592: LD_INT 1
30594: NEG
30595: PUSH
30596: LD_INT 0
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: PUSH
30603: LD_INT 1
30605: NEG
30606: PUSH
30607: LD_INT 1
30609: NEG
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: PUSH
30615: LD_INT 1
30617: NEG
30618: PUSH
30619: LD_INT 2
30621: NEG
30622: PUSH
30623: EMPTY
30624: LIST
30625: LIST
30626: PUSH
30627: LD_INT 2
30629: PUSH
30630: LD_INT 1
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: PUSH
30637: LD_INT 2
30639: PUSH
30640: LD_INT 2
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 1
30649: PUSH
30650: LD_INT 2
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: PUSH
30657: LD_INT 2
30659: NEG
30660: PUSH
30661: LD_INT 1
30663: NEG
30664: PUSH
30665: EMPTY
30666: LIST
30667: LIST
30668: PUSH
30669: LD_INT 2
30671: NEG
30672: PUSH
30673: LD_INT 2
30675: NEG
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PUSH
30681: LD_INT 2
30683: NEG
30684: PUSH
30685: LD_INT 3
30687: NEG
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 3
30695: NEG
30696: PUSH
30697: LD_INT 2
30699: NEG
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 3
30707: NEG
30708: PUSH
30709: LD_INT 3
30711: NEG
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: EMPTY
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: LIST
30724: LIST
30725: LIST
30726: LIST
30727: LIST
30728: LIST
30729: LIST
30730: LIST
30731: LIST
30732: LIST
30733: LIST
30734: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30735: LD_ADDR_VAR 0 14
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: LD_INT 0
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 0
30752: PUSH
30753: LD_INT 1
30755: NEG
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 1
30763: PUSH
30764: LD_INT 0
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PUSH
30771: LD_INT 1
30773: PUSH
30774: LD_INT 1
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 0
30783: PUSH
30784: LD_INT 1
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 1
30793: NEG
30794: PUSH
30795: LD_INT 0
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 1
30804: NEG
30805: PUSH
30806: LD_INT 1
30808: NEG
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 1
30816: NEG
30817: PUSH
30818: LD_INT 2
30820: NEG
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 0
30828: PUSH
30829: LD_INT 2
30831: NEG
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 1
30839: PUSH
30840: LD_INT 1
30842: NEG
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: LD_INT 1
30850: PUSH
30851: LD_INT 2
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: LD_INT 0
30860: PUSH
30861: LD_INT 2
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 1
30870: NEG
30871: PUSH
30872: LD_INT 1
30874: PUSH
30875: EMPTY
30876: LIST
30877: LIST
30878: PUSH
30879: LD_INT 1
30881: NEG
30882: PUSH
30883: LD_INT 3
30885: NEG
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 0
30893: PUSH
30894: LD_INT 3
30896: NEG
30897: PUSH
30898: EMPTY
30899: LIST
30900: LIST
30901: PUSH
30902: LD_INT 1
30904: PUSH
30905: LD_INT 2
30907: NEG
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: EMPTY
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: LIST
30926: LIST
30927: LIST
30928: LIST
30929: LIST
30930: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30931: LD_ADDR_VAR 0 15
30935: PUSH
30936: LD_INT 0
30938: PUSH
30939: LD_INT 0
30941: PUSH
30942: EMPTY
30943: LIST
30944: LIST
30945: PUSH
30946: LD_INT 0
30948: PUSH
30949: LD_INT 1
30951: NEG
30952: PUSH
30953: EMPTY
30954: LIST
30955: LIST
30956: PUSH
30957: LD_INT 1
30959: PUSH
30960: LD_INT 0
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PUSH
30967: LD_INT 1
30969: PUSH
30970: LD_INT 1
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: PUSH
30977: LD_INT 0
30979: PUSH
30980: LD_INT 1
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 1
30989: NEG
30990: PUSH
30991: LD_INT 0
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: LD_INT 1
31004: NEG
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 1
31012: PUSH
31013: LD_INT 1
31015: NEG
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 2
31023: PUSH
31024: LD_INT 0
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 2
31033: PUSH
31034: LD_INT 1
31036: PUSH
31037: EMPTY
31038: LIST
31039: LIST
31040: PUSH
31041: LD_INT 1
31043: NEG
31044: PUSH
31045: LD_INT 1
31047: PUSH
31048: EMPTY
31049: LIST
31050: LIST
31051: PUSH
31052: LD_INT 2
31054: NEG
31055: PUSH
31056: LD_INT 0
31058: PUSH
31059: EMPTY
31060: LIST
31061: LIST
31062: PUSH
31063: LD_INT 2
31065: NEG
31066: PUSH
31067: LD_INT 1
31069: NEG
31070: PUSH
31071: EMPTY
31072: LIST
31073: LIST
31074: PUSH
31075: LD_INT 2
31077: PUSH
31078: LD_INT 1
31080: NEG
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: LD_INT 3
31088: PUSH
31089: LD_INT 0
31091: PUSH
31092: EMPTY
31093: LIST
31094: LIST
31095: PUSH
31096: LD_INT 3
31098: PUSH
31099: LD_INT 1
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: LIST
31110: LIST
31111: LIST
31112: LIST
31113: LIST
31114: LIST
31115: LIST
31116: LIST
31117: LIST
31118: LIST
31119: LIST
31120: LIST
31121: LIST
31122: LIST
31123: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31124: LD_ADDR_VAR 0 16
31128: PUSH
31129: LD_INT 0
31131: PUSH
31132: LD_INT 0
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: PUSH
31139: LD_INT 0
31141: PUSH
31142: LD_INT 1
31144: NEG
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 1
31152: PUSH
31153: LD_INT 0
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: PUSH
31160: LD_INT 1
31162: PUSH
31163: LD_INT 1
31165: PUSH
31166: EMPTY
31167: LIST
31168: LIST
31169: PUSH
31170: LD_INT 0
31172: PUSH
31173: LD_INT 1
31175: PUSH
31176: EMPTY
31177: LIST
31178: LIST
31179: PUSH
31180: LD_INT 1
31182: NEG
31183: PUSH
31184: LD_INT 0
31186: PUSH
31187: EMPTY
31188: LIST
31189: LIST
31190: PUSH
31191: LD_INT 1
31193: NEG
31194: PUSH
31195: LD_INT 1
31197: NEG
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PUSH
31203: LD_INT 1
31205: NEG
31206: PUSH
31207: LD_INT 2
31209: NEG
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 2
31217: PUSH
31218: LD_INT 1
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 2
31227: PUSH
31228: LD_INT 2
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 1
31237: PUSH
31238: LD_INT 2
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 2
31247: NEG
31248: PUSH
31249: LD_INT 1
31251: NEG
31252: PUSH
31253: EMPTY
31254: LIST
31255: LIST
31256: PUSH
31257: LD_INT 2
31259: NEG
31260: PUSH
31261: LD_INT 2
31263: NEG
31264: PUSH
31265: EMPTY
31266: LIST
31267: LIST
31268: PUSH
31269: LD_INT 3
31271: PUSH
31272: LD_INT 2
31274: PUSH
31275: EMPTY
31276: LIST
31277: LIST
31278: PUSH
31279: LD_INT 3
31281: PUSH
31282: LD_INT 3
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 2
31291: PUSH
31292: LD_INT 3
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: PUSH
31299: EMPTY
31300: LIST
31301: LIST
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: LIST
31307: LIST
31308: LIST
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31317: LD_ADDR_VAR 0 17
31321: PUSH
31322: LD_INT 0
31324: PUSH
31325: LD_INT 0
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 0
31334: PUSH
31335: LD_INT 1
31337: NEG
31338: PUSH
31339: EMPTY
31340: LIST
31341: LIST
31342: PUSH
31343: LD_INT 1
31345: PUSH
31346: LD_INT 0
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 1
31355: PUSH
31356: LD_INT 1
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 0
31365: PUSH
31366: LD_INT 1
31368: PUSH
31369: EMPTY
31370: LIST
31371: LIST
31372: PUSH
31373: LD_INT 1
31375: NEG
31376: PUSH
31377: LD_INT 0
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 1
31386: NEG
31387: PUSH
31388: LD_INT 1
31390: NEG
31391: PUSH
31392: EMPTY
31393: LIST
31394: LIST
31395: PUSH
31396: LD_INT 1
31398: NEG
31399: PUSH
31400: LD_INT 2
31402: NEG
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PUSH
31408: LD_INT 0
31410: PUSH
31411: LD_INT 2
31413: NEG
31414: PUSH
31415: EMPTY
31416: LIST
31417: LIST
31418: PUSH
31419: LD_INT 1
31421: PUSH
31422: LD_INT 1
31424: NEG
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 2
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 2
31442: PUSH
31443: LD_INT 1
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 2
31452: PUSH
31453: LD_INT 2
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: LD_INT 1
31462: PUSH
31463: LD_INT 2
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PUSH
31470: LD_INT 0
31472: PUSH
31473: LD_INT 2
31475: PUSH
31476: EMPTY
31477: LIST
31478: LIST
31479: PUSH
31480: LD_INT 1
31482: NEG
31483: PUSH
31484: LD_INT 1
31486: PUSH
31487: EMPTY
31488: LIST
31489: LIST
31490: PUSH
31491: LD_INT 2
31493: NEG
31494: PUSH
31495: LD_INT 0
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 2
31504: NEG
31505: PUSH
31506: LD_INT 1
31508: NEG
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 2
31516: NEG
31517: PUSH
31518: LD_INT 2
31520: NEG
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: LIST
31537: LIST
31538: LIST
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: LIST
31545: LIST
31546: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31547: LD_ADDR_VAR 0 18
31551: PUSH
31552: LD_INT 0
31554: PUSH
31555: LD_INT 0
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PUSH
31562: LD_INT 0
31564: PUSH
31565: LD_INT 1
31567: NEG
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 1
31575: PUSH
31576: LD_INT 0
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 1
31585: PUSH
31586: LD_INT 1
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 0
31595: PUSH
31596: LD_INT 1
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 1
31605: NEG
31606: PUSH
31607: LD_INT 0
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 1
31616: NEG
31617: PUSH
31618: LD_INT 1
31620: NEG
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: LD_INT 1
31628: NEG
31629: PUSH
31630: LD_INT 2
31632: NEG
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: LD_INT 0
31640: PUSH
31641: LD_INT 2
31643: NEG
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 1
31651: PUSH
31652: LD_INT 1
31654: NEG
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: LD_INT 0
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 2
31672: PUSH
31673: LD_INT 1
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 2
31682: PUSH
31683: LD_INT 2
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 1
31692: PUSH
31693: LD_INT 2
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 0
31702: PUSH
31703: LD_INT 2
31705: PUSH
31706: EMPTY
31707: LIST
31708: LIST
31709: PUSH
31710: LD_INT 1
31712: NEG
31713: PUSH
31714: LD_INT 1
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 2
31723: NEG
31724: PUSH
31725: LD_INT 0
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: LD_INT 2
31734: NEG
31735: PUSH
31736: LD_INT 1
31738: NEG
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 2
31746: NEG
31747: PUSH
31748: LD_INT 2
31750: NEG
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: LIST
31763: LIST
31764: LIST
31765: LIST
31766: LIST
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31777: LD_ADDR_VAR 0 19
31781: PUSH
31782: LD_INT 0
31784: PUSH
31785: LD_INT 0
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: LD_INT 1
31797: NEG
31798: PUSH
31799: EMPTY
31800: LIST
31801: LIST
31802: PUSH
31803: LD_INT 1
31805: PUSH
31806: LD_INT 0
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 1
31815: PUSH
31816: LD_INT 1
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 0
31825: PUSH
31826: LD_INT 1
31828: PUSH
31829: EMPTY
31830: LIST
31831: LIST
31832: PUSH
31833: LD_INT 1
31835: NEG
31836: PUSH
31837: LD_INT 0
31839: PUSH
31840: EMPTY
31841: LIST
31842: LIST
31843: PUSH
31844: LD_INT 1
31846: NEG
31847: PUSH
31848: LD_INT 1
31850: NEG
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: LD_INT 1
31858: NEG
31859: PUSH
31860: LD_INT 2
31862: NEG
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 0
31870: PUSH
31871: LD_INT 2
31873: NEG
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 1
31881: PUSH
31882: LD_INT 1
31884: NEG
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: PUSH
31890: LD_INT 2
31892: PUSH
31893: LD_INT 0
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 2
31902: PUSH
31903: LD_INT 1
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: LD_INT 2
31912: PUSH
31913: LD_INT 2
31915: PUSH
31916: EMPTY
31917: LIST
31918: LIST
31919: PUSH
31920: LD_INT 1
31922: PUSH
31923: LD_INT 2
31925: PUSH
31926: EMPTY
31927: LIST
31928: LIST
31929: PUSH
31930: LD_INT 0
31932: PUSH
31933: LD_INT 2
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 1
31942: NEG
31943: PUSH
31944: LD_INT 1
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 2
31953: NEG
31954: PUSH
31955: LD_INT 0
31957: PUSH
31958: EMPTY
31959: LIST
31960: LIST
31961: PUSH
31962: LD_INT 2
31964: NEG
31965: PUSH
31966: LD_INT 1
31968: NEG
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 2
31976: NEG
31977: PUSH
31978: LD_INT 2
31980: NEG
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: LIST
31990: LIST
31991: LIST
31992: LIST
31993: LIST
31994: LIST
31995: LIST
31996: LIST
31997: LIST
31998: LIST
31999: LIST
32000: LIST
32001: LIST
32002: LIST
32003: LIST
32004: LIST
32005: LIST
32006: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32007: LD_ADDR_VAR 0 20
32011: PUSH
32012: LD_INT 0
32014: PUSH
32015: LD_INT 0
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 0
32024: PUSH
32025: LD_INT 1
32027: NEG
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 1
32035: PUSH
32036: LD_INT 0
32038: PUSH
32039: EMPTY
32040: LIST
32041: LIST
32042: PUSH
32043: LD_INT 1
32045: PUSH
32046: LD_INT 1
32048: PUSH
32049: EMPTY
32050: LIST
32051: LIST
32052: PUSH
32053: LD_INT 0
32055: PUSH
32056: LD_INT 1
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: PUSH
32063: LD_INT 1
32065: NEG
32066: PUSH
32067: LD_INT 0
32069: PUSH
32070: EMPTY
32071: LIST
32072: LIST
32073: PUSH
32074: LD_INT 1
32076: NEG
32077: PUSH
32078: LD_INT 1
32080: NEG
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 1
32088: NEG
32089: PUSH
32090: LD_INT 2
32092: NEG
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: LD_INT 0
32100: PUSH
32101: LD_INT 2
32103: NEG
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: LD_INT 1
32111: PUSH
32112: LD_INT 1
32114: NEG
32115: PUSH
32116: EMPTY
32117: LIST
32118: LIST
32119: PUSH
32120: LD_INT 2
32122: PUSH
32123: LD_INT 0
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PUSH
32130: LD_INT 2
32132: PUSH
32133: LD_INT 1
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 2
32142: PUSH
32143: LD_INT 2
32145: PUSH
32146: EMPTY
32147: LIST
32148: LIST
32149: PUSH
32150: LD_INT 1
32152: PUSH
32153: LD_INT 2
32155: PUSH
32156: EMPTY
32157: LIST
32158: LIST
32159: PUSH
32160: LD_INT 0
32162: PUSH
32163: LD_INT 2
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 1
32172: NEG
32173: PUSH
32174: LD_INT 1
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 2
32183: NEG
32184: PUSH
32185: LD_INT 0
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 2
32194: NEG
32195: PUSH
32196: LD_INT 1
32198: NEG
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 2
32206: NEG
32207: PUSH
32208: LD_INT 2
32210: NEG
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PUSH
32216: EMPTY
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: LIST
32223: LIST
32224: LIST
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: LIST
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: LIST
32235: LIST
32236: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32237: LD_ADDR_VAR 0 21
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: LD_INT 0
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 0
32254: PUSH
32255: LD_INT 1
32257: NEG
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: LD_INT 0
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 1
32275: PUSH
32276: LD_INT 1
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 0
32285: PUSH
32286: LD_INT 1
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: LD_INT 1
32295: NEG
32296: PUSH
32297: LD_INT 0
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: PUSH
32304: LD_INT 1
32306: NEG
32307: PUSH
32308: LD_INT 1
32310: NEG
32311: PUSH
32312: EMPTY
32313: LIST
32314: LIST
32315: PUSH
32316: LD_INT 1
32318: NEG
32319: PUSH
32320: LD_INT 2
32322: NEG
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 0
32330: PUSH
32331: LD_INT 2
32333: NEG
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: PUSH
32339: LD_INT 1
32341: PUSH
32342: LD_INT 1
32344: NEG
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 2
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 2
32362: PUSH
32363: LD_INT 1
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 2
32372: PUSH
32373: LD_INT 2
32375: PUSH
32376: EMPTY
32377: LIST
32378: LIST
32379: PUSH
32380: LD_INT 1
32382: PUSH
32383: LD_INT 2
32385: PUSH
32386: EMPTY
32387: LIST
32388: LIST
32389: PUSH
32390: LD_INT 0
32392: PUSH
32393: LD_INT 2
32395: PUSH
32396: EMPTY
32397: LIST
32398: LIST
32399: PUSH
32400: LD_INT 1
32402: NEG
32403: PUSH
32404: LD_INT 1
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 2
32413: NEG
32414: PUSH
32415: LD_INT 0
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 2
32424: NEG
32425: PUSH
32426: LD_INT 1
32428: NEG
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 2
32436: NEG
32437: PUSH
32438: LD_INT 2
32440: NEG
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: EMPTY
32447: LIST
32448: LIST
32449: LIST
32450: LIST
32451: LIST
32452: LIST
32453: LIST
32454: LIST
32455: LIST
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: LIST
32461: LIST
32462: LIST
32463: LIST
32464: LIST
32465: LIST
32466: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32467: LD_ADDR_VAR 0 22
32471: PUSH
32472: LD_INT 0
32474: PUSH
32475: LD_INT 0
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PUSH
32482: LD_INT 0
32484: PUSH
32485: LD_INT 1
32487: NEG
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: PUSH
32493: LD_INT 1
32495: PUSH
32496: LD_INT 0
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: LD_INT 1
32505: PUSH
32506: LD_INT 1
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: PUSH
32513: LD_INT 0
32515: PUSH
32516: LD_INT 1
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 1
32525: NEG
32526: PUSH
32527: LD_INT 0
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: LD_INT 1
32536: NEG
32537: PUSH
32538: LD_INT 1
32540: NEG
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: LD_INT 1
32548: NEG
32549: PUSH
32550: LD_INT 2
32552: NEG
32553: PUSH
32554: EMPTY
32555: LIST
32556: LIST
32557: PUSH
32558: LD_INT 0
32560: PUSH
32561: LD_INT 2
32563: NEG
32564: PUSH
32565: EMPTY
32566: LIST
32567: LIST
32568: PUSH
32569: LD_INT 1
32571: PUSH
32572: LD_INT 1
32574: NEG
32575: PUSH
32576: EMPTY
32577: LIST
32578: LIST
32579: PUSH
32580: LD_INT 2
32582: PUSH
32583: LD_INT 0
32585: PUSH
32586: EMPTY
32587: LIST
32588: LIST
32589: PUSH
32590: LD_INT 2
32592: PUSH
32593: LD_INT 1
32595: PUSH
32596: EMPTY
32597: LIST
32598: LIST
32599: PUSH
32600: LD_INT 2
32602: PUSH
32603: LD_INT 2
32605: PUSH
32606: EMPTY
32607: LIST
32608: LIST
32609: PUSH
32610: LD_INT 1
32612: PUSH
32613: LD_INT 2
32615: PUSH
32616: EMPTY
32617: LIST
32618: LIST
32619: PUSH
32620: LD_INT 0
32622: PUSH
32623: LD_INT 2
32625: PUSH
32626: EMPTY
32627: LIST
32628: LIST
32629: PUSH
32630: LD_INT 1
32632: NEG
32633: PUSH
32634: LD_INT 1
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: PUSH
32641: LD_INT 2
32643: NEG
32644: PUSH
32645: LD_INT 0
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 2
32654: NEG
32655: PUSH
32656: LD_INT 1
32658: NEG
32659: PUSH
32660: EMPTY
32661: LIST
32662: LIST
32663: PUSH
32664: LD_INT 2
32666: NEG
32667: PUSH
32668: LD_INT 2
32670: NEG
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PUSH
32676: EMPTY
32677: LIST
32678: LIST
32679: LIST
32680: LIST
32681: LIST
32682: LIST
32683: LIST
32684: LIST
32685: LIST
32686: LIST
32687: LIST
32688: LIST
32689: LIST
32690: LIST
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32697: LD_ADDR_VAR 0 23
32701: PUSH
32702: LD_INT 0
32704: PUSH
32705: LD_INT 0
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 0
32714: PUSH
32715: LD_INT 1
32717: NEG
32718: PUSH
32719: EMPTY
32720: LIST
32721: LIST
32722: PUSH
32723: LD_INT 1
32725: PUSH
32726: LD_INT 0
32728: PUSH
32729: EMPTY
32730: LIST
32731: LIST
32732: PUSH
32733: LD_INT 1
32735: PUSH
32736: LD_INT 1
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 0
32745: PUSH
32746: LD_INT 1
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: PUSH
32753: LD_INT 1
32755: NEG
32756: PUSH
32757: LD_INT 0
32759: PUSH
32760: EMPTY
32761: LIST
32762: LIST
32763: PUSH
32764: LD_INT 1
32766: NEG
32767: PUSH
32768: LD_INT 1
32770: NEG
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: LD_INT 1
32778: NEG
32779: PUSH
32780: LD_INT 2
32782: NEG
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 0
32790: PUSH
32791: LD_INT 2
32793: NEG
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 1
32801: PUSH
32802: LD_INT 1
32804: NEG
32805: PUSH
32806: EMPTY
32807: LIST
32808: LIST
32809: PUSH
32810: LD_INT 2
32812: PUSH
32813: LD_INT 0
32815: PUSH
32816: EMPTY
32817: LIST
32818: LIST
32819: PUSH
32820: LD_INT 2
32822: PUSH
32823: LD_INT 1
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 2
32832: PUSH
32833: LD_INT 2
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 1
32842: PUSH
32843: LD_INT 2
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 0
32852: PUSH
32853: LD_INT 2
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: LD_INT 1
32862: NEG
32863: PUSH
32864: LD_INT 1
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PUSH
32871: LD_INT 2
32873: NEG
32874: PUSH
32875: LD_INT 0
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 2
32884: NEG
32885: PUSH
32886: LD_INT 1
32888: NEG
32889: PUSH
32890: EMPTY
32891: LIST
32892: LIST
32893: PUSH
32894: LD_INT 2
32896: NEG
32897: PUSH
32898: LD_INT 2
32900: NEG
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: PUSH
32906: LD_INT 2
32908: NEG
32909: PUSH
32910: LD_INT 3
32912: NEG
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: LD_INT 1
32920: NEG
32921: PUSH
32922: LD_INT 3
32924: NEG
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: LD_INT 1
32932: PUSH
32933: LD_INT 2
32935: NEG
32936: PUSH
32937: EMPTY
32938: LIST
32939: LIST
32940: PUSH
32941: LD_INT 2
32943: PUSH
32944: LD_INT 1
32946: NEG
32947: PUSH
32948: EMPTY
32949: LIST
32950: LIST
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: LIST
32956: LIST
32957: LIST
32958: LIST
32959: LIST
32960: LIST
32961: LIST
32962: LIST
32963: LIST
32964: LIST
32965: LIST
32966: LIST
32967: LIST
32968: LIST
32969: LIST
32970: LIST
32971: LIST
32972: LIST
32973: LIST
32974: LIST
32975: LIST
32976: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32977: LD_ADDR_VAR 0 24
32981: PUSH
32982: LD_INT 0
32984: PUSH
32985: LD_INT 0
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: LD_INT 0
32994: PUSH
32995: LD_INT 1
32997: NEG
32998: PUSH
32999: EMPTY
33000: LIST
33001: LIST
33002: PUSH
33003: LD_INT 1
33005: PUSH
33006: LD_INT 0
33008: PUSH
33009: EMPTY
33010: LIST
33011: LIST
33012: PUSH
33013: LD_INT 1
33015: PUSH
33016: LD_INT 1
33018: PUSH
33019: EMPTY
33020: LIST
33021: LIST
33022: PUSH
33023: LD_INT 0
33025: PUSH
33026: LD_INT 1
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PUSH
33033: LD_INT 1
33035: NEG
33036: PUSH
33037: LD_INT 0
33039: PUSH
33040: EMPTY
33041: LIST
33042: LIST
33043: PUSH
33044: LD_INT 1
33046: NEG
33047: PUSH
33048: LD_INT 1
33050: NEG
33051: PUSH
33052: EMPTY
33053: LIST
33054: LIST
33055: PUSH
33056: LD_INT 1
33058: NEG
33059: PUSH
33060: LD_INT 2
33062: NEG
33063: PUSH
33064: EMPTY
33065: LIST
33066: LIST
33067: PUSH
33068: LD_INT 0
33070: PUSH
33071: LD_INT 2
33073: NEG
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 1
33081: PUSH
33082: LD_INT 1
33084: NEG
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 2
33092: PUSH
33093: LD_INT 0
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 2
33102: PUSH
33103: LD_INT 1
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 2
33112: PUSH
33113: LD_INT 2
33115: PUSH
33116: EMPTY
33117: LIST
33118: LIST
33119: PUSH
33120: LD_INT 1
33122: PUSH
33123: LD_INT 2
33125: PUSH
33126: EMPTY
33127: LIST
33128: LIST
33129: PUSH
33130: LD_INT 0
33132: PUSH
33133: LD_INT 2
33135: PUSH
33136: EMPTY
33137: LIST
33138: LIST
33139: PUSH
33140: LD_INT 1
33142: NEG
33143: PUSH
33144: LD_INT 1
33146: PUSH
33147: EMPTY
33148: LIST
33149: LIST
33150: PUSH
33151: LD_INT 2
33153: NEG
33154: PUSH
33155: LD_INT 0
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 2
33164: NEG
33165: PUSH
33166: LD_INT 1
33168: NEG
33169: PUSH
33170: EMPTY
33171: LIST
33172: LIST
33173: PUSH
33174: LD_INT 2
33176: NEG
33177: PUSH
33178: LD_INT 2
33180: NEG
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 1
33188: PUSH
33189: LD_INT 2
33191: NEG
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 2
33199: PUSH
33200: LD_INT 1
33202: NEG
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: LD_INT 3
33210: PUSH
33211: LD_INT 1
33213: PUSH
33214: EMPTY
33215: LIST
33216: LIST
33217: PUSH
33218: LD_INT 3
33220: PUSH
33221: LD_INT 2
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: EMPTY
33229: LIST
33230: LIST
33231: LIST
33232: LIST
33233: LIST
33234: LIST
33235: LIST
33236: LIST
33237: LIST
33238: LIST
33239: LIST
33240: LIST
33241: LIST
33242: LIST
33243: LIST
33244: LIST
33245: LIST
33246: LIST
33247: LIST
33248: LIST
33249: LIST
33250: LIST
33251: LIST
33252: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
33253: LD_ADDR_VAR 0 25
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: LD_INT 0
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 0
33270: PUSH
33271: LD_INT 1
33273: NEG
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 1
33281: PUSH
33282: LD_INT 0
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 1
33291: PUSH
33292: LD_INT 1
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 0
33301: PUSH
33302: LD_INT 1
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 1
33311: NEG
33312: PUSH
33313: LD_INT 0
33315: PUSH
33316: EMPTY
33317: LIST
33318: LIST
33319: PUSH
33320: LD_INT 1
33322: NEG
33323: PUSH
33324: LD_INT 1
33326: NEG
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PUSH
33332: LD_INT 1
33334: NEG
33335: PUSH
33336: LD_INT 2
33338: NEG
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 0
33346: PUSH
33347: LD_INT 2
33349: NEG
33350: PUSH
33351: EMPTY
33352: LIST
33353: LIST
33354: PUSH
33355: LD_INT 1
33357: PUSH
33358: LD_INT 1
33360: NEG
33361: PUSH
33362: EMPTY
33363: LIST
33364: LIST
33365: PUSH
33366: LD_INT 2
33368: PUSH
33369: LD_INT 0
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PUSH
33376: LD_INT 2
33378: PUSH
33379: LD_INT 1
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 2
33388: PUSH
33389: LD_INT 2
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 1
33398: PUSH
33399: LD_INT 2
33401: PUSH
33402: EMPTY
33403: LIST
33404: LIST
33405: PUSH
33406: LD_INT 0
33408: PUSH
33409: LD_INT 2
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 1
33418: NEG
33419: PUSH
33420: LD_INT 1
33422: PUSH
33423: EMPTY
33424: LIST
33425: LIST
33426: PUSH
33427: LD_INT 2
33429: NEG
33430: PUSH
33431: LD_INT 0
33433: PUSH
33434: EMPTY
33435: LIST
33436: LIST
33437: PUSH
33438: LD_INT 2
33440: NEG
33441: PUSH
33442: LD_INT 1
33444: NEG
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: PUSH
33450: LD_INT 2
33452: NEG
33453: PUSH
33454: LD_INT 2
33456: NEG
33457: PUSH
33458: EMPTY
33459: LIST
33460: LIST
33461: PUSH
33462: LD_INT 3
33464: PUSH
33465: LD_INT 1
33467: PUSH
33468: EMPTY
33469: LIST
33470: LIST
33471: PUSH
33472: LD_INT 3
33474: PUSH
33475: LD_INT 2
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PUSH
33482: LD_INT 2
33484: PUSH
33485: LD_INT 3
33487: PUSH
33488: EMPTY
33489: LIST
33490: LIST
33491: PUSH
33492: LD_INT 1
33494: PUSH
33495: LD_INT 3
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: LIST
33506: LIST
33507: LIST
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: LIST
33519: LIST
33520: LIST
33521: LIST
33522: LIST
33523: LIST
33524: LIST
33525: LIST
33526: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33527: LD_ADDR_VAR 0 26
33531: PUSH
33532: LD_INT 0
33534: PUSH
33535: LD_INT 0
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 0
33544: PUSH
33545: LD_INT 1
33547: NEG
33548: PUSH
33549: EMPTY
33550: LIST
33551: LIST
33552: PUSH
33553: LD_INT 1
33555: PUSH
33556: LD_INT 0
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 1
33565: PUSH
33566: LD_INT 1
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 0
33575: PUSH
33576: LD_INT 1
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: PUSH
33583: LD_INT 1
33585: NEG
33586: PUSH
33587: LD_INT 0
33589: PUSH
33590: EMPTY
33591: LIST
33592: LIST
33593: PUSH
33594: LD_INT 1
33596: NEG
33597: PUSH
33598: LD_INT 1
33600: NEG
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: PUSH
33606: LD_INT 1
33608: NEG
33609: PUSH
33610: LD_INT 2
33612: NEG
33613: PUSH
33614: EMPTY
33615: LIST
33616: LIST
33617: PUSH
33618: LD_INT 0
33620: PUSH
33621: LD_INT 2
33623: NEG
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 1
33631: PUSH
33632: LD_INT 1
33634: NEG
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 2
33642: PUSH
33643: LD_INT 0
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 2
33652: PUSH
33653: LD_INT 1
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 2
33662: PUSH
33663: LD_INT 2
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 1
33672: PUSH
33673: LD_INT 2
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: PUSH
33680: LD_INT 0
33682: PUSH
33683: LD_INT 2
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: LD_INT 1
33692: NEG
33693: PUSH
33694: LD_INT 1
33696: PUSH
33697: EMPTY
33698: LIST
33699: LIST
33700: PUSH
33701: LD_INT 2
33703: NEG
33704: PUSH
33705: LD_INT 0
33707: PUSH
33708: EMPTY
33709: LIST
33710: LIST
33711: PUSH
33712: LD_INT 2
33714: NEG
33715: PUSH
33716: LD_INT 1
33718: NEG
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: LD_INT 2
33726: NEG
33727: PUSH
33728: LD_INT 2
33730: NEG
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 2
33738: PUSH
33739: LD_INT 3
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: LD_INT 1
33748: PUSH
33749: LD_INT 3
33751: PUSH
33752: EMPTY
33753: LIST
33754: LIST
33755: PUSH
33756: LD_INT 1
33758: NEG
33759: PUSH
33760: LD_INT 2
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 2
33769: NEG
33770: PUSH
33771: LD_INT 1
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: LIST
33782: LIST
33783: LIST
33784: LIST
33785: LIST
33786: LIST
33787: LIST
33788: LIST
33789: LIST
33790: LIST
33791: LIST
33792: LIST
33793: LIST
33794: LIST
33795: LIST
33796: LIST
33797: LIST
33798: LIST
33799: LIST
33800: LIST
33801: LIST
33802: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33803: LD_ADDR_VAR 0 27
33807: PUSH
33808: LD_INT 0
33810: PUSH
33811: LD_INT 0
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 0
33820: PUSH
33821: LD_INT 1
33823: NEG
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 1
33831: PUSH
33832: LD_INT 0
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: LD_INT 1
33841: PUSH
33842: LD_INT 1
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 0
33851: PUSH
33852: LD_INT 1
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 1
33861: NEG
33862: PUSH
33863: LD_INT 0
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: PUSH
33870: LD_INT 1
33872: NEG
33873: PUSH
33874: LD_INT 1
33876: NEG
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 1
33884: NEG
33885: PUSH
33886: LD_INT 2
33888: NEG
33889: PUSH
33890: EMPTY
33891: LIST
33892: LIST
33893: PUSH
33894: LD_INT 0
33896: PUSH
33897: LD_INT 2
33899: NEG
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 1
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 2
33918: PUSH
33919: LD_INT 0
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 2
33928: PUSH
33929: LD_INT 1
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 2
33938: PUSH
33939: LD_INT 2
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 1
33948: PUSH
33949: LD_INT 2
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 0
33958: PUSH
33959: LD_INT 2
33961: PUSH
33962: EMPTY
33963: LIST
33964: LIST
33965: PUSH
33966: LD_INT 1
33968: NEG
33969: PUSH
33970: LD_INT 1
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 2
33979: NEG
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: LD_INT 2
33990: NEG
33991: PUSH
33992: LD_INT 1
33994: NEG
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 2
34002: NEG
34003: PUSH
34004: LD_INT 2
34006: NEG
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 1
34014: NEG
34015: PUSH
34016: LD_INT 2
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 2
34025: NEG
34026: PUSH
34027: LD_INT 1
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: LD_INT 3
34036: NEG
34037: PUSH
34038: LD_INT 1
34040: NEG
34041: PUSH
34042: EMPTY
34043: LIST
34044: LIST
34045: PUSH
34046: LD_INT 3
34048: NEG
34049: PUSH
34050: LD_INT 2
34052: NEG
34053: PUSH
34054: EMPTY
34055: LIST
34056: LIST
34057: PUSH
34058: EMPTY
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34083: LD_ADDR_VAR 0 28
34087: PUSH
34088: LD_INT 0
34090: PUSH
34091: LD_INT 0
34093: PUSH
34094: EMPTY
34095: LIST
34096: LIST
34097: PUSH
34098: LD_INT 0
34100: PUSH
34101: LD_INT 1
34103: NEG
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PUSH
34109: LD_INT 1
34111: PUSH
34112: LD_INT 0
34114: PUSH
34115: EMPTY
34116: LIST
34117: LIST
34118: PUSH
34119: LD_INT 1
34121: PUSH
34122: LD_INT 1
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: PUSH
34129: LD_INT 0
34131: PUSH
34132: LD_INT 1
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 1
34141: NEG
34142: PUSH
34143: LD_INT 0
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: LD_INT 1
34156: NEG
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 1
34164: NEG
34165: PUSH
34166: LD_INT 2
34168: NEG
34169: PUSH
34170: EMPTY
34171: LIST
34172: LIST
34173: PUSH
34174: LD_INT 0
34176: PUSH
34177: LD_INT 2
34179: NEG
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 1
34187: PUSH
34188: LD_INT 1
34190: NEG
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 2
34198: PUSH
34199: LD_INT 0
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 2
34208: PUSH
34209: LD_INT 1
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: LD_INT 2
34218: PUSH
34219: LD_INT 2
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PUSH
34226: LD_INT 1
34228: PUSH
34229: LD_INT 2
34231: PUSH
34232: EMPTY
34233: LIST
34234: LIST
34235: PUSH
34236: LD_INT 0
34238: PUSH
34239: LD_INT 2
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: PUSH
34246: LD_INT 1
34248: NEG
34249: PUSH
34250: LD_INT 1
34252: PUSH
34253: EMPTY
34254: LIST
34255: LIST
34256: PUSH
34257: LD_INT 2
34259: NEG
34260: PUSH
34261: LD_INT 0
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: PUSH
34268: LD_INT 2
34270: NEG
34271: PUSH
34272: LD_INT 1
34274: NEG
34275: PUSH
34276: EMPTY
34277: LIST
34278: LIST
34279: PUSH
34280: LD_INT 2
34282: NEG
34283: PUSH
34284: LD_INT 2
34286: NEG
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 2
34294: NEG
34295: PUSH
34296: LD_INT 3
34298: NEG
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: PUSH
34304: LD_INT 1
34306: NEG
34307: PUSH
34308: LD_INT 3
34310: NEG
34311: PUSH
34312: EMPTY
34313: LIST
34314: LIST
34315: PUSH
34316: LD_INT 3
34318: NEG
34319: PUSH
34320: LD_INT 1
34322: NEG
34323: PUSH
34324: EMPTY
34325: LIST
34326: LIST
34327: PUSH
34328: LD_INT 3
34330: NEG
34331: PUSH
34332: LD_INT 2
34334: NEG
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: LIST
34353: LIST
34354: LIST
34355: LIST
34356: LIST
34357: LIST
34358: LIST
34359: LIST
34360: LIST
34361: LIST
34362: LIST
34363: LIST
34364: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34365: LD_ADDR_VAR 0 29
34369: PUSH
34370: LD_INT 0
34372: PUSH
34373: LD_INT 0
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: LD_INT 0
34382: PUSH
34383: LD_INT 1
34385: NEG
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: PUSH
34391: LD_INT 1
34393: PUSH
34394: LD_INT 0
34396: PUSH
34397: EMPTY
34398: LIST
34399: LIST
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: LD_INT 1
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 0
34413: PUSH
34414: LD_INT 1
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: NEG
34424: PUSH
34425: LD_INT 0
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: LD_INT 1
34434: NEG
34435: PUSH
34436: LD_INT 1
34438: NEG
34439: PUSH
34440: EMPTY
34441: LIST
34442: LIST
34443: PUSH
34444: LD_INT 1
34446: NEG
34447: PUSH
34448: LD_INT 2
34450: NEG
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: LD_INT 2
34461: NEG
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: LD_INT 1
34469: PUSH
34470: LD_INT 1
34472: NEG
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 2
34480: PUSH
34481: LD_INT 0
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 2
34490: PUSH
34491: LD_INT 1
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 1
34500: PUSH
34501: LD_INT 2
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 0
34510: PUSH
34511: LD_INT 2
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 1
34520: NEG
34521: PUSH
34522: LD_INT 1
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: PUSH
34529: LD_INT 2
34531: NEG
34532: PUSH
34533: LD_INT 1
34535: NEG
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: PUSH
34541: LD_INT 2
34543: NEG
34544: PUSH
34545: LD_INT 2
34547: NEG
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 2
34555: NEG
34556: PUSH
34557: LD_INT 3
34559: NEG
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 2
34567: PUSH
34568: LD_INT 1
34570: NEG
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 3
34578: PUSH
34579: LD_INT 1
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 1
34588: PUSH
34589: LD_INT 3
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 1
34598: NEG
34599: PUSH
34600: LD_INT 2
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: LD_INT 3
34609: NEG
34610: PUSH
34611: LD_INT 2
34613: NEG
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: LIST
34625: LIST
34626: LIST
34627: LIST
34628: LIST
34629: LIST
34630: LIST
34631: LIST
34632: LIST
34633: LIST
34634: LIST
34635: LIST
34636: LIST
34637: LIST
34638: LIST
34639: LIST
34640: LIST
34641: LIST
34642: LIST
34643: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34644: LD_ADDR_VAR 0 30
34648: PUSH
34649: LD_INT 0
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 0
34661: PUSH
34662: LD_INT 1
34664: NEG
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: PUSH
34670: LD_INT 1
34672: PUSH
34673: LD_INT 0
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 1
34682: PUSH
34683: LD_INT 1
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 0
34692: PUSH
34693: LD_INT 1
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 1
34702: NEG
34703: PUSH
34704: LD_INT 0
34706: PUSH
34707: EMPTY
34708: LIST
34709: LIST
34710: PUSH
34711: LD_INT 1
34713: NEG
34714: PUSH
34715: LD_INT 1
34717: NEG
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 1
34725: NEG
34726: PUSH
34727: LD_INT 2
34729: NEG
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: LD_INT 0
34737: PUSH
34738: LD_INT 2
34740: NEG
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: LD_INT 1
34751: NEG
34752: PUSH
34753: EMPTY
34754: LIST
34755: LIST
34756: PUSH
34757: LD_INT 2
34759: PUSH
34760: LD_INT 0
34762: PUSH
34763: EMPTY
34764: LIST
34765: LIST
34766: PUSH
34767: LD_INT 2
34769: PUSH
34770: LD_INT 1
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: LD_INT 2
34779: PUSH
34780: LD_INT 2
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PUSH
34787: LD_INT 1
34789: PUSH
34790: LD_INT 2
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PUSH
34797: LD_INT 1
34799: NEG
34800: PUSH
34801: LD_INT 1
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 2
34810: NEG
34811: PUSH
34812: LD_INT 0
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 2
34821: NEG
34822: PUSH
34823: LD_INT 1
34825: NEG
34826: PUSH
34827: EMPTY
34828: LIST
34829: LIST
34830: PUSH
34831: LD_INT 1
34833: NEG
34834: PUSH
34835: LD_INT 3
34837: NEG
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PUSH
34843: LD_INT 1
34845: PUSH
34846: LD_INT 2
34848: NEG
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 3
34856: PUSH
34857: LD_INT 2
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 2
34866: PUSH
34867: LD_INT 3
34869: PUSH
34870: EMPTY
34871: LIST
34872: LIST
34873: PUSH
34874: LD_INT 2
34876: NEG
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 3
34887: NEG
34888: PUSH
34889: LD_INT 1
34891: NEG
34892: PUSH
34893: EMPTY
34894: LIST
34895: LIST
34896: PUSH
34897: EMPTY
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: LIST
34903: LIST
34904: LIST
34905: LIST
34906: LIST
34907: LIST
34908: LIST
34909: LIST
34910: LIST
34911: LIST
34912: LIST
34913: LIST
34914: LIST
34915: LIST
34916: LIST
34917: LIST
34918: LIST
34919: LIST
34920: LIST
34921: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34922: LD_ADDR_VAR 0 31
34926: PUSH
34927: LD_INT 0
34929: PUSH
34930: LD_INT 0
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 0
34939: PUSH
34940: LD_INT 1
34942: NEG
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 1
34950: PUSH
34951: LD_INT 0
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 1
34960: PUSH
34961: LD_INT 1
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 0
34970: PUSH
34971: LD_INT 1
34973: PUSH
34974: EMPTY
34975: LIST
34976: LIST
34977: PUSH
34978: LD_INT 1
34980: NEG
34981: PUSH
34982: LD_INT 0
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 1
34991: NEG
34992: PUSH
34993: LD_INT 1
34995: NEG
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 1
35003: NEG
35004: PUSH
35005: LD_INT 2
35007: NEG
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: LD_INT 1
35015: PUSH
35016: LD_INT 1
35018: NEG
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: LD_INT 2
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 2
35036: PUSH
35037: LD_INT 1
35039: PUSH
35040: EMPTY
35041: LIST
35042: LIST
35043: PUSH
35044: LD_INT 2
35046: PUSH
35047: LD_INT 2
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: LD_INT 1
35056: PUSH
35057: LD_INT 2
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 0
35066: PUSH
35067: LD_INT 2
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 1
35076: NEG
35077: PUSH
35078: LD_INT 1
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PUSH
35085: LD_INT 2
35087: NEG
35088: PUSH
35089: LD_INT 1
35091: NEG
35092: PUSH
35093: EMPTY
35094: LIST
35095: LIST
35096: PUSH
35097: LD_INT 2
35099: NEG
35100: PUSH
35101: LD_INT 2
35103: NEG
35104: PUSH
35105: EMPTY
35106: LIST
35107: LIST
35108: PUSH
35109: LD_INT 2
35111: NEG
35112: PUSH
35113: LD_INT 3
35115: NEG
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: LD_INT 2
35123: PUSH
35124: LD_INT 1
35126: NEG
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 3
35134: PUSH
35135: LD_INT 1
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: LD_INT 1
35144: PUSH
35145: LD_INT 3
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: LD_INT 2
35158: PUSH
35159: EMPTY
35160: LIST
35161: LIST
35162: PUSH
35163: LD_INT 3
35165: NEG
35166: PUSH
35167: LD_INT 2
35169: NEG
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: LIST
35179: LIST
35180: LIST
35181: LIST
35182: LIST
35183: LIST
35184: LIST
35185: LIST
35186: LIST
35187: LIST
35188: LIST
35189: LIST
35190: LIST
35191: LIST
35192: LIST
35193: LIST
35194: LIST
35195: LIST
35196: LIST
35197: LIST
35198: LIST
35199: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35200: LD_ADDR_VAR 0 32
35204: PUSH
35205: LD_INT 0
35207: PUSH
35208: LD_INT 0
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 0
35217: PUSH
35218: LD_INT 1
35220: NEG
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 1
35228: PUSH
35229: LD_INT 0
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 1
35238: PUSH
35239: LD_INT 1
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 0
35248: PUSH
35249: LD_INT 1
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 1
35258: NEG
35259: PUSH
35260: LD_INT 0
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 1
35269: NEG
35270: PUSH
35271: LD_INT 1
35273: NEG
35274: PUSH
35275: EMPTY
35276: LIST
35277: LIST
35278: PUSH
35279: LD_INT 1
35281: NEG
35282: PUSH
35283: LD_INT 2
35285: NEG
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: PUSH
35291: LD_INT 0
35293: PUSH
35294: LD_INT 2
35296: NEG
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 1
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 2
35315: PUSH
35316: LD_INT 1
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 2
35325: PUSH
35326: LD_INT 2
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 1
35335: PUSH
35336: LD_INT 2
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 0
35345: PUSH
35346: LD_INT 2
35348: PUSH
35349: EMPTY
35350: LIST
35351: LIST
35352: PUSH
35353: LD_INT 1
35355: NEG
35356: PUSH
35357: LD_INT 1
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 2
35366: NEG
35367: PUSH
35368: LD_INT 0
35370: PUSH
35371: EMPTY
35372: LIST
35373: LIST
35374: PUSH
35375: LD_INT 2
35377: NEG
35378: PUSH
35379: LD_INT 1
35381: NEG
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 1
35389: NEG
35390: PUSH
35391: LD_INT 3
35393: NEG
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 1
35401: PUSH
35402: LD_INT 2
35404: NEG
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: LD_INT 3
35412: PUSH
35413: LD_INT 2
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: LD_INT 2
35422: PUSH
35423: LD_INT 3
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 2
35432: NEG
35433: PUSH
35434: LD_INT 1
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PUSH
35441: LD_INT 3
35443: NEG
35444: PUSH
35445: LD_INT 1
35447: NEG
35448: PUSH
35449: EMPTY
35450: LIST
35451: LIST
35452: PUSH
35453: EMPTY
35454: LIST
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: LIST
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35478: LD_ADDR_VAR 0 33
35482: PUSH
35483: LD_INT 0
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 0
35495: PUSH
35496: LD_INT 1
35498: NEG
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 1
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 0
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 1
35536: NEG
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 1
35547: NEG
35548: PUSH
35549: LD_INT 1
35551: NEG
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 1
35559: NEG
35560: PUSH
35561: LD_INT 2
35563: NEG
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 1
35571: PUSH
35572: LD_INT 1
35574: NEG
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 2
35582: PUSH
35583: LD_INT 0
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 2
35592: PUSH
35593: LD_INT 1
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 1
35602: PUSH
35603: LD_INT 2
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: PUSH
35610: LD_INT 0
35612: PUSH
35613: LD_INT 2
35615: PUSH
35616: EMPTY
35617: LIST
35618: LIST
35619: PUSH
35620: LD_INT 1
35622: NEG
35623: PUSH
35624: LD_INT 1
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 2
35633: NEG
35634: PUSH
35635: LD_INT 0
35637: PUSH
35638: EMPTY
35639: LIST
35640: LIST
35641: PUSH
35642: LD_INT 2
35644: NEG
35645: PUSH
35646: LD_INT 1
35648: NEG
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: LD_INT 2
35656: NEG
35657: PUSH
35658: LD_INT 2
35660: NEG
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: LD_INT 2
35668: NEG
35669: PUSH
35670: LD_INT 3
35672: NEG
35673: PUSH
35674: EMPTY
35675: LIST
35676: LIST
35677: PUSH
35678: LD_INT 2
35680: PUSH
35681: LD_INT 1
35683: NEG
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 3
35691: PUSH
35692: LD_INT 1
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: LD_INT 1
35701: PUSH
35702: LD_INT 3
35704: PUSH
35705: EMPTY
35706: LIST
35707: LIST
35708: PUSH
35709: LD_INT 1
35711: NEG
35712: PUSH
35713: LD_INT 2
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: LD_INT 3
35722: NEG
35723: PUSH
35724: LD_INT 2
35726: NEG
35727: PUSH
35728: EMPTY
35729: LIST
35730: LIST
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: LIST
35745: LIST
35746: LIST
35747: LIST
35748: LIST
35749: LIST
35750: LIST
35751: LIST
35752: LIST
35753: LIST
35754: LIST
35755: LIST
35756: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35757: LD_ADDR_VAR 0 34
35761: PUSH
35762: LD_INT 0
35764: PUSH
35765: LD_INT 0
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 0
35774: PUSH
35775: LD_INT 1
35777: NEG
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: LD_INT 1
35785: PUSH
35786: LD_INT 0
35788: PUSH
35789: EMPTY
35790: LIST
35791: LIST
35792: PUSH
35793: LD_INT 1
35795: PUSH
35796: LD_INT 1
35798: PUSH
35799: EMPTY
35800: LIST
35801: LIST
35802: PUSH
35803: LD_INT 0
35805: PUSH
35806: LD_INT 1
35808: PUSH
35809: EMPTY
35810: LIST
35811: LIST
35812: PUSH
35813: LD_INT 1
35815: NEG
35816: PUSH
35817: LD_INT 0
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 1
35826: NEG
35827: PUSH
35828: LD_INT 1
35830: NEG
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PUSH
35836: LD_INT 1
35838: NEG
35839: PUSH
35840: LD_INT 2
35842: NEG
35843: PUSH
35844: EMPTY
35845: LIST
35846: LIST
35847: PUSH
35848: LD_INT 0
35850: PUSH
35851: LD_INT 2
35853: NEG
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 1
35861: PUSH
35862: LD_INT 1
35864: NEG
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 2
35872: PUSH
35873: LD_INT 1
35875: PUSH
35876: EMPTY
35877: LIST
35878: LIST
35879: PUSH
35880: LD_INT 2
35882: PUSH
35883: LD_INT 2
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: PUSH
35890: LD_INT 1
35892: PUSH
35893: LD_INT 2
35895: PUSH
35896: EMPTY
35897: LIST
35898: LIST
35899: PUSH
35900: LD_INT 1
35902: NEG
35903: PUSH
35904: LD_INT 1
35906: PUSH
35907: EMPTY
35908: LIST
35909: LIST
35910: PUSH
35911: LD_INT 2
35913: NEG
35914: PUSH
35915: LD_INT 0
35917: PUSH
35918: EMPTY
35919: LIST
35920: LIST
35921: PUSH
35922: LD_INT 2
35924: NEG
35925: PUSH
35926: LD_INT 1
35928: NEG
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PUSH
35934: LD_INT 2
35936: NEG
35937: PUSH
35938: LD_INT 2
35940: NEG
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 1
35948: NEG
35949: PUSH
35950: LD_INT 3
35952: NEG
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: LD_INT 1
35960: PUSH
35961: LD_INT 2
35963: NEG
35964: PUSH
35965: EMPTY
35966: LIST
35967: LIST
35968: PUSH
35969: LD_INT 3
35971: PUSH
35972: LD_INT 2
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: PUSH
35979: LD_INT 2
35981: PUSH
35982: LD_INT 3
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 2
35991: NEG
35992: PUSH
35993: LD_INT 1
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 3
36002: NEG
36003: PUSH
36004: LD_INT 1
36006: NEG
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: LIST
36016: LIST
36017: LIST
36018: LIST
36019: LIST
36020: LIST
36021: LIST
36022: LIST
36023: LIST
36024: LIST
36025: LIST
36026: LIST
36027: LIST
36028: LIST
36029: LIST
36030: LIST
36031: LIST
36032: LIST
36033: LIST
36034: LIST
36035: LIST
36036: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36037: LD_ADDR_VAR 0 35
36041: PUSH
36042: LD_INT 0
36044: PUSH
36045: LD_INT 0
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 0
36054: PUSH
36055: LD_INT 1
36057: NEG
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: LD_INT 1
36065: PUSH
36066: LD_INT 0
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: LD_INT 1
36075: PUSH
36076: LD_INT 1
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: LD_INT 0
36085: PUSH
36086: LD_INT 1
36088: PUSH
36089: EMPTY
36090: LIST
36091: LIST
36092: PUSH
36093: LD_INT 1
36095: NEG
36096: PUSH
36097: LD_INT 0
36099: PUSH
36100: EMPTY
36101: LIST
36102: LIST
36103: PUSH
36104: LD_INT 1
36106: NEG
36107: PUSH
36108: LD_INT 1
36110: NEG
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: PUSH
36116: LD_INT 2
36118: PUSH
36119: LD_INT 1
36121: PUSH
36122: EMPTY
36123: LIST
36124: LIST
36125: PUSH
36126: LD_INT 2
36128: NEG
36129: PUSH
36130: LD_INT 1
36132: NEG
36133: PUSH
36134: EMPTY
36135: LIST
36136: LIST
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: LIST
36144: LIST
36145: LIST
36146: LIST
36147: LIST
36148: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36149: LD_ADDR_VAR 0 36
36153: PUSH
36154: LD_INT 0
36156: PUSH
36157: LD_INT 0
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PUSH
36164: LD_INT 0
36166: PUSH
36167: LD_INT 1
36169: NEG
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 1
36177: PUSH
36178: LD_INT 0
36180: PUSH
36181: EMPTY
36182: LIST
36183: LIST
36184: PUSH
36185: LD_INT 1
36187: PUSH
36188: LD_INT 1
36190: PUSH
36191: EMPTY
36192: LIST
36193: LIST
36194: PUSH
36195: LD_INT 0
36197: PUSH
36198: LD_INT 1
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: LD_INT 1
36207: NEG
36208: PUSH
36209: LD_INT 0
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 1
36218: NEG
36219: PUSH
36220: LD_INT 1
36222: NEG
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: PUSH
36228: LD_INT 1
36230: NEG
36231: PUSH
36232: LD_INT 2
36234: NEG
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 1
36242: PUSH
36243: LD_INT 2
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: LIST
36254: LIST
36255: LIST
36256: LIST
36257: LIST
36258: LIST
36259: LIST
36260: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36261: LD_ADDR_VAR 0 37
36265: PUSH
36266: LD_INT 0
36268: PUSH
36269: LD_INT 0
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 0
36278: PUSH
36279: LD_INT 1
36281: NEG
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 1
36289: PUSH
36290: LD_INT 0
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 1
36299: PUSH
36300: LD_INT 1
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: LD_INT 0
36309: PUSH
36310: LD_INT 1
36312: PUSH
36313: EMPTY
36314: LIST
36315: LIST
36316: PUSH
36317: LD_INT 1
36319: NEG
36320: PUSH
36321: LD_INT 0
36323: PUSH
36324: EMPTY
36325: LIST
36326: LIST
36327: PUSH
36328: LD_INT 1
36330: NEG
36331: PUSH
36332: LD_INT 1
36334: NEG
36335: PUSH
36336: EMPTY
36337: LIST
36338: LIST
36339: PUSH
36340: LD_INT 1
36342: PUSH
36343: LD_INT 1
36345: NEG
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 1
36353: NEG
36354: PUSH
36355: LD_INT 1
36357: PUSH
36358: EMPTY
36359: LIST
36360: LIST
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: LIST
36366: LIST
36367: LIST
36368: LIST
36369: LIST
36370: LIST
36371: LIST
36372: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36373: LD_ADDR_VAR 0 38
36377: PUSH
36378: LD_INT 0
36380: PUSH
36381: LD_INT 0
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 0
36390: PUSH
36391: LD_INT 1
36393: NEG
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: PUSH
36399: LD_INT 1
36401: PUSH
36402: LD_INT 0
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 1
36411: PUSH
36412: LD_INT 1
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 0
36421: PUSH
36422: LD_INT 1
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 1
36431: NEG
36432: PUSH
36433: LD_INT 0
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: LD_INT 1
36442: NEG
36443: PUSH
36444: LD_INT 1
36446: NEG
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: PUSH
36452: LD_INT 2
36454: PUSH
36455: LD_INT 1
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: PUSH
36462: LD_INT 2
36464: NEG
36465: PUSH
36466: LD_INT 1
36468: NEG
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36485: LD_ADDR_VAR 0 39
36489: PUSH
36490: LD_INT 0
36492: PUSH
36493: LD_INT 0
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 0
36502: PUSH
36503: LD_INT 1
36505: NEG
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: PUSH
36511: LD_INT 1
36513: PUSH
36514: LD_INT 0
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 1
36523: PUSH
36524: LD_INT 1
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 0
36533: PUSH
36534: LD_INT 1
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 1
36543: NEG
36544: PUSH
36545: LD_INT 0
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 1
36554: NEG
36555: PUSH
36556: LD_INT 1
36558: NEG
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: LD_INT 1
36566: NEG
36567: PUSH
36568: LD_INT 2
36570: NEG
36571: PUSH
36572: EMPTY
36573: LIST
36574: LIST
36575: PUSH
36576: LD_INT 1
36578: PUSH
36579: LD_INT 2
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: EMPTY
36587: LIST
36588: LIST
36589: LIST
36590: LIST
36591: LIST
36592: LIST
36593: LIST
36594: LIST
36595: LIST
36596: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36597: LD_ADDR_VAR 0 40
36601: PUSH
36602: LD_INT 0
36604: PUSH
36605: LD_INT 0
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 0
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 1
36625: PUSH
36626: LD_INT 0
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: PUSH
36633: LD_INT 1
36635: PUSH
36636: LD_INT 1
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 0
36645: PUSH
36646: LD_INT 1
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 1
36655: NEG
36656: PUSH
36657: LD_INT 0
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 1
36666: NEG
36667: PUSH
36668: LD_INT 1
36670: NEG
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 1
36678: PUSH
36679: LD_INT 1
36681: NEG
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: LD_INT 1
36689: NEG
36690: PUSH
36691: LD_INT 1
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: LIST
36702: LIST
36703: LIST
36704: LIST
36705: LIST
36706: LIST
36707: LIST
36708: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36709: LD_ADDR_VAR 0 41
36713: PUSH
36714: LD_INT 0
36716: PUSH
36717: LD_INT 0
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 0
36726: PUSH
36727: LD_INT 1
36729: NEG
36730: PUSH
36731: EMPTY
36732: LIST
36733: LIST
36734: PUSH
36735: LD_INT 1
36737: PUSH
36738: LD_INT 0
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: LD_INT 1
36747: PUSH
36748: LD_INT 1
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 0
36757: PUSH
36758: LD_INT 1
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: LD_INT 1
36767: NEG
36768: PUSH
36769: LD_INT 0
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: PUSH
36776: LD_INT 1
36778: NEG
36779: PUSH
36780: LD_INT 1
36782: NEG
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 1
36790: NEG
36791: PUSH
36792: LD_INT 2
36794: NEG
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: LD_INT 1
36802: PUSH
36803: LD_INT 1
36805: NEG
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 2
36813: PUSH
36814: LD_INT 0
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 2
36823: PUSH
36824: LD_INT 1
36826: PUSH
36827: EMPTY
36828: LIST
36829: LIST
36830: PUSH
36831: LD_INT 2
36833: PUSH
36834: LD_INT 2
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 1
36843: PUSH
36844: LD_INT 2
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: PUSH
36851: LD_INT 1
36853: NEG
36854: PUSH
36855: LD_INT 1
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: PUSH
36862: LD_INT 2
36864: NEG
36865: PUSH
36866: LD_INT 0
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 2
36875: NEG
36876: PUSH
36877: LD_INT 1
36879: NEG
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 2
36887: NEG
36888: PUSH
36889: LD_INT 2
36891: NEG
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 2
36899: NEG
36900: PUSH
36901: LD_INT 3
36903: NEG
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 2
36911: PUSH
36912: LD_INT 1
36914: NEG
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: LD_INT 3
36922: PUSH
36923: LD_INT 0
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 3
36932: PUSH
36933: LD_INT 1
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 3
36942: PUSH
36943: LD_INT 2
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 3
36952: PUSH
36953: LD_INT 3
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 2
36962: PUSH
36963: LD_INT 3
36965: PUSH
36966: EMPTY
36967: LIST
36968: LIST
36969: PUSH
36970: LD_INT 2
36972: NEG
36973: PUSH
36974: LD_INT 1
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 3
36983: NEG
36984: PUSH
36985: LD_INT 0
36987: PUSH
36988: EMPTY
36989: LIST
36990: LIST
36991: PUSH
36992: LD_INT 3
36994: NEG
36995: PUSH
36996: LD_INT 1
36998: NEG
36999: PUSH
37000: EMPTY
37001: LIST
37002: LIST
37003: PUSH
37004: LD_INT 3
37006: NEG
37007: PUSH
37008: LD_INT 2
37010: NEG
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: PUSH
37016: LD_INT 3
37018: NEG
37019: PUSH
37020: LD_INT 3
37022: NEG
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: LIST
37034: LIST
37035: LIST
37036: LIST
37037: LIST
37038: LIST
37039: LIST
37040: LIST
37041: LIST
37042: LIST
37043: LIST
37044: LIST
37045: LIST
37046: LIST
37047: LIST
37048: LIST
37049: LIST
37050: LIST
37051: LIST
37052: LIST
37053: LIST
37054: LIST
37055: LIST
37056: LIST
37057: LIST
37058: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37059: LD_ADDR_VAR 0 42
37063: PUSH
37064: LD_INT 0
37066: PUSH
37067: LD_INT 0
37069: PUSH
37070: EMPTY
37071: LIST
37072: LIST
37073: PUSH
37074: LD_INT 0
37076: PUSH
37077: LD_INT 1
37079: NEG
37080: PUSH
37081: EMPTY
37082: LIST
37083: LIST
37084: PUSH
37085: LD_INT 1
37087: PUSH
37088: LD_INT 0
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 1
37097: PUSH
37098: LD_INT 1
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: LD_INT 0
37107: PUSH
37108: LD_INT 1
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: PUSH
37115: LD_INT 1
37117: NEG
37118: PUSH
37119: LD_INT 0
37121: PUSH
37122: EMPTY
37123: LIST
37124: LIST
37125: PUSH
37126: LD_INT 1
37128: NEG
37129: PUSH
37130: LD_INT 1
37132: NEG
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 1
37140: NEG
37141: PUSH
37142: LD_INT 2
37144: NEG
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 0
37152: PUSH
37153: LD_INT 2
37155: NEG
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 1
37163: PUSH
37164: LD_INT 1
37166: NEG
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: PUSH
37172: LD_INT 2
37174: PUSH
37175: LD_INT 1
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 2
37184: PUSH
37185: LD_INT 2
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: LD_INT 1
37194: PUSH
37195: LD_INT 2
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 0
37204: PUSH
37205: LD_INT 2
37207: PUSH
37208: EMPTY
37209: LIST
37210: LIST
37211: PUSH
37212: LD_INT 1
37214: NEG
37215: PUSH
37216: LD_INT 1
37218: PUSH
37219: EMPTY
37220: LIST
37221: LIST
37222: PUSH
37223: LD_INT 2
37225: NEG
37226: PUSH
37227: LD_INT 1
37229: NEG
37230: PUSH
37231: EMPTY
37232: LIST
37233: LIST
37234: PUSH
37235: LD_INT 2
37237: NEG
37238: PUSH
37239: LD_INT 2
37241: NEG
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 2
37249: NEG
37250: PUSH
37251: LD_INT 3
37253: NEG
37254: PUSH
37255: EMPTY
37256: LIST
37257: LIST
37258: PUSH
37259: LD_INT 1
37261: NEG
37262: PUSH
37263: LD_INT 3
37265: NEG
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 0
37273: PUSH
37274: LD_INT 3
37276: NEG
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 1
37284: PUSH
37285: LD_INT 2
37287: NEG
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 3
37295: PUSH
37296: LD_INT 2
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: LD_INT 3
37305: PUSH
37306: LD_INT 3
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PUSH
37313: LD_INT 2
37315: PUSH
37316: LD_INT 3
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 1
37325: PUSH
37326: LD_INT 3
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 0
37335: PUSH
37336: LD_INT 3
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: PUSH
37343: LD_INT 1
37345: NEG
37346: PUSH
37347: LD_INT 2
37349: PUSH
37350: EMPTY
37351: LIST
37352: LIST
37353: PUSH
37354: LD_INT 3
37356: NEG
37357: PUSH
37358: LD_INT 2
37360: NEG
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 3
37368: NEG
37369: PUSH
37370: LD_INT 3
37372: NEG
37373: PUSH
37374: EMPTY
37375: LIST
37376: LIST
37377: PUSH
37378: EMPTY
37379: LIST
37380: LIST
37381: LIST
37382: LIST
37383: LIST
37384: LIST
37385: LIST
37386: LIST
37387: LIST
37388: LIST
37389: LIST
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37409: LD_ADDR_VAR 0 43
37413: PUSH
37414: LD_INT 0
37416: PUSH
37417: LD_INT 0
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: PUSH
37424: LD_INT 0
37426: PUSH
37427: LD_INT 1
37429: NEG
37430: PUSH
37431: EMPTY
37432: LIST
37433: LIST
37434: PUSH
37435: LD_INT 1
37437: PUSH
37438: LD_INT 0
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: LD_INT 1
37447: PUSH
37448: LD_INT 1
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: LD_INT 0
37457: PUSH
37458: LD_INT 1
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 1
37467: NEG
37468: PUSH
37469: LD_INT 0
37471: PUSH
37472: EMPTY
37473: LIST
37474: LIST
37475: PUSH
37476: LD_INT 1
37478: NEG
37479: PUSH
37480: LD_INT 1
37482: NEG
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 1
37490: NEG
37491: PUSH
37492: LD_INT 2
37494: NEG
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: LD_INT 0
37502: PUSH
37503: LD_INT 2
37505: NEG
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 1
37513: PUSH
37514: LD_INT 1
37516: NEG
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 2
37524: PUSH
37525: LD_INT 0
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 2
37534: PUSH
37535: LD_INT 1
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: LD_INT 1
37544: PUSH
37545: LD_INT 2
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 0
37554: PUSH
37555: LD_INT 2
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 1
37564: NEG
37565: PUSH
37566: LD_INT 1
37568: PUSH
37569: EMPTY
37570: LIST
37571: LIST
37572: PUSH
37573: LD_INT 2
37575: NEG
37576: PUSH
37577: LD_INT 0
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: LD_INT 2
37586: NEG
37587: PUSH
37588: LD_INT 1
37590: NEG
37591: PUSH
37592: EMPTY
37593: LIST
37594: LIST
37595: PUSH
37596: LD_INT 1
37598: NEG
37599: PUSH
37600: LD_INT 3
37602: NEG
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 0
37610: PUSH
37611: LD_INT 3
37613: NEG
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: PUSH
37619: LD_INT 1
37621: PUSH
37622: LD_INT 2
37624: NEG
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PUSH
37630: LD_INT 2
37632: PUSH
37633: LD_INT 1
37635: NEG
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 3
37643: PUSH
37644: LD_INT 0
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 3
37653: PUSH
37654: LD_INT 1
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: PUSH
37661: LD_INT 1
37663: PUSH
37664: LD_INT 3
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 0
37673: PUSH
37674: LD_INT 3
37676: PUSH
37677: EMPTY
37678: LIST
37679: LIST
37680: PUSH
37681: LD_INT 1
37683: NEG
37684: PUSH
37685: LD_INT 2
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PUSH
37692: LD_INT 2
37694: NEG
37695: PUSH
37696: LD_INT 1
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 3
37705: NEG
37706: PUSH
37707: LD_INT 0
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 3
37716: NEG
37717: PUSH
37718: LD_INT 1
37720: NEG
37721: PUSH
37722: EMPTY
37723: LIST
37724: LIST
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: LIST
37730: LIST
37731: LIST
37732: LIST
37733: LIST
37734: LIST
37735: LIST
37736: LIST
37737: LIST
37738: LIST
37739: LIST
37740: LIST
37741: LIST
37742: LIST
37743: LIST
37744: LIST
37745: LIST
37746: LIST
37747: LIST
37748: LIST
37749: LIST
37750: LIST
37751: LIST
37752: LIST
37753: LIST
37754: LIST
37755: LIST
37756: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37757: LD_ADDR_VAR 0 44
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: LD_INT 0
37767: PUSH
37768: EMPTY
37769: LIST
37770: LIST
37771: PUSH
37772: LD_INT 0
37774: PUSH
37775: LD_INT 1
37777: NEG
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PUSH
37783: LD_INT 1
37785: PUSH
37786: LD_INT 0
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 1
37795: PUSH
37796: LD_INT 1
37798: PUSH
37799: EMPTY
37800: LIST
37801: LIST
37802: PUSH
37803: LD_INT 0
37805: PUSH
37806: LD_INT 1
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PUSH
37813: LD_INT 1
37815: NEG
37816: PUSH
37817: LD_INT 0
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: PUSH
37824: LD_INT 1
37826: NEG
37827: PUSH
37828: LD_INT 1
37830: NEG
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: LD_INT 1
37838: NEG
37839: PUSH
37840: LD_INT 2
37842: NEG
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 1
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 2
37861: PUSH
37862: LD_INT 0
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 2
37871: PUSH
37872: LD_INT 1
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 2
37881: PUSH
37882: LD_INT 2
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: LD_INT 1
37891: PUSH
37892: LD_INT 2
37894: PUSH
37895: EMPTY
37896: LIST
37897: LIST
37898: PUSH
37899: LD_INT 1
37901: NEG
37902: PUSH
37903: LD_INT 1
37905: PUSH
37906: EMPTY
37907: LIST
37908: LIST
37909: PUSH
37910: LD_INT 2
37912: NEG
37913: PUSH
37914: LD_INT 0
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 2
37923: NEG
37924: PUSH
37925: LD_INT 1
37927: NEG
37928: PUSH
37929: EMPTY
37930: LIST
37931: LIST
37932: PUSH
37933: LD_INT 2
37935: NEG
37936: PUSH
37937: LD_INT 2
37939: NEG
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 2
37947: NEG
37948: PUSH
37949: LD_INT 3
37951: NEG
37952: PUSH
37953: EMPTY
37954: LIST
37955: LIST
37956: PUSH
37957: LD_INT 2
37959: PUSH
37960: LD_INT 1
37962: NEG
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 3
37970: PUSH
37971: LD_INT 0
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 3
37980: PUSH
37981: LD_INT 1
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 3
37990: PUSH
37991: LD_INT 2
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: PUSH
37998: LD_INT 3
38000: PUSH
38001: LD_INT 3
38003: PUSH
38004: EMPTY
38005: LIST
38006: LIST
38007: PUSH
38008: LD_INT 2
38010: PUSH
38011: LD_INT 3
38013: PUSH
38014: EMPTY
38015: LIST
38016: LIST
38017: PUSH
38018: LD_INT 2
38020: NEG
38021: PUSH
38022: LD_INT 1
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 3
38031: NEG
38032: PUSH
38033: LD_INT 0
38035: PUSH
38036: EMPTY
38037: LIST
38038: LIST
38039: PUSH
38040: LD_INT 3
38042: NEG
38043: PUSH
38044: LD_INT 1
38046: NEG
38047: PUSH
38048: EMPTY
38049: LIST
38050: LIST
38051: PUSH
38052: LD_INT 3
38054: NEG
38055: PUSH
38056: LD_INT 2
38058: NEG
38059: PUSH
38060: EMPTY
38061: LIST
38062: LIST
38063: PUSH
38064: LD_INT 3
38066: NEG
38067: PUSH
38068: LD_INT 3
38070: NEG
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: EMPTY
38077: LIST
38078: LIST
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: LIST
38087: LIST
38088: LIST
38089: LIST
38090: LIST
38091: LIST
38092: LIST
38093: LIST
38094: LIST
38095: LIST
38096: LIST
38097: LIST
38098: LIST
38099: LIST
38100: LIST
38101: LIST
38102: LIST
38103: LIST
38104: LIST
38105: LIST
38106: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38107: LD_ADDR_VAR 0 45
38111: PUSH
38112: LD_INT 0
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 0
38124: PUSH
38125: LD_INT 1
38127: NEG
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: LD_INT 1
38135: PUSH
38136: LD_INT 0
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: PUSH
38143: LD_INT 1
38145: PUSH
38146: LD_INT 1
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 0
38155: PUSH
38156: LD_INT 1
38158: PUSH
38159: EMPTY
38160: LIST
38161: LIST
38162: PUSH
38163: LD_INT 1
38165: NEG
38166: PUSH
38167: LD_INT 0
38169: PUSH
38170: EMPTY
38171: LIST
38172: LIST
38173: PUSH
38174: LD_INT 1
38176: NEG
38177: PUSH
38178: LD_INT 1
38180: NEG
38181: PUSH
38182: EMPTY
38183: LIST
38184: LIST
38185: PUSH
38186: LD_INT 1
38188: NEG
38189: PUSH
38190: LD_INT 2
38192: NEG
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 0
38200: PUSH
38201: LD_INT 2
38203: NEG
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 1
38211: PUSH
38212: LD_INT 1
38214: NEG
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 2
38222: PUSH
38223: LD_INT 1
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 2
38232: PUSH
38233: LD_INT 2
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 1
38242: PUSH
38243: LD_INT 2
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 0
38252: PUSH
38253: LD_INT 2
38255: PUSH
38256: EMPTY
38257: LIST
38258: LIST
38259: PUSH
38260: LD_INT 1
38262: NEG
38263: PUSH
38264: LD_INT 1
38266: PUSH
38267: EMPTY
38268: LIST
38269: LIST
38270: PUSH
38271: LD_INT 2
38273: NEG
38274: PUSH
38275: LD_INT 1
38277: NEG
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: PUSH
38283: LD_INT 2
38285: NEG
38286: PUSH
38287: LD_INT 2
38289: NEG
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 2
38297: NEG
38298: PUSH
38299: LD_INT 3
38301: NEG
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 1
38309: NEG
38310: PUSH
38311: LD_INT 3
38313: NEG
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 0
38321: PUSH
38322: LD_INT 3
38324: NEG
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 1
38332: PUSH
38333: LD_INT 2
38335: NEG
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 3
38343: PUSH
38344: LD_INT 2
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: PUSH
38351: LD_INT 3
38353: PUSH
38354: LD_INT 3
38356: PUSH
38357: EMPTY
38358: LIST
38359: LIST
38360: PUSH
38361: LD_INT 2
38363: PUSH
38364: LD_INT 3
38366: PUSH
38367: EMPTY
38368: LIST
38369: LIST
38370: PUSH
38371: LD_INT 1
38373: PUSH
38374: LD_INT 3
38376: PUSH
38377: EMPTY
38378: LIST
38379: LIST
38380: PUSH
38381: LD_INT 0
38383: PUSH
38384: LD_INT 3
38386: PUSH
38387: EMPTY
38388: LIST
38389: LIST
38390: PUSH
38391: LD_INT 1
38393: NEG
38394: PUSH
38395: LD_INT 2
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: LD_INT 3
38404: NEG
38405: PUSH
38406: LD_INT 2
38408: NEG
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PUSH
38414: LD_INT 3
38416: NEG
38417: PUSH
38418: LD_INT 3
38420: NEG
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: LIST
38430: LIST
38431: LIST
38432: LIST
38433: LIST
38434: LIST
38435: LIST
38436: LIST
38437: LIST
38438: LIST
38439: LIST
38440: LIST
38441: LIST
38442: LIST
38443: LIST
38444: LIST
38445: LIST
38446: LIST
38447: LIST
38448: LIST
38449: LIST
38450: LIST
38451: LIST
38452: LIST
38453: LIST
38454: LIST
38455: LIST
38456: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38457: LD_ADDR_VAR 0 46
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: LD_INT 0
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 0
38474: PUSH
38475: LD_INT 1
38477: NEG
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 1
38485: PUSH
38486: LD_INT 0
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 1
38495: PUSH
38496: LD_INT 1
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: LD_INT 1
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: LD_INT 1
38515: NEG
38516: PUSH
38517: LD_INT 0
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: PUSH
38524: LD_INT 1
38526: NEG
38527: PUSH
38528: LD_INT 1
38530: NEG
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: LD_INT 1
38538: NEG
38539: PUSH
38540: LD_INT 2
38542: NEG
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: LD_INT 0
38550: PUSH
38551: LD_INT 2
38553: NEG
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: PUSH
38559: LD_INT 1
38561: PUSH
38562: LD_INT 1
38564: NEG
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 2
38572: PUSH
38573: LD_INT 0
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: PUSH
38580: LD_INT 2
38582: PUSH
38583: LD_INT 1
38585: PUSH
38586: EMPTY
38587: LIST
38588: LIST
38589: PUSH
38590: LD_INT 1
38592: PUSH
38593: LD_INT 2
38595: PUSH
38596: EMPTY
38597: LIST
38598: LIST
38599: PUSH
38600: LD_INT 0
38602: PUSH
38603: LD_INT 2
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 1
38612: NEG
38613: PUSH
38614: LD_INT 1
38616: PUSH
38617: EMPTY
38618: LIST
38619: LIST
38620: PUSH
38621: LD_INT 2
38623: NEG
38624: PUSH
38625: LD_INT 0
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 2
38634: NEG
38635: PUSH
38636: LD_INT 1
38638: NEG
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: LD_INT 1
38646: NEG
38647: PUSH
38648: LD_INT 3
38650: NEG
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: LD_INT 0
38658: PUSH
38659: LD_INT 3
38661: NEG
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PUSH
38667: LD_INT 1
38669: PUSH
38670: LD_INT 2
38672: NEG
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 2
38680: PUSH
38681: LD_INT 1
38683: NEG
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 3
38691: PUSH
38692: LD_INT 0
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 3
38701: PUSH
38702: LD_INT 1
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 1
38711: PUSH
38712: LD_INT 3
38714: PUSH
38715: EMPTY
38716: LIST
38717: LIST
38718: PUSH
38719: LD_INT 0
38721: PUSH
38722: LD_INT 3
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: LD_INT 1
38731: NEG
38732: PUSH
38733: LD_INT 2
38735: PUSH
38736: EMPTY
38737: LIST
38738: LIST
38739: PUSH
38740: LD_INT 2
38742: NEG
38743: PUSH
38744: LD_INT 1
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: PUSH
38751: LD_INT 3
38753: NEG
38754: PUSH
38755: LD_INT 0
38757: PUSH
38758: EMPTY
38759: LIST
38760: LIST
38761: PUSH
38762: LD_INT 3
38764: NEG
38765: PUSH
38766: LD_INT 1
38768: NEG
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: LIST
38778: LIST
38779: LIST
38780: LIST
38781: LIST
38782: LIST
38783: LIST
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38805: LD_ADDR_VAR 0 47
38809: PUSH
38810: LD_INT 0
38812: PUSH
38813: LD_INT 0
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: LD_INT 1
38825: NEG
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: LD_INT 0
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: PUSH
38844: LD_INT 1
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 0
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 1
38863: NEG
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 1
38874: NEG
38875: PUSH
38876: LD_INT 1
38878: NEG
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: NEG
38887: PUSH
38888: LD_INT 2
38890: NEG
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: LD_INT 2
38901: NEG
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 1
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 2
38920: NEG
38921: PUSH
38922: LD_INT 1
38924: NEG
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 2
38932: NEG
38933: PUSH
38934: LD_INT 2
38936: NEG
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: LIST
38946: LIST
38947: LIST
38948: LIST
38949: LIST
38950: LIST
38951: LIST
38952: LIST
38953: LIST
38954: LIST
38955: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38956: LD_ADDR_VAR 0 48
38960: PUSH
38961: LD_INT 0
38963: PUSH
38964: LD_INT 0
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 0
38973: PUSH
38974: LD_INT 1
38976: NEG
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: LD_INT 0
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 1
38994: PUSH
38995: LD_INT 1
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 0
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 1
39014: NEG
39015: PUSH
39016: LD_INT 0
39018: PUSH
39019: EMPTY
39020: LIST
39021: LIST
39022: PUSH
39023: LD_INT 1
39025: NEG
39026: PUSH
39027: LD_INT 1
39029: NEG
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: NEG
39038: PUSH
39039: LD_INT 2
39041: NEG
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: LD_INT 0
39049: PUSH
39050: LD_INT 2
39052: NEG
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: LD_INT 1
39060: PUSH
39061: LD_INT 1
39063: NEG
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: LD_INT 2
39071: PUSH
39072: LD_INT 0
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 2
39081: PUSH
39082: LD_INT 1
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: LIST
39097: LIST
39098: LIST
39099: LIST
39100: LIST
39101: LIST
39102: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39103: LD_ADDR_VAR 0 49
39107: PUSH
39108: LD_INT 0
39110: PUSH
39111: LD_INT 0
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 0
39120: PUSH
39121: LD_INT 1
39123: NEG
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 1
39131: PUSH
39132: LD_INT 0
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 1
39141: PUSH
39142: LD_INT 1
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 0
39151: PUSH
39152: LD_INT 1
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 1
39161: NEG
39162: PUSH
39163: LD_INT 0
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 1
39172: NEG
39173: PUSH
39174: LD_INT 1
39176: NEG
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: PUSH
39182: LD_INT 1
39184: PUSH
39185: LD_INT 1
39187: NEG
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 2
39195: PUSH
39196: LD_INT 0
39198: PUSH
39199: EMPTY
39200: LIST
39201: LIST
39202: PUSH
39203: LD_INT 2
39205: PUSH
39206: LD_INT 1
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: LD_INT 2
39215: PUSH
39216: LD_INT 2
39218: PUSH
39219: EMPTY
39220: LIST
39221: LIST
39222: PUSH
39223: LD_INT 1
39225: PUSH
39226: LD_INT 2
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39247: LD_ADDR_VAR 0 50
39251: PUSH
39252: LD_INT 0
39254: PUSH
39255: LD_INT 0
39257: PUSH
39258: EMPTY
39259: LIST
39260: LIST
39261: PUSH
39262: LD_INT 0
39264: PUSH
39265: LD_INT 1
39267: NEG
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: PUSH
39273: LD_INT 1
39275: PUSH
39276: LD_INT 0
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: PUSH
39283: LD_INT 1
39285: PUSH
39286: LD_INT 1
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 0
39295: PUSH
39296: LD_INT 1
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 1
39305: NEG
39306: PUSH
39307: LD_INT 0
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 1
39316: NEG
39317: PUSH
39318: LD_INT 1
39320: NEG
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: PUSH
39326: LD_INT 2
39328: PUSH
39329: LD_INT 1
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: LD_INT 2
39338: PUSH
39339: LD_INT 2
39341: PUSH
39342: EMPTY
39343: LIST
39344: LIST
39345: PUSH
39346: LD_INT 1
39348: PUSH
39349: LD_INT 2
39351: PUSH
39352: EMPTY
39353: LIST
39354: LIST
39355: PUSH
39356: LD_INT 0
39358: PUSH
39359: LD_INT 2
39361: PUSH
39362: EMPTY
39363: LIST
39364: LIST
39365: PUSH
39366: LD_INT 1
39368: NEG
39369: PUSH
39370: LD_INT 1
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: LIST
39388: LIST
39389: LIST
39390: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39391: LD_ADDR_VAR 0 51
39395: PUSH
39396: LD_INT 0
39398: PUSH
39399: LD_INT 0
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 0
39408: PUSH
39409: LD_INT 1
39411: NEG
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 1
39419: PUSH
39420: LD_INT 0
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: LD_INT 1
39429: PUSH
39430: LD_INT 1
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 0
39439: PUSH
39440: LD_INT 1
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 1
39449: NEG
39450: PUSH
39451: LD_INT 0
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 1
39460: NEG
39461: PUSH
39462: LD_INT 1
39464: NEG
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 1
39472: PUSH
39473: LD_INT 2
39475: PUSH
39476: EMPTY
39477: LIST
39478: LIST
39479: PUSH
39480: LD_INT 0
39482: PUSH
39483: LD_INT 2
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 1
39492: NEG
39493: PUSH
39494: LD_INT 1
39496: PUSH
39497: EMPTY
39498: LIST
39499: LIST
39500: PUSH
39501: LD_INT 2
39503: NEG
39504: PUSH
39505: LD_INT 0
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 2
39514: NEG
39515: PUSH
39516: LD_INT 1
39518: NEG
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: EMPTY
39525: LIST
39526: LIST
39527: LIST
39528: LIST
39529: LIST
39530: LIST
39531: LIST
39532: LIST
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39538: LD_ADDR_VAR 0 52
39542: PUSH
39543: LD_INT 0
39545: PUSH
39546: LD_INT 0
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 0
39555: PUSH
39556: LD_INT 1
39558: NEG
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 1
39566: PUSH
39567: LD_INT 0
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 1
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 0
39586: PUSH
39587: LD_INT 1
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 1
39596: NEG
39597: PUSH
39598: LD_INT 0
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 1
39607: NEG
39608: PUSH
39609: LD_INT 1
39611: NEG
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 1
39619: NEG
39620: PUSH
39621: LD_INT 2
39623: NEG
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PUSH
39629: LD_INT 1
39631: NEG
39632: PUSH
39633: LD_INT 1
39635: PUSH
39636: EMPTY
39637: LIST
39638: LIST
39639: PUSH
39640: LD_INT 2
39642: NEG
39643: PUSH
39644: LD_INT 0
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: LD_INT 2
39653: NEG
39654: PUSH
39655: LD_INT 1
39657: NEG
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 2
39665: NEG
39666: PUSH
39667: LD_INT 2
39669: NEG
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: LIST
39679: LIST
39680: LIST
39681: LIST
39682: LIST
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39689: LD_ADDR_VAR 0 53
39693: PUSH
39694: LD_INT 0
39696: PUSH
39697: LD_INT 0
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: PUSH
39704: LD_INT 0
39706: PUSH
39707: LD_INT 1
39709: NEG
39710: PUSH
39711: EMPTY
39712: LIST
39713: LIST
39714: PUSH
39715: LD_INT 1
39717: PUSH
39718: LD_INT 0
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 1
39727: PUSH
39728: LD_INT 1
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 0
39737: PUSH
39738: LD_INT 1
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: LD_INT 1
39747: NEG
39748: PUSH
39749: LD_INT 0
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 1
39758: NEG
39759: PUSH
39760: LD_INT 1
39762: NEG
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 1
39770: NEG
39771: PUSH
39772: LD_INT 2
39774: NEG
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 0
39782: PUSH
39783: LD_INT 2
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 1
39793: PUSH
39794: LD_INT 1
39796: NEG
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 2
39804: PUSH
39805: LD_INT 0
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 2
39814: PUSH
39815: LD_INT 1
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 2
39824: PUSH
39825: LD_INT 2
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 1
39834: PUSH
39835: LD_INT 2
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 0
39844: PUSH
39845: LD_INT 2
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 1
39854: NEG
39855: PUSH
39856: LD_INT 1
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 2
39865: NEG
39866: PUSH
39867: LD_INT 0
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 2
39876: NEG
39877: PUSH
39878: LD_INT 1
39880: NEG
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 2
39888: NEG
39889: PUSH
39890: LD_INT 2
39892: NEG
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PUSH
39898: EMPTY
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39919: LD_ADDR_VAR 0 54
39923: PUSH
39924: LD_INT 0
39926: PUSH
39927: LD_INT 0
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: LD_INT 0
39936: PUSH
39937: LD_INT 1
39939: NEG
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: PUSH
39945: LD_INT 1
39947: PUSH
39948: LD_INT 0
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 1
39957: PUSH
39958: LD_INT 1
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 0
39967: PUSH
39968: LD_INT 1
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: LD_INT 1
39977: NEG
39978: PUSH
39979: LD_INT 0
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 1
39988: NEG
39989: PUSH
39990: LD_INT 1
39992: NEG
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 1
40000: NEG
40001: PUSH
40002: LD_INT 2
40004: NEG
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: LD_INT 0
40012: PUSH
40013: LD_INT 2
40015: NEG
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 1
40023: PUSH
40024: LD_INT 1
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 2
40034: PUSH
40035: LD_INT 0
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 2
40044: PUSH
40045: LD_INT 1
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 2
40054: PUSH
40055: LD_INT 2
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 1
40064: PUSH
40065: LD_INT 2
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 0
40074: PUSH
40075: LD_INT 2
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 1
40084: NEG
40085: PUSH
40086: LD_INT 1
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 2
40095: NEG
40096: PUSH
40097: LD_INT 0
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 2
40106: NEG
40107: PUSH
40108: LD_INT 1
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 2
40118: NEG
40119: PUSH
40120: LD_INT 2
40122: NEG
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: LIST
40132: LIST
40133: LIST
40134: LIST
40135: LIST
40136: LIST
40137: LIST
40138: LIST
40139: LIST
40140: LIST
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: LIST
40148: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40149: LD_ADDR_VAR 0 55
40153: PUSH
40154: LD_INT 0
40156: PUSH
40157: LD_INT 0
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 0
40166: PUSH
40167: LD_INT 1
40169: NEG
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: PUSH
40175: LD_INT 1
40177: PUSH
40178: LD_INT 0
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 1
40187: PUSH
40188: LD_INT 1
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 0
40197: PUSH
40198: LD_INT 1
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 1
40207: NEG
40208: PUSH
40209: LD_INT 0
40211: PUSH
40212: EMPTY
40213: LIST
40214: LIST
40215: PUSH
40216: LD_INT 1
40218: NEG
40219: PUSH
40220: LD_INT 1
40222: NEG
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: PUSH
40228: LD_INT 1
40230: NEG
40231: PUSH
40232: LD_INT 2
40234: NEG
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: LD_INT 0
40242: PUSH
40243: LD_INT 2
40245: NEG
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 1
40253: PUSH
40254: LD_INT 1
40256: NEG
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PUSH
40262: LD_INT 2
40264: PUSH
40265: LD_INT 0
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: LD_INT 2
40274: PUSH
40275: LD_INT 1
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: PUSH
40282: LD_INT 2
40284: PUSH
40285: LD_INT 2
40287: PUSH
40288: EMPTY
40289: LIST
40290: LIST
40291: PUSH
40292: LD_INT 1
40294: PUSH
40295: LD_INT 2
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 0
40304: PUSH
40305: LD_INT 2
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 1
40314: NEG
40315: PUSH
40316: LD_INT 1
40318: PUSH
40319: EMPTY
40320: LIST
40321: LIST
40322: PUSH
40323: LD_INT 2
40325: NEG
40326: PUSH
40327: LD_INT 0
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: PUSH
40334: LD_INT 2
40336: NEG
40337: PUSH
40338: LD_INT 1
40340: NEG
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 2
40348: NEG
40349: PUSH
40350: LD_INT 2
40352: NEG
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: LIST
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: LIST
40367: LIST
40368: LIST
40369: LIST
40370: LIST
40371: LIST
40372: LIST
40373: LIST
40374: LIST
40375: LIST
40376: LIST
40377: LIST
40378: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40379: LD_ADDR_VAR 0 56
40383: PUSH
40384: LD_INT 0
40386: PUSH
40387: LD_INT 0
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: LD_INT 0
40396: PUSH
40397: LD_INT 1
40399: NEG
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 1
40407: PUSH
40408: LD_INT 0
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: PUSH
40415: LD_INT 1
40417: PUSH
40418: LD_INT 1
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 0
40427: PUSH
40428: LD_INT 1
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 1
40437: NEG
40438: PUSH
40439: LD_INT 0
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: LD_INT 1
40448: NEG
40449: PUSH
40450: LD_INT 1
40452: NEG
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: LD_INT 1
40460: NEG
40461: PUSH
40462: LD_INT 2
40464: NEG
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: LD_INT 0
40472: PUSH
40473: LD_INT 2
40475: NEG
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 1
40483: PUSH
40484: LD_INT 1
40486: NEG
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 2
40494: PUSH
40495: LD_INT 0
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 2
40504: PUSH
40505: LD_INT 1
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 2
40514: PUSH
40515: LD_INT 2
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: LD_INT 1
40524: PUSH
40525: LD_INT 2
40527: PUSH
40528: EMPTY
40529: LIST
40530: LIST
40531: PUSH
40532: LD_INT 0
40534: PUSH
40535: LD_INT 2
40537: PUSH
40538: EMPTY
40539: LIST
40540: LIST
40541: PUSH
40542: LD_INT 1
40544: NEG
40545: PUSH
40546: LD_INT 1
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: PUSH
40553: LD_INT 2
40555: NEG
40556: PUSH
40557: LD_INT 0
40559: PUSH
40560: EMPTY
40561: LIST
40562: LIST
40563: PUSH
40564: LD_INT 2
40566: NEG
40567: PUSH
40568: LD_INT 1
40570: NEG
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: LD_INT 2
40578: NEG
40579: PUSH
40580: LD_INT 2
40582: NEG
40583: PUSH
40584: EMPTY
40585: LIST
40586: LIST
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: LIST
40592: LIST
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: LIST
40601: LIST
40602: LIST
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40609: LD_ADDR_VAR 0 57
40613: PUSH
40614: LD_INT 0
40616: PUSH
40617: LD_INT 0
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 0
40626: PUSH
40627: LD_INT 1
40629: NEG
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 1
40637: PUSH
40638: LD_INT 0
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 1
40647: PUSH
40648: LD_INT 1
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 0
40657: PUSH
40658: LD_INT 1
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 1
40667: NEG
40668: PUSH
40669: LD_INT 0
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: PUSH
40676: LD_INT 1
40678: NEG
40679: PUSH
40680: LD_INT 1
40682: NEG
40683: PUSH
40684: EMPTY
40685: LIST
40686: LIST
40687: PUSH
40688: LD_INT 1
40690: NEG
40691: PUSH
40692: LD_INT 2
40694: NEG
40695: PUSH
40696: EMPTY
40697: LIST
40698: LIST
40699: PUSH
40700: LD_INT 0
40702: PUSH
40703: LD_INT 2
40705: NEG
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PUSH
40711: LD_INT 1
40713: PUSH
40714: LD_INT 1
40716: NEG
40717: PUSH
40718: EMPTY
40719: LIST
40720: LIST
40721: PUSH
40722: LD_INT 2
40724: PUSH
40725: LD_INT 0
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 2
40734: PUSH
40735: LD_INT 1
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: PUSH
40742: LD_INT 2
40744: PUSH
40745: LD_INT 2
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 1
40754: PUSH
40755: LD_INT 2
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PUSH
40762: LD_INT 0
40764: PUSH
40765: LD_INT 2
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 1
40774: NEG
40775: PUSH
40776: LD_INT 1
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: PUSH
40783: LD_INT 2
40785: NEG
40786: PUSH
40787: LD_INT 0
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 2
40796: NEG
40797: PUSH
40798: LD_INT 1
40800: NEG
40801: PUSH
40802: EMPTY
40803: LIST
40804: LIST
40805: PUSH
40806: LD_INT 2
40808: NEG
40809: PUSH
40810: LD_INT 2
40812: NEG
40813: PUSH
40814: EMPTY
40815: LIST
40816: LIST
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: LIST
40822: LIST
40823: LIST
40824: LIST
40825: LIST
40826: LIST
40827: LIST
40828: LIST
40829: LIST
40830: LIST
40831: LIST
40832: LIST
40833: LIST
40834: LIST
40835: LIST
40836: LIST
40837: LIST
40838: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40839: LD_ADDR_VAR 0 58
40843: PUSH
40844: LD_INT 0
40846: PUSH
40847: LD_INT 0
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 0
40856: PUSH
40857: LD_INT 1
40859: NEG
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: LD_INT 1
40867: PUSH
40868: LD_INT 0
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: PUSH
40875: LD_INT 1
40877: PUSH
40878: LD_INT 1
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 0
40887: PUSH
40888: LD_INT 1
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: LD_INT 1
40897: NEG
40898: PUSH
40899: LD_INT 0
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PUSH
40906: LD_INT 1
40908: NEG
40909: PUSH
40910: LD_INT 1
40912: NEG
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 1
40920: NEG
40921: PUSH
40922: LD_INT 2
40924: NEG
40925: PUSH
40926: EMPTY
40927: LIST
40928: LIST
40929: PUSH
40930: LD_INT 0
40932: PUSH
40933: LD_INT 2
40935: NEG
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PUSH
40941: LD_INT 1
40943: PUSH
40944: LD_INT 1
40946: NEG
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: PUSH
40952: LD_INT 2
40954: PUSH
40955: LD_INT 0
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PUSH
40962: LD_INT 2
40964: PUSH
40965: LD_INT 1
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 2
40974: PUSH
40975: LD_INT 2
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: LD_INT 1
40984: PUSH
40985: LD_INT 2
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: LD_INT 0
40994: PUSH
40995: LD_INT 2
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 1
41004: NEG
41005: PUSH
41006: LD_INT 1
41008: PUSH
41009: EMPTY
41010: LIST
41011: LIST
41012: PUSH
41013: LD_INT 2
41015: NEG
41016: PUSH
41017: LD_INT 0
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PUSH
41024: LD_INT 2
41026: NEG
41027: PUSH
41028: LD_INT 1
41030: NEG
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 2
41038: NEG
41039: PUSH
41040: LD_INT 2
41042: NEG
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: LIST
41052: LIST
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: LIST
41059: LIST
41060: LIST
41061: LIST
41062: LIST
41063: LIST
41064: LIST
41065: LIST
41066: LIST
41067: LIST
41068: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41069: LD_ADDR_VAR 0 59
41073: PUSH
41074: LD_INT 0
41076: PUSH
41077: LD_INT 0
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: PUSH
41084: LD_INT 0
41086: PUSH
41087: LD_INT 1
41089: NEG
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: LD_INT 1
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 1
41107: PUSH
41108: LD_INT 1
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: LD_INT 0
41117: PUSH
41118: LD_INT 1
41120: PUSH
41121: EMPTY
41122: LIST
41123: LIST
41124: PUSH
41125: LD_INT 1
41127: NEG
41128: PUSH
41129: LD_INT 0
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: LD_INT 1
41138: NEG
41139: PUSH
41140: LD_INT 1
41142: NEG
41143: PUSH
41144: EMPTY
41145: LIST
41146: LIST
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: LIST
41152: LIST
41153: LIST
41154: LIST
41155: LIST
41156: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41157: LD_ADDR_VAR 0 60
41161: PUSH
41162: LD_INT 0
41164: PUSH
41165: LD_INT 0
41167: PUSH
41168: EMPTY
41169: LIST
41170: LIST
41171: PUSH
41172: LD_INT 0
41174: PUSH
41175: LD_INT 1
41177: NEG
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: LD_INT 1
41185: PUSH
41186: LD_INT 0
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: PUSH
41193: LD_INT 1
41195: PUSH
41196: LD_INT 1
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: PUSH
41203: LD_INT 0
41205: PUSH
41206: LD_INT 1
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: LD_INT 1
41215: NEG
41216: PUSH
41217: LD_INT 0
41219: PUSH
41220: EMPTY
41221: LIST
41222: LIST
41223: PUSH
41224: LD_INT 1
41226: NEG
41227: PUSH
41228: LD_INT 1
41230: NEG
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41245: LD_ADDR_VAR 0 61
41249: PUSH
41250: LD_INT 0
41252: PUSH
41253: LD_INT 0
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PUSH
41260: LD_INT 0
41262: PUSH
41263: LD_INT 1
41265: NEG
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 1
41273: PUSH
41274: LD_INT 0
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 1
41283: PUSH
41284: LD_INT 1
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 0
41293: PUSH
41294: LD_INT 1
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 1
41303: NEG
41304: PUSH
41305: LD_INT 0
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: PUSH
41312: LD_INT 1
41314: NEG
41315: PUSH
41316: LD_INT 1
41318: NEG
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: LIST
41328: LIST
41329: LIST
41330: LIST
41331: LIST
41332: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41333: LD_ADDR_VAR 0 62
41337: PUSH
41338: LD_INT 0
41340: PUSH
41341: LD_INT 0
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 0
41350: PUSH
41351: LD_INT 1
41353: NEG
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 1
41361: PUSH
41362: LD_INT 0
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 1
41371: PUSH
41372: LD_INT 1
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 0
41381: PUSH
41382: LD_INT 1
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 1
41391: NEG
41392: PUSH
41393: LD_INT 0
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: PUSH
41400: LD_INT 1
41402: NEG
41403: PUSH
41404: LD_INT 1
41406: NEG
41407: PUSH
41408: EMPTY
41409: LIST
41410: LIST
41411: PUSH
41412: EMPTY
41413: LIST
41414: LIST
41415: LIST
41416: LIST
41417: LIST
41418: LIST
41419: LIST
41420: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41421: LD_ADDR_VAR 0 63
41425: PUSH
41426: LD_INT 0
41428: PUSH
41429: LD_INT 0
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 0
41438: PUSH
41439: LD_INT 1
41441: NEG
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: PUSH
41447: LD_INT 1
41449: PUSH
41450: LD_INT 0
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: PUSH
41457: LD_INT 1
41459: PUSH
41460: LD_INT 1
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 0
41469: PUSH
41470: LD_INT 1
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: PUSH
41477: LD_INT 1
41479: NEG
41480: PUSH
41481: LD_INT 0
41483: PUSH
41484: EMPTY
41485: LIST
41486: LIST
41487: PUSH
41488: LD_INT 1
41490: NEG
41491: PUSH
41492: LD_INT 1
41494: NEG
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: LIST
41504: LIST
41505: LIST
41506: LIST
41507: LIST
41508: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41509: LD_ADDR_VAR 0 64
41513: PUSH
41514: LD_INT 0
41516: PUSH
41517: LD_INT 0
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 0
41526: PUSH
41527: LD_INT 1
41529: NEG
41530: PUSH
41531: EMPTY
41532: LIST
41533: LIST
41534: PUSH
41535: LD_INT 1
41537: PUSH
41538: LD_INT 0
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: PUSH
41545: LD_INT 1
41547: PUSH
41548: LD_INT 1
41550: PUSH
41551: EMPTY
41552: LIST
41553: LIST
41554: PUSH
41555: LD_INT 0
41557: PUSH
41558: LD_INT 1
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: PUSH
41565: LD_INT 1
41567: NEG
41568: PUSH
41569: LD_INT 0
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 1
41578: NEG
41579: PUSH
41580: LD_INT 1
41582: NEG
41583: PUSH
41584: EMPTY
41585: LIST
41586: LIST
41587: PUSH
41588: EMPTY
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: ST_TO_ADDR
// end ; 1 :
41597: GO 47494
41599: LD_INT 1
41601: DOUBLE
41602: EQUAL
41603: IFTRUE 41607
41605: GO 44230
41607: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41608: LD_ADDR_VAR 0 11
41612: PUSH
41613: LD_INT 1
41615: NEG
41616: PUSH
41617: LD_INT 3
41619: NEG
41620: PUSH
41621: EMPTY
41622: LIST
41623: LIST
41624: PUSH
41625: LD_INT 0
41627: PUSH
41628: LD_INT 3
41630: NEG
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 1
41638: PUSH
41639: LD_INT 2
41641: NEG
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: LIST
41651: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41652: LD_ADDR_VAR 0 12
41656: PUSH
41657: LD_INT 2
41659: PUSH
41660: LD_INT 1
41662: NEG
41663: PUSH
41664: EMPTY
41665: LIST
41666: LIST
41667: PUSH
41668: LD_INT 3
41670: PUSH
41671: LD_INT 0
41673: PUSH
41674: EMPTY
41675: LIST
41676: LIST
41677: PUSH
41678: LD_INT 3
41680: PUSH
41681: LD_INT 1
41683: PUSH
41684: EMPTY
41685: LIST
41686: LIST
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: LIST
41692: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41693: LD_ADDR_VAR 0 13
41697: PUSH
41698: LD_INT 3
41700: PUSH
41701: LD_INT 2
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: PUSH
41708: LD_INT 3
41710: PUSH
41711: LD_INT 3
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: LD_INT 2
41720: PUSH
41721: LD_INT 3
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: LIST
41732: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41733: LD_ADDR_VAR 0 14
41737: PUSH
41738: LD_INT 1
41740: PUSH
41741: LD_INT 3
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: LD_INT 0
41750: PUSH
41751: LD_INT 3
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 1
41760: NEG
41761: PUSH
41762: LD_INT 2
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: LIST
41773: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41774: LD_ADDR_VAR 0 15
41778: PUSH
41779: LD_INT 2
41781: NEG
41782: PUSH
41783: LD_INT 1
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: PUSH
41790: LD_INT 3
41792: NEG
41793: PUSH
41794: LD_INT 0
41796: PUSH
41797: EMPTY
41798: LIST
41799: LIST
41800: PUSH
41801: LD_INT 3
41803: NEG
41804: PUSH
41805: LD_INT 1
41807: NEG
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: LIST
41817: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41818: LD_ADDR_VAR 0 16
41822: PUSH
41823: LD_INT 2
41825: NEG
41826: PUSH
41827: LD_INT 3
41829: NEG
41830: PUSH
41831: EMPTY
41832: LIST
41833: LIST
41834: PUSH
41835: LD_INT 3
41837: NEG
41838: PUSH
41839: LD_INT 2
41841: NEG
41842: PUSH
41843: EMPTY
41844: LIST
41845: LIST
41846: PUSH
41847: LD_INT 3
41849: NEG
41850: PUSH
41851: LD_INT 3
41853: NEG
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: LIST
41863: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41864: LD_ADDR_VAR 0 17
41868: PUSH
41869: LD_INT 1
41871: NEG
41872: PUSH
41873: LD_INT 3
41875: NEG
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: PUSH
41881: LD_INT 0
41883: PUSH
41884: LD_INT 3
41886: NEG
41887: PUSH
41888: EMPTY
41889: LIST
41890: LIST
41891: PUSH
41892: LD_INT 1
41894: PUSH
41895: LD_INT 2
41897: NEG
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: LIST
41907: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41908: LD_ADDR_VAR 0 18
41912: PUSH
41913: LD_INT 2
41915: PUSH
41916: LD_INT 1
41918: NEG
41919: PUSH
41920: EMPTY
41921: LIST
41922: LIST
41923: PUSH
41924: LD_INT 3
41926: PUSH
41927: LD_INT 0
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PUSH
41934: LD_INT 3
41936: PUSH
41937: LD_INT 1
41939: PUSH
41940: EMPTY
41941: LIST
41942: LIST
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: LIST
41948: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41949: LD_ADDR_VAR 0 19
41953: PUSH
41954: LD_INT 3
41956: PUSH
41957: LD_INT 2
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 3
41966: PUSH
41967: LD_INT 3
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 2
41976: PUSH
41977: LD_INT 3
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: LIST
41988: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41989: LD_ADDR_VAR 0 20
41993: PUSH
41994: LD_INT 1
41996: PUSH
41997: LD_INT 3
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: LD_INT 0
42006: PUSH
42007: LD_INT 3
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: PUSH
42014: LD_INT 1
42016: NEG
42017: PUSH
42018: LD_INT 2
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: LIST
42029: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42030: LD_ADDR_VAR 0 21
42034: PUSH
42035: LD_INT 2
42037: NEG
42038: PUSH
42039: LD_INT 1
42041: PUSH
42042: EMPTY
42043: LIST
42044: LIST
42045: PUSH
42046: LD_INT 3
42048: NEG
42049: PUSH
42050: LD_INT 0
42052: PUSH
42053: EMPTY
42054: LIST
42055: LIST
42056: PUSH
42057: LD_INT 3
42059: NEG
42060: PUSH
42061: LD_INT 1
42063: NEG
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: LIST
42073: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42074: LD_ADDR_VAR 0 22
42078: PUSH
42079: LD_INT 2
42081: NEG
42082: PUSH
42083: LD_INT 3
42085: NEG
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 3
42093: NEG
42094: PUSH
42095: LD_INT 2
42097: NEG
42098: PUSH
42099: EMPTY
42100: LIST
42101: LIST
42102: PUSH
42103: LD_INT 3
42105: NEG
42106: PUSH
42107: LD_INT 3
42109: NEG
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: LIST
42119: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
42120: LD_ADDR_VAR 0 23
42124: PUSH
42125: LD_INT 0
42127: PUSH
42128: LD_INT 3
42130: NEG
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: LD_INT 1
42138: NEG
42139: PUSH
42140: LD_INT 4
42142: NEG
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 1
42150: PUSH
42151: LD_INT 3
42153: NEG
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: LIST
42163: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
42164: LD_ADDR_VAR 0 24
42168: PUSH
42169: LD_INT 3
42171: PUSH
42172: LD_INT 0
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 3
42181: PUSH
42182: LD_INT 1
42184: NEG
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 4
42192: PUSH
42193: LD_INT 1
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: EMPTY
42201: LIST
42202: LIST
42203: LIST
42204: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
42205: LD_ADDR_VAR 0 25
42209: PUSH
42210: LD_INT 3
42212: PUSH
42213: LD_INT 3
42215: PUSH
42216: EMPTY
42217: LIST
42218: LIST
42219: PUSH
42220: LD_INT 4
42222: PUSH
42223: LD_INT 3
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: LD_INT 3
42232: PUSH
42233: LD_INT 4
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: LIST
42244: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
42245: LD_ADDR_VAR 0 26
42249: PUSH
42250: LD_INT 0
42252: PUSH
42253: LD_INT 3
42255: PUSH
42256: EMPTY
42257: LIST
42258: LIST
42259: PUSH
42260: LD_INT 1
42262: PUSH
42263: LD_INT 4
42265: PUSH
42266: EMPTY
42267: LIST
42268: LIST
42269: PUSH
42270: LD_INT 1
42272: NEG
42273: PUSH
42274: LD_INT 3
42276: PUSH
42277: EMPTY
42278: LIST
42279: LIST
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: LIST
42285: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
42286: LD_ADDR_VAR 0 27
42290: PUSH
42291: LD_INT 3
42293: NEG
42294: PUSH
42295: LD_INT 0
42297: PUSH
42298: EMPTY
42299: LIST
42300: LIST
42301: PUSH
42302: LD_INT 3
42304: NEG
42305: PUSH
42306: LD_INT 1
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: PUSH
42313: LD_INT 4
42315: NEG
42316: PUSH
42317: LD_INT 1
42319: NEG
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: LIST
42329: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
42330: LD_ADDR_VAR 0 28
42334: PUSH
42335: LD_INT 3
42337: NEG
42338: PUSH
42339: LD_INT 3
42341: NEG
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 3
42349: NEG
42350: PUSH
42351: LD_INT 4
42353: NEG
42354: PUSH
42355: EMPTY
42356: LIST
42357: LIST
42358: PUSH
42359: LD_INT 4
42361: NEG
42362: PUSH
42363: LD_INT 3
42365: NEG
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: LIST
42375: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42376: LD_ADDR_VAR 0 29
42380: PUSH
42381: LD_INT 1
42383: NEG
42384: PUSH
42385: LD_INT 3
42387: NEG
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PUSH
42393: LD_INT 0
42395: PUSH
42396: LD_INT 3
42398: NEG
42399: PUSH
42400: EMPTY
42401: LIST
42402: LIST
42403: PUSH
42404: LD_INT 1
42406: PUSH
42407: LD_INT 2
42409: NEG
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: LD_INT 1
42417: NEG
42418: PUSH
42419: LD_INT 4
42421: NEG
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PUSH
42427: LD_INT 0
42429: PUSH
42430: LD_INT 4
42432: NEG
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: PUSH
42438: LD_INT 1
42440: PUSH
42441: LD_INT 3
42443: NEG
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: PUSH
42449: LD_INT 1
42451: NEG
42452: PUSH
42453: LD_INT 5
42455: NEG
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 0
42463: PUSH
42464: LD_INT 5
42466: NEG
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: PUSH
42472: LD_INT 1
42474: PUSH
42475: LD_INT 4
42477: NEG
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 1
42485: NEG
42486: PUSH
42487: LD_INT 6
42489: NEG
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 0
42497: PUSH
42498: LD_INT 6
42500: NEG
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 1
42508: PUSH
42509: LD_INT 5
42511: NEG
42512: PUSH
42513: EMPTY
42514: LIST
42515: LIST
42516: PUSH
42517: EMPTY
42518: LIST
42519: LIST
42520: LIST
42521: LIST
42522: LIST
42523: LIST
42524: LIST
42525: LIST
42526: LIST
42527: LIST
42528: LIST
42529: LIST
42530: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42531: LD_ADDR_VAR 0 30
42535: PUSH
42536: LD_INT 2
42538: PUSH
42539: LD_INT 1
42541: NEG
42542: PUSH
42543: EMPTY
42544: LIST
42545: LIST
42546: PUSH
42547: LD_INT 3
42549: PUSH
42550: LD_INT 0
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: PUSH
42557: LD_INT 3
42559: PUSH
42560: LD_INT 1
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: PUSH
42567: LD_INT 3
42569: PUSH
42570: LD_INT 1
42572: NEG
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 4
42580: PUSH
42581: LD_INT 0
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 4
42590: PUSH
42591: LD_INT 1
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 4
42600: PUSH
42601: LD_INT 1
42603: NEG
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: PUSH
42609: LD_INT 5
42611: PUSH
42612: LD_INT 0
42614: PUSH
42615: EMPTY
42616: LIST
42617: LIST
42618: PUSH
42619: LD_INT 5
42621: PUSH
42622: LD_INT 1
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 5
42631: PUSH
42632: LD_INT 1
42634: NEG
42635: PUSH
42636: EMPTY
42637: LIST
42638: LIST
42639: PUSH
42640: LD_INT 6
42642: PUSH
42643: LD_INT 0
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PUSH
42650: LD_INT 6
42652: PUSH
42653: LD_INT 1
42655: PUSH
42656: EMPTY
42657: LIST
42658: LIST
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: LIST
42664: LIST
42665: LIST
42666: LIST
42667: LIST
42668: LIST
42669: LIST
42670: LIST
42671: LIST
42672: LIST
42673: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42674: LD_ADDR_VAR 0 31
42678: PUSH
42679: LD_INT 3
42681: PUSH
42682: LD_INT 2
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: LD_INT 3
42691: PUSH
42692: LD_INT 3
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: LD_INT 2
42701: PUSH
42702: LD_INT 3
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: LD_INT 4
42711: PUSH
42712: LD_INT 3
42714: PUSH
42715: EMPTY
42716: LIST
42717: LIST
42718: PUSH
42719: LD_INT 4
42721: PUSH
42722: LD_INT 4
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: PUSH
42729: LD_INT 3
42731: PUSH
42732: LD_INT 4
42734: PUSH
42735: EMPTY
42736: LIST
42737: LIST
42738: PUSH
42739: LD_INT 5
42741: PUSH
42742: LD_INT 4
42744: PUSH
42745: EMPTY
42746: LIST
42747: LIST
42748: PUSH
42749: LD_INT 5
42751: PUSH
42752: LD_INT 5
42754: PUSH
42755: EMPTY
42756: LIST
42757: LIST
42758: PUSH
42759: LD_INT 4
42761: PUSH
42762: LD_INT 5
42764: PUSH
42765: EMPTY
42766: LIST
42767: LIST
42768: PUSH
42769: LD_INT 6
42771: PUSH
42772: LD_INT 5
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PUSH
42779: LD_INT 6
42781: PUSH
42782: LD_INT 6
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PUSH
42789: LD_INT 5
42791: PUSH
42792: LD_INT 6
42794: PUSH
42795: EMPTY
42796: LIST
42797: LIST
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: LIST
42803: LIST
42804: LIST
42805: LIST
42806: LIST
42807: LIST
42808: LIST
42809: LIST
42810: LIST
42811: LIST
42812: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42813: LD_ADDR_VAR 0 32
42817: PUSH
42818: LD_INT 1
42820: PUSH
42821: LD_INT 3
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: LD_INT 0
42830: PUSH
42831: LD_INT 3
42833: PUSH
42834: EMPTY
42835: LIST
42836: LIST
42837: PUSH
42838: LD_INT 1
42840: NEG
42841: PUSH
42842: LD_INT 2
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: LD_INT 1
42851: PUSH
42852: LD_INT 4
42854: PUSH
42855: EMPTY
42856: LIST
42857: LIST
42858: PUSH
42859: LD_INT 0
42861: PUSH
42862: LD_INT 4
42864: PUSH
42865: EMPTY
42866: LIST
42867: LIST
42868: PUSH
42869: LD_INT 1
42871: NEG
42872: PUSH
42873: LD_INT 3
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 1
42882: PUSH
42883: LD_INT 5
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 0
42892: PUSH
42893: LD_INT 5
42895: PUSH
42896: EMPTY
42897: LIST
42898: LIST
42899: PUSH
42900: LD_INT 1
42902: NEG
42903: PUSH
42904: LD_INT 4
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: LD_INT 1
42913: PUSH
42914: LD_INT 6
42916: PUSH
42917: EMPTY
42918: LIST
42919: LIST
42920: PUSH
42921: LD_INT 0
42923: PUSH
42924: LD_INT 6
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: PUSH
42931: LD_INT 1
42933: NEG
42934: PUSH
42935: LD_INT 5
42937: PUSH
42938: EMPTY
42939: LIST
42940: LIST
42941: PUSH
42942: EMPTY
42943: LIST
42944: LIST
42945: LIST
42946: LIST
42947: LIST
42948: LIST
42949: LIST
42950: LIST
42951: LIST
42952: LIST
42953: LIST
42954: LIST
42955: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42956: LD_ADDR_VAR 0 33
42960: PUSH
42961: LD_INT 2
42963: NEG
42964: PUSH
42965: LD_INT 1
42967: PUSH
42968: EMPTY
42969: LIST
42970: LIST
42971: PUSH
42972: LD_INT 3
42974: NEG
42975: PUSH
42976: LD_INT 0
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: PUSH
42983: LD_INT 3
42985: NEG
42986: PUSH
42987: LD_INT 1
42989: NEG
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 3
42997: NEG
42998: PUSH
42999: LD_INT 1
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_INT 4
43008: NEG
43009: PUSH
43010: LD_INT 0
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: PUSH
43017: LD_INT 4
43019: NEG
43020: PUSH
43021: LD_INT 1
43023: NEG
43024: PUSH
43025: EMPTY
43026: LIST
43027: LIST
43028: PUSH
43029: LD_INT 4
43031: NEG
43032: PUSH
43033: LD_INT 1
43035: PUSH
43036: EMPTY
43037: LIST
43038: LIST
43039: PUSH
43040: LD_INT 5
43042: NEG
43043: PUSH
43044: LD_INT 0
43046: PUSH
43047: EMPTY
43048: LIST
43049: LIST
43050: PUSH
43051: LD_INT 5
43053: NEG
43054: PUSH
43055: LD_INT 1
43057: NEG
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 5
43065: NEG
43066: PUSH
43067: LD_INT 1
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: PUSH
43074: LD_INT 6
43076: NEG
43077: PUSH
43078: LD_INT 0
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 6
43087: NEG
43088: PUSH
43089: LD_INT 1
43091: NEG
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: LIST
43101: LIST
43102: LIST
43103: LIST
43104: LIST
43105: LIST
43106: LIST
43107: LIST
43108: LIST
43109: LIST
43110: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
43111: LD_ADDR_VAR 0 34
43115: PUSH
43116: LD_INT 2
43118: NEG
43119: PUSH
43120: LD_INT 3
43122: NEG
43123: PUSH
43124: EMPTY
43125: LIST
43126: LIST
43127: PUSH
43128: LD_INT 3
43130: NEG
43131: PUSH
43132: LD_INT 2
43134: NEG
43135: PUSH
43136: EMPTY
43137: LIST
43138: LIST
43139: PUSH
43140: LD_INT 3
43142: NEG
43143: PUSH
43144: LD_INT 3
43146: NEG
43147: PUSH
43148: EMPTY
43149: LIST
43150: LIST
43151: PUSH
43152: LD_INT 3
43154: NEG
43155: PUSH
43156: LD_INT 4
43158: NEG
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 4
43166: NEG
43167: PUSH
43168: LD_INT 3
43170: NEG
43171: PUSH
43172: EMPTY
43173: LIST
43174: LIST
43175: PUSH
43176: LD_INT 4
43178: NEG
43179: PUSH
43180: LD_INT 4
43182: NEG
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: PUSH
43188: LD_INT 4
43190: NEG
43191: PUSH
43192: LD_INT 5
43194: NEG
43195: PUSH
43196: EMPTY
43197: LIST
43198: LIST
43199: PUSH
43200: LD_INT 5
43202: NEG
43203: PUSH
43204: LD_INT 4
43206: NEG
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 5
43214: NEG
43215: PUSH
43216: LD_INT 5
43218: NEG
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: PUSH
43224: LD_INT 5
43226: NEG
43227: PUSH
43228: LD_INT 6
43230: NEG
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 6
43238: NEG
43239: PUSH
43240: LD_INT 5
43242: NEG
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: LD_INT 6
43250: NEG
43251: PUSH
43252: LD_INT 6
43254: NEG
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: EMPTY
43261: LIST
43262: LIST
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: LIST
43270: LIST
43271: LIST
43272: LIST
43273: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
43274: LD_ADDR_VAR 0 41
43278: PUSH
43279: LD_INT 0
43281: PUSH
43282: LD_INT 2
43284: NEG
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 1
43292: NEG
43293: PUSH
43294: LD_INT 3
43296: NEG
43297: PUSH
43298: EMPTY
43299: LIST
43300: LIST
43301: PUSH
43302: LD_INT 1
43304: PUSH
43305: LD_INT 2
43307: NEG
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: LIST
43317: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
43318: LD_ADDR_VAR 0 42
43322: PUSH
43323: LD_INT 2
43325: PUSH
43326: LD_INT 0
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: PUSH
43333: LD_INT 2
43335: PUSH
43336: LD_INT 1
43338: NEG
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: LD_INT 3
43346: PUSH
43347: LD_INT 1
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: EMPTY
43355: LIST
43356: LIST
43357: LIST
43358: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
43359: LD_ADDR_VAR 0 43
43363: PUSH
43364: LD_INT 2
43366: PUSH
43367: LD_INT 2
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PUSH
43374: LD_INT 3
43376: PUSH
43377: LD_INT 2
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 2
43386: PUSH
43387: LD_INT 3
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: LIST
43398: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43399: LD_ADDR_VAR 0 44
43403: PUSH
43404: LD_INT 0
43406: PUSH
43407: LD_INT 2
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: PUSH
43414: LD_INT 1
43416: PUSH
43417: LD_INT 3
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 1
43426: NEG
43427: PUSH
43428: LD_INT 2
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: EMPTY
43436: LIST
43437: LIST
43438: LIST
43439: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43440: LD_ADDR_VAR 0 45
43444: PUSH
43445: LD_INT 2
43447: NEG
43448: PUSH
43449: LD_INT 0
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 2
43458: NEG
43459: PUSH
43460: LD_INT 1
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: LD_INT 3
43469: NEG
43470: PUSH
43471: LD_INT 1
43473: NEG
43474: PUSH
43475: EMPTY
43476: LIST
43477: LIST
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: LIST
43483: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43484: LD_ADDR_VAR 0 46
43488: PUSH
43489: LD_INT 2
43491: NEG
43492: PUSH
43493: LD_INT 2
43495: NEG
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 2
43503: NEG
43504: PUSH
43505: LD_INT 3
43507: NEG
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: PUSH
43513: LD_INT 3
43515: NEG
43516: PUSH
43517: LD_INT 2
43519: NEG
43520: PUSH
43521: EMPTY
43522: LIST
43523: LIST
43524: PUSH
43525: EMPTY
43526: LIST
43527: LIST
43528: LIST
43529: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43530: LD_ADDR_VAR 0 47
43534: PUSH
43535: LD_INT 2
43537: NEG
43538: PUSH
43539: LD_INT 3
43541: NEG
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: LD_INT 1
43549: NEG
43550: PUSH
43551: LD_INT 3
43553: NEG
43554: PUSH
43555: EMPTY
43556: LIST
43557: LIST
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43563: LD_ADDR_VAR 0 48
43567: PUSH
43568: LD_INT 1
43570: PUSH
43571: LD_INT 2
43573: NEG
43574: PUSH
43575: EMPTY
43576: LIST
43577: LIST
43578: PUSH
43579: LD_INT 2
43581: PUSH
43582: LD_INT 1
43584: NEG
43585: PUSH
43586: EMPTY
43587: LIST
43588: LIST
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43594: LD_ADDR_VAR 0 49
43598: PUSH
43599: LD_INT 3
43601: PUSH
43602: LD_INT 1
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: PUSH
43609: LD_INT 3
43611: PUSH
43612: LD_INT 2
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43623: LD_ADDR_VAR 0 50
43627: PUSH
43628: LD_INT 2
43630: PUSH
43631: LD_INT 3
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: LD_INT 1
43640: PUSH
43641: LD_INT 3
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: PUSH
43648: EMPTY
43649: LIST
43650: LIST
43651: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43652: LD_ADDR_VAR 0 51
43656: PUSH
43657: LD_INT 1
43659: NEG
43660: PUSH
43661: LD_INT 2
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: PUSH
43668: LD_INT 2
43670: NEG
43671: PUSH
43672: LD_INT 1
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43683: LD_ADDR_VAR 0 52
43687: PUSH
43688: LD_INT 3
43690: NEG
43691: PUSH
43692: LD_INT 1
43694: NEG
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PUSH
43700: LD_INT 3
43702: NEG
43703: PUSH
43704: LD_INT 2
43706: NEG
43707: PUSH
43708: EMPTY
43709: LIST
43710: LIST
43711: PUSH
43712: EMPTY
43713: LIST
43714: LIST
43715: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43716: LD_ADDR_VAR 0 53
43720: PUSH
43721: LD_INT 1
43723: NEG
43724: PUSH
43725: LD_INT 3
43727: NEG
43728: PUSH
43729: EMPTY
43730: LIST
43731: LIST
43732: PUSH
43733: LD_INT 0
43735: PUSH
43736: LD_INT 3
43738: NEG
43739: PUSH
43740: EMPTY
43741: LIST
43742: LIST
43743: PUSH
43744: LD_INT 1
43746: PUSH
43747: LD_INT 2
43749: NEG
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: LIST
43759: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43760: LD_ADDR_VAR 0 54
43764: PUSH
43765: LD_INT 2
43767: PUSH
43768: LD_INT 1
43770: NEG
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: PUSH
43776: LD_INT 3
43778: PUSH
43779: LD_INT 0
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: LD_INT 3
43788: PUSH
43789: LD_INT 1
43791: PUSH
43792: EMPTY
43793: LIST
43794: LIST
43795: PUSH
43796: EMPTY
43797: LIST
43798: LIST
43799: LIST
43800: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43801: LD_ADDR_VAR 0 55
43805: PUSH
43806: LD_INT 3
43808: PUSH
43809: LD_INT 2
43811: PUSH
43812: EMPTY
43813: LIST
43814: LIST
43815: PUSH
43816: LD_INT 3
43818: PUSH
43819: LD_INT 3
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: LD_INT 2
43828: PUSH
43829: LD_INT 3
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: EMPTY
43837: LIST
43838: LIST
43839: LIST
43840: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43841: LD_ADDR_VAR 0 56
43845: PUSH
43846: LD_INT 1
43848: PUSH
43849: LD_INT 3
43851: PUSH
43852: EMPTY
43853: LIST
43854: LIST
43855: PUSH
43856: LD_INT 0
43858: PUSH
43859: LD_INT 3
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PUSH
43866: LD_INT 1
43868: NEG
43869: PUSH
43870: LD_INT 2
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: EMPTY
43878: LIST
43879: LIST
43880: LIST
43881: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43882: LD_ADDR_VAR 0 57
43886: PUSH
43887: LD_INT 2
43889: NEG
43890: PUSH
43891: LD_INT 1
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 3
43900: NEG
43901: PUSH
43902: LD_INT 0
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: PUSH
43909: LD_INT 3
43911: NEG
43912: PUSH
43913: LD_INT 1
43915: NEG
43916: PUSH
43917: EMPTY
43918: LIST
43919: LIST
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: LIST
43925: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43926: LD_ADDR_VAR 0 58
43930: PUSH
43931: LD_INT 2
43933: NEG
43934: PUSH
43935: LD_INT 3
43937: NEG
43938: PUSH
43939: EMPTY
43940: LIST
43941: LIST
43942: PUSH
43943: LD_INT 3
43945: NEG
43946: PUSH
43947: LD_INT 2
43949: NEG
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 3
43957: NEG
43958: PUSH
43959: LD_INT 3
43961: NEG
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: LIST
43971: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43972: LD_ADDR_VAR 0 59
43976: PUSH
43977: LD_INT 1
43979: NEG
43980: PUSH
43981: LD_INT 2
43983: NEG
43984: PUSH
43985: EMPTY
43986: LIST
43987: LIST
43988: PUSH
43989: LD_INT 0
43991: PUSH
43992: LD_INT 2
43994: NEG
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: LD_INT 1
44002: PUSH
44003: LD_INT 1
44005: NEG
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: LIST
44015: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
44016: LD_ADDR_VAR 0 60
44020: PUSH
44021: LD_INT 1
44023: PUSH
44024: LD_INT 1
44026: NEG
44027: PUSH
44028: EMPTY
44029: LIST
44030: LIST
44031: PUSH
44032: LD_INT 2
44034: PUSH
44035: LD_INT 0
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: PUSH
44042: LD_INT 2
44044: PUSH
44045: LD_INT 1
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: LIST
44056: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44057: LD_ADDR_VAR 0 61
44061: PUSH
44062: LD_INT 2
44064: PUSH
44065: LD_INT 1
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: PUSH
44072: LD_INT 2
44074: PUSH
44075: LD_INT 2
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: PUSH
44082: LD_INT 1
44084: PUSH
44085: LD_INT 2
44087: PUSH
44088: EMPTY
44089: LIST
44090: LIST
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: LIST
44096: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
44097: LD_ADDR_VAR 0 62
44101: PUSH
44102: LD_INT 1
44104: PUSH
44105: LD_INT 2
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 0
44114: PUSH
44115: LD_INT 2
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 1
44124: NEG
44125: PUSH
44126: LD_INT 1
44128: PUSH
44129: EMPTY
44130: LIST
44131: LIST
44132: PUSH
44133: EMPTY
44134: LIST
44135: LIST
44136: LIST
44137: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
44138: LD_ADDR_VAR 0 63
44142: PUSH
44143: LD_INT 1
44145: NEG
44146: PUSH
44147: LD_INT 1
44149: PUSH
44150: EMPTY
44151: LIST
44152: LIST
44153: PUSH
44154: LD_INT 2
44156: NEG
44157: PUSH
44158: LD_INT 0
44160: PUSH
44161: EMPTY
44162: LIST
44163: LIST
44164: PUSH
44165: LD_INT 2
44167: NEG
44168: PUSH
44169: LD_INT 1
44171: NEG
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: LIST
44181: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44182: LD_ADDR_VAR 0 64
44186: PUSH
44187: LD_INT 1
44189: NEG
44190: PUSH
44191: LD_INT 2
44193: NEG
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 2
44201: NEG
44202: PUSH
44203: LD_INT 1
44205: NEG
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 2
44213: NEG
44214: PUSH
44215: LD_INT 2
44217: NEG
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: EMPTY
44224: LIST
44225: LIST
44226: LIST
44227: ST_TO_ADDR
// end ; 2 :
44228: GO 47494
44230: LD_INT 2
44232: DOUBLE
44233: EQUAL
44234: IFTRUE 44238
44236: GO 47493
44238: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
44239: LD_ADDR_VAR 0 29
44243: PUSH
44244: LD_INT 4
44246: PUSH
44247: LD_INT 0
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 4
44256: PUSH
44257: LD_INT 1
44259: NEG
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 5
44267: PUSH
44268: LD_INT 0
44270: PUSH
44271: EMPTY
44272: LIST
44273: LIST
44274: PUSH
44275: LD_INT 5
44277: PUSH
44278: LD_INT 1
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: PUSH
44285: LD_INT 4
44287: PUSH
44288: LD_INT 1
44290: PUSH
44291: EMPTY
44292: LIST
44293: LIST
44294: PUSH
44295: LD_INT 3
44297: PUSH
44298: LD_INT 0
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: PUSH
44305: LD_INT 3
44307: PUSH
44308: LD_INT 1
44310: NEG
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: PUSH
44316: LD_INT 3
44318: PUSH
44319: LD_INT 2
44321: NEG
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: LD_INT 5
44329: PUSH
44330: LD_INT 2
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: PUSH
44337: LD_INT 3
44339: PUSH
44340: LD_INT 3
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: LD_INT 3
44349: PUSH
44350: LD_INT 2
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: PUSH
44357: LD_INT 4
44359: PUSH
44360: LD_INT 3
44362: PUSH
44363: EMPTY
44364: LIST
44365: LIST
44366: PUSH
44367: LD_INT 4
44369: PUSH
44370: LD_INT 4
44372: PUSH
44373: EMPTY
44374: LIST
44375: LIST
44376: PUSH
44377: LD_INT 3
44379: PUSH
44380: LD_INT 4
44382: PUSH
44383: EMPTY
44384: LIST
44385: LIST
44386: PUSH
44387: LD_INT 2
44389: PUSH
44390: LD_INT 3
44392: PUSH
44393: EMPTY
44394: LIST
44395: LIST
44396: PUSH
44397: LD_INT 2
44399: PUSH
44400: LD_INT 2
44402: PUSH
44403: EMPTY
44404: LIST
44405: LIST
44406: PUSH
44407: LD_INT 4
44409: PUSH
44410: LD_INT 2
44412: PUSH
44413: EMPTY
44414: LIST
44415: LIST
44416: PUSH
44417: LD_INT 2
44419: PUSH
44420: LD_INT 4
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: PUSH
44427: LD_INT 0
44429: PUSH
44430: LD_INT 4
44432: PUSH
44433: EMPTY
44434: LIST
44435: LIST
44436: PUSH
44437: LD_INT 0
44439: PUSH
44440: LD_INT 3
44442: PUSH
44443: EMPTY
44444: LIST
44445: LIST
44446: PUSH
44447: LD_INT 1
44449: PUSH
44450: LD_INT 4
44452: PUSH
44453: EMPTY
44454: LIST
44455: LIST
44456: PUSH
44457: LD_INT 1
44459: PUSH
44460: LD_INT 5
44462: PUSH
44463: EMPTY
44464: LIST
44465: LIST
44466: PUSH
44467: LD_INT 0
44469: PUSH
44470: LD_INT 5
44472: PUSH
44473: EMPTY
44474: LIST
44475: LIST
44476: PUSH
44477: LD_INT 1
44479: NEG
44480: PUSH
44481: LD_INT 4
44483: PUSH
44484: EMPTY
44485: LIST
44486: LIST
44487: PUSH
44488: LD_INT 1
44490: NEG
44491: PUSH
44492: LD_INT 3
44494: PUSH
44495: EMPTY
44496: LIST
44497: LIST
44498: PUSH
44499: LD_INT 2
44501: PUSH
44502: LD_INT 5
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: PUSH
44509: LD_INT 2
44511: NEG
44512: PUSH
44513: LD_INT 3
44515: PUSH
44516: EMPTY
44517: LIST
44518: LIST
44519: PUSH
44520: LD_INT 3
44522: NEG
44523: PUSH
44524: LD_INT 0
44526: PUSH
44527: EMPTY
44528: LIST
44529: LIST
44530: PUSH
44531: LD_INT 3
44533: NEG
44534: PUSH
44535: LD_INT 1
44537: NEG
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 2
44545: NEG
44546: PUSH
44547: LD_INT 0
44549: PUSH
44550: EMPTY
44551: LIST
44552: LIST
44553: PUSH
44554: LD_INT 2
44556: NEG
44557: PUSH
44558: LD_INT 1
44560: PUSH
44561: EMPTY
44562: LIST
44563: LIST
44564: PUSH
44565: LD_INT 3
44567: NEG
44568: PUSH
44569: LD_INT 1
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: LD_INT 4
44578: NEG
44579: PUSH
44580: LD_INT 0
44582: PUSH
44583: EMPTY
44584: LIST
44585: LIST
44586: PUSH
44587: LD_INT 4
44589: NEG
44590: PUSH
44591: LD_INT 1
44593: NEG
44594: PUSH
44595: EMPTY
44596: LIST
44597: LIST
44598: PUSH
44599: LD_INT 4
44601: NEG
44602: PUSH
44603: LD_INT 2
44605: NEG
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: PUSH
44611: LD_INT 2
44613: NEG
44614: PUSH
44615: LD_INT 2
44617: PUSH
44618: EMPTY
44619: LIST
44620: LIST
44621: PUSH
44622: LD_INT 4
44624: NEG
44625: PUSH
44626: LD_INT 4
44628: NEG
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 4
44636: NEG
44637: PUSH
44638: LD_INT 5
44640: NEG
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: LD_INT 3
44648: NEG
44649: PUSH
44650: LD_INT 4
44652: NEG
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: PUSH
44658: LD_INT 3
44660: NEG
44661: PUSH
44662: LD_INT 3
44664: NEG
44665: PUSH
44666: EMPTY
44667: LIST
44668: LIST
44669: PUSH
44670: LD_INT 4
44672: NEG
44673: PUSH
44674: LD_INT 3
44676: NEG
44677: PUSH
44678: EMPTY
44679: LIST
44680: LIST
44681: PUSH
44682: LD_INT 5
44684: NEG
44685: PUSH
44686: LD_INT 4
44688: NEG
44689: PUSH
44690: EMPTY
44691: LIST
44692: LIST
44693: PUSH
44694: LD_INT 5
44696: NEG
44697: PUSH
44698: LD_INT 5
44700: NEG
44701: PUSH
44702: EMPTY
44703: LIST
44704: LIST
44705: PUSH
44706: LD_INT 3
44708: NEG
44709: PUSH
44710: LD_INT 5
44712: NEG
44713: PUSH
44714: EMPTY
44715: LIST
44716: LIST
44717: PUSH
44718: LD_INT 5
44720: NEG
44721: PUSH
44722: LD_INT 3
44724: NEG
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: LIST
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: LIST
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: LIST
44756: LIST
44757: LIST
44758: LIST
44759: LIST
44760: LIST
44761: LIST
44762: LIST
44763: LIST
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44777: LD_ADDR_VAR 0 30
44781: PUSH
44782: LD_INT 4
44784: PUSH
44785: LD_INT 4
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 4
44794: PUSH
44795: LD_INT 3
44797: PUSH
44798: EMPTY
44799: LIST
44800: LIST
44801: PUSH
44802: LD_INT 5
44804: PUSH
44805: LD_INT 4
44807: PUSH
44808: EMPTY
44809: LIST
44810: LIST
44811: PUSH
44812: LD_INT 5
44814: PUSH
44815: LD_INT 5
44817: PUSH
44818: EMPTY
44819: LIST
44820: LIST
44821: PUSH
44822: LD_INT 4
44824: PUSH
44825: LD_INT 5
44827: PUSH
44828: EMPTY
44829: LIST
44830: LIST
44831: PUSH
44832: LD_INT 3
44834: PUSH
44835: LD_INT 4
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 3
44844: PUSH
44845: LD_INT 3
44847: PUSH
44848: EMPTY
44849: LIST
44850: LIST
44851: PUSH
44852: LD_INT 5
44854: PUSH
44855: LD_INT 3
44857: PUSH
44858: EMPTY
44859: LIST
44860: LIST
44861: PUSH
44862: LD_INT 3
44864: PUSH
44865: LD_INT 5
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 0
44874: PUSH
44875: LD_INT 3
44877: PUSH
44878: EMPTY
44879: LIST
44880: LIST
44881: PUSH
44882: LD_INT 0
44884: PUSH
44885: LD_INT 2
44887: PUSH
44888: EMPTY
44889: LIST
44890: LIST
44891: PUSH
44892: LD_INT 1
44894: PUSH
44895: LD_INT 3
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: LD_INT 1
44904: PUSH
44905: LD_INT 4
44907: PUSH
44908: EMPTY
44909: LIST
44910: LIST
44911: PUSH
44912: LD_INT 0
44914: PUSH
44915: LD_INT 4
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 1
44924: NEG
44925: PUSH
44926: LD_INT 3
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 1
44935: NEG
44936: PUSH
44937: LD_INT 2
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 2
44946: PUSH
44947: LD_INT 4
44949: PUSH
44950: EMPTY
44951: LIST
44952: LIST
44953: PUSH
44954: LD_INT 2
44956: NEG
44957: PUSH
44958: LD_INT 2
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: LD_INT 4
44967: NEG
44968: PUSH
44969: LD_INT 0
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 4
44978: NEG
44979: PUSH
44980: LD_INT 1
44982: NEG
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: PUSH
44988: LD_INT 3
44990: NEG
44991: PUSH
44992: LD_INT 0
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 3
45001: NEG
45002: PUSH
45003: LD_INT 1
45005: PUSH
45006: EMPTY
45007: LIST
45008: LIST
45009: PUSH
45010: LD_INT 4
45012: NEG
45013: PUSH
45014: LD_INT 1
45016: PUSH
45017: EMPTY
45018: LIST
45019: LIST
45020: PUSH
45021: LD_INT 5
45023: NEG
45024: PUSH
45025: LD_INT 0
45027: PUSH
45028: EMPTY
45029: LIST
45030: LIST
45031: PUSH
45032: LD_INT 5
45034: NEG
45035: PUSH
45036: LD_INT 1
45038: NEG
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 5
45046: NEG
45047: PUSH
45048: LD_INT 2
45050: NEG
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 3
45058: NEG
45059: PUSH
45060: LD_INT 2
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: LD_INT 3
45069: NEG
45070: PUSH
45071: LD_INT 3
45073: NEG
45074: PUSH
45075: EMPTY
45076: LIST
45077: LIST
45078: PUSH
45079: LD_INT 3
45081: NEG
45082: PUSH
45083: LD_INT 4
45085: NEG
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: PUSH
45091: LD_INT 2
45093: NEG
45094: PUSH
45095: LD_INT 3
45097: NEG
45098: PUSH
45099: EMPTY
45100: LIST
45101: LIST
45102: PUSH
45103: LD_INT 2
45105: NEG
45106: PUSH
45107: LD_INT 2
45109: NEG
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: PUSH
45115: LD_INT 3
45117: NEG
45118: PUSH
45119: LD_INT 2
45121: NEG
45122: PUSH
45123: EMPTY
45124: LIST
45125: LIST
45126: PUSH
45127: LD_INT 4
45129: NEG
45130: PUSH
45131: LD_INT 3
45133: NEG
45134: PUSH
45135: EMPTY
45136: LIST
45137: LIST
45138: PUSH
45139: LD_INT 4
45141: NEG
45142: PUSH
45143: LD_INT 4
45145: NEG
45146: PUSH
45147: EMPTY
45148: LIST
45149: LIST
45150: PUSH
45151: LD_INT 2
45153: NEG
45154: PUSH
45155: LD_INT 4
45157: NEG
45158: PUSH
45159: EMPTY
45160: LIST
45161: LIST
45162: PUSH
45163: LD_INT 4
45165: NEG
45166: PUSH
45167: LD_INT 2
45169: NEG
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: PUSH
45175: LD_INT 0
45177: PUSH
45178: LD_INT 4
45180: NEG
45181: PUSH
45182: EMPTY
45183: LIST
45184: LIST
45185: PUSH
45186: LD_INT 0
45188: PUSH
45189: LD_INT 5
45191: NEG
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: LD_INT 1
45199: PUSH
45200: LD_INT 4
45202: NEG
45203: PUSH
45204: EMPTY
45205: LIST
45206: LIST
45207: PUSH
45208: LD_INT 1
45210: PUSH
45211: LD_INT 3
45213: NEG
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 0
45221: PUSH
45222: LD_INT 3
45224: NEG
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: PUSH
45230: LD_INT 1
45232: NEG
45233: PUSH
45234: LD_INT 4
45236: NEG
45237: PUSH
45238: EMPTY
45239: LIST
45240: LIST
45241: PUSH
45242: LD_INT 1
45244: NEG
45245: PUSH
45246: LD_INT 5
45248: NEG
45249: PUSH
45250: EMPTY
45251: LIST
45252: LIST
45253: PUSH
45254: LD_INT 2
45256: PUSH
45257: LD_INT 3
45259: NEG
45260: PUSH
45261: EMPTY
45262: LIST
45263: LIST
45264: PUSH
45265: LD_INT 2
45267: NEG
45268: PUSH
45269: LD_INT 5
45271: NEG
45272: PUSH
45273: EMPTY
45274: LIST
45275: LIST
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: LIST
45281: LIST
45282: LIST
45283: LIST
45284: LIST
45285: LIST
45286: LIST
45287: LIST
45288: LIST
45289: LIST
45290: LIST
45291: LIST
45292: LIST
45293: LIST
45294: LIST
45295: LIST
45296: LIST
45297: LIST
45298: LIST
45299: LIST
45300: LIST
45301: LIST
45302: LIST
45303: LIST
45304: LIST
45305: LIST
45306: LIST
45307: LIST
45308: LIST
45309: LIST
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: LIST
45319: LIST
45320: LIST
45321: LIST
45322: LIST
45323: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
45324: LD_ADDR_VAR 0 31
45328: PUSH
45329: LD_INT 0
45331: PUSH
45332: LD_INT 4
45334: PUSH
45335: EMPTY
45336: LIST
45337: LIST
45338: PUSH
45339: LD_INT 0
45341: PUSH
45342: LD_INT 3
45344: PUSH
45345: EMPTY
45346: LIST
45347: LIST
45348: PUSH
45349: LD_INT 1
45351: PUSH
45352: LD_INT 4
45354: PUSH
45355: EMPTY
45356: LIST
45357: LIST
45358: PUSH
45359: LD_INT 1
45361: PUSH
45362: LD_INT 5
45364: PUSH
45365: EMPTY
45366: LIST
45367: LIST
45368: PUSH
45369: LD_INT 0
45371: PUSH
45372: LD_INT 5
45374: PUSH
45375: EMPTY
45376: LIST
45377: LIST
45378: PUSH
45379: LD_INT 1
45381: NEG
45382: PUSH
45383: LD_INT 4
45385: PUSH
45386: EMPTY
45387: LIST
45388: LIST
45389: PUSH
45390: LD_INT 1
45392: NEG
45393: PUSH
45394: LD_INT 3
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 2
45403: PUSH
45404: LD_INT 5
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: PUSH
45411: LD_INT 2
45413: NEG
45414: PUSH
45415: LD_INT 3
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: PUSH
45422: LD_INT 3
45424: NEG
45425: PUSH
45426: LD_INT 0
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 3
45435: NEG
45436: PUSH
45437: LD_INT 1
45439: NEG
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: LD_INT 2
45447: NEG
45448: PUSH
45449: LD_INT 0
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: LD_INT 2
45458: NEG
45459: PUSH
45460: LD_INT 1
45462: PUSH
45463: EMPTY
45464: LIST
45465: LIST
45466: PUSH
45467: LD_INT 3
45469: NEG
45470: PUSH
45471: LD_INT 1
45473: PUSH
45474: EMPTY
45475: LIST
45476: LIST
45477: PUSH
45478: LD_INT 4
45480: NEG
45481: PUSH
45482: LD_INT 0
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: PUSH
45489: LD_INT 4
45491: NEG
45492: PUSH
45493: LD_INT 1
45495: NEG
45496: PUSH
45497: EMPTY
45498: LIST
45499: LIST
45500: PUSH
45501: LD_INT 4
45503: NEG
45504: PUSH
45505: LD_INT 2
45507: NEG
45508: PUSH
45509: EMPTY
45510: LIST
45511: LIST
45512: PUSH
45513: LD_INT 2
45515: NEG
45516: PUSH
45517: LD_INT 2
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: PUSH
45524: LD_INT 4
45526: NEG
45527: PUSH
45528: LD_INT 4
45530: NEG
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: PUSH
45536: LD_INT 4
45538: NEG
45539: PUSH
45540: LD_INT 5
45542: NEG
45543: PUSH
45544: EMPTY
45545: LIST
45546: LIST
45547: PUSH
45548: LD_INT 3
45550: NEG
45551: PUSH
45552: LD_INT 4
45554: NEG
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: PUSH
45560: LD_INT 3
45562: NEG
45563: PUSH
45564: LD_INT 3
45566: NEG
45567: PUSH
45568: EMPTY
45569: LIST
45570: LIST
45571: PUSH
45572: LD_INT 4
45574: NEG
45575: PUSH
45576: LD_INT 3
45578: NEG
45579: PUSH
45580: EMPTY
45581: LIST
45582: LIST
45583: PUSH
45584: LD_INT 5
45586: NEG
45587: PUSH
45588: LD_INT 4
45590: NEG
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: LD_INT 5
45598: NEG
45599: PUSH
45600: LD_INT 5
45602: NEG
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PUSH
45608: LD_INT 3
45610: NEG
45611: PUSH
45612: LD_INT 5
45614: NEG
45615: PUSH
45616: EMPTY
45617: LIST
45618: LIST
45619: PUSH
45620: LD_INT 5
45622: NEG
45623: PUSH
45624: LD_INT 3
45626: NEG
45627: PUSH
45628: EMPTY
45629: LIST
45630: LIST
45631: PUSH
45632: LD_INT 0
45634: PUSH
45635: LD_INT 3
45637: NEG
45638: PUSH
45639: EMPTY
45640: LIST
45641: LIST
45642: PUSH
45643: LD_INT 0
45645: PUSH
45646: LD_INT 4
45648: NEG
45649: PUSH
45650: EMPTY
45651: LIST
45652: LIST
45653: PUSH
45654: LD_INT 1
45656: PUSH
45657: LD_INT 3
45659: NEG
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: PUSH
45665: LD_INT 1
45667: PUSH
45668: LD_INT 2
45670: NEG
45671: PUSH
45672: EMPTY
45673: LIST
45674: LIST
45675: PUSH
45676: LD_INT 0
45678: PUSH
45679: LD_INT 2
45681: NEG
45682: PUSH
45683: EMPTY
45684: LIST
45685: LIST
45686: PUSH
45687: LD_INT 1
45689: NEG
45690: PUSH
45691: LD_INT 3
45693: NEG
45694: PUSH
45695: EMPTY
45696: LIST
45697: LIST
45698: PUSH
45699: LD_INT 1
45701: NEG
45702: PUSH
45703: LD_INT 4
45705: NEG
45706: PUSH
45707: EMPTY
45708: LIST
45709: LIST
45710: PUSH
45711: LD_INT 2
45713: PUSH
45714: LD_INT 2
45716: NEG
45717: PUSH
45718: EMPTY
45719: LIST
45720: LIST
45721: PUSH
45722: LD_INT 2
45724: NEG
45725: PUSH
45726: LD_INT 4
45728: NEG
45729: PUSH
45730: EMPTY
45731: LIST
45732: LIST
45733: PUSH
45734: LD_INT 4
45736: PUSH
45737: LD_INT 0
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 4
45746: PUSH
45747: LD_INT 1
45749: NEG
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: PUSH
45755: LD_INT 5
45757: PUSH
45758: LD_INT 0
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: PUSH
45765: LD_INT 5
45767: PUSH
45768: LD_INT 1
45770: PUSH
45771: EMPTY
45772: LIST
45773: LIST
45774: PUSH
45775: LD_INT 4
45777: PUSH
45778: LD_INT 1
45780: PUSH
45781: EMPTY
45782: LIST
45783: LIST
45784: PUSH
45785: LD_INT 3
45787: PUSH
45788: LD_INT 0
45790: PUSH
45791: EMPTY
45792: LIST
45793: LIST
45794: PUSH
45795: LD_INT 3
45797: PUSH
45798: LD_INT 1
45800: NEG
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: LD_INT 3
45808: PUSH
45809: LD_INT 2
45811: NEG
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 5
45819: PUSH
45820: LD_INT 2
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: LIST
45840: LIST
45841: LIST
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: LIST
45848: LIST
45849: LIST
45850: LIST
45851: LIST
45852: LIST
45853: LIST
45854: LIST
45855: LIST
45856: LIST
45857: LIST
45858: LIST
45859: LIST
45860: LIST
45861: LIST
45862: LIST
45863: LIST
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: LIST
45869: LIST
45870: LIST
45871: LIST
45872: LIST
45873: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45874: LD_ADDR_VAR 0 32
45878: PUSH
45879: LD_INT 4
45881: NEG
45882: PUSH
45883: LD_INT 0
45885: PUSH
45886: EMPTY
45887: LIST
45888: LIST
45889: PUSH
45890: LD_INT 4
45892: NEG
45893: PUSH
45894: LD_INT 1
45896: NEG
45897: PUSH
45898: EMPTY
45899: LIST
45900: LIST
45901: PUSH
45902: LD_INT 3
45904: NEG
45905: PUSH
45906: LD_INT 0
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 3
45915: NEG
45916: PUSH
45917: LD_INT 1
45919: PUSH
45920: EMPTY
45921: LIST
45922: LIST
45923: PUSH
45924: LD_INT 4
45926: NEG
45927: PUSH
45928: LD_INT 1
45930: PUSH
45931: EMPTY
45932: LIST
45933: LIST
45934: PUSH
45935: LD_INT 5
45937: NEG
45938: PUSH
45939: LD_INT 0
45941: PUSH
45942: EMPTY
45943: LIST
45944: LIST
45945: PUSH
45946: LD_INT 5
45948: NEG
45949: PUSH
45950: LD_INT 1
45952: NEG
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: PUSH
45958: LD_INT 5
45960: NEG
45961: PUSH
45962: LD_INT 2
45964: NEG
45965: PUSH
45966: EMPTY
45967: LIST
45968: LIST
45969: PUSH
45970: LD_INT 3
45972: NEG
45973: PUSH
45974: LD_INT 2
45976: PUSH
45977: EMPTY
45978: LIST
45979: LIST
45980: PUSH
45981: LD_INT 3
45983: NEG
45984: PUSH
45985: LD_INT 3
45987: NEG
45988: PUSH
45989: EMPTY
45990: LIST
45991: LIST
45992: PUSH
45993: LD_INT 3
45995: NEG
45996: PUSH
45997: LD_INT 4
45999: NEG
46000: PUSH
46001: EMPTY
46002: LIST
46003: LIST
46004: PUSH
46005: LD_INT 2
46007: NEG
46008: PUSH
46009: LD_INT 3
46011: NEG
46012: PUSH
46013: EMPTY
46014: LIST
46015: LIST
46016: PUSH
46017: LD_INT 2
46019: NEG
46020: PUSH
46021: LD_INT 2
46023: NEG
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 3
46031: NEG
46032: PUSH
46033: LD_INT 2
46035: NEG
46036: PUSH
46037: EMPTY
46038: LIST
46039: LIST
46040: PUSH
46041: LD_INT 4
46043: NEG
46044: PUSH
46045: LD_INT 3
46047: NEG
46048: PUSH
46049: EMPTY
46050: LIST
46051: LIST
46052: PUSH
46053: LD_INT 4
46055: NEG
46056: PUSH
46057: LD_INT 4
46059: NEG
46060: PUSH
46061: EMPTY
46062: LIST
46063: LIST
46064: PUSH
46065: LD_INT 2
46067: NEG
46068: PUSH
46069: LD_INT 4
46071: NEG
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: PUSH
46077: LD_INT 4
46079: NEG
46080: PUSH
46081: LD_INT 2
46083: NEG
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PUSH
46089: LD_INT 0
46091: PUSH
46092: LD_INT 4
46094: NEG
46095: PUSH
46096: EMPTY
46097: LIST
46098: LIST
46099: PUSH
46100: LD_INT 0
46102: PUSH
46103: LD_INT 5
46105: NEG
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 1
46113: PUSH
46114: LD_INT 4
46116: NEG
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: PUSH
46122: LD_INT 1
46124: PUSH
46125: LD_INT 3
46127: NEG
46128: PUSH
46129: EMPTY
46130: LIST
46131: LIST
46132: PUSH
46133: LD_INT 0
46135: PUSH
46136: LD_INT 3
46138: NEG
46139: PUSH
46140: EMPTY
46141: LIST
46142: LIST
46143: PUSH
46144: LD_INT 1
46146: NEG
46147: PUSH
46148: LD_INT 4
46150: NEG
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PUSH
46156: LD_INT 1
46158: NEG
46159: PUSH
46160: LD_INT 5
46162: NEG
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: PUSH
46168: LD_INT 2
46170: PUSH
46171: LD_INT 3
46173: NEG
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 2
46181: NEG
46182: PUSH
46183: LD_INT 5
46185: NEG
46186: PUSH
46187: EMPTY
46188: LIST
46189: LIST
46190: PUSH
46191: LD_INT 3
46193: PUSH
46194: LD_INT 0
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: PUSH
46201: LD_INT 3
46203: PUSH
46204: LD_INT 1
46206: NEG
46207: PUSH
46208: EMPTY
46209: LIST
46210: LIST
46211: PUSH
46212: LD_INT 4
46214: PUSH
46215: LD_INT 0
46217: PUSH
46218: EMPTY
46219: LIST
46220: LIST
46221: PUSH
46222: LD_INT 4
46224: PUSH
46225: LD_INT 1
46227: PUSH
46228: EMPTY
46229: LIST
46230: LIST
46231: PUSH
46232: LD_INT 3
46234: PUSH
46235: LD_INT 1
46237: PUSH
46238: EMPTY
46239: LIST
46240: LIST
46241: PUSH
46242: LD_INT 2
46244: PUSH
46245: LD_INT 0
46247: PUSH
46248: EMPTY
46249: LIST
46250: LIST
46251: PUSH
46252: LD_INT 2
46254: PUSH
46255: LD_INT 1
46257: NEG
46258: PUSH
46259: EMPTY
46260: LIST
46261: LIST
46262: PUSH
46263: LD_INT 2
46265: PUSH
46266: LD_INT 2
46268: NEG
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: PUSH
46274: LD_INT 4
46276: PUSH
46277: LD_INT 2
46279: PUSH
46280: EMPTY
46281: LIST
46282: LIST
46283: PUSH
46284: LD_INT 4
46286: PUSH
46287: LD_INT 4
46289: PUSH
46290: EMPTY
46291: LIST
46292: LIST
46293: PUSH
46294: LD_INT 4
46296: PUSH
46297: LD_INT 3
46299: PUSH
46300: EMPTY
46301: LIST
46302: LIST
46303: PUSH
46304: LD_INT 5
46306: PUSH
46307: LD_INT 4
46309: PUSH
46310: EMPTY
46311: LIST
46312: LIST
46313: PUSH
46314: LD_INT 5
46316: PUSH
46317: LD_INT 5
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 4
46326: PUSH
46327: LD_INT 5
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: LD_INT 3
46336: PUSH
46337: LD_INT 4
46339: PUSH
46340: EMPTY
46341: LIST
46342: LIST
46343: PUSH
46344: LD_INT 3
46346: PUSH
46347: LD_INT 3
46349: PUSH
46350: EMPTY
46351: LIST
46352: LIST
46353: PUSH
46354: LD_INT 5
46356: PUSH
46357: LD_INT 3
46359: PUSH
46360: EMPTY
46361: LIST
46362: LIST
46363: PUSH
46364: LD_INT 3
46366: PUSH
46367: LD_INT 5
46369: PUSH
46370: EMPTY
46371: LIST
46372: LIST
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: LIST
46412: LIST
46413: LIST
46414: LIST
46415: LIST
46416: LIST
46417: LIST
46418: LIST
46419: LIST
46420: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46421: LD_ADDR_VAR 0 33
46425: PUSH
46426: LD_INT 4
46428: NEG
46429: PUSH
46430: LD_INT 4
46432: NEG
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: LD_INT 4
46440: NEG
46441: PUSH
46442: LD_INT 5
46444: NEG
46445: PUSH
46446: EMPTY
46447: LIST
46448: LIST
46449: PUSH
46450: LD_INT 3
46452: NEG
46453: PUSH
46454: LD_INT 4
46456: NEG
46457: PUSH
46458: EMPTY
46459: LIST
46460: LIST
46461: PUSH
46462: LD_INT 3
46464: NEG
46465: PUSH
46466: LD_INT 3
46468: NEG
46469: PUSH
46470: EMPTY
46471: LIST
46472: LIST
46473: PUSH
46474: LD_INT 4
46476: NEG
46477: PUSH
46478: LD_INT 3
46480: NEG
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: PUSH
46486: LD_INT 5
46488: NEG
46489: PUSH
46490: LD_INT 4
46492: NEG
46493: PUSH
46494: EMPTY
46495: LIST
46496: LIST
46497: PUSH
46498: LD_INT 5
46500: NEG
46501: PUSH
46502: LD_INT 5
46504: NEG
46505: PUSH
46506: EMPTY
46507: LIST
46508: LIST
46509: PUSH
46510: LD_INT 3
46512: NEG
46513: PUSH
46514: LD_INT 5
46516: NEG
46517: PUSH
46518: EMPTY
46519: LIST
46520: LIST
46521: PUSH
46522: LD_INT 5
46524: NEG
46525: PUSH
46526: LD_INT 3
46528: NEG
46529: PUSH
46530: EMPTY
46531: LIST
46532: LIST
46533: PUSH
46534: LD_INT 0
46536: PUSH
46537: LD_INT 3
46539: NEG
46540: PUSH
46541: EMPTY
46542: LIST
46543: LIST
46544: PUSH
46545: LD_INT 0
46547: PUSH
46548: LD_INT 4
46550: NEG
46551: PUSH
46552: EMPTY
46553: LIST
46554: LIST
46555: PUSH
46556: LD_INT 1
46558: PUSH
46559: LD_INT 3
46561: NEG
46562: PUSH
46563: EMPTY
46564: LIST
46565: LIST
46566: PUSH
46567: LD_INT 1
46569: PUSH
46570: LD_INT 2
46572: NEG
46573: PUSH
46574: EMPTY
46575: LIST
46576: LIST
46577: PUSH
46578: LD_INT 0
46580: PUSH
46581: LD_INT 2
46583: NEG
46584: PUSH
46585: EMPTY
46586: LIST
46587: LIST
46588: PUSH
46589: LD_INT 1
46591: NEG
46592: PUSH
46593: LD_INT 3
46595: NEG
46596: PUSH
46597: EMPTY
46598: LIST
46599: LIST
46600: PUSH
46601: LD_INT 1
46603: NEG
46604: PUSH
46605: LD_INT 4
46607: NEG
46608: PUSH
46609: EMPTY
46610: LIST
46611: LIST
46612: PUSH
46613: LD_INT 2
46615: PUSH
46616: LD_INT 2
46618: NEG
46619: PUSH
46620: EMPTY
46621: LIST
46622: LIST
46623: PUSH
46624: LD_INT 2
46626: NEG
46627: PUSH
46628: LD_INT 4
46630: NEG
46631: PUSH
46632: EMPTY
46633: LIST
46634: LIST
46635: PUSH
46636: LD_INT 4
46638: PUSH
46639: LD_INT 0
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: LD_INT 4
46648: PUSH
46649: LD_INT 1
46651: NEG
46652: PUSH
46653: EMPTY
46654: LIST
46655: LIST
46656: PUSH
46657: LD_INT 5
46659: PUSH
46660: LD_INT 0
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: PUSH
46667: LD_INT 5
46669: PUSH
46670: LD_INT 1
46672: PUSH
46673: EMPTY
46674: LIST
46675: LIST
46676: PUSH
46677: LD_INT 4
46679: PUSH
46680: LD_INT 1
46682: PUSH
46683: EMPTY
46684: LIST
46685: LIST
46686: PUSH
46687: LD_INT 3
46689: PUSH
46690: LD_INT 0
46692: PUSH
46693: EMPTY
46694: LIST
46695: LIST
46696: PUSH
46697: LD_INT 3
46699: PUSH
46700: LD_INT 1
46702: NEG
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: LD_INT 3
46710: PUSH
46711: LD_INT 2
46713: NEG
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 5
46721: PUSH
46722: LD_INT 2
46724: PUSH
46725: EMPTY
46726: LIST
46727: LIST
46728: PUSH
46729: LD_INT 3
46731: PUSH
46732: LD_INT 3
46734: PUSH
46735: EMPTY
46736: LIST
46737: LIST
46738: PUSH
46739: LD_INT 3
46741: PUSH
46742: LD_INT 2
46744: PUSH
46745: EMPTY
46746: LIST
46747: LIST
46748: PUSH
46749: LD_INT 4
46751: PUSH
46752: LD_INT 3
46754: PUSH
46755: EMPTY
46756: LIST
46757: LIST
46758: PUSH
46759: LD_INT 4
46761: PUSH
46762: LD_INT 4
46764: PUSH
46765: EMPTY
46766: LIST
46767: LIST
46768: PUSH
46769: LD_INT 3
46771: PUSH
46772: LD_INT 4
46774: PUSH
46775: EMPTY
46776: LIST
46777: LIST
46778: PUSH
46779: LD_INT 2
46781: PUSH
46782: LD_INT 3
46784: PUSH
46785: EMPTY
46786: LIST
46787: LIST
46788: PUSH
46789: LD_INT 2
46791: PUSH
46792: LD_INT 2
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: PUSH
46799: LD_INT 4
46801: PUSH
46802: LD_INT 2
46804: PUSH
46805: EMPTY
46806: LIST
46807: LIST
46808: PUSH
46809: LD_INT 2
46811: PUSH
46812: LD_INT 4
46814: PUSH
46815: EMPTY
46816: LIST
46817: LIST
46818: PUSH
46819: LD_INT 0
46821: PUSH
46822: LD_INT 4
46824: PUSH
46825: EMPTY
46826: LIST
46827: LIST
46828: PUSH
46829: LD_INT 0
46831: PUSH
46832: LD_INT 3
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: PUSH
46839: LD_INT 1
46841: PUSH
46842: LD_INT 4
46844: PUSH
46845: EMPTY
46846: LIST
46847: LIST
46848: PUSH
46849: LD_INT 1
46851: PUSH
46852: LD_INT 5
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: PUSH
46859: LD_INT 0
46861: PUSH
46862: LD_INT 5
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 1
46871: NEG
46872: PUSH
46873: LD_INT 4
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: LD_INT 1
46882: NEG
46883: PUSH
46884: LD_INT 3
46886: PUSH
46887: EMPTY
46888: LIST
46889: LIST
46890: PUSH
46891: LD_INT 2
46893: PUSH
46894: LD_INT 5
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PUSH
46901: LD_INT 2
46903: NEG
46904: PUSH
46905: LD_INT 3
46907: PUSH
46908: EMPTY
46909: LIST
46910: LIST
46911: PUSH
46912: EMPTY
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: LIST
46919: LIST
46920: LIST
46921: LIST
46922: LIST
46923: LIST
46924: LIST
46925: LIST
46926: LIST
46927: LIST
46928: LIST
46929: LIST
46930: LIST
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: LIST
46938: LIST
46939: LIST
46940: LIST
46941: LIST
46942: LIST
46943: LIST
46944: LIST
46945: LIST
46946: LIST
46947: LIST
46948: LIST
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: LIST
46958: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46959: LD_ADDR_VAR 0 34
46963: PUSH
46964: LD_INT 0
46966: PUSH
46967: LD_INT 4
46969: NEG
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: PUSH
46975: LD_INT 0
46977: PUSH
46978: LD_INT 5
46980: NEG
46981: PUSH
46982: EMPTY
46983: LIST
46984: LIST
46985: PUSH
46986: LD_INT 1
46988: PUSH
46989: LD_INT 4
46991: NEG
46992: PUSH
46993: EMPTY
46994: LIST
46995: LIST
46996: PUSH
46997: LD_INT 1
46999: PUSH
47000: LD_INT 3
47002: NEG
47003: PUSH
47004: EMPTY
47005: LIST
47006: LIST
47007: PUSH
47008: LD_INT 0
47010: PUSH
47011: LD_INT 3
47013: NEG
47014: PUSH
47015: EMPTY
47016: LIST
47017: LIST
47018: PUSH
47019: LD_INT 1
47021: NEG
47022: PUSH
47023: LD_INT 4
47025: NEG
47026: PUSH
47027: EMPTY
47028: LIST
47029: LIST
47030: PUSH
47031: LD_INT 1
47033: NEG
47034: PUSH
47035: LD_INT 5
47037: NEG
47038: PUSH
47039: EMPTY
47040: LIST
47041: LIST
47042: PUSH
47043: LD_INT 2
47045: PUSH
47046: LD_INT 3
47048: NEG
47049: PUSH
47050: EMPTY
47051: LIST
47052: LIST
47053: PUSH
47054: LD_INT 2
47056: NEG
47057: PUSH
47058: LD_INT 5
47060: NEG
47061: PUSH
47062: EMPTY
47063: LIST
47064: LIST
47065: PUSH
47066: LD_INT 3
47068: PUSH
47069: LD_INT 0
47071: PUSH
47072: EMPTY
47073: LIST
47074: LIST
47075: PUSH
47076: LD_INT 3
47078: PUSH
47079: LD_INT 1
47081: NEG
47082: PUSH
47083: EMPTY
47084: LIST
47085: LIST
47086: PUSH
47087: LD_INT 4
47089: PUSH
47090: LD_INT 0
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: PUSH
47097: LD_INT 4
47099: PUSH
47100: LD_INT 1
47102: PUSH
47103: EMPTY
47104: LIST
47105: LIST
47106: PUSH
47107: LD_INT 3
47109: PUSH
47110: LD_INT 1
47112: PUSH
47113: EMPTY
47114: LIST
47115: LIST
47116: PUSH
47117: LD_INT 2
47119: PUSH
47120: LD_INT 0
47122: PUSH
47123: EMPTY
47124: LIST
47125: LIST
47126: PUSH
47127: LD_INT 2
47129: PUSH
47130: LD_INT 1
47132: NEG
47133: PUSH
47134: EMPTY
47135: LIST
47136: LIST
47137: PUSH
47138: LD_INT 2
47140: PUSH
47141: LD_INT 2
47143: NEG
47144: PUSH
47145: EMPTY
47146: LIST
47147: LIST
47148: PUSH
47149: LD_INT 4
47151: PUSH
47152: LD_INT 2
47154: PUSH
47155: EMPTY
47156: LIST
47157: LIST
47158: PUSH
47159: LD_INT 4
47161: PUSH
47162: LD_INT 4
47164: PUSH
47165: EMPTY
47166: LIST
47167: LIST
47168: PUSH
47169: LD_INT 4
47171: PUSH
47172: LD_INT 3
47174: PUSH
47175: EMPTY
47176: LIST
47177: LIST
47178: PUSH
47179: LD_INT 5
47181: PUSH
47182: LD_INT 4
47184: PUSH
47185: EMPTY
47186: LIST
47187: LIST
47188: PUSH
47189: LD_INT 5
47191: PUSH
47192: LD_INT 5
47194: PUSH
47195: EMPTY
47196: LIST
47197: LIST
47198: PUSH
47199: LD_INT 4
47201: PUSH
47202: LD_INT 5
47204: PUSH
47205: EMPTY
47206: LIST
47207: LIST
47208: PUSH
47209: LD_INT 3
47211: PUSH
47212: LD_INT 4
47214: PUSH
47215: EMPTY
47216: LIST
47217: LIST
47218: PUSH
47219: LD_INT 3
47221: PUSH
47222: LD_INT 3
47224: PUSH
47225: EMPTY
47226: LIST
47227: LIST
47228: PUSH
47229: LD_INT 5
47231: PUSH
47232: LD_INT 3
47234: PUSH
47235: EMPTY
47236: LIST
47237: LIST
47238: PUSH
47239: LD_INT 3
47241: PUSH
47242: LD_INT 5
47244: PUSH
47245: EMPTY
47246: LIST
47247: LIST
47248: PUSH
47249: LD_INT 0
47251: PUSH
47252: LD_INT 3
47254: PUSH
47255: EMPTY
47256: LIST
47257: LIST
47258: PUSH
47259: LD_INT 0
47261: PUSH
47262: LD_INT 2
47264: PUSH
47265: EMPTY
47266: LIST
47267: LIST
47268: PUSH
47269: LD_INT 1
47271: PUSH
47272: LD_INT 3
47274: PUSH
47275: EMPTY
47276: LIST
47277: LIST
47278: PUSH
47279: LD_INT 1
47281: PUSH
47282: LD_INT 4
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: PUSH
47289: LD_INT 0
47291: PUSH
47292: LD_INT 4
47294: PUSH
47295: EMPTY
47296: LIST
47297: LIST
47298: PUSH
47299: LD_INT 1
47301: NEG
47302: PUSH
47303: LD_INT 3
47305: PUSH
47306: EMPTY
47307: LIST
47308: LIST
47309: PUSH
47310: LD_INT 1
47312: NEG
47313: PUSH
47314: LD_INT 2
47316: PUSH
47317: EMPTY
47318: LIST
47319: LIST
47320: PUSH
47321: LD_INT 2
47323: PUSH
47324: LD_INT 4
47326: PUSH
47327: EMPTY
47328: LIST
47329: LIST
47330: PUSH
47331: LD_INT 2
47333: NEG
47334: PUSH
47335: LD_INT 2
47337: PUSH
47338: EMPTY
47339: LIST
47340: LIST
47341: PUSH
47342: LD_INT 4
47344: NEG
47345: PUSH
47346: LD_INT 0
47348: PUSH
47349: EMPTY
47350: LIST
47351: LIST
47352: PUSH
47353: LD_INT 4
47355: NEG
47356: PUSH
47357: LD_INT 1
47359: NEG
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 3
47367: NEG
47368: PUSH
47369: LD_INT 0
47371: PUSH
47372: EMPTY
47373: LIST
47374: LIST
47375: PUSH
47376: LD_INT 3
47378: NEG
47379: PUSH
47380: LD_INT 1
47382: PUSH
47383: EMPTY
47384: LIST
47385: LIST
47386: PUSH
47387: LD_INT 4
47389: NEG
47390: PUSH
47391: LD_INT 1
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: PUSH
47398: LD_INT 5
47400: NEG
47401: PUSH
47402: LD_INT 0
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: PUSH
47409: LD_INT 5
47411: NEG
47412: PUSH
47413: LD_INT 1
47415: NEG
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: PUSH
47421: LD_INT 5
47423: NEG
47424: PUSH
47425: LD_INT 2
47427: NEG
47428: PUSH
47429: EMPTY
47430: LIST
47431: LIST
47432: PUSH
47433: LD_INT 3
47435: NEG
47436: PUSH
47437: LD_INT 2
47439: PUSH
47440: EMPTY
47441: LIST
47442: LIST
47443: PUSH
47444: EMPTY
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: LIST
47464: LIST
47465: LIST
47466: LIST
47467: LIST
47468: LIST
47469: LIST
47470: LIST
47471: LIST
47472: LIST
47473: LIST
47474: LIST
47475: LIST
47476: LIST
47477: LIST
47478: LIST
47479: LIST
47480: LIST
47481: LIST
47482: LIST
47483: LIST
47484: LIST
47485: LIST
47486: LIST
47487: LIST
47488: LIST
47489: LIST
47490: ST_TO_ADDR
// end ; end ;
47491: GO 47494
47493: POP
// case btype of b_depot , b_warehouse :
47494: LD_VAR 0 1
47498: PUSH
47499: LD_INT 0
47501: DOUBLE
47502: EQUAL
47503: IFTRUE 47513
47505: LD_INT 1
47507: DOUBLE
47508: EQUAL
47509: IFTRUE 47513
47511: GO 47714
47513: POP
// case nation of nation_american :
47514: LD_VAR 0 5
47518: PUSH
47519: LD_INT 1
47521: DOUBLE
47522: EQUAL
47523: IFTRUE 47527
47525: GO 47583
47527: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
47528: LD_ADDR_VAR 0 9
47532: PUSH
47533: LD_VAR 0 11
47537: PUSH
47538: LD_VAR 0 12
47542: PUSH
47543: LD_VAR 0 13
47547: PUSH
47548: LD_VAR 0 14
47552: PUSH
47553: LD_VAR 0 15
47557: PUSH
47558: LD_VAR 0 16
47562: PUSH
47563: EMPTY
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: LIST
47569: LIST
47570: PUSH
47571: LD_VAR 0 4
47575: PUSH
47576: LD_INT 1
47578: PLUS
47579: ARRAY
47580: ST_TO_ADDR
47581: GO 47712
47583: LD_INT 2
47585: DOUBLE
47586: EQUAL
47587: IFTRUE 47591
47589: GO 47647
47591: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
47592: LD_ADDR_VAR 0 9
47596: PUSH
47597: LD_VAR 0 17
47601: PUSH
47602: LD_VAR 0 18
47606: PUSH
47607: LD_VAR 0 19
47611: PUSH
47612: LD_VAR 0 20
47616: PUSH
47617: LD_VAR 0 21
47621: PUSH
47622: LD_VAR 0 22
47626: PUSH
47627: EMPTY
47628: LIST
47629: LIST
47630: LIST
47631: LIST
47632: LIST
47633: LIST
47634: PUSH
47635: LD_VAR 0 4
47639: PUSH
47640: LD_INT 1
47642: PLUS
47643: ARRAY
47644: ST_TO_ADDR
47645: GO 47712
47647: LD_INT 3
47649: DOUBLE
47650: EQUAL
47651: IFTRUE 47655
47653: GO 47711
47655: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47656: LD_ADDR_VAR 0 9
47660: PUSH
47661: LD_VAR 0 23
47665: PUSH
47666: LD_VAR 0 24
47670: PUSH
47671: LD_VAR 0 25
47675: PUSH
47676: LD_VAR 0 26
47680: PUSH
47681: LD_VAR 0 27
47685: PUSH
47686: LD_VAR 0 28
47690: PUSH
47691: EMPTY
47692: LIST
47693: LIST
47694: LIST
47695: LIST
47696: LIST
47697: LIST
47698: PUSH
47699: LD_VAR 0 4
47703: PUSH
47704: LD_INT 1
47706: PLUS
47707: ARRAY
47708: ST_TO_ADDR
47709: GO 47712
47711: POP
47712: GO 48267
47714: LD_INT 2
47716: DOUBLE
47717: EQUAL
47718: IFTRUE 47728
47720: LD_INT 3
47722: DOUBLE
47723: EQUAL
47724: IFTRUE 47728
47726: GO 47784
47728: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47729: LD_ADDR_VAR 0 9
47733: PUSH
47734: LD_VAR 0 29
47738: PUSH
47739: LD_VAR 0 30
47743: PUSH
47744: LD_VAR 0 31
47748: PUSH
47749: LD_VAR 0 32
47753: PUSH
47754: LD_VAR 0 33
47758: PUSH
47759: LD_VAR 0 34
47763: PUSH
47764: EMPTY
47765: LIST
47766: LIST
47767: LIST
47768: LIST
47769: LIST
47770: LIST
47771: PUSH
47772: LD_VAR 0 4
47776: PUSH
47777: LD_INT 1
47779: PLUS
47780: ARRAY
47781: ST_TO_ADDR
47782: GO 48267
47784: LD_INT 16
47786: DOUBLE
47787: EQUAL
47788: IFTRUE 47846
47790: LD_INT 17
47792: DOUBLE
47793: EQUAL
47794: IFTRUE 47846
47796: LD_INT 18
47798: DOUBLE
47799: EQUAL
47800: IFTRUE 47846
47802: LD_INT 19
47804: DOUBLE
47805: EQUAL
47806: IFTRUE 47846
47808: LD_INT 22
47810: DOUBLE
47811: EQUAL
47812: IFTRUE 47846
47814: LD_INT 20
47816: DOUBLE
47817: EQUAL
47818: IFTRUE 47846
47820: LD_INT 21
47822: DOUBLE
47823: EQUAL
47824: IFTRUE 47846
47826: LD_INT 23
47828: DOUBLE
47829: EQUAL
47830: IFTRUE 47846
47832: LD_INT 24
47834: DOUBLE
47835: EQUAL
47836: IFTRUE 47846
47838: LD_INT 25
47840: DOUBLE
47841: EQUAL
47842: IFTRUE 47846
47844: GO 47902
47846: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47847: LD_ADDR_VAR 0 9
47851: PUSH
47852: LD_VAR 0 35
47856: PUSH
47857: LD_VAR 0 36
47861: PUSH
47862: LD_VAR 0 37
47866: PUSH
47867: LD_VAR 0 38
47871: PUSH
47872: LD_VAR 0 39
47876: PUSH
47877: LD_VAR 0 40
47881: PUSH
47882: EMPTY
47883: LIST
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: LIST
47889: PUSH
47890: LD_VAR 0 4
47894: PUSH
47895: LD_INT 1
47897: PLUS
47898: ARRAY
47899: ST_TO_ADDR
47900: GO 48267
47902: LD_INT 6
47904: DOUBLE
47905: EQUAL
47906: IFTRUE 47958
47908: LD_INT 7
47910: DOUBLE
47911: EQUAL
47912: IFTRUE 47958
47914: LD_INT 8
47916: DOUBLE
47917: EQUAL
47918: IFTRUE 47958
47920: LD_INT 13
47922: DOUBLE
47923: EQUAL
47924: IFTRUE 47958
47926: LD_INT 12
47928: DOUBLE
47929: EQUAL
47930: IFTRUE 47958
47932: LD_INT 15
47934: DOUBLE
47935: EQUAL
47936: IFTRUE 47958
47938: LD_INT 11
47940: DOUBLE
47941: EQUAL
47942: IFTRUE 47958
47944: LD_INT 14
47946: DOUBLE
47947: EQUAL
47948: IFTRUE 47958
47950: LD_INT 10
47952: DOUBLE
47953: EQUAL
47954: IFTRUE 47958
47956: GO 48014
47958: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
47959: LD_ADDR_VAR 0 9
47963: PUSH
47964: LD_VAR 0 41
47968: PUSH
47969: LD_VAR 0 42
47973: PUSH
47974: LD_VAR 0 43
47978: PUSH
47979: LD_VAR 0 44
47983: PUSH
47984: LD_VAR 0 45
47988: PUSH
47989: LD_VAR 0 46
47993: PUSH
47994: EMPTY
47995: LIST
47996: LIST
47997: LIST
47998: LIST
47999: LIST
48000: LIST
48001: PUSH
48002: LD_VAR 0 4
48006: PUSH
48007: LD_INT 1
48009: PLUS
48010: ARRAY
48011: ST_TO_ADDR
48012: GO 48267
48014: LD_INT 36
48016: DOUBLE
48017: EQUAL
48018: IFTRUE 48022
48020: GO 48078
48022: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
48023: LD_ADDR_VAR 0 9
48027: PUSH
48028: LD_VAR 0 47
48032: PUSH
48033: LD_VAR 0 48
48037: PUSH
48038: LD_VAR 0 49
48042: PUSH
48043: LD_VAR 0 50
48047: PUSH
48048: LD_VAR 0 51
48052: PUSH
48053: LD_VAR 0 52
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: LIST
48062: LIST
48063: LIST
48064: LIST
48065: PUSH
48066: LD_VAR 0 4
48070: PUSH
48071: LD_INT 1
48073: PLUS
48074: ARRAY
48075: ST_TO_ADDR
48076: GO 48267
48078: LD_INT 4
48080: DOUBLE
48081: EQUAL
48082: IFTRUE 48104
48084: LD_INT 5
48086: DOUBLE
48087: EQUAL
48088: IFTRUE 48104
48090: LD_INT 34
48092: DOUBLE
48093: EQUAL
48094: IFTRUE 48104
48096: LD_INT 37
48098: DOUBLE
48099: EQUAL
48100: IFTRUE 48104
48102: GO 48160
48104: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
48105: LD_ADDR_VAR 0 9
48109: PUSH
48110: LD_VAR 0 53
48114: PUSH
48115: LD_VAR 0 54
48119: PUSH
48120: LD_VAR 0 55
48124: PUSH
48125: LD_VAR 0 56
48129: PUSH
48130: LD_VAR 0 57
48134: PUSH
48135: LD_VAR 0 58
48139: PUSH
48140: EMPTY
48141: LIST
48142: LIST
48143: LIST
48144: LIST
48145: LIST
48146: LIST
48147: PUSH
48148: LD_VAR 0 4
48152: PUSH
48153: LD_INT 1
48155: PLUS
48156: ARRAY
48157: ST_TO_ADDR
48158: GO 48267
48160: LD_INT 31
48162: DOUBLE
48163: EQUAL
48164: IFTRUE 48210
48166: LD_INT 32
48168: DOUBLE
48169: EQUAL
48170: IFTRUE 48210
48172: LD_INT 33
48174: DOUBLE
48175: EQUAL
48176: IFTRUE 48210
48178: LD_INT 27
48180: DOUBLE
48181: EQUAL
48182: IFTRUE 48210
48184: LD_INT 26
48186: DOUBLE
48187: EQUAL
48188: IFTRUE 48210
48190: LD_INT 28
48192: DOUBLE
48193: EQUAL
48194: IFTRUE 48210
48196: LD_INT 29
48198: DOUBLE
48199: EQUAL
48200: IFTRUE 48210
48202: LD_INT 30
48204: DOUBLE
48205: EQUAL
48206: IFTRUE 48210
48208: GO 48266
48210: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
48211: LD_ADDR_VAR 0 9
48215: PUSH
48216: LD_VAR 0 59
48220: PUSH
48221: LD_VAR 0 60
48225: PUSH
48226: LD_VAR 0 61
48230: PUSH
48231: LD_VAR 0 62
48235: PUSH
48236: LD_VAR 0 63
48240: PUSH
48241: LD_VAR 0 64
48245: PUSH
48246: EMPTY
48247: LIST
48248: LIST
48249: LIST
48250: LIST
48251: LIST
48252: LIST
48253: PUSH
48254: LD_VAR 0 4
48258: PUSH
48259: LD_INT 1
48261: PLUS
48262: ARRAY
48263: ST_TO_ADDR
48264: GO 48267
48266: POP
// temp_list2 = [ ] ;
48267: LD_ADDR_VAR 0 10
48271: PUSH
48272: EMPTY
48273: ST_TO_ADDR
// for i in temp_list do
48274: LD_ADDR_VAR 0 8
48278: PUSH
48279: LD_VAR 0 9
48283: PUSH
48284: FOR_IN
48285: IFFALSE 48337
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
48287: LD_ADDR_VAR 0 10
48291: PUSH
48292: LD_VAR 0 10
48296: PUSH
48297: LD_VAR 0 8
48301: PUSH
48302: LD_INT 1
48304: ARRAY
48305: PUSH
48306: LD_VAR 0 2
48310: PLUS
48311: PUSH
48312: LD_VAR 0 8
48316: PUSH
48317: LD_INT 2
48319: ARRAY
48320: PUSH
48321: LD_VAR 0 3
48325: PLUS
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: EMPTY
48332: LIST
48333: ADD
48334: ST_TO_ADDR
48335: GO 48284
48337: POP
48338: POP
// result = temp_list2 ;
48339: LD_ADDR_VAR 0 7
48343: PUSH
48344: LD_VAR 0 10
48348: ST_TO_ADDR
// end ;
48349: LD_VAR 0 7
48353: RET
// export function EnemyInRange ( unit , dist ) ; begin
48354: LD_INT 0
48356: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
48357: LD_ADDR_VAR 0 3
48361: PUSH
48362: LD_VAR 0 1
48366: PPUSH
48367: CALL_OW 255
48371: PPUSH
48372: LD_VAR 0 1
48376: PPUSH
48377: CALL_OW 250
48381: PPUSH
48382: LD_VAR 0 1
48386: PPUSH
48387: CALL_OW 251
48391: PPUSH
48392: LD_VAR 0 2
48396: PPUSH
48397: CALL 21727 0 4
48401: PUSH
48402: LD_INT 4
48404: ARRAY
48405: ST_TO_ADDR
// end ;
48406: LD_VAR 0 3
48410: RET
// export function PlayerSeeMe ( unit ) ; begin
48411: LD_INT 0
48413: PPUSH
// result := See ( your_side , unit ) ;
48414: LD_ADDR_VAR 0 2
48418: PUSH
48419: LD_OWVAR 2
48423: PPUSH
48424: LD_VAR 0 1
48428: PPUSH
48429: CALL_OW 292
48433: ST_TO_ADDR
// end ;
48434: LD_VAR 0 2
48438: RET
// export function ReverseDir ( unit ) ; begin
48439: LD_INT 0
48441: PPUSH
// if not unit then
48442: LD_VAR 0 1
48446: NOT
48447: IFFALSE 48451
// exit ;
48449: GO 48474
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
48451: LD_ADDR_VAR 0 2
48455: PUSH
48456: LD_VAR 0 1
48460: PPUSH
48461: CALL_OW 254
48465: PUSH
48466: LD_INT 3
48468: PLUS
48469: PUSH
48470: LD_INT 6
48472: MOD
48473: ST_TO_ADDR
// end ;
48474: LD_VAR 0 2
48478: RET
// export function ReverseArray ( array ) ; var i ; begin
48479: LD_INT 0
48481: PPUSH
48482: PPUSH
// if not array then
48483: LD_VAR 0 1
48487: NOT
48488: IFFALSE 48492
// exit ;
48490: GO 48547
// result := [ ] ;
48492: LD_ADDR_VAR 0 2
48496: PUSH
48497: EMPTY
48498: ST_TO_ADDR
// for i := array downto 1 do
48499: LD_ADDR_VAR 0 3
48503: PUSH
48504: DOUBLE
48505: LD_VAR 0 1
48509: INC
48510: ST_TO_ADDR
48511: LD_INT 1
48513: PUSH
48514: FOR_DOWNTO
48515: IFFALSE 48545
// result := Join ( result , array [ i ] ) ;
48517: LD_ADDR_VAR 0 2
48521: PUSH
48522: LD_VAR 0 2
48526: PPUSH
48527: LD_VAR 0 1
48531: PUSH
48532: LD_VAR 0 3
48536: ARRAY
48537: PPUSH
48538: CALL 53203 0 2
48542: ST_TO_ADDR
48543: GO 48514
48545: POP
48546: POP
// end ;
48547: LD_VAR 0 2
48551: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
48552: LD_INT 0
48554: PPUSH
48555: PPUSH
48556: PPUSH
48557: PPUSH
48558: PPUSH
48559: PPUSH
// if not unit or not hexes then
48560: LD_VAR 0 1
48564: NOT
48565: PUSH
48566: LD_VAR 0 2
48570: NOT
48571: OR
48572: IFFALSE 48576
// exit ;
48574: GO 48699
// dist := 9999 ;
48576: LD_ADDR_VAR 0 5
48580: PUSH
48581: LD_INT 9999
48583: ST_TO_ADDR
// for i = 1 to hexes do
48584: LD_ADDR_VAR 0 4
48588: PUSH
48589: DOUBLE
48590: LD_INT 1
48592: DEC
48593: ST_TO_ADDR
48594: LD_VAR 0 2
48598: PUSH
48599: FOR_TO
48600: IFFALSE 48687
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48602: LD_ADDR_VAR 0 6
48606: PUSH
48607: LD_VAR 0 1
48611: PPUSH
48612: LD_VAR 0 2
48616: PUSH
48617: LD_VAR 0 4
48621: ARRAY
48622: PUSH
48623: LD_INT 1
48625: ARRAY
48626: PPUSH
48627: LD_VAR 0 2
48631: PUSH
48632: LD_VAR 0 4
48636: ARRAY
48637: PUSH
48638: LD_INT 2
48640: ARRAY
48641: PPUSH
48642: CALL_OW 297
48646: ST_TO_ADDR
// if tdist < dist then
48647: LD_VAR 0 6
48651: PUSH
48652: LD_VAR 0 5
48656: LESS
48657: IFFALSE 48685
// begin hex := hexes [ i ] ;
48659: LD_ADDR_VAR 0 8
48663: PUSH
48664: LD_VAR 0 2
48668: PUSH
48669: LD_VAR 0 4
48673: ARRAY
48674: ST_TO_ADDR
// dist := tdist ;
48675: LD_ADDR_VAR 0 5
48679: PUSH
48680: LD_VAR 0 6
48684: ST_TO_ADDR
// end ; end ;
48685: GO 48599
48687: POP
48688: POP
// result := hex ;
48689: LD_ADDR_VAR 0 3
48693: PUSH
48694: LD_VAR 0 8
48698: ST_TO_ADDR
// end ;
48699: LD_VAR 0 3
48703: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48704: LD_INT 0
48706: PPUSH
48707: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48708: LD_VAR 0 1
48712: NOT
48713: PUSH
48714: LD_VAR 0 1
48718: PUSH
48719: LD_INT 21
48721: PUSH
48722: LD_INT 2
48724: PUSH
48725: EMPTY
48726: LIST
48727: LIST
48728: PUSH
48729: LD_INT 23
48731: PUSH
48732: LD_INT 2
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: PUSH
48739: EMPTY
48740: LIST
48741: LIST
48742: PPUSH
48743: CALL_OW 69
48747: IN
48748: NOT
48749: OR
48750: IFFALSE 48754
// exit ;
48752: GO 48801
// for i = 1 to 3 do
48754: LD_ADDR_VAR 0 3
48758: PUSH
48759: DOUBLE
48760: LD_INT 1
48762: DEC
48763: ST_TO_ADDR
48764: LD_INT 3
48766: PUSH
48767: FOR_TO
48768: IFFALSE 48799
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48770: LD_VAR 0 1
48774: PPUSH
48775: CALL_OW 250
48779: PPUSH
48780: LD_VAR 0 1
48784: PPUSH
48785: CALL_OW 251
48789: PPUSH
48790: LD_INT 1
48792: PPUSH
48793: CALL_OW 453
48797: GO 48767
48799: POP
48800: POP
// end ;
48801: LD_VAR 0 2
48805: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48806: LD_INT 0
48808: PPUSH
48809: PPUSH
48810: PPUSH
48811: PPUSH
48812: PPUSH
48813: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48814: LD_VAR 0 1
48818: NOT
48819: PUSH
48820: LD_VAR 0 2
48824: NOT
48825: OR
48826: PUSH
48827: LD_VAR 0 1
48831: PPUSH
48832: CALL_OW 314
48836: OR
48837: IFFALSE 48841
// exit ;
48839: GO 49308
// if GetLives ( i ) < 250 then
48841: LD_VAR 0 4
48845: PPUSH
48846: CALL_OW 256
48850: PUSH
48851: LD_INT 250
48853: LESS
48854: IFFALSE 48867
// begin ComAutodestruct ( i ) ;
48856: LD_VAR 0 4
48860: PPUSH
48861: CALL 48704 0 1
// exit ;
48865: GO 49308
// end ; x := GetX ( enemy_unit ) ;
48867: LD_ADDR_VAR 0 7
48871: PUSH
48872: LD_VAR 0 2
48876: PPUSH
48877: CALL_OW 250
48881: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48882: LD_ADDR_VAR 0 8
48886: PUSH
48887: LD_VAR 0 2
48891: PPUSH
48892: CALL_OW 251
48896: ST_TO_ADDR
// if not x or not y then
48897: LD_VAR 0 7
48901: NOT
48902: PUSH
48903: LD_VAR 0 8
48907: NOT
48908: OR
48909: IFFALSE 48913
// exit ;
48911: GO 49308
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48913: LD_ADDR_VAR 0 6
48917: PUSH
48918: LD_VAR 0 7
48922: PPUSH
48923: LD_INT 0
48925: PPUSH
48926: LD_INT 4
48928: PPUSH
48929: CALL_OW 272
48933: PUSH
48934: LD_VAR 0 8
48938: PPUSH
48939: LD_INT 0
48941: PPUSH
48942: LD_INT 4
48944: PPUSH
48945: CALL_OW 273
48949: PUSH
48950: EMPTY
48951: LIST
48952: LIST
48953: PUSH
48954: LD_VAR 0 7
48958: PPUSH
48959: LD_INT 1
48961: PPUSH
48962: LD_INT 4
48964: PPUSH
48965: CALL_OW 272
48969: PUSH
48970: LD_VAR 0 8
48974: PPUSH
48975: LD_INT 1
48977: PPUSH
48978: LD_INT 4
48980: PPUSH
48981: CALL_OW 273
48985: PUSH
48986: EMPTY
48987: LIST
48988: LIST
48989: PUSH
48990: LD_VAR 0 7
48994: PPUSH
48995: LD_INT 2
48997: PPUSH
48998: LD_INT 4
49000: PPUSH
49001: CALL_OW 272
49005: PUSH
49006: LD_VAR 0 8
49010: PPUSH
49011: LD_INT 2
49013: PPUSH
49014: LD_INT 4
49016: PPUSH
49017: CALL_OW 273
49021: PUSH
49022: EMPTY
49023: LIST
49024: LIST
49025: PUSH
49026: LD_VAR 0 7
49030: PPUSH
49031: LD_INT 3
49033: PPUSH
49034: LD_INT 4
49036: PPUSH
49037: CALL_OW 272
49041: PUSH
49042: LD_VAR 0 8
49046: PPUSH
49047: LD_INT 3
49049: PPUSH
49050: LD_INT 4
49052: PPUSH
49053: CALL_OW 273
49057: PUSH
49058: EMPTY
49059: LIST
49060: LIST
49061: PUSH
49062: LD_VAR 0 7
49066: PPUSH
49067: LD_INT 4
49069: PPUSH
49070: LD_INT 4
49072: PPUSH
49073: CALL_OW 272
49077: PUSH
49078: LD_VAR 0 8
49082: PPUSH
49083: LD_INT 4
49085: PPUSH
49086: LD_INT 4
49088: PPUSH
49089: CALL_OW 273
49093: PUSH
49094: EMPTY
49095: LIST
49096: LIST
49097: PUSH
49098: LD_VAR 0 7
49102: PPUSH
49103: LD_INT 5
49105: PPUSH
49106: LD_INT 4
49108: PPUSH
49109: CALL_OW 272
49113: PUSH
49114: LD_VAR 0 8
49118: PPUSH
49119: LD_INT 5
49121: PPUSH
49122: LD_INT 4
49124: PPUSH
49125: CALL_OW 273
49129: PUSH
49130: EMPTY
49131: LIST
49132: LIST
49133: PUSH
49134: EMPTY
49135: LIST
49136: LIST
49137: LIST
49138: LIST
49139: LIST
49140: LIST
49141: ST_TO_ADDR
// for i = tmp downto 1 do
49142: LD_ADDR_VAR 0 4
49146: PUSH
49147: DOUBLE
49148: LD_VAR 0 6
49152: INC
49153: ST_TO_ADDR
49154: LD_INT 1
49156: PUSH
49157: FOR_DOWNTO
49158: IFFALSE 49259
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
49160: LD_VAR 0 6
49164: PUSH
49165: LD_VAR 0 4
49169: ARRAY
49170: PUSH
49171: LD_INT 1
49173: ARRAY
49174: PPUSH
49175: LD_VAR 0 6
49179: PUSH
49180: LD_VAR 0 4
49184: ARRAY
49185: PUSH
49186: LD_INT 2
49188: ARRAY
49189: PPUSH
49190: CALL_OW 488
49194: NOT
49195: PUSH
49196: LD_VAR 0 6
49200: PUSH
49201: LD_VAR 0 4
49205: ARRAY
49206: PUSH
49207: LD_INT 1
49209: ARRAY
49210: PPUSH
49211: LD_VAR 0 6
49215: PUSH
49216: LD_VAR 0 4
49220: ARRAY
49221: PUSH
49222: LD_INT 2
49224: ARRAY
49225: PPUSH
49226: CALL_OW 428
49230: PUSH
49231: LD_INT 0
49233: NONEQUAL
49234: OR
49235: IFFALSE 49257
// tmp := Delete ( tmp , i ) ;
49237: LD_ADDR_VAR 0 6
49241: PUSH
49242: LD_VAR 0 6
49246: PPUSH
49247: LD_VAR 0 4
49251: PPUSH
49252: CALL_OW 3
49256: ST_TO_ADDR
49257: GO 49157
49259: POP
49260: POP
// j := GetClosestHex ( unit , tmp ) ;
49261: LD_ADDR_VAR 0 5
49265: PUSH
49266: LD_VAR 0 1
49270: PPUSH
49271: LD_VAR 0 6
49275: PPUSH
49276: CALL 48552 0 2
49280: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
49281: LD_VAR 0 1
49285: PPUSH
49286: LD_VAR 0 5
49290: PUSH
49291: LD_INT 1
49293: ARRAY
49294: PPUSH
49295: LD_VAR 0 5
49299: PUSH
49300: LD_INT 2
49302: ARRAY
49303: PPUSH
49304: CALL_OW 111
// end ;
49308: LD_VAR 0 3
49312: RET
// export function PrepareApemanSoldier ( ) ; begin
49313: LD_INT 0
49315: PPUSH
// uc_nation := 0 ;
49316: LD_ADDR_OWVAR 21
49320: PUSH
49321: LD_INT 0
49323: ST_TO_ADDR
// hc_sex := sex_male ;
49324: LD_ADDR_OWVAR 27
49328: PUSH
49329: LD_INT 1
49331: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
49332: LD_ADDR_OWVAR 28
49336: PUSH
49337: LD_INT 15
49339: ST_TO_ADDR
// hc_gallery :=  ;
49340: LD_ADDR_OWVAR 33
49344: PUSH
49345: LD_STRING 
49347: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
49348: LD_ADDR_OWVAR 31
49352: PUSH
49353: LD_INT 0
49355: PPUSH
49356: LD_INT 3
49358: PPUSH
49359: CALL_OW 12
49363: PUSH
49364: LD_INT 0
49366: PPUSH
49367: LD_INT 3
49369: PPUSH
49370: CALL_OW 12
49374: PUSH
49375: LD_INT 0
49377: PUSH
49378: LD_INT 0
49380: PUSH
49381: EMPTY
49382: LIST
49383: LIST
49384: LIST
49385: LIST
49386: ST_TO_ADDR
// end ;
49387: LD_VAR 0 1
49391: RET
// export function PrepareApemanEngineer ( ) ; begin
49392: LD_INT 0
49394: PPUSH
// uc_nation := 0 ;
49395: LD_ADDR_OWVAR 21
49399: PUSH
49400: LD_INT 0
49402: ST_TO_ADDR
// hc_sex := sex_male ;
49403: LD_ADDR_OWVAR 27
49407: PUSH
49408: LD_INT 1
49410: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
49411: LD_ADDR_OWVAR 28
49415: PUSH
49416: LD_INT 16
49418: ST_TO_ADDR
// hc_gallery :=  ;
49419: LD_ADDR_OWVAR 33
49423: PUSH
49424: LD_STRING 
49426: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
49427: LD_ADDR_OWVAR 31
49431: PUSH
49432: LD_INT 0
49434: PPUSH
49435: LD_INT 3
49437: PPUSH
49438: CALL_OW 12
49442: PUSH
49443: LD_INT 0
49445: PPUSH
49446: LD_INT 3
49448: PPUSH
49449: CALL_OW 12
49453: PUSH
49454: LD_INT 0
49456: PUSH
49457: LD_INT 0
49459: PUSH
49460: EMPTY
49461: LIST
49462: LIST
49463: LIST
49464: LIST
49465: ST_TO_ADDR
// end ;
49466: LD_VAR 0 1
49470: RET
// export function PrepareApeman ( agressivity ) ; begin
49471: LD_INT 0
49473: PPUSH
// uc_side := 0 ;
49474: LD_ADDR_OWVAR 20
49478: PUSH
49479: LD_INT 0
49481: ST_TO_ADDR
// uc_nation := 0 ;
49482: LD_ADDR_OWVAR 21
49486: PUSH
49487: LD_INT 0
49489: ST_TO_ADDR
// hc_sex := sex_male ;
49490: LD_ADDR_OWVAR 27
49494: PUSH
49495: LD_INT 1
49497: ST_TO_ADDR
// hc_class := class_apeman ;
49498: LD_ADDR_OWVAR 28
49502: PUSH
49503: LD_INT 12
49505: ST_TO_ADDR
// hc_gallery :=  ;
49506: LD_ADDR_OWVAR 33
49510: PUSH
49511: LD_STRING 
49513: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
49514: LD_ADDR_OWVAR 35
49518: PUSH
49519: LD_VAR 0 1
49523: NEG
49524: PPUSH
49525: LD_VAR 0 1
49529: PPUSH
49530: CALL_OW 12
49534: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
49535: LD_ADDR_OWVAR 31
49539: PUSH
49540: LD_INT 0
49542: PPUSH
49543: LD_INT 3
49545: PPUSH
49546: CALL_OW 12
49550: PUSH
49551: LD_INT 0
49553: PPUSH
49554: LD_INT 3
49556: PPUSH
49557: CALL_OW 12
49561: PUSH
49562: LD_INT 0
49564: PUSH
49565: LD_INT 0
49567: PUSH
49568: EMPTY
49569: LIST
49570: LIST
49571: LIST
49572: LIST
49573: ST_TO_ADDR
// end ;
49574: LD_VAR 0 2
49578: RET
// export function PrepareTiger ( agressivity ) ; begin
49579: LD_INT 0
49581: PPUSH
// uc_side := 0 ;
49582: LD_ADDR_OWVAR 20
49586: PUSH
49587: LD_INT 0
49589: ST_TO_ADDR
// uc_nation := 0 ;
49590: LD_ADDR_OWVAR 21
49594: PUSH
49595: LD_INT 0
49597: ST_TO_ADDR
// hc_class := class_tiger ;
49598: LD_ADDR_OWVAR 28
49602: PUSH
49603: LD_INT 14
49605: ST_TO_ADDR
// hc_gallery :=  ;
49606: LD_ADDR_OWVAR 33
49610: PUSH
49611: LD_STRING 
49613: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
49614: LD_ADDR_OWVAR 35
49618: PUSH
49619: LD_VAR 0 1
49623: NEG
49624: PPUSH
49625: LD_VAR 0 1
49629: PPUSH
49630: CALL_OW 12
49634: ST_TO_ADDR
// end ;
49635: LD_VAR 0 2
49639: RET
// export function PrepareEnchidna ( ) ; begin
49640: LD_INT 0
49642: PPUSH
// uc_side := 0 ;
49643: LD_ADDR_OWVAR 20
49647: PUSH
49648: LD_INT 0
49650: ST_TO_ADDR
// uc_nation := 0 ;
49651: LD_ADDR_OWVAR 21
49655: PUSH
49656: LD_INT 0
49658: ST_TO_ADDR
// hc_class := class_baggie ;
49659: LD_ADDR_OWVAR 28
49663: PUSH
49664: LD_INT 13
49666: ST_TO_ADDR
// hc_gallery :=  ;
49667: LD_ADDR_OWVAR 33
49671: PUSH
49672: LD_STRING 
49674: ST_TO_ADDR
// end ;
49675: LD_VAR 0 1
49679: RET
// export function PrepareFrog ( ) ; begin
49680: LD_INT 0
49682: PPUSH
// uc_side := 0 ;
49683: LD_ADDR_OWVAR 20
49687: PUSH
49688: LD_INT 0
49690: ST_TO_ADDR
// uc_nation := 0 ;
49691: LD_ADDR_OWVAR 21
49695: PUSH
49696: LD_INT 0
49698: ST_TO_ADDR
// hc_class := class_frog ;
49699: LD_ADDR_OWVAR 28
49703: PUSH
49704: LD_INT 19
49706: ST_TO_ADDR
// hc_gallery :=  ;
49707: LD_ADDR_OWVAR 33
49711: PUSH
49712: LD_STRING 
49714: ST_TO_ADDR
// end ;
49715: LD_VAR 0 1
49719: RET
// export function PrepareFish ( ) ; begin
49720: LD_INT 0
49722: PPUSH
// uc_side := 0 ;
49723: LD_ADDR_OWVAR 20
49727: PUSH
49728: LD_INT 0
49730: ST_TO_ADDR
// uc_nation := 0 ;
49731: LD_ADDR_OWVAR 21
49735: PUSH
49736: LD_INT 0
49738: ST_TO_ADDR
// hc_class := class_fish ;
49739: LD_ADDR_OWVAR 28
49743: PUSH
49744: LD_INT 20
49746: ST_TO_ADDR
// hc_gallery :=  ;
49747: LD_ADDR_OWVAR 33
49751: PUSH
49752: LD_STRING 
49754: ST_TO_ADDR
// end ;
49755: LD_VAR 0 1
49759: RET
// export function PrepareBird ( ) ; begin
49760: LD_INT 0
49762: PPUSH
// uc_side := 0 ;
49763: LD_ADDR_OWVAR 20
49767: PUSH
49768: LD_INT 0
49770: ST_TO_ADDR
// uc_nation := 0 ;
49771: LD_ADDR_OWVAR 21
49775: PUSH
49776: LD_INT 0
49778: ST_TO_ADDR
// hc_class := class_phororhacos ;
49779: LD_ADDR_OWVAR 28
49783: PUSH
49784: LD_INT 18
49786: ST_TO_ADDR
// hc_gallery :=  ;
49787: LD_ADDR_OWVAR 33
49791: PUSH
49792: LD_STRING 
49794: ST_TO_ADDR
// end ;
49795: LD_VAR 0 1
49799: RET
// export function PrepareHorse ( ) ; begin
49800: LD_INT 0
49802: PPUSH
// uc_side := 0 ;
49803: LD_ADDR_OWVAR 20
49807: PUSH
49808: LD_INT 0
49810: ST_TO_ADDR
// uc_nation := 0 ;
49811: LD_ADDR_OWVAR 21
49815: PUSH
49816: LD_INT 0
49818: ST_TO_ADDR
// hc_class := class_horse ;
49819: LD_ADDR_OWVAR 28
49823: PUSH
49824: LD_INT 21
49826: ST_TO_ADDR
// hc_gallery :=  ;
49827: LD_ADDR_OWVAR 33
49831: PUSH
49832: LD_STRING 
49834: ST_TO_ADDR
// end ;
49835: LD_VAR 0 1
49839: RET
// export function PrepareMastodont ( ) ; begin
49840: LD_INT 0
49842: PPUSH
// uc_side := 0 ;
49843: LD_ADDR_OWVAR 20
49847: PUSH
49848: LD_INT 0
49850: ST_TO_ADDR
// uc_nation := 0 ;
49851: LD_ADDR_OWVAR 21
49855: PUSH
49856: LD_INT 0
49858: ST_TO_ADDR
// vc_chassis := class_mastodont ;
49859: LD_ADDR_OWVAR 37
49863: PUSH
49864: LD_INT 31
49866: ST_TO_ADDR
// vc_control := control_rider ;
49867: LD_ADDR_OWVAR 38
49871: PUSH
49872: LD_INT 4
49874: ST_TO_ADDR
// end ;
49875: LD_VAR 0 1
49879: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49880: LD_INT 0
49882: PPUSH
49883: PPUSH
49884: PPUSH
// uc_side = 0 ;
49885: LD_ADDR_OWVAR 20
49889: PUSH
49890: LD_INT 0
49892: ST_TO_ADDR
// uc_nation = 0 ;
49893: LD_ADDR_OWVAR 21
49897: PUSH
49898: LD_INT 0
49900: ST_TO_ADDR
// InitHc_All ( ) ;
49901: CALL_OW 584
// InitVc ;
49905: CALL_OW 20
// if mastodonts then
49909: LD_VAR 0 6
49913: IFFALSE 49980
// for i = 1 to mastodonts do
49915: LD_ADDR_VAR 0 11
49919: PUSH
49920: DOUBLE
49921: LD_INT 1
49923: DEC
49924: ST_TO_ADDR
49925: LD_VAR 0 6
49929: PUSH
49930: FOR_TO
49931: IFFALSE 49978
// begin vc_chassis := 31 ;
49933: LD_ADDR_OWVAR 37
49937: PUSH
49938: LD_INT 31
49940: ST_TO_ADDR
// vc_control := control_rider ;
49941: LD_ADDR_OWVAR 38
49945: PUSH
49946: LD_INT 4
49948: ST_TO_ADDR
// animal := CreateVehicle ;
49949: LD_ADDR_VAR 0 12
49953: PUSH
49954: CALL_OW 45
49958: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49959: LD_VAR 0 12
49963: PPUSH
49964: LD_VAR 0 8
49968: PPUSH
49969: LD_INT 0
49971: PPUSH
49972: CALL 52108 0 3
// end ;
49976: GO 49930
49978: POP
49979: POP
// if horses then
49980: LD_VAR 0 5
49984: IFFALSE 50051
// for i = 1 to horses do
49986: LD_ADDR_VAR 0 11
49990: PUSH
49991: DOUBLE
49992: LD_INT 1
49994: DEC
49995: ST_TO_ADDR
49996: LD_VAR 0 5
50000: PUSH
50001: FOR_TO
50002: IFFALSE 50049
// begin hc_class := 21 ;
50004: LD_ADDR_OWVAR 28
50008: PUSH
50009: LD_INT 21
50011: ST_TO_ADDR
// hc_gallery :=  ;
50012: LD_ADDR_OWVAR 33
50016: PUSH
50017: LD_STRING 
50019: ST_TO_ADDR
// animal := CreateHuman ;
50020: LD_ADDR_VAR 0 12
50024: PUSH
50025: CALL_OW 44
50029: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50030: LD_VAR 0 12
50034: PPUSH
50035: LD_VAR 0 8
50039: PPUSH
50040: LD_INT 0
50042: PPUSH
50043: CALL 52108 0 3
// end ;
50047: GO 50001
50049: POP
50050: POP
// if birds then
50051: LD_VAR 0 1
50055: IFFALSE 50122
// for i = 1 to birds do
50057: LD_ADDR_VAR 0 11
50061: PUSH
50062: DOUBLE
50063: LD_INT 1
50065: DEC
50066: ST_TO_ADDR
50067: LD_VAR 0 1
50071: PUSH
50072: FOR_TO
50073: IFFALSE 50120
// begin hc_class := 18 ;
50075: LD_ADDR_OWVAR 28
50079: PUSH
50080: LD_INT 18
50082: ST_TO_ADDR
// hc_gallery =  ;
50083: LD_ADDR_OWVAR 33
50087: PUSH
50088: LD_STRING 
50090: ST_TO_ADDR
// animal := CreateHuman ;
50091: LD_ADDR_VAR 0 12
50095: PUSH
50096: CALL_OW 44
50100: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50101: LD_VAR 0 12
50105: PPUSH
50106: LD_VAR 0 8
50110: PPUSH
50111: LD_INT 0
50113: PPUSH
50114: CALL 52108 0 3
// end ;
50118: GO 50072
50120: POP
50121: POP
// if tigers then
50122: LD_VAR 0 2
50126: IFFALSE 50210
// for i = 1 to tigers do
50128: LD_ADDR_VAR 0 11
50132: PUSH
50133: DOUBLE
50134: LD_INT 1
50136: DEC
50137: ST_TO_ADDR
50138: LD_VAR 0 2
50142: PUSH
50143: FOR_TO
50144: IFFALSE 50208
// begin hc_class = class_tiger ;
50146: LD_ADDR_OWVAR 28
50150: PUSH
50151: LD_INT 14
50153: ST_TO_ADDR
// hc_gallery =  ;
50154: LD_ADDR_OWVAR 33
50158: PUSH
50159: LD_STRING 
50161: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
50162: LD_ADDR_OWVAR 35
50166: PUSH
50167: LD_INT 7
50169: NEG
50170: PPUSH
50171: LD_INT 7
50173: PPUSH
50174: CALL_OW 12
50178: ST_TO_ADDR
// animal := CreateHuman ;
50179: LD_ADDR_VAR 0 12
50183: PUSH
50184: CALL_OW 44
50188: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50189: LD_VAR 0 12
50193: PPUSH
50194: LD_VAR 0 8
50198: PPUSH
50199: LD_INT 0
50201: PPUSH
50202: CALL 52108 0 3
// end ;
50206: GO 50143
50208: POP
50209: POP
// if apemans then
50210: LD_VAR 0 3
50214: IFFALSE 50337
// for i = 1 to apemans do
50216: LD_ADDR_VAR 0 11
50220: PUSH
50221: DOUBLE
50222: LD_INT 1
50224: DEC
50225: ST_TO_ADDR
50226: LD_VAR 0 3
50230: PUSH
50231: FOR_TO
50232: IFFALSE 50335
// begin hc_class = class_apeman ;
50234: LD_ADDR_OWVAR 28
50238: PUSH
50239: LD_INT 12
50241: ST_TO_ADDR
// hc_gallery =  ;
50242: LD_ADDR_OWVAR 33
50246: PUSH
50247: LD_STRING 
50249: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
50250: LD_ADDR_OWVAR 35
50254: PUSH
50255: LD_INT 2
50257: NEG
50258: PPUSH
50259: LD_INT 2
50261: PPUSH
50262: CALL_OW 12
50266: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
50267: LD_ADDR_OWVAR 31
50271: PUSH
50272: LD_INT 1
50274: PPUSH
50275: LD_INT 3
50277: PPUSH
50278: CALL_OW 12
50282: PUSH
50283: LD_INT 1
50285: PPUSH
50286: LD_INT 3
50288: PPUSH
50289: CALL_OW 12
50293: PUSH
50294: LD_INT 0
50296: PUSH
50297: LD_INT 0
50299: PUSH
50300: EMPTY
50301: LIST
50302: LIST
50303: LIST
50304: LIST
50305: ST_TO_ADDR
// animal := CreateHuman ;
50306: LD_ADDR_VAR 0 12
50310: PUSH
50311: CALL_OW 44
50315: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50316: LD_VAR 0 12
50320: PPUSH
50321: LD_VAR 0 8
50325: PPUSH
50326: LD_INT 0
50328: PPUSH
50329: CALL 52108 0 3
// end ;
50333: GO 50231
50335: POP
50336: POP
// if enchidnas then
50337: LD_VAR 0 4
50341: IFFALSE 50408
// for i = 1 to enchidnas do
50343: LD_ADDR_VAR 0 11
50347: PUSH
50348: DOUBLE
50349: LD_INT 1
50351: DEC
50352: ST_TO_ADDR
50353: LD_VAR 0 4
50357: PUSH
50358: FOR_TO
50359: IFFALSE 50406
// begin hc_class = 13 ;
50361: LD_ADDR_OWVAR 28
50365: PUSH
50366: LD_INT 13
50368: ST_TO_ADDR
// hc_gallery =  ;
50369: LD_ADDR_OWVAR 33
50373: PUSH
50374: LD_STRING 
50376: ST_TO_ADDR
// animal := CreateHuman ;
50377: LD_ADDR_VAR 0 12
50381: PUSH
50382: CALL_OW 44
50386: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50387: LD_VAR 0 12
50391: PPUSH
50392: LD_VAR 0 8
50396: PPUSH
50397: LD_INT 0
50399: PPUSH
50400: CALL 52108 0 3
// end ;
50404: GO 50358
50406: POP
50407: POP
// if fishes then
50408: LD_VAR 0 7
50412: IFFALSE 50479
// for i = 1 to fishes do
50414: LD_ADDR_VAR 0 11
50418: PUSH
50419: DOUBLE
50420: LD_INT 1
50422: DEC
50423: ST_TO_ADDR
50424: LD_VAR 0 7
50428: PUSH
50429: FOR_TO
50430: IFFALSE 50477
// begin hc_class = 20 ;
50432: LD_ADDR_OWVAR 28
50436: PUSH
50437: LD_INT 20
50439: ST_TO_ADDR
// hc_gallery =  ;
50440: LD_ADDR_OWVAR 33
50444: PUSH
50445: LD_STRING 
50447: ST_TO_ADDR
// animal := CreateHuman ;
50448: LD_ADDR_VAR 0 12
50452: PUSH
50453: CALL_OW 44
50457: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
50458: LD_VAR 0 12
50462: PPUSH
50463: LD_VAR 0 9
50467: PPUSH
50468: LD_INT 0
50470: PPUSH
50471: CALL 52108 0 3
// end ;
50475: GO 50429
50477: POP
50478: POP
// end ;
50479: LD_VAR 0 10
50483: RET
// export function WantHeal ( sci , unit ) ; begin
50484: LD_INT 0
50486: PPUSH
// if GetTaskList ( sci ) > 0 then
50487: LD_VAR 0 1
50491: PPUSH
50492: CALL_OW 437
50496: PUSH
50497: LD_INT 0
50499: GREATER
50500: IFFALSE 50570
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
50502: LD_VAR 0 1
50506: PPUSH
50507: CALL_OW 437
50511: PUSH
50512: LD_INT 1
50514: ARRAY
50515: PUSH
50516: LD_INT 1
50518: ARRAY
50519: PUSH
50520: LD_STRING l
50522: EQUAL
50523: PUSH
50524: LD_VAR 0 1
50528: PPUSH
50529: CALL_OW 437
50533: PUSH
50534: LD_INT 1
50536: ARRAY
50537: PUSH
50538: LD_INT 4
50540: ARRAY
50541: PUSH
50542: LD_VAR 0 2
50546: EQUAL
50547: AND
50548: IFFALSE 50560
// result := true else
50550: LD_ADDR_VAR 0 3
50554: PUSH
50555: LD_INT 1
50557: ST_TO_ADDR
50558: GO 50568
// result := false ;
50560: LD_ADDR_VAR 0 3
50564: PUSH
50565: LD_INT 0
50567: ST_TO_ADDR
// end else
50568: GO 50578
// result := false ;
50570: LD_ADDR_VAR 0 3
50574: PUSH
50575: LD_INT 0
50577: ST_TO_ADDR
// end ;
50578: LD_VAR 0 3
50582: RET
// export function HealTarget ( sci ) ; begin
50583: LD_INT 0
50585: PPUSH
// if not sci then
50586: LD_VAR 0 1
50590: NOT
50591: IFFALSE 50595
// exit ;
50593: GO 50660
// result := 0 ;
50595: LD_ADDR_VAR 0 2
50599: PUSH
50600: LD_INT 0
50602: ST_TO_ADDR
// if GetTaskList ( sci ) then
50603: LD_VAR 0 1
50607: PPUSH
50608: CALL_OW 437
50612: IFFALSE 50660
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
50614: LD_VAR 0 1
50618: PPUSH
50619: CALL_OW 437
50623: PUSH
50624: LD_INT 1
50626: ARRAY
50627: PUSH
50628: LD_INT 1
50630: ARRAY
50631: PUSH
50632: LD_STRING l
50634: EQUAL
50635: IFFALSE 50660
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
50637: LD_ADDR_VAR 0 2
50641: PUSH
50642: LD_VAR 0 1
50646: PPUSH
50647: CALL_OW 437
50651: PUSH
50652: LD_INT 1
50654: ARRAY
50655: PUSH
50656: LD_INT 4
50658: ARRAY
50659: ST_TO_ADDR
// end ;
50660: LD_VAR 0 2
50664: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
50665: LD_INT 0
50667: PPUSH
50668: PPUSH
50669: PPUSH
50670: PPUSH
// if not base_units then
50671: LD_VAR 0 1
50675: NOT
50676: IFFALSE 50680
// exit ;
50678: GO 50767
// result := false ;
50680: LD_ADDR_VAR 0 2
50684: PUSH
50685: LD_INT 0
50687: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
50688: LD_ADDR_VAR 0 5
50692: PUSH
50693: LD_VAR 0 1
50697: PPUSH
50698: LD_INT 21
50700: PUSH
50701: LD_INT 3
50703: PUSH
50704: EMPTY
50705: LIST
50706: LIST
50707: PPUSH
50708: CALL_OW 72
50712: ST_TO_ADDR
// if not tmp then
50713: LD_VAR 0 5
50717: NOT
50718: IFFALSE 50722
// exit ;
50720: GO 50767
// for i in tmp do
50722: LD_ADDR_VAR 0 3
50726: PUSH
50727: LD_VAR 0 5
50731: PUSH
50732: FOR_IN
50733: IFFALSE 50765
// begin result := EnemyInRange ( i , 22 ) ;
50735: LD_ADDR_VAR 0 2
50739: PUSH
50740: LD_VAR 0 3
50744: PPUSH
50745: LD_INT 22
50747: PPUSH
50748: CALL 48354 0 2
50752: ST_TO_ADDR
// if result then
50753: LD_VAR 0 2
50757: IFFALSE 50763
// exit ;
50759: POP
50760: POP
50761: GO 50767
// end ;
50763: GO 50732
50765: POP
50766: POP
// end ;
50767: LD_VAR 0 2
50771: RET
// export function FilterByTag ( units , tag ) ; begin
50772: LD_INT 0
50774: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
50775: LD_ADDR_VAR 0 3
50779: PUSH
50780: LD_VAR 0 1
50784: PPUSH
50785: LD_INT 120
50787: PUSH
50788: LD_VAR 0 2
50792: PUSH
50793: EMPTY
50794: LIST
50795: LIST
50796: PPUSH
50797: CALL_OW 72
50801: ST_TO_ADDR
// end ;
50802: LD_VAR 0 3
50806: RET
// export function IsDriver ( un ) ; begin
50807: LD_INT 0
50809: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
50810: LD_ADDR_VAR 0 2
50814: PUSH
50815: LD_VAR 0 1
50819: PUSH
50820: LD_INT 55
50822: PUSH
50823: EMPTY
50824: LIST
50825: PPUSH
50826: CALL_OW 69
50830: IN
50831: ST_TO_ADDR
// end ;
50832: LD_VAR 0 2
50836: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
50837: LD_INT 0
50839: PPUSH
50840: PPUSH
// list := [ ] ;
50841: LD_ADDR_VAR 0 5
50845: PUSH
50846: EMPTY
50847: ST_TO_ADDR
// case d of 0 :
50848: LD_VAR 0 3
50852: PUSH
50853: LD_INT 0
50855: DOUBLE
50856: EQUAL
50857: IFTRUE 50861
50859: GO 50994
50861: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
50862: LD_ADDR_VAR 0 5
50866: PUSH
50867: LD_VAR 0 1
50871: PUSH
50872: LD_INT 4
50874: MINUS
50875: PUSH
50876: LD_VAR 0 2
50880: PUSH
50881: LD_INT 4
50883: MINUS
50884: PUSH
50885: LD_INT 2
50887: PUSH
50888: EMPTY
50889: LIST
50890: LIST
50891: LIST
50892: PUSH
50893: LD_VAR 0 1
50897: PUSH
50898: LD_INT 3
50900: MINUS
50901: PUSH
50902: LD_VAR 0 2
50906: PUSH
50907: LD_INT 1
50909: PUSH
50910: EMPTY
50911: LIST
50912: LIST
50913: LIST
50914: PUSH
50915: LD_VAR 0 1
50919: PUSH
50920: LD_INT 4
50922: PLUS
50923: PUSH
50924: LD_VAR 0 2
50928: PUSH
50929: LD_INT 4
50931: PUSH
50932: EMPTY
50933: LIST
50934: LIST
50935: LIST
50936: PUSH
50937: LD_VAR 0 1
50941: PUSH
50942: LD_INT 3
50944: PLUS
50945: PUSH
50946: LD_VAR 0 2
50950: PUSH
50951: LD_INT 3
50953: PLUS
50954: PUSH
50955: LD_INT 5
50957: PUSH
50958: EMPTY
50959: LIST
50960: LIST
50961: LIST
50962: PUSH
50963: LD_VAR 0 1
50967: PUSH
50968: LD_VAR 0 2
50972: PUSH
50973: LD_INT 4
50975: PLUS
50976: PUSH
50977: LD_INT 0
50979: PUSH
50980: EMPTY
50981: LIST
50982: LIST
50983: LIST
50984: PUSH
50985: EMPTY
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: LIST
50991: ST_TO_ADDR
// end ; 1 :
50992: GO 51692
50994: LD_INT 1
50996: DOUBLE
50997: EQUAL
50998: IFTRUE 51002
51000: GO 51135
51002: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51003: LD_ADDR_VAR 0 5
51007: PUSH
51008: LD_VAR 0 1
51012: PUSH
51013: LD_VAR 0 2
51017: PUSH
51018: LD_INT 4
51020: MINUS
51021: PUSH
51022: LD_INT 3
51024: PUSH
51025: EMPTY
51026: LIST
51027: LIST
51028: LIST
51029: PUSH
51030: LD_VAR 0 1
51034: PUSH
51035: LD_INT 3
51037: MINUS
51038: PUSH
51039: LD_VAR 0 2
51043: PUSH
51044: LD_INT 3
51046: MINUS
51047: PUSH
51048: LD_INT 2
51050: PUSH
51051: EMPTY
51052: LIST
51053: LIST
51054: LIST
51055: PUSH
51056: LD_VAR 0 1
51060: PUSH
51061: LD_INT 4
51063: MINUS
51064: PUSH
51065: LD_VAR 0 2
51069: PUSH
51070: LD_INT 1
51072: PUSH
51073: EMPTY
51074: LIST
51075: LIST
51076: LIST
51077: PUSH
51078: LD_VAR 0 1
51082: PUSH
51083: LD_VAR 0 2
51087: PUSH
51088: LD_INT 3
51090: PLUS
51091: PUSH
51092: LD_INT 0
51094: PUSH
51095: EMPTY
51096: LIST
51097: LIST
51098: LIST
51099: PUSH
51100: LD_VAR 0 1
51104: PUSH
51105: LD_INT 4
51107: PLUS
51108: PUSH
51109: LD_VAR 0 2
51113: PUSH
51114: LD_INT 4
51116: PLUS
51117: PUSH
51118: LD_INT 5
51120: PUSH
51121: EMPTY
51122: LIST
51123: LIST
51124: LIST
51125: PUSH
51126: EMPTY
51127: LIST
51128: LIST
51129: LIST
51130: LIST
51131: LIST
51132: ST_TO_ADDR
// end ; 2 :
51133: GO 51692
51135: LD_INT 2
51137: DOUBLE
51138: EQUAL
51139: IFTRUE 51143
51141: GO 51272
51143: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
51144: LD_ADDR_VAR 0 5
51148: PUSH
51149: LD_VAR 0 1
51153: PUSH
51154: LD_VAR 0 2
51158: PUSH
51159: LD_INT 3
51161: MINUS
51162: PUSH
51163: LD_INT 3
51165: PUSH
51166: EMPTY
51167: LIST
51168: LIST
51169: LIST
51170: PUSH
51171: LD_VAR 0 1
51175: PUSH
51176: LD_INT 4
51178: PLUS
51179: PUSH
51180: LD_VAR 0 2
51184: PUSH
51185: LD_INT 4
51187: PUSH
51188: EMPTY
51189: LIST
51190: LIST
51191: LIST
51192: PUSH
51193: LD_VAR 0 1
51197: PUSH
51198: LD_VAR 0 2
51202: PUSH
51203: LD_INT 4
51205: PLUS
51206: PUSH
51207: LD_INT 0
51209: PUSH
51210: EMPTY
51211: LIST
51212: LIST
51213: LIST
51214: PUSH
51215: LD_VAR 0 1
51219: PUSH
51220: LD_INT 3
51222: MINUS
51223: PUSH
51224: LD_VAR 0 2
51228: PUSH
51229: LD_INT 1
51231: PUSH
51232: EMPTY
51233: LIST
51234: LIST
51235: LIST
51236: PUSH
51237: LD_VAR 0 1
51241: PUSH
51242: LD_INT 4
51244: MINUS
51245: PUSH
51246: LD_VAR 0 2
51250: PUSH
51251: LD_INT 4
51253: MINUS
51254: PUSH
51255: LD_INT 2
51257: PUSH
51258: EMPTY
51259: LIST
51260: LIST
51261: LIST
51262: PUSH
51263: EMPTY
51264: LIST
51265: LIST
51266: LIST
51267: LIST
51268: LIST
51269: ST_TO_ADDR
// end ; 3 :
51270: GO 51692
51272: LD_INT 3
51274: DOUBLE
51275: EQUAL
51276: IFTRUE 51280
51278: GO 51413
51280: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
51281: LD_ADDR_VAR 0 5
51285: PUSH
51286: LD_VAR 0 1
51290: PUSH
51291: LD_INT 3
51293: PLUS
51294: PUSH
51295: LD_VAR 0 2
51299: PUSH
51300: LD_INT 4
51302: PUSH
51303: EMPTY
51304: LIST
51305: LIST
51306: LIST
51307: PUSH
51308: LD_VAR 0 1
51312: PUSH
51313: LD_INT 4
51315: PLUS
51316: PUSH
51317: LD_VAR 0 2
51321: PUSH
51322: LD_INT 4
51324: PLUS
51325: PUSH
51326: LD_INT 5
51328: PUSH
51329: EMPTY
51330: LIST
51331: LIST
51332: LIST
51333: PUSH
51334: LD_VAR 0 1
51338: PUSH
51339: LD_INT 4
51341: MINUS
51342: PUSH
51343: LD_VAR 0 2
51347: PUSH
51348: LD_INT 1
51350: PUSH
51351: EMPTY
51352: LIST
51353: LIST
51354: LIST
51355: PUSH
51356: LD_VAR 0 1
51360: PUSH
51361: LD_VAR 0 2
51365: PUSH
51366: LD_INT 4
51368: MINUS
51369: PUSH
51370: LD_INT 3
51372: PUSH
51373: EMPTY
51374: LIST
51375: LIST
51376: LIST
51377: PUSH
51378: LD_VAR 0 1
51382: PUSH
51383: LD_INT 3
51385: MINUS
51386: PUSH
51387: LD_VAR 0 2
51391: PUSH
51392: LD_INT 3
51394: MINUS
51395: PUSH
51396: LD_INT 2
51398: PUSH
51399: EMPTY
51400: LIST
51401: LIST
51402: LIST
51403: PUSH
51404: EMPTY
51405: LIST
51406: LIST
51407: LIST
51408: LIST
51409: LIST
51410: ST_TO_ADDR
// end ; 4 :
51411: GO 51692
51413: LD_INT 4
51415: DOUBLE
51416: EQUAL
51417: IFTRUE 51421
51419: GO 51554
51421: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
51422: LD_ADDR_VAR 0 5
51426: PUSH
51427: LD_VAR 0 1
51431: PUSH
51432: LD_VAR 0 2
51436: PUSH
51437: LD_INT 4
51439: PLUS
51440: PUSH
51441: LD_INT 0
51443: PUSH
51444: EMPTY
51445: LIST
51446: LIST
51447: LIST
51448: PUSH
51449: LD_VAR 0 1
51453: PUSH
51454: LD_INT 3
51456: PLUS
51457: PUSH
51458: LD_VAR 0 2
51462: PUSH
51463: LD_INT 3
51465: PLUS
51466: PUSH
51467: LD_INT 5
51469: PUSH
51470: EMPTY
51471: LIST
51472: LIST
51473: LIST
51474: PUSH
51475: LD_VAR 0 1
51479: PUSH
51480: LD_INT 4
51482: PLUS
51483: PUSH
51484: LD_VAR 0 2
51488: PUSH
51489: LD_INT 4
51491: PUSH
51492: EMPTY
51493: LIST
51494: LIST
51495: LIST
51496: PUSH
51497: LD_VAR 0 1
51501: PUSH
51502: LD_VAR 0 2
51506: PUSH
51507: LD_INT 3
51509: MINUS
51510: PUSH
51511: LD_INT 3
51513: PUSH
51514: EMPTY
51515: LIST
51516: LIST
51517: LIST
51518: PUSH
51519: LD_VAR 0 1
51523: PUSH
51524: LD_INT 4
51526: MINUS
51527: PUSH
51528: LD_VAR 0 2
51532: PUSH
51533: LD_INT 4
51535: MINUS
51536: PUSH
51537: LD_INT 2
51539: PUSH
51540: EMPTY
51541: LIST
51542: LIST
51543: LIST
51544: PUSH
51545: EMPTY
51546: LIST
51547: LIST
51548: LIST
51549: LIST
51550: LIST
51551: ST_TO_ADDR
// end ; 5 :
51552: GO 51692
51554: LD_INT 5
51556: DOUBLE
51557: EQUAL
51558: IFTRUE 51562
51560: GO 51691
51562: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
51563: LD_ADDR_VAR 0 5
51567: PUSH
51568: LD_VAR 0 1
51572: PUSH
51573: LD_INT 4
51575: MINUS
51576: PUSH
51577: LD_VAR 0 2
51581: PUSH
51582: LD_INT 1
51584: PUSH
51585: EMPTY
51586: LIST
51587: LIST
51588: LIST
51589: PUSH
51590: LD_VAR 0 1
51594: PUSH
51595: LD_VAR 0 2
51599: PUSH
51600: LD_INT 4
51602: MINUS
51603: PUSH
51604: LD_INT 3
51606: PUSH
51607: EMPTY
51608: LIST
51609: LIST
51610: LIST
51611: PUSH
51612: LD_VAR 0 1
51616: PUSH
51617: LD_INT 4
51619: PLUS
51620: PUSH
51621: LD_VAR 0 2
51625: PUSH
51626: LD_INT 4
51628: PLUS
51629: PUSH
51630: LD_INT 5
51632: PUSH
51633: EMPTY
51634: LIST
51635: LIST
51636: LIST
51637: PUSH
51638: LD_VAR 0 1
51642: PUSH
51643: LD_INT 3
51645: PLUS
51646: PUSH
51647: LD_VAR 0 2
51651: PUSH
51652: LD_INT 4
51654: PUSH
51655: EMPTY
51656: LIST
51657: LIST
51658: LIST
51659: PUSH
51660: LD_VAR 0 1
51664: PUSH
51665: LD_VAR 0 2
51669: PUSH
51670: LD_INT 3
51672: PLUS
51673: PUSH
51674: LD_INT 0
51676: PUSH
51677: EMPTY
51678: LIST
51679: LIST
51680: LIST
51681: PUSH
51682: EMPTY
51683: LIST
51684: LIST
51685: LIST
51686: LIST
51687: LIST
51688: ST_TO_ADDR
// end ; end ;
51689: GO 51692
51691: POP
// result := list ;
51692: LD_ADDR_VAR 0 4
51696: PUSH
51697: LD_VAR 0 5
51701: ST_TO_ADDR
// end ;
51702: LD_VAR 0 4
51706: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
51707: LD_INT 0
51709: PPUSH
51710: PPUSH
51711: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
51712: LD_VAR 0 1
51716: NOT
51717: PUSH
51718: LD_VAR 0 2
51722: PUSH
51723: LD_INT 1
51725: PUSH
51726: LD_INT 2
51728: PUSH
51729: LD_INT 3
51731: PUSH
51732: LD_INT 4
51734: PUSH
51735: EMPTY
51736: LIST
51737: LIST
51738: LIST
51739: LIST
51740: IN
51741: NOT
51742: OR
51743: IFFALSE 51747
// exit ;
51745: GO 51830
// tmp := [ ] ;
51747: LD_ADDR_VAR 0 5
51751: PUSH
51752: EMPTY
51753: ST_TO_ADDR
// for i in units do
51754: LD_ADDR_VAR 0 4
51758: PUSH
51759: LD_VAR 0 1
51763: PUSH
51764: FOR_IN
51765: IFFALSE 51799
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
51767: LD_ADDR_VAR 0 5
51771: PUSH
51772: LD_VAR 0 5
51776: PPUSH
51777: LD_VAR 0 4
51781: PPUSH
51782: LD_VAR 0 2
51786: PPUSH
51787: CALL_OW 259
51791: PPUSH
51792: CALL 53203 0 2
51796: ST_TO_ADDR
51797: GO 51764
51799: POP
51800: POP
// if not tmp then
51801: LD_VAR 0 5
51805: NOT
51806: IFFALSE 51810
// exit ;
51808: GO 51830
// result := SortListByListDesc ( units , tmp ) ;
51810: LD_ADDR_VAR 0 3
51814: PUSH
51815: LD_VAR 0 1
51819: PPUSH
51820: LD_VAR 0 5
51824: PPUSH
51825: CALL_OW 77
51829: ST_TO_ADDR
// end ;
51830: LD_VAR 0 3
51834: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
51835: LD_INT 0
51837: PPUSH
51838: PPUSH
51839: PPUSH
// result := false ;
51840: LD_ADDR_VAR 0 3
51844: PUSH
51845: LD_INT 0
51847: ST_TO_ADDR
// if not building then
51848: LD_VAR 0 2
51852: NOT
51853: IFFALSE 51857
// exit ;
51855: GO 51995
// x := GetX ( building ) ;
51857: LD_ADDR_VAR 0 4
51861: PUSH
51862: LD_VAR 0 2
51866: PPUSH
51867: CALL_OW 250
51871: ST_TO_ADDR
// y := GetY ( building ) ;
51872: LD_ADDR_VAR 0 5
51876: PUSH
51877: LD_VAR 0 2
51881: PPUSH
51882: CALL_OW 251
51886: ST_TO_ADDR
// if not x or not y then
51887: LD_VAR 0 4
51891: NOT
51892: PUSH
51893: LD_VAR 0 5
51897: NOT
51898: OR
51899: IFFALSE 51903
// exit ;
51901: GO 51995
// if GetTaskList ( unit ) then
51903: LD_VAR 0 1
51907: PPUSH
51908: CALL_OW 437
51912: IFFALSE 51995
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51914: LD_STRING e
51916: PUSH
51917: LD_VAR 0 1
51921: PPUSH
51922: CALL_OW 437
51926: PUSH
51927: LD_INT 1
51929: ARRAY
51930: PUSH
51931: LD_INT 1
51933: ARRAY
51934: EQUAL
51935: PUSH
51936: LD_VAR 0 4
51940: PUSH
51941: LD_VAR 0 1
51945: PPUSH
51946: CALL_OW 437
51950: PUSH
51951: LD_INT 1
51953: ARRAY
51954: PUSH
51955: LD_INT 2
51957: ARRAY
51958: EQUAL
51959: AND
51960: PUSH
51961: LD_VAR 0 5
51965: PUSH
51966: LD_VAR 0 1
51970: PPUSH
51971: CALL_OW 437
51975: PUSH
51976: LD_INT 1
51978: ARRAY
51979: PUSH
51980: LD_INT 3
51982: ARRAY
51983: EQUAL
51984: AND
51985: IFFALSE 51995
// result := true end ;
51987: LD_ADDR_VAR 0 3
51991: PUSH
51992: LD_INT 1
51994: ST_TO_ADDR
// end ;
51995: LD_VAR 0 3
51999: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
52000: LD_INT 0
52002: PPUSH
// result := false ;
52003: LD_ADDR_VAR 0 4
52007: PUSH
52008: LD_INT 0
52010: ST_TO_ADDR
// if GetTaskList ( unit ) then
52011: LD_VAR 0 1
52015: PPUSH
52016: CALL_OW 437
52020: IFFALSE 52103
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52022: LD_STRING M
52024: PUSH
52025: LD_VAR 0 1
52029: PPUSH
52030: CALL_OW 437
52034: PUSH
52035: LD_INT 1
52037: ARRAY
52038: PUSH
52039: LD_INT 1
52041: ARRAY
52042: EQUAL
52043: PUSH
52044: LD_VAR 0 2
52048: PUSH
52049: LD_VAR 0 1
52053: PPUSH
52054: CALL_OW 437
52058: PUSH
52059: LD_INT 1
52061: ARRAY
52062: PUSH
52063: LD_INT 2
52065: ARRAY
52066: EQUAL
52067: AND
52068: PUSH
52069: LD_VAR 0 3
52073: PUSH
52074: LD_VAR 0 1
52078: PPUSH
52079: CALL_OW 437
52083: PUSH
52084: LD_INT 1
52086: ARRAY
52087: PUSH
52088: LD_INT 3
52090: ARRAY
52091: EQUAL
52092: AND
52093: IFFALSE 52103
// result := true ;
52095: LD_ADDR_VAR 0 4
52099: PUSH
52100: LD_INT 1
52102: ST_TO_ADDR
// end ; end ;
52103: LD_VAR 0 4
52107: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
52108: LD_INT 0
52110: PPUSH
52111: PPUSH
52112: PPUSH
52113: PPUSH
// if not unit or not area then
52114: LD_VAR 0 1
52118: NOT
52119: PUSH
52120: LD_VAR 0 2
52124: NOT
52125: OR
52126: IFFALSE 52130
// exit ;
52128: GO 52306
// tmp := AreaToList ( area , i ) ;
52130: LD_ADDR_VAR 0 6
52134: PUSH
52135: LD_VAR 0 2
52139: PPUSH
52140: LD_VAR 0 5
52144: PPUSH
52145: CALL_OW 517
52149: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
52150: LD_ADDR_VAR 0 5
52154: PUSH
52155: DOUBLE
52156: LD_INT 1
52158: DEC
52159: ST_TO_ADDR
52160: LD_VAR 0 6
52164: PUSH
52165: LD_INT 1
52167: ARRAY
52168: PUSH
52169: FOR_TO
52170: IFFALSE 52304
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
52172: LD_ADDR_VAR 0 7
52176: PUSH
52177: LD_VAR 0 6
52181: PUSH
52182: LD_INT 1
52184: ARRAY
52185: PUSH
52186: LD_VAR 0 5
52190: ARRAY
52191: PUSH
52192: LD_VAR 0 6
52196: PUSH
52197: LD_INT 2
52199: ARRAY
52200: PUSH
52201: LD_VAR 0 5
52205: ARRAY
52206: PUSH
52207: EMPTY
52208: LIST
52209: LIST
52210: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
52211: LD_INT 92
52213: PUSH
52214: LD_VAR 0 7
52218: PUSH
52219: LD_INT 1
52221: ARRAY
52222: PUSH
52223: LD_VAR 0 7
52227: PUSH
52228: LD_INT 2
52230: ARRAY
52231: PUSH
52232: LD_INT 2
52234: PUSH
52235: EMPTY
52236: LIST
52237: LIST
52238: LIST
52239: LIST
52240: PPUSH
52241: CALL_OW 69
52245: PUSH
52246: LD_INT 0
52248: EQUAL
52249: IFFALSE 52302
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
52251: LD_VAR 0 1
52255: PPUSH
52256: LD_VAR 0 7
52260: PUSH
52261: LD_INT 1
52263: ARRAY
52264: PPUSH
52265: LD_VAR 0 7
52269: PUSH
52270: LD_INT 2
52272: ARRAY
52273: PPUSH
52274: LD_VAR 0 3
52278: PPUSH
52279: CALL_OW 48
// result := IsPlaced ( unit ) ;
52283: LD_ADDR_VAR 0 4
52287: PUSH
52288: LD_VAR 0 1
52292: PPUSH
52293: CALL_OW 305
52297: ST_TO_ADDR
// exit ;
52298: POP
52299: POP
52300: GO 52306
// end ; end ;
52302: GO 52169
52304: POP
52305: POP
// end ;
52306: LD_VAR 0 4
52310: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
52311: LD_INT 0
52313: PPUSH
52314: PPUSH
52315: PPUSH
// if not side or side > 8 then
52316: LD_VAR 0 1
52320: NOT
52321: PUSH
52322: LD_VAR 0 1
52326: PUSH
52327: LD_INT 8
52329: GREATER
52330: OR
52331: IFFALSE 52335
// exit ;
52333: GO 52522
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
52335: LD_ADDR_VAR 0 4
52339: PUSH
52340: LD_INT 22
52342: PUSH
52343: LD_VAR 0 1
52347: PUSH
52348: EMPTY
52349: LIST
52350: LIST
52351: PUSH
52352: LD_INT 21
52354: PUSH
52355: LD_INT 3
52357: PUSH
52358: EMPTY
52359: LIST
52360: LIST
52361: PUSH
52362: EMPTY
52363: LIST
52364: LIST
52365: PPUSH
52366: CALL_OW 69
52370: ST_TO_ADDR
// if not tmp then
52371: LD_VAR 0 4
52375: NOT
52376: IFFALSE 52380
// exit ;
52378: GO 52522
// enable_addtolog := true ;
52380: LD_ADDR_OWVAR 81
52384: PUSH
52385: LD_INT 1
52387: ST_TO_ADDR
// AddToLog ( [ ) ;
52388: LD_STRING [
52390: PPUSH
52391: CALL_OW 561
// for i in tmp do
52395: LD_ADDR_VAR 0 3
52399: PUSH
52400: LD_VAR 0 4
52404: PUSH
52405: FOR_IN
52406: IFFALSE 52513
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
52408: LD_STRING [
52410: PUSH
52411: LD_VAR 0 3
52415: PPUSH
52416: CALL_OW 266
52420: STR
52421: PUSH
52422: LD_STRING , 
52424: STR
52425: PUSH
52426: LD_VAR 0 3
52430: PPUSH
52431: CALL_OW 250
52435: STR
52436: PUSH
52437: LD_STRING , 
52439: STR
52440: PUSH
52441: LD_VAR 0 3
52445: PPUSH
52446: CALL_OW 251
52450: STR
52451: PUSH
52452: LD_STRING , 
52454: STR
52455: PUSH
52456: LD_VAR 0 3
52460: PPUSH
52461: CALL_OW 254
52465: STR
52466: PUSH
52467: LD_STRING , 
52469: STR
52470: PUSH
52471: LD_VAR 0 3
52475: PPUSH
52476: LD_INT 1
52478: PPUSH
52479: CALL_OW 268
52483: STR
52484: PUSH
52485: LD_STRING , 
52487: STR
52488: PUSH
52489: LD_VAR 0 3
52493: PPUSH
52494: LD_INT 2
52496: PPUSH
52497: CALL_OW 268
52501: STR
52502: PUSH
52503: LD_STRING ],
52505: STR
52506: PPUSH
52507: CALL_OW 561
// end ;
52511: GO 52405
52513: POP
52514: POP
// AddToLog ( ]; ) ;
52515: LD_STRING ];
52517: PPUSH
52518: CALL_OW 561
// end ;
52522: LD_VAR 0 2
52526: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
52527: LD_INT 0
52529: PPUSH
52530: PPUSH
52531: PPUSH
52532: PPUSH
52533: PPUSH
// if not area or not rate or not max then
52534: LD_VAR 0 1
52538: NOT
52539: PUSH
52540: LD_VAR 0 2
52544: NOT
52545: OR
52546: PUSH
52547: LD_VAR 0 4
52551: NOT
52552: OR
52553: IFFALSE 52557
// exit ;
52555: GO 52746
// while 1 do
52557: LD_INT 1
52559: IFFALSE 52746
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
52561: LD_ADDR_VAR 0 9
52565: PUSH
52566: LD_VAR 0 1
52570: PPUSH
52571: LD_INT 1
52573: PPUSH
52574: CALL_OW 287
52578: PUSH
52579: LD_INT 10
52581: MUL
52582: ST_TO_ADDR
// r := rate / 10 ;
52583: LD_ADDR_VAR 0 7
52587: PUSH
52588: LD_VAR 0 2
52592: PUSH
52593: LD_INT 10
52595: DIVREAL
52596: ST_TO_ADDR
// time := 1 1$00 ;
52597: LD_ADDR_VAR 0 8
52601: PUSH
52602: LD_INT 2100
52604: ST_TO_ADDR
// if amount < min then
52605: LD_VAR 0 9
52609: PUSH
52610: LD_VAR 0 3
52614: LESS
52615: IFFALSE 52633
// r := r * 2 else
52617: LD_ADDR_VAR 0 7
52621: PUSH
52622: LD_VAR 0 7
52626: PUSH
52627: LD_INT 2
52629: MUL
52630: ST_TO_ADDR
52631: GO 52659
// if amount > max then
52633: LD_VAR 0 9
52637: PUSH
52638: LD_VAR 0 4
52642: GREATER
52643: IFFALSE 52659
// r := r / 2 ;
52645: LD_ADDR_VAR 0 7
52649: PUSH
52650: LD_VAR 0 7
52654: PUSH
52655: LD_INT 2
52657: DIVREAL
52658: ST_TO_ADDR
// time := time / r ;
52659: LD_ADDR_VAR 0 8
52663: PUSH
52664: LD_VAR 0 8
52668: PUSH
52669: LD_VAR 0 7
52673: DIVREAL
52674: ST_TO_ADDR
// if time < 0 then
52675: LD_VAR 0 8
52679: PUSH
52680: LD_INT 0
52682: LESS
52683: IFFALSE 52700
// time := time * - 1 ;
52685: LD_ADDR_VAR 0 8
52689: PUSH
52690: LD_VAR 0 8
52694: PUSH
52695: LD_INT 1
52697: NEG
52698: MUL
52699: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
52700: LD_VAR 0 8
52704: PUSH
52705: LD_INT 35
52707: PPUSH
52708: LD_INT 875
52710: PPUSH
52711: CALL_OW 12
52715: PLUS
52716: PPUSH
52717: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
52721: LD_INT 1
52723: PPUSH
52724: LD_INT 5
52726: PPUSH
52727: CALL_OW 12
52731: PPUSH
52732: LD_VAR 0 1
52736: PPUSH
52737: LD_INT 1
52739: PPUSH
52740: CALL_OW 55
// end ;
52744: GO 52557
// end ;
52746: LD_VAR 0 5
52750: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
52751: LD_INT 0
52753: PPUSH
52754: PPUSH
52755: PPUSH
52756: PPUSH
52757: PPUSH
52758: PPUSH
52759: PPUSH
52760: PPUSH
// if not turrets or not factories then
52761: LD_VAR 0 1
52765: NOT
52766: PUSH
52767: LD_VAR 0 2
52771: NOT
52772: OR
52773: IFFALSE 52777
// exit ;
52775: GO 53084
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
52777: LD_ADDR_VAR 0 10
52781: PUSH
52782: LD_INT 5
52784: PUSH
52785: LD_INT 6
52787: PUSH
52788: EMPTY
52789: LIST
52790: LIST
52791: PUSH
52792: LD_INT 2
52794: PUSH
52795: LD_INT 4
52797: PUSH
52798: EMPTY
52799: LIST
52800: LIST
52801: PUSH
52802: LD_INT 3
52804: PUSH
52805: LD_INT 5
52807: PUSH
52808: EMPTY
52809: LIST
52810: LIST
52811: PUSH
52812: EMPTY
52813: LIST
52814: LIST
52815: LIST
52816: PUSH
52817: LD_INT 24
52819: PUSH
52820: LD_INT 25
52822: PUSH
52823: EMPTY
52824: LIST
52825: LIST
52826: PUSH
52827: LD_INT 23
52829: PUSH
52830: LD_INT 27
52832: PUSH
52833: EMPTY
52834: LIST
52835: LIST
52836: PUSH
52837: EMPTY
52838: LIST
52839: LIST
52840: PUSH
52841: LD_INT 42
52843: PUSH
52844: LD_INT 43
52846: PUSH
52847: EMPTY
52848: LIST
52849: LIST
52850: PUSH
52851: LD_INT 44
52853: PUSH
52854: LD_INT 46
52856: PUSH
52857: EMPTY
52858: LIST
52859: LIST
52860: PUSH
52861: LD_INT 45
52863: PUSH
52864: LD_INT 47
52866: PUSH
52867: EMPTY
52868: LIST
52869: LIST
52870: PUSH
52871: EMPTY
52872: LIST
52873: LIST
52874: LIST
52875: PUSH
52876: EMPTY
52877: LIST
52878: LIST
52879: LIST
52880: ST_TO_ADDR
// result := [ ] ;
52881: LD_ADDR_VAR 0 3
52885: PUSH
52886: EMPTY
52887: ST_TO_ADDR
// for i in turrets do
52888: LD_ADDR_VAR 0 4
52892: PUSH
52893: LD_VAR 0 1
52897: PUSH
52898: FOR_IN
52899: IFFALSE 53082
// begin nat := GetNation ( i ) ;
52901: LD_ADDR_VAR 0 7
52905: PUSH
52906: LD_VAR 0 4
52910: PPUSH
52911: CALL_OW 248
52915: ST_TO_ADDR
// weapon := 0 ;
52916: LD_ADDR_VAR 0 8
52920: PUSH
52921: LD_INT 0
52923: ST_TO_ADDR
// if not nat then
52924: LD_VAR 0 7
52928: NOT
52929: IFFALSE 52933
// continue ;
52931: GO 52898
// for j in list [ nat ] do
52933: LD_ADDR_VAR 0 5
52937: PUSH
52938: LD_VAR 0 10
52942: PUSH
52943: LD_VAR 0 7
52947: ARRAY
52948: PUSH
52949: FOR_IN
52950: IFFALSE 52991
// if GetBWeapon ( i ) = j [ 1 ] then
52952: LD_VAR 0 4
52956: PPUSH
52957: CALL_OW 269
52961: PUSH
52962: LD_VAR 0 5
52966: PUSH
52967: LD_INT 1
52969: ARRAY
52970: EQUAL
52971: IFFALSE 52989
// begin weapon := j [ 2 ] ;
52973: LD_ADDR_VAR 0 8
52977: PUSH
52978: LD_VAR 0 5
52982: PUSH
52983: LD_INT 2
52985: ARRAY
52986: ST_TO_ADDR
// break ;
52987: GO 52991
// end ;
52989: GO 52949
52991: POP
52992: POP
// if not weapon then
52993: LD_VAR 0 8
52997: NOT
52998: IFFALSE 53002
// continue ;
53000: GO 52898
// for k in factories do
53002: LD_ADDR_VAR 0 6
53006: PUSH
53007: LD_VAR 0 2
53011: PUSH
53012: FOR_IN
53013: IFFALSE 53078
// begin weapons := AvailableWeaponList ( k ) ;
53015: LD_ADDR_VAR 0 9
53019: PUSH
53020: LD_VAR 0 6
53024: PPUSH
53025: CALL_OW 478
53029: ST_TO_ADDR
// if not weapons then
53030: LD_VAR 0 9
53034: NOT
53035: IFFALSE 53039
// continue ;
53037: GO 53012
// if weapon in weapons then
53039: LD_VAR 0 8
53043: PUSH
53044: LD_VAR 0 9
53048: IN
53049: IFFALSE 53076
// begin result := [ i , weapon ] ;
53051: LD_ADDR_VAR 0 3
53055: PUSH
53056: LD_VAR 0 4
53060: PUSH
53061: LD_VAR 0 8
53065: PUSH
53066: EMPTY
53067: LIST
53068: LIST
53069: ST_TO_ADDR
// exit ;
53070: POP
53071: POP
53072: POP
53073: POP
53074: GO 53084
// end ; end ;
53076: GO 53012
53078: POP
53079: POP
// end ;
53080: GO 52898
53082: POP
53083: POP
// end ;
53084: LD_VAR 0 3
53088: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
53089: LD_INT 0
53091: PPUSH
// if not side or side > 8 then
53092: LD_VAR 0 3
53096: NOT
53097: PUSH
53098: LD_VAR 0 3
53102: PUSH
53103: LD_INT 8
53105: GREATER
53106: OR
53107: IFFALSE 53111
// exit ;
53109: GO 53170
// if not range then
53111: LD_VAR 0 4
53115: NOT
53116: IFFALSE 53127
// range := - 12 ;
53118: LD_ADDR_VAR 0 4
53122: PUSH
53123: LD_INT 12
53125: NEG
53126: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
53127: LD_VAR 0 1
53131: PPUSH
53132: LD_VAR 0 2
53136: PPUSH
53137: LD_VAR 0 3
53141: PPUSH
53142: LD_VAR 0 4
53146: PPUSH
53147: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
53151: LD_VAR 0 1
53155: PPUSH
53156: LD_VAR 0 2
53160: PPUSH
53161: LD_VAR 0 3
53165: PPUSH
53166: CALL_OW 331
// end ;
53170: LD_VAR 0 5
53174: RET
// export function Video ( mode ) ; begin
53175: LD_INT 0
53177: PPUSH
// ingame_video = mode ;
53178: LD_ADDR_OWVAR 52
53182: PUSH
53183: LD_VAR 0 1
53187: ST_TO_ADDR
// interface_hidden = mode ;
53188: LD_ADDR_OWVAR 54
53192: PUSH
53193: LD_VAR 0 1
53197: ST_TO_ADDR
// end ;
53198: LD_VAR 0 2
53202: RET
// export function Join ( array , element ) ; begin
53203: LD_INT 0
53205: PPUSH
// result := Replace ( array , array + 1 , element ) ;
53206: LD_ADDR_VAR 0 3
53210: PUSH
53211: LD_VAR 0 1
53215: PPUSH
53216: LD_VAR 0 1
53220: PUSH
53221: LD_INT 1
53223: PLUS
53224: PPUSH
53225: LD_VAR 0 2
53229: PPUSH
53230: CALL_OW 1
53234: ST_TO_ADDR
// end ;
53235: LD_VAR 0 3
53239: RET
// export function JoinUnion ( array , element ) ; begin
53240: LD_INT 0
53242: PPUSH
// result := array union element ;
53243: LD_ADDR_VAR 0 3
53247: PUSH
53248: LD_VAR 0 1
53252: PUSH
53253: LD_VAR 0 2
53257: UNION
53258: ST_TO_ADDR
// end ;
53259: LD_VAR 0 3
53263: RET
// export function GetBehemoths ( side ) ; begin
53264: LD_INT 0
53266: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
53267: LD_ADDR_VAR 0 2
53271: PUSH
53272: LD_INT 22
53274: PUSH
53275: LD_VAR 0 1
53279: PUSH
53280: EMPTY
53281: LIST
53282: LIST
53283: PUSH
53284: LD_INT 31
53286: PUSH
53287: LD_INT 25
53289: PUSH
53290: EMPTY
53291: LIST
53292: LIST
53293: PUSH
53294: EMPTY
53295: LIST
53296: LIST
53297: PPUSH
53298: CALL_OW 69
53302: ST_TO_ADDR
// end ;
53303: LD_VAR 0 2
53307: RET
// export function Shuffle ( array ) ; var i , index ; begin
53308: LD_INT 0
53310: PPUSH
53311: PPUSH
53312: PPUSH
// result := [ ] ;
53313: LD_ADDR_VAR 0 2
53317: PUSH
53318: EMPTY
53319: ST_TO_ADDR
// if not array then
53320: LD_VAR 0 1
53324: NOT
53325: IFFALSE 53329
// exit ;
53327: GO 53428
// Randomize ;
53329: CALL_OW 10
// for i = array downto 1 do
53333: LD_ADDR_VAR 0 3
53337: PUSH
53338: DOUBLE
53339: LD_VAR 0 1
53343: INC
53344: ST_TO_ADDR
53345: LD_INT 1
53347: PUSH
53348: FOR_DOWNTO
53349: IFFALSE 53426
// begin index := rand ( 1 , array ) ;
53351: LD_ADDR_VAR 0 4
53355: PUSH
53356: LD_INT 1
53358: PPUSH
53359: LD_VAR 0 1
53363: PPUSH
53364: CALL_OW 12
53368: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
53369: LD_ADDR_VAR 0 2
53373: PUSH
53374: LD_VAR 0 2
53378: PPUSH
53379: LD_VAR 0 2
53383: PUSH
53384: LD_INT 1
53386: PLUS
53387: PPUSH
53388: LD_VAR 0 1
53392: PUSH
53393: LD_VAR 0 4
53397: ARRAY
53398: PPUSH
53399: CALL_OW 2
53403: ST_TO_ADDR
// array := Delete ( array , index ) ;
53404: LD_ADDR_VAR 0 1
53408: PUSH
53409: LD_VAR 0 1
53413: PPUSH
53414: LD_VAR 0 4
53418: PPUSH
53419: CALL_OW 3
53423: ST_TO_ADDR
// end ;
53424: GO 53348
53426: POP
53427: POP
// end ;
53428: LD_VAR 0 2
53432: RET
// export function GetBaseMaterials ( base ) ; begin
53433: LD_INT 0
53435: PPUSH
// result := [ 0 , 0 , 0 ] ;
53436: LD_ADDR_VAR 0 2
53440: PUSH
53441: LD_INT 0
53443: PUSH
53444: LD_INT 0
53446: PUSH
53447: LD_INT 0
53449: PUSH
53450: EMPTY
53451: LIST
53452: LIST
53453: LIST
53454: ST_TO_ADDR
// if not base then
53455: LD_VAR 0 1
53459: NOT
53460: IFFALSE 53464
// exit ;
53462: GO 53513
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
53464: LD_ADDR_VAR 0 2
53468: PUSH
53469: LD_VAR 0 1
53473: PPUSH
53474: LD_INT 1
53476: PPUSH
53477: CALL_OW 275
53481: PUSH
53482: LD_VAR 0 1
53486: PPUSH
53487: LD_INT 2
53489: PPUSH
53490: CALL_OW 275
53494: PUSH
53495: LD_VAR 0 1
53499: PPUSH
53500: LD_INT 3
53502: PPUSH
53503: CALL_OW 275
53507: PUSH
53508: EMPTY
53509: LIST
53510: LIST
53511: LIST
53512: ST_TO_ADDR
// end ;
53513: LD_VAR 0 2
53517: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
53518: LD_INT 0
53520: PPUSH
53521: PPUSH
// result := array ;
53522: LD_ADDR_VAR 0 3
53526: PUSH
53527: LD_VAR 0 1
53531: ST_TO_ADDR
// if size >= result then
53532: LD_VAR 0 2
53536: PUSH
53537: LD_VAR 0 3
53541: GREATEREQUAL
53542: IFFALSE 53546
// exit ;
53544: GO 53596
// if size then
53546: LD_VAR 0 2
53550: IFFALSE 53596
// for i := array downto size do
53552: LD_ADDR_VAR 0 4
53556: PUSH
53557: DOUBLE
53558: LD_VAR 0 1
53562: INC
53563: ST_TO_ADDR
53564: LD_VAR 0 2
53568: PUSH
53569: FOR_DOWNTO
53570: IFFALSE 53594
// result := Delete ( result , result ) ;
53572: LD_ADDR_VAR 0 3
53576: PUSH
53577: LD_VAR 0 3
53581: PPUSH
53582: LD_VAR 0 3
53586: PPUSH
53587: CALL_OW 3
53591: ST_TO_ADDR
53592: GO 53569
53594: POP
53595: POP
// end ;
53596: LD_VAR 0 3
53600: RET
// export function ComExit ( unit ) ; var tmp ; begin
53601: LD_INT 0
53603: PPUSH
53604: PPUSH
// if not IsInUnit ( unit ) then
53605: LD_VAR 0 1
53609: PPUSH
53610: CALL_OW 310
53614: NOT
53615: IFFALSE 53619
// exit ;
53617: GO 53679
// tmp := IsInUnit ( unit ) ;
53619: LD_ADDR_VAR 0 3
53623: PUSH
53624: LD_VAR 0 1
53628: PPUSH
53629: CALL_OW 310
53633: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
53634: LD_VAR 0 3
53638: PPUSH
53639: CALL_OW 247
53643: PUSH
53644: LD_INT 2
53646: EQUAL
53647: IFFALSE 53660
// ComExitVehicle ( unit ) else
53649: LD_VAR 0 1
53653: PPUSH
53654: CALL_OW 121
53658: GO 53669
// ComExitBuilding ( unit ) ;
53660: LD_VAR 0 1
53664: PPUSH
53665: CALL_OW 122
// result := tmp ;
53669: LD_ADDR_VAR 0 2
53673: PUSH
53674: LD_VAR 0 3
53678: ST_TO_ADDR
// end ;
53679: LD_VAR 0 2
53683: RET
// export function ComExitAll ( units ) ; var i ; begin
53684: LD_INT 0
53686: PPUSH
53687: PPUSH
// if not units then
53688: LD_VAR 0 1
53692: NOT
53693: IFFALSE 53697
// exit ;
53695: GO 53723
// for i in units do
53697: LD_ADDR_VAR 0 3
53701: PUSH
53702: LD_VAR 0 1
53706: PUSH
53707: FOR_IN
53708: IFFALSE 53721
// ComExit ( i ) ;
53710: LD_VAR 0 3
53714: PPUSH
53715: CALL 53601 0 1
53719: GO 53707
53721: POP
53722: POP
// end ;
53723: LD_VAR 0 2
53727: RET
// export function ResetHc ; begin
53728: LD_INT 0
53730: PPUSH
// InitHc ;
53731: CALL_OW 19
// hc_importance := 0 ;
53735: LD_ADDR_OWVAR 32
53739: PUSH
53740: LD_INT 0
53742: ST_TO_ADDR
// end ;
53743: LD_VAR 0 1
53747: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
53748: LD_INT 0
53750: PPUSH
53751: PPUSH
53752: PPUSH
// _x := ( x1 + x2 ) div 2 ;
53753: LD_ADDR_VAR 0 6
53757: PUSH
53758: LD_VAR 0 1
53762: PUSH
53763: LD_VAR 0 3
53767: PLUS
53768: PUSH
53769: LD_INT 2
53771: DIV
53772: ST_TO_ADDR
// if _x < 0 then
53773: LD_VAR 0 6
53777: PUSH
53778: LD_INT 0
53780: LESS
53781: IFFALSE 53798
// _x := _x * - 1 ;
53783: LD_ADDR_VAR 0 6
53787: PUSH
53788: LD_VAR 0 6
53792: PUSH
53793: LD_INT 1
53795: NEG
53796: MUL
53797: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
53798: LD_ADDR_VAR 0 7
53802: PUSH
53803: LD_VAR 0 2
53807: PUSH
53808: LD_VAR 0 4
53812: PLUS
53813: PUSH
53814: LD_INT 2
53816: DIV
53817: ST_TO_ADDR
// if _y < 0 then
53818: LD_VAR 0 7
53822: PUSH
53823: LD_INT 0
53825: LESS
53826: IFFALSE 53843
// _y := _y * - 1 ;
53828: LD_ADDR_VAR 0 7
53832: PUSH
53833: LD_VAR 0 7
53837: PUSH
53838: LD_INT 1
53840: NEG
53841: MUL
53842: ST_TO_ADDR
// result := [ _x , _y ] ;
53843: LD_ADDR_VAR 0 5
53847: PUSH
53848: LD_VAR 0 6
53852: PUSH
53853: LD_VAR 0 7
53857: PUSH
53858: EMPTY
53859: LIST
53860: LIST
53861: ST_TO_ADDR
// end ;
53862: LD_VAR 0 5
53866: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
53867: LD_INT 0
53869: PPUSH
53870: PPUSH
53871: PPUSH
53872: PPUSH
// task := GetTaskList ( unit ) ;
53873: LD_ADDR_VAR 0 7
53877: PUSH
53878: LD_VAR 0 1
53882: PPUSH
53883: CALL_OW 437
53887: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
53888: LD_VAR 0 7
53892: NOT
53893: PUSH
53894: LD_VAR 0 1
53898: PPUSH
53899: LD_VAR 0 2
53903: PPUSH
53904: CALL_OW 308
53908: NOT
53909: AND
53910: IFFALSE 53914
// exit ;
53912: GO 54032
// if IsInArea ( unit , area ) then
53914: LD_VAR 0 1
53918: PPUSH
53919: LD_VAR 0 2
53923: PPUSH
53924: CALL_OW 308
53928: IFFALSE 53946
// begin ComMoveToArea ( unit , goAway ) ;
53930: LD_VAR 0 1
53934: PPUSH
53935: LD_VAR 0 3
53939: PPUSH
53940: CALL_OW 113
// exit ;
53944: GO 54032
// end ; if task [ 1 ] [ 1 ] <> M then
53946: LD_VAR 0 7
53950: PUSH
53951: LD_INT 1
53953: ARRAY
53954: PUSH
53955: LD_INT 1
53957: ARRAY
53958: PUSH
53959: LD_STRING M
53961: NONEQUAL
53962: IFFALSE 53966
// exit ;
53964: GO 54032
// x := task [ 1 ] [ 2 ] ;
53966: LD_ADDR_VAR 0 5
53970: PUSH
53971: LD_VAR 0 7
53975: PUSH
53976: LD_INT 1
53978: ARRAY
53979: PUSH
53980: LD_INT 2
53982: ARRAY
53983: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
53984: LD_ADDR_VAR 0 6
53988: PUSH
53989: LD_VAR 0 7
53993: PUSH
53994: LD_INT 1
53996: ARRAY
53997: PUSH
53998: LD_INT 3
54000: ARRAY
54001: ST_TO_ADDR
// if InArea ( x , y , area ) then
54002: LD_VAR 0 5
54006: PPUSH
54007: LD_VAR 0 6
54011: PPUSH
54012: LD_VAR 0 2
54016: PPUSH
54017: CALL_OW 309
54021: IFFALSE 54032
// ComStop ( unit ) ;
54023: LD_VAR 0 1
54027: PPUSH
54028: CALL_OW 141
// end ;
54032: LD_VAR 0 4
54036: RET
// export function Abs ( value ) ; begin
54037: LD_INT 0
54039: PPUSH
// result := value ;
54040: LD_ADDR_VAR 0 2
54044: PUSH
54045: LD_VAR 0 1
54049: ST_TO_ADDR
// if value < 0 then
54050: LD_VAR 0 1
54054: PUSH
54055: LD_INT 0
54057: LESS
54058: IFFALSE 54075
// result := value * - 1 ;
54060: LD_ADDR_VAR 0 2
54064: PUSH
54065: LD_VAR 0 1
54069: PUSH
54070: LD_INT 1
54072: NEG
54073: MUL
54074: ST_TO_ADDR
// end ;
54075: LD_VAR 0 2
54079: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
54080: LD_INT 0
54082: PPUSH
54083: PPUSH
54084: PPUSH
54085: PPUSH
54086: PPUSH
54087: PPUSH
54088: PPUSH
54089: PPUSH
// if not unit or not building then
54090: LD_VAR 0 1
54094: NOT
54095: PUSH
54096: LD_VAR 0 2
54100: NOT
54101: OR
54102: IFFALSE 54106
// exit ;
54104: GO 54332
// x := GetX ( building ) ;
54106: LD_ADDR_VAR 0 4
54110: PUSH
54111: LD_VAR 0 2
54115: PPUSH
54116: CALL_OW 250
54120: ST_TO_ADDR
// y := GetY ( building ) ;
54121: LD_ADDR_VAR 0 6
54125: PUSH
54126: LD_VAR 0 2
54130: PPUSH
54131: CALL_OW 251
54135: ST_TO_ADDR
// d := GetDir ( building ) ;
54136: LD_ADDR_VAR 0 8
54140: PUSH
54141: LD_VAR 0 2
54145: PPUSH
54146: CALL_OW 254
54150: ST_TO_ADDR
// r := 4 ;
54151: LD_ADDR_VAR 0 9
54155: PUSH
54156: LD_INT 4
54158: ST_TO_ADDR
// for i := 1 to 5 do
54159: LD_ADDR_VAR 0 10
54163: PUSH
54164: DOUBLE
54165: LD_INT 1
54167: DEC
54168: ST_TO_ADDR
54169: LD_INT 5
54171: PUSH
54172: FOR_TO
54173: IFFALSE 54330
// begin _x := ShiftX ( x , d , r + i ) ;
54175: LD_ADDR_VAR 0 5
54179: PUSH
54180: LD_VAR 0 4
54184: PPUSH
54185: LD_VAR 0 8
54189: PPUSH
54190: LD_VAR 0 9
54194: PUSH
54195: LD_VAR 0 10
54199: PLUS
54200: PPUSH
54201: CALL_OW 272
54205: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
54206: LD_ADDR_VAR 0 7
54210: PUSH
54211: LD_VAR 0 6
54215: PPUSH
54216: LD_VAR 0 8
54220: PPUSH
54221: LD_VAR 0 9
54225: PUSH
54226: LD_VAR 0 10
54230: PLUS
54231: PPUSH
54232: CALL_OW 273
54236: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
54237: LD_VAR 0 5
54241: PPUSH
54242: LD_VAR 0 7
54246: PPUSH
54247: CALL_OW 488
54251: PUSH
54252: LD_VAR 0 5
54256: PPUSH
54257: LD_VAR 0 7
54261: PPUSH
54262: CALL_OW 428
54266: PPUSH
54267: CALL_OW 247
54271: PUSH
54272: LD_INT 3
54274: PUSH
54275: LD_INT 2
54277: PUSH
54278: EMPTY
54279: LIST
54280: LIST
54281: IN
54282: NOT
54283: AND
54284: IFFALSE 54328
// begin ComMoveXY ( unit , _x , _y ) ;
54286: LD_VAR 0 1
54290: PPUSH
54291: LD_VAR 0 5
54295: PPUSH
54296: LD_VAR 0 7
54300: PPUSH
54301: CALL_OW 111
// result := [ _x , _y ] ;
54305: LD_ADDR_VAR 0 3
54309: PUSH
54310: LD_VAR 0 5
54314: PUSH
54315: LD_VAR 0 7
54319: PUSH
54320: EMPTY
54321: LIST
54322: LIST
54323: ST_TO_ADDR
// exit ;
54324: POP
54325: POP
54326: GO 54332
// end ; end ;
54328: GO 54172
54330: POP
54331: POP
// end ;
54332: LD_VAR 0 3
54336: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
54337: LD_INT 0
54339: PPUSH
54340: PPUSH
54341: PPUSH
// result := 0 ;
54342: LD_ADDR_VAR 0 3
54346: PUSH
54347: LD_INT 0
54349: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
54350: LD_VAR 0 1
54354: PUSH
54355: LD_INT 0
54357: LESS
54358: PUSH
54359: LD_VAR 0 1
54363: PUSH
54364: LD_INT 8
54366: GREATER
54367: OR
54368: PUSH
54369: LD_VAR 0 2
54373: PUSH
54374: LD_INT 0
54376: LESS
54377: OR
54378: PUSH
54379: LD_VAR 0 2
54383: PUSH
54384: LD_INT 8
54386: GREATER
54387: OR
54388: IFFALSE 54392
// exit ;
54390: GO 54467
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
54392: LD_ADDR_VAR 0 4
54396: PUSH
54397: LD_INT 22
54399: PUSH
54400: LD_VAR 0 2
54404: PUSH
54405: EMPTY
54406: LIST
54407: LIST
54408: PPUSH
54409: CALL_OW 69
54413: PUSH
54414: FOR_IN
54415: IFFALSE 54465
// begin un := UnitShoot ( i ) ;
54417: LD_ADDR_VAR 0 5
54421: PUSH
54422: LD_VAR 0 4
54426: PPUSH
54427: CALL_OW 504
54431: ST_TO_ADDR
// if GetSide ( un ) = side1 then
54432: LD_VAR 0 5
54436: PPUSH
54437: CALL_OW 255
54441: PUSH
54442: LD_VAR 0 1
54446: EQUAL
54447: IFFALSE 54463
// begin result := un ;
54449: LD_ADDR_VAR 0 3
54453: PUSH
54454: LD_VAR 0 5
54458: ST_TO_ADDR
// exit ;
54459: POP
54460: POP
54461: GO 54467
// end ; end ;
54463: GO 54414
54465: POP
54466: POP
// end ;
54467: LD_VAR 0 3
54471: RET
// export function GetCargoBay ( units ) ; begin
54472: LD_INT 0
54474: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
54475: LD_ADDR_VAR 0 2
54479: PUSH
54480: LD_VAR 0 1
54484: PPUSH
54485: LD_INT 2
54487: PUSH
54488: LD_INT 34
54490: PUSH
54491: LD_INT 12
54493: PUSH
54494: EMPTY
54495: LIST
54496: LIST
54497: PUSH
54498: LD_INT 34
54500: PUSH
54501: LD_INT 51
54503: PUSH
54504: EMPTY
54505: LIST
54506: LIST
54507: PUSH
54508: LD_INT 34
54510: PUSH
54511: LD_INT 32
54513: PUSH
54514: EMPTY
54515: LIST
54516: LIST
54517: PUSH
54518: LD_INT 34
54520: PUSH
54521: LD_INT 89
54523: PUSH
54524: EMPTY
54525: LIST
54526: LIST
54527: PUSH
54528: EMPTY
54529: LIST
54530: LIST
54531: LIST
54532: LIST
54533: LIST
54534: PPUSH
54535: CALL_OW 72
54539: ST_TO_ADDR
// end ;
54540: LD_VAR 0 2
54544: RET
// export function Negate ( value ) ; begin
54545: LD_INT 0
54547: PPUSH
// result := not value ;
54548: LD_ADDR_VAR 0 2
54552: PUSH
54553: LD_VAR 0 1
54557: NOT
54558: ST_TO_ADDR
// end ;
54559: LD_VAR 0 2
54563: RET
// export function Inc ( value ) ; begin
54564: LD_INT 0
54566: PPUSH
// result := value + 1 ;
54567: LD_ADDR_VAR 0 2
54571: PUSH
54572: LD_VAR 0 1
54576: PUSH
54577: LD_INT 1
54579: PLUS
54580: ST_TO_ADDR
// end ;
54581: LD_VAR 0 2
54585: RET
// export function Dec ( value ) ; begin
54586: LD_INT 0
54588: PPUSH
// result := value - 1 ;
54589: LD_ADDR_VAR 0 2
54593: PUSH
54594: LD_VAR 0 1
54598: PUSH
54599: LD_INT 1
54601: MINUS
54602: ST_TO_ADDR
// end ;
54603: LD_VAR 0 2
54607: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
54608: LD_INT 0
54610: PPUSH
54611: PPUSH
54612: PPUSH
54613: PPUSH
54614: PPUSH
54615: PPUSH
54616: PPUSH
54617: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
54618: LD_VAR 0 1
54622: PPUSH
54623: LD_VAR 0 2
54627: PPUSH
54628: CALL_OW 488
54632: NOT
54633: PUSH
54634: LD_VAR 0 3
54638: PPUSH
54639: LD_VAR 0 4
54643: PPUSH
54644: CALL_OW 488
54648: NOT
54649: OR
54650: IFFALSE 54663
// begin result := - 1 ;
54652: LD_ADDR_VAR 0 5
54656: PUSH
54657: LD_INT 1
54659: NEG
54660: ST_TO_ADDR
// exit ;
54661: GO 54898
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
54663: LD_ADDR_VAR 0 12
54667: PUSH
54668: LD_VAR 0 1
54672: PPUSH
54673: LD_VAR 0 2
54677: PPUSH
54678: LD_VAR 0 3
54682: PPUSH
54683: LD_VAR 0 4
54687: PPUSH
54688: CALL 53748 0 4
54692: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
54693: LD_ADDR_VAR 0 11
54697: PUSH
54698: LD_VAR 0 1
54702: PPUSH
54703: LD_VAR 0 2
54707: PPUSH
54708: LD_VAR 0 12
54712: PUSH
54713: LD_INT 1
54715: ARRAY
54716: PPUSH
54717: LD_VAR 0 12
54721: PUSH
54722: LD_INT 2
54724: ARRAY
54725: PPUSH
54726: CALL_OW 298
54730: ST_TO_ADDR
// distance := 9999 ;
54731: LD_ADDR_VAR 0 10
54735: PUSH
54736: LD_INT 9999
54738: ST_TO_ADDR
// for i := 0 to 5 do
54739: LD_ADDR_VAR 0 6
54743: PUSH
54744: DOUBLE
54745: LD_INT 0
54747: DEC
54748: ST_TO_ADDR
54749: LD_INT 5
54751: PUSH
54752: FOR_TO
54753: IFFALSE 54896
// begin _x := ShiftX ( x1 , i , centerDist ) ;
54755: LD_ADDR_VAR 0 7
54759: PUSH
54760: LD_VAR 0 1
54764: PPUSH
54765: LD_VAR 0 6
54769: PPUSH
54770: LD_VAR 0 11
54774: PPUSH
54775: CALL_OW 272
54779: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
54780: LD_ADDR_VAR 0 8
54784: PUSH
54785: LD_VAR 0 2
54789: PPUSH
54790: LD_VAR 0 6
54794: PPUSH
54795: LD_VAR 0 11
54799: PPUSH
54800: CALL_OW 273
54804: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54805: LD_VAR 0 7
54809: PPUSH
54810: LD_VAR 0 8
54814: PPUSH
54815: CALL_OW 488
54819: NOT
54820: IFFALSE 54824
// continue ;
54822: GO 54752
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
54824: LD_ADDR_VAR 0 9
54828: PUSH
54829: LD_VAR 0 12
54833: PUSH
54834: LD_INT 1
54836: ARRAY
54837: PPUSH
54838: LD_VAR 0 12
54842: PUSH
54843: LD_INT 2
54845: ARRAY
54846: PPUSH
54847: LD_VAR 0 7
54851: PPUSH
54852: LD_VAR 0 8
54856: PPUSH
54857: CALL_OW 298
54861: ST_TO_ADDR
// if tmp < distance then
54862: LD_VAR 0 9
54866: PUSH
54867: LD_VAR 0 10
54871: LESS
54872: IFFALSE 54894
// begin result := i ;
54874: LD_ADDR_VAR 0 5
54878: PUSH
54879: LD_VAR 0 6
54883: ST_TO_ADDR
// distance := tmp ;
54884: LD_ADDR_VAR 0 10
54888: PUSH
54889: LD_VAR 0 9
54893: ST_TO_ADDR
// end ; end ;
54894: GO 54752
54896: POP
54897: POP
// end ;
54898: LD_VAR 0 5
54902: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54903: LD_INT 0
54905: PPUSH
54906: PPUSH
// if not driver or not IsInUnit ( driver ) then
54907: LD_VAR 0 1
54911: NOT
54912: PUSH
54913: LD_VAR 0 1
54917: PPUSH
54918: CALL_OW 310
54922: NOT
54923: OR
54924: IFFALSE 54928
// exit ;
54926: GO 55018
// vehicle := IsInUnit ( driver ) ;
54928: LD_ADDR_VAR 0 3
54932: PUSH
54933: LD_VAR 0 1
54937: PPUSH
54938: CALL_OW 310
54942: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54943: LD_VAR 0 1
54947: PPUSH
54948: LD_STRING \
54950: PUSH
54951: LD_INT 0
54953: PUSH
54954: LD_INT 0
54956: PUSH
54957: LD_INT 0
54959: PUSH
54960: LD_INT 0
54962: PUSH
54963: LD_INT 0
54965: PUSH
54966: LD_INT 0
54968: PUSH
54969: EMPTY
54970: LIST
54971: LIST
54972: LIST
54973: LIST
54974: LIST
54975: LIST
54976: LIST
54977: PUSH
54978: LD_STRING E
54980: PUSH
54981: LD_INT 0
54983: PUSH
54984: LD_INT 0
54986: PUSH
54987: LD_VAR 0 3
54991: PUSH
54992: LD_INT 0
54994: PUSH
54995: LD_INT 0
54997: PUSH
54998: LD_INT 0
55000: PUSH
55001: EMPTY
55002: LIST
55003: LIST
55004: LIST
55005: LIST
55006: LIST
55007: LIST
55008: LIST
55009: PUSH
55010: EMPTY
55011: LIST
55012: LIST
55013: PPUSH
55014: CALL_OW 446
// end ;
55018: LD_VAR 0 2
55022: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
55023: LD_INT 0
55025: PPUSH
55026: PPUSH
// if not driver or not IsInUnit ( driver ) then
55027: LD_VAR 0 1
55031: NOT
55032: PUSH
55033: LD_VAR 0 1
55037: PPUSH
55038: CALL_OW 310
55042: NOT
55043: OR
55044: IFFALSE 55048
// exit ;
55046: GO 55138
// vehicle := IsInUnit ( driver ) ;
55048: LD_ADDR_VAR 0 3
55052: PUSH
55053: LD_VAR 0 1
55057: PPUSH
55058: CALL_OW 310
55062: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
55063: LD_VAR 0 1
55067: PPUSH
55068: LD_STRING \
55070: PUSH
55071: LD_INT 0
55073: PUSH
55074: LD_INT 0
55076: PUSH
55077: LD_INT 0
55079: PUSH
55080: LD_INT 0
55082: PUSH
55083: LD_INT 0
55085: PUSH
55086: LD_INT 0
55088: PUSH
55089: EMPTY
55090: LIST
55091: LIST
55092: LIST
55093: LIST
55094: LIST
55095: LIST
55096: LIST
55097: PUSH
55098: LD_STRING E
55100: PUSH
55101: LD_INT 0
55103: PUSH
55104: LD_INT 0
55106: PUSH
55107: LD_VAR 0 3
55111: PUSH
55112: LD_INT 0
55114: PUSH
55115: LD_INT 0
55117: PUSH
55118: LD_INT 0
55120: PUSH
55121: EMPTY
55122: LIST
55123: LIST
55124: LIST
55125: LIST
55126: LIST
55127: LIST
55128: LIST
55129: PUSH
55130: EMPTY
55131: LIST
55132: LIST
55133: PPUSH
55134: CALL_OW 447
// end ;
55138: LD_VAR 0 2
55142: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
55143: LD_INT 0
55145: PPUSH
55146: PPUSH
55147: PPUSH
// tmp := [ ] ;
55148: LD_ADDR_VAR 0 5
55152: PUSH
55153: EMPTY
55154: ST_TO_ADDR
// for i in units do
55155: LD_ADDR_VAR 0 4
55159: PUSH
55160: LD_VAR 0 1
55164: PUSH
55165: FOR_IN
55166: IFFALSE 55204
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
55168: LD_ADDR_VAR 0 5
55172: PUSH
55173: LD_VAR 0 5
55177: PPUSH
55178: LD_VAR 0 5
55182: PUSH
55183: LD_INT 1
55185: PLUS
55186: PPUSH
55187: LD_VAR 0 4
55191: PPUSH
55192: CALL_OW 256
55196: PPUSH
55197: CALL_OW 2
55201: ST_TO_ADDR
55202: GO 55165
55204: POP
55205: POP
// if not tmp then
55206: LD_VAR 0 5
55210: NOT
55211: IFFALSE 55215
// exit ;
55213: GO 55263
// if asc then
55215: LD_VAR 0 2
55219: IFFALSE 55243
// result := SortListByListAsc ( units , tmp ) else
55221: LD_ADDR_VAR 0 3
55225: PUSH
55226: LD_VAR 0 1
55230: PPUSH
55231: LD_VAR 0 5
55235: PPUSH
55236: CALL_OW 76
55240: ST_TO_ADDR
55241: GO 55263
// result := SortListByListDesc ( units , tmp ) ;
55243: LD_ADDR_VAR 0 3
55247: PUSH
55248: LD_VAR 0 1
55252: PPUSH
55253: LD_VAR 0 5
55257: PPUSH
55258: CALL_OW 77
55262: ST_TO_ADDR
// end ;
55263: LD_VAR 0 3
55267: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
55268: LD_INT 0
55270: PPUSH
55271: PPUSH
// task := GetTaskList ( mech ) ;
55272: LD_ADDR_VAR 0 4
55276: PUSH
55277: LD_VAR 0 1
55281: PPUSH
55282: CALL_OW 437
55286: ST_TO_ADDR
// if not task then
55287: LD_VAR 0 4
55291: NOT
55292: IFFALSE 55296
// exit ;
55294: GO 55338
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
55296: LD_ADDR_VAR 0 3
55300: PUSH
55301: LD_VAR 0 4
55305: PUSH
55306: LD_INT 1
55308: ARRAY
55309: PUSH
55310: LD_INT 1
55312: ARRAY
55313: PUSH
55314: LD_STRING r
55316: EQUAL
55317: PUSH
55318: LD_VAR 0 4
55322: PUSH
55323: LD_INT 1
55325: ARRAY
55326: PUSH
55327: LD_INT 4
55329: ARRAY
55330: PUSH
55331: LD_VAR 0 2
55335: EQUAL
55336: AND
55337: ST_TO_ADDR
// end ;
55338: LD_VAR 0 3
55342: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
55343: LD_INT 0
55345: PPUSH
// SetDir ( unit , d ) ;
55346: LD_VAR 0 1
55350: PPUSH
55351: LD_VAR 0 4
55355: PPUSH
55356: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
55360: LD_VAR 0 1
55364: PPUSH
55365: LD_VAR 0 2
55369: PPUSH
55370: LD_VAR 0 3
55374: PPUSH
55375: LD_VAR 0 5
55379: PPUSH
55380: CALL_OW 48
// end ;
55384: LD_VAR 0 6
55388: RET
// export function ToNaturalNumber ( number ) ; begin
55389: LD_INT 0
55391: PPUSH
// result := number div 1 ;
55392: LD_ADDR_VAR 0 2
55396: PUSH
55397: LD_VAR 0 1
55401: PUSH
55402: LD_INT 1
55404: DIV
55405: ST_TO_ADDR
// if number < 0 then
55406: LD_VAR 0 1
55410: PUSH
55411: LD_INT 0
55413: LESS
55414: IFFALSE 55424
// result := 0 ;
55416: LD_ADDR_VAR 0 2
55420: PUSH
55421: LD_INT 0
55423: ST_TO_ADDR
// end ;
55424: LD_VAR 0 2
55428: RET
// export function SortByClass ( units , class ) ; var un ; begin
55429: LD_INT 0
55431: PPUSH
55432: PPUSH
// if not units or not class then
55433: LD_VAR 0 1
55437: NOT
55438: PUSH
55439: LD_VAR 0 2
55443: NOT
55444: OR
55445: IFFALSE 55449
// exit ;
55447: GO 55544
// result := [ ] ;
55449: LD_ADDR_VAR 0 3
55453: PUSH
55454: EMPTY
55455: ST_TO_ADDR
// for un in units do
55456: LD_ADDR_VAR 0 4
55460: PUSH
55461: LD_VAR 0 1
55465: PUSH
55466: FOR_IN
55467: IFFALSE 55542
// if GetClass ( un ) = class then
55469: LD_VAR 0 4
55473: PPUSH
55474: CALL_OW 257
55478: PUSH
55479: LD_VAR 0 2
55483: EQUAL
55484: IFFALSE 55511
// result := Insert ( result , 1 , un ) else
55486: LD_ADDR_VAR 0 3
55490: PUSH
55491: LD_VAR 0 3
55495: PPUSH
55496: LD_INT 1
55498: PPUSH
55499: LD_VAR 0 4
55503: PPUSH
55504: CALL_OW 2
55508: ST_TO_ADDR
55509: GO 55540
// result := Replace ( result , result + 1 , un ) ;
55511: LD_ADDR_VAR 0 3
55515: PUSH
55516: LD_VAR 0 3
55520: PPUSH
55521: LD_VAR 0 3
55525: PUSH
55526: LD_INT 1
55528: PLUS
55529: PPUSH
55530: LD_VAR 0 4
55534: PPUSH
55535: CALL_OW 1
55539: ST_TO_ADDR
55540: GO 55466
55542: POP
55543: POP
// end ;
55544: LD_VAR 0 3
55548: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
55549: LD_INT 0
55551: PPUSH
55552: PPUSH
55553: PPUSH
55554: PPUSH
55555: PPUSH
55556: PPUSH
55557: PPUSH
// result := [ ] ;
55558: LD_ADDR_VAR 0 4
55562: PUSH
55563: EMPTY
55564: ST_TO_ADDR
// if x - r < 0 then
55565: LD_VAR 0 1
55569: PUSH
55570: LD_VAR 0 3
55574: MINUS
55575: PUSH
55576: LD_INT 0
55578: LESS
55579: IFFALSE 55591
// min_x := 0 else
55581: LD_ADDR_VAR 0 8
55585: PUSH
55586: LD_INT 0
55588: ST_TO_ADDR
55589: GO 55607
// min_x := x - r ;
55591: LD_ADDR_VAR 0 8
55595: PUSH
55596: LD_VAR 0 1
55600: PUSH
55601: LD_VAR 0 3
55605: MINUS
55606: ST_TO_ADDR
// if y - r < 0 then
55607: LD_VAR 0 2
55611: PUSH
55612: LD_VAR 0 3
55616: MINUS
55617: PUSH
55618: LD_INT 0
55620: LESS
55621: IFFALSE 55633
// min_y := 0 else
55623: LD_ADDR_VAR 0 7
55627: PUSH
55628: LD_INT 0
55630: ST_TO_ADDR
55631: GO 55649
// min_y := y - r ;
55633: LD_ADDR_VAR 0 7
55637: PUSH
55638: LD_VAR 0 2
55642: PUSH
55643: LD_VAR 0 3
55647: MINUS
55648: ST_TO_ADDR
// max_x := x + r ;
55649: LD_ADDR_VAR 0 9
55653: PUSH
55654: LD_VAR 0 1
55658: PUSH
55659: LD_VAR 0 3
55663: PLUS
55664: ST_TO_ADDR
// max_y := y + r ;
55665: LD_ADDR_VAR 0 10
55669: PUSH
55670: LD_VAR 0 2
55674: PUSH
55675: LD_VAR 0 3
55679: PLUS
55680: ST_TO_ADDR
// for _x = min_x to max_x do
55681: LD_ADDR_VAR 0 5
55685: PUSH
55686: DOUBLE
55687: LD_VAR 0 8
55691: DEC
55692: ST_TO_ADDR
55693: LD_VAR 0 9
55697: PUSH
55698: FOR_TO
55699: IFFALSE 55800
// for _y = min_y to max_y do
55701: LD_ADDR_VAR 0 6
55705: PUSH
55706: DOUBLE
55707: LD_VAR 0 7
55711: DEC
55712: ST_TO_ADDR
55713: LD_VAR 0 10
55717: PUSH
55718: FOR_TO
55719: IFFALSE 55796
// begin if not ValidHex ( _x , _y ) then
55721: LD_VAR 0 5
55725: PPUSH
55726: LD_VAR 0 6
55730: PPUSH
55731: CALL_OW 488
55735: NOT
55736: IFFALSE 55740
// continue ;
55738: GO 55718
// if GetResourceTypeXY ( _x , _y ) then
55740: LD_VAR 0 5
55744: PPUSH
55745: LD_VAR 0 6
55749: PPUSH
55750: CALL_OW 283
55754: IFFALSE 55794
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
55756: LD_ADDR_VAR 0 4
55760: PUSH
55761: LD_VAR 0 4
55765: PPUSH
55766: LD_VAR 0 4
55770: PUSH
55771: LD_INT 1
55773: PLUS
55774: PPUSH
55775: LD_VAR 0 5
55779: PUSH
55780: LD_VAR 0 6
55784: PUSH
55785: EMPTY
55786: LIST
55787: LIST
55788: PPUSH
55789: CALL_OW 1
55793: ST_TO_ADDR
// end ;
55794: GO 55718
55796: POP
55797: POP
55798: GO 55698
55800: POP
55801: POP
// end ;
55802: LD_VAR 0 4
55806: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
55807: LD_INT 0
55809: PPUSH
55810: PPUSH
55811: PPUSH
55812: PPUSH
55813: PPUSH
55814: PPUSH
55815: PPUSH
55816: PPUSH
// if not units then
55817: LD_VAR 0 1
55821: NOT
55822: IFFALSE 55826
// exit ;
55824: GO 56350
// result := UnitFilter ( units , [ f_ok ] ) ;
55826: LD_ADDR_VAR 0 3
55830: PUSH
55831: LD_VAR 0 1
55835: PPUSH
55836: LD_INT 50
55838: PUSH
55839: EMPTY
55840: LIST
55841: PPUSH
55842: CALL_OW 72
55846: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
55847: LD_ADDR_VAR 0 8
55851: PUSH
55852: LD_VAR 0 1
55856: PUSH
55857: LD_INT 1
55859: ARRAY
55860: PPUSH
55861: CALL_OW 255
55865: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
55866: LD_ADDR_VAR 0 10
55870: PUSH
55871: LD_INT 29
55873: PUSH
55874: LD_INT 91
55876: PUSH
55877: LD_INT 49
55879: PUSH
55880: EMPTY
55881: LIST
55882: LIST
55883: LIST
55884: ST_TO_ADDR
// if not result then
55885: LD_VAR 0 3
55889: NOT
55890: IFFALSE 55894
// exit ;
55892: GO 56350
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
55894: LD_ADDR_VAR 0 5
55898: PUSH
55899: LD_INT 81
55901: PUSH
55902: LD_VAR 0 8
55906: PUSH
55907: EMPTY
55908: LIST
55909: LIST
55910: PPUSH
55911: CALL_OW 69
55915: ST_TO_ADDR
// for i in result do
55916: LD_ADDR_VAR 0 4
55920: PUSH
55921: LD_VAR 0 3
55925: PUSH
55926: FOR_IN
55927: IFFALSE 56348
// begin tag := GetTag ( i ) + 1 ;
55929: LD_ADDR_VAR 0 9
55933: PUSH
55934: LD_VAR 0 4
55938: PPUSH
55939: CALL_OW 110
55943: PUSH
55944: LD_INT 1
55946: PLUS
55947: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
55948: LD_ADDR_VAR 0 7
55952: PUSH
55953: LD_VAR 0 4
55957: PPUSH
55958: CALL_OW 250
55962: PPUSH
55963: LD_VAR 0 4
55967: PPUSH
55968: CALL_OW 251
55972: PPUSH
55973: LD_INT 6
55975: PPUSH
55976: CALL 55549 0 3
55980: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
55981: LD_VAR 0 4
55985: PPUSH
55986: CALL_OW 247
55990: PUSH
55991: LD_INT 2
55993: EQUAL
55994: PUSH
55995: LD_VAR 0 7
55999: AND
56000: PUSH
56001: LD_VAR 0 4
56005: PPUSH
56006: CALL_OW 264
56010: PUSH
56011: LD_VAR 0 10
56015: IN
56016: NOT
56017: AND
56018: IFFALSE 56057
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
56020: LD_VAR 0 4
56024: PPUSH
56025: LD_VAR 0 7
56029: PUSH
56030: LD_INT 1
56032: ARRAY
56033: PUSH
56034: LD_INT 1
56036: ARRAY
56037: PPUSH
56038: LD_VAR 0 7
56042: PUSH
56043: LD_INT 1
56045: ARRAY
56046: PUSH
56047: LD_INT 2
56049: ARRAY
56050: PPUSH
56051: CALL_OW 116
56055: GO 56346
// if path > tag then
56057: LD_VAR 0 2
56061: PUSH
56062: LD_VAR 0 9
56066: GREATER
56067: IFFALSE 56275
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
56069: LD_ADDR_VAR 0 6
56073: PUSH
56074: LD_VAR 0 5
56078: PPUSH
56079: LD_INT 91
56081: PUSH
56082: LD_VAR 0 4
56086: PUSH
56087: LD_INT 8
56089: PUSH
56090: EMPTY
56091: LIST
56092: LIST
56093: LIST
56094: PPUSH
56095: CALL_OW 72
56099: ST_TO_ADDR
// if nearEnemy then
56100: LD_VAR 0 6
56104: IFFALSE 56173
// begin if GetWeapon ( i ) = ru_time_lapser then
56106: LD_VAR 0 4
56110: PPUSH
56111: CALL_OW 264
56115: PUSH
56116: LD_INT 49
56118: EQUAL
56119: IFFALSE 56147
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
56121: LD_VAR 0 4
56125: PPUSH
56126: LD_VAR 0 6
56130: PPUSH
56131: LD_VAR 0 4
56135: PPUSH
56136: CALL_OW 74
56140: PPUSH
56141: CALL_OW 112
56145: GO 56171
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
56147: LD_VAR 0 4
56151: PPUSH
56152: LD_VAR 0 6
56156: PPUSH
56157: LD_VAR 0 4
56161: PPUSH
56162: CALL_OW 74
56166: PPUSH
56167: CALL 57275 0 2
// end else
56171: GO 56273
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
56173: LD_VAR 0 4
56177: PPUSH
56178: LD_VAR 0 2
56182: PUSH
56183: LD_VAR 0 9
56187: ARRAY
56188: PUSH
56189: LD_INT 1
56191: ARRAY
56192: PPUSH
56193: LD_VAR 0 2
56197: PUSH
56198: LD_VAR 0 9
56202: ARRAY
56203: PUSH
56204: LD_INT 2
56206: ARRAY
56207: PPUSH
56208: CALL_OW 297
56212: PUSH
56213: LD_INT 6
56215: GREATER
56216: IFFALSE 56259
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
56218: LD_VAR 0 4
56222: PPUSH
56223: LD_VAR 0 2
56227: PUSH
56228: LD_VAR 0 9
56232: ARRAY
56233: PUSH
56234: LD_INT 1
56236: ARRAY
56237: PPUSH
56238: LD_VAR 0 2
56242: PUSH
56243: LD_VAR 0 9
56247: ARRAY
56248: PUSH
56249: LD_INT 2
56251: ARRAY
56252: PPUSH
56253: CALL_OW 114
56257: GO 56273
// SetTag ( i , tag ) ;
56259: LD_VAR 0 4
56263: PPUSH
56264: LD_VAR 0 9
56268: PPUSH
56269: CALL_OW 109
// end else
56273: GO 56346
// if enemy then
56275: LD_VAR 0 5
56279: IFFALSE 56346
// begin if GetWeapon ( i ) = ru_time_lapser then
56281: LD_VAR 0 4
56285: PPUSH
56286: CALL_OW 264
56290: PUSH
56291: LD_INT 49
56293: EQUAL
56294: IFFALSE 56322
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
56296: LD_VAR 0 4
56300: PPUSH
56301: LD_VAR 0 5
56305: PPUSH
56306: LD_VAR 0 4
56310: PPUSH
56311: CALL_OW 74
56315: PPUSH
56316: CALL_OW 112
56320: GO 56346
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
56322: LD_VAR 0 4
56326: PPUSH
56327: LD_VAR 0 5
56331: PPUSH
56332: LD_VAR 0 4
56336: PPUSH
56337: CALL_OW 74
56341: PPUSH
56342: CALL 57275 0 2
// end ; end ;
56346: GO 55926
56348: POP
56349: POP
// end ;
56350: LD_VAR 0 3
56354: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
56355: LD_INT 0
56357: PPUSH
56358: PPUSH
56359: PPUSH
// if not unit or IsInUnit ( unit ) then
56360: LD_VAR 0 1
56364: NOT
56365: PUSH
56366: LD_VAR 0 1
56370: PPUSH
56371: CALL_OW 310
56375: OR
56376: IFFALSE 56380
// exit ;
56378: GO 56471
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
56380: LD_ADDR_VAR 0 4
56384: PUSH
56385: LD_VAR 0 1
56389: PPUSH
56390: CALL_OW 250
56394: PPUSH
56395: LD_VAR 0 2
56399: PPUSH
56400: LD_INT 1
56402: PPUSH
56403: CALL_OW 272
56407: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
56408: LD_ADDR_VAR 0 5
56412: PUSH
56413: LD_VAR 0 1
56417: PPUSH
56418: CALL_OW 251
56422: PPUSH
56423: LD_VAR 0 2
56427: PPUSH
56428: LD_INT 1
56430: PPUSH
56431: CALL_OW 273
56435: ST_TO_ADDR
// if ValidHex ( x , y ) then
56436: LD_VAR 0 4
56440: PPUSH
56441: LD_VAR 0 5
56445: PPUSH
56446: CALL_OW 488
56450: IFFALSE 56471
// ComTurnXY ( unit , x , y ) ;
56452: LD_VAR 0 1
56456: PPUSH
56457: LD_VAR 0 4
56461: PPUSH
56462: LD_VAR 0 5
56466: PPUSH
56467: CALL_OW 118
// end ;
56471: LD_VAR 0 3
56475: RET
// export function SeeUnits ( side , units ) ; var i ; begin
56476: LD_INT 0
56478: PPUSH
56479: PPUSH
// result := false ;
56480: LD_ADDR_VAR 0 3
56484: PUSH
56485: LD_INT 0
56487: ST_TO_ADDR
// if not units then
56488: LD_VAR 0 2
56492: NOT
56493: IFFALSE 56497
// exit ;
56495: GO 56542
// for i in units do
56497: LD_ADDR_VAR 0 4
56501: PUSH
56502: LD_VAR 0 2
56506: PUSH
56507: FOR_IN
56508: IFFALSE 56540
// if See ( side , i ) then
56510: LD_VAR 0 1
56514: PPUSH
56515: LD_VAR 0 4
56519: PPUSH
56520: CALL_OW 292
56524: IFFALSE 56538
// begin result := true ;
56526: LD_ADDR_VAR 0 3
56530: PUSH
56531: LD_INT 1
56533: ST_TO_ADDR
// exit ;
56534: POP
56535: POP
56536: GO 56542
// end ;
56538: GO 56507
56540: POP
56541: POP
// end ;
56542: LD_VAR 0 3
56546: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
56547: LD_INT 0
56549: PPUSH
56550: PPUSH
56551: PPUSH
56552: PPUSH
// if not unit or not points then
56553: LD_VAR 0 1
56557: NOT
56558: PUSH
56559: LD_VAR 0 2
56563: NOT
56564: OR
56565: IFFALSE 56569
// exit ;
56567: GO 56659
// dist := 99999 ;
56569: LD_ADDR_VAR 0 5
56573: PUSH
56574: LD_INT 99999
56576: ST_TO_ADDR
// for i in points do
56577: LD_ADDR_VAR 0 4
56581: PUSH
56582: LD_VAR 0 2
56586: PUSH
56587: FOR_IN
56588: IFFALSE 56657
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
56590: LD_ADDR_VAR 0 6
56594: PUSH
56595: LD_VAR 0 1
56599: PPUSH
56600: LD_VAR 0 4
56604: PUSH
56605: LD_INT 1
56607: ARRAY
56608: PPUSH
56609: LD_VAR 0 4
56613: PUSH
56614: LD_INT 2
56616: ARRAY
56617: PPUSH
56618: CALL_OW 297
56622: ST_TO_ADDR
// if tmpDist < dist then
56623: LD_VAR 0 6
56627: PUSH
56628: LD_VAR 0 5
56632: LESS
56633: IFFALSE 56655
// begin result := i ;
56635: LD_ADDR_VAR 0 3
56639: PUSH
56640: LD_VAR 0 4
56644: ST_TO_ADDR
// dist := tmpDist ;
56645: LD_ADDR_VAR 0 5
56649: PUSH
56650: LD_VAR 0 6
56654: ST_TO_ADDR
// end ; end ;
56655: GO 56587
56657: POP
56658: POP
// end ;
56659: LD_VAR 0 3
56663: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
56664: LD_INT 0
56666: PPUSH
// uc_side := side ;
56667: LD_ADDR_OWVAR 20
56671: PUSH
56672: LD_VAR 0 1
56676: ST_TO_ADDR
// uc_nation := 3 ;
56677: LD_ADDR_OWVAR 21
56681: PUSH
56682: LD_INT 3
56684: ST_TO_ADDR
// vc_chassis := 25 ;
56685: LD_ADDR_OWVAR 37
56689: PUSH
56690: LD_INT 25
56692: ST_TO_ADDR
// vc_engine := engine_siberite ;
56693: LD_ADDR_OWVAR 39
56697: PUSH
56698: LD_INT 3
56700: ST_TO_ADDR
// vc_control := control_computer ;
56701: LD_ADDR_OWVAR 38
56705: PUSH
56706: LD_INT 3
56708: ST_TO_ADDR
// vc_weapon := 59 ;
56709: LD_ADDR_OWVAR 40
56713: PUSH
56714: LD_INT 59
56716: ST_TO_ADDR
// result := CreateVehicle ;
56717: LD_ADDR_VAR 0 5
56721: PUSH
56722: CALL_OW 45
56726: ST_TO_ADDR
// SetDir ( result , d ) ;
56727: LD_VAR 0 5
56731: PPUSH
56732: LD_VAR 0 4
56736: PPUSH
56737: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
56741: LD_VAR 0 5
56745: PPUSH
56746: LD_VAR 0 2
56750: PPUSH
56751: LD_VAR 0 3
56755: PPUSH
56756: LD_INT 0
56758: PPUSH
56759: CALL_OW 48
// end ;
56763: LD_VAR 0 5
56767: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
56768: LD_INT 0
56770: PPUSH
56771: PPUSH
56772: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
56773: LD_ADDR_VAR 0 2
56777: PUSH
56778: LD_INT 0
56780: PUSH
56781: LD_INT 0
56783: PUSH
56784: LD_INT 0
56786: PUSH
56787: LD_INT 0
56789: PUSH
56790: EMPTY
56791: LIST
56792: LIST
56793: LIST
56794: LIST
56795: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
56796: LD_VAR 0 1
56800: NOT
56801: PUSH
56802: LD_VAR 0 1
56806: PPUSH
56807: CALL_OW 264
56811: PUSH
56812: LD_INT 12
56814: PUSH
56815: LD_INT 51
56817: PUSH
56818: LD_INT 32
56820: PUSH
56821: LD_INT 89
56823: PUSH
56824: EMPTY
56825: LIST
56826: LIST
56827: LIST
56828: LIST
56829: IN
56830: NOT
56831: OR
56832: IFFALSE 56836
// exit ;
56834: GO 56934
// for i := 1 to 3 do
56836: LD_ADDR_VAR 0 3
56840: PUSH
56841: DOUBLE
56842: LD_INT 1
56844: DEC
56845: ST_TO_ADDR
56846: LD_INT 3
56848: PUSH
56849: FOR_TO
56850: IFFALSE 56932
// begin tmp := GetCargo ( cargo , i ) ;
56852: LD_ADDR_VAR 0 4
56856: PUSH
56857: LD_VAR 0 1
56861: PPUSH
56862: LD_VAR 0 3
56866: PPUSH
56867: CALL_OW 289
56871: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
56872: LD_ADDR_VAR 0 2
56876: PUSH
56877: LD_VAR 0 2
56881: PPUSH
56882: LD_VAR 0 3
56886: PPUSH
56887: LD_VAR 0 4
56891: PPUSH
56892: CALL_OW 1
56896: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
56897: LD_ADDR_VAR 0 2
56901: PUSH
56902: LD_VAR 0 2
56906: PPUSH
56907: LD_INT 4
56909: PPUSH
56910: LD_VAR 0 2
56914: PUSH
56915: LD_INT 4
56917: ARRAY
56918: PUSH
56919: LD_VAR 0 4
56923: PLUS
56924: PPUSH
56925: CALL_OW 1
56929: ST_TO_ADDR
// end ;
56930: GO 56849
56932: POP
56933: POP
// end ;
56934: LD_VAR 0 2
56938: RET
// export function Length ( array ) ; begin
56939: LD_INT 0
56941: PPUSH
// result := array + 0 ;
56942: LD_ADDR_VAR 0 2
56946: PUSH
56947: LD_VAR 0 1
56951: PUSH
56952: LD_INT 0
56954: PLUS
56955: ST_TO_ADDR
// end ;
56956: LD_VAR 0 2
56960: RET
// export function PrepareArray ( array ) ; begin
56961: LD_INT 0
56963: PPUSH
// result := array diff 0 ;
56964: LD_ADDR_VAR 0 2
56968: PUSH
56969: LD_VAR 0 1
56973: PUSH
56974: LD_INT 0
56976: DIFF
56977: ST_TO_ADDR
// if not result [ 1 ] then
56978: LD_VAR 0 2
56982: PUSH
56983: LD_INT 1
56985: ARRAY
56986: NOT
56987: IFFALSE 57007
// result := Delete ( result , 1 ) ;
56989: LD_ADDR_VAR 0 2
56993: PUSH
56994: LD_VAR 0 2
56998: PPUSH
56999: LD_INT 1
57001: PPUSH
57002: CALL_OW 3
57006: ST_TO_ADDR
// end ;
57007: LD_VAR 0 2
57011: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
57012: LD_INT 0
57014: PPUSH
57015: PPUSH
57016: PPUSH
57017: PPUSH
// sibRocketRange := 25 ;
57018: LD_ADDR_VAR 0 6
57022: PUSH
57023: LD_INT 25
57025: ST_TO_ADDR
// result := false ;
57026: LD_ADDR_VAR 0 4
57030: PUSH
57031: LD_INT 0
57033: ST_TO_ADDR
// for i := 0 to 5 do
57034: LD_ADDR_VAR 0 5
57038: PUSH
57039: DOUBLE
57040: LD_INT 0
57042: DEC
57043: ST_TO_ADDR
57044: LD_INT 5
57046: PUSH
57047: FOR_TO
57048: IFFALSE 57115
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
57050: LD_VAR 0 1
57054: PPUSH
57055: LD_VAR 0 5
57059: PPUSH
57060: LD_VAR 0 6
57064: PPUSH
57065: CALL_OW 272
57069: PPUSH
57070: LD_VAR 0 2
57074: PPUSH
57075: LD_VAR 0 5
57079: PPUSH
57080: LD_VAR 0 6
57084: PPUSH
57085: CALL_OW 273
57089: PPUSH
57090: LD_VAR 0 3
57094: PPUSH
57095: CALL_OW 309
57099: IFFALSE 57113
// begin result := true ;
57101: LD_ADDR_VAR 0 4
57105: PUSH
57106: LD_INT 1
57108: ST_TO_ADDR
// exit ;
57109: POP
57110: POP
57111: GO 57117
// end ;
57113: GO 57047
57115: POP
57116: POP
// end ;
57117: LD_VAR 0 4
57121: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
57122: LD_INT 0
57124: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
57125: LD_VAR 0 1
57129: PPUSH
57130: LD_VAR 0 2
57134: PPUSH
57135: LD_INT 0
57137: PPUSH
57138: LD_INT 0
57140: PPUSH
57141: LD_INT 1
57143: PPUSH
57144: LD_INT 0
57146: PPUSH
57147: CALL_OW 587
// end ;
57151: LD_VAR 0 3
57155: RET
// export function CenterOnNow ( unit ) ; begin
57156: LD_INT 0
57158: PPUSH
// result := IsInUnit ( unit ) ;
57159: LD_ADDR_VAR 0 2
57163: PUSH
57164: LD_VAR 0 1
57168: PPUSH
57169: CALL_OW 310
57173: ST_TO_ADDR
// if not result then
57174: LD_VAR 0 2
57178: NOT
57179: IFFALSE 57191
// result := unit ;
57181: LD_ADDR_VAR 0 2
57185: PUSH
57186: LD_VAR 0 1
57190: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
57191: LD_VAR 0 1
57195: PPUSH
57196: CALL_OW 87
// end ;
57200: LD_VAR 0 2
57204: RET
// export function ComMoveHex ( unit , hex ) ; begin
57205: LD_INT 0
57207: PPUSH
// if not hex then
57208: LD_VAR 0 2
57212: NOT
57213: IFFALSE 57217
// exit ;
57215: GO 57270
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
57217: LD_VAR 0 2
57221: PUSH
57222: LD_INT 1
57224: ARRAY
57225: PPUSH
57226: LD_VAR 0 2
57230: PUSH
57231: LD_INT 2
57233: ARRAY
57234: PPUSH
57235: CALL_OW 428
57239: IFFALSE 57243
// exit ;
57241: GO 57270
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
57243: LD_VAR 0 1
57247: PPUSH
57248: LD_VAR 0 2
57252: PUSH
57253: LD_INT 1
57255: ARRAY
57256: PPUSH
57257: LD_VAR 0 2
57261: PUSH
57262: LD_INT 2
57264: ARRAY
57265: PPUSH
57266: CALL_OW 111
// end ;
57270: LD_VAR 0 3
57274: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
57275: LD_INT 0
57277: PPUSH
57278: PPUSH
57279: PPUSH
// if not unit or not enemy then
57280: LD_VAR 0 1
57284: NOT
57285: PUSH
57286: LD_VAR 0 2
57290: NOT
57291: OR
57292: IFFALSE 57296
// exit ;
57294: GO 57420
// x := GetX ( enemy ) ;
57296: LD_ADDR_VAR 0 4
57300: PUSH
57301: LD_VAR 0 2
57305: PPUSH
57306: CALL_OW 250
57310: ST_TO_ADDR
// y := GetY ( enemy ) ;
57311: LD_ADDR_VAR 0 5
57315: PUSH
57316: LD_VAR 0 2
57320: PPUSH
57321: CALL_OW 251
57325: ST_TO_ADDR
// if ValidHex ( x , y ) then
57326: LD_VAR 0 4
57330: PPUSH
57331: LD_VAR 0 5
57335: PPUSH
57336: CALL_OW 488
57340: IFFALSE 57420
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
57342: LD_VAR 0 2
57346: PPUSH
57347: CALL_OW 247
57351: PUSH
57352: LD_INT 3
57354: PUSH
57355: LD_INT 2
57357: PUSH
57358: EMPTY
57359: LIST
57360: LIST
57361: IN
57362: PUSH
57363: LD_VAR 0 1
57367: PPUSH
57368: CALL_OW 255
57372: PPUSH
57373: LD_VAR 0 2
57377: PPUSH
57378: CALL_OW 292
57382: AND
57383: IFFALSE 57401
// ComAttackUnit ( unit , enemy ) else
57385: LD_VAR 0 1
57389: PPUSH
57390: LD_VAR 0 2
57394: PPUSH
57395: CALL_OW 115
57399: GO 57420
// ComAgressiveMove ( unit , x , y ) ;
57401: LD_VAR 0 1
57405: PPUSH
57406: LD_VAR 0 4
57410: PPUSH
57411: LD_VAR 0 5
57415: PPUSH
57416: CALL_OW 114
// end ; end_of_file
57420: LD_VAR 0 3
57424: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
57425: LD_INT 0
57427: PPUSH
57428: PPUSH
// skirmish := false ;
57429: LD_ADDR_EXP 59
57433: PUSH
57434: LD_INT 0
57436: ST_TO_ADDR
// debug_mc := false ;
57437: LD_ADDR_EXP 60
57441: PUSH
57442: LD_INT 0
57444: ST_TO_ADDR
// mc_bases := [ ] ;
57445: LD_ADDR_EXP 61
57449: PUSH
57450: EMPTY
57451: ST_TO_ADDR
// mc_sides := [ ] ;
57452: LD_ADDR_EXP 87
57456: PUSH
57457: EMPTY
57458: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57459: LD_ADDR_EXP 62
57463: PUSH
57464: EMPTY
57465: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57466: LD_ADDR_EXP 63
57470: PUSH
57471: EMPTY
57472: ST_TO_ADDR
// mc_need_heal := [ ] ;
57473: LD_ADDR_EXP 64
57477: PUSH
57478: EMPTY
57479: ST_TO_ADDR
// mc_healers := [ ] ;
57480: LD_ADDR_EXP 65
57484: PUSH
57485: EMPTY
57486: ST_TO_ADDR
// mc_build_list := [ ] ;
57487: LD_ADDR_EXP 66
57491: PUSH
57492: EMPTY
57493: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57494: LD_ADDR_EXP 93
57498: PUSH
57499: EMPTY
57500: ST_TO_ADDR
// mc_builders := [ ] ;
57501: LD_ADDR_EXP 67
57505: PUSH
57506: EMPTY
57507: ST_TO_ADDR
// mc_construct_list := [ ] ;
57508: LD_ADDR_EXP 68
57512: PUSH
57513: EMPTY
57514: ST_TO_ADDR
// mc_turret_list := [ ] ;
57515: LD_ADDR_EXP 69
57519: PUSH
57520: EMPTY
57521: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57522: LD_ADDR_EXP 70
57526: PUSH
57527: EMPTY
57528: ST_TO_ADDR
// mc_miners := [ ] ;
57529: LD_ADDR_EXP 75
57533: PUSH
57534: EMPTY
57535: ST_TO_ADDR
// mc_mines := [ ] ;
57536: LD_ADDR_EXP 74
57540: PUSH
57541: EMPTY
57542: ST_TO_ADDR
// mc_minefields := [ ] ;
57543: LD_ADDR_EXP 76
57547: PUSH
57548: EMPTY
57549: ST_TO_ADDR
// mc_crates := [ ] ;
57550: LD_ADDR_EXP 77
57554: PUSH
57555: EMPTY
57556: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57557: LD_ADDR_EXP 78
57561: PUSH
57562: EMPTY
57563: ST_TO_ADDR
// mc_crates_area := [ ] ;
57564: LD_ADDR_EXP 79
57568: PUSH
57569: EMPTY
57570: ST_TO_ADDR
// mc_vehicles := [ ] ;
57571: LD_ADDR_EXP 80
57575: PUSH
57576: EMPTY
57577: ST_TO_ADDR
// mc_attack := [ ] ;
57578: LD_ADDR_EXP 81
57582: PUSH
57583: EMPTY
57584: ST_TO_ADDR
// mc_produce := [ ] ;
57585: LD_ADDR_EXP 82
57589: PUSH
57590: EMPTY
57591: ST_TO_ADDR
// mc_defender := [ ] ;
57592: LD_ADDR_EXP 83
57596: PUSH
57597: EMPTY
57598: ST_TO_ADDR
// mc_parking := [ ] ;
57599: LD_ADDR_EXP 85
57603: PUSH
57604: EMPTY
57605: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57606: LD_ADDR_EXP 71
57610: PUSH
57611: EMPTY
57612: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57613: LD_ADDR_EXP 73
57617: PUSH
57618: EMPTY
57619: ST_TO_ADDR
// mc_scan := [ ] ;
57620: LD_ADDR_EXP 84
57624: PUSH
57625: EMPTY
57626: ST_TO_ADDR
// mc_scan_area := [ ] ;
57627: LD_ADDR_EXP 86
57631: PUSH
57632: EMPTY
57633: ST_TO_ADDR
// mc_tech := [ ] ;
57634: LD_ADDR_EXP 88
57638: PUSH
57639: EMPTY
57640: ST_TO_ADDR
// mc_class := [ ] ;
57641: LD_ADDR_EXP 102
57645: PUSH
57646: EMPTY
57647: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57648: LD_ADDR_EXP 103
57652: PUSH
57653: EMPTY
57654: ST_TO_ADDR
// mc_is_defending := [ ] ;
57655: LD_ADDR_EXP 104
57659: PUSH
57660: EMPTY
57661: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
57662: LD_ADDR_EXP 95
57666: PUSH
57667: EMPTY
57668: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
57669: LD_ADDR_EXP 105
57673: PUSH
57674: LD_INT 0
57676: ST_TO_ADDR
// end ;
57677: LD_VAR 0 1
57681: RET
// export function MC_Kill ( base ) ; begin
57682: LD_INT 0
57684: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57685: LD_ADDR_EXP 61
57689: PUSH
57690: LD_EXP 61
57694: PPUSH
57695: LD_VAR 0 1
57699: PPUSH
57700: EMPTY
57701: PPUSH
57702: CALL_OW 1
57706: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57707: LD_ADDR_EXP 62
57711: PUSH
57712: LD_EXP 62
57716: PPUSH
57717: LD_VAR 0 1
57721: PPUSH
57722: EMPTY
57723: PPUSH
57724: CALL_OW 1
57728: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57729: LD_ADDR_EXP 63
57733: PUSH
57734: LD_EXP 63
57738: PPUSH
57739: LD_VAR 0 1
57743: PPUSH
57744: EMPTY
57745: PPUSH
57746: CALL_OW 1
57750: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57751: LD_ADDR_EXP 64
57755: PUSH
57756: LD_EXP 64
57760: PPUSH
57761: LD_VAR 0 1
57765: PPUSH
57766: EMPTY
57767: PPUSH
57768: CALL_OW 1
57772: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57773: LD_ADDR_EXP 65
57777: PUSH
57778: LD_EXP 65
57782: PPUSH
57783: LD_VAR 0 1
57787: PPUSH
57788: EMPTY
57789: PPUSH
57790: CALL_OW 1
57794: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57795: LD_ADDR_EXP 66
57799: PUSH
57800: LD_EXP 66
57804: PPUSH
57805: LD_VAR 0 1
57809: PPUSH
57810: EMPTY
57811: PPUSH
57812: CALL_OW 1
57816: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57817: LD_ADDR_EXP 67
57821: PUSH
57822: LD_EXP 67
57826: PPUSH
57827: LD_VAR 0 1
57831: PPUSH
57832: EMPTY
57833: PPUSH
57834: CALL_OW 1
57838: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57839: LD_ADDR_EXP 68
57843: PUSH
57844: LD_EXP 68
57848: PPUSH
57849: LD_VAR 0 1
57853: PPUSH
57854: EMPTY
57855: PPUSH
57856: CALL_OW 1
57860: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57861: LD_ADDR_EXP 69
57865: PUSH
57866: LD_EXP 69
57870: PPUSH
57871: LD_VAR 0 1
57875: PPUSH
57876: EMPTY
57877: PPUSH
57878: CALL_OW 1
57882: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57883: LD_ADDR_EXP 70
57887: PUSH
57888: LD_EXP 70
57892: PPUSH
57893: LD_VAR 0 1
57897: PPUSH
57898: EMPTY
57899: PPUSH
57900: CALL_OW 1
57904: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57905: LD_ADDR_EXP 71
57909: PUSH
57910: LD_EXP 71
57914: PPUSH
57915: LD_VAR 0 1
57919: PPUSH
57920: EMPTY
57921: PPUSH
57922: CALL_OW 1
57926: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57927: LD_ADDR_EXP 72
57931: PUSH
57932: LD_EXP 72
57936: PPUSH
57937: LD_VAR 0 1
57941: PPUSH
57942: LD_INT 0
57944: PPUSH
57945: CALL_OW 1
57949: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57950: LD_ADDR_EXP 73
57954: PUSH
57955: LD_EXP 73
57959: PPUSH
57960: LD_VAR 0 1
57964: PPUSH
57965: EMPTY
57966: PPUSH
57967: CALL_OW 1
57971: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57972: LD_ADDR_EXP 74
57976: PUSH
57977: LD_EXP 74
57981: PPUSH
57982: LD_VAR 0 1
57986: PPUSH
57987: EMPTY
57988: PPUSH
57989: CALL_OW 1
57993: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57994: LD_ADDR_EXP 75
57998: PUSH
57999: LD_EXP 75
58003: PPUSH
58004: LD_VAR 0 1
58008: PPUSH
58009: EMPTY
58010: PPUSH
58011: CALL_OW 1
58015: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58016: LD_ADDR_EXP 76
58020: PUSH
58021: LD_EXP 76
58025: PPUSH
58026: LD_VAR 0 1
58030: PPUSH
58031: EMPTY
58032: PPUSH
58033: CALL_OW 1
58037: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58038: LD_ADDR_EXP 77
58042: PUSH
58043: LD_EXP 77
58047: PPUSH
58048: LD_VAR 0 1
58052: PPUSH
58053: EMPTY
58054: PPUSH
58055: CALL_OW 1
58059: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58060: LD_ADDR_EXP 78
58064: PUSH
58065: LD_EXP 78
58069: PPUSH
58070: LD_VAR 0 1
58074: PPUSH
58075: EMPTY
58076: PPUSH
58077: CALL_OW 1
58081: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58082: LD_ADDR_EXP 79
58086: PUSH
58087: LD_EXP 79
58091: PPUSH
58092: LD_VAR 0 1
58096: PPUSH
58097: EMPTY
58098: PPUSH
58099: CALL_OW 1
58103: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58104: LD_ADDR_EXP 80
58108: PUSH
58109: LD_EXP 80
58113: PPUSH
58114: LD_VAR 0 1
58118: PPUSH
58119: EMPTY
58120: PPUSH
58121: CALL_OW 1
58125: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58126: LD_ADDR_EXP 81
58130: PUSH
58131: LD_EXP 81
58135: PPUSH
58136: LD_VAR 0 1
58140: PPUSH
58141: EMPTY
58142: PPUSH
58143: CALL_OW 1
58147: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58148: LD_ADDR_EXP 82
58152: PUSH
58153: LD_EXP 82
58157: PPUSH
58158: LD_VAR 0 1
58162: PPUSH
58163: EMPTY
58164: PPUSH
58165: CALL_OW 1
58169: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58170: LD_ADDR_EXP 83
58174: PUSH
58175: LD_EXP 83
58179: PPUSH
58180: LD_VAR 0 1
58184: PPUSH
58185: EMPTY
58186: PPUSH
58187: CALL_OW 1
58191: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58192: LD_ADDR_EXP 84
58196: PUSH
58197: LD_EXP 84
58201: PPUSH
58202: LD_VAR 0 1
58206: PPUSH
58207: EMPTY
58208: PPUSH
58209: CALL_OW 1
58213: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58214: LD_ADDR_EXP 85
58218: PUSH
58219: LD_EXP 85
58223: PPUSH
58224: LD_VAR 0 1
58228: PPUSH
58229: EMPTY
58230: PPUSH
58231: CALL_OW 1
58235: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58236: LD_ADDR_EXP 86
58240: PUSH
58241: LD_EXP 86
58245: PPUSH
58246: LD_VAR 0 1
58250: PPUSH
58251: EMPTY
58252: PPUSH
58253: CALL_OW 1
58257: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58258: LD_ADDR_EXP 88
58262: PUSH
58263: LD_EXP 88
58267: PPUSH
58268: LD_VAR 0 1
58272: PPUSH
58273: EMPTY
58274: PPUSH
58275: CALL_OW 1
58279: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58280: LD_ADDR_EXP 90
58284: PUSH
58285: LD_EXP 90
58289: PPUSH
58290: LD_VAR 0 1
58294: PPUSH
58295: EMPTY
58296: PPUSH
58297: CALL_OW 1
58301: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58302: LD_ADDR_EXP 91
58306: PUSH
58307: LD_EXP 91
58311: PPUSH
58312: LD_VAR 0 1
58316: PPUSH
58317: EMPTY
58318: PPUSH
58319: CALL_OW 1
58323: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58324: LD_ADDR_EXP 92
58328: PUSH
58329: LD_EXP 92
58333: PPUSH
58334: LD_VAR 0 1
58338: PPUSH
58339: EMPTY
58340: PPUSH
58341: CALL_OW 1
58345: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58346: LD_ADDR_EXP 93
58350: PUSH
58351: LD_EXP 93
58355: PPUSH
58356: LD_VAR 0 1
58360: PPUSH
58361: EMPTY
58362: PPUSH
58363: CALL_OW 1
58367: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58368: LD_ADDR_EXP 94
58372: PUSH
58373: LD_EXP 94
58377: PPUSH
58378: LD_VAR 0 1
58382: PPUSH
58383: EMPTY
58384: PPUSH
58385: CALL_OW 1
58389: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58390: LD_ADDR_EXP 95
58394: PUSH
58395: LD_EXP 95
58399: PPUSH
58400: LD_VAR 0 1
58404: PPUSH
58405: EMPTY
58406: PPUSH
58407: CALL_OW 1
58411: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58412: LD_ADDR_EXP 96
58416: PUSH
58417: LD_EXP 96
58421: PPUSH
58422: LD_VAR 0 1
58426: PPUSH
58427: EMPTY
58428: PPUSH
58429: CALL_OW 1
58433: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58434: LD_ADDR_EXP 97
58438: PUSH
58439: LD_EXP 97
58443: PPUSH
58444: LD_VAR 0 1
58448: PPUSH
58449: EMPTY
58450: PPUSH
58451: CALL_OW 1
58455: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58456: LD_ADDR_EXP 98
58460: PUSH
58461: LD_EXP 98
58465: PPUSH
58466: LD_VAR 0 1
58470: PPUSH
58471: EMPTY
58472: PPUSH
58473: CALL_OW 1
58477: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58478: LD_ADDR_EXP 99
58482: PUSH
58483: LD_EXP 99
58487: PPUSH
58488: LD_VAR 0 1
58492: PPUSH
58493: EMPTY
58494: PPUSH
58495: CALL_OW 1
58499: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58500: LD_ADDR_EXP 100
58504: PUSH
58505: LD_EXP 100
58509: PPUSH
58510: LD_VAR 0 1
58514: PPUSH
58515: EMPTY
58516: PPUSH
58517: CALL_OW 1
58521: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58522: LD_ADDR_EXP 101
58526: PUSH
58527: LD_EXP 101
58531: PPUSH
58532: LD_VAR 0 1
58536: PPUSH
58537: EMPTY
58538: PPUSH
58539: CALL_OW 1
58543: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58544: LD_ADDR_EXP 102
58548: PUSH
58549: LD_EXP 102
58553: PPUSH
58554: LD_VAR 0 1
58558: PPUSH
58559: EMPTY
58560: PPUSH
58561: CALL_OW 1
58565: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58566: LD_ADDR_EXP 103
58570: PUSH
58571: LD_EXP 103
58575: PPUSH
58576: LD_VAR 0 1
58580: PPUSH
58581: LD_INT 0
58583: PPUSH
58584: CALL_OW 1
58588: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
58589: LD_ADDR_EXP 104
58593: PUSH
58594: LD_EXP 104
58598: PPUSH
58599: LD_VAR 0 1
58603: PPUSH
58604: LD_INT 0
58606: PPUSH
58607: CALL_OW 1
58611: ST_TO_ADDR
// end ;
58612: LD_VAR 0 2
58616: RET
// export function MC_Add ( side , units ) ; var base ; begin
58617: LD_INT 0
58619: PPUSH
58620: PPUSH
// base := mc_bases + 1 ;
58621: LD_ADDR_VAR 0 4
58625: PUSH
58626: LD_EXP 61
58630: PUSH
58631: LD_INT 1
58633: PLUS
58634: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58635: LD_ADDR_EXP 87
58639: PUSH
58640: LD_EXP 87
58644: PPUSH
58645: LD_VAR 0 4
58649: PPUSH
58650: LD_VAR 0 1
58654: PPUSH
58655: CALL_OW 1
58659: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58660: LD_ADDR_EXP 61
58664: PUSH
58665: LD_EXP 61
58669: PPUSH
58670: LD_VAR 0 4
58674: PPUSH
58675: LD_VAR 0 2
58679: PPUSH
58680: CALL_OW 1
58684: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58685: LD_ADDR_EXP 62
58689: PUSH
58690: LD_EXP 62
58694: PPUSH
58695: LD_VAR 0 4
58699: PPUSH
58700: EMPTY
58701: PPUSH
58702: CALL_OW 1
58706: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58707: LD_ADDR_EXP 63
58711: PUSH
58712: LD_EXP 63
58716: PPUSH
58717: LD_VAR 0 4
58721: PPUSH
58722: EMPTY
58723: PPUSH
58724: CALL_OW 1
58728: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58729: LD_ADDR_EXP 64
58733: PUSH
58734: LD_EXP 64
58738: PPUSH
58739: LD_VAR 0 4
58743: PPUSH
58744: EMPTY
58745: PPUSH
58746: CALL_OW 1
58750: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58751: LD_ADDR_EXP 65
58755: PUSH
58756: LD_EXP 65
58760: PPUSH
58761: LD_VAR 0 4
58765: PPUSH
58766: EMPTY
58767: PPUSH
58768: CALL_OW 1
58772: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58773: LD_ADDR_EXP 66
58777: PUSH
58778: LD_EXP 66
58782: PPUSH
58783: LD_VAR 0 4
58787: PPUSH
58788: EMPTY
58789: PPUSH
58790: CALL_OW 1
58794: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58795: LD_ADDR_EXP 67
58799: PUSH
58800: LD_EXP 67
58804: PPUSH
58805: LD_VAR 0 4
58809: PPUSH
58810: EMPTY
58811: PPUSH
58812: CALL_OW 1
58816: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58817: LD_ADDR_EXP 68
58821: PUSH
58822: LD_EXP 68
58826: PPUSH
58827: LD_VAR 0 4
58831: PPUSH
58832: EMPTY
58833: PPUSH
58834: CALL_OW 1
58838: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58839: LD_ADDR_EXP 69
58843: PUSH
58844: LD_EXP 69
58848: PPUSH
58849: LD_VAR 0 4
58853: PPUSH
58854: EMPTY
58855: PPUSH
58856: CALL_OW 1
58860: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58861: LD_ADDR_EXP 70
58865: PUSH
58866: LD_EXP 70
58870: PPUSH
58871: LD_VAR 0 4
58875: PPUSH
58876: EMPTY
58877: PPUSH
58878: CALL_OW 1
58882: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58883: LD_ADDR_EXP 71
58887: PUSH
58888: LD_EXP 71
58892: PPUSH
58893: LD_VAR 0 4
58897: PPUSH
58898: EMPTY
58899: PPUSH
58900: CALL_OW 1
58904: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58905: LD_ADDR_EXP 72
58909: PUSH
58910: LD_EXP 72
58914: PPUSH
58915: LD_VAR 0 4
58919: PPUSH
58920: LD_INT 0
58922: PPUSH
58923: CALL_OW 1
58927: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58928: LD_ADDR_EXP 73
58932: PUSH
58933: LD_EXP 73
58937: PPUSH
58938: LD_VAR 0 4
58942: PPUSH
58943: EMPTY
58944: PPUSH
58945: CALL_OW 1
58949: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58950: LD_ADDR_EXP 74
58954: PUSH
58955: LD_EXP 74
58959: PPUSH
58960: LD_VAR 0 4
58964: PPUSH
58965: EMPTY
58966: PPUSH
58967: CALL_OW 1
58971: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58972: LD_ADDR_EXP 75
58976: PUSH
58977: LD_EXP 75
58981: PPUSH
58982: LD_VAR 0 4
58986: PPUSH
58987: EMPTY
58988: PPUSH
58989: CALL_OW 1
58993: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58994: LD_ADDR_EXP 76
58998: PUSH
58999: LD_EXP 76
59003: PPUSH
59004: LD_VAR 0 4
59008: PPUSH
59009: EMPTY
59010: PPUSH
59011: CALL_OW 1
59015: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
59016: LD_ADDR_EXP 77
59020: PUSH
59021: LD_EXP 77
59025: PPUSH
59026: LD_VAR 0 4
59030: PPUSH
59031: EMPTY
59032: PPUSH
59033: CALL_OW 1
59037: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59038: LD_ADDR_EXP 78
59042: PUSH
59043: LD_EXP 78
59047: PPUSH
59048: LD_VAR 0 4
59052: PPUSH
59053: EMPTY
59054: PPUSH
59055: CALL_OW 1
59059: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59060: LD_ADDR_EXP 79
59064: PUSH
59065: LD_EXP 79
59069: PPUSH
59070: LD_VAR 0 4
59074: PPUSH
59075: EMPTY
59076: PPUSH
59077: CALL_OW 1
59081: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59082: LD_ADDR_EXP 80
59086: PUSH
59087: LD_EXP 80
59091: PPUSH
59092: LD_VAR 0 4
59096: PPUSH
59097: EMPTY
59098: PPUSH
59099: CALL_OW 1
59103: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59104: LD_ADDR_EXP 81
59108: PUSH
59109: LD_EXP 81
59113: PPUSH
59114: LD_VAR 0 4
59118: PPUSH
59119: EMPTY
59120: PPUSH
59121: CALL_OW 1
59125: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59126: LD_ADDR_EXP 82
59130: PUSH
59131: LD_EXP 82
59135: PPUSH
59136: LD_VAR 0 4
59140: PPUSH
59141: EMPTY
59142: PPUSH
59143: CALL_OW 1
59147: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59148: LD_ADDR_EXP 83
59152: PUSH
59153: LD_EXP 83
59157: PPUSH
59158: LD_VAR 0 4
59162: PPUSH
59163: EMPTY
59164: PPUSH
59165: CALL_OW 1
59169: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59170: LD_ADDR_EXP 84
59174: PUSH
59175: LD_EXP 84
59179: PPUSH
59180: LD_VAR 0 4
59184: PPUSH
59185: EMPTY
59186: PPUSH
59187: CALL_OW 1
59191: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59192: LD_ADDR_EXP 85
59196: PUSH
59197: LD_EXP 85
59201: PPUSH
59202: LD_VAR 0 4
59206: PPUSH
59207: EMPTY
59208: PPUSH
59209: CALL_OW 1
59213: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
59214: LD_ADDR_EXP 86
59218: PUSH
59219: LD_EXP 86
59223: PPUSH
59224: LD_VAR 0 4
59228: PPUSH
59229: EMPTY
59230: PPUSH
59231: CALL_OW 1
59235: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59236: LD_ADDR_EXP 88
59240: PUSH
59241: LD_EXP 88
59245: PPUSH
59246: LD_VAR 0 4
59250: PPUSH
59251: EMPTY
59252: PPUSH
59253: CALL_OW 1
59257: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
59258: LD_ADDR_EXP 90
59262: PUSH
59263: LD_EXP 90
59267: PPUSH
59268: LD_VAR 0 4
59272: PPUSH
59273: EMPTY
59274: PPUSH
59275: CALL_OW 1
59279: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59280: LD_ADDR_EXP 91
59284: PUSH
59285: LD_EXP 91
59289: PPUSH
59290: LD_VAR 0 4
59294: PPUSH
59295: EMPTY
59296: PPUSH
59297: CALL_OW 1
59301: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59302: LD_ADDR_EXP 92
59306: PUSH
59307: LD_EXP 92
59311: PPUSH
59312: LD_VAR 0 4
59316: PPUSH
59317: EMPTY
59318: PPUSH
59319: CALL_OW 1
59323: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59324: LD_ADDR_EXP 93
59328: PUSH
59329: LD_EXP 93
59333: PPUSH
59334: LD_VAR 0 4
59338: PPUSH
59339: EMPTY
59340: PPUSH
59341: CALL_OW 1
59345: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59346: LD_ADDR_EXP 94
59350: PUSH
59351: LD_EXP 94
59355: PPUSH
59356: LD_VAR 0 4
59360: PPUSH
59361: EMPTY
59362: PPUSH
59363: CALL_OW 1
59367: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59368: LD_ADDR_EXP 95
59372: PUSH
59373: LD_EXP 95
59377: PPUSH
59378: LD_VAR 0 4
59382: PPUSH
59383: EMPTY
59384: PPUSH
59385: CALL_OW 1
59389: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59390: LD_ADDR_EXP 96
59394: PUSH
59395: LD_EXP 96
59399: PPUSH
59400: LD_VAR 0 4
59404: PPUSH
59405: EMPTY
59406: PPUSH
59407: CALL_OW 1
59411: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59412: LD_ADDR_EXP 97
59416: PUSH
59417: LD_EXP 97
59421: PPUSH
59422: LD_VAR 0 4
59426: PPUSH
59427: EMPTY
59428: PPUSH
59429: CALL_OW 1
59433: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59434: LD_ADDR_EXP 98
59438: PUSH
59439: LD_EXP 98
59443: PPUSH
59444: LD_VAR 0 4
59448: PPUSH
59449: EMPTY
59450: PPUSH
59451: CALL_OW 1
59455: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59456: LD_ADDR_EXP 99
59460: PUSH
59461: LD_EXP 99
59465: PPUSH
59466: LD_VAR 0 4
59470: PPUSH
59471: EMPTY
59472: PPUSH
59473: CALL_OW 1
59477: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59478: LD_ADDR_EXP 100
59482: PUSH
59483: LD_EXP 100
59487: PPUSH
59488: LD_VAR 0 4
59492: PPUSH
59493: EMPTY
59494: PPUSH
59495: CALL_OW 1
59499: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59500: LD_ADDR_EXP 101
59504: PUSH
59505: LD_EXP 101
59509: PPUSH
59510: LD_VAR 0 4
59514: PPUSH
59515: EMPTY
59516: PPUSH
59517: CALL_OW 1
59521: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59522: LD_ADDR_EXP 102
59526: PUSH
59527: LD_EXP 102
59531: PPUSH
59532: LD_VAR 0 4
59536: PPUSH
59537: EMPTY
59538: PPUSH
59539: CALL_OW 1
59543: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59544: LD_ADDR_EXP 103
59548: PUSH
59549: LD_EXP 103
59553: PPUSH
59554: LD_VAR 0 4
59558: PPUSH
59559: LD_INT 0
59561: PPUSH
59562: CALL_OW 1
59566: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
59567: LD_ADDR_EXP 104
59571: PUSH
59572: LD_EXP 104
59576: PPUSH
59577: LD_VAR 0 4
59581: PPUSH
59582: LD_INT 0
59584: PPUSH
59585: CALL_OW 1
59589: ST_TO_ADDR
// result := base ;
59590: LD_ADDR_VAR 0 3
59594: PUSH
59595: LD_VAR 0 4
59599: ST_TO_ADDR
// end ;
59600: LD_VAR 0 3
59604: RET
// export function MC_Start ( ) ; var i ; begin
59605: LD_INT 0
59607: PPUSH
59608: PPUSH
// for i = 1 to mc_bases do
59609: LD_ADDR_VAR 0 2
59613: PUSH
59614: DOUBLE
59615: LD_INT 1
59617: DEC
59618: ST_TO_ADDR
59619: LD_EXP 61
59623: PUSH
59624: FOR_TO
59625: IFFALSE 60725
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59627: LD_ADDR_EXP 61
59631: PUSH
59632: LD_EXP 61
59636: PPUSH
59637: LD_VAR 0 2
59641: PPUSH
59642: LD_EXP 61
59646: PUSH
59647: LD_VAR 0 2
59651: ARRAY
59652: PUSH
59653: LD_INT 0
59655: DIFF
59656: PPUSH
59657: CALL_OW 1
59661: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59662: LD_ADDR_EXP 62
59666: PUSH
59667: LD_EXP 62
59671: PPUSH
59672: LD_VAR 0 2
59676: PPUSH
59677: EMPTY
59678: PPUSH
59679: CALL_OW 1
59683: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59684: LD_ADDR_EXP 63
59688: PUSH
59689: LD_EXP 63
59693: PPUSH
59694: LD_VAR 0 2
59698: PPUSH
59699: EMPTY
59700: PPUSH
59701: CALL_OW 1
59705: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59706: LD_ADDR_EXP 64
59710: PUSH
59711: LD_EXP 64
59715: PPUSH
59716: LD_VAR 0 2
59720: PPUSH
59721: EMPTY
59722: PPUSH
59723: CALL_OW 1
59727: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59728: LD_ADDR_EXP 65
59732: PUSH
59733: LD_EXP 65
59737: PPUSH
59738: LD_VAR 0 2
59742: PPUSH
59743: EMPTY
59744: PUSH
59745: EMPTY
59746: PUSH
59747: EMPTY
59748: LIST
59749: LIST
59750: PPUSH
59751: CALL_OW 1
59755: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59756: LD_ADDR_EXP 66
59760: PUSH
59761: LD_EXP 66
59765: PPUSH
59766: LD_VAR 0 2
59770: PPUSH
59771: EMPTY
59772: PPUSH
59773: CALL_OW 1
59777: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59778: LD_ADDR_EXP 93
59782: PUSH
59783: LD_EXP 93
59787: PPUSH
59788: LD_VAR 0 2
59792: PPUSH
59793: EMPTY
59794: PPUSH
59795: CALL_OW 1
59799: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59800: LD_ADDR_EXP 67
59804: PUSH
59805: LD_EXP 67
59809: PPUSH
59810: LD_VAR 0 2
59814: PPUSH
59815: EMPTY
59816: PPUSH
59817: CALL_OW 1
59821: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59822: LD_ADDR_EXP 68
59826: PUSH
59827: LD_EXP 68
59831: PPUSH
59832: LD_VAR 0 2
59836: PPUSH
59837: EMPTY
59838: PPUSH
59839: CALL_OW 1
59843: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59844: LD_ADDR_EXP 69
59848: PUSH
59849: LD_EXP 69
59853: PPUSH
59854: LD_VAR 0 2
59858: PPUSH
59859: LD_EXP 61
59863: PUSH
59864: LD_VAR 0 2
59868: ARRAY
59869: PPUSH
59870: LD_INT 2
59872: PUSH
59873: LD_INT 30
59875: PUSH
59876: LD_INT 32
59878: PUSH
59879: EMPTY
59880: LIST
59881: LIST
59882: PUSH
59883: LD_INT 30
59885: PUSH
59886: LD_INT 33
59888: PUSH
59889: EMPTY
59890: LIST
59891: LIST
59892: PUSH
59893: EMPTY
59894: LIST
59895: LIST
59896: LIST
59897: PPUSH
59898: CALL_OW 72
59902: PPUSH
59903: CALL_OW 1
59907: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59908: LD_ADDR_EXP 70
59912: PUSH
59913: LD_EXP 70
59917: PPUSH
59918: LD_VAR 0 2
59922: PPUSH
59923: LD_EXP 61
59927: PUSH
59928: LD_VAR 0 2
59932: ARRAY
59933: PPUSH
59934: LD_INT 2
59936: PUSH
59937: LD_INT 30
59939: PUSH
59940: LD_INT 32
59942: PUSH
59943: EMPTY
59944: LIST
59945: LIST
59946: PUSH
59947: LD_INT 30
59949: PUSH
59950: LD_INT 31
59952: PUSH
59953: EMPTY
59954: LIST
59955: LIST
59956: PUSH
59957: EMPTY
59958: LIST
59959: LIST
59960: LIST
59961: PUSH
59962: LD_INT 58
59964: PUSH
59965: EMPTY
59966: LIST
59967: PUSH
59968: EMPTY
59969: LIST
59970: LIST
59971: PPUSH
59972: CALL_OW 72
59976: PPUSH
59977: CALL_OW 1
59981: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59982: LD_ADDR_EXP 71
59986: PUSH
59987: LD_EXP 71
59991: PPUSH
59992: LD_VAR 0 2
59996: PPUSH
59997: EMPTY
59998: PPUSH
59999: CALL_OW 1
60003: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
60004: LD_ADDR_EXP 75
60008: PUSH
60009: LD_EXP 75
60013: PPUSH
60014: LD_VAR 0 2
60018: PPUSH
60019: EMPTY
60020: PPUSH
60021: CALL_OW 1
60025: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
60026: LD_ADDR_EXP 74
60030: PUSH
60031: LD_EXP 74
60035: PPUSH
60036: LD_VAR 0 2
60040: PPUSH
60041: EMPTY
60042: PPUSH
60043: CALL_OW 1
60047: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
60048: LD_ADDR_EXP 76
60052: PUSH
60053: LD_EXP 76
60057: PPUSH
60058: LD_VAR 0 2
60062: PPUSH
60063: EMPTY
60064: PPUSH
60065: CALL_OW 1
60069: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
60070: LD_ADDR_EXP 77
60074: PUSH
60075: LD_EXP 77
60079: PPUSH
60080: LD_VAR 0 2
60084: PPUSH
60085: EMPTY
60086: PPUSH
60087: CALL_OW 1
60091: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60092: LD_ADDR_EXP 78
60096: PUSH
60097: LD_EXP 78
60101: PPUSH
60102: LD_VAR 0 2
60106: PPUSH
60107: EMPTY
60108: PPUSH
60109: CALL_OW 1
60113: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
60114: LD_ADDR_EXP 79
60118: PUSH
60119: LD_EXP 79
60123: PPUSH
60124: LD_VAR 0 2
60128: PPUSH
60129: EMPTY
60130: PPUSH
60131: CALL_OW 1
60135: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
60136: LD_ADDR_EXP 80
60140: PUSH
60141: LD_EXP 80
60145: PPUSH
60146: LD_VAR 0 2
60150: PPUSH
60151: EMPTY
60152: PPUSH
60153: CALL_OW 1
60157: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
60158: LD_ADDR_EXP 81
60162: PUSH
60163: LD_EXP 81
60167: PPUSH
60168: LD_VAR 0 2
60172: PPUSH
60173: EMPTY
60174: PPUSH
60175: CALL_OW 1
60179: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
60180: LD_ADDR_EXP 82
60184: PUSH
60185: LD_EXP 82
60189: PPUSH
60190: LD_VAR 0 2
60194: PPUSH
60195: EMPTY
60196: PPUSH
60197: CALL_OW 1
60201: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
60202: LD_ADDR_EXP 83
60206: PUSH
60207: LD_EXP 83
60211: PPUSH
60212: LD_VAR 0 2
60216: PPUSH
60217: EMPTY
60218: PPUSH
60219: CALL_OW 1
60223: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
60224: LD_ADDR_EXP 72
60228: PUSH
60229: LD_EXP 72
60233: PPUSH
60234: LD_VAR 0 2
60238: PPUSH
60239: LD_INT 0
60241: PPUSH
60242: CALL_OW 1
60246: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
60247: LD_ADDR_EXP 85
60251: PUSH
60252: LD_EXP 85
60256: PPUSH
60257: LD_VAR 0 2
60261: PPUSH
60262: LD_INT 0
60264: PPUSH
60265: CALL_OW 1
60269: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
60270: LD_ADDR_EXP 73
60274: PUSH
60275: LD_EXP 73
60279: PPUSH
60280: LD_VAR 0 2
60284: PPUSH
60285: EMPTY
60286: PPUSH
60287: CALL_OW 1
60291: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
60292: LD_ADDR_EXP 84
60296: PUSH
60297: LD_EXP 84
60301: PPUSH
60302: LD_VAR 0 2
60306: PPUSH
60307: LD_INT 0
60309: PPUSH
60310: CALL_OW 1
60314: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
60315: LD_ADDR_EXP 86
60319: PUSH
60320: LD_EXP 86
60324: PPUSH
60325: LD_VAR 0 2
60329: PPUSH
60330: EMPTY
60331: PPUSH
60332: CALL_OW 1
60336: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
60337: LD_ADDR_EXP 89
60341: PUSH
60342: LD_EXP 89
60346: PPUSH
60347: LD_VAR 0 2
60351: PPUSH
60352: LD_INT 0
60354: PPUSH
60355: CALL_OW 1
60359: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
60360: LD_ADDR_EXP 90
60364: PUSH
60365: LD_EXP 90
60369: PPUSH
60370: LD_VAR 0 2
60374: PPUSH
60375: EMPTY
60376: PPUSH
60377: CALL_OW 1
60381: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60382: LD_ADDR_EXP 91
60386: PUSH
60387: LD_EXP 91
60391: PPUSH
60392: LD_VAR 0 2
60396: PPUSH
60397: EMPTY
60398: PPUSH
60399: CALL_OW 1
60403: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60404: LD_ADDR_EXP 92
60408: PUSH
60409: LD_EXP 92
60413: PPUSH
60414: LD_VAR 0 2
60418: PPUSH
60419: EMPTY
60420: PPUSH
60421: CALL_OW 1
60425: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60426: LD_ADDR_EXP 94
60430: PUSH
60431: LD_EXP 94
60435: PPUSH
60436: LD_VAR 0 2
60440: PPUSH
60441: LD_EXP 61
60445: PUSH
60446: LD_VAR 0 2
60450: ARRAY
60451: PPUSH
60452: LD_INT 2
60454: PUSH
60455: LD_INT 30
60457: PUSH
60458: LD_INT 6
60460: PUSH
60461: EMPTY
60462: LIST
60463: LIST
60464: PUSH
60465: LD_INT 30
60467: PUSH
60468: LD_INT 7
60470: PUSH
60471: EMPTY
60472: LIST
60473: LIST
60474: PUSH
60475: LD_INT 30
60477: PUSH
60478: LD_INT 8
60480: PUSH
60481: EMPTY
60482: LIST
60483: LIST
60484: PUSH
60485: EMPTY
60486: LIST
60487: LIST
60488: LIST
60489: LIST
60490: PPUSH
60491: CALL_OW 72
60495: PPUSH
60496: CALL_OW 1
60500: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60501: LD_ADDR_EXP 95
60505: PUSH
60506: LD_EXP 95
60510: PPUSH
60511: LD_VAR 0 2
60515: PPUSH
60516: EMPTY
60517: PPUSH
60518: CALL_OW 1
60522: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60523: LD_ADDR_EXP 96
60527: PUSH
60528: LD_EXP 96
60532: PPUSH
60533: LD_VAR 0 2
60537: PPUSH
60538: EMPTY
60539: PPUSH
60540: CALL_OW 1
60544: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60545: LD_ADDR_EXP 97
60549: PUSH
60550: LD_EXP 97
60554: PPUSH
60555: LD_VAR 0 2
60559: PPUSH
60560: EMPTY
60561: PPUSH
60562: CALL_OW 1
60566: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60567: LD_ADDR_EXP 98
60571: PUSH
60572: LD_EXP 98
60576: PPUSH
60577: LD_VAR 0 2
60581: PPUSH
60582: EMPTY
60583: PPUSH
60584: CALL_OW 1
60588: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60589: LD_ADDR_EXP 99
60593: PUSH
60594: LD_EXP 99
60598: PPUSH
60599: LD_VAR 0 2
60603: PPUSH
60604: EMPTY
60605: PPUSH
60606: CALL_OW 1
60610: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60611: LD_ADDR_EXP 100
60615: PUSH
60616: LD_EXP 100
60620: PPUSH
60621: LD_VAR 0 2
60625: PPUSH
60626: EMPTY
60627: PPUSH
60628: CALL_OW 1
60632: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60633: LD_ADDR_EXP 101
60637: PUSH
60638: LD_EXP 101
60642: PPUSH
60643: LD_VAR 0 2
60647: PPUSH
60648: EMPTY
60649: PPUSH
60650: CALL_OW 1
60654: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60655: LD_ADDR_EXP 102
60659: PUSH
60660: LD_EXP 102
60664: PPUSH
60665: LD_VAR 0 2
60669: PPUSH
60670: EMPTY
60671: PPUSH
60672: CALL_OW 1
60676: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60677: LD_ADDR_EXP 103
60681: PUSH
60682: LD_EXP 103
60686: PPUSH
60687: LD_VAR 0 2
60691: PPUSH
60692: LD_INT 0
60694: PPUSH
60695: CALL_OW 1
60699: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
60700: LD_ADDR_EXP 104
60704: PUSH
60705: LD_EXP 104
60709: PPUSH
60710: LD_VAR 0 2
60714: PPUSH
60715: LD_INT 0
60717: PPUSH
60718: CALL_OW 1
60722: ST_TO_ADDR
// end ;
60723: GO 59624
60725: POP
60726: POP
// MC_InitSides ( ) ;
60727: CALL 61013 0 0
// MC_InitResearch ( ) ;
60731: CALL 60752 0 0
// CustomInitMacro ( ) ;
60735: CALL 219 0 0
// skirmish := true ;
60739: LD_ADDR_EXP 59
60743: PUSH
60744: LD_INT 1
60746: ST_TO_ADDR
// end ;
60747: LD_VAR 0 1
60751: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60752: LD_INT 0
60754: PPUSH
60755: PPUSH
60756: PPUSH
60757: PPUSH
60758: PPUSH
60759: PPUSH
// if not mc_bases then
60760: LD_EXP 61
60764: NOT
60765: IFFALSE 60769
// exit ;
60767: GO 61008
// for i = 1 to 8 do
60769: LD_ADDR_VAR 0 2
60773: PUSH
60774: DOUBLE
60775: LD_INT 1
60777: DEC
60778: ST_TO_ADDR
60779: LD_INT 8
60781: PUSH
60782: FOR_TO
60783: IFFALSE 60809
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60785: LD_ADDR_EXP 88
60789: PUSH
60790: LD_EXP 88
60794: PPUSH
60795: LD_VAR 0 2
60799: PPUSH
60800: EMPTY
60801: PPUSH
60802: CALL_OW 1
60806: ST_TO_ADDR
60807: GO 60782
60809: POP
60810: POP
// tmp := [ ] ;
60811: LD_ADDR_VAR 0 5
60815: PUSH
60816: EMPTY
60817: ST_TO_ADDR
// for i = 1 to mc_sides do
60818: LD_ADDR_VAR 0 2
60822: PUSH
60823: DOUBLE
60824: LD_INT 1
60826: DEC
60827: ST_TO_ADDR
60828: LD_EXP 87
60832: PUSH
60833: FOR_TO
60834: IFFALSE 60892
// if not mc_sides [ i ] in tmp then
60836: LD_EXP 87
60840: PUSH
60841: LD_VAR 0 2
60845: ARRAY
60846: PUSH
60847: LD_VAR 0 5
60851: IN
60852: NOT
60853: IFFALSE 60890
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60855: LD_ADDR_VAR 0 5
60859: PUSH
60860: LD_VAR 0 5
60864: PPUSH
60865: LD_VAR 0 5
60869: PUSH
60870: LD_INT 1
60872: PLUS
60873: PPUSH
60874: LD_EXP 87
60878: PUSH
60879: LD_VAR 0 2
60883: ARRAY
60884: PPUSH
60885: CALL_OW 2
60889: ST_TO_ADDR
60890: GO 60833
60892: POP
60893: POP
// if not tmp then
60894: LD_VAR 0 5
60898: NOT
60899: IFFALSE 60903
// exit ;
60901: GO 61008
// for j in tmp do
60903: LD_ADDR_VAR 0 3
60907: PUSH
60908: LD_VAR 0 5
60912: PUSH
60913: FOR_IN
60914: IFFALSE 61006
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60916: LD_ADDR_VAR 0 6
60920: PUSH
60921: LD_INT 22
60923: PUSH
60924: LD_VAR 0 3
60928: PUSH
60929: EMPTY
60930: LIST
60931: LIST
60932: PPUSH
60933: CALL_OW 69
60937: ST_TO_ADDR
// if not un then
60938: LD_VAR 0 6
60942: NOT
60943: IFFALSE 60947
// continue ;
60945: GO 60913
// nation := GetNation ( un [ 1 ] ) ;
60947: LD_ADDR_VAR 0 4
60951: PUSH
60952: LD_VAR 0 6
60956: PUSH
60957: LD_INT 1
60959: ARRAY
60960: PPUSH
60961: CALL_OW 248
60965: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60966: LD_ADDR_EXP 88
60970: PUSH
60971: LD_EXP 88
60975: PPUSH
60976: LD_VAR 0 3
60980: PPUSH
60981: LD_VAR 0 3
60985: PPUSH
60986: LD_VAR 0 4
60990: PPUSH
60991: LD_INT 1
60993: PPUSH
60994: CALL 15564 0 3
60998: PPUSH
60999: CALL_OW 1
61003: ST_TO_ADDR
// end ;
61004: GO 60913
61006: POP
61007: POP
// end ;
61008: LD_VAR 0 1
61012: RET
// export function MC_InitSides ( ) ; var i ; begin
61013: LD_INT 0
61015: PPUSH
61016: PPUSH
// if not mc_bases then
61017: LD_EXP 61
61021: NOT
61022: IFFALSE 61026
// exit ;
61024: GO 61100
// for i = 1 to mc_bases do
61026: LD_ADDR_VAR 0 2
61030: PUSH
61031: DOUBLE
61032: LD_INT 1
61034: DEC
61035: ST_TO_ADDR
61036: LD_EXP 61
61040: PUSH
61041: FOR_TO
61042: IFFALSE 61098
// if mc_bases [ i ] then
61044: LD_EXP 61
61048: PUSH
61049: LD_VAR 0 2
61053: ARRAY
61054: IFFALSE 61096
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
61056: LD_ADDR_EXP 87
61060: PUSH
61061: LD_EXP 87
61065: PPUSH
61066: LD_VAR 0 2
61070: PPUSH
61071: LD_EXP 61
61075: PUSH
61076: LD_VAR 0 2
61080: ARRAY
61081: PUSH
61082: LD_INT 1
61084: ARRAY
61085: PPUSH
61086: CALL_OW 255
61090: PPUSH
61091: CALL_OW 1
61095: ST_TO_ADDR
61096: GO 61041
61098: POP
61099: POP
// end ;
61100: LD_VAR 0 1
61104: RET
// every 0 0$03 trigger skirmish do
61105: LD_EXP 59
61109: IFFALSE 61263
61111: GO 61113
61113: DISABLE
// begin enable ;
61114: ENABLE
// MC_CheckBuildings ( ) ;
61115: CALL 65775 0 0
// MC_CheckPeopleLife ( ) ;
61119: CALL 65936 0 0
// RaiseSailEvent ( 100 ) ;
61123: LD_INT 100
61125: PPUSH
61126: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
61130: LD_INT 103
61132: PPUSH
61133: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
61137: LD_INT 104
61139: PPUSH
61140: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
61144: LD_INT 105
61146: PPUSH
61147: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
61151: LD_INT 106
61153: PPUSH
61154: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
61158: LD_INT 107
61160: PPUSH
61161: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
61165: LD_INT 108
61167: PPUSH
61168: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
61172: LD_INT 109
61174: PPUSH
61175: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
61179: LD_INT 110
61181: PPUSH
61182: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
61186: LD_INT 111
61188: PPUSH
61189: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
61193: LD_INT 112
61195: PPUSH
61196: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
61200: LD_INT 113
61202: PPUSH
61203: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
61207: LD_INT 120
61209: PPUSH
61210: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
61214: LD_INT 121
61216: PPUSH
61217: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
61221: LD_INT 122
61223: PPUSH
61224: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
61228: LD_INT 123
61230: PPUSH
61231: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
61235: LD_INT 124
61237: PPUSH
61238: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
61242: LD_INT 125
61244: PPUSH
61245: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
61249: LD_INT 126
61251: PPUSH
61252: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
61256: LD_INT 200
61258: PPUSH
61259: CALL_OW 427
// end ;
61263: END
// on SailEvent ( event ) do begin if event < 100 then
61264: LD_VAR 0 1
61268: PUSH
61269: LD_INT 100
61271: LESS
61272: IFFALSE 61283
// CustomEvent ( event ) ;
61274: LD_VAR 0 1
61278: PPUSH
61279: CALL 14179 0 1
// if event = 100 then
61283: LD_VAR 0 1
61287: PUSH
61288: LD_INT 100
61290: EQUAL
61291: IFFALSE 61297
// MC_ClassManager ( ) ;
61293: CALL 61689 0 0
// if event = 101 then
61297: LD_VAR 0 1
61301: PUSH
61302: LD_INT 101
61304: EQUAL
61305: IFFALSE 61311
// MC_RepairBuildings ( ) ;
61307: CALL 66521 0 0
// if event = 102 then
61311: LD_VAR 0 1
61315: PUSH
61316: LD_INT 102
61318: EQUAL
61319: IFFALSE 61325
// MC_Heal ( ) ;
61321: CALL 67456 0 0
// if event = 103 then
61325: LD_VAR 0 1
61329: PUSH
61330: LD_INT 103
61332: EQUAL
61333: IFFALSE 61339
// MC_Build ( ) ;
61335: CALL 67878 0 0
// if event = 104 then
61339: LD_VAR 0 1
61343: PUSH
61344: LD_INT 104
61346: EQUAL
61347: IFFALSE 61353
// MC_TurretWeapon ( ) ;
61349: CALL 69512 0 0
// if event = 105 then
61353: LD_VAR 0 1
61357: PUSH
61358: LD_INT 105
61360: EQUAL
61361: IFFALSE 61367
// MC_BuildUpgrade ( ) ;
61363: CALL 69063 0 0
// if event = 106 then
61367: LD_VAR 0 1
61371: PUSH
61372: LD_INT 106
61374: EQUAL
61375: IFFALSE 61381
// MC_PlantMines ( ) ;
61377: CALL 69942 0 0
// if event = 107 then
61381: LD_VAR 0 1
61385: PUSH
61386: LD_INT 107
61388: EQUAL
61389: IFFALSE 61395
// MC_CollectCrates ( ) ;
61391: CALL 70740 0 0
// if event = 108 then
61395: LD_VAR 0 1
61399: PUSH
61400: LD_INT 108
61402: EQUAL
61403: IFFALSE 61409
// MC_LinkRemoteControl ( ) ;
61405: CALL 72590 0 0
// if event = 109 then
61409: LD_VAR 0 1
61413: PUSH
61414: LD_INT 109
61416: EQUAL
61417: IFFALSE 61423
// MC_ProduceVehicle ( ) ;
61419: CALL 72771 0 0
// if event = 110 then
61423: LD_VAR 0 1
61427: PUSH
61428: LD_INT 110
61430: EQUAL
61431: IFFALSE 61437
// MC_SendAttack ( ) ;
61433: CALL 73237 0 0
// if event = 111 then
61437: LD_VAR 0 1
61441: PUSH
61442: LD_INT 111
61444: EQUAL
61445: IFFALSE 61451
// MC_Defend ( ) ;
61447: CALL 73345 0 0
// if event = 112 then
61451: LD_VAR 0 1
61455: PUSH
61456: LD_INT 112
61458: EQUAL
61459: IFFALSE 61465
// MC_Research ( ) ;
61461: CALL 74225 0 0
// if event = 113 then
61465: LD_VAR 0 1
61469: PUSH
61470: LD_INT 113
61472: EQUAL
61473: IFFALSE 61479
// MC_MinesTrigger ( ) ;
61475: CALL 75339 0 0
// if event = 120 then
61479: LD_VAR 0 1
61483: PUSH
61484: LD_INT 120
61486: EQUAL
61487: IFFALSE 61493
// MC_RepairVehicle ( ) ;
61489: CALL 75438 0 0
// if event = 121 then
61493: LD_VAR 0 1
61497: PUSH
61498: LD_INT 121
61500: EQUAL
61501: IFFALSE 61507
// MC_TameApe ( ) ;
61503: CALL 76207 0 0
// if event = 122 then
61507: LD_VAR 0 1
61511: PUSH
61512: LD_INT 122
61514: EQUAL
61515: IFFALSE 61521
// MC_ChangeApeClass ( ) ;
61517: CALL 77036 0 0
// if event = 123 then
61521: LD_VAR 0 1
61525: PUSH
61526: LD_INT 123
61528: EQUAL
61529: IFFALSE 61535
// MC_Bazooka ( ) ;
61531: CALL 77686 0 0
// if event = 124 then
61535: LD_VAR 0 1
61539: PUSH
61540: LD_INT 124
61542: EQUAL
61543: IFFALSE 61549
// MC_TeleportExit ( ) ;
61545: CALL 77884 0 0
// if event = 125 then
61549: LD_VAR 0 1
61553: PUSH
61554: LD_INT 125
61556: EQUAL
61557: IFFALSE 61563
// MC_Deposits ( ) ;
61559: CALL 78531 0 0
// if event = 126 then
61563: LD_VAR 0 1
61567: PUSH
61568: LD_INT 126
61570: EQUAL
61571: IFFALSE 61577
// MC_RemoteDriver ( ) ;
61573: CALL 79156 0 0
// if event = 200 then
61577: LD_VAR 0 1
61581: PUSH
61582: LD_INT 200
61584: EQUAL
61585: IFFALSE 61591
// MC_Idle ( ) ;
61587: CALL 81063 0 0
// end ;
61591: PPOPN 1
61593: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61594: LD_INT 0
61596: PPUSH
61597: PPUSH
// if not mc_bases [ base ] or not tag then
61598: LD_EXP 61
61602: PUSH
61603: LD_VAR 0 1
61607: ARRAY
61608: NOT
61609: PUSH
61610: LD_VAR 0 2
61614: NOT
61615: OR
61616: IFFALSE 61620
// exit ;
61618: GO 61684
// for i in mc_bases [ base ] union mc_ape [ base ] do
61620: LD_ADDR_VAR 0 4
61624: PUSH
61625: LD_EXP 61
61629: PUSH
61630: LD_VAR 0 1
61634: ARRAY
61635: PUSH
61636: LD_EXP 90
61640: PUSH
61641: LD_VAR 0 1
61645: ARRAY
61646: UNION
61647: PUSH
61648: FOR_IN
61649: IFFALSE 61682
// if GetTag ( i ) = tag then
61651: LD_VAR 0 4
61655: PPUSH
61656: CALL_OW 110
61660: PUSH
61661: LD_VAR 0 2
61665: EQUAL
61666: IFFALSE 61680
// SetTag ( i , 0 ) ;
61668: LD_VAR 0 4
61672: PPUSH
61673: LD_INT 0
61675: PPUSH
61676: CALL_OW 109
61680: GO 61648
61682: POP
61683: POP
// end ;
61684: LD_VAR 0 3
61688: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61689: LD_INT 0
61691: PPUSH
61692: PPUSH
61693: PPUSH
61694: PPUSH
61695: PPUSH
61696: PPUSH
61697: PPUSH
61698: PPUSH
// if not mc_bases then
61699: LD_EXP 61
61703: NOT
61704: IFFALSE 61708
// exit ;
61706: GO 62157
// for i = 1 to mc_bases do
61708: LD_ADDR_VAR 0 2
61712: PUSH
61713: DOUBLE
61714: LD_INT 1
61716: DEC
61717: ST_TO_ADDR
61718: LD_EXP 61
61722: PUSH
61723: FOR_TO
61724: IFFALSE 62155
// begin tmp := MC_ClassCheckReq ( i ) ;
61726: LD_ADDR_VAR 0 4
61730: PUSH
61731: LD_VAR 0 2
61735: PPUSH
61736: CALL 62162 0 1
61740: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61741: LD_ADDR_EXP 102
61745: PUSH
61746: LD_EXP 102
61750: PPUSH
61751: LD_VAR 0 2
61755: PPUSH
61756: LD_VAR 0 4
61760: PPUSH
61761: CALL_OW 1
61765: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61766: LD_ADDR_VAR 0 6
61770: PUSH
61771: LD_EXP 61
61775: PUSH
61776: LD_VAR 0 2
61780: ARRAY
61781: PPUSH
61782: LD_INT 2
61784: PUSH
61785: LD_INT 30
61787: PUSH
61788: LD_INT 4
61790: PUSH
61791: EMPTY
61792: LIST
61793: LIST
61794: PUSH
61795: LD_INT 30
61797: PUSH
61798: LD_INT 5
61800: PUSH
61801: EMPTY
61802: LIST
61803: LIST
61804: PUSH
61805: EMPTY
61806: LIST
61807: LIST
61808: LIST
61809: PPUSH
61810: CALL_OW 72
61814: PUSH
61815: LD_EXP 61
61819: PUSH
61820: LD_VAR 0 2
61824: ARRAY
61825: PPUSH
61826: LD_INT 2
61828: PUSH
61829: LD_INT 30
61831: PUSH
61832: LD_INT 0
61834: PUSH
61835: EMPTY
61836: LIST
61837: LIST
61838: PUSH
61839: LD_INT 30
61841: PUSH
61842: LD_INT 1
61844: PUSH
61845: EMPTY
61846: LIST
61847: LIST
61848: PUSH
61849: EMPTY
61850: LIST
61851: LIST
61852: LIST
61853: PPUSH
61854: CALL_OW 72
61858: PUSH
61859: LD_EXP 61
61863: PUSH
61864: LD_VAR 0 2
61868: ARRAY
61869: PPUSH
61870: LD_INT 30
61872: PUSH
61873: LD_INT 3
61875: PUSH
61876: EMPTY
61877: LIST
61878: LIST
61879: PPUSH
61880: CALL_OW 72
61884: PUSH
61885: LD_EXP 61
61889: PUSH
61890: LD_VAR 0 2
61894: ARRAY
61895: PPUSH
61896: LD_INT 2
61898: PUSH
61899: LD_INT 30
61901: PUSH
61902: LD_INT 6
61904: PUSH
61905: EMPTY
61906: LIST
61907: LIST
61908: PUSH
61909: LD_INT 30
61911: PUSH
61912: LD_INT 7
61914: PUSH
61915: EMPTY
61916: LIST
61917: LIST
61918: PUSH
61919: LD_INT 30
61921: PUSH
61922: LD_INT 8
61924: PUSH
61925: EMPTY
61926: LIST
61927: LIST
61928: PUSH
61929: EMPTY
61930: LIST
61931: LIST
61932: LIST
61933: LIST
61934: PPUSH
61935: CALL_OW 72
61939: PUSH
61940: EMPTY
61941: LIST
61942: LIST
61943: LIST
61944: LIST
61945: ST_TO_ADDR
// for j := 1 to 4 do
61946: LD_ADDR_VAR 0 3
61950: PUSH
61951: DOUBLE
61952: LD_INT 1
61954: DEC
61955: ST_TO_ADDR
61956: LD_INT 4
61958: PUSH
61959: FOR_TO
61960: IFFALSE 62151
// begin if not tmp [ j ] then
61962: LD_VAR 0 4
61966: PUSH
61967: LD_VAR 0 3
61971: ARRAY
61972: NOT
61973: IFFALSE 61977
// continue ;
61975: GO 61959
// for p in tmp [ j ] do
61977: LD_ADDR_VAR 0 5
61981: PUSH
61982: LD_VAR 0 4
61986: PUSH
61987: LD_VAR 0 3
61991: ARRAY
61992: PUSH
61993: FOR_IN
61994: IFFALSE 62147
// begin if not b [ j ] then
61996: LD_VAR 0 6
62000: PUSH
62001: LD_VAR 0 3
62005: ARRAY
62006: NOT
62007: IFFALSE 62011
// break ;
62009: GO 62147
// e := 0 ;
62011: LD_ADDR_VAR 0 7
62015: PUSH
62016: LD_INT 0
62018: ST_TO_ADDR
// for k in b [ j ] do
62019: LD_ADDR_VAR 0 8
62023: PUSH
62024: LD_VAR 0 6
62028: PUSH
62029: LD_VAR 0 3
62033: ARRAY
62034: PUSH
62035: FOR_IN
62036: IFFALSE 62063
// if IsNotFull ( k ) then
62038: LD_VAR 0 8
62042: PPUSH
62043: CALL 17685 0 1
62047: IFFALSE 62061
// begin e := k ;
62049: LD_ADDR_VAR 0 7
62053: PUSH
62054: LD_VAR 0 8
62058: ST_TO_ADDR
// break ;
62059: GO 62063
// end ;
62061: GO 62035
62063: POP
62064: POP
// if e and not UnitGoingToBuilding ( p , e ) then
62065: LD_VAR 0 7
62069: PUSH
62070: LD_VAR 0 5
62074: PPUSH
62075: LD_VAR 0 7
62079: PPUSH
62080: CALL 51835 0 2
62084: NOT
62085: AND
62086: IFFALSE 62145
// begin if IsInUnit ( p ) then
62088: LD_VAR 0 5
62092: PPUSH
62093: CALL_OW 310
62097: IFFALSE 62108
// ComExitBuilding ( p ) ;
62099: LD_VAR 0 5
62103: PPUSH
62104: CALL_OW 122
// ComEnterUnit ( p , e ) ;
62108: LD_VAR 0 5
62112: PPUSH
62113: LD_VAR 0 7
62117: PPUSH
62118: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
62122: LD_VAR 0 5
62126: PPUSH
62127: LD_VAR 0 3
62131: PPUSH
62132: CALL_OW 183
// AddComExitBuilding ( p ) ;
62136: LD_VAR 0 5
62140: PPUSH
62141: CALL_OW 182
// end ; end ;
62145: GO 61993
62147: POP
62148: POP
// end ;
62149: GO 61959
62151: POP
62152: POP
// end ;
62153: GO 61723
62155: POP
62156: POP
// end ;
62157: LD_VAR 0 1
62161: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
62162: LD_INT 0
62164: PPUSH
62165: PPUSH
62166: PPUSH
62167: PPUSH
62168: PPUSH
62169: PPUSH
62170: PPUSH
62171: PPUSH
62172: PPUSH
62173: PPUSH
62174: PPUSH
62175: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
62176: LD_ADDR_VAR 0 2
62180: PUSH
62181: LD_INT 0
62183: PUSH
62184: LD_INT 0
62186: PUSH
62187: LD_INT 0
62189: PUSH
62190: LD_INT 0
62192: PUSH
62193: EMPTY
62194: LIST
62195: LIST
62196: LIST
62197: LIST
62198: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62199: LD_VAR 0 1
62203: NOT
62204: PUSH
62205: LD_EXP 61
62209: PUSH
62210: LD_VAR 0 1
62214: ARRAY
62215: NOT
62216: OR
62217: PUSH
62218: LD_EXP 61
62222: PUSH
62223: LD_VAR 0 1
62227: ARRAY
62228: PPUSH
62229: LD_INT 2
62231: PUSH
62232: LD_INT 30
62234: PUSH
62235: LD_INT 0
62237: PUSH
62238: EMPTY
62239: LIST
62240: LIST
62241: PUSH
62242: LD_INT 30
62244: PUSH
62245: LD_INT 1
62247: PUSH
62248: EMPTY
62249: LIST
62250: LIST
62251: PUSH
62252: EMPTY
62253: LIST
62254: LIST
62255: LIST
62256: PPUSH
62257: CALL_OW 72
62261: NOT
62262: OR
62263: IFFALSE 62267
// exit ;
62265: GO 65770
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62267: LD_ADDR_VAR 0 4
62271: PUSH
62272: LD_EXP 61
62276: PUSH
62277: LD_VAR 0 1
62281: ARRAY
62282: PPUSH
62283: LD_INT 2
62285: PUSH
62286: LD_INT 25
62288: PUSH
62289: LD_INT 1
62291: PUSH
62292: EMPTY
62293: LIST
62294: LIST
62295: PUSH
62296: LD_INT 25
62298: PUSH
62299: LD_INT 2
62301: PUSH
62302: EMPTY
62303: LIST
62304: LIST
62305: PUSH
62306: LD_INT 25
62308: PUSH
62309: LD_INT 3
62311: PUSH
62312: EMPTY
62313: LIST
62314: LIST
62315: PUSH
62316: LD_INT 25
62318: PUSH
62319: LD_INT 4
62321: PUSH
62322: EMPTY
62323: LIST
62324: LIST
62325: PUSH
62326: LD_INT 25
62328: PUSH
62329: LD_INT 5
62331: PUSH
62332: EMPTY
62333: LIST
62334: LIST
62335: PUSH
62336: LD_INT 25
62338: PUSH
62339: LD_INT 8
62341: PUSH
62342: EMPTY
62343: LIST
62344: LIST
62345: PUSH
62346: LD_INT 25
62348: PUSH
62349: LD_INT 9
62351: PUSH
62352: EMPTY
62353: LIST
62354: LIST
62355: PUSH
62356: EMPTY
62357: LIST
62358: LIST
62359: LIST
62360: LIST
62361: LIST
62362: LIST
62363: LIST
62364: LIST
62365: PPUSH
62366: CALL_OW 72
62370: ST_TO_ADDR
// if not tmp then
62371: LD_VAR 0 4
62375: NOT
62376: IFFALSE 62380
// exit ;
62378: GO 65770
// for i in tmp do
62380: LD_ADDR_VAR 0 3
62384: PUSH
62385: LD_VAR 0 4
62389: PUSH
62390: FOR_IN
62391: IFFALSE 62422
// if GetTag ( i ) then
62393: LD_VAR 0 3
62397: PPUSH
62398: CALL_OW 110
62402: IFFALSE 62420
// tmp := tmp diff i ;
62404: LD_ADDR_VAR 0 4
62408: PUSH
62409: LD_VAR 0 4
62413: PUSH
62414: LD_VAR 0 3
62418: DIFF
62419: ST_TO_ADDR
62420: GO 62390
62422: POP
62423: POP
// if not tmp then
62424: LD_VAR 0 4
62428: NOT
62429: IFFALSE 62433
// exit ;
62431: GO 65770
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62433: LD_ADDR_VAR 0 5
62437: PUSH
62438: LD_EXP 61
62442: PUSH
62443: LD_VAR 0 1
62447: ARRAY
62448: PPUSH
62449: LD_INT 2
62451: PUSH
62452: LD_INT 25
62454: PUSH
62455: LD_INT 1
62457: PUSH
62458: EMPTY
62459: LIST
62460: LIST
62461: PUSH
62462: LD_INT 25
62464: PUSH
62465: LD_INT 5
62467: PUSH
62468: EMPTY
62469: LIST
62470: LIST
62471: PUSH
62472: LD_INT 25
62474: PUSH
62475: LD_INT 8
62477: PUSH
62478: EMPTY
62479: LIST
62480: LIST
62481: PUSH
62482: LD_INT 25
62484: PUSH
62485: LD_INT 9
62487: PUSH
62488: EMPTY
62489: LIST
62490: LIST
62491: PUSH
62492: EMPTY
62493: LIST
62494: LIST
62495: LIST
62496: LIST
62497: LIST
62498: PPUSH
62499: CALL_OW 72
62503: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62504: LD_ADDR_VAR 0 6
62508: PUSH
62509: LD_EXP 61
62513: PUSH
62514: LD_VAR 0 1
62518: ARRAY
62519: PPUSH
62520: LD_INT 25
62522: PUSH
62523: LD_INT 2
62525: PUSH
62526: EMPTY
62527: LIST
62528: LIST
62529: PPUSH
62530: CALL_OW 72
62534: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62535: LD_ADDR_VAR 0 7
62539: PUSH
62540: LD_EXP 61
62544: PUSH
62545: LD_VAR 0 1
62549: ARRAY
62550: PPUSH
62551: LD_INT 25
62553: PUSH
62554: LD_INT 3
62556: PUSH
62557: EMPTY
62558: LIST
62559: LIST
62560: PPUSH
62561: CALL_OW 72
62565: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62566: LD_ADDR_VAR 0 8
62570: PUSH
62571: LD_EXP 61
62575: PUSH
62576: LD_VAR 0 1
62580: ARRAY
62581: PPUSH
62582: LD_INT 25
62584: PUSH
62585: LD_INT 4
62587: PUSH
62588: EMPTY
62589: LIST
62590: LIST
62591: PUSH
62592: LD_INT 24
62594: PUSH
62595: LD_INT 251
62597: PUSH
62598: EMPTY
62599: LIST
62600: LIST
62601: PUSH
62602: EMPTY
62603: LIST
62604: LIST
62605: PPUSH
62606: CALL_OW 72
62610: ST_TO_ADDR
// if mc_is_defending [ base ] then
62611: LD_EXP 104
62615: PUSH
62616: LD_VAR 0 1
62620: ARRAY
62621: IFFALSE 63082
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62623: LD_ADDR_EXP 103
62627: PUSH
62628: LD_EXP 103
62632: PPUSH
62633: LD_VAR 0 1
62637: PPUSH
62638: LD_INT 4
62640: PPUSH
62641: CALL_OW 1
62645: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62646: LD_ADDR_VAR 0 12
62650: PUSH
62651: LD_EXP 61
62655: PUSH
62656: LD_VAR 0 1
62660: ARRAY
62661: PPUSH
62662: LD_INT 2
62664: PUSH
62665: LD_INT 30
62667: PUSH
62668: LD_INT 4
62670: PUSH
62671: EMPTY
62672: LIST
62673: LIST
62674: PUSH
62675: LD_INT 30
62677: PUSH
62678: LD_INT 5
62680: PUSH
62681: EMPTY
62682: LIST
62683: LIST
62684: PUSH
62685: EMPTY
62686: LIST
62687: LIST
62688: LIST
62689: PPUSH
62690: CALL_OW 72
62694: ST_TO_ADDR
// if not b then
62695: LD_VAR 0 12
62699: NOT
62700: IFFALSE 62704
// exit ;
62702: GO 65770
// p := [ ] ;
62704: LD_ADDR_VAR 0 11
62708: PUSH
62709: EMPTY
62710: ST_TO_ADDR
// if sci >= 2 then
62711: LD_VAR 0 8
62715: PUSH
62716: LD_INT 2
62718: GREATEREQUAL
62719: IFFALSE 62750
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62721: LD_ADDR_VAR 0 8
62725: PUSH
62726: LD_VAR 0 8
62730: PUSH
62731: LD_INT 1
62733: ARRAY
62734: PUSH
62735: LD_VAR 0 8
62739: PUSH
62740: LD_INT 2
62742: ARRAY
62743: PUSH
62744: EMPTY
62745: LIST
62746: LIST
62747: ST_TO_ADDR
62748: GO 62811
// if sci = 1 then
62750: LD_VAR 0 8
62754: PUSH
62755: LD_INT 1
62757: EQUAL
62758: IFFALSE 62779
// sci := [ sci [ 1 ] ] else
62760: LD_ADDR_VAR 0 8
62764: PUSH
62765: LD_VAR 0 8
62769: PUSH
62770: LD_INT 1
62772: ARRAY
62773: PUSH
62774: EMPTY
62775: LIST
62776: ST_TO_ADDR
62777: GO 62811
// if sci = 0 then
62779: LD_VAR 0 8
62783: PUSH
62784: LD_INT 0
62786: EQUAL
62787: IFFALSE 62811
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62789: LD_ADDR_VAR 0 11
62793: PUSH
62794: LD_VAR 0 4
62798: PPUSH
62799: LD_INT 4
62801: PPUSH
62802: CALL 51707 0 2
62806: PUSH
62807: LD_INT 1
62809: ARRAY
62810: ST_TO_ADDR
// if eng > 4 then
62811: LD_VAR 0 6
62815: PUSH
62816: LD_INT 4
62818: GREATER
62819: IFFALSE 62865
// for i = eng downto 4 do
62821: LD_ADDR_VAR 0 3
62825: PUSH
62826: DOUBLE
62827: LD_VAR 0 6
62831: INC
62832: ST_TO_ADDR
62833: LD_INT 4
62835: PUSH
62836: FOR_DOWNTO
62837: IFFALSE 62863
// eng := eng diff eng [ i ] ;
62839: LD_ADDR_VAR 0 6
62843: PUSH
62844: LD_VAR 0 6
62848: PUSH
62849: LD_VAR 0 6
62853: PUSH
62854: LD_VAR 0 3
62858: ARRAY
62859: DIFF
62860: ST_TO_ADDR
62861: GO 62836
62863: POP
62864: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62865: LD_ADDR_VAR 0 4
62869: PUSH
62870: LD_VAR 0 4
62874: PUSH
62875: LD_VAR 0 5
62879: PUSH
62880: LD_VAR 0 6
62884: UNION
62885: PUSH
62886: LD_VAR 0 7
62890: UNION
62891: PUSH
62892: LD_VAR 0 8
62896: UNION
62897: DIFF
62898: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62899: LD_ADDR_VAR 0 13
62903: PUSH
62904: LD_EXP 61
62908: PUSH
62909: LD_VAR 0 1
62913: ARRAY
62914: PPUSH
62915: LD_INT 2
62917: PUSH
62918: LD_INT 30
62920: PUSH
62921: LD_INT 32
62923: PUSH
62924: EMPTY
62925: LIST
62926: LIST
62927: PUSH
62928: LD_INT 30
62930: PUSH
62931: LD_INT 31
62933: PUSH
62934: EMPTY
62935: LIST
62936: LIST
62937: PUSH
62938: EMPTY
62939: LIST
62940: LIST
62941: LIST
62942: PPUSH
62943: CALL_OW 72
62947: PUSH
62948: LD_EXP 61
62952: PUSH
62953: LD_VAR 0 1
62957: ARRAY
62958: PPUSH
62959: LD_INT 2
62961: PUSH
62962: LD_INT 30
62964: PUSH
62965: LD_INT 4
62967: PUSH
62968: EMPTY
62969: LIST
62970: LIST
62971: PUSH
62972: LD_INT 30
62974: PUSH
62975: LD_INT 5
62977: PUSH
62978: EMPTY
62979: LIST
62980: LIST
62981: PUSH
62982: EMPTY
62983: LIST
62984: LIST
62985: LIST
62986: PPUSH
62987: CALL_OW 72
62991: PUSH
62992: LD_INT 6
62994: MUL
62995: PLUS
62996: ST_TO_ADDR
// if bcount < tmp then
62997: LD_VAR 0 13
63001: PUSH
63002: LD_VAR 0 4
63006: LESS
63007: IFFALSE 63053
// for i = tmp downto bcount do
63009: LD_ADDR_VAR 0 3
63013: PUSH
63014: DOUBLE
63015: LD_VAR 0 4
63019: INC
63020: ST_TO_ADDR
63021: LD_VAR 0 13
63025: PUSH
63026: FOR_DOWNTO
63027: IFFALSE 63051
// tmp := Delete ( tmp , tmp ) ;
63029: LD_ADDR_VAR 0 4
63033: PUSH
63034: LD_VAR 0 4
63038: PPUSH
63039: LD_VAR 0 4
63043: PPUSH
63044: CALL_OW 3
63048: ST_TO_ADDR
63049: GO 63026
63051: POP
63052: POP
// result := [ tmp , 0 , 0 , p ] ;
63053: LD_ADDR_VAR 0 2
63057: PUSH
63058: LD_VAR 0 4
63062: PUSH
63063: LD_INT 0
63065: PUSH
63066: LD_INT 0
63068: PUSH
63069: LD_VAR 0 11
63073: PUSH
63074: EMPTY
63075: LIST
63076: LIST
63077: LIST
63078: LIST
63079: ST_TO_ADDR
// exit ;
63080: GO 65770
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63082: LD_EXP 61
63086: PUSH
63087: LD_VAR 0 1
63091: ARRAY
63092: PPUSH
63093: LD_INT 2
63095: PUSH
63096: LD_INT 30
63098: PUSH
63099: LD_INT 6
63101: PUSH
63102: EMPTY
63103: LIST
63104: LIST
63105: PUSH
63106: LD_INT 30
63108: PUSH
63109: LD_INT 7
63111: PUSH
63112: EMPTY
63113: LIST
63114: LIST
63115: PUSH
63116: LD_INT 30
63118: PUSH
63119: LD_INT 8
63121: PUSH
63122: EMPTY
63123: LIST
63124: LIST
63125: PUSH
63126: EMPTY
63127: LIST
63128: LIST
63129: LIST
63130: LIST
63131: PPUSH
63132: CALL_OW 72
63136: NOT
63137: PUSH
63138: LD_EXP 61
63142: PUSH
63143: LD_VAR 0 1
63147: ARRAY
63148: PPUSH
63149: LD_INT 30
63151: PUSH
63152: LD_INT 3
63154: PUSH
63155: EMPTY
63156: LIST
63157: LIST
63158: PPUSH
63159: CALL_OW 72
63163: NOT
63164: AND
63165: IFFALSE 63237
// begin if eng = tmp then
63167: LD_VAR 0 6
63171: PUSH
63172: LD_VAR 0 4
63176: EQUAL
63177: IFFALSE 63181
// exit ;
63179: GO 65770
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
63181: LD_ADDR_EXP 103
63185: PUSH
63186: LD_EXP 103
63190: PPUSH
63191: LD_VAR 0 1
63195: PPUSH
63196: LD_INT 1
63198: PPUSH
63199: CALL_OW 1
63203: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
63204: LD_ADDR_VAR 0 2
63208: PUSH
63209: LD_INT 0
63211: PUSH
63212: LD_VAR 0 4
63216: PUSH
63217: LD_VAR 0 6
63221: DIFF
63222: PUSH
63223: LD_INT 0
63225: PUSH
63226: LD_INT 0
63228: PUSH
63229: EMPTY
63230: LIST
63231: LIST
63232: LIST
63233: LIST
63234: ST_TO_ADDR
// exit ;
63235: GO 65770
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63237: LD_EXP 88
63241: PUSH
63242: LD_EXP 87
63246: PUSH
63247: LD_VAR 0 1
63251: ARRAY
63252: ARRAY
63253: PUSH
63254: LD_EXP 61
63258: PUSH
63259: LD_VAR 0 1
63263: ARRAY
63264: PPUSH
63265: LD_INT 2
63267: PUSH
63268: LD_INT 30
63270: PUSH
63271: LD_INT 6
63273: PUSH
63274: EMPTY
63275: LIST
63276: LIST
63277: PUSH
63278: LD_INT 30
63280: PUSH
63281: LD_INT 7
63283: PUSH
63284: EMPTY
63285: LIST
63286: LIST
63287: PUSH
63288: LD_INT 30
63290: PUSH
63291: LD_INT 8
63293: PUSH
63294: EMPTY
63295: LIST
63296: LIST
63297: PUSH
63298: EMPTY
63299: LIST
63300: LIST
63301: LIST
63302: LIST
63303: PPUSH
63304: CALL_OW 72
63308: AND
63309: PUSH
63310: LD_EXP 61
63314: PUSH
63315: LD_VAR 0 1
63319: ARRAY
63320: PPUSH
63321: LD_INT 30
63323: PUSH
63324: LD_INT 3
63326: PUSH
63327: EMPTY
63328: LIST
63329: LIST
63330: PPUSH
63331: CALL_OW 72
63335: NOT
63336: AND
63337: IFFALSE 63551
// begin if sci >= 6 then
63339: LD_VAR 0 8
63343: PUSH
63344: LD_INT 6
63346: GREATEREQUAL
63347: IFFALSE 63351
// exit ;
63349: GO 65770
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
63351: LD_ADDR_EXP 103
63355: PUSH
63356: LD_EXP 103
63360: PPUSH
63361: LD_VAR 0 1
63365: PPUSH
63366: LD_INT 2
63368: PPUSH
63369: CALL_OW 1
63373: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
63374: LD_ADDR_VAR 0 9
63378: PUSH
63379: LD_VAR 0 4
63383: PUSH
63384: LD_VAR 0 8
63388: DIFF
63389: PPUSH
63390: LD_INT 4
63392: PPUSH
63393: CALL 51707 0 2
63397: ST_TO_ADDR
// p := [ ] ;
63398: LD_ADDR_VAR 0 11
63402: PUSH
63403: EMPTY
63404: ST_TO_ADDR
// if sci < 6 and sort > 6 then
63405: LD_VAR 0 8
63409: PUSH
63410: LD_INT 6
63412: LESS
63413: PUSH
63414: LD_VAR 0 9
63418: PUSH
63419: LD_INT 6
63421: GREATER
63422: AND
63423: IFFALSE 63504
// begin for i = 1 to 6 - sci do
63425: LD_ADDR_VAR 0 3
63429: PUSH
63430: DOUBLE
63431: LD_INT 1
63433: DEC
63434: ST_TO_ADDR
63435: LD_INT 6
63437: PUSH
63438: LD_VAR 0 8
63442: MINUS
63443: PUSH
63444: FOR_TO
63445: IFFALSE 63500
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63447: LD_ADDR_VAR 0 11
63451: PUSH
63452: LD_VAR 0 11
63456: PPUSH
63457: LD_VAR 0 11
63461: PUSH
63462: LD_INT 1
63464: PLUS
63465: PPUSH
63466: LD_VAR 0 9
63470: PUSH
63471: LD_INT 1
63473: ARRAY
63474: PPUSH
63475: CALL_OW 2
63479: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63480: LD_ADDR_VAR 0 9
63484: PUSH
63485: LD_VAR 0 9
63489: PPUSH
63490: LD_INT 1
63492: PPUSH
63493: CALL_OW 3
63497: ST_TO_ADDR
// end ;
63498: GO 63444
63500: POP
63501: POP
// end else
63502: GO 63524
// if sort then
63504: LD_VAR 0 9
63508: IFFALSE 63524
// p := sort [ 1 ] ;
63510: LD_ADDR_VAR 0 11
63514: PUSH
63515: LD_VAR 0 9
63519: PUSH
63520: LD_INT 1
63522: ARRAY
63523: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63524: LD_ADDR_VAR 0 2
63528: PUSH
63529: LD_INT 0
63531: PUSH
63532: LD_INT 0
63534: PUSH
63535: LD_INT 0
63537: PUSH
63538: LD_VAR 0 11
63542: PUSH
63543: EMPTY
63544: LIST
63545: LIST
63546: LIST
63547: LIST
63548: ST_TO_ADDR
// exit ;
63549: GO 65770
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63551: LD_EXP 88
63555: PUSH
63556: LD_EXP 87
63560: PUSH
63561: LD_VAR 0 1
63565: ARRAY
63566: ARRAY
63567: PUSH
63568: LD_EXP 61
63572: PUSH
63573: LD_VAR 0 1
63577: ARRAY
63578: PPUSH
63579: LD_INT 2
63581: PUSH
63582: LD_INT 30
63584: PUSH
63585: LD_INT 6
63587: PUSH
63588: EMPTY
63589: LIST
63590: LIST
63591: PUSH
63592: LD_INT 30
63594: PUSH
63595: LD_INT 7
63597: PUSH
63598: EMPTY
63599: LIST
63600: LIST
63601: PUSH
63602: LD_INT 30
63604: PUSH
63605: LD_INT 8
63607: PUSH
63608: EMPTY
63609: LIST
63610: LIST
63611: PUSH
63612: EMPTY
63613: LIST
63614: LIST
63615: LIST
63616: LIST
63617: PPUSH
63618: CALL_OW 72
63622: AND
63623: PUSH
63624: LD_EXP 61
63628: PUSH
63629: LD_VAR 0 1
63633: ARRAY
63634: PPUSH
63635: LD_INT 30
63637: PUSH
63638: LD_INT 3
63640: PUSH
63641: EMPTY
63642: LIST
63643: LIST
63644: PPUSH
63645: CALL_OW 72
63649: AND
63650: IFFALSE 64384
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63652: LD_ADDR_EXP 103
63656: PUSH
63657: LD_EXP 103
63661: PPUSH
63662: LD_VAR 0 1
63666: PPUSH
63667: LD_INT 3
63669: PPUSH
63670: CALL_OW 1
63674: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63675: LD_ADDR_VAR 0 2
63679: PUSH
63680: LD_INT 0
63682: PUSH
63683: LD_INT 0
63685: PUSH
63686: LD_INT 0
63688: PUSH
63689: LD_INT 0
63691: PUSH
63692: EMPTY
63693: LIST
63694: LIST
63695: LIST
63696: LIST
63697: ST_TO_ADDR
// if not eng then
63698: LD_VAR 0 6
63702: NOT
63703: IFFALSE 63766
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63705: LD_ADDR_VAR 0 11
63709: PUSH
63710: LD_VAR 0 4
63714: PPUSH
63715: LD_INT 2
63717: PPUSH
63718: CALL 51707 0 2
63722: PUSH
63723: LD_INT 1
63725: ARRAY
63726: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63727: LD_ADDR_VAR 0 2
63731: PUSH
63732: LD_VAR 0 2
63736: PPUSH
63737: LD_INT 2
63739: PPUSH
63740: LD_VAR 0 11
63744: PPUSH
63745: CALL_OW 1
63749: ST_TO_ADDR
// tmp := tmp diff p ;
63750: LD_ADDR_VAR 0 4
63754: PUSH
63755: LD_VAR 0 4
63759: PUSH
63760: LD_VAR 0 11
63764: DIFF
63765: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63766: LD_VAR 0 4
63770: PUSH
63771: LD_VAR 0 8
63775: PUSH
63776: LD_INT 6
63778: LESS
63779: AND
63780: IFFALSE 63968
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63782: LD_ADDR_VAR 0 9
63786: PUSH
63787: LD_VAR 0 4
63791: PUSH
63792: LD_VAR 0 8
63796: PUSH
63797: LD_VAR 0 7
63801: UNION
63802: DIFF
63803: PPUSH
63804: LD_INT 4
63806: PPUSH
63807: CALL 51707 0 2
63811: ST_TO_ADDR
// p := [ ] ;
63812: LD_ADDR_VAR 0 11
63816: PUSH
63817: EMPTY
63818: ST_TO_ADDR
// if sort then
63819: LD_VAR 0 9
63823: IFFALSE 63939
// for i = 1 to 6 - sci do
63825: LD_ADDR_VAR 0 3
63829: PUSH
63830: DOUBLE
63831: LD_INT 1
63833: DEC
63834: ST_TO_ADDR
63835: LD_INT 6
63837: PUSH
63838: LD_VAR 0 8
63842: MINUS
63843: PUSH
63844: FOR_TO
63845: IFFALSE 63937
// begin if i = sort then
63847: LD_VAR 0 3
63851: PUSH
63852: LD_VAR 0 9
63856: EQUAL
63857: IFFALSE 63861
// break ;
63859: GO 63937
// if GetClass ( i ) = 4 then
63861: LD_VAR 0 3
63865: PPUSH
63866: CALL_OW 257
63870: PUSH
63871: LD_INT 4
63873: EQUAL
63874: IFFALSE 63878
// continue ;
63876: GO 63844
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63878: LD_ADDR_VAR 0 11
63882: PUSH
63883: LD_VAR 0 11
63887: PPUSH
63888: LD_VAR 0 11
63892: PUSH
63893: LD_INT 1
63895: PLUS
63896: PPUSH
63897: LD_VAR 0 9
63901: PUSH
63902: LD_VAR 0 3
63906: ARRAY
63907: PPUSH
63908: CALL_OW 2
63912: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63913: LD_ADDR_VAR 0 4
63917: PUSH
63918: LD_VAR 0 4
63922: PUSH
63923: LD_VAR 0 9
63927: PUSH
63928: LD_VAR 0 3
63932: ARRAY
63933: DIFF
63934: ST_TO_ADDR
// end ;
63935: GO 63844
63937: POP
63938: POP
// if p then
63939: LD_VAR 0 11
63943: IFFALSE 63968
// result := Replace ( result , 4 , p ) ;
63945: LD_ADDR_VAR 0 2
63949: PUSH
63950: LD_VAR 0 2
63954: PPUSH
63955: LD_INT 4
63957: PPUSH
63958: LD_VAR 0 11
63962: PPUSH
63963: CALL_OW 1
63967: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63968: LD_VAR 0 4
63972: PUSH
63973: LD_VAR 0 7
63977: PUSH
63978: LD_INT 6
63980: LESS
63981: AND
63982: IFFALSE 64170
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63984: LD_ADDR_VAR 0 9
63988: PUSH
63989: LD_VAR 0 4
63993: PUSH
63994: LD_VAR 0 8
63998: PUSH
63999: LD_VAR 0 7
64003: UNION
64004: DIFF
64005: PPUSH
64006: LD_INT 3
64008: PPUSH
64009: CALL 51707 0 2
64013: ST_TO_ADDR
// p := [ ] ;
64014: LD_ADDR_VAR 0 11
64018: PUSH
64019: EMPTY
64020: ST_TO_ADDR
// if sort then
64021: LD_VAR 0 9
64025: IFFALSE 64141
// for i = 1 to 6 - mech do
64027: LD_ADDR_VAR 0 3
64031: PUSH
64032: DOUBLE
64033: LD_INT 1
64035: DEC
64036: ST_TO_ADDR
64037: LD_INT 6
64039: PUSH
64040: LD_VAR 0 7
64044: MINUS
64045: PUSH
64046: FOR_TO
64047: IFFALSE 64139
// begin if i = sort then
64049: LD_VAR 0 3
64053: PUSH
64054: LD_VAR 0 9
64058: EQUAL
64059: IFFALSE 64063
// break ;
64061: GO 64139
// if GetClass ( i ) = 3 then
64063: LD_VAR 0 3
64067: PPUSH
64068: CALL_OW 257
64072: PUSH
64073: LD_INT 3
64075: EQUAL
64076: IFFALSE 64080
// continue ;
64078: GO 64046
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64080: LD_ADDR_VAR 0 11
64084: PUSH
64085: LD_VAR 0 11
64089: PPUSH
64090: LD_VAR 0 11
64094: PUSH
64095: LD_INT 1
64097: PLUS
64098: PPUSH
64099: LD_VAR 0 9
64103: PUSH
64104: LD_VAR 0 3
64108: ARRAY
64109: PPUSH
64110: CALL_OW 2
64114: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64115: LD_ADDR_VAR 0 4
64119: PUSH
64120: LD_VAR 0 4
64124: PUSH
64125: LD_VAR 0 9
64129: PUSH
64130: LD_VAR 0 3
64134: ARRAY
64135: DIFF
64136: ST_TO_ADDR
// end ;
64137: GO 64046
64139: POP
64140: POP
// if p then
64141: LD_VAR 0 11
64145: IFFALSE 64170
// result := Replace ( result , 3 , p ) ;
64147: LD_ADDR_VAR 0 2
64151: PUSH
64152: LD_VAR 0 2
64156: PPUSH
64157: LD_INT 3
64159: PPUSH
64160: LD_VAR 0 11
64164: PPUSH
64165: CALL_OW 1
64169: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
64170: LD_VAR 0 4
64174: PUSH
64175: LD_INT 6
64177: GREATER
64178: PUSH
64179: LD_VAR 0 6
64183: PUSH
64184: LD_INT 6
64186: LESS
64187: AND
64188: IFFALSE 64382
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64190: LD_ADDR_VAR 0 9
64194: PUSH
64195: LD_VAR 0 4
64199: PUSH
64200: LD_VAR 0 8
64204: PUSH
64205: LD_VAR 0 7
64209: UNION
64210: PUSH
64211: LD_VAR 0 6
64215: UNION
64216: DIFF
64217: PPUSH
64218: LD_INT 2
64220: PPUSH
64221: CALL 51707 0 2
64225: ST_TO_ADDR
// p := [ ] ;
64226: LD_ADDR_VAR 0 11
64230: PUSH
64231: EMPTY
64232: ST_TO_ADDR
// if sort then
64233: LD_VAR 0 9
64237: IFFALSE 64353
// for i = 1 to 6 - eng do
64239: LD_ADDR_VAR 0 3
64243: PUSH
64244: DOUBLE
64245: LD_INT 1
64247: DEC
64248: ST_TO_ADDR
64249: LD_INT 6
64251: PUSH
64252: LD_VAR 0 6
64256: MINUS
64257: PUSH
64258: FOR_TO
64259: IFFALSE 64351
// begin if i = sort then
64261: LD_VAR 0 3
64265: PUSH
64266: LD_VAR 0 9
64270: EQUAL
64271: IFFALSE 64275
// break ;
64273: GO 64351
// if GetClass ( i ) = 2 then
64275: LD_VAR 0 3
64279: PPUSH
64280: CALL_OW 257
64284: PUSH
64285: LD_INT 2
64287: EQUAL
64288: IFFALSE 64292
// continue ;
64290: GO 64258
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64292: LD_ADDR_VAR 0 11
64296: PUSH
64297: LD_VAR 0 11
64301: PPUSH
64302: LD_VAR 0 11
64306: PUSH
64307: LD_INT 1
64309: PLUS
64310: PPUSH
64311: LD_VAR 0 9
64315: PUSH
64316: LD_VAR 0 3
64320: ARRAY
64321: PPUSH
64322: CALL_OW 2
64326: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64327: LD_ADDR_VAR 0 4
64331: PUSH
64332: LD_VAR 0 4
64336: PUSH
64337: LD_VAR 0 9
64341: PUSH
64342: LD_VAR 0 3
64346: ARRAY
64347: DIFF
64348: ST_TO_ADDR
// end ;
64349: GO 64258
64351: POP
64352: POP
// if p then
64353: LD_VAR 0 11
64357: IFFALSE 64382
// result := Replace ( result , 2 , p ) ;
64359: LD_ADDR_VAR 0 2
64363: PUSH
64364: LD_VAR 0 2
64368: PPUSH
64369: LD_INT 2
64371: PPUSH
64372: LD_VAR 0 11
64376: PPUSH
64377: CALL_OW 1
64381: ST_TO_ADDR
// end ; exit ;
64382: GO 65770
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
64384: LD_EXP 88
64388: PUSH
64389: LD_EXP 87
64393: PUSH
64394: LD_VAR 0 1
64398: ARRAY
64399: ARRAY
64400: NOT
64401: PUSH
64402: LD_EXP 61
64406: PUSH
64407: LD_VAR 0 1
64411: ARRAY
64412: PPUSH
64413: LD_INT 30
64415: PUSH
64416: LD_INT 3
64418: PUSH
64419: EMPTY
64420: LIST
64421: LIST
64422: PPUSH
64423: CALL_OW 72
64427: AND
64428: PUSH
64429: LD_EXP 66
64433: PUSH
64434: LD_VAR 0 1
64438: ARRAY
64439: AND
64440: IFFALSE 65048
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64442: LD_ADDR_EXP 103
64446: PUSH
64447: LD_EXP 103
64451: PPUSH
64452: LD_VAR 0 1
64456: PPUSH
64457: LD_INT 5
64459: PPUSH
64460: CALL_OW 1
64464: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64465: LD_ADDR_VAR 0 2
64469: PUSH
64470: LD_INT 0
64472: PUSH
64473: LD_INT 0
64475: PUSH
64476: LD_INT 0
64478: PUSH
64479: LD_INT 0
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: LIST
64486: LIST
64487: ST_TO_ADDR
// if sci > 1 then
64488: LD_VAR 0 8
64492: PUSH
64493: LD_INT 1
64495: GREATER
64496: IFFALSE 64524
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64498: LD_ADDR_VAR 0 4
64502: PUSH
64503: LD_VAR 0 4
64507: PUSH
64508: LD_VAR 0 8
64512: PUSH
64513: LD_VAR 0 8
64517: PUSH
64518: LD_INT 1
64520: ARRAY
64521: DIFF
64522: DIFF
64523: ST_TO_ADDR
// if tmp and not sci then
64524: LD_VAR 0 4
64528: PUSH
64529: LD_VAR 0 8
64533: NOT
64534: AND
64535: IFFALSE 64604
// begin sort := SortBySkill ( tmp , 4 ) ;
64537: LD_ADDR_VAR 0 9
64541: PUSH
64542: LD_VAR 0 4
64546: PPUSH
64547: LD_INT 4
64549: PPUSH
64550: CALL 51707 0 2
64554: ST_TO_ADDR
// if sort then
64555: LD_VAR 0 9
64559: IFFALSE 64575
// p := sort [ 1 ] ;
64561: LD_ADDR_VAR 0 11
64565: PUSH
64566: LD_VAR 0 9
64570: PUSH
64571: LD_INT 1
64573: ARRAY
64574: ST_TO_ADDR
// if p then
64575: LD_VAR 0 11
64579: IFFALSE 64604
// result := Replace ( result , 4 , p ) ;
64581: LD_ADDR_VAR 0 2
64585: PUSH
64586: LD_VAR 0 2
64590: PPUSH
64591: LD_INT 4
64593: PPUSH
64594: LD_VAR 0 11
64598: PPUSH
64599: CALL_OW 1
64603: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64604: LD_ADDR_VAR 0 4
64608: PUSH
64609: LD_VAR 0 4
64613: PUSH
64614: LD_VAR 0 7
64618: DIFF
64619: ST_TO_ADDR
// if tmp and mech < 6 then
64620: LD_VAR 0 4
64624: PUSH
64625: LD_VAR 0 7
64629: PUSH
64630: LD_INT 6
64632: LESS
64633: AND
64634: IFFALSE 64822
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64636: LD_ADDR_VAR 0 9
64640: PUSH
64641: LD_VAR 0 4
64645: PUSH
64646: LD_VAR 0 8
64650: PUSH
64651: LD_VAR 0 7
64655: UNION
64656: DIFF
64657: PPUSH
64658: LD_INT 3
64660: PPUSH
64661: CALL 51707 0 2
64665: ST_TO_ADDR
// p := [ ] ;
64666: LD_ADDR_VAR 0 11
64670: PUSH
64671: EMPTY
64672: ST_TO_ADDR
// if sort then
64673: LD_VAR 0 9
64677: IFFALSE 64793
// for i = 1 to 6 - mech do
64679: LD_ADDR_VAR 0 3
64683: PUSH
64684: DOUBLE
64685: LD_INT 1
64687: DEC
64688: ST_TO_ADDR
64689: LD_INT 6
64691: PUSH
64692: LD_VAR 0 7
64696: MINUS
64697: PUSH
64698: FOR_TO
64699: IFFALSE 64791
// begin if i = sort then
64701: LD_VAR 0 3
64705: PUSH
64706: LD_VAR 0 9
64710: EQUAL
64711: IFFALSE 64715
// break ;
64713: GO 64791
// if GetClass ( i ) = 3 then
64715: LD_VAR 0 3
64719: PPUSH
64720: CALL_OW 257
64724: PUSH
64725: LD_INT 3
64727: EQUAL
64728: IFFALSE 64732
// continue ;
64730: GO 64698
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64732: LD_ADDR_VAR 0 11
64736: PUSH
64737: LD_VAR 0 11
64741: PPUSH
64742: LD_VAR 0 11
64746: PUSH
64747: LD_INT 1
64749: PLUS
64750: PPUSH
64751: LD_VAR 0 9
64755: PUSH
64756: LD_VAR 0 3
64760: ARRAY
64761: PPUSH
64762: CALL_OW 2
64766: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64767: LD_ADDR_VAR 0 4
64771: PUSH
64772: LD_VAR 0 4
64776: PUSH
64777: LD_VAR 0 9
64781: PUSH
64782: LD_VAR 0 3
64786: ARRAY
64787: DIFF
64788: ST_TO_ADDR
// end ;
64789: GO 64698
64791: POP
64792: POP
// if p then
64793: LD_VAR 0 11
64797: IFFALSE 64822
// result := Replace ( result , 3 , p ) ;
64799: LD_ADDR_VAR 0 2
64803: PUSH
64804: LD_VAR 0 2
64808: PPUSH
64809: LD_INT 3
64811: PPUSH
64812: LD_VAR 0 11
64816: PPUSH
64817: CALL_OW 1
64821: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64822: LD_ADDR_VAR 0 4
64826: PUSH
64827: LD_VAR 0 4
64831: PUSH
64832: LD_VAR 0 6
64836: DIFF
64837: ST_TO_ADDR
// if tmp and eng < 6 then
64838: LD_VAR 0 4
64842: PUSH
64843: LD_VAR 0 6
64847: PUSH
64848: LD_INT 6
64850: LESS
64851: AND
64852: IFFALSE 65046
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64854: LD_ADDR_VAR 0 9
64858: PUSH
64859: LD_VAR 0 4
64863: PUSH
64864: LD_VAR 0 8
64868: PUSH
64869: LD_VAR 0 7
64873: UNION
64874: PUSH
64875: LD_VAR 0 6
64879: UNION
64880: DIFF
64881: PPUSH
64882: LD_INT 2
64884: PPUSH
64885: CALL 51707 0 2
64889: ST_TO_ADDR
// p := [ ] ;
64890: LD_ADDR_VAR 0 11
64894: PUSH
64895: EMPTY
64896: ST_TO_ADDR
// if sort then
64897: LD_VAR 0 9
64901: IFFALSE 65017
// for i = 1 to 6 - eng do
64903: LD_ADDR_VAR 0 3
64907: PUSH
64908: DOUBLE
64909: LD_INT 1
64911: DEC
64912: ST_TO_ADDR
64913: LD_INT 6
64915: PUSH
64916: LD_VAR 0 6
64920: MINUS
64921: PUSH
64922: FOR_TO
64923: IFFALSE 65015
// begin if i = sort then
64925: LD_VAR 0 3
64929: PUSH
64930: LD_VAR 0 9
64934: EQUAL
64935: IFFALSE 64939
// break ;
64937: GO 65015
// if GetClass ( i ) = 2 then
64939: LD_VAR 0 3
64943: PPUSH
64944: CALL_OW 257
64948: PUSH
64949: LD_INT 2
64951: EQUAL
64952: IFFALSE 64956
// continue ;
64954: GO 64922
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64956: LD_ADDR_VAR 0 11
64960: PUSH
64961: LD_VAR 0 11
64965: PPUSH
64966: LD_VAR 0 11
64970: PUSH
64971: LD_INT 1
64973: PLUS
64974: PPUSH
64975: LD_VAR 0 9
64979: PUSH
64980: LD_VAR 0 3
64984: ARRAY
64985: PPUSH
64986: CALL_OW 2
64990: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64991: LD_ADDR_VAR 0 4
64995: PUSH
64996: LD_VAR 0 4
65000: PUSH
65001: LD_VAR 0 9
65005: PUSH
65006: LD_VAR 0 3
65010: ARRAY
65011: DIFF
65012: ST_TO_ADDR
// end ;
65013: GO 64922
65015: POP
65016: POP
// if p then
65017: LD_VAR 0 11
65021: IFFALSE 65046
// result := Replace ( result , 2 , p ) ;
65023: LD_ADDR_VAR 0 2
65027: PUSH
65028: LD_VAR 0 2
65032: PPUSH
65033: LD_INT 2
65035: PPUSH
65036: LD_VAR 0 11
65040: PPUSH
65041: CALL_OW 1
65045: ST_TO_ADDR
// end ; exit ;
65046: GO 65770
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
65048: LD_EXP 88
65052: PUSH
65053: LD_EXP 87
65057: PUSH
65058: LD_VAR 0 1
65062: ARRAY
65063: ARRAY
65064: NOT
65065: PUSH
65066: LD_EXP 61
65070: PUSH
65071: LD_VAR 0 1
65075: ARRAY
65076: PPUSH
65077: LD_INT 30
65079: PUSH
65080: LD_INT 3
65082: PUSH
65083: EMPTY
65084: LIST
65085: LIST
65086: PPUSH
65087: CALL_OW 72
65091: AND
65092: PUSH
65093: LD_EXP 66
65097: PUSH
65098: LD_VAR 0 1
65102: ARRAY
65103: NOT
65104: AND
65105: IFFALSE 65770
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
65107: LD_ADDR_EXP 103
65111: PUSH
65112: LD_EXP 103
65116: PPUSH
65117: LD_VAR 0 1
65121: PPUSH
65122: LD_INT 6
65124: PPUSH
65125: CALL_OW 1
65129: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65130: LD_ADDR_VAR 0 2
65134: PUSH
65135: LD_INT 0
65137: PUSH
65138: LD_INT 0
65140: PUSH
65141: LD_INT 0
65143: PUSH
65144: LD_INT 0
65146: PUSH
65147: EMPTY
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: ST_TO_ADDR
// if sci >= 1 then
65153: LD_VAR 0 8
65157: PUSH
65158: LD_INT 1
65160: GREATEREQUAL
65161: IFFALSE 65183
// tmp := tmp diff sci [ 1 ] ;
65163: LD_ADDR_VAR 0 4
65167: PUSH
65168: LD_VAR 0 4
65172: PUSH
65173: LD_VAR 0 8
65177: PUSH
65178: LD_INT 1
65180: ARRAY
65181: DIFF
65182: ST_TO_ADDR
// if tmp and not sci then
65183: LD_VAR 0 4
65187: PUSH
65188: LD_VAR 0 8
65192: NOT
65193: AND
65194: IFFALSE 65263
// begin sort := SortBySkill ( tmp , 4 ) ;
65196: LD_ADDR_VAR 0 9
65200: PUSH
65201: LD_VAR 0 4
65205: PPUSH
65206: LD_INT 4
65208: PPUSH
65209: CALL 51707 0 2
65213: ST_TO_ADDR
// if sort then
65214: LD_VAR 0 9
65218: IFFALSE 65234
// p := sort [ 1 ] ;
65220: LD_ADDR_VAR 0 11
65224: PUSH
65225: LD_VAR 0 9
65229: PUSH
65230: LD_INT 1
65232: ARRAY
65233: ST_TO_ADDR
// if p then
65234: LD_VAR 0 11
65238: IFFALSE 65263
// result := Replace ( result , 4 , p ) ;
65240: LD_ADDR_VAR 0 2
65244: PUSH
65245: LD_VAR 0 2
65249: PPUSH
65250: LD_INT 4
65252: PPUSH
65253: LD_VAR 0 11
65257: PPUSH
65258: CALL_OW 1
65262: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
65263: LD_ADDR_VAR 0 4
65267: PUSH
65268: LD_VAR 0 4
65272: PUSH
65273: LD_VAR 0 7
65277: DIFF
65278: ST_TO_ADDR
// if tmp and mech < 6 then
65279: LD_VAR 0 4
65283: PUSH
65284: LD_VAR 0 7
65288: PUSH
65289: LD_INT 6
65291: LESS
65292: AND
65293: IFFALSE 65475
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
65295: LD_ADDR_VAR 0 9
65299: PUSH
65300: LD_VAR 0 4
65304: PUSH
65305: LD_VAR 0 7
65309: DIFF
65310: PPUSH
65311: LD_INT 3
65313: PPUSH
65314: CALL 51707 0 2
65318: ST_TO_ADDR
// p := [ ] ;
65319: LD_ADDR_VAR 0 11
65323: PUSH
65324: EMPTY
65325: ST_TO_ADDR
// if sort then
65326: LD_VAR 0 9
65330: IFFALSE 65446
// for i = 1 to 6 - mech do
65332: LD_ADDR_VAR 0 3
65336: PUSH
65337: DOUBLE
65338: LD_INT 1
65340: DEC
65341: ST_TO_ADDR
65342: LD_INT 6
65344: PUSH
65345: LD_VAR 0 7
65349: MINUS
65350: PUSH
65351: FOR_TO
65352: IFFALSE 65444
// begin if i = sort then
65354: LD_VAR 0 3
65358: PUSH
65359: LD_VAR 0 9
65363: EQUAL
65364: IFFALSE 65368
// break ;
65366: GO 65444
// if GetClass ( i ) = 3 then
65368: LD_VAR 0 3
65372: PPUSH
65373: CALL_OW 257
65377: PUSH
65378: LD_INT 3
65380: EQUAL
65381: IFFALSE 65385
// continue ;
65383: GO 65351
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65385: LD_ADDR_VAR 0 11
65389: PUSH
65390: LD_VAR 0 11
65394: PPUSH
65395: LD_VAR 0 11
65399: PUSH
65400: LD_INT 1
65402: PLUS
65403: PPUSH
65404: LD_VAR 0 9
65408: PUSH
65409: LD_VAR 0 3
65413: ARRAY
65414: PPUSH
65415: CALL_OW 2
65419: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65420: LD_ADDR_VAR 0 4
65424: PUSH
65425: LD_VAR 0 4
65429: PUSH
65430: LD_VAR 0 9
65434: PUSH
65435: LD_VAR 0 3
65439: ARRAY
65440: DIFF
65441: ST_TO_ADDR
// end ;
65442: GO 65351
65444: POP
65445: POP
// if p then
65446: LD_VAR 0 11
65450: IFFALSE 65475
// result := Replace ( result , 3 , p ) ;
65452: LD_ADDR_VAR 0 2
65456: PUSH
65457: LD_VAR 0 2
65461: PPUSH
65462: LD_INT 3
65464: PPUSH
65465: LD_VAR 0 11
65469: PPUSH
65470: CALL_OW 1
65474: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65475: LD_ADDR_VAR 0 4
65479: PUSH
65480: LD_VAR 0 4
65484: PUSH
65485: LD_VAR 0 6
65489: DIFF
65490: ST_TO_ADDR
// if tmp and eng < 4 then
65491: LD_VAR 0 4
65495: PUSH
65496: LD_VAR 0 6
65500: PUSH
65501: LD_INT 4
65503: LESS
65504: AND
65505: IFFALSE 65695
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65507: LD_ADDR_VAR 0 9
65511: PUSH
65512: LD_VAR 0 4
65516: PUSH
65517: LD_VAR 0 7
65521: PUSH
65522: LD_VAR 0 6
65526: UNION
65527: DIFF
65528: PPUSH
65529: LD_INT 2
65531: PPUSH
65532: CALL 51707 0 2
65536: ST_TO_ADDR
// p := [ ] ;
65537: LD_ADDR_VAR 0 11
65541: PUSH
65542: EMPTY
65543: ST_TO_ADDR
// if sort then
65544: LD_VAR 0 9
65548: IFFALSE 65664
// for i = 1 to 4 - eng do
65550: LD_ADDR_VAR 0 3
65554: PUSH
65555: DOUBLE
65556: LD_INT 1
65558: DEC
65559: ST_TO_ADDR
65560: LD_INT 4
65562: PUSH
65563: LD_VAR 0 6
65567: MINUS
65568: PUSH
65569: FOR_TO
65570: IFFALSE 65662
// begin if i = sort then
65572: LD_VAR 0 3
65576: PUSH
65577: LD_VAR 0 9
65581: EQUAL
65582: IFFALSE 65586
// break ;
65584: GO 65662
// if GetClass ( i ) = 2 then
65586: LD_VAR 0 3
65590: PPUSH
65591: CALL_OW 257
65595: PUSH
65596: LD_INT 2
65598: EQUAL
65599: IFFALSE 65603
// continue ;
65601: GO 65569
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65603: LD_ADDR_VAR 0 11
65607: PUSH
65608: LD_VAR 0 11
65612: PPUSH
65613: LD_VAR 0 11
65617: PUSH
65618: LD_INT 1
65620: PLUS
65621: PPUSH
65622: LD_VAR 0 9
65626: PUSH
65627: LD_VAR 0 3
65631: ARRAY
65632: PPUSH
65633: CALL_OW 2
65637: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65638: LD_ADDR_VAR 0 4
65642: PUSH
65643: LD_VAR 0 4
65647: PUSH
65648: LD_VAR 0 9
65652: PUSH
65653: LD_VAR 0 3
65657: ARRAY
65658: DIFF
65659: ST_TO_ADDR
// end ;
65660: GO 65569
65662: POP
65663: POP
// if p then
65664: LD_VAR 0 11
65668: IFFALSE 65693
// result := Replace ( result , 2 , p ) ;
65670: LD_ADDR_VAR 0 2
65674: PUSH
65675: LD_VAR 0 2
65679: PPUSH
65680: LD_INT 2
65682: PPUSH
65683: LD_VAR 0 11
65687: PPUSH
65688: CALL_OW 1
65692: ST_TO_ADDR
// end else
65693: GO 65739
// for i = eng downto 5 do
65695: LD_ADDR_VAR 0 3
65699: PUSH
65700: DOUBLE
65701: LD_VAR 0 6
65705: INC
65706: ST_TO_ADDR
65707: LD_INT 5
65709: PUSH
65710: FOR_DOWNTO
65711: IFFALSE 65737
// tmp := tmp union eng [ i ] ;
65713: LD_ADDR_VAR 0 4
65717: PUSH
65718: LD_VAR 0 4
65722: PUSH
65723: LD_VAR 0 6
65727: PUSH
65728: LD_VAR 0 3
65732: ARRAY
65733: UNION
65734: ST_TO_ADDR
65735: GO 65710
65737: POP
65738: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65739: LD_ADDR_VAR 0 2
65743: PUSH
65744: LD_VAR 0 2
65748: PPUSH
65749: LD_INT 1
65751: PPUSH
65752: LD_VAR 0 4
65756: PUSH
65757: LD_VAR 0 5
65761: DIFF
65762: PPUSH
65763: CALL_OW 1
65767: ST_TO_ADDR
// exit ;
65768: GO 65770
// end ; end ;
65770: LD_VAR 0 2
65774: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65775: LD_INT 0
65777: PPUSH
65778: PPUSH
65779: PPUSH
// if not mc_bases then
65780: LD_EXP 61
65784: NOT
65785: IFFALSE 65789
// exit ;
65787: GO 65931
// for i = 1 to mc_bases do
65789: LD_ADDR_VAR 0 2
65793: PUSH
65794: DOUBLE
65795: LD_INT 1
65797: DEC
65798: ST_TO_ADDR
65799: LD_EXP 61
65803: PUSH
65804: FOR_TO
65805: IFFALSE 65922
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65807: LD_ADDR_VAR 0 3
65811: PUSH
65812: LD_EXP 61
65816: PUSH
65817: LD_VAR 0 2
65821: ARRAY
65822: PPUSH
65823: LD_INT 21
65825: PUSH
65826: LD_INT 3
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: PUSH
65833: LD_INT 3
65835: PUSH
65836: LD_INT 2
65838: PUSH
65839: LD_INT 30
65841: PUSH
65842: LD_INT 29
65844: PUSH
65845: EMPTY
65846: LIST
65847: LIST
65848: PUSH
65849: LD_INT 30
65851: PUSH
65852: LD_INT 30
65854: PUSH
65855: EMPTY
65856: LIST
65857: LIST
65858: PUSH
65859: EMPTY
65860: LIST
65861: LIST
65862: LIST
65863: PUSH
65864: EMPTY
65865: LIST
65866: LIST
65867: PUSH
65868: LD_INT 3
65870: PUSH
65871: LD_INT 24
65873: PUSH
65874: LD_INT 1000
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: PUSH
65881: EMPTY
65882: LIST
65883: LIST
65884: PUSH
65885: EMPTY
65886: LIST
65887: LIST
65888: LIST
65889: PPUSH
65890: CALL_OW 72
65894: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65895: LD_ADDR_EXP 62
65899: PUSH
65900: LD_EXP 62
65904: PPUSH
65905: LD_VAR 0 2
65909: PPUSH
65910: LD_VAR 0 3
65914: PPUSH
65915: CALL_OW 1
65919: ST_TO_ADDR
// end ;
65920: GO 65804
65922: POP
65923: POP
// RaiseSailEvent ( 101 ) ;
65924: LD_INT 101
65926: PPUSH
65927: CALL_OW 427
// end ;
65931: LD_VAR 0 1
65935: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65936: LD_INT 0
65938: PPUSH
65939: PPUSH
65940: PPUSH
65941: PPUSH
65942: PPUSH
65943: PPUSH
65944: PPUSH
// if not mc_bases then
65945: LD_EXP 61
65949: NOT
65950: IFFALSE 65954
// exit ;
65952: GO 66516
// for i = 1 to mc_bases do
65954: LD_ADDR_VAR 0 2
65958: PUSH
65959: DOUBLE
65960: LD_INT 1
65962: DEC
65963: ST_TO_ADDR
65964: LD_EXP 61
65968: PUSH
65969: FOR_TO
65970: IFFALSE 66507
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
65972: LD_ADDR_VAR 0 5
65976: PUSH
65977: LD_EXP 61
65981: PUSH
65982: LD_VAR 0 2
65986: ARRAY
65987: PUSH
65988: LD_EXP 90
65992: PUSH
65993: LD_VAR 0 2
65997: ARRAY
65998: UNION
65999: PPUSH
66000: LD_INT 21
66002: PUSH
66003: LD_INT 1
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: PUSH
66010: LD_INT 1
66012: PUSH
66013: LD_INT 3
66015: PUSH
66016: LD_INT 54
66018: PUSH
66019: EMPTY
66020: LIST
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 3
66028: PUSH
66029: LD_INT 24
66031: PUSH
66032: LD_INT 1000
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: EMPTY
66040: LIST
66041: LIST
66042: PUSH
66043: EMPTY
66044: LIST
66045: LIST
66046: LIST
66047: PUSH
66048: EMPTY
66049: LIST
66050: LIST
66051: PPUSH
66052: CALL_OW 72
66056: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
66057: LD_ADDR_VAR 0 6
66061: PUSH
66062: LD_EXP 61
66066: PUSH
66067: LD_VAR 0 2
66071: ARRAY
66072: PPUSH
66073: LD_INT 21
66075: PUSH
66076: LD_INT 1
66078: PUSH
66079: EMPTY
66080: LIST
66081: LIST
66082: PUSH
66083: LD_INT 1
66085: PUSH
66086: LD_INT 3
66088: PUSH
66089: LD_INT 54
66091: PUSH
66092: EMPTY
66093: LIST
66094: PUSH
66095: EMPTY
66096: LIST
66097: LIST
66098: PUSH
66099: LD_INT 3
66101: PUSH
66102: LD_INT 24
66104: PUSH
66105: LD_INT 250
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: PUSH
66112: EMPTY
66113: LIST
66114: LIST
66115: PUSH
66116: EMPTY
66117: LIST
66118: LIST
66119: LIST
66120: PUSH
66121: EMPTY
66122: LIST
66123: LIST
66124: PPUSH
66125: CALL_OW 72
66129: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
66130: LD_ADDR_VAR 0 7
66134: PUSH
66135: LD_VAR 0 5
66139: PUSH
66140: LD_VAR 0 6
66144: DIFF
66145: ST_TO_ADDR
// if not need_heal_1 then
66146: LD_VAR 0 6
66150: NOT
66151: IFFALSE 66184
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
66153: LD_ADDR_EXP 64
66157: PUSH
66158: LD_EXP 64
66162: PPUSH
66163: LD_VAR 0 2
66167: PUSH
66168: LD_INT 1
66170: PUSH
66171: EMPTY
66172: LIST
66173: LIST
66174: PPUSH
66175: EMPTY
66176: PPUSH
66177: CALL 20463 0 3
66181: ST_TO_ADDR
66182: GO 66254
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
66184: LD_ADDR_EXP 64
66188: PUSH
66189: LD_EXP 64
66193: PPUSH
66194: LD_VAR 0 2
66198: PUSH
66199: LD_INT 1
66201: PUSH
66202: EMPTY
66203: LIST
66204: LIST
66205: PPUSH
66206: LD_EXP 64
66210: PUSH
66211: LD_VAR 0 2
66215: ARRAY
66216: PUSH
66217: LD_INT 1
66219: ARRAY
66220: PPUSH
66221: LD_INT 3
66223: PUSH
66224: LD_INT 24
66226: PUSH
66227: LD_INT 1000
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: PPUSH
66238: CALL_OW 72
66242: PUSH
66243: LD_VAR 0 6
66247: UNION
66248: PPUSH
66249: CALL 20463 0 3
66253: ST_TO_ADDR
// if not need_heal_2 then
66254: LD_VAR 0 7
66258: NOT
66259: IFFALSE 66292
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
66261: LD_ADDR_EXP 64
66265: PUSH
66266: LD_EXP 64
66270: PPUSH
66271: LD_VAR 0 2
66275: PUSH
66276: LD_INT 2
66278: PUSH
66279: EMPTY
66280: LIST
66281: LIST
66282: PPUSH
66283: EMPTY
66284: PPUSH
66285: CALL 20463 0 3
66289: ST_TO_ADDR
66290: GO 66324
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
66292: LD_ADDR_EXP 64
66296: PUSH
66297: LD_EXP 64
66301: PPUSH
66302: LD_VAR 0 2
66306: PUSH
66307: LD_INT 2
66309: PUSH
66310: EMPTY
66311: LIST
66312: LIST
66313: PPUSH
66314: LD_VAR 0 7
66318: PPUSH
66319: CALL 20463 0 3
66323: ST_TO_ADDR
// if need_heal_2 then
66324: LD_VAR 0 7
66328: IFFALSE 66489
// for j in need_heal_2 do
66330: LD_ADDR_VAR 0 3
66334: PUSH
66335: LD_VAR 0 7
66339: PUSH
66340: FOR_IN
66341: IFFALSE 66487
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66343: LD_ADDR_VAR 0 5
66347: PUSH
66348: LD_EXP 61
66352: PUSH
66353: LD_VAR 0 2
66357: ARRAY
66358: PPUSH
66359: LD_INT 2
66361: PUSH
66362: LD_INT 30
66364: PUSH
66365: LD_INT 6
66367: PUSH
66368: EMPTY
66369: LIST
66370: LIST
66371: PUSH
66372: LD_INT 30
66374: PUSH
66375: LD_INT 7
66377: PUSH
66378: EMPTY
66379: LIST
66380: LIST
66381: PUSH
66382: LD_INT 30
66384: PUSH
66385: LD_INT 8
66387: PUSH
66388: EMPTY
66389: LIST
66390: LIST
66391: PUSH
66392: LD_INT 30
66394: PUSH
66395: LD_INT 0
66397: PUSH
66398: EMPTY
66399: LIST
66400: LIST
66401: PUSH
66402: LD_INT 30
66404: PUSH
66405: LD_INT 1
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: EMPTY
66413: LIST
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: LIST
66419: PPUSH
66420: CALL_OW 72
66424: ST_TO_ADDR
// if tmp then
66425: LD_VAR 0 5
66429: IFFALSE 66485
// begin k := NearestUnitToUnit ( tmp , j ) ;
66431: LD_ADDR_VAR 0 4
66435: PUSH
66436: LD_VAR 0 5
66440: PPUSH
66441: LD_VAR 0 3
66445: PPUSH
66446: CALL_OW 74
66450: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
66451: LD_VAR 0 3
66455: PPUSH
66456: LD_VAR 0 4
66460: PPUSH
66461: CALL_OW 296
66465: PUSH
66466: LD_INT 5
66468: GREATER
66469: IFFALSE 66485
// ComMoveToNearbyEntrance ( j , k ) ;
66471: LD_VAR 0 3
66475: PPUSH
66476: LD_VAR 0 4
66480: PPUSH
66481: CALL 54080 0 2
// end ; end ;
66485: GO 66340
66487: POP
66488: POP
// if not need_heal_1 and not need_heal_2 then
66489: LD_VAR 0 6
66493: NOT
66494: PUSH
66495: LD_VAR 0 7
66499: NOT
66500: AND
66501: IFFALSE 66505
// continue ;
66503: GO 65969
// end ;
66505: GO 65969
66507: POP
66508: POP
// RaiseSailEvent ( 102 ) ;
66509: LD_INT 102
66511: PPUSH
66512: CALL_OW 427
// end ;
66516: LD_VAR 0 1
66520: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
66521: LD_INT 0
66523: PPUSH
66524: PPUSH
66525: PPUSH
66526: PPUSH
66527: PPUSH
66528: PPUSH
66529: PPUSH
66530: PPUSH
// if not mc_bases then
66531: LD_EXP 61
66535: NOT
66536: IFFALSE 66540
// exit ;
66538: GO 67451
// for i = 1 to mc_bases do
66540: LD_ADDR_VAR 0 2
66544: PUSH
66545: DOUBLE
66546: LD_INT 1
66548: DEC
66549: ST_TO_ADDR
66550: LD_EXP 61
66554: PUSH
66555: FOR_TO
66556: IFFALSE 67449
// begin if not mc_building_need_repair [ i ] then
66558: LD_EXP 62
66562: PUSH
66563: LD_VAR 0 2
66567: ARRAY
66568: NOT
66569: IFFALSE 66754
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
66571: LD_ADDR_VAR 0 6
66575: PUSH
66576: LD_EXP 80
66580: PUSH
66581: LD_VAR 0 2
66585: ARRAY
66586: PPUSH
66587: LD_INT 3
66589: PUSH
66590: LD_INT 24
66592: PUSH
66593: LD_INT 1000
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: LD_INT 2
66606: PUSH
66607: LD_INT 34
66609: PUSH
66610: LD_INT 13
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PUSH
66617: LD_INT 34
66619: PUSH
66620: LD_INT 52
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 34
66629: PUSH
66630: LD_INT 88
66632: PUSH
66633: EMPTY
66634: LIST
66635: LIST
66636: PUSH
66637: EMPTY
66638: LIST
66639: LIST
66640: LIST
66641: LIST
66642: PUSH
66643: EMPTY
66644: LIST
66645: LIST
66646: PPUSH
66647: CALL_OW 72
66651: ST_TO_ADDR
// if cranes then
66652: LD_VAR 0 6
66656: IFFALSE 66718
// for j in cranes do
66658: LD_ADDR_VAR 0 3
66662: PUSH
66663: LD_VAR 0 6
66667: PUSH
66668: FOR_IN
66669: IFFALSE 66716
// if not IsInArea ( j , mc_parking [ i ] ) then
66671: LD_VAR 0 3
66675: PPUSH
66676: LD_EXP 85
66680: PUSH
66681: LD_VAR 0 2
66685: ARRAY
66686: PPUSH
66687: CALL_OW 308
66691: NOT
66692: IFFALSE 66714
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66694: LD_VAR 0 3
66698: PPUSH
66699: LD_EXP 85
66703: PUSH
66704: LD_VAR 0 2
66708: ARRAY
66709: PPUSH
66710: CALL_OW 113
66714: GO 66668
66716: POP
66717: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66718: LD_ADDR_EXP 63
66722: PUSH
66723: LD_EXP 63
66727: PPUSH
66728: LD_VAR 0 2
66732: PPUSH
66733: EMPTY
66734: PPUSH
66735: CALL_OW 1
66739: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66740: LD_VAR 0 2
66744: PPUSH
66745: LD_INT 101
66747: PPUSH
66748: CALL 61594 0 2
// continue ;
66752: GO 66555
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66754: LD_ADDR_EXP 67
66758: PUSH
66759: LD_EXP 67
66763: PPUSH
66764: LD_VAR 0 2
66768: PPUSH
66769: EMPTY
66770: PPUSH
66771: CALL_OW 1
66775: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66776: LD_VAR 0 2
66780: PPUSH
66781: LD_INT 103
66783: PPUSH
66784: CALL 61594 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66788: LD_ADDR_VAR 0 5
66792: PUSH
66793: LD_EXP 61
66797: PUSH
66798: LD_VAR 0 2
66802: ARRAY
66803: PUSH
66804: LD_EXP 90
66808: PUSH
66809: LD_VAR 0 2
66813: ARRAY
66814: UNION
66815: PPUSH
66816: LD_INT 2
66818: PUSH
66819: LD_INT 25
66821: PUSH
66822: LD_INT 2
66824: PUSH
66825: EMPTY
66826: LIST
66827: LIST
66828: PUSH
66829: LD_INT 25
66831: PUSH
66832: LD_INT 16
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: EMPTY
66840: LIST
66841: LIST
66842: LIST
66843: PUSH
66844: EMPTY
66845: LIST
66846: PPUSH
66847: CALL_OW 72
66851: ST_TO_ADDR
// if mc_need_heal [ i ] then
66852: LD_EXP 64
66856: PUSH
66857: LD_VAR 0 2
66861: ARRAY
66862: IFFALSE 66906
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
66864: LD_ADDR_VAR 0 5
66868: PUSH
66869: LD_VAR 0 5
66873: PUSH
66874: LD_EXP 64
66878: PUSH
66879: LD_VAR 0 2
66883: ARRAY
66884: PUSH
66885: LD_INT 1
66887: ARRAY
66888: PUSH
66889: LD_EXP 64
66893: PUSH
66894: LD_VAR 0 2
66898: ARRAY
66899: PUSH
66900: LD_INT 2
66902: ARRAY
66903: UNION
66904: DIFF
66905: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
66906: LD_ADDR_VAR 0 6
66910: PUSH
66911: LD_EXP 80
66915: PUSH
66916: LD_VAR 0 2
66920: ARRAY
66921: PPUSH
66922: LD_INT 2
66924: PUSH
66925: LD_INT 34
66927: PUSH
66928: LD_INT 13
66930: PUSH
66931: EMPTY
66932: LIST
66933: LIST
66934: PUSH
66935: LD_INT 34
66937: PUSH
66938: LD_INT 52
66940: PUSH
66941: EMPTY
66942: LIST
66943: LIST
66944: PUSH
66945: LD_INT 34
66947: PUSH
66948: LD_INT 88
66950: PUSH
66951: EMPTY
66952: LIST
66953: LIST
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: LIST
66959: LIST
66960: PPUSH
66961: CALL_OW 72
66965: ST_TO_ADDR
// if cranes then
66966: LD_VAR 0 6
66970: IFFALSE 67138
// begin for j in cranes do
66972: LD_ADDR_VAR 0 3
66976: PUSH
66977: LD_VAR 0 6
66981: PUSH
66982: FOR_IN
66983: IFFALSE 67136
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
66985: LD_VAR 0 3
66989: PPUSH
66990: CALL_OW 256
66994: PUSH
66995: LD_INT 1000
66997: EQUAL
66998: PUSH
66999: LD_VAR 0 3
67003: PPUSH
67004: CALL_OW 314
67008: NOT
67009: AND
67010: IFFALSE 67076
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
67012: LD_ADDR_VAR 0 8
67016: PUSH
67017: LD_EXP 62
67021: PUSH
67022: LD_VAR 0 2
67026: ARRAY
67027: PPUSH
67028: LD_VAR 0 3
67032: PPUSH
67033: CALL_OW 74
67037: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
67038: LD_VAR 0 8
67042: PPUSH
67043: LD_INT 16
67045: PPUSH
67046: CALL 23428 0 2
67050: PUSH
67051: LD_INT 4
67053: ARRAY
67054: PUSH
67055: LD_INT 10
67057: LESS
67058: IFFALSE 67074
// ComRepairBuilding ( j , to_repair ) ;
67060: LD_VAR 0 3
67064: PPUSH
67065: LD_VAR 0 8
67069: PPUSH
67070: CALL_OW 130
// end else
67074: GO 67134
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
67076: LD_VAR 0 3
67080: PPUSH
67081: CALL_OW 256
67085: PUSH
67086: LD_INT 500
67088: LESS
67089: PUSH
67090: LD_VAR 0 3
67094: PPUSH
67095: LD_EXP 85
67099: PUSH
67100: LD_VAR 0 2
67104: ARRAY
67105: PPUSH
67106: CALL_OW 308
67110: NOT
67111: AND
67112: IFFALSE 67134
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67114: LD_VAR 0 3
67118: PPUSH
67119: LD_EXP 85
67123: PUSH
67124: LD_VAR 0 2
67128: ARRAY
67129: PPUSH
67130: CALL_OW 113
// end ;
67134: GO 66982
67136: POP
67137: POP
// end ; if tmp > 3 then
67138: LD_VAR 0 5
67142: PUSH
67143: LD_INT 3
67145: GREATER
67146: IFFALSE 67166
// tmp := ShrinkArray ( tmp , 4 ) ;
67148: LD_ADDR_VAR 0 5
67152: PUSH
67153: LD_VAR 0 5
67157: PPUSH
67158: LD_INT 4
67160: PPUSH
67161: CALL 53518 0 2
67165: ST_TO_ADDR
// if not tmp then
67166: LD_VAR 0 5
67170: NOT
67171: IFFALSE 67175
// continue ;
67173: GO 66555
// for j in tmp do
67175: LD_ADDR_VAR 0 3
67179: PUSH
67180: LD_VAR 0 5
67184: PUSH
67185: FOR_IN
67186: IFFALSE 67445
// begin if IsInUnit ( j ) then
67188: LD_VAR 0 3
67192: PPUSH
67193: CALL_OW 310
67197: IFFALSE 67208
// ComExitBuilding ( j ) ;
67199: LD_VAR 0 3
67203: PPUSH
67204: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
67208: LD_VAR 0 3
67212: PUSH
67213: LD_EXP 63
67217: PUSH
67218: LD_VAR 0 2
67222: ARRAY
67223: IN
67224: NOT
67225: IFFALSE 67283
// begin SetTag ( j , 101 ) ;
67227: LD_VAR 0 3
67231: PPUSH
67232: LD_INT 101
67234: PPUSH
67235: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
67239: LD_ADDR_EXP 63
67243: PUSH
67244: LD_EXP 63
67248: PPUSH
67249: LD_VAR 0 2
67253: PUSH
67254: LD_EXP 63
67258: PUSH
67259: LD_VAR 0 2
67263: ARRAY
67264: PUSH
67265: LD_INT 1
67267: PLUS
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PPUSH
67273: LD_VAR 0 3
67277: PPUSH
67278: CALL 20463 0 3
67282: ST_TO_ADDR
// end ; wait ( 1 ) ;
67283: LD_INT 1
67285: PPUSH
67286: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
67290: LD_ADDR_VAR 0 7
67294: PUSH
67295: LD_EXP 62
67299: PUSH
67300: LD_VAR 0 2
67304: ARRAY
67305: ST_TO_ADDR
// if mc_scan [ i ] then
67306: LD_EXP 84
67310: PUSH
67311: LD_VAR 0 2
67315: ARRAY
67316: IFFALSE 67378
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
67318: LD_ADDR_VAR 0 7
67322: PUSH
67323: LD_EXP 62
67327: PUSH
67328: LD_VAR 0 2
67332: ARRAY
67333: PPUSH
67334: LD_INT 3
67336: PUSH
67337: LD_INT 30
67339: PUSH
67340: LD_INT 32
67342: PUSH
67343: EMPTY
67344: LIST
67345: LIST
67346: PUSH
67347: LD_INT 30
67349: PUSH
67350: LD_INT 33
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: PUSH
67357: LD_INT 30
67359: PUSH
67360: LD_INT 31
67362: PUSH
67363: EMPTY
67364: LIST
67365: LIST
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: LIST
67371: LIST
67372: PPUSH
67373: CALL_OW 72
67377: ST_TO_ADDR
// if not to_repair_tmp then
67378: LD_VAR 0 7
67382: NOT
67383: IFFALSE 67387
// continue ;
67385: GO 67185
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
67387: LD_ADDR_VAR 0 8
67391: PUSH
67392: LD_VAR 0 7
67396: PPUSH
67397: LD_VAR 0 3
67401: PPUSH
67402: CALL_OW 74
67406: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
67407: LD_VAR 0 8
67411: PPUSH
67412: LD_INT 16
67414: PPUSH
67415: CALL 23428 0 2
67419: PUSH
67420: LD_INT 4
67422: ARRAY
67423: PUSH
67424: LD_INT 14
67426: LESS
67427: IFFALSE 67443
// ComRepairBuilding ( j , to_repair ) ;
67429: LD_VAR 0 3
67433: PPUSH
67434: LD_VAR 0 8
67438: PPUSH
67439: CALL_OW 130
// end ;
67443: GO 67185
67445: POP
67446: POP
// end ;
67447: GO 66555
67449: POP
67450: POP
// end ;
67451: LD_VAR 0 1
67455: RET
// export function MC_Heal ; var i , j , tmp ; begin
67456: LD_INT 0
67458: PPUSH
67459: PPUSH
67460: PPUSH
67461: PPUSH
// if not mc_bases then
67462: LD_EXP 61
67466: NOT
67467: IFFALSE 67471
// exit ;
67469: GO 67873
// for i = 1 to mc_bases do
67471: LD_ADDR_VAR 0 2
67475: PUSH
67476: DOUBLE
67477: LD_INT 1
67479: DEC
67480: ST_TO_ADDR
67481: LD_EXP 61
67485: PUSH
67486: FOR_TO
67487: IFFALSE 67871
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
67489: LD_EXP 64
67493: PUSH
67494: LD_VAR 0 2
67498: ARRAY
67499: PUSH
67500: LD_INT 1
67502: ARRAY
67503: NOT
67504: PUSH
67505: LD_EXP 64
67509: PUSH
67510: LD_VAR 0 2
67514: ARRAY
67515: PUSH
67516: LD_INT 2
67518: ARRAY
67519: NOT
67520: AND
67521: IFFALSE 67559
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
67523: LD_ADDR_EXP 65
67527: PUSH
67528: LD_EXP 65
67532: PPUSH
67533: LD_VAR 0 2
67537: PPUSH
67538: EMPTY
67539: PPUSH
67540: CALL_OW 1
67544: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
67545: LD_VAR 0 2
67549: PPUSH
67550: LD_INT 102
67552: PPUSH
67553: CALL 61594 0 2
// continue ;
67557: GO 67486
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67559: LD_ADDR_VAR 0 4
67563: PUSH
67564: LD_EXP 61
67568: PUSH
67569: LD_VAR 0 2
67573: ARRAY
67574: PPUSH
67575: LD_INT 25
67577: PUSH
67578: LD_INT 4
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PPUSH
67585: CALL_OW 72
67589: ST_TO_ADDR
// if not tmp then
67590: LD_VAR 0 4
67594: NOT
67595: IFFALSE 67599
// continue ;
67597: GO 67486
// if mc_taming [ i ] then
67599: LD_EXP 92
67603: PUSH
67604: LD_VAR 0 2
67608: ARRAY
67609: IFFALSE 67633
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67611: LD_ADDR_EXP 92
67615: PUSH
67616: LD_EXP 92
67620: PPUSH
67621: LD_VAR 0 2
67625: PPUSH
67626: EMPTY
67627: PPUSH
67628: CALL_OW 1
67632: ST_TO_ADDR
// for j in tmp do
67633: LD_ADDR_VAR 0 3
67637: PUSH
67638: LD_VAR 0 4
67642: PUSH
67643: FOR_IN
67644: IFFALSE 67867
// begin if IsInUnit ( j ) then
67646: LD_VAR 0 3
67650: PPUSH
67651: CALL_OW 310
67655: IFFALSE 67666
// ComExitBuilding ( j ) ;
67657: LD_VAR 0 3
67661: PPUSH
67662: CALL_OW 122
// if not j in mc_healers [ i ] then
67666: LD_VAR 0 3
67670: PUSH
67671: LD_EXP 65
67675: PUSH
67676: LD_VAR 0 2
67680: ARRAY
67681: IN
67682: NOT
67683: IFFALSE 67729
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67685: LD_ADDR_EXP 65
67689: PUSH
67690: LD_EXP 65
67694: PPUSH
67695: LD_VAR 0 2
67699: PUSH
67700: LD_EXP 65
67704: PUSH
67705: LD_VAR 0 2
67709: ARRAY
67710: PUSH
67711: LD_INT 1
67713: PLUS
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: PPUSH
67719: LD_VAR 0 3
67723: PPUSH
67724: CALL 20463 0 3
67728: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67729: LD_VAR 0 3
67733: PPUSH
67734: CALL_OW 110
67738: PUSH
67739: LD_INT 102
67741: NONEQUAL
67742: IFFALSE 67756
// SetTag ( j , 102 ) ;
67744: LD_VAR 0 3
67748: PPUSH
67749: LD_INT 102
67751: PPUSH
67752: CALL_OW 109
// Wait ( 3 ) ;
67756: LD_INT 3
67758: PPUSH
67759: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67763: LD_EXP 64
67767: PUSH
67768: LD_VAR 0 2
67772: ARRAY
67773: PUSH
67774: LD_INT 1
67776: ARRAY
67777: IFFALSE 67809
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67779: LD_VAR 0 3
67783: PPUSH
67784: LD_EXP 64
67788: PUSH
67789: LD_VAR 0 2
67793: ARRAY
67794: PUSH
67795: LD_INT 1
67797: ARRAY
67798: PUSH
67799: LD_INT 1
67801: ARRAY
67802: PPUSH
67803: CALL_OW 128
67807: GO 67865
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67809: LD_VAR 0 3
67813: PPUSH
67814: CALL_OW 314
67818: NOT
67819: PUSH
67820: LD_EXP 64
67824: PUSH
67825: LD_VAR 0 2
67829: ARRAY
67830: PUSH
67831: LD_INT 2
67833: ARRAY
67834: AND
67835: IFFALSE 67865
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67837: LD_VAR 0 3
67841: PPUSH
67842: LD_EXP 64
67846: PUSH
67847: LD_VAR 0 2
67851: ARRAY
67852: PUSH
67853: LD_INT 2
67855: ARRAY
67856: PUSH
67857: LD_INT 1
67859: ARRAY
67860: PPUSH
67861: CALL_OW 128
// end ;
67865: GO 67643
67867: POP
67868: POP
// end ;
67869: GO 67486
67871: POP
67872: POP
// end ;
67873: LD_VAR 0 1
67877: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
67878: LD_INT 0
67880: PPUSH
67881: PPUSH
67882: PPUSH
67883: PPUSH
67884: PPUSH
67885: PPUSH
// if not mc_bases then
67886: LD_EXP 61
67890: NOT
67891: IFFALSE 67895
// exit ;
67893: GO 69058
// for i = 1 to mc_bases do
67895: LD_ADDR_VAR 0 2
67899: PUSH
67900: DOUBLE
67901: LD_INT 1
67903: DEC
67904: ST_TO_ADDR
67905: LD_EXP 61
67909: PUSH
67910: FOR_TO
67911: IFFALSE 69056
// begin if mc_scan [ i ] then
67913: LD_EXP 84
67917: PUSH
67918: LD_VAR 0 2
67922: ARRAY
67923: IFFALSE 67927
// continue ;
67925: GO 67910
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67927: LD_EXP 66
67931: PUSH
67932: LD_VAR 0 2
67936: ARRAY
67937: NOT
67938: PUSH
67939: LD_EXP 68
67943: PUSH
67944: LD_VAR 0 2
67948: ARRAY
67949: NOT
67950: AND
67951: PUSH
67952: LD_EXP 67
67956: PUSH
67957: LD_VAR 0 2
67961: ARRAY
67962: AND
67963: IFFALSE 68001
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67965: LD_ADDR_EXP 67
67969: PUSH
67970: LD_EXP 67
67974: PPUSH
67975: LD_VAR 0 2
67979: PPUSH
67980: EMPTY
67981: PPUSH
67982: CALL_OW 1
67986: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67987: LD_VAR 0 2
67991: PPUSH
67992: LD_INT 103
67994: PPUSH
67995: CALL 61594 0 2
// continue ;
67999: GO 67910
// end ; if mc_construct_list [ i ] then
68001: LD_EXP 68
68005: PUSH
68006: LD_VAR 0 2
68010: ARRAY
68011: IFFALSE 68231
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68013: LD_ADDR_VAR 0 5
68017: PUSH
68018: LD_EXP 61
68022: PUSH
68023: LD_VAR 0 2
68027: ARRAY
68028: PPUSH
68029: LD_INT 25
68031: PUSH
68032: LD_INT 2
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PPUSH
68039: CALL_OW 72
68043: PUSH
68044: LD_EXP 63
68048: PUSH
68049: LD_VAR 0 2
68053: ARRAY
68054: DIFF
68055: ST_TO_ADDR
// if not tmp then
68056: LD_VAR 0 5
68060: NOT
68061: IFFALSE 68065
// continue ;
68063: GO 67910
// for j in tmp do
68065: LD_ADDR_VAR 0 3
68069: PUSH
68070: LD_VAR 0 5
68074: PUSH
68075: FOR_IN
68076: IFFALSE 68227
// begin if not mc_builders [ i ] then
68078: LD_EXP 67
68082: PUSH
68083: LD_VAR 0 2
68087: ARRAY
68088: NOT
68089: IFFALSE 68147
// begin SetTag ( j , 103 ) ;
68091: LD_VAR 0 3
68095: PPUSH
68096: LD_INT 103
68098: PPUSH
68099: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68103: LD_ADDR_EXP 67
68107: PUSH
68108: LD_EXP 67
68112: PPUSH
68113: LD_VAR 0 2
68117: PUSH
68118: LD_EXP 67
68122: PUSH
68123: LD_VAR 0 2
68127: ARRAY
68128: PUSH
68129: LD_INT 1
68131: PLUS
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: PPUSH
68137: LD_VAR 0 3
68141: PPUSH
68142: CALL 20463 0 3
68146: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68147: LD_VAR 0 3
68151: PPUSH
68152: CALL_OW 310
68156: IFFALSE 68167
// ComExitBuilding ( j ) ;
68158: LD_VAR 0 3
68162: PPUSH
68163: CALL_OW 122
// wait ( 3 ) ;
68167: LD_INT 3
68169: PPUSH
68170: CALL_OW 67
// if not mc_construct_list [ i ] then
68174: LD_EXP 68
68178: PUSH
68179: LD_VAR 0 2
68183: ARRAY
68184: NOT
68185: IFFALSE 68189
// break ;
68187: GO 68227
// if not HasTask ( j ) then
68189: LD_VAR 0 3
68193: PPUSH
68194: CALL_OW 314
68198: NOT
68199: IFFALSE 68225
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
68201: LD_VAR 0 3
68205: PPUSH
68206: LD_EXP 68
68210: PUSH
68211: LD_VAR 0 2
68215: ARRAY
68216: PUSH
68217: LD_INT 1
68219: ARRAY
68220: PPUSH
68221: CALL 23701 0 2
// end ;
68225: GO 68075
68227: POP
68228: POP
// end else
68229: GO 69054
// if mc_build_list [ i ] then
68231: LD_EXP 66
68235: PUSH
68236: LD_VAR 0 2
68240: ARRAY
68241: IFFALSE 69054
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
68243: LD_EXP 66
68247: PUSH
68248: LD_VAR 0 2
68252: ARRAY
68253: PUSH
68254: LD_INT 1
68256: ARRAY
68257: PUSH
68258: LD_INT 1
68260: ARRAY
68261: PPUSH
68262: CALL 23525 0 1
68266: PUSH
68267: LD_EXP 61
68271: PUSH
68272: LD_VAR 0 2
68276: ARRAY
68277: PPUSH
68278: LD_INT 2
68280: PUSH
68281: LD_INT 30
68283: PUSH
68284: LD_INT 2
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: PUSH
68291: LD_INT 30
68293: PUSH
68294: LD_INT 3
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: LIST
68305: PPUSH
68306: CALL_OW 72
68310: NOT
68311: AND
68312: IFFALSE 68417
// begin for j = 1 to mc_build_list [ i ] do
68314: LD_ADDR_VAR 0 3
68318: PUSH
68319: DOUBLE
68320: LD_INT 1
68322: DEC
68323: ST_TO_ADDR
68324: LD_EXP 66
68328: PUSH
68329: LD_VAR 0 2
68333: ARRAY
68334: PUSH
68335: FOR_TO
68336: IFFALSE 68415
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
68338: LD_EXP 66
68342: PUSH
68343: LD_VAR 0 2
68347: ARRAY
68348: PUSH
68349: LD_VAR 0 3
68353: ARRAY
68354: PUSH
68355: LD_INT 1
68357: ARRAY
68358: PUSH
68359: LD_INT 2
68361: EQUAL
68362: IFFALSE 68413
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
68364: LD_ADDR_EXP 66
68368: PUSH
68369: LD_EXP 66
68373: PPUSH
68374: LD_VAR 0 2
68378: PPUSH
68379: LD_EXP 66
68383: PUSH
68384: LD_VAR 0 2
68388: ARRAY
68389: PPUSH
68390: LD_VAR 0 3
68394: PPUSH
68395: LD_INT 1
68397: PPUSH
68398: LD_INT 0
68400: PPUSH
68401: CALL 19881 0 4
68405: PPUSH
68406: CALL_OW 1
68410: ST_TO_ADDR
// break ;
68411: GO 68415
// end ;
68413: GO 68335
68415: POP
68416: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68417: LD_ADDR_VAR 0 6
68421: PUSH
68422: LD_EXP 61
68426: PUSH
68427: LD_VAR 0 2
68431: ARRAY
68432: PPUSH
68433: LD_INT 2
68435: PUSH
68436: LD_INT 30
68438: PUSH
68439: LD_INT 0
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PUSH
68446: LD_INT 30
68448: PUSH
68449: LD_INT 1
68451: PUSH
68452: EMPTY
68453: LIST
68454: LIST
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: LIST
68460: PPUSH
68461: CALL_OW 72
68465: ST_TO_ADDR
// for k := 1 to depot do
68466: LD_ADDR_VAR 0 4
68470: PUSH
68471: DOUBLE
68472: LD_INT 1
68474: DEC
68475: ST_TO_ADDR
68476: LD_VAR 0 6
68480: PUSH
68481: FOR_TO
68482: IFFALSE 69052
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68484: LD_EXP 66
68488: PUSH
68489: LD_VAR 0 2
68493: ARRAY
68494: PUSH
68495: LD_INT 1
68497: ARRAY
68498: PUSH
68499: LD_INT 1
68501: ARRAY
68502: PUSH
68503: LD_INT 0
68505: EQUAL
68506: PUSH
68507: LD_VAR 0 6
68511: PUSH
68512: LD_VAR 0 4
68516: ARRAY
68517: PPUSH
68518: LD_EXP 66
68522: PUSH
68523: LD_VAR 0 2
68527: ARRAY
68528: PUSH
68529: LD_INT 1
68531: ARRAY
68532: PUSH
68533: LD_INT 1
68535: ARRAY
68536: PPUSH
68537: LD_EXP 66
68541: PUSH
68542: LD_VAR 0 2
68546: ARRAY
68547: PUSH
68548: LD_INT 1
68550: ARRAY
68551: PUSH
68552: LD_INT 2
68554: ARRAY
68555: PPUSH
68556: LD_EXP 66
68560: PUSH
68561: LD_VAR 0 2
68565: ARRAY
68566: PUSH
68567: LD_INT 1
68569: ARRAY
68570: PUSH
68571: LD_INT 3
68573: ARRAY
68574: PPUSH
68575: LD_EXP 66
68579: PUSH
68580: LD_VAR 0 2
68584: ARRAY
68585: PUSH
68586: LD_INT 1
68588: ARRAY
68589: PUSH
68590: LD_INT 4
68592: ARRAY
68593: PPUSH
68594: CALL 28937 0 5
68598: OR
68599: IFFALSE 68880
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68601: LD_ADDR_VAR 0 5
68605: PUSH
68606: LD_EXP 61
68610: PUSH
68611: LD_VAR 0 2
68615: ARRAY
68616: PPUSH
68617: LD_INT 25
68619: PUSH
68620: LD_INT 2
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: PPUSH
68627: CALL_OW 72
68631: PUSH
68632: LD_EXP 63
68636: PUSH
68637: LD_VAR 0 2
68641: ARRAY
68642: DIFF
68643: ST_TO_ADDR
// if not tmp then
68644: LD_VAR 0 5
68648: NOT
68649: IFFALSE 68653
// continue ;
68651: GO 68481
// for j in tmp do
68653: LD_ADDR_VAR 0 3
68657: PUSH
68658: LD_VAR 0 5
68662: PUSH
68663: FOR_IN
68664: IFFALSE 68876
// begin if not mc_builders [ i ] then
68666: LD_EXP 67
68670: PUSH
68671: LD_VAR 0 2
68675: ARRAY
68676: NOT
68677: IFFALSE 68735
// begin SetTag ( j , 103 ) ;
68679: LD_VAR 0 3
68683: PPUSH
68684: LD_INT 103
68686: PPUSH
68687: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68691: LD_ADDR_EXP 67
68695: PUSH
68696: LD_EXP 67
68700: PPUSH
68701: LD_VAR 0 2
68705: PUSH
68706: LD_EXP 67
68710: PUSH
68711: LD_VAR 0 2
68715: ARRAY
68716: PUSH
68717: LD_INT 1
68719: PLUS
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PPUSH
68725: LD_VAR 0 3
68729: PPUSH
68730: CALL 20463 0 3
68734: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68735: LD_VAR 0 3
68739: PPUSH
68740: CALL_OW 310
68744: IFFALSE 68755
// ComExitBuilding ( j ) ;
68746: LD_VAR 0 3
68750: PPUSH
68751: CALL_OW 122
// wait ( 3 ) ;
68755: LD_INT 3
68757: PPUSH
68758: CALL_OW 67
// if not mc_build_list [ i ] then
68762: LD_EXP 66
68766: PUSH
68767: LD_VAR 0 2
68771: ARRAY
68772: NOT
68773: IFFALSE 68777
// break ;
68775: GO 68876
// if not HasTask ( j ) then
68777: LD_VAR 0 3
68781: PPUSH
68782: CALL_OW 314
68786: NOT
68787: IFFALSE 68874
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68789: LD_VAR 0 3
68793: PPUSH
68794: LD_EXP 66
68798: PUSH
68799: LD_VAR 0 2
68803: ARRAY
68804: PUSH
68805: LD_INT 1
68807: ARRAY
68808: PUSH
68809: LD_INT 1
68811: ARRAY
68812: PPUSH
68813: LD_EXP 66
68817: PUSH
68818: LD_VAR 0 2
68822: ARRAY
68823: PUSH
68824: LD_INT 1
68826: ARRAY
68827: PUSH
68828: LD_INT 2
68830: ARRAY
68831: PPUSH
68832: LD_EXP 66
68836: PUSH
68837: LD_VAR 0 2
68841: ARRAY
68842: PUSH
68843: LD_INT 1
68845: ARRAY
68846: PUSH
68847: LD_INT 3
68849: ARRAY
68850: PPUSH
68851: LD_EXP 66
68855: PUSH
68856: LD_VAR 0 2
68860: ARRAY
68861: PUSH
68862: LD_INT 1
68864: ARRAY
68865: PUSH
68866: LD_INT 4
68868: ARRAY
68869: PPUSH
68870: CALL_OW 145
// end ;
68874: GO 68663
68876: POP
68877: POP
// end else
68878: GO 69050
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
68880: LD_EXP 61
68884: PUSH
68885: LD_VAR 0 2
68889: ARRAY
68890: PPUSH
68891: LD_EXP 66
68895: PUSH
68896: LD_VAR 0 2
68900: ARRAY
68901: PUSH
68902: LD_INT 1
68904: ARRAY
68905: PUSH
68906: LD_INT 1
68908: ARRAY
68909: PPUSH
68910: LD_EXP 66
68914: PUSH
68915: LD_VAR 0 2
68919: ARRAY
68920: PUSH
68921: LD_INT 1
68923: ARRAY
68924: PUSH
68925: LD_INT 2
68927: ARRAY
68928: PPUSH
68929: LD_EXP 66
68933: PUSH
68934: LD_VAR 0 2
68938: ARRAY
68939: PUSH
68940: LD_INT 1
68942: ARRAY
68943: PUSH
68944: LD_INT 3
68946: ARRAY
68947: PPUSH
68948: LD_EXP 66
68952: PUSH
68953: LD_VAR 0 2
68957: ARRAY
68958: PUSH
68959: LD_INT 1
68961: ARRAY
68962: PUSH
68963: LD_INT 4
68965: ARRAY
68966: PPUSH
68967: LD_EXP 61
68971: PUSH
68972: LD_VAR 0 2
68976: ARRAY
68977: PPUSH
68978: LD_INT 21
68980: PUSH
68981: LD_INT 3
68983: PUSH
68984: EMPTY
68985: LIST
68986: LIST
68987: PPUSH
68988: CALL_OW 72
68992: PPUSH
68993: EMPTY
68994: PPUSH
68995: CALL 27691 0 7
68999: NOT
69000: IFFALSE 69050
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
69002: LD_ADDR_EXP 66
69006: PUSH
69007: LD_EXP 66
69011: PPUSH
69012: LD_VAR 0 2
69016: PPUSH
69017: LD_EXP 66
69021: PUSH
69022: LD_VAR 0 2
69026: ARRAY
69027: PPUSH
69028: LD_INT 1
69030: PPUSH
69031: LD_INT 1
69033: NEG
69034: PPUSH
69035: LD_INT 0
69037: PPUSH
69038: CALL 19881 0 4
69042: PPUSH
69043: CALL_OW 1
69047: ST_TO_ADDR
// continue ;
69048: GO 68481
// end ; end ;
69050: GO 68481
69052: POP
69053: POP
// end ; end ;
69054: GO 67910
69056: POP
69057: POP
// end ;
69058: LD_VAR 0 1
69062: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
69063: LD_INT 0
69065: PPUSH
69066: PPUSH
69067: PPUSH
69068: PPUSH
69069: PPUSH
69070: PPUSH
// if not mc_bases then
69071: LD_EXP 61
69075: NOT
69076: IFFALSE 69080
// exit ;
69078: GO 69507
// for i = 1 to mc_bases do
69080: LD_ADDR_VAR 0 2
69084: PUSH
69085: DOUBLE
69086: LD_INT 1
69088: DEC
69089: ST_TO_ADDR
69090: LD_EXP 61
69094: PUSH
69095: FOR_TO
69096: IFFALSE 69505
// begin tmp := mc_build_upgrade [ i ] ;
69098: LD_ADDR_VAR 0 4
69102: PUSH
69103: LD_EXP 93
69107: PUSH
69108: LD_VAR 0 2
69112: ARRAY
69113: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
69114: LD_ADDR_VAR 0 6
69118: PUSH
69119: LD_EXP 94
69123: PUSH
69124: LD_VAR 0 2
69128: ARRAY
69129: PPUSH
69130: LD_INT 2
69132: PUSH
69133: LD_INT 30
69135: PUSH
69136: LD_INT 6
69138: PUSH
69139: EMPTY
69140: LIST
69141: LIST
69142: PUSH
69143: LD_INT 30
69145: PUSH
69146: LD_INT 7
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: LIST
69157: PPUSH
69158: CALL_OW 72
69162: ST_TO_ADDR
// if not tmp and not lab then
69163: LD_VAR 0 4
69167: NOT
69168: PUSH
69169: LD_VAR 0 6
69173: NOT
69174: AND
69175: IFFALSE 69179
// continue ;
69177: GO 69095
// if tmp then
69179: LD_VAR 0 4
69183: IFFALSE 69303
// for j in tmp do
69185: LD_ADDR_VAR 0 3
69189: PUSH
69190: LD_VAR 0 4
69194: PUSH
69195: FOR_IN
69196: IFFALSE 69301
// begin if UpgradeCost ( j ) then
69198: LD_VAR 0 3
69202: PPUSH
69203: CALL 27351 0 1
69207: IFFALSE 69299
// begin ComUpgrade ( j ) ;
69209: LD_VAR 0 3
69213: PPUSH
69214: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
69218: LD_ADDR_EXP 93
69222: PUSH
69223: LD_EXP 93
69227: PPUSH
69228: LD_VAR 0 2
69232: PPUSH
69233: LD_EXP 93
69237: PUSH
69238: LD_VAR 0 2
69242: ARRAY
69243: PUSH
69244: LD_VAR 0 3
69248: DIFF
69249: PPUSH
69250: CALL_OW 1
69254: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69255: LD_ADDR_EXP 68
69259: PUSH
69260: LD_EXP 68
69264: PPUSH
69265: LD_VAR 0 2
69269: PUSH
69270: LD_EXP 68
69274: PUSH
69275: LD_VAR 0 2
69279: ARRAY
69280: PUSH
69281: LD_INT 1
69283: PLUS
69284: PUSH
69285: EMPTY
69286: LIST
69287: LIST
69288: PPUSH
69289: LD_VAR 0 3
69293: PPUSH
69294: CALL 20463 0 3
69298: ST_TO_ADDR
// end ; end ;
69299: GO 69195
69301: POP
69302: POP
// if not lab or not mc_lab_upgrade [ i ] then
69303: LD_VAR 0 6
69307: NOT
69308: PUSH
69309: LD_EXP 95
69313: PUSH
69314: LD_VAR 0 2
69318: ARRAY
69319: NOT
69320: OR
69321: IFFALSE 69325
// continue ;
69323: GO 69095
// for j in lab do
69325: LD_ADDR_VAR 0 3
69329: PUSH
69330: LD_VAR 0 6
69334: PUSH
69335: FOR_IN
69336: IFFALSE 69501
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
69338: LD_VAR 0 3
69342: PPUSH
69343: CALL_OW 266
69347: PUSH
69348: LD_INT 6
69350: PUSH
69351: LD_INT 7
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: IN
69358: PUSH
69359: LD_VAR 0 3
69363: PPUSH
69364: CALL_OW 461
69368: PUSH
69369: LD_INT 1
69371: NONEQUAL
69372: AND
69373: IFFALSE 69499
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
69375: LD_VAR 0 3
69379: PPUSH
69380: LD_EXP 95
69384: PUSH
69385: LD_VAR 0 2
69389: ARRAY
69390: PUSH
69391: LD_INT 1
69393: ARRAY
69394: PPUSH
69395: CALL 27556 0 2
69399: IFFALSE 69499
// begin ComCancel ( j ) ;
69401: LD_VAR 0 3
69405: PPUSH
69406: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
69410: LD_VAR 0 3
69414: PPUSH
69415: LD_EXP 95
69419: PUSH
69420: LD_VAR 0 2
69424: ARRAY
69425: PUSH
69426: LD_INT 1
69428: ARRAY
69429: PPUSH
69430: CALL_OW 207
// if not j in mc_construct_list [ i ] then
69434: LD_VAR 0 3
69438: PUSH
69439: LD_EXP 68
69443: PUSH
69444: LD_VAR 0 2
69448: ARRAY
69449: IN
69450: NOT
69451: IFFALSE 69497
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69453: LD_ADDR_EXP 68
69457: PUSH
69458: LD_EXP 68
69462: PPUSH
69463: LD_VAR 0 2
69467: PUSH
69468: LD_EXP 68
69472: PUSH
69473: LD_VAR 0 2
69477: ARRAY
69478: PUSH
69479: LD_INT 1
69481: PLUS
69482: PUSH
69483: EMPTY
69484: LIST
69485: LIST
69486: PPUSH
69487: LD_VAR 0 3
69491: PPUSH
69492: CALL 20463 0 3
69496: ST_TO_ADDR
// break ;
69497: GO 69501
// end ; end ; end ;
69499: GO 69335
69501: POP
69502: POP
// end ;
69503: GO 69095
69505: POP
69506: POP
// end ;
69507: LD_VAR 0 1
69511: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
69512: LD_INT 0
69514: PPUSH
69515: PPUSH
69516: PPUSH
69517: PPUSH
69518: PPUSH
69519: PPUSH
69520: PPUSH
69521: PPUSH
69522: PPUSH
// if not mc_bases then
69523: LD_EXP 61
69527: NOT
69528: IFFALSE 69532
// exit ;
69530: GO 69937
// for i = 1 to mc_bases do
69532: LD_ADDR_VAR 0 2
69536: PUSH
69537: DOUBLE
69538: LD_INT 1
69540: DEC
69541: ST_TO_ADDR
69542: LD_EXP 61
69546: PUSH
69547: FOR_TO
69548: IFFALSE 69935
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
69550: LD_EXP 69
69554: PUSH
69555: LD_VAR 0 2
69559: ARRAY
69560: NOT
69561: PUSH
69562: LD_EXP 61
69566: PUSH
69567: LD_VAR 0 2
69571: ARRAY
69572: PPUSH
69573: LD_INT 30
69575: PUSH
69576: LD_INT 3
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: PPUSH
69583: CALL_OW 72
69587: NOT
69588: OR
69589: IFFALSE 69593
// continue ;
69591: GO 69547
// busy := false ;
69593: LD_ADDR_VAR 0 8
69597: PUSH
69598: LD_INT 0
69600: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69601: LD_ADDR_VAR 0 4
69605: PUSH
69606: LD_EXP 61
69610: PUSH
69611: LD_VAR 0 2
69615: ARRAY
69616: PPUSH
69617: LD_INT 30
69619: PUSH
69620: LD_INT 3
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PPUSH
69627: CALL_OW 72
69631: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69632: LD_ADDR_VAR 0 6
69636: PUSH
69637: LD_EXP 69
69641: PUSH
69642: LD_VAR 0 2
69646: ARRAY
69647: PPUSH
69648: LD_INT 2
69650: PUSH
69651: LD_INT 30
69653: PUSH
69654: LD_INT 32
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: PUSH
69661: LD_INT 30
69663: PUSH
69664: LD_INT 33
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: EMPTY
69672: LIST
69673: LIST
69674: LIST
69675: PPUSH
69676: CALL_OW 72
69680: ST_TO_ADDR
// if not t then
69681: LD_VAR 0 6
69685: NOT
69686: IFFALSE 69690
// continue ;
69688: GO 69547
// for j in tmp do
69690: LD_ADDR_VAR 0 3
69694: PUSH
69695: LD_VAR 0 4
69699: PUSH
69700: FOR_IN
69701: IFFALSE 69731
// if not BuildingStatus ( j ) = bs_idle then
69703: LD_VAR 0 3
69707: PPUSH
69708: CALL_OW 461
69712: PUSH
69713: LD_INT 2
69715: EQUAL
69716: NOT
69717: IFFALSE 69729
// begin busy := true ;
69719: LD_ADDR_VAR 0 8
69723: PUSH
69724: LD_INT 1
69726: ST_TO_ADDR
// break ;
69727: GO 69731
// end ;
69729: GO 69700
69731: POP
69732: POP
// if busy then
69733: LD_VAR 0 8
69737: IFFALSE 69741
// continue ;
69739: GO 69547
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69741: LD_ADDR_VAR 0 7
69745: PUSH
69746: LD_VAR 0 6
69750: PPUSH
69751: LD_INT 35
69753: PUSH
69754: LD_INT 0
69756: PUSH
69757: EMPTY
69758: LIST
69759: LIST
69760: PPUSH
69761: CALL_OW 72
69765: ST_TO_ADDR
// if tw then
69766: LD_VAR 0 7
69770: IFFALSE 69847
// begin tw := tw [ 1 ] ;
69772: LD_ADDR_VAR 0 7
69776: PUSH
69777: LD_VAR 0 7
69781: PUSH
69782: LD_INT 1
69784: ARRAY
69785: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69786: LD_ADDR_VAR 0 9
69790: PUSH
69791: LD_VAR 0 7
69795: PPUSH
69796: LD_EXP 86
69800: PUSH
69801: LD_VAR 0 2
69805: ARRAY
69806: PPUSH
69807: CALL 25848 0 2
69811: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69812: LD_EXP 100
69816: PUSH
69817: LD_VAR 0 2
69821: ARRAY
69822: IFFALSE 69845
// if not weapon in mc_allowed_tower_weapons [ i ] then
69824: LD_VAR 0 9
69828: PUSH
69829: LD_EXP 100
69833: PUSH
69834: LD_VAR 0 2
69838: ARRAY
69839: IN
69840: NOT
69841: IFFALSE 69845
// continue ;
69843: GO 69547
// end else
69845: GO 69910
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69847: LD_ADDR_VAR 0 5
69851: PUSH
69852: LD_EXP 69
69856: PUSH
69857: LD_VAR 0 2
69861: ARRAY
69862: PPUSH
69863: LD_VAR 0 4
69867: PPUSH
69868: CALL 52751 0 2
69872: ST_TO_ADDR
// if not tmp2 then
69873: LD_VAR 0 5
69877: NOT
69878: IFFALSE 69882
// continue ;
69880: GO 69547
// tw := tmp2 [ 1 ] ;
69882: LD_ADDR_VAR 0 7
69886: PUSH
69887: LD_VAR 0 5
69891: PUSH
69892: LD_INT 1
69894: ARRAY
69895: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69896: LD_ADDR_VAR 0 9
69900: PUSH
69901: LD_VAR 0 5
69905: PUSH
69906: LD_INT 2
69908: ARRAY
69909: ST_TO_ADDR
// end ; if not weapon then
69910: LD_VAR 0 9
69914: NOT
69915: IFFALSE 69919
// continue ;
69917: GO 69547
// ComPlaceWeapon ( tw , weapon ) ;
69919: LD_VAR 0 7
69923: PPUSH
69924: LD_VAR 0 9
69928: PPUSH
69929: CALL_OW 148
// end ;
69933: GO 69547
69935: POP
69936: POP
// end ;
69937: LD_VAR 0 1
69941: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
69942: LD_INT 0
69944: PPUSH
69945: PPUSH
69946: PPUSH
69947: PPUSH
69948: PPUSH
69949: PPUSH
69950: PPUSH
// if not mc_bases then
69951: LD_EXP 61
69955: NOT
69956: IFFALSE 69960
// exit ;
69958: GO 70735
// for i = 1 to mc_bases do
69960: LD_ADDR_VAR 0 2
69964: PUSH
69965: DOUBLE
69966: LD_INT 1
69968: DEC
69969: ST_TO_ADDR
69970: LD_EXP 61
69974: PUSH
69975: FOR_TO
69976: IFFALSE 70733
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
69978: LD_EXP 74
69982: PUSH
69983: LD_VAR 0 2
69987: ARRAY
69988: NOT
69989: PUSH
69990: LD_EXP 74
69994: PUSH
69995: LD_VAR 0 2
69999: ARRAY
70000: PUSH
70001: LD_EXP 75
70005: PUSH
70006: LD_VAR 0 2
70010: ARRAY
70011: EQUAL
70012: OR
70013: PUSH
70014: LD_EXP 84
70018: PUSH
70019: LD_VAR 0 2
70023: ARRAY
70024: OR
70025: IFFALSE 70029
// continue ;
70027: GO 69975
// if mc_miners [ i ] then
70029: LD_EXP 75
70033: PUSH
70034: LD_VAR 0 2
70038: ARRAY
70039: IFFALSE 70420
// begin for j = mc_miners [ i ] downto 1 do
70041: LD_ADDR_VAR 0 3
70045: PUSH
70046: DOUBLE
70047: LD_EXP 75
70051: PUSH
70052: LD_VAR 0 2
70056: ARRAY
70057: INC
70058: ST_TO_ADDR
70059: LD_INT 1
70061: PUSH
70062: FOR_DOWNTO
70063: IFFALSE 70418
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
70065: LD_EXP 75
70069: PUSH
70070: LD_VAR 0 2
70074: ARRAY
70075: PUSH
70076: LD_VAR 0 3
70080: ARRAY
70081: PPUSH
70082: CALL_OW 301
70086: PUSH
70087: LD_EXP 75
70091: PUSH
70092: LD_VAR 0 2
70096: ARRAY
70097: PUSH
70098: LD_VAR 0 3
70102: ARRAY
70103: PPUSH
70104: CALL_OW 257
70108: PUSH
70109: LD_INT 1
70111: NONEQUAL
70112: OR
70113: IFFALSE 70176
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
70115: LD_ADDR_VAR 0 5
70119: PUSH
70120: LD_EXP 75
70124: PUSH
70125: LD_VAR 0 2
70129: ARRAY
70130: PUSH
70131: LD_EXP 75
70135: PUSH
70136: LD_VAR 0 2
70140: ARRAY
70141: PUSH
70142: LD_VAR 0 3
70146: ARRAY
70147: DIFF
70148: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
70149: LD_ADDR_EXP 75
70153: PUSH
70154: LD_EXP 75
70158: PPUSH
70159: LD_VAR 0 2
70163: PPUSH
70164: LD_VAR 0 5
70168: PPUSH
70169: CALL_OW 1
70173: ST_TO_ADDR
// continue ;
70174: GO 70062
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
70176: LD_EXP 75
70180: PUSH
70181: LD_VAR 0 2
70185: ARRAY
70186: PUSH
70187: LD_VAR 0 3
70191: ARRAY
70192: PPUSH
70193: CALL_OW 257
70197: PUSH
70198: LD_INT 1
70200: EQUAL
70201: PUSH
70202: LD_EXP 75
70206: PUSH
70207: LD_VAR 0 2
70211: ARRAY
70212: PUSH
70213: LD_VAR 0 3
70217: ARRAY
70218: PPUSH
70219: CALL_OW 459
70223: NOT
70224: AND
70225: PUSH
70226: LD_EXP 75
70230: PUSH
70231: LD_VAR 0 2
70235: ARRAY
70236: PUSH
70237: LD_VAR 0 3
70241: ARRAY
70242: PPUSH
70243: CALL_OW 314
70247: NOT
70248: AND
70249: IFFALSE 70416
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
70251: LD_EXP 75
70255: PUSH
70256: LD_VAR 0 2
70260: ARRAY
70261: PUSH
70262: LD_VAR 0 3
70266: ARRAY
70267: PPUSH
70268: CALL_OW 310
70272: IFFALSE 70295
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
70274: LD_EXP 75
70278: PUSH
70279: LD_VAR 0 2
70283: ARRAY
70284: PUSH
70285: LD_VAR 0 3
70289: ARRAY
70290: PPUSH
70291: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
70295: LD_EXP 75
70299: PUSH
70300: LD_VAR 0 2
70304: ARRAY
70305: PUSH
70306: LD_VAR 0 3
70310: ARRAY
70311: PPUSH
70312: CALL_OW 314
70316: NOT
70317: IFFALSE 70416
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
70319: LD_ADDR_VAR 0 7
70323: PUSH
70324: LD_VAR 0 3
70328: PUSH
70329: LD_EXP 74
70333: PUSH
70334: LD_VAR 0 2
70338: ARRAY
70339: PPUSH
70340: CALL 17603 0 1
70344: MOD
70345: PUSH
70346: LD_INT 1
70348: PLUS
70349: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
70350: LD_EXP 75
70354: PUSH
70355: LD_VAR 0 2
70359: ARRAY
70360: PUSH
70361: LD_VAR 0 3
70365: ARRAY
70366: PPUSH
70367: LD_EXP 74
70371: PUSH
70372: LD_VAR 0 2
70376: ARRAY
70377: PUSH
70378: LD_VAR 0 7
70382: ARRAY
70383: PUSH
70384: LD_INT 1
70386: ARRAY
70387: PPUSH
70388: LD_EXP 74
70392: PUSH
70393: LD_VAR 0 2
70397: ARRAY
70398: PUSH
70399: LD_VAR 0 7
70403: ARRAY
70404: PUSH
70405: LD_INT 2
70407: ARRAY
70408: PPUSH
70409: LD_INT 0
70411: PPUSH
70412: CALL_OW 193
// end ; end ; end ;
70416: GO 70062
70418: POP
70419: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70420: LD_ADDR_VAR 0 5
70424: PUSH
70425: LD_EXP 61
70429: PUSH
70430: LD_VAR 0 2
70434: ARRAY
70435: PPUSH
70436: LD_INT 2
70438: PUSH
70439: LD_INT 30
70441: PUSH
70442: LD_INT 4
70444: PUSH
70445: EMPTY
70446: LIST
70447: LIST
70448: PUSH
70449: LD_INT 30
70451: PUSH
70452: LD_INT 5
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 30
70461: PUSH
70462: LD_INT 32
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: PPUSH
70475: CALL_OW 72
70479: ST_TO_ADDR
// if not tmp then
70480: LD_VAR 0 5
70484: NOT
70485: IFFALSE 70489
// continue ;
70487: GO 69975
// list := [ ] ;
70489: LD_ADDR_VAR 0 6
70493: PUSH
70494: EMPTY
70495: ST_TO_ADDR
// for j in tmp do
70496: LD_ADDR_VAR 0 3
70500: PUSH
70501: LD_VAR 0 5
70505: PUSH
70506: FOR_IN
70507: IFFALSE 70576
// begin for k in UnitsInside ( j ) do
70509: LD_ADDR_VAR 0 4
70513: PUSH
70514: LD_VAR 0 3
70518: PPUSH
70519: CALL_OW 313
70523: PUSH
70524: FOR_IN
70525: IFFALSE 70572
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70527: LD_VAR 0 4
70531: PPUSH
70532: CALL_OW 257
70536: PUSH
70537: LD_INT 1
70539: EQUAL
70540: PUSH
70541: LD_VAR 0 4
70545: PPUSH
70546: CALL_OW 459
70550: NOT
70551: AND
70552: IFFALSE 70570
// list := list ^ k ;
70554: LD_ADDR_VAR 0 6
70558: PUSH
70559: LD_VAR 0 6
70563: PUSH
70564: LD_VAR 0 4
70568: ADD
70569: ST_TO_ADDR
70570: GO 70524
70572: POP
70573: POP
// end ;
70574: GO 70506
70576: POP
70577: POP
// list := list diff mc_miners [ i ] ;
70578: LD_ADDR_VAR 0 6
70582: PUSH
70583: LD_VAR 0 6
70587: PUSH
70588: LD_EXP 75
70592: PUSH
70593: LD_VAR 0 2
70597: ARRAY
70598: DIFF
70599: ST_TO_ADDR
// if not list then
70600: LD_VAR 0 6
70604: NOT
70605: IFFALSE 70609
// continue ;
70607: GO 69975
// k := mc_mines [ i ] - mc_miners [ i ] ;
70609: LD_ADDR_VAR 0 4
70613: PUSH
70614: LD_EXP 74
70618: PUSH
70619: LD_VAR 0 2
70623: ARRAY
70624: PUSH
70625: LD_EXP 75
70629: PUSH
70630: LD_VAR 0 2
70634: ARRAY
70635: MINUS
70636: ST_TO_ADDR
// if k > list then
70637: LD_VAR 0 4
70641: PUSH
70642: LD_VAR 0 6
70646: GREATER
70647: IFFALSE 70659
// k := list ;
70649: LD_ADDR_VAR 0 4
70653: PUSH
70654: LD_VAR 0 6
70658: ST_TO_ADDR
// for j = 1 to k do
70659: LD_ADDR_VAR 0 3
70663: PUSH
70664: DOUBLE
70665: LD_INT 1
70667: DEC
70668: ST_TO_ADDR
70669: LD_VAR 0 4
70673: PUSH
70674: FOR_TO
70675: IFFALSE 70729
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70677: LD_ADDR_EXP 75
70681: PUSH
70682: LD_EXP 75
70686: PPUSH
70687: LD_VAR 0 2
70691: PUSH
70692: LD_EXP 75
70696: PUSH
70697: LD_VAR 0 2
70701: ARRAY
70702: PUSH
70703: LD_INT 1
70705: PLUS
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PPUSH
70711: LD_VAR 0 6
70715: PUSH
70716: LD_VAR 0 3
70720: ARRAY
70721: PPUSH
70722: CALL 20463 0 3
70726: ST_TO_ADDR
70727: GO 70674
70729: POP
70730: POP
// end ;
70731: GO 69975
70733: POP
70734: POP
// end ;
70735: LD_VAR 0 1
70739: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
70740: LD_INT 0
70742: PPUSH
70743: PPUSH
70744: PPUSH
70745: PPUSH
70746: PPUSH
70747: PPUSH
70748: PPUSH
70749: PPUSH
70750: PPUSH
70751: PPUSH
70752: PPUSH
// if not mc_bases then
70753: LD_EXP 61
70757: NOT
70758: IFFALSE 70762
// exit ;
70760: GO 72585
// for i = 1 to mc_bases do
70762: LD_ADDR_VAR 0 2
70766: PUSH
70767: DOUBLE
70768: LD_INT 1
70770: DEC
70771: ST_TO_ADDR
70772: LD_EXP 61
70776: PUSH
70777: FOR_TO
70778: IFFALSE 72583
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70780: LD_EXP 61
70784: PUSH
70785: LD_VAR 0 2
70789: ARRAY
70790: NOT
70791: PUSH
70792: LD_EXP 68
70796: PUSH
70797: LD_VAR 0 2
70801: ARRAY
70802: OR
70803: IFFALSE 70807
// continue ;
70805: GO 70777
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70807: LD_EXP 77
70811: PUSH
70812: LD_VAR 0 2
70816: ARRAY
70817: NOT
70818: PUSH
70819: LD_EXP 78
70823: PUSH
70824: LD_VAR 0 2
70828: ARRAY
70829: AND
70830: IFFALSE 70868
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70832: LD_ADDR_EXP 78
70836: PUSH
70837: LD_EXP 78
70841: PPUSH
70842: LD_VAR 0 2
70846: PPUSH
70847: EMPTY
70848: PPUSH
70849: CALL_OW 1
70853: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70854: LD_VAR 0 2
70858: PPUSH
70859: LD_INT 107
70861: PPUSH
70862: CALL 61594 0 2
// continue ;
70866: GO 70777
// end ; target := [ ] ;
70868: LD_ADDR_VAR 0 7
70872: PUSH
70873: EMPTY
70874: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70875: LD_ADDR_VAR 0 6
70879: PUSH
70880: LD_EXP 61
70884: PUSH
70885: LD_VAR 0 2
70889: ARRAY
70890: PUSH
70891: LD_INT 1
70893: ARRAY
70894: PPUSH
70895: CALL_OW 255
70899: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70900: LD_ADDR_VAR 0 9
70904: PUSH
70905: LD_EXP 61
70909: PUSH
70910: LD_VAR 0 2
70914: ARRAY
70915: PPUSH
70916: LD_INT 2
70918: PUSH
70919: LD_INT 30
70921: PUSH
70922: LD_INT 0
70924: PUSH
70925: EMPTY
70926: LIST
70927: LIST
70928: PUSH
70929: LD_INT 30
70931: PUSH
70932: LD_INT 1
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: LIST
70943: PPUSH
70944: CALL_OW 72
70948: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70949: LD_ADDR_VAR 0 3
70953: PUSH
70954: DOUBLE
70955: LD_EXP 77
70959: PUSH
70960: LD_VAR 0 2
70964: ARRAY
70965: INC
70966: ST_TO_ADDR
70967: LD_INT 1
70969: PUSH
70970: FOR_DOWNTO
70971: IFFALSE 71216
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70973: LD_EXP 77
70977: PUSH
70978: LD_VAR 0 2
70982: ARRAY
70983: PUSH
70984: LD_VAR 0 3
70988: ARRAY
70989: PUSH
70990: LD_INT 2
70992: ARRAY
70993: PPUSH
70994: LD_EXP 77
70998: PUSH
70999: LD_VAR 0 2
71003: ARRAY
71004: PUSH
71005: LD_VAR 0 3
71009: ARRAY
71010: PUSH
71011: LD_INT 3
71013: ARRAY
71014: PPUSH
71015: CALL_OW 488
71019: PUSH
71020: LD_EXP 77
71024: PUSH
71025: LD_VAR 0 2
71029: ARRAY
71030: PUSH
71031: LD_VAR 0 3
71035: ARRAY
71036: PUSH
71037: LD_INT 2
71039: ARRAY
71040: PPUSH
71041: LD_EXP 77
71045: PUSH
71046: LD_VAR 0 2
71050: ARRAY
71051: PUSH
71052: LD_VAR 0 3
71056: ARRAY
71057: PUSH
71058: LD_INT 3
71060: ARRAY
71061: PPUSH
71062: CALL_OW 284
71066: PUSH
71067: LD_INT 0
71069: EQUAL
71070: AND
71071: IFFALSE 71126
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
71073: LD_ADDR_VAR 0 5
71077: PUSH
71078: LD_EXP 77
71082: PUSH
71083: LD_VAR 0 2
71087: ARRAY
71088: PPUSH
71089: LD_VAR 0 3
71093: PPUSH
71094: CALL_OW 3
71098: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
71099: LD_ADDR_EXP 77
71103: PUSH
71104: LD_EXP 77
71108: PPUSH
71109: LD_VAR 0 2
71113: PPUSH
71114: LD_VAR 0 5
71118: PPUSH
71119: CALL_OW 1
71123: ST_TO_ADDR
// continue ;
71124: GO 70970
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
71126: LD_VAR 0 6
71130: PPUSH
71131: LD_EXP 77
71135: PUSH
71136: LD_VAR 0 2
71140: ARRAY
71141: PUSH
71142: LD_VAR 0 3
71146: ARRAY
71147: PUSH
71148: LD_INT 2
71150: ARRAY
71151: PPUSH
71152: LD_EXP 77
71156: PUSH
71157: LD_VAR 0 2
71161: ARRAY
71162: PUSH
71163: LD_VAR 0 3
71167: ARRAY
71168: PUSH
71169: LD_INT 3
71171: ARRAY
71172: PPUSH
71173: LD_INT 30
71175: PPUSH
71176: CALL 21727 0 4
71180: PUSH
71181: LD_INT 4
71183: ARRAY
71184: PUSH
71185: LD_INT 0
71187: EQUAL
71188: IFFALSE 71214
// begin target := mc_crates [ i ] [ j ] ;
71190: LD_ADDR_VAR 0 7
71194: PUSH
71195: LD_EXP 77
71199: PUSH
71200: LD_VAR 0 2
71204: ARRAY
71205: PUSH
71206: LD_VAR 0 3
71210: ARRAY
71211: ST_TO_ADDR
// break ;
71212: GO 71216
// end ; end ;
71214: GO 70970
71216: POP
71217: POP
// if not target then
71218: LD_VAR 0 7
71222: NOT
71223: IFFALSE 71227
// continue ;
71225: GO 70777
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
71227: LD_ADDR_VAR 0 8
71231: PUSH
71232: LD_EXP 80
71236: PUSH
71237: LD_VAR 0 2
71241: ARRAY
71242: PPUSH
71243: LD_INT 2
71245: PUSH
71246: LD_INT 3
71248: PUSH
71249: LD_INT 58
71251: PUSH
71252: EMPTY
71253: LIST
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 61
71261: PUSH
71262: EMPTY
71263: LIST
71264: PUSH
71265: LD_INT 33
71267: PUSH
71268: LD_INT 5
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 33
71277: PUSH
71278: LD_INT 3
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: LIST
71289: LIST
71290: LIST
71291: PUSH
71292: LD_INT 2
71294: PUSH
71295: LD_INT 34
71297: PUSH
71298: LD_INT 32
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: PUSH
71305: LD_INT 34
71307: PUSH
71308: LD_INT 51
71310: PUSH
71311: EMPTY
71312: LIST
71313: LIST
71314: PUSH
71315: LD_INT 34
71317: PUSH
71318: LD_INT 12
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: PPUSH
71335: CALL_OW 72
71339: ST_TO_ADDR
// if not cargo then
71340: LD_VAR 0 8
71344: NOT
71345: IFFALSE 72051
// begin if mc_crates_collector [ i ] < 5 then
71347: LD_EXP 78
71351: PUSH
71352: LD_VAR 0 2
71356: ARRAY
71357: PUSH
71358: LD_INT 5
71360: LESS
71361: IFFALSE 71727
// begin if mc_ape [ i ] then
71363: LD_EXP 90
71367: PUSH
71368: LD_VAR 0 2
71372: ARRAY
71373: IFFALSE 71420
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
71375: LD_ADDR_VAR 0 5
71379: PUSH
71380: LD_EXP 90
71384: PUSH
71385: LD_VAR 0 2
71389: ARRAY
71390: PPUSH
71391: LD_INT 25
71393: PUSH
71394: LD_INT 16
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: PUSH
71401: LD_INT 24
71403: PUSH
71404: LD_INT 750
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: PUSH
71411: EMPTY
71412: LIST
71413: LIST
71414: PPUSH
71415: CALL_OW 72
71419: ST_TO_ADDR
// if not tmp then
71420: LD_VAR 0 5
71424: NOT
71425: IFFALSE 71472
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
71427: LD_ADDR_VAR 0 5
71431: PUSH
71432: LD_EXP 61
71436: PUSH
71437: LD_VAR 0 2
71441: ARRAY
71442: PPUSH
71443: LD_INT 25
71445: PUSH
71446: LD_INT 2
71448: PUSH
71449: EMPTY
71450: LIST
71451: LIST
71452: PUSH
71453: LD_INT 24
71455: PUSH
71456: LD_INT 750
71458: PUSH
71459: EMPTY
71460: LIST
71461: LIST
71462: PUSH
71463: EMPTY
71464: LIST
71465: LIST
71466: PPUSH
71467: CALL_OW 72
71471: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71472: LD_EXP 90
71476: PUSH
71477: LD_VAR 0 2
71481: ARRAY
71482: PUSH
71483: LD_EXP 61
71487: PUSH
71488: LD_VAR 0 2
71492: ARRAY
71493: PPUSH
71494: LD_INT 25
71496: PUSH
71497: LD_INT 2
71499: PUSH
71500: EMPTY
71501: LIST
71502: LIST
71503: PUSH
71504: LD_INT 24
71506: PUSH
71507: LD_INT 750
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: PPUSH
71518: CALL_OW 72
71522: AND
71523: PUSH
71524: LD_VAR 0 5
71528: PUSH
71529: LD_INT 5
71531: LESS
71532: AND
71533: IFFALSE 71615
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71535: LD_ADDR_VAR 0 3
71539: PUSH
71540: LD_EXP 61
71544: PUSH
71545: LD_VAR 0 2
71549: ARRAY
71550: PPUSH
71551: LD_INT 25
71553: PUSH
71554: LD_INT 2
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 24
71563: PUSH
71564: LD_INT 750
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PPUSH
71575: CALL_OW 72
71579: PUSH
71580: FOR_IN
71581: IFFALSE 71613
// begin tmp := tmp union j ;
71583: LD_ADDR_VAR 0 5
71587: PUSH
71588: LD_VAR 0 5
71592: PUSH
71593: LD_VAR 0 3
71597: UNION
71598: ST_TO_ADDR
// if tmp >= 5 then
71599: LD_VAR 0 5
71603: PUSH
71604: LD_INT 5
71606: GREATEREQUAL
71607: IFFALSE 71611
// break ;
71609: GO 71613
// end ;
71611: GO 71580
71613: POP
71614: POP
// end ; if not tmp then
71615: LD_VAR 0 5
71619: NOT
71620: IFFALSE 71624
// continue ;
71622: GO 70777
// for j in tmp do
71624: LD_ADDR_VAR 0 3
71628: PUSH
71629: LD_VAR 0 5
71633: PUSH
71634: FOR_IN
71635: IFFALSE 71725
// if not GetTag ( j ) then
71637: LD_VAR 0 3
71641: PPUSH
71642: CALL_OW 110
71646: NOT
71647: IFFALSE 71723
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71649: LD_ADDR_EXP 78
71653: PUSH
71654: LD_EXP 78
71658: PPUSH
71659: LD_VAR 0 2
71663: PUSH
71664: LD_EXP 78
71668: PUSH
71669: LD_VAR 0 2
71673: ARRAY
71674: PUSH
71675: LD_INT 1
71677: PLUS
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PPUSH
71683: LD_VAR 0 3
71687: PPUSH
71688: CALL 20463 0 3
71692: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71693: LD_VAR 0 3
71697: PPUSH
71698: LD_INT 107
71700: PPUSH
71701: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71705: LD_EXP 78
71709: PUSH
71710: LD_VAR 0 2
71714: ARRAY
71715: PUSH
71716: LD_INT 5
71718: GREATEREQUAL
71719: IFFALSE 71723
// break ;
71721: GO 71725
// end ;
71723: GO 71634
71725: POP
71726: POP
// end ; if mc_crates_collector [ i ] and target then
71727: LD_EXP 78
71731: PUSH
71732: LD_VAR 0 2
71736: ARRAY
71737: PUSH
71738: LD_VAR 0 7
71742: AND
71743: IFFALSE 72049
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71745: LD_EXP 78
71749: PUSH
71750: LD_VAR 0 2
71754: ARRAY
71755: PUSH
71756: LD_VAR 0 7
71760: PUSH
71761: LD_INT 1
71763: ARRAY
71764: LESS
71765: IFFALSE 71785
// tmp := mc_crates_collector [ i ] else
71767: LD_ADDR_VAR 0 5
71771: PUSH
71772: LD_EXP 78
71776: PUSH
71777: LD_VAR 0 2
71781: ARRAY
71782: ST_TO_ADDR
71783: GO 71799
// tmp := target [ 1 ] ;
71785: LD_ADDR_VAR 0 5
71789: PUSH
71790: LD_VAR 0 7
71794: PUSH
71795: LD_INT 1
71797: ARRAY
71798: ST_TO_ADDR
// k := 0 ;
71799: LD_ADDR_VAR 0 4
71803: PUSH
71804: LD_INT 0
71806: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71807: LD_ADDR_VAR 0 3
71811: PUSH
71812: LD_EXP 78
71816: PUSH
71817: LD_VAR 0 2
71821: ARRAY
71822: PUSH
71823: FOR_IN
71824: IFFALSE 72047
// begin k := k + 1 ;
71826: LD_ADDR_VAR 0 4
71830: PUSH
71831: LD_VAR 0 4
71835: PUSH
71836: LD_INT 1
71838: PLUS
71839: ST_TO_ADDR
// if k > tmp then
71840: LD_VAR 0 4
71844: PUSH
71845: LD_VAR 0 5
71849: GREATER
71850: IFFALSE 71854
// break ;
71852: GO 72047
// if not GetClass ( j ) in [ 2 , 16 ] then
71854: LD_VAR 0 3
71858: PPUSH
71859: CALL_OW 257
71863: PUSH
71864: LD_INT 2
71866: PUSH
71867: LD_INT 16
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: IN
71874: NOT
71875: IFFALSE 71928
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71877: LD_ADDR_EXP 78
71881: PUSH
71882: LD_EXP 78
71886: PPUSH
71887: LD_VAR 0 2
71891: PPUSH
71892: LD_EXP 78
71896: PUSH
71897: LD_VAR 0 2
71901: ARRAY
71902: PUSH
71903: LD_VAR 0 3
71907: DIFF
71908: PPUSH
71909: CALL_OW 1
71913: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71914: LD_VAR 0 3
71918: PPUSH
71919: LD_INT 0
71921: PPUSH
71922: CALL_OW 109
// continue ;
71926: GO 71823
// end ; if IsInUnit ( j ) then
71928: LD_VAR 0 3
71932: PPUSH
71933: CALL_OW 310
71937: IFFALSE 71948
// ComExitBuilding ( j ) ;
71939: LD_VAR 0 3
71943: PPUSH
71944: CALL_OW 122
// wait ( 3 ) ;
71948: LD_INT 3
71950: PPUSH
71951: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
71955: LD_VAR 0 3
71959: PPUSH
71960: CALL_OW 314
71964: PUSH
71965: LD_VAR 0 6
71969: PPUSH
71970: LD_VAR 0 7
71974: PUSH
71975: LD_INT 2
71977: ARRAY
71978: PPUSH
71979: LD_VAR 0 7
71983: PUSH
71984: LD_INT 3
71986: ARRAY
71987: PPUSH
71988: LD_INT 30
71990: PPUSH
71991: CALL 21727 0 4
71995: PUSH
71996: LD_INT 4
71998: ARRAY
71999: AND
72000: IFFALSE 72018
// ComStandNearbyBuilding ( j , depot ) else
72002: LD_VAR 0 3
72006: PPUSH
72007: LD_VAR 0 9
72011: PPUSH
72012: CALL 17065 0 2
72016: GO 72045
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72018: LD_VAR 0 3
72022: PPUSH
72023: LD_VAR 0 7
72027: PUSH
72028: LD_INT 2
72030: ARRAY
72031: PPUSH
72032: LD_VAR 0 7
72036: PUSH
72037: LD_INT 3
72039: ARRAY
72040: PPUSH
72041: CALL_OW 117
// end ;
72045: GO 71823
72047: POP
72048: POP
// end ; end else
72049: GO 72581
// begin for j in cargo do
72051: LD_ADDR_VAR 0 3
72055: PUSH
72056: LD_VAR 0 8
72060: PUSH
72061: FOR_IN
72062: IFFALSE 72579
// begin if GetTag ( j ) <> 0 then
72064: LD_VAR 0 3
72068: PPUSH
72069: CALL_OW 110
72073: PUSH
72074: LD_INT 0
72076: NONEQUAL
72077: IFFALSE 72081
// continue ;
72079: GO 72061
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
72081: LD_VAR 0 3
72085: PPUSH
72086: CALL_OW 256
72090: PUSH
72091: LD_INT 1000
72093: LESS
72094: PUSH
72095: LD_VAR 0 3
72099: PPUSH
72100: LD_EXP 85
72104: PUSH
72105: LD_VAR 0 2
72109: ARRAY
72110: PPUSH
72111: CALL_OW 308
72115: NOT
72116: AND
72117: IFFALSE 72139
// ComMoveToArea ( j , mc_parking [ i ] ) ;
72119: LD_VAR 0 3
72123: PPUSH
72124: LD_EXP 85
72128: PUSH
72129: LD_VAR 0 2
72133: ARRAY
72134: PPUSH
72135: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
72139: LD_VAR 0 3
72143: PPUSH
72144: CALL_OW 256
72148: PUSH
72149: LD_INT 1000
72151: LESS
72152: PUSH
72153: LD_VAR 0 3
72157: PPUSH
72158: LD_EXP 85
72162: PUSH
72163: LD_VAR 0 2
72167: ARRAY
72168: PPUSH
72169: CALL_OW 308
72173: AND
72174: IFFALSE 72178
// continue ;
72176: GO 72061
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
72178: LD_VAR 0 3
72182: PPUSH
72183: CALL_OW 262
72187: PUSH
72188: LD_INT 2
72190: EQUAL
72191: PUSH
72192: LD_VAR 0 3
72196: PPUSH
72197: CALL_OW 261
72201: PUSH
72202: LD_INT 15
72204: LESS
72205: AND
72206: IFFALSE 72210
// continue ;
72208: GO 72061
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
72210: LD_VAR 0 3
72214: PPUSH
72215: CALL_OW 262
72219: PUSH
72220: LD_INT 1
72222: EQUAL
72223: PUSH
72224: LD_VAR 0 3
72228: PPUSH
72229: CALL_OW 261
72233: PUSH
72234: LD_INT 10
72236: LESS
72237: AND
72238: IFFALSE 72518
// begin if not depot then
72240: LD_VAR 0 9
72244: NOT
72245: IFFALSE 72249
// continue ;
72247: GO 72061
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
72249: LD_VAR 0 3
72253: PPUSH
72254: LD_VAR 0 9
72258: PPUSH
72259: LD_VAR 0 3
72263: PPUSH
72264: CALL_OW 74
72268: PPUSH
72269: CALL_OW 296
72273: PUSH
72274: LD_INT 6
72276: LESS
72277: IFFALSE 72293
// SetFuel ( j , 100 ) else
72279: LD_VAR 0 3
72283: PPUSH
72284: LD_INT 100
72286: PPUSH
72287: CALL_OW 240
72291: GO 72518
// if GetFuel ( j ) = 0 then
72293: LD_VAR 0 3
72297: PPUSH
72298: CALL_OW 261
72302: PUSH
72303: LD_INT 0
72305: EQUAL
72306: IFFALSE 72518
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
72308: LD_ADDR_EXP 80
72312: PUSH
72313: LD_EXP 80
72317: PPUSH
72318: LD_VAR 0 2
72322: PPUSH
72323: LD_EXP 80
72327: PUSH
72328: LD_VAR 0 2
72332: ARRAY
72333: PUSH
72334: LD_VAR 0 3
72338: DIFF
72339: PPUSH
72340: CALL_OW 1
72344: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
72345: LD_VAR 0 3
72349: PPUSH
72350: CALL_OW 263
72354: PUSH
72355: LD_INT 1
72357: EQUAL
72358: IFFALSE 72374
// ComExitVehicle ( IsInUnit ( j ) ) ;
72360: LD_VAR 0 3
72364: PPUSH
72365: CALL_OW 310
72369: PPUSH
72370: CALL_OW 121
// if GetControl ( j ) = control_remote then
72374: LD_VAR 0 3
72378: PPUSH
72379: CALL_OW 263
72383: PUSH
72384: LD_INT 2
72386: EQUAL
72387: IFFALSE 72398
// ComUnlink ( j ) ;
72389: LD_VAR 0 3
72393: PPUSH
72394: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
72398: LD_ADDR_VAR 0 10
72402: PUSH
72403: LD_VAR 0 2
72407: PPUSH
72408: LD_INT 3
72410: PPUSH
72411: CALL 82162 0 2
72415: ST_TO_ADDR
// if fac then
72416: LD_VAR 0 10
72420: IFFALSE 72516
// begin for k in fac do
72422: LD_ADDR_VAR 0 4
72426: PUSH
72427: LD_VAR 0 10
72431: PUSH
72432: FOR_IN
72433: IFFALSE 72514
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
72435: LD_ADDR_VAR 0 11
72439: PUSH
72440: LD_VAR 0 10
72444: PPUSH
72445: LD_VAR 0 3
72449: PPUSH
72450: CALL_OW 265
72454: PPUSH
72455: LD_VAR 0 3
72459: PPUSH
72460: CALL_OW 262
72464: PPUSH
72465: LD_VAR 0 3
72469: PPUSH
72470: CALL_OW 263
72474: PPUSH
72475: LD_VAR 0 3
72479: PPUSH
72480: CALL_OW 264
72484: PPUSH
72485: CALL 17961 0 5
72489: ST_TO_ADDR
// if components then
72490: LD_VAR 0 11
72494: IFFALSE 72512
// begin MC_InsertProduceList ( i , components ) ;
72496: LD_VAR 0 2
72500: PPUSH
72501: LD_VAR 0 11
72505: PPUSH
72506: CALL 81707 0 2
// break ;
72510: GO 72514
// end ; end ;
72512: GO 72432
72514: POP
72515: POP
// end ; continue ;
72516: GO 72061
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72518: LD_VAR 0 3
72522: PPUSH
72523: LD_INT 1
72525: PPUSH
72526: CALL_OW 289
72530: PUSH
72531: LD_INT 100
72533: LESS
72534: PUSH
72535: LD_VAR 0 3
72539: PPUSH
72540: CALL_OW 314
72544: NOT
72545: AND
72546: IFFALSE 72575
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72548: LD_VAR 0 3
72552: PPUSH
72553: LD_VAR 0 7
72557: PUSH
72558: LD_INT 2
72560: ARRAY
72561: PPUSH
72562: LD_VAR 0 7
72566: PUSH
72567: LD_INT 3
72569: ARRAY
72570: PPUSH
72571: CALL_OW 117
// break ;
72575: GO 72579
// end ;
72577: GO 72061
72579: POP
72580: POP
// end ; end ;
72581: GO 70777
72583: POP
72584: POP
// end ;
72585: LD_VAR 0 1
72589: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72590: LD_INT 0
72592: PPUSH
72593: PPUSH
72594: PPUSH
72595: PPUSH
// if not mc_bases then
72596: LD_EXP 61
72600: NOT
72601: IFFALSE 72605
// exit ;
72603: GO 72766
// for i = 1 to mc_bases do
72605: LD_ADDR_VAR 0 2
72609: PUSH
72610: DOUBLE
72611: LD_INT 1
72613: DEC
72614: ST_TO_ADDR
72615: LD_EXP 61
72619: PUSH
72620: FOR_TO
72621: IFFALSE 72764
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72623: LD_ADDR_VAR 0 4
72627: PUSH
72628: LD_EXP 80
72632: PUSH
72633: LD_VAR 0 2
72637: ARRAY
72638: PUSH
72639: LD_EXP 83
72643: PUSH
72644: LD_VAR 0 2
72648: ARRAY
72649: UNION
72650: PPUSH
72651: LD_INT 33
72653: PUSH
72654: LD_INT 2
72656: PUSH
72657: EMPTY
72658: LIST
72659: LIST
72660: PPUSH
72661: CALL_OW 72
72665: ST_TO_ADDR
// if tmp then
72666: LD_VAR 0 4
72670: IFFALSE 72762
// for j in tmp do
72672: LD_ADDR_VAR 0 3
72676: PUSH
72677: LD_VAR 0 4
72681: PUSH
72682: FOR_IN
72683: IFFALSE 72760
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72685: LD_VAR 0 3
72689: PPUSH
72690: CALL_OW 312
72694: NOT
72695: PUSH
72696: LD_VAR 0 3
72700: PPUSH
72701: CALL_OW 256
72705: PUSH
72706: LD_INT 250
72708: GREATEREQUAL
72709: AND
72710: IFFALSE 72723
// Connect ( j ) else
72712: LD_VAR 0 3
72716: PPUSH
72717: CALL 23809 0 1
72721: GO 72758
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72723: LD_VAR 0 3
72727: PPUSH
72728: CALL_OW 256
72732: PUSH
72733: LD_INT 250
72735: LESS
72736: PUSH
72737: LD_VAR 0 3
72741: PPUSH
72742: CALL_OW 312
72746: AND
72747: IFFALSE 72758
// ComUnlink ( j ) ;
72749: LD_VAR 0 3
72753: PPUSH
72754: CALL_OW 136
72758: GO 72682
72760: POP
72761: POP
// end ;
72762: GO 72620
72764: POP
72765: POP
// end ;
72766: LD_VAR 0 1
72770: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72771: LD_INT 0
72773: PPUSH
72774: PPUSH
72775: PPUSH
72776: PPUSH
72777: PPUSH
// if not mc_bases then
72778: LD_EXP 61
72782: NOT
72783: IFFALSE 72787
// exit ;
72785: GO 73232
// for i = 1 to mc_bases do
72787: LD_ADDR_VAR 0 2
72791: PUSH
72792: DOUBLE
72793: LD_INT 1
72795: DEC
72796: ST_TO_ADDR
72797: LD_EXP 61
72801: PUSH
72802: FOR_TO
72803: IFFALSE 73230
// begin if not mc_produce [ i ] then
72805: LD_EXP 82
72809: PUSH
72810: LD_VAR 0 2
72814: ARRAY
72815: NOT
72816: IFFALSE 72820
// continue ;
72818: GO 72802
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72820: LD_ADDR_VAR 0 5
72824: PUSH
72825: LD_EXP 61
72829: PUSH
72830: LD_VAR 0 2
72834: ARRAY
72835: PPUSH
72836: LD_INT 30
72838: PUSH
72839: LD_INT 3
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: PPUSH
72846: CALL_OW 72
72850: ST_TO_ADDR
// if not fac then
72851: LD_VAR 0 5
72855: NOT
72856: IFFALSE 72860
// continue ;
72858: GO 72802
// for j in fac do
72860: LD_ADDR_VAR 0 3
72864: PUSH
72865: LD_VAR 0 5
72869: PUSH
72870: FOR_IN
72871: IFFALSE 73226
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72873: LD_VAR 0 3
72877: PPUSH
72878: CALL_OW 461
72882: PUSH
72883: LD_INT 2
72885: NONEQUAL
72886: PUSH
72887: LD_VAR 0 3
72891: PPUSH
72892: LD_INT 15
72894: PPUSH
72895: CALL 23428 0 2
72899: PUSH
72900: LD_INT 4
72902: ARRAY
72903: OR
72904: IFFALSE 72908
// continue ;
72906: GO 72870
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72908: LD_VAR 0 3
72912: PPUSH
72913: LD_EXP 82
72917: PUSH
72918: LD_VAR 0 2
72922: ARRAY
72923: PUSH
72924: LD_INT 1
72926: ARRAY
72927: PUSH
72928: LD_INT 1
72930: ARRAY
72931: PPUSH
72932: LD_EXP 82
72936: PUSH
72937: LD_VAR 0 2
72941: ARRAY
72942: PUSH
72943: LD_INT 1
72945: ARRAY
72946: PUSH
72947: LD_INT 2
72949: ARRAY
72950: PPUSH
72951: LD_EXP 82
72955: PUSH
72956: LD_VAR 0 2
72960: ARRAY
72961: PUSH
72962: LD_INT 1
72964: ARRAY
72965: PUSH
72966: LD_INT 3
72968: ARRAY
72969: PPUSH
72970: LD_EXP 82
72974: PUSH
72975: LD_VAR 0 2
72979: ARRAY
72980: PUSH
72981: LD_INT 1
72983: ARRAY
72984: PUSH
72985: LD_INT 4
72987: ARRAY
72988: PPUSH
72989: CALL_OW 448
72993: PUSH
72994: LD_VAR 0 3
72998: PPUSH
72999: LD_EXP 82
73003: PUSH
73004: LD_VAR 0 2
73008: ARRAY
73009: PUSH
73010: LD_INT 1
73012: ARRAY
73013: PUSH
73014: LD_INT 1
73016: ARRAY
73017: PUSH
73018: LD_EXP 82
73022: PUSH
73023: LD_VAR 0 2
73027: ARRAY
73028: PUSH
73029: LD_INT 1
73031: ARRAY
73032: PUSH
73033: LD_INT 2
73035: ARRAY
73036: PUSH
73037: LD_EXP 82
73041: PUSH
73042: LD_VAR 0 2
73046: ARRAY
73047: PUSH
73048: LD_INT 1
73050: ARRAY
73051: PUSH
73052: LD_INT 3
73054: ARRAY
73055: PUSH
73056: LD_EXP 82
73060: PUSH
73061: LD_VAR 0 2
73065: ARRAY
73066: PUSH
73067: LD_INT 1
73069: ARRAY
73070: PUSH
73071: LD_INT 4
73073: ARRAY
73074: PUSH
73075: EMPTY
73076: LIST
73077: LIST
73078: LIST
73079: LIST
73080: PPUSH
73081: CALL 27204 0 2
73085: AND
73086: IFFALSE 73224
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
73088: LD_VAR 0 3
73092: PPUSH
73093: LD_EXP 82
73097: PUSH
73098: LD_VAR 0 2
73102: ARRAY
73103: PUSH
73104: LD_INT 1
73106: ARRAY
73107: PUSH
73108: LD_INT 1
73110: ARRAY
73111: PPUSH
73112: LD_EXP 82
73116: PUSH
73117: LD_VAR 0 2
73121: ARRAY
73122: PUSH
73123: LD_INT 1
73125: ARRAY
73126: PUSH
73127: LD_INT 2
73129: ARRAY
73130: PPUSH
73131: LD_EXP 82
73135: PUSH
73136: LD_VAR 0 2
73140: ARRAY
73141: PUSH
73142: LD_INT 1
73144: ARRAY
73145: PUSH
73146: LD_INT 3
73148: ARRAY
73149: PPUSH
73150: LD_EXP 82
73154: PUSH
73155: LD_VAR 0 2
73159: ARRAY
73160: PUSH
73161: LD_INT 1
73163: ARRAY
73164: PUSH
73165: LD_INT 4
73167: ARRAY
73168: PPUSH
73169: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
73173: LD_ADDR_VAR 0 4
73177: PUSH
73178: LD_EXP 82
73182: PUSH
73183: LD_VAR 0 2
73187: ARRAY
73188: PPUSH
73189: LD_INT 1
73191: PPUSH
73192: CALL_OW 3
73196: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
73197: LD_ADDR_EXP 82
73201: PUSH
73202: LD_EXP 82
73206: PPUSH
73207: LD_VAR 0 2
73211: PPUSH
73212: LD_VAR 0 4
73216: PPUSH
73217: CALL_OW 1
73221: ST_TO_ADDR
// break ;
73222: GO 73226
// end ; end ;
73224: GO 72870
73226: POP
73227: POP
// end ;
73228: GO 72802
73230: POP
73231: POP
// end ;
73232: LD_VAR 0 1
73236: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
73237: LD_INT 0
73239: PPUSH
73240: PPUSH
73241: PPUSH
// if not mc_bases then
73242: LD_EXP 61
73246: NOT
73247: IFFALSE 73251
// exit ;
73249: GO 73340
// for i = 1 to mc_bases do
73251: LD_ADDR_VAR 0 2
73255: PUSH
73256: DOUBLE
73257: LD_INT 1
73259: DEC
73260: ST_TO_ADDR
73261: LD_EXP 61
73265: PUSH
73266: FOR_TO
73267: IFFALSE 73338
// begin if mc_attack [ i ] then
73269: LD_EXP 81
73273: PUSH
73274: LD_VAR 0 2
73278: ARRAY
73279: IFFALSE 73336
// begin tmp := mc_attack [ i ] [ 1 ] ;
73281: LD_ADDR_VAR 0 3
73285: PUSH
73286: LD_EXP 81
73290: PUSH
73291: LD_VAR 0 2
73295: ARRAY
73296: PUSH
73297: LD_INT 1
73299: ARRAY
73300: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
73301: LD_ADDR_EXP 81
73305: PUSH
73306: LD_EXP 81
73310: PPUSH
73311: LD_VAR 0 2
73315: PPUSH
73316: EMPTY
73317: PPUSH
73318: CALL_OW 1
73322: ST_TO_ADDR
// Attack ( tmp ) ;
73323: LD_VAR 0 3
73327: PPUSH
73328: CALL 108663 0 1
// exit ;
73332: POP
73333: POP
73334: GO 73340
// end ; end ;
73336: GO 73266
73338: POP
73339: POP
// end ;
73340: LD_VAR 0 1
73344: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
73345: LD_INT 0
73347: PPUSH
73348: PPUSH
73349: PPUSH
73350: PPUSH
73351: PPUSH
73352: PPUSH
73353: PPUSH
// if not mc_bases then
73354: LD_EXP 61
73358: NOT
73359: IFFALSE 73363
// exit ;
73361: GO 74220
// for i = 1 to mc_bases do
73363: LD_ADDR_VAR 0 2
73367: PUSH
73368: DOUBLE
73369: LD_INT 1
73371: DEC
73372: ST_TO_ADDR
73373: LD_EXP 61
73377: PUSH
73378: FOR_TO
73379: IFFALSE 74218
// begin if not mc_bases [ i ] then
73381: LD_EXP 61
73385: PUSH
73386: LD_VAR 0 2
73390: ARRAY
73391: NOT
73392: IFFALSE 73396
// continue ;
73394: GO 73378
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
73396: LD_ADDR_VAR 0 7
73400: PUSH
73401: LD_EXP 61
73405: PUSH
73406: LD_VAR 0 2
73410: ARRAY
73411: PUSH
73412: LD_INT 1
73414: ARRAY
73415: PPUSH
73416: CALL 17287 0 1
73420: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
73421: LD_ADDR_EXP 84
73425: PUSH
73426: LD_EXP 84
73430: PPUSH
73431: LD_VAR 0 2
73435: PPUSH
73436: LD_EXP 61
73440: PUSH
73441: LD_VAR 0 2
73445: ARRAY
73446: PUSH
73447: LD_INT 1
73449: ARRAY
73450: PPUSH
73451: CALL_OW 255
73455: PPUSH
73456: LD_EXP 86
73460: PUSH
73461: LD_VAR 0 2
73465: ARRAY
73466: PPUSH
73467: CALL 17252 0 2
73471: PPUSH
73472: CALL_OW 1
73476: ST_TO_ADDR
// if not mc_scan [ i ] then
73477: LD_EXP 84
73481: PUSH
73482: LD_VAR 0 2
73486: ARRAY
73487: NOT
73488: IFFALSE 73666
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
73490: LD_ADDR_EXP 104
73494: PUSH
73495: LD_EXP 104
73499: PPUSH
73500: LD_VAR 0 2
73504: PPUSH
73505: LD_INT 0
73507: PPUSH
73508: CALL_OW 1
73512: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73513: LD_ADDR_VAR 0 4
73517: PUSH
73518: LD_EXP 61
73522: PUSH
73523: LD_VAR 0 2
73527: ARRAY
73528: PPUSH
73529: LD_INT 2
73531: PUSH
73532: LD_INT 25
73534: PUSH
73535: LD_INT 5
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: PUSH
73542: LD_INT 25
73544: PUSH
73545: LD_INT 8
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: PUSH
73552: LD_INT 25
73554: PUSH
73555: LD_INT 9
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: PPUSH
73568: CALL_OW 72
73572: ST_TO_ADDR
// if not tmp then
73573: LD_VAR 0 4
73577: NOT
73578: IFFALSE 73582
// continue ;
73580: GO 73378
// for j in tmp do
73582: LD_ADDR_VAR 0 3
73586: PUSH
73587: LD_VAR 0 4
73591: PUSH
73592: FOR_IN
73593: IFFALSE 73664
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73595: LD_VAR 0 3
73599: PPUSH
73600: CALL_OW 310
73604: PPUSH
73605: CALL_OW 266
73609: PUSH
73610: LD_INT 5
73612: EQUAL
73613: PUSH
73614: LD_VAR 0 3
73618: PPUSH
73619: CALL_OW 257
73623: PUSH
73624: LD_INT 1
73626: EQUAL
73627: AND
73628: PUSH
73629: LD_VAR 0 3
73633: PPUSH
73634: CALL_OW 459
73638: NOT
73639: AND
73640: PUSH
73641: LD_VAR 0 7
73645: AND
73646: IFFALSE 73662
// ComChangeProfession ( j , class ) ;
73648: LD_VAR 0 3
73652: PPUSH
73653: LD_VAR 0 7
73657: PPUSH
73658: CALL_OW 123
73662: GO 73592
73664: POP
73665: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
73666: LD_EXP 84
73670: PUSH
73671: LD_VAR 0 2
73675: ARRAY
73676: PUSH
73677: LD_EXP 104
73681: PUSH
73682: LD_VAR 0 2
73686: ARRAY
73687: NOT
73688: AND
73689: PUSH
73690: LD_EXP 83
73694: PUSH
73695: LD_VAR 0 2
73699: ARRAY
73700: NOT
73701: AND
73702: PUSH
73703: LD_EXP 61
73707: PUSH
73708: LD_VAR 0 2
73712: ARRAY
73713: PPUSH
73714: LD_INT 50
73716: PUSH
73717: EMPTY
73718: LIST
73719: PUSH
73720: LD_INT 2
73722: PUSH
73723: LD_INT 30
73725: PUSH
73726: LD_INT 32
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: PUSH
73733: LD_INT 30
73735: PUSH
73736: LD_INT 33
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PUSH
73743: LD_INT 30
73745: PUSH
73746: LD_INT 4
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 30
73755: PUSH
73756: LD_INT 5
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: PUSH
73763: EMPTY
73764: LIST
73765: LIST
73766: LIST
73767: LIST
73768: LIST
73769: PUSH
73770: EMPTY
73771: LIST
73772: LIST
73773: PPUSH
73774: CALL_OW 72
73778: PUSH
73779: LD_INT 4
73781: LESS
73782: PUSH
73783: LD_EXP 61
73787: PUSH
73788: LD_VAR 0 2
73792: ARRAY
73793: PPUSH
73794: LD_INT 3
73796: PUSH
73797: LD_INT 24
73799: PUSH
73800: LD_INT 1000
73802: PUSH
73803: EMPTY
73804: LIST
73805: LIST
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: LD_INT 2
73813: PUSH
73814: LD_INT 30
73816: PUSH
73817: LD_INT 0
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: LD_INT 30
73826: PUSH
73827: LD_INT 1
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: EMPTY
73835: LIST
73836: LIST
73837: LIST
73838: PUSH
73839: EMPTY
73840: LIST
73841: LIST
73842: PPUSH
73843: CALL_OW 72
73847: OR
73848: AND
73849: IFFALSE 74100
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
73851: LD_ADDR_EXP 104
73855: PUSH
73856: LD_EXP 104
73860: PPUSH
73861: LD_VAR 0 2
73865: PPUSH
73866: LD_INT 1
73868: PPUSH
73869: CALL_OW 1
73873: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73874: LD_ADDR_VAR 0 4
73878: PUSH
73879: LD_EXP 61
73883: PUSH
73884: LD_VAR 0 2
73888: ARRAY
73889: PPUSH
73890: LD_INT 2
73892: PUSH
73893: LD_INT 25
73895: PUSH
73896: LD_INT 1
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 25
73905: PUSH
73906: LD_INT 5
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 25
73915: PUSH
73916: LD_INT 8
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 25
73925: PUSH
73926: LD_INT 9
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: LIST
73937: LIST
73938: LIST
73939: PPUSH
73940: CALL_OW 72
73944: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73945: LD_ADDR_VAR 0 4
73949: PUSH
73950: LD_VAR 0 4
73954: PUSH
73955: LD_VAR 0 4
73959: PPUSH
73960: LD_INT 18
73962: PPUSH
73963: CALL 50772 0 2
73967: DIFF
73968: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73969: LD_VAR 0 4
73973: NOT
73974: PUSH
73975: LD_EXP 61
73979: PUSH
73980: LD_VAR 0 2
73984: ARRAY
73985: PPUSH
73986: LD_INT 2
73988: PUSH
73989: LD_INT 30
73991: PUSH
73992: LD_INT 4
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: PUSH
73999: LD_INT 30
74001: PUSH
74002: LD_INT 5
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: LIST
74013: PPUSH
74014: CALL_OW 72
74018: NOT
74019: AND
74020: IFFALSE 74082
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
74022: LD_ADDR_VAR 0 4
74026: PUSH
74027: LD_EXP 61
74031: PUSH
74032: LD_VAR 0 2
74036: ARRAY
74037: PPUSH
74038: LD_INT 2
74040: PUSH
74041: LD_INT 25
74043: PUSH
74044: LD_INT 2
74046: PUSH
74047: EMPTY
74048: LIST
74049: LIST
74050: PUSH
74051: LD_INT 25
74053: PUSH
74054: LD_INT 3
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PUSH
74061: LD_INT 25
74063: PUSH
74064: LD_INT 4
74066: PUSH
74067: EMPTY
74068: LIST
74069: LIST
74070: PUSH
74071: EMPTY
74072: LIST
74073: LIST
74074: LIST
74075: LIST
74076: PPUSH
74077: CALL_OW 72
74081: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
74082: LD_VAR 0 2
74086: PPUSH
74087: LD_VAR 0 4
74091: PPUSH
74092: CALL 113372 0 2
// exit ;
74096: POP
74097: POP
74098: GO 74220
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
74100: LD_EXP 84
74104: PUSH
74105: LD_VAR 0 2
74109: ARRAY
74110: PUSH
74111: LD_EXP 104
74115: PUSH
74116: LD_VAR 0 2
74120: ARRAY
74121: NOT
74122: AND
74123: PUSH
74124: LD_EXP 83
74128: PUSH
74129: LD_VAR 0 2
74133: ARRAY
74134: AND
74135: IFFALSE 74216
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
74137: LD_ADDR_EXP 104
74141: PUSH
74142: LD_EXP 104
74146: PPUSH
74147: LD_VAR 0 2
74151: PPUSH
74152: LD_INT 1
74154: PPUSH
74155: CALL_OW 1
74159: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
74160: LD_ADDR_VAR 0 4
74164: PUSH
74165: LD_EXP 83
74169: PUSH
74170: LD_VAR 0 2
74174: ARRAY
74175: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
74176: LD_ADDR_EXP 83
74180: PUSH
74181: LD_EXP 83
74185: PPUSH
74186: LD_VAR 0 2
74190: PPUSH
74191: EMPTY
74192: PPUSH
74193: CALL_OW 1
74197: ST_TO_ADDR
// Defend ( i , tmp ) ;
74198: LD_VAR 0 2
74202: PPUSH
74203: LD_VAR 0 4
74207: PPUSH
74208: CALL 113968 0 2
// exit ;
74212: POP
74213: POP
74214: GO 74220
// end ; end ;
74216: GO 73378
74218: POP
74219: POP
// end ;
74220: LD_VAR 0 1
74224: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
74225: LD_INT 0
74227: PPUSH
74228: PPUSH
74229: PPUSH
74230: PPUSH
74231: PPUSH
74232: PPUSH
74233: PPUSH
74234: PPUSH
74235: PPUSH
74236: PPUSH
74237: PPUSH
// if not mc_bases then
74238: LD_EXP 61
74242: NOT
74243: IFFALSE 74247
// exit ;
74245: GO 75334
// for i = 1 to mc_bases do
74247: LD_ADDR_VAR 0 2
74251: PUSH
74252: DOUBLE
74253: LD_INT 1
74255: DEC
74256: ST_TO_ADDR
74257: LD_EXP 61
74261: PUSH
74262: FOR_TO
74263: IFFALSE 75332
// begin tmp := mc_lab [ i ] ;
74265: LD_ADDR_VAR 0 6
74269: PUSH
74270: LD_EXP 94
74274: PUSH
74275: LD_VAR 0 2
74279: ARRAY
74280: ST_TO_ADDR
// if not tmp then
74281: LD_VAR 0 6
74285: NOT
74286: IFFALSE 74290
// continue ;
74288: GO 74262
// idle_lab := 0 ;
74290: LD_ADDR_VAR 0 11
74294: PUSH
74295: LD_INT 0
74297: ST_TO_ADDR
// for j in tmp do
74298: LD_ADDR_VAR 0 3
74302: PUSH
74303: LD_VAR 0 6
74307: PUSH
74308: FOR_IN
74309: IFFALSE 75328
// begin researching := false ;
74311: LD_ADDR_VAR 0 10
74315: PUSH
74316: LD_INT 0
74318: ST_TO_ADDR
// side := GetSide ( j ) ;
74319: LD_ADDR_VAR 0 4
74323: PUSH
74324: LD_VAR 0 3
74328: PPUSH
74329: CALL_OW 255
74333: ST_TO_ADDR
// if not mc_tech [ side ] then
74334: LD_EXP 88
74338: PUSH
74339: LD_VAR 0 4
74343: ARRAY
74344: NOT
74345: IFFALSE 74349
// continue ;
74347: GO 74308
// if BuildingStatus ( j ) = bs_idle then
74349: LD_VAR 0 3
74353: PPUSH
74354: CALL_OW 461
74358: PUSH
74359: LD_INT 2
74361: EQUAL
74362: IFFALSE 74550
// begin if idle_lab and UnitsInside ( j ) < 6 then
74364: LD_VAR 0 11
74368: PUSH
74369: LD_VAR 0 3
74373: PPUSH
74374: CALL_OW 313
74378: PUSH
74379: LD_INT 6
74381: LESS
74382: AND
74383: IFFALSE 74454
// begin tmp2 := UnitsInside ( idle_lab ) ;
74385: LD_ADDR_VAR 0 9
74389: PUSH
74390: LD_VAR 0 11
74394: PPUSH
74395: CALL_OW 313
74399: ST_TO_ADDR
// if tmp2 then
74400: LD_VAR 0 9
74404: IFFALSE 74446
// for x in tmp2 do
74406: LD_ADDR_VAR 0 7
74410: PUSH
74411: LD_VAR 0 9
74415: PUSH
74416: FOR_IN
74417: IFFALSE 74444
// begin ComExitBuilding ( x ) ;
74419: LD_VAR 0 7
74423: PPUSH
74424: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74428: LD_VAR 0 7
74432: PPUSH
74433: LD_VAR 0 3
74437: PPUSH
74438: CALL_OW 180
// end ;
74442: GO 74416
74444: POP
74445: POP
// idle_lab := 0 ;
74446: LD_ADDR_VAR 0 11
74450: PUSH
74451: LD_INT 0
74453: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
74454: LD_ADDR_VAR 0 5
74458: PUSH
74459: LD_EXP 88
74463: PUSH
74464: LD_VAR 0 4
74468: ARRAY
74469: PUSH
74470: FOR_IN
74471: IFFALSE 74531
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
74473: LD_VAR 0 3
74477: PPUSH
74478: LD_VAR 0 5
74482: PPUSH
74483: CALL_OW 430
74487: PUSH
74488: LD_VAR 0 4
74492: PPUSH
74493: LD_VAR 0 5
74497: PPUSH
74498: CALL 16357 0 2
74502: AND
74503: IFFALSE 74529
// begin researching := true ;
74505: LD_ADDR_VAR 0 10
74509: PUSH
74510: LD_INT 1
74512: ST_TO_ADDR
// ComResearch ( j , t ) ;
74513: LD_VAR 0 3
74517: PPUSH
74518: LD_VAR 0 5
74522: PPUSH
74523: CALL_OW 124
// break ;
74527: GO 74531
// end ;
74529: GO 74470
74531: POP
74532: POP
// if not researching then
74533: LD_VAR 0 10
74537: NOT
74538: IFFALSE 74550
// idle_lab := j ;
74540: LD_ADDR_VAR 0 11
74544: PUSH
74545: LD_VAR 0 3
74549: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
74550: LD_VAR 0 3
74554: PPUSH
74555: CALL_OW 461
74559: PUSH
74560: LD_INT 10
74562: EQUAL
74563: IFFALSE 75151
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
74565: LD_EXP 90
74569: PUSH
74570: LD_VAR 0 2
74574: ARRAY
74575: NOT
74576: PUSH
74577: LD_EXP 91
74581: PUSH
74582: LD_VAR 0 2
74586: ARRAY
74587: NOT
74588: AND
74589: PUSH
74590: LD_EXP 88
74594: PUSH
74595: LD_VAR 0 4
74599: ARRAY
74600: PUSH
74601: LD_INT 1
74603: GREATER
74604: AND
74605: IFFALSE 74736
// begin ComCancel ( j ) ;
74607: LD_VAR 0 3
74611: PPUSH
74612: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
74616: LD_ADDR_EXP 88
74620: PUSH
74621: LD_EXP 88
74625: PPUSH
74626: LD_VAR 0 4
74630: PPUSH
74631: LD_EXP 88
74635: PUSH
74636: LD_VAR 0 4
74640: ARRAY
74641: PPUSH
74642: LD_EXP 88
74646: PUSH
74647: LD_VAR 0 4
74651: ARRAY
74652: PUSH
74653: LD_INT 1
74655: MINUS
74656: PPUSH
74657: LD_EXP 88
74661: PUSH
74662: LD_VAR 0 4
74666: ARRAY
74667: PPUSH
74668: LD_INT 0
74670: PPUSH
74671: CALL 19881 0 4
74675: PPUSH
74676: CALL_OW 1
74680: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
74681: LD_ADDR_EXP 88
74685: PUSH
74686: LD_EXP 88
74690: PPUSH
74691: LD_VAR 0 4
74695: PPUSH
74696: LD_EXP 88
74700: PUSH
74701: LD_VAR 0 4
74705: ARRAY
74706: PPUSH
74707: LD_EXP 88
74711: PUSH
74712: LD_VAR 0 4
74716: ARRAY
74717: PPUSH
74718: LD_INT 1
74720: PPUSH
74721: LD_INT 0
74723: PPUSH
74724: CALL 19881 0 4
74728: PPUSH
74729: CALL_OW 1
74733: ST_TO_ADDR
// continue ;
74734: GO 74308
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74736: LD_EXP 90
74740: PUSH
74741: LD_VAR 0 2
74745: ARRAY
74746: PUSH
74747: LD_EXP 91
74751: PUSH
74752: LD_VAR 0 2
74756: ARRAY
74757: NOT
74758: AND
74759: IFFALSE 74886
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74761: LD_ADDR_EXP 91
74765: PUSH
74766: LD_EXP 91
74770: PPUSH
74771: LD_VAR 0 2
74775: PUSH
74776: LD_EXP 91
74780: PUSH
74781: LD_VAR 0 2
74785: ARRAY
74786: PUSH
74787: LD_INT 1
74789: PLUS
74790: PUSH
74791: EMPTY
74792: LIST
74793: LIST
74794: PPUSH
74795: LD_EXP 90
74799: PUSH
74800: LD_VAR 0 2
74804: ARRAY
74805: PUSH
74806: LD_INT 1
74808: ARRAY
74809: PPUSH
74810: CALL 20463 0 3
74814: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74815: LD_EXP 90
74819: PUSH
74820: LD_VAR 0 2
74824: ARRAY
74825: PUSH
74826: LD_INT 1
74828: ARRAY
74829: PPUSH
74830: LD_INT 112
74832: PPUSH
74833: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74837: LD_ADDR_VAR 0 9
74841: PUSH
74842: LD_EXP 90
74846: PUSH
74847: LD_VAR 0 2
74851: ARRAY
74852: PPUSH
74853: LD_INT 1
74855: PPUSH
74856: CALL_OW 3
74860: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74861: LD_ADDR_EXP 90
74865: PUSH
74866: LD_EXP 90
74870: PPUSH
74871: LD_VAR 0 2
74875: PPUSH
74876: LD_VAR 0 9
74880: PPUSH
74881: CALL_OW 1
74885: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74886: LD_EXP 90
74890: PUSH
74891: LD_VAR 0 2
74895: ARRAY
74896: PUSH
74897: LD_EXP 91
74901: PUSH
74902: LD_VAR 0 2
74906: ARRAY
74907: AND
74908: PUSH
74909: LD_EXP 91
74913: PUSH
74914: LD_VAR 0 2
74918: ARRAY
74919: PUSH
74920: LD_INT 1
74922: ARRAY
74923: PPUSH
74924: CALL_OW 310
74928: NOT
74929: AND
74930: PUSH
74931: LD_VAR 0 3
74935: PPUSH
74936: CALL_OW 313
74940: PUSH
74941: LD_INT 6
74943: EQUAL
74944: AND
74945: IFFALSE 75001
// begin tmp2 := UnitsInside ( j ) ;
74947: LD_ADDR_VAR 0 9
74951: PUSH
74952: LD_VAR 0 3
74956: PPUSH
74957: CALL_OW 313
74961: ST_TO_ADDR
// if tmp2 = 6 then
74962: LD_VAR 0 9
74966: PUSH
74967: LD_INT 6
74969: EQUAL
74970: IFFALSE 75001
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74972: LD_VAR 0 9
74976: PUSH
74977: LD_INT 1
74979: ARRAY
74980: PPUSH
74981: LD_INT 112
74983: PPUSH
74984: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74988: LD_VAR 0 9
74992: PUSH
74993: LD_INT 1
74995: ARRAY
74996: PPUSH
74997: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
75001: LD_EXP 91
75005: PUSH
75006: LD_VAR 0 2
75010: ARRAY
75011: PUSH
75012: LD_EXP 91
75016: PUSH
75017: LD_VAR 0 2
75021: ARRAY
75022: PUSH
75023: LD_INT 1
75025: ARRAY
75026: PPUSH
75027: CALL_OW 314
75031: NOT
75032: AND
75033: PUSH
75034: LD_EXP 91
75038: PUSH
75039: LD_VAR 0 2
75043: ARRAY
75044: PUSH
75045: LD_INT 1
75047: ARRAY
75048: PPUSH
75049: CALL_OW 310
75053: NOT
75054: AND
75055: IFFALSE 75081
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
75057: LD_EXP 91
75061: PUSH
75062: LD_VAR 0 2
75066: ARRAY
75067: PUSH
75068: LD_INT 1
75070: ARRAY
75071: PPUSH
75072: LD_VAR 0 3
75076: PPUSH
75077: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
75081: LD_EXP 91
75085: PUSH
75086: LD_VAR 0 2
75090: ARRAY
75091: PUSH
75092: LD_INT 1
75094: ARRAY
75095: PPUSH
75096: CALL_OW 310
75100: PUSH
75101: LD_EXP 91
75105: PUSH
75106: LD_VAR 0 2
75110: ARRAY
75111: PUSH
75112: LD_INT 1
75114: ARRAY
75115: PPUSH
75116: CALL_OW 310
75120: PPUSH
75121: CALL_OW 461
75125: PUSH
75126: LD_INT 3
75128: NONEQUAL
75129: AND
75130: IFFALSE 75151
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
75132: LD_EXP 91
75136: PUSH
75137: LD_VAR 0 2
75141: ARRAY
75142: PUSH
75143: LD_INT 1
75145: ARRAY
75146: PPUSH
75147: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
75151: LD_VAR 0 3
75155: PPUSH
75156: CALL_OW 461
75160: PUSH
75161: LD_INT 6
75163: EQUAL
75164: PUSH
75165: LD_VAR 0 6
75169: PUSH
75170: LD_INT 1
75172: GREATER
75173: AND
75174: IFFALSE 75326
// begin sci := [ ] ;
75176: LD_ADDR_VAR 0 8
75180: PUSH
75181: EMPTY
75182: ST_TO_ADDR
// for x in ( tmp diff j ) do
75183: LD_ADDR_VAR 0 7
75187: PUSH
75188: LD_VAR 0 6
75192: PUSH
75193: LD_VAR 0 3
75197: DIFF
75198: PUSH
75199: FOR_IN
75200: IFFALSE 75252
// begin if sci = 6 then
75202: LD_VAR 0 8
75206: PUSH
75207: LD_INT 6
75209: EQUAL
75210: IFFALSE 75214
// break ;
75212: GO 75252
// if BuildingStatus ( x ) = bs_idle then
75214: LD_VAR 0 7
75218: PPUSH
75219: CALL_OW 461
75223: PUSH
75224: LD_INT 2
75226: EQUAL
75227: IFFALSE 75250
// sci := sci ^ UnitsInside ( x ) ;
75229: LD_ADDR_VAR 0 8
75233: PUSH
75234: LD_VAR 0 8
75238: PUSH
75239: LD_VAR 0 7
75243: PPUSH
75244: CALL_OW 313
75248: ADD
75249: ST_TO_ADDR
// end ;
75250: GO 75199
75252: POP
75253: POP
// if not sci then
75254: LD_VAR 0 8
75258: NOT
75259: IFFALSE 75263
// continue ;
75261: GO 74308
// for x in sci do
75263: LD_ADDR_VAR 0 7
75267: PUSH
75268: LD_VAR 0 8
75272: PUSH
75273: FOR_IN
75274: IFFALSE 75324
// if IsInUnit ( x ) and not HasTask ( x ) then
75276: LD_VAR 0 7
75280: PPUSH
75281: CALL_OW 310
75285: PUSH
75286: LD_VAR 0 7
75290: PPUSH
75291: CALL_OW 314
75295: NOT
75296: AND
75297: IFFALSE 75322
// begin ComExitBuilding ( x ) ;
75299: LD_VAR 0 7
75303: PPUSH
75304: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
75308: LD_VAR 0 7
75312: PPUSH
75313: LD_VAR 0 3
75317: PPUSH
75318: CALL_OW 180
// end ;
75322: GO 75273
75324: POP
75325: POP
// end ; end ;
75326: GO 74308
75328: POP
75329: POP
// end ;
75330: GO 74262
75332: POP
75333: POP
// end ;
75334: LD_VAR 0 1
75338: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
75339: LD_INT 0
75341: PPUSH
75342: PPUSH
// if not mc_bases then
75343: LD_EXP 61
75347: NOT
75348: IFFALSE 75352
// exit ;
75350: GO 75433
// for i = 1 to mc_bases do
75352: LD_ADDR_VAR 0 2
75356: PUSH
75357: DOUBLE
75358: LD_INT 1
75360: DEC
75361: ST_TO_ADDR
75362: LD_EXP 61
75366: PUSH
75367: FOR_TO
75368: IFFALSE 75431
// if mc_mines [ i ] and mc_miners [ i ] then
75370: LD_EXP 74
75374: PUSH
75375: LD_VAR 0 2
75379: ARRAY
75380: PUSH
75381: LD_EXP 75
75385: PUSH
75386: LD_VAR 0 2
75390: ARRAY
75391: AND
75392: IFFALSE 75429
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
75394: LD_EXP 75
75398: PUSH
75399: LD_VAR 0 2
75403: ARRAY
75404: PUSH
75405: LD_INT 1
75407: ARRAY
75408: PPUSH
75409: CALL_OW 255
75413: PPUSH
75414: LD_EXP 74
75418: PUSH
75419: LD_VAR 0 2
75423: ARRAY
75424: PPUSH
75425: CALL 17440 0 2
75429: GO 75367
75431: POP
75432: POP
// end ;
75433: LD_VAR 0 1
75437: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
75438: LD_INT 0
75440: PPUSH
75441: PPUSH
75442: PPUSH
75443: PPUSH
75444: PPUSH
75445: PPUSH
75446: PPUSH
75447: PPUSH
// if not mc_bases or not mc_parking then
75448: LD_EXP 61
75452: NOT
75453: PUSH
75454: LD_EXP 85
75458: NOT
75459: OR
75460: IFFALSE 75464
// exit ;
75462: GO 76202
// for i = 1 to mc_bases do
75464: LD_ADDR_VAR 0 2
75468: PUSH
75469: DOUBLE
75470: LD_INT 1
75472: DEC
75473: ST_TO_ADDR
75474: LD_EXP 61
75478: PUSH
75479: FOR_TO
75480: IFFALSE 76200
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
75482: LD_EXP 61
75486: PUSH
75487: LD_VAR 0 2
75491: ARRAY
75492: NOT
75493: PUSH
75494: LD_EXP 85
75498: PUSH
75499: LD_VAR 0 2
75503: ARRAY
75504: NOT
75505: OR
75506: IFFALSE 75510
// continue ;
75508: GO 75479
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
75510: LD_ADDR_VAR 0 5
75514: PUSH
75515: LD_EXP 61
75519: PUSH
75520: LD_VAR 0 2
75524: ARRAY
75525: PUSH
75526: LD_INT 1
75528: ARRAY
75529: PPUSH
75530: CALL_OW 255
75534: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75535: LD_ADDR_VAR 0 6
75539: PUSH
75540: LD_EXP 61
75544: PUSH
75545: LD_VAR 0 2
75549: ARRAY
75550: PPUSH
75551: LD_INT 30
75553: PUSH
75554: LD_INT 3
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PPUSH
75561: CALL_OW 72
75565: ST_TO_ADDR
// if not fac then
75566: LD_VAR 0 6
75570: NOT
75571: IFFALSE 75622
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75573: LD_ADDR_VAR 0 6
75577: PUSH
75578: LD_EXP 61
75582: PUSH
75583: LD_VAR 0 2
75587: ARRAY
75588: PPUSH
75589: LD_INT 2
75591: PUSH
75592: LD_INT 30
75594: PUSH
75595: LD_INT 0
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: LD_INT 30
75604: PUSH
75605: LD_INT 1
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: LIST
75616: PPUSH
75617: CALL_OW 72
75621: ST_TO_ADDR
// if not fac then
75622: LD_VAR 0 6
75626: NOT
75627: IFFALSE 75631
// continue ;
75629: GO 75479
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75631: LD_ADDR_VAR 0 7
75635: PUSH
75636: LD_EXP 85
75640: PUSH
75641: LD_VAR 0 2
75645: ARRAY
75646: PPUSH
75647: LD_INT 22
75649: PUSH
75650: LD_VAR 0 5
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 21
75661: PUSH
75662: LD_INT 2
75664: PUSH
75665: EMPTY
75666: LIST
75667: LIST
75668: PUSH
75669: LD_INT 3
75671: PUSH
75672: LD_INT 60
75674: PUSH
75675: EMPTY
75676: LIST
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 3
75684: PUSH
75685: LD_INT 24
75687: PUSH
75688: LD_INT 1000
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: EMPTY
75696: LIST
75697: LIST
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: LIST
75703: LIST
75704: PPUSH
75705: CALL_OW 70
75709: ST_TO_ADDR
// for j in fac do
75710: LD_ADDR_VAR 0 3
75714: PUSH
75715: LD_VAR 0 6
75719: PUSH
75720: FOR_IN
75721: IFFALSE 75816
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75723: LD_ADDR_VAR 0 7
75727: PUSH
75728: LD_VAR 0 7
75732: PUSH
75733: LD_INT 22
75735: PUSH
75736: LD_VAR 0 5
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: LD_INT 91
75747: PUSH
75748: LD_VAR 0 3
75752: PUSH
75753: LD_INT 15
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: LIST
75760: PUSH
75761: LD_INT 21
75763: PUSH
75764: LD_INT 2
75766: PUSH
75767: EMPTY
75768: LIST
75769: LIST
75770: PUSH
75771: LD_INT 3
75773: PUSH
75774: LD_INT 60
75776: PUSH
75777: EMPTY
75778: LIST
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: LD_INT 3
75786: PUSH
75787: LD_INT 24
75789: PUSH
75790: LD_INT 1000
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: LIST
75805: LIST
75806: LIST
75807: PPUSH
75808: CALL_OW 69
75812: UNION
75813: ST_TO_ADDR
75814: GO 75720
75816: POP
75817: POP
// if not vehs then
75818: LD_VAR 0 7
75822: NOT
75823: IFFALSE 75849
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75825: LD_ADDR_EXP 73
75829: PUSH
75830: LD_EXP 73
75834: PPUSH
75835: LD_VAR 0 2
75839: PPUSH
75840: EMPTY
75841: PPUSH
75842: CALL_OW 1
75846: ST_TO_ADDR
// continue ;
75847: GO 75479
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75849: LD_ADDR_VAR 0 8
75853: PUSH
75854: LD_EXP 61
75858: PUSH
75859: LD_VAR 0 2
75863: ARRAY
75864: PPUSH
75865: LD_INT 30
75867: PUSH
75868: LD_INT 3
75870: PUSH
75871: EMPTY
75872: LIST
75873: LIST
75874: PPUSH
75875: CALL_OW 72
75879: ST_TO_ADDR
// if tmp then
75880: LD_VAR 0 8
75884: IFFALSE 75987
// begin for j in tmp do
75886: LD_ADDR_VAR 0 3
75890: PUSH
75891: LD_VAR 0 8
75895: PUSH
75896: FOR_IN
75897: IFFALSE 75985
// for k in UnitsInside ( j ) do
75899: LD_ADDR_VAR 0 4
75903: PUSH
75904: LD_VAR 0 3
75908: PPUSH
75909: CALL_OW 313
75913: PUSH
75914: FOR_IN
75915: IFFALSE 75981
// if k then
75917: LD_VAR 0 4
75921: IFFALSE 75979
// if not k in mc_repair_vehicle [ i ] then
75923: LD_VAR 0 4
75927: PUSH
75928: LD_EXP 73
75932: PUSH
75933: LD_VAR 0 2
75937: ARRAY
75938: IN
75939: NOT
75940: IFFALSE 75979
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75942: LD_ADDR_EXP 73
75946: PUSH
75947: LD_EXP 73
75951: PPUSH
75952: LD_VAR 0 2
75956: PPUSH
75957: LD_EXP 73
75961: PUSH
75962: LD_VAR 0 2
75966: ARRAY
75967: PUSH
75968: LD_VAR 0 4
75972: UNION
75973: PPUSH
75974: CALL_OW 1
75978: ST_TO_ADDR
75979: GO 75914
75981: POP
75982: POP
75983: GO 75896
75985: POP
75986: POP
// end ; if not mc_repair_vehicle [ i ] then
75987: LD_EXP 73
75991: PUSH
75992: LD_VAR 0 2
75996: ARRAY
75997: NOT
75998: IFFALSE 76002
// continue ;
76000: GO 75479
// for j in mc_repair_vehicle [ i ] do
76002: LD_ADDR_VAR 0 3
76006: PUSH
76007: LD_EXP 73
76011: PUSH
76012: LD_VAR 0 2
76016: ARRAY
76017: PUSH
76018: FOR_IN
76019: IFFALSE 76196
// begin if GetClass ( j ) <> 3 then
76021: LD_VAR 0 3
76025: PPUSH
76026: CALL_OW 257
76030: PUSH
76031: LD_INT 3
76033: NONEQUAL
76034: IFFALSE 76075
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
76036: LD_ADDR_EXP 73
76040: PUSH
76041: LD_EXP 73
76045: PPUSH
76046: LD_VAR 0 2
76050: PPUSH
76051: LD_EXP 73
76055: PUSH
76056: LD_VAR 0 2
76060: ARRAY
76061: PUSH
76062: LD_VAR 0 3
76066: DIFF
76067: PPUSH
76068: CALL_OW 1
76072: ST_TO_ADDR
// continue ;
76073: GO 76018
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76075: LD_VAR 0 3
76079: PPUSH
76080: CALL_OW 311
76084: NOT
76085: PUSH
76086: LD_VAR 0 3
76090: PUSH
76091: LD_EXP 64
76095: PUSH
76096: LD_VAR 0 2
76100: ARRAY
76101: PUSH
76102: LD_INT 1
76104: ARRAY
76105: IN
76106: NOT
76107: AND
76108: PUSH
76109: LD_VAR 0 3
76113: PUSH
76114: LD_EXP 64
76118: PUSH
76119: LD_VAR 0 2
76123: ARRAY
76124: PUSH
76125: LD_INT 2
76127: ARRAY
76128: IN
76129: NOT
76130: AND
76131: IFFALSE 76194
// begin if IsInUnit ( j ) then
76133: LD_VAR 0 3
76137: PPUSH
76138: CALL_OW 310
76142: IFFALSE 76155
// ComExitBuilding ( j ) else
76144: LD_VAR 0 3
76148: PPUSH
76149: CALL_OW 122
76153: GO 76194
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
76155: LD_VAR 0 3
76159: PPUSH
76160: LD_VAR 0 7
76164: PUSH
76165: LD_INT 1
76167: ARRAY
76168: PPUSH
76169: CALL 55268 0 2
76173: NOT
76174: IFFALSE 76194
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
76176: LD_VAR 0 3
76180: PPUSH
76181: LD_VAR 0 7
76185: PUSH
76186: LD_INT 1
76188: ARRAY
76189: PPUSH
76190: CALL_OW 129
// end ; end ;
76194: GO 76018
76196: POP
76197: POP
// end ;
76198: GO 75479
76200: POP
76201: POP
// end ;
76202: LD_VAR 0 1
76206: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
76207: LD_INT 0
76209: PPUSH
76210: PPUSH
76211: PPUSH
76212: PPUSH
76213: PPUSH
76214: PPUSH
76215: PPUSH
76216: PPUSH
76217: PPUSH
76218: PPUSH
76219: PPUSH
// if not mc_bases then
76220: LD_EXP 61
76224: NOT
76225: IFFALSE 76229
// exit ;
76227: GO 77031
// for i = 1 to mc_bases do
76229: LD_ADDR_VAR 0 2
76233: PUSH
76234: DOUBLE
76235: LD_INT 1
76237: DEC
76238: ST_TO_ADDR
76239: LD_EXP 61
76243: PUSH
76244: FOR_TO
76245: IFFALSE 77029
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
76247: LD_EXP 89
76251: PUSH
76252: LD_VAR 0 2
76256: ARRAY
76257: NOT
76258: PUSH
76259: LD_EXP 64
76263: PUSH
76264: LD_VAR 0 2
76268: ARRAY
76269: PUSH
76270: LD_INT 1
76272: ARRAY
76273: OR
76274: PUSH
76275: LD_EXP 64
76279: PUSH
76280: LD_VAR 0 2
76284: ARRAY
76285: PUSH
76286: LD_INT 2
76288: ARRAY
76289: OR
76290: PUSH
76291: LD_EXP 87
76295: PUSH
76296: LD_VAR 0 2
76300: ARRAY
76301: PPUSH
76302: LD_INT 1
76304: PPUSH
76305: CALL_OW 325
76309: NOT
76310: OR
76311: PUSH
76312: LD_EXP 84
76316: PUSH
76317: LD_VAR 0 2
76321: ARRAY
76322: OR
76323: IFFALSE 76327
// continue ;
76325: GO 76244
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
76327: LD_ADDR_VAR 0 8
76331: PUSH
76332: LD_EXP 61
76336: PUSH
76337: LD_VAR 0 2
76341: ARRAY
76342: PPUSH
76343: LD_INT 25
76345: PUSH
76346: LD_INT 4
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 50
76355: PUSH
76356: EMPTY
76357: LIST
76358: PUSH
76359: LD_INT 3
76361: PUSH
76362: LD_INT 60
76364: PUSH
76365: EMPTY
76366: LIST
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: LIST
76376: PPUSH
76377: CALL_OW 72
76381: PUSH
76382: LD_EXP 65
76386: PUSH
76387: LD_VAR 0 2
76391: ARRAY
76392: DIFF
76393: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76394: LD_ADDR_VAR 0 9
76398: PUSH
76399: LD_EXP 61
76403: PUSH
76404: LD_VAR 0 2
76408: ARRAY
76409: PPUSH
76410: LD_INT 2
76412: PUSH
76413: LD_INT 30
76415: PUSH
76416: LD_INT 0
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: LD_INT 30
76425: PUSH
76426: LD_INT 1
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: LIST
76437: PPUSH
76438: CALL_OW 72
76442: ST_TO_ADDR
// if not tmp or not dep then
76443: LD_VAR 0 8
76447: NOT
76448: PUSH
76449: LD_VAR 0 9
76453: NOT
76454: OR
76455: IFFALSE 76459
// continue ;
76457: GO 76244
// side := GetSide ( tmp [ 1 ] ) ;
76459: LD_ADDR_VAR 0 11
76463: PUSH
76464: LD_VAR 0 8
76468: PUSH
76469: LD_INT 1
76471: ARRAY
76472: PPUSH
76473: CALL_OW 255
76477: ST_TO_ADDR
// dep := dep [ 1 ] ;
76478: LD_ADDR_VAR 0 9
76482: PUSH
76483: LD_VAR 0 9
76487: PUSH
76488: LD_INT 1
76490: ARRAY
76491: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
76492: LD_ADDR_VAR 0 7
76496: PUSH
76497: LD_EXP 89
76501: PUSH
76502: LD_VAR 0 2
76506: ARRAY
76507: PPUSH
76508: LD_INT 22
76510: PUSH
76511: LD_INT 0
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: LD_INT 25
76520: PUSH
76521: LD_INT 12
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: PPUSH
76532: CALL_OW 70
76536: PUSH
76537: LD_INT 22
76539: PUSH
76540: LD_INT 0
76542: PUSH
76543: EMPTY
76544: LIST
76545: LIST
76546: PUSH
76547: LD_INT 25
76549: PUSH
76550: LD_INT 12
76552: PUSH
76553: EMPTY
76554: LIST
76555: LIST
76556: PUSH
76557: LD_INT 91
76559: PUSH
76560: LD_VAR 0 9
76564: PUSH
76565: LD_INT 20
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: LIST
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: LIST
76577: PPUSH
76578: CALL_OW 69
76582: UNION
76583: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
76584: LD_ADDR_VAR 0 10
76588: PUSH
76589: LD_EXP 89
76593: PUSH
76594: LD_VAR 0 2
76598: ARRAY
76599: PPUSH
76600: LD_INT 81
76602: PUSH
76603: LD_VAR 0 11
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PPUSH
76612: CALL_OW 70
76616: ST_TO_ADDR
// if not apes or danger_at_area then
76617: LD_VAR 0 7
76621: NOT
76622: PUSH
76623: LD_VAR 0 10
76627: OR
76628: IFFALSE 76678
// begin if mc_taming [ i ] then
76630: LD_EXP 92
76634: PUSH
76635: LD_VAR 0 2
76639: ARRAY
76640: IFFALSE 76676
// begin MC_Reset ( i , 121 ) ;
76642: LD_VAR 0 2
76646: PPUSH
76647: LD_INT 121
76649: PPUSH
76650: CALL 61594 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
76654: LD_ADDR_EXP 92
76658: PUSH
76659: LD_EXP 92
76663: PPUSH
76664: LD_VAR 0 2
76668: PPUSH
76669: EMPTY
76670: PPUSH
76671: CALL_OW 1
76675: ST_TO_ADDR
// end ; continue ;
76676: GO 76244
// end ; for j in tmp do
76678: LD_ADDR_VAR 0 3
76682: PUSH
76683: LD_VAR 0 8
76687: PUSH
76688: FOR_IN
76689: IFFALSE 77025
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
76691: LD_VAR 0 3
76695: PUSH
76696: LD_EXP 92
76700: PUSH
76701: LD_VAR 0 2
76705: ARRAY
76706: IN
76707: NOT
76708: PUSH
76709: LD_EXP 92
76713: PUSH
76714: LD_VAR 0 2
76718: ARRAY
76719: PUSH
76720: LD_INT 3
76722: LESS
76723: AND
76724: IFFALSE 76782
// begin SetTag ( j , 121 ) ;
76726: LD_VAR 0 3
76730: PPUSH
76731: LD_INT 121
76733: PPUSH
76734: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76738: LD_ADDR_EXP 92
76742: PUSH
76743: LD_EXP 92
76747: PPUSH
76748: LD_VAR 0 2
76752: PUSH
76753: LD_EXP 92
76757: PUSH
76758: LD_VAR 0 2
76762: ARRAY
76763: PUSH
76764: LD_INT 1
76766: PLUS
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: PPUSH
76772: LD_VAR 0 3
76776: PPUSH
76777: CALL 20463 0 3
76781: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76782: LD_VAR 0 3
76786: PUSH
76787: LD_EXP 92
76791: PUSH
76792: LD_VAR 0 2
76796: ARRAY
76797: IN
76798: IFFALSE 77023
// begin if GetClass ( j ) <> 4 then
76800: LD_VAR 0 3
76804: PPUSH
76805: CALL_OW 257
76809: PUSH
76810: LD_INT 4
76812: NONEQUAL
76813: IFFALSE 76866
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76815: LD_ADDR_EXP 92
76819: PUSH
76820: LD_EXP 92
76824: PPUSH
76825: LD_VAR 0 2
76829: PPUSH
76830: LD_EXP 92
76834: PUSH
76835: LD_VAR 0 2
76839: ARRAY
76840: PUSH
76841: LD_VAR 0 3
76845: DIFF
76846: PPUSH
76847: CALL_OW 1
76851: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76852: LD_VAR 0 3
76856: PPUSH
76857: LD_INT 0
76859: PPUSH
76860: CALL_OW 109
// continue ;
76864: GO 76688
// end ; if IsInUnit ( j ) then
76866: LD_VAR 0 3
76870: PPUSH
76871: CALL_OW 310
76875: IFFALSE 76886
// ComExitBuilding ( j ) ;
76877: LD_VAR 0 3
76881: PPUSH
76882: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76886: LD_ADDR_VAR 0 6
76890: PUSH
76891: LD_VAR 0 7
76895: PPUSH
76896: LD_VAR 0 3
76900: PPUSH
76901: CALL_OW 74
76905: ST_TO_ADDR
// if not ape then
76906: LD_VAR 0 6
76910: NOT
76911: IFFALSE 76915
// break ;
76913: GO 77025
// x := GetX ( ape ) ;
76915: LD_ADDR_VAR 0 4
76919: PUSH
76920: LD_VAR 0 6
76924: PPUSH
76925: CALL_OW 250
76929: ST_TO_ADDR
// y := GetY ( ape ) ;
76930: LD_ADDR_VAR 0 5
76934: PUSH
76935: LD_VAR 0 6
76939: PPUSH
76940: CALL_OW 251
76944: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76945: LD_VAR 0 4
76949: PPUSH
76950: LD_VAR 0 5
76954: PPUSH
76955: CALL_OW 488
76959: NOT
76960: PUSH
76961: LD_VAR 0 11
76965: PPUSH
76966: LD_VAR 0 4
76970: PPUSH
76971: LD_VAR 0 5
76975: PPUSH
76976: LD_INT 20
76978: PPUSH
76979: CALL 21727 0 4
76983: PUSH
76984: LD_INT 4
76986: ARRAY
76987: OR
76988: IFFALSE 76992
// break ;
76990: GO 77025
// if not HasTask ( j ) then
76992: LD_VAR 0 3
76996: PPUSH
76997: CALL_OW 314
77001: NOT
77002: IFFALSE 77023
// ComTameXY ( j , x , y ) ;
77004: LD_VAR 0 3
77008: PPUSH
77009: LD_VAR 0 4
77013: PPUSH
77014: LD_VAR 0 5
77018: PPUSH
77019: CALL_OW 131
// end ; end ;
77023: GO 76688
77025: POP
77026: POP
// end ;
77027: GO 76244
77029: POP
77030: POP
// end ;
77031: LD_VAR 0 1
77035: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
77036: LD_INT 0
77038: PPUSH
77039: PPUSH
77040: PPUSH
77041: PPUSH
77042: PPUSH
77043: PPUSH
77044: PPUSH
77045: PPUSH
// if not mc_bases then
77046: LD_EXP 61
77050: NOT
77051: IFFALSE 77055
// exit ;
77053: GO 77681
// for i = 1 to mc_bases do
77055: LD_ADDR_VAR 0 2
77059: PUSH
77060: DOUBLE
77061: LD_INT 1
77063: DEC
77064: ST_TO_ADDR
77065: LD_EXP 61
77069: PUSH
77070: FOR_TO
77071: IFFALSE 77679
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
77073: LD_EXP 90
77077: PUSH
77078: LD_VAR 0 2
77082: ARRAY
77083: NOT
77084: PUSH
77085: LD_EXP 90
77089: PUSH
77090: LD_VAR 0 2
77094: ARRAY
77095: PPUSH
77096: LD_INT 25
77098: PUSH
77099: LD_INT 12
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PPUSH
77106: CALL_OW 72
77110: NOT
77111: OR
77112: IFFALSE 77116
// continue ;
77114: GO 77070
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
77116: LD_ADDR_VAR 0 5
77120: PUSH
77121: LD_EXP 90
77125: PUSH
77126: LD_VAR 0 2
77130: ARRAY
77131: PUSH
77132: LD_INT 1
77134: ARRAY
77135: PPUSH
77136: CALL_OW 255
77140: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
77141: LD_VAR 0 5
77145: PPUSH
77146: LD_INT 2
77148: PPUSH
77149: CALL_OW 325
77153: IFFALSE 77406
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
77155: LD_ADDR_VAR 0 4
77159: PUSH
77160: LD_EXP 90
77164: PUSH
77165: LD_VAR 0 2
77169: ARRAY
77170: PPUSH
77171: LD_INT 25
77173: PUSH
77174: LD_INT 16
77176: PUSH
77177: EMPTY
77178: LIST
77179: LIST
77180: PPUSH
77181: CALL_OW 72
77185: ST_TO_ADDR
// if tmp < 6 then
77186: LD_VAR 0 4
77190: PUSH
77191: LD_INT 6
77193: LESS
77194: IFFALSE 77406
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77196: LD_ADDR_VAR 0 6
77200: PUSH
77201: LD_EXP 61
77205: PUSH
77206: LD_VAR 0 2
77210: ARRAY
77211: PPUSH
77212: LD_INT 2
77214: PUSH
77215: LD_INT 30
77217: PUSH
77218: LD_INT 0
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 30
77227: PUSH
77228: LD_INT 1
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: EMPTY
77236: LIST
77237: LIST
77238: LIST
77239: PPUSH
77240: CALL_OW 72
77244: ST_TO_ADDR
// if depot then
77245: LD_VAR 0 6
77249: IFFALSE 77406
// begin selected := 0 ;
77251: LD_ADDR_VAR 0 7
77255: PUSH
77256: LD_INT 0
77258: ST_TO_ADDR
// for j in depot do
77259: LD_ADDR_VAR 0 3
77263: PUSH
77264: LD_VAR 0 6
77268: PUSH
77269: FOR_IN
77270: IFFALSE 77301
// begin if UnitsInside ( j ) < 6 then
77272: LD_VAR 0 3
77276: PPUSH
77277: CALL_OW 313
77281: PUSH
77282: LD_INT 6
77284: LESS
77285: IFFALSE 77299
// begin selected := j ;
77287: LD_ADDR_VAR 0 7
77291: PUSH
77292: LD_VAR 0 3
77296: ST_TO_ADDR
// break ;
77297: GO 77301
// end ; end ;
77299: GO 77269
77301: POP
77302: POP
// if selected then
77303: LD_VAR 0 7
77307: IFFALSE 77406
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
77309: LD_ADDR_VAR 0 3
77313: PUSH
77314: LD_EXP 90
77318: PUSH
77319: LD_VAR 0 2
77323: ARRAY
77324: PPUSH
77325: LD_INT 25
77327: PUSH
77328: LD_INT 12
77330: PUSH
77331: EMPTY
77332: LIST
77333: LIST
77334: PPUSH
77335: CALL_OW 72
77339: PUSH
77340: FOR_IN
77341: IFFALSE 77404
// if not HasTask ( j ) then
77343: LD_VAR 0 3
77347: PPUSH
77348: CALL_OW 314
77352: NOT
77353: IFFALSE 77402
// begin if not IsInUnit ( j ) then
77355: LD_VAR 0 3
77359: PPUSH
77360: CALL_OW 310
77364: NOT
77365: IFFALSE 77381
// ComEnterUnit ( j , selected ) ;
77367: LD_VAR 0 3
77371: PPUSH
77372: LD_VAR 0 7
77376: PPUSH
77377: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
77381: LD_VAR 0 3
77385: PPUSH
77386: LD_INT 16
77388: PPUSH
77389: CALL_OW 183
// AddComExitBuilding ( j ) ;
77393: LD_VAR 0 3
77397: PPUSH
77398: CALL_OW 182
// end ;
77402: GO 77340
77404: POP
77405: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
77406: LD_VAR 0 5
77410: PPUSH
77411: LD_INT 11
77413: PPUSH
77414: CALL_OW 325
77418: IFFALSE 77677
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
77420: LD_ADDR_VAR 0 4
77424: PUSH
77425: LD_EXP 90
77429: PUSH
77430: LD_VAR 0 2
77434: ARRAY
77435: PPUSH
77436: LD_INT 25
77438: PUSH
77439: LD_INT 16
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: PPUSH
77446: CALL_OW 72
77450: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
77451: LD_VAR 0 4
77455: PUSH
77456: LD_INT 6
77458: GREATEREQUAL
77459: PUSH
77460: LD_VAR 0 5
77464: PPUSH
77465: LD_INT 2
77467: PPUSH
77468: CALL_OW 325
77472: NOT
77473: OR
77474: IFFALSE 77677
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
77476: LD_ADDR_VAR 0 8
77480: PUSH
77481: LD_EXP 61
77485: PUSH
77486: LD_VAR 0 2
77490: ARRAY
77491: PPUSH
77492: LD_INT 2
77494: PUSH
77495: LD_INT 30
77497: PUSH
77498: LD_INT 4
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: LD_INT 30
77507: PUSH
77508: LD_INT 5
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: LIST
77519: PPUSH
77520: CALL_OW 72
77524: ST_TO_ADDR
// if barracks then
77525: LD_VAR 0 8
77529: IFFALSE 77677
// begin selected := 0 ;
77531: LD_ADDR_VAR 0 7
77535: PUSH
77536: LD_INT 0
77538: ST_TO_ADDR
// for j in barracks do
77539: LD_ADDR_VAR 0 3
77543: PUSH
77544: LD_VAR 0 8
77548: PUSH
77549: FOR_IN
77550: IFFALSE 77581
// begin if UnitsInside ( j ) < 6 then
77552: LD_VAR 0 3
77556: PPUSH
77557: CALL_OW 313
77561: PUSH
77562: LD_INT 6
77564: LESS
77565: IFFALSE 77579
// begin selected := j ;
77567: LD_ADDR_VAR 0 7
77571: PUSH
77572: LD_VAR 0 3
77576: ST_TO_ADDR
// break ;
77577: GO 77581
// end ; end ;
77579: GO 77549
77581: POP
77582: POP
// if selected then
77583: LD_VAR 0 7
77587: IFFALSE 77677
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
77589: LD_ADDR_VAR 0 3
77593: PUSH
77594: LD_EXP 90
77598: PUSH
77599: LD_VAR 0 2
77603: ARRAY
77604: PPUSH
77605: LD_INT 25
77607: PUSH
77608: LD_INT 12
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PPUSH
77615: CALL_OW 72
77619: PUSH
77620: FOR_IN
77621: IFFALSE 77675
// if not IsInUnit ( j ) and not HasTask ( j ) then
77623: LD_VAR 0 3
77627: PPUSH
77628: CALL_OW 310
77632: NOT
77633: PUSH
77634: LD_VAR 0 3
77638: PPUSH
77639: CALL_OW 314
77643: NOT
77644: AND
77645: IFFALSE 77673
// begin ComEnterUnit ( j , selected ) ;
77647: LD_VAR 0 3
77651: PPUSH
77652: LD_VAR 0 7
77656: PPUSH
77657: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
77661: LD_VAR 0 3
77665: PPUSH
77666: LD_INT 15
77668: PPUSH
77669: CALL_OW 183
// end ;
77673: GO 77620
77675: POP
77676: POP
// end ; end ; end ; end ; end ;
77677: GO 77070
77679: POP
77680: POP
// end ;
77681: LD_VAR 0 1
77685: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
77686: LD_INT 0
77688: PPUSH
77689: PPUSH
77690: PPUSH
77691: PPUSH
// if not mc_bases then
77692: LD_EXP 61
77696: NOT
77697: IFFALSE 77701
// exit ;
77699: GO 77879
// for i = 1 to mc_bases do
77701: LD_ADDR_VAR 0 2
77705: PUSH
77706: DOUBLE
77707: LD_INT 1
77709: DEC
77710: ST_TO_ADDR
77711: LD_EXP 61
77715: PUSH
77716: FOR_TO
77717: IFFALSE 77877
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
77719: LD_ADDR_VAR 0 4
77723: PUSH
77724: LD_EXP 61
77728: PUSH
77729: LD_VAR 0 2
77733: ARRAY
77734: PPUSH
77735: LD_INT 25
77737: PUSH
77738: LD_INT 9
77740: PUSH
77741: EMPTY
77742: LIST
77743: LIST
77744: PPUSH
77745: CALL_OW 72
77749: ST_TO_ADDR
// if not tmp then
77750: LD_VAR 0 4
77754: NOT
77755: IFFALSE 77759
// continue ;
77757: GO 77716
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77759: LD_EXP 87
77763: PUSH
77764: LD_VAR 0 2
77768: ARRAY
77769: PPUSH
77770: LD_INT 29
77772: PPUSH
77773: CALL_OW 325
77777: NOT
77778: PUSH
77779: LD_EXP 87
77783: PUSH
77784: LD_VAR 0 2
77788: ARRAY
77789: PPUSH
77790: LD_INT 28
77792: PPUSH
77793: CALL_OW 325
77797: NOT
77798: AND
77799: IFFALSE 77803
// continue ;
77801: GO 77716
// for j in tmp do
77803: LD_ADDR_VAR 0 3
77807: PUSH
77808: LD_VAR 0 4
77812: PUSH
77813: FOR_IN
77814: IFFALSE 77873
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77816: LD_VAR 0 3
77820: PUSH
77821: LD_EXP 64
77825: PUSH
77826: LD_VAR 0 2
77830: ARRAY
77831: PUSH
77832: LD_INT 1
77834: ARRAY
77835: IN
77836: NOT
77837: PUSH
77838: LD_VAR 0 3
77842: PUSH
77843: LD_EXP 64
77847: PUSH
77848: LD_VAR 0 2
77852: ARRAY
77853: PUSH
77854: LD_INT 2
77856: ARRAY
77857: IN
77858: NOT
77859: AND
77860: IFFALSE 77871
// ComSpaceTimeShoot ( j ) ;
77862: LD_VAR 0 3
77866: PPUSH
77867: CALL 16448 0 1
77871: GO 77813
77873: POP
77874: POP
// end ;
77875: GO 77716
77877: POP
77878: POP
// end ;
77879: LD_VAR 0 1
77883: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77884: LD_INT 0
77886: PPUSH
77887: PPUSH
77888: PPUSH
77889: PPUSH
77890: PPUSH
77891: PPUSH
77892: PPUSH
77893: PPUSH
77894: PPUSH
// if not mc_bases then
77895: LD_EXP 61
77899: NOT
77900: IFFALSE 77904
// exit ;
77902: GO 78526
// for i = 1 to mc_bases do
77904: LD_ADDR_VAR 0 2
77908: PUSH
77909: DOUBLE
77910: LD_INT 1
77912: DEC
77913: ST_TO_ADDR
77914: LD_EXP 61
77918: PUSH
77919: FOR_TO
77920: IFFALSE 78524
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77922: LD_EXP 96
77926: PUSH
77927: LD_VAR 0 2
77931: ARRAY
77932: NOT
77933: PUSH
77934: LD_INT 38
77936: PPUSH
77937: LD_EXP 87
77941: PUSH
77942: LD_VAR 0 2
77946: ARRAY
77947: PPUSH
77948: CALL_OW 321
77952: PUSH
77953: LD_INT 2
77955: NONEQUAL
77956: OR
77957: IFFALSE 77961
// continue ;
77959: GO 77919
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77961: LD_ADDR_VAR 0 8
77965: PUSH
77966: LD_EXP 61
77970: PUSH
77971: LD_VAR 0 2
77975: ARRAY
77976: PPUSH
77977: LD_INT 30
77979: PUSH
77980: LD_INT 34
77982: PUSH
77983: EMPTY
77984: LIST
77985: LIST
77986: PPUSH
77987: CALL_OW 72
77991: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77992: LD_ADDR_VAR 0 9
77996: PUSH
77997: LD_EXP 61
78001: PUSH
78002: LD_VAR 0 2
78006: ARRAY
78007: PPUSH
78008: LD_INT 25
78010: PUSH
78011: LD_INT 4
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: PPUSH
78018: CALL_OW 72
78022: PPUSH
78023: LD_INT 0
78025: PPUSH
78026: CALL 50772 0 2
78030: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
78031: LD_VAR 0 9
78035: NOT
78036: PUSH
78037: LD_VAR 0 8
78041: NOT
78042: OR
78043: PUSH
78044: LD_EXP 61
78048: PUSH
78049: LD_VAR 0 2
78053: ARRAY
78054: PPUSH
78055: LD_INT 124
78057: PPUSH
78058: CALL 50772 0 2
78062: OR
78063: IFFALSE 78067
// continue ;
78065: GO 77919
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
78067: LD_EXP 97
78071: PUSH
78072: LD_VAR 0 2
78076: ARRAY
78077: PUSH
78078: LD_EXP 96
78082: PUSH
78083: LD_VAR 0 2
78087: ARRAY
78088: LESS
78089: PUSH
78090: LD_EXP 97
78094: PUSH
78095: LD_VAR 0 2
78099: ARRAY
78100: PUSH
78101: LD_VAR 0 8
78105: LESS
78106: AND
78107: IFFALSE 78522
// begin tmp := sci [ 1 ] ;
78109: LD_ADDR_VAR 0 7
78113: PUSH
78114: LD_VAR 0 9
78118: PUSH
78119: LD_INT 1
78121: ARRAY
78122: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
78123: LD_VAR 0 7
78127: PPUSH
78128: LD_INT 124
78130: PPUSH
78131: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
78135: LD_ADDR_VAR 0 3
78139: PUSH
78140: DOUBLE
78141: LD_EXP 96
78145: PUSH
78146: LD_VAR 0 2
78150: ARRAY
78151: INC
78152: ST_TO_ADDR
78153: LD_EXP 96
78157: PUSH
78158: LD_VAR 0 2
78162: ARRAY
78163: PUSH
78164: FOR_DOWNTO
78165: IFFALSE 78508
// begin if IsInUnit ( tmp ) then
78167: LD_VAR 0 7
78171: PPUSH
78172: CALL_OW 310
78176: IFFALSE 78187
// ComExitBuilding ( tmp ) ;
78178: LD_VAR 0 7
78182: PPUSH
78183: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
78187: LD_INT 35
78189: PPUSH
78190: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
78194: LD_VAR 0 7
78198: PPUSH
78199: CALL_OW 310
78203: NOT
78204: PUSH
78205: LD_VAR 0 7
78209: PPUSH
78210: CALL_OW 314
78214: NOT
78215: AND
78216: IFFALSE 78187
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
78218: LD_ADDR_VAR 0 6
78222: PUSH
78223: LD_VAR 0 7
78227: PPUSH
78228: CALL_OW 250
78232: PUSH
78233: LD_VAR 0 7
78237: PPUSH
78238: CALL_OW 251
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
78247: LD_INT 35
78249: PPUSH
78250: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
78254: LD_ADDR_VAR 0 4
78258: PUSH
78259: LD_EXP 96
78263: PUSH
78264: LD_VAR 0 2
78268: ARRAY
78269: PUSH
78270: LD_VAR 0 3
78274: ARRAY
78275: PUSH
78276: LD_INT 1
78278: ARRAY
78279: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
78280: LD_ADDR_VAR 0 5
78284: PUSH
78285: LD_EXP 96
78289: PUSH
78290: LD_VAR 0 2
78294: ARRAY
78295: PUSH
78296: LD_VAR 0 3
78300: ARRAY
78301: PUSH
78302: LD_INT 2
78304: ARRAY
78305: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
78306: LD_VAR 0 7
78310: PPUSH
78311: LD_INT 10
78313: PPUSH
78314: CALL 23428 0 2
78318: PUSH
78319: LD_INT 4
78321: ARRAY
78322: IFFALSE 78360
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
78324: LD_VAR 0 7
78328: PPUSH
78329: LD_VAR 0 6
78333: PUSH
78334: LD_INT 1
78336: ARRAY
78337: PPUSH
78338: LD_VAR 0 6
78342: PUSH
78343: LD_INT 2
78345: ARRAY
78346: PPUSH
78347: CALL_OW 111
// wait ( 0 0$10 ) ;
78351: LD_INT 350
78353: PPUSH
78354: CALL_OW 67
// end else
78358: GO 78386
// begin ComMoveXY ( tmp , x , y ) ;
78360: LD_VAR 0 7
78364: PPUSH
78365: LD_VAR 0 4
78369: PPUSH
78370: LD_VAR 0 5
78374: PPUSH
78375: CALL_OW 111
// wait ( 0 0$3 ) ;
78379: LD_INT 105
78381: PPUSH
78382: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
78386: LD_VAR 0 7
78390: PPUSH
78391: LD_VAR 0 4
78395: PPUSH
78396: LD_VAR 0 5
78400: PPUSH
78401: CALL_OW 307
78405: IFFALSE 78247
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
78407: LD_VAR 0 7
78411: PPUSH
78412: LD_VAR 0 4
78416: PPUSH
78417: LD_VAR 0 5
78421: PPUSH
78422: LD_VAR 0 8
78426: PUSH
78427: LD_VAR 0 3
78431: ARRAY
78432: PPUSH
78433: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
78437: LD_INT 35
78439: PPUSH
78440: CALL_OW 67
// until not HasTask ( tmp ) ;
78444: LD_VAR 0 7
78448: PPUSH
78449: CALL_OW 314
78453: NOT
78454: IFFALSE 78437
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
78456: LD_ADDR_EXP 97
78460: PUSH
78461: LD_EXP 97
78465: PPUSH
78466: LD_VAR 0 2
78470: PUSH
78471: LD_EXP 97
78475: PUSH
78476: LD_VAR 0 2
78480: ARRAY
78481: PUSH
78482: LD_INT 1
78484: PLUS
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PPUSH
78490: LD_VAR 0 8
78494: PUSH
78495: LD_VAR 0 3
78499: ARRAY
78500: PPUSH
78501: CALL 20463 0 3
78505: ST_TO_ADDR
// end ;
78506: GO 78164
78508: POP
78509: POP
// MC_Reset ( i , 124 ) ;
78510: LD_VAR 0 2
78514: PPUSH
78515: LD_INT 124
78517: PPUSH
78518: CALL 61594 0 2
// end ; end ;
78522: GO 77919
78524: POP
78525: POP
// end ;
78526: LD_VAR 0 1
78530: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
78531: LD_INT 0
78533: PPUSH
78534: PPUSH
78535: PPUSH
// if not mc_bases then
78536: LD_EXP 61
78540: NOT
78541: IFFALSE 78545
// exit ;
78543: GO 79151
// for i = 1 to mc_bases do
78545: LD_ADDR_VAR 0 2
78549: PUSH
78550: DOUBLE
78551: LD_INT 1
78553: DEC
78554: ST_TO_ADDR
78555: LD_EXP 61
78559: PUSH
78560: FOR_TO
78561: IFFALSE 79149
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
78563: LD_ADDR_VAR 0 3
78567: PUSH
78568: LD_EXP 61
78572: PUSH
78573: LD_VAR 0 2
78577: ARRAY
78578: PPUSH
78579: LD_INT 25
78581: PUSH
78582: LD_INT 4
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PPUSH
78589: CALL_OW 72
78593: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78594: LD_VAR 0 3
78598: NOT
78599: PUSH
78600: LD_EXP 98
78604: PUSH
78605: LD_VAR 0 2
78609: ARRAY
78610: NOT
78611: OR
78612: PUSH
78613: LD_EXP 61
78617: PUSH
78618: LD_VAR 0 2
78622: ARRAY
78623: PPUSH
78624: LD_INT 2
78626: PUSH
78627: LD_INT 30
78629: PUSH
78630: LD_INT 0
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PUSH
78637: LD_INT 30
78639: PUSH
78640: LD_INT 1
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: LIST
78651: PPUSH
78652: CALL_OW 72
78656: NOT
78657: OR
78658: IFFALSE 78708
// begin if mc_deposits_finder [ i ] then
78660: LD_EXP 99
78664: PUSH
78665: LD_VAR 0 2
78669: ARRAY
78670: IFFALSE 78706
// begin MC_Reset ( i , 125 ) ;
78672: LD_VAR 0 2
78676: PPUSH
78677: LD_INT 125
78679: PPUSH
78680: CALL 61594 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78684: LD_ADDR_EXP 99
78688: PUSH
78689: LD_EXP 99
78693: PPUSH
78694: LD_VAR 0 2
78698: PPUSH
78699: EMPTY
78700: PPUSH
78701: CALL_OW 1
78705: ST_TO_ADDR
// end ; continue ;
78706: GO 78560
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
78708: LD_EXP 98
78712: PUSH
78713: LD_VAR 0 2
78717: ARRAY
78718: PUSH
78719: LD_INT 1
78721: ARRAY
78722: PUSH
78723: LD_INT 3
78725: ARRAY
78726: PUSH
78727: LD_INT 1
78729: EQUAL
78730: PUSH
78731: LD_INT 20
78733: PPUSH
78734: LD_EXP 87
78738: PUSH
78739: LD_VAR 0 2
78743: ARRAY
78744: PPUSH
78745: CALL_OW 321
78749: PUSH
78750: LD_INT 2
78752: NONEQUAL
78753: AND
78754: IFFALSE 78804
// begin if mc_deposits_finder [ i ] then
78756: LD_EXP 99
78760: PUSH
78761: LD_VAR 0 2
78765: ARRAY
78766: IFFALSE 78802
// begin MC_Reset ( i , 125 ) ;
78768: LD_VAR 0 2
78772: PPUSH
78773: LD_INT 125
78775: PPUSH
78776: CALL 61594 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78780: LD_ADDR_EXP 99
78784: PUSH
78785: LD_EXP 99
78789: PPUSH
78790: LD_VAR 0 2
78794: PPUSH
78795: EMPTY
78796: PPUSH
78797: CALL_OW 1
78801: ST_TO_ADDR
// end ; continue ;
78802: GO 78560
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78804: LD_EXP 98
78808: PUSH
78809: LD_VAR 0 2
78813: ARRAY
78814: PUSH
78815: LD_INT 1
78817: ARRAY
78818: PUSH
78819: LD_INT 1
78821: ARRAY
78822: PPUSH
78823: LD_EXP 98
78827: PUSH
78828: LD_VAR 0 2
78832: ARRAY
78833: PUSH
78834: LD_INT 1
78836: ARRAY
78837: PUSH
78838: LD_INT 2
78840: ARRAY
78841: PPUSH
78842: LD_EXP 87
78846: PUSH
78847: LD_VAR 0 2
78851: ARRAY
78852: PPUSH
78853: CALL_OW 440
78857: IFFALSE 78900
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78859: LD_ADDR_EXP 98
78863: PUSH
78864: LD_EXP 98
78868: PPUSH
78869: LD_VAR 0 2
78873: PPUSH
78874: LD_EXP 98
78878: PUSH
78879: LD_VAR 0 2
78883: ARRAY
78884: PPUSH
78885: LD_INT 1
78887: PPUSH
78888: CALL_OW 3
78892: PPUSH
78893: CALL_OW 1
78897: ST_TO_ADDR
78898: GO 79147
// begin if not mc_deposits_finder [ i ] then
78900: LD_EXP 99
78904: PUSH
78905: LD_VAR 0 2
78909: ARRAY
78910: NOT
78911: IFFALSE 78963
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78913: LD_ADDR_EXP 99
78917: PUSH
78918: LD_EXP 99
78922: PPUSH
78923: LD_VAR 0 2
78927: PPUSH
78928: LD_VAR 0 3
78932: PUSH
78933: LD_INT 1
78935: ARRAY
78936: PUSH
78937: EMPTY
78938: LIST
78939: PPUSH
78940: CALL_OW 1
78944: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78945: LD_VAR 0 3
78949: PUSH
78950: LD_INT 1
78952: ARRAY
78953: PPUSH
78954: LD_INT 125
78956: PPUSH
78957: CALL_OW 109
// end else
78961: GO 79147
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78963: LD_EXP 99
78967: PUSH
78968: LD_VAR 0 2
78972: ARRAY
78973: PUSH
78974: LD_INT 1
78976: ARRAY
78977: PPUSH
78978: CALL_OW 310
78982: IFFALSE 79005
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78984: LD_EXP 99
78988: PUSH
78989: LD_VAR 0 2
78993: ARRAY
78994: PUSH
78995: LD_INT 1
78997: ARRAY
78998: PPUSH
78999: CALL_OW 122
79003: GO 79147
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
79005: LD_EXP 99
79009: PUSH
79010: LD_VAR 0 2
79014: ARRAY
79015: PUSH
79016: LD_INT 1
79018: ARRAY
79019: PPUSH
79020: CALL_OW 314
79024: NOT
79025: PUSH
79026: LD_EXP 99
79030: PUSH
79031: LD_VAR 0 2
79035: ARRAY
79036: PUSH
79037: LD_INT 1
79039: ARRAY
79040: PPUSH
79041: LD_EXP 98
79045: PUSH
79046: LD_VAR 0 2
79050: ARRAY
79051: PUSH
79052: LD_INT 1
79054: ARRAY
79055: PUSH
79056: LD_INT 1
79058: ARRAY
79059: PPUSH
79060: LD_EXP 98
79064: PUSH
79065: LD_VAR 0 2
79069: ARRAY
79070: PUSH
79071: LD_INT 1
79073: ARRAY
79074: PUSH
79075: LD_INT 2
79077: ARRAY
79078: PPUSH
79079: CALL_OW 297
79083: PUSH
79084: LD_INT 6
79086: GREATER
79087: AND
79088: IFFALSE 79147
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
79090: LD_EXP 99
79094: PUSH
79095: LD_VAR 0 2
79099: ARRAY
79100: PUSH
79101: LD_INT 1
79103: ARRAY
79104: PPUSH
79105: LD_EXP 98
79109: PUSH
79110: LD_VAR 0 2
79114: ARRAY
79115: PUSH
79116: LD_INT 1
79118: ARRAY
79119: PUSH
79120: LD_INT 1
79122: ARRAY
79123: PPUSH
79124: LD_EXP 98
79128: PUSH
79129: LD_VAR 0 2
79133: ARRAY
79134: PUSH
79135: LD_INT 1
79137: ARRAY
79138: PUSH
79139: LD_INT 2
79141: ARRAY
79142: PPUSH
79143: CALL_OW 111
// end ; end ; end ;
79147: GO 78560
79149: POP
79150: POP
// end ;
79151: LD_VAR 0 1
79155: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
79156: LD_INT 0
79158: PPUSH
79159: PPUSH
79160: PPUSH
79161: PPUSH
79162: PPUSH
79163: PPUSH
79164: PPUSH
79165: PPUSH
79166: PPUSH
79167: PPUSH
79168: PPUSH
// if not mc_bases then
79169: LD_EXP 61
79173: NOT
79174: IFFALSE 79178
// exit ;
79176: GO 80118
// for i = 1 to mc_bases do
79178: LD_ADDR_VAR 0 2
79182: PUSH
79183: DOUBLE
79184: LD_INT 1
79186: DEC
79187: ST_TO_ADDR
79188: LD_EXP 61
79192: PUSH
79193: FOR_TO
79194: IFFALSE 80116
// begin if not mc_bases [ i ] or mc_scan [ i ] then
79196: LD_EXP 61
79200: PUSH
79201: LD_VAR 0 2
79205: ARRAY
79206: NOT
79207: PUSH
79208: LD_EXP 84
79212: PUSH
79213: LD_VAR 0 2
79217: ARRAY
79218: OR
79219: IFFALSE 79223
// continue ;
79221: GO 79193
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
79223: LD_ADDR_VAR 0 7
79227: PUSH
79228: LD_EXP 61
79232: PUSH
79233: LD_VAR 0 2
79237: ARRAY
79238: PUSH
79239: LD_INT 1
79241: ARRAY
79242: PPUSH
79243: CALL_OW 248
79247: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
79248: LD_VAR 0 7
79252: PUSH
79253: LD_INT 3
79255: EQUAL
79256: PUSH
79257: LD_EXP 80
79261: PUSH
79262: LD_VAR 0 2
79266: ARRAY
79267: PUSH
79268: LD_EXP 83
79272: PUSH
79273: LD_VAR 0 2
79277: ARRAY
79278: UNION
79279: PPUSH
79280: LD_INT 33
79282: PUSH
79283: LD_INT 2
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PPUSH
79290: CALL_OW 72
79294: NOT
79295: OR
79296: IFFALSE 79300
// continue ;
79298: GO 79193
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
79300: LD_ADDR_VAR 0 9
79304: PUSH
79305: LD_EXP 61
79309: PUSH
79310: LD_VAR 0 2
79314: ARRAY
79315: PPUSH
79316: LD_INT 30
79318: PUSH
79319: LD_INT 36
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PPUSH
79326: CALL_OW 72
79330: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
79331: LD_ADDR_VAR 0 10
79335: PUSH
79336: LD_EXP 80
79340: PUSH
79341: LD_VAR 0 2
79345: ARRAY
79346: PPUSH
79347: LD_INT 34
79349: PUSH
79350: LD_INT 31
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PPUSH
79357: CALL_OW 72
79361: ST_TO_ADDR
// if not cts and not mcts then
79362: LD_VAR 0 9
79366: NOT
79367: PUSH
79368: LD_VAR 0 10
79372: NOT
79373: AND
79374: IFFALSE 79378
// continue ;
79376: GO 79193
// x := cts ;
79378: LD_ADDR_VAR 0 11
79382: PUSH
79383: LD_VAR 0 9
79387: ST_TO_ADDR
// if not x then
79388: LD_VAR 0 11
79392: NOT
79393: IFFALSE 79405
// x := mcts ;
79395: LD_ADDR_VAR 0 11
79399: PUSH
79400: LD_VAR 0 10
79404: ST_TO_ADDR
// if not x then
79405: LD_VAR 0 11
79409: NOT
79410: IFFALSE 79414
// continue ;
79412: GO 79193
// if mc_remote_driver [ i ] then
79414: LD_EXP 101
79418: PUSH
79419: LD_VAR 0 2
79423: ARRAY
79424: IFFALSE 79811
// for j in mc_remote_driver [ i ] do
79426: LD_ADDR_VAR 0 3
79430: PUSH
79431: LD_EXP 101
79435: PUSH
79436: LD_VAR 0 2
79440: ARRAY
79441: PUSH
79442: FOR_IN
79443: IFFALSE 79809
// begin if GetClass ( j ) <> 3 then
79445: LD_VAR 0 3
79449: PPUSH
79450: CALL_OW 257
79454: PUSH
79455: LD_INT 3
79457: NONEQUAL
79458: IFFALSE 79511
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
79460: LD_ADDR_EXP 101
79464: PUSH
79465: LD_EXP 101
79469: PPUSH
79470: LD_VAR 0 2
79474: PPUSH
79475: LD_EXP 101
79479: PUSH
79480: LD_VAR 0 2
79484: ARRAY
79485: PUSH
79486: LD_VAR 0 3
79490: DIFF
79491: PPUSH
79492: CALL_OW 1
79496: ST_TO_ADDR
// SetTag ( j , 0 ) ;
79497: LD_VAR 0 3
79501: PPUSH
79502: LD_INT 0
79504: PPUSH
79505: CALL_OW 109
// continue ;
79509: GO 79442
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
79511: LD_EXP 80
79515: PUSH
79516: LD_VAR 0 2
79520: ARRAY
79521: PPUSH
79522: LD_INT 34
79524: PUSH
79525: LD_INT 31
79527: PUSH
79528: EMPTY
79529: LIST
79530: LIST
79531: PUSH
79532: LD_INT 58
79534: PUSH
79535: EMPTY
79536: LIST
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PPUSH
79542: CALL_OW 72
79546: PUSH
79547: LD_VAR 0 3
79551: PPUSH
79552: CALL 50807 0 1
79556: NOT
79557: AND
79558: IFFALSE 79629
// begin if IsInUnit ( j ) then
79560: LD_VAR 0 3
79564: PPUSH
79565: CALL_OW 310
79569: IFFALSE 79580
// ComExitBuilding ( j ) ;
79571: LD_VAR 0 3
79575: PPUSH
79576: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
79580: LD_VAR 0 3
79584: PPUSH
79585: LD_EXP 80
79589: PUSH
79590: LD_VAR 0 2
79594: ARRAY
79595: PPUSH
79596: LD_INT 34
79598: PUSH
79599: LD_INT 31
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 58
79608: PUSH
79609: EMPTY
79610: LIST
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PPUSH
79616: CALL_OW 72
79620: PUSH
79621: LD_INT 1
79623: ARRAY
79624: PPUSH
79625: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
79629: LD_VAR 0 3
79633: PPUSH
79634: CALL_OW 310
79638: NOT
79639: PUSH
79640: LD_VAR 0 3
79644: PPUSH
79645: CALL_OW 310
79649: PPUSH
79650: CALL_OW 266
79654: PUSH
79655: LD_INT 36
79657: NONEQUAL
79658: PUSH
79659: LD_VAR 0 3
79663: PPUSH
79664: CALL 50807 0 1
79668: NOT
79669: AND
79670: OR
79671: IFFALSE 79807
// begin if IsInUnit ( j ) then
79673: LD_VAR 0 3
79677: PPUSH
79678: CALL_OW 310
79682: IFFALSE 79693
// ComExitBuilding ( j ) ;
79684: LD_VAR 0 3
79688: PPUSH
79689: CALL_OW 122
// ct := 0 ;
79693: LD_ADDR_VAR 0 8
79697: PUSH
79698: LD_INT 0
79700: ST_TO_ADDR
// for k in x do
79701: LD_ADDR_VAR 0 4
79705: PUSH
79706: LD_VAR 0 11
79710: PUSH
79711: FOR_IN
79712: IFFALSE 79785
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
79714: LD_VAR 0 4
79718: PPUSH
79719: CALL_OW 264
79723: PUSH
79724: LD_INT 31
79726: EQUAL
79727: PUSH
79728: LD_VAR 0 4
79732: PPUSH
79733: CALL_OW 311
79737: NOT
79738: AND
79739: PUSH
79740: LD_VAR 0 4
79744: PPUSH
79745: CALL_OW 266
79749: PUSH
79750: LD_INT 36
79752: EQUAL
79753: PUSH
79754: LD_VAR 0 4
79758: PPUSH
79759: CALL_OW 313
79763: PUSH
79764: LD_INT 3
79766: LESS
79767: AND
79768: OR
79769: IFFALSE 79783
// begin ct := k ;
79771: LD_ADDR_VAR 0 8
79775: PUSH
79776: LD_VAR 0 4
79780: ST_TO_ADDR
// break ;
79781: GO 79785
// end ;
79783: GO 79711
79785: POP
79786: POP
// if ct then
79787: LD_VAR 0 8
79791: IFFALSE 79807
// ComEnterUnit ( j , ct ) ;
79793: LD_VAR 0 3
79797: PPUSH
79798: LD_VAR 0 8
79802: PPUSH
79803: CALL_OW 120
// end ; end ;
79807: GO 79442
79809: POP
79810: POP
// places := 0 ;
79811: LD_ADDR_VAR 0 5
79815: PUSH
79816: LD_INT 0
79818: ST_TO_ADDR
// for j = 1 to x do
79819: LD_ADDR_VAR 0 3
79823: PUSH
79824: DOUBLE
79825: LD_INT 1
79827: DEC
79828: ST_TO_ADDR
79829: LD_VAR 0 11
79833: PUSH
79834: FOR_TO
79835: IFFALSE 79911
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79837: LD_VAR 0 11
79841: PUSH
79842: LD_VAR 0 3
79846: ARRAY
79847: PPUSH
79848: CALL_OW 264
79852: PUSH
79853: LD_INT 31
79855: EQUAL
79856: IFFALSE 79874
// places := places + 1 else
79858: LD_ADDR_VAR 0 5
79862: PUSH
79863: LD_VAR 0 5
79867: PUSH
79868: LD_INT 1
79870: PLUS
79871: ST_TO_ADDR
79872: GO 79909
// if GetBType ( x [ j ] ) = b_control_tower then
79874: LD_VAR 0 11
79878: PUSH
79879: LD_VAR 0 3
79883: ARRAY
79884: PPUSH
79885: CALL_OW 266
79889: PUSH
79890: LD_INT 36
79892: EQUAL
79893: IFFALSE 79909
// places := places + 3 ;
79895: LD_ADDR_VAR 0 5
79899: PUSH
79900: LD_VAR 0 5
79904: PUSH
79905: LD_INT 3
79907: PLUS
79908: ST_TO_ADDR
79909: GO 79834
79911: POP
79912: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79913: LD_VAR 0 5
79917: PUSH
79918: LD_INT 0
79920: EQUAL
79921: PUSH
79922: LD_VAR 0 5
79926: PUSH
79927: LD_EXP 101
79931: PUSH
79932: LD_VAR 0 2
79936: ARRAY
79937: LESSEQUAL
79938: OR
79939: IFFALSE 79943
// continue ;
79941: GO 79193
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79943: LD_ADDR_VAR 0 6
79947: PUSH
79948: LD_EXP 61
79952: PUSH
79953: LD_VAR 0 2
79957: ARRAY
79958: PPUSH
79959: LD_INT 25
79961: PUSH
79962: LD_INT 3
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: PPUSH
79969: CALL_OW 72
79973: PUSH
79974: LD_EXP 101
79978: PUSH
79979: LD_VAR 0 2
79983: ARRAY
79984: DIFF
79985: PPUSH
79986: LD_INT 3
79988: PPUSH
79989: CALL 51707 0 2
79993: ST_TO_ADDR
// for j in tmp do
79994: LD_ADDR_VAR 0 3
79998: PUSH
79999: LD_VAR 0 6
80003: PUSH
80004: FOR_IN
80005: IFFALSE 80040
// if GetTag ( j ) > 0 then
80007: LD_VAR 0 3
80011: PPUSH
80012: CALL_OW 110
80016: PUSH
80017: LD_INT 0
80019: GREATER
80020: IFFALSE 80038
// tmp := tmp diff j ;
80022: LD_ADDR_VAR 0 6
80026: PUSH
80027: LD_VAR 0 6
80031: PUSH
80032: LD_VAR 0 3
80036: DIFF
80037: ST_TO_ADDR
80038: GO 80004
80040: POP
80041: POP
// if not tmp then
80042: LD_VAR 0 6
80046: NOT
80047: IFFALSE 80051
// continue ;
80049: GO 79193
// if places then
80051: LD_VAR 0 5
80055: IFFALSE 80114
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
80057: LD_ADDR_EXP 101
80061: PUSH
80062: LD_EXP 101
80066: PPUSH
80067: LD_VAR 0 2
80071: PPUSH
80072: LD_EXP 101
80076: PUSH
80077: LD_VAR 0 2
80081: ARRAY
80082: PUSH
80083: LD_VAR 0 6
80087: PUSH
80088: LD_INT 1
80090: ARRAY
80091: UNION
80092: PPUSH
80093: CALL_OW 1
80097: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
80098: LD_VAR 0 6
80102: PUSH
80103: LD_INT 1
80105: ARRAY
80106: PPUSH
80107: LD_INT 126
80109: PPUSH
80110: CALL_OW 109
// end ; end ;
80114: GO 79193
80116: POP
80117: POP
// end ;
80118: LD_VAR 0 1
80122: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
80123: LD_INT 0
80125: PPUSH
80126: PPUSH
80127: PPUSH
80128: PPUSH
80129: PPUSH
80130: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
80131: LD_VAR 0 1
80135: NOT
80136: PUSH
80137: LD_VAR 0 2
80141: NOT
80142: OR
80143: PUSH
80144: LD_VAR 0 3
80148: NOT
80149: OR
80150: PUSH
80151: LD_VAR 0 4
80155: PUSH
80156: LD_INT 1
80158: PUSH
80159: LD_INT 2
80161: PUSH
80162: LD_INT 3
80164: PUSH
80165: LD_INT 4
80167: PUSH
80168: LD_INT 5
80170: PUSH
80171: LD_INT 8
80173: PUSH
80174: LD_INT 9
80176: PUSH
80177: LD_INT 15
80179: PUSH
80180: LD_INT 16
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: LIST
80187: LIST
80188: LIST
80189: LIST
80190: LIST
80191: LIST
80192: LIST
80193: IN
80194: NOT
80195: OR
80196: IFFALSE 80200
// exit ;
80198: GO 81058
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
80200: LD_ADDR_VAR 0 2
80204: PUSH
80205: LD_VAR 0 2
80209: PPUSH
80210: LD_INT 21
80212: PUSH
80213: LD_INT 3
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 24
80222: PUSH
80223: LD_INT 250
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: PUSH
80230: EMPTY
80231: LIST
80232: LIST
80233: PPUSH
80234: CALL_OW 72
80238: ST_TO_ADDR
// case class of 1 , 15 :
80239: LD_VAR 0 4
80243: PUSH
80244: LD_INT 1
80246: DOUBLE
80247: EQUAL
80248: IFTRUE 80258
80250: LD_INT 15
80252: DOUBLE
80253: EQUAL
80254: IFTRUE 80258
80256: GO 80343
80258: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
80259: LD_ADDR_VAR 0 8
80263: PUSH
80264: LD_VAR 0 2
80268: PPUSH
80269: LD_INT 2
80271: PUSH
80272: LD_INT 30
80274: PUSH
80275: LD_INT 32
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 30
80284: PUSH
80285: LD_INT 31
80287: PUSH
80288: EMPTY
80289: LIST
80290: LIST
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: LIST
80296: PPUSH
80297: CALL_OW 72
80301: PUSH
80302: LD_VAR 0 2
80306: PPUSH
80307: LD_INT 2
80309: PUSH
80310: LD_INT 30
80312: PUSH
80313: LD_INT 4
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PUSH
80320: LD_INT 30
80322: PUSH
80323: LD_INT 5
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PUSH
80330: EMPTY
80331: LIST
80332: LIST
80333: LIST
80334: PPUSH
80335: CALL_OW 72
80339: ADD
80340: ST_TO_ADDR
80341: GO 80589
80343: LD_INT 2
80345: DOUBLE
80346: EQUAL
80347: IFTRUE 80357
80349: LD_INT 16
80351: DOUBLE
80352: EQUAL
80353: IFTRUE 80357
80355: GO 80403
80357: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
80358: LD_ADDR_VAR 0 8
80362: PUSH
80363: LD_VAR 0 2
80367: PPUSH
80368: LD_INT 2
80370: PUSH
80371: LD_INT 30
80373: PUSH
80374: LD_INT 0
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 30
80383: PUSH
80384: LD_INT 1
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: LIST
80395: PPUSH
80396: CALL_OW 72
80400: ST_TO_ADDR
80401: GO 80589
80403: LD_INT 3
80405: DOUBLE
80406: EQUAL
80407: IFTRUE 80411
80409: GO 80457
80411: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
80412: LD_ADDR_VAR 0 8
80416: PUSH
80417: LD_VAR 0 2
80421: PPUSH
80422: LD_INT 2
80424: PUSH
80425: LD_INT 30
80427: PUSH
80428: LD_INT 2
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 30
80437: PUSH
80438: LD_INT 3
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: LIST
80449: PPUSH
80450: CALL_OW 72
80454: ST_TO_ADDR
80455: GO 80589
80457: LD_INT 4
80459: DOUBLE
80460: EQUAL
80461: IFTRUE 80465
80463: GO 80522
80465: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
80466: LD_ADDR_VAR 0 8
80470: PUSH
80471: LD_VAR 0 2
80475: PPUSH
80476: LD_INT 2
80478: PUSH
80479: LD_INT 30
80481: PUSH
80482: LD_INT 6
80484: PUSH
80485: EMPTY
80486: LIST
80487: LIST
80488: PUSH
80489: LD_INT 30
80491: PUSH
80492: LD_INT 7
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: PUSH
80499: LD_INT 30
80501: PUSH
80502: LD_INT 8
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: LIST
80513: LIST
80514: PPUSH
80515: CALL_OW 72
80519: ST_TO_ADDR
80520: GO 80589
80522: LD_INT 5
80524: DOUBLE
80525: EQUAL
80526: IFTRUE 80542
80528: LD_INT 8
80530: DOUBLE
80531: EQUAL
80532: IFTRUE 80542
80534: LD_INT 9
80536: DOUBLE
80537: EQUAL
80538: IFTRUE 80542
80540: GO 80588
80542: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
80543: LD_ADDR_VAR 0 8
80547: PUSH
80548: LD_VAR 0 2
80552: PPUSH
80553: LD_INT 2
80555: PUSH
80556: LD_INT 30
80558: PUSH
80559: LD_INT 4
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: PUSH
80566: LD_INT 30
80568: PUSH
80569: LD_INT 5
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: LIST
80580: PPUSH
80581: CALL_OW 72
80585: ST_TO_ADDR
80586: GO 80589
80588: POP
// if not tmp then
80589: LD_VAR 0 8
80593: NOT
80594: IFFALSE 80598
// exit ;
80596: GO 81058
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
80598: LD_VAR 0 4
80602: PUSH
80603: LD_INT 1
80605: PUSH
80606: LD_INT 15
80608: PUSH
80609: EMPTY
80610: LIST
80611: LIST
80612: IN
80613: PUSH
80614: LD_EXP 70
80618: PUSH
80619: LD_VAR 0 1
80623: ARRAY
80624: AND
80625: IFFALSE 80781
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
80627: LD_ADDR_VAR 0 9
80631: PUSH
80632: LD_EXP 70
80636: PUSH
80637: LD_VAR 0 1
80641: ARRAY
80642: PUSH
80643: LD_INT 1
80645: ARRAY
80646: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
80647: LD_VAR 0 9
80651: PUSH
80652: LD_EXP 71
80656: PUSH
80657: LD_VAR 0 1
80661: ARRAY
80662: IN
80663: NOT
80664: IFFALSE 80779
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
80666: LD_ADDR_EXP 71
80670: PUSH
80671: LD_EXP 71
80675: PPUSH
80676: LD_VAR 0 1
80680: PUSH
80681: LD_EXP 71
80685: PUSH
80686: LD_VAR 0 1
80690: ARRAY
80691: PUSH
80692: LD_INT 1
80694: PLUS
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PPUSH
80700: LD_VAR 0 9
80704: PPUSH
80705: CALL 20463 0 3
80709: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
80710: LD_ADDR_EXP 70
80714: PUSH
80715: LD_EXP 70
80719: PPUSH
80720: LD_VAR 0 1
80724: PPUSH
80725: LD_EXP 70
80729: PUSH
80730: LD_VAR 0 1
80734: ARRAY
80735: PUSH
80736: LD_VAR 0 9
80740: DIFF
80741: PPUSH
80742: CALL_OW 1
80746: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80747: LD_VAR 0 3
80751: PPUSH
80752: LD_EXP 71
80756: PUSH
80757: LD_VAR 0 1
80761: ARRAY
80762: PUSH
80763: LD_EXP 71
80767: PUSH
80768: LD_VAR 0 1
80772: ARRAY
80773: ARRAY
80774: PPUSH
80775: CALL_OW 120
// end ; exit ;
80779: GO 81058
// end ; if tmp > 1 then
80781: LD_VAR 0 8
80785: PUSH
80786: LD_INT 1
80788: GREATER
80789: IFFALSE 80893
// for i = 2 to tmp do
80791: LD_ADDR_VAR 0 6
80795: PUSH
80796: DOUBLE
80797: LD_INT 2
80799: DEC
80800: ST_TO_ADDR
80801: LD_VAR 0 8
80805: PUSH
80806: FOR_TO
80807: IFFALSE 80891
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80809: LD_VAR 0 8
80813: PUSH
80814: LD_VAR 0 6
80818: ARRAY
80819: PPUSH
80820: CALL_OW 461
80824: PUSH
80825: LD_INT 6
80827: EQUAL
80828: IFFALSE 80889
// begin x := tmp [ i ] ;
80830: LD_ADDR_VAR 0 9
80834: PUSH
80835: LD_VAR 0 8
80839: PUSH
80840: LD_VAR 0 6
80844: ARRAY
80845: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80846: LD_ADDR_VAR 0 8
80850: PUSH
80851: LD_VAR 0 8
80855: PPUSH
80856: LD_VAR 0 6
80860: PPUSH
80861: CALL_OW 3
80865: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80866: LD_ADDR_VAR 0 8
80870: PUSH
80871: LD_VAR 0 8
80875: PPUSH
80876: LD_INT 1
80878: PPUSH
80879: LD_VAR 0 9
80883: PPUSH
80884: CALL_OW 2
80888: ST_TO_ADDR
// end ;
80889: GO 80806
80891: POP
80892: POP
// for i in tmp do
80893: LD_ADDR_VAR 0 6
80897: PUSH
80898: LD_VAR 0 8
80902: PUSH
80903: FOR_IN
80904: IFFALSE 80931
// begin if IsNotFull ( i ) then
80906: LD_VAR 0 6
80910: PPUSH
80911: CALL 17685 0 1
80915: IFFALSE 80929
// begin j := i ;
80917: LD_ADDR_VAR 0 7
80921: PUSH
80922: LD_VAR 0 6
80926: ST_TO_ADDR
// break ;
80927: GO 80931
// end ; end ;
80929: GO 80903
80931: POP
80932: POP
// if j then
80933: LD_VAR 0 7
80937: IFFALSE 80955
// ComEnterUnit ( unit , j ) else
80939: LD_VAR 0 3
80943: PPUSH
80944: LD_VAR 0 7
80948: PPUSH
80949: CALL_OW 120
80953: GO 81058
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80955: LD_ADDR_VAR 0 10
80959: PUSH
80960: LD_VAR 0 2
80964: PPUSH
80965: LD_INT 2
80967: PUSH
80968: LD_INT 30
80970: PUSH
80971: LD_INT 0
80973: PUSH
80974: EMPTY
80975: LIST
80976: LIST
80977: PUSH
80978: LD_INT 30
80980: PUSH
80981: LD_INT 1
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: LIST
80992: PPUSH
80993: CALL_OW 72
80997: ST_TO_ADDR
// if depot then
80998: LD_VAR 0 10
81002: IFFALSE 81058
// begin depot := NearestUnitToUnit ( depot , unit ) ;
81004: LD_ADDR_VAR 0 10
81008: PUSH
81009: LD_VAR 0 10
81013: PPUSH
81014: LD_VAR 0 3
81018: PPUSH
81019: CALL_OW 74
81023: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
81024: LD_VAR 0 3
81028: PPUSH
81029: LD_VAR 0 10
81033: PPUSH
81034: CALL_OW 296
81038: PUSH
81039: LD_INT 10
81041: GREATER
81042: IFFALSE 81058
// ComStandNearbyBuilding ( unit , depot ) ;
81044: LD_VAR 0 3
81048: PPUSH
81049: LD_VAR 0 10
81053: PPUSH
81054: CALL 17065 0 2
// end ; end ; end ;
81058: LD_VAR 0 5
81062: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
81063: LD_INT 0
81065: PPUSH
81066: PPUSH
81067: PPUSH
81068: PPUSH
// if not mc_bases then
81069: LD_EXP 61
81073: NOT
81074: IFFALSE 81078
// exit ;
81076: GO 81317
// for i = 1 to mc_bases do
81078: LD_ADDR_VAR 0 2
81082: PUSH
81083: DOUBLE
81084: LD_INT 1
81086: DEC
81087: ST_TO_ADDR
81088: LD_EXP 61
81092: PUSH
81093: FOR_TO
81094: IFFALSE 81315
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
81096: LD_ADDR_VAR 0 4
81100: PUSH
81101: LD_EXP 61
81105: PUSH
81106: LD_VAR 0 2
81110: ARRAY
81111: PPUSH
81112: LD_INT 21
81114: PUSH
81115: LD_INT 1
81117: PUSH
81118: EMPTY
81119: LIST
81120: LIST
81121: PPUSH
81122: CALL_OW 72
81126: PUSH
81127: LD_EXP 90
81131: PUSH
81132: LD_VAR 0 2
81136: ARRAY
81137: UNION
81138: ST_TO_ADDR
// if not tmp then
81139: LD_VAR 0 4
81143: NOT
81144: IFFALSE 81148
// continue ;
81146: GO 81093
// for j in tmp do
81148: LD_ADDR_VAR 0 3
81152: PUSH
81153: LD_VAR 0 4
81157: PUSH
81158: FOR_IN
81159: IFFALSE 81311
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
81161: LD_VAR 0 3
81165: PPUSH
81166: CALL_OW 110
81170: NOT
81171: PUSH
81172: LD_VAR 0 3
81176: PPUSH
81177: CALL_OW 314
81181: NOT
81182: AND
81183: PUSH
81184: LD_VAR 0 3
81188: PPUSH
81189: CALL_OW 311
81193: NOT
81194: AND
81195: PUSH
81196: LD_VAR 0 3
81200: PPUSH
81201: CALL_OW 310
81205: NOT
81206: AND
81207: PUSH
81208: LD_VAR 0 3
81212: PUSH
81213: LD_EXP 64
81217: PUSH
81218: LD_VAR 0 2
81222: ARRAY
81223: PUSH
81224: LD_INT 1
81226: ARRAY
81227: IN
81228: NOT
81229: AND
81230: PUSH
81231: LD_VAR 0 3
81235: PUSH
81236: LD_EXP 64
81240: PUSH
81241: LD_VAR 0 2
81245: ARRAY
81246: PUSH
81247: LD_INT 2
81249: ARRAY
81250: IN
81251: NOT
81252: AND
81253: PUSH
81254: LD_VAR 0 3
81258: PUSH
81259: LD_EXP 73
81263: PUSH
81264: LD_VAR 0 2
81268: ARRAY
81269: IN
81270: NOT
81271: AND
81272: IFFALSE 81309
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
81274: LD_VAR 0 2
81278: PPUSH
81279: LD_EXP 61
81283: PUSH
81284: LD_VAR 0 2
81288: ARRAY
81289: PPUSH
81290: LD_VAR 0 3
81294: PPUSH
81295: LD_VAR 0 3
81299: PPUSH
81300: CALL_OW 257
81304: PPUSH
81305: CALL 80123 0 4
// end ;
81309: GO 81158
81311: POP
81312: POP
// end ;
81313: GO 81093
81315: POP
81316: POP
// end ;
81317: LD_VAR 0 1
81321: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
81322: LD_INT 0
81324: PPUSH
81325: PPUSH
81326: PPUSH
81327: PPUSH
81328: PPUSH
81329: PPUSH
// if not mc_bases [ base ] then
81330: LD_EXP 61
81334: PUSH
81335: LD_VAR 0 1
81339: ARRAY
81340: NOT
81341: IFFALSE 81345
// exit ;
81343: GO 81546
// tmp := [ ] ;
81345: LD_ADDR_VAR 0 6
81349: PUSH
81350: EMPTY
81351: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
81352: LD_ADDR_VAR 0 7
81356: PUSH
81357: LD_VAR 0 3
81361: PPUSH
81362: LD_INT 0
81364: PPUSH
81365: CALL_OW 517
81369: ST_TO_ADDR
// if not list then
81370: LD_VAR 0 7
81374: NOT
81375: IFFALSE 81379
// exit ;
81377: GO 81546
// c := Count ( list [ 1 ] ) ;
81379: LD_ADDR_VAR 0 9
81383: PUSH
81384: LD_VAR 0 7
81388: PUSH
81389: LD_INT 1
81391: ARRAY
81392: PPUSH
81393: CALL 17603 0 1
81397: ST_TO_ADDR
// if amount > c then
81398: LD_VAR 0 2
81402: PUSH
81403: LD_VAR 0 9
81407: GREATER
81408: IFFALSE 81420
// amount := c ;
81410: LD_ADDR_VAR 0 2
81414: PUSH
81415: LD_VAR 0 9
81419: ST_TO_ADDR
// for i := 1 to amount do
81420: LD_ADDR_VAR 0 5
81424: PUSH
81425: DOUBLE
81426: LD_INT 1
81428: DEC
81429: ST_TO_ADDR
81430: LD_VAR 0 2
81434: PUSH
81435: FOR_TO
81436: IFFALSE 81494
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
81438: LD_ADDR_VAR 0 6
81442: PUSH
81443: LD_VAR 0 6
81447: PPUSH
81448: LD_VAR 0 5
81452: PPUSH
81453: LD_VAR 0 7
81457: PUSH
81458: LD_INT 1
81460: ARRAY
81461: PUSH
81462: LD_VAR 0 5
81466: ARRAY
81467: PUSH
81468: LD_VAR 0 7
81472: PUSH
81473: LD_INT 2
81475: ARRAY
81476: PUSH
81477: LD_VAR 0 5
81481: ARRAY
81482: PUSH
81483: EMPTY
81484: LIST
81485: LIST
81486: PPUSH
81487: CALL_OW 1
81491: ST_TO_ADDR
81492: GO 81435
81494: POP
81495: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
81496: LD_ADDR_EXP 74
81500: PUSH
81501: LD_EXP 74
81505: PPUSH
81506: LD_VAR 0 1
81510: PPUSH
81511: LD_VAR 0 6
81515: PPUSH
81516: CALL_OW 1
81520: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
81521: LD_ADDR_EXP 76
81525: PUSH
81526: LD_EXP 76
81530: PPUSH
81531: LD_VAR 0 1
81535: PPUSH
81536: LD_VAR 0 3
81540: PPUSH
81541: CALL_OW 1
81545: ST_TO_ADDR
// end ;
81546: LD_VAR 0 4
81550: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
81551: LD_INT 0
81553: PPUSH
// if not mc_bases [ base ] then
81554: LD_EXP 61
81558: PUSH
81559: LD_VAR 0 1
81563: ARRAY
81564: NOT
81565: IFFALSE 81569
// exit ;
81567: GO 81594
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
81569: LD_ADDR_EXP 66
81573: PUSH
81574: LD_EXP 66
81578: PPUSH
81579: LD_VAR 0 1
81583: PPUSH
81584: LD_VAR 0 2
81588: PPUSH
81589: CALL_OW 1
81593: ST_TO_ADDR
// end ;
81594: LD_VAR 0 3
81598: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
81599: LD_INT 0
81601: PPUSH
// if not mc_bases [ base ] then
81602: LD_EXP 61
81606: PUSH
81607: LD_VAR 0 1
81611: ARRAY
81612: NOT
81613: IFFALSE 81617
// exit ;
81615: GO 81654
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
81617: LD_ADDR_EXP 66
81621: PUSH
81622: LD_EXP 66
81626: PPUSH
81627: LD_VAR 0 1
81631: PPUSH
81632: LD_EXP 66
81636: PUSH
81637: LD_VAR 0 1
81641: ARRAY
81642: PUSH
81643: LD_VAR 0 2
81647: UNION
81648: PPUSH
81649: CALL_OW 1
81653: ST_TO_ADDR
// end ;
81654: LD_VAR 0 3
81658: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
81659: LD_INT 0
81661: PPUSH
// if not mc_bases [ base ] then
81662: LD_EXP 61
81666: PUSH
81667: LD_VAR 0 1
81671: ARRAY
81672: NOT
81673: IFFALSE 81677
// exit ;
81675: GO 81702
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
81677: LD_ADDR_EXP 82
81681: PUSH
81682: LD_EXP 82
81686: PPUSH
81687: LD_VAR 0 1
81691: PPUSH
81692: LD_VAR 0 2
81696: PPUSH
81697: CALL_OW 1
81701: ST_TO_ADDR
// end ;
81702: LD_VAR 0 3
81706: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81707: LD_INT 0
81709: PPUSH
// if not mc_bases [ base ] then
81710: LD_EXP 61
81714: PUSH
81715: LD_VAR 0 1
81719: ARRAY
81720: NOT
81721: IFFALSE 81725
// exit ;
81723: GO 81762
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81725: LD_ADDR_EXP 82
81729: PUSH
81730: LD_EXP 82
81734: PPUSH
81735: LD_VAR 0 1
81739: PPUSH
81740: LD_EXP 82
81744: PUSH
81745: LD_VAR 0 1
81749: ARRAY
81750: PUSH
81751: LD_VAR 0 2
81755: ADD
81756: PPUSH
81757: CALL_OW 1
81761: ST_TO_ADDR
// end ;
81762: LD_VAR 0 3
81766: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81767: LD_INT 0
81769: PPUSH
// if not mc_bases [ base ] then
81770: LD_EXP 61
81774: PUSH
81775: LD_VAR 0 1
81779: ARRAY
81780: NOT
81781: IFFALSE 81785
// exit ;
81783: GO 81839
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81785: LD_ADDR_EXP 83
81789: PUSH
81790: LD_EXP 83
81794: PPUSH
81795: LD_VAR 0 1
81799: PPUSH
81800: LD_VAR 0 2
81804: PPUSH
81805: CALL_OW 1
81809: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81810: LD_ADDR_EXP 72
81814: PUSH
81815: LD_EXP 72
81819: PPUSH
81820: LD_VAR 0 1
81824: PPUSH
81825: LD_VAR 0 2
81829: PUSH
81830: LD_INT 0
81832: PLUS
81833: PPUSH
81834: CALL_OW 1
81838: ST_TO_ADDR
// end ;
81839: LD_VAR 0 3
81843: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81844: LD_INT 0
81846: PPUSH
// if not mc_bases [ base ] then
81847: LD_EXP 61
81851: PUSH
81852: LD_VAR 0 1
81856: ARRAY
81857: NOT
81858: IFFALSE 81862
// exit ;
81860: GO 81887
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81862: LD_ADDR_EXP 72
81866: PUSH
81867: LD_EXP 72
81871: PPUSH
81872: LD_VAR 0 1
81876: PPUSH
81877: LD_VAR 0 2
81881: PPUSH
81882: CALL_OW 1
81886: ST_TO_ADDR
// end ;
81887: LD_VAR 0 3
81891: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81892: LD_INT 0
81894: PPUSH
81895: PPUSH
81896: PPUSH
81897: PPUSH
// if not mc_bases [ base ] then
81898: LD_EXP 61
81902: PUSH
81903: LD_VAR 0 1
81907: ARRAY
81908: NOT
81909: IFFALSE 81913
// exit ;
81911: GO 81978
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81913: LD_ADDR_EXP 81
81917: PUSH
81918: LD_EXP 81
81922: PPUSH
81923: LD_VAR 0 1
81927: PUSH
81928: LD_EXP 81
81932: PUSH
81933: LD_VAR 0 1
81937: ARRAY
81938: PUSH
81939: LD_INT 1
81941: PLUS
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PPUSH
81947: LD_VAR 0 1
81951: PUSH
81952: LD_VAR 0 2
81956: PUSH
81957: LD_VAR 0 3
81961: PUSH
81962: LD_VAR 0 4
81966: PUSH
81967: EMPTY
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: PPUSH
81973: CALL 20463 0 3
81977: ST_TO_ADDR
// end ;
81978: LD_VAR 0 5
81982: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81983: LD_INT 0
81985: PPUSH
// if not mc_bases [ base ] then
81986: LD_EXP 61
81990: PUSH
81991: LD_VAR 0 1
81995: ARRAY
81996: NOT
81997: IFFALSE 82001
// exit ;
81999: GO 82026
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
82001: LD_ADDR_EXP 98
82005: PUSH
82006: LD_EXP 98
82010: PPUSH
82011: LD_VAR 0 1
82015: PPUSH
82016: LD_VAR 0 2
82020: PPUSH
82021: CALL_OW 1
82025: ST_TO_ADDR
// end ;
82026: LD_VAR 0 3
82030: RET
// export function MC_GetMinesField ( base ) ; begin
82031: LD_INT 0
82033: PPUSH
// result := mc_mines [ base ] ;
82034: LD_ADDR_VAR 0 2
82038: PUSH
82039: LD_EXP 74
82043: PUSH
82044: LD_VAR 0 1
82048: ARRAY
82049: ST_TO_ADDR
// end ;
82050: LD_VAR 0 2
82054: RET
// export function MC_GetProduceList ( base ) ; begin
82055: LD_INT 0
82057: PPUSH
// result := mc_produce [ base ] ;
82058: LD_ADDR_VAR 0 2
82062: PUSH
82063: LD_EXP 82
82067: PUSH
82068: LD_VAR 0 1
82072: ARRAY
82073: ST_TO_ADDR
// end ;
82074: LD_VAR 0 2
82078: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
82079: LD_INT 0
82081: PPUSH
82082: PPUSH
// if not mc_bases then
82083: LD_EXP 61
82087: NOT
82088: IFFALSE 82092
// exit ;
82090: GO 82157
// if mc_bases [ base ] then
82092: LD_EXP 61
82096: PUSH
82097: LD_VAR 0 1
82101: ARRAY
82102: IFFALSE 82157
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
82104: LD_ADDR_VAR 0 3
82108: PUSH
82109: LD_EXP 61
82113: PUSH
82114: LD_VAR 0 1
82118: ARRAY
82119: PPUSH
82120: LD_INT 30
82122: PUSH
82123: LD_VAR 0 2
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: PPUSH
82132: CALL_OW 72
82136: ST_TO_ADDR
// if result then
82137: LD_VAR 0 3
82141: IFFALSE 82157
// result := result [ 1 ] ;
82143: LD_ADDR_VAR 0 3
82147: PUSH
82148: LD_VAR 0 3
82152: PUSH
82153: LD_INT 1
82155: ARRAY
82156: ST_TO_ADDR
// end ; end ;
82157: LD_VAR 0 3
82161: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
82162: LD_INT 0
82164: PPUSH
82165: PPUSH
// if not mc_bases then
82166: LD_EXP 61
82170: NOT
82171: IFFALSE 82175
// exit ;
82173: GO 82220
// if mc_bases [ base ] then
82175: LD_EXP 61
82179: PUSH
82180: LD_VAR 0 1
82184: ARRAY
82185: IFFALSE 82220
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
82187: LD_ADDR_VAR 0 3
82191: PUSH
82192: LD_EXP 61
82196: PUSH
82197: LD_VAR 0 1
82201: ARRAY
82202: PPUSH
82203: LD_INT 30
82205: PUSH
82206: LD_VAR 0 2
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: PPUSH
82215: CALL_OW 72
82219: ST_TO_ADDR
// end ;
82220: LD_VAR 0 3
82224: RET
// export function MC_SetTame ( base , area ) ; begin
82225: LD_INT 0
82227: PPUSH
// if not mc_bases or not base then
82228: LD_EXP 61
82232: NOT
82233: PUSH
82234: LD_VAR 0 1
82238: NOT
82239: OR
82240: IFFALSE 82244
// exit ;
82242: GO 82269
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
82244: LD_ADDR_EXP 89
82248: PUSH
82249: LD_EXP 89
82253: PPUSH
82254: LD_VAR 0 1
82258: PPUSH
82259: LD_VAR 0 2
82263: PPUSH
82264: CALL_OW 1
82268: ST_TO_ADDR
// end ;
82269: LD_VAR 0 3
82273: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
82274: LD_INT 0
82276: PPUSH
82277: PPUSH
// if not mc_bases or not base then
82278: LD_EXP 61
82282: NOT
82283: PUSH
82284: LD_VAR 0 1
82288: NOT
82289: OR
82290: IFFALSE 82294
// exit ;
82292: GO 82396
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
82294: LD_ADDR_VAR 0 4
82298: PUSH
82299: LD_EXP 61
82303: PUSH
82304: LD_VAR 0 1
82308: ARRAY
82309: PPUSH
82310: LD_INT 30
82312: PUSH
82313: LD_VAR 0 2
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: PPUSH
82322: CALL_OW 72
82326: ST_TO_ADDR
// if not tmp then
82327: LD_VAR 0 4
82331: NOT
82332: IFFALSE 82336
// exit ;
82334: GO 82396
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
82336: LD_ADDR_EXP 93
82340: PUSH
82341: LD_EXP 93
82345: PPUSH
82346: LD_VAR 0 1
82350: PPUSH
82351: LD_EXP 93
82355: PUSH
82356: LD_VAR 0 1
82360: ARRAY
82361: PPUSH
82362: LD_EXP 93
82366: PUSH
82367: LD_VAR 0 1
82371: ARRAY
82372: PUSH
82373: LD_INT 1
82375: PLUS
82376: PPUSH
82377: LD_VAR 0 4
82381: PUSH
82382: LD_INT 1
82384: ARRAY
82385: PPUSH
82386: CALL_OW 2
82390: PPUSH
82391: CALL_OW 1
82395: ST_TO_ADDR
// end ;
82396: LD_VAR 0 3
82400: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
82401: LD_INT 0
82403: PPUSH
82404: PPUSH
// if not mc_bases or not base or not kinds then
82405: LD_EXP 61
82409: NOT
82410: PUSH
82411: LD_VAR 0 1
82415: NOT
82416: OR
82417: PUSH
82418: LD_VAR 0 2
82422: NOT
82423: OR
82424: IFFALSE 82428
// exit ;
82426: GO 82489
// for i in kinds do
82428: LD_ADDR_VAR 0 4
82432: PUSH
82433: LD_VAR 0 2
82437: PUSH
82438: FOR_IN
82439: IFFALSE 82487
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
82441: LD_ADDR_EXP 95
82445: PUSH
82446: LD_EXP 95
82450: PPUSH
82451: LD_VAR 0 1
82455: PUSH
82456: LD_EXP 95
82460: PUSH
82461: LD_VAR 0 1
82465: ARRAY
82466: PUSH
82467: LD_INT 1
82469: PLUS
82470: PUSH
82471: EMPTY
82472: LIST
82473: LIST
82474: PPUSH
82475: LD_VAR 0 4
82479: PPUSH
82480: CALL 20463 0 3
82484: ST_TO_ADDR
82485: GO 82438
82487: POP
82488: POP
// end ;
82489: LD_VAR 0 3
82493: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
82494: LD_INT 0
82496: PPUSH
// if not mc_bases or not base or not areas then
82497: LD_EXP 61
82501: NOT
82502: PUSH
82503: LD_VAR 0 1
82507: NOT
82508: OR
82509: PUSH
82510: LD_VAR 0 2
82514: NOT
82515: OR
82516: IFFALSE 82520
// exit ;
82518: GO 82545
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
82520: LD_ADDR_EXP 79
82524: PUSH
82525: LD_EXP 79
82529: PPUSH
82530: LD_VAR 0 1
82534: PPUSH
82535: LD_VAR 0 2
82539: PPUSH
82540: CALL_OW 1
82544: ST_TO_ADDR
// end ;
82545: LD_VAR 0 3
82549: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
82550: LD_INT 0
82552: PPUSH
// if not mc_bases or not base or not teleports_exit then
82553: LD_EXP 61
82557: NOT
82558: PUSH
82559: LD_VAR 0 1
82563: NOT
82564: OR
82565: PUSH
82566: LD_VAR 0 2
82570: NOT
82571: OR
82572: IFFALSE 82576
// exit ;
82574: GO 82601
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
82576: LD_ADDR_EXP 96
82580: PUSH
82581: LD_EXP 96
82585: PPUSH
82586: LD_VAR 0 1
82590: PPUSH
82591: LD_VAR 0 2
82595: PPUSH
82596: CALL_OW 1
82600: ST_TO_ADDR
// end ;
82601: LD_VAR 0 3
82605: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
82606: LD_INT 0
82608: PPUSH
82609: PPUSH
82610: PPUSH
// if not mc_bases or not base or not ext_list then
82611: LD_EXP 61
82615: NOT
82616: PUSH
82617: LD_VAR 0 1
82621: NOT
82622: OR
82623: PUSH
82624: LD_VAR 0 5
82628: NOT
82629: OR
82630: IFFALSE 82634
// exit ;
82632: GO 82807
// tmp := GetFacExtXYD ( x , y , d ) ;
82634: LD_ADDR_VAR 0 8
82638: PUSH
82639: LD_VAR 0 2
82643: PPUSH
82644: LD_VAR 0 3
82648: PPUSH
82649: LD_VAR 0 4
82653: PPUSH
82654: CALL 50837 0 3
82658: ST_TO_ADDR
// if not tmp then
82659: LD_VAR 0 8
82663: NOT
82664: IFFALSE 82668
// exit ;
82666: GO 82807
// for i in tmp do
82668: LD_ADDR_VAR 0 7
82672: PUSH
82673: LD_VAR 0 8
82677: PUSH
82678: FOR_IN
82679: IFFALSE 82805
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
82681: LD_ADDR_EXP 66
82685: PUSH
82686: LD_EXP 66
82690: PPUSH
82691: LD_VAR 0 1
82695: PPUSH
82696: LD_EXP 66
82700: PUSH
82701: LD_VAR 0 1
82705: ARRAY
82706: PPUSH
82707: LD_EXP 66
82711: PUSH
82712: LD_VAR 0 1
82716: ARRAY
82717: PUSH
82718: LD_INT 1
82720: PLUS
82721: PPUSH
82722: LD_VAR 0 5
82726: PUSH
82727: LD_INT 1
82729: ARRAY
82730: PUSH
82731: LD_VAR 0 7
82735: PUSH
82736: LD_INT 1
82738: ARRAY
82739: PUSH
82740: LD_VAR 0 7
82744: PUSH
82745: LD_INT 2
82747: ARRAY
82748: PUSH
82749: LD_VAR 0 7
82753: PUSH
82754: LD_INT 3
82756: ARRAY
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: PPUSH
82764: CALL_OW 2
82768: PPUSH
82769: CALL_OW 1
82773: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82774: LD_ADDR_VAR 0 5
82778: PUSH
82779: LD_VAR 0 5
82783: PPUSH
82784: LD_INT 1
82786: PPUSH
82787: CALL_OW 3
82791: ST_TO_ADDR
// if not ext_list then
82792: LD_VAR 0 5
82796: NOT
82797: IFFALSE 82803
// exit ;
82799: POP
82800: POP
82801: GO 82807
// end ;
82803: GO 82678
82805: POP
82806: POP
// end ;
82807: LD_VAR 0 6
82811: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82812: LD_INT 0
82814: PPUSH
// if not mc_bases or not base or not weapon_list then
82815: LD_EXP 61
82819: NOT
82820: PUSH
82821: LD_VAR 0 1
82825: NOT
82826: OR
82827: PUSH
82828: LD_VAR 0 2
82832: NOT
82833: OR
82834: IFFALSE 82838
// exit ;
82836: GO 82863
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82838: LD_ADDR_EXP 100
82842: PUSH
82843: LD_EXP 100
82847: PPUSH
82848: LD_VAR 0 1
82852: PPUSH
82853: LD_VAR 0 2
82857: PPUSH
82858: CALL_OW 1
82862: ST_TO_ADDR
// end ;
82863: LD_VAR 0 3
82867: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82868: LD_INT 0
82870: PPUSH
// if not mc_bases or not base or not tech_list then
82871: LD_EXP 61
82875: NOT
82876: PUSH
82877: LD_VAR 0 1
82881: NOT
82882: OR
82883: PUSH
82884: LD_VAR 0 2
82888: NOT
82889: OR
82890: IFFALSE 82894
// exit ;
82892: GO 82919
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82894: LD_ADDR_EXP 88
82898: PUSH
82899: LD_EXP 88
82903: PPUSH
82904: LD_VAR 0 1
82908: PPUSH
82909: LD_VAR 0 2
82913: PPUSH
82914: CALL_OW 1
82918: ST_TO_ADDR
// end ;
82919: LD_VAR 0 3
82923: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82924: LD_INT 0
82926: PPUSH
// if not mc_bases or not parking_area or not base then
82927: LD_EXP 61
82931: NOT
82932: PUSH
82933: LD_VAR 0 2
82937: NOT
82938: OR
82939: PUSH
82940: LD_VAR 0 1
82944: NOT
82945: OR
82946: IFFALSE 82950
// exit ;
82948: GO 82975
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82950: LD_ADDR_EXP 85
82954: PUSH
82955: LD_EXP 85
82959: PPUSH
82960: LD_VAR 0 1
82964: PPUSH
82965: LD_VAR 0 2
82969: PPUSH
82970: CALL_OW 1
82974: ST_TO_ADDR
// end ;
82975: LD_VAR 0 3
82979: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82980: LD_INT 0
82982: PPUSH
// if not mc_bases or not base or not scan_area then
82983: LD_EXP 61
82987: NOT
82988: PUSH
82989: LD_VAR 0 1
82993: NOT
82994: OR
82995: PUSH
82996: LD_VAR 0 2
83000: NOT
83001: OR
83002: IFFALSE 83006
// exit ;
83004: GO 83031
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
83006: LD_ADDR_EXP 86
83010: PUSH
83011: LD_EXP 86
83015: PPUSH
83016: LD_VAR 0 1
83020: PPUSH
83021: LD_VAR 0 2
83025: PPUSH
83026: CALL_OW 1
83030: ST_TO_ADDR
// end ;
83031: LD_VAR 0 3
83035: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
83036: LD_INT 0
83038: PPUSH
83039: PPUSH
// if not mc_bases or not base then
83040: LD_EXP 61
83044: NOT
83045: PUSH
83046: LD_VAR 0 1
83050: NOT
83051: OR
83052: IFFALSE 83056
// exit ;
83054: GO 83120
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
83056: LD_ADDR_VAR 0 3
83060: PUSH
83061: LD_INT 1
83063: PUSH
83064: LD_INT 2
83066: PUSH
83067: LD_INT 3
83069: PUSH
83070: LD_INT 4
83072: PUSH
83073: LD_INT 11
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
83083: LD_ADDR_EXP 88
83087: PUSH
83088: LD_EXP 88
83092: PPUSH
83093: LD_VAR 0 1
83097: PPUSH
83098: LD_EXP 88
83102: PUSH
83103: LD_VAR 0 1
83107: ARRAY
83108: PUSH
83109: LD_VAR 0 3
83113: DIFF
83114: PPUSH
83115: CALL_OW 1
83119: ST_TO_ADDR
// end ;
83120: LD_VAR 0 2
83124: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
83125: LD_INT 0
83127: PPUSH
// result := mc_vehicles [ base ] ;
83128: LD_ADDR_VAR 0 3
83132: PUSH
83133: LD_EXP 80
83137: PUSH
83138: LD_VAR 0 1
83142: ARRAY
83143: ST_TO_ADDR
// if onlyCombat then
83144: LD_VAR 0 2
83148: IFFALSE 83320
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
83150: LD_ADDR_VAR 0 3
83154: PUSH
83155: LD_VAR 0 3
83159: PUSH
83160: LD_VAR 0 3
83164: PPUSH
83165: LD_INT 2
83167: PUSH
83168: LD_INT 34
83170: PUSH
83171: LD_INT 12
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 34
83180: PUSH
83181: LD_INT 51
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: LD_INT 34
83190: PUSH
83191: LD_INT 89
83193: PUSH
83194: EMPTY
83195: LIST
83196: LIST
83197: PUSH
83198: LD_INT 34
83200: PUSH
83201: LD_INT 32
83203: PUSH
83204: EMPTY
83205: LIST
83206: LIST
83207: PUSH
83208: LD_INT 34
83210: PUSH
83211: LD_INT 13
83213: PUSH
83214: EMPTY
83215: LIST
83216: LIST
83217: PUSH
83218: LD_INT 34
83220: PUSH
83221: LD_INT 52
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PUSH
83228: LD_INT 34
83230: PUSH
83231: LD_INT 88
83233: PUSH
83234: EMPTY
83235: LIST
83236: LIST
83237: PUSH
83238: LD_INT 34
83240: PUSH
83241: LD_INT 14
83243: PUSH
83244: EMPTY
83245: LIST
83246: LIST
83247: PUSH
83248: LD_INT 34
83250: PUSH
83251: LD_INT 53
83253: PUSH
83254: EMPTY
83255: LIST
83256: LIST
83257: PUSH
83258: LD_INT 34
83260: PUSH
83261: LD_INT 98
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: LD_INT 34
83270: PUSH
83271: LD_INT 31
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 34
83280: PUSH
83281: LD_INT 48
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: LD_INT 34
83290: PUSH
83291: LD_INT 8
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: PUSH
83298: EMPTY
83299: LIST
83300: LIST
83301: LIST
83302: LIST
83303: LIST
83304: LIST
83305: LIST
83306: LIST
83307: LIST
83308: LIST
83309: LIST
83310: LIST
83311: LIST
83312: LIST
83313: PPUSH
83314: CALL_OW 72
83318: DIFF
83319: ST_TO_ADDR
// end ; end_of_file
83320: LD_VAR 0 3
83324: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
83325: LD_INT 0
83327: PPUSH
83328: PPUSH
83329: PPUSH
// if not mc_bases or not skirmish then
83330: LD_EXP 61
83334: NOT
83335: PUSH
83336: LD_EXP 59
83340: NOT
83341: OR
83342: IFFALSE 83346
// exit ;
83344: GO 83511
// for i = 1 to mc_bases do
83346: LD_ADDR_VAR 0 4
83350: PUSH
83351: DOUBLE
83352: LD_INT 1
83354: DEC
83355: ST_TO_ADDR
83356: LD_EXP 61
83360: PUSH
83361: FOR_TO
83362: IFFALSE 83509
// begin if sci in mc_bases [ i ] then
83364: LD_VAR 0 2
83368: PUSH
83369: LD_EXP 61
83373: PUSH
83374: LD_VAR 0 4
83378: ARRAY
83379: IN
83380: IFFALSE 83507
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
83382: LD_ADDR_EXP 90
83386: PUSH
83387: LD_EXP 90
83391: PPUSH
83392: LD_VAR 0 4
83396: PUSH
83397: LD_EXP 90
83401: PUSH
83402: LD_VAR 0 4
83406: ARRAY
83407: PUSH
83408: LD_INT 1
83410: PLUS
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: PPUSH
83416: LD_VAR 0 1
83420: PPUSH
83421: CALL 20463 0 3
83425: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
83426: LD_ADDR_VAR 0 5
83430: PUSH
83431: LD_EXP 61
83435: PUSH
83436: LD_VAR 0 4
83440: ARRAY
83441: PPUSH
83442: LD_INT 2
83444: PUSH
83445: LD_INT 30
83447: PUSH
83448: LD_INT 0
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 30
83457: PUSH
83458: LD_INT 1
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: LIST
83469: PPUSH
83470: CALL_OW 72
83474: PPUSH
83475: LD_VAR 0 1
83479: PPUSH
83480: CALL_OW 74
83484: ST_TO_ADDR
// if tmp then
83485: LD_VAR 0 5
83489: IFFALSE 83505
// ComStandNearbyBuilding ( ape , tmp ) ;
83491: LD_VAR 0 1
83495: PPUSH
83496: LD_VAR 0 5
83500: PPUSH
83501: CALL 17065 0 2
// break ;
83505: GO 83509
// end ; end ;
83507: GO 83361
83509: POP
83510: POP
// end ;
83511: LD_VAR 0 3
83515: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
83516: LD_INT 0
83518: PPUSH
83519: PPUSH
83520: PPUSH
// if not mc_bases or not skirmish then
83521: LD_EXP 61
83525: NOT
83526: PUSH
83527: LD_EXP 59
83531: NOT
83532: OR
83533: IFFALSE 83537
// exit ;
83535: GO 83626
// for i = 1 to mc_bases do
83537: LD_ADDR_VAR 0 4
83541: PUSH
83542: DOUBLE
83543: LD_INT 1
83545: DEC
83546: ST_TO_ADDR
83547: LD_EXP 61
83551: PUSH
83552: FOR_TO
83553: IFFALSE 83624
// begin if building in mc_busy_turret_list [ i ] then
83555: LD_VAR 0 1
83559: PUSH
83560: LD_EXP 71
83564: PUSH
83565: LD_VAR 0 4
83569: ARRAY
83570: IN
83571: IFFALSE 83622
// begin tmp := mc_busy_turret_list [ i ] diff building ;
83573: LD_ADDR_VAR 0 5
83577: PUSH
83578: LD_EXP 71
83582: PUSH
83583: LD_VAR 0 4
83587: ARRAY
83588: PUSH
83589: LD_VAR 0 1
83593: DIFF
83594: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
83595: LD_ADDR_EXP 71
83599: PUSH
83600: LD_EXP 71
83604: PPUSH
83605: LD_VAR 0 4
83609: PPUSH
83610: LD_VAR 0 5
83614: PPUSH
83615: CALL_OW 1
83619: ST_TO_ADDR
// break ;
83620: GO 83624
// end ; end ;
83622: GO 83552
83624: POP
83625: POP
// end ;
83626: LD_VAR 0 3
83630: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
83631: LD_INT 0
83633: PPUSH
83634: PPUSH
83635: PPUSH
// if not mc_bases or not skirmish then
83636: LD_EXP 61
83640: NOT
83641: PUSH
83642: LD_EXP 59
83646: NOT
83647: OR
83648: IFFALSE 83652
// exit ;
83650: GO 83851
// for i = 1 to mc_bases do
83652: LD_ADDR_VAR 0 5
83656: PUSH
83657: DOUBLE
83658: LD_INT 1
83660: DEC
83661: ST_TO_ADDR
83662: LD_EXP 61
83666: PUSH
83667: FOR_TO
83668: IFFALSE 83849
// if building in mc_bases [ i ] then
83670: LD_VAR 0 1
83674: PUSH
83675: LD_EXP 61
83679: PUSH
83680: LD_VAR 0 5
83684: ARRAY
83685: IN
83686: IFFALSE 83847
// begin tmp := mc_bases [ i ] diff building ;
83688: LD_ADDR_VAR 0 6
83692: PUSH
83693: LD_EXP 61
83697: PUSH
83698: LD_VAR 0 5
83702: ARRAY
83703: PUSH
83704: LD_VAR 0 1
83708: DIFF
83709: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
83710: LD_ADDR_EXP 61
83714: PUSH
83715: LD_EXP 61
83719: PPUSH
83720: LD_VAR 0 5
83724: PPUSH
83725: LD_VAR 0 6
83729: PPUSH
83730: CALL_OW 1
83734: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83735: LD_VAR 0 1
83739: PUSH
83740: LD_EXP 69
83744: PUSH
83745: LD_VAR 0 5
83749: ARRAY
83750: IN
83751: IFFALSE 83790
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83753: LD_ADDR_EXP 69
83757: PUSH
83758: LD_EXP 69
83762: PPUSH
83763: LD_VAR 0 5
83767: PPUSH
83768: LD_EXP 69
83772: PUSH
83773: LD_VAR 0 5
83777: ARRAY
83778: PUSH
83779: LD_VAR 0 1
83783: DIFF
83784: PPUSH
83785: CALL_OW 1
83789: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83790: LD_VAR 0 1
83794: PUSH
83795: LD_EXP 70
83799: PUSH
83800: LD_VAR 0 5
83804: ARRAY
83805: IN
83806: IFFALSE 83845
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83808: LD_ADDR_EXP 70
83812: PUSH
83813: LD_EXP 70
83817: PPUSH
83818: LD_VAR 0 5
83822: PPUSH
83823: LD_EXP 70
83827: PUSH
83828: LD_VAR 0 5
83832: ARRAY
83833: PUSH
83834: LD_VAR 0 1
83838: DIFF
83839: PPUSH
83840: CALL_OW 1
83844: ST_TO_ADDR
// break ;
83845: GO 83849
// end ;
83847: GO 83667
83849: POP
83850: POP
// end ;
83851: LD_VAR 0 4
83855: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83856: LD_INT 0
83858: PPUSH
83859: PPUSH
83860: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83861: LD_EXP 61
83865: NOT
83866: PUSH
83867: LD_EXP 59
83871: NOT
83872: OR
83873: PUSH
83874: LD_VAR 0 3
83878: PUSH
83879: LD_EXP 87
83883: IN
83884: NOT
83885: OR
83886: IFFALSE 83890
// exit ;
83888: GO 84013
// for i = 1 to mc_vehicles do
83890: LD_ADDR_VAR 0 6
83894: PUSH
83895: DOUBLE
83896: LD_INT 1
83898: DEC
83899: ST_TO_ADDR
83900: LD_EXP 80
83904: PUSH
83905: FOR_TO
83906: IFFALSE 84011
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83908: LD_VAR 0 2
83912: PUSH
83913: LD_EXP 80
83917: PUSH
83918: LD_VAR 0 6
83922: ARRAY
83923: IN
83924: PUSH
83925: LD_VAR 0 1
83929: PUSH
83930: LD_EXP 80
83934: PUSH
83935: LD_VAR 0 6
83939: ARRAY
83940: IN
83941: OR
83942: IFFALSE 84009
// begin tmp := mc_vehicles [ i ] diff old ;
83944: LD_ADDR_VAR 0 7
83948: PUSH
83949: LD_EXP 80
83953: PUSH
83954: LD_VAR 0 6
83958: ARRAY
83959: PUSH
83960: LD_VAR 0 2
83964: DIFF
83965: ST_TO_ADDR
// tmp := tmp diff new ;
83966: LD_ADDR_VAR 0 7
83970: PUSH
83971: LD_VAR 0 7
83975: PUSH
83976: LD_VAR 0 1
83980: DIFF
83981: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83982: LD_ADDR_EXP 80
83986: PUSH
83987: LD_EXP 80
83991: PPUSH
83992: LD_VAR 0 6
83996: PPUSH
83997: LD_VAR 0 7
84001: PPUSH
84002: CALL_OW 1
84006: ST_TO_ADDR
// break ;
84007: GO 84011
// end ;
84009: GO 83905
84011: POP
84012: POP
// end ;
84013: LD_VAR 0 5
84017: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
84018: LD_INT 0
84020: PPUSH
84021: PPUSH
84022: PPUSH
84023: PPUSH
// if not mc_bases or not skirmish then
84024: LD_EXP 61
84028: NOT
84029: PUSH
84030: LD_EXP 59
84034: NOT
84035: OR
84036: IFFALSE 84040
// exit ;
84038: GO 84460
// repeat wait ( 0 0$1 ) ;
84040: LD_INT 35
84042: PPUSH
84043: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
84047: LD_EXP 105
84051: NOT
84052: IFFALSE 84040
// mc_block_vehicle_constructed_thread := true ;
84054: LD_ADDR_EXP 105
84058: PUSH
84059: LD_INT 1
84061: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
84062: LD_ADDR_VAR 0 5
84066: PUSH
84067: LD_VAR 0 1
84071: PPUSH
84072: CALL_OW 255
84076: ST_TO_ADDR
// for i = 1 to mc_bases do
84077: LD_ADDR_VAR 0 4
84081: PUSH
84082: DOUBLE
84083: LD_INT 1
84085: DEC
84086: ST_TO_ADDR
84087: LD_EXP 61
84091: PUSH
84092: FOR_TO
84093: IFFALSE 84450
// begin if factory in mc_bases [ i ] then
84095: LD_VAR 0 2
84099: PUSH
84100: LD_EXP 61
84104: PUSH
84105: LD_VAR 0 4
84109: ARRAY
84110: IN
84111: IFFALSE 84448
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
84113: LD_EXP 83
84117: PUSH
84118: LD_VAR 0 4
84122: ARRAY
84123: PUSH
84124: LD_EXP 72
84128: PUSH
84129: LD_VAR 0 4
84133: ARRAY
84134: LESS
84135: PUSH
84136: LD_VAR 0 1
84140: PPUSH
84141: CALL_OW 264
84145: PUSH
84146: LD_INT 31
84148: PUSH
84149: LD_INT 32
84151: PUSH
84152: LD_INT 51
84154: PUSH
84155: LD_INT 89
84157: PUSH
84158: LD_INT 12
84160: PUSH
84161: LD_INT 30
84163: PUSH
84164: LD_INT 98
84166: PUSH
84167: LD_INT 11
84169: PUSH
84170: LD_INT 53
84172: PUSH
84173: LD_INT 14
84175: PUSH
84176: LD_INT 91
84178: PUSH
84179: LD_INT 29
84181: PUSH
84182: LD_INT 99
84184: PUSH
84185: LD_INT 13
84187: PUSH
84188: LD_INT 52
84190: PUSH
84191: LD_INT 88
84193: PUSH
84194: LD_INT 48
84196: PUSH
84197: LD_INT 8
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: LIST
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: IN
84220: NOT
84221: AND
84222: IFFALSE 84270
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
84224: LD_ADDR_EXP 83
84228: PUSH
84229: LD_EXP 83
84233: PPUSH
84234: LD_VAR 0 4
84238: PUSH
84239: LD_EXP 83
84243: PUSH
84244: LD_VAR 0 4
84248: ARRAY
84249: PUSH
84250: LD_INT 1
84252: PLUS
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: PPUSH
84258: LD_VAR 0 1
84262: PPUSH
84263: CALL 20463 0 3
84267: ST_TO_ADDR
84268: GO 84314
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
84270: LD_ADDR_EXP 80
84274: PUSH
84275: LD_EXP 80
84279: PPUSH
84280: LD_VAR 0 4
84284: PUSH
84285: LD_EXP 80
84289: PUSH
84290: LD_VAR 0 4
84294: ARRAY
84295: PUSH
84296: LD_INT 1
84298: PLUS
84299: PUSH
84300: EMPTY
84301: LIST
84302: LIST
84303: PPUSH
84304: LD_VAR 0 1
84308: PPUSH
84309: CALL 20463 0 3
84313: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
84314: LD_ADDR_EXP 105
84318: PUSH
84319: LD_INT 0
84321: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
84322: LD_VAR 0 1
84326: PPUSH
84327: CALL_OW 263
84331: PUSH
84332: LD_INT 2
84334: EQUAL
84335: IFFALSE 84364
// begin repeat wait ( 0 0$3 ) ;
84337: LD_INT 105
84339: PPUSH
84340: CALL_OW 67
// Connect ( vehicle ) ;
84344: LD_VAR 0 1
84348: PPUSH
84349: CALL 23809 0 1
// until IsControledBy ( vehicle ) ;
84353: LD_VAR 0 1
84357: PPUSH
84358: CALL_OW 312
84362: IFFALSE 84337
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
84364: LD_VAR 0 1
84368: PPUSH
84369: LD_EXP 85
84373: PUSH
84374: LD_VAR 0 4
84378: ARRAY
84379: PPUSH
84380: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
84384: LD_VAR 0 1
84388: PPUSH
84389: CALL_OW 263
84393: PUSH
84394: LD_INT 1
84396: NONEQUAL
84397: IFFALSE 84401
// break ;
84399: GO 84450
// repeat wait ( 0 0$1 ) ;
84401: LD_INT 35
84403: PPUSH
84404: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
84408: LD_VAR 0 1
84412: PPUSH
84413: LD_EXP 85
84417: PUSH
84418: LD_VAR 0 4
84422: ARRAY
84423: PPUSH
84424: CALL_OW 308
84428: IFFALSE 84401
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
84430: LD_VAR 0 1
84434: PPUSH
84435: CALL_OW 311
84439: PPUSH
84440: CALL_OW 121
// exit ;
84444: POP
84445: POP
84446: GO 84460
// end ; end ;
84448: GO 84092
84450: POP
84451: POP
// mc_block_vehicle_constructed_thread := false ;
84452: LD_ADDR_EXP 105
84456: PUSH
84457: LD_INT 0
84459: ST_TO_ADDR
// end ;
84460: LD_VAR 0 3
84464: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
84465: LD_INT 0
84467: PPUSH
84468: PPUSH
84469: PPUSH
84470: PPUSH
// if not mc_bases or not skirmish then
84471: LD_EXP 61
84475: NOT
84476: PUSH
84477: LD_EXP 59
84481: NOT
84482: OR
84483: IFFALSE 84487
// exit ;
84485: GO 84840
// repeat wait ( 0 0$1 ) ;
84487: LD_INT 35
84489: PPUSH
84490: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
84494: LD_VAR 0 2
84498: PPUSH
84499: LD_VAR 0 3
84503: PPUSH
84504: CALL_OW 284
84508: IFFALSE 84487
// if GetResourceTypeXY ( x , y ) = mat_artefact then
84510: LD_VAR 0 2
84514: PPUSH
84515: LD_VAR 0 3
84519: PPUSH
84520: CALL_OW 283
84524: PUSH
84525: LD_INT 4
84527: EQUAL
84528: IFFALSE 84532
// exit ;
84530: GO 84840
// for i = 1 to mc_bases do
84532: LD_ADDR_VAR 0 7
84536: PUSH
84537: DOUBLE
84538: LD_INT 1
84540: DEC
84541: ST_TO_ADDR
84542: LD_EXP 61
84546: PUSH
84547: FOR_TO
84548: IFFALSE 84838
// begin if mc_crates_area [ i ] then
84550: LD_EXP 79
84554: PUSH
84555: LD_VAR 0 7
84559: ARRAY
84560: IFFALSE 84671
// for j in mc_crates_area [ i ] do
84562: LD_ADDR_VAR 0 8
84566: PUSH
84567: LD_EXP 79
84571: PUSH
84572: LD_VAR 0 7
84576: ARRAY
84577: PUSH
84578: FOR_IN
84579: IFFALSE 84669
// if InArea ( x , y , j ) then
84581: LD_VAR 0 2
84585: PPUSH
84586: LD_VAR 0 3
84590: PPUSH
84591: LD_VAR 0 8
84595: PPUSH
84596: CALL_OW 309
84600: IFFALSE 84667
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84602: LD_ADDR_EXP 77
84606: PUSH
84607: LD_EXP 77
84611: PPUSH
84612: LD_VAR 0 7
84616: PUSH
84617: LD_EXP 77
84621: PUSH
84622: LD_VAR 0 7
84626: ARRAY
84627: PUSH
84628: LD_INT 1
84630: PLUS
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PPUSH
84636: LD_VAR 0 4
84640: PUSH
84641: LD_VAR 0 2
84645: PUSH
84646: LD_VAR 0 3
84650: PUSH
84651: EMPTY
84652: LIST
84653: LIST
84654: LIST
84655: PPUSH
84656: CALL 20463 0 3
84660: ST_TO_ADDR
// exit ;
84661: POP
84662: POP
84663: POP
84664: POP
84665: GO 84840
// end ;
84667: GO 84578
84669: POP
84670: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84671: LD_ADDR_VAR 0 9
84675: PUSH
84676: LD_EXP 61
84680: PUSH
84681: LD_VAR 0 7
84685: ARRAY
84686: PPUSH
84687: LD_INT 2
84689: PUSH
84690: LD_INT 30
84692: PUSH
84693: LD_INT 0
84695: PUSH
84696: EMPTY
84697: LIST
84698: LIST
84699: PUSH
84700: LD_INT 30
84702: PUSH
84703: LD_INT 1
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: LIST
84714: PPUSH
84715: CALL_OW 72
84719: ST_TO_ADDR
// if not depot then
84720: LD_VAR 0 9
84724: NOT
84725: IFFALSE 84729
// continue ;
84727: GO 84547
// for j in depot do
84729: LD_ADDR_VAR 0 8
84733: PUSH
84734: LD_VAR 0 9
84738: PUSH
84739: FOR_IN
84740: IFFALSE 84834
// if GetDistUnitXY ( j , x , y ) < 30 then
84742: LD_VAR 0 8
84746: PPUSH
84747: LD_VAR 0 2
84751: PPUSH
84752: LD_VAR 0 3
84756: PPUSH
84757: CALL_OW 297
84761: PUSH
84762: LD_INT 30
84764: LESS
84765: IFFALSE 84832
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84767: LD_ADDR_EXP 77
84771: PUSH
84772: LD_EXP 77
84776: PPUSH
84777: LD_VAR 0 7
84781: PUSH
84782: LD_EXP 77
84786: PUSH
84787: LD_VAR 0 7
84791: ARRAY
84792: PUSH
84793: LD_INT 1
84795: PLUS
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: PPUSH
84801: LD_VAR 0 4
84805: PUSH
84806: LD_VAR 0 2
84810: PUSH
84811: LD_VAR 0 3
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: LIST
84820: PPUSH
84821: CALL 20463 0 3
84825: ST_TO_ADDR
// exit ;
84826: POP
84827: POP
84828: POP
84829: POP
84830: GO 84840
// end ;
84832: GO 84739
84834: POP
84835: POP
// end ;
84836: GO 84547
84838: POP
84839: POP
// end ;
84840: LD_VAR 0 6
84844: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84845: LD_INT 0
84847: PPUSH
84848: PPUSH
84849: PPUSH
84850: PPUSH
// if not mc_bases or not skirmish then
84851: LD_EXP 61
84855: NOT
84856: PUSH
84857: LD_EXP 59
84861: NOT
84862: OR
84863: IFFALSE 84867
// exit ;
84865: GO 85144
// side := GetSide ( lab ) ;
84867: LD_ADDR_VAR 0 4
84871: PUSH
84872: LD_VAR 0 2
84876: PPUSH
84877: CALL_OW 255
84881: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84882: LD_VAR 0 4
84886: PUSH
84887: LD_EXP 87
84891: IN
84892: NOT
84893: PUSH
84894: LD_EXP 88
84898: NOT
84899: OR
84900: PUSH
84901: LD_EXP 61
84905: NOT
84906: OR
84907: IFFALSE 84911
// exit ;
84909: GO 85144
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84911: LD_ADDR_EXP 88
84915: PUSH
84916: LD_EXP 88
84920: PPUSH
84921: LD_VAR 0 4
84925: PPUSH
84926: LD_EXP 88
84930: PUSH
84931: LD_VAR 0 4
84935: ARRAY
84936: PUSH
84937: LD_VAR 0 1
84941: DIFF
84942: PPUSH
84943: CALL_OW 1
84947: ST_TO_ADDR
// for i = 1 to mc_bases do
84948: LD_ADDR_VAR 0 5
84952: PUSH
84953: DOUBLE
84954: LD_INT 1
84956: DEC
84957: ST_TO_ADDR
84958: LD_EXP 61
84962: PUSH
84963: FOR_TO
84964: IFFALSE 85142
// begin if lab in mc_bases [ i ] then
84966: LD_VAR 0 2
84970: PUSH
84971: LD_EXP 61
84975: PUSH
84976: LD_VAR 0 5
84980: ARRAY
84981: IN
84982: IFFALSE 85140
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84984: LD_VAR 0 1
84988: PUSH
84989: LD_INT 11
84991: PUSH
84992: LD_INT 4
84994: PUSH
84995: LD_INT 3
84997: PUSH
84998: LD_INT 2
85000: PUSH
85001: EMPTY
85002: LIST
85003: LIST
85004: LIST
85005: LIST
85006: IN
85007: PUSH
85008: LD_EXP 91
85012: PUSH
85013: LD_VAR 0 5
85017: ARRAY
85018: AND
85019: IFFALSE 85140
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
85021: LD_ADDR_VAR 0 6
85025: PUSH
85026: LD_EXP 91
85030: PUSH
85031: LD_VAR 0 5
85035: ARRAY
85036: PUSH
85037: LD_INT 1
85039: ARRAY
85040: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
85041: LD_ADDR_EXP 91
85045: PUSH
85046: LD_EXP 91
85050: PPUSH
85051: LD_VAR 0 5
85055: PPUSH
85056: EMPTY
85057: PPUSH
85058: CALL_OW 1
85062: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
85063: LD_VAR 0 6
85067: PPUSH
85068: LD_INT 0
85070: PPUSH
85071: CALL_OW 109
// ComExitBuilding ( tmp ) ;
85075: LD_VAR 0 6
85079: PPUSH
85080: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
85084: LD_ADDR_EXP 90
85088: PUSH
85089: LD_EXP 90
85093: PPUSH
85094: LD_VAR 0 5
85098: PPUSH
85099: LD_EXP 90
85103: PUSH
85104: LD_VAR 0 5
85108: ARRAY
85109: PPUSH
85110: LD_INT 1
85112: PPUSH
85113: LD_VAR 0 6
85117: PPUSH
85118: CALL_OW 2
85122: PPUSH
85123: CALL_OW 1
85127: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
85128: LD_VAR 0 5
85132: PPUSH
85133: LD_INT 112
85135: PPUSH
85136: CALL 61594 0 2
// end ; end ; end ;
85140: GO 84963
85142: POP
85143: POP
// end ;
85144: LD_VAR 0 3
85148: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
85149: LD_INT 0
85151: PPUSH
85152: PPUSH
85153: PPUSH
85154: PPUSH
85155: PPUSH
85156: PPUSH
85157: PPUSH
85158: PPUSH
// if not mc_bases or not skirmish then
85159: LD_EXP 61
85163: NOT
85164: PUSH
85165: LD_EXP 59
85169: NOT
85170: OR
85171: IFFALSE 85175
// exit ;
85173: GO 86544
// for i = 1 to mc_bases do
85175: LD_ADDR_VAR 0 3
85179: PUSH
85180: DOUBLE
85181: LD_INT 1
85183: DEC
85184: ST_TO_ADDR
85185: LD_EXP 61
85189: PUSH
85190: FOR_TO
85191: IFFALSE 86542
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
85193: LD_VAR 0 1
85197: PUSH
85198: LD_EXP 61
85202: PUSH
85203: LD_VAR 0 3
85207: ARRAY
85208: IN
85209: PUSH
85210: LD_VAR 0 1
85214: PUSH
85215: LD_EXP 68
85219: PUSH
85220: LD_VAR 0 3
85224: ARRAY
85225: IN
85226: OR
85227: PUSH
85228: LD_VAR 0 1
85232: PUSH
85233: LD_EXP 83
85237: PUSH
85238: LD_VAR 0 3
85242: ARRAY
85243: IN
85244: OR
85245: PUSH
85246: LD_VAR 0 1
85250: PUSH
85251: LD_EXP 80
85255: PUSH
85256: LD_VAR 0 3
85260: ARRAY
85261: IN
85262: OR
85263: PUSH
85264: LD_VAR 0 1
85268: PUSH
85269: LD_EXP 90
85273: PUSH
85274: LD_VAR 0 3
85278: ARRAY
85279: IN
85280: OR
85281: PUSH
85282: LD_VAR 0 1
85286: PUSH
85287: LD_EXP 91
85291: PUSH
85292: LD_VAR 0 3
85296: ARRAY
85297: IN
85298: OR
85299: IFFALSE 86540
// begin if un in mc_ape [ i ] then
85301: LD_VAR 0 1
85305: PUSH
85306: LD_EXP 90
85310: PUSH
85311: LD_VAR 0 3
85315: ARRAY
85316: IN
85317: IFFALSE 85356
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
85319: LD_ADDR_EXP 90
85323: PUSH
85324: LD_EXP 90
85328: PPUSH
85329: LD_VAR 0 3
85333: PPUSH
85334: LD_EXP 90
85338: PUSH
85339: LD_VAR 0 3
85343: ARRAY
85344: PUSH
85345: LD_VAR 0 1
85349: DIFF
85350: PPUSH
85351: CALL_OW 1
85355: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
85356: LD_VAR 0 1
85360: PUSH
85361: LD_EXP 91
85365: PUSH
85366: LD_VAR 0 3
85370: ARRAY
85371: IN
85372: IFFALSE 85396
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
85374: LD_ADDR_EXP 91
85378: PUSH
85379: LD_EXP 91
85383: PPUSH
85384: LD_VAR 0 3
85388: PPUSH
85389: EMPTY
85390: PPUSH
85391: CALL_OW 1
85395: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
85396: LD_VAR 0 1
85400: PPUSH
85401: CALL_OW 247
85405: PUSH
85406: LD_INT 2
85408: EQUAL
85409: PUSH
85410: LD_VAR 0 1
85414: PPUSH
85415: CALL_OW 110
85419: PUSH
85420: LD_INT 20
85422: EQUAL
85423: PUSH
85424: LD_VAR 0 1
85428: PUSH
85429: LD_EXP 83
85433: PUSH
85434: LD_VAR 0 3
85438: ARRAY
85439: IN
85440: OR
85441: PUSH
85442: LD_VAR 0 1
85446: PPUSH
85447: CALL_OW 264
85451: PUSH
85452: LD_INT 12
85454: PUSH
85455: LD_INT 51
85457: PUSH
85458: LD_INT 89
85460: PUSH
85461: LD_INT 32
85463: PUSH
85464: LD_INT 13
85466: PUSH
85467: LD_INT 52
85469: PUSH
85470: LD_INT 31
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: IN
85482: OR
85483: AND
85484: IFFALSE 85792
// begin if un in mc_defender [ i ] then
85486: LD_VAR 0 1
85490: PUSH
85491: LD_EXP 83
85495: PUSH
85496: LD_VAR 0 3
85500: ARRAY
85501: IN
85502: IFFALSE 85541
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85504: LD_ADDR_EXP 83
85508: PUSH
85509: LD_EXP 83
85513: PPUSH
85514: LD_VAR 0 3
85518: PPUSH
85519: LD_EXP 83
85523: PUSH
85524: LD_VAR 0 3
85528: ARRAY
85529: PUSH
85530: LD_VAR 0 1
85534: DIFF
85535: PPUSH
85536: CALL_OW 1
85540: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
85541: LD_ADDR_VAR 0 8
85545: PUSH
85546: LD_VAR 0 3
85550: PPUSH
85551: LD_INT 3
85553: PPUSH
85554: CALL 82162 0 2
85558: ST_TO_ADDR
// if fac then
85559: LD_VAR 0 8
85563: IFFALSE 85792
// begin for j in fac do
85565: LD_ADDR_VAR 0 4
85569: PUSH
85570: LD_VAR 0 8
85574: PUSH
85575: FOR_IN
85576: IFFALSE 85790
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
85578: LD_ADDR_VAR 0 9
85582: PUSH
85583: LD_VAR 0 8
85587: PPUSH
85588: LD_VAR 0 1
85592: PPUSH
85593: CALL_OW 265
85597: PPUSH
85598: LD_VAR 0 1
85602: PPUSH
85603: CALL_OW 262
85607: PPUSH
85608: LD_VAR 0 1
85612: PPUSH
85613: CALL_OW 263
85617: PPUSH
85618: LD_VAR 0 1
85622: PPUSH
85623: CALL_OW 264
85627: PPUSH
85628: CALL 17961 0 5
85632: ST_TO_ADDR
// if components then
85633: LD_VAR 0 9
85637: IFFALSE 85788
// begin if GetWeapon ( un ) = ar_control_tower then
85639: LD_VAR 0 1
85643: PPUSH
85644: CALL_OW 264
85648: PUSH
85649: LD_INT 31
85651: EQUAL
85652: IFFALSE 85769
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
85654: LD_VAR 0 1
85658: PPUSH
85659: CALL_OW 311
85663: PPUSH
85664: LD_INT 0
85666: PPUSH
85667: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
85671: LD_ADDR_EXP 101
85675: PUSH
85676: LD_EXP 101
85680: PPUSH
85681: LD_VAR 0 3
85685: PPUSH
85686: LD_EXP 101
85690: PUSH
85691: LD_VAR 0 3
85695: ARRAY
85696: PUSH
85697: LD_VAR 0 1
85701: PPUSH
85702: CALL_OW 311
85706: DIFF
85707: PPUSH
85708: CALL_OW 1
85712: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
85713: LD_ADDR_VAR 0 7
85717: PUSH
85718: LD_EXP 82
85722: PUSH
85723: LD_VAR 0 3
85727: ARRAY
85728: PPUSH
85729: LD_INT 1
85731: PPUSH
85732: LD_VAR 0 9
85736: PPUSH
85737: CALL_OW 2
85741: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
85742: LD_ADDR_EXP 82
85746: PUSH
85747: LD_EXP 82
85751: PPUSH
85752: LD_VAR 0 3
85756: PPUSH
85757: LD_VAR 0 7
85761: PPUSH
85762: CALL_OW 1
85766: ST_TO_ADDR
// end else
85767: GO 85786
// MC_InsertProduceList ( i , [ components ] ) ;
85769: LD_VAR 0 3
85773: PPUSH
85774: LD_VAR 0 9
85778: PUSH
85779: EMPTY
85780: LIST
85781: PPUSH
85782: CALL 81707 0 2
// break ;
85786: GO 85790
// end ; end ;
85788: GO 85575
85790: POP
85791: POP
// end ; end ; if GetType ( un ) = unit_building then
85792: LD_VAR 0 1
85796: PPUSH
85797: CALL_OW 247
85801: PUSH
85802: LD_INT 3
85804: EQUAL
85805: IFFALSE 86208
// begin btype := GetBType ( un ) ;
85807: LD_ADDR_VAR 0 5
85811: PUSH
85812: LD_VAR 0 1
85816: PPUSH
85817: CALL_OW 266
85821: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85822: LD_VAR 0 5
85826: PUSH
85827: LD_INT 29
85829: PUSH
85830: LD_INT 30
85832: PUSH
85833: EMPTY
85834: LIST
85835: LIST
85836: IN
85837: IFFALSE 85910
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85839: LD_VAR 0 1
85843: PPUSH
85844: CALL_OW 250
85848: PPUSH
85849: LD_VAR 0 1
85853: PPUSH
85854: CALL_OW 251
85858: PPUSH
85859: LD_VAR 0 1
85863: PPUSH
85864: CALL_OW 255
85868: PPUSH
85869: CALL_OW 440
85873: NOT
85874: IFFALSE 85910
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85876: LD_VAR 0 1
85880: PPUSH
85881: CALL_OW 250
85885: PPUSH
85886: LD_VAR 0 1
85890: PPUSH
85891: CALL_OW 251
85895: PPUSH
85896: LD_VAR 0 1
85900: PPUSH
85901: CALL_OW 255
85905: PPUSH
85906: CALL_OW 441
// end ; if btype = b_warehouse then
85910: LD_VAR 0 5
85914: PUSH
85915: LD_INT 1
85917: EQUAL
85918: IFFALSE 85936
// begin btype := b_depot ;
85920: LD_ADDR_VAR 0 5
85924: PUSH
85925: LD_INT 0
85927: ST_TO_ADDR
// pos := 1 ;
85928: LD_ADDR_VAR 0 6
85932: PUSH
85933: LD_INT 1
85935: ST_TO_ADDR
// end ; if btype = b_factory then
85936: LD_VAR 0 5
85940: PUSH
85941: LD_INT 3
85943: EQUAL
85944: IFFALSE 85962
// begin btype := b_workshop ;
85946: LD_ADDR_VAR 0 5
85950: PUSH
85951: LD_INT 2
85953: ST_TO_ADDR
// pos := 1 ;
85954: LD_ADDR_VAR 0 6
85958: PUSH
85959: LD_INT 1
85961: ST_TO_ADDR
// end ; if btype = b_barracks then
85962: LD_VAR 0 5
85966: PUSH
85967: LD_INT 5
85969: EQUAL
85970: IFFALSE 85980
// btype := b_armoury ;
85972: LD_ADDR_VAR 0 5
85976: PUSH
85977: LD_INT 4
85979: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85980: LD_VAR 0 5
85984: PUSH
85985: LD_INT 7
85987: PUSH
85988: LD_INT 8
85990: PUSH
85991: EMPTY
85992: LIST
85993: LIST
85994: IN
85995: IFFALSE 86005
// btype := b_lab ;
85997: LD_ADDR_VAR 0 5
86001: PUSH
86002: LD_INT 6
86004: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
86005: LD_ADDR_EXP 66
86009: PUSH
86010: LD_EXP 66
86014: PPUSH
86015: LD_VAR 0 3
86019: PUSH
86020: LD_EXP 66
86024: PUSH
86025: LD_VAR 0 3
86029: ARRAY
86030: PUSH
86031: LD_INT 1
86033: PLUS
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PPUSH
86039: LD_VAR 0 5
86043: PUSH
86044: LD_VAR 0 1
86048: PPUSH
86049: CALL_OW 250
86053: PUSH
86054: LD_VAR 0 1
86058: PPUSH
86059: CALL_OW 251
86063: PUSH
86064: LD_VAR 0 1
86068: PPUSH
86069: CALL_OW 254
86073: PUSH
86074: EMPTY
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: PPUSH
86080: CALL 20463 0 3
86084: ST_TO_ADDR
// if pos = 1 then
86085: LD_VAR 0 6
86089: PUSH
86090: LD_INT 1
86092: EQUAL
86093: IFFALSE 86208
// begin tmp := mc_build_list [ i ] ;
86095: LD_ADDR_VAR 0 7
86099: PUSH
86100: LD_EXP 66
86104: PUSH
86105: LD_VAR 0 3
86109: ARRAY
86110: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
86111: LD_VAR 0 7
86115: PPUSH
86116: LD_INT 2
86118: PUSH
86119: LD_INT 30
86121: PUSH
86122: LD_INT 0
86124: PUSH
86125: EMPTY
86126: LIST
86127: LIST
86128: PUSH
86129: LD_INT 30
86131: PUSH
86132: LD_INT 1
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: LIST
86143: PPUSH
86144: CALL_OW 72
86148: IFFALSE 86158
// pos := 2 ;
86150: LD_ADDR_VAR 0 6
86154: PUSH
86155: LD_INT 2
86157: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
86158: LD_ADDR_VAR 0 7
86162: PUSH
86163: LD_VAR 0 7
86167: PPUSH
86168: LD_VAR 0 6
86172: PPUSH
86173: LD_VAR 0 7
86177: PPUSH
86178: CALL 20789 0 3
86182: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
86183: LD_ADDR_EXP 66
86187: PUSH
86188: LD_EXP 66
86192: PPUSH
86193: LD_VAR 0 3
86197: PPUSH
86198: LD_VAR 0 7
86202: PPUSH
86203: CALL_OW 1
86207: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
86208: LD_VAR 0 1
86212: PUSH
86213: LD_EXP 61
86217: PUSH
86218: LD_VAR 0 3
86222: ARRAY
86223: IN
86224: IFFALSE 86263
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
86226: LD_ADDR_EXP 61
86230: PUSH
86231: LD_EXP 61
86235: PPUSH
86236: LD_VAR 0 3
86240: PPUSH
86241: LD_EXP 61
86245: PUSH
86246: LD_VAR 0 3
86250: ARRAY
86251: PUSH
86252: LD_VAR 0 1
86256: DIFF
86257: PPUSH
86258: CALL_OW 1
86262: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
86263: LD_VAR 0 1
86267: PUSH
86268: LD_EXP 68
86272: PUSH
86273: LD_VAR 0 3
86277: ARRAY
86278: IN
86279: IFFALSE 86318
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
86281: LD_ADDR_EXP 68
86285: PUSH
86286: LD_EXP 68
86290: PPUSH
86291: LD_VAR 0 3
86295: PPUSH
86296: LD_EXP 68
86300: PUSH
86301: LD_VAR 0 3
86305: ARRAY
86306: PUSH
86307: LD_VAR 0 1
86311: DIFF
86312: PPUSH
86313: CALL_OW 1
86317: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
86318: LD_VAR 0 1
86322: PUSH
86323: LD_EXP 80
86327: PUSH
86328: LD_VAR 0 3
86332: ARRAY
86333: IN
86334: IFFALSE 86373
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
86336: LD_ADDR_EXP 80
86340: PUSH
86341: LD_EXP 80
86345: PPUSH
86346: LD_VAR 0 3
86350: PPUSH
86351: LD_EXP 80
86355: PUSH
86356: LD_VAR 0 3
86360: ARRAY
86361: PUSH
86362: LD_VAR 0 1
86366: DIFF
86367: PPUSH
86368: CALL_OW 1
86372: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
86373: LD_VAR 0 1
86377: PUSH
86378: LD_EXP 83
86382: PUSH
86383: LD_VAR 0 3
86387: ARRAY
86388: IN
86389: IFFALSE 86428
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
86391: LD_ADDR_EXP 83
86395: PUSH
86396: LD_EXP 83
86400: PPUSH
86401: LD_VAR 0 3
86405: PPUSH
86406: LD_EXP 83
86410: PUSH
86411: LD_VAR 0 3
86415: ARRAY
86416: PUSH
86417: LD_VAR 0 1
86421: DIFF
86422: PPUSH
86423: CALL_OW 1
86427: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
86428: LD_VAR 0 1
86432: PUSH
86433: LD_EXP 70
86437: PUSH
86438: LD_VAR 0 3
86442: ARRAY
86443: IN
86444: IFFALSE 86483
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
86446: LD_ADDR_EXP 70
86450: PUSH
86451: LD_EXP 70
86455: PPUSH
86456: LD_VAR 0 3
86460: PPUSH
86461: LD_EXP 70
86465: PUSH
86466: LD_VAR 0 3
86470: ARRAY
86471: PUSH
86472: LD_VAR 0 1
86476: DIFF
86477: PPUSH
86478: CALL_OW 1
86482: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
86483: LD_VAR 0 1
86487: PUSH
86488: LD_EXP 69
86492: PUSH
86493: LD_VAR 0 3
86497: ARRAY
86498: IN
86499: IFFALSE 86538
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
86501: LD_ADDR_EXP 69
86505: PUSH
86506: LD_EXP 69
86510: PPUSH
86511: LD_VAR 0 3
86515: PPUSH
86516: LD_EXP 69
86520: PUSH
86521: LD_VAR 0 3
86525: ARRAY
86526: PUSH
86527: LD_VAR 0 1
86531: DIFF
86532: PPUSH
86533: CALL_OW 1
86537: ST_TO_ADDR
// end ; break ;
86538: GO 86542
// end ;
86540: GO 85190
86542: POP
86543: POP
// end ;
86544: LD_VAR 0 2
86548: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
86549: LD_INT 0
86551: PPUSH
86552: PPUSH
86553: PPUSH
// if not mc_bases or not skirmish then
86554: LD_EXP 61
86558: NOT
86559: PUSH
86560: LD_EXP 59
86564: NOT
86565: OR
86566: IFFALSE 86570
// exit ;
86568: GO 86785
// for i = 1 to mc_bases do
86570: LD_ADDR_VAR 0 3
86574: PUSH
86575: DOUBLE
86576: LD_INT 1
86578: DEC
86579: ST_TO_ADDR
86580: LD_EXP 61
86584: PUSH
86585: FOR_TO
86586: IFFALSE 86783
// begin if building in mc_construct_list [ i ] then
86588: LD_VAR 0 1
86592: PUSH
86593: LD_EXP 68
86597: PUSH
86598: LD_VAR 0 3
86602: ARRAY
86603: IN
86604: IFFALSE 86781
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86606: LD_ADDR_EXP 68
86610: PUSH
86611: LD_EXP 68
86615: PPUSH
86616: LD_VAR 0 3
86620: PPUSH
86621: LD_EXP 68
86625: PUSH
86626: LD_VAR 0 3
86630: ARRAY
86631: PUSH
86632: LD_VAR 0 1
86636: DIFF
86637: PPUSH
86638: CALL_OW 1
86642: ST_TO_ADDR
// if building in mc_lab [ i ] then
86643: LD_VAR 0 1
86647: PUSH
86648: LD_EXP 94
86652: PUSH
86653: LD_VAR 0 3
86657: ARRAY
86658: IN
86659: IFFALSE 86714
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
86661: LD_ADDR_EXP 95
86665: PUSH
86666: LD_EXP 95
86670: PPUSH
86671: LD_VAR 0 3
86675: PPUSH
86676: LD_EXP 95
86680: PUSH
86681: LD_VAR 0 3
86685: ARRAY
86686: PPUSH
86687: LD_INT 1
86689: PPUSH
86690: LD_EXP 95
86694: PUSH
86695: LD_VAR 0 3
86699: ARRAY
86700: PPUSH
86701: LD_INT 0
86703: PPUSH
86704: CALL 19881 0 4
86708: PPUSH
86709: CALL_OW 1
86713: ST_TO_ADDR
// if not building in mc_bases [ i ] then
86714: LD_VAR 0 1
86718: PUSH
86719: LD_EXP 61
86723: PUSH
86724: LD_VAR 0 3
86728: ARRAY
86729: IN
86730: NOT
86731: IFFALSE 86777
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86733: LD_ADDR_EXP 61
86737: PUSH
86738: LD_EXP 61
86742: PPUSH
86743: LD_VAR 0 3
86747: PUSH
86748: LD_EXP 61
86752: PUSH
86753: LD_VAR 0 3
86757: ARRAY
86758: PUSH
86759: LD_INT 1
86761: PLUS
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PPUSH
86767: LD_VAR 0 1
86771: PPUSH
86772: CALL 20463 0 3
86776: ST_TO_ADDR
// exit ;
86777: POP
86778: POP
86779: GO 86785
// end ; end ;
86781: GO 86585
86783: POP
86784: POP
// end ;
86785: LD_VAR 0 2
86789: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86790: LD_INT 0
86792: PPUSH
86793: PPUSH
86794: PPUSH
86795: PPUSH
86796: PPUSH
86797: PPUSH
86798: PPUSH
// if not mc_bases or not skirmish then
86799: LD_EXP 61
86803: NOT
86804: PUSH
86805: LD_EXP 59
86809: NOT
86810: OR
86811: IFFALSE 86815
// exit ;
86813: GO 87476
// for i = 1 to mc_bases do
86815: LD_ADDR_VAR 0 3
86819: PUSH
86820: DOUBLE
86821: LD_INT 1
86823: DEC
86824: ST_TO_ADDR
86825: LD_EXP 61
86829: PUSH
86830: FOR_TO
86831: IFFALSE 87474
// begin if building in mc_construct_list [ i ] then
86833: LD_VAR 0 1
86837: PUSH
86838: LD_EXP 68
86842: PUSH
86843: LD_VAR 0 3
86847: ARRAY
86848: IN
86849: IFFALSE 87472
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86851: LD_ADDR_EXP 68
86855: PUSH
86856: LD_EXP 68
86860: PPUSH
86861: LD_VAR 0 3
86865: PPUSH
86866: LD_EXP 68
86870: PUSH
86871: LD_VAR 0 3
86875: ARRAY
86876: PUSH
86877: LD_VAR 0 1
86881: DIFF
86882: PPUSH
86883: CALL_OW 1
86887: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86888: LD_ADDR_EXP 61
86892: PUSH
86893: LD_EXP 61
86897: PPUSH
86898: LD_VAR 0 3
86902: PUSH
86903: LD_EXP 61
86907: PUSH
86908: LD_VAR 0 3
86912: ARRAY
86913: PUSH
86914: LD_INT 1
86916: PLUS
86917: PUSH
86918: EMPTY
86919: LIST
86920: LIST
86921: PPUSH
86922: LD_VAR 0 1
86926: PPUSH
86927: CALL 20463 0 3
86931: ST_TO_ADDR
// btype := GetBType ( building ) ;
86932: LD_ADDR_VAR 0 5
86936: PUSH
86937: LD_VAR 0 1
86941: PPUSH
86942: CALL_OW 266
86946: ST_TO_ADDR
// side := GetSide ( building ) ;
86947: LD_ADDR_VAR 0 8
86951: PUSH
86952: LD_VAR 0 1
86956: PPUSH
86957: CALL_OW 255
86961: ST_TO_ADDR
// if btype = b_lab then
86962: LD_VAR 0 5
86966: PUSH
86967: LD_INT 6
86969: EQUAL
86970: IFFALSE 87020
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86972: LD_ADDR_EXP 94
86976: PUSH
86977: LD_EXP 94
86981: PPUSH
86982: LD_VAR 0 3
86986: PUSH
86987: LD_EXP 94
86991: PUSH
86992: LD_VAR 0 3
86996: ARRAY
86997: PUSH
86998: LD_INT 1
87000: PLUS
87001: PUSH
87002: EMPTY
87003: LIST
87004: LIST
87005: PPUSH
87006: LD_VAR 0 1
87010: PPUSH
87011: CALL 20463 0 3
87015: ST_TO_ADDR
// exit ;
87016: POP
87017: POP
87018: GO 87476
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
87020: LD_VAR 0 5
87024: PUSH
87025: LD_INT 0
87027: PUSH
87028: LD_INT 2
87030: PUSH
87031: LD_INT 4
87033: PUSH
87034: EMPTY
87035: LIST
87036: LIST
87037: LIST
87038: IN
87039: IFFALSE 87163
// begin if btype = b_armoury then
87041: LD_VAR 0 5
87045: PUSH
87046: LD_INT 4
87048: EQUAL
87049: IFFALSE 87059
// btype := b_barracks ;
87051: LD_ADDR_VAR 0 5
87055: PUSH
87056: LD_INT 5
87058: ST_TO_ADDR
// if btype = b_depot then
87059: LD_VAR 0 5
87063: PUSH
87064: LD_INT 0
87066: EQUAL
87067: IFFALSE 87077
// btype := b_warehouse ;
87069: LD_ADDR_VAR 0 5
87073: PUSH
87074: LD_INT 1
87076: ST_TO_ADDR
// if btype = b_workshop then
87077: LD_VAR 0 5
87081: PUSH
87082: LD_INT 2
87084: EQUAL
87085: IFFALSE 87095
// btype := b_factory ;
87087: LD_ADDR_VAR 0 5
87091: PUSH
87092: LD_INT 3
87094: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
87095: LD_VAR 0 5
87099: PPUSH
87100: LD_VAR 0 8
87104: PPUSH
87105: CALL_OW 323
87109: PUSH
87110: LD_INT 1
87112: EQUAL
87113: IFFALSE 87159
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
87115: LD_ADDR_EXP 93
87119: PUSH
87120: LD_EXP 93
87124: PPUSH
87125: LD_VAR 0 3
87129: PUSH
87130: LD_EXP 93
87134: PUSH
87135: LD_VAR 0 3
87139: ARRAY
87140: PUSH
87141: LD_INT 1
87143: PLUS
87144: PUSH
87145: EMPTY
87146: LIST
87147: LIST
87148: PPUSH
87149: LD_VAR 0 1
87153: PPUSH
87154: CALL 20463 0 3
87158: ST_TO_ADDR
// exit ;
87159: POP
87160: POP
87161: GO 87476
// end ; if btype in [ b_bunker , b_turret ] then
87163: LD_VAR 0 5
87167: PUSH
87168: LD_INT 32
87170: PUSH
87171: LD_INT 33
87173: PUSH
87174: EMPTY
87175: LIST
87176: LIST
87177: IN
87178: IFFALSE 87468
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
87180: LD_ADDR_EXP 69
87184: PUSH
87185: LD_EXP 69
87189: PPUSH
87190: LD_VAR 0 3
87194: PUSH
87195: LD_EXP 69
87199: PUSH
87200: LD_VAR 0 3
87204: ARRAY
87205: PUSH
87206: LD_INT 1
87208: PLUS
87209: PUSH
87210: EMPTY
87211: LIST
87212: LIST
87213: PPUSH
87214: LD_VAR 0 1
87218: PPUSH
87219: CALL 20463 0 3
87223: ST_TO_ADDR
// if btype = b_bunker then
87224: LD_VAR 0 5
87228: PUSH
87229: LD_INT 32
87231: EQUAL
87232: IFFALSE 87468
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87234: LD_ADDR_EXP 70
87238: PUSH
87239: LD_EXP 70
87243: PPUSH
87244: LD_VAR 0 3
87248: PUSH
87249: LD_EXP 70
87253: PUSH
87254: LD_VAR 0 3
87258: ARRAY
87259: PUSH
87260: LD_INT 1
87262: PLUS
87263: PUSH
87264: EMPTY
87265: LIST
87266: LIST
87267: PPUSH
87268: LD_VAR 0 1
87272: PPUSH
87273: CALL 20463 0 3
87277: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
87278: LD_ADDR_VAR 0 6
87282: PUSH
87283: LD_EXP 61
87287: PUSH
87288: LD_VAR 0 3
87292: ARRAY
87293: PPUSH
87294: LD_INT 25
87296: PUSH
87297: LD_INT 1
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 3
87306: PUSH
87307: LD_INT 54
87309: PUSH
87310: EMPTY
87311: LIST
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PUSH
87317: EMPTY
87318: LIST
87319: LIST
87320: PPUSH
87321: CALL_OW 72
87325: ST_TO_ADDR
// if tmp then
87326: LD_VAR 0 6
87330: IFFALSE 87336
// exit ;
87332: POP
87333: POP
87334: GO 87476
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
87336: LD_ADDR_VAR 0 6
87340: PUSH
87341: LD_EXP 61
87345: PUSH
87346: LD_VAR 0 3
87350: ARRAY
87351: PPUSH
87352: LD_INT 2
87354: PUSH
87355: LD_INT 30
87357: PUSH
87358: LD_INT 4
87360: PUSH
87361: EMPTY
87362: LIST
87363: LIST
87364: PUSH
87365: LD_INT 30
87367: PUSH
87368: LD_INT 5
87370: PUSH
87371: EMPTY
87372: LIST
87373: LIST
87374: PUSH
87375: EMPTY
87376: LIST
87377: LIST
87378: LIST
87379: PPUSH
87380: CALL_OW 72
87384: ST_TO_ADDR
// if not tmp then
87385: LD_VAR 0 6
87389: NOT
87390: IFFALSE 87396
// exit ;
87392: POP
87393: POP
87394: GO 87476
// for j in tmp do
87396: LD_ADDR_VAR 0 4
87400: PUSH
87401: LD_VAR 0 6
87405: PUSH
87406: FOR_IN
87407: IFFALSE 87466
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
87409: LD_ADDR_VAR 0 7
87413: PUSH
87414: LD_VAR 0 4
87418: PPUSH
87419: CALL_OW 313
87423: PPUSH
87424: LD_INT 25
87426: PUSH
87427: LD_INT 1
87429: PUSH
87430: EMPTY
87431: LIST
87432: LIST
87433: PPUSH
87434: CALL_OW 72
87438: ST_TO_ADDR
// if units then
87439: LD_VAR 0 7
87443: IFFALSE 87464
// begin ComExitBuilding ( units [ 1 ] ) ;
87445: LD_VAR 0 7
87449: PUSH
87450: LD_INT 1
87452: ARRAY
87453: PPUSH
87454: CALL_OW 122
// exit ;
87458: POP
87459: POP
87460: POP
87461: POP
87462: GO 87476
// end ; end ;
87464: GO 87406
87466: POP
87467: POP
// end ; end ; exit ;
87468: POP
87469: POP
87470: GO 87476
// end ; end ;
87472: GO 86830
87474: POP
87475: POP
// end ;
87476: LD_VAR 0 2
87480: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
87481: LD_INT 0
87483: PPUSH
87484: PPUSH
87485: PPUSH
87486: PPUSH
87487: PPUSH
87488: PPUSH
87489: PPUSH
// if not mc_bases or not skirmish then
87490: LD_EXP 61
87494: NOT
87495: PUSH
87496: LD_EXP 59
87500: NOT
87501: OR
87502: IFFALSE 87506
// exit ;
87504: GO 87771
// btype := GetBType ( building ) ;
87506: LD_ADDR_VAR 0 6
87510: PUSH
87511: LD_VAR 0 1
87515: PPUSH
87516: CALL_OW 266
87520: ST_TO_ADDR
// x := GetX ( building ) ;
87521: LD_ADDR_VAR 0 7
87525: PUSH
87526: LD_VAR 0 1
87530: PPUSH
87531: CALL_OW 250
87535: ST_TO_ADDR
// y := GetY ( building ) ;
87536: LD_ADDR_VAR 0 8
87540: PUSH
87541: LD_VAR 0 1
87545: PPUSH
87546: CALL_OW 251
87550: ST_TO_ADDR
// d := GetDir ( building ) ;
87551: LD_ADDR_VAR 0 9
87555: PUSH
87556: LD_VAR 0 1
87560: PPUSH
87561: CALL_OW 254
87565: ST_TO_ADDR
// for i = 1 to mc_bases do
87566: LD_ADDR_VAR 0 4
87570: PUSH
87571: DOUBLE
87572: LD_INT 1
87574: DEC
87575: ST_TO_ADDR
87576: LD_EXP 61
87580: PUSH
87581: FOR_TO
87582: IFFALSE 87769
// begin if not mc_build_list [ i ] then
87584: LD_EXP 66
87588: PUSH
87589: LD_VAR 0 4
87593: ARRAY
87594: NOT
87595: IFFALSE 87599
// continue ;
87597: GO 87581
// for j := 1 to mc_build_list [ i ] do
87599: LD_ADDR_VAR 0 5
87603: PUSH
87604: DOUBLE
87605: LD_INT 1
87607: DEC
87608: ST_TO_ADDR
87609: LD_EXP 66
87613: PUSH
87614: LD_VAR 0 4
87618: ARRAY
87619: PUSH
87620: FOR_TO
87621: IFFALSE 87765
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
87623: LD_VAR 0 6
87627: PUSH
87628: LD_VAR 0 7
87632: PUSH
87633: LD_VAR 0 8
87637: PUSH
87638: LD_VAR 0 9
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: LIST
87647: LIST
87648: PPUSH
87649: LD_EXP 66
87653: PUSH
87654: LD_VAR 0 4
87658: ARRAY
87659: PUSH
87660: LD_VAR 0 5
87664: ARRAY
87665: PPUSH
87666: CALL 27020 0 2
87670: IFFALSE 87763
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
87672: LD_ADDR_EXP 66
87676: PUSH
87677: LD_EXP 66
87681: PPUSH
87682: LD_VAR 0 4
87686: PPUSH
87687: LD_EXP 66
87691: PUSH
87692: LD_VAR 0 4
87696: ARRAY
87697: PPUSH
87698: LD_VAR 0 5
87702: PPUSH
87703: CALL_OW 3
87707: PPUSH
87708: CALL_OW 1
87712: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
87713: LD_ADDR_EXP 68
87717: PUSH
87718: LD_EXP 68
87722: PPUSH
87723: LD_VAR 0 4
87727: PUSH
87728: LD_EXP 68
87732: PUSH
87733: LD_VAR 0 4
87737: ARRAY
87738: PUSH
87739: LD_INT 1
87741: PLUS
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: PPUSH
87747: LD_VAR 0 1
87751: PPUSH
87752: CALL 20463 0 3
87756: ST_TO_ADDR
// exit ;
87757: POP
87758: POP
87759: POP
87760: POP
87761: GO 87771
// end ;
87763: GO 87620
87765: POP
87766: POP
// end ;
87767: GO 87581
87769: POP
87770: POP
// end ;
87771: LD_VAR 0 3
87775: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
87776: LD_INT 0
87778: PPUSH
87779: PPUSH
87780: PPUSH
// if not mc_bases or not skirmish then
87781: LD_EXP 61
87785: NOT
87786: PUSH
87787: LD_EXP 59
87791: NOT
87792: OR
87793: IFFALSE 87797
// exit ;
87795: GO 87987
// for i = 1 to mc_bases do
87797: LD_ADDR_VAR 0 4
87801: PUSH
87802: DOUBLE
87803: LD_INT 1
87805: DEC
87806: ST_TO_ADDR
87807: LD_EXP 61
87811: PUSH
87812: FOR_TO
87813: IFFALSE 87900
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87815: LD_VAR 0 1
87819: PUSH
87820: LD_EXP 69
87824: PUSH
87825: LD_VAR 0 4
87829: ARRAY
87830: IN
87831: PUSH
87832: LD_VAR 0 1
87836: PUSH
87837: LD_EXP 70
87841: PUSH
87842: LD_VAR 0 4
87846: ARRAY
87847: IN
87848: NOT
87849: AND
87850: IFFALSE 87898
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87852: LD_ADDR_EXP 70
87856: PUSH
87857: LD_EXP 70
87861: PPUSH
87862: LD_VAR 0 4
87866: PUSH
87867: LD_EXP 70
87871: PUSH
87872: LD_VAR 0 4
87876: ARRAY
87877: PUSH
87878: LD_INT 1
87880: PLUS
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PPUSH
87886: LD_VAR 0 1
87890: PPUSH
87891: CALL 20463 0 3
87895: ST_TO_ADDR
// break ;
87896: GO 87900
// end ; end ;
87898: GO 87812
87900: POP
87901: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87902: LD_VAR 0 1
87906: PPUSH
87907: CALL_OW 257
87911: PUSH
87912: LD_EXP 87
87916: IN
87917: PUSH
87918: LD_VAR 0 1
87922: PPUSH
87923: CALL_OW 266
87927: PUSH
87928: LD_INT 5
87930: EQUAL
87931: AND
87932: PUSH
87933: LD_VAR 0 2
87937: PPUSH
87938: CALL_OW 110
87942: PUSH
87943: LD_INT 18
87945: NONEQUAL
87946: AND
87947: IFFALSE 87987
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87949: LD_VAR 0 2
87953: PPUSH
87954: CALL_OW 257
87958: PUSH
87959: LD_INT 5
87961: PUSH
87962: LD_INT 8
87964: PUSH
87965: LD_INT 9
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: LIST
87972: IN
87973: IFFALSE 87987
// SetClass ( unit , 1 ) ;
87975: LD_VAR 0 2
87979: PPUSH
87980: LD_INT 1
87982: PPUSH
87983: CALL_OW 336
// end ;
87987: LD_VAR 0 3
87991: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87992: LD_INT 0
87994: PPUSH
87995: PPUSH
// if not mc_bases or not skirmish then
87996: LD_EXP 61
88000: NOT
88001: PUSH
88002: LD_EXP 59
88006: NOT
88007: OR
88008: IFFALSE 88012
// exit ;
88010: GO 88128
// if GetLives ( abandoned_vehicle ) > 250 then
88012: LD_VAR 0 2
88016: PPUSH
88017: CALL_OW 256
88021: PUSH
88022: LD_INT 250
88024: GREATER
88025: IFFALSE 88029
// exit ;
88027: GO 88128
// for i = 1 to mc_bases do
88029: LD_ADDR_VAR 0 6
88033: PUSH
88034: DOUBLE
88035: LD_INT 1
88037: DEC
88038: ST_TO_ADDR
88039: LD_EXP 61
88043: PUSH
88044: FOR_TO
88045: IFFALSE 88126
// begin if driver in mc_bases [ i ] then
88047: LD_VAR 0 1
88051: PUSH
88052: LD_EXP 61
88056: PUSH
88057: LD_VAR 0 6
88061: ARRAY
88062: IN
88063: IFFALSE 88124
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
88065: LD_VAR 0 1
88069: PPUSH
88070: LD_EXP 61
88074: PUSH
88075: LD_VAR 0 6
88079: ARRAY
88080: PPUSH
88081: LD_INT 2
88083: PUSH
88084: LD_INT 30
88086: PUSH
88087: LD_INT 0
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: PUSH
88094: LD_INT 30
88096: PUSH
88097: LD_INT 1
88099: PUSH
88100: EMPTY
88101: LIST
88102: LIST
88103: PUSH
88104: EMPTY
88105: LIST
88106: LIST
88107: LIST
88108: PPUSH
88109: CALL_OW 72
88113: PUSH
88114: LD_INT 1
88116: ARRAY
88117: PPUSH
88118: CALL 54080 0 2
// break ;
88122: GO 88126
// end ; end ;
88124: GO 88044
88126: POP
88127: POP
// end ; end_of_file end_of_file
88128: LD_VAR 0 5
88132: RET
// export globalGameSaveCounter ; every 0 0$1 do
88133: GO 88135
88135: DISABLE
// begin enable ;
88136: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
88137: LD_STRING updateTimer(
88139: PUSH
88140: LD_OWVAR 1
88144: STR
88145: PUSH
88146: LD_STRING );
88148: STR
88149: PPUSH
88150: CALL_OW 559
// end ;
88154: END
// every 0 0$1 do
88155: GO 88157
88157: DISABLE
// begin globalGameSaveCounter := 0 ;
88158: LD_ADDR_EXP 106
88162: PUSH
88163: LD_INT 0
88165: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
88166: LD_STRING setGameSaveCounter(0)
88168: PPUSH
88169: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
88173: LD_STRING initStreamRollete();
88175: PPUSH
88176: CALL_OW 559
// InitStreamMode ;
88180: CALL 89506 0 0
// DefineStreamItems ( false ) ;
88184: LD_INT 0
88186: PPUSH
88187: CALL 89970 0 1
// end ;
88191: END
// export function SOS_MapStart ( ) ; begin
88192: LD_INT 0
88194: PPUSH
// if streamModeActive then
88195: LD_EXP 107
88199: IFFALSE 88208
// DefineStreamItems ( true ) ;
88201: LD_INT 1
88203: PPUSH
88204: CALL 89970 0 1
// UpdateLuaVariables ( ) ;
88208: CALL 88225 0 0
// UpdateFactoryWaypoints ( ) ;
88212: CALL 102839 0 0
// UpdateWarehouseGatheringPoints ( ) ;
88216: CALL 103096 0 0
// end ;
88220: LD_VAR 0 1
88224: RET
// function UpdateLuaVariables ( ) ; begin
88225: LD_INT 0
88227: PPUSH
// if globalGameSaveCounter then
88228: LD_EXP 106
88232: IFFALSE 88266
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
88234: LD_ADDR_EXP 106
88238: PUSH
88239: LD_EXP 106
88243: PPUSH
88244: CALL 54564 0 1
88248: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
88249: LD_STRING setGameSaveCounter(
88251: PUSH
88252: LD_EXP 106
88256: STR
88257: PUSH
88258: LD_STRING )
88260: STR
88261: PPUSH
88262: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
88266: LD_STRING setGameDifficulty(
88268: PUSH
88269: LD_OWVAR 67
88273: STR
88274: PUSH
88275: LD_STRING )
88277: STR
88278: PPUSH
88279: CALL_OW 559
// end ;
88283: LD_VAR 0 1
88287: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
88288: LD_INT 0
88290: PPUSH
// if p2 = stream_mode then
88291: LD_VAR 0 2
88295: PUSH
88296: LD_INT 100
88298: EQUAL
88299: IFFALSE 89302
// begin if not StreamModeActive then
88301: LD_EXP 107
88305: NOT
88306: IFFALSE 88316
// StreamModeActive := true ;
88308: LD_ADDR_EXP 107
88312: PUSH
88313: LD_INT 1
88315: ST_TO_ADDR
// if p3 = 0 then
88316: LD_VAR 0 3
88320: PUSH
88321: LD_INT 0
88323: EQUAL
88324: IFFALSE 88330
// InitStreamMode ;
88326: CALL 89506 0 0
// if p3 = 1 then
88330: LD_VAR 0 3
88334: PUSH
88335: LD_INT 1
88337: EQUAL
88338: IFFALSE 88348
// sRocket := true ;
88340: LD_ADDR_EXP 112
88344: PUSH
88345: LD_INT 1
88347: ST_TO_ADDR
// if p3 = 2 then
88348: LD_VAR 0 3
88352: PUSH
88353: LD_INT 2
88355: EQUAL
88356: IFFALSE 88366
// sSpeed := true ;
88358: LD_ADDR_EXP 111
88362: PUSH
88363: LD_INT 1
88365: ST_TO_ADDR
// if p3 = 3 then
88366: LD_VAR 0 3
88370: PUSH
88371: LD_INT 3
88373: EQUAL
88374: IFFALSE 88384
// sEngine := true ;
88376: LD_ADDR_EXP 113
88380: PUSH
88381: LD_INT 1
88383: ST_TO_ADDR
// if p3 = 4 then
88384: LD_VAR 0 3
88388: PUSH
88389: LD_INT 4
88391: EQUAL
88392: IFFALSE 88402
// sSpec := true ;
88394: LD_ADDR_EXP 110
88398: PUSH
88399: LD_INT 1
88401: ST_TO_ADDR
// if p3 = 5 then
88402: LD_VAR 0 3
88406: PUSH
88407: LD_INT 5
88409: EQUAL
88410: IFFALSE 88420
// sLevel := true ;
88412: LD_ADDR_EXP 114
88416: PUSH
88417: LD_INT 1
88419: ST_TO_ADDR
// if p3 = 6 then
88420: LD_VAR 0 3
88424: PUSH
88425: LD_INT 6
88427: EQUAL
88428: IFFALSE 88438
// sArmoury := true ;
88430: LD_ADDR_EXP 115
88434: PUSH
88435: LD_INT 1
88437: ST_TO_ADDR
// if p3 = 7 then
88438: LD_VAR 0 3
88442: PUSH
88443: LD_INT 7
88445: EQUAL
88446: IFFALSE 88456
// sRadar := true ;
88448: LD_ADDR_EXP 116
88452: PUSH
88453: LD_INT 1
88455: ST_TO_ADDR
// if p3 = 8 then
88456: LD_VAR 0 3
88460: PUSH
88461: LD_INT 8
88463: EQUAL
88464: IFFALSE 88474
// sBunker := true ;
88466: LD_ADDR_EXP 117
88470: PUSH
88471: LD_INT 1
88473: ST_TO_ADDR
// if p3 = 9 then
88474: LD_VAR 0 3
88478: PUSH
88479: LD_INT 9
88481: EQUAL
88482: IFFALSE 88492
// sHack := true ;
88484: LD_ADDR_EXP 118
88488: PUSH
88489: LD_INT 1
88491: ST_TO_ADDR
// if p3 = 10 then
88492: LD_VAR 0 3
88496: PUSH
88497: LD_INT 10
88499: EQUAL
88500: IFFALSE 88510
// sFire := true ;
88502: LD_ADDR_EXP 119
88506: PUSH
88507: LD_INT 1
88509: ST_TO_ADDR
// if p3 = 11 then
88510: LD_VAR 0 3
88514: PUSH
88515: LD_INT 11
88517: EQUAL
88518: IFFALSE 88528
// sRefresh := true ;
88520: LD_ADDR_EXP 120
88524: PUSH
88525: LD_INT 1
88527: ST_TO_ADDR
// if p3 = 12 then
88528: LD_VAR 0 3
88532: PUSH
88533: LD_INT 12
88535: EQUAL
88536: IFFALSE 88546
// sExp := true ;
88538: LD_ADDR_EXP 121
88542: PUSH
88543: LD_INT 1
88545: ST_TO_ADDR
// if p3 = 13 then
88546: LD_VAR 0 3
88550: PUSH
88551: LD_INT 13
88553: EQUAL
88554: IFFALSE 88564
// sDepot := true ;
88556: LD_ADDR_EXP 122
88560: PUSH
88561: LD_INT 1
88563: ST_TO_ADDR
// if p3 = 14 then
88564: LD_VAR 0 3
88568: PUSH
88569: LD_INT 14
88571: EQUAL
88572: IFFALSE 88582
// sFlag := true ;
88574: LD_ADDR_EXP 123
88578: PUSH
88579: LD_INT 1
88581: ST_TO_ADDR
// if p3 = 15 then
88582: LD_VAR 0 3
88586: PUSH
88587: LD_INT 15
88589: EQUAL
88590: IFFALSE 88600
// sKamikadze := true ;
88592: LD_ADDR_EXP 131
88596: PUSH
88597: LD_INT 1
88599: ST_TO_ADDR
// if p3 = 16 then
88600: LD_VAR 0 3
88604: PUSH
88605: LD_INT 16
88607: EQUAL
88608: IFFALSE 88618
// sTroll := true ;
88610: LD_ADDR_EXP 132
88614: PUSH
88615: LD_INT 1
88617: ST_TO_ADDR
// if p3 = 17 then
88618: LD_VAR 0 3
88622: PUSH
88623: LD_INT 17
88625: EQUAL
88626: IFFALSE 88636
// sSlow := true ;
88628: LD_ADDR_EXP 133
88632: PUSH
88633: LD_INT 1
88635: ST_TO_ADDR
// if p3 = 18 then
88636: LD_VAR 0 3
88640: PUSH
88641: LD_INT 18
88643: EQUAL
88644: IFFALSE 88654
// sLack := true ;
88646: LD_ADDR_EXP 134
88650: PUSH
88651: LD_INT 1
88653: ST_TO_ADDR
// if p3 = 19 then
88654: LD_VAR 0 3
88658: PUSH
88659: LD_INT 19
88661: EQUAL
88662: IFFALSE 88672
// sTank := true ;
88664: LD_ADDR_EXP 136
88668: PUSH
88669: LD_INT 1
88671: ST_TO_ADDR
// if p3 = 20 then
88672: LD_VAR 0 3
88676: PUSH
88677: LD_INT 20
88679: EQUAL
88680: IFFALSE 88690
// sRemote := true ;
88682: LD_ADDR_EXP 137
88686: PUSH
88687: LD_INT 1
88689: ST_TO_ADDR
// if p3 = 21 then
88690: LD_VAR 0 3
88694: PUSH
88695: LD_INT 21
88697: EQUAL
88698: IFFALSE 88708
// sPowell := true ;
88700: LD_ADDR_EXP 138
88704: PUSH
88705: LD_INT 1
88707: ST_TO_ADDR
// if p3 = 22 then
88708: LD_VAR 0 3
88712: PUSH
88713: LD_INT 22
88715: EQUAL
88716: IFFALSE 88726
// sTeleport := true ;
88718: LD_ADDR_EXP 141
88722: PUSH
88723: LD_INT 1
88725: ST_TO_ADDR
// if p3 = 23 then
88726: LD_VAR 0 3
88730: PUSH
88731: LD_INT 23
88733: EQUAL
88734: IFFALSE 88744
// sOilTower := true ;
88736: LD_ADDR_EXP 143
88740: PUSH
88741: LD_INT 1
88743: ST_TO_ADDR
// if p3 = 24 then
88744: LD_VAR 0 3
88748: PUSH
88749: LD_INT 24
88751: EQUAL
88752: IFFALSE 88762
// sShovel := true ;
88754: LD_ADDR_EXP 144
88758: PUSH
88759: LD_INT 1
88761: ST_TO_ADDR
// if p3 = 25 then
88762: LD_VAR 0 3
88766: PUSH
88767: LD_INT 25
88769: EQUAL
88770: IFFALSE 88780
// sSheik := true ;
88772: LD_ADDR_EXP 145
88776: PUSH
88777: LD_INT 1
88779: ST_TO_ADDR
// if p3 = 26 then
88780: LD_VAR 0 3
88784: PUSH
88785: LD_INT 26
88787: EQUAL
88788: IFFALSE 88798
// sEarthquake := true ;
88790: LD_ADDR_EXP 147
88794: PUSH
88795: LD_INT 1
88797: ST_TO_ADDR
// if p3 = 27 then
88798: LD_VAR 0 3
88802: PUSH
88803: LD_INT 27
88805: EQUAL
88806: IFFALSE 88816
// sAI := true ;
88808: LD_ADDR_EXP 148
88812: PUSH
88813: LD_INT 1
88815: ST_TO_ADDR
// if p3 = 28 then
88816: LD_VAR 0 3
88820: PUSH
88821: LD_INT 28
88823: EQUAL
88824: IFFALSE 88834
// sCargo := true ;
88826: LD_ADDR_EXP 151
88830: PUSH
88831: LD_INT 1
88833: ST_TO_ADDR
// if p3 = 29 then
88834: LD_VAR 0 3
88838: PUSH
88839: LD_INT 29
88841: EQUAL
88842: IFFALSE 88852
// sDLaser := true ;
88844: LD_ADDR_EXP 152
88848: PUSH
88849: LD_INT 1
88851: ST_TO_ADDR
// if p3 = 30 then
88852: LD_VAR 0 3
88856: PUSH
88857: LD_INT 30
88859: EQUAL
88860: IFFALSE 88870
// sExchange := true ;
88862: LD_ADDR_EXP 153
88866: PUSH
88867: LD_INT 1
88869: ST_TO_ADDR
// if p3 = 31 then
88870: LD_VAR 0 3
88874: PUSH
88875: LD_INT 31
88877: EQUAL
88878: IFFALSE 88888
// sFac := true ;
88880: LD_ADDR_EXP 154
88884: PUSH
88885: LD_INT 1
88887: ST_TO_ADDR
// if p3 = 32 then
88888: LD_VAR 0 3
88892: PUSH
88893: LD_INT 32
88895: EQUAL
88896: IFFALSE 88906
// sPower := true ;
88898: LD_ADDR_EXP 155
88902: PUSH
88903: LD_INT 1
88905: ST_TO_ADDR
// if p3 = 33 then
88906: LD_VAR 0 3
88910: PUSH
88911: LD_INT 33
88913: EQUAL
88914: IFFALSE 88924
// sRandom := true ;
88916: LD_ADDR_EXP 156
88920: PUSH
88921: LD_INT 1
88923: ST_TO_ADDR
// if p3 = 34 then
88924: LD_VAR 0 3
88928: PUSH
88929: LD_INT 34
88931: EQUAL
88932: IFFALSE 88942
// sShield := true ;
88934: LD_ADDR_EXP 157
88938: PUSH
88939: LD_INT 1
88941: ST_TO_ADDR
// if p3 = 35 then
88942: LD_VAR 0 3
88946: PUSH
88947: LD_INT 35
88949: EQUAL
88950: IFFALSE 88960
// sTime := true ;
88952: LD_ADDR_EXP 158
88956: PUSH
88957: LD_INT 1
88959: ST_TO_ADDR
// if p3 = 36 then
88960: LD_VAR 0 3
88964: PUSH
88965: LD_INT 36
88967: EQUAL
88968: IFFALSE 88978
// sTools := true ;
88970: LD_ADDR_EXP 159
88974: PUSH
88975: LD_INT 1
88977: ST_TO_ADDR
// if p3 = 101 then
88978: LD_VAR 0 3
88982: PUSH
88983: LD_INT 101
88985: EQUAL
88986: IFFALSE 88996
// sSold := true ;
88988: LD_ADDR_EXP 124
88992: PUSH
88993: LD_INT 1
88995: ST_TO_ADDR
// if p3 = 102 then
88996: LD_VAR 0 3
89000: PUSH
89001: LD_INT 102
89003: EQUAL
89004: IFFALSE 89014
// sDiff := true ;
89006: LD_ADDR_EXP 125
89010: PUSH
89011: LD_INT 1
89013: ST_TO_ADDR
// if p3 = 103 then
89014: LD_VAR 0 3
89018: PUSH
89019: LD_INT 103
89021: EQUAL
89022: IFFALSE 89032
// sFog := true ;
89024: LD_ADDR_EXP 128
89028: PUSH
89029: LD_INT 1
89031: ST_TO_ADDR
// if p3 = 104 then
89032: LD_VAR 0 3
89036: PUSH
89037: LD_INT 104
89039: EQUAL
89040: IFFALSE 89050
// sReset := true ;
89042: LD_ADDR_EXP 129
89046: PUSH
89047: LD_INT 1
89049: ST_TO_ADDR
// if p3 = 105 then
89050: LD_VAR 0 3
89054: PUSH
89055: LD_INT 105
89057: EQUAL
89058: IFFALSE 89068
// sSun := true ;
89060: LD_ADDR_EXP 130
89064: PUSH
89065: LD_INT 1
89067: ST_TO_ADDR
// if p3 = 106 then
89068: LD_VAR 0 3
89072: PUSH
89073: LD_INT 106
89075: EQUAL
89076: IFFALSE 89086
// sTiger := true ;
89078: LD_ADDR_EXP 126
89082: PUSH
89083: LD_INT 1
89085: ST_TO_ADDR
// if p3 = 107 then
89086: LD_VAR 0 3
89090: PUSH
89091: LD_INT 107
89093: EQUAL
89094: IFFALSE 89104
// sBomb := true ;
89096: LD_ADDR_EXP 127
89100: PUSH
89101: LD_INT 1
89103: ST_TO_ADDR
// if p3 = 108 then
89104: LD_VAR 0 3
89108: PUSH
89109: LD_INT 108
89111: EQUAL
89112: IFFALSE 89122
// sWound := true ;
89114: LD_ADDR_EXP 135
89118: PUSH
89119: LD_INT 1
89121: ST_TO_ADDR
// if p3 = 109 then
89122: LD_VAR 0 3
89126: PUSH
89127: LD_INT 109
89129: EQUAL
89130: IFFALSE 89140
// sBetray := true ;
89132: LD_ADDR_EXP 139
89136: PUSH
89137: LD_INT 1
89139: ST_TO_ADDR
// if p3 = 110 then
89140: LD_VAR 0 3
89144: PUSH
89145: LD_INT 110
89147: EQUAL
89148: IFFALSE 89158
// sContamin := true ;
89150: LD_ADDR_EXP 140
89154: PUSH
89155: LD_INT 1
89157: ST_TO_ADDR
// if p3 = 111 then
89158: LD_VAR 0 3
89162: PUSH
89163: LD_INT 111
89165: EQUAL
89166: IFFALSE 89176
// sOil := true ;
89168: LD_ADDR_EXP 142
89172: PUSH
89173: LD_INT 1
89175: ST_TO_ADDR
// if p3 = 112 then
89176: LD_VAR 0 3
89180: PUSH
89181: LD_INT 112
89183: EQUAL
89184: IFFALSE 89194
// sStu := true ;
89186: LD_ADDR_EXP 146
89190: PUSH
89191: LD_INT 1
89193: ST_TO_ADDR
// if p3 = 113 then
89194: LD_VAR 0 3
89198: PUSH
89199: LD_INT 113
89201: EQUAL
89202: IFFALSE 89212
// sBazooka := true ;
89204: LD_ADDR_EXP 149
89208: PUSH
89209: LD_INT 1
89211: ST_TO_ADDR
// if p3 = 114 then
89212: LD_VAR 0 3
89216: PUSH
89217: LD_INT 114
89219: EQUAL
89220: IFFALSE 89230
// sMortar := true ;
89222: LD_ADDR_EXP 150
89226: PUSH
89227: LD_INT 1
89229: ST_TO_ADDR
// if p3 = 115 then
89230: LD_VAR 0 3
89234: PUSH
89235: LD_INT 115
89237: EQUAL
89238: IFFALSE 89248
// sRanger := true ;
89240: LD_ADDR_EXP 160
89244: PUSH
89245: LD_INT 1
89247: ST_TO_ADDR
// if p3 = 116 then
89248: LD_VAR 0 3
89252: PUSH
89253: LD_INT 116
89255: EQUAL
89256: IFFALSE 89266
// sComputer := true ;
89258: LD_ADDR_EXP 161
89262: PUSH
89263: LD_INT 1
89265: ST_TO_ADDR
// if p3 = 117 then
89266: LD_VAR 0 3
89270: PUSH
89271: LD_INT 117
89273: EQUAL
89274: IFFALSE 89284
// s30 := true ;
89276: LD_ADDR_EXP 162
89280: PUSH
89281: LD_INT 1
89283: ST_TO_ADDR
// if p3 = 118 then
89284: LD_VAR 0 3
89288: PUSH
89289: LD_INT 118
89291: EQUAL
89292: IFFALSE 89302
// s60 := true ;
89294: LD_ADDR_EXP 163
89298: PUSH
89299: LD_INT 1
89301: ST_TO_ADDR
// end ; if p2 = hack_mode then
89302: LD_VAR 0 2
89306: PUSH
89307: LD_INT 101
89309: EQUAL
89310: IFFALSE 89438
// begin case p3 of 1 :
89312: LD_VAR 0 3
89316: PUSH
89317: LD_INT 1
89319: DOUBLE
89320: EQUAL
89321: IFTRUE 89325
89323: GO 89332
89325: POP
// hHackUnlimitedResources ; 2 :
89326: CALL 101585 0 0
89330: GO 89438
89332: LD_INT 2
89334: DOUBLE
89335: EQUAL
89336: IFTRUE 89340
89338: GO 89347
89340: POP
// hHackSetLevel10 ; 3 :
89341: CALL 101718 0 0
89345: GO 89438
89347: LD_INT 3
89349: DOUBLE
89350: EQUAL
89351: IFTRUE 89355
89353: GO 89362
89355: POP
// hHackSetLevel10YourUnits ; 4 :
89356: CALL 101803 0 0
89360: GO 89438
89362: LD_INT 4
89364: DOUBLE
89365: EQUAL
89366: IFTRUE 89370
89368: GO 89377
89370: POP
// hHackInvincible ; 5 :
89371: CALL 102251 0 0
89375: GO 89438
89377: LD_INT 5
89379: DOUBLE
89380: EQUAL
89381: IFTRUE 89385
89383: GO 89392
89385: POP
// hHackInvisible ; 6 :
89386: CALL 102362 0 0
89390: GO 89438
89392: LD_INT 6
89394: DOUBLE
89395: EQUAL
89396: IFTRUE 89400
89398: GO 89407
89400: POP
// hHackChangeYourSide ; 7 :
89401: CALL 102419 0 0
89405: GO 89438
89407: LD_INT 7
89409: DOUBLE
89410: EQUAL
89411: IFTRUE 89415
89413: GO 89422
89415: POP
// hHackChangeUnitSide ; 8 :
89416: CALL 102461 0 0
89420: GO 89438
89422: LD_INT 8
89424: DOUBLE
89425: EQUAL
89426: IFTRUE 89430
89428: GO 89437
89430: POP
// hHackFog ; end ;
89431: CALL 102562 0 0
89435: GO 89438
89437: POP
// end ; if p2 = game_save_mode then
89438: LD_VAR 0 2
89442: PUSH
89443: LD_INT 102
89445: EQUAL
89446: IFFALSE 89501
// begin if p3 = 1 then
89448: LD_VAR 0 3
89452: PUSH
89453: LD_INT 1
89455: EQUAL
89456: IFFALSE 89468
// globalGameSaveCounter := p4 ;
89458: LD_ADDR_EXP 106
89462: PUSH
89463: LD_VAR 0 4
89467: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
89468: LD_VAR 0 3
89472: PUSH
89473: LD_INT 2
89475: EQUAL
89476: PUSH
89477: LD_EXP 106
89481: AND
89482: IFFALSE 89501
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
89484: LD_STRING setGameSaveCounter(
89486: PUSH
89487: LD_EXP 106
89491: STR
89492: PUSH
89493: LD_STRING )
89495: STR
89496: PPUSH
89497: CALL_OW 559
// end ; end ;
89501: LD_VAR 0 7
89505: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
89506: LD_INT 0
89508: PPUSH
// streamModeActive := false ;
89509: LD_ADDR_EXP 107
89513: PUSH
89514: LD_INT 0
89516: ST_TO_ADDR
// normalCounter := 36 ;
89517: LD_ADDR_EXP 108
89521: PUSH
89522: LD_INT 36
89524: ST_TO_ADDR
// hardcoreCounter := 18 ;
89525: LD_ADDR_EXP 109
89529: PUSH
89530: LD_INT 18
89532: ST_TO_ADDR
// sRocket := false ;
89533: LD_ADDR_EXP 112
89537: PUSH
89538: LD_INT 0
89540: ST_TO_ADDR
// sSpeed := false ;
89541: LD_ADDR_EXP 111
89545: PUSH
89546: LD_INT 0
89548: ST_TO_ADDR
// sEngine := false ;
89549: LD_ADDR_EXP 113
89553: PUSH
89554: LD_INT 0
89556: ST_TO_ADDR
// sSpec := false ;
89557: LD_ADDR_EXP 110
89561: PUSH
89562: LD_INT 0
89564: ST_TO_ADDR
// sLevel := false ;
89565: LD_ADDR_EXP 114
89569: PUSH
89570: LD_INT 0
89572: ST_TO_ADDR
// sArmoury := false ;
89573: LD_ADDR_EXP 115
89577: PUSH
89578: LD_INT 0
89580: ST_TO_ADDR
// sRadar := false ;
89581: LD_ADDR_EXP 116
89585: PUSH
89586: LD_INT 0
89588: ST_TO_ADDR
// sBunker := false ;
89589: LD_ADDR_EXP 117
89593: PUSH
89594: LD_INT 0
89596: ST_TO_ADDR
// sHack := false ;
89597: LD_ADDR_EXP 118
89601: PUSH
89602: LD_INT 0
89604: ST_TO_ADDR
// sFire := false ;
89605: LD_ADDR_EXP 119
89609: PUSH
89610: LD_INT 0
89612: ST_TO_ADDR
// sRefresh := false ;
89613: LD_ADDR_EXP 120
89617: PUSH
89618: LD_INT 0
89620: ST_TO_ADDR
// sExp := false ;
89621: LD_ADDR_EXP 121
89625: PUSH
89626: LD_INT 0
89628: ST_TO_ADDR
// sDepot := false ;
89629: LD_ADDR_EXP 122
89633: PUSH
89634: LD_INT 0
89636: ST_TO_ADDR
// sFlag := false ;
89637: LD_ADDR_EXP 123
89641: PUSH
89642: LD_INT 0
89644: ST_TO_ADDR
// sKamikadze := false ;
89645: LD_ADDR_EXP 131
89649: PUSH
89650: LD_INT 0
89652: ST_TO_ADDR
// sTroll := false ;
89653: LD_ADDR_EXP 132
89657: PUSH
89658: LD_INT 0
89660: ST_TO_ADDR
// sSlow := false ;
89661: LD_ADDR_EXP 133
89665: PUSH
89666: LD_INT 0
89668: ST_TO_ADDR
// sLack := false ;
89669: LD_ADDR_EXP 134
89673: PUSH
89674: LD_INT 0
89676: ST_TO_ADDR
// sTank := false ;
89677: LD_ADDR_EXP 136
89681: PUSH
89682: LD_INT 0
89684: ST_TO_ADDR
// sRemote := false ;
89685: LD_ADDR_EXP 137
89689: PUSH
89690: LD_INT 0
89692: ST_TO_ADDR
// sPowell := false ;
89693: LD_ADDR_EXP 138
89697: PUSH
89698: LD_INT 0
89700: ST_TO_ADDR
// sTeleport := false ;
89701: LD_ADDR_EXP 141
89705: PUSH
89706: LD_INT 0
89708: ST_TO_ADDR
// sOilTower := false ;
89709: LD_ADDR_EXP 143
89713: PUSH
89714: LD_INT 0
89716: ST_TO_ADDR
// sShovel := false ;
89717: LD_ADDR_EXP 144
89721: PUSH
89722: LD_INT 0
89724: ST_TO_ADDR
// sSheik := false ;
89725: LD_ADDR_EXP 145
89729: PUSH
89730: LD_INT 0
89732: ST_TO_ADDR
// sEarthquake := false ;
89733: LD_ADDR_EXP 147
89737: PUSH
89738: LD_INT 0
89740: ST_TO_ADDR
// sAI := false ;
89741: LD_ADDR_EXP 148
89745: PUSH
89746: LD_INT 0
89748: ST_TO_ADDR
// sCargo := false ;
89749: LD_ADDR_EXP 151
89753: PUSH
89754: LD_INT 0
89756: ST_TO_ADDR
// sDLaser := false ;
89757: LD_ADDR_EXP 152
89761: PUSH
89762: LD_INT 0
89764: ST_TO_ADDR
// sExchange := false ;
89765: LD_ADDR_EXP 153
89769: PUSH
89770: LD_INT 0
89772: ST_TO_ADDR
// sFac := false ;
89773: LD_ADDR_EXP 154
89777: PUSH
89778: LD_INT 0
89780: ST_TO_ADDR
// sPower := false ;
89781: LD_ADDR_EXP 155
89785: PUSH
89786: LD_INT 0
89788: ST_TO_ADDR
// sRandom := false ;
89789: LD_ADDR_EXP 156
89793: PUSH
89794: LD_INT 0
89796: ST_TO_ADDR
// sShield := false ;
89797: LD_ADDR_EXP 157
89801: PUSH
89802: LD_INT 0
89804: ST_TO_ADDR
// sTime := false ;
89805: LD_ADDR_EXP 158
89809: PUSH
89810: LD_INT 0
89812: ST_TO_ADDR
// sTools := false ;
89813: LD_ADDR_EXP 159
89817: PUSH
89818: LD_INT 0
89820: ST_TO_ADDR
// sSold := false ;
89821: LD_ADDR_EXP 124
89825: PUSH
89826: LD_INT 0
89828: ST_TO_ADDR
// sDiff := false ;
89829: LD_ADDR_EXP 125
89833: PUSH
89834: LD_INT 0
89836: ST_TO_ADDR
// sFog := false ;
89837: LD_ADDR_EXP 128
89841: PUSH
89842: LD_INT 0
89844: ST_TO_ADDR
// sReset := false ;
89845: LD_ADDR_EXP 129
89849: PUSH
89850: LD_INT 0
89852: ST_TO_ADDR
// sSun := false ;
89853: LD_ADDR_EXP 130
89857: PUSH
89858: LD_INT 0
89860: ST_TO_ADDR
// sTiger := false ;
89861: LD_ADDR_EXP 126
89865: PUSH
89866: LD_INT 0
89868: ST_TO_ADDR
// sBomb := false ;
89869: LD_ADDR_EXP 127
89873: PUSH
89874: LD_INT 0
89876: ST_TO_ADDR
// sWound := false ;
89877: LD_ADDR_EXP 135
89881: PUSH
89882: LD_INT 0
89884: ST_TO_ADDR
// sBetray := false ;
89885: LD_ADDR_EXP 139
89889: PUSH
89890: LD_INT 0
89892: ST_TO_ADDR
// sContamin := false ;
89893: LD_ADDR_EXP 140
89897: PUSH
89898: LD_INT 0
89900: ST_TO_ADDR
// sOil := false ;
89901: LD_ADDR_EXP 142
89905: PUSH
89906: LD_INT 0
89908: ST_TO_ADDR
// sStu := false ;
89909: LD_ADDR_EXP 146
89913: PUSH
89914: LD_INT 0
89916: ST_TO_ADDR
// sBazooka := false ;
89917: LD_ADDR_EXP 149
89921: PUSH
89922: LD_INT 0
89924: ST_TO_ADDR
// sMortar := false ;
89925: LD_ADDR_EXP 150
89929: PUSH
89930: LD_INT 0
89932: ST_TO_ADDR
// sRanger := false ;
89933: LD_ADDR_EXP 160
89937: PUSH
89938: LD_INT 0
89940: ST_TO_ADDR
// sComputer := false ;
89941: LD_ADDR_EXP 161
89945: PUSH
89946: LD_INT 0
89948: ST_TO_ADDR
// s30 := false ;
89949: LD_ADDR_EXP 162
89953: PUSH
89954: LD_INT 0
89956: ST_TO_ADDR
// s60 := false ;
89957: LD_ADDR_EXP 163
89961: PUSH
89962: LD_INT 0
89964: ST_TO_ADDR
// end ;
89965: LD_VAR 0 1
89969: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
89970: LD_INT 0
89972: PPUSH
89973: PPUSH
89974: PPUSH
89975: PPUSH
89976: PPUSH
89977: PPUSH
89978: PPUSH
// result := [ ] ;
89979: LD_ADDR_VAR 0 2
89983: PUSH
89984: EMPTY
89985: ST_TO_ADDR
// if campaign_id = 1 then
89986: LD_OWVAR 69
89990: PUSH
89991: LD_INT 1
89993: EQUAL
89994: IFFALSE 93160
// begin case mission_number of 1 :
89996: LD_OWVAR 70
90000: PUSH
90001: LD_INT 1
90003: DOUBLE
90004: EQUAL
90005: IFTRUE 90009
90007: GO 90085
90009: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
90010: LD_ADDR_VAR 0 2
90014: PUSH
90015: LD_INT 2
90017: PUSH
90018: LD_INT 4
90020: PUSH
90021: LD_INT 11
90023: PUSH
90024: LD_INT 12
90026: PUSH
90027: LD_INT 15
90029: PUSH
90030: LD_INT 16
90032: PUSH
90033: LD_INT 22
90035: PUSH
90036: LD_INT 23
90038: PUSH
90039: LD_INT 26
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: PUSH
90053: LD_INT 101
90055: PUSH
90056: LD_INT 102
90058: PUSH
90059: LD_INT 106
90061: PUSH
90062: LD_INT 116
90064: PUSH
90065: LD_INT 117
90067: PUSH
90068: LD_INT 118
90070: PUSH
90071: EMPTY
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: ST_TO_ADDR
90083: GO 93158
90085: LD_INT 2
90087: DOUBLE
90088: EQUAL
90089: IFTRUE 90093
90091: GO 90177
90093: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
90094: LD_ADDR_VAR 0 2
90098: PUSH
90099: LD_INT 2
90101: PUSH
90102: LD_INT 4
90104: PUSH
90105: LD_INT 11
90107: PUSH
90108: LD_INT 12
90110: PUSH
90111: LD_INT 15
90113: PUSH
90114: LD_INT 16
90116: PUSH
90117: LD_INT 22
90119: PUSH
90120: LD_INT 23
90122: PUSH
90123: LD_INT 26
90125: PUSH
90126: EMPTY
90127: LIST
90128: LIST
90129: LIST
90130: LIST
90131: LIST
90132: LIST
90133: LIST
90134: LIST
90135: LIST
90136: PUSH
90137: LD_INT 101
90139: PUSH
90140: LD_INT 102
90142: PUSH
90143: LD_INT 105
90145: PUSH
90146: LD_INT 106
90148: PUSH
90149: LD_INT 108
90151: PUSH
90152: LD_INT 116
90154: PUSH
90155: LD_INT 117
90157: PUSH
90158: LD_INT 118
90160: PUSH
90161: EMPTY
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: LIST
90167: LIST
90168: LIST
90169: LIST
90170: PUSH
90171: EMPTY
90172: LIST
90173: LIST
90174: ST_TO_ADDR
90175: GO 93158
90177: LD_INT 3
90179: DOUBLE
90180: EQUAL
90181: IFTRUE 90185
90183: GO 90273
90185: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
90186: LD_ADDR_VAR 0 2
90190: PUSH
90191: LD_INT 2
90193: PUSH
90194: LD_INT 4
90196: PUSH
90197: LD_INT 5
90199: PUSH
90200: LD_INT 11
90202: PUSH
90203: LD_INT 12
90205: PUSH
90206: LD_INT 15
90208: PUSH
90209: LD_INT 16
90211: PUSH
90212: LD_INT 22
90214: PUSH
90215: LD_INT 26
90217: PUSH
90218: LD_INT 36
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: LIST
90225: LIST
90226: LIST
90227: LIST
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 101
90235: PUSH
90236: LD_INT 102
90238: PUSH
90239: LD_INT 105
90241: PUSH
90242: LD_INT 106
90244: PUSH
90245: LD_INT 108
90247: PUSH
90248: LD_INT 116
90250: PUSH
90251: LD_INT 117
90253: PUSH
90254: LD_INT 118
90256: PUSH
90257: EMPTY
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: ST_TO_ADDR
90271: GO 93158
90273: LD_INT 4
90275: DOUBLE
90276: EQUAL
90277: IFTRUE 90281
90279: GO 90377
90281: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
90282: LD_ADDR_VAR 0 2
90286: PUSH
90287: LD_INT 2
90289: PUSH
90290: LD_INT 4
90292: PUSH
90293: LD_INT 5
90295: PUSH
90296: LD_INT 8
90298: PUSH
90299: LD_INT 11
90301: PUSH
90302: LD_INT 12
90304: PUSH
90305: LD_INT 15
90307: PUSH
90308: LD_INT 16
90310: PUSH
90311: LD_INT 22
90313: PUSH
90314: LD_INT 23
90316: PUSH
90317: LD_INT 26
90319: PUSH
90320: LD_INT 36
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: LIST
90327: LIST
90328: LIST
90329: LIST
90330: LIST
90331: LIST
90332: LIST
90333: LIST
90334: LIST
90335: LIST
90336: PUSH
90337: LD_INT 101
90339: PUSH
90340: LD_INT 102
90342: PUSH
90343: LD_INT 105
90345: PUSH
90346: LD_INT 106
90348: PUSH
90349: LD_INT 108
90351: PUSH
90352: LD_INT 116
90354: PUSH
90355: LD_INT 117
90357: PUSH
90358: LD_INT 118
90360: PUSH
90361: EMPTY
90362: LIST
90363: LIST
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: LIST
90369: LIST
90370: PUSH
90371: EMPTY
90372: LIST
90373: LIST
90374: ST_TO_ADDR
90375: GO 93158
90377: LD_INT 5
90379: DOUBLE
90380: EQUAL
90381: IFTRUE 90385
90383: GO 90497
90385: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
90386: LD_ADDR_VAR 0 2
90390: PUSH
90391: LD_INT 2
90393: PUSH
90394: LD_INT 4
90396: PUSH
90397: LD_INT 5
90399: PUSH
90400: LD_INT 6
90402: PUSH
90403: LD_INT 8
90405: PUSH
90406: LD_INT 11
90408: PUSH
90409: LD_INT 12
90411: PUSH
90412: LD_INT 15
90414: PUSH
90415: LD_INT 16
90417: PUSH
90418: LD_INT 22
90420: PUSH
90421: LD_INT 23
90423: PUSH
90424: LD_INT 25
90426: PUSH
90427: LD_INT 26
90429: PUSH
90430: LD_INT 36
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: LIST
90445: LIST
90446: LIST
90447: LIST
90448: PUSH
90449: LD_INT 101
90451: PUSH
90452: LD_INT 102
90454: PUSH
90455: LD_INT 105
90457: PUSH
90458: LD_INT 106
90460: PUSH
90461: LD_INT 108
90463: PUSH
90464: LD_INT 109
90466: PUSH
90467: LD_INT 112
90469: PUSH
90470: LD_INT 116
90472: PUSH
90473: LD_INT 117
90475: PUSH
90476: LD_INT 118
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: LIST
90486: LIST
90487: LIST
90488: LIST
90489: LIST
90490: PUSH
90491: EMPTY
90492: LIST
90493: LIST
90494: ST_TO_ADDR
90495: GO 93158
90497: LD_INT 6
90499: DOUBLE
90500: EQUAL
90501: IFTRUE 90505
90503: GO 90637
90505: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
90506: LD_ADDR_VAR 0 2
90510: PUSH
90511: LD_INT 2
90513: PUSH
90514: LD_INT 4
90516: PUSH
90517: LD_INT 5
90519: PUSH
90520: LD_INT 6
90522: PUSH
90523: LD_INT 8
90525: PUSH
90526: LD_INT 11
90528: PUSH
90529: LD_INT 12
90531: PUSH
90532: LD_INT 15
90534: PUSH
90535: LD_INT 16
90537: PUSH
90538: LD_INT 20
90540: PUSH
90541: LD_INT 21
90543: PUSH
90544: LD_INT 22
90546: PUSH
90547: LD_INT 23
90549: PUSH
90550: LD_INT 25
90552: PUSH
90553: LD_INT 26
90555: PUSH
90556: LD_INT 30
90558: PUSH
90559: LD_INT 31
90561: PUSH
90562: LD_INT 32
90564: PUSH
90565: LD_INT 36
90567: PUSH
90568: EMPTY
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: PUSH
90589: LD_INT 101
90591: PUSH
90592: LD_INT 102
90594: PUSH
90595: LD_INT 105
90597: PUSH
90598: LD_INT 106
90600: PUSH
90601: LD_INT 108
90603: PUSH
90604: LD_INT 109
90606: PUSH
90607: LD_INT 112
90609: PUSH
90610: LD_INT 116
90612: PUSH
90613: LD_INT 117
90615: PUSH
90616: LD_INT 118
90618: PUSH
90619: EMPTY
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: PUSH
90631: EMPTY
90632: LIST
90633: LIST
90634: ST_TO_ADDR
90635: GO 93158
90637: LD_INT 7
90639: DOUBLE
90640: EQUAL
90641: IFTRUE 90645
90643: GO 90757
90645: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
90646: LD_ADDR_VAR 0 2
90650: PUSH
90651: LD_INT 2
90653: PUSH
90654: LD_INT 4
90656: PUSH
90657: LD_INT 5
90659: PUSH
90660: LD_INT 7
90662: PUSH
90663: LD_INT 11
90665: PUSH
90666: LD_INT 12
90668: PUSH
90669: LD_INT 15
90671: PUSH
90672: LD_INT 16
90674: PUSH
90675: LD_INT 20
90677: PUSH
90678: LD_INT 21
90680: PUSH
90681: LD_INT 22
90683: PUSH
90684: LD_INT 23
90686: PUSH
90687: LD_INT 25
90689: PUSH
90690: LD_INT 26
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: PUSH
90709: LD_INT 101
90711: PUSH
90712: LD_INT 102
90714: PUSH
90715: LD_INT 103
90717: PUSH
90718: LD_INT 105
90720: PUSH
90721: LD_INT 106
90723: PUSH
90724: LD_INT 108
90726: PUSH
90727: LD_INT 112
90729: PUSH
90730: LD_INT 116
90732: PUSH
90733: LD_INT 117
90735: PUSH
90736: LD_INT 118
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: LIST
90743: LIST
90744: LIST
90745: LIST
90746: LIST
90747: LIST
90748: LIST
90749: LIST
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: ST_TO_ADDR
90755: GO 93158
90757: LD_INT 8
90759: DOUBLE
90760: EQUAL
90761: IFTRUE 90765
90763: GO 90905
90765: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
90766: LD_ADDR_VAR 0 2
90770: PUSH
90771: LD_INT 2
90773: PUSH
90774: LD_INT 4
90776: PUSH
90777: LD_INT 5
90779: PUSH
90780: LD_INT 6
90782: PUSH
90783: LD_INT 7
90785: PUSH
90786: LD_INT 8
90788: PUSH
90789: LD_INT 11
90791: PUSH
90792: LD_INT 12
90794: PUSH
90795: LD_INT 15
90797: PUSH
90798: LD_INT 16
90800: PUSH
90801: LD_INT 20
90803: PUSH
90804: LD_INT 21
90806: PUSH
90807: LD_INT 22
90809: PUSH
90810: LD_INT 23
90812: PUSH
90813: LD_INT 25
90815: PUSH
90816: LD_INT 26
90818: PUSH
90819: LD_INT 30
90821: PUSH
90822: LD_INT 31
90824: PUSH
90825: LD_INT 32
90827: PUSH
90828: LD_INT 36
90830: PUSH
90831: EMPTY
90832: LIST
90833: LIST
90834: LIST
90835: LIST
90836: LIST
90837: LIST
90838: LIST
90839: LIST
90840: LIST
90841: LIST
90842: LIST
90843: LIST
90844: LIST
90845: LIST
90846: LIST
90847: LIST
90848: LIST
90849: LIST
90850: LIST
90851: LIST
90852: PUSH
90853: LD_INT 101
90855: PUSH
90856: LD_INT 102
90858: PUSH
90859: LD_INT 103
90861: PUSH
90862: LD_INT 105
90864: PUSH
90865: LD_INT 106
90867: PUSH
90868: LD_INT 108
90870: PUSH
90871: LD_INT 109
90873: PUSH
90874: LD_INT 112
90876: PUSH
90877: LD_INT 116
90879: PUSH
90880: LD_INT 117
90882: PUSH
90883: LD_INT 118
90885: PUSH
90886: EMPTY
90887: LIST
90888: LIST
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: LIST
90897: LIST
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: ST_TO_ADDR
90903: GO 93158
90905: LD_INT 9
90907: DOUBLE
90908: EQUAL
90909: IFTRUE 90913
90911: GO 91061
90913: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
90914: LD_ADDR_VAR 0 2
90918: PUSH
90919: LD_INT 2
90921: PUSH
90922: LD_INT 4
90924: PUSH
90925: LD_INT 5
90927: PUSH
90928: LD_INT 6
90930: PUSH
90931: LD_INT 7
90933: PUSH
90934: LD_INT 8
90936: PUSH
90937: LD_INT 11
90939: PUSH
90940: LD_INT 12
90942: PUSH
90943: LD_INT 15
90945: PUSH
90946: LD_INT 16
90948: PUSH
90949: LD_INT 20
90951: PUSH
90952: LD_INT 21
90954: PUSH
90955: LD_INT 22
90957: PUSH
90958: LD_INT 23
90960: PUSH
90961: LD_INT 25
90963: PUSH
90964: LD_INT 26
90966: PUSH
90967: LD_INT 28
90969: PUSH
90970: LD_INT 30
90972: PUSH
90973: LD_INT 31
90975: PUSH
90976: LD_INT 32
90978: PUSH
90979: LD_INT 36
90981: PUSH
90982: EMPTY
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: PUSH
91005: LD_INT 101
91007: PUSH
91008: LD_INT 102
91010: PUSH
91011: LD_INT 103
91013: PUSH
91014: LD_INT 105
91016: PUSH
91017: LD_INT 106
91019: PUSH
91020: LD_INT 108
91022: PUSH
91023: LD_INT 109
91025: PUSH
91026: LD_INT 112
91028: PUSH
91029: LD_INT 114
91031: PUSH
91032: LD_INT 116
91034: PUSH
91035: LD_INT 117
91037: PUSH
91038: LD_INT 118
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: LIST
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: ST_TO_ADDR
91059: GO 93158
91061: LD_INT 10
91063: DOUBLE
91064: EQUAL
91065: IFTRUE 91069
91067: GO 91265
91069: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
91070: LD_ADDR_VAR 0 2
91074: PUSH
91075: LD_INT 2
91077: PUSH
91078: LD_INT 4
91080: PUSH
91081: LD_INT 5
91083: PUSH
91084: LD_INT 6
91086: PUSH
91087: LD_INT 7
91089: PUSH
91090: LD_INT 8
91092: PUSH
91093: LD_INT 9
91095: PUSH
91096: LD_INT 10
91098: PUSH
91099: LD_INT 11
91101: PUSH
91102: LD_INT 12
91104: PUSH
91105: LD_INT 13
91107: PUSH
91108: LD_INT 14
91110: PUSH
91111: LD_INT 15
91113: PUSH
91114: LD_INT 16
91116: PUSH
91117: LD_INT 17
91119: PUSH
91120: LD_INT 18
91122: PUSH
91123: LD_INT 19
91125: PUSH
91126: LD_INT 20
91128: PUSH
91129: LD_INT 21
91131: PUSH
91132: LD_INT 22
91134: PUSH
91135: LD_INT 23
91137: PUSH
91138: LD_INT 24
91140: PUSH
91141: LD_INT 25
91143: PUSH
91144: LD_INT 26
91146: PUSH
91147: LD_INT 28
91149: PUSH
91150: LD_INT 30
91152: PUSH
91153: LD_INT 31
91155: PUSH
91156: LD_INT 32
91158: PUSH
91159: LD_INT 36
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: LIST
91180: LIST
91181: LIST
91182: LIST
91183: LIST
91184: LIST
91185: LIST
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: PUSH
91193: LD_INT 101
91195: PUSH
91196: LD_INT 102
91198: PUSH
91199: LD_INT 103
91201: PUSH
91202: LD_INT 104
91204: PUSH
91205: LD_INT 105
91207: PUSH
91208: LD_INT 106
91210: PUSH
91211: LD_INT 107
91213: PUSH
91214: LD_INT 108
91216: PUSH
91217: LD_INT 109
91219: PUSH
91220: LD_INT 110
91222: PUSH
91223: LD_INT 111
91225: PUSH
91226: LD_INT 112
91228: PUSH
91229: LD_INT 114
91231: PUSH
91232: LD_INT 116
91234: PUSH
91235: LD_INT 117
91237: PUSH
91238: LD_INT 118
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: ST_TO_ADDR
91263: GO 93158
91265: LD_INT 11
91267: DOUBLE
91268: EQUAL
91269: IFTRUE 91273
91271: GO 91477
91273: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
91274: LD_ADDR_VAR 0 2
91278: PUSH
91279: LD_INT 2
91281: PUSH
91282: LD_INT 3
91284: PUSH
91285: LD_INT 4
91287: PUSH
91288: LD_INT 5
91290: PUSH
91291: LD_INT 6
91293: PUSH
91294: LD_INT 7
91296: PUSH
91297: LD_INT 8
91299: PUSH
91300: LD_INT 9
91302: PUSH
91303: LD_INT 10
91305: PUSH
91306: LD_INT 11
91308: PUSH
91309: LD_INT 12
91311: PUSH
91312: LD_INT 13
91314: PUSH
91315: LD_INT 14
91317: PUSH
91318: LD_INT 15
91320: PUSH
91321: LD_INT 16
91323: PUSH
91324: LD_INT 17
91326: PUSH
91327: LD_INT 18
91329: PUSH
91330: LD_INT 19
91332: PUSH
91333: LD_INT 20
91335: PUSH
91336: LD_INT 21
91338: PUSH
91339: LD_INT 22
91341: PUSH
91342: LD_INT 23
91344: PUSH
91345: LD_INT 24
91347: PUSH
91348: LD_INT 25
91350: PUSH
91351: LD_INT 26
91353: PUSH
91354: LD_INT 28
91356: PUSH
91357: LD_INT 30
91359: PUSH
91360: LD_INT 31
91362: PUSH
91363: LD_INT 32
91365: PUSH
91366: LD_INT 34
91368: PUSH
91369: LD_INT 36
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: LIST
91380: LIST
91381: LIST
91382: LIST
91383: LIST
91384: LIST
91385: LIST
91386: LIST
91387: LIST
91388: LIST
91389: LIST
91390: LIST
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: LIST
91400: LIST
91401: LIST
91402: LIST
91403: LIST
91404: PUSH
91405: LD_INT 101
91407: PUSH
91408: LD_INT 102
91410: PUSH
91411: LD_INT 103
91413: PUSH
91414: LD_INT 104
91416: PUSH
91417: LD_INT 105
91419: PUSH
91420: LD_INT 106
91422: PUSH
91423: LD_INT 107
91425: PUSH
91426: LD_INT 108
91428: PUSH
91429: LD_INT 109
91431: PUSH
91432: LD_INT 110
91434: PUSH
91435: LD_INT 111
91437: PUSH
91438: LD_INT 112
91440: PUSH
91441: LD_INT 114
91443: PUSH
91444: LD_INT 116
91446: PUSH
91447: LD_INT 117
91449: PUSH
91450: LD_INT 118
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: PUSH
91471: EMPTY
91472: LIST
91473: LIST
91474: ST_TO_ADDR
91475: GO 93158
91477: LD_INT 12
91479: DOUBLE
91480: EQUAL
91481: IFTRUE 91485
91483: GO 91705
91485: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
91486: LD_ADDR_VAR 0 2
91490: PUSH
91491: LD_INT 1
91493: PUSH
91494: LD_INT 2
91496: PUSH
91497: LD_INT 3
91499: PUSH
91500: LD_INT 4
91502: PUSH
91503: LD_INT 5
91505: PUSH
91506: LD_INT 6
91508: PUSH
91509: LD_INT 7
91511: PUSH
91512: LD_INT 8
91514: PUSH
91515: LD_INT 9
91517: PUSH
91518: LD_INT 10
91520: PUSH
91521: LD_INT 11
91523: PUSH
91524: LD_INT 12
91526: PUSH
91527: LD_INT 13
91529: PUSH
91530: LD_INT 14
91532: PUSH
91533: LD_INT 15
91535: PUSH
91536: LD_INT 16
91538: PUSH
91539: LD_INT 17
91541: PUSH
91542: LD_INT 18
91544: PUSH
91545: LD_INT 19
91547: PUSH
91548: LD_INT 20
91550: PUSH
91551: LD_INT 21
91553: PUSH
91554: LD_INT 22
91556: PUSH
91557: LD_INT 23
91559: PUSH
91560: LD_INT 24
91562: PUSH
91563: LD_INT 25
91565: PUSH
91566: LD_INT 26
91568: PUSH
91569: LD_INT 27
91571: PUSH
91572: LD_INT 28
91574: PUSH
91575: LD_INT 30
91577: PUSH
91578: LD_INT 31
91580: PUSH
91581: LD_INT 32
91583: PUSH
91584: LD_INT 33
91586: PUSH
91587: LD_INT 34
91589: PUSH
91590: LD_INT 36
91592: PUSH
91593: EMPTY
91594: LIST
91595: LIST
91596: LIST
91597: LIST
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: LIST
91626: LIST
91627: LIST
91628: PUSH
91629: LD_INT 101
91631: PUSH
91632: LD_INT 102
91634: PUSH
91635: LD_INT 103
91637: PUSH
91638: LD_INT 104
91640: PUSH
91641: LD_INT 105
91643: PUSH
91644: LD_INT 106
91646: PUSH
91647: LD_INT 107
91649: PUSH
91650: LD_INT 108
91652: PUSH
91653: LD_INT 109
91655: PUSH
91656: LD_INT 110
91658: PUSH
91659: LD_INT 111
91661: PUSH
91662: LD_INT 112
91664: PUSH
91665: LD_INT 113
91667: PUSH
91668: LD_INT 114
91670: PUSH
91671: LD_INT 116
91673: PUSH
91674: LD_INT 117
91676: PUSH
91677: LD_INT 118
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: PUSH
91699: EMPTY
91700: LIST
91701: LIST
91702: ST_TO_ADDR
91703: GO 93158
91705: LD_INT 13
91707: DOUBLE
91708: EQUAL
91709: IFTRUE 91713
91711: GO 91921
91713: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
91714: LD_ADDR_VAR 0 2
91718: PUSH
91719: LD_INT 1
91721: PUSH
91722: LD_INT 2
91724: PUSH
91725: LD_INT 3
91727: PUSH
91728: LD_INT 4
91730: PUSH
91731: LD_INT 5
91733: PUSH
91734: LD_INT 8
91736: PUSH
91737: LD_INT 9
91739: PUSH
91740: LD_INT 10
91742: PUSH
91743: LD_INT 11
91745: PUSH
91746: LD_INT 12
91748: PUSH
91749: LD_INT 14
91751: PUSH
91752: LD_INT 15
91754: PUSH
91755: LD_INT 16
91757: PUSH
91758: LD_INT 17
91760: PUSH
91761: LD_INT 18
91763: PUSH
91764: LD_INT 19
91766: PUSH
91767: LD_INT 20
91769: PUSH
91770: LD_INT 21
91772: PUSH
91773: LD_INT 22
91775: PUSH
91776: LD_INT 23
91778: PUSH
91779: LD_INT 24
91781: PUSH
91782: LD_INT 25
91784: PUSH
91785: LD_INT 26
91787: PUSH
91788: LD_INT 27
91790: PUSH
91791: LD_INT 28
91793: PUSH
91794: LD_INT 30
91796: PUSH
91797: LD_INT 31
91799: PUSH
91800: LD_INT 32
91802: PUSH
91803: LD_INT 33
91805: PUSH
91806: LD_INT 34
91808: PUSH
91809: LD_INT 36
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: LIST
91816: LIST
91817: LIST
91818: LIST
91819: LIST
91820: LIST
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: LIST
91829: LIST
91830: LIST
91831: LIST
91832: LIST
91833: LIST
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: PUSH
91845: LD_INT 101
91847: PUSH
91848: LD_INT 102
91850: PUSH
91851: LD_INT 103
91853: PUSH
91854: LD_INT 104
91856: PUSH
91857: LD_INT 105
91859: PUSH
91860: LD_INT 106
91862: PUSH
91863: LD_INT 107
91865: PUSH
91866: LD_INT 108
91868: PUSH
91869: LD_INT 109
91871: PUSH
91872: LD_INT 110
91874: PUSH
91875: LD_INT 111
91877: PUSH
91878: LD_INT 112
91880: PUSH
91881: LD_INT 113
91883: PUSH
91884: LD_INT 114
91886: PUSH
91887: LD_INT 116
91889: PUSH
91890: LD_INT 117
91892: PUSH
91893: LD_INT 118
91895: PUSH
91896: EMPTY
91897: LIST
91898: LIST
91899: LIST
91900: LIST
91901: LIST
91902: LIST
91903: LIST
91904: LIST
91905: LIST
91906: LIST
91907: LIST
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: LIST
91913: LIST
91914: PUSH
91915: EMPTY
91916: LIST
91917: LIST
91918: ST_TO_ADDR
91919: GO 93158
91921: LD_INT 14
91923: DOUBLE
91924: EQUAL
91925: IFTRUE 91929
91927: GO 92153
91929: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
91930: LD_ADDR_VAR 0 2
91934: PUSH
91935: LD_INT 1
91937: PUSH
91938: LD_INT 2
91940: PUSH
91941: LD_INT 3
91943: PUSH
91944: LD_INT 4
91946: PUSH
91947: LD_INT 5
91949: PUSH
91950: LD_INT 6
91952: PUSH
91953: LD_INT 7
91955: PUSH
91956: LD_INT 8
91958: PUSH
91959: LD_INT 9
91961: PUSH
91962: LD_INT 10
91964: PUSH
91965: LD_INT 11
91967: PUSH
91968: LD_INT 12
91970: PUSH
91971: LD_INT 13
91973: PUSH
91974: LD_INT 14
91976: PUSH
91977: LD_INT 15
91979: PUSH
91980: LD_INT 16
91982: PUSH
91983: LD_INT 17
91985: PUSH
91986: LD_INT 18
91988: PUSH
91989: LD_INT 19
91991: PUSH
91992: LD_INT 20
91994: PUSH
91995: LD_INT 21
91997: PUSH
91998: LD_INT 22
92000: PUSH
92001: LD_INT 23
92003: PUSH
92004: LD_INT 24
92006: PUSH
92007: LD_INT 25
92009: PUSH
92010: LD_INT 26
92012: PUSH
92013: LD_INT 27
92015: PUSH
92016: LD_INT 28
92018: PUSH
92019: LD_INT 29
92021: PUSH
92022: LD_INT 30
92024: PUSH
92025: LD_INT 31
92027: PUSH
92028: LD_INT 32
92030: PUSH
92031: LD_INT 33
92033: PUSH
92034: LD_INT 34
92036: PUSH
92037: LD_INT 36
92039: PUSH
92040: EMPTY
92041: LIST
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: LIST
92049: LIST
92050: LIST
92051: LIST
92052: LIST
92053: LIST
92054: LIST
92055: LIST
92056: LIST
92057: LIST
92058: LIST
92059: LIST
92060: LIST
92061: LIST
92062: LIST
92063: LIST
92064: LIST
92065: LIST
92066: LIST
92067: LIST
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: PUSH
92077: LD_INT 101
92079: PUSH
92080: LD_INT 102
92082: PUSH
92083: LD_INT 103
92085: PUSH
92086: LD_INT 104
92088: PUSH
92089: LD_INT 105
92091: PUSH
92092: LD_INT 106
92094: PUSH
92095: LD_INT 107
92097: PUSH
92098: LD_INT 108
92100: PUSH
92101: LD_INT 109
92103: PUSH
92104: LD_INT 110
92106: PUSH
92107: LD_INT 111
92109: PUSH
92110: LD_INT 112
92112: PUSH
92113: LD_INT 113
92115: PUSH
92116: LD_INT 114
92118: PUSH
92119: LD_INT 116
92121: PUSH
92122: LD_INT 117
92124: PUSH
92125: LD_INT 118
92127: PUSH
92128: EMPTY
92129: LIST
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: LIST
92141: LIST
92142: LIST
92143: LIST
92144: LIST
92145: LIST
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: ST_TO_ADDR
92151: GO 93158
92153: LD_INT 15
92155: DOUBLE
92156: EQUAL
92157: IFTRUE 92161
92159: GO 92385
92161: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
92162: LD_ADDR_VAR 0 2
92166: PUSH
92167: LD_INT 1
92169: PUSH
92170: LD_INT 2
92172: PUSH
92173: LD_INT 3
92175: PUSH
92176: LD_INT 4
92178: PUSH
92179: LD_INT 5
92181: PUSH
92182: LD_INT 6
92184: PUSH
92185: LD_INT 7
92187: PUSH
92188: LD_INT 8
92190: PUSH
92191: LD_INT 9
92193: PUSH
92194: LD_INT 10
92196: PUSH
92197: LD_INT 11
92199: PUSH
92200: LD_INT 12
92202: PUSH
92203: LD_INT 13
92205: PUSH
92206: LD_INT 14
92208: PUSH
92209: LD_INT 15
92211: PUSH
92212: LD_INT 16
92214: PUSH
92215: LD_INT 17
92217: PUSH
92218: LD_INT 18
92220: PUSH
92221: LD_INT 19
92223: PUSH
92224: LD_INT 20
92226: PUSH
92227: LD_INT 21
92229: PUSH
92230: LD_INT 22
92232: PUSH
92233: LD_INT 23
92235: PUSH
92236: LD_INT 24
92238: PUSH
92239: LD_INT 25
92241: PUSH
92242: LD_INT 26
92244: PUSH
92245: LD_INT 27
92247: PUSH
92248: LD_INT 28
92250: PUSH
92251: LD_INT 29
92253: PUSH
92254: LD_INT 30
92256: PUSH
92257: LD_INT 31
92259: PUSH
92260: LD_INT 32
92262: PUSH
92263: LD_INT 33
92265: PUSH
92266: LD_INT 34
92268: PUSH
92269: LD_INT 36
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: LIST
92276: LIST
92277: LIST
92278: LIST
92279: LIST
92280: LIST
92281: LIST
92282: LIST
92283: LIST
92284: LIST
92285: LIST
92286: LIST
92287: LIST
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: LIST
92308: PUSH
92309: LD_INT 101
92311: PUSH
92312: LD_INT 102
92314: PUSH
92315: LD_INT 103
92317: PUSH
92318: LD_INT 104
92320: PUSH
92321: LD_INT 105
92323: PUSH
92324: LD_INT 106
92326: PUSH
92327: LD_INT 107
92329: PUSH
92330: LD_INT 108
92332: PUSH
92333: LD_INT 109
92335: PUSH
92336: LD_INT 110
92338: PUSH
92339: LD_INT 111
92341: PUSH
92342: LD_INT 112
92344: PUSH
92345: LD_INT 113
92347: PUSH
92348: LD_INT 114
92350: PUSH
92351: LD_INT 116
92353: PUSH
92354: LD_INT 117
92356: PUSH
92357: LD_INT 118
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: PUSH
92379: EMPTY
92380: LIST
92381: LIST
92382: ST_TO_ADDR
92383: GO 93158
92385: LD_INT 16
92387: DOUBLE
92388: EQUAL
92389: IFTRUE 92393
92391: GO 92529
92393: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
92394: LD_ADDR_VAR 0 2
92398: PUSH
92399: LD_INT 2
92401: PUSH
92402: LD_INT 4
92404: PUSH
92405: LD_INT 5
92407: PUSH
92408: LD_INT 7
92410: PUSH
92411: LD_INT 11
92413: PUSH
92414: LD_INT 12
92416: PUSH
92417: LD_INT 15
92419: PUSH
92420: LD_INT 16
92422: PUSH
92423: LD_INT 20
92425: PUSH
92426: LD_INT 21
92428: PUSH
92429: LD_INT 22
92431: PUSH
92432: LD_INT 23
92434: PUSH
92435: LD_INT 25
92437: PUSH
92438: LD_INT 26
92440: PUSH
92441: LD_INT 30
92443: PUSH
92444: LD_INT 31
92446: PUSH
92447: LD_INT 32
92449: PUSH
92450: LD_INT 33
92452: PUSH
92453: LD_INT 34
92455: PUSH
92456: EMPTY
92457: LIST
92458: LIST
92459: LIST
92460: LIST
92461: LIST
92462: LIST
92463: LIST
92464: LIST
92465: LIST
92466: LIST
92467: LIST
92468: LIST
92469: LIST
92470: LIST
92471: LIST
92472: LIST
92473: LIST
92474: LIST
92475: LIST
92476: PUSH
92477: LD_INT 101
92479: PUSH
92480: LD_INT 102
92482: PUSH
92483: LD_INT 103
92485: PUSH
92486: LD_INT 106
92488: PUSH
92489: LD_INT 108
92491: PUSH
92492: LD_INT 112
92494: PUSH
92495: LD_INT 113
92497: PUSH
92498: LD_INT 114
92500: PUSH
92501: LD_INT 116
92503: PUSH
92504: LD_INT 117
92506: PUSH
92507: LD_INT 118
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: LIST
92514: LIST
92515: LIST
92516: LIST
92517: LIST
92518: LIST
92519: LIST
92520: LIST
92521: LIST
92522: PUSH
92523: EMPTY
92524: LIST
92525: LIST
92526: ST_TO_ADDR
92527: GO 93158
92529: LD_INT 17
92531: DOUBLE
92532: EQUAL
92533: IFTRUE 92537
92535: GO 92761
92537: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
92538: LD_ADDR_VAR 0 2
92542: PUSH
92543: LD_INT 1
92545: PUSH
92546: LD_INT 2
92548: PUSH
92549: LD_INT 3
92551: PUSH
92552: LD_INT 4
92554: PUSH
92555: LD_INT 5
92557: PUSH
92558: LD_INT 6
92560: PUSH
92561: LD_INT 7
92563: PUSH
92564: LD_INT 8
92566: PUSH
92567: LD_INT 9
92569: PUSH
92570: LD_INT 10
92572: PUSH
92573: LD_INT 11
92575: PUSH
92576: LD_INT 12
92578: PUSH
92579: LD_INT 13
92581: PUSH
92582: LD_INT 14
92584: PUSH
92585: LD_INT 15
92587: PUSH
92588: LD_INT 16
92590: PUSH
92591: LD_INT 17
92593: PUSH
92594: LD_INT 18
92596: PUSH
92597: LD_INT 19
92599: PUSH
92600: LD_INT 20
92602: PUSH
92603: LD_INT 21
92605: PUSH
92606: LD_INT 22
92608: PUSH
92609: LD_INT 23
92611: PUSH
92612: LD_INT 24
92614: PUSH
92615: LD_INT 25
92617: PUSH
92618: LD_INT 26
92620: PUSH
92621: LD_INT 27
92623: PUSH
92624: LD_INT 28
92626: PUSH
92627: LD_INT 29
92629: PUSH
92630: LD_INT 30
92632: PUSH
92633: LD_INT 31
92635: PUSH
92636: LD_INT 32
92638: PUSH
92639: LD_INT 33
92641: PUSH
92642: LD_INT 34
92644: PUSH
92645: LD_INT 36
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: LIST
92652: LIST
92653: LIST
92654: LIST
92655: LIST
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: PUSH
92685: LD_INT 101
92687: PUSH
92688: LD_INT 102
92690: PUSH
92691: LD_INT 103
92693: PUSH
92694: LD_INT 104
92696: PUSH
92697: LD_INT 105
92699: PUSH
92700: LD_INT 106
92702: PUSH
92703: LD_INT 107
92705: PUSH
92706: LD_INT 108
92708: PUSH
92709: LD_INT 109
92711: PUSH
92712: LD_INT 110
92714: PUSH
92715: LD_INT 111
92717: PUSH
92718: LD_INT 112
92720: PUSH
92721: LD_INT 113
92723: PUSH
92724: LD_INT 114
92726: PUSH
92727: LD_INT 116
92729: PUSH
92730: LD_INT 117
92732: PUSH
92733: LD_INT 118
92735: PUSH
92736: EMPTY
92737: LIST
92738: LIST
92739: LIST
92740: LIST
92741: LIST
92742: LIST
92743: LIST
92744: LIST
92745: LIST
92746: LIST
92747: LIST
92748: LIST
92749: LIST
92750: LIST
92751: LIST
92752: LIST
92753: LIST
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: ST_TO_ADDR
92759: GO 93158
92761: LD_INT 18
92763: DOUBLE
92764: EQUAL
92765: IFTRUE 92769
92767: GO 92917
92769: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
92770: LD_ADDR_VAR 0 2
92774: PUSH
92775: LD_INT 2
92777: PUSH
92778: LD_INT 4
92780: PUSH
92781: LD_INT 5
92783: PUSH
92784: LD_INT 7
92786: PUSH
92787: LD_INT 11
92789: PUSH
92790: LD_INT 12
92792: PUSH
92793: LD_INT 15
92795: PUSH
92796: LD_INT 16
92798: PUSH
92799: LD_INT 20
92801: PUSH
92802: LD_INT 21
92804: PUSH
92805: LD_INT 22
92807: PUSH
92808: LD_INT 23
92810: PUSH
92811: LD_INT 25
92813: PUSH
92814: LD_INT 26
92816: PUSH
92817: LD_INT 30
92819: PUSH
92820: LD_INT 31
92822: PUSH
92823: LD_INT 32
92825: PUSH
92826: LD_INT 33
92828: PUSH
92829: LD_INT 34
92831: PUSH
92832: LD_INT 35
92834: PUSH
92835: LD_INT 36
92837: PUSH
92838: EMPTY
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: PUSH
92861: LD_INT 101
92863: PUSH
92864: LD_INT 102
92866: PUSH
92867: LD_INT 103
92869: PUSH
92870: LD_INT 106
92872: PUSH
92873: LD_INT 108
92875: PUSH
92876: LD_INT 112
92878: PUSH
92879: LD_INT 113
92881: PUSH
92882: LD_INT 114
92884: PUSH
92885: LD_INT 115
92887: PUSH
92888: LD_INT 116
92890: PUSH
92891: LD_INT 117
92893: PUSH
92894: LD_INT 118
92896: PUSH
92897: EMPTY
92898: LIST
92899: LIST
92900: LIST
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: PUSH
92911: EMPTY
92912: LIST
92913: LIST
92914: ST_TO_ADDR
92915: GO 93158
92917: LD_INT 19
92919: DOUBLE
92920: EQUAL
92921: IFTRUE 92925
92923: GO 93157
92925: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
92926: LD_ADDR_VAR 0 2
92930: PUSH
92931: LD_INT 1
92933: PUSH
92934: LD_INT 2
92936: PUSH
92937: LD_INT 3
92939: PUSH
92940: LD_INT 4
92942: PUSH
92943: LD_INT 5
92945: PUSH
92946: LD_INT 6
92948: PUSH
92949: LD_INT 7
92951: PUSH
92952: LD_INT 8
92954: PUSH
92955: LD_INT 9
92957: PUSH
92958: LD_INT 10
92960: PUSH
92961: LD_INT 11
92963: PUSH
92964: LD_INT 12
92966: PUSH
92967: LD_INT 13
92969: PUSH
92970: LD_INT 14
92972: PUSH
92973: LD_INT 15
92975: PUSH
92976: LD_INT 16
92978: PUSH
92979: LD_INT 17
92981: PUSH
92982: LD_INT 18
92984: PUSH
92985: LD_INT 19
92987: PUSH
92988: LD_INT 20
92990: PUSH
92991: LD_INT 21
92993: PUSH
92994: LD_INT 22
92996: PUSH
92997: LD_INT 23
92999: PUSH
93000: LD_INT 24
93002: PUSH
93003: LD_INT 25
93005: PUSH
93006: LD_INT 26
93008: PUSH
93009: LD_INT 27
93011: PUSH
93012: LD_INT 28
93014: PUSH
93015: LD_INT 29
93017: PUSH
93018: LD_INT 30
93020: PUSH
93021: LD_INT 31
93023: PUSH
93024: LD_INT 32
93026: PUSH
93027: LD_INT 33
93029: PUSH
93030: LD_INT 34
93032: PUSH
93033: LD_INT 35
93035: PUSH
93036: LD_INT 36
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: LIST
93046: LIST
93047: LIST
93048: LIST
93049: LIST
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: LIST
93058: LIST
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: LIST
93067: LIST
93068: LIST
93069: LIST
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: PUSH
93077: LD_INT 101
93079: PUSH
93080: LD_INT 102
93082: PUSH
93083: LD_INT 103
93085: PUSH
93086: LD_INT 104
93088: PUSH
93089: LD_INT 105
93091: PUSH
93092: LD_INT 106
93094: PUSH
93095: LD_INT 107
93097: PUSH
93098: LD_INT 108
93100: PUSH
93101: LD_INT 109
93103: PUSH
93104: LD_INT 110
93106: PUSH
93107: LD_INT 111
93109: PUSH
93110: LD_INT 112
93112: PUSH
93113: LD_INT 113
93115: PUSH
93116: LD_INT 114
93118: PUSH
93119: LD_INT 115
93121: PUSH
93122: LD_INT 116
93124: PUSH
93125: LD_INT 117
93127: PUSH
93128: LD_INT 118
93130: PUSH
93131: EMPTY
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: PUSH
93151: EMPTY
93152: LIST
93153: LIST
93154: ST_TO_ADDR
93155: GO 93158
93157: POP
// end else
93158: GO 93389
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
93160: LD_ADDR_VAR 0 2
93164: PUSH
93165: LD_INT 1
93167: PUSH
93168: LD_INT 2
93170: PUSH
93171: LD_INT 3
93173: PUSH
93174: LD_INT 4
93176: PUSH
93177: LD_INT 5
93179: PUSH
93180: LD_INT 6
93182: PUSH
93183: LD_INT 7
93185: PUSH
93186: LD_INT 8
93188: PUSH
93189: LD_INT 9
93191: PUSH
93192: LD_INT 10
93194: PUSH
93195: LD_INT 11
93197: PUSH
93198: LD_INT 12
93200: PUSH
93201: LD_INT 13
93203: PUSH
93204: LD_INT 14
93206: PUSH
93207: LD_INT 15
93209: PUSH
93210: LD_INT 16
93212: PUSH
93213: LD_INT 17
93215: PUSH
93216: LD_INT 18
93218: PUSH
93219: LD_INT 19
93221: PUSH
93222: LD_INT 20
93224: PUSH
93225: LD_INT 21
93227: PUSH
93228: LD_INT 22
93230: PUSH
93231: LD_INT 23
93233: PUSH
93234: LD_INT 24
93236: PUSH
93237: LD_INT 25
93239: PUSH
93240: LD_INT 26
93242: PUSH
93243: LD_INT 27
93245: PUSH
93246: LD_INT 28
93248: PUSH
93249: LD_INT 29
93251: PUSH
93252: LD_INT 30
93254: PUSH
93255: LD_INT 31
93257: PUSH
93258: LD_INT 32
93260: PUSH
93261: LD_INT 33
93263: PUSH
93264: LD_INT 34
93266: PUSH
93267: LD_INT 35
93269: PUSH
93270: LD_INT 36
93272: PUSH
93273: EMPTY
93274: LIST
93275: LIST
93276: LIST
93277: LIST
93278: LIST
93279: LIST
93280: LIST
93281: LIST
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: LIST
93298: LIST
93299: LIST
93300: LIST
93301: LIST
93302: LIST
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: LIST
93308: LIST
93309: LIST
93310: PUSH
93311: LD_INT 101
93313: PUSH
93314: LD_INT 102
93316: PUSH
93317: LD_INT 103
93319: PUSH
93320: LD_INT 104
93322: PUSH
93323: LD_INT 105
93325: PUSH
93326: LD_INT 106
93328: PUSH
93329: LD_INT 107
93331: PUSH
93332: LD_INT 108
93334: PUSH
93335: LD_INT 109
93337: PUSH
93338: LD_INT 110
93340: PUSH
93341: LD_INT 111
93343: PUSH
93344: LD_INT 112
93346: PUSH
93347: LD_INT 113
93349: PUSH
93350: LD_INT 114
93352: PUSH
93353: LD_INT 115
93355: PUSH
93356: LD_INT 116
93358: PUSH
93359: LD_INT 117
93361: PUSH
93362: LD_INT 118
93364: PUSH
93365: EMPTY
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: PUSH
93385: EMPTY
93386: LIST
93387: LIST
93388: ST_TO_ADDR
// if result then
93389: LD_VAR 0 2
93393: IFFALSE 94179
// begin normal :=  ;
93395: LD_ADDR_VAR 0 5
93399: PUSH
93400: LD_STRING 
93402: ST_TO_ADDR
// hardcore :=  ;
93403: LD_ADDR_VAR 0 6
93407: PUSH
93408: LD_STRING 
93410: ST_TO_ADDR
// active :=  ;
93411: LD_ADDR_VAR 0 7
93415: PUSH
93416: LD_STRING 
93418: ST_TO_ADDR
// for i = 1 to normalCounter do
93419: LD_ADDR_VAR 0 8
93423: PUSH
93424: DOUBLE
93425: LD_INT 1
93427: DEC
93428: ST_TO_ADDR
93429: LD_EXP 108
93433: PUSH
93434: FOR_TO
93435: IFFALSE 93536
// begin tmp := 0 ;
93437: LD_ADDR_VAR 0 3
93441: PUSH
93442: LD_STRING 0
93444: ST_TO_ADDR
// if result [ 1 ] then
93445: LD_VAR 0 2
93449: PUSH
93450: LD_INT 1
93452: ARRAY
93453: IFFALSE 93518
// if result [ 1 ] [ 1 ] = i then
93455: LD_VAR 0 2
93459: PUSH
93460: LD_INT 1
93462: ARRAY
93463: PUSH
93464: LD_INT 1
93466: ARRAY
93467: PUSH
93468: LD_VAR 0 8
93472: EQUAL
93473: IFFALSE 93518
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
93475: LD_ADDR_VAR 0 2
93479: PUSH
93480: LD_VAR 0 2
93484: PPUSH
93485: LD_INT 1
93487: PPUSH
93488: LD_VAR 0 2
93492: PUSH
93493: LD_INT 1
93495: ARRAY
93496: PPUSH
93497: LD_INT 1
93499: PPUSH
93500: CALL_OW 3
93504: PPUSH
93505: CALL_OW 1
93509: ST_TO_ADDR
// tmp := 1 ;
93510: LD_ADDR_VAR 0 3
93514: PUSH
93515: LD_STRING 1
93517: ST_TO_ADDR
// end ; normal := normal & tmp ;
93518: LD_ADDR_VAR 0 5
93522: PUSH
93523: LD_VAR 0 5
93527: PUSH
93528: LD_VAR 0 3
93532: STR
93533: ST_TO_ADDR
// end ;
93534: GO 93434
93536: POP
93537: POP
// for i = 1 to hardcoreCounter do
93538: LD_ADDR_VAR 0 8
93542: PUSH
93543: DOUBLE
93544: LD_INT 1
93546: DEC
93547: ST_TO_ADDR
93548: LD_EXP 109
93552: PUSH
93553: FOR_TO
93554: IFFALSE 93659
// begin tmp := 0 ;
93556: LD_ADDR_VAR 0 3
93560: PUSH
93561: LD_STRING 0
93563: ST_TO_ADDR
// if result [ 2 ] then
93564: LD_VAR 0 2
93568: PUSH
93569: LD_INT 2
93571: ARRAY
93572: IFFALSE 93641
// if result [ 2 ] [ 1 ] = 100 + i then
93574: LD_VAR 0 2
93578: PUSH
93579: LD_INT 2
93581: ARRAY
93582: PUSH
93583: LD_INT 1
93585: ARRAY
93586: PUSH
93587: LD_INT 100
93589: PUSH
93590: LD_VAR 0 8
93594: PLUS
93595: EQUAL
93596: IFFALSE 93641
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
93598: LD_ADDR_VAR 0 2
93602: PUSH
93603: LD_VAR 0 2
93607: PPUSH
93608: LD_INT 2
93610: PPUSH
93611: LD_VAR 0 2
93615: PUSH
93616: LD_INT 2
93618: ARRAY
93619: PPUSH
93620: LD_INT 1
93622: PPUSH
93623: CALL_OW 3
93627: PPUSH
93628: CALL_OW 1
93632: ST_TO_ADDR
// tmp := 1 ;
93633: LD_ADDR_VAR 0 3
93637: PUSH
93638: LD_STRING 1
93640: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
93641: LD_ADDR_VAR 0 6
93645: PUSH
93646: LD_VAR 0 6
93650: PUSH
93651: LD_VAR 0 3
93655: STR
93656: ST_TO_ADDR
// end ;
93657: GO 93553
93659: POP
93660: POP
// if isGameLoad then
93661: LD_VAR 0 1
93665: IFFALSE 94140
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
93667: LD_ADDR_VAR 0 4
93671: PUSH
93672: LD_EXP 112
93676: PUSH
93677: LD_EXP 111
93681: PUSH
93682: LD_EXP 113
93686: PUSH
93687: LD_EXP 110
93691: PUSH
93692: LD_EXP 114
93696: PUSH
93697: LD_EXP 115
93701: PUSH
93702: LD_EXP 116
93706: PUSH
93707: LD_EXP 117
93711: PUSH
93712: LD_EXP 118
93716: PUSH
93717: LD_EXP 119
93721: PUSH
93722: LD_EXP 120
93726: PUSH
93727: LD_EXP 121
93731: PUSH
93732: LD_EXP 122
93736: PUSH
93737: LD_EXP 123
93741: PUSH
93742: LD_EXP 131
93746: PUSH
93747: LD_EXP 132
93751: PUSH
93752: LD_EXP 133
93756: PUSH
93757: LD_EXP 134
93761: PUSH
93762: LD_EXP 136
93766: PUSH
93767: LD_EXP 137
93771: PUSH
93772: LD_EXP 138
93776: PUSH
93777: LD_EXP 141
93781: PUSH
93782: LD_EXP 143
93786: PUSH
93787: LD_EXP 144
93791: PUSH
93792: LD_EXP 145
93796: PUSH
93797: LD_EXP 147
93801: PUSH
93802: LD_EXP 148
93806: PUSH
93807: LD_EXP 151
93811: PUSH
93812: LD_EXP 152
93816: PUSH
93817: LD_EXP 153
93821: PUSH
93822: LD_EXP 154
93826: PUSH
93827: LD_EXP 155
93831: PUSH
93832: LD_EXP 156
93836: PUSH
93837: LD_EXP 157
93841: PUSH
93842: LD_EXP 158
93846: PUSH
93847: LD_EXP 159
93851: PUSH
93852: LD_EXP 124
93856: PUSH
93857: LD_EXP 125
93861: PUSH
93862: LD_EXP 128
93866: PUSH
93867: LD_EXP 129
93871: PUSH
93872: LD_EXP 130
93876: PUSH
93877: LD_EXP 126
93881: PUSH
93882: LD_EXP 127
93886: PUSH
93887: LD_EXP 135
93891: PUSH
93892: LD_EXP 139
93896: PUSH
93897: LD_EXP 140
93901: PUSH
93902: LD_EXP 142
93906: PUSH
93907: LD_EXP 146
93911: PUSH
93912: LD_EXP 149
93916: PUSH
93917: LD_EXP 150
93921: PUSH
93922: LD_EXP 160
93926: PUSH
93927: LD_EXP 161
93931: PUSH
93932: LD_EXP 162
93936: PUSH
93937: LD_EXP 163
93941: PUSH
93942: EMPTY
93943: LIST
93944: LIST
93945: LIST
93946: LIST
93947: LIST
93948: LIST
93949: LIST
93950: LIST
93951: LIST
93952: LIST
93953: LIST
93954: LIST
93955: LIST
93956: LIST
93957: LIST
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: LIST
93967: LIST
93968: LIST
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: LIST
93980: LIST
93981: LIST
93982: LIST
93983: LIST
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: LIST
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: ST_TO_ADDR
// tmp :=  ;
93998: LD_ADDR_VAR 0 3
94002: PUSH
94003: LD_STRING 
94005: ST_TO_ADDR
// for i = 1 to normalCounter do
94006: LD_ADDR_VAR 0 8
94010: PUSH
94011: DOUBLE
94012: LD_INT 1
94014: DEC
94015: ST_TO_ADDR
94016: LD_EXP 108
94020: PUSH
94021: FOR_TO
94022: IFFALSE 94058
// begin if flags [ i ] then
94024: LD_VAR 0 4
94028: PUSH
94029: LD_VAR 0 8
94033: ARRAY
94034: IFFALSE 94056
// tmp := tmp & i & ; ;
94036: LD_ADDR_VAR 0 3
94040: PUSH
94041: LD_VAR 0 3
94045: PUSH
94046: LD_VAR 0 8
94050: STR
94051: PUSH
94052: LD_STRING ;
94054: STR
94055: ST_TO_ADDR
// end ;
94056: GO 94021
94058: POP
94059: POP
// for i = 1 to hardcoreCounter do
94060: LD_ADDR_VAR 0 8
94064: PUSH
94065: DOUBLE
94066: LD_INT 1
94068: DEC
94069: ST_TO_ADDR
94070: LD_EXP 109
94074: PUSH
94075: FOR_TO
94076: IFFALSE 94122
// begin if flags [ normalCounter + i ] then
94078: LD_VAR 0 4
94082: PUSH
94083: LD_EXP 108
94087: PUSH
94088: LD_VAR 0 8
94092: PLUS
94093: ARRAY
94094: IFFALSE 94120
// tmp := tmp & ( 100 + i ) & ; ;
94096: LD_ADDR_VAR 0 3
94100: PUSH
94101: LD_VAR 0 3
94105: PUSH
94106: LD_INT 100
94108: PUSH
94109: LD_VAR 0 8
94113: PLUS
94114: STR
94115: PUSH
94116: LD_STRING ;
94118: STR
94119: ST_TO_ADDR
// end ;
94120: GO 94075
94122: POP
94123: POP
// if tmp then
94124: LD_VAR 0 3
94128: IFFALSE 94140
// active := tmp ;
94130: LD_ADDR_VAR 0 7
94134: PUSH
94135: LD_VAR 0 3
94139: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
94140: LD_STRING getStreamItemsFromMission("
94142: PUSH
94143: LD_VAR 0 5
94147: STR
94148: PUSH
94149: LD_STRING ","
94151: STR
94152: PUSH
94153: LD_VAR 0 6
94157: STR
94158: PUSH
94159: LD_STRING ","
94161: STR
94162: PUSH
94163: LD_VAR 0 7
94167: STR
94168: PUSH
94169: LD_STRING ")
94171: STR
94172: PPUSH
94173: CALL_OW 559
// end else
94177: GO 94186
// ToLua ( getStreamItemsFromMission("","","") ) ;
94179: LD_STRING getStreamItemsFromMission("","","")
94181: PPUSH
94182: CALL_OW 559
// end ;
94186: LD_VAR 0 2
94190: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
94191: LD_EXP 107
94195: PUSH
94196: LD_EXP 112
94200: AND
94201: IFFALSE 94325
94203: GO 94205
94205: DISABLE
94206: LD_INT 0
94208: PPUSH
94209: PPUSH
// begin enable ;
94210: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
94211: LD_ADDR_VAR 0 2
94215: PUSH
94216: LD_INT 22
94218: PUSH
94219: LD_OWVAR 2
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: PUSH
94228: LD_INT 2
94230: PUSH
94231: LD_INT 34
94233: PUSH
94234: LD_INT 7
94236: PUSH
94237: EMPTY
94238: LIST
94239: LIST
94240: PUSH
94241: LD_INT 34
94243: PUSH
94244: LD_INT 45
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 34
94253: PUSH
94254: LD_INT 28
94256: PUSH
94257: EMPTY
94258: LIST
94259: LIST
94260: PUSH
94261: LD_INT 34
94263: PUSH
94264: LD_INT 47
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: PUSH
94278: EMPTY
94279: LIST
94280: LIST
94281: PPUSH
94282: CALL_OW 69
94286: ST_TO_ADDR
// if not tmp then
94287: LD_VAR 0 2
94291: NOT
94292: IFFALSE 94296
// exit ;
94294: GO 94325
// for i in tmp do
94296: LD_ADDR_VAR 0 1
94300: PUSH
94301: LD_VAR 0 2
94305: PUSH
94306: FOR_IN
94307: IFFALSE 94323
// begin SetLives ( i , 0 ) ;
94309: LD_VAR 0 1
94313: PPUSH
94314: LD_INT 0
94316: PPUSH
94317: CALL_OW 234
// end ;
94321: GO 94306
94323: POP
94324: POP
// end ;
94325: PPOPN 2
94327: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
94328: LD_EXP 107
94332: PUSH
94333: LD_EXP 113
94337: AND
94338: IFFALSE 94422
94340: GO 94342
94342: DISABLE
94343: LD_INT 0
94345: PPUSH
94346: PPUSH
// begin enable ;
94347: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
94348: LD_ADDR_VAR 0 2
94352: PUSH
94353: LD_INT 22
94355: PUSH
94356: LD_OWVAR 2
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 32
94367: PUSH
94368: LD_INT 3
94370: PUSH
94371: EMPTY
94372: LIST
94373: LIST
94374: PUSH
94375: EMPTY
94376: LIST
94377: LIST
94378: PPUSH
94379: CALL_OW 69
94383: ST_TO_ADDR
// if not tmp then
94384: LD_VAR 0 2
94388: NOT
94389: IFFALSE 94393
// exit ;
94391: GO 94422
// for i in tmp do
94393: LD_ADDR_VAR 0 1
94397: PUSH
94398: LD_VAR 0 2
94402: PUSH
94403: FOR_IN
94404: IFFALSE 94420
// begin SetLives ( i , 0 ) ;
94406: LD_VAR 0 1
94410: PPUSH
94411: LD_INT 0
94413: PPUSH
94414: CALL_OW 234
// end ;
94418: GO 94403
94420: POP
94421: POP
// end ;
94422: PPOPN 2
94424: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
94425: LD_EXP 107
94429: PUSH
94430: LD_EXP 110
94434: AND
94435: IFFALSE 94528
94437: GO 94439
94439: DISABLE
94440: LD_INT 0
94442: PPUSH
// begin enable ;
94443: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
94444: LD_ADDR_VAR 0 1
94448: PUSH
94449: LD_INT 22
94451: PUSH
94452: LD_OWVAR 2
94456: PUSH
94457: EMPTY
94458: LIST
94459: LIST
94460: PUSH
94461: LD_INT 2
94463: PUSH
94464: LD_INT 25
94466: PUSH
94467: LD_INT 5
94469: PUSH
94470: EMPTY
94471: LIST
94472: LIST
94473: PUSH
94474: LD_INT 25
94476: PUSH
94477: LD_INT 9
94479: PUSH
94480: EMPTY
94481: LIST
94482: LIST
94483: PUSH
94484: LD_INT 25
94486: PUSH
94487: LD_INT 8
94489: PUSH
94490: EMPTY
94491: LIST
94492: LIST
94493: PUSH
94494: EMPTY
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: PUSH
94500: EMPTY
94501: LIST
94502: LIST
94503: PPUSH
94504: CALL_OW 69
94508: PUSH
94509: FOR_IN
94510: IFFALSE 94526
// begin SetClass ( i , 1 ) ;
94512: LD_VAR 0 1
94516: PPUSH
94517: LD_INT 1
94519: PPUSH
94520: CALL_OW 336
// end ;
94524: GO 94509
94526: POP
94527: POP
// end ;
94528: PPOPN 1
94530: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
94531: LD_EXP 107
94535: PUSH
94536: LD_EXP 111
94540: AND
94541: PUSH
94542: LD_OWVAR 65
94546: PUSH
94547: LD_INT 7
94549: LESS
94550: AND
94551: IFFALSE 94565
94553: GO 94555
94555: DISABLE
// begin enable ;
94556: ENABLE
// game_speed := 7 ;
94557: LD_ADDR_OWVAR 65
94561: PUSH
94562: LD_INT 7
94564: ST_TO_ADDR
// end ;
94565: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
94566: LD_EXP 107
94570: PUSH
94571: LD_EXP 114
94575: AND
94576: IFFALSE 94778
94578: GO 94580
94580: DISABLE
94581: LD_INT 0
94583: PPUSH
94584: PPUSH
94585: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
94586: LD_ADDR_VAR 0 3
94590: PUSH
94591: LD_INT 81
94593: PUSH
94594: LD_OWVAR 2
94598: PUSH
94599: EMPTY
94600: LIST
94601: LIST
94602: PUSH
94603: LD_INT 21
94605: PUSH
94606: LD_INT 1
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: PPUSH
94617: CALL_OW 69
94621: ST_TO_ADDR
// if not tmp then
94622: LD_VAR 0 3
94626: NOT
94627: IFFALSE 94631
// exit ;
94629: GO 94778
// if tmp > 5 then
94631: LD_VAR 0 3
94635: PUSH
94636: LD_INT 5
94638: GREATER
94639: IFFALSE 94651
// k := 5 else
94641: LD_ADDR_VAR 0 2
94645: PUSH
94646: LD_INT 5
94648: ST_TO_ADDR
94649: GO 94661
// k := tmp ;
94651: LD_ADDR_VAR 0 2
94655: PUSH
94656: LD_VAR 0 3
94660: ST_TO_ADDR
// for i := 1 to k do
94661: LD_ADDR_VAR 0 1
94665: PUSH
94666: DOUBLE
94667: LD_INT 1
94669: DEC
94670: ST_TO_ADDR
94671: LD_VAR 0 2
94675: PUSH
94676: FOR_TO
94677: IFFALSE 94776
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
94679: LD_VAR 0 3
94683: PUSH
94684: LD_VAR 0 1
94688: ARRAY
94689: PPUSH
94690: LD_VAR 0 1
94694: PUSH
94695: LD_INT 4
94697: MOD
94698: PUSH
94699: LD_INT 1
94701: PLUS
94702: PPUSH
94703: CALL_OW 259
94707: PUSH
94708: LD_INT 10
94710: LESS
94711: IFFALSE 94774
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
94713: LD_VAR 0 3
94717: PUSH
94718: LD_VAR 0 1
94722: ARRAY
94723: PPUSH
94724: LD_VAR 0 1
94728: PUSH
94729: LD_INT 4
94731: MOD
94732: PUSH
94733: LD_INT 1
94735: PLUS
94736: PPUSH
94737: LD_VAR 0 3
94741: PUSH
94742: LD_VAR 0 1
94746: ARRAY
94747: PPUSH
94748: LD_VAR 0 1
94752: PUSH
94753: LD_INT 4
94755: MOD
94756: PUSH
94757: LD_INT 1
94759: PLUS
94760: PPUSH
94761: CALL_OW 259
94765: PUSH
94766: LD_INT 1
94768: PLUS
94769: PPUSH
94770: CALL_OW 237
94774: GO 94676
94776: POP
94777: POP
// end ;
94778: PPOPN 3
94780: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
94781: LD_EXP 107
94785: PUSH
94786: LD_EXP 115
94790: AND
94791: IFFALSE 94811
94793: GO 94795
94795: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
94796: LD_INT 4
94798: PPUSH
94799: LD_OWVAR 2
94803: PPUSH
94804: LD_INT 0
94806: PPUSH
94807: CALL_OW 324
94811: END
// every 0 0$1 trigger StreamModeActive and sShovel do
94812: LD_EXP 107
94816: PUSH
94817: LD_EXP 144
94821: AND
94822: IFFALSE 94842
94824: GO 94826
94826: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
94827: LD_INT 19
94829: PPUSH
94830: LD_OWVAR 2
94834: PPUSH
94835: LD_INT 0
94837: PPUSH
94838: CALL_OW 324
94842: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
94843: LD_EXP 107
94847: PUSH
94848: LD_EXP 116
94852: AND
94853: IFFALSE 94955
94855: GO 94857
94857: DISABLE
94858: LD_INT 0
94860: PPUSH
94861: PPUSH
// begin enable ;
94862: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
94863: LD_ADDR_VAR 0 2
94867: PUSH
94868: LD_INT 22
94870: PUSH
94871: LD_OWVAR 2
94875: PUSH
94876: EMPTY
94877: LIST
94878: LIST
94879: PUSH
94880: LD_INT 2
94882: PUSH
94883: LD_INT 34
94885: PUSH
94886: LD_INT 11
94888: PUSH
94889: EMPTY
94890: LIST
94891: LIST
94892: PUSH
94893: LD_INT 34
94895: PUSH
94896: LD_INT 30
94898: PUSH
94899: EMPTY
94900: LIST
94901: LIST
94902: PUSH
94903: EMPTY
94904: LIST
94905: LIST
94906: LIST
94907: PUSH
94908: EMPTY
94909: LIST
94910: LIST
94911: PPUSH
94912: CALL_OW 69
94916: ST_TO_ADDR
// if not tmp then
94917: LD_VAR 0 2
94921: NOT
94922: IFFALSE 94926
// exit ;
94924: GO 94955
// for i in tmp do
94926: LD_ADDR_VAR 0 1
94930: PUSH
94931: LD_VAR 0 2
94935: PUSH
94936: FOR_IN
94937: IFFALSE 94953
// begin SetLives ( i , 0 ) ;
94939: LD_VAR 0 1
94943: PPUSH
94944: LD_INT 0
94946: PPUSH
94947: CALL_OW 234
// end ;
94951: GO 94936
94953: POP
94954: POP
// end ;
94955: PPOPN 2
94957: END
// every 0 0$1 trigger StreamModeActive and sBunker do
94958: LD_EXP 107
94962: PUSH
94963: LD_EXP 117
94967: AND
94968: IFFALSE 94988
94970: GO 94972
94972: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
94973: LD_INT 32
94975: PPUSH
94976: LD_OWVAR 2
94980: PPUSH
94981: LD_INT 0
94983: PPUSH
94984: CALL_OW 324
94988: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
94989: LD_EXP 107
94993: PUSH
94994: LD_EXP 118
94998: AND
94999: IFFALSE 95180
95001: GO 95003
95003: DISABLE
95004: LD_INT 0
95006: PPUSH
95007: PPUSH
95008: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
95009: LD_ADDR_VAR 0 2
95013: PUSH
95014: LD_INT 22
95016: PUSH
95017: LD_OWVAR 2
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: PUSH
95026: LD_INT 33
95028: PUSH
95029: LD_INT 3
95031: PUSH
95032: EMPTY
95033: LIST
95034: LIST
95035: PUSH
95036: EMPTY
95037: LIST
95038: LIST
95039: PPUSH
95040: CALL_OW 69
95044: ST_TO_ADDR
// if not tmp then
95045: LD_VAR 0 2
95049: NOT
95050: IFFALSE 95054
// exit ;
95052: GO 95180
// side := 0 ;
95054: LD_ADDR_VAR 0 3
95058: PUSH
95059: LD_INT 0
95061: ST_TO_ADDR
// for i := 1 to 8 do
95062: LD_ADDR_VAR 0 1
95066: PUSH
95067: DOUBLE
95068: LD_INT 1
95070: DEC
95071: ST_TO_ADDR
95072: LD_INT 8
95074: PUSH
95075: FOR_TO
95076: IFFALSE 95124
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
95078: LD_OWVAR 2
95082: PUSH
95083: LD_VAR 0 1
95087: NONEQUAL
95088: PUSH
95089: LD_OWVAR 2
95093: PPUSH
95094: LD_VAR 0 1
95098: PPUSH
95099: CALL_OW 81
95103: PUSH
95104: LD_INT 2
95106: EQUAL
95107: AND
95108: IFFALSE 95122
// begin side := i ;
95110: LD_ADDR_VAR 0 3
95114: PUSH
95115: LD_VAR 0 1
95119: ST_TO_ADDR
// break ;
95120: GO 95124
// end ;
95122: GO 95075
95124: POP
95125: POP
// if not side then
95126: LD_VAR 0 3
95130: NOT
95131: IFFALSE 95135
// exit ;
95133: GO 95180
// for i := 1 to tmp do
95135: LD_ADDR_VAR 0 1
95139: PUSH
95140: DOUBLE
95141: LD_INT 1
95143: DEC
95144: ST_TO_ADDR
95145: LD_VAR 0 2
95149: PUSH
95150: FOR_TO
95151: IFFALSE 95178
// if Prob ( 60 ) then
95153: LD_INT 60
95155: PPUSH
95156: CALL_OW 13
95160: IFFALSE 95176
// SetSide ( i , side ) ;
95162: LD_VAR 0 1
95166: PPUSH
95167: LD_VAR 0 3
95171: PPUSH
95172: CALL_OW 235
95176: GO 95150
95178: POP
95179: POP
// end ;
95180: PPOPN 3
95182: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
95183: LD_EXP 107
95187: PUSH
95188: LD_EXP 120
95192: AND
95193: IFFALSE 95312
95195: GO 95197
95197: DISABLE
95198: LD_INT 0
95200: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
95201: LD_ADDR_VAR 0 1
95205: PUSH
95206: LD_INT 22
95208: PUSH
95209: LD_OWVAR 2
95213: PUSH
95214: EMPTY
95215: LIST
95216: LIST
95217: PUSH
95218: LD_INT 21
95220: PUSH
95221: LD_INT 1
95223: PUSH
95224: EMPTY
95225: LIST
95226: LIST
95227: PUSH
95228: LD_INT 3
95230: PUSH
95231: LD_INT 23
95233: PUSH
95234: LD_INT 0
95236: PUSH
95237: EMPTY
95238: LIST
95239: LIST
95240: PUSH
95241: EMPTY
95242: LIST
95243: LIST
95244: PUSH
95245: EMPTY
95246: LIST
95247: LIST
95248: LIST
95249: PPUSH
95250: CALL_OW 69
95254: PUSH
95255: FOR_IN
95256: IFFALSE 95310
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
95258: LD_VAR 0 1
95262: PPUSH
95263: CALL_OW 257
95267: PUSH
95268: LD_INT 1
95270: PUSH
95271: LD_INT 2
95273: PUSH
95274: LD_INT 3
95276: PUSH
95277: LD_INT 4
95279: PUSH
95280: EMPTY
95281: LIST
95282: LIST
95283: LIST
95284: LIST
95285: IN
95286: IFFALSE 95308
// SetClass ( un , rand ( 1 , 4 ) ) ;
95288: LD_VAR 0 1
95292: PPUSH
95293: LD_INT 1
95295: PPUSH
95296: LD_INT 4
95298: PPUSH
95299: CALL_OW 12
95303: PPUSH
95304: CALL_OW 336
95308: GO 95255
95310: POP
95311: POP
// end ;
95312: PPOPN 1
95314: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
95315: LD_EXP 107
95319: PUSH
95320: LD_EXP 119
95324: AND
95325: IFFALSE 95404
95327: GO 95329
95329: DISABLE
95330: LD_INT 0
95332: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95333: LD_ADDR_VAR 0 1
95337: PUSH
95338: LD_INT 22
95340: PUSH
95341: LD_OWVAR 2
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: PUSH
95350: LD_INT 21
95352: PUSH
95353: LD_INT 3
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: PUSH
95360: EMPTY
95361: LIST
95362: LIST
95363: PPUSH
95364: CALL_OW 69
95368: ST_TO_ADDR
// if not tmp then
95369: LD_VAR 0 1
95373: NOT
95374: IFFALSE 95378
// exit ;
95376: GO 95404
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
95378: LD_VAR 0 1
95382: PUSH
95383: LD_INT 1
95385: PPUSH
95386: LD_VAR 0 1
95390: PPUSH
95391: CALL_OW 12
95395: ARRAY
95396: PPUSH
95397: LD_INT 100
95399: PPUSH
95400: CALL_OW 234
// end ;
95404: PPOPN 1
95406: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
95407: LD_EXP 107
95411: PUSH
95412: LD_EXP 121
95416: AND
95417: IFFALSE 95515
95419: GO 95421
95421: DISABLE
95422: LD_INT 0
95424: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95425: LD_ADDR_VAR 0 1
95429: PUSH
95430: LD_INT 22
95432: PUSH
95433: LD_OWVAR 2
95437: PUSH
95438: EMPTY
95439: LIST
95440: LIST
95441: PUSH
95442: LD_INT 21
95444: PUSH
95445: LD_INT 1
95447: PUSH
95448: EMPTY
95449: LIST
95450: LIST
95451: PUSH
95452: EMPTY
95453: LIST
95454: LIST
95455: PPUSH
95456: CALL_OW 69
95460: ST_TO_ADDR
// if not tmp then
95461: LD_VAR 0 1
95465: NOT
95466: IFFALSE 95470
// exit ;
95468: GO 95515
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
95470: LD_VAR 0 1
95474: PUSH
95475: LD_INT 1
95477: PPUSH
95478: LD_VAR 0 1
95482: PPUSH
95483: CALL_OW 12
95487: ARRAY
95488: PPUSH
95489: LD_INT 1
95491: PPUSH
95492: LD_INT 4
95494: PPUSH
95495: CALL_OW 12
95499: PPUSH
95500: LD_INT 3000
95502: PPUSH
95503: LD_INT 9000
95505: PPUSH
95506: CALL_OW 12
95510: PPUSH
95511: CALL_OW 492
// end ;
95515: PPOPN 1
95517: END
// every 0 0$1 trigger StreamModeActive and sDepot do
95518: LD_EXP 107
95522: PUSH
95523: LD_EXP 122
95527: AND
95528: IFFALSE 95548
95530: GO 95532
95532: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
95533: LD_INT 1
95535: PPUSH
95536: LD_OWVAR 2
95540: PPUSH
95541: LD_INT 0
95543: PPUSH
95544: CALL_OW 324
95548: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
95549: LD_EXP 107
95553: PUSH
95554: LD_EXP 123
95558: AND
95559: IFFALSE 95642
95561: GO 95563
95563: DISABLE
95564: LD_INT 0
95566: PPUSH
95567: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95568: LD_ADDR_VAR 0 2
95572: PUSH
95573: LD_INT 22
95575: PUSH
95576: LD_OWVAR 2
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: PUSH
95585: LD_INT 21
95587: PUSH
95588: LD_INT 3
95590: PUSH
95591: EMPTY
95592: LIST
95593: LIST
95594: PUSH
95595: EMPTY
95596: LIST
95597: LIST
95598: PPUSH
95599: CALL_OW 69
95603: ST_TO_ADDR
// if not tmp then
95604: LD_VAR 0 2
95608: NOT
95609: IFFALSE 95613
// exit ;
95611: GO 95642
// for i in tmp do
95613: LD_ADDR_VAR 0 1
95617: PUSH
95618: LD_VAR 0 2
95622: PUSH
95623: FOR_IN
95624: IFFALSE 95640
// SetBLevel ( i , 10 ) ;
95626: LD_VAR 0 1
95630: PPUSH
95631: LD_INT 10
95633: PPUSH
95634: CALL_OW 241
95638: GO 95623
95640: POP
95641: POP
// end ;
95642: PPOPN 2
95644: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
95645: LD_EXP 107
95649: PUSH
95650: LD_EXP 124
95654: AND
95655: IFFALSE 95766
95657: GO 95659
95659: DISABLE
95660: LD_INT 0
95662: PPUSH
95663: PPUSH
95664: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95665: LD_ADDR_VAR 0 3
95669: PUSH
95670: LD_INT 22
95672: PUSH
95673: LD_OWVAR 2
95677: PUSH
95678: EMPTY
95679: LIST
95680: LIST
95681: PUSH
95682: LD_INT 25
95684: PUSH
95685: LD_INT 1
95687: PUSH
95688: EMPTY
95689: LIST
95690: LIST
95691: PUSH
95692: EMPTY
95693: LIST
95694: LIST
95695: PPUSH
95696: CALL_OW 69
95700: ST_TO_ADDR
// if not tmp then
95701: LD_VAR 0 3
95705: NOT
95706: IFFALSE 95710
// exit ;
95708: GO 95766
// un := tmp [ rand ( 1 , tmp ) ] ;
95710: LD_ADDR_VAR 0 2
95714: PUSH
95715: LD_VAR 0 3
95719: PUSH
95720: LD_INT 1
95722: PPUSH
95723: LD_VAR 0 3
95727: PPUSH
95728: CALL_OW 12
95732: ARRAY
95733: ST_TO_ADDR
// if Crawls ( un ) then
95734: LD_VAR 0 2
95738: PPUSH
95739: CALL_OW 318
95743: IFFALSE 95754
// ComWalk ( un ) ;
95745: LD_VAR 0 2
95749: PPUSH
95750: CALL_OW 138
// SetClass ( un , class_sniper ) ;
95754: LD_VAR 0 2
95758: PPUSH
95759: LD_INT 5
95761: PPUSH
95762: CALL_OW 336
// end ;
95766: PPOPN 3
95768: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
95769: LD_EXP 107
95773: PUSH
95774: LD_EXP 125
95778: AND
95779: PUSH
95780: LD_OWVAR 67
95784: PUSH
95785: LD_INT 4
95787: LESS
95788: AND
95789: IFFALSE 95808
95791: GO 95793
95793: DISABLE
// begin Difficulty := Difficulty + 1 ;
95794: LD_ADDR_OWVAR 67
95798: PUSH
95799: LD_OWVAR 67
95803: PUSH
95804: LD_INT 1
95806: PLUS
95807: ST_TO_ADDR
// end ;
95808: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
95809: LD_EXP 107
95813: PUSH
95814: LD_EXP 126
95818: AND
95819: IFFALSE 95922
95821: GO 95823
95823: DISABLE
95824: LD_INT 0
95826: PPUSH
// begin for i := 1 to 5 do
95827: LD_ADDR_VAR 0 1
95831: PUSH
95832: DOUBLE
95833: LD_INT 1
95835: DEC
95836: ST_TO_ADDR
95837: LD_INT 5
95839: PUSH
95840: FOR_TO
95841: IFFALSE 95920
// begin uc_nation := nation_nature ;
95843: LD_ADDR_OWVAR 21
95847: PUSH
95848: LD_INT 0
95850: ST_TO_ADDR
// uc_side := 0 ;
95851: LD_ADDR_OWVAR 20
95855: PUSH
95856: LD_INT 0
95858: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95859: LD_ADDR_OWVAR 29
95863: PUSH
95864: LD_INT 12
95866: PUSH
95867: LD_INT 12
95869: PUSH
95870: EMPTY
95871: LIST
95872: LIST
95873: ST_TO_ADDR
// hc_agressivity := 20 ;
95874: LD_ADDR_OWVAR 35
95878: PUSH
95879: LD_INT 20
95881: ST_TO_ADDR
// hc_class := class_tiger ;
95882: LD_ADDR_OWVAR 28
95886: PUSH
95887: LD_INT 14
95889: ST_TO_ADDR
// hc_gallery :=  ;
95890: LD_ADDR_OWVAR 33
95894: PUSH
95895: LD_STRING 
95897: ST_TO_ADDR
// hc_name :=  ;
95898: LD_ADDR_OWVAR 26
95902: PUSH
95903: LD_STRING 
95905: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
95906: CALL_OW 44
95910: PPUSH
95911: LD_INT 0
95913: PPUSH
95914: CALL_OW 51
// end ;
95918: GO 95840
95920: POP
95921: POP
// end ;
95922: PPOPN 1
95924: END
// every 0 0$1 trigger StreamModeActive and sBomb do
95925: LD_EXP 107
95929: PUSH
95930: LD_EXP 127
95934: AND
95935: IFFALSE 95944
95937: GO 95939
95939: DISABLE
// StreamSibBomb ;
95940: CALL 95945 0 0
95944: END
// export function StreamSibBomb ; var i , x , y ; begin
95945: LD_INT 0
95947: PPUSH
95948: PPUSH
95949: PPUSH
95950: PPUSH
// result := false ;
95951: LD_ADDR_VAR 0 1
95955: PUSH
95956: LD_INT 0
95958: ST_TO_ADDR
// for i := 1 to 16 do
95959: LD_ADDR_VAR 0 2
95963: PUSH
95964: DOUBLE
95965: LD_INT 1
95967: DEC
95968: ST_TO_ADDR
95969: LD_INT 16
95971: PUSH
95972: FOR_TO
95973: IFFALSE 96172
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95975: LD_ADDR_VAR 0 3
95979: PUSH
95980: LD_INT 10
95982: PUSH
95983: LD_INT 20
95985: PUSH
95986: LD_INT 30
95988: PUSH
95989: LD_INT 40
95991: PUSH
95992: LD_INT 50
95994: PUSH
95995: LD_INT 60
95997: PUSH
95998: LD_INT 70
96000: PUSH
96001: LD_INT 80
96003: PUSH
96004: LD_INT 90
96006: PUSH
96007: LD_INT 100
96009: PUSH
96010: LD_INT 110
96012: PUSH
96013: LD_INT 120
96015: PUSH
96016: LD_INT 130
96018: PUSH
96019: LD_INT 140
96021: PUSH
96022: LD_INT 150
96024: PUSH
96025: EMPTY
96026: LIST
96027: LIST
96028: LIST
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: PUSH
96042: LD_INT 1
96044: PPUSH
96045: LD_INT 15
96047: PPUSH
96048: CALL_OW 12
96052: ARRAY
96053: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96054: LD_ADDR_VAR 0 4
96058: PUSH
96059: LD_INT 10
96061: PUSH
96062: LD_INT 20
96064: PUSH
96065: LD_INT 30
96067: PUSH
96068: LD_INT 40
96070: PUSH
96071: LD_INT 50
96073: PUSH
96074: LD_INT 60
96076: PUSH
96077: LD_INT 70
96079: PUSH
96080: LD_INT 80
96082: PUSH
96083: LD_INT 90
96085: PUSH
96086: LD_INT 100
96088: PUSH
96089: LD_INT 110
96091: PUSH
96092: LD_INT 120
96094: PUSH
96095: LD_INT 130
96097: PUSH
96098: LD_INT 140
96100: PUSH
96101: LD_INT 150
96103: PUSH
96104: EMPTY
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: LIST
96115: LIST
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: PUSH
96121: LD_INT 1
96123: PPUSH
96124: LD_INT 15
96126: PPUSH
96127: CALL_OW 12
96131: ARRAY
96132: ST_TO_ADDR
// if ValidHex ( x , y ) then
96133: LD_VAR 0 3
96137: PPUSH
96138: LD_VAR 0 4
96142: PPUSH
96143: CALL_OW 488
96147: IFFALSE 96170
// begin result := [ x , y ] ;
96149: LD_ADDR_VAR 0 1
96153: PUSH
96154: LD_VAR 0 3
96158: PUSH
96159: LD_VAR 0 4
96163: PUSH
96164: EMPTY
96165: LIST
96166: LIST
96167: ST_TO_ADDR
// break ;
96168: GO 96172
// end ; end ;
96170: GO 95972
96172: POP
96173: POP
// if result then
96174: LD_VAR 0 1
96178: IFFALSE 96238
// begin ToLua ( playSibBomb() ) ;
96180: LD_STRING playSibBomb()
96182: PPUSH
96183: CALL_OW 559
// wait ( 0 0$14 ) ;
96187: LD_INT 490
96189: PPUSH
96190: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
96194: LD_VAR 0 1
96198: PUSH
96199: LD_INT 1
96201: ARRAY
96202: PPUSH
96203: LD_VAR 0 1
96207: PUSH
96208: LD_INT 2
96210: ARRAY
96211: PPUSH
96212: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
96216: LD_VAR 0 1
96220: PUSH
96221: LD_INT 1
96223: ARRAY
96224: PPUSH
96225: LD_VAR 0 1
96229: PUSH
96230: LD_INT 2
96232: ARRAY
96233: PPUSH
96234: CALL_OW 429
// end ; end ;
96238: LD_VAR 0 1
96242: RET
// every 0 0$1 trigger StreamModeActive and sReset do
96243: LD_EXP 107
96247: PUSH
96248: LD_EXP 129
96252: AND
96253: IFFALSE 96265
96255: GO 96257
96257: DISABLE
// YouLost (  ) ;
96258: LD_STRING 
96260: PPUSH
96261: CALL_OW 104
96265: END
// every 0 0$1 trigger StreamModeActive and sFog do
96266: LD_EXP 107
96270: PUSH
96271: LD_EXP 128
96275: AND
96276: IFFALSE 96290
96278: GO 96280
96280: DISABLE
// FogOff ( your_side ) ;
96281: LD_OWVAR 2
96285: PPUSH
96286: CALL_OW 344
96290: END
// every 0 0$1 trigger StreamModeActive and sSun do
96291: LD_EXP 107
96295: PUSH
96296: LD_EXP 130
96300: AND
96301: IFFALSE 96329
96303: GO 96305
96305: DISABLE
// begin solar_recharge_percent := 0 ;
96306: LD_ADDR_OWVAR 79
96310: PUSH
96311: LD_INT 0
96313: ST_TO_ADDR
// wait ( 5 5$00 ) ;
96314: LD_INT 10500
96316: PPUSH
96317: CALL_OW 67
// solar_recharge_percent := 100 ;
96321: LD_ADDR_OWVAR 79
96325: PUSH
96326: LD_INT 100
96328: ST_TO_ADDR
// end ;
96329: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
96330: LD_EXP 107
96334: PUSH
96335: LD_EXP 131
96339: AND
96340: IFFALSE 96579
96342: GO 96344
96344: DISABLE
96345: LD_INT 0
96347: PPUSH
96348: PPUSH
96349: PPUSH
// begin tmp := [ ] ;
96350: LD_ADDR_VAR 0 3
96354: PUSH
96355: EMPTY
96356: ST_TO_ADDR
// for i := 1 to 6 do
96357: LD_ADDR_VAR 0 1
96361: PUSH
96362: DOUBLE
96363: LD_INT 1
96365: DEC
96366: ST_TO_ADDR
96367: LD_INT 6
96369: PUSH
96370: FOR_TO
96371: IFFALSE 96476
// begin uc_nation := nation_nature ;
96373: LD_ADDR_OWVAR 21
96377: PUSH
96378: LD_INT 0
96380: ST_TO_ADDR
// uc_side := 0 ;
96381: LD_ADDR_OWVAR 20
96385: PUSH
96386: LD_INT 0
96388: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96389: LD_ADDR_OWVAR 29
96393: PUSH
96394: LD_INT 12
96396: PUSH
96397: LD_INT 12
96399: PUSH
96400: EMPTY
96401: LIST
96402: LIST
96403: ST_TO_ADDR
// hc_agressivity := 20 ;
96404: LD_ADDR_OWVAR 35
96408: PUSH
96409: LD_INT 20
96411: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
96412: LD_ADDR_OWVAR 28
96416: PUSH
96417: LD_INT 17
96419: ST_TO_ADDR
// hc_gallery :=  ;
96420: LD_ADDR_OWVAR 33
96424: PUSH
96425: LD_STRING 
96427: ST_TO_ADDR
// hc_name :=  ;
96428: LD_ADDR_OWVAR 26
96432: PUSH
96433: LD_STRING 
96435: ST_TO_ADDR
// un := CreateHuman ;
96436: LD_ADDR_VAR 0 2
96440: PUSH
96441: CALL_OW 44
96445: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
96446: LD_VAR 0 2
96450: PPUSH
96451: LD_INT 1
96453: PPUSH
96454: CALL_OW 51
// tmp := tmp ^ un ;
96458: LD_ADDR_VAR 0 3
96462: PUSH
96463: LD_VAR 0 3
96467: PUSH
96468: LD_VAR 0 2
96472: ADD
96473: ST_TO_ADDR
// end ;
96474: GO 96370
96476: POP
96477: POP
// repeat wait ( 0 0$1 ) ;
96478: LD_INT 35
96480: PPUSH
96481: CALL_OW 67
// for un in tmp do
96485: LD_ADDR_VAR 0 2
96489: PUSH
96490: LD_VAR 0 3
96494: PUSH
96495: FOR_IN
96496: IFFALSE 96570
// begin if IsDead ( un ) then
96498: LD_VAR 0 2
96502: PPUSH
96503: CALL_OW 301
96507: IFFALSE 96527
// begin tmp := tmp diff un ;
96509: LD_ADDR_VAR 0 3
96513: PUSH
96514: LD_VAR 0 3
96518: PUSH
96519: LD_VAR 0 2
96523: DIFF
96524: ST_TO_ADDR
// continue ;
96525: GO 96495
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
96527: LD_VAR 0 2
96531: PPUSH
96532: LD_INT 3
96534: PUSH
96535: LD_INT 22
96537: PUSH
96538: LD_INT 0
96540: PUSH
96541: EMPTY
96542: LIST
96543: LIST
96544: PUSH
96545: EMPTY
96546: LIST
96547: LIST
96548: PPUSH
96549: CALL_OW 69
96553: PPUSH
96554: LD_VAR 0 2
96558: PPUSH
96559: CALL_OW 74
96563: PPUSH
96564: CALL_OW 115
// end ;
96568: GO 96495
96570: POP
96571: POP
// until not tmp ;
96572: LD_VAR 0 3
96576: NOT
96577: IFFALSE 96478
// end ;
96579: PPOPN 3
96581: END
// every 0 0$1 trigger StreamModeActive and sTroll do
96582: LD_EXP 107
96586: PUSH
96587: LD_EXP 132
96591: AND
96592: IFFALSE 96646
96594: GO 96596
96596: DISABLE
// begin ToLua ( displayTroll(); ) ;
96597: LD_STRING displayTroll();
96599: PPUSH
96600: CALL_OW 559
// wait ( 3 3$00 ) ;
96604: LD_INT 6300
96606: PPUSH
96607: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96611: LD_STRING hideTroll();
96613: PPUSH
96614: CALL_OW 559
// wait ( 1 1$00 ) ;
96618: LD_INT 2100
96620: PPUSH
96621: CALL_OW 67
// ToLua ( displayTroll(); ) ;
96625: LD_STRING displayTroll();
96627: PPUSH
96628: CALL_OW 559
// wait ( 1 1$00 ) ;
96632: LD_INT 2100
96634: PPUSH
96635: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96639: LD_STRING hideTroll();
96641: PPUSH
96642: CALL_OW 559
// end ;
96646: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
96647: LD_EXP 107
96651: PUSH
96652: LD_EXP 133
96656: AND
96657: IFFALSE 96720
96659: GO 96661
96661: DISABLE
96662: LD_INT 0
96664: PPUSH
// begin p := 0 ;
96665: LD_ADDR_VAR 0 1
96669: PUSH
96670: LD_INT 0
96672: ST_TO_ADDR
// repeat game_speed := 1 ;
96673: LD_ADDR_OWVAR 65
96677: PUSH
96678: LD_INT 1
96680: ST_TO_ADDR
// wait ( 0 0$1 ) ;
96681: LD_INT 35
96683: PPUSH
96684: CALL_OW 67
// p := p + 1 ;
96688: LD_ADDR_VAR 0 1
96692: PUSH
96693: LD_VAR 0 1
96697: PUSH
96698: LD_INT 1
96700: PLUS
96701: ST_TO_ADDR
// until p >= 60 ;
96702: LD_VAR 0 1
96706: PUSH
96707: LD_INT 60
96709: GREATEREQUAL
96710: IFFALSE 96673
// game_speed := 4 ;
96712: LD_ADDR_OWVAR 65
96716: PUSH
96717: LD_INT 4
96719: ST_TO_ADDR
// end ;
96720: PPOPN 1
96722: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
96723: LD_EXP 107
96727: PUSH
96728: LD_EXP 134
96732: AND
96733: IFFALSE 96879
96735: GO 96737
96737: DISABLE
96738: LD_INT 0
96740: PPUSH
96741: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96742: LD_ADDR_VAR 0 1
96746: PUSH
96747: LD_INT 22
96749: PUSH
96750: LD_OWVAR 2
96754: PUSH
96755: EMPTY
96756: LIST
96757: LIST
96758: PUSH
96759: LD_INT 2
96761: PUSH
96762: LD_INT 30
96764: PUSH
96765: LD_INT 0
96767: PUSH
96768: EMPTY
96769: LIST
96770: LIST
96771: PUSH
96772: LD_INT 30
96774: PUSH
96775: LD_INT 1
96777: PUSH
96778: EMPTY
96779: LIST
96780: LIST
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: LIST
96786: PUSH
96787: EMPTY
96788: LIST
96789: LIST
96790: PPUSH
96791: CALL_OW 69
96795: ST_TO_ADDR
// if not depot then
96796: LD_VAR 0 1
96800: NOT
96801: IFFALSE 96805
// exit ;
96803: GO 96879
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
96805: LD_ADDR_VAR 0 2
96809: PUSH
96810: LD_VAR 0 1
96814: PUSH
96815: LD_INT 1
96817: PPUSH
96818: LD_VAR 0 1
96822: PPUSH
96823: CALL_OW 12
96827: ARRAY
96828: PPUSH
96829: CALL_OW 274
96833: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
96834: LD_VAR 0 2
96838: PPUSH
96839: LD_INT 1
96841: PPUSH
96842: LD_INT 0
96844: PPUSH
96845: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
96849: LD_VAR 0 2
96853: PPUSH
96854: LD_INT 2
96856: PPUSH
96857: LD_INT 0
96859: PPUSH
96860: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
96864: LD_VAR 0 2
96868: PPUSH
96869: LD_INT 3
96871: PPUSH
96872: LD_INT 0
96874: PPUSH
96875: CALL_OW 277
// end ;
96879: PPOPN 2
96881: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
96882: LD_EXP 107
96886: PUSH
96887: LD_EXP 135
96891: AND
96892: IFFALSE 96989
96894: GO 96896
96896: DISABLE
96897: LD_INT 0
96899: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96900: LD_ADDR_VAR 0 1
96904: PUSH
96905: LD_INT 22
96907: PUSH
96908: LD_OWVAR 2
96912: PUSH
96913: EMPTY
96914: LIST
96915: LIST
96916: PUSH
96917: LD_INT 21
96919: PUSH
96920: LD_INT 1
96922: PUSH
96923: EMPTY
96924: LIST
96925: LIST
96926: PUSH
96927: LD_INT 3
96929: PUSH
96930: LD_INT 23
96932: PUSH
96933: LD_INT 0
96935: PUSH
96936: EMPTY
96937: LIST
96938: LIST
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: PUSH
96944: EMPTY
96945: LIST
96946: LIST
96947: LIST
96948: PPUSH
96949: CALL_OW 69
96953: ST_TO_ADDR
// if not tmp then
96954: LD_VAR 0 1
96958: NOT
96959: IFFALSE 96963
// exit ;
96961: GO 96989
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
96963: LD_VAR 0 1
96967: PUSH
96968: LD_INT 1
96970: PPUSH
96971: LD_VAR 0 1
96975: PPUSH
96976: CALL_OW 12
96980: ARRAY
96981: PPUSH
96982: LD_INT 200
96984: PPUSH
96985: CALL_OW 234
// end ;
96989: PPOPN 1
96991: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
96992: LD_EXP 107
96996: PUSH
96997: LD_EXP 136
97001: AND
97002: IFFALSE 97081
97004: GO 97006
97006: DISABLE
97007: LD_INT 0
97009: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
97010: LD_ADDR_VAR 0 1
97014: PUSH
97015: LD_INT 22
97017: PUSH
97018: LD_OWVAR 2
97022: PUSH
97023: EMPTY
97024: LIST
97025: LIST
97026: PUSH
97027: LD_INT 21
97029: PUSH
97030: LD_INT 2
97032: PUSH
97033: EMPTY
97034: LIST
97035: LIST
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PPUSH
97041: CALL_OW 69
97045: ST_TO_ADDR
// if not tmp then
97046: LD_VAR 0 1
97050: NOT
97051: IFFALSE 97055
// exit ;
97053: GO 97081
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
97055: LD_VAR 0 1
97059: PUSH
97060: LD_INT 1
97062: PPUSH
97063: LD_VAR 0 1
97067: PPUSH
97068: CALL_OW 12
97072: ARRAY
97073: PPUSH
97074: LD_INT 60
97076: PPUSH
97077: CALL_OW 234
// end ;
97081: PPOPN 1
97083: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
97084: LD_EXP 107
97088: PUSH
97089: LD_EXP 137
97093: AND
97094: IFFALSE 97193
97096: GO 97098
97098: DISABLE
97099: LD_INT 0
97101: PPUSH
97102: PPUSH
// begin enable ;
97103: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
97104: LD_ADDR_VAR 0 1
97108: PUSH
97109: LD_INT 22
97111: PUSH
97112: LD_OWVAR 2
97116: PUSH
97117: EMPTY
97118: LIST
97119: LIST
97120: PUSH
97121: LD_INT 61
97123: PUSH
97124: EMPTY
97125: LIST
97126: PUSH
97127: LD_INT 33
97129: PUSH
97130: LD_INT 2
97132: PUSH
97133: EMPTY
97134: LIST
97135: LIST
97136: PUSH
97137: EMPTY
97138: LIST
97139: LIST
97140: LIST
97141: PPUSH
97142: CALL_OW 69
97146: ST_TO_ADDR
// if not tmp then
97147: LD_VAR 0 1
97151: NOT
97152: IFFALSE 97156
// exit ;
97154: GO 97193
// for i in tmp do
97156: LD_ADDR_VAR 0 2
97160: PUSH
97161: LD_VAR 0 1
97165: PUSH
97166: FOR_IN
97167: IFFALSE 97191
// if IsControledBy ( i ) then
97169: LD_VAR 0 2
97173: PPUSH
97174: CALL_OW 312
97178: IFFALSE 97189
// ComUnlink ( i ) ;
97180: LD_VAR 0 2
97184: PPUSH
97185: CALL_OW 136
97189: GO 97166
97191: POP
97192: POP
// end ;
97193: PPOPN 2
97195: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
97196: LD_EXP 107
97200: PUSH
97201: LD_EXP 138
97205: AND
97206: IFFALSE 97346
97208: GO 97210
97210: DISABLE
97211: LD_INT 0
97213: PPUSH
97214: PPUSH
// begin ToLua ( displayPowell(); ) ;
97215: LD_STRING displayPowell();
97217: PPUSH
97218: CALL_OW 559
// uc_side := 0 ;
97222: LD_ADDR_OWVAR 20
97226: PUSH
97227: LD_INT 0
97229: ST_TO_ADDR
// uc_nation := 2 ;
97230: LD_ADDR_OWVAR 21
97234: PUSH
97235: LD_INT 2
97237: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
97238: LD_ADDR_OWVAR 37
97242: PUSH
97243: LD_INT 14
97245: ST_TO_ADDR
// vc_engine := engine_siberite ;
97246: LD_ADDR_OWVAR 39
97250: PUSH
97251: LD_INT 3
97253: ST_TO_ADDR
// vc_control := control_apeman ;
97254: LD_ADDR_OWVAR 38
97258: PUSH
97259: LD_INT 5
97261: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
97262: LD_ADDR_OWVAR 40
97266: PUSH
97267: LD_INT 29
97269: ST_TO_ADDR
// un := CreateVehicle ;
97270: LD_ADDR_VAR 0 2
97274: PUSH
97275: CALL_OW 45
97279: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97280: LD_VAR 0 2
97284: PPUSH
97285: LD_INT 1
97287: PPUSH
97288: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97292: LD_INT 35
97294: PPUSH
97295: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97299: LD_VAR 0 2
97303: PPUSH
97304: LD_INT 22
97306: PUSH
97307: LD_OWVAR 2
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: PPUSH
97316: CALL_OW 69
97320: PPUSH
97321: LD_VAR 0 2
97325: PPUSH
97326: CALL_OW 74
97330: PPUSH
97331: CALL_OW 115
// until IsDead ( un ) ;
97335: LD_VAR 0 2
97339: PPUSH
97340: CALL_OW 301
97344: IFFALSE 97292
// end ;
97346: PPOPN 2
97348: END
// every 0 0$1 trigger StreamModeActive and sStu do
97349: LD_EXP 107
97353: PUSH
97354: LD_EXP 146
97358: AND
97359: IFFALSE 97375
97361: GO 97363
97363: DISABLE
// begin ToLua ( displayStucuk(); ) ;
97364: LD_STRING displayStucuk();
97366: PPUSH
97367: CALL_OW 559
// ResetFog ;
97371: CALL_OW 335
// end ;
97375: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
97376: LD_EXP 107
97380: PUSH
97381: LD_EXP 139
97385: AND
97386: IFFALSE 97527
97388: GO 97390
97390: DISABLE
97391: LD_INT 0
97393: PPUSH
97394: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97395: LD_ADDR_VAR 0 2
97399: PUSH
97400: LD_INT 22
97402: PUSH
97403: LD_OWVAR 2
97407: PUSH
97408: EMPTY
97409: LIST
97410: LIST
97411: PUSH
97412: LD_INT 21
97414: PUSH
97415: LD_INT 1
97417: PUSH
97418: EMPTY
97419: LIST
97420: LIST
97421: PUSH
97422: EMPTY
97423: LIST
97424: LIST
97425: PPUSH
97426: CALL_OW 69
97430: ST_TO_ADDR
// if not tmp then
97431: LD_VAR 0 2
97435: NOT
97436: IFFALSE 97440
// exit ;
97438: GO 97527
// un := tmp [ rand ( 1 , tmp ) ] ;
97440: LD_ADDR_VAR 0 1
97444: PUSH
97445: LD_VAR 0 2
97449: PUSH
97450: LD_INT 1
97452: PPUSH
97453: LD_VAR 0 2
97457: PPUSH
97458: CALL_OW 12
97462: ARRAY
97463: ST_TO_ADDR
// SetSide ( un , 0 ) ;
97464: LD_VAR 0 1
97468: PPUSH
97469: LD_INT 0
97471: PPUSH
97472: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
97476: LD_VAR 0 1
97480: PPUSH
97481: LD_OWVAR 3
97485: PUSH
97486: LD_VAR 0 1
97490: DIFF
97491: PPUSH
97492: LD_VAR 0 1
97496: PPUSH
97497: CALL_OW 74
97501: PPUSH
97502: CALL_OW 115
// wait ( 0 0$20 ) ;
97506: LD_INT 700
97508: PPUSH
97509: CALL_OW 67
// SetSide ( un , your_side ) ;
97513: LD_VAR 0 1
97517: PPUSH
97518: LD_OWVAR 2
97522: PPUSH
97523: CALL_OW 235
// end ;
97527: PPOPN 2
97529: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
97530: LD_EXP 107
97534: PUSH
97535: LD_EXP 140
97539: AND
97540: IFFALSE 97646
97542: GO 97544
97544: DISABLE
97545: LD_INT 0
97547: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97548: LD_ADDR_VAR 0 1
97552: PUSH
97553: LD_INT 22
97555: PUSH
97556: LD_OWVAR 2
97560: PUSH
97561: EMPTY
97562: LIST
97563: LIST
97564: PUSH
97565: LD_INT 2
97567: PUSH
97568: LD_INT 30
97570: PUSH
97571: LD_INT 0
97573: PUSH
97574: EMPTY
97575: LIST
97576: LIST
97577: PUSH
97578: LD_INT 30
97580: PUSH
97581: LD_INT 1
97583: PUSH
97584: EMPTY
97585: LIST
97586: LIST
97587: PUSH
97588: EMPTY
97589: LIST
97590: LIST
97591: LIST
97592: PUSH
97593: EMPTY
97594: LIST
97595: LIST
97596: PPUSH
97597: CALL_OW 69
97601: ST_TO_ADDR
// if not depot then
97602: LD_VAR 0 1
97606: NOT
97607: IFFALSE 97611
// exit ;
97609: GO 97646
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
97611: LD_VAR 0 1
97615: PUSH
97616: LD_INT 1
97618: ARRAY
97619: PPUSH
97620: CALL_OW 250
97624: PPUSH
97625: LD_VAR 0 1
97629: PUSH
97630: LD_INT 1
97632: ARRAY
97633: PPUSH
97634: CALL_OW 251
97638: PPUSH
97639: LD_INT 70
97641: PPUSH
97642: CALL_OW 495
// end ;
97646: PPOPN 1
97648: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
97649: LD_EXP 107
97653: PUSH
97654: LD_EXP 141
97658: AND
97659: IFFALSE 97870
97661: GO 97663
97663: DISABLE
97664: LD_INT 0
97666: PPUSH
97667: PPUSH
97668: PPUSH
97669: PPUSH
97670: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97671: LD_ADDR_VAR 0 5
97675: PUSH
97676: LD_INT 22
97678: PUSH
97679: LD_OWVAR 2
97683: PUSH
97684: EMPTY
97685: LIST
97686: LIST
97687: PUSH
97688: LD_INT 21
97690: PUSH
97691: LD_INT 1
97693: PUSH
97694: EMPTY
97695: LIST
97696: LIST
97697: PUSH
97698: EMPTY
97699: LIST
97700: LIST
97701: PPUSH
97702: CALL_OW 69
97706: ST_TO_ADDR
// if not tmp then
97707: LD_VAR 0 5
97711: NOT
97712: IFFALSE 97716
// exit ;
97714: GO 97870
// for i in tmp do
97716: LD_ADDR_VAR 0 1
97720: PUSH
97721: LD_VAR 0 5
97725: PUSH
97726: FOR_IN
97727: IFFALSE 97868
// begin d := rand ( 0 , 5 ) ;
97729: LD_ADDR_VAR 0 4
97733: PUSH
97734: LD_INT 0
97736: PPUSH
97737: LD_INT 5
97739: PPUSH
97740: CALL_OW 12
97744: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
97745: LD_ADDR_VAR 0 2
97749: PUSH
97750: LD_VAR 0 1
97754: PPUSH
97755: CALL_OW 250
97759: PPUSH
97760: LD_VAR 0 4
97764: PPUSH
97765: LD_INT 3
97767: PPUSH
97768: LD_INT 12
97770: PPUSH
97771: CALL_OW 12
97775: PPUSH
97776: CALL_OW 272
97780: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
97781: LD_ADDR_VAR 0 3
97785: PUSH
97786: LD_VAR 0 1
97790: PPUSH
97791: CALL_OW 251
97795: PPUSH
97796: LD_VAR 0 4
97800: PPUSH
97801: LD_INT 3
97803: PPUSH
97804: LD_INT 12
97806: PPUSH
97807: CALL_OW 12
97811: PPUSH
97812: CALL_OW 273
97816: ST_TO_ADDR
// if ValidHex ( x , y ) then
97817: LD_VAR 0 2
97821: PPUSH
97822: LD_VAR 0 3
97826: PPUSH
97827: CALL_OW 488
97831: IFFALSE 97866
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
97833: LD_VAR 0 1
97837: PPUSH
97838: LD_VAR 0 2
97842: PPUSH
97843: LD_VAR 0 3
97847: PPUSH
97848: LD_INT 3
97850: PPUSH
97851: LD_INT 6
97853: PPUSH
97854: CALL_OW 12
97858: PPUSH
97859: LD_INT 1
97861: PPUSH
97862: CALL_OW 483
// end ;
97866: GO 97726
97868: POP
97869: POP
// end ;
97870: PPOPN 5
97872: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
97873: LD_EXP 107
97877: PUSH
97878: LD_EXP 142
97882: AND
97883: IFFALSE 97977
97885: GO 97887
97887: DISABLE
97888: LD_INT 0
97890: PPUSH
97891: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
97892: LD_ADDR_VAR 0 2
97896: PUSH
97897: LD_INT 22
97899: PUSH
97900: LD_OWVAR 2
97904: PUSH
97905: EMPTY
97906: LIST
97907: LIST
97908: PUSH
97909: LD_INT 32
97911: PUSH
97912: LD_INT 1
97914: PUSH
97915: EMPTY
97916: LIST
97917: LIST
97918: PUSH
97919: LD_INT 21
97921: PUSH
97922: LD_INT 2
97924: PUSH
97925: EMPTY
97926: LIST
97927: LIST
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: LIST
97933: PPUSH
97934: CALL_OW 69
97938: ST_TO_ADDR
// if not tmp then
97939: LD_VAR 0 2
97943: NOT
97944: IFFALSE 97948
// exit ;
97946: GO 97977
// for i in tmp do
97948: LD_ADDR_VAR 0 1
97952: PUSH
97953: LD_VAR 0 2
97957: PUSH
97958: FOR_IN
97959: IFFALSE 97975
// SetFuel ( i , 0 ) ;
97961: LD_VAR 0 1
97965: PPUSH
97966: LD_INT 0
97968: PPUSH
97969: CALL_OW 240
97973: GO 97958
97975: POP
97976: POP
// end ;
97977: PPOPN 2
97979: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
97980: LD_EXP 107
97984: PUSH
97985: LD_EXP 143
97989: AND
97990: IFFALSE 98056
97992: GO 97994
97994: DISABLE
97995: LD_INT 0
97997: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97998: LD_ADDR_VAR 0 1
98002: PUSH
98003: LD_INT 22
98005: PUSH
98006: LD_OWVAR 2
98010: PUSH
98011: EMPTY
98012: LIST
98013: LIST
98014: PUSH
98015: LD_INT 30
98017: PUSH
98018: LD_INT 29
98020: PUSH
98021: EMPTY
98022: LIST
98023: LIST
98024: PUSH
98025: EMPTY
98026: LIST
98027: LIST
98028: PPUSH
98029: CALL_OW 69
98033: ST_TO_ADDR
// if not tmp then
98034: LD_VAR 0 1
98038: NOT
98039: IFFALSE 98043
// exit ;
98041: GO 98056
// DestroyUnit ( tmp [ 1 ] ) ;
98043: LD_VAR 0 1
98047: PUSH
98048: LD_INT 1
98050: ARRAY
98051: PPUSH
98052: CALL_OW 65
// end ;
98056: PPOPN 1
98058: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
98059: LD_EXP 107
98063: PUSH
98064: LD_EXP 145
98068: AND
98069: IFFALSE 98198
98071: GO 98073
98073: DISABLE
98074: LD_INT 0
98076: PPUSH
// begin uc_side := 0 ;
98077: LD_ADDR_OWVAR 20
98081: PUSH
98082: LD_INT 0
98084: ST_TO_ADDR
// uc_nation := nation_arabian ;
98085: LD_ADDR_OWVAR 21
98089: PUSH
98090: LD_INT 2
98092: ST_TO_ADDR
// hc_gallery :=  ;
98093: LD_ADDR_OWVAR 33
98097: PUSH
98098: LD_STRING 
98100: ST_TO_ADDR
// hc_name :=  ;
98101: LD_ADDR_OWVAR 26
98105: PUSH
98106: LD_STRING 
98108: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
98109: LD_INT 1
98111: PPUSH
98112: LD_INT 11
98114: PPUSH
98115: LD_INT 10
98117: PPUSH
98118: CALL_OW 380
// un := CreateHuman ;
98122: LD_ADDR_VAR 0 1
98126: PUSH
98127: CALL_OW 44
98131: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98132: LD_VAR 0 1
98136: PPUSH
98137: LD_INT 1
98139: PPUSH
98140: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98144: LD_INT 35
98146: PPUSH
98147: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98151: LD_VAR 0 1
98155: PPUSH
98156: LD_INT 22
98158: PUSH
98159: LD_OWVAR 2
98163: PUSH
98164: EMPTY
98165: LIST
98166: LIST
98167: PPUSH
98168: CALL_OW 69
98172: PPUSH
98173: LD_VAR 0 1
98177: PPUSH
98178: CALL_OW 74
98182: PPUSH
98183: CALL_OW 115
// until IsDead ( un ) ;
98187: LD_VAR 0 1
98191: PPUSH
98192: CALL_OW 301
98196: IFFALSE 98144
// end ;
98198: PPOPN 1
98200: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
98201: LD_EXP 107
98205: PUSH
98206: LD_EXP 147
98210: AND
98211: IFFALSE 98223
98213: GO 98215
98215: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
98216: LD_STRING earthquake(getX(game), 0, 32)
98218: PPUSH
98219: CALL_OW 559
98223: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
98224: LD_EXP 107
98228: PUSH
98229: LD_EXP 148
98233: AND
98234: IFFALSE 98325
98236: GO 98238
98238: DISABLE
98239: LD_INT 0
98241: PPUSH
// begin enable ;
98242: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
98243: LD_ADDR_VAR 0 1
98247: PUSH
98248: LD_INT 22
98250: PUSH
98251: LD_OWVAR 2
98255: PUSH
98256: EMPTY
98257: LIST
98258: LIST
98259: PUSH
98260: LD_INT 21
98262: PUSH
98263: LD_INT 2
98265: PUSH
98266: EMPTY
98267: LIST
98268: LIST
98269: PUSH
98270: LD_INT 33
98272: PUSH
98273: LD_INT 3
98275: PUSH
98276: EMPTY
98277: LIST
98278: LIST
98279: PUSH
98280: EMPTY
98281: LIST
98282: LIST
98283: LIST
98284: PPUSH
98285: CALL_OW 69
98289: ST_TO_ADDR
// if not tmp then
98290: LD_VAR 0 1
98294: NOT
98295: IFFALSE 98299
// exit ;
98297: GO 98325
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98299: LD_VAR 0 1
98303: PUSH
98304: LD_INT 1
98306: PPUSH
98307: LD_VAR 0 1
98311: PPUSH
98312: CALL_OW 12
98316: ARRAY
98317: PPUSH
98318: LD_INT 1
98320: PPUSH
98321: CALL_OW 234
// end ;
98325: PPOPN 1
98327: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
98328: LD_EXP 107
98332: PUSH
98333: LD_EXP 149
98337: AND
98338: IFFALSE 98479
98340: GO 98342
98342: DISABLE
98343: LD_INT 0
98345: PPUSH
98346: PPUSH
98347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98348: LD_ADDR_VAR 0 3
98352: PUSH
98353: LD_INT 22
98355: PUSH
98356: LD_OWVAR 2
98360: PUSH
98361: EMPTY
98362: LIST
98363: LIST
98364: PUSH
98365: LD_INT 25
98367: PUSH
98368: LD_INT 1
98370: PUSH
98371: EMPTY
98372: LIST
98373: LIST
98374: PUSH
98375: EMPTY
98376: LIST
98377: LIST
98378: PPUSH
98379: CALL_OW 69
98383: ST_TO_ADDR
// if not tmp then
98384: LD_VAR 0 3
98388: NOT
98389: IFFALSE 98393
// exit ;
98391: GO 98479
// un := tmp [ rand ( 1 , tmp ) ] ;
98393: LD_ADDR_VAR 0 2
98397: PUSH
98398: LD_VAR 0 3
98402: PUSH
98403: LD_INT 1
98405: PPUSH
98406: LD_VAR 0 3
98410: PPUSH
98411: CALL_OW 12
98415: ARRAY
98416: ST_TO_ADDR
// if Crawls ( un ) then
98417: LD_VAR 0 2
98421: PPUSH
98422: CALL_OW 318
98426: IFFALSE 98437
// ComWalk ( un ) ;
98428: LD_VAR 0 2
98432: PPUSH
98433: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
98437: LD_VAR 0 2
98441: PPUSH
98442: LD_INT 9
98444: PPUSH
98445: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
98449: LD_INT 28
98451: PPUSH
98452: LD_OWVAR 2
98456: PPUSH
98457: LD_INT 2
98459: PPUSH
98460: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
98464: LD_INT 29
98466: PPUSH
98467: LD_OWVAR 2
98471: PPUSH
98472: LD_INT 2
98474: PPUSH
98475: CALL_OW 322
// end ;
98479: PPOPN 3
98481: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
98482: LD_EXP 107
98486: PUSH
98487: LD_EXP 150
98491: AND
98492: IFFALSE 98603
98494: GO 98496
98496: DISABLE
98497: LD_INT 0
98499: PPUSH
98500: PPUSH
98501: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98502: LD_ADDR_VAR 0 3
98506: PUSH
98507: LD_INT 22
98509: PUSH
98510: LD_OWVAR 2
98514: PUSH
98515: EMPTY
98516: LIST
98517: LIST
98518: PUSH
98519: LD_INT 25
98521: PUSH
98522: LD_INT 1
98524: PUSH
98525: EMPTY
98526: LIST
98527: LIST
98528: PUSH
98529: EMPTY
98530: LIST
98531: LIST
98532: PPUSH
98533: CALL_OW 69
98537: ST_TO_ADDR
// if not tmp then
98538: LD_VAR 0 3
98542: NOT
98543: IFFALSE 98547
// exit ;
98545: GO 98603
// un := tmp [ rand ( 1 , tmp ) ] ;
98547: LD_ADDR_VAR 0 2
98551: PUSH
98552: LD_VAR 0 3
98556: PUSH
98557: LD_INT 1
98559: PPUSH
98560: LD_VAR 0 3
98564: PPUSH
98565: CALL_OW 12
98569: ARRAY
98570: ST_TO_ADDR
// if Crawls ( un ) then
98571: LD_VAR 0 2
98575: PPUSH
98576: CALL_OW 318
98580: IFFALSE 98591
// ComWalk ( un ) ;
98582: LD_VAR 0 2
98586: PPUSH
98587: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98591: LD_VAR 0 2
98595: PPUSH
98596: LD_INT 8
98598: PPUSH
98599: CALL_OW 336
// end ;
98603: PPOPN 3
98605: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
98606: LD_EXP 107
98610: PUSH
98611: LD_EXP 151
98615: AND
98616: IFFALSE 98760
98618: GO 98620
98620: DISABLE
98621: LD_INT 0
98623: PPUSH
98624: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
98625: LD_ADDR_VAR 0 2
98629: PUSH
98630: LD_INT 22
98632: PUSH
98633: LD_OWVAR 2
98637: PUSH
98638: EMPTY
98639: LIST
98640: LIST
98641: PUSH
98642: LD_INT 21
98644: PUSH
98645: LD_INT 2
98647: PUSH
98648: EMPTY
98649: LIST
98650: LIST
98651: PUSH
98652: LD_INT 2
98654: PUSH
98655: LD_INT 34
98657: PUSH
98658: LD_INT 12
98660: PUSH
98661: EMPTY
98662: LIST
98663: LIST
98664: PUSH
98665: LD_INT 34
98667: PUSH
98668: LD_INT 51
98670: PUSH
98671: EMPTY
98672: LIST
98673: LIST
98674: PUSH
98675: LD_INT 34
98677: PUSH
98678: LD_INT 32
98680: PUSH
98681: EMPTY
98682: LIST
98683: LIST
98684: PUSH
98685: EMPTY
98686: LIST
98687: LIST
98688: LIST
98689: LIST
98690: PUSH
98691: EMPTY
98692: LIST
98693: LIST
98694: LIST
98695: PPUSH
98696: CALL_OW 69
98700: ST_TO_ADDR
// if not tmp then
98701: LD_VAR 0 2
98705: NOT
98706: IFFALSE 98710
// exit ;
98708: GO 98760
// for i in tmp do
98710: LD_ADDR_VAR 0 1
98714: PUSH
98715: LD_VAR 0 2
98719: PUSH
98720: FOR_IN
98721: IFFALSE 98758
// if GetCargo ( i , mat_artifact ) = 0 then
98723: LD_VAR 0 1
98727: PPUSH
98728: LD_INT 4
98730: PPUSH
98731: CALL_OW 289
98735: PUSH
98736: LD_INT 0
98738: EQUAL
98739: IFFALSE 98756
// SetCargo ( i , mat_siberit , 100 ) ;
98741: LD_VAR 0 1
98745: PPUSH
98746: LD_INT 3
98748: PPUSH
98749: LD_INT 100
98751: PPUSH
98752: CALL_OW 290
98756: GO 98720
98758: POP
98759: POP
// end ;
98760: PPOPN 2
98762: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
98763: LD_EXP 107
98767: PUSH
98768: LD_EXP 152
98772: AND
98773: IFFALSE 98956
98775: GO 98777
98777: DISABLE
98778: LD_INT 0
98780: PPUSH
98781: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98782: LD_ADDR_VAR 0 2
98786: PUSH
98787: LD_INT 22
98789: PUSH
98790: LD_OWVAR 2
98794: PUSH
98795: EMPTY
98796: LIST
98797: LIST
98798: PPUSH
98799: CALL_OW 69
98803: ST_TO_ADDR
// if not tmp then
98804: LD_VAR 0 2
98808: NOT
98809: IFFALSE 98813
// exit ;
98811: GO 98956
// for i := 1 to 2 do
98813: LD_ADDR_VAR 0 1
98817: PUSH
98818: DOUBLE
98819: LD_INT 1
98821: DEC
98822: ST_TO_ADDR
98823: LD_INT 2
98825: PUSH
98826: FOR_TO
98827: IFFALSE 98954
// begin uc_side := your_side ;
98829: LD_ADDR_OWVAR 20
98833: PUSH
98834: LD_OWVAR 2
98838: ST_TO_ADDR
// uc_nation := nation_american ;
98839: LD_ADDR_OWVAR 21
98843: PUSH
98844: LD_INT 1
98846: ST_TO_ADDR
// vc_chassis := us_morphling ;
98847: LD_ADDR_OWVAR 37
98851: PUSH
98852: LD_INT 5
98854: ST_TO_ADDR
// vc_engine := engine_siberite ;
98855: LD_ADDR_OWVAR 39
98859: PUSH
98860: LD_INT 3
98862: ST_TO_ADDR
// vc_control := control_computer ;
98863: LD_ADDR_OWVAR 38
98867: PUSH
98868: LD_INT 3
98870: ST_TO_ADDR
// vc_weapon := us_double_laser ;
98871: LD_ADDR_OWVAR 40
98875: PUSH
98876: LD_INT 10
98878: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
98879: LD_VAR 0 2
98883: PUSH
98884: LD_INT 1
98886: ARRAY
98887: PPUSH
98888: CALL_OW 310
98892: NOT
98893: IFFALSE 98940
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
98895: CALL_OW 45
98899: PPUSH
98900: LD_VAR 0 2
98904: PUSH
98905: LD_INT 1
98907: ARRAY
98908: PPUSH
98909: CALL_OW 250
98913: PPUSH
98914: LD_VAR 0 2
98918: PUSH
98919: LD_INT 1
98921: ARRAY
98922: PPUSH
98923: CALL_OW 251
98927: PPUSH
98928: LD_INT 12
98930: PPUSH
98931: LD_INT 1
98933: PPUSH
98934: CALL_OW 50
98938: GO 98952
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
98940: CALL_OW 45
98944: PPUSH
98945: LD_INT 1
98947: PPUSH
98948: CALL_OW 51
// end ;
98952: GO 98826
98954: POP
98955: POP
// end ;
98956: PPOPN 2
98958: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
98959: LD_EXP 107
98963: PUSH
98964: LD_EXP 153
98968: AND
98969: IFFALSE 99191
98971: GO 98973
98973: DISABLE
98974: LD_INT 0
98976: PPUSH
98977: PPUSH
98978: PPUSH
98979: PPUSH
98980: PPUSH
98981: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98982: LD_ADDR_VAR 0 6
98986: PUSH
98987: LD_INT 22
98989: PUSH
98990: LD_OWVAR 2
98994: PUSH
98995: EMPTY
98996: LIST
98997: LIST
98998: PUSH
98999: LD_INT 21
99001: PUSH
99002: LD_INT 1
99004: PUSH
99005: EMPTY
99006: LIST
99007: LIST
99008: PUSH
99009: LD_INT 3
99011: PUSH
99012: LD_INT 23
99014: PUSH
99015: LD_INT 0
99017: PUSH
99018: EMPTY
99019: LIST
99020: LIST
99021: PUSH
99022: EMPTY
99023: LIST
99024: LIST
99025: PUSH
99026: EMPTY
99027: LIST
99028: LIST
99029: LIST
99030: PPUSH
99031: CALL_OW 69
99035: ST_TO_ADDR
// if not tmp then
99036: LD_VAR 0 6
99040: NOT
99041: IFFALSE 99045
// exit ;
99043: GO 99191
// s1 := rand ( 1 , 4 ) ;
99045: LD_ADDR_VAR 0 2
99049: PUSH
99050: LD_INT 1
99052: PPUSH
99053: LD_INT 4
99055: PPUSH
99056: CALL_OW 12
99060: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
99061: LD_ADDR_VAR 0 4
99065: PUSH
99066: LD_VAR 0 6
99070: PUSH
99071: LD_INT 1
99073: ARRAY
99074: PPUSH
99075: LD_VAR 0 2
99079: PPUSH
99080: CALL_OW 259
99084: ST_TO_ADDR
// if s1 = 1 then
99085: LD_VAR 0 2
99089: PUSH
99090: LD_INT 1
99092: EQUAL
99093: IFFALSE 99113
// s2 := rand ( 2 , 4 ) else
99095: LD_ADDR_VAR 0 3
99099: PUSH
99100: LD_INT 2
99102: PPUSH
99103: LD_INT 4
99105: PPUSH
99106: CALL_OW 12
99110: ST_TO_ADDR
99111: GO 99121
// s2 := 1 ;
99113: LD_ADDR_VAR 0 3
99117: PUSH
99118: LD_INT 1
99120: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
99121: LD_ADDR_VAR 0 5
99125: PUSH
99126: LD_VAR 0 6
99130: PUSH
99131: LD_INT 1
99133: ARRAY
99134: PPUSH
99135: LD_VAR 0 3
99139: PPUSH
99140: CALL_OW 259
99144: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
99145: LD_VAR 0 6
99149: PUSH
99150: LD_INT 1
99152: ARRAY
99153: PPUSH
99154: LD_VAR 0 2
99158: PPUSH
99159: LD_VAR 0 5
99163: PPUSH
99164: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
99168: LD_VAR 0 6
99172: PUSH
99173: LD_INT 1
99175: ARRAY
99176: PPUSH
99177: LD_VAR 0 3
99181: PPUSH
99182: LD_VAR 0 4
99186: PPUSH
99187: CALL_OW 237
// end ;
99191: PPOPN 6
99193: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
99194: LD_EXP 107
99198: PUSH
99199: LD_EXP 154
99203: AND
99204: IFFALSE 99283
99206: GO 99208
99208: DISABLE
99209: LD_INT 0
99211: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
99212: LD_ADDR_VAR 0 1
99216: PUSH
99217: LD_INT 22
99219: PUSH
99220: LD_OWVAR 2
99224: PUSH
99225: EMPTY
99226: LIST
99227: LIST
99228: PUSH
99229: LD_INT 30
99231: PUSH
99232: LD_INT 3
99234: PUSH
99235: EMPTY
99236: LIST
99237: LIST
99238: PUSH
99239: EMPTY
99240: LIST
99241: LIST
99242: PPUSH
99243: CALL_OW 69
99247: ST_TO_ADDR
// if not tmp then
99248: LD_VAR 0 1
99252: NOT
99253: IFFALSE 99257
// exit ;
99255: GO 99283
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99257: LD_VAR 0 1
99261: PUSH
99262: LD_INT 1
99264: PPUSH
99265: LD_VAR 0 1
99269: PPUSH
99270: CALL_OW 12
99274: ARRAY
99275: PPUSH
99276: LD_INT 1
99278: PPUSH
99279: CALL_OW 234
// end ;
99283: PPOPN 1
99285: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
99286: LD_EXP 107
99290: PUSH
99291: LD_EXP 155
99295: AND
99296: IFFALSE 99408
99298: GO 99300
99300: DISABLE
99301: LD_INT 0
99303: PPUSH
99304: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
99305: LD_ADDR_VAR 0 2
99309: PUSH
99310: LD_INT 22
99312: PUSH
99313: LD_OWVAR 2
99317: PUSH
99318: EMPTY
99319: LIST
99320: LIST
99321: PUSH
99322: LD_INT 2
99324: PUSH
99325: LD_INT 30
99327: PUSH
99328: LD_INT 27
99330: PUSH
99331: EMPTY
99332: LIST
99333: LIST
99334: PUSH
99335: LD_INT 30
99337: PUSH
99338: LD_INT 26
99340: PUSH
99341: EMPTY
99342: LIST
99343: LIST
99344: PUSH
99345: LD_INT 30
99347: PUSH
99348: LD_INT 28
99350: PUSH
99351: EMPTY
99352: LIST
99353: LIST
99354: PUSH
99355: EMPTY
99356: LIST
99357: LIST
99358: LIST
99359: LIST
99360: PUSH
99361: EMPTY
99362: LIST
99363: LIST
99364: PPUSH
99365: CALL_OW 69
99369: ST_TO_ADDR
// if not tmp then
99370: LD_VAR 0 2
99374: NOT
99375: IFFALSE 99379
// exit ;
99377: GO 99408
// for i in tmp do
99379: LD_ADDR_VAR 0 1
99383: PUSH
99384: LD_VAR 0 2
99388: PUSH
99389: FOR_IN
99390: IFFALSE 99406
// SetLives ( i , 1 ) ;
99392: LD_VAR 0 1
99396: PPUSH
99397: LD_INT 1
99399: PPUSH
99400: CALL_OW 234
99404: GO 99389
99406: POP
99407: POP
// end ;
99408: PPOPN 2
99410: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
99411: LD_EXP 107
99415: PUSH
99416: LD_EXP 156
99420: AND
99421: IFFALSE 99708
99423: GO 99425
99425: DISABLE
99426: LD_INT 0
99428: PPUSH
99429: PPUSH
99430: PPUSH
// begin i := rand ( 1 , 7 ) ;
99431: LD_ADDR_VAR 0 1
99435: PUSH
99436: LD_INT 1
99438: PPUSH
99439: LD_INT 7
99441: PPUSH
99442: CALL_OW 12
99446: ST_TO_ADDR
// case i of 1 :
99447: LD_VAR 0 1
99451: PUSH
99452: LD_INT 1
99454: DOUBLE
99455: EQUAL
99456: IFTRUE 99460
99458: GO 99470
99460: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
99461: LD_STRING earthquake(getX(game), 0, 32)
99463: PPUSH
99464: CALL_OW 559
99468: GO 99708
99470: LD_INT 2
99472: DOUBLE
99473: EQUAL
99474: IFTRUE 99478
99476: GO 99492
99478: POP
// begin ToLua ( displayStucuk(); ) ;
99479: LD_STRING displayStucuk();
99481: PPUSH
99482: CALL_OW 559
// ResetFog ;
99486: CALL_OW 335
// end ; 3 :
99490: GO 99708
99492: LD_INT 3
99494: DOUBLE
99495: EQUAL
99496: IFTRUE 99500
99498: GO 99604
99500: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99501: LD_ADDR_VAR 0 2
99505: PUSH
99506: LD_INT 22
99508: PUSH
99509: LD_OWVAR 2
99513: PUSH
99514: EMPTY
99515: LIST
99516: LIST
99517: PUSH
99518: LD_INT 25
99520: PUSH
99521: LD_INT 1
99523: PUSH
99524: EMPTY
99525: LIST
99526: LIST
99527: PUSH
99528: EMPTY
99529: LIST
99530: LIST
99531: PPUSH
99532: CALL_OW 69
99536: ST_TO_ADDR
// if not tmp then
99537: LD_VAR 0 2
99541: NOT
99542: IFFALSE 99546
// exit ;
99544: GO 99708
// un := tmp [ rand ( 1 , tmp ) ] ;
99546: LD_ADDR_VAR 0 3
99550: PUSH
99551: LD_VAR 0 2
99555: PUSH
99556: LD_INT 1
99558: PPUSH
99559: LD_VAR 0 2
99563: PPUSH
99564: CALL_OW 12
99568: ARRAY
99569: ST_TO_ADDR
// if Crawls ( un ) then
99570: LD_VAR 0 3
99574: PPUSH
99575: CALL_OW 318
99579: IFFALSE 99590
// ComWalk ( un ) ;
99581: LD_VAR 0 3
99585: PPUSH
99586: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99590: LD_VAR 0 3
99594: PPUSH
99595: LD_INT 8
99597: PPUSH
99598: CALL_OW 336
// end ; 4 :
99602: GO 99708
99604: LD_INT 4
99606: DOUBLE
99607: EQUAL
99608: IFTRUE 99612
99610: GO 99686
99612: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99613: LD_ADDR_VAR 0 2
99617: PUSH
99618: LD_INT 22
99620: PUSH
99621: LD_OWVAR 2
99625: PUSH
99626: EMPTY
99627: LIST
99628: LIST
99629: PUSH
99630: LD_INT 30
99632: PUSH
99633: LD_INT 29
99635: PUSH
99636: EMPTY
99637: LIST
99638: LIST
99639: PUSH
99640: EMPTY
99641: LIST
99642: LIST
99643: PPUSH
99644: CALL_OW 69
99648: ST_TO_ADDR
// if not tmp then
99649: LD_VAR 0 2
99653: NOT
99654: IFFALSE 99658
// exit ;
99656: GO 99708
// CenterNowOnUnits ( tmp [ 1 ] ) ;
99658: LD_VAR 0 2
99662: PUSH
99663: LD_INT 1
99665: ARRAY
99666: PPUSH
99667: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
99671: LD_VAR 0 2
99675: PUSH
99676: LD_INT 1
99678: ARRAY
99679: PPUSH
99680: CALL_OW 65
// end ; 5 .. 7 :
99684: GO 99708
99686: LD_INT 5
99688: DOUBLE
99689: GREATEREQUAL
99690: IFFALSE 99698
99692: LD_INT 7
99694: DOUBLE
99695: LESSEQUAL
99696: IFTRUE 99700
99698: GO 99707
99700: POP
// StreamSibBomb ; end ;
99701: CALL 95945 0 0
99705: GO 99708
99707: POP
// end ;
99708: PPOPN 3
99710: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
99711: LD_EXP 107
99715: PUSH
99716: LD_EXP 157
99720: AND
99721: IFFALSE 99877
99723: GO 99725
99725: DISABLE
99726: LD_INT 0
99728: PPUSH
99729: PPUSH
99730: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
99731: LD_ADDR_VAR 0 2
99735: PUSH
99736: LD_INT 81
99738: PUSH
99739: LD_OWVAR 2
99743: PUSH
99744: EMPTY
99745: LIST
99746: LIST
99747: PUSH
99748: LD_INT 2
99750: PUSH
99751: LD_INT 21
99753: PUSH
99754: LD_INT 1
99756: PUSH
99757: EMPTY
99758: LIST
99759: LIST
99760: PUSH
99761: LD_INT 21
99763: PUSH
99764: LD_INT 2
99766: PUSH
99767: EMPTY
99768: LIST
99769: LIST
99770: PUSH
99771: EMPTY
99772: LIST
99773: LIST
99774: LIST
99775: PUSH
99776: EMPTY
99777: LIST
99778: LIST
99779: PPUSH
99780: CALL_OW 69
99784: ST_TO_ADDR
// if not tmp then
99785: LD_VAR 0 2
99789: NOT
99790: IFFALSE 99794
// exit ;
99792: GO 99877
// p := 0 ;
99794: LD_ADDR_VAR 0 3
99798: PUSH
99799: LD_INT 0
99801: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99802: LD_INT 35
99804: PPUSH
99805: CALL_OW 67
// p := p + 1 ;
99809: LD_ADDR_VAR 0 3
99813: PUSH
99814: LD_VAR 0 3
99818: PUSH
99819: LD_INT 1
99821: PLUS
99822: ST_TO_ADDR
// for i in tmp do
99823: LD_ADDR_VAR 0 1
99827: PUSH
99828: LD_VAR 0 2
99832: PUSH
99833: FOR_IN
99834: IFFALSE 99865
// if GetLives ( i ) < 1000 then
99836: LD_VAR 0 1
99840: PPUSH
99841: CALL_OW 256
99845: PUSH
99846: LD_INT 1000
99848: LESS
99849: IFFALSE 99863
// SetLives ( i , 1000 ) ;
99851: LD_VAR 0 1
99855: PPUSH
99856: LD_INT 1000
99858: PPUSH
99859: CALL_OW 234
99863: GO 99833
99865: POP
99866: POP
// until p > 20 ;
99867: LD_VAR 0 3
99871: PUSH
99872: LD_INT 20
99874: GREATER
99875: IFFALSE 99802
// end ;
99877: PPOPN 3
99879: END
// every 0 0$1 trigger StreamModeActive and sTime do
99880: LD_EXP 107
99884: PUSH
99885: LD_EXP 158
99889: AND
99890: IFFALSE 99925
99892: GO 99894
99894: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
99895: LD_INT 28
99897: PPUSH
99898: LD_OWVAR 2
99902: PPUSH
99903: LD_INT 2
99905: PPUSH
99906: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
99910: LD_INT 30
99912: PPUSH
99913: LD_OWVAR 2
99917: PPUSH
99918: LD_INT 2
99920: PPUSH
99921: CALL_OW 322
// end ;
99925: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
99926: LD_EXP 107
99930: PUSH
99931: LD_EXP 159
99935: AND
99936: IFFALSE 100057
99938: GO 99940
99940: DISABLE
99941: LD_INT 0
99943: PPUSH
99944: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99945: LD_ADDR_VAR 0 2
99949: PUSH
99950: LD_INT 22
99952: PUSH
99953: LD_OWVAR 2
99957: PUSH
99958: EMPTY
99959: LIST
99960: LIST
99961: PUSH
99962: LD_INT 21
99964: PUSH
99965: LD_INT 1
99967: PUSH
99968: EMPTY
99969: LIST
99970: LIST
99971: PUSH
99972: LD_INT 3
99974: PUSH
99975: LD_INT 23
99977: PUSH
99978: LD_INT 0
99980: PUSH
99981: EMPTY
99982: LIST
99983: LIST
99984: PUSH
99985: EMPTY
99986: LIST
99987: LIST
99988: PUSH
99989: EMPTY
99990: LIST
99991: LIST
99992: LIST
99993: PPUSH
99994: CALL_OW 69
99998: ST_TO_ADDR
// if not tmp then
99999: LD_VAR 0 2
100003: NOT
100004: IFFALSE 100008
// exit ;
100006: GO 100057
// for i in tmp do
100008: LD_ADDR_VAR 0 1
100012: PUSH
100013: LD_VAR 0 2
100017: PUSH
100018: FOR_IN
100019: IFFALSE 100055
// begin if Crawls ( i ) then
100021: LD_VAR 0 1
100025: PPUSH
100026: CALL_OW 318
100030: IFFALSE 100041
// ComWalk ( i ) ;
100032: LD_VAR 0 1
100036: PPUSH
100037: CALL_OW 138
// SetClass ( i , 2 ) ;
100041: LD_VAR 0 1
100045: PPUSH
100046: LD_INT 2
100048: PPUSH
100049: CALL_OW 336
// end ;
100053: GO 100018
100055: POP
100056: POP
// end ;
100057: PPOPN 2
100059: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
100060: LD_EXP 107
100064: PUSH
100065: LD_EXP 160
100069: AND
100070: IFFALSE 100358
100072: GO 100074
100074: DISABLE
100075: LD_INT 0
100077: PPUSH
100078: PPUSH
100079: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
100080: LD_OWVAR 2
100084: PPUSH
100085: LD_INT 9
100087: PPUSH
100088: LD_INT 1
100090: PPUSH
100091: LD_INT 1
100093: PPUSH
100094: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
100098: LD_INT 9
100100: PPUSH
100101: LD_OWVAR 2
100105: PPUSH
100106: CALL_OW 343
// uc_side := 9 ;
100110: LD_ADDR_OWVAR 20
100114: PUSH
100115: LD_INT 9
100117: ST_TO_ADDR
// uc_nation := 2 ;
100118: LD_ADDR_OWVAR 21
100122: PUSH
100123: LD_INT 2
100125: ST_TO_ADDR
// hc_name := Dark Warrior ;
100126: LD_ADDR_OWVAR 26
100130: PUSH
100131: LD_STRING Dark Warrior
100133: ST_TO_ADDR
// hc_gallery :=  ;
100134: LD_ADDR_OWVAR 33
100138: PUSH
100139: LD_STRING 
100141: ST_TO_ADDR
// hc_noskilllimit := true ;
100142: LD_ADDR_OWVAR 76
100146: PUSH
100147: LD_INT 1
100149: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
100150: LD_ADDR_OWVAR 31
100154: PUSH
100155: LD_INT 30
100157: PUSH
100158: LD_INT 30
100160: PUSH
100161: LD_INT 30
100163: PUSH
100164: LD_INT 30
100166: PUSH
100167: EMPTY
100168: LIST
100169: LIST
100170: LIST
100171: LIST
100172: ST_TO_ADDR
// un := CreateHuman ;
100173: LD_ADDR_VAR 0 3
100177: PUSH
100178: CALL_OW 44
100182: ST_TO_ADDR
// hc_noskilllimit := false ;
100183: LD_ADDR_OWVAR 76
100187: PUSH
100188: LD_INT 0
100190: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100191: LD_VAR 0 3
100195: PPUSH
100196: LD_INT 1
100198: PPUSH
100199: CALL_OW 51
// ToLua ( playRanger() ) ;
100203: LD_STRING playRanger()
100205: PPUSH
100206: CALL_OW 559
// p := 0 ;
100210: LD_ADDR_VAR 0 2
100214: PUSH
100215: LD_INT 0
100217: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100218: LD_INT 35
100220: PPUSH
100221: CALL_OW 67
// p := p + 1 ;
100225: LD_ADDR_VAR 0 2
100229: PUSH
100230: LD_VAR 0 2
100234: PUSH
100235: LD_INT 1
100237: PLUS
100238: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
100239: LD_VAR 0 3
100243: PPUSH
100244: CALL_OW 256
100248: PUSH
100249: LD_INT 1000
100251: LESS
100252: IFFALSE 100266
// SetLives ( un , 1000 ) ;
100254: LD_VAR 0 3
100258: PPUSH
100259: LD_INT 1000
100261: PPUSH
100262: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
100266: LD_VAR 0 3
100270: PPUSH
100271: LD_INT 81
100273: PUSH
100274: LD_OWVAR 2
100278: PUSH
100279: EMPTY
100280: LIST
100281: LIST
100282: PUSH
100283: LD_INT 91
100285: PUSH
100286: LD_VAR 0 3
100290: PUSH
100291: LD_INT 30
100293: PUSH
100294: EMPTY
100295: LIST
100296: LIST
100297: LIST
100298: PUSH
100299: EMPTY
100300: LIST
100301: LIST
100302: PPUSH
100303: CALL_OW 69
100307: PPUSH
100308: LD_VAR 0 3
100312: PPUSH
100313: CALL_OW 74
100317: PPUSH
100318: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
100322: LD_VAR 0 2
100326: PUSH
100327: LD_INT 80
100329: GREATER
100330: PUSH
100331: LD_VAR 0 3
100335: PPUSH
100336: CALL_OW 301
100340: OR
100341: IFFALSE 100218
// if un then
100343: LD_VAR 0 3
100347: IFFALSE 100358
// RemoveUnit ( un ) ;
100349: LD_VAR 0 3
100353: PPUSH
100354: CALL_OW 64
// end ;
100358: PPOPN 3
100360: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
100361: LD_EXP 161
100365: IFFALSE 100481
100367: GO 100369
100369: DISABLE
100370: LD_INT 0
100372: PPUSH
100373: PPUSH
100374: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100375: LD_ADDR_VAR 0 2
100379: PUSH
100380: LD_INT 81
100382: PUSH
100383: LD_OWVAR 2
100387: PUSH
100388: EMPTY
100389: LIST
100390: LIST
100391: PUSH
100392: LD_INT 21
100394: PUSH
100395: LD_INT 1
100397: PUSH
100398: EMPTY
100399: LIST
100400: LIST
100401: PUSH
100402: EMPTY
100403: LIST
100404: LIST
100405: PPUSH
100406: CALL_OW 69
100410: ST_TO_ADDR
// ToLua ( playComputer() ) ;
100411: LD_STRING playComputer()
100413: PPUSH
100414: CALL_OW 559
// if not tmp then
100418: LD_VAR 0 2
100422: NOT
100423: IFFALSE 100427
// exit ;
100425: GO 100481
// for i in tmp do
100427: LD_ADDR_VAR 0 1
100431: PUSH
100432: LD_VAR 0 2
100436: PUSH
100437: FOR_IN
100438: IFFALSE 100479
// for j := 1 to 4 do
100440: LD_ADDR_VAR 0 3
100444: PUSH
100445: DOUBLE
100446: LD_INT 1
100448: DEC
100449: ST_TO_ADDR
100450: LD_INT 4
100452: PUSH
100453: FOR_TO
100454: IFFALSE 100475
// SetSkill ( i , j , 10 ) ;
100456: LD_VAR 0 1
100460: PPUSH
100461: LD_VAR 0 3
100465: PPUSH
100466: LD_INT 10
100468: PPUSH
100469: CALL_OW 237
100473: GO 100453
100475: POP
100476: POP
100477: GO 100437
100479: POP
100480: POP
// end ;
100481: PPOPN 3
100483: END
// every 0 0$1 trigger s30 do var i , tmp ;
100484: LD_EXP 162
100488: IFFALSE 100557
100490: GO 100492
100492: DISABLE
100493: LD_INT 0
100495: PPUSH
100496: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100497: LD_ADDR_VAR 0 2
100501: PUSH
100502: LD_INT 22
100504: PUSH
100505: LD_OWVAR 2
100509: PUSH
100510: EMPTY
100511: LIST
100512: LIST
100513: PPUSH
100514: CALL_OW 69
100518: ST_TO_ADDR
// if not tmp then
100519: LD_VAR 0 2
100523: NOT
100524: IFFALSE 100528
// exit ;
100526: GO 100557
// for i in tmp do
100528: LD_ADDR_VAR 0 1
100532: PUSH
100533: LD_VAR 0 2
100537: PUSH
100538: FOR_IN
100539: IFFALSE 100555
// SetLives ( i , 300 ) ;
100541: LD_VAR 0 1
100545: PPUSH
100546: LD_INT 300
100548: PPUSH
100549: CALL_OW 234
100553: GO 100538
100555: POP
100556: POP
// end ;
100557: PPOPN 2
100559: END
// every 0 0$1 trigger s60 do var i , tmp ;
100560: LD_EXP 163
100564: IFFALSE 100633
100566: GO 100568
100568: DISABLE
100569: LD_INT 0
100571: PPUSH
100572: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100573: LD_ADDR_VAR 0 2
100577: PUSH
100578: LD_INT 22
100580: PUSH
100581: LD_OWVAR 2
100585: PUSH
100586: EMPTY
100587: LIST
100588: LIST
100589: PPUSH
100590: CALL_OW 69
100594: ST_TO_ADDR
// if not tmp then
100595: LD_VAR 0 2
100599: NOT
100600: IFFALSE 100604
// exit ;
100602: GO 100633
// for i in tmp do
100604: LD_ADDR_VAR 0 1
100608: PUSH
100609: LD_VAR 0 2
100613: PUSH
100614: FOR_IN
100615: IFFALSE 100631
// SetLives ( i , 600 ) ;
100617: LD_VAR 0 1
100621: PPUSH
100622: LD_INT 600
100624: PPUSH
100625: CALL_OW 234
100629: GO 100614
100631: POP
100632: POP
// end ;
100633: PPOPN 2
100635: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
100636: LD_INT 0
100638: PPUSH
// case cmd of 301 :
100639: LD_VAR 0 1
100643: PUSH
100644: LD_INT 301
100646: DOUBLE
100647: EQUAL
100648: IFTRUE 100652
100650: GO 100684
100652: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
100653: LD_VAR 0 6
100657: PPUSH
100658: LD_VAR 0 7
100662: PPUSH
100663: LD_VAR 0 8
100667: PPUSH
100668: LD_VAR 0 4
100672: PPUSH
100673: LD_VAR 0 5
100677: PPUSH
100678: CALL 101893 0 5
100682: GO 100805
100684: LD_INT 302
100686: DOUBLE
100687: EQUAL
100688: IFTRUE 100692
100690: GO 100729
100692: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
100693: LD_VAR 0 6
100697: PPUSH
100698: LD_VAR 0 7
100702: PPUSH
100703: LD_VAR 0 8
100707: PPUSH
100708: LD_VAR 0 9
100712: PPUSH
100713: LD_VAR 0 4
100717: PPUSH
100718: LD_VAR 0 5
100722: PPUSH
100723: CALL 101984 0 6
100727: GO 100805
100729: LD_INT 303
100731: DOUBLE
100732: EQUAL
100733: IFTRUE 100737
100735: GO 100774
100737: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
100738: LD_VAR 0 6
100742: PPUSH
100743: LD_VAR 0 7
100747: PPUSH
100748: LD_VAR 0 8
100752: PPUSH
100753: LD_VAR 0 9
100757: PPUSH
100758: LD_VAR 0 4
100762: PPUSH
100763: LD_VAR 0 5
100767: PPUSH
100768: CALL 100810 0 6
100772: GO 100805
100774: LD_INT 304
100776: DOUBLE
100777: EQUAL
100778: IFTRUE 100782
100780: GO 100804
100782: POP
// hHackTeleport ( unit , x , y ) ; end ;
100783: LD_VAR 0 2
100787: PPUSH
100788: LD_VAR 0 4
100792: PPUSH
100793: LD_VAR 0 5
100797: PPUSH
100798: CALL 102577 0 3
100802: GO 100805
100804: POP
// end ;
100805: LD_VAR 0 12
100809: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
100810: LD_INT 0
100812: PPUSH
100813: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
100814: LD_VAR 0 1
100818: PUSH
100819: LD_INT 1
100821: LESS
100822: PUSH
100823: LD_VAR 0 1
100827: PUSH
100828: LD_INT 3
100830: GREATER
100831: OR
100832: PUSH
100833: LD_VAR 0 5
100837: PPUSH
100838: LD_VAR 0 6
100842: PPUSH
100843: CALL_OW 428
100847: OR
100848: IFFALSE 100852
// exit ;
100850: GO 101580
// uc_side := your_side ;
100852: LD_ADDR_OWVAR 20
100856: PUSH
100857: LD_OWVAR 2
100861: ST_TO_ADDR
// uc_nation := nation ;
100862: LD_ADDR_OWVAR 21
100866: PUSH
100867: LD_VAR 0 1
100871: ST_TO_ADDR
// bc_level = 1 ;
100872: LD_ADDR_OWVAR 43
100876: PUSH
100877: LD_INT 1
100879: ST_TO_ADDR
// case btype of 1 :
100880: LD_VAR 0 2
100884: PUSH
100885: LD_INT 1
100887: DOUBLE
100888: EQUAL
100889: IFTRUE 100893
100891: GO 100904
100893: POP
// bc_type := b_depot ; 2 :
100894: LD_ADDR_OWVAR 42
100898: PUSH
100899: LD_INT 0
100901: ST_TO_ADDR
100902: GO 101524
100904: LD_INT 2
100906: DOUBLE
100907: EQUAL
100908: IFTRUE 100912
100910: GO 100923
100912: POP
// bc_type := b_warehouse ; 3 :
100913: LD_ADDR_OWVAR 42
100917: PUSH
100918: LD_INT 1
100920: ST_TO_ADDR
100921: GO 101524
100923: LD_INT 3
100925: DOUBLE
100926: EQUAL
100927: IFTRUE 100931
100929: GO 100942
100931: POP
// bc_type := b_lab ; 4 .. 9 :
100932: LD_ADDR_OWVAR 42
100936: PUSH
100937: LD_INT 6
100939: ST_TO_ADDR
100940: GO 101524
100942: LD_INT 4
100944: DOUBLE
100945: GREATEREQUAL
100946: IFFALSE 100954
100948: LD_INT 9
100950: DOUBLE
100951: LESSEQUAL
100952: IFTRUE 100956
100954: GO 101016
100956: POP
// begin bc_type := b_lab_half ;
100957: LD_ADDR_OWVAR 42
100961: PUSH
100962: LD_INT 7
100964: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
100965: LD_ADDR_OWVAR 44
100969: PUSH
100970: LD_INT 10
100972: PUSH
100973: LD_INT 11
100975: PUSH
100976: LD_INT 12
100978: PUSH
100979: LD_INT 15
100981: PUSH
100982: LD_INT 14
100984: PUSH
100985: LD_INT 13
100987: PUSH
100988: EMPTY
100989: LIST
100990: LIST
100991: LIST
100992: LIST
100993: LIST
100994: LIST
100995: PUSH
100996: LD_VAR 0 2
101000: PUSH
101001: LD_INT 3
101003: MINUS
101004: ARRAY
101005: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
101006: LD_ADDR_OWVAR 45
101010: PUSH
101011: LD_INT 9
101013: ST_TO_ADDR
// end ; 10 .. 13 :
101014: GO 101524
101016: LD_INT 10
101018: DOUBLE
101019: GREATEREQUAL
101020: IFFALSE 101028
101022: LD_INT 13
101024: DOUBLE
101025: LESSEQUAL
101026: IFTRUE 101030
101028: GO 101107
101030: POP
// begin bc_type := b_lab_full ;
101031: LD_ADDR_OWVAR 42
101035: PUSH
101036: LD_INT 8
101038: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
101039: LD_ADDR_OWVAR 44
101043: PUSH
101044: LD_INT 10
101046: PUSH
101047: LD_INT 12
101049: PUSH
101050: LD_INT 14
101052: PUSH
101053: LD_INT 13
101055: PUSH
101056: EMPTY
101057: LIST
101058: LIST
101059: LIST
101060: LIST
101061: PUSH
101062: LD_VAR 0 2
101066: PUSH
101067: LD_INT 9
101069: MINUS
101070: ARRAY
101071: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
101072: LD_ADDR_OWVAR 45
101076: PUSH
101077: LD_INT 11
101079: PUSH
101080: LD_INT 15
101082: PUSH
101083: LD_INT 12
101085: PUSH
101086: LD_INT 15
101088: PUSH
101089: EMPTY
101090: LIST
101091: LIST
101092: LIST
101093: LIST
101094: PUSH
101095: LD_VAR 0 2
101099: PUSH
101100: LD_INT 9
101102: MINUS
101103: ARRAY
101104: ST_TO_ADDR
// end ; 14 :
101105: GO 101524
101107: LD_INT 14
101109: DOUBLE
101110: EQUAL
101111: IFTRUE 101115
101113: GO 101126
101115: POP
// bc_type := b_workshop ; 15 :
101116: LD_ADDR_OWVAR 42
101120: PUSH
101121: LD_INT 2
101123: ST_TO_ADDR
101124: GO 101524
101126: LD_INT 15
101128: DOUBLE
101129: EQUAL
101130: IFTRUE 101134
101132: GO 101145
101134: POP
// bc_type := b_factory ; 16 :
101135: LD_ADDR_OWVAR 42
101139: PUSH
101140: LD_INT 3
101142: ST_TO_ADDR
101143: GO 101524
101145: LD_INT 16
101147: DOUBLE
101148: EQUAL
101149: IFTRUE 101153
101151: GO 101164
101153: POP
// bc_type := b_ext_gun ; 17 :
101154: LD_ADDR_OWVAR 42
101158: PUSH
101159: LD_INT 17
101161: ST_TO_ADDR
101162: GO 101524
101164: LD_INT 17
101166: DOUBLE
101167: EQUAL
101168: IFTRUE 101172
101170: GO 101200
101172: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
101173: LD_ADDR_OWVAR 42
101177: PUSH
101178: LD_INT 19
101180: PUSH
101181: LD_INT 23
101183: PUSH
101184: LD_INT 19
101186: PUSH
101187: EMPTY
101188: LIST
101189: LIST
101190: LIST
101191: PUSH
101192: LD_VAR 0 1
101196: ARRAY
101197: ST_TO_ADDR
101198: GO 101524
101200: LD_INT 18
101202: DOUBLE
101203: EQUAL
101204: IFTRUE 101208
101206: GO 101219
101208: POP
// bc_type := b_ext_radar ; 19 :
101209: LD_ADDR_OWVAR 42
101213: PUSH
101214: LD_INT 20
101216: ST_TO_ADDR
101217: GO 101524
101219: LD_INT 19
101221: DOUBLE
101222: EQUAL
101223: IFTRUE 101227
101225: GO 101238
101227: POP
// bc_type := b_ext_radio ; 20 :
101228: LD_ADDR_OWVAR 42
101232: PUSH
101233: LD_INT 22
101235: ST_TO_ADDR
101236: GO 101524
101238: LD_INT 20
101240: DOUBLE
101241: EQUAL
101242: IFTRUE 101246
101244: GO 101257
101246: POP
// bc_type := b_ext_siberium ; 21 :
101247: LD_ADDR_OWVAR 42
101251: PUSH
101252: LD_INT 21
101254: ST_TO_ADDR
101255: GO 101524
101257: LD_INT 21
101259: DOUBLE
101260: EQUAL
101261: IFTRUE 101265
101263: GO 101276
101265: POP
// bc_type := b_ext_computer ; 22 :
101266: LD_ADDR_OWVAR 42
101270: PUSH
101271: LD_INT 24
101273: ST_TO_ADDR
101274: GO 101524
101276: LD_INT 22
101278: DOUBLE
101279: EQUAL
101280: IFTRUE 101284
101282: GO 101295
101284: POP
// bc_type := b_ext_track ; 23 :
101285: LD_ADDR_OWVAR 42
101289: PUSH
101290: LD_INT 16
101292: ST_TO_ADDR
101293: GO 101524
101295: LD_INT 23
101297: DOUBLE
101298: EQUAL
101299: IFTRUE 101303
101301: GO 101314
101303: POP
// bc_type := b_ext_laser ; 24 :
101304: LD_ADDR_OWVAR 42
101308: PUSH
101309: LD_INT 25
101311: ST_TO_ADDR
101312: GO 101524
101314: LD_INT 24
101316: DOUBLE
101317: EQUAL
101318: IFTRUE 101322
101320: GO 101333
101322: POP
// bc_type := b_control_tower ; 25 :
101323: LD_ADDR_OWVAR 42
101327: PUSH
101328: LD_INT 36
101330: ST_TO_ADDR
101331: GO 101524
101333: LD_INT 25
101335: DOUBLE
101336: EQUAL
101337: IFTRUE 101341
101339: GO 101352
101341: POP
// bc_type := b_breastwork ; 26 :
101342: LD_ADDR_OWVAR 42
101346: PUSH
101347: LD_INT 31
101349: ST_TO_ADDR
101350: GO 101524
101352: LD_INT 26
101354: DOUBLE
101355: EQUAL
101356: IFTRUE 101360
101358: GO 101371
101360: POP
// bc_type := b_bunker ; 27 :
101361: LD_ADDR_OWVAR 42
101365: PUSH
101366: LD_INT 32
101368: ST_TO_ADDR
101369: GO 101524
101371: LD_INT 27
101373: DOUBLE
101374: EQUAL
101375: IFTRUE 101379
101377: GO 101390
101379: POP
// bc_type := b_turret ; 28 :
101380: LD_ADDR_OWVAR 42
101384: PUSH
101385: LD_INT 33
101387: ST_TO_ADDR
101388: GO 101524
101390: LD_INT 28
101392: DOUBLE
101393: EQUAL
101394: IFTRUE 101398
101396: GO 101409
101398: POP
// bc_type := b_armoury ; 29 :
101399: LD_ADDR_OWVAR 42
101403: PUSH
101404: LD_INT 4
101406: ST_TO_ADDR
101407: GO 101524
101409: LD_INT 29
101411: DOUBLE
101412: EQUAL
101413: IFTRUE 101417
101415: GO 101428
101417: POP
// bc_type := b_barracks ; 30 :
101418: LD_ADDR_OWVAR 42
101422: PUSH
101423: LD_INT 5
101425: ST_TO_ADDR
101426: GO 101524
101428: LD_INT 30
101430: DOUBLE
101431: EQUAL
101432: IFTRUE 101436
101434: GO 101447
101436: POP
// bc_type := b_solar_power ; 31 :
101437: LD_ADDR_OWVAR 42
101441: PUSH
101442: LD_INT 27
101444: ST_TO_ADDR
101445: GO 101524
101447: LD_INT 31
101449: DOUBLE
101450: EQUAL
101451: IFTRUE 101455
101453: GO 101466
101455: POP
// bc_type := b_oil_power ; 32 :
101456: LD_ADDR_OWVAR 42
101460: PUSH
101461: LD_INT 26
101463: ST_TO_ADDR
101464: GO 101524
101466: LD_INT 32
101468: DOUBLE
101469: EQUAL
101470: IFTRUE 101474
101472: GO 101485
101474: POP
// bc_type := b_siberite_power ; 33 :
101475: LD_ADDR_OWVAR 42
101479: PUSH
101480: LD_INT 28
101482: ST_TO_ADDR
101483: GO 101524
101485: LD_INT 33
101487: DOUBLE
101488: EQUAL
101489: IFTRUE 101493
101491: GO 101504
101493: POP
// bc_type := b_oil_mine ; 34 :
101494: LD_ADDR_OWVAR 42
101498: PUSH
101499: LD_INT 29
101501: ST_TO_ADDR
101502: GO 101524
101504: LD_INT 34
101506: DOUBLE
101507: EQUAL
101508: IFTRUE 101512
101510: GO 101523
101512: POP
// bc_type := b_siberite_mine ; end ;
101513: LD_ADDR_OWVAR 42
101517: PUSH
101518: LD_INT 30
101520: ST_TO_ADDR
101521: GO 101524
101523: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
101524: LD_ADDR_VAR 0 8
101528: PUSH
101529: LD_VAR 0 5
101533: PPUSH
101534: LD_VAR 0 6
101538: PPUSH
101539: LD_VAR 0 3
101543: PPUSH
101544: CALL_OW 47
101548: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
101549: LD_OWVAR 42
101553: PUSH
101554: LD_INT 32
101556: PUSH
101557: LD_INT 33
101559: PUSH
101560: EMPTY
101561: LIST
101562: LIST
101563: IN
101564: IFFALSE 101580
// PlaceWeaponTurret ( b , weapon ) ;
101566: LD_VAR 0 8
101570: PPUSH
101571: LD_VAR 0 4
101575: PPUSH
101576: CALL_OW 431
// end ;
101580: LD_VAR 0 7
101584: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
101585: LD_INT 0
101587: PPUSH
101588: PPUSH
101589: PPUSH
101590: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101591: LD_ADDR_VAR 0 4
101595: PUSH
101596: LD_INT 22
101598: PUSH
101599: LD_OWVAR 2
101603: PUSH
101604: EMPTY
101605: LIST
101606: LIST
101607: PUSH
101608: LD_INT 2
101610: PUSH
101611: LD_INT 30
101613: PUSH
101614: LD_INT 0
101616: PUSH
101617: EMPTY
101618: LIST
101619: LIST
101620: PUSH
101621: LD_INT 30
101623: PUSH
101624: LD_INT 1
101626: PUSH
101627: EMPTY
101628: LIST
101629: LIST
101630: PUSH
101631: EMPTY
101632: LIST
101633: LIST
101634: LIST
101635: PUSH
101636: EMPTY
101637: LIST
101638: LIST
101639: PPUSH
101640: CALL_OW 69
101644: ST_TO_ADDR
// if not tmp then
101645: LD_VAR 0 4
101649: NOT
101650: IFFALSE 101654
// exit ;
101652: GO 101713
// for i in tmp do
101654: LD_ADDR_VAR 0 2
101658: PUSH
101659: LD_VAR 0 4
101663: PUSH
101664: FOR_IN
101665: IFFALSE 101711
// for j = 1 to 3 do
101667: LD_ADDR_VAR 0 3
101671: PUSH
101672: DOUBLE
101673: LD_INT 1
101675: DEC
101676: ST_TO_ADDR
101677: LD_INT 3
101679: PUSH
101680: FOR_TO
101681: IFFALSE 101707
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
101683: LD_VAR 0 2
101687: PPUSH
101688: CALL_OW 274
101692: PPUSH
101693: LD_VAR 0 3
101697: PPUSH
101698: LD_INT 99999
101700: PPUSH
101701: CALL_OW 277
101705: GO 101680
101707: POP
101708: POP
101709: GO 101664
101711: POP
101712: POP
// end ;
101713: LD_VAR 0 1
101717: RET
// export function hHackSetLevel10 ; var i , j ; begin
101718: LD_INT 0
101720: PPUSH
101721: PPUSH
101722: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101723: LD_ADDR_VAR 0 2
101727: PUSH
101728: LD_INT 21
101730: PUSH
101731: LD_INT 1
101733: PUSH
101734: EMPTY
101735: LIST
101736: LIST
101737: PPUSH
101738: CALL_OW 69
101742: PUSH
101743: FOR_IN
101744: IFFALSE 101796
// if IsSelected ( i ) then
101746: LD_VAR 0 2
101750: PPUSH
101751: CALL_OW 306
101755: IFFALSE 101794
// begin for j := 1 to 4 do
101757: LD_ADDR_VAR 0 3
101761: PUSH
101762: DOUBLE
101763: LD_INT 1
101765: DEC
101766: ST_TO_ADDR
101767: LD_INT 4
101769: PUSH
101770: FOR_TO
101771: IFFALSE 101792
// SetSkill ( i , j , 10 ) ;
101773: LD_VAR 0 2
101777: PPUSH
101778: LD_VAR 0 3
101782: PPUSH
101783: LD_INT 10
101785: PPUSH
101786: CALL_OW 237
101790: GO 101770
101792: POP
101793: POP
// end ;
101794: GO 101743
101796: POP
101797: POP
// end ;
101798: LD_VAR 0 1
101802: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
101803: LD_INT 0
101805: PPUSH
101806: PPUSH
101807: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
101808: LD_ADDR_VAR 0 2
101812: PUSH
101813: LD_INT 22
101815: PUSH
101816: LD_OWVAR 2
101820: PUSH
101821: EMPTY
101822: LIST
101823: LIST
101824: PUSH
101825: LD_INT 21
101827: PUSH
101828: LD_INT 1
101830: PUSH
101831: EMPTY
101832: LIST
101833: LIST
101834: PUSH
101835: EMPTY
101836: LIST
101837: LIST
101838: PPUSH
101839: CALL_OW 69
101843: PUSH
101844: FOR_IN
101845: IFFALSE 101886
// begin for j := 1 to 4 do
101847: LD_ADDR_VAR 0 3
101851: PUSH
101852: DOUBLE
101853: LD_INT 1
101855: DEC
101856: ST_TO_ADDR
101857: LD_INT 4
101859: PUSH
101860: FOR_TO
101861: IFFALSE 101882
// SetSkill ( i , j , 10 ) ;
101863: LD_VAR 0 2
101867: PPUSH
101868: LD_VAR 0 3
101872: PPUSH
101873: LD_INT 10
101875: PPUSH
101876: CALL_OW 237
101880: GO 101860
101882: POP
101883: POP
// end ;
101884: GO 101844
101886: POP
101887: POP
// end ;
101888: LD_VAR 0 1
101892: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
101893: LD_INT 0
101895: PPUSH
// uc_side := your_side ;
101896: LD_ADDR_OWVAR 20
101900: PUSH
101901: LD_OWVAR 2
101905: ST_TO_ADDR
// uc_nation := nation ;
101906: LD_ADDR_OWVAR 21
101910: PUSH
101911: LD_VAR 0 1
101915: ST_TO_ADDR
// InitHc ;
101916: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
101920: LD_INT 0
101922: PPUSH
101923: LD_VAR 0 2
101927: PPUSH
101928: LD_VAR 0 3
101932: PPUSH
101933: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
101937: LD_VAR 0 4
101941: PPUSH
101942: LD_VAR 0 5
101946: PPUSH
101947: CALL_OW 428
101951: PUSH
101952: LD_INT 0
101954: EQUAL
101955: IFFALSE 101979
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
101957: CALL_OW 44
101961: PPUSH
101962: LD_VAR 0 4
101966: PPUSH
101967: LD_VAR 0 5
101971: PPUSH
101972: LD_INT 1
101974: PPUSH
101975: CALL_OW 48
// end ;
101979: LD_VAR 0 6
101983: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
101984: LD_INT 0
101986: PPUSH
101987: PPUSH
// uc_side := your_side ;
101988: LD_ADDR_OWVAR 20
101992: PUSH
101993: LD_OWVAR 2
101997: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
101998: LD_VAR 0 1
102002: PUSH
102003: LD_INT 1
102005: PUSH
102006: LD_INT 2
102008: PUSH
102009: LD_INT 3
102011: PUSH
102012: LD_INT 4
102014: PUSH
102015: LD_INT 5
102017: PUSH
102018: EMPTY
102019: LIST
102020: LIST
102021: LIST
102022: LIST
102023: LIST
102024: IN
102025: IFFALSE 102037
// uc_nation := nation_american else
102027: LD_ADDR_OWVAR 21
102031: PUSH
102032: LD_INT 1
102034: ST_TO_ADDR
102035: GO 102080
// if chassis in [ 11 , 12 , 13 , 14 ] then
102037: LD_VAR 0 1
102041: PUSH
102042: LD_INT 11
102044: PUSH
102045: LD_INT 12
102047: PUSH
102048: LD_INT 13
102050: PUSH
102051: LD_INT 14
102053: PUSH
102054: EMPTY
102055: LIST
102056: LIST
102057: LIST
102058: LIST
102059: IN
102060: IFFALSE 102072
// uc_nation := nation_arabian else
102062: LD_ADDR_OWVAR 21
102066: PUSH
102067: LD_INT 2
102069: ST_TO_ADDR
102070: GO 102080
// uc_nation := nation_russian ;
102072: LD_ADDR_OWVAR 21
102076: PUSH
102077: LD_INT 3
102079: ST_TO_ADDR
// vc_chassis := chassis ;
102080: LD_ADDR_OWVAR 37
102084: PUSH
102085: LD_VAR 0 1
102089: ST_TO_ADDR
// vc_engine := engine ;
102090: LD_ADDR_OWVAR 39
102094: PUSH
102095: LD_VAR 0 2
102099: ST_TO_ADDR
// vc_control := control ;
102100: LD_ADDR_OWVAR 38
102104: PUSH
102105: LD_VAR 0 3
102109: ST_TO_ADDR
// vc_weapon := weapon ;
102110: LD_ADDR_OWVAR 40
102114: PUSH
102115: LD_VAR 0 4
102119: ST_TO_ADDR
// un := CreateVehicle ;
102120: LD_ADDR_VAR 0 8
102124: PUSH
102125: CALL_OW 45
102129: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
102130: LD_VAR 0 8
102134: PPUSH
102135: LD_INT 0
102137: PPUSH
102138: LD_INT 5
102140: PPUSH
102141: CALL_OW 12
102145: PPUSH
102146: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
102150: LD_VAR 0 8
102154: PPUSH
102155: LD_VAR 0 5
102159: PPUSH
102160: LD_VAR 0 6
102164: PPUSH
102165: LD_INT 1
102167: PPUSH
102168: CALL_OW 48
// end ;
102172: LD_VAR 0 7
102176: RET
// export hInvincible ; every 1 do
102177: GO 102179
102179: DISABLE
// hInvincible := [ ] ;
102180: LD_ADDR_EXP 164
102184: PUSH
102185: EMPTY
102186: ST_TO_ADDR
102187: END
// every 10 do var i ;
102188: GO 102190
102190: DISABLE
102191: LD_INT 0
102193: PPUSH
// begin enable ;
102194: ENABLE
// if not hInvincible then
102195: LD_EXP 164
102199: NOT
102200: IFFALSE 102204
// exit ;
102202: GO 102248
// for i in hInvincible do
102204: LD_ADDR_VAR 0 1
102208: PUSH
102209: LD_EXP 164
102213: PUSH
102214: FOR_IN
102215: IFFALSE 102246
// if GetLives ( i ) < 1000 then
102217: LD_VAR 0 1
102221: PPUSH
102222: CALL_OW 256
102226: PUSH
102227: LD_INT 1000
102229: LESS
102230: IFFALSE 102244
// SetLives ( i , 1000 ) ;
102232: LD_VAR 0 1
102236: PPUSH
102237: LD_INT 1000
102239: PPUSH
102240: CALL_OW 234
102244: GO 102214
102246: POP
102247: POP
// end ;
102248: PPOPN 1
102250: END
// export function hHackInvincible ; var i ; begin
102251: LD_INT 0
102253: PPUSH
102254: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
102255: LD_ADDR_VAR 0 2
102259: PUSH
102260: LD_INT 2
102262: PUSH
102263: LD_INT 21
102265: PUSH
102266: LD_INT 1
102268: PUSH
102269: EMPTY
102270: LIST
102271: LIST
102272: PUSH
102273: LD_INT 21
102275: PUSH
102276: LD_INT 2
102278: PUSH
102279: EMPTY
102280: LIST
102281: LIST
102282: PUSH
102283: EMPTY
102284: LIST
102285: LIST
102286: LIST
102287: PPUSH
102288: CALL_OW 69
102292: PUSH
102293: FOR_IN
102294: IFFALSE 102355
// if IsSelected ( i ) then
102296: LD_VAR 0 2
102300: PPUSH
102301: CALL_OW 306
102305: IFFALSE 102353
// begin if i in hInvincible then
102307: LD_VAR 0 2
102311: PUSH
102312: LD_EXP 164
102316: IN
102317: IFFALSE 102337
// hInvincible := hInvincible diff i else
102319: LD_ADDR_EXP 164
102323: PUSH
102324: LD_EXP 164
102328: PUSH
102329: LD_VAR 0 2
102333: DIFF
102334: ST_TO_ADDR
102335: GO 102353
// hInvincible := hInvincible union i ;
102337: LD_ADDR_EXP 164
102341: PUSH
102342: LD_EXP 164
102346: PUSH
102347: LD_VAR 0 2
102351: UNION
102352: ST_TO_ADDR
// end ;
102353: GO 102293
102355: POP
102356: POP
// end ;
102357: LD_VAR 0 1
102361: RET
// export function hHackInvisible ; var i , j ; begin
102362: LD_INT 0
102364: PPUSH
102365: PPUSH
102366: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102367: LD_ADDR_VAR 0 2
102371: PUSH
102372: LD_INT 21
102374: PUSH
102375: LD_INT 1
102377: PUSH
102378: EMPTY
102379: LIST
102380: LIST
102381: PPUSH
102382: CALL_OW 69
102386: PUSH
102387: FOR_IN
102388: IFFALSE 102412
// if IsSelected ( i ) then
102390: LD_VAR 0 2
102394: PPUSH
102395: CALL_OW 306
102399: IFFALSE 102410
// ComForceInvisible ( i ) ;
102401: LD_VAR 0 2
102405: PPUSH
102406: CALL_OW 496
102410: GO 102387
102412: POP
102413: POP
// end ;
102414: LD_VAR 0 1
102418: RET
// export function hHackChangeYourSide ; begin
102419: LD_INT 0
102421: PPUSH
// if your_side = 8 then
102422: LD_OWVAR 2
102426: PUSH
102427: LD_INT 8
102429: EQUAL
102430: IFFALSE 102442
// your_side := 0 else
102432: LD_ADDR_OWVAR 2
102436: PUSH
102437: LD_INT 0
102439: ST_TO_ADDR
102440: GO 102456
// your_side := your_side + 1 ;
102442: LD_ADDR_OWVAR 2
102446: PUSH
102447: LD_OWVAR 2
102451: PUSH
102452: LD_INT 1
102454: PLUS
102455: ST_TO_ADDR
// end ;
102456: LD_VAR 0 1
102460: RET
// export function hHackChangeUnitSide ; var i , j ; begin
102461: LD_INT 0
102463: PPUSH
102464: PPUSH
102465: PPUSH
// for i in all_units do
102466: LD_ADDR_VAR 0 2
102470: PUSH
102471: LD_OWVAR 3
102475: PUSH
102476: FOR_IN
102477: IFFALSE 102555
// if IsSelected ( i ) then
102479: LD_VAR 0 2
102483: PPUSH
102484: CALL_OW 306
102488: IFFALSE 102553
// begin j := GetSide ( i ) ;
102490: LD_ADDR_VAR 0 3
102494: PUSH
102495: LD_VAR 0 2
102499: PPUSH
102500: CALL_OW 255
102504: ST_TO_ADDR
// if j = 8 then
102505: LD_VAR 0 3
102509: PUSH
102510: LD_INT 8
102512: EQUAL
102513: IFFALSE 102525
// j := 0 else
102515: LD_ADDR_VAR 0 3
102519: PUSH
102520: LD_INT 0
102522: ST_TO_ADDR
102523: GO 102539
// j := j + 1 ;
102525: LD_ADDR_VAR 0 3
102529: PUSH
102530: LD_VAR 0 3
102534: PUSH
102535: LD_INT 1
102537: PLUS
102538: ST_TO_ADDR
// SetSide ( i , j ) ;
102539: LD_VAR 0 2
102543: PPUSH
102544: LD_VAR 0 3
102548: PPUSH
102549: CALL_OW 235
// end ;
102553: GO 102476
102555: POP
102556: POP
// end ;
102557: LD_VAR 0 1
102561: RET
// export function hHackFog ; begin
102562: LD_INT 0
102564: PPUSH
// FogOff ( true ) ;
102565: LD_INT 1
102567: PPUSH
102568: CALL_OW 344
// end ;
102572: LD_VAR 0 1
102576: RET
// export function hHackTeleport ( unit , x , y ) ; begin
102577: LD_INT 0
102579: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
102580: LD_VAR 0 1
102584: PPUSH
102585: LD_VAR 0 2
102589: PPUSH
102590: LD_VAR 0 3
102594: PPUSH
102595: LD_INT 1
102597: PPUSH
102598: LD_INT 1
102600: PPUSH
102601: CALL_OW 483
// CenterOnXY ( x , y ) ;
102605: LD_VAR 0 2
102609: PPUSH
102610: LD_VAR 0 3
102614: PPUSH
102615: CALL_OW 84
// end ;
102619: LD_VAR 0 4
102623: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
102624: LD_INT 0
102626: PPUSH
102627: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
102628: LD_VAR 0 1
102632: NOT
102633: PUSH
102634: LD_VAR 0 2
102638: PPUSH
102639: LD_VAR 0 3
102643: PPUSH
102644: CALL_OW 488
102648: NOT
102649: OR
102650: PUSH
102651: LD_VAR 0 1
102655: PPUSH
102656: CALL_OW 266
102660: PUSH
102661: LD_INT 3
102663: NONEQUAL
102664: PUSH
102665: LD_VAR 0 1
102669: PPUSH
102670: CALL_OW 247
102674: PUSH
102675: LD_INT 1
102677: EQUAL
102678: NOT
102679: AND
102680: OR
102681: IFFALSE 102685
// exit ;
102683: GO 102834
// if GetType ( factory ) = unit_human then
102685: LD_VAR 0 1
102689: PPUSH
102690: CALL_OW 247
102694: PUSH
102695: LD_INT 1
102697: EQUAL
102698: IFFALSE 102715
// factory := IsInUnit ( factory ) ;
102700: LD_ADDR_VAR 0 1
102704: PUSH
102705: LD_VAR 0 1
102709: PPUSH
102710: CALL_OW 310
102714: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
102715: LD_VAR 0 1
102719: PPUSH
102720: CALL_OW 266
102724: PUSH
102725: LD_INT 3
102727: NONEQUAL
102728: IFFALSE 102732
// exit ;
102730: GO 102834
// if HexInfo ( x , y ) = factory then
102732: LD_VAR 0 2
102736: PPUSH
102737: LD_VAR 0 3
102741: PPUSH
102742: CALL_OW 428
102746: PUSH
102747: LD_VAR 0 1
102751: EQUAL
102752: IFFALSE 102779
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
102754: LD_ADDR_EXP 165
102758: PUSH
102759: LD_EXP 165
102763: PPUSH
102764: LD_VAR 0 1
102768: PPUSH
102769: LD_INT 0
102771: PPUSH
102772: CALL_OW 1
102776: ST_TO_ADDR
102777: GO 102830
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
102779: LD_ADDR_EXP 165
102783: PUSH
102784: LD_EXP 165
102788: PPUSH
102789: LD_VAR 0 1
102793: PPUSH
102794: LD_VAR 0 1
102798: PPUSH
102799: CALL_OW 255
102803: PUSH
102804: LD_VAR 0 1
102808: PUSH
102809: LD_VAR 0 2
102813: PUSH
102814: LD_VAR 0 3
102818: PUSH
102819: EMPTY
102820: LIST
102821: LIST
102822: LIST
102823: LIST
102824: PPUSH
102825: CALL_OW 1
102829: ST_TO_ADDR
// UpdateFactoryWaypoints ;
102830: CALL 102839 0 0
// end ;
102834: LD_VAR 0 4
102838: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
102839: LD_INT 0
102841: PPUSH
102842: PPUSH
102843: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
102844: LD_STRING resetFactoryWaypoint();
102846: PPUSH
102847: CALL_OW 559
// if factoryWaypoints then
102851: LD_EXP 165
102855: IFFALSE 102981
// begin list := PrepareArray ( factoryWaypoints ) ;
102857: LD_ADDR_VAR 0 3
102861: PUSH
102862: LD_EXP 165
102866: PPUSH
102867: CALL 56961 0 1
102871: ST_TO_ADDR
// for i := 1 to list do
102872: LD_ADDR_VAR 0 2
102876: PUSH
102877: DOUBLE
102878: LD_INT 1
102880: DEC
102881: ST_TO_ADDR
102882: LD_VAR 0 3
102886: PUSH
102887: FOR_TO
102888: IFFALSE 102979
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
102890: LD_STRING setFactoryWaypointXY(
102892: PUSH
102893: LD_VAR 0 3
102897: PUSH
102898: LD_VAR 0 2
102902: ARRAY
102903: PUSH
102904: LD_INT 1
102906: ARRAY
102907: STR
102908: PUSH
102909: LD_STRING ,
102911: STR
102912: PUSH
102913: LD_VAR 0 3
102917: PUSH
102918: LD_VAR 0 2
102922: ARRAY
102923: PUSH
102924: LD_INT 2
102926: ARRAY
102927: STR
102928: PUSH
102929: LD_STRING ,
102931: STR
102932: PUSH
102933: LD_VAR 0 3
102937: PUSH
102938: LD_VAR 0 2
102942: ARRAY
102943: PUSH
102944: LD_INT 3
102946: ARRAY
102947: STR
102948: PUSH
102949: LD_STRING ,
102951: STR
102952: PUSH
102953: LD_VAR 0 3
102957: PUSH
102958: LD_VAR 0 2
102962: ARRAY
102963: PUSH
102964: LD_INT 4
102966: ARRAY
102967: STR
102968: PUSH
102969: LD_STRING )
102971: STR
102972: PPUSH
102973: CALL_OW 559
102977: GO 102887
102979: POP
102980: POP
// end ; end ;
102981: LD_VAR 0 1
102985: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
102986: LD_INT 0
102988: PPUSH
// if HexInfo ( x , y ) = warehouse then
102989: LD_VAR 0 2
102993: PPUSH
102994: LD_VAR 0 3
102998: PPUSH
102999: CALL_OW 428
103003: PUSH
103004: LD_VAR 0 1
103008: EQUAL
103009: IFFALSE 103036
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
103011: LD_ADDR_EXP 166
103015: PUSH
103016: LD_EXP 166
103020: PPUSH
103021: LD_VAR 0 1
103025: PPUSH
103026: LD_INT 0
103028: PPUSH
103029: CALL_OW 1
103033: ST_TO_ADDR
103034: GO 103087
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
103036: LD_ADDR_EXP 166
103040: PUSH
103041: LD_EXP 166
103045: PPUSH
103046: LD_VAR 0 1
103050: PPUSH
103051: LD_VAR 0 1
103055: PPUSH
103056: CALL_OW 255
103060: PUSH
103061: LD_VAR 0 1
103065: PUSH
103066: LD_VAR 0 2
103070: PUSH
103071: LD_VAR 0 3
103075: PUSH
103076: EMPTY
103077: LIST
103078: LIST
103079: LIST
103080: LIST
103081: PPUSH
103082: CALL_OW 1
103086: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
103087: CALL 103096 0 0
// end ;
103091: LD_VAR 0 4
103095: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
103096: LD_INT 0
103098: PPUSH
103099: PPUSH
103100: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
103101: LD_STRING resetWarehouseGatheringPoints();
103103: PPUSH
103104: CALL_OW 559
// if warehouseGatheringPoints then
103108: LD_EXP 166
103112: IFFALSE 103238
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
103114: LD_ADDR_VAR 0 3
103118: PUSH
103119: LD_EXP 166
103123: PPUSH
103124: CALL 56961 0 1
103128: ST_TO_ADDR
// for i := 1 to list do
103129: LD_ADDR_VAR 0 2
103133: PUSH
103134: DOUBLE
103135: LD_INT 1
103137: DEC
103138: ST_TO_ADDR
103139: LD_VAR 0 3
103143: PUSH
103144: FOR_TO
103145: IFFALSE 103236
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
103147: LD_STRING setWarehouseGatheringPointXY(
103149: PUSH
103150: LD_VAR 0 3
103154: PUSH
103155: LD_VAR 0 2
103159: ARRAY
103160: PUSH
103161: LD_INT 1
103163: ARRAY
103164: STR
103165: PUSH
103166: LD_STRING ,
103168: STR
103169: PUSH
103170: LD_VAR 0 3
103174: PUSH
103175: LD_VAR 0 2
103179: ARRAY
103180: PUSH
103181: LD_INT 2
103183: ARRAY
103184: STR
103185: PUSH
103186: LD_STRING ,
103188: STR
103189: PUSH
103190: LD_VAR 0 3
103194: PUSH
103195: LD_VAR 0 2
103199: ARRAY
103200: PUSH
103201: LD_INT 3
103203: ARRAY
103204: STR
103205: PUSH
103206: LD_STRING ,
103208: STR
103209: PUSH
103210: LD_VAR 0 3
103214: PUSH
103215: LD_VAR 0 2
103219: ARRAY
103220: PUSH
103221: LD_INT 4
103223: ARRAY
103224: STR
103225: PUSH
103226: LD_STRING )
103228: STR
103229: PPUSH
103230: CALL_OW 559
103234: GO 103144
103236: POP
103237: POP
// end ; end ;
103238: LD_VAR 0 1
103242: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
103243: LD_EXP 166
103247: IFFALSE 103932
103249: GO 103251
103251: DISABLE
103252: LD_INT 0
103254: PPUSH
103255: PPUSH
103256: PPUSH
103257: PPUSH
103258: PPUSH
103259: PPUSH
103260: PPUSH
103261: PPUSH
103262: PPUSH
// begin enable ;
103263: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
103264: LD_ADDR_VAR 0 3
103268: PUSH
103269: LD_EXP 166
103273: PPUSH
103274: CALL 56961 0 1
103278: ST_TO_ADDR
// if not list then
103279: LD_VAR 0 3
103283: NOT
103284: IFFALSE 103288
// exit ;
103286: GO 103932
// for i := 1 to list do
103288: LD_ADDR_VAR 0 1
103292: PUSH
103293: DOUBLE
103294: LD_INT 1
103296: DEC
103297: ST_TO_ADDR
103298: LD_VAR 0 3
103302: PUSH
103303: FOR_TO
103304: IFFALSE 103930
// begin depot := list [ i ] [ 2 ] ;
103306: LD_ADDR_VAR 0 8
103310: PUSH
103311: LD_VAR 0 3
103315: PUSH
103316: LD_VAR 0 1
103320: ARRAY
103321: PUSH
103322: LD_INT 2
103324: ARRAY
103325: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
103326: LD_ADDR_VAR 0 5
103330: PUSH
103331: LD_VAR 0 3
103335: PUSH
103336: LD_VAR 0 1
103340: ARRAY
103341: PUSH
103342: LD_INT 1
103344: ARRAY
103345: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
103346: LD_VAR 0 8
103350: PPUSH
103351: CALL_OW 301
103355: PUSH
103356: LD_VAR 0 5
103360: PUSH
103361: LD_VAR 0 8
103365: PPUSH
103366: CALL_OW 255
103370: NONEQUAL
103371: OR
103372: IFFALSE 103401
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
103374: LD_ADDR_EXP 166
103378: PUSH
103379: LD_EXP 166
103383: PPUSH
103384: LD_VAR 0 8
103388: PPUSH
103389: LD_INT 0
103391: PPUSH
103392: CALL_OW 1
103396: ST_TO_ADDR
// exit ;
103397: POP
103398: POP
103399: GO 103932
// end ; x := list [ i ] [ 3 ] ;
103401: LD_ADDR_VAR 0 6
103405: PUSH
103406: LD_VAR 0 3
103410: PUSH
103411: LD_VAR 0 1
103415: ARRAY
103416: PUSH
103417: LD_INT 3
103419: ARRAY
103420: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
103421: LD_ADDR_VAR 0 7
103425: PUSH
103426: LD_VAR 0 3
103430: PUSH
103431: LD_VAR 0 1
103435: ARRAY
103436: PUSH
103437: LD_INT 4
103439: ARRAY
103440: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
103441: LD_ADDR_VAR 0 9
103445: PUSH
103446: LD_VAR 0 6
103450: PPUSH
103451: LD_VAR 0 7
103455: PPUSH
103456: LD_INT 16
103458: PPUSH
103459: CALL 55549 0 3
103463: ST_TO_ADDR
// if not cratesNearbyPoint then
103464: LD_VAR 0 9
103468: NOT
103469: IFFALSE 103475
// exit ;
103471: POP
103472: POP
103473: GO 103932
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
103475: LD_ADDR_VAR 0 4
103479: PUSH
103480: LD_INT 22
103482: PUSH
103483: LD_VAR 0 5
103487: PUSH
103488: EMPTY
103489: LIST
103490: LIST
103491: PUSH
103492: LD_INT 3
103494: PUSH
103495: LD_INT 60
103497: PUSH
103498: EMPTY
103499: LIST
103500: PUSH
103501: EMPTY
103502: LIST
103503: LIST
103504: PUSH
103505: LD_INT 91
103507: PUSH
103508: LD_VAR 0 8
103512: PUSH
103513: LD_INT 6
103515: PUSH
103516: EMPTY
103517: LIST
103518: LIST
103519: LIST
103520: PUSH
103521: LD_INT 2
103523: PUSH
103524: LD_INT 25
103526: PUSH
103527: LD_INT 2
103529: PUSH
103530: EMPTY
103531: LIST
103532: LIST
103533: PUSH
103534: LD_INT 25
103536: PUSH
103537: LD_INT 16
103539: PUSH
103540: EMPTY
103541: LIST
103542: LIST
103543: PUSH
103544: EMPTY
103545: LIST
103546: LIST
103547: LIST
103548: PUSH
103549: EMPTY
103550: LIST
103551: LIST
103552: LIST
103553: LIST
103554: PPUSH
103555: CALL_OW 69
103559: PUSH
103560: LD_VAR 0 8
103564: PPUSH
103565: CALL_OW 313
103569: PPUSH
103570: LD_INT 3
103572: PUSH
103573: LD_INT 60
103575: PUSH
103576: EMPTY
103577: LIST
103578: PUSH
103579: EMPTY
103580: LIST
103581: LIST
103582: PUSH
103583: LD_INT 2
103585: PUSH
103586: LD_INT 25
103588: PUSH
103589: LD_INT 2
103591: PUSH
103592: EMPTY
103593: LIST
103594: LIST
103595: PUSH
103596: LD_INT 25
103598: PUSH
103599: LD_INT 16
103601: PUSH
103602: EMPTY
103603: LIST
103604: LIST
103605: PUSH
103606: EMPTY
103607: LIST
103608: LIST
103609: LIST
103610: PUSH
103611: EMPTY
103612: LIST
103613: LIST
103614: PPUSH
103615: CALL_OW 72
103619: UNION
103620: ST_TO_ADDR
// if tmp then
103621: LD_VAR 0 4
103625: IFFALSE 103705
// begin tmp := ShrinkArray ( tmp , 3 ) ;
103627: LD_ADDR_VAR 0 4
103631: PUSH
103632: LD_VAR 0 4
103636: PPUSH
103637: LD_INT 3
103639: PPUSH
103640: CALL 53518 0 2
103644: ST_TO_ADDR
// for j in tmp do
103645: LD_ADDR_VAR 0 2
103649: PUSH
103650: LD_VAR 0 4
103654: PUSH
103655: FOR_IN
103656: IFFALSE 103699
// begin if IsInUnit ( j ) then
103658: LD_VAR 0 2
103662: PPUSH
103663: CALL_OW 310
103667: IFFALSE 103678
// ComExit ( j ) ;
103669: LD_VAR 0 2
103673: PPUSH
103674: CALL 53601 0 1
// AddComCollect ( j , x , y ) ;
103678: LD_VAR 0 2
103682: PPUSH
103683: LD_VAR 0 6
103687: PPUSH
103688: LD_VAR 0 7
103692: PPUSH
103693: CALL_OW 177
// end ;
103697: GO 103655
103699: POP
103700: POP
// exit ;
103701: POP
103702: POP
103703: GO 103932
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
103705: LD_ADDR_VAR 0 4
103709: PUSH
103710: LD_INT 22
103712: PUSH
103713: LD_VAR 0 5
103717: PUSH
103718: EMPTY
103719: LIST
103720: LIST
103721: PUSH
103722: LD_INT 91
103724: PUSH
103725: LD_VAR 0 8
103729: PUSH
103730: LD_INT 8
103732: PUSH
103733: EMPTY
103734: LIST
103735: LIST
103736: LIST
103737: PUSH
103738: LD_INT 2
103740: PUSH
103741: LD_INT 34
103743: PUSH
103744: LD_INT 12
103746: PUSH
103747: EMPTY
103748: LIST
103749: LIST
103750: PUSH
103751: LD_INT 34
103753: PUSH
103754: LD_INT 51
103756: PUSH
103757: EMPTY
103758: LIST
103759: LIST
103760: PUSH
103761: LD_INT 34
103763: PUSH
103764: LD_INT 32
103766: PUSH
103767: EMPTY
103768: LIST
103769: LIST
103770: PUSH
103771: LD_INT 34
103773: PUSH
103774: LD_INT 89
103776: PUSH
103777: EMPTY
103778: LIST
103779: LIST
103780: PUSH
103781: EMPTY
103782: LIST
103783: LIST
103784: LIST
103785: LIST
103786: LIST
103787: PUSH
103788: EMPTY
103789: LIST
103790: LIST
103791: LIST
103792: PPUSH
103793: CALL_OW 69
103797: ST_TO_ADDR
// if tmp then
103798: LD_VAR 0 4
103802: IFFALSE 103928
// begin for j in tmp do
103804: LD_ADDR_VAR 0 2
103808: PUSH
103809: LD_VAR 0 4
103813: PUSH
103814: FOR_IN
103815: IFFALSE 103926
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
103817: LD_VAR 0 2
103821: PPUSH
103822: CALL_OW 262
103826: PUSH
103827: LD_INT 3
103829: EQUAL
103830: PUSH
103831: LD_VAR 0 2
103835: PPUSH
103836: CALL_OW 261
103840: PUSH
103841: LD_INT 20
103843: GREATER
103844: OR
103845: PUSH
103846: LD_VAR 0 2
103850: PPUSH
103851: CALL_OW 314
103855: NOT
103856: AND
103857: PUSH
103858: LD_VAR 0 2
103862: PPUSH
103863: CALL_OW 263
103867: PUSH
103868: LD_INT 1
103870: NONEQUAL
103871: PUSH
103872: LD_VAR 0 2
103876: PPUSH
103877: CALL_OW 311
103881: OR
103882: AND
103883: IFFALSE 103924
// begin ComCollect ( j , x , y ) ;
103885: LD_VAR 0 2
103889: PPUSH
103890: LD_VAR 0 6
103894: PPUSH
103895: LD_VAR 0 7
103899: PPUSH
103900: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
103904: LD_VAR 0 2
103908: PPUSH
103909: LD_VAR 0 8
103913: PPUSH
103914: CALL_OW 172
// exit ;
103918: POP
103919: POP
103920: POP
103921: POP
103922: GO 103932
// end ;
103924: GO 103814
103926: POP
103927: POP
// end ; end ;
103928: GO 103303
103930: POP
103931: POP
// end ; end_of_file
103932: PPOPN 9
103934: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
103935: LD_INT 0
103937: PPUSH
103938: PPUSH
103939: PPUSH
103940: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
103941: LD_VAR 0 1
103945: PPUSH
103946: CALL_OW 264
103950: PUSH
103951: LD_INT 91
103953: EQUAL
103954: IFFALSE 104026
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
103956: LD_INT 68
103958: PPUSH
103959: LD_VAR 0 1
103963: PPUSH
103964: CALL_OW 255
103968: PPUSH
103969: CALL_OW 321
103973: PUSH
103974: LD_INT 2
103976: EQUAL
103977: IFFALSE 103989
// eff := 70 else
103979: LD_ADDR_VAR 0 4
103983: PUSH
103984: LD_INT 70
103986: ST_TO_ADDR
103987: GO 103997
// eff := 30 ;
103989: LD_ADDR_VAR 0 4
103993: PUSH
103994: LD_INT 30
103996: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
103997: LD_VAR 0 1
104001: PPUSH
104002: CALL_OW 250
104006: PPUSH
104007: LD_VAR 0 1
104011: PPUSH
104012: CALL_OW 251
104016: PPUSH
104017: LD_VAR 0 4
104021: PPUSH
104022: CALL_OW 495
// end ; end ;
104026: LD_VAR 0 2
104030: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
104031: LD_INT 0
104033: PPUSH
// end ;
104034: LD_VAR 0 4
104038: RET
// export function SOS_Command ( cmd ) ; begin
104039: LD_INT 0
104041: PPUSH
// end ;
104042: LD_VAR 0 2
104046: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
104047: LD_INT 0
104049: PPUSH
// end ;
104050: LD_VAR 0 6
104054: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
104055: LD_INT 0
104057: PPUSH
104058: PPUSH
// if not vehicle or not factory then
104059: LD_VAR 0 1
104063: NOT
104064: PUSH
104065: LD_VAR 0 2
104069: NOT
104070: OR
104071: IFFALSE 104075
// exit ;
104073: GO 104306
// if factoryWaypoints >= factory then
104075: LD_EXP 165
104079: PUSH
104080: LD_VAR 0 2
104084: GREATEREQUAL
104085: IFFALSE 104306
// if factoryWaypoints [ factory ] then
104087: LD_EXP 165
104091: PUSH
104092: LD_VAR 0 2
104096: ARRAY
104097: IFFALSE 104306
// begin if GetControl ( vehicle ) = control_manual then
104099: LD_VAR 0 1
104103: PPUSH
104104: CALL_OW 263
104108: PUSH
104109: LD_INT 1
104111: EQUAL
104112: IFFALSE 104193
// begin driver := IsDrivenBy ( vehicle ) ;
104114: LD_ADDR_VAR 0 4
104118: PUSH
104119: LD_VAR 0 1
104123: PPUSH
104124: CALL_OW 311
104128: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
104129: LD_VAR 0 4
104133: PPUSH
104134: LD_EXP 165
104138: PUSH
104139: LD_VAR 0 2
104143: ARRAY
104144: PUSH
104145: LD_INT 3
104147: ARRAY
104148: PPUSH
104149: LD_EXP 165
104153: PUSH
104154: LD_VAR 0 2
104158: ARRAY
104159: PUSH
104160: LD_INT 4
104162: ARRAY
104163: PPUSH
104164: CALL_OW 171
// AddComExitVehicle ( driver ) ;
104168: LD_VAR 0 4
104172: PPUSH
104173: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
104177: LD_VAR 0 4
104181: PPUSH
104182: LD_VAR 0 2
104186: PPUSH
104187: CALL_OW 180
// end else
104191: GO 104306
// if GetControl ( vehicle ) = control_remote then
104193: LD_VAR 0 1
104197: PPUSH
104198: CALL_OW 263
104202: PUSH
104203: LD_INT 2
104205: EQUAL
104206: IFFALSE 104267
// begin wait ( 0 0$2 ) ;
104208: LD_INT 70
104210: PPUSH
104211: CALL_OW 67
// if Connect ( vehicle ) then
104215: LD_VAR 0 1
104219: PPUSH
104220: CALL 23809 0 1
104224: IFFALSE 104265
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
104226: LD_VAR 0 1
104230: PPUSH
104231: LD_EXP 165
104235: PUSH
104236: LD_VAR 0 2
104240: ARRAY
104241: PUSH
104242: LD_INT 3
104244: ARRAY
104245: PPUSH
104246: LD_EXP 165
104250: PUSH
104251: LD_VAR 0 2
104255: ARRAY
104256: PUSH
104257: LD_INT 4
104259: ARRAY
104260: PPUSH
104261: CALL_OW 171
// end else
104265: GO 104306
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
104267: LD_VAR 0 1
104271: PPUSH
104272: LD_EXP 165
104276: PUSH
104277: LD_VAR 0 2
104281: ARRAY
104282: PUSH
104283: LD_INT 3
104285: ARRAY
104286: PPUSH
104287: LD_EXP 165
104291: PUSH
104292: LD_VAR 0 2
104296: ARRAY
104297: PUSH
104298: LD_INT 4
104300: ARRAY
104301: PPUSH
104302: CALL_OW 171
// end ; end ;
104306: LD_VAR 0 3
104310: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
104311: LD_INT 0
104313: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
104314: LD_VAR 0 1
104318: PUSH
104319: LD_INT 250
104321: EQUAL
104322: PUSH
104323: LD_VAR 0 2
104327: PPUSH
104328: CALL_OW 264
104332: PUSH
104333: LD_INT 81
104335: EQUAL
104336: AND
104337: IFFALSE 104358
// MinerPlaceMine ( unit , x , y ) ;
104339: LD_VAR 0 2
104343: PPUSH
104344: LD_VAR 0 4
104348: PPUSH
104349: LD_VAR 0 5
104353: PPUSH
104354: CALL 107182 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
104358: LD_VAR 0 1
104362: PUSH
104363: LD_INT 251
104365: EQUAL
104366: PUSH
104367: LD_VAR 0 2
104371: PPUSH
104372: CALL_OW 264
104376: PUSH
104377: LD_INT 81
104379: EQUAL
104380: AND
104381: IFFALSE 104402
// MinerDetonateMine ( unit , x , y ) ;
104383: LD_VAR 0 2
104387: PPUSH
104388: LD_VAR 0 4
104392: PPUSH
104393: LD_VAR 0 5
104397: PPUSH
104398: CALL 107457 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
104402: LD_VAR 0 1
104406: PUSH
104407: LD_INT 252
104409: EQUAL
104410: PUSH
104411: LD_VAR 0 2
104415: PPUSH
104416: CALL_OW 264
104420: PUSH
104421: LD_INT 81
104423: EQUAL
104424: AND
104425: IFFALSE 104446
// MinerCreateMinefield ( unit , x , y ) ;
104427: LD_VAR 0 2
104431: PPUSH
104432: LD_VAR 0 4
104436: PPUSH
104437: LD_VAR 0 5
104441: PPUSH
104442: CALL 107874 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
104446: LD_VAR 0 1
104450: PUSH
104451: LD_INT 253
104453: EQUAL
104454: PUSH
104455: LD_VAR 0 2
104459: PPUSH
104460: CALL_OW 257
104464: PUSH
104465: LD_INT 5
104467: EQUAL
104468: AND
104469: IFFALSE 104490
// ComBinocular ( unit , x , y ) ;
104471: LD_VAR 0 2
104475: PPUSH
104476: LD_VAR 0 4
104480: PPUSH
104481: LD_VAR 0 5
104485: PPUSH
104486: CALL 108243 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
104490: LD_VAR 0 1
104494: PUSH
104495: LD_INT 254
104497: EQUAL
104498: PUSH
104499: LD_VAR 0 2
104503: PPUSH
104504: CALL_OW 264
104508: PUSH
104509: LD_INT 99
104511: EQUAL
104512: AND
104513: PUSH
104514: LD_VAR 0 3
104518: PPUSH
104519: CALL_OW 263
104523: PUSH
104524: LD_INT 3
104526: EQUAL
104527: AND
104528: IFFALSE 104544
// HackDestroyVehicle ( unit , selectedUnit ) ;
104530: LD_VAR 0 2
104534: PPUSH
104535: LD_VAR 0 3
104539: PPUSH
104540: CALL 106546 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
104544: LD_VAR 0 1
104548: PUSH
104549: LD_INT 255
104551: EQUAL
104552: PUSH
104553: LD_VAR 0 2
104557: PPUSH
104558: CALL_OW 264
104562: PUSH
104563: LD_INT 14
104565: PUSH
104566: LD_INT 53
104568: PUSH
104569: EMPTY
104570: LIST
104571: LIST
104572: IN
104573: AND
104574: PUSH
104575: LD_VAR 0 4
104579: PPUSH
104580: LD_VAR 0 5
104584: PPUSH
104585: CALL_OW 488
104589: AND
104590: IFFALSE 104614
// CutTreeXYR ( unit , x , y , 12 ) ;
104592: LD_VAR 0 2
104596: PPUSH
104597: LD_VAR 0 4
104601: PPUSH
104602: LD_VAR 0 5
104606: PPUSH
104607: LD_INT 12
104609: PPUSH
104610: CALL 104709 0 4
// if cmd = 256 then
104614: LD_VAR 0 1
104618: PUSH
104619: LD_INT 256
104621: EQUAL
104622: IFFALSE 104643
// SetFactoryWaypoint ( unit , x , y ) ;
104624: LD_VAR 0 2
104628: PPUSH
104629: LD_VAR 0 4
104633: PPUSH
104634: LD_VAR 0 5
104638: PPUSH
104639: CALL 102624 0 3
// if cmd = 257 then
104643: LD_VAR 0 1
104647: PUSH
104648: LD_INT 257
104650: EQUAL
104651: IFFALSE 104672
// SetWarehouseGatheringPoint ( unit , x , y ) ;
104653: LD_VAR 0 2
104657: PPUSH
104658: LD_VAR 0 4
104662: PPUSH
104663: LD_VAR 0 5
104667: PPUSH
104668: CALL 102986 0 3
// if cmd = 258 then
104672: LD_VAR 0 1
104676: PUSH
104677: LD_INT 258
104679: EQUAL
104680: IFFALSE 104704
// BurnTreeXYR ( unit , x , y , 8 ) ;
104682: LD_VAR 0 2
104686: PPUSH
104687: LD_VAR 0 4
104691: PPUSH
104692: LD_VAR 0 5
104696: PPUSH
104697: LD_INT 8
104699: PPUSH
104700: CALL 105103 0 4
// end ;
104704: LD_VAR 0 6
104708: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
104709: LD_INT 0
104711: PPUSH
104712: PPUSH
104713: PPUSH
104714: PPUSH
104715: PPUSH
104716: PPUSH
104717: PPUSH
104718: PPUSH
104719: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
104720: LD_VAR 0 1
104724: PPUSH
104725: CALL_OW 302
104729: NOT
104730: PUSH
104731: LD_VAR 0 2
104735: PPUSH
104736: LD_VAR 0 3
104740: PPUSH
104741: CALL_OW 488
104745: NOT
104746: OR
104747: PUSH
104748: LD_VAR 0 4
104752: NOT
104753: OR
104754: IFFALSE 104758
// exit ;
104756: GO 105098
// list := [ ] ;
104758: LD_ADDR_VAR 0 13
104762: PUSH
104763: EMPTY
104764: ST_TO_ADDR
// if x - r < 0 then
104765: LD_VAR 0 2
104769: PUSH
104770: LD_VAR 0 4
104774: MINUS
104775: PUSH
104776: LD_INT 0
104778: LESS
104779: IFFALSE 104791
// min_x := 0 else
104781: LD_ADDR_VAR 0 7
104785: PUSH
104786: LD_INT 0
104788: ST_TO_ADDR
104789: GO 104807
// min_x := x - r ;
104791: LD_ADDR_VAR 0 7
104795: PUSH
104796: LD_VAR 0 2
104800: PUSH
104801: LD_VAR 0 4
104805: MINUS
104806: ST_TO_ADDR
// if y - r < 0 then
104807: LD_VAR 0 3
104811: PUSH
104812: LD_VAR 0 4
104816: MINUS
104817: PUSH
104818: LD_INT 0
104820: LESS
104821: IFFALSE 104833
// min_y := 0 else
104823: LD_ADDR_VAR 0 8
104827: PUSH
104828: LD_INT 0
104830: ST_TO_ADDR
104831: GO 104849
// min_y := y - r ;
104833: LD_ADDR_VAR 0 8
104837: PUSH
104838: LD_VAR 0 3
104842: PUSH
104843: LD_VAR 0 4
104847: MINUS
104848: ST_TO_ADDR
// max_x := x + r ;
104849: LD_ADDR_VAR 0 9
104853: PUSH
104854: LD_VAR 0 2
104858: PUSH
104859: LD_VAR 0 4
104863: PLUS
104864: ST_TO_ADDR
// max_y := y + r ;
104865: LD_ADDR_VAR 0 10
104869: PUSH
104870: LD_VAR 0 3
104874: PUSH
104875: LD_VAR 0 4
104879: PLUS
104880: ST_TO_ADDR
// for _x = min_x to max_x do
104881: LD_ADDR_VAR 0 11
104885: PUSH
104886: DOUBLE
104887: LD_VAR 0 7
104891: DEC
104892: ST_TO_ADDR
104893: LD_VAR 0 9
104897: PUSH
104898: FOR_TO
104899: IFFALSE 105016
// for _y = min_y to max_y do
104901: LD_ADDR_VAR 0 12
104905: PUSH
104906: DOUBLE
104907: LD_VAR 0 8
104911: DEC
104912: ST_TO_ADDR
104913: LD_VAR 0 10
104917: PUSH
104918: FOR_TO
104919: IFFALSE 105012
// begin if not ValidHex ( _x , _y ) then
104921: LD_VAR 0 11
104925: PPUSH
104926: LD_VAR 0 12
104930: PPUSH
104931: CALL_OW 488
104935: NOT
104936: IFFALSE 104940
// continue ;
104938: GO 104918
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
104940: LD_VAR 0 11
104944: PPUSH
104945: LD_VAR 0 12
104949: PPUSH
104950: CALL_OW 351
104954: PUSH
104955: LD_VAR 0 11
104959: PPUSH
104960: LD_VAR 0 12
104964: PPUSH
104965: CALL_OW 554
104969: AND
104970: IFFALSE 105010
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
104972: LD_ADDR_VAR 0 13
104976: PUSH
104977: LD_VAR 0 13
104981: PPUSH
104982: LD_VAR 0 13
104986: PUSH
104987: LD_INT 1
104989: PLUS
104990: PPUSH
104991: LD_VAR 0 11
104995: PUSH
104996: LD_VAR 0 12
105000: PUSH
105001: EMPTY
105002: LIST
105003: LIST
105004: PPUSH
105005: CALL_OW 2
105009: ST_TO_ADDR
// end ;
105010: GO 104918
105012: POP
105013: POP
105014: GO 104898
105016: POP
105017: POP
// if not list then
105018: LD_VAR 0 13
105022: NOT
105023: IFFALSE 105027
// exit ;
105025: GO 105098
// for i in list do
105027: LD_ADDR_VAR 0 6
105031: PUSH
105032: LD_VAR 0 13
105036: PUSH
105037: FOR_IN
105038: IFFALSE 105096
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
105040: LD_VAR 0 1
105044: PPUSH
105045: LD_STRING M
105047: PUSH
105048: LD_VAR 0 6
105052: PUSH
105053: LD_INT 1
105055: ARRAY
105056: PUSH
105057: LD_VAR 0 6
105061: PUSH
105062: LD_INT 2
105064: ARRAY
105065: PUSH
105066: LD_INT 0
105068: PUSH
105069: LD_INT 0
105071: PUSH
105072: LD_INT 0
105074: PUSH
105075: LD_INT 0
105077: PUSH
105078: EMPTY
105079: LIST
105080: LIST
105081: LIST
105082: LIST
105083: LIST
105084: LIST
105085: LIST
105086: PUSH
105087: EMPTY
105088: LIST
105089: PPUSH
105090: CALL_OW 447
105094: GO 105037
105096: POP
105097: POP
// end ;
105098: LD_VAR 0 5
105102: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
105103: LD_INT 0
105105: PPUSH
105106: PPUSH
105107: PPUSH
105108: PPUSH
105109: PPUSH
105110: PPUSH
105111: PPUSH
105112: PPUSH
105113: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
105114: LD_VAR 0 1
105118: PPUSH
105119: CALL_OW 302
105123: NOT
105124: PUSH
105125: LD_VAR 0 2
105129: PPUSH
105130: LD_VAR 0 3
105134: PPUSH
105135: CALL_OW 488
105139: NOT
105140: OR
105141: PUSH
105142: LD_VAR 0 4
105146: NOT
105147: OR
105148: IFFALSE 105152
// exit ;
105150: GO 105500
// list := [ ] ;
105152: LD_ADDR_VAR 0 13
105156: PUSH
105157: EMPTY
105158: ST_TO_ADDR
// if x - r < 0 then
105159: LD_VAR 0 2
105163: PUSH
105164: LD_VAR 0 4
105168: MINUS
105169: PUSH
105170: LD_INT 0
105172: LESS
105173: IFFALSE 105185
// min_x := 0 else
105175: LD_ADDR_VAR 0 7
105179: PUSH
105180: LD_INT 0
105182: ST_TO_ADDR
105183: GO 105201
// min_x := x - r ;
105185: LD_ADDR_VAR 0 7
105189: PUSH
105190: LD_VAR 0 2
105194: PUSH
105195: LD_VAR 0 4
105199: MINUS
105200: ST_TO_ADDR
// if y - r < 0 then
105201: LD_VAR 0 3
105205: PUSH
105206: LD_VAR 0 4
105210: MINUS
105211: PUSH
105212: LD_INT 0
105214: LESS
105215: IFFALSE 105227
// min_y := 0 else
105217: LD_ADDR_VAR 0 8
105221: PUSH
105222: LD_INT 0
105224: ST_TO_ADDR
105225: GO 105243
// min_y := y - r ;
105227: LD_ADDR_VAR 0 8
105231: PUSH
105232: LD_VAR 0 3
105236: PUSH
105237: LD_VAR 0 4
105241: MINUS
105242: ST_TO_ADDR
// max_x := x + r ;
105243: LD_ADDR_VAR 0 9
105247: PUSH
105248: LD_VAR 0 2
105252: PUSH
105253: LD_VAR 0 4
105257: PLUS
105258: ST_TO_ADDR
// max_y := y + r ;
105259: LD_ADDR_VAR 0 10
105263: PUSH
105264: LD_VAR 0 3
105268: PUSH
105269: LD_VAR 0 4
105273: PLUS
105274: ST_TO_ADDR
// for _x = min_x to max_x do
105275: LD_ADDR_VAR 0 11
105279: PUSH
105280: DOUBLE
105281: LD_VAR 0 7
105285: DEC
105286: ST_TO_ADDR
105287: LD_VAR 0 9
105291: PUSH
105292: FOR_TO
105293: IFFALSE 105410
// for _y = min_y to max_y do
105295: LD_ADDR_VAR 0 12
105299: PUSH
105300: DOUBLE
105301: LD_VAR 0 8
105305: DEC
105306: ST_TO_ADDR
105307: LD_VAR 0 10
105311: PUSH
105312: FOR_TO
105313: IFFALSE 105406
// begin if not ValidHex ( _x , _y ) then
105315: LD_VAR 0 11
105319: PPUSH
105320: LD_VAR 0 12
105324: PPUSH
105325: CALL_OW 488
105329: NOT
105330: IFFALSE 105334
// continue ;
105332: GO 105312
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
105334: LD_VAR 0 11
105338: PPUSH
105339: LD_VAR 0 12
105343: PPUSH
105344: CALL_OW 351
105348: PUSH
105349: LD_VAR 0 11
105353: PPUSH
105354: LD_VAR 0 12
105358: PPUSH
105359: CALL_OW 554
105363: AND
105364: IFFALSE 105404
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
105366: LD_ADDR_VAR 0 13
105370: PUSH
105371: LD_VAR 0 13
105375: PPUSH
105376: LD_VAR 0 13
105380: PUSH
105381: LD_INT 1
105383: PLUS
105384: PPUSH
105385: LD_VAR 0 11
105389: PUSH
105390: LD_VAR 0 12
105394: PUSH
105395: EMPTY
105396: LIST
105397: LIST
105398: PPUSH
105399: CALL_OW 2
105403: ST_TO_ADDR
// end ;
105404: GO 105312
105406: POP
105407: POP
105408: GO 105292
105410: POP
105411: POP
// if not list then
105412: LD_VAR 0 13
105416: NOT
105417: IFFALSE 105421
// exit ;
105419: GO 105500
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
105421: LD_ADDR_VAR 0 13
105425: PUSH
105426: LD_VAR 0 1
105430: PPUSH
105431: LD_VAR 0 13
105435: PPUSH
105436: LD_INT 1
105438: PPUSH
105439: LD_INT 1
105441: PPUSH
105442: CALL 20951 0 4
105446: ST_TO_ADDR
// ComStop ( flame ) ;
105447: LD_VAR 0 1
105451: PPUSH
105452: CALL_OW 141
// for i in list do
105456: LD_ADDR_VAR 0 6
105460: PUSH
105461: LD_VAR 0 13
105465: PUSH
105466: FOR_IN
105467: IFFALSE 105498
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
105469: LD_VAR 0 1
105473: PPUSH
105474: LD_VAR 0 6
105478: PUSH
105479: LD_INT 1
105481: ARRAY
105482: PPUSH
105483: LD_VAR 0 6
105487: PUSH
105488: LD_INT 2
105490: ARRAY
105491: PPUSH
105492: CALL_OW 176
105496: GO 105466
105498: POP
105499: POP
// end ;
105500: LD_VAR 0 5
105504: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
105505: LD_EXP 168
105509: NOT
105510: IFFALSE 105560
105512: GO 105514
105514: DISABLE
// begin initHack := true ;
105515: LD_ADDR_EXP 168
105519: PUSH
105520: LD_INT 1
105522: ST_TO_ADDR
// hackTanks := [ ] ;
105523: LD_ADDR_EXP 169
105527: PUSH
105528: EMPTY
105529: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
105530: LD_ADDR_EXP 170
105534: PUSH
105535: EMPTY
105536: ST_TO_ADDR
// hackLimit := 3 ;
105537: LD_ADDR_EXP 171
105541: PUSH
105542: LD_INT 3
105544: ST_TO_ADDR
// hackDist := 12 ;
105545: LD_ADDR_EXP 172
105549: PUSH
105550: LD_INT 12
105552: ST_TO_ADDR
// hackCounter := [ ] ;
105553: LD_ADDR_EXP 173
105557: PUSH
105558: EMPTY
105559: ST_TO_ADDR
// end ;
105560: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
105561: LD_EXP 168
105565: PUSH
105566: LD_INT 34
105568: PUSH
105569: LD_INT 99
105571: PUSH
105572: EMPTY
105573: LIST
105574: LIST
105575: PPUSH
105576: CALL_OW 69
105580: AND
105581: IFFALSE 105834
105583: GO 105585
105585: DISABLE
105586: LD_INT 0
105588: PPUSH
105589: PPUSH
// begin enable ;
105590: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
105591: LD_ADDR_VAR 0 1
105595: PUSH
105596: LD_INT 34
105598: PUSH
105599: LD_INT 99
105601: PUSH
105602: EMPTY
105603: LIST
105604: LIST
105605: PPUSH
105606: CALL_OW 69
105610: PUSH
105611: FOR_IN
105612: IFFALSE 105832
// begin if not i in hackTanks then
105614: LD_VAR 0 1
105618: PUSH
105619: LD_EXP 169
105623: IN
105624: NOT
105625: IFFALSE 105708
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
105627: LD_ADDR_EXP 169
105631: PUSH
105632: LD_EXP 169
105636: PPUSH
105637: LD_EXP 169
105641: PUSH
105642: LD_INT 1
105644: PLUS
105645: PPUSH
105646: LD_VAR 0 1
105650: PPUSH
105651: CALL_OW 1
105655: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
105656: LD_ADDR_EXP 170
105660: PUSH
105661: LD_EXP 170
105665: PPUSH
105666: LD_EXP 170
105670: PUSH
105671: LD_INT 1
105673: PLUS
105674: PPUSH
105675: EMPTY
105676: PPUSH
105677: CALL_OW 1
105681: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
105682: LD_ADDR_EXP 173
105686: PUSH
105687: LD_EXP 173
105691: PPUSH
105692: LD_EXP 173
105696: PUSH
105697: LD_INT 1
105699: PLUS
105700: PPUSH
105701: EMPTY
105702: PPUSH
105703: CALL_OW 1
105707: ST_TO_ADDR
// end ; if not IsOk ( i ) then
105708: LD_VAR 0 1
105712: PPUSH
105713: CALL_OW 302
105717: NOT
105718: IFFALSE 105731
// begin HackUnlinkAll ( i ) ;
105720: LD_VAR 0 1
105724: PPUSH
105725: CALL 105837 0 1
// continue ;
105729: GO 105611
// end ; HackCheckCapturedStatus ( i ) ;
105731: LD_VAR 0 1
105735: PPUSH
105736: CALL 106280 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
105740: LD_ADDR_VAR 0 2
105744: PUSH
105745: LD_INT 81
105747: PUSH
105748: LD_VAR 0 1
105752: PPUSH
105753: CALL_OW 255
105757: PUSH
105758: EMPTY
105759: LIST
105760: LIST
105761: PUSH
105762: LD_INT 33
105764: PUSH
105765: LD_INT 3
105767: PUSH
105768: EMPTY
105769: LIST
105770: LIST
105771: PUSH
105772: LD_INT 91
105774: PUSH
105775: LD_VAR 0 1
105779: PUSH
105780: LD_EXP 172
105784: PUSH
105785: EMPTY
105786: LIST
105787: LIST
105788: LIST
105789: PUSH
105790: LD_INT 50
105792: PUSH
105793: EMPTY
105794: LIST
105795: PUSH
105796: EMPTY
105797: LIST
105798: LIST
105799: LIST
105800: LIST
105801: PPUSH
105802: CALL_OW 69
105806: ST_TO_ADDR
// if not tmp then
105807: LD_VAR 0 2
105811: NOT
105812: IFFALSE 105816
// continue ;
105814: GO 105611
// HackLink ( i , tmp ) ;
105816: LD_VAR 0 1
105820: PPUSH
105821: LD_VAR 0 2
105825: PPUSH
105826: CALL 105973 0 2
// end ;
105830: GO 105611
105832: POP
105833: POP
// end ;
105834: PPOPN 2
105836: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
105837: LD_INT 0
105839: PPUSH
105840: PPUSH
105841: PPUSH
// if not hack in hackTanks then
105842: LD_VAR 0 1
105846: PUSH
105847: LD_EXP 169
105851: IN
105852: NOT
105853: IFFALSE 105857
// exit ;
105855: GO 105968
// index := GetElementIndex ( hackTanks , hack ) ;
105857: LD_ADDR_VAR 0 4
105861: PUSH
105862: LD_EXP 169
105866: PPUSH
105867: LD_VAR 0 1
105871: PPUSH
105872: CALL 20248 0 2
105876: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
105877: LD_EXP 170
105881: PUSH
105882: LD_VAR 0 4
105886: ARRAY
105887: IFFALSE 105968
// begin for i in hackTanksCaptured [ index ] do
105889: LD_ADDR_VAR 0 3
105893: PUSH
105894: LD_EXP 170
105898: PUSH
105899: LD_VAR 0 4
105903: ARRAY
105904: PUSH
105905: FOR_IN
105906: IFFALSE 105932
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
105908: LD_VAR 0 3
105912: PUSH
105913: LD_INT 1
105915: ARRAY
105916: PPUSH
105917: LD_VAR 0 3
105921: PUSH
105922: LD_INT 2
105924: ARRAY
105925: PPUSH
105926: CALL_OW 235
105930: GO 105905
105932: POP
105933: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
105934: LD_ADDR_EXP 170
105938: PUSH
105939: LD_EXP 170
105943: PPUSH
105944: LD_VAR 0 4
105948: PPUSH
105949: EMPTY
105950: PPUSH
105951: CALL_OW 1
105955: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
105956: LD_VAR 0 1
105960: PPUSH
105961: LD_INT 0
105963: PPUSH
105964: CALL_OW 505
// end ; end ;
105968: LD_VAR 0 2
105972: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
105973: LD_INT 0
105975: PPUSH
105976: PPUSH
105977: PPUSH
// if not hack in hackTanks or not vehicles then
105978: LD_VAR 0 1
105982: PUSH
105983: LD_EXP 169
105987: IN
105988: NOT
105989: PUSH
105990: LD_VAR 0 2
105994: NOT
105995: OR
105996: IFFALSE 106000
// exit ;
105998: GO 106275
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
106000: LD_ADDR_VAR 0 2
106004: PUSH
106005: LD_VAR 0 1
106009: PPUSH
106010: LD_VAR 0 2
106014: PPUSH
106015: LD_INT 1
106017: PPUSH
106018: LD_INT 1
106020: PPUSH
106021: CALL 20898 0 4
106025: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
106026: LD_ADDR_VAR 0 5
106030: PUSH
106031: LD_EXP 169
106035: PPUSH
106036: LD_VAR 0 1
106040: PPUSH
106041: CALL 20248 0 2
106045: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
106046: LD_EXP 170
106050: PUSH
106051: LD_VAR 0 5
106055: ARRAY
106056: PUSH
106057: LD_EXP 171
106061: LESS
106062: IFFALSE 106251
// begin for i := 1 to vehicles do
106064: LD_ADDR_VAR 0 4
106068: PUSH
106069: DOUBLE
106070: LD_INT 1
106072: DEC
106073: ST_TO_ADDR
106074: LD_VAR 0 2
106078: PUSH
106079: FOR_TO
106080: IFFALSE 106249
// begin if hackTanksCaptured [ index ] = hackLimit then
106082: LD_EXP 170
106086: PUSH
106087: LD_VAR 0 5
106091: ARRAY
106092: PUSH
106093: LD_EXP 171
106097: EQUAL
106098: IFFALSE 106102
// break ;
106100: GO 106249
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
106102: LD_ADDR_EXP 173
106106: PUSH
106107: LD_EXP 173
106111: PPUSH
106112: LD_VAR 0 5
106116: PPUSH
106117: LD_EXP 173
106121: PUSH
106122: LD_VAR 0 5
106126: ARRAY
106127: PUSH
106128: LD_INT 1
106130: PLUS
106131: PPUSH
106132: CALL_OW 1
106136: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
106137: LD_ADDR_EXP 170
106141: PUSH
106142: LD_EXP 170
106146: PPUSH
106147: LD_VAR 0 5
106151: PUSH
106152: LD_EXP 170
106156: PUSH
106157: LD_VAR 0 5
106161: ARRAY
106162: PUSH
106163: LD_INT 1
106165: PLUS
106166: PUSH
106167: EMPTY
106168: LIST
106169: LIST
106170: PPUSH
106171: LD_VAR 0 2
106175: PUSH
106176: LD_VAR 0 4
106180: ARRAY
106181: PUSH
106182: LD_VAR 0 2
106186: PUSH
106187: LD_VAR 0 4
106191: ARRAY
106192: PPUSH
106193: CALL_OW 255
106197: PUSH
106198: EMPTY
106199: LIST
106200: LIST
106201: PPUSH
106202: CALL 20463 0 3
106206: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
106207: LD_VAR 0 2
106211: PUSH
106212: LD_VAR 0 4
106216: ARRAY
106217: PPUSH
106218: LD_VAR 0 1
106222: PPUSH
106223: CALL_OW 255
106227: PPUSH
106228: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
106232: LD_VAR 0 2
106236: PUSH
106237: LD_VAR 0 4
106241: ARRAY
106242: PPUSH
106243: CALL_OW 141
// end ;
106247: GO 106079
106249: POP
106250: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
106251: LD_VAR 0 1
106255: PPUSH
106256: LD_EXP 170
106260: PUSH
106261: LD_VAR 0 5
106265: ARRAY
106266: PUSH
106267: LD_INT 0
106269: PLUS
106270: PPUSH
106271: CALL_OW 505
// end ;
106275: LD_VAR 0 3
106279: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
106280: LD_INT 0
106282: PPUSH
106283: PPUSH
106284: PPUSH
106285: PPUSH
// if not hack in hackTanks then
106286: LD_VAR 0 1
106290: PUSH
106291: LD_EXP 169
106295: IN
106296: NOT
106297: IFFALSE 106301
// exit ;
106299: GO 106541
// index := GetElementIndex ( hackTanks , hack ) ;
106301: LD_ADDR_VAR 0 4
106305: PUSH
106306: LD_EXP 169
106310: PPUSH
106311: LD_VAR 0 1
106315: PPUSH
106316: CALL 20248 0 2
106320: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
106321: LD_ADDR_VAR 0 3
106325: PUSH
106326: DOUBLE
106327: LD_EXP 170
106331: PUSH
106332: LD_VAR 0 4
106336: ARRAY
106337: INC
106338: ST_TO_ADDR
106339: LD_INT 1
106341: PUSH
106342: FOR_DOWNTO
106343: IFFALSE 106515
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
106345: LD_ADDR_VAR 0 5
106349: PUSH
106350: LD_EXP 170
106354: PUSH
106355: LD_VAR 0 4
106359: ARRAY
106360: PUSH
106361: LD_VAR 0 3
106365: ARRAY
106366: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
106367: LD_VAR 0 5
106371: PUSH
106372: LD_INT 1
106374: ARRAY
106375: PPUSH
106376: CALL_OW 302
106380: NOT
106381: PUSH
106382: LD_VAR 0 5
106386: PUSH
106387: LD_INT 1
106389: ARRAY
106390: PPUSH
106391: CALL_OW 255
106395: PUSH
106396: LD_VAR 0 1
106400: PPUSH
106401: CALL_OW 255
106405: NONEQUAL
106406: OR
106407: IFFALSE 106513
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
106409: LD_VAR 0 5
106413: PUSH
106414: LD_INT 1
106416: ARRAY
106417: PPUSH
106418: CALL_OW 305
106422: PUSH
106423: LD_VAR 0 5
106427: PUSH
106428: LD_INT 1
106430: ARRAY
106431: PPUSH
106432: CALL_OW 255
106436: PUSH
106437: LD_VAR 0 1
106441: PPUSH
106442: CALL_OW 255
106446: EQUAL
106447: AND
106448: IFFALSE 106472
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
106450: LD_VAR 0 5
106454: PUSH
106455: LD_INT 1
106457: ARRAY
106458: PPUSH
106459: LD_VAR 0 5
106463: PUSH
106464: LD_INT 2
106466: ARRAY
106467: PPUSH
106468: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
106472: LD_ADDR_EXP 170
106476: PUSH
106477: LD_EXP 170
106481: PPUSH
106482: LD_VAR 0 4
106486: PPUSH
106487: LD_EXP 170
106491: PUSH
106492: LD_VAR 0 4
106496: ARRAY
106497: PPUSH
106498: LD_VAR 0 3
106502: PPUSH
106503: CALL_OW 3
106507: PPUSH
106508: CALL_OW 1
106512: ST_TO_ADDR
// end ; end ;
106513: GO 106342
106515: POP
106516: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
106517: LD_VAR 0 1
106521: PPUSH
106522: LD_EXP 170
106526: PUSH
106527: LD_VAR 0 4
106531: ARRAY
106532: PUSH
106533: LD_INT 0
106535: PLUS
106536: PPUSH
106537: CALL_OW 505
// end ;
106541: LD_VAR 0 2
106545: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
106546: LD_INT 0
106548: PPUSH
106549: PPUSH
106550: PPUSH
106551: PPUSH
// if not hack in hackTanks then
106552: LD_VAR 0 1
106556: PUSH
106557: LD_EXP 169
106561: IN
106562: NOT
106563: IFFALSE 106567
// exit ;
106565: GO 106652
// index := GetElementIndex ( hackTanks , hack ) ;
106567: LD_ADDR_VAR 0 5
106571: PUSH
106572: LD_EXP 169
106576: PPUSH
106577: LD_VAR 0 1
106581: PPUSH
106582: CALL 20248 0 2
106586: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
106587: LD_ADDR_VAR 0 4
106591: PUSH
106592: DOUBLE
106593: LD_INT 1
106595: DEC
106596: ST_TO_ADDR
106597: LD_EXP 170
106601: PUSH
106602: LD_VAR 0 5
106606: ARRAY
106607: PUSH
106608: FOR_TO
106609: IFFALSE 106650
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
106611: LD_EXP 170
106615: PUSH
106616: LD_VAR 0 5
106620: ARRAY
106621: PUSH
106622: LD_VAR 0 4
106626: ARRAY
106627: PUSH
106628: LD_INT 1
106630: ARRAY
106631: PUSH
106632: LD_VAR 0 2
106636: EQUAL
106637: IFFALSE 106648
// KillUnit ( vehicle ) ;
106639: LD_VAR 0 2
106643: PPUSH
106644: CALL_OW 66
106648: GO 106608
106650: POP
106651: POP
// end ;
106652: LD_VAR 0 3
106656: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
106657: LD_EXP 174
106661: NOT
106662: IFFALSE 106697
106664: GO 106666
106666: DISABLE
// begin initMiner := true ;
106667: LD_ADDR_EXP 174
106671: PUSH
106672: LD_INT 1
106674: ST_TO_ADDR
// minersList := [ ] ;
106675: LD_ADDR_EXP 175
106679: PUSH
106680: EMPTY
106681: ST_TO_ADDR
// minerMinesList := [ ] ;
106682: LD_ADDR_EXP 176
106686: PUSH
106687: EMPTY
106688: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
106689: LD_ADDR_EXP 177
106693: PUSH
106694: LD_INT 5
106696: ST_TO_ADDR
// end ;
106697: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
106698: LD_EXP 174
106702: PUSH
106703: LD_INT 34
106705: PUSH
106706: LD_INT 81
106708: PUSH
106709: EMPTY
106710: LIST
106711: LIST
106712: PPUSH
106713: CALL_OW 69
106717: AND
106718: IFFALSE 107179
106720: GO 106722
106722: DISABLE
106723: LD_INT 0
106725: PPUSH
106726: PPUSH
106727: PPUSH
106728: PPUSH
// begin enable ;
106729: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
106730: LD_ADDR_VAR 0 1
106734: PUSH
106735: LD_INT 34
106737: PUSH
106738: LD_INT 81
106740: PUSH
106741: EMPTY
106742: LIST
106743: LIST
106744: PPUSH
106745: CALL_OW 69
106749: PUSH
106750: FOR_IN
106751: IFFALSE 106823
// begin if not i in minersList then
106753: LD_VAR 0 1
106757: PUSH
106758: LD_EXP 175
106762: IN
106763: NOT
106764: IFFALSE 106821
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
106766: LD_ADDR_EXP 175
106770: PUSH
106771: LD_EXP 175
106775: PPUSH
106776: LD_EXP 175
106780: PUSH
106781: LD_INT 1
106783: PLUS
106784: PPUSH
106785: LD_VAR 0 1
106789: PPUSH
106790: CALL_OW 1
106794: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
106795: LD_ADDR_EXP 176
106799: PUSH
106800: LD_EXP 176
106804: PPUSH
106805: LD_EXP 176
106809: PUSH
106810: LD_INT 1
106812: PLUS
106813: PPUSH
106814: EMPTY
106815: PPUSH
106816: CALL_OW 1
106820: ST_TO_ADDR
// end end ;
106821: GO 106750
106823: POP
106824: POP
// for i := minerMinesList downto 1 do
106825: LD_ADDR_VAR 0 1
106829: PUSH
106830: DOUBLE
106831: LD_EXP 176
106835: INC
106836: ST_TO_ADDR
106837: LD_INT 1
106839: PUSH
106840: FOR_DOWNTO
106841: IFFALSE 107177
// begin if IsLive ( minersList [ i ] ) then
106843: LD_EXP 175
106847: PUSH
106848: LD_VAR 0 1
106852: ARRAY
106853: PPUSH
106854: CALL_OW 300
106858: IFFALSE 106886
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
106860: LD_EXP 175
106864: PUSH
106865: LD_VAR 0 1
106869: ARRAY
106870: PPUSH
106871: LD_EXP 176
106875: PUSH
106876: LD_VAR 0 1
106880: ARRAY
106881: PPUSH
106882: CALL_OW 505
// if not minerMinesList [ i ] then
106886: LD_EXP 176
106890: PUSH
106891: LD_VAR 0 1
106895: ARRAY
106896: NOT
106897: IFFALSE 106901
// continue ;
106899: GO 106840
// for j := minerMinesList [ i ] downto 1 do
106901: LD_ADDR_VAR 0 2
106905: PUSH
106906: DOUBLE
106907: LD_EXP 176
106911: PUSH
106912: LD_VAR 0 1
106916: ARRAY
106917: INC
106918: ST_TO_ADDR
106919: LD_INT 1
106921: PUSH
106922: FOR_DOWNTO
106923: IFFALSE 107173
// begin side := GetSide ( minersList [ i ] ) ;
106925: LD_ADDR_VAR 0 3
106929: PUSH
106930: LD_EXP 175
106934: PUSH
106935: LD_VAR 0 1
106939: ARRAY
106940: PPUSH
106941: CALL_OW 255
106945: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
106946: LD_ADDR_VAR 0 4
106950: PUSH
106951: LD_EXP 176
106955: PUSH
106956: LD_VAR 0 1
106960: ARRAY
106961: PUSH
106962: LD_VAR 0 2
106966: ARRAY
106967: PUSH
106968: LD_INT 1
106970: ARRAY
106971: PPUSH
106972: LD_EXP 176
106976: PUSH
106977: LD_VAR 0 1
106981: ARRAY
106982: PUSH
106983: LD_VAR 0 2
106987: ARRAY
106988: PUSH
106989: LD_INT 2
106991: ARRAY
106992: PPUSH
106993: CALL_OW 428
106997: ST_TO_ADDR
// if not tmp then
106998: LD_VAR 0 4
107002: NOT
107003: IFFALSE 107007
// continue ;
107005: GO 106922
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
107007: LD_VAR 0 4
107011: PUSH
107012: LD_INT 81
107014: PUSH
107015: LD_VAR 0 3
107019: PUSH
107020: EMPTY
107021: LIST
107022: LIST
107023: PPUSH
107024: CALL_OW 69
107028: IN
107029: PUSH
107030: LD_EXP 176
107034: PUSH
107035: LD_VAR 0 1
107039: ARRAY
107040: PUSH
107041: LD_VAR 0 2
107045: ARRAY
107046: PUSH
107047: LD_INT 1
107049: ARRAY
107050: PPUSH
107051: LD_EXP 176
107055: PUSH
107056: LD_VAR 0 1
107060: ARRAY
107061: PUSH
107062: LD_VAR 0 2
107066: ARRAY
107067: PUSH
107068: LD_INT 2
107070: ARRAY
107071: PPUSH
107072: CALL_OW 458
107076: AND
107077: IFFALSE 107171
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
107079: LD_EXP 176
107083: PUSH
107084: LD_VAR 0 1
107088: ARRAY
107089: PUSH
107090: LD_VAR 0 2
107094: ARRAY
107095: PUSH
107096: LD_INT 1
107098: ARRAY
107099: PPUSH
107100: LD_EXP 176
107104: PUSH
107105: LD_VAR 0 1
107109: ARRAY
107110: PUSH
107111: LD_VAR 0 2
107115: ARRAY
107116: PUSH
107117: LD_INT 2
107119: ARRAY
107120: PPUSH
107121: LD_VAR 0 3
107125: PPUSH
107126: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
107130: LD_ADDR_EXP 176
107134: PUSH
107135: LD_EXP 176
107139: PPUSH
107140: LD_VAR 0 1
107144: PPUSH
107145: LD_EXP 176
107149: PUSH
107150: LD_VAR 0 1
107154: ARRAY
107155: PPUSH
107156: LD_VAR 0 2
107160: PPUSH
107161: CALL_OW 3
107165: PPUSH
107166: CALL_OW 1
107170: ST_TO_ADDR
// end ; end ;
107171: GO 106922
107173: POP
107174: POP
// end ;
107175: GO 106840
107177: POP
107178: POP
// end ;
107179: PPOPN 4
107181: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
107182: LD_INT 0
107184: PPUSH
107185: PPUSH
// result := false ;
107186: LD_ADDR_VAR 0 4
107190: PUSH
107191: LD_INT 0
107193: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
107194: LD_VAR 0 1
107198: PPUSH
107199: CALL_OW 264
107203: PUSH
107204: LD_INT 81
107206: EQUAL
107207: NOT
107208: IFFALSE 107212
// exit ;
107210: GO 107452
// index := GetElementIndex ( minersList , unit ) ;
107212: LD_ADDR_VAR 0 5
107216: PUSH
107217: LD_EXP 175
107221: PPUSH
107222: LD_VAR 0 1
107226: PPUSH
107227: CALL 20248 0 2
107231: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
107232: LD_EXP 176
107236: PUSH
107237: LD_VAR 0 5
107241: ARRAY
107242: PUSH
107243: LD_EXP 177
107247: GREATEREQUAL
107248: IFFALSE 107252
// exit ;
107250: GO 107452
// ComMoveXY ( unit , x , y ) ;
107252: LD_VAR 0 1
107256: PPUSH
107257: LD_VAR 0 2
107261: PPUSH
107262: LD_VAR 0 3
107266: PPUSH
107267: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
107271: LD_INT 35
107273: PPUSH
107274: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
107278: LD_VAR 0 1
107282: PPUSH
107283: LD_VAR 0 2
107287: PPUSH
107288: LD_VAR 0 3
107292: PPUSH
107293: CALL 52000 0 3
107297: NOT
107298: PUSH
107299: LD_VAR 0 1
107303: PPUSH
107304: CALL_OW 314
107308: AND
107309: IFFALSE 107313
// exit ;
107311: GO 107452
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
107313: LD_VAR 0 2
107317: PPUSH
107318: LD_VAR 0 3
107322: PPUSH
107323: CALL_OW 428
107327: PUSH
107328: LD_VAR 0 1
107332: EQUAL
107333: PUSH
107334: LD_VAR 0 1
107338: PPUSH
107339: CALL_OW 314
107343: NOT
107344: AND
107345: IFFALSE 107271
// PlaySoundXY ( x , y , PlantMine ) ;
107347: LD_VAR 0 2
107351: PPUSH
107352: LD_VAR 0 3
107356: PPUSH
107357: LD_STRING PlantMine
107359: PPUSH
107360: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
107364: LD_VAR 0 2
107368: PPUSH
107369: LD_VAR 0 3
107373: PPUSH
107374: LD_VAR 0 1
107378: PPUSH
107379: CALL_OW 255
107383: PPUSH
107384: LD_INT 0
107386: PPUSH
107387: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
107391: LD_ADDR_EXP 176
107395: PUSH
107396: LD_EXP 176
107400: PPUSH
107401: LD_VAR 0 5
107405: PUSH
107406: LD_EXP 176
107410: PUSH
107411: LD_VAR 0 5
107415: ARRAY
107416: PUSH
107417: LD_INT 1
107419: PLUS
107420: PUSH
107421: EMPTY
107422: LIST
107423: LIST
107424: PPUSH
107425: LD_VAR 0 2
107429: PUSH
107430: LD_VAR 0 3
107434: PUSH
107435: EMPTY
107436: LIST
107437: LIST
107438: PPUSH
107439: CALL 20463 0 3
107443: ST_TO_ADDR
// result := true ;
107444: LD_ADDR_VAR 0 4
107448: PUSH
107449: LD_INT 1
107451: ST_TO_ADDR
// end ;
107452: LD_VAR 0 4
107456: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
107457: LD_INT 0
107459: PPUSH
107460: PPUSH
107461: PPUSH
// if not unit in minersList then
107462: LD_VAR 0 1
107466: PUSH
107467: LD_EXP 175
107471: IN
107472: NOT
107473: IFFALSE 107477
// exit ;
107475: GO 107869
// index := GetElementIndex ( minersList , unit ) ;
107477: LD_ADDR_VAR 0 6
107481: PUSH
107482: LD_EXP 175
107486: PPUSH
107487: LD_VAR 0 1
107491: PPUSH
107492: CALL 20248 0 2
107496: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
107497: LD_ADDR_VAR 0 5
107501: PUSH
107502: DOUBLE
107503: LD_EXP 176
107507: PUSH
107508: LD_VAR 0 6
107512: ARRAY
107513: INC
107514: ST_TO_ADDR
107515: LD_INT 1
107517: PUSH
107518: FOR_DOWNTO
107519: IFFALSE 107680
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
107521: LD_EXP 176
107525: PUSH
107526: LD_VAR 0 6
107530: ARRAY
107531: PUSH
107532: LD_VAR 0 5
107536: ARRAY
107537: PUSH
107538: LD_INT 1
107540: ARRAY
107541: PUSH
107542: LD_VAR 0 2
107546: EQUAL
107547: PUSH
107548: LD_EXP 176
107552: PUSH
107553: LD_VAR 0 6
107557: ARRAY
107558: PUSH
107559: LD_VAR 0 5
107563: ARRAY
107564: PUSH
107565: LD_INT 2
107567: ARRAY
107568: PUSH
107569: LD_VAR 0 3
107573: EQUAL
107574: AND
107575: IFFALSE 107678
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
107577: LD_EXP 176
107581: PUSH
107582: LD_VAR 0 6
107586: ARRAY
107587: PUSH
107588: LD_VAR 0 5
107592: ARRAY
107593: PUSH
107594: LD_INT 1
107596: ARRAY
107597: PPUSH
107598: LD_EXP 176
107602: PUSH
107603: LD_VAR 0 6
107607: ARRAY
107608: PUSH
107609: LD_VAR 0 5
107613: ARRAY
107614: PUSH
107615: LD_INT 2
107617: ARRAY
107618: PPUSH
107619: LD_VAR 0 1
107623: PPUSH
107624: CALL_OW 255
107628: PPUSH
107629: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
107633: LD_ADDR_EXP 176
107637: PUSH
107638: LD_EXP 176
107642: PPUSH
107643: LD_VAR 0 6
107647: PPUSH
107648: LD_EXP 176
107652: PUSH
107653: LD_VAR 0 6
107657: ARRAY
107658: PPUSH
107659: LD_VAR 0 5
107663: PPUSH
107664: CALL_OW 3
107668: PPUSH
107669: CALL_OW 1
107673: ST_TO_ADDR
// exit ;
107674: POP
107675: POP
107676: GO 107869
// end ; end ;
107678: GO 107518
107680: POP
107681: POP
// for i := minerMinesList [ index ] downto 1 do
107682: LD_ADDR_VAR 0 5
107686: PUSH
107687: DOUBLE
107688: LD_EXP 176
107692: PUSH
107693: LD_VAR 0 6
107697: ARRAY
107698: INC
107699: ST_TO_ADDR
107700: LD_INT 1
107702: PUSH
107703: FOR_DOWNTO
107704: IFFALSE 107867
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
107706: LD_EXP 176
107710: PUSH
107711: LD_VAR 0 6
107715: ARRAY
107716: PUSH
107717: LD_VAR 0 5
107721: ARRAY
107722: PUSH
107723: LD_INT 1
107725: ARRAY
107726: PPUSH
107727: LD_EXP 176
107731: PUSH
107732: LD_VAR 0 6
107736: ARRAY
107737: PUSH
107738: LD_VAR 0 5
107742: ARRAY
107743: PUSH
107744: LD_INT 2
107746: ARRAY
107747: PPUSH
107748: LD_VAR 0 2
107752: PPUSH
107753: LD_VAR 0 3
107757: PPUSH
107758: CALL_OW 298
107762: PUSH
107763: LD_INT 6
107765: LESS
107766: IFFALSE 107865
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
107768: LD_EXP 176
107772: PUSH
107773: LD_VAR 0 6
107777: ARRAY
107778: PUSH
107779: LD_VAR 0 5
107783: ARRAY
107784: PUSH
107785: LD_INT 1
107787: ARRAY
107788: PPUSH
107789: LD_EXP 176
107793: PUSH
107794: LD_VAR 0 6
107798: ARRAY
107799: PUSH
107800: LD_VAR 0 5
107804: ARRAY
107805: PUSH
107806: LD_INT 2
107808: ARRAY
107809: PPUSH
107810: LD_VAR 0 1
107814: PPUSH
107815: CALL_OW 255
107819: PPUSH
107820: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
107824: LD_ADDR_EXP 176
107828: PUSH
107829: LD_EXP 176
107833: PPUSH
107834: LD_VAR 0 6
107838: PPUSH
107839: LD_EXP 176
107843: PUSH
107844: LD_VAR 0 6
107848: ARRAY
107849: PPUSH
107850: LD_VAR 0 5
107854: PPUSH
107855: CALL_OW 3
107859: PPUSH
107860: CALL_OW 1
107864: ST_TO_ADDR
// end ; end ;
107865: GO 107703
107867: POP
107868: POP
// end ;
107869: LD_VAR 0 4
107873: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
107874: LD_INT 0
107876: PPUSH
107877: PPUSH
107878: PPUSH
107879: PPUSH
107880: PPUSH
107881: PPUSH
107882: PPUSH
107883: PPUSH
107884: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
107885: LD_VAR 0 1
107889: PPUSH
107890: CALL_OW 264
107894: PUSH
107895: LD_INT 81
107897: EQUAL
107898: NOT
107899: PUSH
107900: LD_VAR 0 1
107904: PUSH
107905: LD_EXP 175
107909: IN
107910: NOT
107911: OR
107912: IFFALSE 107916
// exit ;
107914: GO 108238
// index := GetElementIndex ( minersList , unit ) ;
107916: LD_ADDR_VAR 0 6
107920: PUSH
107921: LD_EXP 175
107925: PPUSH
107926: LD_VAR 0 1
107930: PPUSH
107931: CALL 20248 0 2
107935: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
107936: LD_ADDR_VAR 0 8
107940: PUSH
107941: LD_EXP 177
107945: PUSH
107946: LD_EXP 176
107950: PUSH
107951: LD_VAR 0 6
107955: ARRAY
107956: MINUS
107957: ST_TO_ADDR
// if not minesFreeAmount then
107958: LD_VAR 0 8
107962: NOT
107963: IFFALSE 107967
// exit ;
107965: GO 108238
// tmp := [ ] ;
107967: LD_ADDR_VAR 0 7
107971: PUSH
107972: EMPTY
107973: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
107974: LD_ADDR_VAR 0 5
107978: PUSH
107979: DOUBLE
107980: LD_INT 1
107982: DEC
107983: ST_TO_ADDR
107984: LD_VAR 0 8
107988: PUSH
107989: FOR_TO
107990: IFFALSE 108185
// begin _d := rand ( 0 , 5 ) ;
107992: LD_ADDR_VAR 0 11
107996: PUSH
107997: LD_INT 0
107999: PPUSH
108000: LD_INT 5
108002: PPUSH
108003: CALL_OW 12
108007: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
108008: LD_ADDR_VAR 0 12
108012: PUSH
108013: LD_INT 2
108015: PPUSH
108016: LD_INT 6
108018: PPUSH
108019: CALL_OW 12
108023: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
108024: LD_ADDR_VAR 0 9
108028: PUSH
108029: LD_VAR 0 2
108033: PPUSH
108034: LD_VAR 0 11
108038: PPUSH
108039: LD_VAR 0 12
108043: PPUSH
108044: CALL_OW 272
108048: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
108049: LD_ADDR_VAR 0 10
108053: PUSH
108054: LD_VAR 0 3
108058: PPUSH
108059: LD_VAR 0 11
108063: PPUSH
108064: LD_VAR 0 12
108068: PPUSH
108069: CALL_OW 273
108073: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
108074: LD_VAR 0 9
108078: PPUSH
108079: LD_VAR 0 10
108083: PPUSH
108084: CALL_OW 488
108088: PUSH
108089: LD_VAR 0 9
108093: PUSH
108094: LD_VAR 0 10
108098: PUSH
108099: EMPTY
108100: LIST
108101: LIST
108102: PUSH
108103: LD_VAR 0 7
108107: IN
108108: NOT
108109: AND
108110: PUSH
108111: LD_VAR 0 9
108115: PPUSH
108116: LD_VAR 0 10
108120: PPUSH
108121: CALL_OW 458
108125: NOT
108126: AND
108127: IFFALSE 108169
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
108129: LD_ADDR_VAR 0 7
108133: PUSH
108134: LD_VAR 0 7
108138: PPUSH
108139: LD_VAR 0 7
108143: PUSH
108144: LD_INT 1
108146: PLUS
108147: PPUSH
108148: LD_VAR 0 9
108152: PUSH
108153: LD_VAR 0 10
108157: PUSH
108158: EMPTY
108159: LIST
108160: LIST
108161: PPUSH
108162: CALL_OW 1
108166: ST_TO_ADDR
108167: GO 108183
// i := i - 1 ;
108169: LD_ADDR_VAR 0 5
108173: PUSH
108174: LD_VAR 0 5
108178: PUSH
108179: LD_INT 1
108181: MINUS
108182: ST_TO_ADDR
// end ;
108183: GO 107989
108185: POP
108186: POP
// for i in tmp do
108187: LD_ADDR_VAR 0 5
108191: PUSH
108192: LD_VAR 0 7
108196: PUSH
108197: FOR_IN
108198: IFFALSE 108236
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
108200: LD_VAR 0 1
108204: PPUSH
108205: LD_VAR 0 5
108209: PUSH
108210: LD_INT 1
108212: ARRAY
108213: PPUSH
108214: LD_VAR 0 5
108218: PUSH
108219: LD_INT 2
108221: ARRAY
108222: PPUSH
108223: CALL 107182 0 3
108227: NOT
108228: IFFALSE 108234
// exit ;
108230: POP
108231: POP
108232: GO 108238
108234: GO 108197
108236: POP
108237: POP
// end ;
108238: LD_VAR 0 4
108242: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
108243: LD_INT 0
108245: PPUSH
108246: PPUSH
108247: PPUSH
108248: PPUSH
108249: PPUSH
108250: PPUSH
108251: PPUSH
// if not GetClass ( unit ) = class_sniper then
108252: LD_VAR 0 1
108256: PPUSH
108257: CALL_OW 257
108261: PUSH
108262: LD_INT 5
108264: EQUAL
108265: NOT
108266: IFFALSE 108270
// exit ;
108268: GO 108658
// dist := 8 ;
108270: LD_ADDR_VAR 0 5
108274: PUSH
108275: LD_INT 8
108277: ST_TO_ADDR
// viewRange := 12 ;
108278: LD_ADDR_VAR 0 7
108282: PUSH
108283: LD_INT 12
108285: ST_TO_ADDR
// side := GetSide ( unit ) ;
108286: LD_ADDR_VAR 0 6
108290: PUSH
108291: LD_VAR 0 1
108295: PPUSH
108296: CALL_OW 255
108300: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
108301: LD_INT 61
108303: PPUSH
108304: LD_VAR 0 6
108308: PPUSH
108309: CALL_OW 321
108313: PUSH
108314: LD_INT 2
108316: EQUAL
108317: IFFALSE 108327
// viewRange := 16 ;
108319: LD_ADDR_VAR 0 7
108323: PUSH
108324: LD_INT 16
108326: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
108327: LD_VAR 0 1
108331: PPUSH
108332: LD_VAR 0 2
108336: PPUSH
108337: LD_VAR 0 3
108341: PPUSH
108342: CALL_OW 297
108346: PUSH
108347: LD_VAR 0 5
108351: GREATER
108352: IFFALSE 108431
// begin ComMoveXY ( unit , x , y ) ;
108354: LD_VAR 0 1
108358: PPUSH
108359: LD_VAR 0 2
108363: PPUSH
108364: LD_VAR 0 3
108368: PPUSH
108369: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108373: LD_INT 35
108375: PPUSH
108376: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
108380: LD_VAR 0 1
108384: PPUSH
108385: LD_VAR 0 2
108389: PPUSH
108390: LD_VAR 0 3
108394: PPUSH
108395: CALL 52000 0 3
108399: NOT
108400: IFFALSE 108404
// exit ;
108402: GO 108658
// until GetDistUnitXY ( unit , x , y ) < dist ;
108404: LD_VAR 0 1
108408: PPUSH
108409: LD_VAR 0 2
108413: PPUSH
108414: LD_VAR 0 3
108418: PPUSH
108419: CALL_OW 297
108423: PUSH
108424: LD_VAR 0 5
108428: LESS
108429: IFFALSE 108373
// end ; ComTurnXY ( unit , x , y ) ;
108431: LD_VAR 0 1
108435: PPUSH
108436: LD_VAR 0 2
108440: PPUSH
108441: LD_VAR 0 3
108445: PPUSH
108446: CALL_OW 118
// wait ( 5 ) ;
108450: LD_INT 5
108452: PPUSH
108453: CALL_OW 67
// _d := GetDir ( unit ) ;
108457: LD_ADDR_VAR 0 10
108461: PUSH
108462: LD_VAR 0 1
108466: PPUSH
108467: CALL_OW 254
108471: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
108472: LD_ADDR_VAR 0 8
108476: PUSH
108477: LD_VAR 0 1
108481: PPUSH
108482: CALL_OW 250
108486: PPUSH
108487: LD_VAR 0 10
108491: PPUSH
108492: LD_VAR 0 5
108496: PPUSH
108497: CALL_OW 272
108501: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
108502: LD_ADDR_VAR 0 9
108506: PUSH
108507: LD_VAR 0 1
108511: PPUSH
108512: CALL_OW 251
108516: PPUSH
108517: LD_VAR 0 10
108521: PPUSH
108522: LD_VAR 0 5
108526: PPUSH
108527: CALL_OW 273
108531: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
108532: LD_VAR 0 8
108536: PPUSH
108537: LD_VAR 0 9
108541: PPUSH
108542: CALL_OW 488
108546: NOT
108547: IFFALSE 108551
// exit ;
108549: GO 108658
// ComAnimCustom ( unit , 1 ) ;
108551: LD_VAR 0 1
108555: PPUSH
108556: LD_INT 1
108558: PPUSH
108559: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
108563: LD_VAR 0 8
108567: PPUSH
108568: LD_VAR 0 9
108572: PPUSH
108573: LD_VAR 0 6
108577: PPUSH
108578: LD_VAR 0 7
108582: PPUSH
108583: CALL_OW 330
// repeat wait ( 1 ) ;
108587: LD_INT 1
108589: PPUSH
108590: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
108594: LD_VAR 0 1
108598: PPUSH
108599: CALL_OW 316
108603: PUSH
108604: LD_VAR 0 1
108608: PPUSH
108609: CALL_OW 314
108613: OR
108614: PUSH
108615: LD_VAR 0 1
108619: PPUSH
108620: CALL_OW 302
108624: NOT
108625: OR
108626: PUSH
108627: LD_VAR 0 1
108631: PPUSH
108632: CALL_OW 301
108636: OR
108637: IFFALSE 108587
// RemoveSeeing ( _x , _y , side ) ;
108639: LD_VAR 0 8
108643: PPUSH
108644: LD_VAR 0 9
108648: PPUSH
108649: LD_VAR 0 6
108653: PPUSH
108654: CALL_OW 331
// end ; end_of_file
108658: LD_VAR 0 4
108662: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
108663: LD_INT 0
108665: PPUSH
108666: PPUSH
108667: PPUSH
108668: PPUSH
108669: PPUSH
108670: PPUSH
108671: PPUSH
108672: PPUSH
108673: PPUSH
108674: PPUSH
108675: PPUSH
108676: PPUSH
108677: PPUSH
108678: PPUSH
108679: PPUSH
108680: PPUSH
108681: PPUSH
108682: PPUSH
108683: PPUSH
108684: PPUSH
108685: PPUSH
108686: PPUSH
108687: PPUSH
108688: PPUSH
108689: PPUSH
108690: PPUSH
108691: PPUSH
108692: PPUSH
108693: PPUSH
108694: PPUSH
108695: PPUSH
108696: PPUSH
108697: PPUSH
108698: PPUSH
// if not list then
108699: LD_VAR 0 1
108703: NOT
108704: IFFALSE 108708
// exit ;
108706: GO 113367
// base := list [ 1 ] ;
108708: LD_ADDR_VAR 0 3
108712: PUSH
108713: LD_VAR 0 1
108717: PUSH
108718: LD_INT 1
108720: ARRAY
108721: ST_TO_ADDR
// group := list [ 2 ] ;
108722: LD_ADDR_VAR 0 4
108726: PUSH
108727: LD_VAR 0 1
108731: PUSH
108732: LD_INT 2
108734: ARRAY
108735: ST_TO_ADDR
// path := list [ 3 ] ;
108736: LD_ADDR_VAR 0 5
108740: PUSH
108741: LD_VAR 0 1
108745: PUSH
108746: LD_INT 3
108748: ARRAY
108749: ST_TO_ADDR
// flags := list [ 4 ] ;
108750: LD_ADDR_VAR 0 6
108754: PUSH
108755: LD_VAR 0 1
108759: PUSH
108760: LD_INT 4
108762: ARRAY
108763: ST_TO_ADDR
// mined := [ ] ;
108764: LD_ADDR_VAR 0 27
108768: PUSH
108769: EMPTY
108770: ST_TO_ADDR
// bombed := [ ] ;
108771: LD_ADDR_VAR 0 28
108775: PUSH
108776: EMPTY
108777: ST_TO_ADDR
// healers := [ ] ;
108778: LD_ADDR_VAR 0 31
108782: PUSH
108783: EMPTY
108784: ST_TO_ADDR
// to_heal := [ ] ;
108785: LD_ADDR_VAR 0 30
108789: PUSH
108790: EMPTY
108791: ST_TO_ADDR
// repairs := [ ] ;
108792: LD_ADDR_VAR 0 33
108796: PUSH
108797: EMPTY
108798: ST_TO_ADDR
// to_repair := [ ] ;
108799: LD_ADDR_VAR 0 32
108803: PUSH
108804: EMPTY
108805: ST_TO_ADDR
// if not group or not path then
108806: LD_VAR 0 4
108810: NOT
108811: PUSH
108812: LD_VAR 0 5
108816: NOT
108817: OR
108818: IFFALSE 108822
// exit ;
108820: GO 113367
// side := GetSide ( group [ 1 ] ) ;
108822: LD_ADDR_VAR 0 35
108826: PUSH
108827: LD_VAR 0 4
108831: PUSH
108832: LD_INT 1
108834: ARRAY
108835: PPUSH
108836: CALL_OW 255
108840: ST_TO_ADDR
// if flags then
108841: LD_VAR 0 6
108845: IFFALSE 108989
// begin f_ignore_area := flags [ 1 ] ;
108847: LD_ADDR_VAR 0 17
108851: PUSH
108852: LD_VAR 0 6
108856: PUSH
108857: LD_INT 1
108859: ARRAY
108860: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
108861: LD_ADDR_VAR 0 18
108865: PUSH
108866: LD_VAR 0 6
108870: PUSH
108871: LD_INT 2
108873: ARRAY
108874: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
108875: LD_ADDR_VAR 0 19
108879: PUSH
108880: LD_VAR 0 6
108884: PUSH
108885: LD_INT 3
108887: ARRAY
108888: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
108889: LD_ADDR_VAR 0 20
108893: PUSH
108894: LD_VAR 0 6
108898: PUSH
108899: LD_INT 4
108901: ARRAY
108902: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
108903: LD_ADDR_VAR 0 21
108907: PUSH
108908: LD_VAR 0 6
108912: PUSH
108913: LD_INT 5
108915: ARRAY
108916: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
108917: LD_ADDR_VAR 0 22
108921: PUSH
108922: LD_VAR 0 6
108926: PUSH
108927: LD_INT 6
108929: ARRAY
108930: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
108931: LD_ADDR_VAR 0 23
108935: PUSH
108936: LD_VAR 0 6
108940: PUSH
108941: LD_INT 7
108943: ARRAY
108944: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
108945: LD_ADDR_VAR 0 24
108949: PUSH
108950: LD_VAR 0 6
108954: PUSH
108955: LD_INT 8
108957: ARRAY
108958: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
108959: LD_ADDR_VAR 0 25
108963: PUSH
108964: LD_VAR 0 6
108968: PUSH
108969: LD_INT 9
108971: ARRAY
108972: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
108973: LD_ADDR_VAR 0 26
108977: PUSH
108978: LD_VAR 0 6
108982: PUSH
108983: LD_INT 10
108985: ARRAY
108986: ST_TO_ADDR
// end else
108987: GO 109069
// begin f_ignore_area := false ;
108989: LD_ADDR_VAR 0 17
108993: PUSH
108994: LD_INT 0
108996: ST_TO_ADDR
// f_capture := false ;
108997: LD_ADDR_VAR 0 18
109001: PUSH
109002: LD_INT 0
109004: ST_TO_ADDR
// f_ignore_civ := false ;
109005: LD_ADDR_VAR 0 19
109009: PUSH
109010: LD_INT 0
109012: ST_TO_ADDR
// f_murder := false ;
109013: LD_ADDR_VAR 0 20
109017: PUSH
109018: LD_INT 0
109020: ST_TO_ADDR
// f_mines := false ;
109021: LD_ADDR_VAR 0 21
109025: PUSH
109026: LD_INT 0
109028: ST_TO_ADDR
// f_repair := false ;
109029: LD_ADDR_VAR 0 22
109033: PUSH
109034: LD_INT 0
109036: ST_TO_ADDR
// f_heal := false ;
109037: LD_ADDR_VAR 0 23
109041: PUSH
109042: LD_INT 0
109044: ST_TO_ADDR
// f_spacetime := false ;
109045: LD_ADDR_VAR 0 24
109049: PUSH
109050: LD_INT 0
109052: ST_TO_ADDR
// f_attack_depot := false ;
109053: LD_ADDR_VAR 0 25
109057: PUSH
109058: LD_INT 0
109060: ST_TO_ADDR
// f_crawl := false ;
109061: LD_ADDR_VAR 0 26
109065: PUSH
109066: LD_INT 0
109068: ST_TO_ADDR
// end ; if f_heal then
109069: LD_VAR 0 23
109073: IFFALSE 109100
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
109075: LD_ADDR_VAR 0 31
109079: PUSH
109080: LD_VAR 0 4
109084: PPUSH
109085: LD_INT 25
109087: PUSH
109088: LD_INT 4
109090: PUSH
109091: EMPTY
109092: LIST
109093: LIST
109094: PPUSH
109095: CALL_OW 72
109099: ST_TO_ADDR
// if f_repair then
109100: LD_VAR 0 22
109104: IFFALSE 109131
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
109106: LD_ADDR_VAR 0 33
109110: PUSH
109111: LD_VAR 0 4
109115: PPUSH
109116: LD_INT 25
109118: PUSH
109119: LD_INT 3
109121: PUSH
109122: EMPTY
109123: LIST
109124: LIST
109125: PPUSH
109126: CALL_OW 72
109130: ST_TO_ADDR
// units_path := [ ] ;
109131: LD_ADDR_VAR 0 16
109135: PUSH
109136: EMPTY
109137: ST_TO_ADDR
// for i = 1 to group do
109138: LD_ADDR_VAR 0 7
109142: PUSH
109143: DOUBLE
109144: LD_INT 1
109146: DEC
109147: ST_TO_ADDR
109148: LD_VAR 0 4
109152: PUSH
109153: FOR_TO
109154: IFFALSE 109183
// units_path := Replace ( units_path , i , path ) ;
109156: LD_ADDR_VAR 0 16
109160: PUSH
109161: LD_VAR 0 16
109165: PPUSH
109166: LD_VAR 0 7
109170: PPUSH
109171: LD_VAR 0 5
109175: PPUSH
109176: CALL_OW 1
109180: ST_TO_ADDR
109181: GO 109153
109183: POP
109184: POP
// repeat for i = group downto 1 do
109185: LD_ADDR_VAR 0 7
109189: PUSH
109190: DOUBLE
109191: LD_VAR 0 4
109195: INC
109196: ST_TO_ADDR
109197: LD_INT 1
109199: PUSH
109200: FOR_DOWNTO
109201: IFFALSE 113323
// begin wait ( 5 ) ;
109203: LD_INT 5
109205: PPUSH
109206: CALL_OW 67
// tmp := [ ] ;
109210: LD_ADDR_VAR 0 14
109214: PUSH
109215: EMPTY
109216: ST_TO_ADDR
// attacking := false ;
109217: LD_ADDR_VAR 0 29
109221: PUSH
109222: LD_INT 0
109224: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
109225: LD_VAR 0 4
109229: PUSH
109230: LD_VAR 0 7
109234: ARRAY
109235: PPUSH
109236: CALL_OW 301
109240: PUSH
109241: LD_VAR 0 4
109245: PUSH
109246: LD_VAR 0 7
109250: ARRAY
109251: NOT
109252: OR
109253: IFFALSE 109362
// begin if GetType ( group [ i ] ) = unit_human then
109255: LD_VAR 0 4
109259: PUSH
109260: LD_VAR 0 7
109264: ARRAY
109265: PPUSH
109266: CALL_OW 247
109270: PUSH
109271: LD_INT 1
109273: EQUAL
109274: IFFALSE 109320
// begin to_heal := to_heal diff group [ i ] ;
109276: LD_ADDR_VAR 0 30
109280: PUSH
109281: LD_VAR 0 30
109285: PUSH
109286: LD_VAR 0 4
109290: PUSH
109291: LD_VAR 0 7
109295: ARRAY
109296: DIFF
109297: ST_TO_ADDR
// healers := healers diff group [ i ] ;
109298: LD_ADDR_VAR 0 31
109302: PUSH
109303: LD_VAR 0 31
109307: PUSH
109308: LD_VAR 0 4
109312: PUSH
109313: LD_VAR 0 7
109317: ARRAY
109318: DIFF
109319: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
109320: LD_ADDR_VAR 0 4
109324: PUSH
109325: LD_VAR 0 4
109329: PPUSH
109330: LD_VAR 0 7
109334: PPUSH
109335: CALL_OW 3
109339: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
109340: LD_ADDR_VAR 0 16
109344: PUSH
109345: LD_VAR 0 16
109349: PPUSH
109350: LD_VAR 0 7
109354: PPUSH
109355: CALL_OW 3
109359: ST_TO_ADDR
// continue ;
109360: GO 109200
// end ; if f_repair then
109362: LD_VAR 0 22
109366: IFFALSE 109855
// begin if GetType ( group [ i ] ) = unit_vehicle then
109368: LD_VAR 0 4
109372: PUSH
109373: LD_VAR 0 7
109377: ARRAY
109378: PPUSH
109379: CALL_OW 247
109383: PUSH
109384: LD_INT 2
109386: EQUAL
109387: IFFALSE 109577
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
109389: LD_VAR 0 4
109393: PUSH
109394: LD_VAR 0 7
109398: ARRAY
109399: PPUSH
109400: CALL_OW 256
109404: PUSH
109405: LD_INT 700
109407: LESS
109408: PUSH
109409: LD_VAR 0 4
109413: PUSH
109414: LD_VAR 0 7
109418: ARRAY
109419: PUSH
109420: LD_VAR 0 32
109424: IN
109425: NOT
109426: AND
109427: IFFALSE 109451
// to_repair := to_repair union group [ i ] ;
109429: LD_ADDR_VAR 0 32
109433: PUSH
109434: LD_VAR 0 32
109438: PUSH
109439: LD_VAR 0 4
109443: PUSH
109444: LD_VAR 0 7
109448: ARRAY
109449: UNION
109450: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
109451: LD_VAR 0 4
109455: PUSH
109456: LD_VAR 0 7
109460: ARRAY
109461: PPUSH
109462: CALL_OW 256
109466: PUSH
109467: LD_INT 1000
109469: EQUAL
109470: PUSH
109471: LD_VAR 0 4
109475: PUSH
109476: LD_VAR 0 7
109480: ARRAY
109481: PUSH
109482: LD_VAR 0 32
109486: IN
109487: AND
109488: IFFALSE 109512
// to_repair := to_repair diff group [ i ] ;
109490: LD_ADDR_VAR 0 32
109494: PUSH
109495: LD_VAR 0 32
109499: PUSH
109500: LD_VAR 0 4
109504: PUSH
109505: LD_VAR 0 7
109509: ARRAY
109510: DIFF
109511: ST_TO_ADDR
// if group [ i ] in to_repair then
109512: LD_VAR 0 4
109516: PUSH
109517: LD_VAR 0 7
109521: ARRAY
109522: PUSH
109523: LD_VAR 0 32
109527: IN
109528: IFFALSE 109575
// begin if not IsInArea ( group [ i ] , f_repair ) then
109530: LD_VAR 0 4
109534: PUSH
109535: LD_VAR 0 7
109539: ARRAY
109540: PPUSH
109541: LD_VAR 0 22
109545: PPUSH
109546: CALL_OW 308
109550: NOT
109551: IFFALSE 109573
// ComMoveToArea ( group [ i ] , f_repair ) ;
109553: LD_VAR 0 4
109557: PUSH
109558: LD_VAR 0 7
109562: ARRAY
109563: PPUSH
109564: LD_VAR 0 22
109568: PPUSH
109569: CALL_OW 113
// continue ;
109573: GO 109200
// end ; end else
109575: GO 109855
// if group [ i ] in repairs then
109577: LD_VAR 0 4
109581: PUSH
109582: LD_VAR 0 7
109586: ARRAY
109587: PUSH
109588: LD_VAR 0 33
109592: IN
109593: IFFALSE 109855
// begin if IsInUnit ( group [ i ] ) then
109595: LD_VAR 0 4
109599: PUSH
109600: LD_VAR 0 7
109604: ARRAY
109605: PPUSH
109606: CALL_OW 310
109610: IFFALSE 109678
// begin z := IsInUnit ( group [ i ] ) ;
109612: LD_ADDR_VAR 0 13
109616: PUSH
109617: LD_VAR 0 4
109621: PUSH
109622: LD_VAR 0 7
109626: ARRAY
109627: PPUSH
109628: CALL_OW 310
109632: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
109633: LD_VAR 0 13
109637: PUSH
109638: LD_VAR 0 32
109642: IN
109643: PUSH
109644: LD_VAR 0 13
109648: PPUSH
109649: LD_VAR 0 22
109653: PPUSH
109654: CALL_OW 308
109658: AND
109659: IFFALSE 109676
// ComExitVehicle ( group [ i ] ) ;
109661: LD_VAR 0 4
109665: PUSH
109666: LD_VAR 0 7
109670: ARRAY
109671: PPUSH
109672: CALL_OW 121
// end else
109676: GO 109855
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
109678: LD_ADDR_VAR 0 13
109682: PUSH
109683: LD_VAR 0 4
109687: PPUSH
109688: LD_INT 95
109690: PUSH
109691: LD_VAR 0 22
109695: PUSH
109696: EMPTY
109697: LIST
109698: LIST
109699: PUSH
109700: LD_INT 58
109702: PUSH
109703: EMPTY
109704: LIST
109705: PUSH
109706: EMPTY
109707: LIST
109708: LIST
109709: PPUSH
109710: CALL_OW 72
109714: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
109715: LD_VAR 0 4
109719: PUSH
109720: LD_VAR 0 7
109724: ARRAY
109725: PPUSH
109726: CALL_OW 314
109730: NOT
109731: IFFALSE 109853
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
109733: LD_ADDR_VAR 0 10
109737: PUSH
109738: LD_VAR 0 13
109742: PPUSH
109743: LD_VAR 0 4
109747: PUSH
109748: LD_VAR 0 7
109752: ARRAY
109753: PPUSH
109754: CALL_OW 74
109758: ST_TO_ADDR
// if not x then
109759: LD_VAR 0 10
109763: NOT
109764: IFFALSE 109768
// continue ;
109766: GO 109200
// if GetLives ( x ) < 1000 then
109768: LD_VAR 0 10
109772: PPUSH
109773: CALL_OW 256
109777: PUSH
109778: LD_INT 1000
109780: LESS
109781: IFFALSE 109805
// ComRepairVehicle ( group [ i ] , x ) else
109783: LD_VAR 0 4
109787: PUSH
109788: LD_VAR 0 7
109792: ARRAY
109793: PPUSH
109794: LD_VAR 0 10
109798: PPUSH
109799: CALL_OW 129
109803: GO 109853
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
109805: LD_VAR 0 23
109809: PUSH
109810: LD_VAR 0 4
109814: PUSH
109815: LD_VAR 0 7
109819: ARRAY
109820: PPUSH
109821: CALL_OW 256
109825: PUSH
109826: LD_INT 1000
109828: LESS
109829: AND
109830: NOT
109831: IFFALSE 109853
// ComEnterUnit ( group [ i ] , x ) ;
109833: LD_VAR 0 4
109837: PUSH
109838: LD_VAR 0 7
109842: ARRAY
109843: PPUSH
109844: LD_VAR 0 10
109848: PPUSH
109849: CALL_OW 120
// end ; continue ;
109853: GO 109200
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
109855: LD_VAR 0 23
109859: PUSH
109860: LD_VAR 0 4
109864: PUSH
109865: LD_VAR 0 7
109869: ARRAY
109870: PPUSH
109871: CALL_OW 247
109875: PUSH
109876: LD_INT 1
109878: EQUAL
109879: AND
109880: IFFALSE 110358
// begin if group [ i ] in healers then
109882: LD_VAR 0 4
109886: PUSH
109887: LD_VAR 0 7
109891: ARRAY
109892: PUSH
109893: LD_VAR 0 31
109897: IN
109898: IFFALSE 110171
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
109900: LD_VAR 0 4
109904: PUSH
109905: LD_VAR 0 7
109909: ARRAY
109910: PPUSH
109911: LD_VAR 0 23
109915: PPUSH
109916: CALL_OW 308
109920: NOT
109921: PUSH
109922: LD_VAR 0 4
109926: PUSH
109927: LD_VAR 0 7
109931: ARRAY
109932: PPUSH
109933: CALL_OW 314
109937: NOT
109938: AND
109939: IFFALSE 109963
// ComMoveToArea ( group [ i ] , f_heal ) else
109941: LD_VAR 0 4
109945: PUSH
109946: LD_VAR 0 7
109950: ARRAY
109951: PPUSH
109952: LD_VAR 0 23
109956: PPUSH
109957: CALL_OW 113
109961: GO 110169
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
109963: LD_VAR 0 4
109967: PUSH
109968: LD_VAR 0 7
109972: ARRAY
109973: PPUSH
109974: CALL 50583 0 1
109978: PPUSH
109979: CALL_OW 256
109983: PUSH
109984: LD_INT 1000
109986: EQUAL
109987: IFFALSE 110006
// ComStop ( group [ i ] ) else
109989: LD_VAR 0 4
109993: PUSH
109994: LD_VAR 0 7
109998: ARRAY
109999: PPUSH
110000: CALL_OW 141
110004: GO 110169
// if not HasTask ( group [ i ] ) and to_heal then
110006: LD_VAR 0 4
110010: PUSH
110011: LD_VAR 0 7
110015: ARRAY
110016: PPUSH
110017: CALL_OW 314
110021: NOT
110022: PUSH
110023: LD_VAR 0 30
110027: AND
110028: IFFALSE 110169
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
110030: LD_ADDR_VAR 0 13
110034: PUSH
110035: LD_VAR 0 30
110039: PPUSH
110040: LD_INT 3
110042: PUSH
110043: LD_INT 54
110045: PUSH
110046: EMPTY
110047: LIST
110048: PUSH
110049: EMPTY
110050: LIST
110051: LIST
110052: PPUSH
110053: CALL_OW 72
110057: PPUSH
110058: LD_VAR 0 4
110062: PUSH
110063: LD_VAR 0 7
110067: ARRAY
110068: PPUSH
110069: CALL_OW 74
110073: ST_TO_ADDR
// if z then
110074: LD_VAR 0 13
110078: IFFALSE 110169
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
110080: LD_INT 91
110082: PUSH
110083: LD_VAR 0 13
110087: PUSH
110088: LD_INT 10
110090: PUSH
110091: EMPTY
110092: LIST
110093: LIST
110094: LIST
110095: PUSH
110096: LD_INT 81
110098: PUSH
110099: LD_VAR 0 13
110103: PPUSH
110104: CALL_OW 255
110108: PUSH
110109: EMPTY
110110: LIST
110111: LIST
110112: PUSH
110113: EMPTY
110114: LIST
110115: LIST
110116: PPUSH
110117: CALL_OW 69
110121: PUSH
110122: LD_INT 0
110124: EQUAL
110125: IFFALSE 110149
// ComHeal ( group [ i ] , z ) else
110127: LD_VAR 0 4
110131: PUSH
110132: LD_VAR 0 7
110136: ARRAY
110137: PPUSH
110138: LD_VAR 0 13
110142: PPUSH
110143: CALL_OW 128
110147: GO 110169
// ComMoveToArea ( group [ i ] , f_heal ) ;
110149: LD_VAR 0 4
110153: PUSH
110154: LD_VAR 0 7
110158: ARRAY
110159: PPUSH
110160: LD_VAR 0 23
110164: PPUSH
110165: CALL_OW 113
// end ; continue ;
110169: GO 109200
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
110171: LD_VAR 0 4
110175: PUSH
110176: LD_VAR 0 7
110180: ARRAY
110181: PPUSH
110182: CALL_OW 256
110186: PUSH
110187: LD_INT 700
110189: LESS
110190: PUSH
110191: LD_VAR 0 4
110195: PUSH
110196: LD_VAR 0 7
110200: ARRAY
110201: PUSH
110202: LD_VAR 0 30
110206: IN
110207: NOT
110208: AND
110209: IFFALSE 110233
// to_heal := to_heal union group [ i ] ;
110211: LD_ADDR_VAR 0 30
110215: PUSH
110216: LD_VAR 0 30
110220: PUSH
110221: LD_VAR 0 4
110225: PUSH
110226: LD_VAR 0 7
110230: ARRAY
110231: UNION
110232: ST_TO_ADDR
// if group [ i ] in to_heal then
110233: LD_VAR 0 4
110237: PUSH
110238: LD_VAR 0 7
110242: ARRAY
110243: PUSH
110244: LD_VAR 0 30
110248: IN
110249: IFFALSE 110358
// begin if GetLives ( group [ i ] ) = 1000 then
110251: LD_VAR 0 4
110255: PUSH
110256: LD_VAR 0 7
110260: ARRAY
110261: PPUSH
110262: CALL_OW 256
110266: PUSH
110267: LD_INT 1000
110269: EQUAL
110270: IFFALSE 110296
// to_heal := to_heal diff group [ i ] else
110272: LD_ADDR_VAR 0 30
110276: PUSH
110277: LD_VAR 0 30
110281: PUSH
110282: LD_VAR 0 4
110286: PUSH
110287: LD_VAR 0 7
110291: ARRAY
110292: DIFF
110293: ST_TO_ADDR
110294: GO 110358
// begin if not IsInArea ( group [ i ] , to_heal ) then
110296: LD_VAR 0 4
110300: PUSH
110301: LD_VAR 0 7
110305: ARRAY
110306: PPUSH
110307: LD_VAR 0 30
110311: PPUSH
110312: CALL_OW 308
110316: NOT
110317: IFFALSE 110341
// ComMoveToArea ( group [ i ] , f_heal ) else
110319: LD_VAR 0 4
110323: PUSH
110324: LD_VAR 0 7
110328: ARRAY
110329: PPUSH
110330: LD_VAR 0 23
110334: PPUSH
110335: CALL_OW 113
110339: GO 110356
// ComHold ( group [ i ] ) ;
110341: LD_VAR 0 4
110345: PUSH
110346: LD_VAR 0 7
110350: ARRAY
110351: PPUSH
110352: CALL_OW 140
// continue ;
110356: GO 109200
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
110358: LD_VAR 0 4
110362: PUSH
110363: LD_VAR 0 7
110367: ARRAY
110368: PPUSH
110369: LD_INT 10
110371: PPUSH
110372: CALL 48354 0 2
110376: NOT
110377: PUSH
110378: LD_VAR 0 16
110382: PUSH
110383: LD_VAR 0 7
110387: ARRAY
110388: PUSH
110389: EMPTY
110390: EQUAL
110391: NOT
110392: AND
110393: IFFALSE 110659
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
110395: LD_VAR 0 4
110399: PUSH
110400: LD_VAR 0 7
110404: ARRAY
110405: PPUSH
110406: CALL_OW 262
110410: PUSH
110411: LD_INT 1
110413: PUSH
110414: LD_INT 2
110416: PUSH
110417: EMPTY
110418: LIST
110419: LIST
110420: IN
110421: IFFALSE 110462
// if GetFuel ( group [ i ] ) < 10 then
110423: LD_VAR 0 4
110427: PUSH
110428: LD_VAR 0 7
110432: ARRAY
110433: PPUSH
110434: CALL_OW 261
110438: PUSH
110439: LD_INT 10
110441: LESS
110442: IFFALSE 110462
// SetFuel ( group [ i ] , 12 ) ;
110444: LD_VAR 0 4
110448: PUSH
110449: LD_VAR 0 7
110453: ARRAY
110454: PPUSH
110455: LD_INT 12
110457: PPUSH
110458: CALL_OW 240
// if units_path [ i ] then
110462: LD_VAR 0 16
110466: PUSH
110467: LD_VAR 0 7
110471: ARRAY
110472: IFFALSE 110657
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
110474: LD_VAR 0 4
110478: PUSH
110479: LD_VAR 0 7
110483: ARRAY
110484: PPUSH
110485: LD_VAR 0 16
110489: PUSH
110490: LD_VAR 0 7
110494: ARRAY
110495: PUSH
110496: LD_INT 1
110498: ARRAY
110499: PUSH
110500: LD_INT 1
110502: ARRAY
110503: PPUSH
110504: LD_VAR 0 16
110508: PUSH
110509: LD_VAR 0 7
110513: ARRAY
110514: PUSH
110515: LD_INT 1
110517: ARRAY
110518: PUSH
110519: LD_INT 2
110521: ARRAY
110522: PPUSH
110523: CALL_OW 297
110527: PUSH
110528: LD_INT 6
110530: GREATER
110531: IFFALSE 110606
// begin if not HasTask ( group [ i ] ) then
110533: LD_VAR 0 4
110537: PUSH
110538: LD_VAR 0 7
110542: ARRAY
110543: PPUSH
110544: CALL_OW 314
110548: NOT
110549: IFFALSE 110604
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
110551: LD_VAR 0 4
110555: PUSH
110556: LD_VAR 0 7
110560: ARRAY
110561: PPUSH
110562: LD_VAR 0 16
110566: PUSH
110567: LD_VAR 0 7
110571: ARRAY
110572: PUSH
110573: LD_INT 1
110575: ARRAY
110576: PUSH
110577: LD_INT 1
110579: ARRAY
110580: PPUSH
110581: LD_VAR 0 16
110585: PUSH
110586: LD_VAR 0 7
110590: ARRAY
110591: PUSH
110592: LD_INT 1
110594: ARRAY
110595: PUSH
110596: LD_INT 2
110598: ARRAY
110599: PPUSH
110600: CALL_OW 114
// end else
110604: GO 110657
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
110606: LD_ADDR_VAR 0 15
110610: PUSH
110611: LD_VAR 0 16
110615: PUSH
110616: LD_VAR 0 7
110620: ARRAY
110621: PPUSH
110622: LD_INT 1
110624: PPUSH
110625: CALL_OW 3
110629: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
110630: LD_ADDR_VAR 0 16
110634: PUSH
110635: LD_VAR 0 16
110639: PPUSH
110640: LD_VAR 0 7
110644: PPUSH
110645: LD_VAR 0 15
110649: PPUSH
110650: CALL_OW 1
110654: ST_TO_ADDR
// continue ;
110655: GO 109200
// end ; end ; end else
110657: GO 113321
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
110659: LD_ADDR_VAR 0 14
110663: PUSH
110664: LD_INT 81
110666: PUSH
110667: LD_VAR 0 4
110671: PUSH
110672: LD_VAR 0 7
110676: ARRAY
110677: PPUSH
110678: CALL_OW 255
110682: PUSH
110683: EMPTY
110684: LIST
110685: LIST
110686: PPUSH
110687: CALL_OW 69
110691: ST_TO_ADDR
// if not tmp then
110692: LD_VAR 0 14
110696: NOT
110697: IFFALSE 110701
// continue ;
110699: GO 109200
// if f_ignore_area then
110701: LD_VAR 0 17
110705: IFFALSE 110793
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
110707: LD_ADDR_VAR 0 15
110711: PUSH
110712: LD_VAR 0 14
110716: PPUSH
110717: LD_INT 3
110719: PUSH
110720: LD_INT 92
110722: PUSH
110723: LD_VAR 0 17
110727: PUSH
110728: LD_INT 1
110730: ARRAY
110731: PUSH
110732: LD_VAR 0 17
110736: PUSH
110737: LD_INT 2
110739: ARRAY
110740: PUSH
110741: LD_VAR 0 17
110745: PUSH
110746: LD_INT 3
110748: ARRAY
110749: PUSH
110750: EMPTY
110751: LIST
110752: LIST
110753: LIST
110754: LIST
110755: PUSH
110756: EMPTY
110757: LIST
110758: LIST
110759: PPUSH
110760: CALL_OW 72
110764: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
110765: LD_VAR 0 14
110769: PUSH
110770: LD_VAR 0 15
110774: DIFF
110775: IFFALSE 110793
// tmp := tmp diff tmp2 ;
110777: LD_ADDR_VAR 0 14
110781: PUSH
110782: LD_VAR 0 14
110786: PUSH
110787: LD_VAR 0 15
110791: DIFF
110792: ST_TO_ADDR
// end ; if not f_murder then
110793: LD_VAR 0 20
110797: NOT
110798: IFFALSE 110856
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
110800: LD_ADDR_VAR 0 15
110804: PUSH
110805: LD_VAR 0 14
110809: PPUSH
110810: LD_INT 3
110812: PUSH
110813: LD_INT 50
110815: PUSH
110816: EMPTY
110817: LIST
110818: PUSH
110819: EMPTY
110820: LIST
110821: LIST
110822: PPUSH
110823: CALL_OW 72
110827: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
110828: LD_VAR 0 14
110832: PUSH
110833: LD_VAR 0 15
110837: DIFF
110838: IFFALSE 110856
// tmp := tmp diff tmp2 ;
110840: LD_ADDR_VAR 0 14
110844: PUSH
110845: LD_VAR 0 14
110849: PUSH
110850: LD_VAR 0 15
110854: DIFF
110855: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
110856: LD_ADDR_VAR 0 14
110860: PUSH
110861: LD_VAR 0 4
110865: PUSH
110866: LD_VAR 0 7
110870: ARRAY
110871: PPUSH
110872: LD_VAR 0 14
110876: PPUSH
110877: LD_INT 1
110879: PPUSH
110880: LD_INT 1
110882: PPUSH
110883: CALL 20898 0 4
110887: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
110888: LD_VAR 0 4
110892: PUSH
110893: LD_VAR 0 7
110897: ARRAY
110898: PPUSH
110899: CALL_OW 257
110903: PUSH
110904: LD_INT 1
110906: EQUAL
110907: IFFALSE 111355
// begin if WantPlant ( group [ i ] ) then
110909: LD_VAR 0 4
110913: PUSH
110914: LD_VAR 0 7
110918: ARRAY
110919: PPUSH
110920: CALL 20399 0 1
110924: IFFALSE 110928
// continue ;
110926: GO 109200
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
110928: LD_VAR 0 18
110932: PUSH
110933: LD_VAR 0 4
110937: PUSH
110938: LD_VAR 0 7
110942: ARRAY
110943: PPUSH
110944: CALL_OW 310
110948: NOT
110949: AND
110950: PUSH
110951: LD_VAR 0 14
110955: PUSH
110956: LD_INT 1
110958: ARRAY
110959: PUSH
110960: LD_VAR 0 14
110964: PPUSH
110965: LD_INT 21
110967: PUSH
110968: LD_INT 2
110970: PUSH
110971: EMPTY
110972: LIST
110973: LIST
110974: PUSH
110975: LD_INT 58
110977: PUSH
110978: EMPTY
110979: LIST
110980: PUSH
110981: EMPTY
110982: LIST
110983: LIST
110984: PPUSH
110985: CALL_OW 72
110989: IN
110990: AND
110991: IFFALSE 111027
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
110993: LD_VAR 0 4
110997: PUSH
110998: LD_VAR 0 7
111002: ARRAY
111003: PPUSH
111004: LD_VAR 0 14
111008: PUSH
111009: LD_INT 1
111011: ARRAY
111012: PPUSH
111013: CALL_OW 120
// attacking := true ;
111017: LD_ADDR_VAR 0 29
111021: PUSH
111022: LD_INT 1
111024: ST_TO_ADDR
// continue ;
111025: GO 109200
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
111027: LD_VAR 0 26
111031: PUSH
111032: LD_VAR 0 4
111036: PUSH
111037: LD_VAR 0 7
111041: ARRAY
111042: PPUSH
111043: CALL_OW 257
111047: PUSH
111048: LD_INT 1
111050: EQUAL
111051: AND
111052: PUSH
111053: LD_VAR 0 4
111057: PUSH
111058: LD_VAR 0 7
111062: ARRAY
111063: PPUSH
111064: CALL_OW 256
111068: PUSH
111069: LD_INT 800
111071: LESS
111072: AND
111073: PUSH
111074: LD_VAR 0 4
111078: PUSH
111079: LD_VAR 0 7
111083: ARRAY
111084: PPUSH
111085: CALL_OW 318
111089: NOT
111090: AND
111091: IFFALSE 111108
// ComCrawl ( group [ i ] ) ;
111093: LD_VAR 0 4
111097: PUSH
111098: LD_VAR 0 7
111102: ARRAY
111103: PPUSH
111104: CALL_OW 137
// if f_mines then
111108: LD_VAR 0 21
111112: IFFALSE 111355
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
111114: LD_VAR 0 14
111118: PUSH
111119: LD_INT 1
111121: ARRAY
111122: PPUSH
111123: CALL_OW 247
111127: PUSH
111128: LD_INT 3
111130: EQUAL
111131: PUSH
111132: LD_VAR 0 14
111136: PUSH
111137: LD_INT 1
111139: ARRAY
111140: PUSH
111141: LD_VAR 0 27
111145: IN
111146: NOT
111147: AND
111148: IFFALSE 111355
// begin x := GetX ( tmp [ 1 ] ) ;
111150: LD_ADDR_VAR 0 10
111154: PUSH
111155: LD_VAR 0 14
111159: PUSH
111160: LD_INT 1
111162: ARRAY
111163: PPUSH
111164: CALL_OW 250
111168: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
111169: LD_ADDR_VAR 0 11
111173: PUSH
111174: LD_VAR 0 14
111178: PUSH
111179: LD_INT 1
111181: ARRAY
111182: PPUSH
111183: CALL_OW 251
111187: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
111188: LD_ADDR_VAR 0 12
111192: PUSH
111193: LD_VAR 0 4
111197: PUSH
111198: LD_VAR 0 7
111202: ARRAY
111203: PPUSH
111204: CALL 48439 0 1
111208: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
111209: LD_VAR 0 4
111213: PUSH
111214: LD_VAR 0 7
111218: ARRAY
111219: PPUSH
111220: LD_VAR 0 10
111224: PPUSH
111225: LD_VAR 0 11
111229: PPUSH
111230: LD_VAR 0 14
111234: PUSH
111235: LD_INT 1
111237: ARRAY
111238: PPUSH
111239: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
111243: LD_VAR 0 4
111247: PUSH
111248: LD_VAR 0 7
111252: ARRAY
111253: PPUSH
111254: LD_VAR 0 10
111258: PPUSH
111259: LD_VAR 0 12
111263: PPUSH
111264: LD_INT 7
111266: PPUSH
111267: CALL_OW 272
111271: PPUSH
111272: LD_VAR 0 11
111276: PPUSH
111277: LD_VAR 0 12
111281: PPUSH
111282: LD_INT 7
111284: PPUSH
111285: CALL_OW 273
111289: PPUSH
111290: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
111294: LD_VAR 0 4
111298: PUSH
111299: LD_VAR 0 7
111303: ARRAY
111304: PPUSH
111305: LD_INT 71
111307: PPUSH
111308: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
111312: LD_ADDR_VAR 0 27
111316: PUSH
111317: LD_VAR 0 27
111321: PPUSH
111322: LD_VAR 0 27
111326: PUSH
111327: LD_INT 1
111329: PLUS
111330: PPUSH
111331: LD_VAR 0 14
111335: PUSH
111336: LD_INT 1
111338: ARRAY
111339: PPUSH
111340: CALL_OW 1
111344: ST_TO_ADDR
// attacking := true ;
111345: LD_ADDR_VAR 0 29
111349: PUSH
111350: LD_INT 1
111352: ST_TO_ADDR
// continue ;
111353: GO 109200
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
111355: LD_VAR 0 4
111359: PUSH
111360: LD_VAR 0 7
111364: ARRAY
111365: PPUSH
111366: CALL_OW 257
111370: PUSH
111371: LD_INT 17
111373: EQUAL
111374: PUSH
111375: LD_VAR 0 4
111379: PUSH
111380: LD_VAR 0 7
111384: ARRAY
111385: PPUSH
111386: CALL_OW 110
111390: PUSH
111391: LD_INT 71
111393: EQUAL
111394: NOT
111395: AND
111396: IFFALSE 111542
// begin attacking := false ;
111398: LD_ADDR_VAR 0 29
111402: PUSH
111403: LD_INT 0
111405: ST_TO_ADDR
// k := 5 ;
111406: LD_ADDR_VAR 0 9
111410: PUSH
111411: LD_INT 5
111413: ST_TO_ADDR
// if tmp < k then
111414: LD_VAR 0 14
111418: PUSH
111419: LD_VAR 0 9
111423: LESS
111424: IFFALSE 111436
// k := tmp ;
111426: LD_ADDR_VAR 0 9
111430: PUSH
111431: LD_VAR 0 14
111435: ST_TO_ADDR
// for j = 1 to k do
111436: LD_ADDR_VAR 0 8
111440: PUSH
111441: DOUBLE
111442: LD_INT 1
111444: DEC
111445: ST_TO_ADDR
111446: LD_VAR 0 9
111450: PUSH
111451: FOR_TO
111452: IFFALSE 111540
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
111454: LD_VAR 0 14
111458: PUSH
111459: LD_VAR 0 8
111463: ARRAY
111464: PUSH
111465: LD_VAR 0 14
111469: PPUSH
111470: LD_INT 58
111472: PUSH
111473: EMPTY
111474: LIST
111475: PPUSH
111476: CALL_OW 72
111480: IN
111481: NOT
111482: IFFALSE 111538
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111484: LD_VAR 0 4
111488: PUSH
111489: LD_VAR 0 7
111493: ARRAY
111494: PPUSH
111495: LD_VAR 0 14
111499: PUSH
111500: LD_VAR 0 8
111504: ARRAY
111505: PPUSH
111506: CALL_OW 115
// attacking := true ;
111510: LD_ADDR_VAR 0 29
111514: PUSH
111515: LD_INT 1
111517: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
111518: LD_VAR 0 4
111522: PUSH
111523: LD_VAR 0 7
111527: ARRAY
111528: PPUSH
111529: LD_INT 71
111531: PPUSH
111532: CALL_OW 109
// continue ;
111536: GO 111451
// end ; end ;
111538: GO 111451
111540: POP
111541: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
111542: LD_VAR 0 4
111546: PUSH
111547: LD_VAR 0 7
111551: ARRAY
111552: PPUSH
111553: CALL_OW 257
111557: PUSH
111558: LD_INT 8
111560: EQUAL
111561: PUSH
111562: LD_VAR 0 4
111566: PUSH
111567: LD_VAR 0 7
111571: ARRAY
111572: PPUSH
111573: CALL_OW 264
111577: PUSH
111578: LD_INT 28
111580: PUSH
111581: LD_INT 45
111583: PUSH
111584: LD_INT 7
111586: PUSH
111587: LD_INT 47
111589: PUSH
111590: EMPTY
111591: LIST
111592: LIST
111593: LIST
111594: LIST
111595: IN
111596: OR
111597: IFFALSE 111853
// begin attacking := false ;
111599: LD_ADDR_VAR 0 29
111603: PUSH
111604: LD_INT 0
111606: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
111607: LD_VAR 0 14
111611: PUSH
111612: LD_INT 1
111614: ARRAY
111615: PPUSH
111616: CALL_OW 266
111620: PUSH
111621: LD_INT 32
111623: PUSH
111624: LD_INT 31
111626: PUSH
111627: LD_INT 33
111629: PUSH
111630: LD_INT 4
111632: PUSH
111633: LD_INT 5
111635: PUSH
111636: EMPTY
111637: LIST
111638: LIST
111639: LIST
111640: LIST
111641: LIST
111642: IN
111643: IFFALSE 111829
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
111645: LD_ADDR_VAR 0 9
111649: PUSH
111650: LD_VAR 0 14
111654: PUSH
111655: LD_INT 1
111657: ARRAY
111658: PPUSH
111659: CALL_OW 266
111663: PPUSH
111664: LD_VAR 0 14
111668: PUSH
111669: LD_INT 1
111671: ARRAY
111672: PPUSH
111673: CALL_OW 250
111677: PPUSH
111678: LD_VAR 0 14
111682: PUSH
111683: LD_INT 1
111685: ARRAY
111686: PPUSH
111687: CALL_OW 251
111691: PPUSH
111692: LD_VAR 0 14
111696: PUSH
111697: LD_INT 1
111699: ARRAY
111700: PPUSH
111701: CALL_OW 254
111705: PPUSH
111706: LD_VAR 0 14
111710: PUSH
111711: LD_INT 1
111713: ARRAY
111714: PPUSH
111715: CALL_OW 248
111719: PPUSH
111720: LD_INT 0
111722: PPUSH
111723: CALL 29809 0 6
111727: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
111728: LD_ADDR_VAR 0 8
111732: PUSH
111733: LD_VAR 0 4
111737: PUSH
111738: LD_VAR 0 7
111742: ARRAY
111743: PPUSH
111744: LD_VAR 0 9
111748: PPUSH
111749: CALL 48552 0 2
111753: ST_TO_ADDR
// if j then
111754: LD_VAR 0 8
111758: IFFALSE 111827
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
111760: LD_VAR 0 8
111764: PUSH
111765: LD_INT 1
111767: ARRAY
111768: PPUSH
111769: LD_VAR 0 8
111773: PUSH
111774: LD_INT 2
111776: ARRAY
111777: PPUSH
111778: CALL_OW 488
111782: IFFALSE 111827
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
111784: LD_VAR 0 4
111788: PUSH
111789: LD_VAR 0 7
111793: ARRAY
111794: PPUSH
111795: LD_VAR 0 8
111799: PUSH
111800: LD_INT 1
111802: ARRAY
111803: PPUSH
111804: LD_VAR 0 8
111808: PUSH
111809: LD_INT 2
111811: ARRAY
111812: PPUSH
111813: CALL_OW 116
// attacking := true ;
111817: LD_ADDR_VAR 0 29
111821: PUSH
111822: LD_INT 1
111824: ST_TO_ADDR
// continue ;
111825: GO 109200
// end ; end else
111827: GO 111853
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111829: LD_VAR 0 4
111833: PUSH
111834: LD_VAR 0 7
111838: ARRAY
111839: PPUSH
111840: LD_VAR 0 14
111844: PUSH
111845: LD_INT 1
111847: ARRAY
111848: PPUSH
111849: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
111853: LD_VAR 0 4
111857: PUSH
111858: LD_VAR 0 7
111862: ARRAY
111863: PPUSH
111864: CALL_OW 265
111868: PUSH
111869: LD_INT 11
111871: EQUAL
111872: IFFALSE 112150
// begin k := 10 ;
111874: LD_ADDR_VAR 0 9
111878: PUSH
111879: LD_INT 10
111881: ST_TO_ADDR
// x := 0 ;
111882: LD_ADDR_VAR 0 10
111886: PUSH
111887: LD_INT 0
111889: ST_TO_ADDR
// if tmp < k then
111890: LD_VAR 0 14
111894: PUSH
111895: LD_VAR 0 9
111899: LESS
111900: IFFALSE 111912
// k := tmp ;
111902: LD_ADDR_VAR 0 9
111906: PUSH
111907: LD_VAR 0 14
111911: ST_TO_ADDR
// for j = k downto 1 do
111912: LD_ADDR_VAR 0 8
111916: PUSH
111917: DOUBLE
111918: LD_VAR 0 9
111922: INC
111923: ST_TO_ADDR
111924: LD_INT 1
111926: PUSH
111927: FOR_DOWNTO
111928: IFFALSE 112003
// begin if GetType ( tmp [ j ] ) = unit_human then
111930: LD_VAR 0 14
111934: PUSH
111935: LD_VAR 0 8
111939: ARRAY
111940: PPUSH
111941: CALL_OW 247
111945: PUSH
111946: LD_INT 1
111948: EQUAL
111949: IFFALSE 112001
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
111951: LD_VAR 0 4
111955: PUSH
111956: LD_VAR 0 7
111960: ARRAY
111961: PPUSH
111962: LD_VAR 0 14
111966: PUSH
111967: LD_VAR 0 8
111971: ARRAY
111972: PPUSH
111973: CALL 48806 0 2
// x := tmp [ j ] ;
111977: LD_ADDR_VAR 0 10
111981: PUSH
111982: LD_VAR 0 14
111986: PUSH
111987: LD_VAR 0 8
111991: ARRAY
111992: ST_TO_ADDR
// attacking := true ;
111993: LD_ADDR_VAR 0 29
111997: PUSH
111998: LD_INT 1
112000: ST_TO_ADDR
// end ; end ;
112001: GO 111927
112003: POP
112004: POP
// if not x then
112005: LD_VAR 0 10
112009: NOT
112010: IFFALSE 112150
// begin attacking := true ;
112012: LD_ADDR_VAR 0 29
112016: PUSH
112017: LD_INT 1
112019: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
112020: LD_VAR 0 4
112024: PUSH
112025: LD_VAR 0 7
112029: ARRAY
112030: PPUSH
112031: CALL_OW 250
112035: PPUSH
112036: LD_VAR 0 4
112040: PUSH
112041: LD_VAR 0 7
112045: ARRAY
112046: PPUSH
112047: CALL_OW 251
112051: PPUSH
112052: CALL_OW 546
112056: PUSH
112057: LD_INT 2
112059: ARRAY
112060: PUSH
112061: LD_VAR 0 14
112065: PUSH
112066: LD_INT 1
112068: ARRAY
112069: PPUSH
112070: CALL_OW 250
112074: PPUSH
112075: LD_VAR 0 14
112079: PUSH
112080: LD_INT 1
112082: ARRAY
112083: PPUSH
112084: CALL_OW 251
112088: PPUSH
112089: CALL_OW 546
112093: PUSH
112094: LD_INT 2
112096: ARRAY
112097: EQUAL
112098: IFFALSE 112126
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
112100: LD_VAR 0 4
112104: PUSH
112105: LD_VAR 0 7
112109: ARRAY
112110: PPUSH
112111: LD_VAR 0 14
112115: PUSH
112116: LD_INT 1
112118: ARRAY
112119: PPUSH
112120: CALL 48806 0 2
112124: GO 112150
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112126: LD_VAR 0 4
112130: PUSH
112131: LD_VAR 0 7
112135: ARRAY
112136: PPUSH
112137: LD_VAR 0 14
112141: PUSH
112142: LD_INT 1
112144: ARRAY
112145: PPUSH
112146: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
112150: LD_VAR 0 4
112154: PUSH
112155: LD_VAR 0 7
112159: ARRAY
112160: PPUSH
112161: CALL_OW 264
112165: PUSH
112166: LD_INT 29
112168: EQUAL
112169: IFFALSE 112535
// begin if WantsToAttack ( group [ i ] ) in bombed then
112171: LD_VAR 0 4
112175: PUSH
112176: LD_VAR 0 7
112180: ARRAY
112181: PPUSH
112182: CALL_OW 319
112186: PUSH
112187: LD_VAR 0 28
112191: IN
112192: IFFALSE 112196
// continue ;
112194: GO 109200
// k := 8 ;
112196: LD_ADDR_VAR 0 9
112200: PUSH
112201: LD_INT 8
112203: ST_TO_ADDR
// x := 0 ;
112204: LD_ADDR_VAR 0 10
112208: PUSH
112209: LD_INT 0
112211: ST_TO_ADDR
// if tmp < k then
112212: LD_VAR 0 14
112216: PUSH
112217: LD_VAR 0 9
112221: LESS
112222: IFFALSE 112234
// k := tmp ;
112224: LD_ADDR_VAR 0 9
112228: PUSH
112229: LD_VAR 0 14
112233: ST_TO_ADDR
// for j = 1 to k do
112234: LD_ADDR_VAR 0 8
112238: PUSH
112239: DOUBLE
112240: LD_INT 1
112242: DEC
112243: ST_TO_ADDR
112244: LD_VAR 0 9
112248: PUSH
112249: FOR_TO
112250: IFFALSE 112382
// begin if GetType ( tmp [ j ] ) = unit_building then
112252: LD_VAR 0 14
112256: PUSH
112257: LD_VAR 0 8
112261: ARRAY
112262: PPUSH
112263: CALL_OW 247
112267: PUSH
112268: LD_INT 3
112270: EQUAL
112271: IFFALSE 112380
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
112273: LD_VAR 0 14
112277: PUSH
112278: LD_VAR 0 8
112282: ARRAY
112283: PUSH
112284: LD_VAR 0 28
112288: IN
112289: NOT
112290: PUSH
112291: LD_VAR 0 14
112295: PUSH
112296: LD_VAR 0 8
112300: ARRAY
112301: PPUSH
112302: CALL_OW 313
112306: AND
112307: IFFALSE 112380
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112309: LD_VAR 0 4
112313: PUSH
112314: LD_VAR 0 7
112318: ARRAY
112319: PPUSH
112320: LD_VAR 0 14
112324: PUSH
112325: LD_VAR 0 8
112329: ARRAY
112330: PPUSH
112331: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
112335: LD_ADDR_VAR 0 28
112339: PUSH
112340: LD_VAR 0 28
112344: PPUSH
112345: LD_VAR 0 28
112349: PUSH
112350: LD_INT 1
112352: PLUS
112353: PPUSH
112354: LD_VAR 0 14
112358: PUSH
112359: LD_VAR 0 8
112363: ARRAY
112364: PPUSH
112365: CALL_OW 1
112369: ST_TO_ADDR
// attacking := true ;
112370: LD_ADDR_VAR 0 29
112374: PUSH
112375: LD_INT 1
112377: ST_TO_ADDR
// break ;
112378: GO 112382
// end ; end ;
112380: GO 112249
112382: POP
112383: POP
// if not attacking and f_attack_depot then
112384: LD_VAR 0 29
112388: NOT
112389: PUSH
112390: LD_VAR 0 25
112394: AND
112395: IFFALSE 112490
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
112397: LD_ADDR_VAR 0 13
112401: PUSH
112402: LD_VAR 0 14
112406: PPUSH
112407: LD_INT 2
112409: PUSH
112410: LD_INT 30
112412: PUSH
112413: LD_INT 0
112415: PUSH
112416: EMPTY
112417: LIST
112418: LIST
112419: PUSH
112420: LD_INT 30
112422: PUSH
112423: LD_INT 1
112425: PUSH
112426: EMPTY
112427: LIST
112428: LIST
112429: PUSH
112430: EMPTY
112431: LIST
112432: LIST
112433: LIST
112434: PPUSH
112435: CALL_OW 72
112439: ST_TO_ADDR
// if z then
112440: LD_VAR 0 13
112444: IFFALSE 112490
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
112446: LD_VAR 0 4
112450: PUSH
112451: LD_VAR 0 7
112455: ARRAY
112456: PPUSH
112457: LD_VAR 0 13
112461: PPUSH
112462: LD_VAR 0 4
112466: PUSH
112467: LD_VAR 0 7
112471: ARRAY
112472: PPUSH
112473: CALL_OW 74
112477: PPUSH
112478: CALL_OW 115
// attacking := true ;
112482: LD_ADDR_VAR 0 29
112486: PUSH
112487: LD_INT 1
112489: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
112490: LD_VAR 0 4
112494: PUSH
112495: LD_VAR 0 7
112499: ARRAY
112500: PPUSH
112501: CALL_OW 256
112505: PUSH
112506: LD_INT 500
112508: LESS
112509: IFFALSE 112535
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112511: LD_VAR 0 4
112515: PUSH
112516: LD_VAR 0 7
112520: ARRAY
112521: PPUSH
112522: LD_VAR 0 14
112526: PUSH
112527: LD_INT 1
112529: ARRAY
112530: PPUSH
112531: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
112535: LD_VAR 0 4
112539: PUSH
112540: LD_VAR 0 7
112544: ARRAY
112545: PPUSH
112546: CALL_OW 264
112550: PUSH
112551: LD_INT 49
112553: EQUAL
112554: IFFALSE 112675
// begin if not HasTask ( group [ i ] ) then
112556: LD_VAR 0 4
112560: PUSH
112561: LD_VAR 0 7
112565: ARRAY
112566: PPUSH
112567: CALL_OW 314
112571: NOT
112572: IFFALSE 112675
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
112574: LD_ADDR_VAR 0 9
112578: PUSH
112579: LD_INT 81
112581: PUSH
112582: LD_VAR 0 4
112586: PUSH
112587: LD_VAR 0 7
112591: ARRAY
112592: PPUSH
112593: CALL_OW 255
112597: PUSH
112598: EMPTY
112599: LIST
112600: LIST
112601: PPUSH
112602: CALL_OW 69
112606: PPUSH
112607: LD_VAR 0 4
112611: PUSH
112612: LD_VAR 0 7
112616: ARRAY
112617: PPUSH
112618: CALL_OW 74
112622: ST_TO_ADDR
// if k then
112623: LD_VAR 0 9
112627: IFFALSE 112675
// if GetDistUnits ( group [ i ] , k ) > 10 then
112629: LD_VAR 0 4
112633: PUSH
112634: LD_VAR 0 7
112638: ARRAY
112639: PPUSH
112640: LD_VAR 0 9
112644: PPUSH
112645: CALL_OW 296
112649: PUSH
112650: LD_INT 10
112652: GREATER
112653: IFFALSE 112675
// ComMoveUnit ( group [ i ] , k ) ;
112655: LD_VAR 0 4
112659: PUSH
112660: LD_VAR 0 7
112664: ARRAY
112665: PPUSH
112666: LD_VAR 0 9
112670: PPUSH
112671: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
112675: LD_VAR 0 4
112679: PUSH
112680: LD_VAR 0 7
112684: ARRAY
112685: PPUSH
112686: CALL_OW 256
112690: PUSH
112691: LD_INT 250
112693: LESS
112694: PUSH
112695: LD_VAR 0 4
112699: PUSH
112700: LD_VAR 0 7
112704: ARRAY
112705: PUSH
112706: LD_INT 21
112708: PUSH
112709: LD_INT 2
112711: PUSH
112712: EMPTY
112713: LIST
112714: LIST
112715: PUSH
112716: LD_INT 23
112718: PUSH
112719: LD_INT 2
112721: PUSH
112722: EMPTY
112723: LIST
112724: LIST
112725: PUSH
112726: EMPTY
112727: LIST
112728: LIST
112729: PPUSH
112730: CALL_OW 69
112734: IN
112735: AND
112736: IFFALSE 112861
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
112738: LD_ADDR_VAR 0 9
112742: PUSH
112743: LD_OWVAR 3
112747: PUSH
112748: LD_VAR 0 4
112752: PUSH
112753: LD_VAR 0 7
112757: ARRAY
112758: DIFF
112759: PPUSH
112760: LD_VAR 0 4
112764: PUSH
112765: LD_VAR 0 7
112769: ARRAY
112770: PPUSH
112771: CALL_OW 74
112775: ST_TO_ADDR
// if not k then
112776: LD_VAR 0 9
112780: NOT
112781: IFFALSE 112785
// continue ;
112783: GO 109200
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
112785: LD_VAR 0 9
112789: PUSH
112790: LD_INT 81
112792: PUSH
112793: LD_VAR 0 4
112797: PUSH
112798: LD_VAR 0 7
112802: ARRAY
112803: PPUSH
112804: CALL_OW 255
112808: PUSH
112809: EMPTY
112810: LIST
112811: LIST
112812: PPUSH
112813: CALL_OW 69
112817: IN
112818: PUSH
112819: LD_VAR 0 9
112823: PPUSH
112824: LD_VAR 0 4
112828: PUSH
112829: LD_VAR 0 7
112833: ARRAY
112834: PPUSH
112835: CALL_OW 296
112839: PUSH
112840: LD_INT 5
112842: LESS
112843: AND
112844: IFFALSE 112861
// ComAutodestruct ( group [ i ] ) ;
112846: LD_VAR 0 4
112850: PUSH
112851: LD_VAR 0 7
112855: ARRAY
112856: PPUSH
112857: CALL 48704 0 1
// end ; if f_attack_depot then
112861: LD_VAR 0 25
112865: IFFALSE 112977
// begin k := 6 ;
112867: LD_ADDR_VAR 0 9
112871: PUSH
112872: LD_INT 6
112874: ST_TO_ADDR
// if tmp < k then
112875: LD_VAR 0 14
112879: PUSH
112880: LD_VAR 0 9
112884: LESS
112885: IFFALSE 112897
// k := tmp ;
112887: LD_ADDR_VAR 0 9
112891: PUSH
112892: LD_VAR 0 14
112896: ST_TO_ADDR
// for j = 1 to k do
112897: LD_ADDR_VAR 0 8
112901: PUSH
112902: DOUBLE
112903: LD_INT 1
112905: DEC
112906: ST_TO_ADDR
112907: LD_VAR 0 9
112911: PUSH
112912: FOR_TO
112913: IFFALSE 112975
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
112915: LD_VAR 0 8
112919: PPUSH
112920: CALL_OW 266
112924: PUSH
112925: LD_INT 0
112927: PUSH
112928: LD_INT 1
112930: PUSH
112931: EMPTY
112932: LIST
112933: LIST
112934: IN
112935: IFFALSE 112973
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112937: LD_VAR 0 4
112941: PUSH
112942: LD_VAR 0 7
112946: ARRAY
112947: PPUSH
112948: LD_VAR 0 14
112952: PUSH
112953: LD_VAR 0 8
112957: ARRAY
112958: PPUSH
112959: CALL_OW 115
// attacking := true ;
112963: LD_ADDR_VAR 0 29
112967: PUSH
112968: LD_INT 1
112970: ST_TO_ADDR
// break ;
112971: GO 112975
// end ;
112973: GO 112912
112975: POP
112976: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
112977: LD_VAR 0 4
112981: PUSH
112982: LD_VAR 0 7
112986: ARRAY
112987: PPUSH
112988: CALL_OW 302
112992: PUSH
112993: LD_VAR 0 29
112997: NOT
112998: AND
112999: IFFALSE 113321
// begin if GetTag ( group [ i ] ) = 71 then
113001: LD_VAR 0 4
113005: PUSH
113006: LD_VAR 0 7
113010: ARRAY
113011: PPUSH
113012: CALL_OW 110
113016: PUSH
113017: LD_INT 71
113019: EQUAL
113020: IFFALSE 113061
// begin if HasTask ( group [ i ] ) then
113022: LD_VAR 0 4
113026: PUSH
113027: LD_VAR 0 7
113031: ARRAY
113032: PPUSH
113033: CALL_OW 314
113037: IFFALSE 113043
// continue else
113039: GO 109200
113041: GO 113061
// SetTag ( group [ i ] , 0 ) ;
113043: LD_VAR 0 4
113047: PUSH
113048: LD_VAR 0 7
113052: ARRAY
113053: PPUSH
113054: LD_INT 0
113056: PPUSH
113057: CALL_OW 109
// end ; k := 8 ;
113061: LD_ADDR_VAR 0 9
113065: PUSH
113066: LD_INT 8
113068: ST_TO_ADDR
// x := 0 ;
113069: LD_ADDR_VAR 0 10
113073: PUSH
113074: LD_INT 0
113076: ST_TO_ADDR
// if tmp < k then
113077: LD_VAR 0 14
113081: PUSH
113082: LD_VAR 0 9
113086: LESS
113087: IFFALSE 113099
// k := tmp ;
113089: LD_ADDR_VAR 0 9
113093: PUSH
113094: LD_VAR 0 14
113098: ST_TO_ADDR
// for j = 1 to k do
113099: LD_ADDR_VAR 0 8
113103: PUSH
113104: DOUBLE
113105: LD_INT 1
113107: DEC
113108: ST_TO_ADDR
113109: LD_VAR 0 9
113113: PUSH
113114: FOR_TO
113115: IFFALSE 113213
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
113117: LD_VAR 0 14
113121: PUSH
113122: LD_VAR 0 8
113126: ARRAY
113127: PPUSH
113128: CALL_OW 247
113132: PUSH
113133: LD_INT 1
113135: EQUAL
113136: PUSH
113137: LD_VAR 0 14
113141: PUSH
113142: LD_VAR 0 8
113146: ARRAY
113147: PPUSH
113148: CALL_OW 256
113152: PUSH
113153: LD_INT 250
113155: LESS
113156: PUSH
113157: LD_VAR 0 20
113161: AND
113162: PUSH
113163: LD_VAR 0 20
113167: NOT
113168: PUSH
113169: LD_VAR 0 14
113173: PUSH
113174: LD_VAR 0 8
113178: ARRAY
113179: PPUSH
113180: CALL_OW 256
113184: PUSH
113185: LD_INT 250
113187: GREATEREQUAL
113188: AND
113189: OR
113190: AND
113191: IFFALSE 113211
// begin x := tmp [ j ] ;
113193: LD_ADDR_VAR 0 10
113197: PUSH
113198: LD_VAR 0 14
113202: PUSH
113203: LD_VAR 0 8
113207: ARRAY
113208: ST_TO_ADDR
// break ;
113209: GO 113213
// end ;
113211: GO 113114
113213: POP
113214: POP
// if x then
113215: LD_VAR 0 10
113219: IFFALSE 113243
// ComAttackUnit ( group [ i ] , x ) else
113221: LD_VAR 0 4
113225: PUSH
113226: LD_VAR 0 7
113230: ARRAY
113231: PPUSH
113232: LD_VAR 0 10
113236: PPUSH
113237: CALL_OW 115
113241: GO 113267
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113243: LD_VAR 0 4
113247: PUSH
113248: LD_VAR 0 7
113252: ARRAY
113253: PPUSH
113254: LD_VAR 0 14
113258: PUSH
113259: LD_INT 1
113261: ARRAY
113262: PPUSH
113263: CALL_OW 115
// if not HasTask ( group [ i ] ) then
113267: LD_VAR 0 4
113271: PUSH
113272: LD_VAR 0 7
113276: ARRAY
113277: PPUSH
113278: CALL_OW 314
113282: NOT
113283: IFFALSE 113321
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
113285: LD_VAR 0 4
113289: PUSH
113290: LD_VAR 0 7
113294: ARRAY
113295: PPUSH
113296: LD_VAR 0 14
113300: PPUSH
113301: LD_VAR 0 4
113305: PUSH
113306: LD_VAR 0 7
113310: ARRAY
113311: PPUSH
113312: CALL_OW 74
113316: PPUSH
113317: CALL_OW 115
// end ; end ; end ;
113321: GO 109200
113323: POP
113324: POP
// wait ( 0 0$2 ) ;
113325: LD_INT 70
113327: PPUSH
113328: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
113332: LD_VAR 0 4
113336: NOT
113337: PUSH
113338: LD_VAR 0 4
113342: PUSH
113343: EMPTY
113344: EQUAL
113345: OR
113346: PUSH
113347: LD_INT 81
113349: PUSH
113350: LD_VAR 0 35
113354: PUSH
113355: EMPTY
113356: LIST
113357: LIST
113358: PPUSH
113359: CALL_OW 69
113363: NOT
113364: OR
113365: IFFALSE 109185
// end ;
113367: LD_VAR 0 2
113371: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
113372: LD_INT 0
113374: PPUSH
113375: PPUSH
113376: PPUSH
113377: PPUSH
113378: PPUSH
113379: PPUSH
// if not base or not mc_bases [ base ] or not solds then
113380: LD_VAR 0 1
113384: NOT
113385: PUSH
113386: LD_EXP 61
113390: PUSH
113391: LD_VAR 0 1
113395: ARRAY
113396: NOT
113397: OR
113398: PUSH
113399: LD_VAR 0 2
113403: NOT
113404: OR
113405: IFFALSE 113409
// exit ;
113407: GO 113963
// side := mc_sides [ base ] ;
113409: LD_ADDR_VAR 0 6
113413: PUSH
113414: LD_EXP 87
113418: PUSH
113419: LD_VAR 0 1
113423: ARRAY
113424: ST_TO_ADDR
// if not side then
113425: LD_VAR 0 6
113429: NOT
113430: IFFALSE 113434
// exit ;
113432: GO 113963
// for i in solds do
113434: LD_ADDR_VAR 0 7
113438: PUSH
113439: LD_VAR 0 2
113443: PUSH
113444: FOR_IN
113445: IFFALSE 113506
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
113447: LD_VAR 0 7
113451: PPUSH
113452: CALL_OW 310
113456: PPUSH
113457: CALL_OW 266
113461: PUSH
113462: LD_INT 32
113464: PUSH
113465: LD_INT 31
113467: PUSH
113468: EMPTY
113469: LIST
113470: LIST
113471: IN
113472: IFFALSE 113492
// solds := solds diff i else
113474: LD_ADDR_VAR 0 2
113478: PUSH
113479: LD_VAR 0 2
113483: PUSH
113484: LD_VAR 0 7
113488: DIFF
113489: ST_TO_ADDR
113490: GO 113504
// SetTag ( i , 18 ) ;
113492: LD_VAR 0 7
113496: PPUSH
113497: LD_INT 18
113499: PPUSH
113500: CALL_OW 109
113504: GO 113444
113506: POP
113507: POP
// if not solds then
113508: LD_VAR 0 2
113512: NOT
113513: IFFALSE 113517
// exit ;
113515: GO 113963
// repeat wait ( 0 0$2 ) ;
113517: LD_INT 70
113519: PPUSH
113520: CALL_OW 67
// enemy := mc_scan [ base ] ;
113524: LD_ADDR_VAR 0 4
113528: PUSH
113529: LD_EXP 84
113533: PUSH
113534: LD_VAR 0 1
113538: ARRAY
113539: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113540: LD_EXP 61
113544: PUSH
113545: LD_VAR 0 1
113549: ARRAY
113550: NOT
113551: PUSH
113552: LD_EXP 61
113556: PUSH
113557: LD_VAR 0 1
113561: ARRAY
113562: PUSH
113563: EMPTY
113564: EQUAL
113565: OR
113566: IFFALSE 113603
// begin for i in solds do
113568: LD_ADDR_VAR 0 7
113572: PUSH
113573: LD_VAR 0 2
113577: PUSH
113578: FOR_IN
113579: IFFALSE 113592
// ComStop ( i ) ;
113581: LD_VAR 0 7
113585: PPUSH
113586: CALL_OW 141
113590: GO 113578
113592: POP
113593: POP
// solds := [ ] ;
113594: LD_ADDR_VAR 0 2
113598: PUSH
113599: EMPTY
113600: ST_TO_ADDR
// exit ;
113601: GO 113963
// end ; for i in solds do
113603: LD_ADDR_VAR 0 7
113607: PUSH
113608: LD_VAR 0 2
113612: PUSH
113613: FOR_IN
113614: IFFALSE 113935
// begin if IsInUnit ( i ) then
113616: LD_VAR 0 7
113620: PPUSH
113621: CALL_OW 310
113625: IFFALSE 113636
// ComExitBuilding ( i ) ;
113627: LD_VAR 0 7
113631: PPUSH
113632: CALL_OW 122
// if GetLives ( i ) > 500 then
113636: LD_VAR 0 7
113640: PPUSH
113641: CALL_OW 256
113645: PUSH
113646: LD_INT 500
113648: GREATER
113649: IFFALSE 113702
// begin e := NearestUnitToUnit ( enemy , i ) ;
113651: LD_ADDR_VAR 0 5
113655: PUSH
113656: LD_VAR 0 4
113660: PPUSH
113661: LD_VAR 0 7
113665: PPUSH
113666: CALL_OW 74
113670: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
113671: LD_VAR 0 7
113675: PPUSH
113676: LD_VAR 0 5
113680: PPUSH
113681: CALL_OW 250
113685: PPUSH
113686: LD_VAR 0 5
113690: PPUSH
113691: CALL_OW 251
113695: PPUSH
113696: CALL_OW 114
// end else
113700: GO 113933
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
113702: LD_VAR 0 7
113706: PPUSH
113707: LD_EXP 61
113711: PUSH
113712: LD_VAR 0 1
113716: ARRAY
113717: PPUSH
113718: LD_INT 2
113720: PUSH
113721: LD_INT 30
113723: PUSH
113724: LD_INT 0
113726: PUSH
113727: EMPTY
113728: LIST
113729: LIST
113730: PUSH
113731: LD_INT 30
113733: PUSH
113734: LD_INT 1
113736: PUSH
113737: EMPTY
113738: LIST
113739: LIST
113740: PUSH
113741: LD_INT 30
113743: PUSH
113744: LD_INT 6
113746: PUSH
113747: EMPTY
113748: LIST
113749: LIST
113750: PUSH
113751: EMPTY
113752: LIST
113753: LIST
113754: LIST
113755: LIST
113756: PPUSH
113757: CALL_OW 72
113761: PPUSH
113762: LD_VAR 0 7
113766: PPUSH
113767: CALL_OW 74
113771: PPUSH
113772: CALL_OW 296
113776: PUSH
113777: LD_INT 10
113779: GREATER
113780: IFFALSE 113933
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
113782: LD_ADDR_VAR 0 8
113786: PUSH
113787: LD_EXP 61
113791: PUSH
113792: LD_VAR 0 1
113796: ARRAY
113797: PPUSH
113798: LD_INT 2
113800: PUSH
113801: LD_INT 30
113803: PUSH
113804: LD_INT 0
113806: PUSH
113807: EMPTY
113808: LIST
113809: LIST
113810: PUSH
113811: LD_INT 30
113813: PUSH
113814: LD_INT 1
113816: PUSH
113817: EMPTY
113818: LIST
113819: LIST
113820: PUSH
113821: LD_INT 30
113823: PUSH
113824: LD_INT 6
113826: PUSH
113827: EMPTY
113828: LIST
113829: LIST
113830: PUSH
113831: EMPTY
113832: LIST
113833: LIST
113834: LIST
113835: LIST
113836: PPUSH
113837: CALL_OW 72
113841: PPUSH
113842: LD_VAR 0 7
113846: PPUSH
113847: CALL_OW 74
113851: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
113852: LD_VAR 0 7
113856: PPUSH
113857: LD_VAR 0 8
113861: PPUSH
113862: CALL_OW 250
113866: PPUSH
113867: LD_INT 3
113869: PPUSH
113870: LD_INT 5
113872: PPUSH
113873: CALL_OW 272
113877: PPUSH
113878: LD_VAR 0 8
113882: PPUSH
113883: CALL_OW 251
113887: PPUSH
113888: LD_INT 3
113890: PPUSH
113891: LD_INT 5
113893: PPUSH
113894: CALL_OW 273
113898: PPUSH
113899: CALL_OW 111
// SetTag ( i , 0 ) ;
113903: LD_VAR 0 7
113907: PPUSH
113908: LD_INT 0
113910: PPUSH
113911: CALL_OW 109
// solds := solds diff i ;
113915: LD_ADDR_VAR 0 2
113919: PUSH
113920: LD_VAR 0 2
113924: PUSH
113925: LD_VAR 0 7
113929: DIFF
113930: ST_TO_ADDR
// continue ;
113931: GO 113613
// end ; end ;
113933: GO 113613
113935: POP
113936: POP
// until not solds or not enemy ;
113937: LD_VAR 0 2
113941: NOT
113942: PUSH
113943: LD_VAR 0 4
113947: NOT
113948: OR
113949: IFFALSE 113517
// MC_Reset ( base , 18 ) ;
113951: LD_VAR 0 1
113955: PPUSH
113956: LD_INT 18
113958: PPUSH
113959: CALL 61594 0 2
// end ;
113963: LD_VAR 0 3
113967: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
113968: LD_INT 0
113970: PPUSH
113971: PPUSH
113972: PPUSH
113973: PPUSH
113974: PPUSH
113975: PPUSH
113976: PPUSH
113977: PPUSH
113978: PPUSH
113979: PPUSH
113980: PPUSH
113981: PPUSH
113982: PPUSH
113983: PPUSH
113984: PPUSH
113985: PPUSH
113986: PPUSH
113987: PPUSH
113988: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
113989: LD_ADDR_VAR 0 12
113993: PUSH
113994: LD_EXP 61
113998: PUSH
113999: LD_VAR 0 1
114003: ARRAY
114004: PPUSH
114005: LD_INT 25
114007: PUSH
114008: LD_INT 3
114010: PUSH
114011: EMPTY
114012: LIST
114013: LIST
114014: PPUSH
114015: CALL_OW 72
114019: ST_TO_ADDR
// if mc_remote_driver [ base ] then
114020: LD_EXP 101
114024: PUSH
114025: LD_VAR 0 1
114029: ARRAY
114030: IFFALSE 114054
// mechs := mechs diff mc_remote_driver [ base ] ;
114032: LD_ADDR_VAR 0 12
114036: PUSH
114037: LD_VAR 0 12
114041: PUSH
114042: LD_EXP 101
114046: PUSH
114047: LD_VAR 0 1
114051: ARRAY
114052: DIFF
114053: ST_TO_ADDR
// for i in mechs do
114054: LD_ADDR_VAR 0 4
114058: PUSH
114059: LD_VAR 0 12
114063: PUSH
114064: FOR_IN
114065: IFFALSE 114100
// if GetTag ( i ) > 0 then
114067: LD_VAR 0 4
114071: PPUSH
114072: CALL_OW 110
114076: PUSH
114077: LD_INT 0
114079: GREATER
114080: IFFALSE 114098
// mechs := mechs diff i ;
114082: LD_ADDR_VAR 0 12
114086: PUSH
114087: LD_VAR 0 12
114091: PUSH
114092: LD_VAR 0 4
114096: DIFF
114097: ST_TO_ADDR
114098: GO 114064
114100: POP
114101: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114102: LD_ADDR_VAR 0 8
114106: PUSH
114107: LD_EXP 61
114111: PUSH
114112: LD_VAR 0 1
114116: ARRAY
114117: PPUSH
114118: LD_INT 2
114120: PUSH
114121: LD_INT 25
114123: PUSH
114124: LD_INT 1
114126: PUSH
114127: EMPTY
114128: LIST
114129: LIST
114130: PUSH
114131: LD_INT 25
114133: PUSH
114134: LD_INT 5
114136: PUSH
114137: EMPTY
114138: LIST
114139: LIST
114140: PUSH
114141: LD_INT 25
114143: PUSH
114144: LD_INT 8
114146: PUSH
114147: EMPTY
114148: LIST
114149: LIST
114150: PUSH
114151: LD_INT 25
114153: PUSH
114154: LD_INT 9
114156: PUSH
114157: EMPTY
114158: LIST
114159: LIST
114160: PUSH
114161: EMPTY
114162: LIST
114163: LIST
114164: LIST
114165: LIST
114166: LIST
114167: PPUSH
114168: CALL_OW 72
114172: ST_TO_ADDR
// if not defenders and not solds then
114173: LD_VAR 0 2
114177: NOT
114178: PUSH
114179: LD_VAR 0 8
114183: NOT
114184: AND
114185: IFFALSE 114189
// exit ;
114187: GO 115959
// depot_under_attack := false ;
114189: LD_ADDR_VAR 0 16
114193: PUSH
114194: LD_INT 0
114196: ST_TO_ADDR
// sold_defenders := [ ] ;
114197: LD_ADDR_VAR 0 17
114201: PUSH
114202: EMPTY
114203: ST_TO_ADDR
// if mechs then
114204: LD_VAR 0 12
114208: IFFALSE 114361
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
114210: LD_ADDR_VAR 0 4
114214: PUSH
114215: LD_VAR 0 2
114219: PPUSH
114220: LD_INT 21
114222: PUSH
114223: LD_INT 2
114225: PUSH
114226: EMPTY
114227: LIST
114228: LIST
114229: PPUSH
114230: CALL_OW 72
114234: PUSH
114235: FOR_IN
114236: IFFALSE 114359
// begin if GetTag ( i ) <> 20 then
114238: LD_VAR 0 4
114242: PPUSH
114243: CALL_OW 110
114247: PUSH
114248: LD_INT 20
114250: NONEQUAL
114251: IFFALSE 114265
// SetTag ( i , 20 ) ;
114253: LD_VAR 0 4
114257: PPUSH
114258: LD_INT 20
114260: PPUSH
114261: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
114265: LD_VAR 0 4
114269: PPUSH
114270: CALL_OW 263
114274: PUSH
114275: LD_INT 1
114277: EQUAL
114278: PUSH
114279: LD_VAR 0 4
114283: PPUSH
114284: CALL_OW 311
114288: NOT
114289: AND
114290: IFFALSE 114357
// begin un := mechs [ 1 ] ;
114292: LD_ADDR_VAR 0 10
114296: PUSH
114297: LD_VAR 0 12
114301: PUSH
114302: LD_INT 1
114304: ARRAY
114305: ST_TO_ADDR
// ComExit ( un ) ;
114306: LD_VAR 0 10
114310: PPUSH
114311: CALL 53601 0 1
// AddComEnterUnit ( un , i ) ;
114315: LD_VAR 0 10
114319: PPUSH
114320: LD_VAR 0 4
114324: PPUSH
114325: CALL_OW 180
// SetTag ( un , 19 ) ;
114329: LD_VAR 0 10
114333: PPUSH
114334: LD_INT 19
114336: PPUSH
114337: CALL_OW 109
// mechs := mechs diff un ;
114341: LD_ADDR_VAR 0 12
114345: PUSH
114346: LD_VAR 0 12
114350: PUSH
114351: LD_VAR 0 10
114355: DIFF
114356: ST_TO_ADDR
// end ; end ;
114357: GO 114235
114359: POP
114360: POP
// if solds then
114361: LD_VAR 0 8
114365: IFFALSE 114424
// for i in solds do
114367: LD_ADDR_VAR 0 4
114371: PUSH
114372: LD_VAR 0 8
114376: PUSH
114377: FOR_IN
114378: IFFALSE 114422
// if not GetTag ( i ) then
114380: LD_VAR 0 4
114384: PPUSH
114385: CALL_OW 110
114389: NOT
114390: IFFALSE 114420
// begin defenders := defenders union i ;
114392: LD_ADDR_VAR 0 2
114396: PUSH
114397: LD_VAR 0 2
114401: PUSH
114402: LD_VAR 0 4
114406: UNION
114407: ST_TO_ADDR
// SetTag ( i , 18 ) ;
114408: LD_VAR 0 4
114412: PPUSH
114413: LD_INT 18
114415: PPUSH
114416: CALL_OW 109
// end ;
114420: GO 114377
114422: POP
114423: POP
// repeat wait ( 0 0$2 ) ;
114424: LD_INT 70
114426: PPUSH
114427: CALL_OW 67
// enemy := mc_scan [ base ] ;
114431: LD_ADDR_VAR 0 21
114435: PUSH
114436: LD_EXP 84
114440: PUSH
114441: LD_VAR 0 1
114445: ARRAY
114446: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114447: LD_EXP 61
114451: PUSH
114452: LD_VAR 0 1
114456: ARRAY
114457: NOT
114458: PUSH
114459: LD_EXP 61
114463: PUSH
114464: LD_VAR 0 1
114468: ARRAY
114469: PUSH
114470: EMPTY
114471: EQUAL
114472: OR
114473: IFFALSE 114510
// begin for i in defenders do
114475: LD_ADDR_VAR 0 4
114479: PUSH
114480: LD_VAR 0 2
114484: PUSH
114485: FOR_IN
114486: IFFALSE 114499
// ComStop ( i ) ;
114488: LD_VAR 0 4
114492: PPUSH
114493: CALL_OW 141
114497: GO 114485
114499: POP
114500: POP
// defenders := [ ] ;
114501: LD_ADDR_VAR 0 2
114505: PUSH
114506: EMPTY
114507: ST_TO_ADDR
// exit ;
114508: GO 115959
// end ; for i in defenders do
114510: LD_ADDR_VAR 0 4
114514: PUSH
114515: LD_VAR 0 2
114519: PUSH
114520: FOR_IN
114521: IFFALSE 115419
// begin e := NearestUnitToUnit ( enemy , i ) ;
114523: LD_ADDR_VAR 0 13
114527: PUSH
114528: LD_VAR 0 21
114532: PPUSH
114533: LD_VAR 0 4
114537: PPUSH
114538: CALL_OW 74
114542: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114543: LD_ADDR_VAR 0 7
114547: PUSH
114548: LD_EXP 61
114552: PUSH
114553: LD_VAR 0 1
114557: ARRAY
114558: PPUSH
114559: LD_INT 2
114561: PUSH
114562: LD_INT 30
114564: PUSH
114565: LD_INT 0
114567: PUSH
114568: EMPTY
114569: LIST
114570: LIST
114571: PUSH
114572: LD_INT 30
114574: PUSH
114575: LD_INT 1
114577: PUSH
114578: EMPTY
114579: LIST
114580: LIST
114581: PUSH
114582: EMPTY
114583: LIST
114584: LIST
114585: LIST
114586: PPUSH
114587: CALL_OW 72
114591: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
114592: LD_ADDR_VAR 0 16
114596: PUSH
114597: LD_VAR 0 7
114601: NOT
114602: PUSH
114603: LD_VAR 0 7
114607: PPUSH
114608: LD_INT 3
114610: PUSH
114611: LD_INT 24
114613: PUSH
114614: LD_INT 600
114616: PUSH
114617: EMPTY
114618: LIST
114619: LIST
114620: PUSH
114621: EMPTY
114622: LIST
114623: LIST
114624: PPUSH
114625: CALL_OW 72
114629: OR
114630: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
114631: LD_VAR 0 4
114635: PPUSH
114636: CALL_OW 247
114640: PUSH
114641: LD_INT 2
114643: DOUBLE
114644: EQUAL
114645: IFTRUE 114649
114647: GO 115045
114649: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
114650: LD_VAR 0 4
114654: PPUSH
114655: CALL_OW 256
114659: PUSH
114660: LD_INT 1000
114662: EQUAL
114663: PUSH
114664: LD_VAR 0 4
114668: PPUSH
114669: LD_VAR 0 13
114673: PPUSH
114674: CALL_OW 296
114678: PUSH
114679: LD_INT 40
114681: LESS
114682: PUSH
114683: LD_VAR 0 13
114687: PPUSH
114688: LD_EXP 86
114692: PUSH
114693: LD_VAR 0 1
114697: ARRAY
114698: PPUSH
114699: CALL_OW 308
114703: OR
114704: AND
114705: IFFALSE 114827
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
114707: LD_VAR 0 4
114711: PPUSH
114712: CALL_OW 262
114716: PUSH
114717: LD_INT 1
114719: EQUAL
114720: PUSH
114721: LD_VAR 0 4
114725: PPUSH
114726: CALL_OW 261
114730: PUSH
114731: LD_INT 30
114733: LESS
114734: AND
114735: PUSH
114736: LD_VAR 0 7
114740: AND
114741: IFFALSE 114811
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
114743: LD_VAR 0 4
114747: PPUSH
114748: LD_VAR 0 7
114752: PPUSH
114753: LD_VAR 0 4
114757: PPUSH
114758: CALL_OW 74
114762: PPUSH
114763: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
114767: LD_VAR 0 4
114771: PPUSH
114772: LD_VAR 0 7
114776: PPUSH
114777: LD_VAR 0 4
114781: PPUSH
114782: CALL_OW 74
114786: PPUSH
114787: CALL_OW 296
114791: PUSH
114792: LD_INT 6
114794: LESS
114795: IFFALSE 114809
// SetFuel ( i , 100 ) ;
114797: LD_VAR 0 4
114801: PPUSH
114802: LD_INT 100
114804: PPUSH
114805: CALL_OW 240
// end else
114809: GO 114825
// ComAttackUnit ( i , e ) ;
114811: LD_VAR 0 4
114815: PPUSH
114816: LD_VAR 0 13
114820: PPUSH
114821: CALL_OW 115
// end else
114825: GO 114928
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
114827: LD_VAR 0 13
114831: PPUSH
114832: LD_EXP 86
114836: PUSH
114837: LD_VAR 0 1
114841: ARRAY
114842: PPUSH
114843: CALL_OW 308
114847: NOT
114848: PUSH
114849: LD_VAR 0 4
114853: PPUSH
114854: LD_VAR 0 13
114858: PPUSH
114859: CALL_OW 296
114863: PUSH
114864: LD_INT 40
114866: GREATEREQUAL
114867: AND
114868: PUSH
114869: LD_VAR 0 4
114873: PPUSH
114874: CALL_OW 256
114878: PUSH
114879: LD_INT 650
114881: LESSEQUAL
114882: OR
114883: PUSH
114884: LD_VAR 0 4
114888: PPUSH
114889: LD_EXP 85
114893: PUSH
114894: LD_VAR 0 1
114898: ARRAY
114899: PPUSH
114900: CALL_OW 308
114904: NOT
114905: AND
114906: IFFALSE 114928
// ComMoveToArea ( i , mc_parking [ base ] ) ;
114908: LD_VAR 0 4
114912: PPUSH
114913: LD_EXP 85
114917: PUSH
114918: LD_VAR 0 1
114922: ARRAY
114923: PPUSH
114924: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
114928: LD_VAR 0 4
114932: PPUSH
114933: CALL_OW 256
114937: PUSH
114938: LD_INT 1000
114940: LESS
114941: PUSH
114942: LD_VAR 0 4
114946: PPUSH
114947: CALL_OW 263
114951: PUSH
114952: LD_INT 1
114954: EQUAL
114955: AND
114956: PUSH
114957: LD_VAR 0 4
114961: PPUSH
114962: CALL_OW 311
114966: AND
114967: PUSH
114968: LD_VAR 0 4
114972: PPUSH
114973: LD_EXP 85
114977: PUSH
114978: LD_VAR 0 1
114982: ARRAY
114983: PPUSH
114984: CALL_OW 308
114988: AND
114989: IFFALSE 115043
// begin mech := IsDrivenBy ( i ) ;
114991: LD_ADDR_VAR 0 9
114995: PUSH
114996: LD_VAR 0 4
115000: PPUSH
115001: CALL_OW 311
115005: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
115006: LD_VAR 0 9
115010: PPUSH
115011: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
115015: LD_VAR 0 9
115019: PPUSH
115020: LD_VAR 0 4
115024: PPUSH
115025: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
115029: LD_VAR 0 9
115033: PPUSH
115034: LD_VAR 0 4
115038: PPUSH
115039: CALL_OW 180
// end ; end ; unit_human :
115043: GO 115390
115045: LD_INT 1
115047: DOUBLE
115048: EQUAL
115049: IFTRUE 115053
115051: GO 115389
115053: POP
// begin b := IsInUnit ( i ) ;
115054: LD_ADDR_VAR 0 18
115058: PUSH
115059: LD_VAR 0 4
115063: PPUSH
115064: CALL_OW 310
115068: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
115069: LD_ADDR_VAR 0 19
115073: PUSH
115074: LD_VAR 0 18
115078: NOT
115079: PUSH
115080: LD_VAR 0 18
115084: PPUSH
115085: CALL_OW 266
115089: PUSH
115090: LD_INT 32
115092: PUSH
115093: LD_INT 31
115095: PUSH
115096: EMPTY
115097: LIST
115098: LIST
115099: IN
115100: OR
115101: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
115102: LD_VAR 0 18
115106: PPUSH
115107: CALL_OW 266
115111: PUSH
115112: LD_INT 5
115114: EQUAL
115115: PUSH
115116: LD_VAR 0 4
115120: PPUSH
115121: CALL_OW 257
115125: PUSH
115126: LD_INT 1
115128: PUSH
115129: LD_INT 2
115131: PUSH
115132: LD_INT 3
115134: PUSH
115135: LD_INT 4
115137: PUSH
115138: EMPTY
115139: LIST
115140: LIST
115141: LIST
115142: LIST
115143: IN
115144: AND
115145: IFFALSE 115182
// begin class := AllowSpecClass ( i ) ;
115147: LD_ADDR_VAR 0 20
115151: PUSH
115152: LD_VAR 0 4
115156: PPUSH
115157: CALL 17287 0 1
115161: ST_TO_ADDR
// if class then
115162: LD_VAR 0 20
115166: IFFALSE 115182
// ComChangeProfession ( i , class ) ;
115168: LD_VAR 0 4
115172: PPUSH
115173: LD_VAR 0 20
115177: PPUSH
115178: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
115182: LD_VAR 0 16
115186: PUSH
115187: LD_VAR 0 2
115191: PPUSH
115192: LD_INT 21
115194: PUSH
115195: LD_INT 2
115197: PUSH
115198: EMPTY
115199: LIST
115200: LIST
115201: PPUSH
115202: CALL_OW 72
115206: PUSH
115207: LD_INT 1
115209: LESSEQUAL
115210: OR
115211: PUSH
115212: LD_VAR 0 19
115216: AND
115217: PUSH
115218: LD_VAR 0 4
115222: PUSH
115223: LD_VAR 0 17
115227: IN
115228: NOT
115229: AND
115230: IFFALSE 115323
// begin if b then
115232: LD_VAR 0 18
115236: IFFALSE 115285
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
115238: LD_VAR 0 18
115242: PPUSH
115243: LD_VAR 0 21
115247: PPUSH
115248: LD_VAR 0 18
115252: PPUSH
115253: CALL_OW 74
115257: PPUSH
115258: CALL_OW 296
115262: PUSH
115263: LD_INT 10
115265: LESS
115266: PUSH
115267: LD_VAR 0 18
115271: PPUSH
115272: CALL_OW 461
115276: PUSH
115277: LD_INT 7
115279: NONEQUAL
115280: AND
115281: IFFALSE 115285
// continue ;
115283: GO 114520
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
115285: LD_ADDR_VAR 0 17
115289: PUSH
115290: LD_VAR 0 17
115294: PPUSH
115295: LD_VAR 0 17
115299: PUSH
115300: LD_INT 1
115302: PLUS
115303: PPUSH
115304: LD_VAR 0 4
115308: PPUSH
115309: CALL_OW 1
115313: ST_TO_ADDR
// ComExitBuilding ( i ) ;
115314: LD_VAR 0 4
115318: PPUSH
115319: CALL_OW 122
// end ; if sold_defenders then
115323: LD_VAR 0 17
115327: IFFALSE 115387
// if i in sold_defenders then
115329: LD_VAR 0 4
115333: PUSH
115334: LD_VAR 0 17
115338: IN
115339: IFFALSE 115387
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
115341: LD_VAR 0 4
115345: PPUSH
115346: CALL_OW 314
115350: NOT
115351: PUSH
115352: LD_VAR 0 4
115356: PPUSH
115357: LD_VAR 0 13
115361: PPUSH
115362: CALL_OW 296
115366: PUSH
115367: LD_INT 30
115369: LESS
115370: AND
115371: IFFALSE 115387
// ComAttackUnit ( i , e ) ;
115373: LD_VAR 0 4
115377: PPUSH
115378: LD_VAR 0 13
115382: PPUSH
115383: CALL_OW 115
// end ; end ; end ;
115387: GO 115390
115389: POP
// if IsDead ( i ) then
115390: LD_VAR 0 4
115394: PPUSH
115395: CALL_OW 301
115399: IFFALSE 115417
// defenders := defenders diff i ;
115401: LD_ADDR_VAR 0 2
115405: PUSH
115406: LD_VAR 0 2
115410: PUSH
115411: LD_VAR 0 4
115415: DIFF
115416: ST_TO_ADDR
// end ;
115417: GO 114520
115419: POP
115420: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
115421: LD_VAR 0 21
115425: NOT
115426: PUSH
115427: LD_VAR 0 2
115431: NOT
115432: OR
115433: PUSH
115434: LD_EXP 61
115438: PUSH
115439: LD_VAR 0 1
115443: ARRAY
115444: NOT
115445: OR
115446: IFFALSE 114424
// MC_Reset ( base , 18 ) ;
115448: LD_VAR 0 1
115452: PPUSH
115453: LD_INT 18
115455: PPUSH
115456: CALL 61594 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115460: LD_ADDR_VAR 0 2
115464: PUSH
115465: LD_VAR 0 2
115469: PUSH
115470: LD_VAR 0 2
115474: PPUSH
115475: LD_INT 2
115477: PUSH
115478: LD_INT 25
115480: PUSH
115481: LD_INT 1
115483: PUSH
115484: EMPTY
115485: LIST
115486: LIST
115487: PUSH
115488: LD_INT 25
115490: PUSH
115491: LD_INT 5
115493: PUSH
115494: EMPTY
115495: LIST
115496: LIST
115497: PUSH
115498: LD_INT 25
115500: PUSH
115501: LD_INT 8
115503: PUSH
115504: EMPTY
115505: LIST
115506: LIST
115507: PUSH
115508: LD_INT 25
115510: PUSH
115511: LD_INT 9
115513: PUSH
115514: EMPTY
115515: LIST
115516: LIST
115517: PUSH
115518: EMPTY
115519: LIST
115520: LIST
115521: LIST
115522: LIST
115523: LIST
115524: PPUSH
115525: CALL_OW 72
115529: DIFF
115530: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
115531: LD_VAR 0 21
115535: NOT
115536: PUSH
115537: LD_VAR 0 2
115541: PPUSH
115542: LD_INT 21
115544: PUSH
115545: LD_INT 2
115547: PUSH
115548: EMPTY
115549: LIST
115550: LIST
115551: PPUSH
115552: CALL_OW 72
115556: AND
115557: IFFALSE 115895
// begin tmp := FilterByTag ( defenders , 19 ) ;
115559: LD_ADDR_VAR 0 11
115563: PUSH
115564: LD_VAR 0 2
115568: PPUSH
115569: LD_INT 19
115571: PPUSH
115572: CALL 50772 0 2
115576: ST_TO_ADDR
// if tmp then
115577: LD_VAR 0 11
115581: IFFALSE 115651
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
115583: LD_ADDR_VAR 0 11
115587: PUSH
115588: LD_VAR 0 11
115592: PPUSH
115593: LD_INT 25
115595: PUSH
115596: LD_INT 3
115598: PUSH
115599: EMPTY
115600: LIST
115601: LIST
115602: PPUSH
115603: CALL_OW 72
115607: ST_TO_ADDR
// if tmp then
115608: LD_VAR 0 11
115612: IFFALSE 115651
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
115614: LD_ADDR_EXP 73
115618: PUSH
115619: LD_EXP 73
115623: PPUSH
115624: LD_VAR 0 1
115628: PPUSH
115629: LD_EXP 73
115633: PUSH
115634: LD_VAR 0 1
115638: ARRAY
115639: PUSH
115640: LD_VAR 0 11
115644: UNION
115645: PPUSH
115646: CALL_OW 1
115650: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
115651: LD_VAR 0 1
115655: PPUSH
115656: LD_INT 19
115658: PPUSH
115659: CALL 61594 0 2
// repeat wait ( 0 0$1 ) ;
115663: LD_INT 35
115665: PPUSH
115666: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115670: LD_EXP 61
115674: PUSH
115675: LD_VAR 0 1
115679: ARRAY
115680: NOT
115681: PUSH
115682: LD_EXP 61
115686: PUSH
115687: LD_VAR 0 1
115691: ARRAY
115692: PUSH
115693: EMPTY
115694: EQUAL
115695: OR
115696: IFFALSE 115733
// begin for i in defenders do
115698: LD_ADDR_VAR 0 4
115702: PUSH
115703: LD_VAR 0 2
115707: PUSH
115708: FOR_IN
115709: IFFALSE 115722
// ComStop ( i ) ;
115711: LD_VAR 0 4
115715: PPUSH
115716: CALL_OW 141
115720: GO 115708
115722: POP
115723: POP
// defenders := [ ] ;
115724: LD_ADDR_VAR 0 2
115728: PUSH
115729: EMPTY
115730: ST_TO_ADDR
// exit ;
115731: GO 115959
// end ; for i in defenders do
115733: LD_ADDR_VAR 0 4
115737: PUSH
115738: LD_VAR 0 2
115742: PUSH
115743: FOR_IN
115744: IFFALSE 115833
// begin if not IsInArea ( i , mc_parking [ base ] ) then
115746: LD_VAR 0 4
115750: PPUSH
115751: LD_EXP 85
115755: PUSH
115756: LD_VAR 0 1
115760: ARRAY
115761: PPUSH
115762: CALL_OW 308
115766: NOT
115767: IFFALSE 115791
// ComMoveToArea ( i , mc_parking [ base ] ) else
115769: LD_VAR 0 4
115773: PPUSH
115774: LD_EXP 85
115778: PUSH
115779: LD_VAR 0 1
115783: ARRAY
115784: PPUSH
115785: CALL_OW 113
115789: GO 115831
// if GetControl ( i ) = control_manual then
115791: LD_VAR 0 4
115795: PPUSH
115796: CALL_OW 263
115800: PUSH
115801: LD_INT 1
115803: EQUAL
115804: IFFALSE 115831
// if IsDrivenBy ( i ) then
115806: LD_VAR 0 4
115810: PPUSH
115811: CALL_OW 311
115815: IFFALSE 115831
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
115817: LD_VAR 0 4
115821: PPUSH
115822: CALL_OW 311
115826: PPUSH
115827: CALL_OW 121
// end ;
115831: GO 115743
115833: POP
115834: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
115835: LD_VAR 0 2
115839: PPUSH
115840: LD_INT 95
115842: PUSH
115843: LD_EXP 85
115847: PUSH
115848: LD_VAR 0 1
115852: ARRAY
115853: PUSH
115854: EMPTY
115855: LIST
115856: LIST
115857: PPUSH
115858: CALL_OW 72
115862: PUSH
115863: LD_VAR 0 2
115867: EQUAL
115868: PUSH
115869: LD_EXP 84
115873: PUSH
115874: LD_VAR 0 1
115878: ARRAY
115879: OR
115880: PUSH
115881: LD_EXP 61
115885: PUSH
115886: LD_VAR 0 1
115890: ARRAY
115891: NOT
115892: OR
115893: IFFALSE 115663
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
115895: LD_ADDR_EXP 83
115899: PUSH
115900: LD_EXP 83
115904: PPUSH
115905: LD_VAR 0 1
115909: PPUSH
115910: LD_VAR 0 2
115914: PPUSH
115915: LD_INT 21
115917: PUSH
115918: LD_INT 2
115920: PUSH
115921: EMPTY
115922: LIST
115923: LIST
115924: PPUSH
115925: CALL_OW 72
115929: PPUSH
115930: CALL_OW 1
115934: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
115935: LD_VAR 0 1
115939: PPUSH
115940: LD_INT 19
115942: PPUSH
115943: CALL 61594 0 2
// MC_Reset ( base , 20 ) ;
115947: LD_VAR 0 1
115951: PPUSH
115952: LD_INT 20
115954: PPUSH
115955: CALL 61594 0 2
// end ; end_of_file
115959: LD_VAR 0 3
115963: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
115964: LD_VAR 0 1
115968: PUSH
115969: LD_INT 200
115971: DOUBLE
115972: GREATEREQUAL
115973: IFFALSE 115981
115975: LD_INT 299
115977: DOUBLE
115978: LESSEQUAL
115979: IFTRUE 115983
115981: GO 116015
115983: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
115984: LD_VAR 0 1
115988: PPUSH
115989: LD_VAR 0 2
115993: PPUSH
115994: LD_VAR 0 3
115998: PPUSH
115999: LD_VAR 0 4
116003: PPUSH
116004: LD_VAR 0 5
116008: PPUSH
116009: CALL 104311 0 5
116013: GO 116092
116015: LD_INT 300
116017: DOUBLE
116018: GREATEREQUAL
116019: IFFALSE 116027
116021: LD_INT 399
116023: DOUBLE
116024: LESSEQUAL
116025: IFTRUE 116029
116027: GO 116091
116029: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
116030: LD_VAR 0 1
116034: PPUSH
116035: LD_VAR 0 2
116039: PPUSH
116040: LD_VAR 0 3
116044: PPUSH
116045: LD_VAR 0 4
116049: PPUSH
116050: LD_VAR 0 5
116054: PPUSH
116055: LD_VAR 0 6
116059: PPUSH
116060: LD_VAR 0 7
116064: PPUSH
116065: LD_VAR 0 8
116069: PPUSH
116070: LD_VAR 0 9
116074: PPUSH
116075: LD_VAR 0 10
116079: PPUSH
116080: LD_VAR 0 11
116084: PPUSH
116085: CALL 100636 0 11
116089: GO 116092
116091: POP
// end ;
116092: PPOPN 11
116094: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
116095: LD_VAR 0 1
116099: PPUSH
116100: LD_VAR 0 2
116104: PPUSH
116105: LD_VAR 0 3
116109: PPUSH
116110: LD_VAR 0 4
116114: PPUSH
116115: LD_VAR 0 5
116119: PPUSH
116120: CALL 104047 0 5
// end ; end_of_file
116124: PPOPN 5
116126: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
116127: LD_VAR 0 1
116131: PPUSH
116132: LD_VAR 0 2
116136: PPUSH
116137: LD_VAR 0 3
116141: PPUSH
116142: LD_VAR 0 4
116146: PPUSH
116147: LD_VAR 0 5
116151: PPUSH
116152: LD_VAR 0 6
116156: PPUSH
116157: CALL 88288 0 6
// end ;
116161: PPOPN 6
116163: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
116164: LD_INT 0
116166: PPUSH
// begin if not units then
116167: LD_VAR 0 1
116171: NOT
116172: IFFALSE 116176
// exit ;
116174: GO 116176
// end ;
116176: PPOPN 7
116178: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
116179: CALL 88192 0 0
// end ;
116183: PPOPN 1
116185: END
